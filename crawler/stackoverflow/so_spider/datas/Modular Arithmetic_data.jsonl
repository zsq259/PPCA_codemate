{"Question": "Modular Arithmetic in R\r\n                \r\nI'm quite new to R and I've been wondering if there is a way to perform modular arithmetic, either in base R or any package, I have not found anything/thought of anything so far.\n\nIf it is not clear what i mean by modular arithmetic, i mean something like, if you have set/module like c(1,2,3,4,5), if you add 7 to 1, you would end up with a two, so it sorta wraps around. I've been coping with the lack of this kind of operation by using  ```\nif```\n  statements, adding special conditions for numbers that go above the max number un a module/set, but right now i'm in the need of performing actual modular arithmetic.\n\nI hope this isn't a too much of a open ended question.\n\nThanks in advance!\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic proofs in agda\r\n                \r\nI'm trying to prove ```\n(n : ℕ) → ∃[ m ] n * n ≡ 3 * m + 2 → ⊥```\n. Typically I would prove this by rewriting it in terms of congruence, and then splitting on each case. There doesn't seem to be a modular arithmetic module in agda-stdlib. How should I implement modular arithmetic or approach this kind of problem without modular arithmetic?\nEdit: there has been discussion in the comments that is not quite precise enough to lead me to an answer, so in the hopes of clarifying what cannot fit in the word count I am dumping my various attempts at this problem, some of which inspired by things in the comments.\n```\nopen Data.Nat.Divisibility.Core\nopen Data.Nat.Base\nopen Relation.Binary.Core\nopen Level using (0ℓ)\nopen Relation.Binary.PropositionalEquality\nopen Data.Empty\nopen Relation.Nullary\nopen Data.Product using (Σ; _,_; ∃; Σ-syntax; ∃-syntax)\nopen Relation.Binary.PropositionalEquality.≡-Reasoning\nopen Data.Nat.Solver\nopen +-*-Solver\n\ndata Z/3 : (n : ℕ) → Set where\n  Z/3₀ : (n : ℕ) → ∃[ m ] n ≡ 3 * m → Z/3 n\n  Z/3₁ : (n : ℕ) → ∃[ m ] n ≡ 3 * m + 1 → Z/3 n\n  Z/3₂ : (n : ℕ) → ∃[ m ] n ≡ 3 * m + 2 → Z/3 n\n\ndata _≋_ : Rel ℕ 0ℓ where\n  3∣|a-b| : ∀ {a b : ℕ} → 3 ∣ ∣ a - b ∣ → a ≋ b\n\nq' : {a : ℕ} → (2 ≋ ((a + 3) * (a + 3))) → (∃[ a' ] 2 ≋ (a' * a'))\nq' = {!!}\n\nqq : (n : ℕ) → Z/3 (n * n)\nqq zero = Z/3₀ zero (zero , refl)\nqq (suc zero) = Z/3₁ 1 (zero , refl)\nqq (suc (suc zero)) = Z/3₁ 4 (1 , refl)\nqq (suc (suc (suc n))) = Z/3₁ ((3 + n) * (3 + n)) ({!!} , {!!})\n\nq'' : (n : ℕ) → ∃[ m ] n * n ≡ 3 * m + 2 → ⊥\nq'' zero (zero , ())\nq'' zero (suc fst , ())\nq'' (suc zero) (suc zero , ())\nq'' (suc zero) (suc (suc fst) , ())\nq'' (suc (suc zero)) (suc (suc (suc (suc zero))) , ())\nq'' (suc (suc zero)) (suc (suc (suc (suc (suc fst)))) , ())\nq'' (suc (suc (suc n))) (suc fst , snd) = q'' n ({!!} , {!!})\n\nsq : {a : ℕ} → Z/3 a →  Z/3 (a * a)\nsq (Z/3₀ n (m , p)) = Z/3₀ (n * n) (3 * m * m , q) where\n  q =\n    begin\n      n * n\n    ≡⟨ cong (λ e → e * n) p ⟩\n      (3 * m) * n\n    ≡⟨ cong (λ e → (3 * m) * e) p ⟩\n      (3 * m) * (3 * m)\n    ≡⟨ solve 1 (λ m' → (con 3 :* m') :* (con 3 :* m') := con 3 :* m' :* m' :+ (con 3 :* m' :* m' :+ (con 3 :* m' :* m' :+ con zero))) refl m ⟩\n      3 * m * m + (3 * m * m + (3 * m * m + zero))\n    ∎\n    -- (3 * b + 1) * (3 * b + 1)\n    -- 9b^2 + 6b + 1\n    -- 3(3b^2 + 2b) +1\n    -- (3 * b + 2) * (3 * b + 2)\n    -- 9b^2 + 12b + 4\n    -- 3(3b^2+4b+1) + 1\nsq (Z/3₁ n (m , p)) = Z/3₁ (n * n) (3 * m * m + 2 * m , q) where\n  q =\n    begin\n      n * n\n    ≡⟨ cong (λ e → e * n) p ⟩\n      (3 * m + 1) * n\n    ≡⟨ cong (λ e → (3 * m + 1) * e) p ⟩\n      (3 * m + 1) * (3 * m + 1)\n    ≡⟨ solve 1 (λ m' → (con 3 :* m' :+ con 1) :* (con 3 :* m' :+ con 1) := (m' :+ (m' :+ (m' :+ con 0))) :* m' :+ (m' :+ (m' :+ con 0)) :+ ((m' :+ (m' :+ (m' :+ con 0))) :* m' :+ (m' :+ (m' :+ con 0)) :+ ((m' :+ (m' :+ (m' :+ con 0))) :* m' :+ (m' :+ (m' :+ con 0)) :+ con 0)) :+ con 1 ) refl m ⟩\n      (m + (m + (m + 0))) * m + (m + (m + 0)) + ((m + (m + (m + 0))) * m + (m + (m + 0)) + ((m + (m + (m + 0))) * m + (m + (m + 0)) + 0)) + 1\n    ∎\nsq (Z/3₂ n (m , p)) = Z/3₁ (n * n) (3 * m * m + 4 * m + 1 , {!!})\n\nq : {a : ℕ} → ¬(2 ≋ (a * a))\nq {zero} (3∣|a-b| (divides zero ()))\nq {zero} (3∣|a-b| (divides (suc quotient) ()))\nq {suc zero} (3∣|a-b| (divides zero ()))\nq {suc zero} (3∣|a-b| (divides (suc quotient) ()))\nq {suc (suc zero)} (3∣|a-b| (divides zero ()))\nq {suc (suc zero)} (3∣|a-b| (divides (suc quotient) ()))\nq {suc (suc (suc a))} (3∣|a-b| (divides (suc quotient) equality)) = {!!}\n```\n\n    ", "Answer": "\r\nBuilding on Mark's proof outline:\n```\nmodule SOMod where\n\nopen import Data.Empty\nopen import Data.Nat\nopen import Data.Nat.Properties\nopen import Data.Nat.DivMod\nopen import Data.Product\nopen import Relation.Binary.PropositionalEquality\nopen import Relation.Nullary.Negation\n\nopen ≡-Reasoning\n\nlemma : ∀ m n → (n * n) % 3 ≢ (3 * m + 2) % 3\nlemma m n p = contradiction ≡2 (≢2 n)\n  where\n  ≡2 : ((n % 3) * (n % 3)) % 3 ≡ 2\n  ≡2 = begin\n    ((n % 3) * (n % 3)) % 3 ≡˘⟨ %-distribˡ-* n n 3 ⟩\n    (n * n) % 3             ≡⟨ p ⟩\n    (3 * m + 2) % 3         ≡⟨ cong (_% 3) (+-comm (3 * m) 2) ⟩\n    (2 + 3 * m) % 3         ≡⟨ cong (λ # → (2 + #) % 3) (*-comm 3 m) ⟩\n    (2 + m * 3) % 3         ≡⟨ [m+kn]%n≡m%n 2 m 3 ⟩\n    2 % 3                   ≡⟨⟩\n    2                       ∎\n\n  ≢2 : ∀ n → ((n % 3) * (n % 3)) % 3 ≢ 2\n  ≢2 zero                = λ ()\n  ≢2 (suc zero)          = λ ()\n  ≢2 (suc (suc zero))    = λ ()\n  ≢2 (suc (suc (suc n))) = ≢2 n\n\nproof : ∀ n → ∃[ m ] n * n ≡ 3 * m + 2 → ⊥\nproof n (m , p) = contradiction (cong (_% 3) p) (lemma m n)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetic in programming [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nCan anyone explain me how modular arithmetic works in programming? I know it is used to operate on large values. \n\nFor example, to calculate the binomial coefficient of B(1000000, 2) using int data-type. i assume we couldn't multiply using int data-type, since it involves calculating factorials of big values like 1000000! which has millions of digits, which don't fit in an 32-bit or 64-bit integer. \n\nI know modular arithmetic is used to these type of problems, But i don't understand exactly how that works.\n    ", "Answer": "\r\nThe modulo operation is a simple operation that calculates the remainder of a division.\nFor instance \n```\n5 % 3 = 2```\n as dividing 5 by 3 will give you a a remainder of .\n\nA common usecase for this is checking whether a number is even or odd.\n```\nnumber % 2 == 0```\n means the number is even.\n\nFor more information please check Wikipedia.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic\r\n                \r\nI'm new to cryptography and modular arithmetic. So, I'm sure it's a silly question, but I can't help it. \n\nHow do I calculate a from \n     pow(a,q) = 1 (mod p), \nwhere p and q are known? I don't get the \"1 (mod p)\" part, it equals to 1, doesn't it? If so, than what is \"mod p\" about? \nIs this the same as \n     pow(a,-q) (mod p) = 1?\n    ", "Answer": "\r\nThe (mod p) part refers not to the right hand side, but to the equality sign: it says that modulo p, pow(a,q) and 1 are equal. For instance, \"modulo 10, 246126 and 7868726 are equal\" (and they are also both equal to 6 modulo 10): two numbers x and y are equal modulo p if they have the same remainder on dividing by p, or equivalently, if p divides x-y. \n\nSince you seem to be coming from a programming perspective, another way of saying it is that pow(a,q)%p=1, where \"%\" is the \"remainder\" operator as implemented in several languages (assuming that p>1).\n\nYou should read the Wikipedia article on Modular arithmetic, or any elementary number theory book (or even a cryptography book, since it is likely to introduce modular arithmetic).\n\nTo answer your other question: there is no general formula for finding such an a (to the best of my knowledge) in general. Assuming that p is prime, and using Fermat's little theorem to reduce q modulo p-1, and assuming that q divides p-1 (or else no such a exists), you can produce such an a by taking a primitive root of p and raising it to the power (p-1)/q. [And more generally, when p is not prime, you can reduce q modulo φ(p), then assuming it divides φ(p) and you know a primitive root (say r) mod p, you can take r to the power of φ(p)/q, where φ is the totient function -- this comes from Euler's theorem.]\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetic in Haskell\r\n                \r\nHow would I go about making a function so that ```\nx```\n has a range of values from ```\nx=0```\n to ```\nx=19```\n and if the ```\nx```\n value exceeds 19 or is below zero how can I get it to wrap around\n\nFrom:\n```\nx=20, x=21, x=22```\n and ```\nx=(-1), x=(-2), x=(-3)```\n\n\nTo:\n```\nx=0, x=1, x=2```\n and ```\nx=19, x=18, x=17```\n respectively?\n\nI've heard of modular arithmetic which is apparently the way I should deal with it.\n    ", "Answer": "\r\nUsually you would use the built-in functions ```\nmod```\n and ```\nrem```\n, but I assume they are off-limits for homework. So you can write your own function, e.g.\n\n```\nmod20 x | x < 0 = ...\n        | x > 19 = ...\n        | otherwise = x\n```\n\n\nThere are different things you can try to fill in the ```\n...```\ns. One of the easiest is repeated addition or subtraction, but I don't want to spoil all the fun.\n\nOnce you have this function, you can \"rescale\" the values after every \"normal\" arithmetic operation, e.g. ```\nmod20 (12 + 17)```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "modular arithmetic on the gpu\r\n                \r\nI am working on the GPU algorithm which is supposed to do a lot of modular computations. Particularly, various operations on matrices in a finite field which in the long run\nreduce to primitive operations like: (a*b - c*d) mod m or (a*b + c) mod m where a,b,c and d are residues modulo m and m is a 32-bit prime. \n\nThrough experimentation I learned that the performance of the algorithm is mostly limited by slow modular arithmetic because integer modulo (%) and division operations are not supported on the GPU in hardware.\n\nI appreciate if somebody can give me an idea how to realize efficient modular computations with CUDA ?\n\nTo see how this is implemented on CUDA, I use the following code snippet:\n\n```\n__global__ void mod_kernel(unsigned *gout, const unsigned *gin) {\n\nunsigned tid = threadIdx.x;\nunsigned a = gin[tid], b = gin[tid * 2], m = gin[tid * 3];\n\ntypedef unsigned long long u64;\n\n__syncthreads();\nunsigned r = (unsigned)(((u64)a * (u64)b) % m);\n__syncthreads();\ngout[tid] = r;\n}\n```\n\n\nThis code is not supposed to work, I just wanted to see how modular reduction is\nimplemented on CUDA. \n\nWhen I disassemble this with cuobjdump --dump-sass (thanks njuffa for advice!), I see the following:\n\n```\n/*0098*/     /*0xffffdc0450ee0000*/     BAR.RED.POPC RZ, RZ;\n/*00a0*/     /*0x1c315c4350000000*/     IMUL.U32.U32.HI R5, R3, R7;\n/*00a8*/     /*0x1c311c0350000000*/     IMUL.U32.U32 R4, R3, R7;\n/*00b0*/     /*0xfc01dde428000000*/     MOV R7, RZ;\n/*00b8*/     /*0xe001000750000000*/     CAL 0xf8;\n/*00c0*/     /*0x00000007d0000000*/     BPT.DRAIN 0x0;\n/*00c8*/     /*0xffffdc0450ee0000*/     BAR.RED.POPC RZ, RZ;\n```\n\n\nNote that between the two calls to bar.red.popc there is a call to 0xf8 procedure which implements some sophisticated algorithm (about 50 instructions or even more). Not surpising that mod (%) operation is slow\n    ", "Answer": "\r\nSome time ago I experimented a lot with modular arithmetic on the GPU. On Fermi GPUs you can use double-precision arithmetic to avoid expensive div and mod operations. For example, modular multiplication can be done as follows:\n\n```\n// fast truncation of double-precision to integers\n#define CUMP_D2I_TRUNC (double)(3ll << 51)\n// computes r = a + b subop c unsigned using extended precision\n#define VADDx(r, a, b, c, subop) \\\n    asm volatile(\"vadd.u32.u32.u32.\" subop \" %0, %1, %2, %3;\" :  \\\n            \"=r\"(r) : \"r\"(a) , \"r\"(b), \"r\"(c));\n\n// computes a * b mod m; invk = (double)(1<<30) / m\n__device__ __forceinline__ \nunsigned mul_m(unsigned a, unsigned b, volatile unsigned m,\n    volatile double invk) { \n\n   unsigned hi = __umulhi(a*2, b*2); // 3 flops\n   // 2 double instructions\n   double rf = __uint2double_rn(hi) * invk + CUMP_D2I_TRUNC;\n   unsigned r = (unsigned)__double2loint(rf);\n   r = a * b - r * m; // 2 flops\n\n   // can also be replaced by: VADDx(r, r, m, r, \"min\") // == umin(r, r + m);\n   if((int)r < 0) \n      r += m;\n   return r;\n}\n```\n\n\nHowever this only works for 31-bit integer modulos (if 1 bit is not critical for you)\nand you also need to precompute 'invk' beforehand. This gives absolute minimum of instructions I can achieve, ie.:\n\n```\nSHL.W R2, R4, 0x1;\nSHL.W R8, R6, 0x1;\nIMUL.U32.U32 R4, R4, R6;\nIMUL.U32.U32.HI R8, R2, R8;\nI2F.F64.U32 R8, R8;\nDFMA R2, R2, R8, R10;\nIMAD.U32.U32 R4, -R12, R2, R4;\nISETP.GE.AND P0, pt, R4, RZ, pt;\n@!P0 IADD R4, R12, R4;\n```\n\n\nFor description of the algorithm, you can have a look at my paper:\ngpu_resultants. Other operations like (xy - zw) mod m are also explained there.\n\nOut of curiosity, I compared the performance of the resultant algorithm \nusing your modular multiplication:\n\n```\nunsigned r = (unsigned)(((u64)a * (u64)b) % m);\n```\n\n\nagainst the optimized version with mul_m.\n\nModular arithmetic with default % operation:\n\n```\nlow_deg: 11; high_deg: 2481; bits: 10227\nnmods: 330; n_real_pts: 2482; npts: 2495\n\nres time: 5755.357910 ms; mod_inv time: 0.907008 ms; interp time: 856.015015 ms; CRA time: 44.065857 ms\nGPU time elapsed: 6659.405273 ms; \n```\n\n\nModular arithmetic with mul_m:\n\n```\nlow_deg: 11; high_deg: 2481; bits: 10227\nnmods: 330; n_real_pts: 2482; npts: 2495\n\nres time: 1100.124756 ms; mod_inv time: 0.192608 ms; interp time: 220.615143 ms; CRA time: 10.376352 ms\nGPU time elapsed: 1334.742310 ms; \n```\n\n\nSo on the average it is about 5x faster. Note also that, you might not see a speed-up if you just evaluate raw arithmetic performance using a kernel with a bunch of mul_mod operations (like saxpy example). But in real applications with control logic, synchronization barriers etc. the speed-up is very noticeable.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Javacard big numbers and modular arithmetic\r\n                \r\nI am new in the Javacard ecosystem and I was wondering what's the consensus regarding (modular) computations with big numbers in Javacard.\n\nMore specifically, I am looking for a lib which supports modular exponentiation and in general modular arithmetic operations between big numbers.\n\nI am aware of BigNumber and ds.ov2.bignat. However, the first one does not provide methods for modular arithmetic.\n\nds.ov2.bignat seems to be more relevant, but I wasn't sure if it is common prctice to use bignat or there is another more popular lib.\n\nThanks!emphasized text\n    ", "Answer": "\r\nThe consensus is kind of not to perform modular exponentiation. ```\nbignat```\n seems to rely on RSA ops for modular arithmetic. Nowadays this should probably be replaced by DH calculations.\n\nBut in general, JC is not really the platform to create your own cryptography. Some platform have vendor specific extensions for users to implement their own cryptography.\n\nSmart cards however rely on many protections against side channel attacks. You'd need a very good understanding about cryptography to implement anything for use \"in the field\".\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Specifying modular arithmetic conditions in Z3\r\n                \r\nHow do I specify a modular artithmetic condition such as\n```\nf1 := (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 1 (mod 5)) ∨ \n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 2 (mod 5)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 3 (mod 5)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 4 (mod 5));\n\nf2 := (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 1 (mod 7)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 2 (mod 7)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 3 (mod 7)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 4 (mod 7)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 5 (mod 7)) ∨\n      (b[0]*2^0 + b[1]*2^1 + b[2]*2^2 + b[3]*2^3 + b[4]*2^4 ≡ 6 (mod 7));\n\nF := f1 ∧ f2;\n```\n\nin Z3 SMT Solver?\nIn the above example\n\n≡ is modular equivalence,\n(mod p) denotes modular arithmetic relative to p,\n\"+\",\"*\" denote modular arithmetic operations addition and multiplication respectively,\n∨ is the logical-or (disjunction) and\n∧ is the logical-and (conjunction)\nb[] is an array of bits i.e., belongs to the set {0,1}\n2^0, 2^1, ...., 2^4 are powers of 2\n\nZ3 C# .NET API preferred. If not, any equivalent Z3 formulation is fine.\n    ", "Answer": "\r\nUsing Z3 .net API\n```\n    internal class Z3Demo : Context\n    {\n        public Z3Demo() :\n            // This example needs model generation turned on.\n            base(new Dictionary<string, string>() { { \"model\", \"true\" } })\n        { \n        }\n        public void Show()\n        {\n            void o(string s) { Console.WriteLine(s); }\n\n            Microsoft.Z3.Global.ToggleWarningMessages(true);\n\n            o($\"Z3 Version: {Microsoft.Z3.Version.FullVersion}\");\n           \n            //  local helper to create int constants\n            IntExpr Int(int val) { return MkInt(val); }\n\n            var b = new BoolExpr[5];\n            for (int i = 0; i < b.Length; i++)\n            {\n                b[i] = MkBoolConst($\"b{i}\");\n            }\n\n            var operands = new IntExpr[5];            \n            for (int i = 0; i < b.Length; i++)\n            {\n                operands[i] = (IntExpr)MkITE(b[i], Int(1 << i), Int(0));\n            }\n\n            var sum = (IntExpr)MkAdd(operands);\n            var sum5 = MkMod(sum, Int(5));\n            var sum7 = MkMod(sum, Int(7));\n            var f1 = MkNot(MkEq(sum5, Int(0)));\n            var f2 = MkNot(MkEq(sum7, Int(0)));\n            var F = MkAnd(f1, f2);\n\n            var solver = MkSolver();\n            solver.Assert(F);\n\n            if (solver.Check() == Status.SATISFIABLE)\n            {\n                o(\"Solution found:\");\n\n                for (int i = 0; i < b.Length; i++)\n                {\n                    o($\"b{i} = {solver.Model.Evaluate(b[i])}\");\n                }\n\n                o(\"\");\n                o($\"{F}\");\n            }\n            else\n            {\n                o(\"No solution found\");\n            }           \n        }\n    }\n```\n\nResulting output\n```\nZ3 Version: Z3 4.12.0.0\nSolution found:\nb0 = true\nb1 = false\nb2 = false\nb3 = false\nb4 = false\n\n(let ((a!1 (+ (ite b0 1 0) (ite b1 2 0) (ite b2 4 0) (ite b3 8 0) (ite b4 16 0))))\n  (and (not (= (mod a!1 5) 0)) (not (= (mod a!1 7) 0))))\n```\n\n\nUsing z3py Z3 Python API\n```\n    from z3 import *\n    \n    #  create array of Boolean decision variables\n    b = [Bool(f'b{i}') for i in range(5)]\n    sum = Sum([b[i] * (2 ** i) for i in range(5)])\n    sum5 = sum % 5\n    sum7 = sum % 7\n    # f1 = Or(sum5 == 1, sum5 == 2, sum5 == 3, sum5 == 4)\n    f1 = (sum5 != 0)\n    # f2 = Or(sum7 == 1, sum7 == 2, sum7 == 3, sum7 == 4, sum7 == 5, sum7 == 6)\n    f2 = (sum7 != 0)\n    F = And(f1, f2)\n    \n    s = Solver()\n    s.add(F)\n    \n    print(s.check())\n    print(s.model())\n    \n    print(s.sexpr)\n```\n\nResulting output\n```\nsat\n[b2 = False, b3 = False, b1 = True, b4 = False, b0 = False]\n<bound method Solver.sexpr of [And((If(b0, 1, 0) +\n      If(b1, 2, 0) +\n      If(b2, 4, 0) +\n      If(b3, 8, 0) +\n      If(b4, 16, 0))%\n     5 !=\n     0,\n     (If(b0, 1, 0) +\n      If(b1, 2, 0) +\n      If(b2, 4, 0) +\n      If(b3, 8, 0) +\n      If(b4, 16, 0))%\n     7 !=\n     0)]>\n```\n\nFor integer rather than Boolean variables, the result is:\n```\nsat\n[b1 = 1, b4 = 0, b0 = 0, b2 = 1, b3 = 0]\n<bound method Solver.sexpr of [And((b0*1 + b1*2 + b2*4 + b3*8 + b4*16)%5 != 0,\n     (b0*1 + b1*2 + b2*4 + b3*8 + b4*16)%7 != 0),\n b0 >= 0,\n b0 <= 1,\n b1 >= 0,\n b1 <= 1,\n b2 >= 0,\n b2 <= 1,\n b3 >= 0,\n b3 <= 1,\n b4 >= 0,\n b4 <= 1]>\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Tensorflow - how to predict modular arithmetic/clock arithmetic (angles)?\r\n                \r\nI'm working on a machine learning project where I'm using TensorFlow (and DNNRegressor). I want to predict a modular arithmetic value (an angle) ranging between -pi and pi. When I try doing it \"the normal way\" the model isn't very good, as it doesn't understand that -pi and pi is actually the same value. \n\nDoes tensorflow have any functionality to make ML models with modular arithmetic?\n    ", "Answer": "\r\nYou should output two values in this case: sin(angle) and cos(angle). Then you can reconstruct the real angle from this (school trigonometry). \nThe loss function can be a sum of RMSEs for each output. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Intel modular arithmetic using AVX or SSE\r\n                \r\nIs it possible to do modular arithmetic on integers with AVX or SSE?  i.e. perform several mods all at once.\n\nBipman\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Non-linear congruence solver (modular arithmetic)\r\n                \r\nIs there an algorithm that can solve a non-linear congruence in modular arithmetic? I read that such a problem is classified as NP-complete.\n\nIn my specific case the congruence is of the form:\n\n```\nx^3 + ax + b congruent to 0 (mod 2^64)\n```\n\n\nwhere a and b are known constants and I need to solve it for x.\n    ", "Answer": "\r\nLook at Hensel's lemma.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "optimizing modular arithmetic computations in C++\r\n                \r\nI am developing some linear algebra code that that is templated on the\nmatrix coefficient type.  One of the possible types is a class to do\nmodular arithmetic, naively implemented as follows:\n\n```\ntemplate<typename val_t> // `val_t` is an integer type\nclass Modular \n{\n  val_t val_;\n  static val_t modulus_;\npublic:\n  Modular(const val_t& value) : val_(value) { };\n  static void global_set_modulus(const val_t& modulus) { modulus_ = modulus; };\n\n  Modular<val_t>& operator=(const Modular<val_t>& other) { val_ = other.val_; return *this; }\n\n  Modular<val_t>& operator+=(const Modular<val_t>& other) { val_ += other.val_; val_ %= modulus_; return *this; }\n  Modular<val_t>& operator-=(const Modular<val_t>& other) { val_ -= other.val_; val_ %= modulus_; return *this; }\n  Modular<val_t>& operator*=(const Modular<val_t>& other) { val_ *= other.val_; val_ %= modulus_; return *this; }\n  Modular<val_t>& operator/=(const Modular<val_t>& other) { val_ *= other.inverse().val_; val_ %= modulus_; return *this; }\n\n  friend Modular<val_t> operator+(const Modular<val_t>& a, const Modular<val_t>& b) { return Modular<val_t>((a.val_ + b.val_) % Modular<val_t>::modulus_); };\n  friend Modular<val_t> operator-(const Modular<val_t>& a, const Modular<val_t>& b) { return Modular<val_t>((a.val_ - b.val_) % Modular<val_t>::modulus_); };\n  // ...etc.\n};\n```\n\n\nHowever, when the program runs with the ```\nModular<int>```\n coefficients, it is several\ntimes slower than when it runs with ```\nint```\n coefficients.  \n\nWhat are the things that I should change in the \"Modular\" class in\norder to gain maximum performance?\n\nFor instance, is it possible to optimize expressions like ```\na*b + c*d```\n\nto ```\n(a.val_*b.val_ + c.val_*d.val_) % modulus```\n, and instead of the obvious:\n\n```\n(((a.val_*b.val_) % modulus) + ((c.val_*d.val_ % modulus) % modulus) % modulus)\n```\n\n    ", "Answer": "\r\nYes.  It is possible.  What you want to look up is \"expression templates\" and start from there.  From that point you're going to have to build some metaprogram logic to optimize/simplify the expression.  Far from a trivial task, but that's not what you asked.\n\nNVM - it's way trivial:\n\n```\nint count = 0;\nint modulus() { count++; return 10; }\n\ntemplate < typename T >\nstruct modular\n{\n  modular(T v) : value_(v) {}\n\n  T value() const { return value_; }\n  void value(T v) { value_ = v; }\n\n  typedef modular<T> modular_type;\n  typedef T raw_type;\nprivate:\n  T value_;\n};\n\ntemplate < typename LH, typename RH >\nstruct multiply\n{\n  multiply(LH l, RH r) : lh(l), rh(r) {}\n\n  typedef typename LH::modular_type modular_type;\n  typedef typename LH::raw_type raw_type;\n\n  raw_type value() const { return lh.value() * rh.value(); }\n\n  operator modular_type () const { return modular_type(value() % modulus()); }\n\nprivate:\n  LH lh; RH rh;\n};\n\ntemplate < typename LH, typename RH >\nstruct add\n{\n  add(LH l, RH r) : lh(l), rh(r) {}\n\n  typedef typename LH::modular_type modular_type;\n  typedef typename LH::raw_type raw_type;\n\n  raw_type value() const { return lh.value() + rh.value(); }\n  operator modular_type () const { return modular_type(value() % modulus()); }\n\nprivate:\n  LH lh; RH rh;\n};\n\ntemplate < typename LH, typename RH >\nadd<LH,RH> operator+(LH const& lh, RH const& rh)\n{\n  return add<LH,RH>(lh,rh);\n}\n\ntemplate < typename LH, typename RH >\nmultiply<LH,RH> operator*(LH const& lh, RH const& rh)\n{\n  return multiply<LH,RH>(lh,rh);\n}\n\n#include <iostream>\n\nint main()\n{\n  modular<int> a = 5;\n  modular<int> b = 7;\n  modular<int> c = 3;\n  modular<int> d = 8;\n\n  std::cout << (5*7+3*8) % 10 << std::endl;\n\n  modular<int> result = a * b + c * d;\n  std::cout << result.value() << std::endl;\n\n  std::cout << count << std::endl;\n\n  std::cin.get();\n}\n```\n\n\nIf you were smart though, you'd put the use of % in the constructor for modular so it's always modular; you'd also put checks in to make sure LH and RH are compatible along with SFINAE crap to keep the operators from killing it for any time at all.  You might also make modulus a template parameter and provide metafunctions to access it.  At any rate...there you go.\n\nEdit: BTW, you can use this same technique to make your matrices calculate faster.  Instead of creating a new matrix for each operation in a string of operations, you make these things and then finally do the math, element by element, when you assign the result.  There's papers on it on the internet and everything, comparing it to FORTRAN and such.  Was one of the first uses of metaprogramming like template use in C++.  Also in the book http://www.amazon.com/Scientific-Engineering-Introduction-Advanced-Techniques/dp/0201533936 <- keep in mind though that \"advanced techniques\" was in 94 :p.  It's not as relevant today.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic AND Eucledian Algorithm\r\n                \r\nI was studying how to find the modular inverse. Suppose the example is:\n27*x is congruent to 1 (mod 392) .\n\nNow we have to find x. In the process we write this Equation as:    \n\nx is congruent to 27^(-1) (mod 392).\n\nHere is my confusion does in modular arithmetic we can simply take 27 from left hand side and move it to right hand side and write it as 1/(27) (mod 392) without considering the 1 (mod 392) present their already and inserting 1/27 in between of 1 and (mod 392). \nBecause 27*x was congruent to 1(mod 392) but now we take x is congruent to 1/27 (mod 392). \n    ", "Answer": "\r\nThis seems confused. If ```\n27x = 1 (mod 392)```\n then by definition x is 27^-1 (mod 392). You don't solve this equation by \"moving\" things from the left hand side to the right hand side. You solve it by using the Extended Euclidean Algorithm to write ```\n27x + 392y = 1```\n in which case x is the inverse you seek since you can rearrange the equation as ```\n392y = 1 - 27x```\n which shows that 27x differs from 1 by a multiple of 392 hence ```\n27x = 1 (mod 392)```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Ceasar Cipher w/ modular arithmetic\r\n                \r\nI have an additive cipher here that brute forces tests all possible permutations of the fixed ciphertext. It functions just fine but I, for the life of me, can't figure out how to implement modular arithmetic and the formula for decryption. p = ((c - key) % 26) where p is the plaintext value and c is the ciphertext in an array of letters (i.e, A = 0, B=1, etc..)\n\nhere is the code \n\n```\npublic class Problem1 {\n\npublic static void main(String[] args) {\n\nString guess = \"\";\n\nString ct = \"UOISCXEWLOBDOX\"; // ciphertext\n    int key;// key to test\n    char ch;\n    for (key = 0; key < 26; key++) { // for each key value\n        for (int i = 0; i < ct.length(); ++i) { // test char\n            ch = ct.charAt(i);\n            if (ch >= 'A' && ch <= 'Z') {\n                ch = (char) (ch - key);\n                if (ch < 'A') {\n                    ch = (char) (ch + 'Z' - 'A' + 1);\n                }\n                guess += ch;\n            } else {\n                guess += ch;\n            }\n        }\n\n        System.out.println(\"key: \" + key + \"     \" + \"Decrypted Message = \" + guess);\n        guess = \"\";\n    }\n}\n\n}// main\n```\n\n\nTHIS IS UPDATED CODE FOR MODULAR ARITHMATIC\n\n```\nimport java.util.*;\nimport java.io.*;\n`public class AdditiveCipher {\n\npublic static void main(String[] args)\n{\n\n    String guess = \"\";\n    //char pt = 'a';\n    String cipherText = \"UOISCXEWLOBDOX\";\n    int key,i,x = 0;\n\n    //array of characters we can use \n    char[] alphabet = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',\n            'P','Q','R','S','T','U','V','W','X','Y','Z'};\n\n    //try each key on the cipher text\n    for(key = 0; key < 26; key++)//for each key\n    {\n        for( i = 0; i < cipherText.length(); i++)//for each letter\n        {\n             int pt = (cipherText.charAt(i) - key - 'A') % 26;\n             guess += (char)pt;\n        }\n        System.out.print(guess + \"\\n\"); //display each guess\n        guess = \"\";\n    }//outer for\n}//end main\n}//end AdditiveCipher.java`\n```\n\n\nThat's my latest attempt after trying for awhile it outputs a ton of boxes. any help with logic would be appreciated, or simply telling my what I'm doing wrong \n    ", "Answer": "\r\nThe implementation for this modulus method of decryption is rather simple, and is done exactly how you have described it in your question. All you have to do is create your array of characters as you described (```\nA = 0, B = 1, ...```\n), and do the conversion ```\np = ((c - key) % 26)```\n for each character to find the original text. At least, this is how it would work in an ideal world. I'm willing to bet the trouble you are having is with the ASCII values of characters. As you can see here, the value ```\n'A'```\n is equal to the integer 65, and the values of the capital letters increase from there. To compensate for this, add 13 (or ```\n'A'```\n, as ```\n'A' % 26 = 13```\n) before performing the modulus division (like so: ```\np = ((c - key + 13) % 26)```\n), and you should be good to go. Just to be clear, p is the location in the character array where the original text value for that character is stored, not the actual integer value of the decrypted character. I hope this helped, and good luck with the implementation!\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic in python to iterate a pandas dataframe\r\n                \r\nOk, I have a big dataframe such as:\n\n```\n      hour    value\n  0      0      1\n  1      6      2\n  2     12      3\n  3     18      4\n  4      0      5\n  5      6      6\n  6     12      7\n  7     18      8\n  8      6      9\n  9     12     10\n 10     18     11\n 11     12     12\n 12     18     13\n 13      0     14\n```\n\n\nLet's don't get lost here. The column ```\nhour```\n represents the hours of the day, from 6 to 6 hours. Column ```\nvalues```\n is well, exactly that, here the values are as an example, not the actual ones.\n\nIf you look closely to the ```\nhour```\n column, you can see that there are hours missing. For instance, there is a gap between rows 7 and 8 (the value of hour 0 is missing). There are also bigger gaps, such as in  between rows 10 and 11 (hours 00 and 06).\n\nWhat do I need? I would like to check when an hour (and of course) a value is missing, and complete the dataframe inserting a row there with the corresponding hour and a ```\nnp.nan```\n as value.\n\nWhat have I thought? I think this would be easily solved using modular arithmetic, in this case with mod 24, such as when ```\n18 + 6 = 24 = 0 mod 24```\n. So initializing the counter to zero and adding 6 with the caveat that the counter is defined in modular arithmetic mod 24 you can verify if each ```\nhour```\n is the corresponding hour, and if not, insert a new row with the corresponding hour and with ```\nnp.nan```\n as value.\n\nI don't know how to do the implementation of modular arithmetic in python to iterate a dataframe column.\n\nThank you very much.\n    ", "Answer": "\r\nSolution\n\n```\ngroup_hours = (df.hour <= df.hour.shift()).cumsum()\n\ndef insert_missing_hours(df):\n    return df.set_index('hour').reindex([0, 6, 12, 18]).reset_index()\n\ndf.groupby(group_hours).apply(insert_missing_hours).reset_index(drop=1)\n```\n\n\nLooks like:\n\n```\n    hour  value\n0      0    1.0\n1      6    2.0\n2     12    3.0\n3     18    4.0\n4      0    5.0\n5      6    6.0\n6     12    7.0\n7     18    8.0\n8      0    NaN\n9      6    9.0\n10    12   10.0\n11    18   11.0\n12     0    NaN\n13     6    NaN\n14    12   12.0\n15    18   13.0\n16     0   14.0\n17     6    NaN\n18    12    NaN\n19    18    NaN\n```\n\n\nExplanation\n\nIn order to apply ```\nreindex```\n I needed to determine which rows to group.  I checked to see if row's hour was less or equal than prior row's hour.  If so, that flags a new group.\n\n```\ninsert_missing_hours```\n is precisely the ```\nreindex```\n of subgroups with ```\n[0, 6, 12, 18]```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Vectorizing Modular Arithmetic\r\n                \r\nI'm trying to write some reasonably fast component-wise vector addition code. I'm working with (signed, I believe) 64-bit integers.\n\nThe function is \n\n```\nvoid addRq (int64_t* a, const int64_t* b, const int32_t dim, const int64_t q) {\n    for(int i = 0; i < dim; i++) {\n        a[i] = (a[i]+b[i])%q; // LINE1\n    }\n}\n```\n\n\nI'm compiling with ```\nicc -std=gnu99 -O3```\n (icc so I can use SVML later) on an IvyBridge (SSE4.2 and AVX, but not AVX2).\n\nMy baseline is removing the ```\n%q```\n from LINE1. 100 (iterated) function calls with ```\ndim=11221184```\n takes 1.6 seconds. ICC auto-vectorizes the code for SSE; great.\n\nI really want to do modular additions though. With the ```\n%q```\n, ICC does not auto-vectorize the code, and it runs in 11.8 seconds(!). Even ignoring the auto-vectorization for the previous attempt, this still seems excessive.\n\nSince I don't have AVX2, vectorization with SSE requires SVML, which is perhaps why ICC didn't auto-vectorize. At any rate, here's my attempt to vectorize the inner loop:\n\n```\n__m128i qs = _mm_set1_epi64x(q);\nfor(int i = 0; i < dim; i+=2) {\n    __m128i xs = _mm_load_si128((const __m128i*)(a+i));\n    __m128i ys = _mm_load_si128((const __m128i*)(b+i));\n    __m128i zs = _mm_add_epi64(xs,ys);\n    zs = _mm_rem_epi64(zs,qs);\n    _mm_store_si128((__m128i*)(a+i),zs);\n}\n```\n\n\nAssembly for the main loop is:\n\n```\n..B3.4:                         # Preds ..B3.2 ..B3.12\n    movdqa    (%r12,%r15,8), %xmm0                          #59.22\n    movdqa    %xmm8, %xmm1                                  #60.14\n    paddq     (%r14,%r15,8), %xmm0                          #59.22\n    call      __svml_i64rem2                                #61.9\n    movdqa    %xmm0, (%r12,%r15,8)                          #61.36\n    addq      $2, %r15                                      #56.30\n    cmpq      %r13, %r15                                    #56.24\n    jl        ..B3.4        # Prob 82%                      #56.24\n```\n\n\nSo the code is getting vectorized as expected. I know I might not get a 2x speedup due to SVML, but the code runs in 12.5 seconds, slower than with no vectorization at all! Is this really the best that can be done here? \n    ", "Answer": "\r\nNeither SSE2 nor AVX2 have integer division instructions. Intel is disingenuous to call the SVML functions intrinsics since many of them are complicated functions which map to several instructions and not just a few.\n\nThere is a way to do faster division (and modulo) with SSE2 or AVX2.  See this paper Improved division by invariant integers.  Basically you precompute a divisor and then do multiplication.  Precomputing the divisor takes time but for some value of ```\ndim```\n in your code it should win out.  I described this method in more detail here SSE integer division?\nI also successfully implemented this method in a prime number finder Finding lists of prime numbers with SIMD - SSE/AVX\n\nAgner Fog implements 32-bit (but not 64-bit) division in his Vector Class using the method described in that paper.  That would be a good place to start if you want some code but you will have to extend it to 64-bit.\n\nEdit: Based on Mysticial's comments and assuming that the inputs are already reduced I produced a version for SSE.  If this is compiled in MSVC then it needs to be in 64 bit mode as 32 bit mode does not support ```\n_mm_set1_epi64x```\n.  This can be fixed for 32 bit mode mode but I don't want to do it.\n\n```\n#ifdef _MSC_VER \n#include <intrin.h>\n#endif\n#include <nmmintrin.h>                 // SSE4.2\n#include <stdint.h>\n#include <stdio.h>\n\nvoid addRq_SSE(int64_t* a, const int64_t* b, const int32_t dim, const int64_t q) {\n    __m128i q2 = _mm_set1_epi64x(q);\n    __m128i t2 = _mm_sub_epi64(q2,_mm_set1_epi64x(1));\n    for(int i = 0; i < dim; i+=2) {\n        __m128i a2 = _mm_loadu_si128((__m128i*)&a[i]);\n        __m128i b2 = _mm_loadu_si128((__m128i*)&b[i]);\n        __m128i c2 = _mm_add_epi64(a2,b2);\n        __m128i cmp = _mm_cmpgt_epi64(c2, t2);\n        c2 = _mm_sub_epi64(c2, _mm_and_si128(q2,cmp));\n        _mm_storeu_si128((__m128i*)&a[i], c2);\n    }\n}\n\nint main() {\n    const int64_t dim = 20;\n    int64_t a[dim];\n    int64_t b[dim];\n    int64_t q = 10;\n\n    for(int i=0; i<dim; i++) {\n        a[i] = i%q; b[i] = i%q;\n    }\n    addRq_SSE(a, b, dim, q);\n    for(int i=0; i<dim; i++) {\n        printf(\"%d\\n\", a[i]);\n    }   \n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetic using Haskell Type-Families or GADTs?\r\n                \r\nI frequently have occasion to perform modular arithmetic in Haskell, where the modulus is usually large and often prime (like 2000000011).  Currently, I just use functions like (modAdd m a b), (modMul m a b), (modDiv m a b) etc.  But that is rather inconvenient, requiring an additional parameter to always be specified and carried around and creating my various functions in both the regular integral form and separately in mod- form.\n\nSo it occurs that it might be a good idea to create a new class something like this:\n\n```\nclass Integral a => Mod a\n\nm = 2000000011\n\ninstance Integral a => Num (Mod a) where\n   ... defining (+), etc. as modulo m\n```\n\n\nThen one could just perform regular arithmetic, using regular functions, and define useful structures like\n\n```\nfactorials :: [Mod Int]\nfactorials = 1:zipWith (*) factorials [1..]\n```\n\n\nBut that has one problem: All values of type Mod Int necessarily must have the same modulus.  However, often I need to work in multiple moduli in one program (of course always only combining values of the same modulus).\n\nI think, but do not understand sufficiently well to be sure, that this could be overcome by something like this:\n\n```\nclass Integral a => Mod Nat a\n```\n\n\nwhere Nat is a type that encodes the modulus in Peano fashion.  This would be advantageous: I could have values of different moduli and the type-checker would save me from accidentally combining this value.\n\nIs something like this feasible and efficient?  Will it cause either the compiler or the RTS to try to actually construct the enormous (Succ (Succ (Succ ... repeated 2000000011 times) if I try to use that modulus, rendering the solution effectively useless?  Will the RTS try to check the type match on every operation?  Will the RTS representation of every value be blown up from what could otherwise be just an unboxed int?\n\nIs there a better way?\n\nCONCLUSION\n\nThanks to helpful comments from cirdec, dfeuer, user5402, and tikhon-jelvis, I learned that (unsurprisingly) I was not the first to have this idea.  In particular, there is a recent paper by Kiselyov and Shan that gives an implementation and tikhon-jelvis has posted to Hackage a solution called (surprise!) modular-arithmetic, that offers even nicer semantics using fancy ghc pragmas.\n\nOPEN QUESTION (TO ME)\n\nWhat happens behind the curtain?  In particular, would a million-element list of [Mod Int 2000000011] carry around an extra million copies of 2000000011 around?  Or does it compile to the same code as a list of a million Int with the modulus parameter carried separately would?  The latter would be nice.\n\nADDENDUM ON PERFORMANCE\n\nI ran a bit of a benchmark on a current problem I am working on.  The first run used an unboxed 10,000-element Int vector and performed 10,000 operations on it:\n\n```\n   4,810,589,520 bytes allocated in the heap\n         107,496 bytes copied during GC\n       1,197,320 bytes maximum residency (1454 sample(s))\n         734,960 bytes maximum slop\n              10 MB total memory in use (0 MB lost due to fragmentation)\n\n                                     Tot time (elapsed)  Avg pause  Max pause\n  Gen  0      6905 colls,     0 par    0.109s   0.101s     0.0000s    0.0006s\n  Gen  1      1454 colls,     0 par    0.812s   0.914s     0.0006s    0.0019s\n\n  TASKS: 13 (1 bound, 12 peak workers (12 total), using -N11)\n\n  SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)\n\n  INIT    time    0.000s  (  0.001s elapsed)\n  MUT     time    2.672s  (  2.597s elapsed)\n  GC      time    0.922s  (  1.015s elapsed)\n  EXIT    time    0.000s  (  0.001s elapsed)\n  Total   time    3.594s  (  3.614s elapsed)\n\n  Alloc rate    1,800,454,557 bytes per MUT second\n\n  Productivity  74.3% of total user, 73.9% of total elapsed\n```\n\n\nFor the second run, I performed the same operations on an unboxed Vector of 10,000 (Mod Int 1000000007).  That made my code a little simpler, but took about 3 times as long (while having nearly identical memory profile):\n\n```\n   4,810,911,824 bytes allocated in the heap\n         107,128 bytes copied during GC\n       1,199,408 bytes maximum residency (1453 sample(s))\n         736,928 bytes maximum slop\n              10 MB total memory in use (0 MB lost due to fragmentation)\n\n                                     Tot time (elapsed)  Avg pause  Max pause\n  Gen  0      6906 colls,     0 par    0.094s   0.107s     0.0000s    0.0007s\n  Gen  1      1453 colls,     0 par    1.516s   1.750s     0.0012s    0.0035s\n\n  TASKS: 13 (1 bound, 12 peak workers (12 total), using -N11)\n\n  SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)\n\n  INIT    time    0.000s  (  0.001s elapsed)\n  MUT     time    8.562s  (  8.323s elapsed)\n  GC      time    1.609s  (  1.857s elapsed)\n  EXIT    time    0.000s  (  0.001s elapsed)\n  Total   time   10.172s  ( 10.183s elapsed)\n\n  Alloc rate    561,858,315 bytes per MUT second\n\n  Productivity  84.2% of total user, 84.1% of total elapsed\n```\n\n\nI wonder why that happens and if it could be fixed.  Still, I really like the modular-arithmetic package and will use it where performance is not absolutely critical.\n    ", "Answer": "\r\nNewer versions of GHC have type-level numbers built in, which should be more efficient than ones you roll yourself using Peano arithmetic. You can use them by enabling ```\nDataKinds```\n. As a bonus, you'd also get some nice syntax:\n\n```\nfactorials :: [Mod Int 20]\n```\n\n\nWhether this is efficient or not depends on how you implement the ```\nMod```\n type. In the most general case, you probably want to just ```\nmod```\n after every arithmetic operation. Unless you're in a hot loop where saving a handful of instructions matters, this should be fine. (And inside the hot loop, it's probably better to be explicit about when you mod anyhow.)\n\nI actually implemented this type in a library on Hackage: ```\nmodular-arithmetic```\n. It has a test suite but no benchmarks so I can't vouch for the absolute performance, but it's not doing anything that should be slow and it was fast enough for my purposes. (Which, admittedly, involved small moduli.) If you try it and run into performance issues, I'd love to hear about them so I can try to fix them.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic on node names in TikZ?\r\n                \r\nSay I want to construct a circulant graph in TikZ, with a variable number of nodes, labelled v0, v1, ..., v_n-1 for some n of my choice (say, 5).\n\nI'd like to be able to use the \\foreach command in TikZ to iteratively (1) define the nodes, and (2) connect the nodes. I'd like to be able to connect v_i to v_(i+1) and v_i to v_{i+2}, say.\n\n```\n\\foreach \\i in {0, ..., 4}\n{\\path (\\i*72:3) node (v\\i) {};}```\n\n\nconstructs the nodes perfectly. But then when I want to draw some lines,\n\n```\n\\foreach \\i \\in {0, ..., 3}\n{ \\draw (v\\i) -- (v{\\i+1}); }```\n ????\n\ndoesn't work. Nor does\n\n```\n\\foreach \\i / \\j in {0/1, ..., 3/4}\n{ \\draw (v\\i) -- (v{\\j}); }```\n\n\nI get an error \"no such shape v0\" or something like that.\n\nI know this must be totally easy to do, but I can't figure out how. Any suggestions?\n\nAs a followup, it would be nice to be able to connect v_i and v_{i+4} or something, with a single ```\n\\foreach```\n command, and have TikZ/pgf do the modular arithmetic for me without having to worry about spilling over.\n    ", "Answer": "\r\nThis worked for me:\n\n```\n\\documentclass{article}\n\\usepackage{tikz}\n\\usetikzlibrary{shapes,fit,arrows,positioning}\n\\tikzstyle{vertex} = [circle, draw, thick, text centered]\n\\tikzstyle{edge} = [draw, thick,->]\n\\begin{document}\n\\begin{tikzpicture}[scale=1]\n  \\foreach \\x in {0,...,6}\n    \\node[vertex] (\\x) at (\\x*360/7:3) {v\\x};\n  \\foreach \\x/\\y in {0/1,1/2,2/3,3/4,4/5,5/6,6/0}\n    \\draw[edge] (\\x) to (\\y);\n\\end{tikzpicture}\n\\end{document}\n```\n\n\n\n\nThe syntax ```\n{0/1,...,5/6}```\n did not work for me. But I admit, I spent a bit of time trying to find a good solution, and I'm still not totally satisfied.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "List based modular arithmetic in excel\r\n                \r\nI am building a file to track my goals when reviewing material. Since the objective is to read one chapter a day, I want to display my progress based upon the start date. Since this is a cyclical review, it requires some form of modular arithmetic to properly account for restarting the list at the end of the previous completion. I can't wrap my head around a straightforward method to do this via excel formulas or VBA programming, and figured the gurus here would be helpful.\n\nSample table:\n\nCurrent day of cycle: XXX\n\nBook  #_of_Chapters\n\nBook A 10\n\nBook B 15\n\nBook C 30\n\nBook D 5\n\nTotal Chapters: 60\n\nToday: Book YYY Chapter ZZZ\n\nExpected result: If XXX is 40, YYY is Book C and ZZZ is Chapter 15 (40-10 for Book A and 15 for Book B). If XXX is 62, YYY is Book A (since we've restarted) and ZZZ is Chapter 2. \n\nI don't currently have the VBA code I started on to add to this post.\n\nThanks!\n    ", "Answer": "\r\nIt's easier if you keep track of how many chapters were in previous books. Here's the CSV of my setup:\n\n\n  Current Day of cycle:,16, ,, Book,Chapters,Prev. Chapters\n  Book A,10,0 Book B,15,10 Book C,30,25 Book D,5,55\n\n\nI used a formula for Prev. Chapters but you don't really have to if your list is really this short.\n\n```\n=SUM($B$4:$B4)-B4\n```\n\n\nNow you have all you need. You can break it into 3 formulas to make it easier to follow: (mine are in the range ```\nE1:E3```\n)\n\n```\n=IF(MOD(B1,60)=0,60,MOD(B1,60))\n=MATCH(E1,C4:C7)\n=\"Book \" & INDEX(A4:A7,E2) & \" Chapter \" & E1-INDEX(C4:C7,E2)\n```\n\n\n... or you can have one big formula:\n\n```\n=\"Book \" & INDEX(A4:A7,MATCH(IF(MOD(B1,60)=0,60,MOD(B1,60)),C4:C7)) & \" Chapter \" & IF(MOD(B1,60)=0,60,MOD(B1,60))-INDEX(C4:C7,MATCH(IF(MOD(B1,60)=0,60,MOD(B1,60)),C4:C7))\n```\n\n\nIf you want just the book name and chapter number, it'd be these:\n\n```\n=INDEX(A4:A7,E2)\n=E1-INDEX(C4:C7,E2)\n```\n\n\n... or as standalones:\n\n```\n=INDEX(A4:A7,MATCH(IF(MOD(B1,60)=0,60,MOD(B1,60)),C4:C7))\n=IF(MOD(B1,60)=0,60,MOD(B1,60))-INDEX(C4:C7,MATCH(IF(MOD(B1,60)=0,60,MOD(B1,60)),C4:C7))\n```\n\n\n\n\nFor your final application, I'd suggest the following:\n\n\nMake the total number of chapters dynamic instead of the hard-coded 60 shown in my examples\nFormat the final output to look like whatever you need\nKeep the formulas separated so you can troubleshoot if something goes crazy. Big formulas give nice results but are hard to fix.\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to find the base value in modular arithmetic?\r\n                \r\nI need an efficient formula of some kind that will allow one to figure out the original message(msg) with regards to the following formula: C = msg^e mod N. If a user is provided with C, e and N, is there an efficient way to calculate msg? In this example, C is the ciphertext, e is the public key and N is a public modulus. \n\nI have done some research on what modular arithmetic is all about and looked over some detailed explanations, however, no articles have shown me how to figure out a problem such as this.\n    ", "Answer": "\r\nModulus is a non-reversible operation.  At best, you know that ```\nmsg ^ e = C + k*N```\n, and need to determine the value of ```\nk```\n.\n\nConsider the following simple case:\n\n```\ne = 2\nN = 10\nmsg =  1 | C = 1  'Note1\nmsg =  2 | C = 4  'Note2\nmsg =  3 | C = 9  'Note3\nmsg =  4 | C = 6  'Note4\nmsg =  5 | C = 5\nmsg =  6 | C = 6  'Note4\nmsg =  7 | C = 9  'Note3\nmsg =  8 | C = 4  'Note2\nmsg =  9 | C = 1  'Note1\nmsg = 10 | C = 0\n```\n\n\n\n\nIt should immediately be obvious that if ```\nC = 6```\n, this could mean that ```\nMsg = 6```\n or that ```\nMsg = 4```\n (Or ```\nMsg = 24```\n, et cetera, ad infinitum) with no way to tell the difference without more information.\n\nHowever, given the same ```\nmsg```\n for different known values of ```\ne```\n and ```\nN```\n, then you can narrow down the possibilities like so:\n\n```\ne = 3\nN = 10\nMsg =  1 | C = 1\nMsg =  2 | C = 8\nMsg =  3 | C = 7\nMsg =  4 | C = 4  'We can now see that this\nMsg =  5 | C = 5\nMsg =  6 | C = 6  'Is different from this\nMsg =  7 | C = 3\nMsg =  8 | C = 2\nMsg =  9 | C = 9\nMsg = 10 | C = 0\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Bash: checking substring increments with modular arithmetic\r\n                \r\nI have a list of files with file names that contain a substring of 6 numbers that represents HHMMSS, HH: 2 digits hour, MM: 2 digits minutes, SS: 2 digits seconds.\nIf the list of files is ordered, the increments should be in steps of 30 minutes, that is, the first substring should be 000000, followed by 003000, 010000, 013000, ..., 233000.\nI want to check that no file is missing iterating the list of files and checking that neither of these substrings is missing. My approach:\n```\nstring_check=000000\nfor file in ${file_list[@]}; do\n  if [[ ${file:22:6} == $string_check ]]; then\n    echo \"Ok\"\n  else\n    echo \"Problem: an hour (file) is missing\"\n    exit 99\n  fi\n  string_check=$((string_check+3000)) #this is the key line\ndone\n```\n\nAnd the previous to the last line is the key. It should be formatted to 6 digits, I know how to do that, but I want to add time like a clock, or, in more specific words, modular arithmetic modulo 60. How can that be done?\n    ", "Answer": "\r\nAssumptions:\n\nall 6-digit strings are of the format ```\nxx[03]0000```\n (ie, has to be an even ```\n00```\n or ```\n30```\n minutes and no seconds)\nif there are strings like ```\nxx1529```\n ... these will be ignored (see 2nd half of answer - use of ```\ncomm```\n - to address OP's comment about these types of strings being an error)\n\nInstead of trying to do a bunch of ```\nmod 60```\n math for the ```\nMM```\n (minutes) portion of the string, we can use a sequence generator to generate all the desired strings:\n```\n$ for string_check in {00..23}{00,30}00; do echo $string_check; done\n000000\n003000\n010000\n013000\n... snip ...\n230000\n233000\n```\n\nWhile OP should be able to add this to the current code, I'm thinking we might go one step further and look at pre-parsing all of the filenames, pulling the 6-digit strings into an associative array (ie, the 6-digit strings act as the indexes), eg:\n```\nunset      myarray\ndeclare -A myarray\n\nfor file in ${file_list}\ndo\n    myarray[${file:22:6}]+=\" ${file}\"       # in case multiple files have same 6-digit string\ndone\n```\n\nUsing the sequence generator as the driver of our logic, we can pull this together like such:\n```\nfor string_check in {00..23}{00,30}00\ndo\n    [[ -z \"${myarray[${string_check}]}\" ]] &&\n    echo \"Problem: (file) '${string_check}' is missing\"\ndone\n```\n\nNOTE: OP can decide if the process should finish checking all strings or if it should ```\nexit```\n on the first missing string (per OP's current code).\n\nOne idea for using ```\ncomm```\n to compare the 2 lists of strings:\n```\n# display sequence generated strings that do not exist in the array:\n\ncomm -23 <(printf \"%s\\n\" {00..23}{00,30}00) <(printf \"%s\\n\" \"${!myarray[@]}\" | sort)\n\n# OP has commented that strings not like 'xx[03]000]` should generate an error;\n# display strings (extracted from file names) that do not exist in the sequence\n\ncomm -13 <(printf \"%s\\n\" {00..23}{00,30}00) <(printf \"%s\\n\" \"${!myarray[@]}\" | sort)\n```\n\nWhere:\n\n```\ncomm -23```\n - display only the lines from the first 'file' that do not exist in the second 'file' (ie, missing sequences of the format ```\nxx[03]000```\n)\n```\ncomm -13```\n - display only the lines from the second 'file' that do not exist in the first 'file' (ie, filenames with strings not of the format ```\nxx[03]000```\n)\n\nThese lists could then be used as input to a loop, or passed to ```\nxargs```\n, for additional processing as needed; keeping in mind the ```\ncomm -13```\n output will display the indices of the array, while the associated contents of the array will contain the name of the original file(s) from which the 6-digit string was derived.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Link between modular arithmetic and bitwise AND in C expression\r\n                \r\nI came across a C snippet that performs a nifty modular arithmetic operation using bitwise logic:\n\n```\nint a,b,c; \nc = (a + b - 1) & (- b) +b; \n```\n\n\nThe value of c is the smallest multiple of b greater than a+b (edited in response to John Bollinger's answer). I am trying to explain how this works to myself (I have a tenuous understanding of how modular arithmetic and the & operation could be related) but am falling short on insight. On the other hand it looks like I can express it as \n\n```\nc = (a+b) - ((a+b)%b) + (((a+b)%b)?b:0)\n```\n\n\nThis expression is easy to understand. Moreover the appearance of the modular and ? operations suggests that the individual parts can be expressed as bitwise logic and somehow reduced to the expression at the top. But how? I leave it as an exercise if anyone wants to give it a go (this is NOT homework). Implementation need not be in C, and if there is an online ref that explains this you are welcome to provide it but will not be a complete answer. I'd like to see the transition from the bottom to the top expression in clear steps...\n\nComments\nThis link suggests that this may apply when b is a power of 2. \nThis other link explains that bitwise & does not distribute over addition.\n\nAssume in the expression ```\n...&(-b)```\n, ```\n(-b)```\n can be replaced with ```\n(nums(int)-b)```\n, where ```\nnums(int)```\n is the total number of possible ints in the representation.  \n\nFeel free to specify your favorite compiler/C version. \n\nSample code:\n\n```\nint a,b,c;\nint alow, ahigh; \n\nb = 16;\nalow = 8; \nahigh = 20; \nprintf(\"a+b      c    lcm(a+b,b) + ?b  \\n\");    \nfor (a=alow;a<ahigh;a++) {\n    c = ((a+b-1) & (-b)) +b;\n    printf(\"%5d   %5d    %5d   \\n\",a+b, c, (a+b) - ((a+b)%b) + (((a+b)%b)?b:0) );\n}\n```\n\n\nSample output:\n\n```\n  a+b      c    lcm(a+b,b) + ?b\n   24      32       32\n   25      32       32\n   26      32       32\n   27      32       32\n   28      32       32\n   29      32       32\n   30      32       32\n   31      32       32\n   32      32       32\n   33      48       48\n   34      48       48\n   35      48       48\n```\n\n    ", "Answer": "\r\nOn machines that use two's complement representation for negative numbers, if ```\nb```\n is a power of 2 then in the representation of ```\n-b```\n, the least-significant ```\nlog2(b)```\n bits have value zero, and all other bits have value one.  Interpreted as an unsigned value, the least significant binary digit in that bit pattern has place value ```\nb```\n.  (Example: the ```\nint8_t```\n with value ```\n-4```\n has bit pattern ```\n11111100```\n in such a represenation.)  This is the most common style of integer representation in use today, and where it matters, the rest of this answer will assume that mode of negative integer representation.\n\nA value such as that can serve as a bitmask to mask off the binary digits having place value less than ```\nb```\n from a non-negative integer.  Given that we assumed a binary representation and ```\nb```\n a power of 2, masking off the bits having lower place value necessarily results in a value divisible by ```\nb```\n.\n\nNow suppose ```\na```\n is non-negative and ```\nb```\n is a power of 2.  The value of ```\na```\n can be expressed as a non-negative multiple of ```\nb```\n plus a remainder:\n\n```\na == n * b + a % b\n```\n\n\nNow consider the expression ```\n(a + b - 1)```\n, and suppose that computing its value does not result in integer overflow.  There are two cases:\n\nCase 1: ```\na % b == 0```\n\n\nIn this case, ```\na == n * b```\n, so\n\n```\n(a + b - 1) == n * b + b - 1\n```\n\n\n.  If we mask off the bits having place value less than ```\nb```\n, we get\n\n```\n(a + b - 1) & (-b) == n * b == a\n```\n\n\nThis is certainly the least multiple of ```\nb```\n greater than or equal to ```\na```\n.\n\n\n\nCase 2: ```\na % b != 0```\n\n\nIn this case, \n\n```\n(a + b - 1) == (n + 1) * b + a % b - 1\n```\n\n\n.  If we mask off the bits having place value less than ```\nb```\n, we get\n\n```\n(a + b - 1) & (-b) == (n + 1) * b\n```\n\n\nSince ```\na```\n is strictly between ```\nn * b```\n and ```\n(n + 1) * b```\n, this is again the least multiple of ```\nb```\n greater than or equal to ```\na```\n.\n\n\n\nThus, your original assertion that\n\n\n  The value of [(a + b - 1) & (-b)] is the next largest number greater than a+b that is divisible by b\n\n\nis an inaccurate characterization for the numeric representation I have supposed (including when ```\nb```\n is not a power of 2, though I have not demonstrated that).  Instead, under the assumptions described above, the expression computes the least multiple of ```\nb```\n that is greater than or equal to ```\na```\n.\n\nYour revised assertion follows directly from the above, however, by adding ```\nb```\n to both sides of the expression.  If ```\n(a + b - 1) & (-b)```\n is the least multiple of ```\nb```\n that is at least as large as ```\na```\n, then it follows that ```\n(a + b - 1) & (-b) + b```\n is the least multiple of ```\nb```\n that is at least as large as ```\na + b```\n.\n\nEquivalent expressions that do not depend on numeric representation (but are still sensitive to overflow) would be\n\n```\n((a + b - 1) / b) * b + b\n\n((a + b) / b) * b + b\n\n((a / b) + 1) * b + ((a % b) ? b : 0)\n```\n\n\nThe last of those maps rather directly onto the two cases presented above, and with a bit of care it can be rearranged to the second expression you present in your question.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Exponentiation (Power in Modular Arithmetic) [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs details or clarity. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Add details and clarify the problem by editing this post.\r\n                \r\n                    \r\n                        Closed 5 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\n\nHello!\n I am got stuck in understanding the concept of modular Exponentiation. When I need this and how this works.\n Suppose I am calling the power function as : power(2,n-1).\nHow the loops will be executed for say n=10 and also the time and space complexity for the below problem\n\n```\n#define m 1000000007\n\nunsigned long long int power(unsigned long long int x, unsigned long long int n){\n\n    unsigned long long int res = 1;\n    while(n > 0){\n        if(n & 1){\n            res = res * x;\n            res = res % m;\n        }\n        x = x * x;\n        x= x % m;\n        n >>= 1;\n    }\n    return res;\n\n}\n```\n\n    ", "Answer": "\r\nFrom the modulo laws on DAle's linked Wikipedia page (on your previous question), we can obtain two formulas:\n\n\n\nFrom the first formula it is clear that we can iteratively calculate the modulo for ```\nn```\n from the result for ```\nn / 2```\n. This is done by the lines\n\n```\nx = x * x;\nx = x % m;\n```\n\n\nThere are thus ```\nlog n```\n steps in the algorithm, because each time the exponent of ```\nx```\n doubles. The step counting is done by ```\nn >>= 1```\n and ```\nwhile (n > 0)```\n, which counts ```\nlog n```\n steps.\n\nNow, you may be wondering 1) why doesn't this part set the value of ```\nres```\n, and 2) what is the purpose of these lines\n\n```\nif(n & 1){\n   res = res * x;\n   res = res % m;\n}\n```\n\n\nThis is necessary as at certain points in the iteration, be it the start or the end, the value of ```\nn```\n may be odd. We can't just ignore it and keep using formula 1, because that means we would skip a power of ```\nx```\n! (Integer division rounds down, so e.g. ```\n5 >> 1 = 2```\n, and we would have ```\nx^4```\n instead of ```\nx^5```\n). This if statement handles the case when ```\nn```\n is odd, i.e. ```\nn % 2 = n & 1 = 1```\n. It simply uses formula 2 above to \"add\" a single power of ```\nx```\n to the result.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How do I use modular arithmetic on a list, I wish to mod 121 after each enumerated number?\r\n                \r\nI have a list that's is enumerated and I wish to use modular arithmetic on each number, but not the enumerated numbers.  How do I do this?\nThis question regards only list modular arithmetic not a simple operation.\n\nHow do I mod 121 each of these numbers in the list (236, 242, 248) all at once?  \n\n```\n    lst1 = [22, 236, 23, 242, 24, 248]\n    print(mod 121 lst1)\n```\n\n    ", "Answer": "\r\nList comprehensions are the typical way to perform an operation on each element in an input iterable, returning a new ```\nlist```\n:\n\n```\nprint([x % 121 for x in lst1])\n```\n\n\nThat's roughly equivalent to:\n\n```\nnewlst = []\nfor x in lst1:\n    newlst.append(x % 121)\nprint(newlst)\n```\n\n\nbut should run significantly faster, and (for simple cases like this) is easier to read.\n\nUpdate: It seems like you only want to apply this to every other element in the ```\nlist```\n, so just slice it down before performing the comprehension:\n\n```\nprint([x % 121 for x in lst1[1::2]])\n```\n\n\n```\nlst1[1::2]```\n is a slice that makes a new ```\nlist```\n with only the odd-index elements (1, 3, 5, ...), so you only operate on ```\n[236, 242, 248]```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "sine cosine modular extended precision arithmetic\r\n                \r\nI've seen in many impletation of sine/cosine a so called extended modular precision arithmetic. But what it is for? \nFor instance in the cephes implemetation, after reduction to the range [0,pi/4], they are doing this modular precision arithmetic to improve the precision. \n\nHereunder the code:\n\n```\nz = ((x - y * DP1) - y * DP2) - y * DP3;\n```\n\n\nwhere DP1, DP2 and DP3 are some hardcoded coefficient.\nHow to find those coefficient mathematically? I've understand the purpose of \"modular extension arithmetic\" for big num, but here what is its exact purpose?\n    ", "Answer": "\r\nIn the context of argument reduction for trigonometric functions, what you are looking at is Cody-Waite argument reduction, a technique introduced in the book: William J. Cody and William Waite, Software Manual for the Elementary Functions, Prentice-Hall, 1980. The goal is to achieve, for arguments up to a certain magnitude, an accurate reduced argument, despite subtractive cancellation in intermediate computation. For this purpose, the relevant constant is represented with more than native precision, by using a sum of multiple numbers of decreasing magnitude (here: ```\nDP1```\n, ```\nDP2```\n, ```\nDP3```\n), such that all of the intermediate products except the least significant one can be computed without rounding error.\n\nConsider as an example the computation of sin (113) in IEEE-754 ```\nbinary32```\n (single precision). The typical argument reduction would conceptually compute ```\ni=rintf(x/(π/2)); reduced_x = x-i*(π/2)```\n. The ```\nbinary32```\n number closest to π/2 is ```\n0x1.921fb6p+0```\n. We compute ```\ni=72```\n, the product rounds to ```\n0x1.c463acp+6```\n, which is close to the argument ```\nx=0x1.c40000p+6```\n. During subtraction, some leading bits cancel, and we wind up with ```\nreduced_x = -0x1.8eb000p-4```\n. Note the trailing zeros introduced by renormalization. These zero bits carry no useful information. Applying an accurate approximation to the reduced argument, ```\nsin(x) = -0x1.8e0eeap-4```\n, whereas the true result is ```\n-0x1.8e0e9d39...p-4```\n. We wind up with large relative error and large ulp error.\n\nWe can remedy this by using a two-step Cody-Waite argument reduction. For example, we could use ```\npio2_hi = 0x1.921f00p+0```\n, and ```\npio2_lo = 0x1.6a8886p-17```\n. Note the eight trailing zero bits in single-precision representation of```\npio2_hi```\n, which allow us to multiply with any 8-bit integer ```\ni```\n and still have the product ```\ni * pio2_hi```\n representable exactly as a single-precision number. When we compute ```\n((x - i * pio2_hi) - i * pio2_lo)```\n, we get ```\nreduced_x = -0x1.8eafb4p-4```\n, and therefore ```\nsin(x) = -0x1.8e0e9ep-4```\n, a quite accurate result.\n\nThe best way to split the constant into a sum will depend on the magnitude of ```\ni```\n we need to handle, on the maximum number of bits subject to subtractive cancellation for a given argument range (based on how close integer multiples of π/2 can get to integers), and performance considerations. Typical real-life use cases involve two- to four-stage Cody-Waite reduction schemes. The availability of fused multiple-add (FMA) allows the use of constituent constants with fewer trailing zero bits. See this paper: Sylvie Boldo, Marc Daumas, and Ren-Cang Li, \"Formally verified argument reduction with a fused multiply-add.\" IEEE Transactions on Computers, 58 :1139–1145, 2009. For a worked example using ```\nfmaf()```\n you might want to look at the code in one of my previous answers.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Javascript Modular Arithmetic\r\n                \r\nJavascript evaluates the following code snippet to -1.\n\n\n-5 % 4\n\n\nI understand that the remainder theorem states a = bq + r such that 0 ≤ r < b.\nGiven the definition above should the answer not be 3? Why does JavaScript return -1?\n    ", "Answer": "\r\nBecause it's a remainder operator, not a modulo. But there's a proposal for a proper one.\n\nA quote from Ecma 5.1\n\n\n  remainder r from a dividend n and a divisor d is defined by the\n  mathematical relation r = n − (d × q)\n  where q is an integer that is negative only if n/d is negative and\n  positive only if n/d is positive\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Linear independence of vectors in modular arithmetic mod 2 using Python\r\n                \r\nI would like to check if there is an easy way to implement a check of linear (in)dependence of vectors but using modular arithmetic mod 2.\nFor example, suppose you have the following 3 vectors:\n\nv1 = (1,1,0);\nv2 = (0,1,1);\nv3 = (1,0,1).\n\nIf we use scipy.linalg's null_space such that:\n```\nM = [[1,0,1],\n     [1,1,0],\n     [0,1,1]]\nnull_space(M)\n```\n\nwe get as a result that the 3 vectors are linearly independent, which is obviously true.\nHowever, what I want to check is linear (in)dependence considering modular arithmetic mod 2. In that case, it is easy to check that v3 = v1 + v2 (i.e., the three vectors are linearly dependent).\nIs there any way to determine this in Python?\nThank you in advance.\n\nUPDATE (02/01/2022): Is there an alternative to doing this with sympy as suggested in one of the answers below? While this solution works for small instances I have noticed (in growing the matrix size) that the code sometimes gets stuck for over 30hours without being able to move on. This is very dependent on the example, which I find fascinating. That is, for a given size while some examples are worked through reasonably quickly (~2hours) others get stuck and the code still hasn't found a solution after 30hours which is less than desirable.! So, is there really no way of doing this with numpy or something like that?\n    ", "Answer": "\r\nHere is a solution using ```\nsympy```\n, adapted from the answer linked by @Lagerbaer.\nWhen finding the nullspace using sympy, you can pass in an argument ```\niszerofunc```\n, which specifies what you consider to be zeros in your matrix. In the case of the field of integers mod 2, our zero function is ```\nlambda x: x % 2 == 0```\n.\nYou can verify that running the following code outputs a non-zero nullspace.\n```\nimport sympy\nM = sympy.Matrix([[1,0,1],\n     [1,1,0],\n     [0,1,1]])\nprint(M.nullspace(iszerofunc=lambda x: x % 2 == 0))\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic (a*b/e)%m?\r\n                \r\nIs there a modular expression possible for following :\n\n```\n((a*b)/e)%m\n```\n\n\nFor ex :\n\n```\n(a*b*c)%m = ((a%m)*(b%m)*(c%m))%m\n```\n\n    ", "Answer": "\r\nInstead of performing division when using modular arithmetic, you must multiply by the modular inverse. For instance, to divide by e, you would multiply by the modular inverse c where c × e ≡ 1 (mod m). You can calculate the modular inverse of x (mod m) by the following algorithm:\n\n```\nfunction inverse(x, m)\n    a, b, u = 0, m, 1\n    while x > 0\n        q = b // x # integer division\n        x, a, b, u = b % x, u, x, a - q * u\n    if b == 1 return a % m\n    error \"must be coprime\"\n```\n\n\nThus, for your expression ```\n((a*b)/e)%m```\n you would compute ```\n(a * b * inverse(e,m)) % m```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Number theory modular arithmetic how to account for adjustments\r\n                \r\nI am not sure whether my solution is justifiable (ans. 171) - Project Euler Q.19 since I am having a hard time getting my head around modular arithmetic and not really sure whether my approach to it was correct or not... I was having trouble on trying to get the equivalence of having 0 as a key rather than 1 to Monday for reference in a hash table. The question was;\n\n\n  \n  1 Jan 1900 was a Monday.\n  Thirty days has September, April, June and November. All the rest    have thirty-one, Saving February alone, which has twenty-eight, rain\n  or shine. And on leap years, twenty-nine.\n  A leap year occurs on any year evenly divisible by 4, but not on a    century unless it is divisible by 400.\n  \n  \n  How many Sundays fell on the first of the month during the twentieth\n  century (1 Jan 1901 to 31 Dec 2000)?\n\n\nSo what I did was start the sum of days at 1 (reference for days in hash table) and subtract 1 after finding the sum of Sunday's, since doing it by 0 caused problems when the total sum of days were divisible by 3 and 6 (3:Wednesday, 6:Sunday). How could I have done this by using 0 as reference for Monday?\n\n```\nimport java.util.*;\n\npublic class p19 {\n\n    public static void main(String[] args) {\n\n        Hashtable<Integer, String> days = new Hashtable<Integer, String>();\n        days.put(1, \"Monday\");\n        days.put(2, \"Tuesday\");\n        days.put(3, \"Wednesday\");\n        days.put(4, \"Thursday\");\n        days.put(5, \"Friday\");\n        days.put(6, \"Saturday\");\n        days.put(7, \"Sunday\");\n\n        Hashtable<Integer, String> months = new Hashtable<Integer, String>();\n        months.put(1, \"January\");\n        months.put(2, \"February\");\n        months.put(3, \"March\");\n        months.put(4, \"April\");\n        months.put(5, \"May\");\n        months.put(6, \"June\");\n        months.put(7, \"July\");\n        months.put(8, \"August\");\n        months.put(9, \"September\");\n        months.put(10, \"October\");\n        months.put(11, \"November\");\n        months.put(12, \"December\");\n\n        int min, max;\n        min = 1900;\n        max = 2000;\n\n        String[][] arr = new String[12 * (max - min + 1)][];\n\n        // Total days starts at 1 to make modular arithmetic easier when accounting for days \n        // (i.e., 1 Monday, 2 Tuesday, etc.) and since the first day, hence, 0th day on 1 Jan 1900 is Monday.\n        for (int year = min, index = 0, totalDays = 1; year <= max; year++) {\n\n            for (int month = 1; month <= 12; month++, index++) {\n\n                arr[index] = new String[numberOfDays(month,year)];\n\n                int sum = 1;\n\n                System.out.println(months.get(new Integer(month)) + \" \" + year);\n\n                for (int day = 1; day <= numberOfDays(month, year); day++, totalDays++) {\n\n                    if (totalDays % 7 == 0) {\n\n                        arr[index][day - 1] = days.get(new Integer((totalDays % 7 + 7) % 365));                         \n                    }\n                    else {\n\n                        arr[index][day - 1] = days.get(new Integer((totalDays % 7) % 365));                         \n                    }\n\n                    if (sum > 7) {\n\n                        System.out.println();\n\n                        sum = 1;\n                    }\n\n                    System.out.print(totalDays + \":= \" + arr[index][day - 1] + \", \" + day + \" | \");\n\n                    sum++;\n                }\n\n                System.out.println(\"\\n\");\n            }\n        }\n\n        int count = 0;\n\n        for (int i = 1; i < arr.length; i++) {\n\n            if (arr[i][0] == \"Sunday\") {\n\n                count++;\n            }\n        }\n        // Subtract 1 from count since the total days were overstated by 1 before inititallizing array\n        System.out.println(\"Number of Sundays that fell on the first of the month from: 1/Jan/1901 - 31/Dec/2000: \" + (count - 1));\n    }\n\n    public static int numberOfDays (int month, int year) {\n\n        int days = 0;\n\n        switch (month) {\n            case 7: \n            case 4: \n            case 6: \n            case 11:\n                days = 30;\n                break;\n            case 2:\n                if (isLeapYear(year)) {\n                    days = 29;\n                }\n                else {\n                    days = 28;\n                }\n                break;\n            default: days = 31;\n                break;   \n        }\n\n        return days;\n    }\n\n    public static boolean isLeapYear(int year) {\n\n        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n    }\n} \n```\n\n    ", "Answer": "\r\nYour daysInMonth check is incorrect - the result must have been correct by incidence: \n\n```\nswitch (month) {\n    case 4:\n    case 6:\n    case 9:\n    case 11:\n        days = 30;\n        break;\n```\n\n\nThe rest of the program can be simplified - note that the start year has to be corrected too, dow stands for DayOfWeek: \n\n```\npublic static void main (String[] args) {\n\n    int count = 0;\n    // dow = 2, since 1.1.1901 was a Thuesday (2)\n    for (int year = 1901, dow = 2; year <= 2000; ++year)\n    {\n        for (int month = 1; month <= 12; ++month)\n        {\n            if (dow == 0) {\n                // System.out.println (\"Date: \" + year + \"-\" + month);\n                ++count;\n            }\n            dow = (dow + numberOfDays (month, year)) % 7;\n        }\n    }\n    System.out.println (\"Number of Sundays that fell on the first of the month from: 1/Jan/1901 - 31/Dec/2000: \" + count);\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Numpy Modular arithmetic\r\n                \r\nHow can I define in numpy a matrix that uses operations modulo 2?\n\nFor example:\n\n```\n0 0       1 0       1 0\n1 1   +   0 1   =   1 0\n```\n\n\nThanks! \n    ", "Answer": "\r\nThis operation is called \"xor\".\n\n```\n>>> import numpy\n>>> x = numpy.array([[0,0],[1,1]])\n>>> y = numpy.array([[1,0],[0,1]])\n>>> x ^ y\narray([[1, 0],\n       [1, 0]])\n```\n\n\nBTW, (element-wise) multiplication modulo 2 can be done with \"and\".\n\n```\n>>> x & y\narray([[0, 0],\n       [0, 1]])\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Java Modular Arithmetic [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  Mod in Java produces negative numbers  \n\n\n\n\nWhen I try to print -16 mod 57, I should get 41. However, I keep getting -16 as my answer. What gives?    \n\nHere is my code:\n\n```\npublic class TestMod {\n\npublic static void main(String[] args) {\n    int number = -16;\n    int mod = 57;\n    int answer = number%mod;\n    System.out.println(answer);\n\n}\n\n}\n```\n\n    ", "Answer": "\r\nFrom the JLS:\n\n\n  The remainder operation for operands that are integers after binary numeric promotion (§5.6.2) produces a result value such that (a/b)*b+(a%b) is equal to a.\n\n\nSubstitute the numbers from your example, and you'll see that ```\n-16```\n is what the language spec mandates.\n\n\n  This identity holds even in the special case that the dividend is the negative integer of largest possible magnitude for its type and the divisor is -1 (the remainder is 0).\n  \n  It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative, and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor.\n\n\nHere is how you can get the result you're expecting:\n\n```\npublic static void main(String[] args) {\n    int number = -16;\n    int mod = 57;\n    int answer = ((number % mod) + mod) % mod;\n    System.out.println(answer);\n\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetic - Division\r\n                \r\nHow does one calculate (a/b) % m where a = x1*x2*.... and the numbers x1, x2,.. are quite large.\n\nIf we only had to find a % m , we could have easily done that using (x1%m) * (x2%m) *... but if there's something in the denominator 'b' in our case, how does one go about calculating it ?\n\nI read somewhere this being done as (a % (m*b)) / b . I have been wondering if this is true and how do we go about proving it ?  \n    ", "Answer": "\r\nYou can get at least this far:\n\n```\nb * ((a / b) % m) = (b * (a / b)) % (b * m)\n                  = (a - (a % b)) % (b * m)\n                  = (a % (b * m) - (a % b) % (b * m))\n                  = (a % (b * m) - (a % b))\n\nhence,\n\n((a / b) % m) = ((a % (b * m)) - (a % b)) / b\n```\n\n\nThat is already easier to compute, hence I justify giving this as an answer.  I think you can go on from there to the simpler formula you suggested, but I haven't the time or inclination to work that out.  (So if this is homework then I leave a bit of it for you to do yourself :))\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "modular arithmetic problems\r\n                \r\ni met a problem from an easy algorithm. The question is below:\n\nProblem description\nThe recursive formula of Fibonacci sequence is: Fn=Fn-1+Fn-2, where F1=F2=1.\n\nWhen n is large, Fn is also very large, and now we want to know what the remainder of Fn over 10007 is.\n\nInput format\n\nThe input contains an integer n.\n\nThe output format\n\nThe output line contains an integer representing the remainder of Fn divided by 10007.\n\nThe sample input\n10\nSample output\n\n55\n\nThe sample input\n22\nSample output\n\n7704\n\nData size and convention\n1 <= n <= 1,000,000.\n\nmy solution is below:\n\n```\nimport java.util.Scanner;\n```\n\n\n/**\n *\n */\npublic class Main {\n\n```\npublic static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    System.out.println(recurrence(n));\n    in.close();\n\n}\n\n\n/**\n *\n * @param n\n * @return\n */\npublic static int recurrence(int n) {\n    int f1 = 1;\n    int f2 = 1;\n    int temp = f1;\n    for (int i = 1; i <= n - 2; i++) {\n        temp = (f1 + f2)%10007;\n        f1 = f2;\n        f2 = temp;\n    }\n    return temp;\n}\n```\n\n\n}\n\nThe solution above is right. But i wanna say the following solution has a problem.\n\n```\npublic static int recurrence(int n) {\n    int f1 = 1;\n    int f2 = 1;\n    int temp = f1;\n    for (int i = 1; i <= n - 2; i++) {\n        f1 %= 10007;\n        f2 %= 10007;\n        temp = f1 + f2;\n        f1 = f2;\n        f2 = temp;\n    }\n    return temp;\n}\n```\n\n\nis not ```\ntemp = (f1+f2)%10007```\n the same as ```\nf1 %= 10007; f2 %= 10007; temp = f1 + f2;```\n？\n\nMy English is poor, i hope you guys can understand what i mean. Thanks!\n    ", "Answer": "\r\nThere are certain properties for rewriting modulo result. Wikipedia shows some of them. The one that's relevant here is:\n\n```\n(a + b) % n = ((a % n) + (b % n)) % n\n```\n\n\nSo if you change\n\n    Fn = Fn-1 + Fn-2\n\nto\n\n    Fn = (Fn-1 + Fn-2) % 10007\n\nyou get what you want, since Fn-1 and Fn-2 have already had the ```\n% 10007```\n applied.\n\n```\nstatic int fibMod(int n, int mod) {\n    if (n < 0 || mod < 2)\n        throw new IllegalArgumentException();\n    if (n <= 1)\n        return n;\n    int prev = 1, fib = 1;\n    for (int i = 3; i <= n; i++)\n        fib = (prev + (prev = fib)) % mod;\n    return fib;\n}\n```\n\n\nTest\n\n```\nSystem.out.println(fibMod(10, 10007));\nSystem.out.println(fibMod(22, 10007));\nSystem.out.println(fibMod(1_000_000, 10007));\n```\n\n\nOutput\n\n```\n55\n7704\n114\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Coq modular arithmetic\r\n                \r\nHow do static analyzers prove overflow using Coq?\n\nDo they have their own definitions of integers and not use the given sets?\nOr does coq have an inbuilt type for n-bit integers and operations on them?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic calculation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question does not appear to be about programming within the scope defined in the help center.\r\n                \r\n                    \r\n                        Closed 4 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nIs there any way to calculate ```\n(a mod c)*(b mod c)```\n?\n\nKnowing only:\n\n\n```\na*b```\n\n```\nc```\n\n```\nd```\n\n```\n((a mod c)*(b mod c)) mod c```\n\n```\n(a mod d)*(b mod d)```\n\n\n    ", "Answer": "\r\nNo, it's impossible.\n\nHere's a counterexample:\n\n```\nab = 1225 = (5)(5)(7)(7)\nc = 3\nd = 5000\n((a mod c)(b mod c)) mod c = 1\n(a mod d)(b mod d) = 1225\n```\n\n\nIf a=25 and b=49, then (a mod c)(b mod c)=(1)(1)=1\n\nIf a=35 and b=35, then (a mod c)(b mod c)=(2)(2)=4\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to calculate timespans using modular arithmetic?\r\n                \r\nThis question is basically about representing modular arithmetic concept in code and using the modulo sign.\n\nSo recently I did a popup for SCCM installation, which should give user time to install an app, the client requuirements were to show the user a clock with the amount of time left to the installation (or let user install now as well). The amount of time on the clock that they wanted was 24 hours, plus whatever time is left to 4pm when the 24 hours have passed so:\n\nprogram runs at 13:00 then the clock should display 24 +3 = 27 hours\n\nwhen 16:00 it should be 24+24 which is 48 hours\n\nwhen 22:00 it should be 24 + 18 which is 42 hours\n\nNow I noticed that:\n\n13 + 27 = 40\n\n16 + 24 = 40\n\n22 + 18 = 40\n\n40 Modulo 24 = 16\n\nSo basically if I subtract the current time from 40 then I will be left with the difference:\n\n40 - 13 = 27\n\n40 - 16 = 24\n\n40 - 22 = 18\n\nSo what I did is this:\n\n```\n//I need to make a timespan object which has 24 hours from current time + time left to the next 4pm\n\n//The context is time to install, which user should see\nTimespan TimeToInstall = new Timespan(23,59,59)\n\nDateTime Now = DateTime.Now;\nif (Now.Hour < 16)\n{\n    long TimeTo4 = (new TimeSpan(40, 0, 0).Ticks - Now.TimeOfDay.Ticks);\n    TimeToInstall = TimeSpan.FromTicks(TimeTo4);\n}\nelse\n{\n\nlong TimeTo4 = (new TimeSpan(40, 0, 0).Ticks - Now.TimeOfDay.Ticks) + TimeGiven.Ticks;\nTimeToInstall = TimeSpan.FromTicks(TimeTo4);\n\n}\n```\n\n\nThe problem with the above solution is that I know that it can be shorter, because when I subtract times times before 4 pm then I don't need to add 24 hours, if the run time is higher than or equal 4 pm then I need to add 24 hours. I have a rough idea how to refactor this in mathematics/pseudocode for example:\n\nabsolute(16-13) modulo 24 = 3\n\nabsolute(16-16) modulo 24 = 0 (24)\n\nabsolute(16-22) modulo 24 = 18\n\nThe question is how to do it in C# code to refactor this code? Please use any language you like, but I would be greatfull for C# example. Thank you guys\n    ", "Answer": "\r\nIf you're looking for a shorter solution, how about this?\n\n```\npublic static int HoursUntilDueTime(DateTime time)\n{\n    DateTime dueTime = (time + TimeSpan.FromHours(8)).Date + TimeSpan.FromHours(24 + 16);\n    return (int)(0.5 + (dueTime - time).TotalHours);\n}\n```\n\n\nOr if you want to pass in the target time (date part is ignored):\n\n```\npublic static int HoursUntilDueTime(DateTime currentTime, DateTime targetTime)\n{\n    DateTime dueTime = (currentTime + TimeSpan.FromHours(24 - targetTime.Hour)).Date + TimeSpan.FromHours(24 + targetTime.Hour);\n    return (int)(0.5 + (dueTime - currentTime).TotalHours);\n}\n```\n\n\nTest code:\n\n```\nvar targetTime = new DateTime(2000, 1, 1, 16, 00, 00);\nConsole.WriteLine(HoursUntilDueTime(new DateTime(2016, 1, 1, 13, 00, 00), targetTime));\nConsole.WriteLine(HoursUntilDueTime(new DateTime(2016, 1, 1, 16, 00, 00), targetTime));\nConsole.WriteLine(HoursUntilDueTime(new DateTime(2016, 1, 1, 22, 00, 00), targetTime));\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Division in modular arithmetic\r\n                \r\nIf X = (a*b)mod(c), and we know the value of \"b\" and \"c\" but not of \"a\", how can we find (a)mod(c)?\nCan we do it as  X divided by (b)mod(c) or something like that?\n    ", "Answer": "\r\nYour suggestion doesn't work.\nFor example\n```\n(3 * 4 ) mod 7 = 5\nbut 3 mod 5 != 5 / (4 mod 7) = 5/4\n```\n\nIn this case we could note that\n```\n(4*2 ) mod 7 = 1\n```\n\nand then\n```\n(2 * ((3 * 4) mod 7) mod 7\n= 24 mod 7 = 3 = 3 mod 7\n```\n\nand in general if b and c have no common divisors, then there is a b' with\n```\n(b'*b ) mod c = 1\n```\n\nand then\n```\n(b' * ((a*b) mod c) ) mod c\n= (a* ((b'*b) mod c)) mod c\n= (a*1) mod c\n= a mod c\n```\n\nGiven b and c with no common divisors you can find b' as above via the extended Euclid algorithm\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic in Python\r\n                \r\nProblem 48 description from Project Euler:\n\n\n  The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317. Find the last\n  ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.\n\n\nI've just solved this problem using a one-liner in Python:\n\n```\nprint sum([i**i for i in range(1,1001)])%(10**10)\n```\n\n\nI did it that way almost instantly, as I remembered that division mod n is very fast in Python. But I still don't understand how does this work under the hood (what optimizations does Python do?) and why is this so fast.\n\nCould you please explain this to me? Is the ```\nmod 10**10```\n operation optimized to be applied for every iteration of the list comprehension instead of the whole sum?\n\n```\n$ time python pe48.py \n9110846700\n\nreal 0m0.070s\nuser 0m0.047s\nsys  0m0.015s\n```\n\n    ", "Answer": "\r\nGiven that\n\n```\nprint sum([i**i for i in range(1,1001)])%(10**10)```\n\n\nand\n\n```\nprint sum([i**i for i in range(1,1001)])```\n\n\nfunction equally fast in Python, the answer to your last question is 'no'.\n\nSo, Python must be able to do integer exponentiation really fast. And it so happens that integer exponentiation is O(log(n)) multiplications: http://en.wikipedia.org/wiki/Exponentiation#Efficient_computation_of_integer_powers\n\nEssentially what is done is, instead of doing 2^100 = 2*2*2*2*2... 100 times, you realize that 2^100 is also 2^64 * 2^32 * 2^4 , that you can square 2 over and over and over to get 2^2 then 2^4 then 2^8... etc, and once you've found the values of all three of those components you multiply them for a final answer. This requires much fewer multiplication operations. The specifics of how to go about it are a bit more complex, but Python is mature enough to be well optimized on such a core feature.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetics and NTT (finite field DFT) optimizations\r\n                \r\nI wanted to use NTT for fast squaring (see Fast bignum square computation), but the result is slow even for really big numbers .. more than 12000 bits.\n\nSo my question is:\n\n\nIs there a way to optimize my NTT transform?\nI did not mean to speed it by parallelism (threads); this is low-level layer only.\nIs there a way to speed up my modular arithmetics?\n\n\nThis is my (already optimized) source code in C++ for NTT (it's complete and 100% working in C++ whitout any need for third-party libs and should also be thread-safe. Beware the source array is used as a temporary!!!, Also it cannot transform the array to itself).\n\n```\n//---------------------------------------------------------------------------\nclass fourier_NTT                                    // Number theoretic transform\n    {\n\npublic:\n    DWORD r,L,p,N;\n    DWORD W,iW,rN;\n    fourier_NTT(){ r=0; L=0; p=0; W=0; iW=0; rN=0; }\n\n    // main interface\n    void  NTT(DWORD *dst,DWORD *src,DWORD n=0);               // DWORD dst[n] = fast  NTT(DWORD src[n])\n    void INTT(DWORD *dst,DWORD *src,DWORD n=0);               // DWORD dst[n] = fast INTT(DWORD src[n])\n\n    // Helper functions\n    bool init(DWORD n);                                       // init r,L,p,W,iW,rN\n    void  NTT_fast(DWORD *dst,DWORD *src,DWORD n,DWORD w);    // DWORD dst[n] = fast  NTT(DWORD src[n])\n\n    // Only for testing\n    void  NTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w);    // DWORD dst[n] = slow  NTT(DWORD src[n])\n    void INTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w);    // DWORD dst[n] = slow INTT(DWORD src[n])\n\n    // DWORD arithmetics\n    DWORD shl(DWORD a);\n    DWORD shr(DWORD a);\n\n    // Modular arithmetics\n    DWORD mod(DWORD a);\n    DWORD modadd(DWORD a,DWORD b);\n    DWORD modsub(DWORD a,DWORD b);\n    DWORD modmul(DWORD a,DWORD b);\n    DWORD modpow(DWORD a,DWORD b);\n    };\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT(DWORD *dst,DWORD *src,DWORD n)\n    {\n    if (n>0) init(n);\n    NTT_fast(dst,src,N,W);\n//    NTT_slow(dst,src,N,W);\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT::INTT(DWORD *dst,DWORD *src,DWORD n)\n    {\n    if (n>0) init(n);\n    NTT_fast(dst,src,N,iW);\n    for (DWORD i=0;i<N;i++) dst[i]=modmul(dst[i],rN);\n       //    INTT_slow(dst,src,N,W);\n    }\n\n//---------------------------------------------------------------------------\nbool fourier_NTT::init(DWORD n)\n    {\n    // (max(src[])^2)*n < p else NTT overflow can ocur !!!\n    r=2; p=0xC0000001; if ((n<2)||(n>0x10000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x30000000/n; // 32:30 bit best for unsigned 32 bit\n//    r=2; p=0x78000001; if ((n<2)||(n>0x04000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x3c000000/n; // 31:27 bit best for signed 32 bit\n//    r=2; p=0x00010001; if ((n<2)||(n>0x00000020)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x00000020/n; // 17:16 bit best for 16 bit\n//    r=2; p=0x0a000001; if ((n<2)||(n>0x01000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x01000000/n; // 28:25 bit\n     N=n;                // size of vectors [DWORDs]\n     W=modpow(r,    L);    // Wn for NTT\n    iW=modpow(r,p-1-L);    // Wn for INTT\n    rN=modpow(n,p-2  );    // scale for INTT\n    return true;\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT_fast(DWORD *dst,DWORD *src,DWORD n,DWORD w)\n    {\n    if (n<=1) { if (n==1) dst[0]=src[0]; return; }\n    DWORD i,j,a0,a1,n2=n>>1,w2=modmul(w,w);\n    // reorder even,odd\n    for (i=0,j=0;i<n2;i++,j+=2) dst[i]=src[j];\n    for (    j=1;i<n ;i++,j+=2) dst[i]=src[j];\n    // recursion\n    NTT_fast(src   ,dst   ,n2,w2);    // even\n    NTT_fast(src+n2,dst+n2,n2,w2);    // odd\n    // restore results\n    for (w2=1,i=0,j=n2;i<n2;i++,j++,w2=modmul(w2,w))\n        {\n        a0=src[i];\n        a1=modmul(src[j],w2);\n        dst[i]=modadd(a0,a1);\n        dst[j]=modsub(a0,a1);\n        }\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w)\n    {\n    DWORD i,j,wj,wi,a,n2=n>>1;\n    for (wj=1,j=0;j<n;j++)\n        {\n        a=0;\n        for (wi=1,i=0;i<n;i++)\n            {\n            a=modadd(a,modmul(wi,src[i]));\n            wi=modmul(wi,wj);\n            }\n        dst[j]=a;\n        wj=modmul(wj,w);\n        }\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT::INTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w)\n    {\n    DWORD i,j,wi=1,wj=1,a,n2=n>>1;\n    for (wj=1,j=0;j<n;j++)\n        {\n        a=0;\n        for (wi=1,i=0;i<n;i++)\n            {\n            a=modadd(a,modmul(wi,src[i]));\n            wi=modmul(wi,wj);\n            }\n        dst[j]=modmul(a,rN);\n        wj=modmul(wj,iW);\n        }\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::shl(DWORD a) { return (a<<1)&0xFFFFFFFE; }\nDWORD fourier_NTT::shr(DWORD a) { return (a>>1)&0x7FFFFFFF; }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::mod(DWORD a)\n    {\n    DWORD bb;\n    for (bb=p;(DWORD(a)>DWORD(bb))&&(!DWORD(bb&0x80000000));bb=shl(bb));\n    for (;;)\n        {\n        if (DWORD(a)>=DWORD(bb)) a-=bb;\n        if (bb==p) break;\n        bb =shr(bb);\n        }\n    return a;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modadd(DWORD a,DWORD b)\n    {\n    DWORD d,cy;\n    a=mod(a);\n    b=mod(b);\n    d=a+b;\n    cy=(shr(a)+shr(b)+shr((a&1)+(b&1)))&0x80000000;\n    if (cy) d-=p;\n    if (DWORD(d)>=DWORD(p)) d-=p;\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modsub(DWORD a,DWORD b)\n    {\n    DWORD d;\n    a=mod(a);\n    b=mod(b);\n    d=a-b; if (DWORD(a)<DWORD(b)) d+=p;\n    if (DWORD(d)>=DWORD(p)) d-=p;\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modmul(DWORD a,DWORD b)\n    {    // b bez orezania !\n    int i;\n    DWORD d;\n    a=mod(a);\n    for (d=0,i=0;i<32;i++)\n        {\n        if (DWORD(a&1))    d=modadd(d,b);\n        a=shr(a);\n        b=modadd(b,b);\n        }\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modpow(DWORD a,DWORD b)\n    {    // a,b bez orezania !\n    int i;\n    DWORD d=1;\n    for (i=0;i<32;i++)\n        {\n        d=modmul(d,d);\n        if (DWORD(b&0x80000000)) d=modmul(d,a);\n        b=shl(b);\n        }\n    return d;\n    }\n//---------------------------------------------------------------------------\n```\n\n\nExample of usage of my NTT class:\n\n```\nfourier_NTT ntt;\nconst DWORD n=32\nDWORD x[N]={0,1,2,3,....31},y[N]={32,33,34,35,...63},z[N];\n\nntt.NTT(z,x,N);    // z[N]=NTT(x[N]), also init constants for N\nntt.NTT(x,y);    // x[N]=NTT(y[N]), no recompute of constants, use last N\n// modular convolution y[]=z[].x[]\nfor (i=0;i<n;i++) y[i]=ntt.modmul(z[i],x[i]);\nntt.INTT(x,y);    // x[N]=INTT(y[N]), no recompute of constants, use last N\n// x[]=convolution of original x[].y[]\n```\n\n\nSome measurements before optimizations (non Class NTT):\n\n```\na = 0.98765588997654321000 | 389*32 bits\nlooped 1x times\nsqr1[ 3.177 ms ] fast sqr\nsqr2[ 720.419 ms ] NTT sqr\nmul1[ 5.588 ms ] simpe mul\nmul2[ 3.172 ms ] karatsuba mul\nmul3[ 1053.382 ms ] NTT mul\n```\n\n\nSome measurements after my optimizations (current code, lower recursion parameter size/count, and better modular arithmetics):\n\n```\na = 0.98765588997654321000 | 389*32 bits\nlooped 1x times\nsqr1[ 3.214 ms ] fast sqr\nsqr2[ 208.298 ms ] NTT sqr\nmul1[ 5.564 ms ] simpe mul\nmul2[ 3.113 ms ] karatsuba mul\nmul3[ 302.740 ms ] NTT mul\n```\n\n\nCheck the NTT mul and NTT sqr times (my optimizations speed it up little over 3x times). It's only 1x times loop so it's not very precise (error ~ 10%), but the speedup is noticeable even now (normally I loop it 1000x and more, but my NTT is too slow for that).\n\nYou can use my code freely... Just keep my nick and/or link to this page somewhere (rem in code, readme.txt, about or whatever). I hope it helps... (I did not see C++ source for fast NTTs anywhere so I had to write it by myself). Roots of unity were tested for all accepted N, see the ```\nfourier_NTT::init(DWORD n)```\n function.\n\nP.S.: For more information about NTT, see Translation from Complex-FFT to Finite-Field-FFT. This code is based on my posts inside that link.\n\n[edit1:] Further changes in the code\n\nI managed to further optimize my modular arithmetics, by exploiting that modulo prime is allways 0xC0000001 and eliminating unnecessary calls. The resulting speedup is stunning (more than 40x times) now and NTT multiplication is faster than karatsuba after about the 1500 * 32 bits threshold. BTW, the speed of my NTT is now the same as my optimized DFFT on 64-bit doubles.\n\nSome measurements:\n\n```\na = 0.98765588997654321000 | 1553*32bits\nlooped 10x times\nmul2[ 28.585 ms ] karatsuba mul\nmul3[ 26.311 ms ] NTT mul\n```\n\n\nNew source code for modular arithmetics:\n\n```\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::mod(DWORD a)\n    {\n    if (a>p) a-=p;\n    return a;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modadd(DWORD a,DWORD b)\n    {\n    DWORD d,cy;\n    if (a>p) a-=p;\n    if (b>p) b-=p;\n    d=a+b;\n    cy=((a>>1)+(b>>1)+(((a&1)+(b&1))>>1))&0x80000000;\n    if (cy ) d-=p;\n    if (d>p) d-=p;\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modsub(DWORD a,DWORD b)\n    {\n    DWORD d;\n    if (a>p) a-=p;\n    if (b>p) b-=p;\n    d=a-b;\n    if (a<b) d+=p;\n    if (d>p) d-=p;\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modmul(DWORD a,DWORD b)\n    {\n    DWORD _a,_b,_p;\n    _a=a;\n    _b=b;\n    _p=p;\n    asm    {\n        mov    eax,_a\n        mov    ebx,_b\n        mul    ebx        // H(edx),L(eax) = eax * ebx\n        mov    ebx,_p\n        div    ebx        // eax = H(edx),L(eax) / ebx\n        mov    _a,edx    // edx = H(edx),L(eax) % ebx\n        }\n    return _a;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modpow(DWORD a,DWORD b)\n    {    // b bez orezania!\n    int i;\n    DWORD d=1;\n    if (a>p) a-=p;\n    for (i=0;i<32;i++)\n        {\n        d=modmul(d,d);\n        if (DWORD(b&0x80000000)) d=modmul(d,a);\n        b<<=1;\n        }\n    return d;\n    }\n\n//---------------------------------------------------------------------------\n```\n\n\nAs you can see, functions ```\nshl```\n and ```\nshr```\n are no more used. I think that modpow can be further optimized, but it's not a critical function because it is called only very few times. The most critical function is modmul, and that seems to be in the best shape possible.\n\nFurther questions:\n\n\nIs there any other option to speedup NTT?\nAre my optimizations of modular arithmetics safe? (Results seem to be the same, but I could miss something.)\n\n\n[edit2] New optimizations\n\n```\na = 0.99991970486 | 2000*32 bits\nlooped 10x\nsqr1[  13.908 ms ] fast sqr\nsqr2[  13.649 ms ] NTT sqr\nmul1[  19.726 ms ] simpe mul\nmul2[  31.808 ms ] karatsuba mul\nmul3[  19.373 ms ] NTT mul\n```\n\n\nI implemented all the usable stuff from all of your comments (thanks for the insight).\n\nSpeedups:\n\n\n+2.5% by removing unnecessary safety mods (Mandalf The Beige)\n+34.9% by use of precomputed W,iW powers (Mysticial)\n+35% total\n\n\nActual full source code:\n\n```\n//---------------------------------------------------------------------------\n//--- Number theoretic transforms: 2.03 -------------------------------------\n//---------------------------------------------------------------------------\n#ifndef _fourier_NTT_h\n#define _fourier_NTT_h\n//---------------------------------------------------------------------------\n//---------------------------------------------------------------------------\nclass fourier_NTT        // Number theoretic transform\n    {\npublic:\n    DWORD r,L,p,N;\n    DWORD W,iW,rN;        // W=(r^L) mod p, iW=inverse W, rN = inverse N\n    DWORD *WW,*iWW,NN;    // Precomputed (W,iW)^(0,..,NN-1) powers\n\n    // Internals\n    fourier_NTT(){ r=0; L=0; p=0; W=0; iW=0; rN=0; WW=NULL; iWW=NULL; NN=0; }\n    ~fourier_NTT(){ _free(); }\n    void _free();                                            // Free precomputed W,iW powers tables\n    void _alloc(DWORD n);                                    // Allocate and precompute W,iW powers tables\n\n    // Main interface\n    void  NTT(DWORD *dst,DWORD *src,DWORD n=0);                // DWORD dst[n] = fast  NTT(DWORD src[n])\n    void iNTT(DWORD *dst,DWORD *src,DWORD n=0);               // DWORD dst[n] = fast INTT(DWORD src[n])\n\n    // Helper functions\n    bool init(DWORD n);                                          // init r,L,p,W,iW,rN\n    void  NTT_fast(DWORD *dst,DWORD *src,DWORD n,DWORD w);    // DWORD dst[n] = fast  NTT(DWORD src[n])\n    void  NTT_fast(DWORD *dst,DWORD *src,DWORD n,DWORD *w2,DWORD i2);\n\n    // Only for testing\n    void  NTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w);    // DWORD dst[n] = slow  NTT(DWORD src[n])\n    void iNTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w);    // DWORD dst[n] = slow INTT(DWORD src[n])\n\n    // Modular arithmetics (optimized, but it works only for p >= 0x80000000!!!)\n    DWORD mod(DWORD a);\n    DWORD modadd(DWORD a,DWORD b);\n    DWORD modsub(DWORD a,DWORD b);\n    DWORD modmul(DWORD a,DWORD b);\n    DWORD modpow(DWORD a,DWORD b);\n    };\n//---------------------------------------------------------------------------\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT::_free()\n    {\n    NN=0;\n    if ( WW) delete[]  WW;  WW=NULL;\n    if (iWW) delete[] iWW; iWW=NULL;\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT::_alloc(DWORD n)\n    {\n    if (n<=NN) return;\n    DWORD *tmp,i,w;\n    tmp=new DWORD[n]; if ((NN)&&( WW)) for (i=0;i<NN;i++) tmp[i]= WW[i]; if ( WW) delete[]  WW;  WW=tmp;  WW[0]=1; for (i=NN?NN:1,w= WW[i-1];i<n;i++){ w=modmul(w, W);  WW[i]=w; }\n    tmp=new DWORD[n]; if ((NN)&&(iWW)) for (i=0;i<NN;i++) tmp[i]=iWW[i]; if (iWW) delete[] iWW; iWW=tmp; iWW[0]=1; for (i=NN?NN:1,w=iWW[i-1];i<n;i++){ w=modmul(w,iW); iWW[i]=w; }\n    NN=n;\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT(DWORD *dst,DWORD *src,DWORD n)\n    {\n    if (n>0) init(n);\n    NTT_fast(dst,src,N,WW,1);\n//    NTT_fast(dst,src,N,W);\n//    NTT_slow(dst,src,N,W);\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT::iNTT(DWORD *dst,DWORD *src,DWORD n)\n    {\n    if (n>0) init(n);\n    NTT_fast(dst,src,N,iWW,1);\n//    NTT_fast(dst,src,N,iW);\n    for (DWORD i=0;i<N;i++) dst[i]=modmul(dst[i],rN);\n//    iNTT_slow(dst,src,N,W);\n    }\n\n//---------------------------------------------------------------------------\nbool fourier_NTT::init(DWORD n)\n    {\n    // (max(src[])^2)*n < p else NTT overflow can ocur!!!\n    r=2; p=0xC0000001; if ((n<2)||(n>0x10000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x30000000/n; // 32:30 bit best for unsigned 32 bit\n//    r=2; p=0x78000001; if ((n<2)||(n>0x04000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x3c000000/n; // 31:27 bit best for signed 32 bit\n//    r=2; p=0x00010001; if ((n<2)||(n>0x00000020)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x00000020/n; // 17:16 bit best for 16 bit\n//    r=2; p=0x0a000001; if ((n<2)||(n>0x01000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x01000000/n; // 28:25 bit\n     N=n;                // Size of vectors [DWORDs]\n     W=modpow(r,    L);  // Wn for NTT\n    iW=modpow(r,p-1-L);  // Wn for INTT\n    rN=modpow(n,p-2  );  // Scale for INTT\n    _alloc(n>>1);        // Precompute W,iW powers\n    return true;\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT_fast(DWORD *dst,DWORD *src,DWORD n,DWORD w)\n    {\n    if (n<=1) { if (n==1) dst[0]=src[0]; return; }\n    DWORD i,j,a0,a1,n2=n>>1,w2=modmul(w,w);\n\n    // Reorder even,odd\n    for (i=0,j=0;i<n2;i++,j+=2) dst[i]=src[j];\n    for (    j=1;i<n ;i++,j+=2) dst[i]=src[j];\n\n    // Recursion\n    NTT_fast(src   ,dst   ,n2,w2);    // Even\n    NTT_fast(src+n2,dst+n2,n2,w2);    // Odd\n\n    // Restore results\n    for (w2=1,i=0,j=n2;i<n2;i++,j++,w2=modmul(w2,w))\n        {\n        a0=src[i];\n        a1=modmul(src[j],w2);\n        dst[i]=modadd(a0,a1);\n        dst[j]=modsub(a0,a1);\n        }\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT_fast(DWORD *dst,DWORD *src,DWORD n,DWORD *w2,DWORD i2)\n    {\n    if (n<=1) { if (n==1) dst[0]=src[0]; return; }\n    DWORD i,j,a0,a1,n2=n>>1;\n\n    // Reorder even,odd\n    for (i=0,j=0;i<n2;i++,j+=2) dst[i]=src[j];\n    for (    j=1;i<n ;i++,j+=2) dst[i]=src[j];\n\n    // Recursion\n    i=i2<<1;\n    NTT_fast(src   ,dst   ,n2,w2,i);    // Even\n    NTT_fast(src+n2,dst+n2,n2,w2,i);    // Odd\n\n    // Restore results\n    for (i=0,j=n2;i<n2;i++,j++,w2+=i2)\n        {\n        a0=src[i];\n        a1=modmul(src[j],*w2);\n        dst[i]=modadd(a0,a1);\n        dst[j]=modsub(a0,a1);\n        }\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT:: NTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w)\n    {\n    DWORD i,j,wj,wi,a;\n    for (wj=1,j=0;j<n;j++)\n        {\n        a=0;\n        for (wi=1,i=0;i<n;i++)\n            {\n            a=modadd(a,modmul(wi,src[i]));\n            wi=modmul(wi,wj);\n            }\n        dst[j]=a;\n        wj=modmul(wj,w);\n        }\n    }\n\n//---------------------------------------------------------------------------\nvoid fourier_NTT::iNTT_slow(DWORD *dst,DWORD *src,DWORD n,DWORD w)\n    {\n    DWORD i,j,wi=1,wj=1,a;\n    for (wj=1,j=0;j<n;j++)\n        {\n        a=0;\n        for (wi=1,i=0;i<n;i++)\n            {\n            a=modadd(a,modmul(wi,src[i]));\n            wi=modmul(wi,wj);\n            }\n        dst[j]=modmul(a,rN);\n        wj=modmul(wj,iW);\n        }\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::mod(DWORD a)\n    {\n    if (a>p) a-=p;\n    return a;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modadd(DWORD a,DWORD b)\n    {\n    DWORD d,cy;\n    //if (a>p) a-=p;\n    //if (b>p) b-=p;\n    d=a+b;\n    cy=((a>>1)+(b>>1)+(((a&1)+(b&1))>>1))&0x80000000;\n    if (cy ) d-=p;\n    if (d>p) d-=p;\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modsub(DWORD a,DWORD b)\n    {\n    DWORD d;\n    //if (a>p) a-=p;\n    //if (b>p) b-=p;\n    d=a-b;\n    if (a<b) d+=p;\n    if (d>p) d-=p;\n    return d;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modmul(DWORD a,DWORD b)\n    {\n    DWORD _a,_b,_p;\n    _a=a;\n    _b=b;\n    _p=p;\n    asm    {\n        mov    eax,_a\n        mov    ebx,_b\n        mul    ebx        // H(edx),L(eax) = eax * ebx\n        mov    ebx,_p\n        div    ebx        // eax = H(edx),L(eax) / ebx\n        mov    _a,edx    // edx = H(edx),L(eax) % ebx\n        }\n    return _a;\n    }\n\n//---------------------------------------------------------------------------\nDWORD fourier_NTT::modpow(DWORD a,DWORD b)\n    {    // b is not mod(p)!\n    int i;\n    DWORD d=1;\n    //if (a>p) a-=p;\n    for (i=0;i<32;i++)\n        {\n        d=modmul(d,d);\n        if (DWORD(b&0x80000000)) d=modmul(d,a);\n        b<<=1;\n        }\n    return d;\n    }\n//---------------------------------------------------------------------------\n//---------------------------------------------------------------------------\n#endif\n//---------------------------------------------------------------------------\n//---------------------------------------------------------------------------\n```\n\n\nThere is still the possibility to use less heap trashing by separating ```\nNTT_fast```\n to two functions. One with ```\nWW[]```\n and the other with ```\niWW[]```\n which leads to one parameter less in recursion calls. But I do not expect much from it (32-bit pointer only) and rather have one function for better code management in the future. Many functions are dormant now (for testing) Like slow variants, ```\nmod```\n and the older fast function (with ```\nw```\n parameter instead of ```\n*w2,i2```\n).\n\nTo avoid overflows for big datasets, limit input numbers to ```\np/4```\n bits. Where ```\np```\n is number of bits per NTT element so for this 32 bit version use max ```\n(32 bit/4 -> 8 bit)```\n input values.\n\n[edit3] Simple string ```\nbigint```\n multiplication for testing\n\n```\n//---------------------------------------------------------------------------\nchar* mul_NTT(const char *sx,const char *sy)\n    {\n    char *s;\n    int i,j,k,n;\n    // n = min power of 2 <= 2 max length(x,y)\n    for (i=0;sx[i];i++); for (n=1;n<i;n<<=1);        i--;\n    for (j=0;sx[j];j++); for (n=1;n<j;n<<=1); n<<=1; j--;\n    DWORD *x,*y,*xx,*yy,a;\n    x=new DWORD[n]; xx=new DWORD[n];\n    y=new DWORD[n]; yy=new DWORD[n];\n\n    // Zero padding\n    for (k=0;i>=0;i--,k++) x[k]=sx[i]-'0'; for (;k<n;k++) x[k]=0;\n    for (k=0;j>=0;j--,k++) y[k]=sy[j]-'0'; for (;k<n;k++) y[k]=0;\n\n    //NTT\n    fourier_NTT ntt;\n    ntt.NTT(xx,x,n);\n    ntt.NTT(yy,y);\n\n    // Convolution\n    for (i=0;i<n;i++) xx[i]=ntt.modmul(xx[i],yy[i]);\n\n    //INTT\n    ntt.iNTT(yy,xx);\n\n    //suma\n    a=0; s=new char[n+1]; for (i=0;i<n;i++) { a+=yy[i]; s[n-i-1]=(a%10)+'0'; a/=10; } s[n]=0;\n    delete[] x; delete[] xx;\n    delete[] y; delete[] yy;\n\n    return s;\n    }\n//---------------------------------------------------------------------------\n```\n\n\nI use ```\nAnsiString```\n's, so I port it to ```\nchar*```\n hopefully, I did not do some mistake. It looks like it works properly (in comparison to the ```\nAnsiString```\n version).\n\n\n```\nsx,sy```\n are decadic integer numbers\nReturns allocated string ```\n(char*)=sx*sy```\n\n\n\nThis is only ~4 bit per 32 bit data word so there is no risk of overflow, but it is slower of course. In my ```\nbignum```\n lib I use a binary representation and use ```\n8 bit```\n chunks per 32-bit WORD for NTT. More than that is risky if ```\nN```\n is big ...\n\nHave fun with this\n    ", "Answer": "\r\nFirst off, thank you very much for posting and making it free to use.  I really appreciate that.\n\nI was able to use some bit tricks to eliminate some branching, rearranged the main loop, and modified the assembly, and was able to get a 1.35x speedup.\n\nAlso, I added a preprocessor condition for 64 bit, seeing as Visual Studio doesn't allow inline assembly in 64 bit mode (thank you Microsoft;  feel free to go screw yourself).\n\nSomething strange happened when I was optimizing the modsub() function.  I rewrote it using bit hacks like I did modadd (which was faster).  But for some reason, the bit wise version of modsub was slower.  Not sure why.  Might just be my computer.\n\n```\n//\n// Mandalf The Beige\n// Based on:\n// Spektre\n// http://stackoverflow.com/questions/18577076/modular-arithmetics-and-ntt-finite-field-dft-optimizations\n//\n// This code may be freely used however you choose, so long as it is accompanied by this notice.\n//\n\n\n\n\n#ifndef H__OPTIMIZED_NUMBER_THEORETIC_TRANSFORM__HDR\n#define H__OPTIMIZED_NUMBER_THEORETIC_TRANSFORM__HDR\n\n#include <string.h>\n\n#ifndef uint32\n#define uint32 unsigned long int\n#endif\n\n#ifndef uint64\n#define uint64 unsigned long long int\n#endif\n\n\nclass fast_ntt                                   // number theoretic transform\n{\n    public:\n    fast_ntt()\n    {\n        r = 0; L = 0;\n        W = 0; iW = 0; rN = 0;\n    }\n    // main interface\n    void  NTT(uint32 *dst, uint32 *src, uint32 n = 0);             // uint32 dst[n] = fast  NTT(uint32 src[n])\n    void INTT(uint32 *dst, uint32 *src, uint32 n = 0);             // uint32 dst[n] = fast INTT(uint32 src[n])\n    // helper functions\n\n    private:\n    bool init(uint32 n);                                     // init r,L,p,W,iW,rN\n    void NTT_calc(uint32 *dst, uint32 *src, uint32 n, uint32 w);  // uint32 dst[n] = fast  NTT(uint32 src[n])\n\n    void  NTT_fast(uint32 *dst, uint32 *src, uint32 n, uint32 w);  // uint32 dst[n] = fast  NTT(uint32 src[n])\n    void NTT_fast(uint32 *dst, const uint32 *src, uint32 n, uint32 w);\n    // only for testing\n    void  NTT_slow(uint32 *dst, uint32 *src, uint32 n, uint32 w);  // uint32 dst[n] = slow  NTT(uint32 src[n])\n    void INTT_slow(uint32 *dst, uint32 *src, uint32 n, uint32 w);  // uint32 dst[n] = slow INTT(uint32 src[n])\n    // uint32 arithmetics\n\n\n    // modular arithmetics\n    inline uint32 modadd(uint32 a, uint32 b);\n    inline uint32 modsub(uint32 a, uint32 b);\n    inline uint32 modmul(uint32 a, uint32 b);\n    inline uint32 modpow(uint32 a, uint32 b);\n\n    uint32 r, L, N;//, p;\n    uint32 W, iW, rN;\n\n    const uint32 p = 0xC0000001;\n};\n\n//---------------------------------------------------------------------------\nvoid fast_ntt::NTT(uint32 *dst, uint32 *src, uint32 n)\n{\n    if (n > 0)\n    {\n        init(n);\n    }\n    NTT_fast(dst, src, N, W);\n    //  NTT_slow(dst,src,N,W);\n}\n\n//---------------------------------------------------------------------------\nvoid fast_ntt::INTT(uint32 *dst, uint32 *src, uint32 n)\n{\n    if (n > 0)\n    {\n        init(n);\n    }\n    NTT_fast(dst, src, N, iW);\n    for (uint32 i = 0; i<N; i++)\n    {\n        dst[i] = modmul(dst[i], rN);\n    }\n    //  INTT_slow(dst,src,N,W);\n}\n\n//---------------------------------------------------------------------------\nbool fast_ntt::init(uint32 n)\n{\n    // (max(src[])^2)*n < p else NTT overflow can ocur !!!\n    r = 2;\n    //p = 0xC0000001;\n    if ((n < 2) || (n > 0x10000000))\n    {\n        r = 0; L = 0; W = 0; // p = 0;\n        iW = 0; rN = 0; N = 0;\n        return false;\n    }\n    L = 0x30000000 / n; // 32:30 bit best for unsigned 32 bit\n    //  r=2; p=0x78000001; if ((n<2)||(n>0x04000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x3c000000/n; // 31:27 bit best for signed 32 bit\n    //  r=2; p=0x00010001; if ((n<2)||(n>0x00000020)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x00000020/n; // 17:16 bit best for 16 bit\n    //  r=2; p=0x0a000001; if ((n<2)||(n>0x01000000)) { r=0; L=0; p=0; W=0; iW=0; rN=0; N=0; return false; } L=0x01000000/n; // 28:25 bit\n    N = n;               // size of vectors [uint32s]\n    W = modpow(r, L); // Wn for NTT\n    iW = modpow(r, p - 1 - L); // Wn for INTT\n    rN = modpow(n, p - 2); // scale for INTT\n    return true;\n}\n\n//---------------------------------------------------------------------------\n\nvoid fast_ntt::NTT_fast(uint32 *dst, uint32 *src, uint32 n, uint32 w)\n{\n    if(n > 1)\n    {\n        if(dst != src)\n        {\n            NTT_calc(dst, src, n, w);\n        }\n        else\n        {\n            uint32* temp = new uint32[n];\n            NTT_calc(temp, src, n, w);\n            memcpy(dst, temp, n * sizeof(uint32));\n            delete [] temp;\n        }\n    }\n    else if(n == 1)\n    {\n        dst[0] = src[0];\n    }\n}\n\nvoid fast_ntt::NTT_fast(uint32 *dst, const uint32 *src, uint32 n, uint32 w)\n{\n    if (n > 1)\n    {\n        uint32* temp = new uint32[n];\n        memcpy(temp, src, n * sizeof(uint32));\n        NTT_calc(dst, temp, n, w);\n        delete[] temp;\n    }\n    else if (n == 1)\n    {\n        dst[0] = src[0];\n    }\n}\n\n\n\nvoid fast_ntt::NTT_calc(uint32 *dst, uint32 *src, uint32 n, uint32 w)\n{\n    if(n > 1)\n    {\n        uint32 i, j, a0, a1,\n        n2 = n >> 1,\n        w2 = modmul(w, w);\n\n        // reorder even,odd\n        for (i = 0, j = 0; i < n2; i++, j += 2)\n        {\n            dst[i] = src[j];\n        }\n        for (j = 1; i < n; i++, j += 2)\n        {\n            dst[i] = src[j];\n        }\n        // recursion\n        if(n2 > 1)\n        {\n            NTT_calc(src, dst, n2, w2);  // even\n            NTT_calc(src + n2, dst + n2, n2, w2);  // odd\n        }\n        else if(n2 == 1)\n        {\n            src[0] = dst[0];\n            src[1] = dst[1];\n        }\n\n        // restore results\n\n        w2 = 1, i = 0, j = n2;\n        a0 = src[i];\n        a1 = src[j];\n        dst[i] = modadd(a0, a1);\n        dst[j] = modsub(a0, a1);\n        while (++i < n2)\n        {\n            w2 = modmul(w2, w);\n            j++;\n            a0 = src[i];\n            a1 = modmul(src[j], w2);\n            dst[i] = modadd(a0, a1);\n            dst[j] = modsub(a0, a1);\n        }\n    }\n}\n\n//---------------------------------------------------------------------------\nvoid fast_ntt::NTT_slow(uint32 *dst, uint32 *src, uint32 n, uint32 w)\n{\n    uint32 i, j, wj, wi, a,\n        n2 = n >> 1;\n    for (wj = 1, j = 0; j < n; j++)\n    {\n        a = 0;\n        for (wi = 1, i = 0; i < n; i++)\n        {\n            a = modadd(a, modmul(wi, src[i]));\n            wi = modmul(wi, wj);\n        }\n        dst[j] = a;\n        wj = modmul(wj, w);\n    }\n}\n\n//---------------------------------------------------------------------------\nvoid fast_ntt::INTT_slow(uint32 *dst, uint32 *src, uint32 n, uint32 w)\n{\n    uint32 i, j, wi = 1, wj = 1, a, n2 = n >> 1;\n\n    for (wj = 1, j = 0; j < n; j++)\n    {\n        a = 0;\n        for (wi = 1, i = 0; i < n; i++)\n        {\n            a = modadd(a, modmul(wi, src[i]));\n            wi = modmul(wi, wj);\n        }\n        dst[j] = modmul(a, rN);\n        wj = modmul(wj, iW);\n    }\n}    \n\n\n//---------------------------------------------------------------------------\nuint32 fast_ntt::modadd(uint32 a, uint32 b)\n{\n    uint32 d;\n    d = a + b;\n\n    if(d < a)\n    {\n        d -= p;\n    }\n    if (d >= p)\n    {\n        d -= p;\n    }\n    return d;\n}\n\n//---------------------------------------------------------------------------\nuint32 fast_ntt::modsub(uint32 a, uint32 b)\n{\n    uint32 d;\n    d = a - b;\n    if (d > a)\n    {\n        d += p;\n    }\n    return d;\n}\n\n//---------------------------------------------------------------------------\nuint32 fast_ntt::modmul(uint32 a, uint32 b)\n{\n    uint32 _a = a;\n    uint32 _b = b;\n\n    // Original\n    uint32 _p = p;\n    __asm\n    {\n        mov eax, _a;\n        mul _b;\n        div _p;\n        mov eax, edx;\n    };\n}\n\n\nuint32 fast_ntt::modpow(uint32 a, uint32 b)\n{\n    //*\n    uint64 D, M, A, P;\n\n    P = p; A = a;\n    M = 0llu - (b & 1);\n    D = (M & A) | ((~M) & 1);\n\n    while ((b >>= 1) != 0)\n    {\n        A = modmul(A, A);\n        //A = (A * A) % P;\n\n        if ((b & 1) == 1)\n        {\n            //D = (D * A) % P;\n            D = modmul(D, A);\n        }\n    }\n    return (uint32)D;\n}\n```\n\n\nNew modmul\n\n```\nuint32 fast_ntt::modmul(uint32 a, uint32 b)\n{\n    uint32 _a = a;\n    uint32 _b = b;   \n\n    __asm\n    {\n    mov eax, a;\n    mul b;\n    mov ebx, eax;\n    mov eax, 2863311530;\n    mov ecx, edx;\n    mul edx;\n    shld edx, eax, 1;\n    mov eax, 3221225473;\n\n    mul edx;\n    sub ebx, eax;\n    mov eax, 3221225473;\n    sbb ecx, edx;\n    jc addback;\n\n            neg ecx;\n            and ecx, eax;\n            sub ebx, ecx;\n\n    sub ebx, eax;\n    sbb edx, edx;\n    and eax, edx;\n            addback:\n    add eax, ebx;          \n    };  \n}\n```\n\n\n[EDIT] \nSpektre, based on your feedback I changed the modadd & modsub back to their original.  I also realized I made some changes to the recursive NTT function I shouldn't have.\n\n[EDIT2]\nRemoved unneeded if statements and bitwise functions.\n\n[EDIT3]\nAdded new modmul inline assembly.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic using fractions\r\n                \r\nI'm stuck on this cryptography problem using multiplication of a whole number and a fraction mod 10.\n\nHere is the equation:\n\n```\n7 * (4/11) mod 10 =?\n```\n\n\nI know I am supposed to convert this to an integer since the mod operator does not work with fractions, but I cannot figure this one out. Obviously,\n\n```\n7 * (4/11) = 28/11,\n```\n\n\nbut I cannot get the mod 10 of a fraction. The instructor wants the exact answer, not a decimal. Any help would be greatly appreciated!\n    ", "Answer": "\r\nHave a look here: \"Is it possible to do modulo of a fraction\" on math.stackexchange.com.\n\nOne natural way to define the modular function is\na (mod b) = a − b ⌊a / b⌋\nwhere ⌊⋅⌋ denotes the floor function. This is the approach used in the influential book Concrete Mathematics by Graham, Knuth, Patashnik.\nThis will give you 1/2(mod3)=1/2.\n\nTo work through your problem, you have ```\na = 7 * (4/11) = 28/11```\n, and ```\nb = 10```\n.\n```\na / b```\n = (28/11)/10 = 0.25454545...\n```\n⌊a/b⌋```\n = 0\n```\nb ⌊a/b⌋```\n = 0 * 0 = 0\n```\na - b ⌊a/b⌋```\n = 28/11 - 0 = 28/11\nThis means your answer is 28/11.\nWolfram Alpha agrees with me and gives ```\n28/11```\n as the exact result. Google also agrees, but gives it as a decimal, 2.54545454.....\nA fraction is an exact answer and not a decimal.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic in VB\r\n                \r\nI have this number x which i need to find in the (40 mod x) = 1\n\na possible answer for x is 3, or 39 as it goes into the number 40 and leaves a remainder of 1.\n\nWhat kind of code would I need if I was to find all possible answers of x?\n    ", "Answer": "\r\nMathematically, to solve ```\n(a mod x) = b```\n, just find all of the divisors of ```\na-b```\n that aren't divisors of ```\na```\n. e.g. for ```\n(40 mod x) = 1```\n, find the divisors of 40 - 1 (i.e. 39), which are 3, 13, and 39. The divisors of 40 are 2, 4, 5, 8, 10, 20, 40. None of the numbers in the first set are in the second, so the solutions are 3, 13, and 19.\n\nFor ```\n(40 mod x) = 5```\n, you find the divisors of 40 - 5 (i.e. 35), which are 5, 7, and 35. 5 is on the list of divisors of 40, but the other two aren't, so the solutions are 7 and 35.\n\nOf course, for such small numbers, it's more work to find all of the factors of ```\na```\n and ```\na-b```\n than it is to simply do all of the trial divisions of ```\na```\n by ```\nx```\n, so the right way to solve your problem is to take exactly the question you asked and put it into code (forgive my VB, I haven't written any in the past 15 years or so...)\n\n```\nfor x = 2 to 39\n   if (40 % x) = 1\n      MsgBox(x)\n   end if\n next\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "recursion for modular arithmetic\r\n                \r\nI'm trying to compute this:\n\n```\nx^y (mod a)\n```\n\n\nUsing recursion as it works better for larger numbers. Here's what I have:\n\n```\npublic int mod (int x, int y, int a){\n\nif(y == 2){\n return x^2%a;\n}\nif(y%2 == 1){\n  return a%m*mod(x , y/2, a);\n}\nif(y%2 == 0 ){\nreturn mod(x, y/2, a);\n}\n\n\n}\n```\n\n\nThe code doesnt work and another issue is the \"missing return statement\" error at the last bracket. What can be done to fix this?\n    ", "Answer": "\r\nIn Java, a function, which return type is not ```\nvoid```\n, must return some value. Unfortunately, the compiler isn't smart enough to understand that your ```\nif```\n statements cover all range of input parameter's values. The compiler assumes that all your conditions can evaluate to ```\nfalse```\n, thus making this function return no value on this case. So it cannot prove the function's correctness, and reports an error.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Python and Modular Arithmetic\r\n                \r\nSuppose ```\na```\n and ```\nb```\n are odd integers. Then ```\na^2 + b^2```\n is either ```\n2```\n or ```\n10```\n modulo ```\n16```\n. My question is the following: Is there a way of writing a script whose assumptions are ```\na%2 == 1```\n and ```\nb%2 == 1```\n so that the output ```\n(a^2 + b^2) % 16```\n gives the tuple ```\n(2,10)```\n?\nEdit: Here's my unsuccessful approach:\n```\ndef test():\naList=[]\nbList=[]\nfor a in range(0,16):\n    for b in range(0,16):\n        if a%2==1 and b%2==1:\n            aList.append(a)\n            bList.append(b)\n            print  a^2+b^2%16\n```\n\nThis of course will not return a tuple. My hope is to output the tuple (2,10).\n    ", "Answer": "\r\nAs I understand, you want to collect the distinct residues modulo 16 of ```\na**2 + b**2```\n (note the ```\n^```\n operator is not what you want here) into a tuple. So instead of printing each residue out, you should add them to a set in order to collect the distinct values. The set can then be converted to a tuple, using ```\nsorted```\n to get them in order:\n```\nresidues = set()\nfor a in range(0, 16):\n    for b in range(0, 16):\n        if a % 2 == 1 and b % 2 == 1:\n            residues.add((a**2 + b**2) % 16)\n\nresidues = tuple(sorted(residues))\nprint(residues)\n```\n\nThe result is ```\n(2, 10)```\n as expected.\nThis code can be simplified somewhat: instead of generating all integers in the range and just keeping the odd ones, you can generate odd integers using a range starting from 1 with a step size of 2; and you can use a set comprehension for brevity.\n```\nresidues = {\n    (a**2 + b**2) % 16\n    for a in range(1, 16, 2)\n    for b in range(1, 16, 2)\n}\n\nresidues = tuple(sorted(residues))\nprint(residues)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Algorithm to determine if number is between two numbers in modular arithmetic\r\n                \r\nI'm trying to write a function that answers the question: if you start counting at ```\na```\n and stop counting at ```\nb```\n, is ```\nc```\n in that range (aka is ```\nc```\n between ```\na```\n and ```\nb```\n).\n\nNormally ```\na < c && c < b```\n would suffice, but I'm in modular arithmetic:\n\n\n\nCounter-clockwise is increasing.\n\nGreen colors: are values for c where the algorithm should indicate true (where c is between a and b)\n\nBlue colors: are values for c where the algorithm should indicate false (where c is not between a and b) (which happens to be the same as where c is between b and a)\n\nThe simple ```\na < c && c < b```\n fails where the range of ```\na```\n and ```\nb```\n crosses over 0.\n\nFor example, say A = 300 and B = 45. If C is 10 then the function should return true: 300, 301, 302 ... 359, 0, 1, 2, 3 ... 8, 9, 10, 11, 12 ... 43, 44, 45. Therefore, 10 is between 300 and 45 in mod 360.\n\nUltimately, what I'm trying to determine is if one hue is between two other hues, where hues are specified in degrees around a color wheel (which is a mod 360 system). It would be great if the answer was in terms of mod n so it would solve the general case and not be specific to my problem though.\n    ", "Answer": "\r\nFirst calculate ```\na mod n```\n, ```\nb mod n```\n, and ```\nc mod n```\n.\n\nIf ```\na < b```\n then we need to check that ```\na < c && c < b```\n. This is the simple case where modular arithmetic doesn't play a huge role.\n\nBecause [a, b] and [b, a] form disjoint regions, instead of trying to deal with the problem of crossing 0, we can test the reverse for cases where ```\nb < a```\n. If ```\nb < c && c < a```\n is true, c is actually between b and a and therefore not between a and b.\n\nCode sample:\n\n```\na = a % n;  // % = mod\nb = b % n;\nc = c % n;\n\nif (a < b) {\n    if (a < c && c < b) return true;\n    else return false;\n} else { // b < a\n    if (b < c && c < a) return false;   // if in [b, a] then not in [a, b]\n    else return true;\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic - competitive programming\r\n                \r\nI saw a lot of competitive programmers writing code with ```\n((a + b) % d + d) % d```\n in C++. Why don't they just use ```\n(a + b) % d```\n? What is that ```\n+ d```\n inside parentheses good for? Does it have something to do with negative numbers?\n\nThanks\n    ", "Answer": "\r\nYes you are correct. Until C++11 the behaviour of the remainder operator ```\n%```\n for negative arguments was left to the implementation, subject to some constraints. And adding ```\nd```\n to the left argument can help that so long as the other terms in that argument sum to greater or equal to ```\n-d```\n, which, in general is not the case. (```\n-a / d```\n multiples of ```\nd```\n for the case of negative ```\na```\n would have been a better additive constant in your particular case.)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "When is the \"Fast Integer Multiplication Using Modular Arithmetic\" (2008) algorithm faster than Schönhage-Strassen algorithm?\r\n                \r\nFrom Wikipedia:\n\n\"Anindya De, Chandan Saha, Piyush Kurur and Ramprasad Saptharishi[11] gave a similar algorithm using modular arithmetic in 2008 achieving the same running time. However, these latter algorithms are only faster than Schönhage–Strassen for impractically large inputs.\" \n\nI would be very interested in the size of such impractically large integers.\n\nMaybe someone did implement both algorithms in a certain way and could do some benchmarks?\n\nThanks\n    ", "Answer": "\r\nFürer's algorithm and it's modular equivalent (DSKS) are very deep research topics and, for now, remain only as academic interest. Nobody actually knows how big the cross-over point is. And in all likeliness it doesn't matter because that cross-over point is likely to be well beyond 64-bit computing limits.\n\nI've implemented Schönhage-Strassen before and I understand how Fürer's algorithm works. So I'm quite familiar with both of them. I can say it's very possible that the cross-over point between Schönhage-Strassen and Fürer's algorithm is so high that a computer capable of holding the parameters will be larger than the size of the observable universe.\n\nThat's the problem when you have complexities that differ by less than a logarithm. It takes exponentially large input sizes to compensate even for small differences in the Big-O constant.\n\nIn this case, Fürer's algorithm is known to have a very very very large Big-O constant.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic using z3\r\n                \r\nI'm trying to prove statements such as the following:\n```\n(assert (=\n    (mod i n)\n    (mod j n)))\n\n(assert (> n 0))\n    \n(assert (not (=\n    (mod (+ i 1) n)\n    (mod (+ j 1) n))))\n\n(check-sat)\n(get-model)\n```\n\nOthers are:\n\n```\n(((i % n) + j) % n) == ((i + j) % n)```\n\n```\n((i - n + 1) % n) == ((i + 1) % n)```\n\n```\n((((a - 1) % n) + 1) % n) == (a % n)```\n\n\nBut z3 does not seem to terminate when proving these statements. Are they beyond the power of z3/smt solvers?\nIf it is the only way I would not mind doing more explicit proof steps, but these rules seem so elementary I would not know where to begin. Even when using induction I quickly run into cases (like the initial example) that I would expect to be true, but which do not seem to be provable with z3.\nI am using z3 4.8.6, for what it's worth. Can anyone shed some light on this why this is hard, or maybe point me in the direction of papers/z3 flags that make this feasible?\n    ", "Answer": "\r\nLong answer short, yes. These sorts of properties are too difficult for SMT solvers to handle. They essentially involve non-linear integer arithmetic, for which there is no decision procedure. The solver has a bunch of built-in heuristics that may or may not answer your query; but more often then not it'll go into an infinite loop as you no doubt observed.\nSee this answer for details:\nHow does Z3 handle non-linear integer arithmetic?\nWhat you can do\nIf you want to stick to a pure push-button solution, there isn't really much you can do. In certain cases, the following line helps:\n```\n(check-sat-using (and-then qfnra-nlsat smt))\n```\n\nThis uses the theory of reals to solve your query (NRA: non-linear real arithmetic-which happens to be decidable), and then sees if the solution is actually integer. Obviously, that does not always work. In particular, any operation like ```\nmod```\n will be difficult to deal with using this strategy.\nIn practice, I recommend proving specific instances of your property instead. That is, run a bunch of cases, fixing ```\nn```\n each time:\n```\n(assert (= n 10))\n```\n\nthen\n```\n(assert (= n 27))\n```\n\netc. Obviously, this will not prove it for all ```\nn```\n, but in a practical system if you pick your values of ```\nn```\n carefully, you can weed out a lot of non-theorems this way.\nIf you really want to prove this for all ```\nn```\n, then use a theorem prover instead. Obviously that won't be push-button, but that's the state of the art. There are many choices here: Isabelle, HOL, HOL-Light, ACL2, Coq, Lean, .. to name a few. Note that most of these theorem provers have built in tactics that utilize SMT solvers under the hood to discharge many of the sub-goals. So, you kind of have the best of both worlds, though of course the proof itself requires manual decomposition in such systems.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetic addition and subtraction using Crypto++\r\n                \r\nI am very new to this, but I am trying to add two Integers in modular format using Crypto++ Library.\n\nMy program is very simple,\n\n```\nAutoSeededRandomPool prng;\nInteger r0, m;\n\nm = Integer( prng, 64);\nr0 = Integer( prng, 64);\n\ncout << \"m: \" << std::hex << m << endl;\ncout << \"r0:\" << std::hex << r0 << endl;\n\nInteger n1(r0 + m);\n```\n\n\nBut this simply didn't work. It complied fine, but it crashed when I was trying to run it.\n\nCould anyone give a sample code for addition/subtraction using Crypto++ please\n    ", "Answer": "\r\n\n  Modular Arithmetic (addition/subtraction) using Crypto++\n\n\nWe have closed some of the missing documentation gaps based on this question, so I won't address the sample code. The improved docs are available at Integer Class Reference and Integer on the Crypto++ wiki.\n\nHowever, there may be a bug or (at least) unexpected results from using the ModularArithmetic class. The class describes itself as \"Ring of congruence classes modulo n\". Mathematically, a Ring is a group with closure and two well defined operations.\n\nThe disconnect is, which two operations are the ones included with ```\nModularArithmetic<Integer>```\n. Based on some sample code, it looks like its ```\nMultiply```\n and ```\nExponentiate```\n, which is mostly expected (though it could have been ```\nAdd```\n and ```\nMultiply```\n).\n\nI don't think the mathematical definition of Ring gives ```\nModularArithmetic```\n a license to produce unexpected results. However, ```\nModularArithmetic```\n is kind of unique, and it may be accumulating intermediate results that one must then reduce using ```\nMultiply```\n and ```\nExponentiate```\n. (It does accumulate results to speed up operations).\n\nThe open question for me is, what do we do... I'm trying to solicit some feedback at the moment on the issue.\n\n\n\nHere's the test program:\n\n```\nint main(int argc, char* argv[])\n{\n  Integer m(\"4294967295\"), n(\"0x1000000000000000000000000000000\"), j;\n  j = 1999;\n\n  ModularArithmetic ma(j);\n\n  cout << \"n+m mod j: \" << ma.Add(n, m) << endl;\n  cout << \"  cross-check: \" << (n+m) % j << endl;\n  cout << \"n-m mod j: \" << ma.Subtract(n, m) << endl;\n  cout << \"  cross-check: \" << (n-m) % j << endl;\n  cout << \"n*m mod j: \" << ma.Multiply(n, m) << endl;\n  cout << \"  cross-check: \" << (n*m) % j << endl;\n  cout << \"n/m mod j: \" << ma.Divide(n, m) << endl;\n  cout << \"  cross-check: \" << (n/m) % j << endl;\n  cout << \"n%m mod j: \" << ma.Reduce(n, m) << endl;\n  cout << \"  cross-check: \" << (n%m) % j << endl;\n  cout << \"n^m mod j: \" << ma.Exponentiate(n, m) << endl;\n  cout << \"  cross-check: \" << a_exp_b_mod_c(n,m,j) << endl;\n\n  return 0;\n}\n```\n\n\nHere are the results:\n\n```\n$ ./test.exe \nn+m mod j: 1329227995784915872903807064575309872.\n  cross-check: 1755.\nn-m mod j: 1329227995784915872903807055985377281.\n  cross-check: 50.\nn*m mod j: 266.\n  cross-check: 266.\nn/m mod j: 599.\n  cross-check: 1997.\nn%m mod j: 1329227995784915872903807055985377281.\n  cross-check: 1608.\nn^m mod j: 1326.\n  cross-check: 1326.\n```\n\n\n\n\nEDIT 1\n\n\n  The disconnect is, which two operations are the ones included with ```\nModularArithmetic<Integer>```\n...\n\n\nSo I had a chance to go though the source code and add more missing documentation. Of particular interest is ```\nAbstractRing< T >```\n Class Template Reference, which ```\nModularArithmetic```\n inherits from. It confirms that multiply and exponentiation are the operations (and it gives rise to helpers, like ```\nSquare```\n).\n\nWhat I am not clear about is why ```\nModularArithmetic```\n is providing ```\nAdd```\n, ```\nSubtract```\n and friends but arriving at unexpected results. It could well be that its effectively accumulating the results and waiting to be reduced with a ```\nMultiply```\n or ```\nExponentiate```\n, but I don't see any comments in the source code.\n\n\n\nEDIT 2\n\nThe reason ```\nModularArithmetic```\n appears to produce incorrect results for ```\nAdd```\n, ```\nSubtract```\n and friends is the class is meant to be fast for specific problems, and it does not perform a full reduction using the Euclidean extended algorithm. Rather, it performs at most one subtraction. That means the accumulated value ```\nn```\n to be reduced by the modulus ```\np```\n must be in the range ```\n[0, 2p)```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "modular arithmetic puzzle codeforces\r\n                \r\nA car moves from point A to point B at speed v meters per second. The action takes place on the X-axis. At the distance d meters from A there are traffic lights. Starting from time 0, for the first g seconds the green light is on, then for the following r seconds the red light is on, then again the green light is on for the g seconds, and so on.\n\nThe car can be instantly accelerated from 0 to v and vice versa, can instantly slow down from the v to 0. Consider that it passes the traffic lights at the green light instantly. If the car approaches the traffic lights at the moment when the red light has just turned on, it doesn't have time to pass it. But if it approaches the traffic lights at the moment when the green light has just turned on, it can move. The car leaves point A at the time 0.\n\nWhat is the minimum time for the car to get from point A to point B without breaking the traffic rules?\n\nInput\n integers l, d, v, g, r (1 ≤ l, d, v, g, r ≤ 1000, d < l) — the distance between A and B (in meters), the distance from A to the traffic lights, car's speed, the duration of green light and the duration of red light.\n\nsolution\n\n```\nif(g*v>d)\n ans = l/v   // i got it\nelse\n ceil(d/v/g+r)*(g+r)+(l-d)/v  // i am not getting Please help\n```\n\n\nExample->suppose l=5 ,d=4,v=1,g=2 ,r=1\n\nAt t=0 car starts from $A $\n\nAt t=2 light become red but car is far away from light so no problem keep moving\n\nAt t=3 light becomes green again for $2$ sec (till $t=5$) \n\nAt t=4 light is green still  and we reach at light\n\nNote-> we have cross the traffic light  don't worry\n\nAt t=5 we reach at point B\n\nBut correct ans = 7 which is not minimum where I am doing wrong ?\n\nAbove approach was used by a red coder and I am including the his solution link below also.\n\nPlease help I am  feeling sad I am trying to find the correct logic from 3 days.\n\nHere you people  are my last hope.\n\nProblem linkproblem b\n\nAccepted solution link of red coder\n\nNote-> the above accepted solution giving 7 as output But I think it should be 5.So this can't be wrong since codeforces accepted it. \n    ", "Answer": "\r\nYes you are right, the answer should be 5.\n\nThe condition ```\ng * v > d```\n doesn't make any sense. It just checks if you can pass the traffic light during the first green phase. Actually it should be ```\n((d + v - 1) / v) % (g + r) < g```\n. First we calculate on which second we pass the traffic light with ```\n(d + v - 1) / v```\n (integer division) which is the same as ```\nceil(d / v)```\n if we are using floating point numbers. Then with the modulo we calculate where in the green red cycle we pass the traffic light. If the result is ```\n< g```\n we passed it when it was green and the solution is ```\n(double)l / v```\n.\n\nYou could use the same technique with the modulo as above to get the number of seconds we have to stop at the traffic light and then add the times from start to the traffic light (whole seconds) and the time from the traffic light to the destination. Or we can calculate the number of seconds we need until the end of the green red cycle when passing the traffic light. This is what you did, but you are missing braces, so for floating point numbers we could use your formula with additional braces: ```\nceil(d / v / (g + r)) * (g + r) + (l - d) / v```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Time complexity of modular arithmetic\r\n                \r\nSay I wanted to calculate a (mod n). What is the time complexity of this? I'm using Matlab, and am not sure how Matlab calculates it. Does it divide a by n, subtract the integer part, and then multiply by n?\n\nDoes it make sense to ask 'what is the time complexity of this'?\n    ", "Answer": "\r\nIt makes sense to ask about the time complexity for long numbers ```\na```\n and/or ```\nn```\n. The related field is called Computational Number Theory. For example, see this book. \n\nThe usual integer arithmetic, which most likely is used by Matlab, is an ALU operation (or multiple operations) performed in a constant time. In this case, one has to remember that the size of the integer is restricted. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Design patterns for dynamic-context-dependent operators (e.g. for modular arithmetic)? [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 6 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nThis is a certain software engineering and language design problem I've constantly run into that I don't have a good solution for in any language. I'm most interested in a C++ solution, but solutions in other (hopefully lexically-scoped) languages would also be interesting to consider.\nHere's an example. Let's say I have some piece of code, like maybe this:\n```\ntemplate<class T, class F>\nT foo(T a, T b, T c, T d, F func) { return func() / (a * d - b * c); }\n```\n\nI argue that the caller should be able to use ```\nfoo```\n with modular arithmetic as well as regular arithmetic.\nIn other words, for an appropriate definition of ```\nfinite_field```\n, in an ideal world, this should evaluate the code above in a finite field rather than in the field of real numbers:\n```\nint main(int argc, char *argv[])\n{\n    finite_field<int> scoped_field(argc /* let's say this is my modulus */);\n    return foo(1, 2, 3, 4, []{ return +1; }) + foo(4, 3, 2, 1, []{ return -1; });\n}\n```\n\nYet, clearly, this doesn't work, because nothing inside ```\nfoo```\n (and specifically, none of the operators) is aware of the arithmetic context imposed by ```\nscoped_field```\n.\nAll the solutions I'm aware of are quite ugly:\n\nStop using arithmetic operators altogether.\nUse ```\nadd(x, y)```\n instead of ```\nx + y```\n, ```\ndiv(x, y)```\n instead of ```\nx / y```\n, etc.\nThen maybe put all of these inside an ```\nArithmetic```\n class of some sort and use ```\nthis```\n to access the current \"arithmetic context\".\nPros: It works, and doesn't require storing excess data.\nCons: Requires editing ```\nfoo```\n, which arguably should not be necessary, and at the same time makes it much less pleasing and much more difficult to read and write.\n\nDefine a custom ```\nModInt```\n type that wraps an ```\nint```\n, store the modulus inside each number, and overload the operator for that type to read the modulus from one of it input arguments.\nPros: It works, and it doesn't require modifying the body of ```\nfoo```\n.\nCons: Inefficient and error-prone -- each modulus is stored inside each integer, meaning there's potential for conflict bugs at runtime, as well as an obvious O(n) space inefficiency. Not to mention that the evaluation context isn't a property of the numbers, but rather a property of the operators themselves.\n\nStore the \"current context\" inside a thread-local variable, and overload the operators to behave differently depending on the context.\nPros: It works (kind of). And it doesn't waste space or require modifying ```\nfoo```\n.\nCons: Ugly, less portable, and either non-reentrant or error-prone depending on how it's implemented (it'd contaminate callees' arithmetic operator contexts)\n\n\nSo, I literally don't know of any solution that is readable, portable, and maintainable.\nIt seems like I fundamentally have to give up one of those, as far as I can tell.\n\nMy questions:\n\nIs this a commonly-encountered or well-known problem?\n\nDoes it have an elegant solution in any reasonably popular language? If so, which ones, and how?\n\nCan it specifically be solved in C++? Is there some kind of a design pattern or idiom for it?\n\n\n    ", "Answer": "\r\n\nNope.\nNo idea. Try tagging every reasonably popular language. I'm sure that nobody would have a problem.\nWhy in God's name should there be a pattern or idiom to cover every possible problem everybody might find in a language? Why should every solution suddenly become a pattern or idiom? Can't it just be a solution to a problem? Seriously.\n\n\nThat said, a small modification to ```\nfoo```\n can probably yield the desired result.\n\n```\ntemplate<typename T, typename F, typename F2>\nT foo(T a, T b, T c, T d, F func, F2 mod) { return func() / (mod(a) * d - mod(b) * c); }\n\nint main(int argc, char *argv[])\n{\n    auto mod = [](int i) { return ModInt(i, modulus); };\n    return foo(1, 2, 3, 4, []{ return +1; }, mod) + foo(4, 3, 2, 1, []{ return -1; }, mod);\n}\n```\n\n\nSince every use of ```\nmod```\n uses the same local, it's impossible for ```\nModInt```\n to ever have different modulos. And since ```\nmod```\n is only invoked when operator precedence and such requires it and any locals are destroyed and their storage re-used, then we're golden w.r.t. storage space. (Also, seriously, a few integers on the stack? Not a big deal.)\n\nBut inherently, modulo arithmetic is a property of the operators involved. That is how it is defined and how it works. You can hack around it but no matter what you do, it's gonna suck at least a little. You need a user-defined operator but you can't pass a user-defined function for two primitive types implicitly, and nor should you be able to.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How do I extract a number from a text file and perform modular arithmetic?\r\n                \r\nHi this is from a newbie programmer using python so bear with me.  I'm trying make use of the mod function in python '%' to extract factors from a formula 2^p-1 when 'p' is prime and the formula 2^p-1 produces a factor.\nFor instance when p=11 2^p-1=2047 so the first factor if using modular '%' would be 23.  Factors in general when 'p' is prime and using 2^p-1 are prime themselves.\nMy question is if I use a large text file loaded with prime numbers, is it possible to quickly access a number and perform a modular arithmetic using it to find a factor for 2^p-1?  My code that I have is poor and it throws an error, can anyone correct it for me?  Here is my code in python 3.7!\nThis is my text file k.txt:\nk=(3,5,7,11,13,17,19,23, 47, 223, 233)\nThis is my error:\n\nFile \"Factor This.py\", line 6, in  if (2**p-1) %\n(open(\"C:\\python37\\k.txt\"),'r') == 0: TypeError: unsupported operand\ntype(s) for %: 'int' and 'tuple'\n\n```\n import timeit\n while True:\n     p = int(input(\"Enter a prime number: \"))\n     start_time = timeit.default_timer()\n     for k in range(3,300,2):\n         if (2**p-1) % (open(\"C:\\python37\\k.txt\"),'r') == 0:\n             print(k)\n             print(timeit.default_timer() - start_time,'seconds')\n             break\n```\n\n    ", "Answer": "\r\nThis simple method should work:\n```\np = int(input(\"Enter a prime number: \"))\n\nwith open(\"C:\\python37\\k.txt\",'r') as f:\n    primes = f.read().split(\"(\")[1].split(')')[0].split(',')  # int list of primes\n    primes = [int(i.strip()) for i in primes]\n    for prime in primes:\n        if (2**p - 1) % int(prime) == 0:\n            print(prime)\n            break\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Efficient reasoning in modular arithmetic\r\n                \r\nI decided to prove the following theorem:\n```\ntheory Scratch\n  imports Main\nbegin\n\nlemma \"(3::int)^k mod 4 = 1 ⟷ even k\"\nproof (cases \"even k\")\n  case True\n    then obtain l where \"2*l = k\" by auto\n    then show ?thesis\n      using power_mult [of \"(3::int)\" 2 l]\n      and power_mod [of \"(9::int)\" 4 l] by auto\nnext\n  case False\n    then obtain l where \"2*l + 1 = k\" using odd_two_times_div_two_succ by blast\n    then have \"(3::int)^k mod 4 = 3\"\n      using power_mult [of \"(3::int)\" 2 l ]\n      and mod_mult_right_eq [of \"(3::int)\" \"9^l\" 4]\n      and power_mod [of \"(9::int)\" 4 l]\n      by auto\n    then show ?thesis using `odd k` by auto\nqed\n\nend\n```\n\nThe proof is accepted by Isabelle, but to my taste, there is way too much trivial detail as to how calculations ```\nmod 4```\n are performed:\n```\n    then have \"(3::int)^k mod 4 = 3\"\n      using power_mult [of \"(3::int)\" 2 l ]\n      and mod_mult_right_eq [of \"(3::int)\" \"9^l\" 4]\n      and power_mod [of \"(9::int)\" 4 l]\n      by auto\n```\n\nApart from the application of ```\npower_mult```\n, this is only application of various rules on what\nparts of expressions may be safely reduced. Is there a proof method that can infer detail like this automatically?\n(I'm also open to any other comments about my proof style - one thing that bothers me is the repetitive ```\n::int```\n)\n    ", "Answer": "\r\nFollowing some discussion on IRC and subsequent experimentation, I have learned the following:\nFirstly, the ```\na mod c = b mod c```\n is somewhat verbose. ```\nHOL-Number_Theory.Cong```\n defines the notation ```\n[a = b] (mod c)```\n, which is much more pleasant to use.\n```\ntheory Scratch\n  imports\n    Main\n    \"HOL-Number_Theory.Cong\" (* or \"HOL-Number_Theory.Number_Theory\",\n                                but that requires some more computation *)\nbegin\n```\n\n(note that this will make Isabelle compile the theory, which can take some time. You might want to run ```\nisabelle jedit -l HOL-Number_Theory```\n, so that this happens only once.)\nA one-line proof of the theorem will still require manually instantiating the relevant lemmas. However, it is usually a better idea to spell out the steps some more. This will allow the tactics to infer how the theorems should be instantiated, while leaving more useful detail for the human.\n```\nproof (cases \"even k\")\n  case True\n  then obtain l where \"2*l = k\" by auto\n  then have \"[3^k = (3^2)^l] (mod 4)\" (is \"cong _ ... _\")\n    by (auto simp add: power_mult)\n  also have \"[... = (1::int)^l] (mod 4)\" (is \"cong _ ... _\")\n    by (intro cong_pow) (simp add: cong_def)\n  also have \"[... = 1] (mod 4)\" by auto\n  finally have \"[3^k = 1::int] (mod 4)\".\n  thus ?thesis using `even k` by blast\nnext\n  case False\n  then obtain l where \"2*l + 1 = k\"\n    using oddE by blast\n  then have \"[3^k = 3^(2*l+1)] (mod 4)\" (is \"cong _ ... _\") by auto\n  also have \"[... = (3^2)^l * 3] (mod 4)\" (is \"cong _ ... _\")\n    by (metis power_mult power_add power_one_right cong_def)\n  also have \"[... = (1::int)^l * 3] (mod 4)\" (is \"cong _ ... _\")\n    by (intro cong_mult cong_pow) (auto simp add: cong_def)\n  also have \"[... = 3] (mod 4)\" by auto\n  finally have \"[3^k ≠ 1::int] (mod 4)\" by (auto simp add: cong_def)\n  then show ?thesis using `odd k` by blast\nqed\n```\n\nThis is a pretty standard calculational proof, where we use ```\n...```\n to refer to the RHS of the previous command. By default, it refers to the last argument of the top-level function application. In this case, that would be the modulus, so we override it with ```\n(is \"cong _ ... _\")```\n.\nAlso note that we can avoid a large part of the work by reusing ```\nminus_one_power_iff```\n:\n```\nlemma \"[3^k = 1::int] (mod 4) ⟷ even k\"\nproof -\n  have \"[3^k = (-1::int)^k] (mod 4)\"\n    by (intro cong_pow) (auto simp: cong_def)\n  thus ?thesis\n    by (auto simp: cong_def minus_one_power_iff)\nqed\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Optimising code for modular arithmetic\r\n                \r\nI am trying to calculate below expression for large numbers.\n\n\n\nSince the value of this expression will be very large, I just need the value of this expression modulus some prime number.  Suppose the value of this expression is ```\nx```\n and I choose the prime number ```\n1000000007```\n; I'm looking for ```\nx % 1000000007```\n.\n\nHere is my code.\n\n```\n#include<iostream>\n#define MOD 1000000007\nusing namespace std;\nint main()\n{\n    unsigned long long A[1001];\n    A[2]=2;\n    for(int i=4;i<=1000;i+=2)\n    {\n        A[i]=((4*A[i-2])/i)%MOD;\n        A[i]=(A[i]*(i-1))%MOD;\n\n    while(1)\n    {\n        int N;\n        cin>>N;\n        cout<<A[N];\n    }\n}\n```\n\n\nBut even this much optimisation is failing for large values of N.  For example if N is 50, the correct output is ```\n605552882```\n, but this gives me ```\n132924730```\n. How can I optimise it further to get the correct output?\n\nNote : I am only considering N as even.\n    ", "Answer": "\r\nWhen you do modular arithmetic, there is no such operation as division. Instead, you take the modular inverse of the denominator and multiply. The modular inverse is computed using the extended Euclidean algorithm, discovered by Etienne Bezout in 1779:\n\n```\n# return y such that x * y == 1 (mod m)\nfunction inverse(x, m)\n    a, b, u := 0, m, 1\n    while x > 0\n        q, r := divide(b, x)\n        x, a, b, u := b % x, u, x, a - q * u\n    if b == 1 return a % m\n    error \"must be coprime\"\n```\n\n\nThe ```\ndivide```\n function returns both quotient and remainder. All of the assignment operators given above are simultaneous assignment, where all of the right hand sides are computed first, then all of the left hand sides are assigned simultaneously. You can see more about modular arithmetic at my blog.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "UVA 369-Combinations | Modular Arithmetic | Binary Exponentiation [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs debugging details. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Edit the question to include desired behavior, a specific problem or error, and the shortest code necessary to reproduce the problem. This will help others answer the question.\r\n                \r\n                    \r\n                        Closed 3 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying to solve uVa's 369(Combinations) problem using Modular Arthimetic and Binary Exponentiation instead of just using BigInteger class in java. I am able to pass the last two base test cases but not the first test case. Can anybody explain where my code is wrong ? \n\n```\npublic class Main {\n    static long M = 1000000007;\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        while(true){\n            String s = br.readLine();\n            s = s.trim();\n            s = s.replaceAll(\"\\\\s{2,}\", \" \");\n            String[] str = s.split(\" \");\n            long n = Long.parseLong(str[0]);\n            long m = Long.parseLong(str[1]);\n            if(n == 0 && m == 0) break;\n            long a = fact(n); long b = fact((n-m) % M); long c = fact(m);\n            long d = (b*c) % M;\n            long ans = divide(a,d);\n            System.out.println(n + \" things taken \" + m + \" at a time is \" + ans + \" exactly\");\n        }\n    }\n    public static long fact(long N){\n        long ans = 1;\n        for(int i=1; i<=N; ++i)\n            ans = (ans * i) % M;\n        return ans;\n    }\n    public static long divide(long a, long b){\n        return a * pow(b,M-2) % M;\n    }\n    public static long pow(long a, long b){\n        long res = 1;\n        while(b > 0){\n            if(b % 2 == 1) res = (res*a) % M;\n            a = (a*a) % M;\n            b /=2;\n        }\n        return res;\n    }\n}\n\n```\n\n    ", "Answer": "\r\n```\nM```\n is too small. For example for the input ```\n100 6```\n, the correct result is 1192052400, but since your code works modulo 1000000007 the result will be 1192052400 mod 1000000007 = 192052393, which is much smaller (not just 7 smaller).\n\nUsing ```\nM = 0x7fffffff```\n (also a prime) may work.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic: Division over factorials % Prime\r\n                \r\nI want to efficiently calculate ((X+Y)!/(X!Y!))% P (P is like 10^9+7)\n\nThis discussion gives some insights on distributing modulo over division. \nMy concern is it's not necessary that a modular inverse always exists for a number.\nBasically, I am looking for a code implementation of solving the problem. \n\nFor multiplication it is very straightforward: \n\n```\npublic static int mod_mul(int Z,int X,int Y,int P)\n{\n// Z=(X+Y) the factorial we need to calculate, P is the prime\nlong result = 1;\nwhile(Z>1)\n  {\n    result = (result*Z)%P\n    Z--;\n  }\nreturn result;\n}\n```\n\n\nI also realize that many factors can get cancelled in the division (before taking modulus), but if the number of divisors increase, then I'm finding it difficult to efficiently come up with an algorithm to divide. ( Looping over List(factors(X)+factors(Y)...) to see which divides current multiplying factor of numerator).\n\nEdit: I don't want to use BigInt solutions.\n\nIs there any java/python based solution or any standard algorithm/library for cancellation of factors( if inverse option is not full-proof) or approaching this type of problem. \n    ", "Answer": "\r\n```\n((X+Y)!/(X!Y!))```\n is a low-level way of spelling a binomial coefficient (```\n(X+Y)-choose-X```\n).  And while you didn't say so in your question, a comment in your code implies that ```\nP```\n is prime.  Put those two together, and Lucas's theorem applies directly:  http://en.wikipedia.org/wiki/Lucas%27_theorem.\n\nThat gives a very simple algorithm based on the base-```\nP```\n representations of ```\nX+Y```\n and ```\nX```\n.  Whether ```\nBigInts```\n are required is impossible to guess because you didn't give any bounds on your arguments, beyond that they're ```\nint```\ns.  Note that your sample ```\nmod_mul```\n code may not work at all if, e.g., ```\nP```\n is greater than the square root of the maximum ```\nint```\n (because ```\nresult * Z```\n may overflow then).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Does compound assignment of two unsigned integers of the same type always operate as if using that type's modular arithmetic?\r\n                \r\nHere is a conjecture:\nFor expression ```\na op b```\n where ```\na```\n and ```\nb```\n are of the same unsigned integral type ```\nU```\n, and ```\nop```\n is one of the compound assignment operators (```\n+=```\n,```\n-=```\n,```\n*=```\n,```\n/=```\n,```\n%=```\n,```\n&=```\n,```\n|=```\n,```\n^=```\n,```\n<<=```\n,```\n>>=```\n), the result is computed directly in the value domain of ```\nU```\n using modular arithmetic, as if no integral promotions or usual arithmetic conversions, etc. are performed at all.\nIs this true? What about signed integral types?\nTo clarify: By definition integral promotions and usual arithmetic conversions do apply here. I'm asking if the result is the same as not applying them.\nI'm looking for an answer in C++, but if you can point out the difference with C, it would also be nice.\n    ", "Answer": "\r\nCounter example:\n```\nint```\n has width ```\n31```\n plus one bit for sign, ```\nunsigned short```\n has width ```\n16```\n. With ```\na```\n and ```\nb```\n of type ```\nunsigned short```\n, after integral promotions, the operation is performed in ```\nint```\n.\nIf ```\na```\n and ```\nb```\n have value ```\n2^16 - 1```\n, then the mathematical exact result of ```\na * b```\n in the natural numbers would be ```\n2^32 - 2^17 + 1```\n. This is larger than ```\n2^31 - 1```\n and therefore cannot be represented by ```\nint```\n.\nArithmetic overflow in signed integral types results in undefined behavior. Therefore ```\na *= b```\n has undefined behavior. It would not have this undefined behavior if unsigned arithmetic modulo ```\n2^width(unsigned short)```\n was used.\n(Applies to all C and C++ versions.)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "What are the rules for modular arithmetic in C?\r\n                \r\nIn earlier classes, I was taught that ```\nn % d = r```\n and to think about it as ```\nn = d*q + r```\n, where ```\nd```\n is the divisor, ```\nq```\n is the quotient, and ```\nr```\n is the remainder (noting that the remainder can never be negative). \n\nSo for instance, ```\n-111 mod 11```\n is ```\n10```\n, because ```\n-111 = -11*-11 + 10```\n (as opposed to ```\n-111 = -11*10 -1```\n, seeing as how that would give us a negative remainder). \n\nHowever, when printing the results of ```\n-111 % 11```\n, ```\n-1```\n is the result and not ```\n10```\n. Why? Isn't this technically wrong? \n    ", "Answer": "\r\nShort Answer:\n\nThe standard guarantee that ```\n(a/b)*b + a%b```\n is equal to ```\na```\n.\n\nIn C99, the result of division ```\n/```\n will truncated toward zero. The result of ```\n%```\n operator will be certain, in this case, ```\n-1```\n.\n\nIn C89, the result of division ```\n/```\n can be truncated either way for negative operands. So the result of ```\n%```\n operator is machine-dependent as well.\n\nLong Answer:\n\nFrom C99 6.5.5\n\n\n  5 The result of the / operator is the quotient from the division of the first operand by the\n  second; the result of the % operator is the remainder. In both operations, if the value of\n  the second operand is zero, the behavior is undefined.\n  \n  6 When integers are divided, the result of the / operator is the algebraic quotient with any\n  fractional part discarded. If the quotient a/b is representable, the expression\n  (a/b)*b + a%b shall equal a; otherwise, the behavior of both a/b and a%b is\n  undefined.\n\n\nAnd the footnote on the same page to explain how ```\n/```\n works, it says:\n\n\n  This is often called ‘‘truncation toward zero’’.\n\n\nAccording to this rule, ```\n-111 / 11```\n can only be ```\n-10```\n, not 1. Since ```\n(a/b)*b + a%b```\n must be equal to ```\na```\n, we have ```\n-111 % 11```\n is ```\n-1```\n.\n\nHowever, K&R Chapter 2.5 gives a different answer:\n\n\n  The direction of truncation for / and the sign of the result for % are machine-dependent for negative operands, as is the action taken on overflow or underflow.\n\n\nAccording to this, either ```\n-1```\n or ```\n10```\n can be a legal result. \n\nThe reason is in C89 3.3.5:\n\n\n  When integers are divided and the division is inexact, if both operands are positive the result of the / operator is the largest integer less than the algebraic quotient and the result of the % operator is positive. If either operand is negative, whether the result of the / operator is the largest integer less than the algebraic quotient or the smallest integer greater than the algebraic quotient is implementation-defined, as is the sign of the result of the % operator. If the quotient a/b is representable, the expression (a/b)*b + a%b shall equal a .\n\n\nIt turns out to be a change from C89 to C99.\n\nC99 Rationale 6.5.5 provides some historical reasons:\n\n\n  In C89, division of integers involving negative operands could round upward or downward in an implementation-defined manner; the intent was to avoid incurring overhead in run-time code to check for special cases and enforce specific behavior. In Fortran, however, the result will always truncate toward zero, and the overhead seems to be acceptable to the numeric programming community. Therefore, C99 now requires similar behavior, which should facilitate porting of code from Fortran to C. The table in §7.20.6.2 of this document illustrates the required semantics.\n\n\nAnd here's the table in §7.20.6.2:\n\n```\nnumer denom quot rem\n 7      3    2    1\n–7      3   –2   –1\n 7     –3   –2    1\n–7     –3    2   –1\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Regular expression involving modular arithmetic\r\n                \r\nI'm trying to create DFA or regular expression for the language\n\n\n  L = {an bm | n mod 3 = m mod 3}`\n\n\nFor example, L contains the strings aaabbb, aaabbbbbb, and abbbb.\n\nHowever, I'm getting stuck making any progress at all here. How can I accomplish this?\n    ", "Answer": "\r\nThere are only three possible remainders modulo three. You can build a regular expression for the language by listing off regular expressions that handle each of the three cases, then unioning them together. Here's one possible answer:\n\n```\n(aaa)*(bbb)* | a(aaa)*b(bbb)* | aa(aaa)*bb(bbb)*\n```\n\n\nHope this helps!\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Python Advanced Modular Arithmetic Algorithm\r\n                \r\nI have this program:\n\n```\n#!/usr/bin/python3\ndef bounce(modulo: int, here: int, add: int) -> int:\n    # additive version\n    # modulo = 2n > 0, 0 <= here < n, add is any integer\n    # cycle {\n    #   {0, 1, 2, 3, ..., n - 1, n - 2, n - 3, ...,\n    #    0, 1, 2, 3, ..., n - 1, n - 2, n - 3, ...},\n    #   {0, 1, 2, 3, ..., n - 1, n - 2, n - 3, ...,\n    #    0, 1, 2, 3, ..., n - 1, n - 2, n - 3, ...},\n    #   ...\n    # }\n    tmp = abs(here + add) % (2 * modulo)\n    if tmp <= modulo:\n        tmp *= -1\n        tmp -= 1\n    tmp %= modulo\n    return tmp\n\n\nm = abs(int(input('Modulus: '))) + 1\ni = abs(int(input('Iterate: '))) + 1\n\nh: int = 0\nm2: int = 3 * m\n\nfor x in range(1, 1 + i):\n    print(h, end = ('\\n' if x % m2 == 0 else ', '))\n    h = bounce(m, h, 1)\n\ninput('Done.')\n```\n\n\nFor some reason, niether the ```\nbounce()```\n function or its testing code is working.  I don't know why.  For example, if I enter ```\n6```\n for the modulus and ```\n4```\n for the iteration variable ```\ni```\n, the program should print 5 lines of ```\n0, 1, 2, 3, 4, 5, 4, 3, 2, 1, 0```\n.  Instead, I'd be seeing 2 lines of ```\n6, 0, 6, 0, ...```\n.  The answer is likely simple.  I've just bashed my brains against this ```\nbounce()```\n function so many times that I can't see it.  The signage of the ```\nadd```\n parameter is tripping me up.\n    ", "Answer": "\r\nYou probably do not need to generate the entire sequence, following is an implementation of a closed form that calculates and returns the index in a sequence of a given size you wish to iterate over in a go-and-back cycle fashion:\n\nYou can start at any point in time, including the past (negative time), and obtain where in the sequence (index) you are, without the need to iterate or build the entire sequence.\n\n```\ndef bounce_back_and_forth(size: int, start_t: int=0)->int:\n    \"\"\"returns the index position in a sequence at time t=t, when the index starts\n    at position zero at time t=0, and walks the list from end to end, and and bounces\n    back and forth.\n    returns the index for all t in Z\n\n    @param size: int, the size of the sequence to iterate over\n    @param start_t: int, the starting indice (usually time), zero by default\n    :return: the index in the sequence corresponding to the start_t provided\n\n    closed form, no iteration necessary --> O(1) time & space complexity\n\n       size=5                     size=5                    size=5\n       start at t=0               start at t=6              start at t=-1 and decreases\n     0 [0, _, _, _, _]         6 [_, _, 2, _, _]        -1 [_, _, _, _, 4]\n     1 [_, 1, _, _, _]         7 [_, 1, _, _, _]        -2 [_, _, _, 3, _]\n     2 [_, _, 2, _, _]         8 [0, _, _, _, _]        -3 [_, _, 2, _, _]\n     3 [_, _, _, 3, _]         9 [_, 1, _, _, _]        -4 [_, 1, _, _, _]\n     4 [_, _, _, _, 4]        10 [_, _, 2, _, _]        -5 [0, _, _, _, _]\n     5 [_, _, _, 3, _]        11 [_, _, _, 3, _]        -6 [_, 1, _, _, _]\n     6 [_, _, 2, _, _]        12 [_, _, _, _, 4]        -7 [_, _, 2, _, _]\n     7 [_, 1, _, _, _]        13 [_, _, _, 3, _]        -8 [_, _, _, 3, _]\n     8 [0, _, _, _, _]        14 [_, _, 2, _, _]        -9 [_, _, _, _, 4]\n     9 [_, 1, _, _, _]        15 [_, 1, _, _, _]       -10 [_, _, _, 3, _]\n    10 [_, _, 2, _, _]        16 [0, _, _, _, _]       -11 [_, _, 2, _, _]\n    \"\"\"\n\n    go_and_back = size * 2 - 2\n\n    if start_t < 0:\n        start_t = size - abs(start_t) % go_and_back\n\n    tdx_at_start_t = start_t % go_and_back\n    if tdx_at_start_t >= size:\n        tdx_at_start_t = go_and_back - tdx_at_start_t\n\n    return tdx_at_start_t\n\n\nif __name__ == '__main__':\n\n    # tests\n    res = [0, 1, 2, 3, 4, 3, 2, 1, 0, 1, 2, 3, 4, 3, 2, 1, 0, 1]\n    for idx in range(18):\n        actual, expected = bounce_back_and_forth(5, start_t=idx), res[idx]\n        assert actual == expected\n\n    stride = 0\n    for _ in range(5):\n        mod = 8  # the size of the sequence to iterate over\n        start = 0\n        stride += 1\n        print(f'size: {mod}, stride: {stride} -> ', end='')\n        for tdx in range(start, 20, stride):  # <-- get indices for 20 time steps ahead\n            print(bounce_back_and_forth(mod, tdx), end=' ')\n        print()\n```\n\n\noutput:\n\n```\nsize: 8, step: 1 -> 0 1 2 3 4 5 6 7 6 5 4 3 2 1 0 1 2 3 4 5 \nsize: 8, step: 2 -> 0 2 4 6 6 4 2 0 2 4 \nsize: 8, step: 3 -> 0 3 6 5 2 1 4 \nsize: 8, step: 4 -> 0 4 6 2 2 \nsize: 8, step: 5 -> 0 5 4 1 \n```\n\n\ntests:\n\n```\nclass TestBounceBackAndForth(unittest.TestCase):\n\n    def test_size5_t0(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=0), 0)\n\n    def test_size5_t3(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=3), 3)\n\n    def test_size5_t4(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=4), 4)\n\n    def test_size5_t5(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=5), 3)\n\n    def test_size5_t6(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=6), 2)\n\n    def test_size5_t7(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=7), 1)\n\n    def test_size5_t8(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=8), 0)\n\n    def test_size5_t9(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=9), 1)\n\n    def test_size5_t10(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=10), 2)\n\n    def test_size5_t11(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=11), 3)\n\n    def test_size2_t0(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=0), 0)\n\n    def test_size2_t1(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=1), 1)\n\n    def test_size2_t2(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=2), 0)\n\n    def test_size2_t3(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=3), 1)\n\n    def test_size2_t4(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=4), 0)\n\n    def test_size15_t7(self):\n        self.assertEqual(bounce_back_and_forth(size=15, start_t=7), 7)\n\n    def test_size15_t8(self):\n        self.assertEqual(bounce_back_and_forth(size=15, start_t=97), 13)\n\n    # --- Negative Indices ------------\n    def test_size5_t_m1(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-1), 4)\n\n    def test_size5_t_m2(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-2), 3)\n\n    def test_size5_t_m3(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-3), 2)\n\n    def test_size5_t_m4(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-4), 1)\n\n    def test_size5_t_m5(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-5), 0)\n\n    def test_size5_t_m6(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-6), 1)\n\n    def test_size5_t_m7(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-7), 2)\n\n    def test_size5_t_m8(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-8), 3)\n\n    def test_size5_t_m9(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-9), 4)\n\n    def test_size5_t_m10(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-10), 3)\n\n    def test_size5_t_m11(self):\n        self.assertEqual(bounce_back_and_forth(size=5, start_t=-11), 2)\n\n    def test_size2_t_m1(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=-1), 1)\n\n    def test_size2_t_m2(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=-2), 0)\n\n    def test_size2_t_m3(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=-3), 1)\n\n    def test_size2_t_m4(self):\n        self.assertEqual(bounce_back_and_forth(size=2, start_t=-4), 0)\n\n    def test_size15_t_m7(self):\n        self.assertEqual(bounce_back_and_forth(size=15, start_t=-7), 8)\n\n    def test_size15_t_m8(self):\n        self.assertEqual(bounce_back_and_forth(size=15, start_t=-8), 7)\n\n    def test_size15_t_m97(self):\n        self.assertEqual(bounce_back_and_forth(size=15, start_t=-97), 2)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Arduino Modular Arithmetic for Large Numbers\r\n                \r\nI have written a code to go around the big numbers: The problem is, there is a slight problem I cant seem to catch it. It is accurate till exponent or b is 2, then 3-4, it is slightly off, then 5-6 it just starts to deviate from the true answer.\n\n```\n#include <iostream>\n#include <conio.h>\nusing namespace std;\n\nunsigned long mul_mod(unsigned long b, unsigned long n, unsigned long m);\n\nunsigned long exponentV2(unsigned long a, unsigned long b, unsigned long m);\n\nint main()\n{\n    cout << exponentV2(16807, 3, 2147483647);\n    getch();\n}\n\nunsigned long exponentV2(unsigned long a, unsigned long b, unsigned long m)\n{\n   unsigned long result = (unsigned long)1;\n   unsigned long mask = b;    // masking\n\n   a = a % m;\n   b = b % m;\n\n   unsigned long pow = a;\n\n   // bits to exponent\n   while(mask)\n   {\n     //Serial.print(\"Binary: \");  // If you want to see the binary representation,     uncomment this and the one below\n     //Serial.println(maskResult, BIN);\n      //delay(1000);  // If you want to see this in slow motion \n     if(mask & 1)\n     {\n            result = (mul_mod(result%m, a%m, m))%m;\n\n           //Serial.println(result);  // to see the step by step answer, uncomment this\n     }\n     a = (mul_mod((a%m), (a%m), m))%m;\n     //Serial.print(\"a is \");\n     //Serial.println(a);\n     mask = mask >> 1;          // shift 1 bit to the left\n\n   }\n   return result;\n}\n\nunsigned long add_mod(unsigned long a, unsigned long b, unsigned long m)\n{\n    a = a%m;\n    b = b%m;\n    return (a+b)%m;\n}\n```\n\n    ", "Answer": "\r\ni just looked at your code and noticed few things:\n\nin function:\n\n```\nunsigned long exponentV2(unsigned long a, unsigned long b, unsigned long m);\n```\n\n\n\ni understand that this function return a^b mod m \nin the initialization you destroy exponent (b=b%m) this invalidates result !!! remove that line\n\n\nin function:\n\n```\nunsigned long add_mod(unsigned long a, unsigned long b, unsigned long m);\n```\n\n\n\nyou do not handle overflow (what if a+b is bigger than long ?)\nin that case (a+b)%m is wrong,... \nyou should in case of overflow substract m*x from result and than do the modulo. \nx must be as big so m*x is almost the size of long to eliminate overflow ... \nso (a+b)-(m*x) also fits to the long variable\n\n\nfor more insight look at this: Modular arithmetics and NTT (finite field DFT) optimizations\n\nhope it helps\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Scala: Using span with modular arithmetic\r\n                \r\nI have a ```\nList[Int]```\n from 1 to 10 and want to make a ```\nList[List[Int]]```\n containing two ```\nList[Int]```\n: one list containing even numbers and the other containing odd numbers. The result should be like this: \n\n```\nList(List(2,4,6,8,10),List(1,3,5,7,9))\n```\n\n\nI tried these things:\n\n```\n1.to(10).toList.span((x:Int) => x % 2 == 0) \n```\n\n\nand\n\n```\nval lst = 1.to(10).toList; lst span (_%2==0)\n```\n\n\nHowever, neither of these worked.\n\nCan someone help me on this matter?\n    ", "Answer": "\r\nThe method you need to use is ```\npartition```\n, not ```\nspan```\n:\n\n```\nscala> (1 to 10).partition(_ % 2 == 0)\nres0: (IndexedSeq[Int], IndexedSeq[Int]) = (Vector(2, 4, 6, 8, 10),Vector(1, 3, 5, 7, 9))\n```\n\n\nSince you want a ```\nList[List[Int]]```\n, you could do this:\n\n```\nval lst = (1 to 10).toList\nval (evens, odds) = lst.partition(_ % 2 == 0)\nval newList = List(evens,odds) // List(List(2, 4, 6, 8, 10), List(1, 3, 5, 7, 9))\n```\n\n\nThe ```\nspan```\n method can only be used to split a sequence at a single point:\n\n```\nscala> (1 to 10).span(_ < 5)\nres1: (Range, Range) = (Range(1, 2, 3, 4),Range(5, 6, 7, 8, 9, 10))\n```\n\n\nWhen you tried ```\nlst.span(_ % 2 == 0)```\n, the program found that the first item, 1, did not pass the test (```\n_ % 2 == 0```\n), so all the elements were put in the second list, leaving none in the first.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic - Prove or disprove calculation\r\n                \r\nHello everyone I am a computer science student, I am studying the Algorithms course independently.\nDuring the course I saw this question:\nI think it's a simple question, but I can not understand it\nProve or disprove: ```\n5^{3001} = 12^{301} (mod 31)$```\n\nmy plan to solve it is starting with (5 and 12) and squaring repeatedly modulo 31.\nmy solution:\n```\n\n5^{3001} = 12^{301} (mod 31) =\n5*5^{3000} = 12*12^{300} (mod 31) =\n5*125^{2998} = 12*6^{300}*2^{300} (mod 31) = \n5*1^{2998} = 12*36^{299}*32^{296} (mod 31) = \n5 = 12*36^{299}*32^{296} (mod 31) = \n5 = 12*5^{299}*1^{296} (mod 31) = \n5 = 12*125^{297}*1 (mod 31) = \n5 = 12*1^{297}*1 (mod 31) = \n5 = 12\n```\n\nThat's what I did, I do not think it is right to do so, is there another way to prove or disprove the claim?\n    ", "Answer": "\r\nExponentiation by squaring works of course, it is OK to do, but it looks like a lot of work and you can use a shortcut: a30 ≡ 1 mod 31 if gcd(a, 31) = 1 (Euler's theorem).\n53001 ≡ 5 * (530)100 ≡ 5 * 1100 ≡ 5 mod 31\n12301 ≡ 12 * (1230)10 ≡ 12 * 110 ≡ 12 mod 31\nThe exponents 3001 and 301 (in combination with the modulus, 31) look like they were chosen specifically to enable an approach based on Euler's theorem. For most arbitrary numbers that could have been chosen, this approach wouldn't have been so nice.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic and semi elgamal encryption\r\n                \r\nI'm implementing a semi ELGamal cryptosystem(from a research paper) function that has been used in PVSS. Unfortunately, I fail to decrypt as it has been described in the algorithm. \n\nHere is the initialisation phase:\n\nSelect a secure prime p such that p-1=2q where q is also a prime, then make a cyclic group G and let g be a random generator of this group. Pick a random x(private key) in the group and let y = g^x(public key). I simply initialise the algorithm as following:\n\n```\np = 233;\ng = 131;\nx = 139;\ny = g ^ x mod 233; //y = 182\n```\n\n\nNow let s (secret) be 23 and we compute our es (encrypted secret):\n\n```\ns = 23\nes = y ^ s mod 233// es = 231\n```\n\n\nIn order to decrypt the es, I raise es to the inverse of x(private key), I should return the g ^ s, assume ds is the deciphered value:\n\n```\nds = es ^ 1/x mod 233 // 1/x = 57, ds = 116\n```\n\n\nProblem is here, ds is not equal to g ^ s but in theory it should be because:\n\nrecall that we encrypted our s as:\n\n```\nes = y ^ s mod 233\n```\n\n\nand we know that \n\n```\ny = g ^ x mod 233\n```\n\n\nso, \n\n```\nes = g ^ x ^ s mod 233\n```\n\n\nGiven that, \n\n```\nds = es ^ 1/x mod 233\n// which means:\nds = g ^ x ^ s ^ 1/x mod 233\n```\n\n\ntherefore, I expect to get same result as of g^s  (131 ^ 23 mod 233) which must be 182 while what I get as the ds result is 116.\n\nIs there anything wrong with what I'm doing?\n    ", "Answer": "\r\nWhen you have:\n\n```\nx * invX = 1 mod p \n```\n\n\nthe following equality is generally not true:\n\n```\n(g ^ x) ^ invX = g mod p\n```\n\n\nAbove expression means multiplying ```\ng*g*....*g```\n a certain number of times, ```\nx * invX```\n, which is also ```\nk * p + 1```\n according to first modulo relation.\n\nSay your generator has a size ```\nn <= p-1```\n:\n\n```\ng ^ n = 1 mod p\n```\n\n\nThat means that ```\nx * invX```\n must be a multiple of ```\nn```\n...\n\nIn your preamble, you assert that ```\nq=(p-1)/2```\n is prime, but here, it's not the case, ```\nq=116```\n...\n\nAnd in your example g=131 is generating a sequence of length 58=(p-1)/4.\nThen, only those x have the property ```\ng ^ x ^(1/x) = 1 mod p```\n :\n\n```\n58 116 132 154 174 203 229 231 232\n```\n\n\nNote that for another generator, g=5, the sequence is of maximal length p-1, and then the sole x satisfying ```\n(g ^ x) ^ invX = 1 mod p```\n is ```\nx=p-1```\n.\n\nSince ```\ny^(p-1) = 1 mod p```\n for any y non multiple of p, x=p-1 is allways working as you expect anyway...\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Error in Modular Arithmetic calculation in Python\r\n                \r\nI have the following code in which there is a mysterious error for one particular combination of entries:\n\nIt *appears\" to work fine for everything else but for the inputs: \"Friday\" and \"1000\", it throws up a variable error.\n\nFull Code listing:\nhttps://repl.it/Jd6a/0\n\nCode\n\n```\n#Use of Modulo Arithmetic\n\ndef main():\n  DAY=\"Monday\"\n  print(\"Here's a little modulo magic for ya...\")\n  dayofweek=input(\"Enter day of week (e.g. Monday, Tuesday, Wednesday, etc:\")\n  numberofdays=input(\"Enter number of days from that day of the week you would like to calculate:\")\n\n  if dayofweek==\"Monday\":\n    dow=1 \n  elif dayofweek==\"Tuesday\":\n    dow=2 \n  elif dayofweek==\"Wednesday\":\n    dow=3 \n  elif dayofweek==\"Thursday\":\n    dow=4 \n  elif dayofweek==\"Friday\":\n    dow=5 \n  elif dayofweek==\"Saturday\":\n    dow=6 \n  elif dayofweek==\"Sunday\":\n    dow=7 \n\n  modanswer=int(numberofdays)%7\n  answer=modanswer+dow\n\n  if answer==1:\n    finalanswer=\"Monday\"\n  elif answer==2:\n    finalanswer=\"Tuesday\"\n  elif answer==3:\n    finalanswer=\"Wednesday\"\n  elif answer==4:\n    finalanswer=\"Thursday\"\n  elif answer==5:\n    finalanswer=\"Friday\"\n  elif answer==6:\n    finalanswer=\"Saturday\"\n  elif answer==7:\n    finalanswer=\"Sunday\"\n\n  print(numberofdays,\"days from -\",dayofweek,\"-will be-\",finalanswer)\n\nmain()\n```\n\n\nTesting (Correct) and Error Shown below\n\n```\nHere's a little modulo magic for ya...\nEnter day of week (e.g. Monday, Tuesday, Wednesday, etc: Monday\nEnter number of days from that day of the week you would like to calculate: 1000000\n1000000 days from - Monday -will be- Tuesday\n   main()\nHere's a little modulo magic for ya...\nEnter day of week (e.g. Monday, Tuesday, Wednesday, etc: Friday\nEnter number of days from that day of the week you would like to calculate: 1000\nTraceback (most recent call last):\n  File \"python\", line 1, in <module>\n  File \"python\", line 42, in main\nUnboundLocalError: local variable 'finalanswer' referenced before assignment\n```\n\n\nWhat I'm looking for:\n\nI'd be interested in a) a solution with explanation to the problem b) More elegant ways, with validation, to solve the problem (using more simple constructs perhaps)\n    ", "Answer": "\r\n```\n modanswer=int(numberofdays)%7\n answer=modanswer+dow\n```\n\n\n```\nmodanwer```\n is between 0 and 6 (inclusive), ```\ndow```\n is between 1 and 7 (inclusive), so ```\nanswer```\n is between 0 and 13 (inclusive). You should apply the modulo operation after the addition. This might work:\n\n```\nanswer = (int(numberofdays) + dow - 1) % 7 +1\n```\n\n\nThe ```\n-1```\n and ```\n+1```\n are needed because your ```\nanswer```\n is between 1 and 7 but modulo returns a number between 0 and 6.\n\nYou could simply use a list, 0-index ```\nday_number```\n and modulo:\n\n```\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n\nday_number = days.index('Friday') # 4\noffset = 1000\nprint(days[(day_number + offset) % 7])\n# Thursday\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Recursion using modular arithmetic explain java\r\n                \r\nCould anyone explain how does this method works.\n\n```\npublic static int calculate(int n){\nif (n/10 == 0)\n    return n;\nelse\n    return (n % 10 + calculate(n/10));\n} \n```\n\n\nI input n = 15 and it get a 6 but I don't understand how the method works. please help. thank you.\n    ", "Answer": "\r\nThe method calculates the sum of the digits.\n\nIf the ```\nn```\n is smaller than 10, you simply return ```\nn```\n (since the sum of digits of a single digit number is the number itself).\n\nOtherwise you add the least significant digit (that's ```\nn % 10```\n) to the sum of digits of the number ```\nn / 10```\n (which is calculated recursively).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Java BigInteger , number theory , modular arithmetic [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question needs to be more focused. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it focuses on one problem only by editing this post.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nAnyone have an idea on how to implement such a problem in java ?\n\n\"Implement a subroutine that takes three positive integer arguments (a; b; n) and returns the\nvalue of ( (a to the power of b) mod n), where the arguments are represented by about 100 decimal digits. Using four different methods.\"\n\nThanks in advance\n\nUPD : Methods were be as following\n\nM1)\n\n```\npublic BigInteger Result1(BigInteger a , BigInteger b , BigInteger n){\n    BigInteger Res = new BigInteger(\"1\");\n    for (BigInteger i = new BigInteger(\"0\"); !i.equals(b); i = i.add(new BigInteger(\"1\"))) {\n        Res = Res.multiply(a).mod(n);\n    }\n    return Res;\n}\n```\n\n\nM2)\n\n```\npublic BigInteger Result2(BigInteger a , BigInteger b , BigInteger n){\n    BigInteger Res = new BigInteger(\"1\");\n    for (BigInteger i = new BigInteger(\"0\"); !i.equals(b); i = i.add(new BigInteger(\"1\"))) {\n        Res = Res.multiply(a);\n    }\n    return Res.mod(n);\n}\n```\n\n\nM3)\n\n```\nublic BigInteger Result3(BigInteger a , BigInteger b , BigInteger n){\n    if(b.equals(new BigInteger(\"0\"))){\n        return new BigInteger(\"1\");\n    }\n    else if(b.mod(new BigInteger(\"2\")).equals(new BigInteger(\"0\"))){\n        BigInteger Res = Result3(a,b.divide(new BigInteger(\"2\")),n);\n        return (Res.multiply(Res)).mod(n);\n    }\n    else{\n        return ( (a.mod(n)).multiply(Result3(a, b.subtract(new BigInteger(\"1\")), n)) ).mod(n);\n    }\n}\n```\n\n\nM4)\n\n```\npublic BigInteger Result4(BigInteger a , BigInteger b , BigInteger n){\n    BigInteger Res = new BigInteger(\"1\");\n    while(!b.equals(new BigInteger(\"0\"))) {\n        if(!(b.mod(new BigInteger(\"2\"))).equals(new BigInteger(\"0\"))) {\n            Res = Res.multiply(a).mod(n);\n        }\n        a = a.multiply(a).mod(n);\n        b = b.divide(new BigInteger(\"2\"));\n    }\n    return Res;\n}\n```\n\n    ", "Answer": "\r\nTo answer your question directly,\nI think BigInteger.modPow might be what you're looking for. \n\n```\npublic BigInteger modPow(BigInteger exponent,\n                     BigInteger m)\n```\n\n\nReturns a BigInteger whose value is (this^exponent mod m)\n\nAlternatively (and more efficiently), you could also take (a mod n)  to the (b mod n) power, this should make the code run much quicker.\n\n(a^b mod n) = ((a mod n)^(b mod n) mod n)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic. How to solve the following equation?\r\n                \r\nHow to solve the following equation?\n\nI am interested in the methods of solutions.\n\nn^3 mod P = (n+1)^3 mod P\n\nP- Prime number\n\nShort example with the answer. \nCould you gives step-by-step solutions for my example.\n\nn^3 mod 61 = (n + 1)^3 mod 61\n\nInteger solutions:\n\nn = 61 m + 4,  \n\nn = 61 m + 56, \n\nm element Z\n\nZ - is set of integers.\n    ", "Answer": "\r\nAn other way to state ```\nn^3 ≡ (n+1)^3```\n is ```\nn^3 ≡ n^3 + 3 n^2 + 3 n + 1```\n (just work out the cube of n+1) then the cubic terms cancel out to give a nicer quadratic ```\n3 n^2 + 3 n + 1 ≡ 0```\n\n\nThen the usual quadratic formula applies, though all of its operations are now modulo P, and the determinant is not always a quadratic residue in which case there are no solutions to the original equation (this happens about half the time). This involves finding a square root modulo a prime, which is not hard for a computer to do for example with the Tonelli–Shanks algorithm, though not trivial to implement.\n\nBy the way ```\n3 n^2 + 3 n + 1 = 0```\n has the property that if ```\nn```\n is a solution, then ```\n-n - 1```\n is too.\n\nFor example, with some Python, once all the support functions exist it is pretty simple:\n\n```\ndef solve(p):\n  # solve 3 n^2 + 3 n + 1 ≡ 0\n  D = -3 % p\n  sqrtD = modular_sqrt(D, p)\n  if sqrtD == 0:\n    return None\n  else:\n    n = (sqrtD - 3) * inverse(6, p) % p\n    return (n, -(n+1) % p)\n```\n\n\nInverse modulo a prime is really easy,\n\n```\ndef inverse(x, p):\n  return pow(x, p - 2, p)\n```\n\n\nI adapted this implementation of Tonelli-Shanks to Python3 (```\n//```\n instead of ```\n/```\n for integer division)\n\n```\ndef modular_sqrt(a, p):\n    \"\"\" Find a quadratic residue (mod p) of 'a'. p\n        must be an odd prime.\n\n        Solve the congruence of the form:\n            x^2 = a (mod p)\n        And returns x. Note that p - x is also a root.\n\n        0 is returned is no square root exists for\n        these a and p.\n\n        The Tonelli-Shanks algorithm is used (except\n        for some simple cases in which the solution\n        is known from an identity). This algorithm\n        runs in polynomial time (unless the\n        generalized Riemann hypothesis is false).\n    \"\"\"\n    # Simple cases\n    #\n    if legendre_symbol(a, p) != 1:\n        return 0\n    elif a == 0:\n        return 0\n    elif p == 2:\n        return 0\n    elif p % 4 == 3:\n        return pow(a, (p + 1) // 4, p)\n\n    # Partition p-1 to s * 2^e for an odd s (i.e.\n    # reduce all the powers of 2 from p-1)\n    #\n    s = p - 1\n    e = 0\n    while s % 2 == 0:\n        s //= 2\n        e += 1\n\n    # Find some 'n' with a legendre symbol n|p = -1.\n    # Shouldn't take long.\n    #\n    n = 2\n    while legendre_symbol(n, p) != -1:\n        n += 1\n\n    # Here be dragons!\n    # Read the paper \"Square roots from 1; 24, 51,\n    # 10 to Dan Shanks\" by Ezra Brown for more\n    # information\n    #\n\n    # x is a guess of the square root that gets better\n    # with each iteration.\n    # b is the \"fudge factor\" - by how much we're off\n    # with the guess. The invariant x^2 = ab (mod p)\n    # is maintained throughout the loop.\n    # g is used for successive powers of n to update\n    # both a and b\n    # r is the exponent - decreases with each update\n    #\n    x = pow(a, (s + 1) // 2, p)\n    b = pow(a, s, p)\n    g = pow(n, s, p)\n    r = e\n\n    while True:\n        t = b\n        m = 0\n        for m in range(r):\n            if t == 1:\n                break\n            t = pow(t, 2, p)\n\n        if m == 0:\n            return x\n\n        gs = pow(g, 2 ** (r - m - 1), p)\n        g = (gs * gs) % p\n        x = (x * gs) % p\n        b = (b * g) % p\n        r = m\n\n\ndef legendre_symbol(a, p):\n    \"\"\" Compute the Legendre symbol a|p using\n        Euler's criterion. p is a prime, a is\n        relatively prime to p (if p divides\n        a, then a|p = 0)\n\n        Returns 1 if a has a square root modulo\n        p, -1 otherwise.\n    \"\"\"\n    ls = pow(a, (p - 1) // 2, p)\n    return -1 if ls == p - 1 else ls\n```\n\n\nYou can see some results on ideone\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Is using an unsigned rather than signed int more likely to cause bugs? Why?\r\n                \r\nIn the Google C++ Style Guide, on the topic of \"Unsigned Integers\", it is suggested that\n\n\n  Because of historical accident, the C++ standard also uses unsigned integers to represent the size of containers - many members of the standards body believe this to be a mistake, but it is effectively impossible to fix at this point. The fact that unsigned arithmetic doesn't model the behavior of a simple integer, but is instead defined by the standard to model modular arithmetic (wrapping around on overflow/underflow), means that a significant class of bugs cannot be diagnosed by the compiler. \n\n\nWhat is wrong with modular arithmetic? Isn't that the expected behaviour of an unsigned int?\n\nWhat kind of bugs (a significant class) does the guide refer to? Overflowing bugs?\n\n\n  Do not use an unsigned type merely to assert that a variable is non-negative.\n\n\nOne reason that I can think of using signed int over unsigned int, is that if it does overflow (to negative), it is easier to detect.\n    ", "Answer": "\r\nSome of the answers here mention the surprising promotion rules between signed and unsigned values, but that seems more like a problem relating to mixing signed and unsigned values, and doesn't necessarily explain why signed variables would be preferred over unsigned outside of mixing scenarios.\nIn my experience, outside of mixed comparisons and promotion rules, there are two primary reasons why unsigned values are bug magnets as follows.\nUnsigned values have a discontinuity at zero, the most common value in programming\nBoth unsigned and signed integers have a discontinuities at their minimum and maximum values, where they wrap around (unsigned) or cause undefined behavior (signed). For ```\nunsigned```\n these points are at zero and ```\nUINT_MAX```\n. For ```\nint```\n they are at ```\nINT_MIN```\n and ```\nINT_MAX```\n. Typical values of ```\nINT_MIN```\n and ```\nINT_MAX```\n on system with 4-byte ```\nint```\n values are ```\n-2^31```\n and ```\n2^31-1```\n, and on such a system ```\nUINT_MAX```\n is typically ```\n2^32-1```\n.\nThe primary bug-inducing problem with ```\nunsigned```\n that doesn't apply to ```\nint```\n is that it has a discontinuity at zero. Zero, of course, is a very common value in programs, along with other small values like 1,2,3. It is common to add and subtract small values, especially 1, in various constructs, and if you subtract anything from an ```\nunsigned```\n value and it happens to be zero, you just got a massive positive value and an almost certain bug.\nConsider code iterates over all values in a vector by index except the last0.5:\n```\nfor (size_t i = 0; i < v.size() - 1; i++) { // do something }\n```\n\nThis works fine until one day you pass in an empty vector. Instead of doing zero iterations, you get ```\nv.size() - 1 == a giant number```\n1 and you'll do 4 billion iterations and almost have a buffer overflow vulnerability.\nYou need to write it like this:\n```\nfor (size_t i = 0; i + 1 < v.size(); i++) { // do something }\n```\n\nSo it can be \"fixed\" in this case, but only by carefully thinking about the unsigned nature of ```\nsize_t```\n. Sometimes you can't apply the fix above because instead of a constant one you have some variable offset you want to apply, which may be positive or negative: so which \"side\" of the comparison you need to put it on depends on the signedness - now the code gets really messy.\nThere is a similar issue with code that tries to iterate down to and including zero. Something like ```\nwhile (index-- > 0)```\n works fine, but the apparently equivalent ```\nwhile (--index >= 0)```\n will never terminate for an unsigned value. Your compiler might warn you when the right hand side is literal zero, but certainly not if it is a value determined at runtime.\nCounterpoint\nSome might argue that signed values also have two discontinuities, so why pick on unsigned? The difference is that both discontinuities are very (maximally) far away from zero. I really consider this a separate problem of \"overflow\", both signed and unsigned values may overflow at very large values. In many cases overflow is impossible due to constraints on the possible range of the values, and overflow of many 64-bit values may be physically impossible). Even if possible, the chance of an overflow related bug is often minuscule compared to an \"at zero\" bug, and overflow occurs for unsigned values too. So unsigned combines the worst of both worlds: potentially overflow with very large magnitude values, and a discontinuity at zero. Signed only has the former.\nMany will argue \"you lose a bit\" with unsigned. This is often true - but not always (if you need to represent differences between unsigned values you'll lose that bit anyways: so many 32-bit things are limited to 2 GiB anyways, or you'll have a weird grey area where say a file can be 4 GiB, but you can't use certain APIs on the second 2 GiB half).\nEven in the cases where unsigned buys you a bit: it doesn't buy you much: if you had to support more than 2 billion \"things\", you'll probably soon have to support more than 4 billion.\nLogically, unsigned values are a subset of signed values\nMathematically, unsigned values (non-negative integers) are a subset of signed integers (just called _integers).2. Yet signed values naturally pop out of operations solely on unsigned values, such as subtraction. We might say that unsigned values aren't closed under subtraction. The same isn't true of signed values.\nWant to find the \"delta\" between two unsigned indexes into a file? Well you better do the subtraction in the right order, or else you'll get the wrong answer. Of course, you often need a runtime check to determine the right order! When dealing with unsigned values as numbers, you'll often find that (logically) signed values keep appearing anyways, so you might as well start of with signed.\nCounterpoint\nAs mentioned in footnote (2) above, signed values in C++ aren't actually a subset of unsigned values of the same size, so unsigned values can represent the same number of results that signed values can.\nTrue, but the range is less useful. Consider subtraction, and unsigned numbers with a range of 0 to 2N, and signed numbers with a range of -N to N. Arbitrary subtractions result in results in the range -2N to 2N in _both cases, and either type of integer can only represent half of it. Well it turns out that the region centered around zero of -N to N is usually way more useful (contains more actual results in real world code) than the range 0 to 2N. Consider any of typical distribution other than uniform (log, zipfian, normal, whatever) and consider subtracting randomly selected values from that distribution: way more values end up in [-N, N] than [0, 2N] (indeed, resulting distribution is always centered at zero).\n64-bit closes the door on many of the reasons to use unsigned values as numbers\nI think the arguments above were already compelling for 32-bit values, but the overflow cases, which affect both signed and unsigned at different thresholds, do occur for 32-bit values, since \"2 billion\" is a number that can exceeded by many abstract and physical quantities (billions of dollars, billions of nanoseconds, arrays with billions of elements). So if someone is convinced enough by the doubling of the positive range for unsigned values, they can make the case that overflow does matter and it slightly favors unsigned.\nOutside of specialized domains 64-bit values largely remove this concern. Signed 64-bit values have an upper range of 9,223,372,036,854,775,807 - more than nine quintillion. That's a lot of nanoseconds (about 292 years worth), and a lot of money. It's also a larger array than any computer is likely to have RAM in a coherent address space for a long time. So maybe 9 quintillion is enough for everybody (for now)?\nWhen to use unsigned values\nNote that the style guide doesn't forbid or even necessarily discourage use of unsigned numbers. It concludes with:\n\nDo not use an unsigned type merely to assert that a variable is non-negative.\n\nIndeed, there are good uses for unsigned variables:\n\nWhen you want to treat an N-bit quantity not as an integer, but simply a \"bag of bits\". For example, as a bitmask or bitmap, or N boolean values or whatever. This use often goes hand-in-hand with the fixed width types like ```\nuint32_t```\n and ```\nuint64_t```\n since you often want to know the exact size of the variable. A hint that a particular variable deserves this treatment is that you only operate on it with with the bitwise operators such as ```\n~```\n, ```\n|```\n, ```\n&```\n, ```\n^```\n, ```\n>>```\n and so on, and not with the arithmetic operations such as ```\n+```\n, ```\n-```\n, ```\n*```\n, ```\n/```\n etc.\nUnsigned is ideal here because the behavior of the bitwise operators is well-defined and standardized. Signed values have several problems, such as undefined and unspecified behavior when shifting, and an unspecified representation.\n\nWhen you actually want modular arithmetic. Sometimes you actually want 2^N modular arithmetic. In these cases \"overflow\" is a feature, not a bug. Unsigned values give you what you want here since they are defined to use modular arithmetic. Signed values cannot be (easily, efficiently) used at all since they have an unspecified representation and overflow is undefined.\n\n\n\n0.5 After I wrote this I realized this is nearly identical to Jarod's example, which I hadn't seen - and for good reason, it's a good example!\n1 We're talking about ```\nsize_t```\n here so usually 2^32-1 on a 32-bit system or 2^64-1 on a 64-bit one.\n2  In C++ this isn't exactly the case because unsigned values contain more values at the upper end than the corresponding signed type, but the basic problem exists that manipulating unsigned values can result in (logically) signed values, but there is no corresponding issue with signed values (since signed values already include unsigned values).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Using modular arithmetics for interval\r\n                \r\nLet's say we have range [-2, -1, 0, 1, 2, 3] which can be described as  MIN_VALUE=-2  and  MAX_VALUE=3\nWe want to implement function called infiniteCarousel() which will accept any number and used modulo operator (or somthing else) in order to calculate corresponding number in specified range.\n\n```\nfunction infiniteCarousel(value, minValue, maxValue)\n{\n    // todo\n    // use modulus operator to calculate correct number\n    // return calculated number \n}\n\n\n// range = [-2, -1, 0, 1, 2, 3]\nconst MIN_VALUE = -2;\nconst MAX_VALUE = 3;\n\nvar array = [];\n\n// let's calculate number from -10 to 10\nfor (var i = -10; i<10; i++)\n{\n    array.push( infiniteCarousel(i, MIN_VALUE, MAX_VALUE) );\n}\n\n// should print [2, 3, -2, -1, 0, 1, 2, 3, -2, -1, 0, 1, 2, 3, -2, -1, 0, 1, 2, 3, -2]\nconsole.log(array);  \n```\n\n\nDo you know any efficient way to implement this?\nAlso, does anybody know what is the correct name for this problem? I am having troubles searching web because I don't know how to properly describe this problem.\n    ", "Answer": "\r\nFirst get the ```\noffset```\n, if ```\nvalue```\n is smaller than ```\nminValue```\n take ```\nmaxValue```\n, otherwise ```\nminValue```\n.\n\nThen adjust ```\nvalue```\n with the offset, take the remainder with the ```\ncount```\n of the items and use the offset for getting the value in the wanted range.\n\n\r\n\r\n```\nfunction infiniteCarousel(value, minValue, maxValue) {\r\n    var count = maxValue - minValue + 1,\r\n        offset = value <= minValue ? maxValue : minValue;\r\n        \r\n    return (value - offset) % count + offset;\r\n}\r\n\r\nvar array = [];\r\nfor (var i = -10; i < 10; i++) array.push(infiniteCarousel(i, -2, 3));\r\n\r\nconsole.log(...[2, 3, -2, -1, 0, 1, 2, 3, -2, -1, 0, 1, 2, 3, -2, -1, 0, 1, 2, 3]);\r\nconsole.log(...array);\r\n\r\narray = [];\r\nfor (var i = -10; i < 10; i++) array.push(infiniteCarousel(i, 2, 6));\r\n\r\nconsole.log(...[5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 2, 3, 4]);\r\nconsole.log(...array);```\n\r\n\r\n\r\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetics and Big Powers\r\n                \r\nIs there a way i can calculate this in javascript.\nI need to solve such type of expressions for encrypting/decrypting.\n\r\n\r\n```\nconst x = 1999 ** 5678 % 567;\nconsole.log(x);```\n\r\n\r\n\r\n\n    ", "Answer": "\r\n```\n1999 ** 5678```\n is a big number which has about 19,000 digits. It's too large to fit in a ```\nnumber```\n.\nBut you can use BigInts instead:\n\r\n\r\n```\nconsole.log((1999n ** 5678n % 567n).toString());```\n\r\n\r\n\r\n\n(I use ```\ntoString```\n above only so that it works in the Stack Snippet interface, which doesn't support BigInts yet.)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Arithmetics and Big Powers\r\n                \r\nIs there a way i can calculate this in javascript.\nI need to solve such type of expressions for encrypting/decrypting.\n\r\n\r\n```\nconst x = 1999 ** 5678 % 567;\nconsole.log(x);```\n\r\n\r\n\r\n\n    ", "Answer": "\r\n```\n1999 ** 5678```\n is a big number which has about 19,000 digits. It's too large to fit in a ```\nnumber```\n.\nBut you can use BigInts instead:\n\r\n\r\n```\nconsole.log((1999n ** 5678n % 567n).toString());```\n\r\n\r\n\r\n\n(I use ```\ntoString```\n above only so that it works in the Stack Snippet interface, which doesn't support BigInts yet.)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How do I use modular arithmetic on indices?\r\n                \r\nI am trying to create a function that, for each member of a list, returns the value of that member and the number of values either side of it. The only trick is that it has to \"wrap around\" when it is at the start or end of the list\n\nFor example:\n\n```\na = [0,1,2,3,4,5,6,7,8,9]  \nmyfunc(a,2) # 2 indicates 2 either side\n\n[8,9,0,1,2]\n[9,0,1,2,3]\n[0,1,2,3,4]\n...\n...\n[6,7,8,9,0]\n[7,8,9,0,1]\n```\n\n\nI can work out how to do it from index 2 until 7:\n\n```\ndef myfunc(vals, rnge):\n    for i in range(0+rnge, len(vals)-rnge):\n        print vals[i-rnge:i+rnge+1]\n```\n\n\nBut I can't work out how to handle when it needs to wrap around.\n    ", "Answer": "\r\nyou could  try this (extend ```\nvals```\n in both directions first). there may be something in ```\ncollections```\n that allows for this to be done more efficiently:\n\n```\ndef myfunc(vals, rnge):\n    vals_ext = vals[-rnge:] + vals + vals[:rnge]\n    for i in range(len(vals)):\n        print( vals_ext[i:i+2*rnge+1] )\n```\n\n\noutput:\n\n```\n[8, 9, 0, 1, 2]\n[9, 0, 1, 2, 3]\n[0, 1, 2, 3, 4]\n[1, 2, 3, 4, 5]\n[2, 3, 4, 5, 6]\n[3, 4, 5, 6, 7]\n[4, 5, 6, 7, 8]\n[5, 6, 7, 8, 9]\n[6, 7, 8, 9, 0]\n[7, 8, 9, 0, 1]\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Type safe modular arthmetic no annotation\r\n                \r\nThere's a number of Haskell modular arithmetic modules that implement type safe modular arithmetic with type annotations. Is it possible to pass in a variable in the type annotation?\n\nFor example in the mod module the following works\n\n```\nlet x = 4 :: Mod 7\nlet y = 5 :: Mod 7\nprint x + y\n```\n\n\nIs there any way to achieve something similar to the following \n\n```\nlet base = 7\nlet x = 4 :: Mod base\nlet y = 5 :: Mod base\nprint x + y\n```\n\n\nMy problem here is that ```\nbase```\n is not a type. I'm unsure of the correct way to approach this problem or whether I'm thinking about this in the wrong way for functional languages. Thanks.\n\nUpdate\n\nIn practice base will be the result of some computation I do not know in advance.\n    ", "Answer": "\r\nA value parameterized by the ```\nbase```\n is a polymorphic value:\n\n```\nimport Data.Mod\nimport GHC.TypeNats (Nat)\n\nnine :: KnownNat base => Mod base\nnine =\n  let x = 4\n      y = 5\n  in x + y   -- Let type inference do the work of deducing that x, y :: Mod base\n```\n\n\nTo explicitly annotate these expressions, use ```\nScopedTypeVariables```\n to be able to refer to the ```\nbase```\n type variable. This also requires ```\nbase```\n to be explicitly quantified:\n\n```\n{-# LANGUAGE ScopedTypeVariables #-}\nimport Data.Mod\nimport GHC.TypeNats (Nat)\n\nnine :: forall base. KnownNat base => Mod base\nnine =\n  let x = 4 :: Mod base\n      y = 5 :: Mod base\n  in x + y\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Explanation of right to left binary method of modular arithmetic?\r\n                \r\nI have been studying this link from wikipedia of modulo of a large number, Here is the pseudocode.\n\n```\nfunction modular_pow(base, exponent, modulus)\n    result := 1\n    while exponent > 0\n        if (exponent mod 2 == 1):\n           result := (result * base) mod modulus\n        exponent := exponent >> 1\n        base = (base * base) mod modulus\n    return result\n```\n\n\nI don't understand the explanation given in wiki.Why I have to check if exp%2 is even or odd. also why I am doing the three operations?\n    ", "Answer": "\r\nThis algorithm is a combination of the Exponentiation by Squaring algorithm and modulo arithmetic.\n\nTo understand what's going on, first consider a situation when ```\nexponent```\n is a power of ```\n2```\n. Then, assuming that ```\nexponent = 2 ^ k```\n, the result could be computed by squaring the result ```\nk```\n times, i.e.\n\n```\nres = (...((base ^ 2) ^2 ) ... ) ^2))\n              ---------------------\n                     k times\n```\n\n\nWhen ```\nexponent```\n is not a power of ```\n2```\n, we need to make additional multiplications. It turns out that if we can divide ```\nexponent```\n by 2 without remainder, we can square the base, and divide the exponent. If, however, there is a remainder, we must additionally multiply the intermediate result by the value of the current ```\nbase```\n.\n\nWhat you see is the same exponentiation by squaring applied to modulo multiplication. The algorithm denotes integer division by two using the ```\nexponent >> 1```\n operation, which is identical to ```\nfloor(exponent / 2)```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "computing modular arithmetic of huge numbers in matlab (RSA)\r\n                \r\nI am trying to perform an RSA encryption/decryption using modulo function in matlab.\nThe problem is that I cannot do mod(x,y) when x is 50+ integer digits and y is also 50+ integer digits.\n\nIs there a function in matlab that can do mod of huge int prime numbers?\n\nAlso is there a way to store really huge numbers in a variable such as:\nx=p^e where p and e are 50+ integers.\n    ", "Answer": "\r\nFor your second question, I'm guessing you'll want to look into the binary expansion method of modular exponentiation, as in this Wikipedia section.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Performing modular arithmetic in Java to implement Diffie-Hellman\r\n                \r\nI have a question, I am trying to implement the encryption protocol between server and client based on Diffie-Hellman problem.\n\nThe problem is when I tried to ```\n((t^RsRc) mod p)^(1/Rc mod q)```\n  it is not giving me ```\n(t^Rs) mod p```\n.\n\nI have checked even if I am  doing \n```\n((t^Rc) mod p)^(1/Rc mod q)\nt.modPow(Rc, p)).modPow(Rc.modInverse(q), p)```\n it is not giving me ```\nt```\n. \n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Problems converting integrer to array using the modular arithmetic\r\n                \r\nSo I want to convert this integrer 03600029145 into an array.\n\nI've tried this:\n\n```\nint firstdigits;\nint array[11];\n\ncin >> firstdigits;\n\nfor (int i = 10; i>=0; i--)\n{\n    array[i] = (firstdigits % 10);\n    firstdigits /= 10;\n}\n```\n\n\nBut the output says that array contains this: 0214748364 (from 10 to 0)\n\nReminder: I know that the integrer is stored from 10 to 0. And that the correct way is from 0 to 10.\n    ", "Answer": "\r\nYou are using ```\nint```\n to store the value but maximum value you can store in an ```\nint```\n is ```\n2147483647(2^31-1)```\n. You should consider using ```\nlong long```\n or ```\nunsigned long long```\n. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to convert a modular arithmetic equation to python code?\r\n                \r\n```\n(x/y) mod n = ((x mod n) * (y mod n)^-1) mod n\n```\n\nI would like to know how to convert the above statement into python.\n    ", "Answer": "\r\nYou can do something like this,\nconsider,\n```\nx=10\ny=5\nn=2\n# You can use if condition to evaluate the expression\nif (x/y)%n==((x%n)*(y%n)**(-1)):\n    print('Condition satisfied')\nelse:\n    print('Condition not satisfied')\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Wrong result on modular arithmetic on ARM (Apple M1) with clang -O3 optimization\r\n                \r\nI am pulling my hair out for the last couple of days with this \"innocuous\" piece of code (minimal reproducible example, part of a larger modular multiplication routine):\n```\n#include <iostream>\n#include <limits>\n\nusing ubigint = unsigned long long int;\nusing bigint = long long int;\n\nvoid modmul(bigint a, bigint b, ubigint p) {\n    ubigint ua = a < 0 ? -a : a;\n    ubigint ub = b < 0 ? -b : b;\n\n    ua %= p;\n    ub %= p;\n\n    std::cout << \"ua: \" << ua << '\\n';\n}\n\nint main() {\n    bigint minbigint = std::numeric_limits<bigint>::min();\n    bigint maxbigint = std::numeric_limits<bigint>::max();\n    std::cout << \"minbigint: \" << minbigint << '\\n';\n    std::cout << \"maxbigint:  \" << maxbigint << '\\n';\n\n    modmul(minbigint, maxbigint, 2314); // expect ua: 2036, got ua: 0\n}\n```\n\nI am compiling on macOS 11.4 with clang 12.0 installed from Homebrew\n```\nclang version 12.0.0 \nTarget: arm64-apple-darwin20.5.0 \nThread model:posix \nInstalledDir: /opt/homebrew/opt/llvm/bin\n```\n\nWhen compiling with ```\nclang -O1```\n, the program spits out the expected result (in this case, 2036, I've checked with Wolfram Mathematica, ```\nMod[9223372036854775808, 2314]```\n, and this is correct). However, when I compile with ```\nclang -O2```\n or ```\nclang -O3```\n (full optimization), somehow the variable ```\nua```\n  is zeroed out (its value becomes ```\n0```\n). I am at a complete loss here, and have no idea why this happens. IMO, there's no UB, nor overflow, or anything dubious in this piece of code. I'd greatly appreciate any advice, or if you can reproduce the issue on your side.\nPS: the code behaves as expected on any other platforms, including Windows/Linux/FreeBSD/Solaris), with any combination of compilers. I'm only getting this error on Apple M1 with clang 12 (didn't test with other compilers on M1).\n    ", "Answer": "\r\nUPDATE: As @harold pointed out in the comment section, ```\nnegq```\n and ```\nsubq```\n from 0 is exactly the same. So the my discussion related to ```\nnegq```\n and ```\nsubq```\n below is incorrect. Please disregard that part, sorry for not double checking before posting answer.\nAbout the original question, I recompile a slightly simpler version of the code godbolt and find out that the problematic compiler's optimization is in ```\nmain```\n not ```\nmodmul```\n. In ```\nmain```\n, clang see that all of its operands for ```\nmodmul```\n is constant so it decided to do the computation of ```\nmodmul```\n at compile time. When calculating ```\nubigint ua = a < 0 ? -a : a;```\n, clang find out that is signed integer overflow UB so it decided to return 0 and print out. That may seem to be a radical thing to do but it's legal because of UB. Moreover, since there is no mathematically correct answer due to the limitation of two's compliment system, return 0 is arguably as good (or as bad) as any other result.\n\nOLD ANSWER BELOWS\nAs some one pointed out in the comment section, the 2 lines below in your code is undefined behavior - signed integer overflow UB.\n```\n    ubigint ua = a < 0 ? -a : a;\n    ubigint ub = b < 0 ? -b : b;\n```\n\nIf you wonder what exactly clang does under the hood to produce 2 different results at 2 different optimization levels, consider a simple example as following.\n```\nusing ubigint = unsigned long long int;\nusing bigint = long long int;\n\nubigint\nnegate(bigint a)\n{\n    ubigint ua = -a;\n    return ua;\n}\n```\n\nWhen compile with -O0\n```\nnegate(long long):                             # @negate(long long)\n        pushq   %rbp\n        movq    %rsp, %rbp\n        movq    %rdi, -8(%rbp)\n        xorl    %eax, %eax\n        subq    -8(%rbp), %rax  # Negation is performed here\n        movq    %rax, -16(%rbp)\n        movq    -16(%rbp), %rax\n        popq    %rbp\n        retq\n```\n\nCompile with -O3\n```\nnegate(long long):                             # @negate(long long)\n        movq    %rdi, %rax\n        negq    %rax  # Negation is performed here\n        retq\n```\n\nAt -O0, clang use normal ```\nsubq```\n instruction which perform binary subtraction of 0 and %rax and produce results with integer-wrap-around behavior.\nAt -O3, clang can do better, it use ```\nnegq```\n instruction which only replace the operand with its two's complement (i.e flip all the bits and add 1). However, you can see that this optimization is only legal if signed integer overflow is undefined behavior (hence the compiler can just ignore overflow cases). If the standard required integer-wrap-around behavior, clang must fall back to the unoptimized version.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmetic does not work in Threshold signature (TSS) implementation\r\n                \r\nI was implementing threshold signatures protocol described in this paper and I run into a case where it fails and I don't understand reasons why. In the end, ```\nu```\n and ```\nx```\n should be the same, but they are not. I would appreciate any advice that will help me to find the bug.\nThis is JS code, it can be executed in browser console\n```\n/// TSS 2-of-2 case\n// Field modulus, secp2561k\nn = 115792089237316195423570985008687907852837564279074904382605163141518161494337n\n\n// party 1 Polynomial coeff of degree 1\ncoeff_1 = 103808273981011494448342588544071102049904991793672697167547228275701563388858n\n// coeff_1 = 10380827398101149444834258854407110204990499179367269716754722827570156338885n // Working coeff\n \n// party 1 Polynomial coeff of degree 1\ncoeff_2 = 49961718147812071312795198333632033669565055597187655909241672498689891015278n\n// coeff_2 = 4996171814781207131279519833363203366956505559718765590924167249868989101527n // Working coeff \n\n// Party 1 secret\nu_1 = 6989964936015280241594720270850184250394589151026058230978623558313385587815n\n\n// Party 2 secret\nu_2 = 91492373973552717359377053249757253672786176158857596037729237022345023720795n\n\n// Party 1 Shamir points\ny1_x = 1n\ny1_1 = (y1_x * coeff_1 + u_1) % n\n// 110798238917026774689937308814921286300299580944698755398525851834014948976673n\ny1_2 = (y1_x * coeff_2 + u_2) % n\n// 25662002884048593248601266574701379489513667476970347564365746379516753241736n\n\n// Party 2 Shamir points\ny2_x = 2n\ny2_1 = (y2_x * coeff_1 + u_1) % n\n// 98814423660722073714708912350304480497367008459296548183467916968198350871194n\ny2_2 = (y2_x * coeff_2 + u_2) % n\n// 75623721031860664561396464908333413159078723074158003473607418878206644257014n\n\n// Party 1 point (y1_x, y1)\ny1 = (y1_1 + y1_2) % n\n\n// Party 2 point (y1_x, y1)\ny2 = (y2_1 + y2_2) % n\n\n// Common secret\nu = (u_1 + u_2) % n\n\n// Same secret, that went though Shamir schema\nx = (y1*2n - y2) % n\n\n// Checking calculations, should be 0 \nu - x\n```\n```\n\n    ", "Answer": "\r\nYour code is almost correct, just missing the final modulus at the end. Change the last line to\n```\n(u - x) % n;```\n\n\nThe ```\n(u -x)```\n is exactly ```\nn```\n.\n115792089237316195423570985008687907852837564279074904382605163141518161494337\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular multiplication [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How can I avoid overflow in modular multiplication?\r\n                            \r\n                                (2 answers)\r\n                            \r\n                    \r\n                Closed 12 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nGiven ```\na```\n, ```\nb```\n and ```\nm```\n, all of type ```\nu64```\n (or ```\nu128```\n), I want to calculate ```\n(a * b) % m```\n. However, ```\na```\n and ```\nb```\n may be large, so an overflow may occur.\nWhile I could cast them to ```\nBigUInt```\n, multiply them and then cast the result back, this seems a bit unelegant to me. (Since the casting to ```\nBigUInt```\n is theoretically unnecessary.)\nI also found the modular arithmetic crate, but it seems to be unmaintained, undocumented and the multiplication is very slow in case of an overflow. Also, there is the modular crate, but there an overflow can occur.\nSo, is there a more elegant way to do modular multiplication in Rust?\n    ", "Answer": "\r\nIf ```\nm * m```\n is small enough to not overflow, you can use ```\n(a % m) * (b % m) % m```\n to keep your multiplicands smaller, and it produces the same result as ```\na * b % m```\n because of neat modular properties.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "modular exponentiation for summation series\r\n                \r\nI am working on a project for school and I have run into a problem. Our goal is to calculate the last six decimal digits of the series of sums, ```\nn, i = 0, i^i```\n using modular arithmetic. I have found a recursive method online to help me better understand how modular exponentiation works.\n```\nint exponentMod(int A, int B, int C)\n{\n    // Base cases\n    if (A == 0)\n        return 0;\n    if (B == 0)\n        return 1;\n \n    // If B is even\n    long y;\n    if (B % 2 == 0) {\n        y = exponentMod(A, B / 2, C);\n        y = (y * y) % C;\n    }\n \n    // If B is odd\n    else {\n        y = A % C;\n        y = (y * exponentMod(A, B - 1, C) % C) % C;\n    }\n \n    return (int)((y + C) % C);\n}\n```\n\nThis method works fine when I am just calculating one exponent, however I'm not sure how to make this work for the problem I have been given with the series. The purpose of modular exponentiation is because we are working with large exponents, so I can not just add them up normally then mod by 1000000. I can't add up the numbers output by the above function either because they don't produce the full number that I need, when the numbers get larger, to get the correct summation. Can Someone point me in the right direction for finding the last six digits of the summation using modular arithmetic?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why is this modular arithmetic incorrect in my rotate string function?\r\n                \r\nI am writing a rotate string function in C. The intended behavior is that the strings chars will be rotated using a modulus of the string length, and a key. The function seems to work in the forward direction, but if I specify a negative key, I want the string to rotate in the opposite direction, and this is where the bug exists. For completeness/testing purposes, I will supply the entire program, but below that I will highlight the problem area and explain what I've done to try to debug so far:\n```\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *rotate_str(char *mutable_str, int key);\n\nint main(void) {\n    char str[] = \"This is a test.\";\n\n    char *output = rotate_str(str, -2);\n    printf(\"%s\\n\", output);\n    return EXIT_SUCCESS;\n}\n\n//Bug - negative rotate doesn't work properly - test with -2\nchar *rotate_str(char *mutable_str, int key) {\n    assert(mutable_str);\n    size_t len = strlen(mutable_str);\n    ssize_t i;\n    char *output = malloc(len + 1);\n    assert(output);\n\n    ssize_t rotated_index = 0;\n    for (i = 0; i < len; ++i) {\n        rotated_index = (i + key) % len; // Get the new index position\n        output[rotated_index] = mutable_str[i];\n    }\n    output[len] = '\\0';\n    return output;\n}\n```\n\nThe trouble spot is:\n```\n    for (i = 0; i < len; ++i) {\n        rotated_index = (i + key) % len; // Get the new index position\n        output[rotated_index] = mutable_str[i];\n    }\n```\n\nOn the first iteration, ```\ni = 0```\n, ```\nkey = -2```\n, and ```\nlen = 15```\n. When I compute ```\n-2 + 0 % 15```\n using a calculator (Google in this case), I get ```\n13```\n. However, my C program is making ```\nrotated_index = 14```\n as per my debugger output. So this itself is already a concern.\nWhen I do a positive ```\n2```\n as ```\nkey```\n, I get output: ```\nt.This is a tes```\n, which is what I'd expect. But when I do the ```\n-2```\n as ```\nkey```\n, I get output: ```\nis is a test.```\n but the expected output is ```\nis is a test.Th```\n\n    ", "Answer": "\r\nYour issue has to do with using the modulo operator with negative numbers.\n\nTo start with, you are using size_t which is an unsigned type, but you are trying to put negative numbers into the unsigned type. There is a better explanation why this is an issue here: https://stackoverflow.com/a/39337256/13341069\n\nHandle the key < (len * -1).\n```\n char* rotate_str(char *mutable_str, int key)\n {\n     assert(mutable_str);\n     int len = strlen(mutable_str);\n     int i;\n     char *output = (char *)malloc(len + 1);\n     assert(output);\n\n     int remainder;\n     int rotated_index = 0;\n     for (i = 0; i < len; ++i)\n     {\n         remainder = (i + key) % len; // Get the new index position. range is (-len to +len)\n         rotated_index = (remainder + len) % len; // Add len to shift value range to [0, +len).\n         output[rotated_index] = mutable_str[i];\n     }\n     output[len] = '\\0';\n     return output;\n }\n```\n\n\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Set bits combined with exponential modular arithmetics\r\n                \r\n\n\nI got this question yesterday in a challenge. I thought I had coded it correctly and my sample test case was passed. However not even a single test case passed at the backend. Here is my code. Please, someone, help me out. The challenge is over for me and so I can't submit it further. But I want to learn from my mistakes. Thanks.\n\n```\n  import java.io.*;\n//import java.util.*;\n\n\npublic class TestClass {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter wr = new PrintWriter(System.out);\n         int n = Integer.parseInt(br.readLine().trim());\n         String[] arr_a = br.readLine().split(\" \");\n         int[] a = new int[n];\n         for(int i_a=0; i_a<arr_a.length; i_a++)\n         {\n            a[i_a] = Integer.parseInt(arr_a[i_a]);\n         }\n\n         long out_ = solve(a);\n         System.out.println(out_);\n\n         wr.close();\n         br.close();\n    }\n    static long solve(int[] a){\n        // Write your code here\n        long sum = 0l;\n        long MAX = 10000000011l;\n        long i = 1l;\n        for(int x : a) {\n            long count = 0;\n            while(x>0) {\n                x &= (x-1l);\n                count++;\n            }\n            long res = 1l;\n            long temp = i;\n            count = count % MAX;\n            while(temp > 0) {\n                if((temp & 1l) == 1l) {\n                    res = (res * count) % MAX;\n                }\n                temp = temp >> 1l;\n                count = ((count % MAX) * (count % MAX)) % MAX;\n\n            }\n\n            long t =((sum%MAX) + (res % MAX))%MAX;\n            sum = t;\n            i++;\n        }\n\n        return sum;\n    }\n}\n```\n\n    ", "Answer": "\r\nIt is a bit strange that \"not even a single test case passed\", but the only error I see is your exponentiation by squaring part. \n\nAll your numbers are less than ```\n10^10 + 11```\n, but this constant has more than 32 bits, and when you multiply, you get an overflow sometimes (because ```\nlong```\n is a 64-bit signed integer). \n\nThis can be fixed by several approaches:\n\n\n```\n(a*b) % M```\n operation can be done with the algorithm that is similar to your \"exponentiation by squaring\" implementation. You just need to replace all multiplications with additions. As a result, multiplication is replaced with ```\nO(log(n))```\n additions and 'multiplying by 2' operations. Sample implementation:\n\n```\nstatic long multiply(long a, long b, long M) {\n    long res = 0;\n    long d = a % M;\n\n    while (b > 0) {\n        if ((b & 1) == 1) {\n            res = (res + d) % M;\n        }\n\n        b >>= 1;\n        d = (d + d) % M;\n    }\n    return res;\n}\n```\n\nYou can just cache ```\nb^i % M```\n numbers for previously computed steps. For every number of set bits (there are not so many of them), you can save previously computed values and ```\nlast(b)```\n - the last ```\ni```\n when ```\na[i]```\n had ```\nb```\n set bits. Then just compute the new value with a linear loop from ```\nlast(b) + 1```\n till current index ```\ni```\n.\nUse BigInteger for multiplications.\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular comparison of characters\r\n                \r\nThis seems like a very simple question, but there's surprisingly little written about it on the Internet, and I'm having a hard time implementing it correctly on my own. What is the best way to implement a modular comparison function on ASCII characters in Java, such that the comparison \"wraps around\" the end of the alphabet? I want to use it for a \"between\" function that can partition the entire alphabet at arbitrary locations, and correctly return \"true\" when asked if 'y' is between 'x' and 'b'.\n\nI've already found all the questions and answers that talk about modular arithmetic on characters, so I know how to do modular addition (character shifting) with code like this:\n\n```\nchar shifted = (((original - 'a') + 1) % 26) + 'a';\n```\n\n\nHowever, this is based on Java's built in modular arithmetic functions, which have no equivalent for comparison. Even if I was using plain ints, I have no way of asking Java if a < b < c mod 26 (which should return true if a = 24, b = 25, and c = 1).\n\nSo the general question is, what's the best way to implement modular comparison operations in Java? If that's too hard a problem, is there at least a way to get such comparisons to work for the ASCII alphabet?\n    ", "Answer": "\r\nIn testing for ```\nA < B < C```\n in a circular queue, you can always assume ```\nA <= B```\n and has either wrapped around or not.\n\nIf ```\nA < B```\n, no wrapping has occurred.  If either ```\nB < C or C < A```\n, then B is between A and C.\n\nIf ```\nA > B```\n, then you've wrapped.  If ```\nB < C and C < A```\n, then B is between A and C.\n\nYou'll need to define for yourself how to handle A==B, B==C, or A==C.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "definition of a type doesn’t work in agda\r\n                \r\nThis definition of modular arithmetic doesn’t compile in agda :\n```\ndata mod (n : nat): n → Set where\n    zeroM : mod n\n    S : mod n → mod n\n    equMod : { x : nat} → (x ≡ n) → (x ≡ zeroM)\n```\n\nError: ```\nnat should be a sort, but isn’t```\n\nCan someone help me ?\n    ", "Answer": "\r\nWhen you write n -> Set you need n to be a type but it is a natural number. I guess you just want to write ```\ndata mod (n : nat) : Set```\n which means that ```\nmod : nat -> Set```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular arithmatic in Rabin-karp algorithm\r\n                \r\n\n\nI am studying Rabin-karp algotithm for string matching from CLRS in which modular arithmetic is used for hashing which i haven't studied so what I don't understand is that how does (7 – 3·3)·10 + 2 (mod 13) evaluate to 8 (mod 13)\n    ", "Answer": "\r\n(7 – 3·3)·10 + 2 (mod 13) evaluate to 8 (mod 13)\n\nBecause 7 - 9 = 11, not -2.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How can I do modular arithmetic with decimal values in Python?\r\n                \r\nSay I want to do something like\n\n```\n9.9 % 13\n```\n\n\nThe normal python modulo will give me an output of 9.9. Are there any modules I can import that will instead give me an output of 6 (or more generally an integer value)?\n    ", "Answer": "\r\nJust do ```\n(99 mod 13 * inverse modulo ( 10, 13)) modulo 13```\n\n\n```\n99 mod 13 = 8, inverse modulo (10,13) = 4```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How can we compute modular arithmetic with large divisor and exponent?\r\n                \r\nExample:\n\n(30000000^30000000) mod 40000000 = ?\n\nI have been using Euler theory and properties of exponents but still cannot get the answer\nAnyone know how to calculate this by just theories and simple calculator?\n\nMy trial is to reduce the exponent of the 30000000 by the Fermat's Little Theorem but the exponent is still too large for the calculator to compute.\n    ", "Answer": "\r\nYou use the halving-and-squaring approach to power computation and reduce in every step the intermediate result modulo the given divisor. \n\nYou can also use negative remainders to get somewhat smaller intermediate results.\n\nNote also that n=40000000=4*10^7=2^9*5^7 is a composite number, so the Euler totient function gives phi(n)=2^8*4*5^6=16*10^5=160000. Now reduce the exponent mod phi(n)-1 first.\n\nThis last method only works if you know the factorization of the divisor.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "C++ vectorization of user defined type\r\n                \r\nSay I am writing a modular arithmetic type, after each arithmetic operation a mod P operation (% P) is applied.\nI would like the new type to be usable with STL's algorithms, as well as execution policies.\nIt seems that the ```\npar```\n policy should work, but what about ```\nunseq```\n vectorization? Is it possible to integrate vectorization capabilities of the standard library with a custom numeric type?\nHow would I add the numeric traits to the custom type?\nBTW, I know that there are modular arithmetic libraries. This is an exercise with modern C++.\n    ", "Answer": "\r\nYou're still going to rely on template instantiation followed by compilation. ```\nunseq```\n vectorization should come from the compiler noticing that there can't be aliasing, allowing it to choose SIMD instructions. That means you're not writing the SIMD instructions manually.\nHowever, you should give the compiler a fair chance to see all the operations together. If your ```\noperator+```\n is only seen by the linker, it would be compiled as a scalar operation . That means you'll need to make all the operations ```\ninline```\n so the compiler can combine multiple calls.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Overflow-safe modular addition and subtraction in C?\r\n                \r\nI'm implementing an algorithm in C that needs to do modular addition and subtraction quickly on unsigned integers and can handle overflow conditions correctly. Here's what I have now (which does work):\n\n```\n/* a and/or b may be greater than m */\nuint32_t modadd_32(uint32_t a, uint32_t b, uint32_t m) {\n    uint32_t tmp;\n    if (b <= UINT32_MAX - a)\n        return (a + b) % m;\n\n    if (m <= (UINT32_MAX>>1))\n        return ((a % m) + (b % m)) % m;\n\n    tmp = a + b;\n    if (tmp > (uint32_t)(m * 2)) // m*2 must be truncated before compare\n        tmp -= m;\n    tmp -= m;\n    return tmp % m;\n}\n\n/* a and/or b may be greater than m */\nuint32_t modsub_32(uint32_t a, uint32_t b, uint32_t m) {\n    uint32_t tmp;\n    if (a >= b)\n        return (a - b) % m;\n\n    tmp = (m - ((b - a) % m)); /* results in m when 0 is needed */\n    if (tmp == m)\n        return 0;\n    return tmp;\n}\n```\n\n\nAnybody know of a better algorithm? The libraries I've found that do modular arithmetic all seem to be for large arbitrary precision numbers which is way overkill. \n\nEdit: I want this to run well on a 32 bit machine. Also, my existing functions are trivially converted to work on other sizes of unsigned integers, a property which would be nice to retain.\n    ", "Answer": "\r\nModular operations usually assume that a and b are less than m. This allows simpler algorithms:\n\n```\numod_t sub_mod(umod_t a, umod_t b, umod_t m)\n{\n  if ( a>=b )\n    return a - b;\n  else\n    return m - b + a;\n}\n\numod_t add_mod(umod_t a, umod_t b, umod_t m)\n{\n  if ( 0==b ) return a;\n\n  // return sub_mod(a, m-b, m);\n  b = m - b;\n  if ( a>=b )\n    return a - b;\n  else\n    return m - b + a;\n}\n```\n\n\nSource: Matters Computational, chapter 39.1.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Compute prime in haskell\r\n                \r\nI wish to compute whether a given integer is prime in Haskell:\n\n```\n--primes\nisPrime :: (Integral a) => a -> Bool\nisPrime n | n < 4 = n > 1\nisPrime n = all ((/=0).mod (n-1)) $ 2:3:[x + i | x <- [6,12..s], i <- [-1,1]]\n            where s = floor $ sqrt $ fromIntegral n\n```\n\n\nHowever, running this on the input ```\n131```\n gives ```\nFalse```\n. I think the error lies in modular arithmetic but I'm not sure. Is there anything wrong with the modular statement in my program?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Calculate modulo of a large number represented as a string\r\n                \r\nSuppose I have a large number (around 10^5 digits) and I have to calculate num % a where a is less than 10^9 i.e. it is in the int range of C++. There's this code :-\n```\nint res = 0;\n\n//num contains the large number stored as a string\nfor (int i = 0; i < num.length(); i++) {\n    res = (res*10 + (int)num[i] - '0') % a; \n    }\n\nreturn res;\n```\n\nI know that this solution uses modular arithmetic but I don't get why we are multiplying res by 10 at every iteration.\nSuppose I have a number 32471.\nAccording to this code first step will be\n```\n(0 * 10 + 3) % a```\n\nWhy this 10? Should it not be\n```\n(0 % a + (3 * 10^4) % a) % a```\n  and so on, according to modular arithmetic?\nCan someone explain how we arrived at this?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Beginner Question: Mod Arithmetic Syntax Error [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is not reproducible or was caused by typos. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     This question was caused by a typo or a problem that can no longer be reproduced. While similar questions may be on-topic here, this one was resolved in a way less likely to help future readers.\r\n                \r\n                    \r\n                        Closed 1 year ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI’m trying to make a fizzbuzz program: count up to n; for each i up to n, print “fizz” if a multiple of 3, and “buzz” if a multiple of 5 — if a multiple of both, print “fizzbuzz”.\nI’m using modular arithmetic, but for some reason my syntax is wrong.\nHere is my code (without the “fizzbuzz” bit yet):\n```\ndef fizzbuzz(n):\n   for i in range(n):\n      if i % 3 = 0\n         return fizz\n      if i % 5 = 0\n         return buzz\n      else\n         return i\n      \nprint(fizzbuzz(100))\n```\n\nError Code:\n```\nPython3IDE(Python 3.7) running!\n  File \"/var/mobile/Containers/Data/Application/FD2AF249-3788-42B7-90B2-929E9D35A2E1/Documents/FizzBuzz.py\", line 5\n    if i % 3 = 0\n             ^\nSyntaxError: invalid syntax\nPytho3IDE run end!\n```\n\nAny help is much appreciated.\n    ", "Answer": "\r\nThe problem is in the ```\nif i % 3 = 0```\n and the ```\nif i % 5 = 0```\n. The comparison operator, in this case, would be ```\n==```\n, so you would have to rewrite both statements with the comparison operator. Currently, you are using the assignment operator, which Python doesn't understand.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "spurious lines using fimplicit on a modular function\r\n                \r\nI want to plot collections of repeating circular arcs and am having trouble with spurious lines showing up in the plots. For example, one of the plots I want is given by\n\n```\na = @(x,y) ((mod(x,1) + 0.5).^2 + (mod(y,1) - 0.5).^2 - 1)\nfimplicit(a,[-1,1],'MeshDensity',500)\n```\n\n\nbut the output is incorrect as far as I can tell:\n\nThe implicit function is decidedly not zero on the verticle lines. I assume something funny is happening with the fimplicit algorithm and modular arithmetic. Any ideas how to get around this? Thanks!\n    ", "Answer": "\r\nThat probably happens because your function is discontinuous at the lines x = k with k integer, as a surface plot reveals:\n\n```\nfsurf(a, [-2 2])\n```\n\n\n\n\nTo verify that the discontinuity is the likely reason, consider the simpler example\n\n```\nf = @(x,y) (2*(x>=0)-1).*(2*(y>=0)-1);\n```\n\n\nThis function is discontinuous at x = 0 and at y = 0. It jumps from 1 to −1 at x = 0 and at y = 0, but it never equals 0.\n\n```\nfsurf(f, [-2 2])\n```\n\n\n\n\nIt can be seen that ```\nfimplicit```\n is confused by the discontinuity, and thinks the function is ```\n0```\n there:\n\n```\nfimplicit(f,[-2,2],'MeshDensity',500)\n```\n\n\n\n\nLooking at the source code of ```\nfimplicit```\n, the actual work is seen to be done (on R2017b at least) by the class ```\nmatlab.graphics.function.ImplicitFunctionLine```\n in the second to last line. That class is a ```\n.p```\n file, and is thus obfuscated, which means that unfortunately its source code cannot be seen.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why does division by 3 require a rightshift (and other oddities) on x86?\r\n                \r\nI have the following C/C++ function:\n```\nunsigned div3(unsigned x) {\n    return x / 3;\n}\n```\n\nWhen compiled using clang 10 at ```\n-O3```\n, this results in:\n```\ndiv3(unsigned int):\n        mov     ecx, edi         # tmp = x\n        mov     eax, 2863311531  # result = 3^-1\n        imul    rax, rcx         # result *= tmp\n        shr     rax, 33          # result >>= 33\n        ret\n```\n\nWhat I do understand is: division by 3 is equivalent to multiplying with the multiplicative inverse 3-1 mod 232 which is 2863311531.\nThere are some things that I don't understand though:\n\nWhy do we need to use ```\necx```\n/```\nrcx```\n at all? Can't we multiply ```\nrax```\n with ```\nedi```\n directly?\nWhy do we multiply in 64-bit mode? Wouldn't it be faster to multiply ```\neax```\n and ```\necx```\n?\nWhy are we using ```\nimul```\n instead of ```\nmul```\n? I thought modular arithmetic would be all unsigned.\nWhat's up with the 33-bit rightshift at the end? I thought we can just drop the highest 32-bits.\n\nEdit 1\nFor those who don't understand what I mean by 3-1 mod 232, I am talking about the multiplicative inverse here.\nFor example:\n```\n// multiplying with inverse of 3:\n15 * 2863311531      = 42949672965\n42949672965 mod 2^32 = 5\n\n// using fixed-point multiplication\n15 * 2863311531      = 42949672965\n42949672965 >> 33    = 5\n\n// simply dividing by 3\n15 / 3               = 5\n```\n\nSo multiplying with 42949672965 is actually equivalent to dividing by 3. I assumed clang's optimization is based on modular arithmetic, when it's really based on fixed point arithmetic.\nEdit 2\nI have now realized that the multiplicative inverse can only be used for divisions without a remainder. For example, multiplying 1 times 3-1 is equal to 3-1, not zero. Only fixed point arithmetic has correct rounding.\nUnfortunately, clang does not make any use of modular arithmetic which would just be a single ```\nimul```\n instruction in this case, even when it could. The following function has the same compile output as above.\n```\nunsigned div3(unsigned x) {\n    __builtin_assume(x % 3 == 0);\n    return x / 3;\n}\n```\n\n\n(Canonical Q&A about fixed-point multiplicative inverses for exact division that work for every possible input: Why does GCC use multiplication by a strange number in implementing integer division? - not quite a duplicate because it only covers the math, not some of the implementation details like register width and imul vs. mul.)\n    ", "Answer": "\r\n\n\nCan't we multiply rax with edi directly?\n\n\nWe can't ```\nimul rax, rdi```\n because the calling convention allows the caller to leave garbage in the high bits of RDI; only the EDI part contains the value.  This is a non-issue when inlining; writing a 32-bit register does implicitly zero-extend to the full 64-bit register, so the compiler will usually not need an extra instruction to zero-extend a 32-bit value.\n(zero-extending into a different register is better because of limitations on mov-elimination, if you can't avoid it).\nTaking your question even more literally, no, x86 doesn't have any multiply instructions that zero-extend one of their inputs to let you multiply a 32-bit and a 64-bit register.  Both inputs must be the same width.\n\n\nWhy do we multiply in 64-bit mode?\n\n\n(terminology: all of this code runs in 64-bit mode.  You're asking why 64-bit operand-size.)\nYou could ```\nmul edi```\n to multiply EAX with EDI to get a 64-bit result split across EDX:EAX, but ```\nmul edi```\n is 3 uops on Intel CPUs, vs. most modern x86-64 CPUs having fast 64-bit ```\nimul```\n.  (Although ```\nimul r64, r64```\n is slower on AMD Bulldozer-family, and on some low-power CPUs.)  https://uops.info/ and https://agner.org/optimize/ (instruction tables and microarch PDF)\n(Fun fact: ```\nmul rdi```\n is actually cheaper on Intel CPUs, only 2 uops.  Perhaps something to do with not having to do extra splitting on the output of the integer multiply unit, like ```\nmul edi```\n would have to split the 64-bit low half multiplier output into EDX and EAX halves, but that happens naturally for 64x64 => 128-bit mul.)\nAlso the part you want is in EDX so you'd need another ```\nmov eax, edx```\n to deal with it.  (Again, because we're looking at code for a stand-alone definition of the function, not after inlining into a caller.)\nGCC 8.3 and earlier did use 32-bit ```\nmul```\n instead of 64-bit ```\nimul```\n (https://godbolt.org/z/5qj7d5).  That was not crazy for ```\n-mtune=generic```\n when Bulldozer-family and old Silvermont CPUs were more relevant, but those CPUs are farther in the past for more recent GCC, and its generic tuning choices reflect that.  Unfortunately GCC also wasted a ```\nmov```\n instruction copying EDI to EAX, making this way look even worse :/\n```\n# gcc8.3 -O3  (default -mtune=generic)\ndiv3(unsigned int):\n        mov     eax, edi                 # 1 uop, stupid wasted instruction\n        mov     edx, -1431655765         # 1 uop  (same 32-bit constant, just printed differently)\n        mul     edx                      # 3 uops on Sandybridge-family\n        mov     eax, edx                 # 1 uop\n        shr     eax                      # 1 uop\n        ret\n                                  # total of 7 uops on SnB-family\n```\n\nWould only be 6 uops with ```\nmov eax, 0xAAAAAAAB```\n / ```\nmul edi```\n, but still worse than:\n```\n# gcc9.3 -O3  (default -mtune=generic)\ndiv3(unsigned int):\n        mov     eax, edi                # 1 uop\n        mov     edi, 2863311531         # 1 uop\n        imul    rax, rdi                # 1 uop\n        shr     rax, 33                 # 1 uop\n        ret\n                      # total 4 uops, not counting ret\n```\n\nUnfortunately, 64-bit ```\n0x00000000AAAAAAAB```\n can't be represented as a 32-bit sign-extended immediate, so ```\nimul rax, rcx, 0xAAAAAAAB```\n isn't encodeable.  It would mean ```\n0xFFFFFFFFAAAAAAAB```\n.\n\n\nWhy are we using imul instead of mul? I thought modular arithmetic would be all unsigned.\n\n\nIt is unsigned.  Signedness of the inputs only affects the high half of the result, but ```\nimul reg, reg```\n doesn't produce the high half.  Only the one-operand forms of ```\nmul```\n and ```\nimul```\n are full multiplies that do NxN => 2N, so only they need separate signed and unsigned versions.\nOnly ```\nimul```\n has the faster and more flexible low-half-only forms.  The only thing that's signed about ```\nimul reg, reg```\n is that it sets OF based on signed overflow of the low half.  It wasn't worth spending more opcodes and more transistors just to have a ```\nmul r,r```\n whose only difference from ```\nimul r,r```\n is the FLAGS output.\nIntel's manual (https://www.felixcloutier.com/x86/imul) even points out the fact that it can be used for unsigned.\n\n\nWhat's up with the 33-bit rightshift at the end? I thought we can just drop the highest 32-bits.\n\n\nNo, there's no multiplier constant that would give the exact right answer for every possible input ```\nx```\n if you implemented it that way.  The \"as-if\" optimization rule doesn't allow approximations, only implementations that produce the exact same observable behaviour for every input the program uses.  Without knowing a value-range for ```\nx```\n other than full range of ```\nunsigned```\n, compilers don't have that option.  (```\n-ffast-math```\n only applies to floating point; if you want faster approximations for integer math, code them manually like below):\nSee Why does GCC use multiplication by a strange number in implementing integer division? for more about the fixed-point multiplicative inverse method compilers use for exact division by compile time constants.\nFor an example of this not working in the general case, see my edit to an answer on Divide by 10 using bit shifts? which proposed\n```\n// Warning: INEXACT FOR LARGE INPUTS\n// this fast approximation can just use the high half,\n// so on 32-bit machines it avoids one shift instruction vs. exact division\nint32_t div10(int32_t dividend)\n{\n    int64_t invDivisor = 0x1999999A;\n    return (int32_t) ((invDivisor * dividend) >> 32);\n}\n```\n\nIts first wrong answer (if you loop from 0 upward) is ```\ndiv10(1073741829) = 107374183```\n when ```\n1073741829/10```\n is actually 107374182.  (It rounded up instead of toward 0 like C integer division is supposed to.)\n\nFrom your edit, I see you were actually talking about using the low half of a multiply result, which apparently works perfectly for exact multiples all the way up to UINT_MAX.\nAs you say, it completely fails when the division would have a remainder, e.g. ```\n16 * 0xaaaaaaab```\n = ```\n0xaaaaaab0```\n when truncated to 32-bit, not ```\n5```\n.\n```\nunsigned div3_exact_only(unsigned x) {\n    __builtin_assume(x % 3 == 0);  // or an equivalent with if() __builtin_unreachable()\n    return x / 3;\n}\n```\n\nYes, if that math works out, it would be legal and optimal for compilers to implement that with 32-bit imul.  They don't look for this optimization because it's rarely a known fact.  IDK if it would be worth adding compiler code to even look for the optimization, in terms of compile time, not to mention compiler maintenance cost in developer time.  It's not a huge difference in runtime cost, and it's rarely going to be possible.  It is nice, though.\n```\ndiv3_exact_only:\n    imul  eax, edi, 0xAAAAAAAB        # 1 uop, 3c latency\n    ret\n```\n\nHowever, it is something you can do yourself in source code, at least for known type widths like ```\nuint32_t```\n:\n```\nuint32_t div3_exact_only(uint32_t x) {\n    return x * 0xaaaaaaabU;\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to make my Fibonacci with Modular Arithmetic more efficient to find the pisano cycle?\r\n                \r\nDue to educational purposes, I am building a code in Python3 in order to accomplish this goal:\n\n\n\nI think I did a very good job for this problem since I am in a beginner/intermediate level. This problem is an advanced and not obligatory one.\n\nI did stress testing using a slow-but-saffer function as \"control group\". After that, I was able to create a faster function.\n\nHowever, my implementation is problematic for some pisano cycles.\nAs you might see in here:\nhttp://webspace.ship.edu/msrenault/fibonacci/fiblist.htm\n some mods can create huge Pisano periodic-cycles... \n\nMy function works really fast for mods like <249... However, I don't know how to deal with mods like 1570, which generates a pattern/cycle with a total length of 4740 numbers... That's the a ciclical pattern involving not 001 our 12113 but 4740 numbers...\n\nI tried searching for a way to solve this. I was able to find different approaches that would solve the problem. Nonetheless, I would like to try fixing my implementation, making it faster on the cycle-recognition part - if this is possible at all....\n\nThat's my code.\n\n```\ncoursera_input = (input())\ncoursera_input = (coursera_input.split())\nn_in = int(coursera_input[0])\nmod_in = int(coursera_input[1])\n\nimport random\n\ndef my_fibo_iter(x):\n    if x<=1:\n        return x\n    else:\n        bef_previous_elem = 0\n        previous_elem = 1\n        current = 0\n        count = 1\n        while count<x:\n            count = count + 1\n            current = bef_previous_elem + previous_elem\n            bef_previous_elem = previous_elem\n            previous_elem = current\n        return (current)\n\ndef fibo_iter_mod_slow(n,mod):\n    if n==0:\n        return n%mod\n    elif n==1:\n        return n%mod\n    else:\n        previous = 1%mod\n        bef_previous = 0%mod \n        count = 1\n        while count<(n):\n                current = bef_previous%mod + previous%mod \n                bef_previous = previous%mod \n                previous = current%mod \n                count = count + 1\n        return current%mod \n\n#preciso construir um algoritmo para identificar a pisano period/cycle\n\ndef pisano_cycle(big_list):\n    promising_list = []\n    for i in big_list:\n        promising_list.append(i)\n        p_l_len = len(promising_list)\n        p_l_final_index = 2*p_l_len\n        if promising_list == big_list[p_l_len:p_l_final_index]:\n            break\n    return promising_list\n\ndef generate_big_pisano_list(mod):\n    big_list = []\n    if mod<249:\n        limit = 700\n    if 249<=mod<1000:\n        limit = 3001\n    else:\n        limit = 6000\n    for i in range(0,limit):\n        big_list.append(fibo_iter_mod_slow(i,mod))\n    return big_list\n\n#agora eu sei gerar uma lista pisano\n#sei identificar uma lista de pisano\n#preciso de uma outra função\n#ela deve, sabendo o padrão CÍCLICO, identificar o nth elemento desse padrão\n\n\ndef fibo_iter_mod_fast(n,mod):\n    big_pisano_list = generate_big_pisano_list(mod)\n    pattern = pisano_cycle(big_pisano_list)\n    length_patt = len(pattern)\n    index_analogous = (n%length_patt)\n    output_in_mod = pattern[index_analogous]\n    return output_in_mod\n\nprint (fibo_iter_mod_fast(n_in,mod_in))\n```\n\n\nIf you input something like:\n\n```\n2816213588 30524\n```\n\n\nIt gets the correct output:\n\n```\n10249\n```\n\n\nBut it takes more than 5 seconds...\n\nAnother problem that happens is when I have a huge number as an input for the mod, like:\n\nFailed case #12/22: (Wrong answer) \n\nInput: 99999999999999999 100000 \n\nYour output: 69026 \n\nCorrect output: 90626 \n\n(Time used: 0.04/5.00, memory used: 24100864/536870912.)\n\nMy code returns an incorrect output due to this part:\n\n```\n   def generate_big_pisano_list(mod):\n        big_list = []\n        if mod<249:\n            limit = 700\n        if 249<=mod<1000:\n            limit = 3001\n        else:\n            limit = 6000\n```\n\n\nI am limiting the range of the pisano cycle in a range of 60000 numbers, and some pisano cycles, apparently, can go really beyond that...\n    ", "Answer": "\r\nYou should compute Fibonacci number with modulo arithmetic instead of computing the cycle length, for which there is a logarithmic algorithm.\n\nThe total number of iterations required for that is certainly lower than the one required to compute explicitly the pisano cycle length.\n\nThe relation you have to exploit is\n\n```\nfib(2n) = fib(n) * ( 2 * fib(n+1) - fib(n) )\nfib(2n+1) = fib(n+1) ^ 2 + fib(n) ^ 2\n```\n\n\nIf you do the multiplications and additions in modulo arithmetic you can use integer data types (10^5 < 2^17) for an exact result.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Non-exhaustive pattern matching\r\n                \r\nI am working on a project that works on Modular Arithmetic.\nI ran into the pattern matching problem when I'm invoking the function.\nHere is the constructor of type Modular.\nmadd takes two instance of type Modular, and is suppose to add them up returning of type Modular.\n\n```\ndata Modular = Mod Integer Integer deriving Show\ninstance (Eq Modular) where\n  (Mod a1 m1) == (Mod a2 m2) = m1==m2 && mod (a1-a2) m1 == 0\n\n\n-- Adds two modular numbers of the same modulus\nmadd :: Modular -> Modular -> Modular\nmadd (Mod a1 m1) (Mod a2 m2) | m1 == m2 = Mod (mod (a1+a2) m1) m1\n```\n\n\nCan anyone help me why am I getting non-exhaustive pattern matching?\nthe error is like this:\n\n```\nWarning: Pattern match(es) are non-exhaustive\n         In an equation for `madd':\n             Patterns not matched: (Mod _ _) (Mod _ _)\n```\n\n\nBTW, I am using haskell plugin within eclipse IDE.\n    ", "Answer": "\r\nFor a quick fix, you can always add your own error reporting:\n\n```\nmadd (Mod a1 m1) (Mod a2 m2) | m1 == m2 = Mod (mod (a1+a2) m1) m1\nmadd (Mod a1 m1) (Mod a2 m2) = \n                  error (\"You can not add  a mod \" ++ show m1 \n                             ++ \" number with a \" show m2 ++ \" number.\")\n```\n\n\nNot only does this get rid of the warning, but it also can be used to give you more information if the case is called.  Of course if it is triggered, the program will crash (as it would without the extra case)....  If I want to communicate an error to the end user I would put something less harsh in.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How does one trap arithmetic overflow errors in Swift?\r\n                \r\nThis one is probably easy. We know that the operator ```\n&+```\n does modular arithmetic on integers (wraps around), while the operator ```\n+```\n causes an error.\n\n```\n$ swift\n  1> var x: Int8 = 100\nx: Int8 = 100\n  2> x &+ x\n$R0: Int8 = -56\n  3> x + x\nExecution interrupted. Enter Swift code to recover and continue.\n```\n\n\nWhat kind of error is this? I can't catch it and I can't turn it in to an optional:\n\n```\n  4> do {try x + x} catch {print(\"got it\")}\nExecution interrupted. Enter Swift code to recover and continue.\n  5> try? x + x\nExecution interrupted. Enter Swift code to recover and continue.\n```\n\n\nI'm pretty sure this kind of error is the same kind of error from this Stack Overflow question (a divide-by-zero) but I don't know if this kind of error can be trapped. What simple thing am I missing? Can it be trapped or not? If so, how?\n    ", "Answer": "\r\nDistinguish between an exception and a runtime error. An exception is thrown and can be caught. A runtime error stops your program dead in its tracks. Adding and getting an overflow is a runtime error, plain and simple. There is nothing to catch.\n\nThe point of an operator like ```\n&+```\n is that it doesn't error and it doesn't tell you there was a problem. That is the whole point.\n\nIf you think you might overflow, and you want to know whether you did, use static methods like ```\naddWithOverflow```\n. It returns a tuple consisting of the result and a Bool stating whether there was an overflow.\n\n```\nvar x: Int8 = 100\nlet result = x &+ x // -56\n\nx = 100\nlet result2 = Int8.addWithOverflow(x,x) // (-56, true)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to order or compare two circular variables (i.e. milliseconds in whole minute), modular arithmetic [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Check if cyclic (modulo 16) number is larger than another?\r\n                            \r\n                                (4 answers)\r\n                            \r\n                    \r\n                Closed 2 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have 2 timestamps represented as milliseconds in the last minute. Imagine there are no synchronization issues between nodes.\nThe receiver has to distinguish which is the first that was generated message. Unfortunately, after 59 seconds the variables restart, then how to compare these two variables?\nRemark: imagine there is a max delay between the timers, i.e. 10 seconds. Otherwise the is no solution to this problem.\nMy solution is posted below.\n    ", "Answer": "\r\nComments in code below:\n```\n#include <limits.h>\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nbool millis_in_last_minute_is_valid(int time) {\n    // represented as milliseconds in the last minute\n    // after 59 seconds the variables restart\n    static_assert(INT_MAX > 59999, \"Use long and not int to represent numbers greater then 2^16. int has __at least__ 16 bits, it may have 16 bits, in which case INT_MAX is around 32000, which will be lower then 59999 and not able to represent your timestamp\");\n    return 0 <= time && time <= 59999;\n}\n\n/**\n * @return true if time1 is happened before time2, false otherwise.\n */\nbool timestamp_millis_in_last_minute_happened_before(int time1, int time2) {\n    assert(millis_in_last_minute_is_valid(time1));\n    assert(millis_in_last_minute_is_valid(time2));\n    const int diff = abs(time2 - time1);\n    // imagine there is a max delay between the timers, i.e. 10 seconds\n    /**\n    There are 4 cases:\n        0---------time---------->60000\n        [---------T1--T2-------->\n        [---------T2--T1-------->\n        [-T2-----------------T1->\n        [-T1-----------------T2->\n    If the difference is smaller then 10 seconds, it's \n    one of two first cases, if it's grater then 10 seconds,\n    it's one of the latter. If the latter, the comparison\n    needs to just be inverted.\n    */\n    // assert the difference between timestamps is max 10 seconds\n    assert(\n        // First two cases\n        (0 <= diff && diff <= 10000) ||\n        // Latter two cases\n        (50000 <= diff && diff < 60000));\n    return diff <= 10000 ? time1 < time2 : time2 < time1;\n}\n\nint main() {\n    // simple test cases with assert\n    // 0 is not lower then 0         |T1T2------->     T1 happened with T2\n    assert(timestamp_millis_in_last_minute_happened_before(0, 0) == 0);\n    // 1 is not lower then 0         |T2-T1------>     T1 happened after T2\n    assert(timestamp_millis_in_last_minute_happened_before(1, 0) == 0);\n    // 0 is lower then 1             |T1-T2------>     T1 happened before T2\n    assert(timestamp_millis_in_last_minute_happened_before(0, 1) == 1);\n    // 59 second happens before 1    |T2------T1->     T1 happened before T2\n    assert(timestamp_millis_in_last_minute_happened_before(59000, 1) == 1);\n    // 1 happens before 59 second    |T1------T2->     T1 happened before T2\n    assert(timestamp_millis_in_last_minute_happened_before(1, 59000) == 0);\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How do you raise a Java BigInteger to the power of a BigInteger without doing modular arithmetic?\r\n                \r\nI'm doing some large integer computing, and I need to raise a BigInteger to the power of another BigInteger. The .pow() method does what I want, but takes an int value as an argument.  The .modPow method takes a BigInteger as an argument, but I do not want an answer congruent to  the value I'm trying to compute.\n\nMy BigInteger exponent is too large to be represented as an int, can someone suggest a way to work around this limitation?\n    ", "Answer": "\r\nYou shouldn't try to calculate the power of an extremely large number with another extremely large number. The resulting number would use huge amounts of memory. If you calculate ```\na.pow(b)```\n it will have approximately ```\nlog(a)*b```\n digits. If ```\nb```\n is too large to fit in an integer then for even quite small values of ```\na```\n the result will have several billion digits.\n\nTry to rethink what you are trying to achieve and how to achieve it without doing this operation.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Is there a mathematical formula for two's complement multiplication when dealing with overflow?\r\n                \r\nFor instance, given a word size of 4 bits:\n\n```\n0b1001 * 0b0111 = 0b1111 // -7 * 7 = -1\n0b0111 * 0b0111 = 0b0001 // 7 * 7 = 1\n0b0111 * 0b0110 = 0b1010 // 7 * 6 = -6\n0b1001 * 0b0110 = 0b0110 // -7 * 6 = 6\n```\n\n\nThere's undoubtedly some modular arithmetic going on here, but the way you take mod seems to be quite inconsistent. Is there a neat mathematical formulation of two's complement multiplication?\n    ", "Answer": "\r\nThe nice thing about twos complement is that addition, subtraction, and multiplication of signed operands are exactly the same operations, bit-for-bit, as the ones for unsigned operands, so the computer doesn't need to care whether you think of them as signed or not.\n\nIn terms of modular arithmetic as well, the operations mean exactly the same thing.  With 4 bit words, when you say:\n\n```\nr = a * b;\n```\n\n\nYou get r = a * b mod 16.\n\nThe only difference between signed and unsigned is the value we assign in our heads to the residues mod 16.  If we think of the words as unsigned then we have values 0-15.  But 15 = -1 mod 16, 14 = -2 mod 16, etc, and if we think of the words as signed, then we just think of the values -8 to 7 instead of 0 to 15.\n\nThe reminder operator ```\n%```\n that you get in C, java, etc, is annoying in the way it handles negative numbers.  If you wanted to express your 4-bit multiply using that operator in larger words, then you could say:\n\n```\na * b =  ( (a * b % 16) + 24 ) % 16 - 8\n```\n\n\nIf the remainder operator worked \"properly\" so that -1 % 16 == 15, then you could write ```\na * b = (a * b + 8) % 16 - 8```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Calculation particular row mod 10^9+7 of pascal table\r\n                \r\nwhat i  want to store is a particular row of pascal table elements mod 10^9+7  in an array i tried to code it but it is failing somewhere when value is huge of like 10^5\n here is the code. i have tried to apply modular inverse here and modular arithmetic here mod is 10^9+7 \n\n```\nvoid pascal_row(ll n){\nmemset(soo,0,MAX);\nsoo[0] = 1; //First element is always 1\nfor(ll i=1; i<n/2+1; i++){ //Progress up, until reaching the middle value\n   soo[i] = (  ( soo[i-1] %mod ) * (((   (n-i+1)%mod * calcInverse(i,mod)%mod) % mod ))%mod)%mod;\n\n\n}\nfor(ll i=n/2+1; i<=n; i++){ //Copy the inverse of the first part\n    soo[i] = soo[n-i]%mod;\n}\n}\n```\n\n\nhere is what my modular inverse function look\n\n```\nlong long calcInverse(long long a, long long n)\n{\nlong long t = 0, newt = 1;\nlong long r = n, newr = a;\nwhile (newr != 0) {\n    auto quotient = r /newr;\n    tie(t, newt) = make_tuple(newt, t- quotient * newt);\n    tie(r, newr) = make_tuple(newr, r - quotient * newr);\n}\nif (r > 1)\n    throw runtime_error(\"a is not invertible\");\nif (t < 0)\n    t += n;\nreturn t;\n}\n```\n\n\nPlease tell what is the correct way of doing this Thanks\n    ", "Answer": "\r\nThere's a relationship between the elements of Pascal's triangle and the choose function (where n choose r = n!/(r!*(n-r)!).)  Specifically, starting from zero, the n'th row and r'th column of Pascal's triangle is n choose r.  To find a particular row, you know what n you want, and then you should iterate over the possible values of r, find n choose r, and then take your modulus.\n\nI'd recommend Java's BigInteger class for this, because it will handle any overflow errors you might be getting.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modulo of Division of Two Numbers\r\n                \r\nwe know that\n\n```\n(A + B) % P = (A % P + B % P) % P\n(A * B) % P = (A % P * B % P) % P\n```\n\n\nwhere ```\nP```\n is a prime .\n\nI need to calculate ```\n(A / B) % P```\n where ```\nA,B```\n can be very large and can overflow .\n\nDoes such kind of formula for modular arithmetic holds for ```\n(A / B) % P```\n and ```\n(A - B) % P```\n.\n\nIf not then please explain what the correct answer is.\n\nI.e is it true that ```\n(A / B) % P = ((A % P) / (B % P)) % P```\n?\n\nI WAS TRYING TO CALULATE (N*(N^2+5)/6)%P where N can be as large as 10^15\n\nhere A=n*(n^2+5) can surely overflow for n=10^15\n    ", "Answer": "\r\nYes, but it's different:\n\n```\n(a - b) mod p = ((a mod p - b mod p) + p) mod p\n\n(a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p\n```\n\n\nWhere ```\nb^(-1) mod p```\n is the modular inverse of ```\nb```\n mod ```\np```\n. For ```\np = prime```\n, ```\nb^(-1) mod p = b^(p - 2) mod p```\n.\n\nEdit:\n\n\n  (N*(N^2+5)/6)%P\n\n\nYou don't need any modular inverses from this. Just simplify the fraction: ```\nN or N^2+5```\n will be divisible by ```\n2```\n and ```\n3```\n. So divide them and then you have ```\n(a*b) mod P```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Fast powering / Successive squaring algorithm moving too slow with larger amount of digits\r\n                \r\nSo, I'm attempting to implement a modular arithmetic fast-powering algorithm in Python, but I seem to be hitting severe bottlenecks. \nSo, as I understand it, you're supposed to find a binary representation of the exponent and calculate the product of the base^2^i, where i is the number of binary digits.\nMy python code is an implementation of the definition of the algorithm usually seen online and in textbooks:\n\n```\n    def fastPower(base, exp, mod):\n        base %= mod\n        workingExp = exp\n        product = 1\n        upperBound = range(int(math.ceil(math.log(exp,2))))\n        for i in upperBound:\n            print upperBound\n            binDigit = workingExp % 2\n            workingExp /= 2\n            binExp = (binDigit << i)\n            product *= base ** binExp\n            product %= mod\n        return product\n```\n\n\nThe bottleneck is at ```\nproduct *= base ** binExp```\n because the powers of 2 end up getting really\nlarge when you hit 20-bit numbers, slowing down the exponentiation to sub-fast powering speeds.\nIs there something unique to modular arithmetic I'm missing in this implementation? Or perhaps I've put operations in poor places for optimizations?\n    ", "Answer": "\r\nHm....I am more familiar with something like this:\n\n```\ndef fastPower(base, exp, mod):\n    if exp == 0:\n        x = 1\n    else:\n        half = fastPower(base, exp // 2, mod)  # just / in Python 2\n        x = half * half\n        if exp % 2 == 1:\n            x *= base\n    return x % mod\n```\n\n\nIt does have a little overhead due to recursion, though it is very clear and still fairly fast.\n\nOr, if I wanted it to be fast:\n\n```\ndef fastPower(base, exp, mod):\n    return pow(base, exp, mod)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Does benchmark in java good for compared modular arithmatic operations?\r\n                \r\nCan I rely on the results of the benchmark in java to compare the calculations such as modular arithmetic to compare between two operation for example\nA = B x C MOD N\nD = E^-1 MOD N\nQ1)\nI want to know.\nMultiplication equivalent amount of time to find the inverted\nIf answer yes. Please suggest how that works.\nQ2)\nI've got a question about benchmarks in Java, in particular.\nDoes UNIX OS better than WXP OS when use Java benchmar Rather UNIX OS give us best results or no?\n    ", "Answer": "\r\n\nMultiplication is typically faster than modular inversion since modular inversion tends to require many multiplications. (Depends on the algorithm you are using, though.)\nInteger arithmetic is accurate everywhere, Unix and Windows are the same.\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "real modulo operator in C/C++? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                Closed 10 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\n\n  Possible Duplicate:\n  How to code a modulo (%) operator in C/C++/Obj-C that handles negative numbers  \n\n\n\n\nFrom what I understand (see Modulo operator with negative values and Modulo operation) C & C++ have a \"remainder\" operator ```\na % b```\n but no operator that actually does modular arithmetic when the LHS is negative.\n\nSeveral languages do have such a function. Is it possible to build an efficient function in C/C++ (or is there no efficient way to do it on i686/x64 CPUs)?\n\nCurrently I use ```\n(n * b + a) % b```\n where ```\nn```\n is picked such that I'm fairly sure the entire LHS is non-negative, but inevitably code gets changed and bugs sometimes occur.\n\nNote: in case it's not clear, by modular arithmetic I mean an operator such that ```\na + b % b = a % b```\n for all integers ```\na```\n and all positive integers ```\nb```\n.\n    ", "Answer": "\r\nThere is no simple way to do it, however it is more efficient if you create a two-line solution, and spare a multiplication plus determining ```\nn```\n.\n\n```\ninline int modulo(int a, int b) {\n  const int result = a % b;\n  return result >= 0 ? result : result + b;\n}\n```\n\n\nAlso, if you need to work correctly for negative ```\nb```\n numbers as well, add to the beginning:\n\n```\n          if(b < 0) return modulo(-a, -b);\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Modular Math in Java (Number Line which Wraps Around)\r\n                \r\nI am trying to create a simple function that utilizes modular arithmetic. This is essentially a number line that wraps around. Specifically I want to use a Mod 8 number line in Java. \n\nWhat I want is to compare two numbers between 0 and 7.  I want to subtract these numbers to get a difference score. However, instead of 0-7=-7, I want it to equal 1. The idea being that after you reach 7, the number line wraps around back to 0 (therefore 0 and 7 are only one space across.)\n\nAre there any packages that fit this criterion?\n    ", "Answer": "\r\nhow about ```\n((0-7)+8) % 8```\n ? This should fix up your case.\n\nNote: % is the Modular operator.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why does compiling this code requires very high memory usage and time only in GCC?\r\n                \r\nGodbolt Link to the code\n\nLogic: Computing a binomial coefficient over a few iterations using a Modular<> struct which is a wrapper over integer supporting modular arithmetic. Combinatorics struct contains two arrays of \"Modular\" integers, one for factorials and other for inverse factorials (modular multiplicative inverse of the corresponding factorial).\n\nOn Linux, compilation using GCC took over 3.3GB of memory and 100% CPU utilization for over 30 minutes, and thereafter I had to kill it. This hints for an infinite loop.\n\nBut other compilers like Clang, ICC, MSVC compiles this code successfully and well within limits.\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why is casting from char to std::byte potentially undefined behavior?\r\n                \r\nThe ```\nstd::byte```\n of C++17 is required to be enum class:\n\n```\nenum class byte : unsigned char {};\n```\n\n\nWe may want to use that ```\nstd::byte```\n to represent raw memory instead of one of ```\nchar```\ns since it is more type-safe, has its byte-specific operators defined and can't promote to ```\nint```\n out of blue like ```\nchar```\ns do. We need to use explicit casts or ```\nto_integer```\n to convert ```\nstd::byte```\n to other integers. However from lot of  sources we still get ```\nchar```\n (or more likely whole buffers of ```\nchar```\n) and so may want to convert it:\n\n```\nvoid fn(char c)\n{\n    std::byte b = static_cast<std::byte>(c);\n    // ... that may invoke undefined behavior, read below\n}\n```\n\n\nThe signedness of ```\nchar```\n is implementation-defined so ```\nstd::numeric_limits<char>::is_signed```\n may be ```\ntrue```\n. Therefore above ```\nc```\n may have negative values that are outside of range of ```\nunsigned char```\n. \n\nNow in C++17 standard in 8.2.9 Static cast [expr.static.cast] paragraph 10\nwe can read that:\n\n\n  A value of integral or enumeration type can be explicitly converted to\n  a complete enumeration type. The value is unchanged if the original\n  value is within the range of the enumeration values (10.2). Otherwise,\n  the behavior is undefined.\n\n\nAnd from 10.2 we can see that the mentioned range is range of underlying type. Therefore to avoid undefined behavior we have to write more code. For example we can add a cast to ```\nunsigned char```\n to achieve defined effects of modular arithmetic during cast:\n\n```\nvoid fn(char c)\n{\n    std::byte b = static_cast<std::byte>(static_cast<unsigned char>(c));\n    // ... now we have done it in portable manner?\n}\n```\n\n\nDid I misunderstand something? Isn't that over-abundantly complicated and restrictive? Why can't the ```\nenum class```\n that has unsigned underlying type follow modular arithmetic like its underlying type does? Note that the whole row of casts is most likely compiled into nothing by compiler anyway. The ```\nchar```\n when it is signed has to be two's complement since C++14 and so its bitwise representation has to be same as after modular arithmetic conversion to ```\nunsigned char```\n. Who benefits from that formal undefined behavior and how?  \n    ", "Answer": "\r\nThis is going to be fixed in the next standard:\n\nA value of integral or enumeration type can be explicitly converted to a complete enumeration type. If the enumeration type has a fixed underlying type, the value is first converted to that type by integral conversion, if necessary, and then to the enumeration type. If the enumeration type does not have a fixed underlying type, the value is unchanged if the original value is within the range of the enumeration values ([dcl.enum]), and otherwise, the behavior is undefined\n\nHere's the rationale behind the change from (C++11) unspecified to (C++17) undefined:\n￼\n\nAlthough issue 1094 clarified that the value of an expression of enumeration type might not be within the range of the values of the enumeration after a conversion to the enumeration type (see 8.2.9 [expr.static.cast] paragraph 10), the result is simply an unspecified value. This should probably be strengthened to produce undefined behavior, in light of the fact that undefined behavior makes an expression non-constant.\n\nAnd here's the rationale behind the C++2a fix:\n\nThe specifications of std::byte (21.2.5 [support.types.byteops]) and bitmask (20.4.2.1.4 [bitmask.types]) have revealed a problem with the integral conversion rules, according to which both those specifications have, in the general case, undefined behavior. The problem is that a conversion to an enumeration type has undefined behavior unless the value to be converted is in the range of the enumeration.\nFor enumerations with an unsigned fixed underlying type, this requirement is overly restrictive, since converting a large value to an unsigned integer type is well-defined.\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "A 1024 bits RSA algorithm with C\r\n                \r\nI am working on a small project with C language , it's an RSA text encrypting .\n\nThe code works but the problem is that it doesn't work if i choose a large key .\nI think that the problem is due to the modular arithmetic but i can't find the solution.\n\nThere is the code of the 2 functions :\n\nENCRYPT\n\n```\n     unsigned int crypt( unsigned int mchiff, unsigned int n,unsigned int e)\n{\n      unsigned int i;\n      double cc=1;   \n      printf(\"\\n\\n\\n\");\n        for(i=0;i<e;i++)\n    {\n       cc=cc*mchiff;\n       printf(\" : %g :    \",cc);\n       cc=fmod(cc,n);\n       printf(\" < %g > \\n\",cc);\n    }\n      printf(\"\\n\\n\\n\");\n      return cc;\n}\n```\n\n\nDECRYPT\n\n```\nunsigned long int decrypt(long cc,int n,int d)\n{\n      int i;\n      unsigned long int cd=1;\n        for(i=0;i<d;i++)   /* the main problem is here if the d is apprx equal to 2^1024 */\n    {\n       cd=cd*cc;\n       cd=cd%n;\n    }\n      return cd;\n}\n```\n\n    ", "Answer": "\r\n```\nint```\n is limited to 32-bit (usually). You want a type that can hold 1024 bits or more. You should use an external library like GNU MP for that.\n\nAnd if you're not trying to learn about RSA and just trying to use, I'd just go with an existing implementation to save you the trouble. OpenSSL has everything.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to solve for X in an equation with modulus?\r\n                \r\nFairly new to modular arithmetic and I've searched through several sources and have not figured out how to do this. I have the following equation:\n\ns = (k * (h + x * r)) mod q\n\nHow would one solve for x? I am quite unsure of what to do with the mod q.\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why are λ-calculus optimal evaluators able to compute big modular exponentiations without formulas?\r\n                \r\nChurch numbers are an encoding of natural numbers as functions.\n\n```\n(\\ f x → (f x))             -- church number 1\n(\\ f x → (f (f (f x))))     -- church number 3\n(\\ f x → (f (f (f (f x))))) -- church number 4\n```\n\n\nNeatly, you can exponentiate 2 church numbers by just applying them. That is, if you apply 4 to 2, you get the church number ```\n16```\n, or ```\n2^4```\n. Obviously,  that is utterly unpractical. Church numbers need a linear amount of memory and are really, really slow. Computing something like ```\n10^10```\n - which GHCI quickly answers correctly - would take ages and couldn't fit the memory on your computer anyway. \n\nI've been experimenting with optimal λ evaluators lately. On my tests, I accidentally typed the following on my optimal λ-calculator:\n\n```\n10 ^ 10 % 13\n```\n\n\nIt was supposed to be multiplication, not exponentiation. Before I could move my fingers to abort the forever-running program in despair, it answered my request:\n\n```\n3\n{ iterations: 11523, applications: 5748, used_memory: 27729 }\n\nreal    0m0.104s\nuser    0m0.086s\nsys     0m0.019s\n```\n\n\nWith my \"bug alert\" flashing, I went to Google and verified, ```\n10^10%13 == 3```\n indeed. But the λ-calculator wasn't supposed to find that result, it can barely store 10^10. I started stressing it, for science. It instantly answered me ```\n20^20%13 == 3```\n, ```\n50^50%13 == 4```\n, ```\n60^60%3 == 0```\n. I had to use external tools to verify those results, since Haskell itself wasn't able to compute it (due to integer overflow) (it is if you use Integers not Ints, of course!). Pushing it to its limits, this was the answer to ```\n200^200%31```\n:\n\n```\n5\n{ iterations: 10351327, applications: 5175644, used_memory: 23754870 }\n\nreal    0m4.025s\nuser    0m3.686s\nsys 0m0.341s\n```\n\n\nIf we had one copy of the universe for each atom on the universe, and we had a computer for each atom we had in total, we couldn't store the church number ```\n200^200```\n. This prompted me to question if my mac was really that powerful. Maybe the optimal evaluator was able to skip the unnecessary branches and arrive right at the answer in the same fashion Haskell does with lazy evaluation. To test this, I compiled the λ program to Haskell:\n\n```\ndata Term = F !(Term -> Term) | N !Double\ninstance Show Term where {\n    show (N x) = \"(N \"++(if fromIntegral (floor x) == x then show (floor x) else show x)++\")\";\n    show (F _) = \"(λ...)\"}\ninfixl 0 #\n(F f) # x = f x\nchurchNum = F(\\(N n)->F(\\f->F(\\x->if n<=0 then x else (f#(churchNum#(N(n-1))#f#x)))))\nexpMod    = (F(\\v0->(F(\\v1->(F(\\v2->((((((churchNum # v2) # (F(\\v3->(F(\\v4->(v3 # (F(\\v5->((v4 # (F(\\v6->(F(\\v7->(v6 # ((v5 # v6) # v7))))))) # v5))))))))) # (F(\\v3->(v3 # (F(\\v4->(F(\\v5->v5)))))))) # (F(\\v3->((((churchNum # v1) # (churchNum # v0)) # ((((churchNum # v2) # (F(\\v4->(F(\\v5->(F(\\v6->(v4 # (F(\\v7->((v5 # v7) # v6))))))))))) # (F(\\v4->v4))) # (F(\\v4->(F(\\v5->(v5 # v4))))))) # ((((churchNum # v2) # (F(\\v4->(F(\\v5->v4))))) # (F(\\v4->v4))) # (F(\\v4->v4))))))) # (F(\\v3->(((F(\\(N x)->F(\\(N y)->N(x+y)))) # v3) # (N 1))))) # (N 0))))))))\nmain = print $ (expMod # N 5 # N 5 # N 4)\n```\n\n\nThis correctly outputs ```\n1```\n (```\n5 ^ 5 % 4```\n) - but throw anything above ```\n10^10```\n and it will be stuck, eliminating the hypothesis. \n\nThe optimal evaluator I used is a 160-lines long, unoptimized JavaScript program that didn't include any sort of exponential modulus math - and the lambda-calculus modulus function I used was equally simple:\n\n```\n(λab.(b(λcd.(c(λe.(d(λfg.(f(efg)))e))))(λc.(c(λde.e)))(λc.(a(b(λdef.(d(λg.(egf))))(λd.d)(λde.(ed)))(b(λde.d)(λd.d)(λd.d))))))\n```\n\n\nI used no specific modular arithmetic algorithm or formula. So, how is the optimal evaluator able to arrive at the right answers?\n    ", "Answer": "\r\nThe phenomenon comes from the amount of shared beta-reduction steps, which can be dramatically different in Haskell-style lazy evaluation (or usual call-by-value, which is not that far in this respect) and in Vuillemin-Lévy-Lamping-Kathail-Asperti-Guerrini-(et al…) \"optimal\" evaluation. This is a general feature, that is completely independent from the arithmetic formulas you could use in this particular example.\n\nSharing means having a representation of your lambda-term in which one \"node\" can describe several similar parts of the actual lambda-term you represent. For instance, you can represent the term \n\n```\n\\x. x ((\\y.y)a) ((\\y.y)a)\n```\n\n\nusing a (directed acyclic) graph in which there is only one occurrence of the subgraph representing ```\n(\\y.y)a```\n, and two edges targeting that subgraph. In Haskell terms, you have one thunk, that you evaluate only once, and two pointers to this thunk.\n\nHaskell-style memoization implements sharing of complete subterms. This level of sharing can be represented by directed acyclic graphs. Optimal sharing does not have this restriction: it can also share \"partial\" subterms, which may imply cycles in the graph representation.\n\nTo see the difference between these two levels of sharing, consider the term\n\n```\n\\x. (\\z.z) ((\\z.z) x)\n```\n\n\nIf your sharing is restricted to complete subterms as it is the case in Haskell, you may have only one occurrence of ```\n\\z.z```\n, but the two beta-redexes here will be distinct: one is ```\n(\\z.z) x```\n and the other one is ```\n(\\z.z) ((\\z.z) x)```\n, and since they are not equal terms they cannot be shared.\nIf the sharing of partial subterms is allowed, then it becomes possible to share the partial term ```\n(\\z.z) []```\n (that is not just the function ```\n\\z.z```\n, but \"the function ```\n\\z.z```\n applied to something), which evaluates in one step to just something, whatever this argument is. Hence you can have a graph in which only one node represents the two applications of ```\n\\z.z```\n to two distinct arguments, and in which these two applications can be reduced in just one step. Remark that there is a cycle on this node, since the argument of the \"first occurrence\" is precisely the \"second occurrence\".\nFinally, with optimal sharing you can go from (a graph representing) ```\n\\x. (\\z.z) ((\\z.z) x))```\n to (a graph representing) the result ```\n\\x.x```\n in just one step of beta-reduction (plus some bookkeeping). This is basically what happens in your optimal evaluator (and the graph representation is also what prevents space explosion).\n\nFor slightly extended explanations, you can look at the paper Weak Optimality, and the Meaning of Sharing (what you are interested in is the introduction and the section 4.1, and maybe some of the bibliographic pointers at the end).\n\nComing back at your example, the coding of arithmetic functions working on Church integers is one of the \"well-known\" mines of examples where optimal evaluators can perform better than mainstream languages (in this sentence, well-known actually means that a handful of specialists are aware of these examples).\nFor more such examples, take a look at the paper Safe Operators: Brackets Closed Forever by Asperti and Chroboczek (and by the way, you will find here interesting lambda-terms that are not EAL-typeable; so I’m encouraging you to take a look at oracles, starting with this Asperti/Chroboczek paper).\n\nAs you said yourself, this kind of encoding is utterly unpractical, but they still represent a nice way of understanding what is going on. And let me conclude with a challenge for further investigation: will you be able to find an example on which optimal evaluation on these supposedly bad encodings is actually on par with traditional evaluation on a reasonable data representation? (as far as I know this is a real open question).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "I am having trouble solving a problem using modulo arithmetic\r\n                \r\ni need to apply modulus e=10^9+7 on the given expression i*(n+k-2)-((i*(i+1)*(n-1))/2) where i is in terms of n and k . n and k are inputted by the user.\n2≤N≤10^18\n1≤K≤10^18\n\ni tried using modular arithmetic using the basics i.e  (a-b)%e=((a%e)-(b%e))%e\nand (ab)%e=((a%e)(b%e))%e.\n\n```\n//i have taken unsigned long long int as the data type for all variables    \n    a=1;\n    b=1;\n    cin>>n>>k;\n    i=(n+k-2)/(n-1);\n    //s=(i*(n+k-2))-((i*(n-1)*(i+1))/2\n    j=(i+1);\n    p=n+k-2;\n    q=n-1;\n    r=i/2;\n    u=j/2;\n    if(i%2==0)\n    {\n        a=(a*i)%e;\n        a=(a*p)%e;\n        b=(b*r)%e;\n        b=(b*q)%e;\n        b=(b*j)%e;\n        s=a-b;\n\n    }\n      else\n    {\n        a=(a*i)%e;\n        a=(a*p)%e;\n        b=(b*u)%e;\n        b=(b*q)%e;\n        b=(b*i)%e;\n        s=a-b;\n\n    }\n    cout<<s%e<<endl;\n```\n\n\ni am getting correct answers for small test cases but for large test cases i am not getting the correct answer.\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "string formatting with modulus/percent sign\r\n                \r\nIs there something happening when string formatting that uses the modulus function while calling either\n\n```\nStringOperand % TupleOperand```\n or\n\n```\nStringOperand % DictionaryOperand```\n\n\nOr is it just an arbitrary use of % for the string formatting function?\n\nI'm guessing that the string formatting operator is not a call to modular arithmetic as the following:\n\n```\ntuple = (1,2,3)\nprint '%d %d %d'%tuple\n```\n\n\nprints: 1 2 3, but\n\n```\nprint '%d %d %d %d'%tuple\n```\n\n\nreturns TypeError: not enough args for format str\n    ", "Answer": "\r\nThis is operator overloading. What you are talking about is language build-in, but you may overload methods on your own. Eg overload ```\n+```\n operator that is decorated in python by ```\n__add__```\n method:\n\n```\nclass YourMath(object):\n    def __init__(self, param):\n        self.param = param\n\n    def __add__(self, x):\n        return int(str(self.param) + str(x.param)) # concatenation \n\n\nx = YourMath(5)\ny = YourMath(4)\n```\n\n\n```\n+```\n will concatenate instead of sum up. \nResult of ```\nx+y```\n in this case is ```\n54```\n.   \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Finding whether 2 indices are adjacent in circular list\r\n                \r\nSay I have a circular list which would look like this to a human:\n\nHow can I determine whether two indices are adjacent please?\nSo far I have:\n```\ndef is_next_to(a, b):\n    if a == b:\n        return False\n    return abs(a - b) == 1\n    \n    \nassert is_next_to(1, 1) is False\nassert is_next_to(1, 2) is True\nassert is_next_to(0, 1) is True\nassert is_next_to(5, 0) is True\nassert is_next_to(4, 3) is True\nassert is_next_to(3, 4) is True\n```\n\nDo I need to make special cases for (0, 5) or (5, 0), or is there some way to use modular arithmetic to solve this?\n    ", "Answer": "\r\nIn a circle of 6, the number 5 is a neighbor of 0, but in a circle of 8, the number 5 would not be a neighbor of 0. So you can only reliable determine this when you know the size of the circle: this should be an extra parameter to your function.\nOnce you have that, you can use this:\n```\ndef is_next_to(n, a, b):\n    return abs(a - b) == 1 or a + b == n - 1\n\n    \nn = 6    \nassert is_next_to(n, 1, 1) is False\nassert is_next_to(n, 1, 2) is True\nassert is_next_to(n, 0, 1) is True\nassert is_next_to(n, 5, 0) is True\nassert is_next_to(n, 4, 3) is True\nassert is_next_to(n, 3, 4) is True\n```\n\nWith modular arithmetic it would look like this:\n```\n    return (a + 1) % n == b or (b + 1) % n == a \n```\n\nor:\n```\n    return (a - b) % n in (1, n - 1) \n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Accessing the phantom type of the return value\r\n                \r\nBelow is an implementation of modular arithmetic Num instance that is modeled after ```\nData.Fixed```\n.\n\nI'd like to write an alternate implementation of ```\nfromRational```\n which would look something like:\n\n```\nfromRational r = case invertMod (denominator r) theModulus of\n                   Just inv -> normalize $ (numerator r) * inv\n                   Nothing -> error \"...\"\n```\n\n\nbut I can't figure out what I would use for ```\ntheModulus```\n. Unlike the other type-class functions, I don't have a value of type ```\nModular a```\n around on which I can call ```\nmodulus```\n.\n\n```\n{-# LANGUAGE NoMonomorphismRestriction #-}\n\nimport Math.NumberTheory.Moduli (invertMod)\nimport Data.Ratio (numerator, denominator)\n\nclass HasModulus a where\n  modulus :: p a -> Integer\n\nwithType :: (p a -> f a) -> f a\nwithType foo = foo undefined\n\nwithModulus :: (HasModulus a) => (Integer -> f a) -> f a\nwithModulus foo = withType (foo . modulus)\n\nnewtype Modular a = M Integer\n\nnormalize :: HasModulus a => Integer -> Modular a\nnormalize x = withModulus $ \\m -> M (x `mod` m)\n\ninstance (HasModulus a) => Num (Modular a) where\n  (M a) + (M b) = normalize (a+b)\n  (M a) - (M b) = normalize (a-b)\n  (M a) * (M b) = normalize (a*b)\n  negate (M a)  = normalize (-a)\n  abs           = id\n  signum _      = fromInteger 1\n  fromInteger   = normalize\n\ninstance (HasModulus a) => Fractional (Modular a) where\n  recip ma@(M a) = case invertMod a (modulus ma) of\n                     Just inv -> normalize $ inv\n                     Nothing  -> error \"divide by zero error\"\n  ma / mb        = ma * (recip mb)\n  fromRational r = (fromInteger $ numerator r) / (fromInteger $ denominator r)\n\ninstance (HasModulus a) => Show (Modular a) where\n  show mx@(M x) = (show x) ++ \" mod \" ++ (show $ modulus mx)\n\ndata M5 = M5\ndata M7 = M7\n\ninstance HasModulus M5 where modulus _ = 5\ninstance HasModulus M7 where modulus _ = 7\n\nbar = 1 / 3\n\nmain = do print $ (bar :: Modular M5)\n          print $ (bar :: Modular M7)\n```\n\n    ", "Answer": "\r\nA way to write ```\nfromRational```\n closer to your initial Ansatz is\n\n```\nfromRational r = let x = case invertMod (denominator r) (modulus x) of\n                           Just inv -> normalize $ (numerator r) * inv\n                           Nothing -> error \"...\"\n                 in x\n```\n\n\nSince the result is of type ```\nModular a```\n, we can obtain the modulus from it (without inspecting it). So all we need is to name it, so that we can refer to it where it's needed.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Partial Homomorphic Encryption with Haskell\r\n                \r\nI am working with a fairly simple Paillier partial homomorphic encryption library in Haskell. The API for the library is here - https://hackage.haskell.org/package/Paillier-0.1.0.3/docs/Crypto-Paillier.html\nThis library unfortunately does not handle negative numbers or floating point numbers. It only operates on positive integers. So, an operation like\n```\ndecrypt prvKey pubKey (encrypt pubKey (-10))  =/=  -10\n```\n\nMy naive approach to handling negative numbers and floating points was to multiply the Integers with my desired precision (say 10^6) and then convert it back. But internally, some modular arithmetic does not work for homomorphic multiplication (exponentiation).\nThe problem could somewhat be boiled down to finding a good encoding of negative numbers as well as floating point numbers into an ```\nInteger```\n type (the arbitrary precision integer type in Haskell). Is there any good strategy to do the encoding?\nAnother strategy could be modifying the modular exponentiation function in the cryptonite package to handle modular arithmetic for negative numbers (https://hackage.haskell.org/package/cryptonite-0.30/docs/Crypto-Number-ModArithmetic.html#v:expSafe).\nCan anyone suggest to me the best strategy or something that I am missing out here?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Checking that float modulo int is finite ordinal\r\n                \r\nIn a for-loop, I'm integrating with respect to time with constant, fractional time step, ```\ndt.```\n I only want to save the simulation results for integral (finite ordinal) time points. My solution is as follows,\n\n```\ndt = 0.1\nsteps = 100\n\nfor step in range(steps):\n    if (step*dt) % 1 == 0.0:\n        print step\n```\n\n\nI've never really trusted modular arithmetic on floats. Is there a better way to check if a float is integral or am I simply being paranoid? \n    ", "Answer": "\r\nThis is dangerous, in any programming language.  In your example, ```\n0.1```\n cannot be represented exactly by in floating-point, so that test will never pass (well I suppose it may do after 2^24 iterations or so).  In many cases, the step size may not have an exact representation in floating-point, so that the accumulated rounding error causes the test to erroneously trigger/not trigger.  In other cases, as the accumulated value gets larger, eventually it will begin to lose precision due to the increasing exponent (in your example, assuming Python uses single-precision by default, you'll get an erroneous trigger after 20971529 iterations).\n\nTry to find a way to avoid performing equality tests on floating-point values (checking for integral values is one such test).  So in your case, just test on ```\nstep % 10```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Need help in understanding Rolling Hash computation in constant time for Rabin-Karp Implementation\r\n                \r\nI've been trying to implement Rabin-Karp algorithm in Java. I have hard time computing the rolling hash value in constant time. I've found one implementation at http://algs4.cs.princeton.edu/53substring/RabinKarp.java.html. Still I could not get how these two lines work.\n\n```\ntxtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;\ntxtHash = (txtHash*R + txt.charAt(i)) % Q;  \n```\n\n\nI looked at couple of articles on modular arithmetic but no article could able to penetrate my thick skull. Please give some pointers to understand this. \n    ", "Answer": "\r\nFirst you need to understand how the hash is computed.\n\nLets take a simple case of base 10 strings. How would you guarantee that the hash code of a string is unique? Base 10 is what we use to represent numbers, and we don't have collisions!!\n\n\n  \"523\" = 5*10^2 + 2*10^1 + 3*10^0 = 523\n\n\nusing the above hash function you are guaranteed to get distinct hashes for every string. \n\nGiven the hash of \"523\", if you want to calculate the hash of \"238\", i.e. by jutting out the leftmost digit 5 and bringing in a new digit 8 from the right, you would have to do the following:\n\n\n  1) remove the effect of the 5 from the hash: \n  hash = hash - 5*10^2 (523-500 = 23)\n  \n  2) adjust the hash of the remaining chars by shifting by 1, hash = hash * 10\n  \n  3) add the hash of the new character: \n  hash = hash + 8  (230 + 8 = 238, which as we expected is the base 10 hash of \"238\")\n\n\nNow let's extend this to all ascii characters. This takes us to the base 256 world. Therefore the hash of the same string \"523\" now is \n\n\n  = 5*256^2 + 2*256^1 + 3*256^0 = 327680 + 512 + 3 = 328195.\n\n\nYou can imagine as the string length increases you will will exceed the range of integer/long in most programming languages relatively quickly. \n\nHow can we solve this? The way this is routinely solved is by working with modulus a large prime number. The drawback of this method is that we will now get false positives as well, which is a small price to pay if it takes the runtime of your algorithm from quadratic to linear!\n\nThe complicated equation you quoted is nothing but the steps 1-3 above done with modulus math.\nThe two modulus properties used above are ->\n\n\n  a) (a*b) % p = ((a % p) * (b % p)) % p\n  \n  b) a % p = (a + p) % p\n\n\nLets go back to steps 1-3 mentioned above ->\n\n\n  1) (expanded using property a) hash = hash - ((5 % p)*(10^2 %p) %p)\n\n\nvs. what you quoted\n\n\n  \n    txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;\n  \n\n\nHere are is how the two are related!\n\n\n  \n    \n    RM = 10^3 % p\n    txt.charAt(i-M) % Q = 5 % p\n    The additional + Q you see is just to ensure that the hash is not negative. See property b above.\n    \n  \n  \n  2 & 3) hash = hash*10 + 8, vs txtHash = (txtHash*R + txt.charAt(i)) % Q;\n  Is the same but with taking mod of the final hash result!\n\n\nLooking at properties a & b more closely, should help you figure it out!\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Montgomery multiplication VHDL Implementation\r\n                \r\nI am trying to create a modular arithmetic operation in this case: \n\n```\nx*y mod n\n```\n\n\nAs far as I have read the fastest way to do it is using the Montgomery multiplication, but I cant understand how that is actually done in other to implement it in hardware using VHDL.\n\nHas someone been able to do it or have any library that enables me to use it?\n    ", "Answer": "\r\nA basic shift and add modular multiplication can be found here as a part of this open cores project.\n\nHere's another project that is using the Montgomery multiplication.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to access functions inside a record inside a module\r\n                \r\nI am trying to do modular arithmetic in Coq. I notice there is the ZModulo library which I attempt to import and create the ```\nZModuloCyclicType```\n Module.\n\n```\nRequire Import Utf8_core.\nRequire Import ZArith_base.\nRequire Import Coq.Numbers.Cyclic.ZModulo.ZModulo.\n\nLtac positive_ne1 :=\n  match goal with\n  | [ |- ?p ≠ 1%positive ] => unfold not; intro H; inversion H\n  end.\n\nModule Positive8 : PositiveNotOne.\n  Definition p := 8%positive.\n  Theorem not_one : p ≠ 1%positive. \n  Proof. positive_ne1. Qed.\nEnd Positive8.\nModule ZquotZ8 := ZModuloCyclicType(Positive8).\nExport ZquotZ8.\n```\n\n\nNow, I want to access the ```\nsucc```\n operation which is inside the record ```\nInstance zmod_ops : ZnZ.Ops Z := ZnZ.MkOps```\n. However,\n\n```\nCheck ZquotZ8.ops.succ. (* Error: The reference ZquotZ8_ops.succ was not found in the current environment. *)\nCheck ZquotZ8.ops.(succ). (* Error: The term \"ops\" has type \"ZnZ.Ops t\" while it is expected to have type \"Z\". *)\n\nDefinition ZquotZ8_ops : ZnZ.Ops Z := zmod_ops 8.\nCheck ZquotZ8_ops.succ. (* Error: The reference ZquotZ8_ops.succ was not found in the current environment. *)\nCheck ZquotZ8_ops.(succ). (* Error: The term \"ZquotZ8_ops\" has type \"ZnZ.Ops Z\" while it is expected to have type \"Z\". *)\n```\n\n\nMy question is: how can I access this instance of ```\nsucc```\n instead of the one defined in ```\nCoq.Numbers.Cyclic.ZModulo.ZModulo.```\n?\n\nWhat I want is ```\nCompute succ_Z8 255 = 0%Z : Z```\n or something similar.\n    ", "Answer": "\r\nIf you're set on a record selection, it's\n\n```\nRequire Import Coq.Numbers.Cyclic.Abstract.CyclicAxioms.\n\nZquotZ8.ops.(@ZnZ.succ _)\n(* equivalent to *)\n@ZnZ.succ _ ZquotZ8.ops\n```\n\n\nBut, the thing is, ```\nZnZ.Ops```\n is a ```\nClass```\n, not just a record, ```\nZquotZ8.ops```\n is an ```\nInstance```\n, and ```\nZnZ.succ```\n can find ```\nZquotZ8.ops```\n implicitly because you have used ```\nExport ZquotZ8```\n. So it's just\n\n```\nZnZ.succ\n```\n\n\nHowever, I think you also need to change the header of ```\nPositive8```\n to\n\n```\n(* NOT            : *)\nModule Positive8 <: PositiveNotOne.\n```\n\n\nOtherwise, ```\nPositive8.p```\n is opaque, and you cannot compute with it. Once that's done, you get\n\n```\nCompute (ZnZ.compare (ZnZ.succ 255%Z) 0%Z).\n(* = Eq *)\n```\n\n\nNote that ```\nsucc```\n doesn't roll over; here, it returns ```\n256%Z```\n. ```\nZnZ.to_Z```\n will actually compute the remainder, or you can use ```\nsucc_c```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Python incomplete decryption\r\n                \r\nThis is a program that i made to encrypt text using one time pad encryption, but the program is not properly decrypting the cipher-text, some of the characters are outputted as question marks, i think that the problem is related to the Modular arithmetic part of the code. \n\n```\nimport os\n\n#This will open a file for encryption\no = open('/Users/kyle/Desktop/one-time.txt', 'r')\n#This is the plain text to encrypt\nplain = 'The quick brown fox jumps over the lazy dog'\nprint 50*\"-\"\nprint plain\n#This will measure the length of the plain text\nf3 = len(plain)\n#generate random chacters as long as the text\na1 = os.urandom(f3)\n#makes the random characters tuple format\nb = list(a1)\nb2 = list(plain)\ns = plain\n#gives the ascii value of the charters\nL = [ord(c) for c in s]\nprint 50*\"-\"\ns = a1\na = [ord(c) for c in s]\nb = [ord(c) for c in plain]\n#adds the random digits and the plain text\nc = map(sum, zip(a,b))\nprint c\nprint 50*\"-\"\n#uses Modular arithmetic if the sum is greater than 256 by subtracting 256 \nx=c\nz = []\nfor y in x:\n    z.append(y-256 if y>=256 else y)\nz = [y-256 if y >= 256 else y for y in x]\nprint z\n#converts the sum back to charter form\ncipher_text = ''.join(chr(i) for i in z)\n#makes a folder for the files\nif os.path.exists(\"/Users/kyle/one time pad/\"):\n    print\nelse:\n    os.mkdir(\"/Users/kyle/one time pad/\")\n\n#makes a file containg the plain text\nif os.path.exists(\"/Users/kyle/one time pad/plain text.txt\"):\n    f = file(\"/Users/kyle/one time pad/plain text.txt\", \"w\")\n    f1 = open(\"/Users/kyle/one time pad/plain text.txt\", \"w\")\n    f1.write(plain)\n    f1.close()\nelse:\n    f = file(\"/Users/kyle/one time pad/plain text.txt\", \"w\")\n    f1 = open(\"/Users/kyle/one time pad/plain text.txt\", \"w\")\n    f1.write(plain)\n    f1.close()\n\nkey = a1\n#makes a file containg the key\nif os.path.exists(\"/Users/kyle/one time pad/key\"):\n    f1 = file(\"/Users/kyle/one time pad/key.txt\", \"w\")\n    f1 = open(\"/Users/kyle/one time pad/key.txt\", \"w\")\n    f1.write(key)\n    f1.close()\nelse:\n    f1 = file(\"/Users/kyle/one time pad/key.txt\", \"w\")\n    f1 = open(\"/Users/kyle/one time pad/key.txt\", \"w\")\n    f1.write(key)\n    f1.close()\n\n#makes a file containg the cipher text\nif os.path.exists(\"/Users/kyle/one time pad/cipher text.txt\"):\n    f1 = file(\"/Users/kyle/one time pad/cipher text.txt\", \"w\")\n    f1 = open(\"/Users/kyle/one time pad/cipher text.txt\", \"w\")\n    f1.write(cipher_text)\n    f1.close()\nelse:\n    f1 = file(\"/Users/kyle/one time pad/cipher text.txt\", \"w\")\n    f1 = open(\"/Users/kyle/one time pad/cipher text.txt\", \"w\")\n    f1.write(cipher_text)\n    f1.close()\n\n\nprint 50*\"-\"\n```\n\n\nThis is the code that decrypts the cipher text. \nI think that there might be a problem with the subtraction of the key from the cipher text. \n\n```\n#opens the cipher text and it converts it to decimal\ncipher1 = open(\"/Users/kyle/one time pad/cipher text.txt\", \"r\")\ncipher2 = cipher1.read()\ncipher3 = [ord(c) for c in cipher2]\n\n#opens the key and coverts it to decimal\nkey1 = open(\"/Users/kyle/one time pad/key.txt\", \"r\")\nkey2 = key1.read()\nkey3 = [ord(c) for c in key2]\n\n#subtracts the key from the cipher\nb = cipher3\na = key3\nc = map(lambda x: x[0]-x[1], zip(a,b))\n\n#prints out the decrypted plain text\nc1 = [abs(d) for d in c]\nprint ''.join(map(chr,c1))\n```\n\n    ", "Answer": "\r\nYou could perform a modulus 256 on the final value. You may want to make sure your files are opened in binary mode; not all ```\n(c + x) % 256```\n values will result in a valid character.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Performance optimization with modular addition when the modulus is of special form\r\n                \r\nI'm writing a program which performs millions of modular additions. For more efficiency, I started thinking about how machine-level instructions can be used to implement modular additions.\n\nLet w be the word size of the machine (typically, 32 or 64 bits). If one takes the modulus to be 2^w, then the modular addition can be performed very fast: It suffices to simply add the addends, and discard the carry.\n\nI tested my idea using the following C code:\n\n```\n#include <stdio.h>\n#include <time.h>\n\nint main()\n{\n    unsigned int x, y, z, i;\n    clock_t t1, t2;\n\n    x = y = 0x90000000;\n\n    t1 = clock();\n\n    for(i = 0; i <20000000 ; i++)\n        z = (x + y) % 0x100000000ULL;\n\n    t2 = clock();\n\n    printf(\"%x\\n\", z);\n    printf(\"%u\\n\", (int)(t2-t1));\n\n    return 0;\n}\n```\n\n\nCompiling using GCC with the following options (I used ```\n-O0```\n to prevent GCC from unfolding the loop):\n\n```\n-S -masm=intel -O0\n```\n\n\nThe relevant part of the resulting assembly code is:\n\n```\n    mov DWORD PTR [esp+36], -1879048192\n    mov eax, DWORD PTR [esp+36]\n    mov DWORD PTR [esp+32], eax\n    call    _clock\n    mov DWORD PTR [esp+28], eax\n    mov DWORD PTR [esp+40], 0\n    jmp L2\nL3:\n    mov eax, DWORD PTR [esp+36]\n    mov edx, DWORD PTR [esp+32]\n    add eax, edx\n    mov DWORD PTR [esp+44], eax\n    inc DWORD PTR [esp+40]\nL2:\n    cmp DWORD PTR [esp+40], 19999999\n    jbe L3\n    call    _clock\n```\n\n\nAs is evident, no modular arithmetic whatsoever is involved.\n\nNow, if we change the modular addition line of the C code to:\n\n```\nz = (x + y) % 0x0F0000000ULL;\n```\n\n\nThe assembly code changes to (only the relevant part is shown):\n\n```\n    mov DWORD PTR [esp+36], -1879048192\n    mov eax, DWORD PTR [esp+36]\n    mov DWORD PTR [esp+32], eax\n    call    _clock\n    mov DWORD PTR [esp+28], eax\n    mov DWORD PTR [esp+40], 0\n    jmp L2\nL3:\n    mov eax, DWORD PTR [esp+36]\n    mov edx, DWORD PTR [esp+32]\n    add edx, eax\n    cmp edx, -268435456\n    setae   al\n    movzx   eax, al\n    mov DWORD PTR [esp+44], eax\n    mov ecx, DWORD PTR [esp+44]\n    mov eax, 0\n    sub eax, ecx\n    sal eax, 28\n    mov ecx, edx\n    sub ecx, eax\n    mov eax, ecx\n    mov DWORD PTR [esp+44], eax\n    inc DWORD PTR [esp+40]\nL2:\n    cmp DWORD PTR [esp+40], 19999999\n    jbe L3\n    call    _clock\n```\n\n\nObviously, a great number of instructions were added between the two calls to ```\n_clock```\n.\n\nConsidering the increased number of assembly instructions,\nI expected the performance gain by proper choice of the modulus to be at least 100%. However, running the output, I noted that the speed is increased by only 10%. I suspected the OS is using the multi-core CPU to run the code in parallel, but even setting the CPU affinity of the process to 1 didn't change anything.\n\nCould you please provide me with an explanation?\n\nEdit: Running the example with VC++ 2010, I got what I expected: the second code is around 12 times slower than the first example!\n    ", "Answer": "\r\nArt nailed it.\n\nFor the power-of-2 modulus, the code for the computation generated with ```\n-O0```\n and ```\n-O3```\n is identical, the difference is the loop-control code, and the running time differs by a factor of 3.\n\nFor the other modulus, the difference in the loop-control code is the same, but the code for the computation is not quite identical (the optimised code looks like it should be a bit faster, but I don't know enough about assembly or my processor to be sure). The difference in running time between unoptimised and optimised code is about 2×.\n\nRunning times for both moduli are similar with unoptimised code. About the same as the running time without any modulus. About the same as the running time of the executable obtained by removing the computation from the generated assembly.\n\nSo the running time is completely dominated by the loop control code\n\n```\n    mov DWORD PTR [esp+40], 0\n    jmp L2\nL3:\n    # snip\n    inc DWORD PTR [esp+40]\nL2:\n    cmp DWORD PTR [esp+40], 19999999\n    jbe L3\n```\n\n\nWith optimisations turned on, the loop counter is kept in a register (here) and decremented, then the jump instruction is a ```\njne```\n. That loop control is so much faster that the modulus computation now takes a significant fraction of the running time, removing the computation from the generated assembly now reduces the running time by a factor of 3 resp. 2.\n\nSo when compiled with ```\n-O0```\n, you're not measuring the speed of the computation, but the speed of the loop control code, thus the small difference. With optimisations, you are measuring both, computation and loop control, and the difference of speed in the computation shows clearly.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Off-by 1 Error in Project Euler 19 [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is off-topic. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                    Want to improve this question? Update the question so it's on-topic for Stack Overflow.\r\n                \r\n                    \r\n                        Closed 10 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI'm doing Project Euler #19. It's obviously a trivial problem if you just want to loop through month-by month and apply some high-school modular arithmetic but I'm trying a different approach just for fun. \n\nI note that Jan/Feb 1 1901 are not Sundays, neither are Jan/Feb 1 2001, hence I can view my calendar year as starting on March 1. Using basic modular arithmetic, it's easily seen that if leap years didn't exist, then the number of Xdays in a given year is a repeating sequence {2,2,2,1,2,1,2} since 365 is congruent 1 (mod 7). So factoring a leap year results in a a 2 element jump in the sequence. So I've written this code to complete the problem:\n\n```\nconst unsigned s[7] = {2,2,2,1,2,1,2};\nunsigned n = 0;  \nunsigned y = 1901;\nunsigned c = 0;\ndo {\n    c=c%7;\n    n+=s[c];\n    ++y; \n    c += ((y%4!=0)||(y%400==0) ? 1 : 2); \n} while (y<2001);\nstd::cout << n << std::endl;\n```\n\n\nHowever I'm getting 172 where the answer is 171. Anyone see where I've gone wrong?\n\nNote: please don't leave 1200/7 comments.\n\nFIXED: replacing with ```\nc += ((y%400==0)||((y%4==0)&&(y%100!=0)) ? 2 : 1);```\n\n    ", "Answer": "\r\nedit: about the leap-year rule.\n\nThe leap year rule has just one more special case.\n\nA year is a leap year if it is:\n\n\nDivisible by four\n\nBut not divisible by 100\n\nExcept when it is also divisible by 400\n\n\n\n\nSometimes I wish we had metric calendars.  Megaseconds and kiloseconds, anybody?\n\n\n\nMaybe you got a bit confused about the leap-year rule?\n\nFrom your link:\n\n\n  A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.\n\n\nSo a year divisible by 400 is a leap year.  Your condition in your code is reversed.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Optimized arithmetic methods in R\r\n                \r\nThe openssl package implements a ```\nbignum```\n class with the corresponding methods for arithmetic and comparison to perform calculations on arbitrary sized integers.\n\nIn cryptography there is a common special case for the modular exponent ```\nx^p %% m```\n which is used by e.g. rsa. For large ```\np```\n, calculating ```\nx^p```\n is not feasible, but ```\nx^p %% m```\n can be calculated efficiently which OpenSSL implements in ```\nBN_mod_exp()```\n.\n\nDoes R provide any mechanism to implement the  ```\n^.bignum```\n and ```\n%%.bignum```\n methods such that when evaluating ```\nx^y %% z```\n we can call this special case rather than actually calculating ```\nx^p```\n?\n    ", "Answer": "\r\nLate to the party but yes, this is absolutely possible, and it’s a moderately common programming technique in some languages, such as C++, where the technique is known as expression templates.\n\nR, being weakly typed, cannot quite harness the pattern to the same extent. But a “light” version is still possible.\n\nIn a nutshell, you define your ```\n^.bignum```\n operator so that, instead or computing the result immediately, it returns a proxy object that signifies “exponentiation operation”. This proxy object has a specially overridden ```\n%%```\n method that invokes the ExpMod implementation (e.g. ```\nBM_mod_exp```\n). It also defines a method that coerces it to a ```\nbignum```\n by evaluating the actual ```\nx ^ y```\n operation.\n\nIn code this may look as follows:\n\n```\n# Vectorisation left as an exercise for the reader.\n\n`^.bignum` = function (x, y)\n    structure(c(x, y), class = 'bignum_mod_exp_proxy')\n\neval_exp = function (x)\n    call_actual_exp(x[1], x[2])\n\nas.bignum = function (x)\n    if (inherits(x, 'bignum_mod_exp_proxy'))\n        eval_exp(x)\n    else\n        # … implement other coercions to bignum, e.g. from `numeric`.\n\n`%%.bignum_mod_exp_proxy` = function (x, y)\n    call_BN_mod_exp(x[1], x[2], y)\n\n# Pretend that a `bignum_mod_exp_proxy` in all other contexts. E.g.:\n\nprint.bignum_mod_exp_proxy = function (x, ...)\n    print(eval_exp(x))\n\n# … etc., for the rest of the `bignum` operations.\n```\n\n\nIn fact, you could even override ```\n=.bignum_mod_exp_proxy```\n, ```\n<-.bignum_mod_exp_proxy```\n and ```\nassign.bignum_mod_exp_proxy```\n (converting ```\nassign```\n into an S3 generic), so that assignments ```\nz = x ^ y```\n are eagerly evaluated to a ```\nbignum```\n. However, this is probably overkill and would incur an overhead for each assignment.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to compute a/b mod P, P is a prime number?\r\n                \r\nI have been searching an answer for this question on various sites. I can understand all the basic rules of modular arithmetic until this bad guy comes in. Recently I have been suggested this page for simple understanding that question:http://theoryofprogramming.com/2014/12/24/modular-arithmetic-properties/\n\nI have understood how to compute a/b mod P and then I tried to code for the same (a*b^P-2 mod P).\nIt's suggested that b^P-2 mod P takes only O(log P) time if we use the Binary Exponentiation method.\n\n```\n    public static long BinaryExp(long base,long power) {\n    long prime = (long)Math.pow(10, 9) + 7;\n    if (power == 0) {\n        return 1;\n    }\n    else if (power == 1) {\n        return Math.floorMod(base, prime);\n    }\n    else {\n        long temp = BinaryExp(base, power/2);\n        temp = Math.floorMod(Math.floorMod(temp,prime)*Math.floorMod(temp,prime), prime);\n        if ((power%2)== 0) {\n            return Math.floorMod(temp, prime);\n        }\n        else return Math.floorMod(temp*Math.floorMod(base, prime),prime);\n    }   \n}\n```\n\n\nThis is my function for binary exponentiation. for input (30, 8) output is 99995408. If I change all longs to ints for the same input (30,8) output is 970003726. I can't figure why it's changing as there is no integer overflow (at least visibly). And the correct answer is 99995408 as per the windows calculator. Please help, I really want to move forward. Thanks in advance!\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Free monads for recursive arithmetic expressions in Scala cats\r\n                \r\nI am trying to define a simple arithmetic expressions evaluator using the Scala cats library and following the tutorial doc. \n\nThe goal is to define the DSL in a modular way combining integer values and additions which could be defined separately.\n\nI have the following code:\n\n```\npackage examples\nimport cats._\nimport cats.data._\nimport cats.free._\nimport cats.free.Free._\nimport scala.language.higherKinds\n\nobject FreeExpr {\n\n  sealed trait ValueF[A]\n  case class IntValue(n: Int) extends ValueF[Int]\n\n  class Value[F[_]](implicit I: Inject[ValueF, F]) {\n    def intVal(n:Int): Free[F,Int] = inject[ValueF,F](IntValue(n))\n  }\n\n  object Value {\n    implicit def value[F[_]](implicit I: Inject[ValueF,F]): Value[F] = new Value[F]\n  }\n\n  sealed trait ArithF[A]\n  case class Add[A](x: A, y: A) extends ArithF[A]\n\n  class Arith[F[_]](implicit I: Inject[ArithF, F]) {\n   def add[A](x: A, y: A) : Free[F,A] =\n     Free.inject[ArithF,F](Add(x,y))\n  }\n\n  object Arith {\n    implicit def arith[F[_]](implicit I: Inject[ArithF,F]): Arith[F] = new Arith[F]\n  }\n\n  type Expr[A] = Coproduct[ArithF, ValueF, A]\n  type Result[A] = Id[A]\n\n  object ArithId  extends (ArithF ~> Result) {\n    def apply[A](fa: ArithF[A]) = fa match {\n      case Add(x,y) => ??? // for { m <- x; n <- y } yield (m + n)\n    }\n  }\n\n  object ValueId extends (ValueF ~> Result) {\n    def apply[A](fa: ValueF[A]) = fa match {\n      case IntValue(n) => Monad[Id].pure(n)\n    }\n  }\n\n  val interpreter: Expr ~> Result = ArithId or ValueId\n\n  def expr1(implicit value : Value[Expr],\n                     arith : Arith[Expr]): Free[Expr, Int] = {\n    import value._, arith._\n    for {\n      n <- intVal(2)\n      m <- add(n, n)\n    } yield m\n   }\n\n  lazy val run1 = expr1.foldMap(interpreter)\n\n}\n```\n\n\nThe previous code compiles because I commented the definition of \"apply\" for the Add case. I initially thought the solution was the code that is commented, but the compiler returns:\n\n```\n[error] ...FreeExpr.scala:40: value flatMap is not a member of type parameter A\n[error]       case Add(x,y) => for { m <- x; n <- y } yield (m + n)\n[error]                                   ^\n```\n\n\nDo you know what do I need to change in the code to define the DSL and the interpreter in a modular way?\n    ", "Answer": "\r\nThe problem was that the result type of ```\nAdd```\n was too general and in the ```\ncase Add(x,y) => ...```\n the values ```\nx```\n and ```\ny```\n had type ```\nA```\n instead of ```\nM[A]```\n. \n\nI found two possible solutions.\n\nOne is to change the definition of ```\nAdd```\n to be ```\ncase class Add(x:Int,y:Int)```\n and the definition of the interpreter to be\n\n```\nobject ArithId  extends (ArithF ~> Result) {\n    def apply[A](fa: ArithF[A]) = fa match {\n      case Add(x,y) => x + y\n    }\n}\n```\n\n\nI have added this solution to this gist: FreeExprInt.scala\n\nOne problem of the previous solution is that the result type is fixed to be an ```\nInt```\n and it may be more interesting that it could be, at least a ```\nSemigroup```\n. \n\nI tried to define it using ```\ncase class Add[A: Semigroup](x: A, y: A)```\n but it seems that the compiler has some problems to treat second implicit parameters lists. \n\nA possible workaround is to add the evidence explicitly. I added this solution to another gist: FreeExprExplicit.scala\n\nAlthough both solutions work, I am not quite satisfied by them as I would prefer a more generic solution where the result type could be any ```\nA```\n.\n\nI was suggested to take a look to the tagless final style (Alternatives to GADTs) but I didn't implement it yet.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Get previous value on a list or array, loop around if first value is reached [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Wrapping around on a list when list index is out of range\r\n                            \r\n                                (3 answers)\r\n                            \r\n                    \r\n                Closed 6 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nConsider list(range(0, 5)), for example. I want the function to do this mapping:\n```\n(1, 4), (2, 1), (3, 2), (4, 3)\n```\n\nThat is, it should return the previous value on the list and, if it can't do that (if it reaches index 0), it will \"loop around\" and output the list's last value.\nI made this ugly solution:\n```\ndef come_back(x, highest, head = 1):\n    if x == head:\n        newx = highest\n    else:\n        newx = x - 1\n    return newx\n```\n\nBut it feels like there should be a more elegant one, probably based on Modular Arithmetic. Any clues?\n    ", "Answer": "\r\nHere's how I would consider doing it:\n```\ndef rotate_one(l: list) -> list:\n    return [l[-1], *l[:-1]]\n\nvalues = list(range(1, 5))\nresult = list(zip(values, rotate_one(values)))\nprint(values)  # [1, 2, 3, 4]\nprint(result)  # [(1, 4), (2, 1), (3, 2), (4, 3)]\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Unexpected behaviour of sapply() within vectorized function\r\n                \r\nI wanted to play around with modular arithmetic and programmed some innocently looking function... but got totally surprised by the following unexpected behaviour:\n```\ncrt <- function(x, mods = c(5, 7)) {\n  sapply(mods, \\(y) x %% y)\n}\ncrt <- Vectorize(crt)\n\ncrt(20)\n##      [,1]\n## [1,]    0\n## [2,]    6\n\ncrt(55)\n##      [,1]\n## [1,]    0\n## [2,]    6\n\ncrt(1:100)\n##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n## [1,]    1    2    3    4    0    1    2    3    4     0     1     2     3     4\n## [2,]    1    2    3    4    5    6    0    1    2     3     4     5     6     0\n##      [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]\n## [1,]     0     1     2     3     4     0     1     2     3     4     0     1\n## [2,]     1     2     3     4     5     6     0     1     2     3     4     5\n##      [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38]\n## [1,]     2     3     4     0     1     2     3     4     0     1     2     3\n## [2,]     6     0     1     2     3     4     5     6     0     1     2     3\n##      [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]\n## [1,]     4     0     1     2     3     4     0     1     2     3     4     0\n## [2,]     4     5     6     0     1     2     3     4     5     6     0     1\n##      [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62]\n## [1,]     1     2     3     4     0     1     2     3     4     0     1     2\n## [2,]     2     3     4     5     6     0     1     2     3     4     5     6\n##      [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74]\n## [1,]     3     4     0     1     2     3     4     0     1     2     3     4\n## [2,]     0     1     2     3     4     5     6     0     1     2     3     4\n##      [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86]\n## [1,]     0     1     2     3     4     0     1     2     3     4     0     1\n## [2,]     5     6     0     1     2     3     4     5     6     0     1     2\n##      [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98]\n## [1,]     2     3     4     0     1     2     3     4     0     1     2     3\n## [2,]     3     4     5     6     0     1     2     3     4     5     6     0\n##      [,99] [,100]\n## [1,]     4      0\n## [2,]     1      2\n\ncrt(x = 1:100, mods = c(12, 60))\n##   [1]  1  2  3  4  5  6  7  8  9 10 11 12  1 14  3 16  5 18  7 20  9 22 11 24  1\n##  [26] 26  3 28  5 30  7 32  9 34 11 36  1 38  3 40  5 42  7 44  9 46 11 48  1 50\n##  [51]  3 52  5 54  7 56  9 58 11  0  1  2  3  4  5  6  7  8  9 10 11 12  1 14  3\n##  [76] 16  5 18  7 20  9 22 11 24  1 26  3 28  5 30  7 32  9 34 11 36  1 38  3 40\n```\n\nWhy is the last function call ```\ncrt(x = 1:100, mods = c(12, 60))```\n giving a totally different output? The first vectorized output ```\ncrt(1:100)```\n is what I wanted and expected, the last one doesn't seem structurally different but the result is... why? And how do I fix this to get the same output as the first?\n    ", "Answer": "\r\nAccording to ```\n?Vectorize```\n\n\nThe arguments named in the vectorize.args argument to Vectorize are the arguments passed in the ... list to mapply. Only those that are actually passed will be vectorized; default values will not.\n\nHere, in the OP's function, there is default value for 'mods'.  If we remove it\n```\ncrt <- function(x, mods) {\n   sapply(mods, \\(y) x %% y)\n }\ncrt <- Vectorize(crt)\n```\n\n-testing\n```\n> crt(1:100, mods = c(5, 7))\n  [1] 1 2 3 4 0 6 2 1 4 3 1 5 3 0 0 2 2 4 4 6 1 1 3 3 0 5 2 0 4 2 1 4 3 6 0 1 2 3 4 5 1 0 3 2 0 4 2 6 4 1 1 3 3 5 0 0 2 2 4 4 1 6 3 1 0 3 2 5 4 0 1 2 3 4\n [75] 0 6 2 1 4 3 1 5 3 0 0 2 2 4 4 6 1 1 3 3 0 5 2 0 4 2\n> crt(1:100, mods = c(12, 60))\n  [1]  1  2  3  4  5  6  7  8  9 10 11 12  1 14  3 16  5 18  7 20  9 22 11 24  1 26  3 28  5 30  7 32  9 34 11 36  1 38  3 40  5 42  7 44  9 46 11 48  1\n [50] 50  3 52  5 54  7 56  9 58 11  0  1  2  3  4  5  6  7  8  9 10 11 12  1 14  3 16  5 18  7 20  9 22 11 24  1 26  3 28  5 30  7 32  9 34 11 36  1 38\n [99]  3 40\n```\n\nThe output format is determined at two levels here - 1) ```\nsapply```\n which by default uses ```\nsimplify = TRUE```\n and ```\nVectorize```\n which also by default have ```\nSIMPLIFY = TRUE```\n\nAlso, based on the function defined, ```\nVectorize```\n is not really needed as internally, it does the looping with ```\n*apply```\n functions and we already have the ```\ncrt```\n defined with ```\nsapply```\n which loop over the 'mods'.  The function applied ```\n%%```\n on those parameters is ```\n%%```\n which is already a vectorized function by default.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Guidance in Implementation for Cryptographic Schemes\r\n                \r\nI have a task of Implementing standard signature schemes which will involve Public Key Cryptography primitives like  :\nCyclic groups,\nExponentiation,\nRandom prime generation,\nmodular arithmetic,\nhash functions and so on.\n\nIt would be of great help if you can provide me with some good links which will guide me in implementing the schemes. \n\nC/C++/Java/Python preferred or any other language which is convenient!\n\nThanks!\n    ", "Answer": "\r\nFor modular arithmetics, you may want to have a look at the Handbook of Applied Cryptography, especially chapters 2 and 14 (chapter 14 is about implementation, but chapter 2 rehearses the underlying mathematics, and you will not go far if you do not master those). IEEE 1363-2000 is also a good source, because it describes many algorithms in full details (especially in Annex A)(unfortunately, this document is not freely available, a fact which generated a bit of a strife because many contributors did contribute under the assumption that the result would be free; google for \"P1363-Main-11-12-99.pdf\" and \"P1363-A-11-12-99.pdf\" to find some downloads of questionable legality for the last draft version). However it is much easier to simply use an existing big-integers library. In particular, Java comes with ```\njava.math.BigInteger```\n which is quite efficient.\n\nFor elliptic curves, the best reference I know is the Guide to Elliptic Curve Cryptography which is not free, but really worth its price.\n\nFor the algorithms themselves, follow the standards. RSA is described in full details in PKCS#1. For DSA (also known as DSS), see FIPS 186-3. Both standards are quite readable. For ECDSA, the standard is ANSI X9.62-2005, which can be purchased for a hundred bucks (as a PDF).\n\nStandard warning: implementing cryptographic primitives is hard. Not really getting the expected result, but doing so in a safe way. Any time you use a private key, you may leak some information on that private key, e.g. through timing (the time your code takes to compute the signature over a given input). Protected against side-channel attacks is a whole research subject and requires thorough understanding of cryptography and mathematics. So you really really should not implement your own primitives. Sony did, and failed. However, if you are implementing only signature verification (which involves only public elements, hence nothing to leak) then you are probably safe. Using existing implementations is still a much better idea. E.g. what standard Java already provides in ```\njava.security```\n and ```\njavax.crypto```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Rust implement modulo arithmetic for direction (up / left / down / right)\r\n                \r\nI'm teaching Rust, and so I go to adventofcode (parallel with boring reading rustbook).\nAnd in one task I need to track direction, during moving and rotations such as \"Straight / Left / Back / Right\" && \"Straight + Right + Right == Back\".\n*) suppose for a second, that \"absolute direction\" and \"relative direction\" are represented as single type.\nSo I trying to solve this issue using enums.\nAnd during this I need two things:\n\nContiguosly place discriminants from \"integer 0\" to last\nGet discriminants count (or \"enum size\") either straightforward or using some tricks.\n\nBut I can't do the second thing.\n```\nenum Dir {\n    Up,\n    Left,\n    Down,\n    Right,\n    //Last = (Dir::Right) as isize,\n} \nimpl Dir {\n    fn add_dir(&self, add_dir: &Self) -> Self {       \n        let last = Dir::from_int((self.to_int() + add_dir.to_int) / (Dir::Last.to_int() + 1));\n        return last;\n    }\n}\n```\n\nSo the questoin is: how can I implement domain-specific, i.e. type-safe, modulo arithmetic in rust (with no performance requirements if it's important).\n=======\nUpdated:\nThe local and narrow question is - how to get constant \"4\" (modulo for modular arithmetic), but don't type it as literal (the last thing, typing constants as literal - is a very errorfull way when programmer starts to change his code).\n    ", "Answer": "\r\n\nGet discriminants count (or \"enum size\") either straightforward or using some tricks.\n\n\nmy problem is - how to properly get constant 4 from enum. Butnot write it as literal in code (this is very errorfull way when programmer will change his code).\n\nYou can reliably get the number of enum variants using the ```\nstrum```\n crate's ```\nEnumCount```\n, which adds the ```\nDir::COUNT```\n static ```\nusize```\n value to your enum:\n```\n/*\n[dependencies]\nstrum = { version = \"0.24\", features = [\"derive\"] }\n*/\nuse strum::EnumCount;\n\n#[derive(EnumCount)]\nenum Dir {\n    Up,\n    Left,\n    Down,\n    Right,\n} \n\nfn main() {\n    assert_eq!(Dir::COUNT, 4);\n}\n```\n\nRustexplorer\n\n\nContiguously place discriminants from \"integer 0\" to last\n\nRust does so for variants implicitly. See @Sven Marnach's answer.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Numpy: prod, what overflow really is?\r\n                \r\nI'm reading in the following documentation of Python:\nhttps://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.prod.html\n\nNotes\nArithmetic is modular when using integer types, and no error is raised\non overflow. That means that, on a 32-bit platform:\n```\n>>> x = np.array([536870910, 536870910, 536870910, 536870910])\n>>> np.prod(x)  # random \n16\n```\n\n\nCan somebody explain what it means that arithmetic is modular when using integer types, and how this relates to if I have a 32- or 64-bit platform?\n    ", "Answer": "\r\nThe wiki page explains modular arithmetic but not the relevance to numpy.\n\nnumpy ints can be signed or unsigned with 8, 16, 32 or 64 bit.\n\n```\n         Range signed        Range unsigned\n 8 bit   -128 to 127         0 to 255        0 to 2**8-1\n16 bit   -32768 to 32767     0 to 65535      0 to 2**16-1\n32 bit   -2**31 to 2**31-1   0 to 2**32-1    Decimal 9 digits\n64 bit   -2**64 to 2**64-1   0 to 2**64-1    Decimal 18/19 digits\n```\n\n\nIt's easiest to visualise for np.int8.  Only 256 different possible values.\n\n```\nimport numpy as np\na=np.arange(256, dtype=np.int8)\nprint(a)\n\n[   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14\n   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29\n   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44\n   45   46   47   48   49   50   51   52   53   54   55   56   57   58   59\n   60   61   62   63   64   65   66   67   68   69   70   71   72   73   74\n   75   76   77   78   79   80   81   82   83   84   85   86   87   88   89\n   90   91   92   93   94   95   96   97   98   99  100  101  102  103  104\n  105  106  107  108  109  110  111  112  113  114  115  116  117  118  119\n  120  121  122  123  124  125  126  127 -128 -127 -126 -125 -124 -123 -122\n -121 -120 -119 -118 -117 -116 -115 -114 -113 -112 -111 -110 -109 -108 -107\n -106 -105 -104 -103 -102 -101 -100  -99  -98  -97  -96  -95  -94  -93  -92\n  -91  -90  -89  -88  -87  -86  -85  -84  -83  -82  -81  -80  -79  -78  -77\n  -76  -75  -74  -73  -72  -71  -70  -69  -68  -67  -66  -65  -64  -63  -62\n  -61  -60  -59  -58  -57  -56  -55  -54  -53  -52  -51  -50  -49  -48  -47\n  -46  -45  -44  -43  -42  -41  -40  -39  -38  -37  -36  -35  -34  -33  -32\n  -31  -30  -29  -28  -27  -26  -25  -24  -23  -22  -21  -20  -19  -18  -17\n  -16  -15  -14  -13  -12  -11  -10   -9   -8   -7  -6  -5  -4  -3  -2 -1]\n```\n\n\nThe numbers represented by 8 bits > 127 show as negative.\n\n```\nnp.binary_repr(127, 8)\nOut[11]: '01111111'\n\nnp.binary_repr(-128, 8)\nOut[12]: '10000000'\n```\n\n\nIf bit 7 is set this indicates a negative integer.\n\nUse np.int8 to play with some numbers.\n\n```\nnp.int8(17*18)   # Out[29]: 50\n17*18 % 256      # Out[30]: 50  (17*18=306) Mod 256 = 50\n\nnp.int8(17*180) # Out[31]: -12\n17*180 % 256    # Out[32]: 244  \nnp.binary_repr(244, 8)   # Out[33]: '11110100'\nnp.binary_repr(-12, 8)   # Out[34]: '11110100'\n```\n\n\nThe documentation is saying that if integer arithmetic overflows it simply wraps around the number range, it doesn't raise an exception.  Replace 'wraps around' with modular.\n\nIf overflow does occur it simply produces surprising (and probably incorrect) results.  \n\nThis gives a quick outline.  Use ```\nnp.int8(expr)```\n and ```\nnp.binary_repr( n, 8)```\n to play around and see what is happening.\n\nEdit to explain bit 7\n\n```\nBit numbers  7 6 5 4 3 2 1 0\n     127     0 1 1 1 1 1 1 1  Bit 7 not set 0 +127\n    -128     1 0 0 0 0 0 0 0  Bit 7 set     1 -128\n      -1     1 1 1 1 1 1 1 1  \n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to calculate `x^3 + ax + b mod p` with Golang big.Int\r\n                \r\nI'm trying to find the Y coordinate for an elliptic point. I understand the formula is ```\ny^2≡x^3+ax+b mod p```\n.\n\nHowever I'm unsure of how I would actually program this in Go.\n\n```\nxCubed.Exp(X, 3, nil)\nAX.Mul(A,X)\n\nN.Add(XPow3, AX) // x^3 + ax\nN.Mod(N, P) // mod p\nN.Add(N, B) // (x^3 + ax) + b\nN.Mod(N, P) // mod p\n\nreturn N\n```\n\n\nWhere xCubed,X,N,P,B are ```\n*big.Int```\n and N represents y^2 \n\nI'm a noob to modular arithmetic, so my assumption mod P is applied to each operation; Is this the correct way to to calculate ```\nx^3 + ax + b mod p```\n?\n\nedit: should I have added AX.Mod(p) ? \n    ", "Answer": "\r\nI figured it out, by scouting some code in the elliptic lib\n\n```\nfunc GetY(x *big.Int, curve *elliptic.CurveParams) *big.Int {\n\n\n    x3 := new(big.Int).Mul(x, x)\n    x3.Mul(x3, x)\n\n    threeX := new(big.Int).Lsh(x, 1)\n    threeX.Add(threeX, x)\n\n    x3.Sub(x3, threeX)\n    x3.Add(x3, curve.B)\n    x3.Mod(x3, curve.P)\n\n    return x3.ModSqrt(x3, curve.P)\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Factorial remainder\r\n                \r\nGiven a number n,the problem is to find all x (1<=x<=n), such that (x-1)! ie (factorial of (x-1)) leaves a remainder of x-1 when divided by x.I have tried of a dynamic programming solution  where dp[n] gives the number of such numbers for given n,but finding the factorial doesn't seem to work for large numbers.Can we use modular arithmetic properties to solve this?\n    ", "Answer": "\r\nWhen (x-1)! is divided by (x-1) for x > 1, the remainder will always be 0. Since it's given that the remainder is x, you need to find all x such that x is congruent to 0 modulo x-1. (Notice that x itself is congruent to 1 mod x - 1).\n\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "how ed=1 in RSA cryptosystem?\r\n                \r\nI fully understand the how the RSA algorithm works, but now I am trying to reason with the formula. I want to know:\n\nwhy the public key e and the private key d in the RSA encryption have to satisfy the equation ed = 1 mod (p − 1)(q − 1)?\n\nIs it because of the standard modular arithmetic rule where 1 mod anything is 1, or is there a more to this answer?\n    ", "Answer": "\r\nSay you have a message called x and you want to encrypt it with your public key (pq, e). If you encrypt x, you get x^e mod pq. Someone who knows d can get x^(ed) mod pq.\nBecause ed = 1 mod (p - 1)(q - 1), by Fermat's little theorem, we get that x^(ed) mod pq = x, thus decrypting the message. If ed != 1 mod (p - 1)(q - 1), then the message could not be decrypted.\n\nA link to Fermat's little theorem:\nhttps://en.wikipedia.org/wiki/Fermat%27s_little_theorem\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Division with modulus remainders\r\n                \r\nHow can you do division with modulus remainders?\n\nFor example: Find the remainder when 9^2012 is divided by 11.\n\nUsing modular arithmetic, 9 == 1(mod 4), so 9^2012 == 1^2012(mod 4). Therefore, 9^2012 == 1(mod 4). Also, 11 == 3(mod 4). To answer the question, I'm trying to do 1(mod 4)/3(mod 4). Is there any way to do this?\n    ", "Answer": "\r\nThere two important theories that would help you to solve this problem :-\n\n\nModular Exponentiation\nFermat's little theorem\n\n\nModular Exponentiation :- This simple recursive formula to make you understand :-\n\n```\n(a^n)%p = ((a^(n-1))%p*a)%p\n```\n\n\nThe above formula can help you prevent the overflow which occurs if a^n is large.\nMoreover fast exponention can be done using O(logn)\n\nFermat's little theorem :- If p is prime in your case 11 is prime then ```\n(a^(p-1))%p = 1```\n for any a that is co-prime to p hence ```\n(a^n)%p = (a^(n%(p-1)))%p```\n\n\nyour example :-\n\n```\n9^2012 % 11 = ?\n\n11 is prime and 9 is co-prime to 11 then using fermat's theorem\n\n9^2012 % 11 = (9^(2012%10)) % 11\n2012%10 = 2\n\n9^2012 % 11 = 9^2 % 11 = 4  \n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to end a while loop in python 3\r\n                \r\nSo I am using modular arithmetic to work out what day it will be in \"x\" amount of days. I have tried to use the ```\nbreak```\n command to end the ```\nwhile```\n loop but when I do it prints what the answer will be for all of the loops. This is my code for one of the loops\n\n```\nwhile (x) == ('Monday') or ('monday'):\n    if round_4 == \".1\":\n        print (\"It will be Tuesday\")\n    elif round_4 == \".2\":\n        print (\"It will be Wednesday\")\n    elif round_4 == \".3\":\n        print (\"It will be Thursday\")\n    elif round_4 == \".4\":\n        print (\"It will be Friday\")\n    elif round_4 == \".5\":\n        print (\"It will be Saturday\")\n    elif round_4 == \".6\":\n        print (\"It will be Sunday\")\n    elif round_4 == \".7\":\n        print (\"It will be Monday\")\n    elif round_4 == \".8\":\n        print (\"It will be Tuesday\")\n    elif round_4 == \".9\":\n        print (\"It will be Wednesday\")\n    elif round_4 == \".0\":\n        print (\"It will be Monday AGAIN\")\n    else:\n        print (\"Sorry, there has been a tecnical difficulty! Please try again!\")\n```\n\n\nIf ```\nround_4```\n was say \".2\" it would print the \".2\" elif for all the while loops.\nSorry, I'm a bit of a n00b to python!\n    ", "Answer": "\r\n\n  So I am using modular arithmetic to work out what day it will be in \"x\" amount of days.\n\n\nNo you're not.  Python has built-in support for modular arithmetic in the modulus operator, ```\n%```\n:\n\n```\n>>> 29 % 7\n1\n```\n\n\nYou do not need looping or recursion to solve this problem.\n\nAssuming you have an integer variable ```\ntoday```\n (with zero standing for Monday, one for Tuesday, etc.), this is very simple math:\n\n```\nreturn (today+x) % 7\n```\n\n\nYou can then use dictionaries to convert between day names and numbers.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Generate time sequence with step 7 seconds\r\n                \r\nHow would you generate the following sequence of strings in Python?\n\n```\n00:00:00\n00:00:07\n00:00:14\n00:00:21\n...\n00:00:49\n00:00:56\n00:01:03\n```\n\n\nThe step is 7 seconds. The end is about 03:30:+/-\n\nI would come with solution that uses modular arithmetic (first 1200 to have hours, than 60 to have minutes and the remainder are seconds and the numbers should be converted to strings and \"one-place\" strings should be prefixed by \"0\").\n\nIs there some smarter (pythonic) solution with using some helper generators in standard library or list comprehension?\n    ", "Answer": "\r\n```\ndef yield_times():\n    from datetime import date, time, datetime, timedelta\n    start = datetime.combine(date.today(), time(0, 0))\n    yield start.strftime(\"%H:%M:%S\")\n    while True:\n        start += timedelta(seconds=7)\n        yield start.strftime(\"%H:%M:%S\")\n\n>>> gen = yield_times()\n>>> for ii in range(5):\n...     print gen.next()\n... \n00:00:00\n00:00:07\n00:00:14\n00:00:21\n00:00:28\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Speeding up integer division with constant divisor\r\n                \r\nI remember reading somewhere a while back that if you are dividing by a constant there is a way to turn it into a multiplication due to the properties of modular arithmetic.  I have been working on the following function and it involves performing many divisions with the same divisor.  I was wondering if I could speed it up using what I described above.  If so how exactly?\n\n```\nint ubi_div_i64(ubigint_t* a, ubi_i64_t b, ubi_i64_t* rem)\n{\n    if(b == 0)\n        return UBI_MATH_ERR;\n\n    ubi_i64_t r = 0;\n\n    for(size_t i = a->used; i-- > 0;)\n    {\n\n        ubi_i64_t out;\n        __asm__(\"\\t\"\n                \"div %[d] \\n\\t\"\n                : \"=a\"(out), \"=d\"(r)\n                : \"a\"(a->data[i]), \"d\"(r), [d]\"r\"(b)\n                : \"cc\");\n        a->data[i] = out;\n    }\n    if(rem)\n        *rem = r;\n\n    return ubi_strip_leading_zeros(a);\n}\n```\n\n\nNote:  The divisor is 64 bit and the dividend is 128 bit.\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Maximise value of (X^Y)%M\r\n                \r\nI know to calculate (X^Y)%M .Now my question is suppose we need to maximise (X^i)%M where i can vary between 0 to Y and M=10^9 + 7.What can i say about i.I mean when it will be maximum?\n\nInput will consist of X and Y which can go upto 10^100 which i can handle by using BigIntegers of JAVA or using modular arithmetic in c++.\n    ", "Answer": "\r\nThe first thing you should do, is to transfer\n\n```\nX=X%M\nY=Y%M\n```\n\n\nNotice, 109+7 is much less than 10100. So, you won't need numbers larger than ```\nlong```\n. Long you will need, for the in-between results.\n\nYou should count the Xi sequentally:\n\n```\npower[0]=X;\nlong i;\nfor(i=1; i<Y; i++){\n    power[i]=(power[i-1]*X)%M;\n    if (power[i] is in power[0..i-1]) {\n       i--;\n       break;\n    }  \n}\nfind max power[0..i];\n```\n\n\nBecause they will be repeating often.  \n\nBut I don't know if 109+7 is prime or not. If it is, there will be no repeating until all numbers under 109+7 will be reached. The only change will be that every X under 109+7 will set its own unique recombination of numbers 1..109+7.\n\nIn this case the max for every Y above 109+7 will be 109+7-1. As for smaller Y's you have to check sequentally, only without the check for the repetition. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Second digit from the right from a huge number\r\n                \r\nNow I actually read about modular arithmetic and managed to get the last digit of some number. Okay. But now... How do I get second last digit? Second one on the right. I actually been working on it on several hours straight trying to find a simple solution, this is the best I could come up so far but it's still not it. Could somebody help me please?\n\nThis is what I have so far\n\n```\nlong long powmod(long long n, long long exp)\n{\n    long long r, result = 1;\n\n    while(exp)\n    {\n        r = exp % 2;\n        exp /= 2;\n        if(r == 1) result = result * n % 10;\n        n = (n * n) % 10;\n    }\n    return result;\n}\n```\n\n\nThanks in advance\n    ", "Answer": "\r\nDivide it by ten, round down, and then get the last digit of what remains. :-)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why is unsigned left bit shift overflow different between runtime and compile time? [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        Why doesn't left bit-shift, \"<<\", for 32-bit integers work as expected when used more than 32 times?\r\n                            \r\n                                (10 answers)\r\n                            \r\n                    \r\n                    \r\n                        Unexpected C/C++ bitwise shift operators outcome\r\n                            \r\n                                (6 answers)\r\n                            \r\n                    \r\n                    \r\n                        Why the output of `printf(\"%llu\\n\", 1ull << n);` and `printf(\"%llu\\n\", 1ull << 64);` is different in C++? (n=64) [duplicate]\r\n                            \r\n                                (3 answers)\r\n                            \r\n                    \r\n                    \r\n                        Is right-shifting an unsigned integer by its total number of bits UB ? [duplicate]\r\n                            \r\n                                (1 answer)\r\n                            \r\n                    \r\n                Closed 6 months ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI have the following code in C++\n```\n#include <iostream>\nusing namespace std;\nint main(){\n    unsigned long long a;\n    cin>>a;\n    cout<< (1ull<<64ull) << ' ' << (1ull<<a) << endl;\n}\n```\n\nnow inputting ```\n64```\n, the output is\n```\n0 1\n```\n\nIn short, the compiler seems to use a circular shift at runtime. But from my reading of the relevant cppreference page, I think it's supposed to be normal modular arithmetic, so the bit should just disappear as in the compile-time version. I tested this on GCC 11, GCC 12 and clang 14 so it's extra unlikely to be a compiler bug. So what am I missing here?\n    ", "Answer": "\r\nfrom the quoted cppreference page\n\nIn any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.\n\nsince 64 is the number of bits in ```\nunsigned long long```\n on my machine, this is undefined behavior\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Operator overloading and class definition in R: Use a different base field/corpus\r\n                \r\n(I'm using the word \"field\" in the mathematical sense; base fields/corpora which ```\nR```\n already uses include the real and complex numbers.)\n\nI'm interested in allowing some other base fields/corpora (like F₅, which is modular arithmetic in base 5). To do that I would need to\n\n\ndefine a new data type\noverload the relevant operators (```\n+```\n, ```\n*```\n, and maybe more)\nmaybe something else? e.g., integrate with other functionality?\n\n\nSo, how does one define a new data type or overload operators in ```\nR```\n?\n    ", "Answer": "\r\nI found Hadley Wickham's devtools wiki an invaluable resource for getting started with classes in R. In particular, read the sections on:\n\n\nS3 classes\nS4 classes\n\n\nHere is a starting point that illustrates some of the concepts in ```\nS3```\n classes.  Let's call your new class ```\nf5```\n.  At a minimum, you would probably want to create methods for:\n\n\nCoercion: ```\nas.f5```\n\nTest: ```\nis.f5```\n\nSome basic operators: ```\n+.f5```\n\nA class to handle printing: ```\nprint.f5```\n\n\n\nSome code (using ```\ndigitsBase```\n in package ```\nGLDEX```\n to do the base conversion):\n\n```\nlibrary(GLDEX)\n\nas.f5 <- function(x){\n  if(!inherits(x, \"f5\")) class(x) <- c(\"f5\", class(x))\n  x\n}\n\nis.f5 <- function(x){\n  inherits(x, \"f5\")\n}\n\n`+.f5` <- function(e1, e2){\n  NextMethod(e1, e2)\n}\n\nprint.f5 <- function(x, ...){\n  # Next line from ?GLDEX::digitsBase\n  b2ch <- function(db) noquote(gsub(\"^0+(.{1,})$\",\" \\1\", \n                           apply(db, 2, paste, collapse = \"\")))\n\n  cat(\"Base 5:\\n\")\n  cat(b2ch(digitsBase(x, 5)))\n  invisible(x)\n}\n\n\nx <- as.f5(0:10)\ny <- as.f5(5)\n\nx + y\n\nBase 5:\n10 11 12 13 14 20 21 22 23 24 30\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Can't get it how the function works\r\n                \r\nSo basically i just started learning JS and had a little exercise which was basically making a function to check if the number is even without using modular arithmetic. When i was done with it i just wanted to compare mine with the answer and i couldn't really get how does it work. \n\n```\nfunction isEven(n) {\n  if (n == 0)\n    return true;\n  else if (n == 1)\n    return false;\n  else if (n < 0)\n    return isEven(-n);\n  else\n    return isEven(n - 2);\n}\n```\n\n\nI'm not sure how the part (n-2) works does it somehow puts the number in a loop and basically does n-=2 until the number gets 1 or 0?\n    ", "Answer": "\r\nLet's take a look at what is going on behind the scenes when this function is run:\n\n```\nisEven(8)\n// isEven(8) Is 8 even?\n//   isEven(6)  Is 6 even?\n//     isEven(4)  Is 4 even?\n//       isEven(2) Is 2 even?\n//         isEven(0) Is 0 even? --> Yes, the function immediately returns true\n// so I know the one at the top, 8, is even\n```\n\n\nAnd so on. For any even number, it eventually gets to 0. For any odd number it eventually gets to 1.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "taking mod from every iteration in factorial computing in c++ to not get a number overflow\r\n                \r\nSo, I'm now learning competitive programming, and the topic was \"modular arithmetic\". It's said that you can use (a*b) % c = ((a % c) * (b % c)) % c\nand the book tells I can compute a factorial using it without number overflows. But in the example it's said that you can take mod of every operation like this:\n```\nlong long x = 1;\nfor (int i = 2; i <= n; i++) {\n    x = (x*i) % m; // a mod number of some kind\n}\ncout << x % m << '\\n';\n```\n\nso, the question is: isn't it better to use it like ((x % c) * (i % c)) % c ? So we won't risk to get an \"i\" number overflow?\n    ", "Answer": "\r\n\nisn't it better to use it like ```\n((x % c) * (i % c)) % c```\n ?\n\nIn the example, does ```\nm```\n's value fit in 32-bit integer?\nIf it is true, the value of ```\nx```\n and ```\ni```\n are also 32-bit, which means there is no overflow in just one multiplication as ```\nx```\n can contain a 64-bit integer. So it is safe.\nIf it is not, even if we replace the calculation with ```\n((x % m * (i % m)) % m```\n, it still could overflow as ```\nx % m```\n could be bigger than 32-bit integer. So I don't think it is the case.\nSo both way works. And your way wouldn't change time complexity of your algorithm. However it has no advantage, just more calculation and more to type :)\n\nAnd I would like to mention one more:\n\nthe book tells I can compute a factorial using it without number overflows.\n\nNo we can compute a factorial modulo ```\nm```\n with that way.\nIn competitive programming, most of the problems avoid the issue that the answer gets too big with this way. So we can always compute an arithmetic operation at a constant time(no big integers).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "dec2base with independent bits/digits calculation\r\n                \r\nNeed ```\nMATLAB```\n/```\nOctave```\n ```\ndec2base```\n functionality function with independent bits/digits calculation algorithm (within integer logic, with no divisions, using modular arithmetic).\nWould be nice to have as well:\n\nanonymous function\n\n\nNB!\nfloating logic and division could be used only one time for scalar to define the maximal amount of digits in converted numbers array:\n```\nceil( log2(max(dec(:)))/log2(base)) )\n```\n\nThe best answers:\n\nAnonymous function solution\nRegular Function solution\n\nP.S.\n\nSolution for simplified ```\ndec2bin```\n case listed here.\nSolution for ```\nbitget```\n provided in this post: Matlab/Octave bitget function for any base\n\n    ", "Answer": "\r\n\nIn ```\nMATLAB```\n / ```\nOCTAVE```\n:\n```\n% For Matlab/Octave: \nde2bs = @(dec,base) base.^([(1+floor( log2(max(dec(:)))/log2(base)) ):-1:1]-1); % an array of powers of a base\nde2bs = @(dec,base) sum(rem(dec(:)                                ...\n                           ,base.*de2bs(dec,base)                 ...\n                           )                                      ...\n                        >=permute((1:base-1)'*(de2bs(dec,base))   ...\n                                 ,[3,2,1]                         ...\n                                 )                                ...\n                        ,3                                        ...\n                        );          \n```\n\nExample:\n```\nx=0:9; base=3; de2bs(x,base)\n\nans =\n\n0   0   0\n0   0   1\n0   0   2\n0   1   0\n0   1   1\n0   1   2           \n0   2   0\n0   2   1\n0   2   2\n1   0   0\n```\n\n\nIn ```\nOCTAVE```\n only: as far as Octave supports default values for anonymous\nfunctions, there is a more interesting overloaded function\nimplementation:\n```\n% OCTAVE only (Matlab do not support default values for parameters)\n\n% Anonymous function de2bs\n% dig = digget(dec, base, isoutputasstring, pos)                \n%   dig  - returns the value of the digits in positions (pos) for numbers (dec)\n%          coverted to the defined base (for base=2 behaves similar to bitget) \n%   dec  - mandatory, initial decimal numbers vector\n%   base - optional (by default base = 2),\n%          base to convert (for binary base = 2 )\n%   isoutputasstring - optional (by default isoutputasstring = true), \n%          example: de2bs(26,16,0) -> '1A'\n%          example: de2bs(26,16,1) -> [1 10]%   \n%   pos  - optional (by default pos = (ceil( log2(max(dec(:)))/log2(base)) ):-1:1 ) \n%          array of positions (like in bitget function)\n\nde2bs = @(dec\n        ,base = [2]                                                  ... % Base of numbers you want to get\n        ,isoutputinstringformat = [true]                             ... % output format 0/1 - integer/string \n        ,pos  = [(ceil( log2(max(dec(:)))/log2(base)) ):-1:1]        ... % Bits/digits positions to return (similar to bitget function)\n    ... % temporary variables listed below (NOT parameters)          ...\n        ,pbs  = [base.^(pos-1)]                                      ... % pbs - powers of base\n        ,num  = [sum(rem(dec(:)                                      ... % conversion to defined base\n                        ,base.*pbs                                   ...\n                        )                                            ...\n                    >= permute((1:base-1)'*pbs                       ...\n                              ,[3,2,1]                               ...\n                              )                                      ...\n                    ,3                                               ...\n                    )                                                ...\n                ]                                                    ...\n        )                                                            ...\n        ifelse(isoutputinstringformat                                ... % Convert digits to chars if necessary\n              ,char(ifelse(num>9,num+55, num+48))                    ... % like 9->'9', 10->'A', 11->'B';\n              ,num                                                   ... \n              );\n```\n\nExamples:\n```\nx=25:28;\nbase=16;\n\n\nde2bs(x)        % behaves as dec2bin(x)\n\nans =\n\n11001\n11010\n11011\n11100        \n\n\nde2bs(x,base)   % behaves as dec2base(x,base)\n\nans =\n\n19\n1A\n1B\n1C\n\n\nde2bs(x,base,0) % behaves as dec2base(x,base) without converting/mapping to string/char format\n\nans =\n\n1    9\n1   10\n1   11\n1   12\n\n\nde2bs(x,base,1,[3 2 1])   % behaves as dec2base(x,base), but returns mentioned digits in number (like in bitget function)\n\nans =\n\n019\n01A\n01B\n01C\n```\n\n\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Math behind sorting grade percentages for grade forecast\r\n                \r\nTitle looks weird but I'll try to elaborate as much as I can.\n\nI want to write a program which is able to provide me the percentages I need to get all possible grades in the class (A,B,C; A = max 10 points lost, B = max 20 points lost, C = max 30 points lost).\n\nSo right now my problem is how should I distribute the amounts of points I can lose, given say I can get a B grade but only can have 12% distributed between 4 homework(each of 1%) and final of 40%.\n\nIs it better to use something of modular arithmetic? (let n=12, then n% 12 to 6 gives all possible combination of scores). This may also be easy when I have more than 2 criteria (homework, midterm, final, project etc)\n\nor\n\njust do some loop/iteration through the total percentage that can be lost?\n\n```\neg 12 - 1\n   12 - 2\n   ....\n   12 - 11\n   12 - 12\n```\n\n\nPlease provide me with some ideas to implement the modular arithmetic version but my understanding of it is not superb.\n\nOn the other hand, if there's a better algorithm or way to do so, feel free to tell me!\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Generating pseudorandom numbers drawn from a uniform distribution\r\n                \r\nI'm looking to build a function in Clojure that outputs m x n matrix of pseudorandom numbers drawn from the open interval (0,1). The specified inputs would be the row dimension m and column dimension n. I have familiarity with constructed matrices, nested vectors, in Clojure but have never generated random (psuedo) numbers before. My first guess, if starting from scratch, would use modular arithmetic to pump out inputs for the m x n matrix. Is this the easiest way to implement this idea? \n    ", "Answer": "\r\nThe built-in ```\n(rand)```\n generates a number from the uniform between 0 and 1. So with:\n\n```\n(for [row (range m)]\n  (for [column (range n)]\n    (rand)))\n```\n\n\nthere is no need to implement your own generator.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Using modualr arithmetic for vector indices in matlab\r\n                \r\nI have a vector n values and i want to split it into groups n groups of 3 adjacent values if it is considered to have a ring topology.\n\nwhat i am trying to do is this:\n\n```\nvector = [some values];\ngroups = {};\n\nfor i = 1:size(vector)(2)\n    groups{i} = [vector(mod(i-1, size(vector)(2));\n                 vector(i);\n                 vector(mod(i+1, size(vector)(2))];\nendfor\n```\n\n\nso if n = 10 and i = 1, groups should be [vector(10); vector(1); vector(2)]\n\nit would be pretty straightforward in most programming languages to just use the mod operator, but i am having trouble working out how to do this using matlab as it doesnt use 0 as the initial index of a vector, so if i = 1, then mod(i-1) = 0 which is an illegal index value. Also i = n would be a problem as mod(n, n) = 0.\n\ni have worked out a pretty hack-ish solution in:\n\n```\nvector = [some values];\ngroups = {};\n\nfor i = 1:size(vector)(2)\n    if i == 1\n        groups{i} = [vector(size(vector)(2));\n                     vector(1);\n                     vector(2)];\n    elseif i == size(vector)(2)\n        groups{i} = [vector(size(vector)(2)-1);\n                     vector(size(vector)(2);\n                     vector(1)];\n    else\n        groups{i} = [vector(i-1);\n                     vector(i);\n                     vector(i+1)];\n    endif\nendfor\n```\n\n\nbut it is pretty inelegant and i feel like there should be a better way to do it..\n\nis there some operator that allows you to perform modular arithmetic over vector indexes?\n    ", "Answer": "\r\nIndeed, the 1-based indexing method of matlab can be quite irritating sometimes...\nYou can simply add 1 to your 0-based indices, though\n\n```\nn = numel(vector);\nfor ii = 1:n\n    idx0 = mod( ii + [-2, 1, 0], n ); % 0-based indices\n    group{ii} = vector( idx0 + 1 );\nend\n```\n\n\nNow, good Matlab practices are about vectorization, here's one way to vectorize this for-loop\n\n```\nidx0 = mod( bsxfun( @plus, 1:n, [-2;1;0] ), n ); % all indices at once\ngroup = mat2cell( vector( idx0+1 ).', ones(n,1), 3 );\n```\n\n\nYou can lookup ```\nmat2cell```\n in mathworks web site for more information. You can also read about bsxfun here at SO for more examples and information.\n\n\n\nPS,\nIt is best not to use ```\ni```\n as a variable name in Matlab.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Creating Maxima code to find the RREF of a matrix over a field\r\n                \r\nI know that Maxima allows you to bring a matrix to a row echelon form through the function echelon, and that simple code can be written to put this in RREF over the real numbers.  Is there a way to adapt this, or a concise way to calculate the RREF over a field modulo some prime (say 7)?\nOne way I saw to do this was to adapt the MATLAB code given here: https://uk.mathworks.com/matlabcentral/answers/441021-row-reduction-using-modular-arithmetic, however it proves to be rather long when converting over to Maxima.\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Reducing nested for loop to single loop in R\r\n                \r\nThis nested for loop can take quite some time to run depending on inputs to specs, perms and K. 'pop' is just an array to store all values. Perms is a large value, say 10,000.\n\n```\nK <- 1 \n\nN <- 100 \n\nHstar <- 10 \n\nperms <- 10000 \n\nspecs <- 1:N \n\npop <- array(dim = c(c(perms, N), K))\n\nhaps <- as.character(1:Hstar)\n\nprobs <- rep(1/Hstar, Hstar) \n\nfor(j in 1:perms){\n    for(i in 1:K){ \n        if(i == 1){\n            pop[j, specs, i] <- sample(haps, size = N, replace = TRUE, prob = probs)\n    }\n        else{\n            pop[j ,, 1] <- sample(haps[s1], size = N, replace = TRUE, prob = probs[s1])\n            pop[j ,, 2] <- sample(haps[s2], size = N, replace = TRUE, prob = probs[s2])\n\n        }\n    }\n}\n\nHAC.mat <- array(dim = c(c(perms, N), K))\n\nfor(k in specs){\n    for(j in 1:perms){\n        for(i in 1:K){ \n            ind.index <- sample(specs, size = k, replace = FALSE) \n            hap.plot <- pop[sample(1:nrow(pop), size = 1, replace = TRUE), ind.index, sample(1:K, size = 1, replace = TRUE)] \n            HAC.mat[j, k, i] <- length(unique(hap.plot))  \n       }\n   }\n}\n\n\nmeans <- apply(HAC.mat, MARGIN = 2, mean)\nlower <- apply(HAC.mat, MARGIN = 2, function(x) quantile(x, 0.025))\nupper <- apply(HAC.mat, MARGIN = 2, function(x) quantile(x, 0.975))\n\npar(mfrow = c(1, 2))\n\nplot(specs, means, type = \"n\", xlab = \"Specimens sampled\", ylab = \"Unique haplotypes\", ylim = c(1, Hstar))\npolygon(x = c(specs, rev(specs)), y = c(lower, rev(upper)), col = \"gray\")\nlines(specs, means, lwd = 2)\nHAC.bar <- barplot(N*probs, xlab = \"Unique haplotypes\", ylab = \"Specimens sampled\", names.arg = 1:Hstar)\n```\n\n\nTo make the loop run faster, I am thinking to condense the above loop into a single loop and having a single index (i) run from 1:(specs*perms) and using modular arithmetic with floor and ceiling functions to get the job done. I am not quite certain how best to implement this. \n    ", "Answer": "\r\nLet's use RcppArmadillo.\nBut first, I need to change 2 things to your code:\n\n\nIt is easier (and faster) to work with ```\npop```\n as an array of integers rather than characters. It is easy to make a correspondence table using ```\nunique```\n and ```\nmatch```\n.\nI need to permute the first two dimensions of ```\npop```\n so that the accesses are more contiguous.\n\n\nNew code to generate ```\npop```\n:\n\n```\nK <- 1 \nN <- 100 \nHstar <- 10 \nperms <- 10000\nspecs <- 1:N \npop <- array(dim = c(N, perms, K))\nhaps <- 1:Hstar\nprobs <- rep(1/Hstar, Hstar) \n\nfor(j in 1:perms){\n  for(i in 1:K){ \n    if(i == 1){\n      pop[, j, i] <- sample(haps, size = N, replace = TRUE, prob = probs)\n    }\n    else{\n      pop[, j, 1] <- sample(haps[s1], size = N, replace = TRUE, prob = probs[s1])\n      pop[, j, 2] <- sample(haps[s2], size = N, replace = TRUE, prob = probs[s2])\n    }\n  }\n}\n```\n\n\nRcppArmadillo code to generate ```\nHAC.mat```\n:\n\n```\n// [[Rcpp::depends(RcppArmadillo)]]\n#define ARMA_DONT_PRINT_OPENMP_WARNING\n#include <RcppArmadillo.h>\n#include <RcppArmadilloExtensions/sample.h>\n#include <set>\nusing namespace Rcpp;\n\n\nint sample_one(int n) {\n  return n * unif_rand();\n} \n\nint sample_n_distinct(const IntegerVector& x, \n                      int k,\n                      const int * pop_ptr) {\n\n  IntegerVector ind_index = RcppArmadillo::sample(x, k, false); \n  std::set<int> distinct_container;\n\n  for (int i = 0; i < k; i++) {\n    distinct_container.insert(pop_ptr[ind_index[i]]);\n  }\n\n  return distinct_container.size();\n}\n\n// [[Rcpp::export]]\narma::Cube<int> fillCube(const arma::Cube<int>& pop,\n                         const IntegerVector& specs,\n                         int perms,\n                         int K) {\n\n  int N = specs.size();\n  arma::Cube<int> res(perms, N, K);\n\n  IntegerVector specs_C = specs - 1;\n  const int * pop_ptr;\n  int i, j, k;\n\n  for (i = 0; i < K; i++) {\n    for (k = 0; k < N; k++) {\n      for (j = 0; j < perms; j++) {\n        pop_ptr = &(pop(0, sample_one(perms), sample_one(K)));\n        res(j, k, i) = sample_n_distinct(specs_C, k + 1, pop_ptr);\n      }\n    }\n  }\n\n  return res;\n}\n```\n\n\nIn R:\n\n```\nRcpp::sourceCpp('cube-sample.cpp')\nHAC.mat <- fillCube(pop, specs, perms, K)\n```\n\n\nThis is 10 times as fast as your version on my computer.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Where is the pow-mod function defined in Elisp\r\n                \r\nI would like to use the pow-mod function to help call perform modular arithmetic on 'bigpos' numbers. \n\nI found it on this elisp documentation website \n\nHowever when I call pow-mod, I cannot even get it to be recognized:\n\n```\n(require 'calc)\n(require 'calc-ext)\n(pow-mod message-encoded e n)\n```\n\n\nBut it's not recognized! I'm confused because it's listed under computational lisp functions. So I assume that it was a part of the 'calc' functions. What is wrong? Is there some library I am missing? I tried `(require 'pow) but to no luck. \n\nWhere is pow-mod defined? Thank you!\n    ", "Answer": "\r\nTry something like\n\n```\n(math-pow-mod 19 103 89)\n```\n\n\n(In the documentation you linked, go up one level to 17.5.7 and check the first paragraph: \"These functions are shown by their names as they conventionally appear in defmath. Their full Lisp names are generally gotten by prepending ‘calcFunc-’ or ‘math-’ to their apparent names.\")\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Finding the nth fib number, in O(logn)\r\n                \r\nI am trying to solve this: SPOJ problem.\n\nAnd after some research I found out that it comes down to a simple calculation of the nth fib number, however n can get really large so an O(n) solution won't do any good. Googling around, I found that you can calculate the nth fib number in O(logn) and also a code sample that does exactly that:\n\n```\nlong long fibonacci(int n) {\n    long long fib[2][2] = {{1,1},{1,0}}, ret[2][2] = {{1,0},{0,1}}, tmp[2][2] = {{0,0},{0,0}};\n    int i, j, k;\n    while (n) {\n        if (n & 1) {\n            memset(tmp, 0, sizeof tmp);\n            for (i = 0; i < 2; i++)\n                for (j = 0; j < 2; j++)\n                    for (k = 0; k < 2; k++)\n                        tmp[i][j] = (tmp[i][j] + ret[i][k] * fib[k][j]);\n            for (i = 0; i < 2; i++)\n                for (j = 0; j < 2; j++)\n                    ret[i][j] = tmp[i][j];\n        }\n        memset(tmp, 0, sizeof tmp);\n        for (i = 0; i < 2; i++)\n            for (j = 0; j < 2; j++)\n                for (k = 0; k < 2; k++)\n                    tmp[i][j] = (tmp[i][j] + fib[i][k] * fib[k][j]);\n        for (i = 0; i < 2; i++)\n            for (j = 0; j < 2; j++)\n                fib[i][j] = tmp[i][j];\n        n /= 2;\n    }\n    return (ret[0][1]);\n}\n```\n\n\nI tried to modify it for the problem and am still getting WA: http://ideone.com/3TtE5m\n\nAm I calculating the modular arithmetic wrong? Or is something else the issue?\n    ", "Answer": "\r\nYou mean the nth Fibonacci number I hope.\n\nIn order to do it you need a matrix decomposition of Fibonacci numbers described here.\n\nThe basic idea is you take the Donald E. Knuth matrix identity form for a Fibonacci number which is:\n\n\n\nAnd instead of calculating the Fibonacci numbers in the traditional way you will try and find the matrix to the power of (k) where k is the given number.\n\nSo this is solving the problem in k matrix multiplications, not really helpful since we can do it in much easier way.\n\nBut wait! We can optimise the matrix multiplication. Instead of doing the k multiplications we can square it first and then do the half of the multiplications. And we can keep on doing it. So if the given number is 2a then we can do it in a steps. By keeping squaring the matrix.\n\nIf the number is not a power of 2 we can do the binary decomposition of a number and see whether to take the given squared matrix into final product or not.\n\nIn your case after each multiplication you also need to apply modulo operator 123456 to each matrix element.\n\nHope my explanation helps if not see the link for a clearer and longer one.\n\nThere is actually one more caveat of the task: as you are asked to provide some Fibonacci number modulo a given number, you should also prove that taking the remainder of each matrix element doesn't change the result. In other words if we multiply matrices and take remainder that we are actually still getting the Fibonacci number remainders. But since the remainder operation is distributive in addition and multiplication it actually does produce the correct results.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Add months to a date in format yymm\r\n                \r\nI am trying to add a specified number of months to a ```\nyymm```\n formatted date. I'm having a hard time dealing with cases when mm exceeds 12. So, for example:\n9109 (ie. 1991-Sept) + 17 months should yield 9302.\n9103 + 3 months should yield 9106\nCurrently, I am trying to use modular arithmetic to obtain the additional months in yymm format, but this isn't working as well as hoped. I convert 17 months into 0105, but adding 0105 to 9109 leads to 9214, which is nonsensical.\nThank you for any help.\n    ", "Answer": "\r\nHere are several approaches. All also work if x is a vector.\n1) as.yearmon Suggest storing your year/month data as yearmon objects.  They are stored internally as year + fraction where fraction is 0 for January, 1/12 for February, ..., 11/12 for December and when printed show in a recognizable form.\nNote that because x is numeric if we are in 2000 or 2001 then x does not have 4 digits so we need to zero fill as shown should such dates be in the input.\nIt's probably easier to just keep everything as yearmon objects but you could replace the last line with ```\nas.numeric(format(ym + 17/12, \"%y%m\"))```\n if you want the output in the same form as ```\nx```\n.\n```\nlibrary(zoo)\n\nx <- 9109 \nym <- as.yearmon(sprintf(\"%04f\", x), \"%y%m\")\nym + 17/12\n## [1] \"Feb 1993\"\n```\n\n2) as.POSIXlt  Another approach is to convert to POSIXlt and then add 17 to the months. This does not use any packages.  We have returned a character string below but you can convert it to numeric using ```\nas.numeric```\n if you want it in exactly the same form as ```\nx```\n.\n```\nlt <- as.POSIXlt(sprintf(\"%04d01\", x), format = \"%y%m%d\")\nlt$mon <- lt$mon + 17\nformat(lt, \"%y%m\")\n## [1] \"9302\"\n```\n\n3) modular arithmetic  To use modular arithmetic convert it to months, add 17 and convert back.  This does not use any packages.\n```\nmonths <- (12 * x %/% 100) + (x %% 100) - 1 + 17\n100 * (months %/% 12) + months %% 12 + 1\n## [1] 9302\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Question about C behaviour for unsigned integer underflow\r\n                \r\nI have read in many places that unsigned integer overflow is well-defined in C unlike the signed counterpart.\n\nIs underflow the same?\n\nFor example:\n\n```\nunsigned int x = -1; // Does x == UINT_MAX?\n```\n\n\nThanks.\n\nI can't recall where, but i read somewhere that arithmetic on unsigned integral types is modular, so if that were the case then -1 == UINT_MAX mod (UINT_MAX+1).\n    ", "Answer": "\r\n§6.3.1.3 Signed and unsigned integers, paragraph 2:\n\nif the new type is\nunsigned, the value is converted by\nrepeatedly adding or subtracting one\nmore than the maximum value that can\nbe represented in the new type until\nthe value is in the range of the new\ntype.\n\nSo yes, ```\nx == UINT_MAX```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "MULTOS Application Programming Interface [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question is seeking recommendations for books, tools, software libraries, and more. It does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     We don’t allow questions seeking recommendations for books, tools, software libraries, and more. You can edit the question so it can be answered with facts and citations.\r\n                \r\n                    \r\n                        Closed 7 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am working on smart cards and especially Java Card. I encountered a lot of difficulties to developp my own cryptographic algorithm due to the restricted API: no access to the crypto-processor to compute an addition of points on EC or a modular multiplication for example.\n\nI heard that MULTOS is more flexible for this kind of feature, is that true? Could you please mention some examples of crypto-processor features (modular arithmetics, elliptic curve points addition etc.) available in MULTOS API, but not available in Java Card?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Highest modulo of a group of numbers\r\n                \r\nI wrote some code that goes through all permutations of a given number and return the one that has the highest modulo of 8.\n\nWhat I'm wondering now, is there an algorithm/ruleset by which I could automatically exclude permutations that cannot have a modulo of 8 higher than the current number?\n\nI've been mulling it over and can't figure it out, but I feel certain that there is something that can be done to optimize the number of permutations that are checked. \n\nModular arithmetic isn't really my strong suit. \n\nThank you in advance if you have any ideas! \n    ", "Answer": "\r\nThere is no faster way.\n\nIf the number wasn't a power of two, it would be slow, but the compiler knows how to handle this, because ```\ny = x % 8;```\n is the same as ```\ny = x & 0x7;```\n.  So it only needs two operations to do the job: first extract the 3 LSbits, and then compare.\n\nNo possible microoptimizations here.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Making unsigned integer underflow throw an exception\r\n                \r\nI understand that there are applications in which using unsigned integer over/underflow is a good way to get cheap modular arithmetic.\n\nIn my code, I use ```\nuint```\n exclusively for indices to containers, so I never want this behaviour.\n\n\nIs this a bad idea? Should I be using ```\nint```\n everywhere instead? I do have to do some unsavoury things to get a for loop to count down to 0.\nIs there a commonly used implementation of a less unsafe unsigned integer type? Something that throws an exception?\nDo compilers (for me gcc, clang) provide a mechanism for less unsafe behaviour in the given compilation unit?\n\n    ", "Answer": "\r\nFirst, a terminology quibble: there is no such thing as unsigned integer underflow, precisely because of the way they wrap around (using modulo arithmetic), which is probably the phrase you meant.\n\nSecond, is this a common scenario to be in? Yes, it is a bit. You're not the only one doing \"unsavoury things\" with loops for reverse counting, and I bet there are a ton of bugs out there where people haven't done \"unsavoury things\" and, as a result, their code has an unsavoury infinite loop hidden in it. Mind you, I'm not sure I'd go so far as to call unsigneds \"unsafe\" as a result; like anything, they are the right tool for a subset of infinite possible jobs, and within that subset they perfectly safe.\n\nThere is debate over whether unsigned integers should be used for array indexes at all. Some standard committee members believe that their use in the standard library was a mistake; I know that several members of the c++ community here on Stack Overflow also hate ```\nunsigned```\n values and wish they'd go away.\n\nPersonally I think having access to the full range of the integer by default is absolutely crucial (and losing that is not worth it for a single \"-1\" sentinel value or whatever), so I think that — while you're not alone in this requirement, and it's a sensible requirement — using unsigned array indexes by default is a good thing. (And what the heck is a negative array index? Semantics, people!)\n\nBut that doesn't help you in this scenario. So, what can you do about it? No, there's no trapping unsigned integer implementation (at least, not one that I'm aware of, let alone widespread) because that would literally violate the rules of the type as defined by C++: it would introduce well-defined underflow/overflow semantics to a type for which underflow/overflow shouldn't even be possible.\n\nYou will have to use signed integers and check for \"logical underflow\" (i.e. going out of your desired range, say -1) yourself. You could wrap this behaviour in a class.\n\nI suppose you could actually just wrap an unsigned integer while you're at it, adding some extra logic to ```\noperator--```\n and ```\noperator-=```\n to detect a wrap-around and throw.\n\nBut I guess my point is that, whatever you do, it's going to be in your \"code space\" and thus subject to decreased performance. You can't eke out this behaviour from the platform itself.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "My code is caught in an infinite loop when I'm trying to find the maximum non dividable subset using the naive approach\r\n                \r\nI'm aware of the modular arithmetic approach to solve this question, I just took it upon myself to solve it in the more naive way, but I just created an infinite loop somewhere in the inner for loop and there is no way out (Please do not tell me to do it in the standard way, This is just a challenge that I made upon myself)\nThe function return the size of a maximal subset of  S where the sum of any 2 numbers in s’ is not evenly divisible by k.\nhere is my code that causes an infinite loop, so be careful\n```\nfunction nonDivisibleSubset(arr, k) {\n  let maxElements = 0;\n  for (let i = 0; i < arr.length; i++) {\n    console.log(i);\n    // arr 1 to (arr.length - 1)\n    let result = [];\n    let noOfElements = 0;\n    for (let j = 0 + 1; j < arr.length; j++) {\n      console.log(`hi${j}`);\n      //arr 2 to arr.length\n      console.log(result.length);\n      if (\n        result.length === 0 &&\n        (arr[i] + arr[j]) % k !== 0\n      ) {\n        console.log(\"hi2\");\n        result.push(arr[i], arr[j]);\n        noOfElements += 2;\n      } else {\n        let isDivisible = false;\n        console.log(`result length: ${result.length}`);\n        for (let l = 0; l < result.length; l++) {\n          console.log(l);\n          if (i !== l && (arr[l] + arr[j]) % 4 === 0) {\n            isDivisible = true;\n            break;\n          }\n          if (!isDivisible) {\n            result.push(arr[l]);\n            console.log(result);\n            noOfElements += 1;\n            break; //removing this break will initialize the infinite loop\n          }\n        }\n      }\n    }\n    if (noOfElements > maxElements) {\n      maxElements = noOfElements;\n    }\n  }\n  return maxElements;\n}\n\n//initialise\nnonDivisibleSubset([19, 10, 12, 10, 24, 25, 22], 4)\n```\n\n    ", "Answer": "\r\nThe ```\nresul array```\n continues to increase in size as the repeat statement spins.\nHere is an example of how you can do it:\n```\n\nfor (let l = 0, size = result.length; l < size; l++) {\n    if (i !== l && (arr[l] + arr[j]) % 4 === 0) {\n        isDivisible = true;\n        break;\n    }\n    if (!isDivisible) {\n        result.push(arr[l]);\n        console.log(result);\n        console.log(result.length);\n        noOfElements += 1;\n        break; //removing this break will initialize the infinite loop\n    }\n}\n\n```\n\nAnd,\n```\n\nif (i !== l && (arr[l] + arr[j]) % 4 === 0)\n\n```\n\nIsn't it k, not 4?\n```\n\nif (i !== l && (arr[l] + arr[j]) % k === 0)\n\n```\n\nI hope it helps.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "floating point multiplication vs repeated addition\r\n                \r\nLet ```\nN```\n be an a compile time unsigned integer.\n\nGCC can optimize\n\n```\nunsigned sum = 0;\nfor(unsigned i=0; i<N; i++) sum += a; // a is an unsigned integer   \n```\n\n\nto simply  ```\na*N```\n. This can be understood since modular arithmetic says ```\n(a%k + b%k)%k = (a+b)%k```\n.\n\nHowever GCC will not optimize\n\n```\nfloat sum = 0;\nfor(unsigned i=0; i<N; i++) sum += a;  // a is a float\n```\n\n\nto ```\na*(float)N```\n.\n\nBut by using associative math with e.g. ```\n-Ofast```\n I discovered that GCC can reduce this in order ```\nlog2(N)```\n steps.  E.g for ```\nN=8```\n it can do the sum in three additions.\n\n```\nsum = a + a\nsum = sum + sum // (a + a) + (a + a)\nsum = sum + sum // ((a + a) + (a + a)) + ((a + a) + (a + a))\n```\n\n\nThough some point after ```\nN=16```\n GCC goes back to doing ```\nN-1```\n sums. \n\nMy question is why does GCC not do ```\na*(float)N```\n with ```\n-Ofast```\n?  \n\nInstead of being ```\nO(N)```\n or ```\nO(Log(N))```\n it could be simply ```\nO(1)```\n. Since ```\nN```\n is known at compile time it's possible to determine if ```\nN```\n fits in a float. And even if ```\nN```\n is too large for a float it could do ```\nsum =a*(float)(N & 0x0000ffff) + a*(float)(N & ffff0000)```\n.  In fact, I did a little test to check the accuracy and ```\na*(float)N```\n is more accurate anyway (see the code and results below).\n\n```\n//gcc -O3 foo.c\n//don't use -Ofast or -ffast-math or -fassociative-math\n#include <stdio.h>   \nfloat sumf(float a, int n)\n{\n  float sum = 0;\n  for(int i=0; i<n; i++) sum += a;\n  return sum;\n}\n\nfloat sumf_kahan(float a, int n)\n{\n  float sum = 0;\n  float c = 0;\n  for(int i=0; i<n; i++) {\n    float y = a - c;\n    float t = sum + y;\n    c = (t -sum) - y;\n    sum = t;\n  }\n  return sum;\n}  \n\nfloat mulf(float a, int n)\n{\n  return a*n;\n}  \n\nint main(void)\n{\n  int n = 1<<24;\n  float a = 3.14159;\n  float t1 = sumf(a,n);\n  float t2 = sumf_kahan(a,n);\n  float t3 = mulf(a,n);\n  printf(\"%f %f %f\\n\",t1,t2,t3);\n}\n```\n\n\nThe result is ```\n61848396.000000 52707136.000000 52707136.000000```\n which shows that multiplication and the Kahan summation have the same result which I think shows that the multiplication is more accurate than the simple sum.\n    ", "Answer": "\r\nThere are some fundamental difference between\n\n```\n float funct( int N, float sum )\n {\n     float value = 10.0;\n     for( i = 0; i < N ;i ++ ) {\n         sum += value;\n     }\n     return sum;\n }\n```\n\n\nand\n\n```\nfloat funct( int N, float sum )\n{\n    float value = 10.0;\n    sum += value * N;\n    return sum;\n}\n```\n\n\nWhen the sum approaches FLT_EPSILON * larger than value, the repeated sum tends towards a no-op.  So any large value of N, would result in no change to sum for repeated addition.  For the multiplication choice, the result (value * N) needs to be FLT_EPSILON * smaller than sum for the operation to have a no-op.\n\nSo the compiler can't make the optimization, because it can't tell if you wanted the exact behavior (where multiply is better), or the implemented behavior, where the scale of  sum affects the result of the addition.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Parallel arbitrary-precision arithmetic library [closed]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                Closed. This question does not meet Stack Overflow guidelines. It is not currently accepting answers.\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n        \r\n            \r\n        \r\n            \r\n                \r\n                        \r\n                            \r\n                        \r\n                     Questions asking us to recommend or find a tool, library or favorite off-site resource are off-topic for Stack Overflow as they tend to attract opinionated answers and spam. Instead, describe the problem and what has been done so far to solve it.\r\n                \r\n                    \r\n                        Closed 8 years ago.\r\n                    \r\n                \r\n\r\n                \r\n            \r\n        \r\n            \r\n                    \r\n                        Improve this question\r\n                    \r\n            \r\n\r\n\r\n    \r\n\r\nI am trying to do modular exponentiation of integers with a very large modulus by repetitive squaring (the power is always a power of 2 in my case, so I believe this is the most efficient way).  Thanks to a nice property of my modulus, computing remainder is cheap; the hard part is multiplication.\n\nCurrently I run GMP on Intel Core 2 Quad.  I would like to make efficient use of the four cores of the processor, but GMP does not scale on SMP environments, so I am looking for a substitute arbitrary-precision arithmetic library.  I have found some libraries for parallel computation on matrices, but what I really need is a library for integers.\n\nDoes what I am looking for exist?\n    ", "Answer": "\r\nThe answer is yes, multi-threaded arbitrary-precision libraries do exist. But I'm not aware of a single one that is actually public. (with comparable speed to GMP)\n\nFor example, the arbitrary-precision libraries that are used in the Pi-computing programs, TachusPi and y-cruncher are capable of multi-threaded arithmetic on large numbers.\n\nHowever, both libraries are closed source and are not available to the public for use.\n\nAffiliation Disclosure: I'm the author of y-cruncher. So I have written one of such multi-threaded arbitrary-precision libraries myself.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Comparing Negative Indices in Numpy with Postive Indices\r\n                \r\nI have a numpy array of indeterminate size and I need to compare some indices being used to extract data. For example if ```\nstart_index > end_index```\n I want an error to be thrown. However, sometimes the indices might be negative, most notably we might have ```\nend_index = -1```\n to represent the final element in the array. If I just straight up compared the indices and ```\nend_index```\n was negative an error could be thrown incorrectly.\n\nMy current solution is to check if ```\nstart_index % array_length > end_index % array_length```\n.\n\nThis does work, but I'm now having to think about everything using modular arithmetic. Does anyone know of a more efficient solution, perhaps a tool from numpy itself?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Computing mod inverse\r\n                \r\nI want to compute the inverse element of a prime in modular arithmetic.\nIn order to speed things up I start a few goroutines which try to find the element in a certain range. When the first one finds the element, it sends it to the main goroutine and at this point I want to terminate the program. So I call ```\nclose```\n in the main goroutine, but I don't know if the goroutines will finish their execution (I guess not). So a few questions arise:\n\n1) Is this a bad style, should I have something like a ```\nWaitGroup```\n?\n\n2) Is there a more idiomatic way to do this computation?\n\n```\npackage main\n\nimport \"fmt\"\n\nconst (\n    Procs = 8\n    P     = 1000099\n    Base  = 1<<31 - 1\n)\n\nfunc compute(start, end uint64, finished chan struct{}, output chan uint64) {\n    for i := start; i < end; i++ {\n        select {\n        case <-finished:\n            return\n        default:\n            break\n        }\n        if i*P%Base == 1 {\n            output <- i\n        }\n    }\n}\n\nfunc main() {\n    finished := make(chan struct{})\n    output := make(chan uint64)\n\n    for i := uint64(0); i < Procs; i++ {\n        start := i * (Base / Procs)\n        end := (i + 1) * (Base / Procs)\n        go compute(start, end, finished, output)\n    }\n\n    fmt.Println(<-output)\n    close(finished)\n}\n```\n\n    ", "Answer": "\r\n\n  Is there a more idiomatic way to do this computation?\n\n\nYou don't actually need a loop to compute this.\n\nIf you use the GCD function (part of the standard library), you get returned numbers x and y such that:\n\n```\nx*P+y*Base=1 \n```\n\n\nthis means that x is the answer you want (because x*P = 1 modulo Base):\n\n```\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nconst (\n    P    = 1000099\n    Base = 1<<31 - 1\n)\n\nfunc main() {\n    bigP := big.NewInt(P)\n    bigBase := big.NewInt(Base)\n    // Compute inverse of bigP modulo bigBase\n    bigGcd := big.NewInt(0)\n    bigX := big.NewInt(0)\n    bigGcd.GCD(bigX,nil,bigP,bigBase)\n    // x*bigP+y*bigBase=1 \n    // => x*bigP = 1 modulo bigBase\n    fmt.Println(bigX)\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Boolean convolution algorithm?\r\n                \r\nI need to perform Boolean convolutions; that is, convolution of bit-vectors where:\n\n\nOR is the \"addition\" operation\nAND is the \"multiplication\" operation\n\n\nIs there an algorithm I can use (similar, perhaps, to an FFT) to do this in faster than quadratic time?\n\nI've looked into \"number-theoretic transforms\" (NTTs), but they seem to be the Fourier analog of modular arithmetic (which wraps around on addition) rather than Boolean arithmetic (which saturates on addition).\n\nThe best alternative I'm aware of would be to approximate it via a vector of floating-point 1's and 0's, and simply use an FFT and threshold the result at some cutoff, but this can be error-prone (and potentially slower than necessary, although error is my bigger concern here).\n(And in any case, I'd like to know if there's a \"correct\" way to do this despite this potential alternative.)\n    ", "Answer": "\r\nIf you convolve the Boolean vectors as 0-1 vectors over the integers mod an integer larger than the length of the shorter vector (i.e., the maximum number of terms in a disjunct), then the pattern of nonzero entries is the same.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Increase digits of a number by one\r\n                \r\nI am working on this seemingly simple problem, where I need to add one to every digit of a number. Example: number = 1234 ; output = 2345\n\nThat's simple, but when 9 is one of those digits, then by the law of addition, that 9 will be replaced by 0 and 1 will be added to the number on the left (9 + 1 = 10, hence, place value = 0 & carry over = 1)\nExample: number = 1239 ; output = 2350\n\n```\nnumber = 1234\ns = str(number)\nl = []\n\nfor num in s:\n    num = int(num)\n    num += 1\n    if num > 9:\n        num = 0\n        l.append(num)\n    else:\n        l.append(num)\n\nprint int(''.join(str(v) for v in l))\n```\n\n\nCan someone please explain to me, what logic should I use? I can see something on the lines of modular arithmetic, but not really sure how to implement that.\nThanks :)\n    ", "Answer": "\r\nA simple approach would be as follows\n\nConsider a number N = anan-1an-2...a0\n\nThen F(N) = N + (10n-1+10n-2 .. 100) = N + int('1' X N)\n          = N + (10n - 1) / (10 - 1) = N + (10n - 1) / 9\n\n```\n>>> def foo(N):\n    return N + int('1'*len(str(N)))\n\n>>> foo(1234)\n2345\n>>> foo(1239)\n2350\n```\n\n\nEdit: Simplifying a bit by utilizing sum of power formula\n\n```\n>>> def foo(N):\n    return N + ((10**len(str(N)) - 1) // 9)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Create a type for each Integer in Haskell?\r\n                \r\nI would like to create a data type in Haskell that represents the integers mod ```\nn```\n, and which is an instance of ```\nNum```\n to help perform simple modular arithmetic operations. My first attempt at this looked like this\n\n```\ndata Z n e = El n e\ninstance (Show n, Show e) => Show (Z n e) where\n    show (El n e) = show e ++ \" (mod \" ++ show n ++ \")\"\n\ninstance (Integral k, Integral e) => Num (Z k e) where\n    (+) (El n a) (El m b) = El n (mod (a + b) n)\n    (-) (El n a) (El m b) = El n (mod (a - b) n)\n    (*) (El n a) (El m b) = El n (mod (a * b) n)\n    negate (El n a) = El n (mod (0 - a) n)\n    abs (El n a) = El n a\n    signum (El n a) = El n a\n    fromInteger i = -- problematic...\n```\n\n\nThis compiles but is problematic not only because its unclear how to implement ```\nfromInteger```\n since ```\nk```\n is out of scope, but also because it is permissible to add an integer ```\nmod 4```\n with an integer ```\nmod 5```\n without a type error. In my second attempt I tried to resolve these issues\n\n```\ndata Z n = El Integer\ninstance (Show n) => Show (Z n) where\n    show (El n e) = show e ++ \" (mod \" ++ show n ++ \")\"\n\ninstance (Integral k) => Num (Z k) where\n    (+) (El k a) (El k b) = El k (mod (a + b) k)\n    (-) (El k a) (El k b) = El k (mod (a - b) k)\n    (*) (El k a) (El k b) = El k (mod (a * b) k)\n    negate (El k a) = El k (mod (0 - a) k)\n    abs (El k a) = El k a\n    signum (El k a) = El k a\n    fromInteger i = El (fromIntegral i) k\n```\n\n\nbut I am running into trouble implementing the ```\nNum```\n interface because of conflicting definitions of ```\nk```\n which is still out of scope. How can I make such a data type in Haskell?\n    ", "Answer": "\r\nAs noted in the comments, the idea is to make use of a type-level representation of natural numbers, so you have separate identifiable types for 2 versus 3 versus 4, etc.  This requires an extension:\n\n```\n{-# LANGUAGE DataKinds #-}\n```\n\n\nThere are two main methods for representing naturals as types.  The first is to define a recursive data type:\n\n```\ndata Nat' = Z | S Nat'\n```\n\n\nwhich the ```\nDataKinds```\n extension automatically lifts to the type level.  You can then use this as, among other things, a type-level tag to define a family of related but distinct types:\n\n```\n{-# LANGUAGE KindSignatures #-}\ndata Foo (n :: Nat') = Foo Int\n\ntwoFoo :: Foo (S (S Z))\ntwoFoo = Foo 10\n\nthreeFoo :: Foo (S (S (S Z)))\nthreeFoo = Foo 20\n\naddFoos :: Foo n -> Foo n -> Foo n\naddFoos (Foo x) (Foo y) = Foo (x + y)\n\nokay = addFoos twoFoo twoFoo\nbad =  addFoos twoFoo threefoo -- error: different types\n```\n\n\nThe second is to use a built-in GHC facility that automatically lifts integer literals, like ```\n2```\n and ```\n3```\n to the type level.  It works much the same way:\n\n```\nimport GHC.TypeLits (Nat)\n\ndata Foo (n :: Nat) = Foo Int\n\ntwoFoo :: Foo 2\ntwoFoo = Foo 10\n\nthreeFoo :: Foo 3\nthreeFoo = Foo 20\n\naddFoos :: Foo n -> Foo n -> Foo n\naddFoos (Foo x) (Foo y) = Foo (x + y)\n\nokay = addFoos twoFoo twoFoo\nbad =  addFoos twoFoo threefoo -- type error\n```\n\n\nWhen you're using naturals only to \"tag\" a type, it's generally more convenient to use the ```\nGHC.TypeLits```\n version of ```\nNat```\n.  If you have to actually do type-level computations on the types, some computations are more easily done using the recursive version.\n\nSince we only need the naturals as tags, we can stick with the ```\nGHC.TypeLits```\n solution.  So, we'd define your data type like so:\n\n```\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\nimport GHC.TypeLits\ndata Z (n :: Nat) = El Integer\n```\n\n\nIn the ```\nShow```\n instance, we need to make use of some other facilities in ```\nGHC.TypeLits```\n to convert the type-level ```\nNat```\n to a value-level ```\nInteger```\n that we can include in the printed representation:\n\n```\ninstance (KnownNat n) => Show (Z n) where\n  show el@(El e) = show e ++ \" (mod \" ++ show (natVal el) ++ \")\"\n```\n\n\nThere's magic going on here!  The ```\nnatVal```\n function has signature:\n\n```\nnatVal :: forall n proxy. KnownNat n => proxy n -> Integer\n```\n\n\nmeaning that for a ```\n\"KnownNat\"```\n, whatever that means, it can take a proxy value whose type is of form ```\nproxy n```\n, and return the actual integer corresponding to the type-level argument ```\nn```\n.  Fortunately, our original element has type ```\nZ n```\n which fits the ```\nproxy n```\n type pattern just fine, so by running ```\nnatVal el```\n, we get the value-level ```\nInteger```\n corresponding to the type-level ```\nn```\n in ```\nZ n```\n.\n\nWe'll use the same magic in the ```\nIntegral```\n instance:\n\n```\ninstance (KnownNat k) => Num (Z k) where\n    (+) el@(El a) (El b) = El (mod (a + b) k) where k = natVal el\n    (-) el@(El a) (El b) = El (mod (a - b) k) where k = natVal el\n    (*) el@(El a) (El b) = El (mod (a * b) k) where k = natVal el\n    negate el@(El a) = El (mod (0 - a) k) where k = natVal el\n    abs el@(El a) = El a where k = natVal el\n    signum el@(El a) = El 1\n    fromInteger i = El (fromIntegral i)\n```\n\n\nNote that the ```\nk```\n disappears from the ```\nEl```\n constructor, because it's not a data-level quantity.  Where needed, it can be retrieved using ```\nnatVal el```\n using the ```\nKnownNat```\n instance.\n\nThe full program is:\n\n```\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE KindSignatures #-}\nimport GHC.TypeLits\ndata Z (n :: Nat) = El Integer\n\ninstance (KnownNat n) => Show (Z n) where\n  show el@(El e) = show e ++ \" (mod \" ++ show (natVal el) ++ \")\"\n\ninstance (KnownNat k) => Num (Z k) where\n    (+) el@(El a) (El b) = El (mod (a + b) k) where k = natVal el\n    (-) el@(El a) (El b) = El (mod (a - b) k) where k = natVal el\n    (*) el@(El a) (El b) = El (mod (a * b) k) where k = natVal el\n    negate el@(El a) = El (mod (0 - a) k) where k = natVal el\n    abs el@(El a) = El a where k = natVal el\n    signum el@(El a) = El 1\n    fromInteger i = El (fromIntegral i)\n```\n\n\nand it works as intended:\n\n```\n> :set -XDataKinds\n> (El 2 :: Z 5) + (El 3 :: Z 5)\n0 (mod 5)\n> (El 2 :: Z 5) + (El 3 :: Z 7)\n\n<interactive>:15:18: error:\n    • Couldn't match type ‘7’ with ‘5’\n      Expected type: Z 5\n        Actual type: Z 7\n    • In the second argument of ‘(+)’, namely ‘(El 3 :: Z 7)’\n      In the expression: (El 2 :: Z 5) + (El 3 :: Z 7)\n      In an equation for ‘it’: it = (El 2 :: Z 5) + (El 3 :: Z 7)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Python, how can I set iterator of enumerate to 0 while reading same file again and again\r\n                \r\n```\nwith open(\"...txt\") as fp: \n    for i, line in enumerate(fp): \n        if some condition : \n            i=0\n            fp.seek(0)\n```\n\n\n\n\nText is huge, GBs of data so I use enumerate. I need to process this huge file several thousands of time so I decided to open it just at first time for efficiency. However although this code works, ```\ni```\n does not become 0 and it just goes on incrementing. I need that to be zero because I need position of lines ```\ni```\n. And it is just inefficient to multiply billions*several thousands everytime and make some modular arithmetic.\n\nSo my question is how can I set ```\ni```\n to be zero when I go back to the beginning of file? Thanks in advance (I use python 3.6)\n    ", "Answer": "\r\nYou could always make your own resettable enumerator, but there are probably better ways to do what you really want to do.\n\nStill, here's what a resettable enumerator looks like:\n\n```\n def reset_enumerate(thing, start=0):\n     x = start\n     for t in thing:\n         val = yield t, x\n         if val is not None:\n             x = val\n         else:\n             x += 1\n```\n\n\nThen you would use it like this:\n\n```\nr = reset_enumerate(range(10))\nfor i, num in r:\n    print('i:', i, 'num:', num)     \n    if i == 5:\n        i, num = r.send(0)\n        print('i:', i, 'num:', num)\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Optimally sampling n rows from location Pandas dataframe\r\n                \r\nI have a dataframe of latitudes and longitudes. I want to get a sample of size n_samples that covers the majority of the region in the dataframe. At first, I wanted to first sort the dataframe by latitude and longitude and then use modular arithmetic to select evenly spread-out rows. However, this does not work in cases where I wish to sample, say, 27 out of 100 rows, since 100 % 27 is not 0. Note this problem gets even worse when trying to use n_sample=80 (since it would sample all 100 rows). So it will not be useful to simply adjust the number of rows afterward.\n```\nimport random\nimport pandas as pd\n\nn_samples = 27\nlat = [random.uniform(30, 50) for i in range(100)]\nlon = [random.uniform(-130, -100) for i in range(100)]\n\nloc_df = pd.DataFrame([lat, lon]).T\nloc_df.columns = ['lat', 'lon']\n\n# Sort loc_df by lat/lon\nloc_df = loc_df.sort_values(['lat', 'lon'])\n\n# Sample every n rows \n# Tends to sample either too many or too few rows\n# In this case, we will be sampling 24 instead of 27 rows\n\nevery_n = round(loc_df.shape[0]/n_samples) \nsample_df = loc_df[::every_n].reset_index(drop=True)\n```\n\n    ", "Answer": "\r\nThe first thing that comes to mind is 'train_test_split' from sklearn.\n\r\n\r\n```\nfrom sklearn.model_selection import train_test_split\n\ntest_pct = 1 - (n_samples / len(loc_df))\n\n\nX = loc_df.iloc[:,0]\nY = loc_df.iloc[:,1]\n\nX_sample, X_remain, Y_sample, Y_remain = train_test_split( X, Y, test_size=test_pct, random_state=0)\n\nsample_df = X_sample.to_frame().join(Y_sample).reset_index(drop=True)```\n\r\n\r\n\r\n\nThis assigns a test_pct variable based on your n_samples and the size of the dataframe\nCreate X (lat) and Y(lon) arrays from your loc_df\nUse \"train_test_split\" to randomly select your \"n_samples\"\nand then create your sample_df dataframe containing \"n_samples\" of data.\nWill that work for your purposes?\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Inferring mRNA from Protein Rosalind\r\n                \r\nProblem\n\nFor positive integers aa and nn, aa modulo nn (written amodnamodn in shorthand) is the remainder when aa is divided by nn. For example, 29mod11=729mod11=7 because 29=11×2+729=11×2+7.\n\nModular arithmetic is the study of addition, subtraction, multiplication, and division with respect to the modulo operation. We say that aa and bb are congruent modulo nn if amodn=bmodnamodn=bmodn; in this case, we use the notation a≡bmodna≡bmodn.\n\nTwo useful facts in modular arithmetic are that if a≡bmodna≡bmodn and c≡dmodnc≡dmodn, then a+c≡b+dmodna+c≡b+dmodn and a×c≡b×dmodna×c≡b×dmodn. To check your understanding of these rules, you may wish to verify these relationships for a=29a=29, b=73b=73, c=10c=10, d=32d=32, and n=11n=11.\n\nAs you will see in this exercise, some Rosalind problems will ask for a (very large) integer solution modulo a smaller number to avoid the computational pitfalls that arise with storing such large numbers.\n\nGiven: A protein string of length at most 1000 aa.\n\nReturn: The total number of different RNA strings from which the protein could have been translated, modulo 1,000,000. (Don't neglect the importance of the stop codon in protein translation.)\n\nSample Dataset\n\nMA\n\nSample Output\n\n12\n\nMy Answer is always set to zero. I realize that there is some issue with the way use mod but I don't know what exactly that is.\n\n```\nrna_table = {\"UUU\":\"F\", \"UUC\":\"F\", \"UUA\":\"L\", \"UUG\":\"L\",\n\"UCU\":\"S\", \"UCC\":\"s\", \"UCA\":\"S\", \"UCG\":\"S\",\n\"UAU\":\"Y\", \"UAC\":\"Y\", \"UAA\":\"STOP\", \"UAG\":\"STOP\",\n\"UGU\":\"C\", \"UGC\":\"C\", \"UGA\":\"STOP\", \"UGG\":\"W\",\n\"CUU\":\"L\", \"CUC\":\"L\", \"CUA\":\"L\", \"CUG\":\"L\",\n\"CCU\":\"P\", \"CCC\":\"P\", \"CCA\":\"P\", \"CCG\":\"P\",\n\"CAU\":\"H\", \"CAC\":\"H\", \"CAA\":\"Q\", \"CAG\":\"Q\",\n\"CGU\":\"R\", \"CGC\":\"R\", \"CGA\":\"R\", \"CGG\":\"R\",\n\"AUU\":\"I\", \"AUC\":\"I\", \"AUA\":\"I\", \"AUG\":\"M\",\n\"ACU\":\"T\", \"ACC\":\"T\", \"ACA\":\"T\", \"ACG\":\"T\",\n\"AAU\":\"N\", \"AAC\":\"N\", \"AAA\":\"K\", \"AAG\":\"K\",\n\"AGU\":\"S\", \"AGC\":\"S\", \"AGA\":\"R\", \"AGG\":\"R\",\n\"GUU\":\"V\", \"GUC\":\"V\", \"GUA\":\"V\", \"GUG\":\"V\",\n\"GCU\":\"A\", \"GCC\":\"A\", \"GCA\":\"A\", \"GCG\":\"A\",\n\"GAU\":\"D\", \"GAC\":\"D\", \"GAA\":\"E\", \"GAG\":\"E\",\n\"GGU\":\"G\", \"GGC\":\"G\", \"GGA\":\"G\", \"GGG\":\"G\"}\n\nwith open(\"rosalind_mrna.txt\") as myfile:\n\n  data = myfile.readlines()\n\ncharData = list(data[0].strip())\n\n\nfrequency_list = {};\n\nfor k,v in rna_table.items():\n\n  if not frequency_list.has_key(v):\n    frequency_list[v] = 1\n  else:\n    frequency_list[v] += 1\n\nanswer = frequency_list['STOP'];\nfor aa in charData:\n  answer = ((answer * frequency_list[aa]) % 1000000)\n\nprint \"Answer is:\\n\"\nprint answer % 1000000\n```\n\n    ", "Answer": "\r\nA couple of minor issues:\n\n\nYou have a typo: ```\n\"UCC\":\"s\"```\n should be ```\n\"UCC\":\"S\"```\n\n```\nif not frequency_list.has_key(v):```\n is more Pythonically written as ```\nif v not in frequency_list:```\n (in fact ```\n.has_key```\n has been removed from Python 3)\n```\ncharData = list(data[0].strip())```\n - ```\nlist()```\n is not needed, you can iterate over the string directly just as well\n```\nfrequency_list = {};```\n - the trailing semicolon is not needed\n```\nprint answer % 1000000```\n - the final ```\n% 1000000```\n is unnecessary, it was already done in the loop calculating ```\nanswer```\n\n\n\nSo it looks like the example, ```\nMA```\n, works like\n\n```\n(\n    {number of ways to encode M == 1}\n  * {number of ways to encode A == 4}\n  * {number of ways to encode STOP == 3}\n)\n% 1000000\n```\n\n\nwhich gives 12, as stated.\n\nYour code works for me as-is, returning ```\n827968```\n. I would take a look at your copy of ```\nrosalind_mrna.txt```\n (make sure it's not a blank file) and check the contents of ```\ndata```\n (make sure it is loading the file correctly).\n\nJust for comparison, I would write it as\n\n```\nfrom functools import reduce\nfrom operator import mul\n\nfreq = {\n    'A': 4, 'C': 2, 'D': 2, 'E': 2,\n    'F': 2, 'G': 4, 'H': 2, 'I': 3,\n    'K': 2, 'L': 6, 'M': 1, 'N': 2,\n    'P': 4, 'Q': 2, 'R': 6, 'S': 6,\n    'T': 4, 'V': 4, 'W': 1, 'Y': 2,\n    'STOP': 3\n}\n\ndef load_dna_file(fname):\n    with open(fname) as inf:\n        dna = inf.read()\n    return \"\".join(dna.split())   # removes all whitespace\n\ndef num_rna_strings(dna, modulo=None):\n    if modulo:\n        reduce_fn = lambda a, b: (a * b) % modulo\n    else:\n        reduce_fn = mul\n    freqs = (freq[base] for base in dna)\n    return reduce(reduce_fn, freqs, freq[\"STOP\"])\n\ndef main():\n    dna = load_dna_file(\"rosalind_mrna.txt\")\n    num = num_rna_strings(dna, 1000000)\n    print(\"Answer is {}\".format(num))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n\nFor interest, if you do not use modulo, the full answer is 423 digits long (6.186 * 10 ** 422)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Z3 Power Modulo Statements\r\n                \r\nDoes Z3 have the ability to do power mod arithmetic? For instance, if I'm placing in expressions of the sort ```\nx ** y % z```\n, is there a way to tell Z3 that it is this type of expression, similar to how python has the function ```\npow(x,y,z)```\n? My assumption is that would open up solving options (such as modular inverse).\n    ", "Answer": "\r\nInteresting point. There isn't any particular support for this in Z3. What are the known techniques in this area?\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "What is an efficient method for adding thousands of numbers quickly?\r\n                \r\nI am attempting to solve a challenge, but I have hit a roadblock. I am a beginner programmer attempting to add tens of thousands of numbers. If I wait long enough, my program can easily yield the correct sum, however, I am looking for a more efficient method.\n\nWhat is an efficient method for adding thousands of numbers quickly?\n\nSide note: I have been reading about modular arithmetic, but I cannot quite wrap my head around it. Not sure if that could be useful for this situation.\n\nI am attempting to get the sum of every prime number below 2 000 000. Here is my code so far:\n\n```\npublic class Problem10 {\n    public static void main (String[] args) {\n        long sum = 0L;\n\n        for(long i = 1L; i < 2000000; i++) {\n            if(isPrimeNumber((int)i)) {\n                sum += i;\n            }\n        }\n        System.out.println(sum);\n    }\n\n    public static boolean isPrimeNumber(int i) {\n        int factors = 0;\n        int j = 1;\n\n        while (j <= i) {\n            if (i % j == 0) {\n                factors++;\n            }\n            j++;\n        }\n        return (factors == 2);\n    }\n}\n```\n\n    ", "Answer": "\r\nYou can replace your ```\nisPrimeNumber()```\n method with this to speed it up substantially.\n\n```\npublic static boolean isPrimeNumber(int i) {\n    if (i==2) return true;\n    if (i==3) return true;\n    if (i%2==0) return false;\n    if (i%3==0) return false;\n\n    int j = 5;\n    int k = 2;\n\n    while (j * j <= i) {\n        if (i % j == 0) return false;\n        j += k ;\n        k = 6 - k;\n\n    }\n    return true;\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Iterate over subrange of weekdays\r\n                \r\nI'm trying to iterate over a range of weekdays, where each weekday maps to an integer ```\n(Sunday = 1, Monday = 2, ..., Saturday = 7)```\n. \n\nThe range is defined by a ```\nstart and end day```\n. This is fine for a start and end day like ```\nMonday(2) - Thursday(5)```\n, as I can just do:\n\n```\nfor(int i = startDay; i <= endDay; i++) { ... } \n```\n\n\nI'm having difficulty when the range is split across the end and start of a week, like ```\nFriday(6) - Monday(2)```\n. This obviously doesn't work with the above for loop - e.g.\n\n```\nfor(int i = 6; i <= 2; i++) { ... }    // wouldn't even execute once. \n```\n\n\nThe only solution I can see is implementing some sort of circular buffer, which I feel is overkill for such a simple problem. I'm just stumped, and most likely missing something obvious here. I think a solution may have something to do with modular arithmetic, but I'm not quite sure.\n    ", "Answer": "\r\nYou can do:\n\n```\nint numberOfDays = endDay >= startDay ? endDay - startDay : 8 - (startDay - endDay);\nfor (int i = startDay; i <= startDay + numberOfDays; i++) {\n    int day = (i - 1) % 7 + 1;\n}\n```\n\n\nThis makes use of the ```\n%```\n modulo operator to ensure all values remain within 1 - 7.\n\nFor example, once ```\ni```\n becomes 8 the calculation will wrap ```\nday```\n back to 1: ```\n(8 - 1) % 7 + 1 == 1```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "multiprecision unsigned subtraction in C\r\n                \r\nI am trying to implement multi-precision unsigned subtraction over a finite field (p=2^191-19) in C, but I cannot figure out how to deal with borrow bit!\nMy operands are represented in radix-2^16 as:\n\n```\ntypedef unsigned long long T[12];\n```\n\n\nwhich means each element of the T-type array has exactly 16-bits data (radix-2^16 representation). \nNow I want to subtract two operands of T type, but I do not know which one is smaller! If the result is negative, I want to add the result to the prime value to have positive results in modular arithmetic. \nHere is my implementation based on this book page-30(Multiprecision subtraction algorithm):\n\n```\nvoid bigint192_sub(T r, const T a, const T b){\n    int i;\n    int borrow;\n    r[0] = a[0] - b[0];\n    borrow = r[0] >> 16;\n    r[0] &= 0xFFFF;\n    for(i=1;i<12;++i){\n        r[i] = a[i] - b[i] - borrow;\n        borrow = r[i] >> 16;\n        r[i] &= 0xFFFF;\n    }\n}\n```\n\n\nbut I got the wrong answer!\n\n```\nMy inputs:\na =0x2d7e33e5bba0f6bb87ce04b28e940662db8f3f81aaf94576\nb =0x28afc585dca4a8003b081f7289de11c2d229d5a967081f72\nMyresult=0x4d16e62defd4ebc4cc8e54104b7f4a0096769d843f12604\nCrresult=0x4ce6e5fdefc4ebb4cc5e54004b5f4a0096569d843f12604\n```\n\n    ", "Answer": "\r\nYou should fix ```\nborrow```\n evaluation, since it may be only ```\n0```\n or ```\n1```\n. So you should treat underflow as ```\nborrow```\n equals to ```\n1```\n:\n\n```\nborrow = (r[i] >> 16) != 0;\n```\n\n\nAlso I'd rewrite function in a bit more general form, since we may treat first pass as like we have no borrow:\n\n```\nvoid bigint192_sub(T r, const T a, const T b){\n    int i;\n    int borrow;\n    for (borrow = 0, i = 0; i < 12; ++i) {\n        r[i] = a[i] - b[i] - borrow;\n        borrow = (r[i] >> 16) != 0;\n        r[i] &= 0xFFFF;\n    }\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Rabin-Karp Hashcode is too big\r\n                \r\nHow to deal with a big hashcode value in rolling hash Rabin-Karp algorithm ? I use modular arithmetic to avoid negative number, however there is a problem when the hashcode exceeds my modulo number (N = 83559671). I set my base number to be prime (the number to calculate hashcode) as well as the modulo number (really big), but it doesn't work with long string. Can anyone see the problem? \n\nHere is my code.\n\n```\n   public static void main(String [] args){\n\n       int P = 13;         // base\n       long M = 83559671;\n       long iHash = 0;    \n       String word = \"abcbadccaaaabbbb\";\n       int WINDOW = 9;\n\n       for(int i = 0; i < WINDOW; i++){\n            iHash = int_mod(int_mod(iHash*P, M) + word[i], M);\n       }\n\n       for(int i = WINDOW; i < word.length; i++){\n            iHash = int_mod(iHash - word[i-WINDOW] * get_pow(P, WINDOW-1, M), M);\n            iHash = int_mod(iHash * P, M);\n            iHash = int_mod(iHash + word[i], M);\n       }\n\n   }\n   public static long get_pow(int p, int t, long M){\n        long a = 1;\n        for(int i = 0 ; i < t; i++){\n              a = int_mod(a * p, M);\n        }\n        return a;\n   }\n\n   public static long int_mod(long a, long b){\n        return (a % b+ b) % b;\n   }\n```\n\n\nThe problem is when I have any string's length longer than 8 then the hashcode of the string exceeds the modulo number 83559671, and that leads to a wrong answer when I make a comparison. Any shorter strings work properly.\n    ", "Answer": "\r\nYou don't need to do the modulus at all.  Here's a demo:\n\n```\npublic class Foo {\n  private static int hash(String s) {\n    int hash = 0;\n    for (int i = 0; i < s.length(); i++) {\n      hash *= 31;\n      hash += s.charAt(i);\n    }\n    return hash;\n  }\n\n  public static void main(String[] args) {\n    String s1 = \"abcdefghij\";\n    String s2 = s1.substring(1) + \"k\";\n    int pow = 1;\n    for (int i = 0; i < s1.length(); i++) {\n      pow *= 31;\n    }\n    System.out.printf(\"hash(%s) = %d%n\", s1, hash(s1));\n    System.out.printf(\"hash(%s) = %d%n31 * hash(%s) - (31^%d * %s) + %s = %s%n\",\n        s2,\n        hash(s2),\n        s1,\n        s1.length(),\n        s1.charAt(0),\n        s2.charAt(s2.length() - 1),\n        31 * hash(s1) - (pow * s1.charAt(0)) + s2.charAt(s2.length() - 1));\n  }\n}\n```\n\n\nThis (correctly) prints out:\n\n```\nhash(abcdefghij) = -634317659\nhash(bcdefghijk) = 21611845\n31 * hash(abcdefghij) - (31^10 * a) + k = 21611845\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Uncaught ReferenceError: add is not defined in javascript code\r\n                \r\nI am writing modular javascript code. I wrote a basic calculator with two inputs and four buttons which performs arithmetic operations. When I run my it shows this error in console.\n\n```\nUncaught ReferenceError: add is not defined```\n\n\nThis happens for all buttons. How can I fix this and why it does not work?\n\nHere is my code\n    ", "Answer": "\r\nYou are mixing up variables and object properties. Javascript never implicitly looks up object properties - it's always a variable lookup with the exception of global object and ```\nwith```\n-statement.\n\nSo specify the object:\n\n```\n    calculation: function(operator) {\n        if(operator == 'add')\n            return this.add(valone, valtwo);\n        else if(operator == 'sub')\n            return this.sub(valone, valtwo);\n        else if(operator == 'mult')\n            return this.mult(valone, valtwo);\n        else\n            return this.div(valone, valtwo);\n    }\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Is it possible to output the permutations of 1,...,n using only iterators?\r\n                \r\nHere a couple of examples in a pseudocode to show what I mean.\n\nThis produces the combinations (selections disregarding order without repetition) of 1,...,n taking 3 at a time. \n\n```\nDo[Print[i,j,k], {i,1...n-2}, {j,i+1...n-1}, {k,j+1...n}]\n```\n\n\nThe loop works from left to right---for each i, the iterator j will go through its values and for each j, the iterator k will go through its. By adding more variables and changing n, we can generalize what we have above.\n\nQuestion: can we do the same for permutations? In other words, can we find a way to tweak the iterators to produce the P(n,k)=n!/(p-k)! permutations of 1,...,n? For k=3, \n\n```\nDo[Print[i,j,k], {i, f_1 , g_1(i,n)}, {j, f_2(i), g_2(i,j,n)}, {k, f_3(i,j), g_3(i,j,k,n)}]\n```\n\n\nUse only basic arithmetic operations and things like modular arithmetic, floor/ceiling fcns.\n\nBecause this might smell like a homework problem to you, I'd settle on an answer of \"yay\" or \"nay\"; your estimate of the difficulty level would be helpful to me as well.\n\nThank you.\n    ", "Answer": "\r\nDo you mean generating permutations iteratively, without recursion? Yes, it's possible:\n\nhttp://en.wikipedia.org/wiki/Permutation\n\nSee the section \"Algorithms to generate permutations\"\n\n```\n1. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\n2. Find the largest index l such that a[k] < a[l]. Since k + 1 is such an index, l is well defined and satisfies k < l.\n3. Swap a[k] with a[l].\n4. Reverse the sequence from a[k + 1] up to and including the final element a[n].\n```\n\n\nThis follows your restriction to only use basic arithmetic operations (if you don't like the swap, know that you can swap two numbers by using additions and subtractions).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "2D isometric engine - Math problems - Cube selection - diamond shape map\r\n                \r\nI calculate my coordinates when i create a layer with a ```\nstd::vector```\n, filled with ```\ncube```\n objects(wich is a class of mine):\n\n```\nfor(int J = 0; J < mapSize; J++)\n{\n    for(int I = 0; I < mapSize; I++)\n    {\n        x = (J - I) * (cubeSize/2);\n        y = (J + I) * (cubeSize/4);\n\n        c = new cube(cubeSize, x, y, z, I, J);\n        cs.push_back(*c);\n    }\n}\n```\n\n\nI wanna do this : ```\ncs[getCubeByID(mouseX, mouseY)].setTexture(...);```\n\n\nExample of use: The cube in ```\nI-J [0, 0]```\n have the ```\nnumber 0```\n in the cubes array. if i ```\nclick on 0,0```\n i got this number.\n\nEDIT:\nWe gave me the formula to get a J or a I with a pair of x,y in the comments, thanks a lot. I only need to convert this pair of I-J to the entry number of my array like the example i gave.\n\nI tried : ```\nint entry = (J - 1) * size + (I - 1);```\n and the selected cube is not so far from the one i want but still not the right formula. Modular arithmetic can fix my problem but i don't understand how it's working.\n    ", "Answer": "\r\nSo you have\n\n```\nx = (J - I) * (cubeSize/2);\ny = (J + I) * (cubeSize/4);\n```\n\n\nand you want to compute ```\nI```\n and ```\nJ```\n (and therefore the index which is ```\nI + J*mapSize```\n) from that, right? It's a linear system of two equations.\n\n```\nJ - I = x * 2 / cubeSize\nJ + I = y * 4 / cubeSize\n\nI = (y * 2 - x) / cubeSize\nJ = (y * 2 + x) / cubeSize\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Examples of Chinese Remainder Theorem being used to represent big numbers\r\n                \r\nIn Knuth's Art of Computer Programming, Chapter 4.3.2 (Vol. 2) is titled \"Modular Arithmetic\", and its focus is on how we can use modulo arithmetic to represent very large numbers, and then add, subtract and multiply them. If we do this cleverly, the Chinese Remainder Theorem means no information is lost in this process.\nHowever, I'm have trouble finding examples of this use in (recent) practice. I found a StackOverflow question which has the tantalizing comment: \"CRT-based representation is the internal representation for some of the Number-Theoretic Transform (NTT) based algorithms for multiplication\". So my question is therefore:\n\nWhich Number-Theoretic Transform (NTT) based algorithms for multiplication use a CRT-based internal representation?\n\nI'm a mathematician rather than a programmer, so I'm doing this because I am interested rather than because I have a specific application in mind. So any \"common\" systems which uses this, or anything generally interesting, would be appreciated.\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Permutation Cycles\r\n                \r\nI am working on an interesting permutation cycle problem. We know any permutation of numbers is made up of disjoint cycles of numbers. For example let's say our original permutation is 12345. After one cycle the permutation becomes 14235. So 1 ==> 1, 2==>3, 3==>4, 4==2, and 5==>5. So our disjoint cycles, are\n1, 234, and 5. Let's say we cycled like this 10^10 times. What is the end result? For example after one more cycle we get to 13425. I want to do this as efficiently as possible. Obviously we want to do modular arithmetic because there is a pattern, but how to write up this code in Java? Thanks\n    ", "Answer": "\r\nThe key here is to use your modular arithmetic insight on each disjoint cycle independently.\n\nFor your example, you can get the result of 10^10 cycles\n\n\nof the first disjoint cycle (1) trivially\nof the second disjoint cycle (234) by cycling it (10^10)%3 = 1 times\nof the third disjoint cycle (5) trivially\n\n\nThat just leaves finding the disjoint cycles, but that wasn't part of your question.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "time complexity for most programming language?\r\n                \r\nI read about time complexity modular arithmetic in many books . there is thing I don't understood .\nI read in some books the following\n\nFor any a mod N, a has a multiplicative inverse modulo N if\nand only if it is relatively prime to N. When this inverse exists, it can be found in time O(n^3) (where as usual n denotes the number of bits of N) by running the extended Euclid algorithm. \nMy question revolves around *extended Euclid algorithm* *is has O(n^3)*\n\nwhen I write in java integrated with netbeans or C# or C++ program this line \n\n```\nA = B.modInverse(N) //here by java syntax \n```\n\n\nIn general. Can I say usually this line has time complexity O(n^3).\n\nor necessary write the same steps extended Euclid algorithm.\n    ", "Answer": "\r\nUnless the documentation of the ```\nmodInverse```\n method makes an explicit guarantee about its time complexity, you generally can't make any assumptions about its running time. The implementation could be completely different depending on the runtime/library or even the version of the runtime.\n\nIf you have access to the source code, you can verify which algorithm is used. You can also run your own benchmarks for different input sizes and you'll get a pretty good picture about the asymptotic behavior of the concrete implementation.\n\nThat said, it's highly probable that popular libraries for arbitrary-precision arithmetic use the best known algorithms for basic operations like ```\nmodInverse```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Combine two \"dbl\" columns in a dataframe into a new column with unite()::tidyr return \"chr\"\r\n                \r\nI am working with flights data from nycflights13 package in R.\n\nI tried to convert dep_time and sched_dep_time column to convert them to a more convenient representation of time. This should be simple, but I am struggling with it.\n\nFirst I used Modular arithmetic and remainder inside the transmute::dplyr to break integers (dep_time and sched_dep_time) up into pieces  than used unite::tidyr . Like this:\n\n```\nflights %>% \n  transmute(dep_time,\n          hour = dep_time %/% 100,\n          minute = dep_time %% 100,\n          sched_dep_time,\n          hour2 = sched_dep_time %/% 100,\n          minute2 = sched_dep_time %% 100)%>%\n          unite(New_dep_time , hour,minute , sep =\":\") %>%\n          unite(New_sched_dep_time , hour2,minute2 , sep =\":\")\n```\n\n\nMy code returning result like this (return news columns New_dep_time and and New_sched_dep as chr):\n\n```\n# A tibble: 336,776 x 4\n   dep_time New_dep_time sched_dep_time New_sched_dep_time\n *    <int>        <chr>          <int>              <chr>\n 1      517         5:17            515               5:15\n 2      533         5:33            529               5:29\n 3      542         5:42            540               5:40\n 4      544         5:44            545               5:45\n 5      554         5:54            600                6:0\n 6      554         5:54            558               5:58\n 7      555         5:55            600                6:0\n 8      557         5:57            600                6:0\n 9      557         5:57            600                6:0\n10      558         5:58            600                6:0\n# ... with 336,766 more rows\n```\n\n\nI am wondering why unite function paste together two \"dbl\" columns (ex: hour and minute) into one column as \"chr\" (New_dep_time). Is there any way to implement hm() from lubridate inside unite to return New_dep_time and and New_sched_dep column as a time format?\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Getting TLE error in Kickstart Alarm challenge, Gooogle KickStart 2019\r\n                \r\nI'm trying to solve the Kickstart Alarm problem given in the Practice Round of the KickStart 2019.That can be found at https://codingcompetitions.withgoogle.com/kickstart/archive/2019\nDoing the math transformations, I got a generic expression that calculates the contribution of each element at the index \"i\" of the Parameter Array \"A\" of length \"N\" to the final result.\n\n```\n[A[i] * (N - i)] * [K + (2^1 + 2^2 + ... + 2^K) + ... + ((i+1)^1 + (i+1)^2 + ... + (i+1)^K)], when i > 0\nA[0] * N * K, otherwise\n```\n\n\nI used modular arithmetic over the modulus given by the challenge, 10^9 + 7, trying to optimize the calculations. Below is the solution implemented in Python 3.5 I tried.\n\n```\ndef generate_parameter_array(N, x, y, C, D, E1, E2, F):\n    array = [(x + y) % F]\n    for i in range(N - 1):\n        old_x = x\n        x = (C * x + D * y + E1) % F\n        y = (D * old_x + C * y + E2) % F\n        array.append((x + y) % F)\n    return array\n\ndef solution():\n    T = int(input())\n    mypow = pow\n    for t in range(1, T + 1):\n        test_case = [int(n) for n in input().split(\" \")]\n        N = test_case[0] # Length of the parameter array\n        K = test_case[1] # Number of exponential powers\n        A = generate_parameter_array(N, *(test_case[2:]))\n        result = 0\n        mod = 10**9 + 7\n        P_sum = K # accumulator of the geometric progressions\n        for i in range(1, N):\n            P_sum = (P_sum + ((mypow(i+1, K+1, mod) - (i+1)) * (mypow(i,mod-2,mod)))) % mod\n            result = (result + (((A[i] * (N - i)) % mod) * P_sum) % mod) % mod\n        result = (result + (((A[0] * N) % mod) * K) % mod) % mod\n        print('Case #{}: {}'.format(t, result))\n```\n\n\nThis solution exceeds the time limit of the challenge at the hidden test set, I'm getting the TLE error. Is there a way to optimize more this algorithm, or am I limited by Python? Please point out my mistakes. Thank you!\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Getting the GHC to accept type signature with KnownNat arithmetic\r\n                \r\nI have been trying to implement the Chinese Remainder Theorem, for the specific case of just two equations, using the Data.Modular package. The idea is that I can specify each equation with only one modular number (```\nx = a (mod m)```\n using the number ```\na (mod m)```\n). Here is my implementation.\n\n```\n{-# LANGUAGE DataKinds, ScopedTypeVariables, TypeOperators #-}\n\nimport GHC.TypeLits\nimport Data.Proxy (Proxy (..))\nimport Data.Modular\n\ncrt :: forall k1 k2 i. (KnownNat k1, KnownNat k2, Integral i) => i `Mod` k1 -> i `Mod` k2 -> i `Mod` (k1 * k2)\ncrt a1 a2 = toMod $ (unMod a1)*n2*(unMod n2') + (unMod a2)*n1*(unMod n1')\n  where n1 = getModulus a1 :: i\n        n2 = getModulus a2 :: i\n        n2' = inv $ (toMod n2 :: i `Mod` k1)\n        n1' = inv $ (toMod n1 :: i `Mod` k2)\n\n        getModulus :: forall n i j. (Integral i, Integral j, KnownNat n) => i `Mod` n -> j\n        getModulus x = fromInteger $ natVal (Proxy :: Proxy n)\n```\n\n\nI get the following error: ```\nCould not deduce (KnownNat (k1 * k2)) arising from a use of ‘toMod’```\n. However, shouldn't GHC be able to do the arithmetic for ```\nKnownNat (k1 * k2)```\n? Also, for some weird reason, it looks like if I had a constructor for the ```\nMod```\n type instead of the ```\ntoMod```\n function, everything would work. I fail to see how that should make a difference either...\n\nI am looking for any fix to help this compile, including whatever extensions. I would, however, like to not have to make my own version of Data.Modular if possible. (I think I could make this work inelegantly and clumsily by using the ```\nMod```\n constructor directly).\n    ", "Answer": "\r\nThe cheap, cheesy way to make this compile is to add ```\nFlexibleContexts```\n, then add ```\nKnownNat (k1 * k2)```\n to the context of ```\ncrt```\n. Once I did this, I could successfully call it in ghci:\n\n```\n> crt (3 :: Mod Integer 5) (5 :: Mod Integer 7)\n33\n```\n\n\nHave fun working out how to express ```\nCoprime k1 k2```\n as a constraint... ;-)\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "link cuda with gmp\r\n                \r\nI am trying to use cuda with the GNU multiple precision library (gmp). When I add gmp instructions like mpf_init() to my device code I get this compiler error: tlgmp.cu(37): error: calling a host function(\"__ gmpf_init\") from a __ device__ /__ global__ function(\"histo\") is not allowed.\n\nIs it possible to redefine gmp instructions so that they can can be used in device code?\n    ", "Answer": "\r\nThe GMP library is compiled for the host, and so it can't be used directly in device code.  That is the direct reason for the error you are seeing.\nSince it's an open-source library, it might be possible with some effort to go through the code and create your own version, that has appropriate ```\n__device__```\n decorators (and possibly other changes) to the various functions you need.  This would probably require a substantial amount of work, however.\nAnother alternative might be to investigate the CUMP library.\nAnother alternative might be to investigate the xmp library\nAnother alternative might be to investigate the campary library\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Find x in a^x = a (mod n)\r\n                \r\nI want to calculate am mod n, where n is a prime number, and m is very large. Rather doing this with binary power calculation, I'd like to find such x that ax = a (mod n) and then calculate a(m mod x) mod n. \n\nObviously such x exists for any a, because powers mod n loop at some point, but I didn't find out how to calculate it with modular arithmetics. I wonder if I missed something or maybe there exists some numerical method for that?\n    ", "Answer": "\r\nYour modulus is prime, that makes it easy to get a start, as by Fermat's (inappropriately dubbed \"little\") theorem, then\n\n```\na^n ≡ a (mod n)\n```\n\n\nfor all ```\na```\n. Equivalent is the formulation\n\n```\na^(n-1) ≡ 1 (mod n),  if n doesn't divide a.\n```\n\n\nThen you have\n\n```\na^m ≡ 0 (mod n) if a ≡ 0 (mod n) and m > 0\n```\n\n\nand\n\n```\na^m ≡ a^(m % (n-1)) (mod n) otherwise\n```\n\n\n(note that your suggested ```\na^(m % x)```\n is in general not correct, if ```\nm = q*x + r```\n, you'd have\n\n```\na^m ≡ (a^x)^q * a^r ≡ a^q * a^r ≡ a^(q+r) (mod n)\n```\n\n\nand you'd need to repeat that reduction for ```\nq+r```\n until you obtain an exponent smaller than ```\nx```\n).\n\nIf you are really interested in the smallest ```\nx > 1```\n such that ```\na^x ≡ a (mod n)```\n, again the case of ```\na ≡ 0 (mod n)```\n is trivial [```\nx = 2```\n], and for the other cases, let ```\ny = min { k > 0 : a^k ≡ 1 (mod n) }```\n, then the desired ```\nx = y+1```\n, and, since the units in the ring ```\nZ/(n)```\n form a (cyclic) group of order ```\nn-1```\n, we know that ```\ny```\n is a divisor of ```\nn-1```\n.\n\nIf you have the factorisation of ```\nn-1```\n, the divisors and hence candidates for ```\ny```\n are easily found and checked, so it isn't too much work to find ```\ny```\n then - but it usually is still far more work than computing ```\na^r (mod n)```\n for one single ```\n0 <= r < n-1```\n.\n\nFinding the factorisation of ```\nn-1```\n can be trivial (e.g. for Fermat primes), but it can also be very hard. In addition to the fact that finding the exact period of ```\na```\n modulo ```\nn```\n is usually far more work than just computing ```\na^r (mod n)```\n for some ```\n0 <= r < n-1```\n, that makes it very doubtful whether it's worth even attempting to reduce the exponent further.\n\nGenerally, when the modulus is not a prime, the case when ```\ngcd(a,n) = 1```\n is analogous, with ```\nn-1```\n replaced by ```\nλ(n)```\n [where ```\nλ```\n is the Carmichael function, which yields the smallest exponent of the group of units of ```\nZ/(n)```\n; for primes ```\nn```\n, we have ```\nλ(n) = n-1```\n].\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why not always use circular array deques instead of array lists?\r\n                \r\nAlmost all programming languages have some implementation of a list that uses a dynamic array, which automatically expands when it reaches a certain capacity. For example, Java has ```\nArrayList```\n, and C++ has ```\nstd::vector```\n.\n\nRecently I learned about circular array deques, which are also implemented using dynamic arrays. They keep track of the starting index of the list, and use modular arithmetic to access elements. Like array lists, they allow O(1) lookup and O(1) insertion at the end, and space proportional to O(N). However, they also allow O(1) insertion at the beginning. \n\n(While Java's ```\nArrayDeque```\n implements this data structure, it doesn't allow lookup of elements. C++'s ```\nstd::deque```\n appears to use a different implementation.)\n\nIf these array deques have the same or better performance characteristics as array lists, then why not always use them as the default implementation for lists?\n    ", "Answer": "\r\nIf you don't need insertion at the head of the list, then a circular deque gives unnecessary overhead, e.g. for indexed methods.  In a circular deque, accessing index i requires adding i to the index of the head element and looping around (e.g. using modulo, or bitwise operators) before accessing the underlying array, whereas with a vanilla vector, no manipulation to i is necessary before accessing the underlying array.\n\nTo demonstrate this overhead, a typical deque implementation might look like:\n\n```\ntemplate <typename T>\nclass Deque {\n  private:\n    T* array; // The underlying array, holding elements of the deque.\n    int size; // The number of elements held by the deque.\n    int capacity; // The size of array ** must be a power of two **.\n    int head; // The index of the head element within array.\n\n  public:\n    T& operator[](int index) {\n        // Notice the calculation required before accessing array.\n        return array[(head + index) & (capacity - 1)]\n    }\n};\n```\n\n\nIn addition, if you require access to the underlying array where your elements are contiguous beginning at index 0, a deque would not deliver.\n\nSee question Why would I prefer using vector to deque, which is very similar to yours.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Scala path-dependent type: testing for type error [duplicate]\r\n                    \r\n            \r\n        \r\n            \r\n                \r\n                    \r\n                            \r\n                                This question already has answers here:\r\n                                \r\n                            \r\n                    \r\n                \r\n            \r\n                    \r\n                        How do I write a scala unit test that ensures compliation fails?\r\n                            \r\n                                (3 answers)\r\n                            \r\n                    \r\n                Closed 8 years ago.\r\n        \r\n\r\n\r\n    \r\n\r\nI've written some Scala to work with modular arithmetic using path dependent types. The parent class represents a group modulo some integer, and the inner class represents elements of this group.\n\n```\nclass ModularInt( modulus : Int ) {\n  case class Value( value: Int ) {\n    def plus( a: Value ) : Value = {\n      val rem: Int = (value + a.toInt) % modulus\n      if( rem < 0 )\n        Value(modulus + rem)\n      else\n        Value(rem)\n    }\n\n    def toInt = value\n  }\n}\n```\n\n\nThis seems to work correctly (e.g. modulo 7: 6 + 2 = 1).\n\nA nice side effect of using path-dependent types is that numbers modulo different integers will throw a type error if you try to operate them together. However, I would like to insert a test that will confirm this fact.\n\n```\nimport org.scalatest.FunSuite\nimport org.junit.runner.RunWith\nimport org.scalatest.junit.JUnitRunner\n\n@RunWith(classOf[JUnitRunner])\nclass ModularIntSuite extends FunSuite {\n  test(\"a mod n + b mod m => error\") {\n    val n: Int = 3\n    val m: Int = 4\n    val modulen = new ModularInt( n )\n    val modulem = new ModularInt( m )\n\n    val a = new modulen.Value(0)\n    val b = new modulem.Value(0)\n\n    assert(a plus b) // catch error here\n  }\n}\n```\n\n\nHowever, as ```\na plus b```\n throws a type error at compile time, the test won't even run.\n\nIs there anyway to insert a test for a compile error? Or does the fact that compile errors are tests of correctness themselves mean that this is a redundant check (i.e. what I'm trying to do makes no sense)?\n\nThanks\n    ", "Answer": "\r\nThe test is redundant. One of the advantages of a strong type system is precisely this, that if you design your types correctly the code won't even compile.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Spring Batch Multithreaded DB Reader\r\n                \r\nIf I understand correctly spring-batch's reader mechanics doesn't provide a mechanism for multithreading in the reader step. I've been playing around with some ideas around using modular arithmetic on the primary key of a database as a partitioning mechanism for multithreading the query. My questions are two fold:\n\n(1) Have I missed something in the ability to run multiple threads during the reader step, particularly in regards to making database queries?\n\n(2) If I come up with a good solution would it be worth opening a Jira for this and submitting it back to the spring-batch codebase? Clearly https://github.com/spring-projects/spring-batch/blob/master/CONTRIBUTING.md would be the starting place, but the Spring guys seem to not have an apparent mailing list for communication. So I figured that I would ask the question before opening a ticket.  \n    ", "Answer": "\r\nThis can be done easily by adding a column called STATUS to your table to track the status of the records that are processed. Initially when you load data to your table, set the status as 'NOT PROCESSED' and when your ItemReader reads the chunk of records set the status to 'IN PROGRESS'. Once your ItemProcessor or ItemWriter completes its processing, change the status from 'IN PROGRESS' to 'PROCESSED'. Make sure to make the method which fetches the data from the database as 'synchronized'. This will make sure multiple threads not to fetch the same data from database. \n\n```\npublic List<DomainObject> read(){\n  return fetchDataFromDb();\n}\n\nprivate synchronized List<DomainObject> fetchProductAssociationData(){\n  //read your chunk-size of records from database which has status as 'NOT PROCESSED' \n  and change the status of the data which is read to 'IN PROGRESS'\n  return list;\n}\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Best way to iterate through unknown number of lists in general?\r\n                \r\nGiven a programming language that supports iteration through lists i.e.\n\n```\nfor element in list do\n    ...\n```\n\n\nIf we have a program that takes a dynamic number of lists as input, ```\nlist[1] ... list[n]```\n (where ```\nn```\n can take any value), what is the best way to iterate through every combination of elements in these lists?\n\ne.g. ```\nlist[1] = [1,2]```\n, ```\nlist[2] = [1,3]```\n then we iterate through ```\n[[1,1], [1,3], [2,1], [2,3]]```\n.\n\nMy ideas that I don't think are very good:\n\n1) Create a big product of these lists into ```\nlist_product```\n (e.g. in Python you could use ```\nitertools.product()```\n multiple times) and then iterate over ```\nlist_product```\n. Problem is that this requires us to store a (potentially huge) iterable.\n\n2) Find the product of the length of all the lists, total_length and do something along the lines of the following by using a modular arithmetic type idea.\n\n```\nlen_lists = [len(list[i]) for i in [1..n]]\ntotal_length = Product(len_lists)\nfor i in [1 ... total_length] do\n    total = i-1\n    list_index = [1...n]\n    for j in [n ... 1] do\n        list_index[j] = IntegerPartOf(total / Product([1:j-1]))\n        total = RemainderOf(total / Product([1:j-1]))\n    od\n    print list_index\nod\n```\n\n\nwhere the ```\nlist_index```\n are then printed for all different combinations.\n\nIs there a better way with regards to speed (don't care so much about readability)?\n    ", "Answer": "\r\n\n  1) Create a big product of these lists into list_product (e.g. in Python you could use itertools.product() multiple times) and then iterate over list_product. Problem is that this requires us to store a (potentially huge) iterable.\n\n\nThe point of ```\nitertools```\n (and iterators in general) is that they do not construct their entire result at once, but create and return terms from the result one at a time. So if you have a list of lists ```\nListOfLists```\n and you want all tuples containing one element from each list in it, do use \n\n```\nfor elt in itertools.product(*ListOfLists):\n   ...\n```\n\n\nNote that you only need to call ```\nproduct```\n once. It's simple and efficient. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "2 different ways to reverse an integer's digits - preferred way?\r\n                \r\nI'm grinding some LeetCode stuff, and one of the problems was to reverse an integer's digits (e.g. 123 becomes 321).\n\nI thought of 2 ways to do it. The first is purely \"numeric\", using powers of 10 and modular arithmetic:\n\n```\ndef reverse_digits1(num):\n    reversed_num = 0\n\n    while num > 0:\n        reversed_num *= 10\n        reversed_num += num % 10\n        num = num // 10\n\n    return reversed_num\n```\n\n\nThe second way is to use built-in ```\nstr()```\n and ```\nint()```\n methods.\n\n```\ndef reverse_digits2(num):\n    num = str(num)\n\n    return int(num[::-1])\n```\n\n\nYou essentially convert it to a string, reverse it, then return the reversed string as an integer.\n\nBetween these 2, which is the \"better\" way to do it? I'm guessing it's the first one, and it doesn't involve mutating numbers into strings and vice versa, and there is no potential loss of information? Would there even be a loss of information? The inputs are all integers, so there's no floating point numbers to worry about, right? \n\nIn general, is it a good idea to work with numbers through ```\nstr()```\n and ```\nint()```\n, or should you just stick to \"numerical methods\"?\n    ", "Answer": "\r\nI added negatives just in case you may need them but the overall performance wouldn't change drastically without them either. \n\n```\ndef reverse_digits1(num):\n    if num < 0:\n        neg = True\n    else:\n        neg = False\n\n    if neg:\n        num *= -1\n\n    reversed_num = 0\n\n    while num > 0:\n        reversed_num *= 10\n        reversed_num += num % 10\n        num = num // 10\n\n    if neg:\n        reversed_num *= -1\n\n    return reversed_num\n\n\ndef reverse_digits2(num):\n    num = str(num)[::-1]\n    if num.endswith('-'):\n        num = '-' + num[:-1]\n\n    return int(num)\n\n\nfrom timeit import timeit as _t\n\ntimeit = lambda x: print(_t(x, globals=globals()))\n\ntimeit(\"reverse_digits1(123456789)\")\ntimeit(\"reverse_digits1(-123456789)\")\ntimeit(\"reverse_digits2(123456789)\")\ntimeit(\"reverse_digits2(-123456789)\")\n```\n\n\nThis result in \n\n```\n5.207313711074936\n6.272431325012982\n2.453335871448827\n3.285427497418125\n```\n\n\nSo other than being more readable* it actually is also faster. \n\nAs of the information loss, I can't imagine it being possible with your regular integers,\nand even if it was floats or some other type of number, strings would be more reliable since as a very basic example, 0.1+02 == 0.300000000000001, in strings however you can manipulate them with certain precision. \n\n*Keep in mind, code is written to be read by humans. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "On Undefined Behavior\r\n                \r\nGenerally, UB is regarded as being something that has to be avoided, and the current C standard itself lists quite a few examples in appendix J.\n\nHowever, there are cases where I can see no harm in exploiting UB other than sacrificing portability.\n\nConsider the following definition:\n\n```\nint a = INT_MAX + 1;\n```\n\n\nEvaluating this expression leads to UB. However, if my program is intended to run on a, say,  32-bit CPU with modular arithmetic representing values in Two's Complement, I'm inclined to believe that I can predict the outcome.\n\nIn my opinion, UB is sometimes just the C standard's way of telling me: \"I hope you know what you're doing, because we can't make any guarantees on what will happen.\"\n\nHence my question: is it safe to sometimes rely on machine-dependent behavior, even if the C standard considers it to invoke UB, or is \"UB\" really to be avoided, no matter what the circumstances are?\n    ", "Answer": "\r\nNo, unless you're also keeping your compiler the same and your compiler documentation defines the otherwise undefined behavior.\nUndefined behavior means that your compiler can ignore your code for any reason, making things true that you don't think should be.\nSometimes this is for optimization, and sometimes it's because of architecture restrictions like this.\n\nI suggest you read this, which addresses your exact example. An excerpt:\n\nSigned integer overflow:\nIf arithmetic on an ```\nint```\n type (for example) overflows, the result is undefined. One example is that ```\nINT_MAX + 1```\n is not guaranteed to be ```\nINT_MIN```\n. This behavior enables certain classes of optimizations that are important for some code.\nFor example, knowing that ```\nINT_MAX + 1```\n is undefined allows optimizing ```\nX + 1 > X```\n to ```\ntrue```\n. Knowing the multiplication \"cannot\" overflow (because doing so would be undefined) allows optimizing ```\nX * 2 / 2```\n to ```\nX```\n. While these may seem trivial, these sorts of things are commonly exposed by inlining and macro expansion. A more important optimization that this allows is for ```\n<=```\n loops like this:\n```\nfor (i = 0; i <= N; ++i) { ... }\n```\n\nIn this loop, the compiler can assume that the loop will iterate exactly ```\nN + 1```\n times if ```\ni```\n is undefined on overflow, which allows a broad range of loop optimizations to kick in. On the other hand, if the variable is defined to wrap around on overflow, then the compiler must assume that the loop is possibly infinite (which happens if ```\nN```\n is ```\nINT_MAX```\n) - which then disables these important loop optimizations. This particularly affects 64-bit platforms since so much code uses ```\nint```\n as induction variables.\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "addition with fixed min/max value\r\n                \r\nmajor edit: 100% solved! it's called Modular arithmetic thanks Peter!!\n\ni need to add two numbers with a fixed min/max value.\ni want my numbers behave like java's int/byte/short (overflowing to its opposite value and continuing the operation)\n\n```\nSystem.out.println((byte) (Byte.MAX_VALUE));    // 127\nSystem.out.println((byte)(Byte.MAX_VALUE + 1)); // -128\nSystem.out.println((byte)(Byte.MAX_VALUE + 2)); // -127\nSystem.out.println((byte)(Byte.MAX_VALUE + 3)); // -126\n```\n\n\nbut with a fixed .MAX_VALUE and .MIN_VALUE.  if a number's value is 3 and it's maxValue is 5 and minValue is 2, then when i add 4 to it (3+4=should be 7) it overflows \nso 3+4: 3 -> 4 -> 5 -> 2 -> 3\nexample:\n\n```\n    int value = 0, minValue = -2, maxValue = 1;\n    MyNumber n = new MyNumber(value, minValue, maxValue);\n\n    // possible values: -2 -1  0  1 -2 -1  0  1 -2 -1  0  1 ..\n\n    n.add(2);   // 0+2 = -2\n    n.add(-2);  // -2-2 = 0\n    n.add(5);   // 0+5 = 1       \n    n.add(-5);  // 1-5 = 0       \n    n.add(-5);  // 0-5 = -1       \n    n.add(-1);  // -1-1 = -2       \n    n.add(11);  // -2+11 = 1\n```\n\n\nthis is what i did:\n\n```\nclass MyNumber {\n\n    int value;\n    final int minValue, maxValue;\n\n    public MyNumber(int value, int minValue, int maxValue) {\n        if (value < minValue || value > maxValue || maxValue < minValue) {\n            throw new RuntimeException();\n        }\n        this.value = value;\n        this.minValue = minValue;\n        this.maxValue = maxValue;\n    }\n\n    void add(int amount) {\n        int step = 1;\n        if (amount < 0) {\n            step = -1;\n            amount = -amount;\n        }\n        while (amount-- > 0) {\n            value += step;\n            if (value < minValue)\n                value = maxValue; // overflows\n            if (value > maxValue)\n                value = minValue; // overflows\n        }\n    }\n}\n```\n\n\nit works but i don't want to iterate the whole addition since i'm going to work with big numbers\ni think it has something to do with MOD... (i am terrible at maths)\nnearly randomly i made this:\n\n```\nvoid add(int amount) {\n    value = (value + amount) % (maxValue - minValue + 1);\n}\n```\n\n\ni was so close but it fails at     \n\n```\nn = new MyNumber(-2, -4, -1);\nn.add(2); // -2+2 shows 0 instead of -4   (-2.. -1.. *overflow*.. -4)\n```\n\n\ni surrender\n    ", "Answer": "\r\nI would try to make things as clear as possible. e.g\n\nIf you want clock arithmetic you can do\n\n```\n   // in the constructor\n   this.range = maxValue - minValue + 1;\n   this.value = -minValue;\n\n   // in the adder.\n   public void add(int num) {\n       value = (value + num) % range;\n       if(value < 0) value += range;\n       // or\n       value = ((value + num) % range + range) % range;\n   }\n\n\n   // add a getter for value.\n   public int getValue() { return value + minValue; };\n```\n\n\n\n\nIf you wanted bounded arithmetic.\n\n```\n    value = Math.min(maxValue, Math.max(minValue, value + step));\n```\n\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Is there any best way(math / C++ trick) of Iterate through forward and reverse within a give range\r\n                \r\nUsing modular arithmetic (or) (%) operator in C++ we can cycle through the successive numbers with a range. \n\nFor example: \n\nif range is 5 (or) modulo 5 then\nwe can cycle through\n\n0 1 2 3 4 0 (5) 1(6) 2(7) 3(8) 4(9) 0(10)............0 1 2 3 etc.\n\nQuestion:\n\nIn the similar sense is there any arithmetical relation / C++ trick we can use to move increasing numbers in forward(till upper bound) and decreasing numbers in reverse direction(till lower bound or 0) with a range.\n\nFor example: \n\nif range = 5 then\n\n0 1 2 3 4 3 2 1 0 1 2 3 4 3 2 1 0.....................0 1 2 3 etc.\n\nIn the below program I used two approaches to iterate forward/reverse within a given range.\n\nBut I'm interested in- Is there any best way (C++ trick/Mathematical relation) of iterate through forward and reverse within a given range ?.\n\n```\n#include<iostream>\nint main() {\n    int range = 5;\n\n    // 0 1 2 3 4 0 1 2 3 4 .....(Cycle through in the range 0 - 4)\n    int i = 0;\n    while(true) {\n        // 0 1 2 3 4 0 1 2 3 4 .....(cycle through in the range 0 - 4)\n        std::cout<< i; \n        i = (i+1)% range; // Modulo\n        // some break condition\n    }\n\n    // 0 1 2 3 4 3 2 1 0 .......... (Forward and Reverse in the range 0 - 4)\n    // Method 1:\n    int j = 0;\n    bool reverse = false;\n    while(true) {\n        if(reverse == false) {\n            if(j < range) {\n                std::cout << j;\n                j = j+1;\n            }\n            else {\n                reverse = true;\n                j = j-1;\n            }\n        }\n        else {\n            j = j-1;\n            std::cout << j;\n            if(j == 0) {\n                reverse = false;\n                j = j + 1;\n            }\n        }\n        // some break condition\n    }\n\n    // 0 1 2 3 4 3 2 1 0 .......... (Forward and Reverse in the range 0 - 4)\n    // Method 2: \n    // Using modulo (if the range is big value then this is not good approach)\n    int limit[8] = {0,1,2,3,4,3,2,1};\n    int k = 0;\n    while(true) {\n        std::cout<< limit[k];\n        k = (k+1)%8;\n        // some break condition\n    }\n    return 0;\n}\n```\n\n    ", "Answer": "\r\nYou can use the absolute value function like this:\n\n```\nint i = range;\nint a = range;\nwhile(true) {\n// 0 1 2 3 4 3 2 1 0 .......... (Forward and Reverse in the range 0 - 4)\n    a = abs(i-range);\n    std::cout<< a; \n    i = (i+1)%(range*2); // Modulo\n}\n```\n\n\nBasically, you double the range, subtract half the range (so it goes from -range to +range), then take absolute value. \n\nEDIT: fixed code to start from zero instead of range.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Best way to feed which(,arr.ind=T) back into matrix in R?\r\n                \r\nI have extracted the array indeces of some elements I want to look at as follows:\n```\nmat = matrix(0,10,10)\n\narrInd = which(mat ==0,arr.ind = T)\n```\n\nThen I do some more operations on this matrix and eventually end up with a vector or rows ```\nrowInd```\n and a vector of columns ```\ncolInd```\n. I want us these indeces to insert values into another matrix, say mat2. But I can't seem to figure out a way to do this without looping or doing the modular arithmetic calculation myself. I realize I could take something like\n```\nmat2[rowInd*(colInd-1)+rowInd]\n```\n\nIn order to transform back to the 1-d indexing. But since R usually has built in functions to do this sort of thing, I was wondering if there is any more concise way to do this? It would just seem natural that such a handy data-manipulation  function like ```\nwhich(,arr.ind=T)```\n would have a handy inverse.\nI also tried using ```\nmat2[rowInd,colInd]```\n, but this did not work.\n    ", "Answer": "\r\nHave a read on R intro: indexing a matrix on the use of matrix indexing. ```\nwhich(, arr.ind = TRUE)```\n returns a two column matrix suitable for direct use of matrix indexing. For example:\n\n```\nA <- matrix(c(1L,2L,2L,1L), 2)\niv <- which(A == 1L, arr.ind = TRUE)\n\n#     row col\n#[1,]   1   1\n#[2,]   2   2\n\nA[iv]\n# [1] 1 1\n```\n\n\nIf you have another matrix ```\nB```\n which you want to update values according to ```\niv```\n, just do\n\n```\nB[iv] <- replacement\n```\n\n\nMaybe for some reason you've separated row index and column index into ```\nrowInd```\n and ```\ncolInd```\n. In that case, just use\n\n```\ncbind(rowInd, colInd)\n```\n\n\nas indexing matrix.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Integer arithmetic when overflow exists\r\n                \r\nTwo 32 bit integer values A and B, are processed to give the 32 bit integers C and D as per the following rules. Which of the rule(s) is(are) reversible?\ni.e.  is it possible to obtain A and B given c and D in all condition?\n\nA.   C = (int32)(A+B), D = (int32)(A-B)\n\nB.   C = (int32)(A+B),  D= (int32)((A-B)>>1)\n\nC.   C = (int32)(A+B),  D = B\n\nD.   C = (int32)(A+B), D = (int32)(A+2*B)\n\nE.   C = (int32)(A*B),  D = (int32)(A/B)\n\nA few questions about the integer arithmetic. Modular addition forms amathematical structure known as an abelian group. How about signed addition? It's also commutative (that’s where the “abelian” part comes in) and associative, is this forms a n an abelian group?\n\nGiven that integer addition is commutative and associative, C is apparently true, because we can retrieve A by (A+(B-B)). What about D? Can we assume that ```\n2 * B = B + B```\n st. ```\nB = A+B+B-(A+B)```\n?\n\nAnd multiplication is more complicated, but I know that it can not be retrieve A if there is an overflow.\n    ", "Answer": "\r\nThis is a quote from 5 [expr] paragraph 4:\n\n\n  If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.\n\n\nWhat makes overflow for unsigned integers work is defined in 3.9.1 [basic.fundamental] paragraph 4:\n\n\n  Unsigned integers shall obey the laws of arithmetic modulo 2n where n is the number of bits in the value representation of that particular size of integer.\n\n\nBasically this says that you shall not overflow when using signed integer arithmetic. If you do, all bets are off. This implies that signed integers do not form an Abelian group in C++.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Creating a sphere packing nearest neighbor list from integers\r\n                \r\nI'm trying to construct a nearest neighbor list in python that stores the nearest neighbors of a node in a finite 3d hexagonal-closest packing (HCP) lattice. I've done this already with a 2d square lattice defining the structure like so. I don't want coordinates, but just a quick way to create a nearest neighbor list for an HCP out of a list of integers. Below is the sample code of how I did this task with a square lattice. \n\n```\nN = int #number of nodes\nL = side # a 32x32 graph, L would be 32\n\nfor i in range(N):\n\n    nearNeighbor[i][0] = (i + 1 ) % N\n    nearNeighbor[i][1] = (i + (N - 1)) % N\n    nearNeighbor[i][2] = (i + L) % N\n    nearNeighbor[i][3] = (i + N - L) % N\n\n    if (i-L < 0):\n         nearNeighbor[i][3] = -2\n    if (i+L >= N):\n         nearNeighbor[i][2] = -2\n    if (i%L) == 0:\n         nearNeighbor[i][1] = -2     \n    if ((i+1)%L) == 0:\n         nearN[eighbori][0] = -2\n```\n\n\nThat's it. Now an HCP lattice, when visualized, resembles a giant cube of spheres closely packed together. Each node should have at most 12 nearest neighbors and they should come out to make something like a cube. I guess largely I want to know how to use integers and modular arithmetic to represent the HCP lattice like I did with the square lattice. Can you help me stack?\n    ", "Answer": "\r\nThe answer to this question depends on how one chooses to truncate the HCP lattice and index it. One choice is\n\n\n\n\nWith this choice, the following code will return a list of neighbors of a given site.\n\n```\ndef neighbors(i, W, H, D):\n  A = W * H\n\n  plane = i / A\n  plane_index = i % A\n  row = plane_index / W\n  col = plane_index % W\n\n  r = -1 if row % 2 else 1   # (-1)**row\n  p = -1 if plane % 2 else 1 # (-1)**plane\n\n  nbors = []\n\n  # first include neighbors in same plane\n  if col != W-1: nbors.append(i+1)\n  if col != 0:   nbors.append(i-1)\n  if row != H-1: nbors.append(i+W)\n  if row != 0:   nbors.append(i-W)\n  if (col != 0 or r > 0) and (col != W-1 or r < 0):\n    if row != H-1: nbors.append(i+W+r)\n    if row != 0:   nbors.append(i-W+r)\n\n  # now add neighbors from other planes\n  if plane != D-1: nbors.append(i+A)\n  if plane != 0:   nbors.append(i-A)\n\n  if (col != 0 or p < 0) and (col != W-1 or p > 0):\n    if plane != D-1: nbors.append(i+A-p)\n    if plane != 0:   nbors.append(i-A-p)\n\n  if ((col != W - 1 or p > 0 or r < 0) and\n      (col != 0 or p < 0 or r > 0) and\n      (row != H-1 or p < 0) and\n      (row != 0 or p > 0)):\n    if plane != D-1:\n      nbors.append(i + A + p*W + (r-p)/2) #10\n    if plane != 0:\n      nbors.append(i - A + p*W + (r-p)/2) #11\n\n  return nbors\n```\n\n\nTo make sure I got the logic correct, I used the following test while writing the above function\n\n```\ndef test_neighbors():\n  n = lambda i: set(neighbors(i, 5, 5, 5))\n\n  # test bottom layer\n  assert n(0) == set([1,5,6,25,30])\n  assert n(2) == set([1,3,7,8,26,27,32])\n  assert n(4) == set([3,9,28,29,34])\n  assert n(5) == set([0,6,10,30])\n  assert n(9) == set([3,4,8,13,14,33,34,38])\n  assert n(20) == set([15,16,21,45])\n  assert n(21) == set([16,17,20,22,45,46])\n  assert n(24) == set([19,23,48,49])\n\n  # test second layer\n  assert n(25) == set([0,1,26,30,31,50,51])\n  assert n(34) == set([4,9,28,29,33,38,39,54,59])\n  assert n(36) == set([7,11,12,31,32,35,37,41,42,57,61,62])\n  assert n(49) == set([24,44,48,74])\n```\n\n\nNote that the test doesn't cover all of the unique types of sites, so, there may still be a corner case somewhere that is wrong.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How do you mitigate proposal-number overflow attacks in Byzantine Paxos?\r\n                \r\nI've been doing a lot of research into Paxos recently, and one thing I've always wondered about, I'm not seeing any answers to, which means I have to ask.\n\nPaxos includes an increasing proposal number (and possibly also a separate round number, depending on who wrote the paper you're reading). And of course, two would-be leaders can get into duels where each tries to out-increment the other in a vicious cycle. But as I'm working in a Byzantine, P2P environment, it makes me what to do about proposers that would attempt to set the proposal number extremely high - for example, the maximum 32-bit or 64-bit word.\n\nHow should a language-agnostic, platform-agnostic Paxos-based protocol deal with integer maximums for proposal number and/or round number? Especially intentional/malicious cases, which make the modular-arithmetic approach of overflowing back to 0 a bit unattractive?\n    ", "Answer": "\r\nFrom what I've read, I think this is still an open question that isn't addressed in literature.\n\nByzantine Proposer Fast Paxos addresses denial of service, but only of the sort that would delay message sending through attacks not related to flooding with incrementing (proposal) counters.\n\nHaving said that, integer overflow is probably the least of your problems. Instead of thinking about integer overflow, you might want to consider membership attacks first (via DoS). Learning about membership after consensus from several nodes may be a viable strategy, but probably still vulnerable to Sybil attacks at some level.\n\nAnother strategy may be to incorporate some proof-of-work system for proposals to limit the flood of requests. However, it's difficult to know what to use this as a metric to balance against (for example, free currency when you mine the block chain in Bitcoin). It really depends on what type of system you're trying to build. You should consider the value of information in your system, then create a proof of work system that requires slightly more cost to circumvent.\n\nHowever, once you have the ability to slow down a proposal counter, you still need to worry about integer maximums in any system with a high number of (valid) operations. You should have a strategy for number wrapping or a multiple precision scheme in place where you can clearly determine how many years/decades your network can run without encountering trouble without blowing out a fixed precision counter. If you can determine that your system will run for 100 years (or whatever) without blowing out your fixed precision counter, even with malicious entities, then you can choose to simplify things.\n\nOn another (important) note, the system model used in most papers doesn't reflect everything that makes a real-life implementation practical (Raft is a nice exception to this). If anything, some authors are guilty of creating a system model that is designed to avoid a hard problem that they haven't found an answer to. So, if someone says that X will solve everything, please be aware they they only mean that it solves everything in the very specific system model that they defined. On the other side of this, you should consider that the system model is closely tied to a statement that says \"Y is impossible\". A nice example to explain this concept is the completely asynchronous message passing of the Ben-Or consensus algorithm which uses nondeterminism in the system model's state machine to avoid the limits specified by the FLP impossibility result (which specifies that consensus requires partially asynchronous message passing when the system model's state machine is deterministic).\n\nSo, you should continue to consider the \"impossible\" after you read a proof that says it can't be done. Nancy Lynch did a nice writeup on this concept.\n\nI guess what I'm really saying is that a good solution to your question doesn't really exist yet. If you figure it out, please publish it (or let me know if you find an existing paper).\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Treating an array of structs containing `x` as an array of `x`\r\n                \r\nSuppose I have an array ```\na```\n of struct ```\nS```\n that includes member ```\nx```\n.\nI also have a function ```\nf```\n that accepts an array of ```\nx```\n (without the struct).\n```\n//file1\nstruct S {\n    int x;\n    //other members...\n};\n\nS s[1000];\n\n//file2\nvoid f(int x[]);\n```\n\nI could modify ```\nf```\n to accept an array of ```\nS```\n, but this pattern is making my code less modular as I have to propagate the definiton of ```\nS```\n, and making my functions less generic. I could loop over ```\na```\n and copy each ```\nx```\n to a new array, but ```\na```\n might be large. Is there a way to keep modularity and efficiency?\nFor instance, maybe ```\nf```\n could also accept the size of the struct and use it for pointer arithmetic, therefore treating an array of arbitrary structs that contain ```\nx```\n as an actual array of ```\nx```\n?\n    ", "Answer": "\r\n\nIs there a way to keep modularity and efficiency?\n\nThere is a way: Templates.\nSince modifying ```\nf```\n seems to be an option, you can achieve your goal by making it a function template. It could accept any range of integers. You can then adapt the array of ```\nS```\n to pass it into ```\nf```\n.\nExample:\n```\ntemplate<class Range>\nvoid f(Range&& x);\n\n// usage\nvoid example()\n{\n    // using with s\n    auto s_to_int = [](S s) { return s.x; };\n    f(std::views::all(s) | std::views::transform(s_to_int));\n\n    // using with an array of integers\n    int arr[] = {1, 2, 3};\n    f(arr);\n}\n```\n\n\n\nS contains a timestamp and datapoint, and f is a component of a Discrete Fourier Transform that operates a vector of datapoints.\n\nIf you're going to do numerical operations on the array of S, then this seems inefficient.\nYou're likely better off by using an array of data points, and a separate array of timestamps where the indices of each array correspond to each other.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "How to create a typesafe range-limited numeric type?\r\n                \r\nIn Rust, I have need of a numeric type with the property of having a domain symmetric around 0. If a number n is a valid value, then the number -n must also be valid. How would I ensure type-safety during initialization and arithmetic? How would it be best to implement modular and saturation arithmetic on the type?\n\n\n\nThe simplest example of the problem is:\n\n```\ntype MyNumber = i8; // Bound to domain (-100, 100)\n\nfn main() {\n    let a = MyNumber(128); // Doesn't panic when 128 > 100\n}\n```\n\n\n\n\nThere are a few considerations to make, and I've attempted different solutions. I'll avoid generic programming for the examples of them below:\n\n\nBasing the type off enum ensures that only valid values are possible values. This becomes messy very fast:\n\n```\nenum MyNumber {\n    One,\n    Two,\n    ...\n}\nimpl MyNumber {\n    fn convert(i8) -> MyNumber {\n        match {\n            1 => MyNumber::One,\n            2 => MyNumber::Two,\n            ...\n        }\n    }\n}\n```\n\nExpose a method which checks parameters before setting the fields, the textbook associated function. This doesn't prevent assigning using the struct constructor.\nValidate operands (and forcibly rectify them) whenever an operation occurs. This seems reasonable, but requires each method to repeat the validation code.\n\n```\nextern crate num;\n\nuse num::Bounded;\nuse std::cmp;\nstruct MyNumber {\n    val: i8,\n}\n\nimpl Bounded for MyNumber {\n    fn max_value() -> Self {\n        MyNumber { val: 65 }\n    }\n    fn min_value() -> Self {\n        MyNumber { val: -50 }\n    }\n}\nimpl MyNumber {\n    fn clamp(&mut self) {\n        self.val = cmp::min(MyNumber::max_value().val, \n                            cmp::max(MyNumber::min_value().val, self.val))\n    }\n    fn add(&mut self, mut addend: Self) {\n        self.clamp();\n        addend.clamp(); \n        //TODO: wrap or saturate result\n        self.val = self.val + addend.val\n    }\n}\n\nfn main() {\n    let mut a = MyNumber { val: i8::max_value() };\n    let b = MyNumber { val: i8::min_value() };\n    a.add(b);\n    println!(\"{} + {} = {}\",\n             MyNumber::max_value().val,\n             MyNumber::min_value().val, \n             a.val);\n}\n```\n\n\n\nNone of the solutions above are very elegant - to some degree this is because they are prototype implementations. There must be a cleaner way to limit the domain of a numeric type! \n\nWhat combination of type and traits would check bounds, use them for modular/saturation arithmetic, and easily convert to a numeric primitive?\n\nEDIT: This question has been flagged as a duplicate of a much older question from 2014. I do not believe the questions are the same on the grounds that Rust was pre alpha and major improvements to the language were brought with version 1.0. The difference is of a greater scale than that between Python 2 and 3.\n    ", "Answer": "\r\n\n  Expose a method which checks parameters before setting the fields, the\n  textbook associated function. This doesn't prevent assigning using the\n  struct constructor.\n\n\nIt does if the field is private.\n\nIn Rust, functions in the same module, or submodules, can see private items...  but if you put the type into its own module, the private fields are not available from outside:\n\n\n\n```\nmod mynumber {\n    // The struct is public, but the fields are not.\n    // Note I've used a tuple struct, since this is a shallow\n    // wrapper around the underlying type.\n    // Implementing Copy since it should be freely copied,\n    // Clone as required by Copy, and Debug for convenience.\n    #[derive(Clone,Copy,Debug)]\n    pub struct MyNumber(i8);\n```\n\n\nAnd here's a simple ```\nimpl```\n with a saturating add, which leverages ```\ni8```\n's built in ```\nsaturating_add```\n to avoid wrapping so that simple clamping works.  The type can be constructed using the ```\npub fn new```\n function, which now returns an ```\nOption<MyNumber>```\n since it can fail.\n\n```\n    impl MyNumber {\n        fn is_in_range(val: i8) -> bool {\n            val >= -100 && val <= 100\n        }\n        fn clamp(val: i8) -> i8 {\n            if val < -100 {\n                return -100;\n            }\n            if val > 100 {\n                return 100;\n            }\n            // Otherwise return val itself\n            val\n        }\n        pub fn new(val: i8) -> Option<MyNumber> {\n            if MyNumber::is_in_range(val) {\n                Some(MyNumber(val))\n            } else {\n                None\n            }\n        }\n\n        pub fn add(&self, other: MyNumber) -> MyNumber {\n            MyNumber(MyNumber::clamp(self.0.saturating_add(other.0)))\n        }\n    }\n}\n```\n\n\nOther modules can ```\nuse```\n the type:\n\n```\nuse mynumber::MyNumber;\n```\n\n\nAnd some example uses:\n\n```\nfn main() {\n    let a1 = MyNumber::new(80).unwrap();\n    let a2 = MyNumber::new(70).unwrap();\n    println!(\"Sum: {:?}\", a1.add(a2));\n    // let bad = MyNumber(123); // won't compile; accessing private field\n    let bad_runtime = MyNumber::new(123).unwrap();  // panics\n}\n```\n\n\nPlayground\n\nIn a more complete implementation I would probably implement ```\nstd::ops::Add```\n etc. so that I could use ```\na1 + a2```\n instead of calling named methods.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Why do two algorithms for finding primes differ in speed so much even though they seem to do the same number of iterations?\r\n                \r\nI have two algorithms of finding primes, in Python. The inner loop of each one seems to be executed the same number of times, and is equally simple. However, one of them takes 10 times as much as the other. My question is:\n\n\n  Why? Is this some quirk of Python that can be optimized away (how?), or am I missing something else?\n\n\nThe problem I am solving is essentially from http://www.spoj.pl/problems/PRIME1/. In my case, I have N = 10 ** 9, delta = 10 ** 5, and I want to find all primes between N-delta and delta. I also have ```\nsmallprimes```\n, a pre-made list of all primes less than or equal to square root of N. The first algorithm is very simple:\n\n```\ndef range_f1(lo, hi, smallprimes):\n  \"\"\"Finds all primes p with lo <= p <= hi. \n\n  smallprimes is the sorted list of all primes up to (at least) square root of hi.\n  hi & lo might be large, but hi-lo+1 miust fit into a long.\"\"\"\n\n  primes =[]\n  for i in xrange(hi-lo+1):\n    n = lo + i\n\n    isprime = True\n    for p in smallprimes:\n        if n % p == 0:\n            isprime = False\n            break\n\n    if isprime:\n        primes.append(n)\n\n  return primes\n```\n\n\nCalling ```\nrange_f1(N-delta,N,smallprimes)```\n takes a long time (about 10 seconds). The inner loop is called 195170 times. I also have a version of this algorithm that replaces the loop with a list comprehension (That is the one I actually use for profiling; see the end of the question) but that is no faster. \n\nThe second version is (an ugly implementation of) the sieve of Eratosthenes:\n\n```\ndef range_sieve(lo, hi, smallprimes):\n  \"\"\"Parameters as before\"\"\"\n\n  # So ugly! But SO FAST!! How??\n\n  delta = hi-lo+1\n  iamprime = [True] * delta      # iamprime[i] says whether lo + i is prime\n  if lo<= 1:\n    iamprime[1 - lo] = False\n\n  def sillyfun():      # For profiling & speed comparison\n    pass\n\n  for p in smallprimes:\n    rem = lo % p\n    if rem == 0:\n        iamprime[0] = False\n    for i in xrange(p - rem, delta, p):\n        iamprime[i] = False\n        sillyfun()\n\n    if p >= lo and p <= hi:\n        iamprime[p - lo] = True\n\n  return [p + lo for (p, ami) in enumerate(iamprime) if ami]\n```\n\n\nThis is about 10 times as fast, takes less than 2 seconds. However, the inner loop (sillyfun()) is called 259982 times, more than in the last case. I am at a loss to explain why this is fast.\n\nI thought that maybe the reason is because the inner loop of the first algorithm contains modular arithmetic, while the second only has an assignment. However, the following seems to imply that assignment is no faster than modular arithmetic:\n\n```\n>>> from timeit import timeit\n>>> timeit(\"10**9 % 2341234\")\n0.23445186469234613\n>>> timeit(\"a[5000]=False\", \"a = [True] * 10000\")\n0.47924750212666822\n```\n\n\n\n\nHere's the (less readable) version of the first algorithm I actually use:\n\n```\ndef range_f2(lo, hi, smallprimes):\n\n  primes =[]\n  for i in xrange(hi-lo+1):\n    n = lo + i\n\n    try:\n        (1 for p in smallprimes if n % p ==0).next()\n    except StopIteration:\n        primes.append(n)\n\n  return primes\n```\n\n\nHere are the result of calling the profiler for range_f2() (note the number of time generating expression is evaluated):\n\n```\n>>> from cProfile import run as prof\n>>> prof(\"range_f2(N-delta,N,sp)\")\n 200005 function calls in 13.866 CPU seconds\n\n Ordered by: standard name\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n      1    0.000    0.000   13.866   13.866 <string>:1(<module>)\n 195170   12.632    0.000   12.632    0.000 prime1.py:101(<genexpr>)\n      1    1.224    1.224   13.865   13.865 prime1.py:90(range_f2)\n   4832    0.009    0.000    0.009    0.000 {method 'append' of 'list' objects}\n      1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```\n\n\nHere is the profiler result for range_sieve():\n\n```\n>>> prof(\"range_sieve(N-delta,N,sp)\")\n259985 function calls in 1.370 CPU seconds\n\nOrdered by: standard name\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     1    0.003    0.003    1.370    1.370 <string>:1(<module>)\n     1    0.877    0.877    1.367    1.367 prime1.py:39(range_sieve)\n259982    0.490    0.000    0.490    0.000 prime1.py:51(sillyfun)\n     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```\n\n\nFinally,here is he complete code that generates the lists of small primes (in a very silly way) so that you can check what results you get: http://pastebin.com/7sfN4mG4\n\nUPDATE By popular demand, the profiling data for the first chunk of code. No data on how many times the inner loop is executed, but it seems pretty clear it's the same as the third.\n\n```\n>>> prof(\"range_f1(N-delta,N,sp)\")\n      4835 function calls in 14.184 CPU seconds\nOrdered by: standard name\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     1    0.000    0.000   14.184   14.184 <string>:1(<module>)\n     1   14.162   14.162   14.183   14.183 prime1.py:69(range_f1)\n  4832    0.021    0.000    0.021    0.000 {method 'append' of 'list' objects}\n     1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```\n\n    ", "Answer": "\r\nThe difference is an algorithmic one. In the first version, trial division, you test each candidate against all small primes - that you don't stop when the small prime exceeds ```\ncandidate ** 0.5```\n doesn't matter for the ```\nrange(10**9 - 10**5 ,10**9)```\n if smallprimes has a good upper bound, but it would if the length of the range were much larger in relation to the upper bound. For composites, that doesn't incur much cost, since most of them have at least one small prime divisor. But for primes, you have to go all the way to ```\nN**0.5```\n. There are roughly ```\n10**5/log(10**9)```\n primes in that interval, each of them is trial-divided by about ```\n10**4.5/log(10**4.5)```\n primes, so that makes about ```\n1.47*10**7```\n trial divisions against primes.\n\nOn the other hand, with the sieve, you only cross off composites, each composite is crossed off as many times as it has prime divisors, while primes aren't crossed off at all (so primes are free). The number of prime divisors of ```\nn```\n is bounded by (a multiple of) ```\nlog(n)```\n (that's a crude upper bound, usually greatly overestimating), so that gives an upper bound of ```\n10**5*log(10**9)```\n (times a small constant) crossings-off, about ```\n2*10**6```\n. In addition to that, the crossing off may be less work than a division (don't know about Python, it is for C arrays). So you're doing less work with the sieve.\n\nEdit: collected the actual numbers for ```\n10**9-10**5```\n to ```\n10**9```\n.\n\n```\nTicks: 259987\n4832\nDivisions: 20353799\n4832\n```\n\n\nThe sieve does only 259987 crossings-off, you see that the crude upper bound above is overestimating by a large factor. The trial division needs more than 20 million divisions, 16433632 of those for primes (```\nx/log x```\n underestimates the number of primes, for ```\nx = 10**4.5```\n by about 10%), 3435183 are used for the 3297 numbers in that range whose smallest prime factor is larger than ```\nn**(1/3)```\n.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Montgomery multiplication on PC with word-size moduli. Is it worth it?\r\n                \r\nI'm writing some C code for a research project in number theory, which requires to do a lot of operations in modular arithmetic, with many different moduli. To put it simple: I need to do the operation ```\n(a * b) % n```\n many many times.\n\nThe code is meant to run on a PC with 64 bits words, and all the moduli are known to be less than 2^64, so all the operands are implemented by unsigned 64 bits integers.\n\nMy question is: Would using Montgomery modular multiplication (that makes use only of addition and multiplication) instead of the C modulo operator ```\n%```\n (that translates to ```\na % n = a - n*(a / n)```\n and uses also a division) result in a faster execution?\n\nIntuitively, I would say that the answer is: No, because (word-size) divisions on a PC are not too much computationally expensive than (word-size) multiplications, and Montgomery reduction would actually cause an overhead.\n\nThank for any suggestions.\n\nUpdate: On the one hand, according to Paul Ogilvie (see his comment below), ```\n(a * b) % n```\n requires 1 multiplication and 1 division. On the other hand, Montgomery multiplication requires (ignoring the operations needed to convert, and convert back, the operands to their Montgomery representations, since they are done once time only for every modulo n; and the binary shifts) 3 multiplications. So it would seem that Montgomery is faster than ``%'' as soon as multiplication is performed two times faster than division...\n    ", "Answer": "\r\nYour intution is incorrect. Division is many times slower than multiplication, whether it is for integers or floating points. See this excellent answer about a similar question. The exact difference in speed depends on which CPU you are running on, whether the code can be vectorized, and even on what the rest of the code is doing around the same time.\n\nIf you do integer divide by a constant, for example if you know ```\nn```\n at compile time, then the compiler could transform this into a sequence of multiplications and shifts, maybe even doing exactly the same as Montgomery modular multiplication. If ```\nn```\n is not known at compile time, then it is probably worthwile to implement Montgomery modular multiplication.\n\nHowever, the best answer you will get is when you implement both versions of your code, and benchmark it.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "periodic boundary conditions - finite differences\r\n                \r\nHi I have a code below that solves non linear coupled PDE's.  However I need to implement periodic boundary conditions.    The periodic boundary conditions are troubling me, what should I add into my code to enforce periodic boundary conditions?  Updated based on modular arithmetic suggestions below.\n\nNote, t>=0 and  x is in the interval [0,1]. Here are the coupled equations, below that I provide my code\n\n\n\nwhere a, b > 0.  \n\nThose are the initial conditions, but now I need to impose periodic boundary conditions.  These can be mathematically written as u(0,t)=u(1,t) and du(0,t)/dx=du(1,t)/dx, the same holds for f(x,t). The du/dx I have for the boundary conditions are really meant to be  partial derivatives.\n\nMy code is below\n\n```\nprogram coupledPDE \n\ninteger, parameter :: n = 10, A = 20 \nreal, parameter :: h = 0.1, k = 0.05 \nreal, dimension(0:n-1) :: u,v,w,f,g,d \ninteger:: i,m \nreal:: t, R, x,c1,c2,c3,aa,b \n\nR=(k/h)**2.\naa=2.0\nb=1.0\nc1=(2.+aa*k**2.-2.0*R)/(1+k/2.)\nc2=R/(1.+k/2.)\nc3=(1.0-k/2.)/(1.0+k/2.)\nc4=b*k**2./(1+k/2.)\n\n\ndo i = 0,n-1 !loop over all space points except 0 and n\n  x = real(i)*h    \n  w(i) = z(x)  !u(x,0)\n  d(i) = z(x)  !f(x,0)\nend do\n\n\ndo i=0,n-1\n  ip=mod(i+1,n)\n  il=modulo(i-1,n)\n  v(i) = (c1/(1.+c3))*w(i) + (c2/(1.+c3))*(w(ip)+w(il)) -(c4/(1.+c3))*w(i)*((w(i))**2.+(d(i))**2.)    !\\partial_t u(x,0)=0\n  g(i) = (c1/(1.+c3))*d(i) + (c2/(1.+c3))*(d(ip)+d(il)) -(c4/(1.+c3))*d(i)*((w(i))**2.+(d(i))**2.)    !\\partial_t f(x,0)=0\nend do\n\ndo m=1,A \n\n   do i=0,n-1\n       ip=mod(i+1,n)\n       il=modulo(i-1,n)\n       u(i)=c1*v(i)+c2*(v(ip)+v(il))-c3*w(i)-c4*v(i)*((v(i))**2.+(g(i))**2.) \n       f(i)=c1*g(i)+c2*(g(ip)+g(il))-c3*d(i)-c4*g(i)*((v(i))**2.+(g(i))**2.) \n   end do \n     print*, \"the values of u(x,t+k) for all m=\",m\n   print \"(//3x,i5,//(3(3x,e22.14)))\",m,u   \n\n  do i=0,n-1\n   w(i)=v(i)\n   v(i)=u(i)\n   d(i)=g(i)\n   t=real(m)*k\n   x=real(i)*k\n  end do\n\nend do\n\n\nend program coupledPDE\n\nfunction z(x)\nreal, intent(in) :: x\nreal :: pi\npi=4.0*atan(1.0)\nz = sin(pi*x)\nend function z\n```\n\n\nThanks for reading,  if I should reformat my question in a more proper way please let me know.  \n    ", "Answer": "\r\nOne option to boundary conditions in PDE discretization is to use ghost (halo) cells (gridpoints). It may be not the most clever one for periodic BC, but it can be used for all other boundary condition types.\n\nSo you declare your arrays as\n\n```\nreal, dimension(-1:n) :: u,v,w,f,g,d\n```\n\n\nbut you solve your PDE only in points 0..n-1 (point n is identical with point 0). You could also do from 1..n and declare arrays form 0..n+1.\n\nThen you set \n\n```\n u(-1) = u(n-1)\n```\n\n\nand \n\n```\n u(n) = u(0)\n```\n\n\nand the same for all other arrays.\n\nAt each time-step you set this again for ```\nu```\n and ```\nf```\n or all other fields that are modified during the solution:\n\n```\ndo m=1,A \n   u(-1) = u(n-1)\n   u(n) = u(0)\n   f(-1) = f(n-1)\n   f(n) = f(0)\n\n   do i=0,n-1 !Discretization equation for all times after the 1st step\n       u(i)=...\n       f(i)=...\n   end do \nend do\n```\n\n\nAll above assumed explicit temporal discretization and spatial discretization with finite differences and it assumed that ```\nx(0) = 0```\n and ```\nx(n) = 1```\n are your boundary points.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Can I ignore the last k while expanding (a + b) % k?\r\n                \r\nToday I was trying to solve a problem that involved modular arithmetic. I was not able to solve it. So I looked it up on Geeks for Geeks\n\nThe above image shows what the author did. I know modular addition for two numbers\n(a + b) % m   =  (a % m + b % m) % m\nThis works for any positive values of a and b\nWhen I consider the equation the author used in the image.\na % k + b % k = 0\nI substituted some random values for a , b and k to see if it really works. It turns out it fails for the input values a = 2, b = 5 and k = 7.\n2 % 7 + 5 % 7 = 7 ≠ 0\nWhen I considered the last equation. It worked.\nb % k = (k - a % k) % k\n(5 % 7) = (7 - 2 % 7) % 7\n5 % 7 = 5 % 7\n(a + b) % k = c\nWhen I solved the above equation with the same idea as the author, I got\n(a + b) % k = c\na % k + b % k = c\nb % k = (c - a % k + k) % k\nIt works for any positive values of a, b, c and k\nIn the equation,\n(a + b) % k  = (a % k + b % k) % k\nCan I just ignore the last k and proceed while expanding (a + b) % k ?. I wonder how the absence of the last k doesn't affect the final result\n    ", "Answer": "\r\nNo, ```\na = b = 0```\n is a counterexample.\nIndeed, the final formula is incorrect, assuming that ```\n%```\n denotes the remainder of truncating division. Let ```\na = 1```\n and ```\nb = -1```\n. (In Python, or for nonnegative integers, it's OK.)\nThis is why mathematicians prefer to deal in equivalence mod ```\nK```\n, which avoids the issue of where to put the mod operator.\n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Going from signed integers to unsigned integers and vice versa in C++20\r\n                \r\nBefore C++20 signed integers were not guaranteed to be two's complement. Now we have two papers proposing standardization of two's complement as the only representation: p0907 and p1236 and, if I understand correctly, one of them got merged into C++20 working draft.\n\nSo, what does it mean for signed-to-unsigned conversion and vice versa? I've looked at cppreference and has found the following wording:\n\n\n  If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value modulo ```\n2n```\n\n  where ```\nn```\n is the number of bits used to represent the destination type.\n  \n  If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is the unique value of the destination type equal to the source value modulo ```\n2n```\n\n  where ```\nn```\n is the number of bits used to represent the destination type. (Note that this is different from signed integer arithmetic overflow, which is undefined).\n\n\nUnfortunately, I have problems understanding this wording and I want to know what is written in C++20 Working Draft.\n\nSo there are two questions:\n\n\nLanguage lawyer part: can someone please point what the standard says exactly and where in the standard does it say it?\nCan someone explain that wording in more layman's terms, probably also explaining modular arithmetic and providing examples?\n\n    ", "Answer": "\r\nThe conversion rule is [conv.integral]/3:\n\n\n  Otherwise, the result is the unique value of the destination type that is congruent to the source integer modulo ```\n2N```\n, where ```\nN```\n is the range exponent of the destination type.\n\n\nwhere the range exponents are described in table in [basic.fundamental], but mean what you expect (for ```\nint```\n it's at least 16, for ```\nlong long```\n, it's at least 64, etc.).\n\nFor instance, converting a ```\nshort```\n with value ```\n-3```\n to ```\nunsigned short```\n is to find the unique value of type ```\nunsigned short```\n which is congruent to ```\n-3```\n modulo ```\n216```\n... which is to say, ```\n216-3```\n or ```\n65533```\n. But converting that same ```\nshort```\n value of ```\n-3```\n to ```\nunsigned long long```\n would change the modulo base to ```\n264```\n, so you end up with ```\n18446744073709551613```\n instead.\n\nConverting from a signed type to a signed type with a different range exponent (or likewise unsigned to unsigned) is more straightforward - you either just chop off bits or zero-extend them. Converting a ```\nshort```\n with value 258 to ```\nint```\n or ```\nlong```\n or ```\nlong long```\n is just 258, but to ```\nsigned char```\n is 2, for instance. \n    ", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
{"Question": "Is there any convenient way to disable clang's undefined sanitizer for system directories?\r\n                \r\nIt was well established in this question that many errors thrown by UBSAN on clang are not undefined behavior but just warnings.\nAlthough not technically UB, I want to turn them on because most often than not, they are actual bugs that my team has introduced. This helps catch mistakes early on in development.\nWhen using clang's libc++ everything is fine as it does not trigger any of the clang's ubsan errors. However when using libstdc++ (gcc) there is a spam of messages from within the STL like the following:\n```\n/usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/uniform_int_dist.h:300:9: runtime error: implicit conversion from type 'unsigned long' of value 13471860010592100493 (64-bit, unsigned) to type 'std::uniform_int_distribution<long>::result_type' (aka 'long') changed the value to -4974884063117451123 (64-bit, signed)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/uniform_int_dist.h:300:9 in \n```\n\nThis apparently is a valid use of modular arithmetic so I am not concerned about its correctness.\nHowever this prevents using gcc's STL with our projects and sometimes we have to so we have to turn off ubsan completely on our code or switch to gcc as compiler.\nMy question then is - is there a way to turn off those messages for just system directories - anything under ```\n/usr```\n for example.\nThanks!\n    ", "Answer": "", "Knowledge_point": "Modular Arithmetic", "Tag": "算法分析"}
