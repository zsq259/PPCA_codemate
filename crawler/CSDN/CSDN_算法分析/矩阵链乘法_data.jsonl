{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_42334072/article/details/106769534可以看一下这个链接最后的代码修正&amp;#xff0c;加上了LAST信号&amp;#xff0c;应该可以重复发送\" id=\"textarea_1639968737421_1639969474932_0\"&gt;https://blog.csdn.net/qq_42334072/article/details/106769534可以看一下这个链接最后的代码修正&amp;#xff0c;加上了LAST信号&amp;#xff0c;应该可以重复发送&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "矩阵链乘法", "Question": ["PYNQ矩阵乘法IP核不能重复调用", ["问题遇到的现象和发生背景", "\n", "矩阵乘法IP核不能重复调用", "\n", "问题相关代码，请勿粘贴截图", "\n", "问题采用的矩阵乘法IP核如下", "\n      \n        ", "基于PYNQ-Z2开发板实现矩阵乘法加速详细流程_谦豫-CSDN博客_hwh文件", "\n        \n      ", "基于PYNQ-Z2开发板实现矩阵乘法加速主要内容1、在Vivado HLS中生成矩阵乘法加速的IP核。2、在Vivado中完成Block Design。3、在Jupyter Notebook上完成IP的调用。完整项目工程文件下载链接见文末所需硬件PYNQ-Z2开发板、USB数据线、网线SD卡、读卡器开发板配置参考链接1、Vivado HLS生成矩阵乘法加速IPHLS硬件配置信息mul.h关键代码#define MAT_A_ROWS 32#define MAT_A_COLS ", "\n      ", "\n      ", "\n        ", "\n          ", "https://blog.csdn.net/qq_42334072/article/details/106769534", "\n        ", "\n      ", "调用过程如下", "\n", "运行结果及报错内容", "\n", "如果只是重复最后三行transfer代码，会报错显示channel not open。如果全部重复，overlay那一行太过耗时。", "\n", "我想要达到的结果", "\n", "在不重复overlay那一行代码的同时，重复进行矩阵乘法运算"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;请采纳。点击我回答右上角【采纳】按钮。&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;iostream&amp;gt;\nusing namespace std;\ntypedef  int  ElemType ;\n#define M 4  //稀疏矩阵行数\n#define N 4  //稀疏矩阵列数\n#define MaxSize  6  //非零元素最多个数\n//三元组类型定义\ntypedef struct\n{\n\tint r;         //行号  \n\tint c;          //列号  \n\tElemType d;     //元素值  \n} TupNode;         //三元组定义  \ntypedef struct\n{\n\tint rows;      //行数  \n\tint cols;     //列数  \n\tint nums;       //非零元素个数  \n\tTupNode data[MaxSize];\n} TSMatrix;    //三元组顺序表定义  \n//十字链表类型定义\ntypedef struct mtxn\n{\n\tint row;   //行号\n\tint col;    //列号\n\tstruct mtxn *right, *down;  //向右和向下的指针\n\tunion\n\t{\n\t\tElemType value;   //非零元素值\n\t\tstruct mtxn *link;  //指向下一个头结点\n\t}tag;\n}MatNode;\n\n\n//三元组创建\nvoid Create_1(TSMatrix &amp;amp;t, ElemType A[M][N])\n{\n\tint i, j;\n\tt.rows &amp;#61; M;\n\tt.cols &amp;#61; N;\n\tt.nums &amp;#61; 0;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tif (A[i][j] !&amp;#61; 0)    //元素值不为零&amp;#xff0c;建立三元组\n\t\t\t{\n\t\t\t\tt.data[t.nums].r &amp;#61; i;\n\t\t\t\tt.data[t.nums].c &amp;#61; j;\n\t\t\t\tt.data[t.nums].d &amp;#61; A[i][j];\n\t\t\t\tt.nums&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t}\n\t}\n}\n//十字链表创建\nvoid Create_2(MatNode *&amp;amp;mh, ElemType a[M][N])\n{\n\tint i, j;\n\tMatNode *h[MaxSize], *p, *q, *r;\n\tmh &amp;#61; (MatNode *)malloc(sizeof(MatNode));   //创建十字链表的头节点\n\tmh-&amp;gt;row &amp;#61; M;\n\tmh-&amp;gt;col &amp;#61; N;\n\tr &amp;#61; mh;   //r指向尾节点\n\tfor (i &amp;#61; 0; i &amp;lt; MaxSize; i&amp;#43;&amp;#43;)   //采用尾插法创建循环表\n\t{\n\t\th[i] &amp;#61; (MatNode *)malloc(sizeof(MatNode));\n\t\th[i]-&amp;gt;down &amp;#61; h[i]-&amp;gt;right &amp;#61; h[i];\t//将down和right方向量置为循环的\n\t\tr-&amp;gt;tag.link &amp;#61; h[i];  //将h[i]加到链表中\n\t\tr &amp;#61; h[i];\n\t}\n\tr-&amp;gt;tag.link &amp;#61; mh;   //置为循环链表\n\n\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)    //处理每一行\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)    //处理每一列\n\t\t{\n\t\t\tif (a[i][j] !&amp;#61; 0)   //处理非零元素\n\t\t\t{\n\t\t\t\tp &amp;#61; (MatNode *)malloc(sizeof(MatNode));\t  //创建一个新节点\n\t\t\t\tp-&amp;gt;row &amp;#61; i;\n\t\t\t\tp-&amp;gt;col &amp;#61; j;\n\t\t\t\tp-&amp;gt;tag.value &amp;#61; a[i][j];\n\t\t\t\tq &amp;#61; h[i];   //查找在行表中插入位置\n\t\t\t\twhile (q-&amp;gt;right !&amp;#61; h[i] &amp;amp;&amp;amp; q-&amp;gt;right-&amp;gt;col &amp;lt; j)\n\t\t\t\t{\n\t\t\t\t\tq &amp;#61; q-&amp;gt;right;\n\t\t\t\t}\n\t\t\t\tp-&amp;gt;right &amp;#61; q-&amp;gt;right;\n\t\t\t\tq-&amp;gt;right &amp;#61; p;\t\t\t//完成行表的操作\n\t\t\t\tq &amp;#61; h[j];      //查找在链表中插入的位置\n\n\t\t\t\twhile (q-&amp;gt;down !&amp;#61; h[j] &amp;amp;&amp;amp; q-&amp;gt;down-&amp;gt;row &amp;lt; i)\n\t\t\t\t{\n\t\t\t\t\tq &amp;#61; q-&amp;gt;down;\n\t\t\t\t}\n\t\t\t\tp-&amp;gt;down &amp;#61; q-&amp;gt;down;\n\t\t\t\tq-&amp;gt;down &amp;#61; p;\t\t\t//完成列表的插入\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n\n//输出三元组矩阵 \nvoid  DispMat_1(TSMatrix t)\n{\n\tint k;\n\tif (t.nums &amp;lt;&amp;#61; 0)\n\t{\n\t\treturn ;\n\t}\n\tcout &amp;lt;&amp;lt; t.rows &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34; &amp;lt;&amp;lt; t.cols &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34; &amp;lt;&amp;lt; t.nums &amp;lt;&amp;lt; endl;\n\tcout &amp;lt;&amp;lt; &amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcout &amp;lt;&amp;lt; &amp;#34;行数&amp;#34; &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &amp;#34; 列数&amp;#34; &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &amp;#34;非零元素&amp;#34; &amp;lt;&amp;lt; endl;\n\tfor (k &amp;#61; 0; k &amp;lt; t.nums; k&amp;#43;&amp;#43;)\n\t{\n\t\tcout &amp;lt;&amp;lt; t.data[k].r &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; t.data[k].c &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; t.data[k].d &amp;lt;&amp;lt; endl;\n\t}\n}\n//输出十字链表矩阵\nvoid DispMat_2(MatNode *mh)\n{\n\tMatNode *p, *q;\n\tcout &amp;lt;&amp;lt; &amp;#34;行&amp;#61;&amp;#34; &amp;lt;&amp;lt; mh-&amp;gt;row &amp;lt;&amp;lt; &amp;#34;列&amp;#61;&amp;#34; &amp;lt;&amp;lt; mh-&amp;gt;col &amp;lt;&amp;lt; endl;\n\tp &amp;#61; mh-&amp;gt;tag.link;\n\twhile (p !&amp;#61; mh)\n\t{\n\t\tq &amp;#61; p-&amp;gt;right;\n\t\twhile (p !&amp;#61; q)\t\t\t\t//输出一行非零元素\n\t\t{\n\t\t\tcout &amp;lt;&amp;lt; q-&amp;gt;row &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; q-&amp;gt;col &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; q-&amp;gt;tag.value &amp;lt;&amp;lt; endl;\n\t\t\tq &amp;#61; q-&amp;gt;right;\n\t\t}\n\t\tp &amp;#61; p-&amp;gt;tag.link;\n\t}\n\n}\n\n\n//三元组元素赋值  \nbool Value(TSMatrix &amp;amp;t, ElemType x, int i, int j)\n{\n\tint k &amp;#61; 0, k1;\n\tif (i &amp;gt;&amp;#61; t.rows || j &amp;gt;&amp;#61; t.cols)\n\t\treturn false;\n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i&amp;gt;t.data[k].r)\n\t\tk&amp;#43;&amp;#43;;      //查找行  \n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i &amp;#61;&amp;#61; t.data[k].r &amp;amp;&amp;amp; j&amp;gt;t.data[k].c)\n\t\tk&amp;#43;&amp;#43;;     //查找列  \n\tif (t.data[k].r &amp;#61;&amp;#61; i &amp;amp;&amp;amp; t.data[k].c &amp;#61;&amp;#61; j)   //存在这样的元素  \n\t\tt.data[k].d &amp;#61; x;\n\telse               //不存在这样的元素时插入一个元素  \n\t{\n\t\tfor (k1 &amp;#61; t.nums - 1; k1 &amp;gt;&amp;#61; k; k1--)\n\t\t{\n\t\t\tt.data[k1 &amp;#43; 1].r &amp;#61; t.data[k1].r;\n\t\t\tt.data[k1 &amp;#43; 1].c &amp;#61; t.data[k1].c;\n\t\t\tt.data[k1 &amp;#43; 1].d &amp;#61; t.data[k1].d;\n\t\t}\n\t\tt.data[k].r &amp;#61; i;\n\t\tt.data[k].c &amp;#61; j;\n\t\tt.data[k].d &amp;#61; x;\n\t\tt.nums&amp;#43;&amp;#43;;\n\t}\n\treturn true;\n}\n//将指定位置的元素值赋给变量 \nbool Assign(TSMatrix t, ElemType &amp;amp;x, int i, int j)\n{\n\tint k &amp;#61; 0;\n\tif (i &amp;gt;&amp;#61; t.rows || j &amp;gt;&amp;#61; t.cols)\n\t\treturn false;\n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i&amp;gt;t.data[k].r)\n\t\tk&amp;#43;&amp;#43;;    //查找行  \n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i &amp;#61;&amp;#61; t.data[k].r &amp;amp;&amp;amp; j&amp;gt;t.data[k].c)\n\t\tk&amp;#43;&amp;#43;;  //查找列  \n\tif (t.data[k].r &amp;#61;&amp;#61; i &amp;amp;&amp;amp; t.data[k].c &amp;#61;&amp;#61; j)\n\t\tx &amp;#61; t.data[k].d;\n\telse\n\t\tx &amp;#61; 0;         //在三元组中没有找到表示是零元素  \n\treturn true;\n}\n\n\n//三元组下矩阵转置 \nvoid TranTat_1(TSMatrix t, TSMatrix &amp;amp;tb)\n{\n\tint k, k1 &amp;#61; 0, v;\t\t//k1记录tb中的元素个数\n\ttb.rows &amp;#61; t.rows;\n\ttb.cols &amp;#61; t.cols;\n\ttb.nums &amp;#61; t.nums;\n\tif (t.nums !&amp;#61; 0)\t//当存在非零元素时执行转置\n\t{\n\t\tfor (v &amp;#61; 0; v &amp;lt; t.cols; v&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tfor (k &amp;#61; 0; k &amp;lt; t.nums; k&amp;#43;&amp;#43;)\t\t//k用于扫描t.data的所有元素\n\t\t\t{\n\t\t\t\tif (t.data[k].c &amp;#61;&amp;#61; v)\t\t//找到一个列号为v的元素\n\t\t\t\t{\n\t\t\t\t\ttb.data[k].r &amp;#61; t.data[k].c;\t\t//将行列交换后添加到tb中\n\t\t\t\t\ttb.data[k].c &amp;#61; t.data[k].r;\n\t\t\t\t\ttb.data[k].d &amp;#61; t.data[k].d;\n\t\t\t\t\tk1&amp;#43;&amp;#43;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n//十字链表下矩阵转置 \nvoid TranTat_2(ElemType a[M][N], ElemType c[M][N])\n{\n\tint i,j;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t\tc[j][i] &amp;#61; a[i][j];\n\t}\n\n}\n\n\n//三元组下矩阵相加 \nbool  AddMat_1(TSMatrix a, TSMatrix b, TSMatrix &amp;amp;c)\n{\n\tint i, j;\n\tElemType x, y, z;\n\tif (a.rows !&amp;#61; b.rows || a.cols !&amp;#61; b.cols)\n\t\treturn false;            //行数或列数不等时不能相加\n\tc.rows &amp;#61; a.rows;\n\tc.cols &amp;#61; a.cols;       //c的行列数与a的相同  \n\tc.nums &amp;#61; 0;\n\tfor (i &amp;#61; 0; i&amp;lt;M; i&amp;#43;&amp;#43;)\n\t\tfor (j &amp;#61; 0; j&amp;lt;N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tAssign(a, x, i, j);\n\t\t\tAssign(b, y, i, j);\n\t\t\tz &amp;#61; x &amp;#43; y;\n\t\t\tif (z!&amp;#61;0)\n\t\t\t\tValue(c, z, i, j);\n\t\t}\n\treturn true;\n}\n//十字链表下矩阵相加 \nvoid AddMat_2(ElemType a[M][N], ElemType b[M][N], ElemType c[M][N])\n{\n\tint i;\n\tint j;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tc[i][j] &amp;#61; a[i][j] &amp;#43; b[i][j];\n\t\t}\n\t}\n}\n\n\n//三元组下矩阵相乘 \nbool  MulMat_1(TSMatrix a, TSMatrix b, TSMatrix &amp;amp;c)\n{\n\tint i, j;\n\tElemType x, y, z;\n\tif (a.rows !&amp;#61; b.rows || a.cols !&amp;#61; b.cols)\n\t\treturn false;            //行数或列数不等时不能相乘\n\tc.rows &amp;#61; a.rows;\n\tc.cols &amp;#61; a.cols;       //c的行列数与a的相同  \n\tc.nums &amp;#61; 0;\n\tfor (i &amp;#61; 0; i&amp;lt;M; i&amp;#43;&amp;#43;)\n\t\tfor (j &amp;#61; 0; j&amp;lt;N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tAssign(a, x, i, j);\n\t\t\tAssign(b, y, i, j);\n\t\t\tz &amp;#61; x * y;\n\t\t\tif (z)\n\t\t\t\tValue(c, z, i, j);\n\t\t}\n\treturn true;\n}\n//十字链表下矩阵相乘 \nvoid  MulMat_2(ElemType a[M][N], ElemType b[M][N], ElemType c[M][N])\n{\n\tint i;\n\tint j;\n\tint k;\n\tint temp;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\ttemp &amp;#61; 0;\n\t\t\tfor (k &amp;#61; 0; k &amp;lt; 4; k&amp;#43;&amp;#43;)\n\t\t\t{\n\t\t\t\ttemp &amp;#61; temp &amp;#43; a[i][k] * b[k][j];\n\t\t\t}\n\t\t\tc[i][j] &amp;#61; temp;\n\t\t}\n\n\t}\n}\n\n\n//主函数实现\nint main()\n{\n\tTSMatrix ta, tb, tc;\n\n\tMatNode *td,*tf;\n\n\tint x,y,z;\n\n\tElemType a[M][N] &amp;#61; { 1, 0, 3, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1 };\n\tElemType b[M][N] &amp;#61; { 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2 };\n\tElemType c[M][N] &amp;#61; { 0 };\n\n\twhile (1)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;提示&amp;#xff1a;输入1----是三元组下的矩阵运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入2----是十字链表下的矩阵运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入3----退出&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入&amp;#xff1a;&amp;#34;;\n\t\tcin &amp;gt;&amp;gt; x;\n\t\tswitch (x)\n\t\t{\n\t\tcase 1:\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;提示&amp;#xff1a;输入1----三元组下矩阵的转置运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入2----三元组下矩阵的相加运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入3----三元组下矩阵的相乘运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入&amp;#xff1a;&amp;#34;;\n\t\t\tcin &amp;gt;&amp;gt; y;\n\t\t\tswitch (y)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;输出三元组下矩阵a&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tDispMat_1(ta);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;三元组下矩阵a转置&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tTranTat_1(ta, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tCreate_1(tb, b);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;三元组下矩阵a,b相加&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tAddMat_1(ta, tb, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tCreate_1(tb, b);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;三元组下矩阵a,b相乘&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tMulMat_1(ta, tb, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;提示&amp;#xff1a;输入1----十字链表下矩阵的转置运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入2----十字链表下矩阵的相加运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入3----十字链表下矩阵的相乘运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入&amp;#xff1a;&amp;#34;;\n\t\t\tcin &amp;gt;&amp;gt; z;\n\t\t\tswitch (z)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tCreate_2(td,a);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;输出十字链表下矩阵a&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tDispMat_2(td);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;十字链表下矩阵a转置&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tTranTat_2(a, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;十字链表下矩阵a,b相加&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tAddMat_2(a, b, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;十字链表下矩阵a,b相乘&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tMulMat_2(a, b, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 3: break; \n\t\t}\n\t}\n\tcout &amp;lt;&amp;lt; endl;\n\tsystem(&amp;#34;pause&amp;#34;);\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "矩阵链乘法", "Question": ["怎么用c语言实现一下稀疏矩阵操作?", ["要求用C语言编写", "\n实现三元组，十字链表下的稀疏矩阵的加、转、乘的实现。", "\n（1）稀疏矩阵的存储", "\n（2）稀疏矩阵加法", "\n（3）矩阵乘法", "\n（4）矩阵转置", "\n\n", "求各位大神指点！！！求源代码，最好有注释", "\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_42334072/article/details/106769534可以看一下这个链接最后的代码修正&amp;#xff0c;加上了LAST信号&amp;#xff0c;应该可以重复发送\" id=\"textarea_1639968737421_1639969474932_0\"&gt;https://blog.csdn.net/qq_42334072/article/details/106769534可以看一下这个链接最后的代码修正&amp;#xff0c;加上了LAST信号&amp;#xff0c;应该可以重复发送&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "矩阵链乘法", "Question": ["PYNQ矩阵乘法IP核不能重复调用", ["问题遇到的现象和发生背景", "\n", "矩阵乘法IP核不能重复调用", "\n", "问题相关代码，请勿粘贴截图", "\n", "问题采用的矩阵乘法IP核如下", "\n      \n        ", "基于PYNQ-Z2开发板实现矩阵乘法加速详细流程_谦豫-CSDN博客_hwh文件", "\n        \n      ", "基于PYNQ-Z2开发板实现矩阵乘法加速主要内容1、在Vivado HLS中生成矩阵乘法加速的IP核。2、在Vivado中完成Block Design。3、在Jupyter Notebook上完成IP的调用。完整项目工程文件下载链接见文末所需硬件PYNQ-Z2开发板、USB数据线、网线SD卡、读卡器开发板配置参考链接1、Vivado HLS生成矩阵乘法加速IPHLS硬件配置信息mul.h关键代码#define MAT_A_ROWS 32#define MAT_A_COLS ", "\n      ", "\n      ", "\n        ", "\n          ", "https://blog.csdn.net/qq_42334072/article/details/106769534", "\n        ", "\n      ", "调用过程如下", "\n", "运行结果及报错内容", "\n", "如果只是重复最后三行transfer代码，会报错显示channel not open。如果全部重复，overlay那一行太过耗时。", "\n", "我想要达到的结果", "\n", "在不重复overlay那一行代码的同时，重复进行矩阵乘法运算"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;请采纳。点击我回答右上角【采纳】按钮。&lt;/strong&gt;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;iostream&amp;gt;\nusing namespace std;\ntypedef  int  ElemType ;\n#define M 4  //稀疏矩阵行数\n#define N 4  //稀疏矩阵列数\n#define MaxSize  6  //非零元素最多个数\n//三元组类型定义\ntypedef struct\n{\n\tint r;         //行号  \n\tint c;          //列号  \n\tElemType d;     //元素值  \n} TupNode;         //三元组定义  \ntypedef struct\n{\n\tint rows;      //行数  \n\tint cols;     //列数  \n\tint nums;       //非零元素个数  \n\tTupNode data[MaxSize];\n} TSMatrix;    //三元组顺序表定义  \n//十字链表类型定义\ntypedef struct mtxn\n{\n\tint row;   //行号\n\tint col;    //列号\n\tstruct mtxn *right, *down;  //向右和向下的指针\n\tunion\n\t{\n\t\tElemType value;   //非零元素值\n\t\tstruct mtxn *link;  //指向下一个头结点\n\t}tag;\n}MatNode;\n\n\n//三元组创建\nvoid Create_1(TSMatrix &amp;amp;t, ElemType A[M][N])\n{\n\tint i, j;\n\tt.rows &amp;#61; M;\n\tt.cols &amp;#61; N;\n\tt.nums &amp;#61; 0;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tif (A[i][j] !&amp;#61; 0)    //元素值不为零&amp;#xff0c;建立三元组\n\t\t\t{\n\t\t\t\tt.data[t.nums].r &amp;#61; i;\n\t\t\t\tt.data[t.nums].c &amp;#61; j;\n\t\t\t\tt.data[t.nums].d &amp;#61; A[i][j];\n\t\t\t\tt.nums&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t}\n\t}\n}\n//十字链表创建\nvoid Create_2(MatNode *&amp;amp;mh, ElemType a[M][N])\n{\n\tint i, j;\n\tMatNode *h[MaxSize], *p, *q, *r;\n\tmh &amp;#61; (MatNode *)malloc(sizeof(MatNode));   //创建十字链表的头节点\n\tmh-&amp;gt;row &amp;#61; M;\n\tmh-&amp;gt;col &amp;#61; N;\n\tr &amp;#61; mh;   //r指向尾节点\n\tfor (i &amp;#61; 0; i &amp;lt; MaxSize; i&amp;#43;&amp;#43;)   //采用尾插法创建循环表\n\t{\n\t\th[i] &amp;#61; (MatNode *)malloc(sizeof(MatNode));\n\t\th[i]-&amp;gt;down &amp;#61; h[i]-&amp;gt;right &amp;#61; h[i];\t//将down和right方向量置为循环的\n\t\tr-&amp;gt;tag.link &amp;#61; h[i];  //将h[i]加到链表中\n\t\tr &amp;#61; h[i];\n\t}\n\tr-&amp;gt;tag.link &amp;#61; mh;   //置为循环链表\n\n\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)    //处理每一行\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)    //处理每一列\n\t\t{\n\t\t\tif (a[i][j] !&amp;#61; 0)   //处理非零元素\n\t\t\t{\n\t\t\t\tp &amp;#61; (MatNode *)malloc(sizeof(MatNode));\t  //创建一个新节点\n\t\t\t\tp-&amp;gt;row &amp;#61; i;\n\t\t\t\tp-&amp;gt;col &amp;#61; j;\n\t\t\t\tp-&amp;gt;tag.value &amp;#61; a[i][j];\n\t\t\t\tq &amp;#61; h[i];   //查找在行表中插入位置\n\t\t\t\twhile (q-&amp;gt;right !&amp;#61; h[i] &amp;amp;&amp;amp; q-&amp;gt;right-&amp;gt;col &amp;lt; j)\n\t\t\t\t{\n\t\t\t\t\tq &amp;#61; q-&amp;gt;right;\n\t\t\t\t}\n\t\t\t\tp-&amp;gt;right &amp;#61; q-&amp;gt;right;\n\t\t\t\tq-&amp;gt;right &amp;#61; p;\t\t\t//完成行表的操作\n\t\t\t\tq &amp;#61; h[j];      //查找在链表中插入的位置\n\n\t\t\t\twhile (q-&amp;gt;down !&amp;#61; h[j] &amp;amp;&amp;amp; q-&amp;gt;down-&amp;gt;row &amp;lt; i)\n\t\t\t\t{\n\t\t\t\t\tq &amp;#61; q-&amp;gt;down;\n\t\t\t\t}\n\t\t\t\tp-&amp;gt;down &amp;#61; q-&amp;gt;down;\n\t\t\t\tq-&amp;gt;down &amp;#61; p;\t\t\t//完成列表的插入\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n\n//输出三元组矩阵 \nvoid  DispMat_1(TSMatrix t)\n{\n\tint k;\n\tif (t.nums &amp;lt;&amp;#61; 0)\n\t{\n\t\treturn ;\n\t}\n\tcout &amp;lt;&amp;lt; t.rows &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34; &amp;lt;&amp;lt; t.cols &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34; &amp;lt;&amp;lt; t.nums &amp;lt;&amp;lt; endl;\n\tcout &amp;lt;&amp;lt; &amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcout &amp;lt;&amp;lt; &amp;#34;行数&amp;#34; &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &amp;#34; 列数&amp;#34; &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; &amp;#34;非零元素&amp;#34; &amp;lt;&amp;lt; endl;\n\tfor (k &amp;#61; 0; k &amp;lt; t.nums; k&amp;#43;&amp;#43;)\n\t{\n\t\tcout &amp;lt;&amp;lt; t.data[k].r &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; t.data[k].c &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; t.data[k].d &amp;lt;&amp;lt; endl;\n\t}\n}\n//输出十字链表矩阵\nvoid DispMat_2(MatNode *mh)\n{\n\tMatNode *p, *q;\n\tcout &amp;lt;&amp;lt; &amp;#34;行&amp;#61;&amp;#34; &amp;lt;&amp;lt; mh-&amp;gt;row &amp;lt;&amp;lt; &amp;#34;列&amp;#61;&amp;#34; &amp;lt;&amp;lt; mh-&amp;gt;col &amp;lt;&amp;lt; endl;\n\tp &amp;#61; mh-&amp;gt;tag.link;\n\twhile (p !&amp;#61; mh)\n\t{\n\t\tq &amp;#61; p-&amp;gt;right;\n\t\twhile (p !&amp;#61; q)\t\t\t\t//输出一行非零元素\n\t\t{\n\t\t\tcout &amp;lt;&amp;lt; q-&amp;gt;row &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; q-&amp;gt;col &amp;lt;&amp;lt; &amp;#39;\\t&amp;#39; &amp;lt;&amp;lt; q-&amp;gt;tag.value &amp;lt;&amp;lt; endl;\n\t\t\tq &amp;#61; q-&amp;gt;right;\n\t\t}\n\t\tp &amp;#61; p-&amp;gt;tag.link;\n\t}\n\n}\n\n\n//三元组元素赋值  \nbool Value(TSMatrix &amp;amp;t, ElemType x, int i, int j)\n{\n\tint k &amp;#61; 0, k1;\n\tif (i &amp;gt;&amp;#61; t.rows || j &amp;gt;&amp;#61; t.cols)\n\t\treturn false;\n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i&amp;gt;t.data[k].r)\n\t\tk&amp;#43;&amp;#43;;      //查找行  \n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i &amp;#61;&amp;#61; t.data[k].r &amp;amp;&amp;amp; j&amp;gt;t.data[k].c)\n\t\tk&amp;#43;&amp;#43;;     //查找列  \n\tif (t.data[k].r &amp;#61;&amp;#61; i &amp;amp;&amp;amp; t.data[k].c &amp;#61;&amp;#61; j)   //存在这样的元素  \n\t\tt.data[k].d &amp;#61; x;\n\telse               //不存在这样的元素时插入一个元素  \n\t{\n\t\tfor (k1 &amp;#61; t.nums - 1; k1 &amp;gt;&amp;#61; k; k1--)\n\t\t{\n\t\t\tt.data[k1 &amp;#43; 1].r &amp;#61; t.data[k1].r;\n\t\t\tt.data[k1 &amp;#43; 1].c &amp;#61; t.data[k1].c;\n\t\t\tt.data[k1 &amp;#43; 1].d &amp;#61; t.data[k1].d;\n\t\t}\n\t\tt.data[k].r &amp;#61; i;\n\t\tt.data[k].c &amp;#61; j;\n\t\tt.data[k].d &amp;#61; x;\n\t\tt.nums&amp;#43;&amp;#43;;\n\t}\n\treturn true;\n}\n//将指定位置的元素值赋给变量 \nbool Assign(TSMatrix t, ElemType &amp;amp;x, int i, int j)\n{\n\tint k &amp;#61; 0;\n\tif (i &amp;gt;&amp;#61; t.rows || j &amp;gt;&amp;#61; t.cols)\n\t\treturn false;\n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i&amp;gt;t.data[k].r)\n\t\tk&amp;#43;&amp;#43;;    //查找行  \n\twhile (k&amp;lt;t.nums &amp;amp;&amp;amp; i &amp;#61;&amp;#61; t.data[k].r &amp;amp;&amp;amp; j&amp;gt;t.data[k].c)\n\t\tk&amp;#43;&amp;#43;;  //查找列  \n\tif (t.data[k].r &amp;#61;&amp;#61; i &amp;amp;&amp;amp; t.data[k].c &amp;#61;&amp;#61; j)\n\t\tx &amp;#61; t.data[k].d;\n\telse\n\t\tx &amp;#61; 0;         //在三元组中没有找到表示是零元素  \n\treturn true;\n}\n\n\n//三元组下矩阵转置 \nvoid TranTat_1(TSMatrix t, TSMatrix &amp;amp;tb)\n{\n\tint k, k1 &amp;#61; 0, v;\t\t//k1记录tb中的元素个数\n\ttb.rows &amp;#61; t.rows;\n\ttb.cols &amp;#61; t.cols;\n\ttb.nums &amp;#61; t.nums;\n\tif (t.nums !&amp;#61; 0)\t//当存在非零元素时执行转置\n\t{\n\t\tfor (v &amp;#61; 0; v &amp;lt; t.cols; v&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tfor (k &amp;#61; 0; k &amp;lt; t.nums; k&amp;#43;&amp;#43;)\t\t//k用于扫描t.data的所有元素\n\t\t\t{\n\t\t\t\tif (t.data[k].c &amp;#61;&amp;#61; v)\t\t//找到一个列号为v的元素\n\t\t\t\t{\n\t\t\t\t\ttb.data[k].r &amp;#61; t.data[k].c;\t\t//将行列交换后添加到tb中\n\t\t\t\t\ttb.data[k].c &amp;#61; t.data[k].r;\n\t\t\t\t\ttb.data[k].d &amp;#61; t.data[k].d;\n\t\t\t\t\tk1&amp;#43;&amp;#43;;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n//十字链表下矩阵转置 \nvoid TranTat_2(ElemType a[M][N], ElemType c[M][N])\n{\n\tint i,j;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t\tc[j][i] &amp;#61; a[i][j];\n\t}\n\n}\n\n\n//三元组下矩阵相加 \nbool  AddMat_1(TSMatrix a, TSMatrix b, TSMatrix &amp;amp;c)\n{\n\tint i, j;\n\tElemType x, y, z;\n\tif (a.rows !&amp;#61; b.rows || a.cols !&amp;#61; b.cols)\n\t\treturn false;            //行数或列数不等时不能相加\n\tc.rows &amp;#61; a.rows;\n\tc.cols &amp;#61; a.cols;       //c的行列数与a的相同  \n\tc.nums &amp;#61; 0;\n\tfor (i &amp;#61; 0; i&amp;lt;M; i&amp;#43;&amp;#43;)\n\t\tfor (j &amp;#61; 0; j&amp;lt;N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tAssign(a, x, i, j);\n\t\t\tAssign(b, y, i, j);\n\t\t\tz &amp;#61; x &amp;#43; y;\n\t\t\tif (z!&amp;#61;0)\n\t\t\t\tValue(c, z, i, j);\n\t\t}\n\treturn true;\n}\n//十字链表下矩阵相加 \nvoid AddMat_2(ElemType a[M][N], ElemType b[M][N], ElemType c[M][N])\n{\n\tint i;\n\tint j;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tc[i][j] &amp;#61; a[i][j] &amp;#43; b[i][j];\n\t\t}\n\t}\n}\n\n\n//三元组下矩阵相乘 \nbool  MulMat_1(TSMatrix a, TSMatrix b, TSMatrix &amp;amp;c)\n{\n\tint i, j;\n\tElemType x, y, z;\n\tif (a.rows !&amp;#61; b.rows || a.cols !&amp;#61; b.cols)\n\t\treturn false;            //行数或列数不等时不能相乘\n\tc.rows &amp;#61; a.rows;\n\tc.cols &amp;#61; a.cols;       //c的行列数与a的相同  \n\tc.nums &amp;#61; 0;\n\tfor (i &amp;#61; 0; i&amp;lt;M; i&amp;#43;&amp;#43;)\n\t\tfor (j &amp;#61; 0; j&amp;lt;N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tAssign(a, x, i, j);\n\t\t\tAssign(b, y, i, j);\n\t\t\tz &amp;#61; x * y;\n\t\t\tif (z)\n\t\t\t\tValue(c, z, i, j);\n\t\t}\n\treturn true;\n}\n//十字链表下矩阵相乘 \nvoid  MulMat_2(ElemType a[M][N], ElemType b[M][N], ElemType c[M][N])\n{\n\tint i;\n\tint j;\n\tint k;\n\tint temp;\n\tfor (i &amp;#61; 0; i &amp;lt; M; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; N; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\ttemp &amp;#61; 0;\n\t\t\tfor (k &amp;#61; 0; k &amp;lt; 4; k&amp;#43;&amp;#43;)\n\t\t\t{\n\t\t\t\ttemp &amp;#61; temp &amp;#43; a[i][k] * b[k][j];\n\t\t\t}\n\t\t\tc[i][j] &amp;#61; temp;\n\t\t}\n\n\t}\n}\n\n\n//主函数实现\nint main()\n{\n\tTSMatrix ta, tb, tc;\n\n\tMatNode *td,*tf;\n\n\tint x,y,z;\n\n\tElemType a[M][N] &amp;#61; { 1, 0, 3, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1 };\n\tElemType b[M][N] &amp;#61; { 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2 };\n\tElemType c[M][N] &amp;#61; { 0 };\n\n\twhile (1)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;提示&amp;#xff1a;输入1----是三元组下的矩阵运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入2----是十字链表下的矩阵运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入3----退出&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入&amp;#xff1a;&amp;#34;;\n\t\tcin &amp;gt;&amp;gt; x;\n\t\tswitch (x)\n\t\t{\n\t\tcase 1:\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;提示&amp;#xff1a;输入1----三元组下矩阵的转置运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入2----三元组下矩阵的相加运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入3----三元组下矩阵的相乘运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入&amp;#xff1a;&amp;#34;;\n\t\t\tcin &amp;gt;&amp;gt; y;\n\t\t\tswitch (y)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;输出三元组下矩阵a&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tDispMat_1(ta);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;三元组下矩阵a转置&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tTranTat_1(ta, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tCreate_1(tb, b);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;三元组下矩阵a,b相加&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tAddMat_1(ta, tb, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tCreate_1(ta, a);\n\t\t\t\tCreate_1(tb, b);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;三元组下矩阵a,b相乘&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tMulMat_1(ta, tb, tc);\n\t\t\t\tDispMat_1(tc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;提示&amp;#xff1a;输入1----十字链表下矩阵的转置运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入2----十字链表下矩阵的相加运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;      输入3----十字链表下矩阵的相乘运算&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入&amp;#xff1a;&amp;#34;;\n\t\t\tcin &amp;gt;&amp;gt; z;\n\t\t\tswitch (z)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t\tCreate_2(td,a);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;输出十字链表下矩阵a&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tDispMat_2(td);\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;十字链表下矩阵a转置&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tTranTat_2(a, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;十字链表下矩阵a,b相加&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tAddMat_2(a, b, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;十字链表下矩阵a,b相乘&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tMulMat_2(a, b, c);\n\t\t\t\tCreate_2(tf, c);\n\t\t\t\tDispMat_2(tf);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase 3: break; \n\t\t}\n\t}\n\tcout &amp;lt;&amp;lt; endl;\n\tsystem(&amp;#34;pause&amp;#34;);\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "矩阵链乘法", "Question": ["怎么用c语言实现一下稀疏矩阵操作?", ["要求用C语言编写", "\n实现三元组，十字链表下的稀疏矩阵的加、转、乘的实现。", "\n（1）稀疏矩阵的存储", "\n（2）稀疏矩阵加法", "\n（3）矩阵乘法", "\n（4）矩阵转置", "\n\n", "求各位大神指点！！！求源代码，最好有注释", "\n\n", " "]], "Tag": "算法设计"}
