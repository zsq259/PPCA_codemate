{"Answer": "&lt;p&gt;贪心的意思就是每次都选最好的&amp;#xff0c;哈夫曼编码的贪心就是每次都选择权重最大的两个结点作为兄弟结点。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["求解哈夫曼编码时如何体现贪心思路", ["请问求解哈夫曼编码时如何体现贪心思路，就是哈夫曼编码的贪心策略吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define max 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; m&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; n,i,top&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,first&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,last&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,first1&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,last1&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[m],z[m];\ntypedef struct snodelinked{undefined\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; data;\nchar bianma;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;parent&lt;/span&gt;;\nstruct snodelinked *Rson,*Lson,*next;\n}snodelinked,*ptr;\nptr hfcreat(ptr head);\n&lt;span class=\"hljs-comment\"&gt;//void bianma(ptr root);&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; preorder(ptr root);\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; x);\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; pop(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top);\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; addq(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; first,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;last,char x);\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; delq(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;first,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; last);\nptr hfinition();\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; translate(ptr root);\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main(){undefined\nptr head,root;\nhead&amp;#61;hfinition();\nroot&amp;#61;hfcreat(head);\npreorder(root);\n&lt;span class=\"hljs-comment\"&gt;// putchar(’\\n’);&lt;/span&gt;\ngetchar();\ntranslate(root);\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\nptr hfinition(){undefined\nptr head,p;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\nhead&amp;#61;p&amp;#61;(ptr)malloc(sizeof(snodelinked));\nhead-&amp;gt;data&amp;#61;max;\nhead-&amp;gt;bianma&amp;#61;’ ‘;\ngetchar();\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;){undefined\np-&amp;gt;next&amp;#61;(ptr)malloc(sizeof(snodelinked));\np&amp;#61;p-&amp;gt;next;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c%1d&amp;#34;&lt;/span&gt;,&amp;amp;p-&amp;gt;bianma,&amp;amp;p-&amp;gt;data);\np-&amp;gt;Lson&amp;#61;p-&amp;gt;Rson&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\np-&amp;gt;parent&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\np-&amp;gt;next&amp;#61;head;\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;\n}\nptr hfcreat(ptr head){undefined\nptr t1,t2,p,q,r;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;#43;&amp;#43;){undefined\nr&amp;#61;(ptr)malloc(sizeof(snodelinked));\nt1&amp;#61;head-&amp;gt;next;\nt2&amp;#61;t1-&amp;gt;next;\nr-&amp;gt;data&amp;#61;t1-&amp;gt;data&amp;#43;t2-&amp;gt;data;\nr-&amp;gt;Lson&amp;#61;t1;\nr-&amp;gt;Rson&amp;#61;t2;\nr-&amp;gt;bianma&amp;#61;’ ‘;\nt1-&amp;gt;parent&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\nt2-&amp;gt;parent&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\nhead-&amp;gt;next&amp;#61;t2-&amp;gt;next;\np&amp;#61;head;\nq&amp;#61;p-&amp;gt;next;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;){undefined\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(r-&amp;gt;data&amp;gt;&amp;#61;q-&amp;gt;data){undefined\np&amp;#61;p-&amp;gt;next;\nq&amp;#61;p-&amp;gt;next;\n}&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{undefined\nr-&amp;gt;next&amp;#61;q;\np-&amp;gt;next&amp;#61;r;\n&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n}\n}\n}\np&amp;#61;head-&amp;gt;next;\nfree(head);\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; p;\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; preorder(ptr root){undefined\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(root-&amp;gt;bianma!&amp;#61;’ ‘){undefined\nputchar(root-&amp;gt;bianma);\nprintf( “:”);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;top;i&amp;#43;&amp;#43;){undefined\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,s[i]);\n}\nputchar(’\\n’);\n}\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(root-&amp;gt;Lson!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {undefined\npush(s,top,root-&amp;gt;Lson-&amp;gt;parent);\npreorder(root-&amp;gt;Lson);\ntop–;\n}\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(root-&amp;gt;Rson!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {undefined\npush(s,top,root-&amp;gt;Rson-&amp;gt;parent);\npreorder(root-&amp;gt;Rson);\ntop–;\n}\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; x){undefined\ns[&amp;#43;&amp;#43;top]&amp;#61;x;\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; pop(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top){undefined\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,s[top–]);\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; translate(ptr root){undefined\nptr h;\nh&amp;#61;root;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; y;\nchar x;\nx&amp;#61;getchar();\nprintf(“original:”);\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(x!&amp;#61;’\\n’){undefined\naddq(z,first1,last1,x);\nx&amp;#61;getchar();\n}\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(first1!&amp;#61;last1){undefined\ny&amp;#61;delq(z,first1,last1);\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(y&amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {undefined\nh &amp;#61; h-&amp;gt;Lson;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(y&amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) h&amp;#61;h-&amp;gt;Rson;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(h-&amp;gt;bianma!&amp;#61;’ &lt;span class=\"hljs-string\"&gt;&amp;#39;){undefined\nputchar(h-&amp;gt;bianma);\nh&amp;#61;root;\n}\n}\n}\nvoid addq(int z[],int first,int &amp;amp;last,char x){undefined\nif(x&amp;#61;&amp;#61;‘0’) z[last]&amp;#61;0;\nelse if(x&amp;#61;&amp;#61;‘1’) z[last]&amp;#61;1;\nlast&amp;#61;(last&amp;#43;1)%m;\n}\nint delq(int z[],int &amp;amp;first,int last){undefined\nreturn z[first&amp;#43;&amp;#43;];\n}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/64585133804613.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["程序设计：编写一个哈夫曼编码译码程序。", ["按词频从小到大的顺序给出各个字符（不超过30个）的词频，根据词频构造哈夫曼树，给出每个字符的哈夫曼编码，并对给出的语句进行译码。", "为确保构建的哈夫曼树唯一，本题做如下限定：", "（1）选择根结点权值最小的两棵二叉树时，选取权值较小者作为左子树。", "（2）若多棵二叉树根结点权值相等，按先后次序分左右，先出现的作为左子树，后出现的作为右子树。", "生成哈夫曼编码时，哈夫曼树左分支标记为0，右分支标记为1。", "【输入格式】", "第一行输入字符个数n；", "第二行到第n行输入相应的字符及其词频(可以是整数，与可以是小数）；", "最后一行输入需进行译码的串。", "【输出格式】", "首先按树的先序顺序输出所有字符的编码，每个编码占一行；", "最后一行输出需译码的原文，加上original:字样。", "输出中均无空格", "【样例输入】", "3", "m1", "n1", "c2", "10110", "【样例输出】", "c:0", "m:10", "n:11", "original:mnc"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;哈夫曼编码C语言问题&lt;br /&gt;参考&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/qq_45746876/article/details/109938879\" id=\"textarea_1651893947877_1651894012714_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_45746876/article/details/109938879&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["关于#c语言#的问题：从控制台输入一个字符串，使用哈夫曼编码对该字符串进行编码，输出每个字符对应的编码以及字符串的编码", ["从控制台输入一个字符串，使用哈夫曼编码对该字符串进行编码，输出每个字符对应的编码以及字符串的编码。"]], "Tag": "算法设计"}
{"Answer": "说实话，我也看不懂。\r\n1. 你要给出上下文，如果这是书上的例子，那么书上肯定会事先或事后说明这段代码是干什么。只有光代码，我根本没有耐心看完\r\n2. 你要尝试着自己去理解，如果真看不懂，至少要说出你的理解，然后我们来帮你分析。", "Konwledge_Point": "哈夫曼编码", "Question": ["跪求大神 帮忙，这段关于哈夫曼编码 的程序着实看不懂啊。。。。。。。", ["struct Codetype{//哈弗曼编码数据类型", "\nchar ", "bits;//编码流-数组，n为为哈夫曼树中叶子结点的数目，编码的长度不可能超过n", "\nint start;//编码实际在编码流数组里的开始位置", "\n};", "\nCodetype *HuffmanCode(hufmtree *tree){//哈弗曼编码的生成", "\n  int i,j,p,k;", "\n  Codetype *code; ", "\n  if(tree==NULL)", "\n     return NULL;", "\n  code=(Codetype", ")malloc(tree->n*sizeof(Codetype));//把tree的n个叶子节点生成哈夫曼码", "\n  for(i=0;in;i++)", "\n  {", "\n      printf(\"%c\",tree->node[i].data);//打印字符信息", "\n      code[i].bits=(char*)malloc(tree->n*sizeof(char));", "\n      code[i].start=tree->n-1;", "\n      j=i;", "\n      p=tree->node[i].parent;", "\n      while(p!=-1){", "\n             if(tree->node[p].lchild==j)", "\n                  code[i].bits[code[i].start]='0';", "\n             else", "\n                 code[i].bits[code[i].start]='1';", "\n             code[i].start--;", "\n             j=p;", "\n             p=tree->node[p].parent;", "\n     }", "\n     for(k=code[i].start+1;kn;k++)//打印字符编码", "\n        printf(\"%c\",code[i].bits[k]);", "\n    printf(\"\\n\");", "\n  }", "\n    return code;", "\n}"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/fduan/article/details/7837444\r\nhttp://blog.sina.com.cn/s/blog_686d0fb001012qmh.html", "Konwledge_Point": "哈夫曼编码", "Question": ["电工4课程作业2：哈夫曼编码实验", ["1) 问题描述设某编码系统共有n个字符，使用频率分别为{w1, w2, …, wn}，设计一个不等长的编码方案，使得该编码系统的空间效率最好。2) 基本要求(1) 设计数据结构；(2) 设计编码算法；(3) 分析时间复杂度和空间复杂度。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;要现成代码还是要算法&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["如何用哈夫曼编码进行通信C语言？", ["怎么用哈夫曼编码实现进行通信C语言的", "发送者的功能：", "输入待传送的字符信息；", "统计字符信息中出现的字符种类数和各字符出现的次数（频率）；", "根据字符的种类数和各自出现的次数建立哈夫曼树；", "利用以上哈夫曼树求出各字符的哈夫曼编码；", "将字符信息转换成对应的编码信息进行传送。", "接收者功能：", "接收发送者传送来的编码信息。", "利用上述哈夫曼树对编码信息进行翻译及将编码信息还原成发送前的字符信息。", "\n", "能在VC++6.0中用 .c 运行下图这结果", "\n"]], "Tag": "算法设计"}
{"Answer": "哈夫曼编码是经典的数据压缩算法，有必要好好学习一下的哦。完整实现参考：\r\nhttps://blog.csdn.net/u013571044/article/details/103042941", "Konwledge_Point": "哈夫曼编码", "Question": ["Java语言高分悬赏：怎么实现一个哈夫曼编码树？用到赏节课我们的带权树的构造，要有完整代码", ["Java语言高分悬赏：怎么实现一个哈夫曼编码树？用到赏节课我们的带权树的构造，要有完整代码"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;把void main()改成int main()&amp;#xff0c;最后return 0;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼编码问题，有错误不知怎么改", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/c_kite/article/details/53516670, 我们数据结构实验也是这个, 自己写的, 完美运行, 看完记得点赞给分啊", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构哈弗曼编码，急急急急急急！", ["在记事本软件中，放入不小于1000个英文字符的文本，命名为source.txt。", "\n编写过程，挑出文本中的不相同字符，输出文件列出每个字符的出现概率。", "\n根据字符列表文件建立字符列表的哈夫曼编码本1", "\n以哈夫曼编码本1为参照，将文本文件source.txt的内容转换为二进制码文件code.dat", "\n以哈夫曼编码本1为参照，将二进制码文件code1.dat的内容解码为target.txt明文", "\n编写函数，对比source.txt和 target.txt是否相同，不同则返回出现不同的位置点。", "\n大学生的数据结构作业，求大神帮忙啊！"]], "Tag": "算法设计"}
{"Answer": "在动态创建的过程中，总是出现未利用的空间出现乱码。通过专门建立一个变量来统计用到的数组长度，可以解决了这个问题。", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树构造过程中出现乱码？", ["程序是根据用户输入的一些列字符及其对应的权值，生成哈夫曼树，再根据生成的哈夫曼树进行编码，在测试时，发现输出每个元素对应的哈夫曼编码时，总会出现一些乱码的文字，知道原因的网友点拨一些，谢谢。程序如下：", "\n\n", " #include <iostream>\n#include<string>\nusing namespace std;\nclass HuffNode\n{\npublic:\n    char c;  // 结点的字符\n    int weight;  // 权值\n    int parent, lChild, rChild; // 左右孩子指针\n};\nclass HuffTree\n{\nprivate:\n    int Node_cnt=0;\n    HuffNode* huff=NULL;\n    string* HuffCode = NULL;\npublic:\n    HuffTree(int n, char* c, int* weights);  // 创建Huffman树\n    ~HuffTree();        // 析构函数\n     void setNode_cnt(int cnt){ Node_cnt = cnt; }\n     void select(int end, int& index1, int& index2); // 选出最小和次小叶子结点\n     void printHuffTree();\n     void setHuffCode();\n     void printHuffCode();\n\n};\nHuffTree::~HuffTree()\n{\n    delete[] huff;\n    delete[] HuffCode;\n}\nvoid HuffTree::printHuffCode()\n{\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        cout << huff[i].c << \"的哈夫曼编码为：\" << HuffCode[i] << endl;\n    }\n}\nvoid HuffTree::setHuffCode()  // 左孩子为0，右孩子为1\n{\n    HuffCode = new string[Node_cnt];\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        int son, father; // 孩子指针和双亲指针\n        int cnt = 0;\n        string str;\n        son = i;\n        father = huff[son].parent;\n        while (father != -1)\n        {\n            if (huff[father].lChild == son)\n            {\n                str.append(\"0\");\n            }\n            else\n            {\n                str.append(\"1\");\n            }\n\n            son = father;  // 孩子指针为当前双亲指针\n            father = huff[father].parent;  // 双亲指针为当前双亲指针的双亲\n        }\n        HuffCode[i] = new char[str.size()];\n        for (unsigned int j = 0; j < str.size(); j++)  // 由于求哈夫曼编码时是从叶子结点一直找到树根，故编码为之前的逆序\n        {\n            HuffCode[i][j] = str[str.size() - 1-j];// 逆序\n        }\n    }\n}\nHuffTree::HuffTree(int n,char* ch,int* weights){\n    Node_cnt = n;\n    huff = new HuffNode[2 * Node_cnt - 1];\n    for (int i = 0; i < Node_cnt; i++) // 初始化\n    {\n        huff[i].c = ch[i];\n        huff[i].weight = weights[i];\n        huff[i].lChild = -1;\n        huff[i].rChild = -1;\n        huff[i].parent = -1;\n    }\n    for (int i = Node_cnt; i < Node_cnt * 2 - 1; i++)\n    {\n        int index1 = -1, index2 = -1;\n        select(i - 1, index1, index2);// 选出最小和次小中间树结点索引\n        huff[index1].parent = i;\n        huff[index2].parent = i;\n        huff[i].weight = huff[index1].weight + huff[index2].weight;\n        huff[i].lChild = index1;\n        huff[i].rChild = index2;\n        huff[i].parent = -1;\n    }\n}\n\nvoid HuffTree::printHuffTree()\n{\n    cout << \"所建哈夫曼静态链表示如下：\" << endl;\n    cout << \"位置\\t\" << \"字符\\t\" << \"权值\\t\" << \"双亲\\t\" << \"左孩子\\t\" << \"右孩子\\t\" << endl;\n    for (int i = 0; i < Node_cnt*2-1; i++)\n    {\n        cout << i << \"\\t\" << huff[i].c << \"\\t\" << huff[i].weight << \"\\t\" << huff[i].parent << \"\\t\" << huff[i].lChild << \"\\t\" << huff[i].rChild << endl;\n    }\n}\nvoid  HuffTree::select(int end, int& index1, int& index2)\n    {\n        int min1=100000,min2 = 100000;  // 设m1为最小值，m2为次小值\n        for (int j = 0; j <=end; j++)\n        {\n            if (huff[j].parent == -1)\n            {\n                if (huff[j].weight < min1)  // 如果当前权值比最小值小\n                {\n                    index2 = index1;\n                    index1 = j;\n                    min2 = min1;\n                    min1 = huff[j].weight;\n                }\n                else if (huff[j].weight < min2)  // 如果当前权值比次小值小\n                {\n                    min2 = huff[j].weight;\n                    index2 = j;\n                }\n            }\n        }\n    }\n\nint main()\n{\n\n    int n;\n    cout << \"请输入树叶结点的个数(小于等于1结束)：\" << endl;\n    cin >> n;\n    if (n < 1) return 0;\n    char chs[256];\n    int weights[256];\n\n    for (int i = 0; i < n; i++){\n        cout << \"请输入第\" << i+1 << \"个字符及权值\" << endl;\n        cin >> chs[i] >> weights[i];\n    }\n    HuffTree tree(n,chs,weights);\n    tree.printHuffTree();\n    tree.setHuffCode();\n    tree.printHuffCode();\n\n    return 0;\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;仅供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;\nusing namespace std;\nstruct huffTree {\n    int parent;\n    int lchild;\n    int rchild;\n    int weight;\n    string flag;\n};\nstruct Lowest_node {\n    char ch;\n    int ch_num;\n};\nvoid coding&lt;span class=\"hljs-params\"&gt;(int length,huffTree *tree,int n,int &amp;amp;a,int &amp;amp;b)&lt;/span&gt; {\n    int i;\n    int r,s;\n\n    r&amp;#61;s&amp;#61;length;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(tree[i].weight&amp;lt;r\n         &amp;amp;&amp;amp; tree[i].&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; {\n            r&amp;#61;tree[i]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n            a&amp;#61;i;\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(tree[i].weight&amp;lt;s\n         &amp;amp;&amp;amp; i!&amp;#61;a\n         &amp;amp;&amp;amp; tree[i].&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; {\n            s&amp;#61;tree[i]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n            b&amp;#61;i;\n        }\n    }\n}\nvoid frequency&lt;span class=\"hljs-params\"&gt;(string str)&lt;/span&gt; {\n    int i,j;\n    int length&amp;#61;str.length&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n    Lowest_node *node&amp;#61;new Lowest_node[length];\n\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; node[i]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;0&lt;/span&gt;;\n\n    int char_type_num&amp;#61;0;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(str[i]&amp;#61;&amp;#61;node[j].ch\n            || (&amp;#39;a&amp;#39;&amp;lt;&amp;#61;node[j].ch &amp;amp;&amp;amp; node[j].ch&amp;lt;&amp;#61;&amp;#39;z&amp;#39;\n                &amp;amp;&amp;amp; str[i]&amp;#43;&lt;span class=\"hljs-attr\"&gt;32&lt;/span&gt;&amp;#61;&amp;#61;node[j].ch)&lt;/span&gt;)\n                break;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(j&amp;lt;char_type_num)&lt;/span&gt; node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;#43;&amp;#43;;\n        else {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(&amp;#39;A&amp;#39;&amp;lt;&amp;#61;str[i] &amp;amp;&amp;amp; str[i] &amp;lt;&amp;#61; &amp;#39;Z&amp;#39;)&lt;/span&gt; node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;str&lt;/span&gt;[i]&amp;#43;32;\n            else node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;str&lt;/span&gt;[i];\n            node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;#43;&amp;#43;;\n            char_type_num&amp;#43;&amp;#43;;\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;i;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(node[j].ch_num&amp;lt;node[j&amp;#43;1].ch_num)&lt;/span&gt; {\n                int temp;\n                char ch_temp;\n                temp&amp;#61;node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n                ch_temp&amp;#61;node[j]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;;\n                node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;node&lt;/span&gt;[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n                node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;node&lt;/span&gt;[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;;\n                node[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;temp&lt;/span&gt;;\n                node[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;ch_temp&lt;/span&gt;;\n            }\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt;\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;字符&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;出现了&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;次&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    huffTree *huff&amp;#61;new huffTree[2*char_type_num-1];\n    huffTree temp;\n    string *code&amp;#61;new string[2*char_type_num-1];\n\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;2*char_type_num-1;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        huff[i]&lt;span class=\"hljs-string\"&gt;.lchild&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.rchild&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;-1&lt;/span&gt;;\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; huff[j]&lt;span class=\"hljs-string\"&gt;.weight&amp;#61;node&lt;/span&gt;[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n    int min1,min2;\n    for &lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;k&lt;/span&gt;&amp;#61;char_type_num;k&amp;lt;2*char_type_num-1;k&amp;#43;&amp;#43;)&lt;/span&gt; {\n        coding&lt;span class=\"hljs-params\"&gt;(length,huff,k,min1,min2)&lt;/span&gt;;\n        huff[min1]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;k&lt;/span&gt;;\n        huff[min2]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;k&lt;/span&gt;;\n        huff[min1]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;;\n        huff[min2]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.lchild&amp;#61;min1&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.rchild&amp;#61;min2&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.weight&amp;#61;huff&lt;/span&gt;[min1]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;&amp;#43;huff[min2]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        temp&amp;#61;huff[i];\n        while &lt;span class=\"hljs-params\"&gt;(1)&lt;/span&gt; {\n            code[i]&amp;#61;temp.flag&amp;#43;code[i];\n            temp&amp;#61;huff[temp.parent];\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(temp.&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; break;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;\n        }\n    }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;字符串的每个字符huffman编码为&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; cout&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;code[i]&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;整个字符串的huffman编码为&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; {                                                                                     &lt;span class=\"hljs-string\"&gt;//S&lt;/span&gt;?\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(str[i]&amp;#61;&amp;#61;node[j].ch)&lt;/span&gt;\n                cout&amp;lt;&amp;lt;code[j];\n        }\n    }\n    delete[] node;\n    node&amp;#61;NULL;\n    delete[] huff;\n    huff&amp;#61;NULL;\n    delete[] code;\n    code&amp;#61;NULL;\n}\nint main&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; {\n    int length&amp;#61;0;\n    string str;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个字符串&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin&amp;gt;&amp;gt;str;\n    frequency&lt;span class=\"hljs-params\"&gt;(str)&lt;/span&gt;;\n    return 0;\n}\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;请输入一个字符串&amp;#xff1a;2333abcde\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符3出现了3次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符2出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符a出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符b出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符c出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符d出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符e出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符串的每个字符huffman编码为&amp;#xff1a;\n&lt;span class=\"hljs-string\"&gt;//3&lt;/span&gt;  11\n&lt;span class=\"hljs-string\"&gt;//2&lt;/span&gt;  000\n&lt;span class=\"hljs-string\"&gt;//a&lt;/span&gt;  001\n&lt;span class=\"hljs-string\"&gt;//b&lt;/span&gt;  010\n&lt;span class=\"hljs-string\"&gt;//c&lt;/span&gt;  011\n&lt;span class=\"hljs-string\"&gt;//d&lt;/span&gt;  100\n&lt;span class=\"hljs-string\"&gt;//e&lt;/span&gt;  101\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;整个字符串的huffman编码为&amp;#xff1a;\n&lt;span class=\"hljs-string\"&gt;//000111111001010011100101&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼算法的编码译码系统", ["实现一个哈夫曼编码系统，系统包括以下功能：", "\n", "字符信息统计：读取待编码的源文件SourceFile.txt，统计出现的字符及其频率。", "建立哈夫曼树：根据统计结果建立哈夫曼树。", "建立哈夫曼码表：利用得到的哈夫曼树，将各字符对应的编码表保存在文件Code.txt中。", "对源文件进行编码：根据哈夫曼码表，将SourceFile.txt中的字符转换成相应的编码文件ResultFile.txt。", "\n", "#define _CRT_SECURE_NO_WARNINGS 1", "#include <stdio.h>", "#include <malloc.h>", "#include <string.h>", "#define MAXVALUE 32767        //极大值相当于无穷大", "#define NODENUM 10            //叶子结点数", "typedef struct", "{", "    char data;                //数据域", "    int weight;                //结点的权值", "    int parent, lch, rch;    //下标", "}htNode,*huffmanTree;        ", "\n", "typedef char** huffmanCode;    //第一个", "是代表它是指针变量，说明它是数组", "                            //第二个", "说明它是指针数组，代表这个char类型数组里每个元素都是*huffmanCode变量", "\n", "int initHuffmanTree(huffmanTree& HT);                                //初始化哈夫曼树", "void creatHuffmanTree(huffmanTree& HT, int n);                        //构建哈夫曼树", "void createHuffmanCode(huffmanTree HT, huffmanCode &HC, int n);        //编写哈夫曼编码", "int main()", "{", "    huffmanTree HT ;", "    initHuffmanTree(HT);", "    huffmanCode HC;", "    creatHuffmanTree(HT,NODENUM);", "    createHuffmanCode(HT,HC,NODENUM);", "    /", "for (int i = NODENUM + 1; i <= 2 * NODENUM - 1; i++)", "        printf(\"%d \", HT[i].weight);", "/", "    for (int i = 1; i <= NODENUM; i++)                                //遍历输出编码", "    {", "        printf(\"%c:\\t\",HT[i].data);", "        printf(\"%s\\n\", HC[i]);", "    }", "    return 0;", "}", "int initHuffmanTree(huffmanTree& HT)", "{", "    HT = (htNode*)malloc(sizeof(htNode) * (2 * NODENUM));            //给HT分配2 * NODENUM个htNOde大小的htNode类型的数组", "    for (int i = 1; i <= 2 * NODENUM - 1; i++)                        //下标从1开始到2 * NODENUM", "    {", "        HT[i].parent = HT[i].lch = HT[i].rch = -1;                    //双亲和  的值都置为-1", "    }", "    printf(\"please input some weight!\\n\");", "    for (int i = 1; i <= NODENUM; i++)                                //权值只有1-n个", "    {", "        scanf(\"%d\",&HT[i].weight);                                    //给每个结点赋予权值", "    }", "        char c = getchar();                                            //这个来接收上面的回车", "    printf(\"please input some data!\\n\");", "    for (int i = 1; i <= NODENUM; i++)", "    {", "            //scanf(\"%c \",&HT[i].data);", "            char a = getchar();", "        if(a == '\\n')                                                //遇到回车就结束", "            break;", "        else", "            HT[i].data = a;                                            //给每个结点赋予数据", "    }", "\n", "return", " ", "1", ";\n", "\n", "}", "\n", "void creatHuffmanTree(huffmanTree& HT, int n)", "{", "    if (n <= 1)                                                            //如果结点数小于等于1，不创建", "        return;", "    int min1, min2;                                                        //定义两个数，来存储每次选取最小两个结点的权值", "    int rnode, lnode;                                                    //定义两个下标值，来存储每次选取最小两个结点的下标", "    for (int i = n + 1; i <= 2 * n -1; i++)                                //要生成n-1个结点，所以要操作n—1次且从下标为n+1开始存储", "    {", "        int min1 = MAXVALUE; int lnode = -1;                            //让最小值初始化为极大值，这样叶子结点的最大值再大也不会超过这个值了", "        int min2 = MAXVALUE; int rnode = -1;", "        for (int j = 1; j <= i - 1; j++)                                //因为起先是在前n个中选择最小的两个结点的权值，但新生成一个后就得在前n+1个中选择最小的两个结点的权值", "        {                                                                //假设n = 10 总结点数就得为19，那我们就只要比较18次就可以得出结果了，记住比较的次数比生成的总结点数少1", "                if (HT[j].weight < min1 && HT[j].parent == -1)            //这个小于就使得当出现相同的权值时优先考虑先出现的值，可以假设下", "                {", "                    min2 = min1;    rnode = lnode;                        //碰到比min1小的，那min1的值就给第二小的min2，下标也给它", "                    min1 = HT[j].weight; lnode = j;                        //然后最小的给min1，下标同理", "                }", "                else if (HT[j].weight < min2 && HT[j].parent == -1)        //这是第二小的判断", "                {", "                    min2 = HT[j].weight;", "                    rnode = j;", "                }", "        }", "        HT[lnode].parent = HT[rnode].parent = i;                        //最小两个结点的parent变为生成结点的下标", "        HT[i].lch = lnode; HT[i].rch = rnode;                            //生成结点的左为最小的min1的下标，右同理", "        HT[i].weight = HT[lnode].weight + HT[rnode].weight;                //生成结点的权值等于最小结点的权值相加", "    }", "\n", "}", "\n", "void createHuffmanCode(huffmanTree HT, huffmanCode& HC, int n)", "{", "    HC = (huffmanCode)malloc(sizeof(huffmanCode) * n + 1);                //申请n + 1个huffmanCode大小huffmanCode类型的临时空间", "                                                                        //因为下标是从一开始，所以我们要申请比结点多一个的结点，和哈夫曼树的结构对应，方便输出", "    char* cd = (char*)malloc(sizeof(char) * n);                            //申请n个char大小char类型的临时空间，这个临时数组记录每次遍历出来的编码", "    int start = 0,c = 0,f = 0;                                            //start为cd数组记录下标，c初始为叶子结点下标，而后就是  结点的下标，f记录双亲结点的下标", "    cd[n - 1] = '\\0';                                                    //这个就是给printf留着的，因为printf不会生成'\\0'，如果用puts就不用这句语句了", "    for (int i = 1; i <= n; i++)                                        //只要叶子结点的编码", "    {", "        start = n - 1;                                                    //这句要赋值n的话，start--要写在判断后方", "        c = i;", "        f = HT[c].parent;", "        while (f != -1)                                                    //根节点没有双亲", "        {", "            start--;", "            if (HT[f].lch == c)                                            //是左就是0，右就为1", "                cd[start] = '0';", "            else", "                cd[start] = '1';", "            c = f; f = HT[c].parent;                                    //向根结点接近", "        }", "        HC[i] = (char*)malloc(sizeof(char) * (n - start));                //给数组里的数组申请n - start个char大小的char*类型的临时空间", "        strcpy(HC[i], &cd[start]);                                        //cd里记录的编码给HC的第i个数组", "    }", "    free(cd);                                                            //释放临时空间", "}", "想问一问为什么输入字符后程序闪退\n "]], "Tag": "算法设计"}
{"Answer": "#include&lt;string&gt;\r\nusing namespace std;\r\nHuffmanTree::HuffmanTree()                             //初始化空树\r\n{\r\n Node=NULL;                                           //将树结点初始化为空 \r\n Info=NULL;                                           //将字符数组初始化为空\r\n LeafNum=0;                                           //将叶子数初始化为0\r\n}\r\nHuffmanTree::~HuffmanTree()            //析构函数\r\n{\r\n delete[] Node;                                         //释放结点空间\r\n delete[] Info;                                         //释放字符存储空间\r\n}\r\n/////////////////////////////////////////\r\n//初始化函数\r\nvoid HuffmanTree::Initialization(int WeightNum)         \r\n{\r\n int i,j,pos1,pos2,max1,max2;\r\nNode=new HuffmanNode[2*WeightNum-1];        //为哈夫曼树所需的结点申请空间         \r\nInfo=new char[2*WeightNum-1];\r\n for(i=0;i&lt;WeightNum;i++)                   //先构造weightnum个点\r\n {\r\n  cout&lt;&lt;\"请输入第\"&lt;&lt;i+1&lt;&lt;\"个字符值\";\r\n  cin&gt;&gt;Info[i];\r\n  cout&lt;&lt;\"请输入该字符的权值或频度\";\r\n  cin&gt;&gt;Node[i].weight;                                 //输入权值\r\n  Node[i].parent=-1;                                   //为根结点\r\n  Node[i].lchild=-1;                                   //无左孩子\r\n  Node[i].rchild=-1;                                   //无右孩子\r\n }\r\n//这里构造出weightnum个带权结点\r\n \r\n for(i=WeightNum;i&lt;2*WeightNum-1;i++)                  \r\n {\r\n  pos1=-1;\r\n  pos2=-1;                                            //分别用来存放当前最小值和次小值的所在单元编号 \r\n  max1=32767;                                         //32767为整型数的最大值 \r\n  max2=32767;                                        \r\n  for(j=0;j&lt;i;j++)                                  \r\n   if(Node[j].parent==-1)         \r\n\t   if(Node[j].weight&lt;max1)     \r\n    { \r\n     max2=max1;                                      //原最小值变为次小值\r\n     max1=Node[j].weight;                            //存放最小值\r\n     pos2=pos1;                                      //修改次小值所在单元编号\r\n     pos1=j;                                         //修改最小值所在单元编号\r\n    }\r\n    else\r\n     if(Node[j].weight&lt;max2)                         \r\n     {\r\n      max2=Node[j].weight;                           //存放次小值\r\n      pos2=j;                                        //修改次小值所在的单元编号\r\n     }\r\n  Node[pos1].parent=i;                               //修改父亲位置\r\n  Node[pos2].parent=i;\r\n  Node[i].lchild=pos1;                               //修改儿子位置\r\n  Node[i].rchild=pos2;\r\n  Node[i].parent=-1;                                 //表示新结点应该是根结点\r\n  Node[i].weight=Node[pos1].weight+Node[pos2].weight;\r\n } \r\n LeafNum=WeightNum; \r\n char ch;\r\n cout&lt;&lt;\"是否要替换原来文件(y/n):\";\r\n cin&gt;&gt;ch;\r\n if(ch=='y'||ch=='Y')\r\n {\r\n ofstream fop;                                       //以二进制方式打开hfmTree.dat文件，并当重新运行时覆盖原文件\r\n fop.open(\"hfmTree.dat\",ios::out|ios::binary|ios::trunc);\r\n if(fop.fail())                                      //文件打开失败\r\n  cout&lt;&lt;\"文件打开失败！\\n\";\r\n fop.write((char*)&amp;WeightNum,sizeof(WeightNum));     //写入WeightNum\r\n for(i=0;i&lt;WeightNum;i++)                            //把各字符信息写入文件\r\n {\r\n  fop.write((char*)&amp;Info[i],sizeof(Info[i]));\r\n  flush(cout);\r\n }\r\n for(i=0;i&lt;2*WeightNum-1;i++)                        //把各节点内容写入文件\r\n {\r\n  fop.write((char*)&amp;Node[i],sizeof(Node[i]));\r\n  flush(cout);\r\n }\r\n fop.close();                                        //关闭文件\r\n }\r\n cout&lt;&lt;\"哈夫曼树已构造完成。\\n\";\r\n}\r\n//编码函数\r\nvoid HuffmanTree::Encoder()\r\n{\r\n if(Node==NULL)                                       \r\n{\r\n  ifstream fip;                                        \r\n  fip.open(\"hfmTree.dat\",ios::binary|ios::in);         //以二进制方式打开hfmTree.dat文件\r\n  if(fip.fail())                                       //文件打开失败\r\n  {\r\n   cout&lt;&lt;\"文件打开失败！\\n\";\r\n   return;                                             //结束本函数\r\n  }\r\n  fip.read((char*)&amp;LeafNum,sizeof(LeafNum));           //读取叶子数\r\n  Info=new char[LeafNum]; \r\n  Node=new HuffmanNode[2*LeafNum-1];\r\n  for(int i=0;i&lt;LeafNum;i++)                           //读取字符信息\r\n   fip.read((char*)&amp;Info[i],sizeof(Info[i]));\r\n  for(int i=0;i&lt;2*LeafNum-1;i++)                           //读取结点信息\r\n   fip.read((char*)&amp;Node[i],sizeof(Node[i]));\r\n } \r\n char *Tree;                                           //用于存储需编码内容\r\n int i=0,num;\r\n char Choose;                                         \r\ncout&lt;&lt;\"从文件中读取内容的请选择1，需要重新输入的请选择2:\";\r\n cin&gt;&gt;Choose;\r\n if(Choose=='1')                                       //读取文件ToBeTran.txt\r\n {\r\n  ifstream fip1(\"ToBeTran.txt\");\r\n  if(fip1.fail())                                      //文件不存在\r\n  {\r\n   cout&lt;&lt;\"文件打开失败!\\n\";\r\n   return;                                              //结束本函数\r\n  }\r\n  char ch;\r\n  int k=0;\r\n  while(fip1.get(ch))            \r\n  {\r\n   k++;                                                 \r\n  } \r\n  fip1.close();   \r\n  Tree=new char[k+1];\r\n  ifstream fip2(\"ToBeTran.txt\");\r\n  k=0; \r\n  while(fip2.get(ch))\r\n  {\r\n   Tree[k]=ch;                                            //读取文件内容，并存到Tree中\r\n   k++;\r\n  }\r\n  fip2.close();\r\n  Tree[k]='\\0';                                           //结束标志\r\n  cout&lt;&lt;\"需编码内容为:\";\r\n  cout&lt;&lt;Tree&lt;&lt;endl;\r\n }                                                        //if(Choose=='2')\r\n else                                                   \r\n {\r\n  string tree;                        \r\n                                                        \r\n  cin.ignore();\r\n  cout&lt;&lt;\"请输入需要编码的内容(可输入任意长，结束时请按2下回车):\\n\";\r\n  getline(cin,tree,'\\n');                                //输入任意长字符串，\r\n                                                        \r\n  while(tree[i]!='\\0')\r\n   i++;\r\n  num=i;                                                //计算tree长度\r\n  i=0;\r\n  Tree=new char[num+1];\r\n  while(tree[i]!='\\0')                                  //将tree中的字符转存到Tree中\r\n  {\r\n   Tree[i]=tree[i];\r\n   i++;\r\n  }\r\n     Tree[i]='\\0';                                      //结束标志符\r\n } \r\n ofstream fop(\"CodeFile.dat\",ios::trunc);             \r\ni=0;\r\n int k=0;\r\n char *code;\r\n code=new char[LeafNum];                                //为所产生编码分配容量为LeafNum的存储空间\r\n                                                       \r\n while(Tree[k]!='\\0')                                   //对每一个字符编码\r\n {\r\n  int j,start=0;\r\n  for(i=0;i&lt;LeafNum;i++)\r\n   if(Info[i]==Tree[k])                                 \r\n    break; \r\n   j=i;\r\n  while(Node[j].parent!=-1)                             //结点j非树根\r\n  {\r\n   j=Node[j].parent;                                    //求结点j的双亲结点\r\n   if(Node[j].lchild==i)                                //是左子树，则生成代码0\r\n    code[start++]='0';\r\n   else                       \r\n    code[start++]='1';                                  //是右子树，则生成代码1\r\n   i=j;\r\n  }\r\n  code[start]='\\0';                                     //置串结束符  \r\n  for(i=0;i&lt;start/2;i++)                                //对二进制序列进行逆置\r\n  {\r\n   j=code[i];\r\n   code[i]=code[start-i-1];\r\n   code[start-i-1]=j;\r\n  }\r\n        i=0;\r\n  while(code[i]!='\\0')                                  //存储代码\r\n  {\r\n   fop&lt;&lt;code[i];\r\n   i++;\r\n  }\r\n  k++;\r\n }\r\n fop.close();\r\n cout&lt;&lt;\"编码完成！且存到文件CodeFile.dat中！\\n\\n\";\r\n} \r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//解码函数\r\n\r\nvoid HuffmanTree::Decoder()\r\n{\r\n int i=0,k=0;\r\n int j=LeafNum*2-1-1;                                        \r\n char* BitStr;\r\n \r\n ifstream fip1(\"CodeFile.dat\");                       //利用已建好的哈夫曼树将文件CodeFile中的代码进行译码\r\n if(fip1.fail())        \r\n {\r\n  cout&lt;&lt;        \"请先编码！\\n\";\r\n  return;\r\n }\r\n cout&lt;&lt;\"经译码,原内容为:\";\r\n char ch;\r\n while(fip1.get(ch))            \r\n {\r\n  k++;                                                 \r\n }\r\n fip1.close();  \r\n \r\n BitStr=new char[k+1];\r\n ifstream fip2(\"CodeFile.dat\");\r\n k=0;\r\n while(fip2.get(ch))\r\n {\r\n  BitStr[k]=ch;                                         //读取文件内容\r\n  k++;\r\n }\r\n fip2.close();                \r\n BitStr[k]='\\0';                                        //结束标志符\r\n if(Node==NULL)                                         //还未建哈夫曼树\r\n {\r\n  cout&lt;&lt;\"请先编码!\\n\";\r\n  return;\r\n }\r\n ofstream fop(\"TextFile.dat\");                          //将字符形式的编码文件写入文件CodePrin中\r\n while(BitStr[i]!='\\0')\r\n {\r\n  if(BitStr[i]=='0')\r\n   j=Node[j].lchild;                                   //往左走\r\n  else\r\n   j=Node[j].rchild;                                   //往右走\r\n  if(Node[j].rchild==-1)                               //到达叶子结点\r\n  {\r\n   cout&lt;&lt;Info[j];                                      //输出叶子结点对应的字符\r\n   j=LeafNum*2-1-1;                                   \r\n   fop&lt;&lt;Info[j];                                        //存入文件\r\n  }                                                        \r\n  i++;\r\n }\r\n fop.close(); \r\n cout&lt;&lt;\"\\n译码成功且已存到文件TextFile.dat中！\\n\\n\";\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//输出编码函数\r\n\r\nvoid HuffmanTree::Print()\r\n{\r\n char ch;\r\n int i=1;\r\n ifstream fip(\"CodeFile.dat\");           \r\n ofstream fop(\"CodePrin.dat\");          \r\n if(fip.fail())\r\n {\r\n  cout&lt;&lt;\"没有文件，请先编码！\\n\";\r\n  return;\r\n }\r\n while(fip.get(ch))\r\n {\r\n  cout&lt;&lt;ch;                                                  //读取文件内容\r\n  fop&lt;&lt;ch;                                                   //存到文件中\r\n  if(i==50)                                                \r\n  {\r\n   cout&lt;&lt;endl;\r\n   i=0;\r\n  }\r\n  i++;\r\n }\r\n cout&lt;&lt;endl;\r\n fip.close();                                               //关闭CodeFile.dat文件\r\n fop.close();                                               //关闭CodePrin.dat文件                                            \r\n}\r\n//输出哈夫曼树\r\n\r\nvoid HuffmanTree::TreePrinting()\r\n{\r\n if(Node==NULL)                                                         \r\n {\r\n  cout&lt;&lt;\"请先建立哈夫曼树！\\n\";\r\n  return;\r\n }\r\n ofstream fop(\"TreePrint.dat\");\r\n cout&lt;&lt;\"结点位置(权值)  \"&lt;&lt;\"编码  \"&lt;&lt;\"左孩子  \"&lt;&lt;\"编码\"&lt;&lt;\"右孩子('^'表示叶子)\\n\";\r\n fop&lt;&lt;\"结点位置(权值)  \"&lt;&lt;\"编码  \"&lt;&lt;\"左孩子  \"&lt;&lt;\"编码\"&lt;&lt;\"右孩子('^'表示叶子)\\n\";\r\n int i;\r\n for(i=(2*LeafNum-2);i&gt;LeafNum-1;i--)        \r\n {\r\n  cout&lt;&lt;i&lt;&lt;\"(\"&lt;&lt;Node[i].weight&lt;&lt;\")\"&lt;&lt;\"--1--\"\r\n  &lt;&lt;Node[i].lchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].lchild].weight&lt;&lt;\")\"&lt;&lt;\"--0--\"\r\n  &lt;&lt;Node[i].rchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].rchild].weight&lt;&lt;\")\"&lt;&lt;endl;\r\n  fop&lt;&lt;i&lt;&lt;\"(\"&lt;&lt;Node[i].weight&lt;&lt;\")\"&lt;&lt;\"--1--\"\r\n  &lt;&lt;Node[i].lchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].lchild].weight&lt;&lt;\")\"&lt;&lt;\"--0--\"\r\n  &lt;&lt;Node[i].rchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].rchild].weight&lt;&lt;\")\"&lt;&lt;endl;\r\n }\r\n for(;i&gt;=0;i--)\r\n {\r\n  cout&lt;&lt;i&lt;&lt;\":\"&lt;&lt;Node[i].weight&lt;&lt;\"(\"&lt;&lt;Info[i]&lt;&lt;\")---^\\n\";\r\n  fop&lt;&lt;i&lt;&lt;\":\"&lt;&lt;Node[i].weight&lt;&lt;\"(\"&lt;&lt;Info[i]&lt;&lt;\")---^\\n\";\r\n }\r\n}", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构（C++版）哈弗曼 编码", ["问题描述：利用哈夫曼编码进行信息通讯可以大大提高信道的利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传输数据预先编码；在接受端将传来的数据进行译码。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编/译码系统。试为这样的信息收发站编写一个哈夫曼码编码/译码系统。", "\n基本要求：根据某字符文件统计字符出现频度，构造Huffman 树，编制Huffman编码，并将给定字符文件编码，生成编码文件；再将给定编码文件解码，生成字符文件（要求按二进制位表示编码）。", "\n提高要求：改进Huffman编码，产生两种以上的编码方案，对同一组测试数据，用不同的编码方案编码，并从文件长度、算法复杂度等方面进行比较分析。", "\n测试数据：找一个英文文档文件或中文文档文件。", "\n用C++来编写，能实现基本要求和提高要求的。"]], "Tag": "算法设计"}
{"Answer": "您好，楼主的问题已经有解决办法，源码在：http://download.csdn.net/detail/doctorczm/6768399\r\n如果您有积分的话直接去该网址下载即可，如果积分不够的话，我可以将源码粘贴出来，希望能帮助到您！", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树算法设计编码译码", ["求大神帮忙用C++语言写一个算法设计", "\n1）从键盘上输入要进行哈夫曼编码的字符集和对应的权值。", "\n2）构造哈夫曼树的算法", "\n3）完成哈夫曼编码的算法", "\n4）完成哈夫曼译码算法。", "\n5)利用编译码算法，对给定的文本文件t1.txt的英语内容进行编码，保存到指定文件code1.txt中。然后再编写一个函数对code1.txt中的内容进行译码。", "\n要求输入哈夫曼编码时，能输出对应的字符。跪求了   真的没法写啊   想不到思路发到我哦空间或者是", "1511437725@qq.com", "都行啊"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;回答&amp;#xff1a;可以自己设置的&amp;#xff0c;哈夫曼树并不唯一&amp;#xff0c;但最终的编码长度是一样的&amp;#xff0c;即二进制位数一致&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼编码时左边的一定要比右边的小吗，还是可以任意的呀", ["图片最上面那个0.6和0.4就是1大0小，但是好像之前看到的很多都是默认1小0大，左小右大滴"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;def &lt;code class=\"language-javascript\"&gt;__init__&lt;/code&gt;(self,name&amp;#61;None,pro&amp;#61;None):&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;__init__&lt;/code&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  应该是两边各有两个_下划线&lt;/span&gt;&lt;br /&gt;你写的是只有一个下划线&lt;code class=\"language-javascript\"&gt;_init_&lt;/code&gt; &lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢!&lt;/strong&gt; 请点击下我回答下方的采纳该回答按钮。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["python,要求输入对应字符和概率，求哈夫曼编码。", ["这个报错告诉对象没有属性root，但我在_init_不是写过了吗，刚学习类，不太清楚，疑惑。", "\n", "\n", "\n", "完整代码如下", "\n", "char_get=", "input", "().split( )", "#储存字母名称", "\npercent=", "input", "().split()", "#储存概率", "\npercent=[", "int", "(percent[i])", "for", " i ", "in", " ", "range", "(", "len", "(percent))]\nlength=", "len", "(percent)", "#有多少个字符", "\n\n", "class", " ", "Nodecreate", "(", "object", "):\n    ", "def", " ", "_init_", "(", "self,name=", "None", ",pro=", "None", "):\n        self.name=name\n        self.pro=pro\n        self.left=", "None", "\n        self.right=", "None", "\n", "class", " ", "Huffman", "(", "object", "):\n    ", "def", " ", "_init_", "(", "self", "):\n        self.", "list", "=[Nodecreate(char_get(i),percent(i)) ", "for", " i ", "in", " ", "range", "(length)]", "#建立列表，用来进行比较概率。", "\n\n        ", "while", "(self.", "list", ")!=", "1", ":", "#当只剩根节点时停止运行", "\n            self.", "list", ".sort(key=", "lambda", " x:x.pro)", "#从小到大排序", "\n            self.new=Nodecreate(pro=(self.", "list", "[", "0", "].pro+self.", "list", "[", "1", "].", "list", "))", "#新的节点pro之和", "\n\n            self.new.left=self.", "list", ".pop(", "0", ")", "#左节点为列表第一个节点", "\n            self.new.right=self.", "list", ".pop(", "0", ")", "#右节点为现在第一个", "\n            self.", "list", ".append(self.", "list", ")\n        self.root=self.", "list", "[", "0", "]", "#储存根节点", "\n\n        self.myth=[", "0", " ", "for", " i ", "in", " ", "range", " (", "10", ")]\n    ", "def", " ", "order", "(", "self,now_tree,myth_length", "):", "#遍历得到huffman编码", "\n        now_node=now_tree\n        ", "if", " now_node.name==", "None", ":\n            ", "return", "\n        ", "else", ":\n            ", "print", "(now_node.name,end=", "\"\"", ")\n            ", "for", " i ", "in", " ", "range", " (myth_length):\n                ", "print", "(self.myth[i],end=", "\"\"", ")\n            ", "return", "\n        self.myth[myth_length]=", "0", "\n        self.order(now_node.left,myth_length+", "1", ")\n        self.myth[myth_length] = ", "1", "\n        self.order(now_node.right, myth_length + ", "1", ")\n    ", "def", " ", "from_print", "(", "self", "):\n        self.order(self.root,", "0", ")\n\ntree=Huffman()\ntree.from_print()\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;打眼一看&amp;#xff0c;创建的树没传出来&amp;#xff0c;要不先建个伪根节点进去建树&amp;#xff0c;要不把建的树作为返回值返回出来。函数的参数只是形参&amp;#xff0c;在函数里怎么修改也不会影响原来的变量的值。其他函数类似。还有参数类型&amp;#xff0c;C不能传&amp;amp;引用&amp;#xff0c;传指针就可以了&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["用哈夫曼树编码并译码，为啥没有输出呢？", ["#include<stdio.h>", "#include<stdlib.h>", "#include<string.h>", "typedef struct", "{", "    char data;", "    int weight;", "    int parent,lchild,rchild;", "}HTNode,*HuffmanTree;", "\n", "typedef char **HuffmanCode;", "\n", "void Select(HuffmanTree &HT,int m,int &s1,int &s2)//选择两个权值较小的结点,并返回序号", "{", "    int i,j,min1,min2;", "    min1=min2=1000;", "    for(i=1;i<=m;i++)", "        if(HT[i].parent==0&&HT[i].weight<min1)", "        {", "            min1=HT[i].weight;", "            s1=i;", "        }", "    for(j=1;j<=m&&j!=s1;j++)", "        if(HT[i].parent==0&&HT[i].weight<min2)", "        {", "            min2=HT[j].weight;", "            s2=j;", "        }", "} ", "\n", "void CreateHuffmanTree(HuffmanTree &HT,int n)//建立哈夫曼树", "{", "    if(n<=1) return;", "    HT=(HuffmanTree)malloc(sizeof(HTNode)", "2", "n);", "    int i,j,s1,s2;", "    char ch='a';", "    for(i=1;i<=(2", "n-1);++i)", "    {", "        HT[i].parent=0;", "        HT[i].lchild=0;", "        HT[i].rchild=0;", "    }", "    for(j=1;j<=n;++j,ch++)", "    {", "        if(j==1)", "        {", "            HT[1].data=' ';", "            scanf(\"%d\",&HT[j].weight);", "        }", "        else", "        {", "            HT[j].data=ch;", "            scanf(\"%d\",&HT[j].weight);", "        }", "    }", "    for(i=n+1;i<=(2", "n-1);++i)", "    {", "        Select(HT,i-1,s1,s2);", "        HT[s1].parent=i;", "        HT[s2].parent=i;", "        HT[i].weight=HT[s1].weight+HT[s2].weight;", "        HT[i].lchild=s1;", "        HT[i].rchild=s2;", "    }", "}", "\n", "void CreateHuffmanCode(HuffmanTree HT,HuffmanCode &HC,int n)//求哈夫曼编码", "{", "    HC=new char*[n+1];", "    char *cd;", "    cd=(char *)malloc(sizeof(char)*n);", "    int i,start,c,f;", "    for(i=1;i<=n;++i)", "    {", "        start=n-1;", "        c=i;", "        f=HT[i].parent;", "        while(f!=0)", "        {", "            --start;", "            if(HT[f].lchild==c) cd[start]='0';//回溯时走左分支为0，右分支为1", "            else cd[start]='1';", "            c=f;", "            f=HT[f].parent;", "        }", "        HC[i]=(char ", ")malloc(sizeof(char)", "(n-start));", "        strcpy(HC[i],&cd[start]);", "    }", "    delete(cd);", "} ", "\n", "void InterpretCode(HuffmanCode HC,char *str)//译码", "{", "    int i;", "    for(i=0;i<strlen(str);i++)", "    {", "        if(str[i]==' ') printf(\"%s\",HC[1]);", "        else{", "        if(str[i]>='A'&&str[i]<='Z') str[i]=str[i]+32;", "        if(str[i]>='a'&&str[i]<='z') printf(\"%s\",HC[str[i]-95]);", "        }", "    }", "} ", "\n", "int main()", "{", "    HuffmanTree HT;", "    HuffmanCode HC;", "    CreateHuffmanTree(HT,27);", "    printf(\"请输入报文:\");", "    CreateHuffmanCode(HT,HC,27);", "    char s[100];", "    gets(s);", "    InterpretCode(HC,s);", "    return 0;", "}"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_32445015/article/details/79972105", "Konwledge_Point": "哈夫曼编码", "Question": ["求哈夫曼对一西文文本提供最优的编、解码方案，并给出编码与解码结果。 其中编码要求正向与逆向两种方式？", ["其中编码要求正向与逆向两种方式？", "\n要求实现两个方案：从键盘输入进行解码译码和对已有的文件中的一串英文进行编译码"]], "Tag": "算法设计"}
{"Answer": "假设对n个数据huffman编码，你用一个n* n的矩阵保存即可", "Konwledge_Point": "哈夫曼编码", "Question": ["如何在MATLAB中实现哈夫曼编码？", ["我是想用二叉树实现，原本想使用MATLAB调用C语言程序，但是接口函数太难写。", "\n请问怎么在MATLAB中实现树结构，或者用别的方法实现哈夫曼编码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你树不对。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;      &lt;span class=\"hljs-attribute\"&gt;100&lt;/span&gt;\n   &lt;span class=\"hljs-attribute\"&gt;45&lt;/span&gt;   &lt;span class=\"hljs-number\"&gt;55&lt;/span&gt;\n      &lt;span class=\"hljs-attribute\"&gt;25&lt;/span&gt;     &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;\n  &lt;span class=\"hljs-attribute\"&gt;12&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;13&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;14&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;\n             &lt;span class=\"hljs-attribute\"&gt;5&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["这个哈夫曼树是答案错了还是我算错了？", ["各位大佬帮忙看看这题的第十七小问，虽然哈夫曼树不是唯一的， 但是这题我算不出选项中的答案，答案也没有写出这一问的具体步骤，是答案错了我还是我错了？", "\n", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nsourceData &amp;#61; [[&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;14&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;]]\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;BinaryTree&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, data, weight&lt;/span&gt;):\n        self.data &amp;#61; data\n        self.weight &amp;#61; weight\n        self.left &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.right &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;min2&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;li&lt;/span&gt;):\n    result &amp;#61; [BinaryTree(&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)), BinaryTree(&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;))]\n    li2 &amp;#61; []\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(li)):\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; li[i].weight &amp;lt; result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].weight:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].weight !&amp;#61; &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;):\n                li2.append(result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n            result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; li[i], result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; li[i].weight &amp;lt; result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].weight:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].weight !&amp;#61; &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;):\n                li2.append(result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n            result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; li[i]\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n            li2.append(li[i])\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result, li2\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;makeHuffman&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;source&lt;/span&gt;):\n    m2, data &amp;#61; min2(source)\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(m2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].data, m2[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].data)\n    left &amp;#61; m2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n    right &amp;#61; m2[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n\n    sumLR &amp;#61; left.weight &amp;#43; right.weight\n    father &amp;#61; BinaryTree(&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;, sumLR)\n    father.left &amp;#61; left\n    father.right &amp;#61; right\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; data &amp;#61;&amp;#61; []:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; father\n    data.append(father)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; makeHuffman(data)\n\n&lt;span class=\"hljs-comment\"&gt;# 中序&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;intermediateTraversal&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;now, result&amp;#61;[]&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; now &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result\n    intermediateTraversal(now.left, result)\n    result.append(now.data)\n    intermediateTraversal(now.right, result)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result\n\n&lt;span class=\"hljs-comment\"&gt;# 后序&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;postorderTraversal&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;now, result&amp;#61;[]&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; now &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;\n    postorderTraversal(now.left, result)\n    postorderTraversal(now.right, result)\n    result.append(now.data)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result\n\n&lt;span class=\"hljs-comment\"&gt;# 创建哈夫曼树&lt;/span&gt;\nsourceData &amp;#61; [BinaryTree(x[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], x[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; x &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; sourceData]\nm &amp;#61; makeHuffman(sourceData)\n&lt;span class=\"hljs-comment\"&gt;# 中序&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(intermediateTraversal(makeHuffman(sourceData)))\n&lt;span class=\"hljs-comment\"&gt;# 后序&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(postorderTraversal(makeHuffman(sourceData)))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["求解用python遍历哈夫曼编码（中序遍历、后序遍历）", ["已知若干个字符的权重值为=[['a',15]，['b',3]，['c',14]，['d',2]，['e',6]，['f',9]，['g',16]，['h',17]]", "\n", "设计python程序，实现构造哈夫曼树，并采用中根序或后根序遍历方法，获取每个叶子节点的哈夫曼编码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://zhuanlan.zhihu.com/p/144562146\" id=\"textarea_1659095594203_1659095689931_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://zhuanlan.zhihu.com/p/144562146&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;h4 id=\"h4_这篇文章讲的很好&amp;#xff0c;可以参考理解一下&amp;#xff0c;不懂问我哟_1659095689931\"&gt;这篇文章讲的很好&amp;#xff0c;可以参考理解一下&amp;#xff0c;不懂问我哟&lt;/h4&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["数据压缩编码中的哈夫曼编码方法是什么？", ["数据压缩编码中的哈夫曼编码方法是什么？", "怎样进行操作？希望有 大_佬解救。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;5 8 6 7 1 3 1 2 7 怎么变成树&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["关于数据压缩编码中的哈夫曼编码方法的问题", ["数据压缩编码中的哈夫曼编码方法是什么？", "怎样进行操作？希望有 大_佬解救。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;两处小错误&amp;#xff0c;见修改注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;/* run this program using the console pauser or add your own getch, system(&amp;#34;pause&amp;#34;) or input loop */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; weight;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; parent, lchild, rchild;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag;\n}HTNode, * HuffmanTree;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;** HuffmanCode;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Select&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree HT, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; end, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* s1, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* s2)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; end; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (HT[min].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            min&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].parent &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; HT[min].weight &amp;gt; HT[i].weight) {\n            min &amp;#61; i;\n        }\n    }\n    *s1 &amp;#61; min;\n    HT[min].flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    min &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; end; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (HT[min].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            min&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].parent &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; HT[min].weight &amp;gt; HT[i].weight) {\n            min &amp;#61; i;\n        }\n    }\n    *s2 &amp;#61; min;\n    HT[min].flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHuffmanTree&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree* HT, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, m &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    *HT &amp;#61; (HuffmanTree)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((m &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(HTNode));\n    HuffmanTree p &amp;#61; *HT;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; m; i&amp;#43;&amp;#43;) {\n        p[i].parent &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        p[i].lchild &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        p[i].rchild &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        p[i].flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入权值&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;(p[i].weight));\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s1, s2;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; n &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; m; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;Select&lt;/span&gt;(*HT, i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;amp;s1, &amp;amp;s2);\n        p[s1].parent &amp;#61; p[s2].parent &amp;#61; i;\n        p[i].lchild &amp;#61; s1;\n        p[i].rchild &amp;#61; s2;\n        p[i].weight &amp;#61; p[s1].weight &amp;#43; p[s2].weight;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHuffmanCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree HT, HuffmanCode* HC, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    (*HC) &amp;#61; (HuffmanCode)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((n &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!(*HC))   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;kong&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* cd &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(n * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!cd)   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;kong&amp;#34;&lt;/span&gt;);\n    cd[n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start &amp;#61; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c &amp;#61; i;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; f &amp;#61; HT[i].parent;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (f !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            --start;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[f].lchild &amp;#61;&amp;#61; c) {\n                cd[start] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                cd[start] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;\n            }\n            c &amp;#61; f;\n            f &amp;#61; HT[f].parent;\n        }\n        &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;%s&amp;#34;,cd);&lt;/span&gt;\n        (*HC)[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((n - start) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;));\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!(*HC)[i]) &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;kong&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;((*HC)[i], cd &amp;#43; start);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, (*HC)[i]);&lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;%s&amp;#34;,HC[i]); 修改&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;--&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(cd);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printHuffmanTree&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree HT, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;节点\\tweight\\tparent\\tlchild\\trchild&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d  \\t%d  \\t%d  \\t%d  \\t%d\\n&amp;#34;&lt;/span&gt;, i, \n            HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* argv[])&lt;/span&gt; &lt;/span&gt;{\n    HuffmanTree HT;\n    HuffmanCode HC;\n    &lt;span class=\"hljs-built_in\"&gt;CreateHuffmanTree&lt;/span&gt;(&amp;amp;HT, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printHuffmanTree&lt;/span&gt;(HT, &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;哈夫曼树&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;CreateHuffmanCode&lt;/span&gt;(HT, &amp;amp;HC, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;; i&amp;#43;&amp;#43;) { &lt;span class=\"hljs-comment\"&gt;// for(i&amp;#61;0;i&amp;lt;&amp;#61;8;i&amp;#43;&amp;#43;) 修改&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, HC[i]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/093773894866171.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼编码有些问题，循环和输出编码有问题", ["问题遇到的现象和发生背景", "\n", "哈夫曼编码函数有些问题，输出哈夫曼编码有些问题", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */", "\n", "typedef", " ", "struct", "{\n    ", "int", " weight;\n    ", "int", " parent,lchild,rchild;\n    ", "int", " flag;\n}HTNode,*HuffmanTree;\n", "typedef", " ", "char", "** HuffmanCode;\n\n\n", "void", " ", "Select", "(HuffmanTree HT,", "int", " end,", "int", " *s1,", "int", " *s2)", "{\n    ", "int", " min=", "1", ",i;\n    ", "for", "(i=", "1", ";i<=end;i++){\n        ", "if", "(HT[i].flag!=", "0", "){\n            ", "continue", ";\n        }\n        ", "while", "(HT[min].flag!=", "0", "){\n            min++;\n        }\n        ", "if", "(HT[i].parent==", "0", "&&HT[min].weight>HT[i].weight){\n                min=i;\n        }    \n    }\n    *s1=min;\n    HT[min].flag=", "1", ";\n    min=", "1", ";\n    ", "for", "(i=", "1", ";i<=end;i++){\n        ", "if", "(HT[i].flag!=", "0", "){\n            ", "continue", ";\n        }\n        ", "while", "(HT[min].flag!=", "0", "){\n            min++;\n        }\n        ", "if", "(HT[i].parent==", "0", "&&HT[min].weight>HT[i].weight){\n                min=i;\n        }\n    }\n    *s2=min;\n    HT[min].flag=", "1", ";\n}\n\n", "void", " ", "CreateHuffmanTree", "(HuffmanTree *HT,", "int", " n)", "{\n    ", "if", "(n<=", "1", ") ", "return", ";\n    ", "int", " i,m=", "2", "*n", "-1", ";\n    *HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    HuffmanTree p=*HT;\n    ", "for", "(i=", "1", ";i<=m;i++){\n        p[i].parent=", "0", ";\n        p[i].lchild=", "0", ";\n        p[i].rchild=", "0", ";\n        p[i].flag=", "0", ";\n    }\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "puts", "(", "\"输入权值：\"", ");\n        ", "scanf", "(", "\"%d\"", ",&(p[i].weight));\n    }\n    ", "int", " s1,s2;\n    ", "for", "(i=n+", "1", ";i<=m;i++){\n        ", "Select", "(*HT,i", "-1", ",&s1,&s2);\n        p[s1].parent=p[s2].parent=i;\n        p[i].lchild=s1;\n        p[i].rchild=s2;\n        p[i].weight=p[s1].weight+p[s2].weight;\n    }    \n}\n\n", "void", " ", "CreateHuffmanCode", "(HuffmanTree HT,HuffmanCode *HC,", "int", " n)", "{\n    ", "int", " i;\n    (*HC)=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", " *));\n     \n    ", "if", "(!(*HC)) ", "printf", "(", "\"kong\"", ");\n    ", "char", " *cd=(", "char", " *)", "malloc", "(n*", "sizeof", "(", "char", "));\n    ", "if", "(!cd) ", "printf", "(", "\"kong\"", ");\n    cd[n", "-1", "]=", "'\\0'", ";\n    \n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "int", " c=i;\n        ", "int", " f=HT[i].parent;\n        \n        ", "while", "(f!=", "0", "){\n            --start;\n            ", "if", "(HT[f].lchild==c){\n                cd[start]=", "'0'", ";\n            }", "else", "{\n                cd[start]=", "'1'", ";\n            }\n            c=f;\n            f=HT[f].parent;\n        }\n        ", "//printf(\"%s\",cd);", "\n        (*HC)[i]=(", "char", " *)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n        ", "if", "(!(*HC)[i]) ", "printf", "(", "\"kong\"", ");\n        ", "strcpy", "((*HC)[i],cd+start);\n        ", "printf", "(", "\"%s\"", ",HC[i]);\n    }\n    ", "puts", "(", "\"--\"", ");\n    ", "free", "(cd);\n}\n\n\n\n\n\n", "void", " ", "printHuffmanTree", "(HuffmanTree HT,", "int", " n)", "{\n    ", "puts", "(", "\"节点\\tweight\\tparent\\tlchild\\trchild\"", ");\n    ", "int", " i;\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "printf", "(", "\"%d  \\t%d  \\t%d  \\t%d  \\t%d\\n\"", ",i,HT[i].weight,HT[i].parent,HT[i].lchild,HT[i].rchild);\n    }\n    \n    \n}\n\n\n", "int", " ", "main", "(", "int", " argc, ", "char", " *argv[])", " ", "{\n    HuffmanTree HT;\n    HuffmanCode HC;\n    ", "CreateHuffmanTree", "(&HT,", "8", ");\n    ", "printHuffmanTree", "(HT,", "15", ");\n    ", "puts", "(", "\"哈夫曼树\"", ");\n    \n    ", "CreateHuffmanCode", "(HT,&HC,", "8", ");\n    \n    ", "int", " i;\n     ", "for", "(i=", "0", ";i<=", "8", ";i++){\n         ", "printf", "(", "\"%s\"", ",HC[i]);\n     }\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "\n", "\n", "@qzjhjxj "]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;tips:\n1&amp;#xff0c;二进制文件读写&amp;#xff08;无法使用string)\n2&amp;#xff0c;ASCII码和字符转换\n3&amp;#xff0c;哈夫曼算法\n4&amp;#xff0c;哈希思想的妙用&amp;#xff08;计算字频&amp;#xff1b;编码使用&amp;#xff09; \n\n数据结构\ntypedef struct\n{\n\tint ascii,weight,parent,lchild,rchild;//哈夫曼树&amp;#xff0c;它们依次表示&amp;#xff1a;字符的ASCII码&amp;#xff0c;双亲&amp;#xff0c;左孩子&amp;#xff0c;右孩子 \n}HTNode,*HuffmanTree;\n\n算法\n假设有n个字符&amp;#xff0c;申请2n个空间&amp;#xff0c;0号不用 ,HTree数组首地址 \n1&amp;#xff0c;初始化1&amp;#xff0c;所有成员赋0&amp;#xff1b;初始化2&amp;#xff0c;读入字符及相应的权值\n2&amp;#xff0c;令下个根节点j &amp;#61; n&amp;#43;1,在parent&amp;#61;0的点中挑选出最小值&amp;#xff0c;次小值分别记录其下标index1&amp;#xff0c;index2&amp;#xff1b;\n3&amp;#xff0c;最小值和次小值的parent&amp;#61;j;  \n*/\n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\n#include&amp;lt;stdlib.h&amp;gt; \n#include&amp;lt;fstream&amp;gt;\n#include&amp;lt;string&amp;gt;\n#include&amp;lt;stack&amp;gt;\n\n#define MIN1 0x1fffffff\n#define MIN2 0x2fffffff\n\n\n//Attention&amp;#xff1a;只可以识别英文输入法下的所有字符&amp;#xff0c;中文打出来的‘&amp;#xff1f;’都不行 \nchar code[20];//二进制读写准备 \n\ntypedef struct\n{\n\tint ascii,weight,parent,lchild,rchild;//哈夫曼树&amp;#xff0c;它们一次表示&amp;#xff1a;字符的ASCII码&amp;#xff0c;双亲&amp;#xff0c;左孩子&amp;#xff0c;右孩子 \n}HTNode,*HuffmanTree;\n\n//统计每个字符出现次数&amp;#xff1a;只有英文符号&amp;#xff0c;否则报错 \nvoid Count_Character_Occur_Frequency()\n{\n\tint cof[256];//存储相应字符出现的次数&amp;#xff0c;字符ASCII为下标。charater_occur_frequency \n\tfor(int i &amp;#61; 0; i &amp;lt; 256; i&amp;#43;&amp;#43;)//初始化字符出现次数统计表 \n\t{\n\t\tcof[i] &amp;#61; 0;\n\t}\n\t//从源文件按行读取&amp;#xff0c;并统计字符个数&amp;#xff0c;由于字符个数有限&amp;#xff0c;所以用字符的ASCII码作为数组下标&amp;#xff0c;数组值作为次数&amp;#xff0c;类似哈希映射 \n\tfstream inFile(&amp;#34;source.txt&amp;#34;,ios::in); \n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;source.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tint sum &amp;#61; 0;//总行数&amp;#xff0c;记录换行个数 \n\tstring s;//存放一行 \n\twhile(true)\n\t{\n\t\tgetline(inFile,s);\n\t\tif(!inFile)break;//避免重复读取最后一个字符 \n\t\tsum&amp;#43;&amp;#43;;\n\t\tfor(int i &amp;#61; 0; i &amp;lt; s.size(); i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tint a &amp;#61; s[i];//cout&amp;lt;&amp;lt;&amp;#34;a:&amp;#34;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;中文会溢出 \n\t\t\tcof[a]&amp;#43;&amp;#43;; //计数 \n\t\t}\n\t}\n\tinFile.close();//好习惯 \n\tint a &amp;#61; &amp;#39;\\n&amp;#39;;//换行符 \n\tcof[a] &amp;#61; sum; //换行符个数 \n\t//&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;将所有出现的字符及其次数写入文件&amp;#xff08;类似全局数组&amp;#xff09;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61; \n\tint n &amp;#61; 0;//计算出现字符总个数 \n\tfor(int i &amp;#61; 0; i &amp;lt; 256; i&amp;#43;&amp;#43;)\n\t{\n\t\tif(cof[i] !&amp;#61; 0)n&amp;#43;&amp;#43;; \n\t}\n\tfstream outFile(&amp;#34;data.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;data.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\toutFile&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;//写入字符总个数 \n\t//打印调试 \n\tfor(int i &amp;#61; 0; i &amp;lt; 256; i&amp;#43;&amp;#43;)\n\t{\n\t\tif(cof[i] !&amp;#61; 0)\n\t\t{\n\t\t\tchar ch &amp;#61; i - &amp;#39;\\0&amp;#39;;\n\t//\t\tcout&amp;lt;&amp;lt;&amp;#34;i: &amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;  字符&amp;#xff1a;&amp;#34;&amp;lt;&amp;lt;ch&amp;lt;&amp;lt;&amp;#34; cof[i]: &amp;#34;&amp;lt;&amp;lt;cof[i]&amp;lt;&amp;lt;endl;\n\t\t\toutFile&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;cof[i]&amp;lt;&amp;lt;endl;//写入文件 \n\t\t}\n\t}\n\toutFile.close();\n}\n//创建哈夫曼树 \nvoid CreateHT()\n{\n\tHuffmanTree HTree;\n\tfstream inFile(&amp;#34;data.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;data.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tint n;//节点个数\n\tinFile&amp;gt;&amp;gt;n;\n\tHTree &amp;#61; (HTNode*)malloc(2*n*sizeof(HTNode));//哈夫曼构造&amp;#xff0c;共需2n-1个&amp;#xff0c;0号单元不用\n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//初始化 1\n\t{\n\t\tHTree[i].ascii &amp;#61; HTree[i].lchild &amp;#61; HTree[i].parent &amp;#61; HTree[i].rchild &amp;#61; HTree[i].weight &amp;#61; 0;//0号单元无用 \n\t} \n\tfor(int i &amp;#61; 1; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)//初始化 2&amp;#xff0c;从文件读取ASCII码及相应权值 \n\t{\n\t\tinFile&amp;gt;&amp;gt;HTree[i].ascii&amp;gt;&amp;gt;HTree[i].weight;\n\t} \n\tinFile.close();\n/*\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//打印输出调试 \n\t{\n\t\tcout&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;endl;\n\t} \n*/\t\n\tfor(int i &amp;#61; n&amp;#43;1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//从n&amp;#43;1开始&amp;#xff0c;进行n-1次计算 \n\t{\n\t\t//寻找最小&amp;#xff0c;次小值&amp;#xff0c;记录其下标 \n\t\tint min1 &amp;#61; MIN1,min2 &amp;#61; MIN2;\n\t\tint index1 &amp;#61; 0,index2 &amp;#61; 0;\n\t\t\n\t\tfor(int j &amp;#61; 1; j &amp;lt; i; j&amp;#43;&amp;#43;)//i是即将要被填入的根节点 \n\t\t{\n\t\t\tif(HTree[j].parent &amp;#61;&amp;#61; 0)//双亲为0表示尚待操作 \n\t\t\t{\n\t\t\t\tif(min1 &amp;gt; HTree[j].weight)\n\t\t\t\t{\n\t\t\t\t\tmin2 &amp;#61; min1;//先赋给次小值 \n\t\t\t\t\tindex2 &amp;#61; index1;\n\t\t\t\t\tmin1 &amp;#61; HTree[j].weight;\n\t\t\t\t\tindex1 &amp;#61; j;\n\t\t\t\t}\n\t\t\t\telse if(min2 &amp;gt; HTree[j].weight)\n\t\t\t\t{\n\t\t\t\t\tmin2 &amp;#61; HTree[j].weight;\n\t\t\t\t\tindex2 &amp;#61; j;\n\t\t\t\t}\n\t\t\t}\n\t\t}//cout&amp;lt;&amp;lt;index1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;index2&amp;lt;&amp;lt;endl; \n\t\t\n\t\tHTree[i].weight &amp;#61; HTree[index1].weight &amp;#43; HTree[index2].weight;//双亲权值更新 \n\t\tHTree[index1].parent &amp;#61; HTree[index2].parent &amp;#61; i;//孩子的双亲节点更新\n\t\tif(HTree[index1].weight &amp;lt; HTree[index2].weight)//1&amp;#xff0c;两个节点权值不同&amp;#xff0c;左小右大 &amp;#xff1b;相同&amp;#xff0c;下标小者在左 \n\t\t{\n\t\t\tHTree[i].lchild &amp;#61; index1;//下标赋值 \n\t\t\tHTree[i].rchild &amp;#61; index2;\n\t\t}\n\t\telse if(HTree[index1].weight &amp;gt; HTree[index2].weight)\n\t\t{\n\t\t\tHTree[i].lchild &amp;#61; index2;\n\t\t\tHTree[i].rchild &amp;#61; index1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(index1 &amp;lt; index2)\n\t\t\t{\n\t\t\t\tHTree[i].lchild &amp;#61; index1;\n\t\t\t\tHTree[i].rchild &amp;#61; index2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tHTree[i].lchild &amp;#61; index2;\n\t\t\t\tHTree[i].rchild &amp;#61; index1;\n\t\t\t}\n\t\t}\n\t} \n\tfstream outFile(&amp;#34;result.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;result.txt 无法打开&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\toutFile&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;//节点个数 \n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//打印输出调试 \n\t{\n//\t\tcout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; ascii:&amp;#34;&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; weight:&amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; parent:&amp;#34;&amp;lt;&amp;lt;HTree[i].parent&amp;lt;&amp;lt;&amp;#34; lchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].lchild&amp;lt;&amp;lt;&amp;#34; rchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].rchild&amp;lt;&amp;lt;endl;\n\t\toutFile&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].parent&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].lchild&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].rchild&amp;lt;&amp;lt;endl;\t\n\t} \n\toutFile.close();\n\t\n\t//&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;建立编码表&amp;#xff0c;写入字符&amp;#xff0c;权值&amp;#xff0c;编码&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;\n\toutFile.open(&amp;#34;result.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;result.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t//利用栈从叶子出发读取每个字符的编码&amp;#xff0c;在写入文件 \n\tstack&amp;lt;char&amp;gt; code;//存储编码 \n\tfor(int i &amp;#61; 1; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)//对n个字符分别求编码 \n\t{\n\t\tint j &amp;#61; i;\n\t\tdo{\n\t\t\tint p &amp;#61; HTree[j].parent;\n\t\t\tif(p !&amp;#61; 0)\n\t\t\t{\n\t\t\t\tint l,r;\n\t\t\t\tl &amp;#61; HTree[p].lchild;\n\t\t\t\tr &amp;#61; HTree[p].rchild;\n\t\t\t\tif(j &amp;#61;&amp;#61; l)code.push(&amp;#39;0&amp;#39;);\n\t\t\t\tif(j &amp;#61;&amp;#61; r)code.push(&amp;#39;1&amp;#39;);\n\t\t\t\tj &amp;#61; p;\n\t\t\t}\n\t\t}while(HTree[j].parent !&amp;#61; 0);\n\t\t\n\t\toutFile&amp;lt;&amp;lt;HTree[i].ascii&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; &amp;#34;;//写入字符&amp;#xff0c;权值 \n\t\twhile(!code.empty())\n\t\t{\n\t\t\toutFile&amp;lt;&amp;lt;code.top();//写入编码 \n\t\t\tcode.pop();\n\t\t}outFile&amp;lt;&amp;lt;endl;\n\t} \n\toutFile.close();\n} \nvoid Encode()\n{\n\tfstream inFile(&amp;#34;result.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt; &amp;#34;result.txt&amp;#34;&amp;lt;&amp;lt;endl;\n\tstring s,codeList[256];//将编码表从文件读入该数组中&amp;#xff0c;ASCII码为下标&amp;#xff0c;类似哈希映射 \n\tint ch,w;\n\twhile(true)\n\t{\n\t\tinFile&amp;gt;&amp;gt;ch&amp;gt;&amp;gt;w&amp;gt;&amp;gt;s;\n\t\tif(!inFile)break;\n\t\tcodeList[ch] &amp;#61; s; \n\t}\n\tinFile.close();\n\t\n\tinFile.open(&amp;#34;source.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;source.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\tfstream outFile(&amp;#34;code.dat&amp;#34;,ios::out|ios::binary);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;code.dat打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\tstring s2;\n\twhile(true)\n\t{\n\t\tgetline(inFile,s);\n\t\tif(!inFile)break;\n\t\tint a;\n\t\tfor(int i &amp;#61; 0; i &amp;lt; s.size(); i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\ta &amp;#61; s[i];//转化为ASCII码 \n\t\t\tint j; \n\t\t\tfor(j &amp;#61; 0; j &amp;lt; codeList[a].size();j&amp;#43;&amp;#43;)\n\t\t\t{\t\n\t\t\t\ts2 &amp;#61; codeList[a];\n\t\t\t\tcode[j] &amp;#61; s2[j];\n\t\t\t}code[j]&amp;#61;&amp;#39;\\0&amp;#39;;//!!!关键的一句 \n\t\t\toutFile.write((char*)code,20*sizeof(char));\n\t\t}\n\t\ta &amp;#61; &amp;#39;\\n&amp;#39;;\n\t\tfor(int j &amp;#61; 0; j &amp;lt; codeList[a].size();j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tcode[j]  &amp;#61; (codeList[a])[j];\n\t\t}\n\t\toutFile.write((char*)code,20*sizeof(char));\n\t}\n\tinFile.close();\n\toutFile.close(); \n}\n//解码 \nvoid Decode()\n{\n\tfstream inFile(&amp;#34;data.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;data.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl; \n\tint n;\n\tinFile&amp;gt;&amp;gt;n;\n\tHuffmanTree HTree;\n\tHTree &amp;#61; (HTNode*)malloc(2*n*sizeof(HTNode));\n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)\n\t{\n\t\tinFile&amp;gt;&amp;gt;HTree[i].ascii &amp;gt;&amp;gt;HTree[i].weight&amp;gt;&amp;gt;HTree[i].parent&amp;gt;&amp;gt;HTree[i].lchild&amp;gt;&amp;gt;HTree[i].rchild;\t\n\t}\n\tinFile.close();\n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//打印输出调试 \n\t{\n\t//\tcout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; ascii:&amp;#34;&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; weight:&amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; parent:&amp;#34;&amp;lt;&amp;lt;HTree[i].parent&amp;lt;&amp;lt;&amp;#34; lchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].lchild&amp;lt;&amp;lt;&amp;#34; rchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].rchild&amp;lt;&amp;lt;endl;\n\t} \n/*\tinFile.open(&amp;#34;code.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;code.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n*/\n\tinFile.open(&amp;#34;code.dat&amp;#34;,ios::in|ios::binary);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;code.dat 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tfstream outFile(&amp;#34;recode.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;recode.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\tchar ch;\n\tint root &amp;#61; 2*n - 1;//char code[100];\n//\tstring s;\n\twhile(true)\n\t{\n\t\tinFile.read((char*)code,20*sizeof(char));\n\t\tif(!inFile)break;\n\t//\tcout&amp;lt;&amp;lt;&amp;#34;ch: &amp;#34;&amp;lt;&amp;lt;ch&amp;lt;&amp;lt;&amp;#34; root: &amp;#34;&amp;lt;&amp;lt;root&amp;lt;&amp;lt;endl;\t\n\t\tfor(int i &amp;#61; 0; code[i] !&amp;#61; &amp;#39;\\0&amp;#39;; i&amp;#43;&amp;#43;)\n\t\t{//cout&amp;lt;&amp;lt;ch;\n\t\t\tch &amp;#61; code[i];\n\t\t\tif(ch &amp;#61;&amp;#61; &amp;#39;0&amp;#39;)root &amp;#61; HTree[root].lchild;\n\t\telse if(ch &amp;#61;&amp;#61; &amp;#39;1&amp;#39;)root &amp;#61; HTree[root].rchild;\n\t\t\n\t\tif(HTree[root].lchild &amp;#61;&amp;#61; 0)\n\t\t{//cout&amp;lt;&amp;lt;endl;\n\t\t\tchar cht &amp;#61; HTree[root].ascii;\n\t\t\toutFile&amp;lt;&amp;lt;cht;\n\t\t\troot &amp;#61; 2*n - 1;\n\t\t} \n\t\t\n\t\t}//cout&amp;lt;&amp;lt;endl;\n\t}\n\toutFile.close();\n}\nint main()\n{\n\tCount_Character_Occur_Frequency();\n\tCreateHT();\n\tEncode();\n\tDecode();\n\treturn 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树的编码与解码", ["综合训练2\t利用哈夫曼树进行编码与解码\n一、主要目的:\n理解哈夫曼树的概念、掌握哈夫曼树的建立以及利用利用哈夫曼树进行哈夫曼编码的方法。\n二、主要内容:\n在基于哈夫易树进行哈夫易编码的基础理论之上，完成对英文文竟的编码和解码，要求如下:\n1、使用文件流方式。\n自行查阅关于文件流的相关资料。\n2、要求提供编码和解码两种方式\n3、能够打开原文文件(dataxt)，统计其中英文字母(假设均为小写)出现的频率，并以此进行哈夫曼编码(空格以及其他字符不加处理)，将每个字母的哈夫曼编码输出到屏幕，并将编码后的结果输出到码文文件(code.xt)中。\n4、能够根据3中得到的字符编码，将码文文件中的码文进行解码，得到解码后的原文(result.txt)\n5、本综合训练以个人方式完成。\n\n上交方法:各班班长统一收齐发送给我。(只要 CPP 文件，不用 data.txt 文件。)命名格式:数学X班 xxx.cpp\n\n提示:\n(1)建立的哈夫曼树结点应添加保存字母的域\n(2)教材中求哈夫曼编码的算法为递归算法，每次在递归中输出所求编码，而我们需要在对原文编码时使用每个字母的哈夫曼编码，所以应该将递归中求得的字母编码保存下来，以备后用。保存方式自行考虑。\n(3)对原文进行编码时，根据读取到的每个字符进行处理:如果是字母，则往code.txt中输出相应编码(根据2中所得编码);如果是其它字符，则不加处理，直接输出到code.txt。(4)解码应在所建立的哈夫曼树基础上进行。依次读取code.txt 文件中字符，若为0或1.则0进左子树1进右子树，直到叶子结点然后取出叶子节点中的字母输出到result.txt:如果是其它字符，则不加处理，直接输出到result.txt。"]], "Tag": "算法设计"}
{"Answer": "```\r\n new char *[n + 1]返回的是char **\r\n  HuffmanTree *HT是HTNode**类型的\r\n\t两边类型不匹配的\r\n```\r\n不知道楼主到底是要干嘛？\r\n\r\n代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。\r\n提醒：再牛×的老师也无法代替学生自己领悟和上厕所！\r\n单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。", "Konwledge_Point": "哈夫曼编码", "Question": ["霍夫曼编码的指针快要搞死我了", ["还是在学数据结构。要写霍夫曼编码了。以下我就直接po全套代码", "\n\n", "\n\n", " #include<iostream>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\n\ntypedef char **HuffmanCode;\ntypedef struct\n{\n    int weight;\n    int parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n\nvoid InsertSearch(HuffmanTree &HT, int n)\n{\n    int i, j;\n    for (i = 2; i <=n ; ++i)\n    {\n        if (HT[i].weight < HT[i -1].weight)\n        {\n            HT[0] = HT[i];\n            HT[i] = HT[i - 1];\n            for (j = i - 2; HT[0].weight < HT[j].weight; --j)\n                HT[j + 1] = HT[j];\n            HT[j + 1] = HT[0];\n        }\n    }\n}\n\nvoid Select(HuffmanTree &HT, int area, int &s1, int &s2)\n{\n    int i, flag = 1;\n    for (i = 1; (i <= area) || (flag == 1); i++)\n    {\n        if (HT[i].parent = 0)\n        {\n            s1 = i;\n            s2 = i + 1;\n            flag = 0;\n        }\n        else continue;\n    }\n}\n\nvoid CreateHuffmanTree(HuffmanTree &HT, int n)\n{\n    int m, i, s1, s2;\n    if (n <= 1)\n        return;\n    m = 2 * n - 1;\n    HT = new HTNode[m + 1];\n    for (i = 1; i <= m; ++i)\n    {\n        HT[i].parent = 0; \n        HT[i].lchild = 0; \n        HT[i].rchild = 0;\n    }\n    for (i = 1; i <= n; ++i)\n        cin >> HT[i].weight;\n\n    InsertSearch(HT, n);\n\n    for (i = n + 1; i <= m; ++i)\n    {\n        Select(HT, i - 1, s1, s2);\n        HT[s1].parent = i; HT[s2].parent = i;\n        HT[i].lchild = s1; HT[i].rchild = s2;\n        HT[i].weight = HT[s1].weight + HT[s2].weight;\n    }\n}\n\nvoid CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n)\n{\n    int i, c, start, f;\n    char *cd;\n    cd = new char[n];\n    cd[n - 1] = '\\0';\n    for (i = 1; i <= n; ++i)\n    {\n        start = n - 1;\n        c = i; f = HT[i].parent;\n        while (f != 0)\n        {\n            --start;\n            if (HT[f].lchild == 0)\n                cd[start] = '0';\n            else\n                cd[start] = '1';\n            c = f;\n            f = HT[f].parent;\n        }\n        HC[i] = new char[n - start];\n        strcpy_s(HC[i], 20, &cd[start]);\n    }\n    delete cd;\n}\n\n\nint main()\n{\n    int n;\n    cout << \"请输入 即将输入的叶子节点个数\" << endl;\n    cin >> n;\n    HuffmanTree *HT = new char *[n + 1];\n    HuffmanCode *HC = new char *[n + 1];\n    CreateHuffmanTree(*HT, n);\n    CreateHuffmanCode(*HT, *HC, n);\n}\n", "\n\n", "\n\n", "问题出在main函数构建HT 和 HC上。po图", "\n\n", "\n\n", "\n\n", "\n\n", "\n\n", "救救我吧，快被指针搞死啦"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我之前的C&amp;#43;&amp;#43; 版本&amp;#xff0c;支持压缩视频https://gitee.com/wubindong/HuffmanTreeCodeApplication/tree/master&amp;#xff0c;可以的话通过下&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["二 实践2:哈夫曼编码", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;输入节点那里有问题&amp;#xff0c;有很多\\n缓存&amp;#xff0c;解决不掉&amp;#xff0c;x没有被赋值&lt;br /&gt;修这个bug确实费劲&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Max 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; weight;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild,rchild,parent;\n} HTNode;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; HTNode HT[Max];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;InitHFMT&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//哈夫曼树初始化子函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入结点个数&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        T[i].weight&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        T[i].lchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        T[i].rchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        T[i].parent&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;InputWeight&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//输入权值子函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w,i;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; x[Max];\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n    \n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入第%d个结点:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-comment\"&gt;//scanf(&amp;#34;%c&amp;#34;,&amp;amp;x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;x:%c&amp;#34;,x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//x&amp;#61;getchar();&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//getchar();&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//T[i].ch&amp;#61;x;&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(x);\n        &lt;span class=\"hljs-comment\"&gt;//T[i].ch[0]&amp;#61;x[0];&lt;/span&gt;\n       &lt;span class=\"hljs-comment\"&gt;// strcpy(T[i].ch,x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;x:%s&amp;#34;,x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//puts(x);&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; t&amp;#61;x[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        T[i].ch&amp;#61;t;\n        &lt;span class=\"hljs-comment\"&gt;//puts(T[i].ch[0]);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//putchar(t);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//putchar(T[i].ch);&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入第%d个权值:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;w);\n        &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n        T[i].weight&amp;#61;w;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;SelectMin&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(HT T,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p1,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p2)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//选择两个结点中小的结点&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; min1&amp;#61;&lt;span class=\"hljs-number\"&gt;888888&lt;/span&gt;,min2&amp;#61;&lt;span class=\"hljs-number\"&gt;88888&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&amp;#61;i; j&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(min1&amp;gt;T[j].weight)\n            {\n                min1&amp;#61;T[j].weight;\n                *p1&amp;#61;j;\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&amp;#61;i; j&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(min2&amp;gt;T[j].weight&amp;amp;&amp;amp;j!&amp;#61;(*p1))\n            {\n                min2&amp;#61;T[j].weight;\n                *p2&amp;#61;j;\n            }\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreatHFMT&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//构造哈夫曼树&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,p1,p2;\n    &lt;span class=\"hljs-built_in\"&gt;InitHFMT&lt;/span&gt; (T);\n    &lt;span class=\"hljs-built_in\"&gt;InputWeight&lt;/span&gt;(T);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;n; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;SelectMin&lt;/span&gt;(T,i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,&amp;amp;p1,&amp;amp;p2);\n        T[p1].parent&amp;#61;T[p2].parent&amp;#61;i;\n        T[i].lchild&amp;#61;p1;\n        T[i].rchild&amp;#61;p2;\n        T[i].weight&amp;#61;T[p1].weight&amp;#43;T[p2].weight;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;hfnode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//哈夫曼编码函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    j&amp;#61;T[i].parent;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].rchild&amp;#61;&amp;#61;i)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].parent!&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        i&amp;#61;j,&lt;span class=\"hljs-built_in\"&gt;hfnode&lt;/span&gt;(T,i);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;huffmannode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//求哈夫曼编码&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n输入的权值对应的哈夫曼编码&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        a&amp;#61;i;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n权值为%i的编码是:&amp;#34;&lt;/span&gt;,T[i].weight);\n        &lt;span class=\"hljs-built_in\"&gt;hfnode&lt;/span&gt;(T,i);\n        i&amp;#61;a;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DeCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//解码&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-2&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;n:%d\\n&amp;#34;,n);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入需要译码的二进制:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();&lt;span class=\"hljs-comment\"&gt;//清除缓冲区&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(str);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,T[a].ch);\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;strlen(str):%d\\n&amp;#34;,strlen(str));&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;译码结果为&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//a&amp;#61;2*n-2;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(str[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)\n        {\n            a&amp;#61;T[a].lchild;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(str[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)\n        {\n            a&amp;#61;T[a].rchild;\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[a].lchild&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; T[a].rchild&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,T[a].ch);\n            a&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-2&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*    ********哈夫曼编码/译码器********         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             1.创建哈夫曼树;                  *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             2.进行哈夫曼编码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             3.进行哈夫曼译码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             4.退出;                          *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//主函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//int n;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//char A[100];&lt;/span&gt;\n    HT HT;\n    &lt;span class=\"hljs-built_in\"&gt;Menu&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; choice;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n请输入要进行的功能&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;choice);\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(choice)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;CreatHFMT&lt;/span&gt;(HT);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;huffmannode&lt;/span&gt;(HT);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;DeCode&lt;/span&gt;(HT,n);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;退出成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;PAUSE&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入失败&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n &amp;#34;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/204312897046122.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["求解 急 为什么哈夫曼的译码出不了", ["哈夫曼的译码出不来", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<string.h>", "\n", "#", "define", " Max 100", "\n", "typedef", " ", "struct", "\n{\n    ", "char", " ch;\n    ", "int", " weight;\n    ", "int", " lchild,rchild,parent;\n} HTNode;\n\n", "typedef", " HTNode HT[Max];\n", "int", " n;\n", "void", " ", "InitHFMT", " ", "(HT T)", "//哈夫曼树初始化子函数 ", "\n", "{\n    ", "int", " i;\n    ", "printf", "(", "\"请输入结点个数：\"", ");\n    ", "scanf", "(", "\"%d\"", ",&n);\n    ", "for", "(i=", "0", ";i<", "2", "*n", "-1", ";i++) \n    {\n        T[i].weight=", "0", ";\n        T[i].lchild=", "-1", ";\n        T[i].rchild=", "-1", ";\n        T[i].parent=", "-1", ";\n    }\n}\n", "void", " ", "InputWeight", "(HT T)", "//输入权值子函数 ", "\n", "{\n    ", "int", " w,i;\n    ", "char", " x;\n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "printf", "(", "\"输入第%d个结点:\"", ",i+", "1", ");\n        ", "scanf", "(", "\"%c\"", ",&x);\n        ", "getchar", "();\n        T[i].ch=x;\n    }\n        \n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "printf", "(", "\"输入第%d个权值:\"", ",i+", "1", ");\n        ", "scanf", "(", "\"%d\"", ",&w);\n        ", "getchar", "();\n        T[i].weight=w;\n    }\n}\n", "void", " ", "SelectMin", " ", "(HT T,", "int", " i,", "int", " *p1,", "int", " *p2)", "//选择两个结点中小的结点 ", "\n", "{\n    ", "long", " min1=", "888888", ",min2=", "88888", ";\n    ", "int", " j;\n    ", "for", "(j=", "0", ";j<=i;j++)\n    {\n     ", "if", "(T[j].parent==", "-1", ")\n        {\n         ", "if", "(min1>T[j].weight)\n         {\n             min1=T[j].weight;\n             *p1=j;\n         }\n        }\n    }\n    ", "for", "(j=", "0", ";j<=i;j++)\n    {\n        ", "if", "(T[j].parent==", "-1", ")\n        {\n            ", "if", "(min2>T[j].weight&&j!=(*p1))\n            {\n                min2=T[j].weight;\n                *p2=j;\n            }\n        }\n    }\n}\n", "void", " ", "CreatHFMT", "(HT T)", "//构造哈夫曼树 ", "\n", "{\n    ", "int", " i,p1,p2;\n    ", "InitHFMT", " (T);\n    ", "InputWeight", "(T);\n    ", "for", "(i=n;i<", "2", "*n", "-1", ";i++)\n    {\n        ", "SelectMin", "(T,i", "-1", ",&p1,&p2);\n        T[p1].parent=T[p2].parent=i;\n        T[i].lchild=p1;\n        T[i].rchild=p2;\n        T[i].weight=T[p1].weight+T[p2].weight;\n    }\n} \n", "void", " ", "hfnode", "(HT T,", "int", " i)", "//哈夫曼编码函数 ", "\n", "{\n    ", "int", " j;\n    j=T[i].parent;\n    ", "if", "(T[j].rchild==i)\n       ", "printf", "(", "\"1\"", ");\n    ", "else", "\n       ", "printf", "(", "\"0\"", ");\n    ", "if", "(T[j].parent!=", "-1", ")\n       i=j,", "hfnode", "(T,i);\n}\n", "void", " ", "huffmannode", "(HT T)", "//求哈夫曼编码 ", "\n", "{\n    ", "int", " i,j,a;\n    ", "printf", "(", "\"\\n输入的权值对应的哈夫曼编码\"", ");\n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        j=", "0", ";\n        a=i;\n        ", "printf", "(", "\"\\n权值为%i的编码是:\"", ",T[i].weight);\n        ", "hfnode", "(T,i);\n        i=a;\n     } \n}\n\n", "void", " ", "DeCode", "(HT T,", "int", " n)", "//解码", "\n", "{\n    ", "int", " i;\n    ", "char", " str[", "50", "];\n    ", "int", " a=", "2", "*n", "-2", ";\n    ", "printf", "(", "\"请输入需要译码的二进制:\\n\"", ");\n    ", "getchar", "();", "//清除缓冲区 ", "\n    ", "gets", "(str);\n    ", "printf", "(", "\"译码结果为：\\n\"", ");\n    ", "for", "(i=", "0", "; i<", "strlen", "(str);i++)\n    {\n        ", "if", "(str[i]==", "'0'", ")\n        {\n                a=T[a].lchild;\n        }\n        ", "else", " ", "if", "(str[i]==", "'1'", ")\n        {\n                a=T[a].rchild;\n        }\n        ", "if", "(T[a].lchild==", "-1", " && T[a].rchild==", "-1", ")\n        {\n            ", "printf", "(", "\"%c\"", ",T[a].ch);\n            a=", "2", "*n", "-2", ";\n        }\n    } \n    ", "printf", "(", "\"\\n\"", ");\n}\n", "void", " ", "Menu", "()", "\n    ", "{\n    ", "printf", "(", "\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\"", ");\n    ", "printf", "(", "\"*    ********哈夫曼编码/译码器********         *\\n\"", ");\n    ", "printf", "(", "\"*             1.创建哈夫曼树;                  *\\n\"", ");\n    ", "printf", "(", "\"*             2.进行哈夫曼编码;                *\\n\"", ");\n    ", "printf", "(", "\"*             3.进行哈夫曼译码;                *\\n\"", ");\n    ", "printf", "(", "\"*             4.退出;                          *\\n\"", ");\n    ", "printf", "(", "\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\"", ");\n    }\n", "int", " ", "main", "()", "//主函数 ", "\n", "{\n    ", "int", " n;\n    ", "char", " A[", "100", "];\n    HT HT;\n    ", "Menu", "();\n    ", "while", "(", "1", ")\n    {\n        ", "int", " choice;\n        ", "printf", "(", "\"\\n请输入要进行的功能：\"", ");\n            ", "scanf", "(", "\"%d\"", ",&choice);\n            ", "switch", "(choice)\n            {\n                ", "case", " ", "1", ":\n                    ", "CreatHFMT", "(HT);\n                ", "break", ";\n                ", "case", " ", "2", ":\n                    ", "huffmannode", "(HT);\n                    ", "break", ";\n                ", "case", " ", "3", ":\n                    ", "DeCode", "(HT,n);\n                    ", "break", ";\n                ", "case", " ", "4", ":\n                    ", "printf", "(", "\"退出成功！\\n\"", ");\n                    ", "system", "(", "\"PAUSE\"", ");\n                    ", "break", "; \n                ", "default", ":\n                    ", "printf", "(", "\"输入失败！\\n\"", ");\n                    ", "break", ";\n                    \n            }\n    }\n    ", "printf", "(", "\"\\n \"", ");\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/xiaoting451292510/article/details/12559421", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树的编码链式存储怎么画，译码链式存储怎么画？", ["哈夫曼树的编码存储怎么画，译码存储怎么画？像二叉树那样画的话那它的0,1序列标在哪里"]], "Tag": "算法设计"}
{"Answer": "这个属于数据的序列化和反序列化问题。在这里是对树的序列化和反序列化。\r\n最简单的方式莫过于在内存里以完全二叉树的空间存储哈夫曼树，然后文件里直接写入这块内存就好了。", "Konwledge_Point": "哈夫曼编码", "Question": ["求教，哈夫曼树问题，感觉好难", ["大佬们，哈夫曼编码的问题，编码完毕后，下次不初始化，怎么从文件中读出哈夫曼树？怎么打印哈夫曼树？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/hold_twenty/article/details/95602451\"&gt;https://blog.csdn.net/hold_twenty/article/details/95602451&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼算法应用(数据结构)", ["求大神解答\n哈夫曼算法的应用\n1.问题描述\n假设某文本文档只包含26个英文字母，应用哈夫曼算法对该文档进行压缩和解压缩操作，使得该文档占用较少的存储空间。\n2.基本要求\n(1)假设文档内容从键盘输入；\n(2)设计哈夫曼算法的存储结构；\n(3)设计哈夫曼编码和解码算法；\n(4)分析时间复杂度和空间复杂度。\n3.设计思想\n对于给定的文档，首先通过扫描确定文档中出现了哪些英文字母以及出现的次数，以出现的次数作为叶子结点的权值构造哈夫曼树，获得各字符的哈夫曼编码；然后再扫描一遍文档将其进行哈夫曼压缩编码，将文本文档转换为二进制编码输出；最后将该二进制流进行解码，并与原文档进行对照，以验证算法的正确性。哈夫曼算法的存储结构以及哈夫曼算法请参见主教材5.7.1节。\n【思考题】如果对任意以文件形式存在的文本文档，如何实现应用哈夫曼算法进行压缩和解压缩？"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你可以参考下这个问题的回答, 看看是否对你有帮助, 链接: &lt;a href=\"https://ask.csdn.net/questions/7517842\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7517842&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;这篇博客你也可以参考下&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/Edward_Mcc/article/details/122567436\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;哈夫曼编码实验报告&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;这篇博客也不错, 你可以看下&lt;a href=\"https://blog.csdn.net/Edward_Mcc/article/details/122567436\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;哈夫曼编码实验报告&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树编码以及译码", ["求一个哈夫曼树编码以及译码的小程序，26个字母以及权值已经给出，希望以此建立哈夫曼树。在由键盘输入字符串或者二进制数时可以根据此树进行编码或译码"]], "Tag": "算法设计"}
{"Answer": "步骤1.构造哈夫曼树，\n2.输入字符个数\n3.输入字符\n4.输入权值\n5.遍历打印输出树\n6.乱序输入字符，输出编码\n7.乱序输入编码，输出对应字符", "Konwledge_Point": "哈夫曼编码", "Question": ["一个程序，哈夫曼树的构造遍历打印，编码解码，缺少遍历和打印", ["#include ", "\n#include     /* 数组头文件 ", "/", "\n#include ", "\n#define MAX 999    /", " 定义长度 ", "/", "\ntypedef struct{     /", " 定义哈夫曼编码的结构数组 ", "/", "\n    char data;", "\n    int weight;    /", " 定义权值 ", "/", "\n    int parent;", "\n    int lchild;", "\n    int rchild;", "\n}huffmannode;", "\ntypedef struct{      /", " 定义保存哈夫曼结构体 ", "/", "\n    char bits[50];", "\n    int start;", "\n}huffmancode ;", "\nvoid main()", "\n{", "\n    huffmannode ht[100];    /", " 定义储存权值的空间 ", "/", "\n    huffmancode cd[100];", "\n    char string[100];      /", " 定义数组存储空间 ", "/", "\n    char hcd[100];", "\n    int i,j,x,y,s1,s2,m1,m2,n,c,f,k;", "\n    printf(\"please input the n =\");     /", " 输入字符的个数 ", "/", "\n    scanf(\"%d\",&n);", "\n    printf(\"\\n============================\\n\");", "\n    for(i=0;i<n;i++)", "\n    {", "\n        getchar();                 /", " 获得输入的字符 ", "/", "\n        printf(\"please input the value :\");", "\n        scanf(\"%c\",&ht[i].data);            /", " 输入字符函数 ", "/", "\n        printf(\"please input the weight:\\n\");", "\n        scanf(\"%d\",&ht[i].weight);", "\n    }", "\n    printf(\"\\n=============================\\n\");", "\n    for(i=0;i<2*n-1;i++)", "\n    {", "\n        ht[i].parent=ht[i].lchild=ht[i].rchild=-1;  /", " 初始化父结点，左右子结点 ", "/", "\n    }", "\n    for (i=n;i<2*n-1;i++)", "\n    {", "\n        s1=s2=0;                        /", " 初始化变量 ", "/", "\n        m1=m2=MAX;", "\n        for (j=0;j<i;j++)", "\n     {", "\n            if (ht[j].weight<m1 &&ht[j].parent==-1) /", " 寻找无父结点的最小值 ", "/", "\n            {", "\n                m2=m1;", "\n                s2=s1;", "\n                m1=ht[j].weight;", "\n                s1=j;                           /", " 寻找当前最小值 ", "/", "\n            }", "\n            else if(ht[j].weight<m2 &&ht[j].parent==-1) /", " 寻找无父结点的次小值 ", "/", "\n            {", "\n                m2=ht[j].weight;", "\n                s2=j;", "\n            }                              /", " 寻找次小值 ", "/", "\n        }", "\n        ht[s1].parent=i;                 /", " s1的父结点为i ", "/", "\n        ht[s2].parent=i;", "\n        ht[i].weight=m1+m2;             /", " 最小值的权值相加为i的权值 ", "/", "\n        ht[i].lchild=s1;                /", " i的左子为s1 ", "/", "\n        ht[i].rchild=s2;                /", " i的右子为s2 ", "/", "\n    }", "\n    for(i=0;i<n;i++)", "\n    {", "\n        cd[i].start=n;", "\n        x=i;", "\n        y=ht[x].parent;                /", " 记录父结点 ", "/", "\n        while (y!=-1)", "\n        {", "\n            if (ht[y].lchild==x)", "\n                cd[i].bits[cd[i].start]='0';   /", " 给字符赋0值 ", "/", "\n            else", "\n               cd[i].bits[cd[i].start]='1';    /", " 给字符赋1值 ", "/", "\n            cd[i].start--;", "\n            x=y;", "\n            y=ht[y].parent;", "\n        }", "\n    }", "\n    printf(\"\\cout the huffmancode:\\n\");", "\n    for (i=0;i<n;i++)", "\n    {", "\n        printf(\"%c:\",ht[i].data);         /", " 输出字符 ", "/", "\n        for(j=cd[i].start;j<=n;j++){", "\n            printf(\"%c\",cd[i].bits[j]);    /", " 输出字符的01代码 ", "/", "\n        }", "\n         printf(\"\\n\");", "\n    }", "\n    printf(\"\\n=============================\\n\");", "\n    printf(\"\\n Please input the message:\\n\");", "\n    scanf(\"%s\",string);                    /", " 输入字符串 ", "/", "\n    for(i=0;string[i]!='0';i++)", "\n    {", "\n        for(c=0;c<=n;c++)", "\n            if(string[i]==ht[c].data)  /", " 寻找与输入字符相匹配的字母 ", "/", "\n            {", "\n                for(j=cd[c].start;j<=n;j++)", "\n                    printf(\"%c\",cd[c].bits[j]);   /", " 输出字母代码 ", "/", "\n                break;", "\n            }", "\n    }", "\n    printf(\"\\n=============================\\n\");", "\n    printf(\"Please input the HuffmanCode:\\n\");", "\n    scanf(\"%s\",hcd);                  /", " 输入0、1代码 ", "/", "\n    f=2*n-2;", "\n    for(i=0;hcd[i]!='\\0';i++)", "\n    {", "\n        if(hcd[i]=='0')               /", " 判断输入为0，寻找左子 ", "/", "\n            f=ht[f].lchild;", "\n        else if(hcd[i]=='1')", "\n            f=ht[f].rchild;           /", " 判断输入为1，寻找右子 ", "/", "\n        if(f<n)", "\n        { ", "\n            printf(\"%c\",ht[f].data);  /", " 输出字符串 */", "\n            f=2*n-2;", "\n        }", "\n    }", "\n    printf(\"\\n\");", "\n    getch();", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/786620974866127.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树如何画出，以及对应的哈夫曼i编码如何求得", ["哈夫曼树如何画出，以及对应的哈夫曼i编码如何求得，求解答，感谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;做过一个比较类似的&amp;#xff0c;需要可以给你&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/606184238656138.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["怎样把句号，逗号作为前缀进行编码", ["利用哈夫曼编码进行压缩英文短文，还需要包括句号，逗号，利用单词重复进行编码，"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;32行for循环后面的分号删掉&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["为什么无论输入什么数，打出来的哈夫曼数都是一样的，而且编码打不出来", ["(为什么无论输入什么数，打出来的哈夫曼数都是一样的，而且编码打不出来)", "\n", "#", "include", " ", "<stdio.h>", " ", "\n", "#", "include", " ", "<stdlib.h>", " ", "\n", "#", "include", " ", "<string.h>", " ", "\n", "#", "define", " N 8", "\n", "//#define M 2*N-1", "\n", "//哈夫曼树类型定义 ", "\n", "typedef", " ", "struct", "    \n{ \n    ", "unsigned", " ", "int", " weight; \n    ", "unsigned", " ", "int", " parent, lchild, rchild; \n}HTNode,*HuffmanTree;\n", "typedef", " ", "char", " **HuffmanCode;\nHuffmanTree HT;\nHuffmanCode HC;\n", "char", " *cd;\n", "//字符、权值、对应编码组成的结构体类型 ", "\n", "struct", " ", "s", "\n{  \n    ", "char", " data;  \n    ", "int", " weight;  \n    ", "char", " code[N]; \n}; \ns S[N];\n", "//此处函数定义请自行编写 ", "\n", "void", " ", "Init", "(s S[N],", "int", " *w)", "\n", "{\n    ", "int", " i;\n    ", "printf", "(", "\"输入%d个字符，及他们的权值:\\n\"", ",N);\n    ", "for", "(i=", "1", ";i<=N;i++)\n    {\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%c\"", ",&S[i", "-1", "].data);\n        ", "getchar", "();\n        ", "printf", "(", "\"请输入该字符的权值：\"", ");\n        ", "scanf", "(", "\"%d\"", ",&w[i", "-1", "]);\n        ", "getchar", "();\n    }\n}\n", "void", " ", "Select", "(HuffmanTree HT,", "int", " n,", "int", " &s1,", "int", " &s2)", "\n", "{\n    ", "int", " minn=", "99999998", ",maxx=", "99999999", ",i=", "1", "; \n    \n    s1=s2=", "0", "; \n    \n    ", "for", "( i=", "1", "; i<=n;i++) \n        \n    { \n        \n        ", "if", "(HT[i].parent==", "0", ") \n            \n        { \n            \n            ", "if", "(HT[i].weight<minn) \n                \n            { \n                \n                minn=HT[i].weight;s1=i; \n            } \n            \n        } \n        \n    } \n    \n    ", "int", " t=HT[s1].weight; \n    \n    HT[s1].weight=maxx; \n    \n    minn=", "99999998", "; \n    \n    ", "for", "( i=", "1", "; i<=n; i++) \n        \n    { \n        \n        ", "if", "(HT[i].parent==", "0", ") \n            \n        { \n            \n            ", "if", "(HT[i].weight<minn) \n                \n            { \n                \n                minn=HT[i].weight; \n                \n                s2=i; \n                \n            } \n            \n        } \n        \n    } \n    \n    HT[s1].weight=t;\n}\n\n", "void", " ", "Huffmancoding", "(HuffmanTree &HT,HuffmanCode &HC,", "int", " n,", "int", " *w)", "\n", "{\n    ", "int", " i,c,f,s1=", "0", ",s2=", "0", ",start,m=", "2", "*n", "-1", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ") * ", "sizeof", "(HTNode)); \n    ", "if", "(n<=", "1", ")", "return", "; \n", "/*    for(i=1;i<=n;i++)\n\n    {undefined\n\n       HT[i].weight=w[i];\n\n       HT[i].parent=HT[i].rchild=HT[i].lchild=0;\n\n    }\n    for(;i<=m;i++)\n\n    {undefined\n\n       HT[i].weight=HT[i].parent=HT[i].rchild=HT[i].lchild=0;\n\n    }*/", "\n    ", "for", "  (p=HT+", "1", ", i=", "1", "; i<=n; ++i, ++p){        \n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=w[i", "-1", "];\n    }  ", "/**p={ * w, 0, 0, 0};*/", "   ", "//用给定的n个", "\n    ", "//权值 ，构造n棵只有一个根结点的二叉树", "\n    \n    ", "for", " (;i<=m;i++,++p){\n        p->weight=", "0", ";\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n    }\n    \n    ", "for", "(i=n+", "1", ";i<=m;i++);\n    { \n        \n        ", "Select", "(HT,i", "-1", ",s1,s2);\n    \n        HT[s1].parent=i;\n    \n        HT[s2].parent=i;\n        \n        HT[i].lchild=s1;\n        \n        HT[i].rchild=s2;\n    \n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", " *));", "//分配n个字符编码的头指针向量", "\n    cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));", "//分配求编码的工作空间，用cd指向该空间", "\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", " (i=", "1", ";i<=n;i++)\n    {\n        start=n", "-1", ";\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent)\n        {\n            ", "if", " (HT[f].lchild==c) \n                cd[--start]=", "'0'", ";\n            ", "else", " \n                cd[--start]=", "'1'", ";\n        }\n        HC[i]=(", "char", " *)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n        ", "strcpy", "(HC[i],&cd[start]);\n        ", "// strcpy(S[i].code,&HC[i]);", "\n    }\n    ", "/*    for( i=1;i<=N;i++)\n    {\n    S[i].weight=\n    S[i].data=\n    //        strcpy(S[i].code,HC[i]);\n    }\n    */", "\n    ", "free", "(cd);\n}\n\n", "int", " ", "main", "()", " \n", "{  ", "//哈夫曼树的建立和编码的生成  ", "\n    ", "//打印输出哈夫曼树数据 ", "\n    ", "//用户输入任意一个由N个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串 ", "\n    ", "//用户输入哈夫曼编码(由01组成)，将进行解码，输出对应的字符串 ", "\n    ", "int", " a[", "100", "];\n    ", "int", " k,*w,n,m=", "2", "*N", "-1", ";\n    w=a;\n    ", "//    HTNode HT[M-1];", "\n    ", "//    HTCode HC[N+1];", "\n    ", "Init", "(S,w);\n    ", "Huffmancoding", "(HT,HC,", "8", ",w);\n    ", "printf", "(", "\"\\n哈夫曼树如下所示:\\n\"", ");\n    ", "for", " (", "int", " v=", "1", ";v<=m;v++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[v].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[v].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[v].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[v].rchild);\n    }\n    ", "printf", "(", "\"\\n%d个字符的字符、权值以及哈夫曼编码如下：\\n\"", ",N);\n    ", "for", "(k=", "1", ";k<=n;k++);\n    {\n        ", "printf", "(", "\"%-3c%-3d%s\\n\"", ",S[k].data,S[k].weight,HC[k]);\n        ", "//puts(S[k].code);", "\n        ", "//printf(\"%c\\t\",HC[k]);", "\n    }\n    ", "return", " ", "0", "; \n} \n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/612858274936127.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;那么加权路径长度WPL&amp;#61;(9&amp;#43;7&amp;#43;8)×2&amp;#43;4×3&amp;#43;(2&amp;#43;3)×4&amp;#61;80&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;结点到树根之间的路径长度与该结点上权的乘积&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/477338274936134.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;构造哈夫曼树的办法是&amp;#xff1a;在W中选出两个权小结点&amp;#xff0c;并同时计算出它们的和&amp;#xff0c;如果两个数的和正好是下一步的两个最小数的其中的一个&amp;#xff0c;那么这个树直接往上生长就可以了&amp;#xff0c;如果这两个数的和比较大&amp;#xff0c;不是下一步的两个最小数的其中一个&amp;#xff0c;那么就并列生长。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树，求解析，数据结构", ["35.(填空题， 2.5 分)", "有一份电文中共使用 6个字符:a,b,c,d,e,f,它们的出现频率依次为2,3,4,7,8,9,试构造一棵哈夫曼树,则其加权路径长度WPL为多少，求解析"]], "Tag": "算法设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201905/02/1556800260_830294.jpg)\r\n![图片说明](https://img-ask.csdn.net/upload/201905/02/1556800272_950431.jpg)", "Konwledge_Point": "哈夫曼编码", "Question": ["二叉树，哈夫曼问题，求大神指点，多谢。", ["1、已知一棵二叉树的前序遍历为：ABCDEFHIKLGJ，中序遍历序列为：CBAFEIHLKDGJ，画出次二叉树的逻辑结构图。", "\n2、已知一段电文仅含8个字符{C1,C2,……,C8}，且每个字符在电文中出现的频率构成权集{13,2,11,20,9,23,17,5}，求各个字符的哈夫曼编码"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;运行结果及代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/237687711556115.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXLEN 30&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXLEAF 130&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXWEIGHT 1&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//结点&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;HuffmanNode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; node;      &lt;span class=\"hljs-comment\"&gt;//结点字符&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; weight;  &lt;span class=\"hljs-comment\"&gt;//结点权值&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; parent;     &lt;span class=\"hljs-comment\"&gt;//父结点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild;     &lt;span class=\"hljs-comment\"&gt;//左子节点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rchild;     &lt;span class=\"hljs-comment\"&gt;//右子节点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; no;         &lt;span class=\"hljs-comment\"&gt;//节点编号&lt;/span&gt;\n};\n&lt;span class=\"hljs-comment\"&gt;//每个结点的编码&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;HuffmanCode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; bit[MAXLEN];  &lt;span class=\"hljs-comment\"&gt;//存储哈夫曼编码&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length;        &lt;span class=\"hljs-comment\"&gt;//每个结点编码的长度&lt;/span&gt;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanNode a, HuffmanNode b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.weight &amp;lt; b.weight;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanNode a, HuffmanNode b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.no &amp;lt; b.no;\n}\n\nHuffmanNode HNode[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * MAXLEAF - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\nHuffmanCode HCode[MAXLEAF];\n\n\n\n\n&lt;span class=\"hljs-comment\"&gt;//构造哈夫曼树&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHafman&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; buf[], &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; w[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//初始化结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        HNode[i].weight &amp;#61; MAXWEIGHT;\n        HNode[i].parent &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        HNode[i].lchild &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        HNode[i].rchild &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        HNode[i].no &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        HNode[i].node &amp;#61; buf[i];\n        HNode[i].weight &amp;#61; w[i];\n        HNode[i].no &amp;#61; i;\n    }\n\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, min2 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;sort&lt;/span&gt;(HNode, HNode &amp;#43; n &amp;#43; i, cmp1);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n &amp;#43; i; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[min1].parent !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n            {\n                min1&amp;#43;&amp;#43;;\n                min2 &amp;#61; min1 &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[min2].parent !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n                min2&amp;#43;&amp;#43;;\n        }\n        HNode[n &amp;#43; i].lchild &amp;#61; HNode[min1].no;\n        HNode[n &amp;#43; i].rchild &amp;#61; HNode[min2].no;\n        HNode[n &amp;#43; i].weight &amp;#61; HNode[min1].weight &amp;#43; HNode[min2].weight;\n        HNode[n &amp;#43; i].no &amp;#61; n &amp;#43; i;\n        HNode[min1].parent &amp;#61; HNode[n &amp;#43; i].no;\n        HNode[min2].parent &amp;#61; HNode[n &amp;#43; i].no;\n\n    }\n    &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;哈夫曼树构建成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//获取每个字符的哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Getcode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; offset &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, p, j;\n    HuffmanCode hc;\n\n    &lt;span class=\"hljs-built_in\"&gt;sort&lt;/span&gt;(HNode, HNode &amp;#43; offset, cmp2);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        hc.length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        j &amp;#61; i;\n        p &amp;#61; HNode[j].parent;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[p].lchild &amp;#61;&amp;#61; HNode[j].no)\n                hc.bit[hc.length] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                hc.bit[hc.length] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            hc.length&amp;#43;&amp;#43;;\n            j &amp;#61; HNode[p].no;\n            p &amp;#61; HNode[j].parent;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; hc.length; k&amp;#43;&amp;#43;)\n            HCode[i].bit[k] &amp;#61; hc.bit[hc.length - k - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        HCode[i].length &amp;#61; hc.length;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//显示哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;showHafman&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//输出哈夫曼编码&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[i].node &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\n&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[i].node &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\r&amp;#39;&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\r&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[i].node &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\t&amp;#39;&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            cout &amp;lt;&amp;lt; HNode[i].node &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; HCode[i].length; j&amp;#43;&amp;#43;)\n            cout &amp;lt;&amp;lt; HCode[i].bit[j];\n        cout &amp;lt;&amp;lt; endl;\n    }\n}\n\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; buf[MAXLEAF]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; w[MAXLEAF]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0.07&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.19&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.02&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.06&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.32&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.03&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.21&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.13&lt;/span&gt;};\n\n    \n    &lt;span class=\"hljs-built_in\"&gt;CreateHafman&lt;/span&gt;(buf, w, n); &lt;span class=\"hljs-comment\"&gt;//创建哈夫曼树&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Getcode&lt;/span&gt;(n);&lt;span class=\"hljs-comment\"&gt;//获取每个字符的编码&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;showHafman&lt;/span&gt;(n);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["利用哈弗曼树编码原理，对字符进行编码（C++,C语言都可）", ["题目：输入任意字符串，str]=(\"a”，“b”，“c”，\"d”，\"e”，\"f”，”g”，“h”；每种字符出现频率fnum，=0.07,0.19,0.02,0.06,0.32,0.03,0.21,0.13，根据出现频率，利用哈夫曼编码原理，对每个字符进行(0.1)编码，并输出每种字符编码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/46826237925613.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Maxleaf 30&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Maxnode 1000&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Max 100000&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Maxsize 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;      &lt;span class=\"hljs-comment\"&gt;//定义结构体&lt;/span&gt;\n{\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;          &lt;span class=\"hljs-comment\"&gt;//定义字符型的结点名&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; weight;     &lt;span class=\"hljs-comment\"&gt;//定义一个整型权值变量&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild,rchild,parent;   &lt;span class=\"hljs-comment\"&gt;//定义左、右孩子及双亲指针&lt;/span&gt;\n}hufmtree;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; bits[Maxsize];        &lt;span class=\"hljs-comment\"&gt;//定义一个字符型的数组存储结点的编码&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start;                 &lt;span class=\"hljs-comment\"&gt;//标志字符串起点&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;                   &lt;span class=\"hljs-comment\"&gt;//存储结点的名称&lt;/span&gt;\n}codetype;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;huffman&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(hufmtree tree[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;//哈夫曼树的创建&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,p1,p2;\n  &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; small1,small2,f;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;           &lt;span class=\"hljs-comment\"&gt;//总的结点数目&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;m;i&amp;#43;&amp;#43;)        &lt;span class=\"hljs-comment\"&gt;//结点信息的初始化&lt;/span&gt;\n  {\n    tree[i].parent&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    tree[i].lchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    tree[i].rchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    tree[i].weight&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n  }\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)              &lt;span class=\"hljs-comment\"&gt;//输入叶子结点的结点名和权值&lt;/span&gt;\n  {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;第%d个元素的结点:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);  \n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,&amp;amp;c);\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入该节点的权值&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;f);\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n    tree[i].ch&amp;#61;c;\n    tree[i].weight&amp;#61;f;\n  }\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;n;i&amp;lt;m;i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//找出剩余结点中的权值最小的两个结点组合&lt;/span&gt;\n  {\n    p1&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;p2&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    small1&amp;#61;Max;small2&amp;#61;Max;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;i;j&amp;#43;&amp;#43;)             \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[j].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)         &lt;span class=\"hljs-comment\"&gt;//如果该结点不存在双亲&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[j].weight&amp;lt;small1)        &lt;span class=\"hljs-comment\"&gt;//结点的权值小于small1时&lt;/span&gt;\n    {\n      small2&amp;#61;small1;                \n      small1&amp;#61;tree[j].weight;          \n      p2&amp;#61;p1;                       \n      p1&amp;#61;j;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[j].weight&amp;lt;small2)         &lt;span class=\"hljs-comment\"&gt;//结点的权值大于small1但是小于small2&lt;/span&gt;\n    {\n      small2&amp;#61;tree[j].weight;\n      p2&amp;#61;j;\n    }\n    tree[p1].parent&amp;#61;i;           \n    tree[p2].parent&amp;#61;i;\n    tree[i].lchild&amp;#61;p1;\n    tree[i].rchild&amp;#61;p2;\n    tree[i].weight&amp;#61;tree[p1].weight&amp;#43;tree[p2].weight;\n  }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;huffmancode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(codetype code[],hufmtree tree[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;//哈夫曼的编码函数&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,c,p;\n  codetype cd;            &lt;span class=\"hljs-comment\"&gt;//定义一个临时变量&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//从下往上遍历哈夫曼树&amp;#xff0c;进行编码&lt;/span&gt;\n  {\n    cd.start&amp;#61;n;            &lt;span class=\"hljs-comment\"&gt;//编码的结束位置&lt;/span&gt;\n    cd.ch&amp;#61;tree[i].ch;        &lt;span class=\"hljs-comment\"&gt;//将哈夫曼结构体中的结点名赋给存储编码的结构体中的结构名&lt;/span&gt;\n    c&amp;#61;i;                       \n    p&amp;#61;tree[i].parent;         \n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)             &lt;span class=\"hljs-comment\"&gt;//当p是根结点的双亲时跳出循环&lt;/span&gt;\n    { \n      cd.start--;           \n      &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[p].lchild&amp;#61;&amp;#61;c)     &lt;span class=\"hljs-comment\"&gt;//如果是它的左孩子&lt;/span&gt;\n         cd.bits[cd.start]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//则输出0&lt;/span&gt;\n      &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n         cd.bits[cd.start]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//否则就是右孩子输出1&lt;/span&gt;\n      c&amp;#61;p;\n      p&amp;#61;tree[p].parent;\n    }\n    code[i]&amp;#61;cd;                     &lt;span class=\"hljs-comment\"&gt;//将临时变量中的值存入结构体数组&lt;/span&gt;\n  }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;decode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(hufmtree tree[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m)&lt;/span&gt;     &lt;span class=\"hljs-comment\"&gt;//译码函数&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; b[Maxsize];             \n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; endflag&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;;\n  i&amp;#61;m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n  &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n  &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(b);                                                  &lt;span class=\"hljs-comment\"&gt;//读入编码&lt;/span&gt;\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输出哈夫曼译码&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n  &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(b[j]!&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;)     \n  {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(b[j]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)                                         &lt;span class=\"hljs-comment\"&gt;//如果编码是0&lt;/span&gt;\n      i&amp;#61;tree[i].lchild;                                 &lt;span class=\"hljs-comment\"&gt;//将该结点左孩子的序号赋给i&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(b[j]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)\n    \n        i&amp;#61;tree[i].rchild;   &lt;span class=\"hljs-comment\"&gt;//如果编码是1&amp;#xff0c;将该结点右孩子的序号赋给i&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;ERROR\\n&amp;#34;&lt;/span&gt;);\n    }\n      &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[i].lchild&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)         &lt;span class=\"hljs-comment\"&gt;//如果该结点左孩子的序号等于-1&amp;#xff0c;即根结点&lt;/span&gt;\n      {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,tree[i].ch);    &lt;span class=\"hljs-comment\"&gt;//输出该结点名&lt;/span&gt;\n        i&amp;#61;m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;                        &lt;span class=\"hljs-comment\"&gt;//回到根结点&lt;/span&gt;\n      }\n   j&amp;#43;&amp;#43;;\n  }\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[i].parent!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)    \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nERROR\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*    ********哈夫曼编码/译码器********         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             1.创建哈夫曼树;                  *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             2.进行哈夫曼编码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             3.进行哈夫曼译码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             4.退出;                          *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n    }\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,n,m;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; choose;\n  hufmtree tree[Maxnode];       \n  codetype code[Maxleaf];   \n  &lt;span class=\"hljs-built_in\"&gt;Menu&lt;/span&gt;();    \n  &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n  {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n请输入要进行的功能&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n     &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;choose);\n     &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(choose)\n     {\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入元素个数&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n          &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n          &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n          &lt;span class=\"hljs-built_in\"&gt;huffman&lt;/span&gt;(tree,n);                                &lt;span class=\"hljs-comment\"&gt;//调用哈夫曼创建函数&lt;/span&gt;\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;成功建立哈夫曼树&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n      &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输出哈夫曼编码&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n          &lt;span class=\"hljs-built_in\"&gt;huffmancode&lt;/span&gt;(code,tree,n);           &lt;span class=\"hljs-comment\"&gt;//调用哈夫曼编码函数&lt;/span&gt;\n          &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)                           &lt;span class=\"hljs-comment\"&gt;//输出结点对应的哈夫曼编码&lt;/span&gt;\n          {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c:&amp;#34;&lt;/span&gt;,code[i].ch);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;code[i].start;j&amp;lt;n;j&amp;#43;&amp;#43;)\n              &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,code[i].bits[j]);\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n          }\n      &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n          m&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入编码&amp;#xff0c;以#为结束标志&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n          &lt;span class=\"hljs-built_in\"&gt;decode&lt;/span&gt;(tree,m);                             &lt;span class=\"hljs-comment\"&gt;//调用译码函数&lt;/span&gt;\n      &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n          &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n     }\n  }\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["下面这个到底哪里不对，运行了是c++那c语言咋整呢", ["给定权值(A:5，B:29，C:7,D: 8, E:14，F:23，G:3， H：11 建立哈夫曼树，输出哈夫曼编码；对上述给定的哈夫曼树及得到的哈夫曼编码，试输入一串二进制编码，输出它的哈夫曼译码。", "要求：将哈夫曼树的结构定义为一个一维数组，每个元素含有四顶：权值、双亲、左、右。权值由键盘输入；二进制编码时，往左走编码为0，往右走编码为1：译码就是将输入的编码还原成对应的字符。", "\n", "以上好多人用的用的是c++有人给改成c语言嘛，不会呀"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;因为有某次调用selectMin()函数时没有进54行那个分支&amp;#xff0c;导致secminIndex没有初始化就赋值给了res[1]&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["C语言哈夫曼树编码及其解码", ["问题：", "读取文件并对其中的数据进行哈夫曼树编码和解码", "出现的问题：", "用数据创建哈夫曼树并对哈夫曼树进行先序遍历的时候，出现程序崩溃，崩溃的原因我觉得莫名其妙", "如图：", "\n", "\n", "需求：", "1.解决上述问题，将字符数据翻译为哈夫曼树编码", "2.完成对解码部分的代码", "代码：", "\n", "#define _CRT_SECURE_NO_WARNINGS\n#include ", "\"stdio.h\"", "\n#include ", "\"stdlib.h\"", "\ntypedef struct TreeNode  ", "//定义树结点", "\n{\n    int weight;  ", "//权值", "\n    int parent;\n    int lchild;\n    int rchild;\n    char ch;\n}treenode;\n\ntypedef struct HuffmanTree  ", "//定义huffmantree，用数组表示树", "\n{\n    treenode* ", "data", ";\n    int length;\n}huffmantree;\n\nhuffmantree* huffmantree_create(int weight[], int length, char character[])", "//huffmantree初始化", "\n{\n    huffmantree* ", "tree", " = (huffmantree*)malloc(sizeof(huffmantree));\n    ", "tree", "->", "data", " = (treenode*)malloc(sizeof(treenode) * (", "2", " * length - ", "1", "));  ", "//n个元素，树中有2n-1个结点", "\n    ", "tree", "->", "length = length;\n    ", "for", " (int i = ", "0", "; i < length; i++)\n    {\n        ", "tree", "->", "data", "[i].weight = weight[i];\n        ", "tree", "->", "data", "[i].parent = ", "0", ";\n        ", "tree", "->", "data", "[i].lchild = -", "1", ";\n        ", "tree", "->", "data", "[i].rchild = -", "1", ";\n        ", "tree", "->", "data", "[i].ch = character[i];\n    }\n    return ", "tree", ";\n}\n\nint* selectMin(huffmantree* ", "tree", ")", "//选择最小的两个结点", "\n{\n    int min=", "10000", ", secmin=", "10000", ";\n    int minIndex, secminIndex;\n    ", "for", " (int i = 0; i < ", "tree", "->", "length; i++)  ", "//找到最小的结点的索引下标", "\n    {\n        ", "if", " (", "tree", "->", "data", "[i].parent == ", "0", ")\n        {\n            ", "if", " (", "tree", "->", "data", "[i].weight < min)\n            {\n                ", "min", " = ", "tree", "->", "data", "[i].weight;\n                minIndex = i;\n            }\n        }\n    }\n    ", "for", " (int i = 0; i < ", "tree", "->", "length; i++)  ", "//找到第二小的结点的索引下标", "\n    {\n        ", "if", " (", "tree", "->", "data", "[i].parent == ", "0", " && i != minIndex)\n        {\n            ", "if", " (", "tree", "->", "data", "[i].weight < secmin)\n            {\n                ", "secmin", " = ", "tree", "->", "data", "[i].weight;\n                secminIndex = i;\n            }\n        }\n    }\n    int* res = (int*)malloc(sizeof(int) * ", "2", ");  ", "//返回两个数据，用int数组返回", "\n    res[", "0", "] = minIndex;\n    res[", "1", "] = secminIndex;\n    return res;\n}\n\nvoid createTree(huffmantree* ", "tree", ")  ", "//建树", "\n{\n    int min;\n    int secmin;\n    int* res;\n    ", "for", " (int i = ", "tree", "->", "length", "; i < ", "tree", "->", "length * ", "2", " - ", "1", "; i++)\n    {\n        res = selectMin(", "tree", ");\n        printf(", "\"%d %d\\t\"", ", res[", "0", "], res[", "1", "]);\n        min = res[", "0", "];\n        secmin = res[", "1", "];\n        ", "tree", "->", "data", "[i].weight = ", "tree", "->", "data", "[min].weight + ", "tree", "->", "data", "[secmin].weight;\n        ", "tree", "->", "data", "[min].parent = i;  ", "//设置双亲结点", "\n        ", "tree", "->", "data", "[secmin].parent = i;\n        ", "tree", "->", "data", "[i].parent = ", "0", ";\n        ", "tree", "->", "data", "[i].lchild = min;  ", "//设置孩子结点", "\n        ", "tree", "->", "data", "[i].rchild = secmin;\n        ", "tree", "->", "length++;\n    }\n}\n\nvoid preorder(huffmantree* ", "tree", ",int index)\n{\n    ", "while", " (index != -", "1", ")\n    {\n        ", "printf", "(\"%c %d\\n\", ", "tree", "->", "data", "[index].ch, ", "tree", "->", "data", "[index].weight);\n        ", "preorder", "(", "tree", ", ", "tree", "->", "data", "[index].lchild);\n        ", "preorder", "(", "tree", ", ", "tree", "->", "data", "[index].rchild);\n    }\n}\n\nint main()\n{\n    FILE* fp;\n    char ch, str[", "100", "],character[", "100", "];\n    int length = ", "0", ", option, lengthchar = ", "0", ", weight[", "100", "];\n    fp = fopen(", "\"test3.txt\"", ", ", "\"r+\"", ");\n    ", "if", " (fp == NULL)\n    {\n        printf(", "\"打开文件失败\\n\"", ");\n        exit(", "0", ");\n    }\n    printf(", "\"打开文件成功\\n\"", ");\n    ch = fgetc(fp);\n    ", "while", " (ch != EOF)\n    {\n        str[length] = ch;\n        length++;\n        ch = fgetc(fp);\n    }\n    str[length] = ", "'\\0'", ";\n    printf(", "\"该文件的数据为:\"", ");\n    puts(str);\n    printf(", "\"请问你是要对文件进行加密还是进行解密？(输入1为加密，输入2为解密)\"", ");\n    printf(", "\"我选择：\"", ");\n    scanf(", "\"%d\"", ", &option);\n    ", "while", " (option != ", "1", " && option != ", "2", ")\n    {\n        printf(", "\"你的输入有误，请重新输入！\\n我选择：\"", ");\n        scanf(", "\"%d\"", ", &option);\n    }\n    ", "if", " (option == ", "1", ")  ", "//对数据进行huffmantree编码", "\n    {\n        int status;\n        huffmantree* hftree;\n        ", "for", " (int i = ", "0", "; i < length; i++)  ", "//先把str中的每一个字符都单列出来放进数组character", "\n        {\n            status = ", "0", ";\n            ", "for", " (int t = ", "0", "; t < lengthchar; t++)\n            {\n                ", "if", " (str[i] == character[t])\n                {\n                    status = ", "1", ";\n                    break;\n                }\n            }\n            ", "if", " (status == ", "1", ")\n                continue;\n            character[lengthchar] = str[i];\n            lengthchar++;\n        }\n        character[lengthchar] = ", "'\\0'", ";\n        printf(", "\"字符数组为:\"", ");\n        puts(character);\n        ", "for", " (int i = ", "0", "; i < lengthchar; i++)  ", "//将权值数组归0", "\n        {\n            weight[i] = ", "0", ";\n        }\n        ", "for", " (int i = ", "0", "; i < lengthchar; i++)  ", "//设置权值数组", "\n        {\n            ", "for", " (int t = ", "0", "; t < length; t++)\n            {\n                ", "if", " (str[t] == character[i])  ", "//统计每个字符的出现次数", "\n                    weight[i]++;\n            }\n        }\n        printf(", "\"权值数组为:\"", ");\n        ", "for", " (int i = ", "0", "; i < lengthchar; i++)\n            printf(", "\"%d \"", ", weight[i]);\n        printf(", "\"\\n\"", ");\n        hftree = huffmantree_create(weight, lengthchar, character);\n        createTree(hftree);\n        ", "preorder", "(hftree,hftree->", "length-", "1", ");\n    }\n    ", "if", " (option == ", "2", ")", "//对huffmantree编码进行解码", "\n    {\n        \n    }\n    fclose(fp);\n    return ", "0", ";\n}\n谢谢！\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;定义hufmtree&amp;#xff08;哈夫曼&amp;#xff09;的结构体&amp;#xff0c;创建一个新的数据类型&amp;#xff0c;名称为hufmtree。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["C语言 哈夫曼编译码器", ["typedef struct", "\n{", "\n char ch;", "\n float weight;", "\n int lchild,rchild,parent;", "\n}hufmtree;", "\n\n", "这段代码是什么作用的？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;哈夫曼树是一种用于编码和压缩数据的数据结构。它是根据给定的权值创建出的二叉树&amp;#xff0c;其中每个节点的权值表示该节点对应的字符或数据块的出现频率。哈夫曼树的编码是指将每个数据块编码成一个二进制序列&amp;#xff0c;该序列由该数据块在哈夫曼树中路径上的左右分支构成。&lt;/p&gt;\n&lt;p&gt;对于哈夫曼树而言&amp;#xff0c;左分支为0或者为1都是可以的。在构建哈夫曼树时&amp;#xff0c;只需要保证编码过程中每个节点的左右分支不重复即可&amp;#xff0c;因此左分支为0或者为1都是正确的。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构中哈夫值曼树的编码", ["问题遇到的现象和发生背景", "\n", "为哈夫曼树设计哈夫曼编码，左分支为0或者为1，都是可以的吗", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/263650482556171.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MaxSize 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ElemType;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 50        &lt;span class=\"hljs-comment\"&gt;//叶子结点数&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; M 2*N-1     &lt;span class=\"hljs-comment\"&gt;//树中结点总数&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//哈夫曼树的节点结构类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; data;  &lt;span class=\"hljs-comment\"&gt;//结点值&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; weight;  &lt;span class=\"hljs-comment\"&gt;//权重&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; parent;     &lt;span class=\"hljs-comment\"&gt;//双亲结点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild;     &lt;span class=\"hljs-comment\"&gt;//左孩子结点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rchild;     &lt;span class=\"hljs-comment\"&gt;//右孩子结点&lt;/span&gt;\n} HTNode;\n\n&lt;span class=\"hljs-comment\"&gt;//每个节点哈夫曼编码的结构类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; cd[N]; &lt;span class=\"hljs-comment\"&gt;//存放哈夫曼码&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start;\n} HCode;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHT&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HTNode ht[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,k,lnode,rnode;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; min1,min2;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//所有结点的相关域置初值-1&lt;/span&gt;\n        ht[i].parent&amp;#61;ht[i].lchild&amp;#61;ht[i].rchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;n; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//构造哈夫曼树&lt;/span&gt;\n    {\n        min1&amp;#61;min2&amp;#61;&lt;span class=\"hljs-number\"&gt;32767&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;//lnode和rnode为最小权重的两个结点位置&lt;/span&gt;\n        lnode&amp;#61;rnode&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k&amp;lt;&amp;#61;i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; k&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[k].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)   &lt;span class=\"hljs-comment\"&gt;//只在尚未构造二叉树的结点中查找&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[k].weight&amp;lt;min1)\n                {\n                    min2&amp;#61;min1;\n                    rnode&amp;#61;lnode;\n                    min1&amp;#61;ht[k].weight;\n                    lnode&amp;#61;k;\n                }\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[k].weight&amp;lt;min2)\n                {\n                    min2&amp;#61;ht[k].weight;\n                    rnode&amp;#61;k;\n                }\n            }\n        ht[i].weight&amp;#61;ht[lnode].weight&amp;#43;ht[rnode].weight;\n        ht[i].lchild&amp;#61;lnode;\n        ht[i].rchild&amp;#61;rnode;\n        ht[lnode].parent&amp;#61;i;\n        ht[rnode].parent&amp;#61;i;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//实现哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HTNode ht[],HCode hcd[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,f,c;\n    HCode hc;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//根据哈夫曼树求哈夫曼编码&lt;/span&gt;\n    {\n        hc.start&amp;#61;n;\n        c&amp;#61;i;\n        f&amp;#61;ht[i].parent;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (f!&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)   &lt;span class=\"hljs-comment\"&gt;//循序直到树根结点&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[f].lchild&amp;#61;&amp;#61;c)    &lt;span class=\"hljs-comment\"&gt;//处理左孩子结点&lt;/span&gt;\n                hc.cd[hc.start--]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;                    &lt;span class=\"hljs-comment\"&gt;//处理右孩子结点&lt;/span&gt;\n                hc.cd[hc.start--]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;\n            c&amp;#61;f;\n            f&amp;#61;ht[f].parent;\n        }\n        hc.start&amp;#43;&amp;#43;;     &lt;span class=\"hljs-comment\"&gt;//start指向哈夫曼编码最开始字符&lt;/span&gt;\n        hcd[i]&amp;#61;hc;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//输出哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DispHCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HTNode ht[],HCode hcd[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,k;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; sum&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,m&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;  输出哈夫曼编码:\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//输出哈夫曼编码&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;      %c:\\t&amp;#34;&lt;/span&gt;,ht[i].data);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (k&amp;#61;hcd[i].start; k&amp;lt;&amp;#61;n; k&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,hcd[i].cd[k]);\n            j&amp;#43;&amp;#43;;\n        }\n        m&amp;#43;&amp;#61;ht[i].weight;\n        sum&amp;#43;&amp;#61;ht[i].weight*j;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n  平均长度&amp;#61;%g\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;*sum/m);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,i;      &lt;span class=\"hljs-comment\"&gt;//n表示初始字符串的个数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[]&amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; fnum[]&amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0.07&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.19&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.02&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.06&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.32&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.03&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.21&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.1&lt;/span&gt;};\n    HTNode ht[M];\n    HCode hcd[N];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        ht[i].data&amp;#61;str[i];\n        ht[i].weight&amp;#61;fnum[i];\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;CreateHT&lt;/span&gt;(ht,n);\n    &lt;span class=\"hljs-built_in\"&gt;CreateHCode&lt;/span&gt;(ht,hcd,n);\n    &lt;span class=\"hljs-built_in\"&gt;DispHCode&lt;/span&gt;(ht,hcd,n);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["输入任意字符串，str[]={\"a\",\"b\",\"c\",\"d\",\"e”,\"f\",\"g\",\"h\"}", ["输入任意字符串，str[]={\"a\",\"b\",\"c\",\"d\",\"e”,\"f\",\"g\",\"h\"},每种字符出现频率fnum[]={0.070.19,0.02,0.06,0.32,0.03,0.21,0.1},根据出现频率，利用哈夫曼编码原理，对每个字符进行（0.1）编码，并输出每种字符编码。", "注意：写清具体步骤（文字描述）和程序流程图！"]], "Tag": "算法设计"}
{"Answer": "还有std::bitset", "Konwledge_Point": "哈夫曼编码", "Question": ["用C++可以存储2bit的数据么?", ["今天用哈夫曼编码做24位bmp图像的压缩，像素里的RGB已经按频率编好了前缀编码。问题是编好了的前缀码有的较短，不需要一个字节来装，只要几个比特就好了。但是最小的数据类型unsigned char也有一个字节，用它来装编码达不到压缩的效果"]], "Tag": "算法设计"}
{"Answer": "http://www.cnblogs.com/yym2013/p/3554471.html", "Konwledge_Point": "哈夫曼编码", "Question": ["Safe Or Unsafe                ", ["Problem Description", "\nJavac++ 一天在看计算机的书籍的时候，看到了一个有趣的东西！每一串字符都可以被编码成一些数字来储存信息，但是不同的编码方式得到的储存空间是不一样的！并且当储存空间大于一定的值的时候是不安全的！所以Javac++ 就想是否有一种方式是可以得到字符编码最小的空间值！显然这是可以的，因为书上有这一块内容--哈夫曼编码(Huffman Coding)；一个字母的权值等于该字母在字符串中出现的频率。所以Javac++ 想让你帮忙，给你安全数值和一串字符串，并让你判断这个字符串是否是安全的？", "\n\n", "Input", "\n输入有多组case，首先是一个数字n表示有n组数据，然后每一组数据是有一个数值m(integer)，和一串字符串没有空格只有包含小写字母组成！", "\n\n", "Output", "\n如果字符串的编码值小于等于给定的值则输出yes，否则输出no。", "\n\n", "Sample Input", "\n2", "\n12", "\nhelloworld", "\n66", "\nithinkyoucandoit", "\n\n", "Sample Output", "\nno", "\nyes"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;在哈夫曼树中&amp;#xff0c;给定任意一个叶子节点&amp;#xff0c;它对应的编码是由根节点到该叶子节点的路径上的 0 和 1 组成的&amp;#xff0c;所以说&amp;#xff0c;在进行哈夫曼编码时&amp;#xff0c;路径为零的叶子节点的编码可以被定义为比路径为 1 的叶子节点的编码小&amp;#xff0c;也可以被定义为比路径为 1 的叶子节点的编码大&amp;#xff0c;具体的定义可以看情况&amp;#xff0c;只需要保证编码的唯一性和无歧义性就行了&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["请问哈夫曼树的零一编码是否需要路径为零的数比路径为1的叶子结点的值小或者大。", ["请问哈夫曼树的零一编码是否需要路径为零的数比路径为1的叶子结点的值小或者大？还是任意的呀，自己编码的话，"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;简单记法&amp;#xff0c;左0右1&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["请问大家这个huffman树编码的0和1是怎么判断的呀", []], "Tag": "算法设计"}
{"Answer": "typedef struct BinNode{};这样是声明一个类，你的声明是一个没有类名的一个结构体对象BinNode", "Konwledge_Point": "哈夫曼编码", "Question": ["请教一下，vs2017 为什么我的c++代码定义的没有问题，也没有错误提示，但是一编译就爆出很奇怪的错误", ["\n\n", "\n\n", "\n\n", "\n\n", "以下是完整代码", "\n\n", "#include \"pch.h\"\n#include<iostream>\nusing namespace std;\n\ntypedef struct {\n    int weight;\n    BTreeNode *left;\n    BTreeNode *right;\n}BTreeNode;\n\nBTreeNode* CreateHuffman(int a[], int n)\n{\n    // 根据数组a中n个权值建立一颗哈夫曼树，则返回树根指针\n    BTreeNode **b, *q;\n    // 动态地分配一个由b指向的指针数组\n    b = new BTreeNode*[n];\n    int i, j;\n\n    // 初始化b指针数组，使每个指针元素指向a数组中对应元素的结点\n    for (i = 0; i < n; i++) {\n        b[i] = new BTreeNode;\n        b[i]->weight = a[i]; b[i]->left = b[i]->right = NULL;\n    }\n\n    // 进行n-1此循环建立哈夫曼树\n    for (i = 1; i < n; i++) {\n        // 用k1表示森林中具有最小权值的树根节点下标\n        // 用k2表示森林中具有次小权值的树根节点下标\n        int k1=-1, k2;\n        for (j = 0; j < n; j++) {\n            if (b[j] != NULL && k1 == -1) {\n                k1 = j; continue;\n            }\n            if (b[j] != NULL) {\n                k2 = j; break;\n            }\n        }\n\n        // 从当前森林中求出最小权值树和次小权值树\n        for (j = k2; j < n; j++) {\n            if (b[j] != NULL) {\n                if (b[j]->weight < b[k1]->weight) {\n                    k2 = k1; k1 = j;\n                }\n                else if (b[j]->weight < b[k2]->weight)\n                    k2 = j;\n            }\n        }\n\n        // 由最小权值树和次小权值树建立一棵新树，q指向树跟结点\n        q = new BTreeNode;\n        q->weight = b[k1]->weight + b[k2]->weight;\n        q->left = b[k1]; q->right = b[k2];\n        // 将指向新树的指针赋给b指针数组k1位置，k2位置置为空\n        b[k1] = q; b[k2] = NULL;\n    }\n\n    // 删除动态建立的数组b\n    delete []b;\n    // 返回整个哈夫曼树的树根指针\n    return q;\n}\n\nvoid HuffManCoding(BTreeNode *FBT, int len)\n{\n    // 根据FBT指针所指向的哈夫曼树输出每个叶子的编码，len初值为0\n    static int code[10];    // 数组的长度要至少等于哈夫曼树的深度减1\n    if (FBT != NULL) {\n        // 访问到叶子结点时输出其保存在数组code中的0和1序列编码\n        if (FBT->left == NULL && FBT->right == NULL) {\n            cout << \"结点权值为\" << FBT->weight << \"的编码：\";\n            for (int i = 0; i < len; i++)\n                cout << code[i] << \" \";\n            cout << endl;\n        }\n\n        // 访问到非叶子节点时分别向左、右子树递归调用，并分别把分支上\n        // 的0、1编码保存到数组code，向下深入一层时len+1\n        else {\n            code[len] = 0; HuffManCoding(FBT->left, len + 1);\n            code[len] = 1; HuffManCoding(FBT->right, len + 1);\n        }\n    }\n}\n\nvoid CleanBTree(BTreeNode *BT)\n{\n    if (BT != NULL) {\n        CleanBTree(BT->left);\n        CleanBTree(BT->right);\n        delete BT;\n        BT = NULL;\n    }\n}\n\nint main()\n{\n    int n, i;\n    BTreeNode *fbt = NULL;\n    // 输入哈夫曼树中叶子结点数\n    cout << \"输入待构造的哈夫曼树中带权叶子结点的权值n：\";\n    cin >> n;\n    // 用数组a保存从键盘输入的n个叶子结点的权值\n    int *a = new int[n];\n    cout << \"输入\" << n << \"个整数作为权值：\";\n    for (i = 0; i < n; i++) cin >> a[i];\n    // 根据数组a建立哈夫曼树\n    fbt = CreateHuffman(a, n);\n    // 输出哈夫曼编码，即每个叶子节点所对应的0、1序列\n    cout << \"树种每个叶子的哈夫曼编码：\" << endl;\n    HuffManCoding(fbt, 0);\n    CleanBTree(fbt);\n}\n"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_29503203/article/details/53034955", "Konwledge_Point": "哈夫曼编码", "Question": ["关于HUFFMAN利用数组压缩的算法问题", ["整体代码如下，具体关于问题在最下方，", "\nstruct head", "\n{", "\n unsigned char b;             /*the charactor*/", "\n long count;                  /*the frequency*/", "\n long parent,lch,rch;         /*make a tree*/", "\n char bits[256];              /*the haffuman code*/", "\n}", "\nheader[512],tmp;", "\n\n", "void compress()", "\n{", "\n\n", "clock_t start,end; ", "\n char filename[255],outputfile[255],buf[512];", "\n int fn = 0, sz = 0, sz1 = 0;", "\n double x = 0;", "\n unsigned char c;", "\n long i,j,m,n,f;", "\n long min1,pt1,flength;", "\n FILE ", "ifp,*ofp;", "\n printf(\"源文件名:\");", "\n gets_s(filename);", "\n ifp=fopen(filename,\"rb\");", "\n if(ifp==NULL)", "\n {", "\n  printf(\"源文件打开失败!\\n\");", "\n  return;", "\n }", "\n fn = _fileno(ifp); /", "取得文件指针的底层流式文件号*/", "\n sz = _filelength(fn);/*根据文件号取得文件大小*/", "\n printf(\"文件大小为:%d B.\\n\", sz);", "\n sz1 = sz;", "\n printf(\"压缩后文件名:\");", "\n gets_s(outputfile);", "\n  start=clock(); /* 计时开始 */ ", "\n ofp=fopen(outputfile,\"wb\");", "\n if(ofp==NULL)", "\n {", "\n  printf(\"压缩文件打开失败!\\n\");", "\n  return;", "\n }", "\n flength=0;", "\n\n", "while(!feof(ifp))", "\n {", "\n  fread(&c,1,1,ifp);//读数据", "\n  header[c].count++; //字符重复出现频率+1", "\n  flength++;  //字符出现原文件长度+1", "\n }", "\n flength--;", "\n header[c].count--;//减一平衡位数", "\n for(i=0;i\n {", "\n  if(header[i].count!=0) ", "\n      header[i].b=(unsigned char)i;", "\n  /*将每个哈夫曼码值及其对应的ASCII码存放在一维数组header[i]中，", "\n  且编码表中的下标和ASCII码满足顺序存放关系*/", "\n  else header[i].b=0;", "\n  header[i].parent=-1; //对结点进行初始化", "\n  header[i].lch=header[i].rch=-1;", "\n }", "\n for(i=0;i\n {", "\n  for(j=i+1;j\n  {", "\n   if(header[i].count \n   {", "\n    tmp=header[i];", "\n    header[i]=header[j];", "\n    header[j]=tmp;", "\n   }", "\n  }", "\n }", "\n for(i=0;i\n n=i;", "\n m=2*n-1; //外部叶子结点数为n个时，内部结点数为n-1，整个哈夫曼树的需要的结点数为2*n-1.", "\n for(i=n;i\n {", "\n  min1=999999999;", "\n  for(j=0;j", "\n  {", "\n   if(header[j].parent!=-1) continue;//parent!=-1说明该结点已存在哈夫曼树中，跳出循环重新选择新结点*/", "\n   if(min1>header[j].count)", "\n   {", "\n    pt1=j;", "\n    min1=header[j].count;//找到最小值", "\n    continue;", "\n   }", "\n  }", "\n  header[i].count=header[pt1].count;", "\n  header[pt1].parent=i; //依据parent域值（结点层数）确定树中结点之间的关系", "\n  header[i].lch=pt1;//计算左分支权值大小", "\n  min1=999999999;", "\n  for(j=0;j", "\n  {", "\n   if(header[j].parent!=-1) continue;", "\n   if(min1>header[j].count)", "\n   {", "\n    pt1=j;", "\n    min1=header[j].count;", "\n    continue;", "\n   }", "\n  }", "\n  header[i].count+=header[pt1].count;", "\n  header[i].rch=pt1;//计算右分支权值大小", "\n  header[pt1].parent=i;", "\n }", "\n for(i=0;i\n {", "\n  f=i;", "\n  header[i].bits[0]=0;//根结点编码0   ", "\n  while(header[f].parent!=-1)", "\n  {", "\n   j=f;", "\n   f=header[f].parent;", "\n   if(header[f].lch==j) //置左分支编码0", "\n   {", "\n    j=strlen(header[i].bits);//扫描长度", "\n    memmove(header[i].bits+1,header[i].bits,j+1);//由header复制j+ 1个到前者", "\n                                                 //依次存储连接“0”“1”编码", "\n    header[i].bits[0]='0';", "\n   }", "\n   else//置右分支编码1", "\n   {", "\n    j=strlen(header[i].bits);//计算字符长度？", "\n    memmove(header[i].bits+1,header[i].bits,j+1);", "\n    header[i].bits[0]='1';", "\n   }", "\n  }", "\n }", "\n fseek(ifp,0,SEEK_SET);//从文件开始位置向前移动0字节，即定位到文件开始位置", "\n fwrite(&flength,sizeof(int),1,ofp);/*用来将数据写入文件流中，参数flength指向欲写入的数据地址，", "\n总共写入的字符数以参数size*int来决定，返回实际写入的int数目1*/ ", "\n fseek(ofp,8,SEEK_SET);", "\n buf[0]=0; //定义缓冲区,它的二进制表示00000000", "\n f=0;", "\n pt1=8;", "\n /*假设原文件第一个字符是\"A\"，8位2进制为01000001，编码后为0110识别编码第一个'0'，", "\n 那么我们就可以将其左移一位，看起来没什么变化。下一个是'1'，应该|1，结果00000001", "\n 同理4位都做完，应该是00000110，由于字节中的8位并没有全部用完，我们应该继续读下一个字符，", "\n 根据编码表继续拼完剩下的4位，如果字符的编码不足4位，还要继续读一个字符，", "\n 如果字符编码超过4位，那么我们将把剩下的位信息拼接到一个新的字节里*/", "\n while(!feof(ifp))", "\n {", "\n  c=fgetc(ifp);", "\n  f++;", "\n  for(i=0;i\n  {", "\n   if(c==header[i].b) break;", "\n  }", "\n  strcat(buf,header[i].bits);", "\n  j=strlen(buf);", "\n  c=0;", "\n  while(j>=8) //对哈夫曼编码位操作进行压缩存储", "\n  {", "\n   for(i=0;i\n   {", "\n    if(buf[i]=='1') c=(c\n    else c=c\n   }", "\n   fwrite(&c,1,1,ofp);", "\n   pt1++; //统计压缩后文件的长度", "\n   strcpy(buf,buf+8);//一个字节一个字节拼接", "\n   j=strlen(buf);", "\n  }", "\n  if(f==flength) break;", "\n }", "\n if(j>0) //对哈夫曼编码位操作进行压缩存储", "\n {", "\n  strcat(buf,\"00000000\");", "\n  for(i=0;i<8;i++)", "\n  {", "\n   if(buf[i]=='1') c=(c<<1)|1;", "\n   else c=c<<1;", "\n  }", "\n  fwrite(&c,1,1,ofp);", "\n  pt1++;", "\n }", "\n fseek(ofp,4,SEEK_SET);", "\n fwrite(&pt1,sizeof(long),1,ofp);", "\n fseek(ofp,pt1,SEEK_SET);", "\n fwrite(&n,sizeof(long),1,ofp);", "\n for(i=0;i<n;i++)", "\n {", "\n  fwrite(&(header[i].b),1,1,ofp);", "\n  c=strlen(header[i].bits);", "\n  fwrite(&c,1,1,ofp);", "\n  j=strlen(header[i].bits);", "\n  if(j%8!=0) //若存储的位数不是8的倍数，则补0", "\n  {", "\n   for(f=j%8;f<8;f++)", "\n   strcat(header[i].bits,\"0\");", "\n  }", "\n  while(header[i].bits[0]!=0)", "\n  {", "\n   c=0;", "\n   for(j=0;j<8;j++) //字符的有效存储不超过8位，则对有效位数左移实现两字符编码的连接", "\n   {", "\n    if(header[i].bits[j]=='1') c=(c<<1)|1; //|1不改变原位置上的“0”“1”值", "\n    else c=c<<1;", "\n   }", "\n   strcpy(header[i].bits,header[i].bits+8);// 把字符的编码按原先存储顺序连接", "\n   fwrite(&c,1,1,ofp);", "\n  }", "\n }", "\n fclose(ifp);", " ", "\n\n", "printf(\"压缩成功!\\n\");", "\n end=clock(); /* 计时结束 ", "/", "\n fn = _fileno(ofp); /", "取得文件指针的底层流式文件号*/", "\n sz = _filelength(fn);/*根据文件号取得文件大小*/", "\n printf(\"压缩后文件大小为:%d B.\\n\", sz);", "\n x = (sz / sz1)*1.0;", "\n printf(\"压缩率为:%d B.\\n\", x);", "\n fclose(ofp); ", "\nprintf(\"压缩用时%f秒\\n\",(double)(end - start) / CLOCKS_PER_SEC);", "\n return;", "\n}", "\n\n", "//", "\n整体代码如上，请问下  关于找到最小值以后", "\n\n", "header[i].count=header[pt1].count;", "\n  header[pt1].parent=i; //依据parent域值（结点层数）确定树中结点之间的关系", "\n  header[i].lch=pt1;//计算左分支权值大小", "\n    哈夫曼生成的节点权重不应该两者之和么，这个对于双亲的赋值不是很懂，这种利用数组进行排序以后的这个操作不是很明白，这个i好像是顺序，但不是累加，怎么剔除以后去和剩下的节点比较啊。原来搞不明白这里怎么赋值的"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1、第一步&amp;#xff1a;将字符全部按照频率按升序排序&amp;#xff1b;&lt;br /&gt;2、b和e是最小的两个节点&amp;#xff0c;两者连接到同一个节点上&amp;#xff0c;该节点权值为0.04&amp;#43;0.06&amp;#61;0.1;&lt;br /&gt;3、最小的两个节点权值为0.1和0.17&amp;#xff0c;将两个节点合并到一个节点上&amp;#xff0c;频率为&amp;#xff1a;0.1&amp;#43;0.17&amp;#61;0.27&amp;#xff1b;&lt;br /&gt;4、重复以上步骤&amp;#xff0c;哈弗曼树构造完成。&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/909285627276126.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;br /&gt;关于WPL&amp;#xff1a;f、a、c在第二层&amp;#xff0c;d在第三层&amp;#xff0c;b和e在第四层&amp;#xff0c;所以&lt;br /&gt;WPS&amp;#61;&amp;#xff08;0.18&amp;#43;0.23&amp;#43;0.32&amp;#xff09;&lt;em&gt;2&amp;#43;0.17&lt;/em&gt;3&amp;#43;&amp;#xff08;0.04&amp;#43;0.06&amp;#xff09;*4&amp;#61;2.37。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构c语言哈夫曼树", ["有一份电文中共使用 6个字符:a,b,c,d,e,f,它们的出现频率依次为0.23  0.04  0.32  0.17  0.06  0.18  试构造一棵哈夫曼树，求其加权路径长度WPL及各字符的编码。"]], "Tag": "算法设计"}
{"Answer": "你的方法定义是不是不对？调用方法之后node里面的内容有带回到主函数吗？可以断点看下返回之后node的内容。", "Konwledge_Point": "哈夫曼编码", "Question": ["当输入3个字母以上，执行到if (node[p].lchild == c) 无法读取内存", ["#include", "\n#include", "\n#include", "\n\n", "#define MAXBIT      100", "\n#define MAXVALUE  10000", "\n#define MAXLEAF     30", "\n#define MAXNODE    MAXLEAF*2 -1", "\n\n", "using namespace std;", "\n\n", "typedef struct{", "\n    int bit[100];", "\n    int start;", "\n}Code;", "\ntypedef struct node{", "\n    char data;", "\n    int weight;", "\n    int parent;", "\n    int lchild;", "\n    int rchild;", "\n    bool tag;", "\n}Node;", "\n\n", "int HuffmanTree(Node node[MAXNODE], int a[128])", "\n{", "\n    int i, j, m1, m2, x1, x2;", "\n    int n = 0;", "\n    for (i = 0; i < 128; i++)", "\n    {", "\n        if (a[i])", "\n        {", "\n            node[n].weight = a[i];", "\n            node[n].parent = -1;", "\n            node[n].lchild = -1;", "\n            node[n].rchild = -1;", "\n            node[n].data = (char)i;", "\n            n++;", "\n        }", "\n    }", "\n    for (i = n ; i < 2*n; i++)", "\n    {", "\n        node[n].weight = 0;", "\n        node[n].parent = -1;", "\n        node[n].lchild = -1;", "\n        node[n].rchild = -1;", "\n    }", "\n    /*循环构建霍夫曼树*/", "\n    for (i = 0; i <n-1; i++)", "\n    {", "\n        m1 = m2 = MAXVALUE;", "\n        /* m1、m2中存放两个无父结点且结点权值最小的两个结点 ", "/", "\n        x1 = x2 = 0;", "\n        /", " 找出所有结点中权值最小、无父结点的两个结点，并合并之为一颗二叉树 */", "\n        for (j = 0; j < n + i; j++)", "\n        {", "\n            if (node[j].parent == -1 && node[j].weight<m1)", "\n            {", "\n                m2 = m1;", "\n                x2 = x1;", "\n                m1 = node[j].weight;", "\n                x1 = j;", "\n            }", "\n            else if (node[j].weight < m2 && node[j].parent == -1)", "\n            {", "\n                m2 = node[j].weight;", "\n                x2 = j;", "\n            }", "\n\n", "    }\n    /* 设置找到的两个子结点 x1、x2 的父结点信息 */\n    node[x1].parent = n + i;\n    node[x2].parent = n + i;\n    node[n + i].weight = node[x1].weight + node[x2].weight;\n    node[n + i].lchild = x1;\n    node[n + i].rchild = x2;\n}\nreturn n;\n", "\n\n", "}", "\nint main()", "\n{", "\n    Node node[MAXNODE];", "\n    Code code[MAXLEAF], cd;", "\n    char s[500];", "\n    int i, j, c, p,n;", "\n    int a[128] = { 0 };", "\n    cout << \"Please input your string:\"<\n    cin >> s;", "\n    for (i = 0; s[i]; i++)", "\n        a[s[i]]++;", "\n    for (j = 0; j < 128; j++)", "\n    {", "\n        if (a[j])", "\n        {", "\n            cout << (char)j << \":\" << a[j] << endl;", "\n        }", "\n    }", "\n    n=HuffmanTree(node, a);", "\n    cout << n;", "\n    for (i = 0; i < n; i++)", "\n    {", "\n        cd.start = n-1;", "\n        c = i;", "\n        p = node[c].parent;", "\n        while (p != -1)", "\n        {", "\n\n", "        if (node[p].lchild == c)\n            cd.bit[cd.start] = 0;\n        else\n        {\n            cd.bit[cd.start] = 1;\n        }\n        cd.start--;\n        c = p;\n        p = node[c].parent;\n    }//end while\n    for (j = cd.start + 1; j < n; j++)\n    {\n        code[i].bit[j] = cd.bit[j];\n    }\n    code[i].start = cd.start;\n}//end for\n/* 输出已保存好的所有存在编码的哈夫曼编码 */\ncout << \"编码：\" << endl;\n        for (i = 0; i < n; i++)\n        {\n            cout << node[i].data<< \" :\";\n            for (j = code[i].start + 1; j < n; j++)\n            {\n                cout << code[i].bit[j];\n            }\n        cout << endl;\n        }\nsystem(\"pause\");\n", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "这个题目你只需要知道哈夫曼树就可以了\r\n首先将字符与加权一一对应，并将他们按权值大小排序：\r\nd 0.12 c 0.14 b 0.17 e 0.18 f 0.19 a 0.2\r\n哈夫曼树构造方法：\r\n假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：\r\n(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；\r\n(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；\r\n(3)从森林中删除选取的两棵树，并将新树加入森林；\r\n(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。\r\n----来源百度百科\r\n（1）先挑选最小的两个节点，此处为dc，作为一棵树的左右叶子，用他们的和作为根节点，就够造成了一棵树。\r\n（2）以新产生的树为左子树，在未加入树中的节点在选择一个最小权值的节点，作为右叶子，构造一棵树。\r\n（3）重复（2），直至结束。\r\n然后根据左零右一得规则进行编码，即任意一个根节点，指向左孩子的树枝（姑且叫树枝）标注零，同理指向右孩子的标注一。如图\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201911/10/1573383456_900144.jpg)\r\n\r\n确定编码：从根节点出发，到指定节点N所走过路径上的编码顺排，就构成了这个节点的编码，如a可以编码1指代。\r\n每个节点的编码图片中已经给出。\r\n求加权路径长度：题目中给出了每个节点的权值，可记为Wi（第i个节点的权重）你需要搞清楚普通路径长度是多少，根据够早的哈弗曼数，每一个节点到根节点的所要经过的边数称为路径长度，此处记为Li（第i个节点的...）\r\n加权路径长度即为全部节点LiWi的西格玛求和\r\n本题目构造的哈夫曼树WPL为\r\n0.2×1+0.19×2+0.18×3+0.17×4+0.14×5+0.12×5\r\n\r\n\r\n学过好久了，可能有纰漏，海涵。", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构------树  能不能帮忙解答下", ["有一份电文中共使用 6个字符：a，b，c，d，e，f，它们的出现频率依次为：  0.2，0.17，0.14，0.12，0.18，0.19，回答下面的问题： ", "\n (1)   试构造一棵哈夫曼树（小值左子树，大值右子树） ", "\n (2)   给出各个字符的编码（按照左0右1编码）", "\n (3)   求其加权路径长度WPL"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;而哈夫曼树&amp;#xff08;Huffman Tree&amp;#xff09;是在叶子结点和权重确定的情况下&amp;#xff0c;带权路径长度最小的二叉树&amp;#xff0c;也被称为最优二叉树。&lt;br /&gt;--链接转自&lt;a href=\"https://blog.csdn.net/qq_45737068/article/details/106910349\" id=\"textarea_1630459855151_1630460459579_0\" class=\"md_link_card\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;\n  &lt;span class=\"md_link_title\"&gt;最全哈夫曼树哈夫曼编码讲解&amp;#xff0c;兄弟你值得拥有_记录博主学到的点滴-CSDN博客&lt;/span&gt;\n  &lt;span class=\"md_link_desc\" style=\"\"&gt;目录 1.哈夫曼树的概念                路径概念        路径长度概念         节点的带权路径长度        树的带权路径长度 2.构建哈夫曼树的步骤 3.构建哈夫曼树的完整代码 4.哈夫曼编码1.哈夫曼树的概念在正式&lt;/span&gt;\n  &lt;span class=\"md_flex_card\"&gt;\n  &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n    &lt;span class=\"flex-1\"&gt;\n      &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_45737068/article/details/106910349&lt;/span&gt;\n    &lt;/span&gt;\n  &lt;/span&gt;&lt;/a&gt;&lt;br /&gt;想要得到一颗哈夫曼树&amp;#xff0c;就应该每次找到权值最小的两个点的权值和作为他们两个点的根节点&amp;#xff0c;这样做的目的是用最大的深度乘以最小的权重。所以为了每次都取最小的两个值&amp;#xff0c;就需要把数组排列一下。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["为什么这个地方要将哈夫曼树的权值由大到小排列。", ["for", "(", "i", "=0;i<256;i++)", "\n{                    ", "//", "按出现权值从大到小排序\n    for", "(", "j", "=i+1;j<256;j++)", "{\n        ", "if", "(header[i].count<header[j].count)", "{\n            tmp=header[i];\n            header[i]=header[j]; \n            header[j]=tmp; \n        } \n    } \n}\nfor", "(", "i", "=0;i<256;i++)", "                    ", "//", "找到第一个空的header结点\n    ", "if", "(header[i].", "count", "==0)", " \n        break; \nn=i;       ", "//", "因为权值已经从大到小排列并且找到了第一个空的header结点，所以这句话代表现有所有结点个数 （n） \nm=2*n-1;    ", "//m", "代表哈夫曼树中需要的所有的结点个数 \nfor", "(", "i", "=n;i<m;i++)", " ", "//", " m=2*n-1\n{\n    min1=999999999;                ", "//", "预设的最大权值，即结点出现的最大次数\n    for", "(", "j", "=0;j<i;j++)", "\n    {\n        ", "if", "(header[j].parent!=-1)", " \n            continue;                /*parent!=-1说明该结点已存在哈夫曼\n                                树中，跳出循环重新选择新结点*/\n        ", "if", "(min1>header[j].count)", " ", "//", "代表不在哈夫曼树中 \n        {    \n            pt1=j; ", "//j", "是下标 \n            min1=header[j]", ".count", "; \n            continue;    \n        } \n    }\n    header[i]", ".count=header", "[pt1]", ".count", "; \n    header[pt1]", ".parent=i", ";      \n    header[i]", ".lch=pt1", ";   \n    min1=999999999;   \n    for", "(", "j", "=0;j<i;j++)", "{\n        ", "if", "(header[j].parent!=-1)", " \n            continue;                                        \n        ", "if", "(min1>header[j].count)", "\n        {\n            pt1=j; \n            min1=header[j]", ".count", "; \n            continue; \n        } \n    }\n    header[i]", ".count", "+=header[pt1]", ".count", "; \n    header[i]", ".rch=pt1", ";   \n    header[pt1]", ".parent=i", ";            ", "//", "哈夫曼无重复前缀编码 \n}\n"]], "Tag": "算法设计"}
{"Answer": "你用写的？\r\nchar cd[n];\r\n这句能通过编译？怎么可能？", "Konwledge_Point": "哈夫曼编码", "Question": ["赫夫曼树出错 ，编译没错 不知道哪里错了运行不了", ["编译没有错误，运行失败", "\n\n", "\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h> \n#include <string.h> \n#define STACK_INIT_SIZE 100//存储空间初始分配量  没分号“;” \n#define STACKINCREMENT 10 //存储空间分配增量\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define INFEASIBLE -1\n\ntypedef struct {\n    unsigned int weight;\n    unsigned int parent,lchild,rchild;  \n}HTNode,*HuffmanTree;\n\ntypedef char **HuffmanCode;\n\n//在HT[1..i-1]选择parent为0且weight最小的两个结点，\n//其序号为最小s1和次小s2(若parent≠0，则说明被选取过不能再选)\n//s1s2并不是指的weight权值，而是最（次）小的这个字符前面的编号（后面需要填进lchild、rchild）\n\nvoid Select(HuffmanTree p,int n,int *s1,int *s2)\n{\n    int i;\n    int min = 99999;\n    for(i=1;i<=n;i++){\n        if(p[i].parent == 0){\n            if(p[i].weight <= min){\n            min = p[i].weight;\n            *s1 = i;\n            }\n        }   \n    }\n    min = 99999;\n    for(i=1;i<=n;i++){\n        if(p[i].parent==0){\n            if(p[i].weight<=min && i!=*s1){\n            min = p[i].weight;\n            *s2 = i;\n            }\n        }   \n    }   \n}\n\n\nvoid HuffmanCoding(HuffmanTree *HT,HuffmanCode *HC,int *w,int n){\n    //n字符 m节点 HT空间\n    int m,i;\n    HuffmanTree p;\n    //int w[8] = {5,29,7,8,14,23,3,11};\n    m = 2*n-1;\n    if(n<=1){return;}   \n    //加上一个未用的0号单元\n    HT = (HuffmanTree *)malloc((m+1)*sizeof(HTNode)); \n\n    //一：初始化，得a图：\n    //(1)把已有字符（1-8） 权重赋值w，左右孩子及parent赋值为0,p指向第二个单元（非0第一个） \n    for(p=*HT+1,i=1 ; i<=n ; ++i,++p,++w){//[问题p=HT+1？]看和鸿昌的聊天记录 \n        //*p={*w,0,0,0};\n        //错误原因： 赋值数组不能分着写\n        //http://zhidao.baidu.com/link?url=jZOgI5PGVycg1v6c1pJ2AlDI3J6fiDLUQQ-1FkGjGzrXTE-hYQusYkoVQlM-EBhr3IjdF9d1wy-o_6elz6m2hald8u0LVM1EUzDaTZ6Rs7e\n        (*p).weight = *w;\n        (*p).parent = 0;\n        (*p).lchild = 0;\n        (*p).rchild = 0;\n    }\n    //(2)把未知字符（9-15） 权重、左右孩子及parent赋值为0， p指向上面跳出来的 未知字符的第一个 9\n    for(;i<=m;++i,++p){\n        (*p).weight = 0;\n        (*p).parent = 0;\n        (*p).lchild = 0;\n        (*p).rchild = 0;    \n    }\n\n    //二：建立赫夫曼树,得到b图 \n    //在HT[1..i-1]选择parent为0且weight最小的两个结点，其序号为最小s1和次小s2(若parent≠0，则说明被选取过不能再选)\n    for(i=n+1;i<=m;++i){    //n+1 即后面未知字符 （比如9开始到15） \n    int s1,s2;\n    //void Select(HuffmanTree HT,int q,int *s1,int *s2){\n    Select(*HT,i-1,&s1,&s2);\n\n    //select(*HT,i-1,&s1,&s2);\n\n    //给s1 s2的parent赋值为当前i 编号 \n    (*HT)[s1].parent = i;\n    (*HT)[s2].parent = i;\n    //给当前i 的lchild和rchild赋值为s1、s2编号 ，给当前i 的 weight赋值为二者权重之和\n    //设最小的作左子树，次小的作右子树 \n    (*HT)[i].lchild = s1;\n    (*HT)[i].rchild = s2;\n    (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;\n    }\n\n    //三：从叶子到根逆向求每个结点字符的赫夫曼编码 \n\n    //存放赫夫曼编码的cd \n    char cd[n];\n    int c,f;\n    //分配n个字符编码的头指针向量HC \n    //HuffmanTree HC;报错类型：declaration of'HTNode* HC'shadows a parameter 原因：函数参数里已有HC的定义导致重复 \n    HC = (HuffmanCode *)malloc((n+1)*sizeof(char *));\n    //编码结束符  如声明cd[8]，0-7中最后一个结束符则为cd[7] \n    cd[n-1] = '\\0';//书上写错了，应该是'\\0' \n    //1-8逐个求 \n    for(i=1;i<=n;++i){\n        //编码结束符位置 \n        int start = n-1;\n        //c=i，f指向当前字 符i的双亲 双亲不为0则循环 经过循环一次后，当前字符变成它的双亲,以此逆向递推 \n        //小细节：--start  如图 \n        for(c=i,f=(*HT)[i].parent;f!=0;c=f,f=(*HT)[f].parent){\n            if((*HT)[f].lchild ==c){\n            cd[--start]='0';//书上写错了，应该是单引号'0' \n            }else{\n            cd[--start]='1';\n            }\n            //for循环结束后，得到cd，为第i个字符分配存储空间HC\n            (*HC)[i] = (char *)malloc((n-start)*sizeof(char));\n            //start目前指到最前面了，所以将cd复制（strcpy）给HC \n            /*原型声明：char *strcpy(char* dest, const char *src);\n                头文件：#include <string.h> 和 #include <stdio.h>\n                功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间*/\n            strcpy((*HC)[i],&cd[start]);\n        }\n    }\n    free(cd);\n}\n\n\n\n\nint main(void){\n   HuffmanTree HT;\n   HuffmanCode HC;\n   int n;\n   printf(\"请输入字符个数(空格间隔)：\");\n   scanf(\"%d\",&n);\n\n   int i; \n   int *w=NULL;\n   w=(int*)malloc(n*sizeof(int));\n   printf(\"请依次输入权值(空格间隔)：\");\n   for(i=0;i<n;i++){\n      scanf(\"%d\",w+i);\n   }\n\n   HuffmanCoding(&HT,&HC,w,n);\n   for(i=1;i<=n;i++){ \n   puts(HC[i]);//???\n   } \n}\n\n", "\n\n", "已解决。。。"]], "Tag": "算法设计"}
{"Answer": "&lt;p style=\"text-align:center\"&gt;&lt;img alt=\"\" src=\"https://img-ask.csdnimg.cn/upload/1624034849533.png\" /&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树压缩，报错不能将errno_t类型的值分配到+file*类型的实体，该怎么修改解决这个问题", ["\n", "#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \n#include <conio.h> \n#define _CRT_SECURE_NO_WARNINGS\n\n/*哈夫曼树结构定义*/\nstruct head\n{\n    unsigned char b;            /*定义一个字符*/\n    long count;                 /*频率数据*/\n    long parent, lch, rch;        /*创建哈夫曼树*/\n    char bits[256];             /*哈夫曼结点*/\n}header[512], tmp;\n\n\n/*压缩文件*/\nvoid yasuo()\n{\n    char filename[255], outputfile[255], buf[512];\n    unsigned char c;\n    char wenjianming[255];\n    long i, j, m, n, f;\n    long min1, pt1, flength;\n    FILE* ifp, * ofp;\n    printf(\"请输入文件地址及文件名：\");\n    gets_s(filename);\n    ifp = fopen_s( &ifp,\"filename\", \"rb\");     /*打开源文件并读取*/\n    while (ifp == NULL)\n    {\n        printf(\"打开文件时出错！\\n\");\n        printf(\"请重新输入文件地址及文件名：\");\n        gets_s(filename);\n        ifp = fopen_s(&ifp,\"filename\", \"rb\");\n    }\n    printf(\"请输入压缩后的文件地址和文件名及后缀：\");\n    gets_s(wenjianming);\n    ofp = fopen_s(&ofp,\"wenjianming\", \"wb\");    /*创建并打开目的文件*/\n\n    while (ofp == NULL)\n    {\n        printf(\"请重新输入压缩后的文件地址和文件名及后缀：\");\n        ofp = fopen_s(&ofp,\"wenjianming\", \"wb\");\n    }\n    flength = 0;\n\n    /*读取ifp文件*/\n    while (!feof(ifp))\n    {\n        fread(&c, 1, 1, ifp);           /*按位读取文件*/\n        header[c].count++;           /*记录文件的字符总数*/\n        flength++;\n    }\n    flength = -1;\n    header[c].count = -1;             /*读取文件结束*/\n    /*构造哈弗曼树，初始结点的设置*/\n    for (i = 0; i < 512; i++)\n    {\n        if (header[i].count != 0)\n            header[i].b = (unsigned char)i;\n        else\n            header[i].b = 0;\n        header[i].parent = -1;\n        header[i].lch = header[i].rch = -1;\n    }\n    /*按结点出现的次数排序*/\n    for (i = 0; i < 256; i++)\n    {\n        for (j = i + 1; j < 256; j++)\n        {\n            if (header[i].count < header[j].count)\n            {\n                tmp = header[i];\n                header[i] = header[j];\n                header[j] = tmp;\n            }\n        }\n    }\n    /*统计不同字符的数量*/\n    for (i = 0; i < 256; i++)\n        if (header[i].count == 0)\n            break;\n    n = i;\n    m = 2 * n - 1;\n    for (i = n; i < m; i++)\n    {\n        min1 = 999999999;\n        for (j = 0; j < i; j++)\n        {\n            if (header[j].parent != -1)\n                continue;\n            if (min1 > header[j].count)\n            {\n                pt1 = j;\n                min1 = header[j].count;\n                continue;\n            }\n        }\n        header[i].count = header[pt1].count;\n        header[pt1].parent = i;\n        header[i].lch = pt1;\n        min1 = 999999999;\n        for (j = 0; j < i; j++)\n        {\n            if (header[j].parent != -1)\n                continue;\n            if (min1 > header[j].count)\n            {\n                pt1 = j;\n                min1 = header[j].count;\n                continue;\n            }\n        }\n        header[i].count += header[pt1].count;\n        header[i].rch = pt1;\n        header[pt1].parent = i;\n    }\n    /*构造哈夫曼树，设置字符编码*/\n    for (i = 0; i < n; i++)\n    {\n        f = i;\n        header[i].bits[0] = 0;\n        while (header[f].parent != -1)\n        {\n            j = f;\n            f = header[f].parent;\n            if (header[f].lch == j)\n            {\n                j = strlen(header[i].bits);\n                memmove(header[i].bits + 1, header[i].bits, j + 1);\n                header[i].bits[0] = '0';\n            }\n            else\n            {\n                j = strlen(header[i].bits);\n                memmove(header[i].bits + 1, header[i].bits, j + 1);\n                header[i].bits[0] = '1';\n            }\n        }\n    } /*哈弗曼构造结束*/\n\n    //读取源文件中的每一个字符，按照设置好的编码替换文件中的字符\n    fseek(ifp, 0, SEEK_SET);\t\t\t\t\t/*把文件指针指向文件的开头*/\n    fwrite(&flength, sizeof(int), 1, ofp);     /*把哈弗曼代码写入ofp文件*/\n    fseek(ofp, 8, SEEK_SET);                   /*以8位二进制数为单位读取*/\n    buf[0] = 0;\n    f = 0;\n    pt1 = 8;\n    while (!feof(ifp))\n    {\n        c = fgetc(ifp);        //从流中读取一个字符，并增加文件指针的位置\n        f++;\n        for (i = 0; i < n; i++)\n        {\n            if (c == header[i].b)\n                break;\n        }\n        strcat_s(buf, header[i].bits); //把header[i].bits所指字符串添加到buf结尾处\n        j = strlen(buf);            //计算字符串buf的长度\n        c = 0;\n        while (j >= 8)     /*按八位二进制数转化成十进制ASCII码写入文件一次进行压缩*/\n        {\n            for (i = 0; i < 8; i++)\n            {\n                if (buf[i] == '1') c = (c << 1) | 1;\n                else c = c << 1;\n            }\n            fwrite(&c, 1, 1, ofp);\n            pt1++;\n            strcpy_s(buf, buf + 8);\n            j = strlen(buf);\n        }\n        if (f == flength)\n            break;\n    }\n    if (j > 0) /*剩余字符数量少于8个*/\n    {\n        strcat_s(buf, \"00000000\");\n        for (i = 0; i < 8; i++)\n        {\n            if (buf[i] == '1') c = (c << 1) | 1;\n            else c = c << 1;     /*对不足的位数补0*/\n        }\n        fwrite(&c, 1, 1, ofp);\n        pt1++;\n    }\n    //将编码信息写入存储文件\n    fseek(ofp, 4, SEEK_SET);     /*fseek 用于二进制方式打开的文件,移动文件读写指针位置.第一个是文件流,第3个是指针零点位置,第2个是把指针移动到的地点. */\n    fwrite(&pt1, sizeof(long), 1, ofp); /*是要输出数据的地址,每次写入的位数,数据项的个数，目标文件地址*/\n    fseek(ofp, pt1, SEEK_SET);\n    fwrite(&n, sizeof(long), 1, ofp);\n    for (i = 0; i < n; i++)\n    {\n        fwrite(&(header[i].b), 1, 1, ofp);\n        c = strlen(header[i].bits);\n        fwrite(&c, 1, 1, ofp);\n        j = strlen(header[i].bits);\n        if (j % 8 != 0)             /*按八位读取，位数不满8位时，对该位补0*/\n        {\n            for (f = j % 8; f < 8; f++)\n                strcat_s(header[i].bits, \"0\");\n        }\n        while (header[i].bits[0] != 0)\n        {\n            c = 0;\n            for (j = 0; j < 8; j++)\n            {\n                if (header[i].bits[j] == '1') c = (c << 1) | 1;\n                else c = c << 1;\n            }\n            strcpy_s(header[i].bits, header[i].bits + 8);  /*把从header[i].bits+8地址开始且含有NULL结束符的字符串赋值到以header[i].bits开始的地址空间 */\n            fwrite(&c, 1, 1, ofp);\n        }\n    }\n    fclose(ifp);\n    fclose(ofp);\n    printf(\"压缩成功\\n\");\n\n}\n/*主函数*/\nvoid main()\n{\n    printf(\"输入a开始压缩\\n\");\n    printf(\"输入b结束压缩\\n\");\n    while (1)\n    {\n        char c;\n        c =_getch();\n        if (c == 'a')\n            yasuo();\n        else\n        {\n            if (c == 'b')\n                return;\n        }\n    }\n}\n"]], "Tag": "算法设计"}
{"Answer": "自己顶下……求解答啊求解答", "Konwledge_Point": "哈夫曼编码", "Question": ["求关于图片裁剪的底层算法解释", ["根据鼠标点击位置得到裁剪范围，然后把指定范围裁剪出来。从底层来看，就是输出指定范围的数据。拿jpg为例，jpg是个压缩格式，经过了游程编码和哈夫曼树，算法是怎么找到鼠标", "\n点击位置是在图像数据的哪里？怎么确定的指定范围对应的图形数据？我看了一些裁剪的源码，但是没有看懂......求大神帮忙解答!!  "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ChatGPT :&lt;br /&gt;在C语言中&amp;#xff0c;无法直接将map写入文件&amp;#xff0c;因为map是一个动态的数据结构&amp;#xff0c;其大小在编译时无法确定。因此&amp;#xff0c;需要将map转换为一种可以写入文件的数据结构&amp;#xff0c;比如数组或者结构体。在本文中&amp;#xff0c;作者使用了一个名为ZipStruct的结构体来存储压缩文件的相关信息&amp;#xff0c;其中包括编码表&amp;#xff08;encodeMap&amp;#xff09;和所占字节数&amp;#xff08;size&amp;#xff09;。在压缩文件时&amp;#xff0c;先将编码表和字节流写入ZipStruct结构体中&amp;#xff0c;然后再将整个结构体写入文件中。在解压文件时&amp;#xff0c;先读取ZipStruct结构体&amp;#xff0c;然后根据其中的编码表将二进制编码字符串转化为原始字符&amp;#xff0c;最后将原始字符写入文件中。需要注意的是&amp;#xff0c;在写入和读取文件时&amp;#xff0c;需要使用二进制模式打开文件&amp;#xff0c;否则可能会出现数据损坏的情况。同时&amp;#xff0c;在写入和读取结构体时&amp;#xff0c;需要使用fwrite和fread函数&amp;#xff0c;而不是普通的文件写入和读取函数。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["关于C语言写入结构体时无法写入map的问题", ["在写哈夫曼编码压缩与解压文件的问题时，Java是非常容器且没有问题的；但是在C语言里面，这个文件读写就变得很困难；当我尝试写入一个结构体时，发现没有问题，但是实际并没有将map的内容顺利写入；而且我发现不管是fread还是fwrite，都无法将无法提前确定大小的map集合写入；太痛苦了；感觉我已经在尝试学习Java序列化的解决思路了。", "\n", "代码如下：（原本以为已经写完的我，才发现只是开了个头；C语言的文件读写好折磨，太折磨了）", "文章地址：", "\n      \n        ", "\n        \n      ", "\n      ", "\n      ", "\n        ", "\n         https://blog.csdn.net/bingbingyihao/article/details/129979463\n        ", "\n      ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "using", " ", "namespace", " std;\n\n", "// 读取文件得到int数组转化成哈夫曼编码得到哈夫曼树，进行压缩与解压", "\n\n", "typedef", " ", "int", " elementType;\n\n", "struct", " ", "Node", "\n{\n    elementType data;\n    ", "int", " value;\n    Node* left;\n    Node* right;\n};\n\n", "struct", " ", "ZipStruct", "\n{\n    map", " encodeMap; ", "// 由哈夫曼树生成的编码表", "\n    ", "int", " size = ", "0", "; ", "// 所占字节数", "\n    ", "int", " zipSize = ", "0", "; ", "// 所占比特数（用于处理末尾数字补全）", "\n};\n\n", "struct", " ", "Zip", "\n{\n    string originFileName;\n    string destFileName; ", "// 压缩生成的文件名", "\n    elementType* buff = ", "NULL", "; ", "// 读入的文件字符数据", "\n    map", "int> twoTuple; ", "// 字符串转化为二元组形式，表示各个字符出现的频率", "\n    map", " encodeMap; ", "// 由哈夫曼树生成的编码表", "\n    string res; ", "// 生成的二进制编码字符串", "\n    ", "int", " size = ", "0", "; ", "// 所占字节数", "\n    ", "int", " zipSize = ", "0", "; ", "// 所占比特数（用于处理末尾数字补全）", "\n};\n\n", "struct", " ", "UnZip", "\n{\n    string originFileName; ", "// 要解压的文件名", "\n    string destFileName; ", "// 解压生成的文件名", "\n};\n\n", "// 将int数组转化为二元组形式，表示各个int数字出现的频率", "\n", "map", "int", "> ", "getList", "(", "int", "* text, ", "int", " length)", ";\n\n", "//自定义排序函数  ", "\n", "bool", " ", "cmp", "(", "const", " Node* node1, ", "const", " Node* node2)", ";\n\n", "// 通过二元组创建哈夫曼树", "\n", "Node* ", "createHafumanTree", "(vector", " list)", ";\n\n", "// 获取编码", "\n", "void", " ", "getCodes", "(Node* root, string path, map", "& encodeMap)", ";\n\n", "// 读取文件内容，得到int数组", "\n", "elementType* ", "readFile", "(string fileName, ", "int", "& size)", ";\n\n", "// 根据编码表将int数组转化为新的编码", "\n", "string ", "transform", "(elementType* buff, ", "int", " length, map", " encodeMap)", ";\n\n", "// 获取文件生成的二进制编码字符串", "\n", "void", " ", "generateCodes", "(Zip& zip)", ";\n\n", "//将传入的二进制字符串转换成十进制，并返回十进制数字", "\n", "int", " ", "binToTen", "(string binaryString)", ";\n\n", "// 将新编码字符串转化为int数组(转化采用末尾不够补0)，减少占用空间，并写入文件中，返回文件比特数，同时一并将编码表和字节与比特数写入", "\n", "void", " ", "zipFile", "(string res, string fileName, ", "int", "& zipSize, ZipStruct* zipStruct)", ";\n\n", "//将传入的int转换成二进制字符串", "\n", "string ", "intToBin", "(", "int", " ch)", ";\n\n", "// 根据编码表将文件还原", "\n", "void", " ", "unZipFile", "(string originFileName, string destFileName, ZipStruct* zipStruct)", ";\n\n", "int", " ", "main", "()", "\n", "{\n    Zip zip;\n    UnZip unZip;\n    ZipStruct zipStruct;\n\n    zip.originFileName = ", "\"D:/test.png\"", ";\n    zip.destFileName = ", "\"D:/test.myZip\"", ";\n    ", "generateCodes", "(zip);\n    zipStruct.encodeMap = zip.encodeMap;\n    zipStruct.size = zip.size;\n    ", "zipFile", "(zip.res, zip.destFileName, zip.zipSize, &zipStruct);\n\n    unZip.originFileName = zip.destFileName;\n    unZip.destFileName = ", "\"D:/test1.png\"", ";\n    ", "unZipFile", "(unZip.originFileName, unZip.destFileName, &zipStruct);\n\n    ", "system", "(", "\"pause\"", ");\n}\n\n", "map", "int", "> ", "getList", "(", "int", "* text, ", "int", " length)", "\n{\n    map", "int> map;\n    ", "for", " (", "int", " i = ", "0", "; i < length; i++)\n    {\n        ", "if", " (map.", "count", "((", "int", ")text[i]) == ", "1", ")\n        {\n            map[text[i]] = map[text[i]] + ", "1", ";\n        }\n        ", "else", "\n        {\n            map[text[i]] = ", "1", ";\n        }\n    }\n    ", "return", " map;\n}\n\n", "bool", " ", "cmp", "(", "const", " Node* node1, ", "const", " Node* node2)", "\n", "{\n    ", "return", " node1->value > node2->value;\n}\n\n", "Node* ", "createHafumanTree", "(vector", " list)", "\n", "{\n    ", "while", " (list.", "size", "() > ", "1", ")\n    {\n        ", "sort", "(list.", "begin", "(), list.", "end", "(), cmp);\n\n        Node* left = list.", "at", "(list.", "size", "() - ", "1", ");\n        Node* right = list.", "at", "(list.", "size", "() - ", "2", ");\n        Node* node = (Node*)", "malloc", "(", "sizeof", "(Node));\n        ", "if", " (node == ", "NULL", ")\n        {\n            cout << ", "\"内存不足\"", " << endl;\n            ", "return", " ", "NULL", ";\n        }\n        node->value = left->value + right->value;\n        node->left = left;\n        node->right = right;\n\n        list.", "pop_back", "();\n        list.", "pop_back", "();\n        list.", "push_back", "(node);\n    }\n\n    ", "return", " list.", "at", "(", "0", ");\n}\n\n", "void", " ", "getCodes", "(Node* root, string path, map", "& encodeMap)", "\n", "{\n    ", "if", " (root == ", "NULL", ")\n    {\n        ", "return", ";\n    }\n    ", "if", " (root->left == ", "NULL", " && root->right == ", "NULL", ")\n    {\n        encodeMap.", "insert", "(map", "::", "value_type", "(root->data, path));\n    }\n    ", "getCodes", "(root->left, path + ", "\"0\"", ", encodeMap);\n    ", "getCodes", "(root->right, path + ", "\"1\"", ", encodeMap);\n}\n\n", "elementType* ", "readFile", "(string fileName, ", "int", "& size)", "\n", "{\n    ", "struct", " ", "stat", " buf;\n    ", "stat", "(fileName.", "c_str", "(), &buf);\n    size = buf.st_size;\n\n    FILE* fp = ", "NULL", ";\n    ", "int", "* buff = ", "new", " ", "int", "[buf.st_size];\n\n    ", "errno_t", " err;\n    ", "if", " ((err = ", "fopen_s", "(&fp, fileName.", "c_str", "(), ", "\"rb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件打开失败\"", " << endl;\n        ", "return", " ", "NULL", ";\n    }\n\n    ", "int", " index = ", "0", ";\n    ", "while", " (index < buf.st_size)\n    {\n        buff[index++] = ", "fgetc", "(fp);\n    }\n    ", "fclose", "(fp);\n    ", "return", " buff;\n}\n\n", "string ", "transform", "(elementType* buff, ", "int", " length, map", " encodeMap)", "\n", "{\n    string res = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i < length; i++)\n    {\n        res += encodeMap[buff[i]];\n    }\n    ", "return", " res;\n}\n\n", "void", " ", "generateCodes", "(Zip& zip)", "\n", "{\n    zip.buff = ", "readFile", "(zip.originFileName, zip.size);\n    zip.twoTuple = ", "getList", "(zip.buff, zip.size);\n    vector", " list;\n    ", "for", " (", "auto", "& it : zip.twoTuple)\n    {\n        Node* node = (Node*)", "malloc", "(", "sizeof", "(Node));\n        ", "if", " (node == ", "NULL", ")\n        {\n            cout << ", "\"内存不足\"", " << endl;\n            ", "return", ";\n        }\n        node->data = it.first;\n        node->value = it.second;\n        node->left = ", "NULL", ";\n        node->right = ", "NULL", ";\n        list.", "push_back", "(node);\n    }\n\n    Node* root = ", "createHafumanTree", "(list);\n    ", "getCodes", "(root, ", "\"\"", ", zip.encodeMap);\n    zip.res = ", "transform", "(zip.buff, zip.size, zip.encodeMap);\n}\n\n", "int", " ", "binToTen", "(string binaryString)", "\n", "{\n    ", "int", " parseBinary = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < binaryString.", "length", "(); ++i)\n    {\n        ", "if", " (binaryString[i] == ", "'1'", ")\n        {\n            parseBinary += ", "pow", "(", "2.0", ", binaryString.", "length", "() - i - ", "1", ");\n        }\n    }\n    ", "return", " parseBinary;\n}\n\n", "void", " ", "zipFile", "(string res, string fileName, ", "int", "& zipSize, ZipStruct* zipStruct)", "\n", "{\n    zipSize = res.", "length", "();\n    zipStruct->zipSize = zipSize;\n    ", "if", " (res.", "length", "() % ", "8", " != ", "0", ")\n    {\n        ", "for", " (", "int", " i = ", "0", "; i < res.", "length", "() % ", "8", "; i++)\n        {\n            res += ", "\"0\"", ";\n        }\n    }\n\n    ", "char", "* bytes = ", "new", " ", "char", "[res.", "length", "() / ", "8", "];\n    ", "int", " index = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < res.", "length", "();)\n    {\n        string subStr = res.", "substr", "(i, ", "8", ");\n        i += ", "8", ";\n        bytes[index] = ", "binToTen", "(subStr);\n        index++;\n    }\n\n    FILE* fp = ", "NULL", ";\n    ", "errno_t", " err;\n    ", "if", " ((err = ", "fopen_s", "(&fp, fileName.", "c_str", "(), ", "\"wb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件写入失败\"", " << endl;\n        ", "return", ";\n    }\n    ", "fwrite", "(zipStruct, ", "sizeof", "(ZipStruct), ", "1", ", fp);\n    ", "fwrite", "(bytes, ", "sizeof", "(", "unsigned", " __int8), res.", "length", "() / ", "8", ", fp);\n    ", "fclose", "(fp);\n}\n\n", "string ", "intToBin", "(", "int", " ch)", "\n", "{\n    string res = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "7", "; i >= ", "0", "; i--)\n    {\n        ", "if", " (ch & (", "128", " >> ", "7", " - i))\n        {\n            res += ", "\"1\"", ";\n        }\n        ", "else", "\n        {\n            res += ", "\"0\"", ";\n        }\n    }\n    ", "return", " res;\n}\n\n", "void", " ", "unZipFile", "(string originFileName, string destFileName, ZipStruct* zipStruct)", "\n", "{\n    FILE* fp = ", "NULL", ";\n    ", "errno_t", " err;\n    ", "if", " ((err = ", "fopen_s", "(&fp, originFileName.", "c_str", "(), ", "\"rb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件打开失败\"", " << endl;\n        ", "return", ";\n    }\n\n    ", "fread", "(zipStruct, ", "sizeof", "(ZipStruct), ", "1", ", fp);\n    map", " decodeMap;\n    ", "for", " (", "auto", "& it : zipStruct->encodeMap)\n    {\n        decodeMap.", "insert", "(map", "char>::", "value_type", "(it.second, it.first));\n    }\n\n    ", "// 为了凑整，省的用if语句了", "\n    ", "int", " size = zipStruct->zipSize;\n    ", "int", " length = (size + ", "7", ") / ", "8", ";\n    ", "int", "* buff = ", "new", " ", "int", "[length];\n    ", "int", " index = ", "0", ";\n    ", "while", " (index < length)\n    {\n        buff[index++] = ", "fgetc", "(fp);\n    }\n    ", "fclose", "(fp);\n\n    string res = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i < length; i++)\n    {\n        res += ", "intToBin", "(buff[i]);\n    }\n\n    string text = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i <= size;)\n    {\n        index = ", "1", ";\n        ", "while", " (i + index <= size)\n        {\n            string temp = res.", "substr", "(i, index);\n            ", "if", " (decodeMap.", "count", "(temp) == ", "1", ")\n            {\n                text += decodeMap[temp];\n                ", "break", ";\n            }\n            index++;\n        }\n        i += index;\n    }\n\n    ", "if", " ((err = ", "fopen_s", "(&fp, destFileName.", "c_str", "(), ", "\"wb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件写入失败\"", " << endl;\n        ", "return", ";\n    }\n    ", "fwrite", "(text.", "c_str", "(), ", "sizeof", "(", "unsigned", " __int8), text.", "length", "(), fp);\n    ", "fclose", "(fp);\n}\n", "\n", "文章可能在审核，要过一小会才能看到"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;贪心的意思就是每次都选最好的&amp;#xff0c;哈夫曼编码的贪心就是每次都选择权重最大的两个结点作为兄弟结点。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["求解哈夫曼编码时如何体现贪心思路", ["请问求解哈夫曼编码时如何体现贪心思路，就是哈夫曼编码的贪心策略吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define max 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; m&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; n,i,top&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,first&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,last&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,first1&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,last1&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[m],z[m];\ntypedef struct snodelinked{undefined\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; data;\nchar bianma;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;parent&lt;/span&gt;;\nstruct snodelinked *Rson,*Lson,*next;\n}snodelinked,*ptr;\nptr hfcreat(ptr head);\n&lt;span class=\"hljs-comment\"&gt;//void bianma(ptr root);&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; preorder(ptr root);\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; x);\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; pop(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top);\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; addq(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; first,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;last,char x);\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; delq(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;first,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; last);\nptr hfinition();\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; translate(ptr root);\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main(){undefined\nptr head,root;\nhead&amp;#61;hfinition();\nroot&amp;#61;hfcreat(head);\npreorder(root);\n&lt;span class=\"hljs-comment\"&gt;// putchar(’\\n’);&lt;/span&gt;\ngetchar();\ntranslate(root);\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\nptr hfinition(){undefined\nptr head,p;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\nhead&amp;#61;p&amp;#61;(ptr)malloc(sizeof(snodelinked));\nhead-&amp;gt;data&amp;#61;max;\nhead-&amp;gt;bianma&amp;#61;’ ‘;\ngetchar();\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;){undefined\np-&amp;gt;next&amp;#61;(ptr)malloc(sizeof(snodelinked));\np&amp;#61;p-&amp;gt;next;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c%1d&amp;#34;&lt;/span&gt;,&amp;amp;p-&amp;gt;bianma,&amp;amp;p-&amp;gt;data);\np-&amp;gt;Lson&amp;#61;p-&amp;gt;Rson&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\np-&amp;gt;parent&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\np-&amp;gt;next&amp;#61;head;\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;\n}\nptr hfcreat(ptr head){undefined\nptr t1,t2,p,q,r;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;#43;&amp;#43;){undefined\nr&amp;#61;(ptr)malloc(sizeof(snodelinked));\nt1&amp;#61;head-&amp;gt;next;\nt2&amp;#61;t1-&amp;gt;next;\nr-&amp;gt;data&amp;#61;t1-&amp;gt;data&amp;#43;t2-&amp;gt;data;\nr-&amp;gt;Lson&amp;#61;t1;\nr-&amp;gt;Rson&amp;#61;t2;\nr-&amp;gt;bianma&amp;#61;’ ‘;\nt1-&amp;gt;parent&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\nt2-&amp;gt;parent&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\nhead-&amp;gt;next&amp;#61;t2-&amp;gt;next;\np&amp;#61;head;\nq&amp;#61;p-&amp;gt;next;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;){undefined\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(r-&amp;gt;data&amp;gt;&amp;#61;q-&amp;gt;data){undefined\np&amp;#61;p-&amp;gt;next;\nq&amp;#61;p-&amp;gt;next;\n}&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{undefined\nr-&amp;gt;next&amp;#61;q;\np-&amp;gt;next&amp;#61;r;\n&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n}\n}\n}\np&amp;#61;head-&amp;gt;next;\nfree(head);\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; p;\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; preorder(ptr root){undefined\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(root-&amp;gt;bianma!&amp;#61;’ ‘){undefined\nputchar(root-&amp;gt;bianma);\nprintf( “:”);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;top;i&amp;#43;&amp;#43;){undefined\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,s[i]);\n}\nputchar(’\\n’);\n}\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(root-&amp;gt;Lson!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {undefined\npush(s,top,root-&amp;gt;Lson-&amp;gt;parent);\npreorder(root-&amp;gt;Lson);\ntop–;\n}\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(root-&amp;gt;Rson!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {undefined\npush(s,top,root-&amp;gt;Rson-&amp;gt;parent);\npreorder(root-&amp;gt;Rson);\ntop–;\n}\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; x){undefined\ns[&amp;#43;&amp;#43;top]&amp;#61;x;\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; pop(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; s[],&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &amp;amp;top){undefined\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,s[top–]);\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; translate(ptr root){undefined\nptr h;\nh&amp;#61;root;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; y;\nchar x;\nx&amp;#61;getchar();\nprintf(“original:”);\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(x!&amp;#61;’\\n’){undefined\naddq(z,first1,last1,x);\nx&amp;#61;getchar();\n}\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(first1!&amp;#61;last1){undefined\ny&amp;#61;delq(z,first1,last1);\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(y&amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {undefined\nh &amp;#61; h-&amp;gt;Lson;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(y&amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) h&amp;#61;h-&amp;gt;Rson;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(h-&amp;gt;bianma!&amp;#61;’ &lt;span class=\"hljs-string\"&gt;&amp;#39;){undefined\nputchar(h-&amp;gt;bianma);\nh&amp;#61;root;\n}\n}\n}\nvoid addq(int z[],int first,int &amp;amp;last,char x){undefined\nif(x&amp;#61;&amp;#61;‘0’) z[last]&amp;#61;0;\nelse if(x&amp;#61;&amp;#61;‘1’) z[last]&amp;#61;1;\nlast&amp;#61;(last&amp;#43;1)%m;\n}\nint delq(int z[],int &amp;amp;first,int last){undefined\nreturn z[first&amp;#43;&amp;#43;];\n}&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/64585133804613.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["程序设计：编写一个哈夫曼编码译码程序。", ["按词频从小到大的顺序给出各个字符（不超过30个）的词频，根据词频构造哈夫曼树，给出每个字符的哈夫曼编码，并对给出的语句进行译码。", "为确保构建的哈夫曼树唯一，本题做如下限定：", "（1）选择根结点权值最小的两棵二叉树时，选取权值较小者作为左子树。", "（2）若多棵二叉树根结点权值相等，按先后次序分左右，先出现的作为左子树，后出现的作为右子树。", "生成哈夫曼编码时，哈夫曼树左分支标记为0，右分支标记为1。", "【输入格式】", "第一行输入字符个数n；", "第二行到第n行输入相应的字符及其词频(可以是整数，与可以是小数）；", "最后一行输入需进行译码的串。", "【输出格式】", "首先按树的先序顺序输出所有字符的编码，每个编码占一行；", "最后一行输出需译码的原文，加上original:字样。", "输出中均无空格", "【样例输入】", "3", "m1", "n1", "c2", "10110", "【样例输出】", "c:0", "m:10", "n:11", "original:mnc"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;哈夫曼编码C语言问题&lt;br /&gt;参考&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/qq_45746876/article/details/109938879\" id=\"textarea_1651893947877_1651894012714_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_45746876/article/details/109938879&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["关于#c语言#的问题：从控制台输入一个字符串，使用哈夫曼编码对该字符串进行编码，输出每个字符对应的编码以及字符串的编码", ["从控制台输入一个字符串，使用哈夫曼编码对该字符串进行编码，输出每个字符对应的编码以及字符串的编码。"]], "Tag": "算法设计"}
{"Answer": "说实话，我也看不懂。\r\n1. 你要给出上下文，如果这是书上的例子，那么书上肯定会事先或事后说明这段代码是干什么。只有光代码，我根本没有耐心看完\r\n2. 你要尝试着自己去理解，如果真看不懂，至少要说出你的理解，然后我们来帮你分析。", "Konwledge_Point": "哈夫曼编码", "Question": ["跪求大神 帮忙，这段关于哈夫曼编码 的程序着实看不懂啊。。。。。。。", ["struct Codetype{//哈弗曼编码数据类型", "\nchar ", "bits;//编码流-数组，n为为哈夫曼树中叶子结点的数目，编码的长度不可能超过n", "\nint start;//编码实际在编码流数组里的开始位置", "\n};", "\nCodetype *HuffmanCode(hufmtree *tree){//哈弗曼编码的生成", "\n  int i,j,p,k;", "\n  Codetype *code; ", "\n  if(tree==NULL)", "\n     return NULL;", "\n  code=(Codetype", ")malloc(tree->n*sizeof(Codetype));//把tree的n个叶子节点生成哈夫曼码", "\n  for(i=0;in;i++)", "\n  {", "\n      printf(\"%c\",tree->node[i].data);//打印字符信息", "\n      code[i].bits=(char*)malloc(tree->n*sizeof(char));", "\n      code[i].start=tree->n-1;", "\n      j=i;", "\n      p=tree->node[i].parent;", "\n      while(p!=-1){", "\n             if(tree->node[p].lchild==j)", "\n                  code[i].bits[code[i].start]='0';", "\n             else", "\n                 code[i].bits[code[i].start]='1';", "\n             code[i].start--;", "\n             j=p;", "\n             p=tree->node[p].parent;", "\n     }", "\n     for(k=code[i].start+1;kn;k++)//打印字符编码", "\n        printf(\"%c\",code[i].bits[k]);", "\n    printf(\"\\n\");", "\n  }", "\n    return code;", "\n}"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/fduan/article/details/7837444\r\nhttp://blog.sina.com.cn/s/blog_686d0fb001012qmh.html", "Konwledge_Point": "哈夫曼编码", "Question": ["电工4课程作业2：哈夫曼编码实验", ["1) 问题描述设某编码系统共有n个字符，使用频率分别为{w1, w2, …, wn}，设计一个不等长的编码方案，使得该编码系统的空间效率最好。2) 基本要求(1) 设计数据结构；(2) 设计编码算法；(3) 分析时间复杂度和空间复杂度。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;要现成代码还是要算法&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["如何用哈夫曼编码进行通信C语言？", ["怎么用哈夫曼编码实现进行通信C语言的", "发送者的功能：", "输入待传送的字符信息；", "统计字符信息中出现的字符种类数和各字符出现的次数（频率）；", "根据字符的种类数和各自出现的次数建立哈夫曼树；", "利用以上哈夫曼树求出各字符的哈夫曼编码；", "将字符信息转换成对应的编码信息进行传送。", "接收者功能：", "接收发送者传送来的编码信息。", "利用上述哈夫曼树对编码信息进行翻译及将编码信息还原成发送前的字符信息。", "\n", "能在VC++6.0中用 .c 运行下图这结果", "\n"]], "Tag": "算法设计"}
{"Answer": "哈夫曼编码是经典的数据压缩算法，有必要好好学习一下的哦。完整实现参考：\r\nhttps://blog.csdn.net/u013571044/article/details/103042941", "Konwledge_Point": "哈夫曼编码", "Question": ["Java语言高分悬赏：怎么实现一个哈夫曼编码树？用到赏节课我们的带权树的构造，要有完整代码", ["Java语言高分悬赏：怎么实现一个哈夫曼编码树？用到赏节课我们的带权树的构造，要有完整代码"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;把void main()改成int main()&amp;#xff0c;最后return 0;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼编码问题，有错误不知怎么改", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/c_kite/article/details/53516670, 我们数据结构实验也是这个, 自己写的, 完美运行, 看完记得点赞给分啊", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构哈弗曼编码，急急急急急急！", ["在记事本软件中，放入不小于1000个英文字符的文本，命名为source.txt。", "\n编写过程，挑出文本中的不相同字符，输出文件列出每个字符的出现概率。", "\n根据字符列表文件建立字符列表的哈夫曼编码本1", "\n以哈夫曼编码本1为参照，将文本文件source.txt的内容转换为二进制码文件code.dat", "\n以哈夫曼编码本1为参照，将二进制码文件code1.dat的内容解码为target.txt明文", "\n编写函数，对比source.txt和 target.txt是否相同，不同则返回出现不同的位置点。", "\n大学生的数据结构作业，求大神帮忙啊！"]], "Tag": "算法设计"}
{"Answer": "在动态创建的过程中，总是出现未利用的空间出现乱码。通过专门建立一个变量来统计用到的数组长度，可以解决了这个问题。", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树构造过程中出现乱码？", ["程序是根据用户输入的一些列字符及其对应的权值，生成哈夫曼树，再根据生成的哈夫曼树进行编码，在测试时，发现输出每个元素对应的哈夫曼编码时，总会出现一些乱码的文字，知道原因的网友点拨一些，谢谢。程序如下：", "\n\n", " #include <iostream>\n#include<string>\nusing namespace std;\nclass HuffNode\n{\npublic:\n    char c;  // 结点的字符\n    int weight;  // 权值\n    int parent, lChild, rChild; // 左右孩子指针\n};\nclass HuffTree\n{\nprivate:\n    int Node_cnt=0;\n    HuffNode* huff=NULL;\n    string* HuffCode = NULL;\npublic:\n    HuffTree(int n, char* c, int* weights);  // 创建Huffman树\n    ~HuffTree();        // 析构函数\n     void setNode_cnt(int cnt){ Node_cnt = cnt; }\n     void select(int end, int& index1, int& index2); // 选出最小和次小叶子结点\n     void printHuffTree();\n     void setHuffCode();\n     void printHuffCode();\n\n};\nHuffTree::~HuffTree()\n{\n    delete[] huff;\n    delete[] HuffCode;\n}\nvoid HuffTree::printHuffCode()\n{\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        cout << huff[i].c << \"的哈夫曼编码为：\" << HuffCode[i] << endl;\n    }\n}\nvoid HuffTree::setHuffCode()  // 左孩子为0，右孩子为1\n{\n    HuffCode = new string[Node_cnt];\n    for (int i = 0; i < Node_cnt; i++)\n    {\n        int son, father; // 孩子指针和双亲指针\n        int cnt = 0;\n        string str;\n        son = i;\n        father = huff[son].parent;\n        while (father != -1)\n        {\n            if (huff[father].lChild == son)\n            {\n                str.append(\"0\");\n            }\n            else\n            {\n                str.append(\"1\");\n            }\n\n            son = father;  // 孩子指针为当前双亲指针\n            father = huff[father].parent;  // 双亲指针为当前双亲指针的双亲\n        }\n        HuffCode[i] = new char[str.size()];\n        for (unsigned int j = 0; j < str.size(); j++)  // 由于求哈夫曼编码时是从叶子结点一直找到树根，故编码为之前的逆序\n        {\n            HuffCode[i][j] = str[str.size() - 1-j];// 逆序\n        }\n    }\n}\nHuffTree::HuffTree(int n,char* ch,int* weights){\n    Node_cnt = n;\n    huff = new HuffNode[2 * Node_cnt - 1];\n    for (int i = 0; i < Node_cnt; i++) // 初始化\n    {\n        huff[i].c = ch[i];\n        huff[i].weight = weights[i];\n        huff[i].lChild = -1;\n        huff[i].rChild = -1;\n        huff[i].parent = -1;\n    }\n    for (int i = Node_cnt; i < Node_cnt * 2 - 1; i++)\n    {\n        int index1 = -1, index2 = -1;\n        select(i - 1, index1, index2);// 选出最小和次小中间树结点索引\n        huff[index1].parent = i;\n        huff[index2].parent = i;\n        huff[i].weight = huff[index1].weight + huff[index2].weight;\n        huff[i].lChild = index1;\n        huff[i].rChild = index2;\n        huff[i].parent = -1;\n    }\n}\n\nvoid HuffTree::printHuffTree()\n{\n    cout << \"所建哈夫曼静态链表示如下：\" << endl;\n    cout << \"位置\\t\" << \"字符\\t\" << \"权值\\t\" << \"双亲\\t\" << \"左孩子\\t\" << \"右孩子\\t\" << endl;\n    for (int i = 0; i < Node_cnt*2-1; i++)\n    {\n        cout << i << \"\\t\" << huff[i].c << \"\\t\" << huff[i].weight << \"\\t\" << huff[i].parent << \"\\t\" << huff[i].lChild << \"\\t\" << huff[i].rChild << endl;\n    }\n}\nvoid  HuffTree::select(int end, int& index1, int& index2)\n    {\n        int min1=100000,min2 = 100000;  // 设m1为最小值，m2为次小值\n        for (int j = 0; j <=end; j++)\n        {\n            if (huff[j].parent == -1)\n            {\n                if (huff[j].weight < min1)  // 如果当前权值比最小值小\n                {\n                    index2 = index1;\n                    index1 = j;\n                    min2 = min1;\n                    min1 = huff[j].weight;\n                }\n                else if (huff[j].weight < min2)  // 如果当前权值比次小值小\n                {\n                    min2 = huff[j].weight;\n                    index2 = j;\n                }\n            }\n        }\n    }\n\nint main()\n{\n\n    int n;\n    cout << \"请输入树叶结点的个数(小于等于1结束)：\" << endl;\n    cin >> n;\n    if (n < 1) return 0;\n    char chs[256];\n    int weights[256];\n\n    for (int i = 0; i < n; i++){\n        cout << \"请输入第\" << i+1 << \"个字符及权值\" << endl;\n        cin >> chs[i] >> weights[i];\n    }\n    HuffTree tree(n,chs,weights);\n    tree.printHuffTree();\n    tree.setHuffCode();\n    tree.printHuffCode();\n\n    return 0;\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;仅供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;\nusing namespace std;\nstruct huffTree {\n    int parent;\n    int lchild;\n    int rchild;\n    int weight;\n    string flag;\n};\nstruct Lowest_node {\n    char ch;\n    int ch_num;\n};\nvoid coding&lt;span class=\"hljs-params\"&gt;(int length,huffTree *tree,int n,int &amp;amp;a,int &amp;amp;b)&lt;/span&gt; {\n    int i;\n    int r,s;\n\n    r&amp;#61;s&amp;#61;length;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(tree[i].weight&amp;lt;r\n         &amp;amp;&amp;amp; tree[i].&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; {\n            r&amp;#61;tree[i]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n            a&amp;#61;i;\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(tree[i].weight&amp;lt;s\n         &amp;amp;&amp;amp; i!&amp;#61;a\n         &amp;amp;&amp;amp; tree[i].&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; {\n            s&amp;#61;tree[i]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n            b&amp;#61;i;\n        }\n    }\n}\nvoid frequency&lt;span class=\"hljs-params\"&gt;(string str)&lt;/span&gt; {\n    int i,j;\n    int length&amp;#61;str.length&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n    Lowest_node *node&amp;#61;new Lowest_node[length];\n\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; node[i]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;0&lt;/span&gt;;\n\n    int char_type_num&amp;#61;0;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(str[i]&amp;#61;&amp;#61;node[j].ch\n            || (&amp;#39;a&amp;#39;&amp;lt;&amp;#61;node[j].ch &amp;amp;&amp;amp; node[j].ch&amp;lt;&amp;#61;&amp;#39;z&amp;#39;\n                &amp;amp;&amp;amp; str[i]&amp;#43;&lt;span class=\"hljs-attr\"&gt;32&lt;/span&gt;&amp;#61;&amp;#61;node[j].ch)&lt;/span&gt;)\n                break;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(j&amp;lt;char_type_num)&lt;/span&gt; node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;#43;&amp;#43;;\n        else {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(&amp;#39;A&amp;#39;&amp;lt;&amp;#61;str[i] &amp;amp;&amp;amp; str[i] &amp;lt;&amp;#61; &amp;#39;Z&amp;#39;)&lt;/span&gt; node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;str&lt;/span&gt;[i]&amp;#43;32;\n            else node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;str&lt;/span&gt;[i];\n            node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;#43;&amp;#43;;\n            char_type_num&amp;#43;&amp;#43;;\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;i;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(node[j].ch_num&amp;lt;node[j&amp;#43;1].ch_num)&lt;/span&gt; {\n                int temp;\n                char ch_temp;\n                temp&amp;#61;node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n                ch_temp&amp;#61;node[j]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;;\n                node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;node&lt;/span&gt;[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n                node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;node&lt;/span&gt;[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;;\n                node[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;temp&lt;/span&gt;;\n                node[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;ch_temp&lt;/span&gt;;\n            }\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt;\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;字符&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;出现了&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;次&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    huffTree *huff&amp;#61;new huffTree[2*char_type_num-1];\n    huffTree temp;\n    string *code&amp;#61;new string[2*char_type_num-1];\n\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;2*char_type_num-1;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        huff[i]&lt;span class=\"hljs-string\"&gt;.lchild&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.rchild&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;-1&lt;/span&gt;;\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; huff[j]&lt;span class=\"hljs-string\"&gt;.weight&amp;#61;node&lt;/span&gt;[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n    int min1,min2;\n    for &lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;k&lt;/span&gt;&amp;#61;char_type_num;k&amp;lt;2*char_type_num-1;k&amp;#43;&amp;#43;)&lt;/span&gt; {\n        coding&lt;span class=\"hljs-params\"&gt;(length,huff,k,min1,min2)&lt;/span&gt;;\n        huff[min1]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;k&lt;/span&gt;;\n        huff[min2]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;k&lt;/span&gt;;\n        huff[min1]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;;\n        huff[min2]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.lchild&amp;#61;min1&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.rchild&amp;#61;min2&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.weight&amp;#61;huff&lt;/span&gt;[min1]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;&amp;#43;huff[min2]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        temp&amp;#61;huff[i];\n        while &lt;span class=\"hljs-params\"&gt;(1)&lt;/span&gt; {\n            code[i]&amp;#61;temp.flag&amp;#43;code[i];\n            temp&amp;#61;huff[temp.parent];\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(temp.&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; break;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;\n        }\n    }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;字符串的每个字符huffman编码为&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; cout&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;code[i]&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;整个字符串的huffman编码为&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; {                                                                                     &lt;span class=\"hljs-string\"&gt;//S&lt;/span&gt;?\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(str[i]&amp;#61;&amp;#61;node[j].ch)&lt;/span&gt;\n                cout&amp;lt;&amp;lt;code[j];\n        }\n    }\n    delete[] node;\n    node&amp;#61;NULL;\n    delete[] huff;\n    huff&amp;#61;NULL;\n    delete[] code;\n    code&amp;#61;NULL;\n}\nint main&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; {\n    int length&amp;#61;0;\n    string str;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个字符串&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin&amp;gt;&amp;gt;str;\n    frequency&lt;span class=\"hljs-params\"&gt;(str)&lt;/span&gt;;\n    return 0;\n}\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;请输入一个字符串&amp;#xff1a;2333abcde\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符3出现了3次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符2出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符a出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符b出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符c出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符d出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符e出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符串的每个字符huffman编码为&amp;#xff1a;\n&lt;span class=\"hljs-string\"&gt;//3&lt;/span&gt;  11\n&lt;span class=\"hljs-string\"&gt;//2&lt;/span&gt;  000\n&lt;span class=\"hljs-string\"&gt;//a&lt;/span&gt;  001\n&lt;span class=\"hljs-string\"&gt;//b&lt;/span&gt;  010\n&lt;span class=\"hljs-string\"&gt;//c&lt;/span&gt;  011\n&lt;span class=\"hljs-string\"&gt;//d&lt;/span&gt;  100\n&lt;span class=\"hljs-string\"&gt;//e&lt;/span&gt;  101\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;整个字符串的huffman编码为&amp;#xff1a;\n&lt;span class=\"hljs-string\"&gt;//000111111001010011100101&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼算法的编码译码系统", ["实现一个哈夫曼编码系统，系统包括以下功能：", "\n", "字符信息统计：读取待编码的源文件SourceFile.txt，统计出现的字符及其频率。", "建立哈夫曼树：根据统计结果建立哈夫曼树。", "建立哈夫曼码表：利用得到的哈夫曼树，将各字符对应的编码表保存在文件Code.txt中。", "对源文件进行编码：根据哈夫曼码表，将SourceFile.txt中的字符转换成相应的编码文件ResultFile.txt。", "\n", "#define _CRT_SECURE_NO_WARNINGS 1", "#include <stdio.h>", "#include <malloc.h>", "#include <string.h>", "#define MAXVALUE 32767        //极大值相当于无穷大", "#define NODENUM 10            //叶子结点数", "typedef struct", "{", "    char data;                //数据域", "    int weight;                //结点的权值", "    int parent, lch, rch;    //下标", "}htNode,*huffmanTree;        ", "\n", "typedef char** huffmanCode;    //第一个", "是代表它是指针变量，说明它是数组", "                            //第二个", "说明它是指针数组，代表这个char类型数组里每个元素都是*huffmanCode变量", "\n", "int initHuffmanTree(huffmanTree& HT);                                //初始化哈夫曼树", "void creatHuffmanTree(huffmanTree& HT, int n);                        //构建哈夫曼树", "void createHuffmanCode(huffmanTree HT, huffmanCode &HC, int n);        //编写哈夫曼编码", "int main()", "{", "    huffmanTree HT ;", "    initHuffmanTree(HT);", "    huffmanCode HC;", "    creatHuffmanTree(HT,NODENUM);", "    createHuffmanCode(HT,HC,NODENUM);", "    /", "for (int i = NODENUM + 1; i <= 2 * NODENUM - 1; i++)", "        printf(\"%d \", HT[i].weight);", "/", "    for (int i = 1; i <= NODENUM; i++)                                //遍历输出编码", "    {", "        printf(\"%c:\\t\",HT[i].data);", "        printf(\"%s\\n\", HC[i]);", "    }", "    return 0;", "}", "int initHuffmanTree(huffmanTree& HT)", "{", "    HT = (htNode*)malloc(sizeof(htNode) * (2 * NODENUM));            //给HT分配2 * NODENUM个htNOde大小的htNode类型的数组", "    for (int i = 1; i <= 2 * NODENUM - 1; i++)                        //下标从1开始到2 * NODENUM", "    {", "        HT[i].parent = HT[i].lch = HT[i].rch = -1;                    //双亲和  的值都置为-1", "    }", "    printf(\"please input some weight!\\n\");", "    for (int i = 1; i <= NODENUM; i++)                                //权值只有1-n个", "    {", "        scanf(\"%d\",&HT[i].weight);                                    //给每个结点赋予权值", "    }", "        char c = getchar();                                            //这个来接收上面的回车", "    printf(\"please input some data!\\n\");", "    for (int i = 1; i <= NODENUM; i++)", "    {", "            //scanf(\"%c \",&HT[i].data);", "            char a = getchar();", "        if(a == '\\n')                                                //遇到回车就结束", "            break;", "        else", "            HT[i].data = a;                                            //给每个结点赋予数据", "    }", "\n", "return", " ", "1", ";\n", "\n", "}", "\n", "void creatHuffmanTree(huffmanTree& HT, int n)", "{", "    if (n <= 1)                                                            //如果结点数小于等于1，不创建", "        return;", "    int min1, min2;                                                        //定义两个数，来存储每次选取最小两个结点的权值", "    int rnode, lnode;                                                    //定义两个下标值，来存储每次选取最小两个结点的下标", "    for (int i = n + 1; i <= 2 * n -1; i++)                                //要生成n-1个结点，所以要操作n—1次且从下标为n+1开始存储", "    {", "        int min1 = MAXVALUE; int lnode = -1;                            //让最小值初始化为极大值，这样叶子结点的最大值再大也不会超过这个值了", "        int min2 = MAXVALUE; int rnode = -1;", "        for (int j = 1; j <= i - 1; j++)                                //因为起先是在前n个中选择最小的两个结点的权值，但新生成一个后就得在前n+1个中选择最小的两个结点的权值", "        {                                                                //假设n = 10 总结点数就得为19，那我们就只要比较18次就可以得出结果了，记住比较的次数比生成的总结点数少1", "                if (HT[j].weight < min1 && HT[j].parent == -1)            //这个小于就使得当出现相同的权值时优先考虑先出现的值，可以假设下", "                {", "                    min2 = min1;    rnode = lnode;                        //碰到比min1小的，那min1的值就给第二小的min2，下标也给它", "                    min1 = HT[j].weight; lnode = j;                        //然后最小的给min1，下标同理", "                }", "                else if (HT[j].weight < min2 && HT[j].parent == -1)        //这是第二小的判断", "                {", "                    min2 = HT[j].weight;", "                    rnode = j;", "                }", "        }", "        HT[lnode].parent = HT[rnode].parent = i;                        //最小两个结点的parent变为生成结点的下标", "        HT[i].lch = lnode; HT[i].rch = rnode;                            //生成结点的左为最小的min1的下标，右同理", "        HT[i].weight = HT[lnode].weight + HT[rnode].weight;                //生成结点的权值等于最小结点的权值相加", "    }", "\n", "}", "\n", "void createHuffmanCode(huffmanTree HT, huffmanCode& HC, int n)", "{", "    HC = (huffmanCode)malloc(sizeof(huffmanCode) * n + 1);                //申请n + 1个huffmanCode大小huffmanCode类型的临时空间", "                                                                        //因为下标是从一开始，所以我们要申请比结点多一个的结点，和哈夫曼树的结构对应，方便输出", "    char* cd = (char*)malloc(sizeof(char) * n);                            //申请n个char大小char类型的临时空间，这个临时数组记录每次遍历出来的编码", "    int start = 0,c = 0,f = 0;                                            //start为cd数组记录下标，c初始为叶子结点下标，而后就是  结点的下标，f记录双亲结点的下标", "    cd[n - 1] = '\\0';                                                    //这个就是给printf留着的，因为printf不会生成'\\0'，如果用puts就不用这句语句了", "    for (int i = 1; i <= n; i++)                                        //只要叶子结点的编码", "    {", "        start = n - 1;                                                    //这句要赋值n的话，start--要写在判断后方", "        c = i;", "        f = HT[c].parent;", "        while (f != -1)                                                    //根节点没有双亲", "        {", "            start--;", "            if (HT[f].lch == c)                                            //是左就是0，右就为1", "                cd[start] = '0';", "            else", "                cd[start] = '1';", "            c = f; f = HT[c].parent;                                    //向根结点接近", "        }", "        HC[i] = (char*)malloc(sizeof(char) * (n - start));                //给数组里的数组申请n - start个char大小的char*类型的临时空间", "        strcpy(HC[i], &cd[start]);                                        //cd里记录的编码给HC的第i个数组", "    }", "    free(cd);                                                            //释放临时空间", "}", "想问一问为什么输入字符后程序闪退\n "]], "Tag": "算法设计"}
{"Answer": "#include&lt;string&gt;\r\nusing namespace std;\r\nHuffmanTree::HuffmanTree()                             //初始化空树\r\n{\r\n Node=NULL;                                           //将树结点初始化为空 \r\n Info=NULL;                                           //将字符数组初始化为空\r\n LeafNum=0;                                           //将叶子数初始化为0\r\n}\r\nHuffmanTree::~HuffmanTree()            //析构函数\r\n{\r\n delete[] Node;                                         //释放结点空间\r\n delete[] Info;                                         //释放字符存储空间\r\n}\r\n/////////////////////////////////////////\r\n//初始化函数\r\nvoid HuffmanTree::Initialization(int WeightNum)         \r\n{\r\n int i,j,pos1,pos2,max1,max2;\r\nNode=new HuffmanNode[2*WeightNum-1];        //为哈夫曼树所需的结点申请空间         \r\nInfo=new char[2*WeightNum-1];\r\n for(i=0;i&lt;WeightNum;i++)                   //先构造weightnum个点\r\n {\r\n  cout&lt;&lt;\"请输入第\"&lt;&lt;i+1&lt;&lt;\"个字符值\";\r\n  cin&gt;&gt;Info[i];\r\n  cout&lt;&lt;\"请输入该字符的权值或频度\";\r\n  cin&gt;&gt;Node[i].weight;                                 //输入权值\r\n  Node[i].parent=-1;                                   //为根结点\r\n  Node[i].lchild=-1;                                   //无左孩子\r\n  Node[i].rchild=-1;                                   //无右孩子\r\n }\r\n//这里构造出weightnum个带权结点\r\n \r\n for(i=WeightNum;i&lt;2*WeightNum-1;i++)                  \r\n {\r\n  pos1=-1;\r\n  pos2=-1;                                            //分别用来存放当前最小值和次小值的所在单元编号 \r\n  max1=32767;                                         //32767为整型数的最大值 \r\n  max2=32767;                                        \r\n  for(j=0;j&lt;i;j++)                                  \r\n   if(Node[j].parent==-1)         \r\n\t   if(Node[j].weight&lt;max1)     \r\n    { \r\n     max2=max1;                                      //原最小值变为次小值\r\n     max1=Node[j].weight;                            //存放最小值\r\n     pos2=pos1;                                      //修改次小值所在单元编号\r\n     pos1=j;                                         //修改最小值所在单元编号\r\n    }\r\n    else\r\n     if(Node[j].weight&lt;max2)                         \r\n     {\r\n      max2=Node[j].weight;                           //存放次小值\r\n      pos2=j;                                        //修改次小值所在的单元编号\r\n     }\r\n  Node[pos1].parent=i;                               //修改父亲位置\r\n  Node[pos2].parent=i;\r\n  Node[i].lchild=pos1;                               //修改儿子位置\r\n  Node[i].rchild=pos2;\r\n  Node[i].parent=-1;                                 //表示新结点应该是根结点\r\n  Node[i].weight=Node[pos1].weight+Node[pos2].weight;\r\n } \r\n LeafNum=WeightNum; \r\n char ch;\r\n cout&lt;&lt;\"是否要替换原来文件(y/n):\";\r\n cin&gt;&gt;ch;\r\n if(ch=='y'||ch=='Y')\r\n {\r\n ofstream fop;                                       //以二进制方式打开hfmTree.dat文件，并当重新运行时覆盖原文件\r\n fop.open(\"hfmTree.dat\",ios::out|ios::binary|ios::trunc);\r\n if(fop.fail())                                      //文件打开失败\r\n  cout&lt;&lt;\"文件打开失败！\\n\";\r\n fop.write((char*)&amp;WeightNum,sizeof(WeightNum));     //写入WeightNum\r\n for(i=0;i&lt;WeightNum;i++)                            //把各字符信息写入文件\r\n {\r\n  fop.write((char*)&amp;Info[i],sizeof(Info[i]));\r\n  flush(cout);\r\n }\r\n for(i=0;i&lt;2*WeightNum-1;i++)                        //把各节点内容写入文件\r\n {\r\n  fop.write((char*)&amp;Node[i],sizeof(Node[i]));\r\n  flush(cout);\r\n }\r\n fop.close();                                        //关闭文件\r\n }\r\n cout&lt;&lt;\"哈夫曼树已构造完成。\\n\";\r\n}\r\n//编码函数\r\nvoid HuffmanTree::Encoder()\r\n{\r\n if(Node==NULL)                                       \r\n{\r\n  ifstream fip;                                        \r\n  fip.open(\"hfmTree.dat\",ios::binary|ios::in);         //以二进制方式打开hfmTree.dat文件\r\n  if(fip.fail())                                       //文件打开失败\r\n  {\r\n   cout&lt;&lt;\"文件打开失败！\\n\";\r\n   return;                                             //结束本函数\r\n  }\r\n  fip.read((char*)&amp;LeafNum,sizeof(LeafNum));           //读取叶子数\r\n  Info=new char[LeafNum]; \r\n  Node=new HuffmanNode[2*LeafNum-1];\r\n  for(int i=0;i&lt;LeafNum;i++)                           //读取字符信息\r\n   fip.read((char*)&amp;Info[i],sizeof(Info[i]));\r\n  for(int i=0;i&lt;2*LeafNum-1;i++)                           //读取结点信息\r\n   fip.read((char*)&amp;Node[i],sizeof(Node[i]));\r\n } \r\n char *Tree;                                           //用于存储需编码内容\r\n int i=0,num;\r\n char Choose;                                         \r\ncout&lt;&lt;\"从文件中读取内容的请选择1，需要重新输入的请选择2:\";\r\n cin&gt;&gt;Choose;\r\n if(Choose=='1')                                       //读取文件ToBeTran.txt\r\n {\r\n  ifstream fip1(\"ToBeTran.txt\");\r\n  if(fip1.fail())                                      //文件不存在\r\n  {\r\n   cout&lt;&lt;\"文件打开失败!\\n\";\r\n   return;                                              //结束本函数\r\n  }\r\n  char ch;\r\n  int k=0;\r\n  while(fip1.get(ch))            \r\n  {\r\n   k++;                                                 \r\n  } \r\n  fip1.close();   \r\n  Tree=new char[k+1];\r\n  ifstream fip2(\"ToBeTran.txt\");\r\n  k=0; \r\n  while(fip2.get(ch))\r\n  {\r\n   Tree[k]=ch;                                            //读取文件内容，并存到Tree中\r\n   k++;\r\n  }\r\n  fip2.close();\r\n  Tree[k]='\\0';                                           //结束标志\r\n  cout&lt;&lt;\"需编码内容为:\";\r\n  cout&lt;&lt;Tree&lt;&lt;endl;\r\n }                                                        //if(Choose=='2')\r\n else                                                   \r\n {\r\n  string tree;                        \r\n                                                        \r\n  cin.ignore();\r\n  cout&lt;&lt;\"请输入需要编码的内容(可输入任意长，结束时请按2下回车):\\n\";\r\n  getline(cin,tree,'\\n');                                //输入任意长字符串，\r\n                                                        \r\n  while(tree[i]!='\\0')\r\n   i++;\r\n  num=i;                                                //计算tree长度\r\n  i=0;\r\n  Tree=new char[num+1];\r\n  while(tree[i]!='\\0')                                  //将tree中的字符转存到Tree中\r\n  {\r\n   Tree[i]=tree[i];\r\n   i++;\r\n  }\r\n     Tree[i]='\\0';                                      //结束标志符\r\n } \r\n ofstream fop(\"CodeFile.dat\",ios::trunc);             \r\ni=0;\r\n int k=0;\r\n char *code;\r\n code=new char[LeafNum];                                //为所产生编码分配容量为LeafNum的存储空间\r\n                                                       \r\n while(Tree[k]!='\\0')                                   //对每一个字符编码\r\n {\r\n  int j,start=0;\r\n  for(i=0;i&lt;LeafNum;i++)\r\n   if(Info[i]==Tree[k])                                 \r\n    break; \r\n   j=i;\r\n  while(Node[j].parent!=-1)                             //结点j非树根\r\n  {\r\n   j=Node[j].parent;                                    //求结点j的双亲结点\r\n   if(Node[j].lchild==i)                                //是左子树，则生成代码0\r\n    code[start++]='0';\r\n   else                       \r\n    code[start++]='1';                                  //是右子树，则生成代码1\r\n   i=j;\r\n  }\r\n  code[start]='\\0';                                     //置串结束符  \r\n  for(i=0;i&lt;start/2;i++)                                //对二进制序列进行逆置\r\n  {\r\n   j=code[i];\r\n   code[i]=code[start-i-1];\r\n   code[start-i-1]=j;\r\n  }\r\n        i=0;\r\n  while(code[i]!='\\0')                                  //存储代码\r\n  {\r\n   fop&lt;&lt;code[i];\r\n   i++;\r\n  }\r\n  k++;\r\n }\r\n fop.close();\r\n cout&lt;&lt;\"编码完成！且存到文件CodeFile.dat中！\\n\\n\";\r\n} \r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//解码函数\r\n\r\nvoid HuffmanTree::Decoder()\r\n{\r\n int i=0,k=0;\r\n int j=LeafNum*2-1-1;                                        \r\n char* BitStr;\r\n \r\n ifstream fip1(\"CodeFile.dat\");                       //利用已建好的哈夫曼树将文件CodeFile中的代码进行译码\r\n if(fip1.fail())        \r\n {\r\n  cout&lt;&lt;        \"请先编码！\\n\";\r\n  return;\r\n }\r\n cout&lt;&lt;\"经译码,原内容为:\";\r\n char ch;\r\n while(fip1.get(ch))            \r\n {\r\n  k++;                                                 \r\n }\r\n fip1.close();  \r\n \r\n BitStr=new char[k+1];\r\n ifstream fip2(\"CodeFile.dat\");\r\n k=0;\r\n while(fip2.get(ch))\r\n {\r\n  BitStr[k]=ch;                                         //读取文件内容\r\n  k++;\r\n }\r\n fip2.close();                \r\n BitStr[k]='\\0';                                        //结束标志符\r\n if(Node==NULL)                                         //还未建哈夫曼树\r\n {\r\n  cout&lt;&lt;\"请先编码!\\n\";\r\n  return;\r\n }\r\n ofstream fop(\"TextFile.dat\");                          //将字符形式的编码文件写入文件CodePrin中\r\n while(BitStr[i]!='\\0')\r\n {\r\n  if(BitStr[i]=='0')\r\n   j=Node[j].lchild;                                   //往左走\r\n  else\r\n   j=Node[j].rchild;                                   //往右走\r\n  if(Node[j].rchild==-1)                               //到达叶子结点\r\n  {\r\n   cout&lt;&lt;Info[j];                                      //输出叶子结点对应的字符\r\n   j=LeafNum*2-1-1;                                   \r\n   fop&lt;&lt;Info[j];                                        //存入文件\r\n  }                                                        \r\n  i++;\r\n }\r\n fop.close(); \r\n cout&lt;&lt;\"\\n译码成功且已存到文件TextFile.dat中！\\n\\n\";\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n//输出编码函数\r\n\r\nvoid HuffmanTree::Print()\r\n{\r\n char ch;\r\n int i=1;\r\n ifstream fip(\"CodeFile.dat\");           \r\n ofstream fop(\"CodePrin.dat\");          \r\n if(fip.fail())\r\n {\r\n  cout&lt;&lt;\"没有文件，请先编码！\\n\";\r\n  return;\r\n }\r\n while(fip.get(ch))\r\n {\r\n  cout&lt;&lt;ch;                                                  //读取文件内容\r\n  fop&lt;&lt;ch;                                                   //存到文件中\r\n  if(i==50)                                                \r\n  {\r\n   cout&lt;&lt;endl;\r\n   i=0;\r\n  }\r\n  i++;\r\n }\r\n cout&lt;&lt;endl;\r\n fip.close();                                               //关闭CodeFile.dat文件\r\n fop.close();                                               //关闭CodePrin.dat文件                                            \r\n}\r\n//输出哈夫曼树\r\n\r\nvoid HuffmanTree::TreePrinting()\r\n{\r\n if(Node==NULL)                                                         \r\n {\r\n  cout&lt;&lt;\"请先建立哈夫曼树！\\n\";\r\n  return;\r\n }\r\n ofstream fop(\"TreePrint.dat\");\r\n cout&lt;&lt;\"结点位置(权值)  \"&lt;&lt;\"编码  \"&lt;&lt;\"左孩子  \"&lt;&lt;\"编码\"&lt;&lt;\"右孩子('^'表示叶子)\\n\";\r\n fop&lt;&lt;\"结点位置(权值)  \"&lt;&lt;\"编码  \"&lt;&lt;\"左孩子  \"&lt;&lt;\"编码\"&lt;&lt;\"右孩子('^'表示叶子)\\n\";\r\n int i;\r\n for(i=(2*LeafNum-2);i&gt;LeafNum-1;i--)        \r\n {\r\n  cout&lt;&lt;i&lt;&lt;\"(\"&lt;&lt;Node[i].weight&lt;&lt;\")\"&lt;&lt;\"--1--\"\r\n  &lt;&lt;Node[i].lchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].lchild].weight&lt;&lt;\")\"&lt;&lt;\"--0--\"\r\n  &lt;&lt;Node[i].rchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].rchild].weight&lt;&lt;\")\"&lt;&lt;endl;\r\n  fop&lt;&lt;i&lt;&lt;\"(\"&lt;&lt;Node[i].weight&lt;&lt;\")\"&lt;&lt;\"--1--\"\r\n  &lt;&lt;Node[i].lchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].lchild].weight&lt;&lt;\")\"&lt;&lt;\"--0--\"\r\n  &lt;&lt;Node[i].rchild&lt;&lt;\"(\"&lt;&lt;Node[Node[i].rchild].weight&lt;&lt;\")\"&lt;&lt;endl;\r\n }\r\n for(;i&gt;=0;i--)\r\n {\r\n  cout&lt;&lt;i&lt;&lt;\":\"&lt;&lt;Node[i].weight&lt;&lt;\"(\"&lt;&lt;Info[i]&lt;&lt;\")---^\\n\";\r\n  fop&lt;&lt;i&lt;&lt;\":\"&lt;&lt;Node[i].weight&lt;&lt;\"(\"&lt;&lt;Info[i]&lt;&lt;\")---^\\n\";\r\n }\r\n}", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构（C++版）哈弗曼 编码", ["问题描述：利用哈夫曼编码进行信息通讯可以大大提高信道的利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传输数据预先编码；在接受端将传来的数据进行译码。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编/译码系统。试为这样的信息收发站编写一个哈夫曼码编码/译码系统。", "\n基本要求：根据某字符文件统计字符出现频度，构造Huffman 树，编制Huffman编码，并将给定字符文件编码，生成编码文件；再将给定编码文件解码，生成字符文件（要求按二进制位表示编码）。", "\n提高要求：改进Huffman编码，产生两种以上的编码方案，对同一组测试数据，用不同的编码方案编码，并从文件长度、算法复杂度等方面进行比较分析。", "\n测试数据：找一个英文文档文件或中文文档文件。", "\n用C++来编写，能实现基本要求和提高要求的。"]], "Tag": "算法设计"}
{"Answer": "您好，楼主的问题已经有解决办法，源码在：http://download.csdn.net/detail/doctorczm/6768399\r\n如果您有积分的话直接去该网址下载即可，如果积分不够的话，我可以将源码粘贴出来，希望能帮助到您！", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树算法设计编码译码", ["求大神帮忙用C++语言写一个算法设计", "\n1）从键盘上输入要进行哈夫曼编码的字符集和对应的权值。", "\n2）构造哈夫曼树的算法", "\n3）完成哈夫曼编码的算法", "\n4）完成哈夫曼译码算法。", "\n5)利用编译码算法，对给定的文本文件t1.txt的英语内容进行编码，保存到指定文件code1.txt中。然后再编写一个函数对code1.txt中的内容进行译码。", "\n要求输入哈夫曼编码时，能输出对应的字符。跪求了   真的没法写啊   想不到思路发到我哦空间或者是", "1511437725@qq.com", "都行啊"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;回答&amp;#xff1a;可以自己设置的&amp;#xff0c;哈夫曼树并不唯一&amp;#xff0c;但最终的编码长度是一样的&amp;#xff0c;即二进制位数一致&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼编码时左边的一定要比右边的小吗，还是可以任意的呀", ["图片最上面那个0.6和0.4就是1大0小，但是好像之前看到的很多都是默认1小0大，左小右大滴"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;def &lt;code class=\"language-javascript\"&gt;__init__&lt;/code&gt;(self,name&amp;#61;None,pro&amp;#61;None):&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;__init__&lt;/code&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  应该是两边各有两个_下划线&lt;/span&gt;&lt;br /&gt;你写的是只有一个下划线&lt;code class=\"language-javascript\"&gt;_init_&lt;/code&gt; &lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢!&lt;/strong&gt; 请点击下我回答下方的采纳该回答按钮。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["python,要求输入对应字符和概率，求哈夫曼编码。", ["这个报错告诉对象没有属性root，但我在_init_不是写过了吗，刚学习类，不太清楚，疑惑。", "\n", "\n", "\n", "完整代码如下", "\n", "char_get=", "input", "().split( )", "#储存字母名称", "\npercent=", "input", "().split()", "#储存概率", "\npercent=[", "int", "(percent[i])", "for", " i ", "in", " ", "range", "(", "len", "(percent))]\nlength=", "len", "(percent)", "#有多少个字符", "\n\n", "class", " ", "Nodecreate", "(", "object", "):\n    ", "def", " ", "_init_", "(", "self,name=", "None", ",pro=", "None", "):\n        self.name=name\n        self.pro=pro\n        self.left=", "None", "\n        self.right=", "None", "\n", "class", " ", "Huffman", "(", "object", "):\n    ", "def", " ", "_init_", "(", "self", "):\n        self.", "list", "=[Nodecreate(char_get(i),percent(i)) ", "for", " i ", "in", " ", "range", "(length)]", "#建立列表，用来进行比较概率。", "\n\n        ", "while", "(self.", "list", ")!=", "1", ":", "#当只剩根节点时停止运行", "\n            self.", "list", ".sort(key=", "lambda", " x:x.pro)", "#从小到大排序", "\n            self.new=Nodecreate(pro=(self.", "list", "[", "0", "].pro+self.", "list", "[", "1", "].", "list", "))", "#新的节点pro之和", "\n\n            self.new.left=self.", "list", ".pop(", "0", ")", "#左节点为列表第一个节点", "\n            self.new.right=self.", "list", ".pop(", "0", ")", "#右节点为现在第一个", "\n            self.", "list", ".append(self.", "list", ")\n        self.root=self.", "list", "[", "0", "]", "#储存根节点", "\n\n        self.myth=[", "0", " ", "for", " i ", "in", " ", "range", " (", "10", ")]\n    ", "def", " ", "order", "(", "self,now_tree,myth_length", "):", "#遍历得到huffman编码", "\n        now_node=now_tree\n        ", "if", " now_node.name==", "None", ":\n            ", "return", "\n        ", "else", ":\n            ", "print", "(now_node.name,end=", "\"\"", ")\n            ", "for", " i ", "in", " ", "range", " (myth_length):\n                ", "print", "(self.myth[i],end=", "\"\"", ")\n            ", "return", "\n        self.myth[myth_length]=", "0", "\n        self.order(now_node.left,myth_length+", "1", ")\n        self.myth[myth_length] = ", "1", "\n        self.order(now_node.right, myth_length + ", "1", ")\n    ", "def", " ", "from_print", "(", "self", "):\n        self.order(self.root,", "0", ")\n\ntree=Huffman()\ntree.from_print()\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;打眼一看&amp;#xff0c;创建的树没传出来&amp;#xff0c;要不先建个伪根节点进去建树&amp;#xff0c;要不把建的树作为返回值返回出来。函数的参数只是形参&amp;#xff0c;在函数里怎么修改也不会影响原来的变量的值。其他函数类似。还有参数类型&amp;#xff0c;C不能传&amp;amp;引用&amp;#xff0c;传指针就可以了&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["用哈夫曼树编码并译码，为啥没有输出呢？", ["#include<stdio.h>", "#include<stdlib.h>", "#include<string.h>", "typedef struct", "{", "    char data;", "    int weight;", "    int parent,lchild,rchild;", "}HTNode,*HuffmanTree;", "\n", "typedef char **HuffmanCode;", "\n", "void Select(HuffmanTree &HT,int m,int &s1,int &s2)//选择两个权值较小的结点,并返回序号", "{", "    int i,j,min1,min2;", "    min1=min2=1000;", "    for(i=1;i<=m;i++)", "        if(HT[i].parent==0&&HT[i].weight<min1)", "        {", "            min1=HT[i].weight;", "            s1=i;", "        }", "    for(j=1;j<=m&&j!=s1;j++)", "        if(HT[i].parent==0&&HT[i].weight<min2)", "        {", "            min2=HT[j].weight;", "            s2=j;", "        }", "} ", "\n", "void CreateHuffmanTree(HuffmanTree &HT,int n)//建立哈夫曼树", "{", "    if(n<=1) return;", "    HT=(HuffmanTree)malloc(sizeof(HTNode)", "2", "n);", "    int i,j,s1,s2;", "    char ch='a';", "    for(i=1;i<=(2", "n-1);++i)", "    {", "        HT[i].parent=0;", "        HT[i].lchild=0;", "        HT[i].rchild=0;", "    }", "    for(j=1;j<=n;++j,ch++)", "    {", "        if(j==1)", "        {", "            HT[1].data=' ';", "            scanf(\"%d\",&HT[j].weight);", "        }", "        else", "        {", "            HT[j].data=ch;", "            scanf(\"%d\",&HT[j].weight);", "        }", "    }", "    for(i=n+1;i<=(2", "n-1);++i)", "    {", "        Select(HT,i-1,s1,s2);", "        HT[s1].parent=i;", "        HT[s2].parent=i;", "        HT[i].weight=HT[s1].weight+HT[s2].weight;", "        HT[i].lchild=s1;", "        HT[i].rchild=s2;", "    }", "}", "\n", "void CreateHuffmanCode(HuffmanTree HT,HuffmanCode &HC,int n)//求哈夫曼编码", "{", "    HC=new char*[n+1];", "    char *cd;", "    cd=(char *)malloc(sizeof(char)*n);", "    int i,start,c,f;", "    for(i=1;i<=n;++i)", "    {", "        start=n-1;", "        c=i;", "        f=HT[i].parent;", "        while(f!=0)", "        {", "            --start;", "            if(HT[f].lchild==c) cd[start]='0';//回溯时走左分支为0，右分支为1", "            else cd[start]='1';", "            c=f;", "            f=HT[f].parent;", "        }", "        HC[i]=(char ", ")malloc(sizeof(char)", "(n-start));", "        strcpy(HC[i],&cd[start]);", "    }", "    delete(cd);", "} ", "\n", "void InterpretCode(HuffmanCode HC,char *str)//译码", "{", "    int i;", "    for(i=0;i<strlen(str);i++)", "    {", "        if(str[i]==' ') printf(\"%s\",HC[1]);", "        else{", "        if(str[i]>='A'&&str[i]<='Z') str[i]=str[i]+32;", "        if(str[i]>='a'&&str[i]<='z') printf(\"%s\",HC[str[i]-95]);", "        }", "    }", "} ", "\n", "int main()", "{", "    HuffmanTree HT;", "    HuffmanCode HC;", "    CreateHuffmanTree(HT,27);", "    printf(\"请输入报文:\");", "    CreateHuffmanCode(HT,HC,27);", "    char s[100];", "    gets(s);", "    InterpretCode(HC,s);", "    return 0;", "}"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_32445015/article/details/79972105", "Konwledge_Point": "哈夫曼编码", "Question": ["求哈夫曼对一西文文本提供最优的编、解码方案，并给出编码与解码结果。 其中编码要求正向与逆向两种方式？", ["其中编码要求正向与逆向两种方式？", "\n要求实现两个方案：从键盘输入进行解码译码和对已有的文件中的一串英文进行编译码"]], "Tag": "算法设计"}
{"Answer": "假设对n个数据huffman编码，你用一个n* n的矩阵保存即可", "Konwledge_Point": "哈夫曼编码", "Question": ["如何在MATLAB中实现哈夫曼编码？", ["我是想用二叉树实现，原本想使用MATLAB调用C语言程序，但是接口函数太难写。", "\n请问怎么在MATLAB中实现树结构，或者用别的方法实现哈夫曼编码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你树不对。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;      &lt;span class=\"hljs-attribute\"&gt;100&lt;/span&gt;\n   &lt;span class=\"hljs-attribute\"&gt;45&lt;/span&gt;   &lt;span class=\"hljs-number\"&gt;55&lt;/span&gt;\n      &lt;span class=\"hljs-attribute\"&gt;25&lt;/span&gt;     &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;\n  &lt;span class=\"hljs-attribute\"&gt;12&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;13&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;14&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;\n             &lt;span class=\"hljs-attribute\"&gt;5&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["这个哈夫曼树是答案错了还是我算错了？", ["各位大佬帮忙看看这题的第十七小问，虽然哈夫曼树不是唯一的， 但是这题我算不出选项中的答案，答案也没有写出这一问的具体步骤，是答案错了我还是我错了？", "\n", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nsourceData &amp;#61; [[&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;14&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;], [&lt;span class=\"hljs-string\"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;]]\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;BinaryTree&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, data, weight&lt;/span&gt;):\n        self.data &amp;#61; data\n        self.weight &amp;#61; weight\n        self.left &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.right &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;min2&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;li&lt;/span&gt;):\n    result &amp;#61; [BinaryTree(&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)), BinaryTree(&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;))]\n    li2 &amp;#61; []\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(li)):\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; li[i].weight &amp;lt; result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].weight:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].weight !&amp;#61; &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;):\n                li2.append(result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n            result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; li[i], result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; li[i].weight &amp;lt; result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].weight:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].weight !&amp;#61; &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;):\n                li2.append(result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n            result[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; li[i]\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n            li2.append(li[i])\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result, li2\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;makeHuffman&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;source&lt;/span&gt;):\n    m2, data &amp;#61; min2(source)\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(m2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].data, m2[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].data)\n    left &amp;#61; m2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n    right &amp;#61; m2[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n\n    sumLR &amp;#61; left.weight &amp;#43; right.weight\n    father &amp;#61; BinaryTree(&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;, sumLR)\n    father.left &amp;#61; left\n    father.right &amp;#61; right\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; data &amp;#61;&amp;#61; []:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; father\n    data.append(father)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; makeHuffman(data)\n\n&lt;span class=\"hljs-comment\"&gt;# 中序&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;intermediateTraversal&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;now, result&amp;#61;[]&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; now &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result\n    intermediateTraversal(now.left, result)\n    result.append(now.data)\n    intermediateTraversal(now.right, result)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result\n\n&lt;span class=\"hljs-comment\"&gt;# 后序&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;postorderTraversal&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;now, result&amp;#61;[]&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; now &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;\n    postorderTraversal(now.left, result)\n    postorderTraversal(now.right, result)\n    result.append(now.data)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result\n\n&lt;span class=\"hljs-comment\"&gt;# 创建哈夫曼树&lt;/span&gt;\nsourceData &amp;#61; [BinaryTree(x[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], x[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; x &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; sourceData]\nm &amp;#61; makeHuffman(sourceData)\n&lt;span class=\"hljs-comment\"&gt;# 中序&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(intermediateTraversal(makeHuffman(sourceData)))\n&lt;span class=\"hljs-comment\"&gt;# 后序&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(postorderTraversal(makeHuffman(sourceData)))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["求解用python遍历哈夫曼编码（中序遍历、后序遍历）", ["已知若干个字符的权重值为=[['a',15]，['b',3]，['c',14]，['d',2]，['e',6]，['f',9]，['g',16]，['h',17]]", "\n", "设计python程序，实现构造哈夫曼树，并采用中根序或后根序遍历方法，获取每个叶子节点的哈夫曼编码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://zhuanlan.zhihu.com/p/144562146\" id=\"textarea_1659095594203_1659095689931_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://zhuanlan.zhihu.com/p/144562146&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;h4 id=\"h4_这篇文章讲的很好&amp;#xff0c;可以参考理解一下&amp;#xff0c;不懂问我哟_1659095689931\"&gt;这篇文章讲的很好&amp;#xff0c;可以参考理解一下&amp;#xff0c;不懂问我哟&lt;/h4&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["数据压缩编码中的哈夫曼编码方法是什么？", ["数据压缩编码中的哈夫曼编码方法是什么？", "怎样进行操作？希望有 大_佬解救。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;5 8 6 7 1 3 1 2 7 怎么变成树&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["关于数据压缩编码中的哈夫曼编码方法的问题", ["数据压缩编码中的哈夫曼编码方法是什么？", "怎样进行操作？希望有 大_佬解救。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;两处小错误&amp;#xff0c;见修改注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;/* run this program using the console pauser or add your own getch, system(&amp;#34;pause&amp;#34;) or input loop */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; weight;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; parent, lchild, rchild;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag;\n}HTNode, * HuffmanTree;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;** HuffmanCode;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Select&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree HT, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; end, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* s1, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* s2)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; end; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (HT[min].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            min&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].parent &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; HT[min].weight &amp;gt; HT[i].weight) {\n            min &amp;#61; i;\n        }\n    }\n    *s1 &amp;#61; min;\n    HT[min].flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    min &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; end; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (HT[min].flag !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            min&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[i].parent &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; HT[min].weight &amp;gt; HT[i].weight) {\n            min &amp;#61; i;\n        }\n    }\n    *s2 &amp;#61; min;\n    HT[min].flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHuffmanTree&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree* HT, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, m &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    *HT &amp;#61; (HuffmanTree)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((m &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(HTNode));\n    HuffmanTree p &amp;#61; *HT;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; m; i&amp;#43;&amp;#43;) {\n        p[i].parent &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        p[i].lchild &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        p[i].rchild &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        p[i].flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入权值&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;(p[i].weight));\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s1, s2;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; n &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; m; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;Select&lt;/span&gt;(*HT, i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;amp;s1, &amp;amp;s2);\n        p[s1].parent &amp;#61; p[s2].parent &amp;#61; i;\n        p[i].lchild &amp;#61; s1;\n        p[i].rchild &amp;#61; s2;\n        p[i].weight &amp;#61; p[s1].weight &amp;#43; p[s2].weight;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHuffmanCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree HT, HuffmanCode* HC, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    (*HC) &amp;#61; (HuffmanCode)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((n &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!(*HC))   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;kong&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* cd &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(n * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!cd)   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;kong&amp;#34;&lt;/span&gt;);\n    cd[n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start &amp;#61; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c &amp;#61; i;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; f &amp;#61; HT[i].parent;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (f !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n            --start;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HT[f].lchild &amp;#61;&amp;#61; c) {\n                cd[start] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                cd[start] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;\n            }\n            c &amp;#61; f;\n            f &amp;#61; HT[f].parent;\n        }\n        &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;%s&amp;#34;,cd);&lt;/span&gt;\n        (*HC)[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((n - start) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;));\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!(*HC)[i]) &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;kong&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;((*HC)[i], cd &amp;#43; start);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, (*HC)[i]);&lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;%s&amp;#34;,HC[i]); 修改&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;--&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(cd);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printHuffmanTree&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanTree HT, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;节点\\tweight\\tparent\\tlchild\\trchild&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d  \\t%d  \\t%d  \\t%d  \\t%d\\n&amp;#34;&lt;/span&gt;, i, \n            HT[i].weight, HT[i].parent, HT[i].lchild, HT[i].rchild);\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* argv[])&lt;/span&gt; &lt;/span&gt;{\n    HuffmanTree HT;\n    HuffmanCode HC;\n    &lt;span class=\"hljs-built_in\"&gt;CreateHuffmanTree&lt;/span&gt;(&amp;amp;HT, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printHuffmanTree&lt;/span&gt;(HT, &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;哈夫曼树&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;CreateHuffmanCode&lt;/span&gt;(HT, &amp;amp;HC, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;; i&amp;#43;&amp;#43;) { &lt;span class=\"hljs-comment\"&gt;// for(i&amp;#61;0;i&amp;lt;&amp;#61;8;i&amp;#43;&amp;#43;) 修改&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, HC[i]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/093773894866171.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼编码有些问题，循环和输出编码有问题", ["问题遇到的现象和发生背景", "\n", "哈夫曼编码函数有些问题，输出哈夫曼编码有些问题", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */", "\n", "typedef", " ", "struct", "{\n    ", "int", " weight;\n    ", "int", " parent,lchild,rchild;\n    ", "int", " flag;\n}HTNode,*HuffmanTree;\n", "typedef", " ", "char", "** HuffmanCode;\n\n\n", "void", " ", "Select", "(HuffmanTree HT,", "int", " end,", "int", " *s1,", "int", " *s2)", "{\n    ", "int", " min=", "1", ",i;\n    ", "for", "(i=", "1", ";i<=end;i++){\n        ", "if", "(HT[i].flag!=", "0", "){\n            ", "continue", ";\n        }\n        ", "while", "(HT[min].flag!=", "0", "){\n            min++;\n        }\n        ", "if", "(HT[i].parent==", "0", "&&HT[min].weight>HT[i].weight){\n                min=i;\n        }    \n    }\n    *s1=min;\n    HT[min].flag=", "1", ";\n    min=", "1", ";\n    ", "for", "(i=", "1", ";i<=end;i++){\n        ", "if", "(HT[i].flag!=", "0", "){\n            ", "continue", ";\n        }\n        ", "while", "(HT[min].flag!=", "0", "){\n            min++;\n        }\n        ", "if", "(HT[i].parent==", "0", "&&HT[min].weight>HT[i].weight){\n                min=i;\n        }\n    }\n    *s2=min;\n    HT[min].flag=", "1", ";\n}\n\n", "void", " ", "CreateHuffmanTree", "(HuffmanTree *HT,", "int", " n)", "{\n    ", "if", "(n<=", "1", ") ", "return", ";\n    ", "int", " i,m=", "2", "*n", "-1", ";\n    *HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    HuffmanTree p=*HT;\n    ", "for", "(i=", "1", ";i<=m;i++){\n        p[i].parent=", "0", ";\n        p[i].lchild=", "0", ";\n        p[i].rchild=", "0", ";\n        p[i].flag=", "0", ";\n    }\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "puts", "(", "\"输入权值：\"", ");\n        ", "scanf", "(", "\"%d\"", ",&(p[i].weight));\n    }\n    ", "int", " s1,s2;\n    ", "for", "(i=n+", "1", ";i<=m;i++){\n        ", "Select", "(*HT,i", "-1", ",&s1,&s2);\n        p[s1].parent=p[s2].parent=i;\n        p[i].lchild=s1;\n        p[i].rchild=s2;\n        p[i].weight=p[s1].weight+p[s2].weight;\n    }    \n}\n\n", "void", " ", "CreateHuffmanCode", "(HuffmanTree HT,HuffmanCode *HC,", "int", " n)", "{\n    ", "int", " i;\n    (*HC)=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", " *));\n     \n    ", "if", "(!(*HC)) ", "printf", "(", "\"kong\"", ");\n    ", "char", " *cd=(", "char", " *)", "malloc", "(n*", "sizeof", "(", "char", "));\n    ", "if", "(!cd) ", "printf", "(", "\"kong\"", ");\n    cd[n", "-1", "]=", "'\\0'", ";\n    \n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "int", " c=i;\n        ", "int", " f=HT[i].parent;\n        \n        ", "while", "(f!=", "0", "){\n            --start;\n            ", "if", "(HT[f].lchild==c){\n                cd[start]=", "'0'", ";\n            }", "else", "{\n                cd[start]=", "'1'", ";\n            }\n            c=f;\n            f=HT[f].parent;\n        }\n        ", "//printf(\"%s\",cd);", "\n        (*HC)[i]=(", "char", " *)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n        ", "if", "(!(*HC)[i]) ", "printf", "(", "\"kong\"", ");\n        ", "strcpy", "((*HC)[i],cd+start);\n        ", "printf", "(", "\"%s\"", ",HC[i]);\n    }\n    ", "puts", "(", "\"--\"", ");\n    ", "free", "(cd);\n}\n\n\n\n\n\n", "void", " ", "printHuffmanTree", "(HuffmanTree HT,", "int", " n)", "{\n    ", "puts", "(", "\"节点\\tweight\\tparent\\tlchild\\trchild\"", ");\n    ", "int", " i;\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "printf", "(", "\"%d  \\t%d  \\t%d  \\t%d  \\t%d\\n\"", ",i,HT[i].weight,HT[i].parent,HT[i].lchild,HT[i].rchild);\n    }\n    \n    \n}\n\n\n", "int", " ", "main", "(", "int", " argc, ", "char", " *argv[])", " ", "{\n    HuffmanTree HT;\n    HuffmanCode HC;\n    ", "CreateHuffmanTree", "(&HT,", "8", ");\n    ", "printHuffmanTree", "(HT,", "15", ");\n    ", "puts", "(", "\"哈夫曼树\"", ");\n    \n    ", "CreateHuffmanCode", "(HT,&HC,", "8", ");\n    \n    ", "int", " i;\n     ", "for", "(i=", "0", ";i<=", "8", ";i++){\n         ", "printf", "(", "\"%s\"", ",HC[i]);\n     }\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "\n", "\n", "@qzjhjxj "]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;tips:\n1&amp;#xff0c;二进制文件读写&amp;#xff08;无法使用string)\n2&amp;#xff0c;ASCII码和字符转换\n3&amp;#xff0c;哈夫曼算法\n4&amp;#xff0c;哈希思想的妙用&amp;#xff08;计算字频&amp;#xff1b;编码使用&amp;#xff09; \n\n数据结构\ntypedef struct\n{\n\tint ascii,weight,parent,lchild,rchild;//哈夫曼树&amp;#xff0c;它们依次表示&amp;#xff1a;字符的ASCII码&amp;#xff0c;双亲&amp;#xff0c;左孩子&amp;#xff0c;右孩子 \n}HTNode,*HuffmanTree;\n\n算法\n假设有n个字符&amp;#xff0c;申请2n个空间&amp;#xff0c;0号不用 ,HTree数组首地址 \n1&amp;#xff0c;初始化1&amp;#xff0c;所有成员赋0&amp;#xff1b;初始化2&amp;#xff0c;读入字符及相应的权值\n2&amp;#xff0c;令下个根节点j &amp;#61; n&amp;#43;1,在parent&amp;#61;0的点中挑选出最小值&amp;#xff0c;次小值分别记录其下标index1&amp;#xff0c;index2&amp;#xff1b;\n3&amp;#xff0c;最小值和次小值的parent&amp;#61;j;  \n*/\n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\n#include&amp;lt;stdlib.h&amp;gt; \n#include&amp;lt;fstream&amp;gt;\n#include&amp;lt;string&amp;gt;\n#include&amp;lt;stack&amp;gt;\n\n#define MIN1 0x1fffffff\n#define MIN2 0x2fffffff\n\n\n//Attention&amp;#xff1a;只可以识别英文输入法下的所有字符&amp;#xff0c;中文打出来的‘&amp;#xff1f;’都不行 \nchar code[20];//二进制读写准备 \n\ntypedef struct\n{\n\tint ascii,weight,parent,lchild,rchild;//哈夫曼树&amp;#xff0c;它们一次表示&amp;#xff1a;字符的ASCII码&amp;#xff0c;双亲&amp;#xff0c;左孩子&amp;#xff0c;右孩子 \n}HTNode,*HuffmanTree;\n\n//统计每个字符出现次数&amp;#xff1a;只有英文符号&amp;#xff0c;否则报错 \nvoid Count_Character_Occur_Frequency()\n{\n\tint cof[256];//存储相应字符出现的次数&amp;#xff0c;字符ASCII为下标。charater_occur_frequency \n\tfor(int i &amp;#61; 0; i &amp;lt; 256; i&amp;#43;&amp;#43;)//初始化字符出现次数统计表 \n\t{\n\t\tcof[i] &amp;#61; 0;\n\t}\n\t//从源文件按行读取&amp;#xff0c;并统计字符个数&amp;#xff0c;由于字符个数有限&amp;#xff0c;所以用字符的ASCII码作为数组下标&amp;#xff0c;数组值作为次数&amp;#xff0c;类似哈希映射 \n\tfstream inFile(&amp;#34;source.txt&amp;#34;,ios::in); \n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;source.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tint sum &amp;#61; 0;//总行数&amp;#xff0c;记录换行个数 \n\tstring s;//存放一行 \n\twhile(true)\n\t{\n\t\tgetline(inFile,s);\n\t\tif(!inFile)break;//避免重复读取最后一个字符 \n\t\tsum&amp;#43;&amp;#43;;\n\t\tfor(int i &amp;#61; 0; i &amp;lt; s.size(); i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tint a &amp;#61; s[i];//cout&amp;lt;&amp;lt;&amp;#34;a:&amp;#34;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;中文会溢出 \n\t\t\tcof[a]&amp;#43;&amp;#43;; //计数 \n\t\t}\n\t}\n\tinFile.close();//好习惯 \n\tint a &amp;#61; &amp;#39;\\n&amp;#39;;//换行符 \n\tcof[a] &amp;#61; sum; //换行符个数 \n\t//&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;将所有出现的字符及其次数写入文件&amp;#xff08;类似全局数组&amp;#xff09;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61; \n\tint n &amp;#61; 0;//计算出现字符总个数 \n\tfor(int i &amp;#61; 0; i &amp;lt; 256; i&amp;#43;&amp;#43;)\n\t{\n\t\tif(cof[i] !&amp;#61; 0)n&amp;#43;&amp;#43;; \n\t}\n\tfstream outFile(&amp;#34;data.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;data.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\toutFile&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;//写入字符总个数 \n\t//打印调试 \n\tfor(int i &amp;#61; 0; i &amp;lt; 256; i&amp;#43;&amp;#43;)\n\t{\n\t\tif(cof[i] !&amp;#61; 0)\n\t\t{\n\t\t\tchar ch &amp;#61; i - &amp;#39;\\0&amp;#39;;\n\t//\t\tcout&amp;lt;&amp;lt;&amp;#34;i: &amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;  字符&amp;#xff1a;&amp;#34;&amp;lt;&amp;lt;ch&amp;lt;&amp;lt;&amp;#34; cof[i]: &amp;#34;&amp;lt;&amp;lt;cof[i]&amp;lt;&amp;lt;endl;\n\t\t\toutFile&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;cof[i]&amp;lt;&amp;lt;endl;//写入文件 \n\t\t}\n\t}\n\toutFile.close();\n}\n//创建哈夫曼树 \nvoid CreateHT()\n{\n\tHuffmanTree HTree;\n\tfstream inFile(&amp;#34;data.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;data.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tint n;//节点个数\n\tinFile&amp;gt;&amp;gt;n;\n\tHTree &amp;#61; (HTNode*)malloc(2*n*sizeof(HTNode));//哈夫曼构造&amp;#xff0c;共需2n-1个&amp;#xff0c;0号单元不用\n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//初始化 1\n\t{\n\t\tHTree[i].ascii &amp;#61; HTree[i].lchild &amp;#61; HTree[i].parent &amp;#61; HTree[i].rchild &amp;#61; HTree[i].weight &amp;#61; 0;//0号单元无用 \n\t} \n\tfor(int i &amp;#61; 1; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)//初始化 2&amp;#xff0c;从文件读取ASCII码及相应权值 \n\t{\n\t\tinFile&amp;gt;&amp;gt;HTree[i].ascii&amp;gt;&amp;gt;HTree[i].weight;\n\t} \n\tinFile.close();\n/*\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//打印输出调试 \n\t{\n\t\tcout&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;endl;\n\t} \n*/\t\n\tfor(int i &amp;#61; n&amp;#43;1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//从n&amp;#43;1开始&amp;#xff0c;进行n-1次计算 \n\t{\n\t\t//寻找最小&amp;#xff0c;次小值&amp;#xff0c;记录其下标 \n\t\tint min1 &amp;#61; MIN1,min2 &amp;#61; MIN2;\n\t\tint index1 &amp;#61; 0,index2 &amp;#61; 0;\n\t\t\n\t\tfor(int j &amp;#61; 1; j &amp;lt; i; j&amp;#43;&amp;#43;)//i是即将要被填入的根节点 \n\t\t{\n\t\t\tif(HTree[j].parent &amp;#61;&amp;#61; 0)//双亲为0表示尚待操作 \n\t\t\t{\n\t\t\t\tif(min1 &amp;gt; HTree[j].weight)\n\t\t\t\t{\n\t\t\t\t\tmin2 &amp;#61; min1;//先赋给次小值 \n\t\t\t\t\tindex2 &amp;#61; index1;\n\t\t\t\t\tmin1 &amp;#61; HTree[j].weight;\n\t\t\t\t\tindex1 &amp;#61; j;\n\t\t\t\t}\n\t\t\t\telse if(min2 &amp;gt; HTree[j].weight)\n\t\t\t\t{\n\t\t\t\t\tmin2 &amp;#61; HTree[j].weight;\n\t\t\t\t\tindex2 &amp;#61; j;\n\t\t\t\t}\n\t\t\t}\n\t\t}//cout&amp;lt;&amp;lt;index1&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;index2&amp;lt;&amp;lt;endl; \n\t\t\n\t\tHTree[i].weight &amp;#61; HTree[index1].weight &amp;#43; HTree[index2].weight;//双亲权值更新 \n\t\tHTree[index1].parent &amp;#61; HTree[index2].parent &amp;#61; i;//孩子的双亲节点更新\n\t\tif(HTree[index1].weight &amp;lt; HTree[index2].weight)//1&amp;#xff0c;两个节点权值不同&amp;#xff0c;左小右大 &amp;#xff1b;相同&amp;#xff0c;下标小者在左 \n\t\t{\n\t\t\tHTree[i].lchild &amp;#61; index1;//下标赋值 \n\t\t\tHTree[i].rchild &amp;#61; index2;\n\t\t}\n\t\telse if(HTree[index1].weight &amp;gt; HTree[index2].weight)\n\t\t{\n\t\t\tHTree[i].lchild &amp;#61; index2;\n\t\t\tHTree[i].rchild &amp;#61; index1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(index1 &amp;lt; index2)\n\t\t\t{\n\t\t\t\tHTree[i].lchild &amp;#61; index1;\n\t\t\t\tHTree[i].rchild &amp;#61; index2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tHTree[i].lchild &amp;#61; index2;\n\t\t\t\tHTree[i].rchild &amp;#61; index1;\n\t\t\t}\n\t\t}\n\t} \n\tfstream outFile(&amp;#34;result.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;result.txt 无法打开&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\toutFile&amp;lt;&amp;lt;n&amp;lt;&amp;lt;endl;//节点个数 \n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//打印输出调试 \n\t{\n//\t\tcout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; ascii:&amp;#34;&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; weight:&amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; parent:&amp;#34;&amp;lt;&amp;lt;HTree[i].parent&amp;lt;&amp;lt;&amp;#34; lchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].lchild&amp;lt;&amp;lt;&amp;#34; rchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].rchild&amp;lt;&amp;lt;endl;\n\t\toutFile&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].parent&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].lchild&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].rchild&amp;lt;&amp;lt;endl;\t\n\t} \n\toutFile.close();\n\t\n\t//&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;建立编码表&amp;#xff0c;写入字符&amp;#xff0c;权值&amp;#xff0c;编码&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;\n\toutFile.open(&amp;#34;result.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;result.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t//利用栈从叶子出发读取每个字符的编码&amp;#xff0c;在写入文件 \n\tstack&amp;lt;char&amp;gt; code;//存储编码 \n\tfor(int i &amp;#61; 1; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)//对n个字符分别求编码 \n\t{\n\t\tint j &amp;#61; i;\n\t\tdo{\n\t\t\tint p &amp;#61; HTree[j].parent;\n\t\t\tif(p !&amp;#61; 0)\n\t\t\t{\n\t\t\t\tint l,r;\n\t\t\t\tl &amp;#61; HTree[p].lchild;\n\t\t\t\tr &amp;#61; HTree[p].rchild;\n\t\t\t\tif(j &amp;#61;&amp;#61; l)code.push(&amp;#39;0&amp;#39;);\n\t\t\t\tif(j &amp;#61;&amp;#61; r)code.push(&amp;#39;1&amp;#39;);\n\t\t\t\tj &amp;#61; p;\n\t\t\t}\n\t\t}while(HTree[j].parent !&amp;#61; 0);\n\t\t\n\t\toutFile&amp;lt;&amp;lt;HTree[i].ascii&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; &amp;#34;;//写入字符&amp;#xff0c;权值 \n\t\twhile(!code.empty())\n\t\t{\n\t\t\toutFile&amp;lt;&amp;lt;code.top();//写入编码 \n\t\t\tcode.pop();\n\t\t}outFile&amp;lt;&amp;lt;endl;\n\t} \n\toutFile.close();\n} \nvoid Encode()\n{\n\tfstream inFile(&amp;#34;result.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt; &amp;#34;result.txt&amp;#34;&amp;lt;&amp;lt;endl;\n\tstring s,codeList[256];//将编码表从文件读入该数组中&amp;#xff0c;ASCII码为下标&amp;#xff0c;类似哈希映射 \n\tint ch,w;\n\twhile(true)\n\t{\n\t\tinFile&amp;gt;&amp;gt;ch&amp;gt;&amp;gt;w&amp;gt;&amp;gt;s;\n\t\tif(!inFile)break;\n\t\tcodeList[ch] &amp;#61; s; \n\t}\n\tinFile.close();\n\t\n\tinFile.open(&amp;#34;source.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;source.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\tfstream outFile(&amp;#34;code.dat&amp;#34;,ios::out|ios::binary);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;code.dat打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\tstring s2;\n\twhile(true)\n\t{\n\t\tgetline(inFile,s);\n\t\tif(!inFile)break;\n\t\tint a;\n\t\tfor(int i &amp;#61; 0; i &amp;lt; s.size(); i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\ta &amp;#61; s[i];//转化为ASCII码 \n\t\t\tint j; \n\t\t\tfor(j &amp;#61; 0; j &amp;lt; codeList[a].size();j&amp;#43;&amp;#43;)\n\t\t\t{\t\n\t\t\t\ts2 &amp;#61; codeList[a];\n\t\t\t\tcode[j] &amp;#61; s2[j];\n\t\t\t}code[j]&amp;#61;&amp;#39;\\0&amp;#39;;//!!!关键的一句 \n\t\t\toutFile.write((char*)code,20*sizeof(char));\n\t\t}\n\t\ta &amp;#61; &amp;#39;\\n&amp;#39;;\n\t\tfor(int j &amp;#61; 0; j &amp;lt; codeList[a].size();j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tcode[j]  &amp;#61; (codeList[a])[j];\n\t\t}\n\t\toutFile.write((char*)code,20*sizeof(char));\n\t}\n\tinFile.close();\n\toutFile.close(); \n}\n//解码 \nvoid Decode()\n{\n\tfstream inFile(&amp;#34;data.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;data.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl; \n\tint n;\n\tinFile&amp;gt;&amp;gt;n;\n\tHuffmanTree HTree;\n\tHTree &amp;#61; (HTNode*)malloc(2*n*sizeof(HTNode));\n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)\n\t{\n\t\tinFile&amp;gt;&amp;gt;HTree[i].ascii &amp;gt;&amp;gt;HTree[i].weight&amp;gt;&amp;gt;HTree[i].parent&amp;gt;&amp;gt;HTree[i].lchild&amp;gt;&amp;gt;HTree[i].rchild;\t\n\t}\n\tinFile.close();\n\tfor(int i &amp;#61; 1; i &amp;lt; 2*n; i&amp;#43;&amp;#43;)//打印输出调试 \n\t{\n\t//\tcout&amp;lt;&amp;lt;&amp;#34;i:&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; ascii:&amp;#34;&amp;lt;&amp;lt;HTree[i].ascii &amp;lt;&amp;lt;&amp;#34; weight:&amp;#34;&amp;lt;&amp;lt;HTree[i].weight&amp;lt;&amp;lt;&amp;#34; parent:&amp;#34;&amp;lt;&amp;lt;HTree[i].parent&amp;lt;&amp;lt;&amp;#34; lchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].lchild&amp;lt;&amp;lt;&amp;#34; rchild:&amp;#34;&amp;lt;&amp;lt;HTree[i].rchild&amp;lt;&amp;lt;endl;\n\t} \n/*\tinFile.open(&amp;#34;code.txt&amp;#34;,ios::in);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;code.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n*/\n\tinFile.open(&amp;#34;code.dat&amp;#34;,ios::in|ios::binary);\n\tif(!inFile)cout&amp;lt;&amp;lt;&amp;#34;code.dat 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tfstream outFile(&amp;#34;recode.txt&amp;#34;,ios::out);\n\tif(!outFile)cout&amp;lt;&amp;lt;&amp;#34;recode.txt 打开失败&amp;#xff01;&amp;#34;&amp;lt;&amp;lt;endl;\n\tchar ch;\n\tint root &amp;#61; 2*n - 1;//char code[100];\n//\tstring s;\n\twhile(true)\n\t{\n\t\tinFile.read((char*)code,20*sizeof(char));\n\t\tif(!inFile)break;\n\t//\tcout&amp;lt;&amp;lt;&amp;#34;ch: &amp;#34;&amp;lt;&amp;lt;ch&amp;lt;&amp;lt;&amp;#34; root: &amp;#34;&amp;lt;&amp;lt;root&amp;lt;&amp;lt;endl;\t\n\t\tfor(int i &amp;#61; 0; code[i] !&amp;#61; &amp;#39;\\0&amp;#39;; i&amp;#43;&amp;#43;)\n\t\t{//cout&amp;lt;&amp;lt;ch;\n\t\t\tch &amp;#61; code[i];\n\t\t\tif(ch &amp;#61;&amp;#61; &amp;#39;0&amp;#39;)root &amp;#61; HTree[root].lchild;\n\t\telse if(ch &amp;#61;&amp;#61; &amp;#39;1&amp;#39;)root &amp;#61; HTree[root].rchild;\n\t\t\n\t\tif(HTree[root].lchild &amp;#61;&amp;#61; 0)\n\t\t{//cout&amp;lt;&amp;lt;endl;\n\t\t\tchar cht &amp;#61; HTree[root].ascii;\n\t\t\toutFile&amp;lt;&amp;lt;cht;\n\t\t\troot &amp;#61; 2*n - 1;\n\t\t} \n\t\t\n\t\t}//cout&amp;lt;&amp;lt;endl;\n\t}\n\toutFile.close();\n}\nint main()\n{\n\tCount_Character_Occur_Frequency();\n\tCreateHT();\n\tEncode();\n\tDecode();\n\treturn 0;\n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树的编码与解码", ["综合训练2\t利用哈夫曼树进行编码与解码\n一、主要目的:\n理解哈夫曼树的概念、掌握哈夫曼树的建立以及利用利用哈夫曼树进行哈夫曼编码的方法。\n二、主要内容:\n在基于哈夫易树进行哈夫易编码的基础理论之上，完成对英文文竟的编码和解码，要求如下:\n1、使用文件流方式。\n自行查阅关于文件流的相关资料。\n2、要求提供编码和解码两种方式\n3、能够打开原文文件(dataxt)，统计其中英文字母(假设均为小写)出现的频率，并以此进行哈夫曼编码(空格以及其他字符不加处理)，将每个字母的哈夫曼编码输出到屏幕，并将编码后的结果输出到码文文件(code.xt)中。\n4、能够根据3中得到的字符编码，将码文文件中的码文进行解码，得到解码后的原文(result.txt)\n5、本综合训练以个人方式完成。\n\n上交方法:各班班长统一收齐发送给我。(只要 CPP 文件，不用 data.txt 文件。)命名格式:数学X班 xxx.cpp\n\n提示:\n(1)建立的哈夫曼树结点应添加保存字母的域\n(2)教材中求哈夫曼编码的算法为递归算法，每次在递归中输出所求编码，而我们需要在对原文编码时使用每个字母的哈夫曼编码，所以应该将递归中求得的字母编码保存下来，以备后用。保存方式自行考虑。\n(3)对原文进行编码时，根据读取到的每个字符进行处理:如果是字母，则往code.txt中输出相应编码(根据2中所得编码);如果是其它字符，则不加处理，直接输出到code.txt。(4)解码应在所建立的哈夫曼树基础上进行。依次读取code.txt 文件中字符，若为0或1.则0进左子树1进右子树，直到叶子结点然后取出叶子节点中的字母输出到result.txt:如果是其它字符，则不加处理，直接输出到result.txt。"]], "Tag": "算法设计"}
{"Answer": "```\r\n new char *[n + 1]返回的是char **\r\n  HuffmanTree *HT是HTNode**类型的\r\n\t两边类型不匹配的\r\n```\r\n不知道楼主到底是要干嘛？\r\n\r\n代码功能归根结底不是别人帮自己看或讲解或注释出来的；而是被自己静下心来花足够长的时间和精力亲自动手单步或设断点或对执行到某步获得的中间结果显示或写到日志文件中一步一步分析出来的。\r\n提醒：再牛×的老师也无法代替学生自己领悟和上厕所！\r\n单步调试和设断点调试（VS IDE中编译连接通过以后，按F10或F11键单步执行，按Shift+F11退出当前函数；在某行按F9设断点后按F5执行停在该断点处。）是程序员必须掌握的技能之一。", "Konwledge_Point": "哈夫曼编码", "Question": ["霍夫曼编码的指针快要搞死我了", ["还是在学数据结构。要写霍夫曼编码了。以下我就直接po全套代码", "\n\n", "\n\n", " #include<iostream>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\n\ntypedef char **HuffmanCode;\ntypedef struct\n{\n    int weight;\n    int parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n\nvoid InsertSearch(HuffmanTree &HT, int n)\n{\n    int i, j;\n    for (i = 2; i <=n ; ++i)\n    {\n        if (HT[i].weight < HT[i -1].weight)\n        {\n            HT[0] = HT[i];\n            HT[i] = HT[i - 1];\n            for (j = i - 2; HT[0].weight < HT[j].weight; --j)\n                HT[j + 1] = HT[j];\n            HT[j + 1] = HT[0];\n        }\n    }\n}\n\nvoid Select(HuffmanTree &HT, int area, int &s1, int &s2)\n{\n    int i, flag = 1;\n    for (i = 1; (i <= area) || (flag == 1); i++)\n    {\n        if (HT[i].parent = 0)\n        {\n            s1 = i;\n            s2 = i + 1;\n            flag = 0;\n        }\n        else continue;\n    }\n}\n\nvoid CreateHuffmanTree(HuffmanTree &HT, int n)\n{\n    int m, i, s1, s2;\n    if (n <= 1)\n        return;\n    m = 2 * n - 1;\n    HT = new HTNode[m + 1];\n    for (i = 1; i <= m; ++i)\n    {\n        HT[i].parent = 0; \n        HT[i].lchild = 0; \n        HT[i].rchild = 0;\n    }\n    for (i = 1; i <= n; ++i)\n        cin >> HT[i].weight;\n\n    InsertSearch(HT, n);\n\n    for (i = n + 1; i <= m; ++i)\n    {\n        Select(HT, i - 1, s1, s2);\n        HT[s1].parent = i; HT[s2].parent = i;\n        HT[i].lchild = s1; HT[i].rchild = s2;\n        HT[i].weight = HT[s1].weight + HT[s2].weight;\n    }\n}\n\nvoid CreateHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n)\n{\n    int i, c, start, f;\n    char *cd;\n    cd = new char[n];\n    cd[n - 1] = '\\0';\n    for (i = 1; i <= n; ++i)\n    {\n        start = n - 1;\n        c = i; f = HT[i].parent;\n        while (f != 0)\n        {\n            --start;\n            if (HT[f].lchild == 0)\n                cd[start] = '0';\n            else\n                cd[start] = '1';\n            c = f;\n            f = HT[f].parent;\n        }\n        HC[i] = new char[n - start];\n        strcpy_s(HC[i], 20, &cd[start]);\n    }\n    delete cd;\n}\n\n\nint main()\n{\n    int n;\n    cout << \"请输入 即将输入的叶子节点个数\" << endl;\n    cin >> n;\n    HuffmanTree *HT = new char *[n + 1];\n    HuffmanCode *HC = new char *[n + 1];\n    CreateHuffmanTree(*HT, n);\n    CreateHuffmanCode(*HT, *HC, n);\n}\n", "\n\n", "\n\n", "问题出在main函数构建HT 和 HC上。po图", "\n\n", "\n\n", "\n\n", "\n\n", "\n\n", "救救我吧，快被指针搞死啦"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我之前的C&amp;#43;&amp;#43; 版本&amp;#xff0c;支持压缩视频https://gitee.com/wubindong/HuffmanTreeCodeApplication/tree/master&amp;#xff0c;可以的话通过下&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["二 实践2:哈夫曼编码", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;输入节点那里有问题&amp;#xff0c;有很多\\n缓存&amp;#xff0c;解决不掉&amp;#xff0c;x没有被赋值&lt;br /&gt;修这个bug确实费劲&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Max 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; weight;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild,rchild,parent;\n} HTNode;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; HTNode HT[Max];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;InitHFMT&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//哈夫曼树初始化子函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入结点个数&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        T[i].weight&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        T[i].lchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        T[i].rchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        T[i].parent&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;InputWeight&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//输入权值子函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w,i;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; x[Max];\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n    \n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入第%d个结点:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-comment\"&gt;//scanf(&amp;#34;%c&amp;#34;,&amp;amp;x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;x:%c&amp;#34;,x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//x&amp;#61;getchar();&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//getchar();&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//T[i].ch&amp;#61;x;&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(x);\n        &lt;span class=\"hljs-comment\"&gt;//T[i].ch[0]&amp;#61;x[0];&lt;/span&gt;\n       &lt;span class=\"hljs-comment\"&gt;// strcpy(T[i].ch,x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;x:%s&amp;#34;,x);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//puts(x);&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; t&amp;#61;x[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        T[i].ch&amp;#61;t;\n        &lt;span class=\"hljs-comment\"&gt;//puts(T[i].ch[0]);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//putchar(t);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//putchar(T[i].ch);&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入第%d个权值:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;w);\n        &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n        T[i].weight&amp;#61;w;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;SelectMin&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(HT T,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p1,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p2)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//选择两个结点中小的结点&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; min1&amp;#61;&lt;span class=\"hljs-number\"&gt;888888&lt;/span&gt;,min2&amp;#61;&lt;span class=\"hljs-number\"&gt;88888&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&amp;#61;i; j&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(min1&amp;gt;T[j].weight)\n            {\n                min1&amp;#61;T[j].weight;\n                *p1&amp;#61;j;\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&amp;#61;i; j&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(min2&amp;gt;T[j].weight&amp;amp;&amp;amp;j!&amp;#61;(*p1))\n            {\n                min2&amp;#61;T[j].weight;\n                *p2&amp;#61;j;\n            }\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreatHFMT&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//构造哈夫曼树&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,p1,p2;\n    &lt;span class=\"hljs-built_in\"&gt;InitHFMT&lt;/span&gt; (T);\n    &lt;span class=\"hljs-built_in\"&gt;InputWeight&lt;/span&gt;(T);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;n; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;SelectMin&lt;/span&gt;(T,i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,&amp;amp;p1,&amp;amp;p2);\n        T[p1].parent&amp;#61;T[p2].parent&amp;#61;i;\n        T[i].lchild&amp;#61;p1;\n        T[i].rchild&amp;#61;p2;\n        T[i].weight&amp;#61;T[p1].weight&amp;#43;T[p2].weight;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;hfnode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//哈夫曼编码函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    j&amp;#61;T[i].parent;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].rchild&amp;#61;&amp;#61;i)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[j].parent!&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        i&amp;#61;j,&lt;span class=\"hljs-built_in\"&gt;hfnode&lt;/span&gt;(T,i);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;huffmannode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//求哈夫曼编码&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n输入的权值对应的哈夫曼编码&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        a&amp;#61;i;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n权值为%i的编码是:&amp;#34;&lt;/span&gt;,T[i].weight);\n        &lt;span class=\"hljs-built_in\"&gt;hfnode&lt;/span&gt;(T,i);\n        i&amp;#61;a;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DeCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HT T,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//解码&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-2&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;n:%d\\n&amp;#34;,n);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入需要译码的二进制:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();&lt;span class=\"hljs-comment\"&gt;//清除缓冲区&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(str);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,T[a].ch);\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;strlen(str):%d\\n&amp;#34;,strlen(str));&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;译码结果为&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//a&amp;#61;2*n-2;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(str[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)\n        {\n            a&amp;#61;T[a].lchild;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(str[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)\n        {\n            a&amp;#61;T[a].rchild;\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(T[a].lchild&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; T[a].rchild&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,T[a].ch);\n            a&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-2&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*    ********哈夫曼编码/译码器********         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             1.创建哈夫曼树;                  *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             2.进行哈夫曼编码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             3.进行哈夫曼译码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             4.退出;                          *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//主函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//int n;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//char A[100];&lt;/span&gt;\n    HT HT;\n    &lt;span class=\"hljs-built_in\"&gt;Menu&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; choice;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n请输入要进行的功能&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;choice);\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(choice)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;CreatHFMT&lt;/span&gt;(HT);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;huffmannode&lt;/span&gt;(HT);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;DeCode&lt;/span&gt;(HT,n);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;退出成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;PAUSE&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入失败&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n &amp;#34;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/204312897046122.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["求解 急 为什么哈夫曼的译码出不了", ["哈夫曼的译码出不来", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<string.h>", "\n", "#", "define", " Max 100", "\n", "typedef", " ", "struct", "\n{\n    ", "char", " ch;\n    ", "int", " weight;\n    ", "int", " lchild,rchild,parent;\n} HTNode;\n\n", "typedef", " HTNode HT[Max];\n", "int", " n;\n", "void", " ", "InitHFMT", " ", "(HT T)", "//哈夫曼树初始化子函数 ", "\n", "{\n    ", "int", " i;\n    ", "printf", "(", "\"请输入结点个数：\"", ");\n    ", "scanf", "(", "\"%d\"", ",&n);\n    ", "for", "(i=", "0", ";i<", "2", "*n", "-1", ";i++) \n    {\n        T[i].weight=", "0", ";\n        T[i].lchild=", "-1", ";\n        T[i].rchild=", "-1", ";\n        T[i].parent=", "-1", ";\n    }\n}\n", "void", " ", "InputWeight", "(HT T)", "//输入权值子函数 ", "\n", "{\n    ", "int", " w,i;\n    ", "char", " x;\n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "printf", "(", "\"输入第%d个结点:\"", ",i+", "1", ");\n        ", "scanf", "(", "\"%c\"", ",&x);\n        ", "getchar", "();\n        T[i].ch=x;\n    }\n        \n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "printf", "(", "\"输入第%d个权值:\"", ",i+", "1", ");\n        ", "scanf", "(", "\"%d\"", ",&w);\n        ", "getchar", "();\n        T[i].weight=w;\n    }\n}\n", "void", " ", "SelectMin", " ", "(HT T,", "int", " i,", "int", " *p1,", "int", " *p2)", "//选择两个结点中小的结点 ", "\n", "{\n    ", "long", " min1=", "888888", ",min2=", "88888", ";\n    ", "int", " j;\n    ", "for", "(j=", "0", ";j<=i;j++)\n    {\n     ", "if", "(T[j].parent==", "-1", ")\n        {\n         ", "if", "(min1>T[j].weight)\n         {\n             min1=T[j].weight;\n             *p1=j;\n         }\n        }\n    }\n    ", "for", "(j=", "0", ";j<=i;j++)\n    {\n        ", "if", "(T[j].parent==", "-1", ")\n        {\n            ", "if", "(min2>T[j].weight&&j!=(*p1))\n            {\n                min2=T[j].weight;\n                *p2=j;\n            }\n        }\n    }\n}\n", "void", " ", "CreatHFMT", "(HT T)", "//构造哈夫曼树 ", "\n", "{\n    ", "int", " i,p1,p2;\n    ", "InitHFMT", " (T);\n    ", "InputWeight", "(T);\n    ", "for", "(i=n;i<", "2", "*n", "-1", ";i++)\n    {\n        ", "SelectMin", "(T,i", "-1", ",&p1,&p2);\n        T[p1].parent=T[p2].parent=i;\n        T[i].lchild=p1;\n        T[i].rchild=p2;\n        T[i].weight=T[p1].weight+T[p2].weight;\n    }\n} \n", "void", " ", "hfnode", "(HT T,", "int", " i)", "//哈夫曼编码函数 ", "\n", "{\n    ", "int", " j;\n    j=T[i].parent;\n    ", "if", "(T[j].rchild==i)\n       ", "printf", "(", "\"1\"", ");\n    ", "else", "\n       ", "printf", "(", "\"0\"", ");\n    ", "if", "(T[j].parent!=", "-1", ")\n       i=j,", "hfnode", "(T,i);\n}\n", "void", " ", "huffmannode", "(HT T)", "//求哈夫曼编码 ", "\n", "{\n    ", "int", " i,j,a;\n    ", "printf", "(", "\"\\n输入的权值对应的哈夫曼编码\"", ");\n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        j=", "0", ";\n        a=i;\n        ", "printf", "(", "\"\\n权值为%i的编码是:\"", ",T[i].weight);\n        ", "hfnode", "(T,i);\n        i=a;\n     } \n}\n\n", "void", " ", "DeCode", "(HT T,", "int", " n)", "//解码", "\n", "{\n    ", "int", " i;\n    ", "char", " str[", "50", "];\n    ", "int", " a=", "2", "*n", "-2", ";\n    ", "printf", "(", "\"请输入需要译码的二进制:\\n\"", ");\n    ", "getchar", "();", "//清除缓冲区 ", "\n    ", "gets", "(str);\n    ", "printf", "(", "\"译码结果为：\\n\"", ");\n    ", "for", "(i=", "0", "; i<", "strlen", "(str);i++)\n    {\n        ", "if", "(str[i]==", "'0'", ")\n        {\n                a=T[a].lchild;\n        }\n        ", "else", " ", "if", "(str[i]==", "'1'", ")\n        {\n                a=T[a].rchild;\n        }\n        ", "if", "(T[a].lchild==", "-1", " && T[a].rchild==", "-1", ")\n        {\n            ", "printf", "(", "\"%c\"", ",T[a].ch);\n            a=", "2", "*n", "-2", ";\n        }\n    } \n    ", "printf", "(", "\"\\n\"", ");\n}\n", "void", " ", "Menu", "()", "\n    ", "{\n    ", "printf", "(", "\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\"", ");\n    ", "printf", "(", "\"*    ********哈夫曼编码/译码器********         *\\n\"", ");\n    ", "printf", "(", "\"*             1.创建哈夫曼树;                  *\\n\"", ");\n    ", "printf", "(", "\"*             2.进行哈夫曼编码;                *\\n\"", ");\n    ", "printf", "(", "\"*             3.进行哈夫曼译码;                *\\n\"", ");\n    ", "printf", "(", "\"*             4.退出;                          *\\n\"", ");\n    ", "printf", "(", "\"◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n\"", ");\n    }\n", "int", " ", "main", "()", "//主函数 ", "\n", "{\n    ", "int", " n;\n    ", "char", " A[", "100", "];\n    HT HT;\n    ", "Menu", "();\n    ", "while", "(", "1", ")\n    {\n        ", "int", " choice;\n        ", "printf", "(", "\"\\n请输入要进行的功能：\"", ");\n            ", "scanf", "(", "\"%d\"", ",&choice);\n            ", "switch", "(choice)\n            {\n                ", "case", " ", "1", ":\n                    ", "CreatHFMT", "(HT);\n                ", "break", ";\n                ", "case", " ", "2", ":\n                    ", "huffmannode", "(HT);\n                    ", "break", ";\n                ", "case", " ", "3", ":\n                    ", "DeCode", "(HT,n);\n                    ", "break", ";\n                ", "case", " ", "4", ":\n                    ", "printf", "(", "\"退出成功！\\n\"", ");\n                    ", "system", "(", "\"PAUSE\"", ");\n                    ", "break", "; \n                ", "default", ":\n                    ", "printf", "(", "\"输入失败！\\n\"", ");\n                    ", "break", ";\n                    \n            }\n    }\n    ", "printf", "(", "\"\\n \"", ");\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/xiaoting451292510/article/details/12559421", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树的编码链式存储怎么画，译码链式存储怎么画？", ["哈夫曼树的编码存储怎么画，译码存储怎么画？像二叉树那样画的话那它的0,1序列标在哪里"]], "Tag": "算法设计"}
{"Answer": "这个属于数据的序列化和反序列化问题。在这里是对树的序列化和反序列化。\r\n最简单的方式莫过于在内存里以完全二叉树的空间存储哈夫曼树，然后文件里直接写入这块内存就好了。", "Konwledge_Point": "哈夫曼编码", "Question": ["求教，哈夫曼树问题，感觉好难", ["大佬们，哈夫曼编码的问题，编码完毕后，下次不初始化，怎么从文件中读出哈夫曼树？怎么打印哈夫曼树？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/hold_twenty/article/details/95602451\"&gt;https://blog.csdn.net/hold_twenty/article/details/95602451&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼算法应用(数据结构)", ["求大神解答\n哈夫曼算法的应用\n1.问题描述\n假设某文本文档只包含26个英文字母，应用哈夫曼算法对该文档进行压缩和解压缩操作，使得该文档占用较少的存储空间。\n2.基本要求\n(1)假设文档内容从键盘输入；\n(2)设计哈夫曼算法的存储结构；\n(3)设计哈夫曼编码和解码算法；\n(4)分析时间复杂度和空间复杂度。\n3.设计思想\n对于给定的文档，首先通过扫描确定文档中出现了哪些英文字母以及出现的次数，以出现的次数作为叶子结点的权值构造哈夫曼树，获得各字符的哈夫曼编码；然后再扫描一遍文档将其进行哈夫曼压缩编码，将文本文档转换为二进制编码输出；最后将该二进制流进行解码，并与原文档进行对照，以验证算法的正确性。哈夫曼算法的存储结构以及哈夫曼算法请参见主教材5.7.1节。\n【思考题】如果对任意以文件形式存在的文本文档，如何实现应用哈夫曼算法进行压缩和解压缩？"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你可以参考下这个问题的回答, 看看是否对你有帮助, 链接: &lt;a href=\"https://ask.csdn.net/questions/7517842\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7517842&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;这篇博客你也可以参考下&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/Edward_Mcc/article/details/122567436\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;哈夫曼编码实验报告&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;这篇博客也不错, 你可以看下&lt;a href=\"https://blog.csdn.net/Edward_Mcc/article/details/122567436\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;哈夫曼编码实验报告&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树编码以及译码", ["求一个哈夫曼树编码以及译码的小程序，26个字母以及权值已经给出，希望以此建立哈夫曼树。在由键盘输入字符串或者二进制数时可以根据此树进行编码或译码"]], "Tag": "算法设计"}
{"Answer": "步骤1.构造哈夫曼树，\n2.输入字符个数\n3.输入字符\n4.输入权值\n5.遍历打印输出树\n6.乱序输入字符，输出编码\n7.乱序输入编码，输出对应字符", "Konwledge_Point": "哈夫曼编码", "Question": ["一个程序，哈夫曼树的构造遍历打印，编码解码，缺少遍历和打印", ["#include ", "\n#include     /* 数组头文件 ", "/", "\n#include ", "\n#define MAX 999    /", " 定义长度 ", "/", "\ntypedef struct{     /", " 定义哈夫曼编码的结构数组 ", "/", "\n    char data;", "\n    int weight;    /", " 定义权值 ", "/", "\n    int parent;", "\n    int lchild;", "\n    int rchild;", "\n}huffmannode;", "\ntypedef struct{      /", " 定义保存哈夫曼结构体 ", "/", "\n    char bits[50];", "\n    int start;", "\n}huffmancode ;", "\nvoid main()", "\n{", "\n    huffmannode ht[100];    /", " 定义储存权值的空间 ", "/", "\n    huffmancode cd[100];", "\n    char string[100];      /", " 定义数组存储空间 ", "/", "\n    char hcd[100];", "\n    int i,j,x,y,s1,s2,m1,m2,n,c,f,k;", "\n    printf(\"please input the n =\");     /", " 输入字符的个数 ", "/", "\n    scanf(\"%d\",&n);", "\n    printf(\"\\n============================\\n\");", "\n    for(i=0;i<n;i++)", "\n    {", "\n        getchar();                 /", " 获得输入的字符 ", "/", "\n        printf(\"please input the value :\");", "\n        scanf(\"%c\",&ht[i].data);            /", " 输入字符函数 ", "/", "\n        printf(\"please input the weight:\\n\");", "\n        scanf(\"%d\",&ht[i].weight);", "\n    }", "\n    printf(\"\\n=============================\\n\");", "\n    for(i=0;i<2*n-1;i++)", "\n    {", "\n        ht[i].parent=ht[i].lchild=ht[i].rchild=-1;  /", " 初始化父结点，左右子结点 ", "/", "\n    }", "\n    for (i=n;i<2*n-1;i++)", "\n    {", "\n        s1=s2=0;                        /", " 初始化变量 ", "/", "\n        m1=m2=MAX;", "\n        for (j=0;j<i;j++)", "\n     {", "\n            if (ht[j].weight<m1 &&ht[j].parent==-1) /", " 寻找无父结点的最小值 ", "/", "\n            {", "\n                m2=m1;", "\n                s2=s1;", "\n                m1=ht[j].weight;", "\n                s1=j;                           /", " 寻找当前最小值 ", "/", "\n            }", "\n            else if(ht[j].weight<m2 &&ht[j].parent==-1) /", " 寻找无父结点的次小值 ", "/", "\n            {", "\n                m2=ht[j].weight;", "\n                s2=j;", "\n            }                              /", " 寻找次小值 ", "/", "\n        }", "\n        ht[s1].parent=i;                 /", " s1的父结点为i ", "/", "\n        ht[s2].parent=i;", "\n        ht[i].weight=m1+m2;             /", " 最小值的权值相加为i的权值 ", "/", "\n        ht[i].lchild=s1;                /", " i的左子为s1 ", "/", "\n        ht[i].rchild=s2;                /", " i的右子为s2 ", "/", "\n    }", "\n    for(i=0;i<n;i++)", "\n    {", "\n        cd[i].start=n;", "\n        x=i;", "\n        y=ht[x].parent;                /", " 记录父结点 ", "/", "\n        while (y!=-1)", "\n        {", "\n            if (ht[y].lchild==x)", "\n                cd[i].bits[cd[i].start]='0';   /", " 给字符赋0值 ", "/", "\n            else", "\n               cd[i].bits[cd[i].start]='1';    /", " 给字符赋1值 ", "/", "\n            cd[i].start--;", "\n            x=y;", "\n            y=ht[y].parent;", "\n        }", "\n    }", "\n    printf(\"\\cout the huffmancode:\\n\");", "\n    for (i=0;i<n;i++)", "\n    {", "\n        printf(\"%c:\",ht[i].data);         /", " 输出字符 ", "/", "\n        for(j=cd[i].start;j<=n;j++){", "\n            printf(\"%c\",cd[i].bits[j]);    /", " 输出字符的01代码 ", "/", "\n        }", "\n         printf(\"\\n\");", "\n    }", "\n    printf(\"\\n=============================\\n\");", "\n    printf(\"\\n Please input the message:\\n\");", "\n    scanf(\"%s\",string);                    /", " 输入字符串 ", "/", "\n    for(i=0;string[i]!='0';i++)", "\n    {", "\n        for(c=0;c<=n;c++)", "\n            if(string[i]==ht[c].data)  /", " 寻找与输入字符相匹配的字母 ", "/", "\n            {", "\n                for(j=cd[c].start;j<=n;j++)", "\n                    printf(\"%c\",cd[c].bits[j]);   /", " 输出字母代码 ", "/", "\n                break;", "\n            }", "\n    }", "\n    printf(\"\\n=============================\\n\");", "\n    printf(\"Please input the HuffmanCode:\\n\");", "\n    scanf(\"%s\",hcd);                  /", " 输入0、1代码 ", "/", "\n    f=2*n-2;", "\n    for(i=0;hcd[i]!='\\0';i++)", "\n    {", "\n        if(hcd[i]=='0')               /", " 判断输入为0，寻找左子 ", "/", "\n            f=ht[f].lchild;", "\n        else if(hcd[i]=='1')", "\n            f=ht[f].rchild;           /", " 判断输入为1，寻找右子 ", "/", "\n        if(f<n)", "\n        { ", "\n            printf(\"%c\",ht[f].data);  /", " 输出字符串 */", "\n            f=2*n-2;", "\n        }", "\n    }", "\n    printf(\"\\n\");", "\n    getch();", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/786620974866127.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树如何画出，以及对应的哈夫曼i编码如何求得", ["哈夫曼树如何画出，以及对应的哈夫曼i编码如何求得，求解答，感谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;做过一个比较类似的&amp;#xff0c;需要可以给你&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/606184238656138.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["怎样把句号，逗号作为前缀进行编码", ["利用哈夫曼编码进行压缩英文短文，还需要包括句号，逗号，利用单词重复进行编码，"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;32行for循环后面的分号删掉&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["为什么无论输入什么数，打出来的哈夫曼数都是一样的，而且编码打不出来", ["(为什么无论输入什么数，打出来的哈夫曼数都是一样的，而且编码打不出来)", "\n", "#", "include", " ", "<stdio.h>", " ", "\n", "#", "include", " ", "<stdlib.h>", " ", "\n", "#", "include", " ", "<string.h>", " ", "\n", "#", "define", " N 8", "\n", "//#define M 2*N-1", "\n", "//哈夫曼树类型定义 ", "\n", "typedef", " ", "struct", "    \n{ \n    ", "unsigned", " ", "int", " weight; \n    ", "unsigned", " ", "int", " parent, lchild, rchild; \n}HTNode,*HuffmanTree;\n", "typedef", " ", "char", " **HuffmanCode;\nHuffmanTree HT;\nHuffmanCode HC;\n", "char", " *cd;\n", "//字符、权值、对应编码组成的结构体类型 ", "\n", "struct", " ", "s", "\n{  \n    ", "char", " data;  \n    ", "int", " weight;  \n    ", "char", " code[N]; \n}; \ns S[N];\n", "//此处函数定义请自行编写 ", "\n", "void", " ", "Init", "(s S[N],", "int", " *w)", "\n", "{\n    ", "int", " i;\n    ", "printf", "(", "\"输入%d个字符，及他们的权值:\\n\"", ",N);\n    ", "for", "(i=", "1", ";i<=N;i++)\n    {\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%c\"", ",&S[i", "-1", "].data);\n        ", "getchar", "();\n        ", "printf", "(", "\"请输入该字符的权值：\"", ");\n        ", "scanf", "(", "\"%d\"", ",&w[i", "-1", "]);\n        ", "getchar", "();\n    }\n}\n", "void", " ", "Select", "(HuffmanTree HT,", "int", " n,", "int", " &s1,", "int", " &s2)", "\n", "{\n    ", "int", " minn=", "99999998", ",maxx=", "99999999", ",i=", "1", "; \n    \n    s1=s2=", "0", "; \n    \n    ", "for", "( i=", "1", "; i<=n;i++) \n        \n    { \n        \n        ", "if", "(HT[i].parent==", "0", ") \n            \n        { \n            \n            ", "if", "(HT[i].weight<minn) \n                \n            { \n                \n                minn=HT[i].weight;s1=i; \n            } \n            \n        } \n        \n    } \n    \n    ", "int", " t=HT[s1].weight; \n    \n    HT[s1].weight=maxx; \n    \n    minn=", "99999998", "; \n    \n    ", "for", "( i=", "1", "; i<=n; i++) \n        \n    { \n        \n        ", "if", "(HT[i].parent==", "0", ") \n            \n        { \n            \n            ", "if", "(HT[i].weight<minn) \n                \n            { \n                \n                minn=HT[i].weight; \n                \n                s2=i; \n                \n            } \n            \n        } \n        \n    } \n    \n    HT[s1].weight=t;\n}\n\n", "void", " ", "Huffmancoding", "(HuffmanTree &HT,HuffmanCode &HC,", "int", " n,", "int", " *w)", "\n", "{\n    ", "int", " i,c,f,s1=", "0", ",s2=", "0", ",start,m=", "2", "*n", "-1", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ") * ", "sizeof", "(HTNode)); \n    ", "if", "(n<=", "1", ")", "return", "; \n", "/*    for(i=1;i<=n;i++)\n\n    {undefined\n\n       HT[i].weight=w[i];\n\n       HT[i].parent=HT[i].rchild=HT[i].lchild=0;\n\n    }\n    for(;i<=m;i++)\n\n    {undefined\n\n       HT[i].weight=HT[i].parent=HT[i].rchild=HT[i].lchild=0;\n\n    }*/", "\n    ", "for", "  (p=HT+", "1", ", i=", "1", "; i<=n; ++i, ++p){        \n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=w[i", "-1", "];\n    }  ", "/**p={ * w, 0, 0, 0};*/", "   ", "//用给定的n个", "\n    ", "//权值 ，构造n棵只有一个根结点的二叉树", "\n    \n    ", "for", " (;i<=m;i++,++p){\n        p->weight=", "0", ";\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n    }\n    \n    ", "for", "(i=n+", "1", ";i<=m;i++);\n    { \n        \n        ", "Select", "(HT,i", "-1", ",s1,s2);\n    \n        HT[s1].parent=i;\n    \n        HT[s2].parent=i;\n        \n        HT[i].lchild=s1;\n        \n        HT[i].rchild=s2;\n    \n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", " *));", "//分配n个字符编码的头指针向量", "\n    cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));", "//分配求编码的工作空间，用cd指向该空间", "\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", " (i=", "1", ";i<=n;i++)\n    {\n        start=n", "-1", ";\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent)\n        {\n            ", "if", " (HT[f].lchild==c) \n                cd[--start]=", "'0'", ";\n            ", "else", " \n                cd[--start]=", "'1'", ";\n        }\n        HC[i]=(", "char", " *)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n        ", "strcpy", "(HC[i],&cd[start]);\n        ", "// strcpy(S[i].code,&HC[i]);", "\n    }\n    ", "/*    for( i=1;i<=N;i++)\n    {\n    S[i].weight=\n    S[i].data=\n    //        strcpy(S[i].code,HC[i]);\n    }\n    */", "\n    ", "free", "(cd);\n}\n\n", "int", " ", "main", "()", " \n", "{  ", "//哈夫曼树的建立和编码的生成  ", "\n    ", "//打印输出哈夫曼树数据 ", "\n    ", "//用户输入任意一个由N个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串 ", "\n    ", "//用户输入哈夫曼编码(由01组成)，将进行解码，输出对应的字符串 ", "\n    ", "int", " a[", "100", "];\n    ", "int", " k,*w,n,m=", "2", "*N", "-1", ";\n    w=a;\n    ", "//    HTNode HT[M-1];", "\n    ", "//    HTCode HC[N+1];", "\n    ", "Init", "(S,w);\n    ", "Huffmancoding", "(HT,HC,", "8", ",w);\n    ", "printf", "(", "\"\\n哈夫曼树如下所示:\\n\"", ");\n    ", "for", " (", "int", " v=", "1", ";v<=m;v++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[v].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[v].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[v].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[v].rchild);\n    }\n    ", "printf", "(", "\"\\n%d个字符的字符、权值以及哈夫曼编码如下：\\n\"", ",N);\n    ", "for", "(k=", "1", ";k<=n;k++);\n    {\n        ", "printf", "(", "\"%-3c%-3d%s\\n\"", ",S[k].data,S[k].weight,HC[k]);\n        ", "//puts(S[k].code);", "\n        ", "//printf(\"%c\\t\",HC[k]);", "\n    }\n    ", "return", " ", "0", "; \n} \n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/612858274936127.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;那么加权路径长度WPL&amp;#61;(9&amp;#43;7&amp;#43;8)×2&amp;#43;4×3&amp;#43;(2&amp;#43;3)×4&amp;#61;80&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;结点到树根之间的路径长度与该结点上权的乘积&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/477338274936134.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;构造哈夫曼树的办法是&amp;#xff1a;在W中选出两个权小结点&amp;#xff0c;并同时计算出它们的和&amp;#xff0c;如果两个数的和正好是下一步的两个最小数的其中的一个&amp;#xff0c;那么这个树直接往上生长就可以了&amp;#xff0c;如果这两个数的和比较大&amp;#xff0c;不是下一步的两个最小数的其中一个&amp;#xff0c;那么就并列生长。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树，求解析，数据结构", ["35.(填空题， 2.5 分)", "有一份电文中共使用 6个字符:a,b,c,d,e,f,它们的出现频率依次为2,3,4,7,8,9,试构造一棵哈夫曼树,则其加权路径长度WPL为多少，求解析"]], "Tag": "算法设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201905/02/1556800260_830294.jpg)\r\n![图片说明](https://img-ask.csdn.net/upload/201905/02/1556800272_950431.jpg)", "Konwledge_Point": "哈夫曼编码", "Question": ["二叉树，哈夫曼问题，求大神指点，多谢。", ["1、已知一棵二叉树的前序遍历为：ABCDEFHIKLGJ，中序遍历序列为：CBAFEIHLKDGJ，画出次二叉树的逻辑结构图。", "\n2、已知一段电文仅含8个字符{C1,C2,……,C8}，且每个字符在电文中出现的频率构成权集{13,2,11,20,9,23,17,5}，求各个字符的哈夫曼编码"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;运行结果及代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/237687711556115.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXLEN 30&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXLEAF 130&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXWEIGHT 1&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//结点&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;HuffmanNode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; node;      &lt;span class=\"hljs-comment\"&gt;//结点字符&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; weight;  &lt;span class=\"hljs-comment\"&gt;//结点权值&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; parent;     &lt;span class=\"hljs-comment\"&gt;//父结点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild;     &lt;span class=\"hljs-comment\"&gt;//左子节点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rchild;     &lt;span class=\"hljs-comment\"&gt;//右子节点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; no;         &lt;span class=\"hljs-comment\"&gt;//节点编号&lt;/span&gt;\n};\n&lt;span class=\"hljs-comment\"&gt;//每个结点的编码&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;HuffmanCode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; bit[MAXLEN];  &lt;span class=\"hljs-comment\"&gt;//存储哈夫曼编码&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length;        &lt;span class=\"hljs-comment\"&gt;//每个结点编码的长度&lt;/span&gt;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanNode a, HuffmanNode b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.weight &amp;lt; b.weight;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HuffmanNode a, HuffmanNode b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.no &amp;lt; b.no;\n}\n\nHuffmanNode HNode[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * MAXLEAF - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\nHuffmanCode HCode[MAXLEAF];\n\n\n\n\n&lt;span class=\"hljs-comment\"&gt;//构造哈夫曼树&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHafman&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; buf[], &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; w[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//初始化结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        HNode[i].weight &amp;#61; MAXWEIGHT;\n        HNode[i].parent &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        HNode[i].lchild &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        HNode[i].rchild &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        HNode[i].no &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        HNode[i].node &amp;#61; buf[i];\n        HNode[i].weight &amp;#61; w[i];\n        HNode[i].no &amp;#61; i;\n    }\n\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, min2 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;sort&lt;/span&gt;(HNode, HNode &amp;#43; n &amp;#43; i, cmp1);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n &amp;#43; i; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[min1].parent !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n            {\n                min1&amp;#43;&amp;#43;;\n                min2 &amp;#61; min1 &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[min2].parent !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n                min2&amp;#43;&amp;#43;;\n        }\n        HNode[n &amp;#43; i].lchild &amp;#61; HNode[min1].no;\n        HNode[n &amp;#43; i].rchild &amp;#61; HNode[min2].no;\n        HNode[n &amp;#43; i].weight &amp;#61; HNode[min1].weight &amp;#43; HNode[min2].weight;\n        HNode[n &amp;#43; i].no &amp;#61; n &amp;#43; i;\n        HNode[min1].parent &amp;#61; HNode[n &amp;#43; i].no;\n        HNode[min2].parent &amp;#61; HNode[n &amp;#43; i].no;\n\n    }\n    &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;哈夫曼树构建成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//获取每个字符的哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Getcode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; offset &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, p, j;\n    HuffmanCode hc;\n\n    &lt;span class=\"hljs-built_in\"&gt;sort&lt;/span&gt;(HNode, HNode &amp;#43; offset, cmp2);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        hc.length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        j &amp;#61; i;\n        p &amp;#61; HNode[j].parent;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[p].lchild &amp;#61;&amp;#61; HNode[j].no)\n                hc.bit[hc.length] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                hc.bit[hc.length] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            hc.length&amp;#43;&amp;#43;;\n            j &amp;#61; HNode[p].no;\n            p &amp;#61; HNode[j].parent;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; hc.length; k&amp;#43;&amp;#43;)\n            HCode[i].bit[k] &amp;#61; hc.bit[hc.length - k - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        HCode[i].length &amp;#61; hc.length;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//显示哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;showHafman&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//输出哈夫曼编码&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[i].node &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\n&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[i].node &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\r&amp;#39;&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\r&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HNode[i].node &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\t&amp;#39;&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            cout &amp;lt;&amp;lt; HNode[i].node &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: Huffman code is: &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; HCode[i].length; j&amp;#43;&amp;#43;)\n            cout &amp;lt;&amp;lt; HCode[i].bit[j];\n        cout &amp;lt;&amp;lt; endl;\n    }\n}\n\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; buf[MAXLEAF]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; w[MAXLEAF]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0.07&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.19&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.02&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.06&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.32&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.03&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.21&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.13&lt;/span&gt;};\n\n    \n    &lt;span class=\"hljs-built_in\"&gt;CreateHafman&lt;/span&gt;(buf, w, n); &lt;span class=\"hljs-comment\"&gt;//创建哈夫曼树&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Getcode&lt;/span&gt;(n);&lt;span class=\"hljs-comment\"&gt;//获取每个字符的编码&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;showHafman&lt;/span&gt;(n);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["利用哈弗曼树编码原理，对字符进行编码（C++,C语言都可）", ["题目：输入任意字符串，str]=(\"a”，“b”，“c”，\"d”，\"e”，\"f”，”g”，“h”；每种字符出现频率fnum，=0.07,0.19,0.02,0.06,0.32,0.03,0.21,0.13，根据出现频率，利用哈夫曼编码原理，对每个字符进行(0.1)编码，并输出每种字符编码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/46826237925613.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Maxleaf 30&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Maxnode 1000&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Max 100000&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; Maxsize 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;      &lt;span class=\"hljs-comment\"&gt;//定义结构体&lt;/span&gt;\n{\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;          &lt;span class=\"hljs-comment\"&gt;//定义字符型的结点名&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; weight;     &lt;span class=\"hljs-comment\"&gt;//定义一个整型权值变量&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild,rchild,parent;   &lt;span class=\"hljs-comment\"&gt;//定义左、右孩子及双亲指针&lt;/span&gt;\n}hufmtree;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; bits[Maxsize];        &lt;span class=\"hljs-comment\"&gt;//定义一个字符型的数组存储结点的编码&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start;                 &lt;span class=\"hljs-comment\"&gt;//标志字符串起点&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;                   &lt;span class=\"hljs-comment\"&gt;//存储结点的名称&lt;/span&gt;\n}codetype;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;huffman&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(hufmtree tree[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;//哈夫曼树的创建&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,p1,p2;\n  &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; small1,small2,f;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;           &lt;span class=\"hljs-comment\"&gt;//总的结点数目&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;m;i&amp;#43;&amp;#43;)        &lt;span class=\"hljs-comment\"&gt;//结点信息的初始化&lt;/span&gt;\n  {\n    tree[i].parent&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    tree[i].lchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    tree[i].rchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    tree[i].weight&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n  }\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)              &lt;span class=\"hljs-comment\"&gt;//输入叶子结点的结点名和权值&lt;/span&gt;\n  {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;第%d个元素的结点:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);  \n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,&amp;amp;c);\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入该节点的权值&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;f);\n    &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n    tree[i].ch&amp;#61;c;\n    tree[i].weight&amp;#61;f;\n  }\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;n;i&amp;lt;m;i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//找出剩余结点中的权值最小的两个结点组合&lt;/span&gt;\n  {\n    p1&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;p2&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    small1&amp;#61;Max;small2&amp;#61;Max;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;i;j&amp;#43;&amp;#43;)             \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[j].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)         &lt;span class=\"hljs-comment\"&gt;//如果该结点不存在双亲&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[j].weight&amp;lt;small1)        &lt;span class=\"hljs-comment\"&gt;//结点的权值小于small1时&lt;/span&gt;\n    {\n      small2&amp;#61;small1;                \n      small1&amp;#61;tree[j].weight;          \n      p2&amp;#61;p1;                       \n      p1&amp;#61;j;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[j].weight&amp;lt;small2)         &lt;span class=\"hljs-comment\"&gt;//结点的权值大于small1但是小于small2&lt;/span&gt;\n    {\n      small2&amp;#61;tree[j].weight;\n      p2&amp;#61;j;\n    }\n    tree[p1].parent&amp;#61;i;           \n    tree[p2].parent&amp;#61;i;\n    tree[i].lchild&amp;#61;p1;\n    tree[i].rchild&amp;#61;p2;\n    tree[i].weight&amp;#61;tree[p1].weight&amp;#43;tree[p2].weight;\n  }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;huffmancode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(codetype code[],hufmtree tree[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;//哈夫曼的编码函数&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,c,p;\n  codetype cd;            &lt;span class=\"hljs-comment\"&gt;//定义一个临时变量&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//从下往上遍历哈夫曼树&amp;#xff0c;进行编码&lt;/span&gt;\n  {\n    cd.start&amp;#61;n;            &lt;span class=\"hljs-comment\"&gt;//编码的结束位置&lt;/span&gt;\n    cd.ch&amp;#61;tree[i].ch;        &lt;span class=\"hljs-comment\"&gt;//将哈夫曼结构体中的结点名赋给存储编码的结构体中的结构名&lt;/span&gt;\n    c&amp;#61;i;                       \n    p&amp;#61;tree[i].parent;         \n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)             &lt;span class=\"hljs-comment\"&gt;//当p是根结点的双亲时跳出循环&lt;/span&gt;\n    { \n      cd.start--;           \n      &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[p].lchild&amp;#61;&amp;#61;c)     &lt;span class=\"hljs-comment\"&gt;//如果是它的左孩子&lt;/span&gt;\n         cd.bits[cd.start]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//则输出0&lt;/span&gt;\n      &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n         cd.bits[cd.start]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//否则就是右孩子输出1&lt;/span&gt;\n      c&amp;#61;p;\n      p&amp;#61;tree[p].parent;\n    }\n    code[i]&amp;#61;cd;                     &lt;span class=\"hljs-comment\"&gt;//将临时变量中的值存入结构体数组&lt;/span&gt;\n  }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;decode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(hufmtree tree[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m)&lt;/span&gt;     &lt;span class=\"hljs-comment\"&gt;//译码函数&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; b[Maxsize];             \n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; endflag&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;;\n  i&amp;#61;m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n  &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n  &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(b);                                                  &lt;span class=\"hljs-comment\"&gt;//读入编码&lt;/span&gt;\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输出哈夫曼译码&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n  &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(b[j]!&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;)     \n  {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(b[j]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)                                         &lt;span class=\"hljs-comment\"&gt;//如果编码是0&lt;/span&gt;\n      i&amp;#61;tree[i].lchild;                                 &lt;span class=\"hljs-comment\"&gt;//将该结点左孩子的序号赋给i&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(b[j]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)\n    \n        i&amp;#61;tree[i].rchild;   &lt;span class=\"hljs-comment\"&gt;//如果编码是1&amp;#xff0c;将该结点右孩子的序号赋给i&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;ERROR\\n&amp;#34;&lt;/span&gt;);\n    }\n      &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[i].lchild&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)         &lt;span class=\"hljs-comment\"&gt;//如果该结点左孩子的序号等于-1&amp;#xff0c;即根结点&lt;/span&gt;\n      {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,tree[i].ch);    &lt;span class=\"hljs-comment\"&gt;//输出该结点名&lt;/span&gt;\n        i&amp;#61;m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;                        &lt;span class=\"hljs-comment\"&gt;//回到根结点&lt;/span&gt;\n      }\n   j&amp;#43;&amp;#43;;\n  }\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tree[i].parent!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)    \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nERROR\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*    ********哈夫曼编码/译码器********         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             1.创建哈夫曼树;                  *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             2.进行哈夫曼编码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             3.进行哈夫曼译码;                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*             4.退出;                          *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆\\n&amp;#34;&lt;/span&gt;);\n    }\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,n,m;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; choose;\n  hufmtree tree[Maxnode];       \n  codetype code[Maxleaf];   \n  &lt;span class=\"hljs-built_in\"&gt;Menu&lt;/span&gt;();    \n  &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n  {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n请输入要进行的功能&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n     &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;choose);\n     &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(choose)\n     {\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入元素个数&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n          &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n          &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n          &lt;span class=\"hljs-built_in\"&gt;huffman&lt;/span&gt;(tree,n);                                &lt;span class=\"hljs-comment\"&gt;//调用哈夫曼创建函数&lt;/span&gt;\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;成功建立哈夫曼树&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n      &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输出哈夫曼编码&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n          &lt;span class=\"hljs-built_in\"&gt;huffmancode&lt;/span&gt;(code,tree,n);           &lt;span class=\"hljs-comment\"&gt;//调用哈夫曼编码函数&lt;/span&gt;\n          &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)                           &lt;span class=\"hljs-comment\"&gt;//输出结点对应的哈夫曼编码&lt;/span&gt;\n          {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c:&amp;#34;&lt;/span&gt;,code[i].ch);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;code[i].start;j&amp;lt;n;j&amp;#43;&amp;#43;)\n              &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,code[i].bits[j]);\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n          }\n      &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n          m&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n          &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入编码&amp;#xff0c;以#为结束标志&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n          &lt;span class=\"hljs-built_in\"&gt;decode&lt;/span&gt;(tree,m);                             &lt;span class=\"hljs-comment\"&gt;//调用译码函数&lt;/span&gt;\n      &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n          &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n     }\n  }\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["下面这个到底哪里不对，运行了是c++那c语言咋整呢", ["给定权值(A:5，B:29，C:7,D: 8, E:14，F:23，G:3， H：11 建立哈夫曼树，输出哈夫曼编码；对上述给定的哈夫曼树及得到的哈夫曼编码，试输入一串二进制编码，输出它的哈夫曼译码。", "要求：将哈夫曼树的结构定义为一个一维数组，每个元素含有四顶：权值、双亲、左、右。权值由键盘输入；二进制编码时，往左走编码为0，往右走编码为1：译码就是将输入的编码还原成对应的字符。", "\n", "以上好多人用的用的是c++有人给改成c语言嘛，不会呀"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;因为有某次调用selectMin()函数时没有进54行那个分支&amp;#xff0c;导致secminIndex没有初始化就赋值给了res[1]&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["C语言哈夫曼树编码及其解码", ["问题：", "读取文件并对其中的数据进行哈夫曼树编码和解码", "出现的问题：", "用数据创建哈夫曼树并对哈夫曼树进行先序遍历的时候，出现程序崩溃，崩溃的原因我觉得莫名其妙", "如图：", "\n", "\n", "需求：", "1.解决上述问题，将字符数据翻译为哈夫曼树编码", "2.完成对解码部分的代码", "代码：", "\n", "#define _CRT_SECURE_NO_WARNINGS\n#include ", "\"stdio.h\"", "\n#include ", "\"stdlib.h\"", "\ntypedef struct TreeNode  ", "//定义树结点", "\n{\n    int weight;  ", "//权值", "\n    int parent;\n    int lchild;\n    int rchild;\n    char ch;\n}treenode;\n\ntypedef struct HuffmanTree  ", "//定义huffmantree，用数组表示树", "\n{\n    treenode* ", "data", ";\n    int length;\n}huffmantree;\n\nhuffmantree* huffmantree_create(int weight[], int length, char character[])", "//huffmantree初始化", "\n{\n    huffmantree* ", "tree", " = (huffmantree*)malloc(sizeof(huffmantree));\n    ", "tree", "->", "data", " = (treenode*)malloc(sizeof(treenode) * (", "2", " * length - ", "1", "));  ", "//n个元素，树中有2n-1个结点", "\n    ", "tree", "->", "length = length;\n    ", "for", " (int i = ", "0", "; i < length; i++)\n    {\n        ", "tree", "->", "data", "[i].weight = weight[i];\n        ", "tree", "->", "data", "[i].parent = ", "0", ";\n        ", "tree", "->", "data", "[i].lchild = -", "1", ";\n        ", "tree", "->", "data", "[i].rchild = -", "1", ";\n        ", "tree", "->", "data", "[i].ch = character[i];\n    }\n    return ", "tree", ";\n}\n\nint* selectMin(huffmantree* ", "tree", ")", "//选择最小的两个结点", "\n{\n    int min=", "10000", ", secmin=", "10000", ";\n    int minIndex, secminIndex;\n    ", "for", " (int i = 0; i < ", "tree", "->", "length; i++)  ", "//找到最小的结点的索引下标", "\n    {\n        ", "if", " (", "tree", "->", "data", "[i].parent == ", "0", ")\n        {\n            ", "if", " (", "tree", "->", "data", "[i].weight < min)\n            {\n                ", "min", " = ", "tree", "->", "data", "[i].weight;\n                minIndex = i;\n            }\n        }\n    }\n    ", "for", " (int i = 0; i < ", "tree", "->", "length; i++)  ", "//找到第二小的结点的索引下标", "\n    {\n        ", "if", " (", "tree", "->", "data", "[i].parent == ", "0", " && i != minIndex)\n        {\n            ", "if", " (", "tree", "->", "data", "[i].weight < secmin)\n            {\n                ", "secmin", " = ", "tree", "->", "data", "[i].weight;\n                secminIndex = i;\n            }\n        }\n    }\n    int* res = (int*)malloc(sizeof(int) * ", "2", ");  ", "//返回两个数据，用int数组返回", "\n    res[", "0", "] = minIndex;\n    res[", "1", "] = secminIndex;\n    return res;\n}\n\nvoid createTree(huffmantree* ", "tree", ")  ", "//建树", "\n{\n    int min;\n    int secmin;\n    int* res;\n    ", "for", " (int i = ", "tree", "->", "length", "; i < ", "tree", "->", "length * ", "2", " - ", "1", "; i++)\n    {\n        res = selectMin(", "tree", ");\n        printf(", "\"%d %d\\t\"", ", res[", "0", "], res[", "1", "]);\n        min = res[", "0", "];\n        secmin = res[", "1", "];\n        ", "tree", "->", "data", "[i].weight = ", "tree", "->", "data", "[min].weight + ", "tree", "->", "data", "[secmin].weight;\n        ", "tree", "->", "data", "[min].parent = i;  ", "//设置双亲结点", "\n        ", "tree", "->", "data", "[secmin].parent = i;\n        ", "tree", "->", "data", "[i].parent = ", "0", ";\n        ", "tree", "->", "data", "[i].lchild = min;  ", "//设置孩子结点", "\n        ", "tree", "->", "data", "[i].rchild = secmin;\n        ", "tree", "->", "length++;\n    }\n}\n\nvoid preorder(huffmantree* ", "tree", ",int index)\n{\n    ", "while", " (index != -", "1", ")\n    {\n        ", "printf", "(\"%c %d\\n\", ", "tree", "->", "data", "[index].ch, ", "tree", "->", "data", "[index].weight);\n        ", "preorder", "(", "tree", ", ", "tree", "->", "data", "[index].lchild);\n        ", "preorder", "(", "tree", ", ", "tree", "->", "data", "[index].rchild);\n    }\n}\n\nint main()\n{\n    FILE* fp;\n    char ch, str[", "100", "],character[", "100", "];\n    int length = ", "0", ", option, lengthchar = ", "0", ", weight[", "100", "];\n    fp = fopen(", "\"test3.txt\"", ", ", "\"r+\"", ");\n    ", "if", " (fp == NULL)\n    {\n        printf(", "\"打开文件失败\\n\"", ");\n        exit(", "0", ");\n    }\n    printf(", "\"打开文件成功\\n\"", ");\n    ch = fgetc(fp);\n    ", "while", " (ch != EOF)\n    {\n        str[length] = ch;\n        length++;\n        ch = fgetc(fp);\n    }\n    str[length] = ", "'\\0'", ";\n    printf(", "\"该文件的数据为:\"", ");\n    puts(str);\n    printf(", "\"请问你是要对文件进行加密还是进行解密？(输入1为加密，输入2为解密)\"", ");\n    printf(", "\"我选择：\"", ");\n    scanf(", "\"%d\"", ", &option);\n    ", "while", " (option != ", "1", " && option != ", "2", ")\n    {\n        printf(", "\"你的输入有误，请重新输入！\\n我选择：\"", ");\n        scanf(", "\"%d\"", ", &option);\n    }\n    ", "if", " (option == ", "1", ")  ", "//对数据进行huffmantree编码", "\n    {\n        int status;\n        huffmantree* hftree;\n        ", "for", " (int i = ", "0", "; i < length; i++)  ", "//先把str中的每一个字符都单列出来放进数组character", "\n        {\n            status = ", "0", ";\n            ", "for", " (int t = ", "0", "; t < lengthchar; t++)\n            {\n                ", "if", " (str[i] == character[t])\n                {\n                    status = ", "1", ";\n                    break;\n                }\n            }\n            ", "if", " (status == ", "1", ")\n                continue;\n            character[lengthchar] = str[i];\n            lengthchar++;\n        }\n        character[lengthchar] = ", "'\\0'", ";\n        printf(", "\"字符数组为:\"", ");\n        puts(character);\n        ", "for", " (int i = ", "0", "; i < lengthchar; i++)  ", "//将权值数组归0", "\n        {\n            weight[i] = ", "0", ";\n        }\n        ", "for", " (int i = ", "0", "; i < lengthchar; i++)  ", "//设置权值数组", "\n        {\n            ", "for", " (int t = ", "0", "; t < length; t++)\n            {\n                ", "if", " (str[t] == character[i])  ", "//统计每个字符的出现次数", "\n                    weight[i]++;\n            }\n        }\n        printf(", "\"权值数组为:\"", ");\n        ", "for", " (int i = ", "0", "; i < lengthchar; i++)\n            printf(", "\"%d \"", ", weight[i]);\n        printf(", "\"\\n\"", ");\n        hftree = huffmantree_create(weight, lengthchar, character);\n        createTree(hftree);\n        ", "preorder", "(hftree,hftree->", "length-", "1", ");\n    }\n    ", "if", " (option == ", "2", ")", "//对huffmantree编码进行解码", "\n    {\n        \n    }\n    fclose(fp);\n    return ", "0", ";\n}\n谢谢！\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;定义hufmtree&amp;#xff08;哈夫曼&amp;#xff09;的结构体&amp;#xff0c;创建一个新的数据类型&amp;#xff0c;名称为hufmtree。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["C语言 哈夫曼编译码器", ["typedef struct", "\n{", "\n char ch;", "\n float weight;", "\n int lchild,rchild,parent;", "\n}hufmtree;", "\n\n", "这段代码是什么作用的？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;哈夫曼树是一种用于编码和压缩数据的数据结构。它是根据给定的权值创建出的二叉树&amp;#xff0c;其中每个节点的权值表示该节点对应的字符或数据块的出现频率。哈夫曼树的编码是指将每个数据块编码成一个二进制序列&amp;#xff0c;该序列由该数据块在哈夫曼树中路径上的左右分支构成。&lt;/p&gt;\n&lt;p&gt;对于哈夫曼树而言&amp;#xff0c;左分支为0或者为1都是可以的。在构建哈夫曼树时&amp;#xff0c;只需要保证编码过程中每个节点的左右分支不重复即可&amp;#xff0c;因此左分支为0或者为1都是正确的。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构中哈夫值曼树的编码", ["问题遇到的现象和发生背景", "\n", "为哈夫曼树设计哈夫曼编码，左分支为0或者为1，都是可以的吗", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/263650482556171.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MaxSize 100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ElemType;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 50        &lt;span class=\"hljs-comment\"&gt;//叶子结点数&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; M 2*N-1     &lt;span class=\"hljs-comment\"&gt;//树中结点总数&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//哈夫曼树的节点结构类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; data;  &lt;span class=\"hljs-comment\"&gt;//结点值&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; weight;  &lt;span class=\"hljs-comment\"&gt;//权重&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; parent;     &lt;span class=\"hljs-comment\"&gt;//双亲结点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lchild;     &lt;span class=\"hljs-comment\"&gt;//左孩子结点&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rchild;     &lt;span class=\"hljs-comment\"&gt;//右孩子结点&lt;/span&gt;\n} HTNode;\n\n&lt;span class=\"hljs-comment\"&gt;//每个节点哈夫曼编码的结构类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; cd[N]; &lt;span class=\"hljs-comment\"&gt;//存放哈夫曼码&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start;\n} HCode;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHT&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HTNode ht[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,k,lnode,rnode;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; min1,min2;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//所有结点的相关域置初值-1&lt;/span&gt;\n        ht[i].parent&amp;#61;ht[i].lchild&amp;#61;ht[i].rchild&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;n; i&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)         &lt;span class=\"hljs-comment\"&gt;//构造哈夫曼树&lt;/span&gt;\n    {\n        min1&amp;#61;min2&amp;#61;&lt;span class=\"hljs-number\"&gt;32767&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;//lnode和rnode为最小权重的两个结点位置&lt;/span&gt;\n        lnode&amp;#61;rnode&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k&amp;lt;&amp;#61;i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; k&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[k].parent&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)   &lt;span class=\"hljs-comment\"&gt;//只在尚未构造二叉树的结点中查找&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[k].weight&amp;lt;min1)\n                {\n                    min2&amp;#61;min1;\n                    rnode&amp;#61;lnode;\n                    min1&amp;#61;ht[k].weight;\n                    lnode&amp;#61;k;\n                }\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[k].weight&amp;lt;min2)\n                {\n                    min2&amp;#61;ht[k].weight;\n                    rnode&amp;#61;k;\n                }\n            }\n        ht[i].weight&amp;#61;ht[lnode].weight&amp;#43;ht[rnode].weight;\n        ht[i].lchild&amp;#61;lnode;\n        ht[i].rchild&amp;#61;rnode;\n        ht[lnode].parent&amp;#61;i;\n        ht[rnode].parent&amp;#61;i;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//实现哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateHCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HTNode ht[],HCode hcd[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,f,c;\n    HCode hc;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//根据哈夫曼树求哈夫曼编码&lt;/span&gt;\n    {\n        hc.start&amp;#61;n;\n        c&amp;#61;i;\n        f&amp;#61;ht[i].parent;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (f!&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)   &lt;span class=\"hljs-comment\"&gt;//循序直到树根结点&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ht[f].lchild&amp;#61;&amp;#61;c)    &lt;span class=\"hljs-comment\"&gt;//处理左孩子结点&lt;/span&gt;\n                hc.cd[hc.start--]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;                    &lt;span class=\"hljs-comment\"&gt;//处理右孩子结点&lt;/span&gt;\n                hc.cd[hc.start--]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;\n            c&amp;#61;f;\n            f&amp;#61;ht[f].parent;\n        }\n        hc.start&amp;#43;&amp;#43;;     &lt;span class=\"hljs-comment\"&gt;//start指向哈夫曼编码最开始字符&lt;/span&gt;\n        hcd[i]&amp;#61;hc;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//输出哈夫曼编码&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DispHCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(HTNode ht[],HCode hcd[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,k;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; sum&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,m&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;  输出哈夫曼编码:\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//输出哈夫曼编码&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;      %c:\\t&amp;#34;&lt;/span&gt;,ht[i].data);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (k&amp;#61;hcd[i].start; k&amp;lt;&amp;#61;n; k&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,hcd[i].cd[k]);\n            j&amp;#43;&amp;#43;;\n        }\n        m&amp;#43;&amp;#61;ht[i].weight;\n        sum&amp;#43;&amp;#61;ht[i].weight*j;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n  平均长度&amp;#61;%g\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;*sum/m);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,i;      &lt;span class=\"hljs-comment\"&gt;//n表示初始字符串的个数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[]&amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;h&amp;#39;&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; fnum[]&amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0.07&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.19&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.02&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.06&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.32&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.03&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.21&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0.1&lt;/span&gt;};\n    HTNode ht[M];\n    HCode hcd[N];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        ht[i].data&amp;#61;str[i];\n        ht[i].weight&amp;#61;fnum[i];\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;CreateHT&lt;/span&gt;(ht,n);\n    &lt;span class=\"hljs-built_in\"&gt;CreateHCode&lt;/span&gt;(ht,hcd,n);\n    &lt;span class=\"hljs-built_in\"&gt;DispHCode&lt;/span&gt;(ht,hcd,n);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["输入任意字符串，str[]={\"a\",\"b\",\"c\",\"d\",\"e”,\"f\",\"g\",\"h\"}", ["输入任意字符串，str[]={\"a\",\"b\",\"c\",\"d\",\"e”,\"f\",\"g\",\"h\"},每种字符出现频率fnum[]={0.070.19,0.02,0.06,0.32,0.03,0.21,0.1},根据出现频率，利用哈夫曼编码原理，对每个字符进行（0.1）编码，并输出每种字符编码。", "注意：写清具体步骤（文字描述）和程序流程图！"]], "Tag": "算法设计"}
{"Answer": "还有std::bitset", "Konwledge_Point": "哈夫曼编码", "Question": ["用C++可以存储2bit的数据么?", ["今天用哈夫曼编码做24位bmp图像的压缩，像素里的RGB已经按频率编好了前缀编码。问题是编好了的前缀码有的较短，不需要一个字节来装，只要几个比特就好了。但是最小的数据类型unsigned char也有一个字节，用它来装编码达不到压缩的效果"]], "Tag": "算法设计"}
{"Answer": "http://www.cnblogs.com/yym2013/p/3554471.html", "Konwledge_Point": "哈夫曼编码", "Question": ["Safe Or Unsafe                ", ["Problem Description", "\nJavac++ 一天在看计算机的书籍的时候，看到了一个有趣的东西！每一串字符都可以被编码成一些数字来储存信息，但是不同的编码方式得到的储存空间是不一样的！并且当储存空间大于一定的值的时候是不安全的！所以Javac++ 就想是否有一种方式是可以得到字符编码最小的空间值！显然这是可以的，因为书上有这一块内容--哈夫曼编码(Huffman Coding)；一个字母的权值等于该字母在字符串中出现的频率。所以Javac++ 想让你帮忙，给你安全数值和一串字符串，并让你判断这个字符串是否是安全的？", "\n\n", "Input", "\n输入有多组case，首先是一个数字n表示有n组数据，然后每一组数据是有一个数值m(integer)，和一串字符串没有空格只有包含小写字母组成！", "\n\n", "Output", "\n如果字符串的编码值小于等于给定的值则输出yes，否则输出no。", "\n\n", "Sample Input", "\n2", "\n12", "\nhelloworld", "\n66", "\nithinkyoucandoit", "\n\n", "Sample Output", "\nno", "\nyes"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;在哈夫曼树中&amp;#xff0c;给定任意一个叶子节点&amp;#xff0c;它对应的编码是由根节点到该叶子节点的路径上的 0 和 1 组成的&amp;#xff0c;所以说&amp;#xff0c;在进行哈夫曼编码时&amp;#xff0c;路径为零的叶子节点的编码可以被定义为比路径为 1 的叶子节点的编码小&amp;#xff0c;也可以被定义为比路径为 1 的叶子节点的编码大&amp;#xff0c;具体的定义可以看情况&amp;#xff0c;只需要保证编码的唯一性和无歧义性就行了&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["请问哈夫曼树的零一编码是否需要路径为零的数比路径为1的叶子结点的值小或者大。", ["请问哈夫曼树的零一编码是否需要路径为零的数比路径为1的叶子结点的值小或者大？还是任意的呀，自己编码的话，"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;简单记法&amp;#xff0c;左0右1&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["请问大家这个huffman树编码的0和1是怎么判断的呀", []], "Tag": "算法设计"}
{"Answer": "typedef struct BinNode{};这样是声明一个类，你的声明是一个没有类名的一个结构体对象BinNode", "Konwledge_Point": "哈夫曼编码", "Question": ["请教一下，vs2017 为什么我的c++代码定义的没有问题，也没有错误提示，但是一编译就爆出很奇怪的错误", ["\n\n", "\n\n", "\n\n", "\n\n", "以下是完整代码", "\n\n", "#include \"pch.h\"\n#include<iostream>\nusing namespace std;\n\ntypedef struct {\n    int weight;\n    BTreeNode *left;\n    BTreeNode *right;\n}BTreeNode;\n\nBTreeNode* CreateHuffman(int a[], int n)\n{\n    // 根据数组a中n个权值建立一颗哈夫曼树，则返回树根指针\n    BTreeNode **b, *q;\n    // 动态地分配一个由b指向的指针数组\n    b = new BTreeNode*[n];\n    int i, j;\n\n    // 初始化b指针数组，使每个指针元素指向a数组中对应元素的结点\n    for (i = 0; i < n; i++) {\n        b[i] = new BTreeNode;\n        b[i]->weight = a[i]; b[i]->left = b[i]->right = NULL;\n    }\n\n    // 进行n-1此循环建立哈夫曼树\n    for (i = 1; i < n; i++) {\n        // 用k1表示森林中具有最小权值的树根节点下标\n        // 用k2表示森林中具有次小权值的树根节点下标\n        int k1=-1, k2;\n        for (j = 0; j < n; j++) {\n            if (b[j] != NULL && k1 == -1) {\n                k1 = j; continue;\n            }\n            if (b[j] != NULL) {\n                k2 = j; break;\n            }\n        }\n\n        // 从当前森林中求出最小权值树和次小权值树\n        for (j = k2; j < n; j++) {\n            if (b[j] != NULL) {\n                if (b[j]->weight < b[k1]->weight) {\n                    k2 = k1; k1 = j;\n                }\n                else if (b[j]->weight < b[k2]->weight)\n                    k2 = j;\n            }\n        }\n\n        // 由最小权值树和次小权值树建立一棵新树，q指向树跟结点\n        q = new BTreeNode;\n        q->weight = b[k1]->weight + b[k2]->weight;\n        q->left = b[k1]; q->right = b[k2];\n        // 将指向新树的指针赋给b指针数组k1位置，k2位置置为空\n        b[k1] = q; b[k2] = NULL;\n    }\n\n    // 删除动态建立的数组b\n    delete []b;\n    // 返回整个哈夫曼树的树根指针\n    return q;\n}\n\nvoid HuffManCoding(BTreeNode *FBT, int len)\n{\n    // 根据FBT指针所指向的哈夫曼树输出每个叶子的编码，len初值为0\n    static int code[10];    // 数组的长度要至少等于哈夫曼树的深度减1\n    if (FBT != NULL) {\n        // 访问到叶子结点时输出其保存在数组code中的0和1序列编码\n        if (FBT->left == NULL && FBT->right == NULL) {\n            cout << \"结点权值为\" << FBT->weight << \"的编码：\";\n            for (int i = 0; i < len; i++)\n                cout << code[i] << \" \";\n            cout << endl;\n        }\n\n        // 访问到非叶子节点时分别向左、右子树递归调用，并分别把分支上\n        // 的0、1编码保存到数组code，向下深入一层时len+1\n        else {\n            code[len] = 0; HuffManCoding(FBT->left, len + 1);\n            code[len] = 1; HuffManCoding(FBT->right, len + 1);\n        }\n    }\n}\n\nvoid CleanBTree(BTreeNode *BT)\n{\n    if (BT != NULL) {\n        CleanBTree(BT->left);\n        CleanBTree(BT->right);\n        delete BT;\n        BT = NULL;\n    }\n}\n\nint main()\n{\n    int n, i;\n    BTreeNode *fbt = NULL;\n    // 输入哈夫曼树中叶子结点数\n    cout << \"输入待构造的哈夫曼树中带权叶子结点的权值n：\";\n    cin >> n;\n    // 用数组a保存从键盘输入的n个叶子结点的权值\n    int *a = new int[n];\n    cout << \"输入\" << n << \"个整数作为权值：\";\n    for (i = 0; i < n; i++) cin >> a[i];\n    // 根据数组a建立哈夫曼树\n    fbt = CreateHuffman(a, n);\n    // 输出哈夫曼编码，即每个叶子节点所对应的0、1序列\n    cout << \"树种每个叶子的哈夫曼编码：\" << endl;\n    HuffManCoding(fbt, 0);\n    CleanBTree(fbt);\n}\n"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_29503203/article/details/53034955", "Konwledge_Point": "哈夫曼编码", "Question": ["关于HUFFMAN利用数组压缩的算法问题", ["整体代码如下，具体关于问题在最下方，", "\nstruct head", "\n{", "\n unsigned char b;             /*the charactor*/", "\n long count;                  /*the frequency*/", "\n long parent,lch,rch;         /*make a tree*/", "\n char bits[256];              /*the haffuman code*/", "\n}", "\nheader[512],tmp;", "\n\n", "void compress()", "\n{", "\n\n", "clock_t start,end; ", "\n char filename[255],outputfile[255],buf[512];", "\n int fn = 0, sz = 0, sz1 = 0;", "\n double x = 0;", "\n unsigned char c;", "\n long i,j,m,n,f;", "\n long min1,pt1,flength;", "\n FILE ", "ifp,*ofp;", "\n printf(\"源文件名:\");", "\n gets_s(filename);", "\n ifp=fopen(filename,\"rb\");", "\n if(ifp==NULL)", "\n {", "\n  printf(\"源文件打开失败!\\n\");", "\n  return;", "\n }", "\n fn = _fileno(ifp); /", "取得文件指针的底层流式文件号*/", "\n sz = _filelength(fn);/*根据文件号取得文件大小*/", "\n printf(\"文件大小为:%d B.\\n\", sz);", "\n sz1 = sz;", "\n printf(\"压缩后文件名:\");", "\n gets_s(outputfile);", "\n  start=clock(); /* 计时开始 */ ", "\n ofp=fopen(outputfile,\"wb\");", "\n if(ofp==NULL)", "\n {", "\n  printf(\"压缩文件打开失败!\\n\");", "\n  return;", "\n }", "\n flength=0;", "\n\n", "while(!feof(ifp))", "\n {", "\n  fread(&c,1,1,ifp);//读数据", "\n  header[c].count++; //字符重复出现频率+1", "\n  flength++;  //字符出现原文件长度+1", "\n }", "\n flength--;", "\n header[c].count--;//减一平衡位数", "\n for(i=0;i\n {", "\n  if(header[i].count!=0) ", "\n      header[i].b=(unsigned char)i;", "\n  /*将每个哈夫曼码值及其对应的ASCII码存放在一维数组header[i]中，", "\n  且编码表中的下标和ASCII码满足顺序存放关系*/", "\n  else header[i].b=0;", "\n  header[i].parent=-1; //对结点进行初始化", "\n  header[i].lch=header[i].rch=-1;", "\n }", "\n for(i=0;i\n {", "\n  for(j=i+1;j\n  {", "\n   if(header[i].count \n   {", "\n    tmp=header[i];", "\n    header[i]=header[j];", "\n    header[j]=tmp;", "\n   }", "\n  }", "\n }", "\n for(i=0;i\n n=i;", "\n m=2*n-1; //外部叶子结点数为n个时，内部结点数为n-1，整个哈夫曼树的需要的结点数为2*n-1.", "\n for(i=n;i\n {", "\n  min1=999999999;", "\n  for(j=0;j", "\n  {", "\n   if(header[j].parent!=-1) continue;//parent!=-1说明该结点已存在哈夫曼树中，跳出循环重新选择新结点*/", "\n   if(min1>header[j].count)", "\n   {", "\n    pt1=j;", "\n    min1=header[j].count;//找到最小值", "\n    continue;", "\n   }", "\n  }", "\n  header[i].count=header[pt1].count;", "\n  header[pt1].parent=i; //依据parent域值（结点层数）确定树中结点之间的关系", "\n  header[i].lch=pt1;//计算左分支权值大小", "\n  min1=999999999;", "\n  for(j=0;j", "\n  {", "\n   if(header[j].parent!=-1) continue;", "\n   if(min1>header[j].count)", "\n   {", "\n    pt1=j;", "\n    min1=header[j].count;", "\n    continue;", "\n   }", "\n  }", "\n  header[i].count+=header[pt1].count;", "\n  header[i].rch=pt1;//计算右分支权值大小", "\n  header[pt1].parent=i;", "\n }", "\n for(i=0;i\n {", "\n  f=i;", "\n  header[i].bits[0]=0;//根结点编码0   ", "\n  while(header[f].parent!=-1)", "\n  {", "\n   j=f;", "\n   f=header[f].parent;", "\n   if(header[f].lch==j) //置左分支编码0", "\n   {", "\n    j=strlen(header[i].bits);//扫描长度", "\n    memmove(header[i].bits+1,header[i].bits,j+1);//由header复制j+ 1个到前者", "\n                                                 //依次存储连接“0”“1”编码", "\n    header[i].bits[0]='0';", "\n   }", "\n   else//置右分支编码1", "\n   {", "\n    j=strlen(header[i].bits);//计算字符长度？", "\n    memmove(header[i].bits+1,header[i].bits,j+1);", "\n    header[i].bits[0]='1';", "\n   }", "\n  }", "\n }", "\n fseek(ifp,0,SEEK_SET);//从文件开始位置向前移动0字节，即定位到文件开始位置", "\n fwrite(&flength,sizeof(int),1,ofp);/*用来将数据写入文件流中，参数flength指向欲写入的数据地址，", "\n总共写入的字符数以参数size*int来决定，返回实际写入的int数目1*/ ", "\n fseek(ofp,8,SEEK_SET);", "\n buf[0]=0; //定义缓冲区,它的二进制表示00000000", "\n f=0;", "\n pt1=8;", "\n /*假设原文件第一个字符是\"A\"，8位2进制为01000001，编码后为0110识别编码第一个'0'，", "\n 那么我们就可以将其左移一位，看起来没什么变化。下一个是'1'，应该|1，结果00000001", "\n 同理4位都做完，应该是00000110，由于字节中的8位并没有全部用完，我们应该继续读下一个字符，", "\n 根据编码表继续拼完剩下的4位，如果字符的编码不足4位，还要继续读一个字符，", "\n 如果字符编码超过4位，那么我们将把剩下的位信息拼接到一个新的字节里*/", "\n while(!feof(ifp))", "\n {", "\n  c=fgetc(ifp);", "\n  f++;", "\n  for(i=0;i\n  {", "\n   if(c==header[i].b) break;", "\n  }", "\n  strcat(buf,header[i].bits);", "\n  j=strlen(buf);", "\n  c=0;", "\n  while(j>=8) //对哈夫曼编码位操作进行压缩存储", "\n  {", "\n   for(i=0;i\n   {", "\n    if(buf[i]=='1') c=(c\n    else c=c\n   }", "\n   fwrite(&c,1,1,ofp);", "\n   pt1++; //统计压缩后文件的长度", "\n   strcpy(buf,buf+8);//一个字节一个字节拼接", "\n   j=strlen(buf);", "\n  }", "\n  if(f==flength) break;", "\n }", "\n if(j>0) //对哈夫曼编码位操作进行压缩存储", "\n {", "\n  strcat(buf,\"00000000\");", "\n  for(i=0;i<8;i++)", "\n  {", "\n   if(buf[i]=='1') c=(c<<1)|1;", "\n   else c=c<<1;", "\n  }", "\n  fwrite(&c,1,1,ofp);", "\n  pt1++;", "\n }", "\n fseek(ofp,4,SEEK_SET);", "\n fwrite(&pt1,sizeof(long),1,ofp);", "\n fseek(ofp,pt1,SEEK_SET);", "\n fwrite(&n,sizeof(long),1,ofp);", "\n for(i=0;i<n;i++)", "\n {", "\n  fwrite(&(header[i].b),1,1,ofp);", "\n  c=strlen(header[i].bits);", "\n  fwrite(&c,1,1,ofp);", "\n  j=strlen(header[i].bits);", "\n  if(j%8!=0) //若存储的位数不是8的倍数，则补0", "\n  {", "\n   for(f=j%8;f<8;f++)", "\n   strcat(header[i].bits,\"0\");", "\n  }", "\n  while(header[i].bits[0]!=0)", "\n  {", "\n   c=0;", "\n   for(j=0;j<8;j++) //字符的有效存储不超过8位，则对有效位数左移实现两字符编码的连接", "\n   {", "\n    if(header[i].bits[j]=='1') c=(c<<1)|1; //|1不改变原位置上的“0”“1”值", "\n    else c=c<<1;", "\n   }", "\n   strcpy(header[i].bits,header[i].bits+8);// 把字符的编码按原先存储顺序连接", "\n   fwrite(&c,1,1,ofp);", "\n  }", "\n }", "\n fclose(ifp);", " ", "\n\n", "printf(\"压缩成功!\\n\");", "\n end=clock(); /* 计时结束 ", "/", "\n fn = _fileno(ofp); /", "取得文件指针的底层流式文件号*/", "\n sz = _filelength(fn);/*根据文件号取得文件大小*/", "\n printf(\"压缩后文件大小为:%d B.\\n\", sz);", "\n x = (sz / sz1)*1.0;", "\n printf(\"压缩率为:%d B.\\n\", x);", "\n fclose(ofp); ", "\nprintf(\"压缩用时%f秒\\n\",(double)(end - start) / CLOCKS_PER_SEC);", "\n return;", "\n}", "\n\n", "//", "\n整体代码如上，请问下  关于找到最小值以后", "\n\n", "header[i].count=header[pt1].count;", "\n  header[pt1].parent=i; //依据parent域值（结点层数）确定树中结点之间的关系", "\n  header[i].lch=pt1;//计算左分支权值大小", "\n    哈夫曼生成的节点权重不应该两者之和么，这个对于双亲的赋值不是很懂，这种利用数组进行排序以后的这个操作不是很明白，这个i好像是顺序，但不是累加，怎么剔除以后去和剩下的节点比较啊。原来搞不明白这里怎么赋值的"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1、第一步&amp;#xff1a;将字符全部按照频率按升序排序&amp;#xff1b;&lt;br /&gt;2、b和e是最小的两个节点&amp;#xff0c;两者连接到同一个节点上&amp;#xff0c;该节点权值为0.04&amp;#43;0.06&amp;#61;0.1;&lt;br /&gt;3、最小的两个节点权值为0.1和0.17&amp;#xff0c;将两个节点合并到一个节点上&amp;#xff0c;频率为&amp;#xff1a;0.1&amp;#43;0.17&amp;#61;0.27&amp;#xff1b;&lt;br /&gt;4、重复以上步骤&amp;#xff0c;哈弗曼树构造完成。&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/909285627276126.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;br /&gt;关于WPL&amp;#xff1a;f、a、c在第二层&amp;#xff0c;d在第三层&amp;#xff0c;b和e在第四层&amp;#xff0c;所以&lt;br /&gt;WPS&amp;#61;&amp;#xff08;0.18&amp;#43;0.23&amp;#43;0.32&amp;#xff09;&lt;em&gt;2&amp;#43;0.17&lt;/em&gt;3&amp;#43;&amp;#xff08;0.04&amp;#43;0.06&amp;#xff09;*4&amp;#61;2.37。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构c语言哈夫曼树", ["有一份电文中共使用 6个字符:a,b,c,d,e,f,它们的出现频率依次为0.23  0.04  0.32  0.17  0.06  0.18  试构造一棵哈夫曼树，求其加权路径长度WPL及各字符的编码。"]], "Tag": "算法设计"}
{"Answer": "你的方法定义是不是不对？调用方法之后node里面的内容有带回到主函数吗？可以断点看下返回之后node的内容。", "Konwledge_Point": "哈夫曼编码", "Question": ["当输入3个字母以上，执行到if (node[p].lchild == c) 无法读取内存", ["#include", "\n#include", "\n#include", "\n\n", "#define MAXBIT      100", "\n#define MAXVALUE  10000", "\n#define MAXLEAF     30", "\n#define MAXNODE    MAXLEAF*2 -1", "\n\n", "using namespace std;", "\n\n", "typedef struct{", "\n    int bit[100];", "\n    int start;", "\n}Code;", "\ntypedef struct node{", "\n    char data;", "\n    int weight;", "\n    int parent;", "\n    int lchild;", "\n    int rchild;", "\n    bool tag;", "\n}Node;", "\n\n", "int HuffmanTree(Node node[MAXNODE], int a[128])", "\n{", "\n    int i, j, m1, m2, x1, x2;", "\n    int n = 0;", "\n    for (i = 0; i < 128; i++)", "\n    {", "\n        if (a[i])", "\n        {", "\n            node[n].weight = a[i];", "\n            node[n].parent = -1;", "\n            node[n].lchild = -1;", "\n            node[n].rchild = -1;", "\n            node[n].data = (char)i;", "\n            n++;", "\n        }", "\n    }", "\n    for (i = n ; i < 2*n; i++)", "\n    {", "\n        node[n].weight = 0;", "\n        node[n].parent = -1;", "\n        node[n].lchild = -1;", "\n        node[n].rchild = -1;", "\n    }", "\n    /*循环构建霍夫曼树*/", "\n    for (i = 0; i <n-1; i++)", "\n    {", "\n        m1 = m2 = MAXVALUE;", "\n        /* m1、m2中存放两个无父结点且结点权值最小的两个结点 ", "/", "\n        x1 = x2 = 0;", "\n        /", " 找出所有结点中权值最小、无父结点的两个结点，并合并之为一颗二叉树 */", "\n        for (j = 0; j < n + i; j++)", "\n        {", "\n            if (node[j].parent == -1 && node[j].weight<m1)", "\n            {", "\n                m2 = m1;", "\n                x2 = x1;", "\n                m1 = node[j].weight;", "\n                x1 = j;", "\n            }", "\n            else if (node[j].weight < m2 && node[j].parent == -1)", "\n            {", "\n                m2 = node[j].weight;", "\n                x2 = j;", "\n            }", "\n\n", "    }\n    /* 设置找到的两个子结点 x1、x2 的父结点信息 */\n    node[x1].parent = n + i;\n    node[x2].parent = n + i;\n    node[n + i].weight = node[x1].weight + node[x2].weight;\n    node[n + i].lchild = x1;\n    node[n + i].rchild = x2;\n}\nreturn n;\n", "\n\n", "}", "\nint main()", "\n{", "\n    Node node[MAXNODE];", "\n    Code code[MAXLEAF], cd;", "\n    char s[500];", "\n    int i, j, c, p,n;", "\n    int a[128] = { 0 };", "\n    cout << \"Please input your string:\"<\n    cin >> s;", "\n    for (i = 0; s[i]; i++)", "\n        a[s[i]]++;", "\n    for (j = 0; j < 128; j++)", "\n    {", "\n        if (a[j])", "\n        {", "\n            cout << (char)j << \":\" << a[j] << endl;", "\n        }", "\n    }", "\n    n=HuffmanTree(node, a);", "\n    cout << n;", "\n    for (i = 0; i < n; i++)", "\n    {", "\n        cd.start = n-1;", "\n        c = i;", "\n        p = node[c].parent;", "\n        while (p != -1)", "\n        {", "\n\n", "        if (node[p].lchild == c)\n            cd.bit[cd.start] = 0;\n        else\n        {\n            cd.bit[cd.start] = 1;\n        }\n        cd.start--;\n        c = p;\n        p = node[c].parent;\n    }//end while\n    for (j = cd.start + 1; j < n; j++)\n    {\n        code[i].bit[j] = cd.bit[j];\n    }\n    code[i].start = cd.start;\n}//end for\n/* 输出已保存好的所有存在编码的哈夫曼编码 */\ncout << \"编码：\" << endl;\n        for (i = 0; i < n; i++)\n        {\n            cout << node[i].data<< \" :\";\n            for (j = code[i].start + 1; j < n; j++)\n            {\n                cout << code[i].bit[j];\n            }\n        cout << endl;\n        }\nsystem(\"pause\");\n", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "这个题目你只需要知道哈夫曼树就可以了\r\n首先将字符与加权一一对应，并将他们按权值大小排序：\r\nd 0.12 c 0.14 b 0.17 e 0.18 f 0.19 a 0.2\r\n哈夫曼树构造方法：\r\n假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：\r\n(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；\r\n(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；\r\n(3)从森林中删除选取的两棵树，并将新树加入森林；\r\n(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。\r\n----来源百度百科\r\n（1）先挑选最小的两个节点，此处为dc，作为一棵树的左右叶子，用他们的和作为根节点，就够造成了一棵树。\r\n（2）以新产生的树为左子树，在未加入树中的节点在选择一个最小权值的节点，作为右叶子，构造一棵树。\r\n（3）重复（2），直至结束。\r\n然后根据左零右一得规则进行编码，即任意一个根节点，指向左孩子的树枝（姑且叫树枝）标注零，同理指向右孩子的标注一。如图\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201911/10/1573383456_900144.jpg)\r\n\r\n确定编码：从根节点出发，到指定节点N所走过路径上的编码顺排，就构成了这个节点的编码，如a可以编码1指代。\r\n每个节点的编码图片中已经给出。\r\n求加权路径长度：题目中给出了每个节点的权值，可记为Wi（第i个节点的权重）你需要搞清楚普通路径长度是多少，根据够早的哈弗曼数，每一个节点到根节点的所要经过的边数称为路径长度，此处记为Li（第i个节点的...）\r\n加权路径长度即为全部节点LiWi的西格玛求和\r\n本题目构造的哈夫曼树WPL为\r\n0.2×1+0.19×2+0.18×3+0.17×4+0.14×5+0.12×5\r\n\r\n\r\n学过好久了，可能有纰漏，海涵。", "Konwledge_Point": "哈夫曼编码", "Question": ["数据结构------树  能不能帮忙解答下", ["有一份电文中共使用 6个字符：a，b，c，d，e，f，它们的出现频率依次为：  0.2，0.17，0.14，0.12，0.18，0.19，回答下面的问题： ", "\n (1)   试构造一棵哈夫曼树（小值左子树，大值右子树） ", "\n (2)   给出各个字符的编码（按照左0右1编码）", "\n (3)   求其加权路径长度WPL"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;而哈夫曼树&amp;#xff08;Huffman Tree&amp;#xff09;是在叶子结点和权重确定的情况下&amp;#xff0c;带权路径长度最小的二叉树&amp;#xff0c;也被称为最优二叉树。&lt;br /&gt;--链接转自&lt;a href=\"https://blog.csdn.net/qq_45737068/article/details/106910349\" id=\"textarea_1630459855151_1630460459579_0\" class=\"md_link_card\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;\n  &lt;span class=\"md_link_title\"&gt;最全哈夫曼树哈夫曼编码讲解&amp;#xff0c;兄弟你值得拥有_记录博主学到的点滴-CSDN博客&lt;/span&gt;\n  &lt;span class=\"md_link_desc\" style=\"\"&gt;目录 1.哈夫曼树的概念                路径概念        路径长度概念         节点的带权路径长度        树的带权路径长度 2.构建哈夫曼树的步骤 3.构建哈夫曼树的完整代码 4.哈夫曼编码1.哈夫曼树的概念在正式&lt;/span&gt;\n  &lt;span class=\"md_flex_card\"&gt;\n  &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n    &lt;span class=\"flex-1\"&gt;\n      &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_45737068/article/details/106910349&lt;/span&gt;\n    &lt;/span&gt;\n  &lt;/span&gt;&lt;/a&gt;&lt;br /&gt;想要得到一颗哈夫曼树&amp;#xff0c;就应该每次找到权值最小的两个点的权值和作为他们两个点的根节点&amp;#xff0c;这样做的目的是用最大的深度乘以最小的权重。所以为了每次都取最小的两个值&amp;#xff0c;就需要把数组排列一下。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["为什么这个地方要将哈夫曼树的权值由大到小排列。", ["for", "(", "i", "=0;i<256;i++)", "\n{                    ", "//", "按出现权值从大到小排序\n    for", "(", "j", "=i+1;j<256;j++)", "{\n        ", "if", "(header[i].count<header[j].count)", "{\n            tmp=header[i];\n            header[i]=header[j]; \n            header[j]=tmp; \n        } \n    } \n}\nfor", "(", "i", "=0;i<256;i++)", "                    ", "//", "找到第一个空的header结点\n    ", "if", "(header[i].", "count", "==0)", " \n        break; \nn=i;       ", "//", "因为权值已经从大到小排列并且找到了第一个空的header结点，所以这句话代表现有所有结点个数 （n） \nm=2*n-1;    ", "//m", "代表哈夫曼树中需要的所有的结点个数 \nfor", "(", "i", "=n;i<m;i++)", " ", "//", " m=2*n-1\n{\n    min1=999999999;                ", "//", "预设的最大权值，即结点出现的最大次数\n    for", "(", "j", "=0;j<i;j++)", "\n    {\n        ", "if", "(header[j].parent!=-1)", " \n            continue;                /*parent!=-1说明该结点已存在哈夫曼\n                                树中，跳出循环重新选择新结点*/\n        ", "if", "(min1>header[j].count)", " ", "//", "代表不在哈夫曼树中 \n        {    \n            pt1=j; ", "//j", "是下标 \n            min1=header[j]", ".count", "; \n            continue;    \n        } \n    }\n    header[i]", ".count=header", "[pt1]", ".count", "; \n    header[pt1]", ".parent=i", ";      \n    header[i]", ".lch=pt1", ";   \n    min1=999999999;   \n    for", "(", "j", "=0;j<i;j++)", "{\n        ", "if", "(header[j].parent!=-1)", " \n            continue;                                        \n        ", "if", "(min1>header[j].count)", "\n        {\n            pt1=j; \n            min1=header[j]", ".count", "; \n            continue; \n        } \n    }\n    header[i]", ".count", "+=header[pt1]", ".count", "; \n    header[i]", ".rch=pt1", ";   \n    header[pt1]", ".parent=i", ";            ", "//", "哈夫曼无重复前缀编码 \n}\n"]], "Tag": "算法设计"}
{"Answer": "你用写的？\r\nchar cd[n];\r\n这句能通过编译？怎么可能？", "Konwledge_Point": "哈夫曼编码", "Question": ["赫夫曼树出错 ，编译没错 不知道哪里错了运行不了", ["编译没有错误，运行失败", "\n\n", "\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h> \n#include <string.h> \n#define STACK_INIT_SIZE 100//存储空间初始分配量  没分号“;” \n#define STACKINCREMENT 10 //存储空间分配增量\n\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 0\n#define INFEASIBLE -1\n\ntypedef struct {\n    unsigned int weight;\n    unsigned int parent,lchild,rchild;  \n}HTNode,*HuffmanTree;\n\ntypedef char **HuffmanCode;\n\n//在HT[1..i-1]选择parent为0且weight最小的两个结点，\n//其序号为最小s1和次小s2(若parent≠0，则说明被选取过不能再选)\n//s1s2并不是指的weight权值，而是最（次）小的这个字符前面的编号（后面需要填进lchild、rchild）\n\nvoid Select(HuffmanTree p,int n,int *s1,int *s2)\n{\n    int i;\n    int min = 99999;\n    for(i=1;i<=n;i++){\n        if(p[i].parent == 0){\n            if(p[i].weight <= min){\n            min = p[i].weight;\n            *s1 = i;\n            }\n        }   \n    }\n    min = 99999;\n    for(i=1;i<=n;i++){\n        if(p[i].parent==0){\n            if(p[i].weight<=min && i!=*s1){\n            min = p[i].weight;\n            *s2 = i;\n            }\n        }   \n    }   \n}\n\n\nvoid HuffmanCoding(HuffmanTree *HT,HuffmanCode *HC,int *w,int n){\n    //n字符 m节点 HT空间\n    int m,i;\n    HuffmanTree p;\n    //int w[8] = {5,29,7,8,14,23,3,11};\n    m = 2*n-1;\n    if(n<=1){return;}   \n    //加上一个未用的0号单元\n    HT = (HuffmanTree *)malloc((m+1)*sizeof(HTNode)); \n\n    //一：初始化，得a图：\n    //(1)把已有字符（1-8） 权重赋值w，左右孩子及parent赋值为0,p指向第二个单元（非0第一个） \n    for(p=*HT+1,i=1 ; i<=n ; ++i,++p,++w){//[问题p=HT+1？]看和鸿昌的聊天记录 \n        //*p={*w,0,0,0};\n        //错误原因： 赋值数组不能分着写\n        //http://zhidao.baidu.com/link?url=jZOgI5PGVycg1v6c1pJ2AlDI3J6fiDLUQQ-1FkGjGzrXTE-hYQusYkoVQlM-EBhr3IjdF9d1wy-o_6elz6m2hald8u0LVM1EUzDaTZ6Rs7e\n        (*p).weight = *w;\n        (*p).parent = 0;\n        (*p).lchild = 0;\n        (*p).rchild = 0;\n    }\n    //(2)把未知字符（9-15） 权重、左右孩子及parent赋值为0， p指向上面跳出来的 未知字符的第一个 9\n    for(;i<=m;++i,++p){\n        (*p).weight = 0;\n        (*p).parent = 0;\n        (*p).lchild = 0;\n        (*p).rchild = 0;    \n    }\n\n    //二：建立赫夫曼树,得到b图 \n    //在HT[1..i-1]选择parent为0且weight最小的两个结点，其序号为最小s1和次小s2(若parent≠0，则说明被选取过不能再选)\n    for(i=n+1;i<=m;++i){    //n+1 即后面未知字符 （比如9开始到15） \n    int s1,s2;\n    //void Select(HuffmanTree HT,int q,int *s1,int *s2){\n    Select(*HT,i-1,&s1,&s2);\n\n    //select(*HT,i-1,&s1,&s2);\n\n    //给s1 s2的parent赋值为当前i 编号 \n    (*HT)[s1].parent = i;\n    (*HT)[s2].parent = i;\n    //给当前i 的lchild和rchild赋值为s1、s2编号 ，给当前i 的 weight赋值为二者权重之和\n    //设最小的作左子树，次小的作右子树 \n    (*HT)[i].lchild = s1;\n    (*HT)[i].rchild = s2;\n    (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight;\n    }\n\n    //三：从叶子到根逆向求每个结点字符的赫夫曼编码 \n\n    //存放赫夫曼编码的cd \n    char cd[n];\n    int c,f;\n    //分配n个字符编码的头指针向量HC \n    //HuffmanTree HC;报错类型：declaration of'HTNode* HC'shadows a parameter 原因：函数参数里已有HC的定义导致重复 \n    HC = (HuffmanCode *)malloc((n+1)*sizeof(char *));\n    //编码结束符  如声明cd[8]，0-7中最后一个结束符则为cd[7] \n    cd[n-1] = '\\0';//书上写错了，应该是'\\0' \n    //1-8逐个求 \n    for(i=1;i<=n;++i){\n        //编码结束符位置 \n        int start = n-1;\n        //c=i，f指向当前字 符i的双亲 双亲不为0则循环 经过循环一次后，当前字符变成它的双亲,以此逆向递推 \n        //小细节：--start  如图 \n        for(c=i,f=(*HT)[i].parent;f!=0;c=f,f=(*HT)[f].parent){\n            if((*HT)[f].lchild ==c){\n            cd[--start]='0';//书上写错了，应该是单引号'0' \n            }else{\n            cd[--start]='1';\n            }\n            //for循环结束后，得到cd，为第i个字符分配存储空间HC\n            (*HC)[i] = (char *)malloc((n-start)*sizeof(char));\n            //start目前指到最前面了，所以将cd复制（strcpy）给HC \n            /*原型声明：char *strcpy(char* dest, const char *src);\n                头文件：#include <string.h> 和 #include <stdio.h>\n                功能：把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间*/\n            strcpy((*HC)[i],&cd[start]);\n        }\n    }\n    free(cd);\n}\n\n\n\n\nint main(void){\n   HuffmanTree HT;\n   HuffmanCode HC;\n   int n;\n   printf(\"请输入字符个数(空格间隔)：\");\n   scanf(\"%d\",&n);\n\n   int i; \n   int *w=NULL;\n   w=(int*)malloc(n*sizeof(int));\n   printf(\"请依次输入权值(空格间隔)：\");\n   for(i=0;i<n;i++){\n      scanf(\"%d\",w+i);\n   }\n\n   HuffmanCoding(&HT,&HC,w,n);\n   for(i=1;i<=n;i++){ \n   puts(HC[i]);//???\n   } \n}\n\n", "\n\n", "已解决。。。"]], "Tag": "算法设计"}
{"Answer": "&lt;p style=\"text-align:center\"&gt;&lt;img alt=\"\" src=\"https://img-ask.csdnimg.cn/upload/1624034849533.png\" /&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["哈夫曼树压缩，报错不能将errno_t类型的值分配到+file*类型的实体，该怎么修改解决这个问题", ["\n", "#include <stdio.h> \n#include <string.h> \n#include <stdlib.h> \n#include <conio.h> \n#define _CRT_SECURE_NO_WARNINGS\n\n/*哈夫曼树结构定义*/\nstruct head\n{\n    unsigned char b;            /*定义一个字符*/\n    long count;                 /*频率数据*/\n    long parent, lch, rch;        /*创建哈夫曼树*/\n    char bits[256];             /*哈夫曼结点*/\n}header[512], tmp;\n\n\n/*压缩文件*/\nvoid yasuo()\n{\n    char filename[255], outputfile[255], buf[512];\n    unsigned char c;\n    char wenjianming[255];\n    long i, j, m, n, f;\n    long min1, pt1, flength;\n    FILE* ifp, * ofp;\n    printf(\"请输入文件地址及文件名：\");\n    gets_s(filename);\n    ifp = fopen_s( &ifp,\"filename\", \"rb\");     /*打开源文件并读取*/\n    while (ifp == NULL)\n    {\n        printf(\"打开文件时出错！\\n\");\n        printf(\"请重新输入文件地址及文件名：\");\n        gets_s(filename);\n        ifp = fopen_s(&ifp,\"filename\", \"rb\");\n    }\n    printf(\"请输入压缩后的文件地址和文件名及后缀：\");\n    gets_s(wenjianming);\n    ofp = fopen_s(&ofp,\"wenjianming\", \"wb\");    /*创建并打开目的文件*/\n\n    while (ofp == NULL)\n    {\n        printf(\"请重新输入压缩后的文件地址和文件名及后缀：\");\n        ofp = fopen_s(&ofp,\"wenjianming\", \"wb\");\n    }\n    flength = 0;\n\n    /*读取ifp文件*/\n    while (!feof(ifp))\n    {\n        fread(&c, 1, 1, ifp);           /*按位读取文件*/\n        header[c].count++;           /*记录文件的字符总数*/\n        flength++;\n    }\n    flength = -1;\n    header[c].count = -1;             /*读取文件结束*/\n    /*构造哈弗曼树，初始结点的设置*/\n    for (i = 0; i < 512; i++)\n    {\n        if (header[i].count != 0)\n            header[i].b = (unsigned char)i;\n        else\n            header[i].b = 0;\n        header[i].parent = -1;\n        header[i].lch = header[i].rch = -1;\n    }\n    /*按结点出现的次数排序*/\n    for (i = 0; i < 256; i++)\n    {\n        for (j = i + 1; j < 256; j++)\n        {\n            if (header[i].count < header[j].count)\n            {\n                tmp = header[i];\n                header[i] = header[j];\n                header[j] = tmp;\n            }\n        }\n    }\n    /*统计不同字符的数量*/\n    for (i = 0; i < 256; i++)\n        if (header[i].count == 0)\n            break;\n    n = i;\n    m = 2 * n - 1;\n    for (i = n; i < m; i++)\n    {\n        min1 = 999999999;\n        for (j = 0; j < i; j++)\n        {\n            if (header[j].parent != -1)\n                continue;\n            if (min1 > header[j].count)\n            {\n                pt1 = j;\n                min1 = header[j].count;\n                continue;\n            }\n        }\n        header[i].count = header[pt1].count;\n        header[pt1].parent = i;\n        header[i].lch = pt1;\n        min1 = 999999999;\n        for (j = 0; j < i; j++)\n        {\n            if (header[j].parent != -1)\n                continue;\n            if (min1 > header[j].count)\n            {\n                pt1 = j;\n                min1 = header[j].count;\n                continue;\n            }\n        }\n        header[i].count += header[pt1].count;\n        header[i].rch = pt1;\n        header[pt1].parent = i;\n    }\n    /*构造哈夫曼树，设置字符编码*/\n    for (i = 0; i < n; i++)\n    {\n        f = i;\n        header[i].bits[0] = 0;\n        while (header[f].parent != -1)\n        {\n            j = f;\n            f = header[f].parent;\n            if (header[f].lch == j)\n            {\n                j = strlen(header[i].bits);\n                memmove(header[i].bits + 1, header[i].bits, j + 1);\n                header[i].bits[0] = '0';\n            }\n            else\n            {\n                j = strlen(header[i].bits);\n                memmove(header[i].bits + 1, header[i].bits, j + 1);\n                header[i].bits[0] = '1';\n            }\n        }\n    } /*哈弗曼构造结束*/\n\n    //读取源文件中的每一个字符，按照设置好的编码替换文件中的字符\n    fseek(ifp, 0, SEEK_SET);\t\t\t\t\t/*把文件指针指向文件的开头*/\n    fwrite(&flength, sizeof(int), 1, ofp);     /*把哈弗曼代码写入ofp文件*/\n    fseek(ofp, 8, SEEK_SET);                   /*以8位二进制数为单位读取*/\n    buf[0] = 0;\n    f = 0;\n    pt1 = 8;\n    while (!feof(ifp))\n    {\n        c = fgetc(ifp);        //从流中读取一个字符，并增加文件指针的位置\n        f++;\n        for (i = 0; i < n; i++)\n        {\n            if (c == header[i].b)\n                break;\n        }\n        strcat_s(buf, header[i].bits); //把header[i].bits所指字符串添加到buf结尾处\n        j = strlen(buf);            //计算字符串buf的长度\n        c = 0;\n        while (j >= 8)     /*按八位二进制数转化成十进制ASCII码写入文件一次进行压缩*/\n        {\n            for (i = 0; i < 8; i++)\n            {\n                if (buf[i] == '1') c = (c << 1) | 1;\n                else c = c << 1;\n            }\n            fwrite(&c, 1, 1, ofp);\n            pt1++;\n            strcpy_s(buf, buf + 8);\n            j = strlen(buf);\n        }\n        if (f == flength)\n            break;\n    }\n    if (j > 0) /*剩余字符数量少于8个*/\n    {\n        strcat_s(buf, \"00000000\");\n        for (i = 0; i < 8; i++)\n        {\n            if (buf[i] == '1') c = (c << 1) | 1;\n            else c = c << 1;     /*对不足的位数补0*/\n        }\n        fwrite(&c, 1, 1, ofp);\n        pt1++;\n    }\n    //将编码信息写入存储文件\n    fseek(ofp, 4, SEEK_SET);     /*fseek 用于二进制方式打开的文件,移动文件读写指针位置.第一个是文件流,第3个是指针零点位置,第2个是把指针移动到的地点. */\n    fwrite(&pt1, sizeof(long), 1, ofp); /*是要输出数据的地址,每次写入的位数,数据项的个数，目标文件地址*/\n    fseek(ofp, pt1, SEEK_SET);\n    fwrite(&n, sizeof(long), 1, ofp);\n    for (i = 0; i < n; i++)\n    {\n        fwrite(&(header[i].b), 1, 1, ofp);\n        c = strlen(header[i].bits);\n        fwrite(&c, 1, 1, ofp);\n        j = strlen(header[i].bits);\n        if (j % 8 != 0)             /*按八位读取，位数不满8位时，对该位补0*/\n        {\n            for (f = j % 8; f < 8; f++)\n                strcat_s(header[i].bits, \"0\");\n        }\n        while (header[i].bits[0] != 0)\n        {\n            c = 0;\n            for (j = 0; j < 8; j++)\n            {\n                if (header[i].bits[j] == '1') c = (c << 1) | 1;\n                else c = c << 1;\n            }\n            strcpy_s(header[i].bits, header[i].bits + 8);  /*把从header[i].bits+8地址开始且含有NULL结束符的字符串赋值到以header[i].bits开始的地址空间 */\n            fwrite(&c, 1, 1, ofp);\n        }\n    }\n    fclose(ifp);\n    fclose(ofp);\n    printf(\"压缩成功\\n\");\n\n}\n/*主函数*/\nvoid main()\n{\n    printf(\"输入a开始压缩\\n\");\n    printf(\"输入b结束压缩\\n\");\n    while (1)\n    {\n        char c;\n        c =_getch();\n        if (c == 'a')\n            yasuo();\n        else\n        {\n            if (c == 'b')\n                return;\n        }\n    }\n}\n"]], "Tag": "算法设计"}
{"Answer": "自己顶下……求解答啊求解答", "Konwledge_Point": "哈夫曼编码", "Question": ["求关于图片裁剪的底层算法解释", ["根据鼠标点击位置得到裁剪范围，然后把指定范围裁剪出来。从底层来看，就是输出指定范围的数据。拿jpg为例，jpg是个压缩格式，经过了游程编码和哈夫曼树，算法是怎么找到鼠标", "\n点击位置是在图像数据的哪里？怎么确定的指定范围对应的图形数据？我看了一些裁剪的源码，但是没有看懂......求大神帮忙解答!!  "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ChatGPT :&lt;br /&gt;在C语言中&amp;#xff0c;无法直接将map写入文件&amp;#xff0c;因为map是一个动态的数据结构&amp;#xff0c;其大小在编译时无法确定。因此&amp;#xff0c;需要将map转换为一种可以写入文件的数据结构&amp;#xff0c;比如数组或者结构体。在本文中&amp;#xff0c;作者使用了一个名为ZipStruct的结构体来存储压缩文件的相关信息&amp;#xff0c;其中包括编码表&amp;#xff08;encodeMap&amp;#xff09;和所占字节数&amp;#xff08;size&amp;#xff09;。在压缩文件时&amp;#xff0c;先将编码表和字节流写入ZipStruct结构体中&amp;#xff0c;然后再将整个结构体写入文件中。在解压文件时&amp;#xff0c;先读取ZipStruct结构体&amp;#xff0c;然后根据其中的编码表将二进制编码字符串转化为原始字符&amp;#xff0c;最后将原始字符写入文件中。需要注意的是&amp;#xff0c;在写入和读取文件时&amp;#xff0c;需要使用二进制模式打开文件&amp;#xff0c;否则可能会出现数据损坏的情况。同时&amp;#xff0c;在写入和读取结构体时&amp;#xff0c;需要使用fwrite和fread函数&amp;#xff0c;而不是普通的文件写入和读取函数。&lt;/p&gt;", "Konwledge_Point": "哈夫曼编码", "Question": ["关于C语言写入结构体时无法写入map的问题", ["在写哈夫曼编码压缩与解压文件的问题时，Java是非常容器且没有问题的；但是在C语言里面，这个文件读写就变得很困难；当我尝试写入一个结构体时，发现没有问题，但是实际并没有将map的内容顺利写入；而且我发现不管是fread还是fwrite，都无法将无法提前确定大小的map集合写入；太痛苦了；感觉我已经在尝试学习Java序列化的解决思路了。", "\n", "代码如下：（原本以为已经写完的我，才发现只是开了个头；C语言的文件读写好折磨，太折磨了）", "文章地址：", "\n      \n        ", "\n        \n      ", "\n      ", "\n      ", "\n        ", "\n         https://blog.csdn.net/bingbingyihao/article/details/129979463\n        ", "\n      ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "# ", "include", " ", "\n", "using", " ", "namespace", " std;\n\n", "// 读取文件得到int数组转化成哈夫曼编码得到哈夫曼树，进行压缩与解压", "\n\n", "typedef", " ", "int", " elementType;\n\n", "struct", " ", "Node", "\n{\n    elementType data;\n    ", "int", " value;\n    Node* left;\n    Node* right;\n};\n\n", "struct", " ", "ZipStruct", "\n{\n    map", " encodeMap; ", "// 由哈夫曼树生成的编码表", "\n    ", "int", " size = ", "0", "; ", "// 所占字节数", "\n    ", "int", " zipSize = ", "0", "; ", "// 所占比特数（用于处理末尾数字补全）", "\n};\n\n", "struct", " ", "Zip", "\n{\n    string originFileName;\n    string destFileName; ", "// 压缩生成的文件名", "\n    elementType* buff = ", "NULL", "; ", "// 读入的文件字符数据", "\n    map", "int> twoTuple; ", "// 字符串转化为二元组形式，表示各个字符出现的频率", "\n    map", " encodeMap; ", "// 由哈夫曼树生成的编码表", "\n    string res; ", "// 生成的二进制编码字符串", "\n    ", "int", " size = ", "0", "; ", "// 所占字节数", "\n    ", "int", " zipSize = ", "0", "; ", "// 所占比特数（用于处理末尾数字补全）", "\n};\n\n", "struct", " ", "UnZip", "\n{\n    string originFileName; ", "// 要解压的文件名", "\n    string destFileName; ", "// 解压生成的文件名", "\n};\n\n", "// 将int数组转化为二元组形式，表示各个int数字出现的频率", "\n", "map", "int", "> ", "getList", "(", "int", "* text, ", "int", " length)", ";\n\n", "//自定义排序函数  ", "\n", "bool", " ", "cmp", "(", "const", " Node* node1, ", "const", " Node* node2)", ";\n\n", "// 通过二元组创建哈夫曼树", "\n", "Node* ", "createHafumanTree", "(vector", " list)", ";\n\n", "// 获取编码", "\n", "void", " ", "getCodes", "(Node* root, string path, map", "& encodeMap)", ";\n\n", "// 读取文件内容，得到int数组", "\n", "elementType* ", "readFile", "(string fileName, ", "int", "& size)", ";\n\n", "// 根据编码表将int数组转化为新的编码", "\n", "string ", "transform", "(elementType* buff, ", "int", " length, map", " encodeMap)", ";\n\n", "// 获取文件生成的二进制编码字符串", "\n", "void", " ", "generateCodes", "(Zip& zip)", ";\n\n", "//将传入的二进制字符串转换成十进制，并返回十进制数字", "\n", "int", " ", "binToTen", "(string binaryString)", ";\n\n", "// 将新编码字符串转化为int数组(转化采用末尾不够补0)，减少占用空间，并写入文件中，返回文件比特数，同时一并将编码表和字节与比特数写入", "\n", "void", " ", "zipFile", "(string res, string fileName, ", "int", "& zipSize, ZipStruct* zipStruct)", ";\n\n", "//将传入的int转换成二进制字符串", "\n", "string ", "intToBin", "(", "int", " ch)", ";\n\n", "// 根据编码表将文件还原", "\n", "void", " ", "unZipFile", "(string originFileName, string destFileName, ZipStruct* zipStruct)", ";\n\n", "int", " ", "main", "()", "\n", "{\n    Zip zip;\n    UnZip unZip;\n    ZipStruct zipStruct;\n\n    zip.originFileName = ", "\"D:/test.png\"", ";\n    zip.destFileName = ", "\"D:/test.myZip\"", ";\n    ", "generateCodes", "(zip);\n    zipStruct.encodeMap = zip.encodeMap;\n    zipStruct.size = zip.size;\n    ", "zipFile", "(zip.res, zip.destFileName, zip.zipSize, &zipStruct);\n\n    unZip.originFileName = zip.destFileName;\n    unZip.destFileName = ", "\"D:/test1.png\"", ";\n    ", "unZipFile", "(unZip.originFileName, unZip.destFileName, &zipStruct);\n\n    ", "system", "(", "\"pause\"", ");\n}\n\n", "map", "int", "> ", "getList", "(", "int", "* text, ", "int", " length)", "\n{\n    map", "int> map;\n    ", "for", " (", "int", " i = ", "0", "; i < length; i++)\n    {\n        ", "if", " (map.", "count", "((", "int", ")text[i]) == ", "1", ")\n        {\n            map[text[i]] = map[text[i]] + ", "1", ";\n        }\n        ", "else", "\n        {\n            map[text[i]] = ", "1", ";\n        }\n    }\n    ", "return", " map;\n}\n\n", "bool", " ", "cmp", "(", "const", " Node* node1, ", "const", " Node* node2)", "\n", "{\n    ", "return", " node1->value > node2->value;\n}\n\n", "Node* ", "createHafumanTree", "(vector", " list)", "\n", "{\n    ", "while", " (list.", "size", "() > ", "1", ")\n    {\n        ", "sort", "(list.", "begin", "(), list.", "end", "(), cmp);\n\n        Node* left = list.", "at", "(list.", "size", "() - ", "1", ");\n        Node* right = list.", "at", "(list.", "size", "() - ", "2", ");\n        Node* node = (Node*)", "malloc", "(", "sizeof", "(Node));\n        ", "if", " (node == ", "NULL", ")\n        {\n            cout << ", "\"内存不足\"", " << endl;\n            ", "return", " ", "NULL", ";\n        }\n        node->value = left->value + right->value;\n        node->left = left;\n        node->right = right;\n\n        list.", "pop_back", "();\n        list.", "pop_back", "();\n        list.", "push_back", "(node);\n    }\n\n    ", "return", " list.", "at", "(", "0", ");\n}\n\n", "void", " ", "getCodes", "(Node* root, string path, map", "& encodeMap)", "\n", "{\n    ", "if", " (root == ", "NULL", ")\n    {\n        ", "return", ";\n    }\n    ", "if", " (root->left == ", "NULL", " && root->right == ", "NULL", ")\n    {\n        encodeMap.", "insert", "(map", "::", "value_type", "(root->data, path));\n    }\n    ", "getCodes", "(root->left, path + ", "\"0\"", ", encodeMap);\n    ", "getCodes", "(root->right, path + ", "\"1\"", ", encodeMap);\n}\n\n", "elementType* ", "readFile", "(string fileName, ", "int", "& size)", "\n", "{\n    ", "struct", " ", "stat", " buf;\n    ", "stat", "(fileName.", "c_str", "(), &buf);\n    size = buf.st_size;\n\n    FILE* fp = ", "NULL", ";\n    ", "int", "* buff = ", "new", " ", "int", "[buf.st_size];\n\n    ", "errno_t", " err;\n    ", "if", " ((err = ", "fopen_s", "(&fp, fileName.", "c_str", "(), ", "\"rb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件打开失败\"", " << endl;\n        ", "return", " ", "NULL", ";\n    }\n\n    ", "int", " index = ", "0", ";\n    ", "while", " (index < buf.st_size)\n    {\n        buff[index++] = ", "fgetc", "(fp);\n    }\n    ", "fclose", "(fp);\n    ", "return", " buff;\n}\n\n", "string ", "transform", "(elementType* buff, ", "int", " length, map", " encodeMap)", "\n", "{\n    string res = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i < length; i++)\n    {\n        res += encodeMap[buff[i]];\n    }\n    ", "return", " res;\n}\n\n", "void", " ", "generateCodes", "(Zip& zip)", "\n", "{\n    zip.buff = ", "readFile", "(zip.originFileName, zip.size);\n    zip.twoTuple = ", "getList", "(zip.buff, zip.size);\n    vector", " list;\n    ", "for", " (", "auto", "& it : zip.twoTuple)\n    {\n        Node* node = (Node*)", "malloc", "(", "sizeof", "(Node));\n        ", "if", " (node == ", "NULL", ")\n        {\n            cout << ", "\"内存不足\"", " << endl;\n            ", "return", ";\n        }\n        node->data = it.first;\n        node->value = it.second;\n        node->left = ", "NULL", ";\n        node->right = ", "NULL", ";\n        list.", "push_back", "(node);\n    }\n\n    Node* root = ", "createHafumanTree", "(list);\n    ", "getCodes", "(root, ", "\"\"", ", zip.encodeMap);\n    zip.res = ", "transform", "(zip.buff, zip.size, zip.encodeMap);\n}\n\n", "int", " ", "binToTen", "(string binaryString)", "\n", "{\n    ", "int", " parseBinary = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < binaryString.", "length", "(); ++i)\n    {\n        ", "if", " (binaryString[i] == ", "'1'", ")\n        {\n            parseBinary += ", "pow", "(", "2.0", ", binaryString.", "length", "() - i - ", "1", ");\n        }\n    }\n    ", "return", " parseBinary;\n}\n\n", "void", " ", "zipFile", "(string res, string fileName, ", "int", "& zipSize, ZipStruct* zipStruct)", "\n", "{\n    zipSize = res.", "length", "();\n    zipStruct->zipSize = zipSize;\n    ", "if", " (res.", "length", "() % ", "8", " != ", "0", ")\n    {\n        ", "for", " (", "int", " i = ", "0", "; i < res.", "length", "() % ", "8", "; i++)\n        {\n            res += ", "\"0\"", ";\n        }\n    }\n\n    ", "char", "* bytes = ", "new", " ", "char", "[res.", "length", "() / ", "8", "];\n    ", "int", " index = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < res.", "length", "();)\n    {\n        string subStr = res.", "substr", "(i, ", "8", ");\n        i += ", "8", ";\n        bytes[index] = ", "binToTen", "(subStr);\n        index++;\n    }\n\n    FILE* fp = ", "NULL", ";\n    ", "errno_t", " err;\n    ", "if", " ((err = ", "fopen_s", "(&fp, fileName.", "c_str", "(), ", "\"wb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件写入失败\"", " << endl;\n        ", "return", ";\n    }\n    ", "fwrite", "(zipStruct, ", "sizeof", "(ZipStruct), ", "1", ", fp);\n    ", "fwrite", "(bytes, ", "sizeof", "(", "unsigned", " __int8), res.", "length", "() / ", "8", ", fp);\n    ", "fclose", "(fp);\n}\n\n", "string ", "intToBin", "(", "int", " ch)", "\n", "{\n    string res = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "7", "; i >= ", "0", "; i--)\n    {\n        ", "if", " (ch & (", "128", " >> ", "7", " - i))\n        {\n            res += ", "\"1\"", ";\n        }\n        ", "else", "\n        {\n            res += ", "\"0\"", ";\n        }\n    }\n    ", "return", " res;\n}\n\n", "void", " ", "unZipFile", "(string originFileName, string destFileName, ZipStruct* zipStruct)", "\n", "{\n    FILE* fp = ", "NULL", ";\n    ", "errno_t", " err;\n    ", "if", " ((err = ", "fopen_s", "(&fp, originFileName.", "c_str", "(), ", "\"rb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件打开失败\"", " << endl;\n        ", "return", ";\n    }\n\n    ", "fread", "(zipStruct, ", "sizeof", "(ZipStruct), ", "1", ", fp);\n    map", " decodeMap;\n    ", "for", " (", "auto", "& it : zipStruct->encodeMap)\n    {\n        decodeMap.", "insert", "(map", "char>::", "value_type", "(it.second, it.first));\n    }\n\n    ", "// 为了凑整，省的用if语句了", "\n    ", "int", " size = zipStruct->zipSize;\n    ", "int", " length = (size + ", "7", ") / ", "8", ";\n    ", "int", "* buff = ", "new", " ", "int", "[length];\n    ", "int", " index = ", "0", ";\n    ", "while", " (index < length)\n    {\n        buff[index++] = ", "fgetc", "(fp);\n    }\n    ", "fclose", "(fp);\n\n    string res = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i < length; i++)\n    {\n        res += ", "intToBin", "(buff[i]);\n    }\n\n    string text = ", "\"\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i <= size;)\n    {\n        index = ", "1", ";\n        ", "while", " (i + index <= size)\n        {\n            string temp = res.", "substr", "(i, index);\n            ", "if", " (decodeMap.", "count", "(temp) == ", "1", ")\n            {\n                text += decodeMap[temp];\n                ", "break", ";\n            }\n            index++;\n        }\n        i += index;\n    }\n\n    ", "if", " ((err = ", "fopen_s", "(&fp, destFileName.", "c_str", "(), ", "\"wb\"", ")) != ", "0", ")\n    {\n        cout << ", "\"文件写入失败\"", " << endl;\n        ", "return", ";\n    }\n    ", "fwrite", "(text.", "c_str", "(), ", "sizeof", "(", "unsigned", " __int8), text.", "length", "(), fp);\n    ", "fclose", "(fp);\n}\n", "\n", "文章可能在审核，要过一小会才能看到"]], "Tag": "算法设计"}
