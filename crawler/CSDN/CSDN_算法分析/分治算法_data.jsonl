{"Answer": "&lt;p&gt;望采纳&amp;#xff1a;&lt;br /&gt;我没有写&amp;#xff0c;我是用gpt帮你写了一个,希望能帮到你。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;procedure&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;hanoi&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(n, src, dst, tmp1, tmp2)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;n&lt;/span&gt; &amp;#61;&amp;#61; 1 &lt;span class=\"hljs-title\"&gt;then&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, dst)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;n&lt;/span&gt; &amp;#61;&amp;#61; 2 &lt;span class=\"hljs-title\"&gt;then&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, tmp1)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tmp1, dst)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;hanoi&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(n-2, src, tmp2, tmp1, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, tmp1)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tmp1, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;hanoi&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(n-2, tmp2, dst, tmp1, src)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;end&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;\n&lt;span class=\"hljs-title\"&gt;end&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;procedure&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中 n 表示盘子数&amp;#xff0c;src 表示源柱&amp;#xff0c;dst 表示目标柱&amp;#xff0c;tmp1 和 tmp2 分别表示两个临时柱&amp;#xff0c;move 函数表示移动操作。具体来说&amp;#xff0c;当只有一个盘子时&amp;#xff0c;直接从源柱移动到目标柱&amp;#xff1b;当有两个盘子时&amp;#xff0c;先将一个盘子从源柱移动到一个临时柱&amp;#xff0c;然后将剩下的两个盘子从源柱直接移动到目标柱&amp;#xff0c;最后将之前移动到临时柱上的盘子移动到目标柱&amp;#xff1b;当有三个或更多盘子时&amp;#xff0c;先将除最上面两个盘子以外的其他盘子从源柱移动到一个临时柱&amp;#xff0c;然后将最上面的两个盘子从源柱直接移动到目标柱&amp;#xff0c;最后将之前移动到临时柱上的其他盘子移动到目标柱&amp;#xff0c;具体的移动过程需要递归调用 hanoi 函数完成。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["写出分治算法解决四柱汉诺塔问题的伪代码", ["写出分治算法解决四柱汉诺塔问题的伪代码。", "写出分治算法解决四柱汉诺塔问题的伪代码。"]], "Tag": "算法设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;望采纳&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def getmid(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;, b):\n    k &amp;#61; int(&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;) / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n    &lt;span class=\"hljs-comment\"&gt;#print(k, a, b)&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; b[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]) / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k] &amp;#61;&amp;#61; b[k]:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k]\n    elif &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k] &amp;lt; b[k]:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; getmid(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:], b[:k])\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; getmid(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[:k], b[k:])\n\n\n\nlsta &amp;#61; [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;]\nlstb &amp;#61; [&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;]\n\nprint(getmid(lsta,lstb))\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "分治算法", "Question": ["用python完成分治策略", ["设A 和B都是从小到大已经排好序的几个不等的整数构成的数组，如果把 A 与B合并后的数组记作C,设计一个算法找出C的中位数python实现而且是分治策略"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答引用chatgpt:&lt;br /&gt;区间覆盖问题&lt;br /&gt;问题描述&amp;#xff1a;给定一些区间&amp;#xff0c;求最少需要多少个点才能覆盖所有的区间。&lt;/p&gt;\n&lt;p&gt;分治算法伪代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;cover(intervals):\n    if intervals &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;empty&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    find the &lt;span class=\"hljs-type\"&gt;interval&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;with&lt;/span&gt; the smallest &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt; point, &lt;span class=\"hljs-keyword\"&gt;called&lt;/span&gt; it &amp;#34;min_interval&amp;#34;\n    remove &amp;#34;min_interval&amp;#34; &lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; &amp;#34;intervals&amp;#34;\n    remove &lt;span class=\"hljs-keyword\"&gt;all&lt;/span&gt; intervals that overlap &lt;span class=\"hljs-keyword\"&gt;with&lt;/span&gt; &amp;#34;min_interval&amp;#34; &lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; &amp;#34;intervals&amp;#34;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt; cover(intervals)\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该算法的思路是选择一个区间&amp;#xff0c;找到所有与之重叠的区间&amp;#xff0c;然后递归地处理这些重叠的区间。由于每个点只会被算一次&amp;#xff0c;因此可以保证最后的点的数量是最小的。&lt;/p&gt;\n&lt;p&gt;2比赛日程安排问题&lt;br /&gt;问题描述&amp;#xff1a;有n个队伍要进行比赛&amp;#xff0c;每个队伍需要和其他队伍比赛一次&amp;#xff0c;求如何安排比赛&amp;#xff0c;使得n天内可以全部比完。&lt;/p&gt;\n&lt;p&gt;分治算法伪代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nschedule(n):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; [[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]]\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n        first_half &amp;#61; schedule(n/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n        second_half &amp;#61; schedule(n - n/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;add&lt;/span&gt; n/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;to&lt;/span&gt; all entries &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;the&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;second&lt;/span&gt; half\n        reverse &lt;span class=\"hljs-keyword\"&gt;the&lt;/span&gt; rows &lt;span class=\"hljs-keyword\"&gt;of&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;the&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;second&lt;/span&gt; half\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; first_half &amp;#43; second_half\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该算法的思路是将所有队伍分为两部分&amp;#xff0c;分别让这两部分内的队伍进行比赛&amp;#xff0c;然后将第二部分内的所有队伍编号加上n/2&amp;#xff0c;再将其倒序排列&amp;#xff0c;最后将这两部分的比赛安排合并即可。由于每个队伍只需要比一次&amp;#xff0c;因此可以保证最后的比赛日程安排是正确的。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["写出分治算法解决区间覆盖问题或比赛日程安排问题的伪代码", ["写出分治算法解决区间覆盖问题或比赛日程安排问题的伪代码。", "请尽量详细一点。"]], "Tag": "算法设计"}
{"Answer": "代码出错了\r\n应该是\r\nwhile(i &lt;= mid)\r\ntemp[k++] = a[i++];", "Konwledge_Point": "分治算法", "Question": ["分治算法：二分归并排序的合并中一段代码有疑问", ["\n上图是数据", "\n下图是合并代码", "\n求大神帮帮忙！！！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;分治算法不算基础算法吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["关于#python#的问题：Python中分治算法的思想在很多基础算法上都有所体现吗", ["Python编程中分治算法的思想在很多基础算法上都有所体现吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个 left  right 不相等不就死循环了么&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/734377907566185.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;第一次循环进去&lt;br /&gt;left 0 right 1 ,然后  (left&amp;#43;right)/2-1)   &amp;#61;&amp;#xff08;0&amp;#43;1&amp;#xff09;/2-1 结果-1 &amp;#xff0c;第二次进去 left 0 right -1  直接死循环&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["java 算法 合并数组", ["public ", "class", " PartitionTest {", "//分治算法 合并排序代码", "\n\n    ", "private", " void merge", "Sort(", "int", " ", "a", "[], ", "int", " ", "left", ",", "int", " ", "right", ")", "{\n        ", "if", "(left", " == ", "right)\n        {\n            return;\n        }\n        merge", "Sort(", "a", ",", "left", ",(", "left", "+", "right", ")", "/", "2", "-", "1", ");\n        merge", "Sort(", "a", ",(", "left", "+", "right", ")", "/", "2", "+", "1", ",right-", "1", " );\n        merge(a,left,right);\n    }\n    ", "private", " void merge(", "int", " a", "[]", ", ", "int", " left, ", "int", " right) {\n        ", "int", " l = left, mid = (left + right)", " / ", "2", ", i = ", "0", ";\n        ", "int", " k = mid + ", "1", ";\n        ", "int", "[]", " arr = ", "new", " ", "int", "[", "left", " - ", "right", " + ", "1", "]", ";", "//存放排好序的数组", "\n        ", "while", " (l <= mid", " && ", "k <= right) {\n            ", "if", " (a", "[", "l", "]", " > a", "[", "k", "]", ") {\n                arr", "[", "i", "]", " = a", "[", "k", "]", ";\n                i++;\n                k++;\n            } ", "else", " {\n                arr", "[", "i", "]", " = a", "[", "l", "]", ";\n                i++;\n                l++;\n            }\n        }\n        ", "if", " (l > mid) {\n            ", "for", " (; k <= right; i++, k++) {\n                arr", "[", "i", "]", " = a", "[", "k", "]", ";\n            }\n        } ", "else", " {\n            ", "for", " (; l <= mid; i++, l++) {\n                arr", "[", "i", "]", " = a", "[", "l", "]", ";\n            }\n        }\n        ", "for", " (", "int", " j = ", "0", "; j < left - right + ", "1", " ; j++) {\n            a", "[", "left", "++", "]", " = arr", "[", "j", "]", ";\n        }\n    }\n\n    public static void main(String", "[]", " args) {\n        ", "int", "[]", " a = {", "2", ",", "0", "};\n        ", "new", " ", "PartitionTest()", ".merge", "Sort(", "a", ",0,", "a", ".", "length", "-1)", ";\n        ", "for", " (", "int", " i = ", "0", "; i < a.length; i++) {\n            ", "System", ".", "out.println(a", "[", "i", "]", ");\n        }\n    }\n}\n\n", "\n", "为什么爆栈了,同样类似的算法在c++ 我没有爆 不明白啊 这里的算法可能有点问题"]], "Tag": "算法设计"}
{"Answer": "你好，是closest()函数point *SR 指针越界导致程序崩溃的。做如下修改可以解决程序崩溃问题\r\npoint *SR = new point[(high - low) / 2]; 改为point *SR = new point[(high - low)+1]; OK", "Konwledge_Point": "分治算法", "Question": ["C++：基于分治思想实现二维平面最近点对算法，n>3时程序崩溃", ["感觉问题出在快速排序的两个函数上，麻烦各位大佬看一下哪里出了问题。", "\n\n", "#include \"stdafx.h\"\n#include <vector>\n#include <math.h>\n#include <time.h>\n#include<algorithm>\n#include <iostream>\nusing namespace std;\n\nstruct point//存储点坐标的结构体\n{\n    int index;\n    float x,y;\n};\n\nvoid Same(int n,int k,point X[])//查找相同的坐标\n{\n    for(int i=0;i<n;i++)\n    {\n        if(X[k].x==X[i].x&&X[k].y==X[i].y)\n        {\n            X[k].x=(float)(rand()%10001);\n            X[k].y=(float)(rand()%10001);\n            Same(n,k,X);\n        }\n    }\n}\n\n\n\nvoid QuickSort1(point arr[], int left, int right)//快速排序\n{\nif (left<right)\n    {   \n        int i=left,j=right;\n        point a; \n        a=arr[left];\n        while (i<j)\n        {\n            while(i<j&&arr[j].x>=a.x) // 从右向左找第一个小于x的数\n                j--; \n            if(i<j)\n                arr[i++].x=arr[j].x;\n            while(i<j&&arr[i].x<a.x) // 从左向右找第一个大于等于x的数\n                i++; \n            if(i<j)\n                arr[j--].x=arr[i].x;\n        }\n        arr[i].x=a.x;\n        QuickSort1(arr,left,i-1); // 递归调用\n        QuickSort1(arr,i+1,right);\n    }\n\n}\n\nvoid QuickSort2(point arr[], int left, int right)//快速排序\n{\nif (left<right)\n    {   \n        int i=left,j=right;\n        point a; \n        a=arr[left];\n        while (i<j)\n        {\n            while(i<j&&arr[j].y>=a.y) // 从右向左找第一个小于x的数\n                j--; \n            if(i<j)\n                arr[i++].y=arr[j].y;\n            while(i<j&&arr[i].y<a.y) // 从左向右找第一个大于等于x的数\n                i++; \n            if(i<j)\n                arr[j--].y=arr[i].y;\n        }\n        arr[i].y=a.y;\n        QuickSort2(arr,left,i-1); // 递归调用\n        QuickSort2(arr,i+1,right);\n    }\n\n}\n\nfloat Distance(point a, point b)//求两点之间距离   !不能以distance命名，与函数模板重名，xutility文件会报错\n{\n    float x=a.x-b.x;\n    float y=a.y-b.y;\n    return sqrt(x*x+y*y);\n}\n\nvoid closest(point X[], point Y[],int low,int high,point &a,point &b,float &min)//求最近点对及其距离，设置ab的目的是输出最近点对的坐标\n{\n    int i,j,k,m;\n    point al,bl,ar,br;\n    float dl,dr;\n    if((high-low)==1) // n=2直接计算两个点之间的距离\n    {   \n        a=X[low];\n        b=X[high];\n        min=Distance(X[low], X[high]);\n    }\n    else\n    {  \n        if((high-low)==2)  //    当n=3时直接计算\n        {                        \n            dl = Distance(X[low], X[low+1]);                       \n            dr = Distance(X[low], X[low+2]);                      \n            min = Distance(X[low+1], X[low+2]);                       \n            if((dl<=dr)&&(dl<=min))\n            {                    \n                a = X[low], b = X[low+1], min = dl;              \n            }\n            else\n            {\n                if(dr<=min)\n                {\n                    a=X[low];\n                    b=X[low+2]; \n                    min=dr;\n                }\n                else\n                {\n                    a=X[low+1];\n                    b=X[low+2];             \n                }                      \n            }                \n        }\n        else //        当n>3时进行分治\n        {                  \n            point *SL = new point[(high-low)/2+1];             \n            point *SR = new point[(high-low)/2];      \n            m = (high-low)/2 + low;    //       把x数组以m为界划分为两半             \n            j = k = 0;            \n            for(i=0; i<=high-low; i++)\n            {                       \n                if(Y[i].index<=m)\n                {                                \n                    SL[j++] = Y[i];   //       收集左边子集中的最近点对                             \n                }\n                else\n                {                      \n                    SR[k++] = Y[i];   //       收集右边子集中的最近点对                           \n                }                    \n            }\n                        closest(X,SL,low, m, al, bl, dl);       //     计算左边子集的最近点对\n                        closest(X,SR,m+1, high, ar, br, dr);//  计算右边子集的最近点对\n                        if(dl<dr)\n                        {                              //    组合步得到左右子集中点的最短距离d\n                                a = al, b = bl, min = dl;\n                        }\n                        else\n                        {\n                                a = ar, b = br, min = dr;\n                        }\n                        point *Z = new point[high-low+1];\n                        k = 0;\n                        for( i=0; i<=high -low; i++) // 收集距离中线距离小于d的元素，保存到数组Z（因Y数组按y坐标递增排序，Z数组也一样）\n                        {       \n                            if(fabs(X[m].x - Y[i].x)<min)//abs求整数绝对值\n                            {  \n                                Z[k].x = Y[i].x, Z[k++].y = Y[i].y;\n\n                            }\n                        }\n                        for( i=0; i<k; i++)\n                        {\n                                for( j=i+1; (j<k)&&(Z[j].y-Z[i].y<min); j++){     //   若前后两点y轴的距离超过d则不可能使距离小于d，退出\n                                        dl = Distance(Z[i], Z[j]);    //        计算前后两点的距离\n                                        if(dl<min){                                   //     若小于min，则更新\n                                                a = Z[i], b = Z[j], min = dl;\n                                        }\n                                }\n                        }\n\n                        delete SL;\n                        delete SR;\n                        delete Z;\n                }\n        }\n}\n\nvoid closest_pair(point X[], int n, point &a, point &b, float &min){\n        if(n<2){        //      当点集个数小于2时不存在最近点对\n                min= 0;\n        }else{\n               QuickSort1(X,0,n-1);      //        对x数组进行递增排序\n               point *Y = new point[n];    //  初始化辅助点数组Y\n                for( int i = 0 ; i < n ;i ++){\n                        Y[i].index = i;\n                        Y[i].x = X[i].x;\n                        Y[i].y = X[i].y;\n                }\n                QuickSort2(Y,0,n-1);      //        对y数组进行递增排序\n                closest(X,Y,0,n-1,a,b,min);              //     求亲密点对\n                min = sqrt(min);                //  将得到的d开平方才是两点间真正的距离\n                delete Y;\n        }\n}\n\nvoid main()\n{ \n    int n;\n    cout<<\"请输入点个数：\"<<endl;\n    cin>>n;\n    point *X=new point[n];\n     srand((int)time(0));\n     for(int i=0;i<n;i++)\n     {\n         X[i].x=(float)(rand()%10001);\n         X[i].y=(float)(rand()%10001);\n     }\n     //for(int j=0;j<n;j++)\n      //  Same(n,j,X);\n     point a,b;\n     float min;\n     closest_pair(X,n,a,b,min);\n     if(n>=2)\n     {\n          printf(\"最近点对为：(%.0f,%.0f),(%.0f,%.0f) \\n两点距离为：%.4f\\n\", a.x, a.y, b.x, b.y, min);\n      }\n     else{\n                printf(\"不存在最近点对！\\n\");\n        }\n\n}\n\n\n"]], "Tag": "算法设计"}
{"Answer": "程序质量的高低一般看程序的运行速度、占用存储的大小，程序是否清晰，容易阅读理解。", "Konwledge_Point": "分治算法", "Question": ["高分悬赏：Java语言中哪些排序算法体现了分治的思想，哪些体现了递归的思想？具体说明", ["高分悬赏：Java语言中哪些排序算法体现了分治的思想，哪些体现了递归的思想？具体说明"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;必要性谈不上&amp;#xff0c;但有些信息可以提供给你参考。算法分为数据结构算法和数学算法&amp;#xff0c;其中&amp;#xff0c;使用数据结构的算法多用于数据的存储和其它的编程问题&amp;#xff0c;而数学算法则多用于人工智能。至于算法题&amp;#xff0c;不清楚你说的是哪一类&amp;#xff0c;如果是大学生的ACM竞赛题、中学生的NOI或NOIP竞赛题的话&amp;#xff0c;大多指的是数学算法类的&amp;#xff0c;数据结构等程序上的算法用的较少&amp;#xff0c;而且&amp;#xff0c;大学数学不是不刷这类算法题的理由&amp;#xff0c;毕竟中学都有集训和比赛的。总而言之&amp;#xff0c;必要性谈不上&amp;#xff0c;至于需不需要练&amp;#xff0c;则看你自己。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["大一有必要学算法刷算法题吗", ["  大一计科专业，学校大二都会讲数据结构算法啥的，现在学了c，平时不知道要干点啥，如果说刷题的话，都是算法题，什么二叉树分治递归的需要用到这些知识，现在没有学去写阻力会很大，每写一题都需要去看相关知识，但这样即使写出来题相关知识也没法掌握住，也只能知道的很浅显也不系统，而且我记得还需要用到其他数学课的知识，现在我们只学了高数线代。可能写一个月也学不了多少，大二会专门去深入讲数据结构什么的，比自己学会好很多。我看我身边有人也在刷洛谷，但是感觉也都是写的磕磕绊绊，为了写出来而写。", "  所以想知道大一有必要学算法写算法题，或者是我上面说的有不对的地方？"]], "Tag": "算法设计"}
{"Answer": "你的目的是找最大点，所以第3步应该是找右边Y值最大的和X值最大的。", "Konwledge_Point": "分治算法", "Question": ["类似于最近点对问题，但是有点不一样，麻烦看下我的思路有没有问题 ", ["问题：（最近点对问题）设平面上有两个不同的点p1=（x1，y1）和p2（x2，y2），若x1>x2,y1>y2,则称p1支配p2,。", "\n给定平面上n个点的集合P={p1，p2，...,pn},若点pi属于P，不被平面上任意点支配，则称pi为P的最大点。", "\n试使用分治法设计一个O（nlogn）的算法计算P中的所有最大点。", "\n\n", "分治法解决最近点对问题思路：", "\n用分治法解决最近点对问题，就是将一个问题分解两个子问题，然后递归处理子问题，然后合并。可能两个点在每个子问题中，也可能两个点分别在两个子问题中，就这两种情况。则基本过程为：找一条中垂线m(坐位S集合x坐标的中位数)把n个元素分成左右两部分元素，然后分别求得两边的最短距离1d,2d，然后取两者中的最小者记为d，在中线两边分别取d的距离，记录该距离范围内点的个数，中线左边有L个元素，右边有R个元素，分别将两边的点按y坐标升序排列，在左边集合中每一个点，找右边集合的点，找到与之距离小于d的点，更新最短距离，直到循环结束，即可求出最短距离。", "\n\n", "以上是解决找距离最近的点的问题", "\n\n", "解决最开始那个问题，我的思路是：", "\n1.找一条中垂线m(坐位S集合x坐标的中位数)把n个元素分成左右两部分元素。", "\n2.既然已经有了坐标，那么这时中垂线右边的点的x坐标肯定要比左边的大，这时就只需要在中垂线的右边找就可以了", "\n3.取得右边最大距离为d", "\n\n", "想到这里不知道接下来该怎么办了", "\n我是初学者，可能有些啰嗦，问题又不是很难，麻烦大家帮我解决一下，谢谢"]], "Tag": "算法设计"}
{"Answer": "```\r\n #include &lt;stdio.h&gt;\r\n\r\nvoid swap(int a[], int i, int j)\r\n{\r\n    // 交换数组a中元素i与元素j的值\r\n    int tmp;\r\n    tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n}\r\n\r\nint partition(int a[], int lo, int hi)\r\n{\r\n    int i = lo-1, pivot = a[lo];\r\n    swap(a, lo, hi);\r\n    while(lo&lt;hi)\r\n    {\r\n        // 循环开始的时候i指向的是小于pivot的最后的一个位置\r\n        if(a[lo] &lt; pivot)\r\n        {\r\n            i ++;\r\n            swap(a, i, lo);\r\n        }\r\n        lo ++;\r\n    }\r\n    i ++;\r\n    swap(a, i, hi);\r\n    return i;\r\n}\r\n\r\nint find(int a[], int left, int right, int k)\r\n{\r\n    int index;\r\n    index = partition(a, left, right);\r\n    if(index == k)\r\n        return a[index];\r\n    else if(index &lt; k)\r\n        return find(a, index+1, right, k);\r\n    else\r\n        return find(a, left, right-1, k);\r\n}\r\n\r\nint main()\r\n{\r\n    int a[10000];\r\n    int n, k, i;\r\n    scanf(\"%d\", &amp;n);\r\n    scanf(\"%d\", &amp;k);\r\n    for(i=0; i&lt;n; i++)\r\n        scanf(\"%d\", &amp;a[i]);\r\n    printf(\"%d\\n\", find(a, 0, n-1, k-1));\r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": ["C++语言编程 急急！！！ 用分治策略", ["设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。", "\n\n", "提示：函数int partition(int a[],int left,int right)的功能是根据a[left]~a[right]中的某个元素x（如a[left])对a[left]~a[right]进行划分，划分后的x所在位置的左段全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。", "\n\n", "输入格式:", "\n输入有两行：", "\n\n", "第一行是n和k，0<k<=n<=10000", "\n\n", "第二行是n个整数", "\n\n", "输出格式:", "\n输出第k小的数", "\n\n", "输入样例:", "\n在这里给出一组输入。例如：", "\n\n", "10 4", "\n2 8 9 0 1 3 6 7 8 2", "\n输出样例:", "\n在这里给出相应的输出。例如：", "\n\n", "2"]], "Tag": "算法设计"}
{"Answer": "在分治求和过程中，遇到更大的和值时，更新一下当前子数组下标就可以了\r\n\r\n\r\n```\r\n \r\npublic class MaxSumSubarray {\r\n\r\n\tprivate static int binarySearch(int a[], int left, int right, MaxSumSubarray result) {\r\n\t\tint leftSum, rightSum, crossSum;\r\n\t\tif (left == right) {\r\n\t\t\tif (a[left] &gt; result.sum) {\r\n\t\t\t\tresult.sum = a[left];\r\n\t\t\t\tresult.begin = left;\r\n\t\t\t\tresult.end = right;\r\n\t\t\t}\r\n\t\t\treturn a[left];\r\n\t\t} else {\r\n\t\t\tint mid = (left + right) / 2;\r\n\t\t\tleftSum = binarySearch(a, left, mid, result);\r\n\t\t\trightSum = binarySearch(a, mid + 1, right, result);\r\n\t\t\tcrossSum = crossBinarySearch(a, left, mid, right, result);\r\n\t\t\tif (leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum) {\r\n\t\t\t\tif (leftSum &gt; result.sum) {\r\n\t\t\t\t\tresult.sum = leftSum;\r\n\t\t\t\t\tresult.begin = left;\r\n\t\t\t\t\tresult.end = mid;\r\n\t\t\t\t}\r\n\t\t\t\treturn leftSum;\r\n\t\t\t} else if (rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum) {\r\n\t\t\t\tif (rightSum &gt; result.sum) {\r\n\t\t\t\t\tresult.sum = rightSum;\r\n\t\t\t\t\tresult.begin = mid;\r\n\t\t\t\t\tresult.end = right;\r\n\t\t\t\t}\r\n\t\t\t\treturn rightSum;\r\n\t\t\t} else {\r\n\t\t\t\treturn crossSum;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MaxSumSubarray binarySearch(int[] a) {\r\n\t\tif (a == null || a.length == 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tMaxSumSubarray result = new MaxSumSubarray();\r\n\t\tresult.sum = binarySearch(a, 0, a.length - 1, result);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprivate static int crossBinarySearch(int a[], int left, int mid, int right, MaxSumSubarray result) {\r\n\t\tint leftSum = 0;\r\n\t\tint max_left_sum = 0;\r\n\t\tint begin = mid, end = mid + 1;\r\n\t\tfor (int i = mid; i &gt;= left; i--) {\r\n\t\t\tleftSum += a[i];\r\n\t\t\tif (leftSum &gt; max_left_sum) {\r\n\t\t\t\tbegin = i;\r\n\t\t\t\tmax_left_sum = leftSum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint rightSum = 0;\r\n\t\tint max_right_sum = 0;\r\n\t\tfor (int i = mid + 1; i &lt;= right; i++) {\r\n\t\t\trightSum += a[i];\r\n\t\t\tif (rightSum &gt; max_right_sum) {\r\n\t\t\t\tend = i;\r\n\t\t\t\tmax_right_sum = rightSum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint sum = max_left_sum + max_right_sum;\r\n\t\tif (sum &gt; result.sum) {\r\n\t\t\tresult.sum = sum;\r\n\t\t\tresult.begin = begin;\r\n\t\t\tresult.end = end;\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tprivate int begin;\r\n\r\n\tprivate int end;\r\n\r\n\tprivate int sum;\r\n\r\n\tpublic MaxSumSubarray() {\r\n\t\tsuper();\r\n\t\tsum = Integer.MIN_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the begin\r\n\t */\r\n\tpublic int getBegin() {\r\n\t\treturn begin;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the end\r\n\t */\r\n\tpublic int getEnd() {\r\n\t\treturn end;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the sum\r\n\t */\r\n\tpublic int getSum() {\r\n\t\treturn sum;\r\n\t}\r\n}\r\n```\r\n\r\n我这里用java语言实现，如果用其他语言，可以将MaxSumSubarray用一个整形数组替换，\r\n\r\n\tprivate int begin;\r\n\r\n\tprivate int end;\r\n\r\n\tprivate int sum;\r\n\t\r\n\t这三个字段就用一个int[3]替换", "Konwledge_Point": "分治算法", "Question": ["算法设计 最大子数组（序列）", ["采用分治法，有没有简单的方法标记最大子序列的开始和结尾点。", "\n即为可以输出子序列各个元素"]], "Tag": "算法设计"}
{"Answer": "```\r\n 参考下面的程序，输入输出就你自己修改了，不然等于帮你做作业了。\r\n\r\n#include&lt;iostream&gt;  \r\n#include&lt;stdio.h&gt;  \r\nusing namespace std;  \r\n  \r\nint Partition (int *L, int low, int high)  \r\n{  \r\n    int temp = L[low];  \r\n    int pt   = L[low]; //哨兵  \r\n    while (low != high)  \r\n    {  \r\n        while (low &lt; high &amp;&amp; L[high] &gt;= pt)  \r\n            high--;  \r\n        L[low] = L[high];         \r\n          \r\n        while (low &lt; high &amp;&amp; L[low] &lt;= pt)  \r\n            low++;  \r\n        L[high] = L[low];  \r\n    }     \r\n    L[low] = temp;  \r\n    return low;  \r\n}  \r\n  \r\nvoid QSort (int *L, int low, int high)  //快速排序  \r\n{  \r\n    int pl;  \r\n    if (low &lt; high)  \r\n    {  \r\n        pl = Partition (L,low,high);  \r\n        QSort (L, low,  pl-1);  \r\n        QSort (L, pl+1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid findk(int k,int *L,int low,int high)  \r\n{  \r\n    int temp;  \r\n    temp=Partition(L,low,high);  \r\n    if(temp==k-1)  \r\n    {  \r\n        cout&lt;&lt;\"第\"&lt;&lt;temp+1&lt;&lt;\"大的数是:\"&lt;&lt;L[temp]&lt;&lt;endl;  \r\n    }  \r\n    else if(temp&gt;k-1)  \r\n        findk(k,L,low,temp-1);  \r\n    else  \r\n        findk(k,L,temp+1,high);  \r\n}  \r\n  \r\nint main()  \r\n{  \r\n    int a[10]={15,25,9,48,36,100,58,99,126,5},i,j,k;  \r\n    cout&lt;&lt;\"排序前：\"&lt;&lt;endl;  \r\n    for(i=0;i&lt;10;i++){  \r\n        cout&lt;&lt;a[i]&lt;&lt;\" \";  \r\n    }  \r\n    cout&lt;&lt;endl;  \r\n    cout&lt;&lt;\"请输入你要查找第k大的数：\"&lt;&lt;endl;  \r\n    cin&gt;&gt;k;  \r\n    findk(k,a,0,9); //查找第k大的数不需要全部排序  \r\n  \r\n    QSort(a,0,9);     \r\n    cout&lt;&lt;\"排序后：\"&lt;&lt;endl;  \r\n    for(i=0;i&lt;10;i++){  \r\n        cout&lt;&lt;a[i]&lt;&lt;\" \";  \r\n    }  \r\n    cout&lt;&lt;endl;  \r\n    system(\"Pause\");  \r\n    return 0;  \r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": ["C++语言编程 急急！！！用分治策略", ["设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。", "\n\n", "提示：函数int partition(int a[],int left,int right)的功能是根据a[left]~a[right]中的某个元素x（如a[left])对a[left]~a[right]进行划分，划分后的x所在位置的左段全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。", "\n\n", "输入格式:", "\n输入有两行：", "\n\n", "第一行是n和k，0<k<=n<=10000", "\n\n", "第二行是n个整数", "\n\n", "输出格式:", "\n输出第k小的数", "\n\n", "输入样例:", "\n在这里给出一组输入。例如：", "\n\n", "10 4", "\n2 8 9 0 1 3 6 7 8 2", "\n输出样例:", "\n在这里给出相应的输出。例如：", "\n\n", "2"]], "Tag": "算法设计"}
{"Answer": "http://wenku.baidu.com/link?url=P10nirc7m3tpWtwvsF-Q_Su0RAaLVgd-pYbL29UAqm3IUVwf_6d-ARR9XLyuxaSkafTM06HHFjbC3xwflpztSUfQnzNq1wdPxJ_QWEkAOS_", "Konwledge_Point": "分治算法", "Question": ["解高次方程，除二分法", ["求解一个高次方程除了二分法，还有什么好的方法。求解一个高次方程除了二分法，还有什么好的方法。求解一个高次方程除了二分法，还有什么好的方法。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;return (maxSubSum(nums, 0, numsSize-1)试试&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["力扣53:最大子序和（最大子段和C语言分治）", ["小白求指点，为什么会报错", "\n", "执行结果： 执行出错 ================================================================= ==42==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x604000000034 at pc 0x5643b9ff8e04 bp 0x7ffd2cd0ab60 sp 0x7ffd2cd0ab50 READ of size 4 at 0x604000000034 thread T0 #5 0x7f15c13530b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2) 0x604000000034 is located 0 bytes to the right of 36-byte region [0x604000000010,0x604000000034) allocated by thread T0 here: #0 0x7f15c1f98bc8 in malloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10dbc8) #3 0x7f15c13530b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2) Shadow bytes around the buggy address: 0x0c087fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =>0x0c087fff8000: fa fa 00 00 00 00[04]fa fa fa fa fa fa fa fa fa 0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==42==ABORTING", "\n", "代码", "\n", "\n", "int", " maxSubArray(", "int", " nums[], ", "int", " numsSize){\n    return (maxSubSum(nums, ", "0", ", numsSize));\n}\n\n", "int", " maxSubSum(", "int", " *nums, ", "int", " ", "left", ", ", "int", " ", "right", "){\n    ", "int", "  ", "sum", " = ", "0", ", left_sum = ", "0", ", right_sum = ", "0", ", allmax = ", "0", ";\n    ", "if", " (", "left", " == ", "right", "){\n        ", "if", " (nums[", "left", "] > ", "0", "){\n            return nums[", "left", "];\n        }\n        else{\n            return ", "0", ";\n        }\n    }\n\n    ", "int", " ", "mid", " = (", "left", " + ", "right", ") / ", "2", ";\n    left_sum = maxSubSum(nums, ", "left", ", ", "mid", ");\n    right_sum = maxSubSum(nums, ", "mid", " + ", "1", ", ", "right", ");\n    for (", "int", " i = ", "mid", "; i >= ", "left", "; i--){\n        ", "sum", " += nums[i];\n        ", "if", " (allmax < ", "sum", "){\n            allmax = ", "sum", ";\n        }\n    }\n    ", "sum", " = allmax;\n    for (", "int", " i = ", "mid", " + ", "1", "; i <= ", "right", "; i++){\n        ", "sum", " += nums[i];\n        ", "if", " (allmax < ", "sum", "){\n            allmax = ", "sum", ";\n        }\n    }\n    ", "if", " (allmax < left_sum && right_sum < left_sum){\n        return left_sum;\n    }\n    ", "if", " (allmax < right_sum){\n        return right_sum;\n    }\n    return allmax;\n}\n\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 100000000&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[N]; \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;quickselect&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;s,j&amp;#61;t;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tmp;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;lt;t)\n    {\n        tmp&amp;#61;a[s];\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i!&amp;#61;j)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(j&amp;gt;i&amp;amp;&amp;amp;a[j]&amp;lt;&amp;#61;tmp)\n            {\n                j--;\n            }\n            a[i]&amp;#61;a[j];\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i&amp;lt;j&amp;amp;&amp;amp;a[i]&amp;gt;&amp;#61;tmp)\n            {\n                i&amp;#43;&amp;#43;;\n            }\n            a[j]&amp;#61;a[i];\n        }\n        a[i]&amp;#61;tmp;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;&amp;#61;&amp;#61;i) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a[i];\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;&amp;lt;i) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;quickselect&lt;/span&gt;(a,s,i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,k);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;quickselect&lt;/span&gt;(a,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,t,k);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;#61;&amp;#61;t&amp;amp;&amp;amp;s&amp;#61;&amp;#61;k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a[k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;];\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k;\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    cin&amp;gt;&amp;gt;a[i];\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;quickselect&lt;/span&gt;(a,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,k);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "分治算法", "Question": ["分治法求第K大的数有一个数据过不了？", ["问题遇到的现象和发生背景", "\n", " 第 k 大的整数**", "分数 25", "作者 李祥", "单位 湖北经济学院", "求 n 个整数中第 k(1≤k≤n) 大的整数。", "\n", "输入格式", "n 和 k", "n 个整数", "\n", "输出格式", "第 k 大的整数", "\n", "输入样例", "10 3", "2 5 -1 9 25 0 12 4 -7 12", "输出样例", "12", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "quickselect", "(", "int", " a[],", "int", " s,", "int", " t,", "int", " k)", "\n", "{\n    ", "int", " i=s,j=t;\n    ", "int", " tmp;\n    ", "if", "(s<t)\n    {\n        tmp=a[s];\n        ", "while", "(i!=j)\n        {\n            ", "while", "(j>i&&a[j]>=tmp) j--;\n            a[i]=a[j];\n            ", "while", "(i<j&&a[i]<=tmp) i++;\n            a[j]=a[i]; \n        }\n        a[i]=tmp;\n        ", "if", "(k", "-1", "==i) ", "return", " a[i];\n        ", "else", " ", "if", "(k", "-1", "<i) ", "return", " ", "quickselect", "(a,s,i", "-1", ",k);\n        ", "else", " ", "return", " ", "quickselect", "(a,i+", "1", ",t,k);\n    }\n    ", "else", " ", "if", "(s==t&&s==k", "-1", ") ", "return", " a[k", "-1", "];\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " n,k,e;\n    cin>>n>>k;\n    ", "int", " a[", "1000001", "];\n    ", "for", "(", "int", " i=", "0", ";i<n;i++)\n    {\n        cin>>a[i];\n    }  \n    e=", "quickselect", "(a,", "0", ",n", "-1", ",n-k+", "1", ");\n    cout<<e<<endl;\n    ", "return", " ", "0", ";\n} \n\n", "\n", "运行结果及报错内容", "\n"]], "Tag": "算法设计"}
{"Answer": "合并排序比较适合多核加速，jdk8的新Arrays.parallelSort API就是这么实现的，quick sort从理论上来说也可以利用多核加速，不过由于其对于不同数据的split有可能出现线性的特点，理论上不是能保证得到加速。\r\n另外，对于多核加速，期望值不要太高，基于我们对Arrays.parallelSort的测试，4核cpu最多能达到3.2倍的速度，而16核只能达到11.8倍。主要是由于现阶段的split之后还有merge。", "Konwledge_Point": "分治算法", "Question": ["快速排序和合并排序是否可以利用多核进一步加速", ["我在研究快速排序和合并排序的时候突然想到这两个算法是否可以利用多核来进一步加快运行效率~", "\n因为它们是采用了分治法的思想，分解成多个互相独立的子排序，与其他需要顺序执行的排序算法不同~", "\n没经过系统学习~正在看算法导论~勿喷~"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这不是分治法吧&amp;#xff0c;而且逻辑也有问题。。。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["请问各位C语言，分治法找出数组中第 k 个小的元素，我错在哪儿，该怎么改呢。能够输出，但是输出结果错误", ["\n#", "include", " <stdio.h>\nvoid mp", "_sort(", "int", " ", "*", "c", ",", "int", " ", "n", ",", "int", " ", "p", ",", "int", " ", "q", ")", ";\n", "/**********  Begin  **********/", "\n", "int", " main", "()", "\n{\n    ", "int", " zd_num,i,num;\n    scanf(", "\"%d %d\"", ",&num,&zd_num);\n    ", "int", " a", "[", "num", "]", ";\n    ", "for", "(i=", "0", ";i<num;i++)\n    {\n        scanf(", "\"%d\"", ",&a", "[", "i", "]", ");\n    }\n    mp", "_sort(", "a", ",", "num", "/", "2,0,", "num", "/", "2-1)", ";\n    mp", "_sort(", "a", ",", "num", "/", "2,", "num", "/", "2,", "num", "-1)", ";\n    ", "if", "(a", "[", "num", "/", "2", "-", "1", "]", "<a", "[", "num", "/", "2", "]", ")\n    {\n        printf(", "\"第%d小的元素是%d\"", ",zd_num,a", "[", "zd_num", "-", "1", "]", ");\n    }\n    ", "else", "\n    {\n        mp", "_sort(", "a", ",", "num", ",0,", "num", "-1)", ";\n        printf(", "\"第%d小的元素是%d\"", ",zd_num,a", "[", "zd_num", "-", "1", "]", ");\n    }\n    return ", "0", ";\n}\nvoid mp", "_sort(", "int", " ", "*", "c", ",", "int", " ", "n", ",", "int", " ", "p", ",", "int", " ", "q", ")", "\n{\n    ", "int", " item,k,m;\n    ", "for", "(k=p;k<q;k++)\n    {\n        ", "for", "(m=p+", "1", ";m<=q;m++)\n        {\n            ", "if", "(c", "[", "k", "]", ">c", "[", "m", "]", ")\n            {\n                item=c", "[", "k", "]", ";\n                c", "[", "k", "]", "=c", "[", "m", "]", ";\n                c", "[", "m", "]", "=item;\n            }\n        }\n    }\n}\n", "/**********  End  **********/", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/750727102936198.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/925657102936170.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/382577102936113.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;\n&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#39;&amp;#39;\n先搞搞思路&amp;#xff0c; 写几行伪代码\n\n1、输入n&amp;#xff0c;真币重量a&amp;#xff0c;假币重量b&amp;#xff0c;假币位置m , 约束 b&amp;lt;a\n\n2、初始化 列表 list_n\nlist_n &amp;#61; [a for n in range(n)]    \nlist_n[m-1] &amp;#61; b\n\n3、根据列表长度切列表&amp;#xff0c;比较&amp;#xff0c;如未找到&amp;#xff0c;继续遍历重量小的列表&amp;#xff0c;直到切完。\n&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_result&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;l&lt;/span&gt;):\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;Find! position is: {}, weight is: {}.&amp;#39;&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;format&lt;/span&gt;(l[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],l[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]))\n\nwork_cmd &amp;#61; &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入硬币n&amp;#xff0c;真币重量a&amp;#xff0c;假币重量b&amp;#xff0c;假币位置m , 约束 b&amp;lt;a&amp;#xff1a;\\nn a b m\\t&amp;#34;&lt;/span&gt;)\nwork_num &amp;#61; [&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(x) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; x &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; work_cmd.split(&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;)]\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (work_num[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;lt; work_num[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; (work_num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; (work_num[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;lt;&amp;#61; work_num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]):\n    list_n &amp;#61; [[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,work_num[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]] &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(work_num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])]\n    list_n[work_num[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; work_num[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;硬币列表&amp;#34;&lt;/span&gt;, list_n)\n\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list_n) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        listlen &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list_n)\n        offset1 &amp;#61; listlen // &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;\n        offset2 &amp;#61; offset1\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; listlen % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            offset2 &amp;#61; offset2 &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n        list1 &amp;#61; list_n[:offset1]\n        list2 &amp;#61; list_n[offset2:]\n        sum1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;([n[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; n &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; list1])\n        sum2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;([n[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; n &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; list2])\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;  sum1 &amp;#61;&amp;#61; sum2  :\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; offset1 !&amp;#61; offset2:\n                show_result(list_n[offset1])\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n                &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;Not Find!&amp;#39;&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; sum1 &amp;lt; sum2:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list1)&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n                    show_result(list1[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;\n                list_n &amp;#61; list1\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list2)&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n                    show_result(list2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;\n                list_n &amp;#61; list2\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;约束条件&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;未符合&amp;#xff0c;结束程序。&amp;#39;&lt;/span&gt;)\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "分治算法", "Question": ["想要请教一下这个python问题该怎么解决", ["相关知识", "找假币问题是一个比较简单且典型能够体现计算思维的问题。假设现在有n（n>=2）枚硬币，已知其中一枚为假币，且知道假币的重量是比真币轻的，请思考如何用分治思想解决该问题。", "\n", "算法原理", "本次实验中我们采用二分法解决假币问题。二分法是一个非常典型的分治思想的应用。", "\n", "如果n是偶数，将n个硬币平均分成两份，直接比较这两份硬币的重量，假币在重量较轻的那份硬币中，继续对重量较轻的那一份硬币使用二分法，直到找出假币；", "如果n是奇数，则随意取出一种的一枚硬币，将剩下的n-1枚硬币等分成两份。如果这两份硬币重量相同，则随机取出的那枚硬币即为假币；否则，按照硬币数为偶数是的处理办法继续执行算法。", "\n", "测试输入：", "3（此处省略七个3），2", "预期输出 :", "position is: 7, weight is: 2."]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&amp;#61;换成&amp;#61;&amp;#61;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/058662309266178.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["时间复杂度，求解答，求解答", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<time.h>", "\n\n", "int", " ", "maxIntervalSum_1", "(", "int", " array[],", "int", " len)", "//穷举法，三层循环", "\n", "{\n    ", "int", " max=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<len;i++)\n    {\n        ", "for", "(", "int", " j=i;j<len;j++)\n        {\n            ", "int", " sum=", "0", ";\n            ", "for", "(", "int", " k=i;k<=j;k++)\n            {\n                sum+=array[k];\n            }\n            ", "if", "(sum>max) max=sum;\n        }\n    }\n    ", "return", " max;\n}\n", "int", " ", "maxIntervalSum_2", "(", "int", " array[],", "int", " len)", "//改进穷举法，两层循环", "\n", "{\n    ", "int", " max=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<len;i++)\n    {\n        ", "int", " sum=", "0", ";\n        ", "for", "(", "int", " j=i;j<len;j++)\n        {\n            sum+=array[j];\n        }\n        ", "if", "(sum>max) max=sum;\n    }\n    ", "return", " max;\n}\n", "int", " ", "maxIntervalSum_3", "(", "int", " array[],", "int", " begin,", "int", " end)", "//分治法", "\n", "{\n    ", "int", " mmax=", "0", ";\n    ", "if", "(begin=end) ", "return", " array[begin]>", "0", "?array[begin]:", "0", ";\n    ", "int", " mid=begin+(end-begin)/", "2", ";\n    ", "int", " lmax=", "maxIntervalSum_3", "(array,begin,mid);", "//左半区间最大值", "\n    ", "int", " rmax=", "maxIntervalSum_3", "(array,mid+", "1", ",end);", "//右半区间最大值", "\n    ", "//中间区间最大值", "\n    ", "int", " sum=", "0", ";\n    ", "int", " left_max=", "0", ";\n    ", "for", "(", "int", " i=mid;i>=begin;i--)\n    {\n        sum+=array[i];\n        ", "if", "(sum>left_max) left_max=sum;\n    }\n    sum=", "0", ";\n    ", "int", " right_max=", "0", ";\n    ", "for", "(", "int", " i=mid+", "1", ";i<=end;i++)\n    {\n        sum+=array[i];\n        ", "if", "(sum>right_max) right_max=sum;\n    }\n    mmax=left_max+right_max;\n    ", "int", " max=(lmax>rmax)?(lmax>mmax?lmax:mmax):(rmax>mmax?rmax:mmax);\n    ", "return", " max;\n}\n", "int", " ", "maxIntervalSum_4", "(", "int", " array[],", "int", " len)", "//动态规则", "\n", "{\n    ", "int", " max=", "0", ";\n    ", "int", " sum=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<len;i++)\n    {\n        sum+=array[i];\n        ", "if", "(sum<", "0", ") sum=", "0", ";\n        ", "if", "(sum>max) max=sum;\n    }\n    ", "return", " max;\n}\n\n", "int", " ", "main", "(", "int", " argc,", "char", "* argv[])", "\n", "{\n    ", "char", "* f_name=argv[", "1", "];", "//文件名", "\n    ", "int", " n=", "atoi", "(argv[", "2", "]);", "//字符串转整数", "\n    ", "int", " repeat_time=", "atoi", "(argv[", "3", "]);", "//重复次数", "\n    ", "//读取数据到数组", "\n    FILE *pf;\n    ", "int", "* data=(", "int", "*)", "malloc", "(n*", "sizeof", "(", "int", "));\n    ", "if", "((pf=", "fopen", "(", "\"C:\\\\text_datum.txt\"", ",", "\"r\"", "))==", "NULL", ")\n    {\n        ", "printf", "(", "\"Error\\n\"", ");\n        ", "system", "(", "\"PAUSE\"", ");\n        ", "exit", "(", "1", ");\n    }\n    ", "//读取文件内容到数列", "\n    ", "for", "(", "long", " ", "long", " ", "int", " i=", "0", ";i<n;i++)\n    {\n        ", "fscanf", "(pf,", "\"%d\\n\"", ",&data[i]);\n    }\n    ", "fclose", "(pf);\n\n\n    ", "clock_t", " c_start,c_end;\n    ", "int", " maxValue=", "0", ";\n    c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++)\n    {\n        maxValue=", "maxIntervalSum_1", "(data,n);\n    }\n    c_end=", "clock", "();\n    ", "double", " ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法1,时间复杂度0(n^3),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n\n\n\n    c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++)\n    {\n        maxValue=", "maxIntervalSum_2", "(data,n);\n    }\n    c_end=", "clock", "();\n    ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法2,时间复杂度0(n^2),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n\n\n\n     c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++){\n        maxValue=", "maxIntervalSum_3", "(data,", "0", ",n", "-1", ");\n    }\n    c_end=", "clock", "();\n    ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法3，时间复杂度0(nlogn),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n\n     c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++){\n        maxValue=", "maxIntervalSum_4", "(data,n);\n    }\n    c_end=", "clock", "();\n    ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法4，时间复杂度0(n),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "求告知该怎么办？", "这是文件链接", "https://share.weiyun.com/FF6MWRaQ", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;先把你代码贴好&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/081322698266195.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["时间复杂度，今天就要交了", ["#include <stdio.h>", "#include <stdlib.h>", "#include <time.h>", "\n", "int maxIntervalSum_1(int array[],int len)//穷举法，三层循环", "{", "    int max=0;", "    for(int i=0;i<len;i++)", "    {", "        for(int j=i;j<len;j++)", "        {", "            int sum=0;", "            for(int k=i;k<=j;k++)", "            {", "                sum+=array[k];", "            }", "            if(sum>max) max=sum;", "        }", "    }", "    return max;", "}", "int maxIntervalSum_2(int array[],int len)//改进穷举法，两层循环", "{", "    int max=0;", "    for(int i=0;i<len;i++)", "    {", "        int sum=0;", "        for(int j=i;j<len;j++)", "        {", "            sum+=array[j];", "        }", "        if(sum>max) max=sum;", "    }", "    return max;", "}", "int maxIntervalSum_3(int array[],int begin,int end)//分治法", "{", "    int mmax=0;", "    if(begin=end) return array[begin]>0?array[begin]:0;", "    int mid=begin+(end-begin)/2;", "    int lmax=maxIntervalSum_3(array,begin,mid);//左半区间最大值", "    int rmax=maxIntervalSum_3(array,mid+1,end);//右半区间最大值", "    //中间区间最大值", "    int sum=0;", "    int left_max=0;", "    for(int i=mid;i>=begin;i--)", "    {", "        sum+=array[i];", "        if(sum>left_max) left_max=sum;", "    }", "    sum=0;", "    int right_max=0;", "    for(int i=mid+1;i<=end;i++)", "    {", "        sum+=array[i];", "        if(sum>right_max) right_max=sum;", "    }", "    mmax=left_max+right_max;", "    int max=(lmax>rmax)?(lmax>mmax?lmax:mmax):(rmax>mmax?rmax:mmax);", "    return max;", "}", "int maxIntervalSum_4(int array[],int len)//动态规则", "{", "    int max=0;", "    int sum=0;", "    for(int i=0;i<len;i++)", "    {", "        sum+=array[i];", "        if(sum<0) sum=0;", "        if(sum>max) max=sum;", "    }", "    return max;", "}", "\n", "int main(int argc,char* argv[])", "{", "    char* f_name=argv[1];//文件名", "    int n=atoi(argv[2]);//字符串转整数", "    int repeat_time=atoi(argv[3]);//重复次数", "    //读取数据到数组", "    FILE ", "pf;", "    int", " data=(int*)malloc(n*sizeof(int));", "    if((pf=fopen(\"C:", "\\text_datum.txt\",\"r\"))==NULL)", "    {", "        printf(\"Error\\n\");", "        system(\"PAUSE\");", "        exit(1);", "    }", "    //读取文件内容到数列", "    for(long long int i=0;i<n;i++)", "    {", "        fscanf(pf,\"%d\\n\",&data[i]);", "    }", "    fclose(pf);", "\n", "clock_t c_start,c_end;\nint ", "maxValue", "=0;\n", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++)\n{\n    ", "maxValue", "=maxIntervalSum_1(data,n);\n}\n", "c_end", "=clock();\ndouble ", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法1,时间复杂度0(n^3),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\n\n\n\n", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++)\n{\n    ", "maxValue", "=maxIntervalSum_2(data,n);\n}\n", "c_end", "=clock();\n", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法2,时间复杂度0(n^2),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\n\n\n\n ", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++){\n    ", "maxValue", "=maxIntervalSum_3(data,0,n-1);\n}\n", "c_end", "=clock();\n", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法3，时间复杂度0(nlogn),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\n\n ", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++){\n    ", "maxValue", "=maxIntervalSum_4(data,n);\n}\n", "c_end", "=clock();\n", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法4，时间复杂度0(n),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\nreturn 0;\n", "\n", "}", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;&lt;p&gt;先说你的错误原因把&amp;#xff1a; 第17行和第18行代码中&amp;#xff0c; 你需要传递数组a&amp;#xff0c; 不需要添加[],  数组的传递只用传递数组名&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;其次&amp;#xff1a;    printf(&amp;#34;分治法求出数组元素的和为:%d&amp;#34;,&amp;amp;sum);输出这里不能加&amp;amp;&amp;#xff0c; 这表示取地址&amp;#xff0c; 加了就是输出sum在电脑中的地址而非输出sum所对应的值&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "分治算法", "Question": ["请问各位C语言求一组数据的和，我的代码编译不出来，该怎么修改呢", ["\n", "#", "include", " ", "\"stdio.h\"", "\n", "#", "include", " ", "\"stdlib.h\"", "\n", "/**********  Begin  **********/", "\n", "int", " ", "get_sum", "(", "int", " b[],", "int", " i,", "int", " j)", ";\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " sum1,sum2,sum,i,num;\n    ", "scanf", "(", "\"%d\"", ",&num);\n    ", "printf", "(", "\"\\n\"", ");\n    ", "int", " a[num];\n    ", "for", "(i=", "0", ";i<num;i++)\n    {\n        ", "scanf", "(", "\"%d\"", ",&a[i]);\n        ", "printf", "(", "\"\\n\"", ");\n    }\n    sum1=", "get_sum", "(a[],", "0", ",num/", "2", "-1", ");\n    sum2=", "get_sum", "(a[],num/", "2", ",num", "-1", ");\n    sum=sum1+sum2;\n    ", "printf", "(", "\"分治法求出数组元素的和为:%d\"", ",&sum);\n       ", "return", " ", "0", ";\n}\n", "int", " ", "get_sum", "(", "int", " b[],", "int", " i,", "int", " j)", "\n", "{\n    ", "int", " sum=", "0", ",k;\n    ", "for", "(k=i;k<=j;k++)\n    {\n        sum+=b[k];\n    }\n    ", "return", " sum;\n}\n\n", "/**********  End  **********/", "\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff1a;&lt;br /&gt;我没有写&amp;#xff0c;我是用gpt帮你写了一个,希望能帮到你。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;procedure&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;hanoi&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(n, src, dst, tmp1, tmp2)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;n&lt;/span&gt; &amp;#61;&amp;#61; 1 &lt;span class=\"hljs-title\"&gt;then&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, dst)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;n&lt;/span&gt; &amp;#61;&amp;#61; 2 &lt;span class=\"hljs-title\"&gt;then&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, tmp1)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tmp1, dst)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;hanoi&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(n-2, src, tmp2, tmp1, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, tmp1)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(src, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;move&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tmp1, dst)&lt;/span&gt;\n        &lt;span class=\"hljs-title\"&gt;hanoi&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(n-2, tmp2, dst, tmp1, src)&lt;/span&gt;\n    &lt;span class=\"hljs-title\"&gt;end&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;\n&lt;span class=\"hljs-title\"&gt;end&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;procedure&lt;/span&gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中 n 表示盘子数&amp;#xff0c;src 表示源柱&amp;#xff0c;dst 表示目标柱&amp;#xff0c;tmp1 和 tmp2 分别表示两个临时柱&amp;#xff0c;move 函数表示移动操作。具体来说&amp;#xff0c;当只有一个盘子时&amp;#xff0c;直接从源柱移动到目标柱&amp;#xff1b;当有两个盘子时&amp;#xff0c;先将一个盘子从源柱移动到一个临时柱&amp;#xff0c;然后将剩下的两个盘子从源柱直接移动到目标柱&amp;#xff0c;最后将之前移动到临时柱上的盘子移动到目标柱&amp;#xff1b;当有三个或更多盘子时&amp;#xff0c;先将除最上面两个盘子以外的其他盘子从源柱移动到一个临时柱&amp;#xff0c;然后将最上面的两个盘子从源柱直接移动到目标柱&amp;#xff0c;最后将之前移动到临时柱上的其他盘子移动到目标柱&amp;#xff0c;具体的移动过程需要递归调用 hanoi 函数完成。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["写出分治算法解决四柱汉诺塔问题的伪代码", ["写出分治算法解决四柱汉诺塔问题的伪代码。", "写出分治算法解决四柱汉诺塔问题的伪代码。"]], "Tag": "算法设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;望采纳&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def getmid(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;, b):\n    k &amp;#61; int(&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;) / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n    &lt;span class=\"hljs-comment\"&gt;#print(k, a, b)&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; b[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]) / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k] &amp;#61;&amp;#61; b[k]:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k]\n    elif &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k] &amp;lt; b[k]:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; getmid(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[k&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:], b[:k])\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; getmid(&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;[:k], b[k:])\n\n\n\nlsta &amp;#61; [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;]\nlstb &amp;#61; [&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;]\n\nprint(getmid(lsta,lstb))\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "分治算法", "Question": ["用python完成分治策略", ["设A 和B都是从小到大已经排好序的几个不等的整数构成的数组，如果把 A 与B合并后的数组记作C,设计一个算法找出C的中位数python实现而且是分治策略"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答引用chatgpt:&lt;br /&gt;区间覆盖问题&lt;br /&gt;问题描述&amp;#xff1a;给定一些区间&amp;#xff0c;求最少需要多少个点才能覆盖所有的区间。&lt;/p&gt;\n&lt;p&gt;分治算法伪代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;cover(intervals):\n    if intervals &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;empty&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    find the &lt;span class=\"hljs-type\"&gt;interval&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;with&lt;/span&gt; the smallest &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt; point, &lt;span class=\"hljs-keyword\"&gt;called&lt;/span&gt; it &amp;#34;min_interval&amp;#34;\n    remove &amp;#34;min_interval&amp;#34; &lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; &amp;#34;intervals&amp;#34;\n    remove &lt;span class=\"hljs-keyword\"&gt;all&lt;/span&gt; intervals that overlap &lt;span class=\"hljs-keyword\"&gt;with&lt;/span&gt; &amp;#34;min_interval&amp;#34; &lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; &amp;#34;intervals&amp;#34;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt; cover(intervals)\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该算法的思路是选择一个区间&amp;#xff0c;找到所有与之重叠的区间&amp;#xff0c;然后递归地处理这些重叠的区间。由于每个点只会被算一次&amp;#xff0c;因此可以保证最后的点的数量是最小的。&lt;/p&gt;\n&lt;p&gt;2比赛日程安排问题&lt;br /&gt;问题描述&amp;#xff1a;有n个队伍要进行比赛&amp;#xff0c;每个队伍需要和其他队伍比赛一次&amp;#xff0c;求如何安排比赛&amp;#xff0c;使得n天内可以全部比完。&lt;/p&gt;\n&lt;p&gt;分治算法伪代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nschedule(n):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; [[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]]\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n        first_half &amp;#61; schedule(n/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n        second_half &amp;#61; schedule(n - n/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;add&lt;/span&gt; n/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;to&lt;/span&gt; all entries &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;the&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;second&lt;/span&gt; half\n        reverse &lt;span class=\"hljs-keyword\"&gt;the&lt;/span&gt; rows &lt;span class=\"hljs-keyword\"&gt;of&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;the&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;second&lt;/span&gt; half\n        &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; first_half &amp;#43; second_half\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该算法的思路是将所有队伍分为两部分&amp;#xff0c;分别让这两部分内的队伍进行比赛&amp;#xff0c;然后将第二部分内的所有队伍编号加上n/2&amp;#xff0c;再将其倒序排列&amp;#xff0c;最后将这两部分的比赛安排合并即可。由于每个队伍只需要比一次&amp;#xff0c;因此可以保证最后的比赛日程安排是正确的。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["写出分治算法解决区间覆盖问题或比赛日程安排问题的伪代码", ["写出分治算法解决区间覆盖问题或比赛日程安排问题的伪代码。", "请尽量详细一点。"]], "Tag": "算法设计"}
{"Answer": "代码出错了\r\n应该是\r\nwhile(i &lt;= mid)\r\ntemp[k++] = a[i++];", "Konwledge_Point": "分治算法", "Question": ["分治算法：二分归并排序的合并中一段代码有疑问", ["\n上图是数据", "\n下图是合并代码", "\n求大神帮帮忙！！！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;分治算法不算基础算法吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["关于#python#的问题：Python中分治算法的思想在很多基础算法上都有所体现吗", ["Python编程中分治算法的思想在很多基础算法上都有所体现吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个 left  right 不相等不就死循环了么&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/734377907566185.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;第一次循环进去&lt;br /&gt;left 0 right 1 ,然后  (left&amp;#43;right)/2-1)   &amp;#61;&amp;#xff08;0&amp;#43;1&amp;#xff09;/2-1 结果-1 &amp;#xff0c;第二次进去 left 0 right -1  直接死循环&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["java 算法 合并数组", ["public ", "class", " PartitionTest {", "//分治算法 合并排序代码", "\n\n    ", "private", " void merge", "Sort(", "int", " ", "a", "[], ", "int", " ", "left", ",", "int", " ", "right", ")", "{\n        ", "if", "(left", " == ", "right)\n        {\n            return;\n        }\n        merge", "Sort(", "a", ",", "left", ",(", "left", "+", "right", ")", "/", "2", "-", "1", ");\n        merge", "Sort(", "a", ",(", "left", "+", "right", ")", "/", "2", "+", "1", ",right-", "1", " );\n        merge(a,left,right);\n    }\n    ", "private", " void merge(", "int", " a", "[]", ", ", "int", " left, ", "int", " right) {\n        ", "int", " l = left, mid = (left + right)", " / ", "2", ", i = ", "0", ";\n        ", "int", " k = mid + ", "1", ";\n        ", "int", "[]", " arr = ", "new", " ", "int", "[", "left", " - ", "right", " + ", "1", "]", ";", "//存放排好序的数组", "\n        ", "while", " (l <= mid", " && ", "k <= right) {\n            ", "if", " (a", "[", "l", "]", " > a", "[", "k", "]", ") {\n                arr", "[", "i", "]", " = a", "[", "k", "]", ";\n                i++;\n                k++;\n            } ", "else", " {\n                arr", "[", "i", "]", " = a", "[", "l", "]", ";\n                i++;\n                l++;\n            }\n        }\n        ", "if", " (l > mid) {\n            ", "for", " (; k <= right; i++, k++) {\n                arr", "[", "i", "]", " = a", "[", "k", "]", ";\n            }\n        } ", "else", " {\n            ", "for", " (; l <= mid; i++, l++) {\n                arr", "[", "i", "]", " = a", "[", "l", "]", ";\n            }\n        }\n        ", "for", " (", "int", " j = ", "0", "; j < left - right + ", "1", " ; j++) {\n            a", "[", "left", "++", "]", " = arr", "[", "j", "]", ";\n        }\n    }\n\n    public static void main(String", "[]", " args) {\n        ", "int", "[]", " a = {", "2", ",", "0", "};\n        ", "new", " ", "PartitionTest()", ".merge", "Sort(", "a", ",0,", "a", ".", "length", "-1)", ";\n        ", "for", " (", "int", " i = ", "0", "; i < a.length; i++) {\n            ", "System", ".", "out.println(a", "[", "i", "]", ");\n        }\n    }\n}\n\n", "\n", "为什么爆栈了,同样类似的算法在c++ 我没有爆 不明白啊 这里的算法可能有点问题"]], "Tag": "算法设计"}
{"Answer": "你好，是closest()函数point *SR 指针越界导致程序崩溃的。做如下修改可以解决程序崩溃问题\r\npoint *SR = new point[(high - low) / 2]; 改为point *SR = new point[(high - low)+1]; OK", "Konwledge_Point": "分治算法", "Question": ["C++：基于分治思想实现二维平面最近点对算法，n>3时程序崩溃", ["感觉问题出在快速排序的两个函数上，麻烦各位大佬看一下哪里出了问题。", "\n\n", "#include \"stdafx.h\"\n#include <vector>\n#include <math.h>\n#include <time.h>\n#include<algorithm>\n#include <iostream>\nusing namespace std;\n\nstruct point//存储点坐标的结构体\n{\n    int index;\n    float x,y;\n};\n\nvoid Same(int n,int k,point X[])//查找相同的坐标\n{\n    for(int i=0;i<n;i++)\n    {\n        if(X[k].x==X[i].x&&X[k].y==X[i].y)\n        {\n            X[k].x=(float)(rand()%10001);\n            X[k].y=(float)(rand()%10001);\n            Same(n,k,X);\n        }\n    }\n}\n\n\n\nvoid QuickSort1(point arr[], int left, int right)//快速排序\n{\nif (left<right)\n    {   \n        int i=left,j=right;\n        point a; \n        a=arr[left];\n        while (i<j)\n        {\n            while(i<j&&arr[j].x>=a.x) // 从右向左找第一个小于x的数\n                j--; \n            if(i<j)\n                arr[i++].x=arr[j].x;\n            while(i<j&&arr[i].x<a.x) // 从左向右找第一个大于等于x的数\n                i++; \n            if(i<j)\n                arr[j--].x=arr[i].x;\n        }\n        arr[i].x=a.x;\n        QuickSort1(arr,left,i-1); // 递归调用\n        QuickSort1(arr,i+1,right);\n    }\n\n}\n\nvoid QuickSort2(point arr[], int left, int right)//快速排序\n{\nif (left<right)\n    {   \n        int i=left,j=right;\n        point a; \n        a=arr[left];\n        while (i<j)\n        {\n            while(i<j&&arr[j].y>=a.y) // 从右向左找第一个小于x的数\n                j--; \n            if(i<j)\n                arr[i++].y=arr[j].y;\n            while(i<j&&arr[i].y<a.y) // 从左向右找第一个大于等于x的数\n                i++; \n            if(i<j)\n                arr[j--].y=arr[i].y;\n        }\n        arr[i].y=a.y;\n        QuickSort2(arr,left,i-1); // 递归调用\n        QuickSort2(arr,i+1,right);\n    }\n\n}\n\nfloat Distance(point a, point b)//求两点之间距离   !不能以distance命名，与函数模板重名，xutility文件会报错\n{\n    float x=a.x-b.x;\n    float y=a.y-b.y;\n    return sqrt(x*x+y*y);\n}\n\nvoid closest(point X[], point Y[],int low,int high,point &a,point &b,float &min)//求最近点对及其距离，设置ab的目的是输出最近点对的坐标\n{\n    int i,j,k,m;\n    point al,bl,ar,br;\n    float dl,dr;\n    if((high-low)==1) // n=2直接计算两个点之间的距离\n    {   \n        a=X[low];\n        b=X[high];\n        min=Distance(X[low], X[high]);\n    }\n    else\n    {  \n        if((high-low)==2)  //    当n=3时直接计算\n        {                        \n            dl = Distance(X[low], X[low+1]);                       \n            dr = Distance(X[low], X[low+2]);                      \n            min = Distance(X[low+1], X[low+2]);                       \n            if((dl<=dr)&&(dl<=min))\n            {                    \n                a = X[low], b = X[low+1], min = dl;              \n            }\n            else\n            {\n                if(dr<=min)\n                {\n                    a=X[low];\n                    b=X[low+2]; \n                    min=dr;\n                }\n                else\n                {\n                    a=X[low+1];\n                    b=X[low+2];             \n                }                      \n            }                \n        }\n        else //        当n>3时进行分治\n        {                  \n            point *SL = new point[(high-low)/2+1];             \n            point *SR = new point[(high-low)/2];      \n            m = (high-low)/2 + low;    //       把x数组以m为界划分为两半             \n            j = k = 0;            \n            for(i=0; i<=high-low; i++)\n            {                       \n                if(Y[i].index<=m)\n                {                                \n                    SL[j++] = Y[i];   //       收集左边子集中的最近点对                             \n                }\n                else\n                {                      \n                    SR[k++] = Y[i];   //       收集右边子集中的最近点对                           \n                }                    \n            }\n                        closest(X,SL,low, m, al, bl, dl);       //     计算左边子集的最近点对\n                        closest(X,SR,m+1, high, ar, br, dr);//  计算右边子集的最近点对\n                        if(dl<dr)\n                        {                              //    组合步得到左右子集中点的最短距离d\n                                a = al, b = bl, min = dl;\n                        }\n                        else\n                        {\n                                a = ar, b = br, min = dr;\n                        }\n                        point *Z = new point[high-low+1];\n                        k = 0;\n                        for( i=0; i<=high -low; i++) // 收集距离中线距离小于d的元素，保存到数组Z（因Y数组按y坐标递增排序，Z数组也一样）\n                        {       \n                            if(fabs(X[m].x - Y[i].x)<min)//abs求整数绝对值\n                            {  \n                                Z[k].x = Y[i].x, Z[k++].y = Y[i].y;\n\n                            }\n                        }\n                        for( i=0; i<k; i++)\n                        {\n                                for( j=i+1; (j<k)&&(Z[j].y-Z[i].y<min); j++){     //   若前后两点y轴的距离超过d则不可能使距离小于d，退出\n                                        dl = Distance(Z[i], Z[j]);    //        计算前后两点的距离\n                                        if(dl<min){                                   //     若小于min，则更新\n                                                a = Z[i], b = Z[j], min = dl;\n                                        }\n                                }\n                        }\n\n                        delete SL;\n                        delete SR;\n                        delete Z;\n                }\n        }\n}\n\nvoid closest_pair(point X[], int n, point &a, point &b, float &min){\n        if(n<2){        //      当点集个数小于2时不存在最近点对\n                min= 0;\n        }else{\n               QuickSort1(X,0,n-1);      //        对x数组进行递增排序\n               point *Y = new point[n];    //  初始化辅助点数组Y\n                for( int i = 0 ; i < n ;i ++){\n                        Y[i].index = i;\n                        Y[i].x = X[i].x;\n                        Y[i].y = X[i].y;\n                }\n                QuickSort2(Y,0,n-1);      //        对y数组进行递增排序\n                closest(X,Y,0,n-1,a,b,min);              //     求亲密点对\n                min = sqrt(min);                //  将得到的d开平方才是两点间真正的距离\n                delete Y;\n        }\n}\n\nvoid main()\n{ \n    int n;\n    cout<<\"请输入点个数：\"<<endl;\n    cin>>n;\n    point *X=new point[n];\n     srand((int)time(0));\n     for(int i=0;i<n;i++)\n     {\n         X[i].x=(float)(rand()%10001);\n         X[i].y=(float)(rand()%10001);\n     }\n     //for(int j=0;j<n;j++)\n      //  Same(n,j,X);\n     point a,b;\n     float min;\n     closest_pair(X,n,a,b,min);\n     if(n>=2)\n     {\n          printf(\"最近点对为：(%.0f,%.0f),(%.0f,%.0f) \\n两点距离为：%.4f\\n\", a.x, a.y, b.x, b.y, min);\n      }\n     else{\n                printf(\"不存在最近点对！\\n\");\n        }\n\n}\n\n\n"]], "Tag": "算法设计"}
{"Answer": "程序质量的高低一般看程序的运行速度、占用存储的大小，程序是否清晰，容易阅读理解。", "Konwledge_Point": "分治算法", "Question": ["高分悬赏：Java语言中哪些排序算法体现了分治的思想，哪些体现了递归的思想？具体说明", ["高分悬赏：Java语言中哪些排序算法体现了分治的思想，哪些体现了递归的思想？具体说明"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;必要性谈不上&amp;#xff0c;但有些信息可以提供给你参考。算法分为数据结构算法和数学算法&amp;#xff0c;其中&amp;#xff0c;使用数据结构的算法多用于数据的存储和其它的编程问题&amp;#xff0c;而数学算法则多用于人工智能。至于算法题&amp;#xff0c;不清楚你说的是哪一类&amp;#xff0c;如果是大学生的ACM竞赛题、中学生的NOI或NOIP竞赛题的话&amp;#xff0c;大多指的是数学算法类的&amp;#xff0c;数据结构等程序上的算法用的较少&amp;#xff0c;而且&amp;#xff0c;大学数学不是不刷这类算法题的理由&amp;#xff0c;毕竟中学都有集训和比赛的。总而言之&amp;#xff0c;必要性谈不上&amp;#xff0c;至于需不需要练&amp;#xff0c;则看你自己。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["大一有必要学算法刷算法题吗", ["  大一计科专业，学校大二都会讲数据结构算法啥的，现在学了c，平时不知道要干点啥，如果说刷题的话，都是算法题，什么二叉树分治递归的需要用到这些知识，现在没有学去写阻力会很大，每写一题都需要去看相关知识，但这样即使写出来题相关知识也没法掌握住，也只能知道的很浅显也不系统，而且我记得还需要用到其他数学课的知识，现在我们只学了高数线代。可能写一个月也学不了多少，大二会专门去深入讲数据结构什么的，比自己学会好很多。我看我身边有人也在刷洛谷，但是感觉也都是写的磕磕绊绊，为了写出来而写。", "  所以想知道大一有必要学算法写算法题，或者是我上面说的有不对的地方？"]], "Tag": "算法设计"}
{"Answer": "你的目的是找最大点，所以第3步应该是找右边Y值最大的和X值最大的。", "Konwledge_Point": "分治算法", "Question": ["类似于最近点对问题，但是有点不一样，麻烦看下我的思路有没有问题 ", ["问题：（最近点对问题）设平面上有两个不同的点p1=（x1，y1）和p2（x2，y2），若x1>x2,y1>y2,则称p1支配p2,。", "\n给定平面上n个点的集合P={p1，p2，...,pn},若点pi属于P，不被平面上任意点支配，则称pi为P的最大点。", "\n试使用分治法设计一个O（nlogn）的算法计算P中的所有最大点。", "\n\n", "分治法解决最近点对问题思路：", "\n用分治法解决最近点对问题，就是将一个问题分解两个子问题，然后递归处理子问题，然后合并。可能两个点在每个子问题中，也可能两个点分别在两个子问题中，就这两种情况。则基本过程为：找一条中垂线m(坐位S集合x坐标的中位数)把n个元素分成左右两部分元素，然后分别求得两边的最短距离1d,2d，然后取两者中的最小者记为d，在中线两边分别取d的距离，记录该距离范围内点的个数，中线左边有L个元素，右边有R个元素，分别将两边的点按y坐标升序排列，在左边集合中每一个点，找右边集合的点，找到与之距离小于d的点，更新最短距离，直到循环结束，即可求出最短距离。", "\n\n", "以上是解决找距离最近的点的问题", "\n\n", "解决最开始那个问题，我的思路是：", "\n1.找一条中垂线m(坐位S集合x坐标的中位数)把n个元素分成左右两部分元素。", "\n2.既然已经有了坐标，那么这时中垂线右边的点的x坐标肯定要比左边的大，这时就只需要在中垂线的右边找就可以了", "\n3.取得右边最大距离为d", "\n\n", "想到这里不知道接下来该怎么办了", "\n我是初学者，可能有些啰嗦，问题又不是很难，麻烦大家帮我解决一下，谢谢"]], "Tag": "算法设计"}
{"Answer": "```\r\n #include &lt;stdio.h&gt;\r\n\r\nvoid swap(int a[], int i, int j)\r\n{\r\n    // 交换数组a中元素i与元素j的值\r\n    int tmp;\r\n    tmp = a[i];\r\n    a[i] = a[j];\r\n    a[j] = tmp;\r\n}\r\n\r\nint partition(int a[], int lo, int hi)\r\n{\r\n    int i = lo-1, pivot = a[lo];\r\n    swap(a, lo, hi);\r\n    while(lo&lt;hi)\r\n    {\r\n        // 循环开始的时候i指向的是小于pivot的最后的一个位置\r\n        if(a[lo] &lt; pivot)\r\n        {\r\n            i ++;\r\n            swap(a, i, lo);\r\n        }\r\n        lo ++;\r\n    }\r\n    i ++;\r\n    swap(a, i, hi);\r\n    return i;\r\n}\r\n\r\nint find(int a[], int left, int right, int k)\r\n{\r\n    int index;\r\n    index = partition(a, left, right);\r\n    if(index == k)\r\n        return a[index];\r\n    else if(index &lt; k)\r\n        return find(a, index+1, right, k);\r\n    else\r\n        return find(a, left, right-1, k);\r\n}\r\n\r\nint main()\r\n{\r\n    int a[10000];\r\n    int n, k, i;\r\n    scanf(\"%d\", &amp;n);\r\n    scanf(\"%d\", &amp;k);\r\n    for(i=0; i&lt;n; i++)\r\n        scanf(\"%d\", &amp;a[i]);\r\n    printf(\"%d\\n\", find(a, 0, n-1, k-1));\r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": ["C++语言编程 急急！！！ 用分治策略", ["设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。", "\n\n", "提示：函数int partition(int a[],int left,int right)的功能是根据a[left]~a[right]中的某个元素x（如a[left])对a[left]~a[right]进行划分，划分后的x所在位置的左段全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。", "\n\n", "输入格式:", "\n输入有两行：", "\n\n", "第一行是n和k，0<k<=n<=10000", "\n\n", "第二行是n个整数", "\n\n", "输出格式:", "\n输出第k小的数", "\n\n", "输入样例:", "\n在这里给出一组输入。例如：", "\n\n", "10 4", "\n2 8 9 0 1 3 6 7 8 2", "\n输出样例:", "\n在这里给出相应的输出。例如：", "\n\n", "2"]], "Tag": "算法设计"}
{"Answer": "在分治求和过程中，遇到更大的和值时，更新一下当前子数组下标就可以了\r\n\r\n\r\n```\r\n \r\npublic class MaxSumSubarray {\r\n\r\n\tprivate static int binarySearch(int a[], int left, int right, MaxSumSubarray result) {\r\n\t\tint leftSum, rightSum, crossSum;\r\n\t\tif (left == right) {\r\n\t\t\tif (a[left] &gt; result.sum) {\r\n\t\t\t\tresult.sum = a[left];\r\n\t\t\t\tresult.begin = left;\r\n\t\t\t\tresult.end = right;\r\n\t\t\t}\r\n\t\t\treturn a[left];\r\n\t\t} else {\r\n\t\t\tint mid = (left + right) / 2;\r\n\t\t\tleftSum = binarySearch(a, left, mid, result);\r\n\t\t\trightSum = binarySearch(a, mid + 1, right, result);\r\n\t\t\tcrossSum = crossBinarySearch(a, left, mid, right, result);\r\n\t\t\tif (leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum) {\r\n\t\t\t\tif (leftSum &gt; result.sum) {\r\n\t\t\t\t\tresult.sum = leftSum;\r\n\t\t\t\t\tresult.begin = left;\r\n\t\t\t\t\tresult.end = mid;\r\n\t\t\t\t}\r\n\t\t\t\treturn leftSum;\r\n\t\t\t} else if (rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum) {\r\n\t\t\t\tif (rightSum &gt; result.sum) {\r\n\t\t\t\t\tresult.sum = rightSum;\r\n\t\t\t\t\tresult.begin = mid;\r\n\t\t\t\t\tresult.end = right;\r\n\t\t\t\t}\r\n\t\t\t\treturn rightSum;\r\n\t\t\t} else {\r\n\t\t\t\treturn crossSum;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MaxSumSubarray binarySearch(int[] a) {\r\n\t\tif (a == null || a.length == 0) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tMaxSumSubarray result = new MaxSumSubarray();\r\n\t\tresult.sum = binarySearch(a, 0, a.length - 1, result);\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprivate static int crossBinarySearch(int a[], int left, int mid, int right, MaxSumSubarray result) {\r\n\t\tint leftSum = 0;\r\n\t\tint max_left_sum = 0;\r\n\t\tint begin = mid, end = mid + 1;\r\n\t\tfor (int i = mid; i &gt;= left; i--) {\r\n\t\t\tleftSum += a[i];\r\n\t\t\tif (leftSum &gt; max_left_sum) {\r\n\t\t\t\tbegin = i;\r\n\t\t\t\tmax_left_sum = leftSum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint rightSum = 0;\r\n\t\tint max_right_sum = 0;\r\n\t\tfor (int i = mid + 1; i &lt;= right; i++) {\r\n\t\t\trightSum += a[i];\r\n\t\t\tif (rightSum &gt; max_right_sum) {\r\n\t\t\t\tend = i;\r\n\t\t\t\tmax_right_sum = rightSum;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tint sum = max_left_sum + max_right_sum;\r\n\t\tif (sum &gt; result.sum) {\r\n\t\t\tresult.sum = sum;\r\n\t\t\tresult.begin = begin;\r\n\t\t\tresult.end = end;\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\r\n\tprivate int begin;\r\n\r\n\tprivate int end;\r\n\r\n\tprivate int sum;\r\n\r\n\tpublic MaxSumSubarray() {\r\n\t\tsuper();\r\n\t\tsum = Integer.MIN_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the begin\r\n\t */\r\n\tpublic int getBegin() {\r\n\t\treturn begin;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the end\r\n\t */\r\n\tpublic int getEnd() {\r\n\t\treturn end;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the sum\r\n\t */\r\n\tpublic int getSum() {\r\n\t\treturn sum;\r\n\t}\r\n}\r\n```\r\n\r\n我这里用java语言实现，如果用其他语言，可以将MaxSumSubarray用一个整形数组替换，\r\n\r\n\tprivate int begin;\r\n\r\n\tprivate int end;\r\n\r\n\tprivate int sum;\r\n\t\r\n\t这三个字段就用一个int[3]替换", "Konwledge_Point": "分治算法", "Question": ["算法设计 最大子数组（序列）", ["采用分治法，有没有简单的方法标记最大子序列的开始和结尾点。", "\n即为可以输出子序列各个元素"]], "Tag": "算法设计"}
{"Answer": "```\r\n 参考下面的程序，输入输出就你自己修改了，不然等于帮你做作业了。\r\n\r\n#include&lt;iostream&gt;  \r\n#include&lt;stdio.h&gt;  \r\nusing namespace std;  \r\n  \r\nint Partition (int *L, int low, int high)  \r\n{  \r\n    int temp = L[low];  \r\n    int pt   = L[low]; //哨兵  \r\n    while (low != high)  \r\n    {  \r\n        while (low &lt; high &amp;&amp; L[high] &gt;= pt)  \r\n            high--;  \r\n        L[low] = L[high];         \r\n          \r\n        while (low &lt; high &amp;&amp; L[low] &lt;= pt)  \r\n            low++;  \r\n        L[high] = L[low];  \r\n    }     \r\n    L[low] = temp;  \r\n    return low;  \r\n}  \r\n  \r\nvoid QSort (int *L, int low, int high)  //快速排序  \r\n{  \r\n    int pl;  \r\n    if (low &lt; high)  \r\n    {  \r\n        pl = Partition (L,low,high);  \r\n        QSort (L, low,  pl-1);  \r\n        QSort (L, pl+1, high);  \r\n    }  \r\n}  \r\n  \r\nvoid findk(int k,int *L,int low,int high)  \r\n{  \r\n    int temp;  \r\n    temp=Partition(L,low,high);  \r\n    if(temp==k-1)  \r\n    {  \r\n        cout&lt;&lt;\"第\"&lt;&lt;temp+1&lt;&lt;\"大的数是:\"&lt;&lt;L[temp]&lt;&lt;endl;  \r\n    }  \r\n    else if(temp&gt;k-1)  \r\n        findk(k,L,low,temp-1);  \r\n    else  \r\n        findk(k,L,temp+1,high);  \r\n}  \r\n  \r\nint main()  \r\n{  \r\n    int a[10]={15,25,9,48,36,100,58,99,126,5},i,j,k;  \r\n    cout&lt;&lt;\"排序前：\"&lt;&lt;endl;  \r\n    for(i=0;i&lt;10;i++){  \r\n        cout&lt;&lt;a[i]&lt;&lt;\" \";  \r\n    }  \r\n    cout&lt;&lt;endl;  \r\n    cout&lt;&lt;\"请输入你要查找第k大的数：\"&lt;&lt;endl;  \r\n    cin&gt;&gt;k;  \r\n    findk(k,a,0,9); //查找第k大的数不需要全部排序  \r\n  \r\n    QSort(a,0,9);     \r\n    cout&lt;&lt;\"排序后：\"&lt;&lt;endl;  \r\n    for(i=0;i&lt;10;i++){  \r\n        cout&lt;&lt;a[i]&lt;&lt;\" \";  \r\n    }  \r\n    cout&lt;&lt;endl;  \r\n    system(\"Pause\");  \r\n    return 0;  \r\n}\r\n```", "Konwledge_Point": "分治算法", "Question": ["C++语言编程 急急！！！用分治策略", ["设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。", "\n\n", "提示：函数int partition(int a[],int left,int right)的功能是根据a[left]~a[right]中的某个元素x（如a[left])对a[left]~a[right]进行划分，划分后的x所在位置的左段全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。", "\n\n", "输入格式:", "\n输入有两行：", "\n\n", "第一行是n和k，0<k<=n<=10000", "\n\n", "第二行是n个整数", "\n\n", "输出格式:", "\n输出第k小的数", "\n\n", "输入样例:", "\n在这里给出一组输入。例如：", "\n\n", "10 4", "\n2 8 9 0 1 3 6 7 8 2", "\n输出样例:", "\n在这里给出相应的输出。例如：", "\n\n", "2"]], "Tag": "算法设计"}
{"Answer": "http://wenku.baidu.com/link?url=P10nirc7m3tpWtwvsF-Q_Su0RAaLVgd-pYbL29UAqm3IUVwf_6d-ARR9XLyuxaSkafTM06HHFjbC3xwflpztSUfQnzNq1wdPxJ_QWEkAOS_", "Konwledge_Point": "分治算法", "Question": ["解高次方程，除二分法", ["求解一个高次方程除了二分法，还有什么好的方法。求解一个高次方程除了二分法，还有什么好的方法。求解一个高次方程除了二分法，还有什么好的方法。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;return (maxSubSum(nums, 0, numsSize-1)试试&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["力扣53:最大子序和（最大子段和C语言分治）", ["小白求指点，为什么会报错", "\n", "执行结果： 执行出错 ================================================================= ==42==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x604000000034 at pc 0x5643b9ff8e04 bp 0x7ffd2cd0ab60 sp 0x7ffd2cd0ab50 READ of size 4 at 0x604000000034 thread T0 #5 0x7f15c13530b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2) 0x604000000034 is located 0 bytes to the right of 36-byte region [0x604000000010,0x604000000034) allocated by thread T0 here: #0 0x7f15c1f98bc8 in malloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10dbc8) #3 0x7f15c13530b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2) Shadow bytes around the buggy address: 0x0c087fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c087fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =>0x0c087fff8000: fa fa 00 00 00 00[04]fa fa fa fa fa fa fa fa fa 0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==42==ABORTING", "\n", "代码", "\n", "\n", "int", " maxSubArray(", "int", " nums[], ", "int", " numsSize){\n    return (maxSubSum(nums, ", "0", ", numsSize));\n}\n\n", "int", " maxSubSum(", "int", " *nums, ", "int", " ", "left", ", ", "int", " ", "right", "){\n    ", "int", "  ", "sum", " = ", "0", ", left_sum = ", "0", ", right_sum = ", "0", ", allmax = ", "0", ";\n    ", "if", " (", "left", " == ", "right", "){\n        ", "if", " (nums[", "left", "] > ", "0", "){\n            return nums[", "left", "];\n        }\n        else{\n            return ", "0", ";\n        }\n    }\n\n    ", "int", " ", "mid", " = (", "left", " + ", "right", ") / ", "2", ";\n    left_sum = maxSubSum(nums, ", "left", ", ", "mid", ");\n    right_sum = maxSubSum(nums, ", "mid", " + ", "1", ", ", "right", ");\n    for (", "int", " i = ", "mid", "; i >= ", "left", "; i--){\n        ", "sum", " += nums[i];\n        ", "if", " (allmax < ", "sum", "){\n            allmax = ", "sum", ";\n        }\n    }\n    ", "sum", " = allmax;\n    for (", "int", " i = ", "mid", " + ", "1", "; i <= ", "right", "; i++){\n        ", "sum", " += nums[i];\n        ", "if", " (allmax < ", "sum", "){\n            allmax = ", "sum", ";\n        }\n    }\n    ", "if", " (allmax < left_sum && right_sum < left_sum){\n        return left_sum;\n    }\n    ", "if", " (allmax < right_sum){\n        return right_sum;\n    }\n    return allmax;\n}\n\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 100000000&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[N]; \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;quickselect&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[],&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;s,j&amp;#61;t;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tmp;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;lt;t)\n    {\n        tmp&amp;#61;a[s];\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i!&amp;#61;j)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(j&amp;gt;i&amp;amp;&amp;amp;a[j]&amp;lt;&amp;#61;tmp)\n            {\n                j--;\n            }\n            a[i]&amp;#61;a[j];\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i&amp;lt;j&amp;amp;&amp;amp;a[i]&amp;gt;&amp;#61;tmp)\n            {\n                i&amp;#43;&amp;#43;;\n            }\n            a[j]&amp;#61;a[i];\n        }\n        a[i]&amp;#61;tmp;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;&amp;#61;&amp;#61;i) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a[i];\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;&amp;lt;i) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;quickselect&lt;/span&gt;(a,s,i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,k);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;quickselect&lt;/span&gt;(a,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,t,k);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;#61;&amp;#61;t&amp;amp;&amp;amp;s&amp;#61;&amp;#61;k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a[k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;];\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k;\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    cin&amp;gt;&amp;gt;a[i];\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;quickselect&lt;/span&gt;(a,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,k);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "分治算法", "Question": ["分治法求第K大的数有一个数据过不了？", ["问题遇到的现象和发生背景", "\n", " 第 k 大的整数**", "分数 25", "作者 李祥", "单位 湖北经济学院", "求 n 个整数中第 k(1≤k≤n) 大的整数。", "\n", "输入格式", "n 和 k", "n 个整数", "\n", "输出格式", "第 k 大的整数", "\n", "输入样例", "10 3", "2 5 -1 9 25 0 12 4 -7 12", "输出样例", "12", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "quickselect", "(", "int", " a[],", "int", " s,", "int", " t,", "int", " k)", "\n", "{\n    ", "int", " i=s,j=t;\n    ", "int", " tmp;\n    ", "if", "(s<t)\n    {\n        tmp=a[s];\n        ", "while", "(i!=j)\n        {\n            ", "while", "(j>i&&a[j]>=tmp) j--;\n            a[i]=a[j];\n            ", "while", "(i<j&&a[i]<=tmp) i++;\n            a[j]=a[i]; \n        }\n        a[i]=tmp;\n        ", "if", "(k", "-1", "==i) ", "return", " a[i];\n        ", "else", " ", "if", "(k", "-1", "<i) ", "return", " ", "quickselect", "(a,s,i", "-1", ",k);\n        ", "else", " ", "return", " ", "quickselect", "(a,i+", "1", ",t,k);\n    }\n    ", "else", " ", "if", "(s==t&&s==k", "-1", ") ", "return", " a[k", "-1", "];\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " n,k,e;\n    cin>>n>>k;\n    ", "int", " a[", "1000001", "];\n    ", "for", "(", "int", " i=", "0", ";i<n;i++)\n    {\n        cin>>a[i];\n    }  \n    e=", "quickselect", "(a,", "0", ",n", "-1", ",n-k+", "1", ");\n    cout<<e<<endl;\n    ", "return", " ", "0", ";\n} \n\n", "\n", "运行结果及报错内容", "\n"]], "Tag": "算法设计"}
{"Answer": "合并排序比较适合多核加速，jdk8的新Arrays.parallelSort API就是这么实现的，quick sort从理论上来说也可以利用多核加速，不过由于其对于不同数据的split有可能出现线性的特点，理论上不是能保证得到加速。\r\n另外，对于多核加速，期望值不要太高，基于我们对Arrays.parallelSort的测试，4核cpu最多能达到3.2倍的速度，而16核只能达到11.8倍。主要是由于现阶段的split之后还有merge。", "Konwledge_Point": "分治算法", "Question": ["快速排序和合并排序是否可以利用多核进一步加速", ["我在研究快速排序和合并排序的时候突然想到这两个算法是否可以利用多核来进一步加快运行效率~", "\n因为它们是采用了分治法的思想，分解成多个互相独立的子排序，与其他需要顺序执行的排序算法不同~", "\n没经过系统学习~正在看算法导论~勿喷~"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这不是分治法吧&amp;#xff0c;而且逻辑也有问题。。。&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["请问各位C语言，分治法找出数组中第 k 个小的元素，我错在哪儿，该怎么改呢。能够输出，但是输出结果错误", ["\n#", "include", " <stdio.h>\nvoid mp", "_sort(", "int", " ", "*", "c", ",", "int", " ", "n", ",", "int", " ", "p", ",", "int", " ", "q", ")", ";\n", "/**********  Begin  **********/", "\n", "int", " main", "()", "\n{\n    ", "int", " zd_num,i,num;\n    scanf(", "\"%d %d\"", ",&num,&zd_num);\n    ", "int", " a", "[", "num", "]", ";\n    ", "for", "(i=", "0", ";i<num;i++)\n    {\n        scanf(", "\"%d\"", ",&a", "[", "i", "]", ");\n    }\n    mp", "_sort(", "a", ",", "num", "/", "2,0,", "num", "/", "2-1)", ";\n    mp", "_sort(", "a", ",", "num", "/", "2,", "num", "/", "2,", "num", "-1)", ";\n    ", "if", "(a", "[", "num", "/", "2", "-", "1", "]", "<a", "[", "num", "/", "2", "]", ")\n    {\n        printf(", "\"第%d小的元素是%d\"", ",zd_num,a", "[", "zd_num", "-", "1", "]", ");\n    }\n    ", "else", "\n    {\n        mp", "_sort(", "a", ",", "num", ",0,", "num", "-1)", ";\n        printf(", "\"第%d小的元素是%d\"", ",zd_num,a", "[", "zd_num", "-", "1", "]", ");\n    }\n    return ", "0", ";\n}\nvoid mp", "_sort(", "int", " ", "*", "c", ",", "int", " ", "n", ",", "int", " ", "p", ",", "int", " ", "q", ")", "\n{\n    ", "int", " item,k,m;\n    ", "for", "(k=p;k<q;k++)\n    {\n        ", "for", "(m=p+", "1", ";m<=q;m++)\n        {\n            ", "if", "(c", "[", "k", "]", ">c", "[", "m", "]", ")\n            {\n                item=c", "[", "k", "]", ";\n                c", "[", "k", "]", "=c", "[", "m", "]", ";\n                c", "[", "m", "]", "=item;\n            }\n        }\n    }\n}\n", "/**********  End  **********/", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/750727102936198.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/925657102936170.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/382577102936113.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;\n&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#39;&amp;#39;\n先搞搞思路&amp;#xff0c; 写几行伪代码\n\n1、输入n&amp;#xff0c;真币重量a&amp;#xff0c;假币重量b&amp;#xff0c;假币位置m , 约束 b&amp;lt;a\n\n2、初始化 列表 list_n\nlist_n &amp;#61; [a for n in range(n)]    \nlist_n[m-1] &amp;#61; b\n\n3、根据列表长度切列表&amp;#xff0c;比较&amp;#xff0c;如未找到&amp;#xff0c;继续遍历重量小的列表&amp;#xff0c;直到切完。\n&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_result&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;l&lt;/span&gt;):\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;Find! position is: {}, weight is: {}.&amp;#39;&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;format&lt;/span&gt;(l[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],l[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]))\n\nwork_cmd &amp;#61; &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入硬币n&amp;#xff0c;真币重量a&amp;#xff0c;假币重量b&amp;#xff0c;假币位置m , 约束 b&amp;lt;a&amp;#xff1a;\\nn a b m\\t&amp;#34;&lt;/span&gt;)\nwork_num &amp;#61; [&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(x) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; x &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; work_cmd.split(&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;)]\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (work_num[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;lt; work_num[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; (work_num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; (work_num[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;lt;&amp;#61; work_num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]):\n    list_n &amp;#61; [[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,work_num[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]] &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(work_num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])]\n    list_n[work_num[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; work_num[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;硬币列表&amp;#34;&lt;/span&gt;, list_n)\n\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list_n) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        listlen &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list_n)\n        offset1 &amp;#61; listlen // &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;\n        offset2 &amp;#61; offset1\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; listlen % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            offset2 &amp;#61; offset2 &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n        list1 &amp;#61; list_n[:offset1]\n        list2 &amp;#61; list_n[offset2:]\n        sum1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;([n[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; n &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; list1])\n        sum2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;([n[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; n &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; list2])\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;  sum1 &amp;#61;&amp;#61; sum2  :\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; offset1 !&amp;#61; offset2:\n                show_result(list_n[offset1])\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n                &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;Not Find!&amp;#39;&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; sum1 &amp;lt; sum2:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list1)&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n                    show_result(list1[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;\n                list_n &amp;#61; list1\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(list2)&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n                    show_result(list2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;\n                list_n &amp;#61; list2\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;约束条件&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;未符合&amp;#xff0c;结束程序。&amp;#39;&lt;/span&gt;)\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "分治算法", "Question": ["想要请教一下这个python问题该怎么解决", ["相关知识", "找假币问题是一个比较简单且典型能够体现计算思维的问题。假设现在有n（n>=2）枚硬币，已知其中一枚为假币，且知道假币的重量是比真币轻的，请思考如何用分治思想解决该问题。", "\n", "算法原理", "本次实验中我们采用二分法解决假币问题。二分法是一个非常典型的分治思想的应用。", "\n", "如果n是偶数，将n个硬币平均分成两份，直接比较这两份硬币的重量，假币在重量较轻的那份硬币中，继续对重量较轻的那一份硬币使用二分法，直到找出假币；", "如果n是奇数，则随意取出一种的一枚硬币，将剩下的n-1枚硬币等分成两份。如果这两份硬币重量相同，则随机取出的那枚硬币即为假币；否则，按照硬币数为偶数是的处理办法继续执行算法。", "\n", "测试输入：", "3（此处省略七个3），2", "预期输出 :", "position is: 7, weight is: 2."]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&amp;#61;换成&amp;#61;&amp;#61;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/058662309266178.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["时间复杂度，求解答，求解答", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<time.h>", "\n\n", "int", " ", "maxIntervalSum_1", "(", "int", " array[],", "int", " len)", "//穷举法，三层循环", "\n", "{\n    ", "int", " max=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<len;i++)\n    {\n        ", "for", "(", "int", " j=i;j<len;j++)\n        {\n            ", "int", " sum=", "0", ";\n            ", "for", "(", "int", " k=i;k<=j;k++)\n            {\n                sum+=array[k];\n            }\n            ", "if", "(sum>max) max=sum;\n        }\n    }\n    ", "return", " max;\n}\n", "int", " ", "maxIntervalSum_2", "(", "int", " array[],", "int", " len)", "//改进穷举法，两层循环", "\n", "{\n    ", "int", " max=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<len;i++)\n    {\n        ", "int", " sum=", "0", ";\n        ", "for", "(", "int", " j=i;j<len;j++)\n        {\n            sum+=array[j];\n        }\n        ", "if", "(sum>max) max=sum;\n    }\n    ", "return", " max;\n}\n", "int", " ", "maxIntervalSum_3", "(", "int", " array[],", "int", " begin,", "int", " end)", "//分治法", "\n", "{\n    ", "int", " mmax=", "0", ";\n    ", "if", "(begin=end) ", "return", " array[begin]>", "0", "?array[begin]:", "0", ";\n    ", "int", " mid=begin+(end-begin)/", "2", ";\n    ", "int", " lmax=", "maxIntervalSum_3", "(array,begin,mid);", "//左半区间最大值", "\n    ", "int", " rmax=", "maxIntervalSum_3", "(array,mid+", "1", ",end);", "//右半区间最大值", "\n    ", "//中间区间最大值", "\n    ", "int", " sum=", "0", ";\n    ", "int", " left_max=", "0", ";\n    ", "for", "(", "int", " i=mid;i>=begin;i--)\n    {\n        sum+=array[i];\n        ", "if", "(sum>left_max) left_max=sum;\n    }\n    sum=", "0", ";\n    ", "int", " right_max=", "0", ";\n    ", "for", "(", "int", " i=mid+", "1", ";i<=end;i++)\n    {\n        sum+=array[i];\n        ", "if", "(sum>right_max) right_max=sum;\n    }\n    mmax=left_max+right_max;\n    ", "int", " max=(lmax>rmax)?(lmax>mmax?lmax:mmax):(rmax>mmax?rmax:mmax);\n    ", "return", " max;\n}\n", "int", " ", "maxIntervalSum_4", "(", "int", " array[],", "int", " len)", "//动态规则", "\n", "{\n    ", "int", " max=", "0", ";\n    ", "int", " sum=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<len;i++)\n    {\n        sum+=array[i];\n        ", "if", "(sum<", "0", ") sum=", "0", ";\n        ", "if", "(sum>max) max=sum;\n    }\n    ", "return", " max;\n}\n\n", "int", " ", "main", "(", "int", " argc,", "char", "* argv[])", "\n", "{\n    ", "char", "* f_name=argv[", "1", "];", "//文件名", "\n    ", "int", " n=", "atoi", "(argv[", "2", "]);", "//字符串转整数", "\n    ", "int", " repeat_time=", "atoi", "(argv[", "3", "]);", "//重复次数", "\n    ", "//读取数据到数组", "\n    FILE *pf;\n    ", "int", "* data=(", "int", "*)", "malloc", "(n*", "sizeof", "(", "int", "));\n    ", "if", "((pf=", "fopen", "(", "\"C:\\\\text_datum.txt\"", ",", "\"r\"", "))==", "NULL", ")\n    {\n        ", "printf", "(", "\"Error\\n\"", ");\n        ", "system", "(", "\"PAUSE\"", ");\n        ", "exit", "(", "1", ");\n    }\n    ", "//读取文件内容到数列", "\n    ", "for", "(", "long", " ", "long", " ", "int", " i=", "0", ";i<n;i++)\n    {\n        ", "fscanf", "(pf,", "\"%d\\n\"", ",&data[i]);\n    }\n    ", "fclose", "(pf);\n\n\n    ", "clock_t", " c_start,c_end;\n    ", "int", " maxValue=", "0", ";\n    c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++)\n    {\n        maxValue=", "maxIntervalSum_1", "(data,n);\n    }\n    c_end=", "clock", "();\n    ", "double", " ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法1,时间复杂度0(n^3),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n\n\n\n    c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++)\n    {\n        maxValue=", "maxIntervalSum_2", "(data,n);\n    }\n    c_end=", "clock", "();\n    ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法2,时间复杂度0(n^2),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n\n\n\n     c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++){\n        maxValue=", "maxIntervalSum_3", "(data,", "0", ",n", "-1", ");\n    }\n    c_end=", "clock", "();\n    ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法3，时间复杂度0(nlogn),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n\n     c_start=", "clock", "();\n    ", "for", "(", "int", " i=", "0", ";i<repeat_time;i++){\n        maxValue=", "maxIntervalSum_4", "(data,n);\n    }\n    c_end=", "clock", "();\n    ", "diff_t", "=", "difftime", "(c_end,c_start);\n    ", "printf", "(", "\"算法4，时间复杂度0(n),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,", "diff_t", "/repeat_time);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "求告知该怎么办？", "这是文件链接", "https://share.weiyun.com/FF6MWRaQ", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;先把你代码贴好&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/081322698266195.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "分治算法", "Question": ["时间复杂度，今天就要交了", ["#include <stdio.h>", "#include <stdlib.h>", "#include <time.h>", "\n", "int maxIntervalSum_1(int array[],int len)//穷举法，三层循环", "{", "    int max=0;", "    for(int i=0;i<len;i++)", "    {", "        for(int j=i;j<len;j++)", "        {", "            int sum=0;", "            for(int k=i;k<=j;k++)", "            {", "                sum+=array[k];", "            }", "            if(sum>max) max=sum;", "        }", "    }", "    return max;", "}", "int maxIntervalSum_2(int array[],int len)//改进穷举法，两层循环", "{", "    int max=0;", "    for(int i=0;i<len;i++)", "    {", "        int sum=0;", "        for(int j=i;j<len;j++)", "        {", "            sum+=array[j];", "        }", "        if(sum>max) max=sum;", "    }", "    return max;", "}", "int maxIntervalSum_3(int array[],int begin,int end)//分治法", "{", "    int mmax=0;", "    if(begin=end) return array[begin]>0?array[begin]:0;", "    int mid=begin+(end-begin)/2;", "    int lmax=maxIntervalSum_3(array,begin,mid);//左半区间最大值", "    int rmax=maxIntervalSum_3(array,mid+1,end);//右半区间最大值", "    //中间区间最大值", "    int sum=0;", "    int left_max=0;", "    for(int i=mid;i>=begin;i--)", "    {", "        sum+=array[i];", "        if(sum>left_max) left_max=sum;", "    }", "    sum=0;", "    int right_max=0;", "    for(int i=mid+1;i<=end;i++)", "    {", "        sum+=array[i];", "        if(sum>right_max) right_max=sum;", "    }", "    mmax=left_max+right_max;", "    int max=(lmax>rmax)?(lmax>mmax?lmax:mmax):(rmax>mmax?rmax:mmax);", "    return max;", "}", "int maxIntervalSum_4(int array[],int len)//动态规则", "{", "    int max=0;", "    int sum=0;", "    for(int i=0;i<len;i++)", "    {", "        sum+=array[i];", "        if(sum<0) sum=0;", "        if(sum>max) max=sum;", "    }", "    return max;", "}", "\n", "int main(int argc,char* argv[])", "{", "    char* f_name=argv[1];//文件名", "    int n=atoi(argv[2]);//字符串转整数", "    int repeat_time=atoi(argv[3]);//重复次数", "    //读取数据到数组", "    FILE ", "pf;", "    int", " data=(int*)malloc(n*sizeof(int));", "    if((pf=fopen(\"C:", "\\text_datum.txt\",\"r\"))==NULL)", "    {", "        printf(\"Error\\n\");", "        system(\"PAUSE\");", "        exit(1);", "    }", "    //读取文件内容到数列", "    for(long long int i=0;i<n;i++)", "    {", "        fscanf(pf,\"%d\\n\",&data[i]);", "    }", "    fclose(pf);", "\n", "clock_t c_start,c_end;\nint ", "maxValue", "=0;\n", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++)\n{\n    ", "maxValue", "=maxIntervalSum_1(data,n);\n}\n", "c_end", "=clock();\ndouble ", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法1,时间复杂度0(n^3),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\n\n\n\n", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++)\n{\n    ", "maxValue", "=maxIntervalSum_2(data,n);\n}\n", "c_end", "=clock();\n", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法2,时间复杂度0(n^2),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\n\n\n\n ", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++){\n    ", "maxValue", "=maxIntervalSum_3(data,0,n-1);\n}\n", "c_end", "=clock();\n", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法3，时间复杂度0(nlogn),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\n\n ", "c_start", "=clock();\n", "for", "(int ", "i", "=0;i<repeat_time;i++){\n    ", "maxValue", "=maxIntervalSum_4(data,n);\n}\n", "c_end", "=clock();\n", "diff_t", "=difftime(c_end,c_start);\nprintf(", "\"算法4，时间复杂度0(n),最大值=%d,执行时间=%f 毫秒.\\n\"", ",maxValue,diff_t/repeat_time);\nreturn 0;\n", "\n", "}", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;&lt;p&gt;先说你的错误原因把&amp;#xff1a; 第17行和第18行代码中&amp;#xff0c; 你需要传递数组a&amp;#xff0c; 不需要添加[],  数组的传递只用传递数组名&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;其次&amp;#xff1a;    printf(&amp;#34;分治法求出数组元素的和为:%d&amp;#34;,&amp;amp;sum);输出这里不能加&amp;amp;&amp;#xff0c; 这表示取地址&amp;#xff0c; 加了就是输出sum在电脑中的地址而非输出sum所对应的值&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "分治算法", "Question": ["请问各位C语言求一组数据的和，我的代码编译不出来，该怎么修改呢", ["\n", "#", "include", " ", "\"stdio.h\"", "\n", "#", "include", " ", "\"stdlib.h\"", "\n", "/**********  Begin  **********/", "\n", "int", " ", "get_sum", "(", "int", " b[],", "int", " i,", "int", " j)", ";\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " sum1,sum2,sum,i,num;\n    ", "scanf", "(", "\"%d\"", ",&num);\n    ", "printf", "(", "\"\\n\"", ");\n    ", "int", " a[num];\n    ", "for", "(i=", "0", ";i<num;i++)\n    {\n        ", "scanf", "(", "\"%d\"", ",&a[i]);\n        ", "printf", "(", "\"\\n\"", ");\n    }\n    sum1=", "get_sum", "(a[],", "0", ",num/", "2", "-1", ");\n    sum2=", "get_sum", "(a[],num/", "2", ",num", "-1", ");\n    sum=sum1+sum2;\n    ", "printf", "(", "\"分治法求出数组元素的和为:%d\"", ",&sum);\n       ", "return", " ", "0", ";\n}\n", "int", " ", "get_sum", "(", "int", " b[],", "int", " i,", "int", " j)", "\n", "{\n    ", "int", " sum=", "0", ",k;\n    ", "for", "(k=i;k<=j;k++)\n    {\n        sum+=b[k];\n    }\n    ", "return", " sum;\n}\n\n", "/**********  End  **********/", "\n\n"]], "Tag": "算法设计"}
