{"Answer": "&lt;p&gt;频谱图比较亮的地方就是低频&amp;#xff0c;因为图像的能量一般都是集中在低频部分&amp;#xff0c;&lt;br /&gt;频谱中心化以后&amp;#xff0c;就是低频在中间高频在四周了。&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/359546560156113.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["傅里叶变换关于频谱图横纵坐标的意义的疑问", ["dft将时域f（x,y）转化为频域F（u,v），这里的u和v不就代表频率大小嘛。那按道理应该未中心化的频谱图上右下角（u-1,v-1）是最高频信息，可是为什么一直说未中心化的频谱图中心是高频信息而四角是低频信息呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;赚个外块真不容易&amp;#xff0c;看了一下午&amp;#xff0c;&lt;/p&gt;\n\n&lt;p&gt;你的问题如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;1&amp;#xff0c;乘法错了&amp;#xff0c; 复数的乘法&amp;#xff0c;你写错了&amp;#xff1b;(a &amp;#43; b j) * (c &amp;#43; d j) &amp;#61; ac-bd &amp;#43; (bc &amp;#43; ad) j &lt;/p&gt;\n\n&lt;p&gt;2.  你蝶形运算错了&amp;#xff0c;你在好好对照蝶形图捋一捋&amp;#xff0c;比如&amp;#xff0c;第0级对应的旋转因子都是0&amp;#xff0c;你的0123&amp;#xff0c;第1级是0202&amp;#xff0c;你的0202&amp;#xff0c;第2级0123&amp;#xff0c;你的0000&amp;#xff0c;刚好反了&amp;#xff0c;你的分组和每组的数&amp;#xff0c;有问题&amp;#xff0c;你再好好捋一捋吧&lt;/p&gt;\n\n&lt;p&gt;附上修改后的程序和运行结果&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;using System;\n\nnamespace ConsoleApp34\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int N &amp;#61; 8;\n            //初始化时域数据\n            Complex[] TD2FD &amp;#61; new Complex[N];\n            for (int i &amp;#61; 0; i &amp;lt; N; i&amp;#43;&amp;#43;)\n            {\n                Complex cpx &amp;#61; new Complex();\n                cpx.re &amp;#61; i;\n                cpx.im &amp;#61; 0;\n                TD2FD[i] &amp;#61; cpx;\n            }\n\n            Console.WriteLine(&amp;#34;------原始信号-----&amp;#34;);\n            Print(TD2FD);\n\n            Console.WriteLine(&amp;#34;----- FFT -----&amp;#34;);\n            FFT(TD2FD);\n            Print(TD2FD);\n\n            Console.WriteLine(&amp;#34;----- IFFT -----&amp;#34;);\n            IFFT(TD2FD);\n            Print(TD2FD);\n\n            Console.Read();\n        }\n\n        //快速傅里叶变换\n        public static void FFT(Complex[] TD2FD)\n        {\n            FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n        }\n\n        //快速傅里叶逆变换\n        public static void IFFT(Complex[] FD2TD)\n        {\n            //做FFT变换\n            Complex[] WT &amp;#61; WT_LUT(FD2TD.Length, -1);\n            FFT_Core(FD2TD, WT);\n            //实部除以N\n            for (int i &amp;#61; 0; i &amp;lt; FD2TD.Length; i&amp;#43;&amp;#43;)\n                FD2TD[i].re /&amp;#61; FD2TD.Length;\n        }\n\n        // 返回旋转因子查询表(twiddle factor lookup table)\n        private static Complex[] WT_LUT(int N, int flag &amp;#61; 1)\n        {\n            Complex[] WT &amp;#61; new Complex[N];\n            for (int i &amp;#61; 0; i &amp;lt; N; i&amp;#43;&amp;#43;)\n            {\n                Complex cpx_wt &amp;#61; new Complex();\n                float angle &amp;#61; (float)(-i * Math.PI * 2 / N);\n                cpx_wt.re &amp;#61; (float)Math.Cos(angle);\n                //IFFT flag&amp;#61;-1, FFT flag&amp;#61;1\n                cpx_wt.im &amp;#61; flag * (float)Math.Sin(angle);\n                WT[i] &amp;#61; cpx_wt;\n            }\n            return WT;\n        }\n\n        private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n        {\n            int power &amp;#61; (int)Math.Log(TD2FD.Length, 2);\n            int butterfly;\n            Complex x1, x2, wt;\n            BitReverse(TD2FD);\n\n            //蝶形运算\n            for (int k &amp;#61; 0; k &amp;lt; power; k&amp;#43;&amp;#43;) //级数\n            {\n                //Console.WriteLine(&amp;#34;第{0}级, 共{1}组&amp;#34;, k, 1 &amp;lt;&amp;lt; k);\n                for (int j &amp;#61; 0; j &amp;lt; 1 &amp;lt;&amp;lt; (power - k - 1); j&amp;#43;&amp;#43;) //组数\n                {\n                    butterfly &amp;#61; 1 &amp;lt;&amp;lt; k &amp;#43; 1;//每组有几个元素\n                    //计算参与蝶形运算的两个元素的索引\n                    for (int i &amp;#61; 0; i &amp;lt; butterfly / 2; i&amp;#43;&amp;#43;) //蝶形运算次数\n                    {\n                        //Console.Write(&amp;#34;  ({0}x{1} wtIdx&amp;#61;{2})&amp;#34;, i &amp;#43; p, i &amp;#43; s, i * (1 &amp;lt;&amp;lt; k));\n                        x1 &amp;#61; TD2FD[i &amp;#43; j * butterfly];\n                        x2 &amp;#61; TD2FD[i &amp;#43; butterfly/2 &amp;#43; j * butterfly];\n                        wt &amp;#61; WT[i * TD2FD.Length / butterfly];\n                        TD2FD[i &amp;#43; j * butterfly] &amp;#61; x1 &amp;#43; x2 * wt;\n                        TD2FD[i &amp;#43; butterfly / 2 &amp;#43; j * butterfly] &amp;#61; x1 - x2 * wt;\n                    }\n                    //Console.WriteLine();\n                }\n            }\n        }\n\n        private static int BitReverse(int x)\n        {\n            //倒位排序\n            //0   1   2   3   4   5   6   7   十进制\n            //000 001 010 011 100 101 110 111 十进制对应的二进制\n            //000 100 010 110 001 101 011 111 码位反转\n            //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n            int[] table &amp;#61; new int[8] { 0, 4, 2, 6, 1, 5, 3, 7 };\n            return table[x];\n        }\n\n        // 倒位排序——雷德算法\n        private static void BitReverse(Complex[] array)\n        {\n            int i, j, k;\n            int N &amp;#61; array.Length;\n            Complex temp;\n            j &amp;#61; 0;\n\n            for (i &amp;#61; 0; i &amp;lt; N - 1; i&amp;#43;&amp;#43;)\n            {\n                if (i &amp;lt; j)\n                {\n                    temp &amp;#61; array[i];\n                    array[i] &amp;#61; array[j];\n                    array[j] &amp;#61; temp;\n                }\n\n                // 求j的下一个倒序位\n                // N/2的二进制最高位为1&amp;#xff0c;其他位都为0\n                // 判断最高位是否为1&amp;#xff0c;可与N/2进行比较\n                // 判断次高位是否为1&amp;#xff0c;可与N/4进行比较\n                k &amp;#61; N &amp;gt;&amp;gt; 1;\n\n                //如果k&amp;lt;&amp;#61;j,表示j的最高位为1\n                while (k &amp;lt;&amp;#61; j)\n                {\n                    //当k&amp;lt;&amp;#61;j时&amp;#xff0c;需要将最高位变为0\n                    j &amp;#61; j - k;\n                    //判断次高位是否为1,依次类推&amp;#xff0c;逐个比较&amp;#xff0c;直到j某个位为0\n                    k &amp;gt;&amp;gt;&amp;#61; 1;\n                }\n\n                j &amp;#61; j &amp;#43; k;//将0变为1\n            }\n        }\n\n        // 打印\n        private static void Print(Complex[] TD2FD)\n        {\n            for (int i &amp;#61; 0; i &amp;lt; TD2FD.Length; i&amp;#43;&amp;#43;)\n            {\n                Console.WriteLine(&amp;#34;(re&amp;#61;{0}, im&amp;#61;{1})&amp;#34;, TD2FD[i].re, TD2FD[i].im);\n            }\n            Console.WriteLine();\n        }\n    }\n\n    //定义复数\n    public class Complex\n    {\n        public float re;//实数部\n        public float im;//虚数部\n\n        public static Complex operator &amp;#43;(Complex lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re &amp;#43; rhs.re;\n            result.im &amp;#61; lhs.im &amp;#43; rhs.im;\n            return result;\n        }\n\n        public static Complex operator -(Complex lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re - rhs.re;\n            result.im &amp;#61; lhs.im - rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re * rhs.re - lhs.im * rhs.im;\n            result.im &amp;#61; lhs.re * rhs.im &amp;#43; lhs.im * rhs.re;\n            return result;\n        }\n\n        public static Complex operator *(float lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs * rhs.re;\n            result.im &amp;#61; lhs * rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, float rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re * rhs;\n            result.im &amp;#61; lhs.im * rhs;\n            return result;\n        }\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"630\" src=\"https://img-ask.csdnimg.cn/upload/1615885734075.png\" width=\"481\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;ok&amp;#xff0c;存在可以忽略的误差&amp;#xff0c;很正常&amp;#xff0c;这个没毛病&amp;#xff1b;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["快速傅里叶逆变换未还原数据", ["\n", "using System;\n\nnamespace ConsoleApp34\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int N = 8;\n            //初始化时域数据\n            Complex[] TD2FD = new Complex[N];\n            for (int i = 0; i < N; i++)\n            {\n                Complex cpx = new Complex();\n                cpx.re = i;\n                cpx.im = 0;\n                TD2FD[i] = cpx;\n            }\n\n            Console.WriteLine(\"------原始信号-----\");\n            Print(TD2FD);\n\n            Console.WriteLine(\"----- FFT -----\");\n            FFT(TD2FD);\n            Print(TD2FD);\n\n            Console.WriteLine(\"----- IFFT -----\");\n            IFFT(TD2FD);\n            Print(TD2FD);\n\n            Console.Read();\n        }\n\n        //快速傅里叶变换\n        public static void FFT(Complex[] TD2FD)\n        {\n            FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n        }\n\n        //快速傅里叶逆变换\n        public static void IFFT(Complex[] FD2TD)\n        {\n            //做FFT变换\n            Complex[] WT = WT_LUT(FD2TD.Length, -1);\n            FFT_Core(FD2TD, WT);\n            //实部除以N\n            for (int i = 0; i < FD2TD.Length; i++)\n                FD2TD[i].re /= FD2TD.Length;\n        }\n\n        // 返回旋转因子查询表(twiddle factor lookup table)\n        private static Complex[] WT_LUT(int N, int flag = 1)\n        {\n            Complex[] WT = new Complex[N];\n            for (int i = 0; i < N; i++)\n            {\n                Complex cpx_wt = new Complex();\n                float angle = (float)(-i * Math.PI * 2 / N);\n                cpx_wt.re = (float)Math.Cos(angle);\n                //IFFT flag=-1, FFT flag=1\n                cpx_wt.im = flag * (float)Math.Sin(angle);\n                WT[i] = cpx_wt;\n            }\n            return WT;\n        }\n\n        private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n        {\n            int power = (int)Math.Log(TD2FD.Length, 2);\n            int butterfly;\n            int p, s;\n            Complex x1, x2, wt;\n\n            BitReverse(TD2FD);\n\n            //蝶形运算\n            for (int k = 0; k < power; k++) //级数\n            {\n                //Console.WriteLine(\"第{0}级, 共{1}组\", k, 1 << k);\n                for (int j = 0; j < 1 << k; j++) //组数\n                {\n                    butterfly = 1 << (power - k);//每组有几个元素\n                    //计算参与蝶形运算的两个元素的索引\n                    p = j * butterfly;\n                    s = p + butterfly / 2;\n                    //Console.WriteLine(\"butterfly={0}, p={1}, s={2}\", butterfly, p, s);\n                    for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                    {\n                        //Console.Write(\"  ({0}x{1} wtIdx={2})\", i + p, i + s, i * (1 << k));\n                        x1 = TD2FD[i + p];\n                        x2 = TD2FD[i + s];\n                        wt = WT[i * (1 << k)];\n                        TD2FD[i + p] = x1 + x2 * wt;\n                        TD2FD[i + s] = x1 - x2 * wt;\n                    }\n                    //Console.WriteLine();\n                }\n            }\n        }\n\n        private static int BitReverse(int x)\n        {\n            //倒位排序\n            //0   1   2   3   4   5   6   7   十进制\n            //000 001 010 011 100 101 110 111 十进制对应的二进制\n            //000 100 010 110 001 101 011 111 码位反转\n            //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n            int[] table = new int[8] { 0, 4, 2, 6, 1, 5, 3, 7 };\n            return table[x];\n        }\n\n        // 倒位排序——雷德算法\n        private static void BitReverse(Complex[] array)\n        {\n            int i, j, k;\n            int N = array.Length;\n            Complex temp;\n            j = 0;\n\n            for (i = 0; i < N - 1; i++)\n            {\n                if (i < j)\n                {\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n\n                // 求j的下一个倒序位\n                // N/2的二进制最高位为1，其他位都为0\n                // 判断最高位是否为1，可与N/2进行比较\n                // 判断次高位是否为1，可与N/4进行比较\n                k = N >> 1;\n\n                //如果k<=j,表示j的最高位为1\n                while (k <= j)\n                {\n                    //当k<=j时，需要将最高位变为0\n                    j = j - k;\n                    //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                    k >>= 1;\n                }\n\n                j = j + k;//将0变为1\n            }\n        }\n\n        // 打印\n        private static void Print(Complex[] TD2FD)\n        {\n            for (int i = 0; i < TD2FD.Length; i++)\n            {\n                Console.WriteLine(\"(re={0}, im={1})\", TD2FD[i].re, TD2FD[i].im);\n            }\n            Console.WriteLine();\n        }\n    }\n\n    //定义复数\n    public class Complex\n    {\n        public float re;//实数部\n        public float im;//虚数部\n\n        public static Complex operator +(Complex lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re + rhs.re;\n            result.im = lhs.im + rhs.im;\n            return result;\n        }\n\n        public static Complex operator -(Complex lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re - rhs.re;\n            result.im = lhs.im - rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re * rhs.re;\n            result.im = lhs.im * rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(float lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs * rhs.re;\n            result.im = lhs * rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, float rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re * rhs;\n            result.im = lhs.im * rhs;\n            return result;\n        }\n    }\n}", "\n\n", "\n\n", "请问下我写的IFFT，为什么没还原成原始数据呢(re=0,1,2,3,4,5,6,7)？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考一下这个&lt;a href=\"https://hub.fastgit.org/Subtitle-Synchronizer/jlibrosa\" id=\"textarea_1632928911364_1632929331902_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;GitHub - Subtitle-Synchronizer/jlibrosa: Librosa equivalent Java library to process audio file adn extract features from it.&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Librosa equivalent Java library to process audio file adn extract features from it. - GitHub - Subtitle-Synchronizer/jlibrosa: Librosa equivalent Java library to process audio file adn extract features from it.&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://assets.fastgit.org/favicons/favicon.png\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://hub.fastgit.org/Subtitle-Synchronizer/jlibrosa&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["在Android上如果对音频做快速傅里叶变换", ["我想在Android上实现语音识别，现在已经有模型了，但是不知道如何在Android上对音频做预处理，就是快速傅里叶变换。", "Python上可以使用librosa对音频预处理，但是Android没有相关工具。", "希望能提供代码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;采样频率时1/dx&lt;br /&gt;dx代表你的位置间距&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["对离散信号进行傅里叶变换", ["我现在测得了一条直线上的信号，这个信号只表示不同位置的信号值，跟时间无关。一共900个采样点，请问在matlab里作快速傅里叶变换的时候，采样频率是啥？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;matlab就可以做到呢&lt;br /&gt;类似这样画图&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;Fs &amp;#61; &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;% Sampling frequency&lt;/span&gt;\nT &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;/Fs;             &lt;span class=\"hljs-comment\"&gt;% Sampling period&lt;/span&gt;\nL &amp;#61; &lt;span class=\"hljs-number\"&gt;1500&lt;/span&gt;;             &lt;span class=\"hljs-comment\"&gt;% Length of signal&lt;/span&gt;\nt &amp;#61; (&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:L&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)*T;        &lt;span class=\"hljs-comment\"&gt;% Time vector&lt;/span&gt;\nS &amp;#61; &lt;span class=\"hljs-number\"&gt;0.7&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;sin&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;pi&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;*t) &amp;#43; &lt;span class=\"hljs-built_in\"&gt;sin&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;pi&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;120&lt;/span&gt;*t);\nX &amp;#61; S &amp;#43; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;randn&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(t));\nY &amp;#61; fft(X);\nP2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;abs&lt;/span&gt;(Y/L);\nP1 &amp;#61; P2(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:L/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\nP1(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;) &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*P1(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\nf &amp;#61; Fs*(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:(L/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;))/L;\n&lt;span class=\"hljs-comment\"&gt;%% 画图类似这样就行&amp;#xff0c;用plot3画图&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;figure&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);clf\n&lt;span class=\"hljs-built_in\"&gt;plot3&lt;/span&gt;(f,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;ones&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(f)),P1); &lt;span class=\"hljs-built_in\"&gt;hold&lt;/span&gt; on;\n&lt;span class=\"hljs-built_in\"&gt;plot3&lt;/span&gt;(f,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;ones&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(f)),P1);\n&lt;span class=\"hljs-built_in\"&gt;plot3&lt;/span&gt;(f,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;ones&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(f)),P1);\nset(gca, &lt;span class=\"hljs-string\"&gt;&amp;#39;ytick&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;yticklabel&amp;#39;&lt;/span&gt;, {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;(c)&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;(b)&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;(a)&amp;#39;&lt;/span&gt;})\nxlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;f &amp;#39;&lt;/span&gt;)\nylabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;不同磨损&amp;#39;&lt;/span&gt;)\nzlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;幅值&amp;#39;&lt;/span&gt;)\nbox on\ngrid on\nview(&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;38&lt;/span&gt;)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/868298506836145.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["将不同信号的快速傅里叶变换图画在一张三维图中进行对比，如下图所示，使用什么软件可以做到？", ["\n", "在论文里看到了这张图，将不同信号的快速傅里叶变换图画在一张三维图中进行对比，如上图所示，使用什么软件可以做到？"]], "Tag": "算法设计"}
{"Answer": "建议添加一个opencv的库，这个库里有很多图像处理函数。像傅里叶变换，这个库里就有接口，可以直接调用。\r\n而特征向量的提取，要看你选择的是什么特征。距离的计算方式也有很多种，一般采用欧氏距离。这个可以表征两个特征向量的相似度", "Konwledge_Point": "快速傅里叶变换", "Question": ["vc做基于傅里叶形状描述子的图像检索系统特征向量和距离算法该怎么写啊？", ["  对图像进行快速傅里叶变换后得到的关于图片在频域空间的矩阵如何提取用于图像检索的特征向量，以及这些特征向量距离的计算方式。\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;fft变换&amp;#xff0c;自己看代码&amp;#xff1a;&lt;br /&gt;假设你有时间数组t和信号数组v&amp;#xff0c;如此即可&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;fs &amp;#61; &lt;span class=\"hljs-built_in\"&gt;floor&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;/&lt;span class=\"hljs-built_in\"&gt;mean&lt;/span&gt;(diff(t)));\nx &amp;#61; v;\nn &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;^&lt;span class=\"hljs-built_in\"&gt;floor&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;log2&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;(x)));\nt &amp;#61; t(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:n);\nx &amp;#61; x(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:n);\nL &amp;#61; &lt;span class=\"hljs-built_in\"&gt;numel&lt;/span&gt;(t);\n&lt;span class=\"hljs-comment\"&gt;%然后对x作傅里叶变换&amp;#xff0c;按照采样频率1000&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;%这样的话就会出现200赫兹地方的双冲击&lt;/span&gt;\ny &amp;#61; fft(x,n);\nP2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;abs&lt;/span&gt;(y/L);\nk &amp;#61; &lt;span class=\"hljs-built_in\"&gt;floor&lt;/span&gt;(L/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\nf &amp;#61; (&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)*fs/L;\n&lt;span class=\"hljs-built_in\"&gt;plot&lt;/span&gt;(f(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:k),P2(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:k))\nxlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;频率&amp;#39;&lt;/span&gt;);ylabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;幅值&amp;#39;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一定要注意&amp;#xff0c;采样频率和时间之间的关系&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["关于matlab  FFT问题，时域图很符合预期，但是快速傅里叶变换处理后的频域图失败了", ["计算出的数据进行FFT，频域信号不正确。", "\n", "下图是时域图", "\n", "\n", "下图是我得出的频域图", "\n", "\n", "（频域图的横纵坐标代表什么？）", "\n", "代码如下，v是数据。", "\n", "fs", "=", "10000", ";", "\n", "T", "=", "1", "/fs", ";", "\n", "N", "=length(v)", ";", "\n", "n", "=", "0", ":N-", "1", ";", "\n", "y", "=fft(v,N)", ";", "\n", "mag", "=abs(y)", ";", "\n", "f", "=n*fs/N", ";", "\n", "a", "=f", ";", "\n", "b", "=mag", ";", "\n\n", "\n", "不知道是代码的问题还是别的", "感谢解答"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ok,搞定了&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;引发错误的地方在于&amp;#xff1a;傅里叶逆变换&amp;#xff0c;实数部分和虚数部分都需要除N&amp;#xff0c;你只给实数部分除了N&amp;#xff0c;一维数据没有问题是因为&amp;#xff0c;你的一维数据全是实数&amp;#xff0c;逆变换后虚数部分为0&amp;#xff0c;所以不影响&amp;#xff1b;而二维傅里叶变换需要两次逆变换&amp;#xff08;行和列的逆变换&amp;#xff09;&amp;#xff0c;因此就有了较大影响&amp;#xff1b;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT &amp;#61; WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i &amp;#61; 0; i &amp;lt; FD2TD.Length; i&amp;#43;&amp;#43;)\n        {\n            FD2TD[i].re /&amp;#61; FD2TD.Length;\n            FD2TD[i].im /&amp;#61; FD2TD.Length;\n        }\n    }&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;这样改一下就好了&amp;#xff0c;我不太会输出txt&amp;#xff0c;我用控制台输出试了一下&amp;#xff0c;这是逆变换以后的数据&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"925\" src=\"https://img-ask.csdnimg.cn/upload/1616415175974.png\" width=\"398\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;ok,误差在可忽略的范围内&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;还有一个规范性的问题&amp;#xff0c;一般矩阵&amp;#xff08;row,columns&amp;#xff09;的行是row(Height),列是columns(Width),你刚开始初始化时确实是这么定义的&amp;#xff0c;但后面你就全部反着来了&amp;#xff0c;因为这次输入的是8*8的数据&amp;#xff0c;行列数相等&amp;#xff0c;没有报错&amp;#xff0c;如果下个数据行列数不相等&amp;#xff0c;就有错了&amp;#xff0c;还是规范起来写的好。&amp;#xff08;这个问题不影响你的这次的结果&amp;#xff0c;但还是改掉的好&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["我写的二维傅里叶逆变换未还原数据，求帮忙调试下!", ["先说下问题：", "\n\n", "我用8x8的数据测试FFT2和IFFT2两个算法，发现数据未还原，求帮忙检查下代码哪写错了？", "\n\n", "(注：如果只对每一行或者每一列做FFT和IFFT，可以还原数据。)", "\n\n", "打印的日志下如", "\n\n", "\n\n", "封装的傅里叶变换类", "\n\n", "\n", "using System;\n\n/// <summary>\n/// 傅里叶变换\n/// </summary>\npublic sealed class Fourier\n{\n    //快速傅里叶变换\n    public static void FFT(Complex[] TD2FD)\n    {\n        FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n    }\n\n    //快速傅里叶变换 (二维)\n    public static void FFT2(Complex2D TD2FD)\n    {\n        //对每一行做FFT\n        for (int i = 0; i < TD2FD.Height; i++)\n        {\n            Complex[] row = TD2FD.GetRow(i);\n            FFT(row);\n            TD2FD.SetRow(i, row);\n        }\n\n        //对每一列做FFT\n        for (int i = 0; i < TD2FD.Width; i++)\n        {\n            Complex[] column = TD2FD.GetColumn(i);\n            FFT(column);\n            TD2FD.SetColumn(i, column);\n        }\n    }\n\n    //快速傅里叶逆变换\n    public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT = WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i = 0; i < FD2TD.Length; i++)\n            FD2TD[i].re /= FD2TD.Length;\n    }\n\n    //快速傅里叶逆变换 (二维)\n    public static void IFFT2(Complex2D FD2TD)\n    {\n        //对每一行做IFFT\n        for (int i = 0; i < FD2TD.Height; i++)\n        {\n            Complex[] row = FD2TD.GetRow(i);\n            IFFT(row);\n            FD2TD.SetRow(i, row);\n        }\n\n        //对每一列做IFFT\n        for (int i = 0; i < FD2TD.Width; i++)\n        {\n            Complex[] column = FD2TD.GetColumn(i);\n            IFFT(column);\n            FD2TD.SetColumn(i, column);\n        }\n    }\n\n    // 将直流分量移到频谱图的中心\n    public static void FFT2Shift(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        //将图像四个象限区域按对角线交换\n        for (int i=0; i<halfH; i++)\n        {\n            for (int j=0; j<complex2D.Width; j++)\n            {\n                if (j < halfW)\n                    complex2D.SwapComplex(i, j, i + halfH, j + halfW);\n                else\n                    complex2D.SwapComplex(i, j, i + halfH, j - halfW);\n            }\n        }\n    }\n\n    // 高通滤波\n    public static void HighPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i = halfH - H4; i < halfH + H4; i++)\n        {\n            for (int j = halfW - W4; j < halfW + W4; j++)\n            {\n                Complex cpx = complex2D.GetComplex(i, j);\n                cpx.re = 0;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n    }\n\n    // 低通滤波\n    public static void LowPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i=0; i < complex2D.Height; i++)\n        {\n            for (int j=0; j < complex2D.Width; j++)\n            {\n                if (i < halfH - H4 || i > halfH + H4 ||\n                    j < halfW - W4 || j > halfW + W4)\n                {\n                    Complex cpx = complex2D.GetComplex(i, j);\n                    cpx.re = 0;\n                    cpx.im = 0;\n                    complex2D.SetComplex(i, j, cpx);\n                }\n            }    \n        }\n    }\n\n    // 返回旋转因子查询表(twiddle factor lookup table)\n    private static Complex[] WT_LUT(int N, int flag = 1)\n    {\n        Complex[] WT = new Complex[N];\n        for (int i = 0; i < N; i++)\n        {\n            Complex cpx_wt = new Complex();\n            float angle = (float)(-i * Math.PI * 2 / N);\n            cpx_wt.re = (float)Math.Cos(angle);\n            //IFFT flag=-1, FFT flag=1\n            cpx_wt.im = flag * (float)Math.Sin(angle);\n            WT[i] = cpx_wt;\n        }\n        return WT;\n    }\n\n    private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n    {\n        int power = (int)Math.Log(TD2FD.Length, 2);\n        int butterfly;\n        int p, s;\n        Complex x1, x2, wt;\n\n        //倒位排序\n        BitReverse(TD2FD);\n\n        //蝶形运算\n        for (int k = 0; k < power; k++) //级数\n        {\n            for (int j = 0; j < 1 << (power - k - 1); j++) //组数\n            {\n                //每组有几个元素\n                butterfly = 1 << k + 1;\n                //计算参与蝶形运算的两个元素的索引\n                p = j * butterfly;\n                s = p + butterfly / 2;\n                for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                {\n                    x1 = TD2FD[i + p];\n                    x2 = TD2FD[i + s];\n                    wt = WT[i * TD2FD.Length / butterfly];\n                    TD2FD[i + p] = x1 + x2 * wt;\n                    TD2FD[i + s] = x1 - x2 * wt;\n                }\n            }\n        }\n    }\n\n    // 倒位排序——雷德算法\n    private static void BitReverse(Complex[] array)\n    {\n        //倒位排序原理\n        //0   1   2   3   4   5   6   7   十进制\n        //000 001 010 011 100 101 110 111 十进制对应的二进制\n        //000 100 010 110 001 101 011 111 码位反转\n        //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n\n        int i, j, k;\n        int N = array.Length;\n        Complex temp;\n        j = 0;\n\n        for (i = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n            // 求j的下一个倒序位\n            // N/2的二进制最高位为1，其他位都为0\n            // 判断最高位是否为1，可与N/2进行比较\n            // 判断次高位是否为1，可与N/4进行比较\n            k = N >> 1;\n            //如果k<=j,表示j的最高位为1\n            while (k <= j)\n            {\n                //当k<=j时，需要将最高位变为0\n                j = j - k;\n                //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                k >>= 1;\n            }\n            j = j + k;//将0变为1\n        }\n    }\n\n    // 打印\n    public static void Print(Complex[] TD2FD)\n    {\n        for (int i = 0; i < TD2FD.Length; i++)\n        {\n            Console.WriteLine(TD2FD[i].ToString());\n        }\n        Console.WriteLine();\n    }\n}\n\n//定义复数\npublic class Complex\n{\n    public float re;//实数部\n    public float im;//虚数部\n\n    // 幅值\n    public double Amplitude\n    {\n        get\n        {\n            //测试发现取值范围为\n            //min=0.0009918213, max=412.4615\n            return Math.Sqrt(re * re + im * im);\n        }\n    }\n\n    // 频谱图像素值\n    public double PixelAmplitude\n    {\n        get\n        {\n            //幅值范围很大,需要做以下处理:\n            //1. 将幅值范围调到 [1, ?]\n            //2. 利用Log函数压缩范围\n            //3. 将范围映射到颜色值[0,1]\n            double p = Math.Log(Amplitude * 10000) / 16f;\n            return p;\n        }\n    }\n\n    // 相位\n    public double Phase\n    {\n        get\n        {\n            return Math.Atan2(im, re);\n        }\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"re={0}, im={1}\", re, im);\n    }\n\n    public static Complex operator +(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re + rhs.re;\n        result.im = lhs.im + rhs.im;\n        return result;\n    }\n\n    public static Complex operator -(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re - rhs.re;\n        result.im = lhs.im - rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs.re - lhs.im * rhs.im;\n        result.im = lhs.re * rhs.im + lhs.im * rhs.re;\n        return result;\n    }\n\n    public static Complex operator *(float lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs * rhs.re;\n        result.im = lhs * rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, float rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs;\n        result.im = lhs.im * rhs;\n        return result;\n    }\n}\n\npublic class Complex2D\n{\n    private Complex[,] matrix;\n    private int m_width;\n    private int m_height;\n\n    // width:图像宽度 height:图像高度\n    public Complex2D(int width, int height)\n    {\n        m_width = width;\n        m_height = height;\n        matrix = new Complex[width, height];\n    }\n\n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n\n    public Complex[] GetRow(int i)\n    {\n        Complex[] row = new Complex[m_width];\n        for (int j = 0; j < m_width; j++)\n            row[j] = matrix[j,i];\n        return row;\n    }\n\n    public void SetRow(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[j, i] = array[j];\n    }\n\n    public Complex[] GetColumn(int i)\n    {\n        Complex[] column = new Complex[m_height];\n        for (int j = 0; j < m_height; j++)\n            column[j] = matrix[i,j];\n        return column;\n    }\n\n    public void SetColumn(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[i, j] = array[j];\n    }\n\n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return matrix[j,i];\n    }\n\n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        matrix[j, i] = src;\n    }\n\n    // 交换两个元素\n    // i: 第几行  j: 第几列\n    public void SwapComplex(int i0, int j0, int i1, int j1)\n    {\n        Complex tmp = matrix[j0,i0];\n        matrix[j0, i0] = matrix[j1, i1];\n        matrix[j1, i1] = tmp;\n    }\n\n    // 交换行\n    public void SwapRow(int i, int j)\n    {\n        for (int k=0; k<m_width; k++)\n        {\n            Complex cpx0 = matrix[k,i];\n            Complex cpx1 = matrix[k,j];\n            matrix[k,i] = cpx1;\n            matrix[k,j] = cpx0;\n        }\n    }\n\n    // 交换列\n    public void SwapColumn(int i, int j)\n    {\n        for (int k = 0; k < m_height; k++)\n        {\n            Complex cpx0 = matrix[i,k];\n            Complex cpx1 = matrix[j,k];\n            matrix[i,k] = cpx1;\n            matrix[j,k] = cpx0;\n        }\n    }\n\n    public void Print(string fileName)\n    {\n        System.Text.StringBuilder sb = new System.Text.StringBuilder();\n        for (int i = 0; i < m_height; i++)\n        {\n            for (int j = 0; j < m_width; j++)\n                sb.AppendFormat(\"{0:G} \", matrix[j,i].re.ToString().PadRight(5));\n            sb.AppendLine();\n        }\n        System.IO.File.WriteAllText(string.Format(\"D://{0}.txt\", fileName), sb.ToString());\n    }\n}\n", "\n\n", "测试代码", "\n\n", "\n", "//测试\n        Complex2D complex2D = new Complex2D(8, 8);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            for (int j = 0; j < complex2D.Width; j++)\n            {\n                Complex cpx = new Complex();\n                cpx.re = i * complex2D.Width + j;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n\n        complex2D.Print(\"8x8\");\n        Fourier.FFT2(complex2D);\n        complex2D.Print(\"fft2\");\n        Fourier.IFFT2(complex2D);\n        complex2D.Print(\"ifft2\");"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;百度搜设置Nuget在线源&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["想要在VS2019中安装math net.Numerisc但是出现如下错误是为什么？", ["\n", "\n", "今天发现快速傅里叶变换的逆变换有了错误，所以在搜索资料时发现了mathnet.Nuerics工具包据说可以调用，所以想要下载一下，但是出现了错误。", "请问大噶知道为什么吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;将第二行改为&amp;#xff0c;N1&amp;#61;length(a)。因为函数height在MATLAB中不存在&amp;#xff0c;只有length函数用于获取数组的长度。&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["【matlab】未定义与 'double' 类型的输入参数相对应的函数 'height'", ["如题，代码是对结构体数组中的变量进行快速傅里叶变换", "第二行报错：未定义与 'double' 类型的输入参数相对应的函数 'height'。", "\n", "a", "=getfield(dec_1D,", "'coefs'", ")", ";", "\n", "N1", "=height(a)", ";", "\n", "Fs1", "=", "10", ";", "\n", "T1", "=", "1", "/Fs1", ";", "\n", "t1", "=(", "0", ":", "1", ":N-", "1", ")*T1", ";", "\n", "t1", "=t1", "';\nA1 = fft(a);", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;先说你程序的错误&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;傅里叶变换和逆变换都没毛病&amp;#xff0c;但你的二维复数矩阵的定义&amp;#xff0c;错了&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;我标出来了&amp;#xff0c;你自己应该能改出来&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;public class Complex2D\n{\n    private List&amp;lt;Complex[]&amp;gt; rows &amp;#61; new List&amp;lt;Complex[]&amp;gt;();\n    private List&amp;lt;Complex[]&amp;gt; columns &amp;#61; new List&amp;lt;Complex[]&amp;gt;();\n    private int m_width;\n    private int m_height;\n \n    public Complex2D(int width, int height)\n    {\n        m_width &amp;#61; width;\n        m_height &amp;#61; height;\n        for (int i &amp;#61; 0; i &amp;lt; height; i&amp;#43;&amp;#43;)\n            rows.Add(new Complex[width]);   //row[0]~row[height-1]\n        for (int i &amp;#61; 0; i &amp;lt; width; i&amp;#43;&amp;#43;)\n            columns.Add(new Complex[height]);//columns[0]~columns[height-1]\n    }                                        //你这里相当于定义了两个矩阵&amp;#xff0c;一个是行向量组成&amp;#xff0c;一个列向量组成&amp;#xff1b;按你的思路&amp;#xff0c;你后面的应该始终保持这两个矩阵相等才对&amp;#xff1b;\n \n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n \n    public Complex[] GetRow(int i)\n    {\n        return rows[i];\n    }\n \n    public Complex[] GetColumn(int i)\n    {\n        return columns[i];\n    }\n \n    public void SetRow(int i, Complex[] src)\n    {\n        rows[i] &amp;#61; src;  //你只行向量&amp;#xff1f;&amp;#xff1f;你如果改了第一行的值&amp;#xff0c;那每一列的第一个值也就跟着变了&amp;#xff0c;你没改&amp;#xff0c;你如果此时读第一列的值&amp;#xff0c;你会发现row[i][j],columns[j][i],不一样\n    }\n \n    public void SetColumn(int i, Complex[] src)\n    {\n        columns[i] &amp;#61; src;  //和上面同理\n    }\n \n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return rows[i][j];  //你的更改行和列有问题&amp;#xff0c;columns[j][i]和row[i][j]不一样了\n    }\n \n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        rows[i][j] &amp;#61; src;   //额。。。。你这里行和列改了&amp;#xff0c;说明你注意到了&amp;#xff0c;然而前面却不改。。\n        columns[j][i] &amp;#61; src;\n    }\n \n    public void SetComplexs(Complex[][] src)\n    {\n        for (int i &amp;#61; 0; i &amp;lt; src.Length; i&amp;#43;&amp;#43;)\n        {\n            Complex[] row &amp;#61; src[i];      //这里你又是只改变了row的值&amp;#xff0c;不改columns\n            for (int j &amp;#61; 0; j &amp;lt; row.Length; j&amp;#43;&amp;#43;)\n                SetComplex(i, j, row[j]);\n        }\n    }\n \n    public void Print()\n    {\n        for (int i &amp;#61; 0; i &amp;lt; rows.Count; i&amp;#43;&amp;#43;)\n        {\n            Complex[] row &amp;#61; rows[i];\n            for (int j &amp;#61; 0; j &amp;lt; row.Length; j&amp;#43;&amp;#43;)\n                Console.Write(&amp;#34;{0:G} &amp;#34;, row[j].re.ToString().PadRight(5));\n            Console.WriteLine();\n        }\n        Console.WriteLine();\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;1.你的傅里叶变换没问题&amp;#xff1b;我看了几遍&amp;#xff0c;确实找不出有啥问题&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;2.是幅度&amp;#xff08;模&amp;#xff09;&amp;#xff0c;还要考虑复数部&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;3.应该不对&amp;#xff0c;我记得中心化应该是把矩阵分成四块&amp;#xff0c;重新排序&amp;#xff0c;你写的shift没看懂什么意思&amp;#xff0c;不过就算不考虑中心化&amp;#xff0c;你的图也不对&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;下面四张图分别是&amp;#xff0c;中心化后的实部&amp;#xff0c;虚部&amp;#xff0c;幅度&amp;#xff0c;和未中心化的幅度谱&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"828\" src=\"https://img-ask.csdnimg.cn/upload/1616123239140.png\" width=\"974\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;C#我不太懂&amp;#xff0c;我用python写的&amp;#xff0c;求幅度&amp;#xff08;模&amp;#xff09;&amp;#xff0c;然后中心化&amp;#xff0c;在取对数&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;freq &amp;#61; 20*np.log10(0.01 &amp;#43; np.abs(fp.fftshift(freq1)))&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;看你的情况&amp;#xff0c;应该把二维复数那一块改一改应该就好了&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["请教下关于FFT算法生成频谱图的问题", ["我理解的大体思路是：", "\n\n", "1、将图像的灰度值作为输入数据代入FFT算法，生成结果A", "\n\n", "2、直接用A的实部值作为像素值生成频谱图", "\n\n", "但是我发现生成的频谱图布局不对。", "\n\n", "用幅度值作为像素值生成的频谱图", "\n\n", "\n\n", "\n\n", "现在我有3个疑问：", "\n\n", "1、将图像灰度值数据代入FFT，再直接IFFT，得到一张正确的灰度图像，是否说明写的FFT和IFFT算法没问题？", "\n\n", "2、频谱图的像素值是由FFT结果数据的实部值生成吗？", "\n\n", "3、代码中的中心化方法FFT2Shift()是我这样写的吗（不确定对公式是否理解正确）？", "\n\n", " ", "\n\n", "在线对图像做傅里叶变换 ", "https://sci2fig.herokuapp.com/fourier", "\n\n", "\n\n", " ", "\n\n", "下面给出我封装的傅里叶变换类", "\n\n", "\n", "using System;\n\n/// <summary>\n/// 傅里叶变换\n/// </summary>\npublic sealed class Fourier\n{\n    //快速傅里叶变换\n    public static void FFT(Complex[] TD2FD)\n    {\n        FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n    }\n\n    //快速傅里叶变换 (二维)\n    public static void FFT2(Complex2D TD2FD)\n    {\n        //对每一行做FFT\n        for (int i = 0; i < TD2FD.Height; i++)\n        {\n            Complex[] row = TD2FD.GetRow(i);\n            FFT(row);\n            TD2FD.SetRow(i, row);\n        }\n\n        //对每一列做FFT\n        for (int i = 0; i < TD2FD.Width; i++)\n        {\n            Complex[] column = TD2FD.GetColumn(i);\n            FFT(column);\n            TD2FD.SetColumn(i, column);\n        }\n    }\n\n    //快速傅里叶逆变换\n    public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT = WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i = 0; i < FD2TD.Length; i++)\n            FD2TD[i].re /= FD2TD.Length;\n    }\n\n    //快速傅里叶逆变换 (二维)\n    public static void IFFT2(Complex2D FD2TD)\n    {\n        //对每一行做IFFT\n        for (int i = 0; i < FD2TD.Height; i++)\n        {\n            Complex[] row = FD2TD.GetRow(i);\n            IFFT(row);\n            FD2TD.SetRow(i, row);\n        }\n\n        //对每一列做IFFT\n        for (int i = 0; i < FD2TD.Width; i++)\n        {\n            Complex[] column = FD2TD.GetColumn(i);\n            IFFT(column);\n            FD2TD.SetColumn(i, column);\n        }\n    }\n\n    // 将直流分量移到频谱图的中心\n    public static void FFT2Shift(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        //将图像四个象限区域按对角线交换\n        for (int i=0; i<halfH; i++)\n        {\n            for (int j=0; j<complex2D.Width; j++)\n            {\n                if (j < halfW)\n                    complex2D.SwapComplex(i, j, i + halfH, j + halfW);\n                else\n                    complex2D.SwapComplex(i, j, i + halfH, j - halfW);\n            }\n        }\n    }\n\n    // 高通滤波\n    public static void HighPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i = halfH - H4; i < halfH + H4; i++)\n        {\n            for (int j = halfW - W4; j < halfW + W4; j++)\n            {\n                Complex cpx = complex2D.GetComplex(i, j);\n                cpx.re = 0;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n    }\n\n    // 低通滤波\n    public static void LowPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i=0; i < complex2D.Height; i++)\n        {\n            for (int j=0; j < complex2D.Width; j++)\n            {\n                if (i < halfH - H4 || i > halfH + H4 ||\n                    j < halfW - W4 || j > halfW + W4)\n                {\n                    Complex cpx = complex2D.GetComplex(i, j);\n                    cpx.re = 0;\n                    cpx.im = 0;\n                    complex2D.SetComplex(i, j, cpx);\n                }\n            }    \n        }\n    }\n\n    // 返回旋转因子查询表(twiddle factor lookup table)\n    private static Complex[] WT_LUT(int N, int flag = 1)\n    {\n        Complex[] WT = new Complex[N];\n        for (int i = 0; i < N; i++)\n        {\n            Complex cpx_wt = new Complex();\n            float angle = (float)(-i * Math.PI * 2 / N);\n            cpx_wt.re = (float)Math.Cos(angle);\n            //IFFT flag=-1, FFT flag=1\n            cpx_wt.im = flag * (float)Math.Sin(angle);\n            WT[i] = cpx_wt;\n        }\n        return WT;\n    }\n\n    private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n    {\n        int power = (int)Math.Log(TD2FD.Length, 2);\n        int butterfly;\n        int p, s;\n        Complex x1, x2, wt;\n\n        //倒位排序\n        BitReverse(TD2FD);\n\n        //蝶形运算\n        for (int k = 0; k < power; k++) //级数\n        {\n            for (int j = 0; j < 1 << (power - k - 1); j++) //组数\n            {\n                //每组有几个元素\n                butterfly = 1 << k + 1;\n                //计算参与蝶形运算的两个元素的索引\n                p = j * butterfly;\n                s = p + butterfly / 2;\n                for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                {\n                    x1 = TD2FD[i + p];\n                    x2 = TD2FD[i + s];\n                    wt = WT[i * TD2FD.Length / butterfly];\n                    TD2FD[i + p] = x1 + x2 * wt;\n                    TD2FD[i + s] = x1 - x2 * wt;\n                }\n            }\n        }\n    }\n\n    // 倒位排序——雷德算法\n    private static void BitReverse(Complex[] array)\n    {\n        //倒位排序原理\n        //0   1   2   3   4   5   6   7   十进制\n        //000 001 010 011 100 101 110 111 十进制对应的二进制\n        //000 100 010 110 001 101 011 111 码位反转\n        //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n\n        int i, j, k;\n        int N = array.Length;\n        Complex temp;\n        j = 0;\n\n        for (i = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n            // 求j的下一个倒序位\n            // N/2的二进制最高位为1，其他位都为0\n            // 判断最高位是否为1，可与N/2进行比较\n            // 判断次高位是否为1，可与N/4进行比较\n            k = N >> 1;\n            //如果k<=j,表示j的最高位为1\n            while (k <= j)\n            {\n                //当k<=j时，需要将最高位变为0\n                j = j - k;\n                //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                k >>= 1;\n            }\n            j = j + k;//将0变为1\n        }\n    }\n\n    // 打印\n    public static void Print(Complex[] TD2FD)\n    {\n        for (int i = 0; i < TD2FD.Length; i++)\n        {\n            Console.WriteLine(TD2FD[i].ToString());\n        }\n        Console.WriteLine();\n    }\n}\n\n//定义复数\npublic class Complex\n{\n    public float re;//实数部\n    public float im;//虚数部\n\n    // 幅值\n    public double Amplitude\n    {\n        get\n        {\n            //测试发现取值范围为\n            //min=0.0009918213, max=412.4615\n            return Math.Sqrt(re * re + im * im);\n        }\n    }\n\n    // 频谱图像素值\n    public double PixelAmplitude\n    {\n        get\n        {\n            //幅值范围很大,需要做以下处理:\n            //1. 将幅值范围调到 [1, ?]\n            //2. 利用Log函数压缩范围\n            //3. 将范围映射到颜色值[0,1]\n            double p = Math.Log(Amplitude * 10000) / 16f;\n            return p;\n        }\n    }\n\n    // 相位\n    public double Phase\n    {\n        get\n        {\n            return Math.Atan2(im, re);\n        }\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"re={0}, im={1}\", re, im);\n    }\n\n    public static Complex operator +(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re + rhs.re;\n        result.im = lhs.im + rhs.im;\n        return result;\n    }\n\n    public static Complex operator -(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re - rhs.re;\n        result.im = lhs.im - rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs.re - lhs.im * rhs.im;\n        result.im = lhs.re * rhs.im + lhs.im * rhs.re;\n        return result;\n    }\n\n    public static Complex operator *(float lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs * rhs.re;\n        result.im = lhs * rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, float rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs;\n        result.im = lhs.im * rhs;\n        return result;\n    }\n}\n\npublic class Complex2D\n{\n    private Complex[,] matrix;\n    private int m_width;\n    private int m_height;\n\n    // width:图像宽度 height:图像高度\n    public Complex2D(int width, int height)\n    {\n        m_width = width;\n        m_height = height;\n        matrix = new Complex[width, height];\n    }\n\n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n\n    public Complex[] GetRow(int i)\n    {\n        Complex[] row = new Complex[m_width];\n        for (int j = 0; j < m_width; j++)\n            row[j] = matrix[j,i];\n        return row;\n    }\n\n    public void SetRow(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[j, i] = array[j];\n    }\n\n    public Complex[] GetColumn(int i)\n    {\n        Complex[] column = new Complex[m_height];\n        for (int j = 0; j < m_height; j++)\n            column[j] = matrix[i,j];\n        return column;\n    }\n\n    public void SetColumn(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[i, j] = array[j];\n    }\n\n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return matrix[j,i];\n    }\n\n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        matrix[j, i] = src;\n    }\n\n    // 交换两个元素\n    // i: 第几行  j: 第几列\n    public void SwapComplex(int i0, int j0, int i1, int j1)\n    {\n        Complex tmp = matrix[j0,i0];\n        matrix[j0, i0] = matrix[j1, i1];\n        matrix[j1, i1] = tmp;\n    }\n\n    // 交换行\n    public void SwapRow(int i, int j)\n    {\n        for (int k=0; k<m_width; k++)\n        {\n            Complex cpx0 = matrix[k,i];\n            Complex cpx1 = matrix[k,j];\n            matrix[k,i] = cpx1;\n            matrix[k,j] = cpx0;\n        }\n    }\n\n    // 交换列\n    public void SwapColumn(int i, int j)\n    {\n        for (int k = 0; k < m_height; k++)\n        {\n            Complex cpx0 = matrix[i,k];\n            Complex cpx1 = matrix[j,k];\n            matrix[i,k] = cpx1;\n            matrix[j,k] = cpx0;\n        }\n    }\n\n    public void Print(string fileName)\n    {\n        System.Text.StringBuilder sb = new System.Text.StringBuilder();\n        for (int i = 0; i < m_height; i++)\n        {\n            for (int j = 0; j < m_width; j++)\n                sb.AppendFormat(\"{0:G} \", matrix[j,i].re.ToString().PadRight(5));\n            sb.AppendLine();\n        }\n        System.IO.File.WriteAllText(string.Format(\"D://{0}.txt\", fileName), sb.ToString());\n    }\n}\n", "\n\n", "我的测试是在Unity中做的，下面给出我的辅助类", "\n\n", "\n", "using UnityEngine;\n\npublic sealed class FourierHelper\n{\n    public static Texture2D ToTexture2D(Complex2D complex2D)\n    {\n        Texture2D tex = new Texture2D(complex2D.Width, complex2D.Height, TextureFormat.RGBA32, false);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            Complex[] cpxs = complex2D.GetRow(i);\n            for (int j = 0; j < cpxs.Length; j++)\n            {\n                Complex cpx = cpxs[j];\n                tex.SetPixel(j, i, new Color(cpx.re, cpx.re, cpx.re));\n            }\n        }\n        tex.Apply();\n        return tex;\n    }\n\n    // 转成频谱图\n    public static Texture2D ToSpectrumTexture2D(Complex2D complex2D)\n    {\n        float min = float.MaxValue;\n        float max = float.MinValue;\n        Texture2D tex = new Texture2D(complex2D.Width, complex2D.Height, TextureFormat.RGBA32, false);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            Complex[] cpxs = complex2D.GetRow(i);\n            for (int j = 0; j < cpxs.Length; j++)\n            {\n                Complex cpx = cpxs[j];\n                float p = (float)cpx.PixelAmplitude;\n                tex.SetPixel(j, i, new Color(p, p, p));\n                if (p < min)\n                    min = p;\n                if (p > max)\n                    max = p;\n            }\n        }\n        tex.Apply();\n        return tex;\n    }\n\n    public static Complex2D ToComplex2D(Texture2D tex)\n    {\n        Complex2D complex2D = new Complex2D(tex.width, tex.height);\n\n        for (int y = 0; y < tex.height; y++)\n        {\n            for (int x = 0; x < tex.width; x++)\n            {\n                Color c = tex.GetPixel(x, y);\n                Complex cpx = new Complex();\n                cpx.re = c.r * 0.3f + c.g * 0.59f + c.b * 0.11f; //灰度值\n                cpx.im = 0;\n                complex2D.SetComplex(y, x, cpx);\n            }\n        }\n\n        return complex2D;\n    }\n}\n", "\n\n", "FFT->IFFT测试代码", "\n\n", "\n", "using UnityEngine;\nusing UnityEngine.UI;\n/// <summary>\n/// 测试FFT->IFFT算法\n/// </summary>\npublic class FFT_IFFT_Test : MonoBehaviour\n{\n    public RawImage rawImage;\n\n    private void Start()\n    {\n        Texture2D tex = rawImage.texture as Texture2D;\n        Complex2D complex2D = FourierHelper.ToComplex2D(tex);\n\n        Fourier.FFT2(complex2D);\n        Fourier.IFFT2(complex2D);\n\n        Texture2D ifft_tex = FourierHelper.ToTexture2D(complex2D);\n        rawImage.texture = ifft_tex;\n    }\n}\n", "\n\n", "频谱图生成代码", "\n\n", "\n", "using UnityEngine;\nusing UnityEngine.UI;\n/// <summary>\n/// 显示频谱图\n/// </summary>\npublic class SpectrumTexture : MonoBehaviour\n{\n    public RawImage rawImage;\n\n    private void Start()\n    {\n        Texture2D tex = rawImage.texture as Texture2D;\n        Complex2D complex2D = FourierHelper.ToComplex2D(tex);\n\n        Fourier.FFT2(complex2D);\n\n        Texture2D sp_tex = FourierHelper.ToTexture2D(complex2D);\n        rawImage.texture = sp_tex;\n    }\n}\n", "\n\n", "如有需要也可下载我的测试工程(Unity)", "\n\n", "链接：https://pan.baidu.com/s/1B62muufCP-tWQklPT5H49Q ", "\n提取码：z6ku ", "\n\n", " ", "\n\n", "补充：IFFT2未还原数据", "\n\n", "@ 皮皮宽", "\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;频谱图比较亮的地方就是低频&amp;#xff0c;因为图像的能量一般都是集中在低频部分&amp;#xff0c;&lt;br /&gt;频谱中心化以后&amp;#xff0c;就是低频在中间高频在四周了。&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/359546560156113.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["傅里叶变换关于频谱图横纵坐标的意义的疑问", ["dft将时域f（x,y）转化为频域F（u,v），这里的u和v不就代表频率大小嘛。那按道理应该未中心化的频谱图上右下角（u-1,v-1）是最高频信息，可是为什么一直说未中心化的频谱图中心是高频信息而四角是低频信息呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;赚个外块真不容易&amp;#xff0c;看了一下午&amp;#xff0c;&lt;/p&gt;\n\n&lt;p&gt;你的问题如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;1&amp;#xff0c;乘法错了&amp;#xff0c; 复数的乘法&amp;#xff0c;你写错了&amp;#xff1b;(a &amp;#43; b j) * (c &amp;#43; d j) &amp;#61; ac-bd &amp;#43; (bc &amp;#43; ad) j &lt;/p&gt;\n\n&lt;p&gt;2.  你蝶形运算错了&amp;#xff0c;你在好好对照蝶形图捋一捋&amp;#xff0c;比如&amp;#xff0c;第0级对应的旋转因子都是0&amp;#xff0c;你的0123&amp;#xff0c;第1级是0202&amp;#xff0c;你的0202&amp;#xff0c;第2级0123&amp;#xff0c;你的0000&amp;#xff0c;刚好反了&amp;#xff0c;你的分组和每组的数&amp;#xff0c;有问题&amp;#xff0c;你再好好捋一捋吧&lt;/p&gt;\n\n&lt;p&gt;附上修改后的程序和运行结果&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;using System;\n\nnamespace ConsoleApp34\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int N &amp;#61; 8;\n            //初始化时域数据\n            Complex[] TD2FD &amp;#61; new Complex[N];\n            for (int i &amp;#61; 0; i &amp;lt; N; i&amp;#43;&amp;#43;)\n            {\n                Complex cpx &amp;#61; new Complex();\n                cpx.re &amp;#61; i;\n                cpx.im &amp;#61; 0;\n                TD2FD[i] &amp;#61; cpx;\n            }\n\n            Console.WriteLine(&amp;#34;------原始信号-----&amp;#34;);\n            Print(TD2FD);\n\n            Console.WriteLine(&amp;#34;----- FFT -----&amp;#34;);\n            FFT(TD2FD);\n            Print(TD2FD);\n\n            Console.WriteLine(&amp;#34;----- IFFT -----&amp;#34;);\n            IFFT(TD2FD);\n            Print(TD2FD);\n\n            Console.Read();\n        }\n\n        //快速傅里叶变换\n        public static void FFT(Complex[] TD2FD)\n        {\n            FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n        }\n\n        //快速傅里叶逆变换\n        public static void IFFT(Complex[] FD2TD)\n        {\n            //做FFT变换\n            Complex[] WT &amp;#61; WT_LUT(FD2TD.Length, -1);\n            FFT_Core(FD2TD, WT);\n            //实部除以N\n            for (int i &amp;#61; 0; i &amp;lt; FD2TD.Length; i&amp;#43;&amp;#43;)\n                FD2TD[i].re /&amp;#61; FD2TD.Length;\n        }\n\n        // 返回旋转因子查询表(twiddle factor lookup table)\n        private static Complex[] WT_LUT(int N, int flag &amp;#61; 1)\n        {\n            Complex[] WT &amp;#61; new Complex[N];\n            for (int i &amp;#61; 0; i &amp;lt; N; i&amp;#43;&amp;#43;)\n            {\n                Complex cpx_wt &amp;#61; new Complex();\n                float angle &amp;#61; (float)(-i * Math.PI * 2 / N);\n                cpx_wt.re &amp;#61; (float)Math.Cos(angle);\n                //IFFT flag&amp;#61;-1, FFT flag&amp;#61;1\n                cpx_wt.im &amp;#61; flag * (float)Math.Sin(angle);\n                WT[i] &amp;#61; cpx_wt;\n            }\n            return WT;\n        }\n\n        private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n        {\n            int power &amp;#61; (int)Math.Log(TD2FD.Length, 2);\n            int butterfly;\n            Complex x1, x2, wt;\n            BitReverse(TD2FD);\n\n            //蝶形运算\n            for (int k &amp;#61; 0; k &amp;lt; power; k&amp;#43;&amp;#43;) //级数\n            {\n                //Console.WriteLine(&amp;#34;第{0}级, 共{1}组&amp;#34;, k, 1 &amp;lt;&amp;lt; k);\n                for (int j &amp;#61; 0; j &amp;lt; 1 &amp;lt;&amp;lt; (power - k - 1); j&amp;#43;&amp;#43;) //组数\n                {\n                    butterfly &amp;#61; 1 &amp;lt;&amp;lt; k &amp;#43; 1;//每组有几个元素\n                    //计算参与蝶形运算的两个元素的索引\n                    for (int i &amp;#61; 0; i &amp;lt; butterfly / 2; i&amp;#43;&amp;#43;) //蝶形运算次数\n                    {\n                        //Console.Write(&amp;#34;  ({0}x{1} wtIdx&amp;#61;{2})&amp;#34;, i &amp;#43; p, i &amp;#43; s, i * (1 &amp;lt;&amp;lt; k));\n                        x1 &amp;#61; TD2FD[i &amp;#43; j * butterfly];\n                        x2 &amp;#61; TD2FD[i &amp;#43; butterfly/2 &amp;#43; j * butterfly];\n                        wt &amp;#61; WT[i * TD2FD.Length / butterfly];\n                        TD2FD[i &amp;#43; j * butterfly] &amp;#61; x1 &amp;#43; x2 * wt;\n                        TD2FD[i &amp;#43; butterfly / 2 &amp;#43; j * butterfly] &amp;#61; x1 - x2 * wt;\n                    }\n                    //Console.WriteLine();\n                }\n            }\n        }\n\n        private static int BitReverse(int x)\n        {\n            //倒位排序\n            //0   1   2   3   4   5   6   7   十进制\n            //000 001 010 011 100 101 110 111 十进制对应的二进制\n            //000 100 010 110 001 101 011 111 码位反转\n            //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n            int[] table &amp;#61; new int[8] { 0, 4, 2, 6, 1, 5, 3, 7 };\n            return table[x];\n        }\n\n        // 倒位排序——雷德算法\n        private static void BitReverse(Complex[] array)\n        {\n            int i, j, k;\n            int N &amp;#61; array.Length;\n            Complex temp;\n            j &amp;#61; 0;\n\n            for (i &amp;#61; 0; i &amp;lt; N - 1; i&amp;#43;&amp;#43;)\n            {\n                if (i &amp;lt; j)\n                {\n                    temp &amp;#61; array[i];\n                    array[i] &amp;#61; array[j];\n                    array[j] &amp;#61; temp;\n                }\n\n                // 求j的下一个倒序位\n                // N/2的二进制最高位为1&amp;#xff0c;其他位都为0\n                // 判断最高位是否为1&amp;#xff0c;可与N/2进行比较\n                // 判断次高位是否为1&amp;#xff0c;可与N/4进行比较\n                k &amp;#61; N &amp;gt;&amp;gt; 1;\n\n                //如果k&amp;lt;&amp;#61;j,表示j的最高位为1\n                while (k &amp;lt;&amp;#61; j)\n                {\n                    //当k&amp;lt;&amp;#61;j时&amp;#xff0c;需要将最高位变为0\n                    j &amp;#61; j - k;\n                    //判断次高位是否为1,依次类推&amp;#xff0c;逐个比较&amp;#xff0c;直到j某个位为0\n                    k &amp;gt;&amp;gt;&amp;#61; 1;\n                }\n\n                j &amp;#61; j &amp;#43; k;//将0变为1\n            }\n        }\n\n        // 打印\n        private static void Print(Complex[] TD2FD)\n        {\n            for (int i &amp;#61; 0; i &amp;lt; TD2FD.Length; i&amp;#43;&amp;#43;)\n            {\n                Console.WriteLine(&amp;#34;(re&amp;#61;{0}, im&amp;#61;{1})&amp;#34;, TD2FD[i].re, TD2FD[i].im);\n            }\n            Console.WriteLine();\n        }\n    }\n\n    //定义复数\n    public class Complex\n    {\n        public float re;//实数部\n        public float im;//虚数部\n\n        public static Complex operator &amp;#43;(Complex lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re &amp;#43; rhs.re;\n            result.im &amp;#61; lhs.im &amp;#43; rhs.im;\n            return result;\n        }\n\n        public static Complex operator -(Complex lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re - rhs.re;\n            result.im &amp;#61; lhs.im - rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re * rhs.re - lhs.im * rhs.im;\n            result.im &amp;#61; lhs.re * rhs.im &amp;#43; lhs.im * rhs.re;\n            return result;\n        }\n\n        public static Complex operator *(float lhs, Complex rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs * rhs.re;\n            result.im &amp;#61; lhs * rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, float rhs)\n        {\n            Complex result &amp;#61; new Complex();\n            result.re &amp;#61; lhs.re * rhs;\n            result.im &amp;#61; lhs.im * rhs;\n            return result;\n        }\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"630\" src=\"https://img-ask.csdnimg.cn/upload/1615885734075.png\" width=\"481\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;ok&amp;#xff0c;存在可以忽略的误差&amp;#xff0c;很正常&amp;#xff0c;这个没毛病&amp;#xff1b;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["快速傅里叶逆变换未还原数据", ["\n", "using System;\n\nnamespace ConsoleApp34\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int N = 8;\n            //初始化时域数据\n            Complex[] TD2FD = new Complex[N];\n            for (int i = 0; i < N; i++)\n            {\n                Complex cpx = new Complex();\n                cpx.re = i;\n                cpx.im = 0;\n                TD2FD[i] = cpx;\n            }\n\n            Console.WriteLine(\"------原始信号-----\");\n            Print(TD2FD);\n\n            Console.WriteLine(\"----- FFT -----\");\n            FFT(TD2FD);\n            Print(TD2FD);\n\n            Console.WriteLine(\"----- IFFT -----\");\n            IFFT(TD2FD);\n            Print(TD2FD);\n\n            Console.Read();\n        }\n\n        //快速傅里叶变换\n        public static void FFT(Complex[] TD2FD)\n        {\n            FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n        }\n\n        //快速傅里叶逆变换\n        public static void IFFT(Complex[] FD2TD)\n        {\n            //做FFT变换\n            Complex[] WT = WT_LUT(FD2TD.Length, -1);\n            FFT_Core(FD2TD, WT);\n            //实部除以N\n            for (int i = 0; i < FD2TD.Length; i++)\n                FD2TD[i].re /= FD2TD.Length;\n        }\n\n        // 返回旋转因子查询表(twiddle factor lookup table)\n        private static Complex[] WT_LUT(int N, int flag = 1)\n        {\n            Complex[] WT = new Complex[N];\n            for (int i = 0; i < N; i++)\n            {\n                Complex cpx_wt = new Complex();\n                float angle = (float)(-i * Math.PI * 2 / N);\n                cpx_wt.re = (float)Math.Cos(angle);\n                //IFFT flag=-1, FFT flag=1\n                cpx_wt.im = flag * (float)Math.Sin(angle);\n                WT[i] = cpx_wt;\n            }\n            return WT;\n        }\n\n        private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n        {\n            int power = (int)Math.Log(TD2FD.Length, 2);\n            int butterfly;\n            int p, s;\n            Complex x1, x2, wt;\n\n            BitReverse(TD2FD);\n\n            //蝶形运算\n            for (int k = 0; k < power; k++) //级数\n            {\n                //Console.WriteLine(\"第{0}级, 共{1}组\", k, 1 << k);\n                for (int j = 0; j < 1 << k; j++) //组数\n                {\n                    butterfly = 1 << (power - k);//每组有几个元素\n                    //计算参与蝶形运算的两个元素的索引\n                    p = j * butterfly;\n                    s = p + butterfly / 2;\n                    //Console.WriteLine(\"butterfly={0}, p={1}, s={2}\", butterfly, p, s);\n                    for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                    {\n                        //Console.Write(\"  ({0}x{1} wtIdx={2})\", i + p, i + s, i * (1 << k));\n                        x1 = TD2FD[i + p];\n                        x2 = TD2FD[i + s];\n                        wt = WT[i * (1 << k)];\n                        TD2FD[i + p] = x1 + x2 * wt;\n                        TD2FD[i + s] = x1 - x2 * wt;\n                    }\n                    //Console.WriteLine();\n                }\n            }\n        }\n\n        private static int BitReverse(int x)\n        {\n            //倒位排序\n            //0   1   2   3   4   5   6   7   十进制\n            //000 001 010 011 100 101 110 111 十进制对应的二进制\n            //000 100 010 110 001 101 011 111 码位反转\n            //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n            int[] table = new int[8] { 0, 4, 2, 6, 1, 5, 3, 7 };\n            return table[x];\n        }\n\n        // 倒位排序——雷德算法\n        private static void BitReverse(Complex[] array)\n        {\n            int i, j, k;\n            int N = array.Length;\n            Complex temp;\n            j = 0;\n\n            for (i = 0; i < N - 1; i++)\n            {\n                if (i < j)\n                {\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n\n                // 求j的下一个倒序位\n                // N/2的二进制最高位为1，其他位都为0\n                // 判断最高位是否为1，可与N/2进行比较\n                // 判断次高位是否为1，可与N/4进行比较\n                k = N >> 1;\n\n                //如果k<=j,表示j的最高位为1\n                while (k <= j)\n                {\n                    //当k<=j时，需要将最高位变为0\n                    j = j - k;\n                    //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                    k >>= 1;\n                }\n\n                j = j + k;//将0变为1\n            }\n        }\n\n        // 打印\n        private static void Print(Complex[] TD2FD)\n        {\n            for (int i = 0; i < TD2FD.Length; i++)\n            {\n                Console.WriteLine(\"(re={0}, im={1})\", TD2FD[i].re, TD2FD[i].im);\n            }\n            Console.WriteLine();\n        }\n    }\n\n    //定义复数\n    public class Complex\n    {\n        public float re;//实数部\n        public float im;//虚数部\n\n        public static Complex operator +(Complex lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re + rhs.re;\n            result.im = lhs.im + rhs.im;\n            return result;\n        }\n\n        public static Complex operator -(Complex lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re - rhs.re;\n            result.im = lhs.im - rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re * rhs.re;\n            result.im = lhs.im * rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(float lhs, Complex rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs * rhs.re;\n            result.im = lhs * rhs.im;\n            return result;\n        }\n\n        public static Complex operator *(Complex lhs, float rhs)\n        {\n            Complex result = new Complex();\n            result.re = lhs.re * rhs;\n            result.im = lhs.im * rhs;\n            return result;\n        }\n    }\n}", "\n\n", "\n\n", "请问下我写的IFFT，为什么没还原成原始数据呢(re=0,1,2,3,4,5,6,7)？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考一下这个&lt;a href=\"https://hub.fastgit.org/Subtitle-Synchronizer/jlibrosa\" id=\"textarea_1632928911364_1632929331902_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;GitHub - Subtitle-Synchronizer/jlibrosa: Librosa equivalent Java library to process audio file adn extract features from it.&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Librosa equivalent Java library to process audio file adn extract features from it. - GitHub - Subtitle-Synchronizer/jlibrosa: Librosa equivalent Java library to process audio file adn extract features from it.&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://assets.fastgit.org/favicons/favicon.png\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://hub.fastgit.org/Subtitle-Synchronizer/jlibrosa&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["在Android上如果对音频做快速傅里叶变换", ["我想在Android上实现语音识别，现在已经有模型了，但是不知道如何在Android上对音频做预处理，就是快速傅里叶变换。", "Python上可以使用librosa对音频预处理，但是Android没有相关工具。", "希望能提供代码。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;采样频率时1/dx&lt;br /&gt;dx代表你的位置间距&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["对离散信号进行傅里叶变换", ["我现在测得了一条直线上的信号，这个信号只表示不同位置的信号值，跟时间无关。一共900个采样点，请问在matlab里作快速傅里叶变换的时候，采样频率是啥？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;matlab就可以做到呢&lt;br /&gt;类似这样画图&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;Fs &amp;#61; &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;% Sampling frequency&lt;/span&gt;\nT &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;/Fs;             &lt;span class=\"hljs-comment\"&gt;% Sampling period&lt;/span&gt;\nL &amp;#61; &lt;span class=\"hljs-number\"&gt;1500&lt;/span&gt;;             &lt;span class=\"hljs-comment\"&gt;% Length of signal&lt;/span&gt;\nt &amp;#61; (&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:L&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)*T;        &lt;span class=\"hljs-comment\"&gt;% Time vector&lt;/span&gt;\nS &amp;#61; &lt;span class=\"hljs-number\"&gt;0.7&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;sin&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;pi&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;*t) &amp;#43; &lt;span class=\"hljs-built_in\"&gt;sin&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;pi&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;120&lt;/span&gt;*t);\nX &amp;#61; S &amp;#43; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;randn&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(t));\nY &amp;#61; fft(X);\nP2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;abs&lt;/span&gt;(Y/L);\nP1 &amp;#61; P2(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:L/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\nP1(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;) &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*P1(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\nf &amp;#61; Fs*(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:(L/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;))/L;\n&lt;span class=\"hljs-comment\"&gt;%% 画图类似这样就行&amp;#xff0c;用plot3画图&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;figure&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);clf\n&lt;span class=\"hljs-built_in\"&gt;plot3&lt;/span&gt;(f,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;ones&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(f)),P1); &lt;span class=\"hljs-built_in\"&gt;hold&lt;/span&gt; on;\n&lt;span class=\"hljs-built_in\"&gt;plot3&lt;/span&gt;(f,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;ones&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(f)),P1);\n&lt;span class=\"hljs-built_in\"&gt;plot3&lt;/span&gt;(f,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;ones&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(f)),P1);\nset(gca, &lt;span class=\"hljs-string\"&gt;&amp;#39;ytick&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;yticklabel&amp;#39;&lt;/span&gt;, {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;(c)&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;(b)&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;(a)&amp;#39;&lt;/span&gt;})\nxlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;f &amp;#39;&lt;/span&gt;)\nylabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;不同磨损&amp;#39;&lt;/span&gt;)\nzlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;幅值&amp;#39;&lt;/span&gt;)\nbox on\ngrid on\nview(&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;38&lt;/span&gt;)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/868298506836145.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["将不同信号的快速傅里叶变换图画在一张三维图中进行对比，如下图所示，使用什么软件可以做到？", ["\n", "在论文里看到了这张图，将不同信号的快速傅里叶变换图画在一张三维图中进行对比，如上图所示，使用什么软件可以做到？"]], "Tag": "算法设计"}
{"Answer": "建议添加一个opencv的库，这个库里有很多图像处理函数。像傅里叶变换，这个库里就有接口，可以直接调用。\r\n而特征向量的提取，要看你选择的是什么特征。距离的计算方式也有很多种，一般采用欧氏距离。这个可以表征两个特征向量的相似度", "Konwledge_Point": "快速傅里叶变换", "Question": ["vc做基于傅里叶形状描述子的图像检索系统特征向量和距离算法该怎么写啊？", ["  对图像进行快速傅里叶变换后得到的关于图片在频域空间的矩阵如何提取用于图像检索的特征向量，以及这些特征向量距离的计算方式。\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;fft变换&amp;#xff0c;自己看代码&amp;#xff1a;&lt;br /&gt;假设你有时间数组t和信号数组v&amp;#xff0c;如此即可&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;fs &amp;#61; &lt;span class=\"hljs-built_in\"&gt;floor&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;/&lt;span class=\"hljs-built_in\"&gt;mean&lt;/span&gt;(diff(t)));\nx &amp;#61; v;\nn &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;^&lt;span class=\"hljs-built_in\"&gt;floor&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;log2&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;(x)));\nt &amp;#61; t(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:n);\nx &amp;#61; x(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:n);\nL &amp;#61; &lt;span class=\"hljs-built_in\"&gt;numel&lt;/span&gt;(t);\n&lt;span class=\"hljs-comment\"&gt;%然后对x作傅里叶变换&amp;#xff0c;按照采样频率1000&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;%这样的话就会出现200赫兹地方的双冲击&lt;/span&gt;\ny &amp;#61; fft(x,n);\nP2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;abs&lt;/span&gt;(y/L);\nk &amp;#61; &lt;span class=\"hljs-built_in\"&gt;floor&lt;/span&gt;(L/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\nf &amp;#61; (&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:k&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)*fs/L;\n&lt;span class=\"hljs-built_in\"&gt;plot&lt;/span&gt;(f(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:k),P2(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:k))\nxlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;频率&amp;#39;&lt;/span&gt;);ylabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;幅值&amp;#39;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一定要注意&amp;#xff0c;采样频率和时间之间的关系&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["关于matlab  FFT问题，时域图很符合预期，但是快速傅里叶变换处理后的频域图失败了", ["计算出的数据进行FFT，频域信号不正确。", "\n", "下图是时域图", "\n", "\n", "下图是我得出的频域图", "\n", "\n", "（频域图的横纵坐标代表什么？）", "\n", "代码如下，v是数据。", "\n", "fs", "=", "10000", ";", "\n", "T", "=", "1", "/fs", ";", "\n", "N", "=length(v)", ";", "\n", "n", "=", "0", ":N-", "1", ";", "\n", "y", "=fft(v,N)", ";", "\n", "mag", "=abs(y)", ";", "\n", "f", "=n*fs/N", ";", "\n", "a", "=f", ";", "\n", "b", "=mag", ";", "\n\n", "\n", "不知道是代码的问题还是别的", "感谢解答"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ok,搞定了&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;引发错误的地方在于&amp;#xff1a;傅里叶逆变换&amp;#xff0c;实数部分和虚数部分都需要除N&amp;#xff0c;你只给实数部分除了N&amp;#xff0c;一维数据没有问题是因为&amp;#xff0c;你的一维数据全是实数&amp;#xff0c;逆变换后虚数部分为0&amp;#xff0c;所以不影响&amp;#xff1b;而二维傅里叶变换需要两次逆变换&amp;#xff08;行和列的逆变换&amp;#xff09;&amp;#xff0c;因此就有了较大影响&amp;#xff1b;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT &amp;#61; WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i &amp;#61; 0; i &amp;lt; FD2TD.Length; i&amp;#43;&amp;#43;)\n        {\n            FD2TD[i].re /&amp;#61; FD2TD.Length;\n            FD2TD[i].im /&amp;#61; FD2TD.Length;\n        }\n    }&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;这样改一下就好了&amp;#xff0c;我不太会输出txt&amp;#xff0c;我用控制台输出试了一下&amp;#xff0c;这是逆变换以后的数据&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"925\" src=\"https://img-ask.csdnimg.cn/upload/1616415175974.png\" width=\"398\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;ok,误差在可忽略的范围内&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;还有一个规范性的问题&amp;#xff0c;一般矩阵&amp;#xff08;row,columns&amp;#xff09;的行是row(Height),列是columns(Width),你刚开始初始化时确实是这么定义的&amp;#xff0c;但后面你就全部反着来了&amp;#xff0c;因为这次输入的是8*8的数据&amp;#xff0c;行列数相等&amp;#xff0c;没有报错&amp;#xff0c;如果下个数据行列数不相等&amp;#xff0c;就有错了&amp;#xff0c;还是规范起来写的好。&amp;#xff08;这个问题不影响你的这次的结果&amp;#xff0c;但还是改掉的好&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["我写的二维傅里叶逆变换未还原数据，求帮忙调试下!", ["先说下问题：", "\n\n", "我用8x8的数据测试FFT2和IFFT2两个算法，发现数据未还原，求帮忙检查下代码哪写错了？", "\n\n", "(注：如果只对每一行或者每一列做FFT和IFFT，可以还原数据。)", "\n\n", "打印的日志下如", "\n\n", "\n\n", "封装的傅里叶变换类", "\n\n", "\n", "using System;\n\n/// <summary>\n/// 傅里叶变换\n/// </summary>\npublic sealed class Fourier\n{\n    //快速傅里叶变换\n    public static void FFT(Complex[] TD2FD)\n    {\n        FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n    }\n\n    //快速傅里叶变换 (二维)\n    public static void FFT2(Complex2D TD2FD)\n    {\n        //对每一行做FFT\n        for (int i = 0; i < TD2FD.Height; i++)\n        {\n            Complex[] row = TD2FD.GetRow(i);\n            FFT(row);\n            TD2FD.SetRow(i, row);\n        }\n\n        //对每一列做FFT\n        for (int i = 0; i < TD2FD.Width; i++)\n        {\n            Complex[] column = TD2FD.GetColumn(i);\n            FFT(column);\n            TD2FD.SetColumn(i, column);\n        }\n    }\n\n    //快速傅里叶逆变换\n    public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT = WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i = 0; i < FD2TD.Length; i++)\n            FD2TD[i].re /= FD2TD.Length;\n    }\n\n    //快速傅里叶逆变换 (二维)\n    public static void IFFT2(Complex2D FD2TD)\n    {\n        //对每一行做IFFT\n        for (int i = 0; i < FD2TD.Height; i++)\n        {\n            Complex[] row = FD2TD.GetRow(i);\n            IFFT(row);\n            FD2TD.SetRow(i, row);\n        }\n\n        //对每一列做IFFT\n        for (int i = 0; i < FD2TD.Width; i++)\n        {\n            Complex[] column = FD2TD.GetColumn(i);\n            IFFT(column);\n            FD2TD.SetColumn(i, column);\n        }\n    }\n\n    // 将直流分量移到频谱图的中心\n    public static void FFT2Shift(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        //将图像四个象限区域按对角线交换\n        for (int i=0; i<halfH; i++)\n        {\n            for (int j=0; j<complex2D.Width; j++)\n            {\n                if (j < halfW)\n                    complex2D.SwapComplex(i, j, i + halfH, j + halfW);\n                else\n                    complex2D.SwapComplex(i, j, i + halfH, j - halfW);\n            }\n        }\n    }\n\n    // 高通滤波\n    public static void HighPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i = halfH - H4; i < halfH + H4; i++)\n        {\n            for (int j = halfW - W4; j < halfW + W4; j++)\n            {\n                Complex cpx = complex2D.GetComplex(i, j);\n                cpx.re = 0;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n    }\n\n    // 低通滤波\n    public static void LowPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i=0; i < complex2D.Height; i++)\n        {\n            for (int j=0; j < complex2D.Width; j++)\n            {\n                if (i < halfH - H4 || i > halfH + H4 ||\n                    j < halfW - W4 || j > halfW + W4)\n                {\n                    Complex cpx = complex2D.GetComplex(i, j);\n                    cpx.re = 0;\n                    cpx.im = 0;\n                    complex2D.SetComplex(i, j, cpx);\n                }\n            }    \n        }\n    }\n\n    // 返回旋转因子查询表(twiddle factor lookup table)\n    private static Complex[] WT_LUT(int N, int flag = 1)\n    {\n        Complex[] WT = new Complex[N];\n        for (int i = 0; i < N; i++)\n        {\n            Complex cpx_wt = new Complex();\n            float angle = (float)(-i * Math.PI * 2 / N);\n            cpx_wt.re = (float)Math.Cos(angle);\n            //IFFT flag=-1, FFT flag=1\n            cpx_wt.im = flag * (float)Math.Sin(angle);\n            WT[i] = cpx_wt;\n        }\n        return WT;\n    }\n\n    private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n    {\n        int power = (int)Math.Log(TD2FD.Length, 2);\n        int butterfly;\n        int p, s;\n        Complex x1, x2, wt;\n\n        //倒位排序\n        BitReverse(TD2FD);\n\n        //蝶形运算\n        for (int k = 0; k < power; k++) //级数\n        {\n            for (int j = 0; j < 1 << (power - k - 1); j++) //组数\n            {\n                //每组有几个元素\n                butterfly = 1 << k + 1;\n                //计算参与蝶形运算的两个元素的索引\n                p = j * butterfly;\n                s = p + butterfly / 2;\n                for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                {\n                    x1 = TD2FD[i + p];\n                    x2 = TD2FD[i + s];\n                    wt = WT[i * TD2FD.Length / butterfly];\n                    TD2FD[i + p] = x1 + x2 * wt;\n                    TD2FD[i + s] = x1 - x2 * wt;\n                }\n            }\n        }\n    }\n\n    // 倒位排序——雷德算法\n    private static void BitReverse(Complex[] array)\n    {\n        //倒位排序原理\n        //0   1   2   3   4   5   6   7   十进制\n        //000 001 010 011 100 101 110 111 十进制对应的二进制\n        //000 100 010 110 001 101 011 111 码位反转\n        //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n\n        int i, j, k;\n        int N = array.Length;\n        Complex temp;\n        j = 0;\n\n        for (i = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n            // 求j的下一个倒序位\n            // N/2的二进制最高位为1，其他位都为0\n            // 判断最高位是否为1，可与N/2进行比较\n            // 判断次高位是否为1，可与N/4进行比较\n            k = N >> 1;\n            //如果k<=j,表示j的最高位为1\n            while (k <= j)\n            {\n                //当k<=j时，需要将最高位变为0\n                j = j - k;\n                //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                k >>= 1;\n            }\n            j = j + k;//将0变为1\n        }\n    }\n\n    // 打印\n    public static void Print(Complex[] TD2FD)\n    {\n        for (int i = 0; i < TD2FD.Length; i++)\n        {\n            Console.WriteLine(TD2FD[i].ToString());\n        }\n        Console.WriteLine();\n    }\n}\n\n//定义复数\npublic class Complex\n{\n    public float re;//实数部\n    public float im;//虚数部\n\n    // 幅值\n    public double Amplitude\n    {\n        get\n        {\n            //测试发现取值范围为\n            //min=0.0009918213, max=412.4615\n            return Math.Sqrt(re * re + im * im);\n        }\n    }\n\n    // 频谱图像素值\n    public double PixelAmplitude\n    {\n        get\n        {\n            //幅值范围很大,需要做以下处理:\n            //1. 将幅值范围调到 [1, ?]\n            //2. 利用Log函数压缩范围\n            //3. 将范围映射到颜色值[0,1]\n            double p = Math.Log(Amplitude * 10000) / 16f;\n            return p;\n        }\n    }\n\n    // 相位\n    public double Phase\n    {\n        get\n        {\n            return Math.Atan2(im, re);\n        }\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"re={0}, im={1}\", re, im);\n    }\n\n    public static Complex operator +(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re + rhs.re;\n        result.im = lhs.im + rhs.im;\n        return result;\n    }\n\n    public static Complex operator -(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re - rhs.re;\n        result.im = lhs.im - rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs.re - lhs.im * rhs.im;\n        result.im = lhs.re * rhs.im + lhs.im * rhs.re;\n        return result;\n    }\n\n    public static Complex operator *(float lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs * rhs.re;\n        result.im = lhs * rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, float rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs;\n        result.im = lhs.im * rhs;\n        return result;\n    }\n}\n\npublic class Complex2D\n{\n    private Complex[,] matrix;\n    private int m_width;\n    private int m_height;\n\n    // width:图像宽度 height:图像高度\n    public Complex2D(int width, int height)\n    {\n        m_width = width;\n        m_height = height;\n        matrix = new Complex[width, height];\n    }\n\n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n\n    public Complex[] GetRow(int i)\n    {\n        Complex[] row = new Complex[m_width];\n        for (int j = 0; j < m_width; j++)\n            row[j] = matrix[j,i];\n        return row;\n    }\n\n    public void SetRow(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[j, i] = array[j];\n    }\n\n    public Complex[] GetColumn(int i)\n    {\n        Complex[] column = new Complex[m_height];\n        for (int j = 0; j < m_height; j++)\n            column[j] = matrix[i,j];\n        return column;\n    }\n\n    public void SetColumn(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[i, j] = array[j];\n    }\n\n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return matrix[j,i];\n    }\n\n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        matrix[j, i] = src;\n    }\n\n    // 交换两个元素\n    // i: 第几行  j: 第几列\n    public void SwapComplex(int i0, int j0, int i1, int j1)\n    {\n        Complex tmp = matrix[j0,i0];\n        matrix[j0, i0] = matrix[j1, i1];\n        matrix[j1, i1] = tmp;\n    }\n\n    // 交换行\n    public void SwapRow(int i, int j)\n    {\n        for (int k=0; k<m_width; k++)\n        {\n            Complex cpx0 = matrix[k,i];\n            Complex cpx1 = matrix[k,j];\n            matrix[k,i] = cpx1;\n            matrix[k,j] = cpx0;\n        }\n    }\n\n    // 交换列\n    public void SwapColumn(int i, int j)\n    {\n        for (int k = 0; k < m_height; k++)\n        {\n            Complex cpx0 = matrix[i,k];\n            Complex cpx1 = matrix[j,k];\n            matrix[i,k] = cpx1;\n            matrix[j,k] = cpx0;\n        }\n    }\n\n    public void Print(string fileName)\n    {\n        System.Text.StringBuilder sb = new System.Text.StringBuilder();\n        for (int i = 0; i < m_height; i++)\n        {\n            for (int j = 0; j < m_width; j++)\n                sb.AppendFormat(\"{0:G} \", matrix[j,i].re.ToString().PadRight(5));\n            sb.AppendLine();\n        }\n        System.IO.File.WriteAllText(string.Format(\"D://{0}.txt\", fileName), sb.ToString());\n    }\n}\n", "\n\n", "测试代码", "\n\n", "\n", "//测试\n        Complex2D complex2D = new Complex2D(8, 8);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            for (int j = 0; j < complex2D.Width; j++)\n            {\n                Complex cpx = new Complex();\n                cpx.re = i * complex2D.Width + j;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n\n        complex2D.Print(\"8x8\");\n        Fourier.FFT2(complex2D);\n        complex2D.Print(\"fft2\");\n        Fourier.IFFT2(complex2D);\n        complex2D.Print(\"ifft2\");"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;百度搜设置Nuget在线源&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["想要在VS2019中安装math net.Numerisc但是出现如下错误是为什么？", ["\n", "\n", "今天发现快速傅里叶变换的逆变换有了错误，所以在搜索资料时发现了mathnet.Nuerics工具包据说可以调用，所以想要下载一下，但是出现了错误。", "请问大噶知道为什么吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;将第二行改为&amp;#xff0c;N1&amp;#61;length(a)。因为函数height在MATLAB中不存在&amp;#xff0c;只有length函数用于获取数组的长度。&lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["【matlab】未定义与 'double' 类型的输入参数相对应的函数 'height'", ["如题，代码是对结构体数组中的变量进行快速傅里叶变换", "第二行报错：未定义与 'double' 类型的输入参数相对应的函数 'height'。", "\n", "a", "=getfield(dec_1D,", "'coefs'", ")", ";", "\n", "N1", "=height(a)", ";", "\n", "Fs1", "=", "10", ";", "\n", "T1", "=", "1", "/Fs1", ";", "\n", "t1", "=(", "0", ":", "1", ":N-", "1", ")*T1", ";", "\n", "t1", "=t1", "';\nA1 = fft(a);", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;先说你程序的错误&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;傅里叶变换和逆变换都没毛病&amp;#xff0c;但你的二维复数矩阵的定义&amp;#xff0c;错了&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;我标出来了&amp;#xff0c;你自己应该能改出来&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;public class Complex2D\n{\n    private List&amp;lt;Complex[]&amp;gt; rows &amp;#61; new List&amp;lt;Complex[]&amp;gt;();\n    private List&amp;lt;Complex[]&amp;gt; columns &amp;#61; new List&amp;lt;Complex[]&amp;gt;();\n    private int m_width;\n    private int m_height;\n \n    public Complex2D(int width, int height)\n    {\n        m_width &amp;#61; width;\n        m_height &amp;#61; height;\n        for (int i &amp;#61; 0; i &amp;lt; height; i&amp;#43;&amp;#43;)\n            rows.Add(new Complex[width]);   //row[0]~row[height-1]\n        for (int i &amp;#61; 0; i &amp;lt; width; i&amp;#43;&amp;#43;)\n            columns.Add(new Complex[height]);//columns[0]~columns[height-1]\n    }                                        //你这里相当于定义了两个矩阵&amp;#xff0c;一个是行向量组成&amp;#xff0c;一个列向量组成&amp;#xff1b;按你的思路&amp;#xff0c;你后面的应该始终保持这两个矩阵相等才对&amp;#xff1b;\n \n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n \n    public Complex[] GetRow(int i)\n    {\n        return rows[i];\n    }\n \n    public Complex[] GetColumn(int i)\n    {\n        return columns[i];\n    }\n \n    public void SetRow(int i, Complex[] src)\n    {\n        rows[i] &amp;#61; src;  //你只行向量&amp;#xff1f;&amp;#xff1f;你如果改了第一行的值&amp;#xff0c;那每一列的第一个值也就跟着变了&amp;#xff0c;你没改&amp;#xff0c;你如果此时读第一列的值&amp;#xff0c;你会发现row[i][j],columns[j][i],不一样\n    }\n \n    public void SetColumn(int i, Complex[] src)\n    {\n        columns[i] &amp;#61; src;  //和上面同理\n    }\n \n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return rows[i][j];  //你的更改行和列有问题&amp;#xff0c;columns[j][i]和row[i][j]不一样了\n    }\n \n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        rows[i][j] &amp;#61; src;   //额。。。。你这里行和列改了&amp;#xff0c;说明你注意到了&amp;#xff0c;然而前面却不改。。\n        columns[j][i] &amp;#61; src;\n    }\n \n    public void SetComplexs(Complex[][] src)\n    {\n        for (int i &amp;#61; 0; i &amp;lt; src.Length; i&amp;#43;&amp;#43;)\n        {\n            Complex[] row &amp;#61; src[i];      //这里你又是只改变了row的值&amp;#xff0c;不改columns\n            for (int j &amp;#61; 0; j &amp;lt; row.Length; j&amp;#43;&amp;#43;)\n                SetComplex(i, j, row[j]);\n        }\n    }\n \n    public void Print()\n    {\n        for (int i &amp;#61; 0; i &amp;lt; rows.Count; i&amp;#43;&amp;#43;)\n        {\n            Complex[] row &amp;#61; rows[i];\n            for (int j &amp;#61; 0; j &amp;lt; row.Length; j&amp;#43;&amp;#43;)\n                Console.Write(&amp;#34;{0:G} &amp;#34;, row[j].re.ToString().PadRight(5));\n            Console.WriteLine();\n        }\n        Console.WriteLine();\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;1.你的傅里叶变换没问题&amp;#xff1b;我看了几遍&amp;#xff0c;确实找不出有啥问题&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;2.是幅度&amp;#xff08;模&amp;#xff09;&amp;#xff0c;还要考虑复数部&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;3.应该不对&amp;#xff0c;我记得中心化应该是把矩阵分成四块&amp;#xff0c;重新排序&amp;#xff0c;你写的shift没看懂什么意思&amp;#xff0c;不过就算不考虑中心化&amp;#xff0c;你的图也不对&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;下面四张图分别是&amp;#xff0c;中心化后的实部&amp;#xff0c;虚部&amp;#xff0c;幅度&amp;#xff0c;和未中心化的幅度谱&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"828\" src=\"https://img-ask.csdnimg.cn/upload/1616123239140.png\" width=\"974\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;C#我不太懂&amp;#xff0c;我用python写的&amp;#xff0c;求幅度&amp;#xff08;模&amp;#xff09;&amp;#xff0c;然后中心化&amp;#xff0c;在取对数&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;freq &amp;#61; 20*np.log10(0.01 &amp;#43; np.abs(fp.fftshift(freq1)))&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;看你的情况&amp;#xff0c;应该把二维复数那一块改一改应该就好了&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "快速傅里叶变换", "Question": ["请教下关于FFT算法生成频谱图的问题", ["我理解的大体思路是：", "\n\n", "1、将图像的灰度值作为输入数据代入FFT算法，生成结果A", "\n\n", "2、直接用A的实部值作为像素值生成频谱图", "\n\n", "但是我发现生成的频谱图布局不对。", "\n\n", "用幅度值作为像素值生成的频谱图", "\n\n", "\n\n", "\n\n", "现在我有3个疑问：", "\n\n", "1、将图像灰度值数据代入FFT，再直接IFFT，得到一张正确的灰度图像，是否说明写的FFT和IFFT算法没问题？", "\n\n", "2、频谱图的像素值是由FFT结果数据的实部值生成吗？", "\n\n", "3、代码中的中心化方法FFT2Shift()是我这样写的吗（不确定对公式是否理解正确）？", "\n\n", " ", "\n\n", "在线对图像做傅里叶变换 ", "https://sci2fig.herokuapp.com/fourier", "\n\n", "\n\n", " ", "\n\n", "下面给出我封装的傅里叶变换类", "\n\n", "\n", "using System;\n\n/// <summary>\n/// 傅里叶变换\n/// </summary>\npublic sealed class Fourier\n{\n    //快速傅里叶变换\n    public static void FFT(Complex[] TD2FD)\n    {\n        FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n    }\n\n    //快速傅里叶变换 (二维)\n    public static void FFT2(Complex2D TD2FD)\n    {\n        //对每一行做FFT\n        for (int i = 0; i < TD2FD.Height; i++)\n        {\n            Complex[] row = TD2FD.GetRow(i);\n            FFT(row);\n            TD2FD.SetRow(i, row);\n        }\n\n        //对每一列做FFT\n        for (int i = 0; i < TD2FD.Width; i++)\n        {\n            Complex[] column = TD2FD.GetColumn(i);\n            FFT(column);\n            TD2FD.SetColumn(i, column);\n        }\n    }\n\n    //快速傅里叶逆变换\n    public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT = WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i = 0; i < FD2TD.Length; i++)\n            FD2TD[i].re /= FD2TD.Length;\n    }\n\n    //快速傅里叶逆变换 (二维)\n    public static void IFFT2(Complex2D FD2TD)\n    {\n        //对每一行做IFFT\n        for (int i = 0; i < FD2TD.Height; i++)\n        {\n            Complex[] row = FD2TD.GetRow(i);\n            IFFT(row);\n            FD2TD.SetRow(i, row);\n        }\n\n        //对每一列做IFFT\n        for (int i = 0; i < FD2TD.Width; i++)\n        {\n            Complex[] column = FD2TD.GetColumn(i);\n            IFFT(column);\n            FD2TD.SetColumn(i, column);\n        }\n    }\n\n    // 将直流分量移到频谱图的中心\n    public static void FFT2Shift(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        //将图像四个象限区域按对角线交换\n        for (int i=0; i<halfH; i++)\n        {\n            for (int j=0; j<complex2D.Width; j++)\n            {\n                if (j < halfW)\n                    complex2D.SwapComplex(i, j, i + halfH, j + halfW);\n                else\n                    complex2D.SwapComplex(i, j, i + halfH, j - halfW);\n            }\n        }\n    }\n\n    // 高通滤波\n    public static void HighPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i = halfH - H4; i < halfH + H4; i++)\n        {\n            for (int j = halfW - W4; j < halfW + W4; j++)\n            {\n                Complex cpx = complex2D.GetComplex(i, j);\n                cpx.re = 0;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n    }\n\n    // 低通滤波\n    public static void LowPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i=0; i < complex2D.Height; i++)\n        {\n            for (int j=0; j < complex2D.Width; j++)\n            {\n                if (i < halfH - H4 || i > halfH + H4 ||\n                    j < halfW - W4 || j > halfW + W4)\n                {\n                    Complex cpx = complex2D.GetComplex(i, j);\n                    cpx.re = 0;\n                    cpx.im = 0;\n                    complex2D.SetComplex(i, j, cpx);\n                }\n            }    \n        }\n    }\n\n    // 返回旋转因子查询表(twiddle factor lookup table)\n    private static Complex[] WT_LUT(int N, int flag = 1)\n    {\n        Complex[] WT = new Complex[N];\n        for (int i = 0; i < N; i++)\n        {\n            Complex cpx_wt = new Complex();\n            float angle = (float)(-i * Math.PI * 2 / N);\n            cpx_wt.re = (float)Math.Cos(angle);\n            //IFFT flag=-1, FFT flag=1\n            cpx_wt.im = flag * (float)Math.Sin(angle);\n            WT[i] = cpx_wt;\n        }\n        return WT;\n    }\n\n    private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n    {\n        int power = (int)Math.Log(TD2FD.Length, 2);\n        int butterfly;\n        int p, s;\n        Complex x1, x2, wt;\n\n        //倒位排序\n        BitReverse(TD2FD);\n\n        //蝶形运算\n        for (int k = 0; k < power; k++) //级数\n        {\n            for (int j = 0; j < 1 << (power - k - 1); j++) //组数\n            {\n                //每组有几个元素\n                butterfly = 1 << k + 1;\n                //计算参与蝶形运算的两个元素的索引\n                p = j * butterfly;\n                s = p + butterfly / 2;\n                for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                {\n                    x1 = TD2FD[i + p];\n                    x2 = TD2FD[i + s];\n                    wt = WT[i * TD2FD.Length / butterfly];\n                    TD2FD[i + p] = x1 + x2 * wt;\n                    TD2FD[i + s] = x1 - x2 * wt;\n                }\n            }\n        }\n    }\n\n    // 倒位排序——雷德算法\n    private static void BitReverse(Complex[] array)\n    {\n        //倒位排序原理\n        //0   1   2   3   4   5   6   7   十进制\n        //000 001 010 011 100 101 110 111 十进制对应的二进制\n        //000 100 010 110 001 101 011 111 码位反转\n        //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n\n        int i, j, k;\n        int N = array.Length;\n        Complex temp;\n        j = 0;\n\n        for (i = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n            // 求j的下一个倒序位\n            // N/2的二进制最高位为1，其他位都为0\n            // 判断最高位是否为1，可与N/2进行比较\n            // 判断次高位是否为1，可与N/4进行比较\n            k = N >> 1;\n            //如果k<=j,表示j的最高位为1\n            while (k <= j)\n            {\n                //当k<=j时，需要将最高位变为0\n                j = j - k;\n                //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                k >>= 1;\n            }\n            j = j + k;//将0变为1\n        }\n    }\n\n    // 打印\n    public static void Print(Complex[] TD2FD)\n    {\n        for (int i = 0; i < TD2FD.Length; i++)\n        {\n            Console.WriteLine(TD2FD[i].ToString());\n        }\n        Console.WriteLine();\n    }\n}\n\n//定义复数\npublic class Complex\n{\n    public float re;//实数部\n    public float im;//虚数部\n\n    // 幅值\n    public double Amplitude\n    {\n        get\n        {\n            //测试发现取值范围为\n            //min=0.0009918213, max=412.4615\n            return Math.Sqrt(re * re + im * im);\n        }\n    }\n\n    // 频谱图像素值\n    public double PixelAmplitude\n    {\n        get\n        {\n            //幅值范围很大,需要做以下处理:\n            //1. 将幅值范围调到 [1, ?]\n            //2. 利用Log函数压缩范围\n            //3. 将范围映射到颜色值[0,1]\n            double p = Math.Log(Amplitude * 10000) / 16f;\n            return p;\n        }\n    }\n\n    // 相位\n    public double Phase\n    {\n        get\n        {\n            return Math.Atan2(im, re);\n        }\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"re={0}, im={1}\", re, im);\n    }\n\n    public static Complex operator +(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re + rhs.re;\n        result.im = lhs.im + rhs.im;\n        return result;\n    }\n\n    public static Complex operator -(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re - rhs.re;\n        result.im = lhs.im - rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs.re - lhs.im * rhs.im;\n        result.im = lhs.re * rhs.im + lhs.im * rhs.re;\n        return result;\n    }\n\n    public static Complex operator *(float lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs * rhs.re;\n        result.im = lhs * rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, float rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs;\n        result.im = lhs.im * rhs;\n        return result;\n    }\n}\n\npublic class Complex2D\n{\n    private Complex[,] matrix;\n    private int m_width;\n    private int m_height;\n\n    // width:图像宽度 height:图像高度\n    public Complex2D(int width, int height)\n    {\n        m_width = width;\n        m_height = height;\n        matrix = new Complex[width, height];\n    }\n\n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n\n    public Complex[] GetRow(int i)\n    {\n        Complex[] row = new Complex[m_width];\n        for (int j = 0; j < m_width; j++)\n            row[j] = matrix[j,i];\n        return row;\n    }\n\n    public void SetRow(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[j, i] = array[j];\n    }\n\n    public Complex[] GetColumn(int i)\n    {\n        Complex[] column = new Complex[m_height];\n        for (int j = 0; j < m_height; j++)\n            column[j] = matrix[i,j];\n        return column;\n    }\n\n    public void SetColumn(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[i, j] = array[j];\n    }\n\n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return matrix[j,i];\n    }\n\n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        matrix[j, i] = src;\n    }\n\n    // 交换两个元素\n    // i: 第几行  j: 第几列\n    public void SwapComplex(int i0, int j0, int i1, int j1)\n    {\n        Complex tmp = matrix[j0,i0];\n        matrix[j0, i0] = matrix[j1, i1];\n        matrix[j1, i1] = tmp;\n    }\n\n    // 交换行\n    public void SwapRow(int i, int j)\n    {\n        for (int k=0; k<m_width; k++)\n        {\n            Complex cpx0 = matrix[k,i];\n            Complex cpx1 = matrix[k,j];\n            matrix[k,i] = cpx1;\n            matrix[k,j] = cpx0;\n        }\n    }\n\n    // 交换列\n    public void SwapColumn(int i, int j)\n    {\n        for (int k = 0; k < m_height; k++)\n        {\n            Complex cpx0 = matrix[i,k];\n            Complex cpx1 = matrix[j,k];\n            matrix[i,k] = cpx1;\n            matrix[j,k] = cpx0;\n        }\n    }\n\n    public void Print(string fileName)\n    {\n        System.Text.StringBuilder sb = new System.Text.StringBuilder();\n        for (int i = 0; i < m_height; i++)\n        {\n            for (int j = 0; j < m_width; j++)\n                sb.AppendFormat(\"{0:G} \", matrix[j,i].re.ToString().PadRight(5));\n            sb.AppendLine();\n        }\n        System.IO.File.WriteAllText(string.Format(\"D://{0}.txt\", fileName), sb.ToString());\n    }\n}\n", "\n\n", "我的测试是在Unity中做的，下面给出我的辅助类", "\n\n", "\n", "using UnityEngine;\n\npublic sealed class FourierHelper\n{\n    public static Texture2D ToTexture2D(Complex2D complex2D)\n    {\n        Texture2D tex = new Texture2D(complex2D.Width, complex2D.Height, TextureFormat.RGBA32, false);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            Complex[] cpxs = complex2D.GetRow(i);\n            for (int j = 0; j < cpxs.Length; j++)\n            {\n                Complex cpx = cpxs[j];\n                tex.SetPixel(j, i, new Color(cpx.re, cpx.re, cpx.re));\n            }\n        }\n        tex.Apply();\n        return tex;\n    }\n\n    // 转成频谱图\n    public static Texture2D ToSpectrumTexture2D(Complex2D complex2D)\n    {\n        float min = float.MaxValue;\n        float max = float.MinValue;\n        Texture2D tex = new Texture2D(complex2D.Width, complex2D.Height, TextureFormat.RGBA32, false);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            Complex[] cpxs = complex2D.GetRow(i);\n            for (int j = 0; j < cpxs.Length; j++)\n            {\n                Complex cpx = cpxs[j];\n                float p = (float)cpx.PixelAmplitude;\n                tex.SetPixel(j, i, new Color(p, p, p));\n                if (p < min)\n                    min = p;\n                if (p > max)\n                    max = p;\n            }\n        }\n        tex.Apply();\n        return tex;\n    }\n\n    public static Complex2D ToComplex2D(Texture2D tex)\n    {\n        Complex2D complex2D = new Complex2D(tex.width, tex.height);\n\n        for (int y = 0; y < tex.height; y++)\n        {\n            for (int x = 0; x < tex.width; x++)\n            {\n                Color c = tex.GetPixel(x, y);\n                Complex cpx = new Complex();\n                cpx.re = c.r * 0.3f + c.g * 0.59f + c.b * 0.11f; //灰度值\n                cpx.im = 0;\n                complex2D.SetComplex(y, x, cpx);\n            }\n        }\n\n        return complex2D;\n    }\n}\n", "\n\n", "FFT->IFFT测试代码", "\n\n", "\n", "using UnityEngine;\nusing UnityEngine.UI;\n/// <summary>\n/// 测试FFT->IFFT算法\n/// </summary>\npublic class FFT_IFFT_Test : MonoBehaviour\n{\n    public RawImage rawImage;\n\n    private void Start()\n    {\n        Texture2D tex = rawImage.texture as Texture2D;\n        Complex2D complex2D = FourierHelper.ToComplex2D(tex);\n\n        Fourier.FFT2(complex2D);\n        Fourier.IFFT2(complex2D);\n\n        Texture2D ifft_tex = FourierHelper.ToTexture2D(complex2D);\n        rawImage.texture = ifft_tex;\n    }\n}\n", "\n\n", "频谱图生成代码", "\n\n", "\n", "using UnityEngine;\nusing UnityEngine.UI;\n/// <summary>\n/// 显示频谱图\n/// </summary>\npublic class SpectrumTexture : MonoBehaviour\n{\n    public RawImage rawImage;\n\n    private void Start()\n    {\n        Texture2D tex = rawImage.texture as Texture2D;\n        Complex2D complex2D = FourierHelper.ToComplex2D(tex);\n\n        Fourier.FFT2(complex2D);\n\n        Texture2D sp_tex = FourierHelper.ToTexture2D(complex2D);\n        rawImage.texture = sp_tex;\n    }\n}\n", "\n\n", "如有需要也可下载我的测试工程(Unity)", "\n\n", "链接：https://pan.baidu.com/s/1B62muufCP-tWQklPT5H49Q ", "\n提取码：z6ku ", "\n\n", " ", "\n\n", "补充：IFFT2未还原数据", "\n\n", "@ 皮皮宽", "\n\n"]], "Tag": "算法设计"}
