{"Answer": "从算法思想找现实案例的基本都是少数，绝大部分都是，从案例分析到匹配算法。\r\n所以你可能学了很多种不同的算法，没有用到现实中，你会觉得学那么多没用。\r\n但是你的潜意识懂得了这种思想，然后当你在现实生活中遇到实际问题的时候，你会很快反应到那些算法可能会有用，哪些又是最优方法。\r\n\r\n那我自己来说，我当初学排序和查找时候，没觉得什么东西需要排序，需要查找，总是觉得生活中乱乱的，你这种查找或者排序肯定不行。\r\n后来工作了，关于游戏排行榜这里的处理的逻辑，查找一个玩家应该排序到哪里，然后立马想到了二分查找。这就是从现实问题找思想。体会很深。\r\n\r\n这种算法思想是通过生活例子抽象出来的一种总结，你再从这种抽象出来的去还原，相比从生活中抽象，肯定不是那么容易，所以学了就学了，\r\n先总结着，或许你可以一边思考生活中，什么事情，什么东西可以在程序中怎么设计，熟练了，再反向思维。", "Konwledge_Point": "最长递增子序列", "Question": ["最长递增子序列问题可以在实际的工作中解决什么样的需求？", ["给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。", "\n测试样例：", "\n[1,4,2,5,3],5", "\n返回 3", "\n\n", "# -*- coding:utf-8 -*-\n\nclass LongestIncreasingSubsequence:\n    def getLIS(self, A, n):\n        dp = [1 for i in range(n)]\n        for i in range(n):\n            maxtemp = 0\n            for j in range(i):\n                if A[j] < A[i] and dp[j] > maxtemp:\n                    maxtemp = dp[j]\n            dp[i] = maxtemp + 1\n        return max(dp)\n", "\n\n", "\n以上是这个经典问题的解法。在百度一搜 LIS（最长递增子序列） 或者 LCS（最长公共子序列） 通篇都在讲什么解法最优，解的过程如何，就是没有人解释这个算法可以解决现实中的什么问题，在工作中解决什么需求，动不动就在谈思想，如果你所学的算法、技术不是为了业务服务，那学习这些东西还有什么意义？", "\n话说回来，有木有大佬能解答一下小弟的疑问"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;那我来个优化的&amp;#xff0c;动态规划的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;\ndef lengthOfLIS():\n    n &amp;#61; &lt;span class=\"hljs-built_in\"&gt;eval&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;())\n    nums &amp;#61; &lt;span class=\"hljs-keyword\"&gt;list&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;().&lt;span class=\"hljs-keyword\"&gt;split&lt;/span&gt;()))\n    &lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt; &amp;#61; [&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; _ in &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(n)] # 动态转换数组\n    max_length &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; # 最短一个词长度为&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;不是&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i in &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,n):\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt; in &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(i):\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; nums[i]&amp;gt;nums[&lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt;]: # 代表遍历到当前为递增&amp;#xff0c;可以加入\n                &lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[i],&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt;]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) # 判断是之前的大&amp;#xff0c;还是现在&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt;]加了&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;大\n        max_length &amp;#61; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[i], max_length) # 当前的长度的最大值和全局长度最大值比较\n    &lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;(max_length)\n\nlengthOfLIS()\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["用Python，输出给定数列的最长递增子序列的长度，写一下注释", ["问题遇到的现象和发生背景", "\n", "给定一个由 nn个整数组成的序列 AA。找到最大的 k有一个索引序列 满足不等式a≤a2≤ak", "例如，序列 A=(5 3  2  4  6 1) 具有最长的递增子序列 (3 4  6) 和 (2 4 6)", "\n", "测试输入输出例子如图", "\n", "\n", "数据输入例子解释", "第一个输入行包含一个整数 n(1≤n≤2000)，A中的元素个数。", "第二个输入行包含 n 个整数 ai（1≤ai ≤1000）", "\n", "数据输出解释", "打印一个整数 k，即最长递增子序列的长度。", "\n", "我想要达到的结果", "\n", "用Python实现编写满足图片和任意的例子，输出打印一个整数 k，输出给定数列的最长递增子序列的长度", "数据输入第一行使用 n= int(input())", "第二行使用li = input().split()接收任意参数", "最后输出打印满足任意条件的结果"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;三方库应该没有。但是你可以自己创建一个库啊&lt;br /&gt;代码如下&amp;#xff1a;&lt;a href=\"https://www.runoob.com/w3cnote/python-longest-increasing-subsequence.html\" id=\"textarea_1660778720377_1660778813718_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://www.runoob.com/w3cnote/python-longest-increasing-subsequence.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["有没有算最长递增子序列的三方库", ["有没有算 最长递增子序列的 三方库，有没有哪位知道的帮下忙    有没有算 最长递增子序列的 三方库，有没有哪位知道的帮下忙 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答引用GPT&amp;#xff0c;有帮助的话请帮我点个采纳&lt;/p&gt;\n&lt;p&gt;LCS通常使用动态规划法进行计算&amp;#xff0c;其时间复杂度为O(mn)&amp;#xff0c;其中m和n分别是两个序列的长度。&lt;/p&gt;\n&lt;p&gt;而LIS可以使用O(nlogn)的算法&amp;#xff0c;如二分查找法或者动态规划法。&lt;/p&gt;\n&lt;p&gt;所以&amp;#xff0c;LCS不一定通过LIS的方法来降低其时间复杂度到O&amp;#xff08;nlogn&amp;#xff09;。&lt;/p&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["关于#c语言#的问题：LCS（最长公共子序列）能否都能通过LIS（最长递增子序列）把时间复杂度降到O（nlogn）", ["LCS（最长公共子序列）能否都能通过LIS（最长递增子序列）把时间复杂度降到O（nlogn）"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;每两个数比较&amp;#xff0c;符合规则时计数加1.不符合规则时判断当前计数是否最大。然后重新开始计数&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;stdio.h&amp;gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i,&lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;,a[&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i]);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(a[i] &amp;gt; a[i-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n            &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;#43;&amp;#43;;\n        else\n        {\n            &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;gt;&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;)\n                &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;&amp;#43;&amp;#43;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最长递增长度&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["芒课 —— 3268试题", ["问题遇到的现象和发生背景", "\n", "如果序列中相邻两个数的左边一个值小于右边的值，则我们说这两个值是递增的。给定一个数值序列，请输出序列中最长的递增子序列（子序列是指原始序列中的连续的一段）的长度。", "\n", "输入说明", "第一行一个整数，表示序列中数值的个数n(1<n<10000)。第二行，n个用空格隔开的整数，表示序列", "\n", "输出说明", "一个整数，表示符合条件的序列长度。如果不存在递增子序列，输出0.", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "算法设计"}
{"Answer": "从算法思想找现实案例的基本都是少数，绝大部分都是，从案例分析到匹配算法。\r\n所以你可能学了很多种不同的算法，没有用到现实中，你会觉得学那么多没用。\r\n但是你的潜意识懂得了这种思想，然后当你在现实生活中遇到实际问题的时候，你会很快反应到那些算法可能会有用，哪些又是最优方法。\r\n\r\n那我自己来说，我当初学排序和查找时候，没觉得什么东西需要排序，需要查找，总是觉得生活中乱乱的，你这种查找或者排序肯定不行。\r\n后来工作了，关于游戏排行榜这里的处理的逻辑，查找一个玩家应该排序到哪里，然后立马想到了二分查找。这就是从现实问题找思想。体会很深。\r\n\r\n这种算法思想是通过生活例子抽象出来的一种总结，你再从这种抽象出来的去还原，相比从生活中抽象，肯定不是那么容易，所以学了就学了，\r\n先总结着，或许你可以一边思考生活中，什么事情，什么东西可以在程序中怎么设计，熟练了，再反向思维。", "Konwledge_Point": "最长递增子序列", "Question": ["最长递增子序列问题可以在实际的工作中解决什么样的需求？", ["给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。", "\n测试样例：", "\n[1,4,2,5,3],5", "\n返回 3", "\n\n", "# -*- coding:utf-8 -*-\n\nclass LongestIncreasingSubsequence:\n    def getLIS(self, A, n):\n        dp = [1 for i in range(n)]\n        for i in range(n):\n            maxtemp = 0\n            for j in range(i):\n                if A[j] < A[i] and dp[j] > maxtemp:\n                    maxtemp = dp[j]\n            dp[i] = maxtemp + 1\n        return max(dp)\n", "\n\n", "\n以上是这个经典问题的解法。在百度一搜 LIS（最长递增子序列） 或者 LCS（最长公共子序列） 通篇都在讲什么解法最优，解的过程如何，就是没有人解释这个算法可以解决现实中的什么问题，在工作中解决什么需求，动不动就在谈思想，如果你所学的算法、技术不是为了业务服务，那学习这些东西还有什么意义？", "\n话说回来，有木有大佬能解答一下小弟的疑问"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;那我来个优化的&amp;#xff0c;动态规划的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;\ndef lengthOfLIS():\n    n &amp;#61; &lt;span class=\"hljs-built_in\"&gt;eval&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;())\n    nums &amp;#61; &lt;span class=\"hljs-keyword\"&gt;list&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;().&lt;span class=\"hljs-keyword\"&gt;split&lt;/span&gt;()))\n    &lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt; &amp;#61; [&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; _ in &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(n)] # 动态转换数组\n    max_length &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; # 最短一个词长度为&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;不是&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i in &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,n):\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt; in &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(i):\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; nums[i]&amp;gt;nums[&lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt;]: # 代表遍历到当前为递增&amp;#xff0c;可以加入\n                &lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[i],&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt;]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) # 判断是之前的大&amp;#xff0c;还是现在&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;j&lt;/span&gt;]加了&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;大\n        max_length &amp;#61; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;dp&lt;/span&gt;[i], max_length) # 当前的长度的最大值和全局长度最大值比较\n    &lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;(max_length)\n\nlengthOfLIS()\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["用Python，输出给定数列的最长递增子序列的长度，写一下注释", ["问题遇到的现象和发生背景", "\n", "给定一个由 nn个整数组成的序列 AA。找到最大的 k有一个索引序列 满足不等式a≤a2≤ak", "例如，序列 A=(5 3  2  4  6 1) 具有最长的递增子序列 (3 4  6) 和 (2 4 6)", "\n", "测试输入输出例子如图", "\n", "\n", "数据输入例子解释", "第一个输入行包含一个整数 n(1≤n≤2000)，A中的元素个数。", "第二个输入行包含 n 个整数 ai（1≤ai ≤1000）", "\n", "数据输出解释", "打印一个整数 k，即最长递增子序列的长度。", "\n", "我想要达到的结果", "\n", "用Python实现编写满足图片和任意的例子，输出打印一个整数 k，输出给定数列的最长递增子序列的长度", "数据输入第一行使用 n= int(input())", "第二行使用li = input().split()接收任意参数", "最后输出打印满足任意条件的结果"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;三方库应该没有。但是你可以自己创建一个库啊&lt;br /&gt;代码如下&amp;#xff1a;&lt;a href=\"https://www.runoob.com/w3cnote/python-longest-increasing-subsequence.html\" id=\"textarea_1660778720377_1660778813718_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://www.runoob.com/w3cnote/python-longest-increasing-subsequence.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["有没有算最长递增子序列的三方库", ["有没有算 最长递增子序列的 三方库，有没有哪位知道的帮下忙    有没有算 最长递增子序列的 三方库，有没有哪位知道的帮下忙 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答引用GPT&amp;#xff0c;有帮助的话请帮我点个采纳&lt;/p&gt;\n&lt;p&gt;LCS通常使用动态规划法进行计算&amp;#xff0c;其时间复杂度为O(mn)&amp;#xff0c;其中m和n分别是两个序列的长度。&lt;/p&gt;\n&lt;p&gt;而LIS可以使用O(nlogn)的算法&amp;#xff0c;如二分查找法或者动态规划法。&lt;/p&gt;\n&lt;p&gt;所以&amp;#xff0c;LCS不一定通过LIS的方法来降低其时间复杂度到O&amp;#xff08;nlogn&amp;#xff09;。&lt;/p&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["关于#c语言#的问题：LCS（最长公共子序列）能否都能通过LIS（最长递增子序列）把时间复杂度降到O（nlogn）", ["LCS（最长公共子序列）能否都能通过LIS（最长递增子序列）把时间复杂度降到O（nlogn）"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;每两个数比较&amp;#xff0c;符合规则时计数加1.不符合规则时判断当前计数是否最大。然后重新开始计数&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;stdio.h&amp;gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i,&lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;,a[&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i]);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(a[i] &amp;gt; a[i-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n            &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;#43;&amp;#43;;\n        else\n        {\n            &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;gt;&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;)\n                &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;&amp;#43;&amp;#43;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最长递增长度&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最长递增子序列", "Question": ["芒课 —— 3268试题", ["问题遇到的现象和发生背景", "\n", "如果序列中相邻两个数的左边一个值小于右边的值，则我们说这两个值是递增的。给定一个数值序列，请输出序列中最长的递增子序列（子序列是指原始序列中的连续的一段）的长度。", "\n", "输入说明", "第一行一个整数，表示序列中数值的个数n(1<n<10000)。第二行，n个用空格隔开的整数，表示序列", "\n", "输出说明", "一个整数，表示符合条件的序列长度。如果不存在递增子序列，输出0.", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "算法设计"}
