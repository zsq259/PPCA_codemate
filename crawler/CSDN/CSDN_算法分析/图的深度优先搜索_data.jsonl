{"Answer": "你画个邻接表懂了，首先对于无向图，n个顶点表＋e个边表，每个都访问一次，就是n+e了，而对于有向图，用的是邻接表表示正向，逆邻接表来表示反响，不是用邻接表来表示正反两个方向的，理解错误，根据题意，问的是邻接表，所以也是n+e", "Konwledge_Point": "图的深度优先搜索", "Question": ["数据结构图的深度优先搜索", ["用邻接表存储的无向图，进行深度优先搜索，时间复杂度为什么不是O(n+2e)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;广搜一般求最短路&amp;#xff0c;算法时间复杂度比较固定&lt;br /&gt;深搜是穷举所有情况&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["广度优先搜索和深度优先搜索的区别", ["广度优先搜索和深度优先搜索的区别在哪里啊？分不清楚什么时候用广度什么时候用宽度"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;EdgeNode&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//边结点&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; adjvex;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;EdgeNode&lt;/span&gt; *next;\n}edge;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;vertexnode&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//临界点&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; data;\n    edge* firstedge;\n}vertexnode,Adjlist[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LGraph&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//图&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; edgenum,nodenum;\n    Adjlist adjlist;\n}LGraph;\n&lt;span class=\"hljs-function\"&gt;LGraph* &lt;span class=\"hljs-title\"&gt;creategraph&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( )&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//创建图&lt;/span&gt;\n&lt;/span&gt;{\n    LGraph*G&amp;#61;(LGraph*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LGraph));\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,&amp;amp;(G-&amp;gt;nodenum),&amp;amp;(G-&amp;gt;edgenum));\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;(G-&amp;gt;nodenum);i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//填充顶点表&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; temp;\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;temp);\n        G-&amp;gt;adjlist[i].data&amp;#61;temp;\n        G-&amp;gt;adjlist[i].firstedge&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//勿漏&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;&amp;#61;(G-&amp;gt;edgenum);j&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//填充边表&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; temp1,temp2;\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,&amp;amp;temp1,&amp;amp;temp2);&lt;span class=\"hljs-comment\"&gt;//读入有向边的”入“&amp;#xff0c;”出“&lt;/span&gt;\n        edge*e&amp;#61;(edge*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(edge));\n        &lt;span class=\"hljs-comment\"&gt;// 有向边的”入“&amp;#xff0c;”出“弄反正了&lt;/span&gt;\n        e-&amp;gt;adjvex&amp;#61;temp2;     &lt;span class=\"hljs-comment\"&gt;//temp1改成temp2&lt;/span&gt;\n        e-&amp;gt;next&amp;#61;G-&amp;gt;adjlist[temp1].firstedge;&lt;span class=\"hljs-comment\"&gt;//头插法  temp2改成temp1&lt;/span&gt;\n        G-&amp;gt;adjlist[temp1].firstedge&amp;#61;e;             &lt;span class=\"hljs-comment\"&gt;//temp2改成temp1&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; G;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; FLAG&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//判断是否能通过v2的标志&amp;#xff0c;全局变量&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DFS&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LGraph*G,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; adjvex,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v2)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//深度搜索&lt;/span&gt;\n&lt;/span&gt;{\n    edge*p;\n    visited[adjvex]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//标记已经访问过&lt;/span&gt;\n    p&amp;#61;G-&amp;gt;adjlist[adjvex].firstedge;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(visited[v2]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) FLAG&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(visited[p-&amp;gt;adjvex]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)      &lt;span class=\"hljs-comment\"&gt;//adjvex 改成 p-&amp;gt;adjvex&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;DFS&lt;/span&gt;(G,p-&amp;gt;adjvex,v2);\n        p&amp;#61;p-&amp;gt;next;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DFSTraverse&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LGraph *G,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v1,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v2)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;(G-&amp;gt;nodenum);i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//首先都初始化为未访问过的状态&lt;/span&gt;\n    {\n        visited[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n        &lt;span class=\"hljs-built_in\"&gt;DFS&lt;/span&gt;(G,v1,v2);&lt;span class=\"hljs-comment\"&gt;//从v1点开始深度搜索&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; FLAG;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    LGraph*G;\n    G&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creategraph&lt;/span&gt;();\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v1,v2,flag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;,&amp;amp;v1,&amp;amp;v2);&lt;span class=\"hljs-comment\"&gt;//要寻找的路径的两端下标&lt;/span&gt;\n    flag&amp;#61;&lt;span class=\"hljs-built_in\"&gt;DFSTraverse&lt;/span&gt;(G,v1,v2);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;yes&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;no&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["有向图的深度优先搜索", ["样例输出应该是yes,但是输出no", "样例如下：", "4 4（结点数，边数）", "1 2 3 4（顶点下标）", "1 2（边信息）", "1 3", "1 4", "2 3", "2 3（要搜索是否存在的边信息）", "以下是代码", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "int", " visited[", "105", "];\n", "typedef", " ", "struct", " ", "EdgeNode", "//边结点", "\n{\n    ", "int", " adjvex;\n    ", "struct", " ", "EdgeNode", " *next;\n}edge;\n", "typedef", " ", "struct", " ", "vertexnode", "//临界点", "\n{\n    ", "int", " data;\n    edge* firstedge;\n}vertexnode,Adjlist[", "105", "];\n", "typedef", " ", "struct", " ", "LGraph", "//图", "\n{\n    ", "int", " edgenum,nodenum;\n    Adjlist adjlist;\n}LGraph;\n", "LGraph* ", "creategraph", "( )", "//创建图", "\n", "{\n    LGraph*G=(LGraph*)", "malloc", "(", "sizeof", "(LGraph));\n    ", "scanf", "(", "\"%d %d\\n\"", ",&(G->nodenum),&(G->edgenum));\n    ", "int", " i,j;\n    ", "for", "(i=", "1", ";i<=(G->nodenum);i++)", "//填充顶点表", "\n    {\n        ", "int", " temp;\n        ", "scanf", "(", "\"%d\"", ",&temp);\n        G->adjlist[i].data=temp;\n        G->adjlist[i].firstedge=", "NULL", ";", "//勿漏", "\n    }\n    ", "for", "(j=", "1", ";j<=(G->edgenum);j++)", "//填充边表", "\n    {\n        ", "int", " temp1,temp2;\n        ", "scanf", "(", "\"%d %d\\n\"", ",&temp1,&temp2);", "//读入有向边的”入“，”出“", "\n        edge*e=(edge*)", "malloc", "(", "sizeof", "(edge));\n        e->adjvex=temp1;\n        e->next=G->adjlist[temp2].firstedge;", "//头插法", "\n        G->adjlist[temp2].firstedge=e;\n    }\n    ", "return", " G;\n}\n", "int", " FLAG=", "0", ";", "//判断是否能通过v2的标志，全局变量", "\n", "void", " ", "DFS", "(LGraph*G,", "int", " adjvex,", "int", " v2)", "//深度搜索", "\n", "{\n    edge*p;\n     visited[adjvex]=", "1", ";", "//标记已经访问过", "\n    p=G->adjlist[adjvex].firstedge;\n    ", "if", "(visited[v2]==", "1", ") FLAG=", "1", ";\n    ", "while", "(p)\n    {\n        ", "if", "(visited[adjvex]==", "0", ")\n        ", "DFS", "(G,p->adjvex,v2);\n        p=p->next;\n    }\n}\n", "int", " ", "DFSTraverse", "(LGraph *G,", "int", " v1,", "int", " v2)", "\n", "{\n    ", "int", " i;\n    ", "for", "(i=", "1", ";i<=(G->nodenum);i++)", "//首先都初始化为未访问过的状态", "\n    {\n        visited[i]=", "0", ";\n    }\n        ", "DFS", "(G,v1,v2);", "//从v1点开始深度搜索", "\n    ", "return", " FLAG;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    LGraph*G;\n    G=", "creategraph", "();\n    ", "int", " v1,v2,flag=", "0", ";\n    ", "scanf", "(", "\"%d %d\"", ",&v1,&v2);", "//要寻找的路径的两端下标", "\n    flag=", "DFSTraverse", "(G,v1,v2);\n    ", "if", "(flag==", "1", ")\n        ", "printf", "(", "\"yes\"", ");\n    ", "else", "\n        ", "printf", "(", "\"no\"", ");\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1.下面是深度优先搜索的程序&amp;#xff0c;用于将图中所有结点的值变为0&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;// 将当前结点的值变为0&lt;/span&gt;\n    G[u][u] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;// 遍历所有与当前结点相连的结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; v &amp;lt; n; v&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;// 如果v是u的相邻结点&amp;#xff0c;则递归调用dfs&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[u][v] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(v, G, n);\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 在主函数中调用dfs&amp;#xff0c;遍历图中所有结点&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setAllValuesToZero&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(u, G, n);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2.下面是广度优先搜索的程序&amp;#xff0c;用于打印图中所有结点的值&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;bfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;// 创建一个队列来保存当前遍历到的结点&lt;/span&gt;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; q;\n    &lt;span class=\"hljs-comment\"&gt;// 将当前结点加入队列&lt;/span&gt;\n    q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(u);\n    &lt;span class=\"hljs-comment\"&gt;// 循环遍历队列中的结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!q.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;())\n    {\n        &lt;span class=\"hljs-comment\"&gt;// 从队列中取出第一个结点&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u &amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;();\n        q.&lt;span class=\"hljs-built_in\"&gt;pop&lt;/span&gt;();\n        &lt;span class=\"hljs-comment\"&gt;// 打印当前结点的值&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, G[u][u]);\n        &lt;span class=\"hljs-comment\"&gt;// 遍历所有与当前结点相连的结点&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; v &amp;lt; n; v&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-comment\"&gt;// 如果v是u的相邻结点&amp;#xff0c;则将其加入队列&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[u][v] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(v);\n            }\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 在主函数中调用bfs&amp;#xff0c;遍历图中所有结点&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printAllValues&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;bfs&lt;/span&gt;(u, G, n);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3.下面是使用邻接表存储图的程序&amp;#xff0c;用于求解每个顶点的入度&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdio.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdlib.h&amp;gt;\n\n#define MAXN &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// 定义链表结点&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; ListNode\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 结点的值&lt;/span&gt;\n    ListNode* next; &lt;span class=\"hljs-comment\"&gt;// 指向下一个结点的指针&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; AdjacencyList\n{\n    ListNode* head; &lt;span class=\"hljs-comment\"&gt;// 指向第一个结点的指针&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; size; &lt;span class=\"hljs-comment\"&gt;// 链表的长度&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-comment\"&gt;// 创建一个新的链表结点&lt;/span&gt;\nListNode* create&lt;span class=\"hljs-constructor\"&gt;ListNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;val&lt;/span&gt;)&lt;/span&gt;\n{\n    ListNode* node &amp;#61; (ListNode*)malloc(sizeof(ListNode));\n    node-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt;;\n    node-&amp;gt;next &amp;#61; NULL;\n    return node;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 初始化邻接表&lt;/span&gt;\nvoid init&lt;span class=\"hljs-constructor\"&gt;AdjacencyList(AdjacencyList&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;list&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;head &amp;#61; NULL;\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;size &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 向邻接表中加入新的结点&lt;/span&gt;\nvoid add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(AdjacencyList&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;list&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;val&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;// 创建新的结点&lt;/span&gt;\n    ListNode* node &amp;#61; create&lt;span class=\"hljs-constructor\"&gt;ListNode(&lt;span class=\"hljs-params\"&gt;val&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;// 将新结点插入到链表的头部&lt;/span&gt;\n    node-&amp;gt;next &amp;#61; &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;head;\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;head &amp;#61; node;\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;size&amp;#43;&amp;#43;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 求解每个顶点的入度&lt;/span&gt;\nvoid &lt;span class=\"hljs-constructor\"&gt;FindInDegree(AdjacencyList&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; G, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;indegree&lt;/span&gt;[], &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;// 初始化所有结点的入度为0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        indegree&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 遍历所有结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;// 遍历当前结点的所有相邻结点&lt;/span&gt;\n        ListNode* curr &amp;#61; G&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt;.head;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (curr !&amp;#61; NULL)\n        {\n              &lt;span class=\"hljs-comment\"&gt;// 将当前结点的相邻结点的入度加1&lt;/span&gt;\n              indegree&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;curr&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;val&lt;/span&gt;]&lt;/span&gt;&amp;#43;&amp;#43;;\n              curr &amp;#61; curr-&amp;gt;next;\n        }\n    }\n}\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n        &lt;span class=\"hljs-comment\"&gt;// 创建邻接表&lt;/span&gt;\n        AdjacencyList G&lt;span class=\"hljs-literal\"&gt;[MAXN]&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; MAXN; i&amp;#43;&amp;#43;)\n        {\n              init&lt;span class=\"hljs-constructor\"&gt;AdjacencyList(&amp;amp;G[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;])&lt;/span&gt;;\n          }\n         &lt;span class=\"hljs-comment\"&gt;// 加入边&lt;/span&gt;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[0], 1)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[0], 2)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[1], 2)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[2], 0)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[2], 3)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[3], 3)&lt;/span&gt;;\n         &lt;span class=\"hljs-comment\"&gt;// 求解每个结点的入度&lt;/span&gt;\n         &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; indegree&lt;span class=\"hljs-literal\"&gt;[MAXN]&lt;/span&gt;;\n         &lt;span class=\"hljs-constructor\"&gt;FindInDegree(G, &lt;span class=\"hljs-params\"&gt;indegree&lt;/span&gt;, MAXN)&lt;/span&gt;;\n\n         &lt;span class=\"hljs-comment\"&gt;// 打印每个结点的入度&lt;/span&gt;\n         &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; MAXN; u&amp;#43;&amp;#43;)\n         {\n             printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d: %d\\n&amp;#34;&lt;/span&gt;, u, indegree&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt;);\n         }\n\n         return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这段程序中&amp;#xff0c;我们使用了链表来存储邻接表&amp;#xff0c;并在&lt;code class=\"language-javascript\"&gt;FindInDegree&lt;/code&gt;函数中遍历所有结点的所有相邻结点&amp;#xff0c;将这些结点的入度加1。最后&amp;#xff0c;我们在主函数中调用了&lt;code class=\"language-javascript\"&gt;FindInDegree&lt;/code&gt;函数&amp;#xff0c;并打印了每个结点的入度。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["写出完整的编程代码！！（C语言）", ["1.已知一个连通图G采用数组存储法，其结点值为数值型，采用深度优先搜索方法，编程序将所有结点的值变为0。", "\n", "2.已知一个连通图G采用数组存储法，其结点值为数值型，采用广度优先搜索方法，编程序将所有结点的值打印出来。", "\n", "3.假设图G采用邻接表存储方式，，编程序求解每个一个顶点的入度: FindInDegree(G, indegree);"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考 &lt;a href=\"https://blog.csdn.net/wd1603926823/article/details/128782281\" id=\"textarea_1679954981190_1679955787658_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/wd1603926823/article/details/128782281&lt;/span&gt;&lt;/a&gt; 可知&amp;#xff1a;&lt;br /&gt;对于答案A&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;    1入&amp;#xff1b;\n1出&amp;#xff0c;3入&amp;#xff1b;\n3出&amp;#xff0c;5入&amp;#xff1b;\n5出&amp;#xff0c;4入&amp;#xff1b;\n4出&amp;#xff0c;2入&amp;#xff1b;\n2出&amp;#xff0c;6入&amp;#xff1b;\n6出&amp;#xff0c;7入&amp;#xff1b;\n7出。    顶点已出完&amp;#xff0c;结束搜索。\n所以顺序是&amp;#xff1a;1&lt;span class=\"hljs-number\"&gt; 3 &lt;/span&gt;5&lt;span class=\"hljs-number\"&gt; 4 &lt;/span&gt;2&lt;span class=\"hljs-number\"&gt; 6 &lt;/span&gt;7\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对于答案B&amp;#xff1a;顶点3 后还有接班人5 &amp;#xff0c;而它直接跳到了4&amp;#xff0c;所以错误。&lt;br /&gt;对于答案C&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;    1入&amp;#xff1b;\n1出&amp;#xff0c;5入&amp;#xff1b;\n5出&amp;#xff0c;3入&amp;#xff1b;\n3出&amp;#xff0c;    &amp;#xff08;3已没有接班人&amp;#xff0c;故此根枝条已捋到底&amp;#xff09;\n        &amp;#xff08;需返回上级5&amp;#xff0c;发现有新分叉枝条4、6均未入队过&amp;#xff0c;所以我们先入4&amp;#xff09;\n     4入&amp;#xff1b;\n4出&amp;#xff0c;2入&amp;#xff1b;\n2出&amp;#xff0c;7入&amp;#xff1b;\n7出&amp;#xff0c;6入&amp;#xff1b;\n6出。     顶点已出完&amp;#xff0c;结束搜索。\n所以顺序是&amp;#xff1a;1&lt;span class=\"hljs-number\"&gt; 5 &lt;/span&gt;3&lt;span class=\"hljs-number\"&gt; 4 &lt;/span&gt;2&lt;span class=\"hljs-number\"&gt; 7 &lt;/span&gt;6\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对于答案D&amp;#xff1a;顶点4还有接班人即未捋到底&amp;#xff0c;而它直接跳到了7 &amp;#xff0c;所以错误。&lt;br /&gt;故答案是AC&amp;#xff0c;我觉得你的标准答案A不正确。只能说A是树不分叉的深度优先搜索选择&amp;#xff0c;因为C虽然也正确但树有一个分叉。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（", ["如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（a　　）。", "A．1 3 5 4 2 6 7                            B．1 3 4 7 6 2 5", "C．1 5 3 4 2 7 6                            D．1 2 4 7 6 5 3", "\n", "这个深度优先搜索遍历，C选项不也可以吗"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考&lt;br /&gt;&lt;a id=\"textarea_1655219157331_1655219218414_0\" target=\"_blank\"&gt;&lt;span class=\"md_link_url\"&gt;http://t.zoukankan.com/yuxiaoba-p-8335758.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["C语言，无向图的深度优先遍历和广度优先遍历", ["给定一个有N个顶点和E条边的无向图，请用深度优先遍历（DFS）和广度优先遍历（BFS）分别列出其所有的连通集。假设顶点从0到N-1编号。进行搜索时，假设总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。", "\n", "输入：输入第1行给出2个整数N(0<N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用一个空格分隔。", "输出：按照“{v1v2…vk}”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;额。。。注释得挺好&lt;br /&gt;把输出结果里的坐标数字替换成星号就好了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;i&lt;/span&gt;, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; res:\n    puzzle&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[j]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;*&amp;#34;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果要保存进txt&amp;#xff0c;还要把之前的迷宫数字都换成字符串&amp;#xff0c;当然&amp;#xff0c;如果你是从txt读取的迷宫矩阵&amp;#xff0c;就没这个问题了。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["python走迷宫深度优先搜索", ["有哦人知道这个程序要怎么改成打印出来的迷宫路径使用星号表示的吗，就是矩阵里面能显示路径", "\n", "\n```python\n", "from", " numpy import *\ndef findpath(puzzle, ", "start", ", ", "end", "):\n    ", "# 四个方向", "\n    d = [(", "-1", ",", "0", "),(", "0", ",", "1", "),(", "1", ",", "0", "),(", "0", ",", "-1", ")]\n    vis = [[", "-1", " ", "for", " _ ", "in", " range(", "len", "(puzzle[", "0", "]))] ", "for", " _ ", "in", " range(", "len", "(puzzle))]\n    ", "#迷宫矩阵,0表示路， 1表示墙 ", "\n    vis[", "start", "[", "0", "]][", "start", "[", "1", "]]=", "start", "\n    dfs = [", "start", "]     \n    ", "while", " dfs:\n        x,y = dfs.pop()    ", "#取栈顶及其探查方向", "\n        ", "for", " i ", "in", " range(", "4", "): ", "#依次检查未探查方向", "\n            m = x+d[i][", "0", "]\n            n = y+d[i][", "1", "]  ", "#算出下一位", "\n            puzzle[", "start", "[", "0", "]][", "start", "[", "1", "]] = ", "6", " ", "#把走过的记录为6", "\n            ", "if", " ", "0", "<=m<", "len", "(puzzle) ", "and", " ", "0", "<=n<", "len", "(puzzle[", "0", "]) ", "and", " puzzle[m][n]==", "0", " ", "and", " vis[m][n]==", "-1", ":   ", "#遇到未探查的新位置 ", "\n                dfs.append((x,y))    ", "#原位置和下一方向入栈", "\n                dfs.append((m,n))\n                vis[m][n]=(x,y)      ", "#新位置入栈", "\n                puzzle[", "start", "[", "0", "]][", "start", "[", "1", "]] = ", "6", " ", "#把走过的记录为6", "\n                ", "if", " ", "end", "==(m,n): ", "#到达出口，打印路径", "\n                    ", "return", " dfs\n                break   ", "#退出内层循环，下次迭代将以新栈顶为当前位置继续", "\n    ", "return", " dfs  ", "#找不到路径", "\n    \npuzzle = zeros((", "10", ", ", "10", "), dtype=float) ", "# 先创建一个全零方阵puzzle;，并且数据的类型设置为float浮点型", "\nf = ", "open", "(", "'test2.txt'", ") ", "# 打开数据文件文件", "\n", "lines", " = f.readlines() ", "# 把全部数据文件读到一个列表lines中", "\npuzzle_row = ", "0", "  ", "# 表示矩阵的行，从0行开始", "\n", "for", " ", "line", " ", "in", " ", "lines", ": ", "# 把lines中的数据逐行读取出", "\n         list = ", "line", ".strip(", "'\\n'", ").", "split", "(", "' '", ") ", "# 处理逐行数据：strip表示把头尾的'\\n'去掉，split表示以空格来分割行数据，然后把处理后的行数据返回到list列表中", "\n         puzzle[puzzle_row:] = list[", "0", ":", "10", "] ", "# 把处理后的数据放到方阵A中。list[0:4]表示列表的0,1,2,3列数据放到矩阵A中的A_row行", "\n         puzzle_row += ", "1", " ", "# 然后方阵A的下一行接着读", "\nprint(puzzle)        \n", "start", " = eval(input(", "\"请输入起始坐标(x,y)：\"", "))\n", "end", " = ", "eval", "(", "input", "(\"请输入终点坐标(", "m", ",", "n", ")：\"))", "\nres = findpath(puzzle, ", "start", ", ", "end", ")\n", "if", " res:print(res)\n", "else", ": print(", "'无路可走'", ")\n\n\n", "\n", "```"]], "Tag": "算法设计"}
{"Answer": "有具体的说明吗，什么题，什么场景\r\n如果非要到n^2，那就往里填平行边呗，某个图的dfs树种存在横叉边的话，把这些横叉边添加到n^2规模再搜索不就是你要的了。", "Konwledge_Point": "图的深度优先搜索", "Question": ["通过深度优先搜索算法生成有向图的DFS树，是否有可能存在横叉边数目等于Ω(n^2)的情况？", ["题中n代表树点。我现在能想到的就只有：有向图的最大边数为n(n-1)，但我不知道如何证明出Ω(n^2)？还是说这种情况并不可能？谢谢！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你能描述下问题具体是要输出什么吗&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["关于深度优先搜索的问题", ["\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "getnum", "(", "int", " x, ", "int", " y)", ";\n", "void", " ", "dfs", "(", "int", " x, ", "int", " y)", ";\n", "int", " map[", "10", "][", "10", "] =\n{\n    {", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "},\n    {", "1", ",", "0", ",", "1", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "1", "},\n    {", "1", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "3", ",", "0", ",", "1", "},\n    {", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "1", "},\n    {", "1", ",", "3", ",", "0", ",", "0", ",", "3", ",", "1", ",", "0", ",", "3", ",", "0", ",", "1", "},\n    {", "1", ",", "3", ",", "1", ",", "0", ",", "0", ",", "3", ",", "3", ",", "1", ",", "1", ",", "1", "},\n    {", "1", ",", "0", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "3", ",", "3", ",", "1", "},\n    {", "1", ",", "1", ",", "0", ",", "0", ",", "3", ",", "0", ",", "0", ",", "0", ",", "3", ",", "1", "},\n    {", "1", ",", "0", ",", "0", ",", "1", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "},\n    {", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "}\n};\n", "typedef", " ", "struct", " {\n    ", "int", " x;\n    ", "int", " y;\n}Note;\n\n", "int", " manipulate[", "4", "][", "2", "] =\n{\n    {", "0", ",", "1", "},\n    {", "1", ",", "0", "},\n    {", "0", ",", "-1", "},\n    {", "-1", ",", "0", "}\n};\n", "int", " book[", "10", "][", "10", "] = { ", "0", " };\n", "int", " killing;\n", "int", " max = ", "0", ";\n", "int", " mx, my;\n\n", "int", " ", "main", "()", "\n", "{\n    \n    ", "dfs", "(", "1", ", ", "1", ");\n    \n    ", "printf", "(", "\"%d from %d,%d\"", ", max, mx, my);\n}\n\n", "void", " ", "dfs", "(", "int", " x,", "int", " y)", "\n", "{\n    ", "if", " (", "1", " == book[x][y] || ", "1", " == map[x][y])\n    {\n        ", "return", ";\n    }\n    book[x][y] = ", "1", ";\n    killing = ", "getnum", "(x, y);\n    ", "if", " (killing > max)\n    {\n        max = killing;\n        mx = x;\n        my = y;\n    }\n\n\n    \n    ", "int", " i;\n    ", "int", " tx, ty;\n    ", "for", " (i = ", "0", "; i < ", "4", "; i++)\n    {\n        tx = x + manipulate[i][", "0", "];\n        ty = y + manipulate[i][", "1", "];\n\n        \n        ", "dfs", "(tx, ty);\n    }\n\n}\n\n    \n\n\n\n\n\n\n\n\n\n", "int", " ", "getnum", "(", "int", " x, ", "int", " y)", "\n", "{\n    ", "int", " sum=", "0", ";\n    ", "int", " i = x;\n    ", "while", " (map[i][y] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[i][y])\n        {\n            sum++;\n        }\n        i++;\n    }\n    \n    i = x;\n    ", "while", " (map[i][y] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[i][y])\n        {\n            sum++;\n        }\n        i--;\n    }\n\n    ", "int", " j = y;\n    ", "while", " (map[x][j] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[x][j])\n            sum++;\n        j++;\n    }\n\n    j = y;\n    ", "while", " (map[x][j] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[x][j])\n            sum++;\n        j--;\n    }\n\n    ", "return", " sum;\n}\n\n", "\n", "能够出结果，但是结果似乎不对，不知到是哪里出了问题"]], "Tag": "算法设计"}
{"Answer": "http://m.blog.csdn.net/article/details?id=50863937", "Konwledge_Point": "图的深度优先搜索", "Question": ["水洼问题 优先深度搜索", ["Description", "\nDue to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.", "\nGiven a diagram of Farmer John’s field, determine how many ponds he has.", "\nInput", "\nLine 1: Two space-separated integers: N and M", "\nLines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.", "\nOutput", "\nLine 1: The number of ponds in Farmer John’s field.", "\nSample Input", "\n10 12 ", "\nW……..WW. ", "\n.WWW…..WWW ", "\n….WW…WW. ", "\n………WW. ", "\n………W.. ", "\n..W……W.. ", "\n.W.W…..WW. ", "\nW.W.W…..W. ", "\n.W.W……W. ", "\n..W…….W.", "\nSample Output", "\n3"]], "Tag": "算法设计"}
{"Answer": "广度，先遍历子节点，再遍历子节点的子节点\r\n12345678\r\n深度，先访问一个节点，往下直到找不到，返回上一个，继续\r\n12485367", "Konwledge_Point": "图的深度优先搜索", "Question": ["数据结构 图的生成树画法", ["\n\n", "原图如上，怎么画他的广度优先，深度优先生成树呢？ 具体画法是什么？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这两个都是正确的&amp;#xff0c;以二叉树为例&amp;#xff0c;dfs的思想是沿着一个子树一直找&amp;#xff0c;找不到了就回溯&amp;#xff0c;再换个子树继续找。当左右子树都找完了&amp;#xff0c;就回到上一层&amp;#xff0c;再在上一层换个子树。没有规定&amp;#xff0c;先找哪个子树。所以上面两个答案都是对的&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如图，关于数据结构 图 的深度优先遍历（DFS） 的遍历顺序问题", ["①和② 两个深度优先遍历的顺序 都是正确 DFS吗？这块内容突然混乱了。", "还是说遇到岔路口时候必须走长的那条？"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;code&gt;append&lt;/code&gt; function may or may not modify the underlying array that your slice refers to. So you are not creating a completely new list when using append. I changed &lt;code&gt;helper&lt;/code&gt; to match your desired behavior.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for i := index; i &amp;lt; length; i++ {\n    if i != index &amp;amp;&amp;amp; nums[i] == nums[i - 1] {\n        continue\n    }\n    if nums[i] &amp;gt; target {\n        break\n    }\n    var newList []int\n    newList = append(newList, list...)\n    newList = append(newList, nums[i])\n    helper(nums, i, target - nums[i], newList, resultp, length)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["使用Golang时对深度优先搜索结果感到困惑", ["\n\n", "I tried to solve the 'Combination Sum' on leetcode, and the result is wrong when using test case:", "\n\n", "\n  ", "[7,3,2] 18", "\n", "\n\n", "I used C++ with the same logic and passed, but when using Golang, my result is:", "\n\n", "\n  ", "[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,7,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]", "\n", "\n\n", "and the correct one should be", "\n\n", "\n  ", "[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]", "\n", "\n\n", "the code is shown below:", "\n\n", "import \"sort\"\nfunc combinationSum(candidates []int, target int) [][]int {\n    result := make([][]int, 0, 0)\n    resultp := &result\n    sort.Ints(candidates)\n    helper(candidates, 0, target, make([]int, 0, 0), resultp, len(candidates))\n    return *resultp\n}\n\nfunc helper(nums []int, index int, target int, list []int, resultp *[][]int, length int) {\n    if target == 0 {\n        *resultp = append(*resultp, list)\n        return\n    }\n    for i := index; i < length; i++ {\n        if i != index && nums[i] == nums[i - 1] {\n            continue\n        }\n        if (nums[i] > target) {\n            break\n        }\n        helper(nums, i, target - nums[i], append(list, nums[i]), resultp, length)\n    }\n}\n", "\n\n", "Can anyone tell me why the result is incorrect, I am just confused about the [2,2,2,2,2,7,3,3] in my answer, why the 7 is before the 3 since the array has been sorted? Or anyone can tell me what mistake I have made in my code ", "\n\n\n    "]], "Tag": "算法设计"}
{"Answer": "1 2 4 8 9 5 10 11 3 6 7", "Konwledge_Point": "图的深度优先搜索", "Question": ["已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列", ["已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ds[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, m;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (y&amp;lt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || y&amp;gt;&amp;#61;n || x&amp;lt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || x&amp;gt;&amp;#61;m || a[y][x]!&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,sum &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    a[y][x] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//这块草坪已经烧过了&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        sum &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(y&amp;#43;ds[i][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], x&amp;#43;ds[i][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sum;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j, d, max;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;)\n    {\n        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; m &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m; j&amp;#43;&amp;#43;)\n            {\n                cin &amp;gt;&amp;gt; a[i][j];\n            }\n        }\n        max &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m; j&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a[i][j] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                {\n                    d &amp;#61; &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(i, j);\n                    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;gt; max)\n                        max &amp;#61; d;\n                }\n            }\n        }\n        cout &amp;lt;&amp;lt; max &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/696528560846188.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["关于这道深度优先遍历的问题，如何解决？（C++）", ["【问题描述】", "给你一块n", "m的草坪，问如果只点一次火，最多能烧多少块草坪。可以从n", "m的草地中任意一个地方开始点火，火只能往上下左右传递，没有草的地方不能燃烧。", "【输入格式】", "输入由多个测试例组成。每个测试例的第一行含两个整数n和m, (1 <=n,m<=100), 分别表示01矩阵的行数与列数，", "后面紧跟着n行，每行含m个整数0或1，1代表草坪，0表示啥也没有，相邻两个整数之间用一个空格隔开，两个测", "试例之间用一个空行隔开，最后一个测试例之后隔一个空行，最后一行含有两个整数0，表示输入结束。", "【输出格式】", "每个测试例对应一行输出，含一个整数，表示只点一次火最多能烧的草坪个数。", "【样例输入】", "5 6", "0 1 1 0 0 1", "1 1 0 1 0 1", "0 1 0 0 1 0", "0 0 0 1 1 1", "1 0 1 1 1 0", "\n", "0 0", "【样例输出】", "7", "【提示】", "深度优先搜索DFS的应用", "\n", "请问C++如何用深度优先搜索解决呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;试着写了一下&amp;#xff0c;应该还可以优化&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;def findpath(puzzle, start, end):\n    d &amp;#61; [(&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)]\n    vis &amp;#61; [[&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt; for &lt;span class=\"hljs-symbol\"&gt;_&lt;/span&gt; in range(len(puzzle[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]))] for &lt;span class=\"hljs-symbol\"&gt;_&lt;/span&gt; in range(len(puzzle))]\n    vis[start[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]][start[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]]&amp;#61;start\n    dfs &amp;#61; [start]\n    while dfs:\n        x,y &amp;#61; dfs.pop()\n        for i in range(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;):\n            m &amp;#61; x&amp;#43;d[i][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n            n &amp;#61; y&amp;#43;d[i][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            if &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;lt;&amp;#61;m&amp;lt;len(puzzle) and &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;lt;&amp;#61;n&amp;lt;len(puzzle[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]) and puzzle[m][n]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; and vis[m][n]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;:\n                dfs.append((x,y))\n                dfs.append((m,n))\n                vis[m][n]&amp;#61;(x,y)\n                if end&amp;#61;&amp;#61;(m,n):return dfs\n                break   \n    return dfs\n\npuzzle &amp;#61; [\n    [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],\n    [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],\n    [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],\n    [&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n]\nstart &amp;#61; eval(input(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入起始坐标(x,y)&amp;#xff1a;&amp;#34;&lt;/span&gt;))\nend &amp;#61; eval(input(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入终点坐标(m,n)&amp;#xff1a;&amp;#34;&lt;/span&gt;))\nres &amp;#61; findpath(puzzle, start, end)\nif res:print(res)\nelse: print(&lt;span class=\"hljs-string\"&gt;&amp;#39;无路可走&amp;#39;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;请输入起始坐标&lt;span class=\"hljs-comment\"&gt;(x,y)&lt;/span&gt;&amp;#xff1a;&lt;span class=\"hljs-comment\"&gt;(0,0)&lt;/span&gt;\n请输入终点坐标&lt;span class=\"hljs-comment\"&gt;(m,n)&lt;/span&gt;&amp;#xff1a;&lt;span class=\"hljs-comment\"&gt;(3,3)&lt;/span&gt;\n[&lt;span class=\"hljs-comment\"&gt;(0, 0)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(1, 0)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(2, 0)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(2, 1)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(3, 1)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(3, 2)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(3, 3)&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["深度优先搜索怎么实现走迷宫呀", ["怎么用dfs深度优先搜索实现走迷宫呀,怎么实现两个坐标中走迷宫出一个路径"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;节点会有分叉是什么意思&amp;#xff1f;你每行数据只有两个数据不同&amp;#xff0c;是根据数据的大小排序吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如何将csv文件中的节点数据通过深度优先搜索进行排序，再进行重新编号", ["举例：", "这些节点会有分叉，如何通过深度优先搜索进行排序编号。本人对此方面尚未接触过，求详细解答"]], "Tag": "算法设计"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;这篇文章讲的很详细&amp;#xff0c;请看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/weixin_37841366/article/details/111777215\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;找到搜索二叉树中两个错误的节点&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "图的深度优先搜索", "Question": ["第二题深度优先搜索怎么做", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdlib.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;string.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXSIZE 3&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXNODESIZE 10&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Branch&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Branch&lt;/span&gt;* next;\n}branch;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Tnode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; data[MAXSIZE]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;\\0&amp;#34;&lt;/span&gt;;\n    branch* first;\n}tnode;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;create&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tnode tree[], &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//创建邻接表&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, t &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n   \n\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;一共有%d个头节点\\n&amp;#34;, cnt);&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt; i&amp;#43;&amp;#43;)\n    {\n        j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;//遇到/就开始找换行符\\n&amp;#xff0c;并跳转到下一行&amp;#xff0c;录入下一行头节点&lt;/span&gt;\n        {\n            tree[i].data[j] &amp;#61; str[t];\n            j&amp;#43;&amp;#43;;\n            t&amp;#43;&amp;#43;;\n        }\n        tree[i].data[j] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//为tree[i].data加入终止符&lt;/span&gt;\n        tree[i].first &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; str[t] !&amp;#61; EOF)  &lt;span class=\"hljs-comment\"&gt;//跳转至下一行&amp;#xff0c;准备录下一行的头节点&lt;/span&gt;\n            t&amp;#43;&amp;#43;;\n        t&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-comment\"&gt;//puts(tree[i].data);  //将该行的头节点中的串打印出来以检验头节点的串是否成功录入&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//头节点初始化完成&amp;#xff0c;接下来将子节点连接到&lt;/span&gt;\n    t &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt &amp;amp;&amp;amp; t &amp;lt; size; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t &amp;lt; size &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;//先跳过头节点&lt;/span&gt;\n            t&amp;#43;&amp;#43;;\n        t&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-comment\"&gt;// p &amp;#61; (branch*)malloc(sizeof(branch));&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t &amp;lt; size &amp;amp;&amp;amp;str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;// 这里是bug1: t是数字&amp;#xff0c; 也要可能是空了&lt;/span&gt;\n        {\n            j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; string[MAXSIZE];\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t &amp;lt; size &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;//将字符串截取出来 bug2:不能处理换行符&lt;/span&gt;\n            {\n                string[j] &amp;#61; str[t];\n                j&amp;#43;&amp;#43;;\n                t&amp;#43;&amp;#43;;\n            }\n            &lt;span class=\"hljs-comment\"&gt;//此时str[t]&amp;#61;&amp;#61;&amp;#39;/&amp;#39;&lt;/span&gt;\n            string[j] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n            &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;子串为:&amp;#34;);&lt;/span&gt;\n            &lt;span class=\"hljs-comment\"&gt;//puts(string);&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; target &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; n &amp;lt; cnt; n&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(tree[n].data, string)) {\n                    target &amp;#61; n;\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n                }\n            }\n            branch* p &amp;#61; tree[i].first;\n            &lt;span class=\"hljs-comment\"&gt;//bug3:插入方式不正确&amp;#xff0c;应该后插入&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {\n                p &amp;#61; (branch*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(branch));\n                p-&amp;gt;index &amp;#61; target;\n                p-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n                tree[i].first &amp;#61; p;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {\n                    p &amp;#61; p-&amp;gt;next;\n                }\n                p-&amp;gt;next &amp;#61; (branch*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(branch));\n                p-&amp;gt;next-&amp;gt;index &amp;#61; target;\n                p-&amp;gt;next-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t &amp;gt;&amp;#61; size ||str[t] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;) {\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n            t&amp;#43;&amp;#43;;  &lt;span class=\"hljs-comment\"&gt;//使t指向下一个单词开头 &lt;/span&gt;\n        }\n        &lt;span class=\"hljs-comment\"&gt;//此时t指向\\n&lt;/span&gt;\n        t&amp;#43;&amp;#43;;  &lt;span class=\"hljs-comment\"&gt;//将t指向下一行第一个字符&lt;/span&gt;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[], tnode tree[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DFS&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tnode tree[])&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//对邻接表进行深度优先遍历&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[MAXNODESIZE];\n  \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; MAXNODESIZE; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(tree[i].data)&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;){\n            cnt&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt; i&amp;#43;&amp;#43;) visited[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[i]) {\n            &lt;span class=\"hljs-comment\"&gt;//没有遍历过&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(visited, tree,   i);\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[], tnode tree[],   &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v)&lt;/span&gt; &lt;/span&gt;{\n    tnode t &amp;#61; tree[v];\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(t.data);\n    visited[v] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (branch* w &amp;#61; t.first; w !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;; w &amp;#61; w-&amp;gt;next) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[w-&amp;gt;index]) { \n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(visited, tree, w-&amp;gt;index);\n        }\n    }\n\n}\n \n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;visit&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tnode* node, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[])&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//对结点进行访问&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(node-&amp;gt;data, str))\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;该结点存在&amp;#xff01;&amp;#34;&lt;/span&gt;);\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FillInText&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[], FILE* fp)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//将文件中内容传入str中&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    ch &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fgetc&lt;/span&gt;(fp);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (ch !&amp;#61; EOF)\n    {\n        str[length] &amp;#61; ch;\n        ch &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fgetc&lt;/span&gt;(fp);\n        length&amp;#43;&amp;#43;;\n    }\n    str[length] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getCount&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[])&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//获取邻接表头节点个数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str[i] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)\n            cnt&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cnt &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    FILE* fp;\n    tnode tree[MAXNODESIZE];\n    \n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch, str[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n    fp &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1\\\\test.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fp &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;文件打开失败\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;FillInText&lt;/span&gt;(str, fp);\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(fp);\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;文件中的文本内容为:\\n&amp;#34;);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//puts(str);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;create&lt;/span&gt;(tree, str, &lt;span class=\"hljs-built_in\"&gt;getCount&lt;/span&gt;(str)); \n    &lt;span class=\"hljs-built_in\"&gt;DFS&lt;/span&gt;(tree);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["对邻接表进行深度优先遍历", ["问题：", "将文本文件中的文本数据提取，并以此建立邻接表，再进行树的深度优先搜索。", "遇到的问题：", "在创建邻接表的时候，感觉逻辑有点混乱。", "我先是把邻接表的头节点都先加载出来，再将子节点接到头节点上。", "子节点接到头结点这个环节，感觉有点乱。", "文本文件内容：", "\n", "\n", "目标：", "将该内容变成存储内的邻接表", "\n", "\n", "并对该邻接表进行深度优先遍历", "\n", "求指教！", "以下为我的屎山代码XD（目前程序还是有问题的，问题在子节点连接到头节点那一块）：", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS", "\n", "#", "include", " ", "\"stdio.h\"", "\n", "#", "include", " ", "\"stdlib.h\"", "\n", "#", "include", " ", "\"string.h\"", "\n", "#", "define", " MAXSIZE 20", "\n", "typedef", " ", "struct", " ", "Branch", "\n{\n    ", "int", " index;\n    ", "struct", " ", "Branch", "* next;\n}branch;\n\n", "typedef", " ", "struct", " ", "Tnode", "\n{\n    ", "char", " data[MAXSIZE];\n    branch* first;\n}tnode;\n\n", "void", " ", "create", "(tnode tree[],", "char", " str[],", "int", " cnt)", "  ", "//创建邻接表", "\n", "{\n    ", "int", " j = ", "0", ", t = ", "0", ";\n    ", "char", " string[MAXSIZE];\n    branch* p;\n    ", "printf", "(", "\"一共有%d个头节点\\n\"", ", cnt);\n    ", "for", " (", "int", " i = ", "0", "; i < cnt; i++)\n    {\n        j = ", "0", ";\n        ", "while", " (str[t] != ", "'/'", ")  ", "//遇到/就开始找换行符\\n，并跳转到下一行，录入下一行头节点", "\n        {\n            tree[i].data[j] = str[t];\n            j++;\n            t++;\n        }\n        tree[i].data[j] = ", "'\\0'", ";  ", "//为tree[i].data加入终止符", "\n        tree[i].first = ", "NULL", ";\n        ", "while", " (str[t] != ", "'\\n'", "&&str[t]!=EOF)  ", "//跳转至下一行，准备录下一行的头节点", "\n            t++;\n        t++;\n        ", "puts", "(tree[i].data);  ", "//将该行的头节点中的串打印出来以检验头节点的串是否成功录入", "\n    }\n    ", "//头节点初始化完成，接下来将子节点连接到", "\n    t = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < cnt; i++)\n    {\n        ", "while", " (str[t] != ", "'/'", ")  ", "//先跳过头节点", "\n            t++;\n        t++;\n        p = (branch*)", "malloc", "(", "sizeof", "(branch));\n        ", "while", " (t != ", "'\\n'", ")\n        {\n            j = ", "0", ";\n            ", "for", " (", "int", " n = ", "0", "; n < ", "strlen", "(string); n++)", "//字符串清空", "\n                string[n] = ", "'\\0'", ";\n            ", "while", " (str[t] != ", "'/'", ")", "//将字符串截取出来", "\n            {\n                string[j] = str[t];\n                j++;\n                t++;\n            }\n            ", "//此时str[t]=='/'", "\n            string[j] = ", "'\\0'", ";\n            ", "printf", "(", "\"子串为:\"", ");\n            ", "puts", "(string);\n            ", "for", " (", "int", " n = ", "0", "; n < cnt; n++)\n            {\n                ", "if", " (!", "strcmp", "(tree[n].data, string))\n                    p->index = n;\n            }\n            p->next = tree[i].first;", "//将p接入头节点中", "\n            tree[i].first = p;\n            t++;  ", "//使t指向下一个单词开头", "\n            p = (branch*)", "malloc", "(", "sizeof", "(branch));\n        }\n        ", "//此时t指向\\n", "\n        t++;  ", "//将t指向下一行第一个字符", "\n    }\n}\n\n", "void", " ", "DFS", "(tnode tree[])", "  ", "//对邻接表进行深度优先遍历", "\n", "{\n\n}\n\n", "void", " ", "visit", "(tnode* node,", "char", " str[])", "  ", "//对结点进行访问", "\n", "{\n    ", "if", " (!", "strcmp", "(node->data, str))\n    {\n        ", "printf", "(", "\"该结点存在！\"", ");\n    }\n}\n\n", "void", " ", "FillInText", "(", "char", " str[], FILE* fp)", "  ", "//将文件中内容传入str中", "\n", "{\n    ", "char", " ch;\n    ", "int", " length = ", "0", ";\n    ch = ", "fgetc", "(fp);\n    ", "while", " (ch != EOF)\n    {\n        str[length] = ch;\n        ch = ", "fgetc", "(fp);\n        length++;\n    }\n    str[length] = ", "'\\0'", ";\n}\n\n", "int", " ", "getCount", "(", "char", " str[])", "  ", "//获取邻接表头节点个数", "\n", "{\n    ", "int", " cnt = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < ", "strlen", "(str); i++)\n    {\n        ", "if", " (str[i] == ", "'\\n'", ")\n            cnt++;\n    }\n    ", "return", " cnt + ", "1", ";\n}\n\n", "int", " ", "main", "()", "\n", "{\n    FILE* fp;\n    tnode tree[MAXSIZE];\n    ", "char", " ch, str[", "100", "];\n    fp = ", "fopen", "(", "\"test.txt\"", ", ", "\"r\"", ");\n    ", "if", " (fp == ", "NULL", ")\n    {\n        ", "printf", "(", "\"文件打开失败\\n\"", ");\n        ", "exit", "(", "0", ");\n    }\n    ", "FillInText", "(str, fp);\n    ", "printf", "(", "\"文件中的文本内容为:\\n\"", ");\n    ", "puts", "(str);\n    ", "create", "(tree, str,", "getCount", "(str));\n    ", "fclose", "(fp);\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "很明显就是你的内存分配以后，没有对其中的字段，比如firstChild nextSibling初始化\r\n\r\n邻接表G建立的有问题，排查一下邻接矩阵转换到邻接表的函数\r\n\r\n# 没有采纳之前先回答你这么多吧", "Konwledge_Point": "图的深度优先搜索", "Question": ["求教大佬们，这个“读取位置 0xCCCCCCCC 时发生访问冲突。”的异常该如何解决？", ["程序是数据结构的图的存储和遍历实验，功能是输入一个无向图并将其转换成邻接矩阵，然后把邻接矩阵变成邻接表，最后深度优先遍历该邻接表生成树（VS2017）：", "\n\n", "#include <stdio.h>\n#include <malloc.h>\n#include <stdlib.h>\n#include <string.h>\n#include<iostream>\nusing namespace std;\ntypedef int InfoType;\n#define MAXV 100                //最大顶点个数\n#define INF 32767               //INF表示∞\n#define isLetter(a)  ((((a)>='a')&&((a)<='z')) || (((a)>='A')&&((a)<='Z')))\n#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))\n//以下定义邻接矩阵类型\ntypedef struct\n{\n    int no;                     //顶点编号\n    InfoType info;              //顶点其他信息\n} VertexType;                   //顶点类型\ntypedef struct              //图的定义\n{\n    char vexnum[MAXV];\n    int edges[MAXV][MAXV];      //邻接矩阵\n    int n, e;                       //顶点数，边数\n    VertexType vexs[MAXV];      //存放顶点信息\n} MGraph, *PGragh;                      //图的邻接矩阵类型\n//以下定义邻接表类型\ntypedef struct ANode            //边的节点结构类型\n{\n    int adjvex;                 //该边的终点位置\n    struct ANode *nextarc = NULL;       //指向下一条边的指针\n    InfoType *info;             //该边的相关信息,这里用于存放权值\n} ArcNode;\ntypedef int Vertex;\ntypedef struct Vnode            //邻接表头节点的类型\n{\n    Vertex data;                //顶点信息\n    ArcNode *firstarc;          //指向第一条边\n} VNode;\ntypedef VNode AdjList[MAXV];    //AdjList是邻接表类型\ntypedef struct\n{\n    AdjList adjlist;            //邻接表\n    int n, e;                   //图中顶点数n和边数e\n} ALGraph;                      //图的邻接表类型\n\nvoid MatToList(MGraph *g, ALGraph *G)\n//将邻接矩阵g转换成邻接表G\n{\n    int i, j;\n    ArcNode *p;\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    for (i = 0; i<g->n; i++)                    //给邻接表中所有头节点的指针域置初值\n        G->adjlist[i].firstarc = NULL;\n    for (i = 0; i<g->n; i++)                    //检查邻接矩阵中每个元素\n    for (j = g->n - 1; j >= 0; j--)\n    if (g->edges[i][j] != 0)        //存在一条边\n    {\n        p = (ArcNode *)malloc(sizeof(ArcNode)); //创建一个节点*p\n        p->adjvex = j;\n        p->nextarc = G->adjlist[i].firstarc;        //采用头插法插入*p\n        G->adjlist[i].firstarc = p;\n    }\n    G->n = g->n; G->e = g->e;\n    //return G;\n}\n\nvoid DispMat(MGraph *g)\n//输出邻接矩阵g\n{\n    int i, j;\n    for (i = 0; i<g->n; i++)\n    {\n        for (j = 0; j<g->n; j++)\n            printf(\"%3d\", g->edges[i][j]);\n        printf(\"\\n\");\n    }\n}\nvoid DispAdj(ALGraph G)\n//输出邻接表G\n{\n    int i;\n    ArcNode *p;\n    for (i = 0; i<G.n; i++)\n    {\n        p = G.adjlist[i].firstarc;\n        printf(\"%3d: \",i);\n        //cout << i << \":\";\n        while (p != NULL)\n        {\n            //printf(\"%3d\",p->adjvex);\n            cout << p->adjvex << \" \";\n            p = p->nextarc;\n        }\n        printf(\"\\n\");\n    }\n}\nstatic int get_position(MGraph g, char ch)\n{\n    int i;\n    for (i = 0; i<g.n; i++)\n    if (g.vexnum[i] == ch)\n        return i;\n    return -1;\n}\n\n\n//读取一个输入字符\n\nstatic char read_char()\n{\n    char ch;\n\n    do {\n        ch = getchar();\n    } while (!isLetter(ch));\n\n    return ch;\n}\n\n\n// 创建无向图\n\nMGraph* create_graph()\n{\n    char c1, c2;\n    int vex, edge;\n    int i, p1, p2;\n    MGraph* pG;\n\n    // 输入顶点数和边数\n    printf(\"输入顶点数和边数：\");\n    scanf_s(\"%d%d\", &vex, &edge);\n    if (vex < 1 || edge < 1 || (edge >(vex * (vex - 1))))\n    {\n        printf(\"input error: invalid parameters!\\n\");\n        return NULL;\n    }\n\n    if ((pG = (MGraph*)malloc(sizeof(MGraph))) == NULL)\n        return NULL;\n    memset(pG, 0, sizeof(MGraph));\n\n    // 初始化顶点数和边数\n    pG->n = vex;\n    pG->e = edge;\n    // 初始化\"顶点\"\n    printf(\"输入各顶点名称：\\n\");\n    for (i = 0; i < pG->n; i++)\n    {\n        printf(\"vertex(%d): \", i);\n        pG->vexnum[i] = read_char();\n    }\n\n    // 初始化\"边\"\n    for (i = 0; i < pG->e; i++)\n    {\n        // 读取边的起始顶点和结束顶点\n        printf(\"edge(%d):\", i);\n        c1 = read_char();\n        c2 = read_char();\n\n        p1 = get_position(*pG, c1);\n        p2 = get_position(*pG, c2);\n        if (p1 == -1 || p2 == -1)\n        {\n            printf(\"input error: invalid edge!\\n\");\n            free(pG);\n            return NULL;\n        }\n\n        pG->edges[p1][p2] = 1;\n        pG->edges[p2][p1] = 1;\n    }\n\n    return pG;\n}\n// 打印矩阵队列图\n\nvoid print_graph(MGraph G)\n{\n    int i, j;\n\n    printf(\"Martix Graph:\\n\");\n    for (i = 0; i < G.n; i++)\n    {\n        for (j = 0; j < G.n; j++)\n            printf(\"%d \", G.edges[i][j]);\n        printf(\"\\n\");\n    }\n}\n//创建一个树的左子女，右兄弟结构\ntypedef struct node\n{\n    int data;\n    node *firstChild = NULL;\n    node *nextSibling = NULL;\n}TreeNode, *BinTree;\nint visited[MAXV];\nvoid Dfs(ALGraph G, int i, BinTree &T)\n{\n    visited[i] = 1;\n    bool first = true;//表示是否为当前节点第一个孩子\n    TreeNode *locat = new TreeNode;//同样是定位作用\n    while (G.adjlist[i].firstarc != NULL)//从此节点出发，访问邻接节点。\n    {\n        if (visited[G.adjlist[i].firstarc->adjvex] == 0)\n        {\n            visited[G.adjlist[i].firstarc->adjvex] = 1;\n            TreeNode *t = new TreeNode;//建立一颗小树\n            t->data = G.adjlist[i].firstarc->adjvex;\n            if (first)//是当前节点第一个孩子\n            {\n                T->nextSibling = t;//建立右孩子\n                first = false;//表示不是传进来的第一个孩子,则是孩子们的兄弟\n            }\n            else\n            {\n                locat->nextSibling = t;\n            }\n            locat = t;\n            Dfs(G, G.adjlist[i].firstarc->adjvex, t);//继续对小树找兄弟\n        }\n        G.adjlist[i].firstarc = G.adjlist[i].firstarc->nextarc;\n    }\n}\n\nvoid DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n\n//建立图深度优先搜索森林\nvoid DFSForest(ALGraph G, BinTree &T)\n{\n    DFS_Traverse(G, T);\n}\nvoid Display(BinTree T)\n{\n    if (T)\n    {\n        cout << T->data << ' ';\n        Display(T->firstChild);\n        Display(T->nextSibling);\n    }\n}\n\n\n\n//以下主函数用作调试\nint main()\n{\n    //int i, j;\n    MGraph* g, g1;\n    ALGraph G;\n    BinTree T;\n    g = create_graph();\n    printf(\"\\n\");\n    printf(\" 无向图G的邻接矩阵:\\n\");\n    DispMat(g);\n\n\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    //M = (ALGraph *)malloc(sizeof(ALGraph));\n    printf(\" 图G的邻接矩阵转换成邻接表，顶点名称用编号表示:\\n\");\n    MatToList(g, &G);\n    DispAdj(G);\n    DFSForest(G, T);\n    Display(T);\n\n\n    system(\"pause\");\n}\n", "\n\n", "运行程序，输入顶点和边的信息，能够输出邻接矩阵和邻接表，但到了生成森林那一步就报异常：", "\n和同学研究了一下发现问题可能是出在执行到函数", "\n\n", "void DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n", "\n\n", "的最后一个for中的Dfs（G，i，locat）；这一句时出了问题，若在该处设置断点再重新运行程序并输入测试数据：", "\n然后按F11逐行运行，就跳到了函数Dfs（）那里：", "\n这时候按“继续”继续运行，到第二次循环时异常就出现了，请教大佬我应该如何修改这个程序，谢谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;给你写了个树&amp;#xff0c;然后按照二叉树排序了一个数组&amp;#xff0c;然后按中序遍历打印树的结点值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n\npublic &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Tree {\n\n    public &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; value;\n    public Tree left;\n    public Tree right;\n\n    &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        value &amp;#61; v;\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;AddLeft(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        left &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;AddRight(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        right &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (v &amp;lt; value) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (left&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;null) {\n                &lt;span class=\"hljs-constructor\"&gt;AddLeft(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                left.&lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            }\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (right&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;null) {\n                &lt;span class=\"hljs-constructor\"&gt;AddRight(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                right.&lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            }\n        }\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (left !&amp;#61; null) {\n            left.&lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(value);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (right !&amp;#61; null) {\n            right.&lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt;;\n        }\n    }\n\n    public static void main(String&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; args) {\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; values&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; { &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; };\n        Tree bt &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;values&lt;/span&gt;[0])&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; values.length; i&amp;#43;&amp;#43;) {\n            bt.&lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;values&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;])&lt;/span&gt;;\n        }\n        bt.&lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt;;\n    }\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["二叉树怎么打印，为什么图中的left和right会报红？", ["\n", "\n", "import", " javax.swing.tree.TreeNode;  ", "//这玩意儿也有导包，可以在非主方法里赋类型啥的", "\n", "import", " java.util.ArrayList;\n", "import", " java.util.List;\n\n", "public", " ", "class", " ", "demoEz94", " {  ", "//深度优先搜索跟递归有关跟深度优先搜索也有关", "\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "Tree", " ", "bt", " ", "=", " ", "new", " ", "Tree", "();\n        bt.createBinTree(bt.root);\n    }\n\n\n\n    ", "public", " List<Integer> ", "solution", "(TreeNode root)", "{\n        List<Integer> res = ", "new", " ", "ArrayList", "<Integer>();\n        inorder(root, res);\n        ", "return", " res;\n\n    }\n\n    ", "public", " ", "void", " ", "inorder", "(TreeNode root, List<Integer> res)", "{\n        ", "if", "(root == ", "null", "){\n            ", "return", ";\n        }\n        inorder(root.left, res);\n        res.add(root.val);\n        inorder(root.right, res);\n\n    }\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;xx✔x&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["请问这几句话哪几句是说法正确的？", ["1.⼴度优先搜索和深度优先搜索不可以互相转化。", "2.如果递推得到的答案很⼤，需要取模，可以只在算出结果后取模，在中间过程不⽤取模。", "3.递推需要严格的边界条件和数据范围。", "4.编译正确，并且样例输出正确的代码，提交之后⼀定可以AC。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考一下&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n \n#define OK 1\n#define ERROR -1\n#define OVERFLOW 0\t\t\t\t\n#define MAXVER 20\t\t\t\t//定义最大定点数\n#define MAXINT 200\t\t\t   \t// 无穷大\n#define NULL 0\n \ntypedef char verType;\t\t\t//定义顶点类型\ntypedef int status ;\n \ntypedef struct ver\t\t\t\t//关于景点(顶点)信息存放&amp;#xff08;结构体数组&amp;#xff09;\n{\n\tchar name[20];\t\t\t\t//存放景点名称\n\tchar mask;\t\t\t\t\t//存放景点代号\n\tchar intro[20];\t\t\t\t//景点简介\n    \n}Ver[MAXVER];\n \ntypedef struct\t\t\t\t\t//无向网存放景区信息\n{\n\tVer  verx;\t\t\t\t\t//定义顶点\n    int arcs[MAXVER][MAXVER];\t//定义弧\n\tint vernum,arcsnum;\t\t\t//定义最大顶点数 和弧\n}MGraph;\n \nint locate(MGraph G,verType ch) //查找顶点在数组中的下标\n{\n\tint i;\n    for(i&amp;#61;0;i&amp;lt;G.vernum&amp;amp;&amp;amp;ch!&amp;#61;G.verx[i].mask;i&amp;#43;&amp;#43;);\n\treturn i;\n}\n \nstatus createUDN(MGraph &amp;amp;G,int &amp;amp;v)\t\t\t//创建无向网\n{\n\tint i,j,w,k;\n\tverType ch1,ch2;\n\tprintf(&amp;#34;请输入场所的个数和路径数&amp;#xff1a;格式如2 3\\n&amp;#34;);\n\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;G.vernum,&amp;amp;G.arcsnum); \n\tfflush(stdin);\n\tprintf(&amp;#34;请输入顶点信息\\n&amp;#34;);\n\tfor(i&amp;#61;0;i&amp;lt;G.vernum;i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;\\n请输入第%d个景点名称:\\n&amp;#34;,i&amp;#43;1);\n\t\tscanf(&amp;#34;%s&amp;#34;,&amp;amp;G.verx[i].name);\n\t\tfflush(stdin);\n\t\tprintf(&amp;#34;请输入景点代号&amp;#xff0c;用一个字符表示如A\\n&amp;#34;);\n\t\tscanf(&amp;#34;%c&amp;#34;,&amp;amp;G.verx[i].mask);\n\t\tfflush(stdin);\n\t\tprintf(&amp;#34;请对景点简单介绍\\n&amp;#34;);\n\t\tscanf(&amp;#34;%s&amp;#34;,&amp;amp;G.verx[i].intro);\n\t\tfflush(stdin);\n\t}\n\tfor(i&amp;#61;0;i&amp;lt;G.vernum;i&amp;#43;&amp;#43;)\n\t{\n\t\tfor(j&amp;#61;0;j&amp;lt;G.vernum;j&amp;#43;&amp;#43;)\n\t\t\tG.arcs[i][j]&amp;#61;MAXINT;\t\t\t//赋初值为无穷大\n\t}\n\tprintf(&amp;#34;请输入场所间距离&amp;#xff1a;格式A B 3\\\\n \\n&amp;#34;);\n\tfor(i&amp;#61;0;i&amp;lt;G.arcsnum;i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;请输入第%d对值\\n&amp;#34;,i&amp;#43;1);\n\t\tscanf(&amp;#34;%c %c %d&amp;#34;,&amp;amp;ch1,&amp;amp;ch2,&amp;amp;w);\t\t   //输入顶点符号和权值\n\t\tfflush(stdin); \n\t\tk&amp;#61;locate(G,ch1);\t\t\t\t\t   //获得顶点下标\n\t\tj&amp;#61;locate(G,ch2);\n\t\tG.arcs[k][j]&amp;#61;w;\t\t\t\t\t\t   //为临界矩阵赋值\n\t\tG.arcs[j][k]&amp;#61;G.arcs[k][j];\t\t\t   //无向图为对称矩阵\n\t}\n\treturn OK;\n}\n \n \nvoid message(MGraph G)\t\t\t\t\t\t//进行信息查询\n{\n    char mask;\n\tprintf(&amp;#34;请输入要查询景点代号如A\\n&amp;#34;);\n\tscanf(&amp;#34;%c&amp;#34;,&amp;amp;mask);\n\tfflush(stdin);\n\t\tfor(int i&amp;#61;0;i&amp;lt;G.vernum;i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tif(mask&amp;#61;&amp;#61;G.verx[i].mask)\n\t\t\t{\n\t\t\t\tprintf(&amp;#34;景点名称&amp;#xff1a;%s\\n景点简介&amp;#xff1a;%s&amp;#34;,G.verx[i].name,G.verx[i].intro);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n}\n \n \nint search(MGraph G)\t\t\t\t\t\t//进行最短路径查询\n{\n\tchar value1,value2; \n\tint i,j;\t\t\t\t\t\t\t\t//存放两个值得下标\n\tint q;\n\tint all&amp;#61;0;\t\t\t\t\t\t\t\t//记录经过点的个数\n\tint lujing[MAXINT][MAXINT];\t\t\t    //用来 记录路径\n\tfor (int m&amp;#61;0;m&amp;lt;MAXINT;m&amp;#43;&amp;#43;)\n\t\tfor (int n&amp;#61;0;n&amp;lt;MAXINT;n&amp;#43;&amp;#43;)\n\t\t\tlujing[m][n]&amp;#61;NULL;\n \n\tint sub;\n\tint D[MAXVER],P[MAXVER],min;\n\tbool final[MAXVER];\n\tprintf(&amp;#34;\\n请输入两个场所值求其最短距离和路径 如A B\\n&amp;#34;);\n\tscanf(&amp;#34;%c %c&amp;#34;,&amp;amp;value1,&amp;amp;value2);\n    i&amp;#61;locate(G,value1);\t\t\t\t\t\t//获得第一个顶点下标\n\tj&amp;#61;locate(G,value2);\t\t\t\t\t\t//获取第二个顶点下标\n\tsub&amp;#61;i;\n\t\n\tfor(int v&amp;#61;0;v&amp;lt;G.vernum;&amp;#43;&amp;#43;v)\t\t\t\t//初始化工作\n\t{\n       final[v]&amp;#61;false;\t\t\t\t\t\t//从起始点到另外点均未找到最短路径 主要是定义一个集合将访问过的点设置值为true  刚开始集合为空\n       D[v]&amp;#61;G.arcs[i][v];\t\t\t\t\t//从其余点到起始点距离(记录是最短距离  到起始点)\n \n\t}\n\tD[i]&amp;#61;0;final[i]&amp;#61;true;\t\t\t\t\t//起始点到起始点距离为0 起始点设置为已经访问过\n\tP[sub]&amp;#61;-1;\n \n\t\n\tfor(int out&amp;#61;1;out&amp;lt;G.vernum;out&amp;#43;&amp;#43;)\t\t//最多扩充n-1个点到已经访问过的点集\n\t{\n       min&amp;#61;MAXINT;\n\t   for(int w&amp;#61;0;w&amp;lt;G.vernum;w&amp;#43;&amp;#43;)\t\t\t// 在当前未选择点集中选估计距离最小的顶点k\n\t   {\n\t\t   if(!final[w])\n\t\t\t   if(D[w]&amp;lt;min) { q&amp;#61;w; min&amp;#61;D[w]; }\t\t\t   \t\t\t   \n\t   }\n\t   final[q]&amp;#61;true;\t\t\t\t\t\t//将最小距离点加入到已经访问过点集中\n       P[q]&amp;#61;sub;\n\t   for( w&amp;#61;0;lujing[q][w]!&amp;#61;NULL;w&amp;#43;&amp;#43;){}\n\t   lujing[q][w]&amp;#61;q;\t\t\t\t  \t\t   \t   \n\t   for(int m&amp;#61;0;m&amp;lt;G.vernum;m&amp;#43;&amp;#43;)\t\t\t//调整剩余点到起始点的估计距离\n\t   {\n\t\t   if(!final[m]&amp;amp;&amp;amp;(min&amp;#43;G.arcs[q][m]&amp;lt;D[m]))\n\t\t   {\n\t\t\t   D[m]&amp;#61;min&amp;#43;G.arcs[q][m];sub&amp;#61;q;\n\t\t\t   P[m]&amp;#61;sub;\n\t\t       for( w&amp;#61;0;lujing[q][w]!&amp;#61;NULL ;w&amp;#43;&amp;#43;)\n\t\t\t\t   lujing[m][w]&amp;#61;lujing[q][w];\n\t\t\t   for(;lujing[m][w]!&amp;#61;NULL;w&amp;#43;&amp;#43;)\n\t\t\t\t   lujing[m][w]&amp;#61;NULL;\n\t\t   }\n\t   }\n\t   if(q&amp;#61;&amp;#61;j)\n\t   {\n\t\t   printf(&amp;#34;最短路径为%d\\n&amp;#34;,D[j]);\n\t\t   printf(&amp;#34;依次经过景区为:&amp;#34;);\n\t\t\t\tprintf(&amp;#34;%c   &amp;#34;,value1);\n\t\t\t   for (int c&amp;#61;0;lujing[j][c]!&amp;#61;NULL;c&amp;#43;&amp;#43;)\n\t\t\t   {\n \n\t\t\t\t   printf(&amp;#34;%c   &amp;#34;,G.verx[lujing[j][c]].mask);\n\t\t\t   }\n\t   }\n\t}\n \n return 0;\t\n}\n \n \n \n \nint main()\n{\n\tMGraph G;\n\tint v&amp;#61;0;\n\tint alter;\n\tprintf(&amp;#34;请先输入建立校园图所需要的信息&amp;#xff1a;\\n\\n&amp;#34;);\n\tif(createUDN(G,v))\t\t\t\t\t\t//创建无向网\n\t{\n\t\t do\n\t\t {\n\t\t\t printf(&amp;#34;\\n\\n查询某个景点信息请输入1\\n&amp;#34;);\n\t\t\t printf(&amp;#34;查询两个景点之间最短距离请输入2\\n&amp;#34;);\n\t\t\t printf(&amp;#34;退出请输入0\\n&amp;#34;);\n\t\t\t scanf(&amp;#34;%d&amp;#34;,&amp;amp;alter);\n\t\t\t fflush(stdin);\n\t\t\t switch(alter)\n\t\t\t {\n\t\t\t\t case 0:return 0; break;\n\t\t\t\t case 1: message(G);break;\n\t\t\t\t case 2:search(G);break;\t\n\t\t\t }\n\t\t}while(alter);\n\t}\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["图（导游图）的创建---------", ["制作陶瓷学院的校园导游图，游客通过终端可询问： （1）从某一景点到另一景点的最短路径。 （2）游客从公园进入，选取一条最佳路线3，使游客可以不重复地游览各景点，最后回到出口（出口就在入口处旁边） 2、要求 （1）将导游图看作一张带权无向图，顶点表示公园的各个景点，边表示各景点之间的道路，边上的权值表示距离。为此图选择适当的数据结构。 （2）把各种路径都显示给游客，由游客自己选择游览路线。 （3）画出景点分布图于屏幕上。 3、实现提示 （1）第一实际是最短路径问题，如果有几条路径长度相同，可选择途径景点较少的路径提供给游客。 （2）第二问可采用深度优先搜索，如果有多种路径可选择，则选择带权路径最小的路线提供给游客。    "]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ans[&lt;span class=\"hljs-number\"&gt;21&lt;/span&gt;];      &lt;span class=\"hljs-comment\"&gt;//用于存放答案&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, total;    &lt;span class=\"hljs-comment\"&gt;//总方案数&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;pr&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d)&lt;/span&gt;&lt;/span&gt;{   &lt;span class=\"hljs-comment\"&gt;//按照要求打印答案&lt;/span&gt;\n    total&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;lt;&amp;#61;d&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)cout&amp;lt;&amp;lt;ans[i]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;ans[d]&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dep, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rest)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(rest&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dep&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;){   &lt;span class=\"hljs-comment\"&gt;//避免单独值的出现&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;pr&lt;/span&gt;(dep&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;ans[dep&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;]; i&amp;lt;&amp;#61;rest; i&amp;#43;&amp;#43;){\n        ans[dep]&amp;#61;i;\n        &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(dep&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, rest-i);\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    cin&amp;gt;&amp;gt;n;\n    ans[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//初始化拆&amp;#xff0c;18行循环语句的初始值&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, n);\n    &lt;span class=\"hljs-comment\"&gt;//cout&amp;lt;&amp;lt;total;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["请问谁能告诉我这道题的思路c++", ["\n", "\n  ", "自然数拆分 - 题库 - 计蒜客", "\n  ", "题号：T1248；知识点：深度优先搜索；难度：普及T2；对于任意大于 $1$ 的自然数 $n$，总是可以拆分成若干个小于 $n$ 的自然数之和。现请你编写程序求出 $n$ 的所有拆分。输入格式输入文件共一行，包含一个自然数，即要拆分的自然数 $n(1 \\le n \\le 20)$。输出格式输出文件", "\n  ", "\n  ", "\n    ", "\n      ", "https://nanti.jisuanke.com/t/T1248", "\n    ", "\n  "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;它之前的表达是没错的&amp;#xff0c;就像事件A&amp;#61;“今天会下雨” &amp;#xff0c;事件B&amp;#61;“明天会下雨”&amp;#xff0c;虽然A or B表示今天或明天下雨即今明两天至少1天下雨。&lt;br /&gt;如果加个not即 not (A or B) 就表示“今明两天至少1天下雨”的反面事件-------也就是今明两天都不下雨。可以理解成not (A or B)&amp;#61;(not A) and (not B)&lt;br /&gt;所以它原来的not (left or right)&amp;#61;(not left) and (not right) 即左空且右空&amp;#xff0c;即左右都空&amp;#xff0c;它原来的注释正确。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["对称二叉树Python解法", ["# 深度优先搜索\n", "class", " Solution:\n    def is", "Symmetric(", "self", ", ", "root", ": Optional[TreeNode])", " -> ", "bool", ":\n        ", "if", " not root: # 空树\n            return True\n        def ", "DFS(", "left", ", ", "right", ")", ":\n            ", "if", " not (left ", "or", " right): # 左右子树，都为空\n                return True\n            ", "if", " not (left ", "and", " right): # 左右子树，一边为空\n                return False\n            ", "if", " left.", "val", " != right.", "val", ":\n                return False\n            return ", "DFS(", "left", ".", "left", ", ", "right", ".", "right", ")", " ", "and", " ", "DFS(", "left", ".", "right", ", ", "right", ".", "left", ")", "\n        return ", "DFS(", "root", ".", "left", ", ", "root", ".", "right", ")", "\n\n", "\n", "第五行和第七行我在想and和or是不是弄反了", "还有对left和right有点疑问 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;没区别&amp;#xff0c;只是第二种逻辑更清晰一点&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["搜索与回溯算法模板区别", ["以下两种搜索与回溯的算法模板，哪一个更好更通用，有什么区别？", "\n", "算法模板1：", "\n", "int", " ", "search", "(", "int", " ", "k", "){\n         ", "for", "(", "int", " ", "i", "=", "0", ";", "i", "<", "max", "(可能数);", "i", "++){\n              ", "if", "(满足可被继续搜索的条件){\n                       保存结果，标记该点为已搜索\n                       ", "if", "(到达目的地) 输出解\n                       ", "else", " ", "search", "(", "k", "+", "1", ")", "//搜索下一步", "\n                       回溯一步，恢复现场\n               }\n        }\n}", "\n", "\n", "算法模板2：", "\n", "int", " ", "search", "(", "int", " ", "k", "){\n       ", "if", "(到达目的地) 输出解并返回\n       ", "for", "(", "int", " ", "i", "=", "0", ";", "i", "<", "max", "(可能数);", "i", "++){\n              ", "if", "(满足可被继续搜索的条件){\n                       保存结果，标记该点为已搜索\n                       ", "search", "(", "k", "+", "1", ")", "//搜索下一步", "\n                       回溯一步，恢复现场\n               }\n        }\n}", "\n", "\n", "最初觉得没有区别", "，但这个题目  马走日", "马在中国象棋以日字形规则移动。", "请编写一段程序，给定n*m大小的棋盘，以及马的初始位置（x,y),要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。", "输入：", "第一行为整数T(T<10),表示测试数据组数。", "每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标n,m,x,y.(0<=x<=n-1,0<=y<=m-1,m<10,n<10)", "输出：", "每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，0为无法遍历一次．", "样例输入：", "1", "5 4 0 0", "样例输出：", "32", "所有解答都是用第二个模板，如果用第一个模板，怎么改！如果改不了，那第一种模板存在的意义是什么，有什么题必须用第一种模板么？多谢各位"]], "Tag": "算法设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;有帮助的话&amp;#xff0c;希望能够采纳支持一下&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n-*- coding:utf-8 -*-\nAuthor&amp;#xff1a;yang-roc\nQQ:327844461\nEmail&amp;#xff1a;aida_pc&amp;#64;qq.com\nTime: 2021-07-30\n&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;testMedium200&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;# dfs  deep-first search  树分支深度优先搜索&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, grid, r, c&lt;/span&gt;):\n        grid[r][c] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        nr, nc &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid), &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; x, y &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; [(r - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, c), (r &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, c), (r, c - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (r, c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; x &amp;lt; nr &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; y &amp;lt; nc &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; grid[x][y] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:\n                self.dfs(grid, x, y)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;numIslands&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, grid&lt;/span&gt;):  &lt;span class=\"hljs-comment\"&gt;# grid: List[List(str)] #集合字符串最后以集合的方式接受输出打印&lt;/span&gt;\n        nr &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; nr &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        nc &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n        num_islands &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; r &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(nr):\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; c &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(nc):\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; grid[r][c] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:\n                    num_islands &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n                    self.dfs(grid, r, c)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; num_islands\n\n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; __name__ &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:\n    t &amp;#61; testMedium200()\n    &lt;span class=\"hljs-comment\"&gt;# 示例①&lt;/span&gt;\n    grid1 &amp;#61; [\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;]\n    ]\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(t.numIslands(grid1))\n    &lt;span class=\"hljs-comment\"&gt;# 示例②&lt;/span&gt;\n    grid2 &amp;#61; [\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;]\n    ]\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(t.numIslands(grid2))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt; 程序运行截图&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/290125975726130.png\" /&gt;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["leetcode200题 dfs怎么打印呀，不会打印", ["\n", "\n", "\n", "class", " ", "testMedium200", ":      ", "#dfs  deep-first search  树分支深度优先搜索", "\n    ", "def", " ", "dfs", "(", "self, grid, r, c", "):\n        grid[r][c] = ", "0", "\n        nr, nc = ", "len", "(grid), ", "len", "(grid[", "0", "])\n        ", "for", " x, y ", "in", " [(r-", "1", ",c),(r+", "1", ", c), (r, c-", "1", "), (r, c+", "1", ")]:\n            ", "if", " ", "0", " <= x < nr ", "and", " ", "0", " <= y <nc ", "and", " grid[x][y] == ", "'1'", ":\n                self.dfs(grid, x, y)\n\n\n    ", "def", " ", "numIslands", "(", "self, grid", "): ", "#grid: List[List(str)] #集合字符串最后以集合的方式接受输出打印", "\n        nr = ", "len", "(grid)\n        ", "if", " nr == ", "0", ":\n            ", "return", " ", "0", "\n        nc = ", "len", "(grid[", "0", "])\n\n        num_islands = ", "0", "\n        ", "for", " r ", "in", " ", "range", "(nr):\n            ", "for", " c ", "in", " ", "range", "(nc):\n                ", "if", " grid[r][c] == ", "'1'", ":\n                    num_islands += ", "1", "\n                    self.dfs(grid, r , c)\n\n        ", "return", " num_islands\n\n    grid = [  [", "\"1\"", ",", "\"1\"", ",", "\"1\"", ",", "\"1\"", ",", "\"0\"", "],  [", "\"1\"", ",", "\"1\"", ",", "\"0\"", ",", "\"1\"", ",", "\"0\"", "],[", "\"1\"", ",", "\"1\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", "],[", "\"0\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", "\n    ", "if", " __name__ == ", "'__main__'", ":\n     t = testMedium200()\n    target = ", "9", "\n    ", "print", "(t.dfs(grid))\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;不就调用一下方法吗。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define MAXV 1000 //最大顶点数设为1000//&lt;/span&gt;\ntypedef struct { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义结构体类型&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint Visited[MAXV]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;顶点标记&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint Edges[MAXV][MAXV]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;邻接矩阵数组&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint VertexN,EdgeN; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;顶点和边数&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}Graph; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用邻接矩阵存储的图结构体&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n\nvoid InitializeG(Graph*G)\n{ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;图的初始化&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint i,j;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;MAXV;i&amp;#43;&amp;#43;)\n{\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;MAXV;j&amp;#43;&amp;#43;)\nG-&amp;gt;Edges[i][j]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\nG-&amp;gt;Visited[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\nG-&amp;gt;VertexN&amp;#61;G-&amp;gt;EdgeN&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\nvoid ReadG(Graph*G) &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;读入并存储一个图&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n{\nint i,V1,V2;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;G-&amp;gt;VertexN,&amp;amp;G-&amp;gt;EdgeN); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用户输入顶点数和边数&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;G-&amp;gt;EdgeN;i&amp;#43;&amp;#43;)\n{\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;V1,&amp;amp;V2); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入顶点名称&amp;#xff0c;比坐标大&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#xff08;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;到N&amp;#xff09;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nG-&amp;gt;Edges[V1-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][V2-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;G-&amp;gt;Edges[V2-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][V1-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n}\n\nvoid DFS(Graph*G,int V)\n{ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;图G的深度优先搜索&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint W;\nG-&amp;gt;Visited[V]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将访问到的结点进行标记&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(W&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;G-&amp;gt;VertexN;W&amp;#43;&amp;#43;)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G-&amp;gt;Edges[V][W]&amp;amp;&amp;amp;!G-&amp;gt;Visited[W])\nDFS(G,W);\n}\n\nint CheckG(Graph*G)\n{ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;检查边的度是否全为偶数&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint r,i,j;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;G-&amp;gt;VertexN;i&amp;#43;&amp;#43;)\n{\nr&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;G-&amp;gt;VertexN;j&amp;#43;&amp;#43;)\nr&amp;#43;&amp;#61;G-&amp;gt;Edges[i][j];\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r%&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;发现奇数度的边则返回&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}\nreturn &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;全是偶数度的边则返回&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}\n\nint main()\n{\nGraph *G&amp;#61;(Graph*)malloc(sizeof(Graph));\nInitializeG(G);\nReadG(G);\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,CheckG(G));\nreturn &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["七巧问题 c语言程序已给出 mian函数问号处该怎么写呢", ["#include<stdio.h>", "#include<stdlib.h>", "#define MAXV 1000                                           /", "最大顶点数设为1000", "/", "typedef struct {                                            /", "定义结构体类型", "/", "    int Visited[MAXV];                                      /", "顶点标记", "/", "    int Edges[MAXV][MAXV];                                  /", "邻接矩阵数组", "/", "    int VertexN,EdgeN;                                      /", "顶点和边数", "/", "}Graph;                                                     /", "用邻接矩阵存储的图结构体", "/ ", "\n", "void InitializeG(Graph*G)", "{                                                           /", "图的初始化", "/", "    int i,j;", "    for(i=0;i<MAXV;i++)", "    {", "        for(j=0;j<MAXV;j++)", "             G->Edges[i][j]=0;", "             G->Visited[i]=0;", "    }", "    G->VertexN=G->EdgeN=0;", "}                                                           ", "\n", "void ReadG(Graph*G)                                         /", "读入并存储一个图", "/", "{", "    int i,V1,V2;", "    scanf(\"%d%d\",&G->VertexN,&G->EdgeN);                    /", "用户输入顶点数和边数", "/", "    for(i=0;i", "EdgeN;i++)", "    {", "        scanf(\"%d%d\",&V1,&V2);                              /", "输入顶点名称，比坐标大1（1到N）", "/", "        G->Edges[V1-1][V2-1]=G->Edges[V2-1][V1-1]=1;", "    }", "}", "\n", "void DFS(Graph*G,int V)", "{                                                           /", "图G的深度优先搜索", "/", "    int W;", "    G->Visited[V]=1;                                        /", "将访问到的结点进行标记", "/", "    for(W=0;W", "VertexN;W++)", "         if (G->Edges[V][W]&&!G->Visited[W])", "         DFS(G,W);", "}", "\n", "int CheckG(Graph*G)", "{                                                           /", "检查边的度是否全为偶数", "/", "    int r,i,j;", "    for(i=0;i", "VertexN;i++)", "    {", "        r=0;", "        for(j=0;j", "VertexN;j++)", "             r+=G->Edges[i][j];", "        if (r%2) return 0;                                  /", "发现奇数度的边则返回0", "/", "    }", "    return 1;                                               /", "全是偶数度的边则返回1", "/", "}", "\n", "int main()", "{", "    int i;", "    Graph", "G=(Graph", ")malloc(sizeof(Graph));", "    ？", "    return 0;", "}", "注：（1）", "输入说明：输入的第1行包含两个正整数，分别为结点数N(1<N<1000)和", "边数M。随后的M行对应M条边，每行给出一对正整数，分别是该条边连", "通的两个结点的编号（结点从1到N编号）。", "（2）", "输出说明：若欧拉回路存在则输出1，否则输出0。", "（3）", "测试实例：", "1）输入：", "6 10", "1 2", "2 3", "3 1", "4 5", "5 6", "6 4", "1 4", "1 6", "3 4", "3 6", "输出：1", "(说明：存在欧拉回路)", "２）输入：", "5 8", "1 2", "1 3", "2 3", "2 4", "2 5", "5 3", "5 4", "3 4", "输出：0", "（说明：不存在欧拉回路）"]], "Tag": "算法设计"}
{"Answer": "你的代码直接把我的Eclipse给卡顿了，停止按钮都没有效果了。\r\n参考个正确版本的吧，绝对秒出结果，只需修正打印语句末尾改为\"\\n\"打印换行即可。\r\nhttp://blog.csdn.net/zhong317/article/details/4586131", "Konwledge_Point": "图的深度优先搜索", "Question": ["(已解决)自己用java写的八皇后问题算法，可是不行,求告知原因", ["\npublic class Test {\n\n    public static void main(String[] args) {\n        Empress a=new Empress();\n        a.find(0,0);\n        System.out.println(a.map);\n    }\n}\n\nclass Empress{\n    public int[][] arry=new int[8][8];\n    public  int map=0;\n\n    public   boolean rule(int arry[][],int k,int j){    //判断节点是否合适\n        for(int i=0;i<8;i++){   //行列冲突\n            if(arry[k][i]==1)\n                return false;\n            else if(arry[i][j]==1)\n                return false;\n        }\n        for(int i=k-1,m=j-1;i>=0&&m>=0;i--,m--){    //左对角线\n            if(arry[i][m]==1)\n                return false;\n        }\n        for(int i=k-1,m=j+1;i>=0&&m<=7;i--,m++){    //右对角线\n            if(arry[i][m]==1)\n                return false;\n        }\n        return true;\n    }\n\n\n    public void find(int i,int m){  //寻找皇后节点\n        if(i>7){    //皇后解 \n            map++;\n        }else{\n            for(int j=i+1;j<8;j++){     //刷新当前结点下的数组\n                for(int k=0;k<8;k++){\n                    arry[j][k]=0;\n                }\n            }\n            for(;i<8;i++){      //深度优先搜索\n                for(;m<8;m++){\n                    if(rule(arry,i,m)){\n                        arry[i][m]=1;\n                        find(i+1,0);\n                    }\n                }\n            }\n        }\n    }\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你说的是可以的&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["结构体指针与结构体？", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "#", "include", "<string.h>", "\n\n", "#", "define", " MAX 100", "\n", "#", "define", " LENGTH(a) (sizeof(a)/sizeof(a[0]))", "\n\n", "//邻接表中标对应的链表的结点", "\n", "typedef", " ", "struct", " ", "_ENode", "\n{\n    ", "int", " ivex;                   ", "// 该边所指向的顶点的位置,是数组的下标", "\n    ", "struct", " ", "_ENode", "* next_edge;   ", "// 指向下一条弧的指针", "\n}ENode,*PENode;\n\n", "//邻接表中的表的顶点", "\n", "typedef", " ", "struct", " ", "_VNode", "\n{\n    ", "char", " data;              ", "// 顶点信息", "\n    ENode* first_edge;      ", "// 指向第一条依附该顶点的弧", "\n}VNode;\n\n", "//邻接表", "\n", "typedef", " ", "struct", " ", "_LGraph", "\n{\n    ", "int", " vexnum;            ", "// 图的顶点的数目", "\n    ", "int", " edgnum;            ", "// 图的边的数目", "\n    VNode vexs[MAX];\n}LGraph;\n\n", "//返回ch在matrix矩阵中的位置", "\n", "static", " ", "int", " ", "get_position", "(LGraph g, ", "char", " ch)", "    ", "//为什么用static？", "\n", "{\n    ", "int", " i;\n    ", "for", " (i = ", "0", "; i < g.vexnum; i++)\n        ", "if", " (g.vexs[i].data == ch)\n            ", "return", " i;\n    ", "return", " ", "-1", ";\n}\n", "//将node链接到list的末尾", "\n", "static", " ", "void", " ", "link_last", "(ENode* list, PENode node)", "\n", "{\n    PENode p = list;\n    ", "while", " (p->next_edge)\n        p = p->next_edge;\n    p->next_edge = node;\n}\n", "//打印邻接表图", "\n", "void", " ", "print_lgraph", "(LGraph G)", "\n", "{\n    ", "int", " i;\n    PENode node;\n\n    ", "printf", "(", "\"List Graph:\\n\"", ");\n    ", "for", " (i = ", "0", "; i < G.vexnum; i++)  ", "//遍历所有的顶点", "\n    {\n        ", "printf", "(", "\"%d(%c): \"", ", i, G.vexs[i].data);\n        node = G.vexs[i].first_edge;\n        ", "while", " (node != ", "NULL", ")  ", "//把每个顶点周围的结点都输出一下", "\n        {\n            ", "printf", "(", "\"%d(%c) \"", ", node->ivex, G.vexs[node->ivex].data);\n            node = node->next_edge;\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n}\n\n", "//创建邻接表对应的图(用已提供的数据)，无向图", "\n", "LGraph* ", "create_example_lgraph", "()", "\n", "{\n    ", "char", " c1, c2;\n    ", "char", " vexs[] = { ", "'A'", ", ", "'B'", ", ", "'C'", ", ", "'D'", ", ", "'E'", ", ", "'F'", ", ", "'G'", " };\n    ", "char", " edges[][", "2", "] = {\n        {", "'A'", ", ", "'C'", "},\n        {", "'A'", ", ", "'D'", "},\n        {", "'A'", ", ", "'F'", "},\n        {", "'B'", ", ", "'C'", "},\n        {", "'C'", ", ", "'D'", "},\n        {", "'E'", ", ", "'G'", "},\n        {", "'F'", ", ", "'G'", "} };\n    ", "int", " vlen = ", "LENGTH", "(vexs);\n    ", "int", " elen = ", "LENGTH", "(edges);\n    ", "//上面类似一个邻接矩阵存储", "\n    ", "int", " pos1, pos2;\n    ENode* node1, * node2;      ", "//无向图，一条边两个对应关系", "\n    LGraph* pG;                 ", "//pG表示图", "\n\n    ", "if", " ((pG = (LGraph*)", "malloc", "(", "sizeof", "(_LGraph))) == ", "NULL", ")   ", "///////", "\n        ", "//若硬件没有内存申请失败", "\n        ", "return", " ", "NULL", ";\n    ", "memset", "(pG, ", "0", ", ", "sizeof", "(LGraph));", "//就是把申请的空间内初始化为0", "\n\n    ", "// 初始化\"顶点数\"和\"边数\"", "\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    ", "// 初始化\"邻接表\"的顶点", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = ", "NULL", ";\n    }\n\n    ", "// 初始化\"邻接表\"的边", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        ", "// 读取边的起始顶点和结束顶点", "\n        c1 = edges[i][", "0", "];\n        c2 = edges[i][", "1", "];\n\n        pos1 = ", "get_position", "(*pG, c1);        ", "//pos1对应起始顶点下标位置", "\n        pos2 = ", "get_position", "(*pG, c2);        ", "//pos2对应结束顶点下标位置", "\n                                             ", "//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以", "\n        ", "// 初始化node1", "\n        node1 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node1->ivex = pos2;\n        ", "// 将node1链接到\"p1所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos1].first_edge == ", "NULL", ")\n            pG->vexs[pos1].first_edge = node1;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos1].first_edge, node1);\n       \n        ", "// 初始化node2", "\n        node2 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node2->ivex = pos1;\n        ", "// 将node2链接到\"p2所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos2].first_edge == ", "NULL", ")\n            pG->vexs[pos2].first_edge = node2;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos2].first_edge, node2);\n    }\n}\n\n", "//创建邻接表对应的图(用已提供的数据)，有向图", "\n", "LGraph* ", "create_example_lgraph_directed", "()", "\n", "{\n    ", "char", " c1, c2;\n    ", "char", " vexs[] = { ", "'A'", ", ", "'B'", ", ", "'C'", ", ", "'D'", ", ", "'E'", ", ", "'F'", ", ", "'G'", " };\n    ", "char", " edges[][", "2", "] = {\n        {", "'A'", ", ", "'C'", "},\n        {", "'A'", ", ", "'D'", "},\n        {", "'A'", ", ", "'F'", "},\n        {", "'B'", ", ", "'C'", "},\n        {", "'C'", ", ", "'D'", "},\n        {", "'E'", ", ", "'G'", "},\n        {", "'F'", ", ", "'G'", "} };\n    ", "int", " vlen = ", "LENGTH", "(vexs);\n    ", "int", " elen = ", "LENGTH", "(edges);\n    ", "//上面类似一个邻接矩阵存储", "\n    ", "int", " pos1, pos2;\n    ENode* node1, * node2;      ", "//无向图，一条边两个对应关系", "\n    LGraph* pG;                 ", "//pG表示图", "\n\n    ", "if", " ((pG = (LGraph*)", "malloc", "(", "sizeof", "(_LGraph))) == ", "NULL", ")   ", "///////", "\n        ", "//若硬件没有内存申请失败", "\n        ", "return", " ", "NULL", ";\n    ", "memset", "(pG, ", "0", ", ", "sizeof", "(LGraph));", "//就是把申请的空间内初始化为0", "\n\n    ", "// 初始化\"顶点数\"和\"边数\"", "\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    ", "// 初始化\"邻接表\"的顶点", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = ", "NULL", ";\n    }\n\n    ", "// 初始化\"邻接表\"的边", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        ", "// 读取边的起始顶点和结束顶点", "\n        c1 = edges[i][", "0", "];\n        c2 = edges[i][", "1", "];\n\n        pos1 = ", "get_position", "(*pG, c1);        ", "//pos1对应起始顶点下标位置", "\n        pos2 = ", "get_position", "(*pG, c2);        ", "//pos2对应结束顶点下标位置", "\n                                             ", "//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以", "\n        ", "// 初始化node1", "\n        node1 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node1->ivex = pos2;\n        ", "// 将node1链接到\"p1所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos1].first_edge == ", "NULL", ")\n            pG->vexs[pos1].first_edge = node1;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos1].first_edge, node1);\n    }\n}\n\n", "//深度优先搜索遍历图的递归实现", "\n", "static", " ", "void", " ", "DFS", "(LGraph G, ", "int", " i, ", "int", " visited[])", "\n", "{\n    ", "printf", "(", "\"%c \"", ", G.vexs[i].data);\n    visited[i] = ", "1", ";\n    ENode* node;\n    node = G.vexs[i].first_edge;\n    ", "while", " (node !=", "NULL", ")\n    {\n        ", "if", " (!visited[node->ivex])", "//只要对应顶点没有访问过，深入到下一个顶点访问", "\n            ", "DFS", "(G, node->ivex, visited);\n        node = node->next_edge;", "//某个顶点的下一条边，例如B结点的下一条边", "\n    }\n}\n\n", "//深度优先搜索遍历图", "\n", "void", " ", "DFSTraverse", "(LGraph G)", "\n", "{\n    ", "int", " visited[MAX];       ", "// 顶点访问标记", "\n    ", "//初始化所有顶点都没有被访问", "\n    ", "memset", "(visited, ", "0", ", ", "sizeof", "(visited));\n   ", "/* for (int i = 0; i < G.vexnum; i++)\n        visited[i] = 0;*/", "\n    ", "printf", "(", "\"DFS:\"", ");\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    {\n        ", "if", " (!visited[i])\n            ", "DFS", "(G, i, visited);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n", "int", " ", "main", "()", "\n", "{\n    LGraph* pG;\n    pG = ", "create_example_lgraph_directed", "();\n    ", "print_lgraph", "(*pG);\n    ", "DFSTraverse", "(*pG);\n}\n", "\n", "请问定义函数时 比如static void DFS(LGraph G, int i, int visited[])", "为什么用LGraph呢 是不是把结构体指针当做参数传入也可以呀 就是后面的访问要变成-> 了"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;v[i][k]&amp;#61;&amp;#61;1;&lt;br /&gt;改成&lt;br /&gt;v[i][k]&amp;#61;1;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["NOI / 2.5基本算法之搜索-1818：红与黑", ["题目链接：", "http://noi.openjudge.cn/ch0205/solution/34697319/", "描述", "有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。", "\n", "输入", "包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下", "1）‘.’黑色的瓷砖；", "2）‘#’红色的瓷砖；", "3）‘", "@’黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。", "当在一行中读入的是两个零时，表示输入结束。", "输出", "对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。", "\n", "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,v[", "25", "][", "25", "],dx[", "4", "]={", "1", ",", "-1", ",", "0", ",", "0", "},dy[", "4", "]={", "0", ",", "0", ",", "1", ",", "-1", "},t=", "0", ";\nchar a[", "25", "][", "25", "];\nint dfs(int x,int y)\n{\n    int i,tx,ty;\n    for(i=", "0", ";i<", "4", ";i++)\n    {\n        tx=dx[i]+x;\n        ty=dy[i]+y;\n        if(tx>", "0", "&&tx<=n&&ty>", "0", "&&ty<=m&&v[tx][ty]==", "0", "&&a[tx][ty]!=", "'#'", ")\n        {\n            v[tx][ty]=", "1", ";\n            t++;\n            dfs(tx,ty);\n        }\n    }\n} \nint main()\n{\n    int i,k,x,y;\n    while(", "1", ")\n    {\n        cin>>m>>n;\n        memset(v,", "0", ",sizeof(v));\n        t=", "0", ";\n        if(m==", "0", "&&n==", "0", ")\n        return ", "0", ";\n        for(i=", "1", ";i<=n;i++)\n        {\n            for(k=", "1", ";k<=m;k++)\n            {\n                cin>>a[i][k];\n                if(a[i][k]==", "'@'", ")\n                {\n                    v[i][k]==", "1", ";\n                    x=i,y=k;\n                }\n            }\n        }\n        dfs(x,y);\n        cout<<t<<endl;\n        \n    }\n    return ", "0", ";\n}\n\n", "\n", "运行结果：Runtime Error"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;DFS&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;vector&amp;gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; MyGraph\n{\nprotected:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; vertexNum;&lt;span class=\"hljs-comment\"&gt;//顶点数量&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;** matrix;&lt;span class=\"hljs-comment\"&gt;//邻接矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;* visitedFlag;&lt;span class=\"hljs-comment\"&gt;//顶点是否访问过的标记&lt;/span&gt;\n    std::vector&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&amp;gt; pathStack;&lt;span class=\"hljs-comment\"&gt;//记录路径的栈&lt;/span&gt;\npublic:\n    &lt;span class=\"hljs-constructor\"&gt;MyGraph(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; VertexNum)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;;\n    void print&lt;span class=\"hljs-constructor\"&gt;Matrix()&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//输出邻接矩阵&lt;/span&gt;\n    void update&lt;span class=\"hljs-constructor\"&gt;Matrix(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//更新row行column列的邻接矩阵值&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;MatrixValue(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//获取邻接矩阵中对应行列号的值&lt;/span&gt;\n    void get&lt;span class=\"hljs-constructor\"&gt;PathofTwoNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//计算两个节点之间的所有路径&lt;/span&gt;\n    void find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;\n    ~&lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;MyGraph.h&amp;#34;&lt;/span&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\nusing namespace std;\n \nMyGraph::&lt;span class=\"hljs-constructor\"&gt;MyGraph(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; VertexNum)&lt;/span&gt;\n{\n    this-&amp;gt;vertexNum &amp;#61; VertexNum;\n    &lt;span class=\"hljs-comment\"&gt;//开辟访问标记数组&lt;/span&gt;\n    this-&amp;gt;visitedFlag &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//开辟邻接矩阵&lt;/span&gt;\n    this-&amp;gt;matrix &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;*&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;vertexNum;i&amp;#43;&amp;#43;)\n    {\n        this-&amp;gt;visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//将所有数组元素全部初始化为0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;vertexNum;j&amp;#43;&amp;#43;)\n            this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 无参数构造函数&amp;#xff0c;通过createTestData函数来构造一个邻接矩阵测试数据\n * 方便其他算法的测试\n */&lt;/span&gt;\nMyGraph::&lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;\n{\n    this-&amp;gt;vertexNum &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//开辟访问标记数组&lt;/span&gt;\n    this-&amp;gt;visitedFlag &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//开辟邻接矩阵&lt;/span&gt;\n    this-&amp;gt;matrix &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;*&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;vertexNum; i&amp;#43;&amp;#43;)\n    {\n        this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n        this-&amp;gt;visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//将所有数组元素全部初始化为0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;vertexNum; j&amp;#43;&amp;#43;)\n            this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//初始化邻接矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; initMatrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]&lt;/span&gt; &amp;#61; {\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-comment\"&gt;//赋值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; vertexNum; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; vertexNum; j&amp;#43;&amp;#43;)\n            this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; initMatrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;;\n    print&lt;span class=\"hljs-constructor\"&gt;Matrix()&lt;/span&gt;;\n}\n \n \nMyGraph::~&lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;vertexNum;i&amp;#43;&amp;#43;)\n        delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;;\n    delete matrix;\n    delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt;visitedFlag;\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 输出邻接矩阵\n */&lt;/span&gt;\nvoid MyGraph::print&lt;span class=\"hljs-constructor\"&gt;Matrix()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;vertexNum;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; vertexNum; j&amp;#43;&amp;#43;)\n            cout &amp;lt;&amp;lt; matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; endl;\n    }\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 更新row行column列的邻接矩阵值\n */&lt;/span&gt;\nvoid MyGraph::update&lt;span class=\"hljs-constructor\"&gt;Matrix(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;//由于是无向图&amp;#xff0c;故更新后的矩阵值是一个对称矩阵&lt;/span&gt;\n    matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;row&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;column&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;column&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;row&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 获取row行column列的邻接矩阵的值\n */&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; MyGraph::get&lt;span class=\"hljs-constructor\"&gt;MatrixValue(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;\n{\n    return this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;row&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;column&lt;/span&gt;]&lt;/span&gt;;\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 计算两个节点之间的所有路径\n */&lt;/span&gt;\nvoid MyGraph::get&lt;span class=\"hljs-constructor\"&gt;PathofTwoNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;//利用深度优先遍历的方式来计算两个节点之间的所有路径&lt;/span&gt;\n    visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;startNode&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    pathStack.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;)&lt;/span&gt;;\n    find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;\n}\n \nvoid MyGraph::find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (startNode&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;endNode)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//找到一条路径&amp;#xff0c;输出路径&lt;/span&gt;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;找到一条路径&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; node : pathStack)\n            cout &amp;lt;&amp;lt; node &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; endl;\n        visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;(&lt;span class=\"hljs-identifier\"&gt;pathStack&lt;/span&gt;.&lt;span class=\"hljs-identifier\"&gt;end&lt;/span&gt;()-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        pathStack.pop&lt;span class=\"hljs-constructor\"&gt;_back()&lt;/span&gt;;\n        return;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-comment\"&gt;//找到startNode所有没有入栈的邻接点&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; unStackedNum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n         &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;vertexNum; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;startNode&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;amp;&amp;amp; &lt;/span&gt;!visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;)\n            {\n                unStackedNum&amp;#43;&amp;#43;;\n                visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n                pathStack.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;)&lt;/span&gt;;\n                find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;\n            }\n        }\n        visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;(&lt;span class=\"hljs-identifier\"&gt;pathStack&lt;/span&gt;.&lt;span class=\"hljs-identifier\"&gt;end&lt;/span&gt;() - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        pathStack.pop&lt;span class=\"hljs-constructor\"&gt;_back()&lt;/span&gt;;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如何用邻接矩阵存储结构求无向图中两个点的所有路径", ["不是很会代码写的也不对，谢谢看看", "\n", "1", "\n", "\n", "#", "include", " ", "<bits/stdc++.h>", "\n", "#", "define", " Infinity 32766", "\n", "#", "define", " MaxVertexNum 50", "\n", "using", " ", "namespace", " std;   \n\n", "//图的邻接矩阵存储结 AdjacencyMatrixGraph", "\n", "typedef", " ", "struct", " ", "AMGraph", " {\n    ", "char", " vex[MaxVertexNum]; ", "//结点名表 ", "\n    ", "int", " arc[MaxVertexNum][MaxVertexNum]; ", "//边表 ", "\n    ", "int", " vexnum, arcnum; ", "//结点数和边数 ", "\n}AMGraph;\n\n", "int", " ", "FindVex", " ", "(AMGraph G, ", "char", " v)", "\n", "{\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    {\n        ", "if", " (G.vex[i] == v)\n        ", "return", " i;\n    }\n", "return", " ", "-1", ";    \n}\n\n", "//无向图 ", "\n", "void", " ", "GraphCreate", " ", "(AMGraph &G)", "\n", "{\n    ", "//输入结点数，边数，结点序列 ", "\n    cin >> G.vexnum >> G.arcnum;\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n        cin >> G.vex[i];\n    ", "//初始化", "\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    ", "for", " (", "int", " j = ", "0", "; j < G.vexnum; j++)\n    G.arc[i][j] = ", "0", ";    \n    ", "//构造邻接矩阵 ", "\n    ", "char", " v1, v2;\n    ", "for", " (", "int", " k = ", "0", "; k < G.arcnum; k++)\n    {\n        cin >> v1 >> v2;\n        ", "int", " i = ", "FindVex", " (G, v1);\n        ", "int", " j = ", "FindVex", " (G, v2);\n        G.arc[i][j] = G.arc[j][i] = ", "1", ";        \n    }      \n}\n\n", "int", " visited[MaxVertexNum] = {", "0", "};\nvector <", "int", "> v;\n", "//基于DFS查找图中所有路径 ", "\n", "void", " ", "AllPathDFS", " ", "(AMGraph G, ", "int", " StartV, ", "int", " EndV)", "\n", "{\n    visited[StartV] = ", "1", ";\n    v.", "push_back", " (StartV);\n    ", "for", " (", "int", " j = ", "0", "; j < G.vexnum; j++)\n    {\n        ", "if", " (StartV == EndV)\n        {    \n            ", "for", " (", "int", " k = ", "0", "; k < v.", "size", "(); k++)\n            {\n                cout << G.vex[v[k]] << ", "\" \"", ";\n            }\n            ", "puts", " (", "\"\"", "); \n            v.", "pop_back", " ();\n            visited[StartV] = ", "0", ";\n            ", "break", ";\n        }\n        \n        ", "if", " (visited[j] == ", "0", " && G.arc[StartV][j] == ", "1", ")\n           ", "AllPathDFS", " (G, j, EndV);\n        \n    }\n}\n\n", "int", " ", "main", " ", "()", "\n", "{\n    AMGraph G;\n    ", "GraphCreate", " (G);\n    ", "AllPathDFS", " (G, ", "0", ", G.vexnum - ", "1", ");\n", "return", " ", "0", ";\n}\n\n", "\n", "用DFS实现所有路径的查找", "\n", "样例", "4 5", "ABCD", "AB", "AD", "BC", "BD", "CD"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1.由于多少个元素不确定&amp;#xff0c;肯定是要递归的&amp;#xff0c;写死循环不可行&lt;br /&gt;2.不用剪枝&amp;#xff0c;递归的时候传递初始值内层与外层相等即可&amp;#xff0c;这样4只能和4,5,6去加&amp;#xff0c;5只能和5,6,7加&amp;#xff0c;6只能和6,7,8加&amp;#xff0c;不能输入的更小&lt;br /&gt;3.暴力搜索容易超时&amp;#xff0c;你应该判断如果不是最后一层递归&amp;#xff0c;相加的结果已经大于给定的数&amp;#xff0c;就结束本次循环&amp;#xff0c;不要继续了&amp;#xff08;只影响当前的层&amp;#xff0c;返回上一层之后继续外层循环&amp;#xff09;&lt;br /&gt;4.如果是最后一层&amp;#xff0c;不要再循环了&amp;#xff0c;直接用给定的数减去前n-1项的和就是最后一项&amp;#xff0c;为防止最后一项小于倒数第2项&amp;#xff0c;这个条件可以在前面3的时候就过滤掉&amp;#xff0c;不要继续循环了&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["暴搜所有组合应该怎么剪枝? 求思路", ["题目简述", "\n", "要求输出n个正整数，他们的和为s, 每个元素值的范围在[1,m]之内。求输出所有可能的组合结果。", "\n", "输入: n = 2, m = 6, s = 10，下面简述为(n, m, s), 即（2，6，10）", "\n", "输出:", "(4,6)", "(5,5)", "\n", "注意:", "(6,4)属于重复的结果", "\n", "边界约束:", "1 <= n  <= 100", "1 <= m <= 1e9", "1 <= s <=  1e5", "\n", "问题", "\n", "我用dfs暴力搜索 + 剪枝，但是还是通过不过用例。", "(100, 100, 10000)", "(3, 1e5, 20)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;假设bool占用1字节并按1字节对齐&amp;#xff0c;900000005字节/1024/1024/1024&amp;#61;0.8381903218gb&amp;#xff0c;小程序大内存。如果按照4字节对齐&amp;#xff0c;那还真不得了。系统会如何处理我不知道&amp;#xff0c;但是不应该这样写。最后&amp;#xff0c;抱歉&amp;#xff0c;没有看明白题目。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["在某些情况中，为什么程序突然中断？", ["问题", "【搜索与回溯算法】生成字符串 (Standard IO)", "时间限制: 1000 ms  空间限制: 262144 KB  具体限制  ", "\n", "题目描述：", "假设一个字符串只由字符”0”、”1”、‘", "’组成，其中字符‘", "’表示该字符可由字符”0”或”1”替代。", "\n", "现有一些字符串，根据这些字符串生成所有可生成的字符串。", "\n", "注意后一个例子中”*01”并没有生成新的字符串。", "\n", "输入", "第一行是两个整数M,N（1≤M≤15,0≤N≤2500）。M表示字符串的长度，N表示字符串的个数。", "以下N行每行各有一个字符串。各行的行首、行末没有多余的空格。", "\n", "输出", "一行，为一个整数,Total表示所能生成的字符串的个数。 ", "\n", "样例输入", "2 3", "10", "1", "0", " ", "\n", "样例输出", "4", "\n", "代码：", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\nstring a[", "2505", "];\n", "int", " n,m,t,len,flag;\n", "bool", " visit[", "900000005", "];\n", "void", " ", "dg", "(", "int", " x,", "int", " i)", "\n", "{\n    ", "if", "(x>len)\n    {\n        ", "long", " ", "long", " qn=", "atol", "(a[i].", "c_str", "());\n        ", "if", "(visit[qn]==", "0", ")\n        {\n            t++;\n            visit[qn]=", "1", ";\n            cout<<", "1", ";\n        }\n    }\n    ", "else", "\n    {\n        \n        ", "if", "(a[i][x]==", "'*'", ")\n        {\n            a[i][x]=", "'1'", ";\n            ", "dg", "(x+", "1", ",i);\n            a[i][x]=", "'0'", ";\n            ", "dg", "(x+", "1", ",i);            \n            a[i][x]=", "'*'", ";\n        }\n        ", "else", " ", "dg", "(x+", "1", ",i);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n    cin>>m>>n;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++)\n    {\n        cin>>a[i];    \n        len=a[i].", "size", "();\n        ", "dg", "(", "0", ",i);\n    }\n    cout<<t;\n}\n\n\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你程序中的问题比较多&amp;#xff0c;我修改的地方我使用****************************标识出来了&lt;br /&gt;其中一点&amp;#xff0c;new要和delete配对使用参考&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/allen807733144/article/details/73608938\" id=\"textarea_1648102336770_1648102457970_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/allen807733144/article/details/73608938&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;stack&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-comment\"&gt;//顺序查找&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Sq_Sear(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; n;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//cpu要做两次判断&amp;#xff0c;可做优化&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;key)\n        {\n            return i;\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//改进,增加一个哨兵来减少循环次数&amp;#xff0c;会污染数组&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//int i &amp;#61; n;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//a[0] &amp;#61; key;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//while (a[i] !&amp;#61; key)&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//{&lt;!-- --&gt;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//    i--;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//}&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//return i;&lt;/span&gt;\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//插值查找(按比例查找)&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; bia&lt;span class=\"hljs-constructor\"&gt;_search(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;str&lt;/span&gt;[], &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; low &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, high &amp;#61; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; mid &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (low &amp;lt;&amp;#61; high)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//折半与按比例的优劣&amp;#xff0c;数的值跨度不是很大按比例更好&amp;#xff0c;&lt;/span&gt;\n        mid &amp;#61; low &amp;#43; (key - str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;low&lt;/span&gt;]&lt;/span&gt;)&lt;span class=\"hljs-operator\"&gt; / &lt;/span&gt;(str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;high&lt;/span&gt;]&lt;/span&gt; - str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;low&lt;/span&gt;]&lt;/span&gt;)&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;(high - low);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;key)\n            return mid;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;gt; key)\n            high &amp;#61; mid - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;lt; key)\n            low &amp;#61; mid &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n\n}\n&lt;span class=\"hljs-comment\"&gt;//斐波那契查找&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//1.首先创建斐波那契数组&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//2。找到有序表最大元素&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//3.补齐有序表最大值到最接近斐波那契数组的一个元素&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//4.根据斐波那契的规则对比查找&lt;/span&gt;\n\n\nvoid produce&lt;span class=\"hljs-constructor\"&gt;Fib(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;fib&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;size&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i;\n    fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; i &amp;lt; size; i&amp;#43;&amp;#43;)\n    {\n        fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; &amp;#43; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&lt;/span&gt;;\n    }\n}\n\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;FibonacciSearch(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;data&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;searchValue&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; low &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, high &amp;#61; length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, mid &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;]&lt;/span&gt;;\n    produce&lt;span class=\"hljs-constructor\"&gt;Fib(&lt;span class=\"hljs-params\"&gt;fib&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;)&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//最接近斐波那契的数&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (high &amp;gt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        k&amp;#43;&amp;#43;;\n    }\n\n\n    &lt;span class=\"hljs-comment\"&gt;//补齐有序表&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;* temp;\n    temp &amp;#61; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;fib&lt;/span&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    memcpy(temp, data, length&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;sizeof(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; length; i &amp;lt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        data&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; data&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;high&lt;/span&gt;]&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (low &amp;lt;&amp;#61; high)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (k &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            mid &amp;#61; low &amp;#43; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            mid &amp;#61; low;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;searchValue)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (mid &amp;lt;&amp;#61; length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                return mid;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                return length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n\n\n\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;gt; searchValue)\n        {\n            high &amp;#61; mid - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k &amp;#61; k - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;lt; searchValue)\n        {\n            low &amp;#61; mid &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k &amp;#61; k - &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n    }\n\n    delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; temp;\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n\ntypedef &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode* lchild;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode* rchild;\n    &lt;span class=\"hljs-constructor\"&gt;BiNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;)&lt;/span&gt; :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n\n}BiNode,&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;BiTree;\n\n&lt;span class=\"hljs-comment\"&gt;//二叉查找树&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//T为搜索的树&amp;#xff0c;f为记录父节点的指针&amp;#xff0c;p作为临时指针保存输出&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, BiTree &lt;span class=\"hljs-params\"&gt;f&lt;/span&gt;, BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!T)\n    {\n        *p &amp;#61; f;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        *p &amp;#61; T;\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, T, &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;gt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, T, &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    BiTree f(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n   &lt;span class=\"hljs-comment\"&gt;// BiTree* p(0);****************************&lt;/span&gt;\n   &lt;span class=\"hljs-comment\"&gt;// f &amp;#61; (BiTree)new BiNode(key); p &amp;#61; new BiTree;****************************&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!T)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//*p &amp;#61; f;****************************&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//*p &amp;#61; T;****************************&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;gt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//删除&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//*p搜索位置结点&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//定义两个临时指针&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//三种情况&lt;/span&gt;\n\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Delete(BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//传输的是指针域的地址,直接修改lchild or rchild&lt;/span&gt;\n{\n    BiTree q, s;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((*t)-&amp;gt;lchild&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)&lt;span class=\"hljs-comment\"&gt;//左子树为空&amp;#xff0c;连接右子树&lt;/span&gt;\n    {\n        q &amp;#61; *t;\n        (*t) &amp;#61; (*t)-&amp;gt;lchild;\n        &lt;span class=\"hljs-comment\"&gt;//q &amp;#61; (*t)-&amp;gt;rchild;//连接右子树&amp;#xff0c;直接改变指针&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//(*t)-&amp;gt;data &amp;#61; q-&amp;gt;data;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//(*t)-&amp;gt;rchild &amp;#61; q-&amp;gt;rchild;&lt;/span&gt;\n        delete q;&lt;span class=\"hljs-comment\"&gt;//删除结点所占空间****************************&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((*t)-&amp;gt;rchild&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)&lt;span class=\"hljs-comment\"&gt;//右子树为空&amp;#xff0c;连接左子树&lt;/span&gt;\n    {\n        q &amp;#61; *t;\n        (*t) &amp;#61; (*t)-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//连接左子树&amp;#xff0c;直接改变指针&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//free(q);//删除结点所占空间&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//有两个孩子&lt;/span&gt;\n    {\n        q &amp;#61; (*t);&lt;span class=\"hljs-comment\"&gt;//找到中序遍历时的前驱结点&amp;#xff0c;即孩子结点的右子树最右边的叶子结点&lt;/span&gt;\n        s &amp;#61; (*t)-&amp;gt;lchild;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s-&amp;gt;rchild !&amp;#61; NULL)\n        {\n            q &amp;#61; s;&lt;span class=\"hljs-comment\"&gt;//记录当前结点值&lt;/span&gt;\n            s &amp;#61; s-&amp;gt;rchild;&lt;span class=\"hljs-comment\"&gt;//找到右子树最右边的叶子结点&lt;/span&gt;\n        }\n        (*t)-&amp;gt;data &amp;#61; s-&amp;gt;data;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (q&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;*t)&lt;span class=\"hljs-comment\"&gt;//孩子结点为目标结点&lt;/span&gt;\n        {\n            q-&amp;gt;lchild &amp;#61; s-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//链接&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//存在右子树&lt;/span&gt;\n        {\n            q-&amp;gt;rchild &amp;#61; s-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//目标结点的父亲结点链接孩子结点&lt;/span&gt;\n        }\n\n        delete s;&lt;span class=\"hljs-comment\"&gt;//****************************&lt;/span&gt;\n\n    }\n\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//删除二叉排序树的结点&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//1.判断是否为空树&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//2.搜索判断是否存在&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//3.执行删除函数&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;DelectBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (T&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)\n    {\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n\n    }\n\n\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;Delete(&amp;amp;T)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;DelectBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;DelectBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//插入&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;InsertBST(BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    BiTree p &amp;#61; nullptr, s &amp;#61; nullptr;\n\n\n    &lt;span class=\"hljs-comment\"&gt;//传入临时结点指针p&amp;#xff0c;通过搜索函数返回当前最接近该插入值的一个节点位置&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-constructor\"&gt;SearchBST(&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;T, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, NULL, &amp;amp;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;)\n    {\n        s &amp;#61; (BiTree)&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;BiNode(&lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//修改了一下这里****************************&lt;/span&gt;\n        s-&amp;gt;data &amp;#61; key;\n        s-&amp;gt;lchild &amp;#61; NULL;\n        s-&amp;gt;rchild &amp;#61; NULL;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!p)\n        {\n            *T &amp;#61; s;&lt;span class=\"hljs-comment\"&gt;//此处为插入根节点&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; p-&amp;gt;data)\n        {\n            p-&amp;gt;lchild &amp;#61; s;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            p-&amp;gt;rchild &amp;#61; s;\n        }\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;已存在相同数据&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//遍历&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//遍历迭代&lt;/span&gt;\nvoid depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(BiNode&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;root&lt;/span&gt;)&lt;/span&gt;\n{\n    stack&amp;lt;BiNode*&amp;gt;sta;\n    sta.push(root);\n    BiNode* p;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!sta.empty&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;)\n    {\n\n        p &amp;#61; sta.top&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p !&amp;#61; NULL)\n            cout &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; &lt;span class=\"hljs-character\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n        sta.pop&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;rchild !&amp;#61; NULL)\n            sta.push(p-&amp;gt;rchild);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;lchild !&amp;#61; NULL)&lt;span class=\"hljs-comment\"&gt;//这里等符号写错了&lt;/span&gt;\n            sta.push(p-&amp;gt;lchild);\n\n    }\n    cout &amp;lt;&amp;lt; endl;\n}\n\n\n\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main(void)\n{\n    &lt;span class=\"hljs-comment\"&gt;//int data[] &amp;#61; { 1,2,3,4,5,6,7,8,9,10 };&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//int len &amp;#61; sizeof(data) / sizeof(data[0]);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//int index &amp;#61; FibonacciSearch(data,len,5);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; index;&lt;/span&gt;\n    BiTree T &amp;#61; &lt;span class=\"hljs-constructor\"&gt;BiTree(0)&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 1)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 2)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 3)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 5)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 7)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 8)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 12)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 11)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 21)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 31)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 51)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 17)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 18)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 121)&lt;/span&gt;;\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(T, 3)&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;DelectBST(T, 12)&lt;/span&gt;;\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["二叉查找树的操作，删除节点的指针和内存释放问题", ["学习删除二叉排序树时遇到的问题，在删除结点时遇到问题，如下，注释的是我自己的想法，原本的内容是看小甲鱼的视频弄的，但感觉不太对，找了不少博客还是没解决问题", "\n", "运行结果及报错内容", "\n", "问题", "每种情况的free（p），都会报错，没搞明白。", "到底为啥？", "\n", "\nbool Delete(BiTree* t)", "//", "传输的是指针域的地址,直接修改lchild or rchild\n{\n    BiTree q, s;\n    ", "if", " ((*t)->lchild == NULL)", "//", "左子树为空，连接右子树\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        ", "//", "q = (*t)->rchild;", "//", "连接右子树，直接改变指针\n        ", "//", "(*t)->data = q->data;\n        ", "//", "(*t)->rchild = q->rchild;\n        free(q);", "//", "删除结点所占空间\n    }\n", "\n", "源程序如下：", "\n", "#", "include", "<iostream>\n#", "include", "<stack>\nusing namespace std;\n", "//顺序查找", "\n", "int", " ", "Sq_Sear(", "int", "*", " ", "a", ", ", "int", " ", "n", ", ", "int", " ", "key", ")", "\n{\n    ", "int", " i = n;\n    ", "for", " (i = ", "0", "; i <= n; i++)", "//cpu要做两次判断，可做优化", "\n    {\n        ", "if", " (a", "[", "i", "]", " == ", "key)\n        {\n            return i;\n        }\n    }\n    return ", "0", ";\n    ", "//改进,增加一个哨兵来减少循环次数，会污染数组", "\n\n    ", "//int i = n;", "\n    ", "//a[0] = key;", "\n    ", "//while (a[i] != key)", "\n    ", "//{", "\n    ", "//    i--;", "\n    ", "//}", "\n\n    ", "//return i;", "\n\n}\n\n\n", "//插值查找(按比例查找)", "\n", "int", " bia", "_search(", "int", " ", "str", "[], ", "int", " ", "n", ", ", "int", " ", "key", ")", "\n{\n    ", "int", " low = ", "0", ", high = n-", "1", ";\n    ", "int", " mid = ", "0", ";\n    ", "while", " (low <= high)\n    {\n        ", "//折半与按比例的优劣，数的值跨度不是很大按比例更好，", "\n        mid = low + (key - str", "[", "low", "]", ")", " / ", "(str", "[", "high", "]", " - str", "[", "low", "]", ")", " * ", "(high - low);\n            ", "if", " (str", "[", "mid", "]", " == ", "key)\n                return mid;\n            ", "if", " (str", "[", "mid", "]", " > key)\n                high = mid - ", "1", ";\n            ", "if", " (str", "[", "mid", "]", " < key)\n            low = mid + ", "1", ";\n    }\n    return -", "1", ";\n\n}\n", "//斐波那契查找", "\n", "//1.首先创建斐波那契数组", "\n", "//2。找到有序表最大元素", "\n", "//3.补齐有序表最大值到最接近斐波那契数组的一个元素", "\n", "//4.根据斐波那契的规则对比查找", "\n\n\nvoid produce", "Fib(", "int", "*", " ", "fib", ", ", "int", " ", "size", ")", "\n{\n    ", "int", " i;\n    fib", "[", "0", "]", " = ", "0", ";\n    fib", "[", "1", "]", " = ", "1", ";\n    ", "for", " (i = ", "2", "; i < size; i++)\n    {\n        fib", "[", "i", "]", " = fib", "[", "i", " - ", "1", "]", " + fib", "[", "i", " - ", "2", "]", ";\n    }\n}\n\n\n", "int", " ", "FibonacciSearch(", "int", "*", " ", "data", ", ", "int", " ", "length", ", ", "int", " ", "searchValue", ")", "\n{\n    ", "int", " low = ", "0", ", high = length - ", "1", ";\n    ", "int", " i = ", "0", ",mid = ", "0", ";\n    ", "int", " fib", "[", "10", "]", ";\n    produce", "Fib(", "fib", ", ", "length", ")", ";\n\n\n    ", "int", " k = ", "0", ";", "//最接近斐波那契的数", "\n\n    ", "while", " (high > fib", "[", "k", "]", " - ", "1", ")\n    {\n        k++;\n    }\n\n\n    ", "//补齐有序表", "\n    ", "int", "* temp;\n    temp = (", "int", "*)", "new", " ", "int", "[", "fib", "[", "k", "]", " - ", "1", "];\n    memcpy(temp, data, length", " * ", "sizeof(", "int", "));\n    ", "for", " (i = length; i < fib", "[", "k", "]", " - ", "1", "; i++)\n    {\n        data", "[", "i", "]", " = data", "[", "high", "]", ";\n    }\n\n    ", "while", " (low <= high)\n    {\n        ", "if", " (k > ", "0", ")\n            mid = low + fib", "[", "k", " - ", "1", "]", " - ", "1", ";\n        ", "else", "\n            mid = low;\n        ", "if", " (temp", "[", "mid", "]", " == ", "searchValue)\n        {\n            ", "if", " (mid <= length - ", "1", ")\n                return mid;\n            ", "else", "\n                return length - ", "1", ";\n        }\n\n\n\n\n        ", "if", " (temp", "[", "mid", "]", " > searchValue)\n        {\n            high = mid - ", "1", ";\n            k = k - ", "1", ";\n        }\n        ", "if", " (temp", "[", "mid", "]", " < searchValue)\n        {\n            low = mid + ", "1", ";\n            k = k - ", "2", ";\n        }\n    }\n\n    delete", "[]", " temp;\n    return -", "1", ";\n}\n\n\ntypedef ", "struct", " BiNode\n{\n    ", "int", " data;\n    ", "struct", " BiNode* lchild;\n    ", "struct", " BiNode* rchild;\n    ", "BiNode(", "int", " ", "x", ")", " :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n    \n}BiNode,*BiTree;\n\n", "//二叉查找树", "\n", "//T为搜索的树，f为记录父节点的指针，p作为临时指针保存输出", "\n", "bool", " ", "SearchBST(BiTree T, ", "int", " ", "key", ", BiTree ", "f", ", BiTree", "*", " ", "p", ")", "\n{\n    ", "if", " (!T)\n    {\n        *p = f;\n        return ", "false", ";\n    }\n    ", "else", " ", "if", "(key==T->data)\n    {\n        *p = T;\n        return ", "true", ";\n    }\n    ", "else", " ", "if", "(key < T->data)\n    {\n        return ", "SearchBST(T->", "lchild", ",", "key", ",T,", "p", ")", ";\n    }\n    ", "else", " ", "if", "(key > T->data)\n    {\n        return ", "SearchBST(T->", "rchild", ",", "key", ",T,", "p", ")", ";\n    }\n    ", "else", "\n    return ", "false", ";\n}\n", "bool", " ", "SearchBST(BiTree T, ", "int", " ", "key", ")", "\n{\n    BiTree f(", "0", ");\n    BiTree* p(", "0", ");\n     f = (BiTree)", "new", " BiTree; p = ", "new", " BiTree;\n    ", "if", " (!T)\n    {\n        *p = f;\n        return ", "false", ";\n    }\n    ", "else", " ", "if", " (key", " == ", "T->data)\n    {\n        *p = T;\n        return ", "true", ";\n    }\n    ", "else", " ", "if", " (key < T->data)\n    {\n        return ", "SearchBST(T->", "lchild", ", ", "key", ")", ";\n    }\n    ", "else", " ", "if", " (key > T->data)\n    {\n        return ", "SearchBST(T->", "rchild", ", ", "key", ")", ";\n    }\n    ", "else", "\n        return ", "false", ";\n}\n", "//删除", "\n", "//*p搜索位置结点", "\n", "//定义两个临时指针", "\n", "//三种情况", "\n\n", "bool", " ", "Delete(BiTree", "*", " ", "t", ")", "//传输的是指针域的地址,直接修改lchild or rchild", "\n{\n    BiTree q, s;\n    ", "if", " ((*t)->lchild", " == ", "NULL)", "//左子树为空，连接右子树", "\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        ", "//q = (*t)->rchild;//连接右子树，直接改变指针", "\n        ", "//(*t)->data = q->data;", "\n        ", "//(*t)->rchild = q->rchild;", "\n        free(q);", "//删除结点所占空间", "\n    }\n    ", "else", " ", "if", " ((*t)->rchild", " == ", "NULL)", "//右子树为空，连接左子树", "\n    {\n        q = *t;\n        (*t) = (*t)->lchild;", "//连接左子树，直接改变指针", "\n        ", "//free(q);//删除结点所占空间", "\n    }\n    ", "else", "//有两个孩子", "\n    {\n        q = (*t);", "//找到中序遍历时的前驱结点，即孩子结点的右子树最右边的叶子结点", "\n        s = (*t)->lchild;\n        ", "while", " (s->rchild != NULL)\n        {\n            q = s;", "//记录当前结点值", "\n            s = s->rchild;", "//找到右子树最右边的叶子结点", "\n        }\n        (*t)->data = s->data;\n        ", "if", " (q", " == ", "*t)", "//孩子结点为目标结点", "\n        {\n            q->lchild = s->lchild;", "//链接", "\n        }\n        ", "else", "//存在右子树", "\n        {\n            q->rchild = s->lchild;", "//目标结点的父亲结点链接孩子结点", "\n        }\n        \n        free(s);\n\n    }\n    \n    return ", "true", ";\n}\n\n", "//删除二叉排序树的结点", "\n", "//1.判断是否为空树", "\n", "//2.搜索判断是否存在", "\n", "//3.执行删除函数", "\n", "int", " ", "DelectBST(BiTree T, ", "int", " ", "key", ")", "\n{\n    ", "if", " (T", " == ", "NULL)\n    {\n        return ", "false", ";\n\n    }\n\n\n    ", "else", " ", "if", " (key", " == ", "T->data)\n        {\n            return ", "Delete(&T)", ";\n        }\n    ", "else", " ", "if", "(key < T->data)\n        {\n            return ", "DelectBST(T->", "lchild", ", ", "key", ")", ";\n        }\n    ", "else", " \n        {\n            return ", "DelectBST(T->", "rchild", ",", "key", ")", ";\n        }\n    \n}\n\n\n", "//插入", "\n", "int", " ", "InsertBST(BiTree", "*", " T, ", "int", " ", "key", ")", "\n{\n    BiTree p ,s;\n\n\n    ", "//传入临时结点指针p，通过搜索函数返回当前最接近该插入值的一个节点位置", "\n    ", "if", " (!", "SearchBST(", "*", "T, ", "key", ", NULL, &", "p", ")", ")\n    {\n        s = (BiTree)", "new", " BiTree;\n        s->data = key;\n        s->lchild = NULL;\n        s->rchild = NULL;\n        ", "if", " (!p)\n        {\n            *T = s;", "//此处为插入根节点", "\n        }\n        ", "else", " ", "if", " (key < p->data)\n        {\n            p->lchild = s;\n        }\n        ", "else", "\n        {\n            p->rchild = s;\n        }\n        return ", "true", ";\n\n    }\n    ", "else", " {\n        cout << ", "\"已存在相同数据！\"", " << endl;\n        \n\n        return ", "false", ";\n    }\n}\n\n\n", "//遍历", "\n", "//遍历迭代", "\nvoid depth", "FirstSearch(BiNode", "*", " ", "root", ")", "\n{\n    stack<BiNode*>sta;\n    sta.push(root);\n    BiNode* p;\n    ", "while", " (!sta.empty", "()", ")\n    {\n        \n        p = sta.top", "()", ";\n        ", "if", " (p != NULL)\n        cout << p->data<<", "' '", ";\n        sta.pop", "()", ";\n        ", "if", " (p->rchild != NULL)\n            sta.push(p->rchild);\n        ", "if", " (p->lchild= NULL)\n            sta.push(p->lchild);\n\n    }\n    cout << endl;\n}\n\n\n\n\n", "int", " main(void)\n{\n    ", "//int data[] = { 1,2,3,4,5,6,7,8,9,10 };", "\n    ", "//int len = sizeof(data) / sizeof(data[0]);", "\n    ", "//int index = FibonacciSearch(data,len,5);", "\n    ", "//cout << index;", "\n    BiTree T = ", "BiTree(0)", ";\n    \n    \n    ", "InsertBST(&T, 1)", ";\n    ", "InsertBST(&T, 2)", ";\n    ", "InsertBST(&T, 3)", "; \n    ", "InsertBST(&T, 5)", ";\n    ", "InsertBST(&T, 7)", ";\n    ", "InsertBST(&T, 8)", "; \n    ", "InsertBST(&T, 12)", ";\n    ", "InsertBST(&T, 11)", ";\n    ", "InsertBST(&T, 21)", ";\n    ", "InsertBST(&T, 31)", ";\n    ", "InsertBST(&T, 51)", ";\n    ", "InsertBST(&T, 17)", ";\n    ", "InsertBST(&T, 18)", ";\n    ", "InsertBST(&T, 121)", ";\n    depth", "FirstSearch(T)", ";\n    \n    cout << ", "SearchBST(T, 3)", " << endl;\n\n    depth", "FirstSearch(T)", ";\n    ", "DelectBST(T,12)", ";\n    depth", "FirstSearch(T)", ";\n    return ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇文章讲的很详细&amp;#xff0c;请看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/getinobacar/article/details/122707664?utm_source&amp;#61;csdn_ai_ada_ask_robot\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;力扣 76题 最小覆盖子串&amp;#xff08;双指针 &amp;#43; 滑动窗口&amp;#xff09;&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["力扣错误提示解惑，76题最小覆盖子串", ["问题遇到的现象和发生背景", "\n", "力扣76.最小覆盖子串，请用通俗的语言概括一下下边这段错误提示的意思。", "同时，贴上我的代码", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "报错内容：", "Line 137: Char 23: runtime error: constructor call on misaligned address 0xbebebebebebec0ba for type 'int', which requires 4 byte alignment (new_allocator.h)", ": note: pointer points here", "SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:146:23", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "class", " Solution {\npublic:\n    static ", "bool", " comp", "SL(", "deque", "<", "int", ">& ", "a", ",", "deque", "<", "int", ">& ", "b", ")", "\n    {\n        ", "if", "(a.empty", "()", ") return ", "0", ";\n        ", "if", "(b.empty", "()", ") return ", "1", ";\n        return a.front", "()", "<b.front", "()", ";\n    }\n    static ", "bool", " comp", "SR(", "deque", "<", "int", ">& ", "c", ",", "deque", "<", "int", ">& ", "d", ")", "\n    {\n        ", "if", "(c.empty", "()", ") return ", "0", ";\n        ", "if", "(d.empty", "()", ") return ", "1", ";\n        return c.back", "()", ">d.back", "()", ";\n    }\n    void ", "DFS(", "int", " ", "k", ",", "string", " ", "t", ",", "vector", "<", "int", "> ", "sUCnt", ",", "vector", "<", "int", "> ", "sLCnt", ",", "vector", "<", "deque", "<", "int", ">> ", "sU", ",", "vector", "<", "deque", "<", "int", ">> ", "sL", ")", "\n    {\n        ", "if", "(k==n)\n        {\n            sort(tU.", "begin", "()", ",tU.", "end", "()", ",compSL);ul=tU", "[", "0", "]", ".empty", "()", "? INT_MAX:tU", "[", "0", "]", ".front", "()", ";\n            sort(tU.", "begin", "()", ",tU.", "end", "()", ",compSR);ur=tU", "[", "0", "]", ".empty", "()", "? INT_MIN:tU", "[", "0", "]", ".back", "()", ";\n            sort(tL.", "begin", "()", ",tL.", "end", "()", ",compSL);ll=tL", "[", "0", "]", ".empty", "()", "? INT_MAX:tL", "[", "0", "]", ".front", "()", ";\n            sort(tL.", "begin", "()", ",tL.", "end", "()", ",compSR);lr=tL", "[", "0", "]", ".empty", "()", "? INT_MIN:tL", "[", "0", "]", ".back", "()", ";\n            mx=max(ur,lr);mn=min(ul,ll);\n            tmp=mx-mn;\n            ", "if", "(tmp+", "1", "<=len)\n            {\n                beg=mn;\n                len=tmp+", "1", ";\n            }\n            return;\n        }\n        ", "int", " j=t", "[", "k", "]", "-", "'A'", ",e;\n        ", "if", "(j<", "26", ")\n        {\n            tUCnt", "[", "j", "]", "--;\n            ", "while", "(!sU", "[", "j", "]", ".empty", "()", ")\n            {\n                sUCnt", "[", "j", "]", "--;\n                ", "if", "(tUCnt", "[", "j", "]", ">sUCnt", "[", "j", "]", ") break;\n                e=sU", "[", "j", "]", ".front", "()", ";\n                tU", "[", "j", "]", ".push", "_back(", "e", ")", ";\n                sU", "[", "j", "]", ".pop", "_front()", ";\n                ", "DFS(", "k", "+1,", "t", ",", "sUCnt", ",", "sLCnt", ",", "sU", ",", "sL", ")", ";\n                tU", "[", "j", "]", ".pop", "_back()", ";\n            }\n            tUCnt", "[", "j", "]", "++;\n        }\n        ", "else", "\n        {\n            j=t", "[", "k", "]", "-", "'a'", ";\n            tLCnt", "[", "j", "]", "--;\n            ", "while", "(!sL", "[", "j", "]", ".empty", "()", ")\n            {\n                sLCnt", "[", "j", "]", "--;\n                ", "if", "(tLCnt", "[", "j", "]", ">sLCnt", "[", "j", "]", ") break;\n                e=sL", "[", "j", "]", ".front", "()", ";\n                tL", "[", "j", "]", ".push", "_back(", "e", ")", ";\n                sL", "[", "j", "]", ".pop", "_front()", ";\n                ", "DFS(", "k", "+1,", "t", ",", "sUCnt", ",", "sLCnt", ",", "sU", ",", "sL", ")", ";\n                tL", "[", "j", "]", ".pop", "_back()", ";\n            }\n            tLCnt", "[", "j", "]", "++;\n        }\n    }\n    ", "string", " min", "Window(", "string", " ", "s", ", ", "string", " ", "t", ")", "\n    {\n        m=s.size", "()", ";\n        n=t.size", "()", ";\n        len=m;\n        vector<", "int", "> s", "UCnt(26)", ",sLCnt;\n        vector<deque<", "int", ">> s", "U(26)", ",sL;\n        tLCnt=sLCnt=tUCnt=sUCnt;\n        tL=sL=tU=sU;\n        ", "for", "(", "int", " i=", "0", ",j;i<m;i++)\n        {\n            j=s", "[", "i", "]", "-", "'A'", ";\n            ", "if", "(j<", "26", ")\n            {\n                sUCnt", "[", "j", "]", "++;\n                sU", "[", "j", "]", ".push", "_back(", "i", ")", ";\n            }\n            ", "else", "\n            {\n                j=s", "[", "i", "]", "-", "'a'", ";\n                sLCnt", "[", "j", "]", "++;\n                sL", "[", "j", "]", ".push", "_back(", "i", ")", ";\n            }\n        }\n        ", "for", "(", "int", " i=", "0", ",j;i<n;i++)\n        {\n            j=t", "[", "i", "]", "-", "'A'", ";\n            ", "if", "(j<", "26", ")\n            {\n                ", "if", "(tUCnt", "[", "j", "]", "==sUCnt", "[", "j", "]", ") return {};\n                tUCnt", "[", "j", "]", "++;\n            }\n            ", "else", "\n            {\n                j=t", "[", "i", "]", "-", "'a'", ";\n                ", "if", "(tLCnt", "[", "j", "]", "==sLCnt", "[", "j", "]", ") return {};\n                tLCnt", "[", "j", "]", "++;\n            }\n        }\n        ", "DFS(0,", "t", ",", "sUCnt", ",", "sLCnt", ",", "sU", ",", "sL", ")", ";\n        return s.substr(beg,len);\n    }\n", "private", ":\n    ", "int", " m,n,tmp,beg,len,ul,ur,ll,lr,mx,mn;\n    vector<", "int", "> tUCnt,tLCnt;\n    vector<deque<", "int", ">> tU,tL;\n};\n\n", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我的代码怎么改是次要的，最主要想请教错误提示想要表达什么？", "如果可能，我还是希望能用回溯法解题", "我先分别对字符串s、t包含的字母统计数量。然后定义4个队列数组，其中两个用于存储s中各字母在s中的位置序号，另外两个用于存储t中各字母在字符串s中可能的位置序号。假如t中某一个字母的剩余数大于s中的剩余数，则终止当前操作，回退数据状态，不再进入更深的一层搜索。只要sU、sL当前字母的队列里还存有序号，则while循环不会停止。当k==n时，说明t中每个字母都匹配到了一个序号，通过自定义sort函数对匹配得到的所有序号进行排序，然后使其中最大值和最小值相减，取得包含t中所有字母的字符串长度，最后通过回溯的方式，找到满足题意长度最小的字符串。", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下&amp;#xff1a;&lt;br /&gt;这是一个典型的搜索问题&amp;#xff0c;可以使用深度优先搜索&amp;#xff08;DFS&amp;#xff09;或广度优先搜索&amp;#xff08;BFS&amp;#xff09;算法来解决。以下是一个使用DFS算法的解决方案&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;n &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;())\nmaze &amp;#61; [&lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;()) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; _ &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(n)]\nvisited &amp;#61; [[&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;] * n &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; _ &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(n)]\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;x, y&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; x &amp;#61;&amp;#61; n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; y &amp;#61;&amp;#61; n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    visited[x][y] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n    res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; dx, dy &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; [(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]:  &lt;span class=\"hljs-comment\"&gt;# 向四个方向移动&lt;/span&gt;\n        nx, ny &amp;#61; x&amp;#43;dx, y&amp;#43;dy\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; nx &amp;lt; n &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; ny &amp;lt; n &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; visited[nx][ny] &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; maze[nx][ny] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;O&amp;#39;&lt;/span&gt;:\n            res &amp;#43;&amp;#61; dfs(nx, ny)\n    visited[x][y] &amp;#61; &lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;# 回溯&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(res, &lt;span class=\"hljs-number\"&gt;50000&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 超过50000时返回50000&lt;/span&gt;\n\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(dfs(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;首先读入迷宫和迷宫大小。然后定义一个visited数组来记录每个瓷砖是否已经走过&amp;#xff0c;初始化为False。接下来定义一个dfs函数&amp;#xff0c;用于搜索从当前位置出发到达终点的方案数。如果当前位置已经是终点&amp;#xff0c;则返回1。否则&amp;#xff0c;依次向四个方向移动&amp;#xff0c;如果某个方向可以移动且未访问过且不是墙壁&amp;#xff0c;则继续搜索从该位置出发到达终点的方案数。最后回溯并返回总方案数。注意&amp;#xff0c;为了避免结果太大&amp;#xff0c;当方案数超过50000时&amp;#xff0c;返回50000。&lt;/p&gt;\n&lt;p&gt;最后调用dfs函数并输出结果即可。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;如果以上回答对您有所帮助&amp;#xff0c;点击一下采纳该答案&amp;#xff5e;谢谢&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["迷宫路径方案数，初学者正在写但怕弄不出来，来问问大家", ["有一个正方形的迷宫，上面铺着正方形的瓷砖，标记为’O’的瓷砖可以在上面移动，但是标记为‘X’不可以在上面移动。一个男人从左上角移动到右下角。请写一个程序来计算他有多少种方案可以完成这个移动，要求是走过的瓷砖不能重复走，同时标记为’X’的瓷砖也不能走。", "\n", "输入格式：", "\n", "第一行一个整数N,表示迷宫由N*N的瓷砖铺成，N<20", "\n", "接下来N行，每行N个字符，‘O’或‘X’", "\n", "输出格式：", "\n", "一个整数，表示移动方案数，如果大于50000则输出50000", "\n", "我自己写的在VS上过了，但学习通提交超时", "，然后写的深度优先搜索不对，求怎么解决呀，我已经快放弃了，能不能来个佬帮帮忙", "\n"]], "Tag": "算法设计"}
{"Answer": "你画个邻接表懂了，首先对于无向图，n个顶点表＋e个边表，每个都访问一次，就是n+e了，而对于有向图，用的是邻接表表示正向，逆邻接表来表示反响，不是用邻接表来表示正反两个方向的，理解错误，根据题意，问的是邻接表，所以也是n+e", "Konwledge_Point": "图的深度优先搜索", "Question": ["数据结构图的深度优先搜索", ["用邻接表存储的无向图，进行深度优先搜索，时间复杂度为什么不是O(n+2e)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;广搜一般求最短路&amp;#xff0c;算法时间复杂度比较固定&lt;br /&gt;深搜是穷举所有情况&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["广度优先搜索和深度优先搜索的区别", ["广度优先搜索和深度优先搜索的区别在哪里啊？分不清楚什么时候用广度什么时候用宽度"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;EdgeNode&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//边结点&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; adjvex;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;EdgeNode&lt;/span&gt; *next;\n}edge;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;vertexnode&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//临界点&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; data;\n    edge* firstedge;\n}vertexnode,Adjlist[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LGraph&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//图&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; edgenum,nodenum;\n    Adjlist adjlist;\n}LGraph;\n&lt;span class=\"hljs-function\"&gt;LGraph* &lt;span class=\"hljs-title\"&gt;creategraph&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( )&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//创建图&lt;/span&gt;\n&lt;/span&gt;{\n    LGraph*G&amp;#61;(LGraph*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LGraph));\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,&amp;amp;(G-&amp;gt;nodenum),&amp;amp;(G-&amp;gt;edgenum));\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;(G-&amp;gt;nodenum);i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//填充顶点表&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; temp;\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;temp);\n        G-&amp;gt;adjlist[i].data&amp;#61;temp;\n        G-&amp;gt;adjlist[i].firstedge&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//勿漏&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;&amp;#61;(G-&amp;gt;edgenum);j&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//填充边表&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; temp1,temp2;\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,&amp;amp;temp1,&amp;amp;temp2);&lt;span class=\"hljs-comment\"&gt;//读入有向边的”入“&amp;#xff0c;”出“&lt;/span&gt;\n        edge*e&amp;#61;(edge*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(edge));\n        &lt;span class=\"hljs-comment\"&gt;// 有向边的”入“&amp;#xff0c;”出“弄反正了&lt;/span&gt;\n        e-&amp;gt;adjvex&amp;#61;temp2;     &lt;span class=\"hljs-comment\"&gt;//temp1改成temp2&lt;/span&gt;\n        e-&amp;gt;next&amp;#61;G-&amp;gt;adjlist[temp1].firstedge;&lt;span class=\"hljs-comment\"&gt;//头插法  temp2改成temp1&lt;/span&gt;\n        G-&amp;gt;adjlist[temp1].firstedge&amp;#61;e;             &lt;span class=\"hljs-comment\"&gt;//temp2改成temp1&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; G;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; FLAG&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//判断是否能通过v2的标志&amp;#xff0c;全局变量&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DFS&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LGraph*G,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; adjvex,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v2)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//深度搜索&lt;/span&gt;\n&lt;/span&gt;{\n    edge*p;\n    visited[adjvex]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//标记已经访问过&lt;/span&gt;\n    p&amp;#61;G-&amp;gt;adjlist[adjvex].firstedge;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(visited[v2]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) FLAG&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(visited[p-&amp;gt;adjvex]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)      &lt;span class=\"hljs-comment\"&gt;//adjvex 改成 p-&amp;gt;adjvex&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;DFS&lt;/span&gt;(G,p-&amp;gt;adjvex,v2);\n        p&amp;#61;p-&amp;gt;next;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DFSTraverse&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LGraph *G,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v1,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v2)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;(G-&amp;gt;nodenum);i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//首先都初始化为未访问过的状态&lt;/span&gt;\n    {\n        visited[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n        &lt;span class=\"hljs-built_in\"&gt;DFS&lt;/span&gt;(G,v1,v2);&lt;span class=\"hljs-comment\"&gt;//从v1点开始深度搜索&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; FLAG;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    LGraph*G;\n    G&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creategraph&lt;/span&gt;();\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v1,v2,flag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;,&amp;amp;v1,&amp;amp;v2);&lt;span class=\"hljs-comment\"&gt;//要寻找的路径的两端下标&lt;/span&gt;\n    flag&amp;#61;&lt;span class=\"hljs-built_in\"&gt;DFSTraverse&lt;/span&gt;(G,v1,v2);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;yes&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;no&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["有向图的深度优先搜索", ["样例输出应该是yes,但是输出no", "样例如下：", "4 4（结点数，边数）", "1 2 3 4（顶点下标）", "1 2（边信息）", "1 3", "1 4", "2 3", "2 3（要搜索是否存在的边信息）", "以下是代码", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "int", " visited[", "105", "];\n", "typedef", " ", "struct", " ", "EdgeNode", "//边结点", "\n{\n    ", "int", " adjvex;\n    ", "struct", " ", "EdgeNode", " *next;\n}edge;\n", "typedef", " ", "struct", " ", "vertexnode", "//临界点", "\n{\n    ", "int", " data;\n    edge* firstedge;\n}vertexnode,Adjlist[", "105", "];\n", "typedef", " ", "struct", " ", "LGraph", "//图", "\n{\n    ", "int", " edgenum,nodenum;\n    Adjlist adjlist;\n}LGraph;\n", "LGraph* ", "creategraph", "( )", "//创建图", "\n", "{\n    LGraph*G=(LGraph*)", "malloc", "(", "sizeof", "(LGraph));\n    ", "scanf", "(", "\"%d %d\\n\"", ",&(G->nodenum),&(G->edgenum));\n    ", "int", " i,j;\n    ", "for", "(i=", "1", ";i<=(G->nodenum);i++)", "//填充顶点表", "\n    {\n        ", "int", " temp;\n        ", "scanf", "(", "\"%d\"", ",&temp);\n        G->adjlist[i].data=temp;\n        G->adjlist[i].firstedge=", "NULL", ";", "//勿漏", "\n    }\n    ", "for", "(j=", "1", ";j<=(G->edgenum);j++)", "//填充边表", "\n    {\n        ", "int", " temp1,temp2;\n        ", "scanf", "(", "\"%d %d\\n\"", ",&temp1,&temp2);", "//读入有向边的”入“，”出“", "\n        edge*e=(edge*)", "malloc", "(", "sizeof", "(edge));\n        e->adjvex=temp1;\n        e->next=G->adjlist[temp2].firstedge;", "//头插法", "\n        G->adjlist[temp2].firstedge=e;\n    }\n    ", "return", " G;\n}\n", "int", " FLAG=", "0", ";", "//判断是否能通过v2的标志，全局变量", "\n", "void", " ", "DFS", "(LGraph*G,", "int", " adjvex,", "int", " v2)", "//深度搜索", "\n", "{\n    edge*p;\n     visited[adjvex]=", "1", ";", "//标记已经访问过", "\n    p=G->adjlist[adjvex].firstedge;\n    ", "if", "(visited[v2]==", "1", ") FLAG=", "1", ";\n    ", "while", "(p)\n    {\n        ", "if", "(visited[adjvex]==", "0", ")\n        ", "DFS", "(G,p->adjvex,v2);\n        p=p->next;\n    }\n}\n", "int", " ", "DFSTraverse", "(LGraph *G,", "int", " v1,", "int", " v2)", "\n", "{\n    ", "int", " i;\n    ", "for", "(i=", "1", ";i<=(G->nodenum);i++)", "//首先都初始化为未访问过的状态", "\n    {\n        visited[i]=", "0", ";\n    }\n        ", "DFS", "(G,v1,v2);", "//从v1点开始深度搜索", "\n    ", "return", " FLAG;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    LGraph*G;\n    G=", "creategraph", "();\n    ", "int", " v1,v2,flag=", "0", ";\n    ", "scanf", "(", "\"%d %d\"", ",&v1,&v2);", "//要寻找的路径的两端下标", "\n    flag=", "DFSTraverse", "(G,v1,v2);\n    ", "if", "(flag==", "1", ")\n        ", "printf", "(", "\"yes\"", ");\n    ", "else", "\n        ", "printf", "(", "\"no\"", ");\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1.下面是深度优先搜索的程序&amp;#xff0c;用于将图中所有结点的值变为0&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;// 将当前结点的值变为0&lt;/span&gt;\n    G[u][u] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;// 遍历所有与当前结点相连的结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; v &amp;lt; n; v&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;// 如果v是u的相邻结点&amp;#xff0c;则递归调用dfs&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[u][v] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(v, G, n);\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 在主函数中调用dfs&amp;#xff0c;遍历图中所有结点&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setAllValuesToZero&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(u, G, n);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2.下面是广度优先搜索的程序&amp;#xff0c;用于打印图中所有结点的值&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;bfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;// 创建一个队列来保存当前遍历到的结点&lt;/span&gt;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; q;\n    &lt;span class=\"hljs-comment\"&gt;// 将当前结点加入队列&lt;/span&gt;\n    q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(u);\n    &lt;span class=\"hljs-comment\"&gt;// 循环遍历队列中的结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!q.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;())\n    {\n        &lt;span class=\"hljs-comment\"&gt;// 从队列中取出第一个结点&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u &amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;();\n        q.&lt;span class=\"hljs-built_in\"&gt;pop&lt;/span&gt;();\n        &lt;span class=\"hljs-comment\"&gt;// 打印当前结点的值&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, G[u][u]);\n        &lt;span class=\"hljs-comment\"&gt;// 遍历所有与当前结点相连的结点&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; v &amp;lt; n; v&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-comment\"&gt;// 如果v是u的相邻结点&amp;#xff0c;则将其加入队列&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[u][v] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(v);\n            }\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 在主函数中调用bfs&amp;#xff0c;遍历图中所有结点&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printAllValues&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; G[][MAXN], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;bfs&lt;/span&gt;(u, G, n);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3.下面是使用邻接表存储图的程序&amp;#xff0c;用于求解每个顶点的入度&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdio.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdlib.h&amp;gt;\n\n#define MAXN &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// 定义链表结点&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; ListNode\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 结点的值&lt;/span&gt;\n    ListNode* next; &lt;span class=\"hljs-comment\"&gt;// 指向下一个结点的指针&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; AdjacencyList\n{\n    ListNode* head; &lt;span class=\"hljs-comment\"&gt;// 指向第一个结点的指针&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; size; &lt;span class=\"hljs-comment\"&gt;// 链表的长度&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-comment\"&gt;// 创建一个新的链表结点&lt;/span&gt;\nListNode* create&lt;span class=\"hljs-constructor\"&gt;ListNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;val&lt;/span&gt;)&lt;/span&gt;\n{\n    ListNode* node &amp;#61; (ListNode*)malloc(sizeof(ListNode));\n    node-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt;;\n    node-&amp;gt;next &amp;#61; NULL;\n    return node;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 初始化邻接表&lt;/span&gt;\nvoid init&lt;span class=\"hljs-constructor\"&gt;AdjacencyList(AdjacencyList&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;list&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;head &amp;#61; NULL;\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;size &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 向邻接表中加入新的结点&lt;/span&gt;\nvoid add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(AdjacencyList&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;list&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;val&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;// 创建新的结点&lt;/span&gt;\n    ListNode* node &amp;#61; create&lt;span class=\"hljs-constructor\"&gt;ListNode(&lt;span class=\"hljs-params\"&gt;val&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;// 将新结点插入到链表的头部&lt;/span&gt;\n    node-&amp;gt;next &amp;#61; &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;head;\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;head &amp;#61; node;\n    &lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;-&amp;gt;size&amp;#43;&amp;#43;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 求解每个顶点的入度&lt;/span&gt;\nvoid &lt;span class=\"hljs-constructor\"&gt;FindInDegree(AdjacencyList&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; G, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;indegree&lt;/span&gt;[], &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;// 初始化所有结点的入度为0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        indegree&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 遍历所有结点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; n; u&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;// 遍历当前结点的所有相邻结点&lt;/span&gt;\n        ListNode* curr &amp;#61; G&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt;.head;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (curr !&amp;#61; NULL)\n        {\n              &lt;span class=\"hljs-comment\"&gt;// 将当前结点的相邻结点的入度加1&lt;/span&gt;\n              indegree&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;curr&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;val&lt;/span&gt;]&lt;/span&gt;&amp;#43;&amp;#43;;\n              curr &amp;#61; curr-&amp;gt;next;\n        }\n    }\n}\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n        &lt;span class=\"hljs-comment\"&gt;// 创建邻接表&lt;/span&gt;\n        AdjacencyList G&lt;span class=\"hljs-literal\"&gt;[MAXN]&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; MAXN; i&amp;#43;&amp;#43;)\n        {\n              init&lt;span class=\"hljs-constructor\"&gt;AdjacencyList(&amp;amp;G[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;])&lt;/span&gt;;\n          }\n         &lt;span class=\"hljs-comment\"&gt;// 加入边&lt;/span&gt;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[0], 1)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[0], 2)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[1], 2)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[2], 0)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[2], 3)&lt;/span&gt;;\n         add&lt;span class=\"hljs-constructor\"&gt;ToAdjacencyList(&amp;amp;G[3], 3)&lt;/span&gt;;\n         &lt;span class=\"hljs-comment\"&gt;// 求解每个结点的入度&lt;/span&gt;\n         &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; indegree&lt;span class=\"hljs-literal\"&gt;[MAXN]&lt;/span&gt;;\n         &lt;span class=\"hljs-constructor\"&gt;FindInDegree(G, &lt;span class=\"hljs-params\"&gt;indegree&lt;/span&gt;, MAXN)&lt;/span&gt;;\n\n         &lt;span class=\"hljs-comment\"&gt;// 打印每个结点的入度&lt;/span&gt;\n         &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; u &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; u &amp;lt; MAXN; u&amp;#43;&amp;#43;)\n         {\n             printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d: %d\\n&amp;#34;&lt;/span&gt;, u, indegree&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt;);\n         }\n\n         return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这段程序中&amp;#xff0c;我们使用了链表来存储邻接表&amp;#xff0c;并在&lt;code class=\"language-javascript\"&gt;FindInDegree&lt;/code&gt;函数中遍历所有结点的所有相邻结点&amp;#xff0c;将这些结点的入度加1。最后&amp;#xff0c;我们在主函数中调用了&lt;code class=\"language-javascript\"&gt;FindInDegree&lt;/code&gt;函数&amp;#xff0c;并打印了每个结点的入度。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["写出完整的编程代码！！（C语言）", ["1.已知一个连通图G采用数组存储法，其结点值为数值型，采用深度优先搜索方法，编程序将所有结点的值变为0。", "\n", "2.已知一个连通图G采用数组存储法，其结点值为数值型，采用广度优先搜索方法，编程序将所有结点的值打印出来。", "\n", "3.假设图G采用邻接表存储方式，，编程序求解每个一个顶点的入度: FindInDegree(G, indegree);"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考 &lt;a href=\"https://blog.csdn.net/wd1603926823/article/details/128782281\" id=\"textarea_1679954981190_1679955787658_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/wd1603926823/article/details/128782281&lt;/span&gt;&lt;/a&gt; 可知&amp;#xff1a;&lt;br /&gt;对于答案A&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;    1入&amp;#xff1b;\n1出&amp;#xff0c;3入&amp;#xff1b;\n3出&amp;#xff0c;5入&amp;#xff1b;\n5出&amp;#xff0c;4入&amp;#xff1b;\n4出&amp;#xff0c;2入&amp;#xff1b;\n2出&amp;#xff0c;6入&amp;#xff1b;\n6出&amp;#xff0c;7入&amp;#xff1b;\n7出。    顶点已出完&amp;#xff0c;结束搜索。\n所以顺序是&amp;#xff1a;1&lt;span class=\"hljs-number\"&gt; 3 &lt;/span&gt;5&lt;span class=\"hljs-number\"&gt; 4 &lt;/span&gt;2&lt;span class=\"hljs-number\"&gt; 6 &lt;/span&gt;7\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对于答案B&amp;#xff1a;顶点3 后还有接班人5 &amp;#xff0c;而它直接跳到了4&amp;#xff0c;所以错误。&lt;br /&gt;对于答案C&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;    1入&amp;#xff1b;\n1出&amp;#xff0c;5入&amp;#xff1b;\n5出&amp;#xff0c;3入&amp;#xff1b;\n3出&amp;#xff0c;    &amp;#xff08;3已没有接班人&amp;#xff0c;故此根枝条已捋到底&amp;#xff09;\n        &amp;#xff08;需返回上级5&amp;#xff0c;发现有新分叉枝条4、6均未入队过&amp;#xff0c;所以我们先入4&amp;#xff09;\n     4入&amp;#xff1b;\n4出&amp;#xff0c;2入&amp;#xff1b;\n2出&amp;#xff0c;7入&amp;#xff1b;\n7出&amp;#xff0c;6入&amp;#xff1b;\n6出。     顶点已出完&amp;#xff0c;结束搜索。\n所以顺序是&amp;#xff1a;1&lt;span class=\"hljs-number\"&gt; 5 &lt;/span&gt;3&lt;span class=\"hljs-number\"&gt; 4 &lt;/span&gt;2&lt;span class=\"hljs-number\"&gt; 7 &lt;/span&gt;6\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对于答案D&amp;#xff1a;顶点4还有接班人即未捋到底&amp;#xff0c;而它直接跳到了7 &amp;#xff0c;所以错误。&lt;br /&gt;故答案是AC&amp;#xff0c;我觉得你的标准答案A不正确。只能说A是树不分叉的深度优先搜索选择&amp;#xff0c;因为C虽然也正确但树有一个分叉。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（", ["如图所示，给出由7个顶点组成的无向图。从顶点1出发，对它进行深度优先搜索得到的顶点序列是（a　　）。", "A．1 3 5 4 2 6 7                            B．1 3 4 7 6 2 5", "C．1 5 3 4 2 7 6                            D．1 2 4 7 6 5 3", "\n", "这个深度优先搜索遍历，C选项不也可以吗"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考&lt;br /&gt;&lt;a id=\"textarea_1655219157331_1655219218414_0\" target=\"_blank\"&gt;&lt;span class=\"md_link_url\"&gt;http://t.zoukankan.com/yuxiaoba-p-8335758.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["C语言，无向图的深度优先遍历和广度优先遍历", ["给定一个有N个顶点和E条边的无向图，请用深度优先遍历（DFS）和广度优先遍历（BFS）分别列出其所有的连通集。假设顶点从0到N-1编号。进行搜索时，假设总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。", "\n", "输入：输入第1行给出2个整数N(0<N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用一个空格分隔。", "输出：按照“{v1v2…vk}”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;额。。。注释得挺好&lt;br /&gt;把输出结果里的坐标数字替换成星号就好了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;i&lt;/span&gt;, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; res:\n    puzzle&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[j]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;*&amp;#34;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果要保存进txt&amp;#xff0c;还要把之前的迷宫数字都换成字符串&amp;#xff0c;当然&amp;#xff0c;如果你是从txt读取的迷宫矩阵&amp;#xff0c;就没这个问题了。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["python走迷宫深度优先搜索", ["有哦人知道这个程序要怎么改成打印出来的迷宫路径使用星号表示的吗，就是矩阵里面能显示路径", "\n", "\n```python\n", "from", " numpy import *\ndef findpath(puzzle, ", "start", ", ", "end", "):\n    ", "# 四个方向", "\n    d = [(", "-1", ",", "0", "),(", "0", ",", "1", "),(", "1", ",", "0", "),(", "0", ",", "-1", ")]\n    vis = [[", "-1", " ", "for", " _ ", "in", " range(", "len", "(puzzle[", "0", "]))] ", "for", " _ ", "in", " range(", "len", "(puzzle))]\n    ", "#迷宫矩阵,0表示路， 1表示墙 ", "\n    vis[", "start", "[", "0", "]][", "start", "[", "1", "]]=", "start", "\n    dfs = [", "start", "]     \n    ", "while", " dfs:\n        x,y = dfs.pop()    ", "#取栈顶及其探查方向", "\n        ", "for", " i ", "in", " range(", "4", "): ", "#依次检查未探查方向", "\n            m = x+d[i][", "0", "]\n            n = y+d[i][", "1", "]  ", "#算出下一位", "\n            puzzle[", "start", "[", "0", "]][", "start", "[", "1", "]] = ", "6", " ", "#把走过的记录为6", "\n            ", "if", " ", "0", "<=m<", "len", "(puzzle) ", "and", " ", "0", "<=n<", "len", "(puzzle[", "0", "]) ", "and", " puzzle[m][n]==", "0", " ", "and", " vis[m][n]==", "-1", ":   ", "#遇到未探查的新位置 ", "\n                dfs.append((x,y))    ", "#原位置和下一方向入栈", "\n                dfs.append((m,n))\n                vis[m][n]=(x,y)      ", "#新位置入栈", "\n                puzzle[", "start", "[", "0", "]][", "start", "[", "1", "]] = ", "6", " ", "#把走过的记录为6", "\n                ", "if", " ", "end", "==(m,n): ", "#到达出口，打印路径", "\n                    ", "return", " dfs\n                break   ", "#退出内层循环，下次迭代将以新栈顶为当前位置继续", "\n    ", "return", " dfs  ", "#找不到路径", "\n    \npuzzle = zeros((", "10", ", ", "10", "), dtype=float) ", "# 先创建一个全零方阵puzzle;，并且数据的类型设置为float浮点型", "\nf = ", "open", "(", "'test2.txt'", ") ", "# 打开数据文件文件", "\n", "lines", " = f.readlines() ", "# 把全部数据文件读到一个列表lines中", "\npuzzle_row = ", "0", "  ", "# 表示矩阵的行，从0行开始", "\n", "for", " ", "line", " ", "in", " ", "lines", ": ", "# 把lines中的数据逐行读取出", "\n         list = ", "line", ".strip(", "'\\n'", ").", "split", "(", "' '", ") ", "# 处理逐行数据：strip表示把头尾的'\\n'去掉，split表示以空格来分割行数据，然后把处理后的行数据返回到list列表中", "\n         puzzle[puzzle_row:] = list[", "0", ":", "10", "] ", "# 把处理后的数据放到方阵A中。list[0:4]表示列表的0,1,2,3列数据放到矩阵A中的A_row行", "\n         puzzle_row += ", "1", " ", "# 然后方阵A的下一行接着读", "\nprint(puzzle)        \n", "start", " = eval(input(", "\"请输入起始坐标(x,y)：\"", "))\n", "end", " = ", "eval", "(", "input", "(\"请输入终点坐标(", "m", ",", "n", ")：\"))", "\nres = findpath(puzzle, ", "start", ", ", "end", ")\n", "if", " res:print(res)\n", "else", ": print(", "'无路可走'", ")\n\n\n", "\n", "```"]], "Tag": "算法设计"}
{"Answer": "有具体的说明吗，什么题，什么场景\r\n如果非要到n^2，那就往里填平行边呗，某个图的dfs树种存在横叉边的话，把这些横叉边添加到n^2规模再搜索不就是你要的了。", "Konwledge_Point": "图的深度优先搜索", "Question": ["通过深度优先搜索算法生成有向图的DFS树，是否有可能存在横叉边数目等于Ω(n^2)的情况？", ["题中n代表树点。我现在能想到的就只有：有向图的最大边数为n(n-1)，但我不知道如何证明出Ω(n^2)？还是说这种情况并不可能？谢谢！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你能描述下问题具体是要输出什么吗&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["关于深度优先搜索的问题", ["\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "getnum", "(", "int", " x, ", "int", " y)", ";\n", "void", " ", "dfs", "(", "int", " x, ", "int", " y)", ";\n", "int", " map[", "10", "][", "10", "] =\n{\n    {", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "},\n    {", "1", ",", "0", ",", "1", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "1", "},\n    {", "1", ",", "0", ",", "0", ",", "0", ",", "1", ",", "1", ",", "0", ",", "3", ",", "0", ",", "1", "},\n    {", "1", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", ",", "0", ",", "0", ",", "0", ",", "1", "},\n    {", "1", ",", "3", ",", "0", ",", "0", ",", "3", ",", "1", ",", "0", ",", "3", ",", "0", ",", "1", "},\n    {", "1", ",", "3", ",", "1", ",", "0", ",", "0", ",", "3", ",", "3", ",", "1", ",", "1", ",", "1", "},\n    {", "1", ",", "0", ",", "3", ",", "3", ",", "0", ",", "0", ",", "0", ",", "3", ",", "3", ",", "1", "},\n    {", "1", ",", "1", ",", "0", ",", "0", ",", "3", ",", "0", ",", "0", ",", "0", ",", "3", ",", "1", "},\n    {", "1", ",", "0", ",", "0", ",", "1", ",", "3", ",", "0", ",", "0", ",", "0", ",", "0", ",", "1", "},\n    {", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", ",", "1", "}\n};\n", "typedef", " ", "struct", " {\n    ", "int", " x;\n    ", "int", " y;\n}Note;\n\n", "int", " manipulate[", "4", "][", "2", "] =\n{\n    {", "0", ",", "1", "},\n    {", "1", ",", "0", "},\n    {", "0", ",", "-1", "},\n    {", "-1", ",", "0", "}\n};\n", "int", " book[", "10", "][", "10", "] = { ", "0", " };\n", "int", " killing;\n", "int", " max = ", "0", ";\n", "int", " mx, my;\n\n", "int", " ", "main", "()", "\n", "{\n    \n    ", "dfs", "(", "1", ", ", "1", ");\n    \n    ", "printf", "(", "\"%d from %d,%d\"", ", max, mx, my);\n}\n\n", "void", " ", "dfs", "(", "int", " x,", "int", " y)", "\n", "{\n    ", "if", " (", "1", " == book[x][y] || ", "1", " == map[x][y])\n    {\n        ", "return", ";\n    }\n    book[x][y] = ", "1", ";\n    killing = ", "getnum", "(x, y);\n    ", "if", " (killing > max)\n    {\n        max = killing;\n        mx = x;\n        my = y;\n    }\n\n\n    \n    ", "int", " i;\n    ", "int", " tx, ty;\n    ", "for", " (i = ", "0", "; i < ", "4", "; i++)\n    {\n        tx = x + manipulate[i][", "0", "];\n        ty = y + manipulate[i][", "1", "];\n\n        \n        ", "dfs", "(tx, ty);\n    }\n\n}\n\n    \n\n\n\n\n\n\n\n\n\n", "int", " ", "getnum", "(", "int", " x, ", "int", " y)", "\n", "{\n    ", "int", " sum=", "0", ";\n    ", "int", " i = x;\n    ", "while", " (map[i][y] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[i][y])\n        {\n            sum++;\n        }\n        i++;\n    }\n    \n    i = x;\n    ", "while", " (map[i][y] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[i][y])\n        {\n            sum++;\n        }\n        i--;\n    }\n\n    ", "int", " j = y;\n    ", "while", " (map[x][j] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[x][j])\n            sum++;\n        j++;\n    }\n\n    j = y;\n    ", "while", " (map[x][j] != ", "1", ")\n    {\n        ", "if", " (", "3", " == map[x][j])\n            sum++;\n        j--;\n    }\n\n    ", "return", " sum;\n}\n\n", "\n", "能够出结果，但是结果似乎不对，不知到是哪里出了问题"]], "Tag": "算法设计"}
{"Answer": "http://m.blog.csdn.net/article/details?id=50863937", "Konwledge_Point": "图的深度优先搜索", "Question": ["水洼问题 优先深度搜索", ["Description", "\nDue to recent rains, water has pooled in various places in Farmer John’s field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water (‘W’) or dry land (‘.’). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors.", "\nGiven a diagram of Farmer John’s field, determine how many ponds he has.", "\nInput", "\nLine 1: Two space-separated integers: N and M", "\nLines 2..N+1: M characters per line representing one row of Farmer John’s field. Each character is either ‘W’ or ‘.’. The characters do not have spaces between them.", "\nOutput", "\nLine 1: The number of ponds in Farmer John’s field.", "\nSample Input", "\n10 12 ", "\nW……..WW. ", "\n.WWW…..WWW ", "\n….WW…WW. ", "\n………WW. ", "\n………W.. ", "\n..W……W.. ", "\n.W.W…..WW. ", "\nW.W.W…..W. ", "\n.W.W……W. ", "\n..W…….W.", "\nSample Output", "\n3"]], "Tag": "算法设计"}
{"Answer": "广度，先遍历子节点，再遍历子节点的子节点\r\n12345678\r\n深度，先访问一个节点，往下直到找不到，返回上一个，继续\r\n12485367", "Konwledge_Point": "图的深度优先搜索", "Question": ["数据结构 图的生成树画法", ["\n\n", "原图如上，怎么画他的广度优先，深度优先生成树呢？ 具体画法是什么？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这两个都是正确的&amp;#xff0c;以二叉树为例&amp;#xff0c;dfs的思想是沿着一个子树一直找&amp;#xff0c;找不到了就回溯&amp;#xff0c;再换个子树继续找。当左右子树都找完了&amp;#xff0c;就回到上一层&amp;#xff0c;再在上一层换个子树。没有规定&amp;#xff0c;先找哪个子树。所以上面两个答案都是对的&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如图，关于数据结构 图 的深度优先遍历（DFS） 的遍历顺序问题", ["①和② 两个深度优先遍历的顺序 都是正确 DFS吗？这块内容突然混乱了。", "还是说遇到岔路口时候必须走长的那条？"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;code&gt;append&lt;/code&gt; function may or may not modify the underlying array that your slice refers to. So you are not creating a completely new list when using append. I changed &lt;code&gt;helper&lt;/code&gt; to match your desired behavior.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for i := index; i &amp;lt; length; i++ {\n    if i != index &amp;amp;&amp;amp; nums[i] == nums[i - 1] {\n        continue\n    }\n    if nums[i] &amp;gt; target {\n        break\n    }\n    var newList []int\n    newList = append(newList, list...)\n    newList = append(newList, nums[i])\n    helper(nums, i, target - nums[i], newList, resultp, length)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["使用Golang时对深度优先搜索结果感到困惑", ["\n\n", "I tried to solve the 'Combination Sum' on leetcode, and the result is wrong when using test case:", "\n\n", "\n  ", "[7,3,2] 18", "\n", "\n\n", "I used C++ with the same logic and passed, but when using Golang, my result is:", "\n\n", "\n  ", "[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,7,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]", "\n", "\n\n", "and the correct one should be", "\n\n", "\n  ", "[[2,2,2,2,2,2,2,2,2],[2,2,2,2,2,2,3,3],[2,2,2,2,3,7],[2,2,2,3,3,3,3],[2,2,7,7],[2,3,3,3,7],[3,3,3,3,3,3]]", "\n", "\n\n", "the code is shown below:", "\n\n", "import \"sort\"\nfunc combinationSum(candidates []int, target int) [][]int {\n    result := make([][]int, 0, 0)\n    resultp := &result\n    sort.Ints(candidates)\n    helper(candidates, 0, target, make([]int, 0, 0), resultp, len(candidates))\n    return *resultp\n}\n\nfunc helper(nums []int, index int, target int, list []int, resultp *[][]int, length int) {\n    if target == 0 {\n        *resultp = append(*resultp, list)\n        return\n    }\n    for i := index; i < length; i++ {\n        if i != index && nums[i] == nums[i - 1] {\n            continue\n        }\n        if (nums[i] > target) {\n            break\n        }\n        helper(nums, i, target - nums[i], append(list, nums[i]), resultp, length)\n    }\n}\n", "\n\n", "Can anyone tell me why the result is incorrect, I am just confused about the [2,2,2,2,2,7,3,3] in my answer, why the 7 is before the 3 since the array has been sorted? Or anyone can tell me what mistake I have made in my code ", "\n\n\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;图的深度优先遍历类似于二叉树的先序遍历&amp;#xff0c;图的广度优先遍历类似于二叉树的层次遍历。&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;以上仅供参考&amp;#xff0c;如有任何疑问&amp;#xff0c;可以评论回复&amp;#xff0c;看到即回。&lt;br /&gt;&lt;strong&gt;希望对题主有所帮助&amp;#xff01;可以的话&amp;#xff0c;点个采纳&amp;#xff01;&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["深度优先搜索和树与图的深度优先遍历有什么区别吗？", ["深度优先搜索和树与图的深度优先遍历有什么区别吗？    同理，宽度呢？"]], "Tag": "算法设计"}
{"Answer": "1 2 4 8 9 5 10 11 3 6 7", "Konwledge_Point": "图的深度优先搜索", "Question": ["已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列", ["已知一颗满二叉树可以用线性表1 2 3 4 5 6 7 8 9 10 11表示，求出深度优先遍历序列"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ds[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, m;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (y&amp;lt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || y&amp;gt;&amp;#61;n || x&amp;lt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || x&amp;gt;&amp;#61;m || a[y][x]!&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,sum &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    a[y][x] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//这块草坪已经烧过了&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        sum &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(y&amp;#43;ds[i][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], x&amp;#43;ds[i][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sum;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j, d, max;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;)\n    {\n        cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; m &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m; j&amp;#43;&amp;#43;)\n            {\n                cin &amp;gt;&amp;gt; a[i][j];\n            }\n        }\n        max &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m; j&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a[i][j] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                {\n                    d &amp;#61; &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(i, j);\n                    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;gt; max)\n                        max &amp;#61; d;\n                }\n            }\n        }\n        cout &amp;lt;&amp;lt; max &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/696528560846188.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["关于这道深度优先遍历的问题，如何解决？（C++）", ["【问题描述】", "给你一块n", "m的草坪，问如果只点一次火，最多能烧多少块草坪。可以从n", "m的草地中任意一个地方开始点火，火只能往上下左右传递，没有草的地方不能燃烧。", "【输入格式】", "输入由多个测试例组成。每个测试例的第一行含两个整数n和m, (1 <=n,m<=100), 分别表示01矩阵的行数与列数，", "后面紧跟着n行，每行含m个整数0或1，1代表草坪，0表示啥也没有，相邻两个整数之间用一个空格隔开，两个测", "试例之间用一个空行隔开，最后一个测试例之后隔一个空行，最后一行含有两个整数0，表示输入结束。", "【输出格式】", "每个测试例对应一行输出，含一个整数，表示只点一次火最多能烧的草坪个数。", "【样例输入】", "5 6", "0 1 1 0 0 1", "1 1 0 1 0 1", "0 1 0 0 1 0", "0 0 0 1 1 1", "1 0 1 1 1 0", "\n", "0 0", "【样例输出】", "7", "【提示】", "深度优先搜索DFS的应用", "\n", "请问C++如何用深度优先搜索解决呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;试着写了一下&amp;#xff0c;应该还可以优化&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;def findpath(puzzle, start, end):\n    d &amp;#61; [(&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)]\n    vis &amp;#61; [[&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt; for &lt;span class=\"hljs-symbol\"&gt;_&lt;/span&gt; in range(len(puzzle[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]))] for &lt;span class=\"hljs-symbol\"&gt;_&lt;/span&gt; in range(len(puzzle))]\n    vis[start[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]][start[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]]&amp;#61;start\n    dfs &amp;#61; [start]\n    while dfs:\n        x,y &amp;#61; dfs.pop()\n        for i in range(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;):\n            m &amp;#61; x&amp;#43;d[i][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n            n &amp;#61; y&amp;#43;d[i][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            if &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;lt;&amp;#61;m&amp;lt;len(puzzle) and &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;lt;&amp;#61;n&amp;lt;len(puzzle[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]) and puzzle[m][n]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; and vis[m][n]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;:\n                dfs.append((x,y))\n                dfs.append((m,n))\n                vis[m][n]&amp;#61;(x,y)\n                if end&amp;#61;&amp;#61;(m,n):return dfs\n                break   \n    return dfs\n\npuzzle &amp;#61; [\n    [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],\n    [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],\n    [&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],\n    [&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n]\nstart &amp;#61; eval(input(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入起始坐标(x,y)&amp;#xff1a;&amp;#34;&lt;/span&gt;))\nend &amp;#61; eval(input(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入终点坐标(m,n)&amp;#xff1a;&amp;#34;&lt;/span&gt;))\nres &amp;#61; findpath(puzzle, start, end)\nif res:print(res)\nelse: print(&lt;span class=\"hljs-string\"&gt;&amp;#39;无路可走&amp;#39;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;请输入起始坐标&lt;span class=\"hljs-comment\"&gt;(x,y)&lt;/span&gt;&amp;#xff1a;&lt;span class=\"hljs-comment\"&gt;(0,0)&lt;/span&gt;\n请输入终点坐标&lt;span class=\"hljs-comment\"&gt;(m,n)&lt;/span&gt;&amp;#xff1a;&lt;span class=\"hljs-comment\"&gt;(3,3)&lt;/span&gt;\n[&lt;span class=\"hljs-comment\"&gt;(0, 0)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(1, 0)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(2, 0)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(2, 1)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(3, 1)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(3, 2)&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;(3, 3)&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["深度优先搜索怎么实现走迷宫呀", ["怎么用dfs深度优先搜索实现走迷宫呀,怎么实现两个坐标中走迷宫出一个路径"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;节点会有分叉是什么意思&amp;#xff1f;你每行数据只有两个数据不同&amp;#xff0c;是根据数据的大小排序吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如何将csv文件中的节点数据通过深度优先搜索进行排序，再进行重新编号", ["举例：", "这些节点会有分叉，如何通过深度优先搜索进行排序编号。本人对此方面尚未接触过，求详细解答"]], "Tag": "算法设计"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;这篇文章讲的很详细&amp;#xff0c;请看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/weixin_37841366/article/details/111777215\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;找到搜索二叉树中两个错误的节点&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "图的深度优先搜索", "Question": ["第二题深度优先搜索怎么做", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdlib.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;string.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXSIZE 3&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXNODESIZE 10&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Branch&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Branch&lt;/span&gt;* next;\n}branch;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Tnode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; data[MAXSIZE]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;\\0&amp;#34;&lt;/span&gt;;\n    branch* first;\n}tnode;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;create&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tnode tree[], &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//创建邻接表&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, t &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n   \n\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;一共有%d个头节点\\n&amp;#34;, cnt);&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt; i&amp;#43;&amp;#43;)\n    {\n        j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;//遇到/就开始找换行符\\n&amp;#xff0c;并跳转到下一行&amp;#xff0c;录入下一行头节点&lt;/span&gt;\n        {\n            tree[i].data[j] &amp;#61; str[t];\n            j&amp;#43;&amp;#43;;\n            t&amp;#43;&amp;#43;;\n        }\n        tree[i].data[j] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//为tree[i].data加入终止符&lt;/span&gt;\n        tree[i].first &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; str[t] !&amp;#61; EOF)  &lt;span class=\"hljs-comment\"&gt;//跳转至下一行&amp;#xff0c;准备录下一行的头节点&lt;/span&gt;\n            t&amp;#43;&amp;#43;;\n        t&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-comment\"&gt;//puts(tree[i].data);  //将该行的头节点中的串打印出来以检验头节点的串是否成功录入&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//头节点初始化完成&amp;#xff0c;接下来将子节点连接到&lt;/span&gt;\n    t &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt &amp;amp;&amp;amp; t &amp;lt; size; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t &amp;lt; size &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;//先跳过头节点&lt;/span&gt;\n            t&amp;#43;&amp;#43;;\n        t&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-comment\"&gt;// p &amp;#61; (branch*)malloc(sizeof(branch));&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t &amp;lt; size &amp;amp;&amp;amp;str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;// 这里是bug1: t是数字&amp;#xff0c; 也要可能是空了&lt;/span&gt;\n        {\n            j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; string[MAXSIZE];\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t &amp;lt; size &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; str[t] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;//将字符串截取出来 bug2:不能处理换行符&lt;/span&gt;\n            {\n                string[j] &amp;#61; str[t];\n                j&amp;#43;&amp;#43;;\n                t&amp;#43;&amp;#43;;\n            }\n            &lt;span class=\"hljs-comment\"&gt;//此时str[t]&amp;#61;&amp;#61;&amp;#39;/&amp;#39;&lt;/span&gt;\n            string[j] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n            &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;子串为:&amp;#34;);&lt;/span&gt;\n            &lt;span class=\"hljs-comment\"&gt;//puts(string);&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; target &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; n &amp;lt; cnt; n&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(tree[n].data, string)) {\n                    target &amp;#61; n;\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n                }\n            }\n            branch* p &amp;#61; tree[i].first;\n            &lt;span class=\"hljs-comment\"&gt;//bug3:插入方式不正确&amp;#xff0c;应该后插入&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {\n                p &amp;#61; (branch*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(branch));\n                p-&amp;gt;index &amp;#61; target;\n                p-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n                tree[i].first &amp;#61; p;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) {\n                    p &amp;#61; p-&amp;gt;next;\n                }\n                p-&amp;gt;next &amp;#61; (branch*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(branch));\n                p-&amp;gt;next-&amp;gt;index &amp;#61; target;\n                p-&amp;gt;next-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t &amp;gt;&amp;#61; size ||str[t] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;) {\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n            t&amp;#43;&amp;#43;;  &lt;span class=\"hljs-comment\"&gt;//使t指向下一个单词开头 &lt;/span&gt;\n        }\n        &lt;span class=\"hljs-comment\"&gt;//此时t指向\\n&lt;/span&gt;\n        t&amp;#43;&amp;#43;;  &lt;span class=\"hljs-comment\"&gt;//将t指向下一行第一个字符&lt;/span&gt;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[], tnode tree[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DFS&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tnode tree[])&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//对邻接表进行深度优先遍历&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[MAXNODESIZE];\n  \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; MAXNODESIZE; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(tree[i].data)&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;){\n            cnt&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt; i&amp;#43;&amp;#43;) visited[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; cnt; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[i]) {\n            &lt;span class=\"hljs-comment\"&gt;//没有遍历过&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(visited, tree,   i);\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[], tnode tree[],   &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v)&lt;/span&gt; &lt;/span&gt;{\n    tnode t &amp;#61; tree[v];\n    &lt;span class=\"hljs-built_in\"&gt;puts&lt;/span&gt;(t.data);\n    visited[v] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (branch* w &amp;#61; t.first; w !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;; w &amp;#61; w-&amp;gt;next) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[w-&amp;gt;index]) { \n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(visited, tree, w-&amp;gt;index);\n        }\n    }\n\n}\n \n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;visit&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(tnode* node, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[])&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//对结点进行访问&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(node-&amp;gt;data, str))\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;该结点存在&amp;#xff01;&amp;#34;&lt;/span&gt;);\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FillInText&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[], FILE* fp)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//将文件中内容传入str中&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    ch &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fgetc&lt;/span&gt;(fp);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (ch !&amp;#61; EOF)\n    {\n        str[length] &amp;#61; ch;\n        ch &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fgetc&lt;/span&gt;(fp);\n        length&amp;#43;&amp;#43;;\n    }\n    str[length] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getCount&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[])&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//获取邻接表头节点个数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str[i] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)\n            cnt&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cnt &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    FILE* fp;\n    tnode tree[MAXNODESIZE];\n    \n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch, str[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n    fp &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;C:\\\\Users\\\\Lenovo\\\\Desktop\\\\1\\\\test.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fp &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;文件打开失败\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;FillInText&lt;/span&gt;(str, fp);\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(fp);\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;文件中的文本内容为:\\n&amp;#34;);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//puts(str);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;create&lt;/span&gt;(tree, str, &lt;span class=\"hljs-built_in\"&gt;getCount&lt;/span&gt;(str)); \n    &lt;span class=\"hljs-built_in\"&gt;DFS&lt;/span&gt;(tree);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["对邻接表进行深度优先遍历", ["问题：", "将文本文件中的文本数据提取，并以此建立邻接表，再进行树的深度优先搜索。", "遇到的问题：", "在创建邻接表的时候，感觉逻辑有点混乱。", "我先是把邻接表的头节点都先加载出来，再将子节点接到头节点上。", "子节点接到头结点这个环节，感觉有点乱。", "文本文件内容：", "\n", "\n", "目标：", "将该内容变成存储内的邻接表", "\n", "\n", "并对该邻接表进行深度优先遍历", "\n", "求指教！", "以下为我的屎山代码XD（目前程序还是有问题的，问题在子节点连接到头节点那一块）：", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS", "\n", "#", "include", " ", "\"stdio.h\"", "\n", "#", "include", " ", "\"stdlib.h\"", "\n", "#", "include", " ", "\"string.h\"", "\n", "#", "define", " MAXSIZE 20", "\n", "typedef", " ", "struct", " ", "Branch", "\n{\n    ", "int", " index;\n    ", "struct", " ", "Branch", "* next;\n}branch;\n\n", "typedef", " ", "struct", " ", "Tnode", "\n{\n    ", "char", " data[MAXSIZE];\n    branch* first;\n}tnode;\n\n", "void", " ", "create", "(tnode tree[],", "char", " str[],", "int", " cnt)", "  ", "//创建邻接表", "\n", "{\n    ", "int", " j = ", "0", ", t = ", "0", ";\n    ", "char", " string[MAXSIZE];\n    branch* p;\n    ", "printf", "(", "\"一共有%d个头节点\\n\"", ", cnt);\n    ", "for", " (", "int", " i = ", "0", "; i < cnt; i++)\n    {\n        j = ", "0", ";\n        ", "while", " (str[t] != ", "'/'", ")  ", "//遇到/就开始找换行符\\n，并跳转到下一行，录入下一行头节点", "\n        {\n            tree[i].data[j] = str[t];\n            j++;\n            t++;\n        }\n        tree[i].data[j] = ", "'\\0'", ";  ", "//为tree[i].data加入终止符", "\n        tree[i].first = ", "NULL", ";\n        ", "while", " (str[t] != ", "'\\n'", "&&str[t]!=EOF)  ", "//跳转至下一行，准备录下一行的头节点", "\n            t++;\n        t++;\n        ", "puts", "(tree[i].data);  ", "//将该行的头节点中的串打印出来以检验头节点的串是否成功录入", "\n    }\n    ", "//头节点初始化完成，接下来将子节点连接到", "\n    t = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < cnt; i++)\n    {\n        ", "while", " (str[t] != ", "'/'", ")  ", "//先跳过头节点", "\n            t++;\n        t++;\n        p = (branch*)", "malloc", "(", "sizeof", "(branch));\n        ", "while", " (t != ", "'\\n'", ")\n        {\n            j = ", "0", ";\n            ", "for", " (", "int", " n = ", "0", "; n < ", "strlen", "(string); n++)", "//字符串清空", "\n                string[n] = ", "'\\0'", ";\n            ", "while", " (str[t] != ", "'/'", ")", "//将字符串截取出来", "\n            {\n                string[j] = str[t];\n                j++;\n                t++;\n            }\n            ", "//此时str[t]=='/'", "\n            string[j] = ", "'\\0'", ";\n            ", "printf", "(", "\"子串为:\"", ");\n            ", "puts", "(string);\n            ", "for", " (", "int", " n = ", "0", "; n < cnt; n++)\n            {\n                ", "if", " (!", "strcmp", "(tree[n].data, string))\n                    p->index = n;\n            }\n            p->next = tree[i].first;", "//将p接入头节点中", "\n            tree[i].first = p;\n            t++;  ", "//使t指向下一个单词开头", "\n            p = (branch*)", "malloc", "(", "sizeof", "(branch));\n        }\n        ", "//此时t指向\\n", "\n        t++;  ", "//将t指向下一行第一个字符", "\n    }\n}\n\n", "void", " ", "DFS", "(tnode tree[])", "  ", "//对邻接表进行深度优先遍历", "\n", "{\n\n}\n\n", "void", " ", "visit", "(tnode* node,", "char", " str[])", "  ", "//对结点进行访问", "\n", "{\n    ", "if", " (!", "strcmp", "(node->data, str))\n    {\n        ", "printf", "(", "\"该结点存在！\"", ");\n    }\n}\n\n", "void", " ", "FillInText", "(", "char", " str[], FILE* fp)", "  ", "//将文件中内容传入str中", "\n", "{\n    ", "char", " ch;\n    ", "int", " length = ", "0", ";\n    ch = ", "fgetc", "(fp);\n    ", "while", " (ch != EOF)\n    {\n        str[length] = ch;\n        ch = ", "fgetc", "(fp);\n        length++;\n    }\n    str[length] = ", "'\\0'", ";\n}\n\n", "int", " ", "getCount", "(", "char", " str[])", "  ", "//获取邻接表头节点个数", "\n", "{\n    ", "int", " cnt = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < ", "strlen", "(str); i++)\n    {\n        ", "if", " (str[i] == ", "'\\n'", ")\n            cnt++;\n    }\n    ", "return", " cnt + ", "1", ";\n}\n\n", "int", " ", "main", "()", "\n", "{\n    FILE* fp;\n    tnode tree[MAXSIZE];\n    ", "char", " ch, str[", "100", "];\n    fp = ", "fopen", "(", "\"test.txt\"", ", ", "\"r\"", ");\n    ", "if", " (fp == ", "NULL", ")\n    {\n        ", "printf", "(", "\"文件打开失败\\n\"", ");\n        ", "exit", "(", "0", ");\n    }\n    ", "FillInText", "(str, fp);\n    ", "printf", "(", "\"文件中的文本内容为:\\n\"", ");\n    ", "puts", "(str);\n    ", "create", "(tree, str,", "getCount", "(str));\n    ", "fclose", "(fp);\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "很明显就是你的内存分配以后，没有对其中的字段，比如firstChild nextSibling初始化\r\n\r\n邻接表G建立的有问题，排查一下邻接矩阵转换到邻接表的函数\r\n\r\n# 没有采纳之前先回答你这么多吧", "Konwledge_Point": "图的深度优先搜索", "Question": ["求教大佬们，这个“读取位置 0xCCCCCCCC 时发生访问冲突。”的异常该如何解决？", ["程序是数据结构的图的存储和遍历实验，功能是输入一个无向图并将其转换成邻接矩阵，然后把邻接矩阵变成邻接表，最后深度优先遍历该邻接表生成树（VS2017）：", "\n\n", "#include <stdio.h>\n#include <malloc.h>\n#include <stdlib.h>\n#include <string.h>\n#include<iostream>\nusing namespace std;\ntypedef int InfoType;\n#define MAXV 100                //最大顶点个数\n#define INF 32767               //INF表示∞\n#define isLetter(a)  ((((a)>='a')&&((a)<='z')) || (((a)>='A')&&((a)<='Z')))\n#define LENGTH(a)  (sizeof(a)/sizeof(a[0]))\n//以下定义邻接矩阵类型\ntypedef struct\n{\n    int no;                     //顶点编号\n    InfoType info;              //顶点其他信息\n} VertexType;                   //顶点类型\ntypedef struct              //图的定义\n{\n    char vexnum[MAXV];\n    int edges[MAXV][MAXV];      //邻接矩阵\n    int n, e;                       //顶点数，边数\n    VertexType vexs[MAXV];      //存放顶点信息\n} MGraph, *PGragh;                      //图的邻接矩阵类型\n//以下定义邻接表类型\ntypedef struct ANode            //边的节点结构类型\n{\n    int adjvex;                 //该边的终点位置\n    struct ANode *nextarc = NULL;       //指向下一条边的指针\n    InfoType *info;             //该边的相关信息,这里用于存放权值\n} ArcNode;\ntypedef int Vertex;\ntypedef struct Vnode            //邻接表头节点的类型\n{\n    Vertex data;                //顶点信息\n    ArcNode *firstarc;          //指向第一条边\n} VNode;\ntypedef VNode AdjList[MAXV];    //AdjList是邻接表类型\ntypedef struct\n{\n    AdjList adjlist;            //邻接表\n    int n, e;                   //图中顶点数n和边数e\n} ALGraph;                      //图的邻接表类型\n\nvoid MatToList(MGraph *g, ALGraph *G)\n//将邻接矩阵g转换成邻接表G\n{\n    int i, j;\n    ArcNode *p;\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    for (i = 0; i<g->n; i++)                    //给邻接表中所有头节点的指针域置初值\n        G->adjlist[i].firstarc = NULL;\n    for (i = 0; i<g->n; i++)                    //检查邻接矩阵中每个元素\n    for (j = g->n - 1; j >= 0; j--)\n    if (g->edges[i][j] != 0)        //存在一条边\n    {\n        p = (ArcNode *)malloc(sizeof(ArcNode)); //创建一个节点*p\n        p->adjvex = j;\n        p->nextarc = G->adjlist[i].firstarc;        //采用头插法插入*p\n        G->adjlist[i].firstarc = p;\n    }\n    G->n = g->n; G->e = g->e;\n    //return G;\n}\n\nvoid DispMat(MGraph *g)\n//输出邻接矩阵g\n{\n    int i, j;\n    for (i = 0; i<g->n; i++)\n    {\n        for (j = 0; j<g->n; j++)\n            printf(\"%3d\", g->edges[i][j]);\n        printf(\"\\n\");\n    }\n}\nvoid DispAdj(ALGraph G)\n//输出邻接表G\n{\n    int i;\n    ArcNode *p;\n    for (i = 0; i<G.n; i++)\n    {\n        p = G.adjlist[i].firstarc;\n        printf(\"%3d: \",i);\n        //cout << i << \":\";\n        while (p != NULL)\n        {\n            //printf(\"%3d\",p->adjvex);\n            cout << p->adjvex << \" \";\n            p = p->nextarc;\n        }\n        printf(\"\\n\");\n    }\n}\nstatic int get_position(MGraph g, char ch)\n{\n    int i;\n    for (i = 0; i<g.n; i++)\n    if (g.vexnum[i] == ch)\n        return i;\n    return -1;\n}\n\n\n//读取一个输入字符\n\nstatic char read_char()\n{\n    char ch;\n\n    do {\n        ch = getchar();\n    } while (!isLetter(ch));\n\n    return ch;\n}\n\n\n// 创建无向图\n\nMGraph* create_graph()\n{\n    char c1, c2;\n    int vex, edge;\n    int i, p1, p2;\n    MGraph* pG;\n\n    // 输入顶点数和边数\n    printf(\"输入顶点数和边数：\");\n    scanf_s(\"%d%d\", &vex, &edge);\n    if (vex < 1 || edge < 1 || (edge >(vex * (vex - 1))))\n    {\n        printf(\"input error: invalid parameters!\\n\");\n        return NULL;\n    }\n\n    if ((pG = (MGraph*)malloc(sizeof(MGraph))) == NULL)\n        return NULL;\n    memset(pG, 0, sizeof(MGraph));\n\n    // 初始化顶点数和边数\n    pG->n = vex;\n    pG->e = edge;\n    // 初始化\"顶点\"\n    printf(\"输入各顶点名称：\\n\");\n    for (i = 0; i < pG->n; i++)\n    {\n        printf(\"vertex(%d): \", i);\n        pG->vexnum[i] = read_char();\n    }\n\n    // 初始化\"边\"\n    for (i = 0; i < pG->e; i++)\n    {\n        // 读取边的起始顶点和结束顶点\n        printf(\"edge(%d):\", i);\n        c1 = read_char();\n        c2 = read_char();\n\n        p1 = get_position(*pG, c1);\n        p2 = get_position(*pG, c2);\n        if (p1 == -1 || p2 == -1)\n        {\n            printf(\"input error: invalid edge!\\n\");\n            free(pG);\n            return NULL;\n        }\n\n        pG->edges[p1][p2] = 1;\n        pG->edges[p2][p1] = 1;\n    }\n\n    return pG;\n}\n// 打印矩阵队列图\n\nvoid print_graph(MGraph G)\n{\n    int i, j;\n\n    printf(\"Martix Graph:\\n\");\n    for (i = 0; i < G.n; i++)\n    {\n        for (j = 0; j < G.n; j++)\n            printf(\"%d \", G.edges[i][j]);\n        printf(\"\\n\");\n    }\n}\n//创建一个树的左子女，右兄弟结构\ntypedef struct node\n{\n    int data;\n    node *firstChild = NULL;\n    node *nextSibling = NULL;\n}TreeNode, *BinTree;\nint visited[MAXV];\nvoid Dfs(ALGraph G, int i, BinTree &T)\n{\n    visited[i] = 1;\n    bool first = true;//表示是否为当前节点第一个孩子\n    TreeNode *locat = new TreeNode;//同样是定位作用\n    while (G.adjlist[i].firstarc != NULL)//从此节点出发，访问邻接节点。\n    {\n        if (visited[G.adjlist[i].firstarc->adjvex] == 0)\n        {\n            visited[G.adjlist[i].firstarc->adjvex] = 1;\n            TreeNode *t = new TreeNode;//建立一颗小树\n            t->data = G.adjlist[i].firstarc->adjvex;\n            if (first)//是当前节点第一个孩子\n            {\n                T->nextSibling = t;//建立右孩子\n                first = false;//表示不是传进来的第一个孩子,则是孩子们的兄弟\n            }\n            else\n            {\n                locat->nextSibling = t;\n            }\n            locat = t;\n            Dfs(G, G.adjlist[i].firstarc->adjvex, t);//继续对小树找兄弟\n        }\n        G.adjlist[i].firstarc = G.adjlist[i].firstarc->nextarc;\n    }\n}\n\nvoid DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n\n//建立图深度优先搜索森林\nvoid DFSForest(ALGraph G, BinTree &T)\n{\n    DFS_Traverse(G, T);\n}\nvoid Display(BinTree T)\n{\n    if (T)\n    {\n        cout << T->data << ' ';\n        Display(T->firstChild);\n        Display(T->nextSibling);\n    }\n}\n\n\n\n//以下主函数用作调试\nint main()\n{\n    //int i, j;\n    MGraph* g, g1;\n    ALGraph G;\n    BinTree T;\n    g = create_graph();\n    printf(\"\\n\");\n    printf(\" 无向图G的邻接矩阵:\\n\");\n    DispMat(g);\n\n\n    //G = (ALGraph *)malloc(sizeof(ALGraph));\n    //M = (ALGraph *)malloc(sizeof(ALGraph));\n    printf(\" 图G的邻接矩阵转换成邻接表，顶点名称用编号表示:\\n\");\n    MatToList(g, &G);\n    DispAdj(G);\n    DFSForest(G, T);\n    Display(T);\n\n\n    system(\"pause\");\n}\n", "\n\n", "运行程序，输入顶点和边的信息，能够输出邻接矩阵和邻接表，但到了生成森林那一步就报异常：", "\n和同学研究了一下发现问题可能是出在执行到函数", "\n\n", "void DFS_Traverse(ALGraph G, BinTree &T)\n{\n    TreeNode *locat = new TreeNode;//此处定义一个定位指针，用来定位当前树的位置\n    for (int i = 1; i <= G.n; i++)\n    {\n        visited[i] = 0;\n    }\n    for (int i = 1; i <= G.n; i++)\n    {\n        if (visited[i] == 0)\n        {\n            TreeNode *t = new TreeNode;//这代表一个小树\n            t->data = G.adjlist[i].data;\n            if (T == NULL)\n            {\n                T = t;//若树为空，建立头节点\n            }\n            else\n            {\n                locat->nextSibling = t;//若树不空，则是森林，插入右兄弟\n            }\n            locat = t;//定位至小树\n            Dfs(G, i, locat);//建立小树\n        }\n    }\n}\n", "\n\n", "的最后一个for中的Dfs（G，i，locat）；这一句时出了问题，若在该处设置断点再重新运行程序并输入测试数据：", "\n然后按F11逐行运行，就跳到了函数Dfs（）那里：", "\n这时候按“继续”继续运行，到第二次循环时异常就出现了，请教大佬我应该如何修改这个程序，谢谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;给你写了个树&amp;#xff0c;然后按照二叉树排序了一个数组&amp;#xff0c;然后按中序遍历打印树的结点值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n\npublic &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Tree {\n\n    public &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; value;\n    public Tree left;\n    public Tree right;\n\n    &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        value &amp;#61; v;\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;AddLeft(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        left &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;AddRight(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        right &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (v &amp;lt; value) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (left&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;null) {\n                &lt;span class=\"hljs-constructor\"&gt;AddLeft(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                left.&lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            }\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (right&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;null) {\n                &lt;span class=\"hljs-constructor\"&gt;AddRight(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                right.&lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;)&lt;/span&gt;;\n            }\n        }\n    }\n\n    public void &lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (left !&amp;#61; null) {\n            left.&lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(value);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (right !&amp;#61; null) {\n            right.&lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt;;\n        }\n    }\n\n    public static void main(String&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; args) {\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; values&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; { &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; };\n        Tree bt &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Tree(&lt;span class=\"hljs-params\"&gt;values&lt;/span&gt;[0])&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; values.length; i&amp;#43;&amp;#43;) {\n            bt.&lt;span class=\"hljs-constructor\"&gt;Add(&lt;span class=\"hljs-params\"&gt;values&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;])&lt;/span&gt;;\n        }\n        bt.&lt;span class=\"hljs-constructor\"&gt;Print()&lt;/span&gt;;\n    }\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["二叉树怎么打印，为什么图中的left和right会报红？", ["\n", "\n", "import", " javax.swing.tree.TreeNode;  ", "//这玩意儿也有导包，可以在非主方法里赋类型啥的", "\n", "import", " java.util.ArrayList;\n", "import", " java.util.List;\n\n", "public", " ", "class", " ", "demoEz94", " {  ", "//深度优先搜索跟递归有关跟深度优先搜索也有关", "\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "Tree", " ", "bt", " ", "=", " ", "new", " ", "Tree", "();\n        bt.createBinTree(bt.root);\n    }\n\n\n\n    ", "public", " List<Integer> ", "solution", "(TreeNode root)", "{\n        List<Integer> res = ", "new", " ", "ArrayList", "<Integer>();\n        inorder(root, res);\n        ", "return", " res;\n\n    }\n\n    ", "public", " ", "void", " ", "inorder", "(TreeNode root, List<Integer> res)", "{\n        ", "if", "(root == ", "null", "){\n            ", "return", ";\n        }\n        inorder(root.left, res);\n        res.add(root.val);\n        inorder(root.right, res);\n\n    }\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;xx✔x&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["请问这几句话哪几句是说法正确的？", ["1.⼴度优先搜索和深度优先搜索不可以互相转化。", "2.如果递推得到的答案很⼤，需要取模，可以只在算出结果后取模，在中间过程不⽤取模。", "3.递推需要严格的边界条件和数据范围。", "4.编译正确，并且样例输出正确的代码，提交之后⼀定可以AC。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考一下&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n \n#define OK 1\n#define ERROR -1\n#define OVERFLOW 0\t\t\t\t\n#define MAXVER 20\t\t\t\t//定义最大定点数\n#define MAXINT 200\t\t\t   \t// 无穷大\n#define NULL 0\n \ntypedef char verType;\t\t\t//定义顶点类型\ntypedef int status ;\n \ntypedef struct ver\t\t\t\t//关于景点(顶点)信息存放&amp;#xff08;结构体数组&amp;#xff09;\n{\n\tchar name[20];\t\t\t\t//存放景点名称\n\tchar mask;\t\t\t\t\t//存放景点代号\n\tchar intro[20];\t\t\t\t//景点简介\n    \n}Ver[MAXVER];\n \ntypedef struct\t\t\t\t\t//无向网存放景区信息\n{\n\tVer  verx;\t\t\t\t\t//定义顶点\n    int arcs[MAXVER][MAXVER];\t//定义弧\n\tint vernum,arcsnum;\t\t\t//定义最大顶点数 和弧\n}MGraph;\n \nint locate(MGraph G,verType ch) //查找顶点在数组中的下标\n{\n\tint i;\n    for(i&amp;#61;0;i&amp;lt;G.vernum&amp;amp;&amp;amp;ch!&amp;#61;G.verx[i].mask;i&amp;#43;&amp;#43;);\n\treturn i;\n}\n \nstatus createUDN(MGraph &amp;amp;G,int &amp;amp;v)\t\t\t//创建无向网\n{\n\tint i,j,w,k;\n\tverType ch1,ch2;\n\tprintf(&amp;#34;请输入场所的个数和路径数&amp;#xff1a;格式如2 3\\n&amp;#34;);\n\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;G.vernum,&amp;amp;G.arcsnum); \n\tfflush(stdin);\n\tprintf(&amp;#34;请输入顶点信息\\n&amp;#34;);\n\tfor(i&amp;#61;0;i&amp;lt;G.vernum;i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;\\n请输入第%d个景点名称:\\n&amp;#34;,i&amp;#43;1);\n\t\tscanf(&amp;#34;%s&amp;#34;,&amp;amp;G.verx[i].name);\n\t\tfflush(stdin);\n\t\tprintf(&amp;#34;请输入景点代号&amp;#xff0c;用一个字符表示如A\\n&amp;#34;);\n\t\tscanf(&amp;#34;%c&amp;#34;,&amp;amp;G.verx[i].mask);\n\t\tfflush(stdin);\n\t\tprintf(&amp;#34;请对景点简单介绍\\n&amp;#34;);\n\t\tscanf(&amp;#34;%s&amp;#34;,&amp;amp;G.verx[i].intro);\n\t\tfflush(stdin);\n\t}\n\tfor(i&amp;#61;0;i&amp;lt;G.vernum;i&amp;#43;&amp;#43;)\n\t{\n\t\tfor(j&amp;#61;0;j&amp;lt;G.vernum;j&amp;#43;&amp;#43;)\n\t\t\tG.arcs[i][j]&amp;#61;MAXINT;\t\t\t//赋初值为无穷大\n\t}\n\tprintf(&amp;#34;请输入场所间距离&amp;#xff1a;格式A B 3\\\\n \\n&amp;#34;);\n\tfor(i&amp;#61;0;i&amp;lt;G.arcsnum;i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;请输入第%d对值\\n&amp;#34;,i&amp;#43;1);\n\t\tscanf(&amp;#34;%c %c %d&amp;#34;,&amp;amp;ch1,&amp;amp;ch2,&amp;amp;w);\t\t   //输入顶点符号和权值\n\t\tfflush(stdin); \n\t\tk&amp;#61;locate(G,ch1);\t\t\t\t\t   //获得顶点下标\n\t\tj&amp;#61;locate(G,ch2);\n\t\tG.arcs[k][j]&amp;#61;w;\t\t\t\t\t\t   //为临界矩阵赋值\n\t\tG.arcs[j][k]&amp;#61;G.arcs[k][j];\t\t\t   //无向图为对称矩阵\n\t}\n\treturn OK;\n}\n \n \nvoid message(MGraph G)\t\t\t\t\t\t//进行信息查询\n{\n    char mask;\n\tprintf(&amp;#34;请输入要查询景点代号如A\\n&amp;#34;);\n\tscanf(&amp;#34;%c&amp;#34;,&amp;amp;mask);\n\tfflush(stdin);\n\t\tfor(int i&amp;#61;0;i&amp;lt;G.vernum;i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tif(mask&amp;#61;&amp;#61;G.verx[i].mask)\n\t\t\t{\n\t\t\t\tprintf(&amp;#34;景点名称&amp;#xff1a;%s\\n景点简介&amp;#xff1a;%s&amp;#34;,G.verx[i].name,G.verx[i].intro);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n}\n \n \nint search(MGraph G)\t\t\t\t\t\t//进行最短路径查询\n{\n\tchar value1,value2; \n\tint i,j;\t\t\t\t\t\t\t\t//存放两个值得下标\n\tint q;\n\tint all&amp;#61;0;\t\t\t\t\t\t\t\t//记录经过点的个数\n\tint lujing[MAXINT][MAXINT];\t\t\t    //用来 记录路径\n\tfor (int m&amp;#61;0;m&amp;lt;MAXINT;m&amp;#43;&amp;#43;)\n\t\tfor (int n&amp;#61;0;n&amp;lt;MAXINT;n&amp;#43;&amp;#43;)\n\t\t\tlujing[m][n]&amp;#61;NULL;\n \n\tint sub;\n\tint D[MAXVER],P[MAXVER],min;\n\tbool final[MAXVER];\n\tprintf(&amp;#34;\\n请输入两个场所值求其最短距离和路径 如A B\\n&amp;#34;);\n\tscanf(&amp;#34;%c %c&amp;#34;,&amp;amp;value1,&amp;amp;value2);\n    i&amp;#61;locate(G,value1);\t\t\t\t\t\t//获得第一个顶点下标\n\tj&amp;#61;locate(G,value2);\t\t\t\t\t\t//获取第二个顶点下标\n\tsub&amp;#61;i;\n\t\n\tfor(int v&amp;#61;0;v&amp;lt;G.vernum;&amp;#43;&amp;#43;v)\t\t\t\t//初始化工作\n\t{\n       final[v]&amp;#61;false;\t\t\t\t\t\t//从起始点到另外点均未找到最短路径 主要是定义一个集合将访问过的点设置值为true  刚开始集合为空\n       D[v]&amp;#61;G.arcs[i][v];\t\t\t\t\t//从其余点到起始点距离(记录是最短距离  到起始点)\n \n\t}\n\tD[i]&amp;#61;0;final[i]&amp;#61;true;\t\t\t\t\t//起始点到起始点距离为0 起始点设置为已经访问过\n\tP[sub]&amp;#61;-1;\n \n\t\n\tfor(int out&amp;#61;1;out&amp;lt;G.vernum;out&amp;#43;&amp;#43;)\t\t//最多扩充n-1个点到已经访问过的点集\n\t{\n       min&amp;#61;MAXINT;\n\t   for(int w&amp;#61;0;w&amp;lt;G.vernum;w&amp;#43;&amp;#43;)\t\t\t// 在当前未选择点集中选估计距离最小的顶点k\n\t   {\n\t\t   if(!final[w])\n\t\t\t   if(D[w]&amp;lt;min) { q&amp;#61;w; min&amp;#61;D[w]; }\t\t\t   \t\t\t   \n\t   }\n\t   final[q]&amp;#61;true;\t\t\t\t\t\t//将最小距离点加入到已经访问过点集中\n       P[q]&amp;#61;sub;\n\t   for( w&amp;#61;0;lujing[q][w]!&amp;#61;NULL;w&amp;#43;&amp;#43;){}\n\t   lujing[q][w]&amp;#61;q;\t\t\t\t  \t\t   \t   \n\t   for(int m&amp;#61;0;m&amp;lt;G.vernum;m&amp;#43;&amp;#43;)\t\t\t//调整剩余点到起始点的估计距离\n\t   {\n\t\t   if(!final[m]&amp;amp;&amp;amp;(min&amp;#43;G.arcs[q][m]&amp;lt;D[m]))\n\t\t   {\n\t\t\t   D[m]&amp;#61;min&amp;#43;G.arcs[q][m];sub&amp;#61;q;\n\t\t\t   P[m]&amp;#61;sub;\n\t\t       for( w&amp;#61;0;lujing[q][w]!&amp;#61;NULL ;w&amp;#43;&amp;#43;)\n\t\t\t\t   lujing[m][w]&amp;#61;lujing[q][w];\n\t\t\t   for(;lujing[m][w]!&amp;#61;NULL;w&amp;#43;&amp;#43;)\n\t\t\t\t   lujing[m][w]&amp;#61;NULL;\n\t\t   }\n\t   }\n\t   if(q&amp;#61;&amp;#61;j)\n\t   {\n\t\t   printf(&amp;#34;最短路径为%d\\n&amp;#34;,D[j]);\n\t\t   printf(&amp;#34;依次经过景区为:&amp;#34;);\n\t\t\t\tprintf(&amp;#34;%c   &amp;#34;,value1);\n\t\t\t   for (int c&amp;#61;0;lujing[j][c]!&amp;#61;NULL;c&amp;#43;&amp;#43;)\n\t\t\t   {\n \n\t\t\t\t   printf(&amp;#34;%c   &amp;#34;,G.verx[lujing[j][c]].mask);\n\t\t\t   }\n\t   }\n\t}\n \n return 0;\t\n}\n \n \n \n \nint main()\n{\n\tMGraph G;\n\tint v&amp;#61;0;\n\tint alter;\n\tprintf(&amp;#34;请先输入建立校园图所需要的信息&amp;#xff1a;\\n\\n&amp;#34;);\n\tif(createUDN(G,v))\t\t\t\t\t\t//创建无向网\n\t{\n\t\t do\n\t\t {\n\t\t\t printf(&amp;#34;\\n\\n查询某个景点信息请输入1\\n&amp;#34;);\n\t\t\t printf(&amp;#34;查询两个景点之间最短距离请输入2\\n&amp;#34;);\n\t\t\t printf(&amp;#34;退出请输入0\\n&amp;#34;);\n\t\t\t scanf(&amp;#34;%d&amp;#34;,&amp;amp;alter);\n\t\t\t fflush(stdin);\n\t\t\t switch(alter)\n\t\t\t {\n\t\t\t\t case 0:return 0; break;\n\t\t\t\t case 1: message(G);break;\n\t\t\t\t case 2:search(G);break;\t\n\t\t\t }\n\t\t}while(alter);\n\t}\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["图（导游图）的创建---------", ["制作陶瓷学院的校园导游图，游客通过终端可询问： （1）从某一景点到另一景点的最短路径。 （2）游客从公园进入，选取一条最佳路线3，使游客可以不重复地游览各景点，最后回到出口（出口就在入口处旁边） 2、要求 （1）将导游图看作一张带权无向图，顶点表示公园的各个景点，边表示各景点之间的道路，边上的权值表示距离。为此图选择适当的数据结构。 （2）把各种路径都显示给游客，由游客自己选择游览路线。 （3）画出景点分布图于屏幕上。 3、实现提示 （1）第一实际是最短路径问题，如果有几条路径长度相同，可选择途径景点较少的路径提供给游客。 （2）第二问可采用深度优先搜索，如果有多种路径可选择，则选择带权路径最小的路线提供给游客。    "]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ans[&lt;span class=\"hljs-number\"&gt;21&lt;/span&gt;];      &lt;span class=\"hljs-comment\"&gt;//用于存放答案&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, total;    &lt;span class=\"hljs-comment\"&gt;//总方案数&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;pr&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d)&lt;/span&gt;&lt;/span&gt;{   &lt;span class=\"hljs-comment\"&gt;//按照要求打印答案&lt;/span&gt;\n    total&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;lt;&amp;#61;d&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)cout&amp;lt;&amp;lt;ans[i]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;ans[d]&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dep, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rest)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(rest&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dep&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;){   &lt;span class=\"hljs-comment\"&gt;//避免单独值的出现&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;pr&lt;/span&gt;(dep&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;ans[dep&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;]; i&amp;lt;&amp;#61;rest; i&amp;#43;&amp;#43;){\n        ans[dep]&amp;#61;i;\n        &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(dep&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, rest-i);\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    cin&amp;gt;&amp;gt;n;\n    ans[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//初始化拆&amp;#xff0c;18行循环语句的初始值&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, n);\n    &lt;span class=\"hljs-comment\"&gt;//cout&amp;lt;&amp;lt;total;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["请问谁能告诉我这道题的思路c++", ["\n", "\n  ", "自然数拆分 - 题库 - 计蒜客", "\n  ", "题号：T1248；知识点：深度优先搜索；难度：普及T2；对于任意大于 $1$ 的自然数 $n$，总是可以拆分成若干个小于 $n$ 的自然数之和。现请你编写程序求出 $n$ 的所有拆分。输入格式输入文件共一行，包含一个自然数，即要拆分的自然数 $n(1 \\le n \\le 20)$。输出格式输出文件", "\n  ", "\n  ", "\n    ", "\n      ", "https://nanti.jisuanke.com/t/T1248", "\n    ", "\n  "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;它之前的表达是没错的&amp;#xff0c;就像事件A&amp;#61;“今天会下雨” &amp;#xff0c;事件B&amp;#61;“明天会下雨”&amp;#xff0c;虽然A or B表示今天或明天下雨即今明两天至少1天下雨。&lt;br /&gt;如果加个not即 not (A or B) 就表示“今明两天至少1天下雨”的反面事件-------也就是今明两天都不下雨。可以理解成not (A or B)&amp;#61;(not A) and (not B)&lt;br /&gt;所以它原来的not (left or right)&amp;#61;(not left) and (not right) 即左空且右空&amp;#xff0c;即左右都空&amp;#xff0c;它原来的注释正确。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["对称二叉树Python解法", ["# 深度优先搜索\n", "class", " Solution:\n    def is", "Symmetric(", "self", ", ", "root", ": Optional[TreeNode])", " -> ", "bool", ":\n        ", "if", " not root: # 空树\n            return True\n        def ", "DFS(", "left", ", ", "right", ")", ":\n            ", "if", " not (left ", "or", " right): # 左右子树，都为空\n                return True\n            ", "if", " not (left ", "and", " right): # 左右子树，一边为空\n                return False\n            ", "if", " left.", "val", " != right.", "val", ":\n                return False\n            return ", "DFS(", "left", ".", "left", ", ", "right", ".", "right", ")", " ", "and", " ", "DFS(", "left", ".", "right", ", ", "right", ".", "left", ")", "\n        return ", "DFS(", "root", ".", "left", ", ", "root", ".", "right", ")", "\n\n", "\n", "第五行和第七行我在想and和or是不是弄反了", "还有对left和right有点疑问 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;没区别&amp;#xff0c;只是第二种逻辑更清晰一点&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["搜索与回溯算法模板区别", ["以下两种搜索与回溯的算法模板，哪一个更好更通用，有什么区别？", "\n", "算法模板1：", "\n", "int", " ", "search", "(", "int", " ", "k", "){\n         ", "for", "(", "int", " ", "i", "=", "0", ";", "i", "<", "max", "(可能数);", "i", "++){\n              ", "if", "(满足可被继续搜索的条件){\n                       保存结果，标记该点为已搜索\n                       ", "if", "(到达目的地) 输出解\n                       ", "else", " ", "search", "(", "k", "+", "1", ")", "//搜索下一步", "\n                       回溯一步，恢复现场\n               }\n        }\n}", "\n", "\n", "算法模板2：", "\n", "int", " ", "search", "(", "int", " ", "k", "){\n       ", "if", "(到达目的地) 输出解并返回\n       ", "for", "(", "int", " ", "i", "=", "0", ";", "i", "<", "max", "(可能数);", "i", "++){\n              ", "if", "(满足可被继续搜索的条件){\n                       保存结果，标记该点为已搜索\n                       ", "search", "(", "k", "+", "1", ")", "//搜索下一步", "\n                       回溯一步，恢复现场\n               }\n        }\n}", "\n", "\n", "最初觉得没有区别", "，但这个题目  马走日", "马在中国象棋以日字形规则移动。", "请编写一段程序，给定n*m大小的棋盘，以及马的初始位置（x,y),要求不能重复经过棋盘上的同一个点，计算马可以有多少途径遍历棋盘上的所有点。", "输入：", "第一行为整数T(T<10),表示测试数据组数。", "每一组测试数据包含一行，为四个整数，分别为棋盘的大小以及初始位置坐标n,m,x,y.(0<=x<=n-1,0<=y<=m-1,m<10,n<10)", "输出：", "每组测试数据包含一行，为一个整数，表示马能遍历棋盘的途径总数，0为无法遍历一次．", "样例输入：", "1", "5 4 0 0", "样例输出：", "32", "所有解答都是用第二个模板，如果用第一个模板，怎么改！如果改不了，那第一种模板存在的意义是什么，有什么题必须用第一种模板么？多谢各位"]], "Tag": "算法设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;有帮助的话&amp;#xff0c;希望能够采纳支持一下&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n-*- coding:utf-8 -*-\nAuthor&amp;#xff1a;yang-roc\nQQ:327844461\nEmail&amp;#xff1a;aida_pc&amp;#64;qq.com\nTime: 2021-07-30\n&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;testMedium200&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;# dfs  deep-first search  树分支深度优先搜索&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, grid, r, c&lt;/span&gt;):\n        grid[r][c] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        nr, nc &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid), &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; x, y &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; [(r - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, c), (r &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, c), (r, c - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (r, c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]:\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; x &amp;lt; nr &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; y &amp;lt; nc &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; grid[x][y] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:\n                self.dfs(grid, x, y)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;numIslands&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, grid&lt;/span&gt;):  &lt;span class=\"hljs-comment\"&gt;# grid: List[List(str)] #集合字符串最后以集合的方式接受输出打印&lt;/span&gt;\n        nr &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; nr &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        nc &amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(grid[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])\n        num_islands &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; r &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(nr):\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; c &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(nc):\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; grid[r][c] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:\n                    num_islands &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n                    self.dfs(grid, r, c)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; num_islands\n\n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; __name__ &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:\n    t &amp;#61; testMedium200()\n    &lt;span class=\"hljs-comment\"&gt;# 示例①&lt;/span&gt;\n    grid1 &amp;#61; [\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;]\n    ]\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(t.numIslands(grid1))\n    &lt;span class=\"hljs-comment\"&gt;# 示例②&lt;/span&gt;\n    grid2 &amp;#61; [\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;],\n        [&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;]\n    ]\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(t.numIslands(grid2))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt; 程序运行截图&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/290125975726130.png\" /&gt;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["leetcode200题 dfs怎么打印呀，不会打印", ["\n", "\n", "\n", "class", " ", "testMedium200", ":      ", "#dfs  deep-first search  树分支深度优先搜索", "\n    ", "def", " ", "dfs", "(", "self, grid, r, c", "):\n        grid[r][c] = ", "0", "\n        nr, nc = ", "len", "(grid), ", "len", "(grid[", "0", "])\n        ", "for", " x, y ", "in", " [(r-", "1", ",c),(r+", "1", ", c), (r, c-", "1", "), (r, c+", "1", ")]:\n            ", "if", " ", "0", " <= x < nr ", "and", " ", "0", " <= y <nc ", "and", " grid[x][y] == ", "'1'", ":\n                self.dfs(grid, x, y)\n\n\n    ", "def", " ", "numIslands", "(", "self, grid", "): ", "#grid: List[List(str)] #集合字符串最后以集合的方式接受输出打印", "\n        nr = ", "len", "(grid)\n        ", "if", " nr == ", "0", ":\n            ", "return", " ", "0", "\n        nc = ", "len", "(grid[", "0", "])\n\n        num_islands = ", "0", "\n        ", "for", " r ", "in", " ", "range", "(nr):\n            ", "for", " c ", "in", " ", "range", "(nc):\n                ", "if", " grid[r][c] == ", "'1'", ":\n                    num_islands += ", "1", "\n                    self.dfs(grid, r , c)\n\n        ", "return", " num_islands\n\n    grid = [  [", "\"1\"", ",", "\"1\"", ",", "\"1\"", ",", "\"1\"", ",", "\"0\"", "],  [", "\"1\"", ",", "\"1\"", ",", "\"0\"", ",", "\"1\"", ",", "\"0\"", "],[", "\"1\"", ",", "\"1\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", "],[", "\"0\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", ",", "\"0\"", "\n    ", "if", " __name__ == ", "'__main__'", ":\n     t = testMedium200()\n    target = ", "9", "\n    ", "print", "(t.dfs(grid))\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;不就调用一下方法吗。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define MAXV 1000 //最大顶点数设为1000//&lt;/span&gt;\ntypedef struct { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义结构体类型&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint Visited[MAXV]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;顶点标记&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint Edges[MAXV][MAXV]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;邻接矩阵数组&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint VertexN,EdgeN; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;顶点和边数&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}Graph; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用邻接矩阵存储的图结构体&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n\nvoid InitializeG(Graph*G)\n{ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;图的初始化&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint i,j;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;MAXV;i&amp;#43;&amp;#43;)\n{\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;MAXV;j&amp;#43;&amp;#43;)\nG-&amp;gt;Edges[i][j]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\nG-&amp;gt;Visited[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\nG-&amp;gt;VertexN&amp;#61;G-&amp;gt;EdgeN&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\nvoid ReadG(Graph*G) &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;读入并存储一个图&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n{\nint i,V1,V2;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;G-&amp;gt;VertexN,&amp;amp;G-&amp;gt;EdgeN); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用户输入顶点数和边数&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;G-&amp;gt;EdgeN;i&amp;#43;&amp;#43;)\n{\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;V1,&amp;amp;V2); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入顶点名称&amp;#xff0c;比坐标大&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#xff08;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;到N&amp;#xff09;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nG-&amp;gt;Edges[V1-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][V2-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;G-&amp;gt;Edges[V2-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][V1-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n}\n\nvoid DFS(Graph*G,int V)\n{ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;图G的深度优先搜索&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint W;\nG-&amp;gt;Visited[V]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将访问到的结点进行标记&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(W&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;G-&amp;gt;VertexN;W&amp;#43;&amp;#43;)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G-&amp;gt;Edges[V][W]&amp;amp;&amp;amp;!G-&amp;gt;Visited[W])\nDFS(G,W);\n}\n\nint CheckG(Graph*G)\n{ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;检查边的度是否全为偶数&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\nint r,i,j;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;G-&amp;gt;VertexN;i&amp;#43;&amp;#43;)\n{\nr&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;G-&amp;gt;VertexN;j&amp;#43;&amp;#43;)\nr&amp;#43;&amp;#61;G-&amp;gt;Edges[i][j];\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r%&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;发现奇数度的边则返回&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}\nreturn &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;全是偶数度的边则返回&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}\n\nint main()\n{\nGraph *G&amp;#61;(Graph*)malloc(sizeof(Graph));\nInitializeG(G);\nReadG(G);\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,CheckG(G));\nreturn &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["七巧问题 c语言程序已给出 mian函数问号处该怎么写呢", ["#include<stdio.h>", "#include<stdlib.h>", "#define MAXV 1000                                           /", "最大顶点数设为1000", "/", "typedef struct {                                            /", "定义结构体类型", "/", "    int Visited[MAXV];                                      /", "顶点标记", "/", "    int Edges[MAXV][MAXV];                                  /", "邻接矩阵数组", "/", "    int VertexN,EdgeN;                                      /", "顶点和边数", "/", "}Graph;                                                     /", "用邻接矩阵存储的图结构体", "/ ", "\n", "void InitializeG(Graph*G)", "{                                                           /", "图的初始化", "/", "    int i,j;", "    for(i=0;i<MAXV;i++)", "    {", "        for(j=0;j<MAXV;j++)", "             G->Edges[i][j]=0;", "             G->Visited[i]=0;", "    }", "    G->VertexN=G->EdgeN=0;", "}                                                           ", "\n", "void ReadG(Graph*G)                                         /", "读入并存储一个图", "/", "{", "    int i,V1,V2;", "    scanf(\"%d%d\",&G->VertexN,&G->EdgeN);                    /", "用户输入顶点数和边数", "/", "    for(i=0;i", "EdgeN;i++)", "    {", "        scanf(\"%d%d\",&V1,&V2);                              /", "输入顶点名称，比坐标大1（1到N）", "/", "        G->Edges[V1-1][V2-1]=G->Edges[V2-1][V1-1]=1;", "    }", "}", "\n", "void DFS(Graph*G,int V)", "{                                                           /", "图G的深度优先搜索", "/", "    int W;", "    G->Visited[V]=1;                                        /", "将访问到的结点进行标记", "/", "    for(W=0;W", "VertexN;W++)", "         if (G->Edges[V][W]&&!G->Visited[W])", "         DFS(G,W);", "}", "\n", "int CheckG(Graph*G)", "{                                                           /", "检查边的度是否全为偶数", "/", "    int r,i,j;", "    for(i=0;i", "VertexN;i++)", "    {", "        r=0;", "        for(j=0;j", "VertexN;j++)", "             r+=G->Edges[i][j];", "        if (r%2) return 0;                                  /", "发现奇数度的边则返回0", "/", "    }", "    return 1;                                               /", "全是偶数度的边则返回1", "/", "}", "\n", "int main()", "{", "    int i;", "    Graph", "G=(Graph", ")malloc(sizeof(Graph));", "    ？", "    return 0;", "}", "注：（1）", "输入说明：输入的第1行包含两个正整数，分别为结点数N(1<N<1000)和", "边数M。随后的M行对应M条边，每行给出一对正整数，分别是该条边连", "通的两个结点的编号（结点从1到N编号）。", "（2）", "输出说明：若欧拉回路存在则输出1，否则输出0。", "（3）", "测试实例：", "1）输入：", "6 10", "1 2", "2 3", "3 1", "4 5", "5 6", "6 4", "1 4", "1 6", "3 4", "3 6", "输出：1", "(说明：存在欧拉回路)", "２）输入：", "5 8", "1 2", "1 3", "2 3", "2 4", "2 5", "5 3", "5 4", "3 4", "输出：0", "（说明：不存在欧拉回路）"]], "Tag": "算法设计"}
{"Answer": "你的代码直接把我的Eclipse给卡顿了，停止按钮都没有效果了。\r\n参考个正确版本的吧，绝对秒出结果，只需修正打印语句末尾改为\"\\n\"打印换行即可。\r\nhttp://blog.csdn.net/zhong317/article/details/4586131", "Konwledge_Point": "图的深度优先搜索", "Question": ["(已解决)自己用java写的八皇后问题算法，可是不行,求告知原因", ["\npublic class Test {\n\n    public static void main(String[] args) {\n        Empress a=new Empress();\n        a.find(0,0);\n        System.out.println(a.map);\n    }\n}\n\nclass Empress{\n    public int[][] arry=new int[8][8];\n    public  int map=0;\n\n    public   boolean rule(int arry[][],int k,int j){    //判断节点是否合适\n        for(int i=0;i<8;i++){   //行列冲突\n            if(arry[k][i]==1)\n                return false;\n            else if(arry[i][j]==1)\n                return false;\n        }\n        for(int i=k-1,m=j-1;i>=0&&m>=0;i--,m--){    //左对角线\n            if(arry[i][m]==1)\n                return false;\n        }\n        for(int i=k-1,m=j+1;i>=0&&m<=7;i--,m++){    //右对角线\n            if(arry[i][m]==1)\n                return false;\n        }\n        return true;\n    }\n\n\n    public void find(int i,int m){  //寻找皇后节点\n        if(i>7){    //皇后解 \n            map++;\n        }else{\n            for(int j=i+1;j<8;j++){     //刷新当前结点下的数组\n                for(int k=0;k<8;k++){\n                    arry[j][k]=0;\n                }\n            }\n            for(;i<8;i++){      //深度优先搜索\n                for(;m<8;m++){\n                    if(rule(arry,i,m)){\n                        arry[i][m]=1;\n                        find(i+1,0);\n                    }\n                }\n            }\n        }\n    }\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你说的是可以的&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["结构体指针与结构体？", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "#", "include", "<string.h>", "\n\n", "#", "define", " MAX 100", "\n", "#", "define", " LENGTH(a) (sizeof(a)/sizeof(a[0]))", "\n\n", "//邻接表中标对应的链表的结点", "\n", "typedef", " ", "struct", " ", "_ENode", "\n{\n    ", "int", " ivex;                   ", "// 该边所指向的顶点的位置,是数组的下标", "\n    ", "struct", " ", "_ENode", "* next_edge;   ", "// 指向下一条弧的指针", "\n}ENode,*PENode;\n\n", "//邻接表中的表的顶点", "\n", "typedef", " ", "struct", " ", "_VNode", "\n{\n    ", "char", " data;              ", "// 顶点信息", "\n    ENode* first_edge;      ", "// 指向第一条依附该顶点的弧", "\n}VNode;\n\n", "//邻接表", "\n", "typedef", " ", "struct", " ", "_LGraph", "\n{\n    ", "int", " vexnum;            ", "// 图的顶点的数目", "\n    ", "int", " edgnum;            ", "// 图的边的数目", "\n    VNode vexs[MAX];\n}LGraph;\n\n", "//返回ch在matrix矩阵中的位置", "\n", "static", " ", "int", " ", "get_position", "(LGraph g, ", "char", " ch)", "    ", "//为什么用static？", "\n", "{\n    ", "int", " i;\n    ", "for", " (i = ", "0", "; i < g.vexnum; i++)\n        ", "if", " (g.vexs[i].data == ch)\n            ", "return", " i;\n    ", "return", " ", "-1", ";\n}\n", "//将node链接到list的末尾", "\n", "static", " ", "void", " ", "link_last", "(ENode* list, PENode node)", "\n", "{\n    PENode p = list;\n    ", "while", " (p->next_edge)\n        p = p->next_edge;\n    p->next_edge = node;\n}\n", "//打印邻接表图", "\n", "void", " ", "print_lgraph", "(LGraph G)", "\n", "{\n    ", "int", " i;\n    PENode node;\n\n    ", "printf", "(", "\"List Graph:\\n\"", ");\n    ", "for", " (i = ", "0", "; i < G.vexnum; i++)  ", "//遍历所有的顶点", "\n    {\n        ", "printf", "(", "\"%d(%c): \"", ", i, G.vexs[i].data);\n        node = G.vexs[i].first_edge;\n        ", "while", " (node != ", "NULL", ")  ", "//把每个顶点周围的结点都输出一下", "\n        {\n            ", "printf", "(", "\"%d(%c) \"", ", node->ivex, G.vexs[node->ivex].data);\n            node = node->next_edge;\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n}\n\n", "//创建邻接表对应的图(用已提供的数据)，无向图", "\n", "LGraph* ", "create_example_lgraph", "()", "\n", "{\n    ", "char", " c1, c2;\n    ", "char", " vexs[] = { ", "'A'", ", ", "'B'", ", ", "'C'", ", ", "'D'", ", ", "'E'", ", ", "'F'", ", ", "'G'", " };\n    ", "char", " edges[][", "2", "] = {\n        {", "'A'", ", ", "'C'", "},\n        {", "'A'", ", ", "'D'", "},\n        {", "'A'", ", ", "'F'", "},\n        {", "'B'", ", ", "'C'", "},\n        {", "'C'", ", ", "'D'", "},\n        {", "'E'", ", ", "'G'", "},\n        {", "'F'", ", ", "'G'", "} };\n    ", "int", " vlen = ", "LENGTH", "(vexs);\n    ", "int", " elen = ", "LENGTH", "(edges);\n    ", "//上面类似一个邻接矩阵存储", "\n    ", "int", " pos1, pos2;\n    ENode* node1, * node2;      ", "//无向图，一条边两个对应关系", "\n    LGraph* pG;                 ", "//pG表示图", "\n\n    ", "if", " ((pG = (LGraph*)", "malloc", "(", "sizeof", "(_LGraph))) == ", "NULL", ")   ", "///////", "\n        ", "//若硬件没有内存申请失败", "\n        ", "return", " ", "NULL", ";\n    ", "memset", "(pG, ", "0", ", ", "sizeof", "(LGraph));", "//就是把申请的空间内初始化为0", "\n\n    ", "// 初始化\"顶点数\"和\"边数\"", "\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    ", "// 初始化\"邻接表\"的顶点", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = ", "NULL", ";\n    }\n\n    ", "// 初始化\"邻接表\"的边", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        ", "// 读取边的起始顶点和结束顶点", "\n        c1 = edges[i][", "0", "];\n        c2 = edges[i][", "1", "];\n\n        pos1 = ", "get_position", "(*pG, c1);        ", "//pos1对应起始顶点下标位置", "\n        pos2 = ", "get_position", "(*pG, c2);        ", "//pos2对应结束顶点下标位置", "\n                                             ", "//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以", "\n        ", "// 初始化node1", "\n        node1 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node1->ivex = pos2;\n        ", "// 将node1链接到\"p1所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos1].first_edge == ", "NULL", ")\n            pG->vexs[pos1].first_edge = node1;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos1].first_edge, node1);\n       \n        ", "// 初始化node2", "\n        node2 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node2->ivex = pos1;\n        ", "// 将node2链接到\"p2所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos2].first_edge == ", "NULL", ")\n            pG->vexs[pos2].first_edge = node2;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos2].first_edge, node2);\n    }\n}\n\n", "//创建邻接表对应的图(用已提供的数据)，有向图", "\n", "LGraph* ", "create_example_lgraph_directed", "()", "\n", "{\n    ", "char", " c1, c2;\n    ", "char", " vexs[] = { ", "'A'", ", ", "'B'", ", ", "'C'", ", ", "'D'", ", ", "'E'", ", ", "'F'", ", ", "'G'", " };\n    ", "char", " edges[][", "2", "] = {\n        {", "'A'", ", ", "'C'", "},\n        {", "'A'", ", ", "'D'", "},\n        {", "'A'", ", ", "'F'", "},\n        {", "'B'", ", ", "'C'", "},\n        {", "'C'", ", ", "'D'", "},\n        {", "'E'", ", ", "'G'", "},\n        {", "'F'", ", ", "'G'", "} };\n    ", "int", " vlen = ", "LENGTH", "(vexs);\n    ", "int", " elen = ", "LENGTH", "(edges);\n    ", "//上面类似一个邻接矩阵存储", "\n    ", "int", " pos1, pos2;\n    ENode* node1, * node2;      ", "//无向图，一条边两个对应关系", "\n    LGraph* pG;                 ", "//pG表示图", "\n\n    ", "if", " ((pG = (LGraph*)", "malloc", "(", "sizeof", "(_LGraph))) == ", "NULL", ")   ", "///////", "\n        ", "//若硬件没有内存申请失败", "\n        ", "return", " ", "NULL", ";\n    ", "memset", "(pG, ", "0", ", ", "sizeof", "(LGraph));", "//就是把申请的空间内初始化为0", "\n\n    ", "// 初始化\"顶点数\"和\"边数\"", "\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    ", "// 初始化\"邻接表\"的顶点", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = ", "NULL", ";\n    }\n\n    ", "// 初始化\"邻接表\"的边", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        ", "// 读取边的起始顶点和结束顶点", "\n        c1 = edges[i][", "0", "];\n        c2 = edges[i][", "1", "];\n\n        pos1 = ", "get_position", "(*pG, c1);        ", "//pos1对应起始顶点下标位置", "\n        pos2 = ", "get_position", "(*pG, c2);        ", "//pos2对应结束顶点下标位置", "\n                                             ", "//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以", "\n        ", "// 初始化node1", "\n        node1 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node1->ivex = pos2;\n        ", "// 将node1链接到\"p1所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos1].first_edge == ", "NULL", ")\n            pG->vexs[pos1].first_edge = node1;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos1].first_edge, node1);\n    }\n}\n\n", "//深度优先搜索遍历图的递归实现", "\n", "static", " ", "void", " ", "DFS", "(LGraph G, ", "int", " i, ", "int", " visited[])", "\n", "{\n    ", "printf", "(", "\"%c \"", ", G.vexs[i].data);\n    visited[i] = ", "1", ";\n    ENode* node;\n    node = G.vexs[i].first_edge;\n    ", "while", " (node !=", "NULL", ")\n    {\n        ", "if", " (!visited[node->ivex])", "//只要对应顶点没有访问过，深入到下一个顶点访问", "\n            ", "DFS", "(G, node->ivex, visited);\n        node = node->next_edge;", "//某个顶点的下一条边，例如B结点的下一条边", "\n    }\n}\n\n", "//深度优先搜索遍历图", "\n", "void", " ", "DFSTraverse", "(LGraph G)", "\n", "{\n    ", "int", " visited[MAX];       ", "// 顶点访问标记", "\n    ", "//初始化所有顶点都没有被访问", "\n    ", "memset", "(visited, ", "0", ", ", "sizeof", "(visited));\n   ", "/* for (int i = 0; i < G.vexnum; i++)\n        visited[i] = 0;*/", "\n    ", "printf", "(", "\"DFS:\"", ");\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    {\n        ", "if", " (!visited[i])\n            ", "DFS", "(G, i, visited);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n", "int", " ", "main", "()", "\n", "{\n    LGraph* pG;\n    pG = ", "create_example_lgraph_directed", "();\n    ", "print_lgraph", "(*pG);\n    ", "DFSTraverse", "(*pG);\n}\n", "\n", "请问定义函数时 比如static void DFS(LGraph G, int i, int visited[])", "为什么用LGraph呢 是不是把结构体指针当做参数传入也可以呀 就是后面的访问要变成-> 了"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;v[i][k]&amp;#61;&amp;#61;1;&lt;br /&gt;改成&lt;br /&gt;v[i][k]&amp;#61;1;&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["NOI / 2.5基本算法之搜索-1818：红与黑", ["题目链接：", "http://noi.openjudge.cn/ch0205/solution/34697319/", "描述", "有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。", "\n", "输入", "包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下", "1）‘.’黑色的瓷砖；", "2）‘#’红色的瓷砖；", "3）‘", "@’黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。", "当在一行中读入的是两个零时，表示输入结束。", "输出", "对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。", "\n", "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,v[", "25", "][", "25", "],dx[", "4", "]={", "1", ",", "-1", ",", "0", ",", "0", "},dy[", "4", "]={", "0", ",", "0", ",", "1", ",", "-1", "},t=", "0", ";\nchar a[", "25", "][", "25", "];\nint dfs(int x,int y)\n{\n    int i,tx,ty;\n    for(i=", "0", ";i<", "4", ";i++)\n    {\n        tx=dx[i]+x;\n        ty=dy[i]+y;\n        if(tx>", "0", "&&tx<=n&&ty>", "0", "&&ty<=m&&v[tx][ty]==", "0", "&&a[tx][ty]!=", "'#'", ")\n        {\n            v[tx][ty]=", "1", ";\n            t++;\n            dfs(tx,ty);\n        }\n    }\n} \nint main()\n{\n    int i,k,x,y;\n    while(", "1", ")\n    {\n        cin>>m>>n;\n        memset(v,", "0", ",sizeof(v));\n        t=", "0", ";\n        if(m==", "0", "&&n==", "0", ")\n        return ", "0", ";\n        for(i=", "1", ";i<=n;i++)\n        {\n            for(k=", "1", ";k<=m;k++)\n            {\n                cin>>a[i][k];\n                if(a[i][k]==", "'@'", ")\n                {\n                    v[i][k]==", "1", ";\n                    x=i,y=k;\n                }\n            }\n        }\n        dfs(x,y);\n        cout<<t<<endl;\n        \n    }\n    return ", "0", ";\n}\n\n", "\n", "运行结果：Runtime Error"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;DFS&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;vector&amp;gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; MyGraph\n{\nprotected:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; vertexNum;&lt;span class=\"hljs-comment\"&gt;//顶点数量&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;** matrix;&lt;span class=\"hljs-comment\"&gt;//邻接矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;* visitedFlag;&lt;span class=\"hljs-comment\"&gt;//顶点是否访问过的标记&lt;/span&gt;\n    std::vector&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&amp;gt; pathStack;&lt;span class=\"hljs-comment\"&gt;//记录路径的栈&lt;/span&gt;\npublic:\n    &lt;span class=\"hljs-constructor\"&gt;MyGraph(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; VertexNum)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;;\n    void print&lt;span class=\"hljs-constructor\"&gt;Matrix()&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//输出邻接矩阵&lt;/span&gt;\n    void update&lt;span class=\"hljs-constructor\"&gt;Matrix(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//更新row行column列的邻接矩阵值&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;MatrixValue(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//获取邻接矩阵中对应行列号的值&lt;/span&gt;\n    void get&lt;span class=\"hljs-constructor\"&gt;PathofTwoNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//计算两个节点之间的所有路径&lt;/span&gt;\n    void find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;\n    ~&lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;MyGraph.h&amp;#34;&lt;/span&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\nusing namespace std;\n \nMyGraph::&lt;span class=\"hljs-constructor\"&gt;MyGraph(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; VertexNum)&lt;/span&gt;\n{\n    this-&amp;gt;vertexNum &amp;#61; VertexNum;\n    &lt;span class=\"hljs-comment\"&gt;//开辟访问标记数组&lt;/span&gt;\n    this-&amp;gt;visitedFlag &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//开辟邻接矩阵&lt;/span&gt;\n    this-&amp;gt;matrix &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;*&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;vertexNum;i&amp;#43;&amp;#43;)\n    {\n        this-&amp;gt;visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//将所有数组元素全部初始化为0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;vertexNum;j&amp;#43;&amp;#43;)\n            this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 无参数构造函数&amp;#xff0c;通过createTestData函数来构造一个邻接矩阵测试数据\n * 方便其他算法的测试\n */&lt;/span&gt;\nMyGraph::&lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;\n{\n    this-&amp;gt;vertexNum &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//开辟访问标记数组&lt;/span&gt;\n    this-&amp;gt;visitedFlag &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//开辟邻接矩阵&lt;/span&gt;\n    this-&amp;gt;matrix &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;*&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;vertexNum; i&amp;#43;&amp;#43;)\n    {\n        this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;vertexNum&lt;/span&gt;]&lt;/span&gt;;\n        this-&amp;gt;visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//将所有数组元素全部初始化为0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;vertexNum; j&amp;#43;&amp;#43;)\n            this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//初始化邻接矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; initMatrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]&lt;/span&gt; &amp;#61; {\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-comment\"&gt;//赋值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; vertexNum; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; vertexNum; j&amp;#43;&amp;#43;)\n            this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; initMatrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;;\n    print&lt;span class=\"hljs-constructor\"&gt;Matrix()&lt;/span&gt;;\n}\n \n \nMyGraph::~&lt;span class=\"hljs-constructor\"&gt;MyGraph()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;vertexNum;i&amp;#43;&amp;#43;)\n        delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;;\n    delete matrix;\n    delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt;visitedFlag;\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 输出邻接矩阵\n */&lt;/span&gt;\nvoid MyGraph::print&lt;span class=\"hljs-constructor\"&gt;Matrix()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;vertexNum;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; vertexNum; j&amp;#43;&amp;#43;)\n            cout &amp;lt;&amp;lt; matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; endl;\n    }\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 更新row行column列的邻接矩阵值\n */&lt;/span&gt;\nvoid MyGraph::update&lt;span class=\"hljs-constructor\"&gt;Matrix(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;//由于是无向图&amp;#xff0c;故更新后的矩阵值是一个对称矩阵&lt;/span&gt;\n    matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;row&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;column&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;column&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;row&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 获取row行column列的邻接矩阵的值\n */&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; MyGraph::get&lt;span class=\"hljs-constructor\"&gt;MatrixValue(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;row&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;column&lt;/span&gt;)&lt;/span&gt;\n{\n    return this-&amp;gt;matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;row&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;column&lt;/span&gt;]&lt;/span&gt;;\n}\n \n&lt;span class=\"hljs-comment\"&gt;/**\n * 计算两个节点之间的所有路径\n */&lt;/span&gt;\nvoid MyGraph::get&lt;span class=\"hljs-constructor\"&gt;PathofTwoNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;//利用深度优先遍历的方式来计算两个节点之间的所有路径&lt;/span&gt;\n    visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;startNode&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    pathStack.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;)&lt;/span&gt;;\n    find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;\n}\n \nvoid MyGraph::find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;startNode&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (startNode&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;endNode)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//找到一条路径&amp;#xff0c;输出路径&lt;/span&gt;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;找到一条路径&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; node : pathStack)\n            cout &amp;lt;&amp;lt; node &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; endl;\n        visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;(&lt;span class=\"hljs-identifier\"&gt;pathStack&lt;/span&gt;.&lt;span class=\"hljs-identifier\"&gt;end&lt;/span&gt;()-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        pathStack.pop&lt;span class=\"hljs-constructor\"&gt;_back()&lt;/span&gt;;\n        return;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-comment\"&gt;//找到startNode所有没有入栈的邻接点&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; unStackedNum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n         &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;vertexNum; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (matrix&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;startNode&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;amp;&amp;amp; &lt;/span&gt;!visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;)\n            {\n                unStackedNum&amp;#43;&amp;#43;;\n                visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n                pathStack.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;)&lt;/span&gt;;\n                find&lt;span class=\"hljs-constructor\"&gt;Path(&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;endNode&lt;/span&gt;)&lt;/span&gt;;\n            }\n        }\n        visitedFlag&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;(&lt;span class=\"hljs-identifier\"&gt;pathStack&lt;/span&gt;.&lt;span class=\"hljs-identifier\"&gt;end&lt;/span&gt;() - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        pathStack.pop&lt;span class=\"hljs-constructor\"&gt;_back()&lt;/span&gt;;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["如何用邻接矩阵存储结构求无向图中两个点的所有路径", ["不是很会代码写的也不对，谢谢看看", "\n", "1", "\n", "\n", "#", "include", " ", "<bits/stdc++.h>", "\n", "#", "define", " Infinity 32766", "\n", "#", "define", " MaxVertexNum 50", "\n", "using", " ", "namespace", " std;   \n\n", "//图的邻接矩阵存储结 AdjacencyMatrixGraph", "\n", "typedef", " ", "struct", " ", "AMGraph", " {\n    ", "char", " vex[MaxVertexNum]; ", "//结点名表 ", "\n    ", "int", " arc[MaxVertexNum][MaxVertexNum]; ", "//边表 ", "\n    ", "int", " vexnum, arcnum; ", "//结点数和边数 ", "\n}AMGraph;\n\n", "int", " ", "FindVex", " ", "(AMGraph G, ", "char", " v)", "\n", "{\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    {\n        ", "if", " (G.vex[i] == v)\n        ", "return", " i;\n    }\n", "return", " ", "-1", ";    \n}\n\n", "//无向图 ", "\n", "void", " ", "GraphCreate", " ", "(AMGraph &G)", "\n", "{\n    ", "//输入结点数，边数，结点序列 ", "\n    cin >> G.vexnum >> G.arcnum;\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n        cin >> G.vex[i];\n    ", "//初始化", "\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    ", "for", " (", "int", " j = ", "0", "; j < G.vexnum; j++)\n    G.arc[i][j] = ", "0", ";    \n    ", "//构造邻接矩阵 ", "\n    ", "char", " v1, v2;\n    ", "for", " (", "int", " k = ", "0", "; k < G.arcnum; k++)\n    {\n        cin >> v1 >> v2;\n        ", "int", " i = ", "FindVex", " (G, v1);\n        ", "int", " j = ", "FindVex", " (G, v2);\n        G.arc[i][j] = G.arc[j][i] = ", "1", ";        \n    }      \n}\n\n", "int", " visited[MaxVertexNum] = {", "0", "};\nvector <", "int", "> v;\n", "//基于DFS查找图中所有路径 ", "\n", "void", " ", "AllPathDFS", " ", "(AMGraph G, ", "int", " StartV, ", "int", " EndV)", "\n", "{\n    visited[StartV] = ", "1", ";\n    v.", "push_back", " (StartV);\n    ", "for", " (", "int", " j = ", "0", "; j < G.vexnum; j++)\n    {\n        ", "if", " (StartV == EndV)\n        {    \n            ", "for", " (", "int", " k = ", "0", "; k < v.", "size", "(); k++)\n            {\n                cout << G.vex[v[k]] << ", "\" \"", ";\n            }\n            ", "puts", " (", "\"\"", "); \n            v.", "pop_back", " ();\n            visited[StartV] = ", "0", ";\n            ", "break", ";\n        }\n        \n        ", "if", " (visited[j] == ", "0", " && G.arc[StartV][j] == ", "1", ")\n           ", "AllPathDFS", " (G, j, EndV);\n        \n    }\n}\n\n", "int", " ", "main", " ", "()", "\n", "{\n    AMGraph G;\n    ", "GraphCreate", " (G);\n    ", "AllPathDFS", " (G, ", "0", ", G.vexnum - ", "1", ");\n", "return", " ", "0", ";\n}\n\n", "\n", "用DFS实现所有路径的查找", "\n", "样例", "4 5", "ABCD", "AB", "AD", "BC", "BD", "CD"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1.由于多少个元素不确定&amp;#xff0c;肯定是要递归的&amp;#xff0c;写死循环不可行&lt;br /&gt;2.不用剪枝&amp;#xff0c;递归的时候传递初始值内层与外层相等即可&amp;#xff0c;这样4只能和4,5,6去加&amp;#xff0c;5只能和5,6,7加&amp;#xff0c;6只能和6,7,8加&amp;#xff0c;不能输入的更小&lt;br /&gt;3.暴力搜索容易超时&amp;#xff0c;你应该判断如果不是最后一层递归&amp;#xff0c;相加的结果已经大于给定的数&amp;#xff0c;就结束本次循环&amp;#xff0c;不要继续了&amp;#xff08;只影响当前的层&amp;#xff0c;返回上一层之后继续外层循环&amp;#xff09;&lt;br /&gt;4.如果是最后一层&amp;#xff0c;不要再循环了&amp;#xff0c;直接用给定的数减去前n-1项的和就是最后一项&amp;#xff0c;为防止最后一项小于倒数第2项&amp;#xff0c;这个条件可以在前面3的时候就过滤掉&amp;#xff0c;不要继续循环了&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["暴搜所有组合应该怎么剪枝? 求思路", ["题目简述", "\n", "要求输出n个正整数，他们的和为s, 每个元素值的范围在[1,m]之内。求输出所有可能的组合结果。", "\n", "输入: n = 2, m = 6, s = 10，下面简述为(n, m, s), 即（2，6，10）", "\n", "输出:", "(4,6)", "(5,5)", "\n", "注意:", "(6,4)属于重复的结果", "\n", "边界约束:", "1 <= n  <= 100", "1 <= m <= 1e9", "1 <= s <=  1e5", "\n", "问题", "\n", "我用dfs暴力搜索 + 剪枝，但是还是通过不过用例。", "(100, 100, 10000)", "(3, 1e5, 20)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;假设bool占用1字节并按1字节对齐&amp;#xff0c;900000005字节/1024/1024/1024&amp;#61;0.8381903218gb&amp;#xff0c;小程序大内存。如果按照4字节对齐&amp;#xff0c;那还真不得了。系统会如何处理我不知道&amp;#xff0c;但是不应该这样写。最后&amp;#xff0c;抱歉&amp;#xff0c;没有看明白题目。&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["在某些情况中，为什么程序突然中断？", ["问题", "【搜索与回溯算法】生成字符串 (Standard IO)", "时间限制: 1000 ms  空间限制: 262144 KB  具体限制  ", "\n", "题目描述：", "假设一个字符串只由字符”0”、”1”、‘", "’组成，其中字符‘", "’表示该字符可由字符”0”或”1”替代。", "\n", "现有一些字符串，根据这些字符串生成所有可生成的字符串。", "\n", "注意后一个例子中”*01”并没有生成新的字符串。", "\n", "输入", "第一行是两个整数M,N（1≤M≤15,0≤N≤2500）。M表示字符串的长度，N表示字符串的个数。", "以下N行每行各有一个字符串。各行的行首、行末没有多余的空格。", "\n", "输出", "一行，为一个整数,Total表示所能生成的字符串的个数。 ", "\n", "样例输入", "2 3", "10", "1", "0", " ", "\n", "样例输出", "4", "\n", "代码：", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\nstring a[", "2505", "];\n", "int", " n,m,t,len,flag;\n", "bool", " visit[", "900000005", "];\n", "void", " ", "dg", "(", "int", " x,", "int", " i)", "\n", "{\n    ", "if", "(x>len)\n    {\n        ", "long", " ", "long", " qn=", "atol", "(a[i].", "c_str", "());\n        ", "if", "(visit[qn]==", "0", ")\n        {\n            t++;\n            visit[qn]=", "1", ";\n            cout<<", "1", ";\n        }\n    }\n    ", "else", "\n    {\n        \n        ", "if", "(a[i][x]==", "'*'", ")\n        {\n            a[i][x]=", "'1'", ";\n            ", "dg", "(x+", "1", ",i);\n            a[i][x]=", "'0'", ";\n            ", "dg", "(x+", "1", ",i);            \n            a[i][x]=", "'*'", ";\n        }\n        ", "else", " ", "dg", "(x+", "1", ",i);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n    cin>>m>>n;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++)\n    {\n        cin>>a[i];    \n        len=a[i].", "size", "();\n        ", "dg", "(", "0", ",i);\n    }\n    cout<<t;\n}\n\n\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你程序中的问题比较多&amp;#xff0c;我修改的地方我使用****************************标识出来了&lt;br /&gt;其中一点&amp;#xff0c;new要和delete配对使用参考&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/allen807733144/article/details/73608938\" id=\"textarea_1648102336770_1648102457970_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/allen807733144/article/details/73608938&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;stack&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-comment\"&gt;//顺序查找&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Sq_Sear(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; n;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//cpu要做两次判断&amp;#xff0c;可做优化&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;key)\n        {\n            return i;\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//改进,增加一个哨兵来减少循环次数&amp;#xff0c;会污染数组&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//int i &amp;#61; n;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//a[0] &amp;#61; key;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//while (a[i] !&amp;#61; key)&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//{&lt;!-- --&gt;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//    i--;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//}&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//return i;&lt;/span&gt;\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//插值查找(按比例查找)&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; bia&lt;span class=\"hljs-constructor\"&gt;_search(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;str&lt;/span&gt;[], &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; low &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, high &amp;#61; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; mid &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (low &amp;lt;&amp;#61; high)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//折半与按比例的优劣&amp;#xff0c;数的值跨度不是很大按比例更好&amp;#xff0c;&lt;/span&gt;\n        mid &amp;#61; low &amp;#43; (key - str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;low&lt;/span&gt;]&lt;/span&gt;)&lt;span class=\"hljs-operator\"&gt; / &lt;/span&gt;(str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;high&lt;/span&gt;]&lt;/span&gt; - str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;low&lt;/span&gt;]&lt;/span&gt;)&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;(high - low);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;key)\n            return mid;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;gt; key)\n            high &amp;#61; mid - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;lt; key)\n            low &amp;#61; mid &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n\n}\n&lt;span class=\"hljs-comment\"&gt;//斐波那契查找&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//1.首先创建斐波那契数组&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//2。找到有序表最大元素&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//3.补齐有序表最大值到最接近斐波那契数组的一个元素&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//4.根据斐波那契的规则对比查找&lt;/span&gt;\n\n\nvoid produce&lt;span class=\"hljs-constructor\"&gt;Fib(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;fib&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;size&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i;\n    fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; i &amp;lt; size; i&amp;#43;&amp;#43;)\n    {\n        fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; &amp;#43; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&lt;/span&gt;;\n    }\n}\n\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;FibonacciSearch(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;data&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;searchValue&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; low &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, high &amp;#61; length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, mid &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;]&lt;/span&gt;;\n    produce&lt;span class=\"hljs-constructor\"&gt;Fib(&lt;span class=\"hljs-params\"&gt;fib&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;)&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//最接近斐波那契的数&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (high &amp;gt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        k&amp;#43;&amp;#43;;\n    }\n\n\n    &lt;span class=\"hljs-comment\"&gt;//补齐有序表&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;* temp;\n    temp &amp;#61; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;fib&lt;/span&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    memcpy(temp, data, length&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;sizeof(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; length; i &amp;lt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        data&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; data&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;high&lt;/span&gt;]&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (low &amp;lt;&amp;#61; high)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (k &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            mid &amp;#61; low &amp;#43; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            mid &amp;#61; low;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;searchValue)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (mid &amp;lt;&amp;#61; length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                return mid;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                return length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n\n\n\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;gt; searchValue)\n        {\n            high &amp;#61; mid - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k &amp;#61; k - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;lt; searchValue)\n        {\n            low &amp;#61; mid &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k &amp;#61; k - &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n    }\n\n    delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; temp;\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n\ntypedef &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode* lchild;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode* rchild;\n    &lt;span class=\"hljs-constructor\"&gt;BiNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;)&lt;/span&gt; :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n\n}BiNode,&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;BiTree;\n\n&lt;span class=\"hljs-comment\"&gt;//二叉查找树&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//T为搜索的树&amp;#xff0c;f为记录父节点的指针&amp;#xff0c;p作为临时指针保存输出&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, BiTree &lt;span class=\"hljs-params\"&gt;f&lt;/span&gt;, BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!T)\n    {\n        *p &amp;#61; f;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        *p &amp;#61; T;\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, T, &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;gt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, T, &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    BiTree f(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n   &lt;span class=\"hljs-comment\"&gt;// BiTree* p(0);****************************&lt;/span&gt;\n   &lt;span class=\"hljs-comment\"&gt;// f &amp;#61; (BiTree)new BiNode(key); p &amp;#61; new BiTree;****************************&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!T)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//*p &amp;#61; f;****************************&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//*p &amp;#61; T;****************************&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;gt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//删除&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//*p搜索位置结点&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//定义两个临时指针&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//三种情况&lt;/span&gt;\n\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Delete(BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//传输的是指针域的地址,直接修改lchild or rchild&lt;/span&gt;\n{\n    BiTree q, s;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((*t)-&amp;gt;lchild&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)&lt;span class=\"hljs-comment\"&gt;//左子树为空&amp;#xff0c;连接右子树&lt;/span&gt;\n    {\n        q &amp;#61; *t;\n        (*t) &amp;#61; (*t)-&amp;gt;lchild;\n        &lt;span class=\"hljs-comment\"&gt;//q &amp;#61; (*t)-&amp;gt;rchild;//连接右子树&amp;#xff0c;直接改变指针&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//(*t)-&amp;gt;data &amp;#61; q-&amp;gt;data;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//(*t)-&amp;gt;rchild &amp;#61; q-&amp;gt;rchild;&lt;/span&gt;\n        delete q;&lt;span class=\"hljs-comment\"&gt;//删除结点所占空间****************************&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((*t)-&amp;gt;rchild&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)&lt;span class=\"hljs-comment\"&gt;//右子树为空&amp;#xff0c;连接左子树&lt;/span&gt;\n    {\n        q &amp;#61; *t;\n        (*t) &amp;#61; (*t)-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//连接左子树&amp;#xff0c;直接改变指针&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//free(q);//删除结点所占空间&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//有两个孩子&lt;/span&gt;\n    {\n        q &amp;#61; (*t);&lt;span class=\"hljs-comment\"&gt;//找到中序遍历时的前驱结点&amp;#xff0c;即孩子结点的右子树最右边的叶子结点&lt;/span&gt;\n        s &amp;#61; (*t)-&amp;gt;lchild;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s-&amp;gt;rchild !&amp;#61; NULL)\n        {\n            q &amp;#61; s;&lt;span class=\"hljs-comment\"&gt;//记录当前结点值&lt;/span&gt;\n            s &amp;#61; s-&amp;gt;rchild;&lt;span class=\"hljs-comment\"&gt;//找到右子树最右边的叶子结点&lt;/span&gt;\n        }\n        (*t)-&amp;gt;data &amp;#61; s-&amp;gt;data;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (q&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;*t)&lt;span class=\"hljs-comment\"&gt;//孩子结点为目标结点&lt;/span&gt;\n        {\n            q-&amp;gt;lchild &amp;#61; s-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//链接&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//存在右子树&lt;/span&gt;\n        {\n            q-&amp;gt;rchild &amp;#61; s-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//目标结点的父亲结点链接孩子结点&lt;/span&gt;\n        }\n\n        delete s;&lt;span class=\"hljs-comment\"&gt;//****************************&lt;/span&gt;\n\n    }\n\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//删除二叉排序树的结点&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//1.判断是否为空树&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//2.搜索判断是否存在&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//3.执行删除函数&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;DelectBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (T&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)\n    {\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n\n    }\n\n\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;Delete(&amp;amp;T)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;DelectBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;DelectBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//插入&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;InsertBST(BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    BiTree p &amp;#61; nullptr, s &amp;#61; nullptr;\n\n\n    &lt;span class=\"hljs-comment\"&gt;//传入临时结点指针p&amp;#xff0c;通过搜索函数返回当前最接近该插入值的一个节点位置&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-constructor\"&gt;SearchBST(&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;T, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, NULL, &amp;amp;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;)\n    {\n        s &amp;#61; (BiTree)&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;BiNode(&lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//修改了一下这里****************************&lt;/span&gt;\n        s-&amp;gt;data &amp;#61; key;\n        s-&amp;gt;lchild &amp;#61; NULL;\n        s-&amp;gt;rchild &amp;#61; NULL;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!p)\n        {\n            *T &amp;#61; s;&lt;span class=\"hljs-comment\"&gt;//此处为插入根节点&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; p-&amp;gt;data)\n        {\n            p-&amp;gt;lchild &amp;#61; s;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            p-&amp;gt;rchild &amp;#61; s;\n        }\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;已存在相同数据&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//遍历&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//遍历迭代&lt;/span&gt;\nvoid depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(BiNode&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;root&lt;/span&gt;)&lt;/span&gt;\n{\n    stack&amp;lt;BiNode*&amp;gt;sta;\n    sta.push(root);\n    BiNode* p;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!sta.empty&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;)\n    {\n\n        p &amp;#61; sta.top&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p !&amp;#61; NULL)\n            cout &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; &lt;span class=\"hljs-character\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n        sta.pop&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;rchild !&amp;#61; NULL)\n            sta.push(p-&amp;gt;rchild);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;lchild !&amp;#61; NULL)&lt;span class=\"hljs-comment\"&gt;//这里等符号写错了&lt;/span&gt;\n            sta.push(p-&amp;gt;lchild);\n\n    }\n    cout &amp;lt;&amp;lt; endl;\n}\n\n\n\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main(void)\n{\n    &lt;span class=\"hljs-comment\"&gt;//int data[] &amp;#61; { 1,2,3,4,5,6,7,8,9,10 };&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//int len &amp;#61; sizeof(data) / sizeof(data[0]);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//int index &amp;#61; FibonacciSearch(data,len,5);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; index;&lt;/span&gt;\n    BiTree T &amp;#61; &lt;span class=\"hljs-constructor\"&gt;BiTree(0)&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 1)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 2)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 3)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 5)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 7)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 8)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 12)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 11)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 21)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 31)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 51)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 17)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 18)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 121)&lt;/span&gt;;\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(T, 3)&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;DelectBST(T, 12)&lt;/span&gt;;\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["二叉查找树的操作，删除节点的指针和内存释放问题", ["学习删除二叉排序树时遇到的问题，在删除结点时遇到问题，如下，注释的是我自己的想法，原本的内容是看小甲鱼的视频弄的，但感觉不太对，找了不少博客还是没解决问题", "\n", "运行结果及报错内容", "\n", "问题", "每种情况的free（p），都会报错，没搞明白。", "到底为啥？", "\n", "\nbool Delete(BiTree* t)", "//", "传输的是指针域的地址,直接修改lchild or rchild\n{\n    BiTree q, s;\n    ", "if", " ((*t)->lchild == NULL)", "//", "左子树为空，连接右子树\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        ", "//", "q = (*t)->rchild;", "//", "连接右子树，直接改变指针\n        ", "//", "(*t)->data = q->data;\n        ", "//", "(*t)->rchild = q->rchild;\n        free(q);", "//", "删除结点所占空间\n    }\n", "\n", "源程序如下：", "\n", "#", "include", "<iostream>\n#", "include", "<stack>\nusing namespace std;\n", "//顺序查找", "\n", "int", " ", "Sq_Sear(", "int", "*", " ", "a", ", ", "int", " ", "n", ", ", "int", " ", "key", ")", "\n{\n    ", "int", " i = n;\n    ", "for", " (i = ", "0", "; i <= n; i++)", "//cpu要做两次判断，可做优化", "\n    {\n        ", "if", " (a", "[", "i", "]", " == ", "key)\n        {\n            return i;\n        }\n    }\n    return ", "0", ";\n    ", "//改进,增加一个哨兵来减少循环次数，会污染数组", "\n\n    ", "//int i = n;", "\n    ", "//a[0] = key;", "\n    ", "//while (a[i] != key)", "\n    ", "//{", "\n    ", "//    i--;", "\n    ", "//}", "\n\n    ", "//return i;", "\n\n}\n\n\n", "//插值查找(按比例查找)", "\n", "int", " bia", "_search(", "int", " ", "str", "[], ", "int", " ", "n", ", ", "int", " ", "key", ")", "\n{\n    ", "int", " low = ", "0", ", high = n-", "1", ";\n    ", "int", " mid = ", "0", ";\n    ", "while", " (low <= high)\n    {\n        ", "//折半与按比例的优劣，数的值跨度不是很大按比例更好，", "\n        mid = low + (key - str", "[", "low", "]", ")", " / ", "(str", "[", "high", "]", " - str", "[", "low", "]", ")", " * ", "(high - low);\n            ", "if", " (str", "[", "mid", "]", " == ", "key)\n                return mid;\n            ", "if", " (str", "[", "mid", "]", " > key)\n                high = mid - ", "1", ";\n            ", "if", " (str", "[", "mid", "]", " < key)\n            low = mid + ", "1", ";\n    }\n    return -", "1", ";\n\n}\n", "//斐波那契查找", "\n", "//1.首先创建斐波那契数组", "\n", "//2。找到有序表最大元素", "\n", "//3.补齐有序表最大值到最接近斐波那契数组的一个元素", "\n", "//4.根据斐波那契的规则对比查找", "\n\n\nvoid produce", "Fib(", "int", "*", " ", "fib", ", ", "int", " ", "size", ")", "\n{\n    ", "int", " i;\n    fib", "[", "0", "]", " = ", "0", ";\n    fib", "[", "1", "]", " = ", "1", ";\n    ", "for", " (i = ", "2", "; i < size; i++)\n    {\n        fib", "[", "i", "]", " = fib", "[", "i", " - ", "1", "]", " + fib", "[", "i", " - ", "2", "]", ";\n    }\n}\n\n\n", "int", " ", "FibonacciSearch(", "int", "*", " ", "data", ", ", "int", " ", "length", ", ", "int", " ", "searchValue", ")", "\n{\n    ", "int", " low = ", "0", ", high = length - ", "1", ";\n    ", "int", " i = ", "0", ",mid = ", "0", ";\n    ", "int", " fib", "[", "10", "]", ";\n    produce", "Fib(", "fib", ", ", "length", ")", ";\n\n\n    ", "int", " k = ", "0", ";", "//最接近斐波那契的数", "\n\n    ", "while", " (high > fib", "[", "k", "]", " - ", "1", ")\n    {\n        k++;\n    }\n\n\n    ", "//补齐有序表", "\n    ", "int", "* temp;\n    temp = (", "int", "*)", "new", " ", "int", "[", "fib", "[", "k", "]", " - ", "1", "];\n    memcpy(temp, data, length", " * ", "sizeof(", "int", "));\n    ", "for", " (i = length; i < fib", "[", "k", "]", " - ", "1", "; i++)\n    {\n        data", "[", "i", "]", " = data", "[", "high", "]", ";\n    }\n\n    ", "while", " (low <= high)\n    {\n        ", "if", " (k > ", "0", ")\n            mid = low + fib", "[", "k", " - ", "1", "]", " - ", "1", ";\n        ", "else", "\n            mid = low;\n        ", "if", " (temp", "[", "mid", "]", " == ", "searchValue)\n        {\n            ", "if", " (mid <= length - ", "1", ")\n                return mid;\n            ", "else", "\n                return length - ", "1", ";\n        }\n\n\n\n\n        ", "if", " (temp", "[", "mid", "]", " > searchValue)\n        {\n            high = mid - ", "1", ";\n            k = k - ", "1", ";\n        }\n        ", "if", " (temp", "[", "mid", "]", " < searchValue)\n        {\n            low = mid + ", "1", ";\n            k = k - ", "2", ";\n        }\n    }\n\n    delete", "[]", " temp;\n    return -", "1", ";\n}\n\n\ntypedef ", "struct", " BiNode\n{\n    ", "int", " data;\n    ", "struct", " BiNode* lchild;\n    ", "struct", " BiNode* rchild;\n    ", "BiNode(", "int", " ", "x", ")", " :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n    \n}BiNode,*BiTree;\n\n", "//二叉查找树", "\n", "//T为搜索的树，f为记录父节点的指针，p作为临时指针保存输出", "\n", "bool", " ", "SearchBST(BiTree T, ", "int", " ", "key", ", BiTree ", "f", ", BiTree", "*", " ", "p", ")", "\n{\n    ", "if", " (!T)\n    {\n        *p = f;\n        return ", "false", ";\n    }\n    ", "else", " ", "if", "(key==T->data)\n    {\n        *p = T;\n        return ", "true", ";\n    }\n    ", "else", " ", "if", "(key < T->data)\n    {\n        return ", "SearchBST(T->", "lchild", ",", "key", ",T,", "p", ")", ";\n    }\n    ", "else", " ", "if", "(key > T->data)\n    {\n        return ", "SearchBST(T->", "rchild", ",", "key", ",T,", "p", ")", ";\n    }\n    ", "else", "\n    return ", "false", ";\n}\n", "bool", " ", "SearchBST(BiTree T, ", "int", " ", "key", ")", "\n{\n    BiTree f(", "0", ");\n    BiTree* p(", "0", ");\n     f = (BiTree)", "new", " BiTree; p = ", "new", " BiTree;\n    ", "if", " (!T)\n    {\n        *p = f;\n        return ", "false", ";\n    }\n    ", "else", " ", "if", " (key", " == ", "T->data)\n    {\n        *p = T;\n        return ", "true", ";\n    }\n    ", "else", " ", "if", " (key < T->data)\n    {\n        return ", "SearchBST(T->", "lchild", ", ", "key", ")", ";\n    }\n    ", "else", " ", "if", " (key > T->data)\n    {\n        return ", "SearchBST(T->", "rchild", ", ", "key", ")", ";\n    }\n    ", "else", "\n        return ", "false", ";\n}\n", "//删除", "\n", "//*p搜索位置结点", "\n", "//定义两个临时指针", "\n", "//三种情况", "\n\n", "bool", " ", "Delete(BiTree", "*", " ", "t", ")", "//传输的是指针域的地址,直接修改lchild or rchild", "\n{\n    BiTree q, s;\n    ", "if", " ((*t)->lchild", " == ", "NULL)", "//左子树为空，连接右子树", "\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        ", "//q = (*t)->rchild;//连接右子树，直接改变指针", "\n        ", "//(*t)->data = q->data;", "\n        ", "//(*t)->rchild = q->rchild;", "\n        free(q);", "//删除结点所占空间", "\n    }\n    ", "else", " ", "if", " ((*t)->rchild", " == ", "NULL)", "//右子树为空，连接左子树", "\n    {\n        q = *t;\n        (*t) = (*t)->lchild;", "//连接左子树，直接改变指针", "\n        ", "//free(q);//删除结点所占空间", "\n    }\n    ", "else", "//有两个孩子", "\n    {\n        q = (*t);", "//找到中序遍历时的前驱结点，即孩子结点的右子树最右边的叶子结点", "\n        s = (*t)->lchild;\n        ", "while", " (s->rchild != NULL)\n        {\n            q = s;", "//记录当前结点值", "\n            s = s->rchild;", "//找到右子树最右边的叶子结点", "\n        }\n        (*t)->data = s->data;\n        ", "if", " (q", " == ", "*t)", "//孩子结点为目标结点", "\n        {\n            q->lchild = s->lchild;", "//链接", "\n        }\n        ", "else", "//存在右子树", "\n        {\n            q->rchild = s->lchild;", "//目标结点的父亲结点链接孩子结点", "\n        }\n        \n        free(s);\n\n    }\n    \n    return ", "true", ";\n}\n\n", "//删除二叉排序树的结点", "\n", "//1.判断是否为空树", "\n", "//2.搜索判断是否存在", "\n", "//3.执行删除函数", "\n", "int", " ", "DelectBST(BiTree T, ", "int", " ", "key", ")", "\n{\n    ", "if", " (T", " == ", "NULL)\n    {\n        return ", "false", ";\n\n    }\n\n\n    ", "else", " ", "if", " (key", " == ", "T->data)\n        {\n            return ", "Delete(&T)", ";\n        }\n    ", "else", " ", "if", "(key < T->data)\n        {\n            return ", "DelectBST(T->", "lchild", ", ", "key", ")", ";\n        }\n    ", "else", " \n        {\n            return ", "DelectBST(T->", "rchild", ",", "key", ")", ";\n        }\n    \n}\n\n\n", "//插入", "\n", "int", " ", "InsertBST(BiTree", "*", " T, ", "int", " ", "key", ")", "\n{\n    BiTree p ,s;\n\n\n    ", "//传入临时结点指针p，通过搜索函数返回当前最接近该插入值的一个节点位置", "\n    ", "if", " (!", "SearchBST(", "*", "T, ", "key", ", NULL, &", "p", ")", ")\n    {\n        s = (BiTree)", "new", " BiTree;\n        s->data = key;\n        s->lchild = NULL;\n        s->rchild = NULL;\n        ", "if", " (!p)\n        {\n            *T = s;", "//此处为插入根节点", "\n        }\n        ", "else", " ", "if", " (key < p->data)\n        {\n            p->lchild = s;\n        }\n        ", "else", "\n        {\n            p->rchild = s;\n        }\n        return ", "true", ";\n\n    }\n    ", "else", " {\n        cout << ", "\"已存在相同数据！\"", " << endl;\n        \n\n        return ", "false", ";\n    }\n}\n\n\n", "//遍历", "\n", "//遍历迭代", "\nvoid depth", "FirstSearch(BiNode", "*", " ", "root", ")", "\n{\n    stack<BiNode*>sta;\n    sta.push(root);\n    BiNode* p;\n    ", "while", " (!sta.empty", "()", ")\n    {\n        \n        p = sta.top", "()", ";\n        ", "if", " (p != NULL)\n        cout << p->data<<", "' '", ";\n        sta.pop", "()", ";\n        ", "if", " (p->rchild != NULL)\n            sta.push(p->rchild);\n        ", "if", " (p->lchild= NULL)\n            sta.push(p->lchild);\n\n    }\n    cout << endl;\n}\n\n\n\n\n", "int", " main(void)\n{\n    ", "//int data[] = { 1,2,3,4,5,6,7,8,9,10 };", "\n    ", "//int len = sizeof(data) / sizeof(data[0]);", "\n    ", "//int index = FibonacciSearch(data,len,5);", "\n    ", "//cout << index;", "\n    BiTree T = ", "BiTree(0)", ";\n    \n    \n    ", "InsertBST(&T, 1)", ";\n    ", "InsertBST(&T, 2)", ";\n    ", "InsertBST(&T, 3)", "; \n    ", "InsertBST(&T, 5)", ";\n    ", "InsertBST(&T, 7)", ";\n    ", "InsertBST(&T, 8)", "; \n    ", "InsertBST(&T, 12)", ";\n    ", "InsertBST(&T, 11)", ";\n    ", "InsertBST(&T, 21)", ";\n    ", "InsertBST(&T, 31)", ";\n    ", "InsertBST(&T, 51)", ";\n    ", "InsertBST(&T, 17)", ";\n    ", "InsertBST(&T, 18)", ";\n    ", "InsertBST(&T, 121)", ";\n    depth", "FirstSearch(T)", ";\n    \n    cout << ", "SearchBST(T, 3)", " << endl;\n\n    depth", "FirstSearch(T)", ";\n    ", "DelectBST(T,12)", ";\n    depth", "FirstSearch(T)", ";\n    return ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇文章讲的很详细&amp;#xff0c;请看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/getinobacar/article/details/122707664?utm_source&amp;#61;csdn_ai_ada_ask_robot\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;力扣 76题 最小覆盖子串&amp;#xff08;双指针 &amp;#43; 滑动窗口&amp;#xff09;&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["力扣错误提示解惑，76题最小覆盖子串", ["问题遇到的现象和发生背景", "\n", "力扣76.最小覆盖子串，请用通俗的语言概括一下下边这段错误提示的意思。", "同时，贴上我的代码", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "报错内容：", "Line 137: Char 23: runtime error: constructor call on misaligned address 0xbebebebebebec0ba for type 'int', which requires 4 byte alignment (new_allocator.h)", ": note: pointer points here", "SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/ext/new_allocator.h:146:23", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "class", " Solution {\npublic:\n    static ", "bool", " comp", "SL(", "deque", "<", "int", ">& ", "a", ",", "deque", "<", "int", ">& ", "b", ")", "\n    {\n        ", "if", "(a.empty", "()", ") return ", "0", ";\n        ", "if", "(b.empty", "()", ") return ", "1", ";\n        return a.front", "()", "<b.front", "()", ";\n    }\n    static ", "bool", " comp", "SR(", "deque", "<", "int", ">& ", "c", ",", "deque", "<", "int", ">& ", "d", ")", "\n    {\n        ", "if", "(c.empty", "()", ") return ", "0", ";\n        ", "if", "(d.empty", "()", ") return ", "1", ";\n        return c.back", "()", ">d.back", "()", ";\n    }\n    void ", "DFS(", "int", " ", "k", ",", "string", " ", "t", ",", "vector", "<", "int", "> ", "sUCnt", ",", "vector", "<", "int", "> ", "sLCnt", ",", "vector", "<", "deque", "<", "int", ">> ", "sU", ",", "vector", "<", "deque", "<", "int", ">> ", "sL", ")", "\n    {\n        ", "if", "(k==n)\n        {\n            sort(tU.", "begin", "()", ",tU.", "end", "()", ",compSL);ul=tU", "[", "0", "]", ".empty", "()", "? INT_MAX:tU", "[", "0", "]", ".front", "()", ";\n            sort(tU.", "begin", "()", ",tU.", "end", "()", ",compSR);ur=tU", "[", "0", "]", ".empty", "()", "? INT_MIN:tU", "[", "0", "]", ".back", "()", ";\n            sort(tL.", "begin", "()", ",tL.", "end", "()", ",compSL);ll=tL", "[", "0", "]", ".empty", "()", "? INT_MAX:tL", "[", "0", "]", ".front", "()", ";\n            sort(tL.", "begin", "()", ",tL.", "end", "()", ",compSR);lr=tL", "[", "0", "]", ".empty", "()", "? INT_MIN:tL", "[", "0", "]", ".back", "()", ";\n            mx=max(ur,lr);mn=min(ul,ll);\n            tmp=mx-mn;\n            ", "if", "(tmp+", "1", "<=len)\n            {\n                beg=mn;\n                len=tmp+", "1", ";\n            }\n            return;\n        }\n        ", "int", " j=t", "[", "k", "]", "-", "'A'", ",e;\n        ", "if", "(j<", "26", ")\n        {\n            tUCnt", "[", "j", "]", "--;\n            ", "while", "(!sU", "[", "j", "]", ".empty", "()", ")\n            {\n                sUCnt", "[", "j", "]", "--;\n                ", "if", "(tUCnt", "[", "j", "]", ">sUCnt", "[", "j", "]", ") break;\n                e=sU", "[", "j", "]", ".front", "()", ";\n                tU", "[", "j", "]", ".push", "_back(", "e", ")", ";\n                sU", "[", "j", "]", ".pop", "_front()", ";\n                ", "DFS(", "k", "+1,", "t", ",", "sUCnt", ",", "sLCnt", ",", "sU", ",", "sL", ")", ";\n                tU", "[", "j", "]", ".pop", "_back()", ";\n            }\n            tUCnt", "[", "j", "]", "++;\n        }\n        ", "else", "\n        {\n            j=t", "[", "k", "]", "-", "'a'", ";\n            tLCnt", "[", "j", "]", "--;\n            ", "while", "(!sL", "[", "j", "]", ".empty", "()", ")\n            {\n                sLCnt", "[", "j", "]", "--;\n                ", "if", "(tLCnt", "[", "j", "]", ">sLCnt", "[", "j", "]", ") break;\n                e=sL", "[", "j", "]", ".front", "()", ";\n                tL", "[", "j", "]", ".push", "_back(", "e", ")", ";\n                sL", "[", "j", "]", ".pop", "_front()", ";\n                ", "DFS(", "k", "+1,", "t", ",", "sUCnt", ",", "sLCnt", ",", "sU", ",", "sL", ")", ";\n                tL", "[", "j", "]", ".pop", "_back()", ";\n            }\n            tLCnt", "[", "j", "]", "++;\n        }\n    }\n    ", "string", " min", "Window(", "string", " ", "s", ", ", "string", " ", "t", ")", "\n    {\n        m=s.size", "()", ";\n        n=t.size", "()", ";\n        len=m;\n        vector<", "int", "> s", "UCnt(26)", ",sLCnt;\n        vector<deque<", "int", ">> s", "U(26)", ",sL;\n        tLCnt=sLCnt=tUCnt=sUCnt;\n        tL=sL=tU=sU;\n        ", "for", "(", "int", " i=", "0", ",j;i<m;i++)\n        {\n            j=s", "[", "i", "]", "-", "'A'", ";\n            ", "if", "(j<", "26", ")\n            {\n                sUCnt", "[", "j", "]", "++;\n                sU", "[", "j", "]", ".push", "_back(", "i", ")", ";\n            }\n            ", "else", "\n            {\n                j=s", "[", "i", "]", "-", "'a'", ";\n                sLCnt", "[", "j", "]", "++;\n                sL", "[", "j", "]", ".push", "_back(", "i", ")", ";\n            }\n        }\n        ", "for", "(", "int", " i=", "0", ",j;i<n;i++)\n        {\n            j=t", "[", "i", "]", "-", "'A'", ";\n            ", "if", "(j<", "26", ")\n            {\n                ", "if", "(tUCnt", "[", "j", "]", "==sUCnt", "[", "j", "]", ") return {};\n                tUCnt", "[", "j", "]", "++;\n            }\n            ", "else", "\n            {\n                j=t", "[", "i", "]", "-", "'a'", ";\n                ", "if", "(tLCnt", "[", "j", "]", "==sLCnt", "[", "j", "]", ") return {};\n                tLCnt", "[", "j", "]", "++;\n            }\n        }\n        ", "DFS(0,", "t", ",", "sUCnt", ",", "sLCnt", ",", "sU", ",", "sL", ")", ";\n        return s.substr(beg,len);\n    }\n", "private", ":\n    ", "int", " m,n,tmp,beg,len,ul,ur,ll,lr,mx,mn;\n    vector<", "int", "> tUCnt,tLCnt;\n    vector<deque<", "int", ">> tU,tL;\n};\n\n", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我的代码怎么改是次要的，最主要想请教错误提示想要表达什么？", "如果可能，我还是希望能用回溯法解题", "我先分别对字符串s、t包含的字母统计数量。然后定义4个队列数组，其中两个用于存储s中各字母在s中的位置序号，另外两个用于存储t中各字母在字符串s中可能的位置序号。假如t中某一个字母的剩余数大于s中的剩余数，则终止当前操作，回退数据状态，不再进入更深的一层搜索。只要sU、sL当前字母的队列里还存有序号，则while循环不会停止。当k==n时，说明t中每个字母都匹配到了一个序号，通过自定义sort函数对匹配得到的所有序号进行排序，然后使其中最大值和最小值相减，取得包含t中所有字母的字符串长度，最后通过回溯的方式，找到满足题意长度最小的字符串。", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下&amp;#xff1a;&lt;br /&gt;这是一个典型的搜索问题&amp;#xff0c;可以使用深度优先搜索&amp;#xff08;DFS&amp;#xff09;或广度优先搜索&amp;#xff08;BFS&amp;#xff09;算法来解决。以下是一个使用DFS算法的解决方案&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;n &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;())\nmaze &amp;#61; [&lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;()) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; _ &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(n)]\nvisited &amp;#61; [[&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;] * n &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; _ &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(n)]\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;x, y&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; x &amp;#61;&amp;#61; n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; y &amp;#61;&amp;#61; n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    visited[x][y] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n    res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; dx, dy &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; [(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)]:  &lt;span class=\"hljs-comment\"&gt;# 向四个方向移动&lt;/span&gt;\n        nx, ny &amp;#61; x&amp;#43;dx, y&amp;#43;dy\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; nx &amp;lt; n &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; ny &amp;lt; n &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; visited[nx][ny] &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; maze[nx][ny] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;O&amp;#39;&lt;/span&gt;:\n            res &amp;#43;&amp;#61; dfs(nx, ny)\n    visited[x][y] &amp;#61; &lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;# 回溯&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(res, &lt;span class=\"hljs-number\"&gt;50000&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 超过50000时返回50000&lt;/span&gt;\n\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(dfs(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;首先读入迷宫和迷宫大小。然后定义一个visited数组来记录每个瓷砖是否已经走过&amp;#xff0c;初始化为False。接下来定义一个dfs函数&amp;#xff0c;用于搜索从当前位置出发到达终点的方案数。如果当前位置已经是终点&amp;#xff0c;则返回1。否则&amp;#xff0c;依次向四个方向移动&amp;#xff0c;如果某个方向可以移动且未访问过且不是墙壁&amp;#xff0c;则继续搜索从该位置出发到达终点的方案数。最后回溯并返回总方案数。注意&amp;#xff0c;为了避免结果太大&amp;#xff0c;当方案数超过50000时&amp;#xff0c;返回50000。&lt;/p&gt;\n&lt;p&gt;最后调用dfs函数并输出结果即可。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;如果以上回答对您有所帮助&amp;#xff0c;点击一下采纳该答案&amp;#xff5e;谢谢&lt;/p&gt;", "Konwledge_Point": "图的深度优先搜索", "Question": ["迷宫路径方案数，初学者正在写但怕弄不出来，来问问大家", ["有一个正方形的迷宫，上面铺着正方形的瓷砖，标记为’O’的瓷砖可以在上面移动，但是标记为‘X’不可以在上面移动。一个男人从左上角移动到右下角。请写一个程序来计算他有多少种方案可以完成这个移动，要求是走过的瓷砖不能重复走，同时标记为’X’的瓷砖也不能走。", "\n", "输入格式：", "\n", "第一行一个整数N,表示迷宫由N*N的瓷砖铺成，N<20", "\n", "接下来N行，每行N个字符，‘O’或‘X’", "\n", "输出格式：", "\n", "一个整数，表示移动方案数，如果大于50000则输出50000", "\n", "我自己写的在VS上过了，但学习通提交超时", "，然后写的深度优先搜索不对，求怎么解决呀，我已经快放弃了，能不能来个佬帮帮忙", "\n"]], "Tag": "算法设计"}
