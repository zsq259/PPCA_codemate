{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/78485545925619.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;看一下是不是你要的&amp;#xff0c;不懂的可以问。&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n#include &lt;span class=\"hljs-string\"&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;\n\nint main()\n\n{\n    int a, b, i, j, k, p, n, &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], &lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;please input n:\\n&amp;#34;&lt;/span&gt;);\n\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;please input C[%d][%d],B[%d][%d]:\\n&amp;#34;&lt;/span&gt;, n, n, n, n);\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d,%7d&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[i][j],\n                  &amp;amp;&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j]); //输入各点(i,j)之间的容量&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[i][j]和运费&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j]\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n        {\n            &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n            for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n            if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;) //注&amp;#xff1a;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;表示&lt;span class=\"hljs-symbol\"&gt;Vi&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;Vj&lt;/span&gt;之间无可行路\n\n            {\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n        for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n            for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n                {\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n                } //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;, n, n);\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n    {\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    } //由表&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;中的数值确定&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的最短路\n\n    a &amp;#61; &lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    b &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] * &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;, a, b);\n\n    &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; //将容量已满的路改为不可行路\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n        {\n            &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n            for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n            if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n\n            {\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n        for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n            for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\nif(&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k]&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n} //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;,n,n);\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\n{\n                    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n} //由表&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;中的数值确定&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的新最短路\n\na&amp;#61;a&amp;#43;&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];b&amp;#61;b&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,a,b);\n\n&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; //将容量已满的路改为不可行路\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n                    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n                    if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n\n                    {\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                    }\n\n}\n\nfor(k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;)\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\nif(&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k]&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n} //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;,n,n);\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\n{\n                    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n} //由表&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;中的数值确定&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的新最短路\n\na&amp;#61;a&amp;#43;&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]-&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];b&amp;#61;b&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,a,b);\n\n&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; //将容量已满的路改为不可行路\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n                    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n                    if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n\n                    {\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                    }\n\n}\n\nfor(k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;)\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\nif(&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k]&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n} //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;,n,n);\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\n{\n                    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n} //检验有无&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的新最短路\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["网络流算法，最小费用最大流问题", ["设有一个给定的网络N(V,x,y,A,C,w)，其中c表示弧容量，w表示弧上的单位费用，另外给定一个常数a>o，请设计一个算法，用于求该网络中一个费用不超过a的最大流·要求给出算法的具体流程，并说明算法的合理性，进一步给出数值模拟的结果", "急！ "]], "Tag": "算法设计"}
{"Answer": "摄像头品牌也没法直接获取，需要有一些自己的判断规则", "Konwledge_Point": "网络中的流", "Question": ["关于网络摄像机主码流和子码流的rtsp地址格式！", ["我想在客户端播放网络摄像机监控视频的时候手动选择主码流和字码流，", "\n可是通过查资料得知不同网络摄像机品牌的RTSP地址格式不同.", "\n例如，请求海康摄像机通道1的主码流，Url如下", "\n主码流：", "\nrtsp://admin:12345@192.0.0.64:554/h264/ch1/main/av_stream", "\n\n", "子码流：", "\nrtsp://admin:12345@192.0.0.64/mpeg4/ch1/sub/av_stream", "\n\n", "大华的则为：", "\n例如，请求某设备的通道2的辅码流，Url如下", "\nrtsp://admin:admin@10.12.4.84:554/cam/realmonitor?channel=2&subtype=1", "\n\n", "那有没有一种兼容式的格式呢，不用考虑不同厂家都可以用一种格式来表示字码流和主码流呢？"]], "Tag": "算法设计"}
{"Answer": "先计算一下接收到的数据长度，测试一下与你的图片是否相等？\r\n\r\n```\r\n        byte[] buffer = new byte[1024 * 2];\r\n        // 读取到数据的长度\r\n        int len;\r\n        while ((len = inStream.read(buffer)) != -1) {\r\n            outStream.write(buffer, 0, len);\r\n        }\r\n```\r\n如果相等，再分析一下接收到手文件中的数据与原始的图片有多大差别。", "Konwledge_Point": "网络中的流", "Question": ["Java保存网络图片到本地图片损毁", [" package imageView;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * 从网络获取图片到本地\n */\npublic class GetImage {\n\n    /**\n     * 测试\n     * \n     * @param args\n     */\n    public static void main(String[] args) {\n        String url = \"http://www.iteye.com/upload/logo/user/1134656/d44c2b36-9869-360a-9c87-e88eaf8db3a5.jpg\";\n        byte[] btImg = getImageFromNetByUrl(url);\n        if (null != btImg && btImg.length > 0) {\n            System.out.println(\"读取到：\" + btImg.length + \"字节\");\n            String fileName = \"abc.jpg\";\n            writeImageToDisk(btImg, fileName);\n        } else {\n            System.out.println(\"没有从该连接获得内容\");\n        }\n    }\n\n    /**\n     * 从输入流中获取数据\n     * \n     * @param inStream\n     *            输入流\n     * @return ByteArray\n     * @throws Exception\n     */\n    public static byte[] readInputStream(InputStream inStream) throws Exception {\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n        // 设置数据缓冲区\n        byte[] buffer = new byte[1024 * 2];\n        // 读取到数据的长度\n        int len;\n        while ((len = inStream.read(buffer)) != -1) {\n            outStream.write(buffer, 0, len);\n        }\n        outStream.close();\n        inStream.close();\n        return outStream.toByteArray();\n\n    }\n\n    /**\n     * 根据地址获得数据的字节流\n     * \n     * @param strUrl\n     *            网络连接地址\n     * @return\n     */\n    public static byte[] getImageFromNetByUrl(String strUrl) {\n        try {\n            URL url = new URL(strUrl);\n            // 处理以http开头的地址\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(10 * 1000);// 设置链接超时时间为10s\n            InputStream inStream = conn.getInputStream();// 通过输入流获取图片数据\n            byte[] btImg = readInputStream(inStream);// 得到图片的二进制数据\n            inStream.close();\n            return btImg;\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * 将图片写入到磁盘\n     * \n     * @param img\n     *            图片数据流\n     * @param fileName\n     *            文件保存时的名称\n     */\n    public static void writeImageToDisk(byte[] img, String fileName) {\n        try {\n            File file = new File(\"E:\\\\\" + fileName);\n            FileOutputStream fops = new FileOutputStream(file);\n            fops.write(img);\n            fops.flush();\n            fops.close();\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n    }\n\n}\n"]], "Tag": "算法设计"}
{"Answer": "[http://blog.csdn.net/lixiang99410/article/details/6173995?locationNum=2](http://blog.csdn.net/lixiang99410/article/details/6173995?locationNum=2 \"\")", "Konwledge_Point": "网络中的流", "Question": ["最大流问题 Ford-Fulkerson算法解决", ["G为连通有向图，f是u-->v路径上已有的流量，Gf为残留网络", "\n伪代码如下：", "\n1 for each edge(u,v)属于E（G）", "\n\n", "2     do f[u,v]=0", "\n\n", "3          f[v,u]=0", "\n\n", "4 while there exists a path p from s to t in the residual network Gf", "\n\n", "5       do cf(p)=min{cf(u,v):(u,v)is in p}", "\n\n", "6        for each edge (u,v) in p", "\n\n", "7              do f[u,v]=f[u,v]+cf(p)", "\n\n", "8                    f[v,u]=-f[u,v]", "\n\n", "比较疑惑第8行是什么作用？在代码中我尝试去掉这句话，结果显示也不错啊？"]], "Tag": "算法设计"}
{"Answer": "1、URL url = new URL(path);  确保path正确 可以在此输出 然后到浏览器试试\r\n2、java.net.ConnectException: Connection timed out \r\n\r\nHttpURLConnection urlCon = (HttpURLConnection)url.openConnection();\r\nurlCon.setConnectTimeout(30000);\r\nurlCon.setReadTimeout(30000);\r\n\r\nsetConnectTimeout：设置连接主机超时（单位：毫秒）\r\nsetReadTimeout：设置从主机读取数据超时（单位：毫秒）\r\n\r\n超市设置的大点", "Konwledge_Point": "网络中的流", "Question": ["java下载网络文件时连接超时", ["错误信息：", "\njava.net.ConnectException: Connection timed out", "\n    java.net.PlainSocketImpl.socketConnect(Native Method)", "\n    java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:351)", "\n    java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:213)", "\n    java.net.PlainSocketImpl.connect(PlainSocketImpl.java:200)", "\n    java.net.SocksSocketImpl.connect(SocksSocketImpl.java:366)", "\n    java.net.Socket.connect(Socket.java:529)", "\n    java.net.Socket.connect(Socket.java:478)", "\n    sun.net.NetworkClient.doConnect(NetworkClient.java:163)", "\n    sun.net.", "www.http.HttpClient.openServer(HttpClient.java:394)", "\n    sun.net.", "www.http.HttpClient.openServer(HttpClient.java:529)", "\n    sun.net.", "www.http.HttpClient", ".(HttpClient.java:233)", "\n    sun.net.", "www.http.HttpClient.New(HttpClient.java:306)", "\n    sun.net.", "www.http.HttpClient.New(HttpClient.java:323)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:970)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:911)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:836)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1172)", "\n    java.net.URL.openStream(URL.java:1010)", "\n    com.srt.ezg.eMeg.voiceMail.action.VoiceAction.voiceDownload(VoiceAction.java:189)", "\n    sun.reflect.GeneratedMethodAccessor3167.invoke(Unknown Source)", "\n    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)", "\n    java.lang.reflect.Method.invoke(Method.java:597)", "\n    org.apache.struts.actions.DispatchAction.dispatchMethod(DispatchAction.java:280)", "\n    org.apache.struts.actions.DispatchAction.execute(DispatchAction.java:216)", "\n    org.apache.struts.actions.DispatchAction$$FastClassByCGLIB$$d3d27916.invoke()", "\n    net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    com.srt.ezg.eMeg.voiceMail.action.VoiceAction$$EnhancerByCGLIB$$e77a6b68.execute()", "\n    org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:484)", "\n    org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:274)", "\n    org.apache.struts.action.ActionServlet.process(ActionServlet.java:1482)", "\n    org.apache.struts.action.ActionServlet.doGet(ActionServlet.java:507)", "\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:617)", "\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:717)", "\n    com.srt.vas.filter.OaFilter.doFilter(OaFilter.java:68)", "\n    com.srt.vas.filter.SetFilterEcod.doFilter(SetFilterEcod.java:25)", "\n    org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:198)", "\n    org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:359)", "\n    org.springframework.security.intercept.web.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:109)", "\n    org.springframework.security.intercept.web.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:83)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor.invoke(CustomFilterSecurityInterceptor.java:117)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor.doFilter(CustomFilterSecurityInterceptor.java:86)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor$$FastClassByCGLIB$$2c376577.invoke()", "\n    net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    com.srt.interceptor.MethodTimeAdvice.invoke(MethodTimeAdvice.java:34)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor$$EnhancerByCGLIB$$635d6668.doFilter()", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.SessionFixationProtectionFilter.doFilterHttp(SessionFixationProtectionFilter.java:67)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.ExceptionTranslationFilter.doFilterHttp(ExceptionTranslationFilter.java:101)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.providers.anonymous.AnonymousProcessingFilter.doFilterHttp(AnonymousProcessingFilter.java:105)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.rememberme.RememberMeProcessingFilter.doFilterHttp(RememberMeProcessingFilter.java:116)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.wrapper.SecurityContextHolderAwareRequestFilter.doFilterHttp(SecurityContextHolderAwareRequestFilter.java:91)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.basicauth.BasicProcessingFilter.doFilterHttp(BasicProcessingFilter.java:173)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.AbstractProcessingFilter.doFilterHttp(AbstractProcessingFilter.java:271)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.AbstractProcessingFilter.doFilterHttp(AbstractProcessingFilter.java:271)", "\n    org.springframework.security.ui.AbstractProcessingFilter$$FastClassByCGLIB$$32042740.invoke()", "\n    net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    com.srt.sdp.security.bean.CustomAuthenticationProcessingFilter$$EnhancerByCGLIB$$3e18fe7e.doFilterHttp()", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.logout.LogoutFilter.doFilterHttp(LogoutFilter.java:89)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.context.HttpSessionContextIntegrationFilter.doFilterHttp(HttpSessionContextIntegrationFilter.java:235)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.util.FilterChainProxy.doFilter(FilterChainProxy.java:174)", "\n    org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:236)", "\n    org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)", "\n\n", "VoiceAction.java中的下载action:", "\n\n", "try {", "\n            request.setCharacterEncoding(\"UTF-8\");", "\n        } catch (UnsupportedEncodingException e) {", "\n        }", "\n        String path = request.getParameter(\"url\");// 语音文件下载地址", "\n        path = new String(path", "\n                .getBytes(\"ISO-8859-1\"), \"UTF-8\");", "\n//        path=\"", "http://127.0.0.1/Ezg_v4.0/a059516000101001.wav", "\";", "\n        int startIndex = path.lastIndexOf(\"/\");", "\n        int endIndex = path.length();", "\n        String fileName = path.substring(startIndex + 1, endIndex);", "\n        BufferedInputStream bis = null;", "\n        BufferedOutputStream bos = null;", "\n        OutputStream fos = null;", "\n        InputStream fis = null;", "\n        URL url = new URL(path);", "\n        try {", "\n            fis = url.openStream();//这行报错", "\n            bis = new BufferedInputStream(fis);", "\n            fos = response.getOutputStream();", "\n            bos = new BufferedOutputStream(fos);", "\n            response.setHeader(\"Content-disposition\", \"attachment;filename=\"", "\n                    + new String(fileName.getBytes(\"gb2312\"), \"ISO-8859-1\"));", "\n            int bytesRead = 0;", "\n            byte[] buffer = new byte[8192];", "\n            while ((bytesRead = bis.read(buffer, 0, 8192)) != -1) {", "\n                bos.write(buffer, 0, bytesRead);", "\n            }", "\n            bos.flush();", "\n            fis.close();", "\n            bis.close();", "\n            fos.close();", "\n            bos.close();", "\n        } catch (FileNotFoundException e) {", "\n            e.printStackTrace();", "\n        }", "\n\n", "        return null;", "\n\n", "首先，代码应该是没有问题的。", "\n报错的位置是在fis = url.openStream()这里。", "\nVoiceAction.java:189", "\n请问，应该从哪里着手解决？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;望采纳&lt;/p&gt;\n&lt;p&gt;下面代码使用文件字符输入流 FileReader 和文件字符输出流 FileWriter 将文件 a.txt 的内容存储到文件 b.txt 中&amp;#xff0c;并在存储成功后在控制台输出 &amp;#34;OK&amp;#34;。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.io.FileReader;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.io.FileWriter;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.io.IOException;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Main&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(String[] args)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt; {\n            &lt;span class=\"hljs-comment\"&gt;// 创建文件字符输入流对象&amp;#xff0c;用于读取文件 a.txt 的内容&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;FileReader&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;inputStream&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;FileReader&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;a.txt&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-comment\"&gt;// 创建文件字符输出流对象&amp;#xff0c;用于写入文件 b.txt 的内容&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;FileWriter&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;outputStream&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;FileWriter&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;b.txt&amp;#34;&lt;/span&gt;);\n\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n            &lt;span class=\"hljs-comment\"&gt;// 使用循环读取文件 a.txt 的内容&amp;#xff0c;每次读取一个字符&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; ((c &amp;#61; inputStream.read()) !&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n                &lt;span class=\"hljs-comment\"&gt;// 将读取的字符写入文件 b.txt&lt;/span&gt;\n                outputStream.write(c);\n            }\n\n            &lt;span class=\"hljs-comment\"&gt;// 关闭文件字符输入流和文件字符输出流&lt;/span&gt;\n            inputStream.close();\n            outputStream.close();\n\n            &lt;span class=\"hljs-comment\"&gt;// 在控制台输出 OK&lt;/span&gt;\n            System.out.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;OK&amp;#34;&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;catch&lt;/span&gt; (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["java 输入输出流和文件处理", ["通过文件字符输入流FileReader和文件字符输出流FileWriter，将a.txt文件内容存储到文件b.txt，存储成功后在控制面板输出“OK”。", "求解答"]], "Tag": "算法设计"}
{"Answer": "```\r\n if(scan.hasNext()) {\r\n　　　　　　System.out.println(scan.nextLine());\r\n　　　　}\r\n\t\t照你的意思是不是应该是while,而不是if\r\n\t\twhile(scan.hasNext()) {\r\n　　　　　　System.out.println(scan.nextLine());\r\n　　　　}\r\n```", "Konwledge_Point": "网络中的流", "Question": ["java网络编程中IO数据输入输出阻塞", ["服务端代码如下：", "\npublic class Server {", "\n　　public static void main(String[] args) throws IOException {", "\n　　　　ServerSocket ss = new ServerSocket(30000);", "\n　　　　Socket socket = ss.accept();", "\n　　　　PrintStream ps = new PrintStream(socket.getOutputStream());", "\n　　　　ps.println(\"服务器第一行数据\"); //1", "\n　　　　ps.println(\"服务器第二行数据\"); //2", "\n　　　　ocket.shutdownOutput(); //3", "\n　　　　//下面语句将输出false", "\n　　　　System.out.println(socket.isClosed());", "\n　　　　Scanner scan = new Scanner(socket.getInputStream());", "\n　　　　BufferedReader br = new BufferedReader(new 　　　　InputStreamReader(socket.getInputStream()));", "\n　　　　//为什么只得到客户端第一条数据", "\n　　　　if(scan.hasNext()) {", "\n　　　　　　System.out.println(scan.nextLine());", "\n　　　　}", "\n　　　　//为什么此处得不到数据", "\n　　　　　while(br.readLine() != null) {", "\n　　　　　　System.out.println(br.readLine());", "\n　　　　}", "\n　　　　scan.close();", "\n　　　　br.close();", "\n　　　　socket.close();", "\n　　　　ss.close();", "\n　　　　}", "\n}", "\n客户端代码如下：", "\npublic class Client {", "\n　　public static void main(String[] args) throws IOException {", "\n　　　　Socket s = new Socket(\"localhost\", 30000);", "\n　　　　Scanner scan = new Scanner(s.getInputStream());", "\n　　　　// 为什么只能得到服务端第一条数据", "\n　　　　if (scan.hasNextLine()) {", "\n　　　　　　System.out.println(scan.nextLine());", "\n　　　　}", "\n　　　　PrintStream ps = new PrintStream(s.getOutputStream());", "\n　　　　ps.println(\"客户端的第一行数据\");", "\n　　　　ps.println(\"客户端的第二行数据\");", "\n　　　　ps.close();", "\n　　　　scan.close();", "\n　　　　s.close();", "\n　　}", "\n}", "\n服务端运行结果：", "\nfalse", "\n客户端的第一行数据", "\n客户端运行结果：", "\n服务器第一行数据", "\n如上述所示，服务端在 //1,//2处已经将数据输出到socket输出流了，在//3处才关闭输出功能，为什在客户端得到的数据只能显示一条", "\n同样，客户端输出了两条数据，在服务端关闭输出，输入功能应该不收影响，为什么也只能得到一条数据。"]], "Tag": "算法设计"}
{"Answer": "首先，目测有一个问题就是你的异常分支没有任何处理，应该打印堆栈日志的。\r\n其次，你说没有输出结果，可能是代码报异常了吧。建议把异常分支都处理后再看看。", "Konwledge_Point": "网络中的流", "Question": ["Java网络编程对象流对象无法传递", ["哪位大神路过指点一下，运行后服务器端控制台只能显示已连接就没了，不知道那里出错了，输出不了对象的name和pass，谢谢指点，谢谢"]], "Tag": "算法设计"}
{"Answer": "**如果这个规则不变，可以通过 .Split('^')[4] 取出来转成 bytes 再转成图片。**\r\n\r\nAAEBAgIDAwMEBAQEBQUFBAQEAwMDAgICAgICAgICAgEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\r\n\r\n\r\n**但是我试过把这段转成图片，发现是失败的，那么很有可能这串字符串不是标准的 base64 字符串，或许需要解码。下面尝试转图片失败的过程。**\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/202007/23/1595485307_921140.png)\r\n\r\n\r\n-------------------------------------------------------------------------------\r\n**这里出使用一张 CSDN 的默认头像照片转成的 Base64 字符串，再转换成图片最后赋值给 pictureBox1 的代码**\r\n![图片说明](https://img-ask.csdn.net/upload/202007/23/1595485516_163924.png)\r\n\r\n\r\nhttps://oktools.net/image2base64\r\n\r\n**这个网站可以在线把图片和 base64 之间互转。最后是转换成功的代码和 base64 信息**\r\n\r\n```\r\nvar str = \"^Application^Octer-stream^Base64^iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAAQBklEQVR4Ae2cPa8mORFG9+9utjEbkJFAQroBQiRESJsgBBIRIAhINkEiWUGAREBAAAHRReeuHqmmxnaX3bbbfsdBy/3hj7Lr+Knqfu/MZ7/5x3/fznHWoDcDn/Xu8PR3IIWBA9ZR7CER64B1wDpgnTC7T5g9ivWwYv3iz38dohhPb8ID1kNgAdSPf/ijt+99/vnbK8J1wJoM1k++/vXbD7788h0ooDpgTXbA01Lee/wUUAesA1VzHmRDnkDyZW+IV+jvhMJBmyYClABbAYTeNhywBoBF2Pv+F198kEcJolTZ26kr9HfA6ggWKuUT8xRI/t4KIPS24YDVCayffvVVWKEsWChbb6eu0N8nDxYqw9HqjFaVElwHrE47u9WBI9oBBY5FbVr6r82lBJMtCZ0tY6/e5pNVLEGFk1tUQ1/NLSQt5wesF1Msn2SjPhEVuBv6PHwHrBcCK6U23LsCC/g8GHevI+Ne2bXi808uFJbe3lCjnJNSMN6FivYHrBdQrCvFSYXD3qHPw3jA2hwsm6x75+ra5zuRNmrbWh6wNgfLJ+s5EBQOr9Qt1772fuunjlzIXuX+J5Fj1eRHOHoWVEB4wNpUsWZCUqtWB6xNoZqRI7XAZNukXhhWCWd37HjpUBjNq6yjZ58fsDZTrdL3qtnwlMY7YG0EFiGw5MyVnh2wNgJrhxAouA9Ym4C1SwgUWPpudidRXrHtSyXvO4VAgXW+Y22gWDuFQIGlko+4rxQWX0KxcAh/rCcn7Vwyj1cAbGuwXgkovxnu/Mn0CjnXlmC9MlApwHZUsK3AIjmv+UHZO2nna/LHnd4gtwHrU1Kp0gbYRb22AOtTVakcYKzHCnlUyYalwUL6d/6EkAOjx33WpeTYp58tCxZQvconhB4gpfpYOe9aEqwD1Xf/018KJn+PzbdiUr8cWAeqOFSCbEW4lgLrQFUPleBaLedaBiyg0iKdsg2wld4WlwHrvP21weQ34SrfuZYA63yn6gOVIFvhT3EeB4sdpgU5ZT/ASOifVK9HwTp5VT+QcpuSFOMJwB4D67wBjofKwjYbsOlgAdTJqeZCZQHjnPVHxfDFqJ9+poHFJHb7hw7eIa94PSoXmwIWu4MJvKJjdp7TKKhQweFgSakOWM+GP78BCIcvEwoPXM/DNVKlbL42XLEY7ITC54GSYilpR610cI+DHBgl6/G74zCwng6B7EwWSMdMtWQsHPTLn//s7fe/+vr9+OYPv33j+PabP70fnPOMOtSdaZ8gy5VAZtWn5bwbWICEQTMXyToQR/37b395+9+//v729p9/Zg/qyKns0B4OpQ/6kg2l8XPPsJv2T78591ArQLwNFkABU47+EfcZDydcQZRzor1PH6hIi0NpQ1vbX49z4EfJRqzdVZ/4s0WhfJvbYKnDGaEPR7LoPZyX6kMOvVKx0XbINuyZuWl7hEDx0A0sdUiJgUjq1e6IPqcvFEoLPrrMORQ7RijU1XxmqBcAWx/ePR8CluCKglOqhzr0CHlXzks9tw590g5sY2OV1unOs155lYWxK1hK4HupFc5MOXzmPd7cVrCDOWPLHYBSbQn7vfKqYWARAlPGt9xDLWYCtMtYVkVb1tW36ZlXDQOLjqH/Kvn1k/PXqyjEqrD1gmsUVHDQNRSK2DtwEUafyqlWBSll1923RdaZPlTKd73KIWBhXGtYfOKtK+W41e+xTl7pW6+Xz7E87bVJPMnp6g5dyb4eIbH3ZwYxMEyxGIBcKbqLgHAlp+1gCylD7eb1/hihVvh+KFg1k575AXQHaKI23vm+NUqthoMVfTs8apX/0TwCWM0GtoqVUyvukyP7I1df4c+WwxQLI+wkSudHre6B1fLh1KqVQIoASp3IZ4owWKKXvAmjKDm4nyI5CtZRq3tQoWjkWtHooA2Ofzjwpe7VlBZMq1Q6vwQLeCJGU4e6ggzgIoaeL+z3wQKumjdEoMA/Eb+WfIgoCCRfZsECkIg0pgamXXQnjPwzmEh+8ip1WMeUL1L3Wv2a6gsx8VBxnQXrLs0pI/w94HsVx64wj17A1PpeUcoClgQrqjYelNrr80G0TxgU1DXhUL4CRtrxJd//lIYK4qMrYFOq9RFY0KdBSyVUMyAQUtZSTt8jwiALxFvmiL7lwB7lCDtrfuYBBupH5gJwJbHB91atkqGw1AEw8DxnEM7EqRhdgpJnGBOZVLROavIrvhik7GS9ovO8qhfZ4C3j4dtS3z4cfqRYJSBqDCr1w7Oavq4Wk+f0lxpztW9kOTt7pQVXwnBn7UuhlrdMq1ofgFUKg4Q7H4NzDqdeysn2Xq+FlA253dQbYI3XWubylV52lpyv9W8dqxRqi2CVvj3VgBABKxdOWx12wPruRQCFFkC5shWskl/pM6tYPMwZU5MMUzfXj+5H1S8KWm6nrhYKR9sZWftWsPBFaQM3gRV1MPWuJodxNf1F6gKqzy9wYqTtzDrY6TdwbztzztemvgNWLpQXQ6GfsAypBeEKLIwb5UzGRqUoR43Ro9+RduacL3/eATkHbRGsXI5VC8IVWHd2TA+nvnofXrkFlMpWsEo5VvFzQw6sWsUqGcDkWif26kD0ml8u8twFqyQYNr/iPPy5AViiEz9g9f2pJrruqsfGFUSpsuYNX31S5t44UcgiWDxMGcK9mpzlCqzWidlJnvM8vKxvzo/cb13/HLA+v/pIsbiRi8+1r+25JI+J1fZ1IMpDlFqbnLIIttb1T70U4GevVkmwcnlWbV6UMuLuxFKL+Kr3UH0OIsV7tPjj797e3KFnqqu1GAFW7qt7Sq2SYHEzpTa1b4YlsHp/ddeC9i5xHGGDTUWJw3Bi73FsfzmIPFS5a+zLQaCN/T5G4X89tPboPPVCgI9TapUFK6daNRKaC6lMzoJ1tSu1gHZ3arKjSsbK2c+mq1XvqJ3v0DpV0vxryiuwovaoXk4Bc2qVBYsHKcVhsTXYVZlL9ATW3Z3ZsuuubNbzHFTa8ZQ1m0z9Rso7cLEmV4pVG3noMxXBSlAVweKDV6rD6BsF9awj7Pm7YnXYmRFHtdTBvtTcNYdRiuVtBRIOnJs73kF0Ya2kWDUfp+knJTD0ATyl44PvWL5iKiSy4O9guMn4RcnJJ86hvRasRuJVVzvTj9nzmjG8cjH36MbqaUttXyWwIpsC3zDP1OaKQFVULEGWg+sqFOAY7XBfpsBkMvYQPPZe7QLfrc/YFq6rOd8dr1f70qbObQzmil8ALwUU967Cn5gJgUWlFFzAAr0AkFuQlIG028VBzEtOqs1Ncmsy475s9hvaXjMfNg1lKtzZutTzvwVaiFLnxVBoG+RyLgwAMCYjldHi2d1uDc3tGrVbqVRYYS4r2VWyhfW169163gKUmAmDpQZA1Gqo2h2w6r6klyBKPcu9kQMK0QcfolI+okjFqFOrUOJDZTVYNGRQjPOGCZyrMpJAphbsiXvKFZnvE+O3jJnb/DU5kgBpLZvAsoMJMnaDdoHI514Ksp2ctCNYrH9q3a3fRp/fBuvKwBRcTLxlJz7RZkewUlDhhytf9Xw+HKzcGyWvt0+AUjvmbmDJXg/XzDAIoMPBYhA/Sa5T37JqnT6jPhsAe3cJ36k3QnLhnmoU6WsKWKlwuMubocDa5YUjtdZsiggMPetMASsVDlmAGYpzd4ydwJKtPkLc/XTQAtwUsDAs9aZCPnDX8TPa46gdFCv1xX120i4Ip4GVUq1dwuEuYKXC4BNqBVzTwEqp1i7hcAew9NOTDYNP5FbTFYsBU6qFfM8IZ3fG2AEsILJQPfEmKKgopyoWA3q5jnwsJRd7EsAnwWLurFlJ3VPfrmZ/t7JQPQIWMd//xliChjcdJf7sSq7vqE9L26fAYl20VpQ52/1m5do7evb1dMVigj4ksmi5N0RAsgsHZLM/rs4Giznb0Faas/9LBurOhig13iNgYYiFBcexICU14g1Su5f6LHwOxtzObr0/Eyw7T+ZbenNG0bDNHk+9BXq4HgMLQ4DJLgqwlJwPSHYny+ElIEv9RZ9pnGj9lnpAovUAKJSoNC9U2240bHw6r7JwPQpWKt9CyUoLitMAzIYAOWKUgo0Ci3miSB6oq3nQBpvssRJUAPYoWBiQgouFvlpcC5gcw0IDJrv/Cs6oqtBPb7BQGzaGFAf7gSVis91QAms1qJYAS3BZOFgwFh1AogBQ14ZJ2nN9F7JeYAkmzVP2RV9EqOfzUtZpRaiWAQtDOFILx72IeglAQBBkUgQcQD/sdhwUUQbbH+2v8j/VV4nNqBDtZIdgqoGdfuyGwRYOAF0lUZf/bPl4KLTGcJ5aRBYSKGoAk4MBSQ6WWsgxgo3nOJv+PXTco74Hi3o8o3/aagy7OQQSz6gnmyIlfdtwiQ06GMOv22rXy4HFArETLQRaUDmYRY84J1WHtgIBx+EkxpKqaCyuOWSHzlP1qGMhBaJWG0tAMfaqoc+DvSRYMjKnXjgfR6IEXmFSMEXvWRUCDqkRIHLoHs7n6Dk2/V/Nd+XQJ5+pXBosjGQxgUhKkipxCI7p6egojHfqAWou3GmezH0noLYBS4ZGAJOS4Sycthpo2CNl8iFVIKncFSj5a3nFkqG2JM9Q7iNH5EochKIpgZ4FG+MAt5L6qL3MA5vtfHc83xIsLTQqlgOqdB+1EHCoG85XDmXzJw8h1zqoBzi04xBA9FsDUc7OXZJ0+cKXW4OFE3OOeYX7O+ZWAmxbsNjRrwBPaQ4onxy1W7klWOzkq+S35LCdnu0aErcE69VDoAd/x5C4HVivFgIjystGOqHw4n/TvbtAEUf4Hb/yNfOJvEXuFhK3UqzSTx694cHhjGc/R+izgj4tRICI2BUJ7bsl8tuAFU3Y7yoaTub7VPSnGr5nAV8EoFwdoIlAupNqbQNWRK0izik5twYoDx6ARZQnN34kd2TT3E0lZrXfAizUKucQe7/VsQAJGB6WluvIBrA26xywImq7i2ptAVbEWcDRAhbt/E83LUDZNhF7BZRKbI+020W1lgcrqlbRHS9HqrwT/ixM9hxQI+ojGyipXzPXWSGtdZzlwYru4qhTrDNJui0QPc95g7RjRc6ZQ0R1d1Ct5cGK7HycEUl+vXN7h0APZu3LBHOIzoN6rWoyo93SYEUXObrTLVgooQeh93XtZwg2CE6PbCagnQFI6xhLgxXZ8QoLkboWrBG5lQeTN0075tW5YImEQ/piQ7U6fnS7ZcGK5kwoD4t05TT7HBg9BKOua4FnLlGllsKNhqSl/2XBqtm1UQgFF32PAsn3G3n5kF2UUqFIOLT1W5w/ss2yYNnFzp0rDNaCNfJt0IPF74o5+1P3BVZ0Y0mxR0LS0veSYEVDgRY1Wl+O5FOAB2DUde1nB+aCI6Nz0uZqcf7INkuCFc1Lap0gsGYk7gKVsTRupNScalRYbUaCUtv3cmDVLKgmW5vH9PpdUPCUyto3Q6kwc4tusBWT+OXAikKiV3McEG0jxRj9YdSDpnEjpYWkZl7aZKuU/wfWRluJhua22QAAAABJRU5ErkJggg==\";\r\nvar bytes = Convert.FromBase64String(str.Split('^')[4]);            \r\nvar ms = new MemoryStream(bytes);\r\npictureBox1.Image = Image.FromStream(ms);\r\n```", "Konwledge_Point": "网络中的流", "Question": ["C#如何将字节流数据显示为图片？", ["^Application^Octer-stream^Base64^„„直方图数据„„”，其中“Application”表示传送的是应用程序数据，“Octer-stream”表示数据为字节流类型， “Base64”表示位图数据的编码方式。", "\n数据：^Application^Octer-stream^Base64^AAEBAgIDAwMEBAQEBQUFBAQEAwMDAgICAgICAgICAgEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="]], "Tag": "算法设计"}
{"Answer": "(1)爬虫有什么用，主要有两个，一个是抓取数据，下载文件；一个是机器人，模拟人对网站操作。\r\n前者你已经基本知道了，后者，比如12306刷票，水军刷评论，操作一些没有提供api接口的网站，比如查询快递进度（现在有接口了，以前没有）\r\n\r\n(2)抓取电商数据有什么用，自动比价，分析，研判。做数据挖掘和分析。\r\n比如说，商品定价贵了，销量比较少，定价便宜了，单品获利少，那么定价多少才能收益最大化？这个定价策略对于个别商品来说，人工可以去估计，但是对于大型电商来说，需要机器学习去分析吧。怎么分析，首先要数据啊。\r\n还有，你要知道哪些商品是爆款吧，哪些商品在短时间内销量大增吧。比如说，12月一到，电暖器销量增加，9月1日，文具销量增加，情人节，鲜花、情趣用品销量增加，这个销量到底增加多少？备货多了，挤压资金，占用场地，备货烧了，供不应求，眼看对手赚钱干着急。那么又需要机器学习了吧。\r\n场景太多了，我只是举例。", "Konwledge_Point": "网络中的流", "Question": ["请教各位大拿，现在流行的网络爬虫有什么用", ["请教各位大拿，现在流行的网络爬虫有什么用，比如python开发的网络爬虫，通过检索电商页面的物品信息、价格、介绍，拿过来有什么实际应用价值吗？", "\n\n", "1.不清楚为什么python爬虫那么火？", "\n\n", "2.不清楚爬虫的真正目的是什么？难道就是为了生成个历史趋势图吗？", "\n\n", "3.它的应用场景是什么？", "\n\n", "请认真说明，喷子勿喷！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这个我们之前做过&amp;#xff0c;从海康威视的摄像头实施传输画面到客户端&amp;#xff0c;格式是rtsp的。客户端是用electron写的。&lt;/p&gt;\n&lt;p&gt;我们第一个方案是用 ffmpeg 在后台将 RTSP 流转成 HLS 流&amp;#xff0c;前端加载 HLS 流。延迟高达 20s 以上&amp;#xff0c;而且还经常失败。而且服务器转码的压力也很大&amp;#xff0c;转上8个流就已经没有资源转其他的了。&lt;/p&gt;\n&lt;p&gt;第二个方案是 RTMP 流&amp;#xff0c;前端用 Flash 插件播放 RTMP 流。延迟也达到了5s以上&amp;#xff0c;而且服务器转码压力还是没有解决。&lt;/p&gt;\n&lt;p&gt;第三个方案是客户端自建 express 服务器&amp;#xff0c;本地调用 ffmpeg 接收 RTSP 流直接转发到 Websocket 中&amp;#xff0c;前端使用 Bilibili 的库 Flv.js 播放。终于能将时间压缩到 2s 。&lt;/p&gt;\n&lt;p&gt;希望能对你有帮助。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["前端播放摄像头实时视频流（H.265）", ["如题，github上有很多播放h265视频的库（h265player、numberwolf/h265web.js、ErosZy/WXInlinePlayer等），但是好像都是播放本地或网络上的文件。不知道如何播放摄像头的视频", "我现在已知的呦摄像头的rtsp，请问怎么处理。"]], "Tag": "算法设计"}
{"Answer": "命令没问题，应该是网络的问题。", "Konwledge_Point": "网络中的流", "Question": ["FFmpeg推送rtmp视频流到nginx的问题", ["FFmpeg将网络摄像机的rtsp视频流转换成rtmp流，然后推送rtmp视频流到nginx上面，然后使用手机播放hls的视频流。", "\n在期间遇到一些问题，总是丢包，我截了个图，请大家帮忙看看是不是我在使用ffmpeg时参数设置的不对啊。", "\n我使用的命令：", "\nffmpeg -i rtsp://admin:12345@172.27.35.56 -vcodec copy -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 640x480  rtmp://172.27.35.2:1935/hls/test2"]], "Tag": "算法设计"}
{"Answer": "调用ffmpeg实现\r\nhttp://blog.csdn.net/hclydao/article/details/36415975\r\nhttp://blog.csdn.net/hclydao/article/details/18546757\r\nhttp://blog.csdn.net/gobitan/article/details/22750719", "Konwledge_Point": "网络中的流", "Question": ["android保存h264流文件为mp4", ["网络预览视频，收到的是H264编码的流，有个保存按钮，可以把收到的留实时保存为H264的流文件，用特定播放器可以播放，想收到流的同时，另外实时生成一个MP4文件，有什么好的方法"]], "Tag": "算法设计"}
{"Answer": "你本地有LiveServer吗？\r\nhttps://github.com/winlinvip/simple-rtmp-server", "Konwledge_Point": "网络中的流", "Question": ["Ubuntu上用FFmpeg将rtsp流转换成rtmp流出错！", ["使用“ffmpeg -i rtsp://admin:12345@172.27.35.55 -f flv rtmp://172.27.35.2/live/stream”命令时出错", "\n其中172.27.35.2是我电脑的IP，172.27.35.55是网络摄像机的IP"]], "Tag": "算法设计"}
{"Answer": "如果是纯 connection 或者 纯OkHttp，响应逻辑，走的是回调驱动，如果业务逻辑复杂，你会面临一个著名的 回调地狱（callback hell）；  \r\n如果你结合了rxjava，当然rxjava 结合 okhttp，和用不用retrofit没有任何关系，但是你既然这么问了，我断定 你写出来的 中间层-桥接层，一定没有retrofit好；  \r\nrxjava基于事件驱动，当然也有用到回调，但是不会陷入回调地狱，这个与纯回调驱动的本质区别；  \r\n但是，如果你对kotlin的协程，有足够的的认识，我想，你是完全可以摆脱rxjava，使用协程并发模型去解决你的业务需求；  \r\n技术选型呢，为业务而生，还有就是，多用著名的开源框架，这样，即使你搞不定，也还有千万网友助阵；", "Konwledge_Point": "网络中的流", "Question": ["android关于网络请求,和异步问题", ["最近很流行RxJava+OkHttp;", "\n我想问的是,目前大部分网络框架中的都有异步网络请求的方法,为什么非得配合Rxjava去进行异步操作呢?"]], "Tag": "算法设计"}
{"Answer": "这个应该是不同版本vlc处理rtmp流时候，处理方式不同造成的，使用播放器potPlayer，这个能很好的处理rtmp流", "Konwledge_Point": "网络中的流", "Question": ["2.2.1版本的vlc播放rtmp流会自动断开，而2.2.1以下的版本都不会", ["2.2.1版本的vlc播放rtmp流会自动断开，而2.2.1以下的版本都不会", "\n通过vlc的 工具-》编码器信息-》统计   这里面可以发现2.2.1版本的vlc播放时候会直接丢掉前面一些帧，比如一次丢掉34帧，然后进行播放，后面都很正常，但是vlc2.2.1 它不会一次直接丢掉前面的34个无效帧，而是直接播放，这样发送数据时候过快，client还未来得及处理，结果client端就直接断开了，但是断开后，rtmp server还是运行的，这时候重新连接client，于是后面可以正常播放了，我想就是第一个I帧残缺引起的错误，我播放的是flv文件，是通过ffmpeg从rtmp://live.hkstv.hk.lxdns.com/live/hks 上面下载下来的", "\nffmpeg -i \"rtmp://live.hkstv.hk.lxdns.com/live/hks\" -vcodec copy -acodec copy  test.flv  。", "\n请教下哪位大神，假设低版本的vlc处理前面的一些帧时候 一次丢掉34帧数据（这里34帧作为参考，可以更多或更少，看文件本身），这样做的好处，和2.2.1版本vlc 却不是这样处理，而是直接播放那些视音频帧，从而断开连接。", "\n\n", "还发现一个问题，就是2.2.1 vlc版本播放rtmp流时候，查看vlc的 工具-》编码器信息-》统计 ，发现视音频的 已解码 已播放 都是0，但是某个时间一下增长到355 355 ，而2.2.1及以下低版本在播放的同时 （视音频的 已解码 已播放） 慢慢增长，请问下 这个是啥情况啊"]], "Tag": "算法设计"}
{"Answer": "按照你的描述,应该可以排除网络问题和程序问题, 那只可能是RK3399的问题了. \r\n可能的原因是RK3399硬件的问题和RK3399系统的问题.\r\n硬件的千兆网接口都是比较成熟的了,出问题的可能性不大.那问题就很可能是软件问题.\r\nfirefly官方的ubuntu系统一直有bug,你可以给他们客服反馈一下,再看以下他们有没有对系统做升级, 如果有,可以试一下新的系统;", "Konwledge_Point": "网络中的流", "Question": ["求助: RK3399 的 TCP 重传无效 问题", ["使用RK3399开发板给服务端的PC发送数据时,总会遇到服务端收不到数据的情况.", "\nRK3399作为TCP的client,PC作为server.", "\n出现问题时,PC端一直收不到ARM的数据,但ARM端没有显示任何异常;15分钟后,ARM放弃该TCP连接,重新建立一个新的TCP连接;", "\n出现异常时,网络正常,能相互ping通;如果另外启动一个client,也能正常发送数据;", "\n使用抓包工具对server端和client端抓包(wireshark和tcpdump),发现两边的抓包结果一致：", "\n\n", "\n", "client和server在正常传输数据；\n\n", "\n", "server端发出 DUP ACK包；", "\n", "client端应答 Fast Retransmission；", "\n", "重复 2，3过程一会儿后，client端发送 TCP Retransmission，server端无应答；", "\n", "client端重新建立连接；\n由于无法上传图片，只能这样描述了。\nPC端尝试更换过工控机和普通的台式机,尝试过windows server和win10和ubuntu16.04, TCP server的程序尝试过自己写的服务端和网络调试助手;\nRK3399更换过3个不同的开发板,也使用过不同的client程序(一个是基于muduo库写的应用程序,一个是基于linux的socket接口写的测试程序)", "\n", "\n", "\n", "详细问题描述在这儿（因为提问的地方没法发图片，只好这样了）：", "https://blog.csdn.net/cdxdrg/article/details/82714541", "\n\n", "后来根据同事的建议，将TCP的每个包大小改到1200byte以内（实际只有800多byte），增加流量控制（每隔200us发一包），仍然有相同的问题。", "\n另外,在这儿: ", "http://dev.t-firefly.com/forum.php?mod=viewthread&tid=13206&extra=&highlight=%CD%F8%C2%E7&page=1", " ", "\n有人提到rk3399的网络有问题,VDD_LOG偏低,但我测试了一下,我的板子的VDD_LOG并无异常.", "\n\n", "麻烦CSDN的高手帮忙解答一下.", "\nQQ: 2775379941  可直接技术交流."]], "Tag": "算法设计"}
{"Answer": "1.需要域名，可以用花生壳等，也可以向 万网 新网 N987 新网互联 35互联 商务中国 中资源 时代互联 等这些购买\r\n2.需要主机或者租电信的网络\r\n3.发布网站，采用域名，会重定向你的计算机，就可以访问了\r\n\r\n防止网站攻击可以采用防火墙，硬件的比较安全", "Konwledge_Point": "网络中的流", "Question": ["如何在网络上发布一个网站?希望懂的人帮帮忙", ["我想把自己的网站发布到网上,具体需要怎么做呢?", "\n还有,发布的网站是不是需要做些必要工作,以防止网站很容易被攻击之类的?"]], "Tag": "算法设计"}
{"Answer": "网络视频，一般采用 RTP 或 RTSP 协议，还是可以检测的。\r\n就算还有其它流媒体，通过网络抓包分析后，也是可以获取到的。不过，需要你对流媒体的格式比较清楚，否则就算抓到流媒体的数据，你也不认识它。", "Konwledge_Point": "网络中的流", "Question": ["关于媒体流侦测的问题", ["浅浅的问一句：有人知道类似vso downloader之类的网络视频下载软件的原理吗？"]], "Tag": "算法设计"}
{"Answer": "http://blog.chinaunix.net/uid-22753395-id-1769787.html", "Konwledge_Point": "网络中的流", "Question": ["Argus                     ", ["A data stream is a real-time, continuous, ordered sequence of items. Some examples include sensor data, Internet traffic, financial tickers, on-line auctions, and transaction logs such as Web usage logs and telephone call records. Likewise, queries over streams run continuously over a period of time and incrementally return new results as new data arrives. For example, a temperature detection system of a factory warehouse may run queries like the following.", "\n\n", "Query-1: ��Every five minutes, retrieve the maximum temperature over the past five minutes.��", "\nQuery-2: ��Return the average temperature measured on each floor over the past 10 minutes.��", "\n\n", "We have developed a Data Stream Management System called Argus, which processes the queries over the data streams. Users can register queries to the Argus. Argus will keep the queries running over the changing data and return the results to the corresponding user with the desired frequency.", "\n\n", "For the Argus, we use the following instruction to register a query:", "\n\n", "Register Q_num Period", "\n\n", "Q_num (0 < Q_num <= 3000) is query ID-number, and Period (0 < Period <= 3000) is the interval between two consecutive returns of the result. After Period seconds of register, the result will be returned for the first time, and after that, the result will be returned every Period seconds.", "\n\n", "Here we have several different queries registered in Argus at once. It is confirmed that all the queries have different Q_num. Your task is to tell the first K queries to return the results. If two or more queries are to return the results at the same time, they will return the results one by one in the ascending order of Q_num.", "\n\n", "Input", "\n\n", "The first part of the input are the register instructions to Argus, one instruction per line. You can assume the number of the instructions will not exceed 1000, and all these instructions are executed at the same time. This part is ended with a line of ��#��.", "\n\n", "The second part is your task. This part contains only one line, which is one positive integer K (<= 10000).", "\n\n", "Output", "\n\n", "You should output the Q_num of the first K queries to return the results, one number per line.", "\n\n", "Sample Input", "\n\n", "Register 2004 200", "\nRegister 2005 300", "\n#", "\n5", "\nSampleOutput", "\n\n", "2004", "\n2005", "\n2004", "\n2004", "\n2005"]], "Tag": "算法设计"}
{"Answer": "如果需要公网访问，则防火墙要关闭，并且监听端口要打开。不过一般不建议开启非通用端口，可以在80或者443上监听。", "Konwledge_Point": "网络中的流", "Question": ["C# HttpListener 在本机测试有用，在服务器上运行，客户端无法连接!", ["C# HttpListener 在本机测试有用，在服务器上运行，客户端无法连接", "\n\n", "if (!HttpListener.IsSupported)", "\n            {", "\n                throw new System.InvalidOperationException(", "\n                    \"使用 HttpListener 必须为 Windows XP SP2 或 Server 2003 以上系统！\");", "\n            }", "\n            // 注意前缀必须以 / 正斜杠结尾", "\n            string[] prefixes = new string[] { \"http://localhost:49152/\" };", "\n            // 创建监听器.", "\n            HttpListener listener = new HttpListener();", "\n            // 增加监听的前缀.", "\n            foreach (string s in prefixes)", "\n            {", "\n                listener.Prefixes.Add(s);", "\n            }", "\n            // 开始监听", "\n            listener.Start();", "\n            Console.WriteLine(\"监听中...\");", "\n            while (true)", "\n            {", "\n                // 注意: GetContext 方法将阻塞线程，直到请求到达", "\n                HttpListenerContext context = listener.GetContext();", "\n                // 取得请求对象", "\n                HttpListenerRequest request = context.Request;", "\n                Console.WriteLine(\"{0} {1} HTTP/1.1\", request.HttpMethod, request.RawUrl);", "\n                Console.WriteLine(\"Accept: {0}\", string.Join(\",\", request.AcceptTypes));", "\n                Console.WriteLine(\"Accept-Language: {0}\",", "\n                    string.Join(\",\", request.UserLanguages));", "\n                Console.WriteLine(\"User-Agent: {0}\", request.UserAgent);", "\n                Console.WriteLine(\"Accept-Encoding: {0}\", request.Headers[\"Accept-Encoding\"]);", "\n                Console.WriteLine(\"Connection: {0}\",", "\n                    request.KeepAlive ? \"Keep-Alive\" : \"close\");", "\n                Console.WriteLine(\"Host: {0}\", request.UserHostName);", "\n                Console.WriteLine(\"Pragma: {0}\", request.Headers[\"Pragma\"]);", "\n                // 取得回应对象", "\n                HttpListenerResponse response = context.Response;", "\n                // 构造回应内容", "\n                string responseString", "\n                    = @\"", "From HttpListener Server", "Hello, world.", "\";", "\n                // 设置回应头部内容，长度，编码", "\n                response.ContentLength64", "\n                    = System.Text.Encoding.UTF8.GetByteCount(responseString);", "\n                response.ContentType = \"text/html; charset=UTF-8\";", "\n                // 输出回应内容", "\n                System.IO.Stream output = response.OutputStream;", "\n                System.IO.StreamWriter writer = new System.IO.StreamWriter(output);", "\n                writer.Write(responseString);", "\n                // 必须关闭输出流", "\n                writer.Close();\n\n", "            if (Console.KeyAvailable)\n                break;\n        }\n        // 关闭服务器\n        listener.Stop();\n"]], "Tag": "算法设计"}
{"Answer": "我是通过tcp的recv去接收数据的，这跟用udp的recvfrom去接收，有什么不同。\r\n我recv到得数据跟标准的rtp包有差别，不只是不是我的接收数据有问题\r\n附上代码：\r\nwhile(receive_bytes = recv(*(pthread_t*)p, recvbuf,\r\n        sizeof(recvbuf)-1, 0)&gt;0)\r\n\t{\r\n        receive_bytes = strlen(recvbuf);\r\n\t\t//printf(\"receive_bytes=%d,strlen(recvbuf)=%d\\n\",receive_bytes,strlen(recvbuf));\r\n\t\t//printf(\"%s\\n\",recvbuf );\r\n        if (strncasecmp(recvbuf,\"RTSP/1.0 200 OK\",15)==0)\r\n\t\t{\r\n\t\t\tsend_ok = 1;\r\n\t\t\tstrtok_ok++;\r\n            printf(\"strtok_ok=%d\\n\",strtok_ok );\r\n\t\t\tif (strtok_ok == 3)//切出session\r\n\t\t\t{\r\n                printf(\"strtok the session\\n\");\r\n\t\t\t\tstrcpy(session,STRTOK(recvbuf));\r\n                printf(\"session=%s\\n\",session );\r\n\t\t\t}\r\n\t\t\telse if (strtok_ok == 4)//切出rtp数据包\r\n\t\t\t{\r\n                printf(\"recving the rtp data\\n\");\t\t\t\t\r\n\t\t\t\tconnet_finish++;\r\n\t\t\t}\r\n\t\t}", "Konwledge_Point": "网络中的流", "Question": ["采用rtsp与网络摄像头对接后，怎么处理网络摄像头发送的rtp数据，才能提出h264视频流？", ["我想问的是：怎么处理网络摄像头的这些数据，才能提出h264视频流？", "\n我把数据放去rtp解包生成h264文件并不能vlc播放。", "\n解包也有错误，解了3分钟，recv到得数据只有3个字节就出现段错误了。", "\n版本号也是不定的，有为0，2,3。", "\n流媒体新人，求大神多指导！！！"]], "Tag": "算法设计"}
{"Answer": "我有碰到过图像失真问题，首先你的弄清楚图片的格式，抓取的如果就是 jpeg格式的话 720*480 能抓到10张还是网速比较快的，\r\n建议先将c里面的图片抓下来存储到文件中，然后看打开是否正常，以排除不是图片本身问题", "Konwledge_Point": "网络中的流", "Question": ["Android里通过C去抓取网络摄像机的Bitmap显示", ["Android里通过C去抓取网络摄像机的图像，1秒钟返回10帧，", "\n也就是10个Bitmap(分辨率：720*480);", "\nAndroid应用层，用ImageView去setImageBitmap显示，画面会花屏、失真；", "\n用surfaceview去draw的话，也是这样；", "\n我想问：应该怎样去处理这些bitmap才不会让图像失真呢？在此先谢谢各位了。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;那叫ajax&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在以瀑布流方式翻页的网站,使用scrapy网络爬虫,但是只爬取了第一页数据,没有爬取第二页.", ["import scrapy\n\n", "from", " news.items import NewsItem\n\n\n", "# https://www.gelonghui.com/api/channels/web_home_page/articles/v8?timestamp=1630749332&loaded=15", "\n\nclass AbcSpider(scrapy.Spider):\n    name = ", "'abc'", "\n    allowed_domains = [", "'gelonghui.com'", "]\n    start_urls = [", "'http://gelonghui.com'", "]\n\n    def parse(self, response):\n        item = NewsItem()\n        elements = response.css(", "'.detail-right'", ")\n\n        ", "for", " element ", "in", " elements:\n            item[", "'title'", "] = element.css(", "'h2::text'", ").extract_first()\n            yield item\n\n        url_ajax = ", "'https://www.gelonghui.com/api/channels/web_home_page/articles/v8?'", "\n        data = {\n            ", "'timestamp'", ": ", "'1630749332'", ",\n            ", "'loaded'", ": ", "'15'", "\n        }\n        yield scrapy.FormRequest(", "url", "=url_ajax,\n                                 ", "method", "=", "'get'", ",\n                                 ", "formdata", "=data,\n                                 ", "dont_filter", "=", "True", ",\n                                 ", "callback", "=self.parse)\n\n\n", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.utils.", "log", "] INFO: Scrapy ", "2.5", ".", "0", " started (bot: news)\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.utils.", "log", "] INFO: Versions: lxml ", "4.6", ".", "3.0", ", libxml2 ", "2.9", ".", "4", ", cssselect ", "1.1", ".", "0", ", parsel ", "1.6", ".", "0", ", w3lib ", "1.22", ".", "0", ", Twisted ", "21.2", ".", "0", ", Python ", "3.9", ".", "1", " (v3.", "9.1", ":", "1", "e5d33e9b9, Dec  ", "7", " ", "2020", ", ", "12", ":", "44", ":", "01", ") - [Clang ", "12.0", ".", "0", " (clang-", "1200.0", ".", "32.27", ")], pyOpenSSL ", "20.0", ".", "1", " (OpenSSL ", "1.1", ".", "1", "l  ", "24", " Aug ", "2021", "), cryptography ", "3.4", ".", "8", ", Platform macOS-", "11.5", ".", "2", "-x86_64-i386-", "64", "bit\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.utils.", "log", "] DEBUG: Using reactor: twisted.internet.selectreactor.SelectReactor\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.crawler] INFO: Overridden settings:\n{", "'BOT_NAME'", ": ", "'news'", ",\n ", "'NEWSPIDER_MODULE'", ": ", "'news.spiders'", ",\n ", "'ROBOTSTXT_OBEY'", ": ", "True", ",\n ", "'SPIDER_MODULES'", ": [", "'news.spiders'", "],\n ", "'USER_AGENT'", ": ", "'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) '", "\n               ", "'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 '", "\n               ", "'Safari/537.36'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.extensions.telnet] INFO: Telnet Password: ", "8", "ec24b696530a0ca\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled extensions:\n[", "'scrapy.extensions.corestats.CoreStats'", ",\n ", "'scrapy.extensions.telnet.TelnetConsole'", ",\n ", "'scrapy.extensions.memusage.MemoryUsage'", ",\n ", "'scrapy.extensions.logstats.LogStats'", "]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled downloader middlewares:\n[", "'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.retry.RetryMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.cookies.CookiesMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.stats.DownloaderStats'", "]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled spider middlewares:\n[", "'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware'", ",\n ", "'scrapy.spidermiddlewares.offsite.OffsiteMiddleware'", ",\n ", "'scrapy.spidermiddlewares.referer.RefererMiddleware'", ",\n ", "'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware'", ",\n ", "'scrapy.spidermiddlewares.depth.DepthMiddleware'", "]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled item pipelines:\n[]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.core.engine] INFO: Spider opened\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.extensions.logstats] INFO: Crawled ", "0", " pages (at ", "0", " pages/", "min", "), scraped ", "0", " ", "items", " (at ", "0", " ", "items", "/", "min", ")\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.extensions.telnet] INFO: Telnet console listening on ", "127.0", ".", "0.1", ":", "6023", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//gelonghui.com/robots.txt> from <GET http://gelonghui.com/robots.txt>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//www.gelonghui.com/robots.txt> from <GET https://gelonghui.com/robots.txt>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.core.engine] DEBUG: Crawled (", "200", ") <", "GET", " https:", "//www.gelonghui.com/robots.txt> (referer: None)", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//gelonghui.com/> from <GET http://gelonghui.com>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//www.gelonghui.com/> from <GET https://gelonghui.com/>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] DEBUG: Crawled (", "200", ") <", "GET", " https:", "//www.gelonghui.com/robots.txt> (referer: None)", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] DEBUG: Crawled (", "200", ") <", "GET", " https:", "//www.gelonghui.com/> (referer: None)", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'元宇宙，人类最后的迁徙'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'Jackson Hole后的美联储货币政策冷思考：预期引导or相机抉择'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'重磅！北交所上市、交易等三大规则来了！七大要点看这里！'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'短空是多短，长多又是多长'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'广发郭磊：九问九答宏观经济'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'房地产经济近况如何？'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'美国50年公平与效率摇摆史的产业启示'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'宋雪涛：宏观研究需要新范式'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'机构席位大宗交易活跃度下降，这些个股却被大幅扫货……'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'永安依旧“最赚钱”，混沌天成“栽了跟头”！73家期货公司上半年业绩出炉，净利最高暴增1368.68%'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'大动作！微信聊天记录付费云存储？苹果每年180元，安卓130元，你会买单吗？'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'能源新基建：绿色复苏新路径'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'食品饮料是如何从天堂到地狱的——速食&休闲篇'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'多部委透露新能源汽车重大政策动向：进一步提高锂、钴、镍保障体系'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'人工钻石的疯狂上位之路'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.downloadermiddlewares.robotstxt] DEBUG: Forbidden by robots.txt: <", "GET", " https:", "//www.gelonghui.com/api/channels/web_home_page/articles/v8?timestamp=1630749332&loaded=15>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] INFO: Closing spider (finished)\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.statscollectors] INFO: Dumping Scrapy stats:\n{", "'downloader/exception_count'", ": ", "1", ",\n ", "'downloader/exception_type_count/scrapy.exceptions.IgnoreRequest'", ": ", "1", ",\n ", "'downloader/request_bytes'", ": ", "2257", ",\n ", "'downloader/request_count'", ": ", "7", ",\n ", "'downloader/request_method_count/GET'", ": ", "7", ",\n ", "'downloader/response_bytes'", ": ", "71423", ",\n ", "'downloader/response_count'", ": ", "7", ",\n ", "'downloader/response_status_count/200'", ": ", "3", ",\n ", "'downloader/response_status_count/301'", ": ", "4", ",\n ", "'elapsed_time_seconds'", ": ", "0.928904", ",\n ", "'finish_reason'", ": ", "'finished'", ",\n ", "'finish_time'", ": datetime.datetime(", "2021", ", ", "9", ", ", "5", ", ", "11", ", ", "17", ", ", "6", ", ", "584573", "),\n ", "'httpcompression/response_bytes'", ": ", "313699", ",\n ", "'httpcompression/response_count'", ": ", "3", ",\n ", "'item_scraped_count'", ": ", "15", ",\n ", "'log_count/DEBUG'", ": ", "23", ",\n ", "'log_count/INFO'", ": ", "10", ",\n ", "'memusage/max'", ": ", "222773248", ",\n ", "'memusage/startup'", ": ", "222773248", ",\n ", "'request_depth_max'", ": ", "1", ",\n ", "'response_received_count'", ": ", "3", ",\n ", "'robotstxt/forbidden'", ": ", "1", ",\n ", "'robotstxt/request_count'", ": ", "2", ",\n ", "'robotstxt/response_count'", ": ", "2", ",\n ", "'robotstxt/response_status_count/200'", ": ", "2", ",\n ", "'scheduler/dequeued'", ": ", "4", ",\n ", "'scheduler/dequeued/memory'", ": ", "4", ",\n ", "'scheduler/enqueued'", ": ", "4", ",\n ", "'scheduler/enqueued/memory'", ": ", "4", ",\n ", "'start_time'", ": datetime.datetime(", "2021", ", ", "9", ", ", "5", ", ", "11", ", ", "17", ", ", "5", ", ", "655669", ")}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] INFO: Spider closed (finished)\n\n\n> \n> \n> \n> \n> \n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There are several ways to play audio in browser:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;1) Most usual flash-plugin:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;With flash you can handle raw PCM samples and play them but in that case you need at least basic knowledge of flash API's and ActionScript 3.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;2) HTML5 Video/Audio API's (Javascript), but specifications for these are not finished yet:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;With current API's you cannot handle PCM directly without media container. Google for containers currently supported by browsers, different browsers support different containers and different codecs.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;3) Other plugins like Windows Media Player:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Maybe you will find, plugin suitable for you but take in account, if you plan to stream your sound to large audience then you better go with popular plugin like flash.&lt;/p&gt;\n\n&lt;p&gt;Summary:&lt;/p&gt;\n\n&lt;p&gt;Sending PCM samples over network is much slower then compressed audio, but as far as you are in local network this should not be a problem.&lt;/p&gt;\n\n&lt;p&gt;One solution is, wrap your samples on server(with PHP), you should choose media container accordingly to client side you choose.&lt;/p&gt;\n\n&lt;p&gt;Or learn little bit of flash and make flash swf that can play PCM samples.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "网络中的流", "Question": ["通过本地网络中的服务器的样本来流式传输音频", ["\n\n", "Excuse me, if my question is silly, but I'm a beginner at web-developing. I am trying to write codes with php and javascript and can't find an answer or some example how to solve my problem.", "\n\n", "The problem is to send audio samples (not a file) from server to client and to play this audio on client.", "\n\n", "I will be very grateful for any help.", "\n    "]], "Tag": "算法设计"}
{"Answer": "都用ijk播放器吧，都用ijk播放器吧，", "Konwledge_Point": "网络中的流", "Question": ["急求,我现在Android 集成Vitamio直播网络视频一段时间就停止,点击也不能继续播放", ["Android 集成Vitamio  直播网络视频m3u8流,一段时间就停止,点击也不能继续播放,必须退出activity页面再进来这个activity播放界面之后进来才能继续播放,", "\n.开始我们怀疑是缓冲问题,为了证实是否是缓冲问题,我们获取缓冲监听OnBufferingUpdateListener 和setOnInfoListener,打log,发现不是在缓冲状态下,而是正常播放状态下卡住.急求!!"]], "Tag": "算法设计"}
{"Answer": "写入的时候：bos.write(buf,0,buf.length);这句话错了，应该是  bos.write(buf,0,i);最后一次只能读取有效长度，不能读取整个数组的长度，因为最后一次数组不会完全读完，有空的。", "Konwledge_Point": "网络中的流", "Question": ["用IO流下载网上的图片，可是图片很模糊，不知道怎么回事。", ["有没有大神帮忙看下，问题在哪，不需要提供其他方法，只是想知道这个的问题在哪？", "\n\n", " package socket.url;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class CopyOfDownLoad {\n    public static void main(String[] args) {\n        // 相关的所有数据流\n        InputStream is = null;\n        BufferedInputStream bis =null;\n        OutputStream os = null;\n        BufferedOutputStream bos = null;\n        try {\n            // 1、想要下载资源的网络地址和要保存的路径\n            // 资源地址\n            String string = \"http://file28.mafengwo.net/M00/EF/F3/wKgB6lTG9UqAG0o2AA2IG9Yw6Og16.groupinfo.w665_500.jpeg\";\n            // 保存路径\n            String pathname = \"D:/sxtjava/图片.jpg\";\n            URL url = new URL(string);\n            // 2、通过openStream()获取字节输入流，进行读取；创建一个流用于写入本地文件\n            // 读取\n//          is = url.openStream();// 获取字节输入流\n            //或者\n            is = url.openConnection().getInputStream();\n            bis = new BufferedInputStream(is);\n            byte[] buf = new byte[1024];\n            // 写入\n            File file = new File(pathname);\n            os = new FileOutputStream(file);\n            bos = new BufferedOutputStream(os);\n            // 3、读取（下载）、写入（本地保存）\n            int lenth= bis.read(buf);\n            // 读取的不为空就继续读取\n            while (lenth != -1) {\n                //写入\n                bos.write(buf,0,buf.length);\n                bos.flush();//刷新\n                lenth= bis.read(buf);\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally { \n            // 4、关闭资源\n            try {\n                if (is != null) {\n                    is.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (bis != null) {\n                    bis.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                bos.flush();//刷新\n                if (bos != null) {\n                    bos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"保存成功！\");\n        }\n    }\n}\n![图片说明](https://img-ask.csdn.net/upload/201707/15/1500119290_3254.jpg)\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;已解决&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["wpf webclient下载http图片资源问题怎么解决", ["在wpf使用webclient的downloadfile，下载完之后打开之后显示图片格式不对，没有显示图片就很奇怪。望能解决。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;没有指定字符集啊&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["java发起HttpURLConnection下载zip文件，下下来后不是zip，内容是乱码", ["\n", "\n", "这是代码，请问是哪里出了问题", "https://www.cnblogs.com/tiancai/p/7942201.html", "这是代码来源"]], "Tag": "算法设计"}
{"Answer": "除了对于每帧数据的压缩，还有帧和帧之间的压缩。也就是说关键帧保存的是完整的一张图片，而其它的帧则只保存和关键帧的差异，这样又省了很多。\r\n\r\n具体的算法，可以看相关数字信号处理的教材以及mpeg规范文档。", "Konwledge_Point": "网络中的流", "Question": ["一般的网络视频对话程序是怎么压缩数据的呢？", ["我的两个摄像头分辨率都是640乘480，压缩方式YUV2。也就是说一帧图像有600K大小", "\n视频要能动的话一秒至少要20多帧，这么算下来需要的网速要144Mbps", "\n如果压缩成JPG的话我实验了下，一帧能缩小到大概20分之一，网速还是要7Mbps", "\n但实际的视频通话数据量明显没这么大，于是我想问下视频对话究竟是怎么压缩数据的呢？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这样写有点问题&lt;br /&gt;首先&amp;#xff0c;你说你在缓存中可以拿到相应的播放地址src&lt;br /&gt;那么请问&amp;#xff0c;你的那个videoLists是定义在哪儿的呢&amp;#xff1f;也是定义在return中吗&amp;#xff1f;如果是&amp;#xff0c;那么你这样写就不正确&amp;#xff0c;return中的this.拿不到return里面定义的变量&lt;br /&gt;其次&amp;#xff0c;如果你已经存到缓存里面的话&amp;#xff0c;你可以在return里面的src那里通过从缓存里面拿而不是this.&amp;#xff0c;缓存可以是sessionStorage或者cookie或者localStorage&amp;#xff0c;不知道存在哪一个里面&amp;#xff0c;还是直接放在全局的作用域底下&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["vue-video-player视频播放获取地址动态播放的问题", ["vue-video-player 中点击视频根据id 进行动态播放。", "目前已经把需要播放的videoList放置缓存中 ，并且可以在页面拿到值了，但是没办法无法把属性放到插件中进行播放"]], "Tag": "算法设计"}
{"Answer": "你所谓的按照GBK编码方式读取，关键问题在于你的文件本身是不是按照GBK来写的？如果本身就是GBK的文件，你读取后封装为XML，传输到另一端后，直接写入文件就可以了，不需要还原。\r\n但是如果你原来的文件不是GBK方式写的，那你按GBK读取的话可能会产生一些数据遗失、错误等情况，那样就没有办法还原了。\r\n建议你不要用什么方式，直接按字节流读取，传输后也不需要什么还原，直接按字节流写回文件。", "Konwledge_Point": "网络中的流", "Question": ["求助：JAVA二进制数据与字符串转换问题", ["从文件中按照GBK编码方式读取二进制流，将二进制数据封装到XML数据包中，经过", "\n网络传输到另一端后，再将二进制数据按照GBK编码写回到某一文件中，二进制数据", "\n能够获取到，但是经过字符串处理后，到另一端如何还原回去？大神，求破！"]], "Tag": "算法设计"}
{"Answer": "byte[] buff = new byte[1024];  \r\n            //Receive the file, write it out.  \r\n            int data;  \r\n            while ( -1 != ( data = is.read(buff) ) )  \r\n            {  \r\n                fos.write( buff,0,data );  \r\n            }  \r\n\r\n你这里读到的不一定就是1024，特别是最后一次，不太可能是1024的整数，所以你写出的时候，应该以读到的为准来写出，而不是把整个buff都写出", "Konwledge_Point": "网络中的流", "Question": ["Java TCP文件服务器，下载到的文件和原文件大小不一致", ["本人编程新手，要求用java写一个tcp文件服务器，客户端向服务器端发送请求，下载服务器端的文件。我出现的问题是：客户端从服务器端下载到的文件大小不一致，而且下载到的文件也带不开，真诚请教解决办法。", "\n[code=\"java\"]", "\n//客户端代码", "\nimport java.io.FileOutputStream;", "\nimport java.io.IOException;", "\nimport java.io.InputStream;", "\nimport java.io.OutputStream;", "\nimport java.io.BufferedOutputStream;", "\nimport java.io.DataInputStream;", "\nimport java.io.DataOutputStream;", "\nimport java.net.InetAddress;", "\nimport java.net.InetSocketAddress;", "\nimport java.net.Socket;", "\nimport java.util.Scanner;", "\n\n", "public class SendFileClient", "\n{", "\n\n", "public static void main( String[] args ) throws IOException\n{\n    // TODO Auto-generated method stub\n\n    System.out.println( \"This is client\" );\n    byte[] buf = new byte[1024];\n\n    System.out.println(\"Please input the Ip Address that you connect\");\n    //Create the scanner s1 to let user input the server IP address\n    Scanner s1 = new Scanner(System.in);\n    String ip = s1.nextLine();\n    System.out.println(\"Please input the port\");\n    //Create the scanner s2 to let user input the server port\n    Scanner s2 = new Scanner(System.in);\n    String portStr = s2.nextLine();\n    //Convert the String portStr to integer\n    int port = Integer.parseInt(portStr);\n\n    try\n    {\n        // Create the socket\n        Socket s = new Socket();\n        s.connect ( new InetSocketAddress (ip,port ));\n        //Create the outstream\n        OutputStream os = s.getOutputStream( );\n        //Create the inputstream\n        InputStream is = s.getInputStream( );\n        //Read the buf though the inputstream\n        int len = is.read( buf );\n        //Print out the data by converting it to a String\n        System.out.println( new String( buf, 0, len ) );\n        System.out.println(\"Please input the request\");\n        //Create scanner s3 to Let the user input the request\n        //The request format has to be:Send filename\n        Scanner s3 = new Scanner(System.in);\n        String req = s3.nextLine();\n        os.write( req.getBytes( ) );\n        //Read the data to buf though the inputstream\n        int len2 = is.read(buf);\n        String file = new String(buf,0,len2);\n        System.out.println(\"Wait...\");\n        //Create the dataoutputstream for receiving the file\n       DataOutputStream fos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));\n        byte[] buff = new byte[1024];\n        //Receive the file, write it out.\n        int data;\n        while ( -1 != ( data = is.read(buff) ) )\n        {\n            fos.write( buff );\n        }\n\n\n\n\n        System.out.println(\"\\nFile has been received successfully.\");\n        fos.flush();\n        fos.close();\n        //Close the outputstream\n        os.flush();\n        os.close();\n        //Close the inputstream\n        is.close();\n        //Close the socket\n        s.close( );\n    } catch ( Exception ex )\n    {\n        ex.printStackTrace();\n    }\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "[code=\"java\"]", "\nimport java.net.*;", "\nimport java.io.*;", "\n\n", "//服务器端代码", "\npublic class SendFileSocket extends Thread", "\n{", "\n    /**", "\n     * @param args", "\n     */", "\n    public static void main( String[] args )", "\n    {", "\n    //Start the server", "\n        server( );", "\n\n", "}\n//Set the Server port =10000\nprivate static final int  PORT  = 10000;\nprivate Socket  s;\n\npublic SendFileSocket( Socket s )\n{\n//Create the socket object\n    this.s = s;\n}\n\npublic void run()\n{\n    try\n    {\n    //Create the outputstream\n        OutputStream os = s.getOutputStream( );\n        //Create the inputstream\n        InputStream is = s.getInputStream( );\n        os.write( \"Hello,welcome you!\".getBytes( ) );\n        //Define the data byte as buf\n        byte[] buf = new byte[10240];\n        while ( true )\n        {\n            //Read the buf though the inputstream\n            int len = is.read( buf );\n            String revStr = new String( buf, 0, len );\n            //Print out the request information from the client\n            System.out.println( \"This client wants to \"+revStr );\n            String fileName;\n            //The requet should starts with Send\n            if ( revStr.startsWith( \"Send \" ))\n\n            {\n                //Get the file name from the request by using\n                //The method getFileName\n                fileName = getFileName( revStr );\n                //Print out the filename\n                System.out.println( \"The file name is :\"+fileName);\n                //Write out the filename though the outputstream \n                os.write(fileName.getBytes());\n                System.out.println(\"Start to send file \" +fileName);\n                String filePath = \"C:/\";\n                String file = (filePath+fileName);\n                //Combine the filepath and the filename\n                File fi = new File(file);\n               //Declare a datainputstream\n               DataInputStream fins = new DataInputStream(\n                    new BufferedInputStream(new FileInputStream(file)));\n                DataOutputStream ps = new DataOutputStream(s.getOutputStream());\n                //Start to read the data from the file\n                byte[] buff = new byte[10240];\n                int data;\n                while ( -1 != ( data = fins.read(buff) ) )\n                    {\n                        //send the file data to the client\n                        ps.write( buff );\n\n                    }\n                    System.out.println(\"Transfer complete.\");\n                    ps.flush();\n                    ps.close();\n                    break;\n\n             }\n                else{\n\n                    System.out.println(\"Request is wrong\");\n                    System.exit(0);\n\n\n                }\n\n        }\n\n\n        os.flush();\n        //Close the outputstream\n        os.close( );\n        //Close the inputstream\n        is.close( );\n        //Close the socket\n        s.close( );\n    } catch ( Exception e )\n    {\n    //Catch the exception\n        e.printStackTrace( );\n    }\n\n}\n\n/* \n * Function：Get the filename from the request which is sent from the client\n * param：The request from the client has to start with\"Send\"\n * Return: The filename\n */\nprivate String getFileName( String revStr )\n{\n    String fileName;\n    fileName = revStr.substring( 4 );\n    while ( fileName.startsWith( \" \" ) )\n    {\n        fileName = fileName.substring( 1 );\n    }\n    return fileName;\n}\n\npublic static void server()\n{\n    System.out.println( \"This is server\" );\n    try\n    {\n        ServerSocket ss = new ServerSocket( PORT );\n        int count = 0;\n        while ( true )\n        {\n            //Create a socket for waiting for the client connect\n            Socket s = ss.accept( );\n            //Count the client and print out\n            count++ ;\n            System.out.println( \"This is the \" + count + \"'st client connetion!\" );\n            //Start new thread for this socket\n            new Thread(new SendFileSocket(s)).start();\n\n        }\n    } catch ( Exception ex )\n    //Catch the exception\n    {\n        ex.printStackTrace( );\n    }\n}\n", "\n\n", "}", "\n\n", "[/code]"]], "Tag": "算法设计"}
{"Answer": "[quote]恩 有点明白了，貌似传的时候有一定的格式，有一些token和一些  boundary分隔符之类的数据，是这样的吗？    请继续指教    我该怎么在http里接受post过来的图片另存呢[/quote]\r\n不好意思,最近比较忙,没有及时答复\r\n\r\n我做了一个简单的实验, 下面列出代码, 这些代码在我机器上运行能得到正确的效果:\r\n1) 使用 WireShark 可以接获 POST 数据, 如下图\r\n[img]http://dl.iteye.com/upload/picture/pic/66426/057aae68-eba3-3ba3-99f0-72eaece03198.jpg[/img]\r\n\r\n这里截获的是人人网上传照片的POST数据, 从图片可以看出 POST Image 数据的一些基本格式\r\n\r\n2) 但是这个格式是抽象好的, 我就通过代码打印出 POST 的数据, 然后针对性地分析这些数据, 得到正确的图片, 主要代码如下:\r\n\r\nprivate void doFileUpload(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) \r\n\tthrows IOException {\r\n\t\tString tempFile = String.format(\"%s%d.jpg\", fileRoot, new Random().nextInt());\r\n\t\tlogger.debug(\"file name:\" + tempFile);\r\n\t\tlogger.debug(\"before transferring bytes in Servlet\");\r\n\t\tFile file = new File(tempFile);\r\n\t\tlogger.debug(\"file path: \" + file.getAbsolutePath());\r\n\t\tlogger.debug(\"file size: \" + file.length());\r\n\t\t\r\n\t\tOutputStream outputStream = new FileOutputStream(file);\r\n\t\tbyte[] bytes = new byte[1024];\r\n\t\tint count = -1;\r\n\t\tServletInputStream in = request.getInputStream();\r\n\t\tString line = null;\r\n\t\tboolean flag = false;\r\n\t\twhile ((count = in.read(bytes)) &gt; 0) {\r\n\t\t\tint start = 0;\r\n\t\t\t\r\n\t\t\tline = new String(bytes, 0, count);\r\n\t\t\tlogger.debug(\"get bytes: \" + count);\r\n\t\t\tlogger.debug(line);\r\n\t\t\tif (line.startsWith(\"-----------------------------\")) {\r\n\t\t\t\tint ndxContentDisp = line.indexOf(\"Content-Disposition\");\r\n\t\t\t\tint ndxContentType = line.indexOf(\"Content-Type\", ndxContentDisp);\r\n\t\t\t\tif (-1 != ndxContentDisp &amp;&amp; -1 != ndxContentType) {\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t\tstart = line.indexOf(\"\\r\\n\", ndxContentType);\r\n\t\t\t\tstart = start + 4;\r\n\t\t\t\tlogger.debug(\"****** flag of start *******: \" + flag + \", start index: \" + start);\r\n\t\t\t} else if (line.startsWith(\"Content-Disposition\")) {\r\n\t\t\t\tflag = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (line.startsWith(\"Content-Type\")) {\r\n\t\t\t\tflag = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (flag) {\r\n\t\t\t\toutputStream.write(bytes, start, count - start);\r\n\t\t\t}\r\n\t\t}\r\n\t\toutputStream.flush();\r\n\t\toutputStream.close();\r\n\t\tlogger.debug(\"after transferring bytes in Servlet\");\r\n\t}\r\n\r\n\r\n客户端页面代码很简单, 如下\r\n\r\n&lt;form action=\"up.do\" method=\"POST\" enctype=\"multipart/form-data\" name=\"upForm\"&gt;\r\n&lt;input type=\"file\" name=\"picPath\" /&gt;\r\n&lt;input type=\"submit\" name=\"submitBtn\" value=\"submit\" /&gt;\r\n&lt;/form&gt;\r\n\r\n\r\n在 2) 的代码中, 我很有针对性地处理了 POST 的数据, 其中图片的数据是包含在一定的边界之中的, 并非InputStream的所有数据. 分清楚这个边界, 取得正确的图片数据, 就能得到正确的结果.\r\n\r\n具体的 POST multipart 数据的格式, 还要参考 HTTP Protocol 的对应部分: http://www.ietf.org/rfc/rfc2388.txt\r\n\r\n使用 Apache FileUpload 组件, 可以省去处理这些处理细节", "Konwledge_Point": "网络中的流", "Question": ["网络传输文件丢字节的问题", ["碰到一个奇怪的问题， 用客户端程序向服务端servlet传输图片文件的时候，总是丢失字节数， 收到的字节数组变小了。发送之前统计的是 229237字节   服务端收到的却是 229056字节", "\n\n", "在服务端保存之后，保存之后的图片文件无法打开。 不知各位是否碰到这种问题。", "\n\n", "客户端代码", "\n\n", "[code=\"java\"]String url =\"", "http://127.0.0.1/api?photo_type=jpg", "\";", "\n\n", "    try {\n     URL dataUrl = new URL(url);\n     HttpURLConnection con = (HttpURLConnection) dataUrl.openConnection();\n     con.setRequestMethod(\"POST\");\n     con.setRequestProperty(\"Proxy-Connection\", \"Keep-Alive\");\n     con.setDoOutput(true);\n     con.setDoInput(true);\n     OutputStream os=con.getOutputStream();\n     FileInputStream in = new java.io.FileInputStream(\"c:\\\\test.jpg\");  \n     byte[] bt = new byte[1024];  \n     while ((count = in.read(bt)) > 0) {  \n         os.write(bt, 0, count);  \n         os.flush();\n\n     }  \n     in.close();  \n     os.flush();\n     os.close(); \n     InputStream is=con.getInputStream();\n     DataInputStream dis=new DataInputStream(is);\n     byte d[]=new byte[dis.available()];\n     dis.read(d);\n\n     con.disconnect();\n    } catch (Exception ex) {\n     ex.printStackTrace();\n    }[/code]\n", "\n\n", "服务端代码：", "\n [code=\"java\"]try {", "\n\n", "        long randomPre = System.currentTimeMillis();\n        Random rand = new Random();\n        fileTemp = fileTemp + String.valueOf(randomPre) + \"_\" + rand.nextInt() + \".\" + photo_type;\n        outputStream = new FileOutputStream(new File(fileTemp));\n        byte[] bytes = new byte[1024];\n        int v;\n        while ((v = request.getInputStream().read(bytes)) > 0) {\n            outputStream.write(bytes, 0, v);\n\n        }\n        outputStream.flush();\n        outputStream.close();\n\n\n    } catch (Exception ex) {\n        ex.printStackTrace(System.err);\n    }[/code]\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;要在Linux嵌入式开发板上进行实时视频流的推拉&amp;#xff0c;您可以使用常见的视频编码格式&amp;#xff08;如H.264或H.265&amp;#xff09;&amp;#xff0c;使用开源的多媒体框架&amp;#xff08;如GStreamer或FFmpeg&amp;#xff09;来编写应用程序。&lt;/p&gt;\n&lt;p&gt;在推流方面&amp;#xff0c;您可以使用视频采集设备&amp;#xff08;如USB摄像头&amp;#xff09;来获取视频数据&amp;#xff0c;将其编码为所需的格式&amp;#xff0c;并使用网络协议&amp;#xff08;如RTMP或HTTP&amp;#xff09;将其推送到视频服务器。GStreamer和FFmpeg都提供了编写此类应用程序的功能。&lt;/p&gt;\n&lt;p&gt;在拉流方面&amp;#xff0c;您可以使用网络协议&amp;#xff08;如RTMP或HTTP&amp;#xff09;从视频服务器上获取视频数据&amp;#xff0c;并使用GStreamer或FFmpeg解码视频数据&amp;#xff0c;并使用视频播放器&amp;#xff08;如VLC或MPlayer&amp;#xff09;将其实时播放。&lt;/p&gt;\n&lt;p&gt;要确保视频流在任意网络内都能进行拉流&amp;#xff0c;您需要确保视频服务器具有公共IP地址或DNS可解析名称&amp;#xff0c;并且将其设置为开放式的防火墙策略&amp;#xff0c;以允许来自任意网络的流量。同时&amp;#xff0c;您可以使用流媒体服务器&amp;#xff08;如Wowza Streaming Engine或Nginx-RTMP&amp;#xff09;来提高视频流的可靠性和质量&amp;#xff0c;并确保视频流的延迟时间不超过1秒。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["如何使用Linux嵌入式开发板平台上，进行实时视频流的推拉，并且在任意网络内都能进行视频流的拉流，同时视频流的延时时间不超过1秒", ["如何使用Linux嵌入式开发板平台上，进行实时视频流的推拉，并且在任意网络内都能进行视频流的拉流，同时视频流的延时时间不超过1秒？"]], "Tag": "算法设计"}
{"Answer": "我公司是做工业相机的，也提供一些类似接口，姑且在这里说一下。\r\n海康是家大公司，提供的接口说明和支持应该是很完善的，你不用担心接口不合理。\r\n那么从一般来说，你现在是根据相机的ip端口返回了一个userID，那么如果是多台，你只要根据各个相机的ip端口返回不同的userID，就可以分别操作各录像机了，之后如何进行操作就是你的程序问题了，你可以试试。\r\n如果有不明确的，找到海康的联系方式，对方应该会安排技术人员，对接口给你进行完整的解释，但我推荐你先看看说明书和demo自己试试。", "Konwledge_Point": "网络中的流", "Question": ["C#海康威视网络硬盘录像机开发 做监控页面", ["菜鸡第一次做二次开次，按照官方手册的逻辑,在视频预览传入的参数是调用登录函数返回的userID,登录的函数用的是录像机的ip+端口，那此刻能预览的就是一路画面吗，如果是多个摄像头一台录像机，如何取到连接到硬盘录像机的所有摄像头列表，并预览，SDK", "\n中没有获取摄像头列表的函数，求大神赐教"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The user's webcam stream is on the &lt;em&gt;client-side&lt;/em&gt; and the problem is getting that stream from each client to your server so having FFmpeg on the server won't help you a lot.&lt;/p&gt;\n\n&lt;p&gt;This is achieved by using some form of browser plugin, like &lt;strong&gt;Flash&lt;/strong&gt; or &lt;strong&gt;Silverlight&lt;/strong&gt; and hopefully in a near future using directly &lt;a href=\"http://www.html5rocks.com/en/tutorials/getusermedia/intro/\" rel=\"nofollow\"&gt;HTML5 / WebRTC&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;For Wowza you can use the &lt;strong&gt;FlashRTMPPlayer&lt;/strong&gt; . Here's the documentation showing &lt;a href=\"http://www.wowza.com/resources/3.6.0/examples/WebcamRecording/FlashRTMPPlayer/player.html\" rel=\"nofollow\"&gt;how to record a webcam feed&lt;/a&gt; and how to setup a &lt;a href=\"http://www.wowza.com/forums/content.php?42-How-to-set-up-live-video-chat\" rel=\"nofollow\"&gt;live video chat application&lt;/a&gt; which is probably a good starting point for your live streaming application.&lt;/p&gt;\n\n&lt;p&gt;There are some other libraries that can do the same. Search for webcam Flash RTMP capture.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "网络中的流", "Question": ["使用FFMPEG将实时网络摄像头AV源传输到wowza", ["\n\n", "I have been trying to find out how to live stream my webcam feed to my wowza server. I am trying to make a web application in php that lets users stream live video through their webcam.", "\n\n", "I am confused, if i need to install FFMPEG in every user's computer that uses my application or just installing it in my web server will do??", "\n\n", "Thank you in advance. A little help would be much appreciated.", "\n    "]], "Tag": "算法设计"}
{"Answer": "难道不同JRE传输数据会先传0xFFFE？\r\n怀疑是这个问题，导致UTF-8无法解析，使用了替换符\r\n\r\n请跟踪一下客户端，看看前两个字节是否为0xFFFE", "Konwledge_Point": "网络中的流", "Question": ["socket通信中多收到了字符 \\ufffd", ["我的程序是一个基于socket的即时群聊系统", "\n\n", "客户端和服务器socket都是用utf-8编码。客户端和服务器在同一台机器上测试的时候，完全正常。当分开时，客户端本来应该收到hello这个单词，现在却多收到了两个字符 \\ufffd\\ufffd", "\n\n", "eclipse中编译时设置了utf-8.", "\n\n", "这是服务端的流：", "\nOutputStreamWriter stream = new OutputStreamWriter(", "\nsocket.getOutputStream(), \"UTF8\");", "\npw = new PrintWriter(stream);", "\nbr = new BufferedReader(new InputStreamReader(", "\nsocket.getInputStream(), \"UTF8\"));", "\n这是客户端的流：", "\nBufferedReader br = new BufferedReader(new InputStreamReader(", "\n  clientSocket.getInputStream(), \"UTF-8\"));", "\n\n", "OutputStreamWriter stream = new OutputStreamWriter(clientSocket.getOutputStream(), \"UTF-8\");", "\n\n", "服务端发送的消息是：", "\n\n", "pw.println(\"hello\");", "\npw.flush();", "\n\n", "客户端收到的是 \\ufffd\\ufffdhello"]], "Tag": "算法设计"}
{"Answer": "确定是日志文件的问题？ 我Java不太熟， 但至少读写文件不会出SocketException应该是肯定的吧？", "Konwledge_Point": "网络中的流", "Question": ["Log4J中Logger如何关闭IO流", ["在项目由于日志需要对日志进行扩展，根据交易号和日期生成logger对象放入队列中，每天会清除之前的日志对象，刚开始没有发现问题，大约到了1个月左右，生产中报了java.net.SocketException：too many open files异常，首先整个系统中除了日志外，只有读取配置文件的两个本地IO操作，其他的是网络IO，其次在早上没有大规模并发请求，除了心跳报文外，其他无请求，综合上述可以将问题定位在日志上。仔细想每天我只是把日志对象从Hashtable中remove了，但是被remove的Logger对象并未立刻被GC，我想在remove后，将Logger中IO资源立即释放，求高手指点。"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/ying1979/article/details/10976259\r\naxShockwaveFlash1.Movie = swf_path; 这里指向你的flv", "Konwledge_Point": "网络中的流", "Question": ["winform如何嵌入播放器播放网络视频flv", ["我希望在我的winform程序中嵌入一个播放器，且能播放网络上的流媒体文件，请好心人帮帮忙，急！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;【1】做底层tcp转发映射&amp;#xff0c;像局域网一样的方式访问摄像头 &amp;#xff08;流畅&amp;#xff0c;稳定&amp;#xff0c;技术难度高&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【2】花生壳&amp;#xff0c;这些内网穿透工具&amp;#xff0c;目前主流的摄像头都支持花生壳透传&amp;#xff08;简单&amp;#xff0c;付费&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【3】自行搭建推流nginx/node&amp;#43;ffmpeg推流,网上也有很多开源直接拿来用&amp;#xff08;有延时&amp;#xff0c;有技术门槛但不高&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【4】对接第三方云&amp;#xff08;难度&amp;#xff1a;1&amp;#43;1&amp;#61;2的计算&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【5】另外和你需要输出的视频流格式有关&amp;#xff0c;rtsp不适合浏览器播放&amp;#xff0c;hls适合&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["外网如何访问内网摄像头", ["背景：有一个A7嵌入式平台，双网口。一个接网络摄像头，摄像头提供rtsp流。另一个接4g模块，4g模块可以访问互联网。公司在公网上自己搭了一个视频服务器。", "\n\n", "如何让服务器能访问摄像头？尝试过使用ffmpeg推流的方案，不太稳定。"]], "Tag": "算法设计"}
{"Answer": "同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。\r\n而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。", "Konwledge_Point": "网络中的流", "Question": ["网络编程中阻塞式IO的真正含义到底是什么", ["这两天在看socket编程，可以说这方面是个新手，其中看到了nio，网上有很多文章介绍了nio相对于多线程处理网络链接（每建立一个socket链接，服务器便会开启一个线程来对此socket单独处理和客户端的通信）的优点。因为nio是事件驱动，不会发生Socket读取流数据时的阻塞。我想问的是这里所说的读取流数据的阻塞是我们平时所说的线程进入阻塞态吗？", "\n\n", "当一个线程单独处理一个客户端请求时，它需要等待客户端向它的输出流写入数据，完后服务器端处理此socket的线程才能读取数据，如果客户端未写入数据，那么服务器端线程便会一直停留在对流的读取状态，即调用流的read()方法，我感到疑惑的是当客户端未写入数据而服务器端正在进入read()读取数据时，服务器端处理的这个线程是由运行态进入阻塞态了还是说一直在read()方法循环检测流中的数据（这样的话线程仍然在运行态），网上的很多表达让我对它们产生了很大的疑惑，关于网络中流的读取写入本人还是个新手，这可能涉及到更底层的一些东西，希望有人能够给指点一下。", "\n\n", "我也看了java的源码，当流读取时，是进入一个 for(;;)的死循环。所以我认为是这个线程并没有进入阻塞态，而是一直循环在检测输入流的数据，一旦有数据便会从read()返回，不知道理解的对还是不对？", "\n\n", "以下是服务器端的代码：", "\n[code=\"java\"]    import java.io.*;", "\n    import java.net.*;", "\n    public class Server{", "\n        public static void main(String args[]) {", "\n           ServerSocket server=null;", "\n            try{", "\n                server=new ServerSocket(4700);", "\n            //创建一个ServerSocket在端口4700监听客户请求(已经建立监听)", "\n            }catch(Exception e) {", "\n                System.out.println(\"can not listen to:\"+e);", "\n            //出错，打印出错信息", "\n            }", "\n            Socket socket=null;", "\n            try{", "\n                while(true){", "\n                    socket=server.accept();", "\n                    //使用accept()阻塞等待客户请求，", "\n                    //请求到来则产生一个Socket对象，并继续执行", "\n                    Thread t = new Thread(new Processor(socket));", "\n                    t.start();", "\n                }", "\n            }catch(Exception e) {", "\n                System.out.println(\"Error.\"+e);", "\n            }", "\n        }", "\n    }", "\n\n", "class Processor implements Runnable{\n    private Socket socket;      \n    public Processor(Socket socket){\n        this.socket = socket;\n    }       \n    public void run() {\n        try{\n            String line;\n            BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            //由Socket对象得到输入流，并构造相应的BufferedReader对象\n            PrintWriter os=new PrintWriter(socket.getOutputStream());\n            //由Socket对象得到输出流，并构造PrintWriter对象\n            BufferedReader sin=new BufferedReader(new InputStreamReader(System.in));\n            //由系统标准输入设备构造BufferedReader对象\n            System.out.println(\"Client:\"+is.readLine());\n            //在标准输出上打印从客户端读入的字符串\n            line=sin.readLine();\n            //从标准输入读入一字符串\n            while(!line.equals(\"bye\")){\n            //如果该字符串为 \"bye\"，则停止循环\n                os.println(line);\n                //向客户端输出该字符串\n                os.flush();\n                //刷新输出流，使Client马上收到该字符串\n                System.out.println(\"Server:\"+line);\n                //在系统标准输出上打印读入的字符串\n                System.out.println(\"Client:\"+is.readLine());\n                //从Client读入一字符串，并打印到标准输出上\n                line=sin.readLine();\n                //从系统标准输入读入一字符串\n            } //继续循环\n            os.close(); //关闭Socket输出流\n            is.close(); //关闭Socket输入流\n            socket.close(); //关闭Socket\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}[/code] \n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;按道理没有问题&amp;#xff0c;有没有调用flush方法呢&amp;#xff1f;具体要看代码。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["关于JAVA缓冲字节流的一个小问题", ["网络编程的时候使用缓冲字节流传输照片时没有问题，但是用同一方法传输文本文件时分，复制过去的文本却没有内容(用同一方法将缓冲字节流变成缓冲字符流时却不出现这个问题)，这是什么问题呢？是使用破解版Idea的原因吗？？"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_41822235/article/details/84944700", "Konwledge_Point": "网络中的流", "Question": ["Java网络编程，多线程，C/S模式", ["1.会结账的服务器，使用多线程编写一个C/S模式的结账程序。 实验要求如下：", "\na)参照教材例16-6，编写两个类Client.java(包含main方法)和Server.java(包含main方法)。客户端和服务器建立套接字连接后，客户将如下格式的账单发送给服务器：", "\n\"房租:2189元 水费:112.9元 电费:569元 物业费:832元\"", "\n\n", "服务器接收客户端所发生的信息，计算总费用，并将总费用返回给客户，返回的信息格式如下：", "\n您的账单：", "\n\"房租:2189元 水费:112.9元 电费:569元 物业费:832元", "\n总计：3699.9元", "\n\n", "b)为服务器编写ServerThread.java线程类。在服务器端，服务器循环监听客户端连接呼叫，与客户端建立连接后，创建并启动ServerThread线程为客户端提供结账服务。", "\n\n", "c)使用DataInputStream类作为输入流接收数据(读)，使用方法如下：", "\nString readUTF();       //读入一个已使用UTF-8修改版格式编码的字符串", "\n\n", "d)使用DataOutputStream类作为输出流进行发送数据，使用方法如下：", "\nvoid writeUTF(String str);  //以机器无关的的方式用UTF-8修改版将一个字符串写到基本输出流。"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/yuanbinquan/article/details/51468886", "Konwledge_Point": "网络中的流", "Question": ["linux多网卡及多拨号的问题", ["1.环境", "\nUBUNTU16.04 64bit", "\n6个网卡（5个作为输入，1个作为输出）", "\n\n", "问题1：实现可指定5个输入网卡中的任意一个接收指定的任意源", "\n         即网卡1接收网络流1", "\n                 即网卡2接收网络流2", "\n                 即网卡3接收网络流3", "\n                 即网卡4接收网络流4", "\n                 即网卡5接收网络流5", "\n问题2：实现可指定5个输入网卡可分别同时拨号", "\n         即网卡ppo1接收网络流1", "\n                 即网卡ppo2接收网络流2", "\n                 即网卡ppo3接收网络流3", "\n                 即网卡ppo4接收网络流4", "\n                 即网卡ppo5接收网络流5", "\n\n", "1个网卡拨号很容易实现，但多个同时拨号完全没方向。有大神搞过这一块，能给点方向么？拜谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;Uncaught 的错误是你没引用Message这个组件&amp;#xff0c;引用一下就好了。&lt;br /&gt;至于post还是get&amp;#xff0c;你这个地方写的要一致&amp;#xff0c;调用的时候写的Methods&amp;#xff0c;封装的时候写的Method&amp;#xff0c;要仔细一点啊&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在前端调用的是get请求，postman上面测试能够从接口获取数据，但是浏览器返回post失败", ["问题遇到的现象和发生背景", "\n", "在前端调用的是get请求，postman上面测试能够从接口获取数据，但是浏览器返回post失败。", "\n", "问题相关代码，请勿粘贴截图", "\n", "后端代码：", "\n", "/* 获取管理员列表 */", "static getAdminList(){", "  return new Promise((resolve,reject)=>{", "    let sql = \"select * from myusers_db where type=3\"", "    this.query(sql).then(result=>{", "      console.log(result)", "      resolve(result)", "    }).catch(err=>{", "      console.log(\"数据读取失败\")", "      reject(\"数据读取失败了！\")", "    })", "  })", "}", "\n", "/* 获取管理员列表 */", "static async getAdminListMsg(req,resp){", "  let body = req.body", "  let adminData = await this.getAdminList()", "  if(adminData.length!=0){", "    console.log(\"读取管理员数据成功\")", "    resp.send(adminData)", "  } else{", "    console.log(adminData)", "    console.log(adminData.length)", "    resp.status(500).send(\"读取管理员数据失败\")", "  }", "}", "\n", "/* 获取管理员列表接口 */", "router.get('/getadminlistmsg',function(req,res){", "  user.getAdminListMsg(req,res)", "})", "\n", "前端代码：", "封装的axios", "/**", "\n", "//封装axios方法,为不需要登录操作时使用", "@param ", "options 配置", "/", "let Axios=(options)=>{", "  axios({", "  url:options.url,\n  ", "method", ":", "options.method||", "'POST'", ",\n  data: options.data,\n  ", "params", ": options.data\n", "\n", "  }).then(result=>{", "console.", "log", "(", "\"成功进入axios\"", ")\n  ", "if", " (", "options", ".success)  ", "options", ".success(result.data)\n", "\n", "  }).catch(err=>{", "  let msg = err.response ? err.response.data:", "'请求异常'", "\n  ", "if", " (", "options", ".", "error", "){\n      ", "options", ".", "error", "(msg)\n      ", "Message", ".", "error", "({", "message", ": msg, offset: 150});\n  }", "else", " {\n      ", "Message", ".", "error", "({", "message", ": msg, offset: 150});\n  }\n", "\n", "  })", "}", "\n", "Vue.prototype.$axios = Axios", "\n", "前端页面在created获取数据：", "  created () {", "    this.$axios({", "      url:'/users/getadminlistmsg',", "      methods:'GET',", "      data:{},", "      success:(result)=>{", "        this.id = result.id", "        this.type = \"管理员\"", "        username = result.username", "      }", "    })", "  },", "\n", "运行结果及报错内容", "\n", "浏览器返回：", "POST ", "http://localhost:3000/users/getadminlistmsg", " 404 (Not Found)", "\n", "Uncaught (in promise) ReferenceError: Message is not defined", "    at eval.", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我尝试把后端改成post（用postman测试，依然可以得到数据），然后前端不出现POST404了，但是拿不到数据，还是显示后面Uncaught的错误", "\n", "我想要达到的结果"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  // 视频流延迟&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        setInterval(() &amp;#61;&amp;gt; {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;          if (this.flvPlayer.buffered.length) {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            let end &amp;#61; this.flvPlayer.buffered.end(0); //获取当前buffered值&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            let diff &amp;#61; end - this.flvPlayer.currentTime; //获取buffered与currentTime的差值&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            if (diff &amp;gt;&amp;#61; 0.5) {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;              //如果差值大于等于0.5 手动跳帧 这里可根据自身需求来定&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;              this.flvPlayer.currentTime &amp;#61; this.flvPlayer.buffered.end(0); //手动跳帧&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;          }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }, 2000);&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/528292587766171.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;添加这段处理延迟代码手动跳帧就会转圈圈&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["前端播放flv处理延迟手动跳帧后一直转圈圈", ["flv播放处理延迟手动跳帧后一直转圈圈怎么办？", "\n", "\n", "<", "template", ">", "\n  ", "<", "div", " ", "class", "=", "\"flv_time\"", ">", "\n    ", "<", "div", " ", "class", "=", "\"flv_title\"", ">", "{{", "title", "}}", "</", "div", ">", "\n    ", "<", "video", " ", "ref", "=", "\"my-video\"", " ", ":id", "=", "\"'dplayer'+this.num\"", " ", "controls", " ", "autoplay", " ", "muted", ">", "</", "video", ">", "\n  ", "</", "div", ">", "\n", "</", "template", ">", "\n\n", "<", "script", ">", "\n", "import", " flvjs ", "from", " ", "\"flv.js\"", ";\n", "export", " ", "default", " {\n  ", "props", ": [", "\"videoUrl\"", ", ", "\"num\"", ", ", "\"title\"", "],\n  ", "data", "(", ") {\n    ", "return", " {\n      ", "flvPlayer", ": ", "null", "\n    };\n  },\n  ", "watch", ": {\n    ", "// idPass: {", "\n    ", "//   handler(newRoom, oldRoom) {", "\n    ", "//     // console.log(this.idPass, \"变动id的值\");", "\n    ", "//   this.update();", "\n    ", "//   },", "\n    ", "//   deep: true", "\n    ", "// },", "\n  },\n  ", "mounted", "(", ") {\n    ", "setTimeout", "(", "() =>", " {\n      ", "// console.log(this.videoUrl, \"路径\");", "\n      ", "this", ".", "startPlay", "();\n    }, ", "2000", ");\n  },\n  ", "beforeDestroy", "(", ") {\n    ", "this", ".", "destoryVideo", "();\n  },\n  ", "methods", ": {\n    ", "startPlay", "(", ") {\n      ", "console", ".", "log", "(", "this", ".", "videoUrl", ", ", "this", ".", "num", ", ", "\"路径\"", ");\n      ", "if", " (flvjs.", "isSupported", "()) {\n        ", "// ->注意：这里的定时器，在中断视频时，要清理哦", "\n        ", "const", " videoElement = ", "document", ".", "getElementById", "(", "\"dplayer\"", " + ", "this", ".", "num", ");\n        ", "this", ".", "flvPlayer", " = flvjs.", "createPlayer", "(\n          {\n            ", "type", ": ", "\"flv\"", ", ", "//指定视频类型", "\n            ", "isLive", ": ", "true", ", ", "// 开启直播", "\n            ", "hasAudio", ": ", "false", ", ", "// 关闭声音", "\n            ", "url", ": ", "this", ".", "videoUrl", " ", "// 指定流链接", "\n          },\n          {\n            ", "autoCleanupSourceBuffer", ": ", "true", ", ", "//对SourceBuffer进行自动清理缓存", "\n            ", "autoCleanupMaxBackwardDuration", ": ", "120", ", ", "//    当向后缓冲区持续时间超过此值（以秒为单位）时，请对SourceBuffer进行自动清理", "\n            ", "autoCleanupMinBackwardDuration", ": ", "60", ", ", "//指示进行自动清除时为反向缓冲区保留的持续时间（以秒为单位）。", "\n            ", "enableStashBuffer", ": ", "false", ", ", "//关闭IO隐藏缓冲区", "\n            ", "reuseRedirectedURL", ": ", "true", ", ", "//重用301/302重定向url，用于随后的请求，如查找、重新连接等。", "\n            ", "stashInitialSize", ": ", "128", "\n          }\n        );\n        ", "this", ".", "flvPlayer", ".", "attachMediaElement", "(videoElement);\n        ", "// 非空判断是否执行流", "\n        ", "if", " (", "this", ".", "videoUrl", " !== ", "\"\"", " && ", "this", ".", "videoUrl", " !== ", "null", ") {\n          ", "this", ".", "flvPlayer", ".", "load", "();\n          ", "this", ".", "flvPlayer", ".", "play", "();\n        }\n        ", "// 视频流延迟", "\n        ", "setInterval", "(", "() =>", " {\n          ", "if", " (", "this", ".", "flvPlayer", ".", "buffered", ".", "length", ") {\n            ", "let", " end = ", "this", ".", "flvPlayer", ".", "buffered", ".", "end", "(", "0", "); ", "//获取当前buffered值", "\n            ", "let", " diff = end - ", "this", ".", "flvPlayer", ".", "currentTime", "; ", "//获取buffered与currentTime的差值", "\n            ", "if", " (diff >= ", "0.5", ") {\n              ", "//如果差值大于等于0.5 手动跳帧 这里可根据自身需求来定", "\n              ", "this", ".", "flvPlayer", ".", "currentTime", " = ", "this", ".", "flvPlayer", ".", "buffered", ".", "end", "(", "0", "); ", "//手动跳帧", "\n            }\n          }\n        }, ", "2000", ");\n        ", "// 断流重连", "\n        ", "this", ".", "flvPlayer", ".", "on", "(flvjs.", "Events", ".", "ERROR", ", ", "(", "errType, errDetail", ") =>", " {\n          ", "// alert(\"网络波动,正在尝试连接中...\");", "\n          ", "console", ".", "log", "(", "\"网络波动,正在尝试连接中...\"", ", ", "this", ".", "flvPlayer", ", ", "\"视频状态\"", ");\n          ", "if", " (", "this", ".", "flvPlayer", ") {\n            ", "this", ".", "reloadVideo", "(", "this", ".", "flvPlayer", ");\n          }\n          ", "// 断流销毁掉视频  方案2", "\n          ", "// if (errType == \"NetworkError\") {", "\n          ", "//   console.log('销毁掉视频');", "\n          ", "//   this.destoryVideo();", "\n          ", "// }", "\n          ", "// errType是 NetworkError时，对应errDetail有：Exception、HttpStatusCodeInvalid、ConnectingTimeout、EarlyEof、UnrecoverableEarlyEof", "\n          ", "// errType是 MediaError时，对应errDetail是MediaMSEError   或MEDIA_SOURCE_ENDED", "\n        });\n        ", "// 画面卡死", "\n        ", "this", ".", "flvPlayer", ".", "on", "(", "\"statistics_info\"", ", ", "function", "(", "res", ") {\n          ", "// console.log(res, \"画面卡死了\");", "\n          ", "let", " lastDecodedFrame = ", "0", ";\n          ", "if", " (lastDecodedFrame == ", "0", ") {\n            lastDecodedFrame = res.", "decodedFrames", ";\n            ", "return", ";\n          }\n          ", "if", " (lastDecodedFrame != res.", "decodedFrames", ") {\n            lastDecodedFrame = res.", "decodedFrames", ";\n          } ", "else", " {\n            lastDecodedFrame = ", "0", ";\n            ", "if", " (", "this", ".", "flvPlayer", ") {\n              ", "this", ".", "reloadVideo", "(", "this", ".", "flvPlayer", ");\n            }\n          }\n        });\n      } ", "else", " {\n        ", "console", ".", "log", "(", "\"flvjs不支持\"", ");\n      }\n    },\n\n    ", "// 执行销毁 后在创建", "\n    ", "reloadVideo", "(", "flvPlayer", ") {\n      ", "this", ".", "destoryVideo", "(flvPlayer);\n      ", "this", ".", "startPlay", "();\n    },\n    ", "destoryVideo", "(", "flvPlayer", ") {\n      ", "this", ".", "flvPlayer", ".", "pause", "();\n      ", "this", ".", "flvPlayer", ".", "unload", "();\n      ", "this", ".", "flvPlayer", ".", "detachMediaElement", "();\n      ", "this", ".", "flvPlayer", ".", "destroy", "();\n      ", "this", ".", "flvPlayer", " = ", "null", ";\n    }\n  }\n};\n", "</", "script", ">", "\n\n", "<", "style", " ", "lang", "=", "\"less\"", " ", "scoped", ">", "\n", ".flv_time", " {\n  ", "width", ": ", "100%", ";\n  ", "height", ": ", "100%", ";\n  ", "position", ": relative;\n  ", ".flv_title", " {\n    ", "width", ": ", "100%", ";\n    ", "height", ": ", "28px", ";\n    ", "font-family", ": ", "\"PingFang SC\"", ";\n    ", "font-size", ": ", "14px", ";\n    ", "line-height", ": ", "28px", ";\n    ", "position", ": absolute;\n    ", "top", ": ", "0", ";\n    ", "text-indent", ": ", "35px", ";\n    ", "color", ": ", "#ffffff", ";\n    ", "background", ": ", "rgba", "(", "0", ", ", "0", ", ", "0", ", ", "0.4", ");\n  }\n  ", "video", " {\n    ", "width", ": ", "100%", ";\n    ", "height", ": ", "100%", ";\n  }\n}\n", "</", "style", ">", "\n\n", "\n"]], "Tag": "算法设计"}
{"Answer": "我被这上问题困扰了很久，后来发现如果调整下路由的MTU值到1472就没问题，只要超过1472就会有问题，后面各种排查，最后更换了光猫问题得到解决。\r\nhttp://www.sohu.com/a/158388912_262201\r\nhttps://yq.aliyun.com/articles/222535", "Konwledge_Point": "网络中的流", "Question": ["提交请求后台（javaweb tomcat）无法获取参数", ["这是一个让我崩溃的问题：", "\n这个问题发生在一个平板电脑A上，用这个平板A提交数据（ajax的POST/GET和from表单）只要内容长度超过1440个字符请求到后台服务", "\n会阻塞可能几十秒，然后我在后台什么参数也获取不到，但用另一个平板电脑B（其它品牌）的话可以正常提交，这时两台平板在同一网络环境N。下面是我处理的过程", "\n1、平板A直接连接我手机热点，提交正常。但只要切换回网络就是不行，平板B怎么都是正常的。", "\n2、让平板A连接上fiddler4软件的代理，查看网络请求，这时候提交又正常。网络还是使用的之前提交不了的网络。", "\n3、然后我用nginx开了代理让平板A通过nginx提交OK。", "\n4、后台服务我更换过tomcat版本，平板A不能提交。", "\n5、后台服务我换为jetty,平板A不能提交。", "\n通过这些处理还是不知道问题在哪？但奇怪的是平板A上我上传文件到OSS上没有一点问题，但上传到我自己的后台服务就不行。心累！！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;6参考下&lt;a href=\"https://blog.csdn.net/yanxiaolx/article/details/53393437\"&gt;https://blog.csdn.net/yanxiaolx/article/details/53393437&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;代码如下&amp;#xff1a;{如果对你有帮助&amp;#xff0c;可以给我个采纳吗&amp;#xff0c;谢谢!! 点击我这个回答右上方的【采纳】按钮}。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#define  _CRT_SECURE_NO_WARNINGS\n \n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\n#include&amp;lt;string.h&amp;gt;\n#include&amp;lt;fstream&amp;gt;\n \nclass student\n{\nprivate:\n\tstudent* next;\npublic:\n\tchar stu_num[15];                  //学号\n\tchar stu_name[30];                //姓名\n\tfloat stu_score;                      //成绩\n \n\tvoid afterInsert(student *p);//在该节点后插入一个节点\n\tvoid afterDelete();//在该节点后删除一个节点\n\t\n\tstudent *getNext()//获得下一个节点的指针\n\t{ \n\t\treturn next; \n\t}\n \n\t/***********查询学生信息************/\n\tvoid getMage();\n \n\t/******学生信息修改******/\n\tvoid changeMage(int n, char *ptr);\n\tvoid changegrade(float p);\n \n\t/******构造*****/\n\tstudent(char *num, char *name, float score);\n\tstudent();\n};\n \nvoid student::changegrade(float p)\n{\n\tstu_score &amp;#61; p;\n}\n \nstudent::student()           //构造\n{\n\tstrcpy(stu_num, &amp;#34;\\0&amp;#34;);\n\tstrcpy(stu_name, &amp;#34;\\0&amp;#34;);\n\tstu_score &amp;#61; 0;\n\tnext &amp;#61; &amp;#39;\\0&amp;#39;;\n}\n \nstudent::student(char *num, char *name, float score)\n{\n\tstrcpy(stu_num, num);\n\tstrcpy(stu_name, name);\n\tstu_score &amp;#61; score;\n\tnext &amp;#61; &amp;#39;\\0&amp;#39;;\n}\n \nvoid student::afterInsert(student *p)//插入节点\n{\n\tp-&amp;gt;next &amp;#61; next;\n\tnext &amp;#61; p;\n}\n \nvoid student::afterDelete()        //删除节点\n{\n\tstudent *p &amp;#61; next;\n\tnext &amp;#61; p-&amp;gt;next;\n\tdelete p;\n}\n \nvoid student::getMage()             //获得信息\n{\n\tcout &amp;lt;&amp;lt; &amp;#34;学号&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_num &amp;lt;&amp;lt; &amp;#34;      姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_name;\n\tcout &amp;lt;&amp;lt; &amp;#34;      c&amp;#43;&amp;#43;成绩&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_score &amp;lt;&amp;lt; endl;\n}\n \nvoid student::changeMage(int n, char *ptr)\n{\n\tswitch (n)\n\t{\n\tcase 1: strcpy(stu_num, ptr); \n\t\tbreak;\n\tcase 2: strcpy(stu_name, ptr);\n\t}\n}\n \n//建立链表函数\nvoid  construct_list(student *tail)\n{\n\tstudent *p &amp;#61; new student;\n\tchar very[20];\n\tfloat achieve;\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入学号:&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; very;\n\tp-&amp;gt;changeMage(1, very);\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; very;\n\tp-&amp;gt;changeMage(2, very);\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入c&amp;#43;&amp;#43;成绩&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; achieve;\n\tp-&amp;gt;changegrade(achieve);\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;信息输入完毕&amp;#34; &amp;lt;&amp;lt; endl;\n \n\tfor (; tail-&amp;gt;getNext() !&amp;#61; &amp;#39;\\0&amp;#39;;)\n\t{\n\t\ttail &amp;#61; tail-&amp;gt;getNext();\n\t}\n \n\ttail-&amp;gt;afterInsert(p);\n}\n \n/*********查询信息*********/\nstudent *findmege(student *head)\n{\nloop:\n\tcout &amp;lt;&amp;lt; &amp;#34;1--按姓名查询           2--按学号查询              q--返回上一级菜单&amp;#34; &amp;lt;&amp;lt; endl;\n\tchar p[5], ptr[20];\n\tstudent *mid &amp;#61; head;\n\tcin &amp;gt;&amp;gt; p;\n \n\tif (p[0] !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;p[0] !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;p[0] !&amp;#61; &amp;#39;q&amp;#39; || strlen(p)&amp;gt;1)\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;你的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tgoto loop;\n\t}\n \n\tswitch (p[0])\n\t{\n\tcase &amp;#39;1&amp;#39;:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入要查找的姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ptr;\n \n\t\tfor (; strcmp(ptr, mid-&amp;gt;stu_name) !&amp;#61; 0; mid &amp;#61; mid-&amp;gt;getNext())\n\t\t{\n\t\t\tif (mid-&amp;gt;getNext() &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t\t{\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;你要查找的人不存在&amp;#xff0c;请确认你的输入是否正确&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\tcase &amp;#39;2&amp;#39;:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入您要查找的学号&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ptr;\n\t\tfor (; strcmp(ptr, mid-&amp;gt;stu_num) !&amp;#61; 0; mid &amp;#61; mid-&amp;gt;getNext())\n\t\t{\n\t\t\tif (mid-&amp;gt;getNext() &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t\t{\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;您要查找的内容不存在&amp;#xff0c;请确认您的输入是否正确&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\tcase &amp;#39;q&amp;#39;: \n\t{\n\t\treturn &amp;#39;\\0&amp;#39;;\n\t}\n\tdefault:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;您的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tgoto loop;\n\t}\n\t}\n}\n \n/******************删除链表 节点***********************/\nvoid delete_list(student *head)\n{\n\tstudent *p &amp;#61; &amp;#39;\\0&amp;#39;;\n\tchar selet[4];\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;在删除前&amp;#xff0c;系统会根据您的提示找到您要删除的学生信息&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\tp &amp;#61; findmege(head);\n\tif (p !&amp;#61; &amp;#39;\\0&amp;#39;)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;确认要删除吗&amp;#xff08;yes/任意键返回&amp;#xff09;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; selet;\n \n\t\tif (strcmp(selet, &amp;#34;yes&amp;#34;) &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tfor (; head-&amp;gt;getNext() !&amp;#61; p; head &amp;#61; head-&amp;gt;getNext());\n\t\t\thead-&amp;gt;afterDelete();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;该信息删除成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t}\n\t}\n}\n \n/*******************修改节点信息********************/\nvoid change_info(student *head)\n{\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;在您修改前&amp;#xff0c;系统会根据您提供的信息找的您要修改的信息&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tstudent *p &amp;#61; &amp;#39;\\0&amp;#39;;\n \n\tfloat achieve;\n\tp &amp;#61; findmege(head);\n\tif (p !&amp;#61; &amp;#39;\\0&amp;#39;)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入c&amp;#43;&amp;#43;成绩:&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; achieve;\n\t\tp-&amp;gt;changegrade(achieve);\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;修改成功!&amp;#34; &amp;lt;&amp;lt; endl;\n\t}\n \n}\n \n/**************输出学生成绩信息**************/\nvoid output(student *head)\n{\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;1-查看指定学生信息&amp;#xff1b;2-查看所有学生信息&amp;#xff1b;3-分段输出学生信息&amp;#34; &amp;lt;&amp;lt; endl;\n\tchar ch;\n\tint n &amp;#61; 0;\n\thead &amp;#61; head-&amp;gt;getNext();\n\tcin &amp;gt;&amp;gt; ch;\n\tswitch (ch)\n\t{\n\tcase &amp;#39;1&amp;#39;: \n\t\thead &amp;#61; findmege(head);\n\t\tif (head &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\thead-&amp;gt;getMage();\n\t\tbreak;\n\tcase &amp;#39;2&amp;#39;: \n\twhile (head)\n\t{\n\t\thead-&amp;gt;getMage();\n\t\thead &amp;#61; head-&amp;gt;getNext();\n\t}\n\tbreak;\n\tcase &amp;#39;3&amp;#39;: \n\t\tcout &amp;lt;&amp;lt; &amp;#34;a-60分以下&amp;#xff1b;b-60~70分之间&amp;#xff1b;c-70~80分之间&amp;#xff1b;d-80~90分之间&amp;#xff1b;e-90~100分之间&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ch;\n\t\tswitch (ch)\n\t\t{\n\t\tcase &amp;#39;a&amp;#39;:\n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score &amp;lt;&amp;#61; 60)\n\t\t\t{\n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\t break;\n\t\tcase &amp;#39;b&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;60 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 70) \n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;; \n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;c&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;70 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 80)\n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage(); \n\t\t\t\tn&amp;#43;&amp;#43;; \n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;d&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;80 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 90)\n\t\t\t{\n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;e&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;90 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 100)\n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\t}\n\t\tif (n &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;该分段内没有您要找的学生信息&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t}\n\t}\n}\n \n/*****************主菜单************************/\nvoid mainmenu(student *head)\n{\n\tchar selet[10];\n\tint n &amp;#61; 1;\n\tofstream outfile;\n\tifstream infile;\n\tstudent *p, *ptr;\n\tstudent *test &amp;#61; head, *mid;\n\tcout &amp;lt;&amp;lt; &amp;#34;*************************欢迎进入学生信息管理系统*************************&amp;#34; &amp;lt;&amp;lt; endl;\n\tdo {\n\t\tcout &amp;lt;&amp;lt; &amp;#34;**************************************************************************&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;1.插入信息&amp;#xff1b;   2.删除信息&amp;#xff1b;  3.修改信息&amp;#xff1b; 4.查看信息&amp;#xff1b; 5.保存  &amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;按&amp;#39;q&amp;#39;键退出      &amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;**************************************************************************&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; selet;\n\t\tif (((selet[0]&amp;lt;&amp;#39;1&amp;#39; || selet[0]&amp;gt;&amp;#39;6&amp;#39;) &amp;amp;&amp;amp; selet[0] !&amp;#61; &amp;#39;q&amp;#39;) || strlen(selet)&amp;gt;1)\n\t\t{\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;您的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (selet[0])\n\t\t{\n \n\t\tcase &amp;#39;1&amp;#39;:\n\t\t\tconstruct_list(head);\n\t\t\tbreak; \n\t\tcase &amp;#39;2&amp;#39;: \n\t\t\tdelete_list(head); \n\t\t\tbreak;\n\t\tcase &amp;#39;3&amp;#39;: \n\t\t\tchange_info(head);\n\t\t\tbreak;\n\t\tcase &amp;#39;4&amp;#39;: \n\t\t\toutput(head);\n\t\t\tbreak;\n\t\tcase &amp;#39;5&amp;#39;:  \n\t\t\toutfile.open(&amp;#34;students.txt&amp;#34;, ios::out | ios::app);\n\t\t\tfor (p &amp;#61; head-&amp;gt;getNext(); p !&amp;#61; &amp;#39;\\0&amp;#39;; p &amp;#61; p-&amp;gt;getNext())\n\t\t\t{\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_name &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_num &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_score &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; endl;\n\t\t\t}\n\t\t\toutfile.close();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;保存成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tbreak;\n\t\tcase &amp;#39;q&amp;#39;: \n\t\t\tbreak;\n\t\t}\n\t} while (selet[0] !&amp;#61; &amp;#39;q&amp;#39;);\n}\n \nvoid main()\n{\n\tstudent head;\n\tmainmenu(&amp;amp;head);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["学生成绩管理系统，要求用C++", ["题目：学生成绩管理系统", "\n\n", "一、基本要求", "\n\n", "1）能进行数据的添加、删除、修改、查询、排序；", "\n\n", "2）完全使用类实现。", "\n\n", "3) 重载输入“>>”操作符，使得可以通过cin直接读入类的对象值。", "\n\n", "4) 编写main函数，测试系统的各种功能。二、系统基本类系统基本类4个：Score类，subject类，Student类，Class类。存储学生的个人信息，考试科目，成绩，班级信息。三、功能拓展文件操作：", "\n\n", "1）初始数据从文件导入，能够实现文件的显示；", "\n\n", "2）数据保存至文件中；", "\n\n", "3）对文件记录进行增、删、改、查；", "\n\n", "4）多个文件组成一个文件。派生：为Student类派生研究生类GStudent，为研究生填加课题类Project类。扩展功能中可包含书上的知识点内容，如文件流、STL标准模板库虚函数、派生、函数重载、运算符重载、静态数据成员和成员函数等。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;使用base64吧&amp;#xff0c;将模型转成字节流然后加密保存到本地&amp;#xff0c;每次读取的时候解密到内存中&amp;#xff0c;从内存中加载模型。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["神经网络在训练时怎么对模型进行加密，并在解密时传入模型进行验证？", ["问题遇到的现象和发生背景", "\n", "目前是用pytorch C++版的接口搭建了一个网络结构，现在想在训练时对我保存下来的模型进行加密，然后在使用模型时进行解密后，用流把模型参数传入到模型中，请问各位是怎么实现的？我做了一个月了 都没有做出来。", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n\n", "我的解答思路和尝试过的方法", "\n", "我本来想的是使用文件流把字符加载到内存里面，然后对每个字符使用异或进行加密，但是打开解密后的模型文件，并传入到网络时会报\"Error data format\"这个错误，我想问问改怎么解决？"]], "Tag": "算法设计"}
{"Answer": "H.264、H.263、MPEG-4、MPEG-3、MPEG-2 只是编解码算法，  播放器除了支持编解码算法还需要能解析出媒体流格式。\r\n通常网络摄像机压缩编码以后，还要将码流进行封装，如果以标准码流进行封装如RTSP等方式，那常见的播放器如vlc、mplayer等就可以直接播放。\r\n如果不太标准那只能找该网络摄像机厂商提供的播放器，或者是SDK来进行开发才能播放。", "Konwledge_Point": "网络中的流", "Question": ["网络摄像机视频编码H.264、H.263、MPEG-4、MPEG-3、MPEG-2兼容性？", ["我的网络摄像机监控客户端可以播放视频编码为H.264和MPEG-4的网络监控视频，请问它能不能播放编码为H.263和MPEG-2和MPEG-3的视频流呢？", "\n\n", "由于手上的网络摄像机只有H.264和MPEG-4这两个选项，没法测试，希望有人知道的话告诉我下，谢谢了"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nthis.$message.success(&amp;#39;下载成功&amp;#39;)\n    const blob &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Blob([&lt;span class=\"hljs-params\"&gt;res&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;data&lt;/span&gt;], { &lt;span class=\"hljs-params\"&gt;type&lt;/span&gt;: &amp;#39;&lt;span class=\"hljs-params\"&gt;application&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;/&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;vnd&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;ms&lt;/span&gt;-&lt;span class=\"hljs-params\"&gt;excel&lt;/span&gt;;&lt;span class=\"hljs-params\"&gt;charset&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-params\"&gt;utf&lt;/span&gt;-8&amp;#39; })&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;let&lt;/span&gt; link &amp;#61; document.create&lt;span class=\"hljs-constructor\"&gt;Element(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;let&lt;/span&gt; href &amp;#61; window.&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;URL&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;create&lt;span class=\"hljs-constructor\"&gt;ObjectURL(&lt;span class=\"hljs-params\"&gt;blob&lt;/span&gt;)&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//下载链接&lt;/span&gt;\n    link.href &amp;#61; href;\n    link.text &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;下载&amp;#34;&lt;/span&gt;;\n    link.download &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;xxx&amp;#34;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//下载后文件名&lt;/span&gt;\n    document.body.append&lt;span class=\"hljs-constructor\"&gt;Child(&lt;span class=\"hljs-params\"&gt;link&lt;/span&gt;)&lt;/span&gt;;\n    link.click&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//点击下载&lt;/span&gt;\n    document.body.remove&lt;span class=\"hljs-constructor\"&gt;Child(&lt;span class=\"hljs-params\"&gt;link&lt;/span&gt;)&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//下载完成移除元素&lt;/span&gt;\n    window.&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;URL&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;revoke&lt;span class=\"hljs-constructor\"&gt;ObjectURL(&lt;span class=\"hljs-params\"&gt;href&lt;/span&gt;)&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//释放blob对象&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["springboot vue 下载文件，浏览器未显示下载的文件\n只有控制台 Preview 有文件", ["springboot vue 下载文件，浏览器未显示下载的文件", "只有控制台 Preview 有文件", "\n", "\n", "\n", "\n    @PostMapping(", "\"/down\"", ")\n   ", "public", " ", "void", " down(HttpServletResponse response, @Param(", "\"id\"", ") ", "int", " id) {\n        Backup backup = backupService.getById(id);\n          ", "File", " ", "file", "=", "new", " ", "File", "(backup.getPath());\n        response.setContentType (", "\"application/octet-stream\"", ");\n         \n        String name = ", "file", ".getName()+", "\".txt\"", ";\n        ", "try", " {\n            name = ", "new", " String (name.getBytes (StandardCharsets.UTF_8), ", "\"ISO8859-1\"", ");\n        } ", "catch", " (UnsupportedEncodingException e) {\n            e.printStackTrace ();\n        }\n        response.addHeader (", "\"Content-Disposition\"", ", ", "\"attachment;filename=\"", " + name);\n\n        OutputStream opmt = ", "null", ";\n\n        ", "try", " {\n            opmt = response.getOutputStream ();\n            opmt.", "write", " (FileUtils.readFileToByteArray (", "new", " ", "File", " (backup.getPath())));\n            opmt.close ();\n        } ", "catch", " (IOException e) {\n            e.printStackTrace ();\n        }\n        \n}\n", "\n", "\n    ", "async", " ", "download", "(", "{id}", "){ ", "// id=", "\n      ", "const", " result = ", "await", " ", "getBackupDown", "({id}).", "catch", "(", "err", "=>", "{\n        ", "this", ".", "$message", ".", "error", "(", "'网络请求错误'", ")\n      })\n      ", "if", "(result.", "status", "){\n        ", "this", ".", "$message", ".", "error", "(", "'下载失败'", ")\n      }", "else", " {\n        ", "this", ".", "$message", ".", "success", "(", "'下载成功'", ")\n      }\n\n      ", "await", " ", "this", ".", "fetchData", "()\n    },\n", "\n", "<a-button ", "value", "=", "\"small\"", " @", "click", "=", "\"download(item)\"", ">下载</a-button>\n\n"]], "Tag": "算法设计"}
{"Answer": "抛出io异常，文件读取的问题。serversocket没有写进数据，socket就读取数据时，会抛出io异常的。", "Konwledge_Point": "网络中的流", "Question": ["java创建socket时失败的原因有哪些？", ["最近练习使用socket时，本来能够脸上服务器的，后来不知道怎么的就连不上了，最后定位就是socket创建失败，什么原因我不知道。我知道的原因如下：", "\n1、没有添加连接网络权限。", "\n2、没有在后台线程中创建socket", "\n3、端口号被占用", "\n这些问题我都避免了，而且之前就连上了，后来连不上，抛出IOException，请问还有其他的原因会导致socket创建失败吗？"]], "Tag": "算法设计"}
{"Answer": "这种问题是要考虑线程的", "Konwledge_Point": "网络中的流", "Question": ["怎么解决java网络通信编程ip和port是从文本框中获取的？", ["为什么我把connect()方法加入button1的事件中就会黑屏", "\n\n", "代码如下", "\n客户端：", "\npackage sunxu.util;", "\n\n", "import java.awt.BorderLayout;", "\nimport java.awt.Dimension;", "\nimport java.awt.event.ActionEvent;", "\nimport java.awt.event.ActionListener;", "\nimport java.io.BufferedReader;", "\nimport java.io.IOException;", "\nimport java.io.InputStreamReader;", "\nimport java.io.PrintWriter;", "\nimport java.net.InetAddress;", "\nimport java.net.Socket;", "\nimport java.net.UnknownHostException;", "\n\n", "import javax.swing.BorderFactory;", "\nimport javax.swing.JButton;", "\n\n", "import javax.swing.JFrame;", "\nimport javax.swing.JLabel;", "\nimport javax.swing.JPanel;", "\nimport javax.swing.JScrollPane;", "\nimport javax.swing.JTextArea;", "\nimport javax.swing.JTextField;", "\n\n", "public class ClientSocketFrame extends JFrame  {", "\n    /**", "\n     * ", "\n     */", "\n    private static final long serialVersionUID = 1L;", "\n    private PrintWriter writer; // 声明PrintWriter类对象", "\n    private BufferedReader reader; // 声明BufferedReader对象", "\n    private Socket socket; // 声明Socket对象", "\n    private JTextArea ta_info; // 创建JtextArea对象", "\n    JButton button1 = new JButton(\"Connect\");", "\n    //private JTextField tf_send; // 创建JtextField对象", "\n    private InetAddress sendIp;", "\n    private int sendPort;", "\n\n", "private void connect() { // 连接套接字方法\n    ta_info.append(\"Connect to server…\\n\"); // 文本域中信息信息\n    try { // 捕捉异常\n        socket = new Socket(sendIp,sendPort); // 实例化Socket对象\n        while (true) {\n            writer = new PrintWriter(socket.getOutputStream(), true);\n            reader = new BufferedReader(new InputStreamReader(socket\n                    .getInputStream())); // 实例化BufferedReader对象\n            ta_info.append(\"Client connected…\\n\"); // 文本域中提示信息\n            getServerInfo();\n        }\n    } catch (Exception e) {\n        e.printStackTrace(); // 输出异常信息\n    }\n}\n\npublic static void main(String[] args) { // 主方法\n      ClientSocketFrame clien = new ClientSocketFrame(); // 创建本例对象\n      clien.setVisible(true); // 将窗体显示\n      //clien.connect(); // 调用连接方法\n}\n\nprivate void getServerInfo() {\n    try {\n        while (true) {\n            if (reader != null) {\n                String line = reader.readLine();// 读取服务器发送的信息\n                if (line != null)\n                    ta_info.append(\"接收到服务器发送的信息：\" + line + \"\\n\"); // 显示服务器端发送的信息\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (reader != null) {\n                reader.close();// 关闭流\n            }\n            if (socket != null) {\n                socket.close(); // 关闭套接字\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n/**\n * Create the frame\n */\npublic ClientSocketFrame() {\n    super();\n    setTitle(\"客户端\");\n    setBounds(100, 100, 361, 257);\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    final JPanel panel = new JPanel();\n    getContentPane().add(panel, BorderLayout.NORTH);\n\n    panel.setBorder(BorderFactory.createTitledBorder(\"客户机设置:\"));\n\n\n\n    final JLabel label = new JLabel();\n    label.setText(\"Server IP:\");\n    panel.add(label);\n    JTextField tf_sen= new JTextField();\n    tf_sen.setPreferredSize(new Dimension(50, 25));\n    panel.add(tf_sen);\n\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Server Port:\");\n    panel.add(label1);\n    JTextField tf_Port = new JTextField();\n    tf_Port.setPreferredSize(new Dimension(50, 25));\n    panel.add(tf_Port);\n\n    final JButton button1 = new JButton(\"Connect\");\n\n    button1.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n            try {\n                sendIp=InetAddress.getByName(tf_sen.getText());\n            } catch (UnknownHostException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }  \n               sendPort=Integer.parseInt(tf_Port.getText());\n               ta_info.append(\"Connect to server…\\n\"); // 文本域中信息信息\n               ta_info.append(sendIp+\"\\n\"); // 文本域中信息信息\n               ta_info.append(sendPort+\"\\n\"); // 文本域中信息信息\n               connect();\n        }\n    });\n    panel.add(button1);\n\n\n    final JPanel panel_1 = new JPanel();\n    getContentPane().add(panel_1, BorderLayout.SOUTH);\n\n    final JLabel label_1 = new JLabel();\n    label_1.setText(\"Say：\");\n    panel_1.add(label_1);\n\n    JTextField tf_send = new JTextField();\n    tf_send.setPreferredSize(new Dimension(220, 25));\n    panel_1.add(tf_send);\n\n    final JButton button = new JButton();\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n            writer.println(tf_send.getText()); // 将文本框中信息写入流\n            ta_info.append(\"客户端发送的信息：\" + tf_send.getText()\n                    + \"\\n\"); // 将文本框中信息显示在文本域中\n            tf_send.setText(\"\"); // 将文本框清空\n        }\n    });\n    button.setText(\"Say\");\n    panel_1.add(button);\n\n    final JScrollPane scrollPane = new JScrollPane();\n    getContentPane().add(scrollPane, BorderLayout.CENTER);\n\n    ta_info = new JTextArea();\n    scrollPane.setViewportView(ta_info);\n    //\n\n}\n", "\n\n", "}", "\n\n", "服务器：", "\npackage sunxu.util;", "\n\n", "import java.awt.BorderLayout;", "\nimport java.awt.Color;", "\nimport java.awt.Dimension;", "\nimport java.awt.Font;", "\nimport java.awt.event.ActionEvent;", "\nimport java.awt.event.ActionListener;", "\nimport java.io.*;", "\nimport java.net.*;", "\n\n", "import javax.swing.BorderFactory;", "\nimport javax.swing.JButton;", "\nimport javax.swing.JFrame;", "\nimport javax.swing.JLabel;", "\nimport javax.swing.JPanel;", "\nimport javax.swing.JScrollPane;", "\nimport javax.swing.JTextArea;", "\nimport javax.swing.JTextField;", "\n\n", "public class ServerSocketFrame extends JFrame {", "\n    //private JTextField tf_send;", "\n    private JTextArea ta_info;", "\n    private PrintWriter writer; // 声明PrintWriter类对象", "\n    private BufferedReader reader; // 声明BufferedReader对象", "\n    private ServerSocket server; // 声明ServerSocket对象", "\n    private Socket socket; // 声明Socket对象socket", "\n    private int sendPort;", "\n\n", "public void getServer() {\n    try {\n        server = new ServerSocket(sendPort); // 实例化Socket对象\n        ta_info.append(\"服务器套接字已经创建成功\\n\"); // 输出信息\n        while (true) { // 如果套接字是连接状态\n            ta_info.append(\"等待客户机的连接......\\n\"); // 输出信息\n            socket = server.accept(); // 实例化Socket对象\n            reader = new BufferedReader(new InputStreamReader(socket\n                    .getInputStream())); // 实例化BufferedReader对象\n            writer = new PrintWriter(socket.getOutputStream(), true);\n            getClientInfo(); // 调用getClientInfo()方法\n        }\n    } catch (Exception e) {\n        e.printStackTrace(); // 输出异常信息\n    }\n}\n\nprivate void getClientInfo() {\n    try {\n        while (true) {\n            String line = reader.readLine();// 读取客户端发送的信息\n            if (line != null)\n                ta_info.append(\"接收到客户机发送的信息：\" + line + \"\\n\"); // 显示客户端发送的信息\n        }\n    } catch (Exception e) {\n        ta_info.append(\"客户端已退出。\\n\"); // 输出异常信息\n    } finally {\n        try {\n            if (reader != null) {\n                reader.close();// 关闭流\n            }\n            if (socket != null) {\n                socket.close(); // 关闭套接字\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic static void main(String[] args) { // 主方法\n    ServerSocketFrame frame = new ServerSocketFrame(); // 创建本类对象\n    frame.setVisible(true);\n    //frame.getServer(); // 调用方法\n}\n\npublic ServerSocketFrame() {\n    super();\n    setTitle(\"服务器端程序\");\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    setBounds(100, 100, 379, 260);\n\n    final JScrollPane scrollPane = new JScrollPane();\n    getContentPane().add(scrollPane, BorderLayout.CENTER);\n\n    ta_info = new JTextArea();\n    scrollPane.setViewportView(ta_info);\n\n    final JPanel panel = new JPanel();\n    getContentPane().add(panel, BorderLayout.SOUTH);\n\n    final JLabel label = new JLabel();\n    label.setText(\"Say：\");\n    panel.add(label);\n\n    JTextField tf_send = new JTextField();\n    tf_send.setPreferredSize(new Dimension(150, 25));\n    panel.add(tf_send);\n\n    final JButton button = new JButton();\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n            writer.println(tf_send.getText()); // 将文本框中信息写入流\n            ta_info.append(\"服务器发送的信息是：\" + tf_send.getText() + \"\\n\"); // 将文本框中信息显示在文本域中\n            tf_send.setText(\"\"); // 将文本框清空\n        }\n    });\n    button.setText(\"Say:\");\n    panel.add(button);\n\n    final JPanel panel_1 = new JPanel();\n    getContentPane().add(panel_1, BorderLayout.NORTH);\n    panel_1.setBorder(BorderFactory.createTitledBorder(\"服务器设置:\"));\n\n    final JLabel label_1 = new JLabel();\n    label_1.setText(\"Port:\");\n    JTextField tf_sen= new JTextField();\n    tf_sen.setPreferredSize(new Dimension(220, 25));\n    panel_1.add(label_1);\n    panel_1.add(tf_sen);\n\n    final JButton button1 = new JButton(\"Strat\");\n\n    button1.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n               sendPort=Integer.parseInt(tf_sen.getText());\n               getServer();\n        }\n    });\n    panel_1.add(button1);\n\n\n}\n", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "跨域头加到视频服务器，不是代理转发那里。你现在加法，跨域头没有加进去的，看一下客户端请求就知道", "Konwledge_Point": "网络中的流", "Question": ["video.js播放m3u8视频无法跨域访问", ["问题：video.js播放m3u8视频无法跨域访问", "\n\n", "今天使用video.js播放m3u8视频时遇到了跨域的问题", "\n我的请求路径是www.xuecheng.com/video.html", "\n\n", "\n\n", "我是通过nginx代理访问的", "\n以下时nginx的配置", "\n\n", "\n\n", "\n\n", "\n\n", "以下是我的工程的，工程中已经下载了video.js以及videojs-contrib-hls.js", "\n\n", "\n\n", "以下是video.html的内容", "\n\n", "\n**", "\n\n", "以下是我的m3u8的视频文件地址**", "\n\n", "\n\n", "**", "\n网络上查看了很多关于Access-Control-Allow-Origin的错误，但是我的ngnix的配置文件中已经加了相关跨域语句，重启nginx还是访问www.xuecheng.com/video.html还是同样的错误。", "\n\n", "求大神们解答，**", "\n\n", "已经解决了，在配置跨域的语句后面加上always", "\n\n", "\n\n", "具体原理我也不懂，请参考这位兄弟的贴", "https://blog.csdn.net/bojinyanfeng/article/details/103719789"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;在Android设置里面&amp;#xff0c;设置一个自定义doh服务器&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://console.dnspod.cn/publicdns/config\" id=\"textarea_1676342340565_1676342624086_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://console.dnspod.cn/publicdns/config&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Public DNS 专业版配置&amp;#xff0c;在云端屏蔽一些域名&amp;#xff0c;这样可以在移动网络和Wifi网络同时生效&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["家里的小朋友天天使用微信视频号刷短视频，有没有办法在他打开微信视频号时候关闭流量，如何解决？", ["家里的小朋友天天使用微信视频号刷短视频，有没有办法在他打开微信视频号时候关闭流量，安卓的系统？，有偿!"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以看下该实例中对于Java Socket 数据传输 基础以及优化&amp;#xff0c;链接&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/z1766042975/article/details/112709438\" id=\"textarea_1672013553959_1672014256766_0\"&gt;https://blog.csdn.net/z1766042975/article/details/112709438&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["Java Socket 传输数据量大时接收端与发送端数据不一致问题", ["Java Socket传输字节流时接收端与发送端数据不一致问题", "\n", "我做的一个TCP传输方法，每次在传输数据时在包头打上数据包大小，在接收端接收到足够大小后再进行处理，在传输数据量小的时候不会出错，但一旦数据量大到几十K时也就是字节数量达到30000时，接收端出现了接受端和发送端发送的字节数量都不一致了，接收端的字节数量时不时会大于发送端，有时多出来几百个字节，有时候多出来几千个字节，更麻烦的是我不知道多出来的字节在哪里，他们插在了这些数据包中间，我在查看发送端和接收端的字节流不同时发现发送端最后几个字节和接收端最后几个字节一致，但接收到的字节数量不一致，我以为是不是发送端在发送时变成了多线程，我尝试调试，可我把断点设置到接收端的InputStream.read时这种现象又离奇的消失了，于是我尝试着在read之前sleep几毫秒，问题也没有出现，但明显这种方法治标不治本且鸡肋，在此", "\n", "\n\n", "\n", "运行结果及详细报错内容", "\n", "这是发送端运行：", "\n", "\n", "最下方是我这个write的数组的大小", "可是在接收端：", "\n", "\n", "右下角监视的client.getInputStream().available()还有8834，说明缓冲区内还有8834个，可是我已经把发送端发送的数据大小全部读取了，而且读的还是有错误的", "可是如果我在前面的", "\n", "\n", "read部分加上断点时它就不会有这种情况了", "\n", "我的解答思路和尝试过的方法，我发现设置断点时它就不会产生这种情况的话，我就在read前面加上sleep也没有产生这种情况，但这种方法很鸡肋，浪费服务器资源不说，如果不同的网络情况我还得调整这个sleep，我猜测产生这个现象的原因是由于发送的write时byte[]数组过大导致发生拆包，但后面的包到达后马上就被read了（可是TCP协议不应该是保证读取有序吗），导致中间空出的字节被覆盖了，后面到达的包就只能排到后面了，可是我没有办法判断我在接受端write的byte[]数组资源全部到达接收端啊。希望能有解我疑惑", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "你这个问题实际上就是要定义一个远程调用协议\r\n1.在客户段给发送信息前面加一个头，例如:\r\n@header@type:methodinvoke@服务端的类@服务端的方法@参数列表@end@header@\r\n2.在服务端接受客户段信息时，判断一下头部是否有如上头，如果有，按照协议解析，\r\n然后根据解析内容通过反射调用客户段请求的逻辑执行\r\n\r\n此外，服务端最好使用线程池处理客户段请求\r\n在类中定义线程池常量\r\nprivate static ExecutorService executoService;\r\n\r\n在调用具体逻辑时\r\nexecutoService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 10);\r\nexecutoService.execute(new SocketThread(socket));", "Konwledge_Point": "网络中的流", "Question": ["Java 网络通信 类还未编写如何进行调用(或者解决思路)", ["  程序想实现的效果：客户端现在有一个对象“狗”，加入了一个LinkedList集合，随后将该集合发送到服务器端。服务器端接收到这个集合，会调用一个方法Judge来判断LinkedList里面有什么，如果是狗则调用XXX方法，如果是猫则调用XXX方法。\n        问题描述：现在客户端与服务器端单独抽出成为一个jar工具包。也就是说服务器端和客户端会预先写好。换而言之，在该包里没有Judge方法，Judge方法是在程序实际编写时再写成的。那么此时服务器端代码应该怎么写？\n        实际应用举例：当实际使用时，应用程序(客户端)调用Send()，此时该jar包中已编好的程序会将对象发送到服务器端；在服务器端只需写一个Judge()，该方法会被jar包中的程序自动调用。\n\n        大体实现的代码：\n", "\n\n", "客户端：", "\n\n", " //向服务器发送数据\n    public void send(TransferLinkedList linkedList) throws IOException{\n        /**\n         * 本方法用于客户端向服务器发送数据。首先从套接字中获取基本输出流，接下来将该输出流转换为对象输出流以输出对象\n         */\n        //从该套接字中获取输出流\n        OutputStream clientOut = client.getOutputStream();\n        //将该输出流处理为对象输出流\n        ObjectOutputStream clientOutObject = new ObjectOutputStream(clientOut);\n        //传输信息\n        clientOutObject.writeObject(linkedList);\n\n        //刷新缓存区\n        clientOutObject.flush();\n\n        //接收服务器信息以确认是否成功发送信息\n\n    }\n", "\n\n", "服务器端：", "\n\n", " //开始运行\n    public void run() throws IOException{\n        //服务器一直等待客户端的连接，当与客户端建立连接时，服务器分出一个线程建立新的Socket进行处理，原有Socket继续等待\n        //此处为了简便省略线程\n        while(true){\n            Socket socket = server.accept();\n\n            //处理新的Socket\n\n            /**\n             * 调用Judge方法，Judge方法应在实际使用该jar包时编写\n             * 此时不知道Judge包含哪些方法，是怎么样的路径，甚至名字是否是Judge\n             * 该使用什么方法来处理？反射？工厂模式？感觉都不大能解决\n             */\n\n        }\n    }\n"]], "Tag": "算法设计"}
{"Answer": "关键是语音流. 对队列也比较赞同. 不过考虑并发多线程问题.    缓冲区 内部划分应该分:  发送区, 资源区, 接受区. 对消息进行编号. 例如2s一个语音段, 发送成功就成功, 不然丢弃. 编号之后, 可以同时并发发送. 发送区进行资源锁定, 进入server 资源区后解锁. 接受区也是一样的, 维护一个顺序索引. 按顺序发送资源区给接收端. 如果丢包你, 怎么处理. 就是语音丢失闹 . 后面再有也不要你. 锁定之后就好.  其实生产--消费者思路.   至于实现, 如何并发, 并发 ,对外封装调用.", "Konwledge_Point": "网络中的流", "Question": ["c#将客户端发来的数据流实时转发给另一个客户端   服务器数据缓冲区的建立问题", ["我想要实现两部安卓客户端的实时语音通讯，安卓客户端都在内网，因此需要一外网pc做数据的中转服务器，安卓语音发送端通过audiotrack录制PCM音频数据并实时发送到服务器，服务器接收数据并不断读入一个缓冲区，开启另一个线程循环读取缓冲区的数据同时将数据发送到另一个安卓客户端，问题就在于服务器的缓冲区要怎么做？怎么保证缓冲区的数据同时被两个线程操作时的有序稳定 求大神指教，假设网络良好，不考虑网络波动带来的数据处理问题。 "]], "Tag": "算法设计"}
{"Answer": "你把动态生成图片的页面粘出来，或是可访问的，让我访问下，我把那地址提取出来", "Konwledge_Point": "网络中的流", "Question": ["java获取网络动态图片", ["使用java实现把网页的图片加载到本地的swing里面查看，但是有些图片是动态生成的，比如用servlet直接生成输出流放到网页上，如何从里面题取出这种图片，谢谢  可以看发送到我的邮箱", "alone_dancer@sohu.com", "\n[b]问题补充：[/b]", "\n可能是说的不太清楚，就是不知道如何得到这个流，生成图片是用js调用servlate生成的，这是查看验证码部分源代码得到的结果", "\n\n", "\n\n", "这是使用查看全部源代码得到的结果：", "验证码", "如果您无法识别验证码，请点图片更换", "\n\n", "有源码发出来，或放邮箱交流更好。谢谢～"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/huzhengnan/article/details/22288897", "Konwledge_Point": "网络中的流", "Question": ["网络爬虫下载网页的问题", ["下载网页时只能下载第一个网页，后续网页虽然能爬出来，但是无法下载到本地。下载网页的代码如下", "\npublic class FileDownLoader {", "\n    /**根据 url 和网页类型生成需要保存的网页的文件名", "去除掉 url 中非文件名字符 ", "\n     */", "\n    public  String getFileNameByUrl(String url,String contentType)", "\n    {", "\n        url=url.substring(7);//remove http://", "\n        if(contentType.indexOf(\"html\")!=-1)//text/html", "\n        {", "\n            url= url.replaceAll(\"[\\?/:", "|<>\\\"]\", \"_\")+\".html\";", "\n            return url;", "\n        }", "\n        else//如application/pdf", "\n        {", "\n            return url.replaceAll(\"[\\?/:*|<>\\\"]\", \"_\")+\".\"+ ", "\n\n", "      contentType.substring(contentType.lastIndexOf(\"/\")+1);\n    }   \n}\n\n/**保存网页字节数组到本地文件\n * filePath 为要保存的文件的相对地址\n */\nprivate void saveToLocal(byte[] data,String filePath)\n{\n    try {\n        DataOutputStream out=new DataOutputStream(\n", "\n\n", "new FileOutputStream(new File(filePath)));", "\n            for(int i=0;i<data.length;i++)", "\n            out.write(data[i]);", "\n            out.flush();", "\n            out.close();", "\n        } catch (IOException e) {", "\n            e.printStackTrace();", "\n        }", "\n    }", "\n\n", "/*下载 url 指向的网页*/\npublic String  downloadFile(String url)\n{\n      String filePath=null;\n\n\n     /* 使用 GetMethod 来访问一个 URL 对应的网页，需要如下一些步骤。\n      1 生成一个 HttpClinet 对象并设置相应的参数。\n      2 生成一个 GetMethod 对象并设置响应的参数。\n      3 用 HttpClinet 生成的对象来执行 GetMethod 生成的 Get 方法。\n      4 处理响应状态码。\n      5 若响应正常，处理 HTTP 响应内容。\n      6 释放连接*/\n      /* 1.生成 HttpClinet 对象并设置参数*/\n      HttpClient httpClient=new HttpClient();\n      //设置 Http 连接超时 5s\n          httpClient.getHttpConnectionManager().getParams().\n", "\n\n", "setConnectionTimeout(5000);", "\n\n", "      /*2.生成 GetMethod 对象并设置参数*/\n      //使用 GetMethod 来访问一个 URL 对应的网页\n      GetMethod getMethod=new GetMethod(url);    \n      //设置 get 请求超时 5s\n      getMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT,5000);\n      //设置请求重试处理,用的是默认的重试处理：请求三次\n      getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,\n        new DefaultHttpMethodRetryHandler());\n\n      /*3.执行 HTTP GET 请求*/\n      try{ \n          /*executeMethod返回值是一个整数，表示了执行该方法后服务器返回的状态码，\n          该状态码能表示出该方法执行是否成功,需要认证或者页面发生了跳转（默认状态下GetMethod的实例是自动处理跳转的）*/\n          int statusCode = httpClient.executeMethod(getMethod);\n          //判断访问的状态码\n          if (statusCode != HttpStatus.SC_OK) \n          {\n", "\n\n", "System.err.println(\"Method failed: \"+ getMethod.getStatusLine());", "\n                  filePath=null;", "\n              }", "\n\n", "          /*4.处理 HTTP 响应内容（返回的状态码正确后，即可取得内容）*/\n          /*取得目标地址的内容有三种方法：\n          1 getResponseBody，该方法返回的是目标的二进制的byte流；\n          2 getResponseBodyAsString，返回的是String类型，值得注意的是该方法返回的String的编码是根据系统默认的编码方式，所以返回的String值可能编码类型有误\n          3 getResponseBodyAsStream，这个方法对于目标地址中有大量数据需要传输是最佳的。\n                  在这里我们使用了最简单的getResponseBody方法。*/\n", "\n\n", "byte[] responseBody = getMethod.getResponseBody();//读取为字节数组", "\n              //根据网页 url 生成保存时的文件名", "\nfilePath=\"E:\\java\\web spider\\\"+getFileNameByUrl(url,", "\n           getMethod.getResponseHeader(\"Content-Type\").getValue());", "\n            saveToLocal(responseBody,filePath);", "\n          } catch (HttpException e) {", "\n                   // 发生致命的异常，可能是协议不对或者返回的内容有问题", "\n                   System.out.println(\"Please check your provided http address!\");", "\n                   e.printStackTrace();", "\n                  } catch (IOException e) {", "\n                   // 发生网络异常", "\n                   e.printStackTrace();", "\n                  } finally {", "\n                   // 释放连接", "\n                   getMethod.releaseConnection();", "\n                  }", "\n                  return filePath;", "\n    }", "\n}", "\n调用他的爬行代码如下：", "\npublic class Crawler {", "\n    /* 使用种子 url 初始化 URL 队列*/", "\n    String results=\"\";", "\n    private void initCrawlerWithSeeds(String[] seeds)", "\n    {", "\n        for(int i=0;i<seeds.length;i++)", "\n            LinkDB.addUnvisitedUrl(seeds[i]);", "\n    }", "\n\n", "/* 爬取方法*/\npublic void crawling(String[] seeds,JTextArea kkk)\n{\n    LinkFilter filter = new LinkFilter(){\n        //提取以 用户输入的URL开头的链接\n        public boolean accept(String url) {\n            if(url.startsWith(url))\n                return true;\n            else\n                return false;\n        }\n    };\n    //初始化 URL 队列\n    initCrawlerWithSeeds(seeds);\n    //循环条件：待抓取的链接不空且抓取的网页不多于 1000\n    while(!LinkDB.unVisitedUrlsEmpty()&&LinkDB.getVisitedUrlNum()<=1000)\n    {\n        //队头 URL 出对\n        String visitUrl=LinkDB.unVisitedUrlDeQueue();\n        if(visitUrl==null)\n            continue;\n        FileDownLoader downLoader=new FileDownLoader();\n        //下载网页\n        downLoader.downloadFile(visitUrl);\n        //该 url 放入到已访问的 URL 中\n        LinkDB.addVisitedUrl(visitUrl);\n        //提取出下载网页中的 URL\n\n        Set<String> links=HtmlParserTool.extractLinks(visitUrl,filter);\n    Iterator<String> it = links.iterator(); //迭代器\n        while(it.hasNext())\n        {  \n            results=results+'\\n'+it.next();\n\n        }\n\n     kkk.setText(results);\n\n\n    }\n}\n", "\n\n", "}", "\n求各位大神帮忙解答，马上就要中期检查了"]], "Tag": "算法设计"}
{"Answer": "你是不是打开视频网址后打开的wireshark? 你的目标网址就是https的协议，是能看到https协议的， 但估计看不到你要的url. wireshark 是不能做https解析的或许你应该用mitmproxy", "Konwledge_Point": "网络中的流", "Question": ["想用wireshark找视频地址，但抓的包只有TCP，没有http、get等，接下来该如何操作？", ["额，本人wireshark新手（大部分网络协议都只是了解，但分层、三次握手等还是知道的），TCP-IP学得太枯燥了，想动手实践加深一点印象", "\n\n", "听说利用wireshark可以找到视频的真实地址，于是我参照了（", "https://blog.csdn.net/u012206807/article/details/14521917?locationnum=2）", " 这篇博文，想亲手实践一下，", "\n\n", "比如目标是(   ", "https://www.bilibili.com/video/av24502164/", "   )这个视频", "\n\n", "但是我只能找到视频发送的ip、端口，自己的ip、端口，出现的所有协议都是ARP、SSL、TCP、TLSv1.2等，就是没有文中所说的http。不知道是我的wireshark隐蔽掉了http呢？还是这视频就不是用http的协议来传输？还是说视频地址已经包含在里面了，只是我不懂得利用？？？我应该补充哪方面的知识呢？", "\n\n", "其实我最想知道的是，想下载一个视频，有没有一套通用的流程？每个步骤需要掌握哪些知识呢？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你好。我也这问题&amp;#xff0c;问问你解决了吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["大华SDK下载录像DEMO问题", ["你好，我想问一下，我把之前用的JFrame框架进行了修改，然后下载录像成功之后，文件的大小确为0K，不知道哪里有问题，请教一下", "\n", "public", " ", "class", " ", "DowmLoadRecordFile", " {\n    ", "private", " ", "String", " ", "m_strIp", " ", "=", " ", "\"117.172.167.248\"", ";\n    ", "private", " ", "int", " ", "m_nPort", " ", "=", " ", "38888", ";\n    ", "private", " ", "String", " ", "m_strUser", " ", "=", " ", "\"admin\"", ";\n    ", "private", " ", "String", " ", "m_strPassword", " ", "=", " ", "\"YBGX1234\"", ";\n\n    ", "// 开始时间", "\n    ", "private", " NetSDKLib.", "NET_TIME", " ", "stTimeStart", " ", "=", " ", "new", " ", "NetSDKLib", ".NET_TIME();\n\n    ", "// 结束时间", "\n    ", "private", " NetSDKLib.", "NET_TIME", " ", "stTimeEnd", " ", "=", " ", "new", " ", "NetSDKLib", ".NET_TIME();\n\n    ", "// 设备信息扩展", "\n    ", "private", " NetSDKLib.", "NET_DEVICEINFO_Ex", " ", "deviceInfo", " ", "=", " ", "new", " ", "NetSDKLib", ".NET_DEVICEINFO_Ex();\n\n    ", "public", " ", "static", " ", "final", " ", "NetSDKLib", " ", "netSdk", " ", "=", " NetSDKLib.NETSDK_INSTANCE;\n\n    ", "// 登陆句柄", "\n    ", "private", " NetSDKLib.", "LLong", " ", "loginHandle", " ", "=", " ", "new", " ", "NetSDKLib", ".LLong(", "0", ");\n\n    ", "private", " NetSDKLib.", "LLong", " ", "m_hDownLoadByTimeHandle", " ", "=", " ", "new", " ", "NetSDKLib", ".LLong(", "0", ");   ", "// 按时间下载句柄", "\n\n    ", "private", " ", "DownLoadPosCallBackByTime", " ", "m_DownLoadPosByTime", " ", "=", " ", "new", " ", "DownLoadPosCallBackByTime", "(); ", "// 录像下载进度", "\n\n    ", "class", " ", "DownLoadPosCallBackByTime", " ", "implements", " ", "NetSDKLib", ".fTimeDownLoadPosCallBack {\n        ", "@Override", "\n        ", "public", " ", "void", " ", "invoke", "(NetSDKLib.LLong lLoginID, ", "final", " ", "int", " dwTotalSize, ", "final", " ", "int", " dwDownLoadSize, ", "int", " index, NetSDKLib.NET_RECORDFILE_INFO.ByValue recordfileinfo, Pointer dwUser)", " {\n            ", "if", "(dwDownLoadSize == -", "1", ") {\n                DownLoadRecordModule.stopDownLoadRecordFile(m_hDownLoadByTimeHandle);\n            }\n        }\n    }\n\n    ", "// 网络连接恢复", "\n    ", "private", " ", "static", " ", "HaveReConnect", " ", "haveReConnect", " ", "=", " ", "new", " ", "HaveReConnect", "();\n\n    ", "// 网络连接恢复，设备重连成功回调", "\n    ", "// 通过 CLIENT_SetAutoReconnect 设置该回调函数，当已断线的设备重连成功时，SDK会调用该函数", "\n    ", "private", " ", "static", " ", "class", " ", "HaveReConnect", " ", "implements", " ", "NetSDKLib", ".fHaveReConnect {\n        ", "@Override", "\n        ", "public", " ", "void", " ", "invoke", "(NetSDKLib.LLong m_hLoginHandle, String pchDVRIP, ", "int", " nDVRPort, Pointer dwUser)", " {\n            System.out.printf(", "\"ReConnect Device[%s] Port[%d]\\n\"", ", pchDVRIP, nDVRPort);\n        }\n    }\n\n    ", "//1.初始化", "\n    ", "public", " ", "void", " ", "init", "()", " {\n", "//        netSdk.CLIENT_Init(DowmLoadRecordFile.DisConnectCallBack.getInstance(), null);", "\n        LoginModule.init(DowmLoadRecordFile.DisConnectCallBack.getInstance(), haveReConnect);   ", "// 打开工程，初始化", "\n    }\n\n    ", "//2.登陆", "\n    ", "public", " ", "void", " ", "Login", "()", " {\n        ", "// 登陆设备", "\n", "//        int nSpecCap = NetSDKLib.EM_LOGIN_SPAC_CAP_TYPE.EM_LOGIN_SPEC_CAP_TCP;    // TCP登入", "\n", "//        IntByReference nError = new IntByReference(0);", "\n", "//        loginHandle = netSdk.CLIENT_LoginEx2(m_strIp, m_nPort, m_strUser,", "\n", "//                m_strPassword, nSpecCap, null, deviceInfo, nError);", "\n", "//        if (loginHandle.longValue() != 0) {", "\n", "//            System.out.printf(\"Login Device[%s] Success!\\n\", m_strIp);", "\n", "//        } else {", "\n", "//            System.err.printf(\"Login Device[%s] Fail.Error[0x%x]\\n\", m_strIp, netSdk.CLIENT_GetLastError());", "\n", "//            LoginOut();", "\n", "//        }", "\n\n        ", "if", "(LoginModule.login(m_strIp,\n                m_nPort,\n                m_strUser,\n                m_strPassword)){\n            DownLoadRecordModule.setStreamType(", "0", ");\n            System.out.printf(", "\"Login Device[%s] Success!\\n\"", ", m_strIp);\n        }", "else", "{\n            System.err.printf(", "\"Login Device[%s] Fail.Error[0x%x]\\n\"", ", m_strIp, netSdk.CLIENT_GetLastError());\n            LoginOut();\n        }\n    }\n\n    ", "//3.执行流程", "\n    ", "public", " ", "void", " ", "run", "(LocalDateTime startTime, LocalDateTime endTime)", " {\n        ", "int", " ", "m_streamType", " ", "=", " ", "0", ";\n        ", "int", " ", "nChannelId", " ", "=", " ", "0", ";\n        ", "int", " ", "nRecordFileType", " ", "=", " ", "0", ";\n\n        stTimeStart.dwYear = startTime.getYear();\n        stTimeStart.dwMonth = startTime.getMonth().getValue();\n        stTimeStart.dwDay = startTime.getDayOfMonth();\n        stTimeStart.dwHour = startTime.getHour();\n        stTimeStart.dwMinute = startTime.getMinute();\n        stTimeStart.dwSecond = startTime.getSecond();\n\n        stTimeEnd.dwYear = endTime.getYear();\n        stTimeEnd.dwMonth = endTime.getMonth().getValue();\n        stTimeEnd.dwDay = endTime.getDayOfMonth();\n        stTimeEnd.dwHour = endTime.getHour();\n        stTimeEnd.dwMinute = endTime.getMinute();\n        stTimeEnd.dwSecond = endTime.getSecond();\n\n\n        ", "//设置回放时的码流类型", "\n        DownLoadRecordModule.setStreamType(m_streamType);\n        NetSDKLib.", "LLong", " ", "m_hDownLoadByFileHandle", " ", "=", " ", "new", " ", "NetSDKLib", ".LLong();\n        ", "//下载录像", "\n        m_hDownLoadByFileHandle = DownLoadRecordModule.downloadRecordFile(nChannelId,\n                nRecordFileType,\n                stTimeStart,", "//20210723171834", "\n                stTimeEnd,", "//20210723171934", "\n                SavePath.getSavePath().getSaveRecordFilePath(),", "//./RecordFile/2021-07-23/2021-07-23_17-25-14.dav", "\n                ", "null", ");\n\n        ", "//停止下载", "\n        DownLoadRecordModule.stopDownLoadRecordFile(m_hDownLoadByFileHandle);\n\n        ", "if", " (m_hDownLoadByFileHandle.longValue() != ", "0", ") {\n            System.out.println(", "\"下载完成\"", ");\n        }\n    }\n\n    ", "//登出", "\n    ", "public", " ", "void", " ", "LoginOut", "()", " {\n        System.out.println(", "\"End Test\"", ");\n\n        ", "if", " (loginHandle.longValue() != ", "0", ") {\n            netSdk.CLIENT_Logout(loginHandle);\n        }\n        System.out.println(", "\"See You...\"", ");\n\n        netSdk.CLIENT_Cleanup();\n        System.exit(", "0", ");\n    }\n\n    ", "/**\n     * 设备断线回调\n     */", "\n    ", "private", " ", "static", " ", "class", " ", "DisConnectCallBack", " ", "implements", " ", "NetSDKLib", ".fDisConnect {\n\n        ", "private", " ", "DisConnectCallBack", "()", " {\n        }\n\n        ", "private", " ", "static", " ", "class", " ", "CallBackHolder", " {\n            ", "private", " ", "static", " DowmLoadRecordFile.", "DisConnectCallBack", " ", "instance", " ", "=", " ", "new", " ", "DowmLoadRecordFile", ".DisConnectCallBack();\n        }\n\n        ", "public", " ", "static", " DowmLoadRecordFile.DisConnectCallBack ", "getInstance", "()", " {\n            ", "return", " DowmLoadRecordFile.DisConnectCallBack.CallBackHolder.instance;\n        }\n\n        ", "@Override", "\n        ", "public", " ", "void", " ", "invoke", "(NetSDKLib.LLong lLoginID, String pchDVRIP, ", "int", " nDVRPort, Pointer dwUser)", " {\n            System.out.printf(", "\"Device[%s] Port[%d] DisConnect!\\n\"", ", pchDVRIP, nDVRPort);\n        }\n    }\n\n\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "DowmLoadRecordFile", " ", "dowmLoadRecordFile", " ", "=", " ", "new", " ", "DowmLoadRecordFile", "();\n        dowmLoadRecordFile.init();\n        dowmLoadRecordFile.Login();\n        dowmLoadRecordFile.run(LocalDateTime.of(", "2021", ", Month.JULY, ", "26", ", ", "9", ", ", "37", ", ", "56", "), LocalDateTime.of(", "2021", ", Month.JULY, ", "26", ", ", "9", ", ", "38", ", ", "56", "));\n        dowmLoadRecordFile.LoginOut();\n    }\n}\n\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/CETET/article/details/128893442\" id=\"textarea_1679620618265_1679620677106_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/CETET/article/details/128893442&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在Linux下如何获取摄像头数据推流", ["在Linux下，我该如何获取摄像头数据，再将摄像头数据通过网络进行推流，进而实现实时视频监控的功能？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;avpacket 的 data 保存为 h264 是不正确的方式。avpacket 中的 data 是视频压缩数据的一部分&amp;#xff0c;需要进行解码才能得到原始图像数据。如果希望保存为 h264&amp;#xff0c;可以将 avpacket 中的压缩数据写入到一个编码器中&amp;#xff0c;编码成 h264 格式后再保存为文件。在代码中&amp;#xff0c;可以使用 libx264 之类的编码器进行编码。另外&amp;#xff0c;在编码之前需要设置编码器的参数&amp;#xff0c;包括分辨率、帧率、码率等等。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["拉取的流保存为h264无法播放 是为什么?", ["avpacket 的 data 不能直接保存为h264吗?", "\n", "\n", "#", "include", " ", "<thread>", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<fstream>", "\n", "extern", " ", "\"C\"", "\n{\n", "#", "include", " ", "<libavcodec/avcodec.h>", "\n", "#", "include", " ", "<libavcodec/bsf.h>", "\n", "#", "include", " ", "<libavformat/avformat.h>", "\n}\n\n", "#", "pragma", " comment(lib,", "\"avcodec.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avdevice.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avfilter.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avformat.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avutil.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"swresample.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"swscale.lib\"", ")", "\n\n", "int", " ", "mp4toannexb", "(AVBSFContext* bsf_ctx, AVPacket* pkt, std::ofstream& out)", "\n", "{\n    ", "int", " ret;\n\n    ret = ", "av_bsf_send_packet", "(bsf_ctx, pkt);\n    ", "if", " (ret < ", "0", ") {\n        std::cout << ", "\"bsf send packet failed, errno:\"", " << ret << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ", "for", " (;;) {\n        ret = ", "av_bsf_receive_packet", "(bsf_ctx, pkt);\n        ", "if", " (AVERROR_EOF == ret || ", "AVERROR", "(EAGAIN) == ret) {\n            ", "return", " ", "0", ";\n        }\n        ", "if", " (ret < ", "0", ") {\n            std::cout << ", "\"Could not receive packet, errno:\"", " << ret << std::endl;\n            ", "return", " ", "-1", ";\n        }\n        out.", "write", "((", "const", " ", "char", "*)pkt->data, pkt->size);\n    }\n    ", "return", " ", "0", ";\n}\n\n\n", "int", " ", "main", "()", "\n", "{\n    AVOutputFormat* ofmt = ", "NULL", ";\n    AVFormatContext* ifmt_ctx = ", "NULL", ";\n    AVBSFContext* bsf_ctx = ", "NULL", ";\n    AVPacket* pkt = ", "NULL", ";\n    ", "const", " ", "char", "* in_filename = ", "\"http://219.151.31.38/liveplay-kk.rtxapp.com/live/program/live/hnwshd/4000000/mnf.m3u8\"", ";\n    ", "int", " ret = ", "-1", ";\n    ", "int", " video_index = ", "-1", ";\n    ", "std::ofstream ", "outh264", "(", "\"D:\\\\ConsoleApplication1\\\\Debug\\\\out.h264\"", ", std::ios::binary | std::ios::trunc)", ";\n    ", "// 初始化网络", "\n    ", "avformat_network_init", "();\n\n    ", "// 初始化输入格式上下文  ", "\n    ", "if", " ((ifmt_ctx = ", "avformat_alloc_context", "()) == ", "NULL", ") {\n        std::cout << ", "\"avformat_alloc_context failed.\"", " << std::endl;\n        ", "exit", "(", "1", ");\n    }\n\n    ", "// 打开输入格式上下文", "\n    ", "if", " ((ret = ", "avformat_open_input", "(&ifmt_ctx, in_filename, ", "0", ", ", "0", ")) < ", "0", ") {\n        std::cout << ", "\"Could not open input file.\"", " << std::endl;\n        ", "exit", "(", "1", ");\n    }\n\n    ", "// 获取输入信息", "\n    ", "if", " ((ret = ", "avformat_find_stream_info", "(ifmt_ctx, ", "0", ")) < ", "0", ") {\n        std::cout << ", "\"Failed to retrieve input stream information\"", " << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ", "// 申请pkt", "\n    ", "if", " (!(pkt = ", "av_packet_alloc", "())) {\n        std::cout << ", "\"Could not allocate packet\"", " << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    video_index = ", "av_find_best_stream", "(ifmt_ctx, AVMEDIA_TYPE_VIDEO, ", "-1", ", ", "-1", ", ", "NULL", ", ", "0", ");\n    ", "if", " (video_index < ", "0", ") {\n        std::cout << ", "\"Could not find stream \"", " << std::", "string", "(", "av_get_media_type_string", "(AVMEDIA_TYPE_VIDEO)) << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ", "av_dump_format", "(ifmt_ctx, ", "0", ", in_filename, ", "0", ");\n\n    ", "const", " AVBitStreamFilter* filter = ", "av_bsf_get_by_name", "(", "\"h264_mp4toannexb\"", ");\n    ", "if", " (", "NULL", " == filter) {\n        std::cout << ", "\"Could not create filter\"", " << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ret = ", "av_bsf_alloc", "(filter, &bsf_ctx);\n    ", "if", " (ret < ", "0", ") {\n        ", "printf", "(", "\"Could not alloc bitstream filter \\n\"", ");\n        ", "return", " ", "-1", ";\n    }\n\n    ", "// avcodec_parameters_from_context", "\n    ret = ", "avcodec_parameters_copy", "(bsf_ctx->par_in, ifmt_ctx->streams[video_index]->codecpar);\n    ", "if", " (ret < ", "0", ") {\n        ", "printf", "(", "\"Parameter copy filed, errno: %d \\n\"", ", ret);\n        ", "return", " ", "-1", ";\n    }\n\n    ret = ", "av_bsf_init", "(bsf_ctx);\n    ", "if", " (ret < ", "0", ") {\n        ", "printf", "(", "\"BSF init failed, errno: %d \\n\"", ", ret);\n        ", "return", " ", "-1", ";\n    }\n\n    ", "while", " (", "av_read_frame", "(ifmt_ctx, pkt) >= ", "0", ") {\n        ", "if", " (pkt->stream_index == video_index)\n        {\n            ", "mp4toannexb", "(bsf_ctx, pkt, outh264);\n        }\n        ", "av_packet_unref", "(pkt);\n    }\n    ", "// 释放", "\n    outh264.", "close", "();\n    ", "avformat_close_input", "(&ifmt_ctx);\n    ", "av_packet_free", "(&pkt);\n    ", "av_bsf_free", "(&bsf_ctx);\n\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我觉得一个很简单的做法是&amp;#xff0c;在客户端就识别出类型&amp;#xff0c;传输的时候把文件类型一起带给你&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["java TCP通信中服务器怎么区分客户端发来的文件类型?", ["问题遇到的现象和发生背景", "\n", "我最近遇到一个问题，就是我学到TCP通信的时候，假如，我作为客户端发送文件给服务器的时候，如果这个文件是一个.jpg的照片，那么我就得在服务器的文件保存路径的末尾加上.jpg   。这样不就变成面向结果编程了嘛？因为我客服端发送的文件是随机格式的，那么服务端应该怎么区别并接收不同类型的文件呢？", "\n", "问题相关代码，请勿粘贴截图", "\n", "这是客户端的代码", "\n", "import", " java.net.Socket;\n", "import", " java.io.*;\n", "//   （主线程负责发消息，子线程负责收消息）", "\n", "public", " ", "class", " ", "Client", "{\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "try", " {\n            System.out.println(", "\"====客户端启动===\"", ");\n            ", "Socket", " ", "socket", " ", "=", " ", "new", " ", "Socket", "(", "\"127.0.0.1\"", ", ", "9998", ");\n            ", "new", " ", "ClientThread", "(socket).start();", "//新的线程 这个线程用于消息的接收", "\n\n\n            ", "//1.先将磁盘中的文件读到内存中来    （使用 字节输入流）", "\n            InputStream f=", "new", " ", "FileInputStream", "(", "\"E:\\\\Documets\\\\Desktop\\\\123.jpg\"", ");\n            BufferedInputStream br=", "new", " ", "BufferedInputStream", "(f);      ", "//包装成字节缓存输入流  传送速度快", "\n\n            ", "//2.将内存中文件数据 发送到网络介质上   （使用字节输出流）", "\n            ", "OutputStream", " ", "os", " ", "=", " socket.getOutputStream();     ", "//定义发送管道", "\n            ", "PrintStream", " ", "ps", " ", "=", " ", "new", " ", "PrintStream", "(os);           ", "//包装成打印流 速度更快！！！", "\n\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n            ", "int", " len;\n            ", "while", " ((len = br.read(buffer)) != -", "1", ") {             ", "//通过 缓存字节输入流 接收字节到 buffer中去 并记录数组中的长度len", "\n                ps.write(buffer, ", "0", ", len);          ", "//将buffer中的字节 通过打印流 发送到网络介质中去", "\n            }\n            ps.flush();\n            socket.shutdownOutput();            ", "//关闭io  而不关闭管道！", "\n            System.out.println(", "\"文件发给服务器成功！\"", ");\n\n            ", "// 关闭资源。", "\n            ", "//socket.close();", "\n\n        } ", "catch", " (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n", "\n", "这是 客户端 子线程的的代码", "\n", "import", " java.io.*;\n", "import", " java.net.Socket;\n\n", "//这个线程类  作为 接收客户端读服务器发来的消息", "\n", "public", " ", "class", " ClientThread ", "extends", " Thread {", "//线程类 要继承Thread 或者实现 Runnable 接口", "\n    ", "private", "  Socket  socket;              ", "//用来存套接字", "\n    ", "public", " ClientThread (Socket socket){   ", "//构造方法，用来接收  与服务器连接的管道对管道进行读操作", "\n        ", "this", ".socket = socket;\n    }\n    @Override\n    ", "public", " ", "void", " run() {", "//重写run方法", "\n        ", "try", " {\n            ", "//1.定义 字节输入流 从网络介质中获取数据存入内存中", "\n            InputStream is=socket.getInputStream();\n            BufferedInputStream br=", "new", " BufferedInputStream(is);      ", "//包装成字节缓存输入流  传送速度快", "\n\n            ", "//2. 定义 打印流将文件数据从内存中写入磁盘", "\n            ", "File", " ", "file", "=", "new", " ", "File", "(", "\"E:\\\\Documets\\\\Desktop\\\\客户\\\\服务器发来的.jpg\"", ");      ", "//选择保存路径", "\n            PrintStream ps = ", "new", " PrintStream(", "file", ");\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n            ", "int", " len;\n            ", "while", "( (len= br.", "read", "(buffer))!=-", "1", " ){\n                ps.", "write", "(buffer,", "0", ",len);             ", "//将文件写入上面的文件路径中去", "\n            }\n            ps.flush();\n            System.out.", "println", "(", "\"接收来自服务器的文件成功!\"", ");\n        } ", "catch", " (Exception e) {\n            System.out.", "println", "(", "\"与服务器断开连接！\"", ");\n        }\n\n\n    }\n}\n\n\n\n", "\n", "这是 服务器的代码", "\n", "import", " java.net.ServerSocket;\n", "import", " java.net.Socket;\n", "import", " java.util.ArrayList;\n", "import", " java.util.List;\n", "//使用两个线程 主线程 用于将连接过来的套接字 添加到集合 代表当前在线的人数", "\n", "public", " ", "class", " ", "Server", " {\n    ", "/*创建一个Socket的list集合 用来装套接字  Socket=（IP地址：端口号）   */", "\n    ", "public", " ", "static", " ", "final", " List<Socket> onLineSockets = ", "new", " ", "ArrayList", "<>();  ", "//当客户端连接上服务器的时候，就将客户端的套接字存入集合中", "\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "try", " {\n            System.out.println(", "\"===服务端启动成功===\"", ");\n            ", "// 1、注册端口", "\n            ", "ServerSocket", " ", "serverSocket", " ", "=", " ", "new", " ", "ServerSocket", "(", "9998", ");\n            ", "// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。", "\n            ", "while", " (", "true", ") {\n                ", "// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息", "\n                ", "Socket", " ", "socket", " ", "=", " serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ ", "\"上线了！\"", ");\n                ", "//这里可以加上日志框架 打印日志", "\n                onLineSockets.add(socket);", "// 把当前客户端管道Socket加入到在线集合中去", "\n                ", "// 3、开始创建独立线程处理socket", "\n                ", "new", " ", "ServerThread", "(socket).start();\n            }\n        } ", "catch", " (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "\n", "这是服务器子线程的代码", "\n", "\n```java\n", "import", " java.io.*;\n", "import", " java.net.Socket;\n\n", "//创建线程类 本类用于数据的发送", "\n", "public", " ", "class", " ServerThread  ", "extends", "  Thread{\n    ", "private", "  Socket socket;\n\n    ", "public", " ServerThread  (Socket socket) {\n        ", "this", ".socket = socket;\n    }\n\n    @Override\n    ", "public", " ", "void", " run() { ", "//重写run方法", "\n        ", "try", " {\n            ", "//1. 定义字节输入流，用于将网络介质上的文件数据 输入到内存（接收来自某一客户的文件数据）", "\n            InputStream is=socket.getInputStream();\n            BufferedInputStream br=", "new", " BufferedInputStream(is);      ", "//包装成字节缓存输入流  传送速度快", "\n\n            ", "//2. 定义 打印流将文件数据从内存中写入磁盘  （接收来自客户端的文件 先存到服务器的磁盘下面）", "\n            ", "File", " ", "file", "=", "new", " ", "File", "(", "\"E:\\\\Documets\\\\Desktop\\\\服务器\\\\客户端发来的123.jpg\"", ");      ", "//服务器的保存路径", "\n            PrintStream ps0 = ", "new", " PrintStream(", "file", ");\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n            ", "int", " len;\n            ", "while", "((len= br.", "read", "(buffer))!=-", "1", "){\n                ps0.", "write", "(buffer ,", "0", " ,len);\n                ps0.flush();\n            }\n            socket.shutdownInput();\n            System.out.", "println", "(", "\"接收来自 \"", "+socket.getRemoteSocketAddress()+ ", "\"的文件成功！\\n\"", ");\n\n            ", "//将文件发给所有人", "\n            sendFileToAll(", "file", ");\n\n        } ", "catch", " (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n    ", "//将字符串进行发送", "\n    ", "private", " ", "void", " sendFileToAll(", "File", " ", "file", ") {\n        ", "try", " {\n            ", "//3.将服务器磁盘中的文件 输入到内存中来", "\n            InputStream is=", "new", " FileInputStream(", "file", ");       ", "//多态 子类对象 传给父类类型", "\n            BufferedInputStream br=", "new", " BufferedInputStream(is);      ", "//包装成字节缓存输入流  传送速度快", "\n\n             ", "//4.定义字节输出流 ，用于将内存中的文件 输出到网络上 （将文件发给别的客户）", "\n           OutputStream os=socket.getOutputStream();\n           PrintStream ps = ", "new", " PrintStream(os);            ", "//包装成打印流", "\n           ", "//BufferedOutputStream bos=new BufferedOutputStream(os);", "\n\n            ", "int", " len;\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n           ", "// for (Socket onLineSocket : Server.onLineSockets) {", "\n                ", "// 除了自己的socket，其他socket我都发！！", "\n                ", "if", "(", "true", "){\n                    ", "while", " ((len=br.", "read", "(buffer))!=-", "1", ") {            ", "//通过 缓存字节输入流 接收字节到 buffer中去 并记录数组中的长度len", "\n                      ps.", "write", "(buffer, ", "0", " , len);          ", "//将buffer中的字节 通过打印流 发送到网络介质中去", "\n                    }\n                }\n          ", "//  }", "\n", "//            br.close();", "\n", "//            ps.close();", "\n            socket.shutdownOutput();\n            System.out.", "println", "(", "\"发送给所有客户成功！\"", ");\n        } ", "catch", " (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "\n", "真的不知道怎么解决 。", "因为服务器不知道网络介质上的文件 是什么格式的  所以应该怎么接收呢?", "\n", "\n", "\n", "运行结果及报错内容", "\n", "然后现在的问题就是，第二步到第三步，服务器怎么知道网络上的数据是.jpg格式？", "\n", "我的解答思路和尝试过的方法", "\n", "是不是要先用正则表达式先截取小数点后面的格式类型，然后作为消息发过先  然后再进行字符串的拼接，再创建服务器的文件对象？", "\n", "我想要达到的结果", "\n", "我希望能达到的效果是 ：客户端发送文件到服务器，然后服务器能区别文件格式并将他保存到服务器的磁盘下，然后再将磁盘的文件发回给客户端"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;011111011111101001111011111110  起始标志为01111110&amp;#xff0c;结束标志为01111110&amp;#xff0c;数据部分为011110111111&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["计算机网络HDLC成帧", ["用HDLC成帧方式将数据流0111101111110成帧得到什么"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;client.shutdownOutput();是关闭服务器连接&amp;#xff0c;关闭连接后 在通过输入流读取in.read();就会造成题主说的&amp;#34;获取不到Socket的返回值&amp;#34;的问题。&lt;br /&gt;按照如下代码块修改即可&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n//输出完后&amp;#xff0c;需要关闭socket的输出通道&amp;#xff0c;表示不存向服务端输出内容\nclient.shutdownOutput()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n//读取socket的返回值\nint readLen &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; in.read()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;\n这部分代码改为下面的代码&amp;#xff1a;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;\n&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;\n\n\n//读取socket的返回值\nint readLen &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; in.read()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n//输出完后&amp;#xff0c;需要关闭socket的输出通道&amp;#xff0c;表示不存向服务端输出内容\nclient.shutdownOutput()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["串口转网络调试组手能正常接受到返回数据，但是java的socket获取不到返回值", ["我使用的有人的串口服务器，调试助手都是的正常的，", "\n\n", "我使用java的socket给TCP的服务器发送数据，也是正常的，就是获取不到Socket的返回值", "\n\n", "下面是测试的代码", "\n\n", "\n", "    @Test\n    public void test1() throws IOException, InterruptedException {\n        //客户端\n        String send = SocketTools.send(\"192.168.0.7\", 26, \"8A0101119B\");\n        System.out.println(\"send = \" + send);\n    }", "\n\n", "下面是工具类", "\n\n", "\n", "​\npackage com.applida.util.socket;\n\nimport com.applida.util.TjStringUtil;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * @author JL\n * @version V1.0\n * @Description 用java.net.Socket进行Socket操作工具类\n */\npublic class SocketTools {\n\n    /**\n     * 发送数据\n     *\n     * @param host    ip地址\n     * @param port    端口\n     * @param content 内容\n     * @throws IOException\n     */\n    public static String send(String host, int port, String content) throws IOException {\n        Socket client = null;\n        String msg;\n        InputStream in = null;\n        OutputStream out = null;\n        if (StringUtils.isEmpty(host) || port == 0 || StringUtils.isEmpty(content)) {\n            return null;\n        }\n        //去除空字符串\n        content = content.replace(\" \", \"\");\n        try {\n            //创建连接\n            client = new Socket(host, port);\n            //设置超时时间\n            client.setSoTimeout(2000);\n            //socket返回的数据流\n            in = client.getInputStream();\n            //socket发送的流（输出流）\n            out = client.getOutputStream();\n            //content按16进制字符串发送\n            out.write(TjStringUtil.hexStrToBytes(content));\n            //输出完后，需要关闭socket的输出通道，表示不存向服务端输出内容\n            client.shutdownOutput();\n            //读取socket的返回值\n            int readLen = in.read();\n            System.out.println(\"返回值长度 = \" + readLen);\n            msg = receive(in);\n            return msg;\n        } catch (UnknownHostException uhe) {\n            uhe.printStackTrace();\n            throw new IOException(\"主机连接创建异常：\" + uhe.getMessage());\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            throw ioe;\n        } finally {\n            streamClose(in, out);\n            clientClose(client);\n        }\n    }\n\n    public static void streamClose(InputStream in, OutputStream out) {\n        //IOUtils.closeQuietly(in); 可用IOUtils工具类关闭流\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                System.out.println(\"关闭输入流异常：\" + ioe.getMessage());\n            }\n        }\n        if (out != null) {\n            try {\n                out.flush();\n                out.close();\n            } catch (IOException ioe) {\n                System.out.println(\"关闭输出流异常：\" + ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * 创建一个客户端Socket连接\n     *\n     * @param host ip地址\n     * @param port 端口号\n     * @return\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    private static Socket createClientSocket(String host, int port) throws UnknownHostException, IOException {\n        return new Socket(host, port);\n    }\n\n\n    private static void clientClose(Socket socket) {\n        if (socket != null && !socket.isClosed()) {\n            try {\n                socket.close();\n            } catch (IOException ioe) {\n                System.out.println(\"Socket关闭异常：\" + ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * 发送数据\n     *\n     * @param out\n     * @param content\n     * @return\n     * @throws IOException\n     */\n    public static OutputStream output(OutputStream out, String content) throws IOException {\n        try {\n//            out.write(content.getBytes(ENCODING));\n            out.write(TjStringUtil.hexStrToBytes(content));\n        } finally {\n            return out;\n        }\n    }\n\n    /**\n     * 接受返回的数据\n     *\n     * @param in\n     * @return\n     * @throws IOException\n     */\n    public static String input(InputStream in) throws IOException {\n        int len;\n        char[] b = new char[1024];\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader;\n        try {\n            //以字符流为主，如需字节流，则不需要BufferedReader和InputStreamReader，可以直接从InputStream中获取或采用对应缓冲包装类\n            reader = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n            while ((len = reader.read(b)) != -1) {\n                sb.append(b, 0, len);\n            }\n            //reader.close();\n        } finally {\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 接受服务器返回的数据\n     *\n     * @return 16进制字符串\n     */\n    public static String receive(InputStream is) {\n        try {\n            //客户端开始接受请求\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            String result = br.readLine();\n            System.out.println(\"result = \" + result);\n//        byte[] buffer = new byte[128];\n//        int data;\n//        String result = null;\n//        try {\n//            int len = 0;\n//            while ((data = in.read()) > -1) {\n//                buffer[len++] = (byte) data;\n//            }\n//            byte[] copyValue = new byte[len];\n//            System.arraycopy(buffer, 0, copyValue, 0, len);\n//            result = TjStringUtil.bytesToString(copyValue);\n//            System.out.println(\"设备->电脑的数据 = \" + result);\n//        } catch (IOException e) {\n//            e.printStackTrace();\n//        }\n            return result;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n\n    public interface SocketFunction {\n        /**\n         * socket信息回调\n         *\n         * @param msg\n         */\n        void callback(String msg);\n    }\n\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String data = \"这是测试数据：\";\n        String send = send(\"192.168.0.7\", 26, \"8A0101119B\");\n        System.out.println(\"send = \" + send);\n        //测试时，请分别单独启动send和listen方法\n        //客户端\n//        send(\"192.168.0.7\", 26, \"8A0101119B\", new SocketFunction() {\n//            @Override\n//            public void callback(String msg) {\n//                System.out.println(data + msg);\n//            }\n//        });\n//        System.in.read();\n\n//        //服务端\n//        listen(8111, \"this is server test\", new SocketFunction() {\n//            @Override\n//            public void callback(String msg) {\n//                System.out.println(data + msg);\n//            }\n//        });\n    }\n\n}\n\n​"]], "Tag": "算法设计"}
{"Answer": "已经找到问题，问题出在JavaFX的application线程，需要给服务器也分配一个线程，否则两者会发生冲突，导致程序无法正常启动。\r\n具体修改程序代码如下,由于有人说看起来太复杂，稍作删减：\r\n\r\n\r\n```\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\nimport javafx.application.Application;\r\nimport javafx.application.Platform;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.ScrollPane;\r\nimport javafx.scene.control.TextArea;\r\nimport javafx.stage.Stage;\r\n\r\npublic class net extends Application{\r\n\t//创建显示文本域\r\n\tprivate TextArea area = new TextArea();\r\n\t\r\n\tpublic void start(Stage primaryStage){\r\n\t\r\n\t\tScene scene = new Scene(new ScrollPane(area), 450,300);\r\n\t\tprimaryStage.setTitle(\"Test2_2Server\");\r\n\t\tprimaryStage.setScene(scene);\r\n\t\tprimaryStage.show();\r\n\t\t\r\n   \t//此处做修改，为服务器分配线程\r\n\t\tnew Thread(() -&gt;{\r\n\t\t\ttry {\r\n\t\t\t\t//创建一个服务器套接字\r\n\t\t\t\tServerSocket serverSocket = new ServerSocket(8000);\r\n\t\t\t\t\r\n\t\t\t\tarea.appendText(\"Server started at \" + new Date() + '\\n');\r\n\t\t\t\t\r\n\t\t\t\twhile (true){\r\n\t\t\t\t\t\r\n\t\t\t\t\t//监听\r\n\t\t\t\t\tSocket socket = serverSocket.accept();\r\n\r\n\t\t\t\t\t//创建进程\r\n\t\t\t\t\tHandleAClient task = new HandleAClient(socket);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//开始运行\r\n\t\t\t\t\tnew Thread(task).start();\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch(IOException ex) {\r\n\t\t\t\tSystem.err.println(ex);\r\n\t\t\t}\r\n\t\t}).start();\r\n\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tlaunch(args);\r\n\t}\r\n\t\r\n\t//服务器端的任务类\r\n\tclass HandleAClient implements Runnable{\r\n\t\tprivate Socket socket;\r\n\t\t\r\n\t\tpublic HandleAClient(Socket socket1){\r\n\t\t\tthis.socket = socket1;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void run(){\r\n\t\t\ttry {\r\n\t\t\t\t//创建输入输出流\r\n\t\t\t\tDataInputStream input = new DataInputStream(socket.getInputStream());\r\n\t\t\t\tDataOutputStream output = new DataOutputStream(socket.getOutputStream());\r\n\t\t\t\t\r\n\t\t\t\twhile (true){\r\n\t\t\t\t\t//获取客户端数据\r\n\t\t\t\t\tdouble annualInterestRate = input.readDouble();\r\n\t\t\t\t\tint numberOfYears = input.readInt();\r\n\t\t\t\t\tdouble loanAmount = input.readDouble();\r\n\t\t\t\t\t\r\n\t\t\t\t\t//计算偿还额\r\n\t\t\t\t\tdouble totalPayment = loanAmount * Math.pow(1 + annualInterestRate * 0.01, numberOfYears);\r\n\t\t\t\t\tdouble monthlyPayment = totalPayment / numberOfYears / 12;\r\n\t\t\t\t\t//将数据传送至客户端\r\n\t\t\t\t\toutput.writeDouble(monthlyPayment);\r\n\t\t\t\t\toutput.writeDouble(totalPayment);\r\n\t\t\t\t\t//输出\r\n\t\t\t\t\tPlatform.runLater(() -&gt;{\r\n\t\t\t\t\t\tarea.appendText(\"Annual Interest Rate:\" + annualInterestRate + '\\n');\r\n\t\t\t\t\t\tarea.appendText(\"Number Of Year:\" + numberOfYears + '\\n');\r\n\t\t\t\t\t\tarea.appendText(\"Loan Amount:\" + loanAmount + '\\n');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tarea.appendText(\"Monthly Payment:\" + monthlyPayment + '\\n');\r\n\t\t\t\t\t\tarea.appendText(\"Total Payment:\" + totalPayment + '\\n');\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (IOException ex) {\r\n\t\t\t\tex.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```", "Konwledge_Point": "网络中的流", "Question": ["初学Java网络编程socket，为何我的服务器打不开？", ["初学Java网络编程socket，写了个服务器，但是打不开，求指导。代码如下", "\n\n", " import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javafx.application.Application;\nimport javafx.application.Platform;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ScrollPane;\nimport javafx.scene.control.TextArea;\nimport javafx.stage.Stage;\n\npublic class Test2_2Server extends Application{\n    //创建显示文本域\n    private TextArea area = new TextArea();\n\n    public void start(Stage primaryStage){\n        area.setEditable(false);\n\n        Scene scene = new Scene(new ScrollPane(area), 450,300);\n        primaryStage.setTitle(\"Test2_2Server\");\n        primaryStage.setScene(scene);\n        primaryStage.show();\n\n        try {\n            //创建一个服务器套接字\n            ServerSocket serverSocket = new ServerSocket(8800);\n            Platform.runLater(() ->\n                area.appendText(\"Server started at \" + new Date() + '\\n'));\n\n            int clientNo = 1;\n            while (true){\n                //监听\n                Socket socket = serverSocket.accept();\n\n                area.appendText(\"Starting thread for client \" + clientNo + \" at \" + new Date() + '\\n');\n\n                //获取客户端地址\n                InetAddress inetAddress = socket.getInetAddress();\n                area.appendText(\"Client \" + clientNo + \"'s host name is \" + inetAddress.getHostName() + '\\n');\n                area.appendText(\"Client \" + clientNo + \"'s IP Address is \" + inetAddress.getHostAddress() + '\\n');\n\n                //创建进程\n                HandleAClient task = new HandleAClient(socket);\n\n                //开始运行\n                new Thread(task).start();\n\n                //客户端数加一\n                clientNo++;\n            }\n        }\n        catch(IOException ex) {\n            System.err.println(ex);\n        }\n\n\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    //服务器端的任务类\n    class HandleAClient implements Runnable{\n        private Socket socket;\n\n        public HandleAClient(Socket socket1){\n            this.socket = socket1;\n        }\n\n        public void run(){\n            try {\n                //创建输入输出流\n                DataInputStream inputFromClient = new DataInputStream(socket.getInputStream());\n                DataOutputStream outputToClient = new DataOutputStream(socket.getOutputStream());\n\n                while (true){\n                    //获取客户端数据\n                    double annualInterestRate = inputFromClient.readDouble();\n                    int numberOfYears = inputFromClient.readInt();\n                    double loanAmount = inputFromClient.readDouble();\n\n                    //计算偿还额\n                    double totalPayment = loanAmount * Math.pow(1 + annualInterestRate * 0.01, numberOfYears);\n                    double monthlyPayment = totalPayment / numberOfYears / 12;\n                    //将数据传送至客户端\n                    outputToClient.writeDouble(monthlyPayment);\n                    outputToClient.writeDouble(totalPayment);\n                    //输出\n                    Platform.runLater(() ->{\n                        area.appendText(\"Annual Interest Rate:\" + annualInterestRate + '\\n');\n                        area.appendText(\"Number Of Year:\" + numberOfYears + '\\n');\n                        area.appendText(\"Loan Amount:\" + loanAmount + '\\n');\n\n                        area.appendText(\"Monthly Payment:\" + monthlyPayment + '\\n');\n                        area.appendText(\"Total Payment:\" + totalPayment + '\\n');\n                    });\n                }\n            }\n            catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n} \n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ovs-ofctl add-flow br0 arp,arp_tpa&amp;#61;10.159.11.21,actions&amp;#61;output:vnet0&lt;br /&gt;ovs-ofctl add-flow br0 ip,nw_dst&amp;#61;10.159.11.21,actions&amp;#61;output:vnet0&lt;br /&gt;ovs-ofctl add-flow br0 arp,arp_tpa&amp;#61;10.159.11.22,actions&amp;#61;output:vnet1&lt;br /&gt;ovs-ofctl add-flow br0 ip,nw_dst&amp;#61;10.159.11.22,actions&amp;#61;output:vnet1&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["相同网段下如何设置OVS流表使两个虚拟机互通？", ["两个虚拟机分别连接到同一OVS网桥的vnet0和vnet1端口，两个虚拟机的IP分别为10.159.11.21和10.159.11.22。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个问题的原因是访问的时候浏览器自动进行了url编码。只需要在获取参数的地方进行解码就可以了。&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/516791391566188.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["Java简易服务器中文乱码", ["Java简易服务器中文乱码", "\n", "\n", "\n", "import java.io.*;", "\n", "import java.net.ServerSocket;", "\n", "import java.net.Socket;", "\n", "public class DemoTCPServer {", "    public static void main(String[] args) throws IOException {", "        ServerSocket ss = new ServerSocket(6667);//构造服务器", "        while (true) {", "\n", "        Socket iouse01 = ss.accept", "()", ";", "//服务器保持监听状态", "\n        ", "new", " ", "Thread(", "new", " Runnable()", " {", "//每加载一次图片创建一个线程", "\n            @Override\n            public void run", "()", " {\n                ", "try", " {\n                    InputStream ips = iouse01.get", "InputStream()", ";", "//接收客户端请求的字节流", "\n                    InputStreamReader ipsr = ", "new", " ", "InputStreamReader(", "ips", ")", ";\n                    BufferedReader bis = ", "new", " ", "BufferedReader(", "ipsr", ")", ";", "//将接收的字节流转换为字符流并缓冲", "\n\n                    ", "//获取客户端请求路径", "\n                    String s = bis.read", "Line()", ";\n                    ", "System", ".", "out.println(s);\n                    String", "[]", " arr = s.split(", "\" \"", ");\n                    String htmlpath = arr", "[", "1", "]", ".substring(", "1", ");\n\n                    FileInputStream fis = ", "new", " ", "FileInputStream(", "htmlpath", ")", ";", "//本地字节流读取硬盘字节数据", "\n                    OutputStream ops = iouse01.get", "OutputStream()", ";", "//获取网络输出流对象", "\n                    ", "//HTTP固定请求头代码", "\n                    ops.write(", "\"HTTP/1.1 200 OK\\r\\n\"", ".get", "Bytes()", ");\n                    ", "// 解决方法：正确告诉浏览器发送的内容是什么编码的", "\n                    ops.write(", "\"Content-Type:text/html\\r\\n\"", ".get", "Bytes()", ");\n                    ops.write(", "\"\\r\\n\"", ".get", "Bytes()", ");\n\n                    ", "//读取本地目的文件并输出", "\n                    byte", "[]", " ", "bytes", " = ", "new", " byte", "[", "1024", "]", ";\n                    ", "int", " len;\n                    ", "while", " ((len = fis.read(", "bytes", ")) != -", "1", ") {\n                        ops.write(", "bytes", ", ", "0", ", len);\n                    }\n\n                    fis.close", "()", ";\n                    iouse01.close", "()", ";\n\n                } catch (IOException e) {\n                    e.print", "StackTrace()", ";\n                }\n\n            }\n        }).start", "()", ";\n\n    }\n\n\n}\n", "\n", "} ", "\n", "\n", "使用原始ie浏览器访问我的服务器，遇到中文就返回乱码", "\n", "我尝试过把浏览器返回的字节码打印出来，中文字节码转为字符打印的是乱码，英文字母正常，", "\n", "字节流转换字符流之后还是和原来的一样中文乱码", "\n", "望大能给个解决思路，感谢！！"]], "Tag": "算法设计"}
{"Answer": "你的目录用错了，不能直接\"/storage/emulated/0/\"这样写，用\r\nEnvironment.getExternalStorageDirectory()来获取Sdcard根目录\r\n另外，需要加上写Sdcard的权限 ，你只是加了read_extranal_stroage，需要加上write_extranal_stroage", "Konwledge_Point": "网络中的流", "Question": ["android从网络上下载图片，写入手机时错误？求解", [" String s = params[0];\n", "\n\n", "//            Toast.makeText(activity,s,Toast.LENGTH_SHORT).show();", "\n            try {", "\n                URL url = new URL(s);", "\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //打开连接", "\n                int size = conn.getContentLength();//获取文件大小", "\n                //0标记表示需要更新最大进度值，1表示更新当前下载的进度取", "\n                publishProgress(0,size);", "\n                byte[] bytes = new byte[20];", "\n                int len = -1;", "\n                InputStream inputStream = conn.getInputStream(); //读取数据流", "\n                FileOutputStream fileOutputStream = new FileOutputStream(\"/storage/emulated/0/\"+ System.currentTimeMillis()+\".jpg\");", "\n                while ((len=inputStream.read(bytes)) != -1){", "\n                    fileOutputStream.write(bytes,0,len);", "\n                    publishProgress(1,len); //更新进度", "\n                    fileOutputStream.flush();", "\n                   // Thread.sleep(500);", "\n                }", "\n               fileOutputStream.close();", "\n                inputStream.close();", "\n            } catch (MalformedURLException e) {", "\n                e.printStackTrace();", "\n            } catch (IOException e) {", "\n                e.printStackTrace();", "\n            }", "\n\n", "                    提示以下错误：java.io.FileNotFoundException: /storage/emulated/0/1483081566430.jpg: open failed: EACCES (Permission denied)\n                    本人使用小米5s真机, <uses-permission android:name=\"android.permission.INTERNET\"></uses-permission>\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"></uses-permission>权限都添加了。求解\n"]], "Tag": "算法设计"}
{"Answer": "如果是海康、大华的摄像头可以对接他们的第三方接口实现控制摄像头功能，包括方向控制，视频录制、录制回放等等等等功能。搞清楚摄像头版本，对对应厂商官网下载他们的SDK和文档，pc端和移动端都有，前段时间刚对接过海事康威的摄像头。", "Konwledge_Point": "网络中的流", "Question": ["录制摄像头画面的方法", ["想要录制网络摄像头的画面，比如海康，大华的rtsp流", "\n\n", "推荐用的平台（Linux/Windows），流媒体库(VLC/FFMPEG/LIVE55)，", "\n需要的知识,  开发环境"]], "Tag": "算法设计"}
{"Answer": "已经有答案了，可以查看环回检测的相关原理", "Konwledge_Point": "网络中的流", "Question": ["交换机环回检测功能是如何对vlan进行检测的（关于网络、交换机、数据通信的）", ["\n\n", "交换机配置如下：", "\n\n", "一、  Port1, port 2, port 3 ,port 4 默认在vlan1 中，是hybrid untagged的，pvid是1", "\n\n", "二、  Port 1，port2以hybrid tagged 加入vlan 10", "\n\n", "三、  Port3,port4以hybrid  untagge加入vlan 10，并使能环回检测功能，检测vlan为vlan 1 和vlan 10", "\n\n", "现想咨询如下问题", "\n\n", "仪表端口A发送带vlan10未知单播流（假如发送1000个数据包），在端口A、B抓包", "\n\n", "一、仪表端口A收到1000个数据包，不带vlan标签", "\n\n", "仪表端口B收到2000个数据包，", "\n\n", "其中1000个为vlan 10，其中1000个不带vlan", "\n\n", "二、如果将port 3，port 4 改为以hybrid tagged 加入vlan 10 ", "\n\n", "则仪表端口A不会收到自己发出去的1000个数据;", "\n\n", "仪表端口B会收到1000个数据包，带vlan 10", "\n\n", "三、如果将port 3，port 4的pvid改为10，", "\n\n", "则仪表端口A不会收到自己发出去的1000个数据;", "\n\n", "仪表端口B会收到1000个数据包，带vlan 10", "\n\n", "以上这些问题应该和环回检测有关，我想知道端口3和端口4是如何进行vlan检测的；", "\n数据包在经过端口3和端口4是如何传输的"]], "Tag": "算法设计"}
{"Answer": "在用HttpURLConnection的时候，没有设置默认编码，可能是utf-8和 \"ISO-8859-1\"混淆了。\r\n然后模拟器和手机不一样的原因是；Android版本不一样导致HttpURLConnection的具体实现不一样，记得Android4.4之后，HttpURLConnection底层采用HttpOK了。", "Konwledge_Point": "网络中的流", "Question": ["android客户端解析json，出现乱码 ( 没有中文 ) ，请大神指点", ["本人使用Tomcat apache-tomcat-8.0.28虚拟服务器，默认utf-8编码", "\n\n", "update.json", "\n\n", "{\"versionName\":\"2.0\",\"versionCode\":2,\"description\":\"Hello word!!\",\"downloadUrl\":\"", "http://www.baidu.com\"", "}", "\n\n", "android studio 1.3.1 做了个客户端：部分编码如下:", "\n\n", "private void checkVersion(){", "\n        new Thread(){", "\n            @Override", "\n            public void run() {", "\n\n", "            try {\n                URL url = new URL(\"http://10.0.2.2:8080/update.json\");\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.setConnectTimeout(5000);\n                conn.setReadTimeout(5000);\n                conn.connect();\n\n                int responseCode = conn.getResponseCode();\n\n                if(responseCode==200){\n                    InputStream inputStream = conn.getInputStream();\n                    String result = StreamUtils.readFromSteam(inputStream);\n                    Log.e(\"System.Out.Print\", \"result:\"+result);\n\n                    //解析Json\n\n                    JSONObject jo = new JSONObject(result);\n                    mVersionName = jo.getString(\"versionName\");\n                    mVersionCode = jo.getInt(\"versionCode\");\n                    mDescription = jo.getString(\"description\");\n                    mDownloadUrl = jo.getString(\"downloadUrl\");\n\n\n                    Log.e(\"System.Out.Print\", \"run \"+mVersionName+\";\"+mVersionCode);\n                    Log.e(\"System.Out.Print\", \"run \"+mDescription+\";\"+mDownloadUrl);\n                }\n\n            } catch (MalformedURLException e) {\n               // utl错误的异常\n\n                e.printStackTrace();\n            } catch (IOException e) {\n                //网络错误的异常\n\n                e.printStackTrace();\n            }\n            catch (JSONException e) {\n                e.printStackTrace();\n            }\n        }\n    }.start();\n}\n", "\n\n", "public class StreamUtils {", "\n\n", "/**\n * readFromSteam() 将输入流读成String后返回\n * @return\n */\npublic static String readFromSteam(InputStream in) throws IOException {\n\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    int len = 0;\n    byte[] buffer = new byte[1024];\n\n    while((len=in.read())!=-1){\n        out.write(buffer,0,len);\n    }\n        String result = out.toString();\n        in.close();\n        out.close();\n    return result;\n    }\n\n}\n\n\n    每次运行后的结果如下：\n\n    ![图片说明](https://img-ask.csdn.net/upload/201602/21/1456069188_115538.jpg)\n\n\n    请大神指点\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你可以用一个Task  或者backgroundWork来做&amp;#xff0c;直接在主线程while 会卡死主线程的&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["写了一个网络通讯的程序，按第三个按钮就会卡死，请大师解答一下，谢谢了，搞了好几天", ["    public partial class Form1 : Form", "\n    {", "\n        private TcpListener server;", "\n        private Thread receive_thread;", "\n\n", "        public Form1()", "\n        {", "\n            InitializeComponent();", "\n            RichTextBox.CheckForIllegalCrossThreadCalls = false;", "\n        }", "\n        private void receive()", "\n        {", "\n            server = new TcpListener(IPAddress.Parse(textBox1.Text), Int32.Parse(textBox2.Text));", "\n            server.Start(); //启动监听", "\n            label8.Text = \"正在监听......\";", "\n            while (true)", "\n            {", "\n                TcpClient theClient = server.AcceptTcpClient(); //接收挂起的连接请求", "\n                NetworkStream theStream = theClient.GetStream();//取得接收数据的网络流", "\n                Byte[] messageByte = new byte[1024];", "\n                theStream.Read(messageByte, 0, messageByte.Length);", "\n                string readMessage = System.Text.Encoding.BigEndianUnicode.GetString(messageByte);", "\n                richTextBox1.AppendText(readMessage);", "\n            }", "\n        }", "\n\n", "        private void button1_Click(object sender, EventArgs e)", "\n        {", "\n            //判断IP地址和端口是否合法", "\n            try", "\n            {", "\n                IPAddress.Parse(textBox1.Text);", "\n                Int32.Parse(textBox2.Text);", "\n            }", "\n            catch (Exception err)", "\n            {", "\n                MessageBox.Show(err.ToString());", "\n                return;", "\n            }", "\n            //如果监听线程已经在运行中，则返回", "\n            if (receive_thread != null && receive_thread.ThreadState == ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"正在监听中......\");", "\n                return;", "\n            }", "\n            try", "\n            {", "\n                receive_thread = new Thread(new ThreadStart(receive));", "\n                receive_thread.Start();", "\n            }", "\n            catch (Exception err)", "\n            {", "\n                MessageBox.Show(err.ToString());", "\n            }", "\n        }", "\n\n", "        private void Form1_Load(object sender, EventArgs e)", "\n        {", "\n            MessageBox.Show(\"请输入监听端IP地址，端口号请保持一致!\\n发送端为自身IP\");", "\n            string name = Dns.GetHostName();", "\n            IPAddress[] ipadrlist = Dns.GetHostAddresses(name);", "\n            textBox3.Text = ipadrlist[2].ToString();", "\n            textBox1.Text = ipadrlist[2].ToString();", "\n        }", "\n\n", "        private void Form1_FormClosing(object sender, FormClosingEventArgs e)", "\n        {", "\n            //如果监听线程扔在运行，则不能关闭", "\n            if (receive_thread != null && receive_thread.ThreadState == ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"请先停止监听再关闭本程序。\");", "\n                e.Cancel = true;", "\n            }", "\n        }", "\n\n", "        private void button2_Click(object sender, EventArgs e)", "\n        {", "\n            //判断IP地址和端口是否合法", "\n            try", "\n            {", "\n                IPAddress.Parse(textBox3.Text);", "\n                Int32.Parse(textBox4.Text);", "\n            }", "\n            catch (Exception err)", "\n            {", "\n                MessageBox.Show(err.ToString());", "\n                return;", "\n            }", "\n            //如果没有启动监听，则返回", "\n            if (receive_thread == null || receive_thread.ThreadState != ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"请先启动监听。\");", "\n                return;", "\n            }", "\n            //创建客户端并发送连接请求", "\n            TcpClient theClient = new TcpClient(textBox3.Text, Int32.Parse(textBox4.Text));", "\n            string send = richTextBox2.Text + \"\\r\\n\";", "\n            //转换编码格式", "\n            byte[] messageByte = System.Text.Encoding.BigEndianUnicode.GetBytes(send.ToCharArray());", "\n            NetworkStream theStream = theClient.GetStream();    //取得发送数据的网络流", "\n            theStream.Write(messageByte, 0, messageByte.Length);//写数据", "\n            theStream.Close();  //关闭流", "\n            theClient.Close();  //关闭客户端", "\n\n", "        }", "\n\n", "        private void button3_Click(object sender, EventArgs e)", "\n        {", "\n            //如果没有启动监听，则返回", "\n            if (receive_thread == null || receive_thread.ThreadState != ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"监听没有开始。\");", "\n                return;", "\n            }", "\n            if (receive_thread != null && receive_thread.ThreadState == ThreadState.Running)", "\n            {", "\n                try", "\n                {", "\n                    receive_thread.Abort();", "\n                }", "\n                catch(Exception err)", "\n                {", "\n                    MessageBox.Show(err.ToString());", "\n                }", "\n                ", "\n            }", "\n            if (server != null)", "\n            {", "\n                server.Stop();", "\n            }", "\n        }", "\n    }", "\n\n", " "]], "Tag": "算法设计"}
{"Answer": "public String appendSpace(String  para){\r\n\t\tint length = para.length();\r\n\t\tchar[] value = new char[length &lt;&lt; 1];\r\n\t\tfor (int i=0, j=0; i&lt;length; ++i, j = i &lt;&lt; 1) {\r\n\t\t\tvalue[j] = para.charAt(i);\r\n\t\t\tvalue[1 + j] = ' ';\r\n\t\t}\r\n\t\treturn new String(value);\r\n\t}\r\n\r\n这就是最简单，也是最高效的方法，这样的问题也要用低效的正则？", "Konwledge_Point": "网络中的流", "Question": ["在每个字符后面加空格", ["String str1 = \"里面将图片保存到本地，到网络上搜索了一下，方法都差不多，大同小异，把输入流转换成输出流的过程而已。\"; ", "\n想在字符串里面的每个字后面添加一个空格，我用正则如下：", "\n   String after1 = str1.replaceAll(\"\\S\" , \"\\S \"); ", "\n   System.out.println(after1); 发现字符串里面的字符全面变成了“S ”。", "\n   正则可以搞定这个问题吗？除了正则，看看还有什么方法？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1.服务端中while循环调不出来的原因是服务端在接收完所有数据后&amp;#xff0c;需要手动关闭输入流is&amp;#xff0c;关闭方法为is.close()&amp;#xff0c;不然服务端会一直等待客户端继续向它传输数据&amp;#xff0c;而不会跳出循环。&lt;br /&gt;2.在客户端&amp;#xff0c;出现阻塞状态的原因是服务端关闭&amp;#xff0c;而客户端在等待服务端发送数据&amp;#xff0c;如果一直没有关闭连接&amp;#xff0c;此时可以在服务端发送完数据后&amp;#xff0c;调用socket.shutdownOutput()方法&amp;#xff0c;表示输出流关闭&amp;#xff0c;通知客户端数据已全部发送完毕&amp;#xff0c;客户端此时可以正常退出程序。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["java刚学网络编程客户端和服务端出现的疑问", ["我的程序：客户端发送一张图片到服务端，服务端接收后发送一条信息给客户端，客户端收到信息后关闭程序，同样服务端也关闭了", "（1）出现的问题：1.在服务端一直调不出来while循环，为什么？", "2.在客户端因为服务端跳不出循环，导致一直在阻塞状态", "\n", "客户端程序", "\n", "package", " TCP_FileCopy;\n\n", "import", " java.io.*;\n", "import", " java.net.InetAddress;\n", "import", " java.net.Socket;\n", "public", " ", "class", " ", "TCP_Client", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " ", "throws", " IOException {\n        String pathSent=", "\"D:\\\\null_.jpg\"", ";\n        ", "//1.建立端口连接", "\n        Socket socket=", "new", " ", "Socket", "(InetAddress.getLocalHost(),", "8888", ");\n        ", "//定义发送的流,一个是输入流，用于读取文件FileInputStream fis=new FileInputStream(\"D:\\\\null_.jpg\");", "\n        ", "// 一个是输出流，用于发送文件 OutputStream ops= socket.getOutputStream();", "\n        OutputStream ops= socket.getOutputStream();\n        FileInputStream fis=", "new", " ", "FileInputStream", "(", "\"D:\\\\null_.jpg\"", ");\n\n\n        ", "BufferedInputStream", " ", "bis", " ", "=", " ", "new", " ", "BufferedInputStream", "(fis);\n        ", "BufferedOutputStream", " ", "bos", " ", "=", " ", "new", " ", "BufferedOutputStream", "(ops);\n        ", "byte", "[] bytes=", "new", " ", "byte", "[", "1024", "];\n        ", "int", " readline;\n        ", "while", "((readline= bis.read(bytes))!=-", "1", "){\n            bos.write(bytes,", "0", ",readline);\n        }\n        bos.flush();\n        System.out.println(", "\"Client发送图片成功！\"", ");\n        ", "//定义一个流用于接收对方发来的字符流图片", "\n        ", "BufferedReader", " ", "bufferedReader", " ", "=", " ", "new", " ", "BufferedReader", "(", "new", " ", "InputStreamReader", "(socket.getInputStream()));\n        String s= bufferedReader.readLine();\n        System.out.println(s);\n\n        ", "//读完之后关闭所有的流文件", "\n        System.out.println(", "\"任务完成\"", ");\n        bufferedReader.close();\n        fis.close();\n        ops.close();\n        socket.close();\n    }\n}\n\n\n", "\n", "服务端程序", "\n", "package", " TCP_FileCopy;\n\n", "import", " com.sun.corba.se.spi.orbutil.fsm.Input;\n\n", "import", " java.io.*;\n", "import", " java.net.ServerSocket;\n", "import", " java.net.Socket;\n\n", "public", " ", "class", " ", "TCP_Server", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " ", "throws", " IOException {\n        ", "//输出到目标文件的敌方", "\n        String s=", "\"src\\\\null2.jpg\"", ";\n        ", "//先建立一个端口", "\n        ServerSocket sockets=", "new", " ", "ServerSocket", "(", "8888", ");\n\n        ", "//建立一个连接", "\n        System.out.println(", "\"已建立端口，等待连接\"", ");\n        Socket socket=sockets.accept();\n\n        ", "//建立字节输入流，用于接收文件。输出流，用于创建文件", "\n        InputStream is= socket.getInputStream();\n        ", "BufferedInputStream", " ", "bis", " ", "=", " ", "new", " ", "BufferedInputStream", "(is);\n        OutputStream os=", "new", " ", "FileOutputStream", "(s);\n        ", "BufferedOutputStream", " ", "bos", " ", "=", " ", "new", " ", "BufferedOutputStream", "(os);\n        ", "byte", "[] bytes=", "new", " ", "byte", "[", "1024", "];\n        ", "int", " readline;\n        System.out.println(", "\"已接受文件，正在拷贝\"", ");\n        ", "while", "((readline=bis.read(bytes))!=-", "1", "){\n            bos.write(bytes,", "0", ",readline);\n        }\n        System.out.println(", "\"拷贝成功\"", ");\n\n        ", "//建立输入流，用于接收服务端发送的文字", "\n        ", "BufferedWriter", " ", "bufferedWriter", " ", "=", " ", "new", " ", "BufferedWriter", "(", "new", " ", "OutputStreamWriter", "(socket.getOutputStream()));\n        bufferedWriter.write(", "\"Server收到图片\"", ");\n        bufferedWriter.newLine();\n", "//        bufferedWriter.flush();", "\n", "//        socket.shutdownOutput();", "\n        bufferedWriter.close();\n        ", "//关闭所有的流", "\n        os.close();\n        is.close();\n        ", "//bufferedWriter.close();", "\n        ", "//socket.close();", "\n        sockets.close();\n    }\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "发现问题了，是Android 9.0 ban了 http只能用https了，解决方案见大佬的文章[Android9.0 http网络请求失败问题分析与解决方案](https://blog.csdn.net/freak_csh/article/details/86100031 \"\")", "Konwledge_Point": "网络中的流", "Question": ["Android Studio 应用无法访问本地服务器", ["代码在android studio 模拟器运行后本地服务器监听不到访问，可以确定后端代码没有问题，并且模拟器网络正常，可以使用模拟器里的浏览器访问服务器。", "\n应用也添加了网络访问权限。", "\n\n", " <uses-permission android:name=\"android.permission.INTERNET\" />\n", "\n\n", "代码：", "\n\n", "public class MainActivity extends AppCompatActivity {\n\n    private TextView tvContent;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        tvContent = (TextView) findViewById(R.id.test1); // 这里页面上就一个简单的TextView，用于展示获取到报文内容\n        requestUsingHttpURLConnection();\n    }\n\n    private Handler handler = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            if(msg.what == 1){\n                tvContent.setText(msg.obj.toString());\n            }\n        }\n    };\n\n\n    private void requestUsingHttpURLConnection() {\n        // 网络通信属于典型的耗时操作，开启新线程进行网络请求\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                HttpURLConnection connection = null;\n                try {\n                    URL url = new URL(\"http://10.0.2.2:8080/ServletTest/RegisterServlet?account=123&password=abc\"); // 声明一个URL,注意——如果用百度首页实验，请使用https  //http://10.20.4.178:8080/ServletTest/RegisterServlet?account=123&password=abc\n                    Log.d(\"test\",  \"开始连接\");\n                    connection = (HttpURLConnection) url.openConnection(); // 打开该URL连接\n                    connection.setRequestMethod(\"GET\"); // 设置请求方法，“POST或GET”，我们这里用GET，在说到POST的时候再用POST\n\n                    connection.setConnectTimeout(8000); // 设置连接建立的超时时间\n                    connection.setReadTimeout(8000); // 设置网络报文收发超时时间\n\n                    InputStream in = connection.getInputStream();  // 通过连接的输入流获取下发报文，然后就是Java的流处理\n                    Log.d(\"test\",  \"获取连接\");\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n\n                    Message msg = new Message();\n                    msg.what = 1;\n                    msg.obj = response.toString();\n                    Log.d(\"test\",  response.toString());\n                    handler.sendMessage(msg);\n\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n}\n", "\n\n", "URL应该没有问题，我通过日志输出的URL可以在模拟器浏览器成功访问服务器", "\n\n", "public class Consatant {\n    public static String URL = \"http://10.0.2.2:8080/ServletTest/\"; // IP地址请改为你自己的IP\n\n    public static String URL_Register = URL + \"RegisterServlet\";\n    public static String URL_Login = URL + \"LoginServlet\";\n\n}\n"]], "Tag": "算法设计"}
{"Answer": "TCP 因为是长连接的，肯定是有序的。数据接收不完整，这种现象在通讯中很常见的，是必须代码处理。", "Konwledge_Point": "网络中的流", "Question": ["Java Socket 读取TCP服务端数据包不完整", ["Java Socket 读取TCP服务端数据包不完整：除了利用数据包大小循环读取输入流的得到完整的数据外，还有其他什么方法？", "\n\n", "数据包在网络传输的过程中，数据传递到客户端基本处于“无序”态。除了开辟一块内存按数据包的顺序存放外，还有其他更好的方案么？"]], "Tag": "算法设计"}
{"Answer": "linux系统有文件系统缓冲，也就是实际上会写入内存，然后才写入硬盘。固态硬盘按照块去写入，一般一个块有4kb甚至更大。如果你更新这个地址范围内哪怕一个字节，都需要把整个块全部写一次。这不但降低了性能，而且极大造成了固态硬盘不必要的磨损，导致硬盘寿命大大减少。\r\n操作系统的缓存机制使得你对相邻的地址改写后，其实都在内存操作，再一次性写入硬盘，这是一种必要的优化。如果你的linux系统可以配置，你可以想办法关掉缓存，立刻写入数据，但是强烈不推荐你这么做。", "Konwledge_Point": "网络中的流", "Question": ["linux系统下，做的视频记录仪，写入固态硬盘的数据量比实际的小很多的问题", ["楼主是个linux新菜鸟，目前在做一个linux系统下的视频记录仪，记录H264的视频，简单说就是从网络读取视频流写入固态硬盘，固态硬盘挂载到linux系统的/MNT下，现在有个问题就是屏幕打印实际读取的数据量例如为12345678字节，如果正常接收关闭信号，关闭文件退出系统则固态硬盘里的数据量与实际相差无几，但一旦是直接关电那么固态硬盘内数据就少很多，最多少过50几秒的视频数据，平均码流是1.5mBPS", "\n\n", "程序简单历程就是", "\nrecv从网络读取  buf【2048】", "\nfwrite讲buf写入已挂载的硬盘里打开的文件", "\n\n", "有关机信号", "\n关闭文件，umount，退出系统"]], "Tag": "算法设计"}
{"Answer": "Set&lt;Map.Entry&lt;String, String&gt;&gt; p= param.entrySet(); //这么些OK了 for(Map.Entry s: p ){\r\n已经解决~", "Konwledge_Point": "网络中的流", "Question": ["java的类型转换报错，显示类型不匹配", ["\n\n\n\n\n\n package com.example.weather;\n\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.jar.Attributes;\n/**\n * 网络访问工具类\n * @author silk\n *\n */\npublic class PostGet {\n    /**\n     * get方法直接调用post方法\n     * @param url 网络地址\n     * @return 返回网络数据\n     */\n    public static String get(String url){\n        return post(url,null);\n    }\n    /**\n     * 设定post方法获取网络资源,如果参数为null,实际上设定为get方法\n     * @param url 网络地址\n     * @param param 请求参数键值对\n     * @return 返回读取数据\n     */\n   public static  String post(String  url,Map param){\n        HttpURLConnection conn=null;\n        try {\n            URL u=new URL(url);\n            conn=(HttpURLConnection) u.openConnection();\n            //返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。\n            StringBuffer sb = null;\n            if(param!=null){//如果请求参数不为空\n                sb=new StringBuffer();\n                /*A URL connection can be used for input and/or output.  Set the DoOutput\n                 * flag to true if you intend to use the URL connection for output,\n                 * false if not.  The default is false.*/\n                //默认为false,post方法需要写入参数,设定true\n                conn.setDoOutput(true);\n                //URL 连接可用于输入和/或输出。如果打算使用 URL 连接进行输出，\n                //则将 DoOutput 标志设置为 true；如果不打算使用，则设置为 false。默认值为 false。\n                //设定post方法,默认get\n                conn.setRequestMethod(\"POST\");\n                //获得输出流\n                OutputStream out=conn.getOutputStream();\n                //对输出流封装成高级输出流\n                BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));\n                //将参数封装成键值对的形式\n\n\n\n                for(Map.Entry s:param.entrySet()){\n\n\n\n                    sb.append(s.getKey()).append(\"=\").append(s.getValue()).append(\"&\");\n                }\n                //将参数通过输出流写入\n                writer.write(sb.deleteCharAt(sb.toString().length()-1).toString());\n                writer.close();//一定要关闭,不然可能出现参数不全的错误\n                sb=null;\n            }\n            conn.connect();//建立连接\n            sb=new StringBuffer();\n            //获取连接状态码\n            int recode=conn.getResponseCode();\n            BufferedReader reader=null;\n            if(recode==200){\n                //Returns an input stream that reads from this open connection\n                //从连接中获取输入流\n                InputStream in=conn.getInputStream();\n                //对输入流进行封装\n                reader=new BufferedReader(new InputStreamReader(in));\n                String str=null;\n                sb=new StringBuffer();\n                //从输入流中读取数据\n                while((str=reader.readLine())!=null){\n                    sb.append(str).append(System.getProperty(\"line.separator\"));\n                }\n                //关闭输入流\n                reader.close();\n                if (sb.toString().length() == 0) {\n                    return null;\n                }\n                return sb.toString().substring(0,\n                        sb.toString().length() - System.getProperty(\"line.separator\").length());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }finally{\n            if(conn!=null)//关闭连接\n                conn.disconnect();\n        }\n        return null;\n    }\n\n}\n", "\n\n", "隔空的for循环行报错：类型不匹配：不能从元素类型 Object 转换为 Map.Entry", "\n不知如何解决 以及为何会报错。望解惑 万分感谢！"]], "Tag": "算法设计"}
{"Answer": "java.io.FileNotFoundException: http://www.xxx.com/xxx/downloadFile/1二维码.png\r\n不都给你报错了吗？", "Konwledge_Point": "网络中的流", "Question": ["当输出0000000000000后停止运行要如何处理？", ["如下代码：", "\n\n", "String url = \"", "http://www.xxx.com/xxx/downloadFile/", "\" + filename + \".\" + format;", "\nloadQianURL(\"Desktop\",url);", "\n\n", "/**", "\n     * 文件或文件夹不存在则创建", "\n     * @param dir 文件夹", "\n     * @param filepath 文件名", "\n     */", "\n    public static void createDirFile(String dir){", "\n       File file = new File(dir);", "\n       if(!file.exists()){", "\n          file.mkdirs();", "\n       }", "\n    }", "\n\n", "/**\n * @param dir 子目录\n * @param fileUrl 图片链接\n * @return\n */\npublic static String loadQianURL(String dir,String fileUrl) {\n   //获取文件名，文件名实际上在URL中可以找到\n   String fileName = fileUrl.substring(fileUrl.lastIndexOf(\"/\")+1,fileUrl.length());\n   //这里服务器上要将此图保存的路径\n   String savePath = \"D:/upload/\";\n   if (!StringUtils.isEmpty(dir)){\n      savePath = savePath +dir+\"/\";\n   }\n   createDirFile(savePath);\n   try {\n      /*将网络资源地址传给,即赋值给url*/\n      URL url = new URL(fileUrl);\n      /*此为联系获得网络资源的固定格式用法，以便后面的in变量获得url截取网络资源的输入流*/\n      HttpURLConnection connection = (HttpURLConnection)url.openConnection();\n      //服务器的安全设置不接受Java程序作为客户端访问，解决方案是设置客户端的User Agent\n      connection.setRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)\");\n      System.out.println(\"0000000000000000000000000000\");\n      DataInputStream in = new DataInputStream(connection.getInputStream());\n      System.out.println(\"111111111111111111111111111111\");\n      /*此处也可用BufferedInputStream与BufferedOutputStream*/\n      DataOutputStream out = new DataOutputStream(new FileOutputStream(savePath+fileName));\n      /*将参数savePath，即将截取的图片的存储在本地地址赋值给out输出流所指定的地址*/\n      byte[] buffer = new byte[4096];\n      int count = 0;\n      /*将输入流以字节的形式读取并写入buffer中*/\n      while ((count = in.read(buffer)) > 0) {\n         out.write(buffer, 0, count);\n      }\n      out.close();/*后面三行为关闭输入输出流以及网络资源的固定格式*/\n      in.close();\n      connection.disconnect();\n      //返回内容是保存后的完整的URL\n      /*网络资源截取并存储本地成功返回true*/\n      return savePath+fileName;\n   } catch (Exception e) {\n      System.out.println(e + fileUrl + savePath);\n      return null;\n   }\n}\n", "\n\n", "运行结果：2019-10-22 16:43:55.545 2f1aa58b I: ", "\n0000000000000000000000000000", "\njava.io.FileNotFoundException: ", "http://www.xxx.com/xxx/downloadFile/1二维码.png", "\n\n", "输出0000000000000后停止运行要如何处理？"]], "Tag": "算法设计"}
{"Answer": "对，内部做了对结果的读写操作。\r\n一般会抛出io异常，包括读写和连接", "Konwledge_Point": "网络中的流", "Question": ["Android中关于HttpClient的问题", ["小白想请教下各位大神，使用HttpUplConnnection时需要用到IO流对数据进行读取，然而使用HttpClient时却不需要用到。。例如：", "\ntry {", "\n                HttpClient httpClient = new DefaultHttpClient();//获取实例", "\n                HttpGet httpGet = new HttpGet(address[0]);//创建HttpGet对象，传入网络地址", "\n                HttpResponse httpResponse = httpClient.execute(httpGet);//IOException", "\n                if (httpResponse.getStatusLine().getStatusCode() == 200){", "\n                    HttpEntity httpEntity = httpResponse.getEntity();//获取HttpEntity实例", "\n                    result = EntityUtils.toString(httpEntity,\"utf-8\");//转换为字符串", "\n                    return result;", "\n                }", "\n            } catch (IOException e) {", "\n                e.printStackTrace();", "\n            }", "\n是不是里面哪里封装了对IO的操作，使我们不用像HttpUplConnnection那样对使用IO。。。。另外想问下，使用HttpClient的过程中，会抛出什么其它的异常？", "\n\n", "多谢各位解答下小白的疑问！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/78485545925619.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;看一下是不是你要的&amp;#xff0c;不懂的可以问。&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n#include &lt;span class=\"hljs-string\"&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;\n\nint main()\n\n{\n    int a, b, i, j, k, p, n, &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], &lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;please input n:\\n&amp;#34;&lt;/span&gt;);\n\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;please input C[%d][%d],B[%d][%d]:\\n&amp;#34;&lt;/span&gt;, n, n, n, n);\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d,%7d&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[i][j],\n                  &amp;amp;&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j]); //输入各点(i,j)之间的容量&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[i][j]和运费&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j]\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n        {\n            &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n            for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n            if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;) //注&amp;#xff1a;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;表示&lt;span class=\"hljs-symbol\"&gt;Vi&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;Vj&lt;/span&gt;之间无可行路\n\n            {\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n        for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n            for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n                {\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n                } //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;, n, n);\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n    {\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    } //由表&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;中的数值确定&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的最短路\n\n    a &amp;#61; &lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    b &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] * &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;, a, b);\n\n    &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; //将容量已满的路改为不可行路\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n        {\n            &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n            for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n            if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n\n            {\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n        for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\n            for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\nif(&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k]&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n} //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;,n,n);\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\n{\n                    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n} //由表&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;中的数值确定&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的新最短路\n\na&amp;#61;a&amp;#43;&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];b&amp;#61;b&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,a,b);\n\n&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; //将容量已满的路改为不可行路\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n                    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n                    if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n\n                    {\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                    }\n\n}\n\nfor(k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;)\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\nif(&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k]&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n} //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;,n,n);\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\n{\n                    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n} //由表&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;中的数值确定&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的新最短路\n\na&amp;#61;a&amp;#43;&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]-&lt;span class=\"hljs-symbol\"&gt;C&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];b&amp;#61;b&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,a,b);\n\n&lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; //将容量已满的路改为不可行路\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;B&lt;/span&gt;[i][j];\n\n                    for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt;&amp;#61; n; k&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n                    if (&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n\n                    {\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                    }\n\n}\n\nfor(k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;)\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\nfor(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n\nif(&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k]&amp;#43;&lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j])\n\n{\n                    &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][k] &amp;#43; &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[k][j];\n\n                    for (p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p &amp;lt;&amp;#61; n; p&amp;#43;&amp;#43;)\n\n                        &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][j][p] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[i][k][p] || &lt;span class=\"hljs-symbol\"&gt;P&lt;/span&gt;[k][j][p];\n\n} //调用&lt;span class=\"hljs-symbol\"&gt;FLOYD&lt;/span&gt;算法\n\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;D[%d][%d]:\\n&amp;#34;&lt;/span&gt;,n,n);\n\nfor(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\n{\n                    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\n                        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%7d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;D&lt;/span&gt;[i][j]);\n\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n} //检验有无&lt;span class=\"hljs-symbol\"&gt;V0&lt;/span&gt;到&lt;span class=\"hljs-symbol\"&gt;V5&lt;/span&gt;的新最短路\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["网络流算法，最小费用最大流问题", ["设有一个给定的网络N(V,x,y,A,C,w)，其中c表示弧容量，w表示弧上的单位费用，另外给定一个常数a>o，请设计一个算法，用于求该网络中一个费用不超过a的最大流·要求给出算法的具体流程，并说明算法的合理性，进一步给出数值模拟的结果", "急！ "]], "Tag": "算法设计"}
{"Answer": "摄像头品牌也没法直接获取，需要有一些自己的判断规则", "Konwledge_Point": "网络中的流", "Question": ["关于网络摄像机主码流和子码流的rtsp地址格式！", ["我想在客户端播放网络摄像机监控视频的时候手动选择主码流和字码流，", "\n可是通过查资料得知不同网络摄像机品牌的RTSP地址格式不同.", "\n例如，请求海康摄像机通道1的主码流，Url如下", "\n主码流：", "\nrtsp://admin:12345@192.0.0.64:554/h264/ch1/main/av_stream", "\n\n", "子码流：", "\nrtsp://admin:12345@192.0.0.64/mpeg4/ch1/sub/av_stream", "\n\n", "大华的则为：", "\n例如，请求某设备的通道2的辅码流，Url如下", "\nrtsp://admin:admin@10.12.4.84:554/cam/realmonitor?channel=2&subtype=1", "\n\n", "那有没有一种兼容式的格式呢，不用考虑不同厂家都可以用一种格式来表示字码流和主码流呢？"]], "Tag": "算法设计"}
{"Answer": "先计算一下接收到的数据长度，测试一下与你的图片是否相等？\r\n\r\n```\r\n        byte[] buffer = new byte[1024 * 2];\r\n        // 读取到数据的长度\r\n        int len;\r\n        while ((len = inStream.read(buffer)) != -1) {\r\n            outStream.write(buffer, 0, len);\r\n        }\r\n```\r\n如果相等，再分析一下接收到手文件中的数据与原始的图片有多大差别。", "Konwledge_Point": "网络中的流", "Question": ["Java保存网络图片到本地图片损毁", [" package imageView;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * 从网络获取图片到本地\n */\npublic class GetImage {\n\n    /**\n     * 测试\n     * \n     * @param args\n     */\n    public static void main(String[] args) {\n        String url = \"http://www.iteye.com/upload/logo/user/1134656/d44c2b36-9869-360a-9c87-e88eaf8db3a5.jpg\";\n        byte[] btImg = getImageFromNetByUrl(url);\n        if (null != btImg && btImg.length > 0) {\n            System.out.println(\"读取到：\" + btImg.length + \"字节\");\n            String fileName = \"abc.jpg\";\n            writeImageToDisk(btImg, fileName);\n        } else {\n            System.out.println(\"没有从该连接获得内容\");\n        }\n    }\n\n    /**\n     * 从输入流中获取数据\n     * \n     * @param inStream\n     *            输入流\n     * @return ByteArray\n     * @throws Exception\n     */\n    public static byte[] readInputStream(InputStream inStream) throws Exception {\n        ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n        // 设置数据缓冲区\n        byte[] buffer = new byte[1024 * 2];\n        // 读取到数据的长度\n        int len;\n        while ((len = inStream.read(buffer)) != -1) {\n            outStream.write(buffer, 0, len);\n        }\n        outStream.close();\n        inStream.close();\n        return outStream.toByteArray();\n\n    }\n\n    /**\n     * 根据地址获得数据的字节流\n     * \n     * @param strUrl\n     *            网络连接地址\n     * @return\n     */\n    public static byte[] getImageFromNetByUrl(String strUrl) {\n        try {\n            URL url = new URL(strUrl);\n            // 处理以http开头的地址\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(10 * 1000);// 设置链接超时时间为10s\n            InputStream inStream = conn.getInputStream();// 通过输入流获取图片数据\n            byte[] btImg = readInputStream(inStream);// 得到图片的二进制数据\n            inStream.close();\n            return btImg;\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * 将图片写入到磁盘\n     * \n     * @param img\n     *            图片数据流\n     * @param fileName\n     *            文件保存时的名称\n     */\n    public static void writeImageToDisk(byte[] img, String fileName) {\n        try {\n            File file = new File(\"E:\\\\\" + fileName);\n            FileOutputStream fops = new FileOutputStream(file);\n            fops.write(img);\n            fops.flush();\n            fops.close();\n        } catch (Exception e) {\n            // TODO: handle exception\n            e.printStackTrace();\n        }\n    }\n\n}\n"]], "Tag": "算法设计"}
{"Answer": "[http://blog.csdn.net/lixiang99410/article/details/6173995?locationNum=2](http://blog.csdn.net/lixiang99410/article/details/6173995?locationNum=2 \"\")", "Konwledge_Point": "网络中的流", "Question": ["最大流问题 Ford-Fulkerson算法解决", ["G为连通有向图，f是u-->v路径上已有的流量，Gf为残留网络", "\n伪代码如下：", "\n1 for each edge(u,v)属于E（G）", "\n\n", "2     do f[u,v]=0", "\n\n", "3          f[v,u]=0", "\n\n", "4 while there exists a path p from s to t in the residual network Gf", "\n\n", "5       do cf(p)=min{cf(u,v):(u,v)is in p}", "\n\n", "6        for each edge (u,v) in p", "\n\n", "7              do f[u,v]=f[u,v]+cf(p)", "\n\n", "8                    f[v,u]=-f[u,v]", "\n\n", "比较疑惑第8行是什么作用？在代码中我尝试去掉这句话，结果显示也不错啊？"]], "Tag": "算法设计"}
{"Answer": "1、URL url = new URL(path);  确保path正确 可以在此输出 然后到浏览器试试\r\n2、java.net.ConnectException: Connection timed out \r\n\r\nHttpURLConnection urlCon = (HttpURLConnection)url.openConnection();\r\nurlCon.setConnectTimeout(30000);\r\nurlCon.setReadTimeout(30000);\r\n\r\nsetConnectTimeout：设置连接主机超时（单位：毫秒）\r\nsetReadTimeout：设置从主机读取数据超时（单位：毫秒）\r\n\r\n超市设置的大点", "Konwledge_Point": "网络中的流", "Question": ["java下载网络文件时连接超时", ["错误信息：", "\njava.net.ConnectException: Connection timed out", "\n    java.net.PlainSocketImpl.socketConnect(Native Method)", "\n    java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:351)", "\n    java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:213)", "\n    java.net.PlainSocketImpl.connect(PlainSocketImpl.java:200)", "\n    java.net.SocksSocketImpl.connect(SocksSocketImpl.java:366)", "\n    java.net.Socket.connect(Socket.java:529)", "\n    java.net.Socket.connect(Socket.java:478)", "\n    sun.net.NetworkClient.doConnect(NetworkClient.java:163)", "\n    sun.net.", "www.http.HttpClient.openServer(HttpClient.java:394)", "\n    sun.net.", "www.http.HttpClient.openServer(HttpClient.java:529)", "\n    sun.net.", "www.http.HttpClient", ".(HttpClient.java:233)", "\n    sun.net.", "www.http.HttpClient.New(HttpClient.java:306)", "\n    sun.net.", "www.http.HttpClient.New(HttpClient.java:323)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.getNewHttpClient(HttpURLConnection.java:970)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:911)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:836)", "\n    sun.net.", "www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1172)", "\n    java.net.URL.openStream(URL.java:1010)", "\n    com.srt.ezg.eMeg.voiceMail.action.VoiceAction.voiceDownload(VoiceAction.java:189)", "\n    sun.reflect.GeneratedMethodAccessor3167.invoke(Unknown Source)", "\n    sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)", "\n    java.lang.reflect.Method.invoke(Method.java:597)", "\n    org.apache.struts.actions.DispatchAction.dispatchMethod(DispatchAction.java:280)", "\n    org.apache.struts.actions.DispatchAction.execute(DispatchAction.java:216)", "\n    org.apache.struts.actions.DispatchAction$$FastClassByCGLIB$$d3d27916.invoke()", "\n    net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    com.srt.ezg.eMeg.voiceMail.action.VoiceAction$$EnhancerByCGLIB$$e77a6b68.execute()", "\n    org.apache.struts.action.RequestProcessor.processActionPerform(RequestProcessor.java:484)", "\n    org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:274)", "\n    org.apache.struts.action.ActionServlet.process(ActionServlet.java:1482)", "\n    org.apache.struts.action.ActionServlet.doGet(ActionServlet.java:507)", "\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:617)", "\n    javax.servlet.http.HttpServlet.service(HttpServlet.java:717)", "\n    com.srt.vas.filter.OaFilter.doFilter(OaFilter.java:68)", "\n    com.srt.vas.filter.SetFilterEcod.doFilter(SetFilterEcod.java:25)", "\n    org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:198)", "\n    org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:359)", "\n    org.springframework.security.intercept.web.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:109)", "\n    org.springframework.security.intercept.web.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:83)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor.invoke(CustomFilterSecurityInterceptor.java:117)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor.doFilter(CustomFilterSecurityInterceptor.java:86)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor$$FastClassByCGLIB$$2c376577.invoke()", "\n    net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    com.srt.interceptor.MethodTimeAdvice.invoke(MethodTimeAdvice.java:34)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    com.srt.sdp.security.bean.CustomFilterSecurityInterceptor$$EnhancerByCGLIB$$635d6668.doFilter()", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.SessionFixationProtectionFilter.doFilterHttp(SessionFixationProtectionFilter.java:67)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.ExceptionTranslationFilter.doFilterHttp(ExceptionTranslationFilter.java:101)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.providers.anonymous.AnonymousProcessingFilter.doFilterHttp(AnonymousProcessingFilter.java:105)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.rememberme.RememberMeProcessingFilter.doFilterHttp(RememberMeProcessingFilter.java:116)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.wrapper.SecurityContextHolderAwareRequestFilter.doFilterHttp(SecurityContextHolderAwareRequestFilter.java:91)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.basicauth.BasicProcessingFilter.doFilterHttp(BasicProcessingFilter.java:173)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.AbstractProcessingFilter.doFilterHttp(AbstractProcessingFilter.java:271)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.AbstractProcessingFilter.doFilterHttp(AbstractProcessingFilter.java:271)", "\n    org.springframework.security.ui.AbstractProcessingFilter$$FastClassByCGLIB$$32042740.invoke()", "\n    net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:89)", "\n    org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    com.srt.sdp.security.bean.CustomAuthenticationProcessingFilter$$EnhancerByCGLIB$$3e18fe7e.doFilterHttp()", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.ui.logout.LogoutFilter.doFilterHttp(LogoutFilter.java:89)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.context.HttpSessionContextIntegrationFilter.doFilterHttp(HttpSessionContextIntegrationFilter.java:235)", "\n    org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)", "\n    org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)", "\n    org.springframework.security.util.FilterChainProxy.doFilter(FilterChainProxy.java:174)", "\n    org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:236)", "\n    org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)", "\n\n", "VoiceAction.java中的下载action:", "\n\n", "try {", "\n            request.setCharacterEncoding(\"UTF-8\");", "\n        } catch (UnsupportedEncodingException e) {", "\n        }", "\n        String path = request.getParameter(\"url\");// 语音文件下载地址", "\n        path = new String(path", "\n                .getBytes(\"ISO-8859-1\"), \"UTF-8\");", "\n//        path=\"", "http://127.0.0.1/Ezg_v4.0/a059516000101001.wav", "\";", "\n        int startIndex = path.lastIndexOf(\"/\");", "\n        int endIndex = path.length();", "\n        String fileName = path.substring(startIndex + 1, endIndex);", "\n        BufferedInputStream bis = null;", "\n        BufferedOutputStream bos = null;", "\n        OutputStream fos = null;", "\n        InputStream fis = null;", "\n        URL url = new URL(path);", "\n        try {", "\n            fis = url.openStream();//这行报错", "\n            bis = new BufferedInputStream(fis);", "\n            fos = response.getOutputStream();", "\n            bos = new BufferedOutputStream(fos);", "\n            response.setHeader(\"Content-disposition\", \"attachment;filename=\"", "\n                    + new String(fileName.getBytes(\"gb2312\"), \"ISO-8859-1\"));", "\n            int bytesRead = 0;", "\n            byte[] buffer = new byte[8192];", "\n            while ((bytesRead = bis.read(buffer, 0, 8192)) != -1) {", "\n                bos.write(buffer, 0, bytesRead);", "\n            }", "\n            bos.flush();", "\n            fis.close();", "\n            bis.close();", "\n            fos.close();", "\n            bos.close();", "\n        } catch (FileNotFoundException e) {", "\n            e.printStackTrace();", "\n        }", "\n\n", "        return null;", "\n\n", "首先，代码应该是没有问题的。", "\n报错的位置是在fis = url.openStream()这里。", "\nVoiceAction.java:189", "\n请问，应该从哪里着手解决？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;望采纳&lt;/p&gt;\n&lt;p&gt;下面代码使用文件字符输入流 FileReader 和文件字符输出流 FileWriter 将文件 a.txt 的内容存储到文件 b.txt 中&amp;#xff0c;并在存储成功后在控制台输出 &amp;#34;OK&amp;#34;。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.io.FileReader;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.io.FileWriter;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.io.IOException;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Main&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(String[] args)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt; {\n            &lt;span class=\"hljs-comment\"&gt;// 创建文件字符输入流对象&amp;#xff0c;用于读取文件 a.txt 的内容&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;FileReader&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;inputStream&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;FileReader&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;a.txt&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-comment\"&gt;// 创建文件字符输出流对象&amp;#xff0c;用于写入文件 b.txt 的内容&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;FileWriter&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;outputStream&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;FileWriter&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;b.txt&amp;#34;&lt;/span&gt;);\n\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n            &lt;span class=\"hljs-comment\"&gt;// 使用循环读取文件 a.txt 的内容&amp;#xff0c;每次读取一个字符&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; ((c &amp;#61; inputStream.read()) !&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n                &lt;span class=\"hljs-comment\"&gt;// 将读取的字符写入文件 b.txt&lt;/span&gt;\n                outputStream.write(c);\n            }\n\n            &lt;span class=\"hljs-comment\"&gt;// 关闭文件字符输入流和文件字符输出流&lt;/span&gt;\n            inputStream.close();\n            outputStream.close();\n\n            &lt;span class=\"hljs-comment\"&gt;// 在控制台输出 OK&lt;/span&gt;\n            System.out.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;OK&amp;#34;&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;catch&lt;/span&gt; (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["java 输入输出流和文件处理", ["通过文件字符输入流FileReader和文件字符输出流FileWriter，将a.txt文件内容存储到文件b.txt，存储成功后在控制面板输出“OK”。", "求解答"]], "Tag": "算法设计"}
{"Answer": "```\r\n if(scan.hasNext()) {\r\n　　　　　　System.out.println(scan.nextLine());\r\n　　　　}\r\n\t\t照你的意思是不是应该是while,而不是if\r\n\t\twhile(scan.hasNext()) {\r\n　　　　　　System.out.println(scan.nextLine());\r\n　　　　}\r\n```", "Konwledge_Point": "网络中的流", "Question": ["java网络编程中IO数据输入输出阻塞", ["服务端代码如下：", "\npublic class Server {", "\n　　public static void main(String[] args) throws IOException {", "\n　　　　ServerSocket ss = new ServerSocket(30000);", "\n　　　　Socket socket = ss.accept();", "\n　　　　PrintStream ps = new PrintStream(socket.getOutputStream());", "\n　　　　ps.println(\"服务器第一行数据\"); //1", "\n　　　　ps.println(\"服务器第二行数据\"); //2", "\n　　　　ocket.shutdownOutput(); //3", "\n　　　　//下面语句将输出false", "\n　　　　System.out.println(socket.isClosed());", "\n　　　　Scanner scan = new Scanner(socket.getInputStream());", "\n　　　　BufferedReader br = new BufferedReader(new 　　　　InputStreamReader(socket.getInputStream()));", "\n　　　　//为什么只得到客户端第一条数据", "\n　　　　if(scan.hasNext()) {", "\n　　　　　　System.out.println(scan.nextLine());", "\n　　　　}", "\n　　　　//为什么此处得不到数据", "\n　　　　　while(br.readLine() != null) {", "\n　　　　　　System.out.println(br.readLine());", "\n　　　　}", "\n　　　　scan.close();", "\n　　　　br.close();", "\n　　　　socket.close();", "\n　　　　ss.close();", "\n　　　　}", "\n}", "\n客户端代码如下：", "\npublic class Client {", "\n　　public static void main(String[] args) throws IOException {", "\n　　　　Socket s = new Socket(\"localhost\", 30000);", "\n　　　　Scanner scan = new Scanner(s.getInputStream());", "\n　　　　// 为什么只能得到服务端第一条数据", "\n　　　　if (scan.hasNextLine()) {", "\n　　　　　　System.out.println(scan.nextLine());", "\n　　　　}", "\n　　　　PrintStream ps = new PrintStream(s.getOutputStream());", "\n　　　　ps.println(\"客户端的第一行数据\");", "\n　　　　ps.println(\"客户端的第二行数据\");", "\n　　　　ps.close();", "\n　　　　scan.close();", "\n　　　　s.close();", "\n　　}", "\n}", "\n服务端运行结果：", "\nfalse", "\n客户端的第一行数据", "\n客户端运行结果：", "\n服务器第一行数据", "\n如上述所示，服务端在 //1,//2处已经将数据输出到socket输出流了，在//3处才关闭输出功能，为什在客户端得到的数据只能显示一条", "\n同样，客户端输出了两条数据，在服务端关闭输出，输入功能应该不收影响，为什么也只能得到一条数据。"]], "Tag": "算法设计"}
{"Answer": "首先，目测有一个问题就是你的异常分支没有任何处理，应该打印堆栈日志的。\r\n其次，你说没有输出结果，可能是代码报异常了吧。建议把异常分支都处理后再看看。", "Konwledge_Point": "网络中的流", "Question": ["Java网络编程对象流对象无法传递", ["哪位大神路过指点一下，运行后服务器端控制台只能显示已连接就没了，不知道那里出错了，输出不了对象的name和pass，谢谢指点，谢谢"]], "Tag": "算法设计"}
{"Answer": "**如果这个规则不变，可以通过 .Split('^')[4] 取出来转成 bytes 再转成图片。**\r\n\r\nAAEBAgIDAwMEBAQEBQUFBAQEAwMDAgICAgICAgICAgEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\r\n\r\n\r\n**但是我试过把这段转成图片，发现是失败的，那么很有可能这串字符串不是标准的 base64 字符串，或许需要解码。下面尝试转图片失败的过程。**\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/202007/23/1595485307_921140.png)\r\n\r\n\r\n-------------------------------------------------------------------------------\r\n**这里出使用一张 CSDN 的默认头像照片转成的 Base64 字符串，再转换成图片最后赋值给 pictureBox1 的代码**\r\n![图片说明](https://img-ask.csdn.net/upload/202007/23/1595485516_163924.png)\r\n\r\n\r\nhttps://oktools.net/image2base64\r\n\r\n**这个网站可以在线把图片和 base64 之间互转。最后是转换成功的代码和 base64 信息**\r\n\r\n```\r\nvar str = \"^Application^Octer-stream^Base64^iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAYAAAA8AXHiAAAQBklEQVR4Ae2cPa8mORFG9+9utjEbkJFAQroBQiRESJsgBBIRIAhINkEiWUGAREBAAAHRReeuHqmmxnaX3bbbfsdBy/3hj7Lr+Knqfu/MZ7/5x3/fznHWoDcDn/Xu8PR3IIWBA9ZR7CER64B1wDpgnTC7T5g9ivWwYv3iz38dohhPb8ID1kNgAdSPf/ijt+99/vnbK8J1wJoM1k++/vXbD7788h0ooDpgTXbA01Lee/wUUAesA1VzHmRDnkDyZW+IV+jvhMJBmyYClABbAYTeNhywBoBF2Pv+F198kEcJolTZ26kr9HfA6ggWKuUT8xRI/t4KIPS24YDVCayffvVVWKEsWChbb6eu0N8nDxYqw9HqjFaVElwHrE47u9WBI9oBBY5FbVr6r82lBJMtCZ0tY6/e5pNVLEGFk1tUQ1/NLSQt5wesF1Msn2SjPhEVuBv6PHwHrBcCK6U23LsCC/g8GHevI+Ne2bXi808uFJbe3lCjnJNSMN6FivYHrBdQrCvFSYXD3qHPw3jA2hwsm6x75+ra5zuRNmrbWh6wNgfLJ+s5EBQOr9Qt1772fuunjlzIXuX+J5Fj1eRHOHoWVEB4wNpUsWZCUqtWB6xNoZqRI7XAZNukXhhWCWd37HjpUBjNq6yjZ58fsDZTrdL3qtnwlMY7YG0EFiGw5MyVnh2wNgJrhxAouA9Ym4C1SwgUWPpudidRXrHtSyXvO4VAgXW+Y22gWDuFQIGlko+4rxQWX0KxcAh/rCcn7Vwyj1cAbGuwXgkovxnu/Mn0CjnXlmC9MlApwHZUsK3AIjmv+UHZO2nna/LHnd4gtwHrU1Kp0gbYRb22AOtTVakcYKzHCnlUyYalwUL6d/6EkAOjx33WpeTYp58tCxZQvconhB4gpfpYOe9aEqwD1Xf/018KJn+PzbdiUr8cWAeqOFSCbEW4lgLrQFUPleBaLedaBiyg0iKdsg2wld4WlwHrvP21weQ34SrfuZYA63yn6gOVIFvhT3EeB4sdpgU5ZT/ASOifVK9HwTp5VT+QcpuSFOMJwB4D67wBjofKwjYbsOlgAdTJqeZCZQHjnPVHxfDFqJ9+poHFJHb7hw7eIa94PSoXmwIWu4MJvKJjdp7TKKhQweFgSakOWM+GP78BCIcvEwoPXM/DNVKlbL42XLEY7ITC54GSYilpR610cI+DHBgl6/G74zCwng6B7EwWSMdMtWQsHPTLn//s7fe/+vr9+OYPv33j+PabP70fnPOMOtSdaZ8gy5VAZtWn5bwbWICEQTMXyToQR/37b395+9+//v729p9/Zg/qyKns0B4OpQ/6kg2l8XPPsJv2T78591ArQLwNFkABU47+EfcZDydcQZRzor1PH6hIi0NpQ1vbX49z4EfJRqzdVZ/4s0WhfJvbYKnDGaEPR7LoPZyX6kMOvVKx0XbINuyZuWl7hEDx0A0sdUiJgUjq1e6IPqcvFEoLPrrMORQ7RijU1XxmqBcAWx/ePR8CluCKglOqhzr0CHlXzks9tw590g5sY2OV1unOs155lYWxK1hK4HupFc5MOXzmPd7cVrCDOWPLHYBSbQn7vfKqYWARAlPGt9xDLWYCtMtYVkVb1tW36ZlXDQOLjqH/Kvn1k/PXqyjEqrD1gmsUVHDQNRSK2DtwEUafyqlWBSll1923RdaZPlTKd73KIWBhXGtYfOKtK+W41e+xTl7pW6+Xz7E87bVJPMnp6g5dyb4eIbH3ZwYxMEyxGIBcKbqLgHAlp+1gCylD7eb1/hihVvh+KFg1k575AXQHaKI23vm+NUqthoMVfTs8apX/0TwCWM0GtoqVUyvukyP7I1df4c+WwxQLI+wkSudHre6B1fLh1KqVQIoASp3IZ4owWKKXvAmjKDm4nyI5CtZRq3tQoWjkWtHooA2Ofzjwpe7VlBZMq1Q6vwQLeCJGU4e6ggzgIoaeL+z3wQKumjdEoMA/Eb+WfIgoCCRfZsECkIg0pgamXXQnjPwzmEh+8ip1WMeUL1L3Wv2a6gsx8VBxnQXrLs0pI/w94HsVx64wj17A1PpeUcoClgQrqjYelNrr80G0TxgU1DXhUL4CRtrxJd//lIYK4qMrYFOq9RFY0KdBSyVUMyAQUtZSTt8jwiALxFvmiL7lwB7lCDtrfuYBBupH5gJwJbHB91atkqGw1AEw8DxnEM7EqRhdgpJnGBOZVLROavIrvhik7GS9ovO8qhfZ4C3j4dtS3z4cfqRYJSBqDCr1w7Oavq4Wk+f0lxpztW9kOTt7pQVXwnBn7UuhlrdMq1ofgFUKg4Q7H4NzDqdeysn2Xq+FlA253dQbYI3XWubylV52lpyv9W8dqxRqi2CVvj3VgBABKxdOWx12wPruRQCFFkC5shWskl/pM6tYPMwZU5MMUzfXj+5H1S8KWm6nrhYKR9sZWftWsPBFaQM3gRV1MPWuJodxNf1F6gKqzy9wYqTtzDrY6TdwbztzztemvgNWLpQXQ6GfsAypBeEKLIwb5UzGRqUoR43Ro9+RduacL3/eATkHbRGsXI5VC8IVWHd2TA+nvnofXrkFlMpWsEo5VvFzQw6sWsUqGcDkWif26kD0ml8u8twFqyQYNr/iPPy5AViiEz9g9f2pJrruqsfGFUSpsuYNX31S5t44UcgiWDxMGcK9mpzlCqzWidlJnvM8vKxvzo/cb13/HLA+v/pIsbiRi8+1r+25JI+J1fZ1IMpDlFqbnLIIttb1T70U4GevVkmwcnlWbV6UMuLuxFKL+Kr3UH0OIsV7tPjj797e3KFnqqu1GAFW7qt7Sq2SYHEzpTa1b4YlsHp/ddeC9i5xHGGDTUWJw3Bi73FsfzmIPFS5a+zLQaCN/T5G4X89tPboPPVCgI9TapUFK6daNRKaC6lMzoJ1tSu1gHZ3arKjSsbK2c+mq1XvqJ3v0DpV0vxryiuwovaoXk4Bc2qVBYsHKcVhsTXYVZlL9ATW3Z3ZsuuubNbzHFTa8ZQ1m0z9Rso7cLEmV4pVG3noMxXBSlAVweKDV6rD6BsF9awj7Pm7YnXYmRFHtdTBvtTcNYdRiuVtBRIOnJs73kF0Ya2kWDUfp+knJTD0ATyl44PvWL5iKiSy4O9guMn4RcnJJ86hvRasRuJVVzvTj9nzmjG8cjH36MbqaUttXyWwIpsC3zDP1OaKQFVULEGWg+sqFOAY7XBfpsBkMvYQPPZe7QLfrc/YFq6rOd8dr1f70qbObQzmil8ALwUU967Cn5gJgUWlFFzAAr0AkFuQlIG028VBzEtOqs1Ncmsy475s9hvaXjMfNg1lKtzZutTzvwVaiFLnxVBoG+RyLgwAMCYjldHi2d1uDc3tGrVbqVRYYS4r2VWyhfW169163gKUmAmDpQZA1Gqo2h2w6r6klyBKPcu9kQMK0QcfolI+okjFqFOrUOJDZTVYNGRQjPOGCZyrMpJAphbsiXvKFZnvE+O3jJnb/DU5kgBpLZvAsoMJMnaDdoHI514Ksp2ctCNYrH9q3a3fRp/fBuvKwBRcTLxlJz7RZkewUlDhhytf9Xw+HKzcGyWvt0+AUjvmbmDJXg/XzDAIoMPBYhA/Sa5T37JqnT6jPhsAe3cJ36k3QnLhnmoU6WsKWKlwuMubocDa5YUjtdZsiggMPetMASsVDlmAGYpzd4ydwJKtPkLc/XTQAtwUsDAs9aZCPnDX8TPa46gdFCv1xX120i4Ip4GVUq1dwuEuYKXC4BNqBVzTwEqp1i7hcAew9NOTDYNP5FbTFYsBU6qFfM8IZ3fG2AEsILJQPfEmKKgopyoWA3q5jnwsJRd7EsAnwWLurFlJ3VPfrmZ/t7JQPQIWMd//xliChjcdJf7sSq7vqE9L26fAYl20VpQ52/1m5do7evb1dMVigj4ksmi5N0RAsgsHZLM/rs4Giznb0Faas/9LBurOhig13iNgYYiFBcexICU14g1Su5f6LHwOxtzObr0/Eyw7T+ZbenNG0bDNHk+9BXq4HgMLQ4DJLgqwlJwPSHYny+ElIEv9RZ9pnGj9lnpAovUAKJSoNC9U2240bHw6r7JwPQpWKt9CyUoLitMAzIYAOWKUgo0Ci3miSB6oq3nQBpvssRJUAPYoWBiQgouFvlpcC5gcw0IDJrv/Cs6oqtBPb7BQGzaGFAf7gSVis91QAms1qJYAS3BZOFgwFh1AogBQ14ZJ2nN9F7JeYAkmzVP2RV9EqOfzUtZpRaiWAQtDOFILx72IeglAQBBkUgQcQD/sdhwUUQbbH+2v8j/VV4nNqBDtZIdgqoGdfuyGwRYOAF0lUZf/bPl4KLTGcJ5aRBYSKGoAk4MBSQ6WWsgxgo3nOJv+PXTco74Hi3o8o3/aagy7OQQSz6gnmyIlfdtwiQ06GMOv22rXy4HFArETLQRaUDmYRY84J1WHtgIBx+EkxpKqaCyuOWSHzlP1qGMhBaJWG0tAMfaqoc+DvSRYMjKnXjgfR6IEXmFSMEXvWRUCDqkRIHLoHs7n6Dk2/V/Nd+XQJ5+pXBosjGQxgUhKkipxCI7p6egojHfqAWou3GmezH0noLYBS4ZGAJOS4Sycthpo2CNl8iFVIKncFSj5a3nFkqG2JM9Q7iNH5EochKIpgZ4FG+MAt5L6qL3MA5vtfHc83xIsLTQqlgOqdB+1EHCoG85XDmXzJw8h1zqoBzi04xBA9FsDUc7OXZJ0+cKXW4OFE3OOeYX7O+ZWAmxbsNjRrwBPaQ4onxy1W7klWOzkq+S35LCdnu0aErcE69VDoAd/x5C4HVivFgIjystGOqHw4n/TvbtAEUf4Hb/yNfOJvEXuFhK3UqzSTx694cHhjGc/R+izgj4tRICI2BUJ7bsl8tuAFU3Y7yoaTub7VPSnGr5nAV8EoFwdoIlAupNqbQNWRK0izik5twYoDx6ARZQnN34kd2TT3E0lZrXfAizUKucQe7/VsQAJGB6WluvIBrA26xywImq7i2ptAVbEWcDRAhbt/E83LUDZNhF7BZRKbI+020W1lgcrqlbRHS9HqrwT/ixM9hxQI+ojGyipXzPXWSGtdZzlwYru4qhTrDNJui0QPc95g7RjRc6ZQ0R1d1Ct5cGK7HycEUl+vXN7h0APZu3LBHOIzoN6rWoyo93SYEUXObrTLVgooQeh93XtZwg2CE6PbCagnQFI6xhLgxXZ8QoLkboWrBG5lQeTN0075tW5YImEQ/piQ7U6fnS7ZcGK5kwoD4t05TT7HBg9BKOua4FnLlGllsKNhqSl/2XBqtm1UQgFF32PAsn3G3n5kF2UUqFIOLT1W5w/ss2yYNnFzp0rDNaCNfJt0IPF74o5+1P3BVZ0Y0mxR0LS0veSYEVDgRY1Wl+O5FOAB2DUde1nB+aCI6Nz0uZqcf7INkuCFc1Lap0gsGYk7gKVsTRupNScalRYbUaCUtv3cmDVLKgmW5vH9PpdUPCUyto3Q6kwc4tusBWT+OXAikKiV3McEG0jxRj9YdSDpnEjpYWkZl7aZKuU/wfWRluJhua22QAAAABJRU5ErkJggg==\";\r\nvar bytes = Convert.FromBase64String(str.Split('^')[4]);            \r\nvar ms = new MemoryStream(bytes);\r\npictureBox1.Image = Image.FromStream(ms);\r\n```", "Konwledge_Point": "网络中的流", "Question": ["C#如何将字节流数据显示为图片？", ["^Application^Octer-stream^Base64^„„直方图数据„„”，其中“Application”表示传送的是应用程序数据，“Octer-stream”表示数据为字节流类型， “Base64”表示位图数据的编码方式。", "\n数据：^Application^Octer-stream^Base64^AAEBAgIDAwMEBAQEBQUFBAQEAwMDAgICAgICAgICAgEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="]], "Tag": "算法设计"}
{"Answer": "(1)爬虫有什么用，主要有两个，一个是抓取数据，下载文件；一个是机器人，模拟人对网站操作。\r\n前者你已经基本知道了，后者，比如12306刷票，水军刷评论，操作一些没有提供api接口的网站，比如查询快递进度（现在有接口了，以前没有）\r\n\r\n(2)抓取电商数据有什么用，自动比价，分析，研判。做数据挖掘和分析。\r\n比如说，商品定价贵了，销量比较少，定价便宜了，单品获利少，那么定价多少才能收益最大化？这个定价策略对于个别商品来说，人工可以去估计，但是对于大型电商来说，需要机器学习去分析吧。怎么分析，首先要数据啊。\r\n还有，你要知道哪些商品是爆款吧，哪些商品在短时间内销量大增吧。比如说，12月一到，电暖器销量增加，9月1日，文具销量增加，情人节，鲜花、情趣用品销量增加，这个销量到底增加多少？备货多了，挤压资金，占用场地，备货烧了，供不应求，眼看对手赚钱干着急。那么又需要机器学习了吧。\r\n场景太多了，我只是举例。", "Konwledge_Point": "网络中的流", "Question": ["请教各位大拿，现在流行的网络爬虫有什么用", ["请教各位大拿，现在流行的网络爬虫有什么用，比如python开发的网络爬虫，通过检索电商页面的物品信息、价格、介绍，拿过来有什么实际应用价值吗？", "\n\n", "1.不清楚为什么python爬虫那么火？", "\n\n", "2.不清楚爬虫的真正目的是什么？难道就是为了生成个历史趋势图吗？", "\n\n", "3.它的应用场景是什么？", "\n\n", "请认真说明，喷子勿喷！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这个我们之前做过&amp;#xff0c;从海康威视的摄像头实施传输画面到客户端&amp;#xff0c;格式是rtsp的。客户端是用electron写的。&lt;/p&gt;\n&lt;p&gt;我们第一个方案是用 ffmpeg 在后台将 RTSP 流转成 HLS 流&amp;#xff0c;前端加载 HLS 流。延迟高达 20s 以上&amp;#xff0c;而且还经常失败。而且服务器转码的压力也很大&amp;#xff0c;转上8个流就已经没有资源转其他的了。&lt;/p&gt;\n&lt;p&gt;第二个方案是 RTMP 流&amp;#xff0c;前端用 Flash 插件播放 RTMP 流。延迟也达到了5s以上&amp;#xff0c;而且服务器转码压力还是没有解决。&lt;/p&gt;\n&lt;p&gt;第三个方案是客户端自建 express 服务器&amp;#xff0c;本地调用 ffmpeg 接收 RTSP 流直接转发到 Websocket 中&amp;#xff0c;前端使用 Bilibili 的库 Flv.js 播放。终于能将时间压缩到 2s 。&lt;/p&gt;\n&lt;p&gt;希望能对你有帮助。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["前端播放摄像头实时视频流（H.265）", ["如题，github上有很多播放h265视频的库（h265player、numberwolf/h265web.js、ErosZy/WXInlinePlayer等），但是好像都是播放本地或网络上的文件。不知道如何播放摄像头的视频", "我现在已知的呦摄像头的rtsp，请问怎么处理。"]], "Tag": "算法设计"}
{"Answer": "命令没问题，应该是网络的问题。", "Konwledge_Point": "网络中的流", "Question": ["FFmpeg推送rtmp视频流到nginx的问题", ["FFmpeg将网络摄像机的rtsp视频流转换成rtmp流，然后推送rtmp视频流到nginx上面，然后使用手机播放hls的视频流。", "\n在期间遇到一些问题，总是丢包，我截了个图，请大家帮忙看看是不是我在使用ffmpeg时参数设置的不对啊。", "\n我使用的命令：", "\nffmpeg -i rtsp://admin:12345@172.27.35.56 -vcodec copy -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 640x480  rtmp://172.27.35.2:1935/hls/test2"]], "Tag": "算法设计"}
{"Answer": "调用ffmpeg实现\r\nhttp://blog.csdn.net/hclydao/article/details/36415975\r\nhttp://blog.csdn.net/hclydao/article/details/18546757\r\nhttp://blog.csdn.net/gobitan/article/details/22750719", "Konwledge_Point": "网络中的流", "Question": ["android保存h264流文件为mp4", ["网络预览视频，收到的是H264编码的流，有个保存按钮，可以把收到的留实时保存为H264的流文件，用特定播放器可以播放，想收到流的同时，另外实时生成一个MP4文件，有什么好的方法"]], "Tag": "算法设计"}
{"Answer": "你本地有LiveServer吗？\r\nhttps://github.com/winlinvip/simple-rtmp-server", "Konwledge_Point": "网络中的流", "Question": ["Ubuntu上用FFmpeg将rtsp流转换成rtmp流出错！", ["使用“ffmpeg -i rtsp://admin:12345@172.27.35.55 -f flv rtmp://172.27.35.2/live/stream”命令时出错", "\n其中172.27.35.2是我电脑的IP，172.27.35.55是网络摄像机的IP"]], "Tag": "算法设计"}
{"Answer": "如果是纯 connection 或者 纯OkHttp，响应逻辑，走的是回调驱动，如果业务逻辑复杂，你会面临一个著名的 回调地狱（callback hell）；  \r\n如果你结合了rxjava，当然rxjava 结合 okhttp，和用不用retrofit没有任何关系，但是你既然这么问了，我断定 你写出来的 中间层-桥接层，一定没有retrofit好；  \r\nrxjava基于事件驱动，当然也有用到回调，但是不会陷入回调地狱，这个与纯回调驱动的本质区别；  \r\n但是，如果你对kotlin的协程，有足够的的认识，我想，你是完全可以摆脱rxjava，使用协程并发模型去解决你的业务需求；  \r\n技术选型呢，为业务而生，还有就是，多用著名的开源框架，这样，即使你搞不定，也还有千万网友助阵；", "Konwledge_Point": "网络中的流", "Question": ["android关于网络请求,和异步问题", ["最近很流行RxJava+OkHttp;", "\n我想问的是,目前大部分网络框架中的都有异步网络请求的方法,为什么非得配合Rxjava去进行异步操作呢?"]], "Tag": "算法设计"}
{"Answer": "这个应该是不同版本vlc处理rtmp流时候，处理方式不同造成的，使用播放器potPlayer，这个能很好的处理rtmp流", "Konwledge_Point": "网络中的流", "Question": ["2.2.1版本的vlc播放rtmp流会自动断开，而2.2.1以下的版本都不会", ["2.2.1版本的vlc播放rtmp流会自动断开，而2.2.1以下的版本都不会", "\n通过vlc的 工具-》编码器信息-》统计   这里面可以发现2.2.1版本的vlc播放时候会直接丢掉前面一些帧，比如一次丢掉34帧，然后进行播放，后面都很正常，但是vlc2.2.1 它不会一次直接丢掉前面的34个无效帧，而是直接播放，这样发送数据时候过快，client还未来得及处理，结果client端就直接断开了，但是断开后，rtmp server还是运行的，这时候重新连接client，于是后面可以正常播放了，我想就是第一个I帧残缺引起的错误，我播放的是flv文件，是通过ffmpeg从rtmp://live.hkstv.hk.lxdns.com/live/hks 上面下载下来的", "\nffmpeg -i \"rtmp://live.hkstv.hk.lxdns.com/live/hks\" -vcodec copy -acodec copy  test.flv  。", "\n请教下哪位大神，假设低版本的vlc处理前面的一些帧时候 一次丢掉34帧数据（这里34帧作为参考，可以更多或更少，看文件本身），这样做的好处，和2.2.1版本vlc 却不是这样处理，而是直接播放那些视音频帧，从而断开连接。", "\n\n", "还发现一个问题，就是2.2.1 vlc版本播放rtmp流时候，查看vlc的 工具-》编码器信息-》统计 ，发现视音频的 已解码 已播放 都是0，但是某个时间一下增长到355 355 ，而2.2.1及以下低版本在播放的同时 （视音频的 已解码 已播放） 慢慢增长，请问下 这个是啥情况啊"]], "Tag": "算法设计"}
{"Answer": "按照你的描述,应该可以排除网络问题和程序问题, 那只可能是RK3399的问题了. \r\n可能的原因是RK3399硬件的问题和RK3399系统的问题.\r\n硬件的千兆网接口都是比较成熟的了,出问题的可能性不大.那问题就很可能是软件问题.\r\nfirefly官方的ubuntu系统一直有bug,你可以给他们客服反馈一下,再看以下他们有没有对系统做升级, 如果有,可以试一下新的系统;", "Konwledge_Point": "网络中的流", "Question": ["求助: RK3399 的 TCP 重传无效 问题", ["使用RK3399开发板给服务端的PC发送数据时,总会遇到服务端收不到数据的情况.", "\nRK3399作为TCP的client,PC作为server.", "\n出现问题时,PC端一直收不到ARM的数据,但ARM端没有显示任何异常;15分钟后,ARM放弃该TCP连接,重新建立一个新的TCP连接;", "\n出现异常时,网络正常,能相互ping通;如果另外启动一个client,也能正常发送数据;", "\n使用抓包工具对server端和client端抓包(wireshark和tcpdump),发现两边的抓包结果一致：", "\n\n", "\n", "client和server在正常传输数据；\n\n", "\n", "server端发出 DUP ACK包；", "\n", "client端应答 Fast Retransmission；", "\n", "重复 2，3过程一会儿后，client端发送 TCP Retransmission，server端无应答；", "\n", "client端重新建立连接；\n由于无法上传图片，只能这样描述了。\nPC端尝试更换过工控机和普通的台式机,尝试过windows server和win10和ubuntu16.04, TCP server的程序尝试过自己写的服务端和网络调试助手;\nRK3399更换过3个不同的开发板,也使用过不同的client程序(一个是基于muduo库写的应用程序,一个是基于linux的socket接口写的测试程序)", "\n", "\n", "\n", "详细问题描述在这儿（因为提问的地方没法发图片，只好这样了）：", "https://blog.csdn.net/cdxdrg/article/details/82714541", "\n\n", "后来根据同事的建议，将TCP的每个包大小改到1200byte以内（实际只有800多byte），增加流量控制（每隔200us发一包），仍然有相同的问题。", "\n另外,在这儿: ", "http://dev.t-firefly.com/forum.php?mod=viewthread&tid=13206&extra=&highlight=%CD%F8%C2%E7&page=1", " ", "\n有人提到rk3399的网络有问题,VDD_LOG偏低,但我测试了一下,我的板子的VDD_LOG并无异常.", "\n\n", "麻烦CSDN的高手帮忙解答一下.", "\nQQ: 2775379941  可直接技术交流."]], "Tag": "算法设计"}
{"Answer": "1.需要域名，可以用花生壳等，也可以向 万网 新网 N987 新网互联 35互联 商务中国 中资源 时代互联 等这些购买\r\n2.需要主机或者租电信的网络\r\n3.发布网站，采用域名，会重定向你的计算机，就可以访问了\r\n\r\n防止网站攻击可以采用防火墙，硬件的比较安全", "Konwledge_Point": "网络中的流", "Question": ["如何在网络上发布一个网站?希望懂的人帮帮忙", ["我想把自己的网站发布到网上,具体需要怎么做呢?", "\n还有,发布的网站是不是需要做些必要工作,以防止网站很容易被攻击之类的?"]], "Tag": "算法设计"}
{"Answer": "网络视频，一般采用 RTP 或 RTSP 协议，还是可以检测的。\r\n就算还有其它流媒体，通过网络抓包分析后，也是可以获取到的。不过，需要你对流媒体的格式比较清楚，否则就算抓到流媒体的数据，你也不认识它。", "Konwledge_Point": "网络中的流", "Question": ["关于媒体流侦测的问题", ["浅浅的问一句：有人知道类似vso downloader之类的网络视频下载软件的原理吗？"]], "Tag": "算法设计"}
{"Answer": "http://blog.chinaunix.net/uid-22753395-id-1769787.html", "Konwledge_Point": "网络中的流", "Question": ["Argus                     ", ["A data stream is a real-time, continuous, ordered sequence of items. Some examples include sensor data, Internet traffic, financial tickers, on-line auctions, and transaction logs such as Web usage logs and telephone call records. Likewise, queries over streams run continuously over a period of time and incrementally return new results as new data arrives. For example, a temperature detection system of a factory warehouse may run queries like the following.", "\n\n", "Query-1: ��Every five minutes, retrieve the maximum temperature over the past five minutes.��", "\nQuery-2: ��Return the average temperature measured on each floor over the past 10 minutes.��", "\n\n", "We have developed a Data Stream Management System called Argus, which processes the queries over the data streams. Users can register queries to the Argus. Argus will keep the queries running over the changing data and return the results to the corresponding user with the desired frequency.", "\n\n", "For the Argus, we use the following instruction to register a query:", "\n\n", "Register Q_num Period", "\n\n", "Q_num (0 < Q_num <= 3000) is query ID-number, and Period (0 < Period <= 3000) is the interval between two consecutive returns of the result. After Period seconds of register, the result will be returned for the first time, and after that, the result will be returned every Period seconds.", "\n\n", "Here we have several different queries registered in Argus at once. It is confirmed that all the queries have different Q_num. Your task is to tell the first K queries to return the results. If two or more queries are to return the results at the same time, they will return the results one by one in the ascending order of Q_num.", "\n\n", "Input", "\n\n", "The first part of the input are the register instructions to Argus, one instruction per line. You can assume the number of the instructions will not exceed 1000, and all these instructions are executed at the same time. This part is ended with a line of ��#��.", "\n\n", "The second part is your task. This part contains only one line, which is one positive integer K (<= 10000).", "\n\n", "Output", "\n\n", "You should output the Q_num of the first K queries to return the results, one number per line.", "\n\n", "Sample Input", "\n\n", "Register 2004 200", "\nRegister 2005 300", "\n#", "\n5", "\nSampleOutput", "\n\n", "2004", "\n2005", "\n2004", "\n2004", "\n2005"]], "Tag": "算法设计"}
{"Answer": "如果需要公网访问，则防火墙要关闭，并且监听端口要打开。不过一般不建议开启非通用端口，可以在80或者443上监听。", "Konwledge_Point": "网络中的流", "Question": ["C# HttpListener 在本机测试有用，在服务器上运行，客户端无法连接!", ["C# HttpListener 在本机测试有用，在服务器上运行，客户端无法连接", "\n\n", "if (!HttpListener.IsSupported)", "\n            {", "\n                throw new System.InvalidOperationException(", "\n                    \"使用 HttpListener 必须为 Windows XP SP2 或 Server 2003 以上系统！\");", "\n            }", "\n            // 注意前缀必须以 / 正斜杠结尾", "\n            string[] prefixes = new string[] { \"http://localhost:49152/\" };", "\n            // 创建监听器.", "\n            HttpListener listener = new HttpListener();", "\n            // 增加监听的前缀.", "\n            foreach (string s in prefixes)", "\n            {", "\n                listener.Prefixes.Add(s);", "\n            }", "\n            // 开始监听", "\n            listener.Start();", "\n            Console.WriteLine(\"监听中...\");", "\n            while (true)", "\n            {", "\n                // 注意: GetContext 方法将阻塞线程，直到请求到达", "\n                HttpListenerContext context = listener.GetContext();", "\n                // 取得请求对象", "\n                HttpListenerRequest request = context.Request;", "\n                Console.WriteLine(\"{0} {1} HTTP/1.1\", request.HttpMethod, request.RawUrl);", "\n                Console.WriteLine(\"Accept: {0}\", string.Join(\",\", request.AcceptTypes));", "\n                Console.WriteLine(\"Accept-Language: {0}\",", "\n                    string.Join(\",\", request.UserLanguages));", "\n                Console.WriteLine(\"User-Agent: {0}\", request.UserAgent);", "\n                Console.WriteLine(\"Accept-Encoding: {0}\", request.Headers[\"Accept-Encoding\"]);", "\n                Console.WriteLine(\"Connection: {0}\",", "\n                    request.KeepAlive ? \"Keep-Alive\" : \"close\");", "\n                Console.WriteLine(\"Host: {0}\", request.UserHostName);", "\n                Console.WriteLine(\"Pragma: {0}\", request.Headers[\"Pragma\"]);", "\n                // 取得回应对象", "\n                HttpListenerResponse response = context.Response;", "\n                // 构造回应内容", "\n                string responseString", "\n                    = @\"", "From HttpListener Server", "Hello, world.", "\";", "\n                // 设置回应头部内容，长度，编码", "\n                response.ContentLength64", "\n                    = System.Text.Encoding.UTF8.GetByteCount(responseString);", "\n                response.ContentType = \"text/html; charset=UTF-8\";", "\n                // 输出回应内容", "\n                System.IO.Stream output = response.OutputStream;", "\n                System.IO.StreamWriter writer = new System.IO.StreamWriter(output);", "\n                writer.Write(responseString);", "\n                // 必须关闭输出流", "\n                writer.Close();\n\n", "            if (Console.KeyAvailable)\n                break;\n        }\n        // 关闭服务器\n        listener.Stop();\n"]], "Tag": "算法设计"}
{"Answer": "我是通过tcp的recv去接收数据的，这跟用udp的recvfrom去接收，有什么不同。\r\n我recv到得数据跟标准的rtp包有差别，不只是不是我的接收数据有问题\r\n附上代码：\r\nwhile(receive_bytes = recv(*(pthread_t*)p, recvbuf,\r\n        sizeof(recvbuf)-1, 0)&gt;0)\r\n\t{\r\n        receive_bytes = strlen(recvbuf);\r\n\t\t//printf(\"receive_bytes=%d,strlen(recvbuf)=%d\\n\",receive_bytes,strlen(recvbuf));\r\n\t\t//printf(\"%s\\n\",recvbuf );\r\n        if (strncasecmp(recvbuf,\"RTSP/1.0 200 OK\",15)==0)\r\n\t\t{\r\n\t\t\tsend_ok = 1;\r\n\t\t\tstrtok_ok++;\r\n            printf(\"strtok_ok=%d\\n\",strtok_ok );\r\n\t\t\tif (strtok_ok == 3)//切出session\r\n\t\t\t{\r\n                printf(\"strtok the session\\n\");\r\n\t\t\t\tstrcpy(session,STRTOK(recvbuf));\r\n                printf(\"session=%s\\n\",session );\r\n\t\t\t}\r\n\t\t\telse if (strtok_ok == 4)//切出rtp数据包\r\n\t\t\t{\r\n                printf(\"recving the rtp data\\n\");\t\t\t\t\r\n\t\t\t\tconnet_finish++;\r\n\t\t\t}\r\n\t\t}", "Konwledge_Point": "网络中的流", "Question": ["采用rtsp与网络摄像头对接后，怎么处理网络摄像头发送的rtp数据，才能提出h264视频流？", ["我想问的是：怎么处理网络摄像头的这些数据，才能提出h264视频流？", "\n我把数据放去rtp解包生成h264文件并不能vlc播放。", "\n解包也有错误，解了3分钟，recv到得数据只有3个字节就出现段错误了。", "\n版本号也是不定的，有为0，2,3。", "\n流媒体新人，求大神多指导！！！"]], "Tag": "算法设计"}
{"Answer": "我有碰到过图像失真问题，首先你的弄清楚图片的格式，抓取的如果就是 jpeg格式的话 720*480 能抓到10张还是网速比较快的，\r\n建议先将c里面的图片抓下来存储到文件中，然后看打开是否正常，以排除不是图片本身问题", "Konwledge_Point": "网络中的流", "Question": ["Android里通过C去抓取网络摄像机的Bitmap显示", ["Android里通过C去抓取网络摄像机的图像，1秒钟返回10帧，", "\n也就是10个Bitmap(分辨率：720*480);", "\nAndroid应用层，用ImageView去setImageBitmap显示，画面会花屏、失真；", "\n用surfaceview去draw的话，也是这样；", "\n我想问：应该怎样去处理这些bitmap才不会让图像失真呢？在此先谢谢各位了。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;那叫ajax&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在以瀑布流方式翻页的网站,使用scrapy网络爬虫,但是只爬取了第一页数据,没有爬取第二页.", ["import scrapy\n\n", "from", " news.items import NewsItem\n\n\n", "# https://www.gelonghui.com/api/channels/web_home_page/articles/v8?timestamp=1630749332&loaded=15", "\n\nclass AbcSpider(scrapy.Spider):\n    name = ", "'abc'", "\n    allowed_domains = [", "'gelonghui.com'", "]\n    start_urls = [", "'http://gelonghui.com'", "]\n\n    def parse(self, response):\n        item = NewsItem()\n        elements = response.css(", "'.detail-right'", ")\n\n        ", "for", " element ", "in", " elements:\n            item[", "'title'", "] = element.css(", "'h2::text'", ").extract_first()\n            yield item\n\n        url_ajax = ", "'https://www.gelonghui.com/api/channels/web_home_page/articles/v8?'", "\n        data = {\n            ", "'timestamp'", ": ", "'1630749332'", ",\n            ", "'loaded'", ": ", "'15'", "\n        }\n        yield scrapy.FormRequest(", "url", "=url_ajax,\n                                 ", "method", "=", "'get'", ",\n                                 ", "formdata", "=data,\n                                 ", "dont_filter", "=", "True", ",\n                                 ", "callback", "=self.parse)\n\n\n", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.utils.", "log", "] INFO: Scrapy ", "2.5", ".", "0", " started (bot: news)\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.utils.", "log", "] INFO: Versions: lxml ", "4.6", ".", "3.0", ", libxml2 ", "2.9", ".", "4", ", cssselect ", "1.1", ".", "0", ", parsel ", "1.6", ".", "0", ", w3lib ", "1.22", ".", "0", ", Twisted ", "21.2", ".", "0", ", Python ", "3.9", ".", "1", " (v3.", "9.1", ":", "1", "e5d33e9b9, Dec  ", "7", " ", "2020", ", ", "12", ":", "44", ":", "01", ") - [Clang ", "12.0", ".", "0", " (clang-", "1200.0", ".", "32.27", ")], pyOpenSSL ", "20.0", ".", "1", " (OpenSSL ", "1.1", ".", "1", "l  ", "24", " Aug ", "2021", "), cryptography ", "3.4", ".", "8", ", Platform macOS-", "11.5", ".", "2", "-x86_64-i386-", "64", "bit\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.utils.", "log", "] DEBUG: Using reactor: twisted.internet.selectreactor.SelectReactor\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.crawler] INFO: Overridden settings:\n{", "'BOT_NAME'", ": ", "'news'", ",\n ", "'NEWSPIDER_MODULE'", ": ", "'news.spiders'", ",\n ", "'ROBOTSTXT_OBEY'", ": ", "True", ",\n ", "'SPIDER_MODULES'", ": [", "'news.spiders'", "],\n ", "'USER_AGENT'", ": ", "'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) '", "\n               ", "'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 '", "\n               ", "'Safari/537.36'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.extensions.telnet] INFO: Telnet Password: ", "8", "ec24b696530a0ca\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled extensions:\n[", "'scrapy.extensions.corestats.CoreStats'", ",\n ", "'scrapy.extensions.telnet.TelnetConsole'", ",\n ", "'scrapy.extensions.memusage.MemoryUsage'", ",\n ", "'scrapy.extensions.logstats.LogStats'", "]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled downloader middlewares:\n[", "'scrapy.downloadermiddlewares.robotstxt.RobotsTxtMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.httpauth.HttpAuthMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.downloadtimeout.DownloadTimeoutMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.defaultheaders.DefaultHeadersMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.retry.RetryMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.redirect.MetaRefreshMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.cookies.CookiesMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware'", ",\n ", "'scrapy.downloadermiddlewares.stats.DownloaderStats'", "]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled spider middlewares:\n[", "'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware'", ",\n ", "'scrapy.spidermiddlewares.offsite.OffsiteMiddleware'", ",\n ", "'scrapy.spidermiddlewares.referer.RefererMiddleware'", ",\n ", "'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware'", ",\n ", "'scrapy.spidermiddlewares.depth.DepthMiddleware'", "]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.middleware] INFO: Enabled item pipelines:\n[]\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.core.engine] INFO: Spider opened\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.extensions.logstats] INFO: Crawled ", "0", " pages (at ", "0", " pages/", "min", "), scraped ", "0", " ", "items", " (at ", "0", " ", "items", "/", "min", ")\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.extensions.telnet] INFO: Telnet console listening on ", "127.0", ".", "0.1", ":", "6023", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//gelonghui.com/robots.txt> from <GET http://gelonghui.com/robots.txt>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//www.gelonghui.com/robots.txt> from <GET https://gelonghui.com/robots.txt>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "05", " [scrapy.core.engine] DEBUG: Crawled (", "200", ") <", "GET", " https:", "//www.gelonghui.com/robots.txt> (referer: None)", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//gelonghui.com/> from <GET http://gelonghui.com>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.downloadermiddlewares.redirect] DEBUG: Redirecting (", "301", ") ", "to", " <", "GET", " https:", "//www.gelonghui.com/> from <GET https://gelonghui.com/>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] DEBUG: Crawled (", "200", ") <", "GET", " https:", "//www.gelonghui.com/robots.txt> (referer: None)", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] DEBUG: Crawled (", "200", ") <", "GET", " https:", "//www.gelonghui.com/> (referer: None)", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'元宇宙，人类最后的迁徙'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'Jackson Hole后的美联储货币政策冷思考：预期引导or相机抉择'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'重磅！北交所上市、交易等三大规则来了！七大要点看这里！'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'短空是多短，长多又是多长'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'广发郭磊：九问九答宏观经济'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'房地产经济近况如何？'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'美国50年公平与效率摇摆史的产业启示'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'宋雪涛：宏观研究需要新范式'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'机构席位大宗交易活跃度下降，这些个股却被大幅扫货……'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'永安依旧“最赚钱”，混沌天成“栽了跟头”！73家期货公司上半年业绩出炉，净利最高暴增1368.68%'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'大动作！微信聊天记录付费云存储？苹果每年180元，安卓130元，你会买单吗？'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'能源新基建：绿色复苏新路径'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'食品饮料是如何从天堂到地狱的——速食&休闲篇'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'多部委透露新能源汽车重大政策动向：进一步提高锂、钴、镍保障体系'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.scraper] DEBUG: Scraped ", "from", " <", "200", " https:", "//www.gelonghui.com/>", "\n{", "'title'", ": ", "'人工钻石的疯狂上位之路'", "}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.downloadermiddlewares.robotstxt] DEBUG: Forbidden by robots.txt: <", "GET", " https:", "//www.gelonghui.com/api/channels/web_home_page/articles/v8?timestamp=1630749332&loaded=15>", "\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] INFO: Closing spider (finished)\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.statscollectors] INFO: Dumping Scrapy stats:\n{", "'downloader/exception_count'", ": ", "1", ",\n ", "'downloader/exception_type_count/scrapy.exceptions.IgnoreRequest'", ": ", "1", ",\n ", "'downloader/request_bytes'", ": ", "2257", ",\n ", "'downloader/request_count'", ": ", "7", ",\n ", "'downloader/request_method_count/GET'", ": ", "7", ",\n ", "'downloader/response_bytes'", ": ", "71423", ",\n ", "'downloader/response_count'", ": ", "7", ",\n ", "'downloader/response_status_count/200'", ": ", "3", ",\n ", "'downloader/response_status_count/301'", ": ", "4", ",\n ", "'elapsed_time_seconds'", ": ", "0.928904", ",\n ", "'finish_reason'", ": ", "'finished'", ",\n ", "'finish_time'", ": datetime.datetime(", "2021", ", ", "9", ", ", "5", ", ", "11", ", ", "17", ", ", "6", ", ", "584573", "),\n ", "'httpcompression/response_bytes'", ": ", "313699", ",\n ", "'httpcompression/response_count'", ": ", "3", ",\n ", "'item_scraped_count'", ": ", "15", ",\n ", "'log_count/DEBUG'", ": ", "23", ",\n ", "'log_count/INFO'", ": ", "10", ",\n ", "'memusage/max'", ": ", "222773248", ",\n ", "'memusage/startup'", ": ", "222773248", ",\n ", "'request_depth_max'", ": ", "1", ",\n ", "'response_received_count'", ": ", "3", ",\n ", "'robotstxt/forbidden'", ": ", "1", ",\n ", "'robotstxt/request_count'", ": ", "2", ",\n ", "'robotstxt/response_count'", ": ", "2", ",\n ", "'robotstxt/response_status_count/200'", ": ", "2", ",\n ", "'scheduler/dequeued'", ": ", "4", ",\n ", "'scheduler/dequeued/memory'", ": ", "4", ",\n ", "'scheduler/enqueued'", ": ", "4", ",\n ", "'scheduler/enqueued/memory'", ": ", "4", ",\n ", "'start_time'", ": datetime.datetime(", "2021", ", ", "9", ", ", "5", ", ", "11", ", ", "17", ", ", "5", ", ", "655669", ")}\n", "2021", "-", "09", "-", "05", " ", "19", ":", "17", ":", "06", " [scrapy.core.engine] INFO: Spider closed (finished)\n\n\n> \n> \n> \n> \n> \n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There are several ways to play audio in browser:&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;1) Most usual flash-plugin:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;With flash you can handle raw PCM samples and play them but in that case you need at least basic knowledge of flash API's and ActionScript 3.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;2) HTML5 Video/Audio API's (Javascript), but specifications for these are not finished yet:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;With current API's you cannot handle PCM directly without media container. Google for containers currently supported by browsers, different browsers support different containers and different codecs.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;3) Other plugins like Windows Media Player:&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Maybe you will find, plugin suitable for you but take in account, if you plan to stream your sound to large audience then you better go with popular plugin like flash.&lt;/p&gt;\n\n&lt;p&gt;Summary:&lt;/p&gt;\n\n&lt;p&gt;Sending PCM samples over network is much slower then compressed audio, but as far as you are in local network this should not be a problem.&lt;/p&gt;\n\n&lt;p&gt;One solution is, wrap your samples on server(with PHP), you should choose media container accordingly to client side you choose.&lt;/p&gt;\n\n&lt;p&gt;Or learn little bit of flash and make flash swf that can play PCM samples.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "网络中的流", "Question": ["通过本地网络中的服务器的样本来流式传输音频", ["\n\n", "Excuse me, if my question is silly, but I'm a beginner at web-developing. I am trying to write codes with php and javascript and can't find an answer or some example how to solve my problem.", "\n\n", "The problem is to send audio samples (not a file) from server to client and to play this audio on client.", "\n\n", "I will be very grateful for any help.", "\n    "]], "Tag": "算法设计"}
{"Answer": "都用ijk播放器吧，都用ijk播放器吧，", "Konwledge_Point": "网络中的流", "Question": ["急求,我现在Android 集成Vitamio直播网络视频一段时间就停止,点击也不能继续播放", ["Android 集成Vitamio  直播网络视频m3u8流,一段时间就停止,点击也不能继续播放,必须退出activity页面再进来这个activity播放界面之后进来才能继续播放,", "\n.开始我们怀疑是缓冲问题,为了证实是否是缓冲问题,我们获取缓冲监听OnBufferingUpdateListener 和setOnInfoListener,打log,发现不是在缓冲状态下,而是正常播放状态下卡住.急求!!"]], "Tag": "算法设计"}
{"Answer": "写入的时候：bos.write(buf,0,buf.length);这句话错了，应该是  bos.write(buf,0,i);最后一次只能读取有效长度，不能读取整个数组的长度，因为最后一次数组不会完全读完，有空的。", "Konwledge_Point": "网络中的流", "Question": ["用IO流下载网上的图片，可是图片很模糊，不知道怎么回事。", ["有没有大神帮忙看下，问题在哪，不需要提供其他方法，只是想知道这个的问题在哪？", "\n\n", " package socket.url;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\npublic class CopyOfDownLoad {\n    public static void main(String[] args) {\n        // 相关的所有数据流\n        InputStream is = null;\n        BufferedInputStream bis =null;\n        OutputStream os = null;\n        BufferedOutputStream bos = null;\n        try {\n            // 1、想要下载资源的网络地址和要保存的路径\n            // 资源地址\n            String string = \"http://file28.mafengwo.net/M00/EF/F3/wKgB6lTG9UqAG0o2AA2IG9Yw6Og16.groupinfo.w665_500.jpeg\";\n            // 保存路径\n            String pathname = \"D:/sxtjava/图片.jpg\";\n            URL url = new URL(string);\n            // 2、通过openStream()获取字节输入流，进行读取；创建一个流用于写入本地文件\n            // 读取\n//          is = url.openStream();// 获取字节输入流\n            //或者\n            is = url.openConnection().getInputStream();\n            bis = new BufferedInputStream(is);\n            byte[] buf = new byte[1024];\n            // 写入\n            File file = new File(pathname);\n            os = new FileOutputStream(file);\n            bos = new BufferedOutputStream(os);\n            // 3、读取（下载）、写入（本地保存）\n            int lenth= bis.read(buf);\n            // 读取的不为空就继续读取\n            while (lenth != -1) {\n                //写入\n                bos.write(buf,0,buf.length);\n                bos.flush();//刷新\n                lenth= bis.read(buf);\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally { \n            // 4、关闭资源\n            try {\n                if (is != null) {\n                    is.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (bis != null) {\n                    bis.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (os != null) {\n                    os.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            try {\n                bos.flush();//刷新\n                if (bos != null) {\n                    bos.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"保存成功！\");\n        }\n    }\n}\n![图片说明](https://img-ask.csdn.net/upload/201707/15/1500119290_3254.jpg)\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;已解决&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["wpf webclient下载http图片资源问题怎么解决", ["在wpf使用webclient的downloadfile，下载完之后打开之后显示图片格式不对，没有显示图片就很奇怪。望能解决。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;没有指定字符集啊&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["java发起HttpURLConnection下载zip文件，下下来后不是zip，内容是乱码", ["\n", "\n", "这是代码，请问是哪里出了问题", "https://www.cnblogs.com/tiancai/p/7942201.html", "这是代码来源"]], "Tag": "算法设计"}
{"Answer": "除了对于每帧数据的压缩，还有帧和帧之间的压缩。也就是说关键帧保存的是完整的一张图片，而其它的帧则只保存和关键帧的差异，这样又省了很多。\r\n\r\n具体的算法，可以看相关数字信号处理的教材以及mpeg规范文档。", "Konwledge_Point": "网络中的流", "Question": ["一般的网络视频对话程序是怎么压缩数据的呢？", ["我的两个摄像头分辨率都是640乘480，压缩方式YUV2。也就是说一帧图像有600K大小", "\n视频要能动的话一秒至少要20多帧，这么算下来需要的网速要144Mbps", "\n如果压缩成JPG的话我实验了下，一帧能缩小到大概20分之一，网速还是要7Mbps", "\n但实际的视频通话数据量明显没这么大，于是我想问下视频对话究竟是怎么压缩数据的呢？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这样写有点问题&lt;br /&gt;首先&amp;#xff0c;你说你在缓存中可以拿到相应的播放地址src&lt;br /&gt;那么请问&amp;#xff0c;你的那个videoLists是定义在哪儿的呢&amp;#xff1f;也是定义在return中吗&amp;#xff1f;如果是&amp;#xff0c;那么你这样写就不正确&amp;#xff0c;return中的this.拿不到return里面定义的变量&lt;br /&gt;其次&amp;#xff0c;如果你已经存到缓存里面的话&amp;#xff0c;你可以在return里面的src那里通过从缓存里面拿而不是this.&amp;#xff0c;缓存可以是sessionStorage或者cookie或者localStorage&amp;#xff0c;不知道存在哪一个里面&amp;#xff0c;还是直接放在全局的作用域底下&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["vue-video-player视频播放获取地址动态播放的问题", ["vue-video-player 中点击视频根据id 进行动态播放。", "目前已经把需要播放的videoList放置缓存中 ，并且可以在页面拿到值了，但是没办法无法把属性放到插件中进行播放"]], "Tag": "算法设计"}
{"Answer": "你所谓的按照GBK编码方式读取，关键问题在于你的文件本身是不是按照GBK来写的？如果本身就是GBK的文件，你读取后封装为XML，传输到另一端后，直接写入文件就可以了，不需要还原。\r\n但是如果你原来的文件不是GBK方式写的，那你按GBK读取的话可能会产生一些数据遗失、错误等情况，那样就没有办法还原了。\r\n建议你不要用什么方式，直接按字节流读取，传输后也不需要什么还原，直接按字节流写回文件。", "Konwledge_Point": "网络中的流", "Question": ["求助：JAVA二进制数据与字符串转换问题", ["从文件中按照GBK编码方式读取二进制流，将二进制数据封装到XML数据包中，经过", "\n网络传输到另一端后，再将二进制数据按照GBK编码写回到某一文件中，二进制数据", "\n能够获取到，但是经过字符串处理后，到另一端如何还原回去？大神，求破！"]], "Tag": "算法设计"}
{"Answer": "byte[] buff = new byte[1024];  \r\n            //Receive the file, write it out.  \r\n            int data;  \r\n            while ( -1 != ( data = is.read(buff) ) )  \r\n            {  \r\n                fos.write( buff,0,data );  \r\n            }  \r\n\r\n你这里读到的不一定就是1024，特别是最后一次，不太可能是1024的整数，所以你写出的时候，应该以读到的为准来写出，而不是把整个buff都写出", "Konwledge_Point": "网络中的流", "Question": ["Java TCP文件服务器，下载到的文件和原文件大小不一致", ["本人编程新手，要求用java写一个tcp文件服务器，客户端向服务器端发送请求，下载服务器端的文件。我出现的问题是：客户端从服务器端下载到的文件大小不一致，而且下载到的文件也带不开，真诚请教解决办法。", "\n[code=\"java\"]", "\n//客户端代码", "\nimport java.io.FileOutputStream;", "\nimport java.io.IOException;", "\nimport java.io.InputStream;", "\nimport java.io.OutputStream;", "\nimport java.io.BufferedOutputStream;", "\nimport java.io.DataInputStream;", "\nimport java.io.DataOutputStream;", "\nimport java.net.InetAddress;", "\nimport java.net.InetSocketAddress;", "\nimport java.net.Socket;", "\nimport java.util.Scanner;", "\n\n", "public class SendFileClient", "\n{", "\n\n", "public static void main( String[] args ) throws IOException\n{\n    // TODO Auto-generated method stub\n\n    System.out.println( \"This is client\" );\n    byte[] buf = new byte[1024];\n\n    System.out.println(\"Please input the Ip Address that you connect\");\n    //Create the scanner s1 to let user input the server IP address\n    Scanner s1 = new Scanner(System.in);\n    String ip = s1.nextLine();\n    System.out.println(\"Please input the port\");\n    //Create the scanner s2 to let user input the server port\n    Scanner s2 = new Scanner(System.in);\n    String portStr = s2.nextLine();\n    //Convert the String portStr to integer\n    int port = Integer.parseInt(portStr);\n\n    try\n    {\n        // Create the socket\n        Socket s = new Socket();\n        s.connect ( new InetSocketAddress (ip,port ));\n        //Create the outstream\n        OutputStream os = s.getOutputStream( );\n        //Create the inputstream\n        InputStream is = s.getInputStream( );\n        //Read the buf though the inputstream\n        int len = is.read( buf );\n        //Print out the data by converting it to a String\n        System.out.println( new String( buf, 0, len ) );\n        System.out.println(\"Please input the request\");\n        //Create scanner s3 to Let the user input the request\n        //The request format has to be:Send filename\n        Scanner s3 = new Scanner(System.in);\n        String req = s3.nextLine();\n        os.write( req.getBytes( ) );\n        //Read the data to buf though the inputstream\n        int len2 = is.read(buf);\n        String file = new String(buf,0,len2);\n        System.out.println(\"Wait...\");\n        //Create the dataoutputstream for receiving the file\n       DataOutputStream fos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));\n        byte[] buff = new byte[1024];\n        //Receive the file, write it out.\n        int data;\n        while ( -1 != ( data = is.read(buff) ) )\n        {\n            fos.write( buff );\n        }\n\n\n\n\n        System.out.println(\"\\nFile has been received successfully.\");\n        fos.flush();\n        fos.close();\n        //Close the outputstream\n        os.flush();\n        os.close();\n        //Close the inputstream\n        is.close();\n        //Close the socket\n        s.close( );\n    } catch ( Exception ex )\n    {\n        ex.printStackTrace();\n    }\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "[code=\"java\"]", "\nimport java.net.*;", "\nimport java.io.*;", "\n\n", "//服务器端代码", "\npublic class SendFileSocket extends Thread", "\n{", "\n    /**", "\n     * @param args", "\n     */", "\n    public static void main( String[] args )", "\n    {", "\n    //Start the server", "\n        server( );", "\n\n", "}\n//Set the Server port =10000\nprivate static final int  PORT  = 10000;\nprivate Socket  s;\n\npublic SendFileSocket( Socket s )\n{\n//Create the socket object\n    this.s = s;\n}\n\npublic void run()\n{\n    try\n    {\n    //Create the outputstream\n        OutputStream os = s.getOutputStream( );\n        //Create the inputstream\n        InputStream is = s.getInputStream( );\n        os.write( \"Hello,welcome you!\".getBytes( ) );\n        //Define the data byte as buf\n        byte[] buf = new byte[10240];\n        while ( true )\n        {\n            //Read the buf though the inputstream\n            int len = is.read( buf );\n            String revStr = new String( buf, 0, len );\n            //Print out the request information from the client\n            System.out.println( \"This client wants to \"+revStr );\n            String fileName;\n            //The requet should starts with Send\n            if ( revStr.startsWith( \"Send \" ))\n\n            {\n                //Get the file name from the request by using\n                //The method getFileName\n                fileName = getFileName( revStr );\n                //Print out the filename\n                System.out.println( \"The file name is :\"+fileName);\n                //Write out the filename though the outputstream \n                os.write(fileName.getBytes());\n                System.out.println(\"Start to send file \" +fileName);\n                String filePath = \"C:/\";\n                String file = (filePath+fileName);\n                //Combine the filepath and the filename\n                File fi = new File(file);\n               //Declare a datainputstream\n               DataInputStream fins = new DataInputStream(\n                    new BufferedInputStream(new FileInputStream(file)));\n                DataOutputStream ps = new DataOutputStream(s.getOutputStream());\n                //Start to read the data from the file\n                byte[] buff = new byte[10240];\n                int data;\n                while ( -1 != ( data = fins.read(buff) ) )\n                    {\n                        //send the file data to the client\n                        ps.write( buff );\n\n                    }\n                    System.out.println(\"Transfer complete.\");\n                    ps.flush();\n                    ps.close();\n                    break;\n\n             }\n                else{\n\n                    System.out.println(\"Request is wrong\");\n                    System.exit(0);\n\n\n                }\n\n        }\n\n\n        os.flush();\n        //Close the outputstream\n        os.close( );\n        //Close the inputstream\n        is.close( );\n        //Close the socket\n        s.close( );\n    } catch ( Exception e )\n    {\n    //Catch the exception\n        e.printStackTrace( );\n    }\n\n}\n\n/* \n * Function：Get the filename from the request which is sent from the client\n * param：The request from the client has to start with\"Send\"\n * Return: The filename\n */\nprivate String getFileName( String revStr )\n{\n    String fileName;\n    fileName = revStr.substring( 4 );\n    while ( fileName.startsWith( \" \" ) )\n    {\n        fileName = fileName.substring( 1 );\n    }\n    return fileName;\n}\n\npublic static void server()\n{\n    System.out.println( \"This is server\" );\n    try\n    {\n        ServerSocket ss = new ServerSocket( PORT );\n        int count = 0;\n        while ( true )\n        {\n            //Create a socket for waiting for the client connect\n            Socket s = ss.accept( );\n            //Count the client and print out\n            count++ ;\n            System.out.println( \"This is the \" + count + \"'st client connetion!\" );\n            //Start new thread for this socket\n            new Thread(new SendFileSocket(s)).start();\n\n        }\n    } catch ( Exception ex )\n    //Catch the exception\n    {\n        ex.printStackTrace( );\n    }\n}\n", "\n\n", "}", "\n\n", "[/code]"]], "Tag": "算法设计"}
{"Answer": "[quote]恩 有点明白了，貌似传的时候有一定的格式，有一些token和一些  boundary分隔符之类的数据，是这样的吗？    请继续指教    我该怎么在http里接受post过来的图片另存呢[/quote]\r\n不好意思,最近比较忙,没有及时答复\r\n\r\n我做了一个简单的实验, 下面列出代码, 这些代码在我机器上运行能得到正确的效果:\r\n1) 使用 WireShark 可以接获 POST 数据, 如下图\r\n[img]http://dl.iteye.com/upload/picture/pic/66426/057aae68-eba3-3ba3-99f0-72eaece03198.jpg[/img]\r\n\r\n这里截获的是人人网上传照片的POST数据, 从图片可以看出 POST Image 数据的一些基本格式\r\n\r\n2) 但是这个格式是抽象好的, 我就通过代码打印出 POST 的数据, 然后针对性地分析这些数据, 得到正确的图片, 主要代码如下:\r\n\r\nprivate void doFileUpload(HttpServletRequest request,\r\n\t\t\tHttpServletResponse response) \r\n\tthrows IOException {\r\n\t\tString tempFile = String.format(\"%s%d.jpg\", fileRoot, new Random().nextInt());\r\n\t\tlogger.debug(\"file name:\" + tempFile);\r\n\t\tlogger.debug(\"before transferring bytes in Servlet\");\r\n\t\tFile file = new File(tempFile);\r\n\t\tlogger.debug(\"file path: \" + file.getAbsolutePath());\r\n\t\tlogger.debug(\"file size: \" + file.length());\r\n\t\t\r\n\t\tOutputStream outputStream = new FileOutputStream(file);\r\n\t\tbyte[] bytes = new byte[1024];\r\n\t\tint count = -1;\r\n\t\tServletInputStream in = request.getInputStream();\r\n\t\tString line = null;\r\n\t\tboolean flag = false;\r\n\t\twhile ((count = in.read(bytes)) &gt; 0) {\r\n\t\t\tint start = 0;\r\n\t\t\t\r\n\t\t\tline = new String(bytes, 0, count);\r\n\t\t\tlogger.debug(\"get bytes: \" + count);\r\n\t\t\tlogger.debug(line);\r\n\t\t\tif (line.startsWith(\"-----------------------------\")) {\r\n\t\t\t\tint ndxContentDisp = line.indexOf(\"Content-Disposition\");\r\n\t\t\t\tint ndxContentType = line.indexOf(\"Content-Type\", ndxContentDisp);\r\n\t\t\t\tif (-1 != ndxContentDisp &amp;&amp; -1 != ndxContentType) {\r\n\t\t\t\t\tflag = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tflag = false;\r\n\t\t\t\t}\r\n\t\t\t\tstart = line.indexOf(\"\\r\\n\", ndxContentType);\r\n\t\t\t\tstart = start + 4;\r\n\t\t\t\tlogger.debug(\"****** flag of start *******: \" + flag + \", start index: \" + start);\r\n\t\t\t} else if (line.startsWith(\"Content-Disposition\")) {\r\n\t\t\t\tflag = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t} else if (line.startsWith(\"Content-Type\")) {\r\n\t\t\t\tflag = true;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (flag) {\r\n\t\t\t\toutputStream.write(bytes, start, count - start);\r\n\t\t\t}\r\n\t\t}\r\n\t\toutputStream.flush();\r\n\t\toutputStream.close();\r\n\t\tlogger.debug(\"after transferring bytes in Servlet\");\r\n\t}\r\n\r\n\r\n客户端页面代码很简单, 如下\r\n\r\n&lt;form action=\"up.do\" method=\"POST\" enctype=\"multipart/form-data\" name=\"upForm\"&gt;\r\n&lt;input type=\"file\" name=\"picPath\" /&gt;\r\n&lt;input type=\"submit\" name=\"submitBtn\" value=\"submit\" /&gt;\r\n&lt;/form&gt;\r\n\r\n\r\n在 2) 的代码中, 我很有针对性地处理了 POST 的数据, 其中图片的数据是包含在一定的边界之中的, 并非InputStream的所有数据. 分清楚这个边界, 取得正确的图片数据, 就能得到正确的结果.\r\n\r\n具体的 POST multipart 数据的格式, 还要参考 HTTP Protocol 的对应部分: http://www.ietf.org/rfc/rfc2388.txt\r\n\r\n使用 Apache FileUpload 组件, 可以省去处理这些处理细节", "Konwledge_Point": "网络中的流", "Question": ["网络传输文件丢字节的问题", ["碰到一个奇怪的问题， 用客户端程序向服务端servlet传输图片文件的时候，总是丢失字节数， 收到的字节数组变小了。发送之前统计的是 229237字节   服务端收到的却是 229056字节", "\n\n", "在服务端保存之后，保存之后的图片文件无法打开。 不知各位是否碰到这种问题。", "\n\n", "客户端代码", "\n\n", "[code=\"java\"]String url =\"", "http://127.0.0.1/api?photo_type=jpg", "\";", "\n\n", "    try {\n     URL dataUrl = new URL(url);\n     HttpURLConnection con = (HttpURLConnection) dataUrl.openConnection();\n     con.setRequestMethod(\"POST\");\n     con.setRequestProperty(\"Proxy-Connection\", \"Keep-Alive\");\n     con.setDoOutput(true);\n     con.setDoInput(true);\n     OutputStream os=con.getOutputStream();\n     FileInputStream in = new java.io.FileInputStream(\"c:\\\\test.jpg\");  \n     byte[] bt = new byte[1024];  \n     while ((count = in.read(bt)) > 0) {  \n         os.write(bt, 0, count);  \n         os.flush();\n\n     }  \n     in.close();  \n     os.flush();\n     os.close(); \n     InputStream is=con.getInputStream();\n     DataInputStream dis=new DataInputStream(is);\n     byte d[]=new byte[dis.available()];\n     dis.read(d);\n\n     con.disconnect();\n    } catch (Exception ex) {\n     ex.printStackTrace();\n    }[/code]\n", "\n\n", "服务端代码：", "\n [code=\"java\"]try {", "\n\n", "        long randomPre = System.currentTimeMillis();\n        Random rand = new Random();\n        fileTemp = fileTemp + String.valueOf(randomPre) + \"_\" + rand.nextInt() + \".\" + photo_type;\n        outputStream = new FileOutputStream(new File(fileTemp));\n        byte[] bytes = new byte[1024];\n        int v;\n        while ((v = request.getInputStream().read(bytes)) > 0) {\n            outputStream.write(bytes, 0, v);\n\n        }\n        outputStream.flush();\n        outputStream.close();\n\n\n    } catch (Exception ex) {\n        ex.printStackTrace(System.err);\n    }[/code]\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;要在Linux嵌入式开发板上进行实时视频流的推拉&amp;#xff0c;您可以使用常见的视频编码格式&amp;#xff08;如H.264或H.265&amp;#xff09;&amp;#xff0c;使用开源的多媒体框架&amp;#xff08;如GStreamer或FFmpeg&amp;#xff09;来编写应用程序。&lt;/p&gt;\n&lt;p&gt;在推流方面&amp;#xff0c;您可以使用视频采集设备&amp;#xff08;如USB摄像头&amp;#xff09;来获取视频数据&amp;#xff0c;将其编码为所需的格式&amp;#xff0c;并使用网络协议&amp;#xff08;如RTMP或HTTP&amp;#xff09;将其推送到视频服务器。GStreamer和FFmpeg都提供了编写此类应用程序的功能。&lt;/p&gt;\n&lt;p&gt;在拉流方面&amp;#xff0c;您可以使用网络协议&amp;#xff08;如RTMP或HTTP&amp;#xff09;从视频服务器上获取视频数据&amp;#xff0c;并使用GStreamer或FFmpeg解码视频数据&amp;#xff0c;并使用视频播放器&amp;#xff08;如VLC或MPlayer&amp;#xff09;将其实时播放。&lt;/p&gt;\n&lt;p&gt;要确保视频流在任意网络内都能进行拉流&amp;#xff0c;您需要确保视频服务器具有公共IP地址或DNS可解析名称&amp;#xff0c;并且将其设置为开放式的防火墙策略&amp;#xff0c;以允许来自任意网络的流量。同时&amp;#xff0c;您可以使用流媒体服务器&amp;#xff08;如Wowza Streaming Engine或Nginx-RTMP&amp;#xff09;来提高视频流的可靠性和质量&amp;#xff0c;并确保视频流的延迟时间不超过1秒。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["如何使用Linux嵌入式开发板平台上，进行实时视频流的推拉，并且在任意网络内都能进行视频流的拉流，同时视频流的延时时间不超过1秒", ["如何使用Linux嵌入式开发板平台上，进行实时视频流的推拉，并且在任意网络内都能进行视频流的拉流，同时视频流的延时时间不超过1秒？"]], "Tag": "算法设计"}
{"Answer": "我公司是做工业相机的，也提供一些类似接口，姑且在这里说一下。\r\n海康是家大公司，提供的接口说明和支持应该是很完善的，你不用担心接口不合理。\r\n那么从一般来说，你现在是根据相机的ip端口返回了一个userID，那么如果是多台，你只要根据各个相机的ip端口返回不同的userID，就可以分别操作各录像机了，之后如何进行操作就是你的程序问题了，你可以试试。\r\n如果有不明确的，找到海康的联系方式，对方应该会安排技术人员，对接口给你进行完整的解释，但我推荐你先看看说明书和demo自己试试。", "Konwledge_Point": "网络中的流", "Question": ["C#海康威视网络硬盘录像机开发 做监控页面", ["菜鸡第一次做二次开次，按照官方手册的逻辑,在视频预览传入的参数是调用登录函数返回的userID,登录的函数用的是录像机的ip+端口，那此刻能预览的就是一路画面吗，如果是多个摄像头一台录像机，如何取到连接到硬盘录像机的所有摄像头列表，并预览，SDK", "\n中没有获取摄像头列表的函数，求大神赐教"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The user's webcam stream is on the &lt;em&gt;client-side&lt;/em&gt; and the problem is getting that stream from each client to your server so having FFmpeg on the server won't help you a lot.&lt;/p&gt;\n\n&lt;p&gt;This is achieved by using some form of browser plugin, like &lt;strong&gt;Flash&lt;/strong&gt; or &lt;strong&gt;Silverlight&lt;/strong&gt; and hopefully in a near future using directly &lt;a href=\"http://www.html5rocks.com/en/tutorials/getusermedia/intro/\" rel=\"nofollow\"&gt;HTML5 / WebRTC&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;For Wowza you can use the &lt;strong&gt;FlashRTMPPlayer&lt;/strong&gt; . Here's the documentation showing &lt;a href=\"http://www.wowza.com/resources/3.6.0/examples/WebcamRecording/FlashRTMPPlayer/player.html\" rel=\"nofollow\"&gt;how to record a webcam feed&lt;/a&gt; and how to setup a &lt;a href=\"http://www.wowza.com/forums/content.php?42-How-to-set-up-live-video-chat\" rel=\"nofollow\"&gt;live video chat application&lt;/a&gt; which is probably a good starting point for your live streaming application.&lt;/p&gt;\n\n&lt;p&gt;There are some other libraries that can do the same. Search for webcam Flash RTMP capture.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "网络中的流", "Question": ["使用FFMPEG将实时网络摄像头AV源传输到wowza", ["\n\n", "I have been trying to find out how to live stream my webcam feed to my wowza server. I am trying to make a web application in php that lets users stream live video through their webcam.", "\n\n", "I am confused, if i need to install FFMPEG in every user's computer that uses my application or just installing it in my web server will do??", "\n\n", "Thank you in advance. A little help would be much appreciated.", "\n    "]], "Tag": "算法设计"}
{"Answer": "难道不同JRE传输数据会先传0xFFFE？\r\n怀疑是这个问题，导致UTF-8无法解析，使用了替换符\r\n\r\n请跟踪一下客户端，看看前两个字节是否为0xFFFE", "Konwledge_Point": "网络中的流", "Question": ["socket通信中多收到了字符 \\ufffd", ["我的程序是一个基于socket的即时群聊系统", "\n\n", "客户端和服务器socket都是用utf-8编码。客户端和服务器在同一台机器上测试的时候，完全正常。当分开时，客户端本来应该收到hello这个单词，现在却多收到了两个字符 \\ufffd\\ufffd", "\n\n", "eclipse中编译时设置了utf-8.", "\n\n", "这是服务端的流：", "\nOutputStreamWriter stream = new OutputStreamWriter(", "\nsocket.getOutputStream(), \"UTF8\");", "\npw = new PrintWriter(stream);", "\nbr = new BufferedReader(new InputStreamReader(", "\nsocket.getInputStream(), \"UTF8\"));", "\n这是客户端的流：", "\nBufferedReader br = new BufferedReader(new InputStreamReader(", "\n  clientSocket.getInputStream(), \"UTF-8\"));", "\n\n", "OutputStreamWriter stream = new OutputStreamWriter(clientSocket.getOutputStream(), \"UTF-8\");", "\n\n", "服务端发送的消息是：", "\n\n", "pw.println(\"hello\");", "\npw.flush();", "\n\n", "客户端收到的是 \\ufffd\\ufffdhello"]], "Tag": "算法设计"}
{"Answer": "确定是日志文件的问题？ 我Java不太熟， 但至少读写文件不会出SocketException应该是肯定的吧？", "Konwledge_Point": "网络中的流", "Question": ["Log4J中Logger如何关闭IO流", ["在项目由于日志需要对日志进行扩展，根据交易号和日期生成logger对象放入队列中，每天会清除之前的日志对象，刚开始没有发现问题，大约到了1个月左右，生产中报了java.net.SocketException：too many open files异常，首先整个系统中除了日志外，只有读取配置文件的两个本地IO操作，其他的是网络IO，其次在早上没有大规模并发请求，除了心跳报文外，其他无请求，综合上述可以将问题定位在日志上。仔细想每天我只是把日志对象从Hashtable中remove了，但是被remove的Logger对象并未立刻被GC，我想在remove后，将Logger中IO资源立即释放，求高手指点。"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/ying1979/article/details/10976259\r\naxShockwaveFlash1.Movie = swf_path; 这里指向你的flv", "Konwledge_Point": "网络中的流", "Question": ["winform如何嵌入播放器播放网络视频flv", ["我希望在我的winform程序中嵌入一个播放器，且能播放网络上的流媒体文件，请好心人帮帮忙，急！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;【1】做底层tcp转发映射&amp;#xff0c;像局域网一样的方式访问摄像头 &amp;#xff08;流畅&amp;#xff0c;稳定&amp;#xff0c;技术难度高&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【2】花生壳&amp;#xff0c;这些内网穿透工具&amp;#xff0c;目前主流的摄像头都支持花生壳透传&amp;#xff08;简单&amp;#xff0c;付费&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【3】自行搭建推流nginx/node&amp;#43;ffmpeg推流,网上也有很多开源直接拿来用&amp;#xff08;有延时&amp;#xff0c;有技术门槛但不高&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【4】对接第三方云&amp;#xff08;难度&amp;#xff1a;1&amp;#43;1&amp;#61;2的计算&amp;#xff09;&lt;/p&gt;\n\n&lt;p&gt;【5】另外和你需要输出的视频流格式有关&amp;#xff0c;rtsp不适合浏览器播放&amp;#xff0c;hls适合&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["外网如何访问内网摄像头", ["背景：有一个A7嵌入式平台，双网口。一个接网络摄像头，摄像头提供rtsp流。另一个接4g模块，4g模块可以访问互联网。公司在公网上自己搭了一个视频服务器。", "\n\n", "如何让服务器能访问摄像头？尝试过使用ffmpeg推流的方案，不太稳定。"]], "Tag": "算法设计"}
{"Answer": "同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。\r\n而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。", "Konwledge_Point": "网络中的流", "Question": ["网络编程中阻塞式IO的真正含义到底是什么", ["这两天在看socket编程，可以说这方面是个新手，其中看到了nio，网上有很多文章介绍了nio相对于多线程处理网络链接（每建立一个socket链接，服务器便会开启一个线程来对此socket单独处理和客户端的通信）的优点。因为nio是事件驱动，不会发生Socket读取流数据时的阻塞。我想问的是这里所说的读取流数据的阻塞是我们平时所说的线程进入阻塞态吗？", "\n\n", "当一个线程单独处理一个客户端请求时，它需要等待客户端向它的输出流写入数据，完后服务器端处理此socket的线程才能读取数据，如果客户端未写入数据，那么服务器端线程便会一直停留在对流的读取状态，即调用流的read()方法，我感到疑惑的是当客户端未写入数据而服务器端正在进入read()读取数据时，服务器端处理的这个线程是由运行态进入阻塞态了还是说一直在read()方法循环检测流中的数据（这样的话线程仍然在运行态），网上的很多表达让我对它们产生了很大的疑惑，关于网络中流的读取写入本人还是个新手，这可能涉及到更底层的一些东西，希望有人能够给指点一下。", "\n\n", "我也看了java的源码，当流读取时，是进入一个 for(;;)的死循环。所以我认为是这个线程并没有进入阻塞态，而是一直循环在检测输入流的数据，一旦有数据便会从read()返回，不知道理解的对还是不对？", "\n\n", "以下是服务器端的代码：", "\n[code=\"java\"]    import java.io.*;", "\n    import java.net.*;", "\n    public class Server{", "\n        public static void main(String args[]) {", "\n           ServerSocket server=null;", "\n            try{", "\n                server=new ServerSocket(4700);", "\n            //创建一个ServerSocket在端口4700监听客户请求(已经建立监听)", "\n            }catch(Exception e) {", "\n                System.out.println(\"can not listen to:\"+e);", "\n            //出错，打印出错信息", "\n            }", "\n            Socket socket=null;", "\n            try{", "\n                while(true){", "\n                    socket=server.accept();", "\n                    //使用accept()阻塞等待客户请求，", "\n                    //请求到来则产生一个Socket对象，并继续执行", "\n                    Thread t = new Thread(new Processor(socket));", "\n                    t.start();", "\n                }", "\n            }catch(Exception e) {", "\n                System.out.println(\"Error.\"+e);", "\n            }", "\n        }", "\n    }", "\n\n", "class Processor implements Runnable{\n    private Socket socket;      \n    public Processor(Socket socket){\n        this.socket = socket;\n    }       \n    public void run() {\n        try{\n            String line;\n            BufferedReader is=new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            //由Socket对象得到输入流，并构造相应的BufferedReader对象\n            PrintWriter os=new PrintWriter(socket.getOutputStream());\n            //由Socket对象得到输出流，并构造PrintWriter对象\n            BufferedReader sin=new BufferedReader(new InputStreamReader(System.in));\n            //由系统标准输入设备构造BufferedReader对象\n            System.out.println(\"Client:\"+is.readLine());\n            //在标准输出上打印从客户端读入的字符串\n            line=sin.readLine();\n            //从标准输入读入一字符串\n            while(!line.equals(\"bye\")){\n            //如果该字符串为 \"bye\"，则停止循环\n                os.println(line);\n                //向客户端输出该字符串\n                os.flush();\n                //刷新输出流，使Client马上收到该字符串\n                System.out.println(\"Server:\"+line);\n                //在系统标准输出上打印读入的字符串\n                System.out.println(\"Client:\"+is.readLine());\n                //从Client读入一字符串，并打印到标准输出上\n                line=sin.readLine();\n                //从系统标准输入读入一字符串\n            } //继续循环\n            os.close(); //关闭Socket输出流\n            is.close(); //关闭Socket输入流\n            socket.close(); //关闭Socket\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n}[/code] \n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;按道理没有问题&amp;#xff0c;有没有调用flush方法呢&amp;#xff1f;具体要看代码。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["关于JAVA缓冲字节流的一个小问题", ["网络编程的时候使用缓冲字节流传输照片时没有问题，但是用同一方法传输文本文件时分，复制过去的文本却没有内容(用同一方法将缓冲字节流变成缓冲字符流时却不出现这个问题)，这是什么问题呢？是使用破解版Idea的原因吗？？"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_41822235/article/details/84944700", "Konwledge_Point": "网络中的流", "Question": ["Java网络编程，多线程，C/S模式", ["1.会结账的服务器，使用多线程编写一个C/S模式的结账程序。 实验要求如下：", "\na)参照教材例16-6，编写两个类Client.java(包含main方法)和Server.java(包含main方法)。客户端和服务器建立套接字连接后，客户将如下格式的账单发送给服务器：", "\n\"房租:2189元 水费:112.9元 电费:569元 物业费:832元\"", "\n\n", "服务器接收客户端所发生的信息，计算总费用，并将总费用返回给客户，返回的信息格式如下：", "\n您的账单：", "\n\"房租:2189元 水费:112.9元 电费:569元 物业费:832元", "\n总计：3699.9元", "\n\n", "b)为服务器编写ServerThread.java线程类。在服务器端，服务器循环监听客户端连接呼叫，与客户端建立连接后，创建并启动ServerThread线程为客户端提供结账服务。", "\n\n", "c)使用DataInputStream类作为输入流接收数据(读)，使用方法如下：", "\nString readUTF();       //读入一个已使用UTF-8修改版格式编码的字符串", "\n\n", "d)使用DataOutputStream类作为输出流进行发送数据，使用方法如下：", "\nvoid writeUTF(String str);  //以机器无关的的方式用UTF-8修改版将一个字符串写到基本输出流。"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/yuanbinquan/article/details/51468886", "Konwledge_Point": "网络中的流", "Question": ["linux多网卡及多拨号的问题", ["1.环境", "\nUBUNTU16.04 64bit", "\n6个网卡（5个作为输入，1个作为输出）", "\n\n", "问题1：实现可指定5个输入网卡中的任意一个接收指定的任意源", "\n         即网卡1接收网络流1", "\n                 即网卡2接收网络流2", "\n                 即网卡3接收网络流3", "\n                 即网卡4接收网络流4", "\n                 即网卡5接收网络流5", "\n问题2：实现可指定5个输入网卡可分别同时拨号", "\n         即网卡ppo1接收网络流1", "\n                 即网卡ppo2接收网络流2", "\n                 即网卡ppo3接收网络流3", "\n                 即网卡ppo4接收网络流4", "\n                 即网卡ppo5接收网络流5", "\n\n", "1个网卡拨号很容易实现，但多个同时拨号完全没方向。有大神搞过这一块，能给点方向么？拜谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;Uncaught 的错误是你没引用Message这个组件&amp;#xff0c;引用一下就好了。&lt;br /&gt;至于post还是get&amp;#xff0c;你这个地方写的要一致&amp;#xff0c;调用的时候写的Methods&amp;#xff0c;封装的时候写的Method&amp;#xff0c;要仔细一点啊&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在前端调用的是get请求，postman上面测试能够从接口获取数据，但是浏览器返回post失败", ["问题遇到的现象和发生背景", "\n", "在前端调用的是get请求，postman上面测试能够从接口获取数据，但是浏览器返回post失败。", "\n", "问题相关代码，请勿粘贴截图", "\n", "后端代码：", "\n", "/* 获取管理员列表 */", "static getAdminList(){", "  return new Promise((resolve,reject)=>{", "    let sql = \"select * from myusers_db where type=3\"", "    this.query(sql).then(result=>{", "      console.log(result)", "      resolve(result)", "    }).catch(err=>{", "      console.log(\"数据读取失败\")", "      reject(\"数据读取失败了！\")", "    })", "  })", "}", "\n", "/* 获取管理员列表 */", "static async getAdminListMsg(req,resp){", "  let body = req.body", "  let adminData = await this.getAdminList()", "  if(adminData.length!=0){", "    console.log(\"读取管理员数据成功\")", "    resp.send(adminData)", "  } else{", "    console.log(adminData)", "    console.log(adminData.length)", "    resp.status(500).send(\"读取管理员数据失败\")", "  }", "}", "\n", "/* 获取管理员列表接口 */", "router.get('/getadminlistmsg',function(req,res){", "  user.getAdminListMsg(req,res)", "})", "\n", "前端代码：", "封装的axios", "/**", "\n", "//封装axios方法,为不需要登录操作时使用", "@param ", "options 配置", "/", "let Axios=(options)=>{", "  axios({", "  url:options.url,\n  ", "method", ":", "options.method||", "'POST'", ",\n  data: options.data,\n  ", "params", ": options.data\n", "\n", "  }).then(result=>{", "console.", "log", "(", "\"成功进入axios\"", ")\n  ", "if", " (", "options", ".success)  ", "options", ".success(result.data)\n", "\n", "  }).catch(err=>{", "  let msg = err.response ? err.response.data:", "'请求异常'", "\n  ", "if", " (", "options", ".", "error", "){\n      ", "options", ".", "error", "(msg)\n      ", "Message", ".", "error", "({", "message", ": msg, offset: 150});\n  }", "else", " {\n      ", "Message", ".", "error", "({", "message", ": msg, offset: 150});\n  }\n", "\n", "  })", "}", "\n", "Vue.prototype.$axios = Axios", "\n", "前端页面在created获取数据：", "  created () {", "    this.$axios({", "      url:'/users/getadminlistmsg',", "      methods:'GET',", "      data:{},", "      success:(result)=>{", "        this.id = result.id", "        this.type = \"管理员\"", "        username = result.username", "      }", "    })", "  },", "\n", "运行结果及报错内容", "\n", "浏览器返回：", "POST ", "http://localhost:3000/users/getadminlistmsg", " 404 (Not Found)", "\n", "Uncaught (in promise) ReferenceError: Message is not defined", "    at eval.", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我尝试把后端改成post（用postman测试，依然可以得到数据），然后前端不出现POST404了，但是拿不到数据，还是显示后面Uncaught的错误", "\n", "我想要达到的结果"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  // 视频流延迟&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        setInterval(() &amp;#61;&amp;gt; {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;          if (this.flvPlayer.buffered.length) {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            let end &amp;#61; this.flvPlayer.buffered.end(0); //获取当前buffered值&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            let diff &amp;#61; end - this.flvPlayer.currentTime; //获取buffered与currentTime的差值&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            if (diff &amp;gt;&amp;#61; 0.5) {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;              //如果差值大于等于0.5 手动跳帧 这里可根据自身需求来定&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;              this.flvPlayer.currentTime &amp;#61; this.flvPlayer.buffered.end(0); //手动跳帧&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;          }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }, 2000);&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/528292587766171.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;添加这段处理延迟代码手动跳帧就会转圈圈&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["前端播放flv处理延迟手动跳帧后一直转圈圈", ["flv播放处理延迟手动跳帧后一直转圈圈怎么办？", "\n", "\n", "<", "template", ">", "\n  ", "<", "div", " ", "class", "=", "\"flv_time\"", ">", "\n    ", "<", "div", " ", "class", "=", "\"flv_title\"", ">", "{{", "title", "}}", "</", "div", ">", "\n    ", "<", "video", " ", "ref", "=", "\"my-video\"", " ", ":id", "=", "\"'dplayer'+this.num\"", " ", "controls", " ", "autoplay", " ", "muted", ">", "</", "video", ">", "\n  ", "</", "div", ">", "\n", "</", "template", ">", "\n\n", "<", "script", ">", "\n", "import", " flvjs ", "from", " ", "\"flv.js\"", ";\n", "export", " ", "default", " {\n  ", "props", ": [", "\"videoUrl\"", ", ", "\"num\"", ", ", "\"title\"", "],\n  ", "data", "(", ") {\n    ", "return", " {\n      ", "flvPlayer", ": ", "null", "\n    };\n  },\n  ", "watch", ": {\n    ", "// idPass: {", "\n    ", "//   handler(newRoom, oldRoom) {", "\n    ", "//     // console.log(this.idPass, \"变动id的值\");", "\n    ", "//   this.update();", "\n    ", "//   },", "\n    ", "//   deep: true", "\n    ", "// },", "\n  },\n  ", "mounted", "(", ") {\n    ", "setTimeout", "(", "() =>", " {\n      ", "// console.log(this.videoUrl, \"路径\");", "\n      ", "this", ".", "startPlay", "();\n    }, ", "2000", ");\n  },\n  ", "beforeDestroy", "(", ") {\n    ", "this", ".", "destoryVideo", "();\n  },\n  ", "methods", ": {\n    ", "startPlay", "(", ") {\n      ", "console", ".", "log", "(", "this", ".", "videoUrl", ", ", "this", ".", "num", ", ", "\"路径\"", ");\n      ", "if", " (flvjs.", "isSupported", "()) {\n        ", "// ->注意：这里的定时器，在中断视频时，要清理哦", "\n        ", "const", " videoElement = ", "document", ".", "getElementById", "(", "\"dplayer\"", " + ", "this", ".", "num", ");\n        ", "this", ".", "flvPlayer", " = flvjs.", "createPlayer", "(\n          {\n            ", "type", ": ", "\"flv\"", ", ", "//指定视频类型", "\n            ", "isLive", ": ", "true", ", ", "// 开启直播", "\n            ", "hasAudio", ": ", "false", ", ", "// 关闭声音", "\n            ", "url", ": ", "this", ".", "videoUrl", " ", "// 指定流链接", "\n          },\n          {\n            ", "autoCleanupSourceBuffer", ": ", "true", ", ", "//对SourceBuffer进行自动清理缓存", "\n            ", "autoCleanupMaxBackwardDuration", ": ", "120", ", ", "//    当向后缓冲区持续时间超过此值（以秒为单位）时，请对SourceBuffer进行自动清理", "\n            ", "autoCleanupMinBackwardDuration", ": ", "60", ", ", "//指示进行自动清除时为反向缓冲区保留的持续时间（以秒为单位）。", "\n            ", "enableStashBuffer", ": ", "false", ", ", "//关闭IO隐藏缓冲区", "\n            ", "reuseRedirectedURL", ": ", "true", ", ", "//重用301/302重定向url，用于随后的请求，如查找、重新连接等。", "\n            ", "stashInitialSize", ": ", "128", "\n          }\n        );\n        ", "this", ".", "flvPlayer", ".", "attachMediaElement", "(videoElement);\n        ", "// 非空判断是否执行流", "\n        ", "if", " (", "this", ".", "videoUrl", " !== ", "\"\"", " && ", "this", ".", "videoUrl", " !== ", "null", ") {\n          ", "this", ".", "flvPlayer", ".", "load", "();\n          ", "this", ".", "flvPlayer", ".", "play", "();\n        }\n        ", "// 视频流延迟", "\n        ", "setInterval", "(", "() =>", " {\n          ", "if", " (", "this", ".", "flvPlayer", ".", "buffered", ".", "length", ") {\n            ", "let", " end = ", "this", ".", "flvPlayer", ".", "buffered", ".", "end", "(", "0", "); ", "//获取当前buffered值", "\n            ", "let", " diff = end - ", "this", ".", "flvPlayer", ".", "currentTime", "; ", "//获取buffered与currentTime的差值", "\n            ", "if", " (diff >= ", "0.5", ") {\n              ", "//如果差值大于等于0.5 手动跳帧 这里可根据自身需求来定", "\n              ", "this", ".", "flvPlayer", ".", "currentTime", " = ", "this", ".", "flvPlayer", ".", "buffered", ".", "end", "(", "0", "); ", "//手动跳帧", "\n            }\n          }\n        }, ", "2000", ");\n        ", "// 断流重连", "\n        ", "this", ".", "flvPlayer", ".", "on", "(flvjs.", "Events", ".", "ERROR", ", ", "(", "errType, errDetail", ") =>", " {\n          ", "// alert(\"网络波动,正在尝试连接中...\");", "\n          ", "console", ".", "log", "(", "\"网络波动,正在尝试连接中...\"", ", ", "this", ".", "flvPlayer", ", ", "\"视频状态\"", ");\n          ", "if", " (", "this", ".", "flvPlayer", ") {\n            ", "this", ".", "reloadVideo", "(", "this", ".", "flvPlayer", ");\n          }\n          ", "// 断流销毁掉视频  方案2", "\n          ", "// if (errType == \"NetworkError\") {", "\n          ", "//   console.log('销毁掉视频');", "\n          ", "//   this.destoryVideo();", "\n          ", "// }", "\n          ", "// errType是 NetworkError时，对应errDetail有：Exception、HttpStatusCodeInvalid、ConnectingTimeout、EarlyEof、UnrecoverableEarlyEof", "\n          ", "// errType是 MediaError时，对应errDetail是MediaMSEError   或MEDIA_SOURCE_ENDED", "\n        });\n        ", "// 画面卡死", "\n        ", "this", ".", "flvPlayer", ".", "on", "(", "\"statistics_info\"", ", ", "function", "(", "res", ") {\n          ", "// console.log(res, \"画面卡死了\");", "\n          ", "let", " lastDecodedFrame = ", "0", ";\n          ", "if", " (lastDecodedFrame == ", "0", ") {\n            lastDecodedFrame = res.", "decodedFrames", ";\n            ", "return", ";\n          }\n          ", "if", " (lastDecodedFrame != res.", "decodedFrames", ") {\n            lastDecodedFrame = res.", "decodedFrames", ";\n          } ", "else", " {\n            lastDecodedFrame = ", "0", ";\n            ", "if", " (", "this", ".", "flvPlayer", ") {\n              ", "this", ".", "reloadVideo", "(", "this", ".", "flvPlayer", ");\n            }\n          }\n        });\n      } ", "else", " {\n        ", "console", ".", "log", "(", "\"flvjs不支持\"", ");\n      }\n    },\n\n    ", "// 执行销毁 后在创建", "\n    ", "reloadVideo", "(", "flvPlayer", ") {\n      ", "this", ".", "destoryVideo", "(flvPlayer);\n      ", "this", ".", "startPlay", "();\n    },\n    ", "destoryVideo", "(", "flvPlayer", ") {\n      ", "this", ".", "flvPlayer", ".", "pause", "();\n      ", "this", ".", "flvPlayer", ".", "unload", "();\n      ", "this", ".", "flvPlayer", ".", "detachMediaElement", "();\n      ", "this", ".", "flvPlayer", ".", "destroy", "();\n      ", "this", ".", "flvPlayer", " = ", "null", ";\n    }\n  }\n};\n", "</", "script", ">", "\n\n", "<", "style", " ", "lang", "=", "\"less\"", " ", "scoped", ">", "\n", ".flv_time", " {\n  ", "width", ": ", "100%", ";\n  ", "height", ": ", "100%", ";\n  ", "position", ": relative;\n  ", ".flv_title", " {\n    ", "width", ": ", "100%", ";\n    ", "height", ": ", "28px", ";\n    ", "font-family", ": ", "\"PingFang SC\"", ";\n    ", "font-size", ": ", "14px", ";\n    ", "line-height", ": ", "28px", ";\n    ", "position", ": absolute;\n    ", "top", ": ", "0", ";\n    ", "text-indent", ": ", "35px", ";\n    ", "color", ": ", "#ffffff", ";\n    ", "background", ": ", "rgba", "(", "0", ", ", "0", ", ", "0", ", ", "0.4", ");\n  }\n  ", "video", " {\n    ", "width", ": ", "100%", ";\n    ", "height", ": ", "100%", ";\n  }\n}\n", "</", "style", ">", "\n\n", "\n"]], "Tag": "算法设计"}
{"Answer": "我被这上问题困扰了很久，后来发现如果调整下路由的MTU值到1472就没问题，只要超过1472就会有问题，后面各种排查，最后更换了光猫问题得到解决。\r\nhttp://www.sohu.com/a/158388912_262201\r\nhttps://yq.aliyun.com/articles/222535", "Konwledge_Point": "网络中的流", "Question": ["提交请求后台（javaweb tomcat）无法获取参数", ["这是一个让我崩溃的问题：", "\n这个问题发生在一个平板电脑A上，用这个平板A提交数据（ajax的POST/GET和from表单）只要内容长度超过1440个字符请求到后台服务", "\n会阻塞可能几十秒，然后我在后台什么参数也获取不到，但用另一个平板电脑B（其它品牌）的话可以正常提交，这时两台平板在同一网络环境N。下面是我处理的过程", "\n1、平板A直接连接我手机热点，提交正常。但只要切换回网络就是不行，平板B怎么都是正常的。", "\n2、让平板A连接上fiddler4软件的代理，查看网络请求，这时候提交又正常。网络还是使用的之前提交不了的网络。", "\n3、然后我用nginx开了代理让平板A通过nginx提交OK。", "\n4、后台服务我更换过tomcat版本，平板A不能提交。", "\n5、后台服务我换为jetty,平板A不能提交。", "\n通过这些处理还是不知道问题在哪？但奇怪的是平板A上我上传文件到OSS上没有一点问题，但上传到我自己的后台服务就不行。心累！！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;6参考下&lt;a href=\"https://blog.csdn.net/yanxiaolx/article/details/53393437\"&gt;https://blog.csdn.net/yanxiaolx/article/details/53393437&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;代码如下&amp;#xff1a;{如果对你有帮助&amp;#xff0c;可以给我个采纳吗&amp;#xff0c;谢谢!! 点击我这个回答右上方的【采纳】按钮}。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#define  _CRT_SECURE_NO_WARNINGS\n \n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\n#include&amp;lt;string.h&amp;gt;\n#include&amp;lt;fstream&amp;gt;\n \nclass student\n{\nprivate:\n\tstudent* next;\npublic:\n\tchar stu_num[15];                  //学号\n\tchar stu_name[30];                //姓名\n\tfloat stu_score;                      //成绩\n \n\tvoid afterInsert(student *p);//在该节点后插入一个节点\n\tvoid afterDelete();//在该节点后删除一个节点\n\t\n\tstudent *getNext()//获得下一个节点的指针\n\t{ \n\t\treturn next; \n\t}\n \n\t/***********查询学生信息************/\n\tvoid getMage();\n \n\t/******学生信息修改******/\n\tvoid changeMage(int n, char *ptr);\n\tvoid changegrade(float p);\n \n\t/******构造*****/\n\tstudent(char *num, char *name, float score);\n\tstudent();\n};\n \nvoid student::changegrade(float p)\n{\n\tstu_score &amp;#61; p;\n}\n \nstudent::student()           //构造\n{\n\tstrcpy(stu_num, &amp;#34;\\0&amp;#34;);\n\tstrcpy(stu_name, &amp;#34;\\0&amp;#34;);\n\tstu_score &amp;#61; 0;\n\tnext &amp;#61; &amp;#39;\\0&amp;#39;;\n}\n \nstudent::student(char *num, char *name, float score)\n{\n\tstrcpy(stu_num, num);\n\tstrcpy(stu_name, name);\n\tstu_score &amp;#61; score;\n\tnext &amp;#61; &amp;#39;\\0&amp;#39;;\n}\n \nvoid student::afterInsert(student *p)//插入节点\n{\n\tp-&amp;gt;next &amp;#61; next;\n\tnext &amp;#61; p;\n}\n \nvoid student::afterDelete()        //删除节点\n{\n\tstudent *p &amp;#61; next;\n\tnext &amp;#61; p-&amp;gt;next;\n\tdelete p;\n}\n \nvoid student::getMage()             //获得信息\n{\n\tcout &amp;lt;&amp;lt; &amp;#34;学号&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_num &amp;lt;&amp;lt; &amp;#34;      姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_name;\n\tcout &amp;lt;&amp;lt; &amp;#34;      c&amp;#43;&amp;#43;成绩&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_score &amp;lt;&amp;lt; endl;\n}\n \nvoid student::changeMage(int n, char *ptr)\n{\n\tswitch (n)\n\t{\n\tcase 1: strcpy(stu_num, ptr); \n\t\tbreak;\n\tcase 2: strcpy(stu_name, ptr);\n\t}\n}\n \n//建立链表函数\nvoid  construct_list(student *tail)\n{\n\tstudent *p &amp;#61; new student;\n\tchar very[20];\n\tfloat achieve;\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入学号:&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; very;\n\tp-&amp;gt;changeMage(1, very);\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; very;\n\tp-&amp;gt;changeMage(2, very);\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入c&amp;#43;&amp;#43;成绩&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; achieve;\n\tp-&amp;gt;changegrade(achieve);\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;信息输入完毕&amp;#34; &amp;lt;&amp;lt; endl;\n \n\tfor (; tail-&amp;gt;getNext() !&amp;#61; &amp;#39;\\0&amp;#39;;)\n\t{\n\t\ttail &amp;#61; tail-&amp;gt;getNext();\n\t}\n \n\ttail-&amp;gt;afterInsert(p);\n}\n \n/*********查询信息*********/\nstudent *findmege(student *head)\n{\nloop:\n\tcout &amp;lt;&amp;lt; &amp;#34;1--按姓名查询           2--按学号查询              q--返回上一级菜单&amp;#34; &amp;lt;&amp;lt; endl;\n\tchar p[5], ptr[20];\n\tstudent *mid &amp;#61; head;\n\tcin &amp;gt;&amp;gt; p;\n \n\tif (p[0] !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;p[0] !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;p[0] !&amp;#61; &amp;#39;q&amp;#39; || strlen(p)&amp;gt;1)\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;你的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tgoto loop;\n\t}\n \n\tswitch (p[0])\n\t{\n\tcase &amp;#39;1&amp;#39;:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入要查找的姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ptr;\n \n\t\tfor (; strcmp(ptr, mid-&amp;gt;stu_name) !&amp;#61; 0; mid &amp;#61; mid-&amp;gt;getNext())\n\t\t{\n\t\t\tif (mid-&amp;gt;getNext() &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t\t{\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;你要查找的人不存在&amp;#xff0c;请确认你的输入是否正确&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\tcase &amp;#39;2&amp;#39;:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入您要查找的学号&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ptr;\n\t\tfor (; strcmp(ptr, mid-&amp;gt;stu_num) !&amp;#61; 0; mid &amp;#61; mid-&amp;gt;getNext())\n\t\t{\n\t\t\tif (mid-&amp;gt;getNext() &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t\t{\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;您要查找的内容不存在&amp;#xff0c;请确认您的输入是否正确&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\tcase &amp;#39;q&amp;#39;: \n\t{\n\t\treturn &amp;#39;\\0&amp;#39;;\n\t}\n\tdefault:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;您的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tgoto loop;\n\t}\n\t}\n}\n \n/******************删除链表 节点***********************/\nvoid delete_list(student *head)\n{\n\tstudent *p &amp;#61; &amp;#39;\\0&amp;#39;;\n\tchar selet[4];\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;在删除前&amp;#xff0c;系统会根据您的提示找到您要删除的学生信息&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\tp &amp;#61; findmege(head);\n\tif (p !&amp;#61; &amp;#39;\\0&amp;#39;)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;确认要删除吗&amp;#xff08;yes/任意键返回&amp;#xff09;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; selet;\n \n\t\tif (strcmp(selet, &amp;#34;yes&amp;#34;) &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tfor (; head-&amp;gt;getNext() !&amp;#61; p; head &amp;#61; head-&amp;gt;getNext());\n\t\t\thead-&amp;gt;afterDelete();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;该信息删除成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t}\n\t}\n}\n \n/*******************修改节点信息********************/\nvoid change_info(student *head)\n{\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;在您修改前&amp;#xff0c;系统会根据您提供的信息找的您要修改的信息&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tstudent *p &amp;#61; &amp;#39;\\0&amp;#39;;\n \n\tfloat achieve;\n\tp &amp;#61; findmege(head);\n\tif (p !&amp;#61; &amp;#39;\\0&amp;#39;)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入c&amp;#43;&amp;#43;成绩:&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; achieve;\n\t\tp-&amp;gt;changegrade(achieve);\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;修改成功!&amp;#34; &amp;lt;&amp;lt; endl;\n\t}\n \n}\n \n/**************输出学生成绩信息**************/\nvoid output(student *head)\n{\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;1-查看指定学生信息&amp;#xff1b;2-查看所有学生信息&amp;#xff1b;3-分段输出学生信息&amp;#34; &amp;lt;&amp;lt; endl;\n\tchar ch;\n\tint n &amp;#61; 0;\n\thead &amp;#61; head-&amp;gt;getNext();\n\tcin &amp;gt;&amp;gt; ch;\n\tswitch (ch)\n\t{\n\tcase &amp;#39;1&amp;#39;: \n\t\thead &amp;#61; findmege(head);\n\t\tif (head &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\thead-&amp;gt;getMage();\n\t\tbreak;\n\tcase &amp;#39;2&amp;#39;: \n\twhile (head)\n\t{\n\t\thead-&amp;gt;getMage();\n\t\thead &amp;#61; head-&amp;gt;getNext();\n\t}\n\tbreak;\n\tcase &amp;#39;3&amp;#39;: \n\t\tcout &amp;lt;&amp;lt; &amp;#34;a-60分以下&amp;#xff1b;b-60~70分之间&amp;#xff1b;c-70~80分之间&amp;#xff1b;d-80~90分之间&amp;#xff1b;e-90~100分之间&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ch;\n\t\tswitch (ch)\n\t\t{\n\t\tcase &amp;#39;a&amp;#39;:\n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score &amp;lt;&amp;#61; 60)\n\t\t\t{\n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\t break;\n\t\tcase &amp;#39;b&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;60 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 70) \n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;; \n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;c&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;70 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 80)\n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage(); \n\t\t\t\tn&amp;#43;&amp;#43;; \n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;d&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;80 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 90)\n\t\t\t{\n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;e&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;90 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 100)\n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\t}\n\t\tif (n &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;该分段内没有您要找的学生信息&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t}\n\t}\n}\n \n/*****************主菜单************************/\nvoid mainmenu(student *head)\n{\n\tchar selet[10];\n\tint n &amp;#61; 1;\n\tofstream outfile;\n\tifstream infile;\n\tstudent *p, *ptr;\n\tstudent *test &amp;#61; head, *mid;\n\tcout &amp;lt;&amp;lt; &amp;#34;*************************欢迎进入学生信息管理系统*************************&amp;#34; &amp;lt;&amp;lt; endl;\n\tdo {\n\t\tcout &amp;lt;&amp;lt; &amp;#34;**************************************************************************&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;1.插入信息&amp;#xff1b;   2.删除信息&amp;#xff1b;  3.修改信息&amp;#xff1b; 4.查看信息&amp;#xff1b; 5.保存  &amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;按&amp;#39;q&amp;#39;键退出      &amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;**************************************************************************&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; selet;\n\t\tif (((selet[0]&amp;lt;&amp;#39;1&amp;#39; || selet[0]&amp;gt;&amp;#39;6&amp;#39;) &amp;amp;&amp;amp; selet[0] !&amp;#61; &amp;#39;q&amp;#39;) || strlen(selet)&amp;gt;1)\n\t\t{\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;您的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (selet[0])\n\t\t{\n \n\t\tcase &amp;#39;1&amp;#39;:\n\t\t\tconstruct_list(head);\n\t\t\tbreak; \n\t\tcase &amp;#39;2&amp;#39;: \n\t\t\tdelete_list(head); \n\t\t\tbreak;\n\t\tcase &amp;#39;3&amp;#39;: \n\t\t\tchange_info(head);\n\t\t\tbreak;\n\t\tcase &amp;#39;4&amp;#39;: \n\t\t\toutput(head);\n\t\t\tbreak;\n\t\tcase &amp;#39;5&amp;#39;:  \n\t\t\toutfile.open(&amp;#34;students.txt&amp;#34;, ios::out | ios::app);\n\t\t\tfor (p &amp;#61; head-&amp;gt;getNext(); p !&amp;#61; &amp;#39;\\0&amp;#39;; p &amp;#61; p-&amp;gt;getNext())\n\t\t\t{\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_name &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_num &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_score &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; endl;\n\t\t\t}\n\t\t\toutfile.close();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;保存成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tbreak;\n\t\tcase &amp;#39;q&amp;#39;: \n\t\t\tbreak;\n\t\t}\n\t} while (selet[0] !&amp;#61; &amp;#39;q&amp;#39;);\n}\n \nvoid main()\n{\n\tstudent head;\n\tmainmenu(&amp;amp;head);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["学生成绩管理系统，要求用C++", ["题目：学生成绩管理系统", "\n\n", "一、基本要求", "\n\n", "1）能进行数据的添加、删除、修改、查询、排序；", "\n\n", "2）完全使用类实现。", "\n\n", "3) 重载输入“>>”操作符，使得可以通过cin直接读入类的对象值。", "\n\n", "4) 编写main函数，测试系统的各种功能。二、系统基本类系统基本类4个：Score类，subject类，Student类，Class类。存储学生的个人信息，考试科目，成绩，班级信息。三、功能拓展文件操作：", "\n\n", "1）初始数据从文件导入，能够实现文件的显示；", "\n\n", "2）数据保存至文件中；", "\n\n", "3）对文件记录进行增、删、改、查；", "\n\n", "4）多个文件组成一个文件。派生：为Student类派生研究生类GStudent，为研究生填加课题类Project类。扩展功能中可包含书上的知识点内容，如文件流、STL标准模板库虚函数、派生、函数重载、运算符重载、静态数据成员和成员函数等。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;使用base64吧&amp;#xff0c;将模型转成字节流然后加密保存到本地&amp;#xff0c;每次读取的时候解密到内存中&amp;#xff0c;从内存中加载模型。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["神经网络在训练时怎么对模型进行加密，并在解密时传入模型进行验证？", ["问题遇到的现象和发生背景", "\n", "目前是用pytorch C++版的接口搭建了一个网络结构，现在想在训练时对我保存下来的模型进行加密，然后在使用模型时进行解密后，用流把模型参数传入到模型中，请问各位是怎么实现的？我做了一个月了 都没有做出来。", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n\n", "我的解答思路和尝试过的方法", "\n", "我本来想的是使用文件流把字符加载到内存里面，然后对每个字符使用异或进行加密，但是打开解密后的模型文件，并传入到网络时会报\"Error data format\"这个错误，我想问问改怎么解决？"]], "Tag": "算法设计"}
{"Answer": "H.264、H.263、MPEG-4、MPEG-3、MPEG-2 只是编解码算法，  播放器除了支持编解码算法还需要能解析出媒体流格式。\r\n通常网络摄像机压缩编码以后，还要将码流进行封装，如果以标准码流进行封装如RTSP等方式，那常见的播放器如vlc、mplayer等就可以直接播放。\r\n如果不太标准那只能找该网络摄像机厂商提供的播放器，或者是SDK来进行开发才能播放。", "Konwledge_Point": "网络中的流", "Question": ["网络摄像机视频编码H.264、H.263、MPEG-4、MPEG-3、MPEG-2兼容性？", ["我的网络摄像机监控客户端可以播放视频编码为H.264和MPEG-4的网络监控视频，请问它能不能播放编码为H.263和MPEG-2和MPEG-3的视频流呢？", "\n\n", "由于手上的网络摄像机只有H.264和MPEG-4这两个选项，没法测试，希望有人知道的话告诉我下，谢谢了"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nthis.$message.success(&amp;#39;下载成功&amp;#39;)\n    const blob &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Blob([&lt;span class=\"hljs-params\"&gt;res&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;data&lt;/span&gt;], { &lt;span class=\"hljs-params\"&gt;type&lt;/span&gt;: &amp;#39;&lt;span class=\"hljs-params\"&gt;application&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;/&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;vnd&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;ms&lt;/span&gt;-&lt;span class=\"hljs-params\"&gt;excel&lt;/span&gt;;&lt;span class=\"hljs-params\"&gt;charset&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-params\"&gt;utf&lt;/span&gt;-8&amp;#39; })&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;let&lt;/span&gt; link &amp;#61; document.create&lt;span class=\"hljs-constructor\"&gt;Element(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;let&lt;/span&gt; href &amp;#61; window.&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;URL&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;create&lt;span class=\"hljs-constructor\"&gt;ObjectURL(&lt;span class=\"hljs-params\"&gt;blob&lt;/span&gt;)&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//下载链接&lt;/span&gt;\n    link.href &amp;#61; href;\n    link.text &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;下载&amp;#34;&lt;/span&gt;;\n    link.download &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;xxx&amp;#34;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//下载后文件名&lt;/span&gt;\n    document.body.append&lt;span class=\"hljs-constructor\"&gt;Child(&lt;span class=\"hljs-params\"&gt;link&lt;/span&gt;)&lt;/span&gt;;\n    link.click&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//点击下载&lt;/span&gt;\n    document.body.remove&lt;span class=\"hljs-constructor\"&gt;Child(&lt;span class=\"hljs-params\"&gt;link&lt;/span&gt;)&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//下载完成移除元素&lt;/span&gt;\n    window.&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;URL&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;revoke&lt;span class=\"hljs-constructor\"&gt;ObjectURL(&lt;span class=\"hljs-params\"&gt;href&lt;/span&gt;)&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//释放blob对象&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["springboot vue 下载文件，浏览器未显示下载的文件\n只有控制台 Preview 有文件", ["springboot vue 下载文件，浏览器未显示下载的文件", "只有控制台 Preview 有文件", "\n", "\n", "\n", "\n    @PostMapping(", "\"/down\"", ")\n   ", "public", " ", "void", " down(HttpServletResponse response, @Param(", "\"id\"", ") ", "int", " id) {\n        Backup backup = backupService.getById(id);\n          ", "File", " ", "file", "=", "new", " ", "File", "(backup.getPath());\n        response.setContentType (", "\"application/octet-stream\"", ");\n         \n        String name = ", "file", ".getName()+", "\".txt\"", ";\n        ", "try", " {\n            name = ", "new", " String (name.getBytes (StandardCharsets.UTF_8), ", "\"ISO8859-1\"", ");\n        } ", "catch", " (UnsupportedEncodingException e) {\n            e.printStackTrace ();\n        }\n        response.addHeader (", "\"Content-Disposition\"", ", ", "\"attachment;filename=\"", " + name);\n\n        OutputStream opmt = ", "null", ";\n\n        ", "try", " {\n            opmt = response.getOutputStream ();\n            opmt.", "write", " (FileUtils.readFileToByteArray (", "new", " ", "File", " (backup.getPath())));\n            opmt.close ();\n        } ", "catch", " (IOException e) {\n            e.printStackTrace ();\n        }\n        \n}\n", "\n", "\n    ", "async", " ", "download", "(", "{id}", "){ ", "// id=", "\n      ", "const", " result = ", "await", " ", "getBackupDown", "({id}).", "catch", "(", "err", "=>", "{\n        ", "this", ".", "$message", ".", "error", "(", "'网络请求错误'", ")\n      })\n      ", "if", "(result.", "status", "){\n        ", "this", ".", "$message", ".", "error", "(", "'下载失败'", ")\n      }", "else", " {\n        ", "this", ".", "$message", ".", "success", "(", "'下载成功'", ")\n      }\n\n      ", "await", " ", "this", ".", "fetchData", "()\n    },\n", "\n", "<a-button ", "value", "=", "\"small\"", " @", "click", "=", "\"download(item)\"", ">下载</a-button>\n\n"]], "Tag": "算法设计"}
{"Answer": "抛出io异常，文件读取的问题。serversocket没有写进数据，socket就读取数据时，会抛出io异常的。", "Konwledge_Point": "网络中的流", "Question": ["java创建socket时失败的原因有哪些？", ["最近练习使用socket时，本来能够脸上服务器的，后来不知道怎么的就连不上了，最后定位就是socket创建失败，什么原因我不知道。我知道的原因如下：", "\n1、没有添加连接网络权限。", "\n2、没有在后台线程中创建socket", "\n3、端口号被占用", "\n这些问题我都避免了，而且之前就连上了，后来连不上，抛出IOException，请问还有其他的原因会导致socket创建失败吗？"]], "Tag": "算法设计"}
{"Answer": "这种问题是要考虑线程的", "Konwledge_Point": "网络中的流", "Question": ["怎么解决java网络通信编程ip和port是从文本框中获取的？", ["为什么我把connect()方法加入button1的事件中就会黑屏", "\n\n", "代码如下", "\n客户端：", "\npackage sunxu.util;", "\n\n", "import java.awt.BorderLayout;", "\nimport java.awt.Dimension;", "\nimport java.awt.event.ActionEvent;", "\nimport java.awt.event.ActionListener;", "\nimport java.io.BufferedReader;", "\nimport java.io.IOException;", "\nimport java.io.InputStreamReader;", "\nimport java.io.PrintWriter;", "\nimport java.net.InetAddress;", "\nimport java.net.Socket;", "\nimport java.net.UnknownHostException;", "\n\n", "import javax.swing.BorderFactory;", "\nimport javax.swing.JButton;", "\n\n", "import javax.swing.JFrame;", "\nimport javax.swing.JLabel;", "\nimport javax.swing.JPanel;", "\nimport javax.swing.JScrollPane;", "\nimport javax.swing.JTextArea;", "\nimport javax.swing.JTextField;", "\n\n", "public class ClientSocketFrame extends JFrame  {", "\n    /**", "\n     * ", "\n     */", "\n    private static final long serialVersionUID = 1L;", "\n    private PrintWriter writer; // 声明PrintWriter类对象", "\n    private BufferedReader reader; // 声明BufferedReader对象", "\n    private Socket socket; // 声明Socket对象", "\n    private JTextArea ta_info; // 创建JtextArea对象", "\n    JButton button1 = new JButton(\"Connect\");", "\n    //private JTextField tf_send; // 创建JtextField对象", "\n    private InetAddress sendIp;", "\n    private int sendPort;", "\n\n", "private void connect() { // 连接套接字方法\n    ta_info.append(\"Connect to server…\\n\"); // 文本域中信息信息\n    try { // 捕捉异常\n        socket = new Socket(sendIp,sendPort); // 实例化Socket对象\n        while (true) {\n            writer = new PrintWriter(socket.getOutputStream(), true);\n            reader = new BufferedReader(new InputStreamReader(socket\n                    .getInputStream())); // 实例化BufferedReader对象\n            ta_info.append(\"Client connected…\\n\"); // 文本域中提示信息\n            getServerInfo();\n        }\n    } catch (Exception e) {\n        e.printStackTrace(); // 输出异常信息\n    }\n}\n\npublic static void main(String[] args) { // 主方法\n      ClientSocketFrame clien = new ClientSocketFrame(); // 创建本例对象\n      clien.setVisible(true); // 将窗体显示\n      //clien.connect(); // 调用连接方法\n}\n\nprivate void getServerInfo() {\n    try {\n        while (true) {\n            if (reader != null) {\n                String line = reader.readLine();// 读取服务器发送的信息\n                if (line != null)\n                    ta_info.append(\"接收到服务器发送的信息：\" + line + \"\\n\"); // 显示服务器端发送的信息\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (reader != null) {\n                reader.close();// 关闭流\n            }\n            if (socket != null) {\n                socket.close(); // 关闭套接字\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n/**\n * Create the frame\n */\npublic ClientSocketFrame() {\n    super();\n    setTitle(\"客户端\");\n    setBounds(100, 100, 361, 257);\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n    final JPanel panel = new JPanel();\n    getContentPane().add(panel, BorderLayout.NORTH);\n\n    panel.setBorder(BorderFactory.createTitledBorder(\"客户机设置:\"));\n\n\n\n    final JLabel label = new JLabel();\n    label.setText(\"Server IP:\");\n    panel.add(label);\n    JTextField tf_sen= new JTextField();\n    tf_sen.setPreferredSize(new Dimension(50, 25));\n    panel.add(tf_sen);\n\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Server Port:\");\n    panel.add(label1);\n    JTextField tf_Port = new JTextField();\n    tf_Port.setPreferredSize(new Dimension(50, 25));\n    panel.add(tf_Port);\n\n    final JButton button1 = new JButton(\"Connect\");\n\n    button1.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n            try {\n                sendIp=InetAddress.getByName(tf_sen.getText());\n            } catch (UnknownHostException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }  \n               sendPort=Integer.parseInt(tf_Port.getText());\n               ta_info.append(\"Connect to server…\\n\"); // 文本域中信息信息\n               ta_info.append(sendIp+\"\\n\"); // 文本域中信息信息\n               ta_info.append(sendPort+\"\\n\"); // 文本域中信息信息\n               connect();\n        }\n    });\n    panel.add(button1);\n\n\n    final JPanel panel_1 = new JPanel();\n    getContentPane().add(panel_1, BorderLayout.SOUTH);\n\n    final JLabel label_1 = new JLabel();\n    label_1.setText(\"Say：\");\n    panel_1.add(label_1);\n\n    JTextField tf_send = new JTextField();\n    tf_send.setPreferredSize(new Dimension(220, 25));\n    panel_1.add(tf_send);\n\n    final JButton button = new JButton();\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n            writer.println(tf_send.getText()); // 将文本框中信息写入流\n            ta_info.append(\"客户端发送的信息：\" + tf_send.getText()\n                    + \"\\n\"); // 将文本框中信息显示在文本域中\n            tf_send.setText(\"\"); // 将文本框清空\n        }\n    });\n    button.setText(\"Say\");\n    panel_1.add(button);\n\n    final JScrollPane scrollPane = new JScrollPane();\n    getContentPane().add(scrollPane, BorderLayout.CENTER);\n\n    ta_info = new JTextArea();\n    scrollPane.setViewportView(ta_info);\n    //\n\n}\n", "\n\n", "}", "\n\n", "服务器：", "\npackage sunxu.util;", "\n\n", "import java.awt.BorderLayout;", "\nimport java.awt.Color;", "\nimport java.awt.Dimension;", "\nimport java.awt.Font;", "\nimport java.awt.event.ActionEvent;", "\nimport java.awt.event.ActionListener;", "\nimport java.io.*;", "\nimport java.net.*;", "\n\n", "import javax.swing.BorderFactory;", "\nimport javax.swing.JButton;", "\nimport javax.swing.JFrame;", "\nimport javax.swing.JLabel;", "\nimport javax.swing.JPanel;", "\nimport javax.swing.JScrollPane;", "\nimport javax.swing.JTextArea;", "\nimport javax.swing.JTextField;", "\n\n", "public class ServerSocketFrame extends JFrame {", "\n    //private JTextField tf_send;", "\n    private JTextArea ta_info;", "\n    private PrintWriter writer; // 声明PrintWriter类对象", "\n    private BufferedReader reader; // 声明BufferedReader对象", "\n    private ServerSocket server; // 声明ServerSocket对象", "\n    private Socket socket; // 声明Socket对象socket", "\n    private int sendPort;", "\n\n", "public void getServer() {\n    try {\n        server = new ServerSocket(sendPort); // 实例化Socket对象\n        ta_info.append(\"服务器套接字已经创建成功\\n\"); // 输出信息\n        while (true) { // 如果套接字是连接状态\n            ta_info.append(\"等待客户机的连接......\\n\"); // 输出信息\n            socket = server.accept(); // 实例化Socket对象\n            reader = new BufferedReader(new InputStreamReader(socket\n                    .getInputStream())); // 实例化BufferedReader对象\n            writer = new PrintWriter(socket.getOutputStream(), true);\n            getClientInfo(); // 调用getClientInfo()方法\n        }\n    } catch (Exception e) {\n        e.printStackTrace(); // 输出异常信息\n    }\n}\n\nprivate void getClientInfo() {\n    try {\n        while (true) {\n            String line = reader.readLine();// 读取客户端发送的信息\n            if (line != null)\n                ta_info.append(\"接收到客户机发送的信息：\" + line + \"\\n\"); // 显示客户端发送的信息\n        }\n    } catch (Exception e) {\n        ta_info.append(\"客户端已退出。\\n\"); // 输出异常信息\n    } finally {\n        try {\n            if (reader != null) {\n                reader.close();// 关闭流\n            }\n            if (socket != null) {\n                socket.close(); // 关闭套接字\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic static void main(String[] args) { // 主方法\n    ServerSocketFrame frame = new ServerSocketFrame(); // 创建本类对象\n    frame.setVisible(true);\n    //frame.getServer(); // 调用方法\n}\n\npublic ServerSocketFrame() {\n    super();\n    setTitle(\"服务器端程序\");\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    setBounds(100, 100, 379, 260);\n\n    final JScrollPane scrollPane = new JScrollPane();\n    getContentPane().add(scrollPane, BorderLayout.CENTER);\n\n    ta_info = new JTextArea();\n    scrollPane.setViewportView(ta_info);\n\n    final JPanel panel = new JPanel();\n    getContentPane().add(panel, BorderLayout.SOUTH);\n\n    final JLabel label = new JLabel();\n    label.setText(\"Say：\");\n    panel.add(label);\n\n    JTextField tf_send = new JTextField();\n    tf_send.setPreferredSize(new Dimension(150, 25));\n    panel.add(tf_send);\n\n    final JButton button = new JButton();\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n            writer.println(tf_send.getText()); // 将文本框中信息写入流\n            ta_info.append(\"服务器发送的信息是：\" + tf_send.getText() + \"\\n\"); // 将文本框中信息显示在文本域中\n            tf_send.setText(\"\"); // 将文本框清空\n        }\n    });\n    button.setText(\"Say:\");\n    panel.add(button);\n\n    final JPanel panel_1 = new JPanel();\n    getContentPane().add(panel_1, BorderLayout.NORTH);\n    panel_1.setBorder(BorderFactory.createTitledBorder(\"服务器设置:\"));\n\n    final JLabel label_1 = new JLabel();\n    label_1.setText(\"Port:\");\n    JTextField tf_sen= new JTextField();\n    tf_sen.setPreferredSize(new Dimension(220, 25));\n    panel_1.add(label_1);\n    panel_1.add(tf_sen);\n\n    final JButton button1 = new JButton(\"Strat\");\n\n    button1.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n               sendPort=Integer.parseInt(tf_sen.getText());\n               getServer();\n        }\n    });\n    panel_1.add(button1);\n\n\n}\n", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "跨域头加到视频服务器，不是代理转发那里。你现在加法，跨域头没有加进去的，看一下客户端请求就知道", "Konwledge_Point": "网络中的流", "Question": ["video.js播放m3u8视频无法跨域访问", ["问题：video.js播放m3u8视频无法跨域访问", "\n\n", "今天使用video.js播放m3u8视频时遇到了跨域的问题", "\n我的请求路径是www.xuecheng.com/video.html", "\n\n", "\n\n", "我是通过nginx代理访问的", "\n以下时nginx的配置", "\n\n", "\n\n", "\n\n", "\n\n", "以下是我的工程的，工程中已经下载了video.js以及videojs-contrib-hls.js", "\n\n", "\n\n", "以下是video.html的内容", "\n\n", "\n**", "\n\n", "以下是我的m3u8的视频文件地址**", "\n\n", "\n\n", "**", "\n网络上查看了很多关于Access-Control-Allow-Origin的错误，但是我的ngnix的配置文件中已经加了相关跨域语句，重启nginx还是访问www.xuecheng.com/video.html还是同样的错误。", "\n\n", "求大神们解答，**", "\n\n", "已经解决了，在配置跨域的语句后面加上always", "\n\n", "\n\n", "具体原理我也不懂，请参考这位兄弟的贴", "https://blog.csdn.net/bojinyanfeng/article/details/103719789"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;在Android设置里面&amp;#xff0c;设置一个自定义doh服务器&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://console.dnspod.cn/publicdns/config\" id=\"textarea_1676342340565_1676342624086_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://console.dnspod.cn/publicdns/config&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Public DNS 专业版配置&amp;#xff0c;在云端屏蔽一些域名&amp;#xff0c;这样可以在移动网络和Wifi网络同时生效&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["家里的小朋友天天使用微信视频号刷短视频，有没有办法在他打开微信视频号时候关闭流量，如何解决？", ["家里的小朋友天天使用微信视频号刷短视频，有没有办法在他打开微信视频号时候关闭流量，安卓的系统？，有偿!"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以看下该实例中对于Java Socket 数据传输 基础以及优化&amp;#xff0c;链接&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/z1766042975/article/details/112709438\" id=\"textarea_1672013553959_1672014256766_0\"&gt;https://blog.csdn.net/z1766042975/article/details/112709438&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["Java Socket 传输数据量大时接收端与发送端数据不一致问题", ["Java Socket传输字节流时接收端与发送端数据不一致问题", "\n", "我做的一个TCP传输方法，每次在传输数据时在包头打上数据包大小，在接收端接收到足够大小后再进行处理，在传输数据量小的时候不会出错，但一旦数据量大到几十K时也就是字节数量达到30000时，接收端出现了接受端和发送端发送的字节数量都不一致了，接收端的字节数量时不时会大于发送端，有时多出来几百个字节，有时候多出来几千个字节，更麻烦的是我不知道多出来的字节在哪里，他们插在了这些数据包中间，我在查看发送端和接收端的字节流不同时发现发送端最后几个字节和接收端最后几个字节一致，但接收到的字节数量不一致，我以为是不是发送端在发送时变成了多线程，我尝试调试，可我把断点设置到接收端的InputStream.read时这种现象又离奇的消失了，于是我尝试着在read之前sleep几毫秒，问题也没有出现，但明显这种方法治标不治本且鸡肋，在此", "\n", "\n\n", "\n", "运行结果及详细报错内容", "\n", "这是发送端运行：", "\n", "\n", "最下方是我这个write的数组的大小", "可是在接收端：", "\n", "\n", "右下角监视的client.getInputStream().available()还有8834，说明缓冲区内还有8834个，可是我已经把发送端发送的数据大小全部读取了，而且读的还是有错误的", "可是如果我在前面的", "\n", "\n", "read部分加上断点时它就不会有这种情况了", "\n", "我的解答思路和尝试过的方法，我发现设置断点时它就不会产生这种情况的话，我就在read前面加上sleep也没有产生这种情况，但这种方法很鸡肋，浪费服务器资源不说，如果不同的网络情况我还得调整这个sleep，我猜测产生这个现象的原因是由于发送的write时byte[]数组过大导致发生拆包，但后面的包到达后马上就被read了（可是TCP协议不应该是保证读取有序吗），导致中间空出的字节被覆盖了，后面到达的包就只能排到后面了，可是我没有办法判断我在接受端write的byte[]数组资源全部到达接收端啊。希望能有解我疑惑", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "你这个问题实际上就是要定义一个远程调用协议\r\n1.在客户段给发送信息前面加一个头，例如:\r\n@header@type:methodinvoke@服务端的类@服务端的方法@参数列表@end@header@\r\n2.在服务端接受客户段信息时，判断一下头部是否有如上头，如果有，按照协议解析，\r\n然后根据解析内容通过反射调用客户段请求的逻辑执行\r\n\r\n此外，服务端最好使用线程池处理客户段请求\r\n在类中定义线程池常量\r\nprivate static ExecutorService executoService;\r\n\r\n在调用具体逻辑时\r\nexecutoService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 10);\r\nexecutoService.execute(new SocketThread(socket));", "Konwledge_Point": "网络中的流", "Question": ["Java 网络通信 类还未编写如何进行调用(或者解决思路)", ["  程序想实现的效果：客户端现在有一个对象“狗”，加入了一个LinkedList集合，随后将该集合发送到服务器端。服务器端接收到这个集合，会调用一个方法Judge来判断LinkedList里面有什么，如果是狗则调用XXX方法，如果是猫则调用XXX方法。\n        问题描述：现在客户端与服务器端单独抽出成为一个jar工具包。也就是说服务器端和客户端会预先写好。换而言之，在该包里没有Judge方法，Judge方法是在程序实际编写时再写成的。那么此时服务器端代码应该怎么写？\n        实际应用举例：当实际使用时，应用程序(客户端)调用Send()，此时该jar包中已编好的程序会将对象发送到服务器端；在服务器端只需写一个Judge()，该方法会被jar包中的程序自动调用。\n\n        大体实现的代码：\n", "\n\n", "客户端：", "\n\n", " //向服务器发送数据\n    public void send(TransferLinkedList linkedList) throws IOException{\n        /**\n         * 本方法用于客户端向服务器发送数据。首先从套接字中获取基本输出流，接下来将该输出流转换为对象输出流以输出对象\n         */\n        //从该套接字中获取输出流\n        OutputStream clientOut = client.getOutputStream();\n        //将该输出流处理为对象输出流\n        ObjectOutputStream clientOutObject = new ObjectOutputStream(clientOut);\n        //传输信息\n        clientOutObject.writeObject(linkedList);\n\n        //刷新缓存区\n        clientOutObject.flush();\n\n        //接收服务器信息以确认是否成功发送信息\n\n    }\n", "\n\n", "服务器端：", "\n\n", " //开始运行\n    public void run() throws IOException{\n        //服务器一直等待客户端的连接，当与客户端建立连接时，服务器分出一个线程建立新的Socket进行处理，原有Socket继续等待\n        //此处为了简便省略线程\n        while(true){\n            Socket socket = server.accept();\n\n            //处理新的Socket\n\n            /**\n             * 调用Judge方法，Judge方法应在实际使用该jar包时编写\n             * 此时不知道Judge包含哪些方法，是怎么样的路径，甚至名字是否是Judge\n             * 该使用什么方法来处理？反射？工厂模式？感觉都不大能解决\n             */\n\n        }\n    }\n"]], "Tag": "算法设计"}
{"Answer": "关键是语音流. 对队列也比较赞同. 不过考虑并发多线程问题.    缓冲区 内部划分应该分:  发送区, 资源区, 接受区. 对消息进行编号. 例如2s一个语音段, 发送成功就成功, 不然丢弃. 编号之后, 可以同时并发发送. 发送区进行资源锁定, 进入server 资源区后解锁. 接受区也是一样的, 维护一个顺序索引. 按顺序发送资源区给接收端. 如果丢包你, 怎么处理. 就是语音丢失闹 . 后面再有也不要你. 锁定之后就好.  其实生产--消费者思路.   至于实现, 如何并发, 并发 ,对外封装调用.", "Konwledge_Point": "网络中的流", "Question": ["c#将客户端发来的数据流实时转发给另一个客户端   服务器数据缓冲区的建立问题", ["我想要实现两部安卓客户端的实时语音通讯，安卓客户端都在内网，因此需要一外网pc做数据的中转服务器，安卓语音发送端通过audiotrack录制PCM音频数据并实时发送到服务器，服务器接收数据并不断读入一个缓冲区，开启另一个线程循环读取缓冲区的数据同时将数据发送到另一个安卓客户端，问题就在于服务器的缓冲区要怎么做？怎么保证缓冲区的数据同时被两个线程操作时的有序稳定 求大神指教，假设网络良好，不考虑网络波动带来的数据处理问题。 "]], "Tag": "算法设计"}
{"Answer": "你把动态生成图片的页面粘出来，或是可访问的，让我访问下，我把那地址提取出来", "Konwledge_Point": "网络中的流", "Question": ["java获取网络动态图片", ["使用java实现把网页的图片加载到本地的swing里面查看，但是有些图片是动态生成的，比如用servlet直接生成输出流放到网页上，如何从里面题取出这种图片，谢谢  可以看发送到我的邮箱", "alone_dancer@sohu.com", "\n[b]问题补充：[/b]", "\n可能是说的不太清楚，就是不知道如何得到这个流，生成图片是用js调用servlate生成的，这是查看验证码部分源代码得到的结果", "\n\n", "\n\n", "这是使用查看全部源代码得到的结果：", "验证码", "如果您无法识别验证码，请点图片更换", "\n\n", "有源码发出来，或放邮箱交流更好。谢谢～"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/huzhengnan/article/details/22288897", "Konwledge_Point": "网络中的流", "Question": ["网络爬虫下载网页的问题", ["下载网页时只能下载第一个网页，后续网页虽然能爬出来，但是无法下载到本地。下载网页的代码如下", "\npublic class FileDownLoader {", "\n    /**根据 url 和网页类型生成需要保存的网页的文件名", "去除掉 url 中非文件名字符 ", "\n     */", "\n    public  String getFileNameByUrl(String url,String contentType)", "\n    {", "\n        url=url.substring(7);//remove http://", "\n        if(contentType.indexOf(\"html\")!=-1)//text/html", "\n        {", "\n            url= url.replaceAll(\"[\\?/:", "|<>\\\"]\", \"_\")+\".html\";", "\n            return url;", "\n        }", "\n        else//如application/pdf", "\n        {", "\n            return url.replaceAll(\"[\\?/:*|<>\\\"]\", \"_\")+\".\"+ ", "\n\n", "      contentType.substring(contentType.lastIndexOf(\"/\")+1);\n    }   \n}\n\n/**保存网页字节数组到本地文件\n * filePath 为要保存的文件的相对地址\n */\nprivate void saveToLocal(byte[] data,String filePath)\n{\n    try {\n        DataOutputStream out=new DataOutputStream(\n", "\n\n", "new FileOutputStream(new File(filePath)));", "\n            for(int i=0;i<data.length;i++)", "\n            out.write(data[i]);", "\n            out.flush();", "\n            out.close();", "\n        } catch (IOException e) {", "\n            e.printStackTrace();", "\n        }", "\n    }", "\n\n", "/*下载 url 指向的网页*/\npublic String  downloadFile(String url)\n{\n      String filePath=null;\n\n\n     /* 使用 GetMethod 来访问一个 URL 对应的网页，需要如下一些步骤。\n      1 生成一个 HttpClinet 对象并设置相应的参数。\n      2 生成一个 GetMethod 对象并设置响应的参数。\n      3 用 HttpClinet 生成的对象来执行 GetMethod 生成的 Get 方法。\n      4 处理响应状态码。\n      5 若响应正常，处理 HTTP 响应内容。\n      6 释放连接*/\n      /* 1.生成 HttpClinet 对象并设置参数*/\n      HttpClient httpClient=new HttpClient();\n      //设置 Http 连接超时 5s\n          httpClient.getHttpConnectionManager().getParams().\n", "\n\n", "setConnectionTimeout(5000);", "\n\n", "      /*2.生成 GetMethod 对象并设置参数*/\n      //使用 GetMethod 来访问一个 URL 对应的网页\n      GetMethod getMethod=new GetMethod(url);    \n      //设置 get 请求超时 5s\n      getMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT,5000);\n      //设置请求重试处理,用的是默认的重试处理：请求三次\n      getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,\n        new DefaultHttpMethodRetryHandler());\n\n      /*3.执行 HTTP GET 请求*/\n      try{ \n          /*executeMethod返回值是一个整数，表示了执行该方法后服务器返回的状态码，\n          该状态码能表示出该方法执行是否成功,需要认证或者页面发生了跳转（默认状态下GetMethod的实例是自动处理跳转的）*/\n          int statusCode = httpClient.executeMethod(getMethod);\n          //判断访问的状态码\n          if (statusCode != HttpStatus.SC_OK) \n          {\n", "\n\n", "System.err.println(\"Method failed: \"+ getMethod.getStatusLine());", "\n                  filePath=null;", "\n              }", "\n\n", "          /*4.处理 HTTP 响应内容（返回的状态码正确后，即可取得内容）*/\n          /*取得目标地址的内容有三种方法：\n          1 getResponseBody，该方法返回的是目标的二进制的byte流；\n          2 getResponseBodyAsString，返回的是String类型，值得注意的是该方法返回的String的编码是根据系统默认的编码方式，所以返回的String值可能编码类型有误\n          3 getResponseBodyAsStream，这个方法对于目标地址中有大量数据需要传输是最佳的。\n                  在这里我们使用了最简单的getResponseBody方法。*/\n", "\n\n", "byte[] responseBody = getMethod.getResponseBody();//读取为字节数组", "\n              //根据网页 url 生成保存时的文件名", "\nfilePath=\"E:\\java\\web spider\\\"+getFileNameByUrl(url,", "\n           getMethod.getResponseHeader(\"Content-Type\").getValue());", "\n            saveToLocal(responseBody,filePath);", "\n          } catch (HttpException e) {", "\n                   // 发生致命的异常，可能是协议不对或者返回的内容有问题", "\n                   System.out.println(\"Please check your provided http address!\");", "\n                   e.printStackTrace();", "\n                  } catch (IOException e) {", "\n                   // 发生网络异常", "\n                   e.printStackTrace();", "\n                  } finally {", "\n                   // 释放连接", "\n                   getMethod.releaseConnection();", "\n                  }", "\n                  return filePath;", "\n    }", "\n}", "\n调用他的爬行代码如下：", "\npublic class Crawler {", "\n    /* 使用种子 url 初始化 URL 队列*/", "\n    String results=\"\";", "\n    private void initCrawlerWithSeeds(String[] seeds)", "\n    {", "\n        for(int i=0;i<seeds.length;i++)", "\n            LinkDB.addUnvisitedUrl(seeds[i]);", "\n    }", "\n\n", "/* 爬取方法*/\npublic void crawling(String[] seeds,JTextArea kkk)\n{\n    LinkFilter filter = new LinkFilter(){\n        //提取以 用户输入的URL开头的链接\n        public boolean accept(String url) {\n            if(url.startsWith(url))\n                return true;\n            else\n                return false;\n        }\n    };\n    //初始化 URL 队列\n    initCrawlerWithSeeds(seeds);\n    //循环条件：待抓取的链接不空且抓取的网页不多于 1000\n    while(!LinkDB.unVisitedUrlsEmpty()&&LinkDB.getVisitedUrlNum()<=1000)\n    {\n        //队头 URL 出对\n        String visitUrl=LinkDB.unVisitedUrlDeQueue();\n        if(visitUrl==null)\n            continue;\n        FileDownLoader downLoader=new FileDownLoader();\n        //下载网页\n        downLoader.downloadFile(visitUrl);\n        //该 url 放入到已访问的 URL 中\n        LinkDB.addVisitedUrl(visitUrl);\n        //提取出下载网页中的 URL\n\n        Set<String> links=HtmlParserTool.extractLinks(visitUrl,filter);\n    Iterator<String> it = links.iterator(); //迭代器\n        while(it.hasNext())\n        {  \n            results=results+'\\n'+it.next();\n\n        }\n\n     kkk.setText(results);\n\n\n    }\n}\n", "\n\n", "}", "\n求各位大神帮忙解答，马上就要中期检查了"]], "Tag": "算法设计"}
{"Answer": "你是不是打开视频网址后打开的wireshark? 你的目标网址就是https的协议，是能看到https协议的， 但估计看不到你要的url. wireshark 是不能做https解析的或许你应该用mitmproxy", "Konwledge_Point": "网络中的流", "Question": ["想用wireshark找视频地址，但抓的包只有TCP，没有http、get等，接下来该如何操作？", ["额，本人wireshark新手（大部分网络协议都只是了解，但分层、三次握手等还是知道的），TCP-IP学得太枯燥了，想动手实践加深一点印象", "\n\n", "听说利用wireshark可以找到视频的真实地址，于是我参照了（", "https://blog.csdn.net/u012206807/article/details/14521917?locationnum=2）", " 这篇博文，想亲手实践一下，", "\n\n", "比如目标是(   ", "https://www.bilibili.com/video/av24502164/", "   )这个视频", "\n\n", "但是我只能找到视频发送的ip、端口，自己的ip、端口，出现的所有协议都是ARP、SSL、TCP、TLSv1.2等，就是没有文中所说的http。不知道是我的wireshark隐蔽掉了http呢？还是这视频就不是用http的协议来传输？还是说视频地址已经包含在里面了，只是我不懂得利用？？？我应该补充哪方面的知识呢？", "\n\n", "其实我最想知道的是，想下载一个视频，有没有一套通用的流程？每个步骤需要掌握哪些知识呢？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你好。我也这问题&amp;#xff0c;问问你解决了吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["大华SDK下载录像DEMO问题", ["你好，我想问一下，我把之前用的JFrame框架进行了修改，然后下载录像成功之后，文件的大小确为0K，不知道哪里有问题，请教一下", "\n", "public", " ", "class", " ", "DowmLoadRecordFile", " {\n    ", "private", " ", "String", " ", "m_strIp", " ", "=", " ", "\"117.172.167.248\"", ";\n    ", "private", " ", "int", " ", "m_nPort", " ", "=", " ", "38888", ";\n    ", "private", " ", "String", " ", "m_strUser", " ", "=", " ", "\"admin\"", ";\n    ", "private", " ", "String", " ", "m_strPassword", " ", "=", " ", "\"YBGX1234\"", ";\n\n    ", "// 开始时间", "\n    ", "private", " NetSDKLib.", "NET_TIME", " ", "stTimeStart", " ", "=", " ", "new", " ", "NetSDKLib", ".NET_TIME();\n\n    ", "// 结束时间", "\n    ", "private", " NetSDKLib.", "NET_TIME", " ", "stTimeEnd", " ", "=", " ", "new", " ", "NetSDKLib", ".NET_TIME();\n\n    ", "// 设备信息扩展", "\n    ", "private", " NetSDKLib.", "NET_DEVICEINFO_Ex", " ", "deviceInfo", " ", "=", " ", "new", " ", "NetSDKLib", ".NET_DEVICEINFO_Ex();\n\n    ", "public", " ", "static", " ", "final", " ", "NetSDKLib", " ", "netSdk", " ", "=", " NetSDKLib.NETSDK_INSTANCE;\n\n    ", "// 登陆句柄", "\n    ", "private", " NetSDKLib.", "LLong", " ", "loginHandle", " ", "=", " ", "new", " ", "NetSDKLib", ".LLong(", "0", ");\n\n    ", "private", " NetSDKLib.", "LLong", " ", "m_hDownLoadByTimeHandle", " ", "=", " ", "new", " ", "NetSDKLib", ".LLong(", "0", ");   ", "// 按时间下载句柄", "\n\n    ", "private", " ", "DownLoadPosCallBackByTime", " ", "m_DownLoadPosByTime", " ", "=", " ", "new", " ", "DownLoadPosCallBackByTime", "(); ", "// 录像下载进度", "\n\n    ", "class", " ", "DownLoadPosCallBackByTime", " ", "implements", " ", "NetSDKLib", ".fTimeDownLoadPosCallBack {\n        ", "@Override", "\n        ", "public", " ", "void", " ", "invoke", "(NetSDKLib.LLong lLoginID, ", "final", " ", "int", " dwTotalSize, ", "final", " ", "int", " dwDownLoadSize, ", "int", " index, NetSDKLib.NET_RECORDFILE_INFO.ByValue recordfileinfo, Pointer dwUser)", " {\n            ", "if", "(dwDownLoadSize == -", "1", ") {\n                DownLoadRecordModule.stopDownLoadRecordFile(m_hDownLoadByTimeHandle);\n            }\n        }\n    }\n\n    ", "// 网络连接恢复", "\n    ", "private", " ", "static", " ", "HaveReConnect", " ", "haveReConnect", " ", "=", " ", "new", " ", "HaveReConnect", "();\n\n    ", "// 网络连接恢复，设备重连成功回调", "\n    ", "// 通过 CLIENT_SetAutoReconnect 设置该回调函数，当已断线的设备重连成功时，SDK会调用该函数", "\n    ", "private", " ", "static", " ", "class", " ", "HaveReConnect", " ", "implements", " ", "NetSDKLib", ".fHaveReConnect {\n        ", "@Override", "\n        ", "public", " ", "void", " ", "invoke", "(NetSDKLib.LLong m_hLoginHandle, String pchDVRIP, ", "int", " nDVRPort, Pointer dwUser)", " {\n            System.out.printf(", "\"ReConnect Device[%s] Port[%d]\\n\"", ", pchDVRIP, nDVRPort);\n        }\n    }\n\n    ", "//1.初始化", "\n    ", "public", " ", "void", " ", "init", "()", " {\n", "//        netSdk.CLIENT_Init(DowmLoadRecordFile.DisConnectCallBack.getInstance(), null);", "\n        LoginModule.init(DowmLoadRecordFile.DisConnectCallBack.getInstance(), haveReConnect);   ", "// 打开工程，初始化", "\n    }\n\n    ", "//2.登陆", "\n    ", "public", " ", "void", " ", "Login", "()", " {\n        ", "// 登陆设备", "\n", "//        int nSpecCap = NetSDKLib.EM_LOGIN_SPAC_CAP_TYPE.EM_LOGIN_SPEC_CAP_TCP;    // TCP登入", "\n", "//        IntByReference nError = new IntByReference(0);", "\n", "//        loginHandle = netSdk.CLIENT_LoginEx2(m_strIp, m_nPort, m_strUser,", "\n", "//                m_strPassword, nSpecCap, null, deviceInfo, nError);", "\n", "//        if (loginHandle.longValue() != 0) {", "\n", "//            System.out.printf(\"Login Device[%s] Success!\\n\", m_strIp);", "\n", "//        } else {", "\n", "//            System.err.printf(\"Login Device[%s] Fail.Error[0x%x]\\n\", m_strIp, netSdk.CLIENT_GetLastError());", "\n", "//            LoginOut();", "\n", "//        }", "\n\n        ", "if", "(LoginModule.login(m_strIp,\n                m_nPort,\n                m_strUser,\n                m_strPassword)){\n            DownLoadRecordModule.setStreamType(", "0", ");\n            System.out.printf(", "\"Login Device[%s] Success!\\n\"", ", m_strIp);\n        }", "else", "{\n            System.err.printf(", "\"Login Device[%s] Fail.Error[0x%x]\\n\"", ", m_strIp, netSdk.CLIENT_GetLastError());\n            LoginOut();\n        }\n    }\n\n    ", "//3.执行流程", "\n    ", "public", " ", "void", " ", "run", "(LocalDateTime startTime, LocalDateTime endTime)", " {\n        ", "int", " ", "m_streamType", " ", "=", " ", "0", ";\n        ", "int", " ", "nChannelId", " ", "=", " ", "0", ";\n        ", "int", " ", "nRecordFileType", " ", "=", " ", "0", ";\n\n        stTimeStart.dwYear = startTime.getYear();\n        stTimeStart.dwMonth = startTime.getMonth().getValue();\n        stTimeStart.dwDay = startTime.getDayOfMonth();\n        stTimeStart.dwHour = startTime.getHour();\n        stTimeStart.dwMinute = startTime.getMinute();\n        stTimeStart.dwSecond = startTime.getSecond();\n\n        stTimeEnd.dwYear = endTime.getYear();\n        stTimeEnd.dwMonth = endTime.getMonth().getValue();\n        stTimeEnd.dwDay = endTime.getDayOfMonth();\n        stTimeEnd.dwHour = endTime.getHour();\n        stTimeEnd.dwMinute = endTime.getMinute();\n        stTimeEnd.dwSecond = endTime.getSecond();\n\n\n        ", "//设置回放时的码流类型", "\n        DownLoadRecordModule.setStreamType(m_streamType);\n        NetSDKLib.", "LLong", " ", "m_hDownLoadByFileHandle", " ", "=", " ", "new", " ", "NetSDKLib", ".LLong();\n        ", "//下载录像", "\n        m_hDownLoadByFileHandle = DownLoadRecordModule.downloadRecordFile(nChannelId,\n                nRecordFileType,\n                stTimeStart,", "//20210723171834", "\n                stTimeEnd,", "//20210723171934", "\n                SavePath.getSavePath().getSaveRecordFilePath(),", "//./RecordFile/2021-07-23/2021-07-23_17-25-14.dav", "\n                ", "null", ");\n\n        ", "//停止下载", "\n        DownLoadRecordModule.stopDownLoadRecordFile(m_hDownLoadByFileHandle);\n\n        ", "if", " (m_hDownLoadByFileHandle.longValue() != ", "0", ") {\n            System.out.println(", "\"下载完成\"", ");\n        }\n    }\n\n    ", "//登出", "\n    ", "public", " ", "void", " ", "LoginOut", "()", " {\n        System.out.println(", "\"End Test\"", ");\n\n        ", "if", " (loginHandle.longValue() != ", "0", ") {\n            netSdk.CLIENT_Logout(loginHandle);\n        }\n        System.out.println(", "\"See You...\"", ");\n\n        netSdk.CLIENT_Cleanup();\n        System.exit(", "0", ");\n    }\n\n    ", "/**\n     * 设备断线回调\n     */", "\n    ", "private", " ", "static", " ", "class", " ", "DisConnectCallBack", " ", "implements", " ", "NetSDKLib", ".fDisConnect {\n\n        ", "private", " ", "DisConnectCallBack", "()", " {\n        }\n\n        ", "private", " ", "static", " ", "class", " ", "CallBackHolder", " {\n            ", "private", " ", "static", " DowmLoadRecordFile.", "DisConnectCallBack", " ", "instance", " ", "=", " ", "new", " ", "DowmLoadRecordFile", ".DisConnectCallBack();\n        }\n\n        ", "public", " ", "static", " DowmLoadRecordFile.DisConnectCallBack ", "getInstance", "()", " {\n            ", "return", " DowmLoadRecordFile.DisConnectCallBack.CallBackHolder.instance;\n        }\n\n        ", "@Override", "\n        ", "public", " ", "void", " ", "invoke", "(NetSDKLib.LLong lLoginID, String pchDVRIP, ", "int", " nDVRPort, Pointer dwUser)", " {\n            System.out.printf(", "\"Device[%s] Port[%d] DisConnect!\\n\"", ", pchDVRIP, nDVRPort);\n        }\n    }\n\n\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "DowmLoadRecordFile", " ", "dowmLoadRecordFile", " ", "=", " ", "new", " ", "DowmLoadRecordFile", "();\n        dowmLoadRecordFile.init();\n        dowmLoadRecordFile.Login();\n        dowmLoadRecordFile.run(LocalDateTime.of(", "2021", ", Month.JULY, ", "26", ", ", "9", ", ", "37", ", ", "56", "), LocalDateTime.of(", "2021", ", Month.JULY, ", "26", ", ", "9", ", ", "38", ", ", "56", "));\n        dowmLoadRecordFile.LoginOut();\n    }\n}\n\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/CETET/article/details/128893442\" id=\"textarea_1679620618265_1679620677106_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/CETET/article/details/128893442&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在Linux下如何获取摄像头数据推流", ["在Linux下，我该如何获取摄像头数据，再将摄像头数据通过网络进行推流，进而实现实时视频监控的功能？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;avpacket 的 data 保存为 h264 是不正确的方式。avpacket 中的 data 是视频压缩数据的一部分&amp;#xff0c;需要进行解码才能得到原始图像数据。如果希望保存为 h264&amp;#xff0c;可以将 avpacket 中的压缩数据写入到一个编码器中&amp;#xff0c;编码成 h264 格式后再保存为文件。在代码中&amp;#xff0c;可以使用 libx264 之类的编码器进行编码。另外&amp;#xff0c;在编码之前需要设置编码器的参数&amp;#xff0c;包括分辨率、帧率、码率等等。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["拉取的流保存为h264无法播放 是为什么?", ["avpacket 的 data 不能直接保存为h264吗?", "\n", "\n", "#", "include", " ", "<thread>", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<fstream>", "\n", "extern", " ", "\"C\"", "\n{\n", "#", "include", " ", "<libavcodec/avcodec.h>", "\n", "#", "include", " ", "<libavcodec/bsf.h>", "\n", "#", "include", " ", "<libavformat/avformat.h>", "\n}\n\n", "#", "pragma", " comment(lib,", "\"avcodec.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avdevice.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avfilter.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avformat.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"avutil.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"swresample.lib\"", ")", "\n", "#", "pragma", " comment(lib,", "\"swscale.lib\"", ")", "\n\n", "int", " ", "mp4toannexb", "(AVBSFContext* bsf_ctx, AVPacket* pkt, std::ofstream& out)", "\n", "{\n    ", "int", " ret;\n\n    ret = ", "av_bsf_send_packet", "(bsf_ctx, pkt);\n    ", "if", " (ret < ", "0", ") {\n        std::cout << ", "\"bsf send packet failed, errno:\"", " << ret << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ", "for", " (;;) {\n        ret = ", "av_bsf_receive_packet", "(bsf_ctx, pkt);\n        ", "if", " (AVERROR_EOF == ret || ", "AVERROR", "(EAGAIN) == ret) {\n            ", "return", " ", "0", ";\n        }\n        ", "if", " (ret < ", "0", ") {\n            std::cout << ", "\"Could not receive packet, errno:\"", " << ret << std::endl;\n            ", "return", " ", "-1", ";\n        }\n        out.", "write", "((", "const", " ", "char", "*)pkt->data, pkt->size);\n    }\n    ", "return", " ", "0", ";\n}\n\n\n", "int", " ", "main", "()", "\n", "{\n    AVOutputFormat* ofmt = ", "NULL", ";\n    AVFormatContext* ifmt_ctx = ", "NULL", ";\n    AVBSFContext* bsf_ctx = ", "NULL", ";\n    AVPacket* pkt = ", "NULL", ";\n    ", "const", " ", "char", "* in_filename = ", "\"http://219.151.31.38/liveplay-kk.rtxapp.com/live/program/live/hnwshd/4000000/mnf.m3u8\"", ";\n    ", "int", " ret = ", "-1", ";\n    ", "int", " video_index = ", "-1", ";\n    ", "std::ofstream ", "outh264", "(", "\"D:\\\\ConsoleApplication1\\\\Debug\\\\out.h264\"", ", std::ios::binary | std::ios::trunc)", ";\n    ", "// 初始化网络", "\n    ", "avformat_network_init", "();\n\n    ", "// 初始化输入格式上下文  ", "\n    ", "if", " ((ifmt_ctx = ", "avformat_alloc_context", "()) == ", "NULL", ") {\n        std::cout << ", "\"avformat_alloc_context failed.\"", " << std::endl;\n        ", "exit", "(", "1", ");\n    }\n\n    ", "// 打开输入格式上下文", "\n    ", "if", " ((ret = ", "avformat_open_input", "(&ifmt_ctx, in_filename, ", "0", ", ", "0", ")) < ", "0", ") {\n        std::cout << ", "\"Could not open input file.\"", " << std::endl;\n        ", "exit", "(", "1", ");\n    }\n\n    ", "// 获取输入信息", "\n    ", "if", " ((ret = ", "avformat_find_stream_info", "(ifmt_ctx, ", "0", ")) < ", "0", ") {\n        std::cout << ", "\"Failed to retrieve input stream information\"", " << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ", "// 申请pkt", "\n    ", "if", " (!(pkt = ", "av_packet_alloc", "())) {\n        std::cout << ", "\"Could not allocate packet\"", " << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    video_index = ", "av_find_best_stream", "(ifmt_ctx, AVMEDIA_TYPE_VIDEO, ", "-1", ", ", "-1", ", ", "NULL", ", ", "0", ");\n    ", "if", " (video_index < ", "0", ") {\n        std::cout << ", "\"Could not find stream \"", " << std::", "string", "(", "av_get_media_type_string", "(AVMEDIA_TYPE_VIDEO)) << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ", "av_dump_format", "(ifmt_ctx, ", "0", ", in_filename, ", "0", ");\n\n    ", "const", " AVBitStreamFilter* filter = ", "av_bsf_get_by_name", "(", "\"h264_mp4toannexb\"", ");\n    ", "if", " (", "NULL", " == filter) {\n        std::cout << ", "\"Could not create filter\"", " << std::endl;\n        ", "return", " ", "-1", ";\n    }\n\n    ret = ", "av_bsf_alloc", "(filter, &bsf_ctx);\n    ", "if", " (ret < ", "0", ") {\n        ", "printf", "(", "\"Could not alloc bitstream filter \\n\"", ");\n        ", "return", " ", "-1", ";\n    }\n\n    ", "// avcodec_parameters_from_context", "\n    ret = ", "avcodec_parameters_copy", "(bsf_ctx->par_in, ifmt_ctx->streams[video_index]->codecpar);\n    ", "if", " (ret < ", "0", ") {\n        ", "printf", "(", "\"Parameter copy filed, errno: %d \\n\"", ", ret);\n        ", "return", " ", "-1", ";\n    }\n\n    ret = ", "av_bsf_init", "(bsf_ctx);\n    ", "if", " (ret < ", "0", ") {\n        ", "printf", "(", "\"BSF init failed, errno: %d \\n\"", ", ret);\n        ", "return", " ", "-1", ";\n    }\n\n    ", "while", " (", "av_read_frame", "(ifmt_ctx, pkt) >= ", "0", ") {\n        ", "if", " (pkt->stream_index == video_index)\n        {\n            ", "mp4toannexb", "(bsf_ctx, pkt, outh264);\n        }\n        ", "av_packet_unref", "(pkt);\n    }\n    ", "// 释放", "\n    outh264.", "close", "();\n    ", "avformat_close_input", "(&ifmt_ctx);\n    ", "av_packet_free", "(&pkt);\n    ", "av_bsf_free", "(&bsf_ctx);\n\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我觉得一个很简单的做法是&amp;#xff0c;在客户端就识别出类型&amp;#xff0c;传输的时候把文件类型一起带给你&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["java TCP通信中服务器怎么区分客户端发来的文件类型?", ["问题遇到的现象和发生背景", "\n", "我最近遇到一个问题，就是我学到TCP通信的时候，假如，我作为客户端发送文件给服务器的时候，如果这个文件是一个.jpg的照片，那么我就得在服务器的文件保存路径的末尾加上.jpg   。这样不就变成面向结果编程了嘛？因为我客服端发送的文件是随机格式的，那么服务端应该怎么区别并接收不同类型的文件呢？", "\n", "问题相关代码，请勿粘贴截图", "\n", "这是客户端的代码", "\n", "import", " java.net.Socket;\n", "import", " java.io.*;\n", "//   （主线程负责发消息，子线程负责收消息）", "\n", "public", " ", "class", " ", "Client", "{\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "try", " {\n            System.out.println(", "\"====客户端启动===\"", ");\n            ", "Socket", " ", "socket", " ", "=", " ", "new", " ", "Socket", "(", "\"127.0.0.1\"", ", ", "9998", ");\n            ", "new", " ", "ClientThread", "(socket).start();", "//新的线程 这个线程用于消息的接收", "\n\n\n            ", "//1.先将磁盘中的文件读到内存中来    （使用 字节输入流）", "\n            InputStream f=", "new", " ", "FileInputStream", "(", "\"E:\\\\Documets\\\\Desktop\\\\123.jpg\"", ");\n            BufferedInputStream br=", "new", " ", "BufferedInputStream", "(f);      ", "//包装成字节缓存输入流  传送速度快", "\n\n            ", "//2.将内存中文件数据 发送到网络介质上   （使用字节输出流）", "\n            ", "OutputStream", " ", "os", " ", "=", " socket.getOutputStream();     ", "//定义发送管道", "\n            ", "PrintStream", " ", "ps", " ", "=", " ", "new", " ", "PrintStream", "(os);           ", "//包装成打印流 速度更快！！！", "\n\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n            ", "int", " len;\n            ", "while", " ((len = br.read(buffer)) != -", "1", ") {             ", "//通过 缓存字节输入流 接收字节到 buffer中去 并记录数组中的长度len", "\n                ps.write(buffer, ", "0", ", len);          ", "//将buffer中的字节 通过打印流 发送到网络介质中去", "\n            }\n            ps.flush();\n            socket.shutdownOutput();            ", "//关闭io  而不关闭管道！", "\n            System.out.println(", "\"文件发给服务器成功！\"", ");\n\n            ", "// 关闭资源。", "\n            ", "//socket.close();", "\n\n        } ", "catch", " (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n\n", "\n", "这是 客户端 子线程的的代码", "\n", "import", " java.io.*;\n", "import", " java.net.Socket;\n\n", "//这个线程类  作为 接收客户端读服务器发来的消息", "\n", "public", " ", "class", " ClientThread ", "extends", " Thread {", "//线程类 要继承Thread 或者实现 Runnable 接口", "\n    ", "private", "  Socket  socket;              ", "//用来存套接字", "\n    ", "public", " ClientThread (Socket socket){   ", "//构造方法，用来接收  与服务器连接的管道对管道进行读操作", "\n        ", "this", ".socket = socket;\n    }\n    @Override\n    ", "public", " ", "void", " run() {", "//重写run方法", "\n        ", "try", " {\n            ", "//1.定义 字节输入流 从网络介质中获取数据存入内存中", "\n            InputStream is=socket.getInputStream();\n            BufferedInputStream br=", "new", " BufferedInputStream(is);      ", "//包装成字节缓存输入流  传送速度快", "\n\n            ", "//2. 定义 打印流将文件数据从内存中写入磁盘", "\n            ", "File", " ", "file", "=", "new", " ", "File", "(", "\"E:\\\\Documets\\\\Desktop\\\\客户\\\\服务器发来的.jpg\"", ");      ", "//选择保存路径", "\n            PrintStream ps = ", "new", " PrintStream(", "file", ");\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n            ", "int", " len;\n            ", "while", "( (len= br.", "read", "(buffer))!=-", "1", " ){\n                ps.", "write", "(buffer,", "0", ",len);             ", "//将文件写入上面的文件路径中去", "\n            }\n            ps.flush();\n            System.out.", "println", "(", "\"接收来自服务器的文件成功!\"", ");\n        } ", "catch", " (Exception e) {\n            System.out.", "println", "(", "\"与服务器断开连接！\"", ");\n        }\n\n\n    }\n}\n\n\n\n", "\n", "这是 服务器的代码", "\n", "import", " java.net.ServerSocket;\n", "import", " java.net.Socket;\n", "import", " java.util.ArrayList;\n", "import", " java.util.List;\n", "//使用两个线程 主线程 用于将连接过来的套接字 添加到集合 代表当前在线的人数", "\n", "public", " ", "class", " ", "Server", " {\n    ", "/*创建一个Socket的list集合 用来装套接字  Socket=（IP地址：端口号）   */", "\n    ", "public", " ", "static", " ", "final", " List<Socket> onLineSockets = ", "new", " ", "ArrayList", "<>();  ", "//当客户端连接上服务器的时候，就将客户端的套接字存入集合中", "\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "try", " {\n            System.out.println(", "\"===服务端启动成功===\"", ");\n            ", "// 1、注册端口", "\n            ", "ServerSocket", " ", "serverSocket", " ", "=", " ", "new", " ", "ServerSocket", "(", "9998", ");\n            ", "// a.定义一个死循环由主线程负责不断的接收客户端的Socket管道连接。", "\n            ", "while", " (", "true", ") {\n                ", "// 2、每接收到一个客户端的Socket管道，交给一个独立的子线程负责读取消息", "\n                ", "Socket", " ", "socket", " ", "=", " serverSocket.accept();\n                System.out.println(socket.getRemoteSocketAddress()+ ", "\"上线了！\"", ");\n                ", "//这里可以加上日志框架 打印日志", "\n                onLineSockets.add(socket);", "// 把当前客户端管道Socket加入到在线集合中去", "\n                ", "// 3、开始创建独立线程处理socket", "\n                ", "new", " ", "ServerThread", "(socket).start();\n            }\n        } ", "catch", " (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "\n", "这是服务器子线程的代码", "\n", "\n```java\n", "import", " java.io.*;\n", "import", " java.net.Socket;\n\n", "//创建线程类 本类用于数据的发送", "\n", "public", " ", "class", " ServerThread  ", "extends", "  Thread{\n    ", "private", "  Socket socket;\n\n    ", "public", " ServerThread  (Socket socket) {\n        ", "this", ".socket = socket;\n    }\n\n    @Override\n    ", "public", " ", "void", " run() { ", "//重写run方法", "\n        ", "try", " {\n            ", "//1. 定义字节输入流，用于将网络介质上的文件数据 输入到内存（接收来自某一客户的文件数据）", "\n            InputStream is=socket.getInputStream();\n            BufferedInputStream br=", "new", " BufferedInputStream(is);      ", "//包装成字节缓存输入流  传送速度快", "\n\n            ", "//2. 定义 打印流将文件数据从内存中写入磁盘  （接收来自客户端的文件 先存到服务器的磁盘下面）", "\n            ", "File", " ", "file", "=", "new", " ", "File", "(", "\"E:\\\\Documets\\\\Desktop\\\\服务器\\\\客户端发来的123.jpg\"", ");      ", "//服务器的保存路径", "\n            PrintStream ps0 = ", "new", " PrintStream(", "file", ");\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n            ", "int", " len;\n            ", "while", "((len= br.", "read", "(buffer))!=-", "1", "){\n                ps0.", "write", "(buffer ,", "0", " ,len);\n                ps0.flush();\n            }\n            socket.shutdownInput();\n            System.out.", "println", "(", "\"接收来自 \"", "+socket.getRemoteSocketAddress()+ ", "\"的文件成功！\\n\"", ");\n\n            ", "//将文件发给所有人", "\n            sendFileToAll(", "file", ");\n\n        } ", "catch", " (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n    ", "//将字符串进行发送", "\n    ", "private", " ", "void", " sendFileToAll(", "File", " ", "file", ") {\n        ", "try", " {\n            ", "//3.将服务器磁盘中的文件 输入到内存中来", "\n            InputStream is=", "new", " FileInputStream(", "file", ");       ", "//多态 子类对象 传给父类类型", "\n            BufferedInputStream br=", "new", " BufferedInputStream(is);      ", "//包装成字节缓存输入流  传送速度快", "\n\n             ", "//4.定义字节输出流 ，用于将内存中的文件 输出到网络上 （将文件发给别的客户）", "\n           OutputStream os=socket.getOutputStream();\n           PrintStream ps = ", "new", " PrintStream(os);            ", "//包装成打印流", "\n           ", "//BufferedOutputStream bos=new BufferedOutputStream(os);", "\n\n            ", "int", " len;\n            ", "byte", "[] buffer=", "new", " ", "byte", "[", "8192", "];\n           ", "// for (Socket onLineSocket : Server.onLineSockets) {", "\n                ", "// 除了自己的socket，其他socket我都发！！", "\n                ", "if", "(", "true", "){\n                    ", "while", " ((len=br.", "read", "(buffer))!=-", "1", ") {            ", "//通过 缓存字节输入流 接收字节到 buffer中去 并记录数组中的长度len", "\n                      ps.", "write", "(buffer, ", "0", " , len);          ", "//将buffer中的字节 通过打印流 发送到网络介质中去", "\n                    }\n                }\n          ", "//  }", "\n", "//            br.close();", "\n", "//            ps.close();", "\n            socket.shutdownOutput();\n            System.out.", "println", "(", "\"发送给所有客户成功！\"", ");\n        } ", "catch", " (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "\n", "真的不知道怎么解决 。", "因为服务器不知道网络介质上的文件 是什么格式的  所以应该怎么接收呢?", "\n", "\n", "\n", "运行结果及报错内容", "\n", "然后现在的问题就是，第二步到第三步，服务器怎么知道网络上的数据是.jpg格式？", "\n", "我的解答思路和尝试过的方法", "\n", "是不是要先用正则表达式先截取小数点后面的格式类型，然后作为消息发过先  然后再进行字符串的拼接，再创建服务器的文件对象？", "\n", "我想要达到的结果", "\n", "我希望能达到的效果是 ：客户端发送文件到服务器，然后服务器能区别文件格式并将他保存到服务器的磁盘下，然后再将磁盘的文件发回给客户端"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;011111011111101001111011111110  起始标志为01111110&amp;#xff0c;结束标志为01111110&amp;#xff0c;数据部分为011110111111&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["计算机网络HDLC成帧", ["用HDLC成帧方式将数据流0111101111110成帧得到什么"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;client.shutdownOutput();是关闭服务器连接&amp;#xff0c;关闭连接后 在通过输入流读取in.read();就会造成题主说的&amp;#34;获取不到Socket的返回值&amp;#34;的问题。&lt;br /&gt;按照如下代码块修改即可&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n//输出完后&amp;#xff0c;需要关闭socket的输出通道&amp;#xff0c;表示不存向服务端输出内容\nclient.shutdownOutput()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n//读取socket的返回值\nint readLen &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; in.read()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;\n这部分代码改为下面的代码&amp;#xff1a;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;\n&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;\n\n\n//读取socket的返回值\nint readLen &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; in.read()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n//输出完后&amp;#xff0c;需要关闭socket的输出通道&amp;#xff0c;表示不存向服务端输出内容\nclient.shutdownOutput()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["串口转网络调试组手能正常接受到返回数据，但是java的socket获取不到返回值", ["我使用的有人的串口服务器，调试助手都是的正常的，", "\n\n", "我使用java的socket给TCP的服务器发送数据，也是正常的，就是获取不到Socket的返回值", "\n\n", "下面是测试的代码", "\n\n", "\n", "    @Test\n    public void test1() throws IOException, InterruptedException {\n        //客户端\n        String send = SocketTools.send(\"192.168.0.7\", 26, \"8A0101119B\");\n        System.out.println(\"send = \" + send);\n    }", "\n\n", "下面是工具类", "\n\n", "\n", "​\npackage com.applida.util.socket;\n\nimport com.applida.util.TjStringUtil;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * @author JL\n * @version V1.0\n * @Description 用java.net.Socket进行Socket操作工具类\n */\npublic class SocketTools {\n\n    /**\n     * 发送数据\n     *\n     * @param host    ip地址\n     * @param port    端口\n     * @param content 内容\n     * @throws IOException\n     */\n    public static String send(String host, int port, String content) throws IOException {\n        Socket client = null;\n        String msg;\n        InputStream in = null;\n        OutputStream out = null;\n        if (StringUtils.isEmpty(host) || port == 0 || StringUtils.isEmpty(content)) {\n            return null;\n        }\n        //去除空字符串\n        content = content.replace(\" \", \"\");\n        try {\n            //创建连接\n            client = new Socket(host, port);\n            //设置超时时间\n            client.setSoTimeout(2000);\n            //socket返回的数据流\n            in = client.getInputStream();\n            //socket发送的流（输出流）\n            out = client.getOutputStream();\n            //content按16进制字符串发送\n            out.write(TjStringUtil.hexStrToBytes(content));\n            //输出完后，需要关闭socket的输出通道，表示不存向服务端输出内容\n            client.shutdownOutput();\n            //读取socket的返回值\n            int readLen = in.read();\n            System.out.println(\"返回值长度 = \" + readLen);\n            msg = receive(in);\n            return msg;\n        } catch (UnknownHostException uhe) {\n            uhe.printStackTrace();\n            throw new IOException(\"主机连接创建异常：\" + uhe.getMessage());\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            throw ioe;\n        } finally {\n            streamClose(in, out);\n            clientClose(client);\n        }\n    }\n\n    public static void streamClose(InputStream in, OutputStream out) {\n        //IOUtils.closeQuietly(in); 可用IOUtils工具类关闭流\n        if (in != null) {\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                System.out.println(\"关闭输入流异常：\" + ioe.getMessage());\n            }\n        }\n        if (out != null) {\n            try {\n                out.flush();\n                out.close();\n            } catch (IOException ioe) {\n                System.out.println(\"关闭输出流异常：\" + ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * 创建一个客户端Socket连接\n     *\n     * @param host ip地址\n     * @param port 端口号\n     * @return\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    private static Socket createClientSocket(String host, int port) throws UnknownHostException, IOException {\n        return new Socket(host, port);\n    }\n\n\n    private static void clientClose(Socket socket) {\n        if (socket != null && !socket.isClosed()) {\n            try {\n                socket.close();\n            } catch (IOException ioe) {\n                System.out.println(\"Socket关闭异常：\" + ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * 发送数据\n     *\n     * @param out\n     * @param content\n     * @return\n     * @throws IOException\n     */\n    public static OutputStream output(OutputStream out, String content) throws IOException {\n        try {\n//            out.write(content.getBytes(ENCODING));\n            out.write(TjStringUtil.hexStrToBytes(content));\n        } finally {\n            return out;\n        }\n    }\n\n    /**\n     * 接受返回的数据\n     *\n     * @param in\n     * @return\n     * @throws IOException\n     */\n    public static String input(InputStream in) throws IOException {\n        int len;\n        char[] b = new char[1024];\n        StringBuilder sb = new StringBuilder();\n        BufferedReader reader;\n        try {\n            //以字符流为主，如需字节流，则不需要BufferedReader和InputStreamReader，可以直接从InputStream中获取或采用对应缓冲包装类\n            reader = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n            while ((len = reader.read(b)) != -1) {\n                sb.append(b, 0, len);\n            }\n            //reader.close();\n        } finally {\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 接受服务器返回的数据\n     *\n     * @return 16进制字符串\n     */\n    public static String receive(InputStream is) {\n        try {\n            //客户端开始接受请求\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n            String result = br.readLine();\n            System.out.println(\"result = \" + result);\n//        byte[] buffer = new byte[128];\n//        int data;\n//        String result = null;\n//        try {\n//            int len = 0;\n//            while ((data = in.read()) > -1) {\n//                buffer[len++] = (byte) data;\n//            }\n//            byte[] copyValue = new byte[len];\n//            System.arraycopy(buffer, 0, copyValue, 0, len);\n//            result = TjStringUtil.bytesToString(copyValue);\n//            System.out.println(\"设备->电脑的数据 = \" + result);\n//        } catch (IOException e) {\n//            e.printStackTrace();\n//        }\n            return result;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n\n    public interface SocketFunction {\n        /**\n         * socket信息回调\n         *\n         * @param msg\n         */\n        void callback(String msg);\n    }\n\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String data = \"这是测试数据：\";\n        String send = send(\"192.168.0.7\", 26, \"8A0101119B\");\n        System.out.println(\"send = \" + send);\n        //测试时，请分别单独启动send和listen方法\n        //客户端\n//        send(\"192.168.0.7\", 26, \"8A0101119B\", new SocketFunction() {\n//            @Override\n//            public void callback(String msg) {\n//                System.out.println(data + msg);\n//            }\n//        });\n//        System.in.read();\n\n//        //服务端\n//        listen(8111, \"this is server test\", new SocketFunction() {\n//            @Override\n//            public void callback(String msg) {\n//                System.out.println(data + msg);\n//            }\n//        });\n    }\n\n}\n\n​"]], "Tag": "算法设计"}
{"Answer": "已经找到问题，问题出在JavaFX的application线程，需要给服务器也分配一个线程，否则两者会发生冲突，导致程序无法正常启动。\r\n具体修改程序代码如下,由于有人说看起来太复杂，稍作删减：\r\n\r\n\r\n```\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport java.util.*;\r\nimport javafx.application.Application;\r\nimport javafx.application.Platform;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.ScrollPane;\r\nimport javafx.scene.control.TextArea;\r\nimport javafx.stage.Stage;\r\n\r\npublic class net extends Application{\r\n\t//创建显示文本域\r\n\tprivate TextArea area = new TextArea();\r\n\t\r\n\tpublic void start(Stage primaryStage){\r\n\t\r\n\t\tScene scene = new Scene(new ScrollPane(area), 450,300);\r\n\t\tprimaryStage.setTitle(\"Test2_2Server\");\r\n\t\tprimaryStage.setScene(scene);\r\n\t\tprimaryStage.show();\r\n\t\t\r\n   \t//此处做修改，为服务器分配线程\r\n\t\tnew Thread(() -&gt;{\r\n\t\t\ttry {\r\n\t\t\t\t//创建一个服务器套接字\r\n\t\t\t\tServerSocket serverSocket = new ServerSocket(8000);\r\n\t\t\t\t\r\n\t\t\t\tarea.appendText(\"Server started at \" + new Date() + '\\n');\r\n\t\t\t\t\r\n\t\t\t\twhile (true){\r\n\t\t\t\t\t\r\n\t\t\t\t\t//监听\r\n\t\t\t\t\tSocket socket = serverSocket.accept();\r\n\r\n\t\t\t\t\t//创建进程\r\n\t\t\t\t\tHandleAClient task = new HandleAClient(socket);\r\n\t\t\t\t\t\r\n\t\t\t\t\t//开始运行\r\n\t\t\t\t\tnew Thread(task).start();\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch(IOException ex) {\r\n\t\t\t\tSystem.err.println(ex);\r\n\t\t\t}\r\n\t\t}).start();\r\n\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tlaunch(args);\r\n\t}\r\n\t\r\n\t//服务器端的任务类\r\n\tclass HandleAClient implements Runnable{\r\n\t\tprivate Socket socket;\r\n\t\t\r\n\t\tpublic HandleAClient(Socket socket1){\r\n\t\t\tthis.socket = socket1;\r\n\t\t}\r\n\t\t\r\n\t\tpublic void run(){\r\n\t\t\ttry {\r\n\t\t\t\t//创建输入输出流\r\n\t\t\t\tDataInputStream input = new DataInputStream(socket.getInputStream());\r\n\t\t\t\tDataOutputStream output = new DataOutputStream(socket.getOutputStream());\r\n\t\t\t\t\r\n\t\t\t\twhile (true){\r\n\t\t\t\t\t//获取客户端数据\r\n\t\t\t\t\tdouble annualInterestRate = input.readDouble();\r\n\t\t\t\t\tint numberOfYears = input.readInt();\r\n\t\t\t\t\tdouble loanAmount = input.readDouble();\r\n\t\t\t\t\t\r\n\t\t\t\t\t//计算偿还额\r\n\t\t\t\t\tdouble totalPayment = loanAmount * Math.pow(1 + annualInterestRate * 0.01, numberOfYears);\r\n\t\t\t\t\tdouble monthlyPayment = totalPayment / numberOfYears / 12;\r\n\t\t\t\t\t//将数据传送至客户端\r\n\t\t\t\t\toutput.writeDouble(monthlyPayment);\r\n\t\t\t\t\toutput.writeDouble(totalPayment);\r\n\t\t\t\t\t//输出\r\n\t\t\t\t\tPlatform.runLater(() -&gt;{\r\n\t\t\t\t\t\tarea.appendText(\"Annual Interest Rate:\" + annualInterestRate + '\\n');\r\n\t\t\t\t\t\tarea.appendText(\"Number Of Year:\" + numberOfYears + '\\n');\r\n\t\t\t\t\t\tarea.appendText(\"Loan Amount:\" + loanAmount + '\\n');\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tarea.appendText(\"Monthly Payment:\" + monthlyPayment + '\\n');\r\n\t\t\t\t\t\tarea.appendText(\"Total Payment:\" + totalPayment + '\\n');\r\n\t\t\t\t\t});\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (IOException ex) {\r\n\t\t\t\tex.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```", "Konwledge_Point": "网络中的流", "Question": ["初学Java网络编程socket，为何我的服务器打不开？", ["初学Java网络编程socket，写了个服务器，但是打不开，求指导。代码如下", "\n\n", " import java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport javafx.application.Application;\nimport javafx.application.Platform;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ScrollPane;\nimport javafx.scene.control.TextArea;\nimport javafx.stage.Stage;\n\npublic class Test2_2Server extends Application{\n    //创建显示文本域\n    private TextArea area = new TextArea();\n\n    public void start(Stage primaryStage){\n        area.setEditable(false);\n\n        Scene scene = new Scene(new ScrollPane(area), 450,300);\n        primaryStage.setTitle(\"Test2_2Server\");\n        primaryStage.setScene(scene);\n        primaryStage.show();\n\n        try {\n            //创建一个服务器套接字\n            ServerSocket serverSocket = new ServerSocket(8800);\n            Platform.runLater(() ->\n                area.appendText(\"Server started at \" + new Date() + '\\n'));\n\n            int clientNo = 1;\n            while (true){\n                //监听\n                Socket socket = serverSocket.accept();\n\n                area.appendText(\"Starting thread for client \" + clientNo + \" at \" + new Date() + '\\n');\n\n                //获取客户端地址\n                InetAddress inetAddress = socket.getInetAddress();\n                area.appendText(\"Client \" + clientNo + \"'s host name is \" + inetAddress.getHostName() + '\\n');\n                area.appendText(\"Client \" + clientNo + \"'s IP Address is \" + inetAddress.getHostAddress() + '\\n');\n\n                //创建进程\n                HandleAClient task = new HandleAClient(socket);\n\n                //开始运行\n                new Thread(task).start();\n\n                //客户端数加一\n                clientNo++;\n            }\n        }\n        catch(IOException ex) {\n            System.err.println(ex);\n        }\n\n\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n\n    //服务器端的任务类\n    class HandleAClient implements Runnable{\n        private Socket socket;\n\n        public HandleAClient(Socket socket1){\n            this.socket = socket1;\n        }\n\n        public void run(){\n            try {\n                //创建输入输出流\n                DataInputStream inputFromClient = new DataInputStream(socket.getInputStream());\n                DataOutputStream outputToClient = new DataOutputStream(socket.getOutputStream());\n\n                while (true){\n                    //获取客户端数据\n                    double annualInterestRate = inputFromClient.readDouble();\n                    int numberOfYears = inputFromClient.readInt();\n                    double loanAmount = inputFromClient.readDouble();\n\n                    //计算偿还额\n                    double totalPayment = loanAmount * Math.pow(1 + annualInterestRate * 0.01, numberOfYears);\n                    double monthlyPayment = totalPayment / numberOfYears / 12;\n                    //将数据传送至客户端\n                    outputToClient.writeDouble(monthlyPayment);\n                    outputToClient.writeDouble(totalPayment);\n                    //输出\n                    Platform.runLater(() ->{\n                        area.appendText(\"Annual Interest Rate:\" + annualInterestRate + '\\n');\n                        area.appendText(\"Number Of Year:\" + numberOfYears + '\\n');\n                        area.appendText(\"Loan Amount:\" + loanAmount + '\\n');\n\n                        area.appendText(\"Monthly Payment:\" + monthlyPayment + '\\n');\n                        area.appendText(\"Total Payment:\" + totalPayment + '\\n');\n                    });\n                }\n            }\n            catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n} \n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ovs-ofctl add-flow br0 arp,arp_tpa&amp;#61;10.159.11.21,actions&amp;#61;output:vnet0&lt;br /&gt;ovs-ofctl add-flow br0 ip,nw_dst&amp;#61;10.159.11.21,actions&amp;#61;output:vnet0&lt;br /&gt;ovs-ofctl add-flow br0 arp,arp_tpa&amp;#61;10.159.11.22,actions&amp;#61;output:vnet1&lt;br /&gt;ovs-ofctl add-flow br0 ip,nw_dst&amp;#61;10.159.11.22,actions&amp;#61;output:vnet1&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["相同网段下如何设置OVS流表使两个虚拟机互通？", ["两个虚拟机分别连接到同一OVS网桥的vnet0和vnet1端口，两个虚拟机的IP分别为10.159.11.21和10.159.11.22。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个问题的原因是访问的时候浏览器自动进行了url编码。只需要在获取参数的地方进行解码就可以了。&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/516791391566188.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["Java简易服务器中文乱码", ["Java简易服务器中文乱码", "\n", "\n", "\n", "import java.io.*;", "\n", "import java.net.ServerSocket;", "\n", "import java.net.Socket;", "\n", "public class DemoTCPServer {", "    public static void main(String[] args) throws IOException {", "        ServerSocket ss = new ServerSocket(6667);//构造服务器", "        while (true) {", "\n", "        Socket iouse01 = ss.accept", "()", ";", "//服务器保持监听状态", "\n        ", "new", " ", "Thread(", "new", " Runnable()", " {", "//每加载一次图片创建一个线程", "\n            @Override\n            public void run", "()", " {\n                ", "try", " {\n                    InputStream ips = iouse01.get", "InputStream()", ";", "//接收客户端请求的字节流", "\n                    InputStreamReader ipsr = ", "new", " ", "InputStreamReader(", "ips", ")", ";\n                    BufferedReader bis = ", "new", " ", "BufferedReader(", "ipsr", ")", ";", "//将接收的字节流转换为字符流并缓冲", "\n\n                    ", "//获取客户端请求路径", "\n                    String s = bis.read", "Line()", ";\n                    ", "System", ".", "out.println(s);\n                    String", "[]", " arr = s.split(", "\" \"", ");\n                    String htmlpath = arr", "[", "1", "]", ".substring(", "1", ");\n\n                    FileInputStream fis = ", "new", " ", "FileInputStream(", "htmlpath", ")", ";", "//本地字节流读取硬盘字节数据", "\n                    OutputStream ops = iouse01.get", "OutputStream()", ";", "//获取网络输出流对象", "\n                    ", "//HTTP固定请求头代码", "\n                    ops.write(", "\"HTTP/1.1 200 OK\\r\\n\"", ".get", "Bytes()", ");\n                    ", "// 解决方法：正确告诉浏览器发送的内容是什么编码的", "\n                    ops.write(", "\"Content-Type:text/html\\r\\n\"", ".get", "Bytes()", ");\n                    ops.write(", "\"\\r\\n\"", ".get", "Bytes()", ");\n\n                    ", "//读取本地目的文件并输出", "\n                    byte", "[]", " ", "bytes", " = ", "new", " byte", "[", "1024", "]", ";\n                    ", "int", " len;\n                    ", "while", " ((len = fis.read(", "bytes", ")) != -", "1", ") {\n                        ops.write(", "bytes", ", ", "0", ", len);\n                    }\n\n                    fis.close", "()", ";\n                    iouse01.close", "()", ";\n\n                } catch (IOException e) {\n                    e.print", "StackTrace()", ";\n                }\n\n            }\n        }).start", "()", ";\n\n    }\n\n\n}\n", "\n", "} ", "\n", "\n", "使用原始ie浏览器访问我的服务器，遇到中文就返回乱码", "\n", "我尝试过把浏览器返回的字节码打印出来，中文字节码转为字符打印的是乱码，英文字母正常，", "\n", "字节流转换字符流之后还是和原来的一样中文乱码", "\n", "望大能给个解决思路，感谢！！"]], "Tag": "算法设计"}
{"Answer": "你的目录用错了，不能直接\"/storage/emulated/0/\"这样写，用\r\nEnvironment.getExternalStorageDirectory()来获取Sdcard根目录\r\n另外，需要加上写Sdcard的权限 ，你只是加了read_extranal_stroage，需要加上write_extranal_stroage", "Konwledge_Point": "网络中的流", "Question": ["android从网络上下载图片，写入手机时错误？求解", [" String s = params[0];\n", "\n\n", "//            Toast.makeText(activity,s,Toast.LENGTH_SHORT).show();", "\n            try {", "\n                URL url = new URL(s);", "\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection(); //打开连接", "\n                int size = conn.getContentLength();//获取文件大小", "\n                //0标记表示需要更新最大进度值，1表示更新当前下载的进度取", "\n                publishProgress(0,size);", "\n                byte[] bytes = new byte[20];", "\n                int len = -1;", "\n                InputStream inputStream = conn.getInputStream(); //读取数据流", "\n                FileOutputStream fileOutputStream = new FileOutputStream(\"/storage/emulated/0/\"+ System.currentTimeMillis()+\".jpg\");", "\n                while ((len=inputStream.read(bytes)) != -1){", "\n                    fileOutputStream.write(bytes,0,len);", "\n                    publishProgress(1,len); //更新进度", "\n                    fileOutputStream.flush();", "\n                   // Thread.sleep(500);", "\n                }", "\n               fileOutputStream.close();", "\n                inputStream.close();", "\n            } catch (MalformedURLException e) {", "\n                e.printStackTrace();", "\n            } catch (IOException e) {", "\n                e.printStackTrace();", "\n            }", "\n\n", "                    提示以下错误：java.io.FileNotFoundException: /storage/emulated/0/1483081566430.jpg: open failed: EACCES (Permission denied)\n                    本人使用小米5s真机, <uses-permission android:name=\"android.permission.INTERNET\"></uses-permission>\n<uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"></uses-permission>权限都添加了。求解\n"]], "Tag": "算法设计"}
{"Answer": "如果是海康、大华的摄像头可以对接他们的第三方接口实现控制摄像头功能，包括方向控制，视频录制、录制回放等等等等功能。搞清楚摄像头版本，对对应厂商官网下载他们的SDK和文档，pc端和移动端都有，前段时间刚对接过海事康威的摄像头。", "Konwledge_Point": "网络中的流", "Question": ["录制摄像头画面的方法", ["想要录制网络摄像头的画面，比如海康，大华的rtsp流", "\n\n", "推荐用的平台（Linux/Windows），流媒体库(VLC/FFMPEG/LIVE55)，", "\n需要的知识,  开发环境"]], "Tag": "算法设计"}
{"Answer": "已经有答案了，可以查看环回检测的相关原理", "Konwledge_Point": "网络中的流", "Question": ["交换机环回检测功能是如何对vlan进行检测的（关于网络、交换机、数据通信的）", ["\n\n", "交换机配置如下：", "\n\n", "一、  Port1, port 2, port 3 ,port 4 默认在vlan1 中，是hybrid untagged的，pvid是1", "\n\n", "二、  Port 1，port2以hybrid tagged 加入vlan 10", "\n\n", "三、  Port3,port4以hybrid  untagge加入vlan 10，并使能环回检测功能，检测vlan为vlan 1 和vlan 10", "\n\n", "现想咨询如下问题", "\n\n", "仪表端口A发送带vlan10未知单播流（假如发送1000个数据包），在端口A、B抓包", "\n\n", "一、仪表端口A收到1000个数据包，不带vlan标签", "\n\n", "仪表端口B收到2000个数据包，", "\n\n", "其中1000个为vlan 10，其中1000个不带vlan", "\n\n", "二、如果将port 3，port 4 改为以hybrid tagged 加入vlan 10 ", "\n\n", "则仪表端口A不会收到自己发出去的1000个数据;", "\n\n", "仪表端口B会收到1000个数据包，带vlan 10", "\n\n", "三、如果将port 3，port 4的pvid改为10，", "\n\n", "则仪表端口A不会收到自己发出去的1000个数据;", "\n\n", "仪表端口B会收到1000个数据包，带vlan 10", "\n\n", "以上这些问题应该和环回检测有关，我想知道端口3和端口4是如何进行vlan检测的；", "\n数据包在经过端口3和端口4是如何传输的"]], "Tag": "算法设计"}
{"Answer": "在用HttpURLConnection的时候，没有设置默认编码，可能是utf-8和 \"ISO-8859-1\"混淆了。\r\n然后模拟器和手机不一样的原因是；Android版本不一样导致HttpURLConnection的具体实现不一样，记得Android4.4之后，HttpURLConnection底层采用HttpOK了。", "Konwledge_Point": "网络中的流", "Question": ["android客户端解析json，出现乱码 ( 没有中文 ) ，请大神指点", ["本人使用Tomcat apache-tomcat-8.0.28虚拟服务器，默认utf-8编码", "\n\n", "update.json", "\n\n", "{\"versionName\":\"2.0\",\"versionCode\":2,\"description\":\"Hello word!!\",\"downloadUrl\":\"", "http://www.baidu.com\"", "}", "\n\n", "android studio 1.3.1 做了个客户端：部分编码如下:", "\n\n", "private void checkVersion(){", "\n        new Thread(){", "\n            @Override", "\n            public void run() {", "\n\n", "            try {\n                URL url = new URL(\"http://10.0.2.2:8080/update.json\");\n                HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setRequestMethod(\"GET\");\n                conn.setConnectTimeout(5000);\n                conn.setReadTimeout(5000);\n                conn.connect();\n\n                int responseCode = conn.getResponseCode();\n\n                if(responseCode==200){\n                    InputStream inputStream = conn.getInputStream();\n                    String result = StreamUtils.readFromSteam(inputStream);\n                    Log.e(\"System.Out.Print\", \"result:\"+result);\n\n                    //解析Json\n\n                    JSONObject jo = new JSONObject(result);\n                    mVersionName = jo.getString(\"versionName\");\n                    mVersionCode = jo.getInt(\"versionCode\");\n                    mDescription = jo.getString(\"description\");\n                    mDownloadUrl = jo.getString(\"downloadUrl\");\n\n\n                    Log.e(\"System.Out.Print\", \"run \"+mVersionName+\";\"+mVersionCode);\n                    Log.e(\"System.Out.Print\", \"run \"+mDescription+\";\"+mDownloadUrl);\n                }\n\n            } catch (MalformedURLException e) {\n               // utl错误的异常\n\n                e.printStackTrace();\n            } catch (IOException e) {\n                //网络错误的异常\n\n                e.printStackTrace();\n            }\n            catch (JSONException e) {\n                e.printStackTrace();\n            }\n        }\n    }.start();\n}\n", "\n\n", "public class StreamUtils {", "\n\n", "/**\n * readFromSteam() 将输入流读成String后返回\n * @return\n */\npublic static String readFromSteam(InputStream in) throws IOException {\n\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    int len = 0;\n    byte[] buffer = new byte[1024];\n\n    while((len=in.read())!=-1){\n        out.write(buffer,0,len);\n    }\n        String result = out.toString();\n        in.close();\n        out.close();\n    return result;\n    }\n\n}\n\n\n    每次运行后的结果如下：\n\n    ![图片说明](https://img-ask.csdn.net/upload/201602/21/1456069188_115538.jpg)\n\n\n    请大神指点\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你可以用一个Task  或者backgroundWork来做&amp;#xff0c;直接在主线程while 会卡死主线程的&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["写了一个网络通讯的程序，按第三个按钮就会卡死，请大师解答一下，谢谢了，搞了好几天", ["    public partial class Form1 : Form", "\n    {", "\n        private TcpListener server;", "\n        private Thread receive_thread;", "\n\n", "        public Form1()", "\n        {", "\n            InitializeComponent();", "\n            RichTextBox.CheckForIllegalCrossThreadCalls = false;", "\n        }", "\n        private void receive()", "\n        {", "\n            server = new TcpListener(IPAddress.Parse(textBox1.Text), Int32.Parse(textBox2.Text));", "\n            server.Start(); //启动监听", "\n            label8.Text = \"正在监听......\";", "\n            while (true)", "\n            {", "\n                TcpClient theClient = server.AcceptTcpClient(); //接收挂起的连接请求", "\n                NetworkStream theStream = theClient.GetStream();//取得接收数据的网络流", "\n                Byte[] messageByte = new byte[1024];", "\n                theStream.Read(messageByte, 0, messageByte.Length);", "\n                string readMessage = System.Text.Encoding.BigEndianUnicode.GetString(messageByte);", "\n                richTextBox1.AppendText(readMessage);", "\n            }", "\n        }", "\n\n", "        private void button1_Click(object sender, EventArgs e)", "\n        {", "\n            //判断IP地址和端口是否合法", "\n            try", "\n            {", "\n                IPAddress.Parse(textBox1.Text);", "\n                Int32.Parse(textBox2.Text);", "\n            }", "\n            catch (Exception err)", "\n            {", "\n                MessageBox.Show(err.ToString());", "\n                return;", "\n            }", "\n            //如果监听线程已经在运行中，则返回", "\n            if (receive_thread != null && receive_thread.ThreadState == ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"正在监听中......\");", "\n                return;", "\n            }", "\n            try", "\n            {", "\n                receive_thread = new Thread(new ThreadStart(receive));", "\n                receive_thread.Start();", "\n            }", "\n            catch (Exception err)", "\n            {", "\n                MessageBox.Show(err.ToString());", "\n            }", "\n        }", "\n\n", "        private void Form1_Load(object sender, EventArgs e)", "\n        {", "\n            MessageBox.Show(\"请输入监听端IP地址，端口号请保持一致!\\n发送端为自身IP\");", "\n            string name = Dns.GetHostName();", "\n            IPAddress[] ipadrlist = Dns.GetHostAddresses(name);", "\n            textBox3.Text = ipadrlist[2].ToString();", "\n            textBox1.Text = ipadrlist[2].ToString();", "\n        }", "\n\n", "        private void Form1_FormClosing(object sender, FormClosingEventArgs e)", "\n        {", "\n            //如果监听线程扔在运行，则不能关闭", "\n            if (receive_thread != null && receive_thread.ThreadState == ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"请先停止监听再关闭本程序。\");", "\n                e.Cancel = true;", "\n            }", "\n        }", "\n\n", "        private void button2_Click(object sender, EventArgs e)", "\n        {", "\n            //判断IP地址和端口是否合法", "\n            try", "\n            {", "\n                IPAddress.Parse(textBox3.Text);", "\n                Int32.Parse(textBox4.Text);", "\n            }", "\n            catch (Exception err)", "\n            {", "\n                MessageBox.Show(err.ToString());", "\n                return;", "\n            }", "\n            //如果没有启动监听，则返回", "\n            if (receive_thread == null || receive_thread.ThreadState != ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"请先启动监听。\");", "\n                return;", "\n            }", "\n            //创建客户端并发送连接请求", "\n            TcpClient theClient = new TcpClient(textBox3.Text, Int32.Parse(textBox4.Text));", "\n            string send = richTextBox2.Text + \"\\r\\n\";", "\n            //转换编码格式", "\n            byte[] messageByte = System.Text.Encoding.BigEndianUnicode.GetBytes(send.ToCharArray());", "\n            NetworkStream theStream = theClient.GetStream();    //取得发送数据的网络流", "\n            theStream.Write(messageByte, 0, messageByte.Length);//写数据", "\n            theStream.Close();  //关闭流", "\n            theClient.Close();  //关闭客户端", "\n\n", "        }", "\n\n", "        private void button3_Click(object sender, EventArgs e)", "\n        {", "\n            //如果没有启动监听，则返回", "\n            if (receive_thread == null || receive_thread.ThreadState != ThreadState.Running)", "\n            {", "\n                MessageBox.Show(\"监听没有开始。\");", "\n                return;", "\n            }", "\n            if (receive_thread != null && receive_thread.ThreadState == ThreadState.Running)", "\n            {", "\n                try", "\n                {", "\n                    receive_thread.Abort();", "\n                }", "\n                catch(Exception err)", "\n                {", "\n                    MessageBox.Show(err.ToString());", "\n                }", "\n                ", "\n            }", "\n            if (server != null)", "\n            {", "\n                server.Stop();", "\n            }", "\n        }", "\n    }", "\n\n", " "]], "Tag": "算法设计"}
{"Answer": "public String appendSpace(String  para){\r\n\t\tint length = para.length();\r\n\t\tchar[] value = new char[length &lt;&lt; 1];\r\n\t\tfor (int i=0, j=0; i&lt;length; ++i, j = i &lt;&lt; 1) {\r\n\t\t\tvalue[j] = para.charAt(i);\r\n\t\t\tvalue[1 + j] = ' ';\r\n\t\t}\r\n\t\treturn new String(value);\r\n\t}\r\n\r\n这就是最简单，也是最高效的方法，这样的问题也要用低效的正则？", "Konwledge_Point": "网络中的流", "Question": ["在每个字符后面加空格", ["String str1 = \"里面将图片保存到本地，到网络上搜索了一下，方法都差不多，大同小异，把输入流转换成输出流的过程而已。\"; ", "\n想在字符串里面的每个字后面添加一个空格，我用正则如下：", "\n   String after1 = str1.replaceAll(\"\\S\" , \"\\S \"); ", "\n   System.out.println(after1); 发现字符串里面的字符全面变成了“S ”。", "\n   正则可以搞定这个问题吗？除了正则，看看还有什么方法？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1.服务端中while循环调不出来的原因是服务端在接收完所有数据后&amp;#xff0c;需要手动关闭输入流is&amp;#xff0c;关闭方法为is.close()&amp;#xff0c;不然服务端会一直等待客户端继续向它传输数据&amp;#xff0c;而不会跳出循环。&lt;br /&gt;2.在客户端&amp;#xff0c;出现阻塞状态的原因是服务端关闭&amp;#xff0c;而客户端在等待服务端发送数据&amp;#xff0c;如果一直没有关闭连接&amp;#xff0c;此时可以在服务端发送完数据后&amp;#xff0c;调用socket.shutdownOutput()方法&amp;#xff0c;表示输出流关闭&amp;#xff0c;通知客户端数据已全部发送完毕&amp;#xff0c;客户端此时可以正常退出程序。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["java刚学网络编程客户端和服务端出现的疑问", ["我的程序：客户端发送一张图片到服务端，服务端接收后发送一条信息给客户端，客户端收到信息后关闭程序，同样服务端也关闭了", "（1）出现的问题：1.在服务端一直调不出来while循环，为什么？", "2.在客户端因为服务端跳不出循环，导致一直在阻塞状态", "\n", "客户端程序", "\n", "package", " TCP_FileCopy;\n\n", "import", " java.io.*;\n", "import", " java.net.InetAddress;\n", "import", " java.net.Socket;\n", "public", " ", "class", " ", "TCP_Client", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " ", "throws", " IOException {\n        String pathSent=", "\"D:\\\\null_.jpg\"", ";\n        ", "//1.建立端口连接", "\n        Socket socket=", "new", " ", "Socket", "(InetAddress.getLocalHost(),", "8888", ");\n        ", "//定义发送的流,一个是输入流，用于读取文件FileInputStream fis=new FileInputStream(\"D:\\\\null_.jpg\");", "\n        ", "// 一个是输出流，用于发送文件 OutputStream ops= socket.getOutputStream();", "\n        OutputStream ops= socket.getOutputStream();\n        FileInputStream fis=", "new", " ", "FileInputStream", "(", "\"D:\\\\null_.jpg\"", ");\n\n\n        ", "BufferedInputStream", " ", "bis", " ", "=", " ", "new", " ", "BufferedInputStream", "(fis);\n        ", "BufferedOutputStream", " ", "bos", " ", "=", " ", "new", " ", "BufferedOutputStream", "(ops);\n        ", "byte", "[] bytes=", "new", " ", "byte", "[", "1024", "];\n        ", "int", " readline;\n        ", "while", "((readline= bis.read(bytes))!=-", "1", "){\n            bos.write(bytes,", "0", ",readline);\n        }\n        bos.flush();\n        System.out.println(", "\"Client发送图片成功！\"", ");\n        ", "//定义一个流用于接收对方发来的字符流图片", "\n        ", "BufferedReader", " ", "bufferedReader", " ", "=", " ", "new", " ", "BufferedReader", "(", "new", " ", "InputStreamReader", "(socket.getInputStream()));\n        String s= bufferedReader.readLine();\n        System.out.println(s);\n\n        ", "//读完之后关闭所有的流文件", "\n        System.out.println(", "\"任务完成\"", ");\n        bufferedReader.close();\n        fis.close();\n        ops.close();\n        socket.close();\n    }\n}\n\n\n", "\n", "服务端程序", "\n", "package", " TCP_FileCopy;\n\n", "import", " com.sun.corba.se.spi.orbutil.fsm.Input;\n\n", "import", " java.io.*;\n", "import", " java.net.ServerSocket;\n", "import", " java.net.Socket;\n\n", "public", " ", "class", " ", "TCP_Server", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " ", "throws", " IOException {\n        ", "//输出到目标文件的敌方", "\n        String s=", "\"src\\\\null2.jpg\"", ";\n        ", "//先建立一个端口", "\n        ServerSocket sockets=", "new", " ", "ServerSocket", "(", "8888", ");\n\n        ", "//建立一个连接", "\n        System.out.println(", "\"已建立端口，等待连接\"", ");\n        Socket socket=sockets.accept();\n\n        ", "//建立字节输入流，用于接收文件。输出流，用于创建文件", "\n        InputStream is= socket.getInputStream();\n        ", "BufferedInputStream", " ", "bis", " ", "=", " ", "new", " ", "BufferedInputStream", "(is);\n        OutputStream os=", "new", " ", "FileOutputStream", "(s);\n        ", "BufferedOutputStream", " ", "bos", " ", "=", " ", "new", " ", "BufferedOutputStream", "(os);\n        ", "byte", "[] bytes=", "new", " ", "byte", "[", "1024", "];\n        ", "int", " readline;\n        System.out.println(", "\"已接受文件，正在拷贝\"", ");\n        ", "while", "((readline=bis.read(bytes))!=-", "1", "){\n            bos.write(bytes,", "0", ",readline);\n        }\n        System.out.println(", "\"拷贝成功\"", ");\n\n        ", "//建立输入流，用于接收服务端发送的文字", "\n        ", "BufferedWriter", " ", "bufferedWriter", " ", "=", " ", "new", " ", "BufferedWriter", "(", "new", " ", "OutputStreamWriter", "(socket.getOutputStream()));\n        bufferedWriter.write(", "\"Server收到图片\"", ");\n        bufferedWriter.newLine();\n", "//        bufferedWriter.flush();", "\n", "//        socket.shutdownOutput();", "\n        bufferedWriter.close();\n        ", "//关闭所有的流", "\n        os.close();\n        is.close();\n        ", "//bufferedWriter.close();", "\n        ", "//socket.close();", "\n        sockets.close();\n    }\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "发现问题了，是Android 9.0 ban了 http只能用https了，解决方案见大佬的文章[Android9.0 http网络请求失败问题分析与解决方案](https://blog.csdn.net/freak_csh/article/details/86100031 \"\")", "Konwledge_Point": "网络中的流", "Question": ["Android Studio 应用无法访问本地服务器", ["代码在android studio 模拟器运行后本地服务器监听不到访问，可以确定后端代码没有问题，并且模拟器网络正常，可以使用模拟器里的浏览器访问服务器。", "\n应用也添加了网络访问权限。", "\n\n", " <uses-permission android:name=\"android.permission.INTERNET\" />\n", "\n\n", "代码：", "\n\n", "public class MainActivity extends AppCompatActivity {\n\n    private TextView tvContent;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        tvContent = (TextView) findViewById(R.id.test1); // 这里页面上就一个简单的TextView，用于展示获取到报文内容\n        requestUsingHttpURLConnection();\n    }\n\n    private Handler handler = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            if(msg.what == 1){\n                tvContent.setText(msg.obj.toString());\n            }\n        }\n    };\n\n\n    private void requestUsingHttpURLConnection() {\n        // 网络通信属于典型的耗时操作，开启新线程进行网络请求\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                HttpURLConnection connection = null;\n                try {\n                    URL url = new URL(\"http://10.0.2.2:8080/ServletTest/RegisterServlet?account=123&password=abc\"); // 声明一个URL,注意——如果用百度首页实验，请使用https  //http://10.20.4.178:8080/ServletTest/RegisterServlet?account=123&password=abc\n                    Log.d(\"test\",  \"开始连接\");\n                    connection = (HttpURLConnection) url.openConnection(); // 打开该URL连接\n                    connection.setRequestMethod(\"GET\"); // 设置请求方法，“POST或GET”，我们这里用GET，在说到POST的时候再用POST\n\n                    connection.setConnectTimeout(8000); // 设置连接建立的超时时间\n                    connection.setReadTimeout(8000); // 设置网络报文收发超时时间\n\n                    InputStream in = connection.getInputStream();  // 通过连接的输入流获取下发报文，然后就是Java的流处理\n                    Log.d(\"test\",  \"获取连接\");\n                    BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                    StringBuilder response = new StringBuilder();\n                    String line;\n                    while ((line = reader.readLine()) != null) {\n                        response.append(line);\n                    }\n\n                    Message msg = new Message();\n                    msg.what = 1;\n                    msg.obj = response.toString();\n                    Log.d(\"test\",  response.toString());\n                    handler.sendMessage(msg);\n\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n}\n", "\n\n", "URL应该没有问题，我通过日志输出的URL可以在模拟器浏览器成功访问服务器", "\n\n", "public class Consatant {\n    public static String URL = \"http://10.0.2.2:8080/ServletTest/\"; // IP地址请改为你自己的IP\n\n    public static String URL_Register = URL + \"RegisterServlet\";\n    public static String URL_Login = URL + \"LoginServlet\";\n\n}\n"]], "Tag": "算法设计"}
{"Answer": "TCP 因为是长连接的，肯定是有序的。数据接收不完整，这种现象在通讯中很常见的，是必须代码处理。", "Konwledge_Point": "网络中的流", "Question": ["Java Socket 读取TCP服务端数据包不完整", ["Java Socket 读取TCP服务端数据包不完整：除了利用数据包大小循环读取输入流的得到完整的数据外，还有其他什么方法？", "\n\n", "数据包在网络传输的过程中，数据传递到客户端基本处于“无序”态。除了开辟一块内存按数据包的顺序存放外，还有其他更好的方案么？"]], "Tag": "算法设计"}
{"Answer": "linux系统有文件系统缓冲，也就是实际上会写入内存，然后才写入硬盘。固态硬盘按照块去写入，一般一个块有4kb甚至更大。如果你更新这个地址范围内哪怕一个字节，都需要把整个块全部写一次。这不但降低了性能，而且极大造成了固态硬盘不必要的磨损，导致硬盘寿命大大减少。\r\n操作系统的缓存机制使得你对相邻的地址改写后，其实都在内存操作，再一次性写入硬盘，这是一种必要的优化。如果你的linux系统可以配置，你可以想办法关掉缓存，立刻写入数据，但是强烈不推荐你这么做。", "Konwledge_Point": "网络中的流", "Question": ["linux系统下，做的视频记录仪，写入固态硬盘的数据量比实际的小很多的问题", ["楼主是个linux新菜鸟，目前在做一个linux系统下的视频记录仪，记录H264的视频，简单说就是从网络读取视频流写入固态硬盘，固态硬盘挂载到linux系统的/MNT下，现在有个问题就是屏幕打印实际读取的数据量例如为12345678字节，如果正常接收关闭信号，关闭文件退出系统则固态硬盘里的数据量与实际相差无几，但一旦是直接关电那么固态硬盘内数据就少很多，最多少过50几秒的视频数据，平均码流是1.5mBPS", "\n\n", "程序简单历程就是", "\nrecv从网络读取  buf【2048】", "\nfwrite讲buf写入已挂载的硬盘里打开的文件", "\n\n", "有关机信号", "\n关闭文件，umount，退出系统"]], "Tag": "算法设计"}
{"Answer": "Set&lt;Map.Entry&lt;String, String&gt;&gt; p= param.entrySet(); //这么些OK了 for(Map.Entry s: p ){\r\n已经解决~", "Konwledge_Point": "网络中的流", "Question": ["java的类型转换报错，显示类型不匹配", ["\n\n\n\n\n\n package com.example.weather;\n\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\nimport java.util.jar.Attributes;\n/**\n * 网络访问工具类\n * @author silk\n *\n */\npublic class PostGet {\n    /**\n     * get方法直接调用post方法\n     * @param url 网络地址\n     * @return 返回网络数据\n     */\n    public static String get(String url){\n        return post(url,null);\n    }\n    /**\n     * 设定post方法获取网络资源,如果参数为null,实际上设定为get方法\n     * @param url 网络地址\n     * @param param 请求参数键值对\n     * @return 返回读取数据\n     */\n   public static  String post(String  url,Map param){\n        HttpURLConnection conn=null;\n        try {\n            URL u=new URL(url);\n            conn=(HttpURLConnection) u.openConnection();\n            //返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。\n            StringBuffer sb = null;\n            if(param!=null){//如果请求参数不为空\n                sb=new StringBuffer();\n                /*A URL connection can be used for input and/or output.  Set the DoOutput\n                 * flag to true if you intend to use the URL connection for output,\n                 * false if not.  The default is false.*/\n                //默认为false,post方法需要写入参数,设定true\n                conn.setDoOutput(true);\n                //URL 连接可用于输入和/或输出。如果打算使用 URL 连接进行输出，\n                //则将 DoOutput 标志设置为 true；如果不打算使用，则设置为 false。默认值为 false。\n                //设定post方法,默认get\n                conn.setRequestMethod(\"POST\");\n                //获得输出流\n                OutputStream out=conn.getOutputStream();\n                //对输出流封装成高级输出流\n                BufferedWriter writer=new BufferedWriter(new OutputStreamWriter(out));\n                //将参数封装成键值对的形式\n\n\n\n                for(Map.Entry s:param.entrySet()){\n\n\n\n                    sb.append(s.getKey()).append(\"=\").append(s.getValue()).append(\"&\");\n                }\n                //将参数通过输出流写入\n                writer.write(sb.deleteCharAt(sb.toString().length()-1).toString());\n                writer.close();//一定要关闭,不然可能出现参数不全的错误\n                sb=null;\n            }\n            conn.connect();//建立连接\n            sb=new StringBuffer();\n            //获取连接状态码\n            int recode=conn.getResponseCode();\n            BufferedReader reader=null;\n            if(recode==200){\n                //Returns an input stream that reads from this open connection\n                //从连接中获取输入流\n                InputStream in=conn.getInputStream();\n                //对输入流进行封装\n                reader=new BufferedReader(new InputStreamReader(in));\n                String str=null;\n                sb=new StringBuffer();\n                //从输入流中读取数据\n                while((str=reader.readLine())!=null){\n                    sb.append(str).append(System.getProperty(\"line.separator\"));\n                }\n                //关闭输入流\n                reader.close();\n                if (sb.toString().length() == 0) {\n                    return null;\n                }\n                return sb.toString().substring(0,\n                        sb.toString().length() - System.getProperty(\"line.separator\").length());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }finally{\n            if(conn!=null)//关闭连接\n                conn.disconnect();\n        }\n        return null;\n    }\n\n}\n", "\n\n", "隔空的for循环行报错：类型不匹配：不能从元素类型 Object 转换为 Map.Entry", "\n不知如何解决 以及为何会报错。望解惑 万分感谢！"]], "Tag": "算法设计"}
{"Answer": "java.io.FileNotFoundException: http://www.xxx.com/xxx/downloadFile/1二维码.png\r\n不都给你报错了吗？", "Konwledge_Point": "网络中的流", "Question": ["当输出0000000000000后停止运行要如何处理？", ["如下代码：", "\n\n", "String url = \"", "http://www.xxx.com/xxx/downloadFile/", "\" + filename + \".\" + format;", "\nloadQianURL(\"Desktop\",url);", "\n\n", "/**", "\n     * 文件或文件夹不存在则创建", "\n     * @param dir 文件夹", "\n     * @param filepath 文件名", "\n     */", "\n    public static void createDirFile(String dir){", "\n       File file = new File(dir);", "\n       if(!file.exists()){", "\n          file.mkdirs();", "\n       }", "\n    }", "\n\n", "/**\n * @param dir 子目录\n * @param fileUrl 图片链接\n * @return\n */\npublic static String loadQianURL(String dir,String fileUrl) {\n   //获取文件名，文件名实际上在URL中可以找到\n   String fileName = fileUrl.substring(fileUrl.lastIndexOf(\"/\")+1,fileUrl.length());\n   //这里服务器上要将此图保存的路径\n   String savePath = \"D:/upload/\";\n   if (!StringUtils.isEmpty(dir)){\n      savePath = savePath +dir+\"/\";\n   }\n   createDirFile(savePath);\n   try {\n      /*将网络资源地址传给,即赋值给url*/\n      URL url = new URL(fileUrl);\n      /*此为联系获得网络资源的固定格式用法，以便后面的in变量获得url截取网络资源的输入流*/\n      HttpURLConnection connection = (HttpURLConnection)url.openConnection();\n      //服务器的安全设置不接受Java程序作为客户端访问，解决方案是设置客户端的User Agent\n      connection.setRequestProperty(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)\");\n      System.out.println(\"0000000000000000000000000000\");\n      DataInputStream in = new DataInputStream(connection.getInputStream());\n      System.out.println(\"111111111111111111111111111111\");\n      /*此处也可用BufferedInputStream与BufferedOutputStream*/\n      DataOutputStream out = new DataOutputStream(new FileOutputStream(savePath+fileName));\n      /*将参数savePath，即将截取的图片的存储在本地地址赋值给out输出流所指定的地址*/\n      byte[] buffer = new byte[4096];\n      int count = 0;\n      /*将输入流以字节的形式读取并写入buffer中*/\n      while ((count = in.read(buffer)) > 0) {\n         out.write(buffer, 0, count);\n      }\n      out.close();/*后面三行为关闭输入输出流以及网络资源的固定格式*/\n      in.close();\n      connection.disconnect();\n      //返回内容是保存后的完整的URL\n      /*网络资源截取并存储本地成功返回true*/\n      return savePath+fileName;\n   } catch (Exception e) {\n      System.out.println(e + fileUrl + savePath);\n      return null;\n   }\n}\n", "\n\n", "运行结果：2019-10-22 16:43:55.545 2f1aa58b I: ", "\n0000000000000000000000000000", "\njava.io.FileNotFoundException: ", "http://www.xxx.com/xxx/downloadFile/1二维码.png", "\n\n", "输出0000000000000后停止运行要如何处理？"]], "Tag": "算法设计"}
{"Answer": "对，内部做了对结果的读写操作。\r\n一般会抛出io异常，包括读写和连接", "Konwledge_Point": "网络中的流", "Question": ["Android中关于HttpClient的问题", ["小白想请教下各位大神，使用HttpUplConnnection时需要用到IO流对数据进行读取，然而使用HttpClient时却不需要用到。。例如：", "\ntry {", "\n                HttpClient httpClient = new DefaultHttpClient();//获取实例", "\n                HttpGet httpGet = new HttpGet(address[0]);//创建HttpGet对象，传入网络地址", "\n                HttpResponse httpResponse = httpClient.execute(httpGet);//IOException", "\n                if (httpResponse.getStatusLine().getStatusCode() == 200){", "\n                    HttpEntity httpEntity = httpResponse.getEntity();//获取HttpEntity实例", "\n                    result = EntityUtils.toString(httpEntity,\"utf-8\");//转换为字符串", "\n                    return result;", "\n                }", "\n            } catch (IOException e) {", "\n                e.printStackTrace();", "\n            }", "\n是不是里面哪里封装了对IO的操作，使我们不用像HttpUplConnnection那样对使用IO。。。。另外想问下，使用HttpClient的过程中，会抛出什么其它的异常？", "\n\n", "多谢各位解答下小白的疑问！"]], "Tag": "算法设计"}
{"Answer": "与当地ISP的连接有关，当连接链路和速率不佳的情况下，与ISP的连接瞬间中断会造成对所访问的站点或信息丢失的情况", "Konwledge_Point": "网络中的流", "Question": ["请问各位 java 批量下载 报错”与服务器的链接被重置“", ["请问各位，我现在做一个批量下载，将几个文件压缩到zip中提供下载，现在下载时总是报”与服务器的链接被重置“，请教各位这是什么问题导致的？", "\n\n", "[code=\"java\"]", "\n//获取网络输入流", "\nZipEntry ze = new ZipEntry(filename, \"GBK\"));//设置文件编码格式", "\nzout.putNextEntry(ze);", "\n//   设置响应头和下载保存的文件名 ", "\nresponse.setContentType(\"APPLICATION/OCTET-STREAM\");", "\nresponse.setHeader(\"Content-Disposition\", \"attachment;filename=\"+zipname+\".zip\");", "\n//   写出流信息 ,bs 是 InputStream", "\nint k;", "\nwhile ((k = bs.read()) != -1) {", "\n    zout.write(k);", "\n}", "\nzout.closeEntry();", "\nbs.close();", "\n[/code]"]], "Tag": "算法设计"}
{"Answer": "javafx2确实不错，但是资料比较少，知道的朋友也少。你要是新知识学习能力比较自信的话绝对推荐javafx2。其实swing也比较小众，但是如果有人知道的话，肯定很能帮助到你，毕竟这是一门经典的技术。", "Konwledge_Point": "网络中的流", "Question": ["java开发网管系统，用Swing还是javaFX2", ["领导交给一个任务，要用java开发网络管理软件，网上搜索有不少用Swing的。但发现javaFX现在也挺流行，界面很漂亮。只是两个都没有用过。不知道哪一个更适合开发这个软件。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我这边跑没什么问题&amp;#xff0c;你删除最后一行还会报错&amp;#xff1f;是python2还是3&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["用requests模块爬百度文本显示错误", ["\n", "# -*- coding: utf-8 -*-", "\n\n", "import", " requests", "#导入网络请求模块", "\n\nresponse = requests.get(", "'http://www.baidu.com'", ")", "#发送网络请求", "\n\n", "print", "(", "'状态码'", ",response.status_code)", "#打印状态码", "\n", "print", "(", "'请求地址'", ",response.url)", "#请求地址", "\n", "print", "(", "'头部信息'", ",response.headers)", "#头部信息", "\n", "print", "(", "'打印cookie信息'", ",response.cookies)", "#打印cookie信息", "\n", "print", "(", "'字节流源码'", ",response.content)", "#字节流源码", "\n", "print", "(", "'文本源码'", ", response.text)", "#文本源码", "\n\n\n\n\nTraceback (most recent call last):\n  File ", "\"D:\\g.爬虫\\g6.py\"", ", line ", "12", ", ", "in", " <module>\n    ", "print", "(", "'文本源码'", ", response.text)", "#文本源码", "\nUnicodeEncodeError: ", "'gbk'", " codec can", "'t encode character '", "\\xe7'", " ", "in", " position ", "295", ": illegal multibyte sequence\n"]], "Tag": "算法设计"}
{"Answer": "多看多记。狂做案例。反正办法很多的。", "Konwledge_Point": "网络中的流", "Question": ["如何学习Android ....................", ["有一定的学习经验,会javaSE,EE,也学过C/C++,Qt;也会python,有一定的学习经验,以当下的趋势来说,我想学习Android编程,有哪些框架在Android端当下比较流行,以及我选择java还是koltin入手,而且学习Android的话主要是学习它的界面设计还是它的网络编程比较,求大神给条指路"]], "Tag": "算法设计"}
{"Answer": "客户端传输完成后关闭输出流", "Konwledge_Point": "网络中的流", "Question": ["如何用Java语言实现两台计算机之间的文件传输？", ["最近新学习了Java语言，算是一个小白，想用TCP Socket进行网络编程，使得服务器端接受客户端的文件，但是遇到了一个错误，有人知道该怎么解决吗？", "\n\n", "//这是服务器端的代码\npublic class UploadServer {\n    public static void main(String[] args) {\n        System.out.println(\"服务器端运行...\");\n        try {\n            //创建一个ServerSocket监听8080端口的客户端请求\n            ServerSocket serverSocket = new ServerSocket(8080);\n\n            //使用accept()阻塞当前线程，等待客户端请求\n            Socket socket = serverSocket.accept();\n\n            //由Socket获得输入流，并创建缓冲输入流\n            BufferedInputStream in = new BufferedInputStream(socket.getInputStream());\n\n            //由文件输出流创建缓冲输出流\n            FileOutputStream out = new FileOutputStream(\"G:\\\\站点\\\\新建文本文档.txt\");\n\n            //创建一个缓冲区\n            byte[] buffer = new byte[1024];\n            //首次向Socket读取数据\n            int len = in.read(buffer);\n            while (len != -1) {\n                //写入数据到文件\n                out.write(buffer, 0, len);\n                //再次从Socket读取数据\n                len = in.read(buffer);\n            }\n            System.out.println(\"接收完成！\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "\n\n", "//这是客户端的代码\npublic class UploadClient {\n public static void main(String[] args) {\n  System.out.println(\"客户端运行...\");\n  try {\n   //向非本机的8080客户端发出请求\n   Socket socket = new Socket(\"192.168.0.106\",8080);\n   //由Socket获得输出流，并创建缓冲输出流\n   BufferedOutputStream out = new BufferedOutputStream(socket.getOutputStream());\n   //创建文件输入流\n   FileInputStream fin = new FileInputStream(\"F:\\\\站点\\\\新建文本文档.txt\");\n   //由文件输入流创建缓冲输出流\n   BufferedInputStream in = new BufferedInputStream(fin);\n   //准备一个缓冲区\n   byte[] buffer = new byte[1024];\n   //首次读取文件\n   int len = in.read(buffer);\n   while(len != -1) {\n    //数据写入Socket\n    out.write(buffer,0,len);\n    //再次读取文件\n    len = in.read(buffer);\n   }\n   System.out.println(\"上传成功！\");\n  } catch(ConnectException e) {\n   System.out.println(\"服务器未启动！\");\n  } catch (IOException e) {\n   e.printStackTrace();\n  }\n\n\n }\n\n}\n\n", "\n\n", "先运行服务器端，在运行客户端", "\n客户端显示：", "\n服务器端显示：", "\n服务器端的第27行是   int len = in.read(buffer);", "\n该如何处理这个异常呢，求解！！！"]], "Tag": "算法设计"}
{"Answer": "1b\r\n2c\r\n3cd\r\n4cd\r\n5a\r\n6d\r\n7d\r\n8d\r\n9c\r\n10f\r\n采纳后可以给你解释。", "Konwledge_Point": "网络中的流", "Question": ["请问下面的题答案是？以及为什么？", ["1）下面哪种方式可以让爬虫合理、合法地抓取当日尽可能多的数据？", "\n\n", "A. 通过漏洞进入他人计算机系统，把数据库dump出来。", "\n\n", "B. 用大量低频关键词在目标站点上搜索，获得当日更全数据。", "\n\n", "C. 找到热门的hub页，热门的话题，热门的账号，获取当日更全数据。", "\n\n", "D. 用热门关键词在百度等搜索引擎上，用site:", "www.website.com", "\n\n", "\n", "关键词 查询，从而发现新数据", "\n", "2）以下所列出的方法中，浏览器web数据抓取效率最高的方法是？", "\n\n", "A. selenium + phantomjs", "\n\n", "B. 使用chrome或者chrome内核抓取", "\n\n", "C. 模拟web协议直接用wget或curl抓取", "\n\n", "3）下面哪项是手机端抓取app数据相比web端的优势（多选）：", "\n\n", "A. 手机端协议简单容易分析", "\n\n", "B. 手机端可以使用模拟点击", "\n\n", "C. 手机端就算出新版了旧版还是可以继续使用，不会立即停掉", "\n\n", "D. 通常来说，手机端抓取同样信息量的数据，下载量更低", "\n\n", "4）下面哪些代理支持rawsocket连接（多选）？", "\n\n", "A. HTTP代理", "\n\n", "B. HTTPS代理", "\n\n", "C. SOCKS4代理", "\n\n", "D. SOCKS5代理", "\n\n", "5）下面代码请求实际访问地址url是什么？", "\n\n", "url = \"", "https://test.cn/test", "\"", "\n\n", "params = {", "\n\n", "\"xxxx\":\"1234\"", "\n\n", "}", "\n\n", "headers = {", "\n\n", "\"Host\": \"", "www.test.cn", "\",", "\n\n", "\"Accept-Encoding\": \"gzip,deflate\",", "\n\n", "\"Connection\": \"Keep-Alive\"", "\n\n", "}", "\n\n", "requests.get(url, params, headers =headers, allow_redirects = False,", "\n\n", "verify = False)", "\n\n", "假设", "http://test.cn/test?xxxx=1234返回的状态码302且response", " header里有Location:", "http://www.test.cn/dpool/ttt/domain.php?d=test&xxxx=1234", "\n\n", "A. ", "https://test.cn/test", "\n\n", "B. ", "https://test.cn/test?xxxx=1234", "\n\n", "C. ", "https://www.test.cn/test?xxxx=1234", "\n\n", "D.", "http://www.test.cn/dpool/ttt/domain.php?d=test&xxxx=1234", "\n\n", "6）假如你要爬大量youtube视频的二进制内容，存储在本地，最佳的办法是？", "\n\n", "A. Mysql数据库存储", "\n\n", "B. Redis存储", "\n\n", "C. Mongodb存储", "\n\n", "D. 文件系统", "\n\n", "7）如果想爬自己手机应用上的HTTPS的数据，获得明文，下面哪个说法是正确的？", "\n\n", "A. 自己搭建一个HTTPS代理，让手机设置为这个代理，即可获得明文", "\n\n", "B. 任何HTTPS明文都是可以获取的", "\n\n", "C. 在PC上建立一个无线热点，让手机连这个热点，并使用Wireshare软件分析出HTTPS的明文数据", "\n\n", "D. 通过让手机系统信任根证书，使用Man-in-the-middle中间人攻击技术，就可以获取任何HTTPS明文", "\n\n", "8）以下哪个功能chromedriver协议不支持？", "\n\n", "A. 注入js文件", "\n\n", "B. 模拟鼠标滑动", "\n\n", "C. 网络请求的响应式处理", "\n\n", "D. 同个实例可以同时操作多个页面", "\n\n", "9）爬取数据过程中，哪个情况是最不可容忍的？", "\n\n", "A. 爬取的数据不完整，有部分数据遗失", "\n\n", "B. 爬取程序非法关闭，内存泄露", "\n\n", "C. 爬取的数据部分出错，手动修改", "\n\n", "D. 不同版本的数据合并在一起", "\n\n", "10）爬虫开发不会涉及到的技术或者知识有？", "\n\n", "A. tcp，udp传输协议", "\n\n", "B. 反汇编技术", "\n\n", "C. 数据库存储", "\n\n", "D. 音视频流解析", "\n\n", "E. 网络路由协议", "\n\n", "F. 以上都会涉及"]], "Tag": "算法设计"}
{"Answer": "视频/图片和非压缩的文本可以通过熵算法判断，视频的熵大。如果要精确判断，需要对数据包进行解析，比如根据一些关键数据特征判断。", "Konwledge_Point": "网络中的流", "Question": ["如何判断手机用户上网的流量是视频还是其他文字内容？", ["请教大神，目前有没有什么办法可以判断出消息报文数据中内容是视频流还是文本或者图片？"]], "Tag": "算法设计"}
{"Answer": "用webclient就可以，没那么麻烦\r\n\r\n参考：http://www.2cto.com/kf/201402/280196.html", "Konwledge_Point": "网络中的流", "Question": ["asp.net开发微信公众平台通过接口上传图片到微信服务器后台", ["asp.net开发微信公众平台通过接口上传图片到微信服务器后台，就要代码。", "\n\n", "ASCIIEncoding encodings = new ASCIIEncoding();", "\n        HttpWebResponse webResponses = null;", "\n        string s = zone.Substring(0, zone.Length - 1);", "\n        s = s.Substring(1, s.Length - 1);", "\n        string imgurl = picssss.PostedFile.FileName;", "\n\n", "    HttpWebRequest webRequests = (HttpWebRequest)WebRequest.Create(\"https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=\" + s );\n\n    //使用post方式提交\n    webRequests.Method = \"POST\";\n    string responseStrs = null;\n    webRequests.Timeout = 50000;\n    //要post的字节数组\n    string postDatas = \"\";\n    //?grant_type=client_credential&appid=wx875bfe9a60fc304f&secret=4e6180a6cd8e1425918ecf7cb22c36e9\n    byte[] postBytess = encodings.GetBytes(postDatas);\n\n    webRequests.ContentType = \"application/x-www-form-urlencoded;\";\n    webRequests.ContentLength = postBytess.Length;\n\n    using (Stream reqStream = webRequests.GetRequestStream())\n    {\n        reqStream.Write(postBytess, 0, postBytess.Length);\n    }\n    try\n    {\n        //尝试获得要请求的URL的返回消息\n        webResponses = (HttpWebResponse)webRequests.GetResponse();\n    }\n    catch (Exception)\n    {\n        //出错后直接抛出\n        throw;\n    }\n    finally\n    {\n        if (webResponses != null)\n        {\n            //获得网络响应流\n            using (StreamReader responseReader = new StreamReader(webResponses.GetResponseStream(), encodings))\n            {\n                responseStrs = responseReader.ReadToEnd();//获得返回流中的内容\n            }\n            webResponses.Close();//关闭web响应流\n        }\n    }\n\n    //JObject jos = (JObject)JsonConvert.DeserializeObject(responseStrs);\n    //string zones = jos[\"url\"].ToString();\n    Response.Write(responseStrs);\n    return responseStrs;\n\n\n}\n\n    或者帮着改改这个代码  我不知道哪里图片改写哪里，菜鸟一个  求大神出手啊。\n"]], "Tag": "算法设计"}
{"Answer": "试试\r\n\r\n    {\r\n           FileOutputStream out = new FileOutputStream(filename);\r\n           bmp.compress(Bitmap.CompressFormat.PNG, 90, out);\r\n    } catch (Exception e) {\r\n           e.printStackTrace();\r\n    }", "Konwledge_Point": "网络中的流", "Question": ["Android：位图保存路径", ["我正在做一个功能，想要从网络服务器上下载图片，在屏幕上重新显示这个图片，如果用户希望保存图片，保存它倒SD卡的一个特定的文件夹中。有简单的方法可以保存位图，然后把它保存到SD卡的我选择的文件夹中么？", "\n我的问题是我可以下载图片，在一个屏幕上显示成位图。我能想到的把图片保存到一个特定的文件夹的方法是使用FileOutputStream，但是这需要一个字节数组。我不知道怎么讲一个位图转换成字节数组（如果这是一个正确的方法），所以我用 Fileoutput流来写数据。", "\n其他的方法，我是用MediaStore", "\n\n", "MediaStore.Images.Media.insertImage(getContentResolver(), bm,barcodeNumber+ \".jpg Card Image\", barcodeNumber+ \".jpg Card Image\");\n", "\n\n", "这个可以保存到SD卡，但是不允许用户自己指定文件夹。", "\n无论什么帮助我都是非常感谢的。先谢谢你。"]], "Tag": "算法设计"}
{"Answer": "你的dns没有找到这个域名。再说了，人家的服务器能给你随便传么？你应该自己建一个http服务器，把这个地址换成你服务器。", "Konwledge_Point": "网络中的流", "Question": ["各位大神，通过URl访问资源，无法获取，URL对应的主机地址", ["例子是复制书上的源码应该不会有错，网络权限也有。", "\n这代码：", "\npackage org.crazyit.net;", "\n\n", "import android.app.Activity;", "\nimport android.graphics.Bitmap;", "\nimport android.graphics.BitmapFactory;", "\nimport android.os.Bundle;", "\nimport android.os.Handler;", "\nimport android.os.Message;", "\nimport android.view.Menu;", "\nimport android.view.MenuItem;", "\nimport android.widget.ImageView;", "\n\n", "import java.io.InputStream;", "\nimport java.io.OutputStream;", "\nimport java.net.URL;", "\n\n", "public class MainActivity extends Activity", "\n{", "\n    ImageView show;", "\n    // 代表从网络下载得到的图片", "\n    Bitmap bitmap;", "\n    Handler handler = new Handler()", "\n    {", "\n        @Override", "\n        public void handleMessage(Message msg)", "\n        {", "\n            if(msg.what == 0x123)", "\n            {", "\n                // 使用ImageView显示该图片", "\n                show.setImageBitmap(bitmap);", "\n            }", "\n        }", "\n    };", "\n    @Override", "\n    public void onCreate(Bundle savedInstanceState)", "\n    {", "\n        super.onCreate(savedInstanceState);", "\n        setContentView(R.layout.main);", "\n        show = (ImageView) findViewById(R.id.show);", "\n        new Thread()", "\n        {", "\n            public void run()", "\n            {", "\n                try", "\n                {", "\n                    // 定义一个URL对象", "\n                    URL url = new URL(\"", "http://www.crazyit.org/", "\"", "\n                            + \"attachments/month_1008/20100812_7763e970f\"", "\n                            + \"822325bfb019ELQVym8tW3A.png\");", "\n                    // 打开该URL对应的资源的输入流", "\n                    InputStream is = url.openStream();", "\n                    // 从InputStream中解析出图片", "\n                    bitmap = BitmapFactory.decodeStream(is);", "\n                    // 发送消息、通知UI组件显示该图片", "\n                    handler.sendEmptyMessage(0x123);", "\n                    is.close();", "\n                    // 再次打开URL对应的资源的输入流", "\n                    is = url.openStream();", "\n                    // 打开手机文件对应的输出流", "\n                    OutputStream os = openFileOutput(\"crazyit.png\"", "\n                        , MODE_PRIVATE);", "\n                    byte[] buff = new byte[1024];", "\n                    int hasRead = 0;", "\n                    // 将URL对应的资源下载到本地", "\n                    while((hasRead = is.read(buff)) > 0)", "\n                    {", "\n                        os.write(buff, 0 , hasRead);", "\n                    }", "\n                    is.close();", "\n                    os.close();", "\n                }", "\n                catch (Exception e)", "\n                {", "\n                    e.printStackTrace();", "\n                }", "\n            }", "\n        }.start();", "\n    }", "\n}", "\n这些是", "报错信息"]], "Tag": "算法设计"}
{"Answer": "&lt;h4 id=\"h4_以下内容部分参考chatgpt模型&amp;#xff1a;_1681113198889\"&gt;以下内容部分参考ChatGPT模型&amp;#xff1a;&lt;/h4&gt;\n&lt;hr /&gt;\n&lt;p&gt;将print输出的结果显示在tkinter界面上&amp;#xff0c;可以使用tkinter的Label组件来实现。在CNN_yuce函数中&amp;#xff0c;可以创建一个Label组件并将print输出的结果赋值给它的text属性&amp;#xff0c;然后将该组件放置在界面上即可。例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def CNN_yuce():\n    global e1, pred, root,predict_class\n    &lt;span class=\"hljs-attr\"&gt;name_dict&lt;/span&gt; &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Uninfected&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Parasitized&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;}\n\n    ...\n\n    &lt;span class=\"hljs-comment\"&gt;# 将预测结果转化为概率值&lt;/span&gt;\n    &lt;span class=\"hljs-attr\"&gt;result&lt;/span&gt; &amp;#61; np.squeeze(model.predict(img1))\n    &lt;span class=\"hljs-attr\"&gt;predict_class&lt;/span&gt; &amp;#61; np.argmax(result)\n    print(result)\n\n    &lt;span class=\"hljs-attr\"&gt;result&lt;/span&gt; &amp;#61; np.argmax(result[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])  &lt;span class=\"hljs-comment\"&gt;# 取出预测结果中概率最大的元素索引值&lt;/span&gt;\n    for k, v &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; name_dict.items():  &lt;span class=\"hljs-comment\"&gt;# 将类别由数字转换为名称&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;result&lt;/span&gt; &amp;#61;&amp;#61; v:  &lt;span class=\"hljs-comment\"&gt;# 如果预测结果等于v, 打印出名称&lt;/span&gt;\n            print(&lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果:&amp;#34;&lt;/span&gt;, k)  &lt;span class=\"hljs-comment\"&gt;# 打印出名称&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;# 创建Label组件并将预测结果赋值给它的text属性&lt;/span&gt;\n    &lt;span class=\"hljs-attr\"&gt;pred&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; k\n    &lt;span class=\"hljs-attr\"&gt;e1&lt;/span&gt; &amp;#61; tk.Label(root, &lt;span class=\"hljs-attr\"&gt;text&amp;#61;pred,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;font&amp;#61;(&amp;#39;Arial&amp;#39;,&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;))\n    e1.place(&lt;span class=\"hljs-attr\"&gt;x&amp;#61;500,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;y&amp;#61;370)&lt;/span&gt;\n\n    ...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样就可以在界面上显示print输出的结果了。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;h3 id=\"h3_如果我的建议对您有帮助、请点击采纳、祝您生活愉快_1681113198926\"&gt;如果我的建议对您有帮助、请点击采纳、祝您生活愉快&lt;/h3&gt;", "Konwledge_Point": "网络中的流", "Question": ["怎么将print中的结果显示在tkinter界面上", ["我想在我的tkinter界面上显示我print出的结果，但是我不知道怎么改。", "在网上查的，也没有查到说的清楚点的。", "下面是我的代码：", "\n", "import", " tkinter ", "as", " tk\n", "import", " tensorflow ", "as", " tf\n", "import", " matplotlib.pyplot ", "as", " plt\n", "from", " matplotlib.backends.backend_tkagg ", "import", " FigureCanvasTkAgg\n", "import", " numpy ", "as", " np\n", "from", " tkinter ", "import", " *\n", "import", " tkinter.filedialog  ", "# 注意次数要将文件对话框导入", "\n", "from", " PIL ", "import", " Image\n", "from", " tensorflow.python.keras ", "import", " models, layers\n\n", "def", " ", "CNN_yuce", "():\n    ", "global", " e1, pred, root,predict_", "class", "\n    ", "name_dict", " = {", "\"Uninfected\"", ":", "0", ", ", "\"Parasitized\"", ":", "1", "}\n\n    fig = plt.figure(figsize=(", "2", ",", "2", "),dpi=", "100", ")\n    ", "# 从本地选择一个文件，并返回文件的目录", "\n    ", "# filenames = tkinter.filedialog.askopenfile()#形成一共io流 的文件名称", "\n    filename = tk.filedialog.askopenfilename(title=", "u'加载图片'", ",initialdir=(()))", "#只保留文件名和后缀", "\n    ", "print", "(filename)\n\n    ", "# model_save_path = 'D:/ningyupeng/pythonProject/Graduation Project V1.0/my_model/variables/variables.ckpt'", "\n\n    model = tf.keras.models.Sequential([\n        tf.keras.layers.Flatten(),", "#Flatten-变成一维数组", "\n        tf.keras.layers.Dense(", "128", ", activation=", "'relu'", "),", "#relu函数可以解决 梯度消失问题 是线性的", "\n        tf.keras.layers.Dense(", "2", ", activation=", "'softmax'", ")])", "# 2个类所以2个神经元 softmax只用在最后一层 可以让最后输出的概率在0-1之间", "\n\n    ", "# model.load_weights('checkpoint-05e-val_acc_0.58.hdf5')#读取文件", "\n    models.load_model(", "\"my_model\"", ")\n\n    ", "# 加载测试图片", "\n    img = Image.", "open", "(filename)\n    ", "# 将图片resize到224x224大小", "\n    img = img.resize((", "128", ", ", "128", "), Image.ANTIALIAS)\n    ", "# 将灰度图转化为RGB模式", "\n    img = img.convert(", "\"RGB\"", ")\n\n    plt.imshow(img)\n    ", "# 归一化", "\n    img1 = np.array(img) / ", "255.", "\n    ", "# 将图片增加一个维度，目的是匹配网络模型", "\n    img1 = (np.expand_dims(img1, ", "0", "))\n    ", "# 将预测结果转化为概率值", "\n    result = np.squeeze(model.predict(img1))\n    predict_class = np.argmax(result)\n    ", "# pred = tf.argmax(result, axis=1)#求最大值得出最后识别出来的数", "\n    ", "# print(inverse_dict[int(predict_class)],result[predict_class])", "\n    ", "# 将预测的结果打印在图片上面", "\n    ", "# plt.title([inverse_dict[int(predict_class)],result[predict_class]])", "\n    ", "print", "(result)\n\n    result = np.argmax(result[", "0", "])  ", "# 取出预测结果中概率最大的元素索引值", "\n    ", "for", " k, v ", "in", " name_dict.items():  ", "# 将类别由数字转换为名称", "\n        ", "if", " result == v:  ", "# 如果预测结果等于v, 打印出名称", "\n            ", "print", "(", "\"预测结果:\"", ", k)  ", "# 打印出名称", "\n\n    e1 = tk.Label(root, text=pred, font=(", "'Arial'", ", ", "16", "))", "#显示预测结果", "\n    e1.place(x=", "500", ", y=", "370", ")\n\n    canvas = FigureCanvasTkAgg(fig, master=root)", "#渲染器 在画布上放置图片", "\n    canvas.draw()\n    canvas.get_tk_widget().place(x=", "550", ",y=", "50", ")\n", "def", " ", "picture", "():\n    ", "global", " root\n    root = Tk()\n    root.wm_title(", "\"细胞图像疟疾检测\"", ")\n    root.geometry(", "'1000x650'", ")\n\n    ask = tk.Button(root, text=", "\"预测\"", ", width=", "10", ", command=CNN_yuce)\n    ask.place(x=", "600", ", y=", "90", ")\n\n    root.mainloop()\n\n", "if", " __name__ == ", "'__main__'", ":\n    picture()\n\n\n\n\n", "\n", "它运行后print的结果不在界面上，下面是print结果截图，和界面的截图。", "\n", "\n", "\n", "我应该怎么更改。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;代码超时&amp;#xff0c;可能存在死循环&lt;br /&gt;不一定就是死循环造成的&lt;br /&gt;你循环次数过多也会超时&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["一个简单的c++疑惑", ["【问题描述】", "神经网络在机器学习领域非常流行。神经网络由多层组成，它包含一个输入层可以输入参数x（程序的输入）。然后输入通过多个隐藏层，在最后一层获得一个输出，称为输出层。", "我们有一个包含N个隐藏层的非常简单的神经网络，每层包含一个神经元。每个神经元有两个相关的值：wi和bi，分别表示神经元的权重和偏移。給定神经元的一个输入x，将生成一个输出(wix)+bi。", "因此，一个输入x被神经网络按照以下方式进行传输。", "第一个隐藏层接受输入x，生成y=w1x+b1，作为第二个神经元的输入。然后，第二个神经元接受输入y，生成一个输出z=w2*y+b2，重复这个过程，在最后的第N个神经元可以得到一个唯一的输出。", "对于一些用户，我们想知道他们是否是垃圾邮件发送人。每个用户有整数的用户ID，取值范围为minX~maxX（包括两个端点,1=<minX=<maxX=<1000000000）。我们把每个用户ID作为神经网络的第一层的输入，如果最终输出为偶数，则该用户不是垃圾邮件发送者，否则，该用户就是垃圾邮件发送者。", "编程统计非垃圾邮件发送者和垃圾邮件发送者的数量。", "【输入形式】", "输入的第一行为一个单一的整数T，表示测试数据的组数，接下来是T组测试数据的描述。", "每个测试数据的第一行为三个用空格分隔的整数N、minX、maxX，接下来的N行，每行包含两个用空格分隔的整数wi和bi，表示第i个神经元的权重和偏移。", "【输出形式】", "对于每个测试用例，输出两个用空格分隔的整数，分别表示非垃圾邮件发送者和垃圾邮件发送者的数量。", "【样例输入】", "3", "1 1 2", "1 2", "2 1 4", "2 4", "2 3", "3 2 1000000000", "2 4", "2 2", "5 4", "【样例输出】", "1 1", "0 4", "999999999 0", "\n", "测试数据有一组错误，说是死循环", "想知道哪里错了？谢谢！"]], "Tag": "算法设计"}
{"Answer": "这样看，你应该也是有几年工作经验了，\r\n\r\n自己看资料我觉得你应该一点问题都没有，\r\n\r\n把下面三个资料下来自己钻研下，不太懂就来问问题，\r\njavaeye里你搜索下jbpm有些好文章可以看看，不到1个星期你就完全ok了\r\nhttp://www.51leifeng.net/viewthread.php?tid=7756&amp;highlight=jbpm\r\nhttp://www.51leifeng.net/viewthread.php?tid=6780&amp;highlight=jbpm\r\nhttp://www.51leifeng.net/viewthread.php?tid=23891&amp;highlight=jbpm", "Konwledge_Point": "网络中的流", "Question": ["求jbpm程序员（兼职）", ["本人现就职于某制造型企业信息中心，企业打算采用JBPM实现工作流，我之前从事.NET、PHP开发，现如今必须使用java开发jbpm。", "\n我已安装好了运行及开发环境，tomcat6.0+mysql+jdk1.6+Eclipse+jbpm3.2+RichFaces2.0。", "\n自学jbpm实现是一件难事，参加正规的培训班似乎不可能，所以，我很想能有相关技能和经验的jbpm程序员能够给予一定的帮助，如培训、个性化流程开发等服务。[b]我本意是想学好jbpm，并可以付一定的学费。[/b]", "\n\n", "我公司在青岛，有青岛的Jbpm高手最好，通过网络也行。", "\n\n", "联系email/msn:", "daiqianjie@163.com"]], "Tag": "算法设计"}
{"Answer": "硬件问题到硬件DIY圈子里去吧.\r\nICE在那儿.\r\n附上传送门.\r\nhttp://pcdiy.group.iteye.com/", "Konwledge_Point": "网络中的流", "Question": ["这款宏基笔记本怎么样，它质量行不，值得买吗?", ["上市时间 2010年10月 ", "\n产品类型 家用 ", "\n产品定位 全能学生本 ", "\n处理器系列 英特尔 酷睿i5 ", "\n处理器型号 Intel 酷睿i5 460M ", "\n标称主频 2.53GHz ", "\n最高睿频 2800MHz ", "\n前端总线 1066 ", "\n三级缓存 3MB ", "\n内核架构 Arrandale ", "\n核心数量/SMT技术 双核心/四线程 ", "\n主板芯片组 Intel HM55 ", "\n标配内存容量 2GB ", "\n内存类型 DDR3 ", "\n最大支持内存 8GB ", "\n硬盘/光驱", "\n硬盘容量 320GB ", "\n硬盘描述 5400转，SATA ", "\n光驱类型 DVD刻录机 ", "\n设计类型 光驱内置 ", "\n光驱描述 支持DVD SuperMulti双层刻录 ", "\n显卡/音效", "\n显卡类型 中高端独立显卡 ", "\n显卡芯片 NVIDIA GeForce GT 330M ", "\n流处理器个数 48 ", "\n显存 1GB ", "\n位宽 128bit ", "\n显存类型 DDR3 ", "\n音频系统 内置音效芯片 ", "\n扬声器 立体声扬声器，内置麦克风 ", "\n显示屏", "\n屏幕尺寸 14英寸 ", "\n屏幕比例 16:9 ", "\n屏幕分辨率 1366×768 ", "\n背光技术 LED背光 ", "\n尺寸/重量", "\n笔记本重量 2.2Kg ", "\n外形尺寸 342×245×25.5-31.9mm ", "\n机壳材质 复合材质 ", "\n外壳描述 黑色 ", "\n网络通信", "\nAcer 4741G（5462G32Mnkk)", "\n无线网卡 支持802.11b/g/n无线协议 ", "\n网卡描述 1000Mbps以太网卡 ", "\n鼠标/键盘", "\n指取设备 触摸板 ", "\n接口", "\nUSB接口 3×USB2.0 ", "\n读卡器 5合1读卡器（SD，MMC，MS，MS PRO，xD） ", "\n视频输出 VGA，HDMI ", "\n其他接口 RJ45（网络接口），耳机输出接口，麦克风输入接口，电源接口 ", "\n电源描述", "\n电池类型 6芯锂电池 ", "\n续航时间 4小时左右，具体时间视使用环境而定 ", "\n电源适配器 100V-240V 自适应交流电源适配器 ", "\n其他", "\n附带软件 随机软件 ", "\n其他性能 集成130万像素摄像头 ", "\n其他特点 BIOS用户，管理者，硬盘密码，Kensington锁孔 ", "\n笔记本附件", "\n包装清单 笔记本主机 x1电池 x1电源适配器 x1说明书 x1 ", "\n可选配件 1GB/2GB/4GB DDR3 1066MHz内存条 6芯锂离子电池 60瓦/90瓦 交流电源适配器 USB外置modem "]], "Tag": "算法设计"}
{"Answer": "从lz提供的source来看\r\nblob数据检索出来以后，并没有被放到photohash中\r\n\r\n另外，根据sql的Blob的文档\r\n[quote]\r\n默认情况下，驱动程序使用 SQL locator(BLOB) 实现 Blob，这意味着 Blob 对象包含一个指向 SQL BLOB 数据而不是数据本身的逻辑指针。Blob 对象在它被创建的事务处理期间有效。 \r\n[/quote]\r\n\r\nTCifPhoto.getPhoto()的类型如果是Blob型而不是 byte[]的话，\r\n一旦检索事务处理结束了，的确有可能变成null", "Konwledge_Point": "网络中的流", "Question": ["关于blob对象（图片）的缓存和提取问题", ["前段时间给客户做了一个会议签到系统", "\n系统中涉及到这么一个问题：", "\n用户签到的时候有一个页面显示当前签到人的照片和最近签到的6个人的照片，", "\n照片数据都以blob对象存储在数据库中的，", "\n为了在页面上显示照片，我直接写了一个servlet来处理照片的请求，", "\nservlet中直接把blob二进制流输出给jsp界面。", "\njsp以", "的形式向servlet发送请求来获取照片", "\nservlet中以", "\nServletOutputStream out = res.getOutputStream();", "\nBlob temp = photo.getPhoto();", "\nInputStream is = temp.getBinaryStream();", "\nbyte buffer[] = new byte[256];", "\nwhile (is.read(buffer, 0, 256) != -1) {", "\nout.write(buffer);", "\n}", "\nout.flush();", "\n的形式响应。", "\n\n", "每当有人签到，jsp页面就自动刷新一次来获取新的6张照片", "\n\n", "这样设计有几个瓶颈", "\n1、照片本身大小比较大,每张都是200+k,每次刷新所有的照片都要重新到后台去获取，对网络的要求比较高，而且如果多个人同时使用这个页面刷新的话,更是问题", "\n2、每次请求的blob数据都需要到后台数据库中取数据，而且都是 并发的请求，对数据库的连接和数据库都有很大的压力，容易使服务down了", "\n\n", "试着改进过，因为每次请求的6张照片中正常情况有5张是重复的，所以我想用hashmap把查出来的结果缓存起来，下次有请求来了，如果在缓存中有了，就直接在缓存中取。没有再到数据库中取，缓存中到了一定数量，再把缓存全部清了，否则肯定会占用大量内存。", "\n\n", "但是这样又有问题，java的回收机制自动把我hashmap中的blob对象给清掉了。每次取到的persistence是有的可是到persistence中取blob却是空的了。所以jsp界面显示的照片都是空的。", "\n\n", "不知道有没有高人能提出一个好的解决方案。探讨探讨，如何改进。或者重新设计。", "\n\n", "不胜感激！", "\n\n", "[b]问题补充：[/b]", "\nHashMap问题blob对象被清  是这样的", "\nHashMap本来就是放在单子实例中的，肯定也是static", "\n\n", "public class AnalyseDAO extends BasicDAO {", "\nprivate static AnalyseDAO _instance= new AnalyseDAO();;", "\npublic static AnalyseDAO getInstance() {", "\n    if (_instance == null) {", "\n        _instance = new AnalyseDAO();", "\n  }", "\n    return _instance;", "\n}", "\nprivate static HashMap photohash = new HashMap();", "\n\n", "public TCifPhoto getCifPhoto(String stuempNo){", "\nif(photohash.size()>=50){", "\n  photohash.clear();", "\n}", "\nif(photohash!=null && photohash.get(stuempNo)!=null){", "\n  TCifPhoto tmp= (TCifPhoto)photohash.get(stuempNo);", "\n  if(tmp.getPhoto()==null){", "\n  System.out.println(\"omg  that's it lob is empty\");", "\n}", "\nreturn tmp;", "\n}else{", "\n  Session s = getSession();", "\n  String sql = \" from TCifPhoto cif where cif.stuempNo= '\"+stuempNo+\"'\";", "\ntry {", "\n  Query q = s.createQuery(sql);", "\n  List list = q.list();", "\n  if(list!=null&&list.size()>0){", "\n  return (TCifPhoto)list.get(0);", "\n}else{", "\n  return null;", "\n}", "\n} catch (HibernateException he) {", "\n  throw he;", "\n}", "\n}", "\n\n", "}", "\n\n", "这样的设计在tomcat上跑一点问题都没有  HashMap中的数据也能取到，可是一但到websphere上HashMap中存储的TCifPhoto 这个persistence还在，就是persistence里面的二进制lob对象没有了，从代码里看出系统输出了“omg  that's it lob is empty”就很明显知道问题的状况。可以判定websphere把lob字段给清了。", "\n\n", "或者另一种架设是websphere用到了对lob字段的lazyload的方式或者别的。没有找到相应的文档资料。", "\n[b]问题补充：[/b]", "\n又补充讨论一下：", "\n现在看来armorking说的应该是对的，blob的操作是逻辑指针，数据库连接释放后就不能取到值了。而tomcat和websphere数据库连接的管理方式又别，所以同样的代码，tomcat能正常运行,websphere就不行。（这有待继续挖掘区别，o(∩_∩)o...）。", "\n\n", "其实把blob缓存，我觉得不是最好的方案吧，即时做成byte[]缓存解决了原先的问题，但是，每张图片有300k，在签到峰值时期，每个用户客户端与服务器的网络流量将达到很高的程度，假设刷新为2s一次 300K*6=1.8M ，接近1M/s。再加上如果有多个客户端在刷。服务器流量将受到考验。", "\n\n", "所以我考虑是不是可以把照片缓存到每个客户端ie缓存中。首先把第一次请求的照片数据从数据库中取出缓存到服务器硬盘上。而客户端直接通过url来存取服务器上的照片。每次刷新后，相同的照片ie会自动取ie缓存中的照片，而不会再到服务器上取，这样就能解决原来的两个问题了。", "\n\n", "不知道大家有什么建议？"]], "Tag": "算法设计"}
{"Answer": "如果一定要用线程  那就用线程池吧  控制线程的数量  但是如果这个操作过程非常慢 可以导致线程池堵塞的话 那还是用队列吧  最靠谱的方法", "Konwledge_Point": "网络中的流", "Question": ["Servlet返回响应和执行业务逻辑代码分开可行吗", ["有一个程序A通过url调用Servlet，如果响应不成功（比如程序里访问url的时候产生网络问题、超时等等情况）就再调用一次。", "\n应用中出现这种情况：程序A实际第一次就调用成功了Servlet的url，但是由于Servlet内部程序执行时间太长，迟迟没有给程序A响应，造成程序A以为没有成功，又重复调用了一次url。结果是调用了两次，重复了。", "\n现在想去掉这种重复，有两个思路：", "\n思路1、程序A通过url调用Servlet时立刻返回正确响应，告诉程序A已经成功访问Servlet了，不需要再重复调用了。Servlet这边自己负责自己的代码是否执行成功，就是虽然告诉程序A调用成功了，但Servlet执行过程中还有可能出现问题，不过跟程序A已经没有关系了。我通过直接关闭response实现这个思路", "\n[code=\"java\"]", "\nServlet{", "\n  doGet(){", "\n         response.setHeader(\"Content-type\", \"text/html;charset=UTF-8\");", "\n         response.setCharacterEncoding(\"utf-8\");", "\n    PrintWriter out = response.getWriter();", "\n\n", "out.println(\"OK\" );\nout.flush();\nout.close();\n\n     ...其他程序...\n", "\n\n", "}", "\n}", "\n[/code]", "\n这样只要访问这个Servlet的网络是正常的，程序A调用这个url基本就不会出问题，也就避免了重复发送的问题。但是Servlet内部如果出错了程序A也就不知道了，需要Servlet自己来做错误处理。", "\n\n", "思路2、在Servlet里面可以用集合做一个缓存，调用一次记录一个request带的参数，这样如果重复调用的话就匹配这个集合，如果集合中存在参数就不执行了。", "\n再开启一个线程，用线程去处理Servlet里的业务功能，Servlet自身只需要返回正确响应就可以了。", "\n这样的话程序A调用Servlet的url应该也不会有问题，因为业务逻辑被另一个线程处理，出了问题不影响Servlet，也就不影响程序A的响应了。", "\n\n", "我的想法是如果第一种方法可行，那就没必要再开启一个线程了。因为Servlet在Tomcat中也是由Tomcat开启多个线程的，反正思路1已经给调用Servlet的程序A返回正确响应了，在Tomcat开启的一个Servlet线程中处理业务逻辑也就不会影响上级调用程序了，所以思路1可以更简单实现需求的功能。", "\n\n", "不知我是否描述清楚了？我的想法是否可行？建议用思路1还是2呢？", "\n再求证一个事情：程序内部通过url调用Servlet时，Servlet在什么情况下返回响应，是在Servlet所有代码执行完吗？还是在response的输出流关闭的时候？如果跟容器有关，那么我想知道Tomcat的实现。"]], "Tag": "算法设计"}
{"Answer": "走AJP协议，是二进制长连接的socket，性能还是可以的，再说只是一个输入输出的壳子，说到底，真正需要负载均衡的是CPU和内存吧。当然网络也可能成为瓶颈，所以在AJP的定义中，只包括inboud的数据", "Konwledge_Point": "网络中的流", "Question": ["apache和tomcat集群JK的性能问题", ["我一直有一个疑问，就是apache和tomcat集群，所有的请求和响应都经过jk，那么怎么保证jk的性能呢？本来就是负载平衡，jk不是又把所有响应集中到一起了吗？这又怎么平衡啊？", "\n\n", " ", "问题补充", "yangyi 写道", "走AJP协议，是二进制长连接的socket，性能还是可以的，再说只是一个输入输出的壳子，说到底，真正需要负载均衡的是CPU和内存吧。当然网络也可能成为瓶颈，所以在AJP的定义中，只包括inboud的数据", "提出这样的问题是因为最近项目有一个相册功能，中间有大量的图片，这些图片是以流的形式直接输出到页面上的，做完集群后发现性能不行。当然实在不行就打算再起一个服务，专门负责图片的处理。谢谢楼上的，我会看看ajp协议的。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;先解决第一个问题&amp;#xff0c;找不到chat.properties,换成绝对路径试试,也就是你这个文件的完整路径&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/966417849556190.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["Java实现实时聊天互动程序，这怎么解决问题", ["ServerChatMain", "\n", "\n\n\n", "package", " pp.chat;\n\n", "import", " java.awt.BorderLayout;\n", "import", " java.awt.event.ActionEvent;\n", "import", " java.awt.event.ActionListener;\n", "import", " java.awt.event.KeyEvent;\n", "import", " java.awt.event.KeyListener;\n", "import", " java.io.BufferedReader;\n", "import", " java.io.BufferedWriter;\n", "import", " java.io.FileReader;\n", "import", " java.io.IOException;\n", "import", " java.io.InputStreamReader;\n", "import", " java.io.OutputStreamWriter;\n", "import", " java.net.ServerSocket;\n", "import", " java.net.Socket;\n", "import", " java.util.Properties;\n\n", "import", " javax.swing.JButton;\n", "import", " javax.swing.JFrame;\n", "import", " javax.swing.JPanel;\n", "import", " javax.swing.JScrollPane;\n", "import", " javax.swing.JTextArea;\n", "import", " javax.swing.JTextField;\n\n\n\n\n\n", "//如果一个类，需要有界面的显示，那么该类就需要继承自JFrame，此时，该类就可以被称为一个“窗体类”", "\n", "//1.定义JFrame窗体中的组件", "\n", "//2.在构造方法中初始化窗体的组件", "\n", "//3.使用网络编程完成数据的传输（TCP,UDP协议）", "\n", "//4.实现“发送”按钮的监听点击事件，需要注意的是，文本域拼接数据时，实现自己换行，不要在发送数据中使用System.lineSeparator()换行。这样会导致无法辨别换行", "\n", "//5.实现“回车键”发送数据", "\n", "public", " ", "class", " ", "ServerChatMain", " ", "extends", " ", "JFrame", " ", "implements", " ", "ActionListener", ",KeyListener{\n\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", "{\n        \n        ", "//调用构造方法", "\n        ", "new", " ", "ServerChatMain", "();\n    }\n    ", "//属性 ", "\n    ", "//文本域", "\n    ", "private", " JTextArea jta;\n    ", "//滚动条", "\n    ", "private", " JScrollPane jsp;\n    ", "//面板", "\n    ", "private", " JPanel jp;\n    ", "//文本框", "\n    ", "private", " JTextField jtf;\n    ", "//按钮", "\n    ", "private", " JButton jb;\n    \n    ", "//输出流", "\n    ", "private", " ", "BufferedWriter", " ", "bw", " ", "=", " ", "null", ";\n    \n    ", "//服务端端口号", "\n    ", "private", " ", "static", " ", "int", " serverPort;\n    \n    ", "//使用static静态代码块读取外部配置文件", "\n    ", "//特点1：在类加载的时候，自动执行。", "\n    ", "//特点2：一个类只会被加载一次，因此静态代码块在程序中仅会被执行一次。", "\n    ", "static", "{\n        ", "Properties", " ", "prop", " ", "=", " ", "new", " ", "Properties", "();\n        \n        ", "try", "{\n            ", "//加载", "\n            prop.load(", "new", " ", "FileReader", "(", "\"char.properties\"", "));\n            \n            ", "//给属性赋值", "\n            serverPort = Integer.parseInt(prop.getProperty(", "\"serverPort\"", "));\n        }", "catch", "(IOException e){\n            e.printStackTrace();\n        }\n        \n    }\n    \n    ", "//构造方法", "\n    ", "public", " ", "ServerChatMain", "()", "{\n        ", "//初始化组件", "\n        jta = ", "new", " ", "JTextArea", "();\n        ", "//设置文本域默认不可编辑", "\n        jta.setEditable(", "false", ");\n        ", "//注意：需要将文本域添加到滚动条中，实现滚动效果", "\n        jsp = ", "new", " ", "JScrollPane", "(jta);\n        ", "//面板", "\n        jp = ", "new", " ", "JPanel", "();\n        jtf = ", "new", " ", "JTextField", "(", "10", ");\n        jb = ", "new", " ", "JButton", "(", "\"发送\"", ");\n        ", "//注意：需要将文本框与按钮添加到面板中", "\n        jp.add(jtf);\n        jp.add(jb);\n        \n        ", "//注意：需要将滚动条与面板全部添加到窗体中去", "\n        ", "this", ".add(jsp,BorderLayout.CENTER);\n        ", "this", ".add(jp,BorderLayout.SOUTH);\n        \n        ", "//注意：需要设置“标题，大小，位置，关闭，是否可见", "\n        ", "this", ".setTitle(", "\"qq聊天 服务端\"", ");\n        ", "this", ".setSize(", "300", ",", "300", ");\n        ", "this", ".setLocation(", "300", ",", "300", ");\n        ", "this", ".setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);", "//窗体关闭程序就退出", "\n        ", "this", ".setVisible(", "true", ");\n        \n        ", "/**********************TCP 服务端 start**********************/", "\n        ", "//给“发送”按钮绑定一个监听点击事件", "\n        jb.addActionListener(", "this", ");\n        ", "//给文本框绑定一个键盘点击事件", "\n        jtf.addKeyListener(", "this", ");\n        ", "try", "{\n            ", "//1.创建一个服务端的套接字", "\n        ", "ServerSocket", " ", "serverSocket", " ", "=", " ", "new", " ", "ServerSocket", "(serverPort);\n        \n        ", "//2.等待客户端的连接", "\n        ", "Socket", " ", "socket", " ", "=", " serverSocket.accept();\n        \n        ", "//3.获取 socket 通道的输入流(输出流是实现读取数据，如何读取？一行一行读取）BufferedReader ->readLine();", "\n        ", "//InputStream in = socket.getInputStream();", "\n        ", "BufferedReader", " ", "br", " ", "=", " ", "new", " ", "BufferedReader", "(", "new", " ", "InputStreamReader", "(socket.getInputStream()));\n        \n        \n    \n        ", "//4.获取 socket 通道的输出流（输出流实现写出数据，也是写一行，换一行，刷新）BufferedWrite -> newLine();", "\n        ", "//问题：什么时候需要写出数据？？？当用户点击“发送”按钮的时候才需要写出数据", "\n        bw = ", "new", " ", "BufferedWriter", "(", "new", " ", "OutputStreamWriter", "(socket.getOutputStream()));\n        \n        ", "//循环读取数据，并拼接到文本域中", "\n        ", "String", " ", "line", " ", "=", " ", "null", ";\n        ", "while", "((line = br.readLine())!= ", "null", "){\n            ", "//将读取的数据拼接到文本域中显示", "\n            jta.append(line + System.lineSeparator());\n            \n        }\n        \n        \n        \n        ", "//5.关闭 serverSocket 通道", "\n        serverSocket.close();\n        \n        }", "catch", "(IOException e1){\n            e1.printStackTrace();\n        }\n        \n        \n        \n        \n        ", "/**********************TCP 服务端 end**********************/", "\n        \n    \n    }\n\n    ", "@Override", "\n    ", "public", " ", "void", " ", "actionPerformed", "(ActionEvent e)", " {\n        ", "//System.out.println(\"发送按钮被点击了。。。\");", "\n        sendDataToSocket();\n\n}\n    ", "//行为", "\n    \n    ", "@Override", "\n    ", "public", " ", "void", " ", "keyPressed", "(KeyEvent e)", " {\n        ", "//回车键", "\n        ", "if", "(e.getKeyCode() == KeyEvent.VK_ENTER){\n            ", "//发送数据到socket通道中", "\n            sendDataToSocket();\n        }\n            \n    }\n    \n    \n    ", "//定义一个方法，实现将数据发送到socket通道中", "\n    ", "private", " ", "void", " ", "sendDataToSocket", "()", "{\n    ", "//1.获取文本框中发送的内容", "\n    ", "String", " ", "text", " ", "=", " jtf.getText();\n    \n    ", "//2.拼接需要发送的数据内容", "\n    text = ", "\"服务端对客户端说：\"", " + text;\n    \n    ", "//3.自己也需要显示", "\n    jta.append(text + System.lineSeparator());\n    \n    ", "try", "{\n    ", "//4.发送", "\n    bw.write(text);\n    bw.newLine();\n    bw.flush();\n    \n    ", "//5.清空文本框内容", "\n    jtf.setText(", "\"\"", ");\n}", "catch", " (IOException e1){\n    e1.printStackTrace();\n}\n    }\n    ", "@Override", "\n    ", "public", " ", "void", " ", "keyReleased", "(KeyEvent e)", " {\n    }\n    \n\n    ", "@Override", "\n    ", "public", " ", "void", " ", "keyTyped", "(KeyEvent e)", " {\n    }\n}\n", "\n", "ClientChatMain", "\n", "package", " pp.chat;\n\n", "import", " java.awt.BorderLayout;\n", "import", " java.awt.event.ActionEvent;\n", "import", " java.awt.event.ActionListener;\n", "import", " java.awt.event.KeyEvent;\n", "import", " java.awt.event.KeyListener;\n", "import", " java.io.BufferedReader;\n", "import", " java.io.BufferedWriter;\n", "import", " java.io.FileReader;\n", "import", " java.io.IOException;\n", "import", " java.io.InputStreamReader;\n", "import", " java.io.OutputStreamWriter;\n", "import", " java.net.Socket;\n", "import", " java.util.Properties;\n\n", "import", " javax.swing.JButton;\n", "import", " javax.swing.JFrame;\n", "import", " javax.swing.JPanel;\n", "import", " javax.swing.JScrollPane;\n", "import", " javax.swing.JTextArea;\n", "import", " javax.swing.JTextField;\n\n", "public", " ", "class", " ", "ClientChatMain", " ", "extends", " ", "JFrame", " ", "implements", " ", "ActionListener", ",KeyListener{\n    \n\n", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", "{\n        \n        ", "//调用构造方法", "\n        ", "new", " ", "ClientChatMain", "();\n    }\n    ", "//属性 ", "\n    ", "//文本域", "\n    ", "private", " JTextArea jta;\n    ", "//滚动条", "\n    ", "private", " JScrollPane jsp;\n    ", "//面板", "\n    ", "private", " JPanel jp;\n    ", "//文本框", "\n    ", "private", " JTextField jtf;\n    ", "//按钮", "\n    ", "private", " JButton jb;\n    \n    ", "//输出流", "\n    ", "private", " ", "BufferedWriter", " ", "bw", " ", "=", " ", "null", ";\n    \n    ", "//客户端的IP地址", "\n    ", "private", " ", "static", " String clientIP;\n    ", "//客户端的port端口号", "\n    ", "private", " ", "static", " ", "int", " clientPort;\n    \n    ", "//静态代码块加载外部配置文件", "\n    ", "static", "{\n        ", "Properties", " ", "prop", " ", "=", " ", "new", " ", "Properties", "();\n        ", "try", "{\n        prop.load(", "new", " ", "FileReader", "(", "\"chat,properties\"", "));\n        clientIP = prop.getProperty(", "\"clientIP\"", ");\n        clientPort = Integer.parseInt(prop.getProperty(", "\"clientPort\"", "));\n        }", "catch", "(IOException e){\n            e.printStackTrace();\n        }\n    }\n    \n    ", "//构造方法", "\n    ", "public", " ", "ClientChatMain", "()", "{\n        ", "//初始化组件", "\n        jta = ", "new", " ", "JTextArea", "();\n        ", "//设置文本域默认不可编辑", "\n        jta.setEditable(", "false", ");\n        ", "//注意：需要将文本域添加到滚动条中，实现滚动效果", "\n        jsp = ", "new", " ", "JScrollPane", "(jta);\n        ", "//面板", "\n        jp = ", "new", " ", "JPanel", "();\n        jtf = ", "new", " ", "JTextField", "(", "10", ");\n        jb = ", "new", " ", "JButton", "(", "\"发送\"", ");\n        ", "//注意：需要将文本框与按钮添加到面板中", "\n        jp.add(jtf);\n        jp.add(jb);\n        \n        ", "//注意：需要将滚动条与面板全部添加到窗体中去", "\n        ", "this", ".add(jsp,BorderLayout.CENTER);\n        ", "this", ".add(jp,BorderLayout.SOUTH);\n        \n        ", "//注意：需要设置“标题，大小，位置，关闭，是否可见", "\n        ", "this", ".setTitle(", "\"qq聊天 客户端\"", ");\n        ", "this", ".setSize(", "300", ",", "300", ");\n        ", "this", ".setLocation(", "600", ",", "300", ");\n        ", "this", ".setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        ", "this", ".setVisible(", "true", ");\n        \n        \n        ", "/**********************TCP 客户端 start**********************/", "\n        ", "//给发送按钮绑定一个监听点击事件", "\n        jb.addActionListener(", "this", ");\n        ", "//给文本框绑定一个键盘点击事件", "\n        jtf.addKeyListener(", "this", ");\n        ", "try", "{\n            ", "//1.创建一个客户端的套接字（尝试连接）", "\n        ", "Socket", " ", "socket", " ", "=", " ", "new", " ", "Socket", "(clientIP,clientPort);\n        \n        \n        ", "//2.获取 socket 通道的输入流", "\n        ", "BufferedReader", " ", "br", " ", "=", " ", "new", " ", "BufferedReader", "(", "new", " ", "InputStreamReader", "(socket.getInputStream()));\n        \n        ", "//3.获取 socket 通道的输出流", "\n        bw = ", "new", " ", "BufferedWriter", "(", "new", " ", "OutputStreamWriter", "(socket.getOutputStream()));\n        \n        \n        \n        ", "//循环读取数据，并拼接到文本域中", "\n        ", "String", " ", "line", " ", "=", " ", "null", ";\n        ", "while", "((line = br.readLine()) != ", "null", "){\n            jta.append(line + System.lineSeparator());    \n            \n        }\n        \n        ", "//4.关闭 socket 通道", "\n        socket.close();\n        \n        }", "catch", "(Exception e){\n            e.printStackTrace();\n        }\n        \n        \n        ", "/**********************TCP 客户端 end**********************/", "\n        \n        \n    }\n\n    ", "@Override", "\n    ", "public", " ", "void", " ", "actionPerformed", "(ActionEvent e)", " {\n        sendDataToSocket();\n    }\n    \n    ", "//行为", "\n    ", "@Override", "\n    ", "public", " ", "void", " ", "keyPressed", "(KeyEvent e)", " {\n        ", "//回车键", "\n        ", "if", "(e.getKeyCode() == KeyEvent.VK_ENTER){\n            ", "//发送数据到socket通道", "\n            sendDataToSocket();\n            \n        }\n        \n    }\n    \n    ", "private", " ", "void", " ", "sendDataToSocket", "()", "{\n        ", "//1.获取文本框中需要发送的数据内容", "\n                ", "String", " ", "text", " ", "=", " jtf.getText();\n        ", "//2.拼接内容", "\n                text = ", "\"客户端对服务端说：\"", " + text;\n        ", "//3.自己显示", "\n                jta.append(text + System.lineSeparator());\n                \n                ", "try", "{\n                    ", "//4.发送", "\n                    bw.write(text);\n                    ", "//bw.newLine() 与 System.lineSeparator() 两个换行导致使用BufferedReader一行一行读取时，无法正确的辨别需要的换行", "\n                    bw.newLine();\n                    bw.flush();\n                    ", "//5.清空", "\n                    jtf.setText(", "\"\"", ");\n                }", "catch", " (IOException e1){\n                    e1.printStackTrace();\n                }\n                \n    }\n\n    ", "@Override", "\n    ", "public", " ", "void", " ", "keyReleased", "(KeyEvent e)", " {\n    }\n\n    ", "@Override", "\n    ", "public", " ", "void", " ", "keyTyped", "(KeyEvent e)", " {\n    }\n    \n    \n}\n\n\n", "\n", "\n", "结果", "没有连接成功，不能成功发送消息", "并且文本框没有刷新", "\n", "还有一堆看不懂的"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"431\" src=\"https://img-ask.csdnimg.cn/upload/1614150440070.png\" width=\"700\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;按行读取不一定就符合你的正则  标签是&lt;/p&gt;\n\n&lt;p&gt;&amp;lt;p&amp;gt;&lt;/p&gt;\n\n&lt;p&gt;xxxxxx&lt;/p&gt;\n\n&lt;p&gt;&amp;lt;/p&amp;gt;你能匹配上吗&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["有Java爬虫大佬帮我看下这个是哪里错了怎么运行不出来呢。谢谢啦，运行结果在下面，也有示例代码！", ["有Java爬虫大佬帮我看下这个是哪里错了怎么运行不出来呢。谢谢啦，", "\n\n", "看不到哪里错了就是运行不出来，，", "\n\n", "代码如下：", "\n\n", "\n", "package Cho;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.URL;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Demo1 {\n\tprivate static final String i = null;\n\n\tpublic static void main(String[] args, boolean isEX) {\n\t\t//根据小说存在位置的file对象\n\t\tFile file=new File(\"D:\\\\pachong\\three_gou.txt\");\n\t\t//2.根据网页的结构编写正则，创建pattern对象\n\t\tString regex_content=\"<p.*?>(.*)</p>\";\n\t\tString regex_title=\"<title>(.*?)</title>\";\n\t\tPattern p_content=Pattern.compile(regex_content);\n\t\tPattern p_title=Pattern.compile(regex_title);\n\t\t\n\t\tMatcher m_content;\n\t\tMatcher m_title;\n\t\t//3.编写循环,创建向所有小说章节页面发起网络请求的url对象\n\t\tfor(int i=0;i<=10;i++)\n\t\tSystem.out.println(\"第\"+i+\"章开始下载。。。\");\n\t\ttry {\n\t\t\t//创建每一个页面的url对象\n\t\t\tURL url=new URL(\"http://www.purepen.com/sgyy/\"+i+\".htm\");\n\t\t\t//创建网络读取流\n\t\t\tBufferedReader reder=new BufferedReader(new InputStreamReader(url.openStream(),\"utf8\"));\n\t\t\t//读取网络内容\n\t\t\tString  str=null;\n\t\t\t\n\t\t\t//创建输入流\n\t\t\tBufferedWriter writer=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file,true)));\n\t\t\t\n\t\t\twhile((str=reder.readLine())!=null){\n\t\t\t\tm_title=p_title.matcher(str.toString());\n\t\t\t\tm_content=p_content.matcher(str.toString());\n\t\t\t\t//获取小说标题写入来本地文件\n\t\t\tboolean ieEx=\tm_title.find();\n\t\t\t\tif(isEX){\n\t\t\t\t\tString title =m_title.group();\n\t\t\t\t\t//清洗得到数据\n\t\t\t\t\ttitle =title.replace(\"<title>\", \"\").replace(\"</title>\", \"\");\n\t\t\twriter.write(\"第\"+i+\"章：\"+title+\"\\n\");\n\t\t\t\t}\n\t\t\t\twhile(m_content.find()){\n\t\t\t\t\tString content=m_content.group();\n\t\t\t\t\t//清洗的到的数据\n\t\t\t\t\tcontent=content.replace(\"<p>\", \"\").replace(\"</p>\", \"\").replace(\"&nbsp;\", \"\").replace(\"?\", \"\");\n\t\t\t\t//吧小说内容写入文件\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"第\"+i+\"章下载完成。。。。。。\");\n\t\t\twriter.write(\"\\n\\n\");\n\t\t\twriter.close();//关闭\n\t\t\treder.close();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"下载失败\");\n\t\t}\n\t\t}\n\t}\n\t\n\n\n", "\n\n", "\n\n", " ", "\n\n", " "]], "Tag": "算法设计"}
{"Answer": "如果是我的话，果断ThinkPad E440：\r\n\r\n1、ThinkPad的CPUi5-4200M(标压)，Dell是i5-4200U(低压)，CPU性能差不少呢；\r\n\r\n2、独立显卡上，Dell的要好一些，但ThinkPad上是集成+独立的双卡，和Dell的性能应该不会差太大，而且既然实在这两款中进行选择，应该没有大型3D游戏的需求；\r\n\r\n配置上，觉得上面两点是最重要的。\r\n\r\n不知道题注，主要用笔记本干啥，如果主要都是，家庭应用，程序开发，Android开发啥的，那就ThinkPad E440，如果是影音娱乐为主，建议Dell吧。\r\n\r\n另外，不管那一款，如果预算充足，建议能将内存升级到8G。\r\n\r\n谢谢。", "Konwledge_Point": "网络中的流", "Question": ["ThinkPad E440（20C5S00500）和戴尔Inspiron 灵越 14R（Ins14RD-5628）那个好，原因", ["ThinkPad E440（20C5S00500）", "\n上市时间：2013年11月", "\n产品类型：商用", "\n产品定位：商务办公本", "\n操作系统：Linux", "\n主板芯片组：Intel HM87", "\n处理器", "\nCPU系列：英特尔 酷睿i5 4代系列", "\nCPU型号：Intel 酷睿i5 4200M", "\nCPU主频：2.5GHz", "\n最高睿频：3100MHz", "\n总线规格：DMI 5 GT/s", "\n三级缓存：3MB", "\n核心架构：Haswell", "\n核心/线程数：双核心/四线程", "\n制程工艺：22nm", "\n指令集：AVX2，64bit", "\n功耗：37W", "\n存储设备", "\n内存容量：4GB（4GB×1）", "\n内存类型：DDR3L（低电压版）1600MHz", "\n插槽数量：2xSO-DIMM", "\n最大内存容量：8GB", "\n硬盘容量：500GB", "\n硬盘描述：5400转", "\n光驱类型：内置DVD刻录机", "\n光驱描述：Rambo", "\n显示屏", "\n触控屏：不支持触控", "\n屏幕尺寸：14英寸", "\n显示比例：16:9", "\n屏幕分辨率：1366x768", "\n屏幕技术：LED背光", "\n显卡", "\n显卡类型：双显卡（性能级独立显卡＋集成显卡）", "\n显卡芯片：NVIDIA GeForce GT 740M＋Intel GMA HD 4400", "\n显存容量：2GB", "\n显存类型：DDR3", "\n显存位宽：64bit", "\n流处理器数量：384", "\nDirectX：11", "\n多媒体设备 ", "\n摄像头：720p HD摄像头", "\n音频系统：内置音效芯片", "\n扬声器：内置扬声器", "\n麦克风：内置麦克风", "\n网络通信", "\n无线网卡：支持802.11b/g/n无线协议", "\n有线网卡：1000Mbps以太网卡", "\n蓝牙：支持，蓝牙4.0模块", "\nI/O接口", "\n数据接口：1×USB2.0+2×USB3.0（其中一个powered供电USB共用接口）", "\n视频接口：VGA，HDMI", "\n音频接口：耳机/麦克风二合一接口", "\n其它接口：RJ45（网络接口），电源接口", "\n读卡器：4合1读卡器", "\n输入设备", "\n指取设备：智能型手势操控触摸板 纠错", "\n键盘描述：全尺寸键盘", "\n电源描述", "\n电池类型：6芯锂电池", "\n续航时间：具体时间视使用环境而定", "\n戴尔Inspiron 灵越 14R（Ins14RD-5628）", "\n上市时间：2013年11月", "\n产品类型：家用", "\n产品定位：全能学生本，时尚丽人本", "\n操作系统：预装Windows 8.1 64bit（64位简体中文版）", "\n主板芯片组：Intel HM76", "\n处理器", "\nCPU系列：英特尔 酷睿i5 4代系列", "\nCPU型号：Intel 酷睿i5 4200U", "\nCPU主频：1.6GHz", "\n最高睿频：2600MHz", "\n总线规格：DMI 5 GT/s", "\n三级缓存：3MB", "\n核心架构：Haswell", "\n核心/线程数：双核心/四线程", "\n制程工艺：22nm", "\n指令集：AVX2，64bit", "\n功耗：15W", "\n存储设备", "\n内存容量：4GB（4GB×1）", "\n内存类型：DDR3L（低电压版）1600MHz", "\n插槽数量：1xSO-DIMM", "\n最大内存容量：8GB", "\n硬盘容量：750GB", "\n硬盘描述：5400转", "\n光驱类型：内置DVD刻录机", "\n光驱描述：支持DVD SuperMulti双层刻录", "\n显示屏", "\n触控屏：不支持触控", "\n屏幕尺寸：14英寸", "\n显示比例：16:9", "\n屏幕分辨率：1366x768", "\n屏幕技术：LED背光", "\n显卡", "\n显卡类型：性能级独立显卡", "\n显卡芯片：NVIDIA GeForce GT 750M", "\n显存容量：2GB", "\n显存类型：GDDR5", "\n显存位宽：128bit", "\n流处理器数量：384", "\nDirectX：11", "\n多媒体设备 ", "\n摄像头：集成100万像素摄像头", "\n音频系统：内置音效芯片", "\n扬声器：内置扬声器", "\n麦克风：内置麦克风", "\n网络通信", "\n无线网卡：支持802.11b/g/n无线协议", "\n有线网卡：100Mbps网卡", "\n蓝牙：支持，蓝牙4.0模块", "\nI/O接口", "\n数据接口：1×USB2.0+2×USB3.0", "\n视频接口：HDMI", "\n音频接口：耳机/麦克风二合一接口", "\n其它接口：RJ45（网络接口），电源接口", "\n读卡器：8合1读卡器（高速-SD，高容量-SD，MMC，MS，MS-PRO，SD，SDXC，xD）", "\n输入设备", "\n指取设备：触摸板", "\n电源描述", "\n电池类型：6芯锂电池，6500毫安", "\n那个好点"]], "Tag": "算法设计"}
{"Answer": "&amp;nbsp;需要遍历局域网IP的，大体分为两步：： 1.得到局域网网段，可由自己机器的IP来确定 2.根据IP类型，一次遍历局域网内IP地址 我给你一个JAVA类，编译之后直接运行便可以得到局域网内所有IP,具体怎样使用你自己编写相应代码调用便可 代码如下：package bean; \r\n\r\nimport java.io.*; \r\nimport java.util.*; \r\n\r\npublic cl......&lt;br/&gt;&lt;strong&gt;答案就在这里：&lt;/strong&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/cz1029648683/article/details/6628617'&gt;java获取局域网IP&lt;/a&gt;&lt;br/&gt;----------------------Hi，地球人，我是问答机器人小S，上面的内容就是我狂拽酷炫叼炸天的答案，除了赞同，你还有别的选择吗？", "Konwledge_Point": "网络中的流", "Question": ["java如何获取局域网内所有IP", ["做个jframe小程序，在加载时将局域网内所有IP和主机名用流布局显示在窗体上！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;重装或换个版本看看&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["enps问题求解决！！", ["我的enps抓包不了", "抓包软件正常能开开", "路径也对。也有数据流", "就是没法和enps联动", "求解答"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;1、注释掉bo.flush并不会影响bo.close,你这里报错的socket closed,应该socket连接的错误。&lt;br /&gt;2、bo.flush() 和 bo.close()&amp;#xff0c;是因为缓冲流BufferedOutputStream有未完成写入的数据&amp;#xff0c;导致接收到未完成接受&amp;#xff0c;所以导致图片不完整&amp;#xff1b;&lt;br /&gt;3、BufferedOutputStream流在调用close方法的时候&amp;#xff0c;在close直接&amp;#xff0c;会判断是否完成写入数据的&amp;#xff0c;如果没有&amp;#xff0c;会自动调用flush方法。&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["在本地实现图片的传输时，socket异常关闭的问题", ["在本地实现图片的传输时，socket异常关闭的问题", "\n", "服务端", "\n", "public", " ", "static", " ", "void", " main(String[] args) ", "throws", " IOException {\n        ", "// 1. 监听 8888 端口", "\n        ServerSocket serverSocket = ", "new", " ServerSocket(", "8888", ");\n        System.out.", "println", "(", "\"8888端口监听中...\"", ");\n\n        ", "// 2. 获取 socket 对象", "\n        Socket socket = serverSocket.accept();\n\n        ", "// 3. 获取写入到本地磁盘的输出流", "\n        FileOutputStream fos = ", "new", " FileOutputStream(", "\"src/DD的头像.jpg\"", ");\n\n        ", "// 4. 读取 socket 输入流并写入文件", "\n        BufferedInputStream bis = ", "new", " BufferedInputStream(socket.getInputStream());\n        BufferedWriter bw = ", "new", " BufferedWriter(", "new", " OutputStreamWriter(socket.getOutputStream(), ", "\"utf8\"", "));\n        ", "int", " readLen;\n        ", "byte", "[] buf = ", "new", " ", "byte", "[", "10", "];\n        ", "while", " ((readLen = bis.", "read", "(buf)) != -", "1", ") {\n            fos.", "write", "(buf, ", "0", ", readLen);\n        }\n        System.out.", "println", "(", "\"文件写入成功。。。\"", ");\n        ", "// 5. 向客户端发送保存成功的消息", "\n        bw.", "write", "(", "\"图片保存成功!!!\"", ");\n        bw.close();\n\n        ", "// 关闭相关流", "\n        fos.close();\n        bis.close();\n        socket.close();\n        serverSocket.close();\n    }\n", "\n", "客户端", "\n", "public static void main(String", "[]", " args) throws IOException {\n        ", "// 1. 获取连接到服务器的 socket", "\n        Socket socket = ", "new", " ", "Socket(InetAddress.", "getLocalHost", "()", ", ", "8888", ");\n        ", "// 2. 获取磁盘文件的输入流", "\n        String filePath = ", "\"D:/FileStudy/DD的头像.jpg\"", ";\n        FileInputStream fis = ", "new", " ", "FileInputStream(", "filePath", ")", ";\n        ", "// 3. 读取磁盘文件", "\n        BufferedOutputStream bo = ", "new", " ", "BufferedOutputStream(", "socket", ".", "getOutputStream", "()", ");\n        ", "int", " readLen;\n        byte", "[]", " buf = ", "new", " byte", "[", "10", "]", ";\n        ", "while", " ((readLen = fis.read(buf)) != -", "1", ") {\n            ", "// 4. 读取的同时，写入到数据通道", "\n            bo.write(buf, ", "0", ", readLen);\n        }\n        bo.flush", "()", "; ", "// ==============================================", "\n        socket.shutdown", "Output()", ";\n        ", "// 5. 接收服务端发送的消息", "\n        BufferedReader br = ", "new", " ", "BufferedReader(", "new", " InputStreamReader(", "socket", ".", "getInputStream", "()", ", ", "\"utf8\"", "));\n        ", "System", ".", "out.println(", "\"接收到服务端的消息：\"", " + br.read", "Line()", ");\n\n        ", "// 关闭相关流", "\n        br.close", "()", ";\n        bo.close", "()", "; ", "// ==============================================", "\n        socket.close", "()", ";\n    }\n", "\n", "其中有很多 \"=\" 的那两行有点疑问（客户端的15和23行）", "\n", "如果注释 bo.flush()，那么最后的 bo.close() 会爆 socket closed 异常，这是为什么？", "如果把 bo.flush() 和 bo.close() 都注释掉，传输的图片就会不完整，这又是为啥"]], "Tag": "算法设计"}
{"Answer": "棋牌类的游戏，最好还是用soket的传递数据，那样对战的双方可以实时知道棋局的情况。\r\n   具体的细节，你就要考虑系统的稳定性，先不要考虑系统的速度，稳定是基础；", "Konwledge_Point": "网络中的流", "Question": ["Java实现一个有联网功能的象棋要用哪种技术？", ["学校大作业，我以前只用socket写过聊天的功能，不知道象棋的联网功能要怎么实现？socket我只知道用来传输字符流，应该不能用于这种较复杂的棋类联网吧？"]], "Tag": "算法设计"}
{"Answer": "最后问题解决了，我路径写的有问题，还有就是不能使用ajax提交，不然无法下载", "Konwledge_Point": "网络中的流", "Question": ["java无法对多个excel打包下载？", ["java实现多个excel 打包下载，我先创建了一个临时文件夹，然后进行打包下载，最后删除这个临时文件夹， 但是没反应也不报错，求大神指教", "\n\n", " @RequestMapping(value = \"downloadPreHomeWorkZIP\")\n    public void downloadLetterZIP(trainTraineeWorkModel  query, HttpServletResponse response, HttpServletRequest request) throws IOException, SQLException {\n\n        String serverPath =request.getSession().getServletContext().getRealPath(\"/\")+\"\\\\upload\\\\tempExcel\";\n         List<File> srcfile=new ArrayList<File>();  \n        //在服务器端创建文件夹  \n        File file = new File(serverPath);  \n        if(!file.exists()){  \n            file.mkdir();  \n        } \n        List<Map> employees = employeeService     //查询学员上传的课前课后作业\n                .getMapTraineesBySessionId(1406940);\n        if(employees.size()!=0){\n            for (Map map : employees) {\n                BLOB blob = (BLOB) map.get(\"BEFORECLASS_WORK\");\n                if(blob!=null&&blob.length()!=0){\n                String employeeCode=(String)map.get(\"EMPLOYEE_CODE\");\n\n                response.setHeader(\"Content-Disposition\", \"attachment; filename=afterSessionWork\"+ java.net.URLEncoder.encode(\n                        employeeCode + \".xls\", \"UTF-8\"));\n                response.setContentType(\"application/octet-stream; charset=utf-8\");\n                SimpleDateFormat sfm = new SimpleDateFormat(\"yyyy-MM-dd\"); \n                 String filename = employeeCode + \"_\" + sfm.format(new Date());  \n                    String encodedfileName = new String(filename.getBytes(), \"UTF-8\"); \n                InputStream in = blob.getBinaryStream();\n                 byte[] buf = new byte[1024];\n                   int bytesIn = 0;\n                   FileOutputStream out = new FileOutputStream(serverPath+ employeeCode+\".xls\");\n                   while ((bytesIn = in.read(buf, 0, 1024)) != -1) {\n                    out.write(buf, 0, bytesIn);\n                   }\n                   srcfile.add(new File(serverPath+\"\\\\\"+encodedfileName+\".xls\"));  \n                   in.close();\n                   out.close();\n                }\n\n            }\n            //将服务器上存放Excel的文件夹打成zip包  \n            File zipfile = new File(serverPath+\"PreWork\"+\".zip\");  \n            ZipUtils.zipFiles(srcfile, zipfile);  \n//          //下载  \n            ZipUtils.downFile(response,serverPath, \"PreWork\"+\".zip\");  \n//          return null;  \n        }\n\n        //工具类\n\n        public class ZipUtils {\n    /** \n     * 将多个Excel打包成zip文件 \n     * @param srcfile \n     * @param zipfile \n     */  \n    public static void zipFiles(List<File> srcfile, File zipfile) {    \n        byte[] buf = new byte[1024];    \n        try {    \n            // Create the ZIP file    \n            ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipfile));    \n            // Compress the files    \n            for (int i = 0; i < srcfile.size(); i++) {    \n                File file = srcfile.get(i);    \n                FileInputStream in = new FileInputStream(file);    \n                // Add ZIP entry to output stream.    \n                out.putNextEntry(new ZipEntry(file.getName()));    \n                // Transfer bytes from the file to the ZIP file    \n                int len;    \n                while ((len = in.read(buf)) > 0) {    \n                    out.write(buf, 0, len);    \n                }    \n                // Complete the entry    \n                out.closeEntry();    \n                in.close();    \n            }    \n            // Complete the ZIP file    \n            out.close();   \n        } catch (IOException e) {    \n           e.printStackTrace();  \n        }    \n    }    \n\n\n    public static void downFile(HttpServletResponse response,String serverPath, String str) {    \n        try {    \n            String path = serverPath + str;    \n            File file = new File(path);    \n            if (file.exists()) {    \n                InputStream ins = new FileInputStream(path);    \n                BufferedInputStream bins = new BufferedInputStream(ins);// 放到缓冲流里面    \n                OutputStream outs = response.getOutputStream();// 获取文件输出IO流    \n                BufferedOutputStream bouts = new BufferedOutputStream(outs);    \n                response.setContentType(\"application/x-download\");// 设置response内容的类型    \n                response.setHeader(    \n                        \"Content-disposition\",    \n                        \"attachment;filename=\"    \n                                + URLEncoder.encode(str, \"UTF-8\"));// 设置头部信息    \n                int bytesRead = 0;    \n                byte[] buffer = new byte[8192];    \n                 //开始向网络传输文件流    \n                while ((bytesRead = bins.read(buffer, 0, 8192)) != -1) {    \n                   bouts.write(buffer, 0, bytesRead);    \n               }    \n               bouts.flush();// 这里一定要调用flush()方法    \n                ins.close();    \n                bins.close();    \n                outs.close();    \n                bouts.close();    \n            } else {    \n                response.sendRedirect(\"../error.jsp\");    \n            }    \n        } catch (IOException e) {    \n            e.printStackTrace();  \n        }    \n    }  \n}\n\n"]], "Tag": "算法设计"}
{"Answer": "使用listview就完美解决问题。", "Konwledge_Point": "网络中的流", "Question": ["RecycleView代码不更新！", ["RecycleView代码不更新！更新代码应该怎么写呢，有没有人教一下", "\n网络数据取到了，Recycleview 没显示出来数据", "\n\n", "public class FoodFragment extends Fragment {\n    public RecyclerView mFoodRecyclerView;//定义RecyclerView\n    //定义以goodsentity实体类为对象的数据集合\n    private ArrayList<FoodEntity> goodsEntityList = new ArrayList<FoodEntity>();\n    //自定义recyclerveiw的适配器\n    private FoodRecycleAdapter mRecyclerAdapter;\n    private JSONArray array;\n\n\n\n    public  FoodFragment() {\n    }\n\n    private static ChangeFoodFragment changeFoodFragment;\n\n    public static FoodFragment newInstance(ChangeFoodFragment foodFragment){\n        changeFoodFragment = foodFragment;\n        Bundle args = new Bundle();\n\n        FoodFragment fragment = new FoodFragment();\n        fragment.setArguments(args);\n        return fragment;\n    }\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,\n                             @Nullable Bundle savedInstanceState) {\n        View  view = inflater.inflate(R.layout.recyclerview_food, container, false);\n        //对recycleview进行配置\n\n        return view;\n    }\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n        initData();\n        initRecyclerView(view);\n\n\n\n\n\n    }\n    private void initData() {\n        new Thread(){\n            public void run()\n            {\n                String url = DocUtil.food_list;\n                OkHttpClient okHttpClient = new OkHttpClient();\n\n                String token= CacheUtils.getString(getActivity(), \"token\", \"\");\n                RequestBody body = new FormBody.Builder()\n                        .add(\"token\",token)\n                        .build();\n\n                Request request = new Request.Builder()\n                        .url(url)\n                        .post(body)\n                        .build();\n\n                Call call = okHttpClient.newCall(request);\n                try {\n                    Response response = call.execute();\n                    //System.out.println(response.body().string());\n                    try {\n                        final String string=response.body().string();\n                        final JSONObject object=new JSONObject(string);\n\n                        array=object.getJSONArray(\"list\");\n                        System.out.println(array);\n                        if(array.length()>0) {\n\n                            try {\n                                FoodEntity foodEntity =new FoodEntity();\n                                for(int i=0;i<array.length();i++){\n                                    JSONObject object1=array.getJSONObject(i);\n                                    foodEntity.setFoodtitle(object1.getString(\"foodtitle\"));\n                                    foodEntity.setFoodcontent(object1.getString(\"foodcontent\"));\n                                    foodEntity.setFoodcontentimg(object1.getString(\"foodcontentimg\"));\n                                    System.out.println(object1.getString(\"foodtitle\"));\n                                    System.out.println(object1.getString(\"foodcontent\"));\n                                    System.out.println(object1.getString(\"foodcontentimg\"));\n\n\n\n                                }\n\n\n\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }else {\n                            Toast.makeText(getActivity(), \"无数据\", Toast.LENGTH_SHORT).show();\n                        }\n                    } catch (JSONException e) {\n                        e.printStackTrace();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n\n\n\n\n//        for (int i=0;i<10;i++){\n//            FoodEntity foodEntity =new FoodEntity();\n//            foodEntity.setName(\"模拟数据FOOD\"+i);\n//            foodEntity.setContent(\"100\"+i);\n//            goodsEntityList.add(foodEntity);\n//        }\n    }\n    private void initRecyclerView(View view) {\n        //获取RecyclerView\n        mFoodRecyclerView=view.findViewById(R.id.food_recyclerView);\n        //创建adapter\n        mRecyclerAdapter = new FoodRecycleAdapter(getActivity(), goodsEntityList);\n        //给RecyclerView设置adapter\n        mFoodRecyclerView.setAdapter( mRecyclerAdapter );\n        //设置layoutManager,可以设置显示效果，是线性布局、grid布局，还是瀑布流布局\n        //参数是：上下文、列表方向（横向还是纵向）、是否倒叙\n        mFoodRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false));\n        //设置item的分割线\n        mFoodRecyclerView.addItemDecoration(new DividerItemDecoration(getActivity(),DividerItemDecoration.VERTICAL));\n\n\n        //RecyclerView中没有item的监听事件，需要自己在适配器中写一个监听事件的接口。参数根据自定义\n        mRecyclerAdapter.setOnItemClickListener(new FoodRecycleAdapter.OnItemClickListener() {\n            @Override\n            public void OnItemClick(View view, FoodEntity data) {\n                Toast.makeText(getActivity(),\"我是item\",Toast.LENGTH_SHORT).show();\n                changeToAnotherFragment();\n            }\n        });\n\n    }\n    @SuppressLint(\"ResourceType\")\n    private void changeToAnotherFragment() {\n        changeFoodFragment.changeFoodFragment();\n    }\n}\n\n", "\n\n", "public class FoodRecycleAdapter extends RecyclerView.Adapter<FoodRecycleAdapter.myViewHodler>{\n\n    private Context context;\n    private ArrayList<FoodEntity> goodsEntityList;\n    private ImageLoaderConfiguration configuration;\n    public DisplayImageOptions imageOptions;\n    private FoodRecycleAdapter adapter;\n\n\n    //创建构造函数\n    public FoodRecycleAdapter(Context context, ArrayList<FoodEntity> goodsEntityList) {\n        //将传递过来的数据，赋值给本地变量\n        this.context = context;//上下文\n        this.goodsEntityList = goodsEntityList;//实体类数据ArrayList\n    }\n\n    /**\n     * 创建viewhodler，相当于listview中getview中的创建view和viewhodler\n     *\n     * @param parent\n     * @param viewType\n     * @return\n     */\n    @Override\n    public myViewHodler onCreateViewHolder(ViewGroup parent, int viewType) {\n        //创建自定义布局\n\n        View itemView = View.inflate(context, R.layout.food_item, null);\n\n        return new myViewHodler(itemView);\n    }\n\n    /**\n     * 绑定数据，数据与view绑定\n     *\n     * @param holder\n     * @param position\n     */\n    @Override\n    public void onBindViewHolder(myViewHodler holder, int position) {\n             //根据点击位置绑定数据\n        FoodEntity data = goodsEntityList.get(position);\n//        holder.mItemGoodsImg;\n        configuration = ImageLoaderConfiguration.createDefault(context);\n        ImageLoader.getInstance().init(configuration);\n        imageOptions = DisplayImageOptions.createSimple();\n        holder.mItemGoodsName.setText(data.foodtitle);//获取实体类中的name字段并设置\n        holder.mItemContent.setText(data.foodcontent);//获取实体类中的price字段并设置\n        adapter=new FoodRecycleAdapter(context, goodsEntityList);\n\n        adapter.notifyItemRangeInserted(position,getItemCount());\n\n//        ImageLoader.getInstance().displayImage(DocUtil.base_url+\n//                        data.foodcontentimg, mItemGoodsImg,\n//                imageOptions);\n\n    }\n\n    /**\n     * 得到总条数\n     *\n     * @return\n     */\n    @Override\n    public int getItemCount() {\n        return goodsEntityList.size();\n    }\n\n    //自定义viewhodler\n    class myViewHodler extends RecyclerView.ViewHolder {\n        private ImageView mItemGoodsImg;\n        private TextView mItemGoodsName;\n        private TextView mItemContent;\n\n        public myViewHodler(View itemView) {\n            super(itemView);\n            mItemGoodsImg = itemView.findViewById(R.id.food_img);\n            mItemGoodsName =  itemView.findViewById(R.id.food_title);\n            mItemContent =  itemView.findViewById(R.id.tx_content);\n\n            //点击事件放在adapter中使用，也可以写个接口在activity中调用\n            //方法一：在adapter中设置点击事件\n            itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    //可以选择直接在本位置直接写业务处理\n                    //Toast.makeText(context,\"点击了xxx\",Toast.LENGTH_SHORT).show();\n                    //此处回传点击监听事件\n\n                    if(onItemClickListener!=null){\n                        onItemClickListener.OnItemClick(v, goodsEntityList.get(getLayoutPosition()));\n                    }\n                }\n            });\n\n        }\n    }\n\n    /**\n     * 设置item的监听事件的接口\n     */\n    public interface OnItemClickListener {\n        /**\n         * 接口中的点击每一项的实现方法，参数自己定义\n         *\n         * @param view 点击的item的视图\n         * @param data 点击的item的数据\n         */\n        public void OnItemClick(View view, FoodEntity data);\n    }\n\n    //需要外部访问，所以需要设置set方法，方便调用\n    private FoodRecycleAdapter.OnItemClickListener onItemClickListener;\n\n    public void setOnItemClickListener(FoodRecycleAdapter.OnItemClickListener onItemClickListener) {\n        this.onItemClickListener = onItemClickListener;\n    }\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "首先要确认pc和手机在同一个局域网，然后都是用本地ip。\r\nGood luck！", "Konwledge_Point": "网络中的流", "Question": ["android与PC用socket通信", ["写了一个小的测试程序，android手机和PC进行通信。", "\n服务器（PC）端代码：", "\npublic class SimpleServer", "\n{", "\n    public static void main(String[] args)", "\n        throws IOException", "\n    {", "\n        // 创建一个ServerSocket，用于监听客户端Socket的连接请求", "\n        ServerSocket ss = new ServerSocket(30000);  //①", "\n        // 采用循环不断接受来自客户端的请求", "\n        while (true)", "\n        {", "\n            // 每当接受到客户端Socket的请求，服务器端也对应产生一个Socket", "\n            Socket s = ss.accept();", "\n            OutputStream os = s.getOutputStream();", "\n            os.write(\"您好，您收到了服务器的新年祝福！\\n\"", "\n                .getBytes(\"utf-8\"));", "\n            // 关闭输出流，关闭Socket", "\n            os.close();", "\n            s.close();", "\n        }", "\n    }", "\n}", "\n\n", "客户端（android）代码：", "\npublic class SimpleClient extends Activity", "\n{", "\n    EditText show;", "\n    @Override", "\n    public void onCreate(Bundle savedInstanceState)", "\n    {", "\n        super.onCreate(savedInstanceState);", "\n        setContentView(R.layout.main);", "\n        show = (EditText) findViewById(R.id.show);", "\n        new Thread()", "\n        {", "\n            @Override", "\n            public void run()", "\n            {", "\n                try", "\n                {", "\n                    // �������ӵ�Զ�̷�������Socket", "\n                    Socket socket = new Socket(\"192.168.0.100\" , 30000);  //��", "\n                    // ��Socket��Ӧ����������װ��BufferedReader", "\n                    BufferedReader br = new BufferedReader(", "\n                        new InputStreamReader(socket.getInputStream()));", "\n                    // ������ͨIO����", "\n                    String line = br.readLine();", "\n                    show.setText(\"���Է���������ݣ�\" + line);", "\n                    // �ر���������socket", "\n                    br.close();", "\n                    socket.close();", "\n                }", "\n                catch (IOException e)", "\n                {", "\n                    e.printStackTrace();", "\n                }", "\n            }", "\n        }.start();", "\n    }", "\n}", "\n\n", "先启动PC机上的服务端，再启动安卓手机客户端，结果客户端无反应。", "\n初步判断应该是客户端socket构造函数里的第一个参数IP地址错误，请问这个地址应该填公网地址还是本地局域网地址？（网络环境：路由器宽带接入，PC有线接路由器，Android无线连WIFI）"]], "Tag": "算法设计"}
{"Answer": "我最近也在做相关的项目,2台android手机跟PC通讯都很正 常。如果需要我可以给你个DEMO程序参照。", "Konwledge_Point": "网络中的流", "Question": ["安卓和C# 用TCP通信发送数据", ["目前在做一个程序，安卓手机每一秒钟向PC机发送若干条数据，有可能一台机器发，也有可能若干台同时发，PC机用C#接收数据。我测试了一台安卓发数据可以正常接收，可是当若干台同时发数据的时候，就出现问题了。后来我发现不知道为什么，这些安卓设备的IP地址用DHCP自动获取IP的时候IP都是一样的，我想会不会就是因为两个相同IP的机器发送数据的时候，因为后来发后数据的机器会把原先正在发送的机器建立的TCP通信链接给关掉然后自己在发送数据，现在由于实验室路由器比较特殊，我没有权限改成静态获取，所以在此问一下是不是因为这个原因出的错，下面列出代码，麻烦大家帮忙看一看，出错的地方我用注释标记出来了", "\n安卓端发送数据代码", "\n\n", " public void sendToPC(String data){\n try {\n            s   =new Socket(\"192.168.0.104\",8730);\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n          DataOutputStream dout=null;   \n           try \n           {\n            dout =new DataOutputStream(s.getOutputStream());\n           Thread.sleep(50, 0);            \n            dout.writeBytes(data);\n            dout.flush();\n           }catch(Exception e){\n\n           }\n    }\n", "\n\n", "C#段代码", "\n\n", "     private void listenConnect()\n        {\n            while (true)\n            {\n                tcpClient = myListener.AcceptTcpClient();\n                //获取网络流\n                User user = new User(tcpClient);\n\n                Thread receiveThread = new Thread(receiveData);\n                receiveThread.IsBackground = true;\n                receiveThread.Start(user);\n\n            }\n        }\n        string receiveString = \"\";\n        public void receiveData(object u)\n        {\n            User user = (User)u;\n            NetworkStream netStream1 = user.client.GetStream();\n            while(true){\n               byte[] myReadBuffer = new Byte[1024];\n               int numberOfBytesRead = 0;\n               StringBuilder myCompleteMessage = new StringBuilder();\n               int nodeId = 0;\n               do\n               {\n                   numberOfBytesRead = netStream1.Read(myReadBuffer, 0, myReadBuffer.Length);//出错总是在这一句，提示错误“远程主机主动关闭现有连接”\n                   myCompleteMessage.AppendFormat(\"{0}\", Encoding.UTF8.GetString(myReadBuffer, 0, numberOfBytesRead));\n               } while (netStream1.DataAvailable);\n               receiveString = myCompleteMessage.ToString();\n               string[] receivearr = receiveString.Split('!');\n               for (int i = 0; i < receivearr.Length-1;i++ )\n               {\n\n                   string[] infoarr = receivearr[i].Split('#');\n                   DoWork(infoarr[1], infoarr[0]);\n               }\n\n\n            }\n        }\n                }\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/139915317856190.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;这个conn.getResponseCode()是你请求server的响应代码&amp;#xff0c;换句话说就是只要你请求成功了&amp;#xff0c;就会返回200&amp;#xff0c;和账号密码没有关系&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["安卓Post登录 相关问题", ["第一次写post请求，遇到了很多问题，到现在也没解决，望各位能给搞定了", "\n", "遇到的问题∶点击登录后，不管账号密码是否正确，都转到了登录后界面，代码里也写判断了。", "首先贴登录JAVA", "\n", "public ", "class", " MainActivity extends Activity { \n     \n    ", "private", " EditText ed1;\n    ", "private", " EditText ed2;\n    ", "private", " Button bt1;\n    @Override\n    protected void on", "Create(Bundle ", "savedInstanceState", ")", " {\n        super.on", "Create(", "savedInstanceState", ")", ";\n        set", "ContentView(R.", "layout", ".", "activity_main", ")", ";\n        \n        ed1 = find", "ViewById(R.", "id", ".", "activity_mainEditText1", ")", ";\n        ed2 = find", "ViewById(R.", "id", ".", "activity_mainEditText2", ")", ";\n        bt1 = find", "ViewById(R.", "id", ".", "activity_mainButton1", ")", ";\n        bt1.set", "OnClickListener(", "new", " OnClickListener()", "{\n\n                @Override\n                public void on", "Click(View ", "p1", ")", " {\n                    \n                    final String username = ed1.get", "Text()", ".", "to", "String()", ";\n                    final String password = ed2.get", "Text()", ".", "to", "String()", ";\n                    ", "if", "(", "TextUtils", ".", "is", "Empty(", "username", ")", "||", "TextUtils", ".is", "Empty(", "password", ")", "){\n                        ", "Toast", ".make", "Text(MainActivity.", "this", ",", "\"用户名或密码不可为空\"", ",Toast.LENGTH_SHORT)", ".show();\n                    }", "else", "{\n                    ", "new", " ", "Thread(", "new", " Runnable()", "{\n\n                            @", "Override", "\n                            public void run() {\n                                ", "/", "/", "final ", "String", " username = ed1.get", "Text()", ".", "to", "String()", ";\n                                ", "/", "/", "final ", "String", " password = ed2.get", "Text()", ".", "to", "String()", ";\n                                ", "String", " url1 = \"http:", "/", "/", "edj.sqktd.top", "/", "api", "/", "Login", "\";\n                                ", "String", " data = \"?username=\"+username+\"&password=\"+password+\"&appid=10000\";\n                                ", "try", " {\n                                    ", "URL", " url = ", "new", " ", "URL(", "url1", ")", ";\n                                    ", "try", " {\n                                        ", "HttpURLConnection", " conn = (", "HttpURLConnection", ") url.", "open", "Connection()", ";\n                                        conn.set", "RequestMethod(", "\"POST\"", ")", ";\n                                        conn.set", "ConnectTimeout(5000)", ";\n                                        conn.set", "RequestProperty(", "\"Content-type\"", ",", "\"application/json\"", ")", ";\n                                        ", "OutputStream", " os = conn.get", "OutputStream()", ";", "/", "/", " 获取输出流\n                                        os.write(data.get", "Bytes()", ");", "/", "/", "将数据提交给服务器\n                                        conn.connect();\n                                        ", "int", " rcod = conn.get", "ResponseCode()", ";\n                                        ", "InputStream", " is = conn.get", "InputStream()", ";\n                                        ", "/", "/", "Log", ".v(\"json\",\"", "MESSAGE", " ", "==", " > \"+stream", "ToString(", "is", ")", ");\n                                        \n                                        ", "/", "*", "Looper", ".prepare();\n                                        ", "Toast", ".make", "Text(MainActivity.", "this", ", ", "rcod", ", Toast.LENGTH_SHORT)", ".show();\n                                        ", "Looper", ".loop();", "*", "/", "\n                                        \n                                        ", "if", "(rcod ", "==", " 200){\n                                            \n                                            ", "Intent", " ", "in", " = ", "new", " ", "Intent(MainActivity.", "this", ",", "rcod", ".", "class", ")", ";\n                                            start", "Activity(", "in", ")", ";\n                                            finish();\n                                        }", "else", "{\n                                            finish();\n                                        }\n                                    } catch (", "IOException", " e) {}\n                                } catch (", "MalformedURLException", " e) {}\n\n                                \n                            }\n\n                        }).start();\n                        }\n                }\n            });\n        \n    }\n    \n    \n} \n\n", "\n", "\n", "：清单文件有完全的网络访问权限", "如图，完全不存在的账号也可以登录"]], "Tag": "算法设计"}
{"Answer": "多个输入流都没有关闭。用我给代码再试试。", "Konwledge_Point": "网络中的流", "Question": ["Process p = rt.exec(\"free -m\")问题，不吝赐教", ["Java代码 ", "\npublic static double[] getMemUsage() throws Exception {   ", "\n\n", "    double[] result = new double[4];   \n\n    Process p = rt.exec(\"free -m\");// 调用系统的命令   \n\n    BufferedReader in = null;   \n    try {   \n        in = new BufferedReader(new InputStreamReader(p.getInputStream()));   \n        String str = null;   \n        String[] strArray = null;   \n\n        while ((str = in.readLine()) != null) {   \n", "\n\n", "public static double[] getMemUsage() throws Exception {", "\n\n", "    double[] result = new double[4];\n\n    Process p = rt.exec(\"free -m\");// 调用系统的命令\n\n    BufferedReader in = null;\n    try {\n        in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n        String str = null;\n        String[] strArray = null;\n\n        while ((str = in.readLine()) != null) {\n            Java代码 \n    int m = 0;   \n\n    if (str.indexOf(\"/\") != -1) {// MemUsed   \n                                                strArray = str.split(\" \");   \n        for (String tmp : strArray) {   \n            if (tmp.trim().length() == 0)   \n                continue;   \n\n            if (++m == 3) {   \n                                            result[1] = Double.parseDouble(tmp);   \n\n            }   \n        }   \n\n    }   \n    if (str.indexOf(\"Mem\") != -1) {// MemTotal   \n\n        strArray = str.split(\" \");   \n        for (String tmp : strArray) {   \n            if (tmp.trim().length() == 0)   \n                continue;   \n\n            if (++m == 2) {   \n\n                result[0] = Double.parseDouble(tmp);   \n\n            }   \n        }   \n\n    }   \n}   \np.getErrorStream();   \n", "\n\n", "} catch (Exception e) {", "\n    e.printStackTrace();", "\n} finally {", "\n    in.close();", "\n    p.destroy();", "\n}", "\n// System.out.println(\"Performance Monitoring menUsed:\" + result[1]);", "\nreturn result;   ", "\n\n", "在一个线程（假设1毫秒一次）中，无限循环执行上面的代码：", "\n\n", "大概20分钟左右后出现如下异常：", "\n\n", "java.io.IOException: Cannot run program \"free\": java.io.IOException: error=24, Too many open files", "\n        at java.lang.ProcessBuilder.start(ProcessBuilder.java:459)", "\n        at java.lang.Runtime.exec(Runtime.java:593)", "\n        at java.lang.Runtime.exec(Runtime.java:431)", "\n        at java.lang.Runtime.exec(Runtime.java:328)", "\n        at LinuxSystemTool.getMemUsage(LinuxSystemTool.java:98)", "\n        at LinuxSystemTool.exec(LinuxSystemTool.java:67)", "\n        at LinuxSystemTool.run(LinuxSystemTool.java:42)", "\n        at java.lang.Thread.run(Thread.java:619)", "\nCaused by: java.io.IOException: java.io.IOException: error=24, Too many open files", "\n        at java.lang.UNIXProcess.(UNIXProcess.java:148)", "\n        at java.lang.ProcessImpl.start(ProcessImpl.java:65)", "\n        at java.lang.ProcessBuilder.start(ProcessBuilder.java:452)", "\n        ... 7 more", "\n\n", "查看网络相关资料，大概了解可能是由于打开的句柄过多造成，也没有找到解决办法，不吝赐教，谢谢", "\n\n", "[b]问题补充：[/b]", "\n如何清除getInputStream？？请详细说明，谢谢", "\n[b]问题补充：[/b]", "\n  Process p = rt.exec(\"free -m\");// 调用系统的命令", "\n大概循环执行1000次左右，就挂掉了，出现上述错误", "\n\n", "原因可能是执行free -m，打开的缓存IO文件过多，如何释放？？", "\n\n", "已经试过的办法：", "\n} finally {", "\n    in.close();", "\n    p.destroy();", "\n}", "\n都不起作用，各位大侠分析分析，不胜感谢。", "\n[b]问题补充：[/b]", "\n首先，非常感谢lewhwa的热情帮助。", "\n\n", "你提供代码和方法我也做过测试，问题依旧，各个流我分别关闭，循环执行1000", "\n\n", "次左右还是出现同样的问题。"]], "Tag": "算法设计"}
{"Answer": "钱多有钱多的做法，钱少有钱少的做法。反正一分钱一分货", "Konwledge_Point": "网络中的流", "Question": ["大家看看这个系统开发需要多少钱？", ["Web OA系统项目需求书", "\n1 项目目标", "\n1.  本系统开发后将作为产品向用户不限量发布；", "\n2.  基本建设内容：短信平台、登陆系统、门户型首页、新闻发布系统、、BBS 论坛系统（栏目添加、主题发表回复功能）、用户群组、消息提醒、排版打印、考核系统、统计汇总、查询、公告。实现多用户协同办公，基层单位与主管部门办公规范化、流程化。", "\n2 具体过程", "\n1.  主管单位通过门户界面和新闻发布系统发布通知、新闻、政策法规等内容，展示自己的工作,6-8个栏目。", "\n2.  利用BBS论坛系统创建栏目发表主题（工作内容），设定主题完成时间、指定需要完成回复主题的用户（建立用户群组），基层单位根据主题要求完成回复。栏目可下设子标题，可添加、修改。", "\n3.  基层单位和网格人完成主题工作，对不能完成的工作，可向主管单位申请协助，（新建主题发给主管单位）。", "\n网格人：基层单位创建的协助完成指定某项具体工作的用户。", "\n4.  当基层单位没有按时或超时没有完成工作，利用短信和站内消息提醒基层单位", "\n5.  利用考核系统完成对基层单位工作的考核，主管单位设置每个工作点（贴子）分值，统计基层单位是否按时完成回复，如不按时完成自动扣分，主管单位可时时汇总基层单位完成工作状态。", "\n5.  排版打印主管单位可利用此功能打印本级完成的各项工作（发表的主题）和新闻内容，基层单位打印本级工作的内容；", "\n\n", "\n", "查询功能主管单位和基层单位搜索标题内容，可按年度-栏目-子标题搜索出相关内容，能够查询列出某个时间段或某项工作的相关内容。\n3 开发范围\n前台网站开发、后台数据库架构、用户界面开发\n3.1 适用平台\n网站构建前台所采用的各种表现形式及所应用的各种插件应符合网络通行标准，适合绝大部分操作系统和通用浏览器浏览需求。\n3.2 软件架构\n以Web应用服务为核心,以数据库系统为基础，以浏览器为用户端的B/S软件体系结构；先进的工作流和规则库解决方案，以及面向对象的分析和设计，促进了结构化和安全性的系统开发，提高软件的再利用。\n3.3 服务器配置\n请提供服务配置……………………　，带宽移动百兆光纤。\n3.3.1 界面\n", "\n首页\n", " \n主管单位\n", "\n主管单位\n", "\n基层单位", "\n"]], "Tag": "算法设计"}
{"Answer": "fiddler抓包对比你的程序和浏览器两者提交的参数区别", "Konwledge_Point": "网络中的流", "Question": [".net HttpWebRequest/ajax() 访问 java Post接口  对方接口一直提示参数不全", ["Httpwebreques请求代码   :", "\n\n", "        HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(\"http://www.baoyanghui.com/Car_2_0/api/open/order/submit\");\n            request.Method = \"POST\";\n            request.Timeout = 8000;\n            request.KeepAlive = false;\n            request.Host = \"www.baoyanghui.com\";\n            request.ContentType = \"application/x-www-form-urlencoded;charset=UTF-8\";\n            request.UserAgent = \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36\";\n            //byte[] payload = Encoding.UTF8.GetBytes(tparams);\n            //request.ContentLength = payload.Length;\n            using (Stream stream = request.GetRequestStream())\n            {\n\n                StreamWriter myStreamWriter = new StreamWriter(stream, Encoding.GetEncoding(\"UTF-8\"));\n                myStreamWriter.Write(tparams);\n                //stream.Write(payload, 0, payload.Length);\n            }\n\n            HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n            if (response.StatusCode == HttpStatusCode.OK)\n            {\n                Stream stream = response.GetResponseStream();\n                System.IO.StreamReader streamReader = new StreamReader(stream, Encoding.GetEncoding(\"UTF-8\"));\n                StringBuilder content = new StringBuilder(streamReader.ReadToEnd());// 读取流字符串内容\n                var res = JsonConvert.DeserializeObject<BranchList>(content.ToString());\n                if (res.code != \"0\")\n                {\n                    throw new Exception(\"订单:\" + orderId + \"。推送失败:\" + res.message);\n                }\n            }\n            else\n            {\n                throw new Exception(\"订单:\" + orderId + \"。推送失败:网络错误\");\n            }\n", "\n\n", "ajax请求代码    :", "\n\n", "        $.ajax({\n            type: \"post\",\n            async: false,\n            data: models,\n            url: \"http://www.baoyanghui.com/Car_2_0/api/open/order/submit\",\n            dataType: \"json\",\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n            success: function (json) {\n                console.log(\"success:\");\n                console.log(json);\n                /*\n                $.post(location.href, { ids: orderIds.join(','), companyNames: companyNames.join(','), shipOrderNumbers: shipOrderNumbers.join(','), needShip: needShip }, function (result) {\n                    loading.close();\n                    if (result.success) {\n                        $.dialog.succeedTips(\"操作成功！\", function () { window.location.href = \"./Management\" });\n                    }\n                    else\n                        $.dialog.errorTips(\"操作失败,\" + result.msg);\n                });*/\n            },\n            error: function (e) {\n                console.log(e);\n            }\n        });\n", "\n\n", "两次都请求成功了，就是参数一直提示不全，但我确定参数是都有传递的，包括必须的和可选的，都传了。", "\n\n", "求问！"]], "Tag": "算法设计"}
{"Answer": "&lt;h2 id=\"h2_已解决&amp;#xff01;创建流的时候&amp;#xff0c;参数和flv的参数不一致&amp;#xff0c;在ffmpeg内部进行发送逻辑时&amp;#xff0c;直接把发送的buffer大小设置为0&amp;#xff0c;导致没有数据发出。_1663952133117\"&gt;已解决&amp;#xff01;创建流的时候&amp;#xff0c;参数和flv的参数不一致&amp;#xff0c;在ffmpeg内部进行发送逻辑时&amp;#xff0c;直接把发送的buffer大小设置为0&amp;#xff0c;导致没有数据发出。&lt;/h2&gt;\n&lt;p&gt;如果是从已知流取数据&amp;#xff0c;最好是直接复制整个AVCodecContext&amp;#xff0c;要么就是自己创建&amp;#xff0c;然后发送使用该codec编码出来的流&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["ffmpeg写数据失败", ["问题遇到的现象和发生背景", "\n", "使用av_write_frame向流写入一个数据包，代码返回正常0，但是，wireshark抓包没有看到数据被发出去", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "            ", "int", " ret = av", "_write_frame(", "mgr", "->", "out_fmt_ctx_", ", ", "t", "->GetPacket()", ");\n\n            ", "if", " (ret < ", "0", ") {\n                ", "char", " buf", "[", "128", "]", " = { ", "0", " };\n                av", "_make_error_string(", "buf", ", 128, ", "ret", ")", ";\n                printf(", "\"deal with: %p, res: %d, reason: %s\\n\"", ", &(*(t->", "GetPacket()", ")), ret, buf);\n            }\n", "\n", "请问这个大概率会是什么原因呢？要怎么解决"]], "Tag": "算法设计"}
{"Answer": "看你的日志你好像是把textview设置到button中了，就是你findviewbyid获取的是textview但是赋值给button了，", "Konwledge_Point": "网络中的流", "Question": ["HttpURLConnection测试程序崩溃", ["今天照《第一行代码》第10章敲出来的HttpURLConnection测试程序运行之后一直闪退，求大神指点，小白拜谢！", "\n\n", "错误日志如下：", "\n\n", "\n\n", "代码如下：", "\n\n", " package com.example.networktest;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport android.app.Activity;\nimport android.app.ActionBar;\nimport android.app.AlertDialog.Builder;\nimport android.app.Fragment;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.os.Build;\n\npublic class MainActivity extends Activity implements OnClickListener {\n    public static final int SHOW_RESPONSE = 0;\n    private TextView textView;\n    private Button button;\n    private Handler handler = new Handler() {\n        public void handlerMessage(Message msg) {\n            switch (msg.what) {\n            case SHOW_RESPONSE:\n                String response = (String) msg.obj;\n                // 更新UI操作\n                textView.setText(response);\n                break;\n\n            default:\n                break;\n            }\n        }\n    };\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.fragment_main);\n        textView = (TextView) findViewById(R.id.sendRequest);\n        button = (Button) findViewById(R.id.responseText);\n        button.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        // TODO Auto-generated method stub\n        if (v.getId() == R.id.sendRequest) {\n            sendRequsetWithHttpURLConnection();\n        }\n    }\n\n    private void sendRequsetWithHttpURLConnection() {\n        // 开启线程来发起网络请求\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                HttpURLConnection connection = null;\n                try {\n                    URL url = new URL(\"http://www.baidu.com\");\n                    connection = (HttpURLConnection) url.openConnection();\n                    connection.setRequestMethod(\"GET\");\n                    connection.setConnectTimeout(8000);\n                    connection.setReadTimeout(8000);\n                    InputStream in = connection.getInputStream();\n                    // 对获取到的输入流进行解析\n                    BufferedReader reader = new BufferedReader(\n                            new InputStreamReader(in));\n                    StringBuilder response = new StringBuilder();\n                    String line ;\n                    while ((line=reader.readLine()) != null) {\n                        response.append(line);\n                    }\n                    // 发送返回结果\n                    Message message = new Message();\n                    message.what = SHOW_RESPONSE;\n                    message.obj = response.toString();\n                    handler.sendMessage(message);\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } finally {\n                    if (connection != null) {\n                        connection.disconnect();\n                    }\n                }\n            }\n        }).start();\n    }\n\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "把server端代码也贴出来", "Konwledge_Point": "网络中的流", "Question": ["java 我执行一个非常简单的socket程序都出错！java.net.ConnectException: Connection refused: ", ["\n", "java  网络编程", "\n", " ", "\n", "我执行一个非常简单的socket程序都出错！要崩溃了！我关闭了防火墙也不行，试了Ping 127.0.0.1是可以的，而且我查了这个端口也没有被占用，怎么解决？", "\n", "java.net.ConnectException: Connection refused: connect", "\n", "at java.net.DualStackPlainSocketImpl.connect0(Native Method)", "\n", "at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:79)", "\n", "at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)", "\n", "at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)", "\n", "at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)", "\n", "at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)", "\n", "at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)", "\n", "at java.net.Socket.connect(Socket.java:579)", "\n", "at java.net.Socket.connect(Socket.java:528)", "\n", "at java.net.Socket.<init>(Socket.java:425)", "\n", "at java.net.Socket.<init>(Socket.java:208)", "\n", "at com.hxw.socket.SimpleSocketClient.main(SimpleSocketClient.java:22)", "\n", "java.lang.NullPointerException", "\n", "at com.hxw.socket.SimpleSocketClient.main(SimpleSocketClient.java:37)", "\n", " ", "\n", "源码在此：", "\n", "package com.hxw.socket;\n\nimport java.io.*;\nimport java.net.*;\n\n/**\n * 简单的Socket客户端 功能为：发送字符串“Hello”到服务器端，并打印出服务器端的反馈\n */\npublic class SimpleSocketClient {\n    public static void main(String[] args) {\n        Socket socket = null;\n        InputStream is = null;\n        OutputStream os = null;\n        // 服务器端IP地址\n        String serverIP = \"127.0.0.1\";\n        // 服务器端端口号\n        int port = 10002;\n        // 发送内容\n        String data = \"Hello\";\n        try {\n            // 建立连接\n            socket = new Socket(serverIP, port);\n            // 发送数据\n            os = socket.getOutputStream();\n            os.write(data.getBytes());\n            // 接收数据\n            is = socket.getInputStream();\n            byte[] b = new byte[1024];\n            int n = is.read(b);\n            // 输出反馈数据\n            System.out.println(\"服务器反馈：\" + new String(b, 0, n));\n        } catch (Exception e) {\n            e.printStackTrace(); // 打印异常信息\n        } finally {\n            try {\n                // 关闭流和连接\n                is.close();\n                os.close();\n                socket.close();\n            } catch (Exception e2) {\n                e2.printStackTrace();\n            }\n        }\n    }\n}\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;解决了&amp;#xff0c;今天windows defender突然弹了个是否用于网络通信的东西。点下确认就ok了&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["APP使用TCP连接下位机时出现错误，如何解决？", ["Android APP控制Stm32单片机继电器时，TCP连接出现错误，但是在使用网络调试助手和APP连接时就可以正常使用,该怎么解决？", "TCPservice.class", "package com.example.smarthome;", "\n", "import android.app.Service;", "import android.content.Intent;", "import android.os.IBinder;", "import android.os.Looper;", "\n", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.PrintStream;", "import java.net.InetSocketAddress;", "import java.net.Socket;", "import java.net.SocketAddress;", "\n", "public class TCPService extends Service {", "    public static Socket socket;", "    public static PrintStream output;", "    boolean conn = false;", "    public String ip=\"192.168.31.179\";", "    public String port=\"8080\";", "    /*", "    String ip=\"192.168.31.179\";", "    String port=\"8080\";", "     */", "\n", "public ", "TCPService()", " {\n}\n\n@Override\npublic IBinder on", "Bind(Intent ", "intent", ")", " {\n    ", "// ", "TODO:", " Return the communication channel to the service.", "\n    throw ", "new", " ", "UnsupportedOperationException(", "\"Not yet implemented\"", ")", ";\n}\n@Override\npublic ", "int", " on", "StartCommand(Intent ", "intent", ", ", "int", " ", "flags", ", ", "int", " ", "startId", ")", "\n{\n    MyThread myThread = ", "new", " ", "MyThread()", ";\n    ", "new", " ", "Thread(", "myThread", ")", ".start", "()", ";\n    ip = intent.get", "StringExtra(", "\"ip\"", ")", ";\n    port = intent.get", "StringExtra(", "\"port\"", ")", ";\n    return super.on", "StartCommand(", "intent", ", ", "flags", ", ", "startId", ")", ";\n}\n\n", "//socket连接线程", "\n", "class", " MyThread implements Runnable{\n    @Override\n    public void run", "()", "{\n        ", "try", " {\n            socket = ", "new", " ", "Socket()", ";\n            SocketAddress socAddress = ", "new", " ", "InetSocketAddress(", "ip", " ,Integer.", "valueOf", "(", "port", ")", ");\n            socket.connect(socAddress, ", "5000", ");\n            InputStream inputstream = socket.get", "InputStream()", ";\n            ", "/* 获取输出流 */", "\n            output = ", "new", " ", "PrintStream(", "socket", ".", "getOutputStream", "()", ", ", "true", ", ", "\"utf-8\"", ");\n            conn = ", "true", ";\n            byte buffer", "[]", " = ", "new", " byte", "[", "1024", "]", ";", "//接收数组的长度", "\n            ", "int", " len2 ;\n            String receiveData;\n            ", "//非阻塞式连接", "\n            ", "while", "(conn){\n                ", "//接收网络数据", "\n                ", "if", "( (len2 = inputstream.read(buffer)) != -", "1", "){\n                    receiveData = ", "new", " ", "String(", "buffer", ", 0, ", "len2", ")", ";\n                    Intent CMDintent = ", "new", " ", "Intent()", ";\n                    ", "CMDintent", ".", "set", "Action(", "\"com.example.communication.data\"", ")", ";\n                    ", "CMDintent", ".", "put", "Extra(", "\"data\"", ", ", "buffer", ")", ";   ", "//buffer为数组，receivedata为文本", "\n                    send", "Broadcast(CMDintent)", ";\n                }", "else", "{\n                    break;\n                }\n            }\n            output.close", "()", ";\n            socket.close", "()", ";\n            ", "Looper", ".", "loop", "()", ";\n        } catch (IOException e) {\n            ", "// TODO Auto-generated catch block", "\n            e.print", "StackTrace()", ";\n            ", "// Looper.prepare();", "\n        }\n    }\n\n};\n\n", "//发送方法（（可以把参数改成Byte[]）：", "\npublic static void send(final byte", "[]", " arr)\n{\n    ", "new", " ", "Thread(", "new", " Runnable()", " {\n        public void run", "()", " {\n            ", "if", " (socket.is", "Connected()", ") {\n                ", "try", " {\n                    output.write(arr);\n                } catch (IOException e) {\n                    e.print", "StackTrace()", ";\n                }\n            }\n        }\n    }).start", "()", ";\n}\n", "\n", "}", "\n", "MeFragment.class", "\n", "package com.example.smarthome;", "\n", "import android.content.Intent;", "import android.os.Bundle;", "import android.view.LayoutInflater;", "import android.view.View;", "import android.view.ViewGroup;", "import android.widget.Button;", "import android.widget.TextView;", "\n", "import androidx.fragment.app.Fragment;", "\n", "public class MeFragment extends Fragment{", "\n", "private", " TextView tev_uname, tev_sex, tev_ip, tev_port, tev_ban;\n", "Button", " bt1, bt_conn;\n", "String", " ip=", "\"192.168.31.179\"", ";\n", "String", " port=", "\"8080\"", ";\n", "\n", "   /* String ip=\"10.10.100.101\";", "    String port=\"8899\";*/", "    String banben = \"1.0\";", "\n", "@Override", "\n", "public", " View ", "onCreateView", "(LayoutInflater inflater, ViewGroup container,\n                         Bundle savedInstanceState)", " {\n    ", "// Inflate the layout for this fragment", "\n    ", "View", " ", "Melayout", " ", "=", " inflater.inflate(R.layout.fragment_me, container, ", "false", ");\n\n    tev_uname = Melayout.findViewById(R.id.me_uname);\n    tev_sex = Melayout.findViewById(R.id.me_sex);\n    tev_ip = Melayout.findViewById(R.id.ip);\n    tev_port = Melayout.findViewById(R.id.port);\n    tev_ban = Melayout.findViewById(R.id.banben);\n\n\n\n\n    ", "Intent", " ", "intent", " ", "=", " getActivity().getIntent();\n    ", "String", " ", "uname", " ", "=", " intent.getStringExtra(", "\"uname\"", ");\n    ", "String", " ", "sex", " ", "=", " intent.getStringExtra(", "\"sex\"", ");\n\n    tev_uname.setText(", "\"   用户名：\"", " + uname);\n    tev_sex.setText(", "\"   性    别：\"", " + sex);\n    tev_ban.setText(", "\"版本号：\"", " + banben);\n\n\n    bt1 = Melayout.findViewById(R.id.btn_quit);\n    bt1.setOnClickListener(", "new", " ", "View", ".OnClickListener() {\n        ", "@Override", "\n        ", "public", " ", "void", " ", "onClick", "(View view)", " {\n            ", "Intent", " ", "intent", " ", "=", " ", "new", " ", "Intent", "(getActivity(), MainActivity.class);\n            startActivity(intent);\n        }\n    });\n\n    tev_ip.setText(ip);\n    tev_port.setText(port);\n\n    bt_conn = Melayout.findViewById(R.id.btn_connect);\n    bt_conn.setOnClickListener(", "new", " ", "View", ".OnClickListener() {\n        ", "@Override", "\n        ", "public", " ", "void", " ", "onClick", "(View view)", " {\n            ip = tev_ip.getText().toString();\n            port = tev_port.getText().toString();\n            ", "Intent", " ", "intent1", " ", "=", " ", "new", " ", "Intent", "(getActivity(), TCPService.class);\n            intent1.putExtra(", "\"ip\"", ", ip);\n            intent1.putExtra(", "\"port\"", ", port);\n            ", "//startActivity(intent1);", "\n            getActivity().startService(intent1);\n        }\n    });\n\n    ", "return", " Melayout;\n}\n", "\n", "}", "\n"]], "Tag": "算法设计"}
{"Answer": "这个还真没有 其实我也是搞java的 呵呵 就是做一些小东西用winform 为了开发速度快 其实安装虚拟机也无所谓 现在多数软件已经都是.net的了 安装了虚拟机以后也省事了 有类似的软件也就无所谓了 java开发不是不好 不过那个界面确实有点说不过去 而且开发速度远不如.net 我对java的看法是 做服务可以 作集成也可以 就是做界面得考虑考虑 呵呵 vb不使用是因为那东西开发打包也不怎么小 而且很多人现在都不用那个东西了 估计您的项目组也没这方面的人了 不使用vc更简单了 那东西作界面活活把人累死 我用vc就是做dll ocx为了达到访问winapi的目的 其他的东西全部不考虑用这个东西作", "Konwledge_Point": "网络中的流", "Question": ["企业管理软件，单机版，用什么语言合适", ["一般就用个进销存，做帐，单机C/S版的，最多也只有2，3个用户。类似于华军软件园上试用的那些管理软件。", "\n如果是员工数很多规模很大的企业，我会选择B/S。升级与维护也方便。我们小县城一般也是很小规模的厂子。", "\n\n", "那我应该选用什么语言比较合适呢？我用过点.net,java,php，便这几样多数在b/s上比较有优势，但是单机版，b/s没有优势，还是一样要架服务器，据我所知除php倒是可以用一些打包的方法，向导安装，asp,asp.net,j2ee做单机版似乎没有省力多少。.net,java如果要c/s版要安装虚拟机也挺麻烦的。", "\n\n", "一般那些桌面版的管理软件，比如医药、餐饮、服饰专卖店、售票等用的，它们是用什么语言写的，delphi,foxpro,vb,pb，VC这些吗？还有没有别的语言可以写c/s管理软件。 ", "\n[b]问题补充：[/b]", "\nto lovewhzlqvc:", "\n对于数据库的操作应该还不及delphi那么方面吧，它似乎做底层一些的开发更好些，是这样吗？", "\n我对这些语言都了解一些，都没有进一步的学习，所以现在要长远的选择好，以后可以精通其一。", "\ndelphi人们都说它没落了，这让我有点虚，是我浮躁了。", "\n[b]问题补充：[/b]", "\nto lovewhzlqvc: ", "\n现在我的问题就是迫切地需要从一门语言来作为突破口，尤其对于编程思想通过这门语言来领会，比如OO，设计模式。", "\n我觉得java语言挺适合学习上面编程思想的，请教java在写好swing swt fx等桌面好，怎么部署可以更方便安装吗，像delphi,vb这类click next就可以的，类似于.net winform在vs中，我打包成msi过，但.net fw太大了，javavm小一点？", "\n我知道点java做桌面似乎不太流行，但我跟某些程序员一样，对win有点排斥，尤其不愿使用盗版win。", "\n[b]问题补充：[/b]", "\nto lovewhzlqvc:", "\n对于用java桌面软件，请问有什么好的办法去部署吗？", "\n[b]问题补充：[/b]", "\n依照你的提示找出了原文，[url]", "http://www.blogjava.net/huliqing/archive/2008/04/18/193907.html[/url]。太好了，就像作者所说“Java在我的眼里算是最完美的语言了，也是我最喜爱的语言。”，我也是这么想的。谢谢了。", "\n[b]问题补充：[/b]", "\nto andilyliao:", "\n我去年也做过2个winform的，控件加是ado.net用起是的确超爽。可虚拟机还是一个问题，于是我按着jvm打包的思路去网上搜，效果不太满意，有人说fetion也ms为移动制定的framework才20多M，还有一种说法是通过.net framework client profile将多余的类库踢除出去。这些讨论都是通过官网上看来的，从那些mvp的口气中，感觉到.net fw似乎不太开放，不鼓励人们阉割.net fw，他们是盼着这个框架能越来越普及，大家都装完整版的，这样ms在.net的市场又加固了。", "\n你有没有好的对.net framework瘦身方案啊？", "\n[b]问题补充：[/b]", "\nto andilyliao: ", "\n已经看到，回家再回复。下班先", "\n[b]问题补充：[/b]", "\nTO andilyliao:", "\n\n", ".net甚至全体ms产品的开发效率是绝对的王者，这点无可争议。有利也有弊，以至于我用惯了鼠标点点的偷懒方式后，惭惭地就不清楚它背后是怎么实现了，mssql之于mysql就不够明了开放了，比如备份一下数据库，mysql导到文本里，数据库内容一目了解，移植也方便得多。", "\njava，我也是喜欢得不了了，买的书，java是最多的，从语法、算法、web开发，android开发，都有了，如thinking in java,sun-core java,servlet jsp core,oreilly－jsp design，数据结构与算法java描述，android开发范例，java web开发典型模块大全，而其他技术书往往只有一到两本或者纯粹只看网上的资源、电子书等。只是在我现在的技术水平看来，还是仰视中。"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-python\"&gt;\n&lt;span class=\"hljs-attr\"&gt;res&lt;/span&gt; &amp;#61; requests.get(&lt;span class=\"hljs-string\"&gt;&amp;#39;https://openapi.cheyun.com/article/41534&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-attr\"&gt;json_data&lt;/span&gt; &amp;#61; json.loads(res.text)\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "网络中的流", "Question": ["python 转换json时错误，提示在文中", ["以下代码我使用  data = json.loads(text)获取的时候提示错误 ，text等于以下代码，错误提示为“json.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 233 (char 232)，请问我应该如何转换为json", "”", "\n", "\n{\n    ", "\"code\"", ": 200,\n    ", "\"message\"", ": ", "\"succees!\"", ",\n    ", "\"data\"", ": {\n        ", "\"id\"", ": ", "\"39581\"", ",\n        ", "\"title\"", ": ", "\"纯电旗舰登场，大众为用户带来了什么？\"", ",\n        ", "\"content\"", ": ", "\"<p>6个月前，大众ID.4 X和ID.4 CROZZ在国内首次亮相。1个月前，分别落户南北合资公司的两开始向用户交付。备受消费者好评，大众也先于对手完成了专用纯电平台产品在中国市场的投放，这是大众向电动化、全面互联化和碳中和迈进的重要节点。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1977", "\\", "/large", "\\", "/16187553727977.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>与此同时，领先对手的大众选择了快马再加鞭。2021上海车展前夕，大众ID.6正式全球首发。与两款ID.4相同，ID.6 X和ID.6 CROZZ会分别在上汽大众与一汽-大众投产。作为大众ID.系列在国内的旗舰车型，二者将在今年夏季正式上市。<\\/p><p>伴随两款ID.6的到来，大众在扩充国内纯电产品阵容之余，还会加速充电网络与相关基础设施建设。在产品与服务共同组成体验闭环的时代，以用户为中心的大众，要做国人新能源车的首选品牌。另外，今年大众将带来5款ID.系列车型，至2023年，ID.家族在中国的产品阵容将增加到8款。<\\/p><h4>目标家庭用户，细节各有不同<\\/h4><p>身为国产ID.系列的旗舰产品，ID.6定位于中大型纯电SUV。相比适合两口之家或家里第二辆车的ID.4，ID.6要扛起举家出行和“第一辆车”的重担。所以“大”是ID.6最鲜明的特点，包含大气、大块头两个方面。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1383", "\\", "/large", "\\", "/16187555451383.jpeg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>两款ID.6的外观设计思路大差不差，圆润饱满的线条搭配双色车身，在大气稳重与年轻化之间完美平衡。用LED灯带替代传统镀铬饰条的思路，与ID.4一脉相承，带发光LOGO和日行灯的格栅就是例子，不过在ID.6上“一道杠”变成了“两道杠”。矩阵式LED头灯能根据天气、道路类型、对向有无来车等因素，自行调节光线照射范围。优化了夜间驾驶员视野，还不会干扰到其他司机。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/228", "\\", "/large", "\\", "/16187555918228.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>既然是主打家用路线的产品，隔音和空间表现都不能差。这次大众不仅拿来了双层隔音玻璃，还在车门、底盘等处放置了大量吸音材质。配合两者2965mm的轴距、MEB纯电平台的短前后悬设计，就算家里三代同堂ID.6也能装得下。虽然二者车身尺寸稍有不同（详情如下），但都在一个水平线上，大块头+长轴距为放置三排座椅铺平了道路。需要说明的是，ID.6会提供6座和7座车型，前者第二排为两个独立座椅。头等舱般的出行体验+灵活多变的空间，大众用心了。<\\/p><blockquote><p>一汽-大众ID.6 CROZZ车身长宽高：4891mmx1848mmx1679mm<\\/p><p>上汽大众ID.6 X车身长宽高：4876mmx1848mmx1680mm<\\/p><\\/blockquote><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1937", "\\", "/large", "\\", "/16187556345937.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>车尾的差异主要体现在尾灯和保险杠，3D立体效果的LED尾灯两者都有。南派善用折线、北派喜欢点阵式设计，风格不同但都很有科技感。需要说明的是，为了将驾乘舒适性做到最佳，ID.6前后轮胎的扁平比也不尽相同，更厚的前轮用来吸收更多的路面颠簸。<\\/p><p>从车身尺寸到座椅布局方式，作为旗舰产品的ID.6有更大更上档次的传统思路，可面向家庭用户，大众在设计之初对细节的考量已显现出“场景化”的影子。从给用户怎样的配置、多大的空间，到营造静谧的出行体验，产品逻辑变化的背后是站在用户视角思考问题的大众。<\\/p><p>就像大众汽车乘用车品牌中国CEO冯思翰博士所说：“从一开始，我们的目标就是将ID.6打造为‘移动休憩室’，为中国用户带来极为顺畅、舒适和安心的体验。短前后悬和2965毫米的长轴距设计可容纳3排座椅，实现灵活的6座或7座布局，进而满足家庭出行需要。”<\\/p><h4>不可少的智能科技，块头大还能跑的远？<\\/h4><p>这对ID.6内饰延续了两款ID.4的设计路线，全液晶仪表+中控触屏+触控为主的车内“按键”，满满的数字化元素。中控台前部的ID.Light灯条，会在上下车、开启导航、充电或状态下，分别变为白色、流动点亮的蓝色、绿色和红色。既会跟你打招呼，也能用不同的点亮方式与颜色传递增量信息，这便是智能交互的一部分。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1395", "\\", "/large", "\\", "/16187556755395.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>凭借E3电子架构的强大算力，智能网联4.0车机系统不仅拥有流畅的触控操作体验，还提供了在线导航、在线音乐\\/电台、智能家居等联网应用。覆盖了娱乐、生活等多场景，还支持语音控制，并实现了前排音源定向，在第二排也能用“你好，大众”唤醒车机。不同于ID.家族的海外车型，国产版会预装算力更强的芯片，支持的功能更多、长期使用也能流畅依旧。而在品鉴会上，大众官方表示今年四季度，国产ID.系列将迎来首次OTA升级。未来会保持每年4-5次的升级频率，为用户带来更多功能和更出色的体验。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/522", "\\", "/large", "\\", "/16187557592522.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>在ID.6上，AR-HUD没有缺席。借助AR增强现实技术，大众将HUD的透射影像分为了两层，AR层在上，行车基础信息层在下。启动车机导航、带全速域自适应巡航和车道居中保持的Travel Assist巡航辅助系统后，AR层里能显示分道线、并入的车辆和导航提示等信息。驾驶员平视前方，就能对车辆行驶状态和引导信息了如指掌。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1555", "\\", "/large", "\\", "/16187558675555.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>除了上述的智能科技体验外，大众在“让用户更满意”这事上也没少下功夫。比如，ID.6的空调系统采用双滤芯设计，额外增加的活性炭滤芯，能更好的过滤空气中的杂质，为一家人带来最优的座舱环境。<\\/p><p>再比如，按下转向柱侧面的启动开关，车辆会进入舒适模式，车机、空调都能正常工作，用的是动力电池包的能量而非12V电瓶，停车等人不至于百无聊赖。甚至车内的触控键还应用了IML盖板镀膜工艺，不用担心亮面烤漆键上出现小划痕了。<\\/p><p>此外，ID.6 CROZZ侧门板上有能发光的镭射饰条，ID.6 X这部分是皮质包裹，喜欢前卫科技or追求传统质感，无论哪种你都有的选。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/858", "\\", "/large", "\\", "/16187559598858.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>当然，对电动车用户来说，续航能力是最重要的。从公布的信息来看，ID.6会延续ID.4的动力配置，后驱车型提供125kW\\/310Nm、150 kW\\/310Nm两种动力输出，前异步+后同步双电机四驱版拥有225kW\\/460Nm的动力输出。量产车会提供62kWh和83kWh两种容量的电池包，NEDC工况下续航里程都会超过580km，并支持100kW快充。<\\/p><p>相比最大续航里程550+km的ID.4，ID.6的动力参数没变，但输出特性会更居家。加上0.28cd的风阻系数，尺寸更大、分量更重的ID.6，能跑的比ID.4更远。同时二氧化碳热泵空调会出现在配置表上，平均百公里能省3-4kWh的电，北方用户冬天不慌。<\\/p><p>浓缩大众数字化科技、关注居家出行、在细节上将产品细分，在相同的技术框架内满足了更多用户的口味。ID.家族产品数量马上要翻番了，可产品本身没有“赶工”的迹象，甚至能发现新车照顾到的细节比之前更多了。<\\/p><h4>步入蓝海，完整的产品体验驶入快车道<\\/h4><p>在多数对手还没拿出纯电专用平台，在售车型多处在“油改电”的今天，大众不仅将第二对ID.系列车型带到了中国市场，还进入了中大型纯电SUV的蓝海。先人一步完成向智能化、电动化转型的同时，基于用户和实际场景的产品思路转变，才是大象转身动作最大的地方。同时有ID.4背书，在造电动车这事上，严谨、务实、靠谱的印象没变，追求科技、敢于尝鲜的步子没停。快速的产品投放，也在逐步提升用户对新产品的接受度。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1484", "\\", "/large", "\\", "/16187559891484.jpeg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><p>当然，从油车变电车，车企有技术门槛，消费者有心理门槛——补能焦虑。在大众看来，充电是电动车生态中的重要一环，更是完整产品体验的一部分，于是充电网络建设成了与产品投放速度“对飙”的事情。按照计划，大众今年将通过开迈斯，率先在北京、上海、广州、深圳、成都、天津、杭州、郑州8地，完成500个充电站、6000个充电枪的密集投放。<\\/p><p>不仅如此，在这8大对电动车需求量大、消费者对电车接受度高的城市里，大众还会通过大数据精确定位到城市新能源车的热点地区，确保充电站能覆盖到、用户充电足够便利。到2025年，大众布局的充电桩将超过17000个，加上手机APP支持预约充电车位等服务。“买电车、享服务”的新势力思路配上大众的体量，不可限量的会是体验升级的速度。<\\/p><p>或许有人会说产品与服务的快速布局依赖于车企自身的体量，可话说回来，决定大众在华体量的是用户，享受完整用车体验的也是用户。说到底，大众的用户思维早就破了单一车型的“圈儿”。而大众也给自己定了个“小目标”——做国人新能源车首选品牌。<\\/p><p style=\"", "text-align: center;", "\"><img src=\"", "http:\\/\\", "/img.cy-cdn.com", "\\", "/w3", "\\", "/1583", "\\", "/large", "\\", "/16187562197583.jpg", "\" title=\"", "\" alt=\"", "\" width=\"", "600", "\" border=\"", "0", "\" vspace=\"", "0", "\" style=\"", "width: 600px;", "\"\\/><\\/p><h4>车云小结<\\/h4><p>大众用ID.6带来了什么，家庭用户的电车新选择、前沿科技+靠谱续航的综合体、服务到位还能打消补能焦虑的中大型SUV，这些都没毛病。而背后是大众基于用户和用车场景的开发逻辑，与用户视角的闭环思考方式。有了这两点，再同时做到阔步转型、加速产品与服务链建设，成为新能源车首选品牌这事，应该叫水到渠成。<\\/p>\"", ",\n        ", "\"keywords\"", ": ", "\"电动车,大众\"", ",\n        ", "\"description\"", ": ", "\"舒适静谧的出行+便利的补能体验，要做新能源车首选品牌的大众。\"", ",\n        ", "\"inputtime\"", ": 1618755165,\n        ", "\"pv\"", ": 4903,\n        ", "\"label\"", ": [\n            {\n                ", "\"name\"", ": ", "\"大众\"", ",\n                ", "\"pinyin\"", ": ", "\"volkswagen\"", "\n            },\n            {\n                ", "\"name\"", ": ", "\"电动车\"", ",\n                ", "\"pinyin\"", ": ", "\"ev\"", "\n            }\n        ],\n        ", "\"site_name\"", ": ", "\"车云网\"", ",\n        ", "\"author_info\"", ": {\n            ", "\"author_id\"", ": 10036,\n            ", "\"author_name\"", ": ", "\"mayifan9306\"", ",\n            ", "\"author_avatar\"", ": ", "\"http:\\/\\/assets.cheyun.com\\/web\\/images\\/common\\/head.jpg\"", ",\n            ", "\"author_summary\"", ": null,\n            ", "\"author_article\"", ": [\n                {\n                    ", "\"id\"", ": 26185,\n                    ", "\"title\"", ": ", "\"科技说丨雷凌与卡罗拉PHEV将上市，中国特供背后的“双赢”逻辑\"", ",\n                    ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1968\\/large\\/15500238961968.jpg\"", ",\n                    ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1916\\/large\\/1550023905916.jpg\"", "\n                },\n                {\n                    ", "\"id\"", ": 26242,\n                    ", "\"title\"", ": ", "\"科技说丨本田Urban EV原型车即将发布，仅仅是中控屏有点怪？\"", ",\n                    ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1752\\/large\\/15501367905752.jpg\"", ",\n                    ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1707\\/large\\/15501368001707.jpg\"", "\n                },\n                {\n                    ", "\"id\"", ": 26268,\n                    ", "\"title\"", ": ", "\"科技说丨从“一枝独秀”到“全副武装”，马自达最新黑科技盘点\"", ",\n                    ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1805\\/large\\/15502272477805.jpg\"", ",\n                    ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/36\\/large\\/15502272554036.jpg\"", "\n                }\n            ],\n            ", "\"author_article_count\"", ": 249\n        },\n        ", "\"recommend\"", ": [\n            {\n                ", "\"id\"", ": 42080,\n                ", "\"title\"", ": ", "\"上半年：大众VS丰田，谁卖的更多，谁更赚钱？\"", ",\n                ", "\"description\"", ": ", "\"大众汽车CEO迪斯：必须改变在中国销售电动汽车(EV)的方法。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/529\\/large\\/16276213058529.png\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1422\\/large\\/16276213093422.png\"", ",\n                ", "\"inputtime\"", ": 1627620545,\n                ", "\"author_id\"", ": 10979,\n                ", "\"author\"", ": ", "\"zhangyuhao\"", ",\n                ", "\"label\"", ": ", "\"大众,丰田\"", "\n            },\n            {\n                ", "\"id\"", ": 41982,\n                ", "\"title\"", ": ", "\"复盘车市上半场：欣欣向荣的表象下潜藏暗涌\"", ",\n                ", "\"description\"", ": ", "\"产品、消费者同步走向成熟，只要产品够好，消费者就愿意用钞票投票。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1989\\/large\\/16273568339989.png\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/431\\/large\\/16273568122431.png\"", ",\n                ", "\"inputtime\"", ": 1627355802,\n                ", "\"author_id\"", ": 10979,\n                ", "\"author\"", ": ", "\"zhangyuhao\"", ",\n                ", "\"label\"", ": ", "\"大众,丰田,吉利,比亚迪\"", "\n            },\n            {\n                ", "\"id\"", ": 41795,\n                ", "\"title\"", ": ", "\"大众将在美国停产停售帕萨特\"", ",\n                ", "\"description\"", ": ", "\"\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/710\\/large\\/16267445512710.jpg\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/312\\/large\\/16267445576312.jpg\"", ",\n                ", "\"inputtime\"", ": 1626744452,\n                ", "\"author_id\"", ": 11032,\n                ", "\"author\"", ": ", "\"chenxiaotong\"", ",\n                ", "\"label\"", ": ", "\"大众\"", "\n            },\n            {\n                ", "\"id\"", ": 41774,\n                ", "\"title\"", ": ", "\"创见 | 大众中国冯思翰：中国新能源车市场正进入新常态\"", ",\n                ", "\"description\"", ": ", "\"冯思翰：现在我们必须消化库存的订单，让客户在这个过渡期当中获得一些非常好的解决方案。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/722\\/large\\/16266725458722.png\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1393\\/large\\/16266725485393.png\"", ",\n                ", "\"inputtime\"", ": 1626671649,\n                ", "\"author_id\"", ": 10979,\n                ", "\"author\"", ": ", "\"zhangyuhao\"", ",\n                ", "\"label\"", ": ", "\"创见,大众\"", "\n            },\n            {\n                ", "\"id\"", ": 41463,\n                ", "\"title\"", ": ", "\"传大众汽车计划出售旗下充电公司部分股权\"", ",\n                ", "\"description\"", ": ", "\"\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1755\\/large\\/16256229691755.jpg\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1782\\/large\\/16256229789782.jpg\"", ",\n                ", "\"inputtime\"", ": 1625622809,\n                ", "\"author_id\"", ": 11032,\n                ", "\"author\"", ": ", "\"chenxiaotong\"", ",\n                ", "\"label\"", ": ", "\"大众\"", "\n            },\n            {\n                ", "\"id\"", ": 41159,\n                ", "\"title\"", ": ", "\"大众高价收购法国租车公司Europcar遭拒绝\"", ",\n                ", "\"description\"", ": ", "\"知情人士透露，主要原因是Europcar认为大众集团的报价过低。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1947\\/large\\/16245233493947.png\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1207\\/large\\/1624523353207.png\"", ",\n                ", "\"inputtime\"", ": 1624523328,\n                ", "\"author_id\"", ": 10979,\n                ", "\"author\"", ": ", "\"zhangyuhao\"", ",\n                ", "\"label\"", ": ", "\"大众\"", "\n            },\n            {\n                ", "\"id\"", ": 41110,\n                ", "\"title\"", ": ", "\"知名机构预测2033年全球电动汽车销量将超燃油车\"", ",\n                ", "\"description\"", ": ", "\"到2045年，非电动汽车销量将降至仅占全球汽车总销量的不到1%。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1137\\/large\\/16244125165137.jpg\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1857\\/large\\/16244125241857.jpg\"", ",\n                ", "\"inputtime\"", ": 1624412369,\n                ", "\"author_id\"", ": 11032,\n                ", "\"author\"", ": ", "\"chenxiaotong\"", ",\n                ", "\"label\"", ": ", "\"电动车\"", "\n            },\n            {\n                ", "\"id\"", ": 41040,\n                ", "\"title\"", ": ", "\"XXXL的大众揽境，除了大还有什么？\"", ",\n                ", "\"description\"", ": ", "\"大众，SUV，大。三者取其一都能成功，如果将这三者组合在一起呢。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/601\\/large\\/16241644994601.jpg\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1228\\/large\\/1624164497228.jpg\"", ",\n                ", "\"inputtime\"", ": 1624337280,\n                ", "\"author_id\"", ": 10902,\n                ", "\"author\"", ": ", "\"nic666\"", ",\n                ", "\"label\"", ": ", "\"大众\"", "\n            },\n            {\n                ", "\"id\"", ": 40897,\n                ", "\"title\"", ": ", "\"大众召回部分进口、国产车型\"", ",\n                ", "\"description\"", ": ", "\"本次召回范围内的车辆使用了供应商在特定时间段内生产的V8发动机。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1232\\/large\\/16234079165232.png\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/253\\/large\\/16234079218253.png\"", ",\n                ", "\"inputtime\"", ": 1623407836,\n                ", "\"author_id\"", ": 10979,\n                ", "\"author\"", ": ", "\"zhangyuhao\"", ",\n                ", "\"label\"", ": ", "\"大众\"", "\n            },\n            {\n                ", "\"id\"", ": 40835,\n                ", "\"title\"", ": ", "\"特斯拉前高管创立的电池公司获得了27.5亿美元融资，大众也参与其中\"", ",\n                ", "\"description\"", ": ", "\"在可预见的未来，电池制造商将会取代现有Tier 1，成为汽车新供应链关系中的核心。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/608\\/large\\/16232972094608.jpeg\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1732\\/large\\/16232972111732.jpeg\"", ",\n                ", "\"inputtime\"", ": 1623297126,\n                ", "\"author_id\"", ": 9763,\n                ", "\"author\"", ": ", "\"wangrh\"", ",\n                ", "\"label\"", ": ", "\"大众,电动汽车,电池\"", "\n            },\n            {\n                ", "\"id\"", ": 40663,\n                ", "\"title\"", ": ", "\"减少集团品牌间重叠 大众将新增两个首席运营官职位\"", ",\n                ", "\"description\"", ": ", "\"迪斯认为，大众汽车集团内部仍存在过多的重复开发项目。\"", ",\n                ", "\"home_pic\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/1843\\/large\\/16227833639843.png\"", ",\n                ", "\"thumb\"", ": ", "\"http:\\/\\/img.cy-cdn.com\\/w3\\/403\\/large\\/16227833664403.png\"", ",\n                ", "\"inputtime\"", ": 1622783278,\n                ", "\"author_id\"", ": 10979,\n                ", "\"author\"", ": ", "\"zhangyuhao\"", ",\n                ", "\"label\"", ": ", "\"大众\"", "\n            }\n        ]\n    }\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这一般人帮不上你&amp;#xff0c;厂家才知道你的invite那里不合适&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["向海康NVR发送回放请求带SDP的INVITE消息后，总是收到400 Bad Request错误提示", ["问题遇到的现象和发生背景", "\n", "但是Play的实时播放已经走通(我对协议参数不太了解；也找不到文档具体该填写什么)；", "\n", "问题相关代码，请勿粘贴截图", "\n", "INVITE", " sip:", "34020000001320000001", "@", "192.168.1.63:5060", " SIP/", "2", ".", "0", "\n", "Call", "-ID: ", "8189", "D8660D8044D5A903C84408221075\n", "CSeq", ": ", "20", " INVITE\n", "From", ": <sip:", "34020000002000000001", "@", "3402000000", ">;tag=FB5DD54E2A6043F4B594715B557ADB7B\n", "To", ": <sip:", "34020000001320000001", "@", "34020000001320000001", ">\n", "Via", ": SIP/", "2", ".", "0", "/UDP ", "192.168.1.63:5060", ";rport\n", "Max", "-Forwards: ", "70", "\n", "Contact", ": <sip:", "34020000002000000001", "@", "192.168.1.34:5060", ">\n", "Content", "-Type: Application/SDP\n", "Content", "-Length: ", "192", "\n", "v", "=", "0", "\n", "o", "=", "34020000002000000001", " ", "0", " ", "0", " IN IP4 ", "192.168.1.34", "\n", "s", "=Playback\n", "c", "=IN IP4 ", "192.168.1.34", "\n", "t", "=", "1655775000000", " ", "1655780400000", "\n", "m", "=video ", "5061", " RTP/AVP ", "96", "\n", "a", "=recvonly\n", "a", "=rtpmap:", "96", " PS/", "90000", "\n", "y", "=", "1200000013", "\n", "\n", "运行结果及报错内容", "\n", "SIP", "/", "2", ".", "0", " ", "400", " Bad Request\n", "Via", ": SIP/", "2", ".", "0", "/UDP ", "192.168.1.63:5060", ";rport=", "5060", ";branch=z9hG4bK-", "323438", "-", "0", "cd759f9a9c9825b5d65bfd714d922d6;received=", "192.168.1.34", "\n", "From", ": <sip:", "34020000002000000001", "@", "3402000000", ">;tag=FB5DD54E2A6043F4B594715B557ADB7B\n", "To", ": <sip:", "34020000001320000001", "@", "34020000001320000001", ">;tag=", "511471901", "\n", "Call", "-ID: ", "8189", "D8660D8044D5A903C84408221075\n", "CSeq", ": ", "20", " INVITE\n", "User", "-Agent: Embedded Net DVR/NVR/DVS\n", "Content", "-Length: ", "0", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我查找过各种方法  sdp应该还需要携带个u字段 但是我已添加上u=34020000001320000001:0 就直接返回404了,现在对 t,y,u这3个字段不知道该如何填写感到疑惑；t 这字段我是将nvr里能看到的回放视频里随便拿了一段时间 y现在是乱写的", "\n", "我想要达到的结果", "\n", "将这信息请求发出 返回回放的视频流；可悬赏"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/jackrex/article/details/8640226", "Konwledge_Point": "网络中的流", "Question": ["java写了一个聊天室的程序  但是私聊第二个人就报空指针异常  不知道为什么 求解", ["下面是全部的代码 ", "\n\n", " package com.sram.chat;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CrazyitMap<K,V> {\n    Map<K,V> maps = Collections.synchronizedMap(new HashMap<K,V>());\n\n    //创建一个删除指定项 如果value值相同就删除\n    public synchronized void removeByValue(V value){\n        for(K key:maps.keySet()){\n            if(maps.get(key)==value){\n                maps.remove(key);\n                break;\n            }\n        }\n    }\n    public synchronized Set<V> valueSet(){\n        Set<V> result = new HashSet<V>();\n        for(K key:maps.keySet()){\n            result.add(maps.get(key));\n        }\n        return result;\n    }\n    //根据value查找key\n    public synchronized K getKeyByValue(V value){\n        for(K key:maps.keySet()){\n            if(maps.get(key)==value||maps.get(key).equals(value)){\n                return key;\n            }\n        }\n        return null;\n    }\n    //添加vlaue 但是不能重复\n    public synchronized V put(K key,V value){\n        for(V val:valueSet()){\n            if(val.equals(value)&&val.hashCode()==value.hashCode()){\n                throw new RuntimeException(\"Map集合中不能重复存储value\");\n            }\n        }\n        return maps.put(key, value);\n    }\n}\n\n", "\n\n", " package com.sram.chat;\n\npublic interface Protocol {\n    //定义协议字符长度\n        int PROTOCOL_LEN = 2;\n        //下面是协议字符不同表示\n        String MEG_ROUND =\"∞∞\";   //发送群聊聊天信息\n        String USER_ROUND=\"ぁぁ\"; //用户名\n        String LOGIN_SUCCESS=\"1\";   //登录成功\n        String NAME_REP =\"-1\";          //重复用户名，登录失败\n        String PRIVATE_ROUND =\"◎◎\"; //私聊\n        String SPLIT_SIGN=\"π\";\n}\n\n", "\n\n", " package com.sram.chat;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\nimport javax.swing.JOptionPane;\n\npublic class Client {\n    private static final int SERVER_PORT = 6868;\n    private Socket socket;\n    private PrintStream ps;\n    private BufferedReader brServer;//\n    private BufferedReader keyIn;//\n    public void init(){\n        try{\n            socket  = new Socket(\"127.0.0.1\",SERVER_PORT);\n            keyIn = new BufferedReader(new InputStreamReader(System.in));\n            ps = new PrintStream(socket.getOutputStream());\n\n            brServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String tip = \"\";\n            while(true){\n                String userName = JOptionPane.showInputDialog(tip+\"输入用户名\");\n                ps.println(Protocol.USER_ROUND+userName+Protocol.USER_ROUND);\n                String result = brServer.readLine();\n                if(result.equals(Protocol.NAME_REP)){\n                    tip = \"用户名重复，请重新\";\n                    continue;\n                }else if(result.equals(Protocol.LOGIN_SUCCESS)){\n\n                    break;\n                }\n\n            }\n        }catch(UnknownHostException e){\n            System.out.println(\"链接不到远程服务器，请确定服务器已经启动\");\n            closeAll();\n            System.exit(1);\n        }catch(IOException e1){\n            System.out.println(\"网络异常！请重新登录\");\n            closeAll();\n            System.exit(1);\n        }\n        new ClientThread(brServer).start();\n    }\n    public void readAndSend(){\n        try {\n            String line = null;\n            while((line = keyIn.readLine())!=null){\n                if(line.indexOf(\"：\")>0&&line.startsWith(\"@@\")){\n                    line = line.substring(2);//\n                    ps.println(Protocol.PRIVATE_ROUND\n                            +line.split(\"：\")[0]\n                            +Protocol.SPLIT_SIGN\n                            +line.split(\"：\")[1]\n                            +Protocol.PRIVATE_ROUND);\n                }else{\n                    ps.println(Protocol.MEG_ROUND+line+Protocol.MEG_ROUND);\n                }\n            }\n        } catch (IOException e) {e.printStackTrace();}\n    }\n    public static void main(String[] args) {\n        Client client = new Client();\n        client.init();\n        client.readAndSend();\n    }\n    public void closeAll(){\n        try{\n                if(keyIn!=null){ //判断流是否创建\n                    keyIn.close();\n                }\n                if(brServer!=null){\n                    brServer.close();\n                }\n                if(ps!=null){\n                    ps.close();\n                }\n                if(socket!=null){\n                    socket.close();\n                }\n                } catch (IOException e){\n                    e.printStackTrace();\n                }\n\n\n    }\n}\n\n", "\n\n", " package com.sram.chat;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\n\npublic class ClientThread extends Thread{\n    BufferedReader br = null;//处理\n    public ClientThread(BufferedReader br){\n        this.br= br;\n    }\n    @Override\n    public void run() {\n        String line = null;\n        try {\n            while((line = br.readLine())!=null){\n                System.out.println(line);   \n            }\n        } catch (IOException e) {e.printStackTrace();}\n        finally{\n            try{\n            if(br!=null){\n                br.close();\n            }\n            }catch(IOException e){e.printStackTrace();}\n        }\n    }\n\n}\n\n", "\n\n", " package com.sram.chat;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server {\n    private static final int SERVER_PORT = 6868;\n    public static CrazyitMap<String,PrintStream> clients = new CrazyitMap<>();\n    public void init(){\n        try{\n            ServerSocket ss = new  ServerSocket(SERVER_PORT);\n            while(true){\n                Socket s = ss.accept();\n                //启动子线程，读取\n                new ServerThread(s).start();;\n            }\n        }catch(IOException ex){\n            System.out.println(\"服务器启动失败，是否\"+SERVER_PORT+\"已被占用？\");\n        }\n    }\n    public static void main(String args[]){\n        Server server = new Server();\n        server.init();\n    }\n}\n\n\n\n\n", "\n\n", " package com.sram.chat;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.net.Socket;\n\npublic class ServerThread extends Thread{\n    private Socket socket;\n    BufferedReader br = null;\n    PrintStream ps = null;\n    ServerThread(Socket socket){\n        this.socket = socket;\n    }\n    @Override\n    public void run() {\n        try{\n            br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            ps = new PrintStream(socket.getOutputStream());\n            String line = null;\n            while((line = br.readLine())!=null){\n                //ぁぁstevejobsぁぁ\n                //如果读到的line字符是以 Protocol.USER_ROUND开始，并且以Protocol.USER_ROUND结束，则可以确定\n                //读到的是用户登录的用户名\n                //System.out.println(line);\n                //System.out.println(getRealMsg(line));\n                if(line.startsWith(Protocol.USER_ROUND)&&line.endsWith(Protocol.USER_ROUND)){\n                    String userName = getRealMsg(line);\n                    if(Server.clients.maps.containsKey(userName)){\n                        System.out.println(\"服务器提示：用户名重复\");//服务器端到客户端\n                        ps.println(Protocol.NAME_REP);\n                    }else{\n                        System.out.println(\"服务器提示：成功\");\n                        ps.println(Protocol.LOGIN_SUCCESS);\n                        Server.clients.put(userName,ps);\n                    }\n                }else if(line.startsWith(Protocol.PRIVATE_ROUND)&&line.endsWith(Protocol.PRIVATE_ROUND)){\n                    String message = getRealMsg(line);\n                    String toUser = message.split(Protocol.SPLIT_SIGN)[0];\n                    String msg = message.split(Protocol.SPLIT_SIGN)[1];\n                    Server.clients.maps.get(toUser).println(Server.clients.getKeyByValue(ps)+\"悄悄对你说：\"+msg);\n                }else if(line.startsWith(Protocol.MEG_ROUND)&&line.startsWith(Protocol.MEG_ROUND)){\n                    String message = getRealMsg(line);\n                    for(PrintStream out:Server.clients.valueSet()){\n                        out.println(Server.clients.getKeyByValue(ps)+\"说：\"+message);\n                    }\n                }\n            }\n        }catch(IOException e){\n            Server.clients.removeByValue(ps);\n            System.out.println(\"集合Map\"+Server.clients.maps.size());\n                try {\n                    if(br!=null){\n                    br.close();\n                    }\n                    if(ps!=null){\n                        ps.close();\n                    }\n                    if(socket!=null){\n                        socket.close();\n                    }\n                } catch (IOException e1) {\n                    e1.printStackTrace();\n                }\n                e.printStackTrace();\n        }\n    }\n    private String getRealMsg(String line){\n        return line.substring(Protocol.PROTOCOL_LEN,line.length()-Protocol.PROTOCOL_LEN);\n\n    }\n\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/mgoann/article/details/4058756'&gt;HttpClient重定向&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/u011585735/article/details/32702785'&gt;httpclient重定向&lt;/a&gt;&lt;br/&gt;----------------------同志你好，我是CSDN问答机器人小N，奉组织之命为你提供参考答案，编程尚未成功，同志仍需努力！", "Konwledge_Point": "网络中的流", "Question": ["关于HttpClient的问题,如何使用HttpClient重定向?", [" /*\n * HttpRequestProxy.java\n *\n * Created on November 3, 2008, 9:53 AM\n */\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.httpclient.Header;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.NameValuePair;\nimport org.apache.commons.httpclient.SimpleHttpConnectionManager;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\n\n\npublic class HttpRequestProxy {\n    // 超时间隔\n    private static int connectTimeOut = 60000;\n    // 让connectionmanager管理httpclientconnection时是否关闭连接\n    private static boolean alwaysClose = false;\n    // 返回数据编码格式\n    private String encoding = \"UTF-8\";\n\n    private final HttpClient client = new HttpClient();\n\n    public HttpClient getHttpClient() {\n        return client;\n    }\n    /**\n     * 用法： HttpRequestProxy hrp = new HttpRequestProxy();\n     * hrp.doRequest(\"http://www.163.com\",null,null,\"gbk\");\n     * \n     * @param url\n     *            请求的资源ＵＲＬ\n     * @param postData\n     *            POST请求时form表单封装的数据 没有时传null\n     * @param header\n     *            request请求时附带的头信息(header) 没有时传null\n     * @param encoding\n     *            response返回的信息编码格式 没有时传null\n     * @return response返回的文本数据\n     * @throws CustomException\n     */\n    public String doRequest(String url, Map postData, Map header, String encoding) throws Exception {\n        String responseString = null;\n        // 头部请求信息\n        Header[] headers = null;\n        if (header != null) {\n            Set entrySet = header.entrySet();\n            int dataLength = entrySet.size();\n            headers = new Header[dataLength];\n            int i = 0;\n            for (Iterator itor = entrySet.iterator(); itor.hasNext();) {\n                Map.Entry entry = (Map.Entry) itor.next();\n                headers[i++] = new Header(entry.getKey().toString(), entry.getValue().toString());\n            }\n        }\n\n        // post方式\n        if (postData != null) {\n            PostMethod postRequest = new PostMethod(url.trim());\n            if (headers != null) {\n                for (int i = 0; i < headers.length; i++) {\n                    postRequest.setRequestHeader(headers[i]);\n                }\n            }\n            Set entrySet = postData.entrySet();\n            int dataLength = entrySet.size();\n            NameValuePair[] params = new NameValuePair[dataLength];\n            int i = 0;\n            for (Iterator itor = entrySet.iterator(); itor.hasNext();) {\n                Map.Entry entry = (Map.Entry) itor.next();\n                params[i++] = new NameValuePair(entry.getKey().toString(), entry.getValue().toString());\n            }\n            postRequest.setRequestBody(params);\n            try {\n                responseString = this.executeMethod(postRequest, encoding);\n            } catch (Exception e) {\n                throw e;\n            } finally {\n                postRequest.releaseConnection();\n            }\n        }\n        return responseString;\n    }\n\n    private String executeMethod(HttpMethod request, String encoding) throws Exception {\n        String responseContent = null;\n        InputStream responseStream = null;\n        BufferedReader rd = null;\n        try {\n            this.getHttpClient().executeMethod(request);\n            if (encoding != null) {\n                responseStream = request.getResponseBodyAsStream();\n                rd = new BufferedReader(new InputStreamReader(responseStream, encoding));\n                String tempLine = rd.readLine();\n                StringBuffer tempStr = new StringBuffer();\n                String crlf = System.getProperty(\"line.separator\");\n                while (tempLine != null) {\n                    tempStr.append(tempLine);\n                    tempStr.append(crlf);\n                    tempLine = rd.readLine();\n                }\n                responseContent = tempStr.toString();\n            } else\n                responseContent = request.getResponseBodyAsString();\n\n            Header locationHeader = request.getResponseHeader(\"location\");\n            // 返回代码为302,301时，表示页面己经重定向，则重新请求location的url，这在\n            // 一些登录授权取cookie时很重要\n            if (locationHeader != null) {\n                String redirectUrl = locationHeader.getValue();\n                this.doRequest(redirectUrl, null, null, null);\n            }\n        } catch (HttpException e) {\n            throw new Exception(e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(e.getMessage());\n\n        } finally {\n            if (rd != null)\n                try {\n                    rd.close();\n                } catch (IOException e) {\n                    throw new Exception(e.getMessage());\n                }\n            if (responseStream != null)\n                try {\n                    responseStream.close();\n                } catch (IOException e) {\n                    throw new Exception(e.getMessage());\n\n                }\n        }\n        return responseContent;\n    }\n\n    /**\n     * 特殊请求数据,这样的请求往往会出现redirect本身而出现递归死循环重定向 所以单独写成一个请求方法\n     * 比如现在请求的url为：http://localhost:8080/demo/index.jsp 返回代码为302\n     * 头部信息中location值为:http://localhost:8083/demo/index.jsp\n     * 这时httpclient认为进入递归死循环重定向，抛出CircularRedirectException异常\n     * \n     * @param url\n     * @return\n     * @throws CustomException\n     */\n    public String doSpecialRequest(String url, int count, String encoding) throws Exception {\n        String str = null;\n        InputStream responseStream = null;\n        BufferedReader rd = null;\n        GetMethod getRequest = new GetMethod(url);\n        // 关闭httpclient自动重定向动能\n        getRequest.setFollowRedirects(false);\n        try {\n\n            this.client.executeMethod(getRequest);\n            Header header = getRequest.getResponseHeader(\"location\");\n            if (header != null) {\n                // 请求重定向后的ＵＲＬ，count同时加1\n                this.doSpecialRequest(header.getValue(), count + 1, encoding);\n            }\n            // 这里用count作为标志位，当count为0时才返回请求的ＵＲＬ文本,\n            // 这样就可以忽略所有的递归重定向时返回文本流操作，提高性能\n            if (count == 0) {\n                getRequest = new GetMethod(url);\n                getRequest.setFollowRedirects(false);\n                this.client.executeMethod(getRequest);\n                responseStream = getRequest.getResponseBodyAsStream();\n                rd = new BufferedReader(new InputStreamReader(responseStream, encoding));\n                String tempLine = rd.readLine();\n                StringBuffer tempStr = new StringBuffer();\n                String crlf = System.getProperty(\"line.separator\");\n                while (tempLine != null) {\n                    tempStr.append(tempLine);\n                    tempStr.append(crlf);\n                    tempLine = rd.readLine();\n                }\n                str = tempStr.toString();\n            }\n\n        } catch (HttpException e) {\n            throw new Exception(e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(e.getMessage());\n        } finally {\n            getRequest.releaseConnection();\n            if (rd != null)\n                try {\n                    rd.close();\n                } catch (IOException e) {\n                    throw new Exception(e.getMessage());\n                }\n            if (responseStream != null)\n                try {\n                    responseStream.close();\n                } catch (IOException e) {\n                    throw new Exception(e.getMessage());\n                }\n        }\n        return str;\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        HttpRequestProxy hrp = new HttpRequestProxy();\n        Map date = new HashMap();\n        date.put(\"jyidApplet\", \"1\");\n        date.put(\"codeNumApplet\", \"1\");\n        date.put(\"jymxIdApplet\", \"447\");\n        date.put(\"patientIdApplet\", \"1118\");\n        String str = hrp.doRequest(\"http://127.0.0.1:8080/lis/mz/addTM\",date, null, null);\n        System.out.println(str);\n\n    }\n\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;从您提供的代码中可以看出&amp;#xff0c;您在将预测结果打印在控制台中时使用了以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; k, v &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; name_dict.&lt;span class=\"hljs-keyword\"&gt;items&lt;/span&gt;():\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;result&lt;/span&gt; &amp;#61;&amp;#61; v:\n        print(&lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果:&amp;#34;&lt;/span&gt;, k)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是&amp;#xff0c;当您在将预测结果显示在 tkinter 窗口中时&amp;#xff0c;使用了以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;result &amp;#61; np.argmax(result[0])\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; k, v &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; name_dict.items():\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; result &amp;#61;&amp;#61; v:\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果:&amp;#34;&lt;/span&gt;, k)\npred &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; k\ne1 &amp;#61; tk.Label(root, &lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;pred, font&amp;#61;(&lt;span class=\"hljs-string\"&gt;&amp;#39;Arial&amp;#39;&lt;/span&gt;, 16))\ne1.place(&lt;span class=\"hljs-attribute\"&gt;x&lt;/span&gt;&amp;#61;600, &lt;span class=\"hljs-attribute\"&gt;y&lt;/span&gt;&amp;#61;370)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这两段代码中的变量 &lt;code class=\"language-javascript\"&gt;k&lt;/code&gt; 的值是不同的。在第一段代码中&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;k&lt;/code&gt; 的值是在循环中最后一次赋值的名称&amp;#xff0c;而在第二段代码中&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;k&lt;/code&gt; 的值是在循环结束后最后一次赋值的名称。因此&amp;#xff0c;这两个变量的值不同&amp;#xff0c;导致在控制台中打印的结果和 tkinter 窗口中显示的结果不一致。&lt;/p&gt;\n&lt;p&gt;要解决这个问题&amp;#xff0c;您可以将第二段代码中的 &lt;code class=\"language-javascript\"&gt;k&lt;/code&gt; 的赋值移到循环内部&amp;#xff0c;以确保每次循环结束时 &lt;code class=\"language-javascript\"&gt;k&lt;/code&gt; 的值都是正确的名称。以下是修改后的代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;result &amp;#61; np.argmax(result[0])\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; k, v &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; name_dict.items():\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; result &amp;#61;&amp;#61; v:\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果:&amp;#34;&lt;/span&gt;, k)\n        pred &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;预测结果&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; k\n        e1 &amp;#61; tk.Label(root, &lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;pred, font&amp;#61;(&lt;span class=\"hljs-string\"&gt;&amp;#39;Arial&amp;#39;&lt;/span&gt;, 16))\n        e1.place(&lt;span class=\"hljs-attribute\"&gt;x&lt;/span&gt;&amp;#61;600, &lt;span class=\"hljs-attribute\"&gt;y&lt;/span&gt;&amp;#61;370)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样修改后&amp;#xff0c;您的预测结果应该在控制台和 tkinter 窗口中都能正确地显示。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;如果以上回答对您有所帮助&amp;#xff0c;点击一下采纳该答案&amp;#xff5e;谢谢&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["我的print出的结果和tkinter上显示的结果不一致，怎么改啊？", ["我的print出的结果，和tkinter上显示的结果不一样，怎么改啊？", "这是我tkinter上的显示：", "\n", "这是print出的结果：", "\n", "这是我将结果显示在tkinter上的代码：", "\n", "    for k, v ", "in", " name_dict.items():  ", "# 将类别由数字转换为名称", "\n        ", "if", " ", "result", " == v:  ", "# 如果预测结果等于v, 打印出名称", "\n            print(", "\"预测结果:\"", ", k)  ", "# 打印出名称", "\n\n    ", "pred", " = ", "\"预测结果：\"", " + k\n    ", "e1", " = tk.Label(root, ", "text=pred,", " ", "font=('Arial',", " ", "16", "))", "#显示预测结果", "\n    e1.place(", "x=600,", " ", "y=370)", "\n\n", "\n", "下面是我的整体代码：", "\n", "import", " tkinter ", "as", " tk\n", "import", " tensorflow ", "as", " tf\n", "import", " matplotlib.pyplot ", "as", " plt\n", "from", " matplotlib.backends.backend_tkagg ", "import", " FigureCanvasTkAgg\n", "import", " numpy ", "as", " np\n", "from", " tkinter ", "import", " *\n", "import", " tkinter.filedialog  ", "# 注意次数要将文件对话框导入", "\n", "from", " PIL ", "import", " Image\n", "from", " tensorflow.python.keras ", "import", " models, layers\n\n", "def", " ", "CNN_yuce", "():\n    ", "global", " e1, pred, root,predict_class, k\n    name_dict = {", "\"Uninfected\"", ":", "0", ", ", "\"Parasitized\"", ":", "1", "}\n\n    fig = plt.figure(figsize=(", "2", ",", "2", "),dpi=", "100", ")\n    ", "# 从本地选择一个文件，并返回文件的目录", "\n    ", "# filenames = tkinter.filedialog.askopenfile()#形成一共io流 的文件名称", "\n    filename = tk.filedialog.askopenfilename(title=", "u'加载图片'", ",initialdir=(()))", "#只保留文件名和后缀", "\n    ", "print", "(filename)\n\n    ", "# model_save_path = 'D:/ningyupeng/pythonProject/Graduation Project V1.0/my_model/variables/variables.ckpt'", "\n\n    model = tf.keras.models.Sequential([\n        tf.keras.layers.Flatten(),", "#Flatten-变成一维数组", "\n        tf.keras.layers.Dense(", "128", ", activation=", "'relu'", "),", "#relu函数可以解决 梯度消失问题 是线性的", "\n        tf.keras.layers.Dense(", "2", ", activation=", "'softmax'", ")])", "# 2个类所以2个神经元 softmax只用在最后一层 可以让最后输出的概率在0-1之间", "\n\n    ", "# model.load_weights('checkpoint-05e-val_acc_0.58.hdf5')#读取文件", "\n    models.load_model(", "\"my_model\"", ")\n\n    ", "# 加载测试图片", "\n    img = Image.", "open", "(filename)\n    ", "# 将图片resize到224x224大小", "\n    img = img.resize((", "128", ", ", "128", "), Image.ANTIALIAS)\n    ", "# 将灰度图转化为RGB模式", "\n    img = img.convert(", "\"RGB\"", ")\n\n    plt.axis(", "'off'", ")  ", "# 去掉坐标轴", "\n    plt.imshow(img)\n    ", "# 归一化", "\n    img1 = np.array(img) / ", "255.", "\n    ", "# 将图片增加一个维度，目的是匹配网络模型", "\n    img1 = (np.expand_dims(img1, ", "0", "))\n    ", "# 将预测结果转化为概率值", "\n    result = np.squeeze(model.predict(img1))\n    predict_class = np.argmax(result)\n    ", "# pred = tf.argmax(result, axis=1)#求最大值得出最后识别出来的数", "\n    ", "# print(inverse_dict[int(predict_class)],result[predict_class])", "\n    ", "# 将预测的结果打印在图片上面", "\n    ", "# plt.title([inverse_dict[int(predict_class)],result[predict_class]])", "\n    ", "print", "(result)\n\n    result = np.argmax(result[", "0", "])  ", "# 取出预测结果中概率最大的元素索引值", "\n    ", "for", " k, v ", "in", " name_dict.items():  ", "# 将类别由数字转换为名称", "\n        ", "if", " result == v:  ", "# 如果预测结果等于v, 打印出名称", "\n            ", "print", "(", "\"预测结果:\"", ", k)  ", "# 打印出名称", "\n\n    pred = ", "\"预测结果：\"", " + k\n    e1 = tk.Label(root, text=pred, font=(", "'Arial'", ", ", "16", "))", "#显示预测结果", "\n    e1.place(x=", "600", ", y=", "370", ")\n\n    canvas = FigureCanvasTkAgg(fig, master=root)", "#渲染器 在画布上放置图片", "\n    canvas.draw()\n    canvas.get_tk_widget().place(x=", "600", ",y=", "150", ")\n", "def", " ", "picture", "():\n    ", "global", " root\n    root = Tk()\n    root.wm_title(", "\"细胞图像疟疾检测\"", ")\n    root.geometry(", "'1000x650'", ")\n\n    ask = tk.Button(root, text=", "\"CNN\"", ", width=", "10", ", command=CNN_yuce)\n    ask.place(x=", "600", ", y=", "90", ")\n\n    root.mainloop()\n\n", "if", " __name__ == ", "'__main__'", ":\n    picture()\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;楼主说的没问题&amp;#xff0c;IPS和杀毒软件的确都是通过识别数据流来进行安全防护的&amp;#xff0c;但是它们的原理和应用场景有一些不同。&lt;/p&gt;\n&lt;p&gt;IPS主要是用在网络安全防护&amp;#xff0c;它是一种基于三层网络层的安全设备&amp;#xff0c;通常部署在网络的边缘或者核心位置&amp;#xff0c;用于监控网络流量&amp;#xff0c;检测和阻止来自外部网络的攻击。IPS可以对网络流量进行实时分析和处理&amp;#xff0c;通过识别和过滤恶意流量&amp;#xff0c;保护网络免受攻击。&lt;br /&gt;杀毒软件主要是用于终端安全防护&amp;#xff0c;它是一种基于主机层的安全软件&amp;#xff0c;通常部署在个人电脑、服务器等终端设备上&amp;#xff0c;用于监控终端设备上的文件、进程等活动&amp;#xff0c;检测和清除恶意软件。杀毒软件可以对终端设备上的文件、邮件、浏览器等进行实时检测和处理&amp;#xff0c;通过识别和清除恶意软件&amp;#xff0c;保护终端设备免受攻击。&lt;br /&gt;因此&amp;#xff0c;尽管IPS和杀毒软件都是通过识别数据流来进行安全防护&amp;#xff0c;但是它们的应用场景和工作原理是有所不同的。&lt;br /&gt;IPS主要用于网络层的安全防护&amp;#xff1b;&lt;br /&gt;杀毒软件主要用于主机层的安全防护。&lt;br /&gt;希望能帮到你&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["ips和杀毒软件本质区别是什么", ["ips和杀毒软件，感觉原理差不多啊，都是识别数据流，ips放在网络位置，杀毒软件放在终端，如果把ips理解成硬件版的杀毒软件好像不怎么正确，应该怎么理解二者区别呢？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;去掉文件名中的汉字&lt;br /&gt;确保安装了cv2对应的dll比如&amp;#xff1a;&lt;br /&gt;Python36\\Lib\\site-packages\\cv2\\opencv_ffmpeg340_64.dll&lt;br /&gt;Python36\\Lib\\site-packages\\cv2\\opencv_videoio_ffmpeg454_64.dll&lt;/p&gt;", "Konwledge_Point": "网络中的流", "Question": ["openpose视频无法导出", ["非常奇怪，不知道为什么导出来电脑上打不开out", "\n", "# main processing function to run pose estimation", "\ndef run_pose_estimation(", "source=0,", " ", "flip=False,", " ", "use_popup=True,", " ", "skip_first_frames=0):", "\n    ", "pafs_output_key", " = compiled_model.output(", "\"Mconv7_stage2_L1\"", ")\n    ", "heatmaps_output_key", " = compiled_model.output(", "\"Mconv7_stage2_L2\"", ")", "#输出层的两个key", "\n    ", "player", " = None\n    ", "#输入源，可以是摄像头设备的编号（默认为0，即默认使用第一个摄像头），也可以是视频文件的路径或者图像文件的路径", "\n    ", "#flip：指定是否翻转输入图像，如果为True，则在估计姿势时会同时对输入图像进行水平翻转，然后将两次估计的结果合并，以提高估计准确度（默认为False）", "\n    ", "#use_popup 显示新窗口", "\n    ", "#skip_first_frames：指定在开始进行姿势估计前需要跳过的帧数，默认为0（即从第一帧开始进行姿势估计）", "\n\n    try:\n        ", "# create video player to play with target fps", "\n        ", "player", " = utils.VideoPlayer(source, ", "flip=flip,", " ", "fps=30,", " ", "skip_first_frames=skip_first_frames)", "\n        ", "# start capturing", "\n        player.start()\n        ", "if", " use_popup:\n            ", "title", " = ", "\"Press ESC to Exit\"", "\n            cv2.namedWindow(title, cv2.WINDOW_GUI_NORMAL | cv2.WINDOW_AUTOSIZE)\n\n        ", "processing_times", " = collections.deque()", "#双端队列processing_times用于存储每帧处理的时间", "\n        ", "fourcc", " = cv2.VideoWriter_fourcc(*", "\"H264\"", ")  ", "# 设置编码器", "\n        ", "output_video", " = cv2.VideoWriter(", "\"D:/桌面/output.mp4\"", ", fourcc, ", "30", ", (width,height))\n        while True:\n            ", "# grab the frame", "\n            ", "frame", " = player.next()\n            ", "if", " frame is None:\n                print(", "\"Source ended\"", ")\n                break", "#不断读取视频帧并进行处理 如果视频已经结束 则退出循环。", "\n            ", "# if frame larger than full HD, reduce size to improve the performance ", "\n            ", "#检查视频的大小是否超过全高清分辨率（1920 x 1080），如果是，则将视频帧大小缩小，以提高性能", "\n            ", "scale", " = ", "1280", " / max(frame.shape)\n            ", "if", " scale < ", "1", ":\n                ", "frame", " = cv2.resize(frame, None, ", "fx=scale,", " ", "fy=scale,", " ", "interpolation=cv2.INTER_AREA)", "\n\n            ", "# resize image and change dims to fit neural network input ", "\n            ", "# (see https://github.com/openvinotoolkit/open_model_zoo/tree/master/models/intel/human-pose-estimation-0001)", "\n            ", "input_img", " = cv2.resize(frame, (width, height), ", "interpolation=cv2.INTER_AREA)", "\n            ", "# create batch of images (size = 1)", "\n            ", "input_img", " = input_img.transpose((", "2", ",", "0", ",", "1", "))[np.newaxis, ...]\n            ", "#将调整图像大小和格式以适应神经网络输入", "\n\n            ", "# measure processing time", "\n            ", "start_time", " = time.time()\n            ", "# get results", "\n            ", "results", " = compiled_model([input_img])\n            ", "stop_time", " = time.time()\n            ", "#记录编译推断模型时间", "\n            \n            ", "pafs", " = results[pafs_output_key]\n            ", "heatmaps", " = results[heatmaps_output_key] ", "#pafs和heatmaps都是神经网络的输出结果", "\n\n            ", "# get poses from network results", "\n            poses, ", "scores", " = process_results(frame, pafs, heatmaps)", "#关节点 置信度", "\n            ", "# draw poses on a frame", "\n            ", "frame", " = draw_poses(frame, poses, ", "0.1", ")", "#frame是指视频流中的一帧图像", "\n\n            processing_times.append(stop_time - start_time)\n            ", "# use processing times from last 200 frames", "\n            ", "if", " len(processing_times) > ", "200", ":\n                processing_times.popleft()\n\n            _, ", "f_width", " = frame.shape[:", "2", "]\n            ", "# mean processing time [ms]", "\n            ", "processing_time", " = np.mean(processing_times) * ", "1000", "\n            ", "fps", " = ", "1000", " / processing_time\n            output_video.write(frame)\n            cv2.putText(frame, f", "\"Inference time: {processing_time:.1f}ms ({fps:.1f} FPS)\"", ", (", "20", ", ", "40", "),\n                        cv2.FONT_HERSHEY_COMPLEX, f_width / ", "1000", ", (", "0", ", ", "0", ", ", "255", "), ", "1", ", cv2.LINE_AA)\n            ", "#这段代码的作用是计算并在窗口上显示每秒处理的帧数（FPS）和推断时间（即处理一帧所需的平均时间）", "\n\n            ", "# use this workaround if there is flickering", "\n\n            ", "if", " use_popup:\n                cv2.imshow(title, frame)                    ", "#在窗口显示", "\n                ", "key", " = cv2.waitKey(", "1", ")\n                ", "# escape = 27", "\n                ", "if", " ", "key", " == ", "27", ":", "#在OpenCV中，按下ESC键的ASCII码为27", "\n                    break\n            ", "else", ":\n                ", "# encode numpy array to jpg", "\n                _, ", "encoded_img", " = cv2.imencode(", "\".jpg\"", ", frame, ", "params=[cv2.IMWRITE_JPEG_QUALITY,", " ", "90", "])\n                ", "# create IPython image", "\n                ", "i", " = display.Image(", "data=encoded_img)", "\n                ", "# display the image in this notebook       #在vscode显示", "\n                display.clear_output(", "wait=True)", " \n                display.display(i)\n        output_video.release()\n    ", "# ctrl-c异常处理", "\n    except KeyboardInterrupt:\n        print(", "\"Interrupted\"", ")\n    ", "# any different error", "\n    except RuntimeError as e:\n        print(e)\n    finally:\n        ", "if", " player is not None:\n            ", "# stop capturing", "\n            player.stop()\n        ", "if", " use_popup:\n            cv2.destroyAllWindows()\n\n", "video_file", " = ", "\"https://github.com/intel-iot-devkit/sample-videos/blob/master/store-aisle-detection.mp4?raw=true\"", "\nrun_pose_estimation(video_file, ", "flip=False,", " ", "use_popup=False,", " ", "skip_first_frames=0)", "\n"]], "Tag": "算法设计"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;以下回答来自chatgpt:\n &lt;p&gt;答案&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;要查看Windows电脑的网卡速率和双工模式&amp;#xff0c;可以使用以下命令&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;在命令行中输入ipconfig /all&amp;#xff0c;查看网卡的速度和双工模式。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;例如&amp;#xff0c;可以通过以下命令查看以太网卡&amp;#xff08;名称为Ethernet&amp;#xff09;的速度和模式&amp;#xff1a;&lt;/p&gt;\n&lt;div class=\"codehilite\"&gt;&lt;pre&gt;&lt;code&gt;ipconfig /all | findstr /i &amp;#34;Ethernet&amp;#34; -A 7\n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;\n\n&lt;ol&gt;&lt;li&gt;在设备管理器中找到网络适配器&amp;#xff08;网卡&amp;#xff09;&amp;#xff0c;查看其属性中的速度和双工模式。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;例如&amp;#xff0c;可以通过以下步骤查看&amp;#xff1a;&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;按下Win &amp;#43; X键&amp;#xff0c;在弹出的菜单中选择设备管理器。&lt;/li&gt;&lt;li&gt;在设备管理器中找到“网络适配器”选项&amp;#xff0c;展开该选项。&lt;/li&gt;&lt;li&gt;找到你想要查看的网卡&amp;#xff0c;右键点击该网卡&amp;#xff0c;选择“属性”。&lt;/li&gt;&lt;li&gt;在属性窗口中选择“高级”选项卡&amp;#xff0c;查看“速度和双工模式”属性的值。&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;div class=\"codehilite\"&gt;&lt;pre&gt;&lt;code&gt;# 查看以太网卡的速度和双工模式\nipconfig /all | findstr /i &amp;#34;Ethernet&amp;#34; -A 7\n\n# 查看所有网卡的速度和双工模式\nipconfig /all\n\n# 查看网卡属性中的速度和双工模式\nGet-NetAdapterAdvancedProperty -Name &amp;#34;Ethernet&amp;#34; -DisplayName &amp;#34;Speed &amp;amp; Duplex&amp;#34;\n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "网络中的流", "Question": ["Windows的网卡速率和双工模式如何用命令查看", ["那位专家知道，什么命令可以输出Windows的网卡速率和双工模式，双工模式显示full，half或者auto。"]], "Tag": "算法设计"}
