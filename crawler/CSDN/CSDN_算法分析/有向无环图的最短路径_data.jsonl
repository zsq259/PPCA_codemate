{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;\nusing namespace std;\nvector&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&amp;gt; road&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;]&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;// 储存每个点能通向的其他点&lt;/span&gt;\nvector&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&amp;gt; finds,key;       &lt;span class=\"hljs-comment\"&gt;// 查找过错 and 储存答案&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;          &lt;span class=\"hljs-comment\"&gt;// 查找结果&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;]&lt;/span&gt;&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;};             &lt;span class=\"hljs-comment\"&gt;// 避免查询过程重复路径&lt;/span&gt;\nvoid find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; N,num,a,b;             &lt;span class=\"hljs-comment\"&gt;// 总点数,边个数,俩个边&lt;/span&gt;\n    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; num;\n\n    &lt;span class=\"hljs-comment\"&gt;// 数据读入&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (num--){\n        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;\n        road&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;a&lt;/span&gt;]&lt;/span&gt;.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;//        road[b].push_back(a);  // 注意无向的话俩个顶点应该是互通的,可你这道题是不互通&lt;/span&gt;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//  开始查询&lt;/span&gt;\n    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;\n    find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;//  答案输出&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag){\n        cout &amp;lt;&amp;lt; key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;z&amp;lt;key.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;z&amp;#43;&amp;#43;) cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;;\n    }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\nvoid find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt;) return;\n    op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    finds.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;y)\n    {\n&lt;span class=\"hljs-comment\"&gt;//        cout&amp;lt;&amp;lt; &amp;#34;*****&amp;#34;;  // 解开注释观察测试数据&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(finds.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;&amp;lt;key.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; || &lt;/span&gt;key.empty&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt; ) {\n            key.assign(finds.&lt;span class=\"hljs-keyword\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;,finds.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;// key复制finds&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(finds.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;&amp;#61;&amp;#61;key.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;){\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;finds.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;z&amp;#43;&amp;#43;){\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;&amp;#61;&amp;#61;finds&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;) continue;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;&amp;gt;finds&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;) key.assign(finds.&lt;span class=\"hljs-keyword\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;,finds.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;// key下一个数比finds的大&lt;/span&gt;\n                break;\n            }\n        }\n        flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n\n&lt;span class=\"hljs-comment\"&gt;//    解开注释观察每次测试数据变换&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    for(int z:finds) cout &amp;lt;&amp;lt; z &amp;lt;&amp;lt; &amp;#34; &amp;#34;;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    cout &amp;lt;&amp;lt; endl;&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; z:road&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt;)  find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;z&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;;\n    finds.pop&lt;span class=\"hljs-constructor\"&gt;_back()&lt;/span&gt;;\n    op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/139437109356198.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "有向无环图的最短路径", "Question": ["图，最短路径，好难，求解", ["路径存在", "对一个包含 N 个顶点的有向图 G(V, E) 用邻接表进行存储，其中顶点以数组保存。对于该有向图类 adjListGraph，", "要求增加一个成员函数 existPath，对于图中的任两个顶点 i, j，检查它们之间是否有路径存在。如有，输出其中最小的一条路径。", "如无，输出字符串 \"false\"。(40')", "\n", "对于最小路径，首先判断长度，输出较小长度的路径，若存在多条长度相同的路径，则输出路径顺序中结点编号较小的路径。例如路径 6 1 5 4 和 6 2 3 4，应选择前者输出。 ", "\n", "注：图中可能存在环。", "\n", "要求：在文件头部说明新增成员函数的设计思路，并分析时间复杂度分析。(10')", "\n", "输入描述", "第1行输入顶点个数 N，N 为正整数。", "\n", "第2行输入有向边信息，边的起点和终点分别为顶点的编号，编号间以逗号相隔，边之间以空格相隔。", "\n", "第3行输入路径起点和终点的编号，以空格相隔。", "\n", "输出描述", "输出路径检查的结果。", "\n", "输入举例", "6", "1,3 2,3 1,4 3,5 2,5 4,2 5,6 3,6", "4 6", "输出举例", "4 2 3 6", "\n", "#", "include", "<bits/stdc++.h>\nusing namespace std;\ntemplate<", "class", " elemType>\n", "class", " linkQueue\n{\n    ", "private", ":\n        ", "struct", " node\n        {\n            elemType data;\n            node *next;\n            node( elemType &x,node *N=NULL)\n            {\n                data=x;\n                next=N;\n            }\n            node", "()", ":next(NULL){}\n            ~node", "()", "{}\n        };\n    node *front,*rear;\n    public:\n        link", "Queue()", ";\n        ~link", "Queue()", ";\n        ", "bool", " is", "Empty()", " ;\n        elemType de", "Queue()", ";\n        void en", "Queue( ", "elemType", " &", "x", ")", ";\n};\n\ntemplate<", "class", " elemType>\n", "bool", " linkQueue<elemType>::is", "Empty()", " \n{\n    return front==NULL;\n}\ntemplate<", "class", " elemType>\nlinkQueue<elemType>::link", "Queue()", "\n{\n    front=rear=NULL;\n}\ntemplate<", "class", " elemType>\nlinkQueue<elemType>::~link", "Queue()", "\n{\n    node *tmp;\n    ", "while", "(front!=NULL)\n    {\n        tmp=front;\n        front=front->next;\n        delete tmp;\n    }\n}\ntemplate<", "class", " elemType>\nvoid linkQueue<elemType>::en", "Queue(", "elemType", " &", "x", ")", "\n{\n    ", "if", "(rear==NULL)\n        front=rear=", "new", " node(x);\n    ", "else", "\n        rear=rear->next=", "new", " node(x);\n}\ntemplate<", "class", " elemType>\nelemType linkQueue<elemType>::de", "Queue()", "\n{\n    node *tmp=front;\n    elemType value=front->data;\n    front=front->next;\n    ", "if", "(front==NULL)\n        rear=NULL;\n    delete tmp;\n    return value;\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\n", "class", " adjListGraph\n{\n    public:\n        adj", "ListGraph(", "int", " ", "vSize", ")", ";\n        void insert(TypeOfVer x,TypeOfVer y,TypeOfEdge w);\n        ", "//void remove(TypeOfVer x,TypeOfVer y);", "\n        ", "//bool exist(TypeOfVer x,TypeOfVer y)const;", "\n        ", "bool", " check", "Route(", "int", " ", "start", ",", "int", " ", "end", ")", ";\n        ", "//void existPath(int start,int end);", "\n        ", "//~adjListGraph();", "\n        void unweighted", "ShortDistance(TypeOfVer ", "start", ",TypeOfVer ", "end", ",TypeOfEdge ", "noEdge", ")", ";\n    ", "private", ":\n        ", "int", " Vers,Edges;\n        ", "struct", " edgeNode \n        {\n            ", "int", " ", "end", ";\n            TypeOfEdge weight;\n            edgeNode *next;\n            edge", "Node(", "int", " ", "e", ",TypeOfEdge ", "w", ",", "edgeNode", " ", "*", "n", "=NULL)", "\n            {\n                ", "end", "=e;\n                weight=w;\n                next=n;\n            }\n        };\n        ", "struct", " verNode\n        {\n            TypeOfVer ver;\n            edgeNode *head;\n            ver", "Node(", "edgeNode", " ", "*", "h", "=NULL)", "\n            {\n                head=h;\n            }\n        };\n        verNode *verList;\n        ", "int", " find(TypeOfVer v)const\n        {\n            ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n            {\n                ", "if", "(verList", "[", "i", "]", ".ver==v)\n                {\n                    return i;\n                }\n            }\n        }\n        ", "bool", " check", "Route(", "int", " ", "start", ",", "int", " ", "end", ",", "bool", " ", "visited", "[])", ";\n        ", "//void existPath(int start,int end,bool visited[]);", "\n        void print", "Path(", "int", " ", "start", ",", "int", " ", "end", ",", "int", " ", "prev", "[])", ";\n};\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nadjListGraph<TypeOfVer,TypeOfEdge>::adj", "ListGraph(", "int", " ", "vSize", ")", "\n{\n    Vers=vSize;\n    Edges=", "0", ";\n    verList=", "new", " verNode", "[", "vSize", "]", ";\n    ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n    {\n        verList", "[", "i", "]", ".ver=i+", "1", ";\n    }\n}\n", "/*template<class TypeOfVer,class TypeOfEdge>\nadjListGraph<TypeOfVer,TypeOfEdge>::~adjListGraph()\n{\n    int i;\n    edgeNode *p;\n    for(i=0;i<Vers;i++)\n    {\n        while((p=verList[i].head)!=NULL)\n        {\n            verList[i].head=p->next;\n            delete p;\n        }\n    }\n    delete []verList;\n}*/", "\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::insert(TypeOfVer x,TypeOfVer y,TypeOfEdge w)\n{\n    ", "int", " u=find(x);\n    ", "int", " v=find(y);\n    verList", "[", "u", "]", ".head=", "new", " edge", "Node(", "v", ",", "w", ",", "verList", "[", "u", "].", "head", ")", ";\n    ++Edges;\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\n", "bool", " adjListGraph<TypeOfVer,TypeOfEdge>::check", "Route(", "int", " ", "start", ",", "int", " ", "end", ")", "\n{\n    ", "bool", " *visited=", "new", " ", "bool", "[V", "ers", "]", ";\n    ", "int", " startNo,endNo;\n    ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n    {\n        visited", "[", "i", "]", "=", "false", ";\n    }\n    ", "for", "(startNo=", "0", ";startNo<Vers;startNo++)\n    {\n        ", "if", "(verList", "[", "startNo", "]", ".ver==start)break;\n    }\n    ", "//if(startNo==Vers)return false;", "\n    ", "for", "(endNo=", "0", ";endNo<Vers;endNo++)\n    {\n        ", "if", "(verList", "[", "endNo", "]", ".ver==", "end", ")break;\n    }\n    ", "//if(endNo==Vers)return false;", "\n    return check", "Route(", "startNo", ",", "endNo", ",", "visited", ")", ";\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\n", "bool", " adjListGraph<TypeOfVer,TypeOfEdge>::check", "Route(", "int", " ", "start", ",", "int", " ", "end", ",", "bool", " ", "visited", "[])", "\n{\n    edgeNode *p=verList", "[", "start", "]", ".head;\n    ", "bool", " flag=", "0", ";\n    visited", "[", "start", "]", "=", "true", ";\n    ", "while", "(p!=NULL)\n    {\n        ", "if", "(p->", "end", "==", "end", ")return ", "true", ";\n        ", "if", "(!visited", "[", "p", "->", "end", "]", ")\n        {\n            flag=check", "Route(", "p", "->", "end", ",", "end", ",", "visited", ")", ";\n            ", "if", "(flag)return ", "true", ";\n        }\n        p=p->next;\n    }\n    ", "//cout<<\"okok\";", "\n    return ", "false", ";\n}\n", "/*template<class TypeOfVer,class TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::existPath(int start,int end)\n{\n    bool *visited=new bool[Vers];\n    for(int i=0;i<Vers;i++)\n    {\n        visited[i]=false;\n    }\n    existPath(start,end,visited);\n}\nstatic int L[100],o=0;\ntemplate<class TypeOfVer,class TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::existPath(int start,int end,bool visited[])\n{\n    edgeNode *p=verList[start].head;\n    L[o]=start;\n    o++;\n    //cout<<start;\n    visited[start]=true;\n    while(p!=NULL)\n    {\n        if(p->end==end)\n        {\n            L[o]=end;\n            o++;\n            //cout<<\"okok\";\n            break;\n        }\n        else if(!visited[p->end]&&checkRoute(p->end,end))\n        {\n            existPath(p->end,end,visited);\n        }\n        p=p->next;\n    }\n}*/", "\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::unweighted", "ShortDistance(TypeOfVer ", "start", ",TypeOfVer ", "end", ",TypeOfEdge ", "noEdge", ")", "\n{\n    linkQueue<", "int", "> q;\n    TypeOfEdge *distance=", "new", " TypeOfEdge", "[V", "ers", "]", ";\n    ", "int", " *prev=", "new", " ", "int", "[V", "ers", "]", ";\n    ", "int", " u,sNo;\n    edgeNode *p;\n    ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n    {\n        distance", "[", "i", "]", "=noEdge;\n    }\n    sNo=find(start);\n    distance", "[", "sNo", "]", "=", "0", ";\n    prev", "[", "sNo", "]", "=sNo;\n    q.en", "Queue(", "sNo", ")", ";\n    ", "while", "(!q.is", "Empty()", ")\n    {\n        u=q.de", "Queue()", ";\n        ", "for", "(p=verList", "[", "u", "]", ".head;p!=NULL;p=p->next)\n        {\n            ", "if", "(distance", "[", "p", "->", "end", "]", "==noEdge)\n            {\n                distance", "[", "p", "->", "end", "]", "=distance", "[", "u", "]", "+", "1", ";\n                prev", "[", "p", "->", "end", "]", "=u;\n                q.en", "Queue(", "p", "->", "end", ")", ";\n            }\n        }\n    }\n    ", "//cout<<prev[6]<<endl; ", "\n    print", "Path(", "sNo", ",", "end", "-1,", "prev", ")", ";\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::print", "Path(", "int", " ", "start", ",", "int", " ", "end", ",", "int", " ", "prev", "[])", "\n{\n    ", "if", "(start==", "end", ")\n    {\n        cout<<verList", "[", "start", "]", ".ver;\n        return;\n    }\n    print", "Path(", "start", ",", "prev", "[", "end", "],", "prev", ")", ";\n    cout<<", "' '", "<<verList", "[", "end", "]", ".ver;\n}\n", "//int **Arr;", "\n", "int", " main", "()", "\n{\n    ", "int", " n;\n    cin>>n;\n    ", "string", " str;\n    getline(cin,str);\n    getline(cin,str);\n    ", "//cout<<str;", "\n    ", "int", " x,y;\n    cin>>x>>y;\n    ", "//cout<<x<<y;", "\n    adjListGraph<", "int", ",", "int", "> ", "A(", "n", ")", ";\n    ", "int", " k=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<str.size", "()", ";i++)\n    {\n        ", "if", "(str", "[", "i", "]", "==", "','", ")\n        {\n            k++;\n        }\n    }\n    ", "//cout<<k;", "\n    ", "for", "(", "int", " i=", "0", ";i<k;i++)\n    {\n        ", "int", " t1,t2,u,v;\n        u=", "4", "*i;v=", "4", "*i+", "2", ";\n        t1=str", "[", "u", "]", "-", "'0'", ";\n        t2=str", "[", "v", "]", "-", "'0'", ";\n        ", "//cout<<t1<<\" \"<<t2<<endl;", "\n        ", "A", ".", "insert(t1,t2,", "0", ");\n    }    \n    ", "bool", " flg=", "A", ".", "check", "Route(", "x", ",", "y", ")", ";\n    ", "//cout<<flg;", "\n    ", "if", "(flg)\n    {\n        ", "A", ".", "unweighted", "ShortDistance(", "x", ",", "y", ",-1)", ";\n    }\n    ", "else", "\n    {\n        cout<<", "\"false\"", ";\n    }\n}\n\n", "\n", "这个是自己写的但是没有办法满足“若存在多条长度相同的路径，则输出路径顺序中结点编号较小的路径”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;解决方法&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;把MTGraph G1, G2, G3挪到main函数外&amp;#xff0c;定义为全局变量&lt;/li&gt;&lt;li&gt;动态分配G1, G2, G3的内存&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "有向无环图的最短路径", "Question": ["VS2019 栈溢出：Stack overflow，数组可能定义太大？", ["\n#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n#include<string>\n#include<fstream>\n#include<windows.h>\n#define ", "NumVertices", " ", "405", "\n#define ", "INFINITY", " ", "65535", " //设", "65535", "为无穷大 \nusing namespace std;\ntypedef int ", "EdgeDate", ";\ntypedef int ", "Pathmatrix", "[", "NumVertices", "][", "NumVertices", "];\ntypedef int ", "ShortPathTable", "[", "NumVertices", "][", "NumVertices", "];\n\ntypedef struct\n{\n    char name[", "50", "];//站点名\n    int linenum[", "5", "];//线路对应序列 \n}station;\n\ntypedef struct\n{\n     char linename[", "20", "];//线路名称   \n}linesystem;\n\ntypedef struct \n{\n    linesystem line[", "15", "]; \n    station ", "VerList", "[", "NumVertices", "];//站点信息 \n    ", "EdgeDate", " ", "Edge", "[", "NumVertices", "][", "NumVertices", "];         // 距离边权值 \n    int n,e;        \n}", "MTGraph", ";\n\nvoid ", "SetLine", "(", "MTGraph", " &", "G", ")//初始化站点所在线路对应的序列 \n{\n    ", "/*\n    605路        1\n    615路        2\n    402路        3\n    368外环      4 \n    368内环      5\n    400外环      6\n    400快内环    7\n    973路        8\n    135路        9\n    26路         10\n    300快外环    11\n    94路         12\n    34路         13\n    200外环      14\n    671路        15\n    */", "\n     int i;\n     ", "G", ".", "VerList", "[", "0", "].linenum[", "0", "] = ", "3", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "1", "] = ", "4", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "2", "] = ", "5", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "4", "] = ", "15", ";\n     ", "G", ".", "VerList", "[", "1", "].linenum[", "0", "] = ", "3", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "1", "] = ", "4", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "2", "] = ", "5", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "4", "] = ", "3", ";\n     ", "G", ".", "VerList", "[", "2", "].linenum[", "0", "] = ", "4", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "1", "] = ", "5", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "2", "] = ", "8", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "4", "] = ", "4", ";\n     ", "G", ".", "VerList", "[", "3", "].linenum[", "0", "] = ", "4", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "1", "] = ", "5", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "2", "] = ", "8", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "4", "] = ", "4", ";\n    //", "15", "\n    for(i=", "391", ";i<=", "404", ";i++){\n        ", "G", ".", "VerList", "[i].linenum[", "0", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "1", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "2", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "3", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "4", "]=", "15", ";\n    }\n}\n\nvoid ", "Getline", "(", "MTGraph", " &", "G", ") //读入线路 名称 \n{\n      int i=", "0", ";\n      ifstream ifp; \n      ifp.open(", "\"bus_Rname.txt\"", ",ios::in);\n      while(!ifp.eof())                    // 如果未读完，继续读文本      eof end of file\n      {                                  \n          ifp>>", "G", ".line[i].linename;       //\n          i++;\n      } \n      ifp.close();\n}\n\nvoid ", "CreateGraph_2", "(", "MTGraph", "& ", "G", ")//初始化一般时间段 \n{\n    ", "Getline", "(", "G", ");\n    ", "SetLine", "(", "G", ");//读入线路信息     \n    int i;\n    ", "G", ".n = ", "0", ";\n    ", "G", ".e = ", "0", ";\n    int j = ", "0", ";\n    ifstream ifp;\n    ifp.open(", "\"bus_name.txt\"", ", ios::in);\n    while (!ifp.eof())\n    {\n        ++", "G", ".n;\n        ifp >> ", "G", ".", "VerList", "[j].name;//读入站点相关信息 \n        j++;\n    }\n    ifp.close();\n    for (i = ", "0", "; i < ", "G", ".n; i++)\n    {\n        for (j = ", "0", "; j < ", "G", ".n; j++)\n        {\n            ", "G", ".", "Edge", "[i][j] = ", "INFINITY", ";//权值初始化 \n        }\n        ", "G", ".", "Edge", "[i][i] = ", "0", ";\n    }\n    int v1, v2, w;\n    ", "FILE", "* fp2;\n    fp2=fopen(", "\"bus_time.txt\"", ", ", "\"r\"", ");\n    if (", "NULL", " == fp2) printf(", "\"文件打开失败\"", ");\n    else\n    {\n        while (!feof(fp2))\n        {\n            fscanf(fp2, ", "\"%d %d %d\"", ", &v1, &v2, &w);//读入边权值 \n            ", "G", ".", "Edge", "[v1][v2] = w;\n            ", "G", ".", "Edge", "[v2][v1] = w;\n            ++", "G", ".e;\n        }\n        fclose(fp2);\n    }\n}\n\nint ", "Getnum", "(", "MTGraph", "& ", "G", ", char* a)//取得站点对应下标 \n{\n    int i = ", "0", ";\n    while (i < ", "G", ".n)\n    {\n        if (strcmp(", "G", ".", "VerList", "[i].name, a) == ", "0", ")\n        {\n            return i;\n            break;\n        }\n        else\n            i++;\n    }\n    if (i >= ", "G", ".n)\n        return ", "-1", ";\n}\n\n\nvoid ", "ShortestPath", "(", "MTGraph", " &", "G", ",", "Pathmatrix", " ", "P", ",", "ShortPathTable", " ", "D", ")//求最短路径 \n{\n    int trans[", "118", "]; \n    char a[", "20", "],b[", "20", "];\n    int i,j,v,w,k,m,n,p,q,r,t,", "T", ";\n    char s;\n    for(i=", "-1", ";i<", "118", ";i++)\n    {\n        trans[i]=i;//对比是否为换乘 \n    }\n    for(v=", "0", ";v<", "G", ".n;v++)//初始化", "D", "与", "P", " \n    {\n        for(w=", "0", ";w<", "G", ".n;w++)\n        {\n           ", "D", "[v][w]=", "G", ".", "Edge", "[v][w];//", "D", "值为对应权值 \n           ", "P", "[v][w]=w;//初始化", "P", "                  \n        }                  \n    }    \n    for(k=", "0", ";k<", "G", ".n;k++)\n    {\n        for(v=", "0", ";v<", "G", ".n;v++)\n        {\n           for(w=", "0", ";w<", "G", ".n;w++)\n           {\n               if(", "D", "[v][w]>", "D", "[v][k]+", "D", "[k][w])//如果经过下标为k顶点路径比原两点间路径更短，将当前权值设为更小的 \n               {\n                   ", "D", "[v][w]=", "D", "[v][k]+", "D", "[k][w];// \n                   ", "P", "[v][w]=", "P", "[v][k];//路径设置经过下标为k的顶点                           \n               }\n           }\n        }                  \n    }//", "Floyd", "算法求最小路径 \n  while(", "1", ")\n  {\n    cout<<endl<<endl<<endl<<", "\"                               ☆最快路径查询☆\"", "<<endl;\n    cout<<", "\"..............................................................................\"", "<<endl<<endl;      \n    while(", "1", ")\n    {\n        while(", "1", ")\n        {    \n            cout<<", "\"            >>>>>>>>>请输入起点站：\"", ";\n            cin>>a;\n            v=", "Getnum", "(", "G", ",a);\n            if(v==", "-1", ")\n            cout<<", "\"站点不存在请重新输入！\"", "<<endl;\n            else\n            break;\n        }\n        while(", "1", ")\n        {\n            cout<<endl<<", "\"            >>>>>>>>>请输入终点站：\"", ";\n            cin>>b;\n            w=", "Getnum", "(", "G", ",b); \n            if(w==", "-1", ")\n            cout<<", "\"站点不存在请重新输入！\"", "<<endl;\n            else\n            break;\n        }\n        if(v==w)\n        cout<<", "\"请输入两个不同的站点名！\"", "<<endl;\n        else\n        break;\n    }//输入起始点于终点 \n    system(", "\"cls\"", ");\n    \n    p=", "0", ";\n    k=", "P", "[v][w];\n    for(i=", "0", ";i<", "3", ";i++)\n    {\n        for(j=", "0", ";j<", "3", ";j++)\n        {\n            if(", "G", ".", "VerList", "[v].linenum[i]==", "G", ".", "VerList", "[k].linenum[j])\n            {p=", "G", ".", "VerList", "[v].linenum[i];}//确定初始时所在的地铁线路对应序列 \n        }\n    }\n    if(p==", "0", ")\n    {p=", "G", ".", "VerList", "[v].linenum[", "0", "];}//如果不能找到对应序列则取下一结点的序列，仅针对", "13", "号起点终点与机场线起点这种", "3", "线交叉情况 */\n    cout<<endl<<endl<<endl<<", "\"                               ☆最快路径查询☆\"", "<<endl;\n    cout<<", "\"..............................................................................\"", "<<endl<<endl;  \n    cout<<", "\"......................起点在\"", "<<p<<", "\"..........\"", "<<", "G", ".line[p", "-1", "].linename<<", "\"........................\"", "<<endl<<endl;     \n    cout<<", "\"            >>>>>>>>>用时最短路径: \"", "<<endl<<endl<<", "\"            >>>>>>>>> ->在 \"", "<<", "G", ".", "VerList", "[v].name<<", "\" 乘 \"", "<<", "G", ".line[p", "-1", "].linename<<", "\" (\"", "<<", "G", ".", "VerList", "[k].name<<", "\"方向)\"", "<<endl;\n    m=v;//设m为k在最短路径中的直接前驱 \n    r=v; \n    ", "T", "=", "3", ";\n    while(k!=w)\n    {\n        q=", "-1", ";\n        while(k!=trans[q]&&k<", "118", ")\n        { \n            q++;\n            if(k==trans[q])//如果k满足是可换乘节点 \n            {\n                n=", "P", "[k][w];//设m为k在最短路径中的直接后继  \n                p=t=", "-1", ";\n                for(i=", "0", ";i<", "5", ";i++)\n                {\n                   for(j=", "0", ";j<", "5", ";j++)\n                   {\n                       if(", "G", ".", "VerList", "[m].linenum[i]==", "G", ".", "VerList", "[k].linenum[j])\n                       {p=", "G", ".", "VerList", "[m].linenum[i];} \n                   }\n                }\n                if(p==", "-1", ")\n                p=", "G", ".", "VerList", "[m].linenum[", "0", "];\n                \n                for(i=", "0", ";i<", "5", ";i++)\n                {\n                   for(j=", "0", ";j<", "5", ";j++)\n                   {\n                       if(", "G", ".", "VerList", "[k].linenum[i]==", "G", ".", "VerList", "[n].linenum[j])\n                       {t=", "G", ".", "VerList", "[k].linenum[i];}\n                   }\n                }\n                if(t==", "-1", ")\n                {\n                    ", "/*if(k==9||k==12)\n                    t=9;\n                    else if(k==23)\n                    t=13;\n                    else */", "\n                    t=", "G", ".", "VerList", "[n].linenum[", "1", "];\n                }\n                if(p!=t)//若k前后两线路序列号不同则换乘 \n                {       \n                    int a=", "D", "[r][k];\n                    double b=a/", "1000", ";        \n                    cout<<", "\"            >>>>>>>>> ->距离为\"", "<<", "D", "[r][k]<<", "\"米，用时约\"", "<<b<<", "\"分钟 至：\"", "<<", "G", ".", "VerList", "[k].name<<", "\" 换乘 \"", "<<", "G", ".line[t", "-1", "].linename<<", "\" (\"", "<<", "G", ".", "VerList", "[n].name<<", "\"方向)\"", "<<endl;//若路径点为换乘点则打印 \n                    r=k;//设定r结点用于求分段时间 \n                    ", "T", "+=", "5", ";\n                } \n            }\n        }\n        \n     m=", "P", "[m][w];//m后移   \n     k=", "P", "[k][w];//k后移             \n    } \n    int c=", "D", "[r][w];\n    int f=", "D", "[v][w];\n    int value;\n    double d=c/", "1000", ";\n    double e=f/", "1000", ";\n    if(", "D", "[v][w]<", "6000", ")\n        value=", "3", ";\n    else if(", "6000", "<", "D", "[v][w]&&", "D", "[v][w]<", "12000", ")\n        value=", "4", ";\n    else if(", "12000", "<", "D", "[v][w]&&", "D", "[v][w]<", "22000", ")\n        value=", "5", ";\n    else if(", "22000", "<", "D", "[v][w]&&", "D", "[v][w]<", "32000", ")\n        value=", "6", ";\n    else if(", "52000", "<", "D", "[v][w]&&", "D", "[v][w]<", "72000", ")\n        value=", "7", ";    \n    else if(", "72000", "<", "D", "[v][w]&&", "D", "[v][w]<", "92000", ")\n        value=", "8", ";    \n    cout<<", "\"            >>>>>>>>> ->距离为\"", "<<", "D", "[r][w]<<", "\"米，用时约\"", "<<d<<", "\"分钟，到达终点：\"", "<<", "G", ".", "VerList", "[w].name<<endl;\n    cout<<endl<<", "\"            >>>>>>>>>总里程为\"", "<<", "D", "[v][w]<<", "\"米，考虑换乘以及等车一共约用时为：\"", "<<e+", "T", "<<", "\"分钟,票价为\"", "<<value<<", "\"元！！！！\"", "<<endl<<endl<<endl<<endl<<endl<<endl;\n    cout<<", "\"            >>>>>>>>>是否继续查询？（Y/N）\"", ";\n    scanf(", "\"%s\"", ",&s);\n    if(s!=", "'y'", "&&s!=", "'Y'", ")\n    break;\n    else\n    system(", "\"cls\"", ");\n    }                \n}\n\nint main()\n{\n    ", "MTGraph", " ", "G1", ",", "G2", ",", "G3", ";\n    char a,d;\n    int c; \n    char b[", "10", "];\n\n\n     scanf(", "\"%s\"", ",&d);\n     system(", "\"cls\"", ");\n               if(d==", "'2'", ")\n              { \n                      ", "CreateGraph_2", "(", "G2", ");\n                      ", "Pathmatrix", " ", "P", ";\n                      ", "ShortPathTable", " ", "D", ";\n                      ", "ShortestPath", "(", "G2", ",", "P", ",", "D", ");\n                      printf(", "\"\\n\"", ");\n                      printf(", "\"请按Enter键返回上一级菜单\"", ");\n                      ", "_getch", "();\n                      system(", "\"cls\"", ");\n                      \n              }           \nreturn ", "0", ";\n}\n", "\n", "初始定义了一个结构体中的数组，大小为405，在dev上能够正常运行，但在VS2019上则出现异常。", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;\nusing namespace std;\nvector&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&amp;gt; road&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;]&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;// 储存每个点能通向的其他点&lt;/span&gt;\nvector&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&amp;gt; finds,key;       &lt;span class=\"hljs-comment\"&gt;// 查找过错 and 储存答案&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;          &lt;span class=\"hljs-comment\"&gt;// 查找结果&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;]&lt;/span&gt;&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;};             &lt;span class=\"hljs-comment\"&gt;// 避免查询过程重复路径&lt;/span&gt;\nvoid find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; N,num,a,b;             &lt;span class=\"hljs-comment\"&gt;// 总点数,边个数,俩个边&lt;/span&gt;\n    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; num;\n\n    &lt;span class=\"hljs-comment\"&gt;// 数据读入&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (num--){\n        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;\n        road&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;a&lt;/span&gt;]&lt;/span&gt;.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;//        road[b].push_back(a);  // 注意无向的话俩个顶点应该是互通的,可你这道题是不互通&lt;/span&gt;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//  开始查询&lt;/span&gt;\n    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;\n    find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;//  答案输出&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag){\n        cout &amp;lt;&amp;lt; key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;z&amp;lt;key.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;z&amp;#43;&amp;#43;) cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;;\n    }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;false&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\nvoid find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt;) return;\n    op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    finds.push&lt;span class=\"hljs-constructor\"&gt;_back(&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;y)\n    {\n&lt;span class=\"hljs-comment\"&gt;//        cout&amp;lt;&amp;lt; &amp;#34;*****&amp;#34;;  // 解开注释观察测试数据&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(finds.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;&amp;lt;key.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; || &lt;/span&gt;key.empty&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt; ) {\n            key.assign(finds.&lt;span class=\"hljs-keyword\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;,finds.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;// key复制finds&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(finds.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;&amp;#61;&amp;#61;key.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;){\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;finds.size&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;z&amp;#43;&amp;#43;){\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;&amp;#61;&amp;#61;finds&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;) continue;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(key&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;&amp;gt;finds&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;z&lt;/span&gt;]&lt;/span&gt;) key.assign(finds.&lt;span class=\"hljs-keyword\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;,finds.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;// key下一个数比finds的大&lt;/span&gt;\n                break;\n            }\n        }\n        flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n\n&lt;span class=\"hljs-comment\"&gt;//    解开注释观察每次测试数据变换&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    for(int z:finds) cout &amp;lt;&amp;lt; z &amp;lt;&amp;lt; &amp;#34; &amp;#34;;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    cout &amp;lt;&amp;lt; endl;&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; z:road&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt;)  find&lt;span class=\"hljs-constructor\"&gt;_RoadMin(&lt;span class=\"hljs-params\"&gt;z&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;;\n    finds.pop&lt;span class=\"hljs-constructor\"&gt;_back()&lt;/span&gt;;\n    op&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;x&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/139437109356198.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "有向无环图的最短路径", "Question": ["图，最短路径，好难，求解", ["路径存在", "对一个包含 N 个顶点的有向图 G(V, E) 用邻接表进行存储，其中顶点以数组保存。对于该有向图类 adjListGraph，", "要求增加一个成员函数 existPath，对于图中的任两个顶点 i, j，检查它们之间是否有路径存在。如有，输出其中最小的一条路径。", "如无，输出字符串 \"false\"。(40')", "\n", "对于最小路径，首先判断长度，输出较小长度的路径，若存在多条长度相同的路径，则输出路径顺序中结点编号较小的路径。例如路径 6 1 5 4 和 6 2 3 4，应选择前者输出。 ", "\n", "注：图中可能存在环。", "\n", "要求：在文件头部说明新增成员函数的设计思路，并分析时间复杂度分析。(10')", "\n", "输入描述", "第1行输入顶点个数 N，N 为正整数。", "\n", "第2行输入有向边信息，边的起点和终点分别为顶点的编号，编号间以逗号相隔，边之间以空格相隔。", "\n", "第3行输入路径起点和终点的编号，以空格相隔。", "\n", "输出描述", "输出路径检查的结果。", "\n", "输入举例", "6", "1,3 2,3 1,4 3,5 2,5 4,2 5,6 3,6", "4 6", "输出举例", "4 2 3 6", "\n", "#", "include", "<bits/stdc++.h>\nusing namespace std;\ntemplate<", "class", " elemType>\n", "class", " linkQueue\n{\n    ", "private", ":\n        ", "struct", " node\n        {\n            elemType data;\n            node *next;\n            node( elemType &x,node *N=NULL)\n            {\n                data=x;\n                next=N;\n            }\n            node", "()", ":next(NULL){}\n            ~node", "()", "{}\n        };\n    node *front,*rear;\n    public:\n        link", "Queue()", ";\n        ~link", "Queue()", ";\n        ", "bool", " is", "Empty()", " ;\n        elemType de", "Queue()", ";\n        void en", "Queue( ", "elemType", " &", "x", ")", ";\n};\n\ntemplate<", "class", " elemType>\n", "bool", " linkQueue<elemType>::is", "Empty()", " \n{\n    return front==NULL;\n}\ntemplate<", "class", " elemType>\nlinkQueue<elemType>::link", "Queue()", "\n{\n    front=rear=NULL;\n}\ntemplate<", "class", " elemType>\nlinkQueue<elemType>::~link", "Queue()", "\n{\n    node *tmp;\n    ", "while", "(front!=NULL)\n    {\n        tmp=front;\n        front=front->next;\n        delete tmp;\n    }\n}\ntemplate<", "class", " elemType>\nvoid linkQueue<elemType>::en", "Queue(", "elemType", " &", "x", ")", "\n{\n    ", "if", "(rear==NULL)\n        front=rear=", "new", " node(x);\n    ", "else", "\n        rear=rear->next=", "new", " node(x);\n}\ntemplate<", "class", " elemType>\nelemType linkQueue<elemType>::de", "Queue()", "\n{\n    node *tmp=front;\n    elemType value=front->data;\n    front=front->next;\n    ", "if", "(front==NULL)\n        rear=NULL;\n    delete tmp;\n    return value;\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\n", "class", " adjListGraph\n{\n    public:\n        adj", "ListGraph(", "int", " ", "vSize", ")", ";\n        void insert(TypeOfVer x,TypeOfVer y,TypeOfEdge w);\n        ", "//void remove(TypeOfVer x,TypeOfVer y);", "\n        ", "//bool exist(TypeOfVer x,TypeOfVer y)const;", "\n        ", "bool", " check", "Route(", "int", " ", "start", ",", "int", " ", "end", ")", ";\n        ", "//void existPath(int start,int end);", "\n        ", "//~adjListGraph();", "\n        void unweighted", "ShortDistance(TypeOfVer ", "start", ",TypeOfVer ", "end", ",TypeOfEdge ", "noEdge", ")", ";\n    ", "private", ":\n        ", "int", " Vers,Edges;\n        ", "struct", " edgeNode \n        {\n            ", "int", " ", "end", ";\n            TypeOfEdge weight;\n            edgeNode *next;\n            edge", "Node(", "int", " ", "e", ",TypeOfEdge ", "w", ",", "edgeNode", " ", "*", "n", "=NULL)", "\n            {\n                ", "end", "=e;\n                weight=w;\n                next=n;\n            }\n        };\n        ", "struct", " verNode\n        {\n            TypeOfVer ver;\n            edgeNode *head;\n            ver", "Node(", "edgeNode", " ", "*", "h", "=NULL)", "\n            {\n                head=h;\n            }\n        };\n        verNode *verList;\n        ", "int", " find(TypeOfVer v)const\n        {\n            ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n            {\n                ", "if", "(verList", "[", "i", "]", ".ver==v)\n                {\n                    return i;\n                }\n            }\n        }\n        ", "bool", " check", "Route(", "int", " ", "start", ",", "int", " ", "end", ",", "bool", " ", "visited", "[])", ";\n        ", "//void existPath(int start,int end,bool visited[]);", "\n        void print", "Path(", "int", " ", "start", ",", "int", " ", "end", ",", "int", " ", "prev", "[])", ";\n};\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nadjListGraph<TypeOfVer,TypeOfEdge>::adj", "ListGraph(", "int", " ", "vSize", ")", "\n{\n    Vers=vSize;\n    Edges=", "0", ";\n    verList=", "new", " verNode", "[", "vSize", "]", ";\n    ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n    {\n        verList", "[", "i", "]", ".ver=i+", "1", ";\n    }\n}\n", "/*template<class TypeOfVer,class TypeOfEdge>\nadjListGraph<TypeOfVer,TypeOfEdge>::~adjListGraph()\n{\n    int i;\n    edgeNode *p;\n    for(i=0;i<Vers;i++)\n    {\n        while((p=verList[i].head)!=NULL)\n        {\n            verList[i].head=p->next;\n            delete p;\n        }\n    }\n    delete []verList;\n}*/", "\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::insert(TypeOfVer x,TypeOfVer y,TypeOfEdge w)\n{\n    ", "int", " u=find(x);\n    ", "int", " v=find(y);\n    verList", "[", "u", "]", ".head=", "new", " edge", "Node(", "v", ",", "w", ",", "verList", "[", "u", "].", "head", ")", ";\n    ++Edges;\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\n", "bool", " adjListGraph<TypeOfVer,TypeOfEdge>::check", "Route(", "int", " ", "start", ",", "int", " ", "end", ")", "\n{\n    ", "bool", " *visited=", "new", " ", "bool", "[V", "ers", "]", ";\n    ", "int", " startNo,endNo;\n    ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n    {\n        visited", "[", "i", "]", "=", "false", ";\n    }\n    ", "for", "(startNo=", "0", ";startNo<Vers;startNo++)\n    {\n        ", "if", "(verList", "[", "startNo", "]", ".ver==start)break;\n    }\n    ", "//if(startNo==Vers)return false;", "\n    ", "for", "(endNo=", "0", ";endNo<Vers;endNo++)\n    {\n        ", "if", "(verList", "[", "endNo", "]", ".ver==", "end", ")break;\n    }\n    ", "//if(endNo==Vers)return false;", "\n    return check", "Route(", "startNo", ",", "endNo", ",", "visited", ")", ";\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\n", "bool", " adjListGraph<TypeOfVer,TypeOfEdge>::check", "Route(", "int", " ", "start", ",", "int", " ", "end", ",", "bool", " ", "visited", "[])", "\n{\n    edgeNode *p=verList", "[", "start", "]", ".head;\n    ", "bool", " flag=", "0", ";\n    visited", "[", "start", "]", "=", "true", ";\n    ", "while", "(p!=NULL)\n    {\n        ", "if", "(p->", "end", "==", "end", ")return ", "true", ";\n        ", "if", "(!visited", "[", "p", "->", "end", "]", ")\n        {\n            flag=check", "Route(", "p", "->", "end", ",", "end", ",", "visited", ")", ";\n            ", "if", "(flag)return ", "true", ";\n        }\n        p=p->next;\n    }\n    ", "//cout<<\"okok\";", "\n    return ", "false", ";\n}\n", "/*template<class TypeOfVer,class TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::existPath(int start,int end)\n{\n    bool *visited=new bool[Vers];\n    for(int i=0;i<Vers;i++)\n    {\n        visited[i]=false;\n    }\n    existPath(start,end,visited);\n}\nstatic int L[100],o=0;\ntemplate<class TypeOfVer,class TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::existPath(int start,int end,bool visited[])\n{\n    edgeNode *p=verList[start].head;\n    L[o]=start;\n    o++;\n    //cout<<start;\n    visited[start]=true;\n    while(p!=NULL)\n    {\n        if(p->end==end)\n        {\n            L[o]=end;\n            o++;\n            //cout<<\"okok\";\n            break;\n        }\n        else if(!visited[p->end]&&checkRoute(p->end,end))\n        {\n            existPath(p->end,end,visited);\n        }\n        p=p->next;\n    }\n}*/", "\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::unweighted", "ShortDistance(TypeOfVer ", "start", ",TypeOfVer ", "end", ",TypeOfEdge ", "noEdge", ")", "\n{\n    linkQueue<", "int", "> q;\n    TypeOfEdge *distance=", "new", " TypeOfEdge", "[V", "ers", "]", ";\n    ", "int", " *prev=", "new", " ", "int", "[V", "ers", "]", ";\n    ", "int", " u,sNo;\n    edgeNode *p;\n    ", "for", "(", "int", " i=", "0", ";i<Vers;i++)\n    {\n        distance", "[", "i", "]", "=noEdge;\n    }\n    sNo=find(start);\n    distance", "[", "sNo", "]", "=", "0", ";\n    prev", "[", "sNo", "]", "=sNo;\n    q.en", "Queue(", "sNo", ")", ";\n    ", "while", "(!q.is", "Empty()", ")\n    {\n        u=q.de", "Queue()", ";\n        ", "for", "(p=verList", "[", "u", "]", ".head;p!=NULL;p=p->next)\n        {\n            ", "if", "(distance", "[", "p", "->", "end", "]", "==noEdge)\n            {\n                distance", "[", "p", "->", "end", "]", "=distance", "[", "u", "]", "+", "1", ";\n                prev", "[", "p", "->", "end", "]", "=u;\n                q.en", "Queue(", "p", "->", "end", ")", ";\n            }\n        }\n    }\n    ", "//cout<<prev[6]<<endl; ", "\n    print", "Path(", "sNo", ",", "end", "-1,", "prev", ")", ";\n}\ntemplate<", "class", " TypeOfVer,", "class", " TypeOfEdge>\nvoid adjListGraph<TypeOfVer,TypeOfEdge>::print", "Path(", "int", " ", "start", ",", "int", " ", "end", ",", "int", " ", "prev", "[])", "\n{\n    ", "if", "(start==", "end", ")\n    {\n        cout<<verList", "[", "start", "]", ".ver;\n        return;\n    }\n    print", "Path(", "start", ",", "prev", "[", "end", "],", "prev", ")", ";\n    cout<<", "' '", "<<verList", "[", "end", "]", ".ver;\n}\n", "//int **Arr;", "\n", "int", " main", "()", "\n{\n    ", "int", " n;\n    cin>>n;\n    ", "string", " str;\n    getline(cin,str);\n    getline(cin,str);\n    ", "//cout<<str;", "\n    ", "int", " x,y;\n    cin>>x>>y;\n    ", "//cout<<x<<y;", "\n    adjListGraph<", "int", ",", "int", "> ", "A(", "n", ")", ";\n    ", "int", " k=", "0", ";\n    ", "for", "(", "int", " i=", "0", ";i<str.size", "()", ";i++)\n    {\n        ", "if", "(str", "[", "i", "]", "==", "','", ")\n        {\n            k++;\n        }\n    }\n    ", "//cout<<k;", "\n    ", "for", "(", "int", " i=", "0", ";i<k;i++)\n    {\n        ", "int", " t1,t2,u,v;\n        u=", "4", "*i;v=", "4", "*i+", "2", ";\n        t1=str", "[", "u", "]", "-", "'0'", ";\n        t2=str", "[", "v", "]", "-", "'0'", ";\n        ", "//cout<<t1<<\" \"<<t2<<endl;", "\n        ", "A", ".", "insert(t1,t2,", "0", ");\n    }    \n    ", "bool", " flg=", "A", ".", "check", "Route(", "x", ",", "y", ")", ";\n    ", "//cout<<flg;", "\n    ", "if", "(flg)\n    {\n        ", "A", ".", "unweighted", "ShortDistance(", "x", ",", "y", ",-1)", ";\n    }\n    ", "else", "\n    {\n        cout<<", "\"false\"", ";\n    }\n}\n\n", "\n", "这个是自己写的但是没有办法满足“若存在多条长度相同的路径，则输出路径顺序中结点编号较小的路径”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;解决方法&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;把MTGraph G1, G2, G3挪到main函数外&amp;#xff0c;定义为全局变量&lt;/li&gt;&lt;li&gt;动态分配G1, G2, G3的内存&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "有向无环图的最短路径", "Question": ["VS2019 栈溢出：Stack overflow，数组可能定义太大？", ["\n#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n#include<string>\n#include<fstream>\n#include<windows.h>\n#define ", "NumVertices", " ", "405", "\n#define ", "INFINITY", " ", "65535", " //设", "65535", "为无穷大 \nusing namespace std;\ntypedef int ", "EdgeDate", ";\ntypedef int ", "Pathmatrix", "[", "NumVertices", "][", "NumVertices", "];\ntypedef int ", "ShortPathTable", "[", "NumVertices", "][", "NumVertices", "];\n\ntypedef struct\n{\n    char name[", "50", "];//站点名\n    int linenum[", "5", "];//线路对应序列 \n}station;\n\ntypedef struct\n{\n     char linename[", "20", "];//线路名称   \n}linesystem;\n\ntypedef struct \n{\n    linesystem line[", "15", "]; \n    station ", "VerList", "[", "NumVertices", "];//站点信息 \n    ", "EdgeDate", " ", "Edge", "[", "NumVertices", "][", "NumVertices", "];         // 距离边权值 \n    int n,e;        \n}", "MTGraph", ";\n\nvoid ", "SetLine", "(", "MTGraph", " &", "G", ")//初始化站点所在线路对应的序列 \n{\n    ", "/*\n    605路        1\n    615路        2\n    402路        3\n    368外环      4 \n    368内环      5\n    400外环      6\n    400快内环    7\n    973路        8\n    135路        9\n    26路         10\n    300快外环    11\n    94路         12\n    34路         13\n    200外环      14\n    671路        15\n    */", "\n     int i;\n     ", "G", ".", "VerList", "[", "0", "].linenum[", "0", "] = ", "3", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "1", "] = ", "4", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "2", "] = ", "5", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "0", "].linenum[", "4", "] = ", "15", ";\n     ", "G", ".", "VerList", "[", "1", "].linenum[", "0", "] = ", "3", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "1", "] = ", "4", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "2", "] = ", "5", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "1", "].linenum[", "4", "] = ", "3", ";\n     ", "G", ".", "VerList", "[", "2", "].linenum[", "0", "] = ", "4", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "1", "] = ", "5", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "2", "] = ", "8", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "2", "].linenum[", "4", "] = ", "4", ";\n     ", "G", ".", "VerList", "[", "3", "].linenum[", "0", "] = ", "4", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "1", "] = ", "5", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "2", "] = ", "8", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "3", "] = ", "11", "; ", "G", ".", "VerList", "[", "3", "].linenum[", "4", "] = ", "4", ";\n    //", "15", "\n    for(i=", "391", ";i<=", "404", ";i++){\n        ", "G", ".", "VerList", "[i].linenum[", "0", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "1", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "2", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "3", "]=", "15", ";", "G", ".", "VerList", "[i].linenum[", "4", "]=", "15", ";\n    }\n}\n\nvoid ", "Getline", "(", "MTGraph", " &", "G", ") //读入线路 名称 \n{\n      int i=", "0", ";\n      ifstream ifp; \n      ifp.open(", "\"bus_Rname.txt\"", ",ios::in);\n      while(!ifp.eof())                    // 如果未读完，继续读文本      eof end of file\n      {                                  \n          ifp>>", "G", ".line[i].linename;       //\n          i++;\n      } \n      ifp.close();\n}\n\nvoid ", "CreateGraph_2", "(", "MTGraph", "& ", "G", ")//初始化一般时间段 \n{\n    ", "Getline", "(", "G", ");\n    ", "SetLine", "(", "G", ");//读入线路信息     \n    int i;\n    ", "G", ".n = ", "0", ";\n    ", "G", ".e = ", "0", ";\n    int j = ", "0", ";\n    ifstream ifp;\n    ifp.open(", "\"bus_name.txt\"", ", ios::in);\n    while (!ifp.eof())\n    {\n        ++", "G", ".n;\n        ifp >> ", "G", ".", "VerList", "[j].name;//读入站点相关信息 \n        j++;\n    }\n    ifp.close();\n    for (i = ", "0", "; i < ", "G", ".n; i++)\n    {\n        for (j = ", "0", "; j < ", "G", ".n; j++)\n        {\n            ", "G", ".", "Edge", "[i][j] = ", "INFINITY", ";//权值初始化 \n        }\n        ", "G", ".", "Edge", "[i][i] = ", "0", ";\n    }\n    int v1, v2, w;\n    ", "FILE", "* fp2;\n    fp2=fopen(", "\"bus_time.txt\"", ", ", "\"r\"", ");\n    if (", "NULL", " == fp2) printf(", "\"文件打开失败\"", ");\n    else\n    {\n        while (!feof(fp2))\n        {\n            fscanf(fp2, ", "\"%d %d %d\"", ", &v1, &v2, &w);//读入边权值 \n            ", "G", ".", "Edge", "[v1][v2] = w;\n            ", "G", ".", "Edge", "[v2][v1] = w;\n            ++", "G", ".e;\n        }\n        fclose(fp2);\n    }\n}\n\nint ", "Getnum", "(", "MTGraph", "& ", "G", ", char* a)//取得站点对应下标 \n{\n    int i = ", "0", ";\n    while (i < ", "G", ".n)\n    {\n        if (strcmp(", "G", ".", "VerList", "[i].name, a) == ", "0", ")\n        {\n            return i;\n            break;\n        }\n        else\n            i++;\n    }\n    if (i >= ", "G", ".n)\n        return ", "-1", ";\n}\n\n\nvoid ", "ShortestPath", "(", "MTGraph", " &", "G", ",", "Pathmatrix", " ", "P", ",", "ShortPathTable", " ", "D", ")//求最短路径 \n{\n    int trans[", "118", "]; \n    char a[", "20", "],b[", "20", "];\n    int i,j,v,w,k,m,n,p,q,r,t,", "T", ";\n    char s;\n    for(i=", "-1", ";i<", "118", ";i++)\n    {\n        trans[i]=i;//对比是否为换乘 \n    }\n    for(v=", "0", ";v<", "G", ".n;v++)//初始化", "D", "与", "P", " \n    {\n        for(w=", "0", ";w<", "G", ".n;w++)\n        {\n           ", "D", "[v][w]=", "G", ".", "Edge", "[v][w];//", "D", "值为对应权值 \n           ", "P", "[v][w]=w;//初始化", "P", "                  \n        }                  \n    }    \n    for(k=", "0", ";k<", "G", ".n;k++)\n    {\n        for(v=", "0", ";v<", "G", ".n;v++)\n        {\n           for(w=", "0", ";w<", "G", ".n;w++)\n           {\n               if(", "D", "[v][w]>", "D", "[v][k]+", "D", "[k][w])//如果经过下标为k顶点路径比原两点间路径更短，将当前权值设为更小的 \n               {\n                   ", "D", "[v][w]=", "D", "[v][k]+", "D", "[k][w];// \n                   ", "P", "[v][w]=", "P", "[v][k];//路径设置经过下标为k的顶点                           \n               }\n           }\n        }                  \n    }//", "Floyd", "算法求最小路径 \n  while(", "1", ")\n  {\n    cout<<endl<<endl<<endl<<", "\"                               ☆最快路径查询☆\"", "<<endl;\n    cout<<", "\"..............................................................................\"", "<<endl<<endl;      \n    while(", "1", ")\n    {\n        while(", "1", ")\n        {    \n            cout<<", "\"            >>>>>>>>>请输入起点站：\"", ";\n            cin>>a;\n            v=", "Getnum", "(", "G", ",a);\n            if(v==", "-1", ")\n            cout<<", "\"站点不存在请重新输入！\"", "<<endl;\n            else\n            break;\n        }\n        while(", "1", ")\n        {\n            cout<<endl<<", "\"            >>>>>>>>>请输入终点站：\"", ";\n            cin>>b;\n            w=", "Getnum", "(", "G", ",b); \n            if(w==", "-1", ")\n            cout<<", "\"站点不存在请重新输入！\"", "<<endl;\n            else\n            break;\n        }\n        if(v==w)\n        cout<<", "\"请输入两个不同的站点名！\"", "<<endl;\n        else\n        break;\n    }//输入起始点于终点 \n    system(", "\"cls\"", ");\n    \n    p=", "0", ";\n    k=", "P", "[v][w];\n    for(i=", "0", ";i<", "3", ";i++)\n    {\n        for(j=", "0", ";j<", "3", ";j++)\n        {\n            if(", "G", ".", "VerList", "[v].linenum[i]==", "G", ".", "VerList", "[k].linenum[j])\n            {p=", "G", ".", "VerList", "[v].linenum[i];}//确定初始时所在的地铁线路对应序列 \n        }\n    }\n    if(p==", "0", ")\n    {p=", "G", ".", "VerList", "[v].linenum[", "0", "];}//如果不能找到对应序列则取下一结点的序列，仅针对", "13", "号起点终点与机场线起点这种", "3", "线交叉情况 */\n    cout<<endl<<endl<<endl<<", "\"                               ☆最快路径查询☆\"", "<<endl;\n    cout<<", "\"..............................................................................\"", "<<endl<<endl;  \n    cout<<", "\"......................起点在\"", "<<p<<", "\"..........\"", "<<", "G", ".line[p", "-1", "].linename<<", "\"........................\"", "<<endl<<endl;     \n    cout<<", "\"            >>>>>>>>>用时最短路径: \"", "<<endl<<endl<<", "\"            >>>>>>>>> ->在 \"", "<<", "G", ".", "VerList", "[v].name<<", "\" 乘 \"", "<<", "G", ".line[p", "-1", "].linename<<", "\" (\"", "<<", "G", ".", "VerList", "[k].name<<", "\"方向)\"", "<<endl;\n    m=v;//设m为k在最短路径中的直接前驱 \n    r=v; \n    ", "T", "=", "3", ";\n    while(k!=w)\n    {\n        q=", "-1", ";\n        while(k!=trans[q]&&k<", "118", ")\n        { \n            q++;\n            if(k==trans[q])//如果k满足是可换乘节点 \n            {\n                n=", "P", "[k][w];//设m为k在最短路径中的直接后继  \n                p=t=", "-1", ";\n                for(i=", "0", ";i<", "5", ";i++)\n                {\n                   for(j=", "0", ";j<", "5", ";j++)\n                   {\n                       if(", "G", ".", "VerList", "[m].linenum[i]==", "G", ".", "VerList", "[k].linenum[j])\n                       {p=", "G", ".", "VerList", "[m].linenum[i];} \n                   }\n                }\n                if(p==", "-1", ")\n                p=", "G", ".", "VerList", "[m].linenum[", "0", "];\n                \n                for(i=", "0", ";i<", "5", ";i++)\n                {\n                   for(j=", "0", ";j<", "5", ";j++)\n                   {\n                       if(", "G", ".", "VerList", "[k].linenum[i]==", "G", ".", "VerList", "[n].linenum[j])\n                       {t=", "G", ".", "VerList", "[k].linenum[i];}\n                   }\n                }\n                if(t==", "-1", ")\n                {\n                    ", "/*if(k==9||k==12)\n                    t=9;\n                    else if(k==23)\n                    t=13;\n                    else */", "\n                    t=", "G", ".", "VerList", "[n].linenum[", "1", "];\n                }\n                if(p!=t)//若k前后两线路序列号不同则换乘 \n                {       \n                    int a=", "D", "[r][k];\n                    double b=a/", "1000", ";        \n                    cout<<", "\"            >>>>>>>>> ->距离为\"", "<<", "D", "[r][k]<<", "\"米，用时约\"", "<<b<<", "\"分钟 至：\"", "<<", "G", ".", "VerList", "[k].name<<", "\" 换乘 \"", "<<", "G", ".line[t", "-1", "].linename<<", "\" (\"", "<<", "G", ".", "VerList", "[n].name<<", "\"方向)\"", "<<endl;//若路径点为换乘点则打印 \n                    r=k;//设定r结点用于求分段时间 \n                    ", "T", "+=", "5", ";\n                } \n            }\n        }\n        \n     m=", "P", "[m][w];//m后移   \n     k=", "P", "[k][w];//k后移             \n    } \n    int c=", "D", "[r][w];\n    int f=", "D", "[v][w];\n    int value;\n    double d=c/", "1000", ";\n    double e=f/", "1000", ";\n    if(", "D", "[v][w]<", "6000", ")\n        value=", "3", ";\n    else if(", "6000", "<", "D", "[v][w]&&", "D", "[v][w]<", "12000", ")\n        value=", "4", ";\n    else if(", "12000", "<", "D", "[v][w]&&", "D", "[v][w]<", "22000", ")\n        value=", "5", ";\n    else if(", "22000", "<", "D", "[v][w]&&", "D", "[v][w]<", "32000", ")\n        value=", "6", ";\n    else if(", "52000", "<", "D", "[v][w]&&", "D", "[v][w]<", "72000", ")\n        value=", "7", ";    \n    else if(", "72000", "<", "D", "[v][w]&&", "D", "[v][w]<", "92000", ")\n        value=", "8", ";    \n    cout<<", "\"            >>>>>>>>> ->距离为\"", "<<", "D", "[r][w]<<", "\"米，用时约\"", "<<d<<", "\"分钟，到达终点：\"", "<<", "G", ".", "VerList", "[w].name<<endl;\n    cout<<endl<<", "\"            >>>>>>>>>总里程为\"", "<<", "D", "[v][w]<<", "\"米，考虑换乘以及等车一共约用时为：\"", "<<e+", "T", "<<", "\"分钟,票价为\"", "<<value<<", "\"元！！！！\"", "<<endl<<endl<<endl<<endl<<endl<<endl;\n    cout<<", "\"            >>>>>>>>>是否继续查询？（Y/N）\"", ";\n    scanf(", "\"%s\"", ",&s);\n    if(s!=", "'y'", "&&s!=", "'Y'", ")\n    break;\n    else\n    system(", "\"cls\"", ");\n    }                \n}\n\nint main()\n{\n    ", "MTGraph", " ", "G1", ",", "G2", ",", "G3", ";\n    char a,d;\n    int c; \n    char b[", "10", "];\n\n\n     scanf(", "\"%s\"", ",&d);\n     system(", "\"cls\"", ");\n               if(d==", "'2'", ")\n              { \n                      ", "CreateGraph_2", "(", "G2", ");\n                      ", "Pathmatrix", " ", "P", ";\n                      ", "ShortPathTable", " ", "D", ";\n                      ", "ShortestPath", "(", "G2", ",", "P", ",", "D", ");\n                      printf(", "\"\\n\"", ");\n                      printf(", "\"请按Enter键返回上一级菜单\"", ");\n                      ", "_getch", "();\n                      system(", "\"cls\"", ");\n                      \n              }           \nreturn ", "0", ";\n}\n", "\n", "初始定义了一个结构体中的数组，大小为405，在dev上能够正常运行，但在VS2019上则出现异常。", "\n"]], "Tag": "算法设计"}
