{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;Dijkstra算法伪代码 \n\nfor each node v    \n    dis(v) ← &amp;#43;∞    \n    previous (v) ← undefined    \n    dis(source) ← 0    \n    while num(S) &amp;lt; n    ▷ S为顶点集合\n        u ← node with smallest distance    \n        Remove u    \n        for each node v in S    \n            alt ← dis(u) &amp;#43; dis(u,v)    \n            if alt &amp;lt; dis(v) then    \n                dis(v) ← alt    ▷ 更新距离\n                previous(v) ← u    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以参考这篇博客&amp;#xff08;含MATLAB代码&amp;#xff09;&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/lishan132/article/details/108527271\" id=\"textarea_1650988419256_1650988630188_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/lishan132/article/details/108527271&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;这篇里面有讲解&amp;#xff08;有示例讲解&amp;#xff09;&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/L_J_Kin/article/details/103061420\" id=\"textarea_1650988419256_1650988630188_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/L_J_Kin/article/details/103061420&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["Matlab 最短路径 起始点出发，回到起始点，经过所有点", ["利用matlab图论知识求解，从起始点出发，经过其他所有点，然后返回起始点，求最短路径"]], "Tag": "算法设计"}
{"Answer": "TSP问题本质和城市间最短路径寻优问题一样，都是求两个点的最优路径，这种问题你要把这些实际数据想成是图的操作\r\nhttp://www.cnblogs.com/biaoyu/archive/2012/09/26/2704456.html", "Konwledge_Point": "最短路径", "Question": ["蚁群算法 寻找最短路径的问题", ["想搞个城市间最短路径寻优，网上全都是tsp问题，我只想要起点到终点的最优路径，不需要返回，该怎么写。。。能不能给点代码……"]], "Tag": "算法设计"}
{"Answer": "已找到，使用图网络模型可以实现。", "Konwledge_Point": "最短路径", "Question": ["神经网络能否不失一般性地解图的最短路径问题？", ["\n\n", "解最短路径问题，我看了一些网上的例子，多是训练DQN能够在某一特定图中找到最短路径（如图，在这个特定图中学习如何绕过黑点到达黄点）", "\n\n", "这种训练，相当于特定图的拓扑存储在了Q Matrix中，当图（环境）改变时则需要重新训练。", "\n问题：请问神经网络能否不失一般性地解图的最短路径问题？也就是不依赖某种特定的图拓扑，每次输入图拓扑和起点终点，输出最优路径"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#define INF 1000000; 这里的分号去掉&lt;br /&gt;输入3 2&amp;#xff0c;中间不能带逗号&amp;#xff0c; 因为你是scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;m);&amp;#xff0c;两个%d之间没有逗号&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["迪杰斯特拉求任意一点的最短路径问题遇到错误情况无法实现", ["代码运行结果不对怎么直接就输出结果了，还有通过visit数组来判断是否经过那个点不知道正不正确", "\n", "#include<stdio.h>", "#define SIZE 110", "#define INF 1000000;", "int map[SIZE][SIZE];  //邻接矩阵存储", "int len[SIZE];      //d[i]表示源点到i这个点的距离", "int visit[SIZE];  //节点是否被访问", "int n,m,j,pos,ans,temp;", " int temp = INF;", "\n", "int dijkstra(int from, int to){    //从源点到目标点", "    int i;", "    for(i = 1 ; i <= n ; i ++){    //初始化", "        visit[i] = 0;    //一开始每个点都没被访问", "        len[i] = map[from][i];    //先假设源点到其他点的距离", "    }  ", "\n", "for", "(i = ", "1", " ; i < n ; ++i){    ", "//对除源点的每一个点进行最短计算 ", "\n    ", "int", " min = INF;  ", "//记录最小len[i] ", "\n      ", "//记录小len[i] 的点 ", "\n    ", "for", "(j = ", "1", " ; j <= n ; ++j){    \n        ", "if", "(!visit[j] && min > ", "len", "[j]){  \n            pos = j;  \n            min = ", "len", "[j];  \n        }  \n    }  \n    visit[pos] = ", "1", ";  \n    ", "for", "(j = ", "1", " ; j <= n ; ++j){\n        ", "if", "(!visit[j] && (", "len", "[j] > (", "len", "[pos] +", "map", "[pos][j]))){ ", "//如果j节点没有被访问过&&j节点到源节点的最短路径>pos节点到源节点的最短路径+pos节点到j节点的路径  ", "\n            ", "len", "[j] = ", "len", "[pos] + ", "map", "[pos][j];    ", "//更新j节点到源节点的最短路径    ", "\n        }  \n    }  \n}  \n", "return", " ", "len", "[to];\n", "\n", "}", "\n", "int main ()", "{  ", "\n", "int", " i,j;  \n\n", "int", " ans,u,v;\n\n", "printf", "(", "\"输入顶点和边数\"", ");\n", "scanf", "(", "\"%d%d\"", ",&n,&m);    ", "//输入数据", "\n\n\n", "for", "(i = ", "1", " ; i <= n ; ++i){    ", "//设一开始每个点都不可达 ", "\n    ", "for", "(j = ", "1", " ; j <= n ; ++j){  \n        map[i][j] = INF;  \n    }  \n}  \n\n", "int", " a,b,c;    ", "//输入数据 ", "\n", "for", "(i = ", "1", " ; i <= m ; ++i){  \n    ", "scanf", "(", "\"%d%d%d\"", ",&a,&b,&c);  \n    map[a][b] = map[b][a] = c;  \n}  \n", "\n", "   printf(\"输入起点和终点：\");", "   scanf(\"%d,%d\",&u,&v);", "\n", "ans=dijkstra(u,v);\n", "for", "(i=", "0", ";i<=n;i++)//输出途径点 \n{\n    ", "if", "(visit[i]==", "1", ")\n    {\n        ", "printf", "(", "\"%d\"", ",i);\n    }\n}\n", "printf", "(", "\"%d\"", ",ans);  \n\n", "return", " ", "0", ";  \n", "\n", "} ", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;上方图中共10个点&amp;#xff0c;确定了起点&amp;#xff0c;相当于9个点的全排列&amp;#xff0c;可以非递归实现&amp;#xff0c;也可以递归实现。&lt;br /&gt;共有9的阶乘&amp;#xff1a;362880种走法&amp;#xff0c;分别计算每一种路径的总距离&amp;#xff0c;取最小的。运行截图如下&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/441053271136188.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;并结合了matplotlib和 pyecharts 可视化出了最短路径分别如下图&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/539693271136124.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/109224271136120.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;源码见&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_40985985/article/details/120199441\" id=\"textarea_1631358369087_1631358407996_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Python访问街区所有节点最短路径问题&amp;#xff0c;并结合matplotlib可视化_程序媛一枚~的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;这篇博客将介绍如何全排列街区的点&amp;#xff0c;即规定起点不重复的走完所有街区&amp;#xff0c;并找出最短路径&amp;#xff0c;并结合matplotlib、pyecharts对最短路径进行可视化。&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_40985985/article/details/120199441&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;回答不易&amp;#xff0c;有帮助麻烦点下采纳哦&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["访问所有节点的最短路径问题，节点只能访问一次，python实现。", ["已知起点（310,385），访问所有节点，节点只能访问一次，不用返回起点。求最短路径，python实现，CVXPY 最好。思路和代码请详细说明，以便我学习。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个是最短路径计算&amp;#xff0c;运费应该两个地点之间经过节点数计算&amp;#xff0c;比如a到c&amp;#xff0c;&amp;#xff0c;经过5个节点&amp;#xff0c;每个节点收费5元&amp;#xff0c;运费就25元。你的要求包括了好几种最短路径算法&amp;#xff0c;具体可以参考&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/printfxgd/article/details/80791847\" id=\"textarea_1637156922423_1637157011619_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/printfxgd/article/details/80791847&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["城市交通查询系统设计", ["题目3: 城市交通查询系统设计内容：设计一个交通查询系统，能够查询：1)从一个城市到其它各城市之间的最短路径或运费最少的路径;2）多个城市中任意一对城市之间的最短路径或运费最少的路径。设计要求：（1）建立关于城市信息结点的结构体；（2）定义城市信息链表的结点结构；（3）建立交通网络图的存储结构；（4）写出采用Dijksta算法求每对顶点之间最短路径的算法函数；  （5）写出采用Floyed算法求任意一对顶点之间最短路径的算法函数；（6）输入交通网络图中的路径信息或费用信息；（7）根据Dijksta算法计算从太原到其它各大城市的最短路径或最小费用；（8）根据Floyed算法计算任意一对大城市之间的最短路径或最小费用；（9）对于不同的查询要求可以输入已知城市间的路程或所需费用信息。"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/ShiWaiGaoRen12345/article/details/69808597", "Konwledge_Point": "最短路径", "Question": ["最短路径的数据结构的问题，C语言的问题，具体怎么解决的思路的问题", ["Problem Description", "\nThere are n points on the plane, Pi(xi, yi)(1 <= i <= n), and xi < xj (i\nBefore you reach the rightmost point Pn, you can only visit the points those have the bigger x-coordinate value. For example, you are at Pi now, then you can only visit Pj(j > i). When you reach Pn, the rule is changed, from now on you can only visit the points those have the smaller x-coordinate value than the point you are in now, for example, you are at Pi now, then you can only visit Pj(j < i). And in the end you back to P1 and the tour is over.", "\nYou should visit all points in this tour and you can visit every point only once.", "\n\n", "Input", "\nThe input consists of multiple test cases. Each case begins with a line containing a positive integer n(2 <= n <= 200), means the number of points. Then following n lines each containing two positive integers Pi(xi, yi), indicating the coordinate of the i-th point in the plane.", "\n\n", "Output", "\nFor each test case, output one line containing the shortest path to visit all the points with the rule mentioned above.The answer should accurate up to 2 decimal places.", "\n\n", "Sample Input", "\n3", "\n1 1", "\n2 3", "\n3 1", "\n\n", "Sample Output", "\n6.47"]], "Tag": "算法设计"}
{"Answer": "这个图有点特殊，每个节点都是关键节点，多条关键路径，因此每个节点的最早开始时间和最晚开始时间都是一样的。我认为是对的。", "Konwledge_Point": "最短路径", "Question": ["最短路径中最早开始时间和最晚开始时间，写的对吗", []], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;OP&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; next[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;], num &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//  记入它接下来抵达的地方,num 为个数&lt;/span&gt;\n}op[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;];                    &lt;span class=\"hljs-comment\"&gt;//  表示点个数,0为出发地,10000为目的地&lt;/span&gt;\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; f[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;],key[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;],k_len&amp;#61;&lt;span class=\"hljs-number\"&gt;50000&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;find_MinRoad&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; now,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num)&lt;/span&gt;&lt;/span&gt;{  &lt;span class=\"hljs-comment\"&gt;// 当前位置,当前走的步数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(now&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(num&amp;lt;k_len) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(k_len&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k_len&amp;lt;num;k_len&amp;#43;&amp;#43;) key[k_len] &amp;#61; f[k_len];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(now!&amp;#61;&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;op[now].num;z&amp;#43;&amp;#43;) {\n            f[num] &amp;#61; op[now].next[z];\n            &lt;span class=\"hljs-built_in\"&gt;find_MinRoad&lt;/span&gt;(op[now].next[z],num&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        }\n    }\n\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; road,a,b;                      &lt;span class=\"hljs-comment\"&gt;//  road : 输入中间路的总个数&amp;#xff0c;你的图为13,如果更多点把int 换成long op那的数组也再开大点&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;road);\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (road--){\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b); &lt;span class=\"hljs-comment\"&gt;// a-&amp;gt;b&lt;/span&gt;\n        op[a].next[op[a].num&amp;#43;&amp;#43;] &amp;#61; b;\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;find_MinRoad&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,k_len&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;k_len;z&amp;#43;&amp;#43;) &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,key[z]);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）", ["对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）（C语言）"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/u014569598/article/details/25472851", "Konwledge_Point": "最短路径", "Question": ["Risk(Floyd)               ", ["Risk is a board game in which several opposing players attempt to conquer the world. The gameboard consists of a world map broken up into hypothetical countries. During a player's turn, armies stationed in one country are only allowed to attack only countries with which they share a common border. Upon conquest of that country, the armies may move into the newly conquered country.", "\nDuring the course of play, a player often engages in a sequence of conquests with the goal of transferring a large mass of armies from some starting country to a destination country. Typically, one chooses the intervening countries so as to minimize the total number of countries that need to be conquered. Given a description of the gameboard with 20 countries each with between 1 and 19 connections to other countries, your task is to write a function that takes a starting country and a destination country and computes the minimum number of countries that must be conquered to reach the destination. You do not need to output the sequence of countries, just the number of countries to be conquered including the destination. For example, if starting and destination countries are neighbors, then your program should return one.", "\n\n", "The following connection diagram illustrates the sample input.", "\n\n", "Input", "\n\n", "Input to your program will consist of a series of country configuration test sets. Each test set will consist of a board description on lines 1 through 19. The representation avoids listing every national boundary twice by only listing the fact that country I borders country J when I < J. Thus, the Ith line, where I is less than 20, contains an integer X indicating how many \"higher-numbered\" countries share borders with country I, then X distinct integers J greater than I and not exceeding 20, each describing a boundary between countries I and J. Line 20 of the test set contains a single integer (1 <= N <= 100) indicating the number of country pairs that follow. The next N lines each contain exactly two integers (1 <= A,B <= 20; A!=B) indicating the starting and ending countries for a possible conquest.", "\n\n", "There can be multiple test sets in the input; your program should continue reading and processing until reaching the end of file. There will be at least one path between any two given countries in every country configuration.", "\n\n", "Output", "\n\n", "For each input set, your program should print the following message \"Test Set #T\" where T is the number of the test set starting with 1. The next NT lines each will contain the result for the corresponding test in the test set - that is, the minimum number of countries to conquer. The test result line should contain the start country code A the string \" to \" the destination country code B ; the string \": \" and a single integer indicating the minimum number of moves required to traverse from country A to country B in the test set. Following all result lines of each input set, your program should print a single blank line.", "\n\n", "Sample Input", "\n\n", "1 3 ", "\n2 3 4 ", "\n3 4 5 6 ", "\n1 6 ", "\n1 7 ", "\n2 12 13 ", "\n1 8 ", "\n2 9 10 ", "\n1 11 ", "\n1 11 ", "\n2 12 17 ", "\n1 14 ", "\n2 14 15 ", "\n2 15 16 ", "\n1 16 ", "\n1 19 ", "\n2 18 19 ", "\n1 20 ", "\n1 20 ", "\n5 ", "\n1 20 ", "\n2 9 ", "\n19 5 ", "\n18 19 ", "\n16 20", "\n\n", "Sample Output", "\n\n", "Test Set #1 ", "\n1 to 20: 7 ", "\n2 to 9: 5 ", "\n19 to 5: 6 ", "\n18 to 19: 2 ", "\n16 to 20: 2 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;根据要求&amp;#xff0c;大体的功能已实现&amp;#xff0c;代码如下。&lt;br /&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n\n#define THRESHOLD   &lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//用户基本信息&lt;/span&gt;\ntypedef struct _userInfo {\n    int id;         &lt;span class=\"hljs-comment\"&gt;//学号&lt;/span&gt;\n    char &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];  &lt;span class=\"hljs-comment\"&gt;//姓名&lt;/span&gt;\n    char gender[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//性别&lt;/span&gt;\n    int age;        &lt;span class=\"hljs-comment\"&gt;//年龄&lt;/span&gt;\n    int step;       &lt;span class=\"hljs-comment\"&gt;//行走步数&lt;/span&gt;\n    struct _userInfo *next;\n} UsrInfo;\n&lt;span class=\"hljs-comment\"&gt;//好友关系以及熟悉程度&lt;/span&gt;\ntypedef struct _relation {\n    int id1;        &lt;span class=\"hljs-comment\"&gt;//用户1学号&lt;/span&gt;\n    int id2;        &lt;span class=\"hljs-comment\"&gt;//用户2学号&lt;/span&gt;\n    int familiar;   &lt;span class=\"hljs-comment\"&gt;//好友熟悉程度&lt;/span&gt;\n    struct _relation *next;\n} Relation;\n&lt;span class=\"hljs-comment\"&gt;//接收信息缓冲区&lt;/span&gt;\ntypedef struct _buffer {\n    int id;                 &lt;span class=\"hljs-comment\"&gt;//用户学号&lt;/span&gt;\n    char msg[THRESHOLD];    &lt;span class=\"hljs-comment\"&gt;//接收信息缓冲区&lt;/span&gt;\n    int len;                &lt;span class=\"hljs-comment\"&gt;//累积的信息长度&lt;/span&gt;\n    struct _buffer *next;\n} Buffer;\n&lt;span class=\"hljs-comment\"&gt;//用户信息节点&amp;#xff08;如果改成这种结构可能更好一些&amp;#xff0c;同一用户的信息全部在一个结构体&amp;#xff0c;统一一个链表管理&amp;#xff09;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//typedef struct _node {&lt;!-- --&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    UsrInfo usrInfo;    //用户基本信息&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    Relation relation;  //好友关系以及熟悉程度&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    Buffer buffer;      //接收信息缓冲区&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    struct _node *next;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//} UsrNode;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//UsrNode *head &amp;#61; NULL;   //用户信息链表头节点&lt;/span&gt;\nUsrInfo *lst &amp;#61; NULL; &lt;span class=\"hljs-comment\"&gt;//用户基本信息链表头节点&lt;/span&gt;\nRelation *rel &amp;#61; NULL; &lt;span class=\"hljs-comment\"&gt;//用户好友关系以及熟悉程度信息链表头节点&lt;/span&gt;\nBuffer *buf &amp;#61; NULL; &lt;span class=\"hljs-comment\"&gt;//用户接收信息缓冲区链表头节点&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//添加用户&lt;/span&gt;\nint addUsr(UsrInfo *lst, int id, char *&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, char *gender, int age, int step)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL) {\n        return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    UsrInfo *p &amp;#61; lst;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id) { &lt;span class=\"hljs-comment\"&gt;//查找到有这个id的用户&lt;/span&gt;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加用户失败&amp;#xff0c;id&amp;#61;%d的用户已存在&amp;#xff01;&amp;#34;&lt;/span&gt;, id);\n            return -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL) {\n            UsrInfo *node &amp;#61; (UsrInfo *)malloc(sizeof(UsrInfo));\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id &amp;#61; id;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(node-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(node-&amp;gt;&lt;/span&gt;gender, gender);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;age &amp;#61; age;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;step &amp;#61; step;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; node;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//同步生成接收信息缓冲区节点&lt;/span&gt;\n    Buffer *p2 &amp;#61; buf;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p2) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id) { &lt;span class=\"hljs-comment\"&gt;//查找到有这个id的用户&lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//直接清空就可以&lt;/span&gt;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL) {\n            Buffer *node &amp;#61; (Buffer *)malloc(sizeof(Buffer));\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id &amp;#61; id;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; node;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt; &amp;#61; p2-&amp;gt;&lt;/span&gt;next;\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//添加好友&lt;/span&gt;\nint addFriend(Relation *rel, int id1, int id2, int familiar)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(rel &amp;#61;&amp;#61; NULL) {\n        return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    int flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    UsrInfo *p &amp;#61; lst;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//查找用户是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id1) {\n            flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id2) {\n            flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag1 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        return -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//id1用户不存在&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag2 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        return -&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//id2用户不存在&lt;/span&gt;\n    }\n    Relation *q &amp;#61; rel;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(q) { &lt;span class=\"hljs-comment\"&gt;//查找好友关系是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;((q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id1 &amp;amp;&amp;amp; q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id2&lt;/span&gt; &amp;#61;&amp;#61; id2) || (q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id2 || q-&amp;gt;&lt;/span&gt;id2 &amp;#61;&amp;#61; id1)) {\n            return -&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(q-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL) {\n            Relation *node &amp;#61; (Relation *)malloc(sizeof(Relation));\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id1 &amp;#61; id1;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id2 &amp;#61; id2;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;familiar &amp;#61; familiar;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; node;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;next;\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//从高到低打印用户行走步数的排行榜&lt;/span&gt;\nvoid printSteps(UsrInfo *lst)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL) {\n        return;\n    }\n    int n &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n\\n&amp;#34;&lt;/span&gt;);\n    U&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;srInfo&lt;/span&gt; *p &amp;#61; lst-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//遍历链表&amp;#xff0c;统计用户个数&lt;/span&gt;\n        n&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;行走步数排行榜为空&amp;#xff0c;当前没有用户&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        char &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[n][&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;], s[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n        int step[n];\n        int m &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, t;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; lst-&amp;gt;&lt;/span&gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//遍历链表&amp;#xff0c;取出用户姓名和行走步数&lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[m], p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;step&lt;/span&gt;[m] &amp;#61; p-&amp;gt;&lt;/span&gt;step;\n            m&amp;#43;&amp;#43;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) { &lt;span class=\"hljs-comment\"&gt;//冒泡排序&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;-i; j&amp;#43;&amp;#43;) {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(step[j] &amp;lt; step[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) {\n                    t &amp;#61; step[j];\n                    step[j] &amp;#61; step[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                    step[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t;\n                    strcpy(s, &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j]);\n                    strcpy(&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j], &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n                    strcpy(&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], s);\n                }\n            }\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;行走步数排行榜\\n\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;排名\\t姓名\\t行走步数\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;) {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t%s\\t%d\\n&amp;#34;&lt;/span&gt;, i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[i], step[i]);\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;//发送消息&lt;/span&gt;\nvoid sendMsg(UsrInfo *lst, Relation *rel, Buffer *buf, int id1, int id2, char *msg)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL || rel &amp;#61;&amp;#61; NULL || buf &amp;#61;&amp;#61; NULL) {\n        return;\n    }\n    int flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    UsrInfo *p &amp;#61; lst;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//查找用户是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id1) {\n            flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id2) {\n            flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag1 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送消息失败&amp;#xff0c;id1&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1);\n        return;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag2 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送消息失败&amp;#xff0c;id2&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id2);\n        return;\n    }\n    Relation *q &amp;#61; rel;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(q) { &lt;span class=\"hljs-comment\"&gt;//查找好友关系是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;((q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id1 &amp;amp;&amp;amp; q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id2&lt;/span&gt; &amp;#61;&amp;#61; id2) || (q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id2 || q-&amp;gt;&lt;/span&gt;id2 &amp;#61;&amp;#61; id1)) {\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(q &amp;#61;&amp;#61; NULL) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送消息失败&amp;#xff0c;id1&amp;#61;%d和id2&amp;#61;%d不是好友关系&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1, id2);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        Buffer *p2 &amp;#61; buf;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p2) { &lt;span class=\"hljs-comment\"&gt;//查找用户是否存在&lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id2) {\n                int msgLen &amp;#61; strlen(msg); &lt;span class=\"hljs-comment\"&gt;//信息长度&lt;/span&gt;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;len &amp;#43; msgLen &amp;gt; THRESHOLD) { &lt;span class=\"hljs-comment\"&gt;//缓冲区中积累的信息长度超过THRESHOLD&amp;#61;32个字符&lt;/span&gt;\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;接收信息缓冲区的内容&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(int i&amp;#61;0; i&amp;lt;p2-&amp;gt;&lt;/span&gt;len; i&amp;#43;&amp;#43;) {\n                        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%c&amp;#34;, p2-&amp;gt;&lt;/span&gt;msg[i]);\n                    }\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, msg);\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                }\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;msg&lt;/span&gt; &amp;#43; p2-&amp;gt;&lt;/span&gt;len, msg);\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#43;&amp;#61; msgLen;\n                }\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;id1&amp;#61;%d向id2&amp;#61;%d发送信息成功&amp;#xff0c;id2&amp;#61;%d用户接收信息缓冲区的信息长度为%d\\n&amp;#34;, id1, id2, id2, p2-&amp;gt;&lt;/span&gt;len);\n                break;\n            }\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt; &amp;#61; p2-&amp;gt;&lt;/span&gt;next;\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//打印当前所有用户基本信息&lt;/span&gt;\nvoid printAllUsrInfo(UsrInfo *lst)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL) {\n        return;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n\\n&amp;#34;&lt;/span&gt;);\n    U&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;srInfo&lt;/span&gt; *p &amp;#61; lst-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;id:     %d\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;id);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;:   %s\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;gender: %s\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;gender);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;age:    %d\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;age);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;step:   %d\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;step);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;//计算各用户间的最短距离和最短路径&amp;#xff08;这个不好写&amp;#xff09;&lt;/span&gt;\n\nint main()\n{\n    int ret, select, running &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    lst &amp;#61; (UsrInfo *)malloc(sizeof(UsrInfo)); &lt;span class=\"hljs-comment\"&gt;//用户基本信息链表头节点&lt;/span&gt;\n    rel &amp;#61; (Relation *)malloc(sizeof(Relation)); &lt;span class=\"hljs-comment\"&gt;//用户好友关系以及熟悉程度信息链表头节点&lt;/span&gt;\n    buf &amp;#61; (Buffer *)malloc(sizeof(Buffer)); &lt;span class=\"hljs-comment\"&gt;//用户接收信息缓冲区链表头节点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(running &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;1 添加用户\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;2 添加好友\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;3 发送消息\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;4 打印行走步数的排行榜\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;5 打印当前所有用户基本信息\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;0 退出\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;Select &amp;gt; &amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;select);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n        switch (select) {\n        case &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        {\n            UsrInfo usrInfo;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;usrInfo.id);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, usrInfo.&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;性别&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, usrInfo.gender);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;年龄&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;usrInfo.age);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;行走步数&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;usrInfo.step);\n            ret &amp;#61; addUsr(lst, usrInfo.id, usrInfo.&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, usrInfo.gender, usrInfo.age, usrInfo.step);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加id&amp;#61;%d的用户成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, usrInfo.id);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加用户失败&amp;#xff0c;id&amp;#61;%d的用户已存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, usrInfo.id);\n            }\n            break;\n        }\n        case &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n        {\n            int id1, id2, familiar;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;用户1学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id1);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;用户2学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id2);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;熟悉程度&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;familiar);\n            ret &amp;#61; addFriend(rel, id1, id2, familiar);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友失败&amp;#xff0c;id1&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友失败&amp;#xff0c;id2&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id2);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友失败&amp;#xff0c;id1&amp;#61;%d和id2&amp;#61;%d已经是好友关系&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1, id2);\n            }\n            break;\n        }\n        case &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n        {\n            int id1, id2;\n            char msg[&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送方用户学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id1);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;接收方用户学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id2);\n            getchar();\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送的信息&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            gets(msg);\n            sendMsg(lst, rel, buf, id1, id2, msg);\n            break;\n        }\n        case &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n            printSteps(lst);\n            break;\n        case &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;:\n            printAllUsrInfo(lst);\n            break;\n        case &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            running &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            break;\n        default:\n            break;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(running &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;//释放链表内存空间&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst) {\n        UsrInfo *p &amp;#61; lst;\n        UsrInfo *q &amp;#61; p;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n            free(p);\n            p &amp;#61; q;\n        }\n        lst &amp;#61; NULL;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(rel) {\n        Relation *p &amp;#61; rel;\n        Relation *q &amp;#61; p;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n            free(p);\n            p &amp;#61; q;\n        }\n        rel &amp;#61; NULL;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(buf) {\n        Buffer *p &amp;#61; buf;\n        Buffer *q &amp;#61; p;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n            free(p);\n            p &amp;#61; q;\n        }\n        buf &amp;#61; NULL;\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["数据结构题，比较急迫，c语言编写", ["设计一个好友通信模拟软件，提供用户管理、好友管理、消息发送、运动健康等功能，具体需求如下：", "选择合适的数据结构（逻辑结构和物理结构）维护用户基本信息列表（即UsrInfo，包括学号id、姓名name、性别gender、年龄age、行走步数step）。（10分）", "选择合适的数据结构（逻辑结构和物理结构）维护用户间的好友关系以及熟悉程度（即Relation）。（10分）", "选择合适的数据结构（逻辑结构和物理结构）维护每个用户的接收信息缓冲区（即Buffer）。（10分）", "实现int addUsr(UsrInfo* lst, int id, char* name, char* gender, int age, int step)函数，向lst中新增用户并初始化基本信息，返回是否新增成功。（12分=算法设计与分析3分+算法实现9分）", "实现int addFriend(Relation* rel, int id1, int id2, int familiar)函数，向rel中新增id1和id2两个用户之间的好友关系；familiar为两用户间的熟悉程度（值越小表示熟悉程度越高），返回是否构建成功。（12分=算法设计与分析3分+算法实现9分）", "实现void printSteps(UsrInfo* lst)函数，从高到低打印用户行走步数的排行榜，包括姓名和步数。（12分=算法设计与分析3分+算法实现9分）", "实现void sendMsg(UsrInfo* lst, Relation* rel, Buffer* buf, int id1, int id2, char* msg)函数，如果id1和id2两个用户是好友，则把msg送入id2的接收信息缓冲区；如果id1和id2两个用户不是好友，则丢弃信息；若该缓冲区中积累的信息长度超过THRESHOLD=32个字符，则按接收先后顺序打印缓冲区中的信息，然后清空缓冲区。（16分=算法设计与分析4分+算法实现12分）", "实现int main()函数，通过调用addUsr、addFriend函数构建如图1所示的用户基本信息和好友关系；通过调用printSteps函数打印行走步数排行榜；通过调用sendMsg函数模拟信息发送过程。（8分）", "根据构建完成的好友关系，手动计算各用户间的最短距离和最短路径。（10分）"]], "Tag": "算法设计"}
{"Answer": "设open中有x,y两个点，全局最优路径中有x-&gt;y，等效证明x在y点前被取出：g(x)+h(x)&lt;=g(x)+h*(x)&lt;=g*(y)&lt;=g(y)&lt;=g(y)+h(y)", "Konwledge_Point": "最短路径", "Question": ["A*算法大牛进，高分。", ["1.如果h(n)经常都比从n移动到目标的实际代价小（或者相等），则A*保证能找到一条最短路径。h(n)越小，A*扩展的结点越多，运行就得越慢。", "\n2.如果h(n)有时比从n移动到目标的实际代价高，则A*不能保证找到一条最短路径，但它运行得更快。", "\n为什么？？？？？？？？？？？？？？？？？？？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;不同于网上找到的答案的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;assert.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n\ntypedef struct &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;\n{\n    int x;\n    int y;\n    int len;\n} QDataType; &lt;span class=\"hljs-comment\"&gt;//数据类型&lt;/span&gt;\n\ntypedef struct ListNode &lt;span class=\"hljs-comment\"&gt;//通过链表实现的&lt;/span&gt;\n{\n    QDataType _&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n    struct ListNode *_pNext;\n} ListNode, *pListNode;\n\ntypedef struct Queue\n{\n    pListNode _pHead; &lt;span class=\"hljs-comment\"&gt;//头指针&lt;/span&gt;\n    pListNode _pTail; &lt;span class=\"hljs-comment\"&gt;//尾指针&lt;/span&gt;\n} Queue;\n\npListNode BuyNode(QDataType d)\n{\n    pListNode new &amp;#61; malloc(sizeof(ListNode));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;new&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; d;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;new&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext &amp;#61; NULL;\n    return new;\n}\n\nvoid QueueInit(Queue *q)\n{\n    assert(q);\n    QDataType d;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pHead &amp;#61; BuyNode(d);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pTail&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;_pHead;\n}\n\nvoid QueuePush(Queue *q, QDataType d)\n{\n    assert(q);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pTail&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext &amp;#61; BuyNode(d);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pTail&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pTail&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext;\n}\n\nvoid QueuePop(Queue *q)\n{\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pListNode&lt;/span&gt; dNode &amp;#61; q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pHead&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (dNode)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pHead&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pNext&lt;/span&gt; &amp;#61; dNode-&amp;gt;&lt;/span&gt;_pNext;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pHead&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext &amp;#61;&amp;#61; NULL)\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pTail&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;_pHead;\n        } &lt;span class=\"hljs-comment\"&gt;//如果只有一个元素&amp;#xff0c;删完后ptail会悬空&lt;/span&gt;\n        free(dNode);\n    }\n}\n\nint QueueSize(Queue *q)\n{\n    assert(q);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pListNode&lt;/span&gt; pre &amp;#61; q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pHead&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext;\n    int count &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pre)\n    {\n        count&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pre&lt;/span&gt; &amp;#61; pre-&amp;gt;&lt;/span&gt;_pNext;\n    }\n    return count;\n}\nint QueueEmpty(Queue *q)\n{\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;return&lt;/span&gt; NULL &amp;#61;&amp;#61; q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pHead&lt;/span&gt;-&amp;gt;&lt;/span&gt;_pNext;\n}\nQDataType Front(Queue *q)\n{\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;return&lt;/span&gt; q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pHead&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pNext&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n}\nQDataType Back(Queue *q)\n{\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;return&lt;/span&gt; q-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pTail&lt;/span&gt;-&amp;gt;&lt;/span&gt;_&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n}\n\nQueue *q;\nint ds[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;{-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;}};\nint m, n;\nint a[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n\nint bfs(int x, int y, int x2, int y2)\n{\n    QDataType d &amp;#61; {x, y, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    QueuePush(q, d);\n    a[x][y] &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!QueueEmpty(q))\n    {\n        d &amp;#61; Front(q);\n        QueuePop(q);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        {\n            int tx &amp;#61; d.x &amp;#43; ds[i][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n            int ty &amp;#61; d.y &amp;#43; ds[i][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tx &amp;#61;&amp;#61; x2 &amp;amp;&amp;amp; ty &amp;#61;&amp;#61; y2)\n            {\n                return d.len&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tx &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; tx &amp;lt; m &amp;amp;&amp;amp; ty &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ty &amp;lt; n &amp;amp;&amp;amp; a[tx][ty] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                QDataType t &amp;#61; {tx, ty, d.len&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;};\n                QueuePush(q, t);\n                a[tx][ty] &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n           }\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\nint main()\n{\n    int x1, y1, x2, y2;\n    int i, j;\n    q &amp;#61; (Queue *)malloc(sizeof(Queue));\n    QueueInit(q);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;, &amp;amp;m, &amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; m; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;a[i][j]);\n    }\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;x1, &amp;amp;y1, &amp;amp;x2, &amp;amp;y2);\n    int len &amp;#61; bfs(x1, y1, x2, y2);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (len&amp;gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, len);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;no path!&amp;#34;&lt;/span&gt;);\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["c语言，运用队列的数据结构知识求解迷宫问题的最短路径步数。", ["问题遇到的现象和发生背景", "\n", "给定一迷宫以及入口和出口的坐标，要求寻找从入口到出口的最短距离。", "Input", "第一行两个数m和n表示迷宫的行数和列数。迷宫大小不超过45×45。", "\n", "接下来是m行n列的数，用来表示迷宫，1表示墙，0表示通路。", "\n", "第二行四个数x1,y1,x2,y2分别表示起点和终点的坐标。", "\n", "Output", "从起点到终点所经过的最短路径长度，如果不存在，输出\"no path!\"", "\n", "Sample Input", "8 8", "0 0 0 0 0 0 0 1", "0 1 1 1 1 0 0 0", "0 1 0 1 1 1 1 0", "0 1 1 0 0 0 0 0", "0 0 0 1 0 1 1 1", "0 1 0 0 0 0 0 0", "0 1 1 1 1 1 1 0", "0 0 0 0 0 0 0 0", "0 0 1 7", "Sample Output", "8", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "用队列求解。", "\n", "我想要达到的结果", "\n", "不同于网上找到的答案的，运用c语言的知识。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff01;&amp;#xff01;点击该回答右侧的“采纳”按钮即可采纳&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["如何用迪杰斯特拉函数得到最短路径和距离", ["问题遇到的现象和发生背景", "\n", "利用迪杰斯特拉方法求最短路径", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "代码中有错误 但是没有报错", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "\n> #", "include", "<stdio.h>\n#", "include", "<math.h>\n#", "include", "<", "string", ".h>\n#", "include", " <stdlib.h>\n\n#define unreach ", "100", " ", "//没有途径的点之间的距离", "\n\n", "struct", " map {\n    ", "int", " edge", "[", "12", "]", "[", "12", "]", ";", "//储存距离", "\n    ", "int", " S", "[", "12", "]", ";", "//储存点的信息", "\n    ", "int", " edgenum;", "//边的个数", "\n}Map;\n\n", "//输入路径图的信息", "\nmap  ", "Creatmap(", "int", " ", "m", ")", " {\n    const ", "char", "* path = ", "\"C:\\\\Users\\\\tyl666\\\\题目5-最短路径规划\\\\路径文件.txt\"", ";\n    FILE* fp = NULL;\n    fopen", "_s(&", "fp", ", ", "\"path\"", ", ", "\"r\"", ")", ";\n\n    ", "int", " a, b, c;", "//点点边", "\n    ", "//初始化点点距", "\n    ", "for", " (", "int", " i = ", "0", ";i < ", "12", ";i++) {\n        ", "for", " (", "int", " j = ", "0", ";j < ", "12", ";j++) {\n            ", "if", " (i", " == ", "j) {\n                ", "Map", ".", "edge", "[", "i", "]", "[", "j", "]", " = ", "0", ";\n            }\n            ", "else", " {\n                ", "Map", ".", "edge", "[", "i", "]", "[", "j", "]", " = unreach;\n            }\n        }\n    }\n    ", "//从文件中读取点与点之间的距离", "\n    ", "for", " (", "int", " i = ", "0", ";i < ", "21", ";i++)\n    {\n        fscanf", "_s(", "fp", ", ", "\"%d,%d,%d\"", ", &", "a", ", &", "b", ", &", "c", ")", ";\n        ", "Map", ".", "edge", "[", "a", "]", "[", "b", "]", " = c;\n        ", "Map", ".", "edge", "[", "b", "]", "[", "a", "]", " = c;\n    }\n    fclose(fp);\n\n    return Map;\n}\n", "//迪杰斯特拉算法", "\nvoid ", "Dijkstra(", "map", " Map, ", "int", " ", "d", ", ", "int", " ", "m", ")", "//d设为起点", "\n{\n    ", "int", " i, j, n;\n    d = ", "1", ";\n    ", "//利用动态数组", "\n    ", "int", "* dist=", "new", " ", "int", "[", "12", "]", ";", "//储存当前最短路径的长度", "\n    ", "char", "* path=", "new", " ", "char", "[", "12", "]", ";", "//储存最短路径", "\n    ", "for", " (i = ", "0", ";i < ", "12", ";i++) {\n        dist", "[", "i", "]", " = ", "Map", ".", "edge", "[", "d", "]", "[", "i", "]", ";\n        path", "[", "i", "]", " = Map.S", "[", "d", "]", " + Map.S", "[", "i", "]", ";\n    }\n    ", "//开始遍历路径图", "\n    ", "for", " (n = ", "1", ";n < ", "12", ";n++) {\n        ", "for", " (i = ", "0", ", j = ", "0", ";i < ", "12", ";i++) {\n            ", "if", " (dist", "[", "i", "]", " != ", "0", "&&dist", "[", "i", "]", "<dist", "[", "j", "]", ") {\n                j = i;\n            }\n        }\n        printf(", "\"%d %d\"", ", dist", "[", "i", "]", ",path", "[", "j", "]", ");\n        ", "//逐步寻找到最短路径及其距离", "\n        ", "for", " (i = ", "0", ";i < ", "12", ";i++) {\n            ", "if", " (dist", "[", "i", "]", " > dist", "[", "j", "]", " + ", "Map", ".", "edge", "[", "j", "]", "[", "i", "]", ") {\n                dist", "[", "i", "]", " = dist", "[", "j", "]", " + ", "Map", ".", "edge", "[", "j", "]", "[", "i", "]", ";\n                path", "[", "i", "]", " = path", "[", "j", "]", " + Map.S", "[", "i", "]", ";\n            }\n        }\n        dist", "[", "j", "]", " = ", "0", ";\n    }\n}\n\n", "int", " main", "()", "\n{\n    ", "int", " a = ", "21", ";\n    ", "int", " m = ", "1", ";\n    Map = ", "Creatmap(", "a", ")", ";\n    ", "Dijkstra(Map, ", "m", ", ", "a", ")", ";\n\n    return ", "0", ";\n}\n\n", "\n", "运行结果及详细报错内容", "\n", "出现了debug警告", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "读取文件数据写入了地图数据，构造函数求最短路径", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "\n", "得到最短路径和距离"]], "Tag": "算法设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;i表示步数&amp;#xff0c;从a顶点出发到b顶点只需要1步&amp;#xff0c;故i&amp;#61;1。到其他顶点&amp;#xff0c;以此类推&amp;#xff1b;&lt;/li&gt;&lt;li&gt;从a到d有3种走法&amp;#xff0c;最短路径和是5&amp;#xff08;2&amp;#43;3&amp;#xff0c;即 a -&amp;gt; b -&amp;gt; d&amp;#xff09;&amp;#xff0c;其他两种走法是  a -&amp;gt; c -&amp;gt; d&amp;#xff0c; a -&amp;gt; b -&amp;gt; c -&amp;gt; d&amp;#xff1b;&lt;/li&gt;&lt;li&gt;∞表无穷大&amp;#xff0c;即从某个节点到某个顶点之间是不可达。&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "最短路径", "Question": ["迪杰斯特拉算法求最短路径", ["看不大懂以下这种迪杰斯特拉求最短路径的方法", "\n", "\n", "\n", "主要疑惑如下：", "1.答案中的i代表的是什么？", "2.为什么会有多个重复的结果出现，例如d行中有三个是完全一模一样的", "3.不是很能理解∞代表的是什么"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;最短路径不对&amp;#xff0c;路径最短不代表它是由最短的边组成的&lt;br /&gt;比如最短的路径是1,100&amp;#xff0c;第二短的路径是102条长度为1的路径组成&amp;#xff0c;很显然最短路径跟这题完全不是同一个问题&lt;br /&gt;而且求最短路径你需要验证每个路径&amp;#xff0c;很耗费时间&lt;br /&gt;这题其实最适合用贪心算法求&amp;#xff0c;反正每路过一个节点&amp;#xff0c;你都走最短的那条就对了&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["与无向图最短路径有关", ["问题", "：一个无向图有n个点，m条边，你现在在1号点，每条边有个对能力值的限制，要大于等于这个限制才能通过它。他们想知道他们至少要有多大的能力值，才能从1号点到n号点。", "\n", "输入", "：第一行两个正整数n,m。分别表示图的大小和边的数量。", "接下来m行，每行3个整数 u,v,l 。表示有一条u到v的边，至少要l能力值才能通过。地图保证1和n是连通的。", "\n", "数据规模", "：对于30%的数据： n<=m<=8", "对于100%的数据 , n<=m<=10^6,1<=u,v<=n,0<=l<=10^9", "\n", "输出描述", "：需要获得的最小的能力值，能够从1到n", "\n", "我的想法和出现的问题", "：我本来打算先求最短路径的，再找出最短路径上最长的一条边的值，但是它测试数据太大了，我邻接矩阵一开数组就爆栈了。有没有什么不爆数组的思路啊。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;D&lt;/p&gt;\n&lt;p&gt;最短路径算法&amp;#xff1a;一个是迪杰斯特拉算法&amp;#xff0c;求从某个源点到其余各顶点的最短路径&amp;#xff0c;求解过程按路径长度递增的次序产生的最短路径&amp;#xff0c;时间复杂度是O(n^2) ; 另一种算法是弗洛伊德算法&amp;#xff0c;求 每一对顶点之间的最短路径&amp;#xff0c;时间复杂度为O(n^3)。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["与费洛伊德算法中最短路径的时间复杂度相关的疑问", ["请教图片中的这个内容该怎么做呢，我能该如何去解决，与费洛伊德算法中最短路径的时间复杂度相关的疑问"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;shortest_path(G[, source, target, weight,...]) 计算图中的最短路径&amp;#xff0c;可以用于无向图或有向图&lt;/p&gt;\n&lt;p&gt;dijkstra_path(G, source, target[, weight]) 计算从源到目标的最短加权路径&amp;#xff0c;用于有权图&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["NetworkX 有权无向图计算最短路径", ["NetworkX 有权无向图计算最短路径时函数shortest_path(G[, source, target, weight,…])和函数dijkstra_path(G, source, target[, weight])有什么区别？", "\n", "\n", "参考链接：", "https://blog.csdn.net/youcans/article/details/116999881?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167210396716800213045638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167210396716800213045638&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116999881-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control1&utm_term=networkx%20shortest_path&spm=1018.2226.3001.4187"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;超时了&amp;#xff0c;换个算法&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["洛谷P4779最短路径问题TLE", ["\n", "#include<bits/stdc++.h>", "using namespace std;", "int  a[10005][10005];", "int  d[10005],i,j;", "const int INF=1e9;", "int t;", "int read()", "{", "    int x=0,y=1;", "    char c;", "    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}", "    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}", "    return x*y;", "}", "void dij(int n)//单源最短路径", "{", "    bool f[10005]={0};", "    f[1]=1;", "    int v;", "    for(i=1;i<n;i++)", "    {", "        int min=INF;", "        for(j=1;j<=n;j++)", "        {", "            if(!f[j]&&min>d[j])//找未标记中最小的", "            {", "                min=d[j];", "                v=j;", "            }", "        }", "        f[v]=1;//标记", "        for(j=v;j<=n;j++)", "        {", "            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度", "            {", "                d[j]=a[v][j]+d[v];", "            }", "        }", "    }", "}", "\n", "int main()", "{", "    int n,m,x,y,z;", "    n=read(),m=read(),t=read();", "    for(i=1;i<=m;i++)", "    {", "        x=read(),y=read(),z=read();", "        a[x][y]=z;", "    }", "    for(i=1;i<=n;i++)", "    {", "        d[i]=a[t][i];//路径长度初始化]]", "    }", "    dij(n);", "    for(i=1;i<=n;i++)", "    {", "        printf(\"%d\\n\",d[i]);", "    }", "    return 0;", "}", "爆TLE，请问这个程序哪里出了问题？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;直接bfs就行了&amp;#xff0c;毕竟询问次数较少&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["PTA 7-3 幸福小镇的故事! (最短路径直接用floyd会超时怎么办?)", ["7-3 幸福小镇的故事！（简单） (25 分)", "\n\n", "在一个很远很远的地方，有一个幸福小镇！", "\n\n", "幸福小镇的治安很不好，所以生活在镇上很不幸福！", "\n\n", "新来的保安队队长小Z决心改变这一切，第一步要解决的是任何两个小镇之间的距离问题！", "\n\n", "我们需要解决这个问题的简化版本：", "\n\n", "幸福小镇可以划分为N个小小镇，从1到N编号！这些小小镇由N-1条道路连通，我们把每条道路的长度简化为1！只要在每个小小镇增派人手，就可以让小镇的治安情况变得越来越好！（题目保证两个小镇之间的道路只有一条！）", "\n\n", "每次小Z会询问你两个小小镇的编号，请你计算出这两个小镇之间的最短路径长度！", "\n\n", "输入格式:", "\n\n", "第一行包含一个正整数（N<=1000），表示小小镇的个数！", "\n\n", "接下来N-1行，每行包含两个1到N之间的整数，表示这两个编号的小小镇之间有一条路！", "\n\n", "接下来一行包含一个整数q（q<=100)，表示询问数！", "\n\n", "接下来q行，每行包含两个小小镇的编号，请在一行中输出这两个小小镇的最短路径长度！", "\n\n", "输出格式:", "\n\n", "输出答案即可！", "\n\n", "输入样例:", "\n\n", "在这里给出一组输入。例如：", "\n\n", "\n", "10\n1 2\n2 3\n1 4\n4 5\n4 6\n3 7\n3 8\n1 9\n9 10\n5\n3 8\n9 3\n1 1\n1 7\n1 9", "\n\n", "输出样例:", "\n\n", "在这里给出相应的输出。例如：", "\n\n", "\n", "1\n3\n0\n3\n1"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/xs18952904/article/details/84670271", "Konwledge_Point": "最短路径", "Question": ["利用C语言的程序设计的技术，计算这个图中的最长最短路径的算法怎么实现", ["Problem Description", "\nThe graph diameter is the length of the \"longest shortest path\" between any two vertices of a graph. In other words, a graph's diameter is the longest path which must be traversed in order to travel from any vertex to another when paths which backtrack, detour, or loop are excluded from consideration.", "\nGiven an undirected graph, your mission is to count the number of diameters of it.", "\n\n", "Input", "\nThe input contains multiple test cases. ", "\nFor each test case, it contains n+1 lines. ", "\nLine 1: two integers m, n (2<= m <= 100, 1 <= n <= 4000) indicating that there are m vertices and n edges in the city. ", "\nLine 2~n+1: each contains three integers i, j, d (1 <= i, j <= m, 1 <= d <= 100), indicating that there is an edge of length d connecting vertex i and vertex j.", "\n\n", "Output", "\nOutput the value of the diameter and the number of diameters in a single line, separated by a single space.", "\n\n", "Sample Input", "\n4 5 ", "\n1 2 1 ", "\n2 3 1 ", "\n3 4 1 ", "\n1 4 1 ", "\n1 3 2 ", "\n\n", "Sample Output", "\n2 5"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;br /&gt;using namespace std;&lt;br /&gt;char a[1005],b[1005],e,f;&lt;br /&gt;int n,d[27][27],s&amp;#61;0;&lt;br /&gt;int main(){&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cin&amp;gt;&amp;gt;n;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        cin&amp;gt;&amp;gt;e&amp;gt;&amp;gt;f;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        d[e-&amp;#39;a&amp;#39;][f-&amp;#39;a&amp;#39;]&amp;#61;d[f-&amp;#39;a&amp;#39;][e-&amp;#39;a&amp;#39;]&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int k&amp;#61;0;k&amp;lt;27;k&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        for(int i&amp;#61;0;i&amp;lt;27;i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            for(int j&amp;#61;0;j&amp;lt;27;j&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                if(d[i][k]!&amp;#61;0&amp;amp;&amp;amp;d[k][j]!&amp;#61;0&amp;amp;&amp;amp;i!&amp;#61;j){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                    if(d[i][j]&amp;#61;&amp;#61;0) d[i][j]&amp;#61;d[i][k]&amp;#43;d[k][j];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                    else d[i][j]&amp;#61;min(d[i][j],d[i][k]&amp;#43;d[k][j]);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;0;i&amp;lt;strlen(a);i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        s&amp;#43;&amp;#61;d[a[i]-&amp;#39;a&amp;#39;][b[i]-&amp;#39;a&amp;#39;];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cout&amp;lt;&amp;lt;s;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    return 0;&lt;/span&gt;&lt;br /&gt;} &lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["弗洛伊德算法求多源最短路径", ["\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答引用ChatGPT &lt;/p&gt;\n&lt;p&gt;1、Dijkstra算法可以用于解决最短路径问题。假设城市A为源点&amp;#xff0c;城市B为终点&amp;#xff0c;可以先将所有城市的距离初始化为无穷大&amp;#xff0c;将城市A到其他城市的距离更新为实际距离&amp;#xff0c;然后选取距离A最近的城市&amp;#xff0c;将它到其他城市的距离与A到其他城市的距离进行比较并更新&amp;#xff0c;直到所有城市的距离都被更新过。最终&amp;#xff0c;从A到B的最短路径即为路径上所有边的距离之和。&lt;/p&gt;\n&lt;p&gt;2、可以使用广度优先搜索算法&amp;#xff08;BFS&amp;#xff09;解决转车次数最少的问题。假设城市A为起点&amp;#xff0c;城市B为终点&amp;#xff0c;将A加入队列&amp;#xff0c;从队列中取出A&amp;#xff0c;遍历A可直达的城市并将其加入队列&amp;#xff0c;标记A为已访问过。接着从队列中取出下一个城市&amp;#xff0c;重复上述过程直到取出B或者队列为空。在遍历时&amp;#xff0c;使用一个数组记录下每个城市到起点的最短距离&amp;#xff0c;每当遍历到一个城市时&amp;#xff0c;如果到达这个城市的路径比之前记录的路径短&amp;#xff0c;就更新这个城市的最短路径。最终&amp;#xff0c;到达B的路径上的中转次数即为B的最短路径上的城市个数减1。&lt;/p&gt;\n&lt;p&gt;3、可以将1和2中的方法结合起来。先按照Dijkstra算法计算出从A到每个城市的最短路径&amp;#xff0c;然后使用BFS算法&amp;#xff0c;从A出发&amp;#xff0c;遍历所有可达城市&amp;#xff0c;更新到这些城市的最短路径和中转次数&amp;#xff0c;直到遍历到B。如果遍历到的城市到A的最短路径加上这个城市到B的最短路径等于A到B的最短路径&amp;#xff0c;说明找到了一条最短路径上的中转点。在更新最短路径和中转次数时&amp;#xff0c;需要考虑到中转次数相同时的比较&amp;#xff0c;可以使用一个优先队列&amp;#xff08;最小堆&amp;#xff09;存储城市信息&amp;#xff0c;根据综合花费&amp;#xff08;最短路径&amp;#43;中转次数&amp;#xff09;的大小来决定优先级。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["数据结构（最短路径的应用）", ["功能：现有10个城市之间的交通信息，若有火车，则提供两个城市之间火车票价格。", "（1）有旅客Ａ，准备从城市A出发到城市B，他希望总想花费最少。试设计一种方案。", "（2）有旅客Ｂ，准备从城市A出发到城市B，他想转车次数最少。试设计一种方案。", "( 3 ) 有旅客Ｂ，准备从城市A出发到城市B，他希望总想花费最少的情况下尽量减少中转次数。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;邻接表&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;deque&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a,b,n1,m1;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;node&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w;\n};\nvector&amp;lt;node&amp;gt; e[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,m,vis[&lt;span class=\"hljs-number\"&gt;100001&lt;/span&gt;],mapa[&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;],ans&amp;#61;&lt;span class=\"hljs-number\"&gt;1000000001&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;gt;&amp;#61;ans)&lt;span class=\"hljs-comment\"&gt;//小剪枝 &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;n)\n    {\n        ans&amp;#61;&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(ans,dis);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    node tt; \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;e[x].&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;();i&amp;#43;&amp;#43;)\n    {\n        tt&amp;#61;e[x][i];\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(vis[tt.v]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            vis[tt.v]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(tt.v,dis&amp;#43;tt.w);\n            vis[tt.v]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    } \n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    node t;\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;m1;\n    &lt;span class=\"hljs-comment\"&gt;//memset(mapa,0x3f,sizeof(mapa));//初始化&lt;/span&gt;\n     \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;m;j&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n        t.v&amp;#61;b;\n        t.w&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        e[a].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(t);\n        t.v&amp;#61;a;\n        t.w&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        e[b].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(t);\n       \n    }\n    vis[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;邻接矩阵&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,m,vis[&lt;span class=\"hljs-number\"&gt;100001&lt;/span&gt;],mapa[&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;],ans&amp;#61;&lt;span class=\"hljs-number\"&gt;1000000001&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;gt;ans)&lt;span class=\"hljs-comment\"&gt;//小剪枝 &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;n)\n    {\n        ans&amp;#61;&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(ans,dis);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//不一定向前走&amp;#xff0c;可能绕一下更近 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(mapa[x][i]!&amp;#61;&lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;&amp;amp;&amp;amp;vis[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) \n    {\n        vis[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(i,dis&amp;#43;mapa[x][i]);\n        vis[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n     } \n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a,b,n1,m1;\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;m1;\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(mapa,&lt;span class=\"hljs-number\"&gt;0x3f&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(mapa));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;m;j&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n        mapa[b][a]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//保证单向 &lt;/span&gt;\n        mapa[a][b]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    vis[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;链式前向星&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;deque&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;edge&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; nxt;\n}e[&lt;span class=\"hljs-number\"&gt;300&lt;/span&gt;]; \n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; h[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;addedge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v)&lt;/span&gt;\n&lt;/span&gt;{\n    cnt&amp;#43;&amp;#43;;\n    e[cnt].to&amp;#61;v;\n    e[cnt].nxt&amp;#61;h[u];\n    h[u]&amp;#61;cnt;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,m,vis[&lt;span class=\"hljs-number\"&gt;100001&lt;/span&gt;],mapa[&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;],ans&amp;#61;&lt;span class=\"hljs-number\"&gt;1000000001&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;gt;&amp;#61;ans)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;n)\n    {\n        ans&amp;#61;&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(ans,dis);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;h[x];i&amp;gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;#61;e[i].nxt)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to&amp;#61;e[i].to;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(vis[to]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            vis[to]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(to,dis&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            vis[to]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n1,m1; \n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;m1;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a,b,c;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;m;j&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n        &lt;span class=\"hljs-built_in\"&gt;addedge&lt;/span&gt;(a,b);\n        &lt;span class=\"hljs-built_in\"&gt;addedge&lt;/span&gt;(b,a);\n    }\n    vis[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["最小换乘，求最短路径的问题", ["设某城市有n个车站，并有m条公交线路连接这些车站。设这些公交", "车都是单向的，这n个车站被顺序编号为0-n-l。本程序，输入该城市的公交线", "路数、车站个数、以及各公交线路上的各站编号。", "要求:", "\n", "（1求从站0出发乘公交车至其他车站的最少换车次数，并输出所经过的站点序", "列;", "(2利用输入信息构建一张有向图，分别用邻接矩阵和邻接表表示，并输出邻接", "矩阵和邻接表信息;", "\n", "(3从站0出发，对公交线路图进行遍历。", "\n", "收起全部 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;i&amp;#61;1, 2, 3, 4, 5, 6&lt;/code&gt;表示第几次迭代&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["数据结构，最短路径问题求解？", ["这个表里的i时什么意思？那个i=1 2 3 4 5 6，这个i是什么意思？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_35710556/article/details/79583229\"&gt;https://blog.csdn.net/qq_35710556/article/details/79583229&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;五种最短路径算法&amp;#xff0c;自己研究一下&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["C++求给出图的最短路径问题", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你理解的没错&amp;#xff0c;但是我觉得你可能想复杂了&amp;#xff0c;我感觉这一段就是解释和证明数组 distTo[v] 保存的是从 s 到 v 的最短距离&amp;#xff0c; v 和 w 都不是定值&amp;#xff0c;disTo[w]&amp;lt;&amp;#61;distTo[v] &amp;#43; e.weight() 的意思就是指到节点 w 的最短距离不可能比经由其他节点去往 w 的距离更长。&lt;br /&gt;附上英文原版帮助理解&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/968135848086140.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["算法第4版  4.4.3 最优路径算法的理论基础 最短路径的最优条件描述是不是不太准确？", ["算法第4版  4.4.3 最优路径算法的理论基础 最短路径的最优条件描述是不是不太准确？", "\n", "\n", "当且仅当对于", "从v到w的任意一条边e", "，这些值都是满足", "disTo[w]<=distTo[v] + e.weight()", "时（换句话说，就是不存在有效边时），它们是最短路径。", "\n", "刚开始我是这么理解w、v和e的", "\n", "\n", "后来才明白应该是这样", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Plenty of reading/algorithms:\n&lt;a href=\"http://en.wikipedia.org/wiki/Shortest_path_problem\" rel=\"nofollow noreferrer\"&gt;Shortest path problem&lt;/a&gt;. You effectively just have every edge (\"link\", as you called it) with an equal weight.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "最短路径", "Question": ["线性阵列，节点随机链接到阵列中的其他节点，最短路径", ["\n\n", "INFO:\nI have an Array of 100 nodes, [ 0 .. 99 ].  Each node can have an arbitrary number of linked nodes:", "\n\n", "eg1, 0 links to 5, 10, 15, 20.\neg2, 1 links to 30, 40, 50.\neg3, etc..", "\n\n", "All 100 nodes have at least one linked node, nodes do not know who links to them.", "\n\n", "QUESTION:\nHow can I find the shortest link-path if provided with START and END.", "\n\n", "eg. START=5, END=80, Link Path (example) : [5]->10->24->36->[80]?", "\n\n", "I'm using Pascal and/or PHP, but understanding how is what I'm looking for [code helps too].", "\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Dijkstra should pass, I just make a submission using JAVA, and it took less than a second to complete each task.&lt;/p&gt;\n\n&lt;p&gt;As I have mentioned, each value in the matrix can go up to 10^9, your solution can encounter a number overflow problem, which can effect the running time.&lt;/p&gt;\n\n&lt;p&gt;My code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;!-- language:java --&amp;gt;\n\nstatic int[]X = {0,1,0,-1};\nstatic int[]Y = {1,0,-1,0};\npublic static void main(String[] args) throws FileNotFoundException {\n    // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n    // \"output.txt\")));\n    PrintWriter out = new PrintWriter(System.out);\n    Scanner in = new Scanner();        \n    int n = in.nextInt();\n    long[][]map = new long[n][n];\n    for(int i = 0; i &amp;lt; n; i++){\n        for(int j = 0; j &amp;lt; n; j++){\n            map[i][j] = in.nextLong();\n        }\n    }\n    PriorityQueue&amp;lt;Pos&amp;gt; q= new PriorityQueue();\n    long[][]dist = new long[n][n];\n    for(long[]a : dist){\n        Arrays.fill(a,Long.MAX_VALUE);\n    }\n    q.add(new Pos(0,0,map[0][0]));\n    dist[0][0] = map[0][0];\n    while(!q.isEmpty()){\n        Pos p = q.poll();\n        if(dist[p.x][p.y] == p.cost){\n            for(int i = 0; i &amp;lt; 4; i++){\n                int x = p.x + X[i];\n                int y = p.y + Y[i];\n                if(x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;lt; n &amp;amp;&amp;amp; dist[x][y] &amp;gt; dist[p.x][p.y] + map[x][y] ){\n                    dist[x][y] = dist[p.x][p.y] + map[x][y];\n                    q.add(new Pos(x,y,dist[x][y]));\n                }\n            }\n        }\n    }\n    out.println(dist[n - 1][n - 1]);\n    out.close();\n}\n\nstatic class Pos implements Comparable&amp;lt;Pos&amp;gt;{\n    int x, y;\n    long cost;\n    public Pos(int x, int y, long cost) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n    }\n    @Override\n    public int compareTo(Pos o) {\n        // TODO Auto-generated method stub\n        return Long.compare(cost, o.cost );\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;p&gt;I think your Dijkstra implementation is not correct:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for frontier.Len() &amp;gt; 0 {\n    element := heap.Pop(&amp;amp;frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    //You didn't check for visited vertex here!\n    visited[vertex] = true\n    neighbors := graph[vertex]\n    for vertex_new, cost_new := range(neighbors){\n        if !visited[vertex_new]{//You can add same vertex multiple times here!\n            if vertex_new == end{\n                return cost + cost_new\n            }\n            heap.Push(&amp;amp;frontier, &amp;amp;Item{\n                value: vertex_new,\n                priority: cost + cost_new,\n            })\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In your implementation, you only update &lt;code&gt;visited&lt;/code&gt; when the vertex pop out of the heap, thus, one vertex can be added and processed multiple time, so, it will significantly increase your time complexity.&lt;/p&gt;\n\n&lt;p&gt;To fix&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for frontier.Len() &amp;gt; 0 {\n    element := heap.Pop(&amp;amp;frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    if !visited[vertex]{\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                   return cost + cost_new\n                }\n                heap.Push(&amp;amp;frontier, &amp;amp;Item{\n                   value: vertex_new,\n                   priority: cost + cost_new,\n                })\n            }\n        }   \n    }\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "最短路径", "Question": ["在矩阵中找到最短路径总和。  Dijkstra是否不适用于这种情况？", ["\n\n", "I am trying to solve ", "the following problem from project euler", " (please take a look at description and the example in the link, but here is the short explanation).", "\n\n", "\n  ", "in the matrix, find the  minimal path sum from the top left to the bottom right, by moving left, right, up, and down", "\n", "\n\n", "Right after I looked at the problem, the obvious solution which came to mind is to create a graph from the matrix and then use ", "Dijkstra", " to find the shortest path.", "\n\n", "To construct a graph from a ", "N*M", " matrix, for every ", "(i, j)", " element I create a vertex ", "i * N + j", " and connect it to any other vertex (to which it is possible to connect with UP, RIGHT, DOWN, LEFT) and the edge will be the value of the element I am connecting to in the matrix. After that I create 2 other vertices ", "-1", " connected to vertex ", "0", " and ", "-2", " connected to ", "N*M - 1", " which will be my start and end vertices (both connection have 0 cost).", "\n\n", "After this I am doing Dijkstra to find shortest path cost from ", "-1", " to ", "-2", ". My Dijkstra implementation uses priority queue and looks this way:", "\n\n", "func dijkstraCost(graph map[int]map[int]int, start, end int) int{\n    if start == end{\n        return 0\n    }\n    frontier := make(PriorityQueue, 1)\n    frontier[0] = &Item{value: start, priority: 0, index: 0}\n    visited := map[int]bool{}\n    heap.Init(&frontier)\n\n    for frontier.Len() > 0 {\n        element := heap.Pop(&frontier).(*Item)\n        vertex, cost := element.value, element.priority\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                    return cost + cost_new\n                }\n                heap.Push(&frontier, &Item{\n                    value: vertex_new,\n                    priority: cost + cost_new,\n                })\n            }\n        }\n    }\n    return -1\n}\n", "\n\n", "where Priority Queue implementation is taken from heap container (example PriorityQueue) with one minor modification:", "\n\n", "func (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority > pq[j].priority // changed to <\n}\n", "\n\n", "The graph that I am providing to the function looks like:", "\n\n", "map[13:map[8:965 18:121 12:746 14:111] 16:map[11:803 21:732 15:537 17:497] 3:map[8:965 2:234 4:18] 4:map[9:150 3:103] 22:map[17:497 21:732 23:37] -1:map[0:131] 17:map[16:699 18:121 12:746 22:524] 1:map[6:96 0:131 2:234] 9:map[4:18 14:111 8:965] 11:map[6:96 16:699 10:630 12:746] 19:map[14:111 24:331 18:121] 24:map[23:37 -2:0 19:956] 2:map[3:103 7:342 1:673] 15:map[10:630 20:805 16:699] 18:map[13:422 23:37 17:497 19:956] 10:map[5:201 15:537 11:803] 14:map[19:956 13:422 9:150] 0:map[5:201 1:673] 6:map[5:201 7:342 1:673 11:803] 8:map[9:150 3:103 13:422 7:342] -2:map[] 12:map[7:342 17:497 11:803 13:422] 20:map[15:537 21:732] 21:map[16:699 20:805 22:524] 5:map[0:131 10:630 6:96] 23:map[18:121 22:524 24:331] 7:map[2:234 12:746 6:96 8:965]]\n", "\n\n", "\n", "This works correctly but the problem is that it is considered inefficient (judging by ", "Hackerrank version of the problem", "). It should run find the value of the best solution for ", "700x700", " matrix in less than 4 seconds, whereas my solution takes 10 seconds.", "\n\n", "I thought that I am doing something wrong in go, so I reimplemented the same solution in python (where it took approximately 70 seconds for 700x700 matrix)", "\n\n", "\n", "My question is:", " Am I using the right approach to find the best solution in a matrix. If so what am I doing wrong with my implementation?", "\n\n", "P.S. I have full go and python solution, just thought that even without them the question is too long.", "\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ryn 安装和python代码都是python2版本的&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["看到您一篇关于ryu最短路径转发的文章，想咨询您一点问题", ["在Ubuntu执行自定义的ryu控制器脚本时出现的问题", "wjc@wjc-virtual-machine:~/ryu/ryu/app$ ryu-manager example_shortestForwarding.py --observe-links", "Traceback (most recent call last):", "  File \"/home/wjc/.local/bin/ryu-manager\", line 5, in ", "    from ryu.cmd.manager import main", "  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/cmd/manager.py\", line 33, in ", "    from ryu.app import wsgi", "  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/app/wsgi.py\", line 23, in ", "    from tinyrpc.server import RPCServer", "  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/", "init", ".py\", line 4, in ", "    from .protocols import *", "  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/protocols/", "init", ".py\", line 15", "    def ", "init", "(self) -> None:", "                       ^", "SyntaxError: invalid syntax", "\n", "不知道这个问题应该如何解决"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/xiaohang3414/article/details/73321625", "Konwledge_Point": "最短路径", "Question": ["最短路径搜索，除了暴搜以外，采用C语言的还有更优化的办法怎么做呢？", ["Problem Description", "\nThe discovery of anti-gravitations technology changed the world. The invention of anti-gravitation shoes (Grav-shoes) enables people to fly in the sky freely. This led to the rise of a new sky sport: ``Flying Circus\".", "\n\n", "Utilizing Grav-shoes and personal flying suits, competitors battle it out in a special field, where they compete scoring obtain m points within a certain time limit. The field is a square with edge length 300 meters. Moreover, there are four buoys floating at each corner of the square. Four buoys are numbered as 1,2,3,4 in clockwise order.", "\n\n", "Two players start at buoy #1. When game begin, they will try to touch four floating buoys in clockwise order.", "\n(Since buoy #1 is the start point, the first buoy they need to touch will be buoy #2, and after that, they need to touch buoy #3,#4,#1 in order) Note that they could fly freely in the field, even fly inside the square field.", "\n\n", "Under two situations the player could score one point.", "\n\n", "⋅1. If you touch a buoy before your opponent, you will get one point. For example if your opponent touch the buoy #2 before you after start, he will score one point. So when you touch the buoy #2, you won't get any point. Meanwhile, you cannot touch buoy #3 or any other buoys before touching the buoy #2.", "\n\n", "⋅2. Ignoring the buoys and relying on dogfighting to get point. If you and your opponent meet in the same position, you can try to fight with your opponent to score one point. For the proposal of game balance, two players are not allowed to fight before buoy #2 is touched by anybody.", "\n\n", "There are three types of players.", "\n\n", "Speeder: As a player specializing in high speed movement, he/she tries to avoid dogfighting while attempting to gain points by touching buoys.", "\nFighter: As a player specializing in dogfighting, he/she always tries to fight with the opponent to score points. Since a fighter is slower than a speeder, it's difficult for him/her to score points by touching buoys when the opponent is a speeder.", "\nAll-Rounder: A balanced player between Fighter and Speeder.", "\n\n", "There will be a training match between Asuka (All-Rounder) and Shion (Speeder).", "\nSince the match is only a training match, the rules are simplified: the game will end after the buoy #1 is touched by anybody. Shion is a speed lover, and his strategy is very simple: touch buoy #2,#3,#4,#1 along the shortest path.", "\n\n", "Asuka is good at dogfighting, so she will always score one point by dogfighting with Shion, and the opponent will be stunned for T seconds after dogfighting. Since Asuka is slower than Shion, she decides to fight with Shion for only one time during the match. It is also assumed that if Asuka and Shion touch the buoy in the same time, the point will be given to Asuka and Asuka could also fight with Shion at the buoy. We assume that in such scenario, the dogfighting must happen after the buoy is touched by Asuka or Shion.", "\n\n", "The speed of Asuka is V1 m/s. The speed of Shion is V2 m/s. Is there any possibility for Asuka to win the match (to have higher score)?", "\n\n", "Input", "\nThe first line contains an integer t (0<t≤1000), followed by t lines.", "\nEach line contains three double T, V1 and V2 (0≤V1≤V2≤2000,0≤T≤2000) with no more than two decimal places, stands for one case.", "\n\n", "Output", "\nIf there exist any strategy for Asuka to win the match, output ", "Yes\", otherwise, output", "No\".", "\n\n", "Sample Input", "\n2", "\n1 10 13", "\n100 10 13", "\n\n", "Sample Output", "\nCase #1: No", "\nCase #2: Yes"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/u012969412/article/details/44818029", "Konwledge_Point": "最短路径", "Question": ["希望大神解答一下，这道题用bfs+优先队列为什么不对，只能用最短路径来写", ["Bessie and the rest of Farmer John's cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 <= R <= 100) by C (1 <= C <= 100) grid of elevations E (-25 <= E <= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.\n\nBessie starts out travelling at a initial speed V (1 <= V <= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.\n\nFind the both smallest amount of time it will take Bessie to join her cow friends.\n", "\n\n", "Input", "\n    * Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie's initial velocity and the number of rows and columns in the grid.", "\n\n", "* Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid. \n", "\n\n", "Output", "\n    A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid. ", "\nSample Input", "\n\n", "1 3 3\n1 5 3\n6 3 5\n2 4 3\n", "\n\n", "Sample Output", "\n\n", "29.00\n", "\n\n", "Hint", "\n    Bessie's best route is:", "\n    Start at 1,1 time 0 speed 1", "\n    East to 1,2 time 1 speed 1/16", "\n    South to 2,2 time 17 speed 1/4", "\n    South to 3,2 time 21 speed 1/8", "\n    East to 3,3 time 29 speed 1/4 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这种问题不应该用Dijkstra这种太理论化的算法去解决问题&amp;#xff0c;因为专业的识别cad图的算法&amp;#xff0c;不是那么轻易就能写好。&lt;br /&gt;建议&amp;#xff1a;&lt;br /&gt;直接读取cad图&amp;#xff0c;自己写识别算法&amp;#xff0c;一张建筑平面图&amp;#xff0c;适当处理下&amp;#xff0c;二值化后就只剩墙壁的黑色部分&amp;#xff0c;用程序遍历一次所有的路线&amp;#xff0c;就能找到最佳路线了&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["给出一张建筑平面图，如何将其转换成路径距离信息的无向图", ["做建筑疏散的实验，考虑用Dijkstra找无向图的最短路径、疏散出口。目前无向图需要手画。", "\n", "\n", "\n", "正在思考如何根据一张建筑平面图，如cad图，去识别这张图，并自动生成他的路径距离信息的图。", "\n", "其中无向图的每个节点可以代表建筑的路口，权重代表路径的距离。"]], "Tag": "算法设计"}
{"Answer": "如果是写代码的话，邻接矩阵肯定比邻接表好写，毕竟是数组实现；\r\n就时间复杂度上而言对于稀疏图用邻接表比较好，对于稠密图用邻接矩阵比较好", "Konwledge_Point": "最短路径", "Question": ["图的拓扑参数 点介数\\点核数\\度分布", ["    对于一个图来说,度分布是比较好做的,列出所有点对<a,b>计算每一点出现的次数,就是度数.\n    点介数是通过该点的最短路径的条数.\n    点核数定义较为复杂.\n    那么对于程序实现来说,狄克斯特拉算法只能算出最短路径并不能得到每一点的信息?\n下面问题来了\n        度分布的计算究竟是用邻接矩阵方便还是邻接表方便呢?\n        介数的计算思想究竟是什么呢?\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;由于题太长导致ChatGPT试了好几次才全部答完&amp;#xff0c;可能答案不正确&lt;/strong&gt;&lt;br /&gt;1、利用随机数原理&amp;#xff0c;随机产生一个二维数组A&amp;#xff08;30*30&amp;#xff09;&amp;#xff0c;其中对角线元素为零&amp;#xff0c;剩余元素中的50%是∞&amp;#xff0c;其余元素的值为大于0的随机数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;srand&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)); &lt;span class=\"hljs-comment\"&gt;// 设置随机数种子&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N];       &lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; j)\n            { &lt;span class=\"hljs-comment\"&gt;// 对角线元素为零&lt;/span&gt;\n                A[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;rand&lt;/span&gt;() % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            { &lt;span class=\"hljs-comment\"&gt;// 50%的概率为∞&lt;/span&gt;\n                A[i][j] &amp;#61; INF;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            { &lt;span class=\"hljs-comment\"&gt;// 剩余元素的值为大于0的随机数&lt;/span&gt;\n                A[i][j] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;rand&lt;/span&gt;() % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 输出二维数组A&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; A[i][j] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        }\n        cout &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、将上述二维数组作为图的邻接矩阵&amp;#xff0c;以该数组作为输入&amp;#xff0c;创建一个图形结构&amp;#xff0c;该图使用邻接表作为存储结构。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;vector&amp;gt;\n\nusing namespace std;\n\nconst &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\nconst &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Edge\n{                    &lt;span class=\"hljs-comment\"&gt;// 定义边的结构体&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;, weight; &lt;span class=\"hljs-comment\"&gt;// to表示边的终点&amp;#xff0c;weight表示边的权值&lt;/span&gt;\n};\n\nvector&amp;lt;Edge&amp;gt; adj&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n\nvoid add&lt;span class=\"hljs-constructor\"&gt;Edge(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;u&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;)&lt;/span&gt;\n{                              &lt;span class=\"hljs-comment\"&gt;// 添加边的函数&lt;/span&gt;\n    adj&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt;.push&lt;span class=\"hljs-constructor\"&gt;_back({&lt;!-- --&gt;&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;})&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 将边(u, v)加入邻接表&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; A&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt; &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (A&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; !&amp;#61; INF)\n            {                            &lt;span class=\"hljs-comment\"&gt;// 如果A[i][j]不是∞&amp;#xff0c;说明存在边(i, j)&lt;/span&gt;\n                add&lt;span class=\"hljs-constructor\"&gt;Edge(&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;j&lt;/span&gt;, A[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;][&lt;span class=\"hljs-params\"&gt;j&lt;/span&gt;])&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 将边(i, j)加入邻接表&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n                { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n                    {\n                        cout &amp;lt;&amp;lt; A&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 输出A[i][j]&lt;/span&gt;\n                    }\n                    cout &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出换行符&lt;/span&gt;\n                }\n            }\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、利用DFS或者BFS算法遍历该图&amp;#xff0c;找到图中权值最小的边。首先是DFS。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Edge&lt;/span&gt;\n{                    &lt;span class=\"hljs-comment\"&gt;// 定义边的结构体&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to, weight; &lt;span class=\"hljs-comment\"&gt;// to表示边的终点&amp;#xff0c;weight表示边的权值&lt;/span&gt;\n};\n\nvector&amp;lt;Edge&amp;gt; adj[N]; &lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;addEdge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w)&lt;/span&gt;\n&lt;/span&gt;{                              &lt;span class=\"hljs-comment\"&gt;// 添加边的函数&lt;/span&gt;\n    adj[u].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;({v, w}); &lt;span class=\"hljs-comment\"&gt;// 将边(u, v)加入邻接表&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, vector&amp;lt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt;&amp;gt; &amp;amp;visited, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;min_weight)&lt;/span&gt;\n&lt;/span&gt;{                       &lt;span class=\"hljs-comment\"&gt;// 定义DFS遍历的函数&lt;/span&gt;\n    visited[u] &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 标记顶点u为已访问&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Edge &amp;amp;e : adj[u])\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历顶点u的所有出边&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; e.to;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w &amp;#61; e.weight;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[v])\n        {                                     &lt;span class=\"hljs-comment\"&gt;// 如果顶点v未被访问过&lt;/span&gt;\n            min_weight &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_weight, w); &lt;span class=\"hljs-comment\"&gt;// 更新最小边权值&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(v, visited, min_weight);     &lt;span class=\"hljs-comment\"&gt;// 递归调用DFS遍历&lt;/span&gt;\n        }\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (A[i][j] !&amp;#61; INF)\n            {                            &lt;span class=\"hljs-comment\"&gt;// 如果A[i][j]不是∞&amp;#xff0c;说明存在边(i, j)&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;addEdge&lt;/span&gt;(i, j, A[i][j]); &lt;span class=\"hljs-comment\"&gt;// 将边(i, j)加入邻接表&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min_weight &amp;#61; INF;                              &lt;span class=\"hljs-comment\"&gt;// 定义最小边权值初始值为∞&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;vector&amp;lt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-title\"&gt;visited&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(N, &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;                      &lt;span class=\"hljs-comment\"&gt;// 定义访问数组&amp;#xff0c;初始值全部为false&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, visited, min_weight);                      &lt;span class=\"hljs-comment\"&gt;// 从顶点0开始遍历图&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Minimum weight: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; min_weight &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出最小边权值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其次是BFS&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Edge&lt;/span&gt;\n{                    &lt;span class=\"hljs-comment\"&gt;// 定义边的结构体&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to, weight; &lt;span class=\"hljs-comment\"&gt;// to表示边的终点&amp;#xff0c;weight表示边的权值&lt;/span&gt;\n};\n\nvector&amp;lt;Edge&amp;gt; adj[N]; &lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;addEdge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w)&lt;/span&gt;\n&lt;/span&gt;{                              &lt;span class=\"hljs-comment\"&gt;// 添加边的函数&lt;/span&gt;\n    adj[u].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;({v, w}); &lt;span class=\"hljs-comment\"&gt;// 将边(u, v)加入邻接表&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;bfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;min_weight)&lt;/span&gt;\n&lt;/span&gt;{                                    &lt;span class=\"hljs-comment\"&gt;// 定义BFS遍历的函数&lt;/span&gt;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; q;                    &lt;span class=\"hljs-comment\"&gt;// 定义队列&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;vector&amp;lt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-title\"&gt;visited&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(N, &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义访问数组&amp;#xff0c;初始值全部为false&lt;/span&gt;\n    visited[u] &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;                &lt;span class=\"hljs-comment\"&gt;// 标记顶点u为已访问&lt;/span&gt;\n    q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(u);                        &lt;span class=\"hljs-comment\"&gt;// 将顶点u加入队列&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!q.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;())\n    {                       &lt;span class=\"hljs-comment\"&gt;// 当队列不为空时&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;(); &lt;span class=\"hljs-comment\"&gt;// 取出队首元素&lt;/span&gt;\n        q.&lt;span class=\"hljs-built_in\"&gt;pop&lt;/span&gt;();           &lt;span class=\"hljs-comment\"&gt;// 弹出队首元素&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Edge &amp;amp;e : adj[x])\n        { &lt;span class=\"hljs-comment\"&gt;// 遍历顶点x的所有出边&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; e.to;\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w &amp;#61; e.weight;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[v])\n            {                                     &lt;span class=\"hljs-comment\"&gt;// 如果顶点v未被访问过&lt;/span&gt;\n                visited[v] &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;                 &lt;span class=\"hljs-comment\"&gt;// 标记顶点v为已访问&lt;/span&gt;\n                min_weight &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_weight, w); &lt;span class=\"hljs-comment\"&gt;// 更新最小边权值&lt;/span&gt;\n                q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(v);                         &lt;span class=\"hljs-comment\"&gt;// 将顶点v加入队列&lt;/span&gt;\n            }\n        }\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (A[i][j] !&amp;#61; INF)\n            {                            &lt;span class=\"hljs-comment\"&gt;// 如果A[i][j]不是∞&amp;#xff0c;说明存在边(i, j)&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;addEdge&lt;/span&gt;(i, j, A[i][j]); &lt;span class=\"hljs-comment\"&gt;// 将边(i, j)加入邻接表&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min_weight &amp;#61; INF;                              &lt;span class=\"hljs-comment\"&gt;// 定义最小边权值初始值为∞&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, min_weight);                                  &lt;span class=\"hljs-comment\"&gt;// 从顶点0开始遍历图&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Minimum weight: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; min_weight &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出最小边权值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;4、设计一个基于Floyd的最短路径算法&amp;#xff0c;计算所有顶点之间的最短路径。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; N; k&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历所有顶点&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n            {\n                A[i][j] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(A[i][j], A[i][k] &amp;#43; A[k][j]); &lt;span class=\"hljs-comment\"&gt;// 更新最短路径&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 输出最短路径矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; A[i][j] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        }\n        cout &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;以上就是ChatGPT给出的答案&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["利用c++解决图论问题", ["1、利用随机数原理，随机产生一个二维数组A（30*30），其中对角线元素为零，剩余元素中的50%是∞，其余元素的值为大于0的随机数。", "2、将上述二维数组作为图的邻接矩阵，以该数组作为输入，创建一个图形结构，该图使用邻接表作为存储结构。", "3、利用DFS或者BFS算法遍历该图，找到图中权值最小的边。", "4、设计一个基于Floyd的最短路径算法，计算所有顶点之间的最短路径。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/Autumn_1/article/details/120704004\" id=\"textarea_1654690889500_1654690932727_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;java实现老鼠迷宫游戏_小小寂寞的城的博客-CSDN博客_老鼠迷宫java&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;最近学java,在递归部分看到老鼠迷宫游戏,感觉挺有意思,记录一下我们可以把迷宫当成一个二位数组,其中1代表障碍物,走不了,初始化一个二维数组,设置好障碍物//老鼠迷宫        int[][] map &amp;#61; {                {1,1,1,1,1,1,1,1},                {1,0,0,0,0,0,0,1},                {1,1,0,0,0,0,0,1},                {1,0,1,0,0,0,0,1},     &lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/Autumn_1/article/details/120704004&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["Java语言迷宫鼠详解", ["（1）概述：用java面向对象程序设计语言，设计和实现一电脑鼠走迷宫的软件程序，", "即一个假想的小车能在图示的迷宫中根据设定的起始点和终点自主寻找路径。", "（2）迷宫地图生成算法的设计和实现", "自动生成迷宫：根据迷宫生成算法自动生成一定复杂度的迷宫地图。", "手动生成迷宫：根据文件中存储的固定数据生成迷宫地图。", "单路径寻找算法的设计与实现：找出迷宫中一条单一的通路。", "迷宫遍历算法的设计与实现：遍历迷宫中所有的可行路径。", "最短路径计算算法的设计与实现：根据遍历结果，找出迷宫中所有通路中的最短通", "路。", "（3）通过动画展示出迷宫鼠在迷宫内的运动。", "（4)具有判断通路和障碍的功能；走不通具备返回的能力（路径记忆）；能够寻找最短路径；"]], "Tag": "算法设计"}
{"Answer": "只将有多条可行路径的点入栈就可以，每一个点从正确性上说也可以，但是不优化。", "Konwledge_Point": "最短路径", "Question": ["想问大家C语言数据结构一个学术问题", ["大家用C语言做迷宫最短路径问题，是将可行路径上的每一个经过的点都入栈，还是仅仅只将有多条可行路径的点入栈呀。我又看了下书，好像懂了QAQ，不过还是欢迎大佬提点一下。", "\n\n", "                                    拜托各位大佬的指点了\n"]], "Tag": "算法设计"}
{"Answer": "[http://www.it165.net/pro/html/201407/16957.html](http://www.it165.net/pro/html/201407/16957.html \"\")", "Konwledge_Point": "最短路径", "Question": ["c语言课程设计分油问题", ["输入三个油瓶容量与目标容量， 用邻接矩阵求它的最短路径   ，先判断两点间有没有路 最短路是什么，  调用邻接矩阵函数求   。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这个正无穷是初始化的时候的&amp;#xff0c;初始化标记正无穷大表示该点无法到达&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这个地方的正无穷是如何看出来的，能否解释一下", ["这个地方的正无穷是如何看的，最短路径。就是比如v1那个有一个正无穷，v5那有四个正无穷，这个正无穷数量该怎么看。"]], "Tag": "算法设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;不停刷题&amp;#xff0c;刷开源代码&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "最短路径", "Question": ["大三学生如何提升代码能力", ["作为一名普通本科计算机专业大三的学生，应当具备怎样的代码能力？我只对c和c++比较熟悉，一些算法比如最短路径，我能手写在纸上，但调试总需要很久。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;非常抱歉&amp;#xff0c;本次您提出的有问必答问题&amp;#xff0c;技术专家团超时未为您做出解答&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;本次提问扣除的有问必答次数&amp;#xff0c;将会以问答VIP体验卡&amp;#xff08;1次有问必答机会、商城购买实体图书享受95折优惠&amp;#xff09;的形式为您补发到账户。&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;因为有问必答VIP体验卡有效期仅有1天&amp;#xff0c;您在需要使用的时候【私信】联系我&amp;#xff0c;我会为您补发。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["关于#matlab# #算法# #python#的问题：校园导航制作", ["需要录入许多个位置点，要怎么录入呢？利用算法快速获得最短路径，我打算使用弗洛伊德算法做，但是无从入手，算法具体应该怎么做，还有还有，这个算法适合做导航吗，请救救孩子吧wwww～ballballyou！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;如果需要展示地图的话还是要调用地图接口的 看你这边的话应该用的是原生js走的&lt;br /&gt;你可以看一下我之前写的调用 高德地图的文章&amp;#xff0c;应该还是比较适用你现在这种情况的&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/084675443146199.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/clli_Chain/article/details/107982453?spm&amp;#61;1001.2014.3001.5502\" id=\"textarea_1641344400250_1641344593085_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/clli_Chain/article/details/107982453?spm&amp;#61;1001.2014.3001.5502&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["怎么把搜索结果界面展示在搜索框下面", ["做一个查询路线的界面，现在需要在搜索框搜索之后，把搜索结果就展示在搜索框的下方位置，应该怎么做", "\n", "把各种最短路径之类的展示在中间的小框里面", "要把查询出来的地图路线展示在下方的大框里面，", "应该怎么做啊"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个问题就是一个加权无向图的最小路径求解的问题&amp;#xff0c;我给个例子你参考一下&amp;#xff0c;直接用现成的算法实现的&amp;#xff0c;代码并不复杂&amp;#xff0c;看看是否符合你的要求&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-built_in\"&gt;import&lt;/span&gt; matplotlib.pyplot as plt\n&lt;span class=\"hljs-built_in\"&gt;import&lt;/span&gt; networkx\n\n&lt;span class=\"hljs-attr\"&gt;G2&lt;/span&gt; &amp;#61; networkx.Graph()  &lt;span class=\"hljs-comment\"&gt;# 创建&amp;#xff1a;空的 无向图&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#创建加权边&amp;#xff0c;a、b、c等代表城市&amp;#xff0c;后边的值代表乘车时间&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;edges&lt;/span&gt; &amp;#61; [(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;13&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;), \n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;k&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;l&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;m&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;),\n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;),\n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;h&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;h&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;),\n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;j&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;j&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;k&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;k&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;l&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;l&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;m&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)]\nG2.add_weighted_edges_from(edges)  &lt;span class=\"hljs-comment\"&gt;# 向图中添加多条赋权边: (node1,node2,weight)&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#指定要求解的两个点&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;source&lt;/span&gt; &amp;#61; &amp;#39;b&amp;#39;\n&lt;span class=\"hljs-attr\"&gt;target&lt;/span&gt; &amp;#61; &amp;#39;f&amp;#39;\n&lt;span class=\"hljs-comment\"&gt;# 两个指定顶点之间的最短加权路径&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;minWPath&amp;#61;&lt;/span&gt; networkx.dijkstra_path(G2, &lt;span class=\"hljs-attr\"&gt;source&amp;#61;source,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;target&amp;#61;target)&lt;/span&gt;\nprint(f&lt;span class=\"hljs-string\"&gt;&amp;#34;顶点 {source} 到 顶点 {target} 的最短加权路径: {minWPath}&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-comment\"&gt;# 两个指定顶点之间的最短加权路径的长度&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;lMinWPath&lt;/span&gt; &amp;#61; networkx.dijkstra_path_length(G2, &lt;span class=\"hljs-attr\"&gt;source&amp;#61;source,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;target&amp;#61;target)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;#最短加权路径长度&lt;/span&gt;\nprint(f&lt;span class=\"hljs-string\"&gt;&amp;#34;顶点 {source} 到 顶点 {target} 的最短加权路径长度: {lMinWPath}&amp;#34;&lt;/span&gt;)\n\n&lt;span class=\"hljs-attr\"&gt;pos&lt;/span&gt; &amp;#61; networkx.spring_layout(G2)  &lt;span class=\"hljs-comment\"&gt;# 用 FR算法排列节点&lt;/span&gt;\nnetworkx.draw(G2, pos, &lt;span class=\"hljs-attr\"&gt;with_labels&amp;#61;True,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;alpha&amp;#61;0.5)&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#画所有节点&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;labels&lt;/span&gt; &amp;#61; networkx.get_edge_attributes(G2,&amp;#39;weight&amp;#39;) &lt;span class=\"hljs-comment\"&gt;#取加权值为标签&lt;/span&gt;\nnetworkx.draw_networkx_edge_labels(G2, pos, &lt;span class=\"hljs-attr\"&gt;edge_labels&lt;/span&gt; &amp;#61; labels) &lt;span class=\"hljs-comment\"&gt;#画边和标签&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;posCopy&lt;/span&gt; &amp;#61; pos.copy()  &lt;span class=\"hljs-comment\"&gt;#复制所有节点&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;edgesCopy&lt;/span&gt; &amp;#61; [] &lt;span class=\"hljs-comment\"&gt;#最小路径加权边&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#遍历所有节点&amp;#xff0c;保留最小路径相关节点&lt;/span&gt;\nfor k &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; pos.keys():\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; k not &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; minWPath:\n        posCopy.pop(k)\n&lt;span class=\"hljs-comment\"&gt;#遍历所有加权边&amp;#xff0c;取出最小路径相关加权边&lt;/span&gt;\nfor i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; range(len(minWPath)-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;):\n    for edge &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; edges:\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; minWPath[i] &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; edge &lt;span class=\"hljs-literal\"&gt;and&lt;/span&gt;  minWPath[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; edge:\n            edgesCopy.append(edge)\n            break\n&lt;span class=\"hljs-attr\"&gt;minG2&lt;/span&gt; &amp;#61; networkx.Graph() &lt;span class=\"hljs-comment\"&gt;#创建空无向图&lt;/span&gt;\nminG2.add_weighted_edges_from(edgesCopy) &lt;span class=\"hljs-comment\"&gt;#向图中添加最小路径加权边&lt;/span&gt;\nnetworkx.draw(minG2, posCopy, &lt;span class=\"hljs-attr\"&gt;with_labels&amp;#61;False,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;alpha&amp;#61;1,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;edge_color&amp;#61;&amp;#39;red&amp;#39;)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;#用红色标记最小路径边&lt;/span&gt;\nplt.show()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/021541002156147.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["尽快，求解以下问题如图中第五题的程序要求，文件夹压缩包的形式发我，最好于4月30号中午12点前发我", ["求解最短路径", "提供算法思想描述，程序结构，测试结果", "\n", "设有n(n> 10)个城市之间的交通图。假设任意两个城市之间不一定有直接交通线路，权表示乘车时间。要求事先将交通图信息将存人磁盘文件中，求从某城市出发到其他城市的最少乘车时间和乘车路线。要求将结果以图形方式在屏幕上输出。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;运行结果&amp;#xff08;ctrl&amp;#43;z结束输入&amp;#xff0c;vs2022需要连续输入3次才ctrl&amp;#43;z可以&amp;#xff09;&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/318529884076145.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#define _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;#define MM 100&lt;/span&gt;\n\n\n&lt;span class=\"hljs-comment\"&gt;//站点信息&lt;/span&gt;\ntypedef struct node\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; cost;      &lt;span class=\"hljs-comment\"&gt;//两个站点间的花费&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; vexnode;   &lt;span class=\"hljs-comment\"&gt;//顶点编号&lt;/span&gt;\n    char name[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//站点名称&lt;/span&gt;\n    struct node* next;\n}Arcnode;\n\ntypedef struct _graph\n{\n    Arcnode* point[MM];\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;  vexnum;\n} graph;\n&lt;span class=\"hljs-comment\"&gt;//队列&lt;/span&gt;\ntypedef struct queue\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; father;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; son;\n    struct queue* next;\n}queue;\n\nqueue* init_queue()\n{\n    queue* head &amp;#61; (queue*)malloc(sizeof(queue));\n    head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;\n}\n&lt;span class=\"hljs-comment\"&gt;//1为空&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;empty&lt;/span&gt;(queue* head)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//入栈&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push(queue* head, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; j)   &lt;span class=\"hljs-comment\"&gt;// i:father point   j:son point&lt;/span&gt;\n{\n    queue* tmp &amp;#61; head;\n    queue* nn &amp;#61; (queue*)malloc(sizeof(queue));\n    nn-&amp;gt;father &amp;#61; j;\n    nn-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//nn-&amp;gt;son &amp;#61; j;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (tmp-&amp;gt;next)\n        tmp &amp;#61; tmp-&amp;gt;next;\n    tmp-&amp;gt;next &amp;#61; nn;\n\n}\n&lt;span class=\"hljs-comment\"&gt;//出栈&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; pop(queue* head, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;* i, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;* j)\n{\n    queue* tmp &amp;#61; head;\n    queue* pre &amp;#61; head;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head-&amp;gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        *j &amp;#61; head-&amp;gt;father;\n        free(head);\n        head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        tmp &amp;#61; head-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (tmp-&amp;gt;next)\n        {\n            pre &amp;#61; tmp;\n            tmp &amp;#61; tmp-&amp;gt;next;\n        }\n        *j &amp;#61; tmp-&amp;gt;father;\n        free(tmp);\n        pre-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//根据名字查找节点是否存在&amp;#xff0c;如果存在返回节点编号&amp;#xff0c;否则返回-1&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; findVertex(graph* g, char* name)\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; g-&amp;gt;vexnum; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(g-&amp;gt;point[i]-&amp;gt;name, name) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//读数据并创建图&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt;  readAndCreatGraph(graph* g)\n{\n    Arcnode* tmpnode, * curnode,*head;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, j;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; cost;\n    char name[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, dst[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    g-&amp;gt;vexnum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %d&amp;#34;&lt;/span&gt;,name,dst,&amp;amp;cost)!&amp;#61; EOF)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//查看节点是否已经存在&lt;/span&gt;\n        i &amp;#61; findVertex(g, name);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//节点不存在&lt;/span&gt;\n        {\n            curnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            curnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            strcpy(curnode-&amp;gt;name, name);\n            &lt;span class=\"hljs-comment\"&gt;//创建当前节点的链表&lt;/span&gt;\n            head &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            head-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            curnode-&amp;gt;next &amp;#61; head; &lt;span class=\"hljs-comment\"&gt;//第一个节点不存储内容&lt;/span&gt;\n            g-&amp;gt;point[g-&amp;gt;vexnum] &amp;#61; curnode;\n            g-&amp;gt;vexnum &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//个数加1&lt;/span&gt;\n\n            &lt;span class=\"hljs-comment\"&gt;//将目的节点插入链表&lt;/span&gt;\n            j &amp;#61; findVertex(g, dst);\n            curnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            curnode-&amp;gt;cost &amp;#61; cost;\n            curnode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            strcpy(curnode-&amp;gt;name, dst);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                curnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                curnode-&amp;gt;vexnode &amp;#61; j;\n            &lt;span class=\"hljs-comment\"&gt;//将节点插入&lt;/span&gt;\n            head-&amp;gt;next &amp;#61; curnode;\n\n            &lt;span class=\"hljs-comment\"&gt;//如果目的节点不再图中&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            {\n                tmpnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                tmpnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                strcpy(tmpnode-&amp;gt;name, dst);\n                head &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                head-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                tmpnode-&amp;gt;next &amp;#61; head;\n                g-&amp;gt;point[g-&amp;gt;vexnum] &amp;#61; tmpnode;\n                g-&amp;gt;vexnum &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//节点数&amp;#43;1&lt;/span&gt;\n            }\n            \n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-comment\"&gt;//源节点已经存在&lt;/span&gt;\n            tmpnode &amp;#61; g-&amp;gt;point[i]-&amp;gt;next; &lt;span class=\"hljs-comment\"&gt;//得到链表头&lt;/span&gt;\n            curnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            curnode-&amp;gt;cost &amp;#61; cost;\n            curnode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            strcpy(curnode-&amp;gt;name, dst);\n            j &amp;#61; findVertex(g, dst); &lt;span class=\"hljs-comment\"&gt;//看看目的节点是否已经存在&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                curnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                curnode-&amp;gt;vexnode &amp;#61; j;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (tmpnode-&amp;gt;next)\n                tmpnode &amp;#61; tmpnode-&amp;gt;next;\n            tmpnode-&amp;gt;next &amp;#61; curnode;\n\n            &lt;span class=\"hljs-comment\"&gt;//如果目的节点不存在&amp;#xff0c;将该节点插入图中&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            {\n                tmpnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                tmpnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                strcpy(tmpnode-&amp;gt;name, dst);\n                head &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                head-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                tmpnode-&amp;gt;next &amp;#61; head;\n                g-&amp;gt;point[g-&amp;gt;vexnum] &amp;#61; tmpnode;\n                g-&amp;gt;vexnum &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n        \n\n    }\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//找最短路径&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; dijkstra(graph* g)\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; inqueue[MM] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };  &lt;span class=\"hljs-comment\"&gt;//是否已经入栈&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; id, start_s;\n    Arcnode* ns &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    queue* last &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//队列的最后一个元素&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; una, unb, xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, yy &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    queue* head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pathMin[MM] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };                &lt;span class=\"hljs-comment\"&gt;//最短路径&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pathTmp[MM] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };                &lt;span class=\"hljs-comment\"&gt;//临时路径&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; minDistance &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, tmpdis &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;       &lt;span class=\"hljs-comment\"&gt;//最短路径距离&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; lengpath &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, minpathlen &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;       &lt;span class=\"hljs-comment\"&gt;//最短路径点个数&lt;/span&gt;\n    queue* qMin &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; kktt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, vv &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; start, end; &lt;span class=\"hljs-comment\"&gt;//起点和终点&lt;/span&gt;\n    char str_start[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;], str_end[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; flags[MM][MM];\n    &lt;span class=\"hljs-comment\"&gt;//system(&amp;#34;cls&amp;#34;);&lt;/span&gt;\n\n\n    &lt;span class=\"hljs-comment\"&gt;//显示地图信息&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//showBaseInfo(g);&lt;/span&gt;\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入起点和终点:&amp;#34;&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s&amp;#34;&lt;/span&gt;, str_start , str_end);\n    start &amp;#61; findVertex(g,str_start);\n    end &amp;#61; findVertex(g,str_end);\n\n    &lt;span class=\"hljs-comment\"&gt;//初始化邻接矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; MM; xx&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (yy &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; yy &amp;lt; MM; yy&amp;#43;&amp;#43;)\n            flags[xx][yy] &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; g-&amp;gt;vexnum; xx&amp;#43;&amp;#43;)\n    {\n        ns &amp;#61; g-&amp;gt;point[xx]-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (ns)\n        {\n            flags[xx][ns-&amp;gt;vexnode] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            ns &amp;#61; ns-&amp;gt;next;\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//起点入栈&lt;/span&gt;\n    head &amp;#61; init_queue();\n    head-&amp;gt;father &amp;#61; start;\n    inqueue[start] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//起点已入栈&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!&lt;span class=\"hljs-keyword\"&gt;empty&lt;/span&gt;(head))\n    {\n        &lt;span class=\"hljs-comment\"&gt;//获取队列中的最后一个元素&lt;/span&gt;\n        last &amp;#61; head;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (last-&amp;gt;next)\n            last &amp;#61; last-&amp;gt;next;\n        start_s &amp;#61; last-&amp;gt;father;\n\n        &lt;span class=\"hljs-comment\"&gt;//获取队列中最后一个元素的一个可到达的站&lt;/span&gt;\n        id &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; g-&amp;gt;vexnum; xx&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flags[start_s][xx] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                flags[start_s][xx] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                id &amp;#61; xx;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//如果未找到&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (id &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            pop(head, &amp;amp;una, &amp;amp;unb); &lt;span class=\"hljs-comment\"&gt;//栈弹出一个元素&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (unb &amp;#61;&amp;#61; start) head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-comment\"&gt;//查找unb所有相邻节点&amp;#xff0c;并将其状态设为未访问&lt;/span&gt;\n\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; MM; xx&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flags[unb][xx] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) flags[unb][xx] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            }\n\n            inqueue[start_s] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//该顶点标记为未入栈&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;             &lt;span class=\"hljs-comment\"&gt;//取栈顶的相邻节点&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (inqueue[id])  &lt;span class=\"hljs-comment\"&gt;//若已经在栈中&amp;#xff0c;取下一个顶点&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n\n\n        push(head, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, id);            &lt;span class=\"hljs-comment\"&gt;//将该顶点入栈&lt;/span&gt;\n        inqueue[id] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;//记为已入栈&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (id &amp;#61;&amp;#61; end)              &lt;span class=\"hljs-comment\"&gt;//如果栈顶已经为所求&amp;#xff0c;将此路径记录&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-comment\"&gt;//-----------------计算路径的长度-----------------------------&lt;/span&gt;\n            qMin &amp;#61; head;\n            lengpath &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (qMin)\n            {\n                pathTmp[lengpath] &amp;#61; qMin-&amp;gt;father;\n                lengpath&amp;#43;&amp;#43;;\n                qMin &amp;#61; qMin-&amp;gt;next;\n            }\n            tmpdis &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (kktt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; kktt &amp;lt; lengpath - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; kktt&amp;#43;&amp;#43;)\n            {\n                vv &amp;#61; pathTmp[kktt];\n                ns &amp;#61; g-&amp;gt;point[vv]-&amp;gt;next;\n                &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (ns)\n                {\n                    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ns-&amp;gt;vexnode &amp;#61;&amp;#61; pathTmp[kktt &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n                    {\n                        tmpdis &amp;#43;&amp;#61; ns-&amp;gt;cost;\n                        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n                    }\n                    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                        ns &amp;#61; ns-&amp;gt;next;\n                }\n            }\n\n            &lt;span class=\"hljs-comment\"&gt;//显示所有路径&lt;/span&gt;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;花费&amp;#61;%d : &amp;#34;&lt;/span&gt;, tmpdis);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; ( xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; lengpath; xx&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//int&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (xx &amp;lt; lengpath - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s --&amp;gt; &amp;#34;&lt;/span&gt;, g-&amp;gt;point[pathTmp[xx]]-&amp;gt;name);\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;,g-&amp;gt;point[pathTmp[xx]]-&amp;gt;name );\n            }\n            &lt;span class=\"hljs-comment\"&gt;//找最短路径&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (minDistance &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || minDistance &amp;gt; tmpdis)\n            {\n                minDistance &amp;#61; tmpdis;\n                minpathlen &amp;#61; lengpath;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; ( xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; lengpath; xx&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//int&lt;/span&gt;\n                    pathMin[xx] &amp;#61; pathTmp[xx];\n            }\n\n            &lt;span class=\"hljs-comment\"&gt;//--------------------------------------------------------------&lt;/span&gt;\n            pop(head, &amp;amp;una, &amp;amp;unb); &lt;span class=\"hljs-comment\"&gt;//将其弹出&amp;#xff0c;继续探索&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (unb &amp;#61;&amp;#61; start) head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            inqueue[id] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//清空入栈的标志位&lt;/span&gt;\n        }\n    } &lt;span class=\"hljs-comment\"&gt;//while end&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//打印最短路径&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (minDistance &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;无可用路径\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n最小花费:%d:&amp;#34;&lt;/span&gt;, minDistance);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (kktt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; kktt &amp;lt; minpathlen; kktt&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (kktt &amp;lt; minpathlen - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s --&amp;gt; &amp;#34;&lt;/span&gt;, g-&amp;gt;point[pathMin[kktt]]-&amp;gt;name);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, g-&amp;gt;point[pathMin[kktt]]-&amp;gt;name);\n    }\n}\n\n\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    graph g;\n    g.vexnum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    readAndCreatGraph(&amp;amp;g);\n    dijkstra(&amp;amp;g);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["迪杰斯特拉算法之解决最省钱的出游方案", ["用迪杰斯特拉最短路径算法解决最省钱的出游方案。即给定一个出发地和目的地，给出最省钱的出游方案。各地票价如下：", "\n", "出发地 目的地 票价", "广州 北京 1000", "广州 深圳 200", "广州 上海 800", "深圳 北京 700", "深圳 上海 600", "深圳 拉萨1000", "北京 广州 1000", "北京 上海 500", "北京 深圳 700", "上海 广州 700", "上海 北京 500", "上海 深圳 700", "上海 拉萨1200", "拉萨 上海 1100"]], "Tag": "算法设计"}
{"Answer": "刚才到网上搜索到了一份A*算法的javascript实现.效果不错.\r\n楼主去看一下吧:[url]http://www.gissky.com/Download/ShowSoft.Asp?Type=4&amp;ID=218[/url]\r\n不过代码没什么注释..看起来可能会有点头痛.", "Konwledge_Point": "最短路径", "Question": ["求算法", ["从A点（0，0）到B点（100，100）的最短路径", "\n\n", "如路线上存在障碍物，求绕过障碍物的最短路线", "\n[b]问题补充：[/b]", "\n其实我是自己无聊的时候在做html小游戏时遇到的问题， 我点击页面某一点， 然后页面中的小球则向我的点击坐标移动。", "\n那么在JS中又怎样实现这算法呢？", "\n这方面我还是太白，……"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;什么错误&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["莫名的错误帮我看看吧", ["\n", "这个错误很离谱，这是一个求图的最短路径代码，m和n分别表示起点和终点，但是如这个图所示，我cin两个指，然后调用shorts函数，这样程序运行时就会调用shorts函数失败，但如果我直接int m=0，n=5。这样它又能运行成功，感觉很疑惑，请教各位教导"]], "Tag": "算法设计"}
{"Answer": "关于(*D)[v][w]和(D)[v][w]的含义和区别，以及引发异常的原因解读\r\n\r\n\r\n```c++\r\n// 解读你的部分代码\r\n#define MAXVEX 20\r\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\r\nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)\r\n{\r\n\t/* \r\n\t * 此处 D 的原型表达式为： int (*)[20][20]\r\n\t *\r\n\t * 1）说明 D 是一个指针（三维数组指针），指向一个整型的二维数组。该二维\r\n\t * 数组的长度是20*20=400，即D的步长是400\r\n\t * \r\n\t * 2）而 *D 则是一个整型的二维数组，或者称 *D 是一个指向非常量的常量指\r\n\t * 针，或者被称为行指针，步长为20\r\n\t */\r\n\r\n\t int v,w;\r\n\r\n\t/*\r\n\t * 此处 (*D)[v][w] 表示二维数组第 v 行第 w 列元素的值。用指针表达式\r\n\t * 为： (*D)[v][w] = *((*D)[v]+w) = *(*((*D)+v)+w)  【地址偏移量=v*20+w】\r\n\t */\r\n\t (*D)[v][w]=...;\r\n\r\n\t/*\r\n\t * 此处 (D)[v][w] 表示三维数组指针 D 的下标运算，指向第 v 行（每行步长\r\n\t * 为400）第 w 列（每列步长20）的整型一维数组（形参为 int [20]）。指针地址表达式\r\n\t * 为： (D)[v][w] = *(D[v])+w = **(D+v)+w 【地址偏移量=v*400+w*20】\r\n\t *\r\n\t * PS: (D)[v][w] = D[v][w] = &amp;(D[v][w][0])\r\n\t * \r\n\t * 【异常】注意指针表达式中的v、w在下标运算中与形参（int [_v][_w]）行列下标是错位的，实际对应的是整型的\r\n\t * 三维数组（int [v][w][0]）下标顺序。很明显只要v&gt;0时，该行代码就会发生指针越界引发异常（行下标越界）\r\n\t */\r\n\t(D)[v][w]=...;\r\n\r\n\t// PPS:\r\n\t/*\r\n\t * 此处 *D[v][w] 表示一维数组第w个元素的值。用指针表达式\r\n\t * 为： *(*(D[v])+w) = *(**(D+v)+w) 【地址偏移量=v*400+w*20+0】\r\n\t *\r\n\t * PPPS: *D[v][w] = *(D[v][w]) = D[v][w][0]\r\n\t */\r\n\t*D[v][w]=...;\r\n}\r\n\r\n```\r\n\r\n---\r\n如果要使用 (D)[v][w] 作为实参计算是可以的哈，只需要改变函数形参即可，代码如下：\r\n\r\n```c++\r\n/**\r\n  * 新变量类型ShortPathTable实质也是一个二维数组，而使用二维数组作为函数参数，函\r\n  * 数调用时传递的是一个指针，不会发生构造拷贝。因此函数内的值修改，其实是在原地\r\n  * 址进行修改，函数返回后当然会保留修改后的值。\r\n  */\r\nvoid ShortestPath_Floyd(MGraph G, Patharc P, ShortPathTable D)\r\n{\r\n\tint v,w,k;\r\n\r\n\t// 此处 (D)[v][w] 表示整型二维数组的第 v 行第 w 列元素的值（表达式是正确的）\r\n\t(D)[v][w]=(D)[v][k]+(D)[k][w];\r\n}\r\n\r\n```", "Konwledge_Point": "最短路径", "Question": ["(*D)[v][w]为何要加上*，不加*程序可以运行但是会出错这是为什么？", ["\n\n", "#include \"stdio.h\"    \n#include \"stdlib.h\"   \n#include \"io.h\"  \n#include \"math.h\"  \n#include \"time.h\"\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n#define MAXEDGE 20\n#define MAXVEX 20\n#define INFINITY 65535\n\ntypedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */\n\ntypedef struct\n{\n    int vexs[MAXVEX];\n    int arc[MAXVEX][MAXVEX];\n    int numVertexes, numEdges;\n}MGraph;\n\ntypedef int Patharc[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\n/* 构件图 */\nvoid CreateMGraph(MGraph *G)\n{\n    int i, j;\n\n    /* printf(\"请输入边数和顶点数:\"); */\n    G->numEdges=16;\n    G->numVertexes=9;\n\n    for (i = 0; i < G->numVertexes; i++)/* 初始化图 */\n    {\n        G->vexs[i]=i;\n    }\n\n    for (i = 0; i < G->numVertexes; i++)/* 初始化图 */\n    {\n        for ( j = 0; j < G->numVertexes; j++)\n        {\n            if (i==j)\n                G->arc[i][j]=0;\n            else\n                G->arc[i][j] = G->arc[j][i] = INFINITY;\n        }\n    }\n\n    G->arc[0][1]=1;\n    G->arc[0][2]=5; \n    G->arc[1][2]=3; \n    G->arc[1][3]=7; \n    G->arc[1][4]=5; \n\n    G->arc[2][4]=1; \n    G->arc[2][5]=7; \n    G->arc[3][4]=2; \n    G->arc[3][6]=3; \n    G->arc[4][5]=3;\n\n    G->arc[4][6]=6;\n    G->arc[4][7]=9; \n    G->arc[5][7]=5; \n    G->arc[6][7]=2; \n    G->arc[6][8]=7;\n\n    G->arc[7][8]=4;\n\n\n    for(i = 0; i < G->numVertexes; i++)\n    {\n        for(j = i; j < G->numVertexes; j++)\n        {\n            G->arc[j][i] =G->arc[i][j];\n        }\n    }\n\n}\n\n/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    \nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)\n{    \n    int v,w,k;    \n    for(v=0; v<G.numVertexes; ++v) /* 初始化D与P */  \n    {        \n        for(w=0; w<G.numVertexes; ++w)  \n        {\n            (*D)[v][w]=G.arc[v][w]; /* D[v][w]值即为对应点间的权值 */\n            (*P)[v][w]=w;               /* 初始化P */\n        }\n    }\n    for(k=0; k<G.numVertexes; ++k)   \n    {\n        for(v=0; v<G.numVertexes; ++v)  \n        {        \n            for(w=0; w<G.numVertexes; ++w)    \n            {\n                if ((*D)[v][w]>(*D)[v][k]+(*D)[k][w])\n                {/* 如果经过下标为k顶点路径比原两点间路径更短 */\n                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */\n                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */\n                }\n            }\n        }\n    }\n}\n\nint main(void)\n{    \n    int v,w,k;  \n    MGraph G;    \n\n    Patharc P;    \n    ShortPathTable D; /* 求某点到其余各点的最短路径 */   \n\n    CreateMGraph(&G);\n\n    ShortestPath_Floyd(G,&P,&D);  \n\n    printf(\"各顶点间最短路径如下:\\n\");  \n    for(v=0; v<G.numVertexes; ++v)   \n    {        \n        for(w=v+1; w<G.numVertexes; w++)  \n        {\n            printf(\"v%d-v%d weight: %d \",v,w,D[v][w]);\n            k=P[v][w];              /* 获得第一个路径顶点下标 */\n            printf(\" path: %d\",v);  /* 打印源点 */\n            while(k!=w)             /* 如果路径顶点下标不是终点 */\n            {\n                printf(\" -> %d\",k); /* 打印路径顶点 */\n\n                k=P[k][w];          /* 获得下一个路径顶点下标 */\n            }\n            printf(\" -> %d\\n\",w);   /* 打印终点 */\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"最短路径D\\n\");\n    for(v=0; v<G.numVertexes; ++v)  \n    {        \n        for(w=0; w<G.numVertexes; ++w)    \n        {\n            printf(\"%d\\t\",D[v][w]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"最短路径P\\n\");\n    for(v=0; v<G.numVertexes; ++v)  \n    {        \n        for(w=0; w<G.numVertexes; ++w)    \n        {\n            printf(\"%d \",P[v][w]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这个是路径规划问题&amp;#xff0c;可以参考一下&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/YF_Li123/article/details/74090301\"&gt;https://blog.csdn.net/YF_Li123/article/details/74090301&lt;/a&gt;&lt;br /&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["此题不会做（C++给代码）", ["\n描述\n现在有", "N", "个城市，编号分别为", "1", "到", "N", "，他们之间用单向道路进行相连。值得注意的是，每条道路有", "2", "个参数：道路长度和需要为此道路支付的通行费。\n\n现在周末来了，住在城市", "1", "的小明，拿上了他的钱包和他的", "switch", "，准备和小红一起玩", "1", "小时游戏。但是小红住在城市", "N", "，且小明的零花钱有限。\n\n需要聪明的你帮助小明找到从城市", "1", "到城市", "N", "的最短路径，而且他能付得起这个通行费。\n\n输入格式\n第", "1", "行输入", "K", "。 这是小明拥有的零花钱", "K", "元。\n\n第", "2", "行输入", "N", "。这是城市总数", "N", "。\n\n第", "3", "行输入", "M", "。这是城市之间的单向道路数。\n\n接下来的", "M", "行，每行输入一道道路，道路信息包含", "4", "个数字，分别代表每条道路的", "4", "个信息：", "S", ",", " ", "D", ",", " ", "L", ",", " ", "C", "。\n\n", "S", "为道路的起点（城市编号），", "D", "为道路终点（城市编号）， ", "L", "为该道路的长度，", "C", "为该道路的通行费。\n\n依次类推，输入若干组样例。\n\n\n\n输出格式\n第", "1", "行输出第", "1", "个样例的结果，", "1", "个数字。代表小明从城市", "1", "到城市", "N", "的最短路径，该路径通行费小于等于", "K", "。如果不存在这样的最短路输出", "-", "1", "。\n\n依次类推，输出其他组样例的结果。\n\n输入样例\n", "5", "\n\n", "6", "\n\n", "7", "\n\n", "1", " ", "2", " ", "2", " ", "3", "\n\n", "2", " ", "4", " ", "3", " ", "3", "\n\n", "3", " ", "4", " ", "2", " ", "4", "\n\n", "1", " ", "3", " ", "4", " ", "1", "\n\n", "4", " ", "6", " ", "2", " ", "1", "\n\n", "3", " ", "5", " ", "2", " ", "0", "\n\n", "5", " ", "4", " ", "3", " ", "2", "\n\n输出样例\n", "11", "\n\n数据范围\n", "0", " ", "<=", " ", "K", " ", "<=", " ", "10000", ",", "\n\n", "2", " ", "<=", " ", "N", " ", "<=", " ", "100", ",", "\n\n", "1", " ", "<=", " ", "M", " ", "<=", " ", "10000", ",", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;核心应该就是最短路径算法的实现&amp;#xff1a;&lt;br /&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include&amp;lt;stdio.h&amp;gt;\n  \n#define SIZE 110  \n#define INF 1000000;  \n \nint map&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;;  //邻接矩阵存储 \nint len&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;;      //d&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;表示源点到i这个点的距离 \nint visit&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;;  //节点是否被访问 \nint n,m;  \n \nint dijkstra(int from, int to){    //从源点到目标点 \n    \n    int i;  \n    \n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; n ; i &amp;#43;&amp;#43;){    //初始化 \n        visit&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; &amp;#61; 0;    //一开始每个点都没被访问 \n        len&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; &amp;#61; map&lt;span class=\"hljs-comment\"&gt;[from]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;;    //先假设源点到其他点的距离 \n    }  \n  \n    int j;  \n    for(i &amp;#61; 1 ; i &amp;lt; n ; &amp;#43;&amp;#43;i){    //对除源点的每一个点进行最短计算 \n        int min &amp;#61; INF;  //记录最小len&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; \n        int pos;  //记录小len&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; 的点 \n  \n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){    \n            if(!visit&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;amp;&amp;amp; min &amp;gt; len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;){  \n                pos &amp;#61; j;  \n                min &amp;#61; len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;;  \n            }  \n        }  \n        visit&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt; &amp;#61; 1;  \n  \n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){\n            if(!visit&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;amp;&amp;amp; (len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;gt; (len&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt; &amp;#43;map&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;))){ //如果j节点没有被访问过&amp;amp;&amp;amp;j节点到源节点的最短路径&amp;gt;pos节点到源节点的最短路径&amp;#43;pos节点到j节点的路径  \n                len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61; len&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt; &amp;#43; map&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;;    //更新j节点到源节点的最短路径    \n            }  \n        }  \n    }  \n  \n    return len&lt;span class=\"hljs-comment\"&gt;[to]&lt;/span&gt;;\n}\n  \n  \nint main () {  \n \n    int i,j;  \n    \n  //  scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;n,&amp;amp;m);    //输入数据\n    n &amp;#61; 6;    //测试数据 \n    m &amp;#61; 9;\n \n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;i){    //设一开始每个点都不可达 \n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){  \n            map&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61; INF;  \n        }  \n    }  \n    \n/*    int a,b,c;    //输入数据 \n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; m ; &amp;#43;&amp;#43;i){  \n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;c);  \n        map&lt;span class=\"hljs-comment\"&gt;[a]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[b]&lt;/span&gt; &amp;#61; map&lt;span class=\"hljs-comment\"&gt;[b]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[a]&lt;/span&gt; &amp;#61; c;  \n    }  */\n    \n    map&lt;span class=\"hljs-comment\"&gt;[1]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[2]&lt;/span&gt; &amp;#61; 7;    //测试数据 \n    map&lt;span class=\"hljs-comment\"&gt;[1]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt; &amp;#61; 9;\n    map&lt;span class=\"hljs-comment\"&gt;[1]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[6]&lt;/span&gt; &amp;#61; 14;\n    map&lt;span class=\"hljs-comment\"&gt;[2]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt; &amp;#61; 10;\n    map&lt;span class=\"hljs-comment\"&gt;[2]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[4]&lt;/span&gt; &amp;#61; 15;\n    map&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[6]&lt;/span&gt; &amp;#61; 2;\n    map&lt;span class=\"hljs-comment\"&gt;[5]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[6]&lt;/span&gt; &amp;#61; 9;\n    map&lt;span class=\"hljs-comment\"&gt;[4]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[5]&lt;/span&gt; &amp;#61; 6;\n    map&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[4]&lt;/span&gt; &amp;#61; 11;\n    int temp &amp;#61; INF;\n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;i){\n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){\n            if(map&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61;&amp;#61; temp)\n                map&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61; map&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;;\n        }\n    }\n \n    int ans &amp;#61; dijkstra(1,5);  \n \n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,ans);  \n \n    return 0;  \n} \n \n/*    边的数据 \n1 2 7\n1 3 9\n1 6 14\n2 3 10\n2 4 15\n3 6 2\n5 6 9\n4 5 6\n3 4 11\n*/\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_34845121/article/details/62056089\" id=\"textarea_1651929968744_1651930069794_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;最短路径之Dijkstra算法 C语言实现_键盘有点滑的博客-CSDN博客_dijkstra算法c语言&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Dijkstra算法&amp;#xff08;单源点路径算法&amp;#xff0c;要求&amp;#xff1a;图中不存在负权值边&amp;#xff09;&amp;#xff1a;步骤&amp;#xff1a;a.  初始时&amp;#xff0c;S只包含源点&amp;#xff0c;即S&amp;#xff1d;{v}&amp;#xff0c;v的距离为0。U包含除v外的其他顶点&amp;#xff0c;即: U&amp;#61;{其余顶点}&amp;#xff0c;若v与U中顶点u有边&amp;#xff0c;则u的距离设置为相应的权值&amp;#xff0c;若u v之间不存在边&amp;#xff0c;则        设置u的距离为无穷大。b.  从U中选取一个距离 v 最小的顶点k&amp;#xff0c;把k&amp;#xff0c;加入S中&amp;#xff08;该选定的距离就是v到k的&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_34845121/article/details/62056089&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html\" id=\"textarea_1651929968744_1651930069794_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;最短路径—Dijkstra算法和Floyd算法 - as_ - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;注意&amp;#xff1a;以下代码 只是描述思路&amp;#xff0c;没有测试过&amp;#xff01;&amp;#xff01; Dijkstra算法 1.定义概览 Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法&amp;#xff0c;用于计算一个节点到其他所有节点的最短路径。主要特点是以起始&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["利用c语音编程关于地铁路线的查询", ["真的想不出来😭    要求不高 求个思路就行", "\n", "选题24、成都地铁查询系统假设成都已经建成了10条地铁形成地铁网络，要求该系统应用在地铁口的查询机上。程序目的是供旅客查询地铁的站点，票价，时间等信息。程序要求利用文件存储这些信息，自动计算出出发地和目的地如何换乘和价格。计算方法有最短路径，时间等选择。在过程中需要考虑到程序的易用性，程序提供站台表供用户选择出发点和目的地。题目提示站台的数据结构建议使用结构体，其中包括票价、站名、下一站，可换乘站台等信息。每条地铁线使用链表的结构来存储，元素为每个站台结构体。用户查询时，可在屏幕上打印每条地铁线的站名等信息使用户一目了然"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考这篇文章&amp;#xff0c;希望对你有帮助&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/Chen_yuazzy/article/details/74081777?utm_source&amp;#61;blogxgwz8\"&gt;【数据结构】旅游景点咨询系统的设计与实现&amp;#xff08;图&amp;#xff0c;DFS&amp;#xff0c;迪杰斯特拉算法&amp;#xff09;_Chen_yuazzy的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这好像是我的作业，好想请教一下大神。", ["题目13 旅游景点咨询系统的设计与实现", "\n\n", "[问题描述]:", "\n\n", "创建一个至少有15个点的有向网表示的某个旅游景点的导游图。顶点代表景点，类型为字符串(例如，泰山导游图:”天地广场门”，“十八盘”，“冯玉祥墓”  桃花峪门”，  中天门”，“南天门”，“玉皇顶”等)，  弧表示两个景点之间可以直达，弧上的权值表示两个景点之间的路程(公里数)，弧上还有到达方法的信息(有步行和索道两种)。建立一个游客咨询系统。", "\n\n", "[基本要求]", "\n\n", "(1)创建图的存储结构。", "\n\n", "(2)  输入两个景点名，就可以得到从一个景点到达另一个景点的所有简单路径、相应路径的路程公里数、行走的方法(每一段是步行，还是坐索道);", "\n\n", "(3)  输入两个景点名,  就可以得到其最短路径，  即:路程最短的行进方法;  如果两者无路径可通，就得出“两景点不可达的信息.", "\n\n", "难点", "\n[实现提示]:", "\n     (1)图的存储、遍历、运算等各种操作;", "\n     (2)  最短路径的计算与算法设计", "\n\n", " "]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/cambridgeacm/article/details/7741330\r\nhttp://blog.sina.com.cn/s/blog_7e5541250100ssue.html", "Konwledge_Point": "最短路径", "Question": ["迷宫问题使用dp怎么求解？             ", ["Description", "\n\n", "定义一个二维数组： ", "\n\n", "int maze[5][5] = {", "\n\n", "0, 1, 0, 0, 0,\n\n0, 1, 0, 1, 0,\n\n0, 0, 0, 0, 0,\n\n0, 1, 1, 1, 0,\n\n0, 0, 0, 1, 0,\n", "\n\n", "};", "\n\n", "它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。", "\nInput", "\n\n", "一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。", "\nOutput", "\n\n", "左上角到右下角的最短路径，格式如样例所示。", "\nSample Input", "\n\n", "0 1 0 0 0", "\n0 1 0 1 0", "\n0 0 0 0 0", "\n0 1 1 1 0", "\n0 0 0 1 0", "\nSample Output", "\n\n", "(0, 0)", "\n(1, 0)", "\n(2, 0)", "\n(2, 1)", "\n(2, 2)", "\n(2, 3)", "\n(2, 4)", "\n(3, 4)", "\n(4, 4)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;java代码我在博文贴了&amp;#xff0c;可以参考一下《如何在64m内存的运行环境下&amp;#xff0c;靠Java完成旅游规划问题》,https://blog.csdn.net/BEYONDMA/article/details/115606833?utm_source&amp;#61;app&amp;amp;app_version&amp;#61;4.5.8&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["Java 和 C 语言在内存使用和速度上有多少差别？", ["题目来源：  ", "https://pintia.cn/problem-sets/15/problems/717", "  ", "\n\n", "7-9 旅游规划 ", "\n\n", " ", "\n\n", "有了一张自驾旅游路线图显示了城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。", "\n\n", "输入格式:", "\n\n", "输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。", "\n\n", "输出格式:", "\n\n", "在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;把报错信息贴出来&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["pta甲级题1111，不知道哪出错了运行不了", ["\n#include<iostream>\nusing namespace std;\n#include<algorithm>\nint n, m;\nint es[", "510", "][", "510", "], et[", "510", "][", "510", "], diss[", "510", "], dist[", "510", "], books[", "510", "], bookt[", "510", "];\n#include<vector>\nvector<int>temppath, path, temptime, timepath, pres[", "510", "], pret[", "510", "];\nint start, jieshu;\nconst int inf = ", "99999999", ";\nint minstime = inf;\nint mincount = inf;\nint minlength = inf;\nint minstime2 = inf;\n//求最短路径的dfs\nvoid dfss(int v) {\n    temppath.push_back(v);\n    if (v == start) {\n        int stime = ", "0", ", length = ", "0", ";\n        for (int i = temppath.size() - ", "1", "; i >= ", "1", "; i--) {\n            int id = temppath[i];\n            int nextid = temppath[i - ", "1", "];\n            length += es[id][nextid];\n            stime += et[id][nextid];\n        }\n        if (length < minlength) {\n            minlength = length;\n            if (stime < minstime) {\n                minstime = stime;\n                path = temppath;\n            }\n        }\n    }\n    for (int i = ", "0", "; i < pres[v].size() - ", "1", "; i++) {\n        dfss(pres[v][i]);\n    }\n    temppath.pop_back();\n}\nvoid dfst(int v) {\n    \n    temptime.push_back(v);\n    if (v == start) {\n        int count = ", "0", ", stime = ", "0", ";\n        for (int i = temppath.size() - ", "1", "; i >= ", "1", "; i--) {\n            int id = temppath[i];\n            int nextid = temppath[i - ", "1", "];\n            count++;\n            stime += et[id][nextid];\n        }\n        if (count < mincount) {\n            mincount = count;\n            if (stime < minstime2) {\n                minstime2 = stime;\n                timepath = temptime;\n            }\n        }\n    }\n    for (int i = ", "0", "; i < pret[v].size() - ", "1", "; i++) {\n        dfst(pret[v][i]);\n    }\n    temptime.pop_back();\n}\nint main()\n{\n    cin >> n, m;\n    fill(es[", "0", "], es[", "0", "] + ", "510", " * ", "510", ", inf);\n    fill(et[", "0", "], et[", "0", "] + ", "510", " * ", "510", ", inf);\n    fill(diss, diss + ", "510", ", inf);\n    fill(dist, dist + ", "510", ", inf);\n    //现在开始输入每个结点之间的距离和时间关系\n    int v1, v2, o, s, t;\n    for (int i = ", "0", "; i < m; i++) {\n        cin >> v1 >> v2 >> o >> s >> t;\n        if (o == ", "1", ")//说明是单行道\n        {\n            es[v1][v2] = s;\n            et[v1][v2] = t;\n        }\n        else if (o == ", "0", ")//说明是双行道\n        {\n            es[v1][v2] = s;\n            es[v2][v1] = s;\n            et[v1][v2] = t;\n            et[v2][v1] = t;\n        }\n    }\n    //现在输出起始点\n    cin >>start >> jieshu;\n    //先从最短路径开始搞起\n    diss[start] = ", "0", ";\n    for (int i = ", "0", "; i < n; i++) {\n        int u = ", "-1", ";\n        int minn = inf;\n        for (int j = ", "0", "; j < n; j++) {\n            if (books[j] == ", "0", " && diss[j] < minn) {\n                minn = diss[j];\n                u = j;\n            }\n        }\n            if (u == ", "-1", ") {\n                break;\n            }\n            books[u] = ", "1", ";\n            for (int v = ", "0", "; v < n; v++) {\n                if (books[v] == ", "0", " && es[u][v] != inf) {\n                    if (diss[v] > diss[u] + es[u][v]) {\n                        diss[v] = diss[u] + es[u][v];\n                        pres[v].clear();\n                        pres[v].push_back(u);\n                    }\n                    else if (diss[v] == diss[u] + es[u][v]) {\n                        pres[v].push_back(u);\n                    }\n                }\n            }\n        }\n    //现在开始dfs求最短路径\n    dfss(jieshu);\n    //现在开始求最短时间\n    dist[start] = ", "0", ";\n    for (int i = ", "0", "; i < n; i++) {\n        int u = ", "-1", ";\n        int minn = inf;\n        for (int j = ", "0", "; j < n; j++) {\n            if (bookt[j] == ", "0", " && dist[j] < minn) {\n                minn = dist[j];\n                u = j;\n            }\n        }\n        if (u == ", "-1", ") {\n            break;\n        }\n        bookt[u] = ", "1", ";\n        for (int v = ", "0", "; v < n; v++) {\n            if (bookt[v] == ", "0", " && et[u][v] != inf) {\n                if (dist[v] > dist[u] + et[u][v]) {\n                    dist[v] = dist[u] + et[u][v];\n                    pret[v].clear();\n                    pret[v].push_back(u);\n                }\n                else if (dist[v] == dist[u] + et[u][v]) {\n                    pret[v].push_back(u);\n                }\n            }\n        }\n    }\n    //现在dfs\n    dfst(jieshu);\n    //现在判断最短路径和最短时间的是不是同一个\n    int index = ", "1", ";\n    for (int i = ", "0", "; i < path.size() - ", "1", "; i++) {\n        if (path[i] == timepath[i]) {\n            index = ", "0", ";\n        }\n    }\n    if (index == ", "1", ")//说明两条路不相等\n    {\n        cout << ", "\"Distance = \"", " << diss[jieshu] << ", "\": \"", " << start;\n        for (int i = path.size() - ", "2", "; i >= ", "0", "; i--) {\n            cout << ", "\"->\"", " << path[i];\n        }\n        cout << endl;\n        cout << ", "\"Time = \"", " << minstime << ", "\": \"", "<<start;\n        for (int i = timepath.size() - ", "2", "; i >= ", "0", "; i--) {\n            cout << ", "\"->\"", " << timepath[i];\n        }\n    }\n    else if (index == ", "0", ") {\n        cout << ", "\"Distance =\"", " << diss[jieshu] << ", "\": \"", " << ", "\"Time = \"", " << minstime << ", "\": \"", "<<start;\n        for (int i = path.size() - ", "2", "; i >= ", "0", "; i--) {\n            cout << ", "\"->\"", " << path[i];\n        }\n\n    }\n    cout << endl;\n    system(", "\"pause\"", ");\n    return ", "0", ";\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;/**\n * &amp;#64;author cuiods\n */\npublic class MazeCell {\n    private int x;\n    private int y;\n    private int step;\n \n    public MazeCell(int x, int y, int step) {\n        this.x &amp;#61; x;\n        this.y &amp;#61; y;\n        this.step &amp;#61; step;\n    }\n \n    public int getX() {\n        return x;\n    }\n \n    public void setX(int x) {\n        this.x &amp;#61; x;\n    }\n \n    public int getY() {\n        return y;\n    }\n \n    public void setY(int y) {\n        this.y &amp;#61; y;\n    }\n \n    public int getStep() {\n        return step;\n    }\n \n    public void setStep(int step) {\n        this.step &amp;#61; step;\n    }\n}\n\nimport java.util.Scanner;\nimport java.util.Stack;\n \n/**\n * 迷宫类\n * 找到所有到达终点的路径\n * &amp;#64;author cuiods\n */\npublic class Maze {\n \n    /**\n     * 临时保存路径\n     */\n    private Stack&amp;lt;MazeCell&amp;gt; pathStack &amp;#61; new Stack&amp;lt;&amp;gt;();\n    /**\n     * 保存迷宫\n     */\n    private int[][] maze;\n    private boolean flag &amp;#61; false;\n    private MazeCell startCell;\n    private MazeCell endCell;\n \n    public Maze() {\n        initialMaze();\n    }\n \n    /**\n     * 寻找路径\n     */\n    public void findPath() {\n        assert flag;\n        processCell(startCell.getX(), startCell.getY(), startCell.getStep());\n    }\n \n    private void processCell(int x, int y, int step) {\n        if (x &amp;#61;&amp;#61; endCell.getX() &amp;amp;&amp;amp; y &amp;#61;&amp;#61; endCell.getY()) {\n            pathStack.pop();\n            printPath();\n            System.out.println(&amp;#34;(&amp;#34;&amp;#43;endCell.getX()&amp;#43;&amp;#34;,&amp;#34;&amp;#43;endCell.getY()&amp;#43;&amp;#34;)&amp;#34;);\n            return;\n        }\n        test(x,y-1,step&amp;#43;1);\n        test(x,y&amp;#43;1,step&amp;#43;1);\n        test(x-1,y,step&amp;#43;1);\n        test(x&amp;#43;1,y,step&amp;#43;1);\n    }\n \n    private void test(int x, int y, int step) {\n        if (canGo(x,y)){\n            MazeCell mazeCell &amp;#61; new MazeCell(x,y,step);\n            insertToPath(mazeCell);\n            processCell(x,y,step);\n        }\n    }\n \n    private void printPath(){\n        for (int i &amp;#61; 0; i &amp;lt; pathStack.size(); i&amp;#43;&amp;#43;) {\n            MazeCell cell &amp;#61; pathStack.get(i);\n            System.out.print(&amp;#34;(&amp;#34;&amp;#43;cell.getX()&amp;#43;&amp;#34;,&amp;#34;&amp;#43;cell.getY()&amp;#43;&amp;#34;)-&amp;gt;&amp;#34;);\n        }\n    }\n \n    private void insertToPath(MazeCell mazeCell) {\n        while (pathStack.peek().getStep() &amp;gt;&amp;#61; mazeCell.getStep()) {\n            pathStack.pop();\n        }\n        pathStack.push(mazeCell);\n    }\n \n    private boolean canGo(int x, int y) {\n        if (maze[x][y]&amp;#61;&amp;#61;1) {\n            return false;\n        }\n        for (int i &amp;#61; 0; i &amp;lt; pathStack.size(); i&amp;#43;&amp;#43;) {\n            MazeCell mazeCell &amp;#61; pathStack.get(i);\n            if (mazeCell.getX()&amp;#61;&amp;#61;x &amp;amp;&amp;amp; mazeCell.getY()&amp;#61;&amp;#61;y) {\n                return false;\n            }\n        }\n        return true;\n    }\n \n    private void initialMaze() {\n        int column;\n        int row;\n        Scanner scanner &amp;#61; new Scanner(System.in);\n        int temp &amp;#61; 0;\n        do {\n            System.out.println(&amp;#34;请输入迷宫行数(&amp;gt;0)&amp;#xff1a;&amp;#34;);\n            temp &amp;#61; scanner.nextInt();\n        } while (temp&amp;lt;&amp;#61;0);\n        row &amp;#61; temp;\n        do {\n            System.out.println(&amp;#34;请输入迷宫列数(&amp;gt;0)&amp;#xff1a;&amp;#34;);\n            temp &amp;#61; scanner.nextInt();\n        } while (temp&amp;lt;&amp;#61;0);\n        column &amp;#61; temp;\n        maze &amp;#61; new int[row&amp;#43;2][column&amp;#43;2];\n        System.out.println(&amp;#34;请输入迷宫&amp;#xff08;1为墙&amp;#xff0c;0为路&amp;#xff0c;-1为起点&amp;#xff0c;2为终点&amp;#xff09;:&amp;#34;);\n        for (int i &amp;#61; 0; i &amp;lt; column&amp;#43;2; i&amp;#43;&amp;#43;) {\n            maze[0][i] &amp;#61; 1;\n        }\n        for (int i &amp;#61; 1; i &amp;lt; row&amp;#43;1; i&amp;#43;&amp;#43;) {\n            maze[i][0] &amp;#61; 1;\n            for (int j &amp;#61; 1; j &amp;lt; column&amp;#43;1; j&amp;#43;&amp;#43;) {\n                temp &amp;#61; scanner.nextInt();\n                switch (temp) {\n                    case -1:\n                        startCell &amp;#61; new MazeCell(i,j,0);\n                        maze[i][j] &amp;#61; temp;\n                        pathStack.push(startCell);\n                        break;\n                    case 2:endCell &amp;#61; new MazeCell(i,j,-1);\n                    case 0:\n                    case 1:maze[i][j] &amp;#61; temp;break;\n                    default:\n                        System.out.println(&amp;#34;输入不符合要求T T&amp;#34;);\n                        return;\n                }\n            }\n            maze[i][column&amp;#43;1] &amp;#61; 1;\n        }\n        for (int i &amp;#61; 0; i &amp;lt; column&amp;#43;2; i&amp;#43;&amp;#43;) {\n            maze[row&amp;#43;1][i] &amp;#61; 1;\n        }\n        if (startCell!&amp;#61;null &amp;amp;&amp;amp; endCell!&amp;#61;null) {\n            flag &amp;#61; true;\n            System.out.println(&amp;#34;输入成功:)&amp;#34;);\n        } else {\n            System.out.println(&amp;#34;至少要有一个起点和终点:(&amp;#34;);\n        }\n    }\n}\n\n/** 测试类\n * &amp;#64;author csdn-zhangteacher\n * test main\n */\npublic class Main {\n \n    public static void main(String[] args) {\n        Maze maze &amp;#61; new Maze();\n        maze.findPath();\n    }\n}&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["java实现迷宫问题", ["给定一个迷宫，阵列中每个元素用0或1表示。0表示可以走，1表示不可走。给定入口位置后，用程序找到出口。输出从入口到出口的路径，路径中每一个节点位置用二维数组（左上角为0,0）表示，并找出最短路径", "\n\n", "以下面4*4的迷宫举例，入口为(0,1)", "\n\n", "1011", "\n\n", "1001", "\n\n", "1100", "\n\n", "1111", "\n\n", "输出应该为：", "\n\n", "(0,1)", "\n\n", "(1,1)", "\n\n", "(1,2)", "\n\n", "(2,2)", "\n\n", "(2,3)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;cbcbbcdb&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["计算机网络一些相关问题", ["1.NAT重载如何提供一对多的地址转换？", "（选择一个）", "A.它使用了一个地址池", "B.它将IPV4地址转换为未使用的IPv6地址", "C. 它为每个会话分配一个唯一的TCP/UDP端口", "D. 它使用虚拟MAC地址和虚拟IP地址", "IPV4中支持哪些IPV6特性，但不常用？（选择一个）", "A. 单播", "B. 多点传送", "C. anycast", "D. 广播", "在哪种CLI配置模式下，您可以配置设备的主机名？（选择一个）", "A. 行方式", "B. 接口方式", "C. 全局方式", "D. 路由器模式", "4.关于跨树根桥选举的说法是正确的？（选择一个）", "A.它总是是自动执行的", "B.每个VLAN都必须有自己的根桥接器", "C. 每个VLAN都必须使用相同的根桥接器", "D. 每个根网桥必须停留在同一根交换机上", "您可以输入哪个命令来验证是否已建立到远程设备的BGP连接？", "A.显示ipbgp摘要", "B.显示ip社区列表", "C.显示ipbgp路径", "D.显示ip路由", "哪个项目代表标准的IPACL？（选择一个）", "A. 访问列表110允许任何任何内容", "B. 访问列表50拒绝192.168.1.10.0.0.255", "C. 访问列表101拒绝tvp任何主机192.168.1.1", "D. 访问列表2500拒绝tcp任何主机192.168.1.1eq22", "哪些特征代表了链路状态路由协议？（选择两个）", "A. 提供了整个拓扑结构的通用视图", "B. 与邻居交换路由表", "C. 计算最短路径", "D. 利用事件触发的更新", "E. 利用频繁的定期更新", "您可以使用哪个实用程序来确定交换机是否可以发送回声请求和回复？（选择一个）", "A. 平", "B. traceroute", "C. ssh", "D. 电视网"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff0c;以下是一个解决这个问题的Python程序&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; sys\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; collections &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; deque\n\n&lt;span class=\"hljs-comment\"&gt;# 有效的骑士移动&lt;/span&gt;\nMOVES &amp;#61; [(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)]\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;to_coord&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;square&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;将棋盘位置转换为坐标&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    col, row &amp;#61; square[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], square[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n    x &amp;#61; &lt;span class=\"hljs-built_in\"&gt;ord&lt;/span&gt;(col) - &lt;span class=\"hljs-built_in\"&gt;ord&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)\n    y &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(row) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; x, y\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;to_square&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;coord&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;将坐标转换为棋盘位置&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    x, y &amp;#61; coord\n    col &amp;#61; &lt;span class=\"hljs-built_in\"&gt;chr&lt;/span&gt;(x &amp;#43; &lt;span class=\"hljs-built_in\"&gt;ord&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;))\n    row &amp;#61; &lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;(y &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; col &amp;#43; row\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;bfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;start, end&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;使用广度优先搜索查找从起点到终点的最短骑士路径&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    start_coord &amp;#61; to_coord(start)\n    end_coord &amp;#61; to_coord(end)\n    queue &amp;#61; deque([(start_coord, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)])\n    visited &amp;#61; &lt;span class=\"hljs-built_in\"&gt;set&lt;/span&gt;([start_coord])\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; queue:\n        coord, moves &amp;#61; queue.popleft()\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; coord &amp;#61;&amp;#61; end_coord:\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; moves\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; dx, dy &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; MOVES:\n            x, y &amp;#61; coord[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; dx, coord[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#43; dy\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; x &amp;lt; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; y &amp;lt; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; (x, y) &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; visited:\n                visited.add((x, y))\n                queue.append(((x, y), moves&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;))\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;# 读取输入文件&lt;/span&gt;\ninput_file &amp;#61; sys.stdin\nline &amp;#61; input_file.readline().strip()\na, b &amp;#61; line.split()\n\n&lt;span class=\"hljs-comment\"&gt;# 查找最短骑士路径&lt;/span&gt;\nn &amp;#61; bfs(a, b)\n\n&lt;span class=\"hljs-comment\"&gt;# 输出结果&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;To get from {} to {} takes {} knight moves.&amp;#34;&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;format&lt;/span&gt;(a, b, n))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该程序首先定义了一个有效的骑士移动列表&amp;#xff0c;然后定义了两个帮助函数&amp;#xff0c;一个将棋盘位置转换为坐标&amp;#xff0c;另一个将坐标转换为棋盘位置。接下来&amp;#xff0c;它使用广度优先搜索算法来查找从起点到终点的最短骑士路径&amp;#xff0c;并返回路径长度。最后&amp;#xff0c;它将结果输出到标准输出流。&lt;/p&gt;\n&lt;p&gt;程序的输入是一个包含两个棋盘位置的字符串的文件。程序可以使用以下命令将其运行&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;python&lt;/span&gt; knight_moves.&lt;span class=\"hljs-keyword\"&gt;py&lt;/span&gt; &amp;lt; &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;.txt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中&amp;#xff0c;input.txt是包含输入的文本文件。程序将输出结果到标准输出流。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["python问题，详细请看问题", ["你的一个朋友正在研究旅行骑士问题(TKP)，在这个问题中，你要找到最短的骑士移动封闭行程，该行程恰好访问棋盘上给定的n个方格中的每个方格一次。他认为问题中最困难的部分是确定在两个给定方格之间最小的骑士移动次数，一旦你完成了这一任务，找到旅程就变得很容易了。你当然知道，反之亦然。所以你让他写一个程序来解决“困难”的部分。你的工作是编写一个程序，将两个方块a和b作为输入，然后确定从a到b的最短路径上的骑士移动次数。", "\n", "输入", "一个输入文件由一行包含两个空格分隔的方格组成。", "方格是由字母(A ..h)和数字(1..8)组成的字符串，前者表示棋盘上的列，后者表示棋盘上的行。", "\n", "输出", "打印一行  ‘To get from xx to yy takes n knight moves.’.", "例子", "\n", "原题内容（英文）", "A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the", "shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard", "exactly once. He thinks that the most difficult part of the problem is determining the smallest number of", "knight moves between two given squares and that, once you have accomplished this, finding the tour", "would be easy. Of course you know that it is vice versa. So you offer him to write a program that solves", "the ”difficult” part. Your job is to write a program that takes two squares a and b as input and then", "determines the number of knight moves on a shortest route from a to b.", "\n", "Input", "• An input file consists of one line containing two squares separated by one space.", "• A square is a string consisting of a letter (a..h) representing the column and a digit (1..8)", "representing the row on the chessboard. ", "\n", "Output", "Print one line saying ‘To get from xx to yy takes n knight moves.’."]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;如何调用函数&amp;#xff1f;你定义好了参数列表中是两个整形变量&amp;#xff0c;你调用的时候往括号里放实际的变量或者数值呀&amp;#xff0c;怎么还在调用的时候在括号里定义变量呢&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这个Display函数该怎么调用", ["下面Display函数调用为什么会出错，是括号里的参数不对嘛，正确的写法是什么", "\n", "\n\nvoid Display(int sight1,int sight2){\n   int a,b,c,d,", "q", "=0;\n    ", "a", "=sight2; \n    ", "if", "(a!=sight1)\n    {\n        printf(", "\"\\n\\t从%s到%s的最短路径是\"", ",G.vex[sight1].sight,G.vex[sight2].sight);\n        printf(", "\"\\t(最短距离为%dm.)\\n\\n\\t\"", ",D[a]); \n        printf(", "\"\\t%s\"", ",G.vex[sight1].sight); \n        ", "d", "=sight1;\n        ", "for", "(", "c", "=0;c<NUM;++c)\n        {\n            P[a][sight1]=0;\n            ", "for", "(", "b", "=0;b<NUM;b++)\n            {\n                ", "if", "(G.arcs[d][b]<32767&&P[a][b])\n                {\n                    printf(", "\"-->%s\"", ",G.vex[b].sight); \n                    ", "q", "=q+1;\n                    P[a][b]=0;\n                    ", "d", "=b; \n                    ", "if", "(q%", "8", "==0) printf(", "\"\\n\"", ");\n                }\n            }\n        }\n    }\n}\n", "\n", "case", " ", "2", ":\n        ", "do", "\n        {\n            system(", "\"cls\"", ");\n            cu=UMenu();\n            ", "switch", "(cu)\n            {\n            ", "case", " ", "1", ":Info(); ", "break", "; \n            ", "case", " ", "2", ":Display(", "int", " sight1,", "int", " sight2); ", "break", ";\n            ", "case", " ", "3", ":", "Map", "(); ", "break", ";\n            }getch();\n        }", "while", "(cu!=", "4", ");\n        ", "break", ";\n    }\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这加了int以后&amp;#xff0c;这个局部变量i就只在循环里使用&amp;#xff0c;循环结束就销毁&amp;#xff0c;这个i和外面的全局变量i不是同一个&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["关于把全局变量改成局部变量结果出现了问题", ["#include<bits/stdc++.h>", "using namespace std;", "int a[1005][1005],d[1005],i,j;", "const int INF=1e9;", "void chushi(int n)//邻接矩阵初始化", "{", "    for(i=1;i<=n;i++)", "    {", "        for(j=1;j<=n;j++)", "        {", "            if(i!=j)", "            a[i][j]=INF;//求最短要初始化为无限大", "        }", "    }", "}", "void dij(int n)//单源最短路径", "{", "    bool f[1005]={0};", "    f[1]=1;", "    int v;", "    for(i=1;i<n;i++)", "    {", "        int min=INF;", "        for(j=1;j<=n;j++)", "        {", "            if(!f[j]&&min>d[j])//找未标记中最小的", "            {", "                min=d[j];", "                v=j;", "            }", "        }", "        f[v]=1;//标记", "        for(j=1;j<=n;j++)", "        {", "            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度", "            {", "                d[j]=a[v][j]+d[v];", "            }", "        }", "    }", "}", "void over(int n)//翻转", "{", "    for(i=1;i<=n;i++)", "    {", "        for(j=i+1;j<=n;j++)", "        {", "            int t=0;", "            t=a[i][j];", "            a[i][j]=a[j][i];", "            a[j][i]=t;", "        }", "    }", "}", "int main()", "{", "    int n,m,x,y,z;", "    cin>>n>>m;", "    chushi(n);", "    for(i=1;i<=m;i++)", "    {", "        cin>>x>>y>>z;", "        a[x][y]=min(a[x][y],z);//避坑：防止同一条路多次输入！", "    }", "    for(i=1;i<=n;i++)", "    {", "        d[i]=a[1][i];//路径长度初始化", "    }", "    dij(n);", "    int ans;", "    for(i=1;i<=n;i++)", "    {", "        ans+=d[i];", "    }", "    over(n);//翻转", "    for(i=1;i<=n;i++)//路径长度初始化", "    {", "        d[i]=a[1][i];", "    }", "    dij(n);", "    for(i=1;i<=n;i++)", "    {", "        ans+=d[i];//求和", "    }", "    cout<<ans<<endl;//华丽地输出", "    return 0;", "}", "输出", "\n", "但如果在i前面加个int，", "\n", "就变成了", "\n", "不过就是把一个i变成了局部变量，其他的也没变啊，为什么最终结果变了？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;封装?你要封装成类吗&amp;#xff0c;如果是&amp;#xff0c;那可能绝大部分代码需要重构&amp;#xff0c;因为你这是面向过程的代码&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这段函数如何进行封装？", ["\n", "#include<iostream>", "\n", "#include<stack>", "\n", "#include<stdio.h>", "\n", "#include<time.h>", "\n", "#include<string>", "\n", "#include <stdlib.h>", "\nusing namespace std;\ntypedef struct\n{\n    ", "int", " ", "x", ",", "y", ";\n}item;\n\ntypedef struct\n{\n    ", "int", " ", "x", ",", "y", ",d;\n}Datetype;\ntypedef stack<Datetype> stack_int;\nvoid path (", "int", " **maze,", "int", ",", "int", ",", "int", ",", "int", ");\nvoid printpath();\n", "#define NUM 100    //队列大小；", "\ntypedef struct{\n    ", "int", " ", "x", ",", "y", ";  ", "//", "所到点的坐标；\n    ", "int", " pre;  ", "//", "前驱点的下标；\n}SqType;  ", "//", "队列；\n", "int", " front,rear;  ", "//", "队首指针与队尾指针；\nvoid printpath(SqType s", "q[]", ",", "int", "){", "//", "打印路径\n    ", "int", " i;\n    i=rear; \n    ", "do", "{\n        cout<<", "\"(\"", "<<s", "q[i]", ".x<<", "\",\"", "<<s", "q[i]", ".y<<", "\")<--\"", ";\n        i=s", "q[i]", ".pre;   ", "//", "回溯；\n    }", "while", "(i!=-", "1", ");\n}\nvoid restore(", "int", " **maze,", "int", " m,", "int", " n){", "//", "恢复迷宫\n    ", "for", "(", "int", " i=", "1", ";i<=m;i++){\n        ", "for", "(", "int", " j=", "1", ";j<=n;j++){\n            ", "if", "(maze[i][j]==-", "1", ")\n                maze[i][j]=", "0", ";\n        }\n    }\n}\n", "int", " path1(", "int", " **maze,", "int", " m,", "int", " n,", "int", " c,", "int", " d,", "int", " x1,", "int", " y1)//最短路径\n{  ", "//m", ",n为迷宫的长和宽，c，d为迷宫入口坐标，x1，y1为迷宫出口坐标；maze为迷宫；\n    item move[", "8", "]={{", "0", ",", "1", "},{", "1", ",", "1", "},{", "1", ",", "0", "},{", "1", ",-", "1", "},{", "0", ",-", "1", "},{-", "1", ",-", "1", "},{-", "1", ",", "0", "},{-", "1", ",", "1", "}};  ", "//", "坐标增量数组；\n    SqType s", "q[NUM]", ";\n    ", "int", " ", "x", ",", "y", ",i,j,v;  \n    front=rear=", "0", ";\n    s", "q[0]", ".x=c;\n    s", "q[0]", ".y=d;\n    s", "q[0]", ".pre=-", "1", "; \n    ", "if", "(maze[c][d]==", "0", ")\n       maze[c][d]=-", "1", ";", "//", "入口点入队；\n    ", "else", " ", "goto", " G;\n    ", "while", "(front<=rear){     ", "//", "队列不为空\n        ", "x", "=s", "q[front]", ".x;\n        ", "y", "=s", "q[front]", ".y;\n        ", "for", "(v=", "0", ";v<", "8", ";v++){\n            i=", "x", "+move[v].x;\n            j=", "y", "+move[v].y;\n            ", "if", "(maze[i][j]==", "0", "){\n                rear++;\n                s", "q[rear]", ".x=i;\n                s", "q[rear]", ".y=j;\n                s", "q[rear]", ".pre=front;\n                maze[i][j]=-", "1", "; ", "//", "访问过的坐标点，入队；\n            }\n            ", "if", "(i==x1&&j==y1){\n                cout<<", "\"最短路径为：\"", "<<endl;\n                printpath(sq,rear);  ", "//", "输出路径；\n                restore(maze,m,n);    ", "//", "恢复迷宫；\n                ", "return", " ", "1", "; \n            }\n            }   //", "for", " v;\n            front++;   ", "//", "当前点搜索完，取下一个点搜索\n        }   //", "while", "\nG:cout<<", "\"无路径。\"", "<<endl;\n        ", "return", " ", "0", ";\n    }\nvoid path(", "int", " **maze,", "int", " a,", "int", " b,", "int", " m,", "int", " n)\n{\n    item move[", "8", "]={{", "0", ",", "1", "},{", "1", ",", "1", "},{", "1", ",", "0", "},{", "1", ",-", "1", "},{", "0", ",-", "1", "},{-", "1", ",-", "1", "},{-", "1", ",", "0", "},{-", "1", ",", "1", "}};\n    stack_int st;\n    Datetype temp;\n    ", "int", " ", "x", ",", "y", ",d,i,j;\n    ", "if", "(maze[a][b]==", "1", "){cout<<", "\"进口输入有误。\"", ";", "return", ";}\n    temp.x=a;temp.y=b;temp.d=-", "1", "; ", "//", "初始化入口点坐标及方向；\n    st.push(temp);\n    ", "while", "(!st.empty())\n    {\n        temp=st.top();\n        st.pop();\n        ", "x", "=temp.x;", "y", "=temp.y;d=temp.d+", "1", ";\n        ", "while", "(d<", "8", ")\n        {\n            i=", "x", "+move[d].x;j=", "y", "+move[d].y;\n            ", "if", "(maze[i][j]==", "0", ")  //该点可到达；\n            {\n                temp.x=", "x", ";temp.y=", "y", ";temp.d=d; ", "//", "坐标及方向；\n                st.push(temp); ", "//", "坐标及方向入栈；\n                ", "x", "=i;", "y", "=j;\n                maze[", "x", "][", "y", "]=-", "1", ";", "//", "到达新点；\n                ", "if", "(", "x", "==m && ", "y", "==n)\n                {\n                    cout<<", "\" 迷宫路径为:\"", "<<endl;\n                    cout<<", "\"(\"", "<<m<<", "\",\"", "<<n<<", "\")<---\"", ";\n                    Datetype t;\n                    ", "while", "(!st.empty())\n                    {\n                        t=st.top();\n                        cout<<", "\"(\"", "<<t.x<<", "\",\"", "<<t.y<<", "\")<---\"", ";\n                        st.pop();\n                    }    //输出路径；\n                    cout<<endl;\n                    ", "return", " ;  ", "//", "到达出口；\n                }\n                ", "else", " d=", "0", ";   ", "//", "重新初始化方向；\n            }\n            ", "else", " d++;    ", "//", "改变方向；\n        }\n    }\n    cout<<", "\"对不起，无法找到出口.\"", ";\n    ", "return", ";   ", "//", "迷宫无路；\n}\n                    \nvoid printpath()\n{\n    ", "int", " m,n,i,j,l,c,d;\n    string s;\n    cout<<", "\" 请输入迷宫的行数列数如:(m n)\"", "<<endl;\n    cin>>m>>n;\n    ", "int", " **maze=new ", "int", "*[m+", "2", "];\n    ", "for", "(i=", "0", ";i<=m+", "1", ";i++)\n        maze[i]=new ", "int", "[n+", "2", "];", "//", "申请迷宫的空间；\n    ", "for", "(i=", "0", ";i<=m+", "1", ";i++)   \n        maze[i][", "0", "]=", "1", ";\n    ", "for", "(i=", "0", ";i<=n+", "1", ";i++)\n        maze[", "0", "][i]=", "1", ";\n    ", "for", "(i=", "0", ";i<=m+", "1", ";i++)\n        maze[i][n+", "1", "]=", "1", ";\n    ", "for", "(i=", "0", ";i<=n+", "1", ";i++)\n        maze[m+", "1", "][i]=", "1", ";  ", "//", "建立迷宫周围的墙；\n    cout<<", "\"1、采用创建好的迷宫; 2、自己创建迷宫（其他输入按'2'处理）\"", "<<endl;\n    cin>>s;\n    ", "if", "(s==", "\"1\"", ")\n    {\n        ", "srand", "(", "time", "(", "0", "));  ", "//", "系统时间随机函数；\n        ", "for", "(i=", "1", ";i<=m;i++)\n            ", "for", "(j=", "1", ";j<=n;j++)\n                maze[i][j]=", "rand", "()%2;  ", "//", "随机赋值\n        maze[", "1", "][", "1", "]=", "0", ";   ", "//", "(", "1", ",", "1", ")点为可通过点；\n        maze[m][n]=", "0", ";   ", "//", "(m,n)点为可通过点；\n    }\n    ", "else", " \n    {\n        cout<<", "\"请输入迷宫：\"", "<<m<<", "\"行\"", "<<n<<", "\"列\"", "<<", "\", 输入必须为'0' 或 '1'；\"", "<<endl;\n        ", "for", "(i=", "1", ";i<=m;i++)     //输入第i行迷宫的构造；\n            ", "for", "(j=", "1", ";j<=n;j++)     //输入第j列迷宫的结构；\n            {\n                cin>>maze[i][j];\n              A:", "if", "(maze[i][j]!=", "0", " && maze[i][j]!=", "1", ")\n                {\n                    cout<<", "\"请再次输入：\"", ";\n                    cin>>maze[i][j];", "goto", " A;  ", "//", "判错；\n                }\n            }    \n    }\n    cout<<", "\"迷宫如下：\"", "<<endl; ", "//", "显示用户输入的迷宫；\n            ", "for", "(i=", "0", ";i<=m+", "1", ";i++)\n            {\n                ", "for", "(j=", "0", ";j<=n+", "1", ";j++)\n                 cout<<maze[i][j]<<", "\"　\"", ";\n                cout<<endl;\n            }\n          H:cout<<", "\"请输入迷宫入口(a,b),出口(c,d)：\"", ";\n            cin>>i>>j>>c>>d;\n    path(maze,i,j,c,d);    ", "//", "调用路径函数，输出路径；\n    cout<<endl;  ", "//", "格式设置；\n    restore(maze,m,n);   ", "//", "恢复迷宫；\n    path1(maze,m,n,i,j,c,d);  ", "//", "输出最短路径；\n    cout<<endl;  ", "//", "格式设置；\n    cout<<", "\"1、寻找其他入口与出口；2、退出此迷宫；\"", ";\n    cin>>l;  \n    ", "if", "(l==", "1", "){\n        restore(maze,m,n);  ", "//", "恢复迷宫；\n        ", "goto", " H;\n    }\n    ", "else", " ", "return", ";   ", "//", "跳出此函数；\n}\n", "int", " main()\n{\n    string s=", "\"Y\"", ";\n    ", "do", "\n    {\n        cout<<", "\"--------------------------欢迎到达迷宫界面--------------------------\\n\"", ";\n        printpath();\n        cout<<endl;\n        cout<<", "\"\\n 是否继续？'Y' 或'N'（输入其他操作按'N'）\"", "<<endl;\n        cin>>s;\n    }", "while", " (s==", "\"Y\"", "||s==", "\"y\"", ");\n    ", "system", "(", "\"pause\"", ");\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇文章讲的很详细&amp;#xff0c;请看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/zzq0523/article/details/104868360\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;最短路之Dijkstra&amp;#43;堆优化&amp;#xff08;单源最短路&amp;#xff09;&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "最短路径", "Question": ["利用dijkstra求解最短路计数出现问题", ["利用dijkstra在枚举最短路的过程中顺便更新路径数", "[原题链接]（", "https://www.luogu.com.cn/problem/P1144", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<cstring>", "\n", "#", "include", "<queue>", "\n", "using", " ", "namespace", " std;\n\n", "typedef", " ", "long", " ", "long", " LL;\n", "const", " ", "int", " N=", "1e6", ";\nLL h[N],e[N],ne[N],w[N],idx;  ", "// 邻接表存储", "\n", "int", " n,m;  ", "// n个顶点,m条边", "\nLL dist[N]; ", "// 每个点到1的距离", "\nLL ans[N];  ", "// 标记起点到每个点的路径条数", "\n", "bool", " st[N];  ", "// 标记是否在点集内", "\n\n", "#", "define", " x first", "\n", "#", "define", " y second", "\n", "typedef", " pair<", "int", ",", "int", ">PII;\n\n", "void", " ", "add", "(", "int", " a,", "int", " b)", "\n", "{\n    e[idx]=b,ne[idx]=h[a],w[idx]=", "1", ",h[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dist,", "0x3f", ",", "sizeof", " dist);\n    dist[", "1", "]=", "0", ";ans[", "1", "]=", "1", ";\n    priority_queue<PII,vector<PII>,greater<PII>>heap;\n    heap.", "push", "({", "0", ",", "1", "});\n    \n    ", "while", "(heap.", "size", "())\n    {\n        ", "auto", " t=heap.", "top", "();\n        heap.", "pop", "();\n        ", "int", " ver=t.y,distance=t.x;\n        ", "if", "(st[ver]) ", "continue", ";\n        st[ver]=", "true", ";\n        ", "for", "(", "int", " i=h[ver];i!=", "-1", ";i=ne[i])\n        {\n            ", "int", " j=e[i];\n            ", "if", "(dist[j]>distance+w[i])  ", "// 比之前的距离小，到达该点的最短路径数修改为能到ver的数量", "\n            {\n                ans[j]=ans[ver];\n                dist[j]=distance+w[i];\n                heap.", "push", "({dist[j],j});\n            }\n          ", "else", " ", "if", "(dist[j]==dist[ver]+w[i]) ans[j]+=ans[ver];\n        }\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n   ", "memset", "(h,", "-1", ",", "sizeof", " h);\n   ", "scanf", "(", "\"%d%d\"", ",&n,&m);\n   ", "while", "(m--)\n   {\n    ", "int", " a,b;\n    ", "scanf", "(", "\"%d%d\"", ",&a,&b);\n    ", "add", "(a,b);", "add", "(b,a);\n   }\n   ", "dijkstra", "();\n   ", "for", "(", "int", " i=", "1", ";i<=n;i++)\n    cout<<ans[i]%", "100003", "<<endl;\n   ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路", "\n", "如果从起点到t有ans[t]条边，从t到j有x条边，那么从起点到j就有两者相乘条边，也可以相加x次，就是每找到一条从t到j的边就加ans[t]", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;看了一下。。这个博主代码完全没放全。。我说一下解决方案&lt;/p&gt;\n\n&lt;p&gt;按照你当前的代码&amp;#xff0c;把16行的import matrix去掉&amp;#xff0c;该博主本身是将这份代码分成两份写的&amp;#xff0c;第一份是matrix.py且代码没给全&amp;#xff0c;比如tran_m方法&lt;/p&gt;\n\n&lt;p&gt;然后将59行开始改为&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;data&amp;#61;matrix(address)\nfloyd(data)&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;按该博主意思&amp;#xff0c;tran_m仅用于数据处理&amp;#xff0c;不影响数据输入floyd方法&lt;/p&gt;\n\n&lt;p&gt;运行结果&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"890\" src=\"https://img-ask.csdnimg.cn/upload/1622807624199.png\" width=\"677\" /&gt;&lt;img alt=\"\" height=\"890\" src=\"https://img-ask.csdnimg.cn/upload/1622807632250.png\" width=\"677\" /&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["module matrix has no attribute matrix", ["使用弗洛伊德算法模拟最短路径时出现module matrix has no attribute matrix", "\n\n", "\n", "import xlrd\nimport sys\n\ndef matrix(address):                           #读取excel生成邻接矩阵\n    wb = xlrd.open_workbook(address)\n    sheet1 = wb.sheet_by_name('邻接矩阵_距离')\n    L = []\n    for i in range(1,51):\n        a = sheet1.row_values(i)\n        a.remove(a[0])\n        L.append([int(x) for x in a])\n    # print(L)\n    return L\n\nfrom pylab import *\nimport matrix\n\n\ndef floyd(d):\n    D=d\n    lengthD = len(D)                    #邻接矩阵大小\n    p = list(range(lengthD))\n    P = []\n    for i in range(lengthD):\n        P.append(p)\n    P = array(P)\n    for k in range(lengthD):\n        for i in range(lengthD):\n            for j in range(lengthD):\n                if(D[i][j] >D[i][k]+D[j][k]):         #两个顶点直接较小的间接路径替换较大的直接路径\n                    P[i][j] = P[i][k]                 #记录新路径的前驱\n                    D[i][j] = D[i][k]+D[j][k]\n    print('各个顶点的最短路径:')\n    for i in range(lengthD):\n        for j in range(i+1,lengthD):\n            print('v%d' % (i+1) + '--' + 'v%d' % (j+1) + '\\t' + 'dist_min:' + '\\t' + str(D[i][j]) + '\\t' + 'path:'+'v%d'%(i+1),end='' )\n            temp=P[i][j]\n            while (temp!=j):\n                print('--'+'v%d'%(temp+1),end='')\n                temp=P[temp][j]\n            print('--'+'v%d'%(j+1))\n    print('P矩阵:')\n    print(P)\n    print('D矩阵:')\n    for i in D:\n        print(i)\n    return D\n\n\nif __name__ == '__main__':\n    chararray = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50']\n    L=[]\n    for i in range(1,len(chararray)+1):\n        L.append('v%d'%i)\n    Dict=dict(zip(L,chararray))\n    print('各点对应关系：')\n    print(Dict)\n    address = 'C:\\\\Users\\11573\\Desktop\\python\\数据及代码\\数据/邻接矩阵.xlsx'\n    data=matrix.matrix(address)\n    d=matrix.tran_m(data)\n    floyd(d)\n\n————————————————\n版权声明：本文为CSDN博主「heavenmark」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/heavenmark/article/details/82794565", "\n\n", "源代码来自与同站博主heavenmark"]], "Tag": "算法设计"}
{"Answer": "网友的相似疑问：https://stackoverflow.com/questions/41479316/maven-dependency-management-the-first-declaration-wins，但是没人去回答他....\r\n\r\n其实这个是 dependency 插件的功能，默认采用的是复写的策略，当构建声明处于同一 pom 中，且 groupid 和 artifactId 一致时，以**最新声明为准**，后面的覆盖前面的。注意这里没涉及到依赖调解的功能。我的理解是依赖调解只发生于构建来自不同 pom 时，而此时构建声明处于同一 pom，故不会触发依赖调解。\r\n\r\n参考：\r\nhttps://maven.apache.org/plugins/maven-dependency-plugin/usage.html\r\nhttps://juejin.im/post/5cbf27a95188250a505c2cd2#heading-18\r\nhttps://stackoverflow.com/questions/42113542/figuring-out-duplicate-dependency-in-war", "Konwledge_Point": "最短路径", "Question": ["Maven 依赖调解原则失效？", ["都知道 Maven 在出现依赖版本冲突问题时，会用最短路径原则和第一声明原则来解决冲突。但在自己电脑上引入如下依赖，却产生了与期望违背的效果：", "\n\n", "<dependency>\n  <groupId>commons-io</groupId>\n  <artifactId>commons-io</artifactId>\n  <version>2.6</version>\n</dependency>\n\n<dependency>\n  <groupId>commons-io</groupId>\n  <artifactId>commons-io</artifactId>\n  <version>2.4</version>\n</dependency>\n", "\n\n", "按照两个原则的话，最终引入的应该是版本为 2.6 的包，但实际却引入了版本为 2.4 的包。分析如下：", "\n\n", "> mvn dependency:tree\n[INFO] ------------------------------------------------------------------------\n[INFO] Building mvn-test 1.0.0\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ mvn-yilaitest ---\n[INFO] com.ariclee:mvn-yilaitest:jar:1.0.0\n[INFO] \\- commons-io:commons-io:jar:2.4:compile\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1.068 s\n[INFO] Finished at: 2019-05-11T16:45:38+08:00\n[INFO] Final Memory: 12M/245M\n[INFO] ------------------------------------------------------------------------\n", "\n\n", "为什么依赖后声明的却被引入了，这不是违背了第一声明原则吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;估计你的编译器不支持c&amp;#43;&amp;#43;11标准&amp;#xff0c;或者你么有打开你的编译器的C&amp;#43;&amp;#43;11标准的开关&amp;#xff0c;如果不支持的话可以用以下语句&lt;br /&gt;q.push(make_pair(1,1));&lt;br /&gt;替代&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["如何使用“{ x,y}”向队列中传入二位数组元素(x,y)？", ["在使用某博主关于BFS算法求解（迷宫）最短路径问题时，我看到了这样几条语句，并提出了我的疑问。", "\n", "（", "1", "）", "typedef", " pair<", "int", ", ", "int", "> PII;", "//pair<int,int>?", "\n（", "2", "）queue<PII> q;", "//队列中使用二维数组作为元素？", "\n（", "3", "） q.", "push", "({", "0", ",", "0", "});", "//怎么push一个二维的数组元素(x,y)", "\n（", "4", "）", "auto", " t=q.", "front", "();", "//哪里来的auto?", "\n", "\n", "我尝试在dev上运行，以下是完整的代码，和我在CSDN上找到的关于使用“{}”返回等的错误改写（其后用“//”标识），但是任然没有解决问题。", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cstring>", "\n", "#", "include", " ", "<algorithm>", "\n", "#", "include", " ", "<queue>", "\n", "//#include <bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "//add_definitions(\"std=c++11\");", "\n", "typedef", " pair<", "int", ", ", "int", "> PII;", "//", "\n", "const", " ", "int", " N = ", "110", ";\n", "int", " s[N][N];\n", "int", " n,m;\n", "int", " g[N][N];\n", "int", " ", "bfs", "()", "\n", "{\n    queue<PII> q;", "//", "\n    ", "memset", "(g, ", "-1", ", ", "sizeof", " g);", "//", "\n    q.", "push", "({", "0", ",", "0", "});", "//", "\n    g[", "0", "][", "0", "]=", "0", ";\n    ", "int", " dx[", "4", "] = {", "-1", ", ", "0", ", ", "1", ", ", "0", "}, dy[", "4", "] = {", "0", ", ", "1", ", ", "0", ", ", "-1", "};", "//", "\n    ", "while", "(q.", "size", "())\n    {\n        ", "auto", " t=q.", "front", "();", "//", "\n        q.", "pop", "();\n        ", "for", "(", "int", " i=", "0", ";i<", "4", ";i++)\n        {\n            ", "int", " a=t.first+dx[i];\n            ", "int", " b=t.second+dy[i];\n            ", "if", "(a>=", "0", " && a<n && b>=", "0", " && b<m && g[a][b]==", "-1", " && s[a][b]==", "0", ")", "//", "\n            {\n                g[a][b]=g[t.first][t.second]+", "1", ";\n                q.", "push", "({a,b});", "//", "\n            }\n        }\n    }\n    ", "return", " g[n", "-1", "][m", "-1", "];\n}\n", "int", " ", "main", "()", "\n", "{cin>>n>>m;\n", "for", "(", "int", " i=", "0", ";i<n;i++)\n", "for", "(", "int", " j=", "0", ";j<m;j++)\ncin>>s[i][j];\ncout<<", "bfs", "()<<endl;\n}\n", "\n", "以下是报错内容截图：", "\n", "\n", "以下是我在搜索过后找到的解决方案。（我没看懂、用了方法也没有成功）", "\n      \n        ", "C++ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11 return {i,j}_m0_46334316的博客-CSDN博客", "\n        \n      ", "C++ vector return{} 返回错误在解答LeetCode两数之和的题目使用{}返回vector出现了错误部分源代码    int array1[4] = {2,7,11,15};    int array2[3] = {3,2,4};    int array3[2] = {3,3};    int target1 = 9;    int target2 = 6;    int target3 = 6;    Solution s;    vector<int&g", "\n      ", "\n      ", "\n        ", "\n          ", "https://blog.csdn.net/m0_46334316/article/details/116431816?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163650113416780264018681%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163650113416780264018681&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-116431816.first_rank_v2_pc_rank_v29&utm_term=%5Bwarning%5D+extended+initializer+lists+only+available+with+-std%3Dc%2B%2B11+or+-std%3Dgnu%2B%2B11&spm=1018.2226.3001.4187", "\n        ", "\n      ", "\n", "总结一下我的问题在于：", "（1）不晓得该怎么传{x,y}到队列里面。", "（2）auto的用法在这里为什么行不通？", "（3）c++11中头文件<bits/stdc++.h>据说是包括了很多头文件……那在这个地方，可以只写它吗？"]], "Tag": "算法设计"}
{"Answer": "引入 \r\n\r\ncommons-dbcp\r\n\r\n的时候把commons-collections-2.1 exclude掉就行了\r\n\r\n或者\r\n\r\n在你的直接的POM中引入\r\n\r\ncommons-collections\r\n\r\nMaven是按照最短路径来的，只要你直接在POM引入了，就会用你直接引入的。\r\n\r\nMaven2.0.9是这样的，不知道2.1这个规则有没有改，LZ试一试上面两种方法", "Konwledge_Point": "最短路径", "Question": ["Maven集成时依赖jar包版本控制问题", ["我有一个WEB工程需要用到commons-collections和commons-dbcp.", "\n代码中用到的是commons-collections的3.1版本特性，但是资源库中commons-dbcp依赖的", "\ncommons-collections指定了2.1版本。看了下commons-dbcp-1.2.1.pom：", "commons-collections", "commons-collections", "2.1", "\n\n", "当我将web工程打包时，maven会将commons-collections-3.1.jar", "\n和commons-collections-2.1.jar都拷贝进WAR包。 如何只让maven只将", "\ncommons-collections-3.1.jar拷贝到war包中去？", "\n\n", "[b]问题补充：[/b]", "\n谢谢，jansel的答复，方案1是可以行的，但是觉得maven应该有其它解决方案，所以发贴出来咨询一下。方案2我试过了，在我自己的工程pom.xml文件中指定了", "\n高版本的common-collections，但是maven做package的时候依赖会将两个版本的common-collections库都打进WEB-INF/lib，我的maven版本是2.0.9.", "\n[b]问题补充：[/b]", "\nE:\\NGWORK\\javaprj\\webapp>mvn dependency:tree -Dverbose -Dincludes=commons-collections", "\n\n", "E:\\NGWORK\\javaprj\\webapp>set MAVEN_OPTS=-Xms64m  -Xmx512m", "\n[INFO] Scanning for projects...", "\n[INFO] Searching repository for plugin with prefix: 'dependency'.", "\n[INFO] ------------------------------------------------------------------------", "\n[INFO] Building Unnamed - asiainfo.cboss:cboss:war:SNAPSHOT", "\n[INFO]    task-segment: [dependency:tree]", "\n[INFO] ------------------------------------------------------------------------", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/cas/aicasclient/1.0/aicasclient-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/cmcc/twcmcc/1.4/twcmcc-1.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/castor/castor-xml/1.0/castor-xml-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/openboss/openclient/2.0/openclient-2.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/xstream/xstream/1.3/xstream-1.3.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/jdk/tools/1.4.2/tools-1.4.2.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/servlet/servlet/2.3/servlet-2.3.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/cboss/portalExternal/1.8/portalExternal-1.8.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/openbuff/EzfrmWeb/1.0/EzfrmWeb-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/openbuff/EzfrmBiz/1.0/EzfrmBiz-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/net/sf/jasperreports/2.0.3/jasperreports-2.0.3.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/lowagie/itext/1.3.1/itext-1.3.1.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/lowagie/itext-asian/1.0/itext-asian-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/net/sf/json/2.2.1/json-2.2.1.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/net/sf/ezmorph/1.0.4/ezmorph-1.0.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/edu/concurrent/1.0/concurrent-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/ny/nysecurity/1.0/nysecurity-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/cmcc/trustwork/1.4/trustwork-1.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/cmcc/pwdSvr/1.4/pwdSvr-1.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/poi/poi/2.5.1-FINAL/poi-2.5.1-FINAL.pom", "\n[INFO] [dependency:tree]", "\n[INFO] asiainfo.cboss:cboss:war:SNAPSHOT", "\n[INFO] +- asiainfo.cboss:cboss-common:jar:SNAPSHOT:compile", "\n[INFO] |  - org.apache.velocity:velocity:jar:1.5:compile", "\n[INFO] |     - (commons-collections:commons-collections:jar:3.1:compile - omitted for conflict with 2.1)", "\n[INFO] +- commons-collections:commons-collections:jar:3.1:runtime (scope not updated to compile)", "\n[INFO] +- commons-dbcp:commons-dbcp:jar:1.2.1:compile", "\n[INFO] |  - (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 3.1)", "\n[INFO] +- commons-beanutils:commons-beanutils:jar:1.6:compile", "\n[INFO] |  - (commons-collections:commons-collections:jar:2.0:compile - omitted for conflict with 3.1)", "\n[INFO] - commons-pool:commons-pool:jar:1.2:compile", "\n[INFO]    - (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 3.1)", "\n[INFO] ------------------------------------------------------------------------", "\n[INFO] BUILD SUCCESSFUL", "\n[INFO] ------------------------------------------------------------------------", "\n[INFO] Total time: 33 seconds", "\n[INFO] Finished at: Wed Sep 09 13:18:59 CST 2009", "\n[INFO] Final Memory: 13M/63M", "\n[b]问题补充：[/b]", "\n的确是按最短路径实现的，我在自己的pom.xml中指定了使用版本，maven就是使用这个版本的。 上午是因为忘记做clean了，所以原来已经拷贝到WEB-INF/lib目录的库没有被清理这样commons-collections－2.1.jar还是会存在， 让我误认为不能生效。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;运筹学的内容吗&amp;#xff1f;&lt;br /&gt;应该是可以的&amp;#xff0c;这个应该是多元n次优化问题&lt;br /&gt;一般是lingo的强项&amp;#xff0c;不过matlab也可以&amp;#xff0c;你需要列出相应的约束&amp;#xff0c;然后找一个前进的方向&amp;#xff0c;定义一个终止条件。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["MATLAB求解二维平面的两点间路径规划", ["有一个问题:给定加速度限制，速度限制(起点速度方向，终点速度方向)，起点(x1，y1)，终点(x2，y2)，这两点间的连线为一个n次多项式函数，可不可以利用MATLAB求出所用时间最短时，该路径函数各次项前的系数"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;int m, n, p, q, k; \nint min &amp;#61; 99999;\nint a[100][100];//1表示空,2表示障碍 \nint v[100][100];//0表示未访问,1表示访问 \n//迷宫问题\nvoid dfs(int x, int y, int step) \n{\n\t//将具体的移动方向转化为数据,4个方向\n\tint dx[4] &amp;#61; {1, 0, -1, 0};\n\tint dy[4] &amp;#61; {0, -1, 0, 1};\n\t\n\t//判断终点\n\tif(x &amp;#61;&amp;#61; p &amp;amp;&amp;amp; y &amp;#61;&amp;#61; q)\n\t{\n\t\tif(step &amp;lt; min)\n\t\t{\n\t\t\tmin &amp;#61; step;\n\t\t}\n\t\treturn;\n\t}\n\t\n\t//开始进行移动\n\tfor(k &amp;#61; 0; k &amp;lt;&amp;#61; 3; k&amp;#43;&amp;#43;)\n\t{\n\t\tint tx,ty;\n\t\t//现在的坐标位置\n\t\ttx &amp;#61; x &amp;#43; dx[k];\n\t\tty &amp;#61; y &amp;#43; dy[k];\n\t\tif(a[tx][ty] &amp;#61;&amp;#61; 1 &amp;amp;&amp;amp; v[tx][ty] &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tv[tx][ty] &amp;#61; 1;\n\t\t\tdfs(tx,ty,step&amp;#43;1);\n\t\t\tv[tx][ty] &amp;#61; 0;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nmain()\n{\n\t//为地图赋值\n\tint i, j;\n\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;m,&amp;amp;n);\n\t\n\tfor(i &amp;#61; 1; i &amp;lt;&amp;#61; m; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor(j &amp;#61; 1; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]);\n\t\t}\n\t}\n\t\n\tint startx,starty;\n\t//确定起点和终点\n\tscanf(&amp;#34;%d%d%d%d&amp;#34;,&amp;amp;startx, &amp;amp;starty,&amp;amp;p,&amp;amp;q);\n\t//将起点设置已访问\n\ta[startx][starty] &amp;#61; 1;\n\tdfs(startx,starty,0);\n\t\n\tprintf(&amp;#34;%d&amp;#34;,min);\n\t\n\treturn 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;参考&lt;a href=\"https://blog.csdn.net/s_meng_/article/details/116357413\"&gt;C语言实现&amp;#xff0c;找出迷宫起点到终点的最短路径&amp;#xff0c;最详细的DFS教程_s_meng_的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["求各位大佬看一下c语言迷宫问题[急]", ["项目要求：1、找到一条或多条从迷宫起点到迷宫终点的路径，并将路径输出；\n2、找到一条最短的路径，并将路径输出；\n3、以尽可能短的时间，找到路径，并将路径输出；\n4、解决方案能适用于任意同形式的迷宫。 "]], "Tag": "算法设计"}
{"Answer": "以下是代码\r\n```\r\nimport random as rd\r\n\r\nminimum=999999  #初始化minimum为一个很大的值 保证任何结果都小于该值\r\nresult =\"\"  #全局最小路径结果\r\n\r\npathLen=[[0,38,42,27,41,24],[38,0,8,21,13,22],[42,8,0,26,10,29],[27,21,26,0,18,5],[41,13,10,18,0,25],[24,22,29,5,25,0]] #各个城市的距离表\r\n\r\nclass path():\r\n    def __init__(self,p1,p2,n=5): #类型初始化,p1为交叉概率,p2为变异概率,n为城市数 本例为5（北京先后到5个城市）\r\n        self.path=[i for i in range(n)]\r\n        self.p1=p1\r\n        self.p2=p2\r\n        self.n=n\r\n    def init(self): #用于第一代的基因生成\r\n        for i in range(self.n):\r\n            self.path[i]=rd.randint(0,self.n)\r\n        \r\n    def exchange(self): #交叉\r\n        if rd.randint(1,100)&gt;(100-self.p1):   #有概率交叉\r\n            while 1:\r\n                position1=rd.randint(0,self.n-1)   #随机生成交叉位置\r\n                position2=rd.randint(0,self.n-1)\r\n                if position1 != position2:  #判断交叉位置非同一位置\r\n                    self.path[position1],self.path[position2]=self.path[position2],self.path[position1]\r\n                    break\r\n                else:\r\n                    continue\r\n    def change(self):\r\n        if rd.randint(1,100)&gt;(100-self.p2):     #有概率变异\r\n            self.path[rd.randint(0,self.n-1)]=rd.randint(0,self.n)\r\n    def calculate(self):    #计算路径总长度\r\n        count=pathLen[1][self.path[0]]   #北京至第一个城市的路程\r\n        for i in range(self.n-1):\r\n            count+=pathLen[self.path[i]][self.path[i+1]]   #中途各个城市间的路程\r\n        count+=pathLen[self.path[-1]][1]  #最后一个城市到北京的路程\r\n        return count\r\n    def parity(self):   #校验是否为每个城市去一次且不包含北京\r\n        count=0\r\n        path=self.path.copy()\r\n        path.sort()\r\n        for i in range(len(path)-1):\r\n            if path[i]==path[i+1]:\r\n                count+=1\r\n            if path[i]==1:\r\n                count+=1\r\n        if count==0:\r\n            return 1\r\n        else:\r\n            return 0\r\n\r\n    def nxt(self,other): #产生子代\r\n        p=path(self.p1,self.p2)\r\n        for i in range(self.n):\r\n            if rd.randint(1,100)&gt;50:\r\n                p.path[i]=self.path[i]\r\n            else:\r\n                p.path[i]=other.path[i]\r\n        return p\r\n        \r\n\r\ndef generate(n,p1,p2):  #生成种群 n为规模 p1为交叉概率 p2为变异概率\r\n    t=[]\r\n    for i in range(n):\r\n        father=path(p1,p2)\r\n        father.init()\r\n        t.append(father)\r\n    return t\r\n\r\n\r\ndef allChange(t):    #进行繁殖、变异、交换、淘汰\r\n    global minimum\r\n    global result\r\n    l=len(t)\r\n    print(\"本轮父代个数为:\",l)\r\n    if l&gt;100:   #如果父代个数大于100则开始父代淘汰机制\r\n        path=[]\r\n        for i in t:\r\n            path.append(i.calculate())   #计算各个个体的路径长度\r\n        path.sort()  #路径长度排序\r\n        tt=[]\r\n        j=0\r\n        while len(tt)&lt;100:\r\n            for i in t:\r\n                if i.calculate()==path[j]:\r\n                    tt.append(i)\r\n            j+=1\r\n        t=tt\r\n    l=len(t)\r\n    for i in range(l):   \r\n        for j in range(l-1-i):\r\n            child=t[i].nxt(t[j]) #两两交配产生子代\r\n            child.exchange()     #子代交换\r\n            child.change()      #子代变异\r\n            t.append(child)          #向种群添加子代\r\n    count=0\r\n    for i in range(len(t)):  #去除不符合的成员\r\n        if t[i-count].parity()==0: #杀死不符合要求的子代 （每个城市去一次且不包含北京）\r\n            del(t[i-count])\r\n            count+=1\r\n    print(\"本轮产生子代后总数:\",len(t))\r\n    result1=t[-1].path\r\n    mini=t[-1].calculate()\r\n    for i in range(len(t)-1):   #获得各个个体的路程长度\r\n        tt=t[i].calculate()     \r\n        if mini&gt;tt:             #比较是否是新的最小路径\r\n            mini=tt\r\n            result1=t[i].path\r\n    print(\"本轮最小路径长度:\",mini)\r\n    print(\"本轮最小路径结果:\",result1)\r\n    if mini&lt;minimum:\r\n        minimum=mini\r\n        result=result1\r\n            \r\n\r\n\r\n\r\nzq=generate(30,10,10) #generate(30,10,10)表示 初始种群30，交换概率10%，变异概率10%\r\nfor i in range(6):  #range(n) 标识迭代n代\r\n    allChange(zq)\r\nprint(\"最后最小路径长度为:\",minimum)\r\nprint(\"最后最小路径为:\",result)\r\n\r\n\r\n```\r\n运行结果\r\n![图片说明](https://img-ask.csdn.net/upload/202006/09/1591697988_503086.png)", "Konwledge_Point": "最短路径", "Question": ["旅行商路径优化问题的遗传算法程序", ["编制旅行商路径优化问题的遗传算法程序，并计算一个实例。(以不超过10个城市为例,给出初始种群规模、交叉概率、变异概率在不同设置情况下的总结分析)。", "\n要求：遗传算法路径结果图，适应函数自选（标明），附上全部代码。", "\n旅行商问题：", "\n\n", "从北京（B）乘飞机到威海(W)、贵阳(G)、上海(S)、昆明(K)、拉萨(L)", "\n五城市做旅游，每城市恰去一次再回北京，应如何安排旅游线，使旅程最短？各城市之间的航线距离如表7。", "\n表7 六城市间的距离", "\n   L    B    W    G    S    K", "\nL 0    38  42   27   41  24", "\nB 38  0    8    21   13   22", "\nW42  8    0    26   10   29", "\nG 27  21  26   0    18    5", "\nS 41  13  10  18    0     25", "\nK 24  22  29   5    25    0"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这种必然要递归&lt;br /&gt;否则回溯会非常麻烦&lt;br /&gt;尤其有环路的时候容易造成死循环&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["走一堆二维平面的点，如何实现最小路径？", ["遇到的现象和发生背景，请写出第一个错误信息", "\n", "走一堆二维平面的点，如何实现最小路径？", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "  public static List<", "int", "> nextpoint(List<NewTrackData> currentlist, ", "int", " currentpoint)", "//当前list,当前点", "\n        {\n            double  distence;\n            double minidistence;\n            ", "for", " (", "int", " i = ", "0", "; i < currentlist.Count; i++)", "//去掉第一个点的新list", "\n            {\n                distence = Math.", "Pow((", "currentlist", "[", "i", "].Track.Start_X - ", "currentlist", "[", "currentpoint", "].Track.Start_X)", ", ", "2.0", ") + Math.", "Pow((", "currentlist", "[", "i", "].Track.Start_Y - ", "currentlist", "[", "currentpoint", "].Track.Start_Y)", ", ", "2.0", ");\n                Distencelist.", "Add(", "distence", ")", ";\n            }\n            minidistence = Distencelist.", "Min()", ";", "//获取list中的最小值", "\n            List<", "int", "> minilist = ", "new", " List<", "int", ">", "()", ";\n            ", "int", " minIndex = Distencelist.", "IndexOf(", "minidistence", ")", ";", "//获取最小值的索引集合", "\n            ", "for", " (", "int", " i = minIndex - ", "1", "; i < Distencelist.Count; i++)\n            {\n                ", "if", " (Distencelist", "[", "i", "]", " == ", "minIndex)\n                {\n                    minilist.", "Add(", "i", ")", ";\n                }\n            }\n             List<", "int", "> index = ", "new", " List<", "int", ">", "()", ";\n             ", "for", " (", "int", " i = ", "0", "; i < minilist.Count; i++)\n             {\n                 index.", "Add(", "currentlist", "[", "minilist", "[", "i", "]].", "originalIndex", ")", ";\n             }\n            return index;", "//原始list的顺序", "\n        }\n", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "1、先定一个起始点A;", "2、计算出起始点A与其他点的距离，比较出距离最短的那个点B；", "3、再用点B与其他点（除点A）比较找出距离最短的点C;但是如果存在D，F点BF，BD距离和BC距离一样如何确定下一个点？", "4、循环操作直到最后一个点，无需比较，直接找到还没有排序的点，追加在最后即可。", "5、然后将所有点循环定为起始点，将每一种点排序组合都加到数组A中，并将这种排序组合所有点连线计算出长度加到数组B中；", "6、找出数组B中值最小的下标，到数组A中找对应的点排列组合，这个排序结果就是最短路线点的排序。", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "这个叫做 中国邮递员问题，你可以google下\r\nhttps://www.cnblogs.com/WABoss/p/5140531.html", "Konwledge_Point": "最短路径", "Question": ["欧拉回路避桥法的扩展：遍历无向图里的所有边，当这个图不是欧拉回路时，怎样使得走过的重复边最少？", ["遍历所有点的问题是tsp问题，但是如果需要遍历所有的边呢？", "\n欧拉回路的避桥法可以对于欧拉回路，实现不重复的遍历所有边，", "\n但是如果该图不是欧拉回路，该怎样在最短行驶路径下遍历所有边呢？", "\n\n", "问题：", "\n\n", "\n给定一个无向连通图，不是欧拉图，需要遍历其中所有**边**，", "\n可以重复走边，问：怎样使得走过的重复路径最少？", "\n做课设需要解决这个问题，有相关的算法吗，", "\n如果没有，该怎样修改对于欧拉回路的避桥法呢？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;您好&amp;#xff0c;想法非常好&amp;#xff0c;也非常符合常识&amp;#xff0c;但是我认为核心问题集中在以下几点 &amp;#xff1a;&lt;br /&gt;第一&amp;#xff0c;‘从初始节点计算与其他节点的距离&amp;#xff0c;使每次选取下一落脚点距离当前节点最近’    能不能更快逼近最优解&amp;#xff1f;  能的。&lt;br /&gt;第二&amp;#xff0c;是否有这个必要&amp;#xff1f;我认为核心还是在于您不确定以这样的方式最终求得路径是否最短。也就是~~&lt;br /&gt;例如有【A1&amp;#xff0c;A2。。。。。。。AN】 N个节点&amp;#xff0c;取任一节点为起始节点&amp;#xff0c;计算出相邻节点最短的一条路径就是我们求的路径&amp;#xff1f;&lt;br /&gt;。。。这个我也不能肯定哈哈哈&amp;#xff0c;常识提醒我是这样的&amp;#xff0c;严谨告诉我最好在少量节点情况下验证一两次。&lt;br /&gt;第三&amp;#xff0c;可行性。假设有n个节点&amp;#xff0c;起始节点计算量为n-1次距离函数~~~~  &amp;#61;》倒数第二个节点计算量为1次函数。&lt;br /&gt;即总计算量为(1&amp;#43;n-1)&lt;em&gt;(n-1)/2 次距离函数. 随着节点数量的增大&amp;#xff0c;计算量也会逐渐增大&amp;#xff0c;那么会不会造成内存不够&amp;#xff1f;&lt;br /&gt;即第一次计算起始点与剩余所有点的距离取最小值就G了 &amp;#xff1f;如果节点在20~30个的话应该没太大的问题&amp;#xff0c;&lt;br /&gt;另外时间上n&lt;/em&gt;(n-1)/2次距离计算是否超出预期&amp;#xff1f;如果时间过长&amp;#xff0c;那么就需要考虑如何简化距离函数&amp;#xff0c;提高单次距离计算的效率。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;有用请采纳&amp;#xff0c;感谢&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["遗传算法种群初始化的优化必要性", ["假设用遗传算法去做一个类旅行商问题，从节点0开始，用最短的路径遍历所有的其他节点。我们假设存在一个具体的小示例如下：", "\n", "\n", "这时候，种群初始化有两种方案：", "\n", "（正常操作）随机节点1234的排列，如1234，4231。", "\n", "\n", "（设想的操作）根据当前出发点0，根据当前出发点与其他节点的距离 取倒数并做归一化。实现", "距离越近，越大概率取为染色体路径的下一个节点", "。选取后，再根据最新的节点路径做新的计算与取值。从直觉上，这样可以更快逼近最优解。但是是否有这个必要", "\n", "想问下这种操作的可行性和必要性，在节点数量大约20个、30个的情况下，会对后续的操作产生什么影响，如果是好影响，是什么。如果有坏影响的话，会有解决方法吗？"]], "Tag": "算法设计"}
{"Answer": "这里有一个\r\n[url]http://blog.csdn.net/java2000_net/archive/2008/05/01/2357485.aspx[/url]", "Konwledge_Point": "最短路径", "Question": ["谁有A*算法的DEMO", ["我最近在做一个搞怪碰碰球的游戏，可能大家以前也玩过，就是在某一直线上如果有5个同色的球相连就消球子得分否则就自动生成3个随机颜色的球子。但选择位置的时候你所选中的球子会判断你选择的位置是否有效（在关闭链表中，有障碍物等）如果有效会生成一条最短的路径自动移动过去，否则不动。", "\n\n", "这个项目着实让我郁闷了好久，到现在还是没有思路。求哪位大虾能指点迷津，最好是能有源代码，因为本人脑子比较笨不太擅长理解那种文字讲述性的文章。感激不尽！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考这些资源&amp;#xff0c;没有积分我可以帮你下载&amp;#xff1a;&lt;a href=\"https://download.csdn.net/download/l591492105/3429920?ops_request_misc&amp;#61;%257B%2522request%255Fid%2522%253A%2522162428184216780366551425%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fdownload.%2522%257D&amp;amp;request_id&amp;#61;162428184216780366551425&amp;amp;biz_id&amp;#61;1&amp;amp;utm_medium&amp;#61;distribute.pc_search_result.none-task-download-2~download~first_rank_v2~rank_dl_default-2-3429920.pc_v2_rank_dl_default&amp;amp;utm_term&amp;#61;%E6%B1%82%E5%87%BA%E5%AE%8C%E6%88%90%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%97%B6%E9%97%B4%E4%BB%A5%E5%8F%8A%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E3%80%81&amp;amp;spm&amp;#61;1018.2226.3001.4451\"&gt;关键路径问题&amp;#xff1a;设计程序求工程关键活动-C文档类资源-CSDN下载&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://download.csdn.net/download/weixin_43729663/12272577?ops_request_misc&amp;#61;%257B%2522request%255Fid%2522%253A%2522162428184216780366551425%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fdownload.%2522%257D&amp;amp;request_id&amp;#61;162428184216780366551425&amp;amp;biz_id&amp;#61;1&amp;amp;utm_medium&amp;#61;distribute.pc_search_result.none-task-download-2~download~first_rank_v2~rank_dl_default-4-12272577.pc_v2_rank_dl_default&amp;amp;utm_term&amp;#61;%E6%B1%82%E5%87%BA%E5%AE%8C%E6%88%90%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%97%B6%E9%97%B4%E4%BB%A5%E5%8F%8A%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E3%80%81&amp;amp;spm&amp;#61;1018.2226.3001.4451\"&gt;数据结构综合课设关键路径问题.docx-C/C&amp;#43;&amp;#43;文档类资源-CSDN下载&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["帮帮忙吧，哥哥们！！！！", ["最短工期的求解", "\n工程最短工期的求解", "\n基本要求：", "\n基本要求：", "\n设计一个程序，求出完成整项工程至少需要多少时间，以及整项工程中的关键活动。", "\n(1)通过菜单选项从键盘输入一个描述工程的AOE网（事件不少于10个），或者，从外部txt文件输入", "\nAOE网。", "\n(2)首先判断AOE网代表的施工图是否能够顺利进行。如果不能顺利进行，能通过菜单选项重新输入。", "\n(3)若该工程能顺利进行，输出关键路径和关键活动。", "\n(4)设计实现菜单方式的交互界面，界面友好，可反复操作。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;哈密顿回路&lt;br /&gt;如果对你有帮助&amp;#xff0c;望采纳&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["历遍所有点再回到原点，属于什么问题", ["手上只有点与点之间的距离，比如1到4、7、8,然后2到3、5、6,……之间的距离，每个点都能到达其中几个点且只知道距离不知道坐标。", "没有要求一定要走完每一条路，只要走完所有点回到原点就行，然后找最短的一条路径。", "我看了好像不属于tsp问题，因为不知道坐标", "也不属于邮递员问题，因为没必要走完每一条线。", "那么这种问题属于什么问题呢，我都不知道该怎么去查资料，或者可以用什么方法呢", "由于刚接触，可以不用给太详细（我也看不懂），给些查资料的方向吧，", "手头的数据是要做从至表然后整理成对称矩阵输入matlab吗？还是说其他什么矩阵"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该程序似乎旨在解决迷宫问题并打印它找到的路径。该程序在搜索解决方案时使用堆栈来存储路径的位置和方向。栈在迷宫的起点被初始化&amp;#xff0c;程序继续寻找解&amp;#xff0c;直到栈为空。&lt;/p&gt;\n&lt;p&gt;有几个可能的原因会导致程序在一段时间后自行停止。一种可能是程序遇到无限循环。这可能是由程序逻辑错误引起的&amp;#xff0c;例如缺少 break 语句或条件始终为真。&lt;/p&gt;\n&lt;p&gt;另一种可能性是程序内存不足。该程序使用一个结构数组来存储路径&amp;#xff0c;如果该数组不够大以容纳所有路径&amp;#xff0c;则可能导致程序崩溃或意外停止。&lt;/p&gt;\n&lt;p&gt;如果没有关于程序的具体行为和输入数据的更多信息&amp;#xff0c;就很难查明问题的确切原因。我建议检查代码并检查可能导致程序自行停止的任何潜在问题或错误。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["C语言数据结构链栈迷宫问题", ["\n", "为什么我在输入完出口后，过一会程序就自己停止了？\n\n下面是迷宫求解函数，问题应该就在这\n\nvoid ", "Path(", "int", " ", "**", "maze", ",", "int", " ", "m", ",", "int", " ", "n", ")", "    ", "//迷宫求解 ", "\n{\n    Direct direct", "[", "4", "]", ";    ", "//定义东，南，西，北四个方向 ", "\n    direct", "[", "0", "]", ".x = ", "0", ",direct", "[", "0", "]", ".y = ", "1", ";    ", "//向东走 ", "\n    direct", "[", "1", "]", ".x = ", "1", ",direct", "[", "1", "]", ".y = ", "0", ";    ", "//向南走 ", "\n    direct", "[", "2", "]", ".x = ", "0", ",direct", "[", "2", "]", ".y = -", "1", ";    ", "//向西走 ", "\n    direct", "[", "3", "]", ".x = -", "1", ",direct", "[", "3", "]", ".y = ", "0", ";    ", "//向北走", "\n    LNode *stack;\n    Temp T", "[MAX]", ",temp;\n    ", "int", " x,y,X,Y,d,count = ", "0", ",length,minlength;\n    ", "bool", " find = ", "false", ";\n    *(*(maze+", "1", ")+", "1", ") = -", "1", ";\n    temp.x = ", "1", ",temp.y = ", "1", ",temp.d = -", "1", ";\n    ", "Init(", "stack", ")", ";\n    ", "Push(", "stack", ",", "temp", ")", ";\n    ", "while", "(!is", "Empty(", "stack", ")", ")\n    {\n        get", "Pop(", "stack", ",&", "temp", ")", ";\n        x = temp.x,y = temp.y,d = temp.d + ", "1", ";\n        ", "if", "(x", " == ", "m&&y", " == ", "n)\n        {\n            length = ", "0", ";\n            printf(", "\"迷宫第%d条路径如下：\"", ",++count);\n            ", "while", "(!is", "Empty(", "stack", ")", "){\n                ", "Pop(", "stack", ",&", "temp", ")", ";\n                T", "[", "length", "++", "]", " = temp;\n            }\n            ", "if", "(length < minlength)\n            {\n                minlength = length;\n            }\n            ", "for", "(", "int", " i = ", "1", ";length > ", "0", ";i++)\n            {\n                printf(", "\"[%d,%d],%d \"", ",T", "[--", "length", "]", ".x,T", "[", "length", "]", ".y,T", "[", "length", "]", ".d);\n                ", "Push(", "stack", ",T[", "length", "])", ";\n                ", "if", "(i % ", "5", " == ", "0", ")\n                printf(", "\"\\n\"", ");\n            }\n            printf(", "\"\\n\"", ");\n            ", "Pop(", "stack", ",&", "temp", ")", ";\n            *(*(maze+temp.x)+temp.y) = ", "0", ";\n        }\n        ", "else", "\n        {\n            ", "Pop(", "stack", ",&", "temp", ")", ";\n            *(*(maze+temp.x)+temp.y) = ", "0", ";\n        }\n        ", "while", "(d<", "4", ")\n        {\n            X = x + direct", "[", "d", "]", ".x;\n            Y = y + direct", "[", "d", "]", ".y;\n            ", "if", "(*(*(maze+X)+Y)", " == ", "0", ")\n            {\n                temp.x = X,temp.y = Y,temp.d = d;\n                ", "Push(", "stack", ",", "temp", ")", ";\n                x = X,y = Y,*(*(maze+X)+Y) = -", "1", ";\n                d = ", "0", ";\n            }\n            ", "else", "\n            {\n                d++;\n            }\n        }\n    }\n    printf(", "\"最短的一条路径是路径是第%d条路径\\n\"", ",minlength);\n    ", "if", "(find", " == ", "false", ")\n    printf(", "\"该迷宫没有可以到达出口的路径！\\n\"", ");\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;concat 可以一次性合并多个 dataFrame&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;filenames&amp;#61;os.listdir(path)\ndf_list &amp;#61; []\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;filename&lt;/span&gt; in filenames:\n    df_list.&lt;span class=\"hljs-keyword\"&gt;append&lt;/span&gt;(pd.read_excel(path &amp;#43; &amp;#39;\\&amp;#39; &amp;#43; &lt;span class=\"hljs-keyword\"&gt;filename&lt;/span&gt;))\nresult_df &amp;#61; pd.&lt;span class=\"hljs-keyword\"&gt;concat&lt;/span&gt;(df_list)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["Python合并表格时间太长怎么解决?", ["求助各位，我用的是pycharm教育版，合并三个表，累计行数在四万行左右，以下是我写的代码，运行时间最短的一次也是一百六十多秒，并且运行一次一次比一次久，最后一次将近四百秒了，求帮忙看下代码写的有什么问题，或者可以怎么改，谢谢，好人一生平安", "\n", "import", " os\n", "import", " pandas ", "as", " pd\n", "import", " time\nstart=time.time()\npath=", "r'D:\\我的工作文件夹\\A 可视化\\sales_order'", "\nempty=pd.DataFrame()\ny=os.listdir(path)\n", "for", " i ", "in", " y:\n    df=pd.read_excel(path+", "'\\%s'", "%i)\n    ", "#连接路径和表名", "\n    empty=pd.concat([empty,df])\nempty.to_excel(excel_writer = ", "r'D:\\我的工作文件夹\\A 可视化\\sales_order.xlsx'", ",sheet_name=", "'order'", ",index=", "False", ")\nend=time.time()\n", "print", "(", "'代码运行时间为:%.2f 秒'", "%", "round", "(end-start,", "2", ")) \n\n"]], "Tag": "算法设计"}
{"Answer": "http://www.cnblogs.com/fenglianchen/p/7674766.html", "Konwledge_Point": "最短路径", "Question": ["求大神，求大咖，不会安装啊", ["请问如何安装 sql server 2008？？在win10环境下的"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;类似于“有限制条件的动态规划旅行商问题”的方法&amp;#xff0c;我们需要定义一个状态 (S, i, p)&amp;#xff0c;其中S是已访问过的顶点集合&amp;#xff08;包括取件点和送货点&amp;#xff09;&amp;#xff0c;i是当前所在的顶点&amp;#xff0c;p表示当前手中的包裹来源&amp;#xff08;取件点集合&amp;#xff09;。转移方程&lt;/p&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;&lt;br /&gt;dp[S, i, p] &amp;#61; min(dp[S, i, p], dp[S-{i}, j, p-{i}] &amp;#43; dist(j, i))&lt;/p&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;j是S中的一个顶点&amp;#xff0c;且满足以下条件&amp;#xff1a;若i是一个送货点&amp;#xff0c;则j必须是与i对应的取件点之一。在递推的过程中&amp;#xff0c;需要保证p始终包含了当前所在的送货点所需的包裹来源初。始化状态和边界条件。dp[S, i, p]初始化为无穷大&amp;#xff08;表示不可达&amp;#xff09;。边界条件为&amp;#xff1a;当S只包含一个顶点&amp;#xff08;即某个取件点&amp;#xff09;时&amp;#xff0c;dp[S, i, p]为0&amp;#xff0c;其中i表示该取件点。&lt;/p&gt;\n&lt;p&gt;最后&amp;#xff0c;遍历所有状态并更新动态规划数组&amp;#xff0c;通过回溯法找到最短路径。&lt;br /&gt;送货点数量不会超过250个&amp;#xff0c;可以试试看这个。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["TSP旅行商问题，多个取件点，可返回，不一定回原点算法", ["我是一个送货员，我想计算出一日工作的最短路程。", "具体：", "\n", "公司有多个取件点，而我每天早上可以随意选从哪一个取件点开始配送", "每一个配送点要送的包裹都有对应的单个或多个取件点（可能一个送货点有来自取件点A和B甚至更多不同地方的包裹要取），要保证去配送的时候手里有对应的包裹（就是之前去过对应包裹的取件点）", "可多次去一个送货点", "每天不用回到初始点，只要回到任意取件点就行", "包裹不限重量，默认去一个取件点就把所有包裹都带上", "每日的送货点不会超过250个", "\n", "背景：之前做了一个GIS系统，需要加上这个送货员功能，目前可以计算两点之间的最短路线，在这里我用的是C++", "个人初步搜索：我浏览了网络上的TSP旅行商问题，也大致了解了解法（但不明白原理所以不知道怎么自己修改）。在想是忽略取货问题先找出所有点的最短路径，然后以那个基础上去改进路线比较好，还是这样子算走远了。如果可以的话，那我该怎么优化路径我也不知道。", "\n", "想问一下在这个条件下该怎么算会更快，谢谢大家"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;Dijkstra算法伪代码 \n\nfor each node v    \n    dis(v) ← &amp;#43;∞    \n    previous (v) ← undefined    \n    dis(source) ← 0    \n    while num(S) &amp;lt; n    ▷ S为顶点集合\n        u ← node with smallest distance    \n        Remove u    \n        for each node v in S    \n            alt ← dis(u) &amp;#43; dis(u,v)    \n            if alt &amp;lt; dis(v) then    \n                dis(v) ← alt    ▷ 更新距离\n                previous(v) ← u    \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以参考这篇博客&amp;#xff08;含MATLAB代码&amp;#xff09;&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/lishan132/article/details/108527271\" id=\"textarea_1650988419256_1650988630188_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/lishan132/article/details/108527271&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;这篇里面有讲解&amp;#xff08;有示例讲解&amp;#xff09;&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/L_J_Kin/article/details/103061420\" id=\"textarea_1650988419256_1650988630188_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/L_J_Kin/article/details/103061420&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["Matlab 最短路径 起始点出发，回到起始点，经过所有点", ["利用matlab图论知识求解，从起始点出发，经过其他所有点，然后返回起始点，求最短路径"]], "Tag": "算法设计"}
{"Answer": "TSP问题本质和城市间最短路径寻优问题一样，都是求两个点的最优路径，这种问题你要把这些实际数据想成是图的操作\r\nhttp://www.cnblogs.com/biaoyu/archive/2012/09/26/2704456.html", "Konwledge_Point": "最短路径", "Question": ["蚁群算法 寻找最短路径的问题", ["想搞个城市间最短路径寻优，网上全都是tsp问题，我只想要起点到终点的最优路径，不需要返回，该怎么写。。。能不能给点代码……"]], "Tag": "算法设计"}
{"Answer": "已找到，使用图网络模型可以实现。", "Konwledge_Point": "最短路径", "Question": ["神经网络能否不失一般性地解图的最短路径问题？", ["\n\n", "解最短路径问题，我看了一些网上的例子，多是训练DQN能够在某一特定图中找到最短路径（如图，在这个特定图中学习如何绕过黑点到达黄点）", "\n\n", "这种训练，相当于特定图的拓扑存储在了Q Matrix中，当图（环境）改变时则需要重新训练。", "\n问题：请问神经网络能否不失一般性地解图的最短路径问题？也就是不依赖某种特定的图拓扑，每次输入图拓扑和起点终点，输出最优路径"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#define INF 1000000; 这里的分号去掉&lt;br /&gt;输入3 2&amp;#xff0c;中间不能带逗号&amp;#xff0c; 因为你是scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;m);&amp;#xff0c;两个%d之间没有逗号&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["迪杰斯特拉求任意一点的最短路径问题遇到错误情况无法实现", ["代码运行结果不对怎么直接就输出结果了，还有通过visit数组来判断是否经过那个点不知道正不正确", "\n", "#include<stdio.h>", "#define SIZE 110", "#define INF 1000000;", "int map[SIZE][SIZE];  //邻接矩阵存储", "int len[SIZE];      //d[i]表示源点到i这个点的距离", "int visit[SIZE];  //节点是否被访问", "int n,m,j,pos,ans,temp;", " int temp = INF;", "\n", "int dijkstra(int from, int to){    //从源点到目标点", "    int i;", "    for(i = 1 ; i <= n ; i ++){    //初始化", "        visit[i] = 0;    //一开始每个点都没被访问", "        len[i] = map[from][i];    //先假设源点到其他点的距离", "    }  ", "\n", "for", "(i = ", "1", " ; i < n ; ++i){    ", "//对除源点的每一个点进行最短计算 ", "\n    ", "int", " min = INF;  ", "//记录最小len[i] ", "\n      ", "//记录小len[i] 的点 ", "\n    ", "for", "(j = ", "1", " ; j <= n ; ++j){    \n        ", "if", "(!visit[j] && min > ", "len", "[j]){  \n            pos = j;  \n            min = ", "len", "[j];  \n        }  \n    }  \n    visit[pos] = ", "1", ";  \n    ", "for", "(j = ", "1", " ; j <= n ; ++j){\n        ", "if", "(!visit[j] && (", "len", "[j] > (", "len", "[pos] +", "map", "[pos][j]))){ ", "//如果j节点没有被访问过&&j节点到源节点的最短路径>pos节点到源节点的最短路径+pos节点到j节点的路径  ", "\n            ", "len", "[j] = ", "len", "[pos] + ", "map", "[pos][j];    ", "//更新j节点到源节点的最短路径    ", "\n        }  \n    }  \n}  \n", "return", " ", "len", "[to];\n", "\n", "}", "\n", "int main ()", "{  ", "\n", "int", " i,j;  \n\n", "int", " ans,u,v;\n\n", "printf", "(", "\"输入顶点和边数\"", ");\n", "scanf", "(", "\"%d%d\"", ",&n,&m);    ", "//输入数据", "\n\n\n", "for", "(i = ", "1", " ; i <= n ; ++i){    ", "//设一开始每个点都不可达 ", "\n    ", "for", "(j = ", "1", " ; j <= n ; ++j){  \n        map[i][j] = INF;  \n    }  \n}  \n\n", "int", " a,b,c;    ", "//输入数据 ", "\n", "for", "(i = ", "1", " ; i <= m ; ++i){  \n    ", "scanf", "(", "\"%d%d%d\"", ",&a,&b,&c);  \n    map[a][b] = map[b][a] = c;  \n}  \n", "\n", "   printf(\"输入起点和终点：\");", "   scanf(\"%d,%d\",&u,&v);", "\n", "ans=dijkstra(u,v);\n", "for", "(i=", "0", ";i<=n;i++)//输出途径点 \n{\n    ", "if", "(visit[i]==", "1", ")\n    {\n        ", "printf", "(", "\"%d\"", ",i);\n    }\n}\n", "printf", "(", "\"%d\"", ",ans);  \n\n", "return", " ", "0", ";  \n", "\n", "} ", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;上方图中共10个点&amp;#xff0c;确定了起点&amp;#xff0c;相当于9个点的全排列&amp;#xff0c;可以非递归实现&amp;#xff0c;也可以递归实现。&lt;br /&gt;共有9的阶乘&amp;#xff1a;362880种走法&amp;#xff0c;分别计算每一种路径的总距离&amp;#xff0c;取最小的。运行截图如下&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/441053271136188.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;并结合了matplotlib和 pyecharts 可视化出了最短路径分别如下图&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/539693271136124.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/109224271136120.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;源码见&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_40985985/article/details/120199441\" id=\"textarea_1631358369087_1631358407996_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Python访问街区所有节点最短路径问题&amp;#xff0c;并结合matplotlib可视化_程序媛一枚~的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;这篇博客将介绍如何全排列街区的点&amp;#xff0c;即规定起点不重复的走完所有街区&amp;#xff0c;并找出最短路径&amp;#xff0c;并结合matplotlib、pyecharts对最短路径进行可视化。&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_40985985/article/details/120199441&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;回答不易&amp;#xff0c;有帮助麻烦点下采纳哦&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["访问所有节点的最短路径问题，节点只能访问一次，python实现。", ["已知起点（310,385），访问所有节点，节点只能访问一次，不用返回起点。求最短路径，python实现，CVXPY 最好。思路和代码请详细说明，以便我学习。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个是最短路径计算&amp;#xff0c;运费应该两个地点之间经过节点数计算&amp;#xff0c;比如a到c&amp;#xff0c;&amp;#xff0c;经过5个节点&amp;#xff0c;每个节点收费5元&amp;#xff0c;运费就25元。你的要求包括了好几种最短路径算法&amp;#xff0c;具体可以参考&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/printfxgd/article/details/80791847\" id=\"textarea_1637156922423_1637157011619_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/printfxgd/article/details/80791847&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["城市交通查询系统设计", ["题目3: 城市交通查询系统设计内容：设计一个交通查询系统，能够查询：1)从一个城市到其它各城市之间的最短路径或运费最少的路径;2）多个城市中任意一对城市之间的最短路径或运费最少的路径。设计要求：（1）建立关于城市信息结点的结构体；（2）定义城市信息链表的结点结构；（3）建立交通网络图的存储结构；（4）写出采用Dijksta算法求每对顶点之间最短路径的算法函数；  （5）写出采用Floyed算法求任意一对顶点之间最短路径的算法函数；（6）输入交通网络图中的路径信息或费用信息；（7）根据Dijksta算法计算从太原到其它各大城市的最短路径或最小费用；（8）根据Floyed算法计算任意一对大城市之间的最短路径或最小费用；（9）对于不同的查询要求可以输入已知城市间的路程或所需费用信息。"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/ShiWaiGaoRen12345/article/details/69808597", "Konwledge_Point": "最短路径", "Question": ["最短路径的数据结构的问题，C语言的问题，具体怎么解决的思路的问题", ["Problem Description", "\nThere are n points on the plane, Pi(xi, yi)(1 <= i <= n), and xi < xj (i\nBefore you reach the rightmost point Pn, you can only visit the points those have the bigger x-coordinate value. For example, you are at Pi now, then you can only visit Pj(j > i). When you reach Pn, the rule is changed, from now on you can only visit the points those have the smaller x-coordinate value than the point you are in now, for example, you are at Pi now, then you can only visit Pj(j < i). And in the end you back to P1 and the tour is over.", "\nYou should visit all points in this tour and you can visit every point only once.", "\n\n", "Input", "\nThe input consists of multiple test cases. Each case begins with a line containing a positive integer n(2 <= n <= 200), means the number of points. Then following n lines each containing two positive integers Pi(xi, yi), indicating the coordinate of the i-th point in the plane.", "\n\n", "Output", "\nFor each test case, output one line containing the shortest path to visit all the points with the rule mentioned above.The answer should accurate up to 2 decimal places.", "\n\n", "Sample Input", "\n3", "\n1 1", "\n2 3", "\n3 1", "\n\n", "Sample Output", "\n6.47"]], "Tag": "算法设计"}
{"Answer": "这个图有点特殊，每个节点都是关键节点，多条关键路径，因此每个节点的最早开始时间和最晚开始时间都是一样的。我认为是对的。", "Konwledge_Point": "最短路径", "Question": ["最短路径中最早开始时间和最晚开始时间，写的对吗", []], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdio.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;OP&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; next[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;], num &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//  记入它接下来抵达的地方,num 为个数&lt;/span&gt;\n}op[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;];                    &lt;span class=\"hljs-comment\"&gt;//  表示点个数,0为出发地,10000为目的地&lt;/span&gt;\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; f[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;],key[&lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;],k_len&amp;#61;&lt;span class=\"hljs-number\"&gt;50000&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;find_MinRoad&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; now,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num)&lt;/span&gt;&lt;/span&gt;{  &lt;span class=\"hljs-comment\"&gt;// 当前位置,当前走的步数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(now&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(num&amp;lt;k_len) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(k_len&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k_len&amp;lt;num;k_len&amp;#43;&amp;#43;) key[k_len] &amp;#61; f[k_len];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(now!&amp;#61;&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;op[now].num;z&amp;#43;&amp;#43;) {\n            f[num] &amp;#61; op[now].next[z];\n            &lt;span class=\"hljs-built_in\"&gt;find_MinRoad&lt;/span&gt;(op[now].next[z],num&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        }\n    }\n\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; road,a,b;                      &lt;span class=\"hljs-comment\"&gt;//  road : 输入中间路的总个数&amp;#xff0c;你的图为13,如果更多点把int 换成long op那的数组也再开大点&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;road);\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (road--){\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b); &lt;span class=\"hljs-comment\"&gt;// a-&amp;gt;b&lt;/span&gt;\n        op[a].next[op[a].num&amp;#43;&amp;#43;] &amp;#61; b;\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;find_MinRoad&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,k_len&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;k_len;z&amp;#43;&amp;#43;) &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,key[z]);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）", ["对于下图，利用最短路径算法，找到从家到学校最短路径长度（能够输出对应路径更好）（C语言）"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/u014569598/article/details/25472851", "Konwledge_Point": "最短路径", "Question": ["Risk(Floyd)               ", ["Risk is a board game in which several opposing players attempt to conquer the world. The gameboard consists of a world map broken up into hypothetical countries. During a player's turn, armies stationed in one country are only allowed to attack only countries with which they share a common border. Upon conquest of that country, the armies may move into the newly conquered country.", "\nDuring the course of play, a player often engages in a sequence of conquests with the goal of transferring a large mass of armies from some starting country to a destination country. Typically, one chooses the intervening countries so as to minimize the total number of countries that need to be conquered. Given a description of the gameboard with 20 countries each with between 1 and 19 connections to other countries, your task is to write a function that takes a starting country and a destination country and computes the minimum number of countries that must be conquered to reach the destination. You do not need to output the sequence of countries, just the number of countries to be conquered including the destination. For example, if starting and destination countries are neighbors, then your program should return one.", "\n\n", "The following connection diagram illustrates the sample input.", "\n\n", "Input", "\n\n", "Input to your program will consist of a series of country configuration test sets. Each test set will consist of a board description on lines 1 through 19. The representation avoids listing every national boundary twice by only listing the fact that country I borders country J when I < J. Thus, the Ith line, where I is less than 20, contains an integer X indicating how many \"higher-numbered\" countries share borders with country I, then X distinct integers J greater than I and not exceeding 20, each describing a boundary between countries I and J. Line 20 of the test set contains a single integer (1 <= N <= 100) indicating the number of country pairs that follow. The next N lines each contain exactly two integers (1 <= A,B <= 20; A!=B) indicating the starting and ending countries for a possible conquest.", "\n\n", "There can be multiple test sets in the input; your program should continue reading and processing until reaching the end of file. There will be at least one path between any two given countries in every country configuration.", "\n\n", "Output", "\n\n", "For each input set, your program should print the following message \"Test Set #T\" where T is the number of the test set starting with 1. The next NT lines each will contain the result for the corresponding test in the test set - that is, the minimum number of countries to conquer. The test result line should contain the start country code A the string \" to \" the destination country code B ; the string \": \" and a single integer indicating the minimum number of moves required to traverse from country A to country B in the test set. Following all result lines of each input set, your program should print a single blank line.", "\n\n", "Sample Input", "\n\n", "1 3 ", "\n2 3 4 ", "\n3 4 5 6 ", "\n1 6 ", "\n1 7 ", "\n2 12 13 ", "\n1 8 ", "\n2 9 10 ", "\n1 11 ", "\n1 11 ", "\n2 12 17 ", "\n1 14 ", "\n2 14 15 ", "\n2 15 16 ", "\n1 16 ", "\n1 19 ", "\n2 18 19 ", "\n1 20 ", "\n1 20 ", "\n5 ", "\n1 20 ", "\n2 9 ", "\n19 5 ", "\n18 19 ", "\n16 20", "\n\n", "Sample Output", "\n\n", "Test Set #1 ", "\n1 to 20: 7 ", "\n2 to 9: 5 ", "\n19 to 5: 6 ", "\n18 to 19: 2 ", "\n16 to 20: 2 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;根据要求&amp;#xff0c;大体的功能已实现&amp;#xff0c;代码如下。&lt;br /&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n\n#define THRESHOLD   &lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//用户基本信息&lt;/span&gt;\ntypedef struct _userInfo {\n    int id;         &lt;span class=\"hljs-comment\"&gt;//学号&lt;/span&gt;\n    char &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];  &lt;span class=\"hljs-comment\"&gt;//姓名&lt;/span&gt;\n    char gender[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//性别&lt;/span&gt;\n    int age;        &lt;span class=\"hljs-comment\"&gt;//年龄&lt;/span&gt;\n    int step;       &lt;span class=\"hljs-comment\"&gt;//行走步数&lt;/span&gt;\n    struct _userInfo *next;\n} UsrInfo;\n&lt;span class=\"hljs-comment\"&gt;//好友关系以及熟悉程度&lt;/span&gt;\ntypedef struct _relation {\n    int id1;        &lt;span class=\"hljs-comment\"&gt;//用户1学号&lt;/span&gt;\n    int id2;        &lt;span class=\"hljs-comment\"&gt;//用户2学号&lt;/span&gt;\n    int familiar;   &lt;span class=\"hljs-comment\"&gt;//好友熟悉程度&lt;/span&gt;\n    struct _relation *next;\n} Relation;\n&lt;span class=\"hljs-comment\"&gt;//接收信息缓冲区&lt;/span&gt;\ntypedef struct _buffer {\n    int id;                 &lt;span class=\"hljs-comment\"&gt;//用户学号&lt;/span&gt;\n    char msg[THRESHOLD];    &lt;span class=\"hljs-comment\"&gt;//接收信息缓冲区&lt;/span&gt;\n    int len;                &lt;span class=\"hljs-comment\"&gt;//累积的信息长度&lt;/span&gt;\n    struct _buffer *next;\n} Buffer;\n&lt;span class=\"hljs-comment\"&gt;//用户信息节点&amp;#xff08;如果改成这种结构可能更好一些&amp;#xff0c;同一用户的信息全部在一个结构体&amp;#xff0c;统一一个链表管理&amp;#xff09;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//typedef struct _node {&lt;!-- --&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    UsrInfo usrInfo;    //用户基本信息&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    Relation relation;  //好友关系以及熟悉程度&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    Buffer buffer;      //接收信息缓冲区&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    struct _node *next;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//} UsrNode;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//UsrNode *head &amp;#61; NULL;   //用户信息链表头节点&lt;/span&gt;\nUsrInfo *lst &amp;#61; NULL; &lt;span class=\"hljs-comment\"&gt;//用户基本信息链表头节点&lt;/span&gt;\nRelation *rel &amp;#61; NULL; &lt;span class=\"hljs-comment\"&gt;//用户好友关系以及熟悉程度信息链表头节点&lt;/span&gt;\nBuffer *buf &amp;#61; NULL; &lt;span class=\"hljs-comment\"&gt;//用户接收信息缓冲区链表头节点&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//添加用户&lt;/span&gt;\nint addUsr(UsrInfo *lst, int id, char *&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, char *gender, int age, int step)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL) {\n        return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    UsrInfo *p &amp;#61; lst;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id) { &lt;span class=\"hljs-comment\"&gt;//查找到有这个id的用户&lt;/span&gt;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加用户失败&amp;#xff0c;id&amp;#61;%d的用户已存在&amp;#xff01;&amp;#34;&lt;/span&gt;, id);\n            return -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL) {\n            UsrInfo *node &amp;#61; (UsrInfo *)malloc(sizeof(UsrInfo));\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id &amp;#61; id;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(node-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(node-&amp;gt;&lt;/span&gt;gender, gender);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;age &amp;#61; age;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;step &amp;#61; step;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; node;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//同步生成接收信息缓冲区节点&lt;/span&gt;\n    Buffer *p2 &amp;#61; buf;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p2) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id) { &lt;span class=\"hljs-comment\"&gt;//查找到有这个id的用户&lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//直接清空就可以&lt;/span&gt;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL) {\n            Buffer *node &amp;#61; (Buffer *)malloc(sizeof(Buffer));\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id &amp;#61; id;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; node;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt; &amp;#61; p2-&amp;gt;&lt;/span&gt;next;\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//添加好友&lt;/span&gt;\nint addFriend(Relation *rel, int id1, int id2, int familiar)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(rel &amp;#61;&amp;#61; NULL) {\n        return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    int flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    UsrInfo *p &amp;#61; lst;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//查找用户是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id1) {\n            flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id2) {\n            flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag1 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        return -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//id1用户不存在&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag2 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        return -&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//id2用户不存在&lt;/span&gt;\n    }\n    Relation *q &amp;#61; rel;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(q) { &lt;span class=\"hljs-comment\"&gt;//查找好友关系是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;((q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id1 &amp;amp;&amp;amp; q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id2&lt;/span&gt; &amp;#61;&amp;#61; id2) || (q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id2 || q-&amp;gt;&lt;/span&gt;id2 &amp;#61;&amp;#61; id1)) {\n            return -&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(q-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL) {\n            Relation *node &amp;#61; (Relation *)malloc(sizeof(Relation));\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id1 &amp;#61; id1;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;id2 &amp;#61; id2;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;familiar &amp;#61; familiar;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; node;\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;next;\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//从高到低打印用户行走步数的排行榜&lt;/span&gt;\nvoid printSteps(UsrInfo *lst)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL) {\n        return;\n    }\n    int n &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n\\n&amp;#34;&lt;/span&gt;);\n    U&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;srInfo&lt;/span&gt; *p &amp;#61; lst-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//遍历链表&amp;#xff0c;统计用户个数&lt;/span&gt;\n        n&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;行走步数排行榜为空&amp;#xff0c;当前没有用户&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        char &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[n][&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;], s[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n        int step[n];\n        int m &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, t;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; lst-&amp;gt;&lt;/span&gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//遍历链表&amp;#xff0c;取出用户姓名和行走步数&lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[m], p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;step&lt;/span&gt;[m] &amp;#61; p-&amp;gt;&lt;/span&gt;step;\n            m&amp;#43;&amp;#43;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) { &lt;span class=\"hljs-comment\"&gt;//冒泡排序&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;-i; j&amp;#43;&amp;#43;) {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(step[j] &amp;lt; step[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) {\n                    t &amp;#61; step[j];\n                    step[j] &amp;#61; step[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                    step[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t;\n                    strcpy(s, &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j]);\n                    strcpy(&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j], &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n                    strcpy(&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], s);\n                }\n            }\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;行走步数排行榜\\n\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;排名\\t姓名\\t行走步数\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;) {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t%s\\t%d\\n&amp;#34;&lt;/span&gt;, i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[i], step[i]);\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;//发送消息&lt;/span&gt;\nvoid sendMsg(UsrInfo *lst, Relation *rel, Buffer *buf, int id1, int id2, char *msg)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL || rel &amp;#61;&amp;#61; NULL || buf &amp;#61;&amp;#61; NULL) {\n        return;\n    }\n    int flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    UsrInfo *p &amp;#61; lst;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) { &lt;span class=\"hljs-comment\"&gt;//查找用户是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id1) {\n            flag1 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id2) {\n            flag2 &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag1 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送消息失败&amp;#xff0c;id1&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1);\n        return;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag2 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送消息失败&amp;#xff0c;id2&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id2);\n        return;\n    }\n    Relation *q &amp;#61; rel;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(q) { &lt;span class=\"hljs-comment\"&gt;//查找好友关系是否存在&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;((q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id1 &amp;amp;&amp;amp; q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id2&lt;/span&gt; &amp;#61;&amp;#61; id2) || (q-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id1&lt;/span&gt; &amp;#61;&amp;#61; id2 || q-&amp;gt;&lt;/span&gt;id2 &amp;#61;&amp;#61; id1)) {\n            break;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; q-&amp;gt;&lt;/span&gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(q &amp;#61;&amp;#61; NULL) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送消息失败&amp;#xff0c;id1&amp;#61;%d和id2&amp;#61;%d不是好友关系&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1, id2);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        Buffer *p2 &amp;#61; buf;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p2) { &lt;span class=\"hljs-comment\"&gt;//查找用户是否存在&lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;id &amp;#61;&amp;#61; id2) {\n                int msgLen &amp;#61; strlen(msg); &lt;span class=\"hljs-comment\"&gt;//信息长度&lt;/span&gt;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;len &amp;#43; msgLen &amp;gt; THRESHOLD) { &lt;span class=\"hljs-comment\"&gt;//缓冲区中积累的信息长度超过THRESHOLD&amp;#61;32个字符&lt;/span&gt;\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;接收信息缓冲区的内容&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(int i&amp;#61;0; i&amp;lt;p2-&amp;gt;&lt;/span&gt;len; i&amp;#43;&amp;#43;) {\n                        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%c&amp;#34;, p2-&amp;gt;&lt;/span&gt;msg[i]);\n                    }\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, msg);\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                }\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(p2-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;msg&lt;/span&gt; &amp;#43; p2-&amp;gt;&lt;/span&gt;len, msg);\n                    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;-&amp;gt;&lt;/span&gt;len &amp;#43;&amp;#61; msgLen;\n                }\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;id1&amp;#61;%d向id2&amp;#61;%d发送信息成功&amp;#xff0c;id2&amp;#61;%d用户接收信息缓冲区的信息长度为%d\\n&amp;#34;, id1, id2, id2, p2-&amp;gt;&lt;/span&gt;len);\n                break;\n            }\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt; &amp;#61; p2-&amp;gt;&lt;/span&gt;next;\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//打印当前所有用户基本信息&lt;/span&gt;\nvoid printAllUsrInfo(UsrInfo *lst)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst &amp;#61;&amp;#61; NULL) {\n        return;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n\\n&amp;#34;&lt;/span&gt;);\n    U&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;srInfo&lt;/span&gt; *p &amp;#61; lst-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;id:     %d\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;id);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;:   %s\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;gender: %s\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;gender);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;age:    %d\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;age);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;step:   %d\\n&amp;#34;, p-&amp;gt;&lt;/span&gt;step);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;********************************\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;//计算各用户间的最短距离和最短路径&amp;#xff08;这个不好写&amp;#xff09;&lt;/span&gt;\n\nint main()\n{\n    int ret, select, running &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    lst &amp;#61; (UsrInfo *)malloc(sizeof(UsrInfo)); &lt;span class=\"hljs-comment\"&gt;//用户基本信息链表头节点&lt;/span&gt;\n    rel &amp;#61; (Relation *)malloc(sizeof(Relation)); &lt;span class=\"hljs-comment\"&gt;//用户好友关系以及熟悉程度信息链表头节点&lt;/span&gt;\n    buf &amp;#61; (Buffer *)malloc(sizeof(Buffer)); &lt;span class=\"hljs-comment\"&gt;//用户接收信息缓冲区链表头节点&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(running &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;1 添加用户\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;2 添加好友\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;3 发送消息\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;4 打印行走步数的排行榜\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;5 打印当前所有用户基本信息\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;0 退出\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;Select &amp;gt; &amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;select);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n        switch (select) {\n        case &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        {\n            UsrInfo usrInfo;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;usrInfo.id);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, usrInfo.&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;性别&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, usrInfo.gender);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;年龄&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;usrInfo.age);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;行走步数&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;usrInfo.step);\n            ret &amp;#61; addUsr(lst, usrInfo.id, usrInfo.&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, usrInfo.gender, usrInfo.age, usrInfo.step);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加id&amp;#61;%d的用户成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, usrInfo.id);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加用户失败&amp;#xff0c;id&amp;#61;%d的用户已存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, usrInfo.id);\n            }\n            break;\n        }\n        case &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n        {\n            int id1, id2, familiar;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;用户1学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id1);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;用户2学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id2);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;熟悉程度&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;familiar);\n            ret &amp;#61; addFriend(rel, id1, id2, familiar);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友失败&amp;#xff0c;id1&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友失败&amp;#xff0c;id2&amp;#61;%d的用户不存在&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id2);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ret &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;) {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加好友失败&amp;#xff0c;id1&amp;#61;%d和id2&amp;#61;%d已经是好友关系&amp;#xff01;\\n&amp;#34;&lt;/span&gt;, id1, id2);\n            }\n            break;\n        }\n        case &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n        {\n            int id1, id2;\n            char msg[&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送方用户学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id1);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;接收方用户学号&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;id2);\n            getchar();\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;发送的信息&amp;#xff1a; &amp;#34;&lt;/span&gt;);\n            gets(msg);\n            sendMsg(lst, rel, buf, id1, id2, msg);\n            break;\n        }\n        case &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n            printSteps(lst);\n            break;\n        case &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;:\n            printAllUsrInfo(lst);\n            break;\n        case &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            running &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            break;\n        default:\n            break;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(running &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;//释放链表内存空间&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(lst) {\n        UsrInfo *p &amp;#61; lst;\n        UsrInfo *q &amp;#61; p;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n            free(p);\n            p &amp;#61; q;\n        }\n        lst &amp;#61; NULL;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(rel) {\n        Relation *p &amp;#61; rel;\n        Relation *q &amp;#61; p;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n            free(p);\n            p &amp;#61; q;\n        }\n        rel &amp;#61; NULL;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(buf) {\n        Buffer *p &amp;#61; buf;\n        Buffer *q &amp;#61; p;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n            free(p);\n            p &amp;#61; q;\n        }\n        buf &amp;#61; NULL;\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["数据结构题，比较急迫，c语言编写", ["设计一个好友通信模拟软件，提供用户管理、好友管理、消息发送、运动健康等功能，具体需求如下：", "选择合适的数据结构（逻辑结构和物理结构）维护用户基本信息列表（即UsrInfo，包括学号id、姓名name、性别gender、年龄age、行走步数step）。（10分）", "选择合适的数据结构（逻辑结构和物理结构）维护用户间的好友关系以及熟悉程度（即Relation）。（10分）", "选择合适的数据结构（逻辑结构和物理结构）维护每个用户的接收信息缓冲区（即Buffer）。（10分）", "实现int addUsr(UsrInfo* lst, int id, char* name, char* gender, int age, int step)函数，向lst中新增用户并初始化基本信息，返回是否新增成功。（12分=算法设计与分析3分+算法实现9分）", "实现int addFriend(Relation* rel, int id1, int id2, int familiar)函数，向rel中新增id1和id2两个用户之间的好友关系；familiar为两用户间的熟悉程度（值越小表示熟悉程度越高），返回是否构建成功。（12分=算法设计与分析3分+算法实现9分）", "实现void printSteps(UsrInfo* lst)函数，从高到低打印用户行走步数的排行榜，包括姓名和步数。（12分=算法设计与分析3分+算法实现9分）", "实现void sendMsg(UsrInfo* lst, Relation* rel, Buffer* buf, int id1, int id2, char* msg)函数，如果id1和id2两个用户是好友，则把msg送入id2的接收信息缓冲区；如果id1和id2两个用户不是好友，则丢弃信息；若该缓冲区中积累的信息长度超过THRESHOLD=32个字符，则按接收先后顺序打印缓冲区中的信息，然后清空缓冲区。（16分=算法设计与分析4分+算法实现12分）", "实现int main()函数，通过调用addUsr、addFriend函数构建如图1所示的用户基本信息和好友关系；通过调用printSteps函数打印行走步数排行榜；通过调用sendMsg函数模拟信息发送过程。（8分）", "根据构建完成的好友关系，手动计算各用户间的最短距离和最短路径。（10分）"]], "Tag": "算法设计"}
{"Answer": "设open中有x,y两个点，全局最优路径中有x-&gt;y，等效证明x在y点前被取出：g(x)+h(x)&lt;=g(x)+h*(x)&lt;=g*(y)&lt;=g(y)&lt;=g(y)+h(y)", "Konwledge_Point": "最短路径", "Question": ["A*算法大牛进，高分。", ["1.如果h(n)经常都比从n移动到目标的实际代价小（或者相等），则A*保证能找到一条最短路径。h(n)越小，A*扩展的结点越多，运行就得越慢。", "\n2.如果h(n)有时比从n移动到目标的实际代价高，则A*不能保证找到一条最短路径，但它运行得更快。", "\n为什么？？？？？？？？？？？？？？？？？？？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff01;&amp;#xff01;点击该回答右侧的“采纳”按钮即可采纳&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["如何用迪杰斯特拉函数得到最短路径和距离", ["问题遇到的现象和发生背景", "\n", "利用迪杰斯特拉方法求最短路径", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "代码中有错误 但是没有报错", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "\n> #", "include", "<stdio.h>\n#", "include", "<math.h>\n#", "include", "<", "string", ".h>\n#", "include", " <stdlib.h>\n\n#define unreach ", "100", " ", "//没有途径的点之间的距离", "\n\n", "struct", " map {\n    ", "int", " edge", "[", "12", "]", "[", "12", "]", ";", "//储存距离", "\n    ", "int", " S", "[", "12", "]", ";", "//储存点的信息", "\n    ", "int", " edgenum;", "//边的个数", "\n}Map;\n\n", "//输入路径图的信息", "\nmap  ", "Creatmap(", "int", " ", "m", ")", " {\n    const ", "char", "* path = ", "\"C:\\\\Users\\\\tyl666\\\\题目5-最短路径规划\\\\路径文件.txt\"", ";\n    FILE* fp = NULL;\n    fopen", "_s(&", "fp", ", ", "\"path\"", ", ", "\"r\"", ")", ";\n\n    ", "int", " a, b, c;", "//点点边", "\n    ", "//初始化点点距", "\n    ", "for", " (", "int", " i = ", "0", ";i < ", "12", ";i++) {\n        ", "for", " (", "int", " j = ", "0", ";j < ", "12", ";j++) {\n            ", "if", " (i", " == ", "j) {\n                ", "Map", ".", "edge", "[", "i", "]", "[", "j", "]", " = ", "0", ";\n            }\n            ", "else", " {\n                ", "Map", ".", "edge", "[", "i", "]", "[", "j", "]", " = unreach;\n            }\n        }\n    }\n    ", "//从文件中读取点与点之间的距离", "\n    ", "for", " (", "int", " i = ", "0", ";i < ", "21", ";i++)\n    {\n        fscanf", "_s(", "fp", ", ", "\"%d,%d,%d\"", ", &", "a", ", &", "b", ", &", "c", ")", ";\n        ", "Map", ".", "edge", "[", "a", "]", "[", "b", "]", " = c;\n        ", "Map", ".", "edge", "[", "b", "]", "[", "a", "]", " = c;\n    }\n    fclose(fp);\n\n    return Map;\n}\n", "//迪杰斯特拉算法", "\nvoid ", "Dijkstra(", "map", " Map, ", "int", " ", "d", ", ", "int", " ", "m", ")", "//d设为起点", "\n{\n    ", "int", " i, j, n;\n    d = ", "1", ";\n    ", "//利用动态数组", "\n    ", "int", "* dist=", "new", " ", "int", "[", "12", "]", ";", "//储存当前最短路径的长度", "\n    ", "char", "* path=", "new", " ", "char", "[", "12", "]", ";", "//储存最短路径", "\n    ", "for", " (i = ", "0", ";i < ", "12", ";i++) {\n        dist", "[", "i", "]", " = ", "Map", ".", "edge", "[", "d", "]", "[", "i", "]", ";\n        path", "[", "i", "]", " = Map.S", "[", "d", "]", " + Map.S", "[", "i", "]", ";\n    }\n    ", "//开始遍历路径图", "\n    ", "for", " (n = ", "1", ";n < ", "12", ";n++) {\n        ", "for", " (i = ", "0", ", j = ", "0", ";i < ", "12", ";i++) {\n            ", "if", " (dist", "[", "i", "]", " != ", "0", "&&dist", "[", "i", "]", "<dist", "[", "j", "]", ") {\n                j = i;\n            }\n        }\n        printf(", "\"%d %d\"", ", dist", "[", "i", "]", ",path", "[", "j", "]", ");\n        ", "//逐步寻找到最短路径及其距离", "\n        ", "for", " (i = ", "0", ";i < ", "12", ";i++) {\n            ", "if", " (dist", "[", "i", "]", " > dist", "[", "j", "]", " + ", "Map", ".", "edge", "[", "j", "]", "[", "i", "]", ") {\n                dist", "[", "i", "]", " = dist", "[", "j", "]", " + ", "Map", ".", "edge", "[", "j", "]", "[", "i", "]", ";\n                path", "[", "i", "]", " = path", "[", "j", "]", " + Map.S", "[", "i", "]", ";\n            }\n        }\n        dist", "[", "j", "]", " = ", "0", ";\n    }\n}\n\n", "int", " main", "()", "\n{\n    ", "int", " a = ", "21", ";\n    ", "int", " m = ", "1", ";\n    Map = ", "Creatmap(", "a", ")", ";\n    ", "Dijkstra(Map, ", "m", ", ", "a", ")", ";\n\n    return ", "0", ";\n}\n\n", "\n", "运行结果及详细报错内容", "\n", "出现了debug警告", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "读取文件数据写入了地图数据，构造函数求最短路径", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”", "\n", "得到最短路径和距离"]], "Tag": "算法设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;i表示步数&amp;#xff0c;从a顶点出发到b顶点只需要1步&amp;#xff0c;故i&amp;#61;1。到其他顶点&amp;#xff0c;以此类推&amp;#xff1b;&lt;/li&gt;&lt;li&gt;从a到d有3种走法&amp;#xff0c;最短路径和是5&amp;#xff08;2&amp;#43;3&amp;#xff0c;即 a -&amp;gt; b -&amp;gt; d&amp;#xff09;&amp;#xff0c;其他两种走法是  a -&amp;gt; c -&amp;gt; d&amp;#xff0c; a -&amp;gt; b -&amp;gt; c -&amp;gt; d&amp;#xff1b;&lt;/li&gt;&lt;li&gt;∞表无穷大&amp;#xff0c;即从某个节点到某个顶点之间是不可达。&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "最短路径", "Question": ["迪杰斯特拉算法求最短路径", ["看不大懂以下这种迪杰斯特拉求最短路径的方法", "\n", "\n", "\n", "主要疑惑如下：", "1.答案中的i代表的是什么？", "2.为什么会有多个重复的结果出现，例如d行中有三个是完全一模一样的", "3.不是很能理解∞代表的是什么"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;最短路径不对&amp;#xff0c;路径最短不代表它是由最短的边组成的&lt;br /&gt;比如最短的路径是1,100&amp;#xff0c;第二短的路径是102条长度为1的路径组成&amp;#xff0c;很显然最短路径跟这题完全不是同一个问题&lt;br /&gt;而且求最短路径你需要验证每个路径&amp;#xff0c;很耗费时间&lt;br /&gt;这题其实最适合用贪心算法求&amp;#xff0c;反正每路过一个节点&amp;#xff0c;你都走最短的那条就对了&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["与无向图最短路径有关", ["问题", "：一个无向图有n个点，m条边，你现在在1号点，每条边有个对能力值的限制，要大于等于这个限制才能通过它。他们想知道他们至少要有多大的能力值，才能从1号点到n号点。", "\n", "输入", "：第一行两个正整数n,m。分别表示图的大小和边的数量。", "接下来m行，每行3个整数 u,v,l 。表示有一条u到v的边，至少要l能力值才能通过。地图保证1和n是连通的。", "\n", "数据规模", "：对于30%的数据： n<=m<=8", "对于100%的数据 , n<=m<=10^6,1<=u,v<=n,0<=l<=10^9", "\n", "输出描述", "：需要获得的最小的能力值，能够从1到n", "\n", "我的想法和出现的问题", "：我本来打算先求最短路径的，再找出最短路径上最长的一条边的值，但是它测试数据太大了，我邻接矩阵一开数组就爆栈了。有没有什么不爆数组的思路啊。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;D&lt;/p&gt;\n&lt;p&gt;最短路径算法&amp;#xff1a;一个是迪杰斯特拉算法&amp;#xff0c;求从某个源点到其余各顶点的最短路径&amp;#xff0c;求解过程按路径长度递增的次序产生的最短路径&amp;#xff0c;时间复杂度是O(n^2) ; 另一种算法是弗洛伊德算法&amp;#xff0c;求 每一对顶点之间的最短路径&amp;#xff0c;时间复杂度为O(n^3)。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["与费洛伊德算法中最短路径的时间复杂度相关的疑问", ["请教图片中的这个内容该怎么做呢，我能该如何去解决，与费洛伊德算法中最短路径的时间复杂度相关的疑问"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;超时了&amp;#xff0c;换个算法&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["洛谷P4779最短路径问题TLE", ["\n", "#include<bits/stdc++.h>", "using namespace std;", "int  a[10005][10005];", "int  d[10005],i,j;", "const int INF=1e9;", "int t;", "int read()", "{", "    int x=0,y=1;", "    char c;", "    while(c<'0'||c>'9'){if(c=='-')y=-1;c=getchar();}", "    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}", "    return x*y;", "}", "void dij(int n)//单源最短路径", "{", "    bool f[10005]={0};", "    f[1]=1;", "    int v;", "    for(i=1;i<n;i++)", "    {", "        int min=INF;", "        for(j=1;j<=n;j++)", "        {", "            if(!f[j]&&min>d[j])//找未标记中最小的", "            {", "                min=d[j];", "                v=j;", "            }", "        }", "        f[v]=1;//标记", "        for(j=v;j<=n;j++)", "        {", "            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度", "            {", "                d[j]=a[v][j]+d[v];", "            }", "        }", "    }", "}", "\n", "int main()", "{", "    int n,m,x,y,z;", "    n=read(),m=read(),t=read();", "    for(i=1;i<=m;i++)", "    {", "        x=read(),y=read(),z=read();", "        a[x][y]=z;", "    }", "    for(i=1;i<=n;i++)", "    {", "        d[i]=a[t][i];//路径长度初始化]]", "    }", "    dij(n);", "    for(i=1;i<=n;i++)", "    {", "        printf(\"%d\\n\",d[i]);", "    }", "    return 0;", "}", "爆TLE，请问这个程序哪里出了问题？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;直接bfs就行了&amp;#xff0c;毕竟询问次数较少&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["PTA 7-3 幸福小镇的故事! (最短路径直接用floyd会超时怎么办?)", ["7-3 幸福小镇的故事！（简单） (25 分)", "\n\n", "在一个很远很远的地方，有一个幸福小镇！", "\n\n", "幸福小镇的治安很不好，所以生活在镇上很不幸福！", "\n\n", "新来的保安队队长小Z决心改变这一切，第一步要解决的是任何两个小镇之间的距离问题！", "\n\n", "我们需要解决这个问题的简化版本：", "\n\n", "幸福小镇可以划分为N个小小镇，从1到N编号！这些小小镇由N-1条道路连通，我们把每条道路的长度简化为1！只要在每个小小镇增派人手，就可以让小镇的治安情况变得越来越好！（题目保证两个小镇之间的道路只有一条！）", "\n\n", "每次小Z会询问你两个小小镇的编号，请你计算出这两个小镇之间的最短路径长度！", "\n\n", "输入格式:", "\n\n", "第一行包含一个正整数（N<=1000），表示小小镇的个数！", "\n\n", "接下来N-1行，每行包含两个1到N之间的整数，表示这两个编号的小小镇之间有一条路！", "\n\n", "接下来一行包含一个整数q（q<=100)，表示询问数！", "\n\n", "接下来q行，每行包含两个小小镇的编号，请在一行中输出这两个小小镇的最短路径长度！", "\n\n", "输出格式:", "\n\n", "输出答案即可！", "\n\n", "输入样例:", "\n\n", "在这里给出一组输入。例如：", "\n\n", "\n", "10\n1 2\n2 3\n1 4\n4 5\n4 6\n3 7\n3 8\n1 9\n9 10\n5\n3 8\n9 3\n1 1\n1 7\n1 9", "\n\n", "输出样例:", "\n\n", "在这里给出相应的输出。例如：", "\n\n", "\n", "1\n3\n0\n3\n1"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/xs18952904/article/details/84670271", "Konwledge_Point": "最短路径", "Question": ["利用C语言的程序设计的技术，计算这个图中的最长最短路径的算法怎么实现", ["Problem Description", "\nThe graph diameter is the length of the \"longest shortest path\" between any two vertices of a graph. In other words, a graph's diameter is the longest path which must be traversed in order to travel from any vertex to another when paths which backtrack, detour, or loop are excluded from consideration.", "\nGiven an undirected graph, your mission is to count the number of diameters of it.", "\n\n", "Input", "\nThe input contains multiple test cases. ", "\nFor each test case, it contains n+1 lines. ", "\nLine 1: two integers m, n (2<= m <= 100, 1 <= n <= 4000) indicating that there are m vertices and n edges in the city. ", "\nLine 2~n+1: each contains three integers i, j, d (1 <= i, j <= m, 1 <= d <= 100), indicating that there is an edge of length d connecting vertex i and vertex j.", "\n\n", "Output", "\nOutput the value of the diameter and the number of diameters in a single line, separated by a single space.", "\n\n", "Sample Input", "\n4 5 ", "\n1 2 1 ", "\n2 3 1 ", "\n3 4 1 ", "\n1 4 1 ", "\n1 3 2 ", "\n\n", "Sample Output", "\n2 5"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;br /&gt;using namespace std;&lt;br /&gt;char a[1005],b[1005],e,f;&lt;br /&gt;int n,d[27][27],s&amp;#61;0;&lt;br /&gt;int main(){&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cin&amp;gt;&amp;gt;n;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        cin&amp;gt;&amp;gt;e&amp;gt;&amp;gt;f;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        d[e-&amp;#39;a&amp;#39;][f-&amp;#39;a&amp;#39;]&amp;#61;d[f-&amp;#39;a&amp;#39;][e-&amp;#39;a&amp;#39;]&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int k&amp;#61;0;k&amp;lt;27;k&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        for(int i&amp;#61;0;i&amp;lt;27;i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            for(int j&amp;#61;0;j&amp;lt;27;j&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                if(d[i][k]!&amp;#61;0&amp;amp;&amp;amp;d[k][j]!&amp;#61;0&amp;amp;&amp;amp;i!&amp;#61;j){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                    if(d[i][j]&amp;#61;&amp;#61;0) d[i][j]&amp;#61;d[i][k]&amp;#43;d[k][j];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                    else d[i][j]&amp;#61;min(d[i][j],d[i][k]&amp;#43;d[k][j]);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;0;i&amp;lt;strlen(a);i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        s&amp;#43;&amp;#61;d[a[i]-&amp;#39;a&amp;#39;][b[i]-&amp;#39;a&amp;#39;];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cout&amp;lt;&amp;lt;s;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    return 0;&lt;/span&gt;&lt;br /&gt;} &lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["弗洛伊德算法求多源最短路径", ["\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该回答引用ChatGPT &lt;/p&gt;\n&lt;p&gt;1、Dijkstra算法可以用于解决最短路径问题。假设城市A为源点&amp;#xff0c;城市B为终点&amp;#xff0c;可以先将所有城市的距离初始化为无穷大&amp;#xff0c;将城市A到其他城市的距离更新为实际距离&amp;#xff0c;然后选取距离A最近的城市&amp;#xff0c;将它到其他城市的距离与A到其他城市的距离进行比较并更新&amp;#xff0c;直到所有城市的距离都被更新过。最终&amp;#xff0c;从A到B的最短路径即为路径上所有边的距离之和。&lt;/p&gt;\n&lt;p&gt;2、可以使用广度优先搜索算法&amp;#xff08;BFS&amp;#xff09;解决转车次数最少的问题。假设城市A为起点&amp;#xff0c;城市B为终点&amp;#xff0c;将A加入队列&amp;#xff0c;从队列中取出A&amp;#xff0c;遍历A可直达的城市并将其加入队列&amp;#xff0c;标记A为已访问过。接着从队列中取出下一个城市&amp;#xff0c;重复上述过程直到取出B或者队列为空。在遍历时&amp;#xff0c;使用一个数组记录下每个城市到起点的最短距离&amp;#xff0c;每当遍历到一个城市时&amp;#xff0c;如果到达这个城市的路径比之前记录的路径短&amp;#xff0c;就更新这个城市的最短路径。最终&amp;#xff0c;到达B的路径上的中转次数即为B的最短路径上的城市个数减1。&lt;/p&gt;\n&lt;p&gt;3、可以将1和2中的方法结合起来。先按照Dijkstra算法计算出从A到每个城市的最短路径&amp;#xff0c;然后使用BFS算法&amp;#xff0c;从A出发&amp;#xff0c;遍历所有可达城市&amp;#xff0c;更新到这些城市的最短路径和中转次数&amp;#xff0c;直到遍历到B。如果遍历到的城市到A的最短路径加上这个城市到B的最短路径等于A到B的最短路径&amp;#xff0c;说明找到了一条最短路径上的中转点。在更新最短路径和中转次数时&amp;#xff0c;需要考虑到中转次数相同时的比较&amp;#xff0c;可以使用一个优先队列&amp;#xff08;最小堆&amp;#xff09;存储城市信息&amp;#xff0c;根据综合花费&amp;#xff08;最短路径&amp;#43;中转次数&amp;#xff09;的大小来决定优先级。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["数据结构（最短路径的应用）", ["功能：现有10个城市之间的交通信息，若有火车，则提供两个城市之间火车票价格。", "（1）有旅客Ａ，准备从城市A出发到城市B，他希望总想花费最少。试设计一种方案。", "（2）有旅客Ｂ，准备从城市A出发到城市B，他想转车次数最少。试设计一种方案。", "( 3 ) 有旅客Ｂ，准备从城市A出发到城市B，他希望总想花费最少的情况下尽量减少中转次数。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;邻接表&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;deque&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a,b,n1,m1;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;node&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w;\n};\nvector&amp;lt;node&amp;gt; e[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,m,vis[&lt;span class=\"hljs-number\"&gt;100001&lt;/span&gt;],mapa[&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;],ans&amp;#61;&lt;span class=\"hljs-number\"&gt;1000000001&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;gt;&amp;#61;ans)&lt;span class=\"hljs-comment\"&gt;//小剪枝 &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;n)\n    {\n        ans&amp;#61;&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(ans,dis);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    node tt; \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;e[x].&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;();i&amp;#43;&amp;#43;)\n    {\n        tt&amp;#61;e[x][i];\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(vis[tt.v]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            vis[tt.v]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(tt.v,dis&amp;#43;tt.w);\n            vis[tt.v]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    } \n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    node t;\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;m1;\n    &lt;span class=\"hljs-comment\"&gt;//memset(mapa,0x3f,sizeof(mapa));//初始化&lt;/span&gt;\n     \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;m;j&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n        t.v&amp;#61;b;\n        t.w&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        e[a].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(t);\n        t.v&amp;#61;a;\n        t.w&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        e[b].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(t);\n       \n    }\n    vis[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;邻接矩阵&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,m,vis[&lt;span class=\"hljs-number\"&gt;100001&lt;/span&gt;],mapa[&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;],ans&amp;#61;&lt;span class=\"hljs-number\"&gt;1000000001&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;gt;ans)&lt;span class=\"hljs-comment\"&gt;//小剪枝 &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;n)\n    {\n        ans&amp;#61;&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(ans,dis);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//不一定向前走&amp;#xff0c;可能绕一下更近 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(mapa[x][i]!&amp;#61;&lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;&amp;amp;&amp;amp;vis[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) \n    {\n        vis[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(i,dis&amp;#43;mapa[x][i]);\n        vis[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n     } \n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a,b,n1,m1;\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;m1;\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(mapa,&lt;span class=\"hljs-number\"&gt;0x3f&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(mapa));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;m;j&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n        mapa[b][a]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//保证单向 &lt;/span&gt;\n        mapa[a][b]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    vis[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;链式前向星&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;deque&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;edge&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; nxt;\n}e[&lt;span class=\"hljs-number\"&gt;300&lt;/span&gt;]; \n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; h[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;addedge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v)&lt;/span&gt;\n&lt;/span&gt;{\n    cnt&amp;#43;&amp;#43;;\n    e[cnt].to&amp;#61;v;\n    e[cnt].nxt&amp;#61;h[u];\n    h[u]&amp;#61;cnt;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,m,vis[&lt;span class=\"hljs-number\"&gt;100001&lt;/span&gt;],mapa[&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;],ans&amp;#61;&lt;span class=\"hljs-number\"&gt;1000000001&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;gt;&amp;#61;ans)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;n)\n    {\n        ans&amp;#61;&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(ans,dis);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;h[x];i&amp;gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;#61;e[i].nxt)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to&amp;#61;e[i].to;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(vis[to]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            vis[to]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(to,dis&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            vis[to]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n1,m1; \n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;m1;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,a,b,c;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;m;j&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n        &lt;span class=\"hljs-built_in\"&gt;addedge&lt;/span&gt;(a,b);\n        &lt;span class=\"hljs-built_in\"&gt;addedge&lt;/span&gt;(b,a);\n    }\n    vis[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["最小换乘，求最短路径的问题", ["设某城市有n个车站，并有m条公交线路连接这些车站。设这些公交", "车都是单向的，这n个车站被顺序编号为0-n-l。本程序，输入该城市的公交线", "路数、车站个数、以及各公交线路上的各站编号。", "要求:", "\n", "（1求从站0出发乘公交车至其他车站的最少换车次数，并输出所经过的站点序", "列;", "(2利用输入信息构建一张有向图，分别用邻接矩阵和邻接表表示，并输出邻接", "矩阵和邻接表信息;", "\n", "(3从站0出发，对公交线路图进行遍历。", "\n", "收起全部 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;i&amp;#61;1, 2, 3, 4, 5, 6&lt;/code&gt;表示第几次迭代&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["数据结构，最短路径问题求解？", ["这个表里的i时什么意思？那个i=1 2 3 4 5 6，这个i是什么意思？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_35710556/article/details/79583229\"&gt;https://blog.csdn.net/qq_35710556/article/details/79583229&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;五种最短路径算法&amp;#xff0c;自己研究一下&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["C++求给出图的最短路径问题", ["\n\n", " "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你理解的没错&amp;#xff0c;但是我觉得你可能想复杂了&amp;#xff0c;我感觉这一段就是解释和证明数组 distTo[v] 保存的是从 s 到 v 的最短距离&amp;#xff0c; v 和 w 都不是定值&amp;#xff0c;disTo[w]&amp;lt;&amp;#61;distTo[v] &amp;#43; e.weight() 的意思就是指到节点 w 的最短距离不可能比经由其他节点去往 w 的距离更长。&lt;br /&gt;附上英文原版帮助理解&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/968135848086140.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["算法第4版  4.4.3 最优路径算法的理论基础 最短路径的最优条件描述是不是不太准确？", ["算法第4版  4.4.3 最优路径算法的理论基础 最短路径的最优条件描述是不是不太准确？", "\n", "\n", "当且仅当对于", "从v到w的任意一条边e", "，这些值都是满足", "disTo[w]<=distTo[v] + e.weight()", "时（换句话说，就是不存在有效边时），它们是最短路径。", "\n", "刚开始我是这么理解w、v和e的", "\n", "\n", "后来才明白应该是这样", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Plenty of reading/algorithms:\n&lt;a href=\"http://en.wikipedia.org/wiki/Shortest_path_problem\" rel=\"nofollow noreferrer\"&gt;Shortest path problem&lt;/a&gt;. You effectively just have every edge (\"link\", as you called it) with an equal weight.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "最短路径", "Question": ["线性阵列，节点随机链接到阵列中的其他节点，最短路径", ["\n\n", "INFO:\nI have an Array of 100 nodes, [ 0 .. 99 ].  Each node can have an arbitrary number of linked nodes:", "\n\n", "eg1, 0 links to 5, 10, 15, 20.\neg2, 1 links to 30, 40, 50.\neg3, etc..", "\n\n", "All 100 nodes have at least one linked node, nodes do not know who links to them.", "\n\n", "QUESTION:\nHow can I find the shortest link-path if provided with START and END.", "\n\n", "eg. START=5, END=80, Link Path (example) : [5]->10->24->36->[80]?", "\n\n", "I'm using Pascal and/or PHP, but understanding how is what I'm looking for [code helps too].", "\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Dijkstra should pass, I just make a submission using JAVA, and it took less than a second to complete each task.&lt;/p&gt;\n\n&lt;p&gt;As I have mentioned, each value in the matrix can go up to 10^9, your solution can encounter a number overflow problem, which can effect the running time.&lt;/p&gt;\n\n&lt;p&gt;My code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;!-- language:java --&amp;gt;\n\nstatic int[]X = {0,1,0,-1};\nstatic int[]Y = {1,0,-1,0};\npublic static void main(String[] args) throws FileNotFoundException {\n    // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n    // \"output.txt\")));\n    PrintWriter out = new PrintWriter(System.out);\n    Scanner in = new Scanner();        \n    int n = in.nextInt();\n    long[][]map = new long[n][n];\n    for(int i = 0; i &amp;lt; n; i++){\n        for(int j = 0; j &amp;lt; n; j++){\n            map[i][j] = in.nextLong();\n        }\n    }\n    PriorityQueue&amp;lt;Pos&amp;gt; q= new PriorityQueue();\n    long[][]dist = new long[n][n];\n    for(long[]a : dist){\n        Arrays.fill(a,Long.MAX_VALUE);\n    }\n    q.add(new Pos(0,0,map[0][0]));\n    dist[0][0] = map[0][0];\n    while(!q.isEmpty()){\n        Pos p = q.poll();\n        if(dist[p.x][p.y] == p.cost){\n            for(int i = 0; i &amp;lt; 4; i++){\n                int x = p.x + X[i];\n                int y = p.y + Y[i];\n                if(x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; n &amp;amp;&amp;amp; y &amp;lt; n &amp;amp;&amp;amp; dist[x][y] &amp;gt; dist[p.x][p.y] + map[x][y] ){\n                    dist[x][y] = dist[p.x][p.y] + map[x][y];\n                    q.add(new Pos(x,y,dist[x][y]));\n                }\n            }\n        }\n    }\n    out.println(dist[n - 1][n - 1]);\n    out.close();\n}\n\nstatic class Pos implements Comparable&amp;lt;Pos&amp;gt;{\n    int x, y;\n    long cost;\n    public Pos(int x, int y, long cost) {\n        super();\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n    }\n    @Override\n    public int compareTo(Pos o) {\n        // TODO Auto-generated method stub\n        return Long.compare(cost, o.cost );\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;:&lt;/p&gt;\n\n&lt;p&gt;I think your Dijkstra implementation is not correct:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for frontier.Len() &amp;gt; 0 {\n    element := heap.Pop(&amp;amp;frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    //You didn't check for visited vertex here!\n    visited[vertex] = true\n    neighbors := graph[vertex]\n    for vertex_new, cost_new := range(neighbors){\n        if !visited[vertex_new]{//You can add same vertex multiple times here!\n            if vertex_new == end{\n                return cost + cost_new\n            }\n            heap.Push(&amp;amp;frontier, &amp;amp;Item{\n                value: vertex_new,\n                priority: cost + cost_new,\n            })\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In your implementation, you only update &lt;code&gt;visited&lt;/code&gt; when the vertex pop out of the heap, thus, one vertex can be added and processed multiple time, so, it will significantly increase your time complexity.&lt;/p&gt;\n\n&lt;p&gt;To fix&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for frontier.Len() &amp;gt; 0 {\n    element := heap.Pop(&amp;amp;frontier).(*Item)\n    vertex, cost := element.value, element.priority\n    if !visited[vertex]{\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                   return cost + cost_new\n                }\n                heap.Push(&amp;amp;frontier, &amp;amp;Item{\n                   value: vertex_new,\n                   priority: cost + cost_new,\n                })\n            }\n        }   \n    }\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "最短路径", "Question": ["在矩阵中找到最短路径总和。  Dijkstra是否不适用于这种情况？", ["\n\n", "I am trying to solve ", "the following problem from project euler", " (please take a look at description and the example in the link, but here is the short explanation).", "\n\n", "\n  ", "in the matrix, find the  minimal path sum from the top left to the bottom right, by moving left, right, up, and down", "\n", "\n\n", "Right after I looked at the problem, the obvious solution which came to mind is to create a graph from the matrix and then use ", "Dijkstra", " to find the shortest path.", "\n\n", "To construct a graph from a ", "N*M", " matrix, for every ", "(i, j)", " element I create a vertex ", "i * N + j", " and connect it to any other vertex (to which it is possible to connect with UP, RIGHT, DOWN, LEFT) and the edge will be the value of the element I am connecting to in the matrix. After that I create 2 other vertices ", "-1", " connected to vertex ", "0", " and ", "-2", " connected to ", "N*M - 1", " which will be my start and end vertices (both connection have 0 cost).", "\n\n", "After this I am doing Dijkstra to find shortest path cost from ", "-1", " to ", "-2", ". My Dijkstra implementation uses priority queue and looks this way:", "\n\n", "func dijkstraCost(graph map[int]map[int]int, start, end int) int{\n    if start == end{\n        return 0\n    }\n    frontier := make(PriorityQueue, 1)\n    frontier[0] = &Item{value: start, priority: 0, index: 0}\n    visited := map[int]bool{}\n    heap.Init(&frontier)\n\n    for frontier.Len() > 0 {\n        element := heap.Pop(&frontier).(*Item)\n        vertex, cost := element.value, element.priority\n        visited[vertex] = true\n        neighbors := graph[vertex]\n        for vertex_new, cost_new := range(neighbors){\n            if !visited[vertex_new]{\n                if vertex_new == end{\n                    return cost + cost_new\n                }\n                heap.Push(&frontier, &Item{\n                    value: vertex_new,\n                    priority: cost + cost_new,\n                })\n            }\n        }\n    }\n    return -1\n}\n", "\n\n", "where Priority Queue implementation is taken from heap container (example PriorityQueue) with one minor modification:", "\n\n", "func (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority > pq[j].priority // changed to <\n}\n", "\n\n", "The graph that I am providing to the function looks like:", "\n\n", "map[13:map[8:965 18:121 12:746 14:111] 16:map[11:803 21:732 15:537 17:497] 3:map[8:965 2:234 4:18] 4:map[9:150 3:103] 22:map[17:497 21:732 23:37] -1:map[0:131] 17:map[16:699 18:121 12:746 22:524] 1:map[6:96 0:131 2:234] 9:map[4:18 14:111 8:965] 11:map[6:96 16:699 10:630 12:746] 19:map[14:111 24:331 18:121] 24:map[23:37 -2:0 19:956] 2:map[3:103 7:342 1:673] 15:map[10:630 20:805 16:699] 18:map[13:422 23:37 17:497 19:956] 10:map[5:201 15:537 11:803] 14:map[19:956 13:422 9:150] 0:map[5:201 1:673] 6:map[5:201 7:342 1:673 11:803] 8:map[9:150 3:103 13:422 7:342] -2:map[] 12:map[7:342 17:497 11:803 13:422] 20:map[15:537 21:732] 21:map[16:699 20:805 22:524] 5:map[0:131 10:630 6:96] 23:map[18:121 22:524 24:331] 7:map[2:234 12:746 6:96 8:965]]\n", "\n\n", "\n", "This works correctly but the problem is that it is considered inefficient (judging by ", "Hackerrank version of the problem", "). It should run find the value of the best solution for ", "700x700", " matrix in less than 4 seconds, whereas my solution takes 10 seconds.", "\n\n", "I thought that I am doing something wrong in go, so I reimplemented the same solution in python (where it took approximately 70 seconds for 700x700 matrix)", "\n\n", "\n", "My question is:", " Am I using the right approach to find the best solution in a matrix. If so what am I doing wrong with my implementation?", "\n\n", "P.S. I have full go and python solution, just thought that even without them the question is too long.", "\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ryn 安装和python代码都是python2版本的&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["看到您一篇关于ryu最短路径转发的文章，想咨询您一点问题", ["在Ubuntu执行自定义的ryu控制器脚本时出现的问题", "wjc@wjc-virtual-machine:~/ryu/ryu/app$ ryu-manager example_shortestForwarding.py --observe-links", "Traceback (most recent call last):", "  File \"/home/wjc/.local/bin/ryu-manager\", line 5, in ", "    from ryu.cmd.manager import main", "  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/cmd/manager.py\", line 33, in ", "    from ryu.app import wsgi", "  File \"/home/wjc/.local/lib/python2.7/site-packages/ryu/app/wsgi.py\", line 23, in ", "    from tinyrpc.server import RPCServer", "  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/", "init", ".py\", line 4, in ", "    from .protocols import *", "  File \"/home/wjc/.local/lib/python2.7/site-packages/tinyrpc/protocols/", "init", ".py\", line 15", "    def ", "init", "(self) -> None:", "                       ^", "SyntaxError: invalid syntax", "\n", "不知道这个问题应该如何解决"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/xiaohang3414/article/details/73321625", "Konwledge_Point": "最短路径", "Question": ["最短路径搜索，除了暴搜以外，采用C语言的还有更优化的办法怎么做呢？", ["Problem Description", "\nThe discovery of anti-gravitations technology changed the world. The invention of anti-gravitation shoes (Grav-shoes) enables people to fly in the sky freely. This led to the rise of a new sky sport: ``Flying Circus\".", "\n\n", "Utilizing Grav-shoes and personal flying suits, competitors battle it out in a special field, where they compete scoring obtain m points within a certain time limit. The field is a square with edge length 300 meters. Moreover, there are four buoys floating at each corner of the square. Four buoys are numbered as 1,2,3,4 in clockwise order.", "\n\n", "Two players start at buoy #1. When game begin, they will try to touch four floating buoys in clockwise order.", "\n(Since buoy #1 is the start point, the first buoy they need to touch will be buoy #2, and after that, they need to touch buoy #3,#4,#1 in order) Note that they could fly freely in the field, even fly inside the square field.", "\n\n", "Under two situations the player could score one point.", "\n\n", "⋅1. If you touch a buoy before your opponent, you will get one point. For example if your opponent touch the buoy #2 before you after start, he will score one point. So when you touch the buoy #2, you won't get any point. Meanwhile, you cannot touch buoy #3 or any other buoys before touching the buoy #2.", "\n\n", "⋅2. Ignoring the buoys and relying on dogfighting to get point. If you and your opponent meet in the same position, you can try to fight with your opponent to score one point. For the proposal of game balance, two players are not allowed to fight before buoy #2 is touched by anybody.", "\n\n", "There are three types of players.", "\n\n", "Speeder: As a player specializing in high speed movement, he/she tries to avoid dogfighting while attempting to gain points by touching buoys.", "\nFighter: As a player specializing in dogfighting, he/she always tries to fight with the opponent to score points. Since a fighter is slower than a speeder, it's difficult for him/her to score points by touching buoys when the opponent is a speeder.", "\nAll-Rounder: A balanced player between Fighter and Speeder.", "\n\n", "There will be a training match between Asuka (All-Rounder) and Shion (Speeder).", "\nSince the match is only a training match, the rules are simplified: the game will end after the buoy #1 is touched by anybody. Shion is a speed lover, and his strategy is very simple: touch buoy #2,#3,#4,#1 along the shortest path.", "\n\n", "Asuka is good at dogfighting, so she will always score one point by dogfighting with Shion, and the opponent will be stunned for T seconds after dogfighting. Since Asuka is slower than Shion, she decides to fight with Shion for only one time during the match. It is also assumed that if Asuka and Shion touch the buoy in the same time, the point will be given to Asuka and Asuka could also fight with Shion at the buoy. We assume that in such scenario, the dogfighting must happen after the buoy is touched by Asuka or Shion.", "\n\n", "The speed of Asuka is V1 m/s. The speed of Shion is V2 m/s. Is there any possibility for Asuka to win the match (to have higher score)?", "\n\n", "Input", "\nThe first line contains an integer t (0<t≤1000), followed by t lines.", "\nEach line contains three double T, V1 and V2 (0≤V1≤V2≤2000,0≤T≤2000) with no more than two decimal places, stands for one case.", "\n\n", "Output", "\nIf there exist any strategy for Asuka to win the match, output ", "Yes\", otherwise, output", "No\".", "\n\n", "Sample Input", "\n2", "\n1 10 13", "\n100 10 13", "\n\n", "Sample Output", "\nCase #1: No", "\nCase #2: Yes"]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/u012969412/article/details/44818029", "Konwledge_Point": "最短路径", "Question": ["希望大神解答一下，这道题用bfs+优先队列为什么不对，只能用最短路径来写", ["Bessie and the rest of Farmer John's cows are taking a trip this winter to go skiing. One day Bessie finds herself at the top left corner of an R (1 <= R <= 100) by C (1 <= C <= 100) grid of elevations E (-25 <= E <= 25). In order to join FJ and the other cows at a discow party, she must get down to the bottom right corner as quickly as she can by travelling only north, south, east, and west.\n\nBessie starts out travelling at a initial speed V (1 <= V <= 1,000,000). She has discovered a remarkable relationship between her speed and her elevation change. When Bessie moves from a location of height A to an adjacent location of eight B, her speed is multiplied by the number 2^(A-B). The time it takes Bessie to travel from a location to an adjacent location is the reciprocal of her speed when she is at the first location.\n\nFind the both smallest amount of time it will take Bessie to join her cow friends.\n", "\n\n", "Input", "\n    * Line 1: Three space-separated integers: V, R, and C, which respectively represent Bessie's initial velocity and the number of rows and columns in the grid.", "\n\n", "* Lines 2..R+1: C integers representing the elevation E of the corresponding location on the grid. \n", "\n\n", "Output", "\n    A single number value, printed to two exactly decimal places: the minimum amount of time that Bessie can take to reach the bottom right corner of the grid. ", "\nSample Input", "\n\n", "1 3 3\n1 5 3\n6 3 5\n2 4 3\n", "\n\n", "Sample Output", "\n\n", "29.00\n", "\n\n", "Hint", "\n    Bessie's best route is:", "\n    Start at 1,1 time 0 speed 1", "\n    East to 1,2 time 1 speed 1/16", "\n    South to 2,2 time 17 speed 1/4", "\n    South to 3,2 time 21 speed 1/8", "\n    East to 3,3 time 29 speed 1/4 "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这种问题不应该用Dijkstra这种太理论化的算法去解决问题&amp;#xff0c;因为专业的识别cad图的算法&amp;#xff0c;不是那么轻易就能写好。&lt;br /&gt;建议&amp;#xff1a;&lt;br /&gt;直接读取cad图&amp;#xff0c;自己写识别算法&amp;#xff0c;一张建筑平面图&amp;#xff0c;适当处理下&amp;#xff0c;二值化后就只剩墙壁的黑色部分&amp;#xff0c;用程序遍历一次所有的路线&amp;#xff0c;就能找到最佳路线了&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["给出一张建筑平面图，如何将其转换成路径距离信息的无向图", ["做建筑疏散的实验，考虑用Dijkstra找无向图的最短路径、疏散出口。目前无向图需要手画。", "\n", "\n", "\n", "正在思考如何根据一张建筑平面图，如cad图，去识别这张图，并自动生成他的路径距离信息的图。", "\n", "其中无向图的每个节点可以代表建筑的路口，权重代表路径的距离。"]], "Tag": "算法设计"}
{"Answer": "如果是写代码的话，邻接矩阵肯定比邻接表好写，毕竟是数组实现；\r\n就时间复杂度上而言对于稀疏图用邻接表比较好，对于稠密图用邻接矩阵比较好", "Konwledge_Point": "最短路径", "Question": ["图的拓扑参数 点介数\\点核数\\度分布", ["    对于一个图来说,度分布是比较好做的,列出所有点对<a,b>计算每一点出现的次数,就是度数.\n    点介数是通过该点的最短路径的条数.\n    点核数定义较为复杂.\n    那么对于程序实现来说,狄克斯特拉算法只能算出最短路径并不能得到每一点的信息?\n下面问题来了\n        度分布的计算究竟是用邻接矩阵方便还是邻接表方便呢?\n        介数的计算思想究竟是什么呢?\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;由于题太长导致ChatGPT试了好几次才全部答完&amp;#xff0c;可能答案不正确&lt;/strong&gt;&lt;br /&gt;1、利用随机数原理&amp;#xff0c;随机产生一个二维数组A&amp;#xff08;30*30&amp;#xff09;&amp;#xff0c;其中对角线元素为零&amp;#xff0c;剩余元素中的50%是∞&amp;#xff0c;其余元素的值为大于0的随机数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;srand&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)); &lt;span class=\"hljs-comment\"&gt;// 设置随机数种子&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N];       &lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; j)\n            { &lt;span class=\"hljs-comment\"&gt;// 对角线元素为零&lt;/span&gt;\n                A[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;rand&lt;/span&gt;() % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            { &lt;span class=\"hljs-comment\"&gt;// 50%的概率为∞&lt;/span&gt;\n                A[i][j] &amp;#61; INF;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            { &lt;span class=\"hljs-comment\"&gt;// 剩余元素的值为大于0的随机数&lt;/span&gt;\n                A[i][j] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;rand&lt;/span&gt;() % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 输出二维数组A&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; A[i][j] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        }\n        cout &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、将上述二维数组作为图的邻接矩阵&amp;#xff0c;以该数组作为输入&amp;#xff0c;创建一个图形结构&amp;#xff0c;该图使用邻接表作为存储结构。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;vector&amp;gt;\n\nusing namespace std;\n\nconst &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\nconst &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Edge\n{                    &lt;span class=\"hljs-comment\"&gt;// 定义边的结构体&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;, weight; &lt;span class=\"hljs-comment\"&gt;// to表示边的终点&amp;#xff0c;weight表示边的权值&lt;/span&gt;\n};\n\nvector&amp;lt;Edge&amp;gt; adj&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n\nvoid add&lt;span class=\"hljs-constructor\"&gt;Edge(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;u&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;)&lt;/span&gt;\n{                              &lt;span class=\"hljs-comment\"&gt;// 添加边的函数&lt;/span&gt;\n    adj&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;u&lt;/span&gt;]&lt;/span&gt;.push&lt;span class=\"hljs-constructor\"&gt;_back({&lt;!-- --&gt;&lt;span class=\"hljs-params\"&gt;v&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;})&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 将边(u, v)加入邻接表&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; A&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt; &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (A&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; !&amp;#61; INF)\n            {                            &lt;span class=\"hljs-comment\"&gt;// 如果A[i][j]不是∞&amp;#xff0c;说明存在边(i, j)&lt;/span&gt;\n                add&lt;span class=\"hljs-constructor\"&gt;Edge(&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;j&lt;/span&gt;, A[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;][&lt;span class=\"hljs-params\"&gt;j&lt;/span&gt;])&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 将边(i, j)加入邻接表&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n                { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n                    {\n                        cout &amp;lt;&amp;lt; A&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 输出A[i][j]&lt;/span&gt;\n                    }\n                    cout &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出换行符&lt;/span&gt;\n                }\n            }\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、利用DFS或者BFS算法遍历该图&amp;#xff0c;找到图中权值最小的边。首先是DFS。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Edge&lt;/span&gt;\n{                    &lt;span class=\"hljs-comment\"&gt;// 定义边的结构体&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to, weight; &lt;span class=\"hljs-comment\"&gt;// to表示边的终点&amp;#xff0c;weight表示边的权值&lt;/span&gt;\n};\n\nvector&amp;lt;Edge&amp;gt; adj[N]; &lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;addEdge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w)&lt;/span&gt;\n&lt;/span&gt;{                              &lt;span class=\"hljs-comment\"&gt;// 添加边的函数&lt;/span&gt;\n    adj[u].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;({v, w}); &lt;span class=\"hljs-comment\"&gt;// 将边(u, v)加入邻接表&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;dfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, vector&amp;lt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt;&amp;gt; &amp;amp;visited, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;min_weight)&lt;/span&gt;\n&lt;/span&gt;{                       &lt;span class=\"hljs-comment\"&gt;// 定义DFS遍历的函数&lt;/span&gt;\n    visited[u] &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 标记顶点u为已访问&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Edge &amp;amp;e : adj[u])\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历顶点u的所有出边&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; e.to;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w &amp;#61; e.weight;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[v])\n        {                                     &lt;span class=\"hljs-comment\"&gt;// 如果顶点v未被访问过&lt;/span&gt;\n            min_weight &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_weight, w); &lt;span class=\"hljs-comment\"&gt;// 更新最小边权值&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(v, visited, min_weight);     &lt;span class=\"hljs-comment\"&gt;// 递归调用DFS遍历&lt;/span&gt;\n        }\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (A[i][j] !&amp;#61; INF)\n            {                            &lt;span class=\"hljs-comment\"&gt;// 如果A[i][j]不是∞&amp;#xff0c;说明存在边(i, j)&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;addEdge&lt;/span&gt;(i, j, A[i][j]); &lt;span class=\"hljs-comment\"&gt;// 将边(i, j)加入邻接表&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min_weight &amp;#61; INF;                              &lt;span class=\"hljs-comment\"&gt;// 定义最小边权值初始值为∞&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;vector&amp;lt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-title\"&gt;visited&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(N, &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;                      &lt;span class=\"hljs-comment\"&gt;// 定义访问数组&amp;#xff0c;初始值全部为false&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, visited, min_weight);                      &lt;span class=\"hljs-comment\"&gt;// 从顶点0开始遍历图&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Minimum weight: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; min_weight &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出最小边权值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其次是BFS&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Edge&lt;/span&gt;\n{                    &lt;span class=\"hljs-comment\"&gt;// 定义边的结构体&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; to, weight; &lt;span class=\"hljs-comment\"&gt;// to表示边的终点&amp;#xff0c;weight表示边的权值&lt;/span&gt;\n};\n\nvector&amp;lt;Edge&amp;gt; adj[N]; &lt;span class=\"hljs-comment\"&gt;// 定义邻接表&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;addEdge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w)&lt;/span&gt;\n&lt;/span&gt;{                              &lt;span class=\"hljs-comment\"&gt;// 添加边的函数&lt;/span&gt;\n    adj[u].&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;({v, w}); &lt;span class=\"hljs-comment\"&gt;// 将边(u, v)加入邻接表&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;bfs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; u, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;min_weight)&lt;/span&gt;\n&lt;/span&gt;{                                    &lt;span class=\"hljs-comment\"&gt;// 定义BFS遍历的函数&lt;/span&gt;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; q;                    &lt;span class=\"hljs-comment\"&gt;// 定义队列&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;vector&amp;lt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-title\"&gt;visited&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(N, &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义访问数组&amp;#xff0c;初始值全部为false&lt;/span&gt;\n    visited[u] &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;                &lt;span class=\"hljs-comment\"&gt;// 标记顶点u为已访问&lt;/span&gt;\n    q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(u);                        &lt;span class=\"hljs-comment\"&gt;// 将顶点u加入队列&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!q.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;())\n    {                       &lt;span class=\"hljs-comment\"&gt;// 当队列不为空时&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;(); &lt;span class=\"hljs-comment\"&gt;// 取出队首元素&lt;/span&gt;\n        q.&lt;span class=\"hljs-built_in\"&gt;pop&lt;/span&gt;();           &lt;span class=\"hljs-comment\"&gt;// 弹出队首元素&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Edge &amp;amp;e : adj[x])\n        { &lt;span class=\"hljs-comment\"&gt;// 遍历顶点x的所有出边&lt;/span&gt;\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v &amp;#61; e.to;\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; w &amp;#61; e.weight;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!visited[v])\n            {                                     &lt;span class=\"hljs-comment\"&gt;// 如果顶点v未被访问过&lt;/span&gt;\n                visited[v] &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;                 &lt;span class=\"hljs-comment\"&gt;// 标记顶点v为已访问&lt;/span&gt;\n                min_weight &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_weight, w); &lt;span class=\"hljs-comment\"&gt;// 更新最小边权值&lt;/span&gt;\n                q.&lt;span class=\"hljs-built_in\"&gt;push&lt;/span&gt;(v);                         &lt;span class=\"hljs-comment\"&gt;// 将顶点v加入队列&lt;/span&gt;\n            }\n        }\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历二维数组A&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (A[i][j] !&amp;#61; INF)\n            {                            &lt;span class=\"hljs-comment\"&gt;// 如果A[i][j]不是∞&amp;#xff0c;说明存在边(i, j)&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;addEdge&lt;/span&gt;(i, j, A[i][j]); &lt;span class=\"hljs-comment\"&gt;// 将边(i, j)加入邻接表&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min_weight &amp;#61; INF;                              &lt;span class=\"hljs-comment\"&gt;// 定义最小边权值初始值为∞&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;bfs&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, min_weight);                                  &lt;span class=\"hljs-comment\"&gt;// 从顶点0开始遍历图&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Minimum weight: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; min_weight &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出最小边权值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;4、设计一个基于Floyd的最短路径算法&amp;#xff0c;计算所有顶点之间的最短路径。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;// 定义数组大小为30*30&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; INF &amp;#61; &lt;span class=\"hljs-number\"&gt;0x3f3f3f3f&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 定义∞的值&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A[N][N] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 定义二维数组A&amp;#xff08;邻接矩阵&amp;#xff09;&lt;/span&gt;\n                   {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, INF, INF, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, INF, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, INF, INF},\n                   {INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, INF},\n                   {INF, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, INF, INF, INF},\n                   {INF, INF, INF, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n                   {INF, INF, INF, INF, INF, INF, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}};\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; N; k&amp;#43;&amp;#43;)\n    { &lt;span class=\"hljs-comment\"&gt;// 遍历所有顶点&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n            {\n                A[i][j] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(A[i][j], A[i][k] &amp;#43; A[k][j]); &lt;span class=\"hljs-comment\"&gt;// 更新最短路径&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 输出最短路径矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; A[i][j] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        }\n        cout &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;以上就是ChatGPT给出的答案&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["利用c++解决图论问题", ["1、利用随机数原理，随机产生一个二维数组A（30*30），其中对角线元素为零，剩余元素中的50%是∞，其余元素的值为大于0的随机数。", "2、将上述二维数组作为图的邻接矩阵，以该数组作为输入，创建一个图形结构，该图使用邻接表作为存储结构。", "3、利用DFS或者BFS算法遍历该图，找到图中权值最小的边。", "4、设计一个基于Floyd的最短路径算法，计算所有顶点之间的最短路径。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/Autumn_1/article/details/120704004\" id=\"textarea_1654690889500_1654690932727_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;java实现老鼠迷宫游戏_小小寂寞的城的博客-CSDN博客_老鼠迷宫java&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;最近学java,在递归部分看到老鼠迷宫游戏,感觉挺有意思,记录一下我们可以把迷宫当成一个二位数组,其中1代表障碍物,走不了,初始化一个二维数组,设置好障碍物//老鼠迷宫        int[][] map &amp;#61; {                {1,1,1,1,1,1,1,1},                {1,0,0,0,0,0,0,1},                {1,1,0,0,0,0,0,1},                {1,0,1,0,0,0,0,1},     &lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/Autumn_1/article/details/120704004&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["Java语言迷宫鼠详解", ["（1）概述：用java面向对象程序设计语言，设计和实现一电脑鼠走迷宫的软件程序，", "即一个假想的小车能在图示的迷宫中根据设定的起始点和终点自主寻找路径。", "（2）迷宫地图生成算法的设计和实现", "自动生成迷宫：根据迷宫生成算法自动生成一定复杂度的迷宫地图。", "手动生成迷宫：根据文件中存储的固定数据生成迷宫地图。", "单路径寻找算法的设计与实现：找出迷宫中一条单一的通路。", "迷宫遍历算法的设计与实现：遍历迷宫中所有的可行路径。", "最短路径计算算法的设计与实现：根据遍历结果，找出迷宫中所有通路中的最短通", "路。", "（3）通过动画展示出迷宫鼠在迷宫内的运动。", "（4)具有判断通路和障碍的功能；走不通具备返回的能力（路径记忆）；能够寻找最短路径；"]], "Tag": "算法设计"}
{"Answer": "只将有多条可行路径的点入栈就可以，每一个点从正确性上说也可以，但是不优化。", "Konwledge_Point": "最短路径", "Question": ["想问大家C语言数据结构一个学术问题", ["大家用C语言做迷宫最短路径问题，是将可行路径上的每一个经过的点都入栈，还是仅仅只将有多条可行路径的点入栈呀。我又看了下书，好像懂了QAQ，不过还是欢迎大佬提点一下。", "\n\n", "                                    拜托各位大佬的指点了\n"]], "Tag": "算法设计"}
{"Answer": "[http://www.it165.net/pro/html/201407/16957.html](http://www.it165.net/pro/html/201407/16957.html \"\")", "Konwledge_Point": "最短路径", "Question": ["c语言课程设计分油问题", ["输入三个油瓶容量与目标容量， 用邻接矩阵求它的最短路径   ，先判断两点间有没有路 最短路是什么，  调用邻接矩阵函数求   。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这个正无穷是初始化的时候的&amp;#xff0c;初始化标记正无穷大表示该点无法到达&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这个地方的正无穷是如何看出来的，能否解释一下", ["这个地方的正无穷是如何看的，最短路径。就是比如v1那个有一个正无穷，v5那有四个正无穷，这个正无穷数量该怎么看。"]], "Tag": "算法设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;不停刷题&amp;#xff0c;刷开源代码&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "最短路径", "Question": ["大三学生如何提升代码能力", ["作为一名普通本科计算机专业大三的学生，应当具备怎样的代码能力？我只对c和c++比较熟悉，一些算法比如最短路径，我能手写在纸上，但调试总需要很久。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;非常抱歉&amp;#xff0c;本次您提出的有问必答问题&amp;#xff0c;技术专家团超时未为您做出解答&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;本次提问扣除的有问必答次数&amp;#xff0c;将会以问答VIP体验卡&amp;#xff08;1次有问必答机会、商城购买实体图书享受95折优惠&amp;#xff09;的形式为您补发到账户。&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;因为有问必答VIP体验卡有效期仅有1天&amp;#xff0c;您在需要使用的时候【私信】联系我&amp;#xff0c;我会为您补发。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["关于#matlab# #算法# #python#的问题：校园导航制作", ["需要录入许多个位置点，要怎么录入呢？利用算法快速获得最短路径，我打算使用弗洛伊德算法做，但是无从入手，算法具体应该怎么做，还有还有，这个算法适合做导航吗，请救救孩子吧wwww～ballballyou！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;如果需要展示地图的话还是要调用地图接口的 看你这边的话应该用的是原生js走的&lt;br /&gt;你可以看一下我之前写的调用 高德地图的文章&amp;#xff0c;应该还是比较适用你现在这种情况的&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/084675443146199.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/clli_Chain/article/details/107982453?spm&amp;#61;1001.2014.3001.5502\" id=\"textarea_1641344400250_1641344593085_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/clli_Chain/article/details/107982453?spm&amp;#61;1001.2014.3001.5502&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["怎么把搜索结果界面展示在搜索框下面", ["做一个查询路线的界面，现在需要在搜索框搜索之后，把搜索结果就展示在搜索框的下方位置，应该怎么做", "\n", "把各种最短路径之类的展示在中间的小框里面", "要把查询出来的地图路线展示在下方的大框里面，", "应该怎么做啊"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这个问题就是一个加权无向图的最小路径求解的问题&amp;#xff0c;我给个例子你参考一下&amp;#xff0c;直接用现成的算法实现的&amp;#xff0c;代码并不复杂&amp;#xff0c;看看是否符合你的要求&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-built_in\"&gt;import&lt;/span&gt; matplotlib.pyplot as plt\n&lt;span class=\"hljs-built_in\"&gt;import&lt;/span&gt; networkx\n\n&lt;span class=\"hljs-attr\"&gt;G2&lt;/span&gt; &amp;#61; networkx.Graph()  &lt;span class=\"hljs-comment\"&gt;# 创建&amp;#xff1a;空的 无向图&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#创建加权边&amp;#xff0c;a、b、c等代表城市&amp;#xff0c;后边的值代表乘车时间&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;edges&lt;/span&gt; &amp;#61; [(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;13&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;), \n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;k&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;l&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;m&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;),\n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;),\n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;h&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;h&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;),\n        (&lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;j&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;j&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;k&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;),(&lt;span class=\"hljs-string\"&gt;&amp;#34;k&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;l&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;), (&lt;span class=\"hljs-string\"&gt;&amp;#34;l&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;m&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)]\nG2.add_weighted_edges_from(edges)  &lt;span class=\"hljs-comment\"&gt;# 向图中添加多条赋权边: (node1,node2,weight)&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#指定要求解的两个点&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;source&lt;/span&gt; &amp;#61; &amp;#39;b&amp;#39;\n&lt;span class=\"hljs-attr\"&gt;target&lt;/span&gt; &amp;#61; &amp;#39;f&amp;#39;\n&lt;span class=\"hljs-comment\"&gt;# 两个指定顶点之间的最短加权路径&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;minWPath&amp;#61;&lt;/span&gt; networkx.dijkstra_path(G2, &lt;span class=\"hljs-attr\"&gt;source&amp;#61;source,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;target&amp;#61;target)&lt;/span&gt;\nprint(f&lt;span class=\"hljs-string\"&gt;&amp;#34;顶点 {source} 到 顶点 {target} 的最短加权路径: {minWPath}&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-comment\"&gt;# 两个指定顶点之间的最短加权路径的长度&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;lMinWPath&lt;/span&gt; &amp;#61; networkx.dijkstra_path_length(G2, &lt;span class=\"hljs-attr\"&gt;source&amp;#61;source,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;target&amp;#61;target)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;#最短加权路径长度&lt;/span&gt;\nprint(f&lt;span class=\"hljs-string\"&gt;&amp;#34;顶点 {source} 到 顶点 {target} 的最短加权路径长度: {lMinWPath}&amp;#34;&lt;/span&gt;)\n\n&lt;span class=\"hljs-attr\"&gt;pos&lt;/span&gt; &amp;#61; networkx.spring_layout(G2)  &lt;span class=\"hljs-comment\"&gt;# 用 FR算法排列节点&lt;/span&gt;\nnetworkx.draw(G2, pos, &lt;span class=\"hljs-attr\"&gt;with_labels&amp;#61;True,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;alpha&amp;#61;0.5)&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#画所有节点&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;labels&lt;/span&gt; &amp;#61; networkx.get_edge_attributes(G2,&amp;#39;weight&amp;#39;) &lt;span class=\"hljs-comment\"&gt;#取加权值为标签&lt;/span&gt;\nnetworkx.draw_networkx_edge_labels(G2, pos, &lt;span class=\"hljs-attr\"&gt;edge_labels&lt;/span&gt; &amp;#61; labels) &lt;span class=\"hljs-comment\"&gt;#画边和标签&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;posCopy&lt;/span&gt; &amp;#61; pos.copy()  &lt;span class=\"hljs-comment\"&gt;#复制所有节点&lt;/span&gt;\n&lt;span class=\"hljs-attr\"&gt;edgesCopy&lt;/span&gt; &amp;#61; [] &lt;span class=\"hljs-comment\"&gt;#最小路径加权边&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#遍历所有节点&amp;#xff0c;保留最小路径相关节点&lt;/span&gt;\nfor k &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; pos.keys():\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; k not &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; minWPath:\n        posCopy.pop(k)\n&lt;span class=\"hljs-comment\"&gt;#遍历所有加权边&amp;#xff0c;取出最小路径相关加权边&lt;/span&gt;\nfor i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; range(len(minWPath)-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;):\n    for edge &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; edges:\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; minWPath[i] &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; edge &lt;span class=\"hljs-literal\"&gt;and&lt;/span&gt;  minWPath[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; edge:\n            edgesCopy.append(edge)\n            break\n&lt;span class=\"hljs-attr\"&gt;minG2&lt;/span&gt; &amp;#61; networkx.Graph() &lt;span class=\"hljs-comment\"&gt;#创建空无向图&lt;/span&gt;\nminG2.add_weighted_edges_from(edgesCopy) &lt;span class=\"hljs-comment\"&gt;#向图中添加最小路径加权边&lt;/span&gt;\nnetworkx.draw(minG2, posCopy, &lt;span class=\"hljs-attr\"&gt;with_labels&amp;#61;False,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;alpha&amp;#61;1,&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;edge_color&amp;#61;&amp;#39;red&amp;#39;)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;#用红色标记最小路径边&lt;/span&gt;\nplt.show()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/021541002156147.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["尽快，求解以下问题如图中第五题的程序要求，文件夹压缩包的形式发我，最好于4月30号中午12点前发我", ["求解最短路径", "提供算法思想描述，程序结构，测试结果", "\n", "设有n(n> 10)个城市之间的交通图。假设任意两个城市之间不一定有直接交通线路，权表示乘车时间。要求事先将交通图信息将存人磁盘文件中，求从某城市出发到其他城市的最少乘车时间和乘车路线。要求将结果以图形方式在屏幕上输出。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;运行结果&amp;#xff08;ctrl&amp;#43;z结束输入&amp;#xff0c;vs2022需要连续输入3次才ctrl&amp;#43;z可以&amp;#xff09;&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/318529884076145.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#define _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;#define MM 100&lt;/span&gt;\n\n\n&lt;span class=\"hljs-comment\"&gt;//站点信息&lt;/span&gt;\ntypedef struct node\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; cost;      &lt;span class=\"hljs-comment\"&gt;//两个站点间的花费&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; vexnode;   &lt;span class=\"hljs-comment\"&gt;//顶点编号&lt;/span&gt;\n    char name[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//站点名称&lt;/span&gt;\n    struct node* next;\n}Arcnode;\n\ntypedef struct _graph\n{\n    Arcnode* point[MM];\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;  vexnum;\n} graph;\n&lt;span class=\"hljs-comment\"&gt;//队列&lt;/span&gt;\ntypedef struct queue\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; father;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; son;\n    struct queue* next;\n}queue;\n\nqueue* init_queue()\n{\n    queue* head &amp;#61; (queue*)malloc(sizeof(queue));\n    head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;\n}\n&lt;span class=\"hljs-comment\"&gt;//1为空&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;empty&lt;/span&gt;(queue* head)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//入栈&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push(queue* head, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; j)   &lt;span class=\"hljs-comment\"&gt;// i:father point   j:son point&lt;/span&gt;\n{\n    queue* tmp &amp;#61; head;\n    queue* nn &amp;#61; (queue*)malloc(sizeof(queue));\n    nn-&amp;gt;father &amp;#61; j;\n    nn-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//nn-&amp;gt;son &amp;#61; j;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (tmp-&amp;gt;next)\n        tmp &amp;#61; tmp-&amp;gt;next;\n    tmp-&amp;gt;next &amp;#61; nn;\n\n}\n&lt;span class=\"hljs-comment\"&gt;//出栈&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; pop(queue* head, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;* i, &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;* j)\n{\n    queue* tmp &amp;#61; head;\n    queue* pre &amp;#61; head;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head-&amp;gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        *j &amp;#61; head-&amp;gt;father;\n        free(head);\n        head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        tmp &amp;#61; head-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (tmp-&amp;gt;next)\n        {\n            pre &amp;#61; tmp;\n            tmp &amp;#61; tmp-&amp;gt;next;\n        }\n        *j &amp;#61; tmp-&amp;gt;father;\n        free(tmp);\n        pre-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//根据名字查找节点是否存在&amp;#xff0c;如果存在返回节点编号&amp;#xff0c;否则返回-1&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; findVertex(graph* g, char* name)\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; g-&amp;gt;vexnum; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(g-&amp;gt;point[i]-&amp;gt;name, name) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//读数据并创建图&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt;  readAndCreatGraph(graph* g)\n{\n    Arcnode* tmpnode, * curnode,*head;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, j;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; cost;\n    char name[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, dst[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    g-&amp;gt;vexnum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %d&amp;#34;&lt;/span&gt;,name,dst,&amp;amp;cost)!&amp;#61; EOF)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//查看节点是否已经存在&lt;/span&gt;\n        i &amp;#61; findVertex(g, name);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//节点不存在&lt;/span&gt;\n        {\n            curnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            curnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            strcpy(curnode-&amp;gt;name, name);\n            &lt;span class=\"hljs-comment\"&gt;//创建当前节点的链表&lt;/span&gt;\n            head &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            head-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            curnode-&amp;gt;next &amp;#61; head; &lt;span class=\"hljs-comment\"&gt;//第一个节点不存储内容&lt;/span&gt;\n            g-&amp;gt;point[g-&amp;gt;vexnum] &amp;#61; curnode;\n            g-&amp;gt;vexnum &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//个数加1&lt;/span&gt;\n\n            &lt;span class=\"hljs-comment\"&gt;//将目的节点插入链表&lt;/span&gt;\n            j &amp;#61; findVertex(g, dst);\n            curnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            curnode-&amp;gt;cost &amp;#61; cost;\n            curnode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            strcpy(curnode-&amp;gt;name, dst);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                curnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                curnode-&amp;gt;vexnode &amp;#61; j;\n            &lt;span class=\"hljs-comment\"&gt;//将节点插入&lt;/span&gt;\n            head-&amp;gt;next &amp;#61; curnode;\n\n            &lt;span class=\"hljs-comment\"&gt;//如果目的节点不再图中&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            {\n                tmpnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                tmpnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                strcpy(tmpnode-&amp;gt;name, dst);\n                head &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                head-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                tmpnode-&amp;gt;next &amp;#61; head;\n                g-&amp;gt;point[g-&amp;gt;vexnum] &amp;#61; tmpnode;\n                g-&amp;gt;vexnum &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//节点数&amp;#43;1&lt;/span&gt;\n            }\n            \n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-comment\"&gt;//源节点已经存在&lt;/span&gt;\n            tmpnode &amp;#61; g-&amp;gt;point[i]-&amp;gt;next; &lt;span class=\"hljs-comment\"&gt;//得到链表头&lt;/span&gt;\n            curnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n            curnode-&amp;gt;cost &amp;#61; cost;\n            curnode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            strcpy(curnode-&amp;gt;name, dst);\n            j &amp;#61; findVertex(g, dst); &lt;span class=\"hljs-comment\"&gt;//看看目的节点是否已经存在&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                curnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                curnode-&amp;gt;vexnode &amp;#61; j;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (tmpnode-&amp;gt;next)\n                tmpnode &amp;#61; tmpnode-&amp;gt;next;\n            tmpnode-&amp;gt;next &amp;#61; curnode;\n\n            &lt;span class=\"hljs-comment\"&gt;//如果目的节点不存在&amp;#xff0c;将该节点插入图中&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            {\n                tmpnode &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                tmpnode-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                strcpy(tmpnode-&amp;gt;name, dst);\n                head &amp;#61; (Arcnode*)malloc(sizeof(Arcnode));\n                head-&amp;gt;vexnode &amp;#61; g-&amp;gt;vexnum;\n                head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                tmpnode-&amp;gt;next &amp;#61; head;\n                g-&amp;gt;point[g-&amp;gt;vexnum] &amp;#61; tmpnode;\n                g-&amp;gt;vexnum &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n        \n\n    }\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//找最短路径&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; dijkstra(graph* g)\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; inqueue[MM] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };  &lt;span class=\"hljs-comment\"&gt;//是否已经入栈&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; id, start_s;\n    Arcnode* ns &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    queue* last &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//队列的最后一个元素&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; una, unb, xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, yy &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    queue* head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pathMin[MM] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };                &lt;span class=\"hljs-comment\"&gt;//最短路径&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pathTmp[MM] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };                &lt;span class=\"hljs-comment\"&gt;//临时路径&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; minDistance &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, tmpdis &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;       &lt;span class=\"hljs-comment\"&gt;//最短路径距离&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; lengpath &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, minpathlen &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;       &lt;span class=\"hljs-comment\"&gt;//最短路径点个数&lt;/span&gt;\n    queue* qMin &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; kktt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, vv &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; start, end; &lt;span class=\"hljs-comment\"&gt;//起点和终点&lt;/span&gt;\n    char str_start[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;], str_end[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; flags[MM][MM];\n    &lt;span class=\"hljs-comment\"&gt;//system(&amp;#34;cls&amp;#34;);&lt;/span&gt;\n\n\n    &lt;span class=\"hljs-comment\"&gt;//显示地图信息&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//showBaseInfo(g);&lt;/span&gt;\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入起点和终点:&amp;#34;&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s&amp;#34;&lt;/span&gt;, str_start , str_end);\n    start &amp;#61; findVertex(g,str_start);\n    end &amp;#61; findVertex(g,str_end);\n\n    &lt;span class=\"hljs-comment\"&gt;//初始化邻接矩阵&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; MM; xx&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (yy &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; yy &amp;lt; MM; yy&amp;#43;&amp;#43;)\n            flags[xx][yy] &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; g-&amp;gt;vexnum; xx&amp;#43;&amp;#43;)\n    {\n        ns &amp;#61; g-&amp;gt;point[xx]-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (ns)\n        {\n            flags[xx][ns-&amp;gt;vexnode] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            ns &amp;#61; ns-&amp;gt;next;\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//起点入栈&lt;/span&gt;\n    head &amp;#61; init_queue();\n    head-&amp;gt;father &amp;#61; start;\n    inqueue[start] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//起点已入栈&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!&lt;span class=\"hljs-keyword\"&gt;empty&lt;/span&gt;(head))\n    {\n        &lt;span class=\"hljs-comment\"&gt;//获取队列中的最后一个元素&lt;/span&gt;\n        last &amp;#61; head;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (last-&amp;gt;next)\n            last &amp;#61; last-&amp;gt;next;\n        start_s &amp;#61; last-&amp;gt;father;\n\n        &lt;span class=\"hljs-comment\"&gt;//获取队列中最后一个元素的一个可到达的站&lt;/span&gt;\n        id &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; g-&amp;gt;vexnum; xx&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flags[start_s][xx] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                flags[start_s][xx] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                id &amp;#61; xx;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//如果未找到&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (id &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            pop(head, &amp;amp;una, &amp;amp;unb); &lt;span class=\"hljs-comment\"&gt;//栈弹出一个元素&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (unb &amp;#61;&amp;#61; start) head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-comment\"&gt;//查找unb所有相邻节点&amp;#xff0c;并将其状态设为未访问&lt;/span&gt;\n\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; MM; xx&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flags[unb][xx] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) flags[unb][xx] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            }\n\n            inqueue[start_s] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//该顶点标记为未入栈&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;             &lt;span class=\"hljs-comment\"&gt;//取栈顶的相邻节点&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (inqueue[id])  &lt;span class=\"hljs-comment\"&gt;//若已经在栈中&amp;#xff0c;取下一个顶点&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n\n\n        push(head, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, id);            &lt;span class=\"hljs-comment\"&gt;//将该顶点入栈&lt;/span&gt;\n        inqueue[id] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;            &lt;span class=\"hljs-comment\"&gt;//记为已入栈&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (id &amp;#61;&amp;#61; end)              &lt;span class=\"hljs-comment\"&gt;//如果栈顶已经为所求&amp;#xff0c;将此路径记录&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-comment\"&gt;//-----------------计算路径的长度-----------------------------&lt;/span&gt;\n            qMin &amp;#61; head;\n            lengpath &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (qMin)\n            {\n                pathTmp[lengpath] &amp;#61; qMin-&amp;gt;father;\n                lengpath&amp;#43;&amp;#43;;\n                qMin &amp;#61; qMin-&amp;gt;next;\n            }\n            tmpdis &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (kktt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; kktt &amp;lt; lengpath - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; kktt&amp;#43;&amp;#43;)\n            {\n                vv &amp;#61; pathTmp[kktt];\n                ns &amp;#61; g-&amp;gt;point[vv]-&amp;gt;next;\n                &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (ns)\n                {\n                    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ns-&amp;gt;vexnode &amp;#61;&amp;#61; pathTmp[kktt &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n                    {\n                        tmpdis &amp;#43;&amp;#61; ns-&amp;gt;cost;\n                        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n                    }\n                    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                        ns &amp;#61; ns-&amp;gt;next;\n                }\n            }\n\n            &lt;span class=\"hljs-comment\"&gt;//显示所有路径&lt;/span&gt;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;花费&amp;#61;%d : &amp;#34;&lt;/span&gt;, tmpdis);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; ( xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; lengpath; xx&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//int&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (xx &amp;lt; lengpath - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s --&amp;gt; &amp;#34;&lt;/span&gt;, g-&amp;gt;point[pathTmp[xx]]-&amp;gt;name);\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;,g-&amp;gt;point[pathTmp[xx]]-&amp;gt;name );\n            }\n            &lt;span class=\"hljs-comment\"&gt;//找最短路径&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (minDistance &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || minDistance &amp;gt; tmpdis)\n            {\n                minDistance &amp;#61; tmpdis;\n                minpathlen &amp;#61; lengpath;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; ( xx &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; xx &amp;lt; lengpath; xx&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//int&lt;/span&gt;\n                    pathMin[xx] &amp;#61; pathTmp[xx];\n            }\n\n            &lt;span class=\"hljs-comment\"&gt;//--------------------------------------------------------------&lt;/span&gt;\n            pop(head, &amp;amp;una, &amp;amp;unb); &lt;span class=\"hljs-comment\"&gt;//将其弹出&amp;#xff0c;继续探索&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (unb &amp;#61;&amp;#61; start) head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            inqueue[id] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//清空入栈的标志位&lt;/span&gt;\n        }\n    } &lt;span class=\"hljs-comment\"&gt;//while end&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//打印最短路径&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (minDistance &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;无可用路径\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n最小花费:%d:&amp;#34;&lt;/span&gt;, minDistance);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (kktt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; kktt &amp;lt; minpathlen; kktt&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (kktt &amp;lt; minpathlen - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s --&amp;gt; &amp;#34;&lt;/span&gt;, g-&amp;gt;point[pathMin[kktt]]-&amp;gt;name);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, g-&amp;gt;point[pathMin[kktt]]-&amp;gt;name);\n    }\n}\n\n\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    graph g;\n    g.vexnum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    readAndCreatGraph(&amp;amp;g);\n    dijkstra(&amp;amp;g);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["迪杰斯特拉算法之解决最省钱的出游方案", ["用迪杰斯特拉最短路径算法解决最省钱的出游方案。即给定一个出发地和目的地，给出最省钱的出游方案。各地票价如下：", "\n", "出发地 目的地 票价", "广州 北京 1000", "广州 深圳 200", "广州 上海 800", "深圳 北京 700", "深圳 上海 600", "深圳 拉萨1000", "北京 广州 1000", "北京 上海 500", "北京 深圳 700", "上海 广州 700", "上海 北京 500", "上海 深圳 700", "上海 拉萨1200", "拉萨 上海 1100"]], "Tag": "算法设计"}
{"Answer": "刚才到网上搜索到了一份A*算法的javascript实现.效果不错.\r\n楼主去看一下吧:[url]http://www.gissky.com/Download/ShowSoft.Asp?Type=4&amp;ID=218[/url]\r\n不过代码没什么注释..看起来可能会有点头痛.", "Konwledge_Point": "最短路径", "Question": ["求算法", ["从A点（0，0）到B点（100，100）的最短路径", "\n\n", "如路线上存在障碍物，求绕过障碍物的最短路线", "\n[b]问题补充：[/b]", "\n其实我是自己无聊的时候在做html小游戏时遇到的问题， 我点击页面某一点， 然后页面中的小球则向我的点击坐标移动。", "\n那么在JS中又怎样实现这算法呢？", "\n这方面我还是太白，……"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;什么错误&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["莫名的错误帮我看看吧", ["\n", "这个错误很离谱，这是一个求图的最短路径代码，m和n分别表示起点和终点，但是如这个图所示，我cin两个指，然后调用shorts函数，这样程序运行时就会调用shorts函数失败，但如果我直接int m=0，n=5。这样它又能运行成功，感觉很疑惑，请教各位教导"]], "Tag": "算法设计"}
{"Answer": "关于(*D)[v][w]和(D)[v][w]的含义和区别，以及引发异常的原因解读\r\n\r\n\r\n```c++\r\n// 解读你的部分代码\r\n#define MAXVEX 20\r\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\r\nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)\r\n{\r\n\t/* \r\n\t * 此处 D 的原型表达式为： int (*)[20][20]\r\n\t *\r\n\t * 1）说明 D 是一个指针（三维数组指针），指向一个整型的二维数组。该二维\r\n\t * 数组的长度是20*20=400，即D的步长是400\r\n\t * \r\n\t * 2）而 *D 则是一个整型的二维数组，或者称 *D 是一个指向非常量的常量指\r\n\t * 针，或者被称为行指针，步长为20\r\n\t */\r\n\r\n\t int v,w;\r\n\r\n\t/*\r\n\t * 此处 (*D)[v][w] 表示二维数组第 v 行第 w 列元素的值。用指针表达式\r\n\t * 为： (*D)[v][w] = *((*D)[v]+w) = *(*((*D)+v)+w)  【地址偏移量=v*20+w】\r\n\t */\r\n\t (*D)[v][w]=...;\r\n\r\n\t/*\r\n\t * 此处 (D)[v][w] 表示三维数组指针 D 的下标运算，指向第 v 行（每行步长\r\n\t * 为400）第 w 列（每列步长20）的整型一维数组（形参为 int [20]）。指针地址表达式\r\n\t * 为： (D)[v][w] = *(D[v])+w = **(D+v)+w 【地址偏移量=v*400+w*20】\r\n\t *\r\n\t * PS: (D)[v][w] = D[v][w] = &amp;(D[v][w][0])\r\n\t * \r\n\t * 【异常】注意指针表达式中的v、w在下标运算中与形参（int [_v][_w]）行列下标是错位的，实际对应的是整型的\r\n\t * 三维数组（int [v][w][0]）下标顺序。很明显只要v&gt;0时，该行代码就会发生指针越界引发异常（行下标越界）\r\n\t */\r\n\t(D)[v][w]=...;\r\n\r\n\t// PPS:\r\n\t/*\r\n\t * 此处 *D[v][w] 表示一维数组第w个元素的值。用指针表达式\r\n\t * 为： *(*(D[v])+w) = *(**(D+v)+w) 【地址偏移量=v*400+w*20+0】\r\n\t *\r\n\t * PPPS: *D[v][w] = *(D[v][w]) = D[v][w][0]\r\n\t */\r\n\t*D[v][w]=...;\r\n}\r\n\r\n```\r\n\r\n---\r\n如果要使用 (D)[v][w] 作为实参计算是可以的哈，只需要改变函数形参即可，代码如下：\r\n\r\n```c++\r\n/**\r\n  * 新变量类型ShortPathTable实质也是一个二维数组，而使用二维数组作为函数参数，函\r\n  * 数调用时传递的是一个指针，不会发生构造拷贝。因此函数内的值修改，其实是在原地\r\n  * 址进行修改，函数返回后当然会保留修改后的值。\r\n  */\r\nvoid ShortestPath_Floyd(MGraph G, Patharc P, ShortPathTable D)\r\n{\r\n\tint v,w,k;\r\n\r\n\t// 此处 (D)[v][w] 表示整型二维数组的第 v 行第 w 列元素的值（表达式是正确的）\r\n\t(D)[v][w]=(D)[v][k]+(D)[k][w];\r\n}\r\n\r\n```", "Konwledge_Point": "最短路径", "Question": ["(*D)[v][w]为何要加上*，不加*程序可以运行但是会出错这是为什么？", ["\n\n", "#include \"stdio.h\"    \n#include \"stdlib.h\"   \n#include \"io.h\"  \n#include \"math.h\"  \n#include \"time.h\"\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n#define MAXEDGE 20\n#define MAXVEX 20\n#define INFINITY 65535\n\ntypedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */\n\ntypedef struct\n{\n    int vexs[MAXVEX];\n    int arc[MAXVEX][MAXVEX];\n    int numVertexes, numEdges;\n}MGraph;\n\ntypedef int Patharc[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\n/* 构件图 */\nvoid CreateMGraph(MGraph *G)\n{\n    int i, j;\n\n    /* printf(\"请输入边数和顶点数:\"); */\n    G->numEdges=16;\n    G->numVertexes=9;\n\n    for (i = 0; i < G->numVertexes; i++)/* 初始化图 */\n    {\n        G->vexs[i]=i;\n    }\n\n    for (i = 0; i < G->numVertexes; i++)/* 初始化图 */\n    {\n        for ( j = 0; j < G->numVertexes; j++)\n        {\n            if (i==j)\n                G->arc[i][j]=0;\n            else\n                G->arc[i][j] = G->arc[j][i] = INFINITY;\n        }\n    }\n\n    G->arc[0][1]=1;\n    G->arc[0][2]=5; \n    G->arc[1][2]=3; \n    G->arc[1][3]=7; \n    G->arc[1][4]=5; \n\n    G->arc[2][4]=1; \n    G->arc[2][5]=7; \n    G->arc[3][4]=2; \n    G->arc[3][6]=3; \n    G->arc[4][5]=3;\n\n    G->arc[4][6]=6;\n    G->arc[4][7]=9; \n    G->arc[5][7]=5; \n    G->arc[6][7]=2; \n    G->arc[6][8]=7;\n\n    G->arc[7][8]=4;\n\n\n    for(i = 0; i < G->numVertexes; i++)\n    {\n        for(j = i; j < G->numVertexes; j++)\n        {\n            G->arc[j][i] =G->arc[i][j];\n        }\n    }\n\n}\n\n/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    \nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)\n{    \n    int v,w,k;    \n    for(v=0; v<G.numVertexes; ++v) /* 初始化D与P */  \n    {        \n        for(w=0; w<G.numVertexes; ++w)  \n        {\n            (*D)[v][w]=G.arc[v][w]; /* D[v][w]值即为对应点间的权值 */\n            (*P)[v][w]=w;               /* 初始化P */\n        }\n    }\n    for(k=0; k<G.numVertexes; ++k)   \n    {\n        for(v=0; v<G.numVertexes; ++v)  \n        {        \n            for(w=0; w<G.numVertexes; ++w)    \n            {\n                if ((*D)[v][w]>(*D)[v][k]+(*D)[k][w])\n                {/* 如果经过下标为k顶点路径比原两点间路径更短 */\n                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */\n                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */\n                }\n            }\n        }\n    }\n}\n\nint main(void)\n{    \n    int v,w,k;  \n    MGraph G;    \n\n    Patharc P;    \n    ShortPathTable D; /* 求某点到其余各点的最短路径 */   \n\n    CreateMGraph(&G);\n\n    ShortestPath_Floyd(G,&P,&D);  \n\n    printf(\"各顶点间最短路径如下:\\n\");  \n    for(v=0; v<G.numVertexes; ++v)   \n    {        \n        for(w=v+1; w<G.numVertexes; w++)  \n        {\n            printf(\"v%d-v%d weight: %d \",v,w,D[v][w]);\n            k=P[v][w];              /* 获得第一个路径顶点下标 */\n            printf(\" path: %d\",v);  /* 打印源点 */\n            while(k!=w)             /* 如果路径顶点下标不是终点 */\n            {\n                printf(\" -> %d\",k); /* 打印路径顶点 */\n\n                k=P[k][w];          /* 获得下一个路径顶点下标 */\n            }\n            printf(\" -> %d\\n\",w);   /* 打印终点 */\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"最短路径D\\n\");\n    for(v=0; v<G.numVertexes; ++v)  \n    {        \n        for(w=0; w<G.numVertexes; ++w)    \n        {\n            printf(\"%d\\t\",D[v][w]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"最短路径P\\n\");\n    for(v=0; v<G.numVertexes; ++v)  \n    {        \n        for(w=0; w<G.numVertexes; ++w)    \n        {\n            printf(\"%d \",P[v][w]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这个是路径规划问题&amp;#xff0c;可以参考一下&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/YF_Li123/article/details/74090301\"&gt;https://blog.csdn.net/YF_Li123/article/details/74090301&lt;/a&gt;&lt;br /&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["此题不会做（C++给代码）", ["\n描述\n现在有", "N", "个城市，编号分别为", "1", "到", "N", "，他们之间用单向道路进行相连。值得注意的是，每条道路有", "2", "个参数：道路长度和需要为此道路支付的通行费。\n\n现在周末来了，住在城市", "1", "的小明，拿上了他的钱包和他的", "switch", "，准备和小红一起玩", "1", "小时游戏。但是小红住在城市", "N", "，且小明的零花钱有限。\n\n需要聪明的你帮助小明找到从城市", "1", "到城市", "N", "的最短路径，而且他能付得起这个通行费。\n\n输入格式\n第", "1", "行输入", "K", "。 这是小明拥有的零花钱", "K", "元。\n\n第", "2", "行输入", "N", "。这是城市总数", "N", "。\n\n第", "3", "行输入", "M", "。这是城市之间的单向道路数。\n\n接下来的", "M", "行，每行输入一道道路，道路信息包含", "4", "个数字，分别代表每条道路的", "4", "个信息：", "S", ",", " ", "D", ",", " ", "L", ",", " ", "C", "。\n\n", "S", "为道路的起点（城市编号），", "D", "为道路终点（城市编号）， ", "L", "为该道路的长度，", "C", "为该道路的通行费。\n\n依次类推，输入若干组样例。\n\n\n\n输出格式\n第", "1", "行输出第", "1", "个样例的结果，", "1", "个数字。代表小明从城市", "1", "到城市", "N", "的最短路径，该路径通行费小于等于", "K", "。如果不存在这样的最短路输出", "-", "1", "。\n\n依次类推，输出其他组样例的结果。\n\n输入样例\n", "5", "\n\n", "6", "\n\n", "7", "\n\n", "1", " ", "2", " ", "2", " ", "3", "\n\n", "2", " ", "4", " ", "3", " ", "3", "\n\n", "3", " ", "4", " ", "2", " ", "4", "\n\n", "1", " ", "3", " ", "4", " ", "1", "\n\n", "4", " ", "6", " ", "2", " ", "1", "\n\n", "3", " ", "5", " ", "2", " ", "0", "\n\n", "5", " ", "4", " ", "3", " ", "2", "\n\n输出样例\n", "11", "\n\n数据范围\n", "0", " ", "<=", " ", "K", " ", "<=", " ", "10000", ",", "\n\n", "2", " ", "<=", " ", "N", " ", "<=", " ", "100", ",", "\n\n", "1", " ", "<=", " ", "M", " ", "<=", " ", "10000", ",", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;核心应该就是最短路径算法的实现&amp;#xff1a;&lt;br /&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include&amp;lt;stdio.h&amp;gt;\n  \n#define SIZE 110  \n#define INF 1000000;  \n \nint map&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;;  //邻接矩阵存储 \nint len&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;;      //d&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;表示源点到i这个点的距离 \nint visit&lt;span class=\"hljs-comment\"&gt;[SIZE]&lt;/span&gt;;  //节点是否被访问 \nint n,m;  \n \nint dijkstra(int from, int to){    //从源点到目标点 \n    \n    int i;  \n    \n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; n ; i &amp;#43;&amp;#43;){    //初始化 \n        visit&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; &amp;#61; 0;    //一开始每个点都没被访问 \n        len&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; &amp;#61; map&lt;span class=\"hljs-comment\"&gt;[from]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;;    //先假设源点到其他点的距离 \n    }  \n  \n    int j;  \n    for(i &amp;#61; 1 ; i &amp;lt; n ; &amp;#43;&amp;#43;i){    //对除源点的每一个点进行最短计算 \n        int min &amp;#61; INF;  //记录最小len&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; \n        int pos;  //记录小len&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt; 的点 \n  \n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){    \n            if(!visit&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;amp;&amp;amp; min &amp;gt; len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;){  \n                pos &amp;#61; j;  \n                min &amp;#61; len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;;  \n            }  \n        }  \n        visit&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt; &amp;#61; 1;  \n  \n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){\n            if(!visit&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;amp;&amp;amp; (len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;gt; (len&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt; &amp;#43;map&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;))){ //如果j节点没有被访问过&amp;amp;&amp;amp;j节点到源节点的最短路径&amp;gt;pos节点到源节点的最短路径&amp;#43;pos节点到j节点的路径  \n                len&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61; len&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt; &amp;#43; map&lt;span class=\"hljs-comment\"&gt;[pos]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;;    //更新j节点到源节点的最短路径    \n            }  \n        }  \n    }  \n  \n    return len&lt;span class=\"hljs-comment\"&gt;[to]&lt;/span&gt;;\n}\n  \n  \nint main () {  \n \n    int i,j;  \n    \n  //  scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;n,&amp;amp;m);    //输入数据\n    n &amp;#61; 6;    //测试数据 \n    m &amp;#61; 9;\n \n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;i){    //设一开始每个点都不可达 \n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){  \n            map&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61; INF;  \n        }  \n    }  \n    \n/*    int a,b,c;    //输入数据 \n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; m ; &amp;#43;&amp;#43;i){  \n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;c);  \n        map&lt;span class=\"hljs-comment\"&gt;[a]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[b]&lt;/span&gt; &amp;#61; map&lt;span class=\"hljs-comment\"&gt;[b]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[a]&lt;/span&gt; &amp;#61; c;  \n    }  */\n    \n    map&lt;span class=\"hljs-comment\"&gt;[1]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[2]&lt;/span&gt; &amp;#61; 7;    //测试数据 \n    map&lt;span class=\"hljs-comment\"&gt;[1]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt; &amp;#61; 9;\n    map&lt;span class=\"hljs-comment\"&gt;[1]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[6]&lt;/span&gt; &amp;#61; 14;\n    map&lt;span class=\"hljs-comment\"&gt;[2]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt; &amp;#61; 10;\n    map&lt;span class=\"hljs-comment\"&gt;[2]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[4]&lt;/span&gt; &amp;#61; 15;\n    map&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[6]&lt;/span&gt; &amp;#61; 2;\n    map&lt;span class=\"hljs-comment\"&gt;[5]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[6]&lt;/span&gt; &amp;#61; 9;\n    map&lt;span class=\"hljs-comment\"&gt;[4]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[5]&lt;/span&gt; &amp;#61; 6;\n    map&lt;span class=\"hljs-comment\"&gt;[3]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[4]&lt;/span&gt; &amp;#61; 11;\n    int temp &amp;#61; INF;\n    for(i &amp;#61; 1 ; i &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;i){\n        for(j &amp;#61; 1 ; j &amp;lt;&amp;#61; n ; &amp;#43;&amp;#43;j){\n            if(map&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61;&amp;#61; temp)\n                map&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt; &amp;#61; map&lt;span class=\"hljs-comment\"&gt;[j]&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;[i]&lt;/span&gt;;\n        }\n    }\n \n    int ans &amp;#61; dijkstra(1,5);  \n \n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,ans);  \n \n    return 0;  \n} \n \n/*    边的数据 \n1 2 7\n1 3 9\n1 6 14\n2 3 10\n2 4 15\n3 6 2\n5 6 9\n4 5 6\n3 4 11\n*/\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qq_34845121/article/details/62056089\" id=\"textarea_1651929968744_1651930069794_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;最短路径之Dijkstra算法 C语言实现_键盘有点滑的博客-CSDN博客_dijkstra算法c语言&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Dijkstra算法&amp;#xff08;单源点路径算法&amp;#xff0c;要求&amp;#xff1a;图中不存在负权值边&amp;#xff09;&amp;#xff1a;步骤&amp;#xff1a;a.  初始时&amp;#xff0c;S只包含源点&amp;#xff0c;即S&amp;#xff1d;{v}&amp;#xff0c;v的距离为0。U包含除v外的其他顶点&amp;#xff0c;即: U&amp;#61;{其余顶点}&amp;#xff0c;若v与U中顶点u有边&amp;#xff0c;则u的距离设置为相应的权值&amp;#xff0c;若u v之间不存在边&amp;#xff0c;则        设置u的距离为无穷大。b.  从U中选取一个距离 v 最小的顶点k&amp;#xff0c;把k&amp;#xff0c;加入S中&amp;#xff08;该选定的距离就是v到k的&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_34845121/article/details/62056089&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html\" id=\"textarea_1651929968744_1651930069794_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;最短路径—Dijkstra算法和Floyd算法 - as_ - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;注意&amp;#xff1a;以下代码 只是描述思路&amp;#xff0c;没有测试过&amp;#xff01;&amp;#xff01; Dijkstra算法 1.定义概览 Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法&amp;#xff0c;用于计算一个节点到其他所有节点的最短路径。主要特点是以起始&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["利用c语音编程关于地铁路线的查询", ["真的想不出来😭    要求不高 求个思路就行", "\n", "选题24、成都地铁查询系统假设成都已经建成了10条地铁形成地铁网络，要求该系统应用在地铁口的查询机上。程序目的是供旅客查询地铁的站点，票价，时间等信息。程序要求利用文件存储这些信息，自动计算出出发地和目的地如何换乘和价格。计算方法有最短路径，时间等选择。在过程中需要考虑到程序的易用性，程序提供站台表供用户选择出发点和目的地。题目提示站台的数据结构建议使用结构体，其中包括票价、站名、下一站，可换乘站台等信息。每条地铁线使用链表的结构来存储，元素为每个站台结构体。用户查询时，可在屏幕上打印每条地铁线的站名等信息使用户一目了然"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考这篇文章&amp;#xff0c;希望对你有帮助&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/Chen_yuazzy/article/details/74081777?utm_source&amp;#61;blogxgwz8\"&gt;【数据结构】旅游景点咨询系统的设计与实现&amp;#xff08;图&amp;#xff0c;DFS&amp;#xff0c;迪杰斯特拉算法&amp;#xff09;_Chen_yuazzy的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这好像是我的作业，好想请教一下大神。", ["题目13 旅游景点咨询系统的设计与实现", "\n\n", "[问题描述]:", "\n\n", "创建一个至少有15个点的有向网表示的某个旅游景点的导游图。顶点代表景点，类型为字符串(例如，泰山导游图:”天地广场门”，“十八盘”，“冯玉祥墓”  桃花峪门”，  中天门”，“南天门”，“玉皇顶”等)，  弧表示两个景点之间可以直达，弧上的权值表示两个景点之间的路程(公里数)，弧上还有到达方法的信息(有步行和索道两种)。建立一个游客咨询系统。", "\n\n", "[基本要求]", "\n\n", "(1)创建图的存储结构。", "\n\n", "(2)  输入两个景点名，就可以得到从一个景点到达另一个景点的所有简单路径、相应路径的路程公里数、行走的方法(每一段是步行，还是坐索道);", "\n\n", "(3)  输入两个景点名,  就可以得到其最短路径，  即:路程最短的行进方法;  如果两者无路径可通，就得出“两景点不可达的信息.", "\n\n", "难点", "\n[实现提示]:", "\n     (1)图的存储、遍历、运算等各种操作;", "\n     (2)  最短路径的计算与算法设计", "\n\n", " "]], "Tag": "算法设计"}
{"Answer": "http://blog.csdn.net/cambridgeacm/article/details/7741330\r\nhttp://blog.sina.com.cn/s/blog_7e5541250100ssue.html", "Konwledge_Point": "最短路径", "Question": ["迷宫问题使用dp怎么求解？             ", ["Description", "\n\n", "定义一个二维数组： ", "\n\n", "int maze[5][5] = {", "\n\n", "0, 1, 0, 0, 0,\n\n0, 1, 0, 1, 0,\n\n0, 0, 0, 0, 0,\n\n0, 1, 1, 1, 0,\n\n0, 0, 0, 1, 0,\n", "\n\n", "};", "\n\n", "它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。", "\nInput", "\n\n", "一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。", "\nOutput", "\n\n", "左上角到右下角的最短路径，格式如样例所示。", "\nSample Input", "\n\n", "0 1 0 0 0", "\n0 1 0 1 0", "\n0 0 0 0 0", "\n0 1 1 1 0", "\n0 0 0 1 0", "\nSample Output", "\n\n", "(0, 0)", "\n(1, 0)", "\n(2, 0)", "\n(2, 1)", "\n(2, 2)", "\n(2, 3)", "\n(2, 4)", "\n(3, 4)", "\n(4, 4)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;java代码我在博文贴了&amp;#xff0c;可以参考一下《如何在64m内存的运行环境下&amp;#xff0c;靠Java完成旅游规划问题》,https://blog.csdn.net/BEYONDMA/article/details/115606833?utm_source&amp;#61;app&amp;amp;app_version&amp;#61;4.5.8&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["Java 和 C 语言在内存使用和速度上有多少差别？", ["题目来源：  ", "https://pintia.cn/problem-sets/15/problems/717", "  ", "\n\n", "7-9 旅游规划 ", "\n\n", " ", "\n\n", "有了一张自驾旅游路线图显示了城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。", "\n\n", "输入格式:", "\n\n", "输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。", "\n\n", "输出格式:", "\n\n", "在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;把报错信息贴出来&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["pta甲级题1111，不知道哪出错了运行不了", ["\n#include<iostream>\nusing namespace std;\n#include<algorithm>\nint n, m;\nint es[", "510", "][", "510", "], et[", "510", "][", "510", "], diss[", "510", "], dist[", "510", "], books[", "510", "], bookt[", "510", "];\n#include<vector>\nvector<int>temppath, path, temptime, timepath, pres[", "510", "], pret[", "510", "];\nint start, jieshu;\nconst int inf = ", "99999999", ";\nint minstime = inf;\nint mincount = inf;\nint minlength = inf;\nint minstime2 = inf;\n//求最短路径的dfs\nvoid dfss(int v) {\n    temppath.push_back(v);\n    if (v == start) {\n        int stime = ", "0", ", length = ", "0", ";\n        for (int i = temppath.size() - ", "1", "; i >= ", "1", "; i--) {\n            int id = temppath[i];\n            int nextid = temppath[i - ", "1", "];\n            length += es[id][nextid];\n            stime += et[id][nextid];\n        }\n        if (length < minlength) {\n            minlength = length;\n            if (stime < minstime) {\n                minstime = stime;\n                path = temppath;\n            }\n        }\n    }\n    for (int i = ", "0", "; i < pres[v].size() - ", "1", "; i++) {\n        dfss(pres[v][i]);\n    }\n    temppath.pop_back();\n}\nvoid dfst(int v) {\n    \n    temptime.push_back(v);\n    if (v == start) {\n        int count = ", "0", ", stime = ", "0", ";\n        for (int i = temppath.size() - ", "1", "; i >= ", "1", "; i--) {\n            int id = temppath[i];\n            int nextid = temppath[i - ", "1", "];\n            count++;\n            stime += et[id][nextid];\n        }\n        if (count < mincount) {\n            mincount = count;\n            if (stime < minstime2) {\n                minstime2 = stime;\n                timepath = temptime;\n            }\n        }\n    }\n    for (int i = ", "0", "; i < pret[v].size() - ", "1", "; i++) {\n        dfst(pret[v][i]);\n    }\n    temptime.pop_back();\n}\nint main()\n{\n    cin >> n, m;\n    fill(es[", "0", "], es[", "0", "] + ", "510", " * ", "510", ", inf);\n    fill(et[", "0", "], et[", "0", "] + ", "510", " * ", "510", ", inf);\n    fill(diss, diss + ", "510", ", inf);\n    fill(dist, dist + ", "510", ", inf);\n    //现在开始输入每个结点之间的距离和时间关系\n    int v1, v2, o, s, t;\n    for (int i = ", "0", "; i < m; i++) {\n        cin >> v1 >> v2 >> o >> s >> t;\n        if (o == ", "1", ")//说明是单行道\n        {\n            es[v1][v2] = s;\n            et[v1][v2] = t;\n        }\n        else if (o == ", "0", ")//说明是双行道\n        {\n            es[v1][v2] = s;\n            es[v2][v1] = s;\n            et[v1][v2] = t;\n            et[v2][v1] = t;\n        }\n    }\n    //现在输出起始点\n    cin >>start >> jieshu;\n    //先从最短路径开始搞起\n    diss[start] = ", "0", ";\n    for (int i = ", "0", "; i < n; i++) {\n        int u = ", "-1", ";\n        int minn = inf;\n        for (int j = ", "0", "; j < n; j++) {\n            if (books[j] == ", "0", " && diss[j] < minn) {\n                minn = diss[j];\n                u = j;\n            }\n        }\n            if (u == ", "-1", ") {\n                break;\n            }\n            books[u] = ", "1", ";\n            for (int v = ", "0", "; v < n; v++) {\n                if (books[v] == ", "0", " && es[u][v] != inf) {\n                    if (diss[v] > diss[u] + es[u][v]) {\n                        diss[v] = diss[u] + es[u][v];\n                        pres[v].clear();\n                        pres[v].push_back(u);\n                    }\n                    else if (diss[v] == diss[u] + es[u][v]) {\n                        pres[v].push_back(u);\n                    }\n                }\n            }\n        }\n    //现在开始dfs求最短路径\n    dfss(jieshu);\n    //现在开始求最短时间\n    dist[start] = ", "0", ";\n    for (int i = ", "0", "; i < n; i++) {\n        int u = ", "-1", ";\n        int minn = inf;\n        for (int j = ", "0", "; j < n; j++) {\n            if (bookt[j] == ", "0", " && dist[j] < minn) {\n                minn = dist[j];\n                u = j;\n            }\n        }\n        if (u == ", "-1", ") {\n            break;\n        }\n        bookt[u] = ", "1", ";\n        for (int v = ", "0", "; v < n; v++) {\n            if (bookt[v] == ", "0", " && et[u][v] != inf) {\n                if (dist[v] > dist[u] + et[u][v]) {\n                    dist[v] = dist[u] + et[u][v];\n                    pret[v].clear();\n                    pret[v].push_back(u);\n                }\n                else if (dist[v] == dist[u] + et[u][v]) {\n                    pret[v].push_back(u);\n                }\n            }\n        }\n    }\n    //现在dfs\n    dfst(jieshu);\n    //现在判断最短路径和最短时间的是不是同一个\n    int index = ", "1", ";\n    for (int i = ", "0", "; i < path.size() - ", "1", "; i++) {\n        if (path[i] == timepath[i]) {\n            index = ", "0", ";\n        }\n    }\n    if (index == ", "1", ")//说明两条路不相等\n    {\n        cout << ", "\"Distance = \"", " << diss[jieshu] << ", "\": \"", " << start;\n        for (int i = path.size() - ", "2", "; i >= ", "0", "; i--) {\n            cout << ", "\"->\"", " << path[i];\n        }\n        cout << endl;\n        cout << ", "\"Time = \"", " << minstime << ", "\": \"", "<<start;\n        for (int i = timepath.size() - ", "2", "; i >= ", "0", "; i--) {\n            cout << ", "\"->\"", " << timepath[i];\n        }\n    }\n    else if (index == ", "0", ") {\n        cout << ", "\"Distance =\"", " << diss[jieshu] << ", "\": \"", " << ", "\"Time = \"", " << minstime << ", "\": \"", "<<start;\n        for (int i = path.size() - ", "2", "; i >= ", "0", "; i--) {\n            cout << ", "\"->\"", " << path[i];\n        }\n\n    }\n    cout << endl;\n    system(", "\"pause\"", ");\n    return ", "0", ";\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;/**\n * &amp;#64;author cuiods\n */\npublic class MazeCell {\n    private int x;\n    private int y;\n    private int step;\n \n    public MazeCell(int x, int y, int step) {\n        this.x &amp;#61; x;\n        this.y &amp;#61; y;\n        this.step &amp;#61; step;\n    }\n \n    public int getX() {\n        return x;\n    }\n \n    public void setX(int x) {\n        this.x &amp;#61; x;\n    }\n \n    public int getY() {\n        return y;\n    }\n \n    public void setY(int y) {\n        this.y &amp;#61; y;\n    }\n \n    public int getStep() {\n        return step;\n    }\n \n    public void setStep(int step) {\n        this.step &amp;#61; step;\n    }\n}\n\nimport java.util.Scanner;\nimport java.util.Stack;\n \n/**\n * 迷宫类\n * 找到所有到达终点的路径\n * &amp;#64;author cuiods\n */\npublic class Maze {\n \n    /**\n     * 临时保存路径\n     */\n    private Stack&amp;lt;MazeCell&amp;gt; pathStack &amp;#61; new Stack&amp;lt;&amp;gt;();\n    /**\n     * 保存迷宫\n     */\n    private int[][] maze;\n    private boolean flag &amp;#61; false;\n    private MazeCell startCell;\n    private MazeCell endCell;\n \n    public Maze() {\n        initialMaze();\n    }\n \n    /**\n     * 寻找路径\n     */\n    public void findPath() {\n        assert flag;\n        processCell(startCell.getX(), startCell.getY(), startCell.getStep());\n    }\n \n    private void processCell(int x, int y, int step) {\n        if (x &amp;#61;&amp;#61; endCell.getX() &amp;amp;&amp;amp; y &amp;#61;&amp;#61; endCell.getY()) {\n            pathStack.pop();\n            printPath();\n            System.out.println(&amp;#34;(&amp;#34;&amp;#43;endCell.getX()&amp;#43;&amp;#34;,&amp;#34;&amp;#43;endCell.getY()&amp;#43;&amp;#34;)&amp;#34;);\n            return;\n        }\n        test(x,y-1,step&amp;#43;1);\n        test(x,y&amp;#43;1,step&amp;#43;1);\n        test(x-1,y,step&amp;#43;1);\n        test(x&amp;#43;1,y,step&amp;#43;1);\n    }\n \n    private void test(int x, int y, int step) {\n        if (canGo(x,y)){\n            MazeCell mazeCell &amp;#61; new MazeCell(x,y,step);\n            insertToPath(mazeCell);\n            processCell(x,y,step);\n        }\n    }\n \n    private void printPath(){\n        for (int i &amp;#61; 0; i &amp;lt; pathStack.size(); i&amp;#43;&amp;#43;) {\n            MazeCell cell &amp;#61; pathStack.get(i);\n            System.out.print(&amp;#34;(&amp;#34;&amp;#43;cell.getX()&amp;#43;&amp;#34;,&amp;#34;&amp;#43;cell.getY()&amp;#43;&amp;#34;)-&amp;gt;&amp;#34;);\n        }\n    }\n \n    private void insertToPath(MazeCell mazeCell) {\n        while (pathStack.peek().getStep() &amp;gt;&amp;#61; mazeCell.getStep()) {\n            pathStack.pop();\n        }\n        pathStack.push(mazeCell);\n    }\n \n    private boolean canGo(int x, int y) {\n        if (maze[x][y]&amp;#61;&amp;#61;1) {\n            return false;\n        }\n        for (int i &amp;#61; 0; i &amp;lt; pathStack.size(); i&amp;#43;&amp;#43;) {\n            MazeCell mazeCell &amp;#61; pathStack.get(i);\n            if (mazeCell.getX()&amp;#61;&amp;#61;x &amp;amp;&amp;amp; mazeCell.getY()&amp;#61;&amp;#61;y) {\n                return false;\n            }\n        }\n        return true;\n    }\n \n    private void initialMaze() {\n        int column;\n        int row;\n        Scanner scanner &amp;#61; new Scanner(System.in);\n        int temp &amp;#61; 0;\n        do {\n            System.out.println(&amp;#34;请输入迷宫行数(&amp;gt;0)&amp;#xff1a;&amp;#34;);\n            temp &amp;#61; scanner.nextInt();\n        } while (temp&amp;lt;&amp;#61;0);\n        row &amp;#61; temp;\n        do {\n            System.out.println(&amp;#34;请输入迷宫列数(&amp;gt;0)&amp;#xff1a;&amp;#34;);\n            temp &amp;#61; scanner.nextInt();\n        } while (temp&amp;lt;&amp;#61;0);\n        column &amp;#61; temp;\n        maze &amp;#61; new int[row&amp;#43;2][column&amp;#43;2];\n        System.out.println(&amp;#34;请输入迷宫&amp;#xff08;1为墙&amp;#xff0c;0为路&amp;#xff0c;-1为起点&amp;#xff0c;2为终点&amp;#xff09;:&amp;#34;);\n        for (int i &amp;#61; 0; i &amp;lt; column&amp;#43;2; i&amp;#43;&amp;#43;) {\n            maze[0][i] &amp;#61; 1;\n        }\n        for (int i &amp;#61; 1; i &amp;lt; row&amp;#43;1; i&amp;#43;&amp;#43;) {\n            maze[i][0] &amp;#61; 1;\n            for (int j &amp;#61; 1; j &amp;lt; column&amp;#43;1; j&amp;#43;&amp;#43;) {\n                temp &amp;#61; scanner.nextInt();\n                switch (temp) {\n                    case -1:\n                        startCell &amp;#61; new MazeCell(i,j,0);\n                        maze[i][j] &amp;#61; temp;\n                        pathStack.push(startCell);\n                        break;\n                    case 2:endCell &amp;#61; new MazeCell(i,j,-1);\n                    case 0:\n                    case 1:maze[i][j] &amp;#61; temp;break;\n                    default:\n                        System.out.println(&amp;#34;输入不符合要求T T&amp;#34;);\n                        return;\n                }\n            }\n            maze[i][column&amp;#43;1] &amp;#61; 1;\n        }\n        for (int i &amp;#61; 0; i &amp;lt; column&amp;#43;2; i&amp;#43;&amp;#43;) {\n            maze[row&amp;#43;1][i] &amp;#61; 1;\n        }\n        if (startCell!&amp;#61;null &amp;amp;&amp;amp; endCell!&amp;#61;null) {\n            flag &amp;#61; true;\n            System.out.println(&amp;#34;输入成功:)&amp;#34;);\n        } else {\n            System.out.println(&amp;#34;至少要有一个起点和终点:(&amp;#34;);\n        }\n    }\n}\n\n/** 测试类\n * &amp;#64;author csdn-zhangteacher\n * test main\n */\npublic class Main {\n \n    public static void main(String[] args) {\n        Maze maze &amp;#61; new Maze();\n        maze.findPath();\n    }\n}&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["java实现迷宫问题", ["给定一个迷宫，阵列中每个元素用0或1表示。0表示可以走，1表示不可走。给定入口位置后，用程序找到出口。输出从入口到出口的路径，路径中每一个节点位置用二维数组（左上角为0,0）表示，并找出最短路径", "\n\n", "以下面4*4的迷宫举例，入口为(0,1)", "\n\n", "1011", "\n\n", "1001", "\n\n", "1100", "\n\n", "1111", "\n\n", "输出应该为：", "\n\n", "(0,1)", "\n\n", "(1,1)", "\n\n", "(1,2)", "\n\n", "(2,2)", "\n\n", "(2,3)"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;cbcbbcdb&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["计算机网络一些相关问题", ["1.NAT重载如何提供一对多的地址转换？", "（选择一个）", "A.它使用了一个地址池", "B.它将IPV4地址转换为未使用的IPv6地址", "C. 它为每个会话分配一个唯一的TCP/UDP端口", "D. 它使用虚拟MAC地址和虚拟IP地址", "IPV4中支持哪些IPV6特性，但不常用？（选择一个）", "A. 单播", "B. 多点传送", "C. anycast", "D. 广播", "在哪种CLI配置模式下，您可以配置设备的主机名？（选择一个）", "A. 行方式", "B. 接口方式", "C. 全局方式", "D. 路由器模式", "4.关于跨树根桥选举的说法是正确的？（选择一个）", "A.它总是是自动执行的", "B.每个VLAN都必须有自己的根桥接器", "C. 每个VLAN都必须使用相同的根桥接器", "D. 每个根网桥必须停留在同一根交换机上", "您可以输入哪个命令来验证是否已建立到远程设备的BGP连接？", "A.显示ipbgp摘要", "B.显示ip社区列表", "C.显示ipbgp路径", "D.显示ip路由", "哪个项目代表标准的IPACL？（选择一个）", "A. 访问列表110允许任何任何内容", "B. 访问列表50拒绝192.168.1.10.0.0.255", "C. 访问列表101拒绝tvp任何主机192.168.1.1", "D. 访问列表2500拒绝tcp任何主机192.168.1.1eq22", "哪些特征代表了链路状态路由协议？（选择两个）", "A. 提供了整个拓扑结构的通用视图", "B. 与邻居交换路由表", "C. 计算最短路径", "D. 利用事件触发的更新", "E. 利用频繁的定期更新", "您可以使用哪个实用程序来确定交换机是否可以发送回声请求和回复？（选择一个）", "A. 平", "B. traceroute", "C. ssh", "D. 电视网"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff0c;以下是一个解决这个问题的Python程序&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; sys\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; collections &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; deque\n\n&lt;span class=\"hljs-comment\"&gt;# 有效的骑士移动&lt;/span&gt;\nMOVES &amp;#61; [(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), (-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, -&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)]\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;to_coord&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;square&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;将棋盘位置转换为坐标&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    col, row &amp;#61; square[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], square[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n    x &amp;#61; &lt;span class=\"hljs-built_in\"&gt;ord&lt;/span&gt;(col) - &lt;span class=\"hljs-built_in\"&gt;ord&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)\n    y &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(row) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; x, y\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;to_square&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;coord&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;将坐标转换为棋盘位置&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    x, y &amp;#61; coord\n    col &amp;#61; &lt;span class=\"hljs-built_in\"&gt;chr&lt;/span&gt;(x &amp;#43; &lt;span class=\"hljs-built_in\"&gt;ord&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;))\n    row &amp;#61; &lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;(y &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; col &amp;#43; row\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;bfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;start, end&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;使用广度优先搜索查找从起点到终点的最短骑士路径&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    start_coord &amp;#61; to_coord(start)\n    end_coord &amp;#61; to_coord(end)\n    queue &amp;#61; deque([(start_coord, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)])\n    visited &amp;#61; &lt;span class=\"hljs-built_in\"&gt;set&lt;/span&gt;([start_coord])\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; queue:\n        coord, moves &amp;#61; queue.popleft()\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; coord &amp;#61;&amp;#61; end_coord:\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; moves\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; dx, dy &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; MOVES:\n            x, y &amp;#61; coord[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; dx, coord[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#43; dy\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; x &amp;lt; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;lt;&amp;#61; y &amp;lt; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; (x, y) &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; visited:\n                visited.add((x, y))\n                queue.append(((x, y), moves&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;))\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;# 读取输入文件&lt;/span&gt;\ninput_file &amp;#61; sys.stdin\nline &amp;#61; input_file.readline().strip()\na, b &amp;#61; line.split()\n\n&lt;span class=\"hljs-comment\"&gt;# 查找最短骑士路径&lt;/span&gt;\nn &amp;#61; bfs(a, b)\n\n&lt;span class=\"hljs-comment\"&gt;# 输出结果&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;To get from {} to {} takes {} knight moves.&amp;#34;&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;format&lt;/span&gt;(a, b, n))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;该程序首先定义了一个有效的骑士移动列表&amp;#xff0c;然后定义了两个帮助函数&amp;#xff0c;一个将棋盘位置转换为坐标&amp;#xff0c;另一个将坐标转换为棋盘位置。接下来&amp;#xff0c;它使用广度优先搜索算法来查找从起点到终点的最短骑士路径&amp;#xff0c;并返回路径长度。最后&amp;#xff0c;它将结果输出到标准输出流。&lt;/p&gt;\n&lt;p&gt;程序的输入是一个包含两个棋盘位置的字符串的文件。程序可以使用以下命令将其运行&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;python&lt;/span&gt; knight_moves.&lt;span class=\"hljs-keyword\"&gt;py&lt;/span&gt; &amp;lt; &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;.txt\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中&amp;#xff0c;input.txt是包含输入的文本文件。程序将输出结果到标准输出流。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["python问题，详细请看问题", ["你的一个朋友正在研究旅行骑士问题(TKP)，在这个问题中，你要找到最短的骑士移动封闭行程，该行程恰好访问棋盘上给定的n个方格中的每个方格一次。他认为问题中最困难的部分是确定在两个给定方格之间最小的骑士移动次数，一旦你完成了这一任务，找到旅程就变得很容易了。你当然知道，反之亦然。所以你让他写一个程序来解决“困难”的部分。你的工作是编写一个程序，将两个方块a和b作为输入，然后确定从a到b的最短路径上的骑士移动次数。", "\n", "输入", "一个输入文件由一行包含两个空格分隔的方格组成。", "方格是由字母(A ..h)和数字(1..8)组成的字符串，前者表示棋盘上的列，后者表示棋盘上的行。", "\n", "输出", "打印一行  ‘To get from xx to yy takes n knight moves.’.", "例子", "\n", "原题内容（英文）", "A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the", "shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard", "exactly once. He thinks that the most difficult part of the problem is determining the smallest number of", "knight moves between two given squares and that, once you have accomplished this, finding the tour", "would be easy. Of course you know that it is vice versa. So you offer him to write a program that solves", "the ”difficult” part. Your job is to write a program that takes two squares a and b as input and then", "determines the number of knight moves on a shortest route from a to b.", "\n", "Input", "• An input file consists of one line containing two squares separated by one space.", "• A square is a string consisting of a letter (a..h) representing the column and a digit (1..8)", "representing the row on the chessboard. ", "\n", "Output", "Print one line saying ‘To get from xx to yy takes n knight moves.’."]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;如何调用函数&amp;#xff1f;你定义好了参数列表中是两个整形变量&amp;#xff0c;你调用的时候往括号里放实际的变量或者数值呀&amp;#xff0c;怎么还在调用的时候在括号里定义变量呢&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这个Display函数该怎么调用", ["下面Display函数调用为什么会出错，是括号里的参数不对嘛，正确的写法是什么", "\n", "\n\nvoid Display(int sight1,int sight2){\n   int a,b,c,d,", "q", "=0;\n    ", "a", "=sight2; \n    ", "if", "(a!=sight1)\n    {\n        printf(", "\"\\n\\t从%s到%s的最短路径是\"", ",G.vex[sight1].sight,G.vex[sight2].sight);\n        printf(", "\"\\t(最短距离为%dm.)\\n\\n\\t\"", ",D[a]); \n        printf(", "\"\\t%s\"", ",G.vex[sight1].sight); \n        ", "d", "=sight1;\n        ", "for", "(", "c", "=0;c<NUM;++c)\n        {\n            P[a][sight1]=0;\n            ", "for", "(", "b", "=0;b<NUM;b++)\n            {\n                ", "if", "(G.arcs[d][b]<32767&&P[a][b])\n                {\n                    printf(", "\"-->%s\"", ",G.vex[b].sight); \n                    ", "q", "=q+1;\n                    P[a][b]=0;\n                    ", "d", "=b; \n                    ", "if", "(q%", "8", "==0) printf(", "\"\\n\"", ");\n                }\n            }\n        }\n    }\n}\n", "\n", "case", " ", "2", ":\n        ", "do", "\n        {\n            system(", "\"cls\"", ");\n            cu=UMenu();\n            ", "switch", "(cu)\n            {\n            ", "case", " ", "1", ":Info(); ", "break", "; \n            ", "case", " ", "2", ":Display(", "int", " sight1,", "int", " sight2); ", "break", ";\n            ", "case", " ", "3", ":", "Map", "(); ", "break", ";\n            }getch();\n        }", "while", "(cu!=", "4", ");\n        ", "break", ";\n    }\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你这加了int以后&amp;#xff0c;这个局部变量i就只在循环里使用&amp;#xff0c;循环结束就销毁&amp;#xff0c;这个i和外面的全局变量i不是同一个&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["关于把全局变量改成局部变量结果出现了问题", ["#include<bits/stdc++.h>", "using namespace std;", "int a[1005][1005],d[1005],i,j;", "const int INF=1e9;", "void chushi(int n)//邻接矩阵初始化", "{", "    for(i=1;i<=n;i++)", "    {", "        for(j=1;j<=n;j++)", "        {", "            if(i!=j)", "            a[i][j]=INF;//求最短要初始化为无限大", "        }", "    }", "}", "void dij(int n)//单源最短路径", "{", "    bool f[1005]={0};", "    f[1]=1;", "    int v;", "    for(i=1;i<n;i++)", "    {", "        int min=INF;", "        for(j=1;j<=n;j++)", "        {", "            if(!f[j]&&min>d[j])//找未标记中最小的", "            {", "                min=d[j];", "                v=j;", "            }", "        }", "        f[v]=1;//标记", "        for(j=1;j<=n;j++)", "        {", "            if(!f[j]&&a[v][j]+d[v]<d[j])//更新路径长度", "            {", "                d[j]=a[v][j]+d[v];", "            }", "        }", "    }", "}", "void over(int n)//翻转", "{", "    for(i=1;i<=n;i++)", "    {", "        for(j=i+1;j<=n;j++)", "        {", "            int t=0;", "            t=a[i][j];", "            a[i][j]=a[j][i];", "            a[j][i]=t;", "        }", "    }", "}", "int main()", "{", "    int n,m,x,y,z;", "    cin>>n>>m;", "    chushi(n);", "    for(i=1;i<=m;i++)", "    {", "        cin>>x>>y>>z;", "        a[x][y]=min(a[x][y],z);//避坑：防止同一条路多次输入！", "    }", "    for(i=1;i<=n;i++)", "    {", "        d[i]=a[1][i];//路径长度初始化", "    }", "    dij(n);", "    int ans;", "    for(i=1;i<=n;i++)", "    {", "        ans+=d[i];", "    }", "    over(n);//翻转", "    for(i=1;i<=n;i++)//路径长度初始化", "    {", "        d[i]=a[1][i];", "    }", "    dij(n);", "    for(i=1;i<=n;i++)", "    {", "        ans+=d[i];//求和", "    }", "    cout<<ans<<endl;//华丽地输出", "    return 0;", "}", "输出", "\n", "但如果在i前面加个int，", "\n", "就变成了", "\n", "不过就是把一个i变成了局部变量，其他的也没变啊，为什么最终结果变了？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;封装?你要封装成类吗&amp;#xff0c;如果是&amp;#xff0c;那可能绝大部分代码需要重构&amp;#xff0c;因为你这是面向过程的代码&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["这段函数如何进行封装？", ["\n", "#include<iostream>", "\n", "#include<stack>", "\n", "#include<stdio.h>", "\n", "#include<time.h>", "\n", "#include<string>", "\n", "#include <stdlib.h>", "\nusing namespace std;\ntypedef struct\n{\n    ", "int", " ", "x", ",", "y", ";\n}item;\n\ntypedef struct\n{\n    ", "int", " ", "x", ",", "y", ",d;\n}Datetype;\ntypedef stack<Datetype> stack_int;\nvoid path (", "int", " **maze,", "int", ",", "int", ",", "int", ",", "int", ");\nvoid printpath();\n", "#define NUM 100    //队列大小；", "\ntypedef struct{\n    ", "int", " ", "x", ",", "y", ";  ", "//", "所到点的坐标；\n    ", "int", " pre;  ", "//", "前驱点的下标；\n}SqType;  ", "//", "队列；\n", "int", " front,rear;  ", "//", "队首指针与队尾指针；\nvoid printpath(SqType s", "q[]", ",", "int", "){", "//", "打印路径\n    ", "int", " i;\n    i=rear; \n    ", "do", "{\n        cout<<", "\"(\"", "<<s", "q[i]", ".x<<", "\",\"", "<<s", "q[i]", ".y<<", "\")<--\"", ";\n        i=s", "q[i]", ".pre;   ", "//", "回溯；\n    }", "while", "(i!=-", "1", ");\n}\nvoid restore(", "int", " **maze,", "int", " m,", "int", " n){", "//", "恢复迷宫\n    ", "for", "(", "int", " i=", "1", ";i<=m;i++){\n        ", "for", "(", "int", " j=", "1", ";j<=n;j++){\n            ", "if", "(maze[i][j]==-", "1", ")\n                maze[i][j]=", "0", ";\n        }\n    }\n}\n", "int", " path1(", "int", " **maze,", "int", " m,", "int", " n,", "int", " c,", "int", " d,", "int", " x1,", "int", " y1)//最短路径\n{  ", "//m", ",n为迷宫的长和宽，c，d为迷宫入口坐标，x1，y1为迷宫出口坐标；maze为迷宫；\n    item move[", "8", "]={{", "0", ",", "1", "},{", "1", ",", "1", "},{", "1", ",", "0", "},{", "1", ",-", "1", "},{", "0", ",-", "1", "},{-", "1", ",-", "1", "},{-", "1", ",", "0", "},{-", "1", ",", "1", "}};  ", "//", "坐标增量数组；\n    SqType s", "q[NUM]", ";\n    ", "int", " ", "x", ",", "y", ",i,j,v;  \n    front=rear=", "0", ";\n    s", "q[0]", ".x=c;\n    s", "q[0]", ".y=d;\n    s", "q[0]", ".pre=-", "1", "; \n    ", "if", "(maze[c][d]==", "0", ")\n       maze[c][d]=-", "1", ";", "//", "入口点入队；\n    ", "else", " ", "goto", " G;\n    ", "while", "(front<=rear){     ", "//", "队列不为空\n        ", "x", "=s", "q[front]", ".x;\n        ", "y", "=s", "q[front]", ".y;\n        ", "for", "(v=", "0", ";v<", "8", ";v++){\n            i=", "x", "+move[v].x;\n            j=", "y", "+move[v].y;\n            ", "if", "(maze[i][j]==", "0", "){\n                rear++;\n                s", "q[rear]", ".x=i;\n                s", "q[rear]", ".y=j;\n                s", "q[rear]", ".pre=front;\n                maze[i][j]=-", "1", "; ", "//", "访问过的坐标点，入队；\n            }\n            ", "if", "(i==x1&&j==y1){\n                cout<<", "\"最短路径为：\"", "<<endl;\n                printpath(sq,rear);  ", "//", "输出路径；\n                restore(maze,m,n);    ", "//", "恢复迷宫；\n                ", "return", " ", "1", "; \n            }\n            }   //", "for", " v;\n            front++;   ", "//", "当前点搜索完，取下一个点搜索\n        }   //", "while", "\nG:cout<<", "\"无路径。\"", "<<endl;\n        ", "return", " ", "0", ";\n    }\nvoid path(", "int", " **maze,", "int", " a,", "int", " b,", "int", " m,", "int", " n)\n{\n    item move[", "8", "]={{", "0", ",", "1", "},{", "1", ",", "1", "},{", "1", ",", "0", "},{", "1", ",-", "1", "},{", "0", ",-", "1", "},{-", "1", ",-", "1", "},{-", "1", ",", "0", "},{-", "1", ",", "1", "}};\n    stack_int st;\n    Datetype temp;\n    ", "int", " ", "x", ",", "y", ",d,i,j;\n    ", "if", "(maze[a][b]==", "1", "){cout<<", "\"进口输入有误。\"", ";", "return", ";}\n    temp.x=a;temp.y=b;temp.d=-", "1", "; ", "//", "初始化入口点坐标及方向；\n    st.push(temp);\n    ", "while", "(!st.empty())\n    {\n        temp=st.top();\n        st.pop();\n        ", "x", "=temp.x;", "y", "=temp.y;d=temp.d+", "1", ";\n        ", "while", "(d<", "8", ")\n        {\n            i=", "x", "+move[d].x;j=", "y", "+move[d].y;\n            ", "if", "(maze[i][j]==", "0", ")  //该点可到达；\n            {\n                temp.x=", "x", ";temp.y=", "y", ";temp.d=d; ", "//", "坐标及方向；\n                st.push(temp); ", "//", "坐标及方向入栈；\n                ", "x", "=i;", "y", "=j;\n                maze[", "x", "][", "y", "]=-", "1", ";", "//", "到达新点；\n                ", "if", "(", "x", "==m && ", "y", "==n)\n                {\n                    cout<<", "\" 迷宫路径为:\"", "<<endl;\n                    cout<<", "\"(\"", "<<m<<", "\",\"", "<<n<<", "\")<---\"", ";\n                    Datetype t;\n                    ", "while", "(!st.empty())\n                    {\n                        t=st.top();\n                        cout<<", "\"(\"", "<<t.x<<", "\",\"", "<<t.y<<", "\")<---\"", ";\n                        st.pop();\n                    }    //输出路径；\n                    cout<<endl;\n                    ", "return", " ;  ", "//", "到达出口；\n                }\n                ", "else", " d=", "0", ";   ", "//", "重新初始化方向；\n            }\n            ", "else", " d++;    ", "//", "改变方向；\n        }\n    }\n    cout<<", "\"对不起，无法找到出口.\"", ";\n    ", "return", ";   ", "//", "迷宫无路；\n}\n                    \nvoid printpath()\n{\n    ", "int", " m,n,i,j,l,c,d;\n    string s;\n    cout<<", "\" 请输入迷宫的行数列数如:(m n)\"", "<<endl;\n    cin>>m>>n;\n    ", "int", " **maze=new ", "int", "*[m+", "2", "];\n    ", "for", "(i=", "0", ";i<=m+", "1", ";i++)\n        maze[i]=new ", "int", "[n+", "2", "];", "//", "申请迷宫的空间；\n    ", "for", "(i=", "0", ";i<=m+", "1", ";i++)   \n        maze[i][", "0", "]=", "1", ";\n    ", "for", "(i=", "0", ";i<=n+", "1", ";i++)\n        maze[", "0", "][i]=", "1", ";\n    ", "for", "(i=", "0", ";i<=m+", "1", ";i++)\n        maze[i][n+", "1", "]=", "1", ";\n    ", "for", "(i=", "0", ";i<=n+", "1", ";i++)\n        maze[m+", "1", "][i]=", "1", ";  ", "//", "建立迷宫周围的墙；\n    cout<<", "\"1、采用创建好的迷宫; 2、自己创建迷宫（其他输入按'2'处理）\"", "<<endl;\n    cin>>s;\n    ", "if", "(s==", "\"1\"", ")\n    {\n        ", "srand", "(", "time", "(", "0", "));  ", "//", "系统时间随机函数；\n        ", "for", "(i=", "1", ";i<=m;i++)\n            ", "for", "(j=", "1", ";j<=n;j++)\n                maze[i][j]=", "rand", "()%2;  ", "//", "随机赋值\n        maze[", "1", "][", "1", "]=", "0", ";   ", "//", "(", "1", ",", "1", ")点为可通过点；\n        maze[m][n]=", "0", ";   ", "//", "(m,n)点为可通过点；\n    }\n    ", "else", " \n    {\n        cout<<", "\"请输入迷宫：\"", "<<m<<", "\"行\"", "<<n<<", "\"列\"", "<<", "\", 输入必须为'0' 或 '1'；\"", "<<endl;\n        ", "for", "(i=", "1", ";i<=m;i++)     //输入第i行迷宫的构造；\n            ", "for", "(j=", "1", ";j<=n;j++)     //输入第j列迷宫的结构；\n            {\n                cin>>maze[i][j];\n              A:", "if", "(maze[i][j]!=", "0", " && maze[i][j]!=", "1", ")\n                {\n                    cout<<", "\"请再次输入：\"", ";\n                    cin>>maze[i][j];", "goto", " A;  ", "//", "判错；\n                }\n            }    \n    }\n    cout<<", "\"迷宫如下：\"", "<<endl; ", "//", "显示用户输入的迷宫；\n            ", "for", "(i=", "0", ";i<=m+", "1", ";i++)\n            {\n                ", "for", "(j=", "0", ";j<=n+", "1", ";j++)\n                 cout<<maze[i][j]<<", "\"　\"", ";\n                cout<<endl;\n            }\n          H:cout<<", "\"请输入迷宫入口(a,b),出口(c,d)：\"", ";\n            cin>>i>>j>>c>>d;\n    path(maze,i,j,c,d);    ", "//", "调用路径函数，输出路径；\n    cout<<endl;  ", "//", "格式设置；\n    restore(maze,m,n);   ", "//", "恢复迷宫；\n    path1(maze,m,n,i,j,c,d);  ", "//", "输出最短路径；\n    cout<<endl;  ", "//", "格式设置；\n    cout<<", "\"1、寻找其他入口与出口；2、退出此迷宫；\"", ";\n    cin>>l;  \n    ", "if", "(l==", "1", "){\n        restore(maze,m,n);  ", "//", "恢复迷宫；\n        ", "goto", " H;\n    }\n    ", "else", " ", "return", ";   ", "//", "跳出此函数；\n}\n", "int", " main()\n{\n    string s=", "\"Y\"", ";\n    ", "do", "\n    {\n        cout<<", "\"--------------------------欢迎到达迷宫界面--------------------------\\n\"", ";\n        printpath();\n        cout<<endl;\n        cout<<", "\"\\n 是否继续？'Y' 或'N'（输入其他操作按'N'）\"", "<<endl;\n        cin>>s;\n    }", "while", " (s==", "\"Y\"", "||s==", "\"y\"", ");\n    ", "system", "(", "\"pause\"", ");\n}\n"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇文章讲的很详细&amp;#xff0c;请看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/zzq0523/article/details/104868360\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;最短路之Dijkstra&amp;#43;堆优化&amp;#xff08;单源最短路&amp;#xff09;&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "最短路径", "Question": ["利用dijkstra求解最短路计数出现问题", ["利用dijkstra在枚举最短路的过程中顺便更新路径数", "[原题链接]（", "https://www.luogu.com.cn/problem/P1144", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<cstring>", "\n", "#", "include", "<queue>", "\n", "using", " ", "namespace", " std;\n\n", "typedef", " ", "long", " ", "long", " LL;\n", "const", " ", "int", " N=", "1e6", ";\nLL h[N],e[N],ne[N],w[N],idx;  ", "// 邻接表存储", "\n", "int", " n,m;  ", "// n个顶点,m条边", "\nLL dist[N]; ", "// 每个点到1的距离", "\nLL ans[N];  ", "// 标记起点到每个点的路径条数", "\n", "bool", " st[N];  ", "// 标记是否在点集内", "\n\n", "#", "define", " x first", "\n", "#", "define", " y second", "\n", "typedef", " pair<", "int", ",", "int", ">PII;\n\n", "void", " ", "add", "(", "int", " a,", "int", " b)", "\n", "{\n    e[idx]=b,ne[idx]=h[a],w[idx]=", "1", ",h[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dist,", "0x3f", ",", "sizeof", " dist);\n    dist[", "1", "]=", "0", ";ans[", "1", "]=", "1", ";\n    priority_queue<PII,vector<PII>,greater<PII>>heap;\n    heap.", "push", "({", "0", ",", "1", "});\n    \n    ", "while", "(heap.", "size", "())\n    {\n        ", "auto", " t=heap.", "top", "();\n        heap.", "pop", "();\n        ", "int", " ver=t.y,distance=t.x;\n        ", "if", "(st[ver]) ", "continue", ";\n        st[ver]=", "true", ";\n        ", "for", "(", "int", " i=h[ver];i!=", "-1", ";i=ne[i])\n        {\n            ", "int", " j=e[i];\n            ", "if", "(dist[j]>distance+w[i])  ", "// 比之前的距离小，到达该点的最短路径数修改为能到ver的数量", "\n            {\n                ans[j]=ans[ver];\n                dist[j]=distance+w[i];\n                heap.", "push", "({dist[j],j});\n            }\n          ", "else", " ", "if", "(dist[j]==dist[ver]+w[i]) ans[j]+=ans[ver];\n        }\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n   ", "memset", "(h,", "-1", ",", "sizeof", " h);\n   ", "scanf", "(", "\"%d%d\"", ",&n,&m);\n   ", "while", "(m--)\n   {\n    ", "int", " a,b;\n    ", "scanf", "(", "\"%d%d\"", ",&a,&b);\n    ", "add", "(a,b);", "add", "(b,a);\n   }\n   ", "dijkstra", "();\n   ", "for", "(", "int", " i=", "1", ";i<=n;i++)\n    cout<<ans[i]%", "100003", "<<endl;\n   ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路", "\n", "如果从起点到t有ans[t]条边，从t到j有x条边，那么从起点到j就有两者相乘条边，也可以相加x次，就是每找到一条从t到j的边就加ans[t]", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;看了一下。。这个博主代码完全没放全。。我说一下解决方案&lt;/p&gt;\n\n&lt;p&gt;按照你当前的代码&amp;#xff0c;把16行的import matrix去掉&amp;#xff0c;该博主本身是将这份代码分成两份写的&amp;#xff0c;第一份是matrix.py且代码没给全&amp;#xff0c;比如tran_m方法&lt;/p&gt;\n\n&lt;p&gt;然后将59行开始改为&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;data&amp;#61;matrix(address)\nfloyd(data)&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;按该博主意思&amp;#xff0c;tran_m仅用于数据处理&amp;#xff0c;不影响数据输入floyd方法&lt;/p&gt;\n\n&lt;p&gt;运行结果&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"890\" src=\"https://img-ask.csdnimg.cn/upload/1622807624199.png\" width=\"677\" /&gt;&lt;img alt=\"\" height=\"890\" src=\"https://img-ask.csdnimg.cn/upload/1622807632250.png\" width=\"677\" /&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["module matrix has no attribute matrix", ["使用弗洛伊德算法模拟最短路径时出现module matrix has no attribute matrix", "\n\n", "\n", "import xlrd\nimport sys\n\ndef matrix(address):                           #读取excel生成邻接矩阵\n    wb = xlrd.open_workbook(address)\n    sheet1 = wb.sheet_by_name('邻接矩阵_距离')\n    L = []\n    for i in range(1,51):\n        a = sheet1.row_values(i)\n        a.remove(a[0])\n        L.append([int(x) for x in a])\n    # print(L)\n    return L\n\nfrom pylab import *\nimport matrix\n\n\ndef floyd(d):\n    D=d\n    lengthD = len(D)                    #邻接矩阵大小\n    p = list(range(lengthD))\n    P = []\n    for i in range(lengthD):\n        P.append(p)\n    P = array(P)\n    for k in range(lengthD):\n        for i in range(lengthD):\n            for j in range(lengthD):\n                if(D[i][j] >D[i][k]+D[j][k]):         #两个顶点直接较小的间接路径替换较大的直接路径\n                    P[i][j] = P[i][k]                 #记录新路径的前驱\n                    D[i][j] = D[i][k]+D[j][k]\n    print('各个顶点的最短路径:')\n    for i in range(lengthD):\n        for j in range(i+1,lengthD):\n            print('v%d' % (i+1) + '--' + 'v%d' % (j+1) + '\\t' + 'dist_min:' + '\\t' + str(D[i][j]) + '\\t' + 'path:'+'v%d'%(i+1),end='' )\n            temp=P[i][j]\n            while (temp!=j):\n                print('--'+'v%d'%(temp+1),end='')\n                temp=P[temp][j]\n            print('--'+'v%d'%(j+1))\n    print('P矩阵:')\n    print(P)\n    print('D矩阵:')\n    for i in D:\n        print(i)\n    return D\n\n\nif __name__ == '__main__':\n    chararray = ['1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49','50']\n    L=[]\n    for i in range(1,len(chararray)+1):\n        L.append('v%d'%i)\n    Dict=dict(zip(L,chararray))\n    print('各点对应关系：')\n    print(Dict)\n    address = 'C:\\\\Users\\11573\\Desktop\\python\\数据及代码\\数据/邻接矩阵.xlsx'\n    data=matrix.matrix(address)\n    d=matrix.tran_m(data)\n    floyd(d)\n\n————————————————\n版权声明：本文为CSDN博主「heavenmark」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/heavenmark/article/details/82794565", "\n\n", "源代码来自与同站博主heavenmark"]], "Tag": "算法设计"}
{"Answer": "网友的相似疑问：https://stackoverflow.com/questions/41479316/maven-dependency-management-the-first-declaration-wins，但是没人去回答他....\r\n\r\n其实这个是 dependency 插件的功能，默认采用的是复写的策略，当构建声明处于同一 pom 中，且 groupid 和 artifactId 一致时，以**最新声明为准**，后面的覆盖前面的。注意这里没涉及到依赖调解的功能。我的理解是依赖调解只发生于构建来自不同 pom 时，而此时构建声明处于同一 pom，故不会触发依赖调解。\r\n\r\n参考：\r\nhttps://maven.apache.org/plugins/maven-dependency-plugin/usage.html\r\nhttps://juejin.im/post/5cbf27a95188250a505c2cd2#heading-18\r\nhttps://stackoverflow.com/questions/42113542/figuring-out-duplicate-dependency-in-war", "Konwledge_Point": "最短路径", "Question": ["Maven 依赖调解原则失效？", ["都知道 Maven 在出现依赖版本冲突问题时，会用最短路径原则和第一声明原则来解决冲突。但在自己电脑上引入如下依赖，却产生了与期望违背的效果：", "\n\n", "<dependency>\n  <groupId>commons-io</groupId>\n  <artifactId>commons-io</artifactId>\n  <version>2.6</version>\n</dependency>\n\n<dependency>\n  <groupId>commons-io</groupId>\n  <artifactId>commons-io</artifactId>\n  <version>2.4</version>\n</dependency>\n", "\n\n", "按照两个原则的话，最终引入的应该是版本为 2.6 的包，但实际却引入了版本为 2.4 的包。分析如下：", "\n\n", "> mvn dependency:tree\n[INFO] ------------------------------------------------------------------------\n[INFO] Building mvn-test 1.0.0\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ mvn-yilaitest ---\n[INFO] com.ariclee:mvn-yilaitest:jar:1.0.0\n[INFO] \\- commons-io:commons-io:jar:2.4:compile\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1.068 s\n[INFO] Finished at: 2019-05-11T16:45:38+08:00\n[INFO] Final Memory: 12M/245M\n[INFO] ------------------------------------------------------------------------\n", "\n\n", "为什么依赖后声明的却被引入了，这不是违背了第一声明原则吗？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;估计你的编译器不支持c&amp;#43;&amp;#43;11标准&amp;#xff0c;或者你么有打开你的编译器的C&amp;#43;&amp;#43;11标准的开关&amp;#xff0c;如果不支持的话可以用以下语句&lt;br /&gt;q.push(make_pair(1,1));&lt;br /&gt;替代&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["如何使用“{ x,y}”向队列中传入二位数组元素(x,y)？", ["在使用某博主关于BFS算法求解（迷宫）最短路径问题时，我看到了这样几条语句，并提出了我的疑问。", "\n", "（", "1", "）", "typedef", " pair<", "int", ", ", "int", "> PII;", "//pair<int,int>?", "\n（", "2", "）queue<PII> q;", "//队列中使用二维数组作为元素？", "\n（", "3", "） q.", "push", "({", "0", ",", "0", "});", "//怎么push一个二维的数组元素(x,y)", "\n（", "4", "）", "auto", " t=q.", "front", "();", "//哪里来的auto?", "\n", "\n", "我尝试在dev上运行，以下是完整的代码，和我在CSDN上找到的关于使用“{}”返回等的错误改写（其后用“//”标识），但是任然没有解决问题。", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cstring>", "\n", "#", "include", " ", "<algorithm>", "\n", "#", "include", " ", "<queue>", "\n", "//#include <bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "//add_definitions(\"std=c++11\");", "\n", "typedef", " pair<", "int", ", ", "int", "> PII;", "//", "\n", "const", " ", "int", " N = ", "110", ";\n", "int", " s[N][N];\n", "int", " n,m;\n", "int", " g[N][N];\n", "int", " ", "bfs", "()", "\n", "{\n    queue<PII> q;", "//", "\n    ", "memset", "(g, ", "-1", ", ", "sizeof", " g);", "//", "\n    q.", "push", "({", "0", ",", "0", "});", "//", "\n    g[", "0", "][", "0", "]=", "0", ";\n    ", "int", " dx[", "4", "] = {", "-1", ", ", "0", ", ", "1", ", ", "0", "}, dy[", "4", "] = {", "0", ", ", "1", ", ", "0", ", ", "-1", "};", "//", "\n    ", "while", "(q.", "size", "())\n    {\n        ", "auto", " t=q.", "front", "();", "//", "\n        q.", "pop", "();\n        ", "for", "(", "int", " i=", "0", ";i<", "4", ";i++)\n        {\n            ", "int", " a=t.first+dx[i];\n            ", "int", " b=t.second+dy[i];\n            ", "if", "(a>=", "0", " && a<n && b>=", "0", " && b<m && g[a][b]==", "-1", " && s[a][b]==", "0", ")", "//", "\n            {\n                g[a][b]=g[t.first][t.second]+", "1", ";\n                q.", "push", "({a,b});", "//", "\n            }\n        }\n    }\n    ", "return", " g[n", "-1", "][m", "-1", "];\n}\n", "int", " ", "main", "()", "\n", "{cin>>n>>m;\n", "for", "(", "int", " i=", "0", ";i<n;i++)\n", "for", "(", "int", " j=", "0", ";j<m;j++)\ncin>>s[i][j];\ncout<<", "bfs", "()<<endl;\n}\n", "\n", "以下是报错内容截图：", "\n", "\n", "以下是我在搜索过后找到的解决方案。（我没看懂、用了方法也没有成功）", "\n      \n        ", "C++ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11 return {i,j}_m0_46334316的博客-CSDN博客", "\n        \n      ", "C++ vector return{} 返回错误在解答LeetCode两数之和的题目使用{}返回vector出现了错误部分源代码    int array1[4] = {2,7,11,15};    int array2[3] = {3,2,4};    int array3[2] = {3,3};    int target1 = 9;    int target2 = 6;    int target3 = 6;    Solution s;    vector<int&g", "\n      ", "\n      ", "\n        ", "\n          ", "https://blog.csdn.net/m0_46334316/article/details/116431816?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163650113416780264018681%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=163650113416780264018681&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-116431816.first_rank_v2_pc_rank_v29&utm_term=%5Bwarning%5D+extended+initializer+lists+only+available+with+-std%3Dc%2B%2B11+or+-std%3Dgnu%2B%2B11&spm=1018.2226.3001.4187", "\n        ", "\n      ", "\n", "总结一下我的问题在于：", "（1）不晓得该怎么传{x,y}到队列里面。", "（2）auto的用法在这里为什么行不通？", "（3）c++11中头文件<bits/stdc++.h>据说是包括了很多头文件……那在这个地方，可以只写它吗？"]], "Tag": "算法设计"}
{"Answer": "引入 \r\n\r\ncommons-dbcp\r\n\r\n的时候把commons-collections-2.1 exclude掉就行了\r\n\r\n或者\r\n\r\n在你的直接的POM中引入\r\n\r\ncommons-collections\r\n\r\nMaven是按照最短路径来的，只要你直接在POM引入了，就会用你直接引入的。\r\n\r\nMaven2.0.9是这样的，不知道2.1这个规则有没有改，LZ试一试上面两种方法", "Konwledge_Point": "最短路径", "Question": ["Maven集成时依赖jar包版本控制问题", ["我有一个WEB工程需要用到commons-collections和commons-dbcp.", "\n代码中用到的是commons-collections的3.1版本特性，但是资源库中commons-dbcp依赖的", "\ncommons-collections指定了2.1版本。看了下commons-dbcp-1.2.1.pom：", "commons-collections", "commons-collections", "2.1", "\n\n", "当我将web工程打包时，maven会将commons-collections-3.1.jar", "\n和commons-collections-2.1.jar都拷贝进WAR包。 如何只让maven只将", "\ncommons-collections-3.1.jar拷贝到war包中去？", "\n\n", "[b]问题补充：[/b]", "\n谢谢，jansel的答复，方案1是可以行的，但是觉得maven应该有其它解决方案，所以发贴出来咨询一下。方案2我试过了，在我自己的工程pom.xml文件中指定了", "\n高版本的common-collections，但是maven做package的时候依赖会将两个版本的common-collections库都打进WEB-INF/lib，我的maven版本是2.0.9.", "\n[b]问题补充：[/b]", "\nE:\\NGWORK\\javaprj\\webapp>mvn dependency:tree -Dverbose -Dincludes=commons-collections", "\n\n", "E:\\NGWORK\\javaprj\\webapp>set MAVEN_OPTS=-Xms64m  -Xmx512m", "\n[INFO] Scanning for projects...", "\n[INFO] Searching repository for plugin with prefix: 'dependency'.", "\n[INFO] ------------------------------------------------------------------------", "\n[INFO] Building Unnamed - asiainfo.cboss:cboss:war:SNAPSHOT", "\n[INFO]    task-segment: [dependency:tree]", "\n[INFO] ------------------------------------------------------------------------", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/cas/aicasclient/1.0/aicasclient-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/cmcc/twcmcc/1.4/twcmcc-1.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/castor/castor-xml/1.0/castor-xml-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/openboss/openclient/2.0/openclient-2.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/xstream/xstream/1.3/xstream-1.3.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/jdk/tools/1.4.2/tools-1.4.2.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/servlet/servlet/2.3/servlet-2.3.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/cboss/portalExternal/1.8/portalExternal-1.8.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/openbuff/EzfrmWeb/1.0/EzfrmWeb-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/openbuff/EzfrmBiz/1.0/EzfrmBiz-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/net/sf/jasperreports/2.0.3/jasperreports-2.0.3.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/lowagie/itext/1.3.1/itext-1.3.1.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/lowagie/itext-asian/1.0/itext-asian-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/net/sf/json/2.2.1/json-2.2.1.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/net/sf/ezmorph/1.0.4/ezmorph-1.0.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/edu/concurrent/1.0/concurrent-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/asiainfo/ny/nysecurity/1.0/nysecurity-1.0.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/cmcc/trustwork/1.4/trustwork-1.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/cmcc/pwdSvr/1.4/pwdSvr-1.4.pom", "\nDownloading: ", "http://repo1.maven.org/maven2/poi/poi/2.5.1-FINAL/poi-2.5.1-FINAL.pom", "\n[INFO] [dependency:tree]", "\n[INFO] asiainfo.cboss:cboss:war:SNAPSHOT", "\n[INFO] +- asiainfo.cboss:cboss-common:jar:SNAPSHOT:compile", "\n[INFO] |  - org.apache.velocity:velocity:jar:1.5:compile", "\n[INFO] |     - (commons-collections:commons-collections:jar:3.1:compile - omitted for conflict with 2.1)", "\n[INFO] +- commons-collections:commons-collections:jar:3.1:runtime (scope not updated to compile)", "\n[INFO] +- commons-dbcp:commons-dbcp:jar:1.2.1:compile", "\n[INFO] |  - (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 3.1)", "\n[INFO] +- commons-beanutils:commons-beanutils:jar:1.6:compile", "\n[INFO] |  - (commons-collections:commons-collections:jar:2.0:compile - omitted for conflict with 3.1)", "\n[INFO] - commons-pool:commons-pool:jar:1.2:compile", "\n[INFO]    - (commons-collections:commons-collections:jar:2.1:compile - omitted for conflict with 3.1)", "\n[INFO] ------------------------------------------------------------------------", "\n[INFO] BUILD SUCCESSFUL", "\n[INFO] ------------------------------------------------------------------------", "\n[INFO] Total time: 33 seconds", "\n[INFO] Finished at: Wed Sep 09 13:18:59 CST 2009", "\n[INFO] Final Memory: 13M/63M", "\n[b]问题补充：[/b]", "\n的确是按最短路径实现的，我在自己的pom.xml中指定了使用版本，maven就是使用这个版本的。 上午是因为忘记做clean了，所以原来已经拷贝到WEB-INF/lib目录的库没有被清理这样commons-collections－2.1.jar还是会存在， 让我误认为不能生效。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;运筹学的内容吗&amp;#xff1f;&lt;br /&gt;应该是可以的&amp;#xff0c;这个应该是多元n次优化问题&lt;br /&gt;一般是lingo的强项&amp;#xff0c;不过matlab也可以&amp;#xff0c;你需要列出相应的约束&amp;#xff0c;然后找一个前进的方向&amp;#xff0c;定义一个终止条件。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["MATLAB求解二维平面的两点间路径规划", ["有一个问题:给定加速度限制，速度限制(起点速度方向，终点速度方向)，起点(x1，y1)，终点(x2，y2)，这两点间的连线为一个n次多项式函数，可不可以利用MATLAB求出所用时间最短时，该路径函数各次项前的系数"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;int m, n, p, q, k; \nint min &amp;#61; 99999;\nint a[100][100];//1表示空,2表示障碍 \nint v[100][100];//0表示未访问,1表示访问 \n//迷宫问题\nvoid dfs(int x, int y, int step) \n{\n\t//将具体的移动方向转化为数据,4个方向\n\tint dx[4] &amp;#61; {1, 0, -1, 0};\n\tint dy[4] &amp;#61; {0, -1, 0, 1};\n\t\n\t//判断终点\n\tif(x &amp;#61;&amp;#61; p &amp;amp;&amp;amp; y &amp;#61;&amp;#61; q)\n\t{\n\t\tif(step &amp;lt; min)\n\t\t{\n\t\t\tmin &amp;#61; step;\n\t\t}\n\t\treturn;\n\t}\n\t\n\t//开始进行移动\n\tfor(k &amp;#61; 0; k &amp;lt;&amp;#61; 3; k&amp;#43;&amp;#43;)\n\t{\n\t\tint tx,ty;\n\t\t//现在的坐标位置\n\t\ttx &amp;#61; x &amp;#43; dx[k];\n\t\tty &amp;#61; y &amp;#43; dy[k];\n\t\tif(a[tx][ty] &amp;#61;&amp;#61; 1 &amp;amp;&amp;amp; v[tx][ty] &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tv[tx][ty] &amp;#61; 1;\n\t\t\tdfs(tx,ty,step&amp;#43;1);\n\t\t\tv[tx][ty] &amp;#61; 0;\n\t\t}\n\t}\n\t\n\treturn;\n}\n\nmain()\n{\n\t//为地图赋值\n\tint i, j;\n\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;m,&amp;amp;n);\n\t\n\tfor(i &amp;#61; 1; i &amp;lt;&amp;#61; m; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor(j &amp;#61; 1; j &amp;lt;&amp;#61; n; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]);\n\t\t}\n\t}\n\t\n\tint startx,starty;\n\t//确定起点和终点\n\tscanf(&amp;#34;%d%d%d%d&amp;#34;,&amp;amp;startx, &amp;amp;starty,&amp;amp;p,&amp;amp;q);\n\t//将起点设置已访问\n\ta[startx][starty] &amp;#61; 1;\n\tdfs(startx,starty,0);\n\t\n\tprintf(&amp;#34;%d&amp;#34;,min);\n\t\n\treturn 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;参考&lt;a href=\"https://blog.csdn.net/s_meng_/article/details/116357413\"&gt;C语言实现&amp;#xff0c;找出迷宫起点到终点的最短路径&amp;#xff0c;最详细的DFS教程_s_meng_的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["求各位大佬看一下c语言迷宫问题[急]", ["项目要求：1、找到一条或多条从迷宫起点到迷宫终点的路径，并将路径输出；\n2、找到一条最短的路径，并将路径输出；\n3、以尽可能短的时间，找到路径，并将路径输出；\n4、解决方案能适用于任意同形式的迷宫。 "]], "Tag": "算法设计"}
{"Answer": "以下是代码\r\n```\r\nimport random as rd\r\n\r\nminimum=999999  #初始化minimum为一个很大的值 保证任何结果都小于该值\r\nresult =\"\"  #全局最小路径结果\r\n\r\npathLen=[[0,38,42,27,41,24],[38,0,8,21,13,22],[42,8,0,26,10,29],[27,21,26,0,18,5],[41,13,10,18,0,25],[24,22,29,5,25,0]] #各个城市的距离表\r\n\r\nclass path():\r\n    def __init__(self,p1,p2,n=5): #类型初始化,p1为交叉概率,p2为变异概率,n为城市数 本例为5（北京先后到5个城市）\r\n        self.path=[i for i in range(n)]\r\n        self.p1=p1\r\n        self.p2=p2\r\n        self.n=n\r\n    def init(self): #用于第一代的基因生成\r\n        for i in range(self.n):\r\n            self.path[i]=rd.randint(0,self.n)\r\n        \r\n    def exchange(self): #交叉\r\n        if rd.randint(1,100)&gt;(100-self.p1):   #有概率交叉\r\n            while 1:\r\n                position1=rd.randint(0,self.n-1)   #随机生成交叉位置\r\n                position2=rd.randint(0,self.n-1)\r\n                if position1 != position2:  #判断交叉位置非同一位置\r\n                    self.path[position1],self.path[position2]=self.path[position2],self.path[position1]\r\n                    break\r\n                else:\r\n                    continue\r\n    def change(self):\r\n        if rd.randint(1,100)&gt;(100-self.p2):     #有概率变异\r\n            self.path[rd.randint(0,self.n-1)]=rd.randint(0,self.n)\r\n    def calculate(self):    #计算路径总长度\r\n        count=pathLen[1][self.path[0]]   #北京至第一个城市的路程\r\n        for i in range(self.n-1):\r\n            count+=pathLen[self.path[i]][self.path[i+1]]   #中途各个城市间的路程\r\n        count+=pathLen[self.path[-1]][1]  #最后一个城市到北京的路程\r\n        return count\r\n    def parity(self):   #校验是否为每个城市去一次且不包含北京\r\n        count=0\r\n        path=self.path.copy()\r\n        path.sort()\r\n        for i in range(len(path)-1):\r\n            if path[i]==path[i+1]:\r\n                count+=1\r\n            if path[i]==1:\r\n                count+=1\r\n        if count==0:\r\n            return 1\r\n        else:\r\n            return 0\r\n\r\n    def nxt(self,other): #产生子代\r\n        p=path(self.p1,self.p2)\r\n        for i in range(self.n):\r\n            if rd.randint(1,100)&gt;50:\r\n                p.path[i]=self.path[i]\r\n            else:\r\n                p.path[i]=other.path[i]\r\n        return p\r\n        \r\n\r\ndef generate(n,p1,p2):  #生成种群 n为规模 p1为交叉概率 p2为变异概率\r\n    t=[]\r\n    for i in range(n):\r\n        father=path(p1,p2)\r\n        father.init()\r\n        t.append(father)\r\n    return t\r\n\r\n\r\ndef allChange(t):    #进行繁殖、变异、交换、淘汰\r\n    global minimum\r\n    global result\r\n    l=len(t)\r\n    print(\"本轮父代个数为:\",l)\r\n    if l&gt;100:   #如果父代个数大于100则开始父代淘汰机制\r\n        path=[]\r\n        for i in t:\r\n            path.append(i.calculate())   #计算各个个体的路径长度\r\n        path.sort()  #路径长度排序\r\n        tt=[]\r\n        j=0\r\n        while len(tt)&lt;100:\r\n            for i in t:\r\n                if i.calculate()==path[j]:\r\n                    tt.append(i)\r\n            j+=1\r\n        t=tt\r\n    l=len(t)\r\n    for i in range(l):   \r\n        for j in range(l-1-i):\r\n            child=t[i].nxt(t[j]) #两两交配产生子代\r\n            child.exchange()     #子代交换\r\n            child.change()      #子代变异\r\n            t.append(child)          #向种群添加子代\r\n    count=0\r\n    for i in range(len(t)):  #去除不符合的成员\r\n        if t[i-count].parity()==0: #杀死不符合要求的子代 （每个城市去一次且不包含北京）\r\n            del(t[i-count])\r\n            count+=1\r\n    print(\"本轮产生子代后总数:\",len(t))\r\n    result1=t[-1].path\r\n    mini=t[-1].calculate()\r\n    for i in range(len(t)-1):   #获得各个个体的路程长度\r\n        tt=t[i].calculate()     \r\n        if mini&gt;tt:             #比较是否是新的最小路径\r\n            mini=tt\r\n            result1=t[i].path\r\n    print(\"本轮最小路径长度:\",mini)\r\n    print(\"本轮最小路径结果:\",result1)\r\n    if mini&lt;minimum:\r\n        minimum=mini\r\n        result=result1\r\n            \r\n\r\n\r\n\r\nzq=generate(30,10,10) #generate(30,10,10)表示 初始种群30，交换概率10%，变异概率10%\r\nfor i in range(6):  #range(n) 标识迭代n代\r\n    allChange(zq)\r\nprint(\"最后最小路径长度为:\",minimum)\r\nprint(\"最后最小路径为:\",result)\r\n\r\n\r\n```\r\n运行结果\r\n![图片说明](https://img-ask.csdn.net/upload/202006/09/1591697988_503086.png)", "Konwledge_Point": "最短路径", "Question": ["旅行商路径优化问题的遗传算法程序", ["编制旅行商路径优化问题的遗传算法程序，并计算一个实例。(以不超过10个城市为例,给出初始种群规模、交叉概率、变异概率在不同设置情况下的总结分析)。", "\n要求：遗传算法路径结果图，适应函数自选（标明），附上全部代码。", "\n旅行商问题：", "\n\n", "从北京（B）乘飞机到威海(W)、贵阳(G)、上海(S)、昆明(K)、拉萨(L)", "\n五城市做旅游，每城市恰去一次再回北京，应如何安排旅游线，使旅程最短？各城市之间的航线距离如表7。", "\n表7 六城市间的距离", "\n   L    B    W    G    S    K", "\nL 0    38  42   27   41  24", "\nB 38  0    8    21   13   22", "\nW42  8    0    26   10   29", "\nG 27  21  26   0    18    5", "\nS 41  13  10  18    0     25", "\nK 24  22  29   5    25    0"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这种必然要递归&lt;br /&gt;否则回溯会非常麻烦&lt;br /&gt;尤其有环路的时候容易造成死循环&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["走一堆二维平面的点，如何实现最小路径？", ["遇到的现象和发生背景，请写出第一个错误信息", "\n", "走一堆二维平面的点，如何实现最小路径？", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "  public static List<", "int", "> nextpoint(List<NewTrackData> currentlist, ", "int", " currentpoint)", "//当前list,当前点", "\n        {\n            double  distence;\n            double minidistence;\n            ", "for", " (", "int", " i = ", "0", "; i < currentlist.Count; i++)", "//去掉第一个点的新list", "\n            {\n                distence = Math.", "Pow((", "currentlist", "[", "i", "].Track.Start_X - ", "currentlist", "[", "currentpoint", "].Track.Start_X)", ", ", "2.0", ") + Math.", "Pow((", "currentlist", "[", "i", "].Track.Start_Y - ", "currentlist", "[", "currentpoint", "].Track.Start_Y)", ", ", "2.0", ");\n                Distencelist.", "Add(", "distence", ")", ";\n            }\n            minidistence = Distencelist.", "Min()", ";", "//获取list中的最小值", "\n            List<", "int", "> minilist = ", "new", " List<", "int", ">", "()", ";\n            ", "int", " minIndex = Distencelist.", "IndexOf(", "minidistence", ")", ";", "//获取最小值的索引集合", "\n            ", "for", " (", "int", " i = minIndex - ", "1", "; i < Distencelist.Count; i++)\n            {\n                ", "if", " (Distencelist", "[", "i", "]", " == ", "minIndex)\n                {\n                    minilist.", "Add(", "i", ")", ";\n                }\n            }\n             List<", "int", "> index = ", "new", " List<", "int", ">", "()", ";\n             ", "for", " (", "int", " i = ", "0", "; i < minilist.Count; i++)\n             {\n                 index.", "Add(", "currentlist", "[", "minilist", "[", "i", "]].", "originalIndex", ")", ";\n             }\n            return index;", "//原始list的顺序", "\n        }\n", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "1、先定一个起始点A;", "2、计算出起始点A与其他点的距离，比较出距离最短的那个点B；", "3、再用点B与其他点（除点A）比较找出距离最短的点C;但是如果存在D，F点BF，BD距离和BC距离一样如何确定下一个点？", "4、循环操作直到最后一个点，无需比较，直接找到还没有排序的点，追加在最后即可。", "5、然后将所有点循环定为起始点，将每一种点排序组合都加到数组A中，并将这种排序组合所有点连线计算出长度加到数组B中；", "6、找出数组B中值最小的下标，到数组A中找对应的点排列组合，这个排序结果就是最短路线点的排序。", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;您好&amp;#xff0c;想法非常好&amp;#xff0c;也非常符合常识&amp;#xff0c;但是我认为核心问题集中在以下几点 &amp;#xff1a;&lt;br /&gt;第一&amp;#xff0c;‘从初始节点计算与其他节点的距离&amp;#xff0c;使每次选取下一落脚点距离当前节点最近’    能不能更快逼近最优解&amp;#xff1f;  能的。&lt;br /&gt;第二&amp;#xff0c;是否有这个必要&amp;#xff1f;我认为核心还是在于您不确定以这样的方式最终求得路径是否最短。也就是~~&lt;br /&gt;例如有【A1&amp;#xff0c;A2。。。。。。。AN】 N个节点&amp;#xff0c;取任一节点为起始节点&amp;#xff0c;计算出相邻节点最短的一条路径就是我们求的路径&amp;#xff1f;&lt;br /&gt;。。。这个我也不能肯定哈哈哈&amp;#xff0c;常识提醒我是这样的&amp;#xff0c;严谨告诉我最好在少量节点情况下验证一两次。&lt;br /&gt;第三&amp;#xff0c;可行性。假设有n个节点&amp;#xff0c;起始节点计算量为n-1次距离函数~~~~  &amp;#61;》倒数第二个节点计算量为1次函数。&lt;br /&gt;即总计算量为(1&amp;#43;n-1)&lt;em&gt;(n-1)/2 次距离函数. 随着节点数量的增大&amp;#xff0c;计算量也会逐渐增大&amp;#xff0c;那么会不会造成内存不够&amp;#xff1f;&lt;br /&gt;即第一次计算起始点与剩余所有点的距离取最小值就G了 &amp;#xff1f;如果节点在20~30个的话应该没太大的问题&amp;#xff0c;&lt;br /&gt;另外时间上n&lt;/em&gt;(n-1)/2次距离计算是否超出预期&amp;#xff1f;如果时间过长&amp;#xff0c;那么就需要考虑如何简化距离函数&amp;#xff0c;提高单次距离计算的效率。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;有用请采纳&amp;#xff0c;感谢&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["遗传算法种群初始化的优化必要性", ["假设用遗传算法去做一个类旅行商问题，从节点0开始，用最短的路径遍历所有的其他节点。我们假设存在一个具体的小示例如下：", "\n", "\n", "这时候，种群初始化有两种方案：", "\n", "（正常操作）随机节点1234的排列，如1234，4231。", "\n", "\n", "（设想的操作）根据当前出发点0，根据当前出发点与其他节点的距离 取倒数并做归一化。实现", "距离越近，越大概率取为染色体路径的下一个节点", "。选取后，再根据最新的节点路径做新的计算与取值。从直觉上，这样可以更快逼近最优解。但是是否有这个必要", "\n", "想问下这种操作的可行性和必要性，在节点数量大约20个、30个的情况下，会对后续的操作产生什么影响，如果是好影响，是什么。如果有坏影响的话，会有解决方法吗？"]], "Tag": "算法设计"}
{"Answer": "这里有一个\r\n[url]http://blog.csdn.net/java2000_net/archive/2008/05/01/2357485.aspx[/url]", "Konwledge_Point": "最短路径", "Question": ["谁有A*算法的DEMO", ["我最近在做一个搞怪碰碰球的游戏，可能大家以前也玩过，就是在某一直线上如果有5个同色的球相连就消球子得分否则就自动生成3个随机颜色的球子。但选择位置的时候你所选中的球子会判断你选择的位置是否有效（在关闭链表中，有障碍物等）如果有效会生成一条最短的路径自动移动过去，否则不动。", "\n\n", "这个项目着实让我郁闷了好久，到现在还是没有思路。求哪位大虾能指点迷津，最好是能有源代码，因为本人脑子比较笨不太擅长理解那种文字讲述性的文章。感激不尽！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考这些资源&amp;#xff0c;没有积分我可以帮你下载&amp;#xff1a;&lt;a href=\"https://download.csdn.net/download/l591492105/3429920?ops_request_misc&amp;#61;%257B%2522request%255Fid%2522%253A%2522162428184216780366551425%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fdownload.%2522%257D&amp;amp;request_id&amp;#61;162428184216780366551425&amp;amp;biz_id&amp;#61;1&amp;amp;utm_medium&amp;#61;distribute.pc_search_result.none-task-download-2~download~first_rank_v2~rank_dl_default-2-3429920.pc_v2_rank_dl_default&amp;amp;utm_term&amp;#61;%E6%B1%82%E5%87%BA%E5%AE%8C%E6%88%90%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%97%B6%E9%97%B4%E4%BB%A5%E5%8F%8A%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E3%80%81&amp;amp;spm&amp;#61;1018.2226.3001.4451\"&gt;关键路径问题&amp;#xff1a;设计程序求工程关键活动-C文档类资源-CSDN下载&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://download.csdn.net/download/weixin_43729663/12272577?ops_request_misc&amp;#61;%257B%2522request%255Fid%2522%253A%2522162428184216780366551425%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fdownload.%2522%257D&amp;amp;request_id&amp;#61;162428184216780366551425&amp;amp;biz_id&amp;#61;1&amp;amp;utm_medium&amp;#61;distribute.pc_search_result.none-task-download-2~download~first_rank_v2~rank_dl_default-4-12272577.pc_v2_rank_dl_default&amp;amp;utm_term&amp;#61;%E6%B1%82%E5%87%BA%E5%AE%8C%E6%88%90%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E6%97%B6%E9%97%B4%E4%BB%A5%E5%8F%8A%E6%95%B4%E9%A1%B9%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8%E3%80%81&amp;amp;spm&amp;#61;1018.2226.3001.4451\"&gt;数据结构综合课设关键路径问题.docx-C/C&amp;#43;&amp;#43;文档类资源-CSDN下载&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["帮帮忙吧，哥哥们！！！！", ["最短工期的求解", "\n工程最短工期的求解", "\n基本要求：", "\n基本要求：", "\n设计一个程序，求出完成整项工程至少需要多少时间，以及整项工程中的关键活动。", "\n(1)通过菜单选项从键盘输入一个描述工程的AOE网（事件不少于10个），或者，从外部txt文件输入", "\nAOE网。", "\n(2)首先判断AOE网代表的施工图是否能够顺利进行。如果不能顺利进行，能通过菜单选项重新输入。", "\n(3)若该工程能顺利进行，输出关键路径和关键活动。", "\n(4)设计实现菜单方式的交互界面，界面友好，可反复操作。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;哈密顿回路&lt;br /&gt;如果对你有帮助&amp;#xff0c;望采纳&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["历遍所有点再回到原点，属于什么问题", ["手上只有点与点之间的距离，比如1到4、7、8,然后2到3、5、6,……之间的距离，每个点都能到达其中几个点且只知道距离不知道坐标。", "没有要求一定要走完每一条路，只要走完所有点回到原点就行，然后找最短的一条路径。", "我看了好像不属于tsp问题，因为不知道坐标", "也不属于邮递员问题，因为没必要走完每一条线。", "那么这种问题属于什么问题呢，我都不知道该怎么去查资料，或者可以用什么方法呢", "由于刚接触，可以不用给太详细（我也看不懂），给些查资料的方向吧，", "手头的数据是要做从至表然后整理成对称矩阵输入matlab吗？还是说其他什么矩阵"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;该程序似乎旨在解决迷宫问题并打印它找到的路径。该程序在搜索解决方案时使用堆栈来存储路径的位置和方向。栈在迷宫的起点被初始化&amp;#xff0c;程序继续寻找解&amp;#xff0c;直到栈为空。&lt;/p&gt;\n&lt;p&gt;有几个可能的原因会导致程序在一段时间后自行停止。一种可能是程序遇到无限循环。这可能是由程序逻辑错误引起的&amp;#xff0c;例如缺少 break 语句或条件始终为真。&lt;/p&gt;\n&lt;p&gt;另一种可能性是程序内存不足。该程序使用一个结构数组来存储路径&amp;#xff0c;如果该数组不够大以容纳所有路径&amp;#xff0c;则可能导致程序崩溃或意外停止。&lt;/p&gt;\n&lt;p&gt;如果没有关于程序的具体行为和输入数据的更多信息&amp;#xff0c;就很难查明问题的确切原因。我建议检查代码并检查可能导致程序自行停止的任何潜在问题或错误。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["C语言数据结构链栈迷宫问题", ["\n", "为什么我在输入完出口后，过一会程序就自己停止了？\n\n下面是迷宫求解函数，问题应该就在这\n\nvoid ", "Path(", "int", " ", "**", "maze", ",", "int", " ", "m", ",", "int", " ", "n", ")", "    ", "//迷宫求解 ", "\n{\n    Direct direct", "[", "4", "]", ";    ", "//定义东，南，西，北四个方向 ", "\n    direct", "[", "0", "]", ".x = ", "0", ",direct", "[", "0", "]", ".y = ", "1", ";    ", "//向东走 ", "\n    direct", "[", "1", "]", ".x = ", "1", ",direct", "[", "1", "]", ".y = ", "0", ";    ", "//向南走 ", "\n    direct", "[", "2", "]", ".x = ", "0", ",direct", "[", "2", "]", ".y = -", "1", ";    ", "//向西走 ", "\n    direct", "[", "3", "]", ".x = -", "1", ",direct", "[", "3", "]", ".y = ", "0", ";    ", "//向北走", "\n    LNode *stack;\n    Temp T", "[MAX]", ",temp;\n    ", "int", " x,y,X,Y,d,count = ", "0", ",length,minlength;\n    ", "bool", " find = ", "false", ";\n    *(*(maze+", "1", ")+", "1", ") = -", "1", ";\n    temp.x = ", "1", ",temp.y = ", "1", ",temp.d = -", "1", ";\n    ", "Init(", "stack", ")", ";\n    ", "Push(", "stack", ",", "temp", ")", ";\n    ", "while", "(!is", "Empty(", "stack", ")", ")\n    {\n        get", "Pop(", "stack", ",&", "temp", ")", ";\n        x = temp.x,y = temp.y,d = temp.d + ", "1", ";\n        ", "if", "(x", " == ", "m&&y", " == ", "n)\n        {\n            length = ", "0", ";\n            printf(", "\"迷宫第%d条路径如下：\"", ",++count);\n            ", "while", "(!is", "Empty(", "stack", ")", "){\n                ", "Pop(", "stack", ",&", "temp", ")", ";\n                T", "[", "length", "++", "]", " = temp;\n            }\n            ", "if", "(length < minlength)\n            {\n                minlength = length;\n            }\n            ", "for", "(", "int", " i = ", "1", ";length > ", "0", ";i++)\n            {\n                printf(", "\"[%d,%d],%d \"", ",T", "[--", "length", "]", ".x,T", "[", "length", "]", ".y,T", "[", "length", "]", ".d);\n                ", "Push(", "stack", ",T[", "length", "])", ";\n                ", "if", "(i % ", "5", " == ", "0", ")\n                printf(", "\"\\n\"", ");\n            }\n            printf(", "\"\\n\"", ");\n            ", "Pop(", "stack", ",&", "temp", ")", ";\n            *(*(maze+temp.x)+temp.y) = ", "0", ";\n        }\n        ", "else", "\n        {\n            ", "Pop(", "stack", ",&", "temp", ")", ";\n            *(*(maze+temp.x)+temp.y) = ", "0", ";\n        }\n        ", "while", "(d<", "4", ")\n        {\n            X = x + direct", "[", "d", "]", ".x;\n            Y = y + direct", "[", "d", "]", ".y;\n            ", "if", "(*(*(maze+X)+Y)", " == ", "0", ")\n            {\n                temp.x = X,temp.y = Y,temp.d = d;\n                ", "Push(", "stack", ",", "temp", ")", ";\n                x = X,y = Y,*(*(maze+X)+Y) = -", "1", ";\n                d = ", "0", ";\n            }\n            ", "else", "\n            {\n                d++;\n            }\n        }\n    }\n    printf(", "\"最短的一条路径是路径是第%d条路径\\n\"", ",minlength);\n    ", "if", "(find", " == ", "false", ")\n    printf(", "\"该迷宫没有可以到达出口的路径！\\n\"", ");\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;concat 可以一次性合并多个 dataFrame&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;filenames&amp;#61;os.listdir(path)\ndf_list &amp;#61; []\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;filename&lt;/span&gt; in filenames:\n    df_list.&lt;span class=\"hljs-keyword\"&gt;append&lt;/span&gt;(pd.read_excel(path &amp;#43; &amp;#39;\\&amp;#39; &amp;#43; &lt;span class=\"hljs-keyword\"&gt;filename&lt;/span&gt;))\nresult_df &amp;#61; pd.&lt;span class=\"hljs-keyword\"&gt;concat&lt;/span&gt;(df_list)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最短路径", "Question": ["Python合并表格时间太长怎么解决?", ["求助各位，我用的是pycharm教育版，合并三个表，累计行数在四万行左右，以下是我写的代码，运行时间最短的一次也是一百六十多秒，并且运行一次一次比一次久，最后一次将近四百秒了，求帮忙看下代码写的有什么问题，或者可以怎么改，谢谢，好人一生平安", "\n", "import", " os\n", "import", " pandas ", "as", " pd\n", "import", " time\nstart=time.time()\npath=", "r'D:\\我的工作文件夹\\A 可视化\\sales_order'", "\nempty=pd.DataFrame()\ny=os.listdir(path)\n", "for", " i ", "in", " y:\n    df=pd.read_excel(path+", "'\\%s'", "%i)\n    ", "#连接路径和表名", "\n    empty=pd.concat([empty,df])\nempty.to_excel(excel_writer = ", "r'D:\\我的工作文件夹\\A 可视化\\sales_order.xlsx'", ",sheet_name=", "'order'", ",index=", "False", ")\nend=time.time()\n", "print", "(", "'代码运行时间为:%.2f 秒'", "%", "round", "(end-start,", "2", ")) \n\n"]], "Tag": "算法设计"}
{"Answer": "http://www.cnblogs.com/fenglianchen/p/7674766.html", "Konwledge_Point": "最短路径", "Question": ["求大神，求大咖，不会安装啊", ["请问如何安装 sql server 2008？？在win10环境下的"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;类似于“有限制条件的动态规划旅行商问题”的方法&amp;#xff0c;我们需要定义一个状态 (S, i, p)&amp;#xff0c;其中S是已访问过的顶点集合&amp;#xff08;包括取件点和送货点&amp;#xff09;&amp;#xff0c;i是当前所在的顶点&amp;#xff0c;p表示当前手中的包裹来源&amp;#xff08;取件点集合&amp;#xff09;。转移方程&lt;/p&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;&lt;br /&gt;dp[S, i, p] &amp;#61; min(dp[S, i, p], dp[S-{i}, j, p-{i}] &amp;#43; dist(j, i))&lt;/p&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;j是S中的一个顶点&amp;#xff0c;且满足以下条件&amp;#xff1a;若i是一个送货点&amp;#xff0c;则j必须是与i对应的取件点之一。在递推的过程中&amp;#xff0c;需要保证p始终包含了当前所在的送货点所需的包裹来源初。始化状态和边界条件。dp[S, i, p]初始化为无穷大&amp;#xff08;表示不可达&amp;#xff09;。边界条件为&amp;#xff1a;当S只包含一个顶点&amp;#xff08;即某个取件点&amp;#xff09;时&amp;#xff0c;dp[S, i, p]为0&amp;#xff0c;其中i表示该取件点。&lt;/p&gt;\n&lt;p&gt;最后&amp;#xff0c;遍历所有状态并更新动态规划数组&amp;#xff0c;通过回溯法找到最短路径。&lt;br /&gt;送货点数量不会超过250个&amp;#xff0c;可以试试看这个。&lt;/p&gt;", "Konwledge_Point": "最短路径", "Question": ["TSP旅行商问题，多个取件点，可返回，不一定回原点算法", ["我是一个送货员，我想计算出一日工作的最短路程。", "具体：", "\n", "公司有多个取件点，而我每天早上可以随意选从哪一个取件点开始配送", "每一个配送点要送的包裹都有对应的单个或多个取件点（可能一个送货点有来自取件点A和B甚至更多不同地方的包裹要取），要保证去配送的时候手里有对应的包裹（就是之前去过对应包裹的取件点）", "可多次去一个送货点", "每天不用回到初始点，只要回到任意取件点就行", "包裹不限重量，默认去一个取件点就把所有包裹都带上", "每日的送货点不会超过250个", "\n", "背景：之前做了一个GIS系统，需要加上这个送货员功能，目前可以计算两点之间的最短路线，在这里我用的是C++", "个人初步搜索：我浏览了网络上的TSP旅行商问题，也大致了解了解法（但不明白原理所以不知道怎么自己修改）。在想是忽略取货问题先找出所有点的最短路径，然后以那个基础上去改进路线比较好，还是这样子算走远了。如果可以的话，那我该怎么优化路径我也不知道。", "\n", "想问一下在这个条件下该怎么算会更快，谢谢大家"]], "Tag": "算法设计"}
