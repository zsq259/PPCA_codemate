{"Answer": "参考：http://blog.chinaunix.net/uid-20357359-id-1963209.html", "Konwledge_Point": "优先队列实现", "Question": ["如何用大小根交替堆实现双端优先队列？", ["双端优先队列是一个支持如下操作的数据结构：", "\n•Insert (S, x) – 将元素x插入集合S", "\n•Extract –Min (S) –删除S中的最小关键字", "\n•Extract –Max (S) –删除S中的最大关键字", "\n可用小大根交替堆来实现对上述三个操作的支持。小大根交替堆是一个满足如下小大根交替条件的完全二元树：如果该二元树不空，那么其上的每个元素都有一个称为关键字的域，且针对该关键字，二元树按层次形成了小大根交替的形式，即对于小大根交替堆中的任何一个结点x，如果x位于小根层次，那么x就是以x为根节点的二元树中键值最小的结点，并称该结点为一个小根结点。同样的道理，如果x位于大根层次，那么x就是以x为根节点的二元树中键值最大的结点，并称该结点为一个大根结点。在小大根交替堆中根结点位于小根层次。"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-xml\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;job&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; job_number;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; priority;\n};\njob priority_queue[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;   &lt;span class=\"hljs-comment\"&gt;//队列中的作业个数 全局变量&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; allnumber&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//作业号&amp;#xff0c;依次递增&amp;#xff0c;赋给增加的作业&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;remove&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(length&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;There is no job!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; maxpriority&amp;#61;&lt;span class=\"hljs-number\"&gt;9999&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; number&amp;#61;&lt;span class=\"hljs-number\"&gt;9999&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sign&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//遍历一次队列&amp;#xff0c;找到最高优先级的作业&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;length;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(priority_queue[i].priority&amp;lt;maxpriority){\n            maxpriority &amp;#61; priority_queue[i].priority;\n            number &amp;#61; priority_queue[i].job_number;\n            sign &amp;#61; i;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(priority_queue[i].priority&amp;#61;&amp;#61;maxpriority)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(priority_queue[i].job_number&amp;lt;number){\n                maxpriority &amp;#61; priority_queue[i].priority;\n                number &amp;#61; priority_queue[i].job_number;\n                sign &amp;#61; i;\n            }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,priority_queue[sign].job_number,priority_queue[sign].priority);\n\n    &lt;span class=\"hljs-comment\"&gt;//找到了作业&amp;#xff0c;删除它&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//从后往前依次覆盖&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;sign;i&amp;lt;length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        priority_queue[i] &amp;#61; priority_queue[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    &lt;span class=\"hljs-comment\"&gt;//作业个数减一&lt;/span&gt;\n    length--;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Remove succeeds!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;add&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\"hljs-comment\"&gt;//控制台输入一个优先级&amp;#xff0c;系统自动赋予作业号&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Please input the priority: &amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p;  &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;p);\n    &lt;span class=\"hljs-comment\"&gt;//构成一个作业&amp;#xff1a;作业号&amp;#xff0c;优先级  并且加在队列最后&lt;/span&gt;\n    priority_queue[length] &amp;#61; {allnumber&amp;#43;&amp;#43;,p};\n    &lt;span class=\"hljs-comment\"&gt;//作业个数加一&lt;/span&gt;\n    length&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,priority_queue[length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;].job_number,priority_queue[length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;].priority);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Add succeeds!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;list&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;List:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;//一个for循环遍历整个数组&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;length;i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,priority_queue[i].job_number,priority_queue[i].priority);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Over!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Please input your operation:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; operation;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,&amp;amp;operation);\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (operation) {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;R&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;remove&lt;/span&gt;();&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;add&lt;/span&gt;();&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;L&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;();&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;: &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Illegal input.\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;menu&lt;/span&gt;();\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;menu&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/16256333605271.png\" /&gt;&lt;/p&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/16256333750022.png\" /&gt;&lt;/p&gt;\n&lt;p&gt;直接复制粘贴就能运行。&lt;/p&gt;\n&lt;p&gt;使用数组存储作业。每次出队时&amp;#xff0c;先找到优先级最高的作业&amp;#xff0c;然后删除它。&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["数据结构（用无序顺序表实现优先队列）", ["需要用c语言编程，加点注释。", "\n", "假设进入计算机系统的作业（job）被赋予一个作业号（job number）和一个从0～9之中的优先级（priority），0表示最大优先级，9表示最小优先级。等待被作业执行的作业的作业号被保存在一个优先级队列（priority queue）中。", "编写一个程序，使用优先级队列来存放作业，并允许用户选择一下菜单操作：R（删除remove）、A（增加add）和L（列举list）。", "对于R，读出当前优先级最高的作业号并把它从优先级队列中删除，如果当前优先级最高的作业有多个，则把作业号小的作业从优先队列中删除；对于A，读入作业号和优先级，然后按上述规则把它加入到优先级队列中；对于L，则列出队列中的所有作业号及其优先级。", "作业号可用一个整数表示，可在作业进入系统时由系统赋予。", "设计适当的数据元素类型，用无序顺序表实现优先队列并写出验证代码验证各个操作，完成上述计算机系统的作业调度的演示方案。新来的作业插入到表尾。假定作业号可以反映作业被加入的先后次序，因此和作业优先级一起可以唯一识别一个作业。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;单调队列必须维护其内元素的有序性。&lt;/p&gt;\n&lt;p&gt;优先队列在普通队列的基础上给每个元素增加了优先级&amp;#xff0c;这样每次出队的元素不再是队首的元素&amp;#xff0c;而是队列中优先级最高的元素&amp;#xff0c;而具体的优先级可以自行定义&amp;#xff0c;典型的就是按元素从大到小或从小到大的顺序定义优先级。&lt;/p&gt;\n&lt;p&gt;堆通常是一个可以被看做一棵完全二叉树的数组对象&amp;#xff0c;和队列这种线性结构有本质上的差别。&lt;/p&gt;\n&lt;p&gt;STL的实现一般是经过编译器优化的。&lt;/p&gt;\n&lt;p&gt;不知道有没有帮到您。&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["单调队列 优先队列 堆的区别和联系?", ["单调队列 优先队列 堆的区别和联系是啥 感觉很像.", "以及优先队列和堆的STL实现方式又有什么联系？"]], "Tag": "算法设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;       //有用到malloc()\r\n#include&lt;conio.h&gt;       //键盘输入\r\n#include&lt;windows.h&gt;\r\n #define MAX 10\r\n\r\n \r\n#define getpch(type)  (type*)malloc(sizeof(type))\r\n#define NULL 0\r\n\r\nstruct task_struct\r\n{\r\n    char name[10];           /*进程名称*/\r\n    int number;              /*进程编号*/\r\n    float come_time;         /*到达时间*/\r\n    float run_begin_time;     /*开始运行时间*/\r\n    float run_time;          /*需要运行时间*/\r\n    float runed_time;\t\t/*运行时间*/\r\n    float run_end_time;      /*运行结束时间*/\r\n    int priority;           /*优先级*/\r\n    int run_flag;          /*调度标志*/\r\n    int start_flag;     //是否为第一次开始调度\r\n} tasks[MAX];\r\nint counter; /*实际进程个数*/\r\nint time_counter=0;\r\nint poutput(); /*调度结果输出*/\r\nint time();\r\nint charge();//判断是否所有的进程都被执行过\r\n \r\nstruct pcb                   //定义进程控制块\r\n{\r\n\tchar name[10];           //定义进程名\r\n\tchar state;              //进程状态\r\n\tint  super;             //进程优先级\r\n\tint  rtime;              //已经运行时间\r\n\tint  ntime;                //运行所需时间\r\n\tstruct pcb* link;           //定义一个队列指针，定义了一个指向pcb结构类型的指针link作为自己的成员函数\r\n}*ready=NULL,*p;                 //定义两个指向pcb结构指针类型的指针ready和p，ready的初值为空,并建立了一个空的就绪队列\r\n\r\n\r\ntypedef struct pcb PCB;           //定义将struct pcb称为PCB\r\n \r\n \r\n \r\n \r\n//***********************************************************************************************\r\nvoid sort()                       //建立对进程进行优先级排列的函数\r\n{\r\n\tPCB *f,*s;                   //定义两个用来排列的指针first和second\r\n\tint insert=0;                    //插入\r\n\tif((ready==NULL)||(p-&gt;super)&gt;(ready-&gt;super))     //比较优先级，优先级最大者，直接插入队首\r\n\t{\r\n\t\tp-&gt;link=ready;                           //\r\n\t\tready=p;                                // 将新建进程放入队首\r\n\t}\r\n\telse                                      //比较进程的优先级，并将其插入适当的地方\r\n\t{\r\n\t\tf=ready;                          //                                                \r\n\t\ts=f-&gt;link;                              //插入新的进程\r\n\t\twhile(s!=NULL)                           //如果第二个进程不为空\r\n\t\t{\r\n\t\t\tif((p-&gt;super)&gt;(s-&gt;super))            //将插入进程与当前进程比较\r\n\t\t\t{                                   //如果插入进程的优先级大于当前进程优先级，则插入当前优先级的前面\r\n\t\t\t\tp-&gt;link=s;\r\n\t\t\t\tf-&gt;link=p;\r\n\t\t\t\ts=NULL;\r\n\t\t\t\tinsert=1;\r\n\t\t\t}\r\n\t\t\telse                                 //否则，将新插入的进程插入到当前进程的后面，向后移指针\r\n\t\t\t{\r\n\t\t\t\tf=f-&gt;link;\r\n\t\t\t\ts=s-&gt;link;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(insert==0)\r\n\t\t\tf-&gt;link=p;                           //将p指针指向队尾\r\n\t}\r\n}\r\n \r\n \r\n \r\n \r\n//**********************************************************************************\r\nvoid input()                                          //建立进程控制块函数\r\n{\r\n\tint i,num;                               \r\n\tprintf(\"*********************最高优先级优先算法**********************\");\r\n\tprintf(\"\\n 请输入进程的数量：\");\r\n\tscanf(\"%d\",&amp;num);              //键盘上输入\r\n\tfor(i=1;i&lt;=num;i++)\r\n\t{\r\n\t\tprintf(\"\\n 进程号No.%d:\",i);\r\n\t\tp=getpch(PCB);\r\n\t\tprintf(\"\\n 请输入进程名：\");\r\n\t\tscanf(\"%s\",p-&gt;name);\r\n\t\tprintf(\"\\n 请输入进程优先级：\");\r\n\t\tscanf(\"%d\",&amp;p-&gt;super);\r\n\t\tprintf(\"\\n 请输入进程所需运行时间：\");\r\n\t\tscanf(\"%d\",&amp;p-&gt;ntime);\r\n\t\tprintf(\"\\n\");\r\n\t\tp-&gt;rtime=0;\r\n\t\tp-&gt;state='w';\r\n\t\tp-&gt;link=NULL;\r\n\t\tsort();                               //调用sort函数进行排序\r\n\t}\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//********************************************************************************\r\nint space()                 //计算进程控制块个数的函数\r\n{\r\n\tint k=0;\r\n\tPCB*pr=ready;          //pr指向队首进程\r\n\twhile(pr!=NULL)          //pr为空则说明计数完成，就绪队列没到头，就一直输出\r\n\t{\r\n\t\tk++;\r\n\t\tpr=pr-&gt;link;\r\n\t}\r\n\tprintf(\" 进程数量：%d\\n\",k);\r\n\tprintf(\"*********************************************\\n\");\r\n\treturn(k);\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//************************************************************************************\r\nvoid disp(PCB*pr)   //建立进程显示函数，显示当前的进程\r\n{\r\n\tprintf(\"\\n name\\t state\\t super \\t ntime\\t rtime\\n\");\r\n\tprintf(\" %s  \\t\",pr-&gt;name);\r\n\tprintf(\" %c  \\t\",pr-&gt;state);\r\n\tprintf(\" %d  \\t\",pr-&gt;super);\r\n\tprintf(\" %d  \\t\",pr-&gt;ntime);\r\n\tprintf(\" %d  \\t\",pr-&gt;rtime);\r\n\tprintf(\"\\n\");\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//****************************************************************************\r\nvoid check()            //建立进程查看函数，查看已经排列好的情况\r\n{\r\n\tPCB* pr;\r\n\tprintf(\"\\n 当前正在运行的进程：%s\",p-&gt;name);\r\n\tdisp(p);                //调用disp()显示已经筛选出来的正在运行的进程\r\n\tpr=ready;                \r\n\tprintf(\"\\n 当前就绪队列状态为：\\n\");\r\n\twhile(pr!=NULL)\r\n\t{\r\n\t\tdisp(pr);             //调用disp()显示已经排列好的就绪队列  \r\n\t\tpr=pr-&gt;link;\r\n\t}\r\n}\r\n \r\n \r\nvoid destroy()      //建立函数，撤销进程\r\n{\r\n\tprintf(\"\\n 进程[%s]已完成.\\n\",p-&gt;name);\r\n\tfree(p);                            //释放空间\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//********************************************************************************\r\nvoid running()                 //建立进程就绪函数（进程运行时间到，置为就绪状态）\r\n{\r\n\t(p-&gt;rtime)++;                    //运行时间加一\r\n\tif(p-&gt;rtime==p-&gt;ntime)\r\n\t   destroy();                     //\r\n\t else\r\n\t {\r\n\t\t (p-&gt;super)--;             //运行时间减一\r\n\t\t p-&gt;state='w';\r\n\t\t sort();                   //调用一次之后，运行时间时间和运行状态改变后，重新去排序进程\r\n\t }\r\n} \r\n \r\n \r\n//***************************************************************************\r\nvoid HPF()                        //主函数\r\n{\r\n\tint len,h=0;                                //h是用于计算执行次数的\r\n\tchar ch;\r\n\tinput();                                    //调用input函数输入相关的进程信息\r\n\tlen=space();                              //input调用完之后，回到主函数调用space函数得到对列长度\r\n\twhile((len!=0)&amp;&amp;(ready!=NULL))\r\n\t{\r\n\t\tch=getchar();                  //从键盘输入一个字符型数据，把值赋给变量ch,这个是为了每一次被执行，自己手动回车呈现出来，如果没有，则会一次性出现全部被执行的情况\r\n\t\th++;\r\n\t\tprintf(\"\\n The execute number:%d \\n\",h);\r\n\t\tp=ready;\r\n\t\tready=p-&gt;link;\r\n\t\tp-&gt;link=NULL;\r\n\t\tp-&gt;state='R';\r\n\t\tcheck();                         //调用显示正在运行的函数和就绪的函数\r\n        running();        // 调用进程就绪函数,上一个正在运行的进程运行完之后，运行时间加1，将就绪队列里面优先级最高的进程置为运行状态，如果是同优先级，则看哪个先进来，这个不可以运行在check()前，会导致多计算，并出现错误\r\n\t\tprintf(\"\\n 请回车继续......\");\r\n\t\tch=getchar();\r\n\t}\r\n\tprintf(\"\\n\\n 进程已经完成.\\n\");\r\n\tch=getchar();\r\n}\r\n\r\n \r\nvoid RR()\r\n{\r\n\t\r\n    pinput();\r\n    printf(\"时间片轮转算法。\\n\\n\");\r\n    time();\r\n    poutput();\r\n}\r\n \r\nint time()\r\n{\r\n    float time_temp=0;\r\n    int i;\r\n    int j=0;\r\n    int k=0;\r\n\tchar ch;\r\n    struct task_struct  copy_task[MAX];//备份\r\n    for(i=0; i&lt;counter; i++)\r\n    {\r\n        copy_task[j++]=tasks[i];//对进程的初始化信息备份\r\n    }\r\n \r\n    time_temp=tasks[0].come_time;\r\n    while(charge())\r\n    {\r\n        for(i=0; i&lt;counter; i++)\r\n        {\r\n            if(tasks[i].come_time&gt;time_temp)\r\n            {\r\n                time_temp=tasks[i].come_time;\r\n                poutput();\r\n                printf(\"\\n 新进程进入输入...任意字符继续......\");\r\n\t\t\t\tch=getchar();\r\n            }\r\n            if(tasks[i].run_flag==0)//该进程还未结束\r\n            {\r\n                if(tasks[i].start_flag==0)  //该条件成立则说明，该进程是第一次执行，记录开始执行时间\r\n                {\r\n                    tasks[i].run_begin_time=time_temp;\r\n                    tasks[i].start_flag=1;\r\n                }\r\n                if(tasks[i].run_time/time_counter&gt;1)//至少有两倍的时间片未执行\r\n                {\r\n                    tasks[i].run_time=tasks[i].run_time-time_counter;\r\n                    time_temp=time_temp+time_counter;\r\n                    tasks[i].runed_time = tasks[i].runed_time + (float)time_counter;//加上的不知道又没用 \r\n                    poutput();\r\n                    printf(\"\\n 执行一次时间片了..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n                else if(tasks[i].run_time-time_counter==0)\r\n                {\r\n                    time_temp=time_temp+time_counter;\r\n                    tasks[i].run_end_time=time_temp;\r\n                    tasks[i].run_flag=1;\r\n                    tasks[i].run_time=copy_task[i].run_time;\r\n                    tasks[i].runed_time = tasks[i].runed_time + (float)time_counter;//加上的不知道又没用 \r\n                    poutput();\r\n                    printf(\"\\n 任务完成..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n                else//仅剩下不足一倍的时间片\r\n                {\r\n                    time_temp=time_temp+tasks[i].run_time;\r\n                    tasks[i].runed_time = tasks[i].runed_time + tasks[i].run_time;//加上的不知道又没用 \r\n                    tasks[i].run_end_time=time_temp;\r\n                    tasks[i].run_flag=1;\r\n                    tasks[i].run_time=copy_task[i].run_time;\r\n                    \r\n                    poutput();\r\n                    printf(\"\\n 任务完成..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n \r\nint charge()//判断是否全部进程都执行完毕\r\n{\r\n    int k;\r\n    int super_flag=0;//判断是否全部的进程都执行完毕\r\n    for(k=0; k&lt;counter; k++)\r\n    {\r\n        if(tasks[k].run_flag==0)\r\n        {\r\n            super_flag=1;\r\n            return super_flag;\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            super_flag=0;\r\n        }\r\n    }\r\n    return super_flag;\r\n}\r\n \r\nint pinput() /*进程参数输入*/\r\n{\r\n\tprintf(\"*********************最高优先级优先算法**********************\\n\");\r\n    int i;\r\n    printf(\"请输入进程数量:\\n\");\r\n    scanf(\"%d\",&amp;counter);\r\n    printf(\"请输入时间片长度:\\n\");\r\n    scanf(\"%d\",&amp;time_counter);\r\n    for(i=0; i&lt;counter; i++)\r\n    {\r\n        printf(\"******************************************\\n\");\r\n        printf(\"请输入第 %d 个进程的信息 :\\n\",i+1);\r\n        printf(\"请输入进程的名字:\\n\");\r\n        scanf(\"%s\",tasks[i].name);\r\n        printf(\"请输入进程编号:\\n\");\r\n        scanf(\"%d\",&amp;tasks[i].number);\r\n        printf(\"请输入进程进入时间:\\n\");\r\n        scanf(\"%f\",&amp;tasks[i].come_time);\r\n        printf(\"请输入进程运行时间:\\n\");\r\n        scanf(\"%f\",&amp;tasks[i].run_time);\r\n        printf(\"进程优先级:\\n\");\r\n        scanf(\"%d\",&amp;tasks[i].priority);\r\n        tasks[i].run_begin_time=0;\r\n        tasks[i].run_end_time=0;\r\n        tasks[i].runed_time=0; //运行时间初始化 \r\n        tasks[i].run_flag=0;  //运行是否结束\r\n        tasks[i].start_flag=0;//是否首次被执行\r\n    }\r\n    return 0;\r\n}\r\n \r\nint poutput() /*调度结果输出*/\r\n{\r\n    int i;\r\n    float turn_round_time=0,f1,w=0;\r\n    printf(\"进程名 进程号 到达时间 需要运行时间 开始时间 结束时间 优先级 周转时间 运行时间 运行状态\\n\");\r\n    for(i=0; i&lt;counter; i++)\r\n    {\r\n        f1=tasks[i].run_end_time-tasks[i].come_time;\r\n        turn_round_time+=f1;\r\n        printf(\"%s\\t%d\\t%5.3f\\t%5.3f\\t    %5.3f\\t %5.3f\\t    %d\\t  %5.3f  %5.3f  %d\\n\",tasks[i].name,tasks[i].number,tasks[i].come_time,tasks[i].run_time,tasks[i].run_begin_time,tasks[i].run_end_time,tasks[i].priority,tasks[i].runed_time,f1,tasks[i].run_flag);\r\n    }\r\n    printf(\"average_turn_round_timer=%5.2f\\n\",turn_round_time/counter);\r\n    return 0;\r\n}\r\nvoid main(){\r\n\tint flag = 0;\r\n\tprintf(\"请输入算法规则（0是HPF-&gt;高优先级优先调度算法,1是RR-&gt;时间片轮转调度算法）：\\n\") ;\r\n\tscanf(\"%d\",&amp;flag);\r\n\tif (flag == 0){\r\n\t\tHPF();\r\n\t} else if(flag = 1){\r\n\t\tRR();\r\n\t} else{\r\n\t\tprintf(\"没有其他了算法\"); \r\n\t}\r\n\t\r\n}\r\n\r\n```", "Konwledge_Point": "优先队列实现", "Question": ["在Windows系统下用C/C++编程实现两种处理机调度算法。", ["\n", "CPU Scheduling\n(1)题目描述\n编程实现两种处理机调度算法，可选择的以下组合方式其中之- -: 1) 高优先级优先调度算法和时间片轮转调度算法; 2) 短进程优先调度算法和时间片轮转调度算法; 3) 先入先出调度算法和时间片轮转让调度算法。\n选择-一个调度算法，实现处理机调度。(2)功能实现\no输入提示选择哪种算法，例如:输入“0”--HPF，输入“1”--RR; )\n输入提示创建进程的个数，初始化进程;\nPCB内容:进程名/PID\n运行时间\n优先权\n状态\nPCB指针\n●运行过程中须提示所创建进程的状态信息，包括:已运行的时间,还需运行的时间，阻塞的时间，要阻塞多长时间;\n●提示进程的状态:运行，就绪，阻塞三者之- -;\n●建立进程的PCB， 用队列实现进程就绪队列和阻塞队列的管理。\n可随机输入若干进程，并按所选算法的规则排序，从就绪队首选进程运行，进程在运行过程中定时(或发生调度时)更新各进程的状态信息，\n进程名状态运行时间 剩余运行时间 优先级进程阻塞属性(有阻塞/无阻塞)\n规定系统可接纳的进程的道数，设置后备队列和挂起状态。若内存中进程少于规定道数，可自动从后备队列调度- -作业进入。\n被挂起进程入挂起队列，设置解挂功能用于将指定挂起进程解挂入就绪队列。", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;list&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;enum class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Priority&lt;/span&gt;\n{\n    Low,\n    Medium,\n    High\n};\n\n&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; T, &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List &amp;#61; std::list&amp;lt;std::pair&amp;lt;T, Priority&amp;gt;&amp;gt;&amp;gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; PriorityQueue\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; List list_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::value_type value_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::size_type size_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::iterator iterator;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::const_iterator const_iterator;\n\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;() : _high_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;()), _medium_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;()) {}\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; PriorityQueue &amp;amp;other) : _list(other._list)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n    }\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;(PriorityQueue &amp;amp;&amp;amp;other)\n        : _list(std::&lt;span class=\"hljs-built_in\"&gt;move&lt;/span&gt;(other._list))\n    {\n        &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n        other._high_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n        other._medium_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n    }\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; std::initializer_list&amp;lt;value_type&amp;gt; &amp;amp;list) : _high_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;()), _medium_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;[value, priority] : list)\n            &lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(value, priority);\n    }\n    ~&lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;() {}\n\n    PriorityQueue &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; PriorityQueue &amp;amp;other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; !&amp;#61; &amp;amp;other)\n        {\n            _list &amp;#61; other._list;\n            &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    PriorityQueue &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(PriorityQueue &amp;amp;&amp;amp;other)\n    {\n        _list &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;move&lt;/span&gt;(other._list);\n        &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n        other._high_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n        other._medium_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;const_iterator &lt;span class=\"hljs-title\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        const_iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;const_iterator &lt;span class=\"hljs-title\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        const_iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;empty&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _list.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;(); }\n\n    &lt;span class=\"hljs-function\"&gt;size_type &lt;span class=\"hljs-title\"&gt;size&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _list.&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(); }\n\n    &lt;span class=\"hljs-function\"&gt;size_type &lt;span class=\"hljs-title\"&gt;size&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        size_type sz &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            sz &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;distance&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;const_iterator&lt;/span&gt;(_medium_end), _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;());\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            sz &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;distance&lt;/span&gt;(_high_end, _medium_end);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            sz &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;distance&lt;/span&gt;(_list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), &lt;span class=\"hljs-built_in\"&gt;const_iterator&lt;/span&gt;(_high_end));\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sz;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;insert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; T &amp;amp;value, Priority priority)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n        {\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; sz_medium &amp;#61; &lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(Priority::Medium);\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; sz_low &amp;#61; &lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(Priority::Low);\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), std::&lt;span class=\"hljs-built_in\"&gt;make_pair&lt;/span&gt;(value, priority));\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sz_low &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                _medium_end &amp;#61; it;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sz_medium &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                    _high_end &amp;#61; it;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n        {\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; sz_medium &amp;#61; &lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(Priority::Medium);\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(_medium_end, std::&lt;span class=\"hljs-built_in\"&gt;make_pair&lt;/span&gt;(value, priority));\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sz_medium &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                _high_end &amp;#61; it;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(_high_end, std::&lt;span class=\"hljs-built_in\"&gt;make_pair&lt;/span&gt;(value, priority));\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;erase&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(iterator pos)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;erase&lt;/span&gt;(pos);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pos &amp;#61;&amp;#61; _high_end)\n            _high_end &amp;#61; it;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pos &amp;#61;&amp;#61; _medium_end)\n            _medium_end &amp;#61; it;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;remove&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; T &amp;amp;value)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            it &amp;#61; &lt;span class=\"hljs-built_in\"&gt;find_if&lt;/span&gt;(it, _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), [value](&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;v)\n                         { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v.first &amp;#61;&amp;#61; value; });\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (it &amp;#61;&amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            it &amp;#61; &lt;span class=\"hljs-built_in\"&gt;erase&lt;/span&gt;(it);\n        }\n    }\n\n    &lt;span class=\"hljs-function\"&gt;value_type &lt;span class=\"hljs-title\"&gt;front&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _list.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;();\n    }\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;init&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        _high_end &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;find_if&lt;/span&gt;(_list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), [](&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;v)\n                                 { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v.second !&amp;#61; Priority::High; });\n        _medium_end &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;find_if&lt;/span&gt;(_high_end, _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), [](&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;v)\n                                   { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v.second !&amp;#61; Priority::Medium; });\n    }\n\n    list_type _list;\n    iterator _high_end;\n    iterator _medium_end;\n};\n\nstd::ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream &amp;amp;os, Priority priority)\n{\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n    {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Low&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Medium&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;High&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; T, &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List&amp;gt;\nstd::ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream &amp;amp;os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; PriorityQueue&amp;lt;T, List&amp;gt; &amp;amp;q)\n{\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;{ &amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; priority : {Priority::High, Priority::Medium, Priority::Low})\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (priority !&amp;#61; Priority::High)\n            os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;, &amp;#34;&lt;/span&gt;;\n        os &amp;lt;&amp;lt; priority &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: [&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; it &amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(priority); it !&amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(priority); &amp;#43;&amp;#43;it)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (it !&amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(priority))\n                os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;, &amp;#34;&lt;/span&gt;;\n            os &amp;lt;&amp;lt; it-&amp;gt;first;\n        }\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;]&amp;#34;&lt;/span&gt;;\n    }\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;}&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    PriorityQueue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; q &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, Priority::Low}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, Priority::Medium}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, Priority::High}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, Priority::High}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, Priority::Medium}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, Priority::Low}};\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; std::endl;\n\n    PriorityQueue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; p1 &amp;#61; q;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after p1 &amp;#61; q:\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;p1 &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; std::endl;\n\n    PriorityQueue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; p2 &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;move&lt;/span&gt;(p1);\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after p2 &amp;#61; std::move(p1):\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;p2 &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p2 &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;p1 &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; std::endl;\n\n    q.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, Priority::High);\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after q.insert(5, Priority::Hight):\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; std::endl;\n\n    q.&lt;span class=\"hljs-built_in\"&gt;remove&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after q.remove(5):\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; std::endl;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q.front(): {&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;().first &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;, &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;().second &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;}&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;$ g&amp;#43;&amp;#43; -Wall -std&amp;#61;c&amp;#43;&amp;#43;&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.cpp&lt;/span&gt;\n$ ./&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.out&lt;/span&gt;\n&lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt; &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nafter p1 &amp;#61; &lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt;:\np1 &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nafter p2 &amp;#61; std::move(p1):\np2 &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\np1 &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[]&lt;/span&gt;}\nafter &lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.insert&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, Priority::Hight):\n&lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt; &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4, 5]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nafter &lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.remove&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;):\n&lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt; &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nfront: {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, High}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["创建一个基于单向线性列表的 \"具有整数优先级的队列\"。", ["当一个元素被插入时，它的优先级被设置，有三个固定值：低、中、高。一旦被放入队列，元素的优先级就不能改变。", "如果没有具有任何优先级的元素，那么指向尾部的相应指针必须为空。", "无参数的构造函数，复制，移动。", "  复制和移动分配运算符。", "确定队列中具有特定优先级的元素的数量和元素的总数量。", "检查是否有空队列。", "插入一个具有价值和优先权的元素。", "从队列中删除一个元素。", "获得关于队列头部元素的优先级和价值的信息。", "  通过菜单实现的头部程序应检查上述所有方法的操作。"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;stdlib.h&amp;gt;\n#define MAX_VERTEX_NUM 100\ntypedef struct ArcNode{\n\tint adjvex;//该边的另一个顶点的位置 \n\tstruct ArcNode *nextarc; //指向下一条边 \n}ArcNode;\ntypedef struct VNode{\n\tint data;//顶点的值 \n\tArcNode *firstarc;//指向第一条依附该顶点的边的指针 \n}VNode,AdjList[MAX_VERTEX_NUM];\ntypedef struct{\n\tAdjList vertices;//顶点数组 \n\tint vexnum,arcnum;\n}ALGraph;\nint LocateVex(ALGraph G,int v){//定位函数 \n\tfor(int i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n\t\tif(v&amp;#61;&amp;#61;G.vertices[i].data)return i;\n\t} \n}\nvoid CreateUDG(ALGraph &amp;amp;G){\n\tArcNode *p,*q;\n\tint i,j,k,v1,v2;\n\tprintf(&amp;#34;分别输入顶点个数和边的数目&amp;#xff1a;\\n&amp;#34;);\n\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;G.vexnum,&amp;amp;G.arcnum);\n\tprintf(&amp;#34;分别输入各个顶点值&amp;#xff1a;\\n&amp;#34;);\n\tfor(i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n\tscanf(&amp;#34;%d&amp;#34;,&amp;amp;G.vertices[i].data);\n\tG.vertices[i].firstarc&amp;#61;NULL;//初始化 \n\t} \n\tprintf(&amp;#34;分别输入各条边的两个顶点&amp;#xff1a;\\n&amp;#34;);\n\tfor(k&amp;#61;0;k&amp;lt;G.arcnum;k&amp;#43;&amp;#43;){\n\t\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;v1,&amp;amp;v2);\n\t\ti&amp;#61;LocateVex(G,v1);j&amp;#61;LocateVex(G,v2);//定位 \n\t\tp&amp;#61;(ArcNode*)malloc(sizeof(ArcNode));//申请一个结点 \n\t\tp-&amp;gt;adjvex&amp;#61;j;p-&amp;gt;nextarc&amp;#61;NULL;//赋值 \n\t\tp-&amp;gt;nextarc&amp;#61;G.vertices[i].firstarc;//连接结点 \n\t\tG.vertices[i].firstarc&amp;#61;p;//连接结点 \n\t\tq&amp;#61;(ArcNode*)malloc(sizeof(ArcNode));\n\t\tq-&amp;gt;adjvex&amp;#61;i;q-&amp;gt;nextarc&amp;#61;NULL;\n\t\tq-&amp;gt;nextarc&amp;#61;G.vertices[j].firstarc;\n\t\tG.vertices[j].firstarc&amp;#61;q;\n\t}\n}\nvoid PrintUDG(ALGraph G){//输出邻接表 \n    int i,j;\n\tfor(i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n\t\tprintf(&amp;#34;%d:&amp;#34;,i);\n\t\tArcNode *p;\n\t\tp&amp;#61;G.vertices[i].firstarc;\n\t\twhile(p!&amp;#61;NULL){\n\t\t\tprintf(&amp;#34;-&amp;gt;%d&amp;#34;,p-&amp;gt;adjvex);\n\t\t\tp&amp;#61;p-&amp;gt;nextarc;\n\t\t}\n\t\tprintf(&amp;#34;\\n&amp;#34;);\n\t}\n}\nint main(){\n\tALGraph G;\n\tCreateUDG(G);\n\tPrintUDG(G);\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;br /&gt;\n &lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["怎样实现无向图的创建算法", ["\n\n", "1、编写一个函数让用户输入这张图，用邻接表存储。", "\n2、编写函数实现此图的深度优先搜索遍历。", "\n3、编程实现循环队列，编写初始化、创建、入队、出队等算法。", "\n4、利用循环队列对图实现广度优先搜索遍历。"]], "Tag": "算法设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;windows.h&gt;\r\n#define MAXSIZE 100\r\ntypedef struct ElemType\r\n{\r\n\tint level;\r\n\tchar name[20];\r\n\tchar gender;\r\n\tchar ID[20];\r\n\r\n}QelemType;\r\ntypedef struct{\r\n\tQelemType *base;\r\n\tint front;\r\n\tint rear;\r\n}squene;\r\nvoid Initquene(squene *s){\r\n\ts-&gt;base=(QelemType *)malloc(MAXSIZE * sizeof(QelemType));\r\n\tif(!s-&gt;base)\r\n\t\texit(-1);\r\n\ts-&gt;front=0;\r\n\ts-&gt;rear=0;\r\n}\r\nvoid enquene(squene *s,QelemType e){\r\n\tif((s-&gt;rear+1)%MAXSIZE==s-&gt;front){\r\n\t\tprintf(\"duimanb\");\r\n\t\texit(0);\r\n\t}\r\n\ts-&gt;base[s-&gt;rear]=e;\r\n\ts-&gt;rear=(s-&gt;rear+1)%MAXSIZE;\r\n}\r\nvoid dequene(squene *s,QelemType *e){\r\n\tif(s-&gt;rear==s-&gt;front){\r\n\t\tprintf(\"栈空\");\r\n\t\texit(-1);\r\n\t}\r\n\t*e=s-&gt;base[s-&gt;front];\r\n\ts-&gt;front=(s-&gt;front+1)  % MAXSIZE;\r\n}\r\nint length(squene s){\r\n\treturn (s.rear-s.front+MAXSIZE) % MAXSIZE;\r\n}\r\n\r\nint main()\r\n{\r\n\tint i,j;\r\n\tint n;\r\n\tsquene Q1;\r\n\tQelemType *e,t;\r\n\tInitquene(&amp;Q1);\r\n\tprintf(\"请输入前来就诊的病人数量：\");\r\n\tscanf(\"%d\",&amp;n);\r\n\te = (QelemType *)malloc(n*sizeof(QelemType));\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tprintf(\"\\n请输入第%d个病人的优先级：\",i+1);\r\n\t\tscanf(\"%d\",&amp;e[i].level);\r\n\t\tprintf(\"\\n请输入第%d个病人的姓名：\",i+1);\r\n\t\tscanf(\"%s\",e[i].name);\r\n\t\tfflush(stdin);\r\n\t\tprintf(\"\\n请输入第%d个病人的性别：\",i+1);\r\n\t\tscanf(\"%c\",&amp;e[i].gender);\r\n\t\tprintf(\"\\n请输入第%d个病人的身份证：\",i+1);\r\n\t\tscanf(\"%s\",e[i].ID);\r\n\t}\r\n\r\n\tfor (i=0;i&lt;n-1;i++)\r\n\t{\r\n\t\tfor (j=0;j&lt;n-i-1;j++)\r\n\t\t{\r\n\t\t\tif (e[j].level&lt;e[j+1].level)\r\n\t\t\t{\r\n\t\t\t\tt = e[j];\r\n\t\t\t\te[j] = e[j+1];\r\n\t\t\t\te[j+1] = t;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (i=0;i&lt;n;i++)\r\n\t{\r\n\t\tenquene(&amp;Q1,e[i]);\r\n\t}\r\n\r\n\tfor (i=0;i&lt;n;i++)\r\n\t{\r\n\t\tdequene(&amp;Q1,&amp;t);\r\n\t\tprintf(\"办理业务 姓名：%s，身份证号：%s,性别：%c，优先级：%d\\n\", t.name,t.ID, t.gender,t.level);\r\n\t}\r\n\r\n\tfree(e);\r\n\te=NULL;\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n\r\n}\r\n\r\n```", "Konwledge_Point": "优先队列实现", "Question": ["医院排队就诊问题（C语言实现）求大神帮忙查看一下如何修改这些错误 （续）", ["问题描述：", "\n医院急诊科室，有医生1名", "\n现有病人7名，先后到达", "\n病人病情轻重各有不同（分3级，3级最重，1级最轻），重症的优先就诊；病症相同的，先来的先就诊。", "\n模型假设：", "\n1.病人挂完号后进入对应的科室，每位病人属性包括姓名，性别，和身份证号", "\n2.一开始的时候，医生空闲（等待病人）。", "\n3.有护士根据病人病情，给出病情优先级后，再排队。", "\n4.排队的病人按照先后次序排队，重症的优先就诊，病症相同的，先来的先就诊。。", "\n5.一位医生每次只能看一个病人。", "\n解决方案模型：", "\n1. 程序模拟医院排队就诊，程序开始输入病人资料（包括优先级，姓名，性别，和身份证号）。", "\n2. 设置一个病人的优先队列，按照优先级由高到低，分段排队，最开头的是优先级最高的病人；如果优先级相同，那么按照先来后到的顺序排队。", "\n3. 对病人队列有两种操作，pop与push，医生每次从病人队列里面pop一个病人，并打印病人信息（包括优先级，姓名，性别，和身份证号），直到队列空。", "\n\n", "\n", "请大佬继续补充回答", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;对给定图进行邻接表表示&amp;#xff0c;并利用队列和栈实现广度优先遍历和深度优先遍历的Python代码实现。同时&amp;#xff0c;程序还支持从键盘输入初始出发的顶点序号&amp;#xff0c;并在遍历过程中输出访问过的结点序号&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; collections &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; defaultdict, deque\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Graph&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, vertices&lt;/span&gt;):\n        self.graph &amp;#61; defaultdict(&lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;)\n        self.vertices &amp;#61; vertices\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;add_edge&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, u, v&lt;/span&gt;):\n        self.graph[u].append(v)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;print_graph&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; vertex &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph:\n            &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(vertex, &lt;span class=\"hljs-string\"&gt;&amp;#34;-&amp;gt;&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34; -&amp;gt; &amp;#34;&lt;/span&gt;.join(&lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;(i) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph[vertex]))\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;bfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, start_vertex&lt;/span&gt;):\n        visited &amp;#61; [&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;] * self.vertices\n        queue &amp;#61; deque()\n\n        visited[start_vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n        queue.append(start_vertex)\n\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; queue:\n            start_vertex &amp;#61; queue.popleft()\n            &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(start_vertex, end&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;)\n\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; vertex &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph[start_vertex]:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; visited[vertex]:\n                    visited[vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n                    queue.append(vertex)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, start_vertex&lt;/span&gt;):\n        visited &amp;#61; [&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;] * self.vertices\n        stack &amp;#61; []\n\n        visited[start_vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n        stack.append(start_vertex)\n\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; stack:\n            start_vertex &amp;#61; stack.pop()\n            &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(start_vertex, end&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;)\n\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; vertex &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph[start_vertex]:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; visited[vertex]:\n                    visited[vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n                    stack.append(vertex)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;traverse&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        start_vertex &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Enter the starting vertex: &amp;#34;&lt;/span&gt;))\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;BFS traversal: &amp;#34;&lt;/span&gt;)\n        self.bfs(start_vertex)\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nDFS traversal: &amp;#34;&lt;/span&gt;)\n        self.dfs(start_vertex)\n\n\n&lt;span class=\"hljs-comment\"&gt;# Create a sample graph&lt;/span&gt;\ng &amp;#61; Graph(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\n\n&lt;span class=\"hljs-comment\"&gt;# Print the graph&lt;/span&gt;\ng.print_graph()\n\n&lt;span class=\"hljs-comment\"&gt;# Traverse the graph&lt;/span&gt;\ng.traverse()\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;1&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;3&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Enter&lt;/span&gt; the starting vertex: &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;BFS&lt;/span&gt; traversal: \n&lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; \n&lt;span class=\"hljs-attribute\"&gt;DFS&lt;/span&gt; traversal: \n&lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; \n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["数据结构算法求详细解", ["5、对任意给定的图（顶点数和边数自定），建立它的邻接表并输出，利用队列的基本运算实现图的广度优先遍历；利用栈的基本运算实现图的深度优先遍历；从键盘输入初始出发的顶点的序号，要求在遍历过程中输出访问过的结点序号。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;main函数文件中的int visited[MaxSize];这一句注释掉。&lt;br /&gt;然后把 int visited[MaxSize];放在.h文件中(const int MaxSize &amp;#61; 10;     这一句下面)&amp;#xff0c;前面加extern就可以了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;extern&lt;/span&gt;  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[MaxSize];\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["为什么在main文件中定义的全局变量在类的函数实现文件中访问不到？（使用的VS编程工具）", ["问题遇到的现象和发生背景", "\n", "就是照着书上敲代码，然后发现和书上面即使是一样，却发生了bug", "\n", "问题相关代码，请勿粘贴截图", "\n", "//头文件", "\n", "#", "ifndef", " MGraph_H        ", "//避免重复包含MGraph.h文件", "\n", "#", "define", " MGraph_H", "\n\n", "const", " ", "int", " MaxSize = ", "10", ";        ", "//图中最多顶点个数", "\n\n", "template", "<", "class", " ", "DataType", ">\n", "class", " ", "MGraph", " {\n", "public", ":\n    ", "MGraph", "(DataType a[], ", "int", " n, ", "int", " e);    ", "//构造函数，建立有n个顶点e条边的图", "\n    ~", "MGraph", "() {};    ", "//析构函数", "\n    ", "void", " ", "DFSTraverse", "(", "int", " v)", ";        ", "//深度优先遍历", "\n    ", "void", " ", "BFSTraverse", "(", "int", " v)", ";        ", "//广度优先遍历", "\n", "private", ":\n    DataType vertex[MaxSize];    ", "//存放途中顶点的数组", "\n    ", "int", " arc[MaxSize][MaxSize];    ", "//存放途中边的数组", "\n    ", "int", " vertexNum, arcNum;        ", "//图的顶点数和边数", "\n};\n", "#", "endif", "\n\n", "//类函数实现类文件：", "\n", "#", "include", "<iostream>", "        ", "//引入输入输出流", "\n", "using", " ", "namespace", " std;\n", "#", "include", "\"MGraph.h\"", "        ", "//引入类MGraph的声明", "\n\n\n", "//以下是对类MGraph的成员函数定义", "\n", "template", " <", "class", " ", "DataType", ">\nMGraph<DataType>::", "MGraph", "(DataType a[], ", "int", " n, ", "int", " e) {\n    ", "int", " i, j, k;\n    vertexNum = n; arcNum = e;\n    ", "for", " (i = ", "0", "; i < vertexNum; i++) {    ", "//存储图的顶点信息", "\n        vertex[i] = a[i];\n    }\n    ", "for", "(i=", "0", ";i<vertexNum;i++)        ", "//初始化边的信息", "\n        ", "for", " (j = ", "0", "; j < vertexNum; j++) {\n            arc[i][j] = ", "0", ";\n        }\n    ", "for", " (k = ", "0", "; k < arcNum; k++) {        ", "//存储变得信息", "\n        cout << ", "\"请输入边的两个顶点序号：\"", ";\n        cin >> i >> j;\n        arc[i][j] = ", "1", "; arc[j][i] = ", "1", ";\n    }\n}\n\n", "template", "<", "class", " ", "DataType", ">\n", "void", " MGraph<DataType>::", "DFSTraverse", "(", "int", " v) {        ", "//深度优先遍历图", "\n    cout << vertex[v]; visited[v] = ", "1", ";\n    ", "for", " (", "int", " j = ", "0", "; j < vertexNum; j++)\n        ", "if", " (arc[v][j] == ", "1", " && visited[j] == ", "0", ")\n            ", "DFSTraverse", "(j);\n}\n\n", "template", "<", "class", " ", "DataType", ">\n", "void", " MGraph<DataType>::", "BFSTraverse", "(", "int", " v)        ", "//广度优先遍历图", "\n{\n    ", "int", " Q[MaxSize];    ", "//假设队列采用顺序存储且不会发生溢出", "\n    ", "int", " front = ", "-1", ", rear = ", "-1", ";        ", "//初始化队列", "\n    cout << vertex[v]; visited[v] = ", "1", "; Q[++rear] = v;        ", "//被访问点入队", "\n    ", "while", " (front != rear) {\n        v = Q[++front];\n        ", "for", " (", "int", " j = ", "0", "; j < vertexNum;j++) {\n            ", "if", " (arc[v][j] == ", "1", " && visited[j] == ", "0", ") {\n                cout << vertex[j]; visited[j]=", "1", "; Q[++rear] = j;\n            }\n        }\n    }\n}\n", "//main函数文件", "\n", "#", "include", "<iostream>", "        ", "//引入输入输出流", "\n", "using", " ", "namespace", " std;\n", "#", "include", "\"MGraph.cpp\"", "        ", "//引入类MGraph的成员函数定义", "\n\n ", "int", " visited[MaxSize];\n\n", "//以下是主函数", "\n", "int", " ", "main", "()", " ", "{\n    ", "char", " ch[] = {", "'A'", ",", "'B'", ",", "'C'", ",", "'D'", ",", "'E'", "};    ", "//定点信息", "\n    ", "MGraph<", "char", "> ", "MG", "(ch, ", "5", ", ", "6", ")", ";    ", "//图中顶点信息是char型", "\n    ", "for", " (", "int", " i = ", "0", "; i < MaxSize;i++) {    ", "//初始化图中所有顶点均未被访问", "\n        visited[i] = ", "0", ";\n    }\n    cout << ", "\"深度优先遍历序列是：\"", ";\n    MG.", "DFSTraverse", "(", "0", ");    ", "//从顶点0出发进行深度优先遍历图", "\n    cout << endl;\n    ", "for", " (", "int", " i = ", "0", "; i < MaxSize;i++) {        ", "//初始化途中所有顶点均未被访问", "\n        visited[i] = ", "0", ";\n    }\n    cout << ", "\"广度优先遍历序列是：\"", ";\n    MG.", "BFSTraverse", "(", "0", ");    ", "//从顶点0出发广度优先遍历图", "\n    cout << endl;\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "使用过将沈明visited放到函数实现类文件的头部，但是出现了其他bug，说是以及有声明了", "\n", "我想要达到的结果", "\n", "解决这visited问题"]], "Tag": "算法设计"}
{"Answer": "错误太多了，只能简单修改下编译错误\r\n\r\n```\r\n// Q1062027.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\n#define OK 1\r\n#define ERROR 0\r\nint M=0;\r\nint N=0;\r\ntypedef int Status;\r\ntypedef struct ElemType\r\n{\r\n    int level;\r\n    char name[20];\r\n    char gender;\r\n    char ID[20];\r\n\r\n}ElemType;\r\ntypedef struct Node   //结点结构\r\n{\r\n    ElemType data;\r\n    struct Node *next;\r\n}Node,*QueuePtr;\r\n\r\ntypedef struct\r\n{\r\n    QueuePtr front,rear;\r\n} LinkQueue;\r\n\r\nStatus InitQueue(LinkQueue **Q)  // 队列初始化\r\n{\r\n   QueuePtr p;\r\n   p=(QueuePtr)malloc(sizeof(QueuePtr));\r\n   if(!p)\r\n   {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n   }\r\n   *Q=(LinkQueue*)malloc(sizeof(LinkQueue));\r\n   if(!(*Q))\r\n   {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n   }\r\n   p-&gt;next=NULL;\r\n   (*Q)-&gt;front=p;\r\n   (*Q)-&gt;front=(*Q)-&gt;rear;\r\n   return OK;\r\n}\r\n\r\nStatus EnQueue(LinkQueue *Q, ElemType e)  //入队\r\n{\r\n    QueuePtr s=(QueuePtr)malloc(sizeof(Node));\r\n    if(!s)\r\n    {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n    }\r\n    s-&gt;data=e;\r\n    s-&gt;next=NULL;\r\n    Q-&gt;rear-&gt;next=s;      //把拥有元素e的新节点s赋值给队尾的后继节点\r\n    Q-&gt;rear=s;            //把当前s设置为队尾节点，rear指向s\r\n    return OK;\r\n}\r\n\r\nStatus DeQueue(LinkQueue *Q,ElemType *e)  //出队\r\n{\r\n    QueuePtr p;\r\n    if(Q-&gt;front==Q-&gt;rear)\r\n    {\r\n        printf(\"队列为空!\");\r\n        return ERROR;\r\n    }\r\n\r\n    p=Q-&gt;front-&gt;next;     //  将预删除的队头结点暂存给p\r\n    *e=p-&gt;data;             // 将删除的队头结点赋值给e 即出队\r\n    Q-&gt;front-&gt;next=p-&gt;next;  //  将原队头结点后继p-&gt;next 赋值给现投结点后继\r\n\r\n    if(Q-&gt;rear==p)\r\n    {\r\n        Q-&gt;rear=Q-&gt;front;      //若队头是队尾，则删除后将rear指向头结点\r\n\r\n    }\r\n     free(p);\r\n\r\n    return OK;\r\n}\r\n\r\nStatus PriorEnQueue(LinkQueue *Q1,LinkQueue *Q2,ElemType e)\r\n{\r\n    if(e.level==3)\r\n       {\r\n           EnQueue(Q1,e);\r\n       }\r\n    else\r\n       {\r\n          EnQueue(Q2,e);\r\n       }\r\n\r\n        return OK;\r\n\r\n}\r\n\r\n\r\nStatus PriorDeQueue(LinkQueue*Q1,LinkQueue*Q2)\r\n{\r\n    ElemType e;\r\n    if(!(Q2-&gt;front==Q2-&gt;rear))\r\n       DeQueue(Q2,&amp;e);\r\n    else if(!(Q1-&gt;front==Q1-&gt;rear))\r\n       DeQueue(Q1,&amp;e);\r\n    else\r\n    {\r\n        return ERROR;\r\n    }\r\n    return OK;\r\n\r\n}\r\n\r\nStatus GetIN(LinkQueue*Q1,LinkQueue*Q2,ElemType*e)\r\n{\r\n    int i;\r\n    int n;\r\n    printf(\"请输入前来就诊的病人数量：\");\r\n    scanf(\"%d\",&amp;n);\r\n    for(i=M;i&lt;M+n;i++)\r\n    {\r\n        printf(\"\\n请输入第%d个病人的优先级：\",i+1);\r\n        scanf(\"%d\",&amp;e[i].level);\r\n        printf(\"\\n请输入第%d个病人的姓名：\",i+1);\r\n        scanf(\"%s\",e[i].name);\r\n        printf(\"\\n请输入第%d个病人的性别：\",i+1);\r\n        scanf(\"%s\",&amp;e[i].gender);\r\n        printf(\"\\n请输入第%d个病人的身份证：\",i+1);\r\n        scanf(\"%s\",e[i].ID);\r\n        PriorEnQueue(Q1,Q2,e[i]);\r\n    }\r\n    M=M+n;\r\n    return OK;\r\n}\r\nStatus ShowInformation(ElemType *e)\r\n{\r\n    int i;\r\n    LinkQueue *Q1,*Q2;\r\n    InitQueue(&amp;Q1);\r\n    InitQueue(&amp;Q2);\r\n    PriorDeQueue(Q1,Q2);\r\n    printf(\"优先级----------姓名----------性别----------身份证\\n\");\r\n    for(i=N;i&lt;N;i++)\r\n    {\r\n        printf(\"\\n\");\r\n        printf(\"%5d %5s %5s %10s\",e[i].level,e[i].name,&amp;e[i].gender,e[i].ID);\r\n    }\r\n    return OK;\r\n}\r\nint main()\r\n{\r\n    LinkQueue Q1,Q2;\r\n\tQ1.front=Q1.rear=NULL;\r\n\tQ2.front=Q2.rear=NULL;\r\n    ElemType e;\r\n    GetIN(&amp;Q1,&amp;Q2,&amp;e);\r\n    ShowInformation(&amp;e);\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n```\r\n# 问题采纳了可以继续帮你看运行的错误", "Konwledge_Point": "优先队列实现", "Question": ["医院排队就诊问题（C语言实现）求大神帮忙查看一下如何修改这些错误", ["问题描述：", "\n医院急诊科室，有医生1名", "\n现有病人7名，先后到达", "\n病人病情轻重各有不同（分3级，3级最重，1级最轻），重症的优先就诊；病症相同的，先来的先就诊。", "\n模型假设：", "\n1.病人挂完号后进入对应的科室，每位病人属性包括姓名，性别，和身份证号", "\n2.一开始的时候，医生空闲（等待病人）。", "\n3.有护士根据病人病情，给出病情优先级后，再排队。", "\n4.排队的病人按照先后次序排队，重症的优先就诊，病症相同的，先来的先就诊。。", "\n5.一位医生每次只能看一个病人。", "\n解决方案模型：", "\n1. 程序模拟医院排队就诊，程序开始输入病人资料（包括优先级，姓名，性别，和身份证号）。", "\n2. 设置一个病人的优先队列，按照优先级由高到低，分段排队，最开头的是优先级最高的病人；如果优先级相同，那么按照先来后到的顺序排队。", "\n3. 对病人队列有两种操作，pop与push，医生每次从病人队列里面pop一个病人，并打印病人信息（包括优先级，姓名，性别，和身份证号），直到队列空。", "\n————————————————", "\n运行输入：", "\n请按照优先级，姓名，性别，和身份证号顺序输入：", "\n1 吕雅畅 男 141130198509277099", "\n1 卞丹丹 女 532925197204181629", "\n2 潘德茂 男 500114197005227938", "\n1 邬碧玉 女 620721198202232320", "\n3 金慧雅 女 533123198508252640", "\n2 岑俊茂 男 152526198707214777", "\n3 毕采萱 女 420600198202107509", "\n\n", "输出：", "\n就诊顺序......", "\n3 金慧雅 女 533123198508252640", "\n3 毕采萱 女 420600198202107509", "\n2 潘德茂 男 500114197005227938", "\n2 岑俊茂 男 152526198707214777", "\n1 吕雅畅 男 141130198509277099", "\n1 卞丹丹 女 532925197204181629", "\n1 邬碧玉 女 620721198202232320", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define OK 1\n#define ERROR 0\nint M=0;\nint N=0;\ntypedef int Status;\ntypedef struct ElemType\n{\n    int level;\n    char name[20];\n    char gender;\n    char ID[20];\n\n}ElemType;\ntypedef struct Node   //结点结构\n{\n    ElemType data;\n    struct Node *next;\n}Node,*QueuePtr;\n\ntypedef struct\n{\n    QueuePtr front,rear;\n} LinkQueue;\n\nStatus InitQueue(LinkQueue *Q)  // 队列初始化\n{\n   QueuePtr p;\n   p=(QueuePtr)malloc(sizeof(QueuePtr));\n   if(!p)\n   {\n       printf(\"内存分配失败\");\n       return ERROR;\n   }\n   Q=(LinkQueue*)malloc(sizeof(LinkQueue));\n   if(!Q)\n   {\n       printf(\"内存分配失败\");\n       return ERROR;\n   }\n   p->next=NULL;\n   Q->front=p;\n   Q->front=Q->rear;\n   return OK;\n}\n\nStatus EnQueue(LinkQueue *Q, ElemType e)  //入队\n{\n    QueuePtr s=(QueuePtr)malloc(sizeof(Node));\n    if(!s)\n    {\n       printf(\"内存分配失败\");\n       return ERROR;\n    }\n    s->data=e;\n    s->next=NULL;\n    Q->rear->next=s;      //把拥有元素e的新节点s赋值给队尾的后继节点\n    Q->rear=s;            //把当前s设置为队尾节点，rear指向s\n    return OK;\n}\n\nStatus DeQueue(LinkQueue *Q,ElemType *e)  //出队\n{\n    QueuePtr p;\n    if(Q->front==Q->rear)\n    {\n        printf(\"队列为空!\");\n        return ERROR;\n    }\n\n    p=Q->front->next;     //  将预删除的队头结点暂存给p\n    *e=p->data;             // 将删除的队头结点赋值给e 即出队\n    Q->front->next=p->next;  //  将原队头结点后继p->next 赋值给现投结点后继\n\n    if(Q->rear==p)\n    {\n        Q->rear=Q->front;      //若队头是队尾，则删除后将rear指向头结点\n\n    }\n     free(p);\n\n    return OK;\n}\n\nStatus PriorEnQueue(LinkQueue *Q1,LinkQueue *Q2,ElemType *e)\n{\n    if(e->level==3)\n       {\n           EnQueue(Q1,e);\n       }\n    else\n       {\n          EnQueue(Q2,e);\n       }\n\n        return OK;\n\n}\n\n\nStatus PriorDeQueue(LinkQueue*Q1,LinkQueue*Q2)\n{\n    ElemType *e;\n    if(!(Q2->front==Q2->rear))\n       e=DeQueue(Q2,e);\n    else if(!(Q1->front==Q1->rear))\n        e=DeQueue(Q1,e);\n    else\n    {\n        return ERROR;\n    }\n    return OK;\n\n}\n\nStatus GetIN(LinkQueue*Q1,LinkQueue*Q2,ElemType*e)\n{\n    int i;\n    int n;\n    printf(\"请输入前来就诊的病人数量：\");\n    scanf(\"%d\",&n);\n    for(i=M;i<M+N;i++)\n    {\n        printf(\"\\n请输入第%d个病人的优先级：\",i+1);\n        scanf(\"%d\",&e[i].level);\n        printf(\"\\n请输入第%d个病人的姓名：\",i+1);\n        scanf(\"%s\",e[i].name);\n        printf(\"\\n请输入第%d个病人的性别：\",i+1);\n        scanf(\"%s\",&e[i].gender);\n        printf(\"\\n请输入第%d个病人的身份证：\",i+1);\n        scanf(\"%s\",e[i].ID);\n        PriorEnQueue(Q1,Q2,e);\n    }\n    M=M+n;\n    return OK;\n}\nStatus ShowInformation(ElemType *e)\n{\n    int i;\n    LinkQueue *Q1,*Q2;\n    InitQueue(Q1);\n    InitQueue(Q2);\n    PriorDeQueue(Q1,Q2);\n    printf(\"优先级----------姓名----------性别----------身份证\\n\");\n    for(i=N;i<N;i++)\n    {\n        printf(\"\\n\");\n        printf(\"%5d %5s %5s %10s\",e[i].level,e[i].name,&e[i].gender,e[i].ID);\n    }\n    return OK;\n}\nint main()\n{\n    LinkQueue *Q1,*Q2;\n    ElemType *e;\n    GetIN(Q1,Q2,e);\n    ShowInformation(e);\n    return 0;\n\n}\n\n\n\n\n\n\n", "\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;操作符和f_dis函数加上const修饰&amp;#xff0c;代码修改如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;cstdio&amp;gt;\n#include&amp;lt;cmath&amp;gt;\n#include&amp;lt;queue&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\nconst int N&amp;#61;100,M&amp;#61;100;\nint n,m;\nbool map[N][M]; \nclass map\n{\nprivate:\n\tbool **p;\n\tint n,m;\n\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t{\n\t\treturn (((i&amp;gt;&amp;#61;((x1&amp;gt;x2)?x2:x1))&amp;amp;&amp;amp;(i&amp;lt;&amp;#61;((x1&amp;gt;x2)?x1:x2)))&amp;amp;&amp;amp;((j&amp;gt;&amp;#61;((y1&amp;gt;y2)?y2:y1))&amp;amp;&amp;amp;(j&amp;lt;&amp;#61;((y1&amp;gt;y2)?y1:y2))));\n\t}\n\tstruct point\n\t{\n\t\tstatic int tar_x,tar_y;\n\t\tint x,y,b_dis;\n\t\tint f_dis() const  //修改1\n\t\t{\n\t\t\treturn abs(x-tar_x)&amp;#43;abs(y-tar_y);\n\t\t}\n\t\tbool operator&amp;lt;(const point b)const   //修改2\n\t\t{\n\t\t\treturn (b_dis&amp;#43;f_dis())&amp;gt;(b.b_dis&amp;#43;b.f_dis());\n\t\t}\n\t};\npublic:\n\tmap(const int N,const int M)\n\t{\n\t\tn&amp;#61;N;\n\t\tm&amp;#61;M;\n\t\tp&amp;#61;new bool*[N&amp;#43;1];\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;N;i&amp;#43;&amp;#43;)\n\t\t\tp[i]&amp;#61;new bool[M&amp;#43;1];\n\t}\n\t~map()\n\t{\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\t\t\tdelete[] p[i];\n\t\tdelete[] p;\n\t}\n\tvoid set_obstruction(const int x,const int y)\n\t{\n\t\tp[x][y]&amp;#61;true;\n\t\treturn;\n\t}\n\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\t\t\tfor(int j&amp;#61;1;j&amp;lt;&amp;#61;m;j&amp;#43;&amp;#43;)\n\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\tp[i][j]&amp;#61;true;\n\t\treturn;\n\t}\n\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tpriority_queue&amp;lt;point&amp;gt; q;\n\t\tpoint::tar_x&amp;#61;x2;\n\t\tpoint::tar_y&amp;#61;y2;\n\t\tpoint start;\n\t\tstart.x&amp;#61;x1;\n\t\tstart.y&amp;#61;y1;\n\t\tq.push(start);\n\t}\n};\nint main()\n{\n\n\treturn 0;\n}\n//我想写一个A*寻路实现&amp;#xff0c;但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了&amp;#xff08;555~~&amp;#xff09;&amp;#xff0c;求大佬告知怎么改啊&amp;#xff1f; &lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["以下这段C++代码为啥跑不了？", ["\n", "#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int N=100,M=100;\nint n,m;\nbool map[N][M]; \nclass map\n{\n\tprivate:\n\t\tbool **p;\n\t\tint n,m;\n\t\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t\t{\n\t\t\treturn (((i>=((x1>x2)?x2:x1))&&(i<=((x1>x2)?x1:x2)))&&((j>=((y1>y2)?y2:y1))&&(j<=((y1>y2)?y1:y2))));\n\t\t}\n\t\tstruct point\n\t\t{\n\t\t\tstatic int tar_x,tar_y;\n\t\t\tint x,y,b_dis;\n\t\t\tint f_dis()\n\t\t\t{\n\t\t\t\treturn abs(x-tar_x)+abs(y-tar_y);\n\t\t\t}\n\t\t\tbool operator<(point b)\n\t\t\t{\n\t\t\t\treturn (b_dis+f_dis())>(b.b_dis+b.f_dis());\n\t\t\t}\n\t\t};\n\tpublic:\n\t\tmap(const int N,const int M)\n\t\t{\n\t\t\tn=N;\n\t\t\tm=M;\n\t\t\tp=new bool*[N+1];\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tp[i]=new bool[M+1];\n\t\t}\n\t\t~map()\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tdelete[] p[i];\n\t\t\tdelete[] p;\n\t\t}\n\t\tvoid set_obstruction(const int x,const int y)\n\t\t{\n\t\t\tp[x][y]=true;\n\t\t\treturn;\n\t\t}\n\t\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\t\tp[i][j]=true;\n\t\t\treturn;\n\t\t}\n\t\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tpriority_queue<point> q;\n\t\t\tpoint::tar_x=x2;\n\t\t\tpoint::tar_y=y2;\n\t\t\tpoint start;\n\t\t\tstart.x=x1;\n\t\t\tstart.y=y1;\n\t\t\tq.push(start);\n\t\t}\n};\nint main()\n{\n\t\n\treturn 0;\n}\n//我想写一个A*寻路实现，但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了（555~~），求大佬告知怎么改啊？ "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;具体的步骤如下:&lt;/p&gt;\n&lt;p&gt;1.启动Netty服务&amp;#xff0c;运行上面给出的启动代码&lt;br /&gt;2.启动WireShark&amp;#xff0c;并选择本机网卡上的流量&lt;br /&gt;3.进行过滤&amp;#xff0c;比如过滤出Netty服务端口为8085的流量&lt;br /&gt;4.开始抓包&amp;#xff0c;并分析抓取到的包&lt;br /&gt;5.需要注意的是&amp;#xff0c;WireShark需要管理员权限运行&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;如果遇到问题&amp;#xff0c;检查以下几点&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1.依赖库是否正确引入&lt;br /&gt;2.网络是否正常&lt;br /&gt;3.端口是否被占用&lt;br /&gt;4.是否有其他程序正在使用相同的端口&lt;br /&gt;5.是否有权限启动服务&lt;br /&gt;6.配置文件是否正确&lt;br /&gt;仅供参考&amp;#xff0c;望采纳&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["Netty怎么用WireShark抓包呢", ["Netty怎么用WireShark抓包呢？", "\n", "这是启动的代码", "\n", "@ServiceScan", "\n", "public", " ", "class", " ", "Server", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n        ", "try", " {\n            ", "NettyServer", " nettyServer = ", "new", " ", "NettyServer", "(", "\"192.168.10.1\"", ", ", "8085", ", ", "SerializerCode", ".", "HESSIAN", ".", "getCode", "());\n            nettyServer.", "start", "();\n        } ", "catch", " (", "RpcException", " e) {\n            e.", "printStackTrace", "();\n        }\n    }\n}\n", "\n", "@Slf4j\npublic ", "class", " NettyServer extends AbstractRpcServer {\n\n\n    ", "/**\n     * 服务器启动时 优先做一些预加载\n     */", "\n    \n    ", "/**\n     *\n     * @param hostName 启动服务所在机器的主机号，可以是私网或者公网\n     * @param port 启动服务所在机器的端口号\n     * @param serializerCode 序列化代码\n     * @throws RpcException\n     */", "\n    public ", "NettyServer(String ", "hostName", ", ", "int", " ", "port", ", Integer ", "serializerCode", ")", " throws RpcException {\n        this.hostName = hostName.equals(", "\"localhost\"", ")", " || ", "hostName.equals(", "\"127.0.0.1\"", ") ? ", "IpUtils", ".", "get", "PubIpAddr()", " : hostName;\n        log.info(", "\"start with host: {}, port: {}\"", ", this.hostName, port);\n        this.port = port;\n        ", "//serviceRegistry = new NacosServiceRegistry();", "\n        ", "//serviceProvider = new DefaultServiceProvider();", "\n        ", "/**\n         * 使用 SPI 机制，接口与实现类解耦到配置文件\n         */", "\n        serviceRegistry = ", "ServiceLoader", ".", "load(", "ServiceRegistry", ".", "class", ").iterator", "()", ".next", "()", ";\n        serviceProvider = ", "ServiceLoader", ".", "load(", "ServiceProvider", ".", "class", ").iterator", "()", ".next", "()", ";\n\n        serializer = ", "CommonSerializer", ".", "get", "ByCode(", "serializerCode", ")", ";\n        ", "// 扫描 @ServiceScan 包下的 所有 @Service类，并 注册它们", "\n        scan", "Services()", ";\n    }\n\n    @Override\n    public void start", "()", " {\n        ", "/**\n         *  封装了 之前 使用的 线程吃 和 任务队列\n         *  实现了 ExecutorService 接口\n         */", "\n        ", "ShutdownHook", ".", "get", "ShutdownHook()", ".add", "ClearAllHook()", ";\n        EventLoopGroup bossGroup = ", "new", " ", "NioEventLoopGroup()", ";\n        EventLoopGroup workerGroup = ", "new", " ", "NioEventLoopGroup()", ";\n\n        ", "try", " {   \n            ", "/**\n             *  启动服务\n             */", "\n            ServerBootstrap serverBootstrap = ", "new", " ", "ServerBootstrap()", ";\n            serverBootstrap.group(bossGroup, workerGroup)\n                    .channel(", "NioServerSocketChannel", ".", "class", ")\n                    .handler(", "new", " ", "LoggingHandler(LogLevel.INFO)", ")\n                    .option(ChannelOption.SO_BACKLOG, ", "256", ")\n                    .option(ChannelOption.SO_KEEPALIVE, ", "true", ")\n                    .child", "Option(ChannelOption.TCP_NODELAY, ", "true", ")", "\n                    .child", "Handler(", "new", " ChannelInitializer<SocketChannel>()", " {\n                        @Override\n                        protected void init", "Channel(SocketChannel ", "ch", ")", " throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline", "()", ";\n                            ", "/**\n                             * 读 超时 触发, WriteIdleTime 和 allIdleTime 为 0 表示不做处理\n                             */", "\n                            pipeline.add", "Last(", "new", " IdleStateHandler(30, 0, 0, TimeUnit.SECONDS)", ");\n                            pipeline.add", "Last(", "new", " CommonEncoder(", "serializer", ")", ");\n                            pipeline.add", "Last(", "new", " CommonDecoder()", ");\n                            pipeline.add", "Last(", "new", " NettyServerHandler()", ");\n                        }\n                    });\n            ChannelFuture future = serverBootstrap.bind(port).sync", "()", ";\n            future.channel", "()", ".close", "Future()", ".sync", "()", ";\n\n        } catch (Exception e) {\n            log.error(", "\"Error occurred while starting server! {}\"", ",e);\n            e.print", "StackTrace()", ";\n        } finally {\n            bossGroup.shutdown", "Gracefully()", ";\n            workerGroup.shutdown", "Gracefully()", ";\n        }\n    }\n\n}\n", "\n", "Wireshark怎么抓呀，我一直没抓到", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/679629798646139.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;兄弟新加的程序位置应该在输入函数&amp;#xff0c;而不是打印函数啊&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["想先删掉链表里的VIP客户再删掉Ordinary客户该怎么写delete函数？", ["问题描述", "注意：用链表完成", "现在银行都有排队叫号系统，如果你到银行去办理业务，首先取得一个顺序号，并告诉你前面有多少人在等待。", "现在请你设计、并实现该系统。", "\n", "客户信息包括：取号的号码、客户银行卡号码、客户类型（包括普通客户和vip客户，分别用Ordinary和VIP表示）。", "VIP用户有优先权，即VIP入队时，可以插入到  所有Ordinary类型用户的前面，已经排队的最后一个VIP用户的后面。", "\n", "本题要求实现以下功能：", "（1）客户进入银行并取号，该功能对应的命令为IN number type，number表示客户银行卡号码，type表示客户类型。", "（2）在上一题基础上，按取号顺序列出当前未办理业务的客户信息，该功能对应的命令为LIST。", "（3）客户办理完业务并离开银行，该功能对应的命令为OUT。", "（4）退出系统，该功能对应的命令为QUIT。", "\n", "输入", "输入有多行，每行表示一种操作。", "\n", "本题实现的操作有：", "IN guestnumber guesttype", "其中IN 表示入队，guestnumber表示客户银行卡号码，guesttype有两种取值，分别为Ordinary和VIP，表示普通客户与VIP客户。", "\n", "LIST", "按取号的顺序输出队列中所有排队的客户信息。", "\n", "QUIT", "退出银行排队系统", "\n", "请注意：输入的数据中，只有最后一个命令是QUIT命令。", "输出", "输出有多行，对不同的命令给出不同的输出。", "\n", "以下是具体的输出说明：", "IN 客户银行卡号码　客户类型", "该命令首先在单独的一行中输出\"IN:\", 然后再输出客户信息。", "客户信息包括客户编号 客户银行卡号码　客户类型 该客户前面的客户数。客户编号由系统在客户取号的时候给定，从1开始顺序编号。", "客户类型分为Ordinary和VIP。数据之间用一个空格分开。", "\n", "请注意：", "第一个客户入队后，则该用户的顺序号为1，前面有0个客户等待；", "第二个客户入队后，则该用户的顺序号为2，前面有1个客户等待。", "以此类推。", "\n", "LIST", "该命令首先在单独的一行中输出\"LIST:\", 后面有若干行先按客户类型（VIP优先），再按客户取号的顺序输出，每一行输出一个客户的信息，每行的输出格式为", "客户编号 客户银行卡号码 客户类型", "\n", "OUT", "该命令首先在单独的一行中输出\"OUT:\"，接下来一行输出办理业务的客户信息，包括顺序号，客户银行卡号码和客户类型。", "如果没有办理业务的客户，则输出\"FAILED:\"。", "\n", "QUIT", "在单独的一行中显示\"GOOD BYE!\"后结束程序。", "输入样列", "IN 1000001 Ordinary", "IN 2000003 VIP", "IN 2000009 VIP", "OUT", "OUT", "OUT", "OUT", "IN 1000007 Ordinary", "IN 2000005 VIP", "LIST", "OUT", "QUIT", "\n", "输出样例", "IN:1 1000001 Ordinary 0", "IN:2 2000003 VIP 0", "IN:3 2000009 VIP 1", "OUT:2 2000003 VIP", "OUT:3 2000009 VIP", "OUT:1 1000001 Ordinary", "FAILED:", "IN:4 1000007 Ordinary 0", "IN:5 2000005 VIP 0", "LIST:", "5 2000005 VIP", "4 1000007 Ordinary", "OUT:5 2000005 VIP", "GOOD BYE!", "\n", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "typedef", " ", "struct", " ", "Client", "{\n    ", "int", " sernumber;\n    ", "char", " guestnumber[", "20", "];\n    ", "char", " guesttype[", "20", "];\n    ", "struct", " ", "Client", " *next;\n}", "Client", ";\n", "int", " n=", "0", ";\n", "int", " wait1=", "0", ",wait2=", "0", ";\n", "int", " out1=", "0", ",out2=", "0", ";\n", "void", " ", "inputSingle", "(", "Client", " *s)", "\n", "{\n    ", "scanf", "(", "\"%s %s\"", ",s->guestnumber,s->guesttype);\n}\n", "void", " ", "outputSingle", "(", "Client", " *s)", "\n", "{\n    n+=", "1", ";\n    s->sernumber=n;\n    ", "if", "(", "strcmp", "(s->guesttype,", "\"VIP\"", ")==", "0", "){\n        ", "printf", "(", "\"%d %s %s %d\\n\"", ",s->sernumber,s->guestnumber,s->guesttype,wait1-out1);\n        wait1++;\n    }\n    ", "if", "(", "strcmp", "(s->guesttype,", "\"Ordinary\"", ")==", "0", "){\n        ", "printf", "(", "\"%d %s %s %d\\n\"", ",s->sernumber,s->guestnumber,s->guesttype,wait2-out1-out2);\n        wait2++;\n    }\n}\n", "void", " ", "outputList", "(", "Client", " *L)", "\n", "{\n    ", "Client", " *p;\n    p=L->next;\n    ", "while", "(p!=", "NULL", "){\n        ", "outputSingle", "(p);\n        p=p->next;\n    }\n}\n", "void", " ", "insert", "(", "Client", " *L,", "Client", " *s)", "\n", "{\n    ", "Client", " *pre,*p;\n    pre=L;\n    p=L->next;\n    ", "while", "(p!=", "NULL", "){\n        pre=p;\n        p=p->next;\n    }\n    s->next=pre-next;\n    pre->next=s;\n}\n", "int", " ", "delete", "(", "Client", " *L,", "Client", " *s)", "\n", "{\n    ", "Client", " *pre,*p;\n    pre=L;\n    p=L->next;\n    ", "while", "(p!=", "NULL", "&&", "strcmp", "(p->guesttype,", "\"VIP\"", ")==", "0", "){\n        pre->next=p->next;\n        ", "free", "(p);\n        out1++;\n    }\n    ", "if", "(p==", "NULL", "){\n        ", "return", " ", "0", ";\n    }\n    ", "else", "{\n        pre=p;\n        p=p->next;\n    }\n}\n", "Client", "* ", "createList", "()", "\n", "{\n    ", "Client", " *L;\n    L=(", "Client", " *)", "malloc", "(", "sizeof", "(", "Client", "));\n    L->next=", "NULL", ";\n    ", "return", " L;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "Client", " *s,*L;\n    string order;\n    ", "while", "(", "1", "){\n        cin>>order;\n        ", "if", "(order==", "\"IN\"", "){\n            ", "printf", "(", "\"IN:\"", ");\n            s=(", "Client", " *)", "malloc", "(", "sizeof", "(", "Client", "));\n            ", "inputSingle", "(s);\n            ", "outputSingle", "(s);\n        }\n        ", "if", "(order==", "\"LIST\"", "){\n            ", "puts", "(", "\"LIST:\"", ");\n            ", "outputList", "(L);\n        }\n        ", "if", "(order==", "\"OUT\"", "){\n            \n        }\n    }\n    ", "return", " ", "0", ";\n}\n", "\n", "暂时只写了这些，我想能不能遍历链表两遍，先删掉VIP再删掉Ordinary呢？但是我不知道咋写"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你看下这篇博客吧, 应该有用&amp;#x1f449; &amp;#xff1a;&lt;a href=\"https://blog.csdn.net/zhaoyangjian724/article/details/122755481?utm_source&amp;#61;csdn_ai_ada_ask_robot\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;java中的空指针异常&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "优先队列实现", "Question": ["空指针异常 java.lang，如何解决？", ["java.lang.NullPointerException", "空指针异常 找了半天没找到", "有会的指导一下吗", "java.lang.NullPointerException", "\n", "package Search;", "\n", "import java.io.IOException;", "import java.util.Scanner;", "\n", "public class Chuanyueleichi1 {", "    /*", "     * 题目描述", "    X星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，", "    否则将报废。", "    某坦克需要从A区到B区去（A，B区本身是安全区，没有正能量或负能量特征），", "    怎样走才能路径最短？", "\n", "已知的地图是一个方阵，上面用字母标出了A，B区，\n其它区都标了正号或负号分别表示正负能量辐射区。\n例如：\nA + - + -\n- + - - +\n- + + + -\n+ - + - +\nB + - + -\n\n坦克车只能水平或垂直方向上移动到相邻的区。\n\n输入格式\n输入第一行是一个整数n，表示方阵的大小， ", "4", "<=n<", "100", "\n接下来是n行，每行有n个数据，可能是A，B，+，-中的某一个，中间用空格分开。\nA，B都只出现一次。\n输出格式\n要求输出一个整数，表示坦克从A区到B区的最少移动步数。\n如果没有方案，则输出", "-1", "\n\n样例输入\n", "5", "\nA + - + -\n- + - - +\n- + + + -\n+ - + - +\nB + - + -\n样例输出\n", "10", "\n\n思想\n", "1.", "图的广度优先算法 直接算出最短路径所用，数据结构 队列（在chuanyueleichi2中具体实现）\n", "2.", "图的深度优先算法 遍历所有路径，求出最小路径（具体在本类实现）\n\n\n步骤\n一.建立全局变量\n    ", "1.", "坐标（x，y）\n    ", "2.", "当前区域辐射值\n    ", "3.", "达到该区所走步数\n二.输入，初始化节点\n    ", "1.", "找到A区位置，并赋值给dfs入口\n三.dfs建立\n    ", "1.", "注意回溯\n*/\n", "public", " ", "static", " ", "String", "[][] arr  = ", "new", " ", "String", "[", "101", "][", "101", "] ;\n", "public", " ", "static", " ", "int", " n = ", "0", ";", "//雷区大小", "\n", "public", " ", "static", " ", "int", " x =", "0", ",y =", "0", ";\n", "public", " ", "static", " ", "int", " min = ", "0", ";", "//记录到达B区最小步数", "\n", "public", " ", "static", " ", "int", "[][] visit =  ", "new", " ", "int", "[", "101", "][", "101", "];", "//标记已走过的雷区 初始值为0 表示都没走过", "\n", "public", " ", "static", " ", "int", " []fx = {", "1", ",", "0", ",", "-1", ",", "0", "};\n", "public", " ", "static", " ", "int", " []fy = {", "0", ",", "-1", ",", "0", ",", "-1", "};", "//表示移动方向分别是 下 右 上 左", "\n", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args)", " throws NumberFormatException, IOException ", "{\n    ", "// TODO Auto-generated method stub", "\n    \n    Scanner sc = ", "new", " ", "Scanner", "(System.in);\n     n = sc.", "nextInt", "();", "//雷区大小", "\n    ", "int", " a = ", "0", ",b=", "0", ";\n    ", "//arr = new String[n+1][n+1];", "\n    ", "//visit = new int[n+1][n+1];", "\n    ", "for", "(", "int", " i = ", "1", " ; i <= n; i++) {\n        ", "for", "(", "int", " j = ", "1", " ; j<= n ;j++) {\n            arr[i][j] = sc.", "next", "();\n            \n            ", "if", "(arr[i][j].", "equals", "(", "\"A\"", ")) {\n                a = i;\n                b = j;\n            }\n        }\n    }\n    ", "dfs", "(a,b,", "\"o\"", ",", "0", ");\n    System.out.", "println", "(min);\n}\n\n", "//输入为坐标  当前的状态（+，-，A，B），当前的步数", "\n", "private", " ", "static", " ", "void", " ", "dfs", "(", "int", " x, ", "int", " y, ", "String", " status, ", "int", " step)", " ", "{\n    ", "// TODO Auto-generated method stub", "\n    ", "if", "(arr[x][y].", "equals", "(", "\"B\"", ")) {\n        min = Math.", "min", "(step, min);\n        ", "return", " ;\n    }\n    \n    ", "int", " x1 = ", "0", " ,y1 = ", "0", ";", "//表示移动的坐标", "\n    ", "for", "(", "int", " i = ", "0", " ; i < ", "4", " ;i++) {\n        x1 = x +fx[i];\n        y1 = y +fy[i];\n        ", "//判断接下来的雷区是否符合要求 且没有重复", "\n        ", "if", "( ", "is", "(x1,y1,x,y)&&visit[x1][y1]!=", "1", ") {\n            ", "//符合的话 标记 已访问", "\n            visit[x1][y1]=", "1", ";\n            ", "dfs", "(x1,y1,arr[x1][y1],step+", "1", ");", "//进入递归", "\n            ", "//当前递归结束 访问标记位取消 以免 访问不到B区（如果有B 区的话）", "\n            visit[x1][y1]=", "0", ";\n        }\n    }\n    \n    \n}\n\n", "private", " ", "static", " ", "boolean", " ", "is", "(", "int", " x1, ", "int", " y1,", "int", " x,", "int", " y)", " ", "{\n    ", "// TODO Auto-generated method stub", "\n    ", "if", "(x1 >= ", "0", "&& x1 <= n && y1 >= ", "0", "&& y1 <=n&&arr[x1][y1]!=arr[x][y])\n        ", "return", " ", "true", ";\n    ", "return", " ", "false", ";\n}\n", "\n", "}", "\n", "Exception in thread \"main\" java.lang.NullPointerException", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:90)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.main(Chuanyueleichi1.java:83)"]], "Tag": "算法设计"}
{"Answer": "你这里面使用了递归没有 ？ \r\n\r\n看你这种情况，引起堆栈溢出的可能性，有两种。一种是递归，一种就是内存没有往堆上分配，即没有使用malloc等内存分配函数。\r\n\r\n我认为递归引起的可能性更大。", "Konwledge_Point": "优先队列实现", "Question": ["AI八数码问题 Stack Overflow", ["AI课本八数码问题，我是用广度优先搜索，用Ismatch来记录状态是否已经遍历，个人感觉算法基本没错吧！可是编译程序的时候只要步数长一点（5步可以输出）就没有输出，用Debug调试显示是：Stack Overflow。我看了很久的代码，也没有搞懂需要在哪里做优化。希望大家看下给点意见。谢谢", "\n[code=\"c\"]#include ", "\n#include ", "\n#define M 362881", "\n\n", "bool IsAnswer = false;", "\nbool Ismatch[M];//标记是否已经遍历过", "\nint tos,len;//队列指针tos,长度len", "\nint tt[9]={1,1,2,6,24,120,720,5040,40320};", "\nchar dest[10];//目标状态", "\nchar tmap[10];", "\nenum dir{up,down,left,right,none};", "\n\n", "struct {", "\n    int dir;", "\n    int t;", "\n}path[M];//记录路径", "\n\n", "struct eightnum{", "\n    char map[10];", "\n    int x,y;", "\n    int father;", "\n    dir myDir;//父节点移动的方向", "\n}num[M];", "\neightnum temp;", "\n\n", "void back_push(eightnum _num)//push", "\n{", "\n    strcpy(num[len].map, _num.map);", "\n    num[len].x = _num.x;", "\n    num[len].y = _num.y;", "\n    num[len].father = _num.father;", "\n    num[len].myDir = _num.myDir;", "\n    ++len;", "\n}", "\n\n", "eightnum front_pop()//pop", "\n{", "\n    tos++;", "\n    if(tos<len)", "\n        return num[tos];", "\n    else", "\n        printf(\"Wrong about the queue!\\n\");", "\n}", "\n\n", "int getHash(char _map[])//获取hash", "\n{", "\n    int hash;", "\n    int k,l;", "\n    hash = 0;", "\n    int count = 0; ", "\n    for(k=0;k<9;++k){", "\n        count = 0;", "\n        for(l = 0 ; l < k ;++ l){", "\n            if(_map[k]<_map[l])", "\n                count++;", "\n        }", "\n        hash += count*tt[k];", "\n    }", "\n    return hash;", "\n}", "\n\n", "int ReverseNum(char _map[])//逆序数", "\n{", "\n    int k,l;", "\n    int count = 0;", "\n    for(k=0;k<9;++k){", "\n        for(l = 0 ; l < k ;++ l){", "\n            if(_map[k] == '0')", "\n                continue;", "\n            else if(_map[k]<_map[l])", "\n                count++;", "\n        }", "\n    }", "\n    return count;", "\n}", "\n\n", "void DFS(eightnum _tmp)//dfs", "\n{", "\n    getHash(_tmp.map);", "\n    if(strcmp(_tmp.map,dest)==0){//find the answer", "\n        IsAnswer = true;", "\n        printf(\"Find the path!\\n\");", "\n        return;", "\n    }", "\n    else if(len>=M){//flow", "\n        printf(\"Above Flow!\");", "\n        return ;", "\n    }", "\n    else{", "\n        //down", "\n        if( _tmp.x != 2){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[_tmp.x*3+_tmp.y];", "\n            tmap[_tmp.x*3+_tmp.y] = tmap[(_tmp.x+1)*3+_tmp.y];", "\n            tmap[(_tmp.x+1)*3+_tmp.y] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x + 1;", "\n                temp.y = _tmp.y;", "\n                temp.father = tos;", "\n                temp.myDir = down;", "\n                back_push(temp);", "\n            }", "\n        }", "\n        //right", "\n        if( _tmp.y != 2 ){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[(_tmp.x)*3+_tmp.y];", "\n            tmap[(_tmp.x)*3+_tmp.y]= tmap[(_tmp.x)*3+_tmp.y+1];", "\n            tmap[(_tmp.x)*3+_tmp.y+1] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x;", "\n                temp.y = _tmp.y+1;", "\n                temp.father = tos;", "\n                temp.myDir = right;", "\n                back_push(temp);", "\n            }", "\n        }", "\n        //up", "\n        if(_tmp.x != 0){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[_tmp.x*3+_tmp.y];", "\n            tmap[_tmp.x*3+_tmp.y] = tmap[(_tmp.x-1)*3+_tmp.y];", "\n            tmap[(_tmp.x-1)*3+_tmp.y] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x - 1;", "\n                temp.y = _tmp.y;", "\n                temp.father = tos;", "\n                temp.myDir = up;", "\n                back_push(temp);", "\n            }", "\n        }", "\n        //left", "\n        if( _tmp.y != 0 ){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[_tmp.x*3+_tmp.y];", "\n            tmap[_tmp.x*3+_tmp.y]= tmap[(_tmp.x)*3+_tmp.y-1];", "\n            tmap[(_tmp.x)*3+_tmp.y-1] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x;", "\n                temp.y = _tmp.y-1;", "\n                temp.father = tos;", "\n                temp.myDir = left;", "\n                back_push(temp);", "\n            }", "\n        }", "\n\n", "}\neightnum m_tmp = front_pop();\nDFS(m_tmp);\n", "\n\n", "}", "\n\n", "void myDisplay(char _map[]){//display", "\n    int ii;", "\n    for(ii=0;ii<9;++ii){", "\n        if(0==ii%3)", "\n            printf(\"\\n\");", "\n        if(_map[ii] == '0')", "\n            printf(\"    \");", "\n        else", "\n            printf(\"%c   \",_map[ii]);", "\n    }", "\n    printf(\"\\n-----------------------------\\n\");", "\n}", "\n\n", "int main()", "\n{", "\n    char input[10] ;//输入", "\n    strcpy(input,\"283164705\");", "\n    strcpy(dest,\"123804765\");", "\n    int i;", "\n    tos =  -1;", "\n    len  = 0;", "\n    strcpy(temp.map,input);", "\n    printf(\"原始状态:\\n\");", "\n    myDisplay(input);", "\n    for(i=0;i<M;++i)", "\n        Ismatch[i] = false;", "\n    if( ReverseNum(input)%2 != ReverseNum(dest)%2){", "\n        printf(\"Not exist the answer!\\n\");", "\n        return 1;", "\n    }", "\n    for(i=0;i<10;++i){", "\n        if(temp.map[i] == '0'){", "\n            Ismatch[getHash(temp.map)] = true;", "\n            temp.x = i/3;", "\n            temp.y = i%3;", "\n            temp.father=-1;", "\n            temp.myDir = none;", "\n            back_push(temp);", "\n            break;", "\n        }", "\n    }", "\n    eightnum _tmp = front_pop();", "\n    DFS(_tmp);", "\n    int kk = 0;", "\n    if (IsAnswer){", "\n        int ff = tos ;", "\n        while( num[ff].father != -1){", "\n            path[kk].dir = num[ff].myDir;", "\n            path[kk].t =  ff;", "\n            kk++;", "\n            //printf(\"%d\",num[ff].myDir);", "\n            ff = num[ff].father;", "\n        }", "\n    }   ", "\n\n", "for(i=kk-1;i>=0;--i)\n{\n    if(path[i].dir==0){\n        printf(\"down-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==1){\n        printf(\"up-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==2){\n        printf(\"right-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==3){\n        printf(\"left-->\");\n        myDisplay(num[path[i].t].map);\n    }\n}\nreturn 0;\n", "\n\n", "}[/code]", "\n\n", "ps:用“在link option中增加/stack”这种方法可以实现步长到27，我是想知道是否有更好的方法可以优化代码"]], "Tag": "算法设计"}
{"Answer": "参考：http://blog.chinaunix.net/uid-20357359-id-1963209.html", "Konwledge_Point": "优先队列实现", "Question": ["如何用大小根交替堆实现双端优先队列？", ["双端优先队列是一个支持如下操作的数据结构：", "\n•Insert (S, x) – 将元素x插入集合S", "\n•Extract –Min (S) –删除S中的最小关键字", "\n•Extract –Max (S) –删除S中的最大关键字", "\n可用小大根交替堆来实现对上述三个操作的支持。小大根交替堆是一个满足如下小大根交替条件的完全二元树：如果该二元树不空，那么其上的每个元素都有一个称为关键字的域，且针对该关键字，二元树按层次形成了小大根交替的形式，即对于小大根交替堆中的任何一个结点x，如果x位于小根层次，那么x就是以x为根节点的二元树中键值最小的结点，并称该结点为一个小根结点。同样的道理，如果x位于大根层次，那么x就是以x为根节点的二元树中键值最大的结点，并称该结点为一个大根结点。在小大根交替堆中根结点位于小根层次。"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-xml\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;job&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; job_number;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; priority;\n};\njob priority_queue[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;   &lt;span class=\"hljs-comment\"&gt;//队列中的作业个数 全局变量&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; allnumber&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//作业号&amp;#xff0c;依次递增&amp;#xff0c;赋给增加的作业&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;remove&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(length&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;There is no job!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; maxpriority&amp;#61;&lt;span class=\"hljs-number\"&gt;9999&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; number&amp;#61;&lt;span class=\"hljs-number\"&gt;9999&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sign&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//遍历一次队列&amp;#xff0c;找到最高优先级的作业&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;length;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(priority_queue[i].priority&amp;lt;maxpriority){\n            maxpriority &amp;#61; priority_queue[i].priority;\n            number &amp;#61; priority_queue[i].job_number;\n            sign &amp;#61; i;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(priority_queue[i].priority&amp;#61;&amp;#61;maxpriority)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(priority_queue[i].job_number&amp;lt;number){\n                maxpriority &amp;#61; priority_queue[i].priority;\n                number &amp;#61; priority_queue[i].job_number;\n                sign &amp;#61; i;\n            }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,priority_queue[sign].job_number,priority_queue[sign].priority);\n\n    &lt;span class=\"hljs-comment\"&gt;//找到了作业&amp;#xff0c;删除它&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//从后往前依次覆盖&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;sign;i&amp;lt;length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        priority_queue[i] &amp;#61; priority_queue[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    &lt;span class=\"hljs-comment\"&gt;//作业个数减一&lt;/span&gt;\n    length--;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Remove succeeds!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;add&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\"hljs-comment\"&gt;//控制台输入一个优先级&amp;#xff0c;系统自动赋予作业号&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Please input the priority: &amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p;  &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;p);\n    &lt;span class=\"hljs-comment\"&gt;//构成一个作业&amp;#xff1a;作业号&amp;#xff0c;优先级  并且加在队列最后&lt;/span&gt;\n    priority_queue[length] &amp;#61; {allnumber&amp;#43;&amp;#43;,p};\n    &lt;span class=\"hljs-comment\"&gt;//作业个数加一&lt;/span&gt;\n    length&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,priority_queue[length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;].job_number,priority_queue[length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;].priority);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Add succeeds!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;list&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;List:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;//一个for循环遍历整个数组&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;length;i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,priority_queue[i].job_number,priority_queue[i].priority);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Over!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Please input your operation:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; operation;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,&amp;amp;operation);\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (operation) {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;R&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;remove&lt;/span&gt;();&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;add&lt;/span&gt;();&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;L&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;();&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;: &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Illegal input.\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;menu&lt;/span&gt;();\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;menu&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/16256333605271.png\" /&gt;&lt;/p&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/16256333750022.png\" /&gt;&lt;/p&gt;\n&lt;p&gt;直接复制粘贴就能运行。&lt;/p&gt;\n&lt;p&gt;使用数组存储作业。每次出队时&amp;#xff0c;先找到优先级最高的作业&amp;#xff0c;然后删除它。&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["数据结构（用无序顺序表实现优先队列）", ["需要用c语言编程，加点注释。", "\n", "假设进入计算机系统的作业（job）被赋予一个作业号（job number）和一个从0～9之中的优先级（priority），0表示最大优先级，9表示最小优先级。等待被作业执行的作业的作业号被保存在一个优先级队列（priority queue）中。", "编写一个程序，使用优先级队列来存放作业，并允许用户选择一下菜单操作：R（删除remove）、A（增加add）和L（列举list）。", "对于R，读出当前优先级最高的作业号并把它从优先级队列中删除，如果当前优先级最高的作业有多个，则把作业号小的作业从优先队列中删除；对于A，读入作业号和优先级，然后按上述规则把它加入到优先级队列中；对于L，则列出队列中的所有作业号及其优先级。", "作业号可用一个整数表示，可在作业进入系统时由系统赋予。", "设计适当的数据元素类型，用无序顺序表实现优先队列并写出验证代码验证各个操作，完成上述计算机系统的作业调度的演示方案。新来的作业插入到表尾。假定作业号可以反映作业被加入的先后次序，因此和作业优先级一起可以唯一识别一个作业。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;单调队列必须维护其内元素的有序性。&lt;/p&gt;\n&lt;p&gt;优先队列在普通队列的基础上给每个元素增加了优先级&amp;#xff0c;这样每次出队的元素不再是队首的元素&amp;#xff0c;而是队列中优先级最高的元素&amp;#xff0c;而具体的优先级可以自行定义&amp;#xff0c;典型的就是按元素从大到小或从小到大的顺序定义优先级。&lt;/p&gt;\n&lt;p&gt;堆通常是一个可以被看做一棵完全二叉树的数组对象&amp;#xff0c;和队列这种线性结构有本质上的差别。&lt;/p&gt;\n&lt;p&gt;STL的实现一般是经过编译器优化的。&lt;/p&gt;\n&lt;p&gt;不知道有没有帮到您。&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["单调队列 优先队列 堆的区别和联系?", ["单调队列 优先队列 堆的区别和联系是啥 感觉很像.", "以及优先队列和堆的STL实现方式又有什么联系？"]], "Tag": "算法设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;       //有用到malloc()\r\n#include&lt;conio.h&gt;       //键盘输入\r\n#include&lt;windows.h&gt;\r\n #define MAX 10\r\n\r\n \r\n#define getpch(type)  (type*)malloc(sizeof(type))\r\n#define NULL 0\r\n\r\nstruct task_struct\r\n{\r\n    char name[10];           /*进程名称*/\r\n    int number;              /*进程编号*/\r\n    float come_time;         /*到达时间*/\r\n    float run_begin_time;     /*开始运行时间*/\r\n    float run_time;          /*需要运行时间*/\r\n    float runed_time;\t\t/*运行时间*/\r\n    float run_end_time;      /*运行结束时间*/\r\n    int priority;           /*优先级*/\r\n    int run_flag;          /*调度标志*/\r\n    int start_flag;     //是否为第一次开始调度\r\n} tasks[MAX];\r\nint counter; /*实际进程个数*/\r\nint time_counter=0;\r\nint poutput(); /*调度结果输出*/\r\nint time();\r\nint charge();//判断是否所有的进程都被执行过\r\n \r\nstruct pcb                   //定义进程控制块\r\n{\r\n\tchar name[10];           //定义进程名\r\n\tchar state;              //进程状态\r\n\tint  super;             //进程优先级\r\n\tint  rtime;              //已经运行时间\r\n\tint  ntime;                //运行所需时间\r\n\tstruct pcb* link;           //定义一个队列指针，定义了一个指向pcb结构类型的指针link作为自己的成员函数\r\n}*ready=NULL,*p;                 //定义两个指向pcb结构指针类型的指针ready和p，ready的初值为空,并建立了一个空的就绪队列\r\n\r\n\r\ntypedef struct pcb PCB;           //定义将struct pcb称为PCB\r\n \r\n \r\n \r\n \r\n//***********************************************************************************************\r\nvoid sort()                       //建立对进程进行优先级排列的函数\r\n{\r\n\tPCB *f,*s;                   //定义两个用来排列的指针first和second\r\n\tint insert=0;                    //插入\r\n\tif((ready==NULL)||(p-&gt;super)&gt;(ready-&gt;super))     //比较优先级，优先级最大者，直接插入队首\r\n\t{\r\n\t\tp-&gt;link=ready;                           //\r\n\t\tready=p;                                // 将新建进程放入队首\r\n\t}\r\n\telse                                      //比较进程的优先级，并将其插入适当的地方\r\n\t{\r\n\t\tf=ready;                          //                                                \r\n\t\ts=f-&gt;link;                              //插入新的进程\r\n\t\twhile(s!=NULL)                           //如果第二个进程不为空\r\n\t\t{\r\n\t\t\tif((p-&gt;super)&gt;(s-&gt;super))            //将插入进程与当前进程比较\r\n\t\t\t{                                   //如果插入进程的优先级大于当前进程优先级，则插入当前优先级的前面\r\n\t\t\t\tp-&gt;link=s;\r\n\t\t\t\tf-&gt;link=p;\r\n\t\t\t\ts=NULL;\r\n\t\t\t\tinsert=1;\r\n\t\t\t}\r\n\t\t\telse                                 //否则，将新插入的进程插入到当前进程的后面，向后移指针\r\n\t\t\t{\r\n\t\t\t\tf=f-&gt;link;\r\n\t\t\t\ts=s-&gt;link;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(insert==0)\r\n\t\t\tf-&gt;link=p;                           //将p指针指向队尾\r\n\t}\r\n}\r\n \r\n \r\n \r\n \r\n//**********************************************************************************\r\nvoid input()                                          //建立进程控制块函数\r\n{\r\n\tint i,num;                               \r\n\tprintf(\"*********************最高优先级优先算法**********************\");\r\n\tprintf(\"\\n 请输入进程的数量：\");\r\n\tscanf(\"%d\",&amp;num);              //键盘上输入\r\n\tfor(i=1;i&lt;=num;i++)\r\n\t{\r\n\t\tprintf(\"\\n 进程号No.%d:\",i);\r\n\t\tp=getpch(PCB);\r\n\t\tprintf(\"\\n 请输入进程名：\");\r\n\t\tscanf(\"%s\",p-&gt;name);\r\n\t\tprintf(\"\\n 请输入进程优先级：\");\r\n\t\tscanf(\"%d\",&amp;p-&gt;super);\r\n\t\tprintf(\"\\n 请输入进程所需运行时间：\");\r\n\t\tscanf(\"%d\",&amp;p-&gt;ntime);\r\n\t\tprintf(\"\\n\");\r\n\t\tp-&gt;rtime=0;\r\n\t\tp-&gt;state='w';\r\n\t\tp-&gt;link=NULL;\r\n\t\tsort();                               //调用sort函数进行排序\r\n\t}\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//********************************************************************************\r\nint space()                 //计算进程控制块个数的函数\r\n{\r\n\tint k=0;\r\n\tPCB*pr=ready;          //pr指向队首进程\r\n\twhile(pr!=NULL)          //pr为空则说明计数完成，就绪队列没到头，就一直输出\r\n\t{\r\n\t\tk++;\r\n\t\tpr=pr-&gt;link;\r\n\t}\r\n\tprintf(\" 进程数量：%d\\n\",k);\r\n\tprintf(\"*********************************************\\n\");\r\n\treturn(k);\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//************************************************************************************\r\nvoid disp(PCB*pr)   //建立进程显示函数，显示当前的进程\r\n{\r\n\tprintf(\"\\n name\\t state\\t super \\t ntime\\t rtime\\n\");\r\n\tprintf(\" %s  \\t\",pr-&gt;name);\r\n\tprintf(\" %c  \\t\",pr-&gt;state);\r\n\tprintf(\" %d  \\t\",pr-&gt;super);\r\n\tprintf(\" %d  \\t\",pr-&gt;ntime);\r\n\tprintf(\" %d  \\t\",pr-&gt;rtime);\r\n\tprintf(\"\\n\");\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//****************************************************************************\r\nvoid check()            //建立进程查看函数，查看已经排列好的情况\r\n{\r\n\tPCB* pr;\r\n\tprintf(\"\\n 当前正在运行的进程：%s\",p-&gt;name);\r\n\tdisp(p);                //调用disp()显示已经筛选出来的正在运行的进程\r\n\tpr=ready;                \r\n\tprintf(\"\\n 当前就绪队列状态为：\\n\");\r\n\twhile(pr!=NULL)\r\n\t{\r\n\t\tdisp(pr);             //调用disp()显示已经排列好的就绪队列  \r\n\t\tpr=pr-&gt;link;\r\n\t}\r\n}\r\n \r\n \r\nvoid destroy()      //建立函数，撤销进程\r\n{\r\n\tprintf(\"\\n 进程[%s]已完成.\\n\",p-&gt;name);\r\n\tfree(p);                            //释放空间\r\n}\r\n \r\n \r\n \r\n \r\n \r\n \r\n//********************************************************************************\r\nvoid running()                 //建立进程就绪函数（进程运行时间到，置为就绪状态）\r\n{\r\n\t(p-&gt;rtime)++;                    //运行时间加一\r\n\tif(p-&gt;rtime==p-&gt;ntime)\r\n\t   destroy();                     //\r\n\t else\r\n\t {\r\n\t\t (p-&gt;super)--;             //运行时间减一\r\n\t\t p-&gt;state='w';\r\n\t\t sort();                   //调用一次之后，运行时间时间和运行状态改变后，重新去排序进程\r\n\t }\r\n} \r\n \r\n \r\n//***************************************************************************\r\nvoid HPF()                        //主函数\r\n{\r\n\tint len,h=0;                                //h是用于计算执行次数的\r\n\tchar ch;\r\n\tinput();                                    //调用input函数输入相关的进程信息\r\n\tlen=space();                              //input调用完之后，回到主函数调用space函数得到对列长度\r\n\twhile((len!=0)&amp;&amp;(ready!=NULL))\r\n\t{\r\n\t\tch=getchar();                  //从键盘输入一个字符型数据，把值赋给变量ch,这个是为了每一次被执行，自己手动回车呈现出来，如果没有，则会一次性出现全部被执行的情况\r\n\t\th++;\r\n\t\tprintf(\"\\n The execute number:%d \\n\",h);\r\n\t\tp=ready;\r\n\t\tready=p-&gt;link;\r\n\t\tp-&gt;link=NULL;\r\n\t\tp-&gt;state='R';\r\n\t\tcheck();                         //调用显示正在运行的函数和就绪的函数\r\n        running();        // 调用进程就绪函数,上一个正在运行的进程运行完之后，运行时间加1，将就绪队列里面优先级最高的进程置为运行状态，如果是同优先级，则看哪个先进来，这个不可以运行在check()前，会导致多计算，并出现错误\r\n\t\tprintf(\"\\n 请回车继续......\");\r\n\t\tch=getchar();\r\n\t}\r\n\tprintf(\"\\n\\n 进程已经完成.\\n\");\r\n\tch=getchar();\r\n}\r\n\r\n \r\nvoid RR()\r\n{\r\n\t\r\n    pinput();\r\n    printf(\"时间片轮转算法。\\n\\n\");\r\n    time();\r\n    poutput();\r\n}\r\n \r\nint time()\r\n{\r\n    float time_temp=0;\r\n    int i;\r\n    int j=0;\r\n    int k=0;\r\n\tchar ch;\r\n    struct task_struct  copy_task[MAX];//备份\r\n    for(i=0; i&lt;counter; i++)\r\n    {\r\n        copy_task[j++]=tasks[i];//对进程的初始化信息备份\r\n    }\r\n \r\n    time_temp=tasks[0].come_time;\r\n    while(charge())\r\n    {\r\n        for(i=0; i&lt;counter; i++)\r\n        {\r\n            if(tasks[i].come_time&gt;time_temp)\r\n            {\r\n                time_temp=tasks[i].come_time;\r\n                poutput();\r\n                printf(\"\\n 新进程进入输入...任意字符继续......\");\r\n\t\t\t\tch=getchar();\r\n            }\r\n            if(tasks[i].run_flag==0)//该进程还未结束\r\n            {\r\n                if(tasks[i].start_flag==0)  //该条件成立则说明，该进程是第一次执行，记录开始执行时间\r\n                {\r\n                    tasks[i].run_begin_time=time_temp;\r\n                    tasks[i].start_flag=1;\r\n                }\r\n                if(tasks[i].run_time/time_counter&gt;1)//至少有两倍的时间片未执行\r\n                {\r\n                    tasks[i].run_time=tasks[i].run_time-time_counter;\r\n                    time_temp=time_temp+time_counter;\r\n                    tasks[i].runed_time = tasks[i].runed_time + (float)time_counter;//加上的不知道又没用 \r\n                    poutput();\r\n                    printf(\"\\n 执行一次时间片了..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n                else if(tasks[i].run_time-time_counter==0)\r\n                {\r\n                    time_temp=time_temp+time_counter;\r\n                    tasks[i].run_end_time=time_temp;\r\n                    tasks[i].run_flag=1;\r\n                    tasks[i].run_time=copy_task[i].run_time;\r\n                    tasks[i].runed_time = tasks[i].runed_time + (float)time_counter;//加上的不知道又没用 \r\n                    poutput();\r\n                    printf(\"\\n 任务完成..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n                else//仅剩下不足一倍的时间片\r\n                {\r\n                    time_temp=time_temp+tasks[i].run_time;\r\n                    tasks[i].runed_time = tasks[i].runed_time + tasks[i].run_time;//加上的不知道又没用 \r\n                    tasks[i].run_end_time=time_temp;\r\n                    tasks[i].run_flag=1;\r\n                    tasks[i].run_time=copy_task[i].run_time;\r\n                    \r\n                    poutput();\r\n                    printf(\"\\n 任务完成..按任意字符继续........\");\r\n\t\t\t\t\tch=getchar();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n \r\nint charge()//判断是否全部进程都执行完毕\r\n{\r\n    int k;\r\n    int super_flag=0;//判断是否全部的进程都执行完毕\r\n    for(k=0; k&lt;counter; k++)\r\n    {\r\n        if(tasks[k].run_flag==0)\r\n        {\r\n            super_flag=1;\r\n            return super_flag;\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            super_flag=0;\r\n        }\r\n    }\r\n    return super_flag;\r\n}\r\n \r\nint pinput() /*进程参数输入*/\r\n{\r\n\tprintf(\"*********************最高优先级优先算法**********************\\n\");\r\n    int i;\r\n    printf(\"请输入进程数量:\\n\");\r\n    scanf(\"%d\",&amp;counter);\r\n    printf(\"请输入时间片长度:\\n\");\r\n    scanf(\"%d\",&amp;time_counter);\r\n    for(i=0; i&lt;counter; i++)\r\n    {\r\n        printf(\"******************************************\\n\");\r\n        printf(\"请输入第 %d 个进程的信息 :\\n\",i+1);\r\n        printf(\"请输入进程的名字:\\n\");\r\n        scanf(\"%s\",tasks[i].name);\r\n        printf(\"请输入进程编号:\\n\");\r\n        scanf(\"%d\",&amp;tasks[i].number);\r\n        printf(\"请输入进程进入时间:\\n\");\r\n        scanf(\"%f\",&amp;tasks[i].come_time);\r\n        printf(\"请输入进程运行时间:\\n\");\r\n        scanf(\"%f\",&amp;tasks[i].run_time);\r\n        printf(\"进程优先级:\\n\");\r\n        scanf(\"%d\",&amp;tasks[i].priority);\r\n        tasks[i].run_begin_time=0;\r\n        tasks[i].run_end_time=0;\r\n        tasks[i].runed_time=0; //运行时间初始化 \r\n        tasks[i].run_flag=0;  //运行是否结束\r\n        tasks[i].start_flag=0;//是否首次被执行\r\n    }\r\n    return 0;\r\n}\r\n \r\nint poutput() /*调度结果输出*/\r\n{\r\n    int i;\r\n    float turn_round_time=0,f1,w=0;\r\n    printf(\"进程名 进程号 到达时间 需要运行时间 开始时间 结束时间 优先级 周转时间 运行时间 运行状态\\n\");\r\n    for(i=0; i&lt;counter; i++)\r\n    {\r\n        f1=tasks[i].run_end_time-tasks[i].come_time;\r\n        turn_round_time+=f1;\r\n        printf(\"%s\\t%d\\t%5.3f\\t%5.3f\\t    %5.3f\\t %5.3f\\t    %d\\t  %5.3f  %5.3f  %d\\n\",tasks[i].name,tasks[i].number,tasks[i].come_time,tasks[i].run_time,tasks[i].run_begin_time,tasks[i].run_end_time,tasks[i].priority,tasks[i].runed_time,f1,tasks[i].run_flag);\r\n    }\r\n    printf(\"average_turn_round_timer=%5.2f\\n\",turn_round_time/counter);\r\n    return 0;\r\n}\r\nvoid main(){\r\n\tint flag = 0;\r\n\tprintf(\"请输入算法规则（0是HPF-&gt;高优先级优先调度算法,1是RR-&gt;时间片轮转调度算法）：\\n\") ;\r\n\tscanf(\"%d\",&amp;flag);\r\n\tif (flag == 0){\r\n\t\tHPF();\r\n\t} else if(flag = 1){\r\n\t\tRR();\r\n\t} else{\r\n\t\tprintf(\"没有其他了算法\"); \r\n\t}\r\n\t\r\n}\r\n\r\n```", "Konwledge_Point": "优先队列实现", "Question": ["在Windows系统下用C/C++编程实现两种处理机调度算法。", ["\n", "CPU Scheduling\n(1)题目描述\n编程实现两种处理机调度算法，可选择的以下组合方式其中之- -: 1) 高优先级优先调度算法和时间片轮转调度算法; 2) 短进程优先调度算法和时间片轮转调度算法; 3) 先入先出调度算法和时间片轮转让调度算法。\n选择-一个调度算法，实现处理机调度。(2)功能实现\no输入提示选择哪种算法，例如:输入“0”--HPF，输入“1”--RR; )\n输入提示创建进程的个数，初始化进程;\nPCB内容:进程名/PID\n运行时间\n优先权\n状态\nPCB指针\n●运行过程中须提示所创建进程的状态信息，包括:已运行的时间,还需运行的时间，阻塞的时间，要阻塞多长时间;\n●提示进程的状态:运行，就绪，阻塞三者之- -;\n●建立进程的PCB， 用队列实现进程就绪队列和阻塞队列的管理。\n可随机输入若干进程，并按所选算法的规则排序，从就绪队首选进程运行，进程在运行过程中定时(或发生调度时)更新各进程的状态信息，\n进程名状态运行时间 剩余运行时间 优先级进程阻塞属性(有阻塞/无阻塞)\n规定系统可接纳的进程的道数，设置后备队列和挂起状态。若内存中进程少于规定道数，可自动从后备队列调度- -作业进入。\n被挂起进程入挂起队列，设置解挂功能用于将指定挂起进程解挂入就绪队列。", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;list&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;enum class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Priority&lt;/span&gt;\n{\n    Low,\n    Medium,\n    High\n};\n\n&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; T, &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List &amp;#61; std::list&amp;lt;std::pair&amp;lt;T, Priority&amp;gt;&amp;gt;&amp;gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; PriorityQueue\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; List list_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::value_type value_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::size_type size_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::iterator iterator;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List::const_iterator const_iterator;\n\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;() : _high_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;()), _medium_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;()) {}\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; PriorityQueue &amp;amp;other) : _list(other._list)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n    }\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;(PriorityQueue &amp;amp;&amp;amp;other)\n        : _list(std::&lt;span class=\"hljs-built_in\"&gt;move&lt;/span&gt;(other._list))\n    {\n        &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n        other._high_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n        other._medium_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n    }\n    &lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; std::initializer_list&amp;lt;value_type&amp;gt; &amp;amp;list) : _high_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;()), _medium_end(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;[value, priority] : list)\n            &lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(value, priority);\n    }\n    ~&lt;span class=\"hljs-built_in\"&gt;PriorityQueue&lt;/span&gt;() {}\n\n    PriorityQueue &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; PriorityQueue &amp;amp;other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; !&amp;#61; &amp;amp;other)\n        {\n            _list &amp;#61; other._list;\n            &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    PriorityQueue &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(PriorityQueue &amp;amp;&amp;amp;other)\n    {\n        _list &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;move&lt;/span&gt;(other._list);\n        &lt;span class=\"hljs-built_in\"&gt;init&lt;/span&gt;();\n        other._high_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n        other._medium_end &amp;#61; other._list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;const_iterator &lt;span class=\"hljs-title\"&gt;begin&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        const_iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;const_iterator &lt;span class=\"hljs-title\"&gt;end&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        const_iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            it &amp;#61; _medium_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _high_end;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;empty&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _list.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;(); }\n\n    &lt;span class=\"hljs-function\"&gt;size_type &lt;span class=\"hljs-title\"&gt;size&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _list.&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(); }\n\n    &lt;span class=\"hljs-function\"&gt;size_type &lt;span class=\"hljs-title\"&gt;size&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Priority priority)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        size_type sz &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n            sz &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;distance&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;const_iterator&lt;/span&gt;(_medium_end), _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;());\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n            sz &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;distance&lt;/span&gt;(_high_end, _medium_end);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            sz &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;distance&lt;/span&gt;(_list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), &lt;span class=\"hljs-built_in\"&gt;const_iterator&lt;/span&gt;(_high_end));\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sz;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;insert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; T &amp;amp;value, Priority priority)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it;\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n        {\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; sz_medium &amp;#61; &lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(Priority::Medium);\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; sz_low &amp;#61; &lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(Priority::Low);\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(_list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), std::&lt;span class=\"hljs-built_in\"&gt;make_pair&lt;/span&gt;(value, priority));\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sz_low &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                _medium_end &amp;#61; it;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sz_medium &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                    _high_end &amp;#61; it;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n        {\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; sz_medium &amp;#61; &lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(Priority::Medium);\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(_medium_end, std::&lt;span class=\"hljs-built_in\"&gt;make_pair&lt;/span&gt;(value, priority));\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sz_medium &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                _high_end &amp;#61; it;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n            it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(_high_end, std::&lt;span class=\"hljs-built_in\"&gt;make_pair&lt;/span&gt;(value, priority));\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;iterator &lt;span class=\"hljs-title\"&gt;erase&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(iterator pos)&lt;/span&gt;\n    &lt;/span&gt;{\n        iterator it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;erase&lt;/span&gt;(pos);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pos &amp;#61;&amp;#61; _high_end)\n            _high_end &amp;#61; it;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pos &amp;#61;&amp;#61; _medium_end)\n            _medium_end &amp;#61; it;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; it;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;remove&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; T &amp;amp;value)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; it &amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            it &amp;#61; &lt;span class=\"hljs-built_in\"&gt;find_if&lt;/span&gt;(it, _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), [value](&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;v)\n                         { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v.first &amp;#61;&amp;#61; value; });\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (it &amp;#61;&amp;#61; _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            it &amp;#61; &lt;span class=\"hljs-built_in\"&gt;erase&lt;/span&gt;(it);\n        }\n    }\n\n    &lt;span class=\"hljs-function\"&gt;value_type &lt;span class=\"hljs-title\"&gt;front&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _list.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;();\n    }\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;init&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        _high_end &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;find_if&lt;/span&gt;(_list.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), [](&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;v)\n                                 { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v.second !&amp;#61; Priority::High; });\n        _medium_end &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;find_if&lt;/span&gt;(_high_end, _list.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), [](&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; &amp;amp;v)\n                                   { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v.second !&amp;#61; Priority::Medium; });\n    }\n\n    list_type _list;\n    iterator _high_end;\n    iterator _medium_end;\n};\n\nstd::ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream &amp;amp;os, Priority priority)\n{\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (priority)\n    {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Low:\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Low&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::Medium:\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Medium&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; Priority::High:\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;High&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; T, &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; List&amp;gt;\nstd::ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream &amp;amp;os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; PriorityQueue&amp;lt;T, List&amp;gt; &amp;amp;q)\n{\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;{ &amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; priority : {Priority::High, Priority::Medium, Priority::Low})\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (priority !&amp;#61; Priority::High)\n            os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;, &amp;#34;&lt;/span&gt;;\n        os &amp;lt;&amp;lt; priority &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;: [&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; it &amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(priority); it !&amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(priority); &amp;#43;&amp;#43;it)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (it !&amp;#61; q.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(priority))\n                os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;, &amp;#34;&lt;/span&gt;;\n            os &amp;lt;&amp;lt; it-&amp;gt;first;\n        }\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;]&amp;#34;&lt;/span&gt;;\n    }\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;}&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    PriorityQueue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; q &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, Priority::Low}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, Priority::Medium}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, Priority::High}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, Priority::High}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, Priority::Medium}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, Priority::Low}};\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; std::endl;\n\n    PriorityQueue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; p1 &amp;#61; q;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after p1 &amp;#61; q:\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;p1 &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; std::endl;\n\n    PriorityQueue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; p2 &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;move&lt;/span&gt;(p1);\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after p2 &amp;#61; std::move(p1):\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;p2 &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p2 &amp;lt;&amp;lt; std::endl;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;p1 &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; std::endl;\n\n    q.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, Priority::High);\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after q.insert(5, Priority::Hight):\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; std::endl;\n\n    q.&lt;span class=\"hljs-built_in\"&gt;remove&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;after q.remove(5):\\n&amp;#34;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; std::endl;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;q.front(): {&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;().first &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;, &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; q.&lt;span class=\"hljs-built_in\"&gt;front&lt;/span&gt;().second &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;}&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;$ g&amp;#43;&amp;#43; -Wall -std&amp;#61;c&amp;#43;&amp;#43;&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.cpp&lt;/span&gt;\n$ ./&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.out&lt;/span&gt;\n&lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt; &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nafter p1 &amp;#61; &lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt;:\np1 &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nafter p2 &amp;#61; std::move(p1):\np2 &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\np1 &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[]&lt;/span&gt;}\nafter &lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.insert&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, Priority::Hight):\n&lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt; &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4, 5]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2, 5]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nafter &lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.remove&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;):\n&lt;span class=\"hljs-selector-tag\"&gt;q&lt;/span&gt; &amp;#61; { High: &lt;span class=\"hljs-selector-attr\"&gt;[3, 4]&lt;/span&gt;, Medium: &lt;span class=\"hljs-selector-attr\"&gt;[2]&lt;/span&gt;, Low: &lt;span class=\"hljs-selector-attr\"&gt;[1, 6]&lt;/span&gt;}\nfront: {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, High}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["创建一个基于单向线性列表的 \"具有整数优先级的队列\"。", ["当一个元素被插入时，它的优先级被设置，有三个固定值：低、中、高。一旦被放入队列，元素的优先级就不能改变。", "如果没有具有任何优先级的元素，那么指向尾部的相应指针必须为空。", "无参数的构造函数，复制，移动。", "  复制和移动分配运算符。", "确定队列中具有特定优先级的元素的数量和元素的总数量。", "检查是否有空队列。", "插入一个具有价值和优先权的元素。", "从队列中删除一个元素。", "获得关于队列头部元素的优先级和价值的信息。", "  通过菜单实现的头部程序应检查上述所有方法的操作。"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;stdlib.h&amp;gt;\n#define MAX_VERTEX_NUM 100\ntypedef struct ArcNode{\n\tint adjvex;//该边的另一个顶点的位置 \n\tstruct ArcNode *nextarc; //指向下一条边 \n}ArcNode;\ntypedef struct VNode{\n\tint data;//顶点的值 \n\tArcNode *firstarc;//指向第一条依附该顶点的边的指针 \n}VNode,AdjList[MAX_VERTEX_NUM];\ntypedef struct{\n\tAdjList vertices;//顶点数组 \n\tint vexnum,arcnum;\n}ALGraph;\nint LocateVex(ALGraph G,int v){//定位函数 \n\tfor(int i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n\t\tif(v&amp;#61;&amp;#61;G.vertices[i].data)return i;\n\t} \n}\nvoid CreateUDG(ALGraph &amp;amp;G){\n\tArcNode *p,*q;\n\tint i,j,k,v1,v2;\n\tprintf(&amp;#34;分别输入顶点个数和边的数目&amp;#xff1a;\\n&amp;#34;);\n\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;G.vexnum,&amp;amp;G.arcnum);\n\tprintf(&amp;#34;分别输入各个顶点值&amp;#xff1a;\\n&amp;#34;);\n\tfor(i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n\tscanf(&amp;#34;%d&amp;#34;,&amp;amp;G.vertices[i].data);\n\tG.vertices[i].firstarc&amp;#61;NULL;//初始化 \n\t} \n\tprintf(&amp;#34;分别输入各条边的两个顶点&amp;#xff1a;\\n&amp;#34;);\n\tfor(k&amp;#61;0;k&amp;lt;G.arcnum;k&amp;#43;&amp;#43;){\n\t\tscanf(&amp;#34;%d%d&amp;#34;,&amp;amp;v1,&amp;amp;v2);\n\t\ti&amp;#61;LocateVex(G,v1);j&amp;#61;LocateVex(G,v2);//定位 \n\t\tp&amp;#61;(ArcNode*)malloc(sizeof(ArcNode));//申请一个结点 \n\t\tp-&amp;gt;adjvex&amp;#61;j;p-&amp;gt;nextarc&amp;#61;NULL;//赋值 \n\t\tp-&amp;gt;nextarc&amp;#61;G.vertices[i].firstarc;//连接结点 \n\t\tG.vertices[i].firstarc&amp;#61;p;//连接结点 \n\t\tq&amp;#61;(ArcNode*)malloc(sizeof(ArcNode));\n\t\tq-&amp;gt;adjvex&amp;#61;i;q-&amp;gt;nextarc&amp;#61;NULL;\n\t\tq-&amp;gt;nextarc&amp;#61;G.vertices[j].firstarc;\n\t\tG.vertices[j].firstarc&amp;#61;q;\n\t}\n}\nvoid PrintUDG(ALGraph G){//输出邻接表 \n    int i,j;\n\tfor(i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n\t\tprintf(&amp;#34;%d:&amp;#34;,i);\n\t\tArcNode *p;\n\t\tp&amp;#61;G.vertices[i].firstarc;\n\t\twhile(p!&amp;#61;NULL){\n\t\t\tprintf(&amp;#34;-&amp;gt;%d&amp;#34;,p-&amp;gt;adjvex);\n\t\t\tp&amp;#61;p-&amp;gt;nextarc;\n\t\t}\n\t\tprintf(&amp;#34;\\n&amp;#34;);\n\t}\n}\nint main(){\n\tALGraph G;\n\tCreateUDG(G);\n\tPrintUDG(G);\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;br /&gt;\n &lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["怎样实现无向图的创建算法", ["\n\n", "1、编写一个函数让用户输入这张图，用邻接表存储。", "\n2、编写函数实现此图的深度优先搜索遍历。", "\n3、编程实现循环队列，编写初始化、创建、入队、出队等算法。", "\n4、利用循环队列对图实现广度优先搜索遍历。"]], "Tag": "算法设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;windows.h&gt;\r\n#define MAXSIZE 100\r\ntypedef struct ElemType\r\n{\r\n\tint level;\r\n\tchar name[20];\r\n\tchar gender;\r\n\tchar ID[20];\r\n\r\n}QelemType;\r\ntypedef struct{\r\n\tQelemType *base;\r\n\tint front;\r\n\tint rear;\r\n}squene;\r\nvoid Initquene(squene *s){\r\n\ts-&gt;base=(QelemType *)malloc(MAXSIZE * sizeof(QelemType));\r\n\tif(!s-&gt;base)\r\n\t\texit(-1);\r\n\ts-&gt;front=0;\r\n\ts-&gt;rear=0;\r\n}\r\nvoid enquene(squene *s,QelemType e){\r\n\tif((s-&gt;rear+1)%MAXSIZE==s-&gt;front){\r\n\t\tprintf(\"duimanb\");\r\n\t\texit(0);\r\n\t}\r\n\ts-&gt;base[s-&gt;rear]=e;\r\n\ts-&gt;rear=(s-&gt;rear+1)%MAXSIZE;\r\n}\r\nvoid dequene(squene *s,QelemType *e){\r\n\tif(s-&gt;rear==s-&gt;front){\r\n\t\tprintf(\"栈空\");\r\n\t\texit(-1);\r\n\t}\r\n\t*e=s-&gt;base[s-&gt;front];\r\n\ts-&gt;front=(s-&gt;front+1)  % MAXSIZE;\r\n}\r\nint length(squene s){\r\n\treturn (s.rear-s.front+MAXSIZE) % MAXSIZE;\r\n}\r\n\r\nint main()\r\n{\r\n\tint i,j;\r\n\tint n;\r\n\tsquene Q1;\r\n\tQelemType *e,t;\r\n\tInitquene(&amp;Q1);\r\n\tprintf(\"请输入前来就诊的病人数量：\");\r\n\tscanf(\"%d\",&amp;n);\r\n\te = (QelemType *)malloc(n*sizeof(QelemType));\r\n\tfor(i=0;i&lt;n;i++)\r\n\t{\r\n\t\tprintf(\"\\n请输入第%d个病人的优先级：\",i+1);\r\n\t\tscanf(\"%d\",&amp;e[i].level);\r\n\t\tprintf(\"\\n请输入第%d个病人的姓名：\",i+1);\r\n\t\tscanf(\"%s\",e[i].name);\r\n\t\tfflush(stdin);\r\n\t\tprintf(\"\\n请输入第%d个病人的性别：\",i+1);\r\n\t\tscanf(\"%c\",&amp;e[i].gender);\r\n\t\tprintf(\"\\n请输入第%d个病人的身份证：\",i+1);\r\n\t\tscanf(\"%s\",e[i].ID);\r\n\t}\r\n\r\n\tfor (i=0;i&lt;n-1;i++)\r\n\t{\r\n\t\tfor (j=0;j&lt;n-i-1;j++)\r\n\t\t{\r\n\t\t\tif (e[j].level&lt;e[j+1].level)\r\n\t\t\t{\r\n\t\t\t\tt = e[j];\r\n\t\t\t\te[j] = e[j+1];\r\n\t\t\t\te[j+1] = t;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfor (i=0;i&lt;n;i++)\r\n\t{\r\n\t\tenquene(&amp;Q1,e[i]);\r\n\t}\r\n\r\n\tfor (i=0;i&lt;n;i++)\r\n\t{\r\n\t\tdequene(&amp;Q1,&amp;t);\r\n\t\tprintf(\"办理业务 姓名：%s，身份证号：%s,性别：%c，优先级：%d\\n\", t.name,t.ID, t.gender,t.level);\r\n\t}\r\n\r\n\tfree(e);\r\n\te=NULL;\r\n\tsystem(\"pause\");\r\n\treturn 0;\r\n\r\n}\r\n\r\n```", "Konwledge_Point": "优先队列实现", "Question": ["医院排队就诊问题（C语言实现）求大神帮忙查看一下如何修改这些错误 （续）", ["问题描述：", "\n医院急诊科室，有医生1名", "\n现有病人7名，先后到达", "\n病人病情轻重各有不同（分3级，3级最重，1级最轻），重症的优先就诊；病症相同的，先来的先就诊。", "\n模型假设：", "\n1.病人挂完号后进入对应的科室，每位病人属性包括姓名，性别，和身份证号", "\n2.一开始的时候，医生空闲（等待病人）。", "\n3.有护士根据病人病情，给出病情优先级后，再排队。", "\n4.排队的病人按照先后次序排队，重症的优先就诊，病症相同的，先来的先就诊。。", "\n5.一位医生每次只能看一个病人。", "\n解决方案模型：", "\n1. 程序模拟医院排队就诊，程序开始输入病人资料（包括优先级，姓名，性别，和身份证号）。", "\n2. 设置一个病人的优先队列，按照优先级由高到低，分段排队，最开头的是优先级最高的病人；如果优先级相同，那么按照先来后到的顺序排队。", "\n3. 对病人队列有两种操作，pop与push，医生每次从病人队列里面pop一个病人，并打印病人信息（包括优先级，姓名，性别，和身份证号），直到队列空。", "\n\n", "\n", "请大佬继续补充回答", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;对给定图进行邻接表表示&amp;#xff0c;并利用队列和栈实现广度优先遍历和深度优先遍历的Python代码实现。同时&amp;#xff0c;程序还支持从键盘输入初始出发的顶点序号&amp;#xff0c;并在遍历过程中输出访问过的结点序号&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; collections &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; defaultdict, deque\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Graph&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, vertices&lt;/span&gt;):\n        self.graph &amp;#61; defaultdict(&lt;span class=\"hljs-built_in\"&gt;list&lt;/span&gt;)\n        self.vertices &amp;#61; vertices\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;add_edge&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, u, v&lt;/span&gt;):\n        self.graph[u].append(v)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;print_graph&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; vertex &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph:\n            &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(vertex, &lt;span class=\"hljs-string\"&gt;&amp;#34;-&amp;gt;&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34; -&amp;gt; &amp;#34;&lt;/span&gt;.join(&lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;(i) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph[vertex]))\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;bfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, start_vertex&lt;/span&gt;):\n        visited &amp;#61; [&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;] * self.vertices\n        queue &amp;#61; deque()\n\n        visited[start_vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n        queue.append(start_vertex)\n\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; queue:\n            start_vertex &amp;#61; queue.popleft()\n            &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(start_vertex, end&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;)\n\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; vertex &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph[start_vertex]:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; visited[vertex]:\n                    visited[vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n                    queue.append(vertex)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;dfs&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, start_vertex&lt;/span&gt;):\n        visited &amp;#61; [&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;] * self.vertices\n        stack &amp;#61; []\n\n        visited[start_vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n        stack.append(start_vertex)\n\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; stack:\n            start_vertex &amp;#61; stack.pop()\n            &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(start_vertex, end&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;)\n\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; vertex &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.graph[start_vertex]:\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; visited[vertex]:\n                    visited[vertex] &amp;#61; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n                    stack.append(vertex)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;traverse&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        start_vertex &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Enter the starting vertex: &amp;#34;&lt;/span&gt;))\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;BFS traversal: &amp;#34;&lt;/span&gt;)\n        self.bfs(start_vertex)\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nDFS traversal: &amp;#34;&lt;/span&gt;)\n        self.dfs(start_vertex)\n\n\n&lt;span class=\"hljs-comment\"&gt;# Create a sample graph&lt;/span&gt;\ng &amp;#61; Graph(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\ng.add_edge(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\n\n&lt;span class=\"hljs-comment\"&gt;# Print the graph&lt;/span&gt;\ng.print_graph()\n\n&lt;span class=\"hljs-comment\"&gt;# Traverse the graph&lt;/span&gt;\ng.traverse()\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;1&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;2&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;3&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Enter&lt;/span&gt; the starting vertex: &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;BFS&lt;/span&gt; traversal: \n&lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; \n&lt;span class=\"hljs-attribute\"&gt;DFS&lt;/span&gt; traversal: \n&lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; \n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["数据结构算法求详细解", ["5、对任意给定的图（顶点数和边数自定），建立它的邻接表并输出，利用队列的基本运算实现图的广度优先遍历；利用栈的基本运算实现图的深度优先遍历；从键盘输入初始出发的顶点的序号，要求在遍历过程中输出访问过的结点序号。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;main函数文件中的int visited[MaxSize];这一句注释掉。&lt;br /&gt;然后把 int visited[MaxSize];放在.h文件中(const int MaxSize &amp;#61; 10;     这一句下面)&amp;#xff0c;前面加extern就可以了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;extern&lt;/span&gt;  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; visited[MaxSize];\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["为什么在main文件中定义的全局变量在类的函数实现文件中访问不到？（使用的VS编程工具）", ["问题遇到的现象和发生背景", "\n", "就是照着书上敲代码，然后发现和书上面即使是一样，却发生了bug", "\n", "问题相关代码，请勿粘贴截图", "\n", "//头文件", "\n", "#", "ifndef", " MGraph_H        ", "//避免重复包含MGraph.h文件", "\n", "#", "define", " MGraph_H", "\n\n", "const", " ", "int", " MaxSize = ", "10", ";        ", "//图中最多顶点个数", "\n\n", "template", "<", "class", " ", "DataType", ">\n", "class", " ", "MGraph", " {\n", "public", ":\n    ", "MGraph", "(DataType a[], ", "int", " n, ", "int", " e);    ", "//构造函数，建立有n个顶点e条边的图", "\n    ~", "MGraph", "() {};    ", "//析构函数", "\n    ", "void", " ", "DFSTraverse", "(", "int", " v)", ";        ", "//深度优先遍历", "\n    ", "void", " ", "BFSTraverse", "(", "int", " v)", ";        ", "//广度优先遍历", "\n", "private", ":\n    DataType vertex[MaxSize];    ", "//存放途中顶点的数组", "\n    ", "int", " arc[MaxSize][MaxSize];    ", "//存放途中边的数组", "\n    ", "int", " vertexNum, arcNum;        ", "//图的顶点数和边数", "\n};\n", "#", "endif", "\n\n", "//类函数实现类文件：", "\n", "#", "include", "<iostream>", "        ", "//引入输入输出流", "\n", "using", " ", "namespace", " std;\n", "#", "include", "\"MGraph.h\"", "        ", "//引入类MGraph的声明", "\n\n\n", "//以下是对类MGraph的成员函数定义", "\n", "template", " <", "class", " ", "DataType", ">\nMGraph<DataType>::", "MGraph", "(DataType a[], ", "int", " n, ", "int", " e) {\n    ", "int", " i, j, k;\n    vertexNum = n; arcNum = e;\n    ", "for", " (i = ", "0", "; i < vertexNum; i++) {    ", "//存储图的顶点信息", "\n        vertex[i] = a[i];\n    }\n    ", "for", "(i=", "0", ";i<vertexNum;i++)        ", "//初始化边的信息", "\n        ", "for", " (j = ", "0", "; j < vertexNum; j++) {\n            arc[i][j] = ", "0", ";\n        }\n    ", "for", " (k = ", "0", "; k < arcNum; k++) {        ", "//存储变得信息", "\n        cout << ", "\"请输入边的两个顶点序号：\"", ";\n        cin >> i >> j;\n        arc[i][j] = ", "1", "; arc[j][i] = ", "1", ";\n    }\n}\n\n", "template", "<", "class", " ", "DataType", ">\n", "void", " MGraph<DataType>::", "DFSTraverse", "(", "int", " v) {        ", "//深度优先遍历图", "\n    cout << vertex[v]; visited[v] = ", "1", ";\n    ", "for", " (", "int", " j = ", "0", "; j < vertexNum; j++)\n        ", "if", " (arc[v][j] == ", "1", " && visited[j] == ", "0", ")\n            ", "DFSTraverse", "(j);\n}\n\n", "template", "<", "class", " ", "DataType", ">\n", "void", " MGraph<DataType>::", "BFSTraverse", "(", "int", " v)        ", "//广度优先遍历图", "\n{\n    ", "int", " Q[MaxSize];    ", "//假设队列采用顺序存储且不会发生溢出", "\n    ", "int", " front = ", "-1", ", rear = ", "-1", ";        ", "//初始化队列", "\n    cout << vertex[v]; visited[v] = ", "1", "; Q[++rear] = v;        ", "//被访问点入队", "\n    ", "while", " (front != rear) {\n        v = Q[++front];\n        ", "for", " (", "int", " j = ", "0", "; j < vertexNum;j++) {\n            ", "if", " (arc[v][j] == ", "1", " && visited[j] == ", "0", ") {\n                cout << vertex[j]; visited[j]=", "1", "; Q[++rear] = j;\n            }\n        }\n    }\n}\n", "//main函数文件", "\n", "#", "include", "<iostream>", "        ", "//引入输入输出流", "\n", "using", " ", "namespace", " std;\n", "#", "include", "\"MGraph.cpp\"", "        ", "//引入类MGraph的成员函数定义", "\n\n ", "int", " visited[MaxSize];\n\n", "//以下是主函数", "\n", "int", " ", "main", "()", " ", "{\n    ", "char", " ch[] = {", "'A'", ",", "'B'", ",", "'C'", ",", "'D'", ",", "'E'", "};    ", "//定点信息", "\n    ", "MGraph<", "char", "> ", "MG", "(ch, ", "5", ", ", "6", ")", ";    ", "//图中顶点信息是char型", "\n    ", "for", " (", "int", " i = ", "0", "; i < MaxSize;i++) {    ", "//初始化图中所有顶点均未被访问", "\n        visited[i] = ", "0", ";\n    }\n    cout << ", "\"深度优先遍历序列是：\"", ";\n    MG.", "DFSTraverse", "(", "0", ");    ", "//从顶点0出发进行深度优先遍历图", "\n    cout << endl;\n    ", "for", " (", "int", " i = ", "0", "; i < MaxSize;i++) {        ", "//初始化途中所有顶点均未被访问", "\n        visited[i] = ", "0", ";\n    }\n    cout << ", "\"广度优先遍历序列是：\"", ";\n    MG.", "BFSTraverse", "(", "0", ");    ", "//从顶点0出发广度优先遍历图", "\n    cout << endl;\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "使用过将沈明visited放到函数实现类文件的头部，但是出现了其他bug，说是以及有声明了", "\n", "我想要达到的结果", "\n", "解决这visited问题"]], "Tag": "算法设计"}
{"Answer": "错误太多了，只能简单修改下编译错误\r\n\r\n```\r\n// Q1062027.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\n#define OK 1\r\n#define ERROR 0\r\nint M=0;\r\nint N=0;\r\ntypedef int Status;\r\ntypedef struct ElemType\r\n{\r\n    int level;\r\n    char name[20];\r\n    char gender;\r\n    char ID[20];\r\n\r\n}ElemType;\r\ntypedef struct Node   //结点结构\r\n{\r\n    ElemType data;\r\n    struct Node *next;\r\n}Node,*QueuePtr;\r\n\r\ntypedef struct\r\n{\r\n    QueuePtr front,rear;\r\n} LinkQueue;\r\n\r\nStatus InitQueue(LinkQueue **Q)  // 队列初始化\r\n{\r\n   QueuePtr p;\r\n   p=(QueuePtr)malloc(sizeof(QueuePtr));\r\n   if(!p)\r\n   {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n   }\r\n   *Q=(LinkQueue*)malloc(sizeof(LinkQueue));\r\n   if(!(*Q))\r\n   {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n   }\r\n   p-&gt;next=NULL;\r\n   (*Q)-&gt;front=p;\r\n   (*Q)-&gt;front=(*Q)-&gt;rear;\r\n   return OK;\r\n}\r\n\r\nStatus EnQueue(LinkQueue *Q, ElemType e)  //入队\r\n{\r\n    QueuePtr s=(QueuePtr)malloc(sizeof(Node));\r\n    if(!s)\r\n    {\r\n       printf(\"内存分配失败\");\r\n       return ERROR;\r\n    }\r\n    s-&gt;data=e;\r\n    s-&gt;next=NULL;\r\n    Q-&gt;rear-&gt;next=s;      //把拥有元素e的新节点s赋值给队尾的后继节点\r\n    Q-&gt;rear=s;            //把当前s设置为队尾节点，rear指向s\r\n    return OK;\r\n}\r\n\r\nStatus DeQueue(LinkQueue *Q,ElemType *e)  //出队\r\n{\r\n    QueuePtr p;\r\n    if(Q-&gt;front==Q-&gt;rear)\r\n    {\r\n        printf(\"队列为空!\");\r\n        return ERROR;\r\n    }\r\n\r\n    p=Q-&gt;front-&gt;next;     //  将预删除的队头结点暂存给p\r\n    *e=p-&gt;data;             // 将删除的队头结点赋值给e 即出队\r\n    Q-&gt;front-&gt;next=p-&gt;next;  //  将原队头结点后继p-&gt;next 赋值给现投结点后继\r\n\r\n    if(Q-&gt;rear==p)\r\n    {\r\n        Q-&gt;rear=Q-&gt;front;      //若队头是队尾，则删除后将rear指向头结点\r\n\r\n    }\r\n     free(p);\r\n\r\n    return OK;\r\n}\r\n\r\nStatus PriorEnQueue(LinkQueue *Q1,LinkQueue *Q2,ElemType e)\r\n{\r\n    if(e.level==3)\r\n       {\r\n           EnQueue(Q1,e);\r\n       }\r\n    else\r\n       {\r\n          EnQueue(Q2,e);\r\n       }\r\n\r\n        return OK;\r\n\r\n}\r\n\r\n\r\nStatus PriorDeQueue(LinkQueue*Q1,LinkQueue*Q2)\r\n{\r\n    ElemType e;\r\n    if(!(Q2-&gt;front==Q2-&gt;rear))\r\n       DeQueue(Q2,&amp;e);\r\n    else if(!(Q1-&gt;front==Q1-&gt;rear))\r\n       DeQueue(Q1,&amp;e);\r\n    else\r\n    {\r\n        return ERROR;\r\n    }\r\n    return OK;\r\n\r\n}\r\n\r\nStatus GetIN(LinkQueue*Q1,LinkQueue*Q2,ElemType*e)\r\n{\r\n    int i;\r\n    int n;\r\n    printf(\"请输入前来就诊的病人数量：\");\r\n    scanf(\"%d\",&amp;n);\r\n    for(i=M;i&lt;M+n;i++)\r\n    {\r\n        printf(\"\\n请输入第%d个病人的优先级：\",i+1);\r\n        scanf(\"%d\",&amp;e[i].level);\r\n        printf(\"\\n请输入第%d个病人的姓名：\",i+1);\r\n        scanf(\"%s\",e[i].name);\r\n        printf(\"\\n请输入第%d个病人的性别：\",i+1);\r\n        scanf(\"%s\",&amp;e[i].gender);\r\n        printf(\"\\n请输入第%d个病人的身份证：\",i+1);\r\n        scanf(\"%s\",e[i].ID);\r\n        PriorEnQueue(Q1,Q2,e[i]);\r\n    }\r\n    M=M+n;\r\n    return OK;\r\n}\r\nStatus ShowInformation(ElemType *e)\r\n{\r\n    int i;\r\n    LinkQueue *Q1,*Q2;\r\n    InitQueue(&amp;Q1);\r\n    InitQueue(&amp;Q2);\r\n    PriorDeQueue(Q1,Q2);\r\n    printf(\"优先级----------姓名----------性别----------身份证\\n\");\r\n    for(i=N;i&lt;N;i++)\r\n    {\r\n        printf(\"\\n\");\r\n        printf(\"%5d %5s %5s %10s\",e[i].level,e[i].name,&amp;e[i].gender,e[i].ID);\r\n    }\r\n    return OK;\r\n}\r\nint main()\r\n{\r\n    LinkQueue Q1,Q2;\r\n\tQ1.front=Q1.rear=NULL;\r\n\tQ2.front=Q2.rear=NULL;\r\n    ElemType e;\r\n    GetIN(&amp;Q1,&amp;Q2,&amp;e);\r\n    ShowInformation(&amp;e);\r\n    return 0;\r\n\r\n}\r\n\r\n\r\n```\r\n# 问题采纳了可以继续帮你看运行的错误", "Konwledge_Point": "优先队列实现", "Question": ["医院排队就诊问题（C语言实现）求大神帮忙查看一下如何修改这些错误", ["问题描述：", "\n医院急诊科室，有医生1名", "\n现有病人7名，先后到达", "\n病人病情轻重各有不同（分3级，3级最重，1级最轻），重症的优先就诊；病症相同的，先来的先就诊。", "\n模型假设：", "\n1.病人挂完号后进入对应的科室，每位病人属性包括姓名，性别，和身份证号", "\n2.一开始的时候，医生空闲（等待病人）。", "\n3.有护士根据病人病情，给出病情优先级后，再排队。", "\n4.排队的病人按照先后次序排队，重症的优先就诊，病症相同的，先来的先就诊。。", "\n5.一位医生每次只能看一个病人。", "\n解决方案模型：", "\n1. 程序模拟医院排队就诊，程序开始输入病人资料（包括优先级，姓名，性别，和身份证号）。", "\n2. 设置一个病人的优先队列，按照优先级由高到低，分段排队，最开头的是优先级最高的病人；如果优先级相同，那么按照先来后到的顺序排队。", "\n3. 对病人队列有两种操作，pop与push，医生每次从病人队列里面pop一个病人，并打印病人信息（包括优先级，姓名，性别，和身份证号），直到队列空。", "\n————————————————", "\n运行输入：", "\n请按照优先级，姓名，性别，和身份证号顺序输入：", "\n1 吕雅畅 男 141130198509277099", "\n1 卞丹丹 女 532925197204181629", "\n2 潘德茂 男 500114197005227938", "\n1 邬碧玉 女 620721198202232320", "\n3 金慧雅 女 533123198508252640", "\n2 岑俊茂 男 152526198707214777", "\n3 毕采萱 女 420600198202107509", "\n\n", "输出：", "\n就诊顺序......", "\n3 金慧雅 女 533123198508252640", "\n3 毕采萱 女 420600198202107509", "\n2 潘德茂 男 500114197005227938", "\n2 岑俊茂 男 152526198707214777", "\n1 吕雅畅 男 141130198509277099", "\n1 卞丹丹 女 532925197204181629", "\n1 邬碧玉 女 620721198202232320", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define OK 1\n#define ERROR 0\nint M=0;\nint N=0;\ntypedef int Status;\ntypedef struct ElemType\n{\n    int level;\n    char name[20];\n    char gender;\n    char ID[20];\n\n}ElemType;\ntypedef struct Node   //结点结构\n{\n    ElemType data;\n    struct Node *next;\n}Node,*QueuePtr;\n\ntypedef struct\n{\n    QueuePtr front,rear;\n} LinkQueue;\n\nStatus InitQueue(LinkQueue *Q)  // 队列初始化\n{\n   QueuePtr p;\n   p=(QueuePtr)malloc(sizeof(QueuePtr));\n   if(!p)\n   {\n       printf(\"内存分配失败\");\n       return ERROR;\n   }\n   Q=(LinkQueue*)malloc(sizeof(LinkQueue));\n   if(!Q)\n   {\n       printf(\"内存分配失败\");\n       return ERROR;\n   }\n   p->next=NULL;\n   Q->front=p;\n   Q->front=Q->rear;\n   return OK;\n}\n\nStatus EnQueue(LinkQueue *Q, ElemType e)  //入队\n{\n    QueuePtr s=(QueuePtr)malloc(sizeof(Node));\n    if(!s)\n    {\n       printf(\"内存分配失败\");\n       return ERROR;\n    }\n    s->data=e;\n    s->next=NULL;\n    Q->rear->next=s;      //把拥有元素e的新节点s赋值给队尾的后继节点\n    Q->rear=s;            //把当前s设置为队尾节点，rear指向s\n    return OK;\n}\n\nStatus DeQueue(LinkQueue *Q,ElemType *e)  //出队\n{\n    QueuePtr p;\n    if(Q->front==Q->rear)\n    {\n        printf(\"队列为空!\");\n        return ERROR;\n    }\n\n    p=Q->front->next;     //  将预删除的队头结点暂存给p\n    *e=p->data;             // 将删除的队头结点赋值给e 即出队\n    Q->front->next=p->next;  //  将原队头结点后继p->next 赋值给现投结点后继\n\n    if(Q->rear==p)\n    {\n        Q->rear=Q->front;      //若队头是队尾，则删除后将rear指向头结点\n\n    }\n     free(p);\n\n    return OK;\n}\n\nStatus PriorEnQueue(LinkQueue *Q1,LinkQueue *Q2,ElemType *e)\n{\n    if(e->level==3)\n       {\n           EnQueue(Q1,e);\n       }\n    else\n       {\n          EnQueue(Q2,e);\n       }\n\n        return OK;\n\n}\n\n\nStatus PriorDeQueue(LinkQueue*Q1,LinkQueue*Q2)\n{\n    ElemType *e;\n    if(!(Q2->front==Q2->rear))\n       e=DeQueue(Q2,e);\n    else if(!(Q1->front==Q1->rear))\n        e=DeQueue(Q1,e);\n    else\n    {\n        return ERROR;\n    }\n    return OK;\n\n}\n\nStatus GetIN(LinkQueue*Q1,LinkQueue*Q2,ElemType*e)\n{\n    int i;\n    int n;\n    printf(\"请输入前来就诊的病人数量：\");\n    scanf(\"%d\",&n);\n    for(i=M;i<M+N;i++)\n    {\n        printf(\"\\n请输入第%d个病人的优先级：\",i+1);\n        scanf(\"%d\",&e[i].level);\n        printf(\"\\n请输入第%d个病人的姓名：\",i+1);\n        scanf(\"%s\",e[i].name);\n        printf(\"\\n请输入第%d个病人的性别：\",i+1);\n        scanf(\"%s\",&e[i].gender);\n        printf(\"\\n请输入第%d个病人的身份证：\",i+1);\n        scanf(\"%s\",e[i].ID);\n        PriorEnQueue(Q1,Q2,e);\n    }\n    M=M+n;\n    return OK;\n}\nStatus ShowInformation(ElemType *e)\n{\n    int i;\n    LinkQueue *Q1,*Q2;\n    InitQueue(Q1);\n    InitQueue(Q2);\n    PriorDeQueue(Q1,Q2);\n    printf(\"优先级----------姓名----------性别----------身份证\\n\");\n    for(i=N;i<N;i++)\n    {\n        printf(\"\\n\");\n        printf(\"%5d %5s %5s %10s\",e[i].level,e[i].name,&e[i].gender,e[i].ID);\n    }\n    return OK;\n}\nint main()\n{\n    LinkQueue *Q1,*Q2;\n    ElemType *e;\n    GetIN(Q1,Q2,e);\n    ShowInformation(e);\n    return 0;\n\n}\n\n\n\n\n\n\n", "\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;操作符和f_dis函数加上const修饰&amp;#xff0c;代码修改如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;cstdio&amp;gt;\n#include&amp;lt;cmath&amp;gt;\n#include&amp;lt;queue&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\nconst int N&amp;#61;100,M&amp;#61;100;\nint n,m;\nbool map[N][M]; \nclass map\n{\nprivate:\n\tbool **p;\n\tint n,m;\n\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t{\n\t\treturn (((i&amp;gt;&amp;#61;((x1&amp;gt;x2)?x2:x1))&amp;amp;&amp;amp;(i&amp;lt;&amp;#61;((x1&amp;gt;x2)?x1:x2)))&amp;amp;&amp;amp;((j&amp;gt;&amp;#61;((y1&amp;gt;y2)?y2:y1))&amp;amp;&amp;amp;(j&amp;lt;&amp;#61;((y1&amp;gt;y2)?y1:y2))));\n\t}\n\tstruct point\n\t{\n\t\tstatic int tar_x,tar_y;\n\t\tint x,y,b_dis;\n\t\tint f_dis() const  //修改1\n\t\t{\n\t\t\treturn abs(x-tar_x)&amp;#43;abs(y-tar_y);\n\t\t}\n\t\tbool operator&amp;lt;(const point b)const   //修改2\n\t\t{\n\t\t\treturn (b_dis&amp;#43;f_dis())&amp;gt;(b.b_dis&amp;#43;b.f_dis());\n\t\t}\n\t};\npublic:\n\tmap(const int N,const int M)\n\t{\n\t\tn&amp;#61;N;\n\t\tm&amp;#61;M;\n\t\tp&amp;#61;new bool*[N&amp;#43;1];\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;N;i&amp;#43;&amp;#43;)\n\t\t\tp[i]&amp;#61;new bool[M&amp;#43;1];\n\t}\n\t~map()\n\t{\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\t\t\tdelete[] p[i];\n\t\tdelete[] p;\n\t}\n\tvoid set_obstruction(const int x,const int y)\n\t{\n\t\tp[x][y]&amp;#61;true;\n\t\treturn;\n\t}\n\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\t\t\tfor(int j&amp;#61;1;j&amp;lt;&amp;#61;m;j&amp;#43;&amp;#43;)\n\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\tp[i][j]&amp;#61;true;\n\t\treturn;\n\t}\n\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tpriority_queue&amp;lt;point&amp;gt; q;\n\t\tpoint::tar_x&amp;#61;x2;\n\t\tpoint::tar_y&amp;#61;y2;\n\t\tpoint start;\n\t\tstart.x&amp;#61;x1;\n\t\tstart.y&amp;#61;y1;\n\t\tq.push(start);\n\t}\n};\nint main()\n{\n\n\treturn 0;\n}\n//我想写一个A*寻路实现&amp;#xff0c;但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了&amp;#xff08;555~~&amp;#xff09;&amp;#xff0c;求大佬告知怎么改啊&amp;#xff1f; &lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "优先队列实现", "Question": ["以下这段C++代码为啥跑不了？", ["\n", "#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int N=100,M=100;\nint n,m;\nbool map[N][M]; \nclass map\n{\n\tprivate:\n\t\tbool **p;\n\t\tint n,m;\n\t\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t\t{\n\t\t\treturn (((i>=((x1>x2)?x2:x1))&&(i<=((x1>x2)?x1:x2)))&&((j>=((y1>y2)?y2:y1))&&(j<=((y1>y2)?y1:y2))));\n\t\t}\n\t\tstruct point\n\t\t{\n\t\t\tstatic int tar_x,tar_y;\n\t\t\tint x,y,b_dis;\n\t\t\tint f_dis()\n\t\t\t{\n\t\t\t\treturn abs(x-tar_x)+abs(y-tar_y);\n\t\t\t}\n\t\t\tbool operator<(point b)\n\t\t\t{\n\t\t\t\treturn (b_dis+f_dis())>(b.b_dis+b.f_dis());\n\t\t\t}\n\t\t};\n\tpublic:\n\t\tmap(const int N,const int M)\n\t\t{\n\t\t\tn=N;\n\t\t\tm=M;\n\t\t\tp=new bool*[N+1];\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tp[i]=new bool[M+1];\n\t\t}\n\t\t~map()\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tdelete[] p[i];\n\t\t\tdelete[] p;\n\t\t}\n\t\tvoid set_obstruction(const int x,const int y)\n\t\t{\n\t\t\tp[x][y]=true;\n\t\t\treturn;\n\t\t}\n\t\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\t\tp[i][j]=true;\n\t\t\treturn;\n\t\t}\n\t\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tpriority_queue<point> q;\n\t\t\tpoint::tar_x=x2;\n\t\t\tpoint::tar_y=y2;\n\t\t\tpoint start;\n\t\t\tstart.x=x1;\n\t\t\tstart.y=y1;\n\t\t\tq.push(start);\n\t\t}\n};\nint main()\n{\n\t\n\treturn 0;\n}\n//我想写一个A*寻路实现，但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了（555~~），求大佬告知怎么改啊？ "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;具体的步骤如下:&lt;/p&gt;\n&lt;p&gt;1.启动Netty服务&amp;#xff0c;运行上面给出的启动代码&lt;br /&gt;2.启动WireShark&amp;#xff0c;并选择本机网卡上的流量&lt;br /&gt;3.进行过滤&amp;#xff0c;比如过滤出Netty服务端口为8085的流量&lt;br /&gt;4.开始抓包&amp;#xff0c;并分析抓取到的包&lt;br /&gt;5.需要注意的是&amp;#xff0c;WireShark需要管理员权限运行&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;如果遇到问题&amp;#xff0c;检查以下几点&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1.依赖库是否正确引入&lt;br /&gt;2.网络是否正常&lt;br /&gt;3.端口是否被占用&lt;br /&gt;4.是否有其他程序正在使用相同的端口&lt;br /&gt;5.是否有权限启动服务&lt;br /&gt;6.配置文件是否正确&lt;br /&gt;仅供参考&amp;#xff0c;望采纳&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["Netty怎么用WireShark抓包呢", ["Netty怎么用WireShark抓包呢？", "\n", "这是启动的代码", "\n", "@ServiceScan", "\n", "public", " ", "class", " ", "Server", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n        ", "try", " {\n            ", "NettyServer", " nettyServer = ", "new", " ", "NettyServer", "(", "\"192.168.10.1\"", ", ", "8085", ", ", "SerializerCode", ".", "HESSIAN", ".", "getCode", "());\n            nettyServer.", "start", "();\n        } ", "catch", " (", "RpcException", " e) {\n            e.", "printStackTrace", "();\n        }\n    }\n}\n", "\n", "@Slf4j\npublic ", "class", " NettyServer extends AbstractRpcServer {\n\n\n    ", "/**\n     * 服务器启动时 优先做一些预加载\n     */", "\n    \n    ", "/**\n     *\n     * @param hostName 启动服务所在机器的主机号，可以是私网或者公网\n     * @param port 启动服务所在机器的端口号\n     * @param serializerCode 序列化代码\n     * @throws RpcException\n     */", "\n    public ", "NettyServer(String ", "hostName", ", ", "int", " ", "port", ", Integer ", "serializerCode", ")", " throws RpcException {\n        this.hostName = hostName.equals(", "\"localhost\"", ")", " || ", "hostName.equals(", "\"127.0.0.1\"", ") ? ", "IpUtils", ".", "get", "PubIpAddr()", " : hostName;\n        log.info(", "\"start with host: {}, port: {}\"", ", this.hostName, port);\n        this.port = port;\n        ", "//serviceRegistry = new NacosServiceRegistry();", "\n        ", "//serviceProvider = new DefaultServiceProvider();", "\n        ", "/**\n         * 使用 SPI 机制，接口与实现类解耦到配置文件\n         */", "\n        serviceRegistry = ", "ServiceLoader", ".", "load(", "ServiceRegistry", ".", "class", ").iterator", "()", ".next", "()", ";\n        serviceProvider = ", "ServiceLoader", ".", "load(", "ServiceProvider", ".", "class", ").iterator", "()", ".next", "()", ";\n\n        serializer = ", "CommonSerializer", ".", "get", "ByCode(", "serializerCode", ")", ";\n        ", "// 扫描 @ServiceScan 包下的 所有 @Service类，并 注册它们", "\n        scan", "Services()", ";\n    }\n\n    @Override\n    public void start", "()", " {\n        ", "/**\n         *  封装了 之前 使用的 线程吃 和 任务队列\n         *  实现了 ExecutorService 接口\n         */", "\n        ", "ShutdownHook", ".", "get", "ShutdownHook()", ".add", "ClearAllHook()", ";\n        EventLoopGroup bossGroup = ", "new", " ", "NioEventLoopGroup()", ";\n        EventLoopGroup workerGroup = ", "new", " ", "NioEventLoopGroup()", ";\n\n        ", "try", " {   \n            ", "/**\n             *  启动服务\n             */", "\n            ServerBootstrap serverBootstrap = ", "new", " ", "ServerBootstrap()", ";\n            serverBootstrap.group(bossGroup, workerGroup)\n                    .channel(", "NioServerSocketChannel", ".", "class", ")\n                    .handler(", "new", " ", "LoggingHandler(LogLevel.INFO)", ")\n                    .option(ChannelOption.SO_BACKLOG, ", "256", ")\n                    .option(ChannelOption.SO_KEEPALIVE, ", "true", ")\n                    .child", "Option(ChannelOption.TCP_NODELAY, ", "true", ")", "\n                    .child", "Handler(", "new", " ChannelInitializer<SocketChannel>()", " {\n                        @Override\n                        protected void init", "Channel(SocketChannel ", "ch", ")", " throws Exception {\n                            ChannelPipeline pipeline = ch.pipeline", "()", ";\n                            ", "/**\n                             * 读 超时 触发, WriteIdleTime 和 allIdleTime 为 0 表示不做处理\n                             */", "\n                            pipeline.add", "Last(", "new", " IdleStateHandler(30, 0, 0, TimeUnit.SECONDS)", ");\n                            pipeline.add", "Last(", "new", " CommonEncoder(", "serializer", ")", ");\n                            pipeline.add", "Last(", "new", " CommonDecoder()", ");\n                            pipeline.add", "Last(", "new", " NettyServerHandler()", ");\n                        }\n                    });\n            ChannelFuture future = serverBootstrap.bind(port).sync", "()", ";\n            future.channel", "()", ".close", "Future()", ".sync", "()", ";\n\n        } catch (Exception e) {\n            log.error(", "\"Error occurred while starting server! {}\"", ",e);\n            e.print", "StackTrace()", ";\n        } finally {\n            bossGroup.shutdown", "Gracefully()", ";\n            workerGroup.shutdown", "Gracefully()", ";\n        }\n    }\n\n}\n", "\n", "Wireshark怎么抓呀，我一直没抓到", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/679629798646139.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;兄弟新加的程序位置应该在输入函数&amp;#xff0c;而不是打印函数啊&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "优先队列实现", "Question": ["想先删掉链表里的VIP客户再删掉Ordinary客户该怎么写delete函数？", ["问题描述", "注意：用链表完成", "现在银行都有排队叫号系统，如果你到银行去办理业务，首先取得一个顺序号，并告诉你前面有多少人在等待。", "现在请你设计、并实现该系统。", "\n", "客户信息包括：取号的号码、客户银行卡号码、客户类型（包括普通客户和vip客户，分别用Ordinary和VIP表示）。", "VIP用户有优先权，即VIP入队时，可以插入到  所有Ordinary类型用户的前面，已经排队的最后一个VIP用户的后面。", "\n", "本题要求实现以下功能：", "（1）客户进入银行并取号，该功能对应的命令为IN number type，number表示客户银行卡号码，type表示客户类型。", "（2）在上一题基础上，按取号顺序列出当前未办理业务的客户信息，该功能对应的命令为LIST。", "（3）客户办理完业务并离开银行，该功能对应的命令为OUT。", "（4）退出系统，该功能对应的命令为QUIT。", "\n", "输入", "输入有多行，每行表示一种操作。", "\n", "本题实现的操作有：", "IN guestnumber guesttype", "其中IN 表示入队，guestnumber表示客户银行卡号码，guesttype有两种取值，分别为Ordinary和VIP，表示普通客户与VIP客户。", "\n", "LIST", "按取号的顺序输出队列中所有排队的客户信息。", "\n", "QUIT", "退出银行排队系统", "\n", "请注意：输入的数据中，只有最后一个命令是QUIT命令。", "输出", "输出有多行，对不同的命令给出不同的输出。", "\n", "以下是具体的输出说明：", "IN 客户银行卡号码　客户类型", "该命令首先在单独的一行中输出\"IN:\", 然后再输出客户信息。", "客户信息包括客户编号 客户银行卡号码　客户类型 该客户前面的客户数。客户编号由系统在客户取号的时候给定，从1开始顺序编号。", "客户类型分为Ordinary和VIP。数据之间用一个空格分开。", "\n", "请注意：", "第一个客户入队后，则该用户的顺序号为1，前面有0个客户等待；", "第二个客户入队后，则该用户的顺序号为2，前面有1个客户等待。", "以此类推。", "\n", "LIST", "该命令首先在单独的一行中输出\"LIST:\", 后面有若干行先按客户类型（VIP优先），再按客户取号的顺序输出，每一行输出一个客户的信息，每行的输出格式为", "客户编号 客户银行卡号码 客户类型", "\n", "OUT", "该命令首先在单独的一行中输出\"OUT:\"，接下来一行输出办理业务的客户信息，包括顺序号，客户银行卡号码和客户类型。", "如果没有办理业务的客户，则输出\"FAILED:\"。", "\n", "QUIT", "在单独的一行中显示\"GOOD BYE!\"后结束程序。", "输入样列", "IN 1000001 Ordinary", "IN 2000003 VIP", "IN 2000009 VIP", "OUT", "OUT", "OUT", "OUT", "IN 1000007 Ordinary", "IN 2000005 VIP", "LIST", "OUT", "QUIT", "\n", "输出样例", "IN:1 1000001 Ordinary 0", "IN:2 2000003 VIP 0", "IN:3 2000009 VIP 1", "OUT:2 2000003 VIP", "OUT:3 2000009 VIP", "OUT:1 1000001 Ordinary", "FAILED:", "IN:4 1000007 Ordinary 0", "IN:5 2000005 VIP 0", "LIST:", "5 2000005 VIP", "4 1000007 Ordinary", "OUT:5 2000005 VIP", "GOOD BYE!", "\n", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "typedef", " ", "struct", " ", "Client", "{\n    ", "int", " sernumber;\n    ", "char", " guestnumber[", "20", "];\n    ", "char", " guesttype[", "20", "];\n    ", "struct", " ", "Client", " *next;\n}", "Client", ";\n", "int", " n=", "0", ";\n", "int", " wait1=", "0", ",wait2=", "0", ";\n", "int", " out1=", "0", ",out2=", "0", ";\n", "void", " ", "inputSingle", "(", "Client", " *s)", "\n", "{\n    ", "scanf", "(", "\"%s %s\"", ",s->guestnumber,s->guesttype);\n}\n", "void", " ", "outputSingle", "(", "Client", " *s)", "\n", "{\n    n+=", "1", ";\n    s->sernumber=n;\n    ", "if", "(", "strcmp", "(s->guesttype,", "\"VIP\"", ")==", "0", "){\n        ", "printf", "(", "\"%d %s %s %d\\n\"", ",s->sernumber,s->guestnumber,s->guesttype,wait1-out1);\n        wait1++;\n    }\n    ", "if", "(", "strcmp", "(s->guesttype,", "\"Ordinary\"", ")==", "0", "){\n        ", "printf", "(", "\"%d %s %s %d\\n\"", ",s->sernumber,s->guestnumber,s->guesttype,wait2-out1-out2);\n        wait2++;\n    }\n}\n", "void", " ", "outputList", "(", "Client", " *L)", "\n", "{\n    ", "Client", " *p;\n    p=L->next;\n    ", "while", "(p!=", "NULL", "){\n        ", "outputSingle", "(p);\n        p=p->next;\n    }\n}\n", "void", " ", "insert", "(", "Client", " *L,", "Client", " *s)", "\n", "{\n    ", "Client", " *pre,*p;\n    pre=L;\n    p=L->next;\n    ", "while", "(p!=", "NULL", "){\n        pre=p;\n        p=p->next;\n    }\n    s->next=pre-next;\n    pre->next=s;\n}\n", "int", " ", "delete", "(", "Client", " *L,", "Client", " *s)", "\n", "{\n    ", "Client", " *pre,*p;\n    pre=L;\n    p=L->next;\n    ", "while", "(p!=", "NULL", "&&", "strcmp", "(p->guesttype,", "\"VIP\"", ")==", "0", "){\n        pre->next=p->next;\n        ", "free", "(p);\n        out1++;\n    }\n    ", "if", "(p==", "NULL", "){\n        ", "return", " ", "0", ";\n    }\n    ", "else", "{\n        pre=p;\n        p=p->next;\n    }\n}\n", "Client", "* ", "createList", "()", "\n", "{\n    ", "Client", " *L;\n    L=(", "Client", " *)", "malloc", "(", "sizeof", "(", "Client", "));\n    L->next=", "NULL", ";\n    ", "return", " L;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "Client", " *s,*L;\n    string order;\n    ", "while", "(", "1", "){\n        cin>>order;\n        ", "if", "(order==", "\"IN\"", "){\n            ", "printf", "(", "\"IN:\"", ");\n            s=(", "Client", " *)", "malloc", "(", "sizeof", "(", "Client", "));\n            ", "inputSingle", "(s);\n            ", "outputSingle", "(s);\n        }\n        ", "if", "(order==", "\"LIST\"", "){\n            ", "puts", "(", "\"LIST:\"", ");\n            ", "outputList", "(L);\n        }\n        ", "if", "(order==", "\"OUT\"", "){\n            \n        }\n    }\n    ", "return", " ", "0", ";\n}\n", "\n", "暂时只写了这些，我想能不能遍历链表两遍，先删掉VIP再删掉Ordinary呢？但是我不知道咋写"]], "Tag": "算法设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你看下这篇博客吧, 应该有用&amp;#x1f449; &amp;#xff1a;&lt;a href=\"https://blog.csdn.net/zhaoyangjian724/article/details/122755481?utm_source&amp;#61;csdn_ai_ada_ask_robot\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;java中的空指针异常&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "优先队列实现", "Question": ["空指针异常 java.lang，如何解决？", ["java.lang.NullPointerException", "空指针异常 找了半天没找到", "有会的指导一下吗", "java.lang.NullPointerException", "\n", "package Search;", "\n", "import java.io.IOException;", "import java.util.Scanner;", "\n", "public class Chuanyueleichi1 {", "    /*", "     * 题目描述", "    X星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，", "    否则将报废。", "    某坦克需要从A区到B区去（A，B区本身是安全区，没有正能量或负能量特征），", "    怎样走才能路径最短？", "\n", "已知的地图是一个方阵，上面用字母标出了A，B区，\n其它区都标了正号或负号分别表示正负能量辐射区。\n例如：\nA + - + -\n- + - - +\n- + + + -\n+ - + - +\nB + - + -\n\n坦克车只能水平或垂直方向上移动到相邻的区。\n\n输入格式\n输入第一行是一个整数n，表示方阵的大小， ", "4", "<=n<", "100", "\n接下来是n行，每行有n个数据，可能是A，B，+，-中的某一个，中间用空格分开。\nA，B都只出现一次。\n输出格式\n要求输出一个整数，表示坦克从A区到B区的最少移动步数。\n如果没有方案，则输出", "-1", "\n\n样例输入\n", "5", "\nA + - + -\n- + - - +\n- + + + -\n+ - + - +\nB + - + -\n样例输出\n", "10", "\n\n思想\n", "1.", "图的广度优先算法 直接算出最短路径所用，数据结构 队列（在chuanyueleichi2中具体实现）\n", "2.", "图的深度优先算法 遍历所有路径，求出最小路径（具体在本类实现）\n\n\n步骤\n一.建立全局变量\n    ", "1.", "坐标（x，y）\n    ", "2.", "当前区域辐射值\n    ", "3.", "达到该区所走步数\n二.输入，初始化节点\n    ", "1.", "找到A区位置，并赋值给dfs入口\n三.dfs建立\n    ", "1.", "注意回溯\n*/\n", "public", " ", "static", " ", "String", "[][] arr  = ", "new", " ", "String", "[", "101", "][", "101", "] ;\n", "public", " ", "static", " ", "int", " n = ", "0", ";", "//雷区大小", "\n", "public", " ", "static", " ", "int", " x =", "0", ",y =", "0", ";\n", "public", " ", "static", " ", "int", " min = ", "0", ";", "//记录到达B区最小步数", "\n", "public", " ", "static", " ", "int", "[][] visit =  ", "new", " ", "int", "[", "101", "][", "101", "];", "//标记已走过的雷区 初始值为0 表示都没走过", "\n", "public", " ", "static", " ", "int", " []fx = {", "1", ",", "0", ",", "-1", ",", "0", "};\n", "public", " ", "static", " ", "int", " []fy = {", "0", ",", "-1", ",", "0", ",", "-1", "};", "//表示移动方向分别是 下 右 上 左", "\n", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args)", " throws NumberFormatException, IOException ", "{\n    ", "// TODO Auto-generated method stub", "\n    \n    Scanner sc = ", "new", " ", "Scanner", "(System.in);\n     n = sc.", "nextInt", "();", "//雷区大小", "\n    ", "int", " a = ", "0", ",b=", "0", ";\n    ", "//arr = new String[n+1][n+1];", "\n    ", "//visit = new int[n+1][n+1];", "\n    ", "for", "(", "int", " i = ", "1", " ; i <= n; i++) {\n        ", "for", "(", "int", " j = ", "1", " ; j<= n ;j++) {\n            arr[i][j] = sc.", "next", "();\n            \n            ", "if", "(arr[i][j].", "equals", "(", "\"A\"", ")) {\n                a = i;\n                b = j;\n            }\n        }\n    }\n    ", "dfs", "(a,b,", "\"o\"", ",", "0", ");\n    System.out.", "println", "(min);\n}\n\n", "//输入为坐标  当前的状态（+，-，A，B），当前的步数", "\n", "private", " ", "static", " ", "void", " ", "dfs", "(", "int", " x, ", "int", " y, ", "String", " status, ", "int", " step)", " ", "{\n    ", "// TODO Auto-generated method stub", "\n    ", "if", "(arr[x][y].", "equals", "(", "\"B\"", ")) {\n        min = Math.", "min", "(step, min);\n        ", "return", " ;\n    }\n    \n    ", "int", " x1 = ", "0", " ,y1 = ", "0", ";", "//表示移动的坐标", "\n    ", "for", "(", "int", " i = ", "0", " ; i < ", "4", " ;i++) {\n        x1 = x +fx[i];\n        y1 = y +fy[i];\n        ", "//判断接下来的雷区是否符合要求 且没有重复", "\n        ", "if", "( ", "is", "(x1,y1,x,y)&&visit[x1][y1]!=", "1", ") {\n            ", "//符合的话 标记 已访问", "\n            visit[x1][y1]=", "1", ";\n            ", "dfs", "(x1,y1,arr[x1][y1],step+", "1", ");", "//进入递归", "\n            ", "//当前递归结束 访问标记位取消 以免 访问不到B区（如果有B 区的话）", "\n            visit[x1][y1]=", "0", ";\n        }\n    }\n    \n    \n}\n\n", "private", " ", "static", " ", "boolean", " ", "is", "(", "int", " x1, ", "int", " y1,", "int", " x,", "int", " y)", " ", "{\n    ", "// TODO Auto-generated method stub", "\n    ", "if", "(x1 >= ", "0", "&& x1 <= n && y1 >= ", "0", "&& y1 <=n&&arr[x1][y1]!=arr[x][y])\n        ", "return", " ", "true", ";\n    ", "return", " ", "false", ";\n}\n", "\n", "}", "\n", "Exception in thread \"main\" java.lang.NullPointerException", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:90)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.dfs(Chuanyueleichi1.java:103)", "    at BlueCup/Search.Chuanyueleichi1.main(Chuanyueleichi1.java:83)"]], "Tag": "算法设计"}
{"Answer": "你这里面使用了递归没有 ？ \r\n\r\n看你这种情况，引起堆栈溢出的可能性，有两种。一种是递归，一种就是内存没有往堆上分配，即没有使用malloc等内存分配函数。\r\n\r\n我认为递归引起的可能性更大。", "Konwledge_Point": "优先队列实现", "Question": ["AI八数码问题 Stack Overflow", ["AI课本八数码问题，我是用广度优先搜索，用Ismatch来记录状态是否已经遍历，个人感觉算法基本没错吧！可是编译程序的时候只要步数长一点（5步可以输出）就没有输出，用Debug调试显示是：Stack Overflow。我看了很久的代码，也没有搞懂需要在哪里做优化。希望大家看下给点意见。谢谢", "\n[code=\"c\"]#include ", "\n#include ", "\n#define M 362881", "\n\n", "bool IsAnswer = false;", "\nbool Ismatch[M];//标记是否已经遍历过", "\nint tos,len;//队列指针tos,长度len", "\nint tt[9]={1,1,2,6,24,120,720,5040,40320};", "\nchar dest[10];//目标状态", "\nchar tmap[10];", "\nenum dir{up,down,left,right,none};", "\n\n", "struct {", "\n    int dir;", "\n    int t;", "\n}path[M];//记录路径", "\n\n", "struct eightnum{", "\n    char map[10];", "\n    int x,y;", "\n    int father;", "\n    dir myDir;//父节点移动的方向", "\n}num[M];", "\neightnum temp;", "\n\n", "void back_push(eightnum _num)//push", "\n{", "\n    strcpy(num[len].map, _num.map);", "\n    num[len].x = _num.x;", "\n    num[len].y = _num.y;", "\n    num[len].father = _num.father;", "\n    num[len].myDir = _num.myDir;", "\n    ++len;", "\n}", "\n\n", "eightnum front_pop()//pop", "\n{", "\n    tos++;", "\n    if(tos<len)", "\n        return num[tos];", "\n    else", "\n        printf(\"Wrong about the queue!\\n\");", "\n}", "\n\n", "int getHash(char _map[])//获取hash", "\n{", "\n    int hash;", "\n    int k,l;", "\n    hash = 0;", "\n    int count = 0; ", "\n    for(k=0;k<9;++k){", "\n        count = 0;", "\n        for(l = 0 ; l < k ;++ l){", "\n            if(_map[k]<_map[l])", "\n                count++;", "\n        }", "\n        hash += count*tt[k];", "\n    }", "\n    return hash;", "\n}", "\n\n", "int ReverseNum(char _map[])//逆序数", "\n{", "\n    int k,l;", "\n    int count = 0;", "\n    for(k=0;k<9;++k){", "\n        for(l = 0 ; l < k ;++ l){", "\n            if(_map[k] == '0')", "\n                continue;", "\n            else if(_map[k]<_map[l])", "\n                count++;", "\n        }", "\n    }", "\n    return count;", "\n}", "\n\n", "void DFS(eightnum _tmp)//dfs", "\n{", "\n    getHash(_tmp.map);", "\n    if(strcmp(_tmp.map,dest)==0){//find the answer", "\n        IsAnswer = true;", "\n        printf(\"Find the path!\\n\");", "\n        return;", "\n    }", "\n    else if(len>=M){//flow", "\n        printf(\"Above Flow!\");", "\n        return ;", "\n    }", "\n    else{", "\n        //down", "\n        if( _tmp.x != 2){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[_tmp.x*3+_tmp.y];", "\n            tmap[_tmp.x*3+_tmp.y] = tmap[(_tmp.x+1)*3+_tmp.y];", "\n            tmap[(_tmp.x+1)*3+_tmp.y] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x + 1;", "\n                temp.y = _tmp.y;", "\n                temp.father = tos;", "\n                temp.myDir = down;", "\n                back_push(temp);", "\n            }", "\n        }", "\n        //right", "\n        if( _tmp.y != 2 ){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[(_tmp.x)*3+_tmp.y];", "\n            tmap[(_tmp.x)*3+_tmp.y]= tmap[(_tmp.x)*3+_tmp.y+1];", "\n            tmap[(_tmp.x)*3+_tmp.y+1] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x;", "\n                temp.y = _tmp.y+1;", "\n                temp.father = tos;", "\n                temp.myDir = right;", "\n                back_push(temp);", "\n            }", "\n        }", "\n        //up", "\n        if(_tmp.x != 0){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[_tmp.x*3+_tmp.y];", "\n            tmap[_tmp.x*3+_tmp.y] = tmap[(_tmp.x-1)*3+_tmp.y];", "\n            tmap[(_tmp.x-1)*3+_tmp.y] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x - 1;", "\n                temp.y = _tmp.y;", "\n                temp.father = tos;", "\n                temp.myDir = up;", "\n                back_push(temp);", "\n            }", "\n        }", "\n        //left", "\n        if( _tmp.y != 0 ){", "\n            strcpy(tmap,_tmp.map);", "\n            char m_tmp;", "\n            m_tmp = tmap[_tmp.x*3+_tmp.y];", "\n            tmap[_tmp.x*3+_tmp.y]= tmap[(_tmp.x)*3+_tmp.y-1];", "\n            tmap[(_tmp.x)*3+_tmp.y-1] = m_tmp;", "\n            int m_hash = getHash(tmap);", "\n            if(Ismatch[m_hash]==false){", "\n                Ismatch[m_hash] = true;", "\n                strcpy(temp.map,tmap);", "\n                temp.x = _tmp.x;", "\n                temp.y = _tmp.y-1;", "\n                temp.father = tos;", "\n                temp.myDir = left;", "\n                back_push(temp);", "\n            }", "\n        }", "\n\n", "}\neightnum m_tmp = front_pop();\nDFS(m_tmp);\n", "\n\n", "}", "\n\n", "void myDisplay(char _map[]){//display", "\n    int ii;", "\n    for(ii=0;ii<9;++ii){", "\n        if(0==ii%3)", "\n            printf(\"\\n\");", "\n        if(_map[ii] == '0')", "\n            printf(\"    \");", "\n        else", "\n            printf(\"%c   \",_map[ii]);", "\n    }", "\n    printf(\"\\n-----------------------------\\n\");", "\n}", "\n\n", "int main()", "\n{", "\n    char input[10] ;//输入", "\n    strcpy(input,\"283164705\");", "\n    strcpy(dest,\"123804765\");", "\n    int i;", "\n    tos =  -1;", "\n    len  = 0;", "\n    strcpy(temp.map,input);", "\n    printf(\"原始状态:\\n\");", "\n    myDisplay(input);", "\n    for(i=0;i<M;++i)", "\n        Ismatch[i] = false;", "\n    if( ReverseNum(input)%2 != ReverseNum(dest)%2){", "\n        printf(\"Not exist the answer!\\n\");", "\n        return 1;", "\n    }", "\n    for(i=0;i<10;++i){", "\n        if(temp.map[i] == '0'){", "\n            Ismatch[getHash(temp.map)] = true;", "\n            temp.x = i/3;", "\n            temp.y = i%3;", "\n            temp.father=-1;", "\n            temp.myDir = none;", "\n            back_push(temp);", "\n            break;", "\n        }", "\n    }", "\n    eightnum _tmp = front_pop();", "\n    DFS(_tmp);", "\n    int kk = 0;", "\n    if (IsAnswer){", "\n        int ff = tos ;", "\n        while( num[ff].father != -1){", "\n            path[kk].dir = num[ff].myDir;", "\n            path[kk].t =  ff;", "\n            kk++;", "\n            //printf(\"%d\",num[ff].myDir);", "\n            ff = num[ff].father;", "\n        }", "\n    }   ", "\n\n", "for(i=kk-1;i>=0;--i)\n{\n    if(path[i].dir==0){\n        printf(\"down-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==1){\n        printf(\"up-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==2){\n        printf(\"right-->\");\n        myDisplay(num[path[i].t].map);\n    }\n    else if(path[i].dir==3){\n        printf(\"left-->\");\n        myDisplay(num[path[i].t].map);\n    }\n}\nreturn 0;\n", "\n\n", "}[/code]", "\n\n", "ps:用“在link option中增加/stack”这种方法可以实现步长到27，我是想知道是否有更好的方法可以优化代码"]], "Tag": "算法设计"}
