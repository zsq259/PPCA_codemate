{"Answer": "&lt;p&gt;å¯ä»¥å‚è€ƒä¸€ä¸‹&lt;a href=\"https://blog.csdn.net/weixin_41598179/article/details/112795877\" id=\"textarea_1652959433332_1652959657006_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Cè¯­è¨€â€”â€”æœ€çŸ­è·¯å¾„é—®é¢˜&amp;#xff08;Dijkstraç®—æ³•&amp;#xff09;_ç§‹ç±³å§å§çš„åšå®¢-CSDNåšå®¢_cè¯­è¨€æ±‚æœ€çŸ­è·¯å¾„&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Cè¯­è¨€â€”â€”æœ€çŸ­è·¯å¾„é—®é¢˜&amp;#xff08;Dijkstraç®—æ³•&amp;#xff09;ä¼˜ç‚¹â€”â€”é€‚ç”¨èŒƒå›´å¹¿&amp;#xff0c;æœ¬ä»£ç å±äºå…¬å¼å‹ä»£ç &amp;#xff0c;å¯éšæ„æ›´æ¢æ•°æ®&amp;#xff0c;é€‚åˆé›¶åŸºç¡€åŒå­¦ã€‚ä¸»è¦æ€è·¯&amp;#xff1a;ä¸»è¦æ€è·¯&amp;#xff1a;1.ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„å­˜æ”¾å¸¦æƒæœ‰å‘å›¾çš„é‚»æ¥çŸ©é˜µ&amp;#xff1b;2.åŸºäºDijkstraç®—æ³•åˆ†åˆ«ç”³è¯·ä¸‰ä¸ªæ•°ç»„&amp;#xff0c;distance[], path[], used[]åˆ†åˆ«è®°å½•ä»èµ·ç‚¹åˆ°å…¶ä½™å„ç‚¹çš„æœ€çŸ­è·ç¦»&amp;#xff0c;åˆ°ç›®æ ‡ç»“ç‚¹è·¯å¾„ä¸Šçš„å‰ä¸€ä¸ªç»“ç‚¹&amp;#xff0c;åˆ°å›¾ä¸­æŸä¸ªç»“ç‚¹æ˜¯å¦å·²æ‰¾åˆ°æœ€çŸ­è·¯å¾„&amp;#xff1b;3.é€æ¸ç¡®å®šä»æºç‚¹åˆ°å›¾ä¸­å„ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„&amp;#xff0c;ç›´è‡³ç»“æŸ&amp;#xff1b;æœ€çŸ­è·¯å¾„ä¾‹é¢˜&amp;#xff1a;å¦‚ä¸‹å›¾æ‰€ç¤º&amp;#xff0c;æ±‚æœ€çŸ­ç»ã€‚&amp;lt;fnä»£ç &amp;#xff1a;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/weixin_41598179/article/details/112795877&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["ã€cè¯­è¨€ã€‘ã€æ•°æ®ç»“æ„ã€‘Dijkstraç®—æ³•æ±‚æœ€å¿«é€é¤è·¯å¾„", ["è¾“å…¥ï¼šç¬¬ä¸€è¡ŒåŒ…å«3ä¸ªæ•´æ•°n,m,tï¼Œåˆ†åˆ«è¡¨ç¤ºè·¯å£çš„ä¸ªæ•°ï¼Œé“è·¯çš„æ¡æ•°å’Œç›®çš„è·¯å£ã€‚", "ï¼ˆ2 â‰¤ n â‰¤ 10ï¼Œ1 â‰¤ m â‰¤ 50ï¼Œ1 â‰¤ w â‰¤ 10ï¼‰", "æ¥ä¸‹æ¥mè¡Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° u,v,wï¼Œè¡¨ç¤ºè·¯å£uåˆ°è·¯å£vå­˜åœ¨ä¸€æ¡è€—æ—¶wçš„å•è¡Œé“ã€‚", "è¾“å‡ºï¼šéª‘æ‰‹ä»å•†å®¶ï¼ˆä½äº1å·è·¯å£ï¼‰åˆ°ç›®çš„è·¯å£çš„æœ€çŸ­æ—¶é—´ï¼Œè‹¥è·¯å¾„ä¸å­˜åœ¨ï¼Œè¾“å‡º-1ã€‚"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;ç”¨Dijkstraç®—æ³•æ±‚ä»é¡¶ç‚¹0å‡ºå‘çš„æœ€çŸ­è·¯å¾„ã€‚ç®€å•æ¥è¯´&amp;#xff0c;å°±æ˜¯ä»èµ·ç‚¹å¼€å§‹&amp;#xff0c;ä¸æ–­åœ°é€‰å–æœªè®¿é—®çš„è·ç¦»èµ·ç‚¹æœ€è¿‘çš„é¡¶ç‚¹&amp;#xff0c;å¹¶æ›´æ–°è¯¥é¡¶ç‚¹åˆ°å…¶ä»–é¡¶ç‚¹çš„è·ç¦»ã€‚è¿™æ ·ä¸æ–­æ‰§è¡Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®è¿‡&amp;#xff0c;å¾—åˆ°èµ·ç‚¹åˆ°å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;æ¥ç€&amp;#xff0c;ç»™å‡ºäº†ç®—æ³•æ‰§è¡Œçš„æŸæ—¶åˆ»&amp;#xff0c;å³å·²ç»è®¿é—®äº†0ã€2ã€3ã€4å››ä¸ªé¡¶ç‚¹ã€‚è¿™æ„å‘³ç€æ­¤æ—¶å·²ç»æ‰¾åˆ°äº†ä»èµ·ç‚¹åˆ°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;æœ€å&amp;#xff0c;éœ€è¦åœ¨è¿™ä¸ªæ—¶åˆ»é€‰å–ä¸‹ä¸€æ­¥ç›®æ ‡é¡¶ç‚¹ã€‚å› ä¸ºé¢˜ç›®æ²¡æœ‰ç»™å‡ºå®Œæ•´çš„å›¾&amp;#xff0c;æ‰€ä»¥æˆ‘ä¹Ÿä¸çŸ¥é“é¡¶ç‚¹Dä¸0ã€2ã€3ã€4ä¹‹é—´çš„è¿è¾¹æƒ…å†µã€‚å› æ­¤æ— æ³•ç¡®å®šé¡¶ç‚¹Dæ˜¯å¦ä¸ºä¸‹ä¸€æ­¥çš„ç›®æ ‡é¡¶ç‚¹ã€‚&lt;/p&gt;\n&lt;p&gt;å› æ­¤&amp;#xff0c;é€‰é¡¹Aã€Bã€Cã€Dä¸­åªæœ‰é€‰é¡¹Dæ˜¯æ— æ³•ç¡®å®šçš„&amp;#xff0c;å…¶ä»–ä¸‰ä¸ªé€‰é¡¹çš„é¡¶ç‚¹éƒ½ä¸æ˜¯ä¸‹ä¸€æ­¥çš„ç›®æ ‡é¡¶ç‚¹çš„å¯èƒ½æ€§æ¯”è¾ƒå°&amp;#xff0c;ä½†éœ€è¦å…·ä½“æƒ…å†µå…·ä½“åˆ†æã€‚å¦‚æœéœ€è¦ç¡®å®šä¸‹ä¸€æ­¥ç›®æ ‡é¡¶ç‚¹&amp;#xff0c;éœ€è¦çŸ¥é“é¡¶ç‚¹Dä¸0ã€2ã€3ã€4ä¹‹é—´çš„è¿è¾¹æƒ…å†µã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["Dijkstraç®—æ³•çš„é—®é¢˜", ["ç”¨Dijkstraç®—æ³•æ±‚ä¸€ä¸ªå¸¦æƒæœ‰å‘å›¾Gä¸­ä»é¡¶ç‚¹0å‡ºå‘çš„æœ€çŸ­è·¯å¾„ï¼Œåœ¨ç®—æ³•æ‰§è¡Œçš„æŸæ—¶åˆ»ï¼ŒS={0,2,3,4}ï¼Œä¸‹ä¸€æ­¥é€‰å–çš„ç›®æ ‡é¡¶ç‚¹å¯èƒ½æ˜¯   D   ã€‚", "A.é¡¶ç‚¹2            B.é¡¶ç‚¹3            C.é¡¶ç‚¹4            D.é¡¶ç‚¹7", "è¡¨è¾¾çš„æ˜¯å•¥æ„æ€å˜ï¼Œé¡¶ç‚¹7åˆæ˜¯æ€ä¹ˆå‡ºæ¥çš„å˜"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/a19990412/article/details/80232810\" id=\"textarea_1655439466811_1655439572959_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•&amp;#xff08;Dijkstra&amp;#xff09;è¯æ˜_è‚¥å®…_Seançš„åšå®¢-CSDNåšå®¢_è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•è¯æ˜&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;é¦–å…ˆ&amp;#xff0c;è¿™ç¯‡æ–‡ç« æ˜¯åœ¨è®²ã€Šå›¾è®ºã€‹æ—¶å€™å†™æ–‡ç« &amp;#xff08;æ‰€ä»¥&amp;#xff0c;è¿˜æ˜¯ä»¥ç†è®ºä¸ºä¸»&amp;#xff0c;ä»¥åæœ‰ç©ºçš„æ—¶å€™&amp;#xff0c;ä¼šæŠŠä»£ç å‘ä¸Šæ¥&amp;#xff0c;ä¸è¿‡æˆ‘è§‰å¾—å¤§å®¶çœ‹å®Œç†è®º&amp;#xff0c;å¦‚æœè®²å¾—å¥½&amp;#xff0c;ä»£ç ä¹Ÿå°±æ¯”è¾ƒå®¹æ˜“äº†ã€‚å¦‚æœè®²å¾—ä¸å¥½&amp;#xff0c;ç½‘ä¸Šçš„ä»£ç ä¹Ÿæ˜¯å¤§æŠŠ&amp;#xff0c;ä¸çœ‹è¿™ç¯‡æ–‡ç« ä¹Ÿç½¢äº†&amp;#xff09;ä¸‹å›¾ä¸ºè€å¸ˆçš„è¯¾ä»¶å†…å®¹éƒ¨åˆ†&amp;#xff0c;æˆ‘è§‰å¾—è™½ç„¶è¯¦å°½&amp;#xff0c;ä½†ä¹Ÿæœ‰äº›æ¯ç‡¥ã€‚å¯èƒ½æ˜¯ä¸ºäº†å‡ç»ƒè¯­è¨€å§ã€‚å¦‚æœæœ‰è€å¿ƒçœ‹çš„è¯&amp;#xff0c;å€’çœŸçš„æ˜¯ä¸€ç¯‡éå¸¸å¥½çš„æ–‡ç« ã€‚&amp;#xff08;åæ­£è¿™ä¸ªåº”è¯¥æ˜¯æ¯”ç™¾åº¦ç™¾ç§‘è¦å¼ºçš„â€¦.&amp;#xff09; æˆ‘åœ¨åé¢ä¼šç”¨è‡ªå·±çš„è¯­è¨€é˜...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/a19990412/article/details/80232810&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["è¯æ˜è¯æ˜Dijkstraç®—æ³•æ­£ç¡®æ€§ï¼Œå¹¶åˆ†ææ—¶é—´å¤æ‚åº¦", ["è¯æ˜Dijkstraç®—æ³•æ­£ç¡®æ€§ï¼Œå¹¶åˆ†æåœ¨æœªä¼˜åŒ–çš„æƒ…å†µä¸‹å…¶å¹³å‡æƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ã€‚å‡è®¾å›¾ä¸ºG=(V,E)", "\n", "è¦æ±‚ï¼šc/c++ï¼Œæœ‰è¯æ˜è¿‡ç¨‹"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;æ®µé”™è¯¯ä¸€èˆ¬æ˜¯æ•°ç»„ä¸‹æ ‡è¶Šç•Œ&lt;br /&gt;æˆ–è€…æŒ‡é’ˆæ²¡æœ‰æ­£ç¡®æŒ‡å‘æˆ–æ²¡æœ‰åˆ†é…ç©ºé—´&lt;br /&gt;å‚è€ƒä»£ç &lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; namespace std;\nstruct Node {\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x, y;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n};\nstruct TS {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n};\n\nTS HHH[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N, &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; D, G[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\nNode Dist[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; visit[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-keyword\"&gt;false&lt;/span&gt;};\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; cmp(TS a, TS b) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.distant &amp;lt; b.distant;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main() {\n    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; D;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;32.5&lt;/span&gt;) {\n        printf(&amp;#34;1\\n&amp;#34;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; X, Y;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tol &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fill(G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; &lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        cin &amp;gt;&amp;gt; X &amp;gt;&amp;gt; Y;\n        HHH[i].num &amp;#61; i;\n        Dist[i].x &amp;#61; X;\n        Dist[i].y &amp;#61; Y;\n        Dist[i].distant &amp;#61; sqrt(X * X &amp;#43; Y * Y);\n        HHH[i].distant &amp;#61; Dist[i].distant;\n        Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;) {\n            Init(i, j);\n        }\n    }\n    \n    sort(HHH, HHH &amp;#43; N, cmp);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HHH[i].distant &amp;gt; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; HHH[i].distant &amp;lt;&amp;#61; D &amp;#43; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; !visit[HHH[i].num]) {\n            tol &amp;#61; BFS(HHH[i].num);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) break;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) printf(&amp;#34;0\\n&amp;#34;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j) {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; Dist[i].x - Dist[j].x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y &amp;#61; Dist[i].y - Dist[j].y;\n    G[i][j] &amp;#61; G[j][i] &amp;#61; sqrt(x * x &amp;#43; y * y);\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((Dist[i].x &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].x - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;) || (Dist[i].y &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].y - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;)) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n\n    visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n    Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; Q;\n    Q.push(i);\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!Q.empty()) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; Q.front();\n        Q.pop();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (Judge(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;)) {\n            cout &amp;lt;&amp;lt; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; endl;\n            stack&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; st;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;) {\n                st.push(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;];\n            }\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!st.empty()) {\n                &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Top &amp;#61; st.top();\n                st.pop();\n                cout &amp;lt;&amp;lt; Dist[Top].x &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; Dist[Top].y &amp;lt;&amp;lt; endl;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;][i] &amp;lt;&amp;#61; D &amp;amp;&amp;amp; !visit[i]) {\n                visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n                Dist[i].c &amp;#61; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;;\n                Q.push(i);\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ•°æ®ç»“æ„ä¹ é¢˜ï¼Œå›¾çš„Dijkstraç®—æ³•", ["é¢˜ç›®å¦‚ä¸‹", "\n", "This time let us consider the situation in the movie \"Live and Let Die\" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big headï¼ˆçœç•¥å·ï¼‰ Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).", "\n", "Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.", "\n", "Input Specification:", "Each input file contains one test case. Each case starts with a line containing two positive integers N (â‰¤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.", "\n", "Output Specification:", "For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.", "\n", "\n", "\n", "æˆ‘çš„ä»£ç ", "\n", "//è‡ªå·±å†™çš„ï¼ŒåŠé”™ç‰ˆæœ¬ ", "\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n#define MaxVertexNum ", "105", "\n#define M_INFINITY ", "65535", "\ntypedef int Vertex;\ntypedef double WeightType;\ntypedef struct Data{\n    int X,Y;\n}DataType[MaxVertexNum];\n\n", "/*è¾¹çš„å®šä¹‰*/", "\ntypedef struct ENode* PtrToENode;\nstruct ENode{\n    Vertex V1,V2;\n    WeightType Weight; \n};\ntypedef PtrToENode Edge;\n\n", "/*å›¾çš„å®šä¹‰*/", "\ntypedef struct GNode* PtrToGNode;\nstruct GNode{\n    int Nv;\n    int Ne;\n    WeightType D[MaxVertexNum][MaxVertexNum];\n    DataType Locate;\n};\ntypedef PtrToGNode MGraph;\n\n", "//åˆ›é€ å›¾çš„å‡½æ•°", "\nvoid InsertEdge(MGraph Graph, Edge E)\n{\n    G", "raph", "->", "D[E->V1][E->V2] = E->Weight;\n    G", "raph", "->", "D[E->V2][E->V1] = E->Weight;\n}\nMGraph CreatGraph(int VertexNum)\n{", "/*åˆå§‹åŒ–ä¸€ä¸ªå›¾ç»“æ„ï¼Œæ‰€æœ‰å¯¹è§’è¾¹ä¸º0ï¼Œéå¯¹è§’è¾¹ä¸ºINFINITY*/", "\n    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));\n    G", "raph", "->", "Nv = VertexNum;\n    G", "raph", "->", "Ne = ", "0", ";\n    int V,W;\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V;W<Graph->", "Nv;W++){\n            ", "if", "(V!=W){\n                G", "raph", "->", "D[V][W] = M_INFINITY;\n                G", "raph", "->", "D[W][V] = M_INFINITY;\n            }", "else", "{\n                G", "raph", "->", "D[V][W] = ", "0", ";\n            }\n        }\n    }\n    return Graph;\n}\nWeightType Length(double X1,double Y1,double X2,double Y2)\n{", "/*è¿”å›ä¸¤ä¸ªç‚¹çš„ç›´çº¿è·ç¦»*/", "\n    double deltx = X1-X2;\n    double delty = Y1-Y2;\n    WeightType weight = ", "sqrt", "(deltx*deltx + delty*delty);\n    return weight;\n}\nMGraph BuildGraph(int Nv,double D)\n{", "/*åˆ›é€ å›¾*/", "\n    int i,V,W;\n    Vertex X,Y;\n    WeightType Weight;\n    MGraph Graph = CreatGraph(Nv+", "1", ");\n    Edge E = (Edge)malloc(sizeof(struct ENode));\n    \n    V=", "1", ";\n    G", "raph", "->", "L", "ocate", "[0].X = Graph->", "Locate[", "0", "].Y = ", "0", ";\n    ", "for", "(i=", "1", ";i<=Nv;i++){\n        scanf(", "\"%d%d\"", ",&X,&Y);\n        \n        ", "if", "(", "abs", "(X)<", "50", " && ", "abs", "(Y)<", "50", " && Length(X,Y,", "0", ",", "0", ")>", "7.5", "){\n            G", "raph", "->", "Locate[V].X = X;\n            G", "raph", "->", "Locate[V].Y = Y;\n            V++;\n        }", "else", "{\n            G", "raph", "->", "Nv--;\n        }\n    }\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V+1;W<Graph->", "Nv;W++){\n            W", "eight", " = Length(Graph->", "L", "ocate", "[V].X,Graph->", "Locate[V].Y,\n            G", "raph", "->", "L", "ocate", "[W].X,Graph->", "Locate[W].Y);\n            ", "if", "(Weight<=D){\n                E->V1 = V;\n                E->V2 = W;\n                E->Weight = Weight;\n                ", "if", "(E->", "V1==", "0", ") E->Weight-=", "7.5", ";\n                InsertEdge(Graph,E);\n            }\n        }\n    }\n    \n    return Graph;\n}\n\nVertex FindMinDist(MGraph Graph, double dist[], int collected[])\n{\n    Vertex MinV, V;\n    int MinDist = M_INFINITY;\n    \n    ", "for", "(V=0; V<Graph->", "Nv; V++){\n        ", "if", "(collected[V]==", "0", " && dist[V]<MinDist){\n            MinDist = dist[V];\n            MinV = V;\n        }\n    }\n    ", "if", "( MinDist < M_INFINITY )\n        return MinV;\n    ", "else", " return ", "0", ";\n}\nvoid Dijkstra(MGraph Graph, double* dist, int* ", "path", ",int* collected)\n{\n    Vertex V,W;\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "dist", "[V] = Graph->", "D[", "0", "][V];\n        ", "if", "(dist[V]<M_INFINITY)\n            ", "path", "[V] = ", "0", ";\n        ", "else", "\n            ", "path", "[V] = -", "1", ";\n        collected[V] = ", "0", ";\n    }\n    ", "/*å…ˆå°†èµ·ç‚¹æ”¶å…¥é›†åˆ*/", "\n    dist[", "0", "] = ", "0", ";\n    collected[", "0", "] = ", "1", ";\n    \n    ", "while", "(", "1", "){\n        V = FindMinDist(Graph,dist,collected);\n        ", "if", "(V==", "0", ")\n            break;\n        collected[V] = ", "1", ";\n        ", "for", "(W=0;W<Graph->", "Nv;W++)\n            ", "if", "(collected[W]==0 && Graph->", "D[V][W]<M_INFINITY){\n                ", "if", "(dist[V]+Graph->", "D[V][W]<dist[W]){\n                    ", "dist", "[W] = dist[V]+Graph->", "D[V][W];\n                    ", "path", "[W] = V; \n                }\n            }\n    }\n}\n\nint min(int x,int y)\n{\n    ", "if", "(x<y) return x;\n    ", "else", " return y;\n}\n\nint main()\n{\n    ", "/*è¾“å…¥æ•°ï¼Œï¼ˆåˆå§‹Nvï¼Œå¯èƒ½ä¼šæ›´å°‘ï¼‰ï¼Œè¾“å…¥JanesBondä¸€æ¬¡æœ€è¿œè·³*/", "\n    int N,D,i;\n    scanf(", "\"%d%d\"", ",&N,&D);\n    ", "/*åˆ›é€ å›¾*/", "\n    MGraph Graph = BuildGraph(N,D);\n    ", "/*åˆå§‹åŒ–dist[],path[],collected[]*/", "\n    ", "double", " dist[Graph->", "Nv];\n    ", "int", " ", "path", "[Graph->", "N", "v", "],collected[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        dist[i] = M_INFINITY;\n        ", "path", "[i] = -", "1", ";\n        collected[i] = ", "0", ";\n    }\n    ", "/*Dijkstraç®—æ³•ç®—dist*/", "\n    Dijkstra(Graph,dist,", "path", ",collected);\n    \n    ", "/*æ‰¾åˆ°å¯ä»¥ä½œä¸ºå‡ºå£å¾—é³„é±¼ï¼ŒåŒæ—¶å°†å®ƒåˆ°å‡ºå£çš„è·ç¦»å­˜å‚¨åˆ°æ•°ç»„ä¸­*/", "\n    V", "ertex", " V,W,OutNode[Graph->", "Nv];\n    int flag = ", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++) OutNode[V]=", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "if", "(50-fabs(Graph->", "L", "ocate", "[V].X)<=D || 50-fabs(Graph->", "Locate[V].Y)<=D){\n            ", "if", "(50-fabs(Graph->", "Locate[V].X)<=D){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }", "else", " ", "if", "(50-fabs(Graph->", "Locate[V].Y<=D)){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }\n            flag=", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    flag = ", "0", ";\n    ", "for", "(W=1;W<Graph->", "Nv;W++){\n        ", "if", "(Graph->", "D[", "0", "][W]!=M_INFINITY){\n            flag = ", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    ", "/*ä»¥ä¸Šä¸ºåˆ¤æ–­æ˜¯å¦æœ‰å¯èƒ½å¯ä»¥å‡ºå»ï¼Œä¹Ÿå°±æ˜¯1>Islandæœ‰æ²¡æœ‰é‚»æ¥ç‚¹ï¼Œ2>æœ‰æ²¡æœ‰å¯ä»¥è·³å‡ºå»çš„é³„é±¼*/", "\n\n    ", "/*\n    æ‰¾æœ€çŸ­è·¯\n    1.æ‰¾å¯ä»¥å‡ºå»çš„è·¯å¾„\n    2.æ¯”è¾ƒå¯ä»¥å‡ºå»çš„è·¯å¾„ä¸­æœ€çŸ­è·¯å¾„ \n    */", "\n    \n    V", "ertex", " OutWay[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        OutWay[i]=-", "1", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(50-", "abs", "(Graph->", "L", "ocate", "[i].X)<=D || 50-", "abs", "(Graph->", "Locate[i].Y)<=D){\n            O", "utWay", "[i] = min(50-", "abs", "(Graph->", "L", "ocate", "[i].X),50-", "abs", "(Graph->", "Locate[i].Y));\n        }\n    }\n    \n    \n    ", "/*ä»å‡ºå£ä¸­æ›´æ–°è·¯å¾„é•¿åº¦*/", "\n    ", "double", " Outdist[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        Outdist[i] = ", "0", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            Vertex temNode = i;\n            ", "while", "(temNode){\n                Outdist[i]+=dist[temNode];\n                temNode = ", "path", "[temNode];\n            }\n        }\n    }\n    \n    ", "/*ä»è·¯å¾„ä¸­æ‰¾æœ€å°é•¿ï¼Œå¹¶è®°å½•*/", "\n    Vertex MinWay;\n    double Mindist=M_INFINITY;\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            ", "if", "(Mindist>Outdist[i]){\n                Mindist = Outdist[i];\n                MinWay = i;\n            }\n        }\n    }\n    \n    ", "/*ä»æœ€å°è·¯å¾„ä¸­æ‰¾ç»“ç‚¹ï¼Œåå‘è¾“å‡º*/", "\n    V", "ertex", " Stack[Graph->", "Nv];\n    int rear=-", "1", ",count=", "1", ";\n    Vertex temNode = MinWay;\n    ", "while", "(temNode){\n        Stack[++rear] = temNode;\n        temNode = ", "path", "[temNode];\n        count++;\n    }\n    printf(", "\"%d\\n\"", ",count);\n    ", "while", "(rear!=-", "1", "){\n        ", "printf", "(\"%d %d\\n\",Graph->", "L", "ocate", "[Stack[rear]].X,Graph->", "Locate[Stack[rear]].Y);\n        rear--;\n    }\n    \n    return ", "0", ";\n}\n\n", "\n", "æœ€åç»“æœ", "\n", "\n", "å®åœ¨ä¸çŸ¥é“å“ªé”™äº†ï¼Œæœ€åˆæ˜¯å‰ä¸‰é¡¹éƒ½é€šè¿‡äº†ï¼Œåæ¥å°±ä»å¤´å†æ¥ä¸€éï¼Œå“ªçŸ¥é“ç°åœ¨åé¢å‡ ä¸ªå¯¹äº†ç¬¬ä¸€ä¸ªé¡¹ç›®è¯´æ®µé”™è¯¯ï¼Œæ®µé”™è¯¯ç»™çš„ç†ç”±å¦‚ä¸‹", "\n", "\n", "ä¸è¿‡ç°åœ¨æµ‹è¯•ç‚¹ä¹Ÿä¸çŸ¥é“å“ªé”™äº†ï¼Œéº»çƒ¦çœ‹çœ‹å§"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;é‚»æ¥è¡¨ä½ å¯ä»¥ç†è§£ä¸ºå¤šä¸ªé“¾è¡¨&amp;#xff0c;æ¯ä¸ªé“¾è¡¨çš„å¤´æ˜¯ä¸€ä¸ªèŠ‚ç‚¹&amp;#xff0c;è€Œä½ æ·»åŠ ä¸€æ¡è¾¹add&amp;#xff08;a,b,c&amp;#xff09;ç›¸å½“äºç»™aå¢æ·»ä¸€ä¸ªå‡ºåº¦bé•¿åº¦ä¸ºc&amp;#xff0c;è€Œ next[a]ä¸­å‚¨å­˜çš„æ˜¯å°±æ˜¯aæ‰€æœ‰çš„å‡ºåº¦çš„åœ°å€&amp;#xff0c;nextå­˜å‚¨çš„æ˜¯ä¸‹ä¸€ä¸ªå‡ºåº¦çš„åœ°å€&amp;#xff0c;ver[i]å°±æ˜¯å‡ºåº¦ç‚¹çš„æ ‡å·&amp;#xff0c;edge[i]å¤´èŠ‚ç‚¹åˆ°å‡ºåº¦çš„è·ç¦»&amp;#xff0c;djçš„åŸºæœ¬æ€è·¯æ˜¯æ¯æ¬¡é€‰å–ä¸€ä¸ªç¦»åŸç‚¹æœ€è¿‘çš„è¾¹æ¥æ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»&amp;#xff0c;æˆ‘ä»¬å…ˆå°†{0&amp;#xff0c;1}åŠ å…¥å †ä¸­&amp;#xff0c;å †æ’åºpairæ ¹æ®firstä¼˜å…ˆåŸåˆ™&amp;#xff0c;æ‰€ä»¥æ„æ€å°±æ˜¯å †ä¸­1å·ç‚¹åˆ°ä¸€å·ç‚¹çš„è·ç¦»ä¸º0&amp;#xff0c;é‚£ä¹ˆæ­¤æ—¶ä¼šç”¨1å·ç‚¹å…ˆæ›´æ–°å®ƒå‡ºåº¦&amp;#xff0c;å¹¶ä¸”æ¯ä¸ªç‚¹æœ‰ä¸”åªä¼šè¢«åŠ å…¥ä¸€æ¬¡&amp;#xff0c;æˆ‘ä»¬å°†å®ƒæ‰“ä¸Šæ ‡è®°&amp;#xff0c;å¦‚æœå †ä¸­å·²ç»åŠ å…¥è¿‡è¿™ä¸ªæœ€çŸ­è¾¹&amp;#xff0c;æˆ‘ä»¬ç›´æ¥å°†å®ƒcontinue&amp;#xff0c;å¦åˆ™è€Œå¾ªç¯çš„ç»ˆç‚¹å°±æ˜¯æ²¡æœ‰è¾¹å†è¢«æ›´æ–°çš„æ—¶å€™&amp;#xff0c;ä¹Ÿå°±æ˜¯æ²¡æœ‰ä¸œè¥¿å¯ä»¥å…¥é˜Ÿäº†&amp;#xff0c;å¾ªç¯ç»“æŸã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["Dijkstraç®—æ³•åŠé‚»æ¥è¡¨ C++", ["priority_queue<pair<", "int", ",", "int", ">>q;", "//å¤§æ ¹å †-å°æ ¹å †", "\n    ", "memset", "(d,", "0x3f", ",", "sizeof", "(d);\n    ", "memset", "(v,", "0", ",", "sizeof", "(v));\n    d[", "1", "]=", "0", ";\n    q.", "push", "(", "make_pair", "(", "0", ",", "1", "));\n    ", "while", "(q.", "size", "())\n    ", "int", " x=q.", "top", "().second;q.", "pop", "();\n    ", "if", "(v[x])", "continue", ";\n    v[x]=", "1", ";\n    ", "for", "(", "int", " i=head[x];i;i=Next[i])\n    ", "int", " y=ver[i],z=edge[i];\n    ", "if", "(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.", "push", "(", "make_pair", "(-d[y],y));\n    }\n    } \n", "\n", "å¦‚ä¸Šï¼Œè¯·é—®ä¸€ä¸‹ï¼š", "\n", "while", "(q.", "size", "())\n", "if", "(v[x])", "continue", ";\n", "for", "(", "int", " i=head[x];i;i=", "Next", "[i])\n", "\n", "å„æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿˜æœ‰é‚»æ¥è¡¨çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿéº»çƒ¦äº†ï¼"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;ä¸è¡Œã€‚å› ä¸ºå„ç§è·¯å¾„çš„ æ­¥æ•°å¹¶ä¸ä¸€å®šç›¸åŒã€‚&lt;br /&gt;æ‰€æœ‰è¾¹æƒå€¼åŠ æ­£æ•°&amp;#xff0c;åªæœ‰åœ¨å„ç§è·¯å¾„æ­¥æ•°ç›¸åŒçš„æƒ…å†µä¸‹æ‰å¯è¡Œã€‚&lt;br /&gt;æ±‚å¸¦è´Ÿæƒå€¼è¾¹çš„å•æºæœ€çŸ­è·¯å¾„å¯ä»¥ç”¨è´å°”æ›¼-ç¦ç‰¹ç®—æ³•ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—", ["è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "å¯ä»¥æœ‰å¿å•Šï¼Œå¤§ç¥å¿«æ¥å•Š![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["OPNETå«æ˜Ÿç½‘ç»œè·¯ç”±ç®—æ³•ä»¿çœŸ", ["æœ€è¿‘è¦äº¤æ¯•è®¾å•¦ï¼ŒOPNETçš„å«æ˜Ÿç½‘ç»œè·¯ç”±ä»¿çœŸè¿˜ä¸ä¼šåšï¼Œæ±‚å¤§ç¥æŒ‡å¯¼å•Šï¼ŒçœŸçš„å¾ˆç€æ€¥ã€‚ç®—æ³•ä¸»è¦", "\næ˜¯æ”¶é›†é“¾è·¯çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚æ—¶å»¶ã€å¸¦å®½ã€ä¸¢åŒ…ç‡ï¼Œç„¶åå½’ä¸€åŒ–åˆ°[0,1]ï¼Œåˆ†é…æƒé‡ä½œä¸º", "\né“¾è·¯çš„Costï¼Œç„¶åç”¨Dijkstraç®—æ³•ã€‚", "\næ±‚æŒ‡å¯¼å•Šï¼Œæ€ä¹ˆåšä»¿çœŸï¼Œå‘œå‘œå‘œ~"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å¦‚æœæƒ³è¦åœ¨éå†å›¾ä¸­çš„æ‰€æœ‰ç‚¹ä¹‹åå¾—åˆ°æœ€ä¼˜è·¯å¾„&amp;#xff0c;å¯ä»¥ä½¿ç”¨ä¸€ç§å«åšæ—…è¡Œå•†é—®é¢˜&amp;#xff08;Travelling Salesman Problem&amp;#xff0c;TSP&amp;#xff09;çš„ç®—æ³•ã€‚TSP é—®é¢˜æ˜¯æŒ‡å¯»æ‰¾éå†ä¸€ä¸ªç»™å®šçš„åŸå¸‚åˆ—è¡¨çš„æœ€çŸ­è·¯å¾„çš„é—®é¢˜ã€‚&lt;/p&gt;\n&lt;p&gt;ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def tsp(self, &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;, end):\n    &lt;span class=\"hljs-comment\"&gt;# åˆå§‹åŒ–æœªéå†çš„ç‚¹çš„é›†åˆ&lt;/span&gt;\n    unvisited &amp;#61; set(self.nodes)\n    &lt;span class=\"hljs-comment\"&gt;# å°†èµ·å§‹ç‚¹åŠ å…¥åˆ°å·²éå†çš„ç‚¹çš„é›†åˆä¸­&lt;/span&gt;\n    visited &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;}\n    &lt;span class=\"hljs-comment\"&gt;# åˆå§‹åŒ–å½“å‰ç‚¹ä¸ºèµ·å§‹ç‚¹&lt;/span&gt;\n    current &amp;#61; &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#åˆå§‹åŒ–è·¯å¾„å’Œè·ç¦»ä¸º 0&lt;/span&gt;\n    path &amp;#61; []\n    distance &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\nwhile unvisited:\n    &lt;span class=\"hljs-comment\"&gt;# å¯»æ‰¾å½“å‰ç‚¹çš„æœ€è¿‘çš„æœªéå†çš„ç‚¹&lt;/span&gt;\n    next_node, next_distance &amp;#61; min([(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt;) for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;not&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; visited], &lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x: x[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# å°†æœ€è¿‘çš„æœªéå†çš„ç‚¹åŠ å…¥åˆ°å·²éå†çš„ç‚¹çš„é›†åˆä¸­&lt;/span&gt;\n    visited.add(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# ä»æœªéå†çš„ç‚¹çš„é›†åˆä¸­åˆ é™¤æœ€è¿‘çš„æœªéå†çš„ç‚¹&lt;/span&gt;\n    unvisited.remove(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# æ›´æ–°å½“å‰ç‚¹ä¸ºæœ€è¿‘çš„æœªéå†çš„ç‚¹&lt;/span&gt;\n    current &amp;#61; next_node\n    &lt;span class=\"hljs-comment\"&gt;# æ›´æ–°è·¯å¾„å’Œè·ç¦»&lt;/span&gt;\n    path.append(next_node)\n    distance &amp;#43;&amp;#61; next_distance\n\n&lt;span class=\"hljs-comment\"&gt;# å¦‚æœæœ€åä¸€ä¸ªéå†çš„ç‚¹ä¸æ˜¯ç»ˆç‚¹&amp;#xff0c;æ·»åŠ ä¸€æ¡ä»æœ€åä¸€ä¸ªéå†çš„ç‚¹åˆ°ç»ˆç‚¹çš„è¾¹&lt;/span&gt;\nif current !&amp;#61; end:\n    &lt;span class=\"hljs-comment\"&gt;# å¯»æ‰¾æœ€åä¸€ä¸ªéå†çš„ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·ç¦»&lt;/span&gt;\n    next_distance &amp;#61; min([cost for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;&amp;#61;&amp;#61; end&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# æ›´æ–°è·¯å¾„å’Œè·ç¦»&lt;/span&gt;\n    path.append(end)\n    distance &amp;#43;&amp;#61; next_distance\n\nreturn path, distance\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ–¹æ³•æ¥è§£å†³ TSP é—®é¢˜&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;graph &amp;#61; Graph(&lt;span class=\"hljs-string\"&gt;&amp;#39;map.txt&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;, distance &amp;#61; graph.tsp(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;)  # [&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(distance)  # &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ä»…ä¾›å‚è€ƒ&amp;#xff0c;æœ›é‡‡çº³&amp;#xff0c;è°¢è°¢ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ€ä¹ˆå°†ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„æ”¹æˆä»»æ„ä¸¤ç‚¹é—´éå†å®Œæ‰€æœ‰ç‚¹åçš„æœ€ä¼˜è·¯å¾„å‘¢", ["\n", "class", " ", "Graph", ":\n            ", "def", " ", "__init__", "(", "self,filename", "):", "#å°†åœ°å›¾å»ºæˆä¸€ä¸ªé‚»æ¥è¡¨", "\n        \n               graph_edges=[]", "#è¾¹çš„é•¿åº¦", "\n               ", "with", " ", "open", "(filename) ", "as", " fhandle:", "#è¯»å–æ–‡ä»¶ï¼Œä¸€è¡Œä¸€è¡Œçš„è¯»", "\n                      ", "for", " line ", "in", " fhandle:\n                          ", "if", " line==", "\"\\n\"", ":", "#è¯»å–æˆªæ­¢æ¡ä»¶ï¼Œæ³¨æ„å¿…é¡»åŠ å¦åˆ™ä¼šæŠ¥é”™", "\n                            ", "break", "\n                ", "#å°†map.txtæ–‡ä»¶ä¸­çš„æ•°æ®æŒ‰ç©ºæ ¼åˆ†ç¦»å¹¶å­˜å‚¨ï¼Œ*_ä»£è¡¨è¿™ä¸€è¡Œåé¢æ‰€æœ‰çš„å…ƒç´ ã€‚", "\n                          edge_from,edge_to,cost,*_=line.strip().split(", "\" \"", ")\n                          graph_edges.append((edge_from,edge_to,cost))", "#ä»¥å…ƒç»„çš„å½¢å¼åŠ å…¥åˆ°graph_edges", "\n        ", "#å»ºç«‹èŠ‚ç‚¹ï¼Œset() å‡½æ•°åˆ›å»ºä¸€ä¸ªæ— åºä¸é‡å¤å…ƒç´ é›†ï¼Œ", "\n        ", "#å¯è¿›è¡Œå…³ç³»æµ‹è¯•ï¼Œåˆ é™¤é‡å¤æ•°æ®ï¼Œè¿˜å¯ä»¥è®¡ç®—äº¤é›†ã€å·®é›†ã€å¹¶é›†ç­‰ã€‚", "\n               self.nodes =", "set", "()\n               ", "for", " edge ", "in", " graph_edges:\n            ", "#åˆå§‹åŒ–èŠ‚ç‚¹", "\n            ", "#update() æ–¹æ³•ç”¨äºä¿®æ”¹å½“å‰é›†åˆï¼Œå¯ä»¥æ·»åŠ æ–°çš„å…ƒç´ æˆ–é›†åˆåˆ°å½“å‰é›†åˆä¸­ï¼Œ", "\n            ", "#å¦‚æœæ·»åŠ çš„å…ƒç´ åœ¨é›†åˆä¸­å·²å­˜åœ¨ï¼Œåˆ™è¯¥å…ƒç´ åªä¼šå‡ºç°ä¸€æ¬¡ï¼Œé‡å¤çš„ä¼šå¿½ç•¥ã€‚", "\n                  self.nodes.update([edge[", "0", "],edge[", "1", "]])\n        ", "#å»ºç«‹é‚»æ¥è¡¨", "\n               self.adjacency_list = {node: ", "set", "() ", "for", " node ", "in", " self.nodes}\n               ", "for", " edge ", "in", " graph_edges:\n           ", "#å­—å…¸ä¸­çš„é”®è¡¨ç¤ºå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œè€Œé”®å€¼åˆ™æ˜¯ä»¥å­—å…¸çš„å½¢å¼å­˜åœ¨é‡Œé¢åŒ…æ‹¬å‡ ç»„ä¸€å…ƒç»„çš„å½¢å¼å‚¨å­˜çš„", "\n           ", "#è¡¨ç¤ºå¯è¾¾åˆ°èŠ‚ç‚¹ä»¥åŠæƒå€¼", "\n                   self.adjacency_list[edge[", "0", "]].add((edge[", "1", "],edge[", "2", "]))\n            ", "def", " ", "shortest_path", "(", "self, start_node, end_node", "):\n                start_node=nameEntry3.get()\n                end_node=nameEntry4.get()\n               \n        ", "#ä½¿ç”¨Dijkstraç®—æ³•æ‰¾åˆ°ä»èµ·å§‹ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè¿”å›ï¼ˆpath,distanceï¼‰", "\n               \n        ", "#åˆ›é€ ä¸€ä¸ªæœªè®¿é—®èŠ‚ç‚¹çš„é›†åˆåˆå§‹åŒ–ä¸ºæ‰€æœ‰èŠ‚ç‚¹", "\n                unvisited_nodes = self.nodes.copy()  \n        ", "#åˆ›å»ºä¸€ä¸ªå­—å…¸è¡¨ç¤ºæ¯ä¸ªç‚¹åˆ°èµ·å§‹ç‚¹çš„è·ç¦»ï¼Œæ¯ä¸ªç‚¹å…ˆåˆå§‹åŒ–ä¸ºinfé™¤äº†ç‚¹æœ¬èº«åˆå§‹åŒ–ä¸º0", "\n        ", "#å½“æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªæ›´çŸ­è·¯å¾„çš„æ—¶å€™æ›´æ–°è¿™ä¸ªå­—å…¸æ‰€å¯¹åº”çš„å€¼ï¼Œæ•°æ®ç»“æ„ä¸º èŠ‚ç‚¹ï¼šè·ç¦»", "\n                distance_from_start = {node: (", "0", " ", "if", " node == start_node ", "else", " INFINITY) ", "for", " node ", "in", " self.nodes}\n \n        ", "#åˆå§‹åŒ–å‰ç½®èŠ‚ç‚¹ä¹Ÿå°±æ˜¯ç”¨æ¥å¯»æ‰¾è·¯å¾„çš„æ–¹æ³•ï¼Œç»“æ„ä¸ºèŠ‚ç‚¹ï¼šèŠ‚ç‚¹å…¶ä¸­åé¢çš„èŠ‚ç‚¹æ˜¯å‰é¢", "\n        ", "#çš„å‰ç½®èŠ‚ç‚¹ï¼Œç”±æ­¤å¯ä»¥ä¸€æ­¥æ­¥æ‰¾åˆ°è·¯å¾„ï¼Œå¦‚æœæ‰¾åˆ°æ›´çŸ­è·¯å¾„å°±æ›´æ–°è¿™ä¸ªå­—å…¸", "\n                previous_node = {node: ", "None", " ", "for", " node ", "in", " self.nodes}\n                ", "while", " unvisited_nodes:\n            ", "#å°†å½“å‰èŠ‚ç‚¹è®¾ç½®ä¸ºåˆ°ç›®å‰ä¸ºæ­¢åœ¨æœªè®¿é—®èŠ‚ç‚¹è¿™ä¸ªå­—å…¸ä¸­è·¯å¾„æœ€çŸ­çš„èŠ‚ç‚¹", "\n                     current_node = ", "min", "(\n                ", "#ä»unvisited_nodesä¸­æ‰¾åˆ°é”®å€¼æœ€å°çš„èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹", "\n                          unvisited_nodes, key=", "lambda", " node: distance_from_start[node]\n                       )\n            ", "#ä»æœªè®¿é—®çš„èŠ‚ç‚¹ä¸­ï¼Œç§»é™¤å½“å‰èŠ‚ç‚¹", "\n                     unvisited_nodes.remove(current_node)\n            ", "#å¦‚æœå½“å‰èŠ‚ç‚¹çš„è·ç¦»ä¸ºæ— ç©·å¤§ï¼Œåˆ™å…¶ä½™æœªè®¿é—®çš„èŠ‚ç‚¹ä¸ä¼šè¿æ¥åˆ°å¼€å§‹èŠ‚ç‚¹ï¼Œåœæ­¢", "\n                     ", "if", " distance_from_start[current_node] == INFINITY:\n                       ", "break", "\n \n            ", "#éå†æ¯ä¸ªå½“å‰èŠ‚ç‚¹çš„é‚»å±…ï¼Œæ£€æŸ¥ä¸€ä¸‹ä»èµ·å§‹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹å†åˆ°é‚»å±…èŠ‚ç‚¹çš„è·ç¦»çš„å¤§å°", "\n            ", "#ä¸distance_form_startä¸­çš„æ¯”è¾ƒçœ‹çœ‹æ˜¯å¦æ›´å°ï¼Œæ˜¯è®²ç©¶æ›´æ–°distanceä¸­æ‰€å¯¹åº”çš„å€¼", "\n                     ", "for", " neighbor, distance ", "in", " self.adjacency_list[current_node]:\n                ", "#æ–°çš„è·¯å¾„çš„è·ç¦»", "\n                        new_path = distance_from_start[current_node] + ", "int", "(distance)\n                        ", "if", " new_path < distance_from_start[neighbor]:\n                             distance_from_start[neighbor] = new_path", "#æ›´æ–°å€¼", "\n                             previous_node[neighbor] = current_node", "#æ›´æ–°è·¯å¾„ï¼Œå°†å½“å‰èŠ‚ç‚¹ä½œä¸ºé‚»å±…çš„å‰ç½®èŠ‚ç‚¹", "\n \n        ", "#ä¸ºäº†æ‰¾åˆ°æˆ‘ä»¬æ‰€å»ºç«‹çš„æœ€çŸ­è·¯å¾„ï¼Œä½¿ç”¨è¿­ä»£å™¨éå†æ¯ä¸ªç‚¹çš„å‰ç½®èŠ‚ç‚¹å³å¯æ‰¾åˆ°è·¯å¾„", "\n        ", "#å¹¶ä¸”æŠŠä»–å­˜å…¥ä¸€ä¸ªé˜Ÿåˆ—ä¸­ä¹‹æ‰€ä»¥å¯ä»¥ä¿è¯æ‰¾å¾—åˆ°å‰ç½®èŠ‚ç‚¹ï¼Œæ˜¯å› ä¸ºç®—æ³•å®Œæˆæ—¶å€™æ¯ä¸ªç‚¹çš„å‰ç½®èŠ‚ç‚¹éƒ½ä»£è¡¨ç€", "\n        ", "#åˆ°èµ·å§‹ç‚¹çš„æœ€çŸ­è·¯å¾„", "\n                path = deque()\n                current_node = end_node\n                ", "while", " previous_node[current_node] ", "is", " ", "not", " ", "None", ":\n                       path.appendleft(current_node)\n                       current_node = previous_node[current_node]\n                path.appendleft(start_node)\n                ", "return", " path, distance_from_start[end_node]\n       \n                   \n", "\n", "æ€ä¹ˆå°†ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„æ”¹æˆä»»æ„ä¸¤ç‚¹é—´éå†å®Œæ‰€æœ‰ç‚¹åçš„æœ€ä¼˜è·¯å¾„å‘¢"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;åŸºäºæœ€æ–°ç‰ˆChatGPT4çš„å›ç­”&amp;#xff0c;æœ›é‡‡çº³!!!æœ‰å…¶ä»–é—®é¢˜ä¹Ÿå¯ä»¥è¯¢é—®æˆ‘å“¦ã€â€(æœ€æ–°ç‰ˆæ›´æ™ºèƒ½&amp;#xff0c;åŠŸèƒ½æ›´åŠ å¼ºå¤§)&lt;/p&gt;\n&lt;p&gt;ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜&amp;#xff0c;æˆ‘ä»¬éœ€è¦ä¿®æ”¹Dijkstraç®—æ³•&amp;#xff0c;ä½¿å…¶æœ€å¤§åŒ–æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æœ€å°åŒ–æƒé‡å’Œã€‚æˆ‘ä»¬å°†è¿›è¡Œä»¥ä¸‹æ›´æ”¹&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;åˆå§‹åŒ–æ—¶&amp;#xff0c;å°†æºèŠ‚ç‚¹çš„è·ç¦»è®¾ç½®ä¸º1&amp;#xff0c;è€Œä¸æ˜¯0ã€‚&lt;/li&gt;&lt;li&gt;åœ¨å¯»æ‰¾æœ€å°è·ç¦»çš„èŠ‚ç‚¹æ—¶&amp;#xff0c;å¯»æ‰¾å…·æœ‰æœ€å¤§è·ç¦»çš„èŠ‚ç‚¹ã€‚&lt;/li&gt;&lt;li&gt;åœ¨æ›´æ–°èŠ‚ç‚¹çš„è·ç¦»æ—¶&amp;#xff0c;ä½¿ç”¨æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æƒé‡å’Œã€‚&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;ä»¥ä¸‹æ˜¯ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä¸­çš„ä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;// DSA Programming task 4.2 - Dijsktra&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// You work on this file where TODO is located&lt;/span&gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &lt;span class=\"hljs-string\"&gt;&amp;#34;dijkstra.h&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Initializes graph for Dijkstra&lt;/span&gt;\nvoid init_graph(weightedgraph* g, int vertices){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;nVertices &amp;#61; vertices;\n    int i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; vertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;adj_list[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// TODO! Note the distance&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Dijkstra search from node s&lt;/span&gt;\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;// Initialize graph&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;1; i &amp;lt;&amp;#61; g-&amp;gt;&lt;/span&gt;nVertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// All vertices in queue&lt;/span&gt;\n        queue[i] &amp;#61; i;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// TODO! Modification should start from here&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Note that the propability should be maximized&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Chanage names of variables accordingly&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[s] &amp;#61; &lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;g-&amp;gt;&lt;/span&gt;nVertices; i &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i--) {\n        &lt;span class=\"hljs-comment\"&gt;// Search for maximum from the queue&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;double&lt;/span&gt; maxval &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]];\n        int maxnode &amp;#61; queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        int maxj&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt;&amp;#61; i; j&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;( g-&amp;gt;&lt;/span&gt;dist[queue[j]] &amp;gt; maxval ){\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;maxval&lt;/span&gt; &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[j]];\n                maxnode &amp;#61; queue[j];\n                maxj &amp;#61; j;\n            }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// Switches the maximum to end (out of the queue)&lt;/span&gt;\n        int temp &amp;#61; queue[i];\n        queue[i] &amp;#61; queue[maxj];\n        queue[maxj] &amp;#61; temp;\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pweightededgenode&lt;/span&gt; pedge &amp;#61; g-&amp;gt;&lt;/span&gt;adj_list[maxnode];\n\n        &lt;span class=\"hljs-comment\"&gt;// Relax the neighbors&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(pedge !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; v &amp;#61; pedge-&amp;gt;&lt;/span&gt;nodenum;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;lt; (g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight))  {\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;#61; g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[v] &amp;#61; maxnode;\n            }\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pedge&lt;/span&gt; &amp;#61; pedge-&amp;gt;&lt;/span&gt;next;\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// DEBUG INFO:&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// printf(&amp;#34;%d processed: d[%d] &amp;#61; %f\\n&amp;#34;,maxnode,maxnode,g-&amp;gt;dist[maxnode]);&lt;/span&gt;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//No need to change anyting after this point!&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•&amp;#xff0c;æ‚¨å°†èƒ½å¤Ÿæ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚åœ¨ç»™å®šç¤ºä¾‹ä¸­&amp;#xff0c;è¯¥ç®—æ³•å°†æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³è·¯å¾„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¿®æ”¹è¿‡çš„Dijkstraç®—æ³•è®¡ç®—ç»™å®šå›¾ä¸­ä»èŠ‚ç‚¹1åˆ°èŠ‚ç‚¹8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚è¯·ç¡®ä¿æ‚¨ä½¿ç”¨äº†ä¸Šè¿°æä¾›çš„ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä»£ç ã€‚ä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•&amp;#xff0c;æ‚¨å¯ä»¥é€šè¿‡è¿è¡Œmain.cæ–‡ä»¶æ‰¾åˆ°æ‰€éœ€çš„è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;ç°åœ¨&amp;#xff0c;æˆ‘ä»¬å·²ç»ä¿®æ”¹äº†Dijkstraç®—æ³•ä»¥è§£å†³æ‚¨çš„é—®é¢˜&amp;#xff0c;æ‚¨å¯ä»¥è¿è¡Œmain.cæ–‡ä»¶&amp;#xff0c;ä»¥æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚åœ¨æ‚¨æä¾›çš„ç¤ºä¾‹ä¸­&amp;#xff0c;è¯¥ç®—æ³•å°†æ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;è¯·æ³¨æ„&amp;#xff0c;ä¿®æ”¹åçš„Dijkstraç®—æ³•å¯ä»¥é€‚ç”¨äºæ‚¨çš„é—®é¢˜ã€‚ä½†æ˜¯&amp;#xff0c;åœ¨ç‰¹å®šæƒ…å†µä¸‹&amp;#xff0c;è¿™ç§æ–¹æ³•å¯èƒ½ä¸æ˜¯æœ€æœ‰æ•ˆçš„ã€‚ä¾‹å¦‚&amp;#xff0c;å¯¹äºå…·æœ‰å¤§é‡èŠ‚ç‚¹å’Œè¾¹çš„å¤§å‹ç½‘ç»œ&amp;#xff0c;è¿™ç§æ–¹æ³•å¯èƒ½éœ€è¦æ›´å¤šçš„è®¡ç®—èµ„æºå’Œæ—¶é—´ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹&amp;#xff0c;å¯ä»¥è€ƒè™‘ä½¿ç”¨å…¶ä»–æ›´é«˜æ•ˆçš„ç®—æ³•&amp;#xff0c;å¦‚A*æœç´¢ç®—æ³•æˆ–å…¶ä»–å¯å‘å¼æœç´¢æ–¹æ³•ã€‚&lt;/p&gt;\n&lt;p&gt;å¦‚æœæ‚¨æœ‰å…¶ä»–å…³äºDijkstraç®—æ³•æˆ–å…¶ä»–ç®—æ³•çš„é—®é¢˜&amp;#xff0c;è¯·éšæ—¶æé—®ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["cè¯­è¨€ï¼Œä¿®æ”¹åŸºäºç¬¬ä¸€ä¸ªå›¾çš„æ—§ç®—æ³•ç®—æ³•ä»¥è§£å†³æ–°çš„é—®é¢˜ï¼Œå¹¶å°†æ–°ç®—æ³•ç”¨äºæœ€åä¸€å¼ å›¾", ["æœ‰ä¸€ä¸ªå…³äºDijkstraçš„æ— å‘å›¾ç®—æ³•çš„å®ç°ï¼Œé˜Ÿåˆ—çš„å¤„ç†ç®€å•ï¼Œä½¿ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºğ›©(ğ‘›2),næ˜¯å›¾ä¸­çš„èŠ‚ç‚¹æ•°,å°†è¯¥ç®—æ³•åº”ç”¨äºæ— å‘ç®—æ³•,ä¸‹é¢æ˜¯æœ€åˆä½¿ç”¨çš„åŠ æƒå›¾", "\n", "\n", "ä¿®æ”¹ç®—æ³•ä»¥è§£å†³ä¸‹åˆ—é—®é¢˜ï¼š", "åœ¨ä¸€ä¸ªé“¾è·¯ç½‘ç»œä¸­ï¼Œæœ‰nä¸ªåŸºç«™ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´ä¼ è¾“æ¶ˆæ¯ï¼Œä¸€ä¸ªç½‘ç»œåŒ…å«nä¸ªäº’ç›¸ä¼ è¾“ä¿¡æ¯çš„ç«™ç‚¹t1, t2, â€¦, tn,ç”±äºå¹²æ‰°ï¼Œæ¶ˆæ¯å¯èƒ½åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«æŸåã€‚å¯¹äºæ¯ä¸€å¯¹ç«™ç‚¹ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“æ¶ˆæ¯è¢«æ­£ç¡®ä¼ è¾“çš„æ¦‚ç‡ï¼ˆä¸€ä¸ªåœ¨0åˆ°1ä¹‹é—´çš„å®æ•°ï¼‰ã€‚ æˆ‘ä»¬æ‰“ç®—ä»t1ç«™åˆ°tnç«™ã€‚è®¾è®¡ä¸€ç§ç®—æ³•æ¥æ‰¾åˆ°ç«™ç‚¹çš„è·¯å¾„ï¼Œä»¥æœ€ä½³çš„æ¦‚ç‡ä¼ é€’æ¶ˆæ¯.è¯·æ³¨æ„ï¼Œå½“ä¸€ä¸ªæ¶ˆæ¯é€šè¿‡ä¸€ç³»åˆ—ç«™ç‚¹ä¼ è¾“æ—¶ï¼Œæ²¡æœ‰é”™è¯¯åœ°ä¼ é€’å®ƒçš„æ¦‚ç‡æ˜¯åºåˆ—ä¸­æ¦‚ç‡çš„ä¹˜ç§¯ã€‚", "ä¾‹å­ï¼Œåœ¨ä¸‹å›¾ä¸­ï¼Œæœ‰ä¸‰ä¸ªç«™ç‚¹å’Œç»™å®šçš„æ¦‚ç‡", "é€šè¿‡vä»tå‘uä¼ é€’ä¿¡æ¯æ¯”ç›´æ¥ä¼ é€’ä¿¡æ¯æ›´å¥½ï¼Œå› ä¸ºç›´æ¥ä¼ é€’ä¿¡æ¯æ¦‚ç‡ä¸º0.5ï¼Œè€Œé€šè¿‡vçš„æ¦‚ç‡ä¸º0.7 Ã— 0.8 = 0.56 > 0.50", "\n", "å› æ­¤ï¼Œåº”è¯¥ä¿®æ”¹ç»™å®šçš„ç®—æ³•è€Œä¸æ˜¯è¾¹çš„å’Œã€‚æˆ‘ä»¬è€ƒè™‘ä¹˜ç§¯ï¼Œå¹¶é€‰æ‹©æœ€å¤§å€¼ï¼ˆè€Œä¸æ˜¯åƒåŸå§‹ç®—æ³•ä¸­é‚£æ ·çš„æœ€å°å€¼ï¼‰", "\n", "å°†è¯¥ç®—æ³•åº”ç”¨äºä»¥ä¸‹ç½‘ç»œï¼Œå…¶ä¸­è¾¹çš„æƒå€¼ä¸ºæ¦‚ç‡ã€‚è¯¥æ¶ˆæ¯å°†ä»ç«™1ä¼ é€åˆ°ç«™8ï¼Œä»¥æ­¤å›¾ç”¨ä½œæ–°çš„ç®—æ³•ã€‚", "\n", "dijkstra.ä¸éœ€è¦ä¿®æ”¹", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n", "#", "ifndef", " DIJKSTRA_H_INCLUDED", "\n", "#", "define", " DIJKSTRA_H_INCLUDED", "\n\n", "#", "include", " ", "<limits.h>", "\n", "#", "include", " ", "<float.h>", "\n\n", "// Maximum number of vertices", "\n", "// define according to your needs", "\n", "#", "define", " MAXVERTS 1000", "\n\n", "// Nodes are numbered as integers from 1", "\n\n", "// Maximum value in the distance table", "\n", "#", "define", " INF DBL_MAX", "\n\n", "// Defines edge in the adjacency list", "\n", "typedef", " ", "struct", " ", "weightedgnd", " {\n    ", "int", " nodenum;\n    ", "double", " weight;\n    ", "struct", " ", "weightedgnd", "* next;\n} weightededgenode, *pweightededgenode;\n\n", "// Defines the graph", "\n", "typedef", " ", "struct", " ", "weightedg", " {\n    pweightededgenode adj_list[MAXVERTS+", "1", "];\n    ", "int", " pred[MAXVERTS+", "1", "];\n    ", "double", " dist[MAXVERTS+", "1", "];\n    ", "int", " nVertices;\n} weightedgraph;\n\n", "// Initializes graph for breadth-first search", "\n", "void", " ", "init_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Adds new edge (x,y)", "\n", "void", " ", "add_edge", "(weightedgraph* g, ", "int", " x, ", "int", " y, ", "double", " wght)", ";\n\n", "// Actual breadth-first search from node s", "\n", "void", " ", "dijkstra", "(weightedgraph* g, ", "int", " s)", ";\n\n", "// Frees allocated memory", "\n", "void", " ", "delete_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Print a path after search", "\n", "void", " ", "print_path", "(weightedgraph* g, ", "int", " dest)", ";\n\n", "#", "endif", "\n\n", "\n", "main.cï¼Œä¸éœ€è¦ä¿®æ”¹", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n#", "include", " <stdio.h>\n#", "include", " ", "\"dijkstra.h\"", "\n\n", "int", " main", "()", "{\n    weightedgraph g;\n    init", "_graph(&", "g", ",8)", ";\n\n    add", "_edge(&", "g", ",1,2,1)", ";\n    add", "_edge(&", "g", ",1,4,7)", ";\n    add", "_edge(&", "g", ",1,5,3)", ";\n\n    add", "_edge(&", "g", ",2,3,1)", ";\n    add", "_edge(&", "g", ",3,4,2)", ";\n    add", "_edge(&", "g", ",5,6,3)", ";\n\n    add", "_edge(&", "g", ",6,7,3)", ";\n    add", "_edge(&", "g", ",6,8,3)", ";\n\n    ", "// The other graph", "\n    add", "_edge(&", "g", ",2,4,2)", ";\n    add", "_edge(&", "g", ",4,6,2)", ";\n\n    dijkstra(&g,", "1", ");\n\n    printf(", "\"The path from 1 to 8 with cumulative weights:\\n\"", ");\n    print", "_path(&", "g", ",8)", ";\n\n    delete", "_graph(&", "g", ",8)", ";\n\n    return ", "0", ";\n}\n\n", "\n", "dijkstra.cåªå¯¹æœ‰TODOçš„éƒ¨åˆ†è¿›è¡Œä¿®æ”¹ï¼ˆå³ä¸ºvoid init_graphå‡½æ•°çš„TODOéƒ¨åˆ†å’Œvoid dijkstraçš„TODOéƒ¨åˆ†ï¼‰ï¼Œå…·ä½“ä¿®æ”¹è¦æ±‚è¯¦æƒ…è§ä»£ç éƒ¨åˆ†çš„æ³¨é‡Š", "\n", "// DSA Programming task 4.2 - Dijsktra", "\n", "// You work on this file where TODO is located", "\n#include <stdio.h>\n#include <stdlib.h>\n#include ", "\"dijkstra.h\"", "\n\n", "// Initializes graph for Dijkstra", "\nvoid init_graph(weightedgraph* g, int vertices){\n    ", "g", "->", "nVertices = vertices;\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "g", "->", "adj_list[i] = ", "0", ";\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "// TODO! Note the distance", "\n        ", "g", "->", "dist[i] = INF;\n    }\n}\n\n", "// Adds new edge (x,y)", "\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    ", "if", "( x <= g->", "nVertices", " && y <= g->", "nVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        ", "pxy", "->", "nodenum = y;\n        ", "pxy", "->", "next", " = g->", "adj_list[x];\n        ", "pxy", "->", "weight = wght;\n        ", "g", "->", "adj_list[x] = pxy;\n\n        ", "pyx", "->", "nodenum = x;\n        ", "pyx", "->", "next", " = g->", "adj_list[y];\n        ", "pyx", "->", "weight = wght;\n        ", "g", "->", "adj_list[y] = pyx;\n    }\n}\n\n\n", "/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/", "\n\n", "// Dijkstra search from node s", "\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=", "0", ";\n\n    ", "// Initialize graph", "\n    ", "for", "(i=1; i <= g->", "nVertices; i++) {\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "g", "->", "dist[i] = INF;\n        ", "// All vertices in queue", "\n        queue[i] = i;\n    }\n\n    ", "// TODO! Modification should start from here", "\n    ", "//       Note that the propability should be maximized", "\n    ", "//       Chanage names of variables accordingly", "\n    ", "g", "->", "dist[s] = ", "0", ";\n\n    ", "for", "(i=g->", "nVertices; i >= ", "1", "; i--) {\n        ", "// Search for minimum from the queue", "\n        ", "double", " minval = g->", "dist[queue[", "1", "]];\n        int minnode = queue[", "1", "];\n        int minj=", "1", ";\n        ", "for", "(int j = ", "1", "; j <= i; j++) {\n            ", "if", "( g->", "dist[queue[j]] < minval ){\n                ", "minval", " = g->", "dist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        ", "// Switches the minimum to end (out of the queue)", "\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        ", "pweightededgenode", " pedge = g->", "adj_list[minnode];\n\n        ", "// Relax the neighbors", "\n        ", "while", "(pedge != ", "0", "){\n            ", "int", " v = pedge->", "nodenum;\n            ", "if", "(g->", "dist", "[v] > (g->", "dist", "[minnode]+pedge->", "weight))  {\n                ", "g", "->", "dist", "[v] = g->", "dist", "[minnode]+pedge->", "weight;\n                ", "g", "->", "pred[v] = minnode;\n            }\n            ", "pedge", " = pedge->", "next;\n        }\n\n        ", "// DEBUG INFO:", "\n        ", "// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);", "\n    }\n}\n", "//No need to change anyting after this point!", "\n\n", "// Free allocated memory", "\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "pweightededgenode", " pedge = g->", "adj_list[i];\n        pweightededgenode pnext = ", "0", ";\n\n        ", "while", "(pedge != ", "0", ") {\n            ", "pnext", " = pedge->", "next;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n", "// Print a path after search", "\nvoid print_path(weightedgraph* g, int dest){\n    ", "if", "( g->", "pred[dest] != ", "0", "){\n        ", "print_path", "(g, g->", "pred[dest]);\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n    ", "else", " ", "if", "(g->", "dist[dest]==", "0", "){\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n}\n\n\n\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["åœ¨Goä¸­ä½¿ç”¨Gonumè¿›è¡Œå›¾ç®—æ³•", ["\n\n", "I am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a ", "graph package", "  that looks promising to use. ", "\n\n", "My problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. ", "\n\n", "The way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. ", "\n    "]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å•æºå³ä¸€ä¸ªå‡ºå‘ç‚¹åˆ°å…¶ä»–å„ç‚¹çš„è·ç¦»&lt;br /&gt;å¤šæºå³è®¡ç®—æ‰€æœ‰å‡ºå‘ç‚¹åˆ°å„ç‚¹çš„è·ç¦»&lt;br /&gt;ä¸¤ç§ç®—æ³•æœ¬è´¨ä¸Šéƒ½æ˜¯è®¡ç®—ç‚¹åˆ°ç‚¹çš„æœ€çŸ­è·ç¦»&amp;#xff0c;åªæ˜¯ä¸€ä¸ªä¸€æ¬¡åªèƒ½ç®—ä¸€ä¸ªç‚¹&amp;#xff0c;ä¸€ä¸ªä¸€æ¬¡è®¡ç®—å…¨éƒ¨ç‚¹&amp;#xff0c;å¦‚æœå‰è€…åŠ ä¸Šå¾ªç¯å°±å’Œåè€…åœ¨ç»“æœä¸Šæ²¡æœ‰åŒºåˆ«äº†&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["å›¾çš„æœ€çŸ­è·¯ç®—æ³•ä¸­ï¼Œå•æºæœ€çŸ­è·¯é—®é¢˜å’Œå…¨æºæœ€çŸ­è·¯é—®é¢˜ï¼Œè¿™é‡Œçš„å•æºå’Œå…¨æºæ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ", ["åˆå­¦å›¾çš„æœ€çŸ­è·¯ï¼Œå‘ç°ä¹¦ä¸Šæœ‰æåˆ°dijkstraè§£å†³å•æºæœ€çŸ­è·¯é—®é¢˜ï¼ŒFloydè§£å†³å…¨æºæœ€çŸ­è·¯é—®é¢˜ï¼Œä½†æ˜¯ä¹¦ä¸Šæ²¡æœ‰è§£é‡Šè¿™é‡Œçš„å•æºå’Œå…¨æºæ˜¯ä»€ä¹ˆæ„æ€ï¼ŒæŒ‡çš„æ˜¯ä»€ä¹ˆï¼Ÿ"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;æŒ‰ç…§ä½ è¿™ä¸ªmatlabä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;function [min,path]&amp;#61;dijkstra(w,start,terminal)\n%% å‡½æ•°ä»‹ç»\n%è¾“å…¥å˜é‡wä¸ºæ‰€æ±‚å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µ&amp;#xff0c;startã€terminalåˆ†åˆ«ä¸ºè·¯å¾„çš„èµ·ç‚¹å’Œç»ˆç‚¹çš„ç¼–å·ã€‚\n%è¿”å›pathä¸ºä»startåˆ°termialçš„æœ€çŸ­è·¯å¾„ä»¥åŠé•¿åº¦min\n&lt;span class=\"hljs-attribute\"&gt;n&lt;/span&gt;&amp;#61;size(w,1); label(start)&amp;#61;0; f(start)&amp;#61;start;\n%nä¸ºæ‰€æ±‚å›¾çš„é¡¶ç‚¹ä¸ªæ•°&amp;#xff0c;labelå­˜æ”¾åˆ°å„ç‚¹çš„æœ€çŸ­è·¯å¾„&amp;#xff0c;f(v)è¡¨ç¤ºvçš„çˆ¶é¡¶ç‚¹ç”¨æ¥è¿˜åŸè·¯å¾„\n%åˆå§‹åŒ–å°†é™¤äº†startä»¥å¤–çš„é¡¶ç‚¹labelå‡è®¾ç½®ä¸ºæ— ç©·å¤§\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; i~&amp;#61;start\nlabel(i)&amp;#61;inf;\nend\nend\n%sæ•°ç»„å­˜æ”¾å·²ç»æœå¥½çš„é¡¶ç‚¹é›†&amp;#xff0c;åˆå§‹åŒ–åªæœ‰start\ns(1)&amp;#61;start; &lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;start;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; length(s)&amp;lt;n\n%éå†ä¸€éé¡¶ç‚¹&amp;#xff0c;å°†ä¸åœ¨é¡¶ç‚¹é›†ä¸­çš„é¡¶ç‚¹é€‰å‡ºæ¥è¿›è¡Œä¸‹é¢çš„&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;åˆ¤å®š\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n%åˆ¤æ–­æ˜¯å¦æœ‰ä¸­ç»§é¡¶ç‚¹ä½¿å¾—å®ƒä»¬ä¹‹é—´çš„è·ç¦»æ›´çŸ­&amp;#xff0c;å¦‚æœæœ‰çš„è¯æ›´æ–°è·ç¦»å¹¶æ›´æ–°å‰é©±ç»“ç‚¹\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; label(v)&amp;gt;(label(u)&amp;#43;w(u,v))\nlabel(v)&amp;#61;(label(u)&amp;#43;w(u,v)); f(v)&amp;#61;u;\nend\nend\nend\n&lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;inf;\n%åŒä¸Šå†æ¬¡è¿›è¡Œéå†&amp;#xff0c;æ‰¾åˆ°ç›®å‰æœ€çŸ­çš„è·¯å¾„é¡¶ç‚¹v1&amp;#xff0c;æ”¾å…¥é¡¶ç‚¹é›†å¹¶æ”¹å˜uçš„å€¼\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; k&amp;gt;label(v)\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;label(v); &lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;v;\nend\nend\nend\ns(length(s)&amp;#43;1)&amp;#61;v1;\n&lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;v1;\nend\n\n&lt;span class=\"hljs-attribute\"&gt;min&lt;/span&gt;&amp;#61;label(terminal); path(1)&amp;#61;terminal;\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1;\n\n%æŒ‰å€’åºç»“æœæ¨å‡ºæœ€çŸ­è·¯å¾„\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; path(i)~&amp;#61;start\npath(i&amp;#43;1)&amp;#61;f(path(i));\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;i&amp;#43;1 ;\nend\npath(i)&amp;#61;start;\n&lt;span class=\"hljs-attribute\"&gt;L&lt;/span&gt;&amp;#61;length(path);\n%ç¿»è½¬å¾—åˆ°æœ€çŸ­è·¯å¾„\n&lt;span class=\"hljs-attribute\"&gt;path&lt;/span&gt;&amp;#61;path(L:-1:1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;å¹¶æ ¹æ®ä½ ç»™çš„ç‚¹&amp;#xff0c;æˆ‘å†™äº†ä¸ªå‘½ä»¤çª—å£ä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;clc&lt;/span&gt;,clear\n&lt;span class=\"hljs-attribute\"&gt;w&lt;/span&gt;&amp;#61;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;inf,inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n&lt;span class=\"hljs-attribute\"&gt;start&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-attribute\"&gt;terminal&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;&lt;span class=\"hljs-meta\"&gt;\n[min,path]&amp;#61;dijkstra(w,start,terminal);\nmin,path&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;è¿è¡Œå¾—å‡ºçš„ç»“æœæ˜¯&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/764607253656172.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;å¹¶æ²¡æœ‰äº§ç”ŸæŠ¥é”™ã€‚&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["ä¸€ä¸ªé—®é¢˜ç®—æ³•çš„ç¨‹åºå‡ºç°é”™è¯¯è¿è¡Œä¸å‡ºæ¥", ["function [min,path]=dijkstra(w,start,terminal)", "%è¾“å…¥å˜é‡wä¸ºæ‰€æ±‚å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µï¼Œstartã€terminalåˆ†åˆ«ä¸ºè·¯å¾„çš„èµ·ç‚¹å’Œç»ˆç‚¹çš„ç¼–å·ã€‚", "%è¿”å›pathä¸ºä»startåˆ°termialçš„æœ€çŸ­è·¯å¾„ä»¥åŠé•¿åº¦min", "\n", "n=size(w,1); label(start)=0; f(start)=start;", "%nä¸ºæ‰€æ±‚å›¾çš„é¡¶ç‚¹ä¸ªæ•°ï¼Œlabelå­˜æ”¾åˆ°å„ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œf(v)è¡¨ç¤ºvçš„çˆ¶é¡¶ç‚¹ç”¨æ¥è¿˜åŸè·¯å¾„", "\n", "%åˆå§‹åŒ–å°†é™¤äº†startä»¥å¤–çš„é¡¶ç‚¹labelå‡è®¾ç½®ä¸ºæ— ç©·å¤§", "for i=1:n", "    if i~=start", "       label(i)=inf;", "    end", "end", "\n", "%sæ•°ç»„å­˜æ”¾å·²ç»æœå¥½çš„é¡¶ç‚¹é›†ï¼Œåˆå§‹åŒ–åªæœ‰start", "s(1)=start; u=start;", "while length(s)<n", "    %éå†ä¸€éé¡¶ç‚¹ï¼Œå°†ä¸åœ¨é¡¶ç‚¹é›†ä¸­çš„é¡¶ç‚¹é€‰å‡ºæ¥è¿›è¡Œä¸‹é¢çš„ifåˆ¤å®š", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        %åˆ¤æ–­æ˜¯å¦æœ‰ä¸­ç»§é¡¶ç‚¹ä½¿å¾—å®ƒä»¬ä¹‹é—´çš„è·ç¦»æ›´çŸ­ï¼Œå¦‚æœæœ‰çš„è¯æ›´æ–°è·ç¦»å¹¶æ›´æ–°å‰é©±ç»“ç‚¹", "        if ins==0", "            v=i;", "            if label(v)>(label(u)+w(u,v))", "                label(v)=(label(u)+w(u,v)); f(v)=u;", "            end", "        end", "    end", "    v1=0;", "    k=inf;", "    %åŒä¸Šå†æ¬¡è¿›è¡Œéå†ï¼Œæ‰¾åˆ°ç›®å‰æœ€çŸ­çš„è·¯å¾„é¡¶ç‚¹v1ï¼Œæ”¾å…¥é¡¶ç‚¹é›†å¹¶æ”¹å˜uçš„å€¼", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        if ins==0", "            v=i;", "            if k>label(v)", "                k=label(v);  v1=v;", "            end", "        end", "    end", "    s(length(s)+1)=v1;", "    u=v1;", "end", "\n", "min=label(terminal); path(1)=terminal;", "i=1; ", "\n", "%æŒ‰å€’åºç»“æœæ¨å‡ºæœ€çŸ­è·¯å¾„", "while path(i)~=start", "    path(i+1)=f(path(i));", "    i=i+1 ;", "end", "path(i)=start;", "L=length(path);", "%ç¿»è½¬å¾—åˆ°æœ€çŸ­è·¯å¾„", "path=path(L:-1:1);", "\n", "\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["ROSåœ¨è¿›è¡Œå¯¼èˆªæ—¶ï¼Œå‡ºç°ä¸€ç›´ä¸‹å‘è§’é€Ÿåº¦å’Œçº¿é€Ÿåº¦ä¸º0çš„æƒ…å†µ", ["\n\n", "å¦‚å›¾æ‰€ç¤ºï¼Œåœ¨å­˜åœ¨è·¯å¾„è§„åˆ’çš„æƒ…å†µä¸‹ï¼Œä¸€ç›´ä¸‹å‘çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦ä¸º0 çš„æƒ…å†µã€‚", "\n\n", "\n", "å±€éƒ¨è§„åˆ’é‡‡ç”¨çš„æ˜¯DWAç®—æ³•", "\n", "å…¨å±€è§„åˆ’é‡‡ç”¨çš„æ˜¯Dijkstra.", "\n", "è†¨èƒ€ç³»æ•°è®¾ç½®æ˜¯15å˜ç±³ã€‚\nå°è½¦æ”¾ç½®åœ¨ä¸€ä¸ªç©ºæ—·åŒºåŸŸ", "\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å¹²äº†å‡ å¹´äº†&amp;#xff0c;ä½ è¯´çš„è¿™äº›æˆ‘ä¸€ä¸ªéƒ½ä¸ä¼š&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["å†™é€»è¾‘ä»£ç è¦å¾ˆé•¿çš„æ—¶é—´é€‚åˆèµ°åç«¯å—ï¼Ÿ", ["(åˆšå­¦ä¹ æ–°ç®—æ³•åæ•²ä»£ç )", "å“ˆå¤«æ›¼åŸºæœ¬å®ç°ç¼–ç ç”¨äº†ä¸¤å¤©(è¯‘ç æ²¡å†™)", "æ£‹ç›˜è¦†ç›–ç”¨äº†6ä¸ªå°æ—¶", "dijkstraç”¨äº†6ä¸ªå°æ—¶", "èƒŒåŒ…å›æº¯ç”¨äº†4ä¸ªå°æ—¶", "äºŒå‰æ ‘åŸºæœ¬æ“ä½œåŒ…æ‹¬ç»“ç‚¹æ•°ï¼Œåº¦ä¸º1ç»“ç‚¹æ•°ç­‰å®ç°ç”¨äº†8ä¸ªé’Ÿ(é€’å½’)", "\n", "å°±æ„Ÿè§‰è‡ªå·±æ•²é€»è¾‘ä»£ç å¥½æ…¢ï¼Œé€‚åˆå¹²åç«¯å—ï¼Œç°åœ¨æœ‰ç‚¹æƒ³èµ°å‰ç«¯çš„æƒ³æ³•"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;é¦–å…ˆ&amp;#xff0c;æ‚¨éœ€è¦å®‰è£… NetworkX å’Œ matplotlib åº“æ¥ç»˜åˆ¶å›¾åƒã€‚ç„¶å&amp;#xff0c;å¯ä»¥ä½¿ç”¨ NetworkX åº“ä¸­çš„ draw å‡½æ•°æ¥ç»˜åˆ¶å›¾ã€‚å°†å›¾ç»˜åˆ¶åˆ°ç”»å¸ƒä¸Š&amp;#xff0c;ç„¶åå°†ç”»å¸ƒæ”¾ç½®åœ¨æ‚¨çš„ç”¨æˆ·ç•Œé¢ä¸­çš„ç›¸åº”ä½ç½®å³å¯ã€‚&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­&amp;#xff0c;å…¶ä¸­ä½¿ç”¨ Tkinter åº“åˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„ç”¨æˆ·ç•Œé¢&amp;#xff0c;å¹¶åœ¨å…¶ä¸­ç»˜åˆ¶äº†ä¸€ä¸ªæ— å‘å›¾&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;import tkinter as tk\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n&lt;span class=\"hljs-comment\"&gt;# åˆ›å»ºä¸€ä¸ªçª—å£&lt;/span&gt;\nwindow &amp;#61; tk.Tk()\n\n&lt;span class=\"hljs-comment\"&gt;# åˆ›å»ºä¸€ä¸ªç”»å¸ƒ&lt;/span&gt;\ncanvas &amp;#61; tk.Canvas(window, &lt;span class=\"hljs-attribute\"&gt;width&lt;/span&gt;&amp;#61;600, &lt;span class=\"hljs-attribute\"&gt;height&lt;/span&gt;&amp;#61;600)\ncanvas.pack()\n\n&lt;span class=\"hljs-comment\"&gt;# åˆ›å»ºä¸€ä¸ªæ— å‘å›¾&lt;/span&gt;\nG &amp;#61; nx.Graph()\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;1)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;7)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;3)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;5)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;9)\n\n&lt;span class=\"hljs-comment\"&gt;# ç»˜åˆ¶å›¾åƒ&lt;/span&gt;\npos &amp;#61; nx.spring_layout(G)  # ä½¿ç”¨ FR ç®—æ³•æ’åˆ—èŠ‚ç‚¹\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\nlabels &amp;#61; nx.get_edge_attributes(G, &lt;span class=\"hljs-string\"&gt;&amp;#39;weight&amp;#39;&lt;/span&gt;)\nnx.draw_networkx_edge_labels(G, pos, &lt;span class=\"hljs-attribute\"&gt;edge_labels&lt;/span&gt;&amp;#61;labels, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\n\n&lt;span class=\"hljs-comment\"&gt;# æ˜¾ç¤ºçª—å£&lt;/span&gt;\nwindow.mainloop()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ä¸Šè¿°ä»£ç ä½¿ç”¨äº† NetworkX åº“ä¸­çš„ spring_layout å‡½æ•°æ¥æ’åˆ¶èŠ‚ç‚¹çš„ä½ç½®&amp;#xff0c;ç„¶åä½¿ç”¨ draw å‡½æ•°ç»˜åˆ¶å›¾åƒã€‚è¿˜ä½¿ç”¨äº† get_edge_attributes å‡½æ•°å’Œ draw_networkx_edge_labels å‡½æ•°æ¥ç»˜åˆ¶è¾¹çš„æ ‡ç­¾ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["å¦‚ä½•è®©æ— å‘å›¾æ˜¾ç¤ºåˆ°ç”¨æˆ·ç•Œé¢é‡Œ", ["\ndef main():\n            \n        \n       \n\n", "# é—®é¢˜ 2ï¼šæ— å‘å›¾çš„æœ€çŸ­è·¯é—®é¢˜ï¼ˆå¸å®ˆå¥ï¼Œæ•°å­¦å»ºæ¨¡ç®—æ³•ä¸åº”ç”¨ï¼ŒP43ï¼Œä¾‹4.3ï¼‰", "\n             G2 = nx.Graph()  # åˆ›å»ºï¼šç©ºçš„ æœ‰å‘å›¾\n\n             G2.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)  # æ·»åŠ  å¸¦æƒè¾¹ï¼Œweightè¡¨ç¤ºè¾¹æƒ\n             G2.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n             G2.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n             G2.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n             G2.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n             G2.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n             G2.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# ä¸¤ä¸ªæŒ‡å®šé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­åŠ æƒè·¯å¾„", "\n             ", "source", "=nameEntry3.get()\n             ", "target", "=nameEntry4.get()\n             minWPath_v1_v5 = nx.dijkstra_path(G2, source, target)  # é¡¶ç‚¹ 0 åˆ° é¡¶ç‚¹ 3 çš„æœ€çŸ­åŠ æƒè·¯å¾„\n             return minWPath_v1_v5\n             # ä¸¤ä¸ªæŒ‡å®šé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­åŠ æƒè·¯å¾„çš„é•¿åº¦\n             lMinWPath_v1_v5 = nx.dijkstra_path_length(G2, source, target)  # æœ€çŸ­åŠ æƒè·¯å¾„é•¿åº¦\n             return lMinWPath_v1_v5\n             plt.clf()\n             pos = nx.spring_layout(G2)  # ç”¨ FRç®—æ³•æ’åˆ—èŠ‚ç‚¹\n             nx.draw(G2, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5)\n             labels = nx.get_edge_attributes(G2, ", "'weight'", ")\n             nx.draw_networkx_edge_labels(G2, pos, ", "edge_labels", "=labels)\n              # plt.show()\n\n\n             edgeList = []\n             ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n             nx.draw_networkx_edges(G2, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4) \n             # è®¾ç½®è¾¹çš„é¢œè‰²\n             \n             plt.savefig(", "'path'", " +", "'.jpg'", ")\n             filename = ", "\".\\path.jpg\"", "\n             image = Image.open(filename)\n             photo = ImageTk.PhotoImage(image)\n             canvas.create_image(450,250,image = photo)\n             canvas.update()\n             time.sleep(sleep_time)\n      \n      frame_mid = Frame(", "width", "=800,height=100,bg='white') \n      frame_mid.grid(", "row", "=8,column=10,rowspan=6,columnspan=2,padx=4, ", "pady", "=5)\n      \n      canvas = Canvas(frame_mid,width = 800,height = 600,bg = ", "'#FFCCCC'", ")#ç”»æ¿\n      \n      canvas.grid()\n\n\n\n                \n\n            \n      def main2():\n            \n               \n               EditText.insert(tkinter.END,main())\n             \n      ", "EditText", "=tkinter.Text(window2,width=15,height=5)\n      EditText.grid(", "row", "=8,column=8)\n      def main3():\n          main()\n      \n        \n     \n      ", "q", "=tkinter.Button(window2,text=\"ç¡®å®š\", font=(", "'å®‹ä½“'", ",15),", "command", "=main2)\n      q.grid(", "row", "=7,column=6)\n      ", "q", "=tkinter.Button(window2,text=\"ç¡®å®š\", font=(", "'å®‹ä½“'", ",15),", "command", "=main3)\n      q.grid(", "row", "=7,column=8\n", "\n", "ä¸ºä»€ä¹ˆæˆ‘ç”¨networkxå’Œcanvasç”»çš„å›¾æ˜¾ç¤ºä¸åˆ°tkinteré‡Œ", "è¯¥å¦‚ä½•è®©å®ƒæ˜¾ç¤ºå‘¢"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;ä½ å¯ä»¥å°†ç”»å¸ƒä½œä¸ºç»˜å›¾å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°&amp;#xff0c;å¦‚&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;nx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;canvas&lt;/span&gt;&amp;#61;canvas)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;æˆ–è€…&amp;#xff0c;å¯ä»¥ä½¿ç”¨ FigureCanvasTkAgg å°†ç”»å¸ƒç»‘å®šåˆ° tkinter çª—å£ä¸­&amp;#xff0c;ä¾‹å¦‚&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfig &amp;#61; plt.figure(figsize&amp;#61;(5, 5))\ncanvas &amp;#61; FigureCanvasTkAgg(fig, &lt;span class=\"hljs-attribute\"&gt;master&lt;/span&gt;&amp;#61;window2)\ncanvas.get_tk_widget().grid(&lt;span class=\"hljs-attribute\"&gt;row&lt;/span&gt;&amp;#61;8, &lt;span class=\"hljs-attribute\"&gt;column&lt;/span&gt;&amp;#61;10)\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;fig&lt;/span&gt;&amp;#61;fig)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;åœ¨è¿™ç§æƒ…å†µä¸‹&amp;#xff0c;åº”è¯¥ä½¿ç”¨ fig è€Œä¸æ˜¯ canvas ä½œä¸ºç»˜å›¾å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚&lt;/p&gt;\n&lt;p&gt;è¯·æ³¨æ„&amp;#xff0c;å¦‚æœä½¿ç”¨ FigureCanvasTkAgg&amp;#xff0c;åˆ™éœ€è¦å¯¼å…¥ matplotlib.pyplot æ¨¡å—&amp;#xff0c;å¹¶ä½¿ç”¨ plt.figure åˆ›å»ºä¸€ä¸ªæ–°å›¾è¡¨ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ€ä¹ˆè®©æˆ‘ç”»çš„æ— å‘å›¾æ˜¾ç¤ºåœ¨canvasç”»å¸ƒä¸Š", ["\ndef main3():\n          canvas = tkinter.Canvas(window2, ", "width", "=50, ", "height", "=50)\n          canvas.grid(", "row", "=8,column=10)\n\n", "# åˆ›å»ºä¸€ä¸ªæ— å‘å›¾", "\n          G = nx.Graph()\n          G.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)\n          G.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n          G.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n          G.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n          G.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n          G.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n          G.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# ç»˜åˆ¶å›¾åƒ", "\n          ", "source", "=nameEntry3.get()\n          ", "target", "=nameEntry4.get()\n \n          minWPath_v1_v5 = nx.dijkstra_path(G, source, target)  # é¡¶ç‚¹ 0 åˆ° é¡¶ç‚¹ 3 çš„æœ€çŸ­åŠ æƒè·¯å¾„\n                \n", "# ä¸¤ä¸ªæŒ‡å®šé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­åŠ æƒè·¯å¾„çš„é•¿åº¦", "\n          \n          pos = nx.spring_layout(G)  # ä½¿ç”¨ FR ç®—æ³•æ’åˆ—èŠ‚ç‚¹\n          nx.draw(G, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5,on=canvas)\n          labels = nx.get_edge_attributes(G, ", "'weight'", ")\n          nx.draw_networkx_edge_labels(G, pos, ", "edge_labels", "=labels)\n          edgeList = []\n          ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                  edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n                  nx.draw_networkx_edges(G, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4,on=canvas)\n\n            \n          \n      \n", "\n", "æ€ä¹ˆè®©æˆ‘ç”»çš„æ— å‘å›¾æ˜¾ç¤ºåœ¨canvasç”»å¸ƒä¸Š"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;è¿™æ˜¯ä¸€ä¸ªå®ç°è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•çš„ä»£ç &amp;#xff0c;ç”¨äºæ±‚è§£å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚è¯¥ç®—æ³•æ˜¯ä¸€ç§è´ªå¿ƒç®—æ³•&amp;#xff0c;æ¯æ¬¡æ±‚è§£çš„æ—¶å€™éƒ½ä¼šæ‰¾åˆ°å½“å‰èƒ½åˆ°è¾¾çš„ç‚¹ä¸­è·ç¦»èµ·ç‚¹æœ€è¿‘çš„ç‚¹&amp;#xff0c;å¹¶ä»è¯¥ç‚¹å¼€å§‹æœç´¢ä¸‹ä¸€æ­¥èƒ½åˆ°è¾¾çš„ç‚¹&amp;#xff0c;ç›´åˆ°åˆ°è¾¾ç»ˆç‚¹ã€‚&lt;/p&gt;\n&lt;p&gt;å…·ä½“æ¥è¯´&amp;#xff0c;ä»£ç ä¸­ä½¿ç”¨äº†ä¸‰ä¸ªæ ˆ&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1ã€stack æ ˆç”¨æ¥å­˜å‚¨æœç´¢è·¯å¾„ä¸­çš„ç‚¹ã€‚&lt;br /&gt;2ã€stackdata æ ˆç”¨æ¥å­˜å‚¨æ¯æ¡è¾¹çš„è·ç¦»ã€‚&lt;br /&gt;3ã€stackfindlj æ ˆç”¨æ¥å­˜å‚¨æ‰€æœ‰å¯èƒ½çš„è·¯å¾„&amp;#xff0c;å…¶ä¸­çš„æ¯ä¸€è¡Œéƒ½æ˜¯ä¸€æ¡è·¯å¾„&amp;#xff0c;ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºèµ·ç‚¹&amp;#xff0c;å…¶ä½™çš„å…ƒç´ ä¸ºè·¯å¾„ä¸­çš„æ¯ä¸ªç‚¹ã€‚&lt;br /&gt;é¦–å…ˆ&amp;#xff0c;ä»èµ·ç‚¹å¼€å§‹æœç´¢&amp;#xff0c;å¦‚æœæ‰¾åˆ°äº†ä¸€æ¡è¾¹ä¸”è¿™æ¡è¾¹è¿˜æ²¡æœ‰è®¿é—®è¿‡&amp;#xff0c;å°±å°†è¿™æ¡è¾¹åŠ å…¥è·¯å¾„ä¸­&amp;#xff0c;å¹¶å°†è¿™æ¡è¾¹çš„è·ç¦»åŠ å…¥è·¯å¾„è·ç¦»ä¸­ã€‚ç„¶åä»è¿™æ¡è¾¹çš„ç»ˆç‚¹å¼€å§‹ç»§ç»­æœç´¢&amp;#xff0c;å¦‚æœèƒ½æ‰¾åˆ°ä¸€æ¡è¾¹ä¸”è¿™æ¡è¾¹è¿˜æ²¡æœ‰è®¿é—®è¿‡&amp;#xff0c;å°±å°†è¿™æ¡è¾¹åŠ å…¥è·¯å¾„ä¸­&amp;#xff0c;å¹¶å°†è¿™æ¡è¾¹çš„è·ç¦»åŠ å…¥è·¯å¾„è·ç¦»ä¸­ã€‚é‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°åˆ°è¾¾ç»ˆç‚¹&amp;#xff0c;æˆ–è€…æ‰¾ä¸åˆ°æ–°çš„è¾¹å¯ä»¥åŠ å…¥è·¯å¾„ä¸­ã€‚&lt;/p&gt;\n&lt;p&gt;æ‰€æœ‰çš„è·¯å¾„è¢«ä¿å­˜åœ¨ stackfindlj ä¸­&amp;#xff0c;å…¶ä¸­çš„æ¯ä¸€è¡Œéƒ½æ˜¯ä¸€æ¡è·¯å¾„ã€‚æ¥ä¸‹æ¥&amp;#xff0c;éå†æ‰€æœ‰çš„è·¯å¾„&amp;#xff0c;æ‰¾åˆ°è·¯å¾„è·ç¦»æœ€å°çš„è·¯å¾„ã€‚å°†è¿™æ¡æœ€çŸ­è·¯å¾„çš„ä¿¡æ¯å¤åˆ¶åˆ°ä¸€ä¸ªåä¸º temp çš„ç»“æ„ä½“ä¸­&amp;#xff0c;å¹¶è¿”å›è¿™ä¸ªç»“æ„ä½“ã€‚&lt;/p&gt;\n&lt;p&gt;è¿™ä¸ªç»“æ„ä½“ä¸­åŒ…å«ä¸¤ä¸ªä¿¡æ¯&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1ã€stack æ•°ç»„ç”¨æ¥å­˜å‚¨æœ€çŸ­è·¯å¾„ä¸­çš„ç‚¹ã€‚&lt;br /&gt;2ã€jl å˜é‡ç”¨æ¥å­˜å‚¨æœ€çŸ­è·¯å¾„çš„è·ç¦»ã€‚&lt;/p&gt;\n&lt;p&gt;å¦‚æœæƒ³è¾“å‡ºæœ€çŸ­è·¯å¾„çš„é€”å¾„ç‚¹ä¿¡æ¯&amp;#xff0c;å¯ä»¥åœ¨è¾“å‡ºè·¯å¾„è·ç¦»ä¹‹åæ·»åŠ ä»¥ä¸‹ä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;æœ€çŸ­è·¯å¾„ä¸º&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp.stack[i] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, temp.stack[i]);\n  }\n}\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;è¿™æ®µä»£ç ä¼šä¾æ¬¡è¾“å‡ºæœ€çŸ­è·¯å¾„ä¸­çš„æ‰€æœ‰ç‚¹ã€‚&lt;br /&gt;ä»…ä¾›å‚è€ƒ&amp;#xff0c;æœ›é‡‡çº³&amp;#xff0c;è°¢è°¢ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ„é€ äº†ä¸€ä¸ªè¿ªæ°æ–¯ç‰¹æ‹‰å‡½æ•°ï¼Œä½†æ˜¯ä¸ä¼šå¾—å‡ºæœ€çŸ­è·¯å¾„çš„é€”å¾„ç‚¹ä¿¡æ¯ï¼Œéœ€è¦æ›´è¯¦ç»†çš„æ³¨é‡Š", ["é—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯ æ„é€ äº†ä¸€ä¸ªè®¡ç®—å‡½æ•°ï¼Œå¦‚ä½•å¾—åˆ°æœ€çŸ­è·¯å¾„çš„ç‚¹çš„ä¿¡æ¯ä»¥åŠéœ€è¦æ›´è¯¦ç»†çš„æ³¨é‡Š", "\n", "é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯ï¼Œè¯·å†™å‡ºç¬¬ä¸€ä¸ªé”™è¯¯ä¿¡æ¯", "\n", "ç”¨ä»£ç å—åŠŸèƒ½æ’å…¥ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾ã€‚ ä¸ç”¨ä»£ç å—å›ç­”ç‡ä¸‹é™ 50%", "\n", "struct ", "MyStack", "  \n{\n    int stack[", "50", "];//æ ˆ\n    int jl;//è·ç¦»\n};\n//è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•\n", "MyStack", " ", "Dijkstra", "(map ", "Map", ", int d, int e)//dè®¾ä¸ºèµ·ç‚¹,eè®¾ä¸ºç»ˆç‚¹\n{\n    int stack[", "50", "] = { ", "0", " }, id1 = ", "0", ";\n    int stackdata[", "50", "] = { ", "0", " }, id2 = ", "0", ";\n    int stackfindlj[", "50", "][", "50", "] = { ", "0", " }, id3 = ", "0", ";//è·¯å¾„ä¿å­˜\n    int stackfindjl[", "50", "] = { ", "0", " };//è·ç¦»ä¿å­˜\n    int isfind = ", "0", ";\n    for (int i = d; i < d + ", "1", "; i++)\n    {\n        for (int j = i; j < ", "12", "; j++)\n        {\n            int edge[", "12", "][", "12", "] = { ", "0", " };//è¾…åŠ©åœ°å›¾\n            if (", "Map", ".edge[i][j] != ", "100", " && ", "Map", ".edge[i][j] != ", "0", " && edge[i][j] == ", "0", ")\n            {\n                stack[id1++] = j;\n                stackdata[id2++] = ", "Map", ".edge[i][j];//è¾¹çš„è·ç¦»\n                edge[i][j] = ", "1", ";//è¾…åŠ©åœ°å›¾\n                while (id1)\n                {\n                    for (int k = stack[id1 - ", "1", "]; k < ", "12", "; k++)\n                    {\n                        if (", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "100", " && ", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "0", " && edge[stack[id1 - ", "1", "]][k] == ", "0", ")//å¼€å§‹æœå¯»è·¯å¾„\n                        {\n                            edge[stack[id1 - ", "1", "]][k] = ", "1", ";\n                            stackdata[id2++] = ", "Map", ".edge[stack[id1 - ", "1", "]][k];\n                            stack[id1++] = k;\n                            if (k == e)//åˆ°è¾¾äº†ç»ˆç‚¹\n                                isfind = ", "1", ";\n                            break;\n                        }\n                        if (k == ", "11", ")\n                        {\n                            id1--; id2--;\n                        }\n                    }\n                    if (isfind == ", "1", ")\n                    {\n                        stackfindlj[id3][", "0", "] = i + ", "1", ";\n                        for (int k = ", "0", "; k < id1; k++)\n                        {\n                            stackfindlj[id3][k + ", "1", "] = stack[k] + ", "1", ";\n                            stackfindjl[id3] += stackdata[k];\n                        }\n                        id3++;\n                        isfind = ", "0", ";\n                    }\n                }\n            }\n        }\n    }\n    int min = stackfindjl[", "0", "], minidx = ", "0", ";\n    for (int i = ", "0", "; i < id3; i++)\n    {\n        if (min > stackfindjl[i])\n        {\n            min = stackfindjl[i];\n            minidx = i;\n        }\n    }\n    ", "MyStack", " temp = { ", "0", " };\n    memcpy(&temp.stack, &stackfindlj[minidx], sizeof(int) * ", "50", ");//å°†å¾—åˆ°çš„æœ€çŸ­è·¯å¾„å¤åˆ¶åˆ°ç»“æ„ä½“çš„æ•°ç»„ä¹‹ä¸­\n    temp.jl = min;//å°†å¾—åˆ°çš„æœ€çŸ­è·ç¦»èµ‹å€¼åˆ°ç»“æ„ä½“çš„è·ç¦»ä¸­\n    printf(", "\"æœ€çŸ­è·¯å¾„è·ç¦»ä¸ºï¼š%d\\n\"", ", temp.jl);\n    return temp;\n\n", "\n", "è¿è¡Œç»“æœåŠè¯¦ç»†æŠ¥é”™å†…å®¹", "\n", "åªä¼šè¾“å‡ºæœ€çŸ­è·ç¦»", "\n", "æˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•ï¼Œä¸å†™è‡ªå·±æ€è·¯çš„ï¼Œå›ç­”ç‡ä¸‹é™ 60%", "\n", "è¿ªæ°æ–¯ç‰¹æ‹‰å‡½æ•°", "\n", "æˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœï¼Œå¦‚æœä½ éœ€è¦å¿«é€Ÿå›ç­”ï¼Œè¯·å°è¯• â€œä»˜è´¹æ‚¬èµâ€"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;åº”è¯¥æ˜¯æ²¡æœ‰visitedæ•°ç»„æ ‡è®°çš„é—®é¢˜&amp;#xff0c;å­˜è¾¹æ˜¯å­˜åŒå‘è¾¹&amp;#xff0c;éœ€è¦æ ‡è®°visited&amp;#xff08;æœ‰æ—¶ä¹Ÿå«used&amp;#xff09;æ•°ç»„è¿›è¡Œæ ‡è®°è¿™ä¸ªç‚¹å·²ç»åˆ°è¾¾è¿‡äº†&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ´›è°·P1462 dijçš„é—®é¢˜", ["https://www.luogu.com.cn/problem/P1462", "\n", "https://www.luogu.com.cn/record/78581018", "\n", "åªå¯¹äº†3ä¸ªç‚¹ï¼Œéƒ½æ˜¯æ— è§£ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´dijå¯èƒ½ä¸å¯¹", "\n", "#", "include", "<bits/stdc++.h>", "\n", "#", "define", " INF 0x3f3f3f3f", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", " MAXN=", "10008", ";\n", "typedef", " pair<", "int", ",", "int", "> pi;\npriority_queue< pi,vector<pi>,greater<pi> > q;\n", "int", " n,m,b;\n", "int", " f[MAXN],dis[MAXN];\n", "struct", " ", "node", "{\n    ", "int", " v,w;\n};\nvector<node> a[MAXN];\n", "bool", " vis[MAXN];\n", "int", " l=INT_MAX,r=INT_MIN,mid;\n", "bool", " ", "dijkstra", "(", "int", " st)", "{\n    ", "memset", "(vis,", "0", ",", "sizeof", "(vis));\n    ", "memset", "(dis,INF,", "sizeof", "(dis));\n    dis[", "1", "]=st;\n    q.", "push", "({", "make_pair", "(dis[", "1", "],", "1", ")});\n    ", "while", "(!q.", "empty", "()){\n        ", "int", " x=q.", "top", "().second;\n        q.", "pop", "();\n        ", "if", "(vis[x]) ", "continue", ";\n        vis[x]=", "true", ";\n        ", "for", "(", "int", " i=", "0", ";i<a[x].", "size", "();i++){\n            ", "int", " y=a[x][i].v,z=a[x][i].w;\n            dis[y]=", "min", "(dis[y],dis[x]+z);\n            q.", "push", "(", "make_pair", "(dis[y],y));\n        }\n    }\n    ", "return", " dis[n]<b;\n}\n", "int", " ", "main", "()", "{\n    ", "scanf", "(", "\"%d%d%d\"", ",&n,&m,&b);\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "scanf", "(", "\"%d\"", ",&f[i]);\n        l=", "min", "(l,f[i]);\n        r=", "max", "(r,f[i]);\n    }\n    ", "int", " maxi=r;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "int", " u,v,w;\n        ", "scanf", "(", "\"%d%d%d\"", ",&u,&v,&w);\n        a[u].", "push_back", "({v,w});\n        a[v].", "push_back", "({u,w});\n    }\n    ", "while", "(l<=r){\n        mid=(l+r)/", "2", ";\n        ", "if", "(", "dijkstra", "(mid)) r=mid", "-1", ";\n        ", "else", " l=mid+", "1", ";\n    }\n    ", "if", "(l==maxi+", "1", ") \n        ", "printf", "(", "\"AFK\\n\"", ");\n    ", "else", "\n        ", "printf", "(", "\"%d\\n\"", ",l);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "æ±‚ç»™å‡ºä»¥å¦‚ä¸Šä»£ç æ”¹å¯¹äº†çš„ä»£ç æˆ–ä¿®æ”¹æ–¹å¼ï¼Œè°¢è°¢"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;æˆ‘è¯•ç€ç…§ç€ä½ çš„dequeè¾“å‡ºçš„ä»£ç å†™äº†ä¸€ä¸ªæµ‹è¯•&amp;#xff0c;å¯ä»¥æ­£å¸¸è¾“å‡º&amp;#xff0c;æ‰€ä»¥é—®é¢˜åº”è¯¥ä¸åœ¨è¿™é‡Œ&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["é—®é¢˜ï¼šä¸ºä»€ä¹ˆç”¨dequeåå‘è¾“å‡ºä¼šæŠ¥é”™è€Œç”¨é€’å½’åå‘è¾“å‡ºæ²¡é—®é¢˜", ["http://poj.org/problem?id=2457", "ï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1", "\n", "ï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "1", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "1", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<", "int", "> stars;\n", "void", " ", "print_stars", "()", "\n", "{\n \n    \n    stars.", "push_front", "(n);\n    k=n;\n    ", "while", "(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.", "push_front", "(k);\n    }\n    stars.", "push_front", "(s);\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    cin>>m>>n;\n", "//    if(n==1)", "\n", "//    {", "\n", "//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';", "\n", "//    }", "\n", "//    else{", "\n    \n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);", "\n        }\n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]<<", "'\\n'", ";\n            ", "print_stars", "();\n            ", "while", "(stars.", "size", "())\n            {\n                cout<<stars.", "front", "()<<", "'\\n'", ";\n                stars.", "pop_front", "();\n            }\n", "//        }", "\n    }\n    ", "return", " ", "0", ";\n}\n \n\n", "\n", "ï¼ˆä»¥ä¸‹æ—¶å°†dequeè¯¥æ¢æˆé€’å½’ä¹‹åå¯ä»¥é€šè¿‡çš„ä»£ç ï¼‰", "\n", " \n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "0", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "0", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\n", "//deque<int> stars;", "\n", "//void print_stars()", "\n", "//{", "\n", "//", "\n", "//    ", "\n", "//    stars.push_front(n);", "\n", "//    k=n;", "\n", "//    while(vis0[k]!=s)", "\n", "//    {", "\n", "//        k=vis0[k]; ", "\n", "//        stars.push_front(k);", "\n", "//    }", "\n", "//    stars.push_front(s);", "\n", "//}", "\n", "void", " ", "printf_path", "(", "int", " vertax)", "\n", "{\n    ", "if", "(vis0[vertax] != ", "-1", " ) ", "printf_path", "(vis0[vertax]);\n    cout<<vertax<<", "'\\n'", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    ", "memset", "(vis0,", "-1", ",", "sizeof", " vis0);\n    cin>>m>>n;\n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);    ", "\n        }\n    ", "if", "(n==", "1", ")\n    {\n        cout<<", "\"1\"", "<<", "'\\n'", "<<", "\"1\"", "<<", "'\\n'", ";\n    }\n    ", "else", "{\n    \n    \n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]+", "1", "<<", "'\\n'", ";\n            ", "printf_path", "(n);\n", "//            while(stars.size())", "\n", "//            {", "\n", "//                cout<<stars.front()<<'\\n';", "\n", "//                stars.pop_front();", "\n", "//            }", "\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å¯ä»¥å‚è€ƒä¸€ä¸‹&lt;a href=\"https://blog.csdn.net/weixin_41598179/article/details/112795877\" id=\"textarea_1652959433332_1652959657006_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Cè¯­è¨€â€”â€”æœ€çŸ­è·¯å¾„é—®é¢˜&amp;#xff08;Dijkstraç®—æ³•&amp;#xff09;_ç§‹ç±³å§å§çš„åšå®¢-CSDNåšå®¢_cè¯­è¨€æ±‚æœ€çŸ­è·¯å¾„&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Cè¯­è¨€â€”â€”æœ€çŸ­è·¯å¾„é—®é¢˜&amp;#xff08;Dijkstraç®—æ³•&amp;#xff09;ä¼˜ç‚¹â€”â€”é€‚ç”¨èŒƒå›´å¹¿&amp;#xff0c;æœ¬ä»£ç å±äºå…¬å¼å‹ä»£ç &amp;#xff0c;å¯éšæ„æ›´æ¢æ•°æ®&amp;#xff0c;é€‚åˆé›¶åŸºç¡€åŒå­¦ã€‚ä¸»è¦æ€è·¯&amp;#xff1a;ä¸»è¦æ€è·¯&amp;#xff1a;1.ç”¨ä¸€ä¸ªäºŒç»´æ•°ç»„å­˜æ”¾å¸¦æƒæœ‰å‘å›¾çš„é‚»æ¥çŸ©é˜µ&amp;#xff1b;2.åŸºäºDijkstraç®—æ³•åˆ†åˆ«ç”³è¯·ä¸‰ä¸ªæ•°ç»„&amp;#xff0c;distance[], path[], used[]åˆ†åˆ«è®°å½•ä»èµ·ç‚¹åˆ°å…¶ä½™å„ç‚¹çš„æœ€çŸ­è·ç¦»&amp;#xff0c;åˆ°ç›®æ ‡ç»“ç‚¹è·¯å¾„ä¸Šçš„å‰ä¸€ä¸ªç»“ç‚¹&amp;#xff0c;åˆ°å›¾ä¸­æŸä¸ªç»“ç‚¹æ˜¯å¦å·²æ‰¾åˆ°æœ€çŸ­è·¯å¾„&amp;#xff1b;3.é€æ¸ç¡®å®šä»æºç‚¹åˆ°å›¾ä¸­å„ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„&amp;#xff0c;ç›´è‡³ç»“æŸ&amp;#xff1b;æœ€çŸ­è·¯å¾„ä¾‹é¢˜&amp;#xff1a;å¦‚ä¸‹å›¾æ‰€ç¤º&amp;#xff0c;æ±‚æœ€çŸ­ç»ã€‚&amp;lt;fnä»£ç &amp;#xff1a;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/weixin_41598179/article/details/112795877&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["ã€cè¯­è¨€ã€‘ã€æ•°æ®ç»“æ„ã€‘Dijkstraç®—æ³•æ±‚æœ€å¿«é€é¤è·¯å¾„", ["è¾“å…¥ï¼šç¬¬ä¸€è¡ŒåŒ…å«3ä¸ªæ•´æ•°n,m,tï¼Œåˆ†åˆ«è¡¨ç¤ºè·¯å£çš„ä¸ªæ•°ï¼Œé“è·¯çš„æ¡æ•°å’Œç›®çš„è·¯å£ã€‚", "ï¼ˆ2 â‰¤ n â‰¤ 10ï¼Œ1 â‰¤ m â‰¤ 50ï¼Œ1 â‰¤ w â‰¤ 10ï¼‰", "æ¥ä¸‹æ¥mè¡Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° u,v,wï¼Œè¡¨ç¤ºè·¯å£uåˆ°è·¯å£vå­˜åœ¨ä¸€æ¡è€—æ—¶wçš„å•è¡Œé“ã€‚", "è¾“å‡ºï¼šéª‘æ‰‹ä»å•†å®¶ï¼ˆä½äº1å·è·¯å£ï¼‰åˆ°ç›®çš„è·¯å£çš„æœ€çŸ­æ—¶é—´ï¼Œè‹¥è·¯å¾„ä¸å­˜åœ¨ï¼Œè¾“å‡º-1ã€‚"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;ç”¨Dijkstraç®—æ³•æ±‚ä»é¡¶ç‚¹0å‡ºå‘çš„æœ€çŸ­è·¯å¾„ã€‚ç®€å•æ¥è¯´&amp;#xff0c;å°±æ˜¯ä»èµ·ç‚¹å¼€å§‹&amp;#xff0c;ä¸æ–­åœ°é€‰å–æœªè®¿é—®çš„è·ç¦»èµ·ç‚¹æœ€è¿‘çš„é¡¶ç‚¹&amp;#xff0c;å¹¶æ›´æ–°è¯¥é¡¶ç‚¹åˆ°å…¶ä»–é¡¶ç‚¹çš„è·ç¦»ã€‚è¿™æ ·ä¸æ–­æ‰§è¡Œç›´åˆ°æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®è¿‡&amp;#xff0c;å¾—åˆ°èµ·ç‚¹åˆ°å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;æ¥ç€&amp;#xff0c;ç»™å‡ºäº†ç®—æ³•æ‰§è¡Œçš„æŸæ—¶åˆ»&amp;#xff0c;å³å·²ç»è®¿é—®äº†0ã€2ã€3ã€4å››ä¸ªé¡¶ç‚¹ã€‚è¿™æ„å‘³ç€æ­¤æ—¶å·²ç»æ‰¾åˆ°äº†ä»èµ·ç‚¹åˆ°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;æœ€å&amp;#xff0c;éœ€è¦åœ¨è¿™ä¸ªæ—¶åˆ»é€‰å–ä¸‹ä¸€æ­¥ç›®æ ‡é¡¶ç‚¹ã€‚å› ä¸ºé¢˜ç›®æ²¡æœ‰ç»™å‡ºå®Œæ•´çš„å›¾&amp;#xff0c;æ‰€ä»¥æˆ‘ä¹Ÿä¸çŸ¥é“é¡¶ç‚¹Dä¸0ã€2ã€3ã€4ä¹‹é—´çš„è¿è¾¹æƒ…å†µã€‚å› æ­¤æ— æ³•ç¡®å®šé¡¶ç‚¹Dæ˜¯å¦ä¸ºä¸‹ä¸€æ­¥çš„ç›®æ ‡é¡¶ç‚¹ã€‚&lt;/p&gt;\n&lt;p&gt;å› æ­¤&amp;#xff0c;é€‰é¡¹Aã€Bã€Cã€Dä¸­åªæœ‰é€‰é¡¹Dæ˜¯æ— æ³•ç¡®å®šçš„&amp;#xff0c;å…¶ä»–ä¸‰ä¸ªé€‰é¡¹çš„é¡¶ç‚¹éƒ½ä¸æ˜¯ä¸‹ä¸€æ­¥çš„ç›®æ ‡é¡¶ç‚¹çš„å¯èƒ½æ€§æ¯”è¾ƒå°&amp;#xff0c;ä½†éœ€è¦å…·ä½“æƒ…å†µå…·ä½“åˆ†æã€‚å¦‚æœéœ€è¦ç¡®å®šä¸‹ä¸€æ­¥ç›®æ ‡é¡¶ç‚¹&amp;#xff0c;éœ€è¦çŸ¥é“é¡¶ç‚¹Dä¸0ã€2ã€3ã€4ä¹‹é—´çš„è¿è¾¹æƒ…å†µã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["Dijkstraç®—æ³•çš„é—®é¢˜", ["ç”¨Dijkstraç®—æ³•æ±‚ä¸€ä¸ªå¸¦æƒæœ‰å‘å›¾Gä¸­ä»é¡¶ç‚¹0å‡ºå‘çš„æœ€çŸ­è·¯å¾„ï¼Œåœ¨ç®—æ³•æ‰§è¡Œçš„æŸæ—¶åˆ»ï¼ŒS={0,2,3,4}ï¼Œä¸‹ä¸€æ­¥é€‰å–çš„ç›®æ ‡é¡¶ç‚¹å¯èƒ½æ˜¯   D   ã€‚", "A.é¡¶ç‚¹2            B.é¡¶ç‚¹3            C.é¡¶ç‚¹4            D.é¡¶ç‚¹7", "è¡¨è¾¾çš„æ˜¯å•¥æ„æ€å˜ï¼Œé¡¶ç‚¹7åˆæ˜¯æ€ä¹ˆå‡ºæ¥çš„å˜"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/a19990412/article/details/80232810\" id=\"textarea_1655439466811_1655439572959_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•&amp;#xff08;Dijkstra&amp;#xff09;è¯æ˜_è‚¥å®…_Seançš„åšå®¢-CSDNåšå®¢_è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•è¯æ˜&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;é¦–å…ˆ&amp;#xff0c;è¿™ç¯‡æ–‡ç« æ˜¯åœ¨è®²ã€Šå›¾è®ºã€‹æ—¶å€™å†™æ–‡ç« &amp;#xff08;æ‰€ä»¥&amp;#xff0c;è¿˜æ˜¯ä»¥ç†è®ºä¸ºä¸»&amp;#xff0c;ä»¥åæœ‰ç©ºçš„æ—¶å€™&amp;#xff0c;ä¼šæŠŠä»£ç å‘ä¸Šæ¥&amp;#xff0c;ä¸è¿‡æˆ‘è§‰å¾—å¤§å®¶çœ‹å®Œç†è®º&amp;#xff0c;å¦‚æœè®²å¾—å¥½&amp;#xff0c;ä»£ç ä¹Ÿå°±æ¯”è¾ƒå®¹æ˜“äº†ã€‚å¦‚æœè®²å¾—ä¸å¥½&amp;#xff0c;ç½‘ä¸Šçš„ä»£ç ä¹Ÿæ˜¯å¤§æŠŠ&amp;#xff0c;ä¸çœ‹è¿™ç¯‡æ–‡ç« ä¹Ÿç½¢äº†&amp;#xff09;ä¸‹å›¾ä¸ºè€å¸ˆçš„è¯¾ä»¶å†…å®¹éƒ¨åˆ†&amp;#xff0c;æˆ‘è§‰å¾—è™½ç„¶è¯¦å°½&amp;#xff0c;ä½†ä¹Ÿæœ‰äº›æ¯ç‡¥ã€‚å¯èƒ½æ˜¯ä¸ºäº†å‡ç»ƒè¯­è¨€å§ã€‚å¦‚æœæœ‰è€å¿ƒçœ‹çš„è¯&amp;#xff0c;å€’çœŸçš„æ˜¯ä¸€ç¯‡éå¸¸å¥½çš„æ–‡ç« ã€‚&amp;#xff08;åæ­£è¿™ä¸ªåº”è¯¥æ˜¯æ¯”ç™¾åº¦ç™¾ç§‘è¦å¼ºçš„â€¦.&amp;#xff09; æˆ‘åœ¨åé¢ä¼šç”¨è‡ªå·±çš„è¯­è¨€é˜...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/a19990412/article/details/80232810&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["è¯æ˜è¯æ˜Dijkstraç®—æ³•æ­£ç¡®æ€§ï¼Œå¹¶åˆ†ææ—¶é—´å¤æ‚åº¦", ["è¯æ˜Dijkstraç®—æ³•æ­£ç¡®æ€§ï¼Œå¹¶åˆ†æåœ¨æœªä¼˜åŒ–çš„æƒ…å†µä¸‹å…¶å¹³å‡æƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦ã€‚å‡è®¾å›¾ä¸ºG=(V,E)", "\n", "è¦æ±‚ï¼šc/c++ï¼Œæœ‰è¯æ˜è¿‡ç¨‹"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;æ®µé”™è¯¯ä¸€èˆ¬æ˜¯æ•°ç»„ä¸‹æ ‡è¶Šç•Œ&lt;br /&gt;æˆ–è€…æŒ‡é’ˆæ²¡æœ‰æ­£ç¡®æŒ‡å‘æˆ–æ²¡æœ‰åˆ†é…ç©ºé—´&lt;br /&gt;å‚è€ƒä»£ç &lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; namespace std;\nstruct Node {\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x, y;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n};\nstruct TS {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n};\n\nTS HHH[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N, &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; D, G[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\nNode Dist[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; visit[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-keyword\"&gt;false&lt;/span&gt;};\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; cmp(TS a, TS b) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.distant &amp;lt; b.distant;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main() {\n    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; D;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;32.5&lt;/span&gt;) {\n        printf(&amp;#34;1\\n&amp;#34;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; X, Y;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tol &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fill(G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; &lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        cin &amp;gt;&amp;gt; X &amp;gt;&amp;gt; Y;\n        HHH[i].num &amp;#61; i;\n        Dist[i].x &amp;#61; X;\n        Dist[i].y &amp;#61; Y;\n        Dist[i].distant &amp;#61; sqrt(X * X &amp;#43; Y * Y);\n        HHH[i].distant &amp;#61; Dist[i].distant;\n        Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;) {\n            Init(i, j);\n        }\n    }\n    \n    sort(HHH, HHH &amp;#43; N, cmp);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HHH[i].distant &amp;gt; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; HHH[i].distant &amp;lt;&amp;#61; D &amp;#43; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; !visit[HHH[i].num]) {\n            tol &amp;#61; BFS(HHH[i].num);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) break;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) printf(&amp;#34;0\\n&amp;#34;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j) {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; Dist[i].x - Dist[j].x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y &amp;#61; Dist[i].y - Dist[j].y;\n    G[i][j] &amp;#61; G[j][i] &amp;#61; sqrt(x * x &amp;#43; y * y);\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((Dist[i].x &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].x - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;) || (Dist[i].y &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].y - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;)) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n\n    visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n    Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; Q;\n    Q.push(i);\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!Q.empty()) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; Q.front();\n        Q.pop();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (Judge(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;)) {\n            cout &amp;lt;&amp;lt; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; endl;\n            stack&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; st;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;) {\n                st.push(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;];\n            }\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!st.empty()) {\n                &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Top &amp;#61; st.top();\n                st.pop();\n                cout &amp;lt;&amp;lt; Dist[Top].x &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; Dist[Top].y &amp;lt;&amp;lt; endl;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;][i] &amp;lt;&amp;#61; D &amp;amp;&amp;amp; !visit[i]) {\n                visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n                Dist[i].c &amp;#61; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;;\n                Q.push(i);\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ•°æ®ç»“æ„ä¹ é¢˜ï¼Œå›¾çš„Dijkstraç®—æ³•", ["é¢˜ç›®å¦‚ä¸‹", "\n", "This time let us consider the situation in the movie \"Live and Let Die\" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big headï¼ˆçœç•¥å·ï¼‰ Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).", "\n", "Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.", "\n", "Input Specification:", "Each input file contains one test case. Each case starts with a line containing two positive integers N (â‰¤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.", "\n", "Output Specification:", "For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.", "\n", "\n", "\n", "æˆ‘çš„ä»£ç ", "\n", "//è‡ªå·±å†™çš„ï¼ŒåŠé”™ç‰ˆæœ¬ ", "\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n#define MaxVertexNum ", "105", "\n#define M_INFINITY ", "65535", "\ntypedef int Vertex;\ntypedef double WeightType;\ntypedef struct Data{\n    int X,Y;\n}DataType[MaxVertexNum];\n\n", "/*è¾¹çš„å®šä¹‰*/", "\ntypedef struct ENode* PtrToENode;\nstruct ENode{\n    Vertex V1,V2;\n    WeightType Weight; \n};\ntypedef PtrToENode Edge;\n\n", "/*å›¾çš„å®šä¹‰*/", "\ntypedef struct GNode* PtrToGNode;\nstruct GNode{\n    int Nv;\n    int Ne;\n    WeightType D[MaxVertexNum][MaxVertexNum];\n    DataType Locate;\n};\ntypedef PtrToGNode MGraph;\n\n", "//åˆ›é€ å›¾çš„å‡½æ•°", "\nvoid InsertEdge(MGraph Graph, Edge E)\n{\n    G", "raph", "->", "D[E->V1][E->V2] = E->Weight;\n    G", "raph", "->", "D[E->V2][E->V1] = E->Weight;\n}\nMGraph CreatGraph(int VertexNum)\n{", "/*åˆå§‹åŒ–ä¸€ä¸ªå›¾ç»“æ„ï¼Œæ‰€æœ‰å¯¹è§’è¾¹ä¸º0ï¼Œéå¯¹è§’è¾¹ä¸ºINFINITY*/", "\n    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));\n    G", "raph", "->", "Nv = VertexNum;\n    G", "raph", "->", "Ne = ", "0", ";\n    int V,W;\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V;W<Graph->", "Nv;W++){\n            ", "if", "(V!=W){\n                G", "raph", "->", "D[V][W] = M_INFINITY;\n                G", "raph", "->", "D[W][V] = M_INFINITY;\n            }", "else", "{\n                G", "raph", "->", "D[V][W] = ", "0", ";\n            }\n        }\n    }\n    return Graph;\n}\nWeightType Length(double X1,double Y1,double X2,double Y2)\n{", "/*è¿”å›ä¸¤ä¸ªç‚¹çš„ç›´çº¿è·ç¦»*/", "\n    double deltx = X1-X2;\n    double delty = Y1-Y2;\n    WeightType weight = ", "sqrt", "(deltx*deltx + delty*delty);\n    return weight;\n}\nMGraph BuildGraph(int Nv,double D)\n{", "/*åˆ›é€ å›¾*/", "\n    int i,V,W;\n    Vertex X,Y;\n    WeightType Weight;\n    MGraph Graph = CreatGraph(Nv+", "1", ");\n    Edge E = (Edge)malloc(sizeof(struct ENode));\n    \n    V=", "1", ";\n    G", "raph", "->", "L", "ocate", "[0].X = Graph->", "Locate[", "0", "].Y = ", "0", ";\n    ", "for", "(i=", "1", ";i<=Nv;i++){\n        scanf(", "\"%d%d\"", ",&X,&Y);\n        \n        ", "if", "(", "abs", "(X)<", "50", " && ", "abs", "(Y)<", "50", " && Length(X,Y,", "0", ",", "0", ")>", "7.5", "){\n            G", "raph", "->", "Locate[V].X = X;\n            G", "raph", "->", "Locate[V].Y = Y;\n            V++;\n        }", "else", "{\n            G", "raph", "->", "Nv--;\n        }\n    }\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V+1;W<Graph->", "Nv;W++){\n            W", "eight", " = Length(Graph->", "L", "ocate", "[V].X,Graph->", "Locate[V].Y,\n            G", "raph", "->", "L", "ocate", "[W].X,Graph->", "Locate[W].Y);\n            ", "if", "(Weight<=D){\n                E->V1 = V;\n                E->V2 = W;\n                E->Weight = Weight;\n                ", "if", "(E->", "V1==", "0", ") E->Weight-=", "7.5", ";\n                InsertEdge(Graph,E);\n            }\n        }\n    }\n    \n    return Graph;\n}\n\nVertex FindMinDist(MGraph Graph, double dist[], int collected[])\n{\n    Vertex MinV, V;\n    int MinDist = M_INFINITY;\n    \n    ", "for", "(V=0; V<Graph->", "Nv; V++){\n        ", "if", "(collected[V]==", "0", " && dist[V]<MinDist){\n            MinDist = dist[V];\n            MinV = V;\n        }\n    }\n    ", "if", "( MinDist < M_INFINITY )\n        return MinV;\n    ", "else", " return ", "0", ";\n}\nvoid Dijkstra(MGraph Graph, double* dist, int* ", "path", ",int* collected)\n{\n    Vertex V,W;\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "dist", "[V] = Graph->", "D[", "0", "][V];\n        ", "if", "(dist[V]<M_INFINITY)\n            ", "path", "[V] = ", "0", ";\n        ", "else", "\n            ", "path", "[V] = -", "1", ";\n        collected[V] = ", "0", ";\n    }\n    ", "/*å…ˆå°†èµ·ç‚¹æ”¶å…¥é›†åˆ*/", "\n    dist[", "0", "] = ", "0", ";\n    collected[", "0", "] = ", "1", ";\n    \n    ", "while", "(", "1", "){\n        V = FindMinDist(Graph,dist,collected);\n        ", "if", "(V==", "0", ")\n            break;\n        collected[V] = ", "1", ";\n        ", "for", "(W=0;W<Graph->", "Nv;W++)\n            ", "if", "(collected[W]==0 && Graph->", "D[V][W]<M_INFINITY){\n                ", "if", "(dist[V]+Graph->", "D[V][W]<dist[W]){\n                    ", "dist", "[W] = dist[V]+Graph->", "D[V][W];\n                    ", "path", "[W] = V; \n                }\n            }\n    }\n}\n\nint min(int x,int y)\n{\n    ", "if", "(x<y) return x;\n    ", "else", " return y;\n}\n\nint main()\n{\n    ", "/*è¾“å…¥æ•°ï¼Œï¼ˆåˆå§‹Nvï¼Œå¯èƒ½ä¼šæ›´å°‘ï¼‰ï¼Œè¾“å…¥JanesBondä¸€æ¬¡æœ€è¿œè·³*/", "\n    int N,D,i;\n    scanf(", "\"%d%d\"", ",&N,&D);\n    ", "/*åˆ›é€ å›¾*/", "\n    MGraph Graph = BuildGraph(N,D);\n    ", "/*åˆå§‹åŒ–dist[],path[],collected[]*/", "\n    ", "double", " dist[Graph->", "Nv];\n    ", "int", " ", "path", "[Graph->", "N", "v", "],collected[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        dist[i] = M_INFINITY;\n        ", "path", "[i] = -", "1", ";\n        collected[i] = ", "0", ";\n    }\n    ", "/*Dijkstraç®—æ³•ç®—dist*/", "\n    Dijkstra(Graph,dist,", "path", ",collected);\n    \n    ", "/*æ‰¾åˆ°å¯ä»¥ä½œä¸ºå‡ºå£å¾—é³„é±¼ï¼ŒåŒæ—¶å°†å®ƒåˆ°å‡ºå£çš„è·ç¦»å­˜å‚¨åˆ°æ•°ç»„ä¸­*/", "\n    V", "ertex", " V,W,OutNode[Graph->", "Nv];\n    int flag = ", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++) OutNode[V]=", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "if", "(50-fabs(Graph->", "L", "ocate", "[V].X)<=D || 50-fabs(Graph->", "Locate[V].Y)<=D){\n            ", "if", "(50-fabs(Graph->", "Locate[V].X)<=D){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }", "else", " ", "if", "(50-fabs(Graph->", "Locate[V].Y<=D)){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }\n            flag=", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    flag = ", "0", ";\n    ", "for", "(W=1;W<Graph->", "Nv;W++){\n        ", "if", "(Graph->", "D[", "0", "][W]!=M_INFINITY){\n            flag = ", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    ", "/*ä»¥ä¸Šä¸ºåˆ¤æ–­æ˜¯å¦æœ‰å¯èƒ½å¯ä»¥å‡ºå»ï¼Œä¹Ÿå°±æ˜¯1>Islandæœ‰æ²¡æœ‰é‚»æ¥ç‚¹ï¼Œ2>æœ‰æ²¡æœ‰å¯ä»¥è·³å‡ºå»çš„é³„é±¼*/", "\n\n    ", "/*\n    æ‰¾æœ€çŸ­è·¯\n    1.æ‰¾å¯ä»¥å‡ºå»çš„è·¯å¾„\n    2.æ¯”è¾ƒå¯ä»¥å‡ºå»çš„è·¯å¾„ä¸­æœ€çŸ­è·¯å¾„ \n    */", "\n    \n    V", "ertex", " OutWay[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        OutWay[i]=-", "1", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(50-", "abs", "(Graph->", "L", "ocate", "[i].X)<=D || 50-", "abs", "(Graph->", "Locate[i].Y)<=D){\n            O", "utWay", "[i] = min(50-", "abs", "(Graph->", "L", "ocate", "[i].X),50-", "abs", "(Graph->", "Locate[i].Y));\n        }\n    }\n    \n    \n    ", "/*ä»å‡ºå£ä¸­æ›´æ–°è·¯å¾„é•¿åº¦*/", "\n    ", "double", " Outdist[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        Outdist[i] = ", "0", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            Vertex temNode = i;\n            ", "while", "(temNode){\n                Outdist[i]+=dist[temNode];\n                temNode = ", "path", "[temNode];\n            }\n        }\n    }\n    \n    ", "/*ä»è·¯å¾„ä¸­æ‰¾æœ€å°é•¿ï¼Œå¹¶è®°å½•*/", "\n    Vertex MinWay;\n    double Mindist=M_INFINITY;\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            ", "if", "(Mindist>Outdist[i]){\n                Mindist = Outdist[i];\n                MinWay = i;\n            }\n        }\n    }\n    \n    ", "/*ä»æœ€å°è·¯å¾„ä¸­æ‰¾ç»“ç‚¹ï¼Œåå‘è¾“å‡º*/", "\n    V", "ertex", " Stack[Graph->", "Nv];\n    int rear=-", "1", ",count=", "1", ";\n    Vertex temNode = MinWay;\n    ", "while", "(temNode){\n        Stack[++rear] = temNode;\n        temNode = ", "path", "[temNode];\n        count++;\n    }\n    printf(", "\"%d\\n\"", ",count);\n    ", "while", "(rear!=-", "1", "){\n        ", "printf", "(\"%d %d\\n\",Graph->", "L", "ocate", "[Stack[rear]].X,Graph->", "Locate[Stack[rear]].Y);\n        rear--;\n    }\n    \n    return ", "0", ";\n}\n\n", "\n", "æœ€åç»“æœ", "\n", "\n", "å®åœ¨ä¸çŸ¥é“å“ªé”™äº†ï¼Œæœ€åˆæ˜¯å‰ä¸‰é¡¹éƒ½é€šè¿‡äº†ï¼Œåæ¥å°±ä»å¤´å†æ¥ä¸€éï¼Œå“ªçŸ¥é“ç°åœ¨åé¢å‡ ä¸ªå¯¹äº†ç¬¬ä¸€ä¸ªé¡¹ç›®è¯´æ®µé”™è¯¯ï¼Œæ®µé”™è¯¯ç»™çš„ç†ç”±å¦‚ä¸‹", "\n", "\n", "ä¸è¿‡ç°åœ¨æµ‹è¯•ç‚¹ä¹Ÿä¸çŸ¥é“å“ªé”™äº†ï¼Œéº»çƒ¦çœ‹çœ‹å§"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;é‚»æ¥è¡¨ä½ å¯ä»¥ç†è§£ä¸ºå¤šä¸ªé“¾è¡¨&amp;#xff0c;æ¯ä¸ªé“¾è¡¨çš„å¤´æ˜¯ä¸€ä¸ªèŠ‚ç‚¹&amp;#xff0c;è€Œä½ æ·»åŠ ä¸€æ¡è¾¹add&amp;#xff08;a,b,c&amp;#xff09;ç›¸å½“äºç»™aå¢æ·»ä¸€ä¸ªå‡ºåº¦bé•¿åº¦ä¸ºc&amp;#xff0c;è€Œ next[a]ä¸­å‚¨å­˜çš„æ˜¯å°±æ˜¯aæ‰€æœ‰çš„å‡ºåº¦çš„åœ°å€&amp;#xff0c;nextå­˜å‚¨çš„æ˜¯ä¸‹ä¸€ä¸ªå‡ºåº¦çš„åœ°å€&amp;#xff0c;ver[i]å°±æ˜¯å‡ºåº¦ç‚¹çš„æ ‡å·&amp;#xff0c;edge[i]å¤´èŠ‚ç‚¹åˆ°å‡ºåº¦çš„è·ç¦»&amp;#xff0c;djçš„åŸºæœ¬æ€è·¯æ˜¯æ¯æ¬¡é€‰å–ä¸€ä¸ªç¦»åŸç‚¹æœ€è¿‘çš„è¾¹æ¥æ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»&amp;#xff0c;æˆ‘ä»¬å…ˆå°†{0&amp;#xff0c;1}åŠ å…¥å †ä¸­&amp;#xff0c;å †æ’åºpairæ ¹æ®firstä¼˜å…ˆåŸåˆ™&amp;#xff0c;æ‰€ä»¥æ„æ€å°±æ˜¯å †ä¸­1å·ç‚¹åˆ°ä¸€å·ç‚¹çš„è·ç¦»ä¸º0&amp;#xff0c;é‚£ä¹ˆæ­¤æ—¶ä¼šç”¨1å·ç‚¹å…ˆæ›´æ–°å®ƒå‡ºåº¦&amp;#xff0c;å¹¶ä¸”æ¯ä¸ªç‚¹æœ‰ä¸”åªä¼šè¢«åŠ å…¥ä¸€æ¬¡&amp;#xff0c;æˆ‘ä»¬å°†å®ƒæ‰“ä¸Šæ ‡è®°&amp;#xff0c;å¦‚æœå †ä¸­å·²ç»åŠ å…¥è¿‡è¿™ä¸ªæœ€çŸ­è¾¹&amp;#xff0c;æˆ‘ä»¬ç›´æ¥å°†å®ƒcontinue&amp;#xff0c;å¦åˆ™è€Œå¾ªç¯çš„ç»ˆç‚¹å°±æ˜¯æ²¡æœ‰è¾¹å†è¢«æ›´æ–°çš„æ—¶å€™&amp;#xff0c;ä¹Ÿå°±æ˜¯æ²¡æœ‰ä¸œè¥¿å¯ä»¥å…¥é˜Ÿäº†&amp;#xff0c;å¾ªç¯ç»“æŸã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["Dijkstraç®—æ³•åŠé‚»æ¥è¡¨ C++", ["priority_queue<pair<", "int", ",", "int", ">>q;", "//å¤§æ ¹å †-å°æ ¹å †", "\n    ", "memset", "(d,", "0x3f", ",", "sizeof", "(d);\n    ", "memset", "(v,", "0", ",", "sizeof", "(v));\n    d[", "1", "]=", "0", ";\n    q.", "push", "(", "make_pair", "(", "0", ",", "1", "));\n    ", "while", "(q.", "size", "())\n    ", "int", " x=q.", "top", "().second;q.", "pop", "();\n    ", "if", "(v[x])", "continue", ";\n    v[x]=", "1", ";\n    ", "for", "(", "int", " i=head[x];i;i=Next[i])\n    ", "int", " y=ver[i],z=edge[i];\n    ", "if", "(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.", "push", "(", "make_pair", "(-d[y],y));\n    }\n    } \n", "\n", "å¦‚ä¸Šï¼Œè¯·é—®ä¸€ä¸‹ï¼š", "\n", "while", "(q.", "size", "())\n", "if", "(v[x])", "continue", ";\n", "for", "(", "int", " i=head[x];i;i=", "Next", "[i])\n", "\n", "å„æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿè¿˜æœ‰é‚»æ¥è¡¨çš„åŸç†æ˜¯ä»€ä¹ˆï¼Ÿéº»çƒ¦äº†ï¼"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;ä¸è¡Œã€‚å› ä¸ºå„ç§è·¯å¾„çš„ æ­¥æ•°å¹¶ä¸ä¸€å®šç›¸åŒã€‚&lt;br /&gt;æ‰€æœ‰è¾¹æƒå€¼åŠ æ­£æ•°&amp;#xff0c;åªæœ‰åœ¨å„ç§è·¯å¾„æ­¥æ•°ç›¸åŒçš„æƒ…å†µä¸‹æ‰å¯è¡Œã€‚&lt;br /&gt;æ±‚å¸¦è´Ÿæƒå€¼è¾¹çš„å•æºæœ€çŸ­è·¯å¾„å¯ä»¥ç”¨è´å°”æ›¼-ç¦ç‰¹ç®—æ³•ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—", ["è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•å¸¦è´Ÿæƒå€¼ï¼Œæ¯æ¡è¾¹æƒå€¼åŒæ—¶åŠ ä¸Šä¸€ä¸ªæ•°å…¨éƒ½å˜ä¸ºæ­£æ•°ï¼Œå†ç”¨è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³• è¿™æ ·å¯¹å—"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "å¯ä»¥æœ‰å¿å•Šï¼Œå¤§ç¥å¿«æ¥å•Š![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![å›¾ç‰‡è¯´æ˜](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["OPNETå«æ˜Ÿç½‘ç»œè·¯ç”±ç®—æ³•ä»¿çœŸ", ["æœ€è¿‘è¦äº¤æ¯•è®¾å•¦ï¼ŒOPNETçš„å«æ˜Ÿç½‘ç»œè·¯ç”±ä»¿çœŸè¿˜ä¸ä¼šåšï¼Œæ±‚å¤§ç¥æŒ‡å¯¼å•Šï¼ŒçœŸçš„å¾ˆç€æ€¥ã€‚ç®—æ³•ä¸»è¦", "\næ˜¯æ”¶é›†é“¾è·¯çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚æ—¶å»¶ã€å¸¦å®½ã€ä¸¢åŒ…ç‡ï¼Œç„¶åå½’ä¸€åŒ–åˆ°[0,1]ï¼Œåˆ†é…æƒé‡ä½œä¸º", "\né“¾è·¯çš„Costï¼Œç„¶åç”¨Dijkstraç®—æ³•ã€‚", "\næ±‚æŒ‡å¯¼å•Šï¼Œæ€ä¹ˆåšä»¿çœŸï¼Œå‘œå‘œå‘œ~"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å¦‚æœæƒ³è¦åœ¨éå†å›¾ä¸­çš„æ‰€æœ‰ç‚¹ä¹‹åå¾—åˆ°æœ€ä¼˜è·¯å¾„&amp;#xff0c;å¯ä»¥ä½¿ç”¨ä¸€ç§å«åšæ—…è¡Œå•†é—®é¢˜&amp;#xff08;Travelling Salesman Problem&amp;#xff0c;TSP&amp;#xff09;çš„ç®—æ³•ã€‚TSP é—®é¢˜æ˜¯æŒ‡å¯»æ‰¾éå†ä¸€ä¸ªç»™å®šçš„åŸå¸‚åˆ—è¡¨çš„æœ€çŸ­è·¯å¾„çš„é—®é¢˜ã€‚&lt;/p&gt;\n&lt;p&gt;ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def tsp(self, &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;, end):\n    &lt;span class=\"hljs-comment\"&gt;# åˆå§‹åŒ–æœªéå†çš„ç‚¹çš„é›†åˆ&lt;/span&gt;\n    unvisited &amp;#61; set(self.nodes)\n    &lt;span class=\"hljs-comment\"&gt;# å°†èµ·å§‹ç‚¹åŠ å…¥åˆ°å·²éå†çš„ç‚¹çš„é›†åˆä¸­&lt;/span&gt;\n    visited &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;}\n    &lt;span class=\"hljs-comment\"&gt;# åˆå§‹åŒ–å½“å‰ç‚¹ä¸ºèµ·å§‹ç‚¹&lt;/span&gt;\n    current &amp;#61; &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#åˆå§‹åŒ–è·¯å¾„å’Œè·ç¦»ä¸º 0&lt;/span&gt;\n    path &amp;#61; []\n    distance &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\nwhile unvisited:\n    &lt;span class=\"hljs-comment\"&gt;# å¯»æ‰¾å½“å‰ç‚¹çš„æœ€è¿‘çš„æœªéå†çš„ç‚¹&lt;/span&gt;\n    next_node, next_distance &amp;#61; min([(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt;) for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;not&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; visited], &lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x: x[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# å°†æœ€è¿‘çš„æœªéå†çš„ç‚¹åŠ å…¥åˆ°å·²éå†çš„ç‚¹çš„é›†åˆä¸­&lt;/span&gt;\n    visited.add(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# ä»æœªéå†çš„ç‚¹çš„é›†åˆä¸­åˆ é™¤æœ€è¿‘çš„æœªéå†çš„ç‚¹&lt;/span&gt;\n    unvisited.remove(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# æ›´æ–°å½“å‰ç‚¹ä¸ºæœ€è¿‘çš„æœªéå†çš„ç‚¹&lt;/span&gt;\n    current &amp;#61; next_node\n    &lt;span class=\"hljs-comment\"&gt;# æ›´æ–°è·¯å¾„å’Œè·ç¦»&lt;/span&gt;\n    path.append(next_node)\n    distance &amp;#43;&amp;#61; next_distance\n\n&lt;span class=\"hljs-comment\"&gt;# å¦‚æœæœ€åä¸€ä¸ªéå†çš„ç‚¹ä¸æ˜¯ç»ˆç‚¹&amp;#xff0c;æ·»åŠ ä¸€æ¡ä»æœ€åä¸€ä¸ªéå†çš„ç‚¹åˆ°ç»ˆç‚¹çš„è¾¹&lt;/span&gt;\nif current !&amp;#61; end:\n    &lt;span class=\"hljs-comment\"&gt;# å¯»æ‰¾æœ€åä¸€ä¸ªéå†çš„ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·ç¦»&lt;/span&gt;\n    next_distance &amp;#61; min([cost for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;&amp;#61;&amp;#61; end&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# æ›´æ–°è·¯å¾„å’Œè·ç¦»&lt;/span&gt;\n    path.append(end)\n    distance &amp;#43;&amp;#61; next_distance\n\nreturn path, distance\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ–¹æ³•æ¥è§£å†³ TSP é—®é¢˜&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;graph &amp;#61; Graph(&lt;span class=\"hljs-string\"&gt;&amp;#39;map.txt&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;, distance &amp;#61; graph.tsp(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;)  # [&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(distance)  # &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ä»…ä¾›å‚è€ƒ&amp;#xff0c;æœ›é‡‡çº³&amp;#xff0c;è°¢è°¢ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ€ä¹ˆå°†ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„æ”¹æˆä»»æ„ä¸¤ç‚¹é—´éå†å®Œæ‰€æœ‰ç‚¹åçš„æœ€ä¼˜è·¯å¾„å‘¢", ["\n", "class", " ", "Graph", ":\n            ", "def", " ", "__init__", "(", "self,filename", "):", "#å°†åœ°å›¾å»ºæˆä¸€ä¸ªé‚»æ¥è¡¨", "\n        \n               graph_edges=[]", "#è¾¹çš„é•¿åº¦", "\n               ", "with", " ", "open", "(filename) ", "as", " fhandle:", "#è¯»å–æ–‡ä»¶ï¼Œä¸€è¡Œä¸€è¡Œçš„è¯»", "\n                      ", "for", " line ", "in", " fhandle:\n                          ", "if", " line==", "\"\\n\"", ":", "#è¯»å–æˆªæ­¢æ¡ä»¶ï¼Œæ³¨æ„å¿…é¡»åŠ å¦åˆ™ä¼šæŠ¥é”™", "\n                            ", "break", "\n                ", "#å°†map.txtæ–‡ä»¶ä¸­çš„æ•°æ®æŒ‰ç©ºæ ¼åˆ†ç¦»å¹¶å­˜å‚¨ï¼Œ*_ä»£è¡¨è¿™ä¸€è¡Œåé¢æ‰€æœ‰çš„å…ƒç´ ã€‚", "\n                          edge_from,edge_to,cost,*_=line.strip().split(", "\" \"", ")\n                          graph_edges.append((edge_from,edge_to,cost))", "#ä»¥å…ƒç»„çš„å½¢å¼åŠ å…¥åˆ°graph_edges", "\n        ", "#å»ºç«‹èŠ‚ç‚¹ï¼Œset() å‡½æ•°åˆ›å»ºä¸€ä¸ªæ— åºä¸é‡å¤å…ƒç´ é›†ï¼Œ", "\n        ", "#å¯è¿›è¡Œå…³ç³»æµ‹è¯•ï¼Œåˆ é™¤é‡å¤æ•°æ®ï¼Œè¿˜å¯ä»¥è®¡ç®—äº¤é›†ã€å·®é›†ã€å¹¶é›†ç­‰ã€‚", "\n               self.nodes =", "set", "()\n               ", "for", " edge ", "in", " graph_edges:\n            ", "#åˆå§‹åŒ–èŠ‚ç‚¹", "\n            ", "#update() æ–¹æ³•ç”¨äºä¿®æ”¹å½“å‰é›†åˆï¼Œå¯ä»¥æ·»åŠ æ–°çš„å…ƒç´ æˆ–é›†åˆåˆ°å½“å‰é›†åˆä¸­ï¼Œ", "\n            ", "#å¦‚æœæ·»åŠ çš„å…ƒç´ åœ¨é›†åˆä¸­å·²å­˜åœ¨ï¼Œåˆ™è¯¥å…ƒç´ åªä¼šå‡ºç°ä¸€æ¬¡ï¼Œé‡å¤çš„ä¼šå¿½ç•¥ã€‚", "\n                  self.nodes.update([edge[", "0", "],edge[", "1", "]])\n        ", "#å»ºç«‹é‚»æ¥è¡¨", "\n               self.adjacency_list = {node: ", "set", "() ", "for", " node ", "in", " self.nodes}\n               ", "for", " edge ", "in", " graph_edges:\n           ", "#å­—å…¸ä¸­çš„é”®è¡¨ç¤ºå›¾ä¸­çš„èŠ‚ç‚¹ï¼Œè€Œé”®å€¼åˆ™æ˜¯ä»¥å­—å…¸çš„å½¢å¼å­˜åœ¨é‡Œé¢åŒ…æ‹¬å‡ ç»„ä¸€å…ƒç»„çš„å½¢å¼å‚¨å­˜çš„", "\n           ", "#è¡¨ç¤ºå¯è¾¾åˆ°èŠ‚ç‚¹ä»¥åŠæƒå€¼", "\n                   self.adjacency_list[edge[", "0", "]].add((edge[", "1", "],edge[", "2", "]))\n            ", "def", " ", "shortest_path", "(", "self, start_node, end_node", "):\n                start_node=nameEntry3.get()\n                end_node=nameEntry4.get()\n               \n        ", "#ä½¿ç”¨Dijkstraç®—æ³•æ‰¾åˆ°ä»èµ·å§‹ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè¿”å›ï¼ˆpath,distanceï¼‰", "\n               \n        ", "#åˆ›é€ ä¸€ä¸ªæœªè®¿é—®èŠ‚ç‚¹çš„é›†åˆåˆå§‹åŒ–ä¸ºæ‰€æœ‰èŠ‚ç‚¹", "\n                unvisited_nodes = self.nodes.copy()  \n        ", "#åˆ›å»ºä¸€ä¸ªå­—å…¸è¡¨ç¤ºæ¯ä¸ªç‚¹åˆ°èµ·å§‹ç‚¹çš„è·ç¦»ï¼Œæ¯ä¸ªç‚¹å…ˆåˆå§‹åŒ–ä¸ºinfé™¤äº†ç‚¹æœ¬èº«åˆå§‹åŒ–ä¸º0", "\n        ", "#å½“æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªæ›´çŸ­è·¯å¾„çš„æ—¶å€™æ›´æ–°è¿™ä¸ªå­—å…¸æ‰€å¯¹åº”çš„å€¼ï¼Œæ•°æ®ç»“æ„ä¸º èŠ‚ç‚¹ï¼šè·ç¦»", "\n                distance_from_start = {node: (", "0", " ", "if", " node == start_node ", "else", " INFINITY) ", "for", " node ", "in", " self.nodes}\n \n        ", "#åˆå§‹åŒ–å‰ç½®èŠ‚ç‚¹ä¹Ÿå°±æ˜¯ç”¨æ¥å¯»æ‰¾è·¯å¾„çš„æ–¹æ³•ï¼Œç»“æ„ä¸ºèŠ‚ç‚¹ï¼šèŠ‚ç‚¹å…¶ä¸­åé¢çš„èŠ‚ç‚¹æ˜¯å‰é¢", "\n        ", "#çš„å‰ç½®èŠ‚ç‚¹ï¼Œç”±æ­¤å¯ä»¥ä¸€æ­¥æ­¥æ‰¾åˆ°è·¯å¾„ï¼Œå¦‚æœæ‰¾åˆ°æ›´çŸ­è·¯å¾„å°±æ›´æ–°è¿™ä¸ªå­—å…¸", "\n                previous_node = {node: ", "None", " ", "for", " node ", "in", " self.nodes}\n                ", "while", " unvisited_nodes:\n            ", "#å°†å½“å‰èŠ‚ç‚¹è®¾ç½®ä¸ºåˆ°ç›®å‰ä¸ºæ­¢åœ¨æœªè®¿é—®èŠ‚ç‚¹è¿™ä¸ªå­—å…¸ä¸­è·¯å¾„æœ€çŸ­çš„èŠ‚ç‚¹", "\n                     current_node = ", "min", "(\n                ", "#ä»unvisited_nodesä¸­æ‰¾åˆ°é”®å€¼æœ€å°çš„èŠ‚ç‚¹ä½œä¸ºå½“å‰èŠ‚ç‚¹", "\n                          unvisited_nodes, key=", "lambda", " node: distance_from_start[node]\n                       )\n            ", "#ä»æœªè®¿é—®çš„èŠ‚ç‚¹ä¸­ï¼Œç§»é™¤å½“å‰èŠ‚ç‚¹", "\n                     unvisited_nodes.remove(current_node)\n            ", "#å¦‚æœå½“å‰èŠ‚ç‚¹çš„è·ç¦»ä¸ºæ— ç©·å¤§ï¼Œåˆ™å…¶ä½™æœªè®¿é—®çš„èŠ‚ç‚¹ä¸ä¼šè¿æ¥åˆ°å¼€å§‹èŠ‚ç‚¹ï¼Œåœæ­¢", "\n                     ", "if", " distance_from_start[current_node] == INFINITY:\n                       ", "break", "\n \n            ", "#éå†æ¯ä¸ªå½“å‰èŠ‚ç‚¹çš„é‚»å±…ï¼Œæ£€æŸ¥ä¸€ä¸‹ä»èµ·å§‹èŠ‚ç‚¹åˆ°å½“å‰èŠ‚ç‚¹å†åˆ°é‚»å±…èŠ‚ç‚¹çš„è·ç¦»çš„å¤§å°", "\n            ", "#ä¸distance_form_startä¸­çš„æ¯”è¾ƒçœ‹çœ‹æ˜¯å¦æ›´å°ï¼Œæ˜¯è®²ç©¶æ›´æ–°distanceä¸­æ‰€å¯¹åº”çš„å€¼", "\n                     ", "for", " neighbor, distance ", "in", " self.adjacency_list[current_node]:\n                ", "#æ–°çš„è·¯å¾„çš„è·ç¦»", "\n                        new_path = distance_from_start[current_node] + ", "int", "(distance)\n                        ", "if", " new_path < distance_from_start[neighbor]:\n                             distance_from_start[neighbor] = new_path", "#æ›´æ–°å€¼", "\n                             previous_node[neighbor] = current_node", "#æ›´æ–°è·¯å¾„ï¼Œå°†å½“å‰èŠ‚ç‚¹ä½œä¸ºé‚»å±…çš„å‰ç½®èŠ‚ç‚¹", "\n \n        ", "#ä¸ºäº†æ‰¾åˆ°æˆ‘ä»¬æ‰€å»ºç«‹çš„æœ€çŸ­è·¯å¾„ï¼Œä½¿ç”¨è¿­ä»£å™¨éå†æ¯ä¸ªç‚¹çš„å‰ç½®èŠ‚ç‚¹å³å¯æ‰¾åˆ°è·¯å¾„", "\n        ", "#å¹¶ä¸”æŠŠä»–å­˜å…¥ä¸€ä¸ªé˜Ÿåˆ—ä¸­ä¹‹æ‰€ä»¥å¯ä»¥ä¿è¯æ‰¾å¾—åˆ°å‰ç½®èŠ‚ç‚¹ï¼Œæ˜¯å› ä¸ºç®—æ³•å®Œæˆæ—¶å€™æ¯ä¸ªç‚¹çš„å‰ç½®èŠ‚ç‚¹éƒ½ä»£è¡¨ç€", "\n        ", "#åˆ°èµ·å§‹ç‚¹çš„æœ€çŸ­è·¯å¾„", "\n                path = deque()\n                current_node = end_node\n                ", "while", " previous_node[current_node] ", "is", " ", "not", " ", "None", ":\n                       path.appendleft(current_node)\n                       current_node = previous_node[current_node]\n                path.appendleft(start_node)\n                ", "return", " path, distance_from_start[end_node]\n       \n                   \n", "\n", "æ€ä¹ˆå°†ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯å¾„æ”¹æˆä»»æ„ä¸¤ç‚¹é—´éå†å®Œæ‰€æœ‰ç‚¹åçš„æœ€ä¼˜è·¯å¾„å‘¢"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;åŸºäºæœ€æ–°ç‰ˆChatGPT4çš„å›ç­”&amp;#xff0c;æœ›é‡‡çº³!!!æœ‰å…¶ä»–é—®é¢˜ä¹Ÿå¯ä»¥è¯¢é—®æˆ‘å“¦ã€â€(æœ€æ–°ç‰ˆæ›´æ™ºèƒ½&amp;#xff0c;åŠŸèƒ½æ›´åŠ å¼ºå¤§)&lt;/p&gt;\n&lt;p&gt;ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜&amp;#xff0c;æˆ‘ä»¬éœ€è¦ä¿®æ”¹Dijkstraç®—æ³•&amp;#xff0c;ä½¿å…¶æœ€å¤§åŒ–æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æœ€å°åŒ–æƒé‡å’Œã€‚æˆ‘ä»¬å°†è¿›è¡Œä»¥ä¸‹æ›´æ”¹&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;åˆå§‹åŒ–æ—¶&amp;#xff0c;å°†æºèŠ‚ç‚¹çš„è·ç¦»è®¾ç½®ä¸º1&amp;#xff0c;è€Œä¸æ˜¯0ã€‚&lt;/li&gt;&lt;li&gt;åœ¨å¯»æ‰¾æœ€å°è·ç¦»çš„èŠ‚ç‚¹æ—¶&amp;#xff0c;å¯»æ‰¾å…·æœ‰æœ€å¤§è·ç¦»çš„èŠ‚ç‚¹ã€‚&lt;/li&gt;&lt;li&gt;åœ¨æ›´æ–°èŠ‚ç‚¹çš„è·ç¦»æ—¶&amp;#xff0c;ä½¿ç”¨æ¦‚ç‡ä¹˜ç§¯è€Œä¸æ˜¯æƒé‡å’Œã€‚&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;ä»¥ä¸‹æ˜¯ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä¸­çš„ä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;// DSA Programming task 4.2 - Dijsktra&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// You work on this file where TODO is located&lt;/span&gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &lt;span class=\"hljs-string\"&gt;&amp;#34;dijkstra.h&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Initializes graph for Dijkstra&lt;/span&gt;\nvoid init_graph(weightedgraph* g, int vertices){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;nVertices &amp;#61; vertices;\n    int i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; vertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;adj_list[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// TODO! Note the distance&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Dijkstra search from node s&lt;/span&gt;\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;// Initialize graph&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;1; i &amp;lt;&amp;#61; g-&amp;gt;&lt;/span&gt;nVertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// All vertices in queue&lt;/span&gt;\n        queue[i] &amp;#61; i;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// TODO! Modification should start from here&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Note that the propability should be maximized&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Chanage names of variables accordingly&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[s] &amp;#61; &lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;g-&amp;gt;&lt;/span&gt;nVertices; i &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i--) {\n        &lt;span class=\"hljs-comment\"&gt;// Search for maximum from the queue&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;double&lt;/span&gt; maxval &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]];\n        int maxnode &amp;#61; queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        int maxj&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt;&amp;#61; i; j&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;( g-&amp;gt;&lt;/span&gt;dist[queue[j]] &amp;gt; maxval ){\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;maxval&lt;/span&gt; &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[j]];\n                maxnode &amp;#61; queue[j];\n                maxj &amp;#61; j;\n            }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// Switches the maximum to end (out of the queue)&lt;/span&gt;\n        int temp &amp;#61; queue[i];\n        queue[i] &amp;#61; queue[maxj];\n        queue[maxj] &amp;#61; temp;\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pweightededgenode&lt;/span&gt; pedge &amp;#61; g-&amp;gt;&lt;/span&gt;adj_list[maxnode];\n\n        &lt;span class=\"hljs-comment\"&gt;// Relax the neighbors&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(pedge !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; v &amp;#61; pedge-&amp;gt;&lt;/span&gt;nodenum;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;lt; (g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight))  {\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;#61; g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[v] &amp;#61; maxnode;\n            }\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pedge&lt;/span&gt; &amp;#61; pedge-&amp;gt;&lt;/span&gt;next;\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// DEBUG INFO:&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// printf(&amp;#34;%d processed: d[%d] &amp;#61; %f\\n&amp;#34;,maxnode,maxnode,g-&amp;gt;dist[maxnode]);&lt;/span&gt;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//No need to change anyting after this point!&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•&amp;#xff0c;æ‚¨å°†èƒ½å¤Ÿæ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚åœ¨ç»™å®šç¤ºä¾‹ä¸­&amp;#xff0c;è¯¥ç®—æ³•å°†æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³è·¯å¾„ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ä¿®æ”¹è¿‡çš„Dijkstraç®—æ³•è®¡ç®—ç»™å®šå›¾ä¸­ä»èŠ‚ç‚¹1åˆ°èŠ‚ç‚¹8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚è¯·ç¡®ä¿æ‚¨ä½¿ç”¨äº†ä¸Šè¿°æä¾›çš„ä¿®æ”¹åçš„dijkstra.cæ–‡ä»¶ä»£ç ã€‚ä½¿ç”¨æ­¤ä¿®æ”¹åçš„ç®—æ³•&amp;#xff0c;æ‚¨å¯ä»¥é€šè¿‡è¿è¡Œmain.cæ–‡ä»¶æ‰¾åˆ°æ‰€éœ€çš„è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;ç°åœ¨&amp;#xff0c;æˆ‘ä»¬å·²ç»ä¿®æ”¹äº†Dijkstraç®—æ³•ä»¥è§£å†³æ‚¨çš„é—®é¢˜&amp;#xff0c;æ‚¨å¯ä»¥è¿è¡Œmain.cæ–‡ä»¶&amp;#xff0c;ä»¥æ‰¾åˆ°ä»ç«™1åˆ°ç«™8çš„æœ€ä½³ä¼ è¾“è·¯å¾„ã€‚åœ¨æ‚¨æä¾›çš„ç¤ºä¾‹ä¸­&amp;#xff0c;è¯¥ç®—æ³•å°†æ‰¾åˆ°å…·æœ‰æœ€ä½³æ¦‚ç‡ä¼ é€’æ¶ˆæ¯çš„è·¯å¾„ã€‚&lt;/p&gt;\n&lt;p&gt;è¯·æ³¨æ„&amp;#xff0c;ä¿®æ”¹åçš„Dijkstraç®—æ³•å¯ä»¥é€‚ç”¨äºæ‚¨çš„é—®é¢˜ã€‚ä½†æ˜¯&amp;#xff0c;åœ¨ç‰¹å®šæƒ…å†µä¸‹&amp;#xff0c;è¿™ç§æ–¹æ³•å¯èƒ½ä¸æ˜¯æœ€æœ‰æ•ˆçš„ã€‚ä¾‹å¦‚&amp;#xff0c;å¯¹äºå…·æœ‰å¤§é‡èŠ‚ç‚¹å’Œè¾¹çš„å¤§å‹ç½‘ç»œ&amp;#xff0c;è¿™ç§æ–¹æ³•å¯èƒ½éœ€è¦æ›´å¤šçš„è®¡ç®—èµ„æºå’Œæ—¶é—´ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹&amp;#xff0c;å¯ä»¥è€ƒè™‘ä½¿ç”¨å…¶ä»–æ›´é«˜æ•ˆçš„ç®—æ³•&amp;#xff0c;å¦‚A*æœç´¢ç®—æ³•æˆ–å…¶ä»–å¯å‘å¼æœç´¢æ–¹æ³•ã€‚&lt;/p&gt;\n&lt;p&gt;å¦‚æœæ‚¨æœ‰å…¶ä»–å…³äºDijkstraç®—æ³•æˆ–å…¶ä»–ç®—æ³•çš„é—®é¢˜&amp;#xff0c;è¯·éšæ—¶æé—®ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["cè¯­è¨€ï¼Œä¿®æ”¹åŸºäºç¬¬ä¸€ä¸ªå›¾çš„æ—§ç®—æ³•ç®—æ³•ä»¥è§£å†³æ–°çš„é—®é¢˜ï¼Œå¹¶å°†æ–°ç®—æ³•ç”¨äºæœ€åä¸€å¼ å›¾", ["æœ‰ä¸€ä¸ªå…³äºDijkstraçš„æ— å‘å›¾ç®—æ³•çš„å®ç°ï¼Œé˜Ÿåˆ—çš„å¤„ç†ç®€å•ï¼Œä½¿ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºğ›©(ğ‘›2),næ˜¯å›¾ä¸­çš„èŠ‚ç‚¹æ•°,å°†è¯¥ç®—æ³•åº”ç”¨äºæ— å‘ç®—æ³•,ä¸‹é¢æ˜¯æœ€åˆä½¿ç”¨çš„åŠ æƒå›¾", "\n", "\n", "ä¿®æ”¹ç®—æ³•ä»¥è§£å†³ä¸‹åˆ—é—®é¢˜ï¼š", "åœ¨ä¸€ä¸ªé“¾è·¯ç½‘ç»œä¸­ï¼Œæœ‰nä¸ªåŸºç«™ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®ƒä»¬ä¹‹é—´ä¼ è¾“æ¶ˆæ¯ï¼Œä¸€ä¸ªç½‘ç»œåŒ…å«nä¸ªäº’ç›¸ä¼ è¾“ä¿¡æ¯çš„ç«™ç‚¹t1, t2, â€¦, tn,ç”±äºå¹²æ‰°ï¼Œæ¶ˆæ¯å¯èƒ½åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­è¢«æŸåã€‚å¯¹äºæ¯ä¸€å¯¹ç«™ç‚¹ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“æ¶ˆæ¯è¢«æ­£ç¡®ä¼ è¾“çš„æ¦‚ç‡ï¼ˆä¸€ä¸ªåœ¨0åˆ°1ä¹‹é—´çš„å®æ•°ï¼‰ã€‚ æˆ‘ä»¬æ‰“ç®—ä»t1ç«™åˆ°tnç«™ã€‚è®¾è®¡ä¸€ç§ç®—æ³•æ¥æ‰¾åˆ°ç«™ç‚¹çš„è·¯å¾„ï¼Œä»¥æœ€ä½³çš„æ¦‚ç‡ä¼ é€’æ¶ˆæ¯.è¯·æ³¨æ„ï¼Œå½“ä¸€ä¸ªæ¶ˆæ¯é€šè¿‡ä¸€ç³»åˆ—ç«™ç‚¹ä¼ è¾“æ—¶ï¼Œæ²¡æœ‰é”™è¯¯åœ°ä¼ é€’å®ƒçš„æ¦‚ç‡æ˜¯åºåˆ—ä¸­æ¦‚ç‡çš„ä¹˜ç§¯ã€‚", "ä¾‹å­ï¼Œåœ¨ä¸‹å›¾ä¸­ï¼Œæœ‰ä¸‰ä¸ªç«™ç‚¹å’Œç»™å®šçš„æ¦‚ç‡", "é€šè¿‡vä»tå‘uä¼ é€’ä¿¡æ¯æ¯”ç›´æ¥ä¼ é€’ä¿¡æ¯æ›´å¥½ï¼Œå› ä¸ºç›´æ¥ä¼ é€’ä¿¡æ¯æ¦‚ç‡ä¸º0.5ï¼Œè€Œé€šè¿‡vçš„æ¦‚ç‡ä¸º0.7 Ã— 0.8 = 0.56 > 0.50", "\n", "å› æ­¤ï¼Œåº”è¯¥ä¿®æ”¹ç»™å®šçš„ç®—æ³•è€Œä¸æ˜¯è¾¹çš„å’Œã€‚æˆ‘ä»¬è€ƒè™‘ä¹˜ç§¯ï¼Œå¹¶é€‰æ‹©æœ€å¤§å€¼ï¼ˆè€Œä¸æ˜¯åƒåŸå§‹ç®—æ³•ä¸­é‚£æ ·çš„æœ€å°å€¼ï¼‰", "\n", "å°†è¯¥ç®—æ³•åº”ç”¨äºä»¥ä¸‹ç½‘ç»œï¼Œå…¶ä¸­è¾¹çš„æƒå€¼ä¸ºæ¦‚ç‡ã€‚è¯¥æ¶ˆæ¯å°†ä»ç«™1ä¼ é€åˆ°ç«™8ï¼Œä»¥æ­¤å›¾ç”¨ä½œæ–°çš„ç®—æ³•ã€‚", "\n", "dijkstra.ä¸éœ€è¦ä¿®æ”¹", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n", "#", "ifndef", " DIJKSTRA_H_INCLUDED", "\n", "#", "define", " DIJKSTRA_H_INCLUDED", "\n\n", "#", "include", " ", "<limits.h>", "\n", "#", "include", " ", "<float.h>", "\n\n", "// Maximum number of vertices", "\n", "// define according to your needs", "\n", "#", "define", " MAXVERTS 1000", "\n\n", "// Nodes are numbered as integers from 1", "\n\n", "// Maximum value in the distance table", "\n", "#", "define", " INF DBL_MAX", "\n\n", "// Defines edge in the adjacency list", "\n", "typedef", " ", "struct", " ", "weightedgnd", " {\n    ", "int", " nodenum;\n    ", "double", " weight;\n    ", "struct", " ", "weightedgnd", "* next;\n} weightededgenode, *pweightededgenode;\n\n", "// Defines the graph", "\n", "typedef", " ", "struct", " ", "weightedg", " {\n    pweightededgenode adj_list[MAXVERTS+", "1", "];\n    ", "int", " pred[MAXVERTS+", "1", "];\n    ", "double", " dist[MAXVERTS+", "1", "];\n    ", "int", " nVertices;\n} weightedgraph;\n\n", "// Initializes graph for breadth-first search", "\n", "void", " ", "init_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Adds new edge (x,y)", "\n", "void", " ", "add_edge", "(weightedgraph* g, ", "int", " x, ", "int", " y, ", "double", " wght)", ";\n\n", "// Actual breadth-first search from node s", "\n", "void", " ", "dijkstra", "(weightedgraph* g, ", "int", " s)", ";\n\n", "// Frees allocated memory", "\n", "void", " ", "delete_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Print a path after search", "\n", "void", " ", "print_path", "(weightedgraph* g, ", "int", " dest)", ";\n\n", "#", "endif", "\n\n", "\n", "main.cï¼Œä¸éœ€è¦ä¿®æ”¹", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n#", "include", " <stdio.h>\n#", "include", " ", "\"dijkstra.h\"", "\n\n", "int", " main", "()", "{\n    weightedgraph g;\n    init", "_graph(&", "g", ",8)", ";\n\n    add", "_edge(&", "g", ",1,2,1)", ";\n    add", "_edge(&", "g", ",1,4,7)", ";\n    add", "_edge(&", "g", ",1,5,3)", ";\n\n    add", "_edge(&", "g", ",2,3,1)", ";\n    add", "_edge(&", "g", ",3,4,2)", ";\n    add", "_edge(&", "g", ",5,6,3)", ";\n\n    add", "_edge(&", "g", ",6,7,3)", ";\n    add", "_edge(&", "g", ",6,8,3)", ";\n\n    ", "// The other graph", "\n    add", "_edge(&", "g", ",2,4,2)", ";\n    add", "_edge(&", "g", ",4,6,2)", ";\n\n    dijkstra(&g,", "1", ");\n\n    printf(", "\"The path from 1 to 8 with cumulative weights:\\n\"", ");\n    print", "_path(&", "g", ",8)", ";\n\n    delete", "_graph(&", "g", ",8)", ";\n\n    return ", "0", ";\n}\n\n", "\n", "dijkstra.cåªå¯¹æœ‰TODOçš„éƒ¨åˆ†è¿›è¡Œä¿®æ”¹ï¼ˆå³ä¸ºvoid init_graphå‡½æ•°çš„TODOéƒ¨åˆ†å’Œvoid dijkstraçš„TODOéƒ¨åˆ†ï¼‰ï¼Œå…·ä½“ä¿®æ”¹è¦æ±‚è¯¦æƒ…è§ä»£ç éƒ¨åˆ†çš„æ³¨é‡Š", "\n", "// DSA Programming task 4.2 - Dijsktra", "\n", "// You work on this file where TODO is located", "\n#include <stdio.h>\n#include <stdlib.h>\n#include ", "\"dijkstra.h\"", "\n\n", "// Initializes graph for Dijkstra", "\nvoid init_graph(weightedgraph* g, int vertices){\n    ", "g", "->", "nVertices = vertices;\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "g", "->", "adj_list[i] = ", "0", ";\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "// TODO! Note the distance", "\n        ", "g", "->", "dist[i] = INF;\n    }\n}\n\n", "// Adds new edge (x,y)", "\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    ", "if", "( x <= g->", "nVertices", " && y <= g->", "nVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        ", "pxy", "->", "nodenum = y;\n        ", "pxy", "->", "next", " = g->", "adj_list[x];\n        ", "pxy", "->", "weight = wght;\n        ", "g", "->", "adj_list[x] = pxy;\n\n        ", "pyx", "->", "nodenum = x;\n        ", "pyx", "->", "next", " = g->", "adj_list[y];\n        ", "pyx", "->", "weight = wght;\n        ", "g", "->", "adj_list[y] = pyx;\n    }\n}\n\n\n", "/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/", "\n\n", "// Dijkstra search from node s", "\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=", "0", ";\n\n    ", "// Initialize graph", "\n    ", "for", "(i=1; i <= g->", "nVertices; i++) {\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "g", "->", "dist[i] = INF;\n        ", "// All vertices in queue", "\n        queue[i] = i;\n    }\n\n    ", "// TODO! Modification should start from here", "\n    ", "//       Note that the propability should be maximized", "\n    ", "//       Chanage names of variables accordingly", "\n    ", "g", "->", "dist[s] = ", "0", ";\n\n    ", "for", "(i=g->", "nVertices; i >= ", "1", "; i--) {\n        ", "// Search for minimum from the queue", "\n        ", "double", " minval = g->", "dist[queue[", "1", "]];\n        int minnode = queue[", "1", "];\n        int minj=", "1", ";\n        ", "for", "(int j = ", "1", "; j <= i; j++) {\n            ", "if", "( g->", "dist[queue[j]] < minval ){\n                ", "minval", " = g->", "dist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        ", "// Switches the minimum to end (out of the queue)", "\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        ", "pweightededgenode", " pedge = g->", "adj_list[minnode];\n\n        ", "// Relax the neighbors", "\n        ", "while", "(pedge != ", "0", "){\n            ", "int", " v = pedge->", "nodenum;\n            ", "if", "(g->", "dist", "[v] > (g->", "dist", "[minnode]+pedge->", "weight))  {\n                ", "g", "->", "dist", "[v] = g->", "dist", "[minnode]+pedge->", "weight;\n                ", "g", "->", "pred[v] = minnode;\n            }\n            ", "pedge", " = pedge->", "next;\n        }\n\n        ", "// DEBUG INFO:", "\n        ", "// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);", "\n    }\n}\n", "//No need to change anyting after this point!", "\n\n", "// Free allocated memory", "\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "pweightededgenode", " pedge = g->", "adj_list[i];\n        pweightededgenode pnext = ", "0", ";\n\n        ", "while", "(pedge != ", "0", ") {\n            ", "pnext", " = pedge->", "next;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n", "// Print a path after search", "\nvoid print_path(weightedgraph* g, int dest){\n    ", "if", "( g->", "pred[dest] != ", "0", "){\n        ", "print_path", "(g, g->", "pred[dest]);\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n    ", "else", " ", "if", "(g->", "dist[dest]==", "0", "){\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n}\n\n\n\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["åœ¨Goä¸­ä½¿ç”¨Gonumè¿›è¡Œå›¾ç®—æ³•", ["\n\n", "I am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a ", "graph package", "  that looks promising to use. ", "\n\n", "My problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. ", "\n\n", "The way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. ", "\n    "]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å•æºå³ä¸€ä¸ªå‡ºå‘ç‚¹åˆ°å…¶ä»–å„ç‚¹çš„è·ç¦»&lt;br /&gt;å¤šæºå³è®¡ç®—æ‰€æœ‰å‡ºå‘ç‚¹åˆ°å„ç‚¹çš„è·ç¦»&lt;br /&gt;ä¸¤ç§ç®—æ³•æœ¬è´¨ä¸Šéƒ½æ˜¯è®¡ç®—ç‚¹åˆ°ç‚¹çš„æœ€çŸ­è·ç¦»&amp;#xff0c;åªæ˜¯ä¸€ä¸ªä¸€æ¬¡åªèƒ½ç®—ä¸€ä¸ªç‚¹&amp;#xff0c;ä¸€ä¸ªä¸€æ¬¡è®¡ç®—å…¨éƒ¨ç‚¹&amp;#xff0c;å¦‚æœå‰è€…åŠ ä¸Šå¾ªç¯å°±å’Œåè€…åœ¨ç»“æœä¸Šæ²¡æœ‰åŒºåˆ«äº†&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["å›¾çš„æœ€çŸ­è·¯ç®—æ³•ä¸­ï¼Œå•æºæœ€çŸ­è·¯é—®é¢˜å’Œå…¨æºæœ€çŸ­è·¯é—®é¢˜ï¼Œè¿™é‡Œçš„å•æºå’Œå…¨æºæ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ", ["åˆå­¦å›¾çš„æœ€çŸ­è·¯ï¼Œå‘ç°ä¹¦ä¸Šæœ‰æåˆ°dijkstraè§£å†³å•æºæœ€çŸ­è·¯é—®é¢˜ï¼ŒFloydè§£å†³å…¨æºæœ€çŸ­è·¯é—®é¢˜ï¼Œä½†æ˜¯ä¹¦ä¸Šæ²¡æœ‰è§£é‡Šè¿™é‡Œçš„å•æºå’Œå…¨æºæ˜¯ä»€ä¹ˆæ„æ€ï¼ŒæŒ‡çš„æ˜¯ä»€ä¹ˆï¼Ÿ"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;æŒ‰ç…§ä½ è¿™ä¸ªmatlabä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;function [min,path]&amp;#61;dijkstra(w,start,terminal)\n%% å‡½æ•°ä»‹ç»\n%è¾“å…¥å˜é‡wä¸ºæ‰€æ±‚å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µ&amp;#xff0c;startã€terminalåˆ†åˆ«ä¸ºè·¯å¾„çš„èµ·ç‚¹å’Œç»ˆç‚¹çš„ç¼–å·ã€‚\n%è¿”å›pathä¸ºä»startåˆ°termialçš„æœ€çŸ­è·¯å¾„ä»¥åŠé•¿åº¦min\n&lt;span class=\"hljs-attribute\"&gt;n&lt;/span&gt;&amp;#61;size(w,1); label(start)&amp;#61;0; f(start)&amp;#61;start;\n%nä¸ºæ‰€æ±‚å›¾çš„é¡¶ç‚¹ä¸ªæ•°&amp;#xff0c;labelå­˜æ”¾åˆ°å„ç‚¹çš„æœ€çŸ­è·¯å¾„&amp;#xff0c;f(v)è¡¨ç¤ºvçš„çˆ¶é¡¶ç‚¹ç”¨æ¥è¿˜åŸè·¯å¾„\n%åˆå§‹åŒ–å°†é™¤äº†startä»¥å¤–çš„é¡¶ç‚¹labelå‡è®¾ç½®ä¸ºæ— ç©·å¤§\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; i~&amp;#61;start\nlabel(i)&amp;#61;inf;\nend\nend\n%sæ•°ç»„å­˜æ”¾å·²ç»æœå¥½çš„é¡¶ç‚¹é›†&amp;#xff0c;åˆå§‹åŒ–åªæœ‰start\ns(1)&amp;#61;start; &lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;start;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; length(s)&amp;lt;n\n%éå†ä¸€éé¡¶ç‚¹&amp;#xff0c;å°†ä¸åœ¨é¡¶ç‚¹é›†ä¸­çš„é¡¶ç‚¹é€‰å‡ºæ¥è¿›è¡Œä¸‹é¢çš„&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;åˆ¤å®š\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n%åˆ¤æ–­æ˜¯å¦æœ‰ä¸­ç»§é¡¶ç‚¹ä½¿å¾—å®ƒä»¬ä¹‹é—´çš„è·ç¦»æ›´çŸ­&amp;#xff0c;å¦‚æœæœ‰çš„è¯æ›´æ–°è·ç¦»å¹¶æ›´æ–°å‰é©±ç»“ç‚¹\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; label(v)&amp;gt;(label(u)&amp;#43;w(u,v))\nlabel(v)&amp;#61;(label(u)&amp;#43;w(u,v)); f(v)&amp;#61;u;\nend\nend\nend\n&lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;inf;\n%åŒä¸Šå†æ¬¡è¿›è¡Œéå†&amp;#xff0c;æ‰¾åˆ°ç›®å‰æœ€çŸ­çš„è·¯å¾„é¡¶ç‚¹v1&amp;#xff0c;æ”¾å…¥é¡¶ç‚¹é›†å¹¶æ”¹å˜uçš„å€¼\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; k&amp;gt;label(v)\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;label(v); &lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;v;\nend\nend\nend\ns(length(s)&amp;#43;1)&amp;#61;v1;\n&lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;v1;\nend\n\n&lt;span class=\"hljs-attribute\"&gt;min&lt;/span&gt;&amp;#61;label(terminal); path(1)&amp;#61;terminal;\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1;\n\n%æŒ‰å€’åºç»“æœæ¨å‡ºæœ€çŸ­è·¯å¾„\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; path(i)~&amp;#61;start\npath(i&amp;#43;1)&amp;#61;f(path(i));\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;i&amp;#43;1 ;\nend\npath(i)&amp;#61;start;\n&lt;span class=\"hljs-attribute\"&gt;L&lt;/span&gt;&amp;#61;length(path);\n%ç¿»è½¬å¾—åˆ°æœ€çŸ­è·¯å¾„\n&lt;span class=\"hljs-attribute\"&gt;path&lt;/span&gt;&amp;#61;path(L:-1:1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;å¹¶æ ¹æ®ä½ ç»™çš„ç‚¹&amp;#xff0c;æˆ‘å†™äº†ä¸ªå‘½ä»¤çª—å£ä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;clc&lt;/span&gt;,clear\n&lt;span class=\"hljs-attribute\"&gt;w&lt;/span&gt;&amp;#61;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;inf,inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n&lt;span class=\"hljs-attribute\"&gt;start&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-attribute\"&gt;terminal&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;&lt;span class=\"hljs-meta\"&gt;\n[min,path]&amp;#61;dijkstra(w,start,terminal);\nmin,path&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;è¿è¡Œå¾—å‡ºçš„ç»“æœæ˜¯&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/764607253656172.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;å¹¶æ²¡æœ‰äº§ç”ŸæŠ¥é”™ã€‚&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["ä¸€ä¸ªé—®é¢˜ç®—æ³•çš„ç¨‹åºå‡ºç°é”™è¯¯è¿è¡Œä¸å‡ºæ¥", ["function [min,path]=dijkstra(w,start,terminal)", "%è¾“å…¥å˜é‡wä¸ºæ‰€æ±‚å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µï¼Œstartã€terminalåˆ†åˆ«ä¸ºè·¯å¾„çš„èµ·ç‚¹å’Œç»ˆç‚¹çš„ç¼–å·ã€‚", "%è¿”å›pathä¸ºä»startåˆ°termialçš„æœ€çŸ­è·¯å¾„ä»¥åŠé•¿åº¦min", "\n", "n=size(w,1); label(start)=0; f(start)=start;", "%nä¸ºæ‰€æ±‚å›¾çš„é¡¶ç‚¹ä¸ªæ•°ï¼Œlabelå­˜æ”¾åˆ°å„ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œf(v)è¡¨ç¤ºvçš„çˆ¶é¡¶ç‚¹ç”¨æ¥è¿˜åŸè·¯å¾„", "\n", "%åˆå§‹åŒ–å°†é™¤äº†startä»¥å¤–çš„é¡¶ç‚¹labelå‡è®¾ç½®ä¸ºæ— ç©·å¤§", "for i=1:n", "    if i~=start", "       label(i)=inf;", "    end", "end", "\n", "%sæ•°ç»„å­˜æ”¾å·²ç»æœå¥½çš„é¡¶ç‚¹é›†ï¼Œåˆå§‹åŒ–åªæœ‰start", "s(1)=start; u=start;", "while length(s)<n", "    %éå†ä¸€éé¡¶ç‚¹ï¼Œå°†ä¸åœ¨é¡¶ç‚¹é›†ä¸­çš„é¡¶ç‚¹é€‰å‡ºæ¥è¿›è¡Œä¸‹é¢çš„ifåˆ¤å®š", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        %åˆ¤æ–­æ˜¯å¦æœ‰ä¸­ç»§é¡¶ç‚¹ä½¿å¾—å®ƒä»¬ä¹‹é—´çš„è·ç¦»æ›´çŸ­ï¼Œå¦‚æœæœ‰çš„è¯æ›´æ–°è·ç¦»å¹¶æ›´æ–°å‰é©±ç»“ç‚¹", "        if ins==0", "            v=i;", "            if label(v)>(label(u)+w(u,v))", "                label(v)=(label(u)+w(u,v)); f(v)=u;", "            end", "        end", "    end", "    v1=0;", "    k=inf;", "    %åŒä¸Šå†æ¬¡è¿›è¡Œéå†ï¼Œæ‰¾åˆ°ç›®å‰æœ€çŸ­çš„è·¯å¾„é¡¶ç‚¹v1ï¼Œæ”¾å…¥é¡¶ç‚¹é›†å¹¶æ”¹å˜uçš„å€¼", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        if ins==0", "            v=i;", "            if k>label(v)", "                k=label(v);  v1=v;", "            end", "        end", "    end", "    s(length(s)+1)=v1;", "    u=v1;", "end", "\n", "min=label(terminal); path(1)=terminal;", "i=1; ", "\n", "%æŒ‰å€’åºç»“æœæ¨å‡ºæœ€çŸ­è·¯å¾„", "while path(i)~=start", "    path(i+1)=f(path(i));", "    i=i+1 ;", "end", "path(i)=start;", "L=length(path);", "%ç¿»è½¬å¾—åˆ°æœ€çŸ­è·¯å¾„", "path=path(L:-1:1);", "\n", "\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["ROSåœ¨è¿›è¡Œå¯¼èˆªæ—¶ï¼Œå‡ºç°ä¸€ç›´ä¸‹å‘è§’é€Ÿåº¦å’Œçº¿é€Ÿåº¦ä¸º0çš„æƒ…å†µ", ["\n\n", "å¦‚å›¾æ‰€ç¤ºï¼Œåœ¨å­˜åœ¨è·¯å¾„è§„åˆ’çš„æƒ…å†µä¸‹ï¼Œä¸€ç›´ä¸‹å‘çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦ä¸º0 çš„æƒ…å†µã€‚", "\n\n", "\n", "å±€éƒ¨è§„åˆ’é‡‡ç”¨çš„æ˜¯DWAç®—æ³•", "\n", "å…¨å±€è§„åˆ’é‡‡ç”¨çš„æ˜¯Dijkstra.", "\n", "è†¨èƒ€ç³»æ•°è®¾ç½®æ˜¯15å˜ç±³ã€‚\nå°è½¦æ”¾ç½®åœ¨ä¸€ä¸ªç©ºæ—·åŒºåŸŸ", "\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;å¹²äº†å‡ å¹´äº†&amp;#xff0c;ä½ è¯´çš„è¿™äº›æˆ‘ä¸€ä¸ªéƒ½ä¸ä¼š&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["å†™é€»è¾‘ä»£ç è¦å¾ˆé•¿çš„æ—¶é—´é€‚åˆèµ°åç«¯å—ï¼Ÿ", ["(åˆšå­¦ä¹ æ–°ç®—æ³•åæ•²ä»£ç )", "å“ˆå¤«æ›¼åŸºæœ¬å®ç°ç¼–ç ç”¨äº†ä¸¤å¤©(è¯‘ç æ²¡å†™)", "æ£‹ç›˜è¦†ç›–ç”¨äº†6ä¸ªå°æ—¶", "dijkstraç”¨äº†6ä¸ªå°æ—¶", "èƒŒåŒ…å›æº¯ç”¨äº†4ä¸ªå°æ—¶", "äºŒå‰æ ‘åŸºæœ¬æ“ä½œåŒ…æ‹¬ç»“ç‚¹æ•°ï¼Œåº¦ä¸º1ç»“ç‚¹æ•°ç­‰å®ç°ç”¨äº†8ä¸ªé’Ÿ(é€’å½’)", "\n", "å°±æ„Ÿè§‰è‡ªå·±æ•²é€»è¾‘ä»£ç å¥½æ…¢ï¼Œé€‚åˆå¹²åç«¯å—ï¼Œç°åœ¨æœ‰ç‚¹æƒ³èµ°å‰ç«¯çš„æƒ³æ³•"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;é¦–å…ˆ&amp;#xff0c;æ‚¨éœ€è¦å®‰è£… NetworkX å’Œ matplotlib åº“æ¥ç»˜åˆ¶å›¾åƒã€‚ç„¶å&amp;#xff0c;å¯ä»¥ä½¿ç”¨ NetworkX åº“ä¸­çš„ draw å‡½æ•°æ¥ç»˜åˆ¶å›¾ã€‚å°†å›¾ç»˜åˆ¶åˆ°ç”»å¸ƒä¸Š&amp;#xff0c;ç„¶åå°†ç”»å¸ƒæ”¾ç½®åœ¨æ‚¨çš„ç”¨æˆ·ç•Œé¢ä¸­çš„ç›¸åº”ä½ç½®å³å¯ã€‚&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­&amp;#xff0c;å…¶ä¸­ä½¿ç”¨ Tkinter åº“åˆ›å»ºäº†ä¸€ä¸ªç®€å•çš„ç”¨æˆ·ç•Œé¢&amp;#xff0c;å¹¶åœ¨å…¶ä¸­ç»˜åˆ¶äº†ä¸€ä¸ªæ— å‘å›¾&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;import tkinter as tk\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n&lt;span class=\"hljs-comment\"&gt;# åˆ›å»ºä¸€ä¸ªçª—å£&lt;/span&gt;\nwindow &amp;#61; tk.Tk()\n\n&lt;span class=\"hljs-comment\"&gt;# åˆ›å»ºä¸€ä¸ªç”»å¸ƒ&lt;/span&gt;\ncanvas &amp;#61; tk.Canvas(window, &lt;span class=\"hljs-attribute\"&gt;width&lt;/span&gt;&amp;#61;600, &lt;span class=\"hljs-attribute\"&gt;height&lt;/span&gt;&amp;#61;600)\ncanvas.pack()\n\n&lt;span class=\"hljs-comment\"&gt;# åˆ›å»ºä¸€ä¸ªæ— å‘å›¾&lt;/span&gt;\nG &amp;#61; nx.Graph()\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;1)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;7)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;3)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;5)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;9)\n\n&lt;span class=\"hljs-comment\"&gt;# ç»˜åˆ¶å›¾åƒ&lt;/span&gt;\npos &amp;#61; nx.spring_layout(G)  # ä½¿ç”¨ FR ç®—æ³•æ’åˆ—èŠ‚ç‚¹\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\nlabels &amp;#61; nx.get_edge_attributes(G, &lt;span class=\"hljs-string\"&gt;&amp;#39;weight&amp;#39;&lt;/span&gt;)\nnx.draw_networkx_edge_labels(G, pos, &lt;span class=\"hljs-attribute\"&gt;edge_labels&lt;/span&gt;&amp;#61;labels, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\n\n&lt;span class=\"hljs-comment\"&gt;# æ˜¾ç¤ºçª—å£&lt;/span&gt;\nwindow.mainloop()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ä¸Šè¿°ä»£ç ä½¿ç”¨äº† NetworkX åº“ä¸­çš„ spring_layout å‡½æ•°æ¥æ’åˆ¶èŠ‚ç‚¹çš„ä½ç½®&amp;#xff0c;ç„¶åä½¿ç”¨ draw å‡½æ•°ç»˜åˆ¶å›¾åƒã€‚è¿˜ä½¿ç”¨äº† get_edge_attributes å‡½æ•°å’Œ draw_networkx_edge_labels å‡½æ•°æ¥ç»˜åˆ¶è¾¹çš„æ ‡ç­¾ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["å¦‚ä½•è®©æ— å‘å›¾æ˜¾ç¤ºåˆ°ç”¨æˆ·ç•Œé¢é‡Œ", ["\ndef main():\n            \n        \n       \n\n", "# é—®é¢˜ 2ï¼šæ— å‘å›¾çš„æœ€çŸ­è·¯é—®é¢˜ï¼ˆå¸å®ˆå¥ï¼Œæ•°å­¦å»ºæ¨¡ç®—æ³•ä¸åº”ç”¨ï¼ŒP43ï¼Œä¾‹4.3ï¼‰", "\n             G2 = nx.Graph()  # åˆ›å»ºï¼šç©ºçš„ æœ‰å‘å›¾\n\n             G2.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)  # æ·»åŠ  å¸¦æƒè¾¹ï¼Œweightè¡¨ç¤ºè¾¹æƒ\n             G2.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n             G2.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n             G2.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n             G2.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n             G2.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n             G2.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# ä¸¤ä¸ªæŒ‡å®šé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­åŠ æƒè·¯å¾„", "\n             ", "source", "=nameEntry3.get()\n             ", "target", "=nameEntry4.get()\n             minWPath_v1_v5 = nx.dijkstra_path(G2, source, target)  # é¡¶ç‚¹ 0 åˆ° é¡¶ç‚¹ 3 çš„æœ€çŸ­åŠ æƒè·¯å¾„\n             return minWPath_v1_v5\n             # ä¸¤ä¸ªæŒ‡å®šé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­åŠ æƒè·¯å¾„çš„é•¿åº¦\n             lMinWPath_v1_v5 = nx.dijkstra_path_length(G2, source, target)  # æœ€çŸ­åŠ æƒè·¯å¾„é•¿åº¦\n             return lMinWPath_v1_v5\n             plt.clf()\n             pos = nx.spring_layout(G2)  # ç”¨ FRç®—æ³•æ’åˆ—èŠ‚ç‚¹\n             nx.draw(G2, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5)\n             labels = nx.get_edge_attributes(G2, ", "'weight'", ")\n             nx.draw_networkx_edge_labels(G2, pos, ", "edge_labels", "=labels)\n              # plt.show()\n\n\n             edgeList = []\n             ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n             nx.draw_networkx_edges(G2, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4) \n             # è®¾ç½®è¾¹çš„é¢œè‰²\n             \n             plt.savefig(", "'path'", " +", "'.jpg'", ")\n             filename = ", "\".\\path.jpg\"", "\n             image = Image.open(filename)\n             photo = ImageTk.PhotoImage(image)\n             canvas.create_image(450,250,image = photo)\n             canvas.update()\n             time.sleep(sleep_time)\n      \n      frame_mid = Frame(", "width", "=800,height=100,bg='white') \n      frame_mid.grid(", "row", "=8,column=10,rowspan=6,columnspan=2,padx=4, ", "pady", "=5)\n      \n      canvas = Canvas(frame_mid,width = 800,height = 600,bg = ", "'#FFCCCC'", ")#ç”»æ¿\n      \n      canvas.grid()\n\n\n\n                \n\n            \n      def main2():\n            \n               \n               EditText.insert(tkinter.END,main())\n             \n      ", "EditText", "=tkinter.Text(window2,width=15,height=5)\n      EditText.grid(", "row", "=8,column=8)\n      def main3():\n          main()\n      \n        \n     \n      ", "q", "=tkinter.Button(window2,text=\"ç¡®å®š\", font=(", "'å®‹ä½“'", ",15),", "command", "=main2)\n      q.grid(", "row", "=7,column=6)\n      ", "q", "=tkinter.Button(window2,text=\"ç¡®å®š\", font=(", "'å®‹ä½“'", ",15),", "command", "=main3)\n      q.grid(", "row", "=7,column=8\n", "\n", "ä¸ºä»€ä¹ˆæˆ‘ç”¨networkxå’Œcanvasç”»çš„å›¾æ˜¾ç¤ºä¸åˆ°tkinteré‡Œ", "è¯¥å¦‚ä½•è®©å®ƒæ˜¾ç¤ºå‘¢"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;ä½ å¯ä»¥å°†ç”»å¸ƒä½œä¸ºç»˜å›¾å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°&amp;#xff0c;å¦‚&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;nx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;canvas&lt;/span&gt;&amp;#61;canvas)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;æˆ–è€…&amp;#xff0c;å¯ä»¥ä½¿ç”¨ FigureCanvasTkAgg å°†ç”»å¸ƒç»‘å®šåˆ° tkinter çª—å£ä¸­&amp;#xff0c;ä¾‹å¦‚&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfig &amp;#61; plt.figure(figsize&amp;#61;(5, 5))\ncanvas &amp;#61; FigureCanvasTkAgg(fig, &lt;span class=\"hljs-attribute\"&gt;master&lt;/span&gt;&amp;#61;window2)\ncanvas.get_tk_widget().grid(&lt;span class=\"hljs-attribute\"&gt;row&lt;/span&gt;&amp;#61;8, &lt;span class=\"hljs-attribute\"&gt;column&lt;/span&gt;&amp;#61;10)\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;fig&lt;/span&gt;&amp;#61;fig)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;åœ¨è¿™ç§æƒ…å†µä¸‹&amp;#xff0c;åº”è¯¥ä½¿ç”¨ fig è€Œä¸æ˜¯ canvas ä½œä¸ºç»˜å›¾å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚&lt;/p&gt;\n&lt;p&gt;è¯·æ³¨æ„&amp;#xff0c;å¦‚æœä½¿ç”¨ FigureCanvasTkAgg&amp;#xff0c;åˆ™éœ€è¦å¯¼å…¥ matplotlib.pyplot æ¨¡å—&amp;#xff0c;å¹¶ä½¿ç”¨ plt.figure åˆ›å»ºä¸€ä¸ªæ–°å›¾è¡¨ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ€ä¹ˆè®©æˆ‘ç”»çš„æ— å‘å›¾æ˜¾ç¤ºåœ¨canvasç”»å¸ƒä¸Š", ["\ndef main3():\n          canvas = tkinter.Canvas(window2, ", "width", "=50, ", "height", "=50)\n          canvas.grid(", "row", "=8,column=10)\n\n", "# åˆ›å»ºä¸€ä¸ªæ— å‘å›¾", "\n          G = nx.Graph()\n          G.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)\n          G.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n          G.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n          G.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n          G.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n          G.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n          G.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# ç»˜åˆ¶å›¾åƒ", "\n          ", "source", "=nameEntry3.get()\n          ", "target", "=nameEntry4.get()\n \n          minWPath_v1_v5 = nx.dijkstra_path(G, source, target)  # é¡¶ç‚¹ 0 åˆ° é¡¶ç‚¹ 3 çš„æœ€çŸ­åŠ æƒè·¯å¾„\n                \n", "# ä¸¤ä¸ªæŒ‡å®šé¡¶ç‚¹ä¹‹é—´çš„æœ€çŸ­åŠ æƒè·¯å¾„çš„é•¿åº¦", "\n          \n          pos = nx.spring_layout(G)  # ä½¿ç”¨ FR ç®—æ³•æ’åˆ—èŠ‚ç‚¹\n          nx.draw(G, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5,on=canvas)\n          labels = nx.get_edge_attributes(G, ", "'weight'", ")\n          nx.draw_networkx_edge_labels(G, pos, ", "edge_labels", "=labels)\n          edgeList = []\n          ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                  edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n                  nx.draw_networkx_edges(G, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4,on=canvas)\n\n            \n          \n      \n", "\n", "æ€ä¹ˆè®©æˆ‘ç”»çš„æ— å‘å›¾æ˜¾ç¤ºåœ¨canvasç”»å¸ƒä¸Š"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;shortest_path(G[, source, target, weight,...]) è®¡ç®—å›¾ä¸­çš„æœ€çŸ­è·¯å¾„&amp;#xff0c;å¯ä»¥ç”¨äºæ— å‘å›¾æˆ–æœ‰å‘å›¾&lt;/p&gt;\n&lt;p&gt;dijkstra_path(G, source, target[, weight]) è®¡ç®—ä»æºåˆ°ç›®æ ‡çš„æœ€çŸ­åŠ æƒè·¯å¾„&amp;#xff0c;ç”¨äºæœ‰æƒå›¾&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["NetworkX æœ‰æƒæ— å‘å›¾è®¡ç®—æœ€çŸ­è·¯å¾„", ["NetworkX æœ‰æƒæ— å‘å›¾è®¡ç®—æœ€çŸ­è·¯å¾„æ—¶å‡½æ•°shortest_path(G[, source, target, weight,â€¦])å’Œå‡½æ•°dijkstra_path(G, source, target[, weight])æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ", "\n", "\n", "å‚è€ƒé“¾æ¥ï¼š", "https://blog.csdn.net/youcans/article/details/116999881?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167210396716800213045638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167210396716800213045638&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116999881-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control1&utm_term=networkx%20shortest_path&spm=1018.2226.3001.4187"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;è¿™æ˜¯ä¸€ä¸ªå®ç°è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•çš„ä»£ç &amp;#xff0c;ç”¨äºæ±‚è§£å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚è¯¥ç®—æ³•æ˜¯ä¸€ç§è´ªå¿ƒç®—æ³•&amp;#xff0c;æ¯æ¬¡æ±‚è§£çš„æ—¶å€™éƒ½ä¼šæ‰¾åˆ°å½“å‰èƒ½åˆ°è¾¾çš„ç‚¹ä¸­è·ç¦»èµ·ç‚¹æœ€è¿‘çš„ç‚¹&amp;#xff0c;å¹¶ä»è¯¥ç‚¹å¼€å§‹æœç´¢ä¸‹ä¸€æ­¥èƒ½åˆ°è¾¾çš„ç‚¹&amp;#xff0c;ç›´åˆ°åˆ°è¾¾ç»ˆç‚¹ã€‚&lt;/p&gt;\n&lt;p&gt;å…·ä½“æ¥è¯´&amp;#xff0c;ä»£ç ä¸­ä½¿ç”¨äº†ä¸‰ä¸ªæ ˆ&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1ã€stack æ ˆç”¨æ¥å­˜å‚¨æœç´¢è·¯å¾„ä¸­çš„ç‚¹ã€‚&lt;br /&gt;2ã€stackdata æ ˆç”¨æ¥å­˜å‚¨æ¯æ¡è¾¹çš„è·ç¦»ã€‚&lt;br /&gt;3ã€stackfindlj æ ˆç”¨æ¥å­˜å‚¨æ‰€æœ‰å¯èƒ½çš„è·¯å¾„&amp;#xff0c;å…¶ä¸­çš„æ¯ä¸€è¡Œéƒ½æ˜¯ä¸€æ¡è·¯å¾„&amp;#xff0c;ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºèµ·ç‚¹&amp;#xff0c;å…¶ä½™çš„å…ƒç´ ä¸ºè·¯å¾„ä¸­çš„æ¯ä¸ªç‚¹ã€‚&lt;br /&gt;é¦–å…ˆ&amp;#xff0c;ä»èµ·ç‚¹å¼€å§‹æœç´¢&amp;#xff0c;å¦‚æœæ‰¾åˆ°äº†ä¸€æ¡è¾¹ä¸”è¿™æ¡è¾¹è¿˜æ²¡æœ‰è®¿é—®è¿‡&amp;#xff0c;å°±å°†è¿™æ¡è¾¹åŠ å…¥è·¯å¾„ä¸­&amp;#xff0c;å¹¶å°†è¿™æ¡è¾¹çš„è·ç¦»åŠ å…¥è·¯å¾„è·ç¦»ä¸­ã€‚ç„¶åä»è¿™æ¡è¾¹çš„ç»ˆç‚¹å¼€å§‹ç»§ç»­æœç´¢&amp;#xff0c;å¦‚æœèƒ½æ‰¾åˆ°ä¸€æ¡è¾¹ä¸”è¿™æ¡è¾¹è¿˜æ²¡æœ‰è®¿é—®è¿‡&amp;#xff0c;å°±å°†è¿™æ¡è¾¹åŠ å…¥è·¯å¾„ä¸­&amp;#xff0c;å¹¶å°†è¿™æ¡è¾¹çš„è·ç¦»åŠ å…¥è·¯å¾„è·ç¦»ä¸­ã€‚é‡å¤è¿™ä¸ªè¿‡ç¨‹ç›´åˆ°åˆ°è¾¾ç»ˆç‚¹&amp;#xff0c;æˆ–è€…æ‰¾ä¸åˆ°æ–°çš„è¾¹å¯ä»¥åŠ å…¥è·¯å¾„ä¸­ã€‚&lt;/p&gt;\n&lt;p&gt;æ‰€æœ‰çš„è·¯å¾„è¢«ä¿å­˜åœ¨ stackfindlj ä¸­&amp;#xff0c;å…¶ä¸­çš„æ¯ä¸€è¡Œéƒ½æ˜¯ä¸€æ¡è·¯å¾„ã€‚æ¥ä¸‹æ¥&amp;#xff0c;éå†æ‰€æœ‰çš„è·¯å¾„&amp;#xff0c;æ‰¾åˆ°è·¯å¾„è·ç¦»æœ€å°çš„è·¯å¾„ã€‚å°†è¿™æ¡æœ€çŸ­è·¯å¾„çš„ä¿¡æ¯å¤åˆ¶åˆ°ä¸€ä¸ªåä¸º temp çš„ç»“æ„ä½“ä¸­&amp;#xff0c;å¹¶è¿”å›è¿™ä¸ªç»“æ„ä½“ã€‚&lt;/p&gt;\n&lt;p&gt;è¿™ä¸ªç»“æ„ä½“ä¸­åŒ…å«ä¸¤ä¸ªä¿¡æ¯&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1ã€stack æ•°ç»„ç”¨æ¥å­˜å‚¨æœ€çŸ­è·¯å¾„ä¸­çš„ç‚¹ã€‚&lt;br /&gt;2ã€jl å˜é‡ç”¨æ¥å­˜å‚¨æœ€çŸ­è·¯å¾„çš„è·ç¦»ã€‚&lt;/p&gt;\n&lt;p&gt;å¦‚æœæƒ³è¾“å‡ºæœ€çŸ­è·¯å¾„çš„é€”å¾„ç‚¹ä¿¡æ¯&amp;#xff0c;å¯ä»¥åœ¨è¾“å‡ºè·¯å¾„è·ç¦»ä¹‹åæ·»åŠ ä»¥ä¸‹ä»£ç &amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;æœ€çŸ­è·¯å¾„ä¸º&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp.stack[i] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, temp.stack[i]);\n  }\n}\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;è¿™æ®µä»£ç ä¼šä¾æ¬¡è¾“å‡ºæœ€çŸ­è·¯å¾„ä¸­çš„æ‰€æœ‰ç‚¹ã€‚&lt;br /&gt;ä»…ä¾›å‚è€ƒ&amp;#xff0c;æœ›é‡‡çº³&amp;#xff0c;è°¢è°¢ã€‚&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ„é€ äº†ä¸€ä¸ªè¿ªæ°æ–¯ç‰¹æ‹‰å‡½æ•°ï¼Œä½†æ˜¯ä¸ä¼šå¾—å‡ºæœ€çŸ­è·¯å¾„çš„é€”å¾„ç‚¹ä¿¡æ¯ï¼Œéœ€è¦æ›´è¯¦ç»†çš„æ³¨é‡Š", ["é—®é¢˜é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯ æ„é€ äº†ä¸€ä¸ªè®¡ç®—å‡½æ•°ï¼Œå¦‚ä½•å¾—åˆ°æœ€çŸ­è·¯å¾„çš„ç‚¹çš„ä¿¡æ¯ä»¥åŠéœ€è¦æ›´è¯¦ç»†çš„æ³¨é‡Š", "\n", "é‡åˆ°çš„ç°è±¡å’Œå‘ç”ŸèƒŒæ™¯ï¼Œè¯·å†™å‡ºç¬¬ä¸€ä¸ªé”™è¯¯ä¿¡æ¯", "\n", "ç”¨ä»£ç å—åŠŸèƒ½æ’å…¥ä»£ç ï¼Œè¯·å‹¿ç²˜è´´æˆªå›¾ã€‚ ä¸ç”¨ä»£ç å—å›ç­”ç‡ä¸‹é™ 50%", "\n", "struct ", "MyStack", "  \n{\n    int stack[", "50", "];//æ ˆ\n    int jl;//è·ç¦»\n};\n//è¿ªæ°æ–¯ç‰¹æ‹‰ç®—æ³•\n", "MyStack", " ", "Dijkstra", "(map ", "Map", ", int d, int e)//dè®¾ä¸ºèµ·ç‚¹,eè®¾ä¸ºç»ˆç‚¹\n{\n    int stack[", "50", "] = { ", "0", " }, id1 = ", "0", ";\n    int stackdata[", "50", "] = { ", "0", " }, id2 = ", "0", ";\n    int stackfindlj[", "50", "][", "50", "] = { ", "0", " }, id3 = ", "0", ";//è·¯å¾„ä¿å­˜\n    int stackfindjl[", "50", "] = { ", "0", " };//è·ç¦»ä¿å­˜\n    int isfind = ", "0", ";\n    for (int i = d; i < d + ", "1", "; i++)\n    {\n        for (int j = i; j < ", "12", "; j++)\n        {\n            int edge[", "12", "][", "12", "] = { ", "0", " };//è¾…åŠ©åœ°å›¾\n            if (", "Map", ".edge[i][j] != ", "100", " && ", "Map", ".edge[i][j] != ", "0", " && edge[i][j] == ", "0", ")\n            {\n                stack[id1++] = j;\n                stackdata[id2++] = ", "Map", ".edge[i][j];//è¾¹çš„è·ç¦»\n                edge[i][j] = ", "1", ";//è¾…åŠ©åœ°å›¾\n                while (id1)\n                {\n                    for (int k = stack[id1 - ", "1", "]; k < ", "12", "; k++)\n                    {\n                        if (", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "100", " && ", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "0", " && edge[stack[id1 - ", "1", "]][k] == ", "0", ")//å¼€å§‹æœå¯»è·¯å¾„\n                        {\n                            edge[stack[id1 - ", "1", "]][k] = ", "1", ";\n                            stackdata[id2++] = ", "Map", ".edge[stack[id1 - ", "1", "]][k];\n                            stack[id1++] = k;\n                            if (k == e)//åˆ°è¾¾äº†ç»ˆç‚¹\n                                isfind = ", "1", ";\n                            break;\n                        }\n                        if (k == ", "11", ")\n                        {\n                            id1--; id2--;\n                        }\n                    }\n                    if (isfind == ", "1", ")\n                    {\n                        stackfindlj[id3][", "0", "] = i + ", "1", ";\n                        for (int k = ", "0", "; k < id1; k++)\n                        {\n                            stackfindlj[id3][k + ", "1", "] = stack[k] + ", "1", ";\n                            stackfindjl[id3] += stackdata[k];\n                        }\n                        id3++;\n                        isfind = ", "0", ";\n                    }\n                }\n            }\n        }\n    }\n    int min = stackfindjl[", "0", "], minidx = ", "0", ";\n    for (int i = ", "0", "; i < id3; i++)\n    {\n        if (min > stackfindjl[i])\n        {\n            min = stackfindjl[i];\n            minidx = i;\n        }\n    }\n    ", "MyStack", " temp = { ", "0", " };\n    memcpy(&temp.stack, &stackfindlj[minidx], sizeof(int) * ", "50", ");//å°†å¾—åˆ°çš„æœ€çŸ­è·¯å¾„å¤åˆ¶åˆ°ç»“æ„ä½“çš„æ•°ç»„ä¹‹ä¸­\n    temp.jl = min;//å°†å¾—åˆ°çš„æœ€çŸ­è·ç¦»èµ‹å€¼åˆ°ç»“æ„ä½“çš„è·ç¦»ä¸­\n    printf(", "\"æœ€çŸ­è·¯å¾„è·ç¦»ä¸ºï¼š%d\\n\"", ", temp.jl);\n    return temp;\n\n", "\n", "è¿è¡Œç»“æœåŠè¯¦ç»†æŠ¥é”™å†…å®¹", "\n", "åªä¼šè¾“å‡ºæœ€çŸ­è·ç¦»", "\n", "æˆ‘çš„è§£ç­”æ€è·¯å’Œå°è¯•è¿‡çš„æ–¹æ³•ï¼Œä¸å†™è‡ªå·±æ€è·¯çš„ï¼Œå›ç­”ç‡ä¸‹é™ 60%", "\n", "è¿ªæ°æ–¯ç‰¹æ‹‰å‡½æ•°", "\n", "æˆ‘æƒ³è¦è¾¾åˆ°çš„ç»“æœï¼Œå¦‚æœä½ éœ€è¦å¿«é€Ÿå›ç­”ï¼Œè¯·å°è¯• â€œä»˜è´¹æ‚¬èµâ€"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;åº”è¯¥æ˜¯æ²¡æœ‰visitedæ•°ç»„æ ‡è®°çš„é—®é¢˜&amp;#xff0c;å­˜è¾¹æ˜¯å­˜åŒå‘è¾¹&amp;#xff0c;éœ€è¦æ ‡è®°visited&amp;#xff08;æœ‰æ—¶ä¹Ÿå«used&amp;#xff09;æ•°ç»„è¿›è¡Œæ ‡è®°è¿™ä¸ªç‚¹å·²ç»åˆ°è¾¾è¿‡äº†&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["æ´›è°·P1462 dijçš„é—®é¢˜", ["https://www.luogu.com.cn/problem/P1462", "\n", "https://www.luogu.com.cn/record/78581018", "\n", "åªå¯¹äº†3ä¸ªç‚¹ï¼Œéƒ½æ˜¯æ— è§£ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´dijå¯èƒ½ä¸å¯¹", "\n", "#", "include", "<bits/stdc++.h>", "\n", "#", "define", " INF 0x3f3f3f3f", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", " MAXN=", "10008", ";\n", "typedef", " pair<", "int", ",", "int", "> pi;\npriority_queue< pi,vector<pi>,greater<pi> > q;\n", "int", " n,m,b;\n", "int", " f[MAXN],dis[MAXN];\n", "struct", " ", "node", "{\n    ", "int", " v,w;\n};\nvector<node> a[MAXN];\n", "bool", " vis[MAXN];\n", "int", " l=INT_MAX,r=INT_MIN,mid;\n", "bool", " ", "dijkstra", "(", "int", " st)", "{\n    ", "memset", "(vis,", "0", ",", "sizeof", "(vis));\n    ", "memset", "(dis,INF,", "sizeof", "(dis));\n    dis[", "1", "]=st;\n    q.", "push", "({", "make_pair", "(dis[", "1", "],", "1", ")});\n    ", "while", "(!q.", "empty", "()){\n        ", "int", " x=q.", "top", "().second;\n        q.", "pop", "();\n        ", "if", "(vis[x]) ", "continue", ";\n        vis[x]=", "true", ";\n        ", "for", "(", "int", " i=", "0", ";i<a[x].", "size", "();i++){\n            ", "int", " y=a[x][i].v,z=a[x][i].w;\n            dis[y]=", "min", "(dis[y],dis[x]+z);\n            q.", "push", "(", "make_pair", "(dis[y],y));\n        }\n    }\n    ", "return", " dis[n]<b;\n}\n", "int", " ", "main", "()", "{\n    ", "scanf", "(", "\"%d%d%d\"", ",&n,&m,&b);\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "scanf", "(", "\"%d\"", ",&f[i]);\n        l=", "min", "(l,f[i]);\n        r=", "max", "(r,f[i]);\n    }\n    ", "int", " maxi=r;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "int", " u,v,w;\n        ", "scanf", "(", "\"%d%d%d\"", ",&u,&v,&w);\n        a[u].", "push_back", "({v,w});\n        a[v].", "push_back", "({u,w});\n    }\n    ", "while", "(l<=r){\n        mid=(l+r)/", "2", ";\n        ", "if", "(", "dijkstra", "(mid)) r=mid", "-1", ";\n        ", "else", " l=mid+", "1", ";\n    }\n    ", "if", "(l==maxi+", "1", ") \n        ", "printf", "(", "\"AFK\\n\"", ");\n    ", "else", "\n        ", "printf", "(", "\"%d\\n\"", ",l);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "æ±‚ç»™å‡ºä»¥å¦‚ä¸Šä»£ç æ”¹å¯¹äº†çš„ä»£ç æˆ–ä¿®æ”¹æ–¹å¼ï¼Œè°¢è°¢"]], "Tag": "ç®—æ³•è®¾è®¡"}
{"Answer": "&lt;p&gt;æˆ‘è¯•ç€ç…§ç€ä½ çš„dequeè¾“å‡ºçš„ä»£ç å†™äº†ä¸€ä¸ªæµ‹è¯•&amp;#xff0c;å¯ä»¥æ­£å¸¸è¾“å‡º&amp;#xff0c;æ‰€ä»¥é—®é¢˜åº”è¯¥ä¸åœ¨è¿™é‡Œ&lt;/p&gt;", "Konwledge_Point": "Dijkstraç®—æ³•", "Question": ["é—®é¢˜ï¼šä¸ºä»€ä¹ˆç”¨dequeåå‘è¾“å‡ºä¼šæŠ¥é”™è€Œç”¨é€’å½’åå‘è¾“å‡ºæ²¡é—®é¢˜", ["http://poj.org/problem?id=2457", "ï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1", "\n", "ï¼ˆç”±äºé¢˜ç›®æ˜¯è‹±æ–‡ï¼Œä»¥ä¸‹å›¾ç‰‡æ—¶ä¸­æ–‡ç¿»è¯‘åçš„å›¾ç‰‡ï¼‰", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "1", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "1", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<", "int", "> stars;\n", "void", " ", "print_stars", "()", "\n", "{\n \n    \n    stars.", "push_front", "(n);\n    k=n;\n    ", "while", "(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.", "push_front", "(k);\n    }\n    stars.", "push_front", "(s);\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    cin>>m>>n;\n", "//    if(n==1)", "\n", "//    {", "\n", "//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';", "\n", "//    }", "\n", "//    else{", "\n    \n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);", "\n        }\n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]<<", "'\\n'", ";\n            ", "print_stars", "();\n            ", "while", "(stars.", "size", "())\n            {\n                cout<<stars.", "front", "()<<", "'\\n'", ";\n                stars.", "pop_front", "();\n            }\n", "//        }", "\n    }\n    ", "return", " ", "0", ";\n}\n \n\n", "\n", "ï¼ˆä»¥ä¸‹æ—¶å°†dequeè¯¥æ¢æˆé€’å½’ä¹‹åå¯ä»¥é€šè¿‡çš„ä»£ç ï¼‰", "\n", " \n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "0", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "0", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\n", "//deque<int> stars;", "\n", "//void print_stars()", "\n", "//{", "\n", "//", "\n", "//    ", "\n", "//    stars.push_front(n);", "\n", "//    k=n;", "\n", "//    while(vis0[k]!=s)", "\n", "//    {", "\n", "//        k=vis0[k]; ", "\n", "//        stars.push_front(k);", "\n", "//    }", "\n", "//    stars.push_front(s);", "\n", "//}", "\n", "void", " ", "printf_path", "(", "int", " vertax)", "\n", "{\n    ", "if", "(vis0[vertax] != ", "-1", " ) ", "printf_path", "(vis0[vertax]);\n    cout<<vertax<<", "'\\n'", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    ", "memset", "(vis0,", "-1", ",", "sizeof", " vis0);\n    cin>>m>>n;\n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);    ", "\n        }\n    ", "if", "(n==", "1", ")\n    {\n        cout<<", "\"1\"", "<<", "'\\n'", "<<", "\"1\"", "<<", "'\\n'", ";\n    }\n    ", "else", "{\n    \n    \n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]+", "1", "<<", "'\\n'", ";\n            ", "printf_path", "(n);\n", "//            while(stars.size())", "\n", "//            {", "\n", "//                cout<<stars.front()<<'\\n';", "\n", "//                stars.pop_front();", "\n", "//            }", "\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "ç®—æ³•è®¾è®¡"}
