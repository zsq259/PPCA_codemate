{"Answer": "&lt;p&gt;可以参考一下&lt;a href=\"https://blog.csdn.net/weixin_41598179/article/details/112795877\" id=\"textarea_1652959433332_1652959657006_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C语言——最短路径问题&amp;#xff08;Dijkstra算法&amp;#xff09;_秋米姐姐的博客-CSDN博客_c语言求最短路径&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;C语言——最短路径问题&amp;#xff08;Dijkstra算法&amp;#xff09;优点——适用范围广&amp;#xff0c;本代码属于公式型代码&amp;#xff0c;可随意更换数据&amp;#xff0c;适合零基础同学。主要思路&amp;#xff1a;主要思路&amp;#xff1a;1.用一个二维数组存放带权有向图的邻接矩阵&amp;#xff1b;2.基于Dijkstra算法分别申请三个数组&amp;#xff0c;distance[], path[], used[]分别记录从起点到其余各点的最短距离&amp;#xff0c;到目标结点路径上的前一个结点&amp;#xff0c;到图中某个结点是否已找到最短路径&amp;#xff1b;3.逐渐确定从源点到图中各结点的最短路径&amp;#xff0c;直至结束&amp;#xff1b;最短路径例题&amp;#xff1a;如下图所示&amp;#xff0c;求最短经。&amp;lt;fn代码&amp;#xff1a;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/weixin_41598179/article/details/112795877&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["【c语言】【数据结构】Dijkstra算法求最快送餐路径", ["输入：第一行包含3个整数n,m,t，分别表示路口的个数，道路的条数和目的路口。", "（2 ≤ n ≤ 10，1 ≤ m ≤ 50，1 ≤ w ≤ 10）", "接下来m行每行包含三个整数 u,v,w，表示路口u到路口v存在一条耗时w的单行道。", "输出：骑手从商家（位于1号路口）到目的路口的最短时间，若路径不存在，输出-1。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;用Dijkstra算法求从顶点0出发的最短路径。简单来说&amp;#xff0c;就是从起点开始&amp;#xff0c;不断地选取未访问的距离起点最近的顶点&amp;#xff0c;并更新该顶点到其他顶点的距离。这样不断执行直到所有顶点都被访问过&amp;#xff0c;得到起点到各个顶点的最短路径。&lt;/p&gt;\n&lt;p&gt;接着&amp;#xff0c;给出了算法执行的某时刻&amp;#xff0c;即已经访问了0、2、3、4四个顶点。这意味着此时已经找到了从起点到这些顶点的最短路径。&lt;/p&gt;\n&lt;p&gt;最后&amp;#xff0c;需要在这个时刻选取下一步目标顶点。因为题目没有给出完整的图&amp;#xff0c;所以我也不知道顶点D与0、2、3、4之间的连边情况。因此无法确定顶点D是否为下一步的目标顶点。&lt;/p&gt;\n&lt;p&gt;因此&amp;#xff0c;选项A、B、C、D中只有选项D是无法确定的&amp;#xff0c;其他三个选项的顶点都不是下一步的目标顶点的可能性比较小&amp;#xff0c;但需要具体情况具体分析。如果需要确定下一步目标顶点&amp;#xff0c;需要知道顶点D与0、2、3、4之间的连边情况。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["Dijkstra算法的问题", ["用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻，S={0,2,3,4}，下一步选取的目标顶点可能是   D   。", "A.顶点2            B.顶点3            C.顶点4            D.顶点7", "表达的是啥意思嘞，顶点7又是怎么出来的嘞"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/a19990412/article/details/80232810\" id=\"textarea_1655439466811_1655439572959_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;迪杰斯特拉算法&amp;#xff08;Dijkstra&amp;#xff09;证明_肥宅_Sean的博客-CSDN博客_迪杰斯特拉算法证明&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;首先&amp;#xff0c;这篇文章是在讲《图论》时候写文章&amp;#xff08;所以&amp;#xff0c;还是以理论为主&amp;#xff0c;以后有空的时候&amp;#xff0c;会把代码发上来&amp;#xff0c;不过我觉得大家看完理论&amp;#xff0c;如果讲得好&amp;#xff0c;代码也就比较容易了。如果讲得不好&amp;#xff0c;网上的代码也是大把&amp;#xff0c;不看这篇文章也罢了&amp;#xff09;下图为老师的课件内容部分&amp;#xff0c;我觉得虽然详尽&amp;#xff0c;但也有些枯燥。可能是为了凝练语言吧。如果有耐心看的话&amp;#xff0c;倒真的是一篇非常好的文章。&amp;#xff08;反正这个应该是比百度百科要强的….&amp;#xff09; 我在后面会用自己的语言阐...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/a19990412/article/details/80232810&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["证明证明Dijkstra算法正确性，并分析时间复杂度", ["证明Dijkstra算法正确性，并分析在未优化的情况下其平均情况下时间复杂度。假设图为G=(V,E)", "\n", "要求：c/c++，有证明过程"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;段错误一般是数组下标越界&lt;br /&gt;或者指针没有正确指向或没有分配空间&lt;br /&gt;参考代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; namespace std;\nstruct Node {\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x, y;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n};\nstruct TS {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n};\n\nTS HHH[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N, &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; D, G[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\nNode Dist[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; visit[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-keyword\"&gt;false&lt;/span&gt;};\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; cmp(TS a, TS b) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.distant &amp;lt; b.distant;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main() {\n    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; D;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;32.5&lt;/span&gt;) {\n        printf(&amp;#34;1\\n&amp;#34;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; X, Y;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tol &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fill(G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; &lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        cin &amp;gt;&amp;gt; X &amp;gt;&amp;gt; Y;\n        HHH[i].num &amp;#61; i;\n        Dist[i].x &amp;#61; X;\n        Dist[i].y &amp;#61; Y;\n        Dist[i].distant &amp;#61; sqrt(X * X &amp;#43; Y * Y);\n        HHH[i].distant &amp;#61; Dist[i].distant;\n        Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;) {\n            Init(i, j);\n        }\n    }\n    \n    sort(HHH, HHH &amp;#43; N, cmp);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HHH[i].distant &amp;gt; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; HHH[i].distant &amp;lt;&amp;#61; D &amp;#43; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; !visit[HHH[i].num]) {\n            tol &amp;#61; BFS(HHH[i].num);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) break;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) printf(&amp;#34;0\\n&amp;#34;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j) {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; Dist[i].x - Dist[j].x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y &amp;#61; Dist[i].y - Dist[j].y;\n    G[i][j] &amp;#61; G[j][i] &amp;#61; sqrt(x * x &amp;#43; y * y);\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((Dist[i].x &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].x - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;) || (Dist[i].y &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].y - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;)) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n\n    visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n    Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; Q;\n    Q.push(i);\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!Q.empty()) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; Q.front();\n        Q.pop();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (Judge(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;)) {\n            cout &amp;lt;&amp;lt; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; endl;\n            stack&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; st;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;) {\n                st.push(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;];\n            }\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!st.empty()) {\n                &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Top &amp;#61; st.top();\n                st.pop();\n                cout &amp;lt;&amp;lt; Dist[Top].x &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; Dist[Top].y &amp;lt;&amp;lt; endl;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;][i] &amp;lt;&amp;#61; D &amp;amp;&amp;amp; !visit[i]) {\n                visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n                Dist[i].c &amp;#61; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;;\n                Q.push(i);\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["数据结构习题，图的Dijkstra算法", ["题目如下", "\n", "This time let us consider the situation in the movie \"Live and Let Die\" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head（省略号） Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).", "\n", "Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.", "\n", "Input Specification:", "Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.", "\n", "Output Specification:", "For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.", "\n", "\n", "\n", "我的代码", "\n", "//自己写的，半错版本 ", "\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n#define MaxVertexNum ", "105", "\n#define M_INFINITY ", "65535", "\ntypedef int Vertex;\ntypedef double WeightType;\ntypedef struct Data{\n    int X,Y;\n}DataType[MaxVertexNum];\n\n", "/*边的定义*/", "\ntypedef struct ENode* PtrToENode;\nstruct ENode{\n    Vertex V1,V2;\n    WeightType Weight; \n};\ntypedef PtrToENode Edge;\n\n", "/*图的定义*/", "\ntypedef struct GNode* PtrToGNode;\nstruct GNode{\n    int Nv;\n    int Ne;\n    WeightType D[MaxVertexNum][MaxVertexNum];\n    DataType Locate;\n};\ntypedef PtrToGNode MGraph;\n\n", "//创造图的函数", "\nvoid InsertEdge(MGraph Graph, Edge E)\n{\n    G", "raph", "->", "D[E->V1][E->V2] = E->Weight;\n    G", "raph", "->", "D[E->V2][E->V1] = E->Weight;\n}\nMGraph CreatGraph(int VertexNum)\n{", "/*初始化一个图结构，所有对角边为0，非对角边为INFINITY*/", "\n    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));\n    G", "raph", "->", "Nv = VertexNum;\n    G", "raph", "->", "Ne = ", "0", ";\n    int V,W;\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V;W<Graph->", "Nv;W++){\n            ", "if", "(V!=W){\n                G", "raph", "->", "D[V][W] = M_INFINITY;\n                G", "raph", "->", "D[W][V] = M_INFINITY;\n            }", "else", "{\n                G", "raph", "->", "D[V][W] = ", "0", ";\n            }\n        }\n    }\n    return Graph;\n}\nWeightType Length(double X1,double Y1,double X2,double Y2)\n{", "/*返回两个点的直线距离*/", "\n    double deltx = X1-X2;\n    double delty = Y1-Y2;\n    WeightType weight = ", "sqrt", "(deltx*deltx + delty*delty);\n    return weight;\n}\nMGraph BuildGraph(int Nv,double D)\n{", "/*创造图*/", "\n    int i,V,W;\n    Vertex X,Y;\n    WeightType Weight;\n    MGraph Graph = CreatGraph(Nv+", "1", ");\n    Edge E = (Edge)malloc(sizeof(struct ENode));\n    \n    V=", "1", ";\n    G", "raph", "->", "L", "ocate", "[0].X = Graph->", "Locate[", "0", "].Y = ", "0", ";\n    ", "for", "(i=", "1", ";i<=Nv;i++){\n        scanf(", "\"%d%d\"", ",&X,&Y);\n        \n        ", "if", "(", "abs", "(X)<", "50", " && ", "abs", "(Y)<", "50", " && Length(X,Y,", "0", ",", "0", ")>", "7.5", "){\n            G", "raph", "->", "Locate[V].X = X;\n            G", "raph", "->", "Locate[V].Y = Y;\n            V++;\n        }", "else", "{\n            G", "raph", "->", "Nv--;\n        }\n    }\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V+1;W<Graph->", "Nv;W++){\n            W", "eight", " = Length(Graph->", "L", "ocate", "[V].X,Graph->", "Locate[V].Y,\n            G", "raph", "->", "L", "ocate", "[W].X,Graph->", "Locate[W].Y);\n            ", "if", "(Weight<=D){\n                E->V1 = V;\n                E->V2 = W;\n                E->Weight = Weight;\n                ", "if", "(E->", "V1==", "0", ") E->Weight-=", "7.5", ";\n                InsertEdge(Graph,E);\n            }\n        }\n    }\n    \n    return Graph;\n}\n\nVertex FindMinDist(MGraph Graph, double dist[], int collected[])\n{\n    Vertex MinV, V;\n    int MinDist = M_INFINITY;\n    \n    ", "for", "(V=0; V<Graph->", "Nv; V++){\n        ", "if", "(collected[V]==", "0", " && dist[V]<MinDist){\n            MinDist = dist[V];\n            MinV = V;\n        }\n    }\n    ", "if", "( MinDist < M_INFINITY )\n        return MinV;\n    ", "else", " return ", "0", ";\n}\nvoid Dijkstra(MGraph Graph, double* dist, int* ", "path", ",int* collected)\n{\n    Vertex V,W;\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "dist", "[V] = Graph->", "D[", "0", "][V];\n        ", "if", "(dist[V]<M_INFINITY)\n            ", "path", "[V] = ", "0", ";\n        ", "else", "\n            ", "path", "[V] = -", "1", ";\n        collected[V] = ", "0", ";\n    }\n    ", "/*先将起点收入集合*/", "\n    dist[", "0", "] = ", "0", ";\n    collected[", "0", "] = ", "1", ";\n    \n    ", "while", "(", "1", "){\n        V = FindMinDist(Graph,dist,collected);\n        ", "if", "(V==", "0", ")\n            break;\n        collected[V] = ", "1", ";\n        ", "for", "(W=0;W<Graph->", "Nv;W++)\n            ", "if", "(collected[W]==0 && Graph->", "D[V][W]<M_INFINITY){\n                ", "if", "(dist[V]+Graph->", "D[V][W]<dist[W]){\n                    ", "dist", "[W] = dist[V]+Graph->", "D[V][W];\n                    ", "path", "[W] = V; \n                }\n            }\n    }\n}\n\nint min(int x,int y)\n{\n    ", "if", "(x<y) return x;\n    ", "else", " return y;\n}\n\nint main()\n{\n    ", "/*输入数，（初始Nv，可能会更少），输入JanesBond一次最远跳*/", "\n    int N,D,i;\n    scanf(", "\"%d%d\"", ",&N,&D);\n    ", "/*创造图*/", "\n    MGraph Graph = BuildGraph(N,D);\n    ", "/*初始化dist[],path[],collected[]*/", "\n    ", "double", " dist[Graph->", "Nv];\n    ", "int", " ", "path", "[Graph->", "N", "v", "],collected[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        dist[i] = M_INFINITY;\n        ", "path", "[i] = -", "1", ";\n        collected[i] = ", "0", ";\n    }\n    ", "/*Dijkstra算法算dist*/", "\n    Dijkstra(Graph,dist,", "path", ",collected);\n    \n    ", "/*找到可以作为出口得鳄鱼，同时将它到出口的距离存储到数组中*/", "\n    V", "ertex", " V,W,OutNode[Graph->", "Nv];\n    int flag = ", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++) OutNode[V]=", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "if", "(50-fabs(Graph->", "L", "ocate", "[V].X)<=D || 50-fabs(Graph->", "Locate[V].Y)<=D){\n            ", "if", "(50-fabs(Graph->", "Locate[V].X)<=D){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }", "else", " ", "if", "(50-fabs(Graph->", "Locate[V].Y<=D)){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }\n            flag=", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    flag = ", "0", ";\n    ", "for", "(W=1;W<Graph->", "Nv;W++){\n        ", "if", "(Graph->", "D[", "0", "][W]!=M_INFINITY){\n            flag = ", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    ", "/*以上为判断是否有可能可以出去，也就是1>Island有没有邻接点，2>有没有可以跳出去的鳄鱼*/", "\n\n    ", "/*\n    找最短路\n    1.找可以出去的路径\n    2.比较可以出去的路径中最短路径 \n    */", "\n    \n    V", "ertex", " OutWay[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        OutWay[i]=-", "1", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(50-", "abs", "(Graph->", "L", "ocate", "[i].X)<=D || 50-", "abs", "(Graph->", "Locate[i].Y)<=D){\n            O", "utWay", "[i] = min(50-", "abs", "(Graph->", "L", "ocate", "[i].X),50-", "abs", "(Graph->", "Locate[i].Y));\n        }\n    }\n    \n    \n    ", "/*从出口中更新路径长度*/", "\n    ", "double", " Outdist[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        Outdist[i] = ", "0", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            Vertex temNode = i;\n            ", "while", "(temNode){\n                Outdist[i]+=dist[temNode];\n                temNode = ", "path", "[temNode];\n            }\n        }\n    }\n    \n    ", "/*从路径中找最小长，并记录*/", "\n    Vertex MinWay;\n    double Mindist=M_INFINITY;\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            ", "if", "(Mindist>Outdist[i]){\n                Mindist = Outdist[i];\n                MinWay = i;\n            }\n        }\n    }\n    \n    ", "/*从最小路径中找结点，反向输出*/", "\n    V", "ertex", " Stack[Graph->", "Nv];\n    int rear=-", "1", ",count=", "1", ";\n    Vertex temNode = MinWay;\n    ", "while", "(temNode){\n        Stack[++rear] = temNode;\n        temNode = ", "path", "[temNode];\n        count++;\n    }\n    printf(", "\"%d\\n\"", ",count);\n    ", "while", "(rear!=-", "1", "){\n        ", "printf", "(\"%d %d\\n\",Graph->", "L", "ocate", "[Stack[rear]].X,Graph->", "Locate[Stack[rear]].Y);\n        rear--;\n    }\n    \n    return ", "0", ";\n}\n\n", "\n", "最后结果", "\n", "\n", "实在不知道哪错了，最初是前三项都通过了，后来就从头再来一遍，哪知道现在后面几个对了第一个项目说段错误，段错误给的理由如下", "\n", "\n", "不过现在测试点也不知道哪错了，麻烦看看吧"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;邻接表你可以理解为多个链表&amp;#xff0c;每个链表的头是一个节点&amp;#xff0c;而你添加一条边add&amp;#xff08;a,b,c&amp;#xff09;相当于给a增添一个出度b长度为c&amp;#xff0c;而 next[a]中储存的是就是a所有的出度的地址&amp;#xff0c;next存储的是下一个出度的地址&amp;#xff0c;ver[i]就是出度点的标号&amp;#xff0c;edge[i]头节点到出度的距离&amp;#xff0c;dj的基本思路是每次选取一个离原点最近的边来更新其他点的距离&amp;#xff0c;我们先将{0&amp;#xff0c;1}加入堆中&amp;#xff0c;堆排序pair根据first优先原则&amp;#xff0c;所以意思就是堆中1号点到一号点的距离为0&amp;#xff0c;那么此时会用1号点先更新它出度&amp;#xff0c;并且每个点有且只会被加入一次&amp;#xff0c;我们将它打上标记&amp;#xff0c;如果堆中已经加入过这个最短边&amp;#xff0c;我们直接将它continue&amp;#xff0c;否则而循环的终点就是没有边再被更新的时候&amp;#xff0c;也就是没有东西可以入队了&amp;#xff0c;循环结束。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["Dijkstra算法及邻接表 C++", ["priority_queue<pair<", "int", ",", "int", ">>q;", "//大根堆-小根堆", "\n    ", "memset", "(d,", "0x3f", ",", "sizeof", "(d);\n    ", "memset", "(v,", "0", ",", "sizeof", "(v));\n    d[", "1", "]=", "0", ";\n    q.", "push", "(", "make_pair", "(", "0", ",", "1", "));\n    ", "while", "(q.", "size", "())\n    ", "int", " x=q.", "top", "().second;q.", "pop", "();\n    ", "if", "(v[x])", "continue", ";\n    v[x]=", "1", ";\n    ", "for", "(", "int", " i=head[x];i;i=Next[i])\n    ", "int", " y=ver[i],z=edge[i];\n    ", "if", "(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.", "push", "(", "make_pair", "(-d[y],y));\n    }\n    } \n", "\n", "如上，请问一下：", "\n", "while", "(q.", "size", "())\n", "if", "(v[x])", "continue", ";\n", "for", "(", "int", " i=head[x];i;i=", "Next", "[i])\n", "\n", "各是什么意思？还有邻接表的原理是什么？麻烦了！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;不行。因为各种路径的 步数并不一定相同。&lt;br /&gt;所有边权值加正数&amp;#xff0c;只有在各种路径步数相同的情况下才可行。&lt;br /&gt;求带负权值边的单源最短路径可以用贝尔曼-福特算法。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗", ["迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗"]], "Tag": "算法设计"}
{"Answer": "可以有偿啊，大神快来啊![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstra算法", "Question": ["OPNET卫星网络路由算法仿真", ["最近要交毕设啦，OPNET的卫星网络路由仿真还不会做，求大神指导啊，真的很着急。算法主要", "\n是收集链路状态信息，比如时延、带宽、丢包率，然后归一化到[0,1]，分配权重作为", "\n链路的Cost，然后用Dijkstra算法。", "\n求指导啊，怎么做仿真，呜呜呜~"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;如果想要在遍历图中的所有点之后得到最优路径&amp;#xff0c;可以使用一种叫做旅行商问题&amp;#xff08;Travelling Salesman Problem&amp;#xff0c;TSP&amp;#xff09;的算法。TSP 问题是指寻找遍历一个给定的城市列表的最短路径的问题。&lt;/p&gt;\n&lt;p&gt;以下是一个示例实现&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def tsp(self, &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;, end):\n    &lt;span class=\"hljs-comment\"&gt;# 初始化未遍历的点的集合&lt;/span&gt;\n    unvisited &amp;#61; set(self.nodes)\n    &lt;span class=\"hljs-comment\"&gt;# 将起始点加入到已遍历的点的集合中&lt;/span&gt;\n    visited &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;}\n    &lt;span class=\"hljs-comment\"&gt;# 初始化当前点为起始点&lt;/span&gt;\n    current &amp;#61; &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#初始化路径和距离为 0&lt;/span&gt;\n    path &amp;#61; []\n    distance &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\nwhile unvisited:\n    &lt;span class=\"hljs-comment\"&gt;# 寻找当前点的最近的未遍历的点&lt;/span&gt;\n    next_node, next_distance &amp;#61; min([(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt;) for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;not&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; visited], &lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x: x[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# 将最近的未遍历的点加入到已遍历的点的集合中&lt;/span&gt;\n    visited.add(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# 从未遍历的点的集合中删除最近的未遍历的点&lt;/span&gt;\n    unvisited.remove(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# 更新当前点为最近的未遍历的点&lt;/span&gt;\n    current &amp;#61; next_node\n    &lt;span class=\"hljs-comment\"&gt;# 更新路径和距离&lt;/span&gt;\n    path.append(next_node)\n    distance &amp;#43;&amp;#61; next_distance\n\n&lt;span class=\"hljs-comment\"&gt;# 如果最后一个遍历的点不是终点&amp;#xff0c;添加一条从最后一个遍历的点到终点的边&lt;/span&gt;\nif current !&amp;#61; end:\n    &lt;span class=\"hljs-comment\"&gt;# 寻找最后一个遍历的点到终点的最短距离&lt;/span&gt;\n    next_distance &amp;#61; min([cost for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;&amp;#61;&amp;#61; end&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# 更新路径和距离&lt;/span&gt;\n    path.append(end)\n    distance &amp;#43;&amp;#61; next_distance\n\nreturn path, distance\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以使用这个方法来解决 TSP 问题&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;graph &amp;#61; Graph(&lt;span class=\"hljs-string\"&gt;&amp;#39;map.txt&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;, distance &amp;#61; graph.tsp(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;)  # [&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(distance)  # &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;仅供参考&amp;#xff0c;望采纳&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["怎么将任意两点间的最短路径改成任意两点间遍历完所有点后的最优路径呢", ["\n", "class", " ", "Graph", ":\n            ", "def", " ", "__init__", "(", "self,filename", "):", "#将地图建成一个邻接表", "\n        \n               graph_edges=[]", "#边的长度", "\n               ", "with", " ", "open", "(filename) ", "as", " fhandle:", "#读取文件，一行一行的读", "\n                      ", "for", " line ", "in", " fhandle:\n                          ", "if", " line==", "\"\\n\"", ":", "#读取截止条件，注意必须加否则会报错", "\n                            ", "break", "\n                ", "#将map.txt文件中的数据按空格分离并存储，*_代表这一行后面所有的元素。", "\n                          edge_from,edge_to,cost,*_=line.strip().split(", "\" \"", ")\n                          graph_edges.append((edge_from,edge_to,cost))", "#以元组的形式加入到graph_edges", "\n        ", "#建立节点，set() 函数创建一个无序不重复元素集，", "\n        ", "#可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。", "\n               self.nodes =", "set", "()\n               ", "for", " edge ", "in", " graph_edges:\n            ", "#初始化节点", "\n            ", "#update() 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，", "\n            ", "#如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。", "\n                  self.nodes.update([edge[", "0", "],edge[", "1", "]])\n        ", "#建立邻接表", "\n               self.adjacency_list = {node: ", "set", "() ", "for", " node ", "in", " self.nodes}\n               ", "for", " edge ", "in", " graph_edges:\n           ", "#字典中的键表示图中的节点，而键值则是以字典的形式存在里面包括几组一元组的形式储存的", "\n           ", "#表示可达到节点以及权值", "\n                   self.adjacency_list[edge[", "0", "]].add((edge[", "1", "],edge[", "2", "]))\n            ", "def", " ", "shortest_path", "(", "self, start_node, end_node", "):\n                start_node=nameEntry3.get()\n                end_node=nameEntry4.get()\n               \n        ", "#使用Dijkstra算法找到从起始点到终点的最短路径，返回（path,distance）", "\n               \n        ", "#创造一个未访问节点的集合初始化为所有节点", "\n                unvisited_nodes = self.nodes.copy()  \n        ", "#创建一个字典表示每个点到起始点的距离，每个点先初始化为inf除了点本身初始化为0", "\n        ", "#当我们找到一个更短路径的时候更新这个字典所对应的值，数据结构为 节点：距离", "\n                distance_from_start = {node: (", "0", " ", "if", " node == start_node ", "else", " INFINITY) ", "for", " node ", "in", " self.nodes}\n \n        ", "#初始化前置节点也就是用来寻找路径的方法，结构为节点：节点其中后面的节点是前面", "\n        ", "#的前置节点，由此可以一步步找到路径，如果找到更短路径就更新这个字典", "\n                previous_node = {node: ", "None", " ", "for", " node ", "in", " self.nodes}\n                ", "while", " unvisited_nodes:\n            ", "#将当前节点设置为到目前为止在未访问节点这个字典中路径最短的节点", "\n                     current_node = ", "min", "(\n                ", "#从unvisited_nodes中找到键值最小的节点作为当前节点", "\n                          unvisited_nodes, key=", "lambda", " node: distance_from_start[node]\n                       )\n            ", "#从未访问的节点中，移除当前节点", "\n                     unvisited_nodes.remove(current_node)\n            ", "#如果当前节点的距离为无穷大，则其余未访问的节点不会连接到开始节点，停止", "\n                     ", "if", " distance_from_start[current_node] == INFINITY:\n                       ", "break", "\n \n            ", "#遍历每个当前节点的邻居，检查一下从起始节点到当前节点再到邻居节点的距离的大小", "\n            ", "#与distance_form_start中的比较看看是否更小，是讲究更新distance中所对应的值", "\n                     ", "for", " neighbor, distance ", "in", " self.adjacency_list[current_node]:\n                ", "#新的路径的距离", "\n                        new_path = distance_from_start[current_node] + ", "int", "(distance)\n                        ", "if", " new_path < distance_from_start[neighbor]:\n                             distance_from_start[neighbor] = new_path", "#更新值", "\n                             previous_node[neighbor] = current_node", "#更新路径，将当前节点作为邻居的前置节点", "\n \n        ", "#为了找到我们所建立的最短路径，使用迭代器遍历每个点的前置节点即可找到路径", "\n        ", "#并且把他存入一个队列中之所以可以保证找得到前置节点，是因为算法完成时候每个点的前置节点都代表着", "\n        ", "#到起始点的最短路径", "\n                path = deque()\n                current_node = end_node\n                ", "while", " previous_node[current_node] ", "is", " ", "not", " ", "None", ":\n                       path.appendleft(current_node)\n                       current_node = previous_node[current_node]\n                path.appendleft(start_node)\n                ", "return", " path, distance_from_start[end_node]\n       \n                   \n", "\n", "怎么将任意两点间的最短路径改成任意两点间遍历完所有点后的最优路径呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;基于最新版ChatGPT4的回答&amp;#xff0c;望采纳!!!有其他问题也可以询问我哦、”(最新版更智能&amp;#xff0c;功能更加强大)&lt;/p&gt;\n&lt;p&gt;为了解决这个问题&amp;#xff0c;我们需要修改Dijkstra算法&amp;#xff0c;使其最大化概率乘积而不是最小化权重和。我们将进行以下更改&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;初始化时&amp;#xff0c;将源节点的距离设置为1&amp;#xff0c;而不是0。&lt;/li&gt;&lt;li&gt;在寻找最小距离的节点时&amp;#xff0c;寻找具有最大距离的节点。&lt;/li&gt;&lt;li&gt;在更新节点的距离时&amp;#xff0c;使用概率乘积而不是权重和。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;以下是修改后的dijkstra.c文件中的代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;// DSA Programming task 4.2 - Dijsktra&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// You work on this file where TODO is located&lt;/span&gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &lt;span class=\"hljs-string\"&gt;&amp;#34;dijkstra.h&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Initializes graph for Dijkstra&lt;/span&gt;\nvoid init_graph(weightedgraph* g, int vertices){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;nVertices &amp;#61; vertices;\n    int i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; vertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;adj_list[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// TODO! Note the distance&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Dijkstra search from node s&lt;/span&gt;\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;// Initialize graph&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;1; i &amp;lt;&amp;#61; g-&amp;gt;&lt;/span&gt;nVertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// All vertices in queue&lt;/span&gt;\n        queue[i] &amp;#61; i;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// TODO! Modification should start from here&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Note that the propability should be maximized&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Chanage names of variables accordingly&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[s] &amp;#61; &lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;g-&amp;gt;&lt;/span&gt;nVertices; i &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i--) {\n        &lt;span class=\"hljs-comment\"&gt;// Search for maximum from the queue&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;double&lt;/span&gt; maxval &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]];\n        int maxnode &amp;#61; queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        int maxj&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt;&amp;#61; i; j&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;( g-&amp;gt;&lt;/span&gt;dist[queue[j]] &amp;gt; maxval ){\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;maxval&lt;/span&gt; &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[j]];\n                maxnode &amp;#61; queue[j];\n                maxj &amp;#61; j;\n            }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// Switches the maximum to end (out of the queue)&lt;/span&gt;\n        int temp &amp;#61; queue[i];\n        queue[i] &amp;#61; queue[maxj];\n        queue[maxj] &amp;#61; temp;\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pweightededgenode&lt;/span&gt; pedge &amp;#61; g-&amp;gt;&lt;/span&gt;adj_list[maxnode];\n\n        &lt;span class=\"hljs-comment\"&gt;// Relax the neighbors&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(pedge !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; v &amp;#61; pedge-&amp;gt;&lt;/span&gt;nodenum;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;lt; (g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight))  {\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;#61; g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[v] &amp;#61; maxnode;\n            }\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pedge&lt;/span&gt; &amp;#61; pedge-&amp;gt;&lt;/span&gt;next;\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// DEBUG INFO:&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// printf(&amp;#34;%d processed: d[%d] &amp;#61; %f\\n&amp;#34;,maxnode,maxnode,g-&amp;gt;dist[maxnode]);&lt;/span&gt;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//No need to change anyting after this point!&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用此修改后的算法&amp;#xff0c;您将能够找到具有最佳概率传递消息的路径。在给定示例中&amp;#xff0c;该算法将找到从站1到站8的最佳路径。我们将使用修改过的Dijkstra算法计算给定图中从节点1到节点8的最佳传输路径。请确保您使用了上述提供的修改后的dijkstra.c文件代码。使用此修改后的算法&amp;#xff0c;您可以通过运行main.c文件找到所需的路径。&lt;/p&gt;\n&lt;p&gt;现在&amp;#xff0c;我们已经修改了Dijkstra算法以解决您的问题&amp;#xff0c;您可以运行main.c文件&amp;#xff0c;以找到从站1到站8的最佳传输路径。在您提供的示例中&amp;#xff0c;该算法将找到具有最佳概率传递消息的路径。&lt;/p&gt;\n&lt;p&gt;请注意&amp;#xff0c;修改后的Dijkstra算法可以适用于您的问题。但是&amp;#xff0c;在特定情况下&amp;#xff0c;这种方法可能不是最有效的。例如&amp;#xff0c;对于具有大量节点和边的大型网络&amp;#xff0c;这种方法可能需要更多的计算资源和时间。在这种情况下&amp;#xff0c;可以考虑使用其他更高效的算法&amp;#xff0c;如A*搜索算法或其他启发式搜索方法。&lt;/p&gt;\n&lt;p&gt;如果您有其他关于Dijkstra算法或其他算法的问题&amp;#xff0c;请随时提问。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["c语言，修改基于第一个图的旧算法算法以解决新的问题，并将新算法用于最后一张图", ["有一个关于Dijkstra的无向图算法的实现，队列的处理简单，使算法的时间复杂度为𝛩(𝑛2),n是图中的节点数,将该算法应用于无向算法,下面是最初使用的加权图", "\n", "\n", "修改算法以解决下列问题：", "在一个链路网络中，有n个基站，我们可以在它们之间传输消息，一个网络包含n个互相传输信息的站点t1, t2, …, tn,由于干扰，消息可能在传输过程中被损坏。对于每一对站点，我们都知道消息被正确传输的概率（一个在0到1之间的实数）。 我们打算从t1站到tn站。设计一种算法来找到站点的路径，以最佳的概率传递消息.请注意，当一个消息通过一系列站点传输时，没有错误地传递它的概率是序列中概率的乘积。", "例子，在下图中，有三个站点和给定的概率", "通过v从t向u传递信息比直接传递信息更好，因为直接传递信息概率为0.5，而通过v的概率为0.7 × 0.8 = 0.56 > 0.50", "\n", "因此，应该修改给定的算法而不是边的和。我们考虑乘积，并选择最大值（而不是像原始算法中那样的最小值）", "\n", "将该算法应用于以下网络，其中边的权值为概率。该消息将从站1传送到站8，以此图用作新的算法。", "\n", "dijkstra.不需要修改", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n", "#", "ifndef", " DIJKSTRA_H_INCLUDED", "\n", "#", "define", " DIJKSTRA_H_INCLUDED", "\n\n", "#", "include", " ", "<limits.h>", "\n", "#", "include", " ", "<float.h>", "\n\n", "// Maximum number of vertices", "\n", "// define according to your needs", "\n", "#", "define", " MAXVERTS 1000", "\n\n", "// Nodes are numbered as integers from 1", "\n\n", "// Maximum value in the distance table", "\n", "#", "define", " INF DBL_MAX", "\n\n", "// Defines edge in the adjacency list", "\n", "typedef", " ", "struct", " ", "weightedgnd", " {\n    ", "int", " nodenum;\n    ", "double", " weight;\n    ", "struct", " ", "weightedgnd", "* next;\n} weightededgenode, *pweightededgenode;\n\n", "// Defines the graph", "\n", "typedef", " ", "struct", " ", "weightedg", " {\n    pweightededgenode adj_list[MAXVERTS+", "1", "];\n    ", "int", " pred[MAXVERTS+", "1", "];\n    ", "double", " dist[MAXVERTS+", "1", "];\n    ", "int", " nVertices;\n} weightedgraph;\n\n", "// Initializes graph for breadth-first search", "\n", "void", " ", "init_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Adds new edge (x,y)", "\n", "void", " ", "add_edge", "(weightedgraph* g, ", "int", " x, ", "int", " y, ", "double", " wght)", ";\n\n", "// Actual breadth-first search from node s", "\n", "void", " ", "dijkstra", "(weightedgraph* g, ", "int", " s)", ";\n\n", "// Frees allocated memory", "\n", "void", " ", "delete_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Print a path after search", "\n", "void", " ", "print_path", "(weightedgraph* g, ", "int", " dest)", ";\n\n", "#", "endif", "\n\n", "\n", "main.c，不需要修改", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n#", "include", " <stdio.h>\n#", "include", " ", "\"dijkstra.h\"", "\n\n", "int", " main", "()", "{\n    weightedgraph g;\n    init", "_graph(&", "g", ",8)", ";\n\n    add", "_edge(&", "g", ",1,2,1)", ";\n    add", "_edge(&", "g", ",1,4,7)", ";\n    add", "_edge(&", "g", ",1,5,3)", ";\n\n    add", "_edge(&", "g", ",2,3,1)", ";\n    add", "_edge(&", "g", ",3,4,2)", ";\n    add", "_edge(&", "g", ",5,6,3)", ";\n\n    add", "_edge(&", "g", ",6,7,3)", ";\n    add", "_edge(&", "g", ",6,8,3)", ";\n\n    ", "// The other graph", "\n    add", "_edge(&", "g", ",2,4,2)", ";\n    add", "_edge(&", "g", ",4,6,2)", ";\n\n    dijkstra(&g,", "1", ");\n\n    printf(", "\"The path from 1 to 8 with cumulative weights:\\n\"", ");\n    print", "_path(&", "g", ",8)", ";\n\n    delete", "_graph(&", "g", ",8)", ";\n\n    return ", "0", ";\n}\n\n", "\n", "dijkstra.c只对有TODO的部分进行修改（即为void init_graph函数的TODO部分和void dijkstra的TODO部分），具体修改要求详情见代码部分的注释", "\n", "// DSA Programming task 4.2 - Dijsktra", "\n", "// You work on this file where TODO is located", "\n#include <stdio.h>\n#include <stdlib.h>\n#include ", "\"dijkstra.h\"", "\n\n", "// Initializes graph for Dijkstra", "\nvoid init_graph(weightedgraph* g, int vertices){\n    ", "g", "->", "nVertices = vertices;\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "g", "->", "adj_list[i] = ", "0", ";\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "// TODO! Note the distance", "\n        ", "g", "->", "dist[i] = INF;\n    }\n}\n\n", "// Adds new edge (x,y)", "\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    ", "if", "( x <= g->", "nVertices", " && y <= g->", "nVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        ", "pxy", "->", "nodenum = y;\n        ", "pxy", "->", "next", " = g->", "adj_list[x];\n        ", "pxy", "->", "weight = wght;\n        ", "g", "->", "adj_list[x] = pxy;\n\n        ", "pyx", "->", "nodenum = x;\n        ", "pyx", "->", "next", " = g->", "adj_list[y];\n        ", "pyx", "->", "weight = wght;\n        ", "g", "->", "adj_list[y] = pyx;\n    }\n}\n\n\n", "/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/", "\n\n", "// Dijkstra search from node s", "\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=", "0", ";\n\n    ", "// Initialize graph", "\n    ", "for", "(i=1; i <= g->", "nVertices; i++) {\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "g", "->", "dist[i] = INF;\n        ", "// All vertices in queue", "\n        queue[i] = i;\n    }\n\n    ", "// TODO! Modification should start from here", "\n    ", "//       Note that the propability should be maximized", "\n    ", "//       Chanage names of variables accordingly", "\n    ", "g", "->", "dist[s] = ", "0", ";\n\n    ", "for", "(i=g->", "nVertices; i >= ", "1", "; i--) {\n        ", "// Search for minimum from the queue", "\n        ", "double", " minval = g->", "dist[queue[", "1", "]];\n        int minnode = queue[", "1", "];\n        int minj=", "1", ";\n        ", "for", "(int j = ", "1", "; j <= i; j++) {\n            ", "if", "( g->", "dist[queue[j]] < minval ){\n                ", "minval", " = g->", "dist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        ", "// Switches the minimum to end (out of the queue)", "\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        ", "pweightededgenode", " pedge = g->", "adj_list[minnode];\n\n        ", "// Relax the neighbors", "\n        ", "while", "(pedge != ", "0", "){\n            ", "int", " v = pedge->", "nodenum;\n            ", "if", "(g->", "dist", "[v] > (g->", "dist", "[minnode]+pedge->", "weight))  {\n                ", "g", "->", "dist", "[v] = g->", "dist", "[minnode]+pedge->", "weight;\n                ", "g", "->", "pred[v] = minnode;\n            }\n            ", "pedge", " = pedge->", "next;\n        }\n\n        ", "// DEBUG INFO:", "\n        ", "// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);", "\n    }\n}\n", "//No need to change anyting after this point!", "\n\n", "// Free allocated memory", "\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "pweightededgenode", " pedge = g->", "adj_list[i];\n        pweightededgenode pnext = ", "0", ";\n\n        ", "while", "(pedge != ", "0", ") {\n            ", "pnext", " = pedge->", "next;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n", "// Print a path after search", "\nvoid print_path(weightedgraph* g, int dest){\n    ", "if", "( g->", "pred[dest] != ", "0", "){\n        ", "print_path", "(g, g->", "pred[dest]);\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n    ", "else", " ", "if", "(g->", "dist[dest]==", "0", "){\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n}\n\n\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["在Go中使用Gonum进行图算法", ["\n\n", "I am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a ", "graph package", "  that looks promising to use. ", "\n\n", "My problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. ", "\n\n", "The way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. ", "\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;单源即一个出发点到其他各点的距离&lt;br /&gt;多源即计算所有出发点到各点的距离&lt;br /&gt;两种算法本质上都是计算点到点的最短距离&amp;#xff0c;只是一个一次只能算一个点&amp;#xff0c;一个一次计算全部点&amp;#xff0c;如果前者加上循环就和后者在结果上没有区别了&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["图的最短路算法中，单源最短路问题和全源最短路问题，这里的单源和全源是什么意思？", ["初学图的最短路，发现书上有提到dijkstra解决单源最短路问题，Floyd解决全源最短路问题，但是书上没有解释这里的单源和全源是什么意思，指的是什么？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;按照你这个matlab代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;function [min,path]&amp;#61;dijkstra(w,start,terminal)\n%% 函数介绍\n%输入变量w为所求图的带权邻接矩阵&amp;#xff0c;start、terminal分别为路径的起点和终点的编号。\n%返回path为从start到termial的最短路径以及长度min\n&lt;span class=\"hljs-attribute\"&gt;n&lt;/span&gt;&amp;#61;size(w,1); label(start)&amp;#61;0; f(start)&amp;#61;start;\n%n为所求图的顶点个数&amp;#xff0c;label存放到各点的最短路径&amp;#xff0c;f(v)表示v的父顶点用来还原路径\n%初始化将除了start以外的顶点label均设置为无穷大\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; i~&amp;#61;start\nlabel(i)&amp;#61;inf;\nend\nend\n%s数组存放已经搜好的顶点集&amp;#xff0c;初始化只有start\ns(1)&amp;#61;start; &lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;start;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; length(s)&amp;lt;n\n%遍历一遍顶点&amp;#xff0c;将不在顶点集中的顶点选出来进行下面的&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;判定\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n%判断是否有中继顶点使得它们之间的距离更短&amp;#xff0c;如果有的话更新距离并更新前驱结点\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; label(v)&amp;gt;(label(u)&amp;#43;w(u,v))\nlabel(v)&amp;#61;(label(u)&amp;#43;w(u,v)); f(v)&amp;#61;u;\nend\nend\nend\n&lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;inf;\n%同上再次进行遍历&amp;#xff0c;找到目前最短的路径顶点v1&amp;#xff0c;放入顶点集并改变u的值\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; k&amp;gt;label(v)\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;label(v); &lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;v;\nend\nend\nend\ns(length(s)&amp;#43;1)&amp;#61;v1;\n&lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;v1;\nend\n\n&lt;span class=\"hljs-attribute\"&gt;min&lt;/span&gt;&amp;#61;label(terminal); path(1)&amp;#61;terminal;\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1;\n\n%按倒序结果推出最短路径\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; path(i)~&amp;#61;start\npath(i&amp;#43;1)&amp;#61;f(path(i));\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;i&amp;#43;1 ;\nend\npath(i)&amp;#61;start;\n&lt;span class=\"hljs-attribute\"&gt;L&lt;/span&gt;&amp;#61;length(path);\n%翻转得到最短路径\n&lt;span class=\"hljs-attribute\"&gt;path&lt;/span&gt;&amp;#61;path(L:-1:1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;并根据你给的点&amp;#xff0c;我写了个命令窗口代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;clc&lt;/span&gt;,clear\n&lt;span class=\"hljs-attribute\"&gt;w&lt;/span&gt;&amp;#61;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;inf,inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n&lt;span class=\"hljs-attribute\"&gt;start&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-attribute\"&gt;terminal&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;&lt;span class=\"hljs-meta\"&gt;\n[min,path]&amp;#61;dijkstra(w,start,terminal);\nmin,path&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行得出的结果是&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/764607253656172.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;并没有产生报错。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["一个问题算法的程序出现错误运行不出来", ["function [min,path]=dijkstra(w,start,terminal)", "%输入变量w为所求图的带权邻接矩阵，start、terminal分别为路径的起点和终点的编号。", "%返回path为从start到termial的最短路径以及长度min", "\n", "n=size(w,1); label(start)=0; f(start)=start;", "%n为所求图的顶点个数，label存放到各点的最短路径，f(v)表示v的父顶点用来还原路径", "\n", "%初始化将除了start以外的顶点label均设置为无穷大", "for i=1:n", "    if i~=start", "       label(i)=inf;", "    end", "end", "\n", "%s数组存放已经搜好的顶点集，初始化只有start", "s(1)=start; u=start;", "while length(s)<n", "    %遍历一遍顶点，将不在顶点集中的顶点选出来进行下面的if判定", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        %判断是否有中继顶点使得它们之间的距离更短，如果有的话更新距离并更新前驱结点", "        if ins==0", "            v=i;", "            if label(v)>(label(u)+w(u,v))", "                label(v)=(label(u)+w(u,v)); f(v)=u;", "            end", "        end", "    end", "    v1=0;", "    k=inf;", "    %同上再次进行遍历，找到目前最短的路径顶点v1，放入顶点集并改变u的值", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        if ins==0", "            v=i;", "            if k>label(v)", "                k=label(v);  v1=v;", "            end", "        end", "    end", "    s(length(s)+1)=v1;", "    u=v1;", "end", "\n", "min=label(terminal); path(1)=terminal;", "i=1; ", "\n", "%按倒序结果推出最短路径", "while path(i)~=start", "    path(i+1)=f(path(i));", "    i=i+1 ;", "end", "path(i)=start;", "L=length(path);", "%翻转得到最短路径", "path=path(L:-1:1);", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstra算法", "Question": ["ROS在进行导航时，出现一直下发角速度和线速度为0的情况", ["\n\n", "如图所示，在存在路径规划的情况下，一直下发线速度和角速度为0 的情况。", "\n\n", "\n", "局部规划采用的是DWA算法", "\n", "全局规划采用的是Dijkstra.", "\n", "膨胀系数设置是15厘米。\n小车放置在一个空旷区域", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;干了几年了&amp;#xff0c;你说的这些我一个都不会&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["写逻辑代码要很长的时间适合走后端吗？", ["(刚学习新算法后敲代码)", "哈夫曼基本实现编码用了两天(译码没写)", "棋盘覆盖用了6个小时", "dijkstra用了6个小时", "背包回溯用了4个小时", "二叉树基本操作包括结点数，度为1结点数等实现用了8个钟(递归)", "\n", "就感觉自己敲逻辑代码好慢，适合干后端吗，现在有点想走前端的想法"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;首先&amp;#xff0c;您需要安装 NetworkX 和 matplotlib 库来绘制图像。然后&amp;#xff0c;可以使用 NetworkX 库中的 draw 函数来绘制图。将图绘制到画布上&amp;#xff0c;然后将画布放置在您的用户界面中的相应位置即可。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;以下是一个例子&amp;#xff0c;其中使用 Tkinter 库创建了一个简单的用户界面&amp;#xff0c;并在其中绘制了一个无向图&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;import tkinter as tk\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n&lt;span class=\"hljs-comment\"&gt;# 创建一个窗口&lt;/span&gt;\nwindow &amp;#61; tk.Tk()\n\n&lt;span class=\"hljs-comment\"&gt;# 创建一个画布&lt;/span&gt;\ncanvas &amp;#61; tk.Canvas(window, &lt;span class=\"hljs-attribute\"&gt;width&lt;/span&gt;&amp;#61;600, &lt;span class=\"hljs-attribute\"&gt;height&lt;/span&gt;&amp;#61;600)\ncanvas.pack()\n\n&lt;span class=\"hljs-comment\"&gt;# 创建一个无向图&lt;/span&gt;\nG &amp;#61; nx.Graph()\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;1)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;7)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;3)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;5)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;9)\n\n&lt;span class=\"hljs-comment\"&gt;# 绘制图像&lt;/span&gt;\npos &amp;#61; nx.spring_layout(G)  # 使用 FR 算法排列节点\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\nlabels &amp;#61; nx.get_edge_attributes(G, &lt;span class=\"hljs-string\"&gt;&amp;#39;weight&amp;#39;&lt;/span&gt;)\nnx.draw_networkx_edge_labels(G, pos, &lt;span class=\"hljs-attribute\"&gt;edge_labels&lt;/span&gt;&amp;#61;labels, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\n\n&lt;span class=\"hljs-comment\"&gt;# 显示窗口&lt;/span&gt;\nwindow.mainloop()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码使用了 NetworkX 库中的 spring_layout 函数来排制节点的位置&amp;#xff0c;然后使用 draw 函数绘制图像。还使用了 get_edge_attributes 函数和 draw_networkx_edge_labels 函数来绘制边的标签。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["如何让无向图显示到用户界面里", ["\ndef main():\n            \n        \n       \n\n", "# 问题 2：无向图的最短路问题（司守奎，数学建模算法与应用，P43，例4.3）", "\n             G2 = nx.Graph()  # 创建：空的 有向图\n\n             G2.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)  # 添加 带权边，weight表示边权\n             G2.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n             G2.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n             G2.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n             G2.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n             G2.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n             G2.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# 两个指定顶点之间的最短加权路径", "\n             ", "source", "=nameEntry3.get()\n             ", "target", "=nameEntry4.get()\n             minWPath_v1_v5 = nx.dijkstra_path(G2, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n             return minWPath_v1_v5\n             # 两个指定顶点之间的最短加权路径的长度\n             lMinWPath_v1_v5 = nx.dijkstra_path_length(G2, source, target)  # 最短加权路径长度\n             return lMinWPath_v1_v5\n             plt.clf()\n             pos = nx.spring_layout(G2)  # 用 FR算法排列节点\n             nx.draw(G2, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5)\n             labels = nx.get_edge_attributes(G2, ", "'weight'", ")\n             nx.draw_networkx_edge_labels(G2, pos, ", "edge_labels", "=labels)\n              # plt.show()\n\n\n             edgeList = []\n             ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n             nx.draw_networkx_edges(G2, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4) \n             # 设置边的颜色\n             \n             plt.savefig(", "'path'", " +", "'.jpg'", ")\n             filename = ", "\".\\path.jpg\"", "\n             image = Image.open(filename)\n             photo = ImageTk.PhotoImage(image)\n             canvas.create_image(450,250,image = photo)\n             canvas.update()\n             time.sleep(sleep_time)\n      \n      frame_mid = Frame(", "width", "=800,height=100,bg='white') \n      frame_mid.grid(", "row", "=8,column=10,rowspan=6,columnspan=2,padx=4, ", "pady", "=5)\n      \n      canvas = Canvas(frame_mid,width = 800,height = 600,bg = ", "'#FFCCCC'", ")#画板\n      \n      canvas.grid()\n\n\n\n                \n\n            \n      def main2():\n            \n               \n               EditText.insert(tkinter.END,main())\n             \n      ", "EditText", "=tkinter.Text(window2,width=15,height=5)\n      EditText.grid(", "row", "=8,column=8)\n      def main3():\n          main()\n      \n        \n     \n      ", "q", "=tkinter.Button(window2,text=\"确定\", font=(", "'宋体'", ",15),", "command", "=main2)\n      q.grid(", "row", "=7,column=6)\n      ", "q", "=tkinter.Button(window2,text=\"确定\", font=(", "'宋体'", ",15),", "command", "=main3)\n      q.grid(", "row", "=7,column=8\n", "\n", "为什么我用networkx和canvas画的图显示不到tkinter里", "该如何让它显示呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你可以将画布作为绘图函数的第一个参数&amp;#xff0c;如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;nx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;canvas&lt;/span&gt;&amp;#61;canvas)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或者&amp;#xff0c;可以使用 FigureCanvasTkAgg 将画布绑定到 tkinter 窗口中&amp;#xff0c;例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfig &amp;#61; plt.figure(figsize&amp;#61;(5, 5))\ncanvas &amp;#61; FigureCanvasTkAgg(fig, &lt;span class=\"hljs-attribute\"&gt;master&lt;/span&gt;&amp;#61;window2)\ncanvas.get_tk_widget().grid(&lt;span class=\"hljs-attribute\"&gt;row&lt;/span&gt;&amp;#61;8, &lt;span class=\"hljs-attribute\"&gt;column&lt;/span&gt;&amp;#61;10)\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;fig&lt;/span&gt;&amp;#61;fig)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这种情况下&amp;#xff0c;应该使用 fig 而不是 canvas 作为绘图函数的第一个参数。&lt;/p&gt;\n&lt;p&gt;请注意&amp;#xff0c;如果使用 FigureCanvasTkAgg&amp;#xff0c;则需要导入 matplotlib.pyplot 模块&amp;#xff0c;并使用 plt.figure 创建一个新图表。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["怎么让我画的无向图显示在canvas画布上", ["\ndef main3():\n          canvas = tkinter.Canvas(window2, ", "width", "=50, ", "height", "=50)\n          canvas.grid(", "row", "=8,column=10)\n\n", "# 创建一个无向图", "\n          G = nx.Graph()\n          G.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)\n          G.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n          G.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n          G.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n          G.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n          G.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n          G.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# 绘制图像", "\n          ", "source", "=nameEntry3.get()\n          ", "target", "=nameEntry4.get()\n \n          minWPath_v1_v5 = nx.dijkstra_path(G, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n                \n", "# 两个指定顶点之间的最短加权路径的长度", "\n          \n          pos = nx.spring_layout(G)  # 使用 FR 算法排列节点\n          nx.draw(G, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5,on=canvas)\n          labels = nx.get_edge_attributes(G, ", "'weight'", ")\n          nx.draw_networkx_edge_labels(G, pos, ", "edge_labels", "=labels)\n          edgeList = []\n          ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                  edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n                  nx.draw_networkx_edges(G, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4,on=canvas)\n\n            \n          \n      \n", "\n", "怎么让我画的无向图显示在canvas画布上"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这是一个实现迪杰斯特拉算法的代码&amp;#xff0c;用于求解单源最短路径问题。该算法是一种贪心算法&amp;#xff0c;每次求解的时候都会找到当前能到达的点中距离起点最近的点&amp;#xff0c;并从该点开始搜索下一步能到达的点&amp;#xff0c;直到到达终点。&lt;/p&gt;\n&lt;p&gt;具体来说&amp;#xff0c;代码中使用了三个栈&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1、stack 栈用来存储搜索路径中的点。&lt;br /&gt;2、stackdata 栈用来存储每条边的距离。&lt;br /&gt;3、stackfindlj 栈用来存储所有可能的路径&amp;#xff0c;其中的每一行都是一条路径&amp;#xff0c;第一个元素为起点&amp;#xff0c;其余的元素为路径中的每个点。&lt;br /&gt;首先&amp;#xff0c;从起点开始搜索&amp;#xff0c;如果找到了一条边且这条边还没有访问过&amp;#xff0c;就将这条边加入路径中&amp;#xff0c;并将这条边的距离加入路径距离中。然后从这条边的终点开始继续搜索&amp;#xff0c;如果能找到一条边且这条边还没有访问过&amp;#xff0c;就将这条边加入路径中&amp;#xff0c;并将这条边的距离加入路径距离中。重复这个过程直到到达终点&amp;#xff0c;或者找不到新的边可以加入路径中。&lt;/p&gt;\n&lt;p&gt;所有的路径被保存在 stackfindlj 中&amp;#xff0c;其中的每一行都是一条路径。接下来&amp;#xff0c;遍历所有的路径&amp;#xff0c;找到路径距离最小的路径。将这条最短路径的信息复制到一个名为 temp 的结构体中&amp;#xff0c;并返回这个结构体。&lt;/p&gt;\n&lt;p&gt;这个结构体中包含两个信息&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1、stack 数组用来存储最短路径中的点。&lt;br /&gt;2、jl 变量用来存储最短路径的距离。&lt;/p&gt;\n&lt;p&gt;如果想输出最短路径的途径点信息&amp;#xff0c;可以在输出路径距离之后添加以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;最短路径为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp.stack[i] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, temp.stack[i]);\n  }\n}\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这段代码会依次输出最短路径中的所有点。&lt;br /&gt;仅供参考&amp;#xff0c;望采纳&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["构造了一个迪杰斯特拉函数，但是不会得出最短路径的途径点信息，需要更详细的注释", ["问题遇到的现象和发生背景 构造了一个计算函数，如何得到最短路径的点的信息以及需要更详细的注释", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "struct ", "MyStack", "  \n{\n    int stack[", "50", "];//栈\n    int jl;//距离\n};\n//迪杰斯特拉算法\n", "MyStack", " ", "Dijkstra", "(map ", "Map", ", int d, int e)//d设为起点,e设为终点\n{\n    int stack[", "50", "] = { ", "0", " }, id1 = ", "0", ";\n    int stackdata[", "50", "] = { ", "0", " }, id2 = ", "0", ";\n    int stackfindlj[", "50", "][", "50", "] = { ", "0", " }, id3 = ", "0", ";//路径保存\n    int stackfindjl[", "50", "] = { ", "0", " };//距离保存\n    int isfind = ", "0", ";\n    for (int i = d; i < d + ", "1", "; i++)\n    {\n        for (int j = i; j < ", "12", "; j++)\n        {\n            int edge[", "12", "][", "12", "] = { ", "0", " };//辅助地图\n            if (", "Map", ".edge[i][j] != ", "100", " && ", "Map", ".edge[i][j] != ", "0", " && edge[i][j] == ", "0", ")\n            {\n                stack[id1++] = j;\n                stackdata[id2++] = ", "Map", ".edge[i][j];//边的距离\n                edge[i][j] = ", "1", ";//辅助地图\n                while (id1)\n                {\n                    for (int k = stack[id1 - ", "1", "]; k < ", "12", "; k++)\n                    {\n                        if (", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "100", " && ", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "0", " && edge[stack[id1 - ", "1", "]][k] == ", "0", ")//开始搜寻路径\n                        {\n                            edge[stack[id1 - ", "1", "]][k] = ", "1", ";\n                            stackdata[id2++] = ", "Map", ".edge[stack[id1 - ", "1", "]][k];\n                            stack[id1++] = k;\n                            if (k == e)//到达了终点\n                                isfind = ", "1", ";\n                            break;\n                        }\n                        if (k == ", "11", ")\n                        {\n                            id1--; id2--;\n                        }\n                    }\n                    if (isfind == ", "1", ")\n                    {\n                        stackfindlj[id3][", "0", "] = i + ", "1", ";\n                        for (int k = ", "0", "; k < id1; k++)\n                        {\n                            stackfindlj[id3][k + ", "1", "] = stack[k] + ", "1", ";\n                            stackfindjl[id3] += stackdata[k];\n                        }\n                        id3++;\n                        isfind = ", "0", ";\n                    }\n                }\n            }\n        }\n    }\n    int min = stackfindjl[", "0", "], minidx = ", "0", ";\n    for (int i = ", "0", "; i < id3; i++)\n    {\n        if (min > stackfindjl[i])\n        {\n            min = stackfindjl[i];\n            minidx = i;\n        }\n    }\n    ", "MyStack", " temp = { ", "0", " };\n    memcpy(&temp.stack, &stackfindlj[minidx], sizeof(int) * ", "50", ");//将得到的最短路径复制到结构体的数组之中\n    temp.jl = min;//将得到的最短距离赋值到结构体的距离中\n    printf(", "\"最短路径距离为：%d\\n\"", ", temp.jl);\n    return temp;\n\n", "\n", "运行结果及详细报错内容", "\n", "只会输出最短距离", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "迪杰斯特拉函数", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;应该是没有visited数组标记的问题&amp;#xff0c;存边是存双向边&amp;#xff0c;需要标记visited&amp;#xff08;有时也叫used&amp;#xff09;数组进行标记这个点已经到达过了&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["洛谷P1462 dij的问题", ["https://www.luogu.com.cn/problem/P1462", "\n", "https://www.luogu.com.cn/record/78581018", "\n", "只对了3个点，都是无解点，也就是说dij可能不对", "\n", "#", "include", "<bits/stdc++.h>", "\n", "#", "define", " INF 0x3f3f3f3f", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", " MAXN=", "10008", ";\n", "typedef", " pair<", "int", ",", "int", "> pi;\npriority_queue< pi,vector<pi>,greater<pi> > q;\n", "int", " n,m,b;\n", "int", " f[MAXN],dis[MAXN];\n", "struct", " ", "node", "{\n    ", "int", " v,w;\n};\nvector<node> a[MAXN];\n", "bool", " vis[MAXN];\n", "int", " l=INT_MAX,r=INT_MIN,mid;\n", "bool", " ", "dijkstra", "(", "int", " st)", "{\n    ", "memset", "(vis,", "0", ",", "sizeof", "(vis));\n    ", "memset", "(dis,INF,", "sizeof", "(dis));\n    dis[", "1", "]=st;\n    q.", "push", "({", "make_pair", "(dis[", "1", "],", "1", ")});\n    ", "while", "(!q.", "empty", "()){\n        ", "int", " x=q.", "top", "().second;\n        q.", "pop", "();\n        ", "if", "(vis[x]) ", "continue", ";\n        vis[x]=", "true", ";\n        ", "for", "(", "int", " i=", "0", ";i<a[x].", "size", "();i++){\n            ", "int", " y=a[x][i].v,z=a[x][i].w;\n            dis[y]=", "min", "(dis[y],dis[x]+z);\n            q.", "push", "(", "make_pair", "(dis[y],y));\n        }\n    }\n    ", "return", " dis[n]<b;\n}\n", "int", " ", "main", "()", "{\n    ", "scanf", "(", "\"%d%d%d\"", ",&n,&m,&b);\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "scanf", "(", "\"%d\"", ",&f[i]);\n        l=", "min", "(l,f[i]);\n        r=", "max", "(r,f[i]);\n    }\n    ", "int", " maxi=r;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "int", " u,v,w;\n        ", "scanf", "(", "\"%d%d%d\"", ",&u,&v,&w);\n        a[u].", "push_back", "({v,w});\n        a[v].", "push_back", "({u,w});\n    }\n    ", "while", "(l<=r){\n        mid=(l+r)/", "2", ";\n        ", "if", "(", "dijkstra", "(mid)) r=mid", "-1", ";\n        ", "else", " l=mid+", "1", ";\n    }\n    ", "if", "(l==maxi+", "1", ") \n        ", "printf", "(", "\"AFK\\n\"", ");\n    ", "else", "\n        ", "printf", "(", "\"%d\\n\"", ",l);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "求给出以如上代码改对了的代码或修改方式，谢谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我试着照着你的deque输出的代码写了一个测试&amp;#xff0c;可以正常输出&amp;#xff0c;所以问题应该不在这里&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["问题：为什么用deque反向输出会报错而用递归反向输出没问题", ["http://poj.org/problem?id=2457", "（由于题目是英文，以下图片时中文翻译后的图片）", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1", "\n", "（由于题目是英文，以下图片时中文翻译后的图片）", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "1", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "1", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<", "int", "> stars;\n", "void", " ", "print_stars", "()", "\n", "{\n \n    \n    stars.", "push_front", "(n);\n    k=n;\n    ", "while", "(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.", "push_front", "(k);\n    }\n    stars.", "push_front", "(s);\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    cin>>m>>n;\n", "//    if(n==1)", "\n", "//    {", "\n", "//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';", "\n", "//    }", "\n", "//    else{", "\n    \n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);", "\n        }\n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]<<", "'\\n'", ";\n            ", "print_stars", "();\n            ", "while", "(stars.", "size", "())\n            {\n                cout<<stars.", "front", "()<<", "'\\n'", ";\n                stars.", "pop_front", "();\n            }\n", "//        }", "\n    }\n    ", "return", " ", "0", ";\n}\n \n\n", "\n", "（以下时将deque该换成递归之后可以通过的代码）", "\n", " \n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "0", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "0", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\n", "//deque<int> stars;", "\n", "//void print_stars()", "\n", "//{", "\n", "//", "\n", "//    ", "\n", "//    stars.push_front(n);", "\n", "//    k=n;", "\n", "//    while(vis0[k]!=s)", "\n", "//    {", "\n", "//        k=vis0[k]; ", "\n", "//        stars.push_front(k);", "\n", "//    }", "\n", "//    stars.push_front(s);", "\n", "//}", "\n", "void", " ", "printf_path", "(", "int", " vertax)", "\n", "{\n    ", "if", "(vis0[vertax] != ", "-1", " ) ", "printf_path", "(vis0[vertax]);\n    cout<<vertax<<", "'\\n'", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    ", "memset", "(vis0,", "-1", ",", "sizeof", " vis0);\n    cin>>m>>n;\n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);    ", "\n        }\n    ", "if", "(n==", "1", ")\n    {\n        cout<<", "\"1\"", "<<", "'\\n'", "<<", "\"1\"", "<<", "'\\n'", ";\n    }\n    ", "else", "{\n    \n    \n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]+", "1", "<<", "'\\n'", ";\n            ", "printf_path", "(n);\n", "//            while(stars.size())", "\n", "//            {", "\n", "//                cout<<stars.front()<<'\\n';", "\n", "//                stars.pop_front();", "\n", "//            }", "\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;可以参考一下&lt;a href=\"https://blog.csdn.net/weixin_41598179/article/details/112795877\" id=\"textarea_1652959433332_1652959657006_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C语言——最短路径问题&amp;#xff08;Dijkstra算法&amp;#xff09;_秋米姐姐的博客-CSDN博客_c语言求最短路径&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;C语言——最短路径问题&amp;#xff08;Dijkstra算法&amp;#xff09;优点——适用范围广&amp;#xff0c;本代码属于公式型代码&amp;#xff0c;可随意更换数据&amp;#xff0c;适合零基础同学。主要思路&amp;#xff1a;主要思路&amp;#xff1a;1.用一个二维数组存放带权有向图的邻接矩阵&amp;#xff1b;2.基于Dijkstra算法分别申请三个数组&amp;#xff0c;distance[], path[], used[]分别记录从起点到其余各点的最短距离&amp;#xff0c;到目标结点路径上的前一个结点&amp;#xff0c;到图中某个结点是否已找到最短路径&amp;#xff1b;3.逐渐确定从源点到图中各结点的最短路径&amp;#xff0c;直至结束&amp;#xff1b;最短路径例题&amp;#xff1a;如下图所示&amp;#xff0c;求最短经。&amp;lt;fn代码&amp;#xff1a;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/weixin_41598179/article/details/112795877&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["【c语言】【数据结构】Dijkstra算法求最快送餐路径", ["输入：第一行包含3个整数n,m,t，分别表示路口的个数，道路的条数和目的路口。", "（2 ≤ n ≤ 10，1 ≤ m ≤ 50，1 ≤ w ≤ 10）", "接下来m行每行包含三个整数 u,v,w，表示路口u到路口v存在一条耗时w的单行道。", "输出：骑手从商家（位于1号路口）到目的路口的最短时间，若路径不存在，输出-1。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;用Dijkstra算法求从顶点0出发的最短路径。简单来说&amp;#xff0c;就是从起点开始&amp;#xff0c;不断地选取未访问的距离起点最近的顶点&amp;#xff0c;并更新该顶点到其他顶点的距离。这样不断执行直到所有顶点都被访问过&amp;#xff0c;得到起点到各个顶点的最短路径。&lt;/p&gt;\n&lt;p&gt;接着&amp;#xff0c;给出了算法执行的某时刻&amp;#xff0c;即已经访问了0、2、3、4四个顶点。这意味着此时已经找到了从起点到这些顶点的最短路径。&lt;/p&gt;\n&lt;p&gt;最后&amp;#xff0c;需要在这个时刻选取下一步目标顶点。因为题目没有给出完整的图&amp;#xff0c;所以我也不知道顶点D与0、2、3、4之间的连边情况。因此无法确定顶点D是否为下一步的目标顶点。&lt;/p&gt;\n&lt;p&gt;因此&amp;#xff0c;选项A、B、C、D中只有选项D是无法确定的&amp;#xff0c;其他三个选项的顶点都不是下一步的目标顶点的可能性比较小&amp;#xff0c;但需要具体情况具体分析。如果需要确定下一步目标顶点&amp;#xff0c;需要知道顶点D与0、2、3、4之间的连边情况。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["Dijkstra算法的问题", ["用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻，S={0,2,3,4}，下一步选取的目标顶点可能是   D   。", "A.顶点2            B.顶点3            C.顶点4            D.顶点7", "表达的是啥意思嘞，顶点7又是怎么出来的嘞"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/a19990412/article/details/80232810\" id=\"textarea_1655439466811_1655439572959_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;迪杰斯特拉算法&amp;#xff08;Dijkstra&amp;#xff09;证明_肥宅_Sean的博客-CSDN博客_迪杰斯特拉算法证明&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;首先&amp;#xff0c;这篇文章是在讲《图论》时候写文章&amp;#xff08;所以&amp;#xff0c;还是以理论为主&amp;#xff0c;以后有空的时候&amp;#xff0c;会把代码发上来&amp;#xff0c;不过我觉得大家看完理论&amp;#xff0c;如果讲得好&amp;#xff0c;代码也就比较容易了。如果讲得不好&amp;#xff0c;网上的代码也是大把&amp;#xff0c;不看这篇文章也罢了&amp;#xff09;下图为老师的课件内容部分&amp;#xff0c;我觉得虽然详尽&amp;#xff0c;但也有些枯燥。可能是为了凝练语言吧。如果有耐心看的话&amp;#xff0c;倒真的是一篇非常好的文章。&amp;#xff08;反正这个应该是比百度百科要强的….&amp;#xff09; 我在后面会用自己的语言阐...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/a19990412/article/details/80232810&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["证明证明Dijkstra算法正确性，并分析时间复杂度", ["证明Dijkstra算法正确性，并分析在未优化的情况下其平均情况下时间复杂度。假设图为G=(V,E)", "\n", "要求：c/c++，有证明过程"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;段错误一般是数组下标越界&lt;br /&gt;或者指针没有正确指向或没有分配空间&lt;br /&gt;参考代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; namespace std;\nstruct Node {\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x, y;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n};\nstruct TS {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; distant;\n};\n\nTS HHH[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N, &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; D, G[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\nNode Dist[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; visit[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-keyword\"&gt;false&lt;/span&gt;};\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i);\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; cmp(TS a, TS b) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.distant &amp;lt; b.distant;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main() {\n    cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; D;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;32.5&lt;/span&gt;) {\n        printf(&amp;#34;1\\n&amp;#34;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; X, Y;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tol &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fill(G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], G[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; &lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        cin &amp;gt;&amp;gt; X &amp;gt;&amp;gt; Y;\n        HHH[i].num &amp;#61; i;\n        Dist[i].x &amp;#61; X;\n        Dist[i].y &amp;#61; Y;\n        Dist[i].distant &amp;#61; sqrt(X * X &amp;#43; Y * Y);\n        HHH[i].distant &amp;#61; Dist[i].distant;\n        Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt; N; j&amp;#43;&amp;#43;) {\n            Init(i, j);\n        }\n    }\n    \n    sort(HHH, HHH &amp;#43; N, cmp);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (HHH[i].distant &amp;gt; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; HHH[i].distant &amp;lt;&amp;#61; D &amp;#43; &lt;span class=\"hljs-number\"&gt;7.5&lt;/span&gt; &amp;amp;&amp;amp; !visit[HHH[i].num]) {\n            tol &amp;#61; BFS(HHH[i].num);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) break;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (tol &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) printf(&amp;#34;0\\n&amp;#34;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Init(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j) {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; Dist[i].x - Dist[j].x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y &amp;#61; Dist[i].y - Dist[j].y;\n    G[i][j] &amp;#61; G[j][i] &amp;#61; sqrt(x * x &amp;#43; y * y);\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Judge(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((Dist[i].x &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].x - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;) || (Dist[i].y &amp;#43; D &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;) || (Dist[i].y - D &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;-50&lt;/span&gt;)) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; BFS(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i) {\n\n    visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n    Dist[i].c &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    queue&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; Q;\n    Q.push(i);\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!Q.empty()) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; Q.front();\n        Q.pop();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (Judge(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;)) {\n            cout &amp;lt;&amp;lt; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; endl;\n            stack&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; st;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;) {\n                st.push(&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;];\n            }\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!st.empty()) {\n                &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Top &amp;#61; st.top();\n                st.pop();\n                cout &amp;lt;&amp;lt; Dist[Top].x &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; Dist[Top].y &amp;lt;&amp;lt; endl;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (G[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;][i] &amp;lt;&amp;#61; D &amp;amp;&amp;amp; !visit[i]) {\n                visit[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;true&lt;/span&gt;;\n                Dist[i].c &amp;#61; Dist[&lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;].c &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;;\n                Q.push(i);\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["数据结构习题，图的Dijkstra算法", ["题目如下", "\n", "This time let us consider the situation in the movie \"Live and Let Die\" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head（省略号） Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).", "\n", "Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.", "\n", "Input Specification:", "Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.", "\n", "Output Specification:", "For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.", "\n", "\n", "\n", "我的代码", "\n", "//自己写的，半错版本 ", "\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n#define MaxVertexNum ", "105", "\n#define M_INFINITY ", "65535", "\ntypedef int Vertex;\ntypedef double WeightType;\ntypedef struct Data{\n    int X,Y;\n}DataType[MaxVertexNum];\n\n", "/*边的定义*/", "\ntypedef struct ENode* PtrToENode;\nstruct ENode{\n    Vertex V1,V2;\n    WeightType Weight; \n};\ntypedef PtrToENode Edge;\n\n", "/*图的定义*/", "\ntypedef struct GNode* PtrToGNode;\nstruct GNode{\n    int Nv;\n    int Ne;\n    WeightType D[MaxVertexNum][MaxVertexNum];\n    DataType Locate;\n};\ntypedef PtrToGNode MGraph;\n\n", "//创造图的函数", "\nvoid InsertEdge(MGraph Graph, Edge E)\n{\n    G", "raph", "->", "D[E->V1][E->V2] = E->Weight;\n    G", "raph", "->", "D[E->V2][E->V1] = E->Weight;\n}\nMGraph CreatGraph(int VertexNum)\n{", "/*初始化一个图结构，所有对角边为0，非对角边为INFINITY*/", "\n    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));\n    G", "raph", "->", "Nv = VertexNum;\n    G", "raph", "->", "Ne = ", "0", ";\n    int V,W;\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V;W<Graph->", "Nv;W++){\n            ", "if", "(V!=W){\n                G", "raph", "->", "D[V][W] = M_INFINITY;\n                G", "raph", "->", "D[W][V] = M_INFINITY;\n            }", "else", "{\n                G", "raph", "->", "D[V][W] = ", "0", ";\n            }\n        }\n    }\n    return Graph;\n}\nWeightType Length(double X1,double Y1,double X2,double Y2)\n{", "/*返回两个点的直线距离*/", "\n    double deltx = X1-X2;\n    double delty = Y1-Y2;\n    WeightType weight = ", "sqrt", "(deltx*deltx + delty*delty);\n    return weight;\n}\nMGraph BuildGraph(int Nv,double D)\n{", "/*创造图*/", "\n    int i,V,W;\n    Vertex X,Y;\n    WeightType Weight;\n    MGraph Graph = CreatGraph(Nv+", "1", ");\n    Edge E = (Edge)malloc(sizeof(struct ENode));\n    \n    V=", "1", ";\n    G", "raph", "->", "L", "ocate", "[0].X = Graph->", "Locate[", "0", "].Y = ", "0", ";\n    ", "for", "(i=", "1", ";i<=Nv;i++){\n        scanf(", "\"%d%d\"", ",&X,&Y);\n        \n        ", "if", "(", "abs", "(X)<", "50", " && ", "abs", "(Y)<", "50", " && Length(X,Y,", "0", ",", "0", ")>", "7.5", "){\n            G", "raph", "->", "Locate[V].X = X;\n            G", "raph", "->", "Locate[V].Y = Y;\n            V++;\n        }", "else", "{\n            G", "raph", "->", "Nv--;\n        }\n    }\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "for", "(W=V+1;W<Graph->", "Nv;W++){\n            W", "eight", " = Length(Graph->", "L", "ocate", "[V].X,Graph->", "Locate[V].Y,\n            G", "raph", "->", "L", "ocate", "[W].X,Graph->", "Locate[W].Y);\n            ", "if", "(Weight<=D){\n                E->V1 = V;\n                E->V2 = W;\n                E->Weight = Weight;\n                ", "if", "(E->", "V1==", "0", ") E->Weight-=", "7.5", ";\n                InsertEdge(Graph,E);\n            }\n        }\n    }\n    \n    return Graph;\n}\n\nVertex FindMinDist(MGraph Graph, double dist[], int collected[])\n{\n    Vertex MinV, V;\n    int MinDist = M_INFINITY;\n    \n    ", "for", "(V=0; V<Graph->", "Nv; V++){\n        ", "if", "(collected[V]==", "0", " && dist[V]<MinDist){\n            MinDist = dist[V];\n            MinV = V;\n        }\n    }\n    ", "if", "( MinDist < M_INFINITY )\n        return MinV;\n    ", "else", " return ", "0", ";\n}\nvoid Dijkstra(MGraph Graph, double* dist, int* ", "path", ",int* collected)\n{\n    Vertex V,W;\n    \n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "dist", "[V] = Graph->", "D[", "0", "][V];\n        ", "if", "(dist[V]<M_INFINITY)\n            ", "path", "[V] = ", "0", ";\n        ", "else", "\n            ", "path", "[V] = -", "1", ";\n        collected[V] = ", "0", ";\n    }\n    ", "/*先将起点收入集合*/", "\n    dist[", "0", "] = ", "0", ";\n    collected[", "0", "] = ", "1", ";\n    \n    ", "while", "(", "1", "){\n        V = FindMinDist(Graph,dist,collected);\n        ", "if", "(V==", "0", ")\n            break;\n        collected[V] = ", "1", ";\n        ", "for", "(W=0;W<Graph->", "Nv;W++)\n            ", "if", "(collected[W]==0 && Graph->", "D[V][W]<M_INFINITY){\n                ", "if", "(dist[V]+Graph->", "D[V][W]<dist[W]){\n                    ", "dist", "[W] = dist[V]+Graph->", "D[V][W];\n                    ", "path", "[W] = V; \n                }\n            }\n    }\n}\n\nint min(int x,int y)\n{\n    ", "if", "(x<y) return x;\n    ", "else", " return y;\n}\n\nint main()\n{\n    ", "/*输入数，（初始Nv，可能会更少），输入JanesBond一次最远跳*/", "\n    int N,D,i;\n    scanf(", "\"%d%d\"", ",&N,&D);\n    ", "/*创造图*/", "\n    MGraph Graph = BuildGraph(N,D);\n    ", "/*初始化dist[],path[],collected[]*/", "\n    ", "double", " dist[Graph->", "Nv];\n    ", "int", " ", "path", "[Graph->", "N", "v", "],collected[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        dist[i] = M_INFINITY;\n        ", "path", "[i] = -", "1", ";\n        collected[i] = ", "0", ";\n    }\n    ", "/*Dijkstra算法算dist*/", "\n    Dijkstra(Graph,dist,", "path", ",collected);\n    \n    ", "/*找到可以作为出口得鳄鱼，同时将它到出口的距离存储到数组中*/", "\n    V", "ertex", " V,W,OutNode[Graph->", "Nv];\n    int flag = ", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++) OutNode[V]=", "0", ";\n    ", "for", "(V=0;V<Graph->", "Nv;V++){\n        ", "if", "(50-fabs(Graph->", "L", "ocate", "[V].X)<=D || 50-fabs(Graph->", "Locate[V].Y)<=D){\n            ", "if", "(50-fabs(Graph->", "Locate[V].X)<=D){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }", "else", " ", "if", "(50-fabs(Graph->", "Locate[V].Y<=D)){\n                O", "utNode", "[V] = 50-fabs(Graph->", "Locate[V].X);\n            }\n            flag=", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    flag = ", "0", ";\n    ", "for", "(W=1;W<Graph->", "Nv;W++){\n        ", "if", "(Graph->", "D[", "0", "][W]!=M_INFINITY){\n            flag = ", "1", ";\n        }\n    }\n    ", "if", "(!flag){\n        printf(", "\"0\"", ");\n        return ", "0", ";\n    }\n    ", "/*以上为判断是否有可能可以出去，也就是1>Island有没有邻接点，2>有没有可以跳出去的鳄鱼*/", "\n\n    ", "/*\n    找最短路\n    1.找可以出去的路径\n    2.比较可以出去的路径中最短路径 \n    */", "\n    \n    V", "ertex", " OutWay[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        OutWay[i]=-", "1", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(50-", "abs", "(Graph->", "L", "ocate", "[i].X)<=D || 50-", "abs", "(Graph->", "Locate[i].Y)<=D){\n            O", "utWay", "[i] = min(50-", "abs", "(Graph->", "L", "ocate", "[i].X),50-", "abs", "(Graph->", "Locate[i].Y));\n        }\n    }\n    \n    \n    ", "/*从出口中更新路径长度*/", "\n    ", "double", " Outdist[Graph->", "Nv];\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        Outdist[i] = ", "0", ";\n    }\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            Vertex temNode = i;\n            ", "while", "(temNode){\n                Outdist[i]+=dist[temNode];\n                temNode = ", "path", "[temNode];\n            }\n        }\n    }\n    \n    ", "/*从路径中找最小长，并记录*/", "\n    Vertex MinWay;\n    double Mindist=M_INFINITY;\n    ", "for", "(i=0;i<Graph->", "Nv;i++){\n        ", "if", "(OutWay[i]!=-", "1", "){\n            ", "if", "(Mindist>Outdist[i]){\n                Mindist = Outdist[i];\n                MinWay = i;\n            }\n        }\n    }\n    \n    ", "/*从最小路径中找结点，反向输出*/", "\n    V", "ertex", " Stack[Graph->", "Nv];\n    int rear=-", "1", ",count=", "1", ";\n    Vertex temNode = MinWay;\n    ", "while", "(temNode){\n        Stack[++rear] = temNode;\n        temNode = ", "path", "[temNode];\n        count++;\n    }\n    printf(", "\"%d\\n\"", ",count);\n    ", "while", "(rear!=-", "1", "){\n        ", "printf", "(\"%d %d\\n\",Graph->", "L", "ocate", "[Stack[rear]].X,Graph->", "Locate[Stack[rear]].Y);\n        rear--;\n    }\n    \n    return ", "0", ";\n}\n\n", "\n", "最后结果", "\n", "\n", "实在不知道哪错了，最初是前三项都通过了，后来就从头再来一遍，哪知道现在后面几个对了第一个项目说段错误，段错误给的理由如下", "\n", "\n", "不过现在测试点也不知道哪错了，麻烦看看吧"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;邻接表你可以理解为多个链表&amp;#xff0c;每个链表的头是一个节点&amp;#xff0c;而你添加一条边add&amp;#xff08;a,b,c&amp;#xff09;相当于给a增添一个出度b长度为c&amp;#xff0c;而 next[a]中储存的是就是a所有的出度的地址&amp;#xff0c;next存储的是下一个出度的地址&amp;#xff0c;ver[i]就是出度点的标号&amp;#xff0c;edge[i]头节点到出度的距离&amp;#xff0c;dj的基本思路是每次选取一个离原点最近的边来更新其他点的距离&amp;#xff0c;我们先将{0&amp;#xff0c;1}加入堆中&amp;#xff0c;堆排序pair根据first优先原则&amp;#xff0c;所以意思就是堆中1号点到一号点的距离为0&amp;#xff0c;那么此时会用1号点先更新它出度&amp;#xff0c;并且每个点有且只会被加入一次&amp;#xff0c;我们将它打上标记&amp;#xff0c;如果堆中已经加入过这个最短边&amp;#xff0c;我们直接将它continue&amp;#xff0c;否则而循环的终点就是没有边再被更新的时候&amp;#xff0c;也就是没有东西可以入队了&amp;#xff0c;循环结束。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["Dijkstra算法及邻接表 C++", ["priority_queue<pair<", "int", ",", "int", ">>q;", "//大根堆-小根堆", "\n    ", "memset", "(d,", "0x3f", ",", "sizeof", "(d);\n    ", "memset", "(v,", "0", ",", "sizeof", "(v));\n    d[", "1", "]=", "0", ";\n    q.", "push", "(", "make_pair", "(", "0", ",", "1", "));\n    ", "while", "(q.", "size", "())\n    ", "int", " x=q.", "top", "().second;q.", "pop", "();\n    ", "if", "(v[x])", "continue", ";\n    v[x]=", "1", ";\n    ", "for", "(", "int", " i=head[x];i;i=Next[i])\n    ", "int", " y=ver[i],z=edge[i];\n    ", "if", "(d[y]>d[x]+z){\n        d[y]=d[x]+z;\n        q.", "push", "(", "make_pair", "(-d[y],y));\n    }\n    } \n", "\n", "如上，请问一下：", "\n", "while", "(q.", "size", "())\n", "if", "(v[x])", "continue", ";\n", "for", "(", "int", " i=head[x];i;i=", "Next", "[i])\n", "\n", "各是什么意思？还有邻接表的原理是什么？麻烦了！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;不行。因为各种路径的 步数并不一定相同。&lt;br /&gt;所有边权值加正数&amp;#xff0c;只有在各种路径步数相同的情况下才可行。&lt;br /&gt;求带负权值边的单源最短路径可以用贝尔曼-福特算法。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗", ["迪杰斯特拉算法带负权值，每条边权值同时加上一个数全都变为正数，再用迪杰斯特拉算法 这样对吗"]], "Tag": "算法设计"}
{"Answer": "可以有偿啊，大神快来啊![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)![图片说明](http://forum.csdn.net/PointForum/ui/scripts/csdn/Plugin/001/face/9.gif)", "Konwledge_Point": "Dijkstra算法", "Question": ["OPNET卫星网络路由算法仿真", ["最近要交毕设啦，OPNET的卫星网络路由仿真还不会做，求大神指导啊，真的很着急。算法主要", "\n是收集链路状态信息，比如时延、带宽、丢包率，然后归一化到[0,1]，分配权重作为", "\n链路的Cost，然后用Dijkstra算法。", "\n求指导啊，怎么做仿真，呜呜呜~"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;如果想要在遍历图中的所有点之后得到最优路径&amp;#xff0c;可以使用一种叫做旅行商问题&amp;#xff08;Travelling Salesman Problem&amp;#xff0c;TSP&amp;#xff09;的算法。TSP 问题是指寻找遍历一个给定的城市列表的最短路径的问题。&lt;/p&gt;\n&lt;p&gt;以下是一个示例实现&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;def tsp(self, &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;, end):\n    &lt;span class=\"hljs-comment\"&gt;# 初始化未遍历的点的集合&lt;/span&gt;\n    unvisited &amp;#61; set(self.nodes)\n    &lt;span class=\"hljs-comment\"&gt;# 将起始点加入到已遍历的点的集合中&lt;/span&gt;\n    visited &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;}\n    &lt;span class=\"hljs-comment\"&gt;# 初始化当前点为起始点&lt;/span&gt;\n    current &amp;#61; &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#初始化路径和距离为 0&lt;/span&gt;\n    path &amp;#61; []\n    distance &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\nwhile unvisited:\n    &lt;span class=\"hljs-comment\"&gt;# 寻找当前点的最近的未遍历的点&lt;/span&gt;\n    next_node, next_distance &amp;#61; min([(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt;) for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;not&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; visited], &lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x: x[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# 将最近的未遍历的点加入到已遍历的点的集合中&lt;/span&gt;\n    visited.add(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# 从未遍历的点的集合中删除最近的未遍历的点&lt;/span&gt;\n    unvisited.remove(next_node)\n    &lt;span class=\"hljs-comment\"&gt;# 更新当前点为最近的未遍历的点&lt;/span&gt;\n    current &amp;#61; next_node\n    &lt;span class=\"hljs-comment\"&gt;# 更新路径和距离&lt;/span&gt;\n    path.append(next_node)\n    distance &amp;#43;&amp;#61; next_distance\n\n&lt;span class=\"hljs-comment\"&gt;# 如果最后一个遍历的点不是终点&amp;#xff0c;添加一条从最后一个遍历的点到终点的边&lt;/span&gt;\nif current !&amp;#61; end:\n    &lt;span class=\"hljs-comment\"&gt;# 寻找最后一个遍历的点到终点的最短距离&lt;/span&gt;\n    next_distance &amp;#61; min([cost for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, cost&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; self.adjacency_list[current] if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;&amp;#61;&amp;#61; end&lt;/span&gt;])\n    &lt;span class=\"hljs-comment\"&gt;# 更新路径和距离&lt;/span&gt;\n    path.append(end)\n    distance &amp;#43;&amp;#61; next_distance\n\nreturn path, distance\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以使用这个方法来解决 TSP 问题&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;graph &amp;#61; Graph(&lt;span class=\"hljs-string\"&gt;&amp;#39;map.txt&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;, distance &amp;#61; graph.tsp(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;path&lt;/span&gt;)  # [&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(distance)  # &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;仅供参考&amp;#xff0c;望采纳&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["怎么将任意两点间的最短路径改成任意两点间遍历完所有点后的最优路径呢", ["\n", "class", " ", "Graph", ":\n            ", "def", " ", "__init__", "(", "self,filename", "):", "#将地图建成一个邻接表", "\n        \n               graph_edges=[]", "#边的长度", "\n               ", "with", " ", "open", "(filename) ", "as", " fhandle:", "#读取文件，一行一行的读", "\n                      ", "for", " line ", "in", " fhandle:\n                          ", "if", " line==", "\"\\n\"", ":", "#读取截止条件，注意必须加否则会报错", "\n                            ", "break", "\n                ", "#将map.txt文件中的数据按空格分离并存储，*_代表这一行后面所有的元素。", "\n                          edge_from,edge_to,cost,*_=line.strip().split(", "\" \"", ")\n                          graph_edges.append((edge_from,edge_to,cost))", "#以元组的形式加入到graph_edges", "\n        ", "#建立节点，set() 函数创建一个无序不重复元素集，", "\n        ", "#可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。", "\n               self.nodes =", "set", "()\n               ", "for", " edge ", "in", " graph_edges:\n            ", "#初始化节点", "\n            ", "#update() 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，", "\n            ", "#如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。", "\n                  self.nodes.update([edge[", "0", "],edge[", "1", "]])\n        ", "#建立邻接表", "\n               self.adjacency_list = {node: ", "set", "() ", "for", " node ", "in", " self.nodes}\n               ", "for", " edge ", "in", " graph_edges:\n           ", "#字典中的键表示图中的节点，而键值则是以字典的形式存在里面包括几组一元组的形式储存的", "\n           ", "#表示可达到节点以及权值", "\n                   self.adjacency_list[edge[", "0", "]].add((edge[", "1", "],edge[", "2", "]))\n            ", "def", " ", "shortest_path", "(", "self, start_node, end_node", "):\n                start_node=nameEntry3.get()\n                end_node=nameEntry4.get()\n               \n        ", "#使用Dijkstra算法找到从起始点到终点的最短路径，返回（path,distance）", "\n               \n        ", "#创造一个未访问节点的集合初始化为所有节点", "\n                unvisited_nodes = self.nodes.copy()  \n        ", "#创建一个字典表示每个点到起始点的距离，每个点先初始化为inf除了点本身初始化为0", "\n        ", "#当我们找到一个更短路径的时候更新这个字典所对应的值，数据结构为 节点：距离", "\n                distance_from_start = {node: (", "0", " ", "if", " node == start_node ", "else", " INFINITY) ", "for", " node ", "in", " self.nodes}\n \n        ", "#初始化前置节点也就是用来寻找路径的方法，结构为节点：节点其中后面的节点是前面", "\n        ", "#的前置节点，由此可以一步步找到路径，如果找到更短路径就更新这个字典", "\n                previous_node = {node: ", "None", " ", "for", " node ", "in", " self.nodes}\n                ", "while", " unvisited_nodes:\n            ", "#将当前节点设置为到目前为止在未访问节点这个字典中路径最短的节点", "\n                     current_node = ", "min", "(\n                ", "#从unvisited_nodes中找到键值最小的节点作为当前节点", "\n                          unvisited_nodes, key=", "lambda", " node: distance_from_start[node]\n                       )\n            ", "#从未访问的节点中，移除当前节点", "\n                     unvisited_nodes.remove(current_node)\n            ", "#如果当前节点的距离为无穷大，则其余未访问的节点不会连接到开始节点，停止", "\n                     ", "if", " distance_from_start[current_node] == INFINITY:\n                       ", "break", "\n \n            ", "#遍历每个当前节点的邻居，检查一下从起始节点到当前节点再到邻居节点的距离的大小", "\n            ", "#与distance_form_start中的比较看看是否更小，是讲究更新distance中所对应的值", "\n                     ", "for", " neighbor, distance ", "in", " self.adjacency_list[current_node]:\n                ", "#新的路径的距离", "\n                        new_path = distance_from_start[current_node] + ", "int", "(distance)\n                        ", "if", " new_path < distance_from_start[neighbor]:\n                             distance_from_start[neighbor] = new_path", "#更新值", "\n                             previous_node[neighbor] = current_node", "#更新路径，将当前节点作为邻居的前置节点", "\n \n        ", "#为了找到我们所建立的最短路径，使用迭代器遍历每个点的前置节点即可找到路径", "\n        ", "#并且把他存入一个队列中之所以可以保证找得到前置节点，是因为算法完成时候每个点的前置节点都代表着", "\n        ", "#到起始点的最短路径", "\n                path = deque()\n                current_node = end_node\n                ", "while", " previous_node[current_node] ", "is", " ", "not", " ", "None", ":\n                       path.appendleft(current_node)\n                       current_node = previous_node[current_node]\n                path.appendleft(start_node)\n                ", "return", " path, distance_from_start[end_node]\n       \n                   \n", "\n", "怎么将任意两点间的最短路径改成任意两点间遍历完所有点后的最优路径呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;基于最新版ChatGPT4的回答&amp;#xff0c;望采纳!!!有其他问题也可以询问我哦、”(最新版更智能&amp;#xff0c;功能更加强大)&lt;/p&gt;\n&lt;p&gt;为了解决这个问题&amp;#xff0c;我们需要修改Dijkstra算法&amp;#xff0c;使其最大化概率乘积而不是最小化权重和。我们将进行以下更改&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;初始化时&amp;#xff0c;将源节点的距离设置为1&amp;#xff0c;而不是0。&lt;/li&gt;&lt;li&gt;在寻找最小距离的节点时&amp;#xff0c;寻找具有最大距离的节点。&lt;/li&gt;&lt;li&gt;在更新节点的距离时&amp;#xff0c;使用概率乘积而不是权重和。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;以下是修改后的dijkstra.c文件中的代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;// DSA Programming task 4.2 - Dijsktra&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// You work on this file where TODO is located&lt;/span&gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &lt;span class=\"hljs-string\"&gt;&amp;#34;dijkstra.h&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Initializes graph for Dijkstra&lt;/span&gt;\nvoid init_graph(weightedgraph* g, int vertices){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;nVertices &amp;#61; vertices;\n    int i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; vertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;adj_list[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// TODO! Note the distance&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// Dijkstra search from node s&lt;/span&gt;\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;// Initialize graph&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;1; i &amp;lt;&amp;#61; g-&amp;gt;&lt;/span&gt;nVertices; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// All vertices in queue&lt;/span&gt;\n        queue[i] &amp;#61; i;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// TODO! Modification should start from here&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Note that the propability should be maximized&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//       Chanage names of variables accordingly&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;dist[s] &amp;#61; &lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt;(i&amp;#61;g-&amp;gt;&lt;/span&gt;nVertices; i &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i--) {\n        &lt;span class=\"hljs-comment\"&gt;// Search for maximum from the queue&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;double&lt;/span&gt; maxval &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]];\n        int maxnode &amp;#61; queue[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        int maxj&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt;&amp;#61; i; j&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;( g-&amp;gt;&lt;/span&gt;dist[queue[j]] &amp;gt; maxval ){\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;maxval&lt;/span&gt; &amp;#61; g-&amp;gt;&lt;/span&gt;dist[queue[j]];\n                maxnode &amp;#61; queue[j];\n                maxj &amp;#61; j;\n            }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// Switches the maximum to end (out of the queue)&lt;/span&gt;\n        int temp &amp;#61; queue[i];\n        queue[i] &amp;#61; queue[maxj];\n        queue[maxj] &amp;#61; temp;\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pweightededgenode&lt;/span&gt; pedge &amp;#61; g-&amp;gt;&lt;/span&gt;adj_list[maxnode];\n\n        &lt;span class=\"hljs-comment\"&gt;// Relax the neighbors&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(pedge !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; v &amp;#61; pedge-&amp;gt;&lt;/span&gt;nodenum;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;lt; (g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight))  {\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[v] &amp;#61; g-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;dist&lt;/span&gt;[maxnode]*pedge-&amp;gt;&lt;/span&gt;weight;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;g&lt;/span&gt;-&amp;gt;&lt;/span&gt;pred[v] &amp;#61; maxnode;\n            }\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pedge&lt;/span&gt; &amp;#61; pedge-&amp;gt;&lt;/span&gt;next;\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;// DEBUG INFO:&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// printf(&amp;#34;%d processed: d[%d] &amp;#61; %f\\n&amp;#34;,maxnode,maxnode,g-&amp;gt;dist[maxnode]);&lt;/span&gt;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//No need to change anyting after this point!&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;// ...&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用此修改后的算法&amp;#xff0c;您将能够找到具有最佳概率传递消息的路径。在给定示例中&amp;#xff0c;该算法将找到从站1到站8的最佳路径。我们将使用修改过的Dijkstra算法计算给定图中从节点1到节点8的最佳传输路径。请确保您使用了上述提供的修改后的dijkstra.c文件代码。使用此修改后的算法&amp;#xff0c;您可以通过运行main.c文件找到所需的路径。&lt;/p&gt;\n&lt;p&gt;现在&amp;#xff0c;我们已经修改了Dijkstra算法以解决您的问题&amp;#xff0c;您可以运行main.c文件&amp;#xff0c;以找到从站1到站8的最佳传输路径。在您提供的示例中&amp;#xff0c;该算法将找到具有最佳概率传递消息的路径。&lt;/p&gt;\n&lt;p&gt;请注意&amp;#xff0c;修改后的Dijkstra算法可以适用于您的问题。但是&amp;#xff0c;在特定情况下&amp;#xff0c;这种方法可能不是最有效的。例如&amp;#xff0c;对于具有大量节点和边的大型网络&amp;#xff0c;这种方法可能需要更多的计算资源和时间。在这种情况下&amp;#xff0c;可以考虑使用其他更高效的算法&amp;#xff0c;如A*搜索算法或其他启发式搜索方法。&lt;/p&gt;\n&lt;p&gt;如果您有其他关于Dijkstra算法或其他算法的问题&amp;#xff0c;请随时提问。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["c语言，修改基于第一个图的旧算法算法以解决新的问题，并将新算法用于最后一张图", ["有一个关于Dijkstra的无向图算法的实现，队列的处理简单，使算法的时间复杂度为𝛩(𝑛2),n是图中的节点数,将该算法应用于无向算法,下面是最初使用的加权图", "\n", "\n", "修改算法以解决下列问题：", "在一个链路网络中，有n个基站，我们可以在它们之间传输消息，一个网络包含n个互相传输信息的站点t1, t2, …, tn,由于干扰，消息可能在传输过程中被损坏。对于每一对站点，我们都知道消息被正确传输的概率（一个在0到1之间的实数）。 我们打算从t1站到tn站。设计一种算法来找到站点的路径，以最佳的概率传递消息.请注意，当一个消息通过一系列站点传输时，没有错误地传递它的概率是序列中概率的乘积。", "例子，在下图中，有三个站点和给定的概率", "通过v从t向u传递信息比直接传递信息更好，因为直接传递信息概率为0.5，而通过v的概率为0.7 × 0.8 = 0.56 > 0.50", "\n", "因此，应该修改给定的算法而不是边的和。我们考虑乘积，并选择最大值（而不是像原始算法中那样的最小值）", "\n", "将该算法应用于以下网络，其中边的权值为概率。该消息将从站1传送到站8，以此图用作新的算法。", "\n", "dijkstra.不需要修改", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n", "#", "ifndef", " DIJKSTRA_H_INCLUDED", "\n", "#", "define", " DIJKSTRA_H_INCLUDED", "\n\n", "#", "include", " ", "<limits.h>", "\n", "#", "include", " ", "<float.h>", "\n\n", "// Maximum number of vertices", "\n", "// define according to your needs", "\n", "#", "define", " MAXVERTS 1000", "\n\n", "// Nodes are numbered as integers from 1", "\n\n", "// Maximum value in the distance table", "\n", "#", "define", " INF DBL_MAX", "\n\n", "// Defines edge in the adjacency list", "\n", "typedef", " ", "struct", " ", "weightedgnd", " {\n    ", "int", " nodenum;\n    ", "double", " weight;\n    ", "struct", " ", "weightedgnd", "* next;\n} weightededgenode, *pweightededgenode;\n\n", "// Defines the graph", "\n", "typedef", " ", "struct", " ", "weightedg", " {\n    pweightededgenode adj_list[MAXVERTS+", "1", "];\n    ", "int", " pred[MAXVERTS+", "1", "];\n    ", "double", " dist[MAXVERTS+", "1", "];\n    ", "int", " nVertices;\n} weightedgraph;\n\n", "// Initializes graph for breadth-first search", "\n", "void", " ", "init_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Adds new edge (x,y)", "\n", "void", " ", "add_edge", "(weightedgraph* g, ", "int", " x, ", "int", " y, ", "double", " wght)", ";\n\n", "// Actual breadth-first search from node s", "\n", "void", " ", "dijkstra", "(weightedgraph* g, ", "int", " s)", ";\n\n", "// Frees allocated memory", "\n", "void", " ", "delete_graph", "(weightedgraph* g, ", "int", " vertices)", ";\n\n", "// Print a path after search", "\n", "void", " ", "print_path", "(weightedgraph* g, ", "int", " dest)", ";\n\n", "#", "endif", "\n\n", "\n", "main.c，不需要修改", "\n", "// DSA Programming task 4.2 - Dijkstra", "\n", "// You do not need to change anything here", "\n\n#", "include", " <stdio.h>\n#", "include", " ", "\"dijkstra.h\"", "\n\n", "int", " main", "()", "{\n    weightedgraph g;\n    init", "_graph(&", "g", ",8)", ";\n\n    add", "_edge(&", "g", ",1,2,1)", ";\n    add", "_edge(&", "g", ",1,4,7)", ";\n    add", "_edge(&", "g", ",1,5,3)", ";\n\n    add", "_edge(&", "g", ",2,3,1)", ";\n    add", "_edge(&", "g", ",3,4,2)", ";\n    add", "_edge(&", "g", ",5,6,3)", ";\n\n    add", "_edge(&", "g", ",6,7,3)", ";\n    add", "_edge(&", "g", ",6,8,3)", ";\n\n    ", "// The other graph", "\n    add", "_edge(&", "g", ",2,4,2)", ";\n    add", "_edge(&", "g", ",4,6,2)", ";\n\n    dijkstra(&g,", "1", ");\n\n    printf(", "\"The path from 1 to 8 with cumulative weights:\\n\"", ");\n    print", "_path(&", "g", ",8)", ";\n\n    delete", "_graph(&", "g", ",8)", ";\n\n    return ", "0", ";\n}\n\n", "\n", "dijkstra.c只对有TODO的部分进行修改（即为void init_graph函数的TODO部分和void dijkstra的TODO部分），具体修改要求详情见代码部分的注释", "\n", "// DSA Programming task 4.2 - Dijsktra", "\n", "// You work on this file where TODO is located", "\n#include <stdio.h>\n#include <stdlib.h>\n#include ", "\"dijkstra.h\"", "\n\n", "// Initializes graph for Dijkstra", "\nvoid init_graph(weightedgraph* g, int vertices){\n    ", "g", "->", "nVertices = vertices;\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "g", "->", "adj_list[i] = ", "0", ";\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "// TODO! Note the distance", "\n        ", "g", "->", "dist[i] = INF;\n    }\n}\n\n", "// Adds new edge (x,y)", "\nvoid add_edge(weightedgraph* g, int x, int y, double wght){\n    ", "if", "( x <= g->", "nVertices", " && y <= g->", "nVertices){\n        pweightededgenode pxy = malloc(sizeof(weightededgenode));\n        pweightededgenode pyx = malloc(sizeof(weightededgenode));\n\n        ", "pxy", "->", "nodenum = y;\n        ", "pxy", "->", "next", " = g->", "adj_list[x];\n        ", "pxy", "->", "weight = wght;\n        ", "g", "->", "adj_list[x] = pxy;\n\n        ", "pyx", "->", "nodenum = x;\n        ", "pyx", "->", "next", " = g->", "adj_list[y];\n        ", "pyx", "->", "weight = wght;\n        ", "g", "->", "adj_list[y] = pyx;\n    }\n}\n\n\n", "/*\n   Dijkstra's algorithm:\n   DIJKSTRA(G,w,s)\n   for each vertex v in V\n      d[v] = INF\n      p[v] = NIL\n   d[s] = 0\n   S = EMPTY\n   Q = V[G]\n   while Q != EMPTY\n         u =  EXTRACT-MIN(Q)\n         S = S UNION {u}\n         for each vertex v in Adj[u] do\n            if d[v] > d[u] + w(u,v) then\n               d[v] = d[u] + w(u,v)\n               p[v] = u\n*/", "\n\n", "// Dijkstra search from node s", "\nvoid dijkstra(weightedgraph* g, int s){\n    int queue[MAXVERTS];\n    int i=", "0", ";\n\n    ", "// Initialize graph", "\n    ", "for", "(i=1; i <= g->", "nVertices; i++) {\n        ", "g", "->", "pred[i] = ", "0", ";\n        ", "g", "->", "dist[i] = INF;\n        ", "// All vertices in queue", "\n        queue[i] = i;\n    }\n\n    ", "// TODO! Modification should start from here", "\n    ", "//       Note that the propability should be maximized", "\n    ", "//       Chanage names of variables accordingly", "\n    ", "g", "->", "dist[s] = ", "0", ";\n\n    ", "for", "(i=g->", "nVertices; i >= ", "1", "; i--) {\n        ", "// Search for minimum from the queue", "\n        ", "double", " minval = g->", "dist[queue[", "1", "]];\n        int minnode = queue[", "1", "];\n        int minj=", "1", ";\n        ", "for", "(int j = ", "1", "; j <= i; j++) {\n            ", "if", "( g->", "dist[queue[j]] < minval ){\n                ", "minval", " = g->", "dist[queue[j]];\n                minnode = queue[j];\n                minj = j;\n            }\n        }\n\n        ", "// Switches the minimum to end (out of the queue)", "\n        int temp = queue[i];\n        queue[i] = queue[minj];\n        queue[minj] = temp;\n\n        ", "pweightededgenode", " pedge = g->", "adj_list[minnode];\n\n        ", "// Relax the neighbors", "\n        ", "while", "(pedge != ", "0", "){\n            ", "int", " v = pedge->", "nodenum;\n            ", "if", "(g->", "dist", "[v] > (g->", "dist", "[minnode]+pedge->", "weight))  {\n                ", "g", "->", "dist", "[v] = g->", "dist", "[minnode]+pedge->", "weight;\n                ", "g", "->", "pred[v] = minnode;\n            }\n            ", "pedge", " = pedge->", "next;\n        }\n\n        ", "// DEBUG INFO:", "\n        ", "// printf(\"%d processed: d[%d] = %f\\n\",minnode,minnode,g->dist[minnode]);", "\n    }\n}\n", "//No need to change anyting after this point!", "\n\n", "// Free allocated memory", "\nvoid delete_graph(weightedgraph* g, int vertices){\n    int i;\n    ", "for", "(i=", "1", "; i <= vertices; i++) {\n        ", "pweightededgenode", " pedge = g->", "adj_list[i];\n        pweightededgenode pnext = ", "0", ";\n\n        ", "while", "(pedge != ", "0", ") {\n            ", "pnext", " = pedge->", "next;\n            free(pedge);\n            pedge = pnext;\n        }\n    }\n}\n\n", "// Print a path after search", "\nvoid print_path(weightedgraph* g, int dest){\n    ", "if", "( g->", "pred[dest] != ", "0", "){\n        ", "print_path", "(g, g->", "pred[dest]);\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n    ", "else", " ", "if", "(g->", "dist[dest]==", "0", "){\n        ", "printf", "(\"%d:%f\\n\",dest,g->", "dist[dest]);\n    }\n}\n\n\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If you're just starting with Go I would recommend sticking with the standard library for a bit and not adding more to your learning curve. Try to implement a simple graph data structure with some basic algorithms - it's very easy, and will let you practice with the language. Later on when you need more performance/features, you can look around for libraries (gonum or others). For example, a simple graph can be represented with:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Node is a node in the graph; it has a (unique) ID and a sequence of\n// edges to other nodes.\ntype Node struct {\n    Id    int64\n    Edges []int64\n}\n\n// Graph contains a set of Nodes, uniquely identified by numeric IDs.\ntype Graph struct {\n    Nodes map[int64]Node\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["在Go中使用Gonum进行图算法", ["\n\n", "I am a new Go programmer, just finished the \"A tour of Go\" tutorial a couple days ago. I want to create a graph of a 150 x 120 size and then get all the edge nodes for each node and implement some graph search algorithms such as BFS and Dijkstra. I found a great looking library called Gonum with a ", "graph package", "  that looks promising to use. ", "\n\n", "My problem is that it is a lot of information and I don't know where to get started. I was hoping there would be a tutorial of some sorts to get me started in the right direction, but I haven't had any luck finding one. ", "\n\n", "The way I set this up in Python was making a numpy arrays of zero's to represent the size of the graph and then iterate through it to get each edge for each node, but I am not sure that this is the best way to think about how graphs are set up in Go. ", "\n    "]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;单源即一个出发点到其他各点的距离&lt;br /&gt;多源即计算所有出发点到各点的距离&lt;br /&gt;两种算法本质上都是计算点到点的最短距离&amp;#xff0c;只是一个一次只能算一个点&amp;#xff0c;一个一次计算全部点&amp;#xff0c;如果前者加上循环就和后者在结果上没有区别了&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["图的最短路算法中，单源最短路问题和全源最短路问题，这里的单源和全源是什么意思？", ["初学图的最短路，发现书上有提到dijkstra解决单源最短路问题，Floyd解决全源最短路问题，但是书上没有解释这里的单源和全源是什么意思，指的是什么？"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;按照你这个matlab代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;function [min,path]&amp;#61;dijkstra(w,start,terminal)\n%% 函数介绍\n%输入变量w为所求图的带权邻接矩阵&amp;#xff0c;start、terminal分别为路径的起点和终点的编号。\n%返回path为从start到termial的最短路径以及长度min\n&lt;span class=\"hljs-attribute\"&gt;n&lt;/span&gt;&amp;#61;size(w,1); label(start)&amp;#61;0; f(start)&amp;#61;start;\n%n为所求图的顶点个数&amp;#xff0c;label存放到各点的最短路径&amp;#xff0c;f(v)表示v的父顶点用来还原路径\n%初始化将除了start以外的顶点label均设置为无穷大\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; i~&amp;#61;start\nlabel(i)&amp;#61;inf;\nend\nend\n%s数组存放已经搜好的顶点集&amp;#xff0c;初始化只有start\ns(1)&amp;#61;start; &lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;start;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; length(s)&amp;lt;n\n%遍历一遍顶点&amp;#xff0c;将不在顶点集中的顶点选出来进行下面的&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;判定\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n%判断是否有中继顶点使得它们之间的距离更短&amp;#xff0c;如果有的话更新距离并更新前驱结点\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; label(v)&amp;gt;(label(u)&amp;#43;w(u,v))\nlabel(v)&amp;#61;(label(u)&amp;#43;w(u,v)); f(v)&amp;#61;u;\nend\nend\nend\n&lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;inf;\n%同上再次进行遍历&amp;#xff0c;找到目前最短的路径顶点v1&amp;#xff0c;放入顶点集并改变u的值\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1:n\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;0;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;j&lt;/span&gt;&amp;#61;1:length(s)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;&amp;#61;s(j)\n&lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;1;\nend\nend\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;ins&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-attribute\"&gt;v&lt;/span&gt;&amp;#61;i;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; k&amp;gt;label(v)\n&lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;label(v); &lt;span class=\"hljs-attribute\"&gt;v1&lt;/span&gt;&amp;#61;v;\nend\nend\nend\ns(length(s)&amp;#43;1)&amp;#61;v1;\n&lt;span class=\"hljs-attribute\"&gt;u&lt;/span&gt;&amp;#61;v1;\nend\n\n&lt;span class=\"hljs-attribute\"&gt;min&lt;/span&gt;&amp;#61;label(terminal); path(1)&amp;#61;terminal;\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1;\n\n%按倒序结果推出最短路径\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; path(i)~&amp;#61;start\npath(i&amp;#43;1)&amp;#61;f(path(i));\n&lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;i&amp;#43;1 ;\nend\npath(i)&amp;#61;start;\n&lt;span class=\"hljs-attribute\"&gt;L&lt;/span&gt;&amp;#61;length(path);\n%翻转得到最短路径\n&lt;span class=\"hljs-attribute\"&gt;path&lt;/span&gt;&amp;#61;path(L:-1:1);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;并根据你给的点&amp;#xff0c;我写了个命令窗口代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;clc&lt;/span&gt;,clear\n&lt;span class=\"hljs-attribute\"&gt;w&lt;/span&gt;&amp;#61;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;inf,inf,inf,inf,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n&lt;span class=\"hljs-attribute\"&gt;start&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-attribute\"&gt;terminal&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;&lt;span class=\"hljs-meta\"&gt;\n[min,path]&amp;#61;dijkstra(w,start,terminal);\nmin,path&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行得出的结果是&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/764607253656172.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;并没有产生报错。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["一个问题算法的程序出现错误运行不出来", ["function [min,path]=dijkstra(w,start,terminal)", "%输入变量w为所求图的带权邻接矩阵，start、terminal分别为路径的起点和终点的编号。", "%返回path为从start到termial的最短路径以及长度min", "\n", "n=size(w,1); label(start)=0; f(start)=start;", "%n为所求图的顶点个数，label存放到各点的最短路径，f(v)表示v的父顶点用来还原路径", "\n", "%初始化将除了start以外的顶点label均设置为无穷大", "for i=1:n", "    if i~=start", "       label(i)=inf;", "    end", "end", "\n", "%s数组存放已经搜好的顶点集，初始化只有start", "s(1)=start; u=start;", "while length(s)<n", "    %遍历一遍顶点，将不在顶点集中的顶点选出来进行下面的if判定", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        %判断是否有中继顶点使得它们之间的距离更短，如果有的话更新距离并更新前驱结点", "        if ins==0", "            v=i;", "            if label(v)>(label(u)+w(u,v))", "                label(v)=(label(u)+w(u,v)); f(v)=u;", "            end", "        end", "    end", "    v1=0;", "    k=inf;", "    %同上再次进行遍历，找到目前最短的路径顶点v1，放入顶点集并改变u的值", "    for i=1:n", "        ins=0;", "        for j=1:length(s)", "            if i==s(j)", "                ins=1;", "            end", "        end", "        if ins==0", "            v=i;", "            if k>label(v)", "                k=label(v);  v1=v;", "            end", "        end", "    end", "    s(length(s)+1)=v1;", "    u=v1;", "end", "\n", "min=label(terminal); path(1)=terminal;", "i=1; ", "\n", "%按倒序结果推出最短路径", "while path(i)~=start", "    path(i+1)=f(path(i));", "    i=i+1 ;", "end", "path(i)=start;", "L=length(path);", "%翻转得到最短路径", "path=path(L:-1:1);", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "https://blog.csdn.net/qq_29320587/article/details/104842330", "Konwledge_Point": "Dijkstra算法", "Question": ["ROS在进行导航时，出现一直下发角速度和线速度为0的情况", ["\n\n", "如图所示，在存在路径规划的情况下，一直下发线速度和角速度为0 的情况。", "\n\n", "\n", "局部规划采用的是DWA算法", "\n", "全局规划采用的是Dijkstra.", "\n", "膨胀系数设置是15厘米。\n小车放置在一个空旷区域", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;干了几年了&amp;#xff0c;你说的这些我一个都不会&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["写逻辑代码要很长的时间适合走后端吗？", ["(刚学习新算法后敲代码)", "哈夫曼基本实现编码用了两天(译码没写)", "棋盘覆盖用了6个小时", "dijkstra用了6个小时", "背包回溯用了4个小时", "二叉树基本操作包括结点数，度为1结点数等实现用了8个钟(递归)", "\n", "就感觉自己敲逻辑代码好慢，适合干后端吗，现在有点想走前端的想法"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;首先&amp;#xff0c;您需要安装 NetworkX 和 matplotlib 库来绘制图像。然后&amp;#xff0c;可以使用 NetworkX 库中的 draw 函数来绘制图。将图绘制到画布上&amp;#xff0c;然后将画布放置在您的用户界面中的相应位置即可。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;以下是一个例子&amp;#xff0c;其中使用 Tkinter 库创建了一个简单的用户界面&amp;#xff0c;并在其中绘制了一个无向图&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;import tkinter as tk\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n&lt;span class=\"hljs-comment\"&gt;# 创建一个窗口&lt;/span&gt;\nwindow &amp;#61; tk.Tk()\n\n&lt;span class=\"hljs-comment\"&gt;# 创建一个画布&lt;/span&gt;\ncanvas &amp;#61; tk.Canvas(window, &lt;span class=\"hljs-attribute\"&gt;width&lt;/span&gt;&amp;#61;600, &lt;span class=\"hljs-attribute\"&gt;height&lt;/span&gt;&amp;#61;600)\ncanvas.pack()\n\n&lt;span class=\"hljs-comment\"&gt;# 创建一个无向图&lt;/span&gt;\nG &amp;#61; nx.Graph()\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;1)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;7)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;3)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;4)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;5)\nG.add_edge(&lt;span class=\"hljs-string\"&gt;&amp;#39;G&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;weight&lt;/span&gt;&amp;#61;9)\n\n&lt;span class=\"hljs-comment\"&gt;# 绘制图像&lt;/span&gt;\npos &amp;#61; nx.spring_layout(G)  # 使用 FR 算法排列节点\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\nlabels &amp;#61; nx.get_edge_attributes(G, &lt;span class=\"hljs-string\"&gt;&amp;#39;weight&amp;#39;&lt;/span&gt;)\nnx.draw_networkx_edge_labels(G, pos, &lt;span class=\"hljs-attribute\"&gt;edge_labels&lt;/span&gt;&amp;#61;labels, &lt;span class=\"hljs-attribute\"&gt;on&lt;/span&gt;&amp;#61;canvas)\n\n&lt;span class=\"hljs-comment\"&gt;# 显示窗口&lt;/span&gt;\nwindow.mainloop()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码使用了 NetworkX 库中的 spring_layout 函数来排制节点的位置&amp;#xff0c;然后使用 draw 函数绘制图像。还使用了 get_edge_attributes 函数和 draw_networkx_edge_labels 函数来绘制边的标签。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["如何让无向图显示到用户界面里", ["\ndef main():\n            \n        \n       \n\n", "# 问题 2：无向图的最短路问题（司守奎，数学建模算法与应用，P43，例4.3）", "\n             G2 = nx.Graph()  # 创建：空的 有向图\n\n             G2.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)  # 添加 带权边，weight表示边权\n             G2.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n             G2.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n             G2.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n             G2.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n             G2.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n             G2.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# 两个指定顶点之间的最短加权路径", "\n             ", "source", "=nameEntry3.get()\n             ", "target", "=nameEntry4.get()\n             minWPath_v1_v5 = nx.dijkstra_path(G2, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n             return minWPath_v1_v5\n             # 两个指定顶点之间的最短加权路径的长度\n             lMinWPath_v1_v5 = nx.dijkstra_path_length(G2, source, target)  # 最短加权路径长度\n             return lMinWPath_v1_v5\n             plt.clf()\n             pos = nx.spring_layout(G2)  # 用 FR算法排列节点\n             nx.draw(G2, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5)\n             labels = nx.get_edge_attributes(G2, ", "'weight'", ")\n             nx.draw_networkx_edge_labels(G2, pos, ", "edge_labels", "=labels)\n              # plt.show()\n\n\n             edgeList = []\n             ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n             nx.draw_networkx_edges(G2, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4) \n             # 设置边的颜色\n             \n             plt.savefig(", "'path'", " +", "'.jpg'", ")\n             filename = ", "\".\\path.jpg\"", "\n             image = Image.open(filename)\n             photo = ImageTk.PhotoImage(image)\n             canvas.create_image(450,250,image = photo)\n             canvas.update()\n             time.sleep(sleep_time)\n      \n      frame_mid = Frame(", "width", "=800,height=100,bg='white') \n      frame_mid.grid(", "row", "=8,column=10,rowspan=6,columnspan=2,padx=4, ", "pady", "=5)\n      \n      canvas = Canvas(frame_mid,width = 800,height = 600,bg = ", "'#FFCCCC'", ")#画板\n      \n      canvas.grid()\n\n\n\n                \n\n            \n      def main2():\n            \n               \n               EditText.insert(tkinter.END,main())\n             \n      ", "EditText", "=tkinter.Text(window2,width=15,height=5)\n      EditText.grid(", "row", "=8,column=8)\n      def main3():\n          main()\n      \n        \n     \n      ", "q", "=tkinter.Button(window2,text=\"确定\", font=(", "'宋体'", ",15),", "command", "=main2)\n      q.grid(", "row", "=7,column=6)\n      ", "q", "=tkinter.Button(window2,text=\"确定\", font=(", "'宋体'", ",15),", "command", "=main3)\n      q.grid(", "row", "=7,column=8\n", "\n", "为什么我用networkx和canvas画的图显示不到tkinter里", "该如何让它显示呢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;你可以将画布作为绘图函数的第一个参数&amp;#xff0c;如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;nx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;canvas&lt;/span&gt;&amp;#61;canvas)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或者&amp;#xff0c;可以使用 FigureCanvasTkAgg 将画布绑定到 tkinter 窗口中&amp;#xff0c;例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfig &amp;#61; plt.figure(figsize&amp;#61;(5, 5))\ncanvas &amp;#61; FigureCanvasTkAgg(fig, &lt;span class=\"hljs-attribute\"&gt;master&lt;/span&gt;&amp;#61;window2)\ncanvas.get_tk_widget().grid(&lt;span class=\"hljs-attribute\"&gt;row&lt;/span&gt;&amp;#61;8, &lt;span class=\"hljs-attribute\"&gt;column&lt;/span&gt;&amp;#61;10)\nnx.draw(G, pos, &lt;span class=\"hljs-attribute\"&gt;with_labels&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;, &lt;span class=\"hljs-attribute\"&gt;alpha&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;fig&lt;/span&gt;&amp;#61;fig)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这种情况下&amp;#xff0c;应该使用 fig 而不是 canvas 作为绘图函数的第一个参数。&lt;/p&gt;\n&lt;p&gt;请注意&amp;#xff0c;如果使用 FigureCanvasTkAgg&amp;#xff0c;则需要导入 matplotlib.pyplot 模块&amp;#xff0c;并使用 plt.figure 创建一个新图表。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["怎么让我画的无向图显示在canvas画布上", ["\ndef main3():\n          canvas = tkinter.Canvas(window2, ", "width", "=50, ", "height", "=50)\n          canvas.grid(", "row", "=8,column=10)\n\n", "# 创建一个无向图", "\n          G = nx.Graph()\n          G.add_edge(", "'A'", ", ", "'B'", ", ", "weight", "=1)\n          G.add_edge(", "'A'", ", ", "'D'", ", ", "weight", "=7)\n          G.add_edge(", "'B'", ", ", "'E'", ", ", "weight", "=4)\n          G.add_edge(", "'D'", ", ", "'E'", ", ", "weight", "=3)\n          G.add_edge(", "'F'", ", ", "'G'", ", ", "weight", "=4)\n          G.add_edge(", "'F'", ", ", "'E'", ", ", "weight", "=5)\n          G.add_edge(", "'G'", ", ", "'K'", ", ", "weight", "=9)\n\n", "# 绘制图像", "\n          ", "source", "=nameEntry3.get()\n          ", "target", "=nameEntry4.get()\n \n          minWPath_v1_v5 = nx.dijkstra_path(G, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n                \n", "# 两个指定顶点之间的最短加权路径的长度", "\n          \n          pos = nx.spring_layout(G)  # 使用 FR 算法排列节点\n          nx.draw(G, pos, ", "with_labels", "=", "True", ", ", "alpha", "=0.5,on=canvas)\n          labels = nx.get_edge_attributes(G, ", "'weight'", ")\n          nx.draw_networkx_edge_labels(G, pos, ", "edge_labels", "=labels)\n          edgeList = []\n          ", "for", " i ", "in", " range(len(minWPath_v1_v5)-1):\n                  edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n                  nx.draw_networkx_edges(G, pos, ", "edgelist", "=edgeList, ", "edge_color", "=", "'m'", ", ", "width", "=4,on=canvas)\n\n            \n          \n      \n", "\n", "怎么让我画的无向图显示在canvas画布上"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;shortest_path(G[, source, target, weight,...]) 计算图中的最短路径&amp;#xff0c;可以用于无向图或有向图&lt;/p&gt;\n&lt;p&gt;dijkstra_path(G, source, target[, weight]) 计算从源到目标的最短加权路径&amp;#xff0c;用于有权图&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["NetworkX 有权无向图计算最短路径", ["NetworkX 有权无向图计算最短路径时函数shortest_path(G[, source, target, weight,…])和函数dijkstra_path(G, source, target[, weight])有什么区别？", "\n", "\n", "参考链接：", "https://blog.csdn.net/youcans/article/details/116999881?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167210396716800213045638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167210396716800213045638&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116999881-null-null.142^v68^control,201^v4^add_ask,213^v2^t3_control1&utm_term=networkx%20shortest_path&spm=1018.2226.3001.4187"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这是一个实现迪杰斯特拉算法的代码&amp;#xff0c;用于求解单源最短路径问题。该算法是一种贪心算法&amp;#xff0c;每次求解的时候都会找到当前能到达的点中距离起点最近的点&amp;#xff0c;并从该点开始搜索下一步能到达的点&amp;#xff0c;直到到达终点。&lt;/p&gt;\n&lt;p&gt;具体来说&amp;#xff0c;代码中使用了三个栈&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1、stack 栈用来存储搜索路径中的点。&lt;br /&gt;2、stackdata 栈用来存储每条边的距离。&lt;br /&gt;3、stackfindlj 栈用来存储所有可能的路径&amp;#xff0c;其中的每一行都是一条路径&amp;#xff0c;第一个元素为起点&amp;#xff0c;其余的元素为路径中的每个点。&lt;br /&gt;首先&amp;#xff0c;从起点开始搜索&amp;#xff0c;如果找到了一条边且这条边还没有访问过&amp;#xff0c;就将这条边加入路径中&amp;#xff0c;并将这条边的距离加入路径距离中。然后从这条边的终点开始继续搜索&amp;#xff0c;如果能找到一条边且这条边还没有访问过&amp;#xff0c;就将这条边加入路径中&amp;#xff0c;并将这条边的距离加入路径距离中。重复这个过程直到到达终点&amp;#xff0c;或者找不到新的边可以加入路径中。&lt;/p&gt;\n&lt;p&gt;所有的路径被保存在 stackfindlj 中&amp;#xff0c;其中的每一行都是一条路径。接下来&amp;#xff0c;遍历所有的路径&amp;#xff0c;找到路径距离最小的路径。将这条最短路径的信息复制到一个名为 temp 的结构体中&amp;#xff0c;并返回这个结构体。&lt;/p&gt;\n&lt;p&gt;这个结构体中包含两个信息&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;1、stack 数组用来存储最短路径中的点。&lt;br /&gt;2、jl 变量用来存储最短路径的距离。&lt;/p&gt;\n&lt;p&gt;如果想输出最短路径的途径点信息&amp;#xff0c;可以在输出路径距离之后添加以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;最短路径为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp.stack[i] !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, temp.stack[i]);\n  }\n}\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这段代码会依次输出最短路径中的所有点。&lt;br /&gt;仅供参考&amp;#xff0c;望采纳&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["构造了一个迪杰斯特拉函数，但是不会得出最短路径的途径点信息，需要更详细的注释", ["问题遇到的现象和发生背景 构造了一个计算函数，如何得到最短路径的点的信息以及需要更详细的注释", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "struct ", "MyStack", "  \n{\n    int stack[", "50", "];//栈\n    int jl;//距离\n};\n//迪杰斯特拉算法\n", "MyStack", " ", "Dijkstra", "(map ", "Map", ", int d, int e)//d设为起点,e设为终点\n{\n    int stack[", "50", "] = { ", "0", " }, id1 = ", "0", ";\n    int stackdata[", "50", "] = { ", "0", " }, id2 = ", "0", ";\n    int stackfindlj[", "50", "][", "50", "] = { ", "0", " }, id3 = ", "0", ";//路径保存\n    int stackfindjl[", "50", "] = { ", "0", " };//距离保存\n    int isfind = ", "0", ";\n    for (int i = d; i < d + ", "1", "; i++)\n    {\n        for (int j = i; j < ", "12", "; j++)\n        {\n            int edge[", "12", "][", "12", "] = { ", "0", " };//辅助地图\n            if (", "Map", ".edge[i][j] != ", "100", " && ", "Map", ".edge[i][j] != ", "0", " && edge[i][j] == ", "0", ")\n            {\n                stack[id1++] = j;\n                stackdata[id2++] = ", "Map", ".edge[i][j];//边的距离\n                edge[i][j] = ", "1", ";//辅助地图\n                while (id1)\n                {\n                    for (int k = stack[id1 - ", "1", "]; k < ", "12", "; k++)\n                    {\n                        if (", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "100", " && ", "Map", ".edge[stack[id1 - ", "1", "]][k] != ", "0", " && edge[stack[id1 - ", "1", "]][k] == ", "0", ")//开始搜寻路径\n                        {\n                            edge[stack[id1 - ", "1", "]][k] = ", "1", ";\n                            stackdata[id2++] = ", "Map", ".edge[stack[id1 - ", "1", "]][k];\n                            stack[id1++] = k;\n                            if (k == e)//到达了终点\n                                isfind = ", "1", ";\n                            break;\n                        }\n                        if (k == ", "11", ")\n                        {\n                            id1--; id2--;\n                        }\n                    }\n                    if (isfind == ", "1", ")\n                    {\n                        stackfindlj[id3][", "0", "] = i + ", "1", ";\n                        for (int k = ", "0", "; k < id1; k++)\n                        {\n                            stackfindlj[id3][k + ", "1", "] = stack[k] + ", "1", ";\n                            stackfindjl[id3] += stackdata[k];\n                        }\n                        id3++;\n                        isfind = ", "0", ";\n                    }\n                }\n            }\n        }\n    }\n    int min = stackfindjl[", "0", "], minidx = ", "0", ";\n    for (int i = ", "0", "; i < id3; i++)\n    {\n        if (min > stackfindjl[i])\n        {\n            min = stackfindjl[i];\n            minidx = i;\n        }\n    }\n    ", "MyStack", " temp = { ", "0", " };\n    memcpy(&temp.stack, &stackfindlj[minidx], sizeof(int) * ", "50", ");//将得到的最短路径复制到结构体的数组之中\n    temp.jl = min;//将得到的最短距离赋值到结构体的距离中\n    printf(", "\"最短路径距离为：%d\\n\"", ", temp.jl);\n    return temp;\n\n", "\n", "运行结果及详细报错内容", "\n", "只会输出最短距离", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "迪杰斯特拉函数", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;应该是没有visited数组标记的问题&amp;#xff0c;存边是存双向边&amp;#xff0c;需要标记visited&amp;#xff08;有时也叫used&amp;#xff09;数组进行标记这个点已经到达过了&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["洛谷P1462 dij的问题", ["https://www.luogu.com.cn/problem/P1462", "\n", "https://www.luogu.com.cn/record/78581018", "\n", "只对了3个点，都是无解点，也就是说dij可能不对", "\n", "#", "include", "<bits/stdc++.h>", "\n", "#", "define", " INF 0x3f3f3f3f", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", " MAXN=", "10008", ";\n", "typedef", " pair<", "int", ",", "int", "> pi;\npriority_queue< pi,vector<pi>,greater<pi> > q;\n", "int", " n,m,b;\n", "int", " f[MAXN],dis[MAXN];\n", "struct", " ", "node", "{\n    ", "int", " v,w;\n};\nvector<node> a[MAXN];\n", "bool", " vis[MAXN];\n", "int", " l=INT_MAX,r=INT_MIN,mid;\n", "bool", " ", "dijkstra", "(", "int", " st)", "{\n    ", "memset", "(vis,", "0", ",", "sizeof", "(vis));\n    ", "memset", "(dis,INF,", "sizeof", "(dis));\n    dis[", "1", "]=st;\n    q.", "push", "({", "make_pair", "(dis[", "1", "],", "1", ")});\n    ", "while", "(!q.", "empty", "()){\n        ", "int", " x=q.", "top", "().second;\n        q.", "pop", "();\n        ", "if", "(vis[x]) ", "continue", ";\n        vis[x]=", "true", ";\n        ", "for", "(", "int", " i=", "0", ";i<a[x].", "size", "();i++){\n            ", "int", " y=a[x][i].v,z=a[x][i].w;\n            dis[y]=", "min", "(dis[y],dis[x]+z);\n            q.", "push", "(", "make_pair", "(dis[y],y));\n        }\n    }\n    ", "return", " dis[n]<b;\n}\n", "int", " ", "main", "()", "{\n    ", "scanf", "(", "\"%d%d%d\"", ",&n,&m,&b);\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "scanf", "(", "\"%d\"", ",&f[i]);\n        l=", "min", "(l,f[i]);\n        r=", "max", "(r,f[i]);\n    }\n    ", "int", " maxi=r;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++){\n        ", "int", " u,v,w;\n        ", "scanf", "(", "\"%d%d%d\"", ",&u,&v,&w);\n        a[u].", "push_back", "({v,w});\n        a[v].", "push_back", "({u,w});\n    }\n    ", "while", "(l<=r){\n        mid=(l+r)/", "2", ";\n        ", "if", "(", "dijkstra", "(mid)) r=mid", "-1", ";\n        ", "else", " l=mid+", "1", ";\n    }\n    ", "if", "(l==maxi+", "1", ") \n        ", "printf", "(", "\"AFK\\n\"", ");\n    ", "else", "\n        ", "printf", "(", "\"%d\\n\"", ",l);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "求给出以如上代码改对了的代码或修改方式，谢谢"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;我试着照着你的deque输出的代码写了一个测试&amp;#xff0c;可以正常输出&amp;#xff0c;所以问题应该不在这里&lt;/p&gt;", "Konwledge_Point": "Dijkstra算法", "Question": ["问题：为什么用deque反向输出会报错而用递归反向输出没问题", ["http://poj.org/problem?id=2457", "（由于题目是英文，以下图片时中文翻译后的图片）", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/800335390746158.png?x-oss-process=image/auto-orient,1", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/394075390746180.png?x-oss-process=image/auto-orient,1", "\n", "（由于题目是英文，以下图片时中文翻译后的图片）", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "1", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "1", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\ndeque<", "int", "> stars;\n", "void", " ", "print_stars", "()", "\n", "{\n \n    \n    stars.", "push_front", "(n);\n    k=n;\n    ", "while", "(vis0[k]!=s)\n    {\n        k=vis0[k]; \n        stars.", "push_front", "(k);\n    }\n    stars.", "push_front", "(s);\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    cin>>m>>n;\n", "//    if(n==1)", "\n", "//    {", "\n", "//        cout<<\"1\"<<'\\n'<<\"1\"<<'\\n';", "\n", "//    }", "\n", "//    else{", "\n    \n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);", "\n        }\n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]<<", "'\\n'", ";\n            ", "print_stars", "();\n            ", "while", "(stars.", "size", "())\n            {\n                cout<<stars.", "front", "()<<", "'\\n'", ";\n                stars.", "pop_front", "();\n            }\n", "//        }", "\n    }\n    ", "return", " ", "0", ";\n}\n \n\n", "\n", "（以下时将deque该换成递归之后可以通过的代码）", "\n", " \n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<queue>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<deque>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", "  N=", "1e5", "+", "10", ",M=", "2e5", "+", "10", ";\n", "typedef", " pair<", "int", ",", "int", "> PII;\n", "int", " dis[N],k,head[N],n,idx,m,s=", "1", ",t,vis0[N];\n", "bool", " vis[N];\n", "struct", " ", "Edge", "{\n    ", "int", " to,w,next;\n}edge[M];\n", "void", " ", "add", "(", "int", " a,", "int", " b ,", "int", " c)", "\n", "{\n    edge[idx].to=b,edge[idx].w=c,edge[idx].next=head[a],head[a]=idx++;\n}\n", "void", " ", "dijkstra", "()", "\n", "{\n    ", "memset", "(dis,", "0x3f", ",", "sizeof", " dis);\n    dis[s]=", "0", ";\n    priority_queue<PII,vector<PII>,greater<PII> > heap;\n    heap.", "push", "({", "0", ",s});\n", "//    vis0[1]=1;", "\n    ", "while", "(heap.", "size", "())\n    {\n        ", "int", " vertax = heap.", "top", "().second;\n        heap.", "pop", "();\n        \n        ", "if", "(vis[vertax])", "continue", ";\n        vis[vertax]=", "true", ";\n", "//        cout<<vertax<<\" \";", "\n        ", "for", "(", "int", " i = head[vertax]; i != ", "-1", "; i = edge[i].next)\n        {\n            ", "int", " j=edge[i].to;\n            ", "if", "(dis[j]>dis[vertax]+edge[i].w)\n            {\n                dis[j]=dis[vertax]+edge[i].w;\n                vis0[j]=vertax;\n                heap.", "push", "({dis[j],j});\n            }\n        }\n        \n    }\n}\n", "//deque<int> stars;", "\n", "//void print_stars()", "\n", "//{", "\n", "//", "\n", "//    ", "\n", "//    stars.push_front(n);", "\n", "//    k=n;", "\n", "//    while(vis0[k]!=s)", "\n", "//    {", "\n", "//        k=vis0[k]; ", "\n", "//        stars.push_front(k);", "\n", "//    }", "\n", "//    stars.push_front(s);", "\n", "//}", "\n", "void", " ", "printf_path", "(", "int", " vertax)", "\n", "{\n    ", "if", "(vis0[vertax] != ", "-1", " ) ", "printf_path", "(vis0[vertax]);\n    cout<<vertax<<", "'\\n'", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a,b,c;\n    ", "memset", "(head,", "-1", ",", "sizeof", " head);\n    ", "memset", "(vis0,", "-1", ",", "sizeof", " vis0);\n    cin>>m>>n;\n        ", "for", "(", "int", " i=", "1", ";i<=m;i++)\n        {\n            cin>>a>>b;\n            c=", "1", ";\n            ", "add", "(a,b,c);\n", "//            add(b,a,c);    ", "\n        }\n    ", "if", "(n==", "1", ")\n    {\n        cout<<", "\"1\"", "<<", "'\\n'", "<<", "\"1\"", "<<", "'\\n'", ";\n    }\n    ", "else", "{\n    \n    \n        ", "dijkstra", "();\n        ", "if", "(dis[n]==", "0x3f3f3f3f", ")\n        {\n            cout<<", "\"-1\"", ";\n        }\n        ", "else", "{\n            cout<<dis[n]+", "1", "<<", "'\\n'", ";\n            ", "printf_path", "(n);\n", "//            while(stars.size())", "\n", "//            {", "\n", "//                cout<<stars.front()<<'\\n';", "\n", "//                stars.pop_front();", "\n", "//            }", "\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
