{"Answer": "普里姆算法是选顶点\r\n假设从A点出发构造最小生成树，距离A点最近的是D点，连接AD；然后距离A、D最近的是B点，连接BD；然后距离A、D、B最近的是C点，连接BC；\r\n然后距离A、D、B、C最近的是F点，连接CF；然后距离A、D、B、C、F最近的是G，连接FG；然后距离A、D、B、C、F、G点最近的是E点，连接GE；\r\n然后距离A、D、B、C、F、G、E点最近的是H点，连接EH。\r\n最小生成树为ADBCFGEH\r\n克鲁斯卡尔算法是选边\r\n边权为2最小，连接BC，EG；然后边权为3最小，连接EH；然后边权为4最小，连接CF，AD；然后边权为5最小，连接BD，FG。\r\n最小生成树为ADBCFGEH", "Konwledge_Point": "最小生成树", "Question": ["用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树", ["用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树"]], "Tag": "算法设计"}
{"Answer": "不对，这题应该选A\r\n求顶点的入度的时间复杂度为O(e)*n=O(n*e)\r\n遍历顶点的时间复杂度是O(n^2)\r\n相加是O(n^2+n*e)=O(n^2)", "Konwledge_Point": "最小生成树", "Question": ["在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为?", ["在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为?", "\nA o(n^2) B o(n^3) C o(n) D o(n+e)", "\n答案是o(n+e)。。。不理解..求过程"]], "Tag": "算法设计"}
{"Answer": "原理可以从 算法4th 中学习，\r\n里面讲了三种算法 csharp 代码：\r\n1. [KruskalMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/KruskalMinimumSpanTree.cs \"\")\r\n2. [LazyPrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/LazyPrimMinimumSpanTree.cs \"\")\r\n3. [PrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/PrimMinimumSpanTree.cs \"\")", "Konwledge_Point": "最小生成树", "Question": ["求一个   最小生成树聚类  的程序", ["求一个最小生成树的聚类的程序，谢谢。最好是c++语言，当然matlab，java，python程序也可以。"]], "Tag": "算法设计"}
{"Answer": "http://bbs.csdn.net/topics/380240225", "Konwledge_Point": "最小生成树", "Question": ["类似最小生成树的算法求解答", ["输入一些二元组，二元组代表连通的两个节点。所有的二元组构成一个无向图。现在请你设计一个算法，求出一个最小生成树，使得图中没有回路，并且连接所有节点。输出的数据也用二元组表达。", "\n要用Java或者C#来实现。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;当然不一定了。&lt;br /&gt;例如&amp;#xff1a; 5个顶点 12345 的全连通图&amp;#xff0c;取出 4条边&amp;#xff08;12&amp;#xff0c;13&amp;#xff0c;23&amp;#xff0c;45&amp;#xff09;和 5个顶点 12345&amp;#xff0c;并不是连通图。&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["关于连通图和最小生成树", ["对于一个有n个顶点的连通图，最少有N-1条边，最多有C(n,2)条边", "那么如果现在这个连通图有C（n,2)条边，那么我取任意n-1条边出来和n个顶点组成一个新图，那么这个新图还是连通图吗"]], "Tag": "算法设计"}
{"Answer": "https://www.cnblogs.com/qscqesze/p/5246222.html", "Konwledge_Point": "最小生成树", "Question": ["最小生成树方面的一个问题，用C语言怎么解决的？？？？", ["Problem Description", "\nThere is an undirected graph G with n vertices and m edges. Every time, you can select several edges and delete them. The edges selected must meet the following condition: let G′ be graph induced from these edges, then every connected component of G′ has at most one cycle. What is the minimum number of deletion needed in order to delete all the edges.", "\n\n", "Input", "\nThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case:", "\n\n", "The first line contains two integers n and m (1≤n≤2000,0≤m≤2000) -- the number of vertices and the number of edges.", "\n\n", "For the next m lines, each line contains two integers ui and vi, which means there is an undirected edge between ui and vi (1≤ui,vi≤n,ui≠vi).", "\n\n", "The sum of values of n in all test cases doesn't exceed 2⋅104. The sum of values of m in all test cases doesn't exceed 2⋅104.", "\n\n", "Output", "\nFor each test case, output the minimum number of deletion needed.", "\n\n", "Sample Input", "\n3", "\n4 2", "\n1 2", "\n1 3", "\n4 5", "\n1 2", "\n1 3", "\n1 4", "\n2 3", "\n2 4", "\n4 4", "\n1 2", "\n2 3", "\n3 4", "\n4 1", "\n\n", "Sample Output", "\n1", "\n2", "\n1"]], "Tag": "算法设计"}
{"Answer": "http://hzwer.com/3666.html", "Konwledge_Point": "最小生成树", "Question": ["最小生成树                 ", ["Description", "\n\n", "　给定一个边带正权的连通无向图G=(V,E)，其中N=|V|，M=|E|，N个点从1到N依次编号，给定三个正整数u，v，和L (u≠v)，假设现在加入一条边权为L的边(u,v)，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上？", "\n\n", "Input", "\n\n", "　　第一行包含用空格隔开的两个整数，分别为N和M；", "\n接下来M行，每行包含三个正整数u，v和w表示图G存在一条边权为w的边(u,v)。", "\n最后一行包含用空格隔开的三个整数，分别为u，v，和 L；", "\n数据保证图中没有自环。", "\nOutput", "\n\n", "　输出一行一个整数表示最少需要删掉的边的数量。", "\n\n", "Sample Input", "\n\n", "3 2", "\n3 2 1", "\n1 2 3", "\n1 2 2", "\nSample Output", "\n\n", "1"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;prim算法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;def findTree(G:dict):\n    &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt; &amp;#61; list(G.keys())[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n    choice &amp;#61; [(&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;, i, j) for i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; G[&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;].items()]\n    choice.sort(&lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x:x[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])\n    tree &amp;#61; list()\n    seen &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;}\n    while choice:\n        &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;&amp;#61; choice&lt;/span&gt;.pop(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;] not &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; seen:\n            seen.add(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;])\n            line &amp;#61; sorted([&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[0&lt;/span&gt;],&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;]])\n            line.append(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[2&lt;/span&gt;])\n            tree.append(line)\n            for i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; G[&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;]].items():\n                choice.append((&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;],i,j))\n            choice.sort(&lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x:x[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])\n    return tree\n\nif __name__ &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:\n    graph &amp;#61; {\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;}\n    }\n    lines &amp;#61; set()\n    for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, value&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; graph.items():\n        for i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; value.items():\n            temp &amp;#61; sorted([&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;,i&lt;/span&gt;])\n            temp.append(j)\n            lines.add(tuple(temp))\n    print(lines)\n    tree &amp;#61; findTree(graph)\n    print(tree)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["关于最小生成树的应用", ["已知带权无向图（如下所示），求最小生成树。Program2用图要求输出：(1)所有的边及权值，如：（‘a’,’b’,10）…(2)最小生成树所包含的边，如：（’a’,‘c’,‘weight’:8）…", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ArcGIS是一个功能丰富的地理信息系统(GIS)工具&amp;#xff0c;可以用来处理和分析地理数据。要在ArcGIS中构建最小生成树网络(Minimum Spanning Tree, MST)&amp;#xff0c;可以使用其中的&amp;#34;Network Analyst&amp;#34;工具。&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;首先&amp;#xff0c;需要拥有一个点数据集和一个边数据集。这些数据集可以来自 shapefile 文件&amp;#xff0c;CSV文件或者是GDB文件。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"2\"&gt;&lt;li&gt;打开ArcMap&amp;#xff0c;添加点数据集和边数据集到地图中。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"3\"&gt;&lt;li&gt;打开 &amp;#34;Network Analyst&amp;#34;工具&amp;#xff0c;在工具栏中选&amp;#34;New Network Analysis Layer&amp;#34;。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"3\"&gt;&lt;li&gt;在弹出的窗口中&amp;#xff0c;选择“Connectivity”作为类型&amp;#xff0c;并指定点数据集作为终点&amp;#xff0c;边数据集作为边。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"4\"&gt;&lt;li&gt;点击 &amp;#34;OK&amp;#34;按钮&amp;#xff0c;创建网络分析层。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"5\"&gt;&lt;li&gt;在 &amp;#34;Network Analyst&amp;#34;面板中&amp;#xff0c;选择 &amp;#34;Generate Service Area&amp;#34;工具。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"6\"&gt;&lt;li&gt;在弹出的窗口中&amp;#xff0c;选择要求的选项&amp;#xff08;比如网络设置&amp;#xff0c;分析阈值等&amp;#xff09;&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"7\"&gt;&lt;li&gt;在 &amp;#34;Solver&amp;#34;栏中&amp;#xff0c;选择“Minimum Spanning Tree&amp;#34;&amp;#xff0c;并点击 &amp;#34;Solve&amp;#34;按钮运行分析。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"8\"&gt;&lt;li&gt;分析完成后&amp;#xff0c;结果将显示在地图上&amp;#xff0c;表示最小生成树的路径。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"9\"&gt;&lt;li&gt;可以通过导出成 shapefile或者其他文件格式来保存结果&amp;#xff0c;或者在 ArcGIS Pro里继续分析。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;另外&amp;#xff0c;需要注意的是,使用&amp;#34;Network Analyst&amp;#34;工具构建的最小生成树&amp;#xff0c;是基于空间关系的&amp;#xff0c;即根据点之间的距离构建最小生成树,如果需要根据权重来构建最小生成树&amp;#xff0c;需要在边数据中设置权重属性,并在Network Analyst中对权重属性进行设置。&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["如何用argis构建最小生成树网络", ["想使用arcgis构建最小生成树网络 该方法来源于faber2014的一篇文章 但是不知道如何具体操作"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/033372774866162.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;第一题D  1&amp;#43;2&amp;#43;4&amp;#43;7&amp;#61;14&lt;br /&gt;第二题 一个或多个&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["分别选择什么，第一道题有没有最小生成树的图示啊", ["分别选择什么，第一道题有没有最小生成树的图示啊，谢谢，辛苦辛苦", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这道题一看就是最小生成树&amp;#xff0c;有两种方法&amp;#xff0c;分别为&lt;br /&gt;普里姆算法&amp;#xff08;prim&amp;#xff09;&lt;br /&gt;和&lt;br /&gt;克鲁斯卡尔&amp;#xff08;kruskal&amp;#xff09;&lt;br /&gt;本题解使用的是 kruskal&lt;br /&gt;假设连通网G&amp;#xff1d;&amp;#xff08;V&amp;#xff0c;E&amp;#xff09;&amp;#xff0c;则令最小生成树的初始状态为只有n个顶点而无边的非连通网&amp;#xff0c;图中每个顶点自成一个连通分量。在E中选择代价最小的边&amp;#xff0c;若该边依附的顶点落在T中不同的连通分量上&amp;#xff0c;则将此边加入到T中&amp;#xff0c;否则舍去此边而选择下一条代价最小的边。依此类推&amp;#xff0c;直至T中所有顶点都在同一连通分量上为止。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,a[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;],v[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;],p,q,minn,ans,m;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n     &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n      &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i][j]);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)v[i]&amp;#61;i; &lt;span class=\"hljs-comment\"&gt;//全部点都是一定单独的集合&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;i&amp;#43;&amp;#43;){ &lt;span class=\"hljs-comment\"&gt;//只用循环到n-1&amp;#xff0c;因为只有n-1条边&lt;/span&gt;\n        minn&amp;#61;&lt;span class=\"hljs-number\"&gt;99999999&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//minn要赋最大值&amp;#xff0c;一定不要赋0x7f&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;)\n         &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n          &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(v[k]!&amp;#61;v[j] &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; a[k][j]&amp;lt;&amp;#61;minn &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; a[k][j]!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n              minn&amp;#61;a[k][j];\n              p&amp;#61;j; &lt;span class=\"hljs-comment\"&gt;//记录j和k&amp;#xff0c;供后面使用&lt;/span&gt;\n              q&amp;#61;k;\n          }\n        ans&amp;#43;&amp;#61;minn; &lt;span class=\"hljs-comment\"&gt;//把权值加上去&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t&amp;#61;v[p];\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;){\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(v[k]&amp;#61;&amp;#61;t)v[k]&amp;#61;v[q]; &lt;span class=\"hljs-comment\"&gt;//把v[k]集合的点全部变成v[q]集合的点&amp;#xff0c;符合克鲁斯卡尔算法的思想&lt;/span&gt;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,ans);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["关于最小生成树的问题，如何修改？(语言-c++)", ["\n", "【最小生成树专题】最短网络 (Standard IO)", "时间限制: 1000 ms  空间限制: 262144 KB  具体限制  ", "\n", "\n", "题目描述", "农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了用最小的消费，他想铺设最短的光纤去连接所有的农场。你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。每两个农场间的距离不会超过100000。", "\n", "输入", "第一行：农场的个数，N（3<=N<=100）。", "后来的行包含了一个N*N的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们限制在80个字符，因此，某些行会紧接着另一些行。当然，对角线将会是0，因为不会有线路从第i个农场到它本身。", "\n", "输出", "只有一个输出，其中包含连接到每个农场的光纤的最小长度。", "\n", "样例输入", "4", "0  4  9  21", "4  0  8  17", "9  8  0  16", "21 17 16  0", "\n", "样例输出", "28", "\n", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "int", " a[", "105", "][", "105", "],s,n,visit[", "105", "],visitt;\nqueue<", "int", "> q;\n", "void", " ", "pr", "()", "\n", "{\n    q.", "push", "(", "1", ");\n    visit[", "1", "]=", "1", ";\n    ", "while", "(", "1", ")\n    {\n        ", "int", " minn=", "100005", ",minni;\n        ", "for", "(", "int", " j=", "1", ";j<=n;j++)\n        {\n            ", "if", "(a[q.", "front", "()][j]<minn&&visit[j]==", "0", ")\n            {\n                minn=a[q.", "front", "()][j];\n                minni=j;\n            }\n        }\n        cout<<endl;\n        cout<<minn<<", "\" \"", ";\n        q.", "pop", "();\n        q.", "push", "(minni);\n        visit[minni]=", "1", ";\n        visitt++;\n        s=s+minn;\n        ", "if", "(visitt==n", "-1", ") ", "break", ";\n    }\n    \n}\n", "int", " ", "main", "()", "\n", "{\n    cin>>n;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++)\n    {\n        ", "for", "(", "int", " j=", "1", ";j<=n;j++)\n        {\n            cin>>a[i][j];\n        }\n    }\n    ", "pr", "();\n    cout<<s;\n}\n\n\n", "\n", "我哪里错了，求指明！"]], "Tag": "算法设计"}
{"Answer": "楼主可以参考这个，很可能对楼主有用： [url]http://www.cnblogs.com/codeyu/archive/2009/09/03/1559736.html[/url]", "Konwledge_Point": "最小生成树", "Question": ["我有个java连接网络的程序，想要在windows登陆前执行这个程序，请教该如何做", ["我有个java连接网络的程序，想要在windows开机以后，用户登陆前执行这个程序，请教该如何做"]], "Tag": "算法设计"}
{"Answer": "http://www.cnblogs.com/Fatedayt/archive/2011/09/19/2181775.html", "Konwledge_Point": "最小生成树", "Question": ["迷宫城堡             ", ["Problem Description", "\n为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N<=10000)和M条通道(M<=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。", "\n\n", "Input", "\n输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。", "\n\n", "Output", "\n对于输入的每组数据，如果任意两个房间都是相互连接的，输出\"Yes\"，否则输出\"No\"。", "\n\n", "Sample Input", "\n3 3 1 2 2 3 3 1 3 3 1 2 2 3 3 2 0 0", "\n\n", "Sample Output", "\nYes No"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;br /&gt;using namespace std;&lt;br /&gt;const int inf&amp;#61;0x3f3f3f3f;&lt;br /&gt;int n,m;&lt;br /&gt;int mp[50][50],book[50],dis[50],parent[50];&lt;br /&gt;void prim()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        dis[i]&amp;#61;mp[1][i];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        if(mp[1][i]!&amp;#61;inf)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            parent[i]&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int ans;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    book[1]&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        int minn&amp;#61;inf,u;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        for(int j&amp;#61;1;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            if(!book[j]&amp;amp;&amp;amp;minn&amp;gt;dis[j])&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                u&amp;#61;j;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                minn&amp;#61;dis[j];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        book[u]&amp;#61;1;&lt;/span&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;    int x&amp;#61;parent[u];\n    int y&amp;#61;u;\n    int z&amp;#61;mp[parent[u]][u];\n    if(x&amp;gt;y) \n        swap(x,y);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d,%d,%d\\n&amp;#34;&lt;/span&gt;,x,y,z);\n    \n    for(int v&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;v&amp;lt;&amp;#61;n;v&amp;#43;&amp;#43;)\n    {\n        if(!book[v]&amp;amp;&amp;amp;dis[v]&amp;gt;mp[u][v])\n        {\n            dis[v]&amp;#61;mp[u][v];\n            parent[v]&amp;#61;u;\n        }    \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;p&gt;int main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    memset(book,0,sizeof(book));&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    memset(mp,0x3f,sizeof(mp));&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        mp[i][i]&amp;#61;0;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;&amp;#61;m;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        int a,b,c;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        mp[a][b]&amp;#61;mp[b][a]&amp;#61;min(mp[a][b],c);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    prim();&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["R7-2 最小生成树构造 (25 分)", [" giegie们！！", "\n", "输入样例：", "4 6", "1 2 1", "1 3 4", "1 4 1", "2 3 3", "2 4 2", "3 4 5"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mctFromLeafValues&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt; arr&lt;/span&gt;):\n    res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        min_val &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(arr)\n        idx &amp;#61; arr.index(min_val)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; idx &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; idx &amp;lt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左有右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左没右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#为什么是16&amp;#xff1f;因为最大只有15&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有右没左&lt;/span&gt;\n            left_val, right_val &amp;#61; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            \n        res &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) &lt;span class=\"hljs-comment\"&gt;#把当前最小值删掉&amp;#xff0c;已经用完了&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res\narr &amp;#61; [&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(mctFromLeafValues(arr))\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["用python语言实现“最小代价生成树”问题的分支限界算法", ["求Python的各位帮忙看看，用python语言实现“最小代价生成树”问题的分支限界算法"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;打断点追一下这个t值&amp;#xff0c;有可能t值还是-1。&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["这个缓冲区溢出和无效数据怎么解决啊", ["大一求问，用prim算法求最小生成树，⚠️缓冲区溢出和无效数据，不知道怎么改"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#include&amp;#34;MST.h&amp;#34;之前的部分保存为MST.h文件&lt;br /&gt;这行前面缺个花括号&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["我从别人那复制过来的但是找不到MST.h文件", ["帮我看看这些代码为什么运行不了，我缺少的MST.h文件应该是什么内容才能让这些正常运行在vs2013里写的", "\n", "\n```c++\n", "#", "include", "<vector>", "\n", "#", "include", "<string>", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "MST", "{\n", "public", ":\n    ", "MST", "(){ pNumber = ", "0", "; map = ", "NULL", "; }  \n    ~", "MST", "(){ ", "delete", " []map; }\n    ", "void", " ", "createPoint", "()", ";        ", "//对应通信网造价模拟系统的A选项创建电网顶点", "\n    ", "void", " ", "addEdge", "()", ";            ", "//对应通信网造价模拟系统的B选项添加电网的边", "\n    ", "void", " ", "createTree", "()", ";           ", "//对应通信网造价模拟系统的C选项构造最小生成树", "\n    ", "void", " ", "displayTree", "()", ";           ", "//对应通信网造价模拟系统的D选项显示最小生成树", "\n    ", "string ", "findPoint", "(", "int", " iPos)", ";", "//寻找pName中iPos位置的节点名称", "\n    ", "bool", " ", "judgePoint", "(", "int", " iPos)", "; ", "//判断iPos位置的点是否已经放入store容器中", "\n    ", "int", " ", "judgeEdge", "(", "int", " temp)", ";   ", "//判断是否存在权值比temp数值还小的边", "\n", "private", ":\n    ", "int", " pNumber;               ", "//通信网节点的个数", "\n    ", "int", " iCount = ", "0", ";            ", "//通信网节点个数计数器", "\n    ", "int", " iStart;                ", "//起始点位置对应pName中的位置", "\n    ", "int", " iWeight;               ", "//存在比temp数值更小的边的权", "\n    ", "int", " **map;                 ", "//用于存储各边之间的权", "\n    string start;              ", "//起始点位置的名称", "\n    vector <string>pName;      ", "//存储所有节点的名称", "\n    vector<pair<", "int", ", ", "int", ">>store;", "//store中的起点存储的每条边的终点和对应的权值", "\n\n", "#", "include", "\"MST.h\"", "\n", "using", " ", "namespace", " std;\n", "bool", " ", "MST::judgePoint", "(", "int", " iPos)", "{\n    ", "for", " (", "int", " iX=", "0", " ; iX < store.", "size", "(); iX++){         \n        ", "if", " (iPos == store[iX].first&&store[iX].second != ", "0", ")\n            ", "return", " ", "false", ";               ", "//store中存在这个点", "\n    }\n    ", "return", " ", "true", ";                        ", "//store中不存在这个点", "\n}\n", "int", " ", "MST::judgeEdge", "(", "int", " temp)", "{\n    ", "int", " iPos;\n    ", "if", " (iCount == ", "1", "){                   ", "//第二个顶点开始的位置单独讨论", "\n        ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){\n            ", "if", " (map[iStart][iX] < temp&&map[iStart][iX]>", "0", " && map[iStart][iX] != store[", "0", "].second){\n                iWeight = map[iStart][iX];\n                ", "return", " iX;\n            }\n        }\n    }\n    ", "if", "(iCount>", "1", "){\n        ", "int", " iPos = iCount", "-1", ";\n        ", "for", " (iPos;iPos>=", "0", ";iPos--)\n            ", "for", " (", "int", " iX = ", "0", "; iX < pNumber;iX++)\n                ", "if", " (map[iPos][iX] < temp&&map[iPos][iX] != store[iPos].second&&map[iPos][iX]>", "0", " && iX != iStart){\n                iWeight = map[iPos][iX];\n                ", "return", " iX;                ", "//之前的顶点对应有权更小的边", "\n            }\n        }\n    ", "return", " ", "-1", ";", "//没有权更小的边", "\n}\n", "void", " ", "MST::createTree", "()", "{\n    cout << ", "\"请输入起始顶点：\"", ";\n    cin >> start;\n    iCount = ", "0", ";        ", "//计数器每次操作前置0                     ", "\n    ", "int", " iPos,temp,iName;  ", "//iPos对应每次搜索的起点 temp对应起点对应的边的权 iName对应搜索后的终点", "\n    store.", "clear", "();       ", "//store每次操作前清空", "\n    store.", "resize", "(pNumber);\n    ", "for", " (iPos = ", "0", "; iPos < pNumber; iPos++){  ", "//首先找到起始点对应pName中的位置", "\n        ", "if", " (start == pName[iPos]){\n            iStart = iPos;\n            ", "break", ";\n        }\n    }\n    ", "while", " (iCount<pNumber", "-1", "){         \n        ", "if", " (iPos!=", "0", ")                    ", "//搜索前分别讨论iPos为0时可能出现的不同状况", "\n            temp=map[iPos][", "0", "];\n        ", "if", " (iPos == ", "0", "){\n            temp = map[iPos][", "1", "];\n            iName = ", "1", ";\n        }\n        ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){   ", "//从起点开始搜寻周围权最小的边", "\n            ", "if", " (temp>=map[iPos][iX] && map[iPos][iX]>", "0", " && iPos != iX&&", "judgePoint", "(iX)){\n                ", "if", " ((iCount != ", "0", " && iPos != iStart||iCount==", "0", "&&iPos==iStart)&&iX!=iStart){\n                    temp = map[iPos][iX];\n                    iName = iX;\n                }\n            }\n        }\n        ", "if", " (", "judgeEdge", "(temp) == ", "-1", "){   ", "//如果store之前的顶点不存在权比temp更小的边", "\n            store[iCount].second = temp;\n            store[iCount].first = iName;\n        }\n\n        ", "if", " (", "judgeEdge", "(temp) != ", "-1", "){    ", "//如果存在权比temp更小的边", "\n            store[iCount].first = ", "judgeEdge", "(temp);\n            store[iCount].second = iWeight;\n        }\n        iPos = store[iCount].first;\n        iCount++;\n    }\n    cout << ", "\"生成Prim最小生成树！\"", "<<endl;\n    cout << endl;\n}\n", "void", " ", "MST::createPoint", "()", "{\n    string name;\n    cout << ", "\"请输入顶点的个数：\"", ";\n    cin >> pNumber;\n    cout << ", "\"请依次输入各顶点的名称：\"", " << endl;\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){\n        cin >> name;\n        pName.", "push_back", "(name);\n    }\n    cout << endl;\n}\n", "void", " ", "MST::addEdge", "()", "{\n    string pA, pB;\n    ", "int", " iA = ", "0", ", iB = ", "0", ";\n    map = ", "new", " ", "int", "*[pNumber];\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++)\n        map[iX] = ", "new", " ", "int", "[pNumber];\n\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber - ", "1", "; iX++){\n        map[iX][iX] = ", "0", ";\n        cout << ", "\"请输入两个顶点及边: \"", ";\n        ", "for", " (", "int", " iY = iX + ", "1", "; iY < pNumber; iY++){ \n            iA = iB = ", "0", ";\n            cin >> pA >> pB;\n            ", "while", " (pA != pName[iA])   ", "//搜索输入两个顶点对应的位置，并将权赋值到对应的map中", "\n                iA++;\n            ", "while", " (pB != pName[iB])\n                iB++;\n            cin >> map[iA][iB];\n            ", "if", " (iY != pNumber - ", "1", ")\n                cout << ", "\"请输入两个顶点及边: \"", ";\n        }\n    }\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){\n        ", "for", " (", "int", " iY = ", "0", "; iY < iX; iY++){\n            map[iX][iY] = map[iY][iX];\n        }\n    }\n    cout << endl;\n    \n}\n", "void", " ", "MST::displayTree", "()", "{\n    string end;\n    string begin;\n    cout << ", "\"最小生成树的的顶点及边为：\"", " << endl;\n    cout << endl;\n    cout << start << ", "\"-<\"", " << store[", "0", "].second << ", "\">-\"", " << ", "findPoint", "(store[", "0", "].first);\n    ", "for", " (", "int", " iX = ", "1", "; iX < pNumber - ", "1", "; iX++){\n        ", "if", " (store[iX].second == map[store[iX].first][iX]){", "//如果最小生成树没有分支", "\n            begin = ", "findPoint", "(store[iX - ", "1", "].first);\n            end = ", "findPoint", "(store[iX].first);\n            cout << ", "\"        \"", " << begin << ", "\"-<\"", " << store[iX].second << ", "\">-\"", " << end;\n        }\n        ", "else", "{", "//最小生成树存在分支，依据终点和权找到对应的起点", "\n            ", "int", " iStart = store[iX].second;\n            ", "int", " iJ = ", "0", ";\n            ", "int", " iK = ", "0", ";\n            ", "bool", " flag = ", "false", ";\n            ", "for", " (iJ = ", "0", "; iJ < pNumber; iJ++){\n                ", "for", " (iK = ", "0", "; iK < pNumber; iK++){\n                    ", "if", " (map[iJ][iK] == iStart){\n                        flag = ", "true", ";\n                        ", "break", ";\n                    }\n                }\n                ", "if", " (flag == ", "true", ")\n                    ", "break", ";\n            }\n            ", "if", " (iK == store[iX].first){\n                begin = ", "findPoint", "(iJ);\n                end = ", "findPoint", "(iK);\n                cout << ", "\"        \"", " << begin << ", "\"-<\"", " << store[iX].second << ", "\">-\"", " << end;\n            }\n            ", "if", " (iJ == store[iX].first){\n                begin = ", "findPoint", "(iK);\n                end = ", "findPoint", "(iJ);\n                cout << ", "\"        \"", " << begin << ", "\"-<\"", " << store[iX].second << ", "\">-\"", " << end;\n            }\n        }\n    }\n    cout << endl << endl;\n}\n", "string ", "MST::findPoint", "(", "int", " iPos)", "{\n    string point;\n    point = pName[iPos];\n    ", "return", " point;\n}\n\n", "#", "include", "<iostream>", "\n", "#", "include", "<vector>", "\n", "#", "include", "\"MST.h\"", "\n", "using", " ", "namespace", " std;\n", "void", " ", "main", "()", "{\n    MST tree;\n    ", "char", " order;\n    cout << ", "\"**                     通信网造价模拟系统                     **\"", " << endl;\n    cout << ", "\"==============================================================\"", " << endl;\n    cout << ", "\"**                     A---创建通信网顶点                     **\"", " << endl;\n    cout << ", "\"**                     B---添加通信网的边                     **\"", " << endl;\n    cout << ", "\"**                     C---构造最小生成树                   **\"", " << endl;\n    cout << ", "\"**                     D---显示最小生成树                   **\"", " << endl;\n    cout << ", "\"**                     E---退出   程序                      **\"", " << endl;\n    cout << ", "\"==============================================================\"", " << endl<<endl;\n    cout << ", "\"请选择操作：\"", ";\n    cin >> order;\n    ", "while", " (order!=", "'E'", "){\n        ", "switch", " (order)\n        {\n        ", "case", " ", "'A'", ":\n            tree.", "createPoint", "();\n            ", "break", ";\n        ", "case", " ", "'B'", ":\n            tree.", "addEdge", "();\n            ", "break", ";\n        ", "case", " ", "'C'", ":\n            tree.", "createTree", "();\n            ", "break", ";\n        ", "case", " ", "'D'", ":\n            tree.", "displayTree", "();\n        ", "default", ":\n            ", "break", ";\n        }\n        cout << ", "\"请选择操作：\"", ";\n        cin >> order;\n    }\n}\n\n\n\n\n\n\n\n", "\n", "```"]], "Tag": "算法设计"}
{"Answer": "[http://www.cnblogs.com/hxsyl/p/3286956.html](http://www.cnblogs.com/hxsyl/p/3286956.html \"\")", "Konwledge_Point": "最小生成树", "Question": ["如何在克鲁斯卡尔中加入并查集的运用", ["在运用克鲁斯卡尔算法求最小生成树时如何将并查集的相关内容也运用进去？第一次发问，请大家给力点！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;一个人搞确实有难度&amp;#xff0c;建议和老师同学多交流&amp;#xff0c;参加一些相关的比赛&amp;#xff0c;积累经验&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["想问下做项目是啥意思", ["目前学完了c，数据结构与算法学到了图的最小生成树，力扣也刷了五六十道题了，听说做项目提升快，但现在还没见过项目，也不知道咋找项目，有大佬能指导下吗😂"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/774661583276158.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/992790583276149.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;\n#define &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;\nusing namespace std;\n\n//利用二维数组创建有向图的邻接矩阵\nvoid &lt;span class=\"hljs-symbol\"&gt;CreateMatrix&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;]);\n//利用&lt;span class=\"hljs-symbol\"&gt;Prim&lt;/span&gt;算法求解最小生成树\nvoid &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int i, int visit[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int dist[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int path[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;]);\n\nint main()\n{\n    //创建有向图的带有权值的邻接矩阵\n    int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;];\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        for (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        {\n            mat[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;INT_MAX&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-symbol\"&gt;CreateMatrix&lt;/span&gt;(mat);\n    int visit[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    int dist[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;];\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        dist[i] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;INT_MAX&lt;/span&gt;;\n    }\n    int path[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n\n    //利用&lt;span class=\"hljs-symbol\"&gt;Prim&lt;/span&gt;算法求解最小生成树\n    //初始源点的dist初始化为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;#xff0c;path初始化为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    dist[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    path[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(mat,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,visit,dist,path);\n\n    //输出最小生成树的边及相应权值&amp;#xff0c;总权值\n    int totalValue &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        totalValue &amp;#43;&amp;#61; dist[i];\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最小生成树的边&amp;#xff1a;&amp;lt;v%d , v%d&amp;gt;&amp;#34;&lt;/span&gt;,(i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(path[i]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;));\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34; 权值&amp;#xff1a;%d&amp;#34;&lt;/span&gt;,dist[i]);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最小生成树的总权值&amp;#xff1a;%d&amp;#34;&lt;/span&gt;,totalValue);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n//利用二维数组创建有向图的邻接矩阵&amp;#xff0c;带权值\nvoid &lt;span class=\"hljs-symbol\"&gt;CreateMatrix&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;])\n{\n    mat[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n}\n\n//利用&lt;span class=\"hljs-symbol\"&gt;Prim&lt;/span&gt;算法求解最小生成树\nvoid &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int i, int visit[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int dist[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int path[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;])\n{\n    //初始化\n    visit[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    //dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    //path[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    //访问与顶点i相邻接的未被访问的顶点&amp;#xff0c;获取路径长度&amp;#xff0c;如果小于之前路径长度则替换&amp;#xff0c;并记录路径\n    for (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;j&amp;#43;&amp;#43;)\n    {\n        if (visit[j] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; mat[i][j] !&amp;#61; &lt;span class=\"hljs-symbol\"&gt;INT_MAX&lt;/span&gt;)\n        {\n            if (mat[i][j]&amp;lt;dist[j])\n            {\n                dist[j] &amp;#61; mat[i][j];\n                path[j] &amp;#61; i;\n            }\n        }\n    }\n\n    //在未被访问过的顶点中寻找路径最短的顶点\n    int minDist &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    for (int m &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;m&amp;lt;&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;m&amp;#43;&amp;#43;)\n    {\n        if (visit[m] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            minDist &amp;#61; m;\n            break;\n        }\n    }\n    for (int k &amp;#61; minDist &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; k&amp;lt;&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;; k&amp;#43;&amp;#43;)\n    {\n        if (visit[k] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; dist[k]&amp;lt;dist[minDist])\n        {\n            minDist &amp;#61; k;\n        }\n\n    }\n    //如果找到继续寻找到下一个顶点的最短路径&amp;#xff08;递归&amp;#xff09;\n    if (minDist !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(mat, minDist, visit, dist, path);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["求下面问题的完整答案，图在链接里", ["已知顶点集合{a,b,c,d,e,f}，构成的无向图的带权邻接矩阵如下：", "https://cg.sau.edu.cn/userfiles/image/1483599133822034852.png", "① 画出无向带权图；   ", "② 给出无向带权图的最小生成树；"]], "Tag": "算法设计"}
{"Answer": "你的toString方法里递归调用了,死循环出不来了...\r\n这是AbstractMap的toString方法:\r\n\r\npublic String toString() {\r\n\tIterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();\r\n\tif (! i.hasNext())\r\n\t    return \"{}\";\r\n\r\n\tStringBuilder sb = new StringBuilder();\r\n\tsb.append('{');\r\n\tfor (;;) {\r\n\t    Entry&lt;K,V&gt; e = i.next();\r\n\t    K key = e.getKey();\r\n\t    V value = e.getValue();\r\n\t    sb.append(key   == this ? \"(this Map)\" : key);\r\n\t    sb.append('=');\r\n\t    sb.append(value == this ? \"(this Map)\" : value);\r\n\t    if (! i.hasNext())\r\n\t\treturn sb.append('}').toString();\r\n\t    sb.append(\", \");\r\n\t}\r\n    }\r\n\r\n由于你的Map里Key还是City对象,所以执行Map的toString时这一行 sb.append(key   == this ? \"(this Map)\" : key);会自动调用key的toString方法,这样又进入了City的toString方法,然后就挂了.....", "Konwledge_Point": "最小生成树", "Question": ["StackOverflowError异常，哪位好心人看看啊", ["   打算用面向对象思想，写个求最小生成树问题。写了一半，就出现问题了import java.util.HashMap;", "\n\n", "public class City {\n    private String cityName; \n\n    private HashMap<City, Double> adjCities = new HashMap<City, Double>(); \n\n    public City(String cityName) {\n        this.cityName = cityName;\n\n    }\n\n    public void addAjdCity(City city, double cost) {\n        adjCities.put(city, cost);\n        // System.out.println(\"test1\");\n        city.adjCities.put(this, cost);\n        // System.out.println(\"test2\");\n\n    }\n\n    public void removeAjdCity(City city) {\n\n    }\n\n    public void removeAjdCity(String cityName) {\n\n    }\n\n    public String toString() {\n        return cityName + \":\" + \"\\n\" + adjCities;\n    }\n\n    public static void main(String[] args) {\n        City c1 = new City(\"上海\");\n        City c2 = new City(\"杭州\");\n\n        c1.addAjdCity(c2, 100);\n        // 怎么输出c1 c2时会出问题？StackOverflowError异常。如果把最后两句println注释掉，就不会报错？？\n        System.out.println(c1);\n        System.out.println(c2);\n\n    }\n\n}\n"]], "Tag": "算法设计"}
{"Answer": "就是将下标为k的顶点各边权值小于此前这些顶点未被加入的生成树权值", "Konwledge_Point": "最小生成树", "Question": ["小白求教，请问**部分是什么意思？", ["//Prim算法最小生成树", "\nvoid MiniSpanTree_Prime(Graph g)", "\n{", "\n    int min, i, j, k;", "\n    int adjvex[MAXVEX];         //保存相关顶点下标", "\n    int lowcost[MAXVEX];        //保存相关顶点间边的权值", "\n    lowcost[0] = 0;             //初始化第一个权值为0，即v0加入生成树  ", "\n\n", "adjvex[0] = 0;              //初始化第一个顶点下标为0  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    //循环除下标为0外的全部顶点  \n    lowcost[i] = g.arc[0][i];   //将v0顶点与之有边的权值存入数组  \n    adjvex[i] = 0;              //初始化都为v0下标  \n}  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    min = INFINITY;             //初始化最小权值为无穷大  \n    j = 1;  \n    k = 0;  \n    while(j < g.numVertexes) //循环全部顶点  \n    {  \n        //如果权值不为0,且权值小于min  \n        if(lowcost[j] != 0 && lowcost[j] < min)  \n        {  \n            min = lowcost[j];       //则让当前权值成为最小值  \n            k = j;                  //将当前最小值的下标存入k  \n        }  \n        j++;  \n    }  \n    printf(\"(%d,%d)\", adjvex[k], k);//打印当前顶点边中权值最小边  \n    lowcost[k] = 0;                 //将当前顶点的权值设置为0，表示此顶点已经完成任务  \n\n    for(j = 1; j < g.numVertexes; j++)//循环所有顶点  \n    {  \n        if(lowcost[j] != 0 && g.arc[k][j] < lowcost[j])  \n        {  \n          **  //若下标为k的顶点各边权值小于此前这些顶点未被加入的生成树权值 ** \n            lowcost[j] = g.arc[k][j];  \n            adjvex[j] = k;         //将下标为k的顶点存入adjvex  \n        }  \n    }  \n}  \nprintf(\"\\n\");  \n", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mctFromLeafValues&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt; arr&lt;/span&gt;):\n    res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        min_val &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(arr)\n        idx &amp;#61; arr.index(min_val)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; idx &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; idx &amp;lt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左有右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左没右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#为什么是16&amp;#xff1f;因为最大只有15&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有右没左&lt;/span&gt;\n            left_val, right_val &amp;#61; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            \n        res &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) &lt;span class=\"hljs-comment\"&gt;#把当前最小值删掉&amp;#xff0c;已经用完了&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res\narr &amp;#61; [&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(mctFromLeafValues(arr))\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["python分支限界算法", ["用python语言实现最小代价生成树问题，利用分支限界算法python"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;      &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mctFromLeafValues&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, arr&lt;/span&gt;):\n        &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n        :type arr: List[int]\n        :rtype: int\n        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n        res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            min_val &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(arr)\n            idx &amp;#61; arr.index(min_val)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; idx &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; idx &amp;lt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左有右&lt;/span&gt;\n                left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左没右&lt;/span&gt;\n                left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#为什么是16&amp;#xff1f;因为最大只有15&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有右没左&lt;/span&gt;\n                left_val, right_val &amp;#61; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n                \n            res &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_val * left_val, min_val * right_val)\n            arr.remove(min_val) &lt;span class=\"hljs-comment\"&gt;#把当前最小值删掉&amp;#xff0c;已经用完了&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["python初学者，问一个简单的分支限界算法", ["用python语言实现“最小代价生成树”问题的分支限界算法", "求解答……"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;网上很多原题解析&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/LYKXHTP/article/details/88316879\" id=\"textarea_1667819239063_1667819264187_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;哈夫曼树 - 九度教程第30题_Yoc Lu的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;哈夫曼树 - 九度教程第30题题目时间限制&amp;#xff1a;1 秒 内存限制&amp;#xff1a;32 兆 特殊判题&amp;#xff1a;否题目描述&amp;#xff1a;哈夫曼树&amp;#xff0c;第一行输入一个数n&amp;#xff0c;表示叶结点的个数。需要用这些叶结点生成哈夫曼树&amp;#xff0c;根据哈夫曼树的概念&amp;#xff0c;这些结点有权值&amp;#xff0c;即weight&amp;#xff0c;题目需要输出所有结点的值与权值的乘积之和。输入&amp;#xff1a;输入有多组数据。每组第一行输入一个数n&amp;#xff0c;接着输入n个叶节点&amp;#xff08;叶节点权值不超过100&amp;#xff0c;2&amp;amp;amp;lt;&amp;#61;n&amp;amp;amp;lt;&amp;#61;10...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/LYKXHTP/article/details/88316879&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["构造哈夫曼树以及计算带权路径长度", ["7-1 哈夫曼树", "分数 15", "作者 李廷元", "单位 中国民用航空飞行学院", "哈夫曼树，第一行输入一个数n，表示叶结点的个数。", "\n", "需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出哈夫曼树的带权路径长度（WPL）。", "\n", "输入格式:", "第一行输入一个数n，第二行输入n个叶结点（叶结点权值不超过1000，2<=n<=1000）。", "\n", "输出格式:", "在一行中输出WPL值。", "\n", "输入样例:", "5", "1 2 2 5 9", "输出样例:", "37", "\n", "我的问题：", "我们老师上课讲解过如何构造哈夫曼树这是方法：", "结点结构如下。", "\n", "define MAXBIT 10", "define MAXVALUE 1000", "typedef struct HNode /定义结点结构/", "{ int weight;", "int parent , lchild , rchild;", "}HNode, *HTree;", "\n", "HTree HuffmanTree( int w , int n) /给定n个权值构造哈夫曼树/", "{ / w存储n个字符的权值，构造哈夫曼树HT*/", "int m, m1, m2, x1, x2, i, j; HTree ht;", "HNode *p;", "if (n <= 1) return NULL;", "m= 2*n-1;", "ht = (HNode *)malloc (m*sizeof(HNode) ); /*哈夫曼树的构造*/", "if(ht==NULL) return ht;", "for(p = ht, i =0; i < n; ++ i, ++ p, ++w) /*初始化叶子结点信息*/", "{ p->weight = *w; p->lchild = -1;", "p->rchild = -1; p->parent = -1;", "}", "for( ; i < m; ++ i, ++ p) /*初始化分支结点信息*/", "{ p->weight = 0; p->lchild = -1;", "p->rchild = -1; p->parent = -1;", "}", "for( i = n; i < m; ++ i) /*构造哈夫曼树 */", "{ m1 = m2 = MAXVALUE;", "x1 = x2 = 0; /寻找parent为-1且权值最小的两棵子树/", "for(j = 0; j < i; ++ j)", "{ if( ht[j].parent == -1 && ht[j].weight < m1)", "{ m2 = m1; x2 = x1; m1 = ht[j].weight; x1 = j; }", "else if( ht[j].parent == -1 && ht[j].weight < m2)", "{ m2 = ht[j].weight; x2 = j; }", "}", "/合并成一棵新的子树/", "ht[x1].parent = i; ht[x2].parent = i;", "ht[i].lchild = x1; ht[i].rchild = x2;", "ht[i].weight = m1 + m2;", "}", "return ht;", "}", "说实话看的有的云里雾里的能不能用中文描述下思路", "而且题中要让求最短路径长度，我这上面只有构造哈夫曼树这一块，求解最短路径长度这块有点不知道如何下手，还有主函数也不太知道咋写，希望能同时提供解题思路以及完整运行结果，感谢感谢，因为基础太差了，我就算知道思路自己也打不出来，答案错误看半天也找不出错误，辛苦"]], "Tag": "算法设计"}
{"Answer": "Problem1：https://paste.ubuntu.com/p/p5vmGWqFYh/\r\nProblem2：https://paste.ubuntu.com/p/kSSnfGDpMy/", "Konwledge_Point": "最小生成树", "Question": ["麻烦用c语言解决一下。。", ["A、编写一个读取1000个随机数整数的c程序，创建一个二叉树并打印树的深度。", "\n使用shuf-i1-1000命令生成随机数。（自己生成也行）", "\n B、编写一个c程序，重复上一个问题的实验1000次（每次一千个随机数都不同）。计算所创建的1000个二叉树的平均深度，最小深度和最大深度。不要忘记在实验之间释放树。使用shuf-i1-1000000生成一个1000x1000=1000000个整数的列表。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;是你结构体数组S的最后一个元素下标越界了&lt;/p&gt;\n&lt;p&gt;N &amp;#61; 8; 你这样 s S[N-1]; 是声明结构体数组S的长度只有7个元素&amp;#xff0c;下标是从S[0]到S[6]&amp;#xff0c;没有S[7]&amp;#xff0c;最后一个S[7]的内存空间是不属于S数组的。虽然可以访问S[7]但不安全。因为这个内存空间可能会分配给其它变量&amp;#xff0c;当这个变量的值改变时S[7]也就受到影响。&lt;/p&gt;\n&lt;p&gt;改成 s S[N]; 就可以了&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢!&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["创建动态数组后，另一个数组的最后一个元素值被改变", ["在用c语言编写哈夫曼树时，为了存放权值，建立了一个有8个元素的结构体数组S，而后依次将8个结构体的权值成员赋值为1，2，3，4，5，6，7，8", "\n", "s  S[", "7", "];\n    ", "printf", "(", "\"请输入8个字符的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=", "7", ";i++){\n        scanf(", "\"%u\"", ",&S[i].weight);\n        ", "printf", "(", "\"%d\\n\"", ",S[i].weight);\n    }\n\n", "\n", "\n", "然后创建一个动态数组HT，此时发现S最后一个结构体元素的权值成员变为了随机值，这是为什么？", "\n", "    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "printf", "(", "\"%u\\n\"", ",S[", "7", "].weight);\n    ", "for", "(", "unsigned", " ", "int", " g=", "0", ";g<=", "7", ";g++){\n         ", "printf", "(", "\"%u\\t\"", ",S[g].weight);\n    }\n\n", "\n", "\n", "完整代码如下", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "define", " N 8", "\n", "//存储哈夫曼树的静态三叉链表定义", "\n", "typedef", " ", "struct", "{\n", "unsigned", " ", "int", " weight;\n", "unsigned", " ", "int", " parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n", "typedef", " ", "char", " ** HuffmanCode;\n", "//字符、权值、对应编码组成的结构体类型", "\n", "struct", " ", "s", " \n{\n", "char", " c;\n", "unsigned", " ", "int", " weight;\n", "char", " code[N];\n};\n", "//选择两个权值最小的结点", "\n", "void", " ", "Select", "(HuffmanTree &HT,", "unsigned", " ", "int", " i,", "int", " *s1,", "int", " *s2)", "{\n    ", "unsigned", " ", "int", " min1,min2,j;\n    min1=min2=", "9999", ";\n    ", "for", "(j=", "1", ";j<=i;j++){\n        ", "if", "(HT[j].parent==", "0", "){\n            ", "if", "(HT[j].weight<min2){\n                ", "if", "(HT[j].weight<min1){\n                    min2=min1;\n                    min1=HT[j].weight ;\n                    *s1=j;\n                }\n                ", "else", " {\n                    min2=HT[j].weight ;\n                    *s2=j;\n                }\n            }\n        }\n    }\n}\n\n", "//构造哈夫曼树和哈夫曼编码", "\n", "void", " ", "Huffman", "(HuffmanTree &HT,HuffmanCode &HC,", "unsigned", " ", "int", " n,s S[N])", "{\n    ", "if", " (n<=", "1", ")", "return", ";\n    ", "unsigned", " ", "int", " i=", "0", ",m=", "2", "*n", "-1", ",c=", "0", ",f=", "0", ";\n    ", "int", " s1=", "0", ",s2=", "0", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "printf", "(", "\"%u\\n\"", ",S[", "7", "].weight);\n    ", "for", "(", "unsigned", " ", "int", " g=", "0", ";g<=", "7", ";g++){\n         ", "printf", "(", "\"%u\\t\"", ",S[g].weight);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n    ", "for", "(p=HT+", "1", ",i=", "1", ";i<=n;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=S[i", "-1", "].weight;\n    }\n    ", "for", "(;i<=m;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=", "0", ";\n    }\n    ", "for", "(i=n+", "1", ";i<=m;++i){\n        ", "Select", "(HT,n,&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", "*));\n    ", "char", " *cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "printf", "(", "\"test1\"", ");\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent){\n            ", "if", "(HT[f].lchild==c)cd[--start]=", "'0'", ";\n            ", "else", " cd[--start]=", "'1'", ";}\n        HC[i]=(", "char", "*)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n        ", "strcpy", "(HC[i],&cd[start]);\n        ", "strcpy", "(S[i].code,&cd[start]);\n    }\n}\n", "//输出哈夫曼树数据", "\n", "void", " ", "PrintHuffman", "(HuffmanTree HT,", "int", " n,s S[N])", "{\n    ", "printf", "(", "\"哈夫曼树如下所示:\\n\"", ");\n    ", "for", "(", "int", " k=", "1", ";k<=", "2", "*n", "-1", ";k++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[k].rchild);\n    }\n    ", "printf", "(", "\"8个字符的字符、权值及哈夫曼编码如下:\\n\"", ");\n    ", "for", "(", "int", " l=", "0", ";l<=n;l++){\n         ", "printf", "(", "\"%s\\t%u\\t%s\\t\\n\"", ",S[l].c,S[l]. weight,S[l].code);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n ", "//哈夫曼树的建立和编码的生成", "\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N", "-1", "];\n    ", "printf", "(", "\"请输入8个字符，及它们的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=N;i++){\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%s\"", ",&S[i", "-1", "].c);\n        ", "printf", "(", "\"请输入该字符的权值:\"", ");\n        ", "scanf", "(", "\"%u\"", ",&S[i", "-1", "].weight);\n        ", "printf", "(", "\"%d\\n\"", ",S[i", "-1", "].weight);\n    }\n    ", "Huffman", "(HT,HC,", "8", ",S);\n   \n ", "//打印输出哈夫曼树数据", "\n  ", "//  PrintHuffman(HT,8,S);", "\n ", "//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串", "\n    ", "printf", "(", "\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"", ");\n    \n    ", "printf", "(", "\"\\n该字符串对应的哈夫曼编码为:\"", ");\n\n\n", "//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串", "\n    ", "printf", "(", "\"请输入一个由0或1构成的哈夫曼编码:\"", ");\n    ", "printf", "(", "\"\\n该哈夫曼编码对应的字符串为\"", ");\n    ", "system", "(", "\"PAUSE\"", ");\n ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;scanf(&amp;#34;%s&amp;#34;,&amp;amp;S[i-1].c);&lt;br /&gt;改为&lt;br /&gt;scanf(&amp;#34;%c&amp;#34;,&amp;amp;S[i-1].c);&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["无法打印结构体数组里的数据", ["在练习用c语言实现哈夫曼树时，建立了一个结构体数组原来存放字符及其相应的权值和编码", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "define", " N 8", "\n", "//存储哈夫曼树的静态三叉链表定义", "\n", "typedef", " ", "struct", "{\n", "unsigned", " ", "int", " weight;\n", "unsigned", " ", "int", " parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n", "typedef", " ", "char", " ** HuffmanCode;\n", "//字符、权值、对应编码组成的结构体类型", "\n", "struct", " ", "s", " \n{\n", "char", " c;\n", "unsigned", " ", "int", " weight;\n", "char", " code[N];\n};\n", "//选择两个权值最小的结点", "\n", "void", " ", "Select", "(HuffmanTree &HT,", "unsigned", " ", "int", " i,", "unsigned", " ", "int", " *s1,", "unsigned", " ", "int", " *s2)", "{\n    ", "unsigned", " ", "int", " min1,min2,j;\n    min1=min2=", "9999", ";\n    ", "for", "(j=", "1", ";j<=i;j++){\n        ", "if", "(HT[j].weight<min2&&HT[j].parent ==", "0", "){\n            min2=min1;\n            *s2=j;\n            ", "if", "(HT[j].weight<min1&&HT[j].parent==", "0", "){\n                min1=HT[j].weight;\n                *s1=j;\n\n            }\n        }\n    }\n}\n\n", "//构造哈夫曼树和哈夫曼编码", "\n", "void", " ", "Huffman", "(HuffmanTree &HT,HuffmanCode &HC,", "unsigned", " ", "int", " n,s S[N])", "{\n    ", "if", " (n<=", "1", ")", "return", ";\n    ", "unsigned", " ", "int", " i=", "0", ",m=", "2", "*n", "-1", ",c=", "0", ",f=", "0", ",s1=", "0", ",s2=", "0", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "for", "(p=HT+", "1", ",i=", "1", ";i<=n;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=S[i", "-1", "].weight;\n    }\n", "/*    for(unsigned int v=1;v<=2*n-1;v++){\n        printf(\"%d\\t\",HT[v].weight);\n        printf(\"%d\\t\",HT[v].parent);\n        printf(\"%d\\t\",HT[v].lchild);\n        printf(\"%d\\t\\n\",HT[v].rchild);\n    }\n    printf(\"****************************************************\\n\");*/", "\n    ", "for", "(;i<=m;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=", "0", ";\n    }\n    ", "/*for(unsigned int o=1;o<=2*n-1;o++){\n        printf(\"%d\\t\",HT[o].weight);\n        printf(\"%d\\t\",HT[o].parent);\n        printf(\"%d\\t\",HT[o].lchild);\n        printf(\"%d\\t\\n\",HT[o].rchild);\n    }\n    printf(\"*************************************************************************\\n\");*/", "\n        ", "for", "(i=n+", "1", ";i<=m;++i){\n        ", "Select", "(HT,i", "-1", ",&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n", "/*    for(unsigned int k=1;k<=2*n-1;k++){\n        printf(\"%d\\t\",HT[k].weight);\n        printf(\"%d\\t\",HT[k].parent);\n        printf(\"%d\\t\",HT[k].lchild);\n        printf(\"%d\\t\\n\",HT[k].rchild);\n    }*/", "\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", "*));\n    ", "char", " *cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent){\n            ", "if", "(HT[f].lchild==c)cd[--start]=", "'0'", ";\n            ", "else", " cd[--start]=", "'1'", ";}\n        HC[i]=(", "char", "*)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n", "//        strcpy(HC[i],&cd[start]);", "\n        ", "strcpy", "(S[i].code,&cd[start]);\n    }\n    ", "free", "(cd);\n}\n", "//输出哈夫曼树数据", "\n", "void", " ", "PrintHuffman", "(HuffmanTree HT,", "int", " n,s S[N])", "{\n    ", "printf", "(", "\"哈夫曼树如下所示:\\n\"", ");\n    ", "for", "(", "int", " k=", "1", ";k<=", "2", "*n", "-1", ";k++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[k].rchild);\n    }\n    ", "printf", "(", "\"8个字符的字符、权值及哈夫曼编码如下:\\n\"", ");\n    ", "for", "(", "int", " l=", "0", ";l<=n;l++){\n    ", "printf", "(", "\"%s\\t%u\\t%s\\t\\n\"", ",S[l].c,S[l].weight,S[l].code);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n ", "//哈夫曼树的建立和编码的生成", "\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N];\n    ", "printf", "(", "\"请输入8个字符，及它们的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=N;i++){\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%s\"", ",&S[i", "-1", "].c);\n        ", "printf", "(", "\"请输入该字符的权值:\"", ");\n        ", "scanf", "(", "\"%u\"", ",&S[i", "-1", "].weight);\n    ", "//    printf(\"%d\\n\",S[i-1].weight);", "\n    }\n    ", "Huffman", "(HT,HC,", "8", ",S);\n   \n ", "//打印输出哈夫曼树数据", "\n    ", "PrintHuffman", "(HT,", "8", ",S);\n ", "//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串", "\n    ", "printf", "(", "\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"", ");\n    \n    ", "printf", "(", "\"\\n该字符串对应的哈夫曼编码为:\"", ");\n\n\n", "//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串", "\n    ", "printf", "(", "\"请输入一个由0或1构成的哈夫曼编码:\"", ");\n    ", "printf", "(", "\"\\n该哈夫曼编码对应的字符串为\"", ");\n    ", "system", "(", "\"PAUSE\"", ");\n ", "return", " ", "0", ";\n}\n", "\n", "但是打印输出的时候没有打印结构体数组里的数据，为什么？", "\n", "\n", "\n"]], "Tag": "算法设计"}
{"Answer": "普里姆算法是选顶点\r\n假设从A点出发构造最小生成树，距离A点最近的是D点，连接AD；然后距离A、D最近的是B点，连接BD；然后距离A、D、B最近的是C点，连接BC；\r\n然后距离A、D、B、C最近的是F点，连接CF；然后距离A、D、B、C、F最近的是G，连接FG；然后距离A、D、B、C、F、G点最近的是E点，连接GE；\r\n然后距离A、D、B、C、F、G、E点最近的是H点，连接EH。\r\n最小生成树为ADBCFGEH\r\n克鲁斯卡尔算法是选边\r\n边权为2最小，连接BC，EG；然后边权为3最小，连接EH；然后边权为4最小，连接CF，AD；然后边权为5最小，连接BD，FG。\r\n最小生成树为ADBCFGEH", "Konwledge_Point": "最小生成树", "Question": ["用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树", ["用普里姆算法或克鲁斯卡尔算法求下面无向带权图的最小生成树"]], "Tag": "算法设计"}
{"Answer": "不对，这题应该选A\r\n求顶点的入度的时间复杂度为O(e)*n=O(n*e)\r\n遍历顶点的时间复杂度是O(n^2)\r\n相加是O(n^2+n*e)=O(n^2)", "Konwledge_Point": "最小生成树", "Question": ["在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为?", ["在图采用邻接表存储时，求最小生成树的Prime算法的时间复杂度为?", "\nA o(n^2) B o(n^3) C o(n) D o(n+e)", "\n答案是o(n+e)。。。不理解..求过程"]], "Tag": "算法设计"}
{"Answer": "原理可以从 算法4th 中学习，\r\n里面讲了三种算法 csharp 代码：\r\n1. [KruskalMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/KruskalMinimumSpanTree.cs \"\")\r\n2. [LazyPrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/LazyPrimMinimumSpanTree.cs \"\")\r\n3. [PrimMinimumSpanTree](https://github.com/FuGangqiang/algorithms/blob/master/Books/Algorithms/Chap4/PrimMinimumSpanTree.cs \"\")", "Konwledge_Point": "最小生成树", "Question": ["求一个   最小生成树聚类  的程序", ["求一个最小生成树的聚类的程序，谢谢。最好是c++语言，当然matlab，java，python程序也可以。"]], "Tag": "算法设计"}
{"Answer": "http://bbs.csdn.net/topics/380240225", "Konwledge_Point": "最小生成树", "Question": ["类似最小生成树的算法求解答", ["输入一些二元组，二元组代表连通的两个节点。所有的二元组构成一个无向图。现在请你设计一个算法，求出一个最小生成树，使得图中没有回路，并且连接所有节点。输出的数据也用二元组表达。", "\n要用Java或者C#来实现。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;当然不一定了。&lt;br /&gt;例如&amp;#xff1a; 5个顶点 12345 的全连通图&amp;#xff0c;取出 4条边&amp;#xff08;12&amp;#xff0c;13&amp;#xff0c;23&amp;#xff0c;45&amp;#xff09;和 5个顶点 12345&amp;#xff0c;并不是连通图。&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["关于连通图和最小生成树", ["对于一个有n个顶点的连通图，最少有N-1条边，最多有C(n,2)条边", "那么如果现在这个连通图有C（n,2)条边，那么我取任意n-1条边出来和n个顶点组成一个新图，那么这个新图还是连通图吗"]], "Tag": "算法设计"}
{"Answer": "https://www.cnblogs.com/qscqesze/p/5246222.html", "Konwledge_Point": "最小生成树", "Question": ["最小生成树方面的一个问题，用C语言怎么解决的？？？？", ["Problem Description", "\nThere is an undirected graph G with n vertices and m edges. Every time, you can select several edges and delete them. The edges selected must meet the following condition: let G′ be graph induced from these edges, then every connected component of G′ has at most one cycle. What is the minimum number of deletion needed in order to delete all the edges.", "\n\n", "Input", "\nThere are multiple test cases. The first line of input contains an integer T indicating the number of test cases. For each test case:", "\n\n", "The first line contains two integers n and m (1≤n≤2000,0≤m≤2000) -- the number of vertices and the number of edges.", "\n\n", "For the next m lines, each line contains two integers ui and vi, which means there is an undirected edge between ui and vi (1≤ui,vi≤n,ui≠vi).", "\n\n", "The sum of values of n in all test cases doesn't exceed 2⋅104. The sum of values of m in all test cases doesn't exceed 2⋅104.", "\n\n", "Output", "\nFor each test case, output the minimum number of deletion needed.", "\n\n", "Sample Input", "\n3", "\n4 2", "\n1 2", "\n1 3", "\n4 5", "\n1 2", "\n1 3", "\n1 4", "\n2 3", "\n2 4", "\n4 4", "\n1 2", "\n2 3", "\n3 4", "\n4 1", "\n\n", "Sample Output", "\n1", "\n2", "\n1"]], "Tag": "算法设计"}
{"Answer": "http://hzwer.com/3666.html", "Konwledge_Point": "最小生成树", "Question": ["最小生成树                 ", ["Description", "\n\n", "　给定一个边带正权的连通无向图G=(V,E)，其中N=|V|，M=|E|，N个点从1到N依次编号，给定三个正整数u，v，和L (u≠v)，假设现在加入一条边权为L的边(u,v)，那么需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上？", "\n\n", "Input", "\n\n", "　　第一行包含用空格隔开的两个整数，分别为N和M；", "\n接下来M行，每行包含三个正整数u，v和w表示图G存在一条边权为w的边(u,v)。", "\n最后一行包含用空格隔开的三个整数，分别为u，v，和 L；", "\n数据保证图中没有自环。", "\nOutput", "\n\n", "　输出一行一个整数表示最少需要删掉的边的数量。", "\n\n", "Sample Input", "\n\n", "3 2", "\n3 2 1", "\n1 2 3", "\n1 2 2", "\nSample Output", "\n\n", "1"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;prim算法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;def findTree(G:dict):\n    &lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt; &amp;#61; list(G.keys())[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n    choice &amp;#61; [(&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;, i, j) for i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; G[&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;].items()]\n    choice.sort(&lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x:x[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])\n    tree &amp;#61; list()\n    seen &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;start&lt;/span&gt;}\n    while choice:\n        &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;&amp;#61; choice&lt;/span&gt;.pop(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        if &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;] not &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; seen:\n            seen.add(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;])\n            line &amp;#61; sorted([&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[0&lt;/span&gt;],&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;]])\n            line.append(&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[2&lt;/span&gt;])\n            tree.append(line)\n            for i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; G[&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;]].items():\n                choice.append((&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;[1&lt;/span&gt;],i,j))\n            choice.sort(&lt;span class=\"hljs-attr\"&gt;key&amp;#61;&lt;/span&gt;lambda x:x[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])\n    return tree\n\nif __name__ &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:\n    graph &amp;#61; {\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;g&amp;#34;&lt;/span&gt;:{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;}\n    }\n    lines &amp;#61; set()\n    for &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;, value&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; graph.items():\n        for i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; value.items():\n            temp &amp;#61; sorted([&lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;,i&lt;/span&gt;])\n            temp.append(j)\n            lines.add(tuple(temp))\n    print(lines)\n    tree &amp;#61; findTree(graph)\n    print(tree)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["关于最小生成树的应用", ["已知带权无向图（如下所示），求最小生成树。Program2用图要求输出：(1)所有的边及权值，如：（‘a’,’b’,10）…(2)最小生成树所包含的边，如：（’a’,‘c’,‘weight’:8）…", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;ArcGIS是一个功能丰富的地理信息系统(GIS)工具&amp;#xff0c;可以用来处理和分析地理数据。要在ArcGIS中构建最小生成树网络(Minimum Spanning Tree, MST)&amp;#xff0c;可以使用其中的&amp;#34;Network Analyst&amp;#34;工具。&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;首先&amp;#xff0c;需要拥有一个点数据集和一个边数据集。这些数据集可以来自 shapefile 文件&amp;#xff0c;CSV文件或者是GDB文件。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"2\"&gt;&lt;li&gt;打开ArcMap&amp;#xff0c;添加点数据集和边数据集到地图中。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"3\"&gt;&lt;li&gt;打开 &amp;#34;Network Analyst&amp;#34;工具&amp;#xff0c;在工具栏中选&amp;#34;New Network Analysis Layer&amp;#34;。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"3\"&gt;&lt;li&gt;在弹出的窗口中&amp;#xff0c;选择“Connectivity”作为类型&amp;#xff0c;并指定点数据集作为终点&amp;#xff0c;边数据集作为边。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"4\"&gt;&lt;li&gt;点击 &amp;#34;OK&amp;#34;按钮&amp;#xff0c;创建网络分析层。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"5\"&gt;&lt;li&gt;在 &amp;#34;Network Analyst&amp;#34;面板中&amp;#xff0c;选择 &amp;#34;Generate Service Area&amp;#34;工具。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"6\"&gt;&lt;li&gt;在弹出的窗口中&amp;#xff0c;选择要求的选项&amp;#xff08;比如网络设置&amp;#xff0c;分析阈值等&amp;#xff09;&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"7\"&gt;&lt;li&gt;在 &amp;#34;Solver&amp;#34;栏中&amp;#xff0c;选择“Minimum Spanning Tree&amp;#34;&amp;#xff0c;并点击 &amp;#34;Solve&amp;#34;按钮运行分析。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"8\"&gt;&lt;li&gt;分析完成后&amp;#xff0c;结果将显示在地图上&amp;#xff0c;表示最小生成树的路径。&lt;/li&gt;&lt;/ol&gt;\n&lt;ol start=\"9\"&gt;&lt;li&gt;可以通过导出成 shapefile或者其他文件格式来保存结果&amp;#xff0c;或者在 ArcGIS Pro里继续分析。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;另外&amp;#xff0c;需要注意的是,使用&amp;#34;Network Analyst&amp;#34;工具构建的最小生成树&amp;#xff0c;是基于空间关系的&amp;#xff0c;即根据点之间的距离构建最小生成树,如果需要根据权重来构建最小生成树&amp;#xff0c;需要在边数据中设置权重属性,并在Network Analyst中对权重属性进行设置。&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["如何用argis构建最小生成树网络", ["想使用arcgis构建最小生成树网络 该方法来源于faber2014的一篇文章 但是不知道如何具体操作"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/033372774866162.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;第一题D  1&amp;#43;2&amp;#43;4&amp;#43;7&amp;#61;14&lt;br /&gt;第二题 一个或多个&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["分别选择什么，第一道题有没有最小生成树的图示啊", ["分别选择什么，第一道题有没有最小生成树的图示啊，谢谢，辛苦辛苦", "\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;这道题一看就是最小生成树&amp;#xff0c;有两种方法&amp;#xff0c;分别为&lt;br /&gt;普里姆算法&amp;#xff08;prim&amp;#xff09;&lt;br /&gt;和&lt;br /&gt;克鲁斯卡尔&amp;#xff08;kruskal&amp;#xff09;&lt;br /&gt;本题解使用的是 kruskal&lt;br /&gt;假设连通网G&amp;#xff1d;&amp;#xff08;V&amp;#xff0c;E&amp;#xff09;&amp;#xff0c;则令最小生成树的初始状态为只有n个顶点而无边的非连通网&amp;#xff0c;图中每个顶点自成一个连通分量。在E中选择代价最小的边&amp;#xff0c;若该边依附的顶点落在T中不同的连通分量上&amp;#xff0c;则将此边加入到T中&amp;#xff0c;否则舍去此边而选择下一条代价最小的边。依此类推&amp;#xff0c;直至T中所有顶点都在同一连通分量上为止。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,a[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;],v[&lt;span class=\"hljs-number\"&gt;105&lt;/span&gt;],p,q,minn,ans,m;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n     &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n      &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i][j]);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)v[i]&amp;#61;i; &lt;span class=\"hljs-comment\"&gt;//全部点都是一定单独的集合&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;i&amp;#43;&amp;#43;){ &lt;span class=\"hljs-comment\"&gt;//只用循环到n-1&amp;#xff0c;因为只有n-1条边&lt;/span&gt;\n        minn&amp;#61;&lt;span class=\"hljs-number\"&gt;99999999&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//minn要赋最大值&amp;#xff0c;一定不要赋0x7f&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;)\n         &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)\n          &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(v[k]!&amp;#61;v[j] &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; a[k][j]&amp;lt;&amp;#61;minn &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; a[k][j]!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n              minn&amp;#61;a[k][j];\n              p&amp;#61;j; &lt;span class=\"hljs-comment\"&gt;//记录j和k&amp;#xff0c;供后面使用&lt;/span&gt;\n              q&amp;#61;k;\n          }\n        ans&amp;#43;&amp;#61;minn; &lt;span class=\"hljs-comment\"&gt;//把权值加上去&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t&amp;#61;v[p];\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;k&amp;lt;&amp;#61;n;k&amp;#43;&amp;#43;){\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(v[k]&amp;#61;&amp;#61;t)v[k]&amp;#61;v[q]; &lt;span class=\"hljs-comment\"&gt;//把v[k]集合的点全部变成v[q]集合的点&amp;#xff0c;符合克鲁斯卡尔算法的思想&lt;/span&gt;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,ans);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["关于最小生成树的问题，如何修改？(语言-c++)", ["\n", "【最小生成树专题】最短网络 (Standard IO)", "时间限制: 1000 ms  空间限制: 262144 KB  具体限制  ", "\n", "\n", "题目描述", "农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了用最小的消费，他想铺设最短的光纤去连接所有的农场。你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。每两个农场间的距离不会超过100000。", "\n", "输入", "第一行：农场的个数，N（3<=N<=100）。", "后来的行包含了一个N*N的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们限制在80个字符，因此，某些行会紧接着另一些行。当然，对角线将会是0，因为不会有线路从第i个农场到它本身。", "\n", "输出", "只有一个输出，其中包含连接到每个农场的光纤的最小长度。", "\n", "样例输入", "4", "0  4  9  21", "4  0  8  17", "9  8  0  16", "21 17 16  0", "\n", "样例输出", "28", "\n", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "int", " a[", "105", "][", "105", "],s,n,visit[", "105", "],visitt;\nqueue<", "int", "> q;\n", "void", " ", "pr", "()", "\n", "{\n    q.", "push", "(", "1", ");\n    visit[", "1", "]=", "1", ";\n    ", "while", "(", "1", ")\n    {\n        ", "int", " minn=", "100005", ",minni;\n        ", "for", "(", "int", " j=", "1", ";j<=n;j++)\n        {\n            ", "if", "(a[q.", "front", "()][j]<minn&&visit[j]==", "0", ")\n            {\n                minn=a[q.", "front", "()][j];\n                minni=j;\n            }\n        }\n        cout<<endl;\n        cout<<minn<<", "\" \"", ";\n        q.", "pop", "();\n        q.", "push", "(minni);\n        visit[minni]=", "1", ";\n        visitt++;\n        s=s+minn;\n        ", "if", "(visitt==n", "-1", ") ", "break", ";\n    }\n    \n}\n", "int", " ", "main", "()", "\n", "{\n    cin>>n;\n    ", "for", "(", "int", " i=", "1", ";i<=n;i++)\n    {\n        ", "for", "(", "int", " j=", "1", ";j<=n;j++)\n        {\n            cin>>a[i][j];\n        }\n    }\n    ", "pr", "();\n    cout<<s;\n}\n\n\n", "\n", "我哪里错了，求指明！"]], "Tag": "算法设计"}
{"Answer": "楼主可以参考这个，很可能对楼主有用： [url]http://www.cnblogs.com/codeyu/archive/2009/09/03/1559736.html[/url]", "Konwledge_Point": "最小生成树", "Question": ["我有个java连接网络的程序，想要在windows登陆前执行这个程序，请教该如何做", ["我有个java连接网络的程序，想要在windows开机以后，用户登陆前执行这个程序，请教该如何做"]], "Tag": "算法设计"}
{"Answer": "http://www.cnblogs.com/Fatedayt/archive/2011/09/19/2181775.html", "Konwledge_Point": "最小生成树", "Question": ["迷宫城堡             ", ["Problem Description", "\n为了训练小希的方向感，Gardon建立了一座大城堡，里面有N个房间(N<=10000)和M条通道(M<=100000)，每个通道都是单向的，就是说若称某通道连通了A房间和B房间，只说明可以通过这个通道由A房间到达B房间，但并不说明通过它可以由B房间到达A房间。Gardon需要请你写个程序确认一下是否任意两个房间都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从房间i到房间j，也存在一条路径可以从房间j到房间i。", "\n\n", "Input", "\n输入包含多组数据，输入的第一行有两个数：N和M，接下来的M行每行有两个数a和b，表示了一条通道可以从A房间来到B房间。文件最后以两个0结束。", "\n\n", "Output", "\n对于输入的每组数据，如果任意两个房间都是相互连接的，输出\"Yes\"，否则输出\"No\"。", "\n\n", "Sample Input", "\n3 3 1 2 2 3 3 1 3 3 1 2 2 3 3 2 0 0", "\n\n", "Sample Output", "\nYes No"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;br /&gt;using namespace std;&lt;br /&gt;const int inf&amp;#61;0x3f3f3f3f;&lt;br /&gt;int n,m;&lt;br /&gt;int mp[50][50],book[50],dis[50],parent[50];&lt;br /&gt;void prim()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        dis[i]&amp;#61;mp[1][i];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        if(mp[1][i]!&amp;#61;inf)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            parent[i]&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int ans;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    book[1]&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        int minn&amp;#61;inf,u;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        for(int j&amp;#61;1;j&amp;lt;&amp;#61;n;j&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            if(!book[j]&amp;amp;&amp;amp;minn&amp;gt;dis[j])&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                u&amp;#61;j;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                minn&amp;#61;dis[j];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        book[u]&amp;#61;1;&lt;/span&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;    int x&amp;#61;parent[u];\n    int y&amp;#61;u;\n    int z&amp;#61;mp[parent[u]][u];\n    if(x&amp;gt;y) \n        swap(x,y);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d,%d,%d\\n&amp;#34;&lt;/span&gt;,x,y,z);\n    \n    for(int v&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;v&amp;lt;&amp;#61;n;v&amp;#43;&amp;#43;)\n    {\n        if(!book[v]&amp;amp;&amp;amp;dis[v]&amp;gt;mp[u][v])\n        {\n            dis[v]&amp;#61;mp[u][v];\n            parent[v]&amp;#61;u;\n        }    \n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;p&gt;int main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    memset(book,0,sizeof(book));&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    memset(mp,0x3f,sizeof(mp));&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        mp[i][i]&amp;#61;0;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(int i&amp;#61;1;i&amp;lt;&amp;#61;m;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        int a,b,c;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        mp[a][b]&amp;#61;mp[b][a]&amp;#61;min(mp[a][b],c);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    prim();&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["R7-2 最小生成树构造 (25 分)", [" giegie们！！", "\n", "输入样例：", "4 6", "1 2 1", "1 3 4", "1 4 1", "2 3 3", "2 4 2", "3 4 5"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mctFromLeafValues&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt; arr&lt;/span&gt;):\n    res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        min_val &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(arr)\n        idx &amp;#61; arr.index(min_val)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; idx &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; idx &amp;lt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左有右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左没右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#为什么是16&amp;#xff1f;因为最大只有15&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有右没左&lt;/span&gt;\n            left_val, right_val &amp;#61; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            \n        res &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) &lt;span class=\"hljs-comment\"&gt;#把当前最小值删掉&amp;#xff0c;已经用完了&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res\narr &amp;#61; [&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(mctFromLeafValues(arr))\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["用python语言实现“最小代价生成树”问题的分支限界算法", ["求Python的各位帮忙看看，用python语言实现“最小代价生成树”问题的分支限界算法"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;打断点追一下这个t值&amp;#xff0c;有可能t值还是-1。&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["这个缓冲区溢出和无效数据怎么解决啊", ["大一求问，用prim算法求最小生成树，⚠️缓冲区溢出和无效数据，不知道怎么改"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;#include&amp;#34;MST.h&amp;#34;之前的部分保存为MST.h文件&lt;br /&gt;这行前面缺个花括号&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["我从别人那复制过来的但是找不到MST.h文件", ["帮我看看这些代码为什么运行不了，我缺少的MST.h文件应该是什么内容才能让这些正常运行在vs2013里写的", "\n", "\n```c++\n", "#", "include", "<vector>", "\n", "#", "include", "<string>", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "MST", "{\n", "public", ":\n    ", "MST", "(){ pNumber = ", "0", "; map = ", "NULL", "; }  \n    ~", "MST", "(){ ", "delete", " []map; }\n    ", "void", " ", "createPoint", "()", ";        ", "//对应通信网造价模拟系统的A选项创建电网顶点", "\n    ", "void", " ", "addEdge", "()", ";            ", "//对应通信网造价模拟系统的B选项添加电网的边", "\n    ", "void", " ", "createTree", "()", ";           ", "//对应通信网造价模拟系统的C选项构造最小生成树", "\n    ", "void", " ", "displayTree", "()", ";           ", "//对应通信网造价模拟系统的D选项显示最小生成树", "\n    ", "string ", "findPoint", "(", "int", " iPos)", ";", "//寻找pName中iPos位置的节点名称", "\n    ", "bool", " ", "judgePoint", "(", "int", " iPos)", "; ", "//判断iPos位置的点是否已经放入store容器中", "\n    ", "int", " ", "judgeEdge", "(", "int", " temp)", ";   ", "//判断是否存在权值比temp数值还小的边", "\n", "private", ":\n    ", "int", " pNumber;               ", "//通信网节点的个数", "\n    ", "int", " iCount = ", "0", ";            ", "//通信网节点个数计数器", "\n    ", "int", " iStart;                ", "//起始点位置对应pName中的位置", "\n    ", "int", " iWeight;               ", "//存在比temp数值更小的边的权", "\n    ", "int", " **map;                 ", "//用于存储各边之间的权", "\n    string start;              ", "//起始点位置的名称", "\n    vector <string>pName;      ", "//存储所有节点的名称", "\n    vector<pair<", "int", ", ", "int", ">>store;", "//store中的起点存储的每条边的终点和对应的权值", "\n\n", "#", "include", "\"MST.h\"", "\n", "using", " ", "namespace", " std;\n", "bool", " ", "MST::judgePoint", "(", "int", " iPos)", "{\n    ", "for", " (", "int", " iX=", "0", " ; iX < store.", "size", "(); iX++){         \n        ", "if", " (iPos == store[iX].first&&store[iX].second != ", "0", ")\n            ", "return", " ", "false", ";               ", "//store中存在这个点", "\n    }\n    ", "return", " ", "true", ";                        ", "//store中不存在这个点", "\n}\n", "int", " ", "MST::judgeEdge", "(", "int", " temp)", "{\n    ", "int", " iPos;\n    ", "if", " (iCount == ", "1", "){                   ", "//第二个顶点开始的位置单独讨论", "\n        ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){\n            ", "if", " (map[iStart][iX] < temp&&map[iStart][iX]>", "0", " && map[iStart][iX] != store[", "0", "].second){\n                iWeight = map[iStart][iX];\n                ", "return", " iX;\n            }\n        }\n    }\n    ", "if", "(iCount>", "1", "){\n        ", "int", " iPos = iCount", "-1", ";\n        ", "for", " (iPos;iPos>=", "0", ";iPos--)\n            ", "for", " (", "int", " iX = ", "0", "; iX < pNumber;iX++)\n                ", "if", " (map[iPos][iX] < temp&&map[iPos][iX] != store[iPos].second&&map[iPos][iX]>", "0", " && iX != iStart){\n                iWeight = map[iPos][iX];\n                ", "return", " iX;                ", "//之前的顶点对应有权更小的边", "\n            }\n        }\n    ", "return", " ", "-1", ";", "//没有权更小的边", "\n}\n", "void", " ", "MST::createTree", "()", "{\n    cout << ", "\"请输入起始顶点：\"", ";\n    cin >> start;\n    iCount = ", "0", ";        ", "//计数器每次操作前置0                     ", "\n    ", "int", " iPos,temp,iName;  ", "//iPos对应每次搜索的起点 temp对应起点对应的边的权 iName对应搜索后的终点", "\n    store.", "clear", "();       ", "//store每次操作前清空", "\n    store.", "resize", "(pNumber);\n    ", "for", " (iPos = ", "0", "; iPos < pNumber; iPos++){  ", "//首先找到起始点对应pName中的位置", "\n        ", "if", " (start == pName[iPos]){\n            iStart = iPos;\n            ", "break", ";\n        }\n    }\n    ", "while", " (iCount<pNumber", "-1", "){         \n        ", "if", " (iPos!=", "0", ")                    ", "//搜索前分别讨论iPos为0时可能出现的不同状况", "\n            temp=map[iPos][", "0", "];\n        ", "if", " (iPos == ", "0", "){\n            temp = map[iPos][", "1", "];\n            iName = ", "1", ";\n        }\n        ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){   ", "//从起点开始搜寻周围权最小的边", "\n            ", "if", " (temp>=map[iPos][iX] && map[iPos][iX]>", "0", " && iPos != iX&&", "judgePoint", "(iX)){\n                ", "if", " ((iCount != ", "0", " && iPos != iStart||iCount==", "0", "&&iPos==iStart)&&iX!=iStart){\n                    temp = map[iPos][iX];\n                    iName = iX;\n                }\n            }\n        }\n        ", "if", " (", "judgeEdge", "(temp) == ", "-1", "){   ", "//如果store之前的顶点不存在权比temp更小的边", "\n            store[iCount].second = temp;\n            store[iCount].first = iName;\n        }\n\n        ", "if", " (", "judgeEdge", "(temp) != ", "-1", "){    ", "//如果存在权比temp更小的边", "\n            store[iCount].first = ", "judgeEdge", "(temp);\n            store[iCount].second = iWeight;\n        }\n        iPos = store[iCount].first;\n        iCount++;\n    }\n    cout << ", "\"生成Prim最小生成树！\"", "<<endl;\n    cout << endl;\n}\n", "void", " ", "MST::createPoint", "()", "{\n    string name;\n    cout << ", "\"请输入顶点的个数：\"", ";\n    cin >> pNumber;\n    cout << ", "\"请依次输入各顶点的名称：\"", " << endl;\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){\n        cin >> name;\n        pName.", "push_back", "(name);\n    }\n    cout << endl;\n}\n", "void", " ", "MST::addEdge", "()", "{\n    string pA, pB;\n    ", "int", " iA = ", "0", ", iB = ", "0", ";\n    map = ", "new", " ", "int", "*[pNumber];\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++)\n        map[iX] = ", "new", " ", "int", "[pNumber];\n\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber - ", "1", "; iX++){\n        map[iX][iX] = ", "0", ";\n        cout << ", "\"请输入两个顶点及边: \"", ";\n        ", "for", " (", "int", " iY = iX + ", "1", "; iY < pNumber; iY++){ \n            iA = iB = ", "0", ";\n            cin >> pA >> pB;\n            ", "while", " (pA != pName[iA])   ", "//搜索输入两个顶点对应的位置，并将权赋值到对应的map中", "\n                iA++;\n            ", "while", " (pB != pName[iB])\n                iB++;\n            cin >> map[iA][iB];\n            ", "if", " (iY != pNumber - ", "1", ")\n                cout << ", "\"请输入两个顶点及边: \"", ";\n        }\n    }\n    ", "for", " (", "int", " iX = ", "0", "; iX < pNumber; iX++){\n        ", "for", " (", "int", " iY = ", "0", "; iY < iX; iY++){\n            map[iX][iY] = map[iY][iX];\n        }\n    }\n    cout << endl;\n    \n}\n", "void", " ", "MST::displayTree", "()", "{\n    string end;\n    string begin;\n    cout << ", "\"最小生成树的的顶点及边为：\"", " << endl;\n    cout << endl;\n    cout << start << ", "\"-<\"", " << store[", "0", "].second << ", "\">-\"", " << ", "findPoint", "(store[", "0", "].first);\n    ", "for", " (", "int", " iX = ", "1", "; iX < pNumber - ", "1", "; iX++){\n        ", "if", " (store[iX].second == map[store[iX].first][iX]){", "//如果最小生成树没有分支", "\n            begin = ", "findPoint", "(store[iX - ", "1", "].first);\n            end = ", "findPoint", "(store[iX].first);\n            cout << ", "\"        \"", " << begin << ", "\"-<\"", " << store[iX].second << ", "\">-\"", " << end;\n        }\n        ", "else", "{", "//最小生成树存在分支，依据终点和权找到对应的起点", "\n            ", "int", " iStart = store[iX].second;\n            ", "int", " iJ = ", "0", ";\n            ", "int", " iK = ", "0", ";\n            ", "bool", " flag = ", "false", ";\n            ", "for", " (iJ = ", "0", "; iJ < pNumber; iJ++){\n                ", "for", " (iK = ", "0", "; iK < pNumber; iK++){\n                    ", "if", " (map[iJ][iK] == iStart){\n                        flag = ", "true", ";\n                        ", "break", ";\n                    }\n                }\n                ", "if", " (flag == ", "true", ")\n                    ", "break", ";\n            }\n            ", "if", " (iK == store[iX].first){\n                begin = ", "findPoint", "(iJ);\n                end = ", "findPoint", "(iK);\n                cout << ", "\"        \"", " << begin << ", "\"-<\"", " << store[iX].second << ", "\">-\"", " << end;\n            }\n            ", "if", " (iJ == store[iX].first){\n                begin = ", "findPoint", "(iK);\n                end = ", "findPoint", "(iJ);\n                cout << ", "\"        \"", " << begin << ", "\"-<\"", " << store[iX].second << ", "\">-\"", " << end;\n            }\n        }\n    }\n    cout << endl << endl;\n}\n", "string ", "MST::findPoint", "(", "int", " iPos)", "{\n    string point;\n    point = pName[iPos];\n    ", "return", " point;\n}\n\n", "#", "include", "<iostream>", "\n", "#", "include", "<vector>", "\n", "#", "include", "\"MST.h\"", "\n", "using", " ", "namespace", " std;\n", "void", " ", "main", "()", "{\n    MST tree;\n    ", "char", " order;\n    cout << ", "\"**                     通信网造价模拟系统                     **\"", " << endl;\n    cout << ", "\"==============================================================\"", " << endl;\n    cout << ", "\"**                     A---创建通信网顶点                     **\"", " << endl;\n    cout << ", "\"**                     B---添加通信网的边                     **\"", " << endl;\n    cout << ", "\"**                     C---构造最小生成树                   **\"", " << endl;\n    cout << ", "\"**                     D---显示最小生成树                   **\"", " << endl;\n    cout << ", "\"**                     E---退出   程序                      **\"", " << endl;\n    cout << ", "\"==============================================================\"", " << endl<<endl;\n    cout << ", "\"请选择操作：\"", ";\n    cin >> order;\n    ", "while", " (order!=", "'E'", "){\n        ", "switch", " (order)\n        {\n        ", "case", " ", "'A'", ":\n            tree.", "createPoint", "();\n            ", "break", ";\n        ", "case", " ", "'B'", ":\n            tree.", "addEdge", "();\n            ", "break", ";\n        ", "case", " ", "'C'", ":\n            tree.", "createTree", "();\n            ", "break", ";\n        ", "case", " ", "'D'", ":\n            tree.", "displayTree", "();\n        ", "default", ":\n            ", "break", ";\n        }\n        cout << ", "\"请选择操作：\"", ";\n        cin >> order;\n    }\n}\n\n\n\n\n\n\n\n", "\n", "```"]], "Tag": "算法设计"}
{"Answer": "[http://www.cnblogs.com/hxsyl/p/3286956.html](http://www.cnblogs.com/hxsyl/p/3286956.html \"\")", "Konwledge_Point": "最小生成树", "Question": ["如何在克鲁斯卡尔中加入并查集的运用", ["在运用克鲁斯卡尔算法求最小生成树时如何将并查集的相关内容也运用进去？第一次发问，请大家给力点！"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;一个人搞确实有难度&amp;#xff0c;建议和老师同学多交流&amp;#xff0c;参加一些相关的比赛&amp;#xff0c;积累经验&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["想问下做项目是啥意思", ["目前学完了c，数据结构与算法学到了图的最小生成树，力扣也刷了五六十道题了，听说做项目提升快，但现在还没见过项目，也不知道咋找项目，有大佬能指导下吗😂"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/774661583276158.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/992790583276149.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;\n#define &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;\nusing namespace std;\n\n//利用二维数组创建有向图的邻接矩阵\nvoid &lt;span class=\"hljs-symbol\"&gt;CreateMatrix&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;]);\n//利用&lt;span class=\"hljs-symbol\"&gt;Prim&lt;/span&gt;算法求解最小生成树\nvoid &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int i, int visit[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int dist[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int path[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;]);\n\nint main()\n{\n    //创建有向图的带有权值的邻接矩阵\n    int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;];\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        for (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        {\n            mat[i][j] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;INT_MAX&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-symbol\"&gt;CreateMatrix&lt;/span&gt;(mat);\n    int visit[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    int dist[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;];\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        dist[i] &amp;#61; &lt;span class=\"hljs-symbol\"&gt;INT_MAX&lt;/span&gt;;\n    }\n    int path[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n\n    //利用&lt;span class=\"hljs-symbol\"&gt;Prim&lt;/span&gt;算法求解最小生成树\n    //初始源点的dist初始化为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;#xff0c;path初始化为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    dist[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    path[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(mat,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,visit,dist,path);\n\n    //输出最小生成树的边及相应权值&amp;#xff0c;总权值\n    int totalValue &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        totalValue &amp;#43;&amp;#61; dist[i];\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最小生成树的边&amp;#xff1a;&amp;lt;v%d , v%d&amp;gt;&amp;#34;&lt;/span&gt;,(i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),(path[i]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;));\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34; 权值&amp;#xff1a;%d&amp;#34;&lt;/span&gt;,dist[i]);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最小生成树的总权值&amp;#xff1a;%d&amp;#34;&lt;/span&gt;,totalValue);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n//利用二维数组创建有向图的邻接矩阵&amp;#xff0c;带权值\nvoid &lt;span class=\"hljs-symbol\"&gt;CreateMatrix&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;])\n{\n    mat[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n\n    mat[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    mat[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n}\n\n//利用&lt;span class=\"hljs-symbol\"&gt;Prim&lt;/span&gt;算法求解最小生成树\nvoid &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(int mat[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int i, int visit[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int dist[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;], int path[&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;])\n{\n    //初始化\n    visit[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    //dist[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    //path[i]&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    //访问与顶点i相邻接的未被访问的顶点&amp;#xff0c;获取路径长度&amp;#xff0c;如果小于之前路径长度则替换&amp;#xff0c;并记录路径\n    for (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;j&amp;#43;&amp;#43;)\n    {\n        if (visit[j] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; mat[i][j] !&amp;#61; &lt;span class=\"hljs-symbol\"&gt;INT_MAX&lt;/span&gt;)\n        {\n            if (mat[i][j]&amp;lt;dist[j])\n            {\n                dist[j] &amp;#61; mat[i][j];\n                path[j] &amp;#61; i;\n            }\n        }\n    }\n\n    //在未被访问过的顶点中寻找路径最短的顶点\n    int minDist &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    for (int m &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;m&amp;lt;&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;;m&amp;#43;&amp;#43;)\n    {\n        if (visit[m] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            minDist &amp;#61; m;\n            break;\n        }\n    }\n    for (int k &amp;#61; minDist &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; k&amp;lt;&lt;span class=\"hljs-symbol\"&gt;NUM&lt;/span&gt;; k&amp;#43;&amp;#43;)\n    {\n        if (visit[k] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; dist[k]&amp;lt;dist[minDist])\n        {\n            minDist &amp;#61; k;\n        }\n\n    }\n    //如果找到继续寻找到下一个顶点的最短路径&amp;#xff08;递归&amp;#xff09;\n    if (minDist !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-symbol\"&gt;DijkstraSearch&lt;/span&gt;(mat, minDist, visit, dist, path);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["求下面问题的完整答案，图在链接里", ["已知顶点集合{a,b,c,d,e,f}，构成的无向图的带权邻接矩阵如下：", "https://cg.sau.edu.cn/userfiles/image/1483599133822034852.png", "① 画出无向带权图；   ", "② 给出无向带权图的最小生成树；"]], "Tag": "算法设计"}
{"Answer": "你的toString方法里递归调用了,死循环出不来了...\r\n这是AbstractMap的toString方法:\r\n\r\npublic String toString() {\r\n\tIterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();\r\n\tif (! i.hasNext())\r\n\t    return \"{}\";\r\n\r\n\tStringBuilder sb = new StringBuilder();\r\n\tsb.append('{');\r\n\tfor (;;) {\r\n\t    Entry&lt;K,V&gt; e = i.next();\r\n\t    K key = e.getKey();\r\n\t    V value = e.getValue();\r\n\t    sb.append(key   == this ? \"(this Map)\" : key);\r\n\t    sb.append('=');\r\n\t    sb.append(value == this ? \"(this Map)\" : value);\r\n\t    if (! i.hasNext())\r\n\t\treturn sb.append('}').toString();\r\n\t    sb.append(\", \");\r\n\t}\r\n    }\r\n\r\n由于你的Map里Key还是City对象,所以执行Map的toString时这一行 sb.append(key   == this ? \"(this Map)\" : key);会自动调用key的toString方法,这样又进入了City的toString方法,然后就挂了.....", "Konwledge_Point": "最小生成树", "Question": ["StackOverflowError异常，哪位好心人看看啊", ["   打算用面向对象思想，写个求最小生成树问题。写了一半，就出现问题了import java.util.HashMap;", "\n\n", "public class City {\n    private String cityName; \n\n    private HashMap<City, Double> adjCities = new HashMap<City, Double>(); \n\n    public City(String cityName) {\n        this.cityName = cityName;\n\n    }\n\n    public void addAjdCity(City city, double cost) {\n        adjCities.put(city, cost);\n        // System.out.println(\"test1\");\n        city.adjCities.put(this, cost);\n        // System.out.println(\"test2\");\n\n    }\n\n    public void removeAjdCity(City city) {\n\n    }\n\n    public void removeAjdCity(String cityName) {\n\n    }\n\n    public String toString() {\n        return cityName + \":\" + \"\\n\" + adjCities;\n    }\n\n    public static void main(String[] args) {\n        City c1 = new City(\"上海\");\n        City c2 = new City(\"杭州\");\n\n        c1.addAjdCity(c2, 100);\n        // 怎么输出c1 c2时会出问题？StackOverflowError异常。如果把最后两句println注释掉，就不会报错？？\n        System.out.println(c1);\n        System.out.println(c2);\n\n    }\n\n}\n"]], "Tag": "算法设计"}
{"Answer": "就是将下标为k的顶点各边权值小于此前这些顶点未被加入的生成树权值", "Konwledge_Point": "最小生成树", "Question": ["小白求教，请问**部分是什么意思？", ["//Prim算法最小生成树", "\nvoid MiniSpanTree_Prime(Graph g)", "\n{", "\n    int min, i, j, k;", "\n    int adjvex[MAXVEX];         //保存相关顶点下标", "\n    int lowcost[MAXVEX];        //保存相关顶点间边的权值", "\n    lowcost[0] = 0;             //初始化第一个权值为0，即v0加入生成树  ", "\n\n", "adjvex[0] = 0;              //初始化第一个顶点下标为0  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    //循环除下标为0外的全部顶点  \n    lowcost[i] = g.arc[0][i];   //将v0顶点与之有边的权值存入数组  \n    adjvex[i] = 0;              //初始化都为v0下标  \n}  \nfor(i = 1; i < g.numVertexes; i++)  \n{  \n    min = INFINITY;             //初始化最小权值为无穷大  \n    j = 1;  \n    k = 0;  \n    while(j < g.numVertexes) //循环全部顶点  \n    {  \n        //如果权值不为0,且权值小于min  \n        if(lowcost[j] != 0 && lowcost[j] < min)  \n        {  \n            min = lowcost[j];       //则让当前权值成为最小值  \n            k = j;                  //将当前最小值的下标存入k  \n        }  \n        j++;  \n    }  \n    printf(\"(%d,%d)\", adjvex[k], k);//打印当前顶点边中权值最小边  \n    lowcost[k] = 0;                 //将当前顶点的权值设置为0，表示此顶点已经完成任务  \n\n    for(j = 1; j < g.numVertexes; j++)//循环所有顶点  \n    {  \n        if(lowcost[j] != 0 && g.arc[k][j] < lowcost[j])  \n        {  \n          **  //若下标为k的顶点各边权值小于此前这些顶点未被加入的生成树权值 ** \n            lowcost[j] = g.arc[k][j];  \n            adjvex[j] = k;         //将下标为k的顶点存入adjvex  \n        }  \n    }  \n}  \nprintf(\"\\n\");  \n", "\n\n", "}"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mctFromLeafValues&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt; arr&lt;/span&gt;):\n    res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        min_val &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(arr)\n        idx &amp;#61; arr.index(min_val)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; idx &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; idx &amp;lt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左有右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左没右&lt;/span&gt;\n            left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#为什么是16&amp;#xff1f;因为最大只有15&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有右没左&lt;/span&gt;\n            left_val, right_val &amp;#61; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            \n        res &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_val * left_val, min_val * right_val)\n        arr.remove(min_val) &lt;span class=\"hljs-comment\"&gt;#把当前最小值删掉&amp;#xff0c;已经用完了&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res\narr &amp;#61; [&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(mctFromLeafValues(arr))\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["python分支限界算法", ["用python语言实现最小代价生成树问题，利用分支限界算法python"]], "Tag": "算法设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;      &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mctFromLeafValues&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, arr&lt;/span&gt;):\n        &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n        :type arr: List[int]\n        :rtype: int\n        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n        res &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            min_val &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(arr)\n            idx &amp;#61; arr.index(min_val)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; idx &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; idx &amp;lt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左有右&lt;/span&gt;\n                left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(arr) - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有左没右&lt;/span&gt;\n                left_val, right_val &amp;#61; arr[idx - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#为什么是16&amp;#xff1f;因为最大只有15&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; idx &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;#有右没左&lt;/span&gt;\n                left_val, right_val &amp;#61; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, arr[idx &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n                \n            res &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(min_val * left_val, min_val * right_val)\n            arr.remove(min_val) &lt;span class=\"hljs-comment\"&gt;#把当前最小值删掉&amp;#xff0c;已经用完了&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "最小生成树", "Question": ["python初学者，问一个简单的分支限界算法", ["用python语言实现“最小代价生成树”问题的分支限界算法", "求解答……"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;网上很多原题解析&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/LYKXHTP/article/details/88316879\" id=\"textarea_1667819239063_1667819264187_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;哈夫曼树 - 九度教程第30题_Yoc Lu的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;哈夫曼树 - 九度教程第30题题目时间限制&amp;#xff1a;1 秒 内存限制&amp;#xff1a;32 兆 特殊判题&amp;#xff1a;否题目描述&amp;#xff1a;哈夫曼树&amp;#xff0c;第一行输入一个数n&amp;#xff0c;表示叶结点的个数。需要用这些叶结点生成哈夫曼树&amp;#xff0c;根据哈夫曼树的概念&amp;#xff0c;这些结点有权值&amp;#xff0c;即weight&amp;#xff0c;题目需要输出所有结点的值与权值的乘积之和。输入&amp;#xff1a;输入有多组数据。每组第一行输入一个数n&amp;#xff0c;接着输入n个叶节点&amp;#xff08;叶节点权值不超过100&amp;#xff0c;2&amp;amp;amp;lt;&amp;#61;n&amp;amp;amp;lt;&amp;#61;10...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/LYKXHTP/article/details/88316879&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["构造哈夫曼树以及计算带权路径长度", ["7-1 哈夫曼树", "分数 15", "作者 李廷元", "单位 中国民用航空飞行学院", "哈夫曼树，第一行输入一个数n，表示叶结点的个数。", "\n", "需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出哈夫曼树的带权路径长度（WPL）。", "\n", "输入格式:", "第一行输入一个数n，第二行输入n个叶结点（叶结点权值不超过1000，2<=n<=1000）。", "\n", "输出格式:", "在一行中输出WPL值。", "\n", "输入样例:", "5", "1 2 2 5 9", "输出样例:", "37", "\n", "我的问题：", "我们老师上课讲解过如何构造哈夫曼树这是方法：", "结点结构如下。", "\n", "define MAXBIT 10", "define MAXVALUE 1000", "typedef struct HNode /定义结点结构/", "{ int weight;", "int parent , lchild , rchild;", "}HNode, *HTree;", "\n", "HTree HuffmanTree( int w , int n) /给定n个权值构造哈夫曼树/", "{ / w存储n个字符的权值，构造哈夫曼树HT*/", "int m, m1, m2, x1, x2, i, j; HTree ht;", "HNode *p;", "if (n <= 1) return NULL;", "m= 2*n-1;", "ht = (HNode *)malloc (m*sizeof(HNode) ); /*哈夫曼树的构造*/", "if(ht==NULL) return ht;", "for(p = ht, i =0; i < n; ++ i, ++ p, ++w) /*初始化叶子结点信息*/", "{ p->weight = *w; p->lchild = -1;", "p->rchild = -1; p->parent = -1;", "}", "for( ; i < m; ++ i, ++ p) /*初始化分支结点信息*/", "{ p->weight = 0; p->lchild = -1;", "p->rchild = -1; p->parent = -1;", "}", "for( i = n; i < m; ++ i) /*构造哈夫曼树 */", "{ m1 = m2 = MAXVALUE;", "x1 = x2 = 0; /寻找parent为-1且权值最小的两棵子树/", "for(j = 0; j < i; ++ j)", "{ if( ht[j].parent == -1 && ht[j].weight < m1)", "{ m2 = m1; x2 = x1; m1 = ht[j].weight; x1 = j; }", "else if( ht[j].parent == -1 && ht[j].weight < m2)", "{ m2 = ht[j].weight; x2 = j; }", "}", "/合并成一棵新的子树/", "ht[x1].parent = i; ht[x2].parent = i;", "ht[i].lchild = x1; ht[i].rchild = x2;", "ht[i].weight = m1 + m2;", "}", "return ht;", "}", "说实话看的有的云里雾里的能不能用中文描述下思路", "而且题中要让求最短路径长度，我这上面只有构造哈夫曼树这一块，求解最短路径长度这块有点不知道如何下手，还有主函数也不太知道咋写，希望能同时提供解题思路以及完整运行结果，感谢感谢，因为基础太差了，我就算知道思路自己也打不出来，答案错误看半天也找不出错误，辛苦"]], "Tag": "算法设计"}
{"Answer": "Problem1：https://paste.ubuntu.com/p/p5vmGWqFYh/\r\nProblem2：https://paste.ubuntu.com/p/kSSnfGDpMy/", "Konwledge_Point": "最小生成树", "Question": ["麻烦用c语言解决一下。。", ["A、编写一个读取1000个随机数整数的c程序，创建一个二叉树并打印树的深度。", "\n使用shuf-i1-1000命令生成随机数。（自己生成也行）", "\n B、编写一个c程序，重复上一个问题的实验1000次（每次一千个随机数都不同）。计算所创建的1000个二叉树的平均深度，最小深度和最大深度。不要忘记在实验之间释放树。使用shuf-i1-1000000生成一个1000x1000=1000000个整数的列表。"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;是你结构体数组S的最后一个元素下标越界了&lt;/p&gt;\n&lt;p&gt;N &amp;#61; 8; 你这样 s S[N-1]; 是声明结构体数组S的长度只有7个元素&amp;#xff0c;下标是从S[0]到S[6]&amp;#xff0c;没有S[7]&amp;#xff0c;最后一个S[7]的内存空间是不属于S数组的。虽然可以访问S[7]但不安全。因为这个内存空间可能会分配给其它变量&amp;#xff0c;当这个变量的值改变时S[7]也就受到影响。&lt;/p&gt;\n&lt;p&gt;改成 s S[N]; 就可以了&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢!&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["创建动态数组后，另一个数组的最后一个元素值被改变", ["在用c语言编写哈夫曼树时，为了存放权值，建立了一个有8个元素的结构体数组S，而后依次将8个结构体的权值成员赋值为1，2，3，4，5，6，7，8", "\n", "s  S[", "7", "];\n    ", "printf", "(", "\"请输入8个字符的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=", "7", ";i++){\n        scanf(", "\"%u\"", ",&S[i].weight);\n        ", "printf", "(", "\"%d\\n\"", ",S[i].weight);\n    }\n\n", "\n", "\n", "然后创建一个动态数组HT，此时发现S最后一个结构体元素的权值成员变为了随机值，这是为什么？", "\n", "    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "printf", "(", "\"%u\\n\"", ",S[", "7", "].weight);\n    ", "for", "(", "unsigned", " ", "int", " g=", "0", ";g<=", "7", ";g++){\n         ", "printf", "(", "\"%u\\t\"", ",S[g].weight);\n    }\n\n", "\n", "\n", "完整代码如下", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "define", " N 8", "\n", "//存储哈夫曼树的静态三叉链表定义", "\n", "typedef", " ", "struct", "{\n", "unsigned", " ", "int", " weight;\n", "unsigned", " ", "int", " parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n", "typedef", " ", "char", " ** HuffmanCode;\n", "//字符、权值、对应编码组成的结构体类型", "\n", "struct", " ", "s", " \n{\n", "char", " c;\n", "unsigned", " ", "int", " weight;\n", "char", " code[N];\n};\n", "//选择两个权值最小的结点", "\n", "void", " ", "Select", "(HuffmanTree &HT,", "unsigned", " ", "int", " i,", "int", " *s1,", "int", " *s2)", "{\n    ", "unsigned", " ", "int", " min1,min2,j;\n    min1=min2=", "9999", ";\n    ", "for", "(j=", "1", ";j<=i;j++){\n        ", "if", "(HT[j].parent==", "0", "){\n            ", "if", "(HT[j].weight<min2){\n                ", "if", "(HT[j].weight<min1){\n                    min2=min1;\n                    min1=HT[j].weight ;\n                    *s1=j;\n                }\n                ", "else", " {\n                    min2=HT[j].weight ;\n                    *s2=j;\n                }\n            }\n        }\n    }\n}\n\n", "//构造哈夫曼树和哈夫曼编码", "\n", "void", " ", "Huffman", "(HuffmanTree &HT,HuffmanCode &HC,", "unsigned", " ", "int", " n,s S[N])", "{\n    ", "if", " (n<=", "1", ")", "return", ";\n    ", "unsigned", " ", "int", " i=", "0", ",m=", "2", "*n", "-1", ",c=", "0", ",f=", "0", ";\n    ", "int", " s1=", "0", ",s2=", "0", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "printf", "(", "\"%u\\n\"", ",S[", "7", "].weight);\n    ", "for", "(", "unsigned", " ", "int", " g=", "0", ";g<=", "7", ";g++){\n         ", "printf", "(", "\"%u\\t\"", ",S[g].weight);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n    ", "for", "(p=HT+", "1", ",i=", "1", ";i<=n;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=S[i", "-1", "].weight;\n    }\n    ", "for", "(;i<=m;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=", "0", ";\n    }\n    ", "for", "(i=n+", "1", ";i<=m;++i){\n        ", "Select", "(HT,n,&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", "*));\n    ", "char", " *cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "printf", "(", "\"test1\"", ");\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent){\n            ", "if", "(HT[f].lchild==c)cd[--start]=", "'0'", ";\n            ", "else", " cd[--start]=", "'1'", ";}\n        HC[i]=(", "char", "*)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n        ", "strcpy", "(HC[i],&cd[start]);\n        ", "strcpy", "(S[i].code,&cd[start]);\n    }\n}\n", "//输出哈夫曼树数据", "\n", "void", " ", "PrintHuffman", "(HuffmanTree HT,", "int", " n,s S[N])", "{\n    ", "printf", "(", "\"哈夫曼树如下所示:\\n\"", ");\n    ", "for", "(", "int", " k=", "1", ";k<=", "2", "*n", "-1", ";k++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[k].rchild);\n    }\n    ", "printf", "(", "\"8个字符的字符、权值及哈夫曼编码如下:\\n\"", ");\n    ", "for", "(", "int", " l=", "0", ";l<=n;l++){\n         ", "printf", "(", "\"%s\\t%u\\t%s\\t\\n\"", ",S[l].c,S[l]. weight,S[l].code);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n ", "//哈夫曼树的建立和编码的生成", "\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N", "-1", "];\n    ", "printf", "(", "\"请输入8个字符，及它们的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=N;i++){\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%s\"", ",&S[i", "-1", "].c);\n        ", "printf", "(", "\"请输入该字符的权值:\"", ");\n        ", "scanf", "(", "\"%u\"", ",&S[i", "-1", "].weight);\n        ", "printf", "(", "\"%d\\n\"", ",S[i", "-1", "].weight);\n    }\n    ", "Huffman", "(HT,HC,", "8", ",S);\n   \n ", "//打印输出哈夫曼树数据", "\n  ", "//  PrintHuffman(HT,8,S);", "\n ", "//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串", "\n    ", "printf", "(", "\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"", ");\n    \n    ", "printf", "(", "\"\\n该字符串对应的哈夫曼编码为:\"", ");\n\n\n", "//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串", "\n    ", "printf", "(", "\"请输入一个由0或1构成的哈夫曼编码:\"", ");\n    ", "printf", "(", "\"\\n该哈夫曼编码对应的字符串为\"", ");\n    ", "system", "(", "\"PAUSE\"", ");\n ", "return", " ", "0", ";\n}\n\n"]], "Tag": "算法设计"}
{"Answer": "&lt;p&gt;scanf(&amp;#34;%s&amp;#34;,&amp;amp;S[i-1].c);&lt;br /&gt;改为&lt;br /&gt;scanf(&amp;#34;%c&amp;#34;,&amp;amp;S[i-1].c);&lt;/p&gt;", "Konwledge_Point": "最小生成树", "Question": ["无法打印结构体数组里的数据", ["在练习用c语言实现哈夫曼树时，建立了一个结构体数组原来存放字符及其相应的权值和编码", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "define", " N 8", "\n", "//存储哈夫曼树的静态三叉链表定义", "\n", "typedef", " ", "struct", "{\n", "unsigned", " ", "int", " weight;\n", "unsigned", " ", "int", " parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n", "typedef", " ", "char", " ** HuffmanCode;\n", "//字符、权值、对应编码组成的结构体类型", "\n", "struct", " ", "s", " \n{\n", "char", " c;\n", "unsigned", " ", "int", " weight;\n", "char", " code[N];\n};\n", "//选择两个权值最小的结点", "\n", "void", " ", "Select", "(HuffmanTree &HT,", "unsigned", " ", "int", " i,", "unsigned", " ", "int", " *s1,", "unsigned", " ", "int", " *s2)", "{\n    ", "unsigned", " ", "int", " min1,min2,j;\n    min1=min2=", "9999", ";\n    ", "for", "(j=", "1", ";j<=i;j++){\n        ", "if", "(HT[j].weight<min2&&HT[j].parent ==", "0", "){\n            min2=min1;\n            *s2=j;\n            ", "if", "(HT[j].weight<min1&&HT[j].parent==", "0", "){\n                min1=HT[j].weight;\n                *s1=j;\n\n            }\n        }\n    }\n}\n\n", "//构造哈夫曼树和哈夫曼编码", "\n", "void", " ", "Huffman", "(HuffmanTree &HT,HuffmanCode &HC,", "unsigned", " ", "int", " n,s S[N])", "{\n    ", "if", " (n<=", "1", ")", "return", ";\n    ", "unsigned", " ", "int", " i=", "0", ",m=", "2", "*n", "-1", ",c=", "0", ",f=", "0", ",s1=", "0", ",s2=", "0", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "for", "(p=HT+", "1", ",i=", "1", ";i<=n;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=S[i", "-1", "].weight;\n    }\n", "/*    for(unsigned int v=1;v<=2*n-1;v++){\n        printf(\"%d\\t\",HT[v].weight);\n        printf(\"%d\\t\",HT[v].parent);\n        printf(\"%d\\t\",HT[v].lchild);\n        printf(\"%d\\t\\n\",HT[v].rchild);\n    }\n    printf(\"****************************************************\\n\");*/", "\n    ", "for", "(;i<=m;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=", "0", ";\n    }\n    ", "/*for(unsigned int o=1;o<=2*n-1;o++){\n        printf(\"%d\\t\",HT[o].weight);\n        printf(\"%d\\t\",HT[o].parent);\n        printf(\"%d\\t\",HT[o].lchild);\n        printf(\"%d\\t\\n\",HT[o].rchild);\n    }\n    printf(\"*************************************************************************\\n\");*/", "\n        ", "for", "(i=n+", "1", ";i<=m;++i){\n        ", "Select", "(HT,i", "-1", ",&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n", "/*    for(unsigned int k=1;k<=2*n-1;k++){\n        printf(\"%d\\t\",HT[k].weight);\n        printf(\"%d\\t\",HT[k].parent);\n        printf(\"%d\\t\",HT[k].lchild);\n        printf(\"%d\\t\\n\",HT[k].rchild);\n    }*/", "\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", "*));\n    ", "char", " *cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent){\n            ", "if", "(HT[f].lchild==c)cd[--start]=", "'0'", ";\n            ", "else", " cd[--start]=", "'1'", ";}\n        HC[i]=(", "char", "*)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n", "//        strcpy(HC[i],&cd[start]);", "\n        ", "strcpy", "(S[i].code,&cd[start]);\n    }\n    ", "free", "(cd);\n}\n", "//输出哈夫曼树数据", "\n", "void", " ", "PrintHuffman", "(HuffmanTree HT,", "int", " n,s S[N])", "{\n    ", "printf", "(", "\"哈夫曼树如下所示:\\n\"", ");\n    ", "for", "(", "int", " k=", "1", ";k<=", "2", "*n", "-1", ";k++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[k].rchild);\n    }\n    ", "printf", "(", "\"8个字符的字符、权值及哈夫曼编码如下:\\n\"", ");\n    ", "for", "(", "int", " l=", "0", ";l<=n;l++){\n    ", "printf", "(", "\"%s\\t%u\\t%s\\t\\n\"", ",S[l].c,S[l].weight,S[l].code);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n ", "//哈夫曼树的建立和编码的生成", "\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N];\n    ", "printf", "(", "\"请输入8个字符，及它们的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=N;i++){\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%s\"", ",&S[i", "-1", "].c);\n        ", "printf", "(", "\"请输入该字符的权值:\"", ");\n        ", "scanf", "(", "\"%u\"", ",&S[i", "-1", "].weight);\n    ", "//    printf(\"%d\\n\",S[i-1].weight);", "\n    }\n    ", "Huffman", "(HT,HC,", "8", ",S);\n   \n ", "//打印输出哈夫曼树数据", "\n    ", "PrintHuffman", "(HT,", "8", ",S);\n ", "//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串", "\n    ", "printf", "(", "\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"", ");\n    \n    ", "printf", "(", "\"\\n该字符串对应的哈夫曼编码为:\"", ");\n\n\n", "//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串", "\n    ", "printf", "(", "\"请输入一个由0或1构成的哈夫曼编码:\"", ");\n    ", "printf", "(", "\"\\n该哈夫曼编码对应的字符串为\"", ");\n    ", "system", "(", "\"PAUSE\"", ");\n ", "return", " ", "0", ";\n}\n", "\n", "但是打印输出的时候没有打印结构体数组里的数据，为什么？", "\n", "\n", "\n"]], "Tag": "算法设计"}
