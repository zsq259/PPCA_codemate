{"Answer": "```\r\n public struct SqJpegScliceSize\r\n {\r\n\t public uint[] scliceSize;\r\n\t public IntPtr[] jpegDst;\r\n}\r\n[DllImport(\"xxxxx.dll\",ExactSpelling =false,EntryPoint = \"SqGetSliceData\",CharSet = CharSet.Auto, CallingConvention = CallingConvention.Cdecl)] public static void SqGetSliceData(out SqJpegScliceSize jss);\r\n\r\n//初始化结构体\r\nSqJpegScliceSize jss=new SqJpegScliceSize();\r\njss.scliceSize=new uint[64];\r\njss.jpegDst=new IntPtr[64];\r\n\r\n//调用函数\r\nSqGetSliceData（out jss）;\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C++中的带有指针数组的结构体在C#上怎么封装，并作为形参传给C++dll的函数", ["#pragma pack(1)", "\nstruct SqJpegScliceSize", "\n{", "\n    unsigned int scliceSize[64];", "\n    unsigned char *jpegDst[64];", "\n};", "\nextern \"C\" _declspec(dllexport) void SqGetSliceData(SqJpegScliceSize *jss)", "\n这是C++函数和结构体", "\n在C#上怎么写?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体中有指针的话不能直接强转&amp;#xff0c;需要自己写个解析函数&amp;#xff0c;按照报文格式&amp;#xff0c;逐个字段解析出来放到结构体中。&lt;/p&gt;\n&lt;h2 id=\"h2_题外话&amp;#xff1a;_1642676540433\"&gt;题外话&amp;#xff1a;&lt;/h2&gt;\n&lt;p&gt;如果结构体中没有指针&amp;#xff0c;如果在发送端发送的时候&amp;#xff0c;直接用结构体取地址的方式发送&amp;#xff0c;那么在接收端就可以直接转&amp;#xff0c;否则就不能直接强转。&lt;br /&gt;假设有结构体&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;struct StData\n{\nint a&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\nint b&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\nstruct StData st&lt;span class=\"hljs-comment\"&gt;; &lt;/span&gt;\nst.a &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\nst.b &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果再发送端发送的时候&amp;#xff0c;使用的方式是&lt;br /&gt;writeDatagram(&amp;amp;st,QHostAddress::LocalHost,6000);&lt;br /&gt;这种形式&amp;#xff0c;那么在接收端&amp;#xff0c;收到数据后&amp;#xff0c;可以直接把接收到的数据强转为结构体。&amp;#xff08;只有这种情况下才能直接强转&amp;#xff09;&lt;br /&gt;否则&amp;#xff0c;就不能直接强转。&lt;/p&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的“&lt;strong&gt;采纳该答案&lt;/strong&gt;”帮忙采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/256641676246186.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["QT中 QByteArray数据转自定义结构体（含成员指针）能强转吗", ["QT中 UDP接收数据用的QByteArray，然后需要将QByteArray数据转换成自定义结构体数据（含成员指针），能进行强制转换吗？"]], "Tag": "程序设计"}
{"Answer": "你可以将该QList中的数据转为model后再注册为qml的属性，这样qml端就能获取数据了。\r\n参考这个：https://www.jianshu.com/p/65d4d0b4b22a", "Konwledge_Point": "数据封装——结构体", "Question": ["一个存有结构体的QList对象，怎么才能跟qml进行数据交互", ["结构体如下：", "\n\n", "typedef struct  {\n    int sequenceNumber;\n    QString currentAngle;\n}CurrentAngleStruct;\n", "\n\n", "使用了 Q_PROPERTY :", "\n\n", "Q_PROPERTY(QList<CurrentAngleStruct> CurrentAngleList READ CurrentAngleList NOTIFY  CurrentAngleListChanged)\nQList<CurrentAngleStruct> CurrentAngleList(){ return m_CurrentAngleList}\n\n", "\n\n", "定义了 m_CurrentAngleList", "\n\n", "private:\n    QList<CurrentAngleStruct> m_CurrentAngleList\n", "\n\n", "我想要在qml中使用的时候，提示：不能处理未定义的数据类型 'QList' for property ' MissionController::CurrentAngleList'"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;TCP发送的时候有黏包现象&amp;#xff0c;在接收端每次读取的数据长度&amp;#xff0c;并不一定是你每次发送的数据长度&amp;#xff0c;而且&amp;#xff0c;看你结构体中有QVector&amp;#xff0c;QVector的长度是不固定的&amp;#xff0c;在转QByteArray的时候&amp;#xff0c;转换的字节大小可能有问题。&lt;br /&gt;正确的方式&amp;#xff1a;定义一个报文头&amp;#xff0c;报文头的格式、长度固定&amp;#xff0c;在报文头中写明每次发送的报文大小&amp;#xff0c;这样在接收端接受数据时&amp;#xff0c;先接收报文头长度的字节数&amp;#xff0c;然后得到本次报文的长度&amp;#xff0c;然后再去读取这个长度的字符串&amp;#xff0c;然后再去解析成结构体。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Qt Tcpscoket QByteArray 发送自定义结构体", ["问题遇到的现象和发生背景", "\n", " Qt Tcpscoket QByteArray 发送自定义结构体：  发送端将结构体转QByteArray 再转结构体结构正确，但在接收端将Qbytearray转结构体程序崩溃", "\n", "问题相关代码，请勿粘贴截图", "\n", "struct Info", "{", "    int numMax;", "    int id;", "    QVector", " v_name;", "};", "struct Data{", "    QVector", " v_info;", "};", "//发送端", "    Data data;", "    int num = 5;", "    for(int i = 2; i < num; i++)", "    {", "        Info info;", "        info.id = i;", "        info.numMax = i;", "        for(int j = 0; j < i; j++)", "        {", "            info.v_name.push_back(\"player\"+QString::number(j));", "        }", "        data.v_info.push_back(info);", "    }", "\n", "QByteArray", " arr;\n", "arr", ".append(reinterpret_cast<char *>(&", "data", "), sizeof(", "Data", "));", "\n", "socket", "->write(arr);\n", "\n", "//接收端", "    QByteArray arr = socket->readAll();", "    Data *getMsg = new Data;", "    getMsg = reinterpret_cast<Data *>(arr.data());", "//    getMsg2 = (Data *)arr.data();", "\n", "for", "(", "auto", " &", "i", ":", "getMsg", "->", "v_info", ")", "\n{\n    ", "qDebug", "() << ", "i.id", " <<", "\" \"", " << ", "i.numMax", ";\n    ", "for", "(", "int", " ", "j", " = ", "0", "; ", "j", "<", "i.v_name.size", "(); ", "j", "++)", "\n    {\n        ", "qDebug", "()<< ", "i.v_name.at", "(", "j", ");\n    }\n}", "\n", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "2   2", "\"player0\"", "\"player1\"", "3   3", "\"player0\"", "\"player1\"", "\"player2\"", "4   4", "\"player0\"", "\"player1\"", "\"player2\"", "\"player3\""]], "Tag": "程序设计"}
{"Answer": "结构体有有字节对齐，因此，sizeof（PingHeader）=24，大于结构体各成员宽度之和（17），字节是不对应的。int size 从第一个字节开始到第四个字节，第五个字节到第八个字节是空的，double time事实上是从第9个字节开始的，而不是从第5个字节开始。结构体的字节对齐，默认是以最大的成员字节数为基准，比如，你这里的字节对齐就是8字节。当然，你可以自己设定结构体字节对齐值，如果设置字节对齐为1字节的话，sizeof(PingHeader）就等于17了。修改方法是：在程序开头加上预处理命令#pragma pack(1)。想了解更多结构占用空间大小，可以参考http://blog.csdn.net/qq_28249373/article/details/76784475", "Konwledge_Point": "数据封装——结构体", "Question": ["将16进制数据写入结构体时，遇到double型出错", ["我定义了一个结构体 ", "\nstruct RAW", "\n{", "\n   int  size；", "\n   double  time；", "\n   int  size2；", "\n  char name；", "\n}PingHeader；", "\n想用结构体对齐，直接读取到PingHeader中。", "\ninfile.read((char*)&PingHeader,sizeof(PingHeader));", "\n但是转换成double是就会出错，当把double注释掉是就可以按照类型大小一一次赋值了。是在搞不懂了，希望大哥指点指点"]], "Tag": "程序设计"}
{"Answer": "struct Tool\r\n{\r\nint 编号;\r\nchar 名称[100];\r\n...\r\n};\r\nstruct 记录\r\n{\r\nTool value;\r\nTool * next;\r\n};\r\n前者代表某一项，后者是链表，把它们串起来。", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言编程题目——创建结构体和链表", ["希望得到讲解", "\n\n", "1）定义一个结构体(struct Tool)表示工具，包括：工具编号、名称、价格、重量、存放位置等信息；", "\n\n", "2）要求定义一个线性单链表(struct ToolList)存储工具档案记录。", "\n\n", "两者创建有什么区别吗？希望得到创建源码，谢谢"]], "Tag": "程序设计"}
{"Answer": "main.cpp\r\n\r\n\r\n```\r\n #include \"Queue.h\"\r\nvoid testQueue1();\r\nvoid testQueue2();\r\nvoid testQueue3();\r\nint main()\r\n{\r\n\tprintf(\"\\n\");\r\n\ttestQueue1();\r\n\ttestQueue2();\r\n\ttestQueue3();\r\n\treturn 0;\r\n}\r\n\r\nvoid testQueue1()\r\n{\r\n\tQueue *q = NULL;\r\n\tInitQueue(&amp;q);\t//要在函数里改变q，就要传q的地址过去，也就是2级指针\r\n\tprintf(\"front = %d, rear = %d\\n\",q-&gt;qfront,q-&gt;qrear);\r\n\tprintf(\"\\n\");\r\n\r\n}\r\n\r\nvoid testQueue2()\r\n{\r\n\tQueue *q = InitQueue_H();\r\n\t//输出q的front和rear的值发现他们相等，说明初始化成功，没有问题。\r\n\tprintf(\"front = %d, rear = %d\\n\",q-&gt;qfront,q-&gt;qrear);\r\n}\r\n\r\nvoid testQueue3()\r\n{\r\n\tQueue *q;\r\n\tq = (Queue*)malloc(sizeof(Queue));\r\n\tq-&gt;qfront = (QNode*)malloc(sizeof(QNode));\t\r\n}\r\n```\r\n\r\n\r\nQueue.h\r\n\r\n\r\n```\r\n typedef int DATA;\r\ntypedef struct _qnode;\r\ntypedef struct _qnode\r\n{\r\n\tDATA data;\r\n\tstruct _qnode *next;\r\n}QNode;\r\n\r\ntypedef struct _queue\r\n{\r\n\tQNode *qfront;\r\n\tQNode *qrear;\r\n}Queue,*LinkedQueue;\r\n\r\nint InitQueue(Queue **q);\t//用2级指针传递参数\r\nQueue  *InitQueue_H();\r\nint IsQEmpty(Queue *q);\r\n```\r\n\r\n\r\nQueue.cpp\r\n\r\n\r\n```\r\nint InitQueue(Queue **q)\t//2级指针传参\r\n{\r\n\t*q = (Queue*)malloc(sizeof(Queue));\r\n\r\n\tif(*q == NULL)\r\n\t\treturn 0;\r\n\t(*q)-&gt;qfront = (*q)-&gt;qrear = (QNode*)malloc(sizeof(QNode));\r\n\tif((*q)-&gt;qfront == NULL)\r\n\t\treturn 0;\r\n\t(*q)-&gt;qfront-&gt;next = NULL;\r\n\t\treturn 1;\r\n}\r\nQueue *InitQueue_H()\r\n{\r\n\tQueue *q=(Queue*)malloc(sizeof(Queue));\r\n\tif(q==NULL)\r\n\t\treturn NULL;\r\n\tq-&gt;qfront = q-&gt;qrear = (QNode*)malloc(sizeof(QNode));\r\n\tif(q-&gt;qfront==NULL)\r\n\t\treturn NULL;\r\n\tq-&gt;qfront-&gt;next=NULL;\r\n\t\treturn q;\r\n}\r\nint IsQEmpty(Queue *q)\r\n{\r\n\tif(q==NULL || q-&gt;qfront==NULL || q-&gt;qrear==NULL) \r\n\t\treturn 0;  //没写返回值\r\n\treturn q-&gt;qfront==q-&gt;qrear;\r\n}\r\n```\r\n\r\n\r\n把InitQueue()改了一下，还是认为testQueue2()没问题，具体改动我注释上了。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针初始化问题", ["定义一个队列结构体，想用init方法初始化一个该结构体的指针，testQueue1和testQueue2两种方法都有问题。Queue内部的front和rear指针无法初始化。", "\n但如果是在主程序或者testQueue函数中用malloc初始化，却是可以的。", "\nmain程序如下：", "\n#include \"Queue.h\"", "\nvoid testQueue1();", "\nvoid testQueue2();", "\nvoid testQueue3();", "\nint main()", "\n{", "\nprintf(\"\\n\");", "\ntestQueue1();", "\ntestQueue2();", "\ntestQueue3();", "\nreturn 0;", "\n}", "\nvoid testQueue1()", "\n{", "\nQueue ", "q;", "\nInitQueue(q);", "\nprintf(\"\\n\");", "\n}", "\nvoid testQueue2()", "\n{", "\nQueue *q=InitQueue_H();", "\n}", "\nvoid testQueue3()", "\n{", "\nQueue *q;", "\nq=malloc(sizeof(Queue));", "\nq->qfront=malloc(sizeof(QNode));", "\n}", "\n头文件：", "\n#include ", "\n#include ", "\n//定义数据结构", "\ntypedef int DATA;", "\ntypedef struct _qnode;", "\ntypedef struct _qnode", "\n{", "\nDATA data;", "\nstruct _qnode *next;", "\n}QNode;", "\n//本定义中，qfront和qrear作为头尾指针，并不存储数据", "\ntypedef struct _queue", "\n{", "\nQNode *qfront;", "\nQNode *qrear;", "\n}Queue,*LinkedQueue;", "\n//初始化一个空队列,返回值1表示初始化成功，0表示初始化失败", "\nint InitQueue(Queue *q);", "\n//初始化，返货Queue指针", "\nQueue  *InitQueue_H();", "\n//判断是否为空", "\nint IsQEmpty(Queue *q);", "\n程序实现：", "\n#include \"Queue.h\"", "\nint InitQueue(Queue *q)", "\n{", "\nq=(Queue", ")malloc(sizeof(Queue));", "\nif(q==NULL)return 0;", "\nq->qfront=q->qrear=(QNode*)malloc(sizeof(QNode));", "\nif(q->qfront==NULL)", "\nreturn 0;", "\nq->qfront->next=NULL;", "\nreturn 1;", "\n}", "\nQueue ", "InitQueue_H()", "\n{", "\nQueue *q=(Queue", ")malloc(sizeof(Queue));", "\nif(q==NULL)return NULL;", "\nq->qfront=q->qrear=(QNode*)malloc(sizeof(QNode));", "\nif(q->qfront==NULL)", "\nreturn NULL;", "\nq->qfront->next=NULL;", "\nreturn q;", "\n}", "\nint IsQEmpty(Queue *q)", "\n{", "\nif(q==NULL||q->qfront==NULL||q->qrear==NULL) return;", "\nreturn q->qfront==q->qrear;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;应该内存出错了&lt;/p&gt;\n\n&lt;p&gt;结构体指针是不是new出来的&amp;#xff1f;有没有在别的地方释放&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["QT 传递结构体数据出错", ["# 问题描述", "\n\n", "我在QT应用中需要开启一个UDP服务器线程接收数据， 把收到的数据解析为对应的结构体，刚解析完结构体时，数据是正确的，但是在emit这个结构体之前，数据就变得奇奇怪怪的。", "\n\n", "# 代码", "\n\n", "下图是UDP服务器循环接收数据的线程：", "\n\n", "我把接收到的数据放到parser里解析。", "\n\n", "\n\n", "解析的函数：", "\n\n", "解析好的数据放在currUdpData的结构体指针里，下面的输出 *currUdpData是没问题的。", "\n\n", "\n\n", "但是回到线程里：", "\n\n", "\n\n", "箭头指的，打印出来的数据就是错误的， 这里是输出结果：", "\n\n", "\n\n", "我不能理解！", "\n\n", "这是为什么！"]], "Tag": "程序设计"}
{"Answer": "这里的问题是string，string类型浅拷贝的结果是两个指针指向同一块区域，那么析构的时候就会遇到double free了，你如果想整体将结构体写入文件，那么你需要确保没有复杂的结构对象，或者你自己实现序列化才可以", "Konwledge_Point": "数据封装——结构体", "Question": ["C++中使用二进制文件保存和读取结构体的问题", ["为了了解书中的代码，自己编写了下面这段简单的测试代码。", "\n    #include", "\n    #include", "\n    #include", "\n\n", "struct Test\n{\n    int key;\n    std::string data;\n};\n\nint main()\n{\n    Test test;\n    test.key = 1;\n    test.data = \"Anthony\";\n    std::ofstream fout(\"D:\\\\Data.dat\", std::ios_base::out | std::ios_base::binary);\n    fout.write((char*)&test, sizeof Test);\n    fout.close();\n    std::ifstream fin(\"D:\\\\Data.dat\", std::ios_base::in | std::ios_base::app | std::ios_base::binary);\n    Test test_1;\n    fin.seekg(0);\n    fin.read((char*)&test_1, sizeof Test);\n    std::cout << test_1.key << std::endl;\n    std::cout << test_1.key << std::endl;\n    std::cout << test_1.data << std::endl;\n  std::cout << test_1.data << std::endl;\n\n    system(\"pause\");\n    return 0;\n}\n", "\n\n", "这段代码编译没有任何问题，但是出现了运行错误(CE)。而且经调试发现错误实在程序执行return 0;之后才发生的。程序运行截图如下。", "\n运行代码后如下：", "\n再按任意键后如下：", "\n\n", "调试后发现的异常为：", "0x00088538 处(位于 FileStruct.exe 中)引发的异常: 0xC0000005: 写入位置 0xDDDDDDDD 时发生访问冲突。****"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这个只是 modify_infor函数缺少返回值&amp;#xff0c;导致编译不过&amp;#xff0c;你重新全部编译就可以得出这个问题。改下就好了&amp;#xff0c;应该是之前编译的时候有数据残留导致你编译能够通过。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["【C语言】结构体数据存储问题", ["做了一个学生成绩的结构体数组，运行的时候发现成绩始终是0.0，好像输入的score数据没有传进去，其他的都正常。源码贴在下面，请大佬纠错！", "\n\n", "\n", "#include<stdio.h> \n#include<stdlib.h>\n#include<string.h>\n//定义结构体数组\ntypedef struct {\n\tchar num[20];//学号\n\tchar name[20];//学生姓名\n\tint score;//分数\n}STUDENT;\nSTUDENT stu[20]; \n//home page\nvoid home_page()\n{\n\tprintf(\"\\n\\t\\t******************************** \\n\");\n\tprintf(\"\\t\\t     学生成绩信息管理系统       \\n\\n\");\n\tprintf(\"\\t\\t        1、录入信息            \\n\\n\");\n\tprintf(\"\\t\\t        2、浏览信息            \\n\\n\");\n\tprintf(\"\\t\\t        3、查询信息            \\n\\n\");\n\tprintf(\"\\t\\t        4、修改信息            \\n\\n\");\n\tprintf(\"\\t\\t        5、成绩排序            \\n\\n\");\n\tprintf(\"\\t\\t        6、删除信息            \\n\\n\");\n\tprintf(\"\\t\\t        7、向文件写入数据       \\n\\n\");\n\tprintf(\"\\t\\t        8、从文件读出数据       \\n\\n\");\n\tprintf(\"\\t\\t        9、退出系统            \\n\\n\");\n\tprintf(\"\\t\\t******************************** \\n\\n\");\n}\n// add information\nint add_infor(STUDENT stu[], int n)\n{\n\tint i = 0;\n\tchar sign = 'Y';\n\n\twhile ((sign == 'Y') || (sign == 'y'))\n\t{\n\t\tprintf(\"\\n\\t\\t\\t学号：\");\n\t\tscanf(\"\\t\\t%s\", stu[n + i].num);\n\t\tprintf(\"\\t\\t\\t姓名：\");\n\t\tscanf(\"\\t\\t%s\", stu[n + i].name);\n\t\tprintf(\"\\t\\t\\t成绩：\");\n\t\tscanf(\"\\t\\t%d\", &stu[n + i].score);\n\n\t\tprintf(\"\\n\\t\\t\\t是否继续录入？（Y/N）：\");\n\t\t//清空缓存\n\t\tscanf(\"%*[^\\n]\") ;\n\t\tscanf(\"%*c\");\n\t\tsign=getchar();\n\n\t\ti++;\n\t}\n\n\treturn (n + i);\n}\n//browse information\nvoid browse_infor(STUDENT stu[], int n)\n{\n\tint i;\n\n\tprintf(\"\\n\\n\");\n\tprintf(\"\\t\\t学号\\t姓名\\t成绩\\n\\n\");\n\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tprintf(\"\\t\\t%s\\t%s\\t %d\\n\",stu[i].num,stu[i].name,stu[i].score);\n\t}\n}\n//find information\nvoid find_infor(STUDENT stu[], int n)\n{\n\tint option;\n\tint i = 0;\n\tchar search_num[10] = { 0 };\n\tchar search_name[20] = { 0 };\n\n\tprintf(\"\\n\\t\\t\\t1、按学号查找\\n\");\n\tprintf(\"\\t\\t\\t2、按姓名查找\\n\");\n\tprintf(\"\\n\\t\\t\\t请选择相应的选项：\");\n\tscanf(\"%d\",&option);\n\n\tsystem(\"cls\");\n\n\tif (1 == option)\n\t{\n\t\tprintf(\"\\n\\t\\t请输入要查找的学号：\");\n\t\tscanf(\"%s\", search_num);\n\n\t\twhile ((strcmp(stu[i].num, search_num) != 0) && i < n)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (2 == option)\n\t{\n\t\tprintf(\"\\n\\t\\t请输入要查找的姓名：\");\n\t\tscanf(\"%s\", search_name);\n\n\t\twhile ((strcmp(stu[i].name, search_name) != 0) && i < n)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (i == n)\n\t{\n\t\tprintf(\"\\n\\t\\t未找到！\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\n\\t\\t学号：%s\\n\", stu[i].num);\n\tprintf(\"\\t\\t姓名：%s\\n\", stu[i].name);\n\tprintf(\"\\t\\t成绩：%d\\n\", stu[i].score);\n}\n//modify information\nint modify_infor(STUDENT stu[], int n)\n{\n\tint option, choice;\n\tint i = 0;\n\tchar old_temp[20] = { 0 };\n\tchar new_temp[20] = { 0 };\n\tfloat new_score;\n\n\tprintf(\"\\n\\t\\t\\t1、按学号查找修改\\n\");\n\tprintf(\"\\t\\t\\t2、按姓名查找修改\\n\");\n\tprintf(\"\\n\\t\\t请输入选项选择功能：\");\n\tscanf(\"%d\", &option);\n\n\tsystem(\"cls\");\n\n\tif (1 == option)\n\t{\n\t\tprintf(\"\\n\\t\\t请输入学号：\");\n\t\tscanf(\"%s\", &old_temp);\n\n\t\twhile ((strcmp(stu[i].num, old_temp) != 0) && i < n)\n\t\t{\n\t\t\ti++;\n\t\t}\n\n\t\tif (i == n)\n\t\t{\n\t\t\tprintf(\"\\n\\t\\t未找到！\");\n\t\t}\n\t}\n\n\tif (2 == option)\n\t{\n\t\tprintf(\"\\n\\t\\t请输入姓名：\");\n\t\tscanf(\"%s\", &old_temp);\n\n\t\twhile ((strcmp(stu[i].name, old_temp) != 0) && i < n)\n\t\t{\n\t\t\ti++;\n\t\t}\n\n\t\tif (i == n)\n\t\t{\n\t\t\tprintf(\"\\n\\t\\t未找到！\");\n\t\t}\n\t}\n\n\tprintf(\"\\n\\t\\t待修改学生的信息：\\n\");\n\tprintf(\"\\n\\t\\t学号：%s\\n\\t\\t姓名：%s\\n\\t\\t成绩：%d\\n\", stu[i].num, stu[i].name, stu[i].score);\n\n\tprintf(\"\\n\\t\\t请选择要修改的信息（1.学号 2.姓名 3.成绩）：\");\n\tscanf(\"%d\", &choice);\n\n\tif (1 == choice)\n\t{\n\t\tprintf(\"\\n\\t\\t输入修改后的学号：\");\n\t\tscanf(\"%s\", &new_temp);\n\n\t\tstrcpy(stu[i].num, new_temp);\n\t\tprintf(\"\\t\\t修改成功！\\n\");\n\t}\n\n\tif (2 == choice)\n\t{\n\t\tprintf(\"\\n\\t\\t输入修改后的姓名：\");\n\t\tscanf(\"%s\", &new_temp);\n\n\t\tstrcpy(stu[i].name, new_temp);\n\t\tprintf(\"\\t\\t修改成功！\\n\");\n\t}\n\n\tif (3 == choice)\n\t{\n\t\tprintf(\"\\n\\t\\t输入修改后的成绩：\");\n\t\tscanf(\"%f\", &new_score);\n\n\t\tstu[i].score = new_score;\n\t\tprintf(\"\\t\\t修改成功！\\n\");\n\t}\n}\n//sort the score\nvoid sort_score(STUDENT stu[], int n)\n{\n\tint i, j;\n\tint * p, * q, s;\n\tchar temp[20];\n\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tfor (j = 0; j < n - 1 - i; j++)\n\t\t{\n\t\t\tif (stu[j].score > stu[j + 1].score)\n\t\t\t{\n\t\t\t\tstrcpy(temp, stu[j].num);\n\t\t\t\tstrcpy(stu[j].num, stu[j + 1].num);\n\t\t\t\tstrcpy(stu[j + 1].num, temp);\n\n\t\t\t\tstrcpy(temp, stu[j].name);\n\t\t\t\tstrcpy(stu[j].name, stu[j+1].name);\n\t\t\t\tstrcpy(stu[j+1].name,temp);\n\n\t\t\t\tp = &stu[j].score;\n\t\t\t\tq = &stu[j + 1].score;\n\t\t\t\ts = *p;\n\t\t\t\t*p = *q;\n\t\t\t\t*q = s;\n\t\t\t}\n\t\t}\n\t}\n}\n//delete information\nint delete_infor(STUDENT stu[], int n)\n{\n\tchar search_num[10] = { 0 };\n\tchar search_name[20] = { 0 };\n\tint i = 0;\n\tint j;\n\tint option;\n\t\n\tprintf(\"\\n\\t\\t\\t1、按学号查找删除\\n\");\n\tprintf(\"\\t\\t\\t2、按姓名查找删除\\n\");\n\tprintf(\"\\n\\t\\t\\t请输入选项选择功能：\");\n\tscanf(\"%d\", &option);\n\t\n\tsystem(\"cls\");\n\n\tif (1 == option)\n\t{\n\t\tprintf(\"\\n\\t\\t请输入要删除的学生的学号：\");\n\t\tscanf(\"%s\", &search_num);\n\n\t\twhile ((strcmp(stu[i].num, search_num)) != 0 && (i < n))\n\t\t{\n\t\t\ti++;\n\t\t}\n\n\t\tif (i == n)\n\t\t{\n\t\t\tprintf(\"\\t\\t未找到！\\n\");\n\t\t\treturn n;\n\t\t}\n\t}\n\t\n\tif (2 == option)\n\t{\n\t\tprintf(\"\\n\\t\\t请输入要删除的学生的姓名：\");\n\t\tscanf(\"%s\", &search_name);\n\n\t\twhile ((strcmp(stu[i].num, search_name) != 0) && (i < n))\n\t\t{\n\t\t\ti++;\n\t\t}\n\n\t\tif (i == n)\n\t\t{\n\t\t\tprintf(\"\\t\\t未找到！\\n\");\n\t\t\treturn n;\n\t\t}\n\t}\n\n\tfor (j = i; j < n; j++)\n\t{\n\t\tstrcpy(stu[j].num, stu[j + 1].num);\n\t\tstrcpy(stu[j].name, stu[j + 1].name);\n\t\tstu[j].score = stu[j + 1].score;\n\t}\n\n\tprintf(\"\\t\\t删除成功！\\n\");\n\treturn (n - 1);\n}\n//write to file\nvoid writetofile(STUDENT stu[], int n)\n{\n\tFILE* fp;\n\tint i = 0;\n\tchar filename[20] = { 0 };\n\t\n\tprintf(\"\\n\\t\\t\\t请输入文件名称：\");\n\tscanf(\"%s\", filename);\n\n\tif ((fp = fopen(filename, \"w\")) == NULL)\n\t{\n\t\tprintf(\"\\n\\t\\t\\t打开文件失败！\\n\");\n\t\treturn;\n\t}\n\n\tfprintf(fp, \"%d\\n\", n);\n\n\twhile (i < n)\n\t{\n\t\tfprintf(fp, \"%-6s%-10s%d\\n\", stu[i].num, stu[i].name, stu[i].score);\n\t\ti++;\n\t}\n\n\tfclose(fp);\n\n\tprintf(\"\\n\\t\\t\\t写入文件成功！\\n\");\n}\n//read from file\nint readfromfile(STUDENT stu[], int n)\n{\n\tFILE* fp;\n\tint i, num;\n\tchar filename[20];\n\n\ti = 0;\n\n\tprintf(\"\\n\\t\\t\\t请输入文件名称：\");\n\tscanf(\"%s\", filename);\n\n\tif ((fp = fopen(filename, \"r\")) == NULL)\n\t{\n\t\tprintf(\"\\n\\t\\t\\t无法打开文件！\\n\");\n\n\t\treturn n;\n\t}\n\n\tfscanf(fp, \"%d\", &num);\n\n\twhile (i < num)\n\t{\n\t\tfscanf(fp, \"%-5s%-10s%d\\n\", stu[n + i].num, stu[n + i].name, stu[n + i].score);\n\t\ti++;\n\t}\n\n\tn += num;\n\tfclose(fp);\n\n\tprintf(\"\\n\\t\\t\\t读出数据成功！\\n\");\n\n\treturn n;\n}\nint main()\n{\n\tint select = 0;\n\tint n = 0;\n\n\twhile (1)\n\t{\n\t\tsystem(\"cls\");\n\t\t\n\t\thome_page();\n\n\t\tprintf(\"\\t\\t输入标号选择功能： \");\n\t\tscanf(\"%d\", &select);\n\n\t\tswitch (select)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t********录入学生成绩信息********\\n\");\n\t\t\t\tn = add_infor(stu, n);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t********浏览学生成绩信息********\\n\");\n\t\t\t\tbrowse_infor(stu, n);\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\t\t\t\n\t\t\tcase 3:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t**********查询学生信息**********\\n\");\n\t\t\t\tfind_infor(stu, n);\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t*********修改学生信息*********\\n\");\n\t\t\t\tn = modify_infor(stu, n);\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t*********按成绩排序*********\\n\");\n\t\t\t\tsort_score(stu, n);\n\t\t\t\tprintf(\"\\n\\t\\t\\t排序成功！\");\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\t\n\t\t\tcase 6:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t*********删除学生信息*********\\n\");\n\t\t\t\tn = delete_infor(stu, n);\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t********向文件写入数据********\\n\");\n\t\t\t\twritetofile(stu, n);\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\t\\t********从文件读出数据********\\n\");\n\t\t\t\tn = readfromfile(stu, n);\n\t\t\t\tgetchar();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tprintf(\"\\n\\n\\t\\t**********谢谢使用！**********\\n\");\n\t\t\t\texit(0);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tgetchar();\n\t}\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;scanf(&amp;#34;%s&amp;#34;,&amp;amp;S[i-1].c);&lt;br /&gt;改为&lt;br /&gt;scanf(&amp;#34;%c&amp;#34;,&amp;amp;S[i-1].c);&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["无法打印结构体数组里的数据", ["在练习用c语言实现哈夫曼树时，建立了一个结构体数组原来存放字符及其相应的权值和编码", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "define", " N 8", "\n", "//存储哈夫曼树的静态三叉链表定义", "\n", "typedef", " ", "struct", "{\n", "unsigned", " ", "int", " weight;\n", "unsigned", " ", "int", " parent, lchild, rchild;\n}HTNode, *HuffmanTree;\n", "typedef", " ", "char", " ** HuffmanCode;\n", "//字符、权值、对应编码组成的结构体类型", "\n", "struct", " ", "s", " \n{\n", "char", " c;\n", "unsigned", " ", "int", " weight;\n", "char", " code[N];\n};\n", "//选择两个权值最小的结点", "\n", "void", " ", "Select", "(HuffmanTree &HT,", "unsigned", " ", "int", " i,", "unsigned", " ", "int", " *s1,", "unsigned", " ", "int", " *s2)", "{\n    ", "unsigned", " ", "int", " min1,min2,j;\n    min1=min2=", "9999", ";\n    ", "for", "(j=", "1", ";j<=i;j++){\n        ", "if", "(HT[j].weight<min2&&HT[j].parent ==", "0", "){\n            min2=min1;\n            *s2=j;\n            ", "if", "(HT[j].weight<min1&&HT[j].parent==", "0", "){\n                min1=HT[j].weight;\n                *s1=j;\n\n            }\n        }\n    }\n}\n\n", "//构造哈夫曼树和哈夫曼编码", "\n", "void", " ", "Huffman", "(HuffmanTree &HT,HuffmanCode &HC,", "unsigned", " ", "int", " n,s S[N])", "{\n    ", "if", " (n<=", "1", ")", "return", ";\n    ", "unsigned", " ", "int", " i=", "0", ",m=", "2", "*n", "-1", ",c=", "0", ",f=", "0", ",s1=", "0", ",s2=", "0", ";\n    HuffmanTree p;\n    HT=(HuffmanTree)", "malloc", "((m+", "1", ")*", "sizeof", "(HTNode));\n    ", "for", "(p=HT+", "1", ",i=", "1", ";i<=n;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=S[i", "-1", "].weight;\n    }\n", "/*    for(unsigned int v=1;v<=2*n-1;v++){\n        printf(\"%d\\t\",HT[v].weight);\n        printf(\"%d\\t\",HT[v].parent);\n        printf(\"%d\\t\",HT[v].lchild);\n        printf(\"%d\\t\\n\",HT[v].rchild);\n    }\n    printf(\"****************************************************\\n\");*/", "\n    ", "for", "(;i<=m;i++,++p){\n        p->parent=", "0", ";\n        p->lchild=", "0", ";\n        p->rchild=", "0", ";\n        p->weight=", "0", ";\n    }\n    ", "/*for(unsigned int o=1;o<=2*n-1;o++){\n        printf(\"%d\\t\",HT[o].weight);\n        printf(\"%d\\t\",HT[o].parent);\n        printf(\"%d\\t\",HT[o].lchild);\n        printf(\"%d\\t\\n\",HT[o].rchild);\n    }\n    printf(\"*************************************************************************\\n\");*/", "\n        ", "for", "(i=n+", "1", ";i<=m;++i){\n        ", "Select", "(HT,i", "-1", ",&s1,&s2);\n        HT[s1].parent=i;\n        HT[s2].parent=i;\n        HT[i].lchild=s1;\n        HT[i].rchild=s2;\n        HT[i].weight=HT[s1].weight+HT[s2].weight;\n    }\n", "/*    for(unsigned int k=1;k<=2*n-1;k++){\n        printf(\"%d\\t\",HT[k].weight);\n        printf(\"%d\\t\",HT[k].parent);\n        printf(\"%d\\t\",HT[k].lchild);\n        printf(\"%d\\t\\n\",HT[k].rchild);\n    }*/", "\n    HC=(HuffmanCode)", "malloc", "((n+", "1", ")*", "sizeof", "(", "char", "*));\n    ", "char", " *cd=(", "char", "*)", "malloc", "(n*", "sizeof", "(", "char", "));\n    cd[n", "-1", "]=", "'\\0'", ";\n    ", "for", "(i=", "1", ";i<=n;i++){\n        ", "int", " start=n", "-1", ";\n        ", "for", "(c=i,f=HT[i].parent;f!=", "0", ";c=f,f=HT[f].parent){\n            ", "if", "(HT[f].lchild==c)cd[--start]=", "'0'", ";\n            ", "else", " cd[--start]=", "'1'", ";}\n        HC[i]=(", "char", "*)", "malloc", "((n-start)*", "sizeof", "(", "char", "));\n", "//        strcpy(HC[i],&cd[start]);", "\n        ", "strcpy", "(S[i].code,&cd[start]);\n    }\n    ", "free", "(cd);\n}\n", "//输出哈夫曼树数据", "\n", "void", " ", "PrintHuffman", "(HuffmanTree HT,", "int", " n,s S[N])", "{\n    ", "printf", "(", "\"哈夫曼树如下所示:\\n\"", ");\n    ", "for", "(", "int", " k=", "1", ";k<=", "2", "*n", "-1", ";k++){\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].weight);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].parent);\n        ", "printf", "(", "\"%d\\t\"", ",HT[k].lchild);\n        ", "printf", "(", "\"%d\\t\\n\"", ",HT[k].rchild);\n    }\n    ", "printf", "(", "\"8个字符的字符、权值及哈夫曼编码如下:\\n\"", ");\n    ", "for", "(", "int", " l=", "0", ";l<=n;l++){\n    ", "printf", "(", "\"%s\\t%u\\t%s\\t\\n\"", ",S[l].c,S[l].weight,S[l].code);\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n ", "//哈夫曼树的建立和编码的生成", "\n    HuffmanTree HT;\n    HuffmanCode HC;\n    s S[N];\n    ", "printf", "(", "\"请输入8个字符，及它们的权值:\\n\"", ");\n    ", "for", "(", "int", " i=", "1", ";i<=N;i++){\n        ", "printf", "(", "\"请输入第%d个字符:\"", ",i);\n        ", "scanf", "(", "\"%s\"", ",&S[i", "-1", "].c);\n        ", "printf", "(", "\"请输入该字符的权值:\"", ");\n        ", "scanf", "(", "\"%u\"", ",&S[i", "-1", "].weight);\n    ", "//    printf(\"%d\\n\",S[i-1].weight);", "\n    }\n    ", "Huffman", "(HT,HC,", "8", ",S);\n   \n ", "//打印输出哈夫曼树数据", "\n    ", "PrintHuffman", "(HT,", "8", ",S);\n ", "//用户输入任意一个由 N 个字符组成的字符串，输出该字符串对应的哈夫曼编码字符串", "\n    ", "printf", "(", "\"请输入一个字符串,该字符串只能包含8个字符(ABCDEFGH):\"", ");\n    \n    ", "printf", "(", "\"\\n该字符串对应的哈夫曼编码为:\"", ");\n\n\n", "//用户输入哈夫曼编码(由 01 组成)，将进行解码，输出对应的字符串", "\n    ", "printf", "(", "\"请输入一个由0或1构成的哈夫曼编码:\"", ");\n    ", "printf", "(", "\"\\n该哈夫曼编码对应的字符串为\"", ");\n    ", "system", "(", "\"PAUSE\"", ");\n ", "return", " ", "0", ";\n}\n", "\n", "但是打印输出的时候没有打印结构体数组里的数据，为什么？", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;很可能是matlab的版本问题&amp;#xff0c;检查一下版本的兼容性。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["matlab App Designer报错“结构体内容引用自非结构体数组对象”", ["github上fork的matlab代码，但是无法查看源代码", "\n", "GitHub项目地址", "https://github.com/NathanJustus/VideoVibrometry_MatlabApp", "\n", "报错", "\n", "\n", "运行报错", "\n", "\n", "matlab刚接触，求各位指点", "\n", "万分感谢"]], "Tag": "程序设计"}
{"Answer": "c 用 qsort\r\nc++ 用 sort\r\n重写排序函数 cmp", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言 超级菜的小白请问怎么通过结构体数组中元素将结构体排序？", ["学校编程题", "\n问题描述", "\n考研初试成绩公布后需要对m个学生的成绩进行排序，筛选出可以进入复试的前n名学生。排序规则为首先按照总分排序，总分相同则按英语单科成绩排序，总分和英语成绩也相同时考号小者排在前面。现给出这m个学生的考研初试成绩，请筛选出可以进入复试的n名学生并按照排名从高到低的顺序依次输出。", "\n输入说明", "\n输入为m+1行，第一行为两个整数m和n，分别表示总人数和可以进入复试人数，m和n之间用空格分隔，0<n<m<200。接下来为m行数据，每行包括三项信息，分别表示一个学生的考号（字符串）、总成绩（整数）和英语单科成绩（整数），这三项之间用空格分隔。", "\n输出说明", "\n按排名从高到低的顺序输出进入复试的这n名学生的信息。", "\n输入样例", "\n5 3 ", "\nXD20160001 330 65 ", "\nXD20160002 330 70 ", "\nXD20160003 340 60 ", "\nXD20160004 310 80 ", "\nXD20160005 360 75 ", "\n输出样例", "\nXD20160005 360 75 ", "\nXD20160003 340 60 ", "\nXD20160002 330 70 ", "\n\n", "本人写的", "\n\n", "#include", "\n#include", "\n#define stu struct STU", "\nint main()", "\n{", "\n    int m,n;", "\n    scanf(\"%d %d\",&m,&n);", "\n    struct STU", "\n    {", "\n        char no[10];", "\n        int zong;", "\n        int eng;", "\n    }xue[m];", "\n    for(int i=0;i\n    scanf(\"%s %d %d\",xue[i].no,&xue[i].zong,&xue[i].eng);", "\n    int i,j,t;", "\n    for(i=0;i\n     for(j=0;j\n        if(xue[j].zong0))", "\n        {", "\n            t=xue[j].;xue[j]=xue[j+1];xue[j+1]=t;", "\n        }", "\n        for(i=0;i<n;i++)", "\n        printf(\"%s %d %d\",xue[i].no,xue[i].zong,xue[i].eng);", "\n        return 0;", "\n}", "\n\n", "想用冒泡法排序 结构体用不了 有点meng'bi"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;直接给定最大长度定义&lt;br /&gt;如果需要传输时尽量节省字节数&amp;#xff0c;传输时根据实际数据字节长度截短。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言如何定义数据内容大小不确定的结构体？", ["\n", "\n", "对于图片表格这种内容大小不确定的结构体，该怎么表示定义？struct里面嵌套一个union吗，还是说直接给定最大长度定义？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;void swap(complex &amp;amp;a, complex &amp;amp;b) {\n\tcomplex tmp;\n    tmp &amp;#61; a;\n\ta &amp;#61; b;\n\tb &amp;#61; tmp;\n}\ntmp是备份变量&amp;#xff0c;利用它交换两个结构体其实和交换两个变量也是一样的&amp;#xff0c;只不过不能在数值上操作。&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求教大佬 如何实现C语言结构体内容交换？", ["\n", "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nstruct complex\n{\n    double r,i;\n    complex() {r=0,i=0;}\n    complex(double r1,double i1): r(r1),i(i1){}\n};\nvoid swap(complax*a ,complax*b)\n{\n    \n}\nint main()\n{\n  complex a1(1,2) , a2(4,6);\n  swap(a1,a2)\n  return 0\n}\n", "\n\n", "想通过swap交换a1 a2 的值  ", "\n\n", "帮忙实现一下swap函数"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;用结构体指针同样可以   printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t%s\\n&amp;#34;&lt;/span&gt;,Stu[i].number,Stu[i].name);输出\n或者是  printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t%s\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(Stu&amp;#43;i)&lt;/span&gt;-&amp;gt;&lt;/span&gt;number,&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(Stu&amp;#43;i)&lt;/span&gt;-&amp;gt;&lt;/span&gt;name);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&amp;#xff08;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢! 点击我这个回答右上方的&lt;strong&gt;【采纳】&lt;/strong&gt;按钮&amp;#xff09;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Node&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; number;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Node&lt;/span&gt; *link;\n} Nodelist;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Nodelist stu[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; {\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;aaa&amp;#34;&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;bbb&amp;#34;&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;ccc&amp;#34;&lt;/span&gt;}\n    };\n    Nodelist *Stu &amp;#61; stu;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t%s\\n&amp;#34;&lt;/span&gt;,(Stu&amp;#43;i)-&amp;gt;number,(Stu&amp;#43;i)-&amp;gt;name);\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/375045454336152.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体赋值给结构体指针后，怎样才能正确输出打印赋值给结构体指针后的字符指针", ["\n", "如图所示，我应该怎样正确输出打印结构体指针对应的字符串数据呢？？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;最好是做一下初始化&lt;br /&gt;如&amp;#xff1a;struct book history_book[6] &amp;#61; {0};&lt;br /&gt;或者定义的时候不做初始化&amp;#xff0c;在程序开始的地方对结构体数组做一下清空。&lt;br /&gt;如&amp;#xff1a;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        struct book history_book[6] &amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        memset&amp;#xff08;&amp;amp;history_book, 0,sizeof&amp;#xff08;history_book&amp;#xff09;&amp;#xff09;&amp;#xff1b;&lt;/span&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言   结构体数组需不需要初始化？ 怎样初始化为0或为空", ["关于 C语言中的 结构体数组，最近有一个疑问：", "\n", "在学习数组的时候，要求在定义一个数组之后，最好初始化一下，为0 或者为空，以免后面出现意想不到的错误。", "\n", "那么 对于  结构体数组呢 ？  是否 定义了之后  也最好需要初始化一下？ ", "\n", "例如  定义一个存储了书名和价格的结构体  struct  book {  char  book_name[30] ;   float  price; }  , 然后定义   一个书名的结构体数组 ", "\n", "struct  book   history_book[6];  ", "\n", "对于  初次定义的这个  结构体  数组， 到底需不需要初始化？    ", "\n", "怎样将 这个  结构体数组初始化为0 或者  为空？  ", "\n", "谢谢！  "]], "Tag": "程序设计"}
{"Answer": "可以不初始化，不初始化输出的就是随机值，即申请这段内存时存储的值。\r\n如果你学过c或者c++就会知道变量不赋初值会带来很严重的问题或者bug。\r\n很多条条框框的东西存在即是为了不让你费时间去思考不这样做会不会有问题，因为这都是前辈踩出来的坑或者血的教训，如果你非要思考这种问题，等到后面学进程锁、线程安全概念后有一堆原理等着你去剖析，一般这种问题按照规范去做就没事了。\r\njava中基本类型的的变量会在声明的时候进行初始化，但是坚持自己代码初始化还是一个好习惯。", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言关于结构体必须要初始化吗？", ["#include<stdio.h>\n#include<stdlib.h>\n\nstruct stu\n{\n    int a;\n    char b;\n    float c;\n    char arr[10];\n};\n\nint main(void)\n{\n    struct stu  st;\n    //memset(st, 0, sizeof(st));\n    printf(\"%d\\n\", st.a);\n\n    return 0;\n}\n", "\n\n", "结构体必须要初始化吗？在声明完一个结构体变量后，不是已经在内存中申请了空间了吗，为啥不能够直接输出st.a必须要初始化，虽然不初始化里面的内容", "\n不确定。"]], "Tag": "程序设计"}
{"Answer": "直接调用内存清零的函数，如：memset，或者 ZeroMemory()等，参数需要结构体变量的指针和结构体大小。", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体清零的实现", ["struct BLACK{", "\nchar Name[10];", "\n int a;", "\nint b;", "\n int  c;", "\nint d;", "\n};", "\n\n", "void Clear(unsigned char *Ptr, int Size )", "\n{", "\n        while(Size!=0)", "\n        {", "\n                *Ptr++ = 0;", "\n                Size --;", "\n        }", "\n}", "\n\n", "引用: void main()", "\n{", "\n         Clear(( unsigned char *)&Name[0],sizeof(Name));", "\n\n", "}", "\n\n", "这是我找到的一种方法，请问还可以怎样实现结构体清零呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这样定义有几个好处&lt;br /&gt;1.可以保证你的指针在循环的过程中不会把head搞丢了&amp;#xff0c;你的tree永远指向的是root&amp;#xff0c;它跟node类型不一样&amp;#xff0c;你不会不小心把指向root的指针给指向node去&lt;br /&gt;2.如果你需要记录整棵树到底有多少个节点这种信息&amp;#xff0c;那放到node里是不合适的&amp;#xff0c;就应该单独拿出来&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么有些数据结构要定义两个结构体？", ["复习数据结构的时候发现，我这本教材的所有逻辑结构几乎都定义了两个结构体，一个定义结点，一个定义这个结构", "例如树的结构：", "\n", "typedef ", "struct", " ", "btnode", "\n{\n  ElemType element;\n  ", "struct", " ", "btnode", " *lChild;\n  ", "struct", " ", "btnode", " *rChild; \n}BTNode;\n\ntypedef ", "struct", " ", "binarytree", "\n{\n  BTNode *root;\n}BinaryTree;\n", "\n", "像顺序表这种定义第二个可以记录表的长度，树的定义里面除了根节点什么都没有，所以我看到很多网上的代码是没有第二个定义的，直接用根结点进行运算", "那为什么还要定义它呢？"]], "Tag": "程序设计"}
{"Answer": "int型是32位的，也就是说要占用4个byte，你直接输出byte[]当然没用，要读取int型请使用DataInputStream包装，使用其readInt方法读取。", "Konwledge_Point": "数据封装——结构体", "Question": ["java socket如何接收C客户端发过来的结构体数据？", ["C做客户端向java服务器通过socket发送结构体数据，传送的是约定好的数字，但是服务端通过InputStream接收数据，然后放到byte数组中，然后再转为string类型的，现在出现乱码？这是怎么回事呢？直接将byte数组中的数据输出发现里面出现负数，约定的数据都是正的，这是怎么回事呢？是转码的问题还是接收的问题呢？请问如何解决呢？麻烦知道的帮助小弟一下。多谢"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    table t;\n    &lt;span class=\"hljs-constructor\"&gt;Initlist()&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;Listhead(&lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; s&amp;#61;&lt;span class=\"hljs-constructor\"&gt;Listlength(&lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;)&lt;/span&gt;;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++的结构体struct和自定义函数的调用", ["怎样在main函数中调用Initlist()，并传入函数执行后的值？怎样输出Listsize()，Listlength()和Listhead()的返回值？", "\n", "#include <stdio.h>", "#include ", "\n", "using namespace std;", "#define Size 8 //顺序表的容量大小", "\n", "struct table {", "int size; //顺序表的容量大小（形参）", "int length;//顺序表的有效长度，及数组中的元素个数", "int* head;//动态数组", "};", "\n", "void Initlist()", "{", "table t;", "t.length = 0;", "t.size=Size;", "t.head = new int[t.size];", "\n", "int i;", "int n;", "cout<<\"输入\"<<n<<\"的值\"；", "cin>>n;", "for (i = 0; i < n; i++)", "{", "cout << endl<<\"输入第\" << i + 1 << \"个数据:\";", "cin >> t.head[i];", "t.length++;", "}", "};", "\n", "int Listsize(table t) //求顺序表的容量大小", "{", "return t.size;", "}", "\n", "int Listlength(table t)//求顺序表中数组的元素个数", "{", "return t.length;", "}", "\n", "int Listhead(table t)//求顺序表中数组的各元素", "{", "int i;", "int n=0;", "for (i = 0; i < n; i++)", "return t.head[i];", "}", "\n", "int main()", "{", "Listsize();", "Listlength();", "Listhead();", "return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把你代码贴出来&lt;br /&gt;看你的输入&amp;#xff0c;错误是 scanf()函数&amp;#xff0c;如果是字符串%s&amp;#xff0c;不需要加&amp;amp;符号&amp;#xff0c;也不要在scanf()里面加\\n&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["无法将数据输入结构体", ["\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改处见注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\ntypedef struct User_basicinfo\n{\n    char id[&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;];\n    char paw[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    char name[&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;];\n    char sex[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    char shenfen[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n}Users;\n\n\nvoid check_3_() &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;浏览一般教师名单\n{\n    int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    Users tmp;   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;Users a[];\n    FILE* pf &amp;#61; fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;users.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pf &amp;#61;&amp;#61; NULL)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;      打开文件失败\\n&amp;#34;&lt;/span&gt;);\n        return;\n    }\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;fread(&amp;amp;a, sizeof(struct User_basicinfo), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fread(&amp;amp;tmp, sizeof(struct User_basicinfo), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(tmp.shenfen, &lt;span class=\"hljs-string\"&gt;&amp;#34;一般教师&amp;#34;&lt;/span&gt;) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)         &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;如果有此类教师\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;----------------------------------------------------------------------------------------------------\\n&amp;#34;&lt;/span&gt;);\n                    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;教师编号  姓名\\n&amp;#34;&lt;/span&gt;);\n                }\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%20s%9s\\n&amp;#34;&lt;/span&gt;, tmp.id, tmp.name);\n                i&amp;#43;&amp;#43;;\n                &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    fclose(pf);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!i)\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t                   ◆无此类教师&amp;#xff01; &amp;#34;&lt;/span&gt;);\n\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n            &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (!feof(pf))  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;如果文件没有读完\n\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    fread(&amp;amp;a, sizeof(struct User_basicinfo), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n    \n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    Sleep(&lt;span class=\"hljs-number\"&gt;500&lt;/span&gt;);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    fclose(pf);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    return;\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n---------------------------------◇所有信息已显示&amp;#xff0c;按回车返回主菜单◇-------------------------------\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;fclose(pf); pf &amp;#61; NULL;\n    getchar();\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    checkmenu();\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何输出结构体中指定一项变量信息的全部数据", ["如下图部分代码所示", "我建立了一个结构体users，然后想输出结构体中身份为一般教师的全部教师信息，请问这个应该怎么实现呀？", "\n", "typedef", " ", "struct", " ", "User_basicinfo", "\n{\n    ", "char", " id[", "15", "];\n    ", "char", " paw[", "20", "];\n    ", "char", " name[", "15", "];\n    ", "char", " sex[", "5", "];\n    ", "char", " shenfen[", "20", "];\n}Users;\n\n\n", "void", " ", "check_3_", "()", "                                                                                    ", "//浏览一般教师名单", "\n", "{\n    ", "int", " i=", "0", ";\n    Users a[];\n    FILE *pf=", "fopen", "(", "\"users.txt\"", ",", "\"r\"", ");\n    ", "if", "(pf==", "NULL", ")\n    {\n        ", "printf", "(", "\"      打开文件失败\\n\"", ");\n        ", "return", " ;\n    }\n    ", "fread", "(&a, ", "sizeof", "(", "struct", " User_basicinfo),", "1", ",pf);\n     ", "while", " (", "1", ")\n           {\n               ", "if", " (", "strcmp", "(a[i].shenfen, ", "\"一般教师\"", ") == ", "0", ")         ", "//如果有此类教师", "\n               {\n                   i++;\n                   ", "printf", "(", "\"----------------------------------------------------------------------------------------------------\\n\"", ");\n                   ", "printf", "(", "\"教师编号  姓名\\n\"", ");\n                   ", "printf", "(", "\"%20s%9s\\n\"", ",a[i].id,a[i].name);\n                   ", "break", ";\n               }\n\n               ", "else", "\n               {\n                   ", "if", " (!", "feof", "(pf))  ", "//如果文件没有读完", "\n\n                   {\n                       ", "fread", "(&a, ", "sizeof", "(", "struct", " User_basicinfo),", "1", ",pf);\n                   }\n\n                   ", "else", "\n                   {\n                       ", "printf", "(", "\"\\t\\t\\t                   ◆无此类教师！ \"", ");\n                       ", "Sleep", "(", "500", ");\n                       ", "fclose", "(pf);\n                       ", "return", ";\n                   }\n               }\n       }\n\n\n     ", "printf", "(", "\"\\n---------------------------------◇所有信息已显示，按回车返回主菜单◇-------------------------------\\n\"", ");\n     ", "fclose", "(pf); pf=", "NULL", ";\n     ", "getchar", "();\n     ", "system", "(", "\"pause\"", ");\n     ", "checkmenu", "();\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "fscanf(fp, \"%d\", &amp;(s2-&gt;number));", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言,从文件中读取数据给结构体变量赋值,不知道哪里错了", ["#include ", "\n#include ", "\n#include ", "\nstruct student {", "\n    int number;", "\n}num;", "\n\n", "int main()", "\n{", "\n\n", "struct student s1, *s2;\ns2 = &s1;\nFILE *fp = fopen(\"test.txt\", \"r\");\nfscanf(fp, \"%d\", s2->number);\n\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "结构体是值类型，参数是object,传递的时候装箱。方法体内修改的是装箱后的object,修改这个object，调用处的值类型结构体不会变。你把ref object改成ref TTrapPrm。但是直接通过反射写应该还是错的，在方法体内可以先装箱，反射赋值之后拆箱。随手写了一下，应该有更好的方法仅供参考![图片说明](https://img-ask.csdn.net/upload/202007/30/1596103325_330545.png)", "Konwledge_Point": "数据封装——结构体", "Question": ["C#  怎么通过方法修改结构体的值？", ["我想写个方法来通过结构体字段的 名称和值来批量设置参数，但是现在结构体作为参数传递后，方法中结构体参数改变了，但是方法外部的没变。", "\n怎么解决这个问题", "\n\n", "         public static void SetStructValue(ref object pStruct, string name, object value)\n        {\n            Type type = pStruct.GetType();\n            FieldInfo fieldInfo = type.GetField(name);\n            if (fieldInfo != null)\n            {\n                object v = Convert.ChangeType(value, fieldInfo.FieldType);\n                fieldInfo.SetValue(pStruct, v);\n            }\n        }\n\n\n", "\n\n", "        public struct TTrapPrm\n        {\n            public double acc;\n            public double dec;\n            public double velStart;\n            public short  smoothTime;\n        }\n\n\n", "\n\n", "找到办法了，先把结构体转换为object，运行完成后再将object 赋值给 struct", "\n\n", "连 ref  都能去掉", "\n\n", "            TTrapPrm trapPara = new TTrapPrm();\n            object obj = trapPara;\n            SetStructValue(obj, \"acc\", 10);\n            trapPara = (TTrapPrm)obj;\n", "\n\n", "不知道有没有更好的办法", "\n\n", "试过了，另一种实现方法", "\n\n", "          public static void SetStructValue1<T>(ref T scr, string name, object value)\n        {\n            object pStruct = scr as object;\n            Type type = pStruct.GetType();\n            FieldInfo fieldInfo = type.GetField(name);\n            if (fieldInfo != null)\n            {\n                object v = Convert.ChangeType(value, fieldInfo.FieldType);\n                fieldInfo.SetValue(pStruct, v);\n            }\n            scr = (T)pStruct;\n        }\n"]], "Tag": "程序设计"}
{"Answer": "问题一:\r\n       可以这样的。\r\n问题二:\r\n       也是可以的，只是不知道你怎么用的p\r\n\t\t\t这样应该可以:   p-&gt;B就是数组的首地址， p-&gt;B[0].id就等于12\r\n\t\t\t你试试吧，应该是可以的。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体数组指针可以直接赋值给结构体指针吗？", ["有一个结构体比如为", "\nstruct A {", "\n        struct *B;", "\n        struct *C;", "\n};", "\n\n", "struct B {", "\n    int id;", "\n    int pin;", "\n};", "\n\n", "struct C {", "\n    int a;", "\n    int b;", "\n};", "\n\n", "定义初始化struct B和struct C:", "\nstruct B   b__arry[2] = {{12, 34}, {56, 78}};", "\nstruct C  c__arry[2]   = {{12, 34}, {56, 78}};", "\n\n", "问题：", "\n1. 能否这样初始化struct A？", "\n   struct A a = {b_arry, c_arry};", "\n   struct A里的成员是结构体指针而b_arry和c_arry是结构体数组的地址。", "\n2. 结构体经过以下传递会不会造成数据的混乱？", "\n   比如有一个函数void func (void *arg);", "\n   往函数里面传参，如func (&a); (a按照问题1里进行了初始化)；", "\n   在函数里，是这样对参数进行转换的：", "\n   void func (void *arg) {", "\n   struct A *p = (struct A *)arg;", "\n   }", "\n   问题是用p取出里面的数据时发现都错了，但是在func函数外面取出数据都是正确的，我猜想是否因为void *arg的arg保存的是一个单纯的地址，并没有结构信息，所以当对它进行转换的时候它并不能识别里面有数组信息。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 5&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stuff&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;   stuffID;&lt;span class=\"hljs-comment\"&gt;//职工编号&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; bonus; &lt;span class=\"hljs-comment\"&gt;//工资&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( )&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stuff&lt;/span&gt; Stuff[N];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  i;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; minBonus;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;N; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//输入&lt;/span&gt;\n    {\n       &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%f&amp;#34;&lt;/span&gt;,&amp;amp;Stuff[i].stuffID, &amp;amp;Stuff[i].bonus);\n       &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n           minBonus &amp;#61; Stuff[i].bonus;\n       &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (minBonus &amp;gt; Stuff[i].bonus)\n           minBonus &amp;#61; Stuff[i].bonus;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;N; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//输出&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %.2f\\n&amp;#34;&lt;/span&gt;,Stuff[i].stuffID,Stuff[i].bonus);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;minBonus&amp;#61;%.2f&amp;#34;&lt;/span&gt;,minBonus);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["【C语言】结构体问题有以下职工信息，使用结构体数组存储这些信息，从键盘输入5条记录， 之后在屏幕上依次输出职工信息。", ["【问题描述】", "有以下职工信息，使用结构体数组存储这些信息，从键盘输入5条记录，", "之后在屏幕上依次输出职工信息。", "struct stuff{", "int stuffID;//职工编号", "float bonus; //工资", "};", "【输入形式】5条职工信息，分行输入，数据间空格隔开", "【输出形式】分行输出5条职工信息和最低工资，每行数据均使用1个空格分隔", "【输入样例】", "1001 8540.59", "1002 6345.45", "1003 3500.65", "1004 4898.86", "1005 5345.80", "【输出样例】每行数据均使用一个空格分割，分五行输出", "1001 8540.59", "1002 6345.45", "1003 3500.65", "1004 4898.86", "1005 5345.80", "minBonus=3500.65", "\n", "#include <stdio.h>", "#define N 5", "struct Stuff", "{", "    char name[8]; //职工姓名", "    int year; //工作年限", "    int salary; //工资", "};", "int main( )", "{", "    struct Stuff stuff[N];", "    int i;", "    //输入", "    for(i=0; i<N; i++)", "    {", "        scanf(\"%s%d%d\",stuff[i].name, &stuff[i].year,&stuff[i].salary);", "    }", "    //输出1", "    printf(\"原始工资\\n\");", "    printf(\"姓名 年限 工资\\n\");", "    for(i=0; i<N; i++)", "    {", "        printf(\"%s %d %d\\n\",stuff[i].name, stuff[i].year,stuff[i].salary);", "    }", "    //输出2", "    printf(\"加薪后工资\\n\");", "    printf(\"姓名 年限 工资\\n\");", "    for(i=0; i<N; i++)", "    {", "        printf(\"%s %d \",stuff[i].name, stuff[i].year);", "        if(stuff[i].year>=30)", "            printf(\"%d\\n\",stuff[i].salary+100);", "        else", "            printf(\"%d\\n\",stuff[i].salary);", "    }", "    return 0;", "}", "版权声明：本文为CSDN博主「伦栋才」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。", "原文链接：", "https://blog.csdn.net/lundongcai/article/details/53729705", "有什么不对？"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;通过文件大小&amp;#xff08;字节数&amp;#xff09;来判断记录个数是不正确的&amp;#xff0c;这对文件格式要有非常严格的要求&amp;#xff0c;比如姓名都是2个字&amp;#xff0c;分数不能是100分或低于10分&amp;#xff08;占用字节数不一样,导致每条记录大小不一样&amp;#xff09;&lt;/li&gt;&lt;li&gt;struct Stu 的大小包含了一些padding 的大小&amp;#xff0c;大小应该是4&amp;#43;8&amp;#43;4 &amp;#61; 16个字节&amp;#xff0c;所以用文件大小/sizeof(struct Stu)很难得到正确的记录数&lt;/li&gt;&lt;li&gt;可以通过读文件有多少行来判断有多少个记录&amp;#xff0c;然后对每次读入的一行进行sscanf&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么fscanf不能把数据读到结构体中去，求解答", ["#include\"stdio.h\"", "typedef struct Stu", "{", "    int no;", "    char name[6];", "    int grade;", "}sstu,*psstu;", "\n", "int main(int argc, char const *argv[])", "{", "    FILE *in,*out;", "    char str[100];", "    int n,i,sum=0;", "    float ave;", "    while ((in=fopen(\"a.txt\",\"r+\"))==NULL)", "    {", "        printf(\"不能打开源文件\\n\");", "    }", "    while ((out=fopen(\"b.txt\",\"w+\"))==NULL)", "    {", "        printf(\"不能打开目标文件\\n\");", "    }", "    while (fgets(str,100,in))", "    {", "        fputs(str,out);", "    }", "    fseek(in,0,2);", "    n=ftell(in);", "    printf(\"%d\\n\",n);", "    printf(\"%d\\n\",sizeof(struct Stu));", "    n=n/sizeof(struct Stu);", "    printf(\"有%d个学生的数据\\n\",n);", "    struct Stu t[n];", "    for(i=0;i<n;i++)", "    {", "        fscanf(in,\"%d %s %d\",&t[i].no,t[i].name,&t[i].grade);", "    }", "    for ( i = 0; i < n; i++)", "    {", "        printf(\"%d\\t\",t[i].grade);", "    }", "    for ( i = 0; i < n; i++)", "    {", "        sum=sum+t[i].grade;", "    }", "    ave=sum/n;", "    printf(\"平均成绩是%d\",ave);", "    fclose(in);", "    fclose(out);", "    return 0;", "}", "\n", "txt文件的格式是这样的：", "3011 张三  91", "3012 李四  96", "3013 王五  98", "3014 赵六  55"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff1a;&amp;#xff08;定义好结构体数组后&amp;#xff0c;进行临时变量的替换&amp;#xff0c;或者按顺序依次输入&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/227172466046137.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;这里涉及到scanf的默认换行符问题&amp;#xff0c;然后导致有空格输入&amp;#xff0c;用gets时&amp;#xff0c;会被之前的覆盖掉&amp;#xff0c;所以都改成了char类型数组&amp;#xff0c;在进行age换算时&amp;#xff0c;可以转化为int类型&amp;#xff0c;用atoi函数就行&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; NUM 3         &lt;span class=\"hljs-comment\"&gt;//可自己修改&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ID[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; Name[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; sex[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; age[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n}Student;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Init_stu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student stu[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(stu[i].ID);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(stu[i].Name);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;性别&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(stu[i].sex);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;年龄&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(stu[i].age);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }    \n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Print_stu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student stu[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号\\t姓名\\t性别\\t年龄\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\t&amp;#34;&lt;/span&gt;, stu[i].ID);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\t&amp;#34;&lt;/span&gt;, stu[i].Name);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\t&amp;#34;&lt;/span&gt;, stu[i].sex);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, stu[i].age);\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    Student stu[NUM];\n    &lt;span class=\"hljs-built_in\"&gt;Init_stu&lt;/span&gt;(stu, NUM);\n    &lt;span class=\"hljs-built_in\"&gt;Print_stu&lt;/span&gt;(stu, NUM);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言问题的输出使用结构体中的数据", ["有3个学生的信息，放在结构体数组中，要求输出全部学生的信息。", "注：学生姓名中可能包含空格，输出的数据中间有一个空格", "我的问题是我只会给结构体输入一组数据，怎么才能给结构体赋值多组输入呢？", "输入用例：", "10101", "Li Lin", "M", "18", "10102", "Zhang Fun", "M", "19", "10104", "Wang Min", "F", "20", "No. Name sex age", "10101 Li Lin M 18", "10102 Zhang Fun M 19", "10104 Wang Min F 20", "输出用例：", "No. Name sex age", "10101 Li Lin M 18", "10102 Zhang Fun M 19", "10104 Wang Min F 20", "输入用例：", "21001", "张三", "M", "20", "21002", "李四", "F", "22", "21003", "王五", "M", "19", "输出用例：", "No. Name sex age", "21001 张三 M 20", "21002 李四 F 22", "21003 王五 M 19"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是想既写入链表&amp;#xff0c;又写入文件&amp;#xff0c;然后还要循环输入&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["单链表循环输入结构体数据", [" 如图，我创建一个单链表，一个节点需要输入一组学生信息。现想要实现能循环输入，直至输入   #    结束 。求解，第二个while的条件该怎么写？  感谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;原题是啥&amp;#xff0c;你想怎莫加&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言怎么定义一个动态结构体数组的同时，又把前三个数据加进去", ["\n", "struct", " ", "Cate", "\n{\n    ", "int", " No;\n    ", "char", " Name[", "30", "];\n}ca;\n\n", "int", " ", "main", "()", "{\n    \n    ", "struct", " ", "Cate", " ca[", "1000", "]=\n    {\n        {", "1", ",", "\"Starter\"", "},\n        {", "2", ",", "\"Curries\"", "},\n        {", "3", ",", "\"Barbecues\"", "}\n    };\n    ca = (", "struct", " Cate*)", "malloc", "(", "sizeof", "(", "struct", " Cate)*", "1000", ");\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;回答1&amp;#xff1a;有没有更优雅的方式呢&amp;#xff1f;&lt;/p&gt;\n\n&lt;p&gt;不知道怎么算优雅&amp;#xff1f;&lt;/p&gt;\n\n&lt;p&gt;但是可以换一种写法&amp;#xff0c;一般都是这样写的吧&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;typedef node_ node;\n\nstruct node_{\n    node* next;\n    double float_value;\n}node;\n\n\nnode* p &amp;#61; (node*)malloc(sizeof(node);&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;回答2&amp;#xff1a;能不能只通过类型node得到结构体的大小呢&amp;#xff1f;&lt;/p&gt;\n\n&lt;p&gt;可以&lt;/p&gt;\n\n&lt;p&gt;结构体大小可以用  &lt;strong&gt;(int)(p&amp;#43;1) - (int)p &lt;/strong&gt;表示&amp;#xff0c;等同sizeof&amp;#xff0c;&lt;/p&gt;\n\n&lt;p&gt;但是&lt;strong&gt;sizeof() &lt;/strong&gt;的返回值是无符号的整型&lt;/p&gt;\n\n&lt;p&gt;所以改为&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;(unsigned int)(p&amp;#43;1) - (unsigned int)p &lt;/strong&gt;最好&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言通过指向结构体的指针，获得结构体大小", ["我定义了一个结构体，并定义了一个指针类型指向这个结构体", "\n\n", "\n", "typedef struct node_* node;\nstruct node_{\n    node next;\n    double float_value;\n};", "\n\n", "现在我想通过类型node申请空间，我直接", "\n\n", "\n", "node p = (node)malloc(sizeof(node);", "\n\n", "肯定是不行的，因为这是指针的大小，我尝试", "\n\n", "\n", "node p = (node)malloc(sizeof(node *);", "\n\n", "也不行，当然我可以直接这样：", "\n\n", "\n", "node p = (node)malloc(sizeof(struct node_);", "\n\n", "或者通过声明一个变量，然后解指针。", "\n\n", "但是请问有没有更优雅的方式呢？能不能只通过类型node得到结构体的大小呢？", "\n\n", "谢谢各位！"]], "Tag": "程序设计"}
{"Answer": "发送：\r\n\t\tstruct f;\r\n    char *ffff[sizeof(f)];\r\n    memcpy(ffff, &amp;f, sizeof(f));\r\n\t\t\r\n\t\t接收：\r\n\t\tstruct f;\r\n\t\tffff为收到的数据\r\n\t\tmemcpy(&amp;f, ffff, sizeof(ffff));", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言  socket  如何发送带指针的结构体？", ["发送一个带指针的结构体，我知道怎么发送？ 先把结构体转换成字符串，然后发出。", "\n但是接收的时候，怎么接收到结构体中？thanks！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Q_PROPERTY支持自定义数据结构体&amp;#xff0c;你需要使用Q_DECLARE_METATYPE()宏将该类型注册到Qt的MetaType System.&amp;#xff0c;这样这个结构体就可以用QVariant类来存取&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://doc.qt.io/qt-5/properties.html#properties-and-custom-types\" id=\"textarea_1641554972948_1641555222563_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://doc.qt.io/qt-5/properties.html#properties-and-custom-types&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=\"https://doc.qt.io/qt-5/qmetatype.html#Q_DECLARE_METATYPE\" id=\"textarea_1641554972948_1641555222563_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://doc.qt.io/qt-5/qmetatype.html#Q_DECLARE_METATYPE&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Q_PROPERTY进阶使用，自定义参数类型", ["Q_PROPERTY设定时第一个参数是数据类型，是否支持自定义数据结构体，在QTDesigner中激活自定义对话框输入结构体中各元素的值？"]], "Tag": "程序设计"}
{"Answer": "```\r\nstruct  B **b[4] 表示数组元素是二级指针的指针数组，即b[0]存放的是二级指针变量，那么b[0]的数据类型是struct B **，这点理解很关键！\r\nb[0] 是个二级指针，指向一个一级指针的内存单元，即指向(struct B*)指针类型，而*b[0]是这个一级指针所指向的内存单元的首地址，而这个内存单元是(struct B)结构体类型。不管是一级指针变量还是二级指针变量，指针变量本身也是需要占用存储空间的，只不过它存放的是地址值而已，这点理解也很关键！\r\n```\r\n使用memset初始化的方法如下：\r\n```\r\nstruct Big big;\r\nfor(i=0; i&lt;4; i++){\r\n\t\tbig.b[i] = (struct B**)malloc(sizeof(struct B *)); //动态分配一个一级指针变量内存单元，二级指针指向这个一级指针的内存单元\r\n\t\t*big.b[i] = (struct B *)malloc(sizeof(struct B));\r\n\t\tmemset(*big.b[i], 0, sizeof(struct B));\r\n}\r\n\t\r\n```\r\n要复制数据到单个struct B结构体，使用同样的方法：\r\n\r\n```\r\nstruct B *data = malloc(sizeof(struct B));\r\nfor(i=0; i&lt;4; i++)\r\n\tmemcpy(*big.b[i], data, sizeof(struct B));\r\n```\r\n\r\n我写了一个示例程序如下：\r\n\r\n```\r\n#include &lt;stdio.h&gt;\r\n#include &lt;string.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n\r\nstruct B{\r\n\tint b;\r\n};\r\n\r\nstruct Big{\r\n\tint other;\r\n\tstruct B **b[4];\r\n};\r\n\r\nint main()\r\n{\r\n\tint i=0;\r\n\tstruct Big big;\r\n\tfor(i=0; i&lt;4; i++){\r\n\t\tbig.b[i] = (struct B**)malloc(sizeof(struct B *)); //动态分配一个一级指针变量内存单元，二级指针指向这个一级指针的内存单元\r\n\t\t*big.b[i] = (struct B *)malloc(sizeof(struct B));\r\n\t\tmemset(*big.b[i], 0, sizeof(struct B));\r\n\t}\r\n\tstruct B *data = malloc(sizeof(struct B));\r\n\tdata-&gt;b = 999;\r\n\tfor(i=0; i&lt;4; i++){\r\n\t\tprintf(\"*big.b[%d]=%p, **big.b[%d]=%d\\n\", i, *big.b[i], i, **big.b[i]);\r\n\t\tmemcpy(*big.b[i], data, sizeof(struct B));\r\n\t\tprintf(\"*big.b[%d]=%p, **big.b[%d]=%d\\n\\n\", i, *big.b[i], i, **big.b[i]);\r\n\t}\r\n\t\r\n\tfor(i=0;i&lt;4;i++)\r\n\t{\r\n\t\tfree(*big.b[i]);\r\n\t\tfree(big.b[i]);\r\n\t}\r\n\tfree(data);\r\n\treturn 0;\r\n}\r\n```\r\n运行结果如下：\r\nF:\\c_work&gt;gcc demo.c -std=c99\r\n\r\nF:\\c_work&gt;a.exe\r\n*big.b[0]=0000000000B313F0, **big.b[0]=0\r\n*big.b[0]=0000000000B313F0, **big.b[0]=999\r\n\r\n*big.b[1]=0000000000B31430, **big.b[1]=0\r\n*big.b[1]=0000000000B31430, **big.b[1]=999\r\n\r\n*big.b[2]=0000000000B31470, **big.b[2]=0\r\n*big.b[2]=0000000000B31470, **big.b[2]=999\r\n\r\n*big.b[3]=0000000000B314B0, **big.b[3]=0\r\n*big.b[3]=0000000000B314B0, **big.b[3]=999\r\n从运行结果来看，赋值是正确的呀", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体的数据拷贝和清空", ["如图：", "\n有一个大的结构体指针：struct Big *big;", "\n里面有四个缓存，每一个缓存都是数组，每一个数组里面都是B的结构体指针。", "\n我有两个需要；", "\n1:memset 每个缓存", "\n2:向每个缓存memcpy单个struct B 的指针数据", "\n\n", "不知道有没有可行的方法。", "\n\n"]], "Tag": "程序设计"}
{"Answer": "用[StructLayout(LayoutKind.Sequential)]，可以让C#的结构体兼容C++的\r\n进一步用[FieldOffset]可以指定某个成员相对结构体内存的位置\r\n\r\n具体参考\r\nhttps://msdn.microsoft.com/zh-cn/library/system.runtime.interopservices.structlayoutattribute.aspx", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C#结构体\\类  对等C语言结构体的问题", ["目前在学C/S，服务端用C写的，客户端用C#，服务端现在接受数据用的是结构体，客户端目前只会将数据按顺序排列好放入byte[],然后发送到服务端，看起来简单也方便理解，但是每次数据对齐都很麻烦，请问有木有比较方便的方法？", "\n\n", "C#不是太精通，试过序列化，但是序列化出来的数据貌似很多七七八八的东西比如版本号什么的，显然不能直接放入C语言的结构体中。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体可以嵌套&amp;#xff0c;51行的结构体是没法识别上面两个结构体变量的&amp;#xff0c;你赋值可以直接给值&amp;#xff0c;不能给变量名&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么结构体嵌套结构体会报错", ["请问51行为什么报错，结构体不可以嵌套吗", "请问51行为什么报错，结构体不可以嵌套吗", "请问51行为什么报错，结构体不可以嵌套吗", "请问51行为什么报错，结构体不可以嵌套吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;哈喽&amp;#xff0c;我来告诉你原具体情况&amp;#xff0c;&lt;br /&gt;1&amp;#xff0c;append到q2中的每次的数据和最后打出来的q2确实是不一样的&amp;#xff0c;你没看错&lt;br /&gt;2&amp;#xff0c;最外层循环是两次&amp;#xff0c;每隔两次q2的值会被改一下&amp;#xff0c;改的新值就是最内层循环ls.cc[i].bb &amp;#61; sj的值&amp;#xff0c;i的值每次分别为0,1,2也就是取的i&amp;#61;2时候的值&lt;br /&gt;3&amp;#xff0c;每次执行到最后一次ls.cc[i].bb &amp;#61; sj的时候&amp;#xff0c;看起来是改的ls&amp;#xff0c;实际上连位置为i的q2的值也一块改了&amp;#xff1b;并且q1v和q2是同步修改的&amp;#xff0c;改ls时q1v跟着改&amp;#xff1b;&lt;br /&gt;4&amp;#xff0c;实际上最终q2里的值都是q1v的每次最新值&amp;#xff0c;那么到这里原因就浮现了&amp;#xff0c;第二层循环每进行一次都把最新的q1v赋给了ls变量&amp;#xff0c;换句话说&amp;#xff0c;代码里的ls实际上意义不大&amp;#xff0c;有和没有效果一样(q2直接拼接q1v的值也是这个结果)&lt;br /&gt;&amp;#61;&amp;#61;&amp;#61;&amp;gt;&lt;strong&gt;q2每次拼接的对象地址和ls在最内层循环最后一次修改的值都在同一个地址&amp;#xff0c;因此q2跟着改了&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;最后&amp;#xff0c;可以把number :&amp;#61; 0 调整到第二和第三层循环之间就看得比较清楚了&lt;br /&gt;如果想要每次加的值和最终q2元素相同&amp;#xff0c;可以这么改&amp;#xff1a;&lt;br /&gt;func main() {&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    q2 :&amp;#61; make([]A, 0)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    q1 :&amp;#61; []A{&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        {aa: 1, ab: &amp;#34;1&amp;#34;, cc: []B{&lt;!-- --&gt;{ba: 1}, {ba: 2}, {ba: 3}}},&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        {aa: 2, ab: &amp;#34;2&amp;#34;, cc: []B{&lt;!-- --&gt;{ba: 1}, {ba: 2}, {ba: 3}}},&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for _, q1v :&amp;#61; range q1 { // 2次&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        for _, iv2 :&amp;#61; range []string{&amp;#34;11&amp;#34;, &amp;#34;22&amp;#34;} { // 2次&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            ls,number  :&amp;#61; &amp;amp;A{aa: q1v.aa, ab: q1v.ab, cc: make([]B, 3)},0&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            for i :&amp;#61; range q1v.cc { // 3次&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                number &amp;#43;&amp;#61; 1&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                sj :&amp;#61; iv2 &amp;#43; &amp;#34;----&amp;#34; &amp;#43; strconv.Itoa(number)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                ls.cc[i].ba &amp;#61; q1v.cc[i].ba&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                ls.cc[i].bb &amp;#61; sj&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            fmt.Printf(&amp;#34;加入临时值:%&amp;#43;v\\n&amp;#34;, ls)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            q2 &amp;#61; append(q2, *ls)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for _, a :&amp;#61; range q2 {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        fmt.Printf(&amp;#34;输出:%&amp;#43;v\\n&amp;#34;, &amp;amp;a)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    //fmt.Printf(&amp;#34;s%&amp;#43;v&amp;#34;,q2)&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;如果解决了疑问&amp;#xff0c;欢迎采纳哦&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["go 多重循环中对结构体切片append 最后结果和预期不一致", ["问题遇到的现象和发生背景", "\n", "go 多重循环中对结构体切片append 最后结果和预期不一致", "\n", "问题相关代码，请勿粘贴截图", "\n", "package main\n\nimport (\n    ", "\"fmt\"", "\n    _ ", "\"github.com/mattn/go-oci8\"", "\n    ", "\"strconv\"", "\n    _ ", "\"test-app/internal/packed\"", "\n)\n\n", "type", " A struct {\n    aa ", "int", "\n    ", "ab", " ", "string", "\n    ", "cc", " []B\n}\n", "type", " B struct {\n    ", "ba", " ", "int", "\n    bb ", "string", "\n}\nfunc main() {\n    var q1 []A\n\n    q2:=", "make", "([]A,", "0", ")\n    q1=[]A{{", "a", "a:1", ",", "ab", ":", "\"1\"", ",", "cc", ":[]B{{", "ba", ": ", "1", "},{", "ba", ": ", "2", "},{", "ba", ": ", "3", "}}},{", "a", "a:2", ",", "ab", ":", "\"2\"", ",", "cc", ":[]B{{", "ba", ": ", "1", "},{", "ba", ": ", "2", "},{", "ba", ": ", "3", "}}}}\n    ", "number", ":=", "0", "\n    ", "for", " _, q1v := ", "range", " q1 {\n        ", "x", ":=[]", "string", "{", "\"11\"", ",", "\"22\"", "}\n        ", "for", " _, iv2 := ", "range", " ", "x", " {\n            ", "ls", ":=q1v\n            ", "for", " i, _ := ", "range", " ", "ls", ".", "cc", " {\n                ", "number", "+=", "1", "\n                sj:=iv2 +", "\"----\"", "+strconv.Itoa(", "number", ")\n                ", "ls", ".", "cc", "[i].bb=sj\n            }\n            fmt.Printf(", "\"加入临时值:%+v\\n\"", ",", "ls", ")\n            q2=", "append", "(q2,", "ls", ")\n        }\n\n    }\n    ", "for", " _, ", "a", " := ", "range", " q2 {\n        fmt.Printf(", "\"输出:%+v\\n\"", ",", "a", ")\n    }\n    //fmt.Printf(", "\"s%+v\"", ",q2)\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "可以看出最后输出的和加入临时值的时候并不一样", "\n", "我的解答思路和尝试过的方法", "\n", "没找到解决方案", "\n", "我想要达到的结果", "\n", "最后输出的结果和 加入临时值一致"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;struct book\n\n{\n int id;\n\n char name[30];\n\n char author[20];\n\n char publish[20];\n\n int store;\n\n int total;\n\n char user[10];\n\n char days[90];\n\n}books[100];\n\nvoid savebooks()\n{\n    FILE *fp;\n    fp &amp;#61; fopen(&amp;#34;books.txt&amp;#34;,&amp;#34;r&amp;#34;);\n    if(fp &amp;#61;&amp;#61; NULL)\n        return;\n    for(int i&amp;#61;0;i&amp;lt;100;i&amp;#43;&amp;#43;)\n    {\n        fprintf(fp,&amp;#34;%d\\t%s\\t%s\\t%s\\t%d\\t%d\\t%s\\t%s\\n&amp;#34;,books[i].num,books[i].name,books[i].author,books[i].publish,books[i].store,books[i].total,books[i].user,books[i].days);\n\n    }\n    fclose(fp);\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;最后两个成员user和days应该也是char 数组吧&amp;#xff1f;为什么是int数组呢&amp;#xff1f;如果确实是&amp;#xff0c;那应该单独用for循环逐个写入&amp;#xff0c;可以用TAB键或者空格分隔&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求把结构体里的数据读写入文件", ["//预处理 ", "\n\n", "#include<stdio.h>  ", "\n\n", "#include<string.h>", "\n\n", "#include<stdlib.h>", "\n\n", "#include<conio.h>", "\n\n", " ", "\n\n", "//定义结构体 ", "\n\n", "struct book", "\n\n", "{", "\n\n", " int id;", "\n\n", " char name[30];", "\n\n", " char author[20];", "\n\n", " char publish[20];", "\n\n", " int store;", "\n\n", " int total;", "\n\n", " int user[10];", "\n\n", " int days[90];", "\n\n", "}books[100];"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;行参名是data&amp;#xff0c;你cin 用的都是date&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["用结构体数组存储数据", ["\n", "void inputCustomer()不变。希望详细讲解代码的错误和改正方法，谢谢各位。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;四个&amp;#xff0c;s[2].c和s[2].b&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["大学C语言结构体，下面程序段中定义的结构体数组有几个元素？要输出第3组数据应使用的语句是什么？", ["\n", "3.", "下面程序段中定义的结构体数组有几个元素？要输出第", "3", "组数据应使用的语句是什么？\n\n解析：\n\n", "#", "include", "<stdio.h>", "\n\n", "int", " ", "main", "(", "void", ")", "\n\n", "{\n\n", "typedef", " ", "struct", " ", "data", "\n\n{ ", "int", " c;\n\n", "int", " b;\n\n}DA;\n\nDA s[]={{", "1", ",", "10", "},{", "2", ",", "20", "},{", "3", ",", "30", "},{", "4", ",", "40", "}};\n\n                                                      ；\n\n", "return", " ", "0", ";\n\n}\n"]], "Tag": "程序设计"}
{"Answer": "fp = fopen(\"student.doc\", \"w\");这句不对，写入doc不能用fopen\r\n改成fp = fopen(\"student.txt\", \"w\");", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言把结构体内容写入文件问题", ["#include", "\n#define m  2", "\nmain(){", "\n    int  i;", "\n    FILE  *fp;", "\ntypedef struct{", "\n    int     year;", "\n    int     month;", "\n    int      day;", "\n}date;", "\n        struct    student{", "\n                            int        number;", "\n                            char    name[20];", "\n                            date     birth;", "\n                    }student1[m];", "\n        fp=fopen(\"student.doc\",\"w\");", "\n        for(i=0;i<m;i++){", "\n        student1[i].number=i;", "\n        scanf(\"%s\",student1[i].name);", "\nscanf(\"%d%d%d\",&(student1[i].birth.year),&(student1[i].birth.month),&(student1[i].birth.day));", "\nfwrite(&(student1[i]),sizeof(struct student),1,fp);", "\n}", "\nfclose(fp);", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用string定义字符串&amp;#xff0c;就不要用scanf了&amp;#xff0c;用cin输入&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于#c++#的问题：结构体数组越界问题#include <bits>", ["结构体数组越界问题", "\n", "\n", "\n", "#include <bits/stdc++.h>", "using namespace std;", "struct Sunshine {", "    string title;", "    long long x;", "};", "\n", "int main() {", "    struct Sunshine sun[1001];", "    int n;", "    scanf(\"%d\",&n);", "    for(int i = 1;i <= n;i++) {", "        scanf(\"%s %lld\",&sun[i].title,&sun[i].x);", "    }", "\n", "long", " ", "long", " q;\n", "scanf", "(", "\"%lld\"", ",&q);\n", "while", "(q--) {\n    ", "int", " a,b;\n    string s;\n    ", "scanf", "(", "\"%d %d %s\"", ",&a,&b,&s);\n    ", "long", " ", "long", " ans = ", "0", ";\n    ", "for", "(", "int", " j = a;j <= b;j++) {\n        ", "if", "(sun[j].title.", "compare", "(s) == ", "0", ") ans += sun[j].x;\n    }\n    ", "printf", "(", "\"%lld\\n\"", ",ans);\n}\n", "\n", "return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;#34;stdio.h&amp;#34;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;#define N 2&lt;/span&gt;\nstruct student{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; id;\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; kaoqun;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; biaoxian;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; zuoye;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; biji;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; sum;\n}stud[N],t;\n\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;N;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个学生信息\\n&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %s&amp;#34;&lt;/span&gt;,&amp;amp;stud[i].id,&amp;amp;stud[i].name);\n        fflush(stdin);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d %d&amp;#34;&lt;/span&gt;,&amp;amp;stud[i].kaoqun,&amp;amp;stud[i].biaoxian,&amp;amp;stud[i].zuoye,&amp;amp;stud[i].biji);\n        stud[i].sum &amp;#61; stud[i].kaoqun*&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;stud[i].biaoxian*&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;stud[i].zuoye*&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;stud[i].biji*&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    \n    //排序\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; - i; j&amp;#43;&amp;#43;){ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按成绩对学生信息进行排序\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (stud[j].sum &amp;gt; stud[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].sum){ &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;整型数字的比较\n                t &amp;#61; stud[j];\n                stud[j] &amp;#61; stud[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                stud[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t;\n            }\n        }\n    }\n    //打印\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号\\t姓名\\t考勤\\t表现\\t作业\\t笔记\\t总分\\t\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, stud[i].id);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\t&amp;#34;&lt;/span&gt;, stud[i].name);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, stud[i].kaoqun);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, stud[i].biaoxian);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, stud[i].zuoye);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, stud[i].biji);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d \\n&amp;#34;&lt;/span&gt;, stud[i].sum);\n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体，定义学生信息结构体student", ["定义学生信息结构体student，包含学号、姓名、学号、性别、手机号、成绩，输入n个学生的信息，并将其打印出来（每行打印一个），按照学生成绩的高低对学生信息进行排序，并输出学生信息。（要求定义以下函数实现相应功能，并在主函数中调用他们）"]], "Tag": "程序设计"}
{"Answer": "结构体虽然分配了空间，但是里面的成员的值是随机的，特别是如果里面有指针的话，如果不初始化而直接访问，则会造成读取非法的内存地址的错误。\r\n\r\n学校里面的学生和专业程序员的区别在于，前者无知因此无畏。你要知道，开发程序中编写初始的代码花费1小时，那么维护这个代码需要3小时，调试代码排除错误需要花6小时。当你维护和调试不规范的代码而花费大量的时间精力的时候，你自然就明白预防性编程，也就是用规范编写代码来杜绝错误隐患，比起少写那么一行代码，有价值得多。", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言中结构体必须要初始化吗？", ["#include<stdio.h>\n#include<stdlib.h>\n\nstruct stu\n{\n    int a;\n    char b;\n    float c;\n    char arr[10];\n};\n\nint main(void)\n{\n    struct stu  st;\n    //memset(st, 0, sizeof(st));\n    printf(\"%d\\n\", st.a);\n\n    return 0;\n}\n", "\n\n", "结构体在使用它时，必须要初始化吗，在声明完变量st后不是已经分配空间了吗？", "\n直接输出其中的st.a为什么不行，虽然其中的只不确定。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You could start with, using &lt;a href=\"http://golang.org/pkg/reflect/#Indirect\" rel=\"nofollow\"&gt;&lt;code&gt;reflect.Indirect()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;val := reflect.ValueOf(myinterface)\nif val.Kind() == reflect.Ptr {\n    val = reflect.Indirect(val)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["从接口去获取指向结构体的指针？", ["\n\n", "Given an interface, how do I obtain a pointer to the underlying value?", "\n\n", "My naive attempt was to use a type assertion like this:", "\n\n", "var mytypeptr *MyType = myinterface.(*MyType)\n", "\n\n", "But I get:", "\n\n", "interface conversion: MyInterface is MyType, not *MyType\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;后面那个括号是全角字符&amp;#xff0c;不会被当成括号处理&amp;#xff0c;当成了变量名的一部分&amp;#xff0c;你仔细看提示&amp;#xff0c;提示未定义的那个东西&amp;#xff0c;带着后括号。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么定义了结构体却说没定义", ["跟着b站江科大教程，可是最后却有这个报错，很不理解。有没有哪位能给解答一下？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;指针的内存分配需要靠new或者malloc才行。不管是一个变量指针还是一个结构体指针或是一个类指针都需要new或这malloc以分配内存。&lt;br /&gt;如果你希望linkstring是一个指针&amp;#xff0c;可通过类似以下方式实现&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;snode&lt;/span&gt;\n{\n  node *head,*rear;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n  snode *linkstring&amp;#xff1b;    &lt;span class=\"hljs-comment\"&gt;//定义指针&lt;/span&gt;\n  linkstring &amp;#61; (snode*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(snode));  &lt;span class=\"hljs-comment\"&gt;//分配内存&lt;/span&gt;\n  &lt;span class=\"hljs-built_in\"&gt;init_string&lt;/span&gt;(linkstring);    &lt;span class=\"hljs-comment\"&gt;//最后再使用指针&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["请问一下大家结构体命名加'*'和不加'*'的区别在哪里", ["\n", "想问一下结构体这部分，加'*'就相当于是命名了一个结构体指针，所以按上图我开始是这么写的", "\n", "typedef struct ", "node", "\n", "{\n  int", " data[length];\n  struct ", "node", "*next", ";\n}", "node", ";\ntypedef", " struct snode\n{\n  ", "node", " ", "*head", ",*rear;\n}*linkstring;\n//然后我在初始化的时候就这样子写\nbool init_string(linkstring &s)\n{\n  s->", "head=", "s->", "rear=", "(", "node", "*)malloc", "(sizeof(", "node", "));\n  s-", ">rear->", "next=", "NULL;  \n}\n", "\n", "然后编译出来就会显示内存冲突，我把他改成像图中一样的普通的结构体类型，编译又可以通过了，所以想问一下这个是为什么呢？是因为指针不能这样子分配内存吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; no;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age;\n    student* next;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt; si;\n        cin &amp;gt;&amp;gt; si.no;\n        cin &amp;gt;&amp;gt; si.name;\n        cin &amp;gt;&amp;gt; si.age;\n    cout &amp;lt;&amp;lt; si.no;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["怎么将键盘输入的数据输入到结构体中c++", ["不会用所学的知识，把键盘中的数据输入到结构体中", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "student", " \n{\n    ", "int", " no;\n    ", "char", " name [", "6", "];\n    ", "int", " age;\n    student *next;\n};\n", "int", " ", "main", "()", "\n", "{\n", "int", " x;\ncin>>x;\n", "for", "(", "int", " si=", "0", ";si<x;si++)\n{\n    ", "struct", " ", "student", " si;\n    cin>>si.no;\n    cin>>si.name;\n    cin>>si.age;\n}\ncout<<s3.no;\n    ", "return", " ", "0", ";\n}\n\n", "\n", "以上是简单测试了一下，程序报错，是不是要用什么函数啊", "求解，我会的的知识可能不是太多，请多多指教，感谢！"]], "Tag": "程序设计"}
{"Answer": "gets(Math.name)是什么鬼，根本没存到组里面去啊，名字。应该是Math[i].name", "Konwledge_Point": "数据封装——结构体", "Question": ["在结构体数组怎么用gets()输入字符", ["\n\n", "            图中报错了。。。如果使用gets(Math->name)就不会报错，但结构体成员的引用方式可以是\"结构体变量名 . 成员名\"啊。\n\n            如果使用gets(Math->name)也有问题!\n\n            [图片说明](https://img-ask.csdn.net/upload/201809/27/1538042738_555785.png)\n\n            我搜了一下加了个fflush(stdin)但是还有问题\n\n            ![图片说明](https://img-ask.csdn.net/upload/201809/27/1538044791_900762.png)\n\n            书上输入名字用的是scanf,我想换一种。\n            求救！\n"]], "Tag": "程序设计"}
{"Answer": "感觉题主很像我刚学C语言的时候，有问题不知该怎么办\r\n下面是我的解决方案\r\n\r\n```\r\n //头文件没有包\r\n#include &lt;stdio.h&gt;\r\ntypedef struct Lnode List;\r\n//你这里typedef 类型重定义为 List 后面用的是list\r\nstruct Lnode{\r\n  int a[100];\r\n  int length;\r\n\r\n};\r\nint sequentialSearch(List* tb1,int k);\r\nint main(void)\r\n{\r\n  int n,key;\r\n  scanf(\"%d\",&amp;n);\r\n  //定义一个 List\r\n  List tb1;\r\n\r\n  //输入你要查找的值\r\n  scanf(\"%d\",&amp;key);\r\n\r\n  for(int i = 0 ; i &lt; n ; i++)\r\n  {\r\n    //这块应该是循环输入\r\n    scanf(\"%d\",&amp;(tb1.a[i]));\r\n  }\r\n\r\n  //1.这里\"\"后面缺少,\r\n  //2.函数参数类型为List类型\r\n  printf(\"%d \",sequentialSearch(&amp;tb1,key));\r\n} \r\n\r\nint sequentialSearch(List* tb1,int k){\r\n  int i;\r\n  tb1-&gt;a[0] = k;\r\n  for(i = tb1-&gt;length; i &gt; 0 &amp;&amp;tb1-&gt;a[i] != k;i--)\r\n    ;\r\n  return i;\r\n}\r\n\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言“结构体”一直报错", ["按照网课输入下列代码，一直报错。", "\n看起来应该是 结构体 部分有错", "\n但是网课的代码就这么写的……", "\n求问大家怎么修改！", "\n#include", "\ntypedef struct Lnode *List;", "\nstruct Lnode{", "\n    int a[100];", "\n    int length;", "\n};", "\nint sequentialSearch(list tb1,int k);", "\nint main(void)", "\n{", "\n    int n,key;", "\n    int a[100];", "\n    scanf(\"%d\",&n);", "\n    for(int i = 0 ; i < n ; i++)", "\n        scanf(\"%d\",&a[i]);", "\n    scanf(\"%d\",&key);", "\n    printf(\"%d \"sequentialSearch(a,key));", "\n} ", "\nint sequentialSearch(list tb1,int k){", "\n    int i;", "\n    tb1->a[0] = k;", "\n    for(i = tb1->length; &&tb1->a[i] != k;i--)", "\n        ;", "\n        return i;", "\n}", "\n\n", "\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "定义两个以这个结构体为类型的指针变量，分别指向前驱后继的节点", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中结构体名字加变量是什么意思？", ["#include", "\n\n", "class OutOfBound {};", "\n\n", "using namespace std;", "\ntemplate ", "\nclass linkList : public list", "\n{", "\nprivate:", "\n    struct node {", "\n        elemType  data;", "node *prev, *next;", "\n        node(const elemType &x, node *p = NULL, node *n = NULL)", "\n        {", "\n            data = x; next = n; prev = p;", "\n        }", "\n        node() :next(NULL), prev(NULL) {}", "\n        ~node() {}", "\n    };", "\n    node  *head, *tail;", "\n}", "\n以上的斜体加粗是什么意思，是指定义什么类型的指针啊。。初学.."]], "Tag": "程序设计"}
{"Answer": "http://www.2cto.com/kf/201312/261194.html\r\n把 ElemType 换成Student", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言建立一个结构体索引", ["定义了一个学生信息结构体，怎么建立一个链表实现以Sno学生学号为索引，把一个学生的信息关联起来作为一个整体，实现对这一个学生信息的增删查找？", "\n\n", " struct Student         //定义基本表——Student\n{\n    long long int Sno;      //学生学号\n    char Sname[20];    //学生姓名\n    char Ssex[6];      //学生性别\n    int Sage;          //学生年龄\n    char Sdept[15];    //学生所在系\n    STUDENT_DEF *next;\n};\n\n"]], "Tag": "程序设计"}
{"Answer": "使用前置声明，并且在Line里使用point的指针类型\r\n\r\n```\r\n #include&lt;stdio.h&gt;\r\n \r\nstruct point;\r\nstruct Line\r\n{\r\n    char start;\r\n    char end;\r\n    char L;\r\n    char R;\r\n    point *p1;\r\n};\r\nstruct point\r\n{\r\n    Line l1;\r\n    Line l2;\r\n    Line l3;\r\n    int k;\r\n};\r\n \r\nvoid main()\r\n{\r\n \r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体成员定义求助大神！！", ["int main()", "\n{", "\n    struct Line", "\n    {", "\n        char start;", "\n        char end;", "\n        char L;", "\n        char R;", "\n    };", "\n    struct point", "\n    {", "\n        Line l1;", "\n        Line l2;", "\n        Line l3;", "\n        int k;", "\n    };", "\n我想把Line类型中的成员定义成point类型，怎么实现呢？？？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;math.h&amp;gt;\nstruct point\n{\n\tdouble x,y;\n};\n\nstruct circle\n{\n\tpoint center;\n\tdouble radius;\n};\n\nint main()\n{\n\tcircle c1,c2;\n\tdouble disCent;\n\tprintf(&amp;#34;请输入圆1的中心点和半径:&amp;#34;);\n\tscanf(&amp;#34;%lf %lf %lf&amp;#34;,&amp;amp;c1.center.x,&amp;amp;c1.center.y,&amp;amp;c1.radius);\n\tprintf(&amp;#34;请输入圆2的中心点和半径:&amp;#34;);\n\tscanf(&amp;#34;%lf %lf %lf&amp;#34;,&amp;amp;c2.center.x,&amp;amp;c2.center.y,&amp;amp;c2.radius);\n\n\tdisCent &amp;#61; sqrt((c1.center.x - c2.center.x)* (c1.center.x - c2.center.x)&amp;#43;(c1.center.y - c2.center.y)* (c1.center.y - c2.center.y));\n\n\tif (disCent &amp;gt; c1.radius &amp;#43; c2.radius)\n\t{\n\t\tprintf(&amp;#34;外离\\n&amp;#34;);\n\t}else if (disCent &amp;#61; c1.radius &amp;#43; c2.radius)\n\t{\n\t\tprintf(&amp;#34;外切\\n&amp;#34;);\n\t}else if ( abs(c1.radius - c2.radius) &amp;#61;&amp;#61; disCent)\n\t{\n\t\tprintf(&amp;#34;内切\\n&amp;#34;);\n\t}else if (disCent &amp;lt; c1.radius &amp;#43; c2.radius &amp;amp;&amp;amp; disCent &amp;gt; abs(c1.radius-c2.radius))\n\t{\n\t\tprintf(&amp;#34;相交\\n&amp;#34;);\n\t}else\n\t\tprintf(&amp;#34;内含&amp;#34;);\n\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求C语言题目！谢谢\n\n定义一个表示平面上点的结构体类型point，包括两个实数型\n成员，分别为点的x", ["求C语言题目！谢谢\n\n定义一个表示平面上点的结构体类型point，包括两个实数型\n成员，分别为点的x坐标和y坐标：再定义表示平面上圆的结构体类型，包括两个成员，分别为圆心(point结构体类型)和半径(实数型)。从键盘输入两个圆的数据，并判定两圆位置关系(外离、外切、相交、内切或内含)。"]], "Tag": "程序设计"}
{"Answer": "http://www.jb51.net/article/41177.htm", "Konwledge_Point": "数据封装——结构体", "Question": ["C#中如何调用由Delphi 7.0创建的dll，数据结构体的约定怎么写？", ["C#中如何调用由Delphi 7.0创建的dll，数据结构体的约定怎么写？"]], "Tag": "程序设计"}
{"Answer": "我觉着这个是数组越界导致的，刚才我测试了一下，结构体里面存放的变量地址是连续的，看下面的图；\r\n起初你定义了一个sb[5]，这个数组可以存放5个元素，但是我们知道存放字符串的时候，字符数组最后一个要存放\\0以表示结束，\r\n但上面实例，你存放了12345这5个元素已经占满了数组空间，所以无法存放\\0结束符，在输出的时候该数组无法结束，\r\n所以将会顺着地址一直往下输出，直到遇见\\0结束输出，所以我们平时我们字符数组存放字符串的时候都是多开辟一个空间来存放\\0结束符，\r\n希望这个答案能帮到你。\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201906/05/1559740129_747371.png)", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中字符串的输入输出", ["#include<stdio.h>\n\nint main(void)\n{\n    struct message\n    {\n        char sb[5];\n        char name[10];\n        int score;\n    };\n    int n;\n    int i;\n    scanf(\"%d\",&n);\n    struct message stu[n];\n    for(i=0;i<n;i++)\n    {\n        scanf(\"%s %s %d\",stu[i].sb,stu[i].name,&stu[i].score);\n        printf(\"%s %s\\n\",stu[i].name,stu[i].sb);\n    }\n    return 0;\n}\n", "\n\n", "\n结果和数组大小有关系，这是什么情况？，求大佬解答（卑微）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;使用循环遍历结构体数组&amp;#xff0c;再定义一个变量获取值&amp;#xff0c;再做比较。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体数组中元素的比较", ["定义一个结构体数组，结构体里面有整型成员，比较数组的各个元素是否相同，"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nstruct j {\r\n\tint arr[5] = {1,2,3,4,5};\r\n}n[10];\r\nint main() {\r\n\tchar x = 'a';\r\n\tscanf(\"%c\", &amp;x);\r\n\tprintf(\"%d\", n[0].arr[x - 'a']);\r\n\treturn 0;\r\n}\r\n\r\n```\r\n\r\n```\r\n#include&lt;iostream&gt;\r\n#include&lt;map&gt;\r\nusing namespace std;\r\nstruct j {\r\n\tmap&lt;char, int&gt; mp;\r\n}n[10];\r\nint main() {\r\n\tchar x = 'a';\r\n\tscanf(\"%c\", &amp;x);\r\n\tprintf(\"%d\", n[0].mp[x]);\r\n\treturn 0;\r\n}\r\n\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["如何通过变量访问结构体成员", ["如何通过变量访问结构体成员，如代码：", "\n\n", "struct j{\n    int a,b,c,d,e;\n}n[10]\nint main(){\n    char x[1]=\"/0\";\n    scanf(\"%c\",&x[0]);\n    //然后我想用x这个字符里的字符去访问j里的变量，比如x=\"a\",那么就访问n[i].a,别用判断结构（if,case,switch）因为我要用链表\n}\n", "\n\n", "我本人穷的一匹，求", "\n#大佬", "帮助"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Not directly, no. You can freely convert between &lt;em&gt;identical types&lt;/em&gt; only.&lt;/p&gt;\n\n&lt;p&gt;You can get various levels of solutions to this type of problem:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;writing the assignments out yourself (likely the best performance)&lt;/li&gt;\n&lt;li&gt;using reflection to copy from one to the other based on field names&lt;/li&gt;\n&lt;li&gt;something quick-and-dirty like marshalling one type to JSON then unmarshalling to the other type (which is basically using reflection under the hood with a plaintext middleman, so it's even less efficient, but can be done with little work on your part)&lt;/li&gt;\n&lt;/ul&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["当一个结构包含另一个结构时，如何在Go中将其转换为另一个结构？", ["\n\n", "I would like to know if there is easy way to convert from one struct to another in Go when one struct includes the other.", "\n\n", "For example", "\n\n", "type Type1 struct {\n  Field1 int\n  Field2 string\n}\n\ntype Type2 struct {\n  Field1 int\n}\n", "\n\n", "I know that it can be handled like this", "\n\n", "var a Type1{10, \"A\"}\nvar b Type2\nb.Field1 = a.Field1\n", "\n\n", "but if there are many fields, I will have to write numerous assignments. Is there any other way to handle it without multiple assignments?", "\n\n", "In a word, is there anything like ", "b = _.omit(a, 'Field2')", " in javascript?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n \n#define _CRT_SECURE_NO_WARNINGS &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt;&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;fstream&amp;gt;\n#define MAX &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;\nusing namespace std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Preson\n{\npublic:\n    &lt;span class=\"hljs-comment\"&gt;// 保存联系人姓名&lt;/span&gt;\n    void &lt;span class=\"hljs-constructor\"&gt;SetName(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &amp;amp;&lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt; {\n        m_Name &amp;#61; name;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 获取联系人姓名&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;GetName()&lt;/span&gt; {\n        return m_Name;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 保存联系人单位信息&lt;/span&gt;\n    void &lt;span class=\"hljs-constructor\"&gt;SetPostion(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &amp;amp;&lt;span class=\"hljs-params\"&gt;postion&lt;/span&gt;)&lt;/span&gt; {\n        m_Postion &amp;#61; postion;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 获取联系人单位信息&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;GetPostion()&lt;/span&gt; {\n        return m_Postion;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 保存联系人关系信息&lt;/span&gt;\n    void &lt;span class=\"hljs-constructor\"&gt;SetRelation(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &amp;amp;&lt;span class=\"hljs-params\"&gt;relation&lt;/span&gt;)&lt;/span&gt; {\n        m_Relation &amp;#61; relation;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 获取联系人关系&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;GetRelation()&lt;/span&gt; {\n        return m_Relation;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 保存联系人电话号码&lt;/span&gt;\n    void &lt;span class=\"hljs-constructor\"&gt;SetPhone(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &amp;amp;&lt;span class=\"hljs-params\"&gt;phone&lt;/span&gt;)&lt;/span&gt; {\n        m_Phone &amp;#61; phone;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 获取联系人电话号码&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;GetPhone()&lt;/span&gt; {\n        return m_Phone;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 保存联系人QQ&lt;/span&gt;\n    void &lt;span class=\"hljs-constructor\"&gt;SetQQ(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &amp;amp;&lt;span class=\"hljs-params\"&gt;qq&lt;/span&gt;)&lt;/span&gt; {\n        m_QQ &amp;#61; qq;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 获取联系人QQ&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;GetQQ()&lt;/span&gt; {\n        return m_QQ;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 保存联系人邮箱&lt;/span&gt;\n    void &lt;span class=\"hljs-constructor\"&gt;SetEmail(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &amp;amp;&lt;span class=\"hljs-params\"&gt;email&lt;/span&gt;)&lt;/span&gt; {\n        m_Email &amp;#61; email;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 获取联系人邮箱&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;GetEmail()&lt;/span&gt; {\n        return m_Email;\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-comment\"&gt;// 私有成员&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; m_Name;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; m_Postion;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; m_Relation;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; m_Phone;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; m_QQ;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; m_Email;\n};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Addressbooks\n{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Preson presonArray&lt;span class=\"hljs-literal\"&gt;[MAX]&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//保存的数组&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; m_Size;                  &lt;span class=\"hljs-comment\"&gt;//个数&lt;/span&gt;\n};\n \nvoid &lt;span class=\"hljs-constructor\"&gt;ShowMenu()&lt;/span&gt;\n{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t****************************&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  1:添加联系人  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  2:显示联系人  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  3:删除联系人  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  4:查找联系人  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  5:修改联系人  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  6:清空联系人  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  7:写入文件    ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t******  0:退出该系统  ******&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t\\t\\t\\t****************************&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n}\nvoid add&lt;span class=\"hljs-constructor\"&gt;Preson(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;      &lt;span class=\"hljs-comment\"&gt;//添加的函数&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (abs-&amp;gt;m_Size&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;MAX)   &lt;span class=\"hljs-comment\"&gt;//看看是不是满了&lt;/span&gt;\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;通讯录满了&amp;#xff0c;无法再输入了&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        return;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-comment\"&gt;//开始添加了&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入姓名 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        cin &amp;gt;&amp;gt; name;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;abs&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;m_Size&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetName(&lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入电话 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; phone;\n        cin &amp;gt;&amp;gt; phone;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;abs&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;m_Size&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetPhone(&lt;span class=\"hljs-params\"&gt;phone&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入单位 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; postion;\n        cin &amp;gt;&amp;gt; postion;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;abs&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;m_Size&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetPostion(&lt;span class=\"hljs-params\"&gt;postion&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入关系 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; relation;\n        cin &amp;gt;&amp;gt; relation;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;abs&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;m_Size&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetRelation(&lt;span class=\"hljs-params\"&gt;relation&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入Email : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; email;\n        cin &amp;gt;&amp;gt; email;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;abs&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;m_Size&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetEmail(&lt;span class=\"hljs-params\"&gt;email&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入QQ : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; qq;\n        cin &amp;gt;&amp;gt; qq;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;abs&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-identifier\"&gt;m_Size&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetQQ(&lt;span class=\"hljs-params\"&gt;qq&lt;/span&gt;)&lt;/span&gt;;\n        abs-&amp;gt;m_Size&amp;#43;&amp;#43;;           &lt;span class=\"hljs-comment\"&gt;//更新一下&lt;/span&gt;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;添加成功&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n        system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n    }\n}\nvoid show&lt;span class=\"hljs-constructor\"&gt;Person(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;         &lt;span class=\"hljs-comment\"&gt;//显示&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (abs-&amp;gt;m_Size&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)   &lt;span class=\"hljs-comment\"&gt;//判断是否为空&lt;/span&gt;\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;当前记录为空&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; abs-&amp;gt;m_Size; i&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetName()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  电话&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetPhone()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  单位&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetPostion()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  关系&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetRelation()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  Email&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetEmail()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  QQ&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetQQ()&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        }\n    }\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; is&lt;span class=\"hljs-constructor\"&gt;Exist(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//检索联系人是否存在&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; abs-&amp;gt;m_Size; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetName()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;name)\n        {\n            return i;\n        }\n    }\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\nvoid delete&lt;span class=\"hljs-constructor\"&gt;Person(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;           &lt;span class=\"hljs-comment\"&gt;//删除&lt;/span&gt;\n{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要删除的联系人姓名&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n    cin &amp;gt;&amp;gt; name;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; ret &amp;#61; is&lt;span class=\"hljs-constructor\"&gt;Exist(&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ret !&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; ret; i &amp;lt; abs-&amp;gt;m_Size; i&amp;#43;&amp;#43;)  &lt;span class=\"hljs-comment\"&gt;//删除的操作&lt;/span&gt;\n        {\n            abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//数据前移&lt;/span&gt;\n        }\n        abs-&amp;gt;m_Size--;  &lt;span class=\"hljs-comment\"&gt;//更新一下&lt;/span&gt;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;删除成功&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;查无此人&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n}\nvoid find&lt;span class=\"hljs-constructor\"&gt;Person(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;       &lt;span class=\"hljs-comment\"&gt;//查找&lt;/span&gt;\n{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要查找的联系人姓名&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n    cin &amp;gt;&amp;gt; name;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; ret &amp;#61; is&lt;span class=\"hljs-constructor\"&gt;Exist(&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ret !&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {    &lt;span class=\"hljs-comment\"&gt;//打印&lt;/span&gt;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetName()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  电话&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetPhone()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  单位&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetPostion()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  关系&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetRelation()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  Email&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetEmail()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  QQ&amp;#xff1a; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetQQ()&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;查无此人&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n}\nvoid out(Addressbooks* abs)\n{\n    ofstream fp;\n    fp.&lt;span class=\"hljs-keyword\"&gt;open&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;通讯录.txt&amp;#34;&lt;/span&gt;, ios::out);\n    fp &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;电话&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;单位&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;关系&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Email&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;QQ&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; abs-&amp;gt;m_Size; i&amp;#43;&amp;#43;)\n    {\n        fp &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetName()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetPhone()&lt;/span&gt; &amp;lt;&amp;lt;\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetPostion()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetRelation()&lt;/span&gt;\n            &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetEmail()&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;GetQQ()&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    fp.close&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;写入成功&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n}\nvoid modify&lt;span class=\"hljs-constructor\"&gt;Person(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;           &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要修改的联系人姓名&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n    cin &amp;gt;&amp;gt; name;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; ret &amp;#61; is&lt;span class=\"hljs-constructor\"&gt;Exist(&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ret !&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入姓名 &amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        cin &amp;gt;&amp;gt; name;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetName(&lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入电话&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; phone;\n        cin &amp;gt;&amp;gt; phone;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetPhone(&lt;span class=\"hljs-params\"&gt;phone&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入单位&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; postion;\n        cin &amp;gt;&amp;gt; postion;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetPostion(&lt;span class=\"hljs-params\"&gt;postion&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入关系&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; relation;\n        cin &amp;gt;&amp;gt; relation;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetRelation(&lt;span class=\"hljs-params\"&gt;relation&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入Email :&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; email;\n        cin &amp;gt;&amp;gt; email;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetEmail(&lt;span class=\"hljs-params\"&gt;email&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入QQ&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; qq;\n        cin &amp;gt;&amp;gt; qq;\n        abs-&amp;gt;presonArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;ret&lt;/span&gt;]&lt;/span&gt;.&lt;span class=\"hljs-constructor\"&gt;SetQQ(&lt;span class=\"hljs-params\"&gt;qq&lt;/span&gt;)&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;修改成功&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;查无此人&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n}\nvoid clean&lt;span class=\"hljs-constructor\"&gt;Person(Addressbooks&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;\n{\n    abs-&amp;gt;m_Size &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;通讯录已清空&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;&lt;span class=\"hljs-comment\"&gt;//直接不让访问了&lt;/span&gt;\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    Addressbooks abs;          &lt;span class=\"hljs-comment\"&gt;//创建结构体变量&lt;/span&gt;\n    abs.m_Size &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;                &lt;span class=\"hljs-comment\"&gt;//初始化一下&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; select &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//供用户选择菜单&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-constructor\"&gt;ShowMenu()&lt;/span&gt;;\n        cin &amp;gt;&amp;gt; select;\n        switch (select)\n        {\n        case &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:                         &lt;span class=\"hljs-comment\"&gt;//添加&lt;/span&gt;\n            add&lt;span class=\"hljs-constructor\"&gt;Preson(&amp;amp;&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;;        &lt;span class=\"hljs-comment\"&gt;//记得带 &amp;amp;&lt;/span&gt;\n            break;\n        case &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:                         &lt;span class=\"hljs-comment\"&gt;//显示&lt;/span&gt;\n            show&lt;span class=\"hljs-constructor\"&gt;Person(&amp;amp;&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;;\n            break;\n        case &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:                         &lt;span class=\"hljs-comment\"&gt;//删除&lt;/span&gt;\n            delete&lt;span class=\"hljs-constructor\"&gt;Person(&amp;amp;&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;;\n            break;\n        case &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:                          &lt;span class=\"hljs-comment\"&gt;//查找&lt;/span&gt;\n            find&lt;span class=\"hljs-constructor\"&gt;Person(&amp;amp;&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;;\n            break;\n        case &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;:                         &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n            modify&lt;span class=\"hljs-constructor\"&gt;Person(&amp;amp;&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;;\n            break;\n        case &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;:                          &lt;span class=\"hljs-comment\"&gt;//清空&lt;/span&gt;\n            clean&lt;span class=\"hljs-constructor\"&gt;Person(&amp;amp;&lt;span class=\"hljs-params\"&gt;abs&lt;/span&gt;)&lt;/span&gt;;\n            break;\n        case &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;:\n            out(&amp;amp;abs);\n            break;\n        case &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:                              &lt;span class=\"hljs-comment\"&gt;//退出&lt;/span&gt;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;退出成功&amp;#xff0c;欢迎下次使用&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pasue&amp;#34;&lt;/span&gt;);\n            return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            break;\n        default:\n            break;\n        }\n    }\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++中把结构体变成类", ["\n \n", "#define _CRT_SECURE_NO_WARNINGS 1", "\n", "#include <iostream>", "\n", "#include <string>", "\n", "#include <fstream>", "\n", "#define MAX 1000", "\nusing ", "namespace", " ", "std", ";\nstruct Preson\n{\n    ", "string", " m_Name;\n    ", "string", " m_Postion;\n    ", "string", " m_Relation;\n    ", "string", " m_Phone;\n    ", "string", " m_QQ;\n    ", "string", " m_Email;\n};\nstruct Addressbooks\n{\n    struct Preson presonArray[MAX];    ", "//保存的数组", "\n    ", "int", " m_Size;                  ", "//个数", "\n};\n \n \n", "void", " ShowMenu()\n{\n    cout << ", "\"\\t\\t\\t\\t****************************\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  1:添加联系人  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  2:显示联系人  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  3:删除联系人  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  4:查找联系人  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  5:修改联系人  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  6:清空联系人  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  7:写入文件    ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t******  0:退出该系统  ******\"", " << endl;\n    cout << ", "\"\\t\\t\\t\\t****************************\"", " << endl;\n}\n", "void", " addPreson(Addressbooks* abs)      ", "//添加的函数", "\n{\n    ", "if", " (abs->m_Size == MAX)   ", "//看看是不是满了", "\n    {\n        cout << ", "\"通讯录满了，无法再输入了！\"", " << endl;\n        ", "return", ";\n    }\n    ", "else", "\n    {\n        ", "//开始添加了", "\n        ", "string", " name;\n        cout << ", "\"请输入姓名 : \"", " << endl;\n        cin >> name;\n        abs->presonArray[abs->m_Size].m_Name = name;\n        cout << ", "\"请输入电话 : \"", " << endl;\n        ", "string", " phone;\n        cin >> phone;\n        abs->presonArray[abs->m_Size].m_Phone = phone;\n        cout << ", "\"请输入单位 : \"", " << endl;\n        ", "string", " postion;\n        cin >> postion;\n        abs->presonArray[abs->m_Size].m_Postion = postion;\n        cout << ", "\"请输入关系 : \"", " << endl;\n        ", "string", " relation;\n        cin >> relation;\n        abs->presonArray[abs->m_Size].m_Relation = relation;\n        cout << ", "\"请输入Email : \"", " << endl;\n        ", "string", " email;\n        cin >> email;\n        abs->presonArray[abs->m_Size].m_Email = email;\n        cout << ", "\"请输入QQ : \"", " << endl;\n        ", "string", " qq;\n        cin >> qq;\n        abs->presonArray[abs->m_Size].m_QQ = qq;\n        abs->m_Size++;           ", "//更新一下", "\n        cout << ", "\"添加成功！\"", " << endl;\n        system(", "\"pause\"", ");\n        system(", "\"cls\"", ");\n    }\n}\n", "void", " showPerson(Addressbooks* abs)         ", "//显示", "\n{\n    ", "if", " (abs->m_Size == ", "0", ")   ", "//判断是否为空", "\n    {\n        cout << ", "\"当前记录为空\"", " << endl;\n    }\n    ", "else", "\n    {\n        ", "for", " (", "int", " i = ", "0", "; i < abs->m_Size; i++)\n        {\n            cout << ", "\"姓名： \"", " << abs->presonArray[i].m_Name << ", "\"\\t\"", ";\n            cout << ", "\"  电话： \"", " << abs->presonArray[i].m_Phone << ", "\"\\t\"", ";\n            cout << ", "\"  单位： \"", " << abs->presonArray[i].m_Postion << ", "\"\\t\"", ";\n            cout << ", "\"  关系： \"", " << abs->presonArray[i].m_Relation << ", "\"\\t\"", ";\n            cout << ", "\"  Email： \"", " << abs->presonArray[i].m_Email << ", "\"\\t\"", ";\n            cout << ", "\"  QQ： \"", " << abs->presonArray[i].m_QQ << endl;\n        }\n    }\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n", "int", " isExist(Addressbooks* abs, ", "string", " name)  ", "//检索联系人是否存在", "\n{\n    ", "for", " (", "int", " i = ", "0", "; i < abs->m_Size; i++)\n    {\n        ", "if", " (abs->presonArray[i].m_Name == name)\n        {\n            ", "return", " i;\n        }\n    }\n    ", "return", " -", "1", ";\n}\n", "void", " deletePerson(Addressbooks* abs)           ", "//删除", "\n{\n    cout << ", "\"请输入要删除的联系人姓名：\"", " << endl;\n    ", "string", " name;\n    cin >> name;\n    ", "int", " ret = isExist(abs, name);\n    ", "if", " (ret != -", "1", ")\n    {\n        ", "for", " (", "int", " i = ret; i < abs->m_Size; i++)  ", "//删除的操作", "\n        {\n            abs->presonArray[i] = abs->presonArray[i + ", "1", "];  ", "//数据前移", "\n        }\n        abs->m_Size--;  ", "//更新一下", "\n        cout << ", "\"删除成功！\"", " << endl;\n    }\n    ", "else", "\n    {\n        cout << ", "\"查无此人\"", " << endl;\n    }\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n", "void", " findPerson(Addressbooks* abs)       ", "//查找", "\n{\n    cout << ", "\"请输入要查找的联系人姓名：\"", " << endl;\n    ", "string", " name;\n    cin >> name;\n    ", "int", " ret = isExist(abs, name);\n    ", "if", " (ret != -", "1", ")\n    {    ", "//打印", "\n        cout << ", "\"姓名： \"", " << abs->presonArray[ret].m_Name << ", "\"\\t\"", ";\n        cout << ", "\"  电话： \"", " << abs->presonArray[ret].m_Phone << ", "\"\\t\"", ";\n        cout << ", "\"  单位： \"", " << abs->presonArray[ret].m_Postion << ", "\"\\t\"", ";\n        cout << ", "\"  关系： \"", " << abs->presonArray[ret].m_Relation << ", "\"\\t\"", ";\n        cout << ", "\"  Email： \"", " << abs->presonArray[ret].m_Email << ", "\"\\t\"", ";\n        cout << ", "\"  QQ： \"", " << abs->presonArray[ret].m_QQ << endl;\n    }\n    ", "else", "\n    {\n        cout << ", "\"查无此人\"", " << endl;\n    }\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n \n", "void", " out(Addressbooks* abs)\n{\n    ofstream fp;\n    fp.open(", "\"通讯录.txt\"", ", ios::out);\n    fp << ", "\"姓名\"", " << ", "\"\\t\"", " << ", "\"电话\"", " << ", "\"\\t\"", " << ", "\"单位\"", " << ", "\"\\t\"", " << ", "\"关系\"", " << ", "\"\\t\"", " << ", "\"Email\"", " << ", "\"\\t\"", " << ", "\"QQ\"", " << endl;\n    ", "for", " (", "int", " i = ", "0", "; i <= abs->m_Size; i++)\n    {\n        fp << abs->presonArray[i].m_Name << ", "\"\\t\"", " << abs->presonArray[i].m_Phone <<\n            ", "\"\\t\"", " << abs->presonArray[i].m_Postion << ", "\"\\t\"", " << abs->presonArray[i].m_Relation\n            << ", "\"\\t\"", " << abs->presonArray[i].m_Email << ", "\"\\t\"", " << abs->presonArray[i].m_QQ << endl;\n    }\n    fp.close();\n    cout << ", "\"写入成功\"", " << endl;\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n \n", "void", " modifyPerson(Addressbooks* abs)           ", "//修改", "\n{\n    cout << ", "\"请输入要修改的联系人姓名\"", " << endl;\n    ", "string", " name;\n    cin >> name;\n    ", "int", " ret = isExist(abs, name);\n    ", "if", " (ret != -", "1", ")\n    {\n        ", "string", " name;\n        cout << ", "\"请输入姓名 ：\"", " << endl;\n        cin >> name;\n        abs->presonArray[ret].m_Name = name;\n        cout << ", "\"请输入电话：\"", " << endl;\n        ", "string", " phone;\n        cin >> phone;\n        abs->presonArray[ret].m_Phone = phone;\n        cout << ", "\"请输入单位：\"", " << endl;\n        ", "string", " postion;\n        cin >> postion;\n        abs->presonArray[ret].m_Postion = postion;\n        cout << ", "\"请输入关系：\"", " << endl;\n        ", "string", " relation;\n        cin >> relation;\n        abs->presonArray[ret].m_Relation = relation;\n        cout << ", "\"请输入Email :\"", " << endl;\n        ", "string", " email;\n        cin >> email;\n        abs->presonArray[ret].m_Email = email;\n        cout << ", "\"请输入QQ：\"", " << endl;\n        ", "string", " qq;\n        cin >> qq;\n        abs->presonArray[ret].m_QQ = qq;\n        cout << ", "\"修改成功！\"", " << endl;\n    }\n    ", "else", "\n    {\n        cout << ", "\"查无此人\"", " << endl;\n    }\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n", "void", " cleanPerson(Addressbooks* abs)\n{\n    abs->m_Size = ", "0", ";\n    cout << ", "\"通讯录已清空！\"", " << endl;", "//直接不让访问了", "\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n", "int", " main()\n{\n    Addressbooks abs;          ", "//创建结构体变量", "\n    abs.m_Size = ", "0", ";                ", "//初始化一下", "\n    ", "int", " select = ", "0", ";  ", "//供用户选择菜单", "\n    ", "while", " (", "true", ")\n    {\n        ShowMenu();\n        cin >> select;\n        ", "switch", " (select)\n        {\n        ", "case", " ", "1", ":                         ", "//添加", "\n            addPreson(&abs);        ", "//记得带 &", "\n            ", "break", ";\n        ", "case", " ", "2", ":                         ", "//显示", "\n            showPerson(&abs);\n            ", "break", ";\n        ", "case", " ", "3", ":                         ", "//删除", "\n            deletePerson(&abs);\n            ", "break", ";\n        ", "case", " ", "4", ":                          ", "//查找", "\n            findPerson(&abs);\n            ", "break", ";\n        ", "case", " ", "5", ":                         ", "//修改", "\n            modifyPerson(&abs);\n            ", "break", ";\n        ", "case", " ", "6", ":                          ", "//清空", "\n            cleanPerson(&abs);\n            ", "break", ";\n        ", "case", " ", "7", ":\n            out(&abs);\n            ", "break", ";\n        ", "case", " ", "0", ":                              ", "//退出", "\n            cout << ", "\"退出成功，欢迎下次使用！\"", " << endl;\n            system(", "\"pasue\"", ");\n            ", "return", " ", "0", ";\n            ", "break", ";\n        ", "default", ":\n            ", "break", ";\n        }\n    }\n    system(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "把结构体变成类 最好有详细的注释（体谅一下小白）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这些都是分配在堆种。&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;当你有一个独立的结构体&amp;#xff0c;并定义一个局部变量&amp;#xff0c;它分配在栈上。比如&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;struct A\n{\n    int member;\n    // more members\n};\n\n\nclass B\n{\n    public void f()\n    {\n        A a; // allocated on stack\n        // ....\n    }\n};\n\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;这里有一篇文章图示了类和结构内训分布以及性能方面的比较&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;https://medium.com/csharp-architects/whats-faster-in-c-a-struct-or-a-class-99e4761a7b76#:~:text&amp;#61;The%20only%20difference%20between%20these,than%20MeasureTestB%20which%20allocates%20classes!&amp;amp;text&amp;#61;The%20difference%20is%20caused%20by,classes%20are%20stored%20in%20memory.&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C#中结构体中嵌套类 结构体在堆栈中如何分布?", ["\n", " //图像队列类\n    public class ImageArray\n    {\n        //图像队列结构体\n        public struct structImageArray\n        {\n            //图像变量\n            public HObject m_Image;\n            //采图完成标志位：false未采图，true已采图\n            public bool m_bFinished;\n        }\n\n        //把图像写入到图像队列的索引\n        public int m_nWriteIndex=0;\n\n        //从图像队列读取图像的索引\n        public int m_nReadIndex=0;\n\n        //图像队列变量\n        public structImageArray[] m_Array;\n   }", "\n\n", "实例化ImageArray类后 图像队列变量 m_Array在堆还是栈中存放 结构体在堆中还是栈中存放 ?", "\n\n", "如果不是嵌套在类中的结构体 单独声明的结构体 但是结构体中嵌套类 那么结构体中的类在内存中如何存储? ", "\n\n", "结构体的值类型如何理解?如何正确使用结构体的特点提高代码运行效率?"]], "Tag": "程序设计"}
{"Answer": "typedef struct pice\r\n{\r\n\tint stream_Type;\r\n\tunsigned short PID;\r\n\tunsigned short InfoDescrip;\r\n}M_PICE;\r\nM_PICE* pMypice;\r\nint main(){\r\n\tpMypice = (M_PICE*)malloc(sizeof(M_PICE));//此处分配内存空间，否则怎么存数据、\r\n\tpMypice-&gt;InfoDescrip = 0;\r\n\tprintf(\"%d\\n\",pMypice-&gt;InfoDescrip);\r\n\r\n}\r\n赶紧采纳。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体类型的指针初始化和赋值问题", ["编程的时候我定义了一个结构体，结构体有几个变量的值我必须要赋初值，因为循环得用。", "\n结构体这样定义:", "\ntypedef struct", "\n{", "\n    BYTE stream_Type;", "\n    unsigned short PID;", "\n    unsigned short InfoDescrip;", "\n}M_PICE;", "\n用的时候：", "\nM_PICE* p_Mpice = NULL;", "\np_Mpice->InfoDescrip = 0;", "\n运行到上一句就报错", "\nUnhandled exception in DVB.exe:0xC0000005:Access Violation"]], "Tag": "程序设计"}
{"Answer": "不同的编译器的结构体都不兼容。c++和c语言显然不是一个编译器，当然不能保证了。\r\nc/c++语言的规范里并没有规定结构体的内存布局的标准。", "Konwledge_Point": "数据封装——结构体", "Question": ["c++和c语言的结构体是不是兼容的", ["如题，想知道用c语言和c++语言在结构体上的兼容性，也就是说我如果用c语言储存一个结构体并用二进制形式写入文件,用c++成员相同的结构体读取能不能正确读取？", "\n\n", "我在Linux下GNU编译器下测试了一个简单程序，结构体只包括数据成员没有对象成员和函数成员，都是int 和 long和char数组之类的，发现c存储到文件的结构体调用系统接口open  write 和read 在c++下用相同成员的结构体读取正确，我想知道是不是所有编译器和系统下处理都相同？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用容器的push_back方法&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["QVector存储结构体数据时的写入和读出", ["定义了QVector：", "\n", "typedef struct arr{\nint x", ";", "\nint y", ";", "\n}ARR", ";", "\n申明容器的大小：\nQVector<ARR>value[", "100", "]", ";", "\n", "\n", "现在我需要往value[i]（i=0-100）里面加入坐标数据（x,y），怎么加入？加入完之后，我需要从value[i]（i=0-100）里面读出数据，怎么读？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;未初始化变量你可以加上构造函数解决这个警告&amp;#xff0c;如果你加上了大括号&amp;#xff0c;编译器认为你可能要赋值&amp;#xff0c;就不警告了&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体成员变量未初始化问题和解决", ["如题，在定义结构体person和addressbook时结构体中的整型变量警告未初始化变量，这是为什么呢，还有最后加大括号后解决了，这又是为啥呢，此时大括号起的啥作用呢？感谢您的回答！", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "需要修改两点：\r\n1、删除a.h中对c.h的包含，因为a.h包含c.h，c.h又包含a.h，造成循环包含。\r\n2、在main.c中包含c.h。\r\n\r\n修改之前main.c展开如下，部分代码将不参与编译\r\n\r\n\r\n```\r\n#ifndef _a_H\r\n#define _a_H\r\n\r\n#ifndef _c_H\r\n#define _c_H\r\n\r\n#ifndef _a_H\r\n#define _a_H\r\n//以下代码不编译\r\n#include \"c.h\"\r\n typedef struct{\r\n int a;\r\n }A;\r\nextern A my_a;\r\n//以上代码不编译\r\n#endif\r\n\r\nA fun2(A _data);\r\n#endif\r\n\r\n typedef struct{\r\n int a;\r\n }A;\r\nextern A my_a;\r\n#endif\r\n\r\nint main()\r\n{\r\nA Adata;\r\nAdata=fun2(my_a);\r\n\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["keil跨文件调用结构体报错", ["最近学STM32项目遇到问题。我在a.h定义了结构体 typedef  struct{}A 并extern A my_a，在a.c初始化了my_a={参数值}。在c.c中我定义了一个函数 A exp（A _data），c.h中include\"a.h\",然后声明函数 A exp（A _data）（需要在main（）中调用的），这时c.c单独编译通过，但是整体编译生成hex时候就会报APP/c.h(9): error:  #20: identifier A\" is undefined A  A exp（A _data)", "\n真的想不明白  求大佬救助", "\n\n", "main.c", "\n\n", "#include \"a.h\"\nint main()\n{\nA Adata;\nAdata=fun2(my_a);\n\n}\n\n", "\n\n", "a.c", "\n\n", "#include \"a.h\"\n\nA my_a={.a=1};\n", "\n\n", "a.h文件", "\n\n", "#ifndef _a_H\n#define _a_H\n#include \"c.h\"\n typedef struct{\n int a;\n }A;\nextern A my_a;\n#endif\n", "\n\n", "c.c文件", "\n\n", "#include \"c.h\"\nA fun2(A _data)\n{\n\n  return _data;\n}\n", "\n\n", "c.h文件", "\n\n", "#ifndef _c_H\n#define _c_H\n#include \"a.h\"\nA fun2(A _data);\n#endif\n", "\n\n", "错误 .\\app\\c.h(4): error:  #20: identifier \"A\" is undefined", "\n  A fun2(A _data);"]], "Tag": "程序设计"}
{"Answer": "```\r\nstruct DataInfo{\r\n    GLenum       type;\r\n    char*  filename;\r\n    int       note;\r\n    DataInfo(GLenum ptype, const char*  pfilename,int pnote){\r\n        type = ptype;\r\n        strcpy(filename,pfilename);\r\n        note = pnote;\r\n    }\r\n};\r\n/*************************/\r\nDataInfo pain((GLenum)1,\"../texture/red.file\",0);\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["qt 中结构体添加构造函数后报错", ["我定义了一个结构体并添加了构造函数：", "\n\n", "struct DataInfo{\n    GLenum       type;\n    const char*  filename;\n    int       note;\n    DataInfo(){\n        type = 0;\n        filename = nullptr;\n        note = 0;\n    }\n};\n", "\n\n", "但是在初始化一个结构体时：", "\n\n", "DataInfo pain = {1,\"../texture/red.file\",null};\n", "\n\n", "qt报错：could not convert '{1, \"../texture/red.file\"}' from 'brace-enclosed initializer list' to 'ShaderInfo'"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的第二张图里的那个数组是结构体的一个成员。&lt;br /&gt;要定义一个结构体数组&amp;#xff0c;方法类似&amp;#xff1a;itemnode myStruct[10];&lt;br /&gt;要调用结构体成员里面的item数组&amp;#xff0c;方法类似&amp;#xff1a;myStruct[0].item[0][0];&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言数据结构中结构体的定义", ["\n", "那个结构体定义的是数组吗？如果是，那后续调用的时候应该怎么调用数组？"]], "Tag": "程序设计"}
{"Answer": "写一个循环，从txt中读取数据，然后赋值给结构数组，完成初始化，如果数据在txt里面，是无法直接初始化的", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体初始化问题， 定义了结构体和结构体数组，结构体中想存的数据写在了txt文件中，我该怎么做初始化", ["定义了结构体和结构体数组，结构体中想存的数据写在了txt文件中，我该怎么做初始化", "\n//定义结构体//", "\nstruct achievement", "\n{int number;", "\n char name[20];", "\n char sex;", "\n float achievement1,achievement2,achievement3;", "\n}tab_achievement[N];"]], "Tag": "程序设计"}
{"Answer": "http://msdn.microsoft.com/zh-cn/library/hk9wyw21.aspx", "Konwledge_Point": "数据封装——结构体", "Question": ["C# 调用c++函数 结构体 指针", ["求大神解答下，", "\n\n", "c++结构体：", "\ntypedef struct", "\n{", "\n    Byte byIndex;", "\n\n", "Byte byRW;\n", "\n\n", "}PACKET;", "\n\n", "typedef struct", "\n{", "\n    PACKET *pPackets;", "\n\n", "INT32 iNumPackets;\n", "\n\n", "}BLOCK", "\n\n", "c++ 函数申明：", "\nBOOL Transfer(BLOCK block);", "\n\n", "C#如何调用这个Transfer函数：", "\n1：定义C#结构体", "\n     public struct PACKET", "\n    {", "\n         byte byIndex;", "\n         byte byRW;", "\n    }", "\n    那么另个结构体BLOCK在C#中怎么定义？？？", "\n2. 定义完后如何调用（DllImport这个我知道），其他有什么特殊设置？？？？"]], "Tag": "程序设计"}
{"Answer": "while((scanf(\"%s %d %d\",city[i].name,&amp;city[i].x),&amp;city[i].y)!=0) 这句的city[i].x后面怎么有个括号", "Konwledge_Point": "数据封装——结构体", "Question": ["【C语言】结构体数据处理异常问题", ["每个城市信息由城市名（字符串）和位置坐标组成(x,y)。设计实现一程序，完成如下功能：", "\n（1）从键盘或文件输入各城市信息", "\n（2）按城市名字非递减排序后输出", "\n（3）输入某个位置信息，查询该位置的城市名称，要求能多次查询。    ", "\n\n", " #include <stdio.h>\n#include <stdlib.h>\n\n#define MAXSIZE 20\n\ntypedef char ElemType; \nstruct info\n{\n    ElemType name[MAXSIZE];\n    int x;\n    int y;\n};\n\nint main()\n{\n    struct info city[MAXSIZE];\n    //从键盘输入信息\n    int i=0,count=0;\n    printf(\"请输入城市名和位置坐标x,y,以空格键隔开(输入“q 0 0”以结束):\");\n    while((scanf(\"%s %d %d\",city[i].name,&city[i].x),&city[i].y)!=0)\n    {\n        if(i>=MAXSIZE)\n        {\n            printf(\"超出最大输入个数!\");\n            break;\n        }\n        if(strcmp(city[i].name,\"q\")==0)\n         break;\n        i++;\n        count++;\n        printf(\"请输入城市名和位置坐标x,y,以空格键隔开:\");\n    } \n\n    //排序\n    int m,n;\n    struct info temp;\n    for(m=0;m<count-1;m++)\n    {\n        for(n=0;n<count-m-1;n++)\n        {\n            if(strcmp(city[n].name,city[n+1])>0) \n            {\n                temp=city[n];\n                city[n]=city[n+1];\n                city[n+1]=temp;\n            }\n        }\n    }\n\n    //按非递减顺序输出\n    for(i=0;i<count;i++)\n    {\n        printf(\"%s  %d  %d  \\n\",city[i].name,city[i].x,city[i].y);\n    } \n\n\n    //查询\n    int x,y;\n    printf(\"请输入您要查找的位置坐标x,y，之间以空格隔开，以“q q”结束操作:\");\n    while(scanf(\"%d %d\",&x,&y)!=0)\n    {\n        for(i=0;i<count;i++)\n        {\n            if(x==city[i].x&&y==city[i].y)\n             {\n                printf(\"\\n您要查找的城市为 %s \",city[i].name);\n                break;\n             }\n            else if(i==count-1)\n            {\n                printf(\"\\n未找到匹配的城市!\");\n            }\n        }\n    } \n    printf(\"\\n感谢您的使用，再见!\");\n\n    return 0;\n}\n\n", "\n\n", "代码运行正常，排序、查找功能都正常，但输入数据后，输出（打印在屏幕上）的数据坐标y全部变为0，请问这是怎么回事，看了很久没有看出来"]], "Tag": "程序设计"}
{"Answer": "因为第一行输入学生数3之后输入了一个回车，回车会被第一次的gets()读取。\r\n在scanf(\"%d\",&amp;n); 这一行后面加一个 getchar(); 就好了", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体输入的问题~", ["#include", "\n#include", "\nstruct member{", "\n    char name[15];", "\n    char number[15];", "\n};", "\nvoid main(){", "\n    int n,i;", "\n    printf(\"请输入成员个数\");", "\n    scanf(\"%d\",&n);", "\n    struct member mem[n];", "\n  printf(\"请依次输入姓名、电话\\n\");", "\n\n", "for(i=0;i<n;i++){\n    gets(mem[i].name);\n    gets(mem[i].number);\n}\n\n\nprintf(\"请输入姓名\");\nchar temp[15];\ngets(temp);\nif(strlen(temp)==0){\n    for(i=0;i<n;i++){\n        puts(mem[i].name);\n        puts(mem[i].number);\n    }\n}else{\n    for(i=0;i<n;i++){\n        if(strcmp(temp,mem[i].name)==0){\n            puts(mem[i].name);\n            puts(mem[i].number);\n            break;\n        }\n    }\n}\n", "\n\n", "}", "\n\n", "在输入的时候，为什么第一次无法输入的呢", "\n如图只能有五个输入。", "\n有大佬 能解释一下嘛，万分感谢"]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/lethic/article/details/7781203", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ 语言关于结构体的排序的功能", ["结构体由多个字段构成，要求按照先后次序对字段排序，用C++语言实现，怎么才能简单高效可靠"]], "Tag": "程序设计"}
{"Answer": "代码没问题，但你组长的担心也不是凭空的。\r\n如果返回的是局部变量的地址（&amp;a1）的话，程序运行后会出错。因为函数只是把a1的首地址复制后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。\r\n但你这里返回的是局部变量的值（a1），不涉及地址，所以程序不会出错。\r\n如果说你不知道原理的话，还真是运气好了，祝你好运连连！", "Konwledge_Point": "数据封装——结构体", "Question": ["c,c++一个函数返回结构体到底可不可以？", ["今天我遇到另一个问题，在我写的代码里，", "\nvs2015,c++/c 程序", "\n有一个函数，返回一个结构体，", "\n组长说这样是不可以的，", "\n我还和他说我以前写的代码里有返回结构体的，", "\n现在还运行的好好的，这么就不行了，", "\n为此，他还发了火，", "\n想问一下大佬们，返回一个结构体这样到底行不行？", "\n代码简化版贴出来了：", "\n#include", "\n#include", "\n#include", "\n#include", "\n\n", "using namespace std;", "\n#pragma warning(disable:4996)", "\ntypedef struct user_info", "\n{", "\n    char type;", "\n    char name[16];", "\n    char passwd[16];", "\n}INFO;", "\n\n", "INFO get_info(char c)", "\n{", "\n    INFO a1;", "\n    a1.type = 'c';", "\n    strcpy(a1.name, \"abcde\");", "\n    strcpy(a1.passwd, \"123456\");", "\n    return a1;", "\n}", "\n\n", "int main()", "\n{", "\n    INFO n;", "\n    n = get_info('a');", "\n    cout << n.type << endl;", "\n    cout << n.name << endl;", "\n    cout << n.passwd << endl;", "\n    getchar();", "\n    return 1;", "\n}", "\n\n", "说什么你的程序能运行起来算你运气好，说什么局部变量返回会出错，", "\n我就纳闷了，返回int这样的函数", "\nint aaa()", "\n{", "\n    int as;", "\n        as=5;", "\n        return as;", "\n}", "\n难道有错吗？那么返回结构体咋就不对了？", "\nINFO get_info(char c)", "\n{", "\n    INFO a1;", "\n    a1.type = 'c';", "\n    strcpy(a1.name, \"abcde\");", "\n    strcpy(a1.passwd, \"123456\");", "\n    return a1;", "\n}"]], "Tag": "程序设计"}
{"Answer": "c语言中指针和数组有非常紧密的联系，某种意义上说它们是同一个东西。\r\n题目中声明了一个结构体数组: \r\n\r\n```\r\n struct stu s[3]\r\n```\r\n相当于声明了一个指针变量 s ，它指向数组的第一个元素，即：\r\n\r\n\r\n\r\n```\r\n s = &amp;s[0]\r\n```\r\np=s 即 p的初值为&amp;s[0]\r\ns+2 即 &amp;s[2]\r\n\r\n这样for循环中 p 的值从&amp;s[0]到 &amp;s[2]。\r\n再对p进行取值操作，就从s[0]到s[2]。\r\n\r\n\r\n**用心回答每个问题，如果对您有帮助，请采纳答案好吗，谢谢。**", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针for循环判断", ["有struct stu", "\n{", "\nint age;", "\nchar name[10];", "\n...等等", "\n}s[3]={5，“wzw”,....},*p;", "\nfor(p=s;p<s+3;p++)", "\n判断语句是怎么判断的,我知道是一直循环从s[0]到s[2];但他是怎么判断的"]], "Tag": "程序设计"}
{"Answer": "你写进去的只是cstring的地址，并没有把cstring的内容写进去，最简单的的可以把结构体内的cstring改为char类型的数组然后进行你现在的存法，第二种就是写数据时将结构体内的成员变量一个一个的写入，读取时也是一个一个的读取，就可以了", "Konwledge_Point": "数据封装——结构体", "Question": ["C++/MFC中结构体使用CString出现问题", ["我定义了如下结构体：", "\n\n", " struct u\n    {\n\n        CString  sNumber;\n        CString sPass;\n        int PRIOR;\n    };\n", "\n\n", "我在OnDestroy()函数中去将结构体中的三个变量写入到user.dat文件中，但是当我", "\n再次读取文件中数据时，只有int类型的PRIOR有数据，CString类型拿不到数据。打断点的结果是，写入数据时，数据是成功写入的。", "\n\n", " CFile file;//创建一个CFile文件\n    if (!file.Open(_T(\"./user.dat\"),CFile::modeCreate|CFile::modeWrite))//判断是否有文件，return是必须有的\n    {\n        AfxMessageBox(_T(\"保存文件失败\"));\n        return;\n    }\n    CListCtrl *plist = (CListCtrl *)GetDlgItem(IDC_LIST);\n    int i = 0,nCount = plist->GetItemCount();\n    u user;\n    // (int i = 0; i < nCount; i++)\n    while (i<nCount)\n    {\n        user.sNumber = plist->GetItemText(i, 0);\n        user.sPass = plist->GetItemText(i, 1);\n\n        file.Write(&user, sizeof(user));//写入一个结构体\n        ++i;\n\n    }\n\n\n    file.Close();\n    user.PRIOR = plist->GetItemText(i, 2) == _T(\"高级\");\n\n", "\n\n", "我知道可以用char，但是更想使用CString类型。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;单词拼写错误&lt;br /&gt;上面是student&amp;#xff0c;main里写的stduent&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言初始化结构体数组报错", ["用的vs定义结构体数组报错，不允许使用不完整的类型", "报错怎么解决呀，求解，请求帮忙。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对结构体变量属性的赋值要在函数中进行&lt;br /&gt;不能在函数外&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;aa&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;aa&lt;/span&gt; k;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n     k.num &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["keli5中定义好的结构体却使用不了，如何解决？(语言-c语言)", ["\n", "如图所示，结构体语法应该没问题，为啥会报错？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看到你提的这个问题&amp;#xff0c;可能你对结构体不熟悉&amp;#xff0c;或者说你对指针还不熟悉&amp;#xff1b;&lt;br /&gt;int *p&amp;#xff1b;&lt;br /&gt;p &amp;#43; 1 是多少&amp;#xff1f;是p 往后的4个字节&amp;#xff0c;按照 p 的类型移动的。&lt;/p&gt;\n&lt;p&gt;struct structA *p&amp;#xff1b;&lt;br /&gt;p &amp;#43;1 是多少&amp;#xff1f;&lt;br /&gt;移动到下一个结构体内存&amp;#xff0c;如果你这个结构体是12个字节&amp;#xff0c;那么p &amp;#43;1 是跳到 12 字节以后&lt;/p&gt;\n&lt;p&gt;那 怎么指定结构体中的成员&amp;#xff1f;C语言提供了一种方式&amp;#xff0c;-&amp;gt; 和 .  这两个运算符&amp;#xff0c;明白了否&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言定义一个指向结构体首地址的指针，如何表示结构体里的某个字段", ["C语言定义一个指向结构体首地址的指针，如何表示结构体里的某个字段", "\n", "\n", "struct", " ", "structA", "\n{\n", "int", " a;", "//占内存大小4字节", "\n", "int", " b;", "//占内存大小4字节", "\n", "int", " c;", "//占内存大小4字节", "\n", "float", " d;", "//占内存大小4字节", "\n", "uint32_t", " e;", "//占内存大小4字节", "\n} test,*testPtr\n\n", "\n", "定义一个指针aPtr指向存这个结构体的内存块首地址，如何表示e这个字段？", "\n", "我的想法是（*aPtr+12） ，C语言只会一点入门知识，不确定，希望有人解答", "\n"]], "Tag": "程序设计"}
{"Answer": "`scanf`这个函数要求使用变量的地址，而变量`name`是一个数组，数组的名字代表了数组的地址，所以不用使用`&amp;`这个取地址的操作符了", "Konwledge_Point": "数据封装——结构体", "Question": ["关于scanf输入到结构体中时不用&的问题", ["有一个结构体", "\nstruct student", "\n{", "\n            long num;", "\n            char name[20];", "\n}zhao;", "\n输入数据时是这样：", "\nscanf(\"%s\",zhao.name);  //这里为什么没有&了？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没看逻辑&amp;#xff0c;错误好像是因为上一次循环fHead&amp;#61;fHead-&amp;gt;tailLink把fHead赋值为NULL了&amp;#xff0c;结果在该次while循环的条件判断中调用了fHead-&amp;gt;headVex导致了空指针异常&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么给结构体指针赋值失败", ["我想写一个十字链表（有向图），但是遇到了无法给结构体指针赋值的问题。", "\n\n", "\n", "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXVEX 100\n\nstruct edgeNode                      //边表结点\n{\n\tint tailVex, headVex;\n\tedgeNode *tailLink, *headLink;\n};\n\nstruct vertexNode                    //顶点表结点\n{\n\tint data;\n\tedgeNode *firstIn, *firstOut;\n};\n\nstruct graph_OL                     //十字链表结构\n{\n\tvertexNode OLList[MAXVEX];\n\tint numVertexes;\n};\n\nvoid createOLGraph(graph_OL* g)     //生成一个十字链表\n{\n\tprintf(\"请输入结点数：\");\n\tscanf(\"%d\", &g->numVertexes);\n\tsetbuf(stdin, NULL);\n\n\tfor (int i = 0; i < g->numVertexes; i++)\n\t{\n\t\tprintf(\"请输入结点的值：\");\n\t\tscanf(\"%d\", &g->OLList[i].data);\n\t\tsetbuf(stdin, NULL);\n\t}\n\n\tprintf(\"构造十字链表的出度链：\\n\");\n\tfor (int i = 0; i < g->numVertexes; i++)           //连接每一个结点的弧尾\n\t{\n\t\tint tTail;\n\t\tedgeNode* p = g->OLList[i].firstOut;\n\t\tedgeNode *tEdgeNode;\n\t\tint flag = 1;\n\t\tprintf(\"第%d个结点的出度链：\\n\", i);\n\t\tif (p)\n\t\t{\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tprintf(\"请输入一个弧尾，-1表示输完了所有的弧尾：\");\n\t\t\t\tscanf(\"%d\", &tTail);\n\t\t\t\tsetbuf(stdin, NULL);\n\t\t\t\tif (tTail == -1)\n\t\t\t\t{\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tg->OLList[i].firstOut = NULL;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp->tailLink = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttEdgeNode = (edgeNode*)malloc(sizeof(edgeNode));\n\t\t\t\t\tif (tEdgeNode)\n\t\t\t\t\t{\n\t\t\t\t\t\ttEdgeNode->headVex = i;\n\t\t\t\t\t\ttEdgeNode->tailVex = tTail;\n\t\t\t\t\t\tif (flag)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tg->OLList[i].firstOut = tEdgeNode;\n\t\t\t\t\t\t\tp = tEdgeNode;\n\t\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp->tailLink = tEdgeNode;\n\t\t\t\t\t\t\tp = tEdgeNode;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"构造十字链表的入度链：\\n\");\n\tfor (int i = 0; i < g->numVertexes; i++)     //连接每一个链表的弧头\n\t{\n\t\tint tIn;\n\t\tedgeNode* tHead = g->OLList[i].firstIn;\n\t\tedgeNode* fHead = NULL;\n\t\tint flag = 1;\n\t\tprintf(\"第%d个结点的入度链：\\n\", i);\n\t\twhile (1)\n\t\t{\n\t\t\tprintf(\"请输入一个弧头，-1表示输完了所有的弧头：\");\n\t\t\tscanf(\"%d\", &tIn);\n\t\t\tsetbuf(stdin, NULL);\n\t\t\tif (tIn == -1)\n\t\t\t{\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tg->OLList[i].firstIn = NULL;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttHead->tailLink = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfHead = g->OLList[tIn].firstOut;\n\t\t\t\tif (fHead)\n\t\t\t\t{\n\t\t\t\t\twhile (fHead->headVex != i)     //此处提示fHead是nullptr\n\t\t\t\t\t{\n\t\t\t\t\t\tfHead = fHead->tailLink;\n\t\t\t\t\t}\n\t\t\t\t\tif (flag)\n\t\t\t\t\t{\n\t\t\t\t\t\tg->OLList[i].firstIn = fHead;\n\t\t\t\t\t\ttHead = fHead;\n\t\t\t\t\t\tflag = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttHead->headLink = fHead;\n\t\t\t\t\t\ttHead = fHead;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid showOLGraph(graph_OL g)                 //显示十字链表\n{\n\tedgeNode* t;\n\tprintf(\"显示十字链表的出度链：\\n\");\n\tfor (int i = 0; i < g.numVertexes; i++)\n\t{\n\t\tprintf(\"数组下标：%d，data值：%d，\", i, g.OLList[i].data);\n\t\tif (t = g.OLList[i].firstOut)\n\t\t{\n\t\t\tprintf(\"无弧尾\\n\");\n\t\t}\n\t\telse {\n\t\t\twhile (t)\n\t\t\t{\n\t\t\t\tprintf(\" ——> 下标：%d\", t->headVex);\n\t\t\t\tt = t->tailLink;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"显示十字链表的入度链：\\n\");\n\tfor (int i = 0; i < g.numVertexes; i++)\n\t{\n\t\tprintf(\"数组下标：%d，data值：%d，\", i, g.OLList[i].data);\n\t\tif (t = g.OLList[i].firstIn)\n\t\t{\n\t\t\tprintf(\"无弧头\\n\");\n\t\t}\n\t\telse {\n\t\t\twhile (t)\n\t\t\t{\n\t\t\t\tprintf(\" ——> 下标：%d\", t->tailVex);\n\t\t\t\tt = t->headLink;\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}\n\nint main()\n{\n\tgraph_OL myOLGraph;\n\tcreateOLGraph(&myOLGraph);\n\tshowOLGraph(myOLGraph);\n}", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;STU * find(STU * aStu, int n, char * aName)\n{\n\tint i;\n\tfor(i&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;,aStu&amp;#43;&amp;#43;)\n\t{\n\t\tif(strcmp(aStu-&amp;gt;name,aName)&amp;#61;&amp;#61;0)\n\t\t    break;\n\t}\n\tif(i&amp;lt;n)\n    {\n        printf(&amp;#34;%s,%d\\n&amp;#34;,aStu-&amp;gt;name,aStu-&amp;gt;score);\n\t\treturn aStu;\n    }\n\telse\n\t\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;用if&amp;#xff0c;不是用while&lt;/p&gt;\n\n&lt;p&gt;printf也要确定是否aStu找到啊&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["用C语言结构体，输入学生姓名，查找是否有该学生", ["a.", "\n\n", "现有一个班级的学生成绩，要求自定义结构体存储学生信息，学生信息包括学生姓名与学生成绩。然后编写函数完成对指定姓名的学生信息的查找，找到后打印学生信息，函数原型为：", "\n\n", "\n", "STU * find(STU * aStu, int n, char * aName);", "\n\n", "aStu代表数组首元素地址，n代表数组中元素个数，aName代表要查找学生的名字，如果找到则返回该学生的结构体的指针，没有找到返回NULL。", "\n\n", "学生数组里面的学生数据信息自己填写，数组长度自定义，不存在重名学生，学生信息结构体如下：", "\n\n", "\n", "typedef struct student\n{\n    char name[20];\n    int score;\n} STU;", "\n\n", "将查找到的学生信息输出，学生信息包括学生姓名、学生成绩，中间使用空格隔开。如果没有找到则打印\"没有找到\"。", "\n\n", "输入示例：", "\n\n", "例1    张飞", "\n\n", "例2     李逵", "\n\n", "输出示例：", "\n\n", "例1     张飞 95", "\n\n", "例2    没有找到", "\n\n", "b.我没办法成功输入学生姓名，所以我直接把定义了一个aName[20]，把想找的姓名储存起来（这样就不用从键盘上输入了），但是最后只能打印出学生姓名，分数无法打印，而且会出现乱码", "\n\n", "c.", "\n\n", "\n", "#include <stdio.h>\n#include <string.h>\ntypedef struct student\n{\n    char name[20];\n    int score;\n} STU;\nSTU * find(STU * aStu, int n, char * aName);\nint main (void)\n{\n\t/*char Name[20];\n\tscanf(\"%s\",Name);*/\n\t//这里一直不能输入所以我改成了下面这一行\n\tchar aName[20]=\"zhangsan\";\n\tSTU Stu[3]=\n\t{\n\t\t{\"zhangsan\",20},\n\t\t{\"lisi\",30},\n\t\t{\"wangwu\",40}\n\t};\n\tSTU * x=find(Stu,3,aName); \n\tif(x!=NULL)\n\t\tprintf(\"%s %d\",x->name,x->score);\n\telse\n\t\tprintf(\"没有找到\");\n} \nSTU * find(STU * aStu, int n, char * aName)\n{\n\tint i;\n\tfor(i=0;i<n;i++,aStu++)\n\t{\n\t\twhile(strcmp(aStu->name,aName)==0)\n\t\tbreak;\n\t}\n\tprintf(\"%s,%d\\n\",aStu->name,aStu->score);\n\tif(i<=n)\n\t\treturn aStu;\n\telse\n\t\treturn 0;\n}", "\n\n", "运行结果是这样的，理想的结果应该是zhangsan 20", "\n\n", "用的软件是VS2012", "\n\n", "ps：大佬们我是小白，刚开始学，插入代码段的时候不知道哪个是C语言，就选的C++", "\n\n", "谢谢泥萌！"]], "Tag": "程序设计"}
{"Answer": "for(i=0;i \r\n这里错了\r\nfor(i=0;i &lt; 10; i++)\r\nstmax=st;\r\n这是整体\r\nstmax.score=0; stmin.score=100;\r\n这是变量\r\n\r\n优越性就是组织在一起，而不是分为多个变量，可以整体操作，比如你的赋值", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C语言结构体的一些疑问？", ["（1）输入10个学生的学号、姓名和成绩，求出其中的高分者和低分者。", "\n\n", "#include ", "\nstruct student", "\n { ", "\n    int num;", "\n    char  name[20];", "\n    int score;", "\n };", "\nint main( )", "\n{ ", "\n    int i;", "\n    struct student st,stmax,stmin;", "\n    stmax.score=0;  stmin.score=100;", "\n    printf(\"\\n input  data\");", "\n    for(i=0;i\n    { ", "\n        scanf(\"%d%s%d\",&st.num,st.name,&st.score);", "\n        if(st.score>stmax.score) ", "\n            stmax=st;", "\n        if(st.score<stmin.score) ", "\n            stmin=st;", "\n    }", "\n    printf(\"\\n hight:%5d%15s%5d\",stmax.num,stmax.name,stmax.score);", "\n    printf(\"\\n low:%5d%15s%5d\",stmin.num,stmin.name,stmin.score);", "\n    return 0;", "\n}", "\n\n", "① 分析程序，上机运行程序。", "\n② 程序中，哪些是对结构体变量成员的引用？哪些是整体引用？", "\n③ 对于此例来说，用结构体变量作为数据结构有何优越性"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;data是unsigned char类型数组吗&amp;#xff0c;sizeof括号里面为什么不是data , getChksum(data, sizeof(data)); 这样呢&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["unsigned char * 指向结构体", ["问题遇到的现象和发生背景", "\n", "unsigned", " ", "char", " ", "getChksum", "(", "unsigned", " ", "char", "* p, ", "int", " len)", "\n", "{\n    ", "int", " i;\n    ", "unsigned", " ", "char", " chksum = ", "0", ";\n    ", "for", " ( i = ", "0", "; i < len; i++) {\n        chksum += *p;\n        p++;\n    }\n    ", "return", " chksum;\n}\n\n", "\n", "这是求校验码", "\n", "问题相关代码，请勿粘贴截图", "\n", "newchksum = getChksum(&data[iCount], sizeof(checkinData));", "这是要使用", "\n", "运行结果及报错内容", "\n", "报错类型与实参不相容", "\n", "我的解答思路和尝试过的方法", "\n", "然后在VS2019下有的能跑，有点报错不能跑", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;定义学生信息结构数组&amp;#xff0c;直接用结构数组进行fwrite和fread&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; _student\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;id&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; age;\n}student;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    student stu[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    &lt;span class=\"hljs-comment\"&gt;//省略信息输入&lt;/span&gt;\n    FILE *fp1,*fp2;\n    fp1 &amp;#61; fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;stu.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fp1 !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n      fwrite(stu,&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(student),&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,fp1);\n    fclose(fp1);\n    fp2 &amp;#61; fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;stu.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fp2 !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n      fread(stu,&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(student),&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,fp2);\n    fclose(fp2);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["从键盘输入5名学生的学号、姓名和年龄，存入结构体数组中，然后将他们转存到磁盘文件中，用fwrite和fread", ["从键盘输入5名学生的学号、姓名和年龄，存入结构体数组中，然后将他们转存到磁盘文件中，用fwrite和fread。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a, b, c;   &lt;span class=\"hljs-comment\"&gt;//用逗号&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a;          &lt;span class=\"hljs-comment\"&gt;//用分号&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; c;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义一个结构体变量时，中间内容是用逗号？我记得是用分号，所以正确的到底是逗号还是分号？", ["定义一个结构体变量时，中间内容是用逗号？我记得是用分号，所以正确的到底是逗号还是分号？", "定义一个结构体变量时，中间内容是用逗号？我记得是用分号，所以正确的到底是逗号还是分号？"]], "Tag": "程序设计"}
{"Answer": "vec.push_back(*buffer);\r\n你vector类型是imageBuffer，imageBuffer *buffer是指针，解引用成对象就可以了 *buffer", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体内有指针，怎么把结构体push_back到容器内", ["有这么一个结构体", "\n\n", "typedef struct imageBufferStruct {\n    char *data_im;\n    float *data_depth;\n}imageBuffer;\n", "\n\n", "定义一个结构体并给指针申请空间", "\n\n", "imageBuffer *buffer;\nbuffer = new imageBuffer();\nbuffer->data_im = new char[1024*1024];\nbuffer->data_depth = new float[1024*1024];\n", "\n\n", "我想把buffer放到容器内", "\n\n", "vector<imageBuffer> vec;\nvec.push_back(buffer); //这是好像内存是有问题\n", "\n\n", "请问结构体内有指针的容器怎么push_back类似的例子", "\n谢谢大神给个链接例子"]], "Tag": "程序设计"}
{"Answer": "这个需要c++11才能支持，你的编译器是什么？", "Konwledge_Point": "数据封装——结构体", "Question": ["C++关于结构体初始化的问题", ["#include ", "\n#include ", "\nusing namespace std;", "\nstruct Person", "\n{", "\nstring name;", "\nint count;", "\n};", "\n\n", "int main()", "\n{", "\n    Person leader[3]={{\"li\",0},{\"zhang\",0},{\"fun\",0}};", "\n\n", "error C2440: 'initializing' : cannot convert from 'char [3]' to 'struct Person'\n"]], "Tag": "程序设计"}
{"Answer": "定义一个函数，函数的参数如文档，传给它。这些参数是调用者传给你的，你不要赋值。\r\n如果不理解，可以参考windows api函数，里面有很多回调的。\r\n比如enumwindows就是一个回调函数\r\nhttp://www.cnblogs.com/magic-cube/archive/2011/05/12/2044984.html", "Konwledge_Point": "数据封装——结构体", "Question": ["C++中结构体怎么赋值。", ["其中 Long类型的lCommadn该怎么赋值？还有Char * pBuf该怎么赋值？ 求大虾解答下。谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;回答&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Employee&lt;/span&gt;{\n    string name;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; base_wage;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; float_wage;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;  out_pay;\n};\n\n&lt;span class=\"hljs-comment\"&gt;//这里结构体可以用链表依次添加&amp;#xff0c;也可以用数组直接定好&amp;#xff0c;为了简单理解就用数组了&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    Employee employee[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        cin&amp;gt;&amp;gt;employee[i].name&amp;gt;&amp;gt;employee[i].base_wage&amp;gt;&amp;gt;employee[i].float_wage&amp;gt;&amp;gt;employee[i].out_pay;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        cout&amp;lt;&amp;lt;employee[i].name&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f\\n&amp;#34;&lt;/span&gt;, employee[i].base_wage &amp;#43; employee[i].float_wage - employee[i].out_pay);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/786151450646162.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["打印工资单c++刚需求解", [" 打印工资单", "\n", "【问题描述】", "\n", "定义结构体，存储下表中的数据，然后按照顺序输出每个人的姓名和实发工资。", "\n", "输入：3行，每行对应表格中的一行数据，以空格隔开。", "\n", "输出：3行，每行包括姓名和实发工资，以空格隔开。", "\n", "要求：使用结构体，结果保留两位小数。", "\n", "注意：实发工资=基本工资+浮动工资-支出。", "\n", "工资表", "\n", "姓名", "\n", "基本工资", "\n", "浮动工资", "\n", "支出", "\n", "Zxy", "\n", "230.00", "\n", "400.00", "\n", "76.00", "\n", "Ljt", "\n", "350.00", "\n", "120.00", "\n", "56.00", "\n", "Zhm", "\n", "360.00", "\n", "0.00", "\n", "80.00", "\n", "【样例输入】", "\n", "Zxy 230.00 400.00 76.00", "\n", "Ljt 350.00 120.00 56.00", "\n", "Zhm 360.00 0.00 80.00", "\n", "【样例输出】", "\n", "Zxy 554.00", "\n", "Ljt 414.00", "\n", "Zhm 280.00"]], "Tag": "程序设计"}
{"Answer": "TS[i].Num\r\n这样写才对\r\n\r\nTS-&gt;Num也合法，因为数组也相当于指针\r\n这代码相当于\r\nTS[0].Num", "Konwledge_Point": "数据封装——结构体", "Question": ["在C语言中，要引用结构体数组成员时，究竟应该用箭头还是点？", ["我是C语言的初学者，在学习结构体的时候发现了一个和书籍和网上资料不符的地方。根据我在网上找到的资料，点（.）是用于结构体变量访问成员，箭头（->）是用于结构体指针访问成员。", "\n\n", "在调用结构体TS中的Num变量时，因为我并未使用指针变量，理论上应该是“TS.Num”，但是在编译的过程中，编译器会自动将其转化为“TS->Num”，而且转化后能顺利识别运行，而如果强行将其改成点则会出现无法编译的问题。我想确认这种差异究竟是因为编译环境的影响，还是因为我忽略了什么因素？", "\n\n", "下面是我测试用的代码，我使用的系统是64位Windows7，使用的编译器是Visual Studio 2019。", "\n\n", "#include<stdio.h>\n#include<math.h>\n#include\"Mine.h\"\nstruct Data\n{\n    int Num;\n    char Name[20];\n    char Sex;\n};\nint main(void)\n{\n    int i;\n    struct Data test;\n    struct Data TS[10];\n    test.Num = 10;\n    TS->Num = 20;\n    printf(\"%d,%d\\n\", test.Num, TS->Num);\n}\n"]], "Tag": "程序设计"}
{"Answer": "base-&gt;UCR1 &amp;= ~(1&lt;&lt;0);\r\n或者（*base).UCR1 &amp;= ~(1&lt;&lt;0);\r\n第二种可能不能将数值改变的结果带出去", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体名是指针类型吗？", ["先贴代码", "\n\n", "void uart_enable(UART_Type *base)\n{\n    base->UCR1 &= ~(1<<0);\n}\n", "\n\n", "我的疑问就是：", "\n数据base是一个指向UART_Type类型的指针", "\n为什么可以这样使用，直接就操作base->UCR1。", "\n不应该先取值吗，*base->UCR1 &= ~(1<<0)这样吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改处见注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;stdio.h&amp;gt; \n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;cstdlib&amp;gt;\n#define N &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student\n{\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; name&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;]&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//这几个字符串数组设置太大了&amp;#xff0c;不需要这么长的字符串。&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; no&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; partname&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; partno&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; score&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student* next;\n};\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i{};\n\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student stu&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; num1;&lt;span class=\"hljs-comment\"&gt;//需要输入的学生人数&lt;/span&gt;\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;sizeof(struct student)&amp;#61;%d\\n&amp;#34;&lt;/span&gt;, sizeof(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student));&lt;span class=\"hljs-comment\"&gt;//看看结构体大小&lt;/span&gt;\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入需要录入人数&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-params\"&gt;num1&lt;/span&gt;)&lt;/span&gt;;\n    FILE* fwp;\n    fopen&lt;span class=\"hljs-constructor\"&gt;_s(&amp;amp;&lt;span class=\"hljs-params\"&gt;fwp&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;期末大作业三.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fwp&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)  return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (N &amp;lt; num1)&lt;span class=\"hljs-comment\"&gt;//动态录入数据&lt;/span&gt;\n    {\n        num1 &amp;#61; N;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;最大人数为N&amp;#61;100!\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num1; i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n请输入第%d个学生的信息&amp;#34;&lt;/span&gt;, i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n学生姓名为:&amp;#34;&lt;/span&gt;); scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;name&lt;/span&gt;)&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//scanf_s(&amp;#34;%s&amp;#34;, stu[i].name, sizeof(stu));&lt;/span&gt;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n学生学号:&amp;#34;&lt;/span&gt;); scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;no&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;no&lt;/span&gt;)&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n该学生的零件的名称:&amp;#34;&lt;/span&gt;); scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;partname&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;partname&lt;/span&gt;)&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n该学生的零件编号:&amp;#34;&lt;/span&gt;); scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;partno&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;partno&lt;/span&gt;)&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n该学生的得分:&amp;#34;&lt;/span&gt;); scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;score&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;score&lt;/span&gt;)&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    }\n    fwrite(stu, sizeof(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student), num1, fwp);\n    fclose(fwp);\n\n    student stuu&lt;span class=\"hljs-literal\"&gt;[N]&lt;/span&gt;;\n    FILE* fpp;\n    fopen&lt;span class=\"hljs-constructor\"&gt;_s(&amp;amp;&lt;span class=\"hljs-params\"&gt;fpp&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;期末大作业三.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fpp&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)  return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    fread(stuu, sizeof(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student), num1, fpp);\n    fclose(fpp);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num1; i&amp;#43;&amp;#43;)\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %s %s %s\\n&amp;#34;&lt;/span&gt;, stuu&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.name, stuu&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.no, stuu&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.partname, stuu&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.partno, stuu&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.score);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体输入文件时出错", ["C语言初学者，在写一个程序编辑一个结构体，然后输入进文件的过程", "出现的问题，就是它提示Run-Time Check Failure #2 - Stack around the variable 'stu' was corrupted.", "然后输出的TXT文件有10MB之大，求问是怎么回事。", "\n", "\n", "\n#", "include", "<stdio.h> \n#", "include", " <cstdlib>\n#define N ", "100", "\n", "struct", " student\n{\n    ", "char", " name", "[", "200", "]", ";\n    ", "char", " no", "[", "200", "]", ";\n    ", "char", " partname", "[", "100", "]", ";\n    ", "char", " partno", "[", "200", "]", ";\n    ", "char", " score", "[", "100", "]", ";\n    ", "struct", " student* next;\n};\n", "int", " main", "()", "\n{\n    ", "int", " i{};\n  \n    ", "struct", " student stu", "[N]", ";\n    ", "int", " num1;", "//需要输入的学生人数", "\n    printf(", "\"请输入需要录入人数：\\n\"", ");\n    scanf", "_s(", "\"%d\"", ", &", "num1", ")", ";\n    ", "if", " (N < num1)", "//动态录入数据", "\n    {\n        num1 = N;\n        printf(", "\"最大人数为N=100!\\n\"", ");\n    }\n    ", "for", " (", "int", " i = ", "0", "; i < num1; i++)\n    {\n\n        printf(", "\"\\n请输入第%d个学生的信息\"", ", i + ", "1", ");\n        printf(", "\"\\n学生姓名为:\"", "); scanf", "_s(", "\"%s\"", ", ", "stu", "[", "i", "].", "name", ", ", "sizeof", "(", "stu", ")", ");\n        printf(", "\"\\n学生学号:\"", "); scanf", "_s(", "\"%s\"", ", ", "stu", "[", "i", "].", "no", ", ", "sizeof", "(", "stu", ")", ");\n        printf(", "\"\\n该学生的零件的名称:\"", "); scanf", "_s(", "\"%s\"", ", ", "stu", "[", "i", "].", "partname", ", ", "sizeof", "(", "stu", ")", ");\n        printf(", "\"\\n该学生的零件编号:\"", "); scanf", "_s(", "\"%s\"", ", ", "stu", "[", "i", "].", "partno", ", ", "sizeof", "(", "stu", ")", ");\n        printf(", "\"\\n该学生的得分:\"", "); scanf", "_s(", "\"%s\"", ", ", "stu", "[", "i", "].", "score", ", ", "sizeof", "(", "stu", ")", ");\n\n    }\n    student stuu", "[N]", ";\n    FILE* fpp;\n    fopen", "_s(&", "fpp", ", ", "\"期末大作业三.txt\"", ", ", "\"rb\"", ")", ";\n    fread(stuu, sizeof(student), N, fpp);\n    fclose(fpp);\n}\n", "\n", "运行结果及报错内容", "\n", "\n", "文件大到打不开= =", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "Vertex_Chain[0].Vertex_Num\r\n-&gt;\r\n600", "Konwledge_Point": "数据封装——结构体", "Question": ["在一个结构体中动态创建另一个结构体数组，那么怎样释放内存！求助，谢谢了！", ["struct Link_Info", "\n{", "\n    int Destination_VertexID;", "\n    int Vertex_To_Vertex_LinkID;", "\n    int Cost_of_Link;", "\n\n", "};", "\n\n", "struct Vertex_Info {", "\n    int OutDegree;", "\n    int Vertex_Num;", "\n    Link_Info* out = new Link_Info[8];", "\n};", "\n\n", "Vertex_Info* Vertex_Chain = new Vertex_Info [600];"]], "Tag": "程序设计"}
{"Answer": "乍看起来c++的cin、cout、ifstream、ofstream、istringstream、ostringstream在输入、输出上比c的scanf、printf、fscanf、fprintf、fread、fwrite、sscanf、sprintf简单，不用格式控制符！\r\n但是不用格式控制符，输入输出恰好是你期望的格式的时候好说；等到输入输出不是你期望的格式的时候，你就会觉得还是用格式控制符更方便、更靠谱。\r\n摒弃cin、cout、ifstream、ofstream、istringstream、ostringstream！\r\n使用scanf、printf、fscanf、fprintf、fread、fwrite、sscanf、sprintf。", "Konwledge_Point": "数据封装——结构体", "Question": ["语言：c++ 从文本文档读取数据，并保存到struct中", ["各位，我想要从txt文本文档中读取三万行数据，每行两列，一列为小数，一列为整数，现用getline()逐行读取，并将每一行分割成两个数据，保存到struct中，这个struct有double型和int型两个变量，具体应该这么做，希望有人给出具体的代码，感激不尽。"]], "Tag": "程序设计"}
{"Answer": "肯定需要啊，delete结构体指针，默认只会释放在结构体中直接声明的变量，对于new或者malloc出来的指针需要手动释放，而在实际的开发中为了方便，\r\n我们常常将对结构体中指针的释放放在结构体的析构函数的，当然 像你这种用户也是没有问题的。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中的指针指向申请的内存空间，delete结构体变量前必须要释放吗？", ["\n593行是必须的吗？解释下要或不要的原因。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;要插入记录的话&amp;#xff0c;需要将插入位置及其后续的记录全部后移一个位置&amp;#xff0c;然后在插入位置放置新记录内容即可&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;struct student\n{\n    char name[20];\n    float score;\n}stu[50];\nint stunum &amp;#61; 0;\nvoid main()\n{\n    printf(&amp;#34;请输入学生数量:&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;stunum);\n    int i;\n    for(i&amp;#61;0;i&amp;lt;stunum;i&amp;#43;&amp;#43;)\n        scanf(&amp;#34;%s %f&amp;#34;,stu.name,&amp;amp;stu[i].score);\n    printf(&amp;#34;请输入要插入的学生姓名&amp;#xff0c;成绩和插入位置:&amp;#34;);\n    student newstu;\n    int pos;\n    scanf(&amp;#34;%s %d %d&amp;#34;,newstu.name,&amp;amp;newstu.score,&amp;amp;pos);\n    if(pos &amp;gt;&amp;#61; stunum || pos &amp;lt; 0)  //加入pos的位置不在学生数量范围&amp;#xff0c;则加入末尾\n        stu[stunum&amp;#43;&amp;#43;] &amp;#61; newstu;\n    else\n    {\n        for(i&amp;#61;stunum;i&amp;gt;&amp;#61;pos;i--)\n            stu[i] &amp;#61; stu[i-1];\n        stu[pos] &amp;#61; newstu;\n        stunum&amp;#43;&amp;#43;;\n    }\n    for(i&amp;#61;0;i&amp;lt;stunum;i&amp;#43;&amp;#43;)\n        printf(&amp;#34;姓名:%s\\t成绩:%f\\n&amp;#34;,stu[i].name,stu[i].score);\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求一个c++结构体数组相关程序", ["定义一个结构体数组，输入结构体数组元素，并编写函数对结构体数组中插入记录"]], "Tag": "程序设计"}
{"Answer": "解决这个问题并不难，楼主把\r\n#ifndef STACK_H\r\n#define STACK_H\r\n和\r\n#ifndef TREE_H\r\n#define TREE_H\r\n放到文件的最前面，即include头文件前面\r\n\r\n但如果有源文件包含这两个头文件如果顺序不对的话，又会出现识别不了类型\r\n楼主可以读一下这篇：http://blog.csdn.net/hazir/article/details/38600419\r\n\r\n所以比较好的解决方法是，尽量避免头文件互相包含，将公用的结构放到另一个文件里，然后都包含那个文件", "Konwledge_Point": "数据封装——结构体", "Question": ["如何把一个头文件中定义的结构体用到另一个头文件中，另一个头文件中定义的结构体又用到改头文件中？", ["//栈的头文件声明", "\n #include ", "\n#include ", "\n#include \"Tree\"", "\n#ifndef STACK_H", "\n#define STACK_H", "\ntypedef union typelemt{", "\n    char ch;", "\n    Tree t;", "\n}typelemt;", "\ntypedef struct stack{", "\n    typelemt* type_stack;", "\n    int max;", "\n}stack;", "\ntypelemt pop(stack* p);//出栈 ", "\nvoid push(stack* p,typelemt a);//入栈 ", "\nvoid show_stack(stack* p);//释放栈 ", "\nstack* build_stack();//建栈 ", "\nvoid breakstack();//释放栈 ", "\n\n", "#endif ", "\n\n", "//树的头文件声明", "\n#include ", "\n#include ", "\n#include ", "\n#include \"Stack.h\"", "\n#ifndef TREE_H", "\n#define TREE_H", "\ntypedef char element;", "\ntypedef struct  treeNode{", "\n    element value;//树值 ", "\n    struct treeNode* right;//左儿子 ", "\n    struct treeNode* left;//右二子 ", "\n}treeNode;", "\ntypedef treeNode ", "Tree;", "\nvoid BuildTreeWithGeneralListInput(char", " s);", "\n//（广义表输入建树）", "\n/*这个函数里要用到栈，但是这样写\"Stack.h\"包含\"tree.h\"而tree.h又包含Stack.h彼此包含无穷无尽先然这是错误的*/", "\n//但是去掉Stack.h中的tree.h则我无法识别出union里的Tree", "\n//去掉Tree.h中的Stack.h我就无法识别广义表输入建树用到的栈和它的函数", "\n//怎么解决啊！！求前辈！", "\n#endif"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;注意你的结构体成员是char数组  用%s啊&lt;/p&gt;\n\n&lt;p&gt;注意你的中文符号&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;iostream&amp;gt;\nusing namespace std;\nstruct student\n{\n\n\tchar num[10];\n\tchar name[20];\n\tchar sex[6];\n\tchar score[3];\n}stu[5];\nvoid input(student stu[])\n{\n\tint i, a;\n\tfor (i &amp;#61; 0; i &amp;lt; 5; i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;%d学号&amp;#34; ,i&amp;#43;1);\n\t\t\tscanf_s(&amp;#34;%s&amp;#34;, &amp;amp;stu[i].num,10);\n\t\tprintf(&amp;#34; %d姓名&amp;#34;, i&amp;#43;1);\n\t\tscanf_s(&amp;#34;%s&amp;#34;, &amp;amp;stu[i].name,20);\n\t\tprintf(&amp;#34;%d性别&amp;#34;, i&amp;#43;1);\n\t\tscanf_s(&amp;#34;%s&amp;#34;, &amp;amp;stu[i].sex,6);\n\t\tprintf(&amp;#34;%d成绩&amp;#34;, i&amp;#43;1);\n\t\tscanf_s(&amp;#34;%s&amp;#34;, &amp;amp;stu[i].score,3);\n\t}\n}\nvoid output(student stu[])\n{\n\tint i;\n\tfor (i &amp;#61; 0; i &amp;lt; 5; i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;%s &amp;#34;, stu[i].name);\n\t\tprintf(&amp;#34;%s &amp;#34;, stu[i].sex);\n\t\tprintf(&amp;#34;%s &amp;#34;, stu[i].score);\n\t\tprintf(&amp;#34; \\n&amp;#34;);\n\t}\n}\nint main()\n{\n\tstruct student stu[5];\n\tinput(stu);\n\toutput(stu);\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义一个表示学生基本信息的结构体数据类型", ["这是题目要求：定义一个表示学生基本信息的结构体数据类型student，期中包括学号(char num[10])、姓名(char name[20])、性别(char sex)、三门功课成绩(int score[3])。定义两个函数fun_input(struct student)、fun_output(struct student)，分别实现学生基本信息的输入与输出。main函数中定义一个数组struct student stu[5]，再分别调用上述两个函数，输入五个学生信息，再将5个学生信息输出。", "这是我的程序：", "\n", "#include", "<iostream>\nusing namespace std;\nstruct student\n{\n    \n    char num", "[10]", ";\n    char name", "[20]", ";\n    char sex", "[6]", ";\n    char score", "[3]", ";\n}stu", "[5]", ";\nvoid ", "input", "(student stu[])\n{\n    int ", "i", ",", "a", ";\n    for(i=", "1", ";i<", "5", ";i++)\n    {\n        printf(“%d学号\" ,i);\n        scanf(\"%c\",&stu[i].num);\n        printf(“%d姓名”,i);\n        scanf(\"%c\",&stu[i].name);\n        printf(\"%d性别\" ,i);\n        scanf(\"%c\",&stu[i].sex);\n        printf(\"%d成绩\" ,i);\n        scanf(\"%d\",&stu[i].score);\n    }\n}\nvoid output(student stu[])\n{\n    int ", "i", ";\n    for(i=", "0", ";i<", "5", ";i++)\n    {\n        printf(\"%c\",stu[i].name);\n        printf(\"%c\",stu[i].sex);\n        printf(\"%d\",stu[i].score);\n    }\n}\nint ", "main", "()\n{\n    struct student stu", "[5]", ";\n    ", "input", "(stu);\n    output(stu);\n}\n\n\n", "\n", "没有报错但是在输入的时候就已经出问题了 ，该怎么修改？感谢感谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;写了一个管理系统&amp;#xff0c;你可以测试一下&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAX 10&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;book&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ID[&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; BookName[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; Writer[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; Publish[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; date[&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; price;\n}BOOK;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Contact&lt;/span&gt;\n{\n    BOOK data[MAX];&lt;span class=\"hljs-comment\"&gt;//存放数据&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz;&lt;span class=\"hljs-comment\"&gt;//有效数据个数&lt;/span&gt;\n}Contact;\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;menu&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*********************************\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;****** 1.add     2.show    ******\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;****** 3.search  0.exit    ******\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*********************************\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;//增加书籍&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;AddBook&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Contact* pc)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pc-&amp;gt;sz &amp;#61;&amp;#61; MAX)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;书籍已满\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入书号&amp;gt;&amp;#34;&lt;/span&gt;); \n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, pc-&amp;gt;data[pc-&amp;gt;sz].ID);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入书名&amp;gt;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, pc-&amp;gt;data[pc-&amp;gt;sz].BookName);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入作者&amp;gt;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, pc-&amp;gt;data[pc-&amp;gt;sz].Writer);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入出版社&amp;gt;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, pc-&amp;gt;data[pc-&amp;gt;sz].Publish);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入出版日期&amp;gt;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, pc-&amp;gt;data[pc-&amp;gt;sz].date);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入价格&amp;gt;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;, &amp;amp;pc-&amp;gt;data[pc-&amp;gt;sz].price);\n\n    pc-&amp;gt;sz&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;增加书籍成功\\n&amp;#34;&lt;/span&gt;);\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FindBook&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Contact* pc)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;assert&lt;/span&gt;(pc);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ID[&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, ID);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; pc-&amp;gt;sz; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(ID, pc-&amp;gt;data[i].ID) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//查找到后需要打印&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;SearchBook&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Contact* pc)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;assert&lt;/span&gt;(pc);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入需要查找的书号&amp;gt;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-built_in\"&gt;FindBook&lt;/span&gt;(pc);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;找到书籍如下:\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-15s\\t%-30s\\t%-20s\\t%-30s\\t%-10s\\t%-5s\\t\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;书号&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;书名&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;作者&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;出版社&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;出版日期&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;价格&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-15s\\t%-30s\\t%-20s\\t%-30s\\t%-10s\\t%-5.2f\\t\\n&amp;#34;&lt;/span&gt;,\n          pc-&amp;gt;data[i].ID, pc-&amp;gt;data[i].BookName, pc-&amp;gt;data[i].Writer, pc-&amp;gt;data[i].Publish, pc-&amp;gt;data[i].date,pc-&amp;gt;data[i].price);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;该书籍不存在\\n&amp;#34;&lt;/span&gt;);\n    }\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ShowBook&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Contact* pc)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;assert&lt;/span&gt;(pc);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pc-&amp;gt;sz &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;书架为空\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-15s\\t%-30s\\t%-20s\\t%-30s\\t%-10s\\t%-5s\\t\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;书号&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;书名&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;作者&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;出版社&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;出版日期&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;价格&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; pc-&amp;gt;sz; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-15s\\t%-30s\\t%-20s\\t%-30s\\t%-10s\\t%-5.2f\\t\\n&amp;#34;&lt;/span&gt;,\n            pc-&amp;gt;data[i].ID, pc-&amp;gt;data[i].BookName, pc-&amp;gt;data[i].Writer, pc-&amp;gt;data[i].Publish, pc-&amp;gt;data[i].date, pc-&amp;gt;data[i].price);\n    }\n\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; input;\n    Contact con &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    &lt;span class=\"hljs-keyword\"&gt;do&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;menu&lt;/span&gt;();\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;input);\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (input)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;AddBook&lt;/span&gt;(&amp;amp;con);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;ShowBook&lt;/span&gt;(&amp;amp;con);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;SearchBook&lt;/span&gt;(&amp;amp;con);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;退出系统\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入错误\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    } &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (input);\n    \n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;效果如图&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/172193354346183.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义一个结构体数据类型，用来描述学校图书馆中图书的基本信息", ["定义一个结构体数据类型，用来描述我校图书馆中图书的基本", "信息，信息包含:", "统一-书号(不超过13字符)", "书名(不超过30字符)", "作者(不超过20字符)", "出版社(不超过30字符)", "出版日期(包括:年、月、日)", "价格(精确到分)", "假设10本图书的基本信息已经存放到一一个数组中，要求:根", "据输入的书号查询该书，若查找到，输出该书的所有基本信", "息，若未查到，给出提示信息。", "（要求定义以下函数实现相应功能，并在主函数中调用他们）", "如果有人能解答一下的话，就真的帮大忙了，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;/*-------------------------------------------------------\n【程序填空】\n---------------------------------------------------------\n题目&amp;#xff1a;程序通过定义学生结构体变量&amp;#xff0c;存储学生的学号、姓名和3门课的成绩。函数fun的\n      功能是&amp;#xff1a;将形参a所指结构体变量中的数据赋给函数中的结构体变量b&amp;#xff0c;并修改b中\n      的学号和姓名&amp;#xff0c;最后输出修改后的数据。\n例如&amp;#xff1a;a所指变量中的学号、姓名和三门课的成绩依次是&amp;#xff1a;10001、&amp;#34;ZhangSan&amp;#34;、95、80、88&amp;#xff0c;\n      则修改后输出b中的数据应为&amp;#xff1a;10002、&amp;#34;LiSi&amp;#34;、95、80、88。\n-------------------------------------------------------*/&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;  &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;  &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt;  sno;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;  name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;  score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;fun&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;  student  a)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;  b;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  i;\n    &lt;span class=\"hljs-comment\"&gt;/***********SPACE***********/&lt;/span&gt;\n    b &amp;#61; a;&lt;span class=\"hljs-comment\"&gt;//【 ? 】;&lt;/span&gt;\n    b.sno &amp;#61; &lt;span class=\"hljs-number\"&gt;10002&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;/***********SPACE***********/&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(b.name,&lt;span class=\"hljs-string\"&gt;&amp;#34;LiSi&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//(【 ? 】, &amp;#34;LiSi&amp;#34;);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nThe data after modified :\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nNo: %ld  Name: %s\\nScores:  &amp;#34;&lt;/span&gt;, b.sno, b.name);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-comment\"&gt;/***********SPACE***********/&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%6.2f &amp;#34;&lt;/span&gt;, b.score[i]);&lt;span class=\"hljs-comment\"&gt;//【 ? 】);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;  s &amp;#61; { &lt;span class=\"hljs-number\"&gt;10001&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;ZhangSan&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;95&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;88&lt;/span&gt; };\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n\\nThe original data :\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nNo: %ld  Name: %s\\nScores:  &amp;#34;&lt;/span&gt;, s.sno, s.name);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%6.2f &amp;#34;&lt;/span&gt;, s.score[i]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;fun&lt;/span&gt;(s);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言程序填空题。程序通过定义学生结构体变量，存储学生的学号、姓名和3门课的成绩。", ["\n", "/*-------------------------------------------------------\n【程序填空】\n---------------------------------------------------------\n\n题目：程序通过定义学生结构体变量，存储学生的学号、姓名和3门课的成绩。函数fun的\n      功能是：将形参a所指结构体变量中的数据赋给函数中的结构体变量b，并修改b中\n      的学号和姓名，最后输出修改后的数据。\n\n例如：a所指变量中的学号、姓名和三门课的成绩依次是：10001、\"ZhangSan\"、95、80、88，\n      则修改后输出b中的数据应为：10002、\"LiSi\"、95、80、88。\n\n-------------------------------------------------------*/", "\n", "#", "include", "  ", "<stdio.h>", "\n", "#", "include", "  ", "<string.h>", "\n\n", "struct", " ", "student", " \n{\n        ", "long", "  sno;\n        ", "char", "  name[", "10", "];\n        ", "float", "  score[", "3", "];\n};\n", "void", " ", "fun", "(", "struct", "  student  a)", "\n", "{ \n        ", "struct", " ", "student", "  b;   \n        ", "int", "  i;\n", "/***********SPACE***********/", "\n        b = 【?】;\n        b.sno = ", "10002", ";\n", "/***********SPACE***********/", "\n        ", "strcpy", "(【?】, ", "\"LiSi\"", ");\n        ", "printf", "(", "\"\\nThe data after modified :\\n\"", ");\n        ", "printf", "(", "\"\\nNo: %ld  Name: %s\\nScores:  \"", ",b.sno, b.name);\n        ", "for", " (i=", "0", "; i<", "3", "; i++) \n", "/***********SPACE***********/", "\n                ", "printf", "(", "\"%6.2f \"", ",  b.【?】);\n        ", "printf", "(", "\"\\n\"", ");\n}\n", "main", "()\n{ \n        ", "struct", " ", "student", "  s={", "10001", ",", "\"ZhangSan\"", ", ", "95", ", ", "80", ", ", "88", "};\n        ", "int", "  i;\n        ", "printf", "(", "\"\\n\\nThe original data :\\n\"", ");\n        ", "printf", "(", "\"\\nNo: %ld  Name: %s\\nScores:  \"", ",s.sno, s.name);\n        ", "for", " (i=", "0", "; i<", "3", "; i++) \n                ", "printf", "(", "\"%6.2f \"", ",  s.score[i]);\n        ", "printf", "(", "\"\\n\"", ");\n        ", "fun", "(s);\n}\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用指针就好&amp;#xff0c;定义一个指针变量&amp;#xff0c;然后动态空间申请&amp;#xff0c;可以去看一下我主页的顺序表的增删&amp;#xff0c;里面有。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体里面的动态数组应该怎么定义", ["#include <stdio.h>", "#define size 8", "\n", "struct Table{", "int size; //顺序表的容量大小", "\n", "int length；//顺序表的有效长度，及数组中的元素个数", "\n", "int *head; //动态数组", "}table1", "\n"]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/lethic/article/details/7781203", "Konwledge_Point": "数据封装——结构体", "Question": ["C++结构体中包含指针的结构体数组的排序怎么做？", ["C++结构体中包含指针的结构体数组的排序怎么做？关于这方面的主要问题是什么？怎么使得排序结果稳定？"]], "Tag": "程序设计"}
{"Answer": "typedef struct {\n    int a;\n    int b;\n    int c;\n    int d;\n}my_st;\n\nmy_st st_var;\n\nvoid fun()\n{\n    st_var.a = 1;\n    st_var.b = 2;\n    st_var.c = 22;\n    st_var.d = 524;\n}", "Konwledge_Point": "数据封装——结构体", "Question": ["c结构体全局变量的使用？", ["我在一个函数里面这样写，这些是全局变量；我应该怎么样去把这些当道一个结构体里面调用？", "\nvoid fun（）{", "\n a=1；", "\n b=2；", "\n c=22；", "\n d=524；", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;加上构造就行了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; student {\n    student(&lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; y&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; s&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;):\n    name(n),years(y),score(s)\n    {}\n    &lt;span class=\"hljs-comment\"&gt;// 姓名&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n    &lt;span class=\"hljs-comment\"&gt;// 年龄&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; years;\n    &lt;span class=\"hljs-comment\"&gt;//分数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; score;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注&amp;#xff1a;c&amp;#43;&amp;#43;中结构体和类除了默认访问权限&amp;#xff0c;其他类能做到的&amp;#xff0c;struct也能&amp;#xff0c;基本上是一样的&amp;#xff0c;只是平时使用时习惯使用struct来表达纯数据无方法的结构。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["有关结构体未初始化变量问题", ["初学C++结构体，只是定义了一个结构体加一个变量，就出现了警告。", "代码如下，vs2019把警告线划在了定义完结构体之后的大括号上。", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "student", " {\n    ", "// 姓名", "\n    string name;\n    ", "// 年龄", "\n    ", "int", " years;\n    ", "//分数", "\n    ", "int", " score;\n};\n", "int", " ", "main", "()", "\n", "{\ntruct student s3 = { ", "\"李三\"", ",", "19", ",", "660", " };\n    cout << ", "\"name=\"", " << s3.name << endl << ", "\"years=\"", " << s3.years << endl << ", "\"score=\"", " << s3.score << endl;\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n", "\n", "警告内容是", "\n", "警告    C26495    未初始化变量 student::years。始终初始化成员变量(type.6)。", "警告    C26495    未初始化变量 student::score。始终初始化成员变量(type.6)。", "\n", "有什么办法可以解决这两个警告吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;d  下标越界&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体变量单选题", ["有以下声明和定义：", "\n\n", "struct Student { char num[10]; int age; };", "\n\n", "struct Student stu[3]={{\"202001\",20},{\"202002\",18},{\"202002\",19}};", "\n\n", "struct Student *p=stu;", "\n\n", "以下选项中，引用结构体变量成员的表达式错误的是 。 A. (p++)->num B. p->num C. (*p).num D. stu[3].age"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;得是dates[i].Cost_X&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言的结构体成员已经添加，但是一直说没有（环境vs2019）", ["问题遇到的现象和发生背景", "\n", "struct STU", "{", "    char name[100];//书名", "    char Start_Time[100];//开始租赁时间", "    int Time;//使用天数", "    int Flag;//书籍状态", "    double Price;//价格", "    double Cost;//费用", "    float Cost_X;//需要花费", "    char Peop[100];//租赁人", "}dates[N];", "为什么提示没有    float Cost_X;//需要花费", "    char Peop[100];//租赁人", "这两个成员，不是已经加了吗", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/975423939456197.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; stu[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    FILE *file;\n    file&amp;#61;&lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;file.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(file!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名:&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,stu[i].name);\n            &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d&amp;#34;&lt;/span&gt;,&amp;amp;stu[i].num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],&amp;amp;stu[i].num[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],&amp;amp;stu[i].num[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n            &lt;span class=\"hljs-built_in\"&gt;fputs&lt;/span&gt;(stu[i].name,file);\n            &lt;span class=\"hljs-built_in\"&gt;fputc&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;\\t&amp;#39;&lt;/span&gt;,file);\n            &lt;span class=\"hljs-built_in\"&gt;fprintf&lt;/span&gt;(file,&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d&amp;#34;&lt;/span&gt;,stu[i].num[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],stu[i].num[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],stu[i].num[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(i!&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-built_in\"&gt;fputc&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;,file);\n            }\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(file);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; line[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;];\n    file&amp;#61;&lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;file.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;feof&lt;/span&gt;(file))\n    {\n        &lt;span class=\"hljs-built_in\"&gt;fgets&lt;/span&gt;(line,&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;,file);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,line);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于#c##的问题：需要整理三名学生的三科成绩，从键盘上输入结构体数组各元素的值，将结构体数组的内容写入到一个文件中，并从文件中读出", ["需要整理三名学生的三科成绩，从键盘上输入结构体数组各元素的值，将结构体数组的内容写入到一个文件中，并从文件中读出，并输出到屏幕上。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;What you've written appears to be correct. &lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将结构体上的方法传递为golang中的回调", ["\n\n", "Is it possible to pass a method on a struct as a callback function in golang ?  ", "\n\n", "E.g. Register a message handler :", "\n\n", "func (mc MQTTClient) MessageHandler(client MQTT.Client, msg MQTT.Message) {\n   fmt.Printf(\"TOPIC: %s\n\", msg.Topic())\n   fmt.Printf(\"MSG: %s\n\", msg.Payload())\n}\n\nfunc (mc MQTTClient) AddMessageHandler(){\n  //..\n  //subscribe to the topic /go-mqtt/sample and request messages to be delivered\n  //at a maximum qos of zero, wait for the receipt to confirm the subscription\n\n  if token := c.Subscribe(\"go-mqtt/sample\", 0, mc.MessageHandler); token.Wait() && token.Error() != nil {\n                    fmt.Println(token.Error())\n                    os.Exit(1)\n  }\n}\n", "\n\n", "Thank you very much !", "\n    "]], "Tag": "程序设计"}
{"Answer": "pLSN = (pLINKSTACKNODE)&amp;stu1;\r\n pLSN-&gt;pNext = pLinkStackHead-&gt;headNode.pNext;//stu1.name[]被修改为NULL了", "Konwledge_Point": "数据封装——结构体", "Question": ["用malloc开辟空间存储结构体的指针", ["#include<stdlib.h>\n#include<string.h>\n#include<stdio.h>\n#include<math.h>\n#include<time.h>\n\ntypedef struct student\n{\n    char name[21];\n    int age;\n}STU, * pSTU;\n\ntypedef struct linkStackNode\n{\n    struct linkStackNode* pNext;    //只维护指针域\n}LINKSTACKNODE, * pLINKSTACKNODE;\n\ntypedef struct linkStack            //链式的栈结构体，栈顶设计在头部\n{\n    LINKSTACKNODE headNode;         //头节点【不是头指针】，并不存放有效数据\n    int length;                     //栈的大小\n}LINKSTACK, * pLINKSTACK;\n\n//====================================================================================================\n\n//初始化栈\npLINKSTACK initLinkStack()\n{\n    //头指针\n    pLINKSTACK pLinkStackHead = (pLINKSTACK)malloc(sizeof(LINKSTACKNODE));\n    if (NULL == pLinkStackHead)\n    {\n        printf(\"内存分配失败.\\n\");\n        return NULL;\n    }\n\n    pLinkStackHead->headNode.pNext = NULL;\n    pLinkStackHead->length = 0;\n    return pLinkStackHead;\n}\n\n//====================================================================================================\n\nint main(int argc, char* argv[])\n{\n    STU stu1;\n\n    strcpy(stu1.name, \"张三\");\n    stu1.age = 23;\n\n    pSTU pStu = (pSTU)malloc(sizeof(pSTU));\n    pStu = &stu1;\n    printf(\"name = %s ||=====|| age = %d\\n\", pStu->name, pStu->age);\n\n    pLINKSTACK pLinkStackHead = initLinkStack();\n\n    pLINKSTACKNODE pLSN = (pLINKSTACKNODE)malloc(sizeof(LINKSTACKNODE));\n    pLSN = (pLINKSTACKNODE)&stu1;\n\n    pLSN->pNext = pLinkStackHead->headNode.pNext;\n    pLinkStackHead->headNode.pNext = pLSN;\n\n    pSTU tmp = (pSTU)pLinkStackHead->headNode.pNext;\n    printf(\"name = %s ||=====|| age = %d\\n\", tmp->name, tmp->age);\n\n    system(\"pause\");\n    return EXIT_SUCCESS;\n}\n", "\n\n", "为什么最后一个printf，没有打印出name的信息"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;/*\n学生的记录由学号、姓名和C语言成绩组成&amp;#xff0c;根据班级人数&amp;#xff0c;将学生记录存放在结构体数组中。\n请编程实现将分数高于平均分的学生记录存放到另一个结构体数组中&amp;#xff0c;\n输出平均分、相应学生记录和人数。要求&amp;#xff1a;班级人数、学生记录均由键盘输入。\n*/\n#include &amp;lt;stdio.h&amp;gt;\nvoid main()\n{\n\tstudent stu[100];\n\tstudent goodstu[100];\n\tint i, n,m&amp;#61;0;\n\tfloat sum &amp;#61; 0;\n\tprintf(&amp;#34;请输入学生人数&amp;#xff1a;&amp;#34;);\n\tscanf_s(&amp;#34;%d&amp;#34;, &amp;amp;n);\n\tprintf(&amp;#34;\\n&amp;#34;);\n\tfor (i &amp;#61; 0; i &amp;lt; n; i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;请输入第%d个学生学号&amp;#xff1a;&amp;#34;,i&amp;#43;1);\n\t\tscanf_s(&amp;#34;%d&amp;#34;, &amp;amp;stu[i].nID);\n\t\tprintf(&amp;#34;\\n请输入第%d个学生姓名&amp;#xff1a;&amp;#34;, i &amp;#43; 1);\n\t\tscanf_s(&amp;#34;%s&amp;#34;, stu[i].name,20);\n\t\tprintf(&amp;#34;\\n请输入第%d个学生C语言成绩&amp;#xff1a;&amp;#34;, i &amp;#43; 1);\n\t\tscanf_s(&amp;#34;%f&amp;#34;, &amp;amp;stu[i].score);\n\t\tprintf(&amp;#34;\\n&amp;#34;);\n\t\tsum &amp;#43;&amp;#61; stu[i].score;\n\t}\n\tfloat avg &amp;#61; sum / n;\n\t//\n\n\tfor (i &amp;#61; 0; i &amp;lt; n; i&amp;#43;&amp;#43;)\n\t{\n\t\tif (stu[i].score &amp;gt; avg)\n\t\t{\n\t\t\tgoodstu[m].nID &amp;#61; stu[i].nID;\n\t\t\tgoodstu[m].score &amp;#61; stu[i].score;\n\t\t\tmemcpy(goodstu[m].name, stu[i].name, 20);\n\t\t\tm&amp;#43;&amp;#43;;\n\t\t}\n\t}\n\tprintf(&amp;#34;平均分为&amp;#xff1a;%.1f&amp;#xff0c;超过平均分的学生共有%d人\\n&amp;#34;, avg,m);\n\tfor (i &amp;#61; 0; i &amp;lt; m; i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;%d\\t%s\\t%.1f\\n&amp;#34;, goodstu[i].nID, goodstu[i].name, goodstu[i].score);\n\t}\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体的应用..", ["用struct student的形式 ", "\n\n", "c语言作业 ", "\n\n", "大佬帮帮忙", "\n\n", "学生的记录由学号、姓名和C语言成绩组成，根据班级人数，将学生记录存放在结构体数组中。请编程实现将分数高于平均分的学生记录存放到另一个结构体数组中，输出平均分、相应学生记录和人数。要求：班级人数、学生记录均由键盘输入。", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;package main\n\nimport (\n\t&amp;#34;fmt&amp;#34;\n\t&amp;#34;reflect&amp;#34;\n\t&amp;#34;strings&amp;#34;\n)\n \n// 定义结构体\ntype cat struct {\n\tName string\n\tAge int &amp;#96;json:&amp;#34;age&amp;#34; id:&amp;#34;101&amp;#34;&amp;#96;\n}\n\n// 定义结构体方法\nfunc (c *cat) speak(){\n\tfmt.Printf(&amp;#34;喵喵喵&amp;#34;)\n}\n\n// 定义函数\nfunc GetFieldByIndex(a string) bool {\n\treturn strings.ToLower(a) &amp;#61;&amp;#61; &amp;#34;name&amp;#34;\n}\n\nfunc main() {\n\t// 创建结构体变量\n\tc :&amp;#61; cat{Name: &amp;#34;Lily&amp;#34;, Age: 18}\n\t// ValueOf()创建反射结构体变量\n\tvc :&amp;#61; reflect.ValueOf(c)\n\t// 计算成员数量\n\tvnu :&amp;#61; vc.NumField()\n\tfmt.Printf(&amp;#34;NumField()计算成员数量&amp;#xff1a;%v&amp;#xff0c;数据类型&amp;#xff1a;%T\\n&amp;#34;, vnu, vnu)\n\t// 以成员名称访问成员值\n\tvn :&amp;#61; vc.FieldByName(&amp;#34;Name&amp;#34;)\n\tfmt.Printf(&amp;#34;FieldByName()访问某个成员&amp;#xff1a;%v&amp;#xff0c;数据类型&amp;#xff1a;%T\\n&amp;#34;, vn, vn)\n\t// 以成员排序索引访问成员值\n\tvi :&amp;#61; vc.Field(1)\n\tfmt.Printf(&amp;#34;Field()访问某个成员&amp;#xff1a;%v&amp;#xff0c;数据类型&amp;#xff1a;%T\\n&amp;#34;, vi, vi)\n\t// 以成员排序索引访问成员值&amp;#xff0c;索引值以切片表示\n\tvbi :&amp;#61; vc.FieldByIndex([]int{0})\n\tfmt.Printf(&amp;#34;FieldByIndex()访问某个成员&amp;#xff1a;%v&amp;#xff0c;数据类型&amp;#xff1a;%T\\n&amp;#34;, vbi, vbi)\n\t// 以函数方式判断并获取某个成员名称&amp;#xff0c;再从成员名称获取成员值\n\tvf :&amp;#61; vc.FieldByNameFunc(GetFieldByIndex)\n\tfmt.Printf(&amp;#34;FieldByNameFunc()访问某个成员&amp;#xff1a;%v&amp;#xff0c;数据类型&amp;#xff1a;%T\\n&amp;#34;, vf, vf)\n\t// 判断反射结构体变量能否修改数据\n\tfmt.Printf(&amp;#34;反射结构体变量能否修改数据&amp;#xff1a;%v\\n&amp;#34;, vc.CanSet())\n\n\t// ValueOf()创建反射结构体指针变量\n\tvc_pit :&amp;#61; reflect.ValueOf(&amp;amp;c)\n\t// 获取所有成员的值\n\tve :&amp;#61; vc_pit.Elem()\n\tfmt.Printf(&amp;#34;Elem()获取所有成员的值&amp;#xff1a;%v&amp;#xff0c;数据类型&amp;#xff1a;%T\\n&amp;#34;, ve, ve)\n\t// Set()、SetInt()等方法设置成员值\n\tve.FieldByName(&amp;#34;Name&amp;#34;).SetString(&amp;#34;Tom&amp;#34;)\n\tve.FieldByName(&amp;#34;Name&amp;#34;).Set(reflect.ValueOf(&amp;#34;Tim&amp;#34;))\n\tve.FieldByName(&amp;#34;Age&amp;#34;).SetInt(666)\n\tfmt.Printf(&amp;#34;Set()、SetInt()等方法设置成员值&amp;#xff1a;%v\\n&amp;#34;, ve)\n\n\n\n\n\n\n\t// TypeOf()创建反射结构体变量\n\tvt :&amp;#61; reflect.TypeOf(c)\n\t// 遍历结构体所有成员数量\n\tfor i :&amp;#61; 0; i &amp;lt; vt.NumField(); i&amp;#43;&amp;#43; {\n\t\t// 获取每个成员的结构体成员类型\n\t\tvinfo :&amp;#61; vt.Field(i)\n\t\t// 输出成员名和tag\n\t\tfmt.Printf(&amp;#34;结构成员&amp;#xff1a;%v&amp;#xff0c;其标签为&amp;#xff1a;%v\\n&amp;#34;, vinfo.Name, vinfo.Tag)\n\t}\n\t// 通过成员名, 找到成员类型信息\n\tif catTypeName, ok :&amp;#61; vt.FieldByName(&amp;#34;age&amp;#34;); ok {\n\t\t// 从tag中取出需要的tag\n\t\tfmt.Printf(&amp;#34;标签json的内容&amp;#xff1a;%v\\n&amp;#34;, catTypeName.Tag.Get(&amp;#34;json&amp;#34;))\n\t\tfmt.Printf(&amp;#34;标签id的内容&amp;#xff1a;%v\\n&amp;#34;, catTypeName.Tag.Get(&amp;#34;id&amp;#34;))\n\t}\n\t// 通过成员索引, 找到成员类型信息&amp;#xff0c;索引以切片形式表示\n\tcatTypeIndex :&amp;#61; vt.FieldByIndex([]int{1})\n\tfmt.Printf(&amp;#34;标签json的内容&amp;#xff1a;%v\\n&amp;#34;, catTypeIndex.Tag.Get(&amp;#34;json&amp;#34;))\n\tfmt.Printf(&amp;#34;标签id的内容&amp;#xff1a;%v\\n&amp;#34;, catTypeIndex.Tag.Get(&amp;#34;id&amp;#34;))\n\t// 通过成员索引, 找到成员类型信息&amp;#xff0c;索引以切片形式表示\n\tcatTypeField :&amp;#61; vt.Field(1)\n\tfmt.Printf(&amp;#34;标签json的内容&amp;#xff1a;%v\\n&amp;#34;, catTypeField.Tag.Get(&amp;#34;json&amp;#34;))\n\tfmt.Printf(&amp;#34;标签id的内容&amp;#xff1a;%v\\n&amp;#34;, catTypeField.Tag.Get(&amp;#34;id&amp;#34;))\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;参考一下详细的使用过程&lt;/p&gt;\n\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["go语言反射怎样使用结构体", ["结构体和反射之间怎样转换和使用？转换后怎样访问结构体"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;struct 结构体名 *数组名 &amp;#61; NULL;&lt;br /&gt;数组名 &amp;#61; (struct 结构体名 *)malloc(sizeof(struct 结构名)*N);&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言如何动态申请结构体指针数组？", ["写成NODE* array ＝ (NODE**)malloc (NODE*)会报错，NODE是结构体名。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这已经是排序过了&amp;#xff0c;所以2才会在1前面啊&lt;br /&gt;你先录入的e&amp;#xff0c;e的序号是1&lt;br /&gt;后录入的a&amp;#xff0c;a的序号是2&lt;br /&gt;然后你按书名排序&amp;#xff0c;a在前&amp;#xff0c;e在后&amp;#xff0c;那序号是2,1不就对了吗&lt;br /&gt;除非你想显示的不是序号&amp;#xff0c;而是行号&amp;#xff0c;那就应该用循环体的i来作为序号显示&amp;#xff0c;而不要用struct里的num&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么我的结构体数组的序号不会跟着其他数据排序啊？", ["结构体数组的序号不排序", "我的结构体里包括了序号啊", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "# 如果问题得到解决，请点我回答左上角的采纳和向上的箭头\r\n# \r\n\r\n```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\n\r\ntypedef struct node\r\n{\r\n    int id;\r\n\tchar name[20];\r\n\tint score[4];\r\n    node * next;\r\n} * List;\r\n\r\nint main()\r\n{\r\n    List list = NULL;\r\n    node * p = NULL;\r\n\tnode * q = NULL;\r\n\tint n;\r\n\tscanf(\"%d\", &amp;n);\r\n\tnode input;\r\n    for (int i = 0; i &lt; n; i++)\r\n    {\r\n        scanf(\"%d %s %d %d %d %d\", &amp;input.id, &amp;input.name[0], &amp;input.score[0], &amp;input.score[1], &amp;input.score[2], &amp;input.score[3]);\r\n        if (!list)\r\n        {\r\n            list = p = (node *)malloc(sizeof(node));\r\n            p-&gt;id = input.id;\r\n\t\t\tstrcpy(p-&gt;name, input.name);\r\n\t\t\tp-&gt;score[0] = input.score[0];\r\n\t\t\tp-&gt;score[1] = input.score[1];\r\n\t\t\tp-&gt;score[2] = input.score[2];\r\n\t\t\tp-&gt;score[3] = input.score[3];\r\n            p-&gt;next = NULL;\r\n        }\r\n        else\r\n        {\r\n            p-&gt;next = (node *)malloc(sizeof(node));\r\n            p = p-&gt;next;\r\n            p-&gt;id = input.id;\r\n\t\t\tstrcpy(p-&gt;name, input.name);\r\n\t\t\tp-&gt;score[0] = input.score[0];\r\n\t\t\tp-&gt;score[1] = input.score[1];\r\n\t\t\tp-&gt;score[2] = input.score[2];\r\n\t\t\tp-&gt;score[3] = input.score[3];\r\n            p-&gt;next = NULL;         \r\n        }\r\n    }\r\n    q = list;\r\n\twhile (q-&gt;next != NULL)\r\n\t{\r\n\t\tp = q;\r\n\t\tnode * min = p;\r\n\t\twhile (p)\r\n\t\t{\r\n\t\t\tif ((p-&gt;score[0] + p-&gt;score[1] + p-&gt;score[2] + p-&gt;score[3]) &gt; (min-&gt;score[0] + min-&gt;score[1] + min-&gt;score[2] + min-&gt;score[3]))\r\n\t\t\t\tmin = p;\r\n\t\t\tp = p-&gt;next;\r\n\t\t}\r\n\t\tif (min != q)\r\n\t\t{\r\n\t\t\tint tid = min-&gt;id;\r\n\t\t\tchar tname[20];\r\n\t\t\tstrcpy(tname, min-&gt;name);\r\n\t\t\tint tscore[4];\r\n\t\t\tmemcpy(tscore, min-&gt;score, sizeof(int) * 4);\r\n\r\n\t\t\tmin-&gt;id = q-&gt;id;\r\n\t\t\tstrcpy(min-&gt;name, q-&gt;name);\r\n\t\t\tmemcpy(min-&gt;score, q-&gt;score, sizeof(int) * 4);\r\n\r\n\t\t\tq-&gt;id = tid;\r\n\t\t\tstrcpy(q-&gt;name, tname);\r\n\t\t\tmemcpy(q-&gt;score, tscore, sizeof(int) * 4);\r\n\t\t}\r\n\t\tq = q-&gt;next;\r\n\t}\r\n\tp = list;\r\n    while (p)\r\n    {\r\n\t\tint sum = 0;\r\n\t\tint c3 = 1;\r\n\t\tfor (int i = 0; i &lt; 4; i++)\r\n\t\t{\r\n\t\t\tif (p-&gt;score[i] &lt; 55 &amp;&amp; i != 3) c3 = 0;\r\n\t\t\tsum += p-&gt;score[i];\r\n\t\t}\r\n\t\tif (c3 &amp;&amp; sum &gt;= 240)\r\n\t\t\tprintf(\"%d %s %d %d %d %d\\n\",p-&gt;id, p-&gt;name, p-&gt;score[0], p-&gt;score[1], p-&gt;score[2], p-&gt;score[3]);\r\n        p = p-&gt;next;\r\n    }\r\n    return 0;\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201812/01/1543643590_592417.gif)", "Konwledge_Point": "数据封装——结构体", "Question": ["只用结构体要怎么做？", []], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/lanzhihui_10086/article/details/44353381", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言中结构体中对齐问题", ["怎么让结构体中char只占一个字节，不与其他的short数据对齐？请各位大神指教"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c#\"&gt;&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; System.Collections;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\nList&amp;lt;PhoneNum&amp;gt; test1&amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;List&lt;/span&gt;&amp;lt;PhoneNum&amp;gt;();\ntest1.&lt;span class=\"hljs-built_in\"&gt;Add&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;PhoneNum&lt;/span&gt;());\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;.net类库里的类型比MFC里的类型要多&lt;br /&gt;既然你学的是C#而不是C&amp;#43;&amp;#43;,那你要把这些类型利用起来&lt;br /&gt;如果你用C&amp;#43;&amp;#43;&amp;#xff0c;就只能自己定义链表了&lt;br /&gt;尽量别用ArrayList&amp;#xff0c;ArrayList里面每个元素都是object类型&amp;#xff0c;用之前要强制转换不说&amp;#xff0c;还容易把不相干的类型add进去&lt;br /&gt;C#是强类型的编程语言&amp;#xff0c;利用好这个特性&amp;#xff0c;很多bug就可以在编译阶段排除&lt;br /&gt;乱用object你就只好自己慢慢debug&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C# 动态结构体数组怎么创建啊？", ["大学暑假编程实训刚学习C#，有个问题不明白，想请教一下。", "我建立了一个结构体，然后创建这个结构体的数组，但是一开始不知道这个数组到底有多少个下标，所以想建立动态数组，请问一个应该怎么做了？", "\n", "public", " ", "struct", " PhoneNum\n{\n    ", "public", " ", "string", " department;\n    ", "public", " ", "string", " phone;\n}\n\n……\n\nPhoneNum[] test1 = ", "new", " PhoneNum[", "10", "];\n", "\n", "现在就是想把这个test1能变成动态数组那样，先不声明有多少个，等我用的时候再一个个加。"]], "Tag": "程序设计"}
{"Answer": "直接进行强制转换就可以了。", "Konwledge_Point": "数据封装——结构体", "Question": ["利用结构体中的整数数组将同一结构体的指针转换？求大神，看图，不好说清", ["\n\n", "因为需要将结构体中的指针指向的内容排序组装，所以先利用相对应的整形数组排序，可是指针地址怎么转换？？？？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-attribute\"&gt;pass&lt;/span&gt;是字符串\n&lt;span class=\"hljs-attribute\"&gt;struct&lt;/span&gt; Player player &amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;老衲用飘柔&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;123456&amp;#34;&lt;/span&gt;, &amp;#39;f&amp;#39;, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;艾欧尼亚&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;500&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;}};// {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;老衲用飘柔&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;123456&lt;/span&gt;, &amp;#39;f&amp;#39;, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;艾欧尼亚&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;500&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;}};\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体中的结构体显示不出来", ["#include <stdio.h>", "#include <stdlib.h>", "#include<string.h>", "\n", "struct Martial", "{", "    int id;           //门派ID", "    char name[50];    //门派名称", "    int count;        //门派人数", "    int type;         //门派阵营1正派2中立3邪派", "\n", "};", "\n", "struct Player", "{", "    int id;", "    char name[50];     //玩家名称", "    char pass[50];     //玩家登陆密码", "    char sex;          //玩家性别", "    struct Martial martial; //门派ID", "};", "int main()", "{", "    struct Player player={1,\"老衲用飘柔\",123456,'f',{1,\"艾欧尼亚\",500,3}};", "    printf(\"%s\\t%s\\n\",player.name,player.martial.name);", "\n", "return", " ", "0", ";\n", "\n", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没什么问题&amp;#xff0c;修改处见注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;malloc.h&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;单链表结构体\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;-&amp;gt;是箭头\ntypedef int ElemType;\ntypedef struct node &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;node是结点的意思\n{\n    ElemType data;\n    struct node* &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;指向结点本身\n}LNode, * LinkList;\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;头插入法:带头结点(输入数据与输出数据相反)\nvoid CreLinkListHead(LinkList L, int n)\n{\n    LNode* s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;等价于LinkList s\n    ElemType x;\n    int i;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;带头结点头插法--输入结点:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; n; i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;x);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;从键盘输入结点x的值\n        s &amp;#61; (LNode*)malloc(sizeof(LNode));&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;生成一个s结点\n        s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        s-&amp;gt;data &amp;#61; x;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;数据域\n        s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;s的指针域指向下一个结点L的地址编号\n        L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s;\n    }\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出链表信息\nvoid OutPut(LinkList L)\n{\n    LNode* p;\n    p &amp;#61; L;    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;; 修改\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; NULL)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, p-&amp;gt;data);\n        p &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;尾部插入法:带头结点(输入数据与输出数据相同)\nvoid CreLinkListTail(LinkList L, int n)\n{\n    LNode* s, * r;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r结点\n    ElemType x;\n    int i;\n    r &amp;#61; L;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r结点的初始化&amp;#xff0c;首先指向链表L\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;带头结点尾插法--输入结点:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; n; i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;x);\n        s &amp;#61; (LNode*)malloc(sizeof(LNode));\n        s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        s-&amp;gt;data &amp;#61; x;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;上面三条语句和头部插入法相同\n        r-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r的下一个结点是s\n        r &amp;#61; s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r指向s\n    }\n        &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (r !&amp;#61; NULL)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r后没有结点 &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    r-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;尾部插入法:不带头结点(输入数据与输出数据相同)\nLNode* CreLinkListTailNo(int n)\n{\n    LNode* s, * r;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r结点\n    LinkList L &amp;#61; NULL;\n    r &amp;#61; L;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r结点的初始化&amp;#xff0c;首先指向链表L\n    ElemType x;\n    int i;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入结点:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; n; i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;x);\n        s &amp;#61; (LNode*)malloc(sizeof(LNode));\n        s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        s-&amp;gt;data &amp;#61; x;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L &amp;#61;&amp;#61; NULL)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;链表的第一个结点的处理\n        {\n            L &amp;#61; s;\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r &amp;#61; s;    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n            r-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r的下一个结点是s\n        r &amp;#61; s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r指向s\n    }\n          &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (r !&amp;#61; NULL)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r后没有结点&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n          &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n          &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    r-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n          &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n    return L;\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;头插入法:不带头结点(输入数据与输出数据相反)\nLNode* CreLinkListNo(int n)\n{\n    LinkList L &amp;#61; NULL;\n    LNode* s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;等价于LinkList s\n    ElemType x;\n    int i;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入结点:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; n; i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;x);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;从键盘输入结点x的值\n        s &amp;#61; (LNode*)malloc(sizeof(LNode));&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;生成一个s结点\n        s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        s-&amp;gt;data &amp;#61; x;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;数据域\n        s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; L;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;s的指针域指向下一个结点L的地址编号\n        L &amp;#61; s;\n    }\n    return L; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;单链表插入操作&amp;#xff1a;第i个位置插入s结点\nint InsertList(LinkList L, int i, ElemType x)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;x为数据域\n{\n    LNode* p, * s;\n    int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    p &amp;#61; L;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p指向L的头\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; !&amp;#61; NULL &amp;amp;&amp;amp; j &amp;lt; i)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p结点的下一个结点不能为空\n    {\n         p &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p指向p的下个结点\n         j&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p &amp;#61;&amp;#61; NULL)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;链表的末尾\n    {\n         printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;插入位置i不合理&amp;#xff01;&amp;#34;&lt;/span&gt;);\n         return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n         s &amp;#61; (LNode*)malloc(sizeof(LNode));\n         s-&amp;gt;data &amp;#61; x;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;s的数据域\n         s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;s指向下一个结点&amp;#xff0c;p当前所指向结点的下一个\n         p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p的下一个结点等于s\n         return &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;单链表删除操作:删除第i个结点(s是要删除的结点)\nint DeleteList(LinkList L, int i)\n{\n    LNode* p, * s;\n    int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    p &amp;#61; L;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p从L开始\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; !&amp;#61; NULL &amp;amp;&amp;amp; j &amp;lt; i)\n    {\n         p &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n         j&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p &amp;#61;&amp;#61; NULL)\n    {\n         printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;删除位置不合理&amp;#xff01;&amp;#34;&lt;/span&gt;);\n         return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n         s &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;s所指向的结点是p的下个结点\n         p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;等价于p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;\n         free(s);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在内存里释放掉s所指向结点的空间\n         return &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n}\n\nvoid main()\n{\n    int n;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;n个结点\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请在键盘中输入链表有几个结点:\\n&amp;#34;&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入n个结点\n\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;不带头结点尾插法建立单链表L\n    LinkList L1 &amp;#61; CreLinkListTailNo(n);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;不带头结点尾插法--输出建立后的单链表:\\n&amp;#34;&lt;/span&gt;);\n    OutPut(L1); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出建立后的单链表\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;不带头结点头插法建立单链表L\n    LinkList L2 &amp;#61; CreLinkListNo(n);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;不带头结点头插法--输出建立后的单链表:\\n&amp;#34;&lt;/span&gt;);\n    OutPut(L2); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出建立后的单链表\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n \n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;带头结点\n    LinkList L &amp;#61; (LinkList)malloc(sizeof(LNode));&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;空链表的创建\n    L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;指针域为空\n\n    CreLinkListTail(L, n);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;尾插入法建立单链表L\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;尾插法--输出建立后的单链表:\\n&amp;#34;&lt;/span&gt;);\n    OutPut(L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OutPut(L);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出建立后的单链表 &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n\n    LinkList LL &amp;#61; (LinkList)malloc(sizeof(LNode));&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;空链表的创建\n    LL-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;指针域为空\n\n    CreLinkListHead(LL, n);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;头插法建立单链表L\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;头插法--输出建立后的单链表:\\n&amp;#34;&lt;/span&gt;);\n    OutPut(LL-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OutPut(L);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出建立后的单链表 &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;DeleteList(L, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除第&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;个位置的元素\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;输出删除后的单链表:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OutPut(L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OutPut(L);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出删除成功后的单链表\n\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;InsertList(L, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在第&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;个位置插入一个数据元素&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;输出插入后的单链表:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OutPut(L);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输出插入成功后的单链表\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构——链表，不带头结点的头插法和尾插法", ["我想知道不带头结点的头插法和不带头结点的尾插法错在哪里，以及main函数部分有没有错，再者就是整体还能不能优化（前面两个是最主要的问题）", "\n", "（注释是听网课记下的，不知道对了没有，帮忙看一下）", "\n", "#include <stdio.h>", "#include <stdlib.h>", "#include <malloc.h>", "\n", "//单链表结构体", "//->是箭头", "typedef int ElemType;", "typedef struct node    //node是结点的意思", "{", "    ElemType data;", "    struct node* next;//next指向结点本身", "}LNode, * LinkList;", "\n", "//头插入法:带头结点(输入数据与输出数据相反)", "\n", "void CreLinkListHead(LinkList L, int n)", "{", "    LNode* s;//等价于LinkList s", "    ElemType x;", "    int i;", "    printf(\"头插法--输入结点:\\n\");", "    for (i = n; i > 0; i--)", "    {", "        scanf_s(\"%d\", &x);//从键盘输入结点x的值", "        s = (LNode*)malloc(sizeof(LNode));//生成一个s结点", "        s->data = x;//数据域", "        s->next = L->next;//s的指针域指向下一个结点L的地址编号", "        L->next = s;", "    }", "}", "\n", "//输出链表信息", "\n", "void OutPut(LinkList L)", "{", "    LNode* p;", "    p = L->next;", "    while (p != NULL)", "    {", "        printf(\"%d \", p->data);", "        p = p->next;", "    }", "    printf(\"\\n\");", "}", "\n", "//尾部插入法:带头结点(输入数据与输出数据相同)", "\n", "void CreLinkListTail(LinkList L, int n)", "{", "    LNode* s, * r;//r结点", "    ElemType x;", "    int i;", "    r = L;//r结点的初始化，首先指向链表L", "    printf(\"尾插法--输入结点:\\n\");", "    for (i = n; i > 0; i--)", "    {", "        scanf_s(\"%d\", &x);", "        s = (LNode*)malloc(sizeof(LNode));", "        s->data = x;", "        //上面三条语句和头部插入法相同", "        r->next = s;//r的下一个结点是s", "        r = s;//r指向s", "    }", "    if (r != NULL)//r后没有结点", "    {", "        r->next = NULL;", "    }", "}", "\n", "//尾部插入法:不带头结点(输入数据与输出数据相同)", "\n", "LNode* CreLinkListTailNo(int n)", "{", "    LNode* s, * r;//r结点", "    LinkList L = NULL;", "    r = L;//r结点的初始化，首先指向链表L", "    ElemType x;", "    int i;", "    printf(\"输入结点:\\n\");", "    for (i = n; i > 0; i--)", "    {", "        scanf_s(\"%d\", &x);", "        s = (LNode*)malloc(sizeof(LNode));", "        s->data = x;", "        if (L == NULL)//链表的第一个结点的处理", "        {", "            L = s;", "            r = s;", "            continue;", "        }", "        r->next = s;//r的下一个结点是s", "        r = s;//r指向s", "    }", "    if (r != NULL)//r后没有结点", "    {", "        r->next = NULL;", "    }", "    return L;", "}", "\n", "//头插入法:不带头结点(输入数据与输出数据相反)", "\n", "LNode* CreLinkListNo(int n)", "{", "    LinkList L = NULL;", "    LNode* s;//等价于LinkList s", "    ElemType x;", "    int i;", "    printf(\"输入结点:\\n\");", "    for (i = n; i > 0; i--)", "    {", "        scanf_s(\"%d\", &x);//从键盘输入结点x的值", "        s = (LNode*)malloc(sizeof(LNode));//生成一个s结点", "        s->data = x;//数据域", "        s->next = L;//s的指针域指向下一个结点L的地址编号", "        L = s;", "    }", "}", "\n", "//单链表插入操作：第i个位置插入s结点", "\n", "int  InsertList(LinkList L, int i, ElemType x)//x为数据域", "{", "    LNode* p, * s;", "    int j = 0;", "    p = L;//p指向L的头", "    while (p->next != NULL && j < i)//p结点的下一个结点不能为空", "    {", "        p = p->next;//p指向p的下个结点", "        j++;", "    }", "    if (p == NULL)//链表的末尾", "    {", "        printf(\"插入位置i不合理！\");", "        return 0;", "    }", "    else", "    {", "        s = (LNode*)malloc(sizeof(LNode));", "        s->data = x;//s的数据域", "        s->next = p->next;//s指向下一个结点，p当前所指向结点的下一个", "        p->next = s;//p的下一个结点等于s", "        return 1;", "    }", "}", "\n", "//单链表删除操作:删除第i个结点(s是要删除的结点)", "\n", "int  DeleteList(LinkList L, int i)", "{", "    LNode* p, * s;", "    int j = 0;", "    p = L;//p从L开始", "    while (p->next != NULL && j < i)", "    {", "        p = p->next;", "        j++;", "    }", "    if (p == NULL)", "    {", "        printf(\"删除位置不合理！\");", "        return 0;", "    }", "    else", "    {", "        s = p->next;//s所指向的结点是p的下个结点", "        p->next = s->next;//等价于p->next=p->next->next", "        free(s);//在内存里释放掉s所指向结点的空间", "        return 1;", "    }", "}", "\n", "void main()", "{", "    int n;//n个结点", "    printf(\"请在键盘中输入链表有几个结点:\\n\");", "    scanf_s(\"%d\", &n);//输入n个结点", "\n", "//", "带头结点\n", "//", "LinkList L = (LinkList)malloc(sizeof(LNode));", "//", "空链表的创建\n", "//", "L->", "next", " = NULL;", "//", "指针域为空\n", "//", "\n", "//", "不带头结点尾插法建立单链表L\n", "//", "LinkList L = CreLinkListTailNo(n);\n", "//", "printf(", "\"不带头结点尾插法--输出建立后的单链表:\\n\"", ");\n", "//", "OutPut(L); ", "//", "输出建立后的单链表\n", "//", "\n", "//", "不带头结点头插法建立单链表L\nLinkList L = CreLinkListNo(n);\nprintf(", "\"不带头结点头插法--输出建立后的单链表:\\n\"", ");\nOutPut(L); ", "//", "输出建立后的单链表\n", "//", "\n\n", "//", "CreLinkListTail(L, n);", "//", "尾插入法建立单链表L\n", "//", "printf(", "\"尾插法--输出建立后的单链表:\\n\"", ");\n", "//", "OutPut(L); ", "//", "输出建立后的单链表\n\n", "//", "CreLinkListHead(L, n);", "//", "头插法建立单链表L\n", "//", "printf(", "\"头插法--输出建立后的单链表:\\n\"", ");\n", "//", "OutPut(L);", "//", "输出建立后的单链表\n\n", "//", "DeleteList(L, ", "3", ");", "//", "删除第", "3", "个位置的元素\n", "//", "printf(", "\"输出删除后的单链表:\\n\"", ");\n", "//", "OutPut(L);", "//", "输出删除成功后的单链表\n\n", "//", "InsertList(L, ", "3", ", ", "100", ");", "//", "在第", "3", "个位置插入一个数据元素", "100", "\n", "//", "printf(", "\"输出插入后的单链表:\\n\"", ");\n", "//", "OutPut(L);", "//", "输出插入成功后的单链表\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在邻接表中&amp;#xff0c;边实际上就是顶点的一部分&amp;#xff0c;你可以把它们都放到顶点的结构体中&amp;#xff0c;也没问题。这个地方把它单独抽象出来是为了让整个数据结构更加清晰。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构，图的邻接表存储结构为什么要设三个结构体？", ["\n", "typedef struct VNode\n{\n\tVerTexType data;         //顶点信息\n\tArcNode *firstarc;       //指向第一条依附该顶点的边的指针\n}VNode,AdjList[Num];\n\ntypedef struct ArcNode           //边结点\n{\n\tint adjvex;                  //该边所指向的顶点的位置\n\tstruct ArcNode *nextarc;     //指向下一条边的指针\n\tOtherInfo info;              //和边相关的信息(权值等)\n}ArcNode;\n\ntypedef struct\n{\n\tAdjList vertices;      //存放各个顶点的数组\n\tint vexnum, arcnum;    //图的当前顶点数和弧数\n}ALGraph;\n", "\n\n", "为什么要定义顶点，边，图三个结构体？", "\n\n", "我知道图的邻接表是 所有 顶点串起来的链表 的数组，", "\n\n", "所以顶点结构体是头结点，边结构体存储的是与顶点相连的边和点的信息，图结构体是将所有链表封装在一起。", "\n\n", "我疑惑的是为什么要将顶点和边结构体区别开来？（可以将顶点和边的信息都放在数据域？）图结构体的边数也不是必要的吧？", "\n\n", "感谢解答！"]], "Tag": "程序设计"}
{"Answer": "```\r\n改为：\r\n q[i]=&amp;h[i];//q[i]是指针数组，每个元素都是指针，没有初始化，不能*q[i]=h[i]\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针数组指向结构体类型数组的问题", [" #include<stdio.h>\n#include<stdlib.h>\nstruct student\n{\n    char num;\n    char name[10];\n    int grade;\n};\n\nvoid swap(struct student *p[],int n)\n{\n    int k,m,i,j;\n    struct student *d;\n    k=0;m=n-1;\n    while(k<m)\n    {\n        j=m-1;m=0;\n        for(i=k;i<=j;i++)\n        if(((*p[i]).grade)>((*p[i+1]).grade))\n        {d=p[i];p[i]=p[i+1];p[i+1]=d;m=i;}\n        j=k+1;k=0;\n        for(i=m;i>=j;i--)\n        if(((*p[i-1]).grade)>((*p[i]).grade))\n        {d=p[i];p[i]=p[i-1];p[i-1]=d;k=i;}\n    }\n    return;\n}\n\nmain()\n{\n    int i;  \n    struct student *q[13];\n    struct student h[13]=\n    {\n        {2,\"Lin\",92},\n        {3,\"Zhang\",87},\n        {4,\"Zhao\",72},\n        {5,\"Ma\",91},\n        {9,\"Zhen\",85},\n        {11,\"Wang\",100},\n        {12,\"Li\",86},\n        {13,\"Xu\",83},\n        {16,\"Mao\",78},\n        {17,\"Hao\",95},      \n        {20,\"Lu\",82},\n        {21,\"Song\",76},\n        {22,\"Wu\",88}\n    };  \n    for(i=0;i<13;i++)\n**      *q[i]=h[i];**\n    printf(\"学号(num)  姓名(name)  成绩(grade)\\n\");\n    for(i=0;i<13;i++)\n        printf(\"  %02d    %s   %d\\n\",h[i].num,h[i].name,h[i].grade);\n    printf(\"------------------------------\\n\");\n    swap(q,13);\n    for(i=0;i<13;i++)\n    printf(\"  %02d    %s   %d\\n\",(*q[i]).num,(*q[i]).name,(*q[i]).grade);\n}\n\n", "\n\n", "0x00BB16B0 处有未经处理的异常: 0xC0000005: 写入位置 0xCCCCCCCC 时发生访问冲突。（代码中加粗的行： *q[i]=h[i];），这是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "这只是个变量名称，没啥意义，可能是习惯吧，就像for循环，喜欢用i", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言中下划线都有什么用，比如说下面这个struct结构体类型", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以通过重载QDataStream类&amp;#xff0c;具体方法参考&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/houqd2012/article/details/25070987\"&gt;https://blog.csdn.net/houqd2012/article/details/25070987&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/qfl_sdu/article/details/117406212\"&gt;https://blog.csdn.net/qfl_sdu/article/details/117406212&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["value为自定义结构体的QMap容器如何序列化和反序列化？", ["typedef struct struct1{", "\n\n", "    double x;", "\n\n", "    double y;", "\n\n", "} Point;", "\n", "\ntypedef struct struct2{", "\n\n", "    QString name;", "\n\n", "    struct1 point;", "\n\n", "} Project;", "\n\n", " 请问，QMap< int, struct2 >怎么序列化啊？key值是int型，value值是struct2型，好像不能直接序列化？？？有没有什么方法将这种情况序列化啊？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;仅供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;malloc.h&amp;gt;&lt;/span&gt;\nint **newarr2d(int rows,int cols) {\n    int **p,i;\n\n    p&amp;#61;(int **)malloc(rows*sizeof(int *));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (NULL&amp;#61;&amp;#61;p) &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;rows;i&amp;#43;&amp;#43;) {\n        p[i]&amp;#61;(int *)malloc(cols*sizeof(int));\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (NULL&amp;#61;&amp;#61;p[i]) &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    }\n    return p;\n}\nvoid deletearr2d(int **p,int rows) {\n    int i;\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;rows;i&amp;#43;&amp;#43;) {\n        free(p[i]);\n    }\n    free(p);\n}\nint main() {\n    int **arr2d,i,j,r,c;\n\n    r&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    c&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在堆中开辟一个&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;×&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;的二维int数组\n    arr2d&amp;#61;newarr2d(r,c);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;r;i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;c;j&amp;#43;&amp;#43;) {\n            arr2d[i][j]&amp;#61;i*c&amp;#43;j;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;r;i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;c;j&amp;#43;&amp;#43;) {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34; %2d&amp;#34;&lt;/span&gt;,arr2d[i][j]);\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    deletearr2d(arr2d,r);\n\n    r&amp;#61;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    c&amp;#61;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在堆中开辟一个&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;×&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;的二维int数组\n    arr2d&amp;#61;newarr2d(r,c);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;r;i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;c;j&amp;#43;&amp;#43;) {\n            arr2d[i][j]&amp;#61;i*c&amp;#43;j;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;r;i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;c;j&amp;#43;&amp;#43;) {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34; %2d&amp;#34;&lt;/span&gt;,arr2d[i][j]);\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    deletearr2d(arr2d,r);\n\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;11&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;13&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;14&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;17&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;18&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;19&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;13&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;14&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["使用labview生成DLL在C++中调用，生成的.h文件中数组结构体怎么理解", ["使用labview生成DLL在C++中调用，生成的.h文件中数组结构体怎么理解。", "\n", "typedef struct {", "    int32_t dimSizes[2];", "    double Numeric[1];", "} DoubleArrayBase;", "**typedef DoubleArrayBase ", "DoubleArray;", "typedef struct {", "    int32_t dimSize;", "    double elt[1];", "} DoubleArray1Base;", "typedef DoubleArray1Base **DoubleArray1;", "typedef struct {", "    DoubleArray1 Amplitudes;", "} Cluster;", "typedef struct {", "    int32_t dimSize;", "    Cluster Locations[1];", "} ClusterArrayBase;", "typedef ClusterArrayBase **ClusterArray;", "typedef struct {", "    DoubleArray1 _2ndDerivatives;", "} Cluster1;", "typedef struct {", "    int32_t dimSize;", "    Cluster1 Locations[1];", "} Cluster1ArrayBase;", "typedef Cluster1ArrayBase **Cluster1Array;", "\n", "/*!", "\n", "FindPeak", "/", "void __cdecl FindPeak(*", "DoubleArray ", "Array", ", double threshold,", "  uint16_t peaksValleys, int32_t width, int32_t found[],", "  ClusterArray *Amplitudes, Cluster1Array *_2ndDerivatives, int32_t len);", "\n", "其中，FindPeak函数中在VI中定义的输入数组是二维数组，但labview生成.h文件中二维数组的格式是结构体DoubleArray *Array,完全不知道咋用了", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "看你是不是指针，指针用-&gt;，一般变量用 .", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体，我用点不行，必须要用->才编译成功，这是为什么", ["#include", "\n#include", "\n#include", "\n#define LEN sizeof(struct student)", "\nstruct student", "\n{", "\n    int number;", "\n    struct student *pnext;", "\n};", "\nint n;", "\nstruct student *creat(void)", "\n{", "\n    struct student *head,*p1,*p2;", "\n    n=0;", "\n    p1=p2=(struct student *)malloc(LEN);", "\n    head=NULL;", "\n    scanf(\"%d\",&p1.number);", "\n    while(p1.number!=0)", "\n    {", "\n        n++;", "\n        if(n==1) head=p1;", "\n        else p2->pnext=p1;", "\n        p2=p1;", "\n        p1=(struct student *)malloc(LEN);", "\n        scanf(\"%d\",&p1.number);", "\n    }", "\n    p2->pnext=NULL;", "\n    return(head);", "\n}", "\nmain()", "\n{", "\n    struct student *p;", "\n    p=creat();", "\n    while(p->pnext!=NULL)", "\n    {", "\n        printf(\"%d\\n\",p->number);", "\n        p=p->pnext;", "\n    }", "\n    return 0;", "\n } ", "\n\n", "17 17  E:\\学习\\C源程序\\C红书刷题\\第三章_结构数据\\链表\\创建动态链表\\未命名2.cpp  [Error] request for member 'number' in 'p1', which is of pointer type 'student*' (maybe you meant to use '->' ?)", "\n 这是错误提示，然后我把.改成了->就解决了。为什么要这样,  点和->作用不是一样的么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;错误原因&amp;#xff1a;&lt;br /&gt;在C&amp;#43;&amp;#43;中&amp;#xff0c;函数外面只允许声明&amp;#xff0c;不允许其他操作&amp;#xff08;如赋值等&amp;#xff09;&amp;#xff0c;其它操作需要放在函数里面。&lt;br /&gt;所以定义全局变量是要不就在定义时进行初始化&amp;#xff0c;要不就需要在函数里面进行赋值。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["给结构体类型的数组赋值", ["//创建方向试探数组结构体", "typedef struct{", "    int incX;//x方向的增量", "    int incY;//y方向的增量", "}Direction;", "//给方向试探数组结构体赋值", "Direction direct[4];", "direct[0].incX=1;direct[0].incY=0;//向左移动一格", "direct[1].incX=0;direct[1].incY=1;//向下移动一格", "direct[2].incX=-1;direct[2].incY=0;//向右移动一格", "direct[3].incX=0;direct[3].incY=-1;//向上移动一格", "如题，想给结构体类型的数组赋值，该怎么操作呢?"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;I think you're going about this the wrong way. If you were wanting to use the C library, you would use the C library to read the file.&lt;/p&gt;\n\n&lt;p&gt;Don't use cgo purely to have struct definitions, you should create these in Go yourself. You could then write the appropriate marshal / unmarshal code to read from the raw bytes. &lt;/p&gt;\n\n&lt;p&gt;A quick Google shows that someone has already done the work required to convert a look of the relevant C library to Go. See the &lt;a href=\"https://github.com/ericlagergren/go-gnulib/tree/master/utmp\" rel=\"nofollow noreferrer\"&gt;utmp repository&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;A short example of how this could be used is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/ericlagergren/go-gnulib/utmp\"\n)\n\nfunc handleError(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc byteToStr(b []byte) string {\n    i := bytes.IndexByte(b, 0)\n    if i == -1 {\n        i = len(b)\n    }\n    return string(b[:i])\n}\n\nfunc main() {\n    list, err := utmp.ReadUtmp(utmp.UtmpxFile, 0)\n    handleError(err)\n    for _, u := range list {\n        fmt.Println(byteToStr(u.User[:]))\n    }\n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can view the &lt;a href=\"https://godoc.org/github.com/ericlagergren/go-gnulib/utmp\" rel=\"nofollow noreferrer\"&gt;GoDoc&lt;/a&gt; for the &lt;code&gt;utmp&lt;/code&gt; package for more information.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何在go中将字节转换为struct（c struct）？", ["\n\n", "package main\n\n/*\n#define _GNU_SOURCE 1\n#include <stdio.h>\n#include <stdlib.h>\n#include <utmpx.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nchar *path_utmpx = _PATH_UTMPX;\n\ntypedef struct utmpx utmpx;\n*/\nimport \"C\"\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n)\n\ntype Record C.utmpx\n\nfunc main() {\n\n  path := C.GoString(C.path_utmpx)\n\n  content, err := ioutil.ReadFile(path)\n  handleError(err)\n\n  var records []Record\n\n  // now we have the bytes(content), the struct(Record/C.utmpx)\n  // how can I cast bytes to struct ?\n}\n\nfunc handleError(err error) {\n  if err != nil {\n    panic(\"bad\")\n  }\n}\n", "\n\n", "I'm trying to read ", "content", " into ", "Record", " \nI have asked a few related questions.", "\n\n", "Cannot access c variables in cgo", "\n\n", "Can not read utmpx file in go", "\n\n", "I have read some articles and posts but still cannot figure out a way to do this. ", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Work&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; Name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; Sex;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Age;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; Salary;\n}Worker;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Worker works[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i; \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, works[i].Name);\n \n        &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n \n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, &amp;amp;works[i].Sex);\n \n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %f&amp;#34;&lt;/span&gt;, &amp;amp;works[i].Age, &amp;amp;works[i].Salary);\n \n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s,%c,%d,%f\\n&amp;#34;&lt;/span&gt;, works[i].Name, works[i].Sex, works[i].Age, works[i].Salary);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/77466424755616.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["请编写程序：定义一个结构体（包括职工名、性别、年龄、工资四个域），按此结构体类型定义一个结构体数组，然后从键盘输入每个结构体元素所需的数据，最后逐个输出这些元素的数据(可设数组只有三个元素)。", ["谢谢各位神仙 下面是部分代码", "int main(){", "\n", "//......", "\n\n", "return", " ", "0", ";\n", "\n", "}", "\n", "输入格式:", "\n", "scanf(\"%s\", works[i].Name);", "\n", "getchar();", "\n", "scanf(\"%c\", &works[i].Sex);", "\n", "scanf(\"%d %f\", &works[i].Age, &works[i].Salary);", "\n", "输出格式：", "\n", "printf(\"%s,%c,%d,%f\\n\", works[i].Name,works[i].Sex, works[i].Age, works[i].Salary);", "\n", "输入样例：", "\n", "张三 M 23 5000", "\n", "李四 F 32 8000", "\n", "王五 M 25 6000", "\n", "输出样例：", "\n", "张三,M,23,5000.000000", "李四,F,32,8000.000000", "王五,M,25,6000.000000"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a是个结构体变量&amp;#xff0c;你当然不能 int *head &amp;#61; &amp;amp;a了。得是结构体指针变量才行&amp;#xff0c;如例子所示的 struct text * head &amp;#61; &amp;amp;a;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体定义一个指针所表示", ["结构体经营的一个指针表示的是什么意思呀？我试过了。如果int *head=&a是错误的，哪位程序兄弟帮我看看"]], "Tag": "程序设计"}
{"Answer": "书籍:`C++ primer`\r\n这种形式的构造函数是创建的时候初始化，然后再调用构造函数。\r\n也就是说变量`label`的赋值完成后，才会执行构造函数里面的语句。\r\nC++结构体和类相似，有部分不同。具体的看书就明白了。", "Konwledge_Point": "数据封装——结构体", "Question": ["C++结构体如何定义构造函数？？", ["问题：", "在网上看到别人写的c++定义构造函数的代码如下：", "\n\n", "struct Gnode{\n    int label;    //\n    vector<Gnode *> nbs;\n    Gnode(int x): label(x) {}    //构造函数  ？  \n};\n", "\n\n", "\n请问，这个第3行构造函数为什么可以这样写，为何label（x）可以写在大括号的前面？", "\n不是应该写成：", "\n\n", "\nstruct Gnode{\n    int label;    //\n    vector<Gnode *> nbs;\n    Gnode(int x){\n        label=x; \n    }    \n\n};\n", "\n\n", "这种形式吗？", "对C++结构体部分不太熟悉，求大佬解释一下？", "\n另外我如果想补充一下自己的这些知识，有啥推荐的书吗？ 重新学一遍大一时候学的C++课本？？"]], "Tag": "程序设计"}
{"Answer": "```\r\nid是学号，长度6，只能放5个字符，后面还有换行符。\r\n还有\r\nstudent[0] [1] [2]\r\n而不是 [1] [2] [3]，数组从0开始编号的。\r\n因为你student长度是3，你这么写，越界了。\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体基础题目求解（感谢）", ["\n\n", "定义一个学生结构体，然后输入3个学生的学号和数学、英语、计算机成绩，要求： ", "\n(1) 计算每一个学生的平均成绩。 ", "\n(2) 计算每门课程的平均成绩。 ", "\n最后输出3个同学的所有信息。", "\n\n", "整体就后面的第三位学生输出有问题。但是不知道问题出在哪，因为是通过一个for循环来输出的。", "\n\n", "感谢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;D:错误原因&amp;#xff1a;等号两侧类型不一致&amp;#xff0c;一个是student类型指针&amp;#xff0c;一个是int型指针&amp;#xff0c;除非用强制转换&amp;#xff0c;否则不能直接相等&lt;br /&gt;A:代表的是stu[0]中的num元素即20&lt;br /&gt;B:代表的是stu[0]&amp;#xff0c;即student结构体类型{1001&amp;#xff0c;20}&lt;br /&gt;C:同A。&lt;br /&gt;地址取成员用&amp;#34;-&amp;gt;&amp;#34;&amp;#xff0c;变量去成员用&amp;#34;.&amp;#34;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体的引用问题", ["见图，有关结构体的引用，", "\n", "\n", "为什么选D呢，再麻烦把A,B,C代表什么说一下，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;for循环录入剩余3个学生数据后&amp;#xff0c;用fopen打开文件&amp;#xff0c;用fprintf逐个写入文件就是了。&lt;br /&gt;读取文件用fscanf函数读取就可以了&lt;br /&gt;参考如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n\nstruct stud \n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; id;\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    char banj[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    char sex;\n    float scorel;\n    float score2;\n    float total;\n};\n\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    struct stud s[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]&amp;#61;{ {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;111&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;一班&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;70&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;150&lt;/span&gt;},{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;112&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;李四&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;二班&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;70&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;150&lt;/span&gt;} }; \n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i;\n    FILE* fp;\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入3个学生的信息&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入学号&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].id); getchar(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;接收回车符\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].name); getchar(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;接收回车符\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入班级&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].banj); getchar(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;接收回车符\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入性别(F/M)&amp;#xff1a;&amp;#34;&lt;/span&gt;); \n        s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].sex &amp;#61; getchar();\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入成绩1&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].scorel);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入成绩2&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].score2);\n        s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].total &amp;#61; s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].scorel &amp;#43; s[i&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;].score2;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((fp&amp;#61;fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;a.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;)) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;文件打开失败\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    //写入文件\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        fprintf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %s %s %c %f %f %f\\n&amp;#34;&lt;/span&gt;,s[i].id,s[i].name,s[i].banj,s[i].sex,s[i].scorel,s[i].score2,s[i].total);\n    }\n    fclose(fp);\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;读取文件并显示\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;((fp&amp;#61;fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;a.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;))&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;文件打开失败\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!feof(fp))\n    {\n        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %s %s %c %f %f %f\\n&amp;#34;&lt;/span&gt;,&amp;amp;s[i].id,s[i].name,s[i].banj,&amp;amp;s[i].sex,&amp;amp;s[i].scorel,&amp;amp;s[i].score2,&amp;amp;s[i].total);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s[i].id &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)//避免读入空行\n        {\n            \n            &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %s %s %c %f %f %f\\n&amp;#34;&lt;/span&gt;,s[i].id,s[i].name,s[i].banj,s[i].sex,s[i].scorel,s[i].score2,s[i].total);\n            i&amp;#43;&amp;#43;;\n        }\n        \n    }\n    fclose(fp);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体变量的初始化，运用", ["1)定义一个结构体类型stud (int id, char name[20], char banj[30], char sex, float scorel,float score2, float total)", "2)定义 个结构体数组s[5]，并初始化前2个人的数据，从键盘输入3个人的数据。", " 3)将这5个人的数据写入到文件a.txt中", "4)从a.txt中读出数据，存放在s[5]中，用循环实现5个人数据的计算并屏幕输出。"]], "Tag": "程序设计"}
{"Answer": "C++的话，可以放在不同的namespace，C的话，必须用两个名字。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体类型名可以和共同体类型名相同吗", ["结构体类型名可以和共同体类型名相同吗，还有就是不能对共同体变量整体赋值？结构体就可以整体赋值啊，共同体不能是什么情况"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先&amp;#xff0c;你的最大总分比较有问题&amp;#xff0c;应该把max &amp;#61; stu[i].S和j&amp;#61;i一起放在if中&amp;#xff0c;你少了{}&amp;#xff0c;然后&amp;#xff0c;是sum/30&amp;#xff0c;sum/10只是每个人的平均总成绩&amp;#xff0c;而不是每个人的平均成绩&amp;#xff0c;再然后&amp;#xff0c;你的最后输出分数数组时单独输出&amp;#xff0c;没有把整个数组输出&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["R7-10 使用结构体数组求10个学生三门课总平均成绩，及最高分学生信息;如何用C++实现？", ["这道题我改了好几遍愣是没改对过一次啊（@A@）求大佬救命！！！", "\n\n", "学生结构体数组管理10名学生的信息，分别是学号、姓名、3门课的成绩(double型)，从键盘输入10名学生的全部信息，打印出总的平均成绩与最高分学生信息", "\n\n", "输入格式:", "\n\n", "依次输入10名学生的信息，包括学号char num[6]、姓名char name[8]、三门课分数 double score[3]", "\n\n", "输出格式:", "\n\n", "输出10名学生总的平均成绩，与3门课程总成绩最高的学生分数，所有成绩输出保留小数点后2位小数", "\n\n", "输入样例:", "\n\n", "在这里给出一组输入。例如：", "\n\n", "\n", "101 wang 93 89 87\n102 li 86 80 78\n103 zhao 76 40 98\n104 ma 77 70 84\n105 han 70 67 60\n106 zhang 99 97 95\n107 zhou 88 89 88\n108 chen 87 88 85\n109 yang 72 70 69\n110 liu 78 80 83", "\n\n", "输出样例:", "\n\n", "在这里给出相应的输出。例如：", "\n\n", "\n", "80.77\n106 zhang 99.00 97.00 95.00", "\n\n", "#include<iostream>", "\n#include<iomanip>", "\nusing namespace std;", "\nstruct student", "\n{", "\n    char num[6];", "\n    char name[8];", "\n    double score[3];", "\n    double S;", "\n}stu[10];", "\nint main()", "\n{", "\n    //void input(struct Student stu[]);", "\n    double sum=0;", "\n    for(int i=0;i<10;i++)", "\n    {", "\n        cin>>stu[i].num>>stu[i].name;//分别输入学号，名字", "\n        for(int j=0;j<3;j++)", "\n        {", "\n            cin>>stu[i].score[j];//输入成绩", "\n            sum+=stu[i].score[j];//所有人总分", "\n            stu[i].S+=stu[i].score[j];//单人三科总成绩", "\n        }", "\n    }", "\n    int j;", "\n    int max=stu[0].S;", "\n    for(int i=1;i<=10;i++)", "\n    {", "\n        if(stu[i].S>max)", "\n            max=stu[i].S;j=i;", "\n    }", "\n    cout<<fixed<<setprecision(2)<<sum/10<<endl;", "\n    cout<<stu[j].num[6]<<stu[j].name[8]<<fixed<<setprecision(2)<<stu[j].score[3]<<endl;", "\n    return 0;", "\n} "]], "Tag": "程序设计"}
{"Answer": "```\r\n sp * p2=(sp *)malloc(10*sizeof(sp)); \r\n```\r\np2 既是指针的首地址。。", "Konwledge_Point": "数据封装——结构体", "Question": ["malloc怎么返回结构体指针数组的首地址", ["typedef struct student{", "\nint id;", "\n\n", "}s ,*sp;", "\n\n", "main(){", "\nsp p1=(sp)malloc(10*sizeof(sp));        // 假设1", "\n\n", "sp * p2=(sp *)malloc(10*sizeof(sp));   // 假设2 ", "\n\n", "}", "\n如果我要malloc一个长度为10 的结构体指针数组的话", "\n假设1 和假设2 哪个返回了结构体指针数组的首地址?", "\n哪个正确呢"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;void deleteOldby(){//删除学生信息\n \n\tint i,j;\n\tchar x[20];//char *x; *x只是指针&amp;#xff0c;没有分配内存\n\tprintf(&amp;#34;Please input the id or name:\\n&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;, &amp;amp;x);\n\t\n\tfor (i &amp;#61; 0; i &amp;lt; NUM; i&amp;#43;&amp;#43;)\t\n\t{\n\t\tif ((strcmp(stu[i].id , x))&amp;#61;&amp;#61;0)\n\t\t{   //找到该信息&amp;#xff0c;索引为i\n\t\t\tfor(j&amp;#61;i;j&amp;lt;NUM;j&amp;#43;&amp;#43;){ //for( j&amp;#61;0;j&amp;lt;NUM;j&amp;#43;&amp;#43;){  从i开始把后面的往前挪\n\t\t\t\tstu[j]&amp;#61;stu[j&amp;#43;1];}\n\t\t\tprintf(&amp;#34;删除成功&amp;#xff01;\\n&amp;#34;);\n            break;  //删除成功&amp;#xff0c;跳出循环  以上修改下同\n\t\t}\n\t\telse if((strcmp(stu[i].name , x))&amp;#61;&amp;#61;0)\n\t\t{\n\t\t\tfor( j&amp;#61;i;j&amp;lt;NUM;j&amp;#43;&amp;#43;){\n\t\t\t\tstu[j]&amp;#61;stu[j&amp;#43;1];}\n\t\t\tprintf(&amp;#34;删除成功&amp;#xff01;\\n&amp;#34;);\n            break;\n\t\t}\t\t\n\t}\n    if(i&amp;#61;&amp;#61;NUM)  printf(&amp;#34;删除失败&amp;#xff01;\\n&amp;#34;);//删除成功&amp;#xff0c;跳出循环时i&amp;lt;NUM的&amp;#xff0c;只有数组被全部遍历一次的时候&amp;#xff0c;i才会&amp;#61;NUM    \n\tgetch();\n \n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言，删除结构体学生信息", ["为什么输入信息后无法显示后面内容？", "\n\n", "部分代码如下：", "\n\n", "\n", "void deleteOld(){//删除学生信息\n\n\tint i,j;\n\tchar *x;\n\tprintf(\"Please input the id or name:\\n\");\n\tscanf(\"%s\", &x);\n\t\n\tfor (i = 0; i < NUM; i++)\t\n\t{\n\t\tif ((strcmp(stu[i].id , x))==0)\n\t\t{\n\t\t\tfor( j=0;j<NUM;j++){\n\t\t\t\tstu[j]=stu[j+1];}\n\t\t\tprintf(\"删除成功！\\n\");\n\t\t}\n\t\telse if  ((strcmp(stu[i].name , x))==0)\n\t\t{\n\t\t\tfor( j=0;j<NUM;j++){\n\t\t\t\tstu[j]=stu[j+1];}\n\t\t\tprintf(\"删除成功！\\n\");\n\t\t}\n\n\t\telse\n\t\t\tprintf(\"删除失败！\\n\");\n\t}\n\tgetch();\n\n}"]], "Tag": "程序设计"}
{"Answer": "给你看看我之前写的管理系统里面的保存类信息吧：\r\n\r\n```\r\nclass Student//学生类\r\n{\r\npublic:\r\n\tstring id;//定义见下面的show\r\n\tstring name;\r\n\tstring sex;\r\n\tstring cl;\r\n\tstring native;\r\n\tstring birthday;\r\n\tstring hobby;\r\n\tstring family;\r\n\tstring address;\r\n\r\n\tvoid input(string i, string n, string s, string c, string _native, string b, string h, string f, string _address)//设置类的变量\r\n\t{\r\n\t\tid = i;\r\n\t\tname = n;\r\n\t\tsex = s;\r\n\t\tcl = c;\r\n\t\tnative = _native;\r\n\t\tbirthday = b;\r\n\t\thobby = h;\r\n\t\tfamily = f;\r\n\t\taddress = _address;\r\n\t}\r\n\r\n\tvoid show()\r\n\t{\r\n\t\tcout &lt;&lt; \"学号：\" &lt;&lt; id \r\n\t\t\t&lt;&lt; \" 姓名：\" &lt;&lt; name \r\n\t\t\t&lt;&lt; \" 性别：\" &lt;&lt; sex \r\n\t\t\t&lt;&lt; \" 班级：\" &lt;&lt; cl \r\n\t\t\t&lt;&lt; \" 籍贯：\" &lt;&lt; native \r\n\t\t\t&lt;&lt; \" 生日：\" &lt;&lt; birthday \r\n\t\t\t&lt;&lt; \" 爱好：\" &lt;&lt; hobby \r\n\t\t\t&lt;&lt; \" 家庭状况：\" &lt;&lt; family \r\n\t\t\t&lt;&lt; \" 住址：\" &lt;&lt; address &lt;&lt; endl;\r\n\t}\r\n\r\n\tvoid input(ifstream &amp; is)//从文件读取\r\n\t{\r\n\t\tis &gt;&gt; id &gt;&gt; name &gt;&gt; sex &gt;&gt; cl &gt;&gt; native &gt;&gt; birthday &gt;&gt; hobby &gt;&gt; family &gt;&gt; address;\r\n\t}\r\n\r\n\tvoid output(ofstream &amp; os)//写入文件\r\n\t{\r\n\t\tos &lt;&lt; id\r\n\t\t\t&lt;&lt; \" \" &lt;&lt; name\r\n\t\t\t&lt;&lt; \" \" &lt;&lt; sex \r\n\t\t\t&lt;&lt; \" \" &lt;&lt; cl \r\n\t\t\t&lt;&lt; \" \" &lt;&lt; native \r\n\t\t\t&lt;&lt; \" \" &lt;&lt; birthday \r\n\t\t\t&lt;&lt; \" \" &lt;&lt; hobby \r\n\t\t\t&lt;&lt; \" \" &lt;&lt; family \r\n\t\t\t&lt;&lt; \" \" &lt;&lt; address \r\n\t\t\t&lt;&lt; endl;\r\n\t}\r\n\r\n};\r\n```\r\n之后调用这个类时候，读写信息在这里：\r\n\r\n```\r\n\tvoid save(string filename)//保存文件\r\n\t{\r\n\t\tofstream write(filename.c_str(), ios::out);\r\n\t\twrite &lt;&lt; m_count &lt;&lt; endl;//\r\n\t\tfor (int i = 0; i &lt; m_count; i++)\r\n\t\t{\r\n\t\t\tm_student[i].output(write);\r\n\t\t}\r\n\r\n\t\twrite.close();\r\n\t}\r\n\r\n\tvoid load(string filename)//读取文件\r\n\t{\r\n\t\tifstream read(filename.c_str(), ios::in);\r\n\t\tif (read.peek() == EOF)\r\n\t\t{\r\n\t\t\tread.close();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tread &gt;&gt; m_count;\r\n\t\tfor (int i = 0; i &lt; m_count; i++)\r\n\t\t{\r\n\t\t\tm_student[i].input(read);\r\n\t\t}\r\n\r\n\t\tread.close();\r\n\t}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["对于一个结构体，如何能在执行程序后将其存储起来，下次执行程序时可以继续调用（修改）", ["以下是我写的一个通讯录，但是它的使用仅限于一次程序执行，如何每次执行都可以使用之前的数据", "\n//Book.h", "\n#include", "\nusing namespace std;", "\nconstexpr auto Max = 500;", "\n\n", "//定义联系人的结构体", "\nstruct person", "\n{", "\n    string name;", "\n    double age = 0;", "\n    string phone;", "\n    string address;", "\n    int sex = 0;", "\n};", "\n\n", "//定义通讯录数组", "\nstruct adds", "\n{", "\n    person presonarray[Max];", "\n    int size = 0;", "\n};", "\nclass interface", "\n{", "\n\n", "};", "\n\n", "//定义工具类", "\nclass tool", "\n{", "\npublic:int is_number(string x);", "\n      double change(string x);", "\n\n", "};", "\n\n", "//定义通讯本", "\n\n", "class address_book", "\n{", "\npublic:", "\n    int compare(string name);", "\n    void showmenu();         //显示菜单", "\n    void add();              //添加联系人", "\n    void show_contacts();    //显示联系人", "\n    void seek();             //查找联系人", "\n    void revise();           //修改联系人", "\n    void all_clear();        //清空所有联系人", "\n    void delete_person();    //删除联系人", "\n    adds a;", "\n};", "\n\n", "//Book.cpp", "\n#include\"Book.h\"", "\n\n", "int address_book::compare(string name)", "\n{", "\n    for (int i = 0; i < a.size; i++) ", "\n    {", "\n        if (a.presonarray[i].name == name) ", "\n        {", "\n            return i;", "\n        }", "\n    }", "\n    return -1;", "\n}", "\n\n", "//显示菜单", "\nvoid address_book::showmenu()", "\n{", "\n    cout << \"*****************************\" << endl;", "\n    cout << \"*****   1、添加联系人   *****\" << endl;", "\n    cout << \"*****   2、查找联系人   *****\" << endl;", "\n    cout << \"*****   3、显示联系人   *****\" << endl;", "\n    cout << \"*****   4、删除联系人   *****\" << endl;", "\n    cout << \"*****   5、修改联系人   *****\" << endl;", "\n    cout << \"*****   6、清空联系人   *****\" << endl;", "\n    cout << \"*****   0、退出通讯录   *****\" << endl;", "\n    cout << \"*****************************\" << endl;", "\n}", "\n\n", "//添加联系人", "\nvoid address_book::add() ", "\n{", "\n    tool tool;", "\n    cout << \"请输入联系人的姓名：\" << endl;", "\n    string name;", "\n    cin >> name;", "\n    a.presonarray[a.size].name = name;", "\n    string age;", "\n    double  num = 0;", "\n    do ", "\n    {", "\n        cout << \"年龄（输入正整数）：\" << endl;", "\n        cin >> age;", "\n        int x = tool.is_number(age);", "\n        if (x == 1) ", "\n        {", "\n            break;", "\n        }", "\n        else ", "\n        {", "\n            cout << \"输入有误，请输入正整数\" << endl;", "\n        }", "\n    } while (true);", "\n    num = tool.change(age);", "\n    a.presonarray[a.size].age = num;", "\n    while (true) ", "\n    {", "\n        cout << \"性别：  1、男  2、女（输入数字）\" << endl;", "\n        int sex = 0;", "\n        cin >> sex;", "\n        if (sex == 1 || sex == 2) ", "\n        {", "\n            a.presonarray[a.size].sex = sex;", "\n            break;", "\n        }", "\n        else ", "\n        {", "\n            cout << \"输入有误请重新输入\" << endl;", "\n        }", "\n    }", "\n    cout << \"电话：\" << endl;", "\n    string phone;", "\n    cin >> phone;", "\n    a.presonarray[a.size].phone = phone;", "\n    cout << \"地址\" << endl;", "\n    string address;", "\n    cin >> address;", "\n    a.presonarray[a.size].address = address;", "\n    a.size++;", "\n    cout << \"添加成功\" << endl;", "\n    system(\"pause\");", "\n    system(\"cls\");", "\n}", "\n\n", "//显示联系人", "\nvoid address_book::show_contacts() ", "\n{", "\n    if (a.size == 0) ", "\n    {", "\n        cout << \"暂无联系人\" << endl;", "\n        system(\"pause\");", "\n        system(\"cls\");", "\n    }", "\n    else ", "\n    {", "\n        for (int i = 0; i < a.size; i++) ", "\n        {", "\n            cout << \"姓名：\" << a.presonarray[i].name << \"\\t\";", "\n            cout << \"年龄：\" << a.presonarray[i].age << \"\\t\";", "\n            cout << \"性别：\" << (a.presonarray[i].sex == 1 ? \"男\" : \"女\") << \"\\t\";", "\n            cout << \"电话：\" << a.presonarray[i].phone << \"\\t\";", "\n            cout << \"地址：\" << a.presonarray[i].address << endl;", "\n        }", "\n        system(\"pause\");", "\n        system(\"cls\");", "\n    }", "\n\n", "}", "\n\n", "//查找联系人", "\nvoid address_book::seek() {", "\n    string name;", "\n    cout << \"请输入查找联系人的姓名：\" << endl;", "\n    cin >> name;", "\n    if (compare(name) == -1) {", "\n        cout << \"查无此人\" << endl;", "\n        system(\"pause\");", "\n        system(\"cls\");", "\n    }", "\n    else {", "\n        cout << \"姓名\" << a.presonarray[compare(name)].name << \"\\t\";", "\n        cout << \"年龄：\" << a.presonarray[compare(name)].age << \"\\t\";", "\n        cout << \"性别：\" << (a.presonarray[compare(name)].sex == 1 ? \"男\" : \"女\") << \"\\t\";", "\n        cout << \"电话：\" << a.presonarray[compare(name)].phone << \"\\t\";", "\n        cout << \"地址：\" << a.presonarray[compare(name)].address << endl;", "\n        system(\"pause\");", "\n        system(\"cls\");", "\n    }", "\n}", "\n\n", "//修改联系人的信息", "\nvoid address_book::revise() ", "\n{", "\n    cout << \"请输入需要修改联系人的姓名：\" << endl;", "\n    string name;", "\n    cin >> name;", "\n    int ret = compare(name);", "\n    if (ret == -1) {", "\n        cout << \"查无此人\" << endl;", "\n    }", "\n    else {", "\n        cout << \"姓名\" << a.presonarray[compare(name)].name << \"\\t\";", "\n        cout << \"年龄：\" << a.presonarray[compare(name)].age << \"\\t\";", "\n        cout << \"性别：\" << (a.presonarray[compare(name)].sex == 1 ? \"男\" : \"女\") << \"\\t\";", "\n        cout << \"电话：\" << a.presonarray[compare(name)].phone << \"\\t\";", "\n        cout << \"地址：\" << a.presonarray[compare(name)].address << endl;", "\n        cout << \"请输入联系人的姓名：\" << endl;", "\n        string name;", "\n        cin >> name;", "\n        a.presonarray[ret].name = name;", "\n        cout << \"年龄：\" << endl;", "\n        int age = 0;", "\n        cin >> age;", "\n        a.presonarray[ret].age = age;", "\n        while (true) ", "\n        {", "\n            cout << \"性别：  1、男  2、女\" << endl;", "\n            int sex = 0;", "\n            cin >> sex;", "\n            if (sex == 1 || sex == 2) {", "\n                a.presonarray[ret].sex = sex;", "\n                break;", "\n            }", "\n            else {", "\n                cout << \"输入有误请重新输入\" << endl;", "\n            }", "\n        }", "\n        cout << \"电话：\" << endl;", "\n        string phone;", "\n        cin >> phone;", "\n        a.presonarray[ret].phone = phone;", "\n        cout << \"地址\" << endl;", "\n        string address;", "\n        cin >> address;", "\n        a.presonarray[ret].address = address;", "\n        cout << \"修改成功\" << endl;", "\n        system(\"pause\");", "\n        system(\"cls\");", "\n\n", "}\n", "\n\n", "}", "\n\n", "//清除所有联系人", "\nvoid address_book::all_clear() {", "\n    for (int i = 0; i < a.size; i++) {", "\n        a.presonarray[i] = a.presonarray[a.size];", "\n    }", "\n    a.size = 0;", "\n    cout << \"清除成功\" << endl;", "\n    system(\"pause\");", "\n    system(\"cls\");", "\n}", "\n\n", "//删除选中的联系人", "\nvoid address_book::delete_person() {", "\n    cout << \"请输入要删除的联系人姓名：\" << endl;", "\n    string name;", "\n    cin >> name;", "\n    if (compare(name) == -1) {", "\n        cout << \"查无此人\" << endl;", "\n    }", "\n    else {", "\n        for (int i = compare(name); i < a.size; i++) {", "\n            a.presonarray[i] = a.presonarray[i + 1];", "\n        }", "\n        cout << \"删除成功\" << endl;", "\n        a.size--;", "\n    }", "\n    system(\"pause\");", "\n    system(\"cls\");", "\n\n", "}", "\n//判断字符串是否全部由数字组成", "\nint tool::is_number(string x) {", "\n    int n = 0;", "\n    n = x.length();", "\n    int a = 0;", "\n    for (int i = 0; i < n; i++) {", "\n        if (x[i] >= '0' && x[i] <= '9') {", "\n            a++;", "\n        }", "\n    }", "\n    if (a == n) {", "\n        return 1;", "\n    }", "\n    else {", "\n        return 0;", "\n    }", "\n}", "\n\n", "//将字符串变为整形", "\ndouble tool::change(string x) {", "\n    double n = x.length();", "\n    double num = 0;", "\n    for (int i = 0; i < n; i++) {", "\n        num += ((double)x[i] - 48) * pow(10, n - i - 1);", "\n    }", "\n    return num;", "\n}", "\n\n", "//main.cpp", "\n#include\"Book.h\"", "\nint main()", "\n{", "\n    address_book b;", "\n    tool tool;", "\n    while (true) ", "\n    {", "\n        b.showmenu();", "\n        string select;", "\n        cin >> select;", "\n        int select1 = (int)tool.change(select);", "\n        switch (select1) ", "\n        {", "\n        case 1:", "\n            b.add();", "\n            break;", "\n        case 2:", "\n            b.seek();", "\n            break;", "\n        case 3:", "\n            b.show_contacts();", "\n            break;", "\n        case 4:", "\n            b.delete_person();", "\n            break;", "\n        case 5:", "\n            b.revise();", "\n            break;", "\n        case 6:", "\n            b.all_clear();", "\n            break;", "\n        case 0:", "\n            system(\"cls\");", "\n            b.showmenu();", "\n            cout << \"欢迎下次使用\" << endl;", "\n            return 0;", "\n        default:", "\n            cout << \"请输入0~6之间的整数\" << endl;", "\n            system(\"pause\");", "\n            system(\"cls\");", "\n            break;", "\n        }", "\n    }", "\n    return 0;", "\n}", "\n\n", "\n", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "结构体指针可以是单个结构体也可以是结构体数组，取决于你给指针赋值怎么写，开辟或者指向的内容是数组还是单个的\r\n结构体可以定义数组，也可以定义数组的指针。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体的问题定义和赋值问题", ["在结构体中定义指针就相当于定义数组吗？还有在结构体中可以直接定义数组的话，如果可以的话，那么定义时和使用赋值时，有什么要求吗？"]], "Tag": "程序设计"}
{"Answer": "STUDENT* creatlink() {\r\n    char name[10],*t;\r\n    int i, n, num, s, r, w, h;\r\n    STUDENT *head, *p, *q;\r\n    printf(\"输入要录入的人数：\");\r\n    scanf(\"%d\", &amp;n);\r\n    printf(\"请依次录入学生的学号 姓名 及听说读写的分数\");\r\n    head = NULL;\r\n    q = NULL;\r\n    for (i = 0; i &lt; n; i++) {\r\n        p = (STUDENT *)malloc(sizeof(STUDENT));\r\n        scanf(\"%d%s%d%d%d%d\", &amp;num, name, &amp;s, &amp;r, &amp;w, &amp;h);\r\n        p-&gt;num = num;\r\n        strcpy(p-&gt;name,name);\r\n        p-&gt;SCAN.speach = s;\r\n        p-&gt;SCAN.hear = h;\r\n        p-&gt;SCAN.read = r;\r\n        p-&gt;SCAN.write = w;\r\n        if (head == NULL)\r\n          head = p;\r\n        \r\n        if(q != NULL)\r\n          q-&gt;next = p;\r\n        q = p;\r\n    }\r\n\r\n    return head;\r\n}", "Konwledge_Point": "数据封装——结构体", "Question": ["如何返回结构体指针？", ["小白新学链表   想用函数来表达一下 在函数返回值的地方遇到麻烦   请大佬们帮助", "\n\n", "typedef struct student {\n    char name[10];\n    int num;\n    struct scan {\n        int speach;\n        int read;\n        int write;\n        int hear;\n    }SCAN;\n    struct student *next;\n}STUDENT;\n", "\n\n", "用函数创建一个链表后   想返回头节点    如何以STUDENT*  返回函数值", "\n\n", "STUDENT* creatlink() {\n    char name[10],*t;\n    int i, n, num, s, r, w, h;\n    STUDENT *head, *p, *q;\n    printf(\"输入要录入的人数：\");\n    scanf(\"%d\", &n);\n    printf(\"请依次录入学生的学号 姓名 及听说读写的分数\");\n    head = NULL;\n    q = NULL;\n    for (i = 0; i < n; i++) {\n        p = (STUDENT *)malloc(sizeof(STUDENT));\n        scanf(\"%d%s%d%d%d%d\", &num, name, &s, &r, &w, &h);\n        p->num = num;\n        strcpy(p->name,name);\n        p->SCAN.speach = s;\n        p->SCAN.hear = h;\n        p->SCAN.read = r;\n        p->SCAN.write = w;\n        if (head == NULL) head = p;\n        else q->next = p;\n        q = p;\n    }\n\n    return *head;\n}\n", "\n\n", "编译时在", "\nreturn ", "head;  *号上", "\n说 不存在从 STUDENT 到STUDENT", " 的适当转换函数", "\n然后我删掉返回值上的*（return *head;） 后 输出的函数又不能用了", "\n\n", "求大佬帮助    全部代码在下面   ", "\n\n", "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct student {\n    char name[10];\n    int num;\n    struct scan {\n        int speach;\n        int read;\n        int write;\n        int hear;\n    }SCAN;\n    struct student *next;\n}STUDENT;\nSTUDENT* creatlink() {\n    char name[10],*t;\n    int i, n, num, s, r, w, h;\n    STUDENT *head, *p, *q;\n    printf(\"输入要录入的人数：\");\n    scanf(\"%d\", &n);\n    printf(\"请依次录入学生的学号 姓名 及听说读写的分数\");\n    head = NULL;\n    q = NULL;\n    for (i = 0; i < n; i++) {\n        p = (STUDENT *)malloc(sizeof(STUDENT));\n        scanf(\"%d%s%d%d%d%d\", &num, name, &s, &r, &w, &h);\n        p->num = num;\n        strcpy(p->name,name);\n        p->SCAN.speach = s;\n        p->SCAN.hear = h;\n        p->SCAN.read = r;\n        p->SCAN.write = w;\n        if (head == NULL) head = p;\n        else q->next = p;\n        q = p;\n    }\n\n    return *head;\n}\n\nvoid putlink(STUDENT *HEAD) {\n    STUDENT *t;\n    t = HEAD;\n    while (t != NULL) {\n        printf(\"%d\\t%s\\t听%d,说%d,读%d,写%d\", t->num, t->name, t->SCAN.hear, t->SCAN.speach, t->SCAN.read, t->SCAN.write);\n        t = t + 1;\n    }\n\n}\n\nint main() {\n    STUDENT *HEAD;\n    HEAD = NULL;\n\n\n\n    putlink(creatlink());\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;那你的意思是有时候i不是0&amp;#xff0c;是1&amp;#xff1f;如果这样不就说明了i一直都默认0&amp;#xff0c;和数组没关系吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体整型变量默认初始值", ["\n\n```c\n", "#", "include", "<stdio.h>", "\n", "typedef", " ", "struct", " ", "A", "{\n    ", "int", " a[", "4", "] = {", "0", "};\n    ", "int", " i;\n}A;\n\n", "int", " ", "main", "()", "{\n    A a;\n    ", "printf", "(", "\"%d\"", ",a.i);\n}\n\n", "\n", "如果这样写的话，输出的值就是不确定的，但是如果数组中的值的个数少于", "4", "，i的默认值总是", "0", "\n然后如果结构体中不定义数组的话，i的默认值也总是", "0", "\n\n```c\n", "#", "include", "<stdio.h>", "\n", "typedef", " ", "struct", " ", "A", "{\n    ", "int", " i;\n}A;\n\n", "int", " ", "main", "()", "{\n    A a;\n    ", "printf", "(", "\"%d\"", ",a.i);\n}\n\n", "\n", "\n", "可否帮解释一下怎么回事啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;初始化时可以全部一起赋值struct date today &amp;#61; { 2022,4,25 };&lt;br /&gt;初始化过后只能单独赋值&amp;#xff1a;today.year &amp;#61; 2022;today.month &amp;#61; 4;这样一个一个赋值&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言为什么初始化结构体的时候显示错误呢？（初学者）", ["画红线的地方有错误，是我的语法有错误吗？", "我用的是vs2017.", "那要该怎么解决这个错误呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n\n&amp;#96;&amp;#96;&amp;#96;c\n* LinkList的意思是将struct Lnode* 另命名为LinkList\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构中的typede中与结构体混合后面的指针是什么意思？", ["\n", "这个理解成定义了一个叫Lnode的结构体，这个叫“Lnode的结构体”可以用“Lnode”替换；那么*LinkList是个什么鬼？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;amp;是引用类型。&lt;br /&gt;指针形参在函数中重新赋值&amp;#xff0c;它的值带不出函数&amp;#xff0c;因此需要再加&amp;amp;&amp;#xff0c;把这个值带出函数。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["构造函数时，对形参的结构体指针LinkList &L感到困惑", ["typedef char ElemType;", "typedef struct Node", "{", "    ElemType data;", "    struct Node *next;", "}LNode,  ", "LinkList;", "在上面这个结构体中重新命名了结构体变量和结构体指针的名字", "struct Node就等于LNode，struct Node", " 就等于Linklist。", "\n", "void CreatList(LinkList &L,int m)", "但是在构造函数CreatList的时候，我对形参的 LinkList &L形式产生了困惑，定义结构体指针变量为什么加取地址符呢？不是应该为LinkList L吗？LinkLIst &L不就等于struct Node* &L。恳请为我解惑，谢谢。（尽量详细点）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这样写它认为你在定义结构体&amp;#xff0c;把main里面的struct删掉&amp;#xff0c;student改成大写&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/449307677546184.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/306807677546186.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体不允许使用不完整的类型的问题", ["当我把关键字typedef注释掉之后，并在结构体变量前加了struct还是提示我不允许使用不完整的类型，刚学到结构体请大lao指导"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; No[&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Score;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FindMaxScore&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student stu[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; stus[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;2008030201&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;89&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;2008030202&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;92&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;2008030203&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;78&lt;/span&gt;}};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k;\n\n    k &amp;#61; &lt;span class=\"hljs-built_in\"&gt;FindMaxScore&lt;/span&gt;(stus,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %d\\n&amp;#34;&lt;/span&gt;, stus[k].No, stus[k].Score);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FindMaxScore&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student stu[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, max, k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    max &amp;#61; stu[k].Score;    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;lt;n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (stu[i].Score &amp;gt; max)\n        {\n            k &amp;#61; i;\n            max &amp;#61; stu[k].Score;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; k;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["有三个学生的信息(包括学号和成绩)保存在主函数的结构体中，主函数调用函数以找出多个学生中成绩最大者的下标。", ["#include <stdio.h>", "\n", "struct Student", "{", "    char No[11];", "    int Score;", "};", "\n", "int FindMaxScore(struct Student stu[], int n);", "\n", "int main(void)", "{", "    struct Student stus[3] = {{\"2008030201\", 89}, {\"2008030202\", 92}, {\"2008030203\", 78}};", "    int k;", "\n", "3", " 分\n\n", "printf", "(", "\"%s %d\\n\"", ", stus[k].No, stus[k].Score);\n\n", "return", " ", "0", ";\n", "\n", "}", "\n", "int FindMaxScore(3 分", ")", "{", "    int i, max, k=0;", "\n", "max", " ", "=", " stu[k].Score", ";    ", "\nfor (i", "=", "1", "; i<n; i++)", "\n{\n    if (", "3", " 分\n", "\n", ")", "        {", "            k = i;", "            max = stu[k].Score;", "        }", "    }", "\n", "return", " k;\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/loy_184548/article/details/50569805", "Konwledge_Point": "数据封装——结构体", "Question": ["定义了结构体，用C语言实现数据的搜索查找的思路，谢谢", ["Problem Description", "\nBessie and her friend Elsie decide to have a meeting. However, after Farmer John decorated his", "\nfences they were separated into different blocks. John's farm are divided into n blocks labelled from 1 to n.", "\nBessie lives in the first block while Elsie lives in the n-th one. They have a map of the farm", "\nwhich shows that it takes they ti minutes to travel from a block in Ei to another block", "\nin Ei where Ei (1≤i≤m) is a set of blocks. They want to know how soon they can meet each other", "\nand which block should be chosen to have the meeting.", "\n\n", "Input", "\nThe first line contains an integer T (1≤T≤6), the number of test cases. Then T test cases", "\nfollow.", "\n\n", "The first line of input contains n and m. 2≤n≤105. The following m lines describe the sets Ei (1≤i≤m). Each line will contain two integers ti(1≤ti≤109) and Si (Si>0) firstly. Then Si integer follows which are the labels of blocks in Ei. It is guaranteed that ∑mi=1Si≤106.", "\n\n", "Output", "\nFor each test case, if they cannot have the meeting, then output \"Evil John\" (without quotes) in one line.", "\n\n", "Otherwise, output two lines. The first line contains an integer, the time it takes for they to meet.", "\nThe second line contains the numbers of blocks where they meet. If there are multiple", "\noptional blocks, output all of them in ascending order.", "\n\n", "Sample Input", "\n2", "\n5 4", "\n1 3 1 2 3", "\n2 2 3 4", "\n10 2 1 5", "\n3 3 3 4 5", "\n3 1", "\n1 2 1 2", "\n\n", "Sample Output", "\nCase #1: 3", "\n3 4", "\nCase #2: Evil John"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;前两个char是可以合起来的&amp;#xff0c;总长是12&amp;#xff0c;正好四字节对齐&amp;#xff0c;加上4字节浮点数是16&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C结构体 内存对齐问题", ["int", " ", "main", "()", "{\n        ", "struct", " ", "Test7", "{\n        ", "char", " ch1[", "11", "];", "// 11 + 1", "\n        ", "char", " ch2;   ", "// 1 + 1", "\n        ", "float", " f;    ", "// 4", "\n    };\n    ", "printf", "(", "\"Test7 is %d\\n\"", ",", "sizeof", "(", "struct", " Test7));  ", "// 16", "\n}\n", "\n", "使用vscode进行测试，得到结果是16个字节，", "这里float的字节数最大，不是应该以4的倍数对齐嘛？", "ch1字节数11，加1位，共12位，是4的倍数，", "ch2字节数1，加1位，共2位，是4的倍数，", "float字节数4位，", "12+2+4不是等于18嘛？", "小白求解答！"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;之后多了分号;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;之后多了分号;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;之后多了分号;&lt;/span&gt;\n\ntArray只是数组,不是指针\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;allocateSpace&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Teacher * tArray[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* len)&lt;/span&gt; &lt;/span&gt;{\n改成\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;allocateSpace&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Teacher tArray[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* len)&lt;/span&gt; &lt;/span&gt;{\n并且\ntArray[i]-&amp;gt;name\n改成\ntArray[i].name\n\ntArray[i]-&amp;gt;sArray[j].name\ntArray[i]-&amp;gt;sArray[j].score \n改成\ntArray[i].sArray[j].name\ntArray[i].sArray[j].score \n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;void allocate&lt;span class=\"hljs-constructor\"&gt;Space(&lt;span class=\"hljs-params\"&gt;struct&lt;/span&gt; Teacher &lt;span class=\"hljs-params\"&gt;tArray&lt;/span&gt;[], &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;len&lt;/span&gt;)&lt;/span&gt; {\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; nameseed &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;ABCDE&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; tname &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;教师&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; sname &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;教师&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; *len; i&amp;#43;&amp;#43;) {\n        tArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.name &amp;#61; tname &amp;#43; nameseed&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; j&amp;#43;&amp;#43;) {\n            tArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.sArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;.name &amp;#61; sname &amp;#43; nameseed&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;;\n            tArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.sArray&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;.score &amp;#61; rand&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt; % &lt;span class=\"hljs-number\"&gt;61&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;40&lt;/span&gt;;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c++结构体做函数参数使用地址传递出现问题", ["问题遇到的现象和发生背景", "\n", "学校正在做毕设项目，每名teacher带领5个学生，总共有3名teacher，需求如下", "设计学生和teacher的结构体，其中在teacher的结构体中，有teacher姓名和一个存放5名学生的数组作为成员", "学生的成员有姓名、考试分数，创建数组存放3名teacher，通过函数给每个teacher及所带的学生赋值", "最终打印出teacher数据以及teacher所带的学生数据。", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "<iostream>;\nusing namespace std;\n#", "include", "<", "string", ">;\n#", "include", "<ctime>;\n\n", "struct", " Student {\n    ", "string", " name;\n    ", "int", " score;\n\n};\n", "struct", " Teacher {\n    ", "string", " name;\n    ", "struct", " Student sArray", "[", "5", "]", ";\n};\n\nvoid print", "Teacher(", "struct", " Teacher ", "tArray", "[], ", "int", "  ", "len", ")", " {\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++) {\n        cout <<", "\"老师的姓名为\"", "<< tArray", "[", "i", "]", ".name << endl;\n        ", "for", " (", "int", " j = ", "0", "; j < ", "5", "; j++) {\n            cout << ", "\"\\t学生的姓名为：\"", " << tArray", "[", "i", "]", ".sArray", "[", "j", "]", ".name<<", "\" 学生的成绩为：\"", " << tArray", "[", "i", "]", ".sArray", "[", "j", "]", ".score << endl;\n        }\n    }\n}\n\nvoid allocate", "Space(", "struct", " Teacher ", "*", " ", "tArray", "[], ", "int", "*", " ", "len", ")", " {\n    ", "string", " nameseed = ", "\"ABCDE\"", ";\n    ", "string", " tname = ", "\"教师\"", ";\n    ", "string", " sname = ", "\"教师\"", ";\n    ", "for", " (", "int", " i = ", "0", "; i < *len; i++) {\n        tArray", "[", "i", "]", "->name = tname + nameseed", "[", "i", "]", ";\n        ", "for", " (", "int", " j = ", "0", "; j < ", "5", "; j++) {\n            tArray", "[", "i", "]", "->sArray", "[", "j", "]", ".name = sname + nameseed", "[", "j", "]", ";\n            tArray", "[", "i", "]", "->sArray", "[", "j", "]", ".score = rand", "()", " % ", "61", " + ", "40", ";\n        }\n    }\n}\n", "int", " main", "()", " {\n    srand((unsigned ", "int", ")time(NULL)); ", "//随机数种子 头文件 #include <ctime>", "\n    ", "struct", " Teacher tArray", "[", "3", "]", ";\n    ", "int", " len = sizeof(tArray)", " / ", "sizeof(tArray", "[", "0", "]", ");\n    cout << tArray << endl;\n\n    allocate", "Space(", "tArray", ", &", "len", ")", ";\n    print", "Teacher(", "tArray", ", ", "len", ")", ";\n\n    system(", "\"pause\"", ");\n    return ", "0", ";\n}\n\n", "\n", "\n", "\n", "运行结果及报错内容", "\n", "调用allocateSpace方法时它提示实参与形参不兼容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "把指针去掉，使用值传递没有错误", "在实参前加入&依然出错", "\n", "我想要达到的结果", "\n", "应该如何修改代码在使用指针的情况下达到目的，为什么我这样写会出错", "修改改成值传递结果如下：", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "PChar是指针，应该是4个字节", "Konwledge_Point": "数据封装——结构体", "Question": ["Delphi结构体的对齐问题                  ", ["Delphi结构体的对齐问题，Delphi的PChar是几个字节，Short和PChar是不是需要按照4字节对齐？"]], "Tag": "程序设计"}
{"Answer": "写一个函数直接访问结构体的成员变量就好了的！\r\n\r\n还有就是，你的经度纬度两个成员变量的名字一样了。\r\n城市名那个成员，建议用数组，因为城市名一般不会是只有一个字符，而是多个字符。\r\n\r\nstruct information\r\n{\r\n\t//char cityname;//城市名字\r\n\tchar cityname[10];\r\n\tint number;       //城市编号\r\n\tint longitude;    //经度\r\n\tint latitude;    //纬度\r\n}information1;\r\nstruct information i;//结构体information的名字也为i\r\n\r\nvoid test7()\r\n{\r\n\t//printf(\"城市名称：%c\\n\",i.cityname);\r\n\tprintf(\"城市名称：%s\\n\", i.cityname);\r\n\tprintf(\"城市编号：%d\\n\", i.number);\r\n\tprintf(\"城市经度：%d\\n\", i.longitude);\r\n\tprintf(\"城市纬度：%d\\n\", i.latitude);\r\n}\r\n\r\n\r\n//测试代码\r\n\r\n```\r\n#include &lt;stdio.h&gt; \r\n#include &lt;string.h&gt; \r\ntypedef struct __CITYDATA { \r\n\tchar cityname[10];//城市名字\r\n\tint number; //城市编号\r\n\tint longitude; //经度\r\n\tint latitude; //纬度 \r\n}CITYDATA;\r\n\r\nCITYDATA cityData[5];//定义结构体变量 \r\nvoid print(CITYDATA p[5],int num)\r\n{\r\n\tint i = 0;//定义数组a的下标\r\n\tprintf(\"\\n\\n城市名称\\t\\t城市编号\\t\\t城市经度\\t\\t城市纬度\\n\");\r\n\tfor(i = 0;i &lt; num;i++)\r\n\t{\t\r\n\t\tprintf(\"%s\\t\\t\\t%d\\t\\t\\t%d\\t\\t\\t%d\",p[i].cityname,p[i].number,p[i].longitude,p[i].latitude); \r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\nint main() \r\n{ \r\n\tint n = 0;//定义城市数量 \r\n\tint i = 0;//cityname数组的下标\r\n\tprintf(\"输入城市数量:\"); \r\n\tscanf_s(\"%d\",&amp;n);\r\n\tif (n &gt; 5)\r\n\t\tn = 5;\r\n\tfor(i = 0;i &lt; n;++i) \r\n\t{\r\n\t\tprintf(\"\\n输入第%d个城市名称:\", i + 1);\r\n\t\tscanf(\"%s\",cityData[i].cityname);\r\n\t\tprintf(\"\\n输入第%d个城市编号:\", i + 1);\r\n\t\tscanf_s(\"%d\", &amp;cityData[i].number);\r\n\t\tprintf(\"\\n输入第%d个城市经度:\", i + 1);\r\n\t\tscanf_s(\"%d\", &amp;cityData[i].longitude);\r\n\t\tprintf(\"\\n输入第%d个城市纬度:\", i + 1);\r\n\t\tscanf_s(\"%d\", &amp;cityData[i].latitude);\r\n\t} \r\n\tprint(cityData,n);\r\n\treturn 0; \r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["用c/c++来编写一个程序，需要用到结构体变量，一次循环", ["城市信息的输入与输出（结构体）", "\n\n", "【问题描述】编写程序，能够输入和显示若干个城市的数据记录，每个记录包括城市编号、城市名、经度、维度。建议选择自己所在地的城市、熟悉或者喜欢的城市。只用结构体变量而不用结构体数组完成，只用一个循环完成。", "\n\n", "#include<stdio.h>\nstruct information\n{\n    char cityname;//城市名字\n    int number;       //城市编号\n    int longitude;    //经度\n    int longitude;    //纬度\n}information1;\nstruct information i;//结构体information的名字也为i\nint main()\n{\n\n}\n", "\n\n", "不知道怎么用一个循环来遍历这个结构体。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If you want a function that takes any struct type and returns a slice of it, like:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func MakeSlice(s ANY_STRUCT_TYPE) []ANY_STRUCT_TYPE\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You're looking for generics, which Go doesn't currently support. See &lt;a href=\"https://golang.org/doc/faq#generics\" rel=\"nofollow noreferrer\"&gt;this FAQ entry&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;The Go team is working to &lt;a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md\" rel=\"nofollow noreferrer\"&gt;add generics to the language&lt;/a&gt; - it's a work in progress, and everyone is free to participate in the discussion. Once generics exist, they will provide the solution you seek here.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;In the meantime, you could use &lt;a href=\"https://blog.golang.org/generate\" rel=\"nofollow noreferrer\"&gt;code generation&lt;/a&gt; or think of a slightly different design for your problem. Some code duplication is OK too, Go doesn't frown upon it as badly as some other languages.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将结构体作为参数传递给函数，并返回相应结构体的切片", ["\n\n", "I am trying to write a function which can be used by different structs.\nThe return of the function has to be a slice of the corresponding struct.\nThus I need a function which accept a struct as a parameter and return a slice.\nMy code somehow looks like this but I have no idea how can I wrap it as a function?", "\n\n", "type name struct{\n   FirstName string `xml:\"firstName\"`\n   LastName string `xml:\"lastName\"`\n  }\n\nfileList := TreeTraversal(\".\")\n    var a name\n    var b []name \n\n\nfor i := 0; i < len(fileList); i++{\n    fileByte, _ := ioutil.ReadFile(fileList[i])\n\n    xml.Unmarshal(fileByte, &a)\n    b = append(b, a)\n}\n", "\n\n", "As far as I know I can pass a struct to a function as an interface, but I have no idea about the return type? ", "\n    "]], "Tag": "程序设计"}
{"Answer": "看Unix/Linux上的man：\r\n\r\nStandard C Library Functions                             gets(3C)\r\nNAME\r\n     gets, fgets - get a string from a stream\r\n\r\nSYNOPSIS\r\n     #include &lt;stdio.h&gt;\r\n\r\n     char *gets(char *s);\r\n\r\n     char *fgets(char *s, int n, FILE *stream);\r\n\r\nDESCRIPTION\r\n     The gets() function reads  bytes  from  the  standard  input\r\n     stream  (see  intro(3)), stdin, into the array pointed to by\r\n     s, until a newline character is read or an end-of-file  con-\r\n     dition  is  encountered.  The newline character is discarded\r\n     and the string is terminated with a null byte.\r\n....\r\n\r\ngets是标准库函数，要求传入的是一个数组的地址。其实是要求caller应当分配空间给他。你的结构体中指针数组指向了已经分配好的内存吗？如果没有就别想了。想用就自己先给他空间", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体中指针数组怎样赋值", ["定义一个结构体", "\nstruct AS", "\n{", "\n    char *p[1]；", "\n}；", "\n怎样用gets函数给指针数组赋值呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Your &lt;code&gt;loadPos()&lt;/code&gt; method is using a value receiver (as opposed to a pointer), meaning that it's operating on a copy of the &lt;code&gt;order&lt;/code&gt; object.&lt;br&gt;\nSo when you call &lt;code&gt;o.loadPos()&lt;/code&gt;, go is copying &lt;code&gt;o&lt;/code&gt;, and calling &lt;code&gt;loadPos()&lt;/code&gt; on that copy.&lt;/p&gt;\n\n&lt;p&gt;The solution is to simply change the receiver to a pointer:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (o *order) loadPos() {\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;sup&gt;&lt;a href=\"https://play.golang.org/p/PATpBCZLT7\" rel=\"nofollow\"&gt;https://play.golang.org/p/PATpBCZLT7&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["去：结构体中的数组失去了它的内容", ["\n\n", "The following go code (shared: ", "link", ") should insert two positions in an order (both order and position are ", "struct", "s:", "\n\n", "package main\n\nimport \"fmt\"\n\ntype orderPosition struct{\n   art string\n   qty string   \n}\n\ntype order struct{\n   posList []orderPosition\n}\n\nfunc main() {\n  o := new(order)\n  o.loadPos()\n  fmt.Printf(\"# pos: %d\n\",len(o.posList))\n\n}\n\nfunc (o order) loadPos() {\n  o.posList = append(o.posList, orderPosition {art: \"art 1\", qty: \"2 pc\"})\n  o.posList = append(o.posList, orderPosition {art: \"art 2\", qty: \"7 pc\"})\n  fmt.Printf(\"# pos: %d\n\",len(o.posList))\n}\n", "\n\n", "The output is:", "\n\n", "# pos: 2\n# pos: 0    \n", "\n\n", "The method ", "loadPos", " fills the positions in the order. But as soon as the method is left the list of positions is lost.", "\n\n", "Why is the array loosing its content?", "\n\n", "Any help would be greatly appreciated.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体排序比较结构体元素交换结构体&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/604087880246177.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\nstruct stu\n{\n    int num;\n    int &lt;span class=\"hljs-keyword\"&gt;score;\n&lt;/span&gt;};\nvoid fun(struct stu t[],int n)\n{\n    int &lt;span class=\"hljs-keyword\"&gt;j,k;\n&lt;/span&gt;    for(k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; k&amp;lt;n-1; k&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;n-k-1; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;)\n&lt;/span&gt;        {\n            if(t[&lt;span class=\"hljs-keyword\"&gt;j].score&amp;lt;t[j&amp;#43;1].score)\n&lt;/span&gt;            {\n                struct stu tem&amp;#61;t[&lt;span class=\"hljs-keyword\"&gt;j];\n&lt;/span&gt;                t[&lt;span class=\"hljs-keyword\"&gt;j]&amp;#61;t[j&amp;#43;1];\n&lt;/span&gt;                t[&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;1]&amp;#61;tem;\n&lt;/span&gt;            }\n        }\n    }\n}\nint main()\n{\n    struct stu t[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]&amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;56&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;66&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;45&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;68&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;};\n    int &lt;span class=\"hljs-keyword\"&gt;j;\n&lt;/span&gt;    for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;5; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;)\n&lt;/span&gt;    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a;%d  分数&amp;#xff1a;%d  \\n&amp;#34;&lt;/span&gt;,t[&lt;span class=\"hljs-keyword\"&gt;j].num,t[j].score);\n&lt;/span&gt;    }\n    fun(t,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;排序后\\n&amp;#34;&lt;/span&gt;);\n    for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;5; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;)\n&lt;/span&gt;    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a;%d  分数&amp;#xff1a;%d  \\n&amp;#34;&lt;/span&gt;,t[&lt;span class=\"hljs-keyword\"&gt;j].num,t[j].score);\n&lt;/span&gt;    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言程序设计，结构体作为函数的返回值", ["已知学生的记录由学号和成绩组成。N名学生的数据已在主函数中放入结构体中输出S中。请编写函数fun，它的功能是：按分数的高低排列学生的记录,高分在前"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在case中如果定义变量的话&amp;#xff0c;对整个case代码块增加大括号&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["修改结构体中一个数据的值", ["就是switch里面那些修改的句子", "都会报错", "是为什么啊", "不能单独一个修改吗", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;flow&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; metric;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    FILE *file &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;open.bin&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#43;b&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!file)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;failed to open file\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;flow&lt;/span&gt; t &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;test&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;127&lt;/span&gt;};\n    &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(&amp;amp;t, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; flow), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, file);\n\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;flow&lt;/span&gt; *p &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; flow *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; flow));\n    &lt;span class=\"hljs-built_in\"&gt;rewind&lt;/span&gt;(file);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(p, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; flow), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, file) !&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;read error\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(file);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;gt; %d\\n&amp;#34;&lt;/span&gt;, p-&amp;gt;num);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;gt; %s\\n&amp;#34;&lt;/span&gt;, p-&amp;gt;name);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;gt; %d\\n&amp;#34;&lt;/span&gt;, p-&amp;gt;metric);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言write与read函数读取写入结构体到文件问题", ["将结构体赋值后写入文件，再用read函数读取到结构体指针中，并没有获取到打印信息，请教这是怎么回事！！", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<unistd.h>", "\n", "#", "include", " ", "<fcntl.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n\n", "struct", " ", "flow", "\n{\n    ", "unsigned", " ", "int", " num;\n    ", "char", " name[", "32", "];\n    ", "unsigned", " ", "char", " metric;\n};\n\n", "int", " ", "main", "(", "int", " argc, ", "const", " ", "char", " *argv[])", "\n", "{\n    ", "int", " fd = ", "open", "(", "\"./open.txt\"", ",O_RDWR | O_CREAT | O_TRUNC,", "0666", ");\n    ", "if", "(fd == ", "-1", ")\n    {\n        ", "perror", "(", "\"open failed\"", ");\n        ", "return", " ", "-1", ";\n    }\n\n    ", "struct", " ", "flow", " t;\n    ", "memset", "(&t, ", "0", ", ", "sizeof", "(", "struct", " flow));\n    t.num = ", "5", ";\n    ", "strcpy", "(t.name, ", "\"test\"", ");\n    t.metric = ", "127", ";\n    ", "write", "(fd, &t, ", "sizeof", "(", "struct", " flow));\n\n       ", "struct", " ", "flow", " *p = ", "NULL", ";\n    p = (", "struct", " flow*)", "malloc", "(", "sizeof", "(", "struct", " flow)); \n\n    ", "printf", "(", "\"ret1: %d\\n\"", ", ret1);\n\n    ", "//读取", "\n    ", "int", " ret1 = ", "lseek", " (fd, ", "0", ", ", "0", ");\n    ", "if", " (", "read", "(fd, p, ", "sizeof", "(", "struct", " flow) == ", "-1", "))\n    {\n        ", "printf", "(", "\"read error\\n\"", ");\n        ", "exit", "(", "1", ");\n    }\n\n    ", "//没有打印信息，貌似没有读取成功", "\n    ", "printf", "(", "\"==> %d\\n\"", ", p->num);\n    ", "printf", "(", "\"==> %s\\n\"", ", p->name);\n    ", "printf", "(", "\"==> %d\\n\"", ", p->metric);\n    ", "close", "(fd);\n    ", "return", " ", "0", ";\n}\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; n 10&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; num[&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score;\n} stu;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,k;\n    stu a[n], buf;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %d&amp;#34;&lt;/span&gt;,&amp;amp;a[i].num,a[i].name,&amp;amp;a[i].score);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; &amp;#43;&amp;#43;i)  &lt;span class=\"hljs-comment\"&gt;//比较n-1轮&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;-i; &amp;#43;&amp;#43;j)  &lt;span class=\"hljs-comment\"&gt;//每轮比较n-1-i次,&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a[j].score &amp;lt; a[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].score)\n            {\n                buf &amp;#61; a[j];\n                a[j] &amp;#61; a[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                a[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; buf;\n            }\n        }\n    }\n    FILE *fp &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;./result.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %d\\n&amp;#34;&lt;/span&gt;,a[i].num,a[i].name,a[i].score);\n        &lt;span class=\"hljs-built_in\"&gt;fprintf&lt;/span&gt;(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %d\\n&amp;#34;&lt;/span&gt;,a[i].num,a[i].name,a[i].score);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言用结构体对学生成绩进行排序（不懂啊）", ["建立学生结构体类型，包括：学号（学号11位）、姓名和总分。建立结构数组，从键盘录入10个同学的信息，然后对这10个同学按成绩从高到低的顺序排序，然后在屏幕上输出排序后的所有学生记录并写入文件中。假设本问题中，学生成绩一定为[0,100]之间的正整数。要求使用选择排序（或改进的选择排序）和冒泡排序（或改进的冒泡排序）两种方法来完成。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;申明结构体数组&amp;#xff0c;两种方式&lt;br /&gt;struct ROLE role[count] 或者&lt;br /&gt;struct ROLE *pRole &amp;#61; new struct ROLE[count];&lt;br /&gt;你的方法是第二种&amp;#xff0c;但你没有叫星号&amp;#xff0c;所以不对&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["我该怎么才能声明一个结构体数组呢", ["我该怎么才能声明一个结构体数组呢？用1的这种方式哪里错了呢?", "应该如何声明定义", "\n", "\nstruct  ROLE\n{\n    string id", ";", "\n    int exp", "; ", "\n}", ";", "\n", "count", "=", "count/", "2", ";", "\n//", "1", ".struct ROLE role", "=", "new ROLE[count]\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//string name&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; li;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; shi;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *x, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *y)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt; *xx &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; stu *)x;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt; *yy &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; stu *)y;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (yy-&amp;gt;li &amp;#43; yy-&amp;gt;shi) - (xx-&amp;gt;li &amp;#43; xx-&amp;gt;shi);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t;\n    cin &amp;gt;&amp;gt; t;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t--)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n        cin &amp;gt;&amp;gt; n;\n        &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt; *student &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; stu[n];\n\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        {\n            cin &amp;gt;&amp;gt; student[i].name &amp;gt;&amp;gt; student[i].li &amp;gt;&amp;gt; student[i].shi;\n        }\n        &lt;span class=\"hljs-built_in\"&gt;qsort&lt;/span&gt;(student, n, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(stu), cmp);\n\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; student[j].name &amp;lt;&amp;lt; endl;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; student;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c++结构体qsort", ["\n", "#", "include", "<iostream>", "\n", "#", "include", "<iomanip>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<vector>", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<cmath>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "stu", "{\n    string name;\n    ", "int", " li;\n    ", "int", " shi;\n}student[", "1010", "];\n", "int", " ", "cmp", "(", "const", " ", "void", "*x,", "const", " ", "void", "*y)", "{\n    ", "struct", " ", "stu", "* xx = (", "struct", " stu*)x;\n    ", "struct", " ", "stu", "* yy = (", "struct", " stu*)y;\n    ", "return", " (yy->li+yy->shi)-(xx->li+xx->shi);\n}\n", "int", " ", "main", "()", "{\n    ", "int", " t;\n    cin>>t;\n    ", "while", "(t--){\n        ", "int", " n;\n        cin>>n;\n        \n        ", "for", "(", "int", " i=", "0", ";i<n;i++){\n            cin>>student[i].name>>student[i].li>>student[i].shi;\n        }\n        ", "qsort", "(&student[", "0", "], ", "sizeof", "(student) / ", "sizeof", "(student[", "0", "]), ", "sizeof", "(student[", "0", "]), cmp);\n        \n        ", "for", "(", "int", " j=", "0", ";j<n;j++){\n            cout<<student[j].name<<endl;\n        }\n    }\n    \n}\n", "\n", "为什么这会有问题？", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;char&lt;/span&gt;* name;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;   &lt;span class=\"hljs-keyword\"&gt;id&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; age;\n    &lt;span class=\"hljs-keyword\"&gt;char&lt;/span&gt; group;\n    &lt;span class=\"hljs-keyword\"&gt;float&lt;/span&gt; score;\n}Student;\n\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i, j;\n    Student cls[] &amp;#61; {\n                     {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1001&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;95.50&lt;/span&gt;},\n                     {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;李四&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1002&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;90.00&lt;/span&gt;},\n                     {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;王五&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1003&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;80.50&lt;/span&gt;}\n    };\n    j &amp;#61; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(cls) / &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(Student);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;j;i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %d %u %c %f\\n&amp;#34;&lt;/span&gt;, cls[i].name,cls[i].id,\n                         cls[i].age,cls[i].group,cls[i].score);\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(Student));\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(cls));\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["怎么打印存储在结构体里的数组", ["#include <stdio.h>", "#include <stdlib.h>", "\n", "typedef struct", "{", "    char *name;", "    int id;", "    unsigned int age;", "    char group;", "    float score;", "}Student;", "\n", "int main()", "{", "    int i,j;", "    Student cls[] = {", "        {\"张三\", 1001, 16, 'A', 95.50},", "        {\"李四\", 1002, 15, 'A', 90.00},", "        {\"王五\", 1003, 16, 'B', 80.50}", "    };", "\n", "/*", "for", "(i=", "0", ";i<", "5", ";i++)\n{\n    ", "for", "(j=", "0", ";j<", "3", ";j++)\n    {\n        ", "printf", "(", "\"%c\"", ",Student cls[]);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}*/\n\n", "printf", "(", "\"%d\\n\"", ",sizeof(Student));\n", "printf", "(", "\"%d\"", ",sizeof(cls));\n", "\n", "}", "\n", "怎么将数组里的数据打印出来呢？", "自己写的不知道输出哪个变量名"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载是面向对象的功能&amp;#xff0c;c不支持重载&amp;#xff0c;c需要新建个比较函数进行比较。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言要怎么重载结构体里面的小于号呢，他没有引用啊", ["这是C艹咯，但是C语言怎么操作呢？", "\n", "\n", "struct", " ", "per", "\n{\n    ", "int", " w;\n    ", "int", " s;\n    ", "bool", " ", "operator", " < (", "const", " ", "struct", " per &t) ", "const", "\n    {\n        ", "return", " w + s < t.w + t.s;\n    };\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;循环里的第二个for应该是len减1减 i 不是 i 减1&lt;br /&gt;冒泡排序每一趟都得跑到未排序数组的最后一个&amp;#xff0c;如果你是按从低到高排序&amp;#xff0c;那么每一趟都会把最大的一个数据放到最后&amp;#xff0c;然后第二趟的时候 i&amp;#43;&amp;#43;&amp;#xff0c;len - 1 - i&amp;#xff0c;就再少往后走一个&amp;#xff0c;如果你直接用 i - 1 作为判断条件最开始 i 等于0&amp;#xff1b;你再想想看你这个循环是怎么执行的&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体的冒泡排序", ["请问一下，这个冒泡排序他最终的结果没有达到预期，但是程序本身可以运行，请问究竟是什么地方出错了？？", "\n", "我想做的程序是一个可以根据人物年龄将所有人物排序的程序", "\n", "#", "include", " <iostream>\n#", "include", " <", "string", ">\n\nusing namespace std;\n\n", "struct", " hero {\n    ", "string", " name;", "//姓名", "\n\n    ", "int", " age;", "//年龄", "\n\n    ", "string", " sex;", "//性别", "\n};", "//定义英雄结构体", "\n\n", "//定义冒泡排序函数", "\nvoid ", "BubbleSort(", "hero", " ", "heroArray", "[],", "int", " ", "len", ")", "{\n\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++) {\n        ", "for", " (", "int", " j = ", "0", "; j < i - ", "1", "; j++) {\n\n            ", "if", " ( heroArray", "[", "j", "]", ".age >  heroArray", "[", "j", " + ", "1", "]", ".age) {\n                hero temp = heroArray", "[", "j", "]", ";\n                heroArray", "[", "j", "]", " = heroArray", "[", "j", " + ", "1", "]", ";\n                heroArray", "[", "j", " + ", "1", "]", " =  temp;\n\n            }\n        }\n    }\n\n}\n\nvoid ", "PrintHero(", "struct", " ", "hero", " ", "heroArray", "[],", "int", " ", "len", ")", " {\n\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++) {\n\n        cout << ", "\"姓名：\"", " << heroArray", "[", "i", "]", ".name << ", "\"  年龄：\"", " << heroArray", "[", "i", "]", ".age\n            << ", "\"  性别：\"", " << heroArray", "[", "i", "]", ".sex << endl;\n    }\n\n}\n\n\n", "int", " main", "()", " {\n    ", "//创建英雄结构体", "\n    hero heroArray", "[", "3", "]", " = {\n        {", "\"张飞\"", ",", "20", ",", "\"男\"", "},\n        \n        {", "\"关羽\"", ",", "21", ",", "\"男\"", "},\n        \n        {", "\"貂蝉\"", ",", "18", ",", "\"女\"", "}\n\n    };\n    \n    ", "//计算数量", "\n    ", "int", " len = sizeof(heroArray)", " / ", "sizeof(heroArray", "[", "0", "]", ");\n    \n    ", "//排序，年龄从高到低", "\n    ", "BubbleSort(", "heroArray", ",", "len", ")", ";\n\n    ", "//打印", "\n    ", "PrintHero(", "heroArray", ", ", "len", ")", ";\n\n    \n    \n    \n    system(", "\"pause\"", ");\n\n    return ", "0", ";\n}\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "Matrix(int a = 0,int b=0)\r\n这个可不是“对里面的成员变量设置默认值”\r\n而是缺省参数\r\n也就是当你用\r\nMatrix m()的时候，相当于Matrix m(0,0)\r\n而Matrix m(123)的时候相当于 Matrix m(123,0)\r\n缺少的参数由你的缺省值补进去\r\n\r\n至于这个a b参数，并没有传给作为成员变量的a b！！！", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C++中结构体的构造函数中带冒号的问题", [" struct Matrix {\n   int a, b;\n     Matrix(int a = 0,int b=0) : a(a),b(b) { }\n} m[26];\n", "\n\n", "构造函数中是对里面的成员变量设置默认值，那为什么在上述代码中已经初始化之后还要再加冒号呢？", "\n 另外有冒号的这一行是什么意思。新手小白一个，请大神指教，非常感谢"]], "Tag": "程序设计"}
{"Answer": "一个个的回答吧。\r\n1、SqStack Sq[10]表示有长度为10的SqStack类型元素的数组，一个SqStack类型元素占用4(SElemType * base)+4(SElemType * top)+4(int stacksize)=12字节，十个元素就占12 * 10=120字节。\r\n\r\n2、SElemType中的str[10]数组没有被声明，因为SqStack结构体中只声明了两个SElemType 类型的指针。\r\n\r\n3、如果没有赋值，base、top的确为空指针。", "Konwledge_Point": "数据封装——结构体", "Question": ["请教结构体声明中内存状况", ["数据结构如下：", "\ntypedef struct{", "\n    char str[10];", "\n}SElemType;//自定义元素类型。", "\ntypedef struct{", "\n    SElemType *base;", "\n    SElemType *top;", "\n    int stacksize;//栈长度。", "\n}SqStack;//顺序栈", "\n假设我现在声明一个数组SqStack Sq[10];那么这时内存中怎么个表示情况？这个数组声明时SElemType中的str[10]数组有没有同时声明呢？换句话说，声明的Sq数组的每个分量中，base,top指针是否为空？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这个结构体由于有指针&amp;#xff0c;所以用sizeof是不能够得到指针指向空间的大小的&amp;#xff0c;自然也没有办法将指针指向空间数据写入文件。所以这个结构体你需要单独写一个GetSize函数&amp;#xff0c;写文件的时候&amp;#xff0c;指针指向的空间数据要单独写文件&amp;#xff0c;直接write(fd,test,sizeof(record1)*1);是不行的&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体成员是指针时 怎样去使用结构体?", ["如题", "\n结构体", "\ntypedef struct{", "\nint id;", "\nchar name[8];", "\nchar *cc;", "\n}record;", "\n\n", "//初始化结构体分配内存", "\nrecord * test=(record *)malloc(sizeof(record)*1);", "\n//下面需要初始化 结构体成员 指针cc吗?", "\n//初始化成员 cc 分配内存", "\n(*(test) ).cc =(char *)malloc(sizeof(char)*20);", "\n//结构体成员赋值", "\n(*(test) ).id = 11;", "\nstrcpy((*(test)).name,\"abc\");", "\nstrcpy((*(test)).cc,\"test\");", "\n//这里成员cc 已经赋值  并且打印成员值正常", "\n//printf(\"%s\\n\",(*(test)).cc);  ", "\n", "\n我的疑问是 ,这个cc成员单独使用是没有问题的,", "\n在使用结构体的时候是不正常 ,", "\n例如:将结构体写入到文件 ", "\nwrite(fd,test,sizeof(record1)*1);", "\n//写入后去看文件 其他的值都是正常 ,  而结构体成员cc那个位置的数据是 乱码", "\n//写入后的二进制文件内容", "\n/* 0B 00 00 00 61 62 63 00  00 00 00 00 00 00 00 00  C0 A2 2C 01 00 00 00 00  00 00 00 00 00 00 00 00 */", "\n//0B 是结构体成员id的值11,  结构体成员name的值是 61 62 63 即abc,", "\n//成员cc  这里的值 不对 而且每运行一次程序 对应位置的数据是变化的", "\n//回到c程序 用结构体去读这个文件   结果也是读不出数据 ", "\n//其他值正常 , 指针成员cc  %p打印显示是 指针 %s没有显示 空的, sizeof 显示8大小", "\n\n", "//现在的疑问是  结构体里 成员是指针时    这个结构体要怎样用呢? 结构体成员指针有什么作用和功能?", "\n//自学c语言 刚接触结构体 ,这里不太明白  希望大神们讲解下 .谢谢", "\n ", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/lethic/article/details/7781203", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ 6.0结构体字段多重排序的函数指针", ["C++对结构体数组进行排序，排序结果存在紊乱，库函数的函数指针怎么解决排序紊乱的问题？"]], "Tag": "程序设计"}
{"Answer": "```\r\n p是指针，指针访问成员用-&gt;，非指针用.，静态成员用::\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体指针，，，，，，", ["结构体指针像这样：", "\nstruct student ", "\n{", "\n        long num;", "\n        char name[20];", "\n        int score[3];", "\n}zhang,*p;", "\np=&zhang;", "\n\n", "访问时可以用p->num  或者(*p).num", "\n这里为什么不是p,num而是（*p）呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;大概这种感觉?&lt;br /&gt;不太清楚为什么你结构体里面申请的是几个数组,但是用的时候只赋了一个值,所以直接去掉了&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/664832623236182.png\" width=\"600px\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;str&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; id;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; deng;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; chai;\n} st[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;compare&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *a, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;str&lt;/span&gt; *pa &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; str *)a;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;str&lt;/span&gt; *pb &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; str *)b;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num1 &amp;#61; pa-&amp;gt;deng &amp;#43; pa-&amp;gt;chai;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num2 &amp;#61; pb-&amp;gt;deng &amp;#43; pb-&amp;gt;chai;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)num2 - num1;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *a, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;str&lt;/span&gt; *pa &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; str *)a;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;str&lt;/span&gt; *pb &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; str *)b;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)(pb-&amp;gt;chai - pa-&amp;gt;chai);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, k, h;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sum[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; t &amp;lt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; t&amp;#43;&amp;#43;)\n    {\n        sum[t] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;n, &amp;amp;k, &amp;amp;h);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;(st[i].id), &amp;amp;(st[i].deng), &amp;amp;(st[i].chai));\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d\\n&amp;#34;&lt;/span&gt;, st[i].id, st[i].deng, st[i].chai);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;qsort&lt;/span&gt;(st, n, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;), cmp);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d\\n&amp;#34;&lt;/span&gt;, st[i].id, st[i].deng, st[i].chai);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体数组的输入与输出", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "struct", " ", "str", " {\n    ", "int", " id[", "10", "];\n    ", "int", " deng[", "10", "];\n    ", "int", " chai[", "10", "];\n    \n}st[", "100", "];\n\n", "int", " ", "compare", "(", "const", " ", "void", "*a,", "const", " ", "void", "*b)", "{\n    ", "struct", " ", "str", " *pa = (", "struct", " str*)a;\n    ", "struct", " ", "str", " *pb = (", "struct", " str*)b;\n\n    ", "int", " num1 = *pa->deng + *pa->chai;\n    ", "int", " num2 = *pb->deng + *pb->chai;\n\n    ", "return", " (", "int", ")num2 - num1;\n\n}\n", "int", " ", "cmp", "(", "const", " ", "void", "*a, ", "const", " ", "void", "*b)", " ", "{\n    ", "struct", " ", "str", " *pa = (", "struct", " str*)a;\n    ", "struct", " ", "str", " *pb = (", "struct", " str*)b;\n\n    ", "return", " (", "int", ")(*pb->chai - *pa->chai);\n}\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "int", " n, k, h;\n    ", "int", " sum[", "100", "];\n    ", "for", " (", "int", " t = ", "0", "; t < ", "100", "; t++) {\n        sum[t] = ", "0", ";\n    }\n\n    ", "scanf_s", "(", "\"%d %d %d\"", ", &n, &k, &h);\n\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++) {\n        ", "scanf_s", "(", "\"%d %d %d\"", ", &st[i].id, &st[i].deng, &st[i].chai);\n    }\n\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++) {\n        ", "printf", "(", "\"%d %d %d\\n\"", ", st[i].id, st[i].deng, st[i].chai);\n    }\n\n    ", "qsort", "(st, ", "sizeof", "(st[n]) / ", "sizeof", "(st[", "0", "]), ", "sizeof", "(", "int", "), cmp);\n\n\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++) {\n        ", "printf", "(", "\"%d %d %d\\n\"", ", st[i].id, st[i].deng, st[i].chai);\n    }\n\n    ", "return", " ", "0", ";\n\n    \n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你所谓的自引用的结构体无非就是比正常结构体多一个指向本结构体类型的指针而已。所以就是普通的结构体计算大小的方式&amp;#xff0c;除了本结构体自身大小&amp;#xff0c;还要加上内存对齐的大小。简单的办法就是sizeof(MyClass)就好了。有帮助请采纳&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["自引用的结构体怎么计算占用内存空间", ["自引用的结构体怎么计算占用内存空间，就是定义一个结构体类型，然后里面有各种基本类型的变量还有本结构体类型的指针，这种情况下怎么判断内存空间"]], "Tag": "程序设计"}
{"Answer": "```\r\nprintf(\"%10s%5d%20s%5.1f%5.1f%5.1f%5.1f%5.1f%10s\\n\",s[i].name,s[i].id,s[i].subject,s[i].perf,s[i].mid,s[i].final,s[i].total,s[i].level);\r\n--&gt;\r\nprintf(\"%10s%5d%20s%5.1f%5.1f%5.1f%5.1f%10s\\n\",s[i].name,s[i].id,s[i].subject,s[i].perf,s[i].mid,s[i].final,s[i].total,s[i].level);\r\n写多了一个 %5.1f，应该去掉一个%5.1f。\r\n\r\n```\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201907/11/1562815151_233616.png)", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体输出问题，输出不了结果", ["为什么输出不了计算出的结果，只能输出两行文字", "\n代码如下：", "\n#include", "\n#include", "\n#define N 3", "\ntypedef struct", "\n{", "\n    int id;//学号 ", "\n    char name[20];//姓名 ", "\n    char subject[20];//考试科目 ", "\n    float perf;//平时成绩 ", "\n    float mid;//期中成绩 ", "\n    float final;//期末成绩 ", "\n    float total;//总评 ", "\n    char level[10];//等级 ", "\n}STU;", "\nvoid input(STU [],int);//输入学生信息", "\nvoid clac(STU[],int);//计算总评和等级", "\nint fail(STU[],STU[],int);//计算不及格学生人数", "\nvoid sort(STU[],int);//排序", "\nvoid show(STU[],STU[],int,int);//输出学生信息 ", "\nvoid input(STU s[],int n){//输入学生信息", "\n    for(int i=0;i\n        printf(\"请输入学生信息：\\n\");", "\n        scanf(\"%d%s%s%f%f%f\",&s[i].id,&s[i].name,&s[i].subject,&s[i].perf,&s[i].mid,&s[i].final);", "\n    }", "\n}", "\nvoid clac(STU s[],int n){//计算总评和成绩", "\n    for(int i=0;i\n        s[i].total=0.2*s[i].perf+0.2*s[i].mid+0.6*s[i].final;", "\n        if(s[i].total>=90){", "\n            strcpy(s[i].level,\"优秀\");", "\n        }", "\n        else if(s[i].total>=80&&s[i].total\n            strcpy(s[i].level,\"良好\");", "\n        }", "\n        else if(s[i].total>=70&&s[i].total\n            strcpy(s[i].level,\"中等\");", "\n        }", "\n        else if(s[i].total>=60&&s[i].total<70){ ", "\n            strcpy(s[i].level,\"及格\");", "\n        }", "\n        else{", "\n            strcpy(s[i].level,\"不及格\"); ", "\n        }", "\n    }", "\n}", "\nint fail(STU s[],STU t[],int n){//计算不及格人数 ", "\n    int i,k=0;", "\n    for(i=0;i<n;i++){", "\n        if(s[i].total<60){", "\n            t[k++]=s[i];", "\n        }", "\n    }", "\n    return k;", "\n}", "\nvoid sort(STU s[],int n){//排序 ", "\n    int i,j;", "\n    STU temp;", "\n    for(i=0;i<n-1;i++){", "\n        for(j=0;j<n-1-i;j++){", "\n            if(s[j].total<s[j+1].total){", "\n                temp=s[j+1];", "\n                s[j+1]=s[j];", "\n                s[j]=temp; ", "\n            }", "\n        }", "\n    }", "\n}", "\nvoid show(STU s[],STU t[],int n,int m){", "\n    int i;", "\n    printf(\"学生成绩排名情况\\n\");", "\n    printf(\"------------------\\n\");", "\n    printf(\"姓名 学号 考试科目 平时成绩 期中成绩 期末成绩 总评 成绩等级\\n\");", "\n    for(i=0;i<n;i++){", "\n        printf(\"%10s%5d%20s%5.1f%5.1f%5.1f%5.1f%5.1f%10s\\n\",s[i].name,s[i].id,s[i].subject,s[i].perf,s[i].mid,s[i].final,s[i].total,s[i].level);", "\n    } ", "\n    printf(\"不及格学生情况\\n\");", "\n    printf(\"------------------\\n\");", "\n    printf(\"姓名 学号 考试科目 平时成绩 期中成绩 期末成绩 总评 成绩等级\\n\");", "\n    for(i=0;i<m;i++){", "\n        printf(\"%10s%5d%20s%5.1f%5.1f%5.1f%5.1f%5.1f%10s\\n\",t[i].name,t[i].id,t[i].subject,t[i].perf,t[i].mid,t[i].final,t[i].total,t[i].level);", "\n    } ", "\n}", "\nint main(){", "\n    STU ccc[N],cwy[N];", "\n    int k;", "\n    input(ccc,N);", "\n    clac(ccc,N);", "\n    k=fail(ccc,cwy,N);", "\n    sort(ccc,N);", "\n    show(ccc,cwy,N,k);", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "c语言不同于C++的一点是，变量的声明必须位于所有代码段的前面。请参看我写的文章的第七点内容，你就能明白了。http://blog.csdn.net/mougaidong/archive/2010/09/27/5909694.aspx", "Konwledge_Point": "数据封装——结构体", "Question": ["利用typedef定义结构体不能编译通过诡异问题", ["今天在利用typedef定义结构体时,顺带定义了结构体的别名，指向结构体的指针变量别名以及结构体数组的别名，但是在程序的执行过程中法相智能是一段一段的执行，全部执行时编译器报错(用的是VS2008)，特向高手请教。", "\n程序代码如下:", "\n#include ", "\n#define len 10", "\n#define N 5", "\n#define null 0", "\ntypedef struct student", "\n{", "\n  int age;", "\n  float total;", "\n} person_alias,*pointer_struct_alias,Stu_alias[5];", "\nvoid main()", "\n{", "\n   /* 1首先是person", "\n      person_alias p1;  //这里person 等价于struct student", "\n      p1.age=20;p1.total=65.36;", "\n      printf(\"p1.age=%d,p1.total=%f\\n\",p1.age,p1.total);", "\n  */", "\n\n", "/* 2然后是定义结构体指针的别名 */", "\n      person_alias p2;", "\n      pointer_struct_alias pointer1; //定义一个指向结构体变量p2 的 指针变量pointer1", "\n      pointer1=&p2;", "\n      pointer1->age=29;pointer1->total=55.32;", "\n      printf(\"p2->age=%d,p2->total=%f\\n\",pointer1->age,(*pointer1).total);", "\n\n", "/*(3) 然后是结构数组的别名*/", "\n        Stu_alias Stu;", "\n     int i=0;", "\n     pointer_struct_alias pointer2;", "\n     pointer2=Stu;", "\n     for(;i\n     {", "\n         pointer2->age=2*i+2;", "\n         pointer2->total=1.1*i+60;", "\n     }", "\n     printf(\"结构体数组的数据为\\n\");", "\n     for(pointer2=Stu;pointer2\n     {", "\n         printf(\"Age=%d-->total=%f\\n\",pointer2->age,pointer2->total);", "\n     }", "\n        system(\"pause\");", "\n}", "\n经过测试，分别对 1,2,3进行编译时都是能够正确运行的，但是1,2,3段一起编译时就报错，因没有分数，望帮忙。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;n个{int, int, int} 对象的遍历&amp;#xff0c;时间复杂度是 n。&lt;br /&gt;map&amp;lt;int,vector&amp;gt; 对象的遍历&amp;#xff0c;时间复杂度是log(n)。&lt;br /&gt;理论上n&amp;gt;1时&amp;#xff0c;map的遍历更快。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体操作和map，vector等操作谁快谁慢", ["结构体{int, int, int}和map<int,vector>，这两个对数据存取和修改操作，一般谁快谁慢呢。数据上万条，也就是上万个结构体或者上万个map元素。"]], "Tag": "程序设计"}
{"Answer": "如果是直接序化 c 的结构体,就要了解 c 结构体的内存布局.还有内存大小端问题\r\n如果在安桌端用的是 java / c# 等。来反序化原始的 c结构内存数据,有点烦人.\r\n建议选用  protobuf      ans1 等格式化", "Konwledge_Point": "数据封装——结构体", "Question": ["跪求安卓客户端如何接收Ubuntu系统过来的结构体协议，还有应该怎么发送过去", ["安卓客户端怎么接受C语言写的结构体协议，应该怎么发送到服务器端进行数据交互"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体是一种复合数据类型&amp;#xff0c;它由不同数据类型的存储单元组合。例如&amp;#xff0c;学生的成绩表上有姓名、专业、学号和没门功课成绩&amp;#xff0c;姓名和专业可以看作是字符串型数据&amp;#xff0c;学号是无符号长整型数据&amp;#xff0c;每门功课是单精度浮点型数据&amp;#xff0c;由这些类型复合组成的学生成绩单数据类型&amp;#xff0c;就是结构体类型。&lt;/p&gt;\n&lt;p&gt;是用来存储成员的。&lt;/p&gt;\n&lt;p&gt;成员可以定义各种变量类型。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;说明&amp;#xff1a;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;struct 结构体名 {&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt;成员列表&lt;/p&gt;\n&lt;p&gt;};&lt;/p&gt;\n&lt;p&gt;结构体名是该结构体独一无二的名称&amp;#xff0c;命名规则与变量命名相同。成员项列表是结构体中数据成员的数据类型和名称。数据成员可以是变量、数组或者其他结构体等复合数据结构。成员项列表的一般形式为&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;数据类型 成员名1;&lt;/p&gt;\n&lt;p&gt;数据类型 成员名2;&lt;/p&gt;\n&lt;p&gt;数据类型 成员名3;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言中结构体变量有什么用？", ["结构体变量是什么？有什么作用？", "是用来存储成员的吗？", "成员是用来表示变量的值？"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/ggmove/article/details/17377117", "Konwledge_Point": "数据封装——结构体", "Question": ["java用jna调用c动态库结构体问题", ["接口是这样的：", "设备句柄已经没问题。结构体是这样：", "\n我模拟的结构体：", "但是new了之后传入一直返回传入指针为null的错误代码，请问这结构体应该怎么搞？"]], "Tag": "程序设计"}
{"Answer": "if else 最容易用非分支来计算了\r\n\r\n简化一下你的计算\r\n\r\n if (init == 0)//初始化点\r\n{\r\n        dataBuffer[f].pos = pos;\r\n｝\r\nelse\r\n｛\r\n     dataBuffer[f].pos = pos + dataBuffer[f].velocity; //根据力计算出坐标\r\n｝\r\n\r\n可以直接对应为：\r\n\r\n\r\ndataBuffer[f].pos = pos + clamp(0,1, floor(abs(init)) ) * dataBuffer[f].velocity; \r\n\r\n讲init取绝对值，再取整，再规到0-1之间，也就是，init ！= 0的结果全是1，跟后边的计算相乘。。。\r\n\r\n求分，求C币", "Konwledge_Point": "数据封装——结构体", "Question": ["unity ComputeShader里结构体变量初始化如何不用分支判断", ["unity ComputeShader里结构体变量初始化如何不用分支判断", "\n\n", "init 是一个int 类型   在跑完第一帧之后会被设置成其他值", "\n现在想求助各位大神", "\n如何在不使用标志位的情况下初始化这个结构体里的成员变量", "\n dataBuffer[f].pos = pos; ", "\n dataBuffer[f].velocity = float3(0, 0, 0);", "\n （补充说明：如果没有这个if分支初始化变量会导致不显示，直接初始化没有标志位分支表现结果和预期不符）", "\n\n", " // Each #kernel tells which function to compile; you can have many kernels\n#pragma kernel CSMain\n\n// Create a RenderTexture with enableRandomWrite flag and set it\n// with cs.SetTexture\nRWTexture2D<float4> Result;\nfloat3 mousePos;\nfloat3 originPos;\nfloat deltaTime;\nint init;\nfloat radius;\nstruct Data\n{\n    float3 pos;\n    float3 velocity;\n    float3 uv;\n};\nRWStructuredBuffer<Data> dataBuffer;\n\n//[numthreads(32, 32, 1)]\n\n[numthreads(32, 32, 1)]\nvoid CSMain(uint3 id : SV_DispatchThreadID)\n{\n    // TODO: insert actual code here!\n\n    //id.x 第X列的线程ID\n    //id.y 第Y行的线程ID\n\n    uint f = id.x + id.y * 32 * 64;\n    //   uint f = id.x + id.y * 32 * 64;\n    float3 pos = float3(id.x, id.y, id.z) / 2 + originPos; //计算出原始坐标\n    dataBuffer[f].uv = ((pos - originPos) / 2048) * 2; //计算出每个点的uv\n    //dataBuffer[f].uv = ((pos - originPos) / 2048) * 2; //计算出每个点的uv\n\n    if (init == 0)//初始化点\n    {\n        dataBuffer[f].pos = pos;\n        dataBuffer[f].velocity = float3(0, 0, 0);\n    }else\n    {\n\n        float3 dis = dataBuffer[f].pos - mousePos; //计算出当前坐标与鼠标点间的向量\n\n        float vel = clamp(radius - length(dis), 0.01, radius) * deltaTime * 20; //计算出力\n\n        dataBuffer[f].velocity += normalize(dis) * vel; //加上力\n\n        dataBuffer[f].velocity = normalize(dataBuffer[f].velocity) * clamp((length(dataBuffer[f].velocity) - deltaTime * 2), 0, radius); //限制力的范围，并且加上指向原始点的力\n\n        dataBuffer[f].pos = pos + dataBuffer[f].velocity; //根据力计算出坐标\n    }\n\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果从逻辑含义上来看的话&amp;#xff0c;p代表首节点或当前节点&amp;#xff0c;p-&amp;gt;pnext代表当前节点的下一个节点&amp;#xff0c;p为NULL代表当前节点为空&amp;#xff0c;p-&amp;gt;pnext为NULL代表当前节点的下一个节点为空&amp;#xff0c;一般代表用是否为空来判断当前节点是由有值&amp;#xff08;结构成员data&amp;#xff09;&amp;#xff0c;下面是一个例子&amp;#xff08;例子与实际编程的情况可能有所不同&amp;#xff09;&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-title\"&gt;typedef&lt;/span&gt; struct &lt;span class=\"hljs-type\"&gt;Node&lt;/span&gt;{\n&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;&lt;/span&gt;\n&lt;span class=\"hljs-title\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Node&lt;/span&gt; * pnext;\n}&lt;span class=\"hljs-type\"&gt;NODE&lt;/span&gt;,*&lt;span class=\"hljs-type\"&gt;PNODE&lt;/span&gt;;\n&lt;span class=\"hljs-type\"&gt;PNODE&lt;/span&gt; p;\n\n&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; main(void){\n    \n    &lt;span class=\"hljs-type\"&gt;PNODE&lt;/span&gt; p &amp;#61; (&lt;span class=\"hljs-type\"&gt;Node&lt;/span&gt;*)malloc(sizeof(&lt;span class=\"hljs-type\"&gt;Node&lt;/span&gt;));\n    p-&amp;gt;pnext&amp;#61;&lt;span class=\"hljs-type\"&gt;NULL&lt;/span&gt;;\n    p-&amp;gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; 1;&lt;/span&gt;\n    //printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;p-&amp;gt;data&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,p-&amp;gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);&lt;/span&gt;\n    \n    p-&amp;gt;pnext &amp;#61; (&lt;span class=\"hljs-type\"&gt;Node&lt;/span&gt;*)malloc(sizeof(&lt;span class=\"hljs-type\"&gt;Node&lt;/span&gt;));\n    p-&amp;gt;pnext-&amp;gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; 2;&lt;/span&gt;\n    p-&amp;gt;pnext-&amp;gt;pnext&amp;#61;&lt;span class=\"hljs-type\"&gt;NULL&lt;/span&gt;;\n//    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;p-&amp;gt;pnext-&amp;gt;data&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,p-&amp;gt;pnext-&amp;gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);&lt;/span&gt;\n\n    \n\n        while(p!&amp;#61;&lt;span class=\"hljs-type\"&gt;NULL&lt;/span&gt;){  //代表当前节点不为空&amp;#xff0c;即代表当前节点有值 \n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,p-&amp;gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);&lt;/span&gt;\n            p&amp;#61; p-&amp;gt;pnext;  //把p指向后一个节点pnext&amp;#xff0c; 如果赋值后的p不为&lt;span class=\"hljs-type\"&gt;NULL&lt;/span&gt;&amp;#xff0c;即代表pnext不为&lt;span class=\"hljs-type\"&gt;NULL&lt;/span&gt;&amp;#xff0c;代表下一个节点有值 \n        }\n    \n    \n    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/54111116555612.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针为NULL和结构体的成员指针为NULL的区别", ["结构体指针为NULL和结构体的成员指针为NULL的区别", "typedef struct Node{", "    int data;", "    struct Node * pnext;", "}NODE,*PNODE;", "PNODE p;", "p=NULL和p->pnext=NULL的区别"]], "Tag": "程序设计"}
{"Answer": "代表的类型就是你定义的结构体，结构体也是一种类型。\r\ntypedef struct{\r\nchar* stuNo;\r\nchar* stuName;\r\nchar* stuSex;\r\nint mathScore;\r\nint chinScoee;\r\n}DataType;\r\n\r\nDataType a; //a就是结构体的一个学生，你可以给他赋值\r\n\r\na.stuNo =“01”；//学号1号\r\na.stuName = \"张三\"；//名字张三\r\na.stuSex =“男”；//性别男\r\na.mathScore = 100;  //数学100\r\na.chainScore = 0; //语文0蛋\r\n\r\n其实如果有些东西理解不到不用这么深究，先记住，多写代码，代码写多了很多东西自然就懂了，个人感受！", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构顺序表   求指教！", ["1.typedef struct{", "\n     char* stuNo;", "\n     char* stuName;", "\n     char* stuSex;", "\n     int mathScore;", "\n     int chinScoee;", "\n}DataType; ", "\n\n", "2.typedef struct{", "\n    DataType *data; //一维数组data用于存放表节点", "\n    int length;      //线性表当前的长度", "\n}SeqList;", "\n\n", "1中的DataType和2中的SeqList意思一样吗？", "\n不一样的话分别代表什么意思？", "\n谢谢！"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include &lt;stdio.h&gt;\r\nstruct Student \r\n{\r\nint id; //学号\r\nchar name[20]; //姓名\r\nfloat score; //成绩\r\n};\r\nint main()\r\n{\r\nStudent  s[2];\r\nfor (int i = 0; i &lt; 2; i++)\r\n{\r\nscanf(\"%d\", &amp;s[i].id);\r\nscanf(\"%s\", s[i].name);\r\nscanf(\"%f\", &amp;s[i].score);\r\n}\r\nFILE * fp = fopen(\"students.txt\", \"w+\");\r\nfor (int i = 0; i &lt; 2; i++)\r\n{\r\nfprintf(fp, \"%d %s %f\\n\", s[i].id, s[i].name, s[i].score);\r\n}\r\nfclose();\r\nreturn 0;\r\n}\r\n```\r\n# 问题解决的话，请点下采纳，包括之前的问题。这样才能继续回答你后续的问题", "Konwledge_Point": "数据封装——结构体", "Question": ["68定义一个结构体类型，名称为 Student  struct Student ？", ["68.", "\n编程题", "\n定义一个结构体类型，名称为 Student ", "\nstruct Student ", "\n{", "\n    int id;           //学号", "\n    char name[20];    //姓名", "\n    float score;      //成绩", "\n};", "\n编写一个程序，从键盘输入2个学生的学号、姓名和成绩分别保存，再将2个学生的信息分行（每个学生信息占1行）输出到屏幕和“students.txt”文本文件中。", "\n请认真测试程序的正确性。将源代码以文本方式提交，不要直接提交文件。"]], "Tag": "程序设计"}
{"Answer": "```\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tint i,j;\r\n\tstruct A *a = (struct A *)calloc(3,sizeof(struct A));\r\n\tfor(i=0;i&lt;3;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;3;j++)\r\n\t\t{\r\n\t\t\tint * ptr = (int *)calloc(1,sizeof(int));\r\n\t\t\ta[i].num[j] = (int)ptr;\r\n\t\t}\r\n\t}\r\n\tfor(i=0;i&lt;3;i++)\r\n\t{\r\n\t\tfor(j=0;j&lt;3;j++)\r\n\t\t{\r\n\t\t\tfree((int*)a[i].num[j]); //编译器编译显示这里出错\r\n\t\t}\r\n\t}\r\n\tfree(a);\r\n\treturn 0;\r\n}\r\n \r\n```\r\n\r\n你这问题陷阱太多了：)\r\n我是按照你想在num数组中存储指针处理的。", "Konwledge_Point": "数据封装——结构体", "Question": ["如何解决C语言给结构体当中的数组分配堆空间的问题", ["#include", "\n#include", "\nstruct A{", "\n      int num[3];", "\n};", "\n\n", "int main()", "\n{", "\n     int i,j;", "\n     struct A *a = (struct A *)calloc(3,sizeof(struct A));", "\n         for(i=0;i<3;i++)", "\n        {", "\n            for(j=0;j<3;j++)", "\n                    a[i].num[j] = (int *)calloc(1,sizeof(int));", "\n        }", "\n        for(i=0;i<3;i++)", "\n               free(a[i].num[j]);   //编译器编译显示这里出错", "\n        free(a);", "\n        return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;typedef struct _student\n{\n    char name[20];\n    float eng;\n    float chn;\n    float maths;\n    float avg;\n}student;\n\nvoid main()\n{\n    student s[3];\n    int i;\n    for(i&amp;#61;0;i&amp;lt;3;i&amp;#43;&amp;#43;)\n    {\n        printf(&amp;#34;请输入第%d个学生的数据:\\n&amp;#34;,i&amp;#43;1);\n        printf(&amp;#34;请输入姓名:&amp;#34;);\n        scanf(&amp;#34;%s&amp;#34;,s[i].name);\n        printf(&amp;#34;请输入数学、英语和语文成绩&amp;#xff0c;用空格分开&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%f %f %f&amp;#34;,&amp;amp;s[i].maths,&amp;amp;s[i].eng,&amp;amp;s[i].chn);\n        s[i].avg &amp;#61; (s[i].maths&amp;#43;s[i].eng&amp;#43;s[i].chn)/3;\n    }\n    printf(&amp;#34;输出结果为:\\n&amp;#34;);\n    printf(&amp;#34;------------&amp;#34;);\n    printf(&amp;#34;姓名\\t成绩\\n&amp;#34;);\n    for(i&amp;#61;0;i&amp;lt;3;i&amp;#43;&amp;#43;)\n        printf(&amp;#34;%s\\t%.1f\\n&amp;#34;,s[i].name,s[i].avg);\n    \n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言，结构体和数组", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a[i].name[20]是什么鬼&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体的输入全部输出", []], "Tag": "程序设计"}
{"Answer": "CaoZuo[0].XiangMu=new string[2]\r\n那就在方法中将这个实例化", "Konwledge_Point": "数据封装——结构体", "Question": ["C# 结构体数组里的成员变量也是数组，如何进行定义和初始化？下面代码运行时提示“其他信息: 未将对象引用设置到对象的实例。”", ["namespace StructArrayTest", "\n{", "\n    public partial class Form1 : Form", "\n    {", "\n        public Form1()", "\n        {", "\n            InitializeComponent();", "\n            CaoZuoStructInit();", "\n        }", "\n\n", "    struct CAOZUO_STRUCT\n    {\n        public Single WenDu;\n        public string[] XiangMu;\n        public Single[] ShuZhi;\n    }\n    CAOZUO_STRUCT[] CaoZuo = new CAOZUO_STRUCT[2];\n    private void CaoZuoStructInit()\n    {\n        CaoZuo[0].WenDu = 25.0F;\n        CaoZuo[0].XiangMu[0] = \"电压\";\n        CaoZuo[0].XiangMu[1] = \"电流\";\n        CaoZuo[0].ShuZhi[0] = 50.0F;\n        CaoZuo[0].ShuZhi[1] = 2.0F;\n\n        CaoZuo[1].WenDu = 25.0F;\n        CaoZuo[1].XiangMu[0] = \"电压\";\n        CaoZuo[1].XiangMu[1] = \"电流\";\n        CaoZuo[1].ShuZhi[0] = 50.0F;\n        CaoZuo[1].ShuZhi[1] = 2.0F;\n\n    }\n    private void Form1_Load(object sender, EventArgs e)\n    {\n    }\n}\n", "\n\n", "}", "\n\n", "以上内容运行时会报错，“其他信息: 未将对象引用设置到对象的实例。”还会提示警告    1   从未对字段“StructArrayTest.Form1.CAOZUO_STRUCT.XiangMu”赋值，字段将一直保持其默认值 null E:\\VS_CSharp_Project\\StructArrayTest\\StructArrayTest\\Form1.cs   24  29  StructArrayTest"]], "Tag": "程序设计"}
{"Answer": "结构体指针和数组首地址相同，代码验证\r\n```\r\n #include \"stdafx.h\"\r\n#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nstruct A{\r\n\tint a[100];\r\n};\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\tstruct A aa;\r\n\tstruct A *pA=&amp;aa;\r\n\r\n\tcout&lt;&lt;hex&lt;&lt;pA&lt;&lt;endl;\r\n\tcout&lt;&lt;hex&lt;&lt;(pA-&gt;a)&lt;&lt;endl;\r\n\t\r\n\r\n\treturn 0;\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["关于c语言结构体指针的问题", ["结构体指针只包含了结构体的首地址还是包含了所有成员的地址？还有结构体的首地址是什么，比如第一个成员是一个数组，那么首地址是不是就是这个数组的首地址？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对比着C&amp;#43;&amp;#43;中类的初始化去理解&amp;#xff0c;struct和class的区别&lt;br /&gt;结构体内部除了定义内部成员变量外&amp;#xff0c;还可以定义对应的初始化函数&amp;#xff0c; 在声明一个结构体变量时&amp;#xff0c;就会默认调用这些符合条件的初始化函数。&lt;/p&gt;\n&lt;p&gt;去百度“结构体构造函数”这个知识点。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["这个结构体里面是什么？", ["这个结构体变量声明后面的是什么？", "有什么功能？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;It doesn't work because none of the fields in the File struct are exported.&lt;/p&gt;\n\n&lt;p&gt;The following works just fine:&lt;/p&gt;\n\n&lt;pre class=\"lang-golang prettyprint-override\"&gt;&lt;code&gt;package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n)\n\ntype File struct {\n    Name      string\n    TimeStamp int64\n}\n\nfunc main() {\n\n    files := make([]File, 0, 20)\n\n    filepath.Walk(\"/tmp/\", func(path string, f os.FileInfo, err error) error {\n\n        if f == nil {\n            return nil\n        }\n\n        name := f.Name()\n        if len(name) &amp;gt; 3 {\n            files = append(files, File{\n                Name:      name,\n                TimeStamp: f.ModTime().UnixNano() / int64(time.Millisecond),\n            })\n\n            // grow array if needed\n            if cap(files) == len(files) {\n                newFiles := make([]File, len(files), cap(files)*2)\n                for i := range files {\n                    newFiles[i] = files[i]\n                }\n                files = newFiles\n            }\n        }\n        return nil\n    })\n\n    fmt.Println(files)\n    encoder := json.NewEncoder(os.Stdout)\n    encoder.Encode(&amp;amp;files)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["自己的结构体数组的JSON编码", ["\n\n", "I try to read a directory and make a JSON string out of the file entries. But the json.encoder.Encode() function returns only empty objects. For test I have two files in a tmp dir: ", "\n\n", "test1.js  test2.js \n", "\n\n", "The go program is this:", "\n\n", "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"time\"\n)\n\ntype File struct {\n    name      string\n    timeStamp int64\n}\n\nfunc main() {\n\n    files := make([]File, 0, 20)\n\n    filepath.Walk(\"/home/michael/tmp/\", func(path string, f os.FileInfo, err error) error {\n\n        if f == nil {\n            return nil\n        }\n\n        name := f.Name()\n        if len(name) > 3 {\n            files = append(files, File{\n                name:      name,\n                timeStamp: f.ModTime().UnixNano() / int64(time.Millisecond),\n            })\n\n            // grow array if needed\n            if cap(files) == len(files) {\n                newFiles := make([]File, len(files), cap(files)*2)\n                for i := range files {\n                    newFiles[i] = files[i]\n                }\n                files = newFiles\n            }\n        }\n        return nil\n    })\n\n    fmt.Println(files)\n\n    encoder := json.NewEncoder(os.Stdout)\n    encoder.Encode(&files)\n}\n", "\n\n", "And the out that it produces is:", "\n\n", "[{test1.js 1444549471481} {test2.js 1444549481017}]\n[{},{}]\n", "\n\n", "Why is the JSON string empty?", "\n    "]], "Tag": "程序设计"}
{"Answer": "很经典的问题 ，画个内存四区图就知道了", "Konwledge_Point": "数据封装——结构体", "Question": ["求教大佬，关于C语言结构体指针的问题", ["我定义了一个结构体数组，然后题目要求按选择法把结构体内的数据从小到大排序。选择排序我是定义了一个函数，函数的参数是两个结构体指针（struct Stu_Score *p,struct Stu_Score *q），函数体内定义了一个中间指针变量struct Stu_Score *temp，在交换的时候就是用中间指针变量对p和q交换，结果这样并没有出现语法错误，但是在运行的时候显示已停止工作。后来我把指针变量还为普通的结构体变量，就是把*temp改成了temp（相应的调用时的-＞改成了.），结果这样运行就没问题了，请教大佬这是为什么"]], "Tag": "程序设计"}
{"Answer": "结构体里包含指针类型时，动态申请结构体内存并不会报错，但是在使用之前要对这个指针类型申请指向的内存。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体构成的栈初始化报错问题", ["char *str；似乎把这个写进结构体然后调用malloc（）就报错了，各位有遇到过吗？是不是这样啊？"]], "Tag": "程序设计"}
{"Answer": "没有用extern，那么定义了两个h变量，你访问的不是你应该访问的那个。", "Konwledge_Point": "数据封装——结构体", "Question": ["C++：new和delete结构体问题", ["假设有三个文件，分别为main.cpp,IRSend.cpp,IRSend.h", "\nIRSend.h内容为：", "\nclass IRSend", "\n{", "\npublic:", "\n        void a();", "\n        void b();", "\n        void c();", "\n};", "\nextern IRSend IR;", "\nIRSend.cpp内容为：", "\n#include\"IRSend.h\"", "\ntypedef struct {", "\n            int d;", "\n            int e;", "\n            int f;", "\n} hh;", "\nvolatile hh *h;", "\nvoid  IRSend::a()", "\n{", "\n    h=new volatile hh;", "\n}", "\nvoid  IRSend::b()", "\n{", "\n    delete h;", "\n}", "\nvoid  IRSend::c()", "\n{", "\n    h->d=1;", "\n    h->e=2;", "\n    h->f=3;", "\n}", "\nmain.cpp内容为：", "\n#include\"IRSend.h\"", "\nIRSend IR;", "\nvoid main()", "\n{", "\nwhile(1)", "\n    {", "\n         IR.a();//new结构体", "\n        IR.c();", "\n        IR.b();//delete结构体", "\n        }", "\n}", "\n\n", "请问上面new结构体和delete结构体有问题吗？（我的程序类似于上面）", "\n为什么执行后编译能通过，就是得不到想要的效果。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;仅供参考&amp;#xff0c;望采纳~&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; leap_year[]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;29&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;};\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; pin_year[]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;28&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;};\ntypedef struct data\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; mon;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; day;\n}d1;\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; inputdata(d1 *rq)\n{\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;rq-&amp;gt;year);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;rq-&amp;gt;mon);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;rq-&amp;gt;day);\n}\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; outputdata(d1 *rq)\n{\n    printf(&amp;#34;%d/%d/%d\\n&amp;#34;,rq-&amp;gt;year,rq-&amp;gt;mon,rq-&amp;gt;day);\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; count_day(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; mon,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; day)\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; result&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;((year%&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;amp;&amp;amp;year%&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)||(year%&lt;span class=\"hljs-number\"&gt;400&lt;/span&gt;&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;))//闰年&lt;span class=\"hljs-number\"&gt;366&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;mon;i&amp;#43;&amp;#43;)\n        {\n            result&amp;#43;&amp;#61;leap_year[i];\n        }\n        result&amp;#43;&amp;#61;day;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;//平年&lt;span class=\"hljs-number\"&gt;365&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;mon;j&amp;#43;&amp;#43;)\n        {\n            result&amp;#43;&amp;#61;pin_year[j];\n        }\n        result&amp;#43;&amp;#61;day;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)\n{\n    d1 &lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    inputdata(&amp;amp;&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;);\n    outputdata(&amp;amp;&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;);\n    n&amp;#61;count_day(&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;.year,&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;.mon,&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;.day);\n    printf(&amp;#34;%4d年%02d月%02d日是这一年中的第%d天\\n&amp;#34;,&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;.year,&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;.mon,&lt;span class=\"hljs-type\"&gt;time&lt;/span&gt;.day,n);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/529781890176118.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;br /&gt;ps&amp;#xff1a;未做日期限制&amp;#xff0c;勿输入不正常月份和天数&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求个思路解法！定义一个表示日期的结构体变量（包括年、月、日），并实现以下要 求：", ["a) 编写一个函数，用于让用户输入年、月、日，函数参数为结构体指", "针；", "b) 编写一个函数，实现用“年/月/日”格式输出日期（例如", "2020/5/15），函数参数为结构体变量；", "c) 编写一个函数，计算一个日期在本年中是第几天（注意闰年的问", "题），函数参数为要计算的日期（年、月、日），计算结果为函数", "返回值；", "d) 编写一个 main 函数，可以测试以上函数的功能，并给出 2020 年 5", "月 15 日是这一年中的第几天"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;表示ID,DLC各自占uint32类型的多少位。即ID变量长度为29位&amp;#xff0c;DLC变量为4位&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体成员这种形式是什么意思", [" typedef struct{", "     uint32 ID :29;", "     uint32 DLC :4;", "     uint32  :31;", "     uint8 Data[8];", " }Diag_TxBuffer_t;", "请问上面结构体的前3个成员的这种形式是什么意思？成员名加冒号再跟常数是什么意思？没有成员名，直接冒号和常数又是什么意思？求解惑"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改了一下&amp;#xff0c;如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;#define NC 100&lt;/span&gt;\nstruct studentRed {  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义学生记录&amp;#xff0c;即对应表格的一行\n    char studName[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;姓名对应第一列的Student Name\n    char studID[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;学号对应第二列的Student ID 用&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;个字符编码&amp;#xff0c;可用字母做学号\n    float compProgram; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; score &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; Computer programming 用浮点数可输入小数分数\n    float physEducat;  &lt;span class=\"hljs-regexp\"&gt;//s&lt;/span&gt;core &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; Computer programming\n    float commResech;  &lt;span class=\"hljs-regexp\"&gt;//s&lt;/span&gt;core &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; Communication &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; Research\n    float averageScore;  &lt;span class=\"hljs-regexp\"&gt;//a&lt;/span&gt;verage score\n}*p,students[NC]&amp;#61;{\n        {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;John&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zy001&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;84&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;86&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;78&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Xiaoming&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zy002&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;77&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;82&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;90&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Xiaohua&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zy003&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;79&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;82&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;85&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Jianguo&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zy004&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;84&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;86&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;78&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n        {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Xiaodong&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zy005&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;55&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;40&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;},\n};\n \nvoid insertAvgScore(struct studentRed *stu,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;length&lt;/span&gt;){\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&lt;span class=\"hljs-keyword\"&gt;length&lt;/span&gt; ;&amp;#43;&amp;#43;i) {\n        stu[i].averageScore&amp;#61;(stu[i].compProgram&amp;#43;stu[i].physEducat&amp;#43;stu[i].commResech)/&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    }\n}\nvoid printStudentInfo(struct studentRed *stu,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;length&lt;/span&gt;){\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Name\\t\\tID\\t\\tComputer\\tPhysical\\tCommunication\\tAverages\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-keyword\"&gt;length&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-12s%s\\t%f\\t%f\\t%f\\t\\t%f\\n&amp;#34;&lt;/span&gt;,stu[i].studName,stu[i].studID,stu[i].compProgram,stu[i].physEducat,stu[i].commResech,stu[i].averageScore);\n    }\n \n}\n \n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main(){\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;0\\n&amp;#34;&lt;/span&gt;);\n    insertAvgScore(students,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    &lt;span class=\"hljs-regexp\"&gt;//prin&lt;/span&gt;tStudentInfo(students,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    \n    FILE * fp &amp;#61; fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;f:\\\\stu.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#43;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fp&amp;#61;&amp;#61;NULL){\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;打开文件失败或创建文件失败&amp;#xff0c;程序退出&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; \n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;存放文件 \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        fprintf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %f %f %f %f &amp;#34;&lt;/span&gt;,students[i].studName,students[i].studID,students[i].compProgram,students[i].physEducat,students[i].commResech,students[i].averageScore); \n    } \n     \n    fclose(fp);\n    \n    fp &amp;#61; fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;f:\\\\stu.txt&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fp&amp;#61;&amp;#61;NULL){\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;打开文件失败&amp;#xff0c;程序退出&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; \n    }\n    \n    struct studentRed t[NC] ;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;1\\n&amp;#34;&lt;/span&gt;); \n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Name\\t\\tID\\t\\tComputer\\tPhysical\\tCommunication\\tAverages\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;从文件读取并打印 \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;){\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,t.studName);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,t.studID);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,t.compProgram);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,t.physEducat);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,t.commResech);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,t.averageScore);\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.1\\n&amp;#34;&lt;/span&gt;);\n        fscanf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%s%s%f%f%f%f &amp;#34;&lt;/span&gt;,t[i].studName,t[i].studID,&amp;amp;t[i].compProgram,&amp;amp;t[i].physEducat,&amp;amp;t[i].commResech,&amp;amp;t[i].averageScore); \n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n21\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-12s%s\\t%f\\t%f\\t%f\\t\\t%f\\n&amp;#34;&lt;/span&gt;,t[i].studName,t[i].studID,t[i].compProgram,t[i].physEducat,t[i].commResech,t[i].averageScore);    \n        &lt;span class=\"hljs-regexp\"&gt;//prin&lt;/span&gt;tf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n3\\n&amp;#34;&lt;/span&gt;);\n    } \n      \n    fclose(fp); \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["编程实现功能：可将整个students结构体数组存到硬盘上，并从存好的硬盘上读到内存的students结构体数组中", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "define", " NC 100", "\n", "struct", " ", "studentRed", " {  ", "//定义学生记录，即对应表格的一行", "\n    ", "char", " studName[", "20", "]; ", "//姓名对应第一列的Student Name", "\n    ", "char", " studID[", "20", "]; ", "//学号对应第二列的Student ID 用20个字符编码，可用字母做学号", "\n    ", "float", " compProgram; ", "// score for Computer programming 用浮点数可输入小数分数", "\n    ", "float", " physEducat;  ", "//score for Computer programming", "\n    ", "float", " commResech;  ", "//score for Communication and Research", "\n    ", "float", " averageScore;  ", "//average score", "\n}*p,students[NC]={\n        {", "\"John\"", ",", "\"zy001\"", ",", "84", ",", "86", ",", "78", ",", "0", "},\n        {", "\"Xiaoming\"", ",", "\"zy002\"", ",", "77", ",", "82", ",", "90", ",", "0", "},\n        {", "\"Xiaohua\"", ",", "\"zy003\"", ",", "79", ",", "82", ",", "85", ",", "0", "},\n        {", "\"Jianguo\"", ",", "\"zy004\"", ",", "84", ",", "86", ",", "78", ",", "0", "},\n        {", "\"Xiaodong\"", ",", "\"zy005\"", ",", "60", ",", "55", ",", "40", ",", "0", "},\n};\n\n", "void", " ", "insertAvgScore", "(", "struct", " studentRed *stu,", "int", " length)", "{\n    ", "for", " (", "int", " i = ", "0", "; i <length ;++i) {\n        stu[i].averageScore=(stu[i].compProgram+stu[i].physEducat+stu[i].commResech)/", "3", ";\n    }\n}\n", "void", " ", "printStudentInfo", "(", "struct", " studentRed *stu,", "int", " length)", "{\n    ", "printf", "(", "\"Name\\t\\tID\\t\\tComputer\\tPhysical\\tCommunication\\tAverages\\n\"", ");\n    ", "for", "(", "int", " i=", "0", ";i<length;i++){\n        ", "printf", "(", "\"%-12s%s\\t%f\\t%f\\t%f\\t\\t%f\\n\"", ",stu[i].studName,stu[i].studID,stu[i].compProgram,stu[i].physEducat,stu[i].commResech,stu[i].averageScore);\n    }\n\n}\n\n", "int", " ", "main", "()", "{\n    ", "insertAvgScore", "(students,", "5", ");\n    ", "printStudentInfo", "(students,", "5", ");\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "你声明的是int data[1]；意味data是一个只有一个元素的数组。你所进行的g-&gt;data[1]访问实际上是非法的。", "Konwledge_Point": "数据封装——结构体", "Question": ["32位下结构体指针值莫名其妙的改变了，64位没问题，请问是什么情况？", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;定义个学生结构&amp;#xff0c;然后定义学生数组&amp;#xff0c;逐个输入再求值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; id;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; avg;\n}student;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(student *s,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个学生的学号:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;s[i].id);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个学生的姓名:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n        &lt;span class=\"hljs-built_in\"&gt;gets&lt;/span&gt;(s[i].name);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个学生的数学成绩:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;s[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个学生的物理成绩:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;s[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个学生的计算机成绩:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;s[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n        s[i].avg &amp;#61; (s[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; s[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#43; s[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])/&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;output&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(student *s,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-10s%-22s%-10s%-10s%-10s%-10s\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;数学&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;物理&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;计算机&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;平均分&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%-10d%-22s%-10.1f%-10.1f%-10.1f%-10.1f\\n&amp;#34;&lt;/span&gt;,s[i].id,s[i].name,s[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],s[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],s[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;],s[i].avg);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getHigh&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(student *s,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; max &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s[i].avg &amp;gt; s[max].avg)\n            max &amp;#61; i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;最高分学生信息为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号: %d\\n&amp;#34;&lt;/span&gt;,s[max].id);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名: %s\\n&amp;#34;&lt;/span&gt;,s[max].name);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;数学: %.1f\\n&amp;#34;&lt;/span&gt;,s[max].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;物理: %.1f\\n&amp;#34;&lt;/span&gt;,s[max].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;计算机: %.1f\\n&amp;#34;&lt;/span&gt;,s[max].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;平均分: %.1f\\n&amp;#34;&lt;/span&gt;,s[max].avg);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    student stu[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;];\n    &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(stu,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;output&lt;/span&gt;(stu,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;getHigh&lt;/span&gt;(stu,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体数组及结构体数组成员的访问方法", ["有4个学生，每个学生的信息包括学号、姓名、3门课程（数学、物理、计算机）的成绩，如下表所示：", "学号", "姓名", "数学", "物理", "计算机", "1001", "Wang li", "93", "89", "87", "1002", "Li shan", "85", "80", "78", "1003", "Zhao min", "65", "70", "60", "1004", "Ma yun", "77", "70", "83", "（1） 从键盘上输入4个学生的上述信息（要有提示性语句）；", "（2） 计算每个学生的平均成绩；", "（3） 输出各位同学的学号、姓名、数学、物理、计算机成绩和平均成绩；", "（4） 输出平均成绩最高的同学的学号、姓名、数学、物理、计算机成绩和平均成绩。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n#include &amp;lt;stdio.h&amp;gt;\n\ntypedef struct book\n{\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; danjia, xse;\n    int xiaol;\n} BOOK;\n\nint main()\n{\n    BOOK &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;], temp;\n    int i, j;\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s%f%d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].name, &amp;amp;&lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].danjia, &amp;amp;&lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].xiaol);\n        &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].xse &amp;#61; &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].xiaol * &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].danjia;\n    }\n\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        for (j &amp;#61; i; j &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; j&amp;#43;&amp;#43;)\n        {\n            if (&lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i].xse &amp;lt; &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j].xse)\n            {\n                temp &amp;#61; &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i];\n                &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[i] &amp;#61; &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j];\n                &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j] &amp;#61; temp;\n            }\n        }\n    }\n    for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; j&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %.2f %d %.2f&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j].name, &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j].danjia, &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j].xiaol, &lt;span class=\"hljs-type\"&gt;list&lt;/span&gt;[j].xse);\n    }\n\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义一个结构体数组，输入五本书的信息（图书销售额 = 图书销量 * 单价），然后按照图书销量排序，输出排序结果；再按照图书销售额排序，输出排序结果。", ["解题思路：一个排序可以使用排序算法，定义一个struct book 结构体变量temp，用于排序中的交换；两个结构体变量可以直接赋值，如：list[i] = temp;"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff0c;有问题再沟通&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;这个问题是由于使用 strcpy 函数将字符串 &amp;#34;\\0&amp;#34; 复制到 stu[i].r 中时出现的。&lt;/li&gt;&lt;li&gt;strcpy 函数的作用是将一个字符串的内容复制到另一个字符串中。然而&amp;#xff0c;在这种情况下&amp;#xff0c;stu[i].r 是一个字符数组&amp;#xff0c;而不是一个指向字符串的指针。因此&amp;#xff0c;使用 strcpy 函数将字符串 &amp;#34;\\0&amp;#34; 复制到 stu[i].r 中时&amp;#xff0c;会将字符串 &amp;#34;\\0&amp;#34; 中的所有字符&amp;#xff08;即&amp;#39;\\0&amp;#39;&amp;#xff09;复制到 stu[i].r 中。&lt;/li&gt;&lt;li&gt;此外&amp;#xff0c;在使用 scanf 函数读入字符串时&amp;#xff0c;字符串后面会自动添加一个空字符&amp;#39;\\0&amp;#39;&amp;#xff0c;因此最终会在 stu[i].r 中有两个空字符&amp;#39;\\0&amp;#39;&amp;#xff0c;导致最后输出的字符串中多出了两个空字符&amp;#39;\\0&amp;#39;。&lt;/li&gt;&lt;li&gt;要解决这个问题&amp;#xff0c;可以使用 memset 函数将 stu[i].r 中的每个字符都设为&amp;#39;\\0&amp;#39;&amp;#xff0c;或者直接使用 stu[i].r &amp;#61; {0} 初始化字符数组。&lt;/li&gt;&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;memset(stu&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.r&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, sizeof(stu&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.r&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;或者&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;stu[i].r &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体难度不大的问题，求解决", ["#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " N,i;\n    ", "scanf", "(", "\"%d\"", ",&N);\n    ", "struct", " ", "student", "\n    {\n\n        ", "char", " r[", "20", "];\n        ", "int", " b,c,d;\n\n    } stu[N];\n    ", "for", "(i=", "0", "; i<N; i++)\n    {\n        ", "strcpy", "(stu[i].r,", "\"\\0\"", ");\n    }\n    ", "for", "(i=", "0", "; i<N; i++)\n    {\n        ", "scanf", "(", "\"%s %d %d\"", ",stu[i].r,&stu[i].b,&stu[i].c);\n        stu[i].d=stu[i].c*", "1000", "+stu[i].b;\n    }\n    ", "printf", "(", "\"\\n\"", ");\n    ", "for", "(i=", "0", "; i<N; i++)\n    {\n        ", "printf", "(", "\"%s %d\\n\"", ",stu[i].r,stu[i].d);\n![img](https:", "//img-mid.csdnimg.cn/release/static/image/mid/ask/33311007027613.png \"#left\")", "\n\n    }\n    ", "return", " ", "0", ";\n}\n", "\n", "题目：现有N名销售人员，每名销售人员的工资由基本工资与绩效组成，其中绩效为当月成功订单金额中抽成10%，现给出每名销售人员的基本情况，输出每名销售人员的姓名与工资情况。", "\n", "\n", "为什么第五个数据中的名字最后输出的时候会多出来PG两个字母？我尝试过对结构体中的数组赋空格的初值，发现最后还是有这两个字母，求告知原因和解决方法。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;len_tch算错了&amp;#xff0c;srand放到main里面只调用一次&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ 结构体_指针_函数例题", ["问题遇到的现象和发生背景", "\n", "不明白为什么我的随机数只赋值了一遍，不明白为什么我的teacher就打印了一遍", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<ctime>", "\n", "#", "include", " ", "<string>", "\n", "using", " ", "namespace", " std;\n\n", "// 学生结构体", "\n", "struct", " ", "Student", "\n{\n    ", "// 学生姓名", "\n    string Name_stu;\n\n    ", "// 学生分数(随机数)", "\n    ", "int", " Score;\n};\n\n", "// t结构体", "\n", "struct", " ", "Teacher", "\n{\n    ", "// t姓名", "\n    string Name_tch;\n\n    ", "// 学生数组", "\n    ", "struct", " ", "Student", " Array_stu[", "5", "];\n};\n\n", "// 函数声明", "\n\n", "// 命名函数", "\n", "void", " ", "Allocate_name", "(", "struct", " Teacher Array_tch[], ", "int", " len_tch, ", "int", " len_stu)", ";\n", "// 传入t数组，t数组长度，学生数组长度", "\n\n", "// 打印函数", "\n", "void", " ", "Print_result", "(", "struct", " Teacher Array_tch_fun[], ", "int", " len_tch, ", "int", " len_stu)", ";\n", "// 传入t数组，t数组长度，学生数组长度", "\n\n", "int", " ", "main", "()", "\n", "{\n\n    ", "// 1.创建一个有三个t的数组", "\n\n    ", "struct", " ", "Teacher", " Array_tch[", "3", "];\n\n    ", "// 2.给每个t名字，给每个学生赋值名字和分数(随机数)", "\n\n    ", "int", " len_tch = ", "sizeof", "(Array_tch) / ", "sizeof", "(Array_tch);\n    ", "int", " len_stu = ", "sizeof", "(Array_tch->Array_stu) / ", "sizeof", "(Array_tch->Array_stu[", "0", "]);\n    ", "Allocate_name", "(Array_tch, len_tch, len_stu);\n\n    ", "// 3.打印出结果", "\n\n    ", "Print_result", "(Array_tch, len_tch, len_stu);\n\n    ", "return", " ", "0", ";\n}\n\n\n\n", "// 命名和赋值函数", "\n", "void", " ", "Allocate_name", "(", "struct", " Teacher Array_tch[], ", "int", " len_tch, ", "int", " len_stu)", "\n", "{\n    string Nameseed = ", "\"ABCDE\"", ";\n    \n    ", "// teacher 命名", "\n    ", "for", " (", "int", " i = ", "0", "; i < len_tch; i++)\n    {\n        Array_tch[i].Name_tch = ", "\"Teacher_\"", ";\n        Array_tch[i].Name_tch += Nameseed[i];\n\n        ", "// student 命名", "\n        ", "for", " (", "int", " j = ", "0", "; j < len_stu; j++)\n        {\n            Array_tch[i].Array_stu[j].Name_stu = ", "\"Student_\"", ";\n            Array_tch[i].Array_stu[j].Name_stu += Nameseed[j];\n\n            ", "// student 赋分", "\n            ", "srand", "((", "unsigned", ")", "time", "(", "NULL", "));\n            ", "int", " num = ", "rand", "() % ", "101", "; ", "// 0到100", "\n            \n            Array_tch[i].Array_stu[j].Score = num;\n        }\n    }\n}\n\n\n", "// 打印函数", "\n", "void", " ", "Print_result", "(", "struct", " Teacher Array_tch_fun[],", "int", " len_tch, ", "int", " len_stu)", "\n", "{\n    ", "// 打印t信息", "\n    ", "for", " (", "int", " i = ", "0", "; i < len_tch; i++)\n    {\n        cout << Array_tch_fun[i].Name_tch << ", "\"\\t\"", " << endl;\n\n        ", "// 打印学生姓名和分数", "\n        ", "for", " (", "int", " j = ", "0", "; j < len_stu; j++)\n        {\n            cout << Array_tch_fun[i].Array_stu[j].Name_stu << ", "\"\\t\"", "\n                 << ", "\"得分:\"", " << ", "\"\\t\"", " << Array_tch_fun[i].Array_stu[j].Score << ", "\"\\t\"", " << endl;\n        }\n        cout << endl;\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "解决不了", "\n", "我想要达到的结果", "\n", "ABC t各带ABCDE五个学生，", "\n"]], "Tag": "程序设计"}
{"Answer": "这里有一个误解\r\n\r\n```\r\n fun(s[1]);\r\n```\r\n\r\n\r\n```\r\n 并不是传递数组，而是传递了一个结构体变量  (这个变量是结构体数组s的第二个元素)\r\n```\r\n所以\r\n\r\n\r\n\r\n```\r\n  fun(s[1]);\r\n```\r\n仍然属于传值方式，将参数的一个拷贝传给函数，函数的执行并不影响原来的变量值。", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体数组变量作参数的问题", ["书上说数组都是以传地址的方式进行参数传递的。为什么A，B的输出不同？结构体数组变量s[1]", "\n作为参数和结构体变量成员s作参传递的都是数组，为什么输出不同？", "\nA:#include ", "\n#include", "\ntypedef struct {char name[10];} STU;", "\nvoid fun(char name[10])", "\n{", "\n    strcpy(name,\"sun\");", "\n}", "\nint main()", "\n{", "\n    STU s={\"qian\"};", "\n    fun(s.name);", "\n    printf(\"%s\",s.name);", "\n}", "\noutput:sun", "\n\n", "B：", "\n#include ", "\n#include", "\ntypedef struct {char name[10];} STU;", "\nvoid fun(STU t)", "\n{", "\n    strcpy(t.name,\"sun\");", "\n}", "\nint main()", "\n{", "\n    STU s[2]={\"qian\",\"zhao\"};", "\n    fun(s[1]);", "\n    printf(\"%s\",s[1].name);", "\n}", "\noutput:zhao"]], "Tag": "程序设计"}
{"Answer": "需要双指针\r\n# 问题解决的话，请点采纳\r\n```\r\n#include &lt;stdio.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n#include &lt;string.h&gt;\r\n\r\ntypedef int elemtype;\r\nstruct Node {\r\n    struct Node* next;\r\n    elemtype data;\r\n};\r\ntypedef struct Node node;\r\nnode* getnode(elemtype x, node* nextptr) {\r\n    node* n;\r\n    n = (node*)malloc(sizeof(node));\r\n    n-&gt;data = x;\r\n    n-&gt;next = nextptr;\r\n    return n;\r\n}\r\n\r\ntypedef struct {\r\n    node* front;\r\n    node* rear;\r\n    int length;\r\n\r\n}swlqueue;\r\n\r\nvoid  initqueue(swlqueue** qd) {\r\n    *qd = (swlqueue*)malloc(sizeof(swlqueue));\r\n    (*qd)-&gt;front = getnode(0, NULL);\r\n    (*qd)-&gt;rear = (*qd)-&gt;front;\r\n    (*qd)-&gt;length = 0;\r\n}\r\n\r\nvoid insertafter(node* n, node* p) {\r\n    p-&gt;next = n-&gt;next;\r\n    n-&gt;next = p;\r\n}\r\n\r\n\r\n\r\nvoid in(swlqueue* q, elemtype x) {\r\n    node* newnode;\r\n    newnode = getnode(x, NULL);\r\n    if (q-&gt;length == 0)\r\n        insertafter(q-&gt;front, newnode);\r\n    insertafter(q-&gt;rear, newnode);\r\n    q-&gt;rear = newnode;\r\n    q-&gt;length++;\r\n}\r\n\r\nelemtype out(swlqueue* q) {\r\n    node* n;\r\n    elemtype x;\r\n    x = ((q-&gt;front)-&gt;next)-&gt;data;\r\n    n = q-&gt;front;\r\n    q-&gt;front = (q-&gt;front)-&gt;next;\r\n    free(n);\r\n    q-&gt;length--;\r\n    return x;\r\n}\r\n\r\nint main() {\r\n    swlqueue *q;\r\n    initqueue(&amp;q);\r\n    int array[20];\r\n    memset(array, 0, sizeof(array));\r\n    for (int i = 0; i &lt;= 50; i++)\r\n        in(q, i);\r\n    for (int j = 0; j &lt; 20; j++)\r\n        array[19 - j] = out(q);\r\n    for (int k = 0; k &lt;= 19; k++)\r\n        printf(\"%d\\n\", array[k]);\r\n    system(\"pause\");\r\n    return 0;\r\n\r\n\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/202005/12/1589248404_64595.png)", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体变量初始化失败", ["main()函数中的结构体变量q调用initqueue()初始化失败了，不知道为什么，我明明用了地址来调用初始化函数的", "\n\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef int elemtype;\nstruct Node {\n    struct Node* next;\n    elemtype data;\n};\ntypedef struct Node node;\nnode* getnode(elemtype x, node* nextptr) {\n    node* n;\n    n = (node*)malloc(sizeof(node));\n    n->data = x;\n    n->next = nextptr;\n    return n;\n}\n\ntypedef struct {\n    node* front;\n    node* rear;\n    int length;\n\n}swlqueue;\n\nvoid  initqueue(swlqueue* qd) {\n    qd = (swlqueue*)malloc(sizeof(swlqueue));\n    qd->front = getnode(0, NULL);\n    qd->rear = qd->front;\n    qd->length = 0;\n}\n\nvoid insertafter(node* n, node* p) {\n    p->next = n->next;\n    n->next = p;\n}\n\n\n\nvoid in(swlqueue* q, elemtype x) {\n    node* newnode;\n    newnode = getnode(x, NULL);\n    if (q->length == 0)\n        insertafter(q->front, newnode);\n    insertafter(q->rear, newnode);\n    q->rear = newnode;\n    q->length++;\n}\n\nelemtype out(swlqueue* q) {\n    node* n;\n    elemtype x;\n    x = ((q->front)->next)->data;\n    n = q->front;\n    q->front = (q->front)->next;\n    free(n);\n    q->length--;\n    return x;\n}\n\nint main() {\n    swlqueue q;\n    initqueue(&q);\n    int array[20];\n    memset(array, 0, sizeof(array));\n    for (int i = 0; i <= 50; i++)\n        in(&q, i);\n    for (int j = 0; j < 20; j++)\n        array[19 - j] = out(&q);\n    for (int k = 0; k <= 19; k++)\n        printf(\"%d\\n\", array[k]);\n    system(\"pause\");\n    return 0;\n\n\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳。用结构体比较分数大小的一种方法是定义一个结构体&amp;#xff0c;用来存储分数信息&amp;#xff0c;包括分子和分母。然后你可以写一个函数&amp;#xff0c;用来比较两个分数的大小。在 C 语言中&amp;#xff0c;你可以这样定义结构体&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;struct fraction {\n    int numerator&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    int denominator&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面是一个示例函数&amp;#xff0c;它比较两个分数的大小&amp;#xff0c;并返回它们的差值&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-symbol\"&gt;int&lt;/span&gt; compare_fractions(struct fraction &lt;span class=\"hljs-built_in\"&gt;f1&lt;/span&gt;, struct fraction &lt;span class=\"hljs-built_in\"&gt;f2&lt;/span&gt;) {\n    &lt;span class=\"hljs-comment\"&gt;// 先将两个分数都化为同类型的分数&amp;#xff0c;即分子和分母都是整数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;f1&lt;/span&gt;.numerator *&amp;#61; &lt;span class=\"hljs-built_in\"&gt;f2&lt;/span&gt;.denominator&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;f2&lt;/span&gt;.numerator *&amp;#61; &lt;span class=\"hljs-built_in\"&gt;f1&lt;/span&gt;.denominator&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;// 然后比较分子的大小&amp;#xff0c;返回它们的差值&lt;/span&gt;\n    return &lt;span class=\"hljs-built_in\"&gt;f1&lt;/span&gt;.numerator - &lt;span class=\"hljs-built_in\"&gt;f2&lt;/span&gt;.numerator&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你可以调用这个函数来比较两个分数&amp;#xff0c;比如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;fraction&lt;/span&gt; f1 &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;fraction&lt;/span&gt; f2 &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;};\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; diff &amp;#61; &lt;span class=\"hljs-built_in\"&gt;compare_fractions&lt;/span&gt;(f1, f2);\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (diff &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;f1 is greater than f2\\n&amp;#34;&lt;/span&gt;);\n} &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (diff &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;f1 is less than f2\\n&amp;#34;&lt;/span&gt;);\n} &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;f1 is equal to f2\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言，用结构体比较分数大小", ["请问怎么用结构体比较分数大小呢？在C语言中是不是不可以直接分子除以分母再比较小数啊……", "\n", "\n```c\n", "#", "include", "\"stdio.h\"", "\n", "#", "include", "\"math.h\"", "\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "struct", "\n    {\n        ", "int", " a;\n        ", "int", " b;\n        ", "double", " z;\n    }f1,f2;\n    ", "scanf", "(", "\"%d %d\"", ",&f1.a,&f1.b);\n    ", "scanf", "(", "\"%d %d\"", ",&f2.a,&f2.b);\n    f1.z = ", "1.0", " * f1.a / f1.b;\n    f2.z = ", "1.0", " * f2.b / f2.b;\n    ", "if", "(f1.z < f2.z)\n    ", "printf", "(", "\"%d/%d < %d/%d\"", ",f1.a,f1.b,f2.a,f2.b);\n    ", "if", "(f1.z == f2.z)\n    ", "printf", "(", "\"%d/%d = %d/%d\"", ",f1.a,f1.b,f2.a,f2.b);\n    ", "if", "(f1.z > f2.z)\n    ", "printf", "(", "\"%d/%d > %d/%d\"", ",f1.a,f1.b,f2.a,f2.b);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;同学&amp;#xff0c;当你明白题干的意思后就可以看选项了。&lt;br /&gt;c选项最好解决&amp;#xff0c;要知道结构体名字是不能够使用的。&lt;br /&gt;那么接下来就是a&amp;#xff0c;d选项&amp;#xff0c;它们有个共同点&amp;#xff0c;都含有-&amp;gt;&amp;#xff0c;我们都知道点运算符“.”&amp;#xff0c;和箭头运算符“-&amp;gt;”可以用于访问结构体的成员&amp;#xff0c;只不过箭头运算符需要与结构体指针结合使用&amp;#xff0c;故-&amp;gt;只能用在结构体指针&amp;#xff0c;本题根本不含指针变量&amp;#xff0c;class只是数组&amp;#xff0c;所以a,d选项是错误的。&lt;br /&gt;b选项&amp;#xff0c;在class[10]被赋值后访问的是“H”&amp;#xff0c;H的ascll码正好是72.&lt;br /&gt;故本题选B。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["有关结构体的选择题。", ["\n", "有关结构体的题，A选项，百度解析说是29+21+21，为啥子Ծ‸Ծ"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Position 也是一个结构体吧&amp;#xff0c;里面有什么成员。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体数组的调用", ["有这样一个结构体数组", "struct LNode {", "    ElementType Data[10000];", "    Position Last;", "};", "假如 数据存储下标从0开始，Last=2 , 那么在没有对数组进行初始化的情况下，对数组中Last位置之后的元素进行调用是否合法呢，如果合法，那这些元素有默认值吗", "比如  L－>Data[3]"]], "Tag": "程序设计"}
{"Answer": "cout &lt;&lt; (int)(&amp;(A.a)) &lt;&lt; endl;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体里的第一个字符变量无法正确取出地址", ["定义一个结构体，结构体的第一个成员是一个字符变量，然后在主函数里创建一个这个结构体的对象，取这个对象的在结构体中的第一个字符变量的地址，在winxp系统下显示出来的是乱码，在安卓手机上的AIDE下运行也没有正常显示出来，而把结构体的第一个变量定义成如int型的其他类型的变量就可以正常显示出地址，这是为什么"]], "Tag": "程序设计"}
{"Answer": "主函数里为什么会有两个creat函数调用，我把你的代码测试了一下，去掉第一个creat 是可以运行成功的，也有输出信息。另外你的代码缺少标准库能编译通过吗？希望有所帮助。\r\n#include&lt;stdlib.h&gt;\r\n#include &lt;stdio.h&gt; \r\n #define LEN sizeof(student)\r\n \r\n struct student{\r\n int num;\r\n float score;\r\n student *next;\r\n };\r\n \r\n student * creat(){\r\n int num;\r\n float score;\r\n student *head, *p,*q;\r\nq=p=head = (student *)malloc(LEN);\r\nhead-&gt;num = NULL;\r\nscanf(\"%d%f\",&amp;num,&amp;score);\r\nwhile (num != 0)//如果输入0的话就当成结束\r\n{\r\n    p = (student*)malloc(LEN);\r\n    p-&gt;num = num;\r\n    p-&gt;score = score;\r\n    p-&gt;next = NULL;\r\n    q-&gt;next = p;\r\n    q = q-&gt;next;\r\n    scanf(\"%d%f\",&amp;num,&amp;score);\r\n}\r\np-&gt;next = NULL;\r\nreturn head;\r\n\r\n\r\n}\r\n void print(student * head){\r\n student *p;\r\n p = head;\r\n for (; p-&gt;next != NULL;)\r\n {\r\n printf(\"%d %f\", p-&gt;next-&gt;num, p-&gt;next-&gt;score);\r\n p = p-&gt;next;\r\n }\r\n\r\n}\r\nint main(){\r\n student *head;\r\n head = creat();\r\n print(head);\r\n\r\nreturn 0;\r\n}", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言链表创建问题..123", ["#include\"stdafx.h\"", "\n#include", "\n#define LEN sizeof(student)", "\nstruct student{", "\n    int num;", "\n    float score;", "\n    student *next;", "\n};", "\n student * creat(){", "\n     int num;", "\n     float score;", "\n    student *head, *p,*q;", "\n\n", "q=p=head = (student *)malloc(LEN);\nhead->num = NULL;\nscanf_s(\"%d%f\",&num,&score);\nwhile (num != 0)//如果输入0的话就当成结束\n{\n    p = (student*)malloc(LEN);\n    p->num = num;\n    p->score = score;\n    p->next = NULL;\n    q->next = p;\n    q = p;\n    scanf_s(\"%d%f\",&num,&score);\n}\np->next = NULL;\nreturn head;\n", "\n\n", "}", "\nvoid print(student * head){", "\n    student *p;", "\n    p = head;", "\n    for (; p->next != NULL;)", "\n    {", "\n        printf(\"%d %f\", p->next->num, p->next->score);", "\n        p = p->next;", "\n    }", "\n\n", "}", "\nvoid main(){", "\n    student *head;", "\n    creat();", "\n    head = creat();", "\n    print(head);", "\n\n", "}", "\n//我输入", "\n1 20", "\n2 30", "\n3 40", "\n0 10", "\n的话没有输出什么东西啊"]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/lethic/article/details/7781203", "Konwledge_Point": "数据封装——结构体", "Question": ["C++怎么对数组的结构体排序结果不稳定？", ["C++库函数利用函数指针对数组结构体排序的方法是什么？怎么样克服排序结果不稳定的弊端？"]], "Tag": "程序设计"}
{"Answer": "stu[0].code = 20140001;\r\nstu[0].name = \"xxx\";\r\n...", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体数组在头文件里赋值的问题", ["\n上面的赋值是写在一个头文件里的，用VS2008，或者VC++6.0调都会出现上面的错误，VS2013和DEV就不会报错。", "\n完整代码是：", "\n//头文件“信息.h”", "\nstruct students", "\n{", "\n    long code;", "\n    char *name;", "\n    float score[3];", "\n    float sum;", "\n};", "\nvoid default_initiate(struct students stu[ ])", "\n{", "\n    stu[0] = { 20140001, \"陈龙\", {50.0, 30.0, 89.0 }};", "\n}", "\n\n", "//main函数", "\nint  main( )", "\n{", "\n    int a[2],c;", "\n    struct students class1[3];", "\n    default_initiate(class1);", "\n    return 0；", "\n}", "\n请问语法是哪里错了呢？一定要把给结构体数组赋初值放到main函数里面吗？", "\n学生党一枚，请各位大大们帮忙！"]], "Tag": "程序设计"}
{"Answer": "用类吧，分别建立两个数组类，然后用友元函数相互就可以调用了", "Konwledge_Point": "数据封装——结构体", "Question": ["请问两个结构体怎么建立相互联系呢？", ["其实是两个数组，一个float[3] 类型的数组和 float[6]类型的数组。 3个为一个点，第二个的两个点不能重复（和顺序无关）。怎么建立联系才能通过第一个找到第二个，同样可以通过第二个返回来找到第一个对应得"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;chanping_info&lt;/span&gt;\n{\n    int shchl[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    int xsl[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n}zhengge[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;];\n\n&lt;span class=\"hljs-comment\"&gt;//定义一个新的结构体&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;StNode&lt;/span&gt; \n{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;chanping_info&lt;/span&gt; data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;StNode&lt;/span&gt;* next;\n};\n\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;StNode&lt;/span&gt;* &lt;span class=\"hljs-built_in\"&gt;creat&lt;/span&gt;()\n{\n    int i,j;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;StNode&lt;/span&gt;* head,*node,*&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;;\n    head &amp;#61; node &amp;#61; &lt;span class=\"hljs-built_in\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        end-&amp;gt;data &amp;#61; zhengge[i];\n        &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;-&amp;gt;next &amp;#61; &lt;span class=\"hljs-built_in\"&gt;NULL&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//节点串联起来&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(head &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;NULL&lt;/span&gt;)\n        {\n            head &amp;#61; &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;;\n            node &amp;#61; head;\n        }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            node-&amp;gt;next &amp;#61; &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;;\n            node &amp;#61; &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;&lt;span class=\"hljs-comment\"&gt;//返回链表头&lt;/span&gt;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["建立了一个结构体数组，然后又想建立链表", ["我的结构体是这样的", "struct chanping_info", "{     int shchl[5];", "        int xsl[5];", "}zhengge[4];那怎么建立链表啊？而且数据已经在另一个函数里完成输入了。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;I would recommend embedding the Updateable struct into the larger struct:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type UpdateableUser struct {\n    FirstName string\n    LastName  string\n    Email     string\n    Tlm       float64\n    Dob       time.Time\n}\n\ntype User struct {\n    UpdateableUser\n    ID      string\n    created time.Time\n   updated time.Time\n}\n\nfunc (u *User) UpdateFrom(src *UpdateableUser) {\n    if src.FirstName != \"\" {\n        u.FirstName = src.FirstName\n    }\n    if src.LastName != \"\" {\n        u.LastName = src.LastName\n    }\n    // ... And other properties. Tedious, but simple and avoids Reflection\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This allows you to use &lt;code&gt;UpdateableUser&lt;/code&gt; as an interface to make it explicit which properties can be updated.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在Golang中将值从一个结构复制到另一个", ["\n\n", "I've two structs:", "\n\n", "type UpdateableUser struct {\n    FirstName string\n    LastName string\n    Email string\n    Tlm float64\n    Dob time.Time\n}\n\ntype User struct {\n    Id string\n    FirstName string\n    LastName string\n    Email string\n    DOB time.Time\n    Tlm float64\n    created time.Time\n    updated time.Time\n}\n", "\n\n", "Through a binder I bind request data to the updateableUser struct, therefore I might have an updateableUser with only one \"real\" value, like uu here:", "\n\n", "uu := UpdateableUser{Lastname: \"Smith\"}\n", "\n\n", "Now I want to set only the not \"emtpy\" values from UpdateableUser to User. Can you please give me a hint or more?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;根据需求来的&amp;#xff0c;max的作用就是找到成绩最高的人的所有信息返回&amp;#xff0c;void 肯定没有这个方便&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言函数的定义，结构体", ["\n", "这里input 和 max 函数的定义写法为什么不一样呀？max函数可以用void声明吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;a href=\"https://golang.org/ref/spec\"&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"https://golang.org/ref/spec#Calls\"&gt;Calls&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;In a function call, the function value and arguments are evaluated in\n  the usual order. After they are evaluated, the parameters of the call\n  are passed by value to the function and the called function begins\n  execution. The return parameters of the function are passed by value\n  back to the calling function when the function returns.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;The receiver &lt;code&gt;sm some&lt;/code&gt; is passed by value to the method and the copy is discarded when you return from the method. Use a pointer receiver.&lt;/p&gt;\n\n&lt;p&gt;For example,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\ntype some struct {\n    I uint32\n}\n\nfunc (sm *some) Add1() {\n    atomic.AddUint32(&amp;amp;sm.I, 1)\n}\n\nfunc main() {\n    var s some\n    s.Add1()\n    fmt.Println(s)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;{1}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;a href=\"https://golang.org/doc/faq\"&gt;Go Frequently Asked Questions (FAQ)&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"https://golang.org/doc/faq#pass_by_value\"&gt;When are function parameters passed by value?&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;As in all languages in the C family, everything in Go is passed by\n  value. That is, a function always gets a copy of the thing being\n  passed, as if there were an assignment statement assigning the value\n  to the parameter. For instance, passing an int value to a function\n  makes a copy of the int, and passing a pointer value makes a copy of\n  the pointer, but not the data it points to.&lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"https://golang.org/doc/faq#methods_on_values_or_pointers\"&gt;Should I define methods on values or pointers?&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (s *MyStruct) pointerMethod() { } // method on pointer\nfunc (s MyStruct)  valueMethod()   { } // method on value\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;For programmers unaccustomed to pointers, the distinction between\n  these two examples can be confusing, but the situation is actually\n  very simple. When defining a method on a type, the receiver (s in the\n  above examples) behaves exactly as if it were an argument to the\n  method. Whether to define the receiver as a value or as a pointer is\n  the same question, then, as whether a function argument should be a\n  value or a pointer. There are several considerations.&lt;/p&gt;\n  \n  &lt;p&gt;First, and most important, does the method need to modify the\n  receiver? If it does, the receiver must be a pointer. (Slices and maps\n  act as references, so their story is a little more subtle, but for\n  instance to change the length of a slice in a method the receiver must\n  still be a pointer.) In the examples above, if pointerMethod modifies\n  the fields of s, the caller will see those changes, but valueMethod is\n  called with a copy of the caller's argument (that's the definition of\n  passing a value), so changes it makes will be invisible to the caller.&lt;/p&gt;\n  \n  &lt;p&gt;By the way, pointer receivers are identical to the situation in Java,\n  although in Java the pointers are hidden under the covers; it's Go's\n  value receivers that are unusual.&lt;/p&gt;\n  \n  &lt;p&gt;Second is the consideration of efficiency. If the receiver is large, a\n  big struct for instance, it will be much cheaper to use a pointer\n  receiver.&lt;/p&gt;\n  \n  &lt;p&gt;Next is consistency. If some of the methods of the type must have\n  pointer receivers, the rest should too, so the method set is\n  consistent regardless of how the type is used. See the section on\n  method sets for details.&lt;/p&gt;\n  \n  &lt;p&gt;For types such as basic types, slices, and small structs, a value\n  receiver is very cheap so unless the semantics of the method requires\n  a pointer, a value receiver is efficient and clear.&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中int的奇怪行为", ["\n\n", "Let's say we have this kind of a struct (one of the simplest ever):", "\n\n", "type some struct{\n    I uint32\n}\n", "\n\n", "And we want to have a variable of that type and to atomically increment in for loop (possibly in another goroutine but now the story is different). I do the following:", "\n\n", "q := some{0}\nfor i := 0; i < 10; i++ {\n        atomic.AddUint32(&q.I,1) // increment [1]\n        fmt.Println(q.I)\n}\n", "\n\n", "We're getting what we'd expect, so far so good, but if we declare a function for that type as follows:", "\n\n", "func (sm some) Add1(){\n    atomic.AddUint32(&sm.I,1)\n}\n", "\n\n", "and call this function in the above sample (line [1]) the value isn't incremented and  we just get zeros. The question is obvious - why?", "\n\n", "This has to be something basic but since I am new to go I don't realize it.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/635932796466178.png\" class=\"md_img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_stnode&lt;/span&gt; \n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; id[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//学号 字符串&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//名字 字符串&lt;/span&gt;\n}MyData;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    MyData data[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//结构体数组&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,i;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;( &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s&amp;#34;&lt;/span&gt;,data[n].id,data[n].name))\n            n&amp;#43;&amp;#43;;\n        ch &amp;#61; &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ch &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//输入回车结束&lt;/span&gt;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//输出&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输出&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s\\n&amp;#34;&lt;/span&gt;,data[i].id,data[i].name);\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言输入字符串到结构体数组中", ["每输入一个字符串存在结构体数组中，空格后再一个名字，存入结构体数组，知道回车键结束输入"]], "Tag": "程序设计"}
{"Answer": "FMarketTabSet.Tabs是个列表，里面放着PMarketType ，PMarketType(FMarketTabSet.Tabs.Objects[0])意思就是将列表中第一个对象转为PMarketType 指针，然后访问它的iType字段\r\n\r\n结构体是TMarketType", "Konwledge_Point": "数据封装——结构体", "Question": ["小白求教delphi 结构体指针问题", ["case PMarketType(FMarketTabSet.Tabs.Objects[0]).iType of ", "\n这是什么意思", "\nPMarketType = ^TMarketType;", "\n  TMarketType = packed record", "\nFMarketTabSet := TTabSet.Create", "\n\n", "PMarketType(FMarketTabSet.Tabs.Objects[0]).iType 这个东西的值是怎么得来的。新手，求大神指点啊，请说详细点谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int BeforeTime(struct CLOCK* time, struct CLOCK duration)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int sum &amp;#61; 0, flag &amp;#61; 0;&lt;/span&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (duration.hour &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;)\n    sum &amp;#61; duration.hour / &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;;\nduration.hour &amp;#61; duration.hour % &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;second &amp;lt; duration.second)\n{\n    --&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;minute;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;second &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;second&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;second - duration.second;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;minute &amp;lt; duration.minute) {\n    --&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;hour;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;minute &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;;\n\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;minute&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;minute - duration.minute;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;hour &amp;lt; duration.hour)\n{\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;hour &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;; \n    flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;hour&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;-&amp;gt;&lt;/span&gt;hour - duration.hour;\nreturn flag &amp;#43; sum;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体计算时间差问题", ["编写函数BeforTime(time,duration)计算时间time之前“xx小时xx分xx秒”的时间。时间以24小时制格式表示。", "BeforTime函数的返回值为计算结果与初始时间之间的日期差。如果是同一天返回0，是前n天则返回n。", "用结构体类型存储时间。", "提示：先计算秒，再计算分，最后计算小时。例如计算“09:19:52”前“1：20：30”的方法是：", "秒：52−30=22，借0", "分：19−20−0+60=59，借1", "时：9−1−1=7，借0", "测试输入1：", "09:19:52", "1:15:30", "输出：", "同一天08:04:22", "测试输入2：", "00:19:52", "1:20:30", "输出：", "前1天22:59:22", "测试输入3：", "00:19:52", "25:30:59", "输出：", "前2天22:48:53", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include <stdio.h>", "struct CLOCK", "{", "    int hour;", "    int minute;", "    int second;", "};", "int BeforeTime(struct CLOCK *time,struct CLOCK duration);", "\n", "int main()", "{", "    struct CLOCK timeNow,timePast;", "    int n;", "    scanf(\"%d:%d:%d\",&timeNow.hour,&timeNow.minute,&timeNow.second);", "    scanf(\"%d:%d:%d\",&timePast.hour,&timePast.minute,&timePast.second);", "    n = BeforeTime(&timeNow,timePast);", "    if(n == 0)", "        printf(\"同一天\");", "    else", "        printf(\"前%d天\",n);", "    printf(\"%02d:%02d:%02d\",timeNow.hour,timeNow.minute,timeNow.second);", "    return 0;", "}", "//此函数计算time时刻前duration的时间；", "//函数的返回值：计算结果与time相比是同一天，应返回0，是前n天，则返回n", "int BeforeTime(struct CLOCK *time,struct CLOCK duration)", "{", "    int sum=0,flag=0;", "   if(time->second<duration.second)", "   {", "     --time->minute;", "    time->second+=60;", "    }", "\n", "time", "->", "second", "=", "time", "->", "second-duration.second;\n", "if", "(", "time", "->", "minute<duration.minute){\n    --", "time", "->", "hour;\n    ", "time", "->", "minute += ", "60", ";\n    ", "if", "(", "time", "->", "hour<duration.hour)\n    {", "time", "->", "hour+=", "24", ";flag=", "1", ";}\n}\n\n", "time", "->", "minute", "= ", "time", "->", "minute -duration.minute;\n", "\n", "   time->hour = time->hour - duration.hour;", "    sum=((time->second+time->minute", "60+time->hour", "3600)-(duration.second+duration.minute", "60+duration.hour", "3600))/3600;", "    if(sum<=24)", "    return 0+flag;", "    else return sum/24+flag;", "}", "\n", "运行结果及报错内容", "\n", "第三个测试过不了", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"179\" src=\"https://img-ask.csdnimg.cn/upload/1624956373567.png\" width=\"468\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;这个地方&amp;#xff0c;你这样改一下&lt;/p&gt;\n\n&lt;p&gt;for(i&amp;#61;NUM-2;i&amp;gt;&amp;#61;p-1;i--)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        stu[i&amp;#43;1]&amp;#61;stu[i];&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;我理解的这个地方 NUM&amp;#xff0c;指的是结构体总数&amp;#43;1&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;如果你的NUM代表的是学生总数的话&amp;#xff0c;这样改&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;for(i&amp;#61;NUM-1;i&amp;gt;&amp;#61;p-1;i--)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        stu[i&amp;#43;1]&amp;#61;stu[i];&lt;br /&gt;\n    }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            &lt;img alt=\"\" height=\"876\" src=\"https://img-ask.csdnimg.cn/upload/1624957486504.png\" width=\"656\" /&gt;                                                                                                                                                                                                                                                                                                              &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言，如何将结构体内容向后移动？", ["求解答，感谢，我尝试在结构体中插入新的信息，想的是1，输入指定位置；2，指定位置，和数组内4321的倒序循环，比较，就比如我输入插到第3个位置，循环会帮助我找到第三个位置，然后将第三个位置后包括第三个位置的结构体向后移动，但是我的结果是第三个新的信息", "替换", "掉了原来第三个位置的信息，请问如何成功将第三个位置的结构体", "向后移动一位", "？", "\n\n", "\n", "void InsertNew(){//指定位置插入新的学生信息\n\tint p=0,i;\n    STU temp1={0};\n\tprintf(\"Please enter the position where you want to insert the student information. \\n\"\n\t\t   \"If you want to put the information in the first place, enter 1\\n\");\n\tscanf(\"%d\",&p);//输入指定的位置\n\n\tfor(i=NUM-2;i>=0;i--)\n\t{\n\t\tif(p <= stu[i].o){//循环实现，将指定内容后的数组内容向后移动一位\n\t\t\tstu[i+1]=stu[i];\n\t\t}\n\t\n\t\telse{//移动后将输入信息插入到指定位置\n\t\t\tbreak;\n\t\t\t}\n\n\t}\n\n\t\t\tprintf(\"Please input student information:\");\n\t\t\t\t\n        \tprintf(\"Student ID(zy00*)\\n\");\n\t        scanf(\"%s\",stu[p-1].id);\n        \tgetchar();//Absorb extra line breaks\n\t        printf(\"name\\n\");\n\t        scanf(\"%s\",stu[p-1].name);\n        \tprintf(\"Please input the score of each subject\\n\");\n        \tstu[p-1].sum=0;\n        \tfor(int j =0;j<3;j++)\n\t\t\t{\n\t        \tscanf(\"%f\",&stu[p-1].ach[j]);\n\t        \tstu[p-1].sum +=stu[p-1].ach[j];\n\t\t\t}\n\t\tgetch();\n}\t"]], "Tag": "程序设计"}
{"Answer": "```\r\n template&lt;int N&gt;\r\nclass ListNode&lt;N&gt;{\r\n    int arr[N];\r\n};\r\n使用\r\nListNode&lt;2&gt; p = new ListNode&lt;2&gt;;\r\n```\r\n用C++模板理论上可以生成任意的程序，给你一本书，好好学吧。\r\nhttps://download.csdn.net/download/yinxing408033943/4341621", "Konwledge_Point": "数据封装——结构体", "Question": ["c++声明结构体动态数组的问题", ["struct ListNode {", "\n      int val;", "\n      ListNode ", "next;", "\n      ListNode(int x) : val(x), next(NULL) {}", "\n  };", "\n 然后我想达成的效果是", "\n ListNode", " p = new ListNode", "k", ";", "\n\n", "就是说申请一个k(变量)维的数组，然后都初始化成0.", "\n 不改变结构体声明的情况下能做到吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;In (ANSI) C99, you can use a &lt;strong&gt;designated initializer&lt;/strong&gt; to initialize a structure: &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;MY_TYPE a = { .flag = true, .value = 123, .stuff = 0.456 };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Edit: Other members are initialized as zero: \"Omitted field members are implicitly initialized the same as objects that have static storage duration.\" (&lt;a href=\"https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html\" rel=\"noreferrer\"&gt;https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html&lt;/a&gt;)&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何根据 c 语言标准初始化一个结构体", ["\n\n", "I want to initialize a struct element, split in declaration and initialization. This is what I have:", "\n\n", "typedef struct MY_TYPE {\n  boolean flag;\n  short int value;\n  double stuff;\n} MY_TYPE;\n\nvoid function(void) {\n  MY_TYPE a;\n  ...\n  a = { true, 15, 0.123 }\n}\n", "\n\n", "Is this the way to declare and initialize a local variable of ", "MY_TYPE", " in accordance with C programming language standards (C89, C90, C99, C11, etc.)? Or is there anything better or at least working?", "\n\n", "Update", " I ended up having a static initialization element where I set every subelement according to my needs.", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/330793/how-to-initialize-a-struct-in-accordance-with-c-programming-language-standards"]], "Tag": "程序设计"}
{"Answer": "直接引用WebService中的结构体即可", "Konwledge_Point": "数据封装——结构体", "Question": ["webservice 带结构体参数的函数调用", ["各位大神，小弟刚接触websevice", "\n\n", "我在webservice中写了一个带结构体参数的函数。", "\n 再在客户端定义了一个结构体，并以此结构体作为参数，调用webservice中的函数。", "\n 。程序报错", "\n 但当传入其他类型的参数是没有问题的。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;A,B,C,D选项信息你能用代码块贴出来吗&amp;#xff1f;你这么贴的话&amp;#xff0c;看不清楚哪些有 * 号&amp;#xff0c;哪些没有。应该是C选项开头有个 * &amp;#xff0c;D选项开头有个 *&lt;br /&gt;总体看的话&amp;#xff0c;确实B是错的&lt;br /&gt;A: p是指针&amp;#xff0c;用-&amp;gt;访问成员没问题&lt;br /&gt;B: .优先级高于  * &amp;#xff0c;不能用.访问成员的&lt;br /&gt;C: -&amp;gt;优先级高于 * ,相当于取得p-&amp;gt;pk指针的第一个元素值&lt;br /&gt;D: .优先级高于 * ,相当于取得x.pk指针的第一个元素值&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体变量指针指向结构体成员指针的问题", ["问题遇到的现象", "已知", " struct node{", "     int len;", "     char *pk;", " }x={2,\"right\"},*p=&x;", "问不符合C语言语法", "A.p->pk", "B *p.pk", "C .", "p->pk", "D", "x.pk", "一眼看ac有点像可能在ac中选 ，但是d选项更像 答案为d；", "但是放在编译器中B选项报错  pk不是结构体或者联合体；", "望解答"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;两种是不一样的&amp;#xff0c;和C&amp;#xff0c;C&amp;#43;&amp;#43; 无关&lt;br /&gt;第一种只是定义一种结构体类型&amp;#xff0c;第二种是在定义结构体类型的同时&amp;#xff0c;定义别名&amp;#xff0c;一定使用typedef&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["初学者关于结构体名位置的疑惑", ["C语言，在定义结构是，结构体名在struck后，在“｛”前，而结构体变量在“｝”后。而为什么在定义线性表或者栈的时候，结构体名放在了“｝”后，有程序哥解惑吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为结构体里&amp;#xff0c; char *name; name定义的是个指针变量&amp;#xff0c;定义结构体对象时&amp;#xff0c;并没有分配额外的空间给它们&amp;#xff0c;改了下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&amp;#96;&amp;#96;&amp;#96;c&amp;#43;&amp;#43;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *name,gender;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score;\n};\n&lt;span class=\"hljs-built_in\"&gt;main&lt;/span&gt;()\n{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt; a &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;m&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;290&lt;/span&gt;},b;\n    a.name &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(a.name,&lt;span class=\"hljs-string\"&gt;&amp;#34;Qian&amp;#34;&lt;/span&gt;);\n    b &amp;#61; a;\n    b.gender &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;;\n    b.score &amp;#61; &lt;span class=\"hljs-number\"&gt;350&lt;/span&gt;;\n    b.name &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(b.name,&lt;span class=\"hljs-string\"&gt;&amp;#34;Aian&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s,%c,%d,\\n&amp;#34;&lt;/span&gt;,a.name,a.gender,a.score);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s,%c,%d\\n&amp;#34;&lt;/span&gt;,b.name,b.gender,b.score);\n  \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中指针指向的问题", ["b = a是重新定义了一个结构体对象，b.name获得的是a的地址，在改变b.name的值时改变了b.name的指向，为何会影响a.name的值与指向", "\n", "struct", " ", "stu", "{\n    ", "char", " *name,gender;\n    ", "int", " score;\n};\n", "main", "(){\n    ", "struct", " ", "stu", " a = {", "NULL", ",", "'m'", ",", "290", "},b;\n    a.name = (", "char", "*)", "malloc", "(", "10", ");\n    ", "strcpy", "(a.name,", "\"Qian\"", ");\n    b = a;b.gender = ", "'f'", ";\n    b.score = ", "350", ";\n    ", "strcpy", "(b.name,", "\"Qian\"", ");\n    ", "printf", "(", "\"%s,%c,%d,\"", ",a.name,a.gender,a.score);\n    ", "printf", "(", "\"%s,%c,%d\\n\"", ",b.name,b.gender,b.score);\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码最后一个printf函数中输出成绩的格式符号应该是f。而你写成了d&amp;#xff0c;就是这个错误。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体学生成绩问题", ["五名学生的学号和成绩 找出成绩最低的 为什么最后输出的时候成绩一直是0？？？", "#include <stdio.h>", "struct student", "{", "    int data;", "    float score;", "}s[5];", "int main() {", "    struct student s[5];", "    int i, j, k = 0;", "    for (i = 0; i < 5; i++) {", "        scanf_s(\"%d %f\", &s[i].data, &s[i].score);", "    }", "    for (i = 0; i < 5; i++) {", "        if (s[i].score < s[k].score)", "            k = i;", "    }", "    printf(\"%d-%d\", s[k].data, s[k].score);", "    return 0;", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "(p+j)-&gt;name已经是字符串了不需要加*，举个例子吧，定义一个结构体\r\n\r\n\r\n```\r\n typedef struct Stu {\r\n\t char name;\r\n\t int age;\r\n };\r\n //在声明一个这个结构体的变量\r\n struct Stu stu1;\r\n //定义一个指针\r\n struct Stu *p;\r\n p=&amp;stu1;\r\n p-&gt;name = stu1-&gt;name;\r\n```\r\n去访问结构体stu1里面的成员时，使用stu1-&gt;name;那么将stu1的地址传给指针p即：p=&amp;stu1，那么stu1和指针p存储的\r\n都是这个结构体变量的内存地址，可以stu1-&gt;name,也就可以p-&gt;name;\r\n后面的赋值运算是对结构体变量的赋值，当然要使用解引用符了。", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体指针问题。什么时候在指针前面加*号，什么时候不加", ["我在做一道对结构体数组，按姓名升序进行冒泡排序的题的时候有些不理解指针什么时候加“*”什么时候不加*。", "\n\n", "下面上我的代码。", "\n结构体定义", "\n\n", " typedef struct array{\n    int a;\n    char b;\n}Array;\n", "\n\n", "为结构体赋值", "\n\n", " Stu student[5] = {\n        {\"uioyi\",'m',95,58},\n        {\"asdf\",'m',88,28},\n        {\"cvb\",'m',93,37},\n        {\"aa\",'m',60,49},\n        {\"tyu\",'m',99,57}\n    };\n", "\n\n", "下面重点来了，函数", "\n\n", "void sortedByName(Stu *p,int count){\n    for (int i = 0; i < count - 1; i++) {\n        for (int j = 0; j < count - 1 - i; j++) {\n            if (**strcmp((p + j) -> name, (p + j + 1) -> name)** > 0 ) {\n                Stu temp = *(p + j);\n                *(p + j) = *(p + j + 1);\n                *(p + j + 1) = temp;\n            }\n        }\n    }\n}\n", "\n\n", "请大神为我回答一下，在函数if比较的冒泡排序中，为什么strcmp函数中俩个相比较的指针(p + j) -> name和(p + j + 1) -> name前面为什么不能加*。", "\n但是为什么下面进行冒泡排序赋值的时候就必须要加*"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;输入的地方&amp;#xff0c;不是&amp;#xff05;c&amp;#xff0c;是两个&amp;#xff05;s&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["输出结构体成员时总是乱码", ["这是我的结构体链表", "这是我的输入函数", "\n", "这是我的输出函数", "\n", "\n", "但最后输出时全是乱码"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;总分按照你的公式计算出来&amp;#xff0c;写个冒泡排序就可以了。代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#define &lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;\nstruct student\n{\n    int no;\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    int kaoqing;\n    int zuoye;\n    int qimo;\n};\n\nint main(void)\n{\n    int i, sum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    int j;\n    struct student stu[&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, temp;\n    double t1, t2;\n    puts(&lt;span class=\"hljs-string\"&gt;&amp;#34;Please enter information of student: &amp;#34;&lt;/span&gt;);\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %s %d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;stu[i].no, stu[i].name, &amp;amp;stu[i].kaoqing, &amp;amp;stu[i].zuoye, &amp;amp;stu[i].qimo);\n    }\n\n    //排序\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; - i; j&amp;#43;&amp;#43;)\n        {\n            t1 &amp;#61; stu[j].zuoye * &lt;span class=\"hljs-number\"&gt;0.2&lt;/span&gt; &amp;#43; stu[j].kaoqing * &lt;span class=\"hljs-number\"&gt;0.1&lt;/span&gt; &amp;#43; stu[j].qimo * &lt;span class=\"hljs-number\"&gt;0.7&lt;/span&gt;;\n            t2 &amp;#61; stu[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].zuoye * &lt;span class=\"hljs-number\"&gt;0.2&lt;/span&gt; &amp;#43; stu[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].kaoqing * &lt;span class=\"hljs-number\"&gt;0.1&lt;/span&gt; &amp;#43; stu[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].qimo * &lt;span class=\"hljs-number\"&gt;0.7&lt;/span&gt;;\n            if (t1 &amp;lt; t2)\n            {\n                temp &amp;#61; stu[j];\n                stu[j] &amp;#61; stu[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                stu[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; temp;\n            }\n        }\n    }\n\n\n    //显示结果\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34; ID&amp;#61;%d Name&amp;#61;%s check_in&amp;#61;%f zuoye&amp;#61;%f qimo&amp;#61;%f sum&amp;#61;%f\\n&amp;#34;&lt;/span&gt;, stu[i].no, stu[i].name, stu[i].kaoqing * &lt;span class=\"hljs-number\"&gt;0.1&lt;/span&gt;, stu[i].zuoye * &lt;span class=\"hljs-number\"&gt;0.2&lt;/span&gt;, stu[i].qimo * &lt;span class=\"hljs-number\"&gt;0.7&lt;/span&gt;, (stu[i].kaoqing * &lt;span class=\"hljs-number\"&gt;0.1&lt;/span&gt;) &amp;#43; (stu[i].zuoye * &lt;span class=\"hljs-number\"&gt;0.2&lt;/span&gt;) &amp;#43; (stu[i].qimo * &lt;span class=\"hljs-number\"&gt;0.7&lt;/span&gt;));\n    }\n\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体排序遇到问题", ["题目要求输入20名学生的学号 名字 作 业（20％）考勤（10％）和期 末（70％）成绩并在求出总分后按总分从大到小排序", "\n", "我在写排序的过程中遇到了困难，请告诉我怎么写，谢谢", "\n", "#include <stdio.h>", "\n", "#define N 5", "\nstruct student\n{\n    ", "int", " ", "no", ";\n    char name[", "20", "];\n    ", "int", " kaoqing;\n    ", "int", " zuoye;\n    ", "int", " qimo;\n};\n\n", "int", " main(void)\n{\n    ", "int", " i, sum = ", "0", " ;\n    struct student stu[N] = ", "{0}", ", temp;\n    puts(", "\"Please enter information of student: \"", ");\n    ", "for", " (i = ", "0", "; i < N; i++)\n    {\n        scanf(", "\"%d %s %d %d %d\"", ", &stu[i].no, stu[i].name, &stu[i].kaoqing, &stu[i].zuoye, &stu[i].qimo);\n    }\n\n    ", "for", " (i = ", "0", "; i < N; i++)\n    {\n        sum++;\n        ", "//", " 考勤", "10", "%作业", "20", "%期末", "70", "%\n        ", "printf", "(", "\" ID=%d Name=%s check_in=%f zuoye=%f qimo=%f sum=%f\\n\"", ", stu[i].no, stu[i].name, stu[i].kaoqing * ", "0", ".", "1", ", stu[i].zuoye * ", "0", ".", "2", ", stu[i].qimo * ", "0", ".", "7", ", (stu[i].kaoqing * ", "0", ".", "1", ") + (stu[i].zuoye * ", "0", ".", "2", ") + (stu[i].qimo * ", "0", ".", "7", "));\n    }\n\n    ", "return", " ", "0", ";\n}\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;string&amp;gt;\n\nusing namespace std;\n\nconst int num&amp;#61;6;\n\ntypedef struct Date\n{\n\tint score;\n\tchar name[10];\n}Date;\n\ntypedef struct Student\n{\n\tDate *date;\n\tStudent *next;\n}Student;\n\nStudent * Created()\n{\n\tStudent *head,*node,*t;\n\t\n\thead&amp;#61;(Student *)malloc(sizeof(Student));\n\thead-&amp;gt;date&amp;#61;(Date *)malloc(sizeof(Date));\n\t\n\tnode&amp;#61;(Student *)malloc(sizeof(Student));\n\tnode-&amp;gt;date&amp;#61;(Date *)malloc(sizeof(Date));\n\t\n\thead-&amp;gt;date&amp;#61;NULL;\n\tcout&amp;lt;&amp;lt;&amp;#34;第&amp;#34;&amp;lt;&amp;lt;num&amp;lt;&amp;lt;&amp;#34;个节点的数据&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\tcout&amp;lt;&amp;lt;&amp;#34;name&amp;#xff1a;&amp;#34;;\n\tcin&amp;gt;&amp;gt;node-&amp;gt;date-&amp;gt;name;\n\tcout &amp;lt;&amp;lt;node-&amp;gt;date-&amp;gt;name&amp;lt;&amp;lt; endl;\n\t\n\tcout&amp;lt;&amp;lt;&amp;#34;score&amp;#xff1a;&amp;#34;;\n\tcin&amp;gt;&amp;gt;node-&amp;gt;date-&amp;gt;score;\n\tcout &amp;lt;&amp;lt;node-&amp;gt;date-&amp;gt;score&amp;lt;&amp;lt; endl;\n\t\n\thead-&amp;gt;next&amp;#61;node;\n\tnode-&amp;gt;next &amp;#61;NULL;\n\t\n\tfor(int i&amp;#61;num-1;i&amp;gt;0;i--)\n\t{\n    \tnode&amp;#61;(Student *)malloc(sizeof(Student));\n    \tnode-&amp;gt;date&amp;#61;(Date *)malloc(sizeof(Date));\n    \t\n    \tcout&amp;lt;&amp;lt;&amp;#34;第&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34;个节点的数据&amp;#34;&amp;lt;&amp;lt;endl;\n    \t\n    \tcout&amp;lt;&amp;lt;&amp;#34;name&amp;#xff1a;&amp;#34;;\n    \tcin&amp;gt;&amp;gt;node-&amp;gt;date-&amp;gt;name;\n    \tcout &amp;lt;&amp;lt;node-&amp;gt;date-&amp;gt;name&amp;lt;&amp;lt; endl;\n    \t\n    \tcout&amp;lt;&amp;lt;&amp;#34;score&amp;#xff1a;&amp;#34;;\n    \tcin&amp;gt;&amp;gt;node-&amp;gt;date-&amp;gt;score;\n    \tcout &amp;lt;&amp;lt;node-&amp;gt;date-&amp;gt;score&amp;lt;&amp;lt; endl;\n    \t\n    \tnode-&amp;gt;next&amp;#61;head-&amp;gt;next;\n    \thead-&amp;gt;next&amp;#61;node;\n\t}\n\t\n\tt&amp;#61;head-&amp;gt;next;\n\tcout&amp;lt;&amp;lt;&amp;#34;遍历一遍&amp;#34;&amp;lt;&amp;lt;endl;\n\t\n\twhile(t!&amp;#61;NULL)\n\t{\n\t\tcout&amp;lt;&amp;lt;&amp;#34;name: &amp;#34;&amp;lt;&amp;lt;t-&amp;gt;date-&amp;gt;name&amp;lt;&amp;lt;&amp;#34;\\tscore: &amp;#34;&amp;lt;&amp;lt;t-&amp;gt;date-&amp;gt;score&amp;lt;&amp;lt;endl;\n\t\tt&amp;#61;t-&amp;gt;next;\n\t}\n\treturn head;\n}\n\nint main()\n{\n\tStudent *s&amp;#61;Created();\t\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;输入&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;1&lt;br /&gt;\n20&lt;br /&gt;\n2&lt;br /&gt;\n30&lt;br /&gt;\n3&lt;br /&gt;\n40&lt;br /&gt;\n4&lt;br /&gt;\n50&lt;br /&gt;\n5&lt;br /&gt;\n60&lt;br /&gt;\n6&lt;br /&gt;\n70&lt;br /&gt;\n &lt;/p&gt;\n\n&lt;p&gt;输出&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;第6个节点的数据&lt;br /&gt;\nname&amp;#xff1a;1&lt;br /&gt;\nscore&amp;#xff1a;20&lt;br /&gt;\n第5个节点的数据&lt;br /&gt;\nname&amp;#xff1a;2&lt;br /&gt;\nscore&amp;#xff1a;30&lt;br /&gt;\n第4个节点的数据&lt;br /&gt;\nname&amp;#xff1a;3&lt;br /&gt;\nscore&amp;#xff1a;40&lt;br /&gt;\n第3个节点的数据&lt;br /&gt;\nname&amp;#xff1a;4&lt;br /&gt;\nscore&amp;#xff1a;50&lt;br /&gt;\n第2个节点的数据&lt;br /&gt;\nname&amp;#xff1a;5&lt;br /&gt;\nscore&amp;#xff1a;60&lt;br /&gt;\n第1个节点的数据&lt;br /&gt;\nname&amp;#xff1a;6&lt;br /&gt;\nscore&amp;#xff1a;70&lt;br /&gt;\n遍历一遍&lt;br /&gt;\nname: 6    score: 70&lt;br /&gt;\nname: 5    score: 60&lt;br /&gt;\nname: 4    score: 50&lt;br /&gt;\nname: 3    score: 40&lt;br /&gt;\nname: 2    score: 30&lt;br /&gt;\nname: 1    score: 20&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;好像是cin和String的问题我改成char name[10]了&amp;#xff0c;顺便改了一下输出格式&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["链表建立以及结构体的嵌套实例问题求解", [" 小白求解答", "\n\n", " 也不知道是什么问题总是这个样子", "\n\n", "\n", "#include <iostream>\n#include <string>\nusing namespace std;\nconst int num=6;\ntypedef struct Date\n{\n\tstring name;\n\tint score;\n}Date;\ntypedef struct Student\n{\n\tDate *date;\n\tStudent *next;\n}Student;\nStudent * Created()\n{\n\tStudent *head,*node,*t;\n\thead=(Student *)malloc(sizeof(Student));\n\thead->date=(Date *)malloc(sizeof(Date));\n\tnode=(Student *)malloc(sizeof(Student));\n\tnode->date=(Date *)malloc(sizeof(Date));\n\thead->date=NULL;\n\tcout<<\"第\"<<num<<\"个节点的数据\"<<endl;\n\tcout<<\"name：\";\n\tcin>>node->date->name;\n\tcout<<\"\\nscore：\";\n\tcin>>node->date->score;\n\thead->next=node;\n\tnode->next =NULL;\n\tfor(int i=num-1;i>0;i--)\n\t{\n\tnode=(Student *)malloc(sizeof(Student));\n\tnode->date=(Date *)malloc(sizeof(Date));\n\tcout<<\"第\"<<i<<\"个节点的数据\"<<endl;\n\tcout<<\"name：\";\n\tcin>>node->date->name;\n\tcout<<\"\\nscore：\";\n\tcin>>node->date->score;\n\tnode->next=head->next;\n\thead->next=node;\n\t}\n\tt=head->next;\n\tcout<<\"遍历一遍\"<<endl;\n\twhile(t!=NULL)\n\t{\n\t\tcout<<\"name: \"<<t->date->name<<\"score: \"<<t->date->score<<endl;\n\t\tt=t->next;\n\t}\n\treturn head;\n}\nvoid main()\n{\n\tStudent *s=Created();\t\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你那结构体有三个变量&amp;#xff0c;怎么一次性打出来&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;day&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; month;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; data;\n};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Node&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; sex[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;day&lt;/span&gt; birthday;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; address[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Node&lt;/span&gt; node1 &amp;#61; { &lt;span class=\"hljs-string\"&gt;&amp;#34;wangchun&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;man&amp;#34;&lt;/span&gt;,{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2003&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;18&lt;/span&gt;},&lt;span class=\"hljs-string\"&gt;&amp;#34;China&amp;#34;&lt;/span&gt; };\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名:%s,性别:%s,生日:%d年%d月%d日,住址:%s&amp;#34;&lt;/span&gt;, node1.name, node1.sex, node1.birthday.year,node1.birthday.month,node1.birthday.data, node1.address);\n\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体打印出错", ["C语言结构体", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "struct", " ", "day", "{\n    ", "int", " year;\n    ", "int", " month;\n    ", "int", " data;\n};\n", "struct", " ", "Node", "{\n     ", "char", " name[", "20", "];\n     ", "char", " sex[", "10", "];\n     ", "struct", " ", "day", " birthday;\n     ", "char", " address[", "100", "];\n};\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "struct", " ", "Node", " node1={", "\"wangchun\"", ",", "\"man\"", ",{", "2003", ",", "2", ",", "18", "},", "\"China\"", "};\n    ", "printf", "(", "\"姓名:%s,性别:%s,生日:%d,住址:%s\"", ",node1.name,node1.sex,node1.birthday,node1.address);\n    \n}\n\n", "\n", "就是我在打印这个birthday的时候并不会报错但是会打印出来一些不相关的字符，不明白是怎么回事"]], "Tag": "程序设计"}
{"Answer": "```\r\n 是一个函数指针。\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体的指针问题。", ["struct GenInfo {", "\n  uint64_t (*next)(struct GenInfo * const);", "\n  enum GeneratorType type;", "\n  union {", "\n    struct GenInfo_Constant     constant;", "\n    struct GenInfo_Counter      counter;", "\n    struct GenInfo_Discrete     discrete;", "\n    struct GenInfo_Exponential  exponential;", "\n    struct GenInfo_File         file;", "\n    struct GenInfo_Histogram    histogram;", "\n    struct GenInfo_HotSet       hotset;", "\n    struct GenInfo_Zipfian      zipfian;", "\n    struct GenInfo_Latest       latest;", "\n    struct GenInfo_Uniform      uniform;", "\n  } gen;", "\n};", "\n\n", "该结构体内的第一行： uint64_t (*next)(struct GenInfo * const); 这一行表示的是什么？", "\n是不是指向下一个该结构体的指针呢？", "\n谢谢。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;blockquote&gt;\n  &lt;p&gt;or a dereferenced pointer symbol *&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;That is the norm, for complex non-value type, in order to avoid making a copy.&lt;br&gt;\nSee &lt;a href=\"http://www.golang-book.com/8/index.htm\" rel=\"nofollow noreferrer\"&gt;Golang book \"Pointers\"&lt;/a&gt; for example of struct with pointer(s) in them.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;return &amp;amp;DB{db}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;That returns a pointer to the newly created &lt;code&gt;DB&lt;/code&gt; instance.&lt;br&gt;\nAs noted in \"&lt;a href=\"https://stackoverflow.com/a/12098718/6309\"&gt;Can you “pin” an object in memory with Go?&lt;/a&gt;\":&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Note that, unlike in C, it's perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;From \"&lt;a href=\"http://jmoiron.net/blog/pointer-value-subtleties/\" rel=\"nofollow noreferrer\"&gt;Pointer/Value Subtleties&lt;/a&gt;\":&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Go is also pass by value, but it has both pointers and value types. Pointers refer to a certain memory location, and allow you to mutate the data at that location&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;For more, see \"&lt;a href=\"https://stackoverflow.com/a/23551970/6309\"&gt;Best practice “returning” structs in Go?&lt;/a&gt;\"&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Use pointers for big structs or structs you'll have to change, and otherwise use values, because getting things changed by surprise via a pointer is confusing.&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["解引用指向结构体中DB的指针", ["\n\n", "Usually when I see a field declared on a struct it's without a pointer or a dereferenced pointer symbol *, however in several code snippets where I've seen a database field in a struct it's with a pointer dereference as you see below. Why is that necessary?", "\n\n", "type DB struct {\n    *bolt.DB\n}\nfunc Open(path string, mode os.FileMode) (*DB, error) {\n    db, err := bolt.Open(path, mode)\n    if err != nil {\n        return nil, err\n    }\n    return &DB{db}, nil\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-xml\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    string name;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; aver;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student *s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;average&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student *s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;high&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student *s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Student stu[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], *st&amp;#61;stu;\n    &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(st, &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;average&lt;/span&gt;(st, &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;high&lt;/span&gt;(st, &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student *s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    Student *p;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (p&amp;#61;s, i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; p&amp;lt;s&amp;#43;n; p&amp;#43;&amp;#43;, i&amp;#43;&amp;#43;){\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Please enter No.&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; student num, name, score: &amp;#34;&lt;/span&gt;;\n        cin&amp;gt;&amp;gt;p-&amp;gt;num&amp;gt;&amp;gt;p-&amp;gt;name;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; cin&amp;gt;&amp;gt;p-&amp;gt;score[j&amp;#43;&amp;#43;]);\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;average&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student *s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    Student *p;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; sum, ave&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (p&amp;#61;s; p&amp;lt;s&amp;#43;n; p&amp;#43;&amp;#43;){\n        sum&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; sum&amp;#43;&amp;#61;p-&amp;gt;score[i&amp;#43;&amp;#43;]);\n        p-&amp;gt;aver&amp;#61;(sum/&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n        ave&amp;#43;&amp;#61;p-&amp;gt;aver;\n    }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Average&amp;#61; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;ave/n&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;high&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student *s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    Student *p, *h;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; high;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (p&amp;#61;s, h&amp;#61;p, high&amp;#61;p-&amp;gt;aver; p&amp;lt;s&amp;#43;n; p&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;aver&amp;gt;high){\n            high&amp;#61;p-&amp;gt;aver;\n            h&amp;#61;p;\n        }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Highest student info: &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;h-&amp;gt;num&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;h-&amp;gt;name&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; cout&amp;lt;&amp;lt;h-&amp;gt;score[i&amp;#43;&amp;#43;]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;h-&amp;gt;aver&amp;lt;&amp;lt;endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++结构体问题，不会码？？", ["有 10 个学生，每个学生的数据包括学号、姓名、3 门课的成绩， 从键盘输入10 个学生的数据，要求打印出 3 门课的总平均成绩，并计算出每人的平均成绩?"]], "Tag": "程序设计"}
{"Answer": "http://blog.sina.com.cn/s/blog_b716ca8d01016uzf.html", "Konwledge_Point": "数据封装——结构体", "Question": ["用结构体数组存储某班的30名学生的信息，每个学生的数据项有学号", ["用结构体数组存储某班的30名学生的信息，每个学生的数据项有学号、姓名、性别和四门课的成绩。编写程序计算四门课的平均成绩，要求用键盘输入学生数据，再按平均成绩排序，并输出含平均成绩的报表。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C语言字符串可以用strcpy函数&amp;#xff0c;C&amp;#43;&amp;#43;如果是string类的话直接 &amp;#61; 赋值就行了&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何在函数里面将传入的字符串赋值给结构体以及将结构体中的元素用传入的字符串替换", ["C语言将字符串传入函数，函数通过指针接收，如何在函数里面将传入的字符串赋值给结构体以及将结构体中的元素用传入的字符串替换，我用的是VS2019编译器，哪位来指点一下迷津"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把报错行的void删掉&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["做结构体的时候发现抱错不允许使用不完整的类型，但是看不出问题在哪", ["\n", "一直报错：不允许使用不完整的类型，问题出在哪啊，", "还有一个小问题，就是我如果定义一个", "struct a", "{", "  char a[10];", "  char b[10];", "};", "和", "struct b", "{", "char a;", "char b;", "};", "有什么区别吗，好像用处是一样啊"]], "Tag": "程序设计"}
{"Answer": "你的set函数中demo变量本来就是空值，你把它赋给L它肯定输出空值啊", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针作为实参的值传递问题", ["#include", "\n#include", "\n\n", "struct Process", "\n{", "\n    char name[5];", "\n    int again;", "\n    int serve;", "\n    char state;", "\n    struct Process *next;", "\n};", "\nvoid Set(struct Process *L)", "\n{", "\n    struct Process Demo;", "\n    L=&Demo;", "\n    printf(\"%p\\n\",L);", "\n}", "\nint main(void)", "\n{", "\n    struct Process *L=NULL;", "\n\n", "Set(L);\nif(L)\n{\n    printf(\"函数结束，空间释放！\\n\");\n    printf(\"%p\\n\",L);\n}\nelse\n    printf(\"L地址为NULL\\n\");\n\nreturn 0;\n", "\n\n", "}", "\n程序的运行结果为：", "\n0000000000FDF0", "\nL的地址为NULL", "\n\n", "在这个程序中，我在main函数中声明了*L指针，本来打算在Set（）函数中把L的地址改为Demo结构体变量的地址，可是程序的运行结果不对呀！怎么回事？求详解分析下！", "\n\n", "只有1个币了，只能这次酬谢这么多了！谢谢呐！"]], "Tag": "程序设计"}
{"Answer": "编译器会自动填充字节以对齐结构体元素内存位置。\r\n深入学习可以参考:\r\n\r\nhttp://www.cnblogs.com/clover-toeic/p/3853132.html\r\n\r\n如果想禁止编译器的这种行为：\r\n对visual studio来说，可以在文件头部加上：\r\n\r\n\r\n\r\n```\r\n # pragma pack (1)\r\n```\r\n\r\n**如果有帮助，请采纳答案好吗，谢谢！**", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言求结构体大小怎么计算的", ["struct student{", "\n  9     char score[20];", "\n 10     int snum[10];", "\n 11", "\n 12 }stu;", "\n 13 int main()", "\n 14 {", "\n 15     printf(\"%d\\n\",sizeof(stu));", "\n 16 }  ", "\n\n", "像这样算出来结果是60，如果在第11行加  char u[10]；   结果算出来是72，这是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "看到一篇博客，可能比较适合你：https://blog.csdn.net/lcj8/article/details/2912551", "Konwledge_Point": "数据封装——结构体", "Question": ["高分悬赏，Java语言如何调用C语言写的dll，并且传递结构体指针", ["高分悬赏，Java语言如何调用C语言写的dll，并且传递结构体指针", "\n高分悬赏，Java语言如何调用C语言写的dll，并且传递结构体指针"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;sdl&lt;/code&gt;没有初始化&amp;#xff0c;用空指针初始化肯定不行&amp;#xff0c;空指针不能解引用。&lt;code class=\"language-javascript\"&gt;sdl&lt;/code&gt;必须指向有效的&lt;code class=\"language-javascript\"&gt;studentlist&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["mfc中结构体指针未初始化变量", ["用空指针初始化也出发了异常", "错误讯息是 已触发了一个断点。", "求解"]], "Tag": "程序设计"}
{"Answer": "http://blog.itpub.net/102086/viewspace-792251/", "Konwledge_Point": "数据封装——结构体", "Question": ["Visual Basic 6.0 读取一个C++编写的DLL中的结构体函数", ["Visual Basic 6.0 读取一个C++编写的DLL中的结构体函数，几个函数公用一个内存有没有问题？需要复制内存么？"]], "Tag": "程序设计"}
{"Answer": "你的struct word结构中的word1成员只是char*类型，你想用它保存输入单词的话就要用malloc()分配一个内存块来存储你的单词，另外单词所在的行数赋给int line[0]，那int line[1]到int line[999]你又空着干嘛。。还有我没见过函数声明写在另一个函数里面的", "Konwledge_Point": "数据封装——结构体", "Question": ["初学者问一个关于c语言结构体的问题", ["结构体中指针和数组有什么不同？", "\n\n", "我定义了这么一个结构体：", "\nstruct word", "\n{", "\nchar*word1;", "\nint line[1000];", "\n};", "\nstruct word danci", "\n\n", "然后用一个函数getword读取输入并给该结构体赋值,具体是怎么样就不写了", "\ngetword（danci，100）;", "\n然后", "\nprintf(\"%d\",danci.line[0]);", "\n但是这句报错了，原因是struct word danci没有初始化", "\n但是我把结构体中int line[1000]   改为int*line再给line分配一个地址 则不会报错。", "\n请问这是为什么？？？？", "\n以下是getword函数的代码：", "\nint getword(struct word word,int lim)", "\n{", "\n    int c,getch(void);", "\n    void ungetch(int);", "\n    char*w=word.word1;", "\n    static int nline=1;", "\n    while((c=getch())==' '||c=='\\t')", "\n        ;", "\n    if(c!=EOF)", "\n        *w++=c;", "\n    if(c=='\\n')", "\n        ++nline;", "\n    if(nline>MAXLINE)", "\n    {", "\n        printf(\"只能处理1000行以内的单词\\n\");", "\n        return EOF;", "\n    }", "\n    if(!isalpha(c))", "\n    {", "\n        *w='\\0';", "\n        return c;", "\n    }", "\n    for(;--lim>0;w++)", "\n        if(!isalnum(*w=getch()))", "\n        {", "\n            *(word.line)=nline;", "\n            ungetch(*w);", "\n            break;", "\n        }", "\n    *w='\\0';", "\n    return word.word1[0];", "\n}", "\ngetword用来读取输入中的单词，将其赋给结构体struct word中的char*word1,把单词所在的行数赋给int line[0]"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ac是结构体AC的数组。那么每个ac元素都是结构体AC的变量&amp;#xff0c;你要哪个变量的首地址呢&amp;#xff1f;&lt;br /&gt;取首地址可以是 Y &amp;#61; L.ac &amp;#43; i; i表示你要去的ac数组中第i个ac变量&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c 语言，结构体,取首地址，", ["\n", "struct", "  AC\n{\n", "int", " a", "[", "10", "]", ";\n", "int", " c;\n};\n\n", "struct", "  ABC\n{\n", "struct", " AC  ac", "[", "10", "]", ";\n", "int", " B", "[", "10", "]", ";\n};\n", "struct", " ABC  L;\n\nX= ", "L", ".", "ac", "[", "3", "]", ".a;  \nY =(&", "L", ".", "ac", "[", "3", "]", ");  \n", "\n", "通过(*)(X++)可以取到ac[3]的a[0]到c的值，但是在取c的值时编译器就会报超界的警告看着不舒服", "\n", "通过(*)(Y++)就不是取ac[3]的a[0]到c的值，好像是指向了ac[4],不太清楚，", "有什么不用AC中元素的地址（报警告，看着太别扭了），取结构体AC的首地址的方法吗？"]], "Tag": "程序设计"}
{"Answer": "global.h是不是重复包含了？加上包含宏判断试试。\r\n#ifndef GLOBAL_H\r\n#define GLOBAL_H\r\n....global的内容\r\n#endif", "Konwledge_Point": "数据封装——结构体", "Question": ["MFC小白请教  结构体提示重复定义如何修改", ["!["]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;struct  SL{  ...};  表示创建一个结构体&amp;#xff0c;该结构体名称为SL&lt;br /&gt;struct   name{ ...}  SL;    表示创建一个结构体&amp;#xff0c;该结构体名称为name&amp;#xff0c;并初始化一个名为SL的结构体变量&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构中的结构体问题", ["有人懂在定义结构体后写个SL是什么意思吗？好像是定义什么去了，不太记得了"]], "Tag": "程序设计"}
{"Answer": "stuffnode的定义在哪里\r\n要先定义\r\nstruct stuffnode\r\n{\r\n\r\n};\r\n\r\nstuffhead 在哪里定义的\r\n是不是stuffnode *类型\r\n\r\n感觉你有两个结构体\r\n一个是stuffnode，其中包含了一个s\r\n而s是另一个结构体。", "Konwledge_Point": "数据封装——结构体", "Question": ["vs2010怎么设置结构体", ["源文件", "\nvoid menu()", "\n{", "\n    int quanxianflag = 0;", "\n    char name1[10];", "\n    char password1[15];", "\n    show();", "\n    initial_stuff();", "\n    initial_goods();", "\n    printf(\"请输入用户名：\\n\");", "\n    scanf(\"%s\",name1);", "\n    printf(\"请输入用户密码：\\n\");", "\n    scanf(\"%s\",password1);", "\n    stuffnode *p2;", "\n    p2 = stuffhead; ", "\n    while(p2->next != NULL)", "\n    {", "\n        if ((strcmp( p2->s.name, name1)  == 0 && strcmp( p2->s.password, password1)  == 0 ) && ", "\n            ((strcmp( p2->s.quanxian, \"y\")  == 0 || strcmp( p2->s.quanxian, \"Y\")  == 0 )))", "\n        {", "\n            quanxianflag = 1;", "\n            break;", "\n        }", "\n        else", "\n        {", "\n            p2 = p2->next;", "\n        }", "\n    }", "\n\n", "显示错误\n错误  23  error C2065: “p2”: 未声明的标识符    \n警告  25  warning C4047: “=”:“int”与“stuffnode *”的间接级别不同   \n错误  22  error C2275: “stuffnode”: 将此类型用作表达式非法\n错误  27  error C2223: “->next”的左侧必须指向结构/联合 \n错误  33  error C2198: “strcmp”: 用于调用的参数太少  \n错误  29  error C2223: “->s”的左侧必须指向结构/联合\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;In (ANSI) C99, you can use a &lt;strong&gt;designated initializer&lt;/strong&gt; to initialize a structure: &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;MY_TYPE a = { .flag = true, .value = 123, .stuff = 0.456 };\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Edit: Other members are initialized as zero: \"Omitted field members are implicitly initialized the same as objects that have static storage duration.\" (&lt;a href=\"https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html\" rel=\"noreferrer\"&gt;https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html&lt;/a&gt;)&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何根据 c 语言标准初始化一个结构体", ["\n\n", "I want to initialize a struct element, split in declaration and initialization. This is what I have:", "\n\n", "typedef struct MY_TYPE {\n  boolean flag;\n  short int value;\n  double stuff;\n} MY_TYPE;\n\nvoid function(void) {\n  MY_TYPE a;\n  ...\n  a = { true, 15, 0.123 }\n}\n", "\n\n", "Is this the way to declare and initialize a local variable of ", "MY_TYPE", " in accordance with C programming language standards (C89, C90, C99, C11, etc.)? Or is there anything better or at least working?", "\n\n", "Update", " I ended up having a static initialization element where I set every subelement according to my needs.", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/330793/how-to-initialize-a-struct-in-accordance-with-c-programming-language-standards"]], "Tag": "程序设计"}
{"Answer": "this不是一个变量，所以在对象或结构体中没有它的存储空间。在C++的标准中是这么说的，\r\n![图片说明](https://img-ask.csdn.net/upload/201611/03/1478142629_171430.png)\r\n所以，可以看到this不是变量，是一个表达式。", "Konwledge_Point": "数据封装——结构体", "Question": ["c++ 结构体中的成员函数怎么解决", ["结构体中的成员函数在成员函数的参数中不能看this的地址它说【表达式必须为左值或函数指示符】应该怎么才能看this的地址 不明白解释以下比如说", "\n#include", "\nusing namespace std;", "\nstruct MyStruct", "\n{", "\n    int h;", "\n    int i;", "\n    void hun()", "\n    {", "\n        cout << h + i;", "\n    }", "\n};", "\nint main() {", "\n    MyStruct ki;", "\n    ki.h = 10;", "\n    ki.i = 100;", "\n    ki.hun();", "\n\n", "}", "\n不能查看this的地址"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把&lt;code class=\"language-javascript\"&gt;v1&lt;/code&gt;按值传入&lt;code class=\"language-javascript\"&gt;printf()&lt;/code&gt;函数&amp;#xff0c;相当于把&lt;code class=\"language-javascript\"&gt;v1.m_ptr&lt;/code&gt;, &lt;code class=\"language-javascript\"&gt;v1.m_age&lt;/code&gt;分别压入栈&amp;#xff0c;因此输出格式&lt;code class=\"language-javascript\"&gt;&amp;#34;%X %X&amp;#34;&lt;/code&gt;输出的就是&lt;code class=\"language-javascript\"&gt;v1.m_ptr&lt;/code&gt;, &lt;code class=\"language-javascript\"&gt;v1.m_age&lt;/code&gt;的值&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C/C++ 结构体打印结果不一样", ["如果用 printf 打印 直接打印结构体 ，我一直以为打印出来的就是第一个成员的内容 （ 排除虚表）", "问题：", "（是32位，类型大小都一样，没有那个内存对齐什么的）", "\n", "（图1）", "\n", "（图1）看出 用printf打印 对象名 直接出 第一个成员 ，但是 如果这样打印 ， 结果不一样 （图2）", "\n", "（图2）", "\n", "发现 打印 v1 依旧是 &val 地址 ，但是在第一条语句中 &val 是 m_age 的值（这里我多次试过不同的m_age值）", "就是说偏移了4个字节 直接到了 m_age上 ， 我知道 printf 的参数是从右往左算的 （应该是吧，我记得我学过汇编，有一课是看函数的堆栈图，参数都是从右往左 push 进去 的， 汇编就学了点皮毛 ，应该是这样，可是这对打印结果有什么影响呢？这里我就不明白了）", "\n", "但是我换个 方式打印 如（图3）", "\n", "（图3）", "\n", "这个合乎我的意料（但不知道这样为什么就对了）"]], "Tag": "程序设计"}
{"Answer": "如果你的cstring是指针，那么还是需要手工delete的，否则不可能自动释放。", "Konwledge_Point": "数据封装——结构体", "Question": ["MFC中cstring放入结构体的释放", ["用delete释放结构体的话，cstring会被释放么？如果不会，能用free去释放cstring么？"]], "Tag": "程序设计"}
{"Answer": "http://its.nbtvu.net.cn/xhyu/cai_c/c_web/c/c8/c83.htm\r\n这个涉及到存储\r\n![图片说明](https://img-ask.csdn.net/upload/201611/03/1478102621_509132.png)", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体的相关问题，会的留言", ["struct TFLS{", "\n            unsigned char f1:2;", "\n            unsigned char f2:1;", "\n            unsigned char f3:3;", "\n            unsigned char f4:5;", "\n}", "\n解释一下并说出占多少个字节"]], "Tag": "程序设计"}
{"Answer": "你可以看一下报错内容，是没有main函数入口吧。。。", "Konwledge_Point": "数据封装——结构体", "Question": ["vs定义一个结构体时报错，但后面用这个结构体写了一点东西后又可以整个通过编译，为啥？？萌新求大佬指教", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你声明的closePoinet函数需要的参数是结构数组&amp;#xff0c;而你调用是传递的point[7]是一个具体的结构&amp;#xff0c;不是一个结构数组&amp;#xff0c;可以直接传递point。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["请大佬帮我看看哪里错了 错误显示p=closePoint(point[7]);不匹配", ["#include<stdio.h>", "\n\n", "#include<math.h>", "\n\n", "//构造一个结构体数据类型来描述一个点", "\n\n", "struct Point", "\n\n", "{", "\n\n", "   int x;//x轴坐标", "\n\n", "   int y;//y轴坐标", "\n\n", "};  //分号不能丢", "\n\n", " ", "\n\n", "//构造一个double computeDist () 函数来计算两点之间的距离", "\n\n", "double computeDist (int x,int y)", "\n\n", "{", "\n\n", "    int x0=1;", "\n\n", "    int y0=-1;", "\n\n", "    double distance;//定义每个花坛到土堆的距离", "\n\n", "    distance=sqrt(pow(x-x0,2)+pow(y-y0,2));//计算距离公式", "\n\n", "    return distance;", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "//构造一个closetPoint()函数来计算最近邻点，返回为一个点(结构体)的指针", "\n\n", "struct Point *closePoint(struct Point point[])", "\n\n", "{", "\n\n", "  int i;", "\n\n", "  int m;", "\n\n", "  double distance[i];", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "    distance[i]=computeDist(point[i].x,point[i].y);", "\n\n", "  }", "\n\n", "  int min=distance[0];", "\n\n", "  struct Point *pStruct;//定义一个结构体型指针", "\n\n", "  pStruct=point;//指针指向point", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "      if(min>distance[i])", "\n\n", "      {", "\n\n", "          min=distance[i];", "\n\n", "          pStruct=&point[i];", "\n\n", "      }", "\n\n", "  }", "\n\n", "   return pStruct;", "\n\n", "}", "\n\n", "//主体", "\n\n", "int main()", "\n\n", "{", "\n\n", "  struct Point point[7]={{2,7},{10,5},{8,-2},{7,-6},{-3,-5},{-8,0},{-5,6}};", "\n\n", "  //构造一个结构体数组来存放我们的7个点,并初始化结构体数组的值", "\n\n", "  struct Point *p;", "\n\n", "  p=closePoint(point[7]);//指针指向最近的点", "\n\n", "  printf(\"最近的花坛坐标为(%d,%d)\",(*p).x,(*p).y);", "\n\n", "  return 0;", "\n\n", "}", "\n\n", "#include<stdio.h>", "\n\n", "#include<math.h>", "\n\n", "//构造一个结构体数据类型来描述一个点", "\n\n", "struct Point", "\n\n", "{", "\n\n", "   int x;//x轴坐标", "\n\n", "   int y;//y轴坐标", "\n\n", "};  //分号不能丢", "\n\n", " ", "\n\n", "//构造一个double computeDist () 函数来计算两点之间的距离", "\n\n", "double computeDist (int x,int y)", "\n\n", "{", "\n\n", "    int x0=1;", "\n\n", "    int y0=-1;", "\n\n", "    double distance;//定义每个花坛到土堆的距离", "\n\n", "    distance=sqrt(pow(x-x0,2)+pow(y-y0,2));//计算距离公式", "\n\n", "    return distance;", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "//构造一个closetPoint()函数来计算最近邻点，返回为一个点(结构体)的指针", "\n\n", "struct Point *closePoint(struct Point point[])", "\n\n", "{", "\n\n", "  int i;", "\n\n", "  int m;", "\n\n", "  double distance[i];", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "    distance[i]=computeDist(point[i].x,point[i].y);", "\n\n", "  }", "\n\n", "  int min=distance[0];", "\n\n", "  struct Point *pStruct;//定义一个结构体型指针", "\n\n", "  pStruct=point;//指针指向point", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "      if(min>distance[i])", "\n\n", "      {", "\n\n", "          min=distance[i];", "\n\n", "          pStruct=&point[i];", "\n\n", "      }", "\n\n", "  }", "\n\n", "   return pStruct;", "\n\n", "}", "\n\n", "//主体", "\n\n", "int main()", "\n\n", "{", "\n\n", "  struct Point point[7]={{2,7},{10,5},{8,-2},{7,-6},{-3,-5},{-8,0},{-5,6}};", "\n\n", "  //构造一个结构体数组来存放我们的7个点,并初始化结构体数组的值", "\n\n", "  struct Point *p;", "\n\n", "  p=closePoint(point[7]);//指针指向最近的点", "\n\n", "  printf(\"最近的花坛坐标为(%d,%d)\",(*p).x,(*p).y);", "\n\n", "  return 0;", "\n\n", "}", "\n\n", "#include<stdio.h>", "\n\n", "#include<math.h>", "\n\n", "//构造一个结构体数据类型来描述一个点", "\n\n", "struct Point", "\n\n", "{", "\n\n", "   int x;//x轴坐标", "\n\n", "   int y;//y轴坐标", "\n\n", "};  //分号不能丢", "\n\n", " ", "\n\n", "//构造一个double computeDist () 函数来计算两点之间的距离", "\n\n", "double computeDist (int x,int y)", "\n\n", "{", "\n\n", "    int x0=1;", "\n\n", "    int y0=-1;", "\n\n", "    double distance;//定义每个花坛到土堆的距离", "\n\n", "    distance=sqrt(pow(x-x0,2)+pow(y-y0,2));//计算距离公式", "\n\n", "    return distance;", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "//构造一个closetPoint()函数来计算最近邻点，返回为一个点(结构体)的指针", "\n\n", "struct Point *closePoint(struct Point point[])", "\n\n", "{", "\n\n", "  int i;", "\n\n", "  int m;", "\n\n", "  double distance[i];", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "    distance[i]=computeDist(point[i].x,point[i].y);", "\n\n", "  }", "\n\n", "  int min=distance[0];", "\n\n", "  struct Point *pStruct;//定义一个结构体型指针", "\n\n", "  pStruct=point;//指针指向point", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "      if(min>distance[i])", "\n\n", "      {", "\n\n", "          min=distance[i];", "\n\n", "          pStruct=&point[i];", "\n\n", "      }", "\n\n", "  }", "\n\n", "   return pStruct;", "\n\n", "}", "\n\n", "//主体", "\n\n", "int main()", "\n\n", "{", "\n\n", "  struct Point point[7]={{2,7},{10,5},{8,-2},{7,-6},{-3,-5},{-8,0},{-5,6}};", "\n\n", "  //构造一个结构体数组来存放我们的7个点,并初始化结构体数组的值", "\n\n", "  struct Point *p;", "\n\n", "  p=closePoint(point[7]);//指针指向最近的点", "\n\n", "  printf(\"最近的花坛坐标为(%d,%d)\",(*p).x,(*p).y);", "\n\n", "  return 0;", "\n\n", "}", "\n\n", "#include<stdio.h>", "\n\n", "#include<math.h>", "\n\n", "//构造一个结构体数据类型来描述一个点", "\n\n", "struct Point", "\n\n", "{", "\n\n", "   int x;//x轴坐标", "\n\n", "   int y;//y轴坐标", "\n\n", "};  //分号不能丢", "\n\n", " ", "\n\n", "//构造一个double computeDist () 函数来计算两点之间的距离", "\n\n", "double computeDist (int x,int y)", "\n\n", "{", "\n\n", "    int x0=1;", "\n\n", "    int y0=-1;", "\n\n", "    double distance;//定义每个花坛到土堆的距离", "\n\n", "    distance=sqrt(pow(x-x0,2)+pow(y-y0,2));//计算距离公式", "\n\n", "    return distance;", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "//构造一个closetPoint()函数来计算最近邻点，返回为一个点(结构体)的指针", "\n\n", "struct Point *closePoint(struct Point point[])", "\n\n", "{", "\n\n", "  int i;", "\n\n", "  int m;", "\n\n", "  double distance[i];", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "    distance[i]=computeDist(point[i].x,point[i].y);", "\n\n", "  }", "\n\n", "  int min=distance[0];", "\n\n", "  struct Point *pStruct;//定义一个结构体型指针", "\n\n", "  pStruct=point;//指针指向point", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "      if(min>distance[i])", "\n\n", "      {", "\n\n", "          min=distance[i];", "\n\n", "          pStruct=&point[i];", "\n\n", "      }", "\n\n", "  }", "\n\n", "   return pStruct;", "\n\n", "}", "\n\n", "//主体", "\n\n", "int main()", "\n\n", "{", "\n\n", "  struct Point point[7]={{2,7},{10,5},{8,-2},{7,-6},{-3,-5},{-8,0},{-5,6}};", "\n\n", "  //构造一个结构体数组来存放我们的7个点,并初始化结构体数组的值", "\n\n", "  struct Point *p;", "\n\n", "  p=closePoint(point[7]);//指针指向最近的点", "\n\n", "  printf(\"最近的花坛坐标为(%d,%d)\",(*p).x,(*p).y);", "\n\n", "  return 0;", "\n\n", "}", "\n\n", "#include<stdio.h>", "\n\n", "#include<math.h>", "\n\n", "//构造一个结构体数据类型来描述一个点", "\n\n", "struct Point", "\n\n", "{", "\n\n", "   int x;//x轴坐标", "\n\n", "   int y;//y轴坐标", "\n\n", "};  //分号不能丢", "\n\n", " ", "\n\n", "//构造一个double computeDist () 函数来计算两点之间的距离", "\n\n", "double computeDist (int x,int y)", "\n\n", "{", "\n\n", "    int x0=1;", "\n\n", "    int y0=-1;", "\n\n", "    double distance;//定义每个花坛到土堆的距离", "\n\n", "    distance=sqrt(pow(x-x0,2)+pow(y-y0,2));//计算距离公式", "\n\n", "    return distance;", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "//构造一个closetPoint()函数来计算最近邻点，返回为一个点(结构体)的指针", "\n\n", "struct Point *closePoint(struct Point point[])", "\n\n", "{", "\n\n", "  int i;", "\n\n", "  int m;", "\n\n", "  double distance[i];", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "    distance[i]=computeDist(point[i].x,point[i].y);", "\n\n", "  }", "\n\n", "  int min=distance[0];", "\n\n", "  struct Point *pStruct;//定义一个结构体型指针", "\n\n", "  pStruct=point;//指针指向point", "\n\n", "  for(i=0;i<m;i++)", "\n\n", "  {", "\n\n", "      if(min>distance[i])", "\n\n", "      {", "\n\n", "          min=distance[i];", "\n\n", "          pStruct=&point[i];", "\n\n", "      }", "\n\n", "  }", "\n\n", "   return pStruct;", "\n\n", "}", "\n\n", "//主体", "\n\n", "int main()", "\n\n", "{", "\n\n", "  struct Point point[7]={{2,7},{10,5},{8,-2},{7,-6},{-3,-5},{-8,0},{-5,6}};", "\n\n", "  //构造一个结构体数组来存放我们的7个点,并初始化结构体数组的值", "\n\n", "  struct Point *p;", "\n\n", "  p=closePoint(point[7]);//指针指向最近的点", "\n\n", "  printf(\"最近的花坛坐标为(%d,%d)\",(*p).x,(*p).y);", "\n\n", "  return 0;", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你结构体没贴出来&amp;#xff0c;怎么看啊&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体函数问题", ["题1struct date    //定义一个表示日期的结构体date", "{   int year, month, day;  };", "struct stu     //定义一个表示学生记录的结构体stu", "{   char name[20];", "    struct date birthday;", "    int Score[4];", "float ave;", "};", "1.结构体同题1，声明语句“struct stu zhang,*p=&zhang;”，要完成将zhang的出生日期的年份设为2000，正确的语句是（  ）。", "A", "zhang.year=2000;", "B", "zhang.date.year=2000;", "C", "p->birthday->year=2000;", "D", "p->birthday.year=2000;", "\n", "结构体定义同题1，要声明结构体stu的n个元素的动态数组ps，正确的语句是（    ）。", "A", "ps=malloc(sizeof(stu));", "B", "ps=malloc(sizeof(stu)", "n);", "C", "ps=(stu", ")malloc(sizeof(stu)", "n);", "D", "ps=(struct stu", ")malloc(sizeof(struct stu)*n);", "\n", "这两题分别选B D是对的吗 能帮忙解答一下吗 谢谢🙏"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;冒泡排序第二个循环应该是j从0开始&amp;#xff0c;j&amp;lt;n-1 ,&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体与共同体——成绩排名", ["麻烦帮我看见哪里有问题，我一直找不出来，有的测试点一直过不了", "\n", "定义结构体struct stu，编写成绩排名函数:void sort(struct stu *ps,int n),对结构体数组按成绩排名。 程序功能为读入整数N（N<100）,再读入N个学生的学号（整型）和成绩(实数)。按样例输出排名。", "\n", "输出格式:", "\n", "第一列是名次，注意并列情况；第二列是学号，第三列是成绩（2位小数）。", "输入样例:", "\n", "5", "101 99", "102 100", "103 50", "104 80", "105 99", "输出样例:", "\n", "1 102 100.00", "2 101 99.00", "2 105 99.00", "4 104 80.00", "5 103 50.00", "\n", "\n", "#include <stdio.h>", "\nstruct stu\n{\n  int num;\n  double grade;\n};\nvoid sort(struct stu *ps,int n)\n{\n   int i,j,t,m;\n   ", "for", "(", "i", "=0;i<n;i++){\n       scanf(", "\"%d %lf\"", ",&ps[i].num,&ps[i].grade);\n   ｝\n   ", "for", "(", "i", "=0;i<n;i++){\n       ", "for", "(", "j", "=i;j<n-i-1;j++){\n           ", "if", "(ps[j].grade<ps[j+1].grade){\n              ", "t", "=ps[j].grade;\n              ps[j].", "grade", "=ps[j+1].grade;\n              ps[j+1].", "grade", "=t;\n              ", "m", "=ps[j].num;\n              ps[j].", "num", "=ps[j+1].num;\n              ps[j+1].", "num", "=m;\n           }\n       }\n   }\n   int ", "k", "=1,p=1;\n   ", "for", "(", "i", "=0;i<n;i++){\n        ", "if", "(ps[i-1].grade!=ps[i].grade){\n            printf(", "\"%d %d %.2f\\n\"", ",p,ps[i].num,ps[i].grade);\n            ", "k", "=p;\n            p++;\n        }", "else", "{\n            printf(", "\"%d %d %.2f\\n\"", ",k,ps[i].num,ps[i].grade);\n            p++;\n        }\n   }\n}\nint main()\n{\n    int n;\n    scanf(", "\"%d\"", ",&n);\n    struct stu p[100];\n    sort(p,n);\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n scanf(\"%d%s%lf\",&amp;s[k].num,&amp;s[k].name,&amp;s[k].score);\r\n```\r\n应为：\r\n\r\n\r\n\r\n```\r\n scanf(\"%d%s%lf\",&amp;s[k].num,s[k].name,&amp;s[k].score);\r\n```\r\n\r\n\r\n\r\n\r\n看一下结构体中name的定义：\r\n```\r\n char name[19]; //数组名name就是数组的首地址，所以用%s读入时，不用再加取地址运算符&amp;。\r\n```\r\n\r\n**用心回答每个问题，如果有帮助，请采纳答案好吗，谢谢~~~**", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体指针问题求修改", ["#include", "\nint main(void)", "\n{", "\n    struct student {", "\n        int num;", "\n        char name[19];", "\n        double score;", "\n    };", "\n    int i,k,N;", "\n    scanf(\"%d\",&N);", "\n    for(i=0;i\n    {", "\n        struct student s[3];", "\n        struct student *p;", "\n        for(k=0;k\n            scanf(\"%d%s%lf\",&s[k].num,&s[k].name,&s[k].score);", "\n            p = &s[k];", "\n        }", "\n        for(k=0;k\n            printf(\"%d\\t%-20s%lf\\n\",s[k].num,s[k].name,s[k].score);", "\n        }", "\n        for(k=0;k\n            printf(\"%d\\t%-20s%lf\\n\",p->num,p->name,p->score);", "\n        }", "\n    }", "\n    return 0;", "\n}", "\n编译器显示：Your Code: In function 'main':", "\nYour Code:17:19: warning: format '%s' expects argument of type 'char ", "', but argument 3 has type 'char (", ")[19]' [-Wformat=]", "\n             scanf(\"%d%s%lf\",&s[k].num,&s[k].name,&s[k].score);", "\n                   ^", "\n0:编译失败，请检查源代码!", "\n\n", "请问如何解决这个问题？谢谢各位好心人！急急急！！！", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "你的typedef struct grade里的第二项，struct grede *next，grede拼写错了\r\n应该为grade", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言 结构体类型转换，急", ["error C2440: '=' : cannot convert from 'struct grade *' to 'struct grede *'", "\n\n", "VC++  编译环境报整个错误，   初学者我就看不懂了。。。", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You want to bypass the Go type system, which is unsafe. Therefore, you should be very careful. Implement this as a function and use the Go testing package to write tests. Check for errors. Write simple, readable code. Don't be clever.&lt;/p&gt;\n\n&lt;p&gt;For example,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nconst num1 = 42\n\ntype struct1 struct {\n    arr [num1]byte\n}\n\nconst (\n    n1 = 1\n    n2 = 2\n    n3 = 1\n)\n\ntype struct2 struct {\n    b1 [n1]uint64\n    b2 [n2]uint64\n    b3 [n3]uint64\n}\n\nfunc arrInsert(p1 *struct1, i1 int, p2 *struct2) int {\n    if p1 == nil || p2 == nil {\n        return 0\n    }\n    if i1 &amp;lt; 0 || i1 &amp;gt;= len(p1.arr) {\n        return 0\n    }\n    s1 := p1.arr[i1:]\n    s2 := (*[unsafe.Sizeof(*p2)]byte)(unsafe.Pointer(p2))[:]\n    return copy(s1, s2)\n}\n\nfunc main() {\n    p1 := new(struct1)\n    p2 := new(struct2)\n    for i := range p2.b1 {\n        p2.b1[i] = uint64(i + 10)\n    }\n    for i := range p2.b2 {\n        p2.b2[i] = uint64(i + 20)\n    }\n    for i := range p2.b3 {\n        p2.b3[i] = uint64(i + 30)\n    }\n    n := arrInsert(p1, 1, p2)\n    fmt.Println(n)\n    fmt.Println(*p1)\n    fmt.Println((*[unsafe.Sizeof(*p2)]byte)(unsafe.Pointer(p2))[:])\n    fmt.Println(*p2)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Playground: &lt;a href=\"https://play.golang.org/p/KA0B0xpFR6l\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/KA0B0xpFR6l&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;32\n{[0 10 0 0 0 0 0 0 0 20 0 0 0 0 0 0 0 21 0 0 0 0 0 0 0 30 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]}\n[10 0 0 0 0 0 0 0 20 0 0 0 0 0 0 0 21 0 0 0 0 0 0 0 30 0 0 0 0 0 0 0]\n{[10] [20 21] [30]}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在GO中从一个结构复制到另一个结构", ["\n\n", "I have two structs:", "\n\n", "type struct1 struct{\n     arr [num1]byte\n}\n\ntype struct2 struct{\n     b1 [n1]uint64\n     b2 [n2]uint64\n     b3 [n3]uint64\n}\n", "\n\n", "Now, I have two pointers to these structs:", "\n\n", "p1 := new(struct1);\np2 := new(struct2);\n", "\n\n", "and after some computations, I want to copy p2 to a specified part of p1. Something like:", "\n\n", "copy(p1.arr[k:], p2);\n", "\n\n", "Where k is a positive integer. It can be easily done in C using ", "memcpy", ", but I could not find an easy way to do it in GO without using any external libraries. Does anyone have any suggestions? I'll really appreciate it.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;值类型分配在堆&amp;#xff0c;引用类型分配在栈。对吗&amp;#xff1f;&lt;br /&gt;基本上对&amp;#xff0c;有一些特例&amp;#xff0c;比如你第二个问题提到的场景&amp;#xff0c;或者是static对象等。&lt;/p&gt;\n&lt;p&gt;struct是值类型&amp;#xff0c;class是引用类型。 class里的值类型分配在堆上对吗&lt;br /&gt;对&amp;#xff0c;值类型会跟分配时的引用放在一起。&lt;/p&gt;\n&lt;p&gt;struct里的引用类型&amp;#xff0c;比如数组 内存分配在哪&lt;br /&gt;struct里保存一个引用&amp;#xff0c;实际对象还是在堆中&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C#  struct里的引用类型内存分配在堆上还是栈上", ["值类型分配在堆，引用类型分配在栈。对吗？struct是值类型，class是引用类型。  class里的值类型分配在堆上对吗。struct里的引用类型，比如数组 内存分配在哪。头蒙蒙"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/jiftlixu/article/details/5351741", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ DLL接口结构体的转寰问题，究竟字符串内存的分配是怎样的", ["为什么VB6.0不需要释放内存，而同样的结构体在C++ DLL使用，C++自己反倒需要释放内存呢？字符串有什么不同？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&amp;#xff08;可能结构体中的名字不一致&amp;#xff0c;修改一下即可&amp;#xff09;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n//定义课程数量\n#define NMBKC 4\nstruct Student\n{\n\tchar id[5];    //学号\n\tchar name[20]; //姓名\n\tfloat score[NMBKC];//成绩\n\tfloat total;   //总分\n\tfloat avg;     //平均分\n};\n//录入信息\nvoid InputInfo(struct Student arr[],int n)\n{\n\tint i,j;\n\tfor (i &amp;#61; 0;i &amp;lt; n; i&amp;#43;&amp;#43;)\n\t{\n\t\tarr[i].total &amp;#61; 0.0;\n\t\tprintf(&amp;#34;请输入第%d名学生的信息&amp;#xff08;学号、姓名、课程成绩&amp;#xff09;&amp;#xff1a;&amp;#34;,i&amp;#43;1);\n\t\tscanf(&amp;#34;%s %s&amp;#34;,arr[i].id,arr[i].name);\n\t\tfor (j &amp;#61; 0;j &amp;lt; NMBKC;j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tscanf(&amp;#34;%f&amp;#34;,&amp;amp;arr[i].score[j]);\n\t\t\tarr[i].total &amp;#43;&amp;#61; arr[i].score[j];\n\t\t}\n\t\tarr[i].avg &amp;#61; arr[i].total / NMBKC;\n\t}\n}\n//修改数据\nvoid ChangeInfo(struct Student arr[],int n)\n{\n\tint i,j;\n\tchar id[8] &amp;#61; {0};\n\tchar c;\n\tprintf(&amp;#34;请输入学生的学号:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;,id);\n\n\tfor (i &amp;#61; 0; i &amp;lt; n;i&amp;#43;&amp;#43;)\n\t{\n\t\tif (strcmp(arr[i].id, id) &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tprintf(&amp;#34;是否修改姓名(Y/N)?&amp;#34;);\n\t\t\tscanf(&amp;#34; %c&amp;#34;,&amp;amp;c);\n\t\t\tgetchar();//吸收回车符\n\t\t\tif (&amp;#39;Y&amp;#39; &amp;#61;&amp;#61; c || &amp;#39;y&amp;#39; &amp;#61;&amp;#61; c)\n\t\t\t{\n\t\t\t\tprintf(&amp;#34;请输入修改后的名字:&amp;#34;);\n\t\t\t\tscanf(&amp;#34;%s&amp;#34;,arr[i].name);\n\t\t\t}\n\t\t\tprintf(&amp;#34;是否修改成绩(Y/N)?&amp;#34;);\n\t\t\tscanf(&amp;#34; %c&amp;#34;,&amp;amp;c);\n\t\t\tgetchar();//吸收回车符\n\t\t\tif(&amp;#39;Y&amp;#39; &amp;#61;&amp;#61; c || &amp;#39;y&amp;#39; &amp;#61;&amp;#61; c)\n\t\t\t{\n\t\t\t\tprintf(&amp;#34;请输入%d门成绩:&amp;#34;,NMBKC);\n\t\t\t\t//此处默认修改全部成绩&amp;#xff0c;也可以进一步细化修改某个课程的成绩\n\t\t\t\tarr[i].total &amp;#61; 0.0;\n\t\t\t\tfor (j &amp;#61; 0;j &amp;lt; NMBKC;j&amp;#43;&amp;#43;)\n\t\t\t\t{\n\t\t\t\t\tscanf(&amp;#34;%f&amp;#34;,&amp;amp;arr[i].score[j]);\n\t\t\t\t\tarr[i].total &amp;#43;&amp;#61; arr[i].score[j];\n\t\t\t\t}\n\t\t\t\tarr[i].avg &amp;#61; arr[i].total / NMBKC;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n//排序\nvoid SortByTotal(struct Student arr[],int n)\n{\n\tint i,j;\n\tstruct Student tmp;\n\tfor (i &amp;#61; 0; i &amp;lt; n-1;i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0;j &amp;lt; n-1-j;j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tif(arr[j].total &amp;lt; arr[j&amp;#43;1].total)\n\t\t\t{\n\t\t\t\ttmp &amp;#61; arr[j];\n\t\t\t\tarr[j] &amp;#61; arr[j&amp;#43;1];\n\t\t\t\tarr[j&amp;#43;1] &amp;#61; tmp;\n\t\t\t}\n\t\t}\n\t}\n\t//显示\n\tfor (i &amp;#61; 0;i&amp;lt; n;i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;%s\\t%s\\t%.1f\\t%.1f\\t&amp;#34;,arr[i].id,arr[i].name,arr[i].total,arr[i].avg);\n\t\tfor (j&amp;#61;0;j&amp;lt;NMBKC;j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tprintf(&amp;#34;%f\\t&amp;#34;,arr[i].score[j]);\n\t\t}\n\t\tprintf(&amp;#34;\\n&amp;#34;);\n\t}\n}\n\n//查询\nvoid Find(struct Student arr[],int n)\n{\n\tint i,j;\n\n\tchar name[20]&amp;#61;{0};\n\tprintf(&amp;#34;请输入学号或者姓名:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;,name);\n\t\n\tfor (i &amp;#61; 0;i &amp;lt; n;i&amp;#43;&amp;#43;)\n\t{\n\t\tif( (strcmp(arr[i].name,name) &amp;#61;&amp;#61; 0) || (strcmp(arr[i].id ,name)&amp;#61;&amp;#61;0) )\n\t\t{\n\t\t\tprintf(&amp;#34;%s\\t%s\\t%.1f\\t%.1f\\t&amp;#34;,arr[i].id,arr[i].name,arr[i].total,arr[i].avg);\n\t\t\tfor (j&amp;#61;0;j&amp;lt;NMBKC;j&amp;#43;&amp;#43;)\n\t\t\t{\n\t\t\t\tprintf(&amp;#34;%f\\t&amp;#34;,arr[i].score[j]);\n\t\t\t}\n\t\t\tprintf(&amp;#34;\\n&amp;#34;);\n\t\t\tbreak;;\n\t\t}\n\t}\n}\n//统计每个学生的平均成绩和每门课程的平均成绩\n//每个学生的平均成绩在录入成绩时已经计算&amp;#xff0c;此处只统计每门课程的平均成绩\n//统计结果放在avg数组中\nvoid Tongji(struct Student arr[],int n,float avg[])\n{\n\tint i,j;\n\tfor (i &amp;#61; 0; i&amp;lt; NMBKC;i&amp;#43;&amp;#43;)\n\t{\n\t\tavg[i] &amp;#61; 0.0;\n\t\tfor (j &amp;#61; 0;j &amp;lt; n;j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tavg[i] &amp;#43;&amp;#61; arr[j].score[i];\n\t\t}\n\t\tavg[i] &amp;#61; avg[i]/n;\n\t}\n\t//显示课程平均分\n\tprintf(&amp;#34;课程平均分:&amp;#34;);\n\tfor (i &amp;#61; 0;i &amp;lt; NMBKC;i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;课程%d的平均分:%.1f\\n&amp;#34;,i&amp;#43;1,avg[i]);\n\t}\n}\n\nint main()\n{\n\tstruct Student stu[10];\n\tint n;\n\tint opt;\n\tint bgo &amp;#61; 1;\n\tfloat avg[NMBKC]; //课程平均分\n\twhile(bgo)\n\t{\n\t\tprintf(&amp;#34;-------学生管理系统-------\\n&amp;#34;);\n\t\tprintf(&amp;#34;  1.录入学生信息          \\n&amp;#34;);\n\t\tprintf(&amp;#34;  2.修改学生信息          \\n&amp;#34;);\n\t\tprintf(&amp;#34;  3.按总分排序            \\n&amp;#34;);\n\t\tprintf(&amp;#34;  4.学生平均分和课程平均分\\n&amp;#34;);\n\t\tprintf(&amp;#34;  9.退出系统              \\n&amp;#34;);\n\t\tprintf(&amp;#34;--------------------------\\n&amp;#34;);\n\t\tscanf(&amp;#34;%d&amp;#34;,&amp;amp;opt);\n\t\tswitch(opt)\n\t\t{\n\t\tcase 1:\n\t\t\tprintf(&amp;#34;请输入学生人数:&amp;#34;);\n\t\t\tscanf(&amp;#34;%d&amp;#34;,&amp;amp;n);\n\t\t\tInputInfo(stu,n);\n\t\t\tgetchar();\n\t\t\tgetchar();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tChangeInfo(stu,n);\n\t\t\tgetchar();\n\t\t\tgetchar();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSortByTotal(stu,n);\n\t\t\tgetchar();\n\t\t\tgetchar();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tTongji(stu,n,avg);\n\t\t\tgetchar();\n\t\t\tgetchar();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tbgo &amp;#61; 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++结构体应用.。", ["把30名学生的学号，姓名，4门课的成绩以及平均分放在一个结构体数组中。学生的学号、姓名、4门课的成绩由键盘输入，计算出平均分放在结构体对应的域中", "\n\n", "提示类型说明如下", "\n\n", "struct  student", "\n\n", "｛", "\n\n", "       char num【5】，name【10】；", "\n\n", "       int s【4】；", "\n\n", "       double ave；", "\n\n", "｝"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;成绩除以10&amp;#xff0c;用switch...case...&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-xml\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;\n{\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score;\n  &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; grade[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n}stu[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;fun&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n  {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; g &amp;#61; stu[i].score/&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(g)\n    {\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;:\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;:\n        stu[i].grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;优&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;:\n        stu[i].grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;良&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;:\n        stu[i].grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;中&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;:\n        stu[i].grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;及格&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;:\n        stu[i].grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;不及格&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n  }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入学生人数:&amp;#34;&lt;/span&gt;);\n  &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请逐行输入%d个学生的姓名和成绩:\\n&amp;#34;&lt;/span&gt;,n);\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %d&amp;#34;&lt;/span&gt;,stu[i].name,&amp;amp;stu[i].score);\n  &lt;span class=\"hljs-built_in\"&gt;fun&lt;/span&gt;();\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %d %s\\n&amp;#34;&lt;/span&gt;,stu[i].name,stu[i].score,stu[i].grade);\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求解定义一个学生成绩的结构体数组", ["定义一个学生成绩的结构体数组，编写函数，根据学生成绩给出“优、良、中、及格”的评定“90-100”-优、“80-90”-良，“70-80”-中，“60-70”-及格。"]], "Tag": "程序设计"}
{"Answer": "在java里面没有指针的定义，但java里面可以用对象替代指针，比如\nA   a   =new   A;\nA   b=a;\na和b是指向同一个对象的。", "Konwledge_Point": "数据封装——结构体", "Question": ["Java怎么实现C++中的结构体", ["比如这样一个C++的代码：", "\nStruct struct{", "\n    int a;", "\n    int b;", "\n    struct* next;", "\n}", "\n\n", "Java怎么用类写出来，尤其是那个next指针怎么写"]], "Tag": "程序设计"}
{"Answer": "应该是`struct st at;`或者是\r\n\r\n```\r\ntypedef struct st{int a;char q;short d;} st;\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["这里的结构体怎么不好定义的？", []], "Tag": "程序设计"}
{"Answer": "scanf_s对于%c和%s格式需要指定数组元素或变量的个数\r\n\r\n```\r\n \tscanf_s(\"%s\", &amp;me.name,10);\r\n\tprintf(\"Please Input Your sex\\n\");\r\n\tscanf_s(\"%s\", &amp;me.sex,5);\r\n\tprintf(\"Please Input Your age\\n\");\r\n\tscanf_s(\"%d\", &amp;me.age);\r\n\tprintf(\"Please Input Your Class\\n\");\r\n\tscanf_s(\"%d\", &amp;me.Class);\r\n\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体在VS2013输入时候遇到的问题", ["IDE:VS2013", "\nOS:Windows7", "\n源码附上:", "\n\n", "#include<windows.h>\n#include<stdio.h>\nint main()\n{\n    //定义一个People类型的结构体\n    struct People{\n        char name[10];//名字\n        char sex[5];//性别\n        int age;//年龄\n        int Class;//班级\n    }me;\n    //将me声明为People类型的结构体变量\n\n    printf(\"Please Input Your Name\\n\");\n    scanf_s(\"%s\", &me.name);\n    printf(\"Please Input Your sex\\n\");\n    scanf_s(\"%s\", &me.sex);\n    printf(\"Please Input Your age\\n\");\n    scanf_s(\"%d\", &me.age);\n    printf(\"Please Input Your Class\\n\");\n    scanf_s(\"%d\", &me.Class);\n\n    printf(\"%s\", me.name);\n    printf(\"%s\", me.sex);\n    printf(\"%d\", me.age);\n    printf(\"%d\", me.Class);\n\n\n    system(\"pause\");\n    return 0;\n}\n\n", "\n\n", "问题概述", "\n输入名字后 程序直接没了 然后直接打印出后面的三句话了 按程序来说 应该是打印一句话 然后停下来让我输入的啊 怎么我输入一个 下面三句话都打印出来了 ", "\n\n", "运行结果:", "\n\n", "改了下程序 把scanf_s _s去掉后 在Devc++中就可以正常使用 ", "\n\n", "在Devc++中的运行结果", "\n\n", "请问各位C前辈 是不是因为VS2013中 对键盘缓冲区进行了特殊的处理呢？"]], "Tag": "程序设计"}
{"Answer": "C++ 代码已经实现，代码调试通过。请速度采用，急用C币下载！！\r\n\r\n```\r\n \r\n \r\n #include&lt;iostream&gt;\r\n#include&lt;fstream&gt;\r\n\r\nusing namespace std;\r\nstruct student\r\n{\r\n\tint id;\r\n\tint avescore;\r\n};\r\n\r\n\r\nint main()\r\n{\r\n\tint numbers = 0;\r\n\tcout &lt;&lt; \"请输入元素个数：\";\r\n\tcin &gt;&gt; numbers;\r\n\tstudent*  pArrStudent = new student[numbers];\r\n\tfor (int i = 0; i &lt; numbers; i++)\r\n\t{\r\n\t\tcout &lt;&lt; \"请输入第\" &lt;&lt; i + 1 &lt;&lt; \"个元素id和avescore，空格分隔：\";\r\n\t\tint id = 0;\r\n\t\tint avescore = 0;\r\n\t\tcin &gt;&gt; id &gt;&gt; avescore;\r\n\t\tpArrStudent[i].id = id;\r\n\t\tpArrStudent[i].avescore = avescore;\r\n\r\n\t}\r\n\r\n\r\n\t//显示输入的数据\r\n\tcout &lt;&lt; \"({\";\r\n\tfor (int i = 0; i &lt; numbers; i++)\r\n\t{\r\n\t\tif (i &lt; numbers - 1)\r\n\t\t{\r\n\t\t\tcout &lt;&lt; pArrStudent[i].id &lt;&lt; \",\" &lt;&lt; pArrStudent[i].avescore &lt;&lt; \";\";\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout &lt;&lt; pArrStudent[i].id &lt;&lt; \",\" &lt;&lt; pArrStudent[i].avescore;\r\n\t\t}\r\n\r\n\t};\r\n\tcout &lt;&lt; \"})\";\r\n\r\n\r\n\t//存入磁盘文件:student.txt\r\n\tofstream oFile(L\"student.txt\");\r\n\toFile.write((char*)pArrStudent, sizeof(student)*numbers);\r\n\toFile.close();\r\n\r\n\r\n\t//从student.txt中读出数据\r\n\tstudent*  pArrStudentTemp = new student[numbers];\r\n\tifstream iFileTemp(L\"student.txt\");\r\n\tiFileTemp.read((char*)pArrStudentTemp, sizeof(student)*numbers);\r\n\tiFileTemp.close();\r\n\r\n\t//采用二进制模式存入文件student.bin\r\n\tofstream oFileTemp(L\"student.bin\", ios::binary);\r\n\toFileTemp.write((char*)pArrStudent, sizeof(student)*numbers);\r\n\toFileTemp.close();\r\n\r\n\tdelete []pArrStudent;\r\n\tdelete[]pArrStudentTemp;\r\n\r\n\treturn 0;\r\n};\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["c++ io流输入输出问题求解", ["构建一个结构体struct student,包括两个成员：id和avescore。", "\n构建一个struct student类型的动态数组（new 操作），元素个数由用户输入（要求3个）。", "\n输入数据存入数组并显示出来（{1,5;2,8;3,10}）", "\n使用文本模式通过I/O流把数组内容存入磁盘文件:student.txt", "\n从student.txt中读出数据，采用二进制模式存入文件student.bin", "\n使用VS打开两个文件，比较两个文件的区别"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; 前面3部分结构是固定的&amp;#xff0c;可以定义为一个结构体 命名为header&amp;#xff0c;后面的内容根据不同内容有变化&amp;#xff0c;可以把每种类型的数据分别定义为一个结构体&lt;br /&gt;然后定义一个大的结构体&amp;#xff0c;结构体的第一个部分是那个header&amp;#xff0c;第二个部分是一个union&amp;#xff0c;union的成员包括各种类型的数据。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体定义问题", ["\n", "\n", "C语言如何定义图片表格中的内容，第二个图是报文示例，供参考。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ElemType是用来表示顺序表元素类型的。而length表示长度&amp;#xff0c;必须用整型啊。&lt;br /&gt;假设将length类型写成ElemType&amp;#xff0c;回头你这顺序表元素想改成字符类型怎么办&amp;#xff1f;岂不是length成了字符类型了&amp;#xff1f;&amp;#xff1f;&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构 结构体中 int length可不可以写成 ElemType length 如果可以的话 为什么不这样写", ["数据结构 结构体中 int length可不可以写成 ElemType length 如果可以的话 为什么不这样写"]], "Tag": "程序设计"}
{"Answer": "呃，你这个代码问题实在比较多....\r\n我就捡最主要的几个说说吧。\r\n这应当是学校的练习题吧。\r\n\r\n1.  scanf获取学号（我猜的你那个num的含义）和姓名的时候，格式符\"%d%c\"是错的，要有空格，而且不能用%c来接收字符串，应当是\"d% %s\"\r\n2.  num未曾使用，不如不要求输入\r\n3.  开始输入之前最好给点提示吧，要不别人怎么知道如何输入？\r\n4.  最终的结果应当输出，否则没有意义\r\n至于输入回退、撤销等等，我想，在练习题中你没有必要实现了。", "Konwledge_Point": "数据封装——结构体", "Question": ["编程小问题，关于结构体", ["用结构体类型数组进行程序设计。有五个学生，每个学生的信息包括：学号，姓名，三门课的成绩和平均成绩。从键盘输入每个学生的学号，姓名和三门课的成绩，计算每个学生的平均成绩，计算并输出总平均成绩，求出最高分学生，并输出其信息(姓名和平均成绩)。", "\n实验步骤", "\n① 用一个函数输入五个学生的数据信息；", "\n② 用一个函数求每个学生的平均成绩；", "\n③ 用一个函数找出最高分的学生；", "\n④ 主函数中调用相关函数，并输出总平均成绩和最高分学生的信息。", "\n\n", "这是我写的代码", "\n#include", "\n#define N 5", "\nstruct student", "\n{", "\n    int num;", "\n    char name[20];", "\n    int score[3];", "\n}stu[5];", "\nfloat ave[3];", "\nvoid input();", "\nvoid average();", "\nint max();", "\nint main()", "\n{", "\n    input();", "\n    average();", "\n    int t;", "\n    t=max();", "\n}", "\nvoid input()", "\n{", "\n    int i,j;", "\n    for(i=0;i<5;i++)", "\n    {", "\n        scanf(\"%d%c\",&stu[i].num,&stu[i].name);", "\n        for(j=0;j<3;j++)", "\n        {", "\n            scanf(\"%d\",&stu[i].score[j]);", "\n        }", "\n    }", "\n}", "\nvoid average()", "\n{", "\n    int i,j;", "\n    for(i=0;i<5;i++)", "\n    {", "\n        ave[i]=0;", "\n        for(j=0;j<3;j++)", "\n        {", "\n            ave[i]+=stu[i].score[j];", "\n        }", "\n        ave[i]/=3;", "\n    }", "\n}", "\nint max()", "\n{", "\n    int i,maxi=0;", "\n    float max=ave[0];", "\n    for(i=1;i<5;i++)", "\n    {", "\n        if(max<ave[i])", "\n        {", "\n            max=ave[i];", "\n            maxi=i+1;", "\n        }", "\n    }", "\n    return maxi;", "\n}", "\n为什么无法运行啊？求指导"]], "Tag": "程序设计"}
{"Answer": "scanf 那邊\"%d %c %f\" 改成 \"%c %d %f\" 應該就可以了~~", "Konwledge_Point": "数据封装——结构体", "Question": ["c++编程结构体加多个函数为什么输入函数后面的几个函数不一样呢？", ["我在编程后 第一次因为scanf语句错误加上了fflush(stdin);成功了", "\n第二次编译成功，可是scanf后  其他函数的信息共享不到呢？", "\n\n", " #include \"stdafx.h\"\n#include<stdio.h>\n#define N 3\nstruct student\n{\n    int number;\n    char name;\n    float score;\n};\nstruct student stu[N];\nvoid input(){\n\n    for(int i=0;i<N;i++)\n    {   printf(\"请分别输入姓名、学号、分数:\\n\");\n    fflush(stdin);\n        scanf(\"%d %c %f\",&stu[i].name,&stu[i].number,&stu[i].score);\n\n        printf(\"\\n\");}\n\n}\nvoid otput()\n{\n    for(int i=0;i<N;i++)\n    {printf(\"第%d同学的姓名是%c，学号是%d，分数是%f \\n\",i+1,stu[i].name,stu[i].number,stu[i].score);}    \n\n}\n\nvoid avg()\n{\n    float s=0;\n    for(int i=0;i<N;i++)\n    {s=stu[i].score+s;}\n    printf(\"平均分是%f\\n\",s);\n}\nvoid nopass()\n{\n\n    printf(\"不及格的名单：\");\n    for(int i=0;i<N;i++)\n    {if(stu[i].score<60)\n    printf(\"%c\\n\",stu[i].name);\n    }\n}\n\nint main(int argc, char* argv[])\n{   \n    input();\n    otput();\n    avg();\n    nopass();\n    return 0;\n}\n\n\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是的&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体数组（如下图）是不是全局数组", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The &lt;a href=\"https://golang.org/pkg/encoding/json/\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;encoding/json&lt;/code&gt;&lt;/a&gt; package can be used to easily convert a &lt;code&gt;struct&lt;/code&gt; to JSON string and vice versa (parse a JSON string into a &lt;code&gt;struct&lt;/code&gt;).&lt;/p&gt;\n\n&lt;p&gt;Simple example (try it on the &lt;a href=\"http://play.golang.org/p/fZzKA5Yveh\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{\"Bob\", 23}\n\n    // Struct -&amp;gt; JSON\n    data, err := json.Marshal(&amp;amp;p)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(string(data))\n\n    // JSON -&amp;gt; JSON\n    var p2 Person\n    err = json.Unmarshal(data, &amp;amp;p2)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"%+v\", p2)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;{\"Name\":\"Bob\",\"Age\":23}\n{Name:Bob Age:23}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h3&gt;Notes:&lt;/h3&gt;\n\n&lt;p&gt;The fields of the &lt;code&gt;struct&lt;/code&gt; must be exported (start them with capital letter), else the &lt;code&gt;json&lt;/code&gt; package (which uses reflection) will not be able to read/write them.&lt;/p&gt;\n\n&lt;p&gt;You can also specify tags for the struct fields to control/fine tune the json marshaling/unmarshaling process, for example to change the names in the JSON text:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"years\"`\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;With this change the output of the above application is the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;{\"name\":\"Bob\",\"years\":23}\n{Name:Bob Age:23}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The documentation of the &lt;a href=\"https://golang.org/pkg/encoding/json/#Marshal\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;json.Marshal()&lt;/code&gt;&lt;/a&gt; function details the possibilities provided by the tags.&lt;/p&gt;\n\n&lt;p&gt;And by implementing the &lt;a href=\"https://golang.org/pkg/encoding/json/#Marshaler\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;json.Marshaler&lt;/code&gt;&lt;/a&gt; and &lt;a href=\"https://golang.org/pkg/encoding/json/#Unmarshaler\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;json.Unmarshaler&lt;/code&gt;&lt;/a&gt; interfaces you can fully customize the marshaling / unmarshaling process.&lt;/p&gt;\n\n&lt;p&gt;Also if your struct is not pre-defined (e.g. you don't know the fields in advance), you can use a &lt;code&gt;map[string]interface{}&lt;/code&gt;. &lt;a href=\"https://stackoverflow.com/a/28860080/1705598\"&gt;See this answer for details and examples&lt;/a&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将结构体作为字符串存储在Redis中", ["\n\n", "As Redis only stores strings I would like to know how I can do the equivalent of Javascript's JSON.stringify using Go to convert a Struct into a string.", "\n\n", "I have tried typecasting:", "\n\n", "string(the_struct)\n", "\n\n", "but this results in an error.", "\n    "]], "Tag": "程序设计"}
{"Answer": "32bit平台4+4+8+16=32\r\n64bit平台8+8+8+16=40", "Konwledge_Point": "数据封装——结构体", "Question": ["这个结构体的大小怎么计算？我怎么算都是48", ["typedef struct my", "\n{", "\n                            struct my *n;", "\n                            struct my *p;", "\n                            long value;", "\n                            unsigned char a[16];", "\n}m;", "\n用sizeof输出是40，可我怎么算都是48，求大佬帮我解释下"]], "Tag": "程序设计"}
{"Answer": "直接使用数组", "Konwledge_Point": "数据封装——结构体", "Question": ["问个关于jNI返回结构体的问题,请教一下a ", ["如果要返回两个值则", "\n[code=C/C++][/code]JNIEXPORT jobject JNICALL Java_com_sundy_jnidemo_CMFJ_getStruct", "\n(JNIEnv *env, jobject obj)", "\n{   ", "\n\n", "//获取Java中的实例类", "\njclass objectClass = (*env)-> FindClass(env,\"com/sundy/jnidemo/DiskInfo\");   ", "\n\n", "//获取Java中的构造函数", "\njmethodID init = (*env)->GetMethodID(env, objectClass , \"\", \"(Ljava/lang/String;I)V\");", "\n\n", "//调用构造函数创建对象，写入名字和序列号", "\njobject newObj = (*env)->NewObject(env, objectClass, init, (*env)->NewStringUTF(env, \"my name is D:\"), 10);", "\n\n", "//返回创建的对象", "\nreturn newObj;", "\n}   ", "\n\n", "那如果要返回四个则怎么写呢，我总是不出结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以参考下这篇文章&amp;#xff0c;希望对你有帮助&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/899719225136113.png\" /&gt;&lt;/p&gt;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/lina_acm/article/details/51162501\" id=\"textarea_1631522894696_1631522918921_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;数据结构&amp;#xff08;线性表子系统&amp;#xff1a;c实现&amp;#xff09;_2puT-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;#include#include//因为使用malloc动态空间#define N sizeof(node)//  结点定义typedef struct linknode{    char data;    struct linknode * next;}node,*linklist;node *head;   // 定义一个全局头指针//建表并且输入内容&amp;#xff0c;结束标记位‘#&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/lina_acm/article/details/51162501&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何用结构体描述单链表", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;问题主要是输入输出缓冲区残留字符的处理&amp;#xff0c;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include &amp;lt;conio.h&amp;gt; //getche()需要的头文件\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#define OK 1\n#define MVNum 100\ntypedef int OtherInfo;\ntypedef char VerTexType;\ntypedef struct ArcNode{\n    int adjvex;\n    struct ArcNode*nextarc;\n    OtherInfo info;\n}ArcNode;\n\ntypedef struct VNode{\nVerTexType data;\nArcNode*firstarc;\n}VNode,AdjList[MVNum];\n\ntypedef struct{\n    AdjList vertices;\n    int  vexnum,arcnum;\n}ALGraph;\n\nint LocateNode(ALGraph G,VerTexType v){\n    int i;\n    for(i&amp;#61;0;i&amp;lt;G.vexnum;i&amp;#43;&amp;#43;){\n        if(v&amp;#61;&amp;#61;G.vertices[i].data){\n            return i;\n        }\n    }\n    return 0;\n}\n\nint  CreateGraph(ALGraph *G){\n    printf(&amp;#34;------开始创建无向网------\\n&amp;#34;);\n    printf(&amp;#34;请输入顶点数和边数&amp;#xff1a;&amp;#34;);\n    fflush(stdout);rewind(stdin);\n    scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;G-&amp;gt;vexnum,&amp;amp;G-&amp;gt;arcnum);\n                                   //fflush(stdin);\n    int n;\n\nfor(n&amp;#61;0;n&amp;lt;G-&amp;gt;vexnum;n&amp;#43;&amp;#43;){\n    printf(&amp;#34;\\n请输入第%d个顶点&amp;#xff1a;&amp;#34;,n&amp;#43;1);\n    fflush(stdout);rewind(stdin);\n    G-&amp;gt;vertices[n].data&amp;#61;getchar();//G-&amp;gt;vertices[n].data&amp;#61;getche(); 改用getchar()更合理\n    G-&amp;gt;vertices[n].firstarc&amp;#61;NULL;\n }\n int i,j;\n for(n&amp;#61;0;n&amp;lt;G-&amp;gt;arcnum;n&amp;#43;&amp;#43;){\n    printf(&amp;#34;\\n请输入第%d条边关联的顶点和权值&amp;#xff0c;以空格间隔:&amp;#34;,n&amp;#43;1);\n    fflush(stdout);rewind(stdin);//fflush(stdin);\n    VerTexType v1,v2;\n    OtherInfo w;\n    scanf(&amp;#34;%c %c %d&amp;#34;,&amp;amp;v1,&amp;amp;v2,&amp;amp;w);\n    i&amp;#61;LocateNode(*G,v1);\n    j&amp;#61;LocateNode(*G,v2);\n    ArcNode *p1&amp;#61;(ArcNode *)malloc(sizeof(ArcNode));\n    p1-&amp;gt;adjvex&amp;#61;j;\n    p1-&amp;gt;info&amp;#61;w;\n    p1-&amp;gt;nextarc&amp;#61;G-&amp;gt;vertices[i].firstarc;\n    G-&amp;gt;vertices[i].firstarc&amp;#61;p1;\n    ArcNode *p2&amp;#61;(ArcNode *)malloc(sizeof(ArcNode));\n    p2-&amp;gt;adjvex&amp;#61;i;\n    p2-&amp;gt;info&amp;#61;w;\n    p2-&amp;gt;nextarc&amp;#61;G-&amp;gt;vertices[j].firstarc;\n    G-&amp;gt;vertices[j].firstarc&amp;#61;p2;\n\n }\n return 0;\n}\n\nint ShowGraph(ALGraph *G)\n    {int i;\n    for (i&amp;#61;0;i&amp;lt;G-&amp;gt;vexnum;i&amp;#43;&amp;#43;)\n    {\n        printf(&amp;#34;%d-&amp;gt;&amp;#34;,i&amp;#43;1);\n        while(1)\n        {\n            if(G-&amp;gt;vertices[i].firstarc&amp;#61;&amp;#61;NULL)\n            {\n                printf(&amp;#34;^&amp;#34;);\n                break;\n            }\n            printf(&amp;#34;%d-&amp;gt;&amp;#34;,G-&amp;gt;vertices[i].firstarc-&amp;gt;adjvex&amp;#43;1);\n            G-&amp;gt;vertices[i].firstarc&amp;#61;G-&amp;gt;vertices[i].firstarc-&amp;gt;nextarc;\n        }\n        printf(&amp;#34;\\n&amp;#34;);\n    }\n}\n\nint main()\n{\n    ALGraph *G;\n    CreateGraph(G);\n    ShowGraph(G);\n    \n    return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构 为什么我运行时输入后被强行退出", ["#include <stdio.h>", "\n#include <stdlib.h>", "\n#define OK 1", "\n#define MVNum 100", "\ntypedef int OtherInfo;", "\ntypedef char VerTexType;", "\ntypedef struct ArcNode{", "\n    int adjvex;", "\n    struct ArcNode*nextarc;", "\n    OtherInfo info;", "\n}ArcNode;", "\n\n", "typedef struct VNode{", "\nVerTexType data;", "\nArcNode*firstarc;", "\n}VNode,AdjList[MVNum];", "\n\n", "typedef struct{", "\n    AdjList vertices;", "\n    int  vexnum,arcnum;", "\n}ALGraph;", "\n\n", "int LocateNode(ALGraph G,VerTexType v){", "\n    int i;", "\n    for(i=0;i<G.vexnum;i++){", "\n        if(v==G.vertices[i].data){", "\n            return i;", "\n        }", "\n    }", "\n    return 0;", "\n}", "\n\n", "int  CreateGraph(ALGraph *G){", "\n    printf(\"------开始创建无向网------\\n\");", "\n    printf(\"请输入顶点数和边数：\");", "\n    scanf(\"%d %d\",&G->vexnum,&G->arcnum);", "\n    fflush(stdin);", "\n    int n;", "\n\n", "for(n=0;n<G->vexnum;n++){", "\n    printf(\"\\n请输入第%d个顶点：\",n+1);", "\n    G->vertices[n].data=getche();", "\n    G->vertices[n].firstarc=NULL;", "\n}", "\n int i,j;", "\n for(n=0;n<G->arcnum;n++){", "\n    printf(\"\\n请输入第%d条边关联的顶点和权值，以空格间隔:\",n+1);", "\n    fflush(stdin);", "\n    VerTexType v1,v2;", "\n    OtherInfo w;", "\n    scanf(\"%c %c %d\",&v1,&v2,&w);", "\n    i=LocateNode(*G,v1);", "\n    j=LocateNode(*G,v2);", "\n    ArcNode *p1=(ArcNode *)malloc(sizeof(ArcNode));", "\n    p1->adjvex=j;", "\n    p1->info=w;", "\n    p1->nextarc=G->vertices[i].firstarc;", "\n    G->vertices[i].firstarc=p1;", "\n    ArcNode *p2=(ArcNode *)malloc(sizeof(ArcNode));", "\n    p2->adjvex=i;", "\n    p2->info=w;", "\n    p2->nextarc=G->vertices[j].firstarc;", "\n    G->vertices[j].firstarc=p2;", "\n\n", " }", "\n return 0;", "\n}", "\n\n", "int ShowGraph(ALGraph *G)", "\n    {int i;", "\n    for (i=0;i<G->vexnum;i++)", "\n    {", "\n        printf(\"%d->\",i+1);", "\n        while(1)", "\n        {", "\n            if(G->vertices[i].firstarc==NULL)", "\n            {", "\n                printf(\"^\");", "\n                break;", "\n            }", "\n            printf(\"%d->\",G->vertices[i].firstarc->adjvex+1);", "\n            G->vertices[i].firstarc=G->vertices[i].firstarc->nextarc;", "\n        }", "\n        printf(\"\\n\");", "\n    }", "\n}", "\n\n", "int main()", "\n{", "\n    ALGraph *G;", "\n    CreateGraph(G);", "\n    ShowGraph(G);", "\n    return 0;", "\n}", "\n "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是的&amp;#xff0c;b&amp;#61;a&amp;#xff0c;b指向的结构体地址和a指向的结构体地址为同一个&amp;#xff0c;所以不管哪一个修改&amp;#xff0c;另一个都会变&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["有关结构体变量赋值的简单问题", ["这个输出a.name为什么是qian，之前被赋值为zhao，又经过b=a的原因吗？", "#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "struct stu", "{", "    char ", "name;", "    char g;", "    int score;", "};", "void main()", "{", "    struct stu a={NULL,'m',290},b;", "    a.name=(char", ")malloc(10);", "    strcpy(a.name,\"zhao\");", "    b=a;b.g='f';", "    b.score=350;", "    strcpy(b.name,\"qian\");", "    printf(\"%s%c%d\",a.name,a.g,a.score);", "}", "\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;比如你定义一个指针向量要这样&lt;br /&gt;int* p&lt;br /&gt;通过下面定义别名&lt;br /&gt;typedef *int t&lt;br /&gt;就可以到达&lt;br /&gt;t p;等价于int* p的作业&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体重命名带*号的问题", ["\n", "\n", "我的第一张图片的第二个结构体的*BSTree这个结构体名称应该生成的是指针变量吧，那么第二，三张图片的BSTree T和BSTree&T有什么区别呢?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;确认一下你的SQlist里面每个节点里的指针是否都正确分配空间了,如果没分配空间的话指针指向的是一个无效地址,无法进行访问修改操作&lt;br /&gt;然后确认一下i是否有越界&lt;br /&gt;建议贴一下完整代码&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言：结构体的输入问题", ["初学者，想问一下各位为什么我不能继续往下输入数据了，字符串输入要注意些什么东西呢", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;其实最高最低都算错了&lt;/p&gt;\n\n&lt;p&gt;if(min&amp;gt;s[i].score)&lt;/p&gt;\n\n&lt;p&gt;{&lt;!-- --&gt;&lt;/p&gt;\n\n&lt;p&gt;min&amp;#61;s[i].score; k&amp;#61;i;&lt;/p&gt;\n\n&lt;p&gt;}&lt;/p&gt;\n\n&lt;p&gt;这里少了大括号把两行代码包起来&amp;#xff0c;否则k&amp;#61;i每次循环都执行&amp;#xff0c;最后都是最后一条记录。max的地方也一样&amp;#xff0c;只不过巧合的是最后一条刚好是最大值而已&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;好用请点击采纳支持&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言使用结构体求最高分的学生和最低分的学生", [" ", "\n\n", "\n#include<stdio.h>\n\tstruct Student\n\t{int num;\n\tchar name[20];\n\tfloat score;\n\t};\n\t\n\tint main()\n{\t\n\tint i,k;\n\tstruct Student s[5];\n\tfloat aver,max=s[0].score,min=s[0].score,sum=0.0;\n\tfor(i=0;i<5;i++)\n\tscanf(\"%d %s %f\",&s[i].num,s[i].name,&s[i].score);\n\tfor(i=0;i<5;i++)\n\t{\n\t    if(max<s[i].score)\n\t    max=s[i].score;\n\t    k=i;\n\t}\n\tprintf(\"最高分为：%d %s %f\\n\",s[k].num,s[k].name,max);\n\tfor(i=0;i<5;i++)\n\t{\n\t\tif(min>s[i].score)\n\t\tmin=s[i].score;\n\t\tk=i;\n\t}\n\tprintf(\"最低分为：%d %s %f\\n\",s[k].num,s[k].name,min);\n\tfor(i=0;i<5;i++)\n\t{sum=sum+s[i].score;}\n\taver=sum/5;\n\tprintf(\"平均分为：%f\\n\",aver); \n\treturn 0;\n}", "\n\n", "C语言初学者", "\n\n", "能帮我看看哪里出错了嘛QAQ", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是数组传递&amp;#xff0c;数组相当于指针&amp;#xff0c;所以可以修改&lt;br /&gt;如果只是传递结构变量&amp;#xff0c;那么不可以修改&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体值传递传入函数为什么可以改变实参？", ["struct hero", "{    string name;    int age;    string sex;};", "//冒泡排序", "void bubbleSort(hero arr[] , int len)", "{    for (int i = 0; i < len - 1; i++)", "       {        for (int j = 0; j < len - 1 - i; j++)", "               {            if (arr[j].age > arr[j + 1].age)", "                                               {    hero temp = arr[j];", "                                                         arr[j] = arr[j + 1];", "                                                         arr[j + 1] = temp;", "                                               }", "                       }", "        }", "}", "//打印数组", "void printHeros(hero arr[], int len)", "{    for (int i = 0; i < len; i++)", "       {        cout << \"姓名： \" << arr[i].name << \" 性别： \" << arr[i].sex << \" 年龄： \" << arr[i].age << endl;", "       }", "}", "\n", "int main()", " {", "struct hero arr[5] =    {        {\"刘备\",23,\"男\"},", "                                                        {\"关羽\",22,\"男\"},", "                                                        {\"张飞\",20,\"男\"},", "                                                        {\"赵云\",21,\"男\"},", "                                                        {\"貂蝉\",19,\"女\"},", "                                        };", "int len = sizeof(arr) / sizeof(hero); //获取数组元素个数    bubbleSort(arr, len); //排序", "printHeros(arr, len); //打印", "system(\"pause\");", "return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "```\r\nprintf(\"%p\",stu);\r\n打印结构体的首地址，因为stu指向结构体指针开头。也就是a的地址\r\n\r\nprintf(\"%p\",&amp;stu);\r\n打印的是结构体指针的地址\r\n\r\n对于数组\r\na 和 &amp;a 以及 &amp;a[0] 都是一样的。\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["关于c语言结构体指针的一个疑惑，请大神解释一下。", ["在学结构体指针的时候发现了一个问题。", "\n\n", "struct student{\n    int a;\n    int b;\n    int c;\n}stu={1,2,3},*p=&stu;\n", "\n\n", "第一个问题，&stu 这个结构体变量的地址 和 &stu.a是一样的；", "\n\n", "printf(\"%p\",stu);\n", "\n\n", "结构体stu变量的值，也就是stu里面存的什么地址？？", "\n比如定义一个数组，int a[10]  ", "\n\n", "printf(\"%p\",a);\nprintf(\"%p\",&a);\n", "\n\n", "a的值和&a的地址都是一样的；", "\n可是在结构体变量中，stu和&stu 不一样的地址；", "\n\n", "我测试了一下。", "\n\n", "struct student{\nint a;\nint b;\nint c;\n}stu{1,2,3};\nint *p;\nprintf(\"%p\",stu);  //输出stu的值；\nscanf(\"%p\",&p); //把上面输出的stu的值写入；\nprintf(\"%d\",*p); //这里可以输出 stu.1也就是 a的值；\n", "\n\n", "可是stu 和 &stu所输出的地址不一样，难道结构体在内存中在两处存放吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof的用法:&lt;br /&gt;sizeof是计算对象所占的字节个数&amp;#xff0c;通常用来查看变量或结构体等所占的字节个数。比如&amp;#xff1a;int a;sizeof(a); // 计算变量a所占的字节数&amp;#xff0c;等价于sizeof(int) struct{ int num; char name; int age;}person;sizeof(person); // 计算整个结构所占的字节总数&lt;br /&gt;采纳下&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Qt/C++如何获取动态数组的长度？", ["Qt/C++如何获取动态数组的长度", "\n", "问题相关代码", "\n", "    IHxUserService ql;\n    ST_USER* z;      ", "//结构体数组", "\n    z = ql.queryUser", "(\"user_id>905\")", ";\n    qDebug", "()", "<<sizeof", "(*z)", ";\n    qDebug", "()", "<<sizeof", "(z)", ";\n    qDebug", "()", "<<sizeof", "(ST_USER)", ";\n    qDebug", "()", "<<_msize", "(z)", ";\n", "\n", "运行结果", "\n", "nRow", " ", "7", "\n", "56", "\n", "4", "\n", "56", "\n", "4294967295", "\n", "\n", "上面结构体数组应该为7，但是好像求不出来，请问有没有什么好的方法"]], "Tag": "程序设计"}
{"Answer": "printf(\"%5s:%d\\n\",(p++)-&gt;name,(p++)-&gt;num);\r\n-&gt;\r\nprintf(\"%5s:%d\\n\",p-&gt;name,p-&gt;num);\r\np++;\r\n先输出，然后再移动指针。", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言：有三个学生信息，放在结构体中，要求输出全部学生信息。这段代码错哪啦？", ["有三个学生信息abc，放在结构体中，要求从分数小到大输出全部学生信息。这段代码错哪啦？", "\n\n", "#include <stdio.h>\n#include <string.h>\n# define n 3\nstruct Student{\n    int num;\n    char name[20];\n} ;\nint main()\n{\n    struct Student stu[3]={3,\"a\",2,\"b\",1,\"c\"};\n        struct Student *p;\n    p=stu;\n    int i,j,k;\n    struct Student temp;\n    for(i=0;i<n-1;i++)\n    {k=i;\n    for(j=1+i;j<n;j++)\n    {\n        if(stu[j].num<stu[k].num)k=j;}\n    {temp=stu[k];stu[k]=stu[i];stu[i]=temp;}\n    }\nwhile(p<stu+3)\n    printf(\"%5s:%d\\n\",(p++)->name,(p++)->num);\n    return 0;\n}\n", "\n\n", "结果是", "\nc:1", "\na:3", "\n然而把while改成", "\nfor(p=stu;p\nprintf(\"%5s:%d\\n\",p->name,p->num);", "\n就正确了", "\n为什么？两种写法不是等价的吗"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *name,&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; *t)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//字符串要传地址&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t%s\\t&amp;#34;&lt;/span&gt;,num,name);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f\\t&amp;#34;&lt;/span&gt;,*(t&amp;#43;i));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; b[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;],*p;\n    p&amp;#61;b;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;abc&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n        &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//字符串用数组&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; g[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    }a;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a;\\t姓名&amp;#xff1a;\\t语文&amp;#xff1a;\\t数学&amp;#xff1a;\\t英语&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%s&amp;#34;&lt;/span&gt;,&amp;amp;a.num,a.name);&lt;span class=\"hljs-comment\"&gt;//字符串不需要加&amp;amp;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f&amp;#34;&lt;/span&gt;,&amp;amp;a.g[j]);\n            b[j]&amp;#61;a.g[j];\n        }\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(a.num,a.name,p);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言 结构体 程序，有问题，运行没有结果。", ["//程序有问题", "\n", "/*编写一个函数print，输出若干位学生的数据记录，有5位学生，每一位学生的数据记录包括学号（num），姓名（name），三门课的成绩（g[3]），\n要求用主函数输入这些记录，用print函数输出这些记录。请编程实现。*/", "            \n", "#", "include", "<stdio.h>", "\n", "void", " ", "print", "(", "int", " num,", "char", " name,", "float", " *t)", "\n", "{\n    ", "int", " i;\n    ", "printf", "(", "\"%d\\t%s\\t\"", ",num,name);\n    ", "for", "(i=", "0", ";i<", "3", ";i++)\n        ", "printf", "(", "\"%f\\t\"", ",*(t+i));\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " i,j;\n    ", "float", " b[", "3", "],*p;\n    p=b;\n    ", "struct", " ", "abc", "\n    {\n        ", "int", " num;\n        ", "char", " name;\n        ", "float", " g[", "3", "];\n    }a;\n    ", "for", "(i=", "0", ";i<", "5", ";i++)\n    {\n        ", "printf", "(", "\"学号：\\t姓名：\\t语文：\\t数学：\\t英语：\\n\"", ");\n        ", "scanf", "(", "\"%d%s\"", ",&a.num,&a.name);\n        ", "for", "(j=", "0", ";j<", "3", ";j++)\n        {\n            ", "scanf", "(", "\"%f\"", ",&a.g[j]);\n            b[j]=a.g[j];\n        }\n        ", "print", "(a.num,a.name,p);\n    }\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "cout &lt;&lt; (i + 1) &lt;&lt; \".  \" &lt;&lt; Book[i].ID &lt;&lt; \"     \" &lt;&lt; Book[i].title; \r\n \r\n 还有你的这一行，若果进来，因为你的Book[i].title此时指向的是NULL，所以输出肯定蹦...", "Konwledge_Point": "数据封装——结构体", "Question": ["c++代码错误，求教（结构体，动态分配）", [" #include<string>\n#include<iostream>\n//#include<stdlib.h>\nusing namespace std;\nstruct book\n{\n    int ID;\n    char* title ;\n    int status;\n};\n\nvoid getCmdNum(const char *cmd,char *cmd1, char *cmd2);\n\nint bookCounter = 0;\nbook *Book;\nbook *tempBook;\n\nint main()\n{\n    string cmd;\n\n\n    char* cmd_1;\n    char* cmd_2;\n    char* cmd_3;\n    do\n    {\n        cout << \">>\";\n        getline(cin, cmd);\n        cmd_1 = strtok((char*)cmd.data(), \" \");\n        cmd_2 = strtok(NULL, \" \");\n        cmd_3 = strtok(NULL, \" \");\n        getCmdNum((const char*)cmd_1, cmd_2, cmd_3);\n    } while (1);\n}\n\nvoid getCmdNum(const char* cmd,char* cmd1,char* cmd2)\n{\n    if (!strcmp(cmd,\"addbook\"))\n    {\n        tempBook = new book[bookCounter];\n        for (int i = 0; i < bookCounter; i++)\n        {\n            tempBook[i] = Book[i];\n        }\n        Book = new book[bookCounter+1];\n        for (int i = 0; i < bookCounter;i++)\n        {\n            Book[i] = tempBook[i];\n        }\n\n        long ID = atol(cmd1);\n        Book[bookCounter].ID = ID;\n        Book[bookCounter].title = cmd2;\n        bookCounter++;\n    }\n    if (!strcmp(cmd, \"listbook\"))\n    {\n        for (int i = 0; i < bookCounter; i++)\n        {\n            cout << (i + 1) << \".  \" << Book[i].ID << \"     \" << Book[i].title;\n            if (Book[i].status != 1)\n                cout << \"     on shelf\" << endl;\n            else\n                cout << \"     borrowed\" << endl;\n        }\n    }\n}\n", "\n\n", "在运行的时候先addbook 在listbook然后book[].title会重叠出错，不知道是为什么。", "\n输入格式为", "\n\n", "\n", "\n", "addbook book[].ID book[].title", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "可以的。\r\nstruct MyStruct node;\r\n\tint x = 1;\r\n\tfloat y = 0.15f;\r\n\r\n\tnode.data = &amp;x;\r\n\tnode.next = NULL;\r\n\tprintf(\"%d\\n\", *((int*)node.data));\r\n\tnode.data = &amp;y;\r\n\tnode.next = NULL;\r\n\r\n\tprintf(\"%.2f\\n\", *((float*)node.data));\r\n\t\r\n\t//再加个data存放结构指针的例子\r\n\tnode1.data = &amp;node;\r\n\tnode1.next = NULL;\r\n\tprintf(\"%.2f\", *(float*)(((struct MyStruct*)node1.data)-&gt;data));\r\n\t\r\n\tvoid*代表的是通用型指针，你可以将指向任何类型的指针存放进去，但是取出来的时候必须注意要先转换成对应的指针，再取值就可以了，比如上面先将第一个指针转换成指向整数的指针，然后再取值", "Konwledge_Point": "数据封装——结构体", "Question": ["【C语言】能不能做出保存任意类型的结构体类型", ["struct ListItem\n{\n    void *data;\n    struct ListItem *NEXTITEM;\n}；\n", "\n\n", "想试试看C能不能做出类似Python中列表一样，可以保存不同类型的数据类型，像这样定义一个结构体", "\n\n", "struct ListItem item[3];\n\nitem[0].data = 666;\nitem[0].NEXTITEM = NULL;\n\nitem[1].data = \"cool\";\nitem[0].NEXTITEM = &item[1];\n\nfloat tempFloat = 1.66;\nitem[2].data = &tempFloat;\nitem[1].NEXTITEM = &item[2];\nitem[2].NEXTITEM = NULL;\n", "\n\n", "类似这样传入数值,整形和字符串都可以正常输出,为什么浮点类型输出来就是0.0000?", "\n已经很久没有碰过C语言了,如果有大佬知道,万分感谢..."]], "Tag": "程序设计"}
{"Answer": "这篇文章&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/qq_44757034/article/details/104543701\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;C语言结构体数组&amp;#xff0c;结构体数组的定义&amp;#xff0c;结构体数组的输出&amp;#xff0c;结构体的应用&lt;/font&gt;&lt;/a&gt; 也许有你想要的答案&amp;#xff0c;你可以看看", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言：使用实例化的结构体定义数组时出错，如何解决？", ["问题遇到的现象和发生背景", "\n", "本人在编写二叉树代码时需要对决定树结点的结构体实例化，同时需要用实例化的结构体去定义一个结构体数组，用来存放结点。结果在编译时遇到了错误。", "\n", "问题相关代码，请勿粘贴截图", "\n", "typedef", " ", "struct", " ", "Treenode", "\n{\n    ", "char", " data;\n    ", "int", " parent;\n}PTNode;\n", "struct", " ", "Treenode", " treenode = {", "'#'", ",", "1", "};\n", "typedef", " ", "struct", "\n{\n    treenode nodes[MaxSize];\n    ", "int", " n;\n}PTree;\n", "\n", "运行结果及报错内容", "\n", "无法运行。", "报错内容如下：", "\n", "||=== Build: Debug in binarytree (compiler: GNU GCC Compiler) ===|\n", "error: ", "expected specifier-qualifier-list before 'treenode'\n", "error: ", "'PTree' {aka 'struct <anonymous>'} has no member named 'n'\n", "error: ", "'PTree' {aka 'struct <anonymous>'} has no member named 'nodes'\n", "error: ", "'PTree' {aka 'struct <anonymous>'} has no member named 'nodes'\n", "error: ", "'PTree' {aka 'struct <anonymous>'} has no member named 'nodes'\n", "error: ", "'PTree' {aka 'struct <anonymous>'} has no member named 'nodes'\n\n||=== Build failed: 6 error(s), 1 warning(s) (0 minute(s), 0 second(s)) ===|\n", "\n", "我的解答思路和尝试过的方法", "\n", "使用for循环对结构体数组初始化赋值。（编译成功，代码运行结果正确）", "\n", "\n", "我想要达到的结果", "\n", "不使用for循环对 nodes[MaxSize] 中的每个结构体进行赋值，能否直接用实例化的结构体定义 nodes[MaxSize] 数组？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;printf(&amp;#34;%s&amp;#34;, c)按字符数组名c找到其数组起始地址&amp;#xff0c;然后逐个输出其中的字符&amp;#xff0c;直到遇到&amp;#39;\\0&amp;#39;为止&amp;#xff0c;并不是看字符数组有多长就输出多少&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体指针问题", ["\n", "\n", "#", "include", " ", "<stdio.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "struct", " ", "stru", "\n    {\n        ", "short", " m;\n        ", "int", " n;\n        ", "char", " s[", "4", "];\n    } a,* p;\n\n    p = &a;\n    a.m = ", "123", ";\n    a.n = ", "456", ";\n    a.s[", "0", "] = ", "65", ";    a.s[", "1", "] = ", "66", ";    a.s[", "2", "] = ", "67", ";    a.s[", "3", "] = ", "68", ";\n\n    ", "printf", "(", "\"%d,%d,%s\\n\"", ", (*p).m, (*p).n,(*p).s);\n    \n    ", "return", " ", "0", ";\n}\n", "\n", "不知道为什么指针指向这片空间会超出s的范围。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ptbs head&amp;#61;(struct pbs*)malloc(sizeof(pbs)); //显示此处错误  这行修改为&amp;#xff1a;ptbs head&amp;#61;(struct pbs*)malloc(sizeof(struct pbs));&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["对结构体指针重命名，为什么老是显示未申请？", ["typedef struct pif", "{", "    char name[20];", "    char num[12];", "    char qq[15];", "    char email[20];", "}bs;", "\n", "typedef struct pbs", "{", "    bs data;", "    struct pbs *next;", "}*ptbs;", "\n", "ptbs head=(struct pbs*)malloc(sizeof(pbs));     //显示此处错误", "\n", "error :  'pbs'  undeclared  here  ( not in a function  )", "我已经定义了pbs,为什么此处还是显示未声明？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;I'll do my best to answer the question I think you're asking.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=\"https://golang.org/doc/effective_go.html#embedding\" rel=\"nofollow noreferrer\"&gt;documentation&lt;/a&gt; on embedding explains the behavior you're seeing,&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;There's an important way in which embedding differs from subclassing.\n  When we embed a type, the methods of that type become methods of the\n  outer type, but when they are invoked the receiver of the method is\n  the inner type, not the outer one.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This explains how a &lt;code&gt;Vodka&lt;/code&gt; struct, which embeds struct &lt;code&gt;BaseAttributes&lt;/code&gt; which implements all of the methods in &lt;code&gt;BarStocks&lt;/code&gt; is able to satisfy the interface &lt;code&gt;Barstocks&lt;/code&gt;. This excerpt, however, does not explain how we effectively override &lt;code&gt;GetVodka()&lt;/code&gt; for our &lt;code&gt;Vodka&lt;/code&gt; struct.&lt;/p&gt;\n\n&lt;p&gt;To understand this we need to read another excerpt from the documentation.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Embedding types introduces the problem of name conflicts but the rules\n  to resolve them are simple. First, a field or method X hides any other\n  item X in a more deeply nested part of the type.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;This excerpt explains that If &lt;code&gt;Vodka&lt;/code&gt; implements &lt;code&gt;GetVodka()&lt;/code&gt; and embeds a struct (&lt;code&gt;BaseAttributes)&lt;/code&gt; which also implements &lt;code&gt;GetVodka()&lt;/code&gt;, the outer-most definition is the one that takes precedence.&lt;/p&gt;\n\n&lt;p&gt;The combination of these behaviors explain how &lt;code&gt;Vodka&lt;/code&gt; satisfies the &lt;code&gt;BarStocks&lt;/code&gt; interface and has the behavior you see in the example code.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["GoLang的类型转换到由结构体和嵌入式结构体实现的接口的工作方式", ["\n\n", "I recently came across a code that is doing something I don't understand.", "\n\n", "There are multiple structs having the same embedded struct and an interface that defines methods returning pointer to each struct. This interface is implemented by the embedded struct but only 'partially' by the individual structs, as such, each struct only implements the method where the pointer to that struct is returned.", "\n\n", "For better understanding, here is the representative code:", "\n\n", "type BarStocks interface {\n    GetVodka() *Vodka\n    GetMartini() *Martini\n    GetBourbon() *Bourbon\n    GetNegroni() *Negroni\n    GetManhattan() *Manhattan\n}\n\ntype BaseAttributes struct {\n    ID        uuid.UUID\n    Quantity float64\n    CreatedAt time.Time\n    UpdatedAt time.Time\n}\n\nfunc (e *BaseAttributes) GetVodka() *Vodka {\n    return nil\n}\n\nfunc (e *BaseAttributes) GetMartini() *Martini {\n    return nil\n}\n\nfunc (e *BaseAttributes) GetBourbon() *Bourbon {\n    return nil\n}\n\nfunc (e *BaseAttributes) GetNegroni() *Negroni {\n    return nil\n}\n\nfunc (e *BaseAttributes) GetManhattan() *Manhattan {\n    return nil\n}\n", "\n\n", "And then each individual struct implements only the method where its pointer is returned, for example:", "\n\n", "type Vodka struct {\n    BaseAttributes\n\n    Label string\n}\n\nfunc (v *Vodka) GetVodka() *Vodka {\n    return v\n}\n", "\n\n", "Now in the code, this setup is used to typecast the individual struct to the interface as a pointer, something like this:", "\n\n", "func someFunc() BarStocks {\n    v := Vodka{}\n    return &v\n}\n", "\n\n", "Now I am not too deep into Go yet and so unable to comprehend how the pointer to the struct becomes the same type as the interface.", "\n\n", "Thanks in advance for any insight into this.", "\n    "]], "Tag": "程序设计"}
{"Answer": "#include &lt;stdio.h&gt;\r\n#include &lt;string.h&gt;\r\n\r\n/*结构体定义*/\r\nstruct stdTmp{\r\n    char user[16];          //用户名\r\n    char pasd[16];          //密码\r\n    unsigned char age;      //年龄\r\n};\r\n\r\n/*\r\n    函数名称：std_write\r\n    函数功能：将结构体，写入文件\r\n    传入参数：\r\n                const char *_file_path      文件路径\r\n                const struct stdTmp *_std   要写入的结构体\r\n    传出数据：\r\n                 0  运行成功\r\n                -1  输入参数有误\r\n                -2  打开文件失败\r\n                -3  文件写入数据失败\r\n    注意事项：如果结构体过大的话，建议修改\"写入结构体\"区域，分片写入\r\n    编写人员：voidar\r\n    编写时间：2016-11-07\r\n*/\r\nint std_write(const char *_file_path, const struct stdTmp *_std){\r\n    FILE *fp = (FILE *)0x00;    //文件操作\r\n    \r\n    /*参数校验*/\r\n    if(!_file_path || !strlen(_file_path) || !_std) return -0x01;\r\n    \r\n    /*打开文件*/\r\n    if( !(fp = fopen(_file_path, \"wb+\")) ) return -0x02;\r\n    \r\n    /*写入结构体*/\r\n    if(fwrite((const void *)_std, sizeof(struct stdTmp), 0x01, fp) != 0x01) { fclose(fp); return -0x03; }\r\n    if(fflush(fp)){ fclose(fp); return -0x04; }\r\n    \r\n    /*关闭文件*/\r\n    fclose(fp);\r\n    \r\n    return 0x00;\r\n}\r\n\r\n/*\r\n    函数名称：std_read\r\n    函数功能：从文件中读取结构体\r\n    传入参数：\r\n                const char *_file_path      文件路径\r\n                struct stdTmp *_std         读取到的结构体体存储到该指针指向的结构体中\r\n    传出数据：\r\n                 0  运行成功\r\n                -1  输入参数有误\r\n                -2  打开文件失败\r\n                -3  文件内容有误(长度不合法)\r\n    注意事项：无\r\n    编写人员：voidar\r\n    编写时间：2016-11-07\r\n*/\r\nint std_read(const char *_file_path, struct stdTmp *_std){\r\n    FILE *fp = (FILE *)0x00;    //文件操作\r\n\r\n    /*参数校验*/\r\n    if(!_file_path || !strlen(_file_path) || !_std) return -0x01;\r\n    \r\n    /*打开文件*/\r\n    if( !(fp = fopen(_file_path, \"rb+\")) ) return -0x02;\r\n    \r\n    /*读取文件*/\r\n    if(fread((void *)_std, sizeof(struct stdTmp), 0x01, fp) != 0x01){ fclose(fp); return -0x03; }\r\n    \r\n    /*关闭文件*/\r\n    fclose(fp);\r\n    \r\n    return 0x00;\r\n}\r\n\r\nint main(){\r\n    int err = 0x00;\r\n    struct stdTmp mystd = {\"admin\", \"123456\", 12};\r\n    struct stdTmp getstd;\r\n    \r\n    /*写入结构体*/\r\n    if(err = std_write(\"stdFile.txt\", &amp;mystd)){ printf(\"write error：%d\\n\", err); return err; }\r\n\r\n    /*读取结构体*/\r\n    if(err = std_read(\"stdFile.txt\", &amp;getstd)){ printf(\"read error：%d\\n\", err); return err; }\r\n\r\n    /*显示获取到的数据*/\r\n    printf(\r\n        \"用户名:%s\\n密码：%s\\n年龄：%d\\n\",\r\n        getstd.user,\r\n        getstd.pasd,\r\n        getstd.age\r\n    );\r\n}", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言中，有没有办法让数组（结构体）数据保存到一个文本文档或者是其他的什么的里面", ["一个可以做到让机器读取玩这个文件内容后自动获取了这个数组的数据的方法。"]], "Tag": "程序设计"}
{"Answer": "加一个无惨构造函数\r\n\r\n\r\n```\r\n ListNode(){}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["c++声明结构体指针变量提示没有构造函数错误", ["##在OJ中做题", "\n###题目描述", "\n输入一个链表，从尾到头打印链表每个节点的值。", "\n\n", "我的代码：", "\n\n", "\n//  struct ListNode {\n//        int val;\n//        struct ListNode *next;\n//        ListNode(int x) :\n//              val(x), next(NULL) {\n//        }\n//  };\n\nclass Solution {\npublic:\n    vector<int> printListFromTailToHead(struct ListNode* head) {\n        struct ListNode* p1, p2;\n        p1 = head;\n        p1->next = NULL;\n        p2 = p1->next, p2->next = p1;\n        p1 = p2;\n        while(p1->next != NULL) {\n            p2 = p1->next;\n            p2->next = p1;\n            p1 = p2;\n        }\n        //现在p1指向新链表头\n        vector<int> out;\n        int i = 0;\n        while(p1 != NULL) {\n            out[i++] = p1->val;\n            p1 = p1->next;\n        }\n    }\n};\n\n", "\n\n", "我想先反转链表再顺序输出，可是结构体变量声明那一行提示没有构造函数错误（去掉结构体定义的注释号提示结构体重复定义，所以我认为结构体在后台已经定义过了）", "\n错误信息：", "\n编译错误:您提交的代码无法完成编译", "\n\n", "In file included from main.cc:2:", "\n./solution.h:13:30: error: no matching constructor for initialization of 'struct ListNode'", "\nstruct ListNode* p1, p2;", "\n^", "\n../../include/tools.h:115:2: note: candidate constructor not viable: requires single argument 'x', but no arguments were provided", "\nListNode(int x) :", "\n^", "\n../../include/tools.h:112:8: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 0 were provided", "\nstruct ListNode {", "\n^", "\n../../include/tools.h:112:8: note: candidate constructor (the implicit move constructor) not viable: requires 1 argument, but 0 were provided", "\n1 error generated.", "\n提交运行"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if ((err &amp;#61; fopen_s(&amp;amp;fp, filename, &amp;#34;wt&amp;#43;&amp;#34;)) !&amp;#61; 0)&lt;br /&gt;打开方式改为&amp;#34;r&amp;#34;试试。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言读取TXT文件数据到结构体数组，结果均为0", ["自定义函数read的目的是读取TXT文本文件中的结构化数据，数据截图如下:", "\n", "因此定义对应的结构体，代码如下：", "\n", "struct point\n{\n    int fid", ";", "\n    int orig_fid", ";", "\n    double x", ";", "\n    double y", ";", "\n}", ";", "\n", "\n", "声明结构体数组：", "\n", "struct", " ", "point", " pt[", "9", "];\n", "\n", "自定义函数read的代码如下：", "\n", "int", " read", "()", "\n{\n    ", "int", " num", "[", "99", "]", ";\n    ", "char", " filename", "[", "10", "]", ";\n    errno_t err;\n    printf(", "\"请输入文件名：\\n\"", ");\n    scanf", "_s(", "\"%s\"", ", ", "filename", ", 10)", ";\n    FILE *fp;\n    ", "if", " ((err = fopen", "_s(&", "fp", ", ", "filename", ", ", "\"wt+\"", ")", ") != ", "0", ")    \n    {\n        printf(", "\"无法打开此文件\\n\"", ");            ", "//如果打不开，就输出打不开", "\n        exit(", "0", ");                               ", "//终止程序", "\n    }\n    ", "else", "\n    {\n        ", "for", " (", "int", " i = ", "0", "; i < ", "9", "; i++)\n        {\n            fscanf", "_s(", "fp", ", ", "\"%d;%d;%lf;%lf\\n\"", ", &", "pt", "[", "i", "].", "fid", ", &", "pt", "[", "i", "].", "orig_fid", ", &", "pt", "[", "i", "].", "x", ", &", "pt", "[", "i", "].", "y", ")", ";\n            printf(", "\"%d,%d,%lf,%lf\\n\"", ", pt", "[", "i", "]", ".fid, pt", "[", "i", "]", ".orig_fid, pt", "[", "i", "]", ".x, pt", "[", "i", "]", ".y);\n        }\n    }\n    fclose(fp);\n    ", "//char fgets(point *buf,int size,FILE *fp);", "\n    return ", "0", ";\n}\n", "\n", "调用自定义函数的主函数如下：", "\n", "int", " ", "main", "()", "\n", "{\n    ", "//int D;", "\n    ", "read", "();\n    ", "return", " ", "0", ";\n}\n", "\n", "程序运行结果如下：", "\n", "我的问题是，为什么不能显示原本数据文件中的数据？", "（注：程序运行软件为vs2019）"]], "Tag": "程序设计"}
{"Answer": "其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。\r\n既然能保证成绩都不相同，而成绩在0-100之间，那么学生人数应该最大不超过101\r\n你数组搞小一点（102就可以了）看看。\r\n\r\n另外\r\n\r\n```\r\n    for (i = 1; i &lt;= n; i++) {\r\n        cin &gt;&gt; s[i] &gt;&gt; num[i] &gt;&gt; grade[i];\r\n        cout &lt;&lt; endl; //这里的cout似乎没用，去掉\r\n    }//依次输入学生信息\r\n```\r\n# 问题解决的话，请点下`采纳`", "Konwledge_Point": "数据封装——结构体", "Question": ["PAT乙级1004不使用结构体时全测试点格式错误", ["初学者,因为无法独自解决此问题,所以想请教一下各位大大", "\n\n", "之前有看过论坛里面一些大大写的此题的代码,但是最后的cout语句基本是一样的", "\n\n", "所以不太明白格式错误是什么问题导致的...", "\n\n", "代码如下(C++语言,提交时编译器为C++(g++)),提交时没有加入注释内容", "\n\n", "#include<string>\n#include<iostream>\nusing namespace std;\nint main(void)\n{\n    int n, i, j, max,min;\n    string s[10000];//因为题目只提及n＞0\n    string num[10000];//所以声明了较大的数组\n    int grade[10000];\n    cin >> n;//输入学生数量\n    for (i = 1; i <= n; i++) {\n        cin >> s[i] >> num[i] >> grade[i];\n        cout << endl;\n    }//依次输入学生信息\n\n    max = min = 1;\n    for (j = 1; j <= n; j++) {\n        if (grade[j] > grade[max]) \n            max = j;\n        if (grade[j] < grade[min])\n            min = j;\n    }//比较成绩的高低\n\n    cout << s[max] << \" \" << num[max] << endl;//最高\n    cout << s[min] << \" \" << num[min] << endl;//最低\n    return 0;\n}\n", "\n\n", "\n\n", "在上面的代码里我并没有使用结构体,这道题是一定要用结构体的吗?", "\n\n", "另外还看到有的大大没有在输出最低成绩的行末尾加endl,我尝试之后也是一样的格式错误结果...", "\norz", "\n\n", "参考过其他大大的文章:", "\n\n", "PAT乙级1004-作者strivinging", "\n\n", "PAT 1004成绩排序（解决部分正确的原因）-作者linluoluo", "\n\n", "PAT 1004 成绩排名 （20 分）-fyy_lufan", "(主要还是看了这位大大的文章才考虑不用结构体)", "\n\n", "提前感谢各位大大的解答!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体中的冒号表示位域。&lt;/p&gt;\n&lt;p&gt;位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节&amp;#xff0c;同时也是为了节省存储空间和方便处理。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;color&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int16_t&lt;/span&gt; blue :&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; ;  &lt;span class=\"hljs-comment\"&gt;//表示blue只占1比特(1bit)&lt;/span&gt;\n  &lt;span class=\"hljs-type\"&gt;int16_t&lt;/span&gt; red :&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; ;   &lt;span class=\"hljs-comment\"&gt;//表示red 只占3比特(3bit)&lt;/span&gt;\n}\n&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;个变量共用&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;个字节\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体中的 ：是什么意思？", ["struct color{", "  int16_t blue :1 ;", " int16_t red :3 ;", "}", "调试也不报错，这其中有什么含义吗，我C语言学了好久也没见过，求大佬解惑"]], "Tag": "程序设计"}
{"Answer": "绝对不可以。数组作为结构体成员，结构体已经初始化了，成员也已经初始化了，这是初始化的语法，不是赋值的语法。", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言,对结构体中的整型数组进行赋值.....", ["c语言中,在结构体里声明整型数组,想对整型数组赋值,只能用循环吗?如果我想这样呢.....", "\ntypedef struct Data", "\n{", "\n                int arr[10];", "\n}Data;", "\nint main()", "\n{", "\n    Data ", "data;", "\n    data = (Data", ")malloc(sizeof(Data));", "\n    data->arr[10]={1,3,2,4,5,6,7,8,9,0};", "\n\n", ".", "\n...", "\n... ...", "\n}", "\n\n", "这样可以吗?"]], "Tag": "程序设计"}
{"Answer": "你的p指针指向的内存已经释放了。test是个局部变量，函数返回的时候内存就回收了", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言一个结构体指针的问题", ["我用一个子函数初始化了一个结构体并返回结构体的地址，但是却发现在主函数中输出的num和str字符串和子函数中输出的不一样，主函数中输出的内容更像是一些乱码，但是两个函数中的地址是一致的，这是哪儿出现什么问题了吗？", "\n\n", "代码如下，大家可以测试一下（这个代码并没有实际意义，就是在练习结构体时候瞎写的）", "\n\n", " #include <stdio.h>\n\nstruct Test\n{\n    int num;\n    char str[20];\n};\n\nstruct Test * function();\n\nint main()\n{\n    struct Test *p = function();\n\n    printf(\"address : %p\\n\", p);\n\n    printf(\"num = %d\\n\", p->num);\n    printf(\"str = %s\\n\", p->str);\n}\n\nstruct Test * function()\n{\n\n    struct Test test =\n    {\n        10,\n        \"hello world\"\n    };\n\n    struct Test *p = &test;\n\n    printf(\"num = %d\\n\", p->num);\n    printf(\"str = %s\\n\", p->str);\n\n    printf(\"address : %p\\n\", p);\n\n    return p;\n}\n\n", "\n\n", "附上运行结果图：", "\n第一行是子函数中的num", "\n第二行是子函数中的str", "\n第三行是子函数中返回的地址", "\n第四行是主函数中接收到的地址", "\n第五行是主函数中的num", "\n第六行是主函数中的str"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;//将下文中八卦的有关内容(结构体数组)以文本方式存储到sign.txt 文件中,读取文中的内容输出。\n\n#include&amp;lt;stdio.h&amp;gt;\n\n#include&amp;lt;stdlib.h&amp;gt;\n\n#define size 8\n\nstruct Yi\n\n{\n  int  no;\n\n  char name[4];\n\n  char xiang[64];\n\n}Y[8]&amp;#61;{&lt;!-- --&gt;{1,&amp;#34;乾&amp;#34;,&amp;#34;天行健&amp;#xff0c;君子以自强不息&amp;#34;},\n      {29,&amp;#34;坎&amp;#34;,&amp;#34;水洊至&amp;#xff0c;习坎。君子以常德行习教事&amp;#34;},\n      {52,&amp;#34;艮&amp;#34;,&amp;#34;兼山&amp;#xff0c;艮。君子以思不出其位&amp;#34;},\n      {51,&amp;#34;震&amp;#34;,&amp;#34;洊雷&amp;#xff0c;震。君子以恐惧修省&amp;#34;},\n      {57,&amp;#34;巽&amp;#34;,&amp;#34;随风&amp;#xff0c;巽。君子以申命行事&amp;#34;},\n      {30,&amp;#34;离&amp;#34;,&amp;#34;明两做&amp;#xff0c;离。大人以继明照四方&amp;#34;},\n      {2, &amp;#34;坤&amp;#34;,&amp;#34;地势坤&amp;#xff0c;君子以厚德载物&amp;#34;},\n      {58,&amp;#34;兑&amp;#34;,&amp;#34;丽泽兑&amp;#xff0c;君子以朋友讲习&amp;#34;}};\n\nvoid save()\n\n{\n     FILE *fp;\n\n     int i;\n\n     if((fp&amp;#61;fopen(&amp;#34;sign.txt&amp;#34;,&amp;#34;w&amp;#43;&amp;#34;))&amp;#61;&amp;#61;NULL)\n\n     {\n          printf(&amp;#34;不能打开文件\\n&amp;#34;);\n\n          return;\n\n     }\n\n     for(i&amp;#61;0;i&amp;lt;size;i&amp;#43;&amp;#43;)\n\n     {\n          fwrite(&amp;amp;Y[i],sizeof(struct Yi),1,fp);\n\n                   // printf(&amp;#34;文件写入错误\\n&amp;#34;);\n     }\n     fclose(fp);\n}\n\nint main()\n\n{ \n     struct Yi x[8];\n\n     FILE *fp;\n\n     int i;\n\n     if((fp&amp;#61;fopen(&amp;#34;sign.txt&amp;#34;,&amp;#34;r&amp;#43;&amp;#34;))&amp;#61;&amp;#61;NULL)\n\n     {\n          printf(&amp;#34;不能打开文件,退出程序后重新运行&amp;#xff01;\\n&amp;#34;);\n\n          //return;\n\n     }else{\n          for(i&amp;#61;0;i&amp;lt;size;i&amp;#43;&amp;#43;)\n\n          {\n              fread(&amp;amp;x[i],sizeof(struct Yi),1,fp);\n\n              printf(&amp;#34;卦序:%d\\n卦名:%s\\n卦象:%s\\n\\n&amp;#34;,x[i].no,x[i].name,x[i].xiang);\n\n           }\n           fclose(fp);\n     }\n\n     save();\n\n     \n     return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p style=\"text-align:center\"&gt;&lt;img alt=\"\" src=\"https://img-ask.csdnimg.cn/upload/1624165786803.jpg\" /&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将下文中八卦的有关内容(结构体数组)以文本方式存储到sign.txt 文件中,读取文中的内容输出。", [" ", "\n\n", " ", "\n\n", " ", "\n\n", "下面我自己写了一个，但有个错误，说32行的fp使用没有初始化，不会了啊，而且不知道改完能不能正确运行出来，求大佬帮我看看。", "\n\n", "#include<stdio.h>", "\n\n", "#include<stdlib.h>", "\n\n", "#define size 8", "\n\n", "struct Yi", "\n\n", "{", "\n\n", " int no;", "\n\n", " char name[3];", "\n\n", " char xiang[50];", "\n\n", "}Y[8]={{1,\"乾\",\"天行健，君子以自强不息\"},{29,\"坎\",\"水洊至，习坎。君子以常德行习教事\"},{52,\"艮\",\"兼山，艮。君子以思不出其位\"},{51,\"震\",\"洊雷，震。君子以恐惧修省\"},{57,\"巽\",\"随风，巽。君子以申命行事\"},{30,\"离\",\"明两做，离。大人以继明照四方\"},{2,\"坤\",\"地势坤，君子以厚德载物\"},{58,\"兑\",\"丽泽兑，君子以朋友讲习\"}};", "\n\n", "void save()", "\n\n", "{", "\n\n", " FILE *fp;", "\n\n", " int i;", "\n\n", " if((fp=fopen(\"sign.txt\",\"w+\"))==NULL)", "\n\n", "  {", "\n\n", "   printf(\"不能打开文件\\n\");", "\n\n", "   return;", "\n\n", "  }", "\n\n", " for(i=0;i<size;i++) ", "\n\n", " {", "\n\n", "  if(fwrite(&Y[i],sizeof(struct Yi),1,fp)!=1)", "\n\n", "   printf(\"文件写入错误\\n\");", "\n\n", "  fclose(fp);  ", "\n\n", " }", "\n\n", "}", "\n\n", "int main()", "\n\n", "{ ", "\n\n", " FILE *fp;", "\n\n", " int i;", "\n\n", " for(i=0;i<size;i++)", "\n\n", "  {", "\n\n", "   fwrite(&Y[i],sizeof(struct Yi),1,fp);", "\n\n", "  }", "\n\n", " save();", "\n\n", " for(i=0;i<size;i++)", "\n\n", "  {", "\n\n", "   fread(&Y[i],sizeof(struct Yi),1,fp);", "\n\n", "   printf(\"卦序:%d\\n卦名:%s\\n卦象:%s\\n\\n\",Y[i].no,Y[i].name,Y[i].xiang);", "\n\n", "  }", "\n\n", " fclose(fp);", "\n\n", " return 0;", "\n\n", "}", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;好了   我知道了  在VS中应该把定义放在输入的前面&lt;br /&gt;否则会报错&lt;br /&gt;谢谢大佬的私信&amp;#xff01;&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体代码运行问题报错", ["\n\n```c++\n\n\n", "\n", "###### 问题遇到的现象和发生背景 \n结构体代码运行问题\n###### 问题相关代码，请勿粘贴截图 \n", "/*输入平面上两个点P1(x1,y1)和P2(x2,y2)的坐标，以这两个点为左上角和右下角可以确定一个矩形，输出这个矩形的周长。\n要求平面上点的坐标和矩形都用结构体来表示。*/", "\n#", "include", "<stdio.h>\n", "struct", " Piont                                          ", "//坐标结构体", "\n{\n    ", "int", " x;\n    ", "int", " y;\n};\n", "struct", " Unit                                           ", "//单位计量结构体", "\n{\n    ", "int", " width;\n    ", "int", " length;\n};\n\n\n", "int", " main", "()", "\n{\n    ", "struct", " Piont P1;\n    ", "struct", " Piont P2;\n    printf(", "\"请输入P1，P2的坐标:\\n\"", ");\n    scanf(", "\"%d %d %d %d\"", ",&", "P1", ".", "x,&", "P1", ".", "y,&", "P2", ".", "x,&", "P2", ".", "y);\n    ", "struct", " Unit P;\n    ", "P", ".", "width=", "P1", ".", "x-", "P2", ".", "x;\n    ", "P", ".", "length=", "P1", ".", "y-", "P2", ".", "y;\n    ", "//等会儿再考虑正负问题", "\n    ", "int", " girth;\n    girth=", "2", "*(", "P", ".", "width+", "P", ".", "length);\n    printf(", "\"该矩形的周长为:%d\\n\"", ",girth);\n    return ", "0", ";\n}\n###### 运行结果及报错内容 \n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "21", "): warning C4996: 'scanf': This ", "function", " ", "or", " variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help ", "for", " details.\n", "1", ">          c:\\program files (x86)\\microsoft visual studio ", "11.0", "\\vc\\", "include", "\\stdio.h(", "290", ") : 参见“scanf”的声明\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "22", "): error C2143: 语法错误 : 缺少“;”(在“类型”的前面)\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "23", "): error C2065: “P”: 未声明的标识符\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "23", "): error C2224: “.width”的左侧必须具有结构/联合类型\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "24", "): error C2065: “P”: 未声明的标识符\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "24", "): error C2224: “.length”的左侧必须具有结构/联合类型\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "26", "): error C2143: 语法错误 : 缺少“;”(在“类型”的前面)\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "27", "): error C2065: “girth”: 未声明的标识符\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "27", "): error C2065: “P”: 未声明的标识符\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "27", "): error C2224: “.width”的左侧必须具有结构/联合类型\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "27", "): error C2224: “.length”的左侧必须具有结构/联合类型\n", "1", ">f:\\project1\\project3\\project3\\exp2.c(", "28", "): error C2065: “girth”: 未声明的标识符\n\n\n\n帮忙看看 谢谢！\n"]], "Tag": "程序设计"}
{"Answer": "用strcmp试试？？？", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言，结构体数组的引用问题", ["struct {", "\n\n", "char name[20];", "\n\n", "int  count; \n", "\n\n", "}man[]={", "\n                                {\"aaa\",0},", "\n                                {\"bbb\",0},", "\n                                {\"ccc\",0}", "\n                            },human[10];", "\n\n", "int main()", "\n{", "\n\n", "int i,j;\nfor (i=0;i<=2;i++)\n{\n    printf(\"第%d位投票，请输入候选人的名字:\",i+1);\n    scanf(\"%s\",&human[i].name);\n\n    for(j=0;j<=2;j++)\n    {\n\n        if(\"aaa\"==human[i].name)\n        {\n            man[0].count+=1;\n        }\n    }\n\n}\nfor(i=0;i<=2;i++)\n{\n    printf(\"%s票数为:%d\\n\",man[i].name,man[i].count);\n}\n", "\n\n", "}", "\n\n", "\n", "\n\n", "为什么man[0].count的值没有自增？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这题的主要问题在  class moon; 类里定义了元素  i  ,然后在后面的代码里又将 i 定义成for()循环里的自变量&amp;#xff0c;然后就乱了&amp;#xff0c;出现莫名其妙的现象&amp;#xff0c;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;\nusing namespace std;\nclass moon{\n    public:\n    double s;\n    double p;\n    double i;\n};\nstruct sumdata{\n    double sum;\n};\nstruct pricedata{\n    double price;\n};\n&lt;span class=\"hljs-string\"&gt;//10&lt;/span&gt; 20\n&lt;span class=\"hljs-string\"&gt;//18&lt;/span&gt; 15 10 12 13 1 2 3 4 5\n&lt;span class=\"hljs-string\"&gt;//75&lt;/span&gt; 72 45 1  2  3 4 5 6 7\n&lt;span class=\"hljs-string\"&gt;//4&lt;/span&gt;  5  4.5\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;每个输入包含一个测试用例。\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;以及不超过 500&amp;#xff08;以万吨为单位&amp;#xff09;的正整数 D 表示市场最大需求量。\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;随后一行给出 N 个正数表示每种月饼的库存量&amp;#xff08;以万吨为单位&amp;#xff09;&amp;#xff1b;\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;最后一行给出 N 个正数表示每种月饼的总售价&amp;#xff08;以亿元为单位&amp;#xff09;。\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;数字间以空格分隔。\n&lt;span class=\"hljs-string\"&gt;//N&lt;/span&gt; D\n&lt;span class=\"hljs-string\"&gt;//S1&lt;/span&gt; S2 S3 SN\n&lt;span class=\"hljs-string\"&gt;//P1&lt;/span&gt; P2 P3 PN\nint main&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n{\n　int N&amp;#61;10,D&amp;#61;20;\n    cin&amp;gt;&amp;gt;N&amp;gt;&amp;gt;D;\n    class moon M[N];\n    sumdata S[N];\n    pricedata P[N];\n    for&lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;N;i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        cin&amp;gt;&amp;gt;S[i]&lt;span class=\"hljs-string\"&gt;.sum&lt;/span&gt;;\n    }\n    for&lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;N;i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        cin&amp;gt;&amp;gt;P[i]&lt;span class=\"hljs-string\"&gt;.price&lt;/span&gt;;\n    }\n    for&lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;k&lt;/span&gt;&amp;#61;0;k&amp;lt;N;k&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        M[k]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt; &amp;#61; S[k]&lt;span class=\"hljs-string\"&gt;.sum&lt;/span&gt;;\n        M[k]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt; &amp;#61; P[k]&lt;span class=\"hljs-string\"&gt;.price&lt;/span&gt;;\n        M[k]&lt;span class=\"hljs-string\"&gt;.i&lt;/span&gt; &amp;#61; M[k]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt; / M[k]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt;;\n    }\n    for&lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;k&lt;/span&gt;&amp;#61;0;k&amp;lt;N-1;k&amp;#43;&amp;#43;)&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;对结构体数组进行冒泡排序&amp;#xff0c;大的在前&amp;#xff0c;小的在后\n    {\n        for&lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;N-k-1;j&amp;#43;&amp;#43;)&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(M[j].i&amp;lt;M[j&amp;#43;1].i)&lt;/span&gt;\n            {\n                double sum,price,ind;\n                sum &amp;#61; M[j]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt;;\n                price &amp;#61; M[j]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt;;\n                ind &amp;#61; M[j]&lt;span class=\"hljs-string\"&gt;.i&lt;/span&gt;;\n                M[j]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt; &amp;#61; M[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt;;\n                M[j]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt; &amp;#61; M[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt;;\n                M[j]&lt;span class=\"hljs-string\"&gt;.i&lt;/span&gt; &amp;#61; M[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.i&lt;/span&gt;;\n                M[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt; &amp;#61; sum;\n                M[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt; &amp;#61; price;\n                M[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.i&lt;/span&gt; &amp;#61; ind;\n            }\n        }\n    }\n    cout&amp;lt;&amp;lt;M[1]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt;&amp;lt;&amp;lt;endl;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;输出第二个大的\n    cout&amp;lt;&amp;lt;M[1]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;M[N-1]&lt;span class=\"hljs-string\"&gt;.s&lt;/span&gt;&amp;lt;&amp;lt;endl;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;输出最后一个小的&amp;#xff0c;&amp;#xff08;数组长度为N&amp;#xff0c;所以最后一个下标为N-1}\n    cout&amp;lt;&amp;lt;M[N-1]&lt;span class=\"hljs-string\"&gt;.p&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    system&lt;span class=\"hljs-params\"&gt;(&amp;#34;pause&amp;#34;)&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-string\"&gt;//10&lt;/span&gt; 20\n&lt;span class=\"hljs-string\"&gt;//18&lt;/span&gt; 15 10 12 13 1 2 3 4 5\n&lt;span class=\"hljs-string\"&gt;//75&lt;/span&gt; 72 45 1 2 3 4 5 6 7\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;0&lt;/span&gt;,M[0]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;18.000000&lt;/span&gt;,M[0]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;75.000000&lt;/span&gt;,M[0]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;4.166667&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;1&lt;/span&gt;,M[1]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;15.000000&lt;/span&gt;,M[1]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;72.000000&lt;/span&gt;,M[1]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;4.800000&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;2&lt;/span&gt;,M[2]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;10.000000&lt;/span&gt;,M[2]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;45.000000&lt;/span&gt;,M[2]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;4.500000&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;3&lt;/span&gt;,M[3]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;12.000000&lt;/span&gt;,M[3]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;1.000000&lt;/span&gt;,M[3]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;0.083333&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;4&lt;/span&gt;,M[4]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;13.000000&lt;/span&gt;,M[4]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;2.000000&lt;/span&gt;,M[4]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;0.153846&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;5&lt;/span&gt;,M[5]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;1.000000&lt;/span&gt;,M[5]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;3.000000&lt;/span&gt;,M[5]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;3.000000&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;6&lt;/span&gt;,M[6]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;2.000000&lt;/span&gt;,M[6]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;4.000000&lt;/span&gt;,M[6]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;2.000000&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;7&lt;/span&gt;,M[7]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;3.000000&lt;/span&gt;,M[7]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;5.000000&lt;/span&gt;,M[7]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;1.666667&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;8&lt;/span&gt;,M[8]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;4.000000&lt;/span&gt;,M[8]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;6.000000&lt;/span&gt;,M[8]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;1.500000&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//k&amp;#61;9&lt;/span&gt;,M[9]&lt;span class=\"hljs-string\"&gt;.s&amp;#61;5.000000&lt;/span&gt;,M[9]&lt;span class=\"hljs-string\"&gt;.p&amp;#61;7.000000&lt;/span&gt;,M[9]&lt;span class=\"hljs-string\"&gt;.i&amp;#61;1.400000&lt;/span&gt;\n\n&lt;span class=\"hljs-string\"&gt;//10&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//45&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//12&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//1&lt;/span&gt;\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;请按任意键继续. . .\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体数组的相关问题", ["\n", "\n\n", "#include<iostream>", "\nusing namespace std;\n\nclass moon{\n    public:\n    double s;\n    double p;\n    double i;\n};\n\nstruct sumdata{\n    double sum;\n};\n\nstruct pricedata{\n    double price;\n};\n", "//10", " 20\n", "//18", " 15 10 12 13 1 2 3 4 5\n", "//75", " 72 45 1  2  3 4 5 6 7\n", "//4", "  5  4.5 \n", "//", "每个输入包含一个测试用例。\n", "//", "每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、\n", "//", "以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。\n", "//", "随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；\n", "//", "最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。\n", "//", "数字间以空格分隔。\n", "//N", " D\n", "//S1", " S2 S3 SN\n", "//P1", " P2 P3 PN\nint main", "()", "\n{\n    int N,D;\n    cin>>N>>D;\n    class moon M[N];\n    sumdata S[N];\n    pricedata P[N];\n    for", "(int ", "i", "=0;i<N;i++)", "\n    {\n        cin>>S[i]", ".sum", ";\n    }\n    for", "(int ", "i", "=0;i<N;i++)", "\n    {\n        cin>>P[i]", ".price", ";\n    }\n    for", "(int ", "i", "=0;i<N;i++)", "\n    {\n        M[i]", ".s", " = S[i]", ".sum", ";\n        M[i]", ".p", " = P[i]", ".price", ";\n        M[i]", ".i", " = M[i]", ".p", " / M[i]", ".s", ";\n    }\n    for", "(int ", "i", "=0;i<N;i++)", "//", "对结构体数组进行冒泡排序，大的在前，小的在后 \n    {\n        for", "(int ", "j", "=0;j<N-i;j++)", "\n        {\n            ", "if", "(M[i].i<M[i+1].i)", "\n            {\n                double sum,price,ind;\n                sum = M[i]", ".s", ";\n                price = M[i]", ".p", ";\n                ind = M[i]", ".i", ";\n                M[i]", ".s", " = M[i+1]", ".s", ";\n                M[i]", ".p", " = M[i+1]", ".p", ";\n                M[i]", ".i", " = M[i+1]", ".i", ";\n                M[i+1]", ".s", " = sum;\n                M[i+1]", ".p", " = price;\n                M[i+1]", ".i", " = ind;\n            }\n        }\n    }\n    cout<<M[1]", ".s", "<<endl;", "//", "输出第二个大的 \n    cout<<M[1]", ".p", "<<endl;\n    cout<<M[N-1]", ".s", "<<endl;", "//", "输出最后一个小的，（数组长度为N，所以最后一个下标为N-1} \n    cout<<M[N-1]", ".p", "<<endl;\n}\n\n\n", "\n", "想问一下，为什么长度为N的结构体数组,输出下标为N-1时出现了错误？"]], "Tag": "程序设计"}
{"Answer": "```\r\nFILE *fp;\r\nfp = fopen(\"x:\\\\你的文件.txt\", \"r+\");\r\nchar buffer[1000];\r\nwhile (!feof(fp))\r\n{\r\nfscanf(fp, \"%s\", &amp;buffer[0]);\r\nif (strcmp(buffer, \"[]BEGIN\"))\r\nbuffer就是你要的\r\n...\r\n }\r\n\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C++高效处理TXT文本，并写入结构体数组的优秀实例?", ["C++读取TXT文本文件[BGIN]和[END]中相关有用数据，将数据写入结构体数组（如下），", "\n\n", "struct Vpdata", "\n{", "\n    chart PT[5];                     //X9", "\n    string ActiveTiP;             //B1S8", "\n    float  Retract;                 //3.000000", "\n    float  Tolerance_Upper; //0.020", "\n    float  Tolerance_Lower; //-0.020", "\n    double X;                       //46.0978", "\n    double Y;                       //449.5917", "\n    double Z;                       //264.0902", "\n    double I;                        //0.8906", "\n    double J;                        //0.1080", "\n    double K;                       //0.4417", "\n};", "\n\n", "txt格式如下，行数量未知；", "\n... ...", "\n... ...", "\n[BEGIN]", "\nX9:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=46.0978,449.5917,264.0902,0.8906,0.1080,0.4417", "\nX1:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=79.8739,529.1789,317.0000,0.0000,0.0000,1.0000", "\nX2:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=40.7599,508.9691,292.0000,0.0000,0.0000,1.0000", "\nX3:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=17.3222,509.0666,297.4902,0.000,-0.5924,0.8056", "\nX4:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=36.4060,486.6219,281.6236,0.000,-0.5748,0.8183", "\nX5:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=44.2144,469.7959,273.7131,0.0000,-0.9962,0.0872", "\nX6:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=147.8952,464.1894,265.9202,0.00,-0.5585,0.8295", "\nX7:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=139.8095,463.2058,272.1759,0.86,0.1464,0.4886", "\nX8:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=147.0377,455.5513,266.9044,0.8916,0.1626,0.4226", "\nX10:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=177.1025,476.6855,266.5594,0.0000,-0.9986,0.0523", "\nX11:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=158.5258,461.6525,254.3172,1.0000,0.0000,0.0000", "\nX12:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=158.5258,450.9872,249.6415,1.0000,0.0000,0.0000", "\nX13:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=204.6803,462.8675,267.9680,-0.9659,0.0000,0.2588", "\nX14:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=201.7029,447.5408,256.8562,-0.9659,0.0000,0.2588", "\nX15:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=172.4805,433.3200,246.7664,0.0000,0.9986,0.0523", "\nX16:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=154.5043,430.8859,253.7178,0.0000,-0.4304,0.9027", "\nX17:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=155.3791,419.7767,248.7889,0.0000,-0.6482,0.7614", "\nX18:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=157.0619,400.7633,232.8402,0.0000,-0.6369,0.7710", "\nX19:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=157.7367,383.6450,218.8977,0.0000,-0.6260,0.7798", "\nX20:M=B1S8,RA=3.000000,MSG=0.020,-0.020,MKJYGF=157.6545,365.7935,204.7889,0.0000,-0.6140,0.7893", "\n... ...", "\n[END]"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Here's how you may embed the Foo struct in the Bar one :&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Foo struct {\n    Val1, Val2, Val3 int\n}\ntype Bar struct {\n    Foo\n    OtherVal string\n}\nfunc main() {\n    f := &amp;amp;Foo{123, 234, 354}\n    b := &amp;amp;Bar{*f, \"test\"}\n    fmt.Println(b.Val2) // prints 234\n    f.Val2 = 567\n    fmt.Println(b.Val2) // still 234\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now suppose you don't want the values to be copied and that you want &lt;code&gt;b&lt;/code&gt; to change if &lt;code&gt;f&lt;/code&gt; changes. Then you don't want embedding but composition with a pointer :&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Foo struct {\n    Val1, Val2, Val3 int\n}\ntype Bar struct {\n    *Foo\n    OtherVal string\n}\nfunc main() {\n    f := &amp;amp;Foo{123, 234, 354}\n    b := &amp;amp;Bar{f, \"test\"}\n    fmt.Println(b.Val2) // 234\n    f.Val2 = 567\n    fmt.Println(b.Val2) // 567\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Two different kind of composition, with different abilities.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Go结构体可以继承一组值吗？", ["\n\n", "Can a Go struct inherit a set of values from a type of another struct?", "\n\n", "Something like this.", "\n\n", "type Foo struct {\n    Val1, Val2, Val3 int\n}\n\nvar f *Foo = &Foo{123, 234, 354}\n\ntype Bar struct {\n    // somehow add the f here so that it will be used in \"Bar\" inheritance\n    OtherVal string\n}\n", "\n\n", "Which would let me do this.", "\n\n", "b := Bar{\"test\"}\nfmt.Println(b.Val2) // 234\n", "\n\n", "If not, what technique could be used to achieve something similar?", "\n    "]], "Tag": "程序设计"}
{"Answer": "_THREAD_CONTEXT 是标示符\r\nTHREAD_CONTEXT 是结构体类型\r\n*PTHREAD_CONTEXT 是结构体指针类型\r\n\r\n上面两个均可以定义结构体对象，第三个为指针类型。", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ 结构体之定义（名称）", ["typedef struct _THREAD_CONTEXT", "\n{", "\n   CWorkQueue* pWorkQueue;", "\n   void*       pThreadData;", "\n} THREAD_CONTEXT,*PTHREAD_CONTEXT;", "\n\n", "_THREAD_CONTEXT", "\nTHREAD_CONTEXT,", "\n*PTHREAD_CONTEXT", "\n请问这三个区别以及应用的时候有什么注意的。"]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/lethic/article/details/7781203", "Konwledge_Point": "数据封装——结构体", "Question": ["库函数指针传递调用结构体数组排序要稳定性排序怎么做？", ["C++ 6.0库函数指针传递调用结构体数组排序要稳定性排序怎么做？最好给出一个例子加以说明，代码怎么写？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;char的话&amp;#xff0c;只能是一个字符啊。你输入as是两个字符&amp;#xff0c;所以第二个人的姓名自动接收第二个字符s了&amp;#xff0c;因此不需要再输入&amp;#xff0c;没毛病。&lt;br /&gt;本身的问题就是姓名你不止一个字符&amp;#xff0c;定义成char name就是错的&amp;#xff0c;应该是字符数组才对&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["创建char型单链表输入输出问题", ["问题遇到的现象和发生背景", "\n", "当用char name[]数组存储读入字符时候，结果正常；", "用char 类型变量存储键盘输入信息时候，出现异常结果", "是不是输入输出语句有问题啊", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<malloc.h>", " ", "\n\n", "typedef", " ", "struct", " ", "node", "{\n    ", "char", " name;\n    ", "struct", " ", "node", " *next;\n}student;\n\n", "student *", "creat", "(", "int", " n)", "\n", "{\n    student *p,*h=(student *)", "malloc", "(", "sizeof", "(student)),*s;\n    ", "int", " i;\n", "//    h->name=NULL;", "\n    h->next=", "NULL", ";\n    p=h;\n    ", "for", "(i=", "0", ";i<n;i++){\n        ", "if", "((s=(student *)", "malloc", "(", "sizeof", "(student) ))==", "NULL", "){\n            ", "printf", "(", "\"不能分配\"", ");\n            ", "exit", "(", "0", "); \n        }\n        p->next=s;\n        ", "printf", "(", "\"第%d个人的姓名：\"", ",i+", "1", ");\n    ", "//    scanf(\"%c\",s->name);", "\n        s->name=", "getchar", "();\n    \n        s->next=", "NULL", ";\n        p=s;\n    }\n    ", "return", " h;\n}\n\n", "void", " ", "Print_Elem", "(student *p)", "\n", "{\n    ", "while", "(p->next!=", "NULL", "){\n        p=p->next;\n    ", "//    printf(\"%c\\n\",p->name);", "\n    ", "putchar", "(p->name);\n    }\n}\n\n", "int", " ", "main", "()", "{\n\n    student *head;\n\n    head=", "creat", "(", "3", ");\n    ", "Print_Elem", "(head);\n}\n\n", "\n", "运行结果及报错内容", "\n", "第1个人的姓名：as", "第2个人的姓名：第3个人的姓名：as", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "为什么键盘输入的过程看起来只是执行了一次"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There are two reasons:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Your XML is malformed - you should add a closing &lt;code&gt;&amp;lt;/Envelope&amp;gt;&lt;/code&gt;. &lt;/li&gt;\n&lt;li&gt;Your struct tags in &lt;code&gt;Data&lt;/code&gt; are malformed – they don't quote the name of the attribute - this means the the XML deserializer looks for an 'Order' field, instead of the &lt;code&gt;Orders&lt;/code&gt; field. &lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;For good measure: you can find a fully working example on &lt;a href=\"http://play.golang.org/p/6-odOcSOnF\" rel=\"nofollow\"&gt;http://play.golang.org/p/6-odOcSOnF&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;The relevant part is my&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Data struct {\n    XMLName xml.Name `xml:\"Data\"`\n    Orders  []Order  `xml:\"Order\"`\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;versus your original&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Data struct {\n    XMLName xml.Name `xml:Data`\n    Orders  []Order  `xml:Order`\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将XML解组为struct", ["\n\n", "I have this xml file and i it seems i cant unmarshal any data into a struct. Someone can help me out here. Its just i never used xml before, always prefered json before xml. Just edited this post with my code and it still gives me empty struct values", "\n\n", "<Envelope>\n<Data>\n        <Order>\n            <DeliveryData>\n                <del_country>BELGIQUE/BELGIE</del_country>\n                <del_country_code>BE</del_country_code>\n                <del_company>False</del_company>\n                <del_name>ADAM</del_name>\n                <del_contact></del_contact>\n                <del_firstName></del_firstName>\n                <del_addressLine1>Durasweg 33</del_addressLine1>\n                <del_addressLine2></del_addressLine2>\n                <del_areaCode>1000</del_areaCode>\n                <del_city>BRUXELLES</del_city>\n                <del_country>BE</del_country>\n                <del_language>FR</del_language>\n                <del_modeCode>71</del_modeCode>\n                <phone1>0032872180808</phone1> \n                <email></email>\n                <inv_third>438802</inv_third>\n                <OrderID>15787978</OrderID>\n                <ParcelID>NE1578797801</ParcelID>\n                <OrderDate>16/09/2014 14:22:54</OrderDate>\n                <Shipping_date>16/09/2014 14:26:55</Shipping_date>\n            </DeliveryData>\n    </Order>\n  </Data>\n", "\n\n", "\n\n", " type DeliveryData struct {\n    XMLName xml.Name `xml:\"DeliveryData\"`\n    Country string   `xml:\"del_country\"`\n}\n\ntype Envelope struct {\n    XMLName xml.Name `xml:\"Envelope\"`\n    Data    Data     `xml:\"Data\"`\n}\n\ntype Data struct {\n    XMLName xml.Name `xml:Data`\n    Orders  []Order  `xml:Order`\n}\n\ntype Order struct {\n    XMLName      xml.Name     `xml:\"Order\"`\n    DeliveryData DeliveryData `xml:\"DeliveryData\"`\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数据结构定义不对&amp;#xff0c;只有name是字符数组&amp;#xff0c;其它都是int就可以了&amp;#xff0c;不要定义成数组&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体输入学生基本信息", ["请问这个错误是什么意思，因为这个程序本身是从网上找的，进行修改，但是我是初学者，也不太明白哪错了，谢谢"]], "Tag": "程序设计"}
{"Answer": "这是一个指针。看下函数定义", "Konwledge_Point": "数据封装——结构体", "Question": ["window不是一个结构体，也没有allow——shrink成员，why可以通过->引用", [" GTK_WINDOW(window)->allow_shrink=TRUE\n\n        window不是一个结构体，也没有allow——shrink成员，但是上面可以调节window\n         的属性，怎么做到的？还是说这是个通例。\n"]], "Tag": "程序设计"}
{"Answer": "http://www.educity.cn/wenda/542535.html", "Konwledge_Point": "数据封装——结构体", "Question": ["很多结构体类型，只有一个字段的类型不同，能不能合并成一个存入数组？", ["很多结构体类型，只有一个字段的类型不同，能不能合并成一个存入数组？怎么定义类型灵活的结构体，在vb里？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;构造函数定义时多了一个参数&amp;#xff1b;&lt;br /&gt;worker(string&amp;#61;&amp;#34;&amp;#34;,string&amp;#61;&amp;#34;&amp;#34;, string&amp;#61;&amp;#34;&amp;#34;, char&amp;#61;&amp;#39;f&amp;#39;, double&amp;#61;0);&lt;br /&gt;改成&lt;br /&gt;&amp;#61;&amp;#61;》&lt;br /&gt;worker(string&amp;#61;&amp;#34;&amp;#34;,string&amp;#61;&amp;#34;&amp;#34;,char&amp;#61;&amp;#39;f&amp;#39;, double&amp;#61;0);&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c++结构体 静态 函数", ["这个怎么出错了呀找了半天都不知道哪里错了🥲有没有学长学姐能帮我解答一下呀谢谢😭"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;定义结构数组 可以这样定义&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;line&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b;\n} ;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;line&lt;/span&gt;  t  [&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;}};\n    \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;%d,b&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,t[i].a,t[i].b);\n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;    \n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求解答：结构体数组初始值设定项太多", ["\nstruct line\n{\n    int a;\n    int b;\n}l[", "20", "];\nint main()\n{\n    l[", "20", "] = { { ", "2", ", ", "3", " } };", "//", "三这里显示初始值设定项太多\n    return ", "0", ";\n}\n\n![img](https:", "//img", "-mid.csdnimg.cn", "/release/", "static", "/image/mi", "d", "/ask/", "700104049636157", ".png ", "\"#left\"", ")\n"]], "Tag": "程序设计"}
{"Answer": "student[i].id 是内存地址  st[i]是char类型的值 你是将地址赋值给变量", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C语言中的结构体。", ["\n\n", "源代码：", "\n#include", "\nint m = 0;", "\nvoid input(void);", "\nvoid sort(void);", "\nstruct stu", "\n{", "\n    char sex[100];", "\n    char id[100];", "\n    char name[100];", "\n};", "\nstruct stu student[10];", "\nint main(void)", "\n{", "\n    struct stu student[10];", "\n    input();", "\n    sort();", "\n}", "\nvoid input(void)//定义赋值函数", "\n{", "\n    int i,N;", "\n    printf(\"请输入需要多少组学生信息（最多10组）:\");", "\n    scanf(\"%d\",&N); ", "\n    printf(\"请依次输入学生信息，数据用空格隔开\\n\");", "\n    printf(\"性别  姓名  学号\\n\");", "\n    for(i = 0;i < N;i++)", "\n    { ", "\n        scanf(\"%s%s%s\",&student[i].sex,&student[i].name,&student[i].id);", "\n        if(i < N - 1)// 防止最后多输入一次“请输入下一组数据”", "\n        {", "\n            printf(\"请输入下一组数据\");", "\n        }", "\n        m++; //用于比大小函数中的判断条件", "\n    }", "\n}", "\nvoid sort(void)//定义比大小函数", "\n{", "\n    int i = 0,k = 0;", "\n    char st[100];", "\n    for(i = 0;i < m;i++)//将student.id的值赋给st", "\n    {", "\n        st[i] = student[i].id;", "\n    }", "\n    for(i = 0;i < m - 1;i++)//比较", "\n    {", "\n        if(st[i] > st[i + 1])", "\n        {", "\n            st[i + 1] = st[i];", "\n            k = i;", "\n        }", "\n        else", "\n        {", "\n            k = i + 1; ", "\n        }", "\n    }", "\n    printf(\"id值最大的成员为：\\n\");", "\n    printf(\"%s    %s   %s \",student[k].sex,student[k].name,student[k].id); ", "\n}", "\n现在需要做的是比较id的大小，并找出其中最大的一组，但是为什么图中框住的地方赋值一直有问题？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先按学号从小到大排序&amp;#xff0c;再顺序输出&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在结构体数组中，学号顺序输出学生信息", ["有10名同学的结构体数组，里面包含学生的学号，名次，姓名等信息，现在想按学号顺序输出学生信息，应该怎么办？", "\n\n", "谢谢啦"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考:&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;stdio.h&amp;gt;\n#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;windows.h&amp;gt;\n#include &amp;lt;conio.h&amp;gt;\n#include &amp;lt;string&amp;gt;\n#include &amp;lt;time.h&amp;gt;\nstruct conncet\t//学生-课程成绩信息\n{\n\tint num_1;\t\t//学号\n\tint num_2[10];\t\t//课程号\n\tint grade[10];\t\t//成绩\n\tstruct conncet* next;\n};\nvoid jiemian()\n{\n\tint i &amp;#61; 0;\n\tprintf(&amp;#34;*********************************************************\\n&amp;#34;);\n\tprintf(&amp;#34;**                                                     **\\n&amp;#34;);\n\tprintf(&amp;#34;**          请输入你想要执行的操作&amp;#xff1a;                   **\\n&amp;#34;);\n\tprintf(&amp;#34;**          1&amp;#xff1a;输出学生-课程信息                       **\\n&amp;#34;);\n\tprintf(&amp;#34;*********************************************************\\n&amp;#34;);\n}\nvoid connect_m(int x)\n{\n\tint i, j, k, x_1, x_2, temp, a, b;\n\tconncet* head &amp;#61; NULL, * p1, * p2;\n\tconncet* head_1;\n\t//p1 &amp;#61; p2 &amp;#61; (conncet*)malloc(sizeof(conncet));\n\tunsigned int times &amp;#61; (unsigned int)time(NULL);\n\tfor (i &amp;#61; 0; i &amp;lt; x; i&amp;#43;&amp;#43;)\n\t{\n                p1 &amp;#61; (struct conncet*)malloc(sizeof(struct conncet));\n\t\tp1-&amp;gt;num_1 &amp;#61; i &amp;#43; 1;\n\t\tif (i &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\thead &amp;#61; p2 &amp;#61; p1;\n\t\t}\n\t\tfor (j &amp;#61; 0; j &amp;lt; 10; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tsrand(times * ((i &amp;#43; 1) * (j &amp;#43; 1)));\n\t\t\tx_1 &amp;#61; rand() % 50 &amp;#43; 1;\n\t\t\tx_2 &amp;#61; rand() % 40 &amp;#43; 60;\n\t\t\tp1-&amp;gt;num_2[j] &amp;#61; x_1;\n\t\t\tp1-&amp;gt;grade[j] &amp;#61; x_2;\n\t\t}\n\t\tp2-&amp;gt;next &amp;#61; p1;\n\t\tp2 &amp;#61; p1;\n\t\tprintf(&amp;#34;学号为&amp;#xff1a;%-3d\\n&amp;#34;, p2-&amp;gt;num_1);\n\t\tfor (j &amp;#61; 0; j &amp;lt; 10; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tprintf(&amp;#34;课程号为&amp;#xff1a;%-3d&amp;#34;, p2-&amp;gt;num_2[j]);\n\t\t\tprintf(&amp;#34;成绩为&amp;#xff1a;%-3d\\n&amp;#34;, p2-&amp;gt;grade[j]);\n\t\t}\n                //p1 &amp;#61; (conncet*)malloc(sizeof(conncet));\n\t}\n\tp2-&amp;gt;next &amp;#61; NULL;\n\thead_1 &amp;#61; head;\n        for(k&amp;#61;0;k &amp;lt; x;k&amp;#43;&amp;#43;){  //对每个学生的循环\n         \tfor (i &amp;#61; 0; i &amp;lt; 10-1; i&amp;#43;&amp;#43;)\n\t        {\n\t\t     for (j &amp;#61; 0; j &amp;lt; 10 - i - 1; j&amp;#43;&amp;#43;)\n\t\t     {\n\t\t\tif (head_1-&amp;gt;num_2[j] &amp;gt; head_1-&amp;gt;num_2[j &amp;#43; 1])    //相邻元素之间比较\n\t\t\t{                            //大的元素向右移动\n\t\t\t\ttemp &amp;#61; head_1-&amp;gt;num_2[j];          //每一轮比较最大的元素在最后\n\t\t\t\thead_1-&amp;gt;num_2[j] &amp;#61; head_1-&amp;gt;num_2[j &amp;#43; 1];\n\t\t\t\thead_1-&amp;gt;num_2[j &amp;#43; 1] &amp;#61; temp;\n\t\t\t}\n                     }\n                }\n                printf(&amp;#34;\\n只改变课程号顺序而不改变成绩顺序,排序完成后:\\n&amp;#34;);\n                printf(&amp;#34;学号为&amp;#xff1a;%-3d\\n&amp;#34;, head_1-&amp;gt;num_1);\n                for (j &amp;#61; 0; j &amp;lt; 10; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tprintf(&amp;#34;课程号为&amp;#xff1a;%-3d&amp;#34;, head_1-&amp;gt;num_2[j]);\n\t\t\tprintf(&amp;#34;成绩为&amp;#xff1a;%-3d\\n&amp;#34;, head_1-&amp;gt;grade[j]);\n\t\t}\n                head_1 &amp;#61; head_1-&amp;gt;next;\n        }\n\n}\n\n\nint main()\n{\n\t\tint num_1 &amp;#61; 1, x;\n\t\tint control;\n\t\tjiemian();\n\t\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;x);\n\t\tswitch (x)\n\t\t{\n\t\tcase 1:\n\t\t\tprintf(&amp;#34;请输入想要生成学生的数量&amp;#xff1a;&amp;#34;);\n\t\t\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;control);\n\t\t\tconnect_m(control);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(&amp;#34;error\\n&amp;#34;);\n\t\t\tbreak;\n\t\t}\n      \n\t\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言无法排序指针指向的结构体变量", ["\n\n", "课程号和成绩为随机数生成的，想要根据课程号来排序，既允许只改变课程号顺序而不改变成绩顺序，如（课程号：50，成绩：60，课程号：24，成绩：70  改为 课程号：24，成绩：60，课程号：50，成绩：70）", "\n\n", "也允许根据课程号顺序同时更改成绩顺序。如（课程号：50，成绩：60，课程号：24，成绩：70  改为 课程号：24，成绩：70，课程号：50，成绩：60）", "\n\n", "但是为什么我这样写就会显示读取访问权限冲突呢", "\n\n", "\n\n", " ", "\n\n", "完整代码如下", "\n\n", "\n", "#include <iostream>\n#include <windows.h>\n#include <conio.h> \n#include <string>\n#include <time.h>\nstruct conncet\t//学生-课程成绩信息\n{\n\tint num_1;\t\t//学号\n\tint num_2[10];\t\t//课程号\n\tint grade[10];\t\t//成绩\n\tstruct conncet* next;\n};\nvoid jiemian()\n{\n\tint i = 0;\n\tprintf(\"*********************************************************\\n\");\n\tprintf(\"**                                     **\\n\");\n\tprintf(\"**          请输入你想要执行的操作：                   **\\n\");\n\tprintf(\"**          1：输出学生-课程信息                       **\\n\");\n\tprintf(\"*********************************************************\\n\");\n\n}\nvoid connect(int x)\n{\n\tint i, j, x_1, x_2, temp, a, b;\n\tconncet* head = NULL, * p1, * p2;\n\tconncet* head_1;\n\tp1 = p2 = (conncet*)malloc(sizeof(conncet));\n\tunsigned int times = (unsigned int)time(NULL);\n\tfor (i = 0; i < x; i++)\n\t{\n\t\tp1->num_1 = i + 1;\n\t\tif (i == 0)\n\t\t{\n\t\t\thead = p1;\n\t\t}\n\t\tfor (j = 0; j < 10; j++)\n\t\t{\n\t\t\tsrand(times * ((i + 1) * (j + 1)));\n\t\t\tx_1 = rand() % 50 + 1;\n\t\t\tx_2 = rand() % 40 + 60;\n\t\t\tp1->num_2[j] = x_1;\n\t\t\tp1->grade[j] = x_2;\n\t\t}\n\t\tp2->next = p1;\n\t\tp2 = p1;\n\t\tp1 = (conncet*)malloc(sizeof(conncet));\n\t\tprintf(\"学号为：%-3d\\n\", p2->num_1);\n\t\tfor (j = 0; j < 10; j++)\n\t\t{\n\t\t\tprintf(\"课程号为：%-3d\", p2->num_2[j]);\n\t\t\tprintf(\"成绩为：%-3d\\n\", p2->grade[j]);\n\t\t}\n\n\t}\n\tp2->next = NULL;\n\thead_1 = head;\n\tfor (i = 0; i < 10; i++)\n\t{\n\t\tfor (j = 0; j < 10 - i - 1; j++)\n\t\t{\n\t\t\tif (head_1->num_2[j] > head_1->num_2[j + 1])    //相邻元素之间比较\n\t\t\t{                            //大的元素向右移动\n\t\t\t\ttemp = head_1->num_2[j];          //每一轮比较最大的元素在最后\n\t\t\t\thead_1->num_2[j] = head_1->num_2[j + 1];\n\t\t\t\thead_1->num_2[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t\thead_1 = head_1->next;\n\t}\n}\n\tint main()\n\t{\n\t\tint num_1 = 1, x;\n\t\tint control;\n\t\tjiemian();\n\t\tscanf(\"%d\", &x);\n\t\tswitch (x)\n\t\t{\n\t\tcase 1:\n\t\t\tprintf(\"请输入想要生成学生的数量：\");\n\t\t\tscanf(\"%d\", &control);\n\t\t\tconnect(control);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n#define Maxsize 30\ntypedef struct Student\n{\n\tint num;\n\tchar name[Maxsize];\n\tchar sex[Maxsize];\n\tint age;\n\tint Chinese;\n\tint Math;\n\tint English;\n}Student;\nvoid line(char c, int n)\n{\n\tint i;\n\tfor (i &amp;#61; 0; i &amp;lt; n; i&amp;#43;&amp;#43;)\n\t\tprintf(&amp;#34;%c&amp;#34;, c);\n}\nvoid input(Student* stud)\n{\n\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;stud-&amp;gt;num);\n\tscanf(&amp;#34;%s&amp;#34;, stud-&amp;gt;name);\n\tscanf(&amp;#34;%s&amp;#34;, stud-&amp;gt;sex);\n\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;stud-&amp;gt;age);\n\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;stud-&amp;gt;Chinese);\n\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;stud-&amp;gt;Math);\n\tscanf(&amp;#34;%d&amp;#34;, &amp;amp;stud-&amp;gt;English);\n}\nvoid print(Student* stud)\n{\n\tint total, aver;\n\ttotal &amp;#61; stud-&amp;gt;Chinese &amp;#43; stud-&amp;gt;Math &amp;#43; stud-&amp;gt;English;\n\taver &amp;#61; total / 3;\n\tprintf(&amp;#34;%-8d%-8s%-8s%-8d%-8d%-8d%-8d%-8d%-8d\\n&amp;#34;, stud-&amp;gt;num, stud-&amp;gt;name, stud-&amp;gt;sex, stud-&amp;gt;age, stud-&amp;gt;Chinese, stud-&amp;gt;Math, stud-&amp;gt;English, total, aver);\n}\nvoid print_all(Student* stud, int n)\n{\n\tint i;\n\tint aver1 &amp;#61; 0, aver2 &amp;#61; 0, aver3 &amp;#61; 0, aver4, aver5;\n\tprintf(&amp;#34;学号\t姓名\t性别\t年龄\t语文\t数学\t英语\t总分\t均分\\n&amp;#34;);\n\tfor (i &amp;#61; 1; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\t\tprint(stud &amp;#43; i);\n\tfor (i &amp;#61; 1; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n\t{\n\t\taver1 &amp;#43;&amp;#61; (stud &amp;#43; i)-&amp;gt;Chinese;\n\t\taver2 &amp;#43;&amp;#61; (stud &amp;#43; i)-&amp;gt;Math;\n\t\taver3 &amp;#43;&amp;#61; (stud &amp;#43; i)-&amp;gt;English;\n\t}\n\tprintf(&amp;#34;\\n&amp;#34;);\n\taver4 &amp;#61; aver1 &amp;#43; aver2 &amp;#43; aver3;\n\taver1 /&amp;#61; n;\n\taver2 /&amp;#61; n;\n\taver3 /&amp;#61; n;\n\taver4 /&amp;#61; n;\n\taver5 &amp;#61; aver1 &amp;#43; aver2 &amp;#43; aver3;\n\taver5 /&amp;#61; n;\n\tprintf(&amp;#34; 班级平均分\t\t\t\t\t\t%-8d%-8d%-8d%-8d%-8d\\n\\n&amp;#34;, aver1, aver2, aver3, aver4, aver5);\n}\nvoid  main()\n{\n\tStudent stud[5];\n\tstud[1].num &amp;#61; 201701;\n\tstrcpy(stud[1].name,&amp;#34;WangDachuan&amp;#34;);\n\tstrcpy(stud[1].sex,&amp;#34;man&amp;#34;);\n\tstud[1].age &amp;#61; 25;\n\tstud[1].Chinese &amp;#61; 89;\n\tstud[1].Math &amp;#61; 88;\n\tstud[1].English &amp;#61; 99;\n\tstud[2].num &amp;#61; 201702;\n\tstrcpy(stud[2].name,&amp;#34;ZhangDajiang&amp;#34;);\n\tstrcpy(stud[2].sex,&amp;#34;man&amp;#34;);\n\tstud[2].age &amp;#61; 23;\n\tstud[2].Chinese &amp;#61; 90;\n\tstud[2].Math &amp;#61; 85;\n\tstud[2].English &amp;#61; 78;\n\tstud[3].num &amp;#61; 201703;\n\t\n\tstrcpy(stud[3].name,&amp;#34;LiTiemei&amp;#34;);\n\tstrcpy(stud[3].sex,&amp;#34;woman&amp;#34;);\n\tstud[3].age &amp;#61; 22;\n\tstud[3].Chinese &amp;#61; 95;\n\tstud[3].Math &amp;#61; 88;\n\tstud[3].English &amp;#61; 89;\n\tprintf(&amp;#34;输入后两个学生的信息&amp;#xff08;空格分隔&amp;#xff0c;每行一人&amp;#xff09;&amp;#xff1a;\\n\\n&amp;#34;);\n\tprintf(&amp;#34;学号   姓名   性别   年龄   语文   数学   英语\\n\\n&amp;#34;);\n\tinput(stud &amp;#43; 4);\n\tinput(stud &amp;#43; 5);\n\tprint_all(stud, 5);\n}\n \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;代码调整如上&amp;#xff0c;已经能够正常运行&amp;#xff0c;万望采纳。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体题目，乱码弹出崩溃了，求助！", ["题目：", "\n\n", "(1) 定义一个包括：学号、姓名、性别、年龄和三门课成绩(语文、数学、外语)的结构体类型struct Student。", "\n\n", "(2) 在主函数中定义一个包括5个元素的struct Student类型的数组students。前3个学生给定初值，后两个学生的信息在main函数中调用下面的input函数从键盘输入。", "\n\n", "(3) 实现一个画横线的函数line, 用于绘制由n个字符c输出组成的行线,函数原形如下:", "\n\n", "void line(char c,int n);", "\n\n", "参数: c:要输出的字符，n：输出多少个", "\n\n", "(4) 实现输入一个学生信息的函数input，函数原型如下：", "\n\n", "void input( struc", "t", " Student * stud );", "\n\n", "参数：stud：指向要输入的学生的结构体变量或数组元素", "\n\n", "(5) 实现输出一个学生信息的函数print，在一行中输出参数指定学生的所有信息、成绩、总分和平均分，函数原型如下:", "\n\n", "void print( struc", "t", " Student * stud );", "\n\n", "参数：stud：指向要输出的学生的结构体变量或数组元素", "\n\n", "(6) 实现一个输出所有学生信息的函数print_all，在该函数中输出表头，并", "调用print函数输出", "每个学生的信息及其总分和平均分，最后输出所有学生各门课（含个人总分和均分）的平均分。其原型如下：", "\n\n", "void print", "_all", "( struct Student * studs，int n );", "\n\n", "参数：studs：指向结构体数组的第一个元素，n：数组元素的个数", "\n\n", "(7) 在主函数中调用", "input", " 函数输入后两个学生的信息，调用print_all函数输出所有学生的信息和各门课的平均分（含所有人总分和均分的平均分）。", "\n\n", " ", "\n\n", "憋了一早上的代码555", "\n\n", "\n", "#include<stdio.h>\n\n#define Maxsize 30\n\ntypedef struct Student\n{\n\tint num;\n\tchar name[Maxsize];\n\tchar sex[Maxsize];\n\tint age;\n\tint Chinese;\n\tint Math;\n\tint English;\n}Student;\n\nvoid line(char c, int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++)\n\t\tprintf(\"%c\", c);\n}\n\nvoid input(Student* stud)\n{\n\tscanf_s(\"%d\", &stud->num);\n\tscanf(\"%s\", stud->name);\n\tscanf(\"%s\", stud->sex);\n\tscanf_s(\"%d\", &stud->age);\n\tscanf_s(\"%d\", &stud->Chinese);\n\tscanf_s(\"%d\", &stud->Math);\n\tscanf_s(\"%d\", &stud->English);\n}\n\nvoid print(Student* stud)\n{\n\tint total, aver;\n\ttotal = stud->Chinese + stud->Math + stud->English;\n\taver = total / 3;\n\tprintf(\"%-8d%-8s%-8s%-8d%-8d%-8d%-8d%-8d%-8d\\n\", stud->num, stud->name, stud->sex, stud->age, stud->Chinese, stud->Math, stud->English, total, aver);\n}\n\nvoid print_all(Student* stud, int n)\n{\n\tint i;\n\tint aver1 = 0, aver2 = 0, aver3 = 0, aver4, aver5;\n\tprintf(\"学号\t姓名\t性别\t年龄\t语文\t数学\t英语\t总分\t均分\\n\");\n\tfor (i = 1; i <= n; i++)\n\t\tprint(stud + i);\n\tfor (i = 1; i <= n; i++)\n\t{\n\t\taver1 += (stud + i)->Chinese;\n\t\taver2 += (stud + i)->Math;\n\t\taver3 += (stud + i)->English;\n\t}\n\tprintf(\"\\n\");\n\taver4 = aver1 + aver2 + aver3;\n\taver1 /= n;\n\taver2 /= n;\n\taver3 /= n;\n\taver4 /= n;\n\taver5 = aver1 + aver2 + aver3;\n\taver5 /= n;\n\tprintf(\" 班级平均分\t\t\t\t\t\t%-8d%-8d%-8d%-8d%-8d\\n\\n\", aver1, aver2, aver3, aver4, aver5);\n\n}\n\nvoid main()\n{\n\tStudent stud[5];\n\tstud[1].num = 201701;\n\t*stud[1].name = \"WangDachuan\";\n\t*stud[1].sex = \"man\";\n\tstud[1].age = 25;\n\tstud[1].Chinese = 89;\n\tstud[1].Math = 88;\n\tstud[1].English = 99;\n\n\tstud[2].num = 201702;\n\t*stud[2].name = \"ZhangDajiang\";\n\t*stud[2].sex = \"man\";\n\tstud[2].age = 23;\n\tstud[2].Chinese = 90;\n\tstud[2].Math = 85;\n\tstud[2].English = 78;\n\n\tstud[3].num = 201703;\n\tstud[3].name[Maxsize] = \"LiTiemei\";\n\tstud[3].sex[Maxsize] = \"woman\";\n\tstud[3].age = 22;\n\tstud[3].Chinese = 95;\n\tstud[3].Math = 88;\n\tstud[3].English = 89;\n\n\tprintf(\"输入后两个学生的信息（空格分隔，每行一人）：\\n\\n\");\n\tprintf(\"学号   姓名   性别   年龄   语文   数学   英语\\n\\n\");\n\tinput(stud + 4);\n\tinput(stud + 5);\n\tprint_all(stud, 5);\n}\n\n\n\n", "\n\n", "但是运行的结果中，原本有的前三个成员的名字和性别都是乱码，成绩学号什么的都没问题，哪出了问题搞不明白，求助！"]], "Tag": "程序设计"}
{"Answer": "由于C#结构体不能引用自身,所以我用IntPtr代替\r\nIntPtr next\r\n\r\nMarshal.PtrToStructure()读取", "Konwledge_Point": "数据封装——结构体", "Question": ["c#如何创建链表的结构体(struct)", ["例如c++中的结构体为", "\n\n", "typedef struct aa\n{\n     int x,\n     struct aa *next;\n};\n", "\n\n", "这个结构在c#中不使用指针应该如何定义为struct呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;定义一个姓名数组和票数数组。没输入一个名字&amp;#xff0c;检查姓名数组中有没有&amp;#xff0c;有则票数加1&amp;#xff0c;无则增加一个新的名字&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;],nm[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; count[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,nm]);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;k;j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(name[j],nm) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                  count[j]&amp;#43;&amp;#43;;\n                  &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(j&amp;#61;&amp;#61;k)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(name[k],num);\n            count[k] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k&amp;#43;&amp;#43;;\n        }\n    }\n    j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;k;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(count[i] &amp;gt; count[j])\n            j &amp;#61; i;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,name[j]);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言智能结构体 候选人得票结果统计", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;First off you cannot assign/initialize inside the struct. The := operator declares and assigns. You can however, achieve the same result simply.&lt;/p&gt;\n\n&lt;p&gt;Here is a simple, trivial example that would do roughly what you're trying:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type house struct {\n    s []string\n}\n\nfunc main() {\n    h := house{}\n    a := make([]string, 3)\n    h.s = a\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I've never written one that way, but if it servers your purpose... it compiles anyway.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["去：在结构体中声明一个切片？", ["\n\n", "I have the following code:", "\n\n", "type room struct {\n    width float32\n    length float32\n}\ntype house struct{\n    s := make([]string, 3)\n    name string\n    roomSzSlice := make([]room, 3)\n} \n\nfunc main() {\n\n\n}\n", "\n\n", "And when i try to build and run it i get the following errors:", "\n\n", "c:\\go\\src\\test\\main.go:10: syntax error: unexpected :=\nc:\\go\\src\\test\\main.go:11: non-declaration statement outside function body\nc:\\go\\src\\test\\main.go:12: non-declaration statement outside function body\nc:\\go\\src\\test\\main.go:13: syntax error: unexpected }\n", "\n\n", "What did i do wrong?", "\n\n", "Thanks!", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Human&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year;\n}human;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Nerbor&lt;/span&gt; \n{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; number;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Human&lt;/span&gt; human;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printS&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Nerbor *nerbor)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printS&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Nerbor *nerbor)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%ld %s %d&amp;#34;&lt;/span&gt;,nerbor-&amp;gt;number,nerbor-&amp;gt;human.name,nerbor-&amp;gt;human.year);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%ld %s %d&amp;#34;&lt;/span&gt;,(nerbor&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)-&amp;gt;number,(nerbor&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)-&amp;gt;human.name,(nerbor&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)-&amp;gt;human.year);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Nerbor&lt;/span&gt; *him;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Nerbor&lt;/span&gt; nerbor[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;302039823&lt;/span&gt;,{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;John&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1985&lt;/span&gt;}},{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;302039776&lt;/span&gt;,{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Alice&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2000&lt;/span&gt;}}};\n    him &amp;#61; &amp;amp;nerbor[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n    &lt;span class=\"hljs-built_in\"&gt;printS&lt;/span&gt;(him);\n    &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/901044195536132.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将结构体传入函数是发生的错误", ["代码如下：", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<windows.h>", "\n", "void", " ", "printS", "(", "struct", " Nerbor *nerbor)", ";\n", "void", " ", "printS", "(", "struct", " Nerbor *nerbor)", "\n", "{\n    ", "printf", "(", "\"%ld %s %d\"", ",nerbor->number,nerbor->human.name,nerbor->human.year);\n    ", "printf", "(", "\"%ld %s %d\"", ",(nerbor+", "1", ")->number,(nerbor+", "1", ")->human.name,(nerbor+", "1", ")->human.year);\n}\n", "struct", " ", "Nerbor", " \n{\n    ", "long", " number;\n    ", "struct", " ", "Human", " human;\n};\n\n", "struct", " ", "Human", "\n{\n    ", "char", " name[", "10", "];\n    ", "int", " year;\n}human;\n\n\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "struct", " ", "Nerbor", " *him;\n    ", "struct", " ", "Nerbor", " nerbor[", "2", "] = {{", "302039823", ",{", "\"John\"", ",", "1985", "}},{", "302039776", ",{", "\"Alice\"", ",", "2000", "}}};\n    him = &nerbor[", "0", "];\n    ", "printS", "(him);\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n", "\n", "报错如下：", "invalid use of incomplete type 'struct Nerbor'；", "应输入标识符；", "field 'human' has incomplete type 'Human'；"]], "Tag": "程序设计"}
{"Answer": "首先，其实你是忘记了C++的基础问题，C++里面只要涉及char都不能直接通过“=”来赋值，因为C++里面没有提供这个功能。必须使用str开头的函数。\r\n只有后来的CString重载来“-，+，=”之后才可以怎么方便的使用。CString str；str=“sasa\";.\r\n其次，t1.name=\"abc\";//报错为什么？name[20]是一个20大小的内存空间，而”abc“是一个常量匿名字符串的地址，现在你应该明白了.\r\n你把一个地址赋值给了数组，也就是说现在char[20]=\"0x51825182\"之类的，get it !\r\n最后，oyljerry 说的数组声明时候的初始化   应该被采纳！", "Konwledge_Point": "数据封装——结构体", "Question": ["数组赋值和结构体中的数组赋值问题", [" typedef struct _Teacher{\n  char name[20];\n  int age;\n}Teacher;\nvoid main(){\n    Teacher t1;\n        t1.age=20;\n        t1.name=\"abc\";//报错为什么？\n\n        char name[20]=\"abc\";//不报错\n\n}\n", "\n\n", "求大牛给个详细的解释，对于abc  C++编译器是如何处理的？是分配内存放在全局区，还是当做字面值"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;staff&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; salary;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;staff&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;staff&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; vnum,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *vname,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; vage,&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; vsalary);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n};\n\nstaff::&lt;span class=\"hljs-built_in\"&gt;staff&lt;/span&gt;()\n{\n    num&amp;#61;age&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    salary&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(name,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;);\n}\n    \nstaff::&lt;span class=\"hljs-built_in\"&gt;ssaff&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; vnum,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *vname,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; vage,&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; vsalary)\n{\n    num&amp;#61;vnum;\n    &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(name,vname);\n    age&amp;#61;vage;\n    salary&amp;#61;vsalary;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;staff::print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    cout&amp;lt;&amp;lt;num&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;age&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;salary&amp;lt;&amp;lt;endl;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体改成类的问题 怎么实现呢", ["如果雇员定义的是一个类（结构体改成类", "怎么用文件呢", "\n", "\n", "//1） 将五名员工的数据（包括员工编号、姓名、年龄和工资）按员工编号从小到大的顺序输出到磁盘文件中保存。", "\n", "//（2） 从键盘输入一名员工的数据（员工编号大于现有员工编号），并将其添加到文件末尾。", "\n", "//（3） 输出文件中所有员工的数据。", "\n", "//（4） 从键盘输入一个数字，以确定文件中是否有此员工编号。如果是，将显示该员工的所有数据。如果没有，则输出“无人发现”。您可以重复查询。如果输入的员工编号为0，则查询将结束。", "\n", "#", "include", "<bits/stdc++.h>", "\n", "#", "include", " ", "<fstream>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "staff", "{\n    ", "int", " num;\n    ", "char", " name[", "20", "];\n    ", "int", " age;\n    ", "double", " salary;\n};\n", "int", " ", "main", "()", "{\n    staff staff_[", "7", "]={\n    ", "2001", ",", "\"Li\"", ",", "25", ",", "8500", ",\n    ", "2002", ",", "\"Wang\"", ",", "26", ",", "9000", ",\n    ", "2003", ",", "\"Zhang\"", ",", "27", ",", "9500", ",\n    ", "2004", ",", "\"Liu\"", ",", "28", ",", "9600", ",\n    ", "2005", ",", "\"Zheng\"", ",", "26", ",", "10000.1", "},staff_1;\n    ", "fstream ", "iofile", "(", "\"staff.dat\"", ",ios::in | ios::out|ios::binary)", "; ", "//以读写模式打开", "\n    ", "if", "(!iofile){ ", "//用is_open()判断是否打开", "\n        cerr<<", "\"open error!\"", "<<endl;\n        ", "abort", "();\n    }\n    ", "int", " num;\n    cout<<", "\"Five staff:\"", "<<endl;\n    ", "for", "(", "int", " i=", "0", ";i<", "5", ";i++){\n        cout<<staff_[i].num<<", "\" \"", "<<staff_[i].name<<", "\" \"", "<<staff_[i].age<<", "\" \"", "<<staff_[i].salary<<endl;\n        iofile.", "write", "((", "char", "*)&staff_[i],", "sizeof", "(staff_[i]));", "//写入文件 ", "\n    }\n    cout<<", "\"Please input the staff's information that you want to insert\"", "<<endl;\n        cin>>staff_1.num>>staff_1.name>>staff_1.age>>staff_1.salary;\n        iofile.", "write", "((", "char", "*)&staff_1,", "sizeof", "(staff_1));\n    cout<<", "\"All the staff\"", "<<endl;\n \n    iofile.", "seekg", "(", "0", ",ios::beg);\n    ", "int", " ntotal = ", "0", ";\n    ", "while", "(!iofile.", "eof", "())\n    { ", "//这里用eof判断是否读取结束", "\n        iofile.", "read", "((", "char", "*)&staff_[ntotal],", "sizeof", "(staff_[ntotal]));\n        \n        ", "if", "(staff_[ntotal].num > ", "0", " && staff_[ntotal].age>", "0", " && staff_[ntotal].salary>", "0", ")\n        {\n            cout<<staff_[ntotal].num<<", "\" \"", "<<staff_[ntotal].name<<", "\" \"", "<<staff_[ntotal].age<<", "\" \"", "<<staff_[ntotal].salary<<endl;\n            ntotal++;\n        }\n    }\n    iofile.", "close", "();\n    cout<<", "\"Please input the number that you want to search\"", "<<endl;\n    cin>>num;\n    ", "int", " flag=", "0", ";\n    ", "while", "(flag ==", "0", ")\n    {\n        ", "for", "(", "int", " i=", "0", ";i<ntotal;i++){\n            ", "if", "(num==staff_[i].num){\n                cout<<num<<", "\"is No.\"", "<<i+", "1", "<<endl;\n                cout<<staff_[i].num<<", "\" \"", "<<staff_[i].name<<", "\" \"", "<<staff_[i].age<<", "\" \"", "<<staff_[i].salary<<endl;\n                flag=", "1", ";\n                ", "break", ";\n            }\n        }\n        ", "if", "(flag==", "0", "){\n            cout<<", "\"can't find!\"", "<<endl;\n            cout<<", "\"Please input again or enter 0 to stop!\"", "<<endl;\n            cin>>num;\n        }\n    }\n    \n    \n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "字符串只有在声明的时候才能初始化，其它时候赋值只能一个字符一个字符的赋值，或者通过strcpy之类的函数。\n改成：struct std student ={\"abcf\"};", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体方面的问题", ["小弟初学者在编程的时候遇到了一个问题", "\nstruct   std{", "\nchar  nane[4];", "\n};", "\nstruct  std  student;", "\nstudent.name={a,c,f,g};", "\n\n", "这个样子的问题是不是那里搞错了。。。。为什么会提示错误啊！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不要直接用String类型。用char数组。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;        &lt;span class=\"hljs-keyword\"&gt;string&lt;/span&gt; s;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(getline(infile,s))\n        {\n        char a[&lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;];\n        &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt; &amp;#61; s.&lt;span class=\"hljs-built_in\"&gt;copy&lt;/span&gt;(a,&lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;);\n        send(conn,a,&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        }\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c++socket传含有string类型的", ["为什么我用socket传含有string类的结构体总是会出现乱码啊", "昨天一模一样的写法还可以正确传输", "现在却不行了"]], "Tag": "程序设计"}
{"Answer": "要看看完整的代码，你是不是除了函数的定义，前面还有一个函数原型声明，而那里的参数类型不对", "Konwledge_Point": "数据封装——结构体", "Question": ["编译器报错显示函数不接受结构体变量的参数怎么办？", ["\n\n", "大一的新生刚刚学C语言，做一个通讯录管理系统，在主菜单mean函数中调用了添加联系人函数add_per，可是显示不接受参数，怎么办怎么办？希望能详细点回答，希望有好心人路过帮忙解答一下呀qwq，谢谢~~~~~"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;虽然我没有自己验证过&amp;#xff0c;但是希望这篇文章对你有帮助&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/yeditaba/article/details/77991341\" id=\"textarea_1644542670819_1644542885796_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/yeditaba/article/details/77991341&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义一个结构体，有一个int（四位）和一个char（一位）类型数据，那么在Linux系统中占几位", ["感谢各位大佬🧍‍♂️🥳🥳🥳🥳🥳🥳🥳🥳🥳🥳🥳"]], "Tag": "程序设计"}
{"Answer": "结构体在32bit编译器上一般为了优化性能，会按照4字节对齐，所以虽然short只有两个字节，但是后面的两个字节会被浪费掉，而不是存下面一个double", "Konwledge_Point": "数据封装——结构体", "Question": ["一个结构体长度的问题.大佬们来一发啊", ["\n下面是结果.", "\n\n", "请问这是为什么呢？？？  "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Decode the JSON directly to types you want instead of decoding to an &lt;code&gt;interface{}&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Declare types that match the structure of your JSON data. Use structs for JSON objects and slices for JSON arrays:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type transform struct {\n    // not enough information in question to fill this in.\n}\n\ntype urlTransform struct {\n    Item string\n    Transform transform\n}\n\nvar transforms []urlTransform\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The field names must be &lt;a href=\"https://golang.org/ref/spec#Exported_identifiers\" rel=\"nofollow noreferrer\"&gt;exported&lt;/a&gt; (start with uppercase letter).&lt;/p&gt;\n\n&lt;p&gt;Unmarshal the JSON to the declared value:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;err := json.Unmarshal(data, &amp;amp;transforms)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;err := json.NewDecoder(reader).Decode(&amp;amp;transforms)\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在Golang中将interface {}转换为struct", ["\n\n我是Go的新手，正努力了解所有不同的类型以及如何使用它们。 我有以下接口（最初在json文件中）：\n\n", "[map[item:electricity transform:{fuelType}] map[transform:{fuelType} item:gas]]\n", "\n\n", "并且我有以下的结构：", "\n\n", "type urlTransform struct {\n        item string\n        transform string\n}\n", "\n\n", "我不知道如何将接口数据放入结构中。 我敢肯定这确实很愚蠢，但是我会一直努力。 有任何的帮助都将不胜感激。", "\n    "]], "Tag": "程序设计"}
{"Answer": "这里以vector为例，主要有两种方式：\r\n1.重载要排序的结构体或类的&lt;号或者&gt;号，演示代码如下：\r\n```\r\n#include&lt;vector&gt;\r\n#include&lt;algorIThm&gt;\r\nusing namespace std;\r\ntypedef struct ValuePerWeight //定义结构体\r\n{\r\n    double vw;\r\n    int i;\r\n    bool operator &lt;(const ValuePerWeight &amp;other)const   //升序排序\r\n    {\r\n        return vw&gt;other.vw;\r\n    }\r\n    //或者\r\n    bool operator &gt;(const ValuePerWeight &amp;r)const   //降序排序\r\n    {\r\n        return vw&gt;other.vw;\r\n    }\r\n}ValuePerWeight;\r\nint main(){\r\n    ValuePerWeight a1..an; \r\n    vector&lt;ValuePerWeight&gt; vpw ;\r\n    for(int i=1;i&lt;=n;i++){\r\n        ....\r\n        vpw.push_back(ai);//对a1到an处理后加到vpw\r\n    }\r\n    sort(vpw.begin(), vpw.end(),greater&lt;ValuePerWeight&gt;());//降序\r\n     \r\n    sort(vpw.begin(), vpw.end(),less&lt;ValuePerWeight&gt;());//升序\r\n    //默认情况为升序 sort(vpw.begin(), vpw.end())\r\n    ....\r\n    return 0;\r\n} \r\n```\r\n\r\n2.不修改结构体或类的定义部分，用函数对象来实现，演示代码如下：\r\n```\r\n #include&lt;vector&gt;\r\n#include&lt;algorIThm&gt;\r\n#include &lt;functional&gt; \r\n \r\nusing namespace std;\r\n \r\ntypedef struct ValuePerWeight//自定义结构体\r\n{\r\n    double vw;\r\n    int i;\r\n     \r\n}ValuePerWeight;\r\n//全局函数\r\nbool a_less_b(const ValuePerWeight&amp; r,const ValuePerWeight&amp; s)\r\n{\r\n    return r.vw &lt; s.vw;\r\n}\r\nbool a_greater_b(const ValuePerWeight&amp; r,const ValuePerWeight&amp; s)\r\n{\r\n    return r.vw &gt; s.vw;\r\n}\r\nint main(){\r\n    ValuePerWeight a1..an; \r\n    vector&lt;ValuePerWeight&gt; vpw ;\r\n    for(int i=1;i&lt;=n;i++){\r\n        ....\r\n        vpw.push_back(ai);//对a1到an处理后加到vpw\r\n    }\r\n    sort(vpw.begin(), vpw.end(),a_less_b);   //升序排序\r\n     \r\n    sort(vpw.begin(), vpw.end(),a_greater_b); //降序排序\r\n \r\n    ....\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C++库函数对结构体排序，排序顺序紊乱的问题", ["C++库函数怎么样对结构体的数组数组排序，同时要避免结果出现紊乱的弊端！代码的思路和方式"]], "Tag": "程序设计"}
{"Answer": "sturct my()  结构体定义没有括号的吧。", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中头文件的问题怎么解决求答案", ["头文件中有：", "\nsturct my()", "\n{", "\nint h;", "\nint hao[20]", "\nmy()", "\n{", "\nh=0;", "\n}", "\n\n", "}uo;", "\n把这一代码放入头文件中在cpp中编译错误说找到一个或多个重定义符号", "\n错误说uo  "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"hljs language-cpp\"&gt;typedef struct person{\n\tint num;\n\tchar name[20];\n};\n\nint main()\n{\n\tperson ps[5];\n\tperson p;\n\tint i,j;\n\tfor(i&amp;#61;0;i&amp;lt;5;i&amp;#43;&amp;#43;)\n\t{\n\t\tscanf(&amp;#34;%d&amp;#34;,&amp;amp;(ps[i].num));\n\t\tscanf(&amp;#34;%s&amp;#34;,ps[i].name);\n\t}\n\t for (i &amp;#61; 0; i &amp;lt; 5; i&amp;#43;&amp;#43;)\n    {\n        for (j &amp;#61; 0; j &amp;lt; 4 - i; j&amp;#43;&amp;#43;)\n        {\n            if (ps[j].num &amp;gt; ps[j &amp;#43; 1].num) \n            {\n                p &amp;#61; ps[j];\n                ps[j] &amp;#61; ps[j &amp;#43; 1];\n                ps[j &amp;#43; 1] &amp;#61; p;\n            }\n        }\n    }\n\t for(i&amp;#61;0;i&amp;lt;5;i&amp;#43;&amp;#43;)\n\t\t printf(&amp;#34;%d,%s\\n&amp;#34;,ps[i].num,ps[i].name);\n\t\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言关于定义结构体", ["给出5个职工的姓名及编号，将编号从小到大排序，相应职工姓名也同时调整。上机运行并验证程序。\n\n【提示】\t定义结构体person 包含2个成员:\t num表示编号，\t name[20]表示姓名。\n\n struct person\n{\n int num;\nchar name[20];\n};"]], "Tag": "程序设计"}
{"Answer": "VB不支持指针，一般你可以定义成局部变量，这样函数退出会自动回收的。", "Konwledge_Point": "数据封装——结构体", "Question": ["Visula Basic 6.0语言调用C++ struct结构体中的字符串问题", ["VB6调用C++ DLL结构体struct中的字符串，内存预分配的写法是什么，内存回收怎么做？VB不能用指针的谢谢"]], "Tag": "程序设计"}
{"Answer": "继承是类和类之间才有的关系，写法上是\r\n\r\n```class/struct MyClassName:public/protected/private BaseClassName\r\n{\r\n\t//类定义\r\n}\r\n \r\n```\r\n这种形式。意思是MyClassName继承自BaseClassName。你写的那句话的意思是**定义一个MultiCopter类的对象**，名字是aparm。由于MultiCopter类是嵌套类，因此要在前面加上外层类的类名和\"::\"作用域选择符。", "Konwledge_Point": "数据封装——结构体", "Question": ["一个类中内嵌两个结构体", ["class AP_Vehicle {", "\n\n", "public:", "\n    /*", "\n      common parameters for fixed wing aircraft", "\n     */", "\n    struct FixedWing {", "\n        AP_Int8 throttle_min;", "\n        AP_Int8 throttle_max;", "\n        AP_Int8 throttle_slewrate;", "\n        AP_Int8 throttle_cruise;", "\n        AP_Int16 airspeed_min;", "\n        AP_Int16 airspeed_max;", "\n        AP_Int16 pitch_limit_max_cd;", "\n        AP_Int16 pitch_limit_min_cd;", "\n        AP_Int8  autotune_level;", "\n        AP_Int16 land_pitch_cd;", "\n    };", "\n\n", "/*\n  common parameters for multicopters\n */\nstruct MultiCopter {\n    AP_Int16 angle_max;\n};\n", "\n\n", "};", "\n一个类中内嵌两个结构体，", "\nstatic AP_Vehicle::MultiCopter aparm; //这个静态函数用来定义", "\n这里的定义意思应该是aparm函数继承了MultiCopter的属性。", "\n这样理解对吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;可以查看手册&amp;#xff1a;&lt;a href=\"https://zh.cppreference.com/w/c/language/function_definition\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;c语言-函数定义&lt;/font&gt;&lt;/a&gt; 中的内容&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在结构体定义时别名定义后本命还能使用吗", ["在结构体定义时别名定义后本命还能使用吗？", "那这种现象如何解释？我想不明白", "\n", "而这种的却可以正常运行", "\n", "\n", "是这两个文件后缀不同的原因吗？ 第一个为.c", "                                                       第二个为.cpp"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;栈溢出了&amp;#xff0c;根据你的运行提示&amp;#xff0c;3221225725 是字节&amp;#xff0c;你可以算一下&amp;#xff0c;差不多3G,。&lt;br /&gt;一般来说&lt;br /&gt;函数内申请的变量&amp;#xff0c;数组&amp;#xff0c;是在栈&amp;#xff08;stack&amp;#xff09;中申请的一段连续的空间。栈的默认大小为2M或1M&amp;#xff0c;开的比较小&amp;#xff1b;当然linux和window是有区别&amp;#xff0c;但也不大&amp;#xff0c;linux默认是8M&lt;/p&gt;\n&lt;p&gt;全局变量&amp;#xff0c;全局数组&amp;#xff0c;静态数组&amp;#xff08;static&amp;#xff09;则是开在全局区&amp;#xff08;静态区&amp;#xff09;&amp;#xff08;static&amp;#xff09;。大小为2G&amp;#xff0c;所以能够开的很大&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;而malloc、new出的空间&amp;#xff0c;则是开在堆&amp;#xff08;heap&amp;#xff09;的一段不连续的空间。理论上则是硬盘大小&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;数组很大的情况下通常使用new动态内存分配。&lt;br /&gt;你可以sizeof(struct bign)计算一下一个bign是多少字节&amp;#xff0c;我算了下是4000024字节&amp;#xff0c;也就是差不多4M&amp;#xff0c;我想你的代码可能使用了有接近800多个struct bign吧。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体里面的数组开大了为什么会奔溃啊", ["问题相关代码，请勿粘贴截图", "\n", "struct", " bign {\n    ", "int", " d[", "100005", "];\n    ", "int", " ", "len", ";\n    bign() {\n        memset(d, ", "0", ", sizeof(d));\n        ", "len", " = ", "0", ";\n    }\n};\n", "\n", "运行结果及报错内容", "\n", "当我把上面这个d数组开到1000005的时候，就出现了下面这种情况", "\n", "\n", "下面是完整的代码：", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cmath>", "\n", "#", "include", " ", "<algorithm>", "\n", "#", "include", " ", "<cstring>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "bign", " {\n    ", "int", " d[", "1000005", "];\n    ", "int", " len;\n    ", "bign", "() {\n        ", "memset", "(d, ", "0", ", ", "sizeof", "(d));\n        len = ", "0", ";\n    }\n};\n", "bign ", "change", "(", "char", " str[])", " ", "{\n    bign c;\n    c.len = ", "strlen", "(str);\n    ", "for", " (", "int", " i = ", "0", "; i < c.len; i++) {\n        c.d[i] = str[c.len - i - ", "1", "] - ", "'0'", "; \n    }\n    ", "return", " c;\n}\n", "bign ", "multi", "(bign a, ", "int", " b)", " ", "{\n    bign c;\n    ", "int", " carry = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < a.len; i++) {\n        ", "int", " temp = a.d[i] * b + carry;\n        c.d[c.len++] = temp % ", "10", ";\n        carry = temp / ", "10", ";\n    }\n    ", "while", " (carry != ", "0", ") {\n        c.d[c.len++] = carry % ", "10", ";\n        carry /= ", "10", ";\n    }\n    ", "return", " c;\n}\n", "void", " ", "print", "(bign a)", " ", "{\n    ", "for", " (", "int", " i = a.len - ", "1", "; i >= ", "0", "; i--) \n        ", "printf", "(", "\"%d\"", ", a.d[i]);\n    ", "printf", "(", "\"\\n\"", ");\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " n;\n    ", "while", " (cin >> n) {\n        ", "if", " (n == ", "0", ") cout << ", "1", " << endl;\n        ", "else", " {\n            bign ans;\n            ans.d[", "0", "] = ", "1", "; ans.len = ", "1", ";\n            ", "for", " (", "int", " i = ", "2", "; i <= n; i++) {\n                ans = ", "multi", "(ans, i);\n            }\n            ", "print", "(ans);\n        }\n    }\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include &lt;stdlib.h&gt;\r\n#include &lt;stdio.h&gt;\r\n\r\ntypedef struct {\r\n    char name[20];\r\n    int math;\r\n    int eng;\r\n    int db;\r\n} Student;\r\n\r\nvoid SetZero(Student&amp; s)\r\n{\r\n    s.math = 0;\r\n    s.eng = 0;\r\n    s.db = 0;\r\n}\r\n\r\nStudent* SetZero1(Student s)\r\n{\r\n    Student *p = (Student *)malloc(sizeof(Student));\r\n    memcpy(p, &amp;s, sizeof(Student));\r\n    p-&gt;math = 0;\r\n    p-&gt;eng = 0;\r\n    p-&gt;db = 0;\r\n    return p;\r\n}\r\n\r\nint main()\r\n{\r\n    Student s;\r\n    s.math = 100;\r\n    printf(\"%d\\n\", s.math);\r\n    SetZero(s);\r\n    printf(\"%d\\n\", s.math);\r\n    s.math = 100;\r\n    printf(\"%d\\n\", s.math);\r\n    s = *SetZero1(s);\r\n    printf(\"%d\\n\", s.math);\r\n    return 0;\r\n}\r\n```\r\n\r\n100\r\n0\r\n100\r\n0", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C++结构体的问题(新手)", ["结构体清零有什么函数可以用么？还有用引用来调用。。如题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;同一转换成毫秒计算差值&amp;#xff0c;然后再转成天、小时、分钟、秒、毫秒。&lt;br /&gt;两个测试运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/466221845276132.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/228031845276168.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_date&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year, mon, day;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; hour, min, sec;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ms; \n}Date;\n\n&lt;span class=\"hljs-comment\"&gt;//判断是否是闰年&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;isleapyear&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (year % &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; year % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || year % &lt;span class=\"hljs-number\"&gt;400&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//计算两个日期之间相差的毫秒数&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Date d1, Date d2)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; mon[] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;28&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt; };\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; sec &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; n1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, n2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    Date t;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.year &amp;gt; d2.year)\n    {\n        t &amp;#61; d1;\n        d1 &amp;#61; d2;\n        d2 &amp;#61; t;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;isleapyear&lt;/span&gt;(d1.year))\n        mon[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;29&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//计算d1本年已经过了多少秒&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; d1.mon; i&amp;#43;&amp;#43;)\n        n1 &amp;#43;&amp;#61; mon[i];\n    n1 &amp;#61; n1 * &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;* &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//转成秒数&lt;/span&gt;\n    n1 &amp;#61; n1 &amp;#43; (d1.day - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt; &amp;#43; d1.hour * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt; &amp;#43; d1.min * &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt; &amp;#43; d1.sec;\n    &lt;span class=\"hljs-comment\"&gt;//转毫秒&lt;/span&gt;\n    n1 &amp;#61; n1 * &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt; &amp;#43; d1.ms;\n\n    &lt;span class=\"hljs-comment\"&gt;//计算d2到d1的差值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; d1.year; i &amp;lt; d2.year; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;isleapyear&lt;/span&gt;(i))\n            n2 &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;366&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            n2 &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;365&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;isleapyear&lt;/span&gt;(d2.year))\n        mon[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;29&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        mon[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;28&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; d2.mon; i&amp;#43;&amp;#43;)\n    {\n        n2 &amp;#43;&amp;#61; mon[i];\n    }\n    n2 &amp;#43;&amp;#61; d2.day - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//得到天数&lt;/span&gt;\n    n2 &amp;#61; n2 * &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt; &amp;#43; d2.hour * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt; &amp;#43; d2.min * &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt; &amp;#43; d2.sec; &lt;span class=\"hljs-comment\"&gt;//得到秒数&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//转毫秒&lt;/span&gt;\n    n2 &amp;#61; n2 * &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt; &amp;#43; d2.ms;\n\n    sec &amp;#61; n2 - n1;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sec; &lt;span class=\"hljs-comment\"&gt;//返回两者差的毫秒数&lt;/span&gt;\n}\n\n\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Date d1, d2;\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; s &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; day, hour, min, sec, ms;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入时间1的年 月 日 时 分 秒 毫秒&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d %d %d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;d1.year, &amp;amp;d1.mon, &amp;amp;d1.day, &amp;amp;d1.hour, &amp;amp;d1.min, &amp;amp;d1.sec,&amp;amp;d1.ms);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入时间2的年 月 日 时 分 秒 毫秒&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d %d %d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;d2.year, &amp;amp;d2.mon, &amp;amp;d2.day, &amp;amp;d2.hour, &amp;amp;d2.min, &amp;amp;d2.sec,&amp;amp;d2.ms);\n\n    s &amp;#61; &lt;span class=\"hljs-built_in\"&gt;cmp&lt;/span&gt;(d1,d2);\n    ms &amp;#61; s % &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//毫秒数&lt;/span&gt;\n\n    s &amp;#61; s / &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//转成秒&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//计算天&lt;/span&gt;\n    day &amp;#61; s / (&lt;span class=\"hljs-number\"&gt;24&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt;);\n    s -&amp;#61; day * &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//计算小时&lt;/span&gt;\n    hour &amp;#61; s / &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt;;\n    s -&amp;#61; hour * &lt;span class=\"hljs-number\"&gt;3600&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//计算分钟&lt;/span&gt;\n    min &amp;#61; s / &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;;\n    s -&amp;#61; min * &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//计算秒&lt;/span&gt;\n    sec &amp;#61; s;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;两个时间的时间差&amp;#xff1a;%d天%d小时%d分钟%d秒%dms&amp;#34;&lt;/span&gt;, day, hour, min, sec, ms);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于#c语言#的问题：定义一个表示日期、时间的结构体，输入任意两个时间，计算两个时间的时间差(天、 小时、分钟、秒、ms)", ["定义一个表示日期、时间的结构体，输入任意两个时间，计算两个时间的时间差(天、 小时、分钟、秒、ms)"]], "Tag": "程序设计"}
{"Answer": "应该是声明一个结构体对象", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体名后面有个“=”是什么意思？", ["请教下下面代码fops后面那个“=”是什么意思？", "\n\n", " static const struct file_operations mem_fops =\n{\n  .llseek = mem_llseek,\n  .read = mem_read,\n  .write = mem_write,\n  .open = mem_open,\n  .release = mem_release,\n};\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里应该是j&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"459\" src=\"https://img-ask.csdnimg.cn/upload/1623251403264.png\" width=\"573\" /&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["我用指向结构体的指针变量作形参输出结构体，不对，求大佬帮忙找找问题。", ["\n", "#include<stdio.h>\nstruct study \n{\n    char name[20];\n    char number[20];\n    char subject[20];\n    int score;\n } ; \n \n void Input(struct study *p)\n {\n     scanf(\"%s%s%s%d\",p->name,p->number,p->subject,&p->score);\n }\n \n void Print(struct study *p)\n {\n     printf(\"%s\\t%s\\t%s\\t%d\\n\",p->name,p->number,p->subject,p->score);\n }\n \n int main()\n {\n     int i,j,k;\n     struct study si[3];\n     \n     for(i=0;i<3;i++)\n     {\n         printf(\"Please input student' information:\\n\");\n         Input(&si[i]);\n     }\n     \n     for(j=0;j<3;j++)\n     {\n         Print(&si[i]);\n     }\n     return 0;\n }"]], "Tag": "程序设计"}
{"Answer": "```\r\nvoid myInitialMap(int **my_map, int n)\r\n{\r\n    my_map = (int **)malloc(sizeof(int*) * n); // 这句对传入的参数my_map没有影响\r\n    for(int i=0;i&lt;n;++i){\r\n        my_map[i] = (int*)malloc(sizeof(int) * n);\r\n    }\r\n\r\n    int count=0;\r\n}\r\n```\r\n这一段代码有问题，应该改为\r\n\r\n```\r\nvoid myInitialMap(int ***my_map, int n) // 调用的时候使用&amp;item.my_map\r\n{\r\n    *my_map = (int **)malloc(sizeof(int*) * n);\r\n    for(int i=0;i&lt;n;++i){\r\n        (*my_map)[i] = (int*)malloc(sizeof(int) * n);\r\n    }\r\n\r\n    int count=0;\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言，每次执行到给结构体内的二维数组成员变量赋值时程序就崩溃了，有大佬知道原因吗", ["结构体的声明", "\n\n", "struct IMPERIAL{\n    int **my_map;\n    int numVar;\n    void(*initialMap)(int **, int );\n    void(*clearMap)(int **, int );\n};\nvoid myInitialMap(int **my_map, int n)\n{\n    my_map = (int **)malloc(sizeof(int*) * n);\n    for(int i=0;i<n;++i){\n        my_map[i] = (int*)malloc(sizeof(int) * n);\n    }\n\n    int count=0;\n}\nvoid myClearMap(int **my_map, int n)\n{\n    for(int i=0;i<=n;i++) free(*(my_map + i));\n    free(my_map);\n}\n", "\n\n", "初始化", "\n\n", "int node;\n    char myInput[10];\n    for(int j=2;j<=item.numVar;j++)  \n        for(int i=1;i<j;i++){\n            scanf(\"%s\",myInput);\n            int b;\n            if(myInput[0]!='x')\n            {\n                sscanf(myInput,\"%d\",&node);\n                item.my_map[j][i]=node;\n                item.my_map[i][j]=item.my_map[j][i];\n            }\n        }\n", "\n\n", "每次一到 item.my_map[j][i]=node; 程序就崩溃了，不知道什么原因啊", "\n\n", "编译过了，没有报错，执行到这一步程序就会直接卡住"]], "Tag": "程序设计"}
{"Answer": "把实现和类定义放在同一个文件里（#include实现或者直接写在一个文件里），模板和内联一样，分开放的话链接的时候模板没法实例化", "Konwledge_Point": "数据封装——结构体", "Question": ["c++类模板，调用结构体模板出错！！", ["#ifndef _LIST_H_\n#define _LIST_H_\ntemplate <typename T>\nstruct Num {\n    T num;\n    Num *next;\n};\ntemplate <typename T>\nclass List {\nprivate:\n    Num<T>* pHead;\npublic:\n    List();\n    int count();\n    void create(T *a, int n);\n    void list_();\n    void add(T key, int n);\n    void Swapat(int a, int b);\n    void Swapnum(T num1, T num2);\n    int& at(int n);\n    void Sort();\n    void del(int n);\n    void delTheSame();\n\n};\n#endif\n", "\n\n", "\nSeverity    Code    Description Project File    Line", "\nError   LNK1120 3 unresolved externals  Test    C:\\Users\\Sar.Kerson\\Desktop\\Test1\\Test\\Debug\\Test.exe   1", "\nSeverity    Code    Description Project File    Line", "\nError   LNK2019 unresolved external symbol \"public: __thiscall List::List(void)\" (??0?$List@H@@QAE@XZ) referenced in function ", "main   Test    C:\\Users\\Sar.Kerson\\Desktop\\Test1\\Test\\Test\\main.obj    1", "\nSeverity    Code    Description Project File    Line", "\nError   LNK2019 unresolved external symbol \"public: void __thiscall List::create(int *,int)\" (?create@?$List@H@@QAEXPAHH@Z) referenced in function _main   Test    C:\\Users\\Sar.Kerson\\Desktop\\Test1\\Test\\Test\\main.obj    1", "\nSeverity    Code    Description Project File    Line", "\nError   LNK2019 unresolved external symbol \"public: void __thiscall List::list", "(void)\" (?list_@?$List@H@@QAEXXZ) referenced in function _main  Test    C:\\Users\\Sar.Kerson\\Desktop\\Test1\\Test\\Test\\main.obj    1", "\n\n", "求助大侠这是怎么回事？！（以下为几个报错函数的实现）", "\n\n", "template <typename T>\nList<T>::List() {\n    pHead = NULL;\n}\ntemplate <typename T>\nvoid List<T>::create(T *a, int n) {\n    Num<T> *pTail = NULL;\n    for (int i = 0; i < n; ++i) {\n        Num<T> *t = new Num<T>;\n        t->num = a[i];\n        t->next = NULL;\n        if (pHead == NULL) {\n            pHead = t;\n            pTail = pHead;\n        }\n        else {\n            pTail->next = t;\n            pTail = t;\n        }\n    }\n}\ntemplate <typename T>\nvoid List<T>::list_() {\n    Num<T> *t = pHead;\n    while (t != NULL) {\n        cout << t->num << \" \";\n        t = t->next;\n    }\n    cout << endl;\n}\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个题目任何一本书上举的例子都是这个学生学号&amp;#xff0c;年龄的问题&amp;#xff0c;成绩的问题&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["程序代码应该怎么用结构体实现啊？想要全部代码", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;br /&gt;#define N 100&lt;br /&gt;typedef struct&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int yu;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int shu;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int wai;&lt;/span&gt;&lt;br /&gt;}cj;&lt;br /&gt;void input(cj s[],int n);&lt;br /&gt;void sort(cj s[],int n);&lt;br /&gt;int main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    cj s[N];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int n,i&amp;#61;0;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    scanf(&amp;#34;%d&amp;#34;,&amp;amp;n);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    input(s,n);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    sort(s,n);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(i&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        printf(&amp;#34;%d\\n&amp;#34;,s[i].yu&amp;#43;s[i].shu&amp;#43;s[i].wai);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    return 0;&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;void input(cj s[],int n)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int i&amp;#61;0;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(i&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;s[i].yu,&amp;amp;s[i].shu,&amp;amp;s[i].wai);&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;void sort(cj *s,int n)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int i,j;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(i&amp;#61;0;i&amp;lt;n-1;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;         for(j&amp;#61;0;j&amp;lt;n-1;j&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;         {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;             if(s[j].shu&amp;#43;s[j].wai&amp;#43;s[j].yu&amp;lt;s[j&amp;#43;1].shu&amp;#43;s[j&amp;#43;1].wai&amp;#43;s[j&amp;#43;1].yu)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;             {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                 cj temp&amp;#61;s[j];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                 s[j]&amp;#61;s[j&amp;#43;1];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                 s[j&amp;#43;1]&amp;#61;temp;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;             }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;         }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     }&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;//这是修改后的版本&amp;#xff0c;有啥问题可以关注我&amp;#xff0c;私信互相交流&amp;#xff0c;随时回复&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体成绩排序遇到了一些问题", ["问题遇到的现象和发生背景", "\n", "不知道哪里错了，", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include<stdio.h>\n#define ", "N", " ", "100", "\ntypedef struct\n{\n    int yu[", "6", "];\n    int shu[", "6", "];\n    int wai[", "6", "];\n}cj;\nvoid input(cj s[],int n);\nvoid sort(cj s[],int n);\nint main()\n{\n    cj s[", "N", "];\n    int n,i=", "0", ";\n    scanf(", "\"%d\"", ",&n);\n    input(s,n);\n    sort(s,n);\n    for(i=", "0", ";i<n;i++)\n    {\n        printf(", "\"%d\\n\"", ",s[i].yu+s[i].shu+s[i].wai); \n    }\n    return ", "0", ";\n}\nvoid input(cj s[],int n)\n{\n    int i=", "0", ";\n    for(i=", "0", ";i<n;i++)\n    scanf(", "\"%d%d%d\"", ",&s[i].yu,&s[i].shu,&s[i].score);\n}\nvoid sort(cj s[],int n)\n{\n    int i,j;\n    cj temp;\n    for(i=", "0", ";i<n", "-1", ";i++)\n     for(j=i+", "1", ";j<n;j++) \n     {if(s[j].yu+s[j].shu+s[j].wai>s[i].yu+s[i].shu+s[i].wai)\n      {      \n      temp=s[i];\n      s[i]=s[j];\n      s[j]=temp;\n      }\n      \n      else if(s[j].yu+s[j].shu+s[j].wai=s[i].yu+s[i].shu+s[i].wai)\n      {\n          if(s[j].yu>s[i].yu)\n      {\n      temp=s[i];\n      s[i]=s[j];\n      s[j]=temp；          \n      }      \n    } \n      }\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;传入的不是类/结构体&amp;#xff0c;而是空对象。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["golang的结构体，类似Java中的类，相当于创造对象的模子，直接作为实参传入的作用是什么？", ["\nerr := gen.WriteTupleEncodersToFile(\"./chain/types/cbor_gen.go\", \"types\",\n   types.BlockHeader{},//问题：这里传的是什么？为什么这么传？结构体，类似Java中的类，相当于创造对象的模子，直接作为实参传入的作用是什么？\n   types.Ticket{},)"]], "Tag": "程序设计"}
{"Answer": "这个一般是链表中定义一个结点用到的结构体\r\nstruct node* next的意思就是定义了一个指针叫next,这个next指针指向的元素的类型是struct node *\r\n这个next指针一般是指向链表的下一个结点（如果已经是最后一个结点就为NULL）", "Konwledge_Point": "数据封装——结构体", "Question": ["Ｃ结构体定义问题　struct　求详解", ["typedef struct node", "\n{", "\n  int data;", "\n  struct node* next;// 这个地方注意结构体变量的定义规则", "\n} Node, *PNode;", "\n\n", "struct node* next 这句看不懂啊，有没有大神帮忙详解一下。"]], "Tag": "程序设计"}
{"Answer": "BYTE bNodeaddr[6];  \r\n    DWORD dwIp;  \r\n这两个写反了\r\n而且考虑到数据对齐，bNodeaddr可能占用的是8个字节，具体你调试的时候看下内存", "Konwledge_Point": "数据封装——结构体", "Question": ["C#调用C++ Dll 返回信息与C++返回结构体中信息不一致？", ["各位大佬，小弟遇到一个很难理解的问题，情况如下：", "\n    C++ 开发的Dll和硬件通讯，在C++中使用返回正常的数值，而在C#中通过DllImport方式调用，发现返回的数值不一致，具体代码如下：", "\n\n", "**  C++ 提供的结构体：**", "\n\n", "typedef struct _SXPSERVER { \n    BYTE bNodeaddr[6];  \n    DWORD dwIp;  \n    char  szMachineType[16]; \n    char  szHostName[16]; \n} SXPSERVER, *LPSXPSERVER; \n\n\n", "\n\n", "\n\n", "**C# 自己写的DllImport 的结构体**\n", "\n\n", "     [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n        public struct SXPSERVER\n        {\n            public uint dwIp;\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]\n            public byte[] bNodeaddr;\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]\n            public string szMachineType;\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]\n            public string szHostName;\n        }\n", "\n\n", "\n\n", "调用全部都一切正常，结构体中也能够返回值，现在就是这个DWORD dwIp;  转换到C#中的 public uint dwIp;返回不一样，其他的都没有问题，请问各位大佬，我这个转换不对吗？查了半天看到的对应转换关系都是DWORD -》uint，我改成了int同样也是不对，这个咋整，这个值还会是后面的函数中的关键参数，卡到这里进行不下去了。", "\n\n", "PS：看到有大神留言说这个参数位置写反了，我最开始的时候就是按照这个顺序（", "\n\n", "    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]\n        public struct SXPSERVER\n        {\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]\n            public byte[] bNodeaddr;\n                      public uint dwIp;\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]\n            public string szMachineType;\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 16)]\n            public string szHostName;\n        }\n", "\n\n", "）来的，出来的结果和这个是一样的", "\n\n", "问题已经解决了，解决的方式是这样的：", "\n我在C++的结构体与C#定义的结构体的顺序是不一样的，但这个不是主要的原因。而是我调用方式有问题。我把c#实现的这个结构体单独放到了一个DLL中，然后再通过别的工程去调用这个DLL，这样的话。不管结构体中的顺序是什么，它都能够调用成功，但是他成功之后，里面的数值是不对的，这个是我通过反编译看到的，所有的结构体变量约束都没有了，所以这个值肯定不对啦。而我把这个调用C++的这个结构体直接放到了我现在用的工程当中，按照错误的顺序，这个方法都不会调用成功，而按照正确的顺序后就ok啦！"]], "Tag": "程序设计"}
{"Answer": "```\r\n两个类型不兼容，为什么非要用一个名字。\r\n一般来说是这么写\r\n#include &lt;stdio.h&gt;\r\n\r\ntypedef union {\r\nstruct {\r\nshort high;\r\nshort low;\r\n};\r\nint value;\r\n} SElemType;\t\r\n\r\nint main () {\r\n\tSElemType x;\r\n\tx.value = 65538;\r\n\tprintf(\"%d %d\\n\", x.low, x.high);\r\n\treturn 0;\r\n}\r\n结果\r\n2\r\n1\r\n```\r\n\r\n\r\n```\r\n#include&lt;stdio.h&gt;\r\n\r\ntypedef struct {\r\n    int a;\r\n    int b;\r\n}SE;\r\n\r\nvoid fun(int a){}\r\n\r\nvoid main() {\r\n    SE e;\r\n    e.a = 1;\r\n    e.b = 2;\r\n    int q = *(int*)&amp;e;\r\n    fun(q);\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言中typedef定义的结构体变量如何重定义", ["如果已经定义了一个SElemType类型，", "\n\n", "typedef int SElemType;\n", "\n\n", "然后我想把SElemType类型改成", "\n\n", "typedef struct {\n    int low, high;\n}SElemType;\n", "\n\n", "该如何操作?", "\n\n", "#include<stdio.h>\n\ntypedef struct {\n    int a;\n    int b;\n}SE;\n\nvoid fun(int a){}\n\nvoid main() {\n    SE e;\n    e.a = 1;\n    e.b = 2;\n    int q = (int)e;\n    fun(q);\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "动态内存没分配；\r\n\r\n```\r\n L  *LL;\r\n 改成\r\n L *LL = (L *)malloc(sizeof(L));\r\n```\r\n\r\n全部代码：\r\n\r\n```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;conio.h&gt;\r\n#include&lt;malloc.h&gt;\r\n\r\nint main()\r\n{\r\n    typedef struct\r\n    {\r\n        int no;\r\n        char nn;\r\n    }L;\r\n    L *LL = (L *)malloc(sizeof(L));\r\n    LL-&gt;no=1;\r\n    printf(\"%d\",LL-&gt;no);\r\n    free(LL);\r\n    LL = NULL;\r\n    getch();\r\n    return 0;\r\n}\r\n\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针的内容赋值相关问题", ["int main()\n{\n\nint a=1;\nint *b;\ntypedef struct  \n{\n\nint no;\nchar nn;\n}L;\n L  *LL;\nLL->no=1;\nprintf(\"%d\",LL->no);\n\n\n\n\n\n\n\ngetch();\n\n\nreturn 0;\n}\n\n", "\n\n", "这是我写的代码，代码没有报错，为什么运行的时候会溢出呢？"]], "Tag": "程序设计"}
{"Answer": "```\r\npublic class THFI_Param {\r\npublic int nMinFaceSize { get; set; }\r\npublic int nRollAngle { get; set; }\r\npublic bool bOnlyDetect { get; set; }\r\npublic uint? dwReserved { get; set; }\r\npublic THFI_Param() {\r\n        this.nMinFaceSize = 50;\r\n            this.nRollAngle = 30;\r\n            this.bOnlyDetect = false;\r\n            this.dwReserved = null;\r\n    }\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["急！急！急！ C++ 结构体带构造函数的在C#中改如何定义", ["struct THFI_Param", "\n{", "\n    int nMinFaceSize; ", "\n    int nRollAngle; ", "\n    bool bOnlyDetect; ", "\n    DWORD dwReserved; ", "\n    THFI_Param()", "\n    {", "\n        nMinFaceSize=50;", "\n        nRollAngle=30;", "\n        bOnlyDetect=false;", "\n        dwReserved=NULL;", "\n    }", "\n};"]], "Tag": "程序设计"}
{"Answer": "头文件里面一般放什么： 主要是类的定义，以及对象或者函数的声明。 而你的函数实现体应该放在源文件里面，包括你的new语句，然后在源文件\r\n里面new跟delete就可以了...你的这种编程思路有问题", "Konwledge_Point": "数据封装——结构体", "Question": ["C++：new结构体释放问题", ["假设有如下几个文件main.c，IRSend.c, IRSend.h", "\n在IRSend.h中定义如下：", "\ntypedef struct {", "\n    int recvpin;", "\n    int rcvstate; ", "\n    int timer; ", "\n} irparams_t;", "\nextern volatile irparams_t *irparams;", "\n\n", "在IRSend.c中定义如下：", "\n#include \"IRSend.h\"", "\nvolatile irparams_t *irparams=new volatile irparams_t;", "\nvoid a()", "\n{", "\nirparams->recvpin=1;", "\n}", "\nvoid b()", "\n{", "\nirparams->rcvstate=2;", "\n}", "\nvoid c()", "\n{", "\nirparams->timer=2;", "\n}", "\n\n", "在main.c中定义如下：", "\n#include \"IRSend.h\"", "\nvoid main()", "\n{", "\n        a();", "\n        b();", "\n        c();", "\n}", "\n\n", "请问应在哪个地方delete irparams。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You can cast &lt;code&gt;unsafe.Pointer&lt;/code&gt; to &lt;code&gt;*myStruct&lt;/code&gt; passing pointer to the first element of the bytes slice:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import \"unsafe\"\n...\nobj = (*myStruct)(unsafe.Pointer(&amp;amp;data[0]))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;test: &lt;a href=\"https://play.golang.org/p/c7XO3dPKcLu\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/c7XO3dPKcLu&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何使用结构体指针转换[] byte？", ["\n\n", "I'd like to use Go for low level project and avoid copying data.", "\n\n", "I have a struct of fixed size:", "\n\n", "type myStruct struct {\n    a    uint8\n    b    uint8\n}\n", "\n\n", "I would like to cast a ", "pointer of my struct", " with this ", "slice of bytes", " in order to read the value as if the slice of bytes was a struct without copying anything.", "\n\n", "data := []byte{69,0}\n\nvar obj *myStruct\n\n//something like:\nobj = myStruct(data)\n// or\nobj = &myStruct(data)\n", "\n\n", "In C it would be: ", "obj = (struct myStruct*) data;", "\n\n", "\n", "Is it possible ? What are the solutions to do so ? The best practice ?", "\n", "\n", "I'd like to void using offset and index for the []byte.", "\n\n", "Since a slice is not a fixed memory, I guess it'd be possible by converting ", "[]byte", " into a fixed array ", "byte[0:2]", ".", "\n    "]], "Tag": "程序设计"}
{"Answer": "```\r\n没有你txt文件的内容和member的定义，没法给你调试和编写代码\r\n\r\n只能大概说说\r\n\r\nstruct member member[100];\r\n\r\n你定义了member[100]\r\n但是没有读取记录放入member里面的逻辑\r\n在\r\nif((fp1=fopen(\"D:\\Vc data\\salary.txt\",\"r\"))==NULL)\r\n{printf(\"File open error!\\n\");\r\nexit(0); }\r\n下面\r\nfor (int i = 0; i &lt; n; i++)\r\n{\r\nfscanf(fp, \"%s %d,...\", member[i].sname, &amp;member[i].age); //这一行是大概的演示，要根据你结构体的内容和文件的内容去修改\r\n}\r\n...\r\n然后\r\nfor(i=0;i++;i&lt;n){\r\nif(strcmp(Sname,member[i].name)==0){\r\nbreak;\r\n}\r\n}\r\nprintf(\"%s\", member[i].sname); //此时i就是找到的数据的下标\r\n这样就能查询了\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言用其中一个结构的体元素从文件中查找到相同的结构体之后如何从文件中输出查找到的那个结构体", ["功能要求：\n① 职工基本信息的录入、增加、删除、修改；\n② 按各种条件查询职工信息；\n③ 应发工资计算；\n④ 其它功能，如工资分布情况统计，代交税金计算，津贴发放，工资晋级等。\n\n\n\n\n\n\n\n\n\n", "\n\n", "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint n;\nvoid member_putin_info();\nvoid member_seaech_info(struct member member[100],int n);\nvoid member_add_info();\nvoid member_modify_info();\nvoid member_delete_info();\nchar Readspecailline_info(int i);\n\n    struct member{\n    char name[20];\n    char post[20];\n    int age,wages;\n    int WorkingHours;\n    };\n\n    void member_putin_info(){\n    int i;\n    FILE *fp1,*fp2;\n    struct member member[100];\n    printf(\"Input n:\");\n    scanf(\"%d\",&n);\n\n\n    if((fp2=fopen(\"D:\\\\VC data\\\\salary1.txt\",\"w\"))==NULL)\n    {printf(\"File open error!\\n\");\n    exit(0);                                               \n    }\n    fprintf(fp2,\"%d\",n);\n\n    if(fclose(fp2)){                           \n    printf(\"can not close the file!\\n\");\n    exit(0);\n    }\n\n    if((fp1=fopen(\"D:\\\\VC data\\\\salary.txt\",\"w\"))==NULL)\n    {printf(\"File open error!\\n\");\n    exit(0);                                              //*打开文件*//\n    }\n\n    for(i=0;i<n;i++){                                //*职工信息录入功能*//\n    printf(\"Input name:\\n\");\n    scanf(\"%s\",&member[i].name);\n    fprintf(fp1,\"%s \",member[i].name);\n    printf(\"Input post:\\n\");\n    scanf(\"%s\",&member[i].post);\n    fprintf(fp1,\"%s \",member[i].post);\n    printf(\"Input age:\\n\");\n    scanf(\"%d\",&member[i].age);\n    fprintf(fp1,\"%d \",member[i].age);\n    printf(\"Input wages:\\n\");\n    scanf(\"%d\",&member[i].wages);\n    fprintf(fp1,\"%d \",member[i].wages);\n    printf(\"Input WorkingHours:\\n\");\n    scanf(\"%d\",&member[i].WorkingHours);\n    fprintf(fp1,\"%d \",member[i].WorkingHours);\n    printf(\"\\n\");\n    fprintf(fp1,\"\\n\");\n\n    }\n    if(fclose(fp1)){                          //*关闭文件*//\n    printf(\"can not close the file!\\n\");\n    exit(0);\n    }\n    }\n\n\n\n    void member_seaech_info()                                //*职工信息查询功能*// \n    {\n       struct member member[100];\n        FILE *fp1,*fp2,*fp3;\nif((fp2=fopen(\"D:\\\\Vc data\\\\salary.txt\",\"r\"))==NULL)\n    {printf(\"File open error!\\n\");\nexit(0);  }   \n   fscanf(fp2,\"%d\",&n);\n\n\nif((fp1=fopen(\"D:\\\\Vc data\\\\salary.txt\",\"r\"))==NULL)\n    {printf(\"File open error!\\n\");\nexit(0);  }          \n     int i;\n    char Sname[20]; \n    char Spost[20];\n     int choice; \n     int age; \n     char ch[2];\n\n     printf(\"[1]Select name\\n\");\n     printf(\"[2]Select post\\n\");\n     printf(\"[3]Select age\\n\");\n     printf(\"[4]Selcet wages\\n\");\n     printf(\"[5]Select WorkingHours\\n\");\n\n     printf(\"Enter choice:\");\n     scanf(\"%d\",&choice);\n     if(choice<1||choice>5)\n         printf(\"输入错误！\\n\");\n\n     if(choice==1){\nprintf(\"Enter the name:\");\nscanf(\"%s\",&Sname);\nfor(i=0;i++;i<n){\n    if(strcmp(Sname,member[i].name)==0){\n    break;\n    }\n}\n     }\n\n\n\nif(fclose(fp1)){                         \n    printf(\"can not close the file!\\n\");\n    exit(0);\n    }\n\nif(fclose(fp2)){                          \n    printf(\"can not close the file!\\n\");\n    exit(0);}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    int main(void)\n    { int choice;\n    printf(\"enter your choice:\");\n    scanf(\"%d\",&choice);    \n    switch(choice){\n        case 1:member_putin_info();break;\n        case 2:member_seaech_info();break;\n\n    }\n\n", "\n\n", "return 0;", "\n    }", "\n\n", "     我就用名字进行对比，完了之后找到第几个结构有相同的名字，想输出这个结构体的所有元素，但是用scanf(fp1,\"%s\",member[i].name)这样的做法貌似永远只取值我文件中的第一行，求大神教教我方法！！\n只要方法能行可靠就okk！！\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;stddef.h&amp;gt;\n#include&amp;lt;string.h&amp;gt;\n\ntypedef struct date\n{\n    int i;\n    int j;\n    char str[30];\n}date_t;\n\ndate_t s&amp;#61;{0,1,&amp;#34;this is a test&amp;#34;};\n\nint main(void)\n{\n   printf(&amp;#34;%s\\n&amp;#34;,s.str);\n   //date_t s&amp;#61;{.j&amp;#61;1,.str&amp;#61;&amp;#34;this is a test&amp;#34;};\n   \n   return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ 结构体初始化", ["报[Error] C99 designator 'str' outside aggregate initializer 求解决方法", "\n\n", "#include<stdio.h>", "\n#include<stddef.h>", "\n#include<string.h>", "\n", "\ntypedef struct date", "\n{", "\nint i;", "\nint j;", "\nchar str[30];", "\n}date_t;", "\nint main(void)", "\n{", "\ndate_t s={.j=1,.str=\"this is a test\"};", "\n", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;试图访问NULL等非法地址会引发段错误&amp;#xff0c;通常会导致闪退&amp;#xff0c;有时候会卡一下。&lt;br /&gt;你这个while(p)显然是错误的&amp;#xff0c;因为这样做会导致最后p得到空。正确的得到最后一个元素应该用while(p-&amp;gt;next)&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体变量为null，给他的成员变量赋值会怎么样？？求", ["#如题", "#代码", "\n", "\n", "\n", "void add(sNode node,sNode* sL){\n    \n    ", "sNode", "* p=sL->", "next;                          ", "//获取指向首元结点的指针", "\n    \n    ", "while", "(p)p=p->", "next;                          ", "//通过循环将指针指向最后一个元素", "\n   \n    \n    \n     ", "p", "->", "name", "=node.", "name", ";                            、、、、、、、运行时卡在了这里，我不知道问题是出在了哪里\n    ", "p", "->", "age=node.age;\n    ", "p", "->", "next=NULL;                               ", "//将结点初始化", "\n   \n    ", "printf", "(\"姓名：%s,nianling:%d\\n\",sL->", "next", "->", "name", ",sL->", "next", "->", "age);\n    \n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sex输出要用%c&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体运行不出来是什么原因呀", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;getdata()返回值是个mystruct指针&amp;#xff0c;所以又可以访问到结构体里面的a&amp;#xff0c;你写getdata()毫无意义&amp;#xff0c;因为你可以直接访问temp里面的a&amp;#xff0c;然后还有一点&amp;#xff0c;如果结构体里面有编写函数的需求的话&amp;#xff0c;可以使用类代替结构体。使用结构体之前&amp;#xff0c;记得给结构体初始化&amp;#xff0c;否则可能发生一些意外。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++中结构体变量读取数据问题", ["C++中结构体", "声明：", "typedef struct mystruct", "{", "  int a；", "  int b；", "  mystruct* getdata();", "}_mystruct ;", "mystruct* mystruct::getdata()", "{", "    int a=0；", "    int b=1；", "    return this；", "}", "调用：", "mystruct temp；", "int a= temp.getdata()->a;", "\n", "疑惑：", "在调用的地方temp不是我声明的一个数据类型吗？temp是我声明的mystruct数据类型，可以直接调用初始化函数读取变量a的值吗？在getdata()初始化函数里面返回的this也是数据类型吧，也不是一个数据变量"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;下面是我的一个实现,供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;rectangle&lt;/span&gt;{\n    \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; width;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; height;\n    \n}; \n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{\n    \n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;rectangle&lt;/span&gt; r;\n    \n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d %d&amp;#34;&lt;/span&gt;,&amp;amp;r.x,&amp;amp;r.y,&amp;amp;r.width,&amp;amp;r.height);\n    \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d\\n&amp;#34;&lt;/span&gt;,r.x&amp;#43;r.width,r.y&amp;#43;r.height);\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言rectangle运用", ["定义一个结构体类型表示rectangle，包括左上角的点的坐标(x,y)，以及宽度(width)和高度(height)。从键盘输入左上角点的坐标以及rectangle的宽度和高度，四个值均为整型数据，输出这个rectangle右下角的点的坐标，坐标值为整型。", "\n", "输入格式:", "从键盘输入一个rectangle的左上角的坐标和rectangle的宽度和高度，之间用空格分隔", "\n", "输出格式:", "输出这个rectangle右下角的点的坐标，坐标值为整型，之间用空格分隔。", "\n", "输入样例:", "在这里给出一组输入。例如：", "\n", "3 3 8 7", "输出样例:", "在这里给出相应的输出。例如：", "\n", "11 10"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在dev的顶部的【工具】里找到【编译选项】&lt;br /&gt;然后在【编译时加入以下命令】那里打上对勾&lt;br /&gt;在对应的那个方框里输入&amp;#34;-std&amp;#61;c&amp;#43;&amp;#43;11&amp;#34;, 没有引号&amp;#xff0c;然后点【确定】&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;其实黄色的字只是警告&amp;#xff0c;它提示你使用了c&amp;#43;&amp;#43;11的语法&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体变量中的报错问题", ["第20行有一个报错是怎么回事？没有看懂啊，有谁可以给我讲解一下？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The fields of CellValue are unexported (start with a lowercase character). &lt;a href=\"https://golang.org/pkg/encoding/json/#Marshal\" rel=\"nofollow noreferrer\"&gt;Per the documentation&lt;/a&gt; (emphasis mine), \"Each &lt;strong&gt;exported&lt;/strong&gt; struct field becomes a member of the object\" - meaning unexported values are ignored when marshaling or unmarshaling.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["编组映射到JSON时丢失数据", ["\n\n", "I'm trying to marshal to JSON a struct ", "Foo", " that has a ", "Values map[string]CellValue", " property where ", "CellValue", " is another struct.  For some reason, the resultant JSON does not contain the data held in the ", "CellValue", " struct even though all the keys in the ", "Values", " map ", "are", " present.", "\n\n", "Here's a ", "simple playground repro", " of the issue.", "\n\n", "I'm new to Go, can anyone spot the problem here?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;For your specific example, you can easily convert it &lt;a href=\"http://play.golang.org/p/aieOjbbjP_\"&gt;&lt;kbd&gt;playground&lt;/kbd&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;t1 := type1{{\"A\", 1}, {\"B\", 2}}\nt2 := type2(t1)\nfmt.Println(t2)\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Golang：不同结构类型之间是否可以转换？", ["\n\n", "Let's say I have two similar types set this way :", "\n\n", "type type1 []struct {\n    Field1 string\n    Field2 int\n}\ntype type2 []struct {\n    Field1 string\n    Field2 int\n}\n", "\n\n", "Is there a direct way to write values from a type1 to a type2, knowing that they have the same fields ?\n(other than writing a loop that will copy all the fields from the source to the target)", "\n\n", "Thanks.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Given that you are using a private protocol. It's a good idea to implement your own protocol. There are many &lt;a href=\"http://godoc.org/encoding/json\" rel=\"nofollow\"&gt;examples&lt;/a&gt; &lt;a href=\"http://godoc.org/encoding/csv\" rel=\"nofollow\"&gt;of&lt;/a&gt; &lt;a href=\"https://godoc.org/github.com/ugorji/go/codec\" rel=\"nofollow\"&gt;how&lt;/a&gt; to do this.&lt;/p&gt;\n\n&lt;p&gt;You are only limited by the implementing of your encoder. I'd recommend looking at the &lt;a href=\"https://godoc.org/encoding/json#Decoder\" rel=\"nofollow\"&gt;json.Decoder&lt;/a&gt; for handling buffers rather than looking at straight byte slices. These operate on buffers and are very useful for large data streams.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["golang将字节数组转换为结构", ["\n\n", "I am looking for clean way to cast byte array to struct for client-server application.\nI know most ppl turn to gob package for this solution however I do not control the encoding for the application. that being said, I only programmed the server application not the client, there is a mutual contract for the protocol that is being exchanged.", "\n\n", "The best I could come out is the following.", "\n\n", "type T struct {\n    A int16\n    B int8\n    C []byte\n}\n\nfunc main() {\n    // Create a struct and write it.\n    t := T{A: 99, B: 10}\n    buf := &bytes.Buffer{}\n\n    buf1 := []byte{5, 100, 100}\n    fmt.Println(buf1)\n\n    buf.Write(buf1)\n\n    //err := binary.Write(buf, binary.BigEndian, t)\n\n    //if err != nil {\n    //  panic(err)\n    //}\n    fmt.Println(buf)\n\n    // Read into an empty struct.\n    t = T{}\n    err := binary.Read(buf, binary.BigEndian, &t)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Printf(\"%d %d\", t.A, t.B)\n}\n", "\n\n", "However, as soon as number bytes does not coincide with the size of the struct, then go will send a panic. How can I modify this to work without the panic if undersize or oversize", "\n\n", "<kbd>", "Go playground", "</kbd>", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/346904416356198.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体出现问题，求解答", ["\n", "\n", "编译一直出错，找不到办法解决1242215155151616656565"]], "Tag": "程序设计"}
{"Answer": "看看这样行不行：\r\nPackage.java\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\npublic class Package{\r\n  String name;\r\n  String type;\r\n  String operation;\r\n  List fields = new ArrayList();\r\n\r\n  public String getName(){\r\n    return name;\r\n  }\r\n\r\n  public void setName( String name ){\r\n    this.name = name;\r\n  }\r\n\r\n  public String getOperation(){\r\n    return operation;\r\n  }\r\n\r\n  public void setOperation( String operation ){\r\n    this.operation = operation;\r\n  }\r\n\r\n  public String getType(){\r\n    return type;\r\n  }\r\n\r\n  public void setType( String type ){\r\n    this.type = type;\r\n  }\r\n\r\n  public void add( Field field ){\r\n    this.add( field );\r\n  }\r\n\r\n  public void delete( Field field ){\r\n    this.delete( field );\r\n  }\r\n}\r\n\r\n\r\n\r\nField.java\r\n\r\npublic class Field{\r\n  String name;\r\n  String type;\r\n  String operations;\r\n  public String getName(){\r\n    return name;\r\n  }\r\n  public void setName( String name ){\r\n    this.name = name;\r\n  }\r\n  public String getOperations(){\r\n    return operations;\r\n  }\r\n  public void setOperations( String operations ){\r\n    this.operations = operations;\r\n  }\r\n  public String getType(){\r\n    return type;\r\n  }\r\n  public void setType( String type ){\r\n    this.type = type;\r\n  }\r\n}", "Konwledge_Point": "数据封装——结构体", "Question": ["Java菜鸟问题之定义数据结构", ["我的leader让我定义一个数据结构！", "\n有两个类：Package（属性：name、type、operation等等。方法包括：add，delete，以及对Field字段的添加、删除等功能方法）和Field（属性：name、type、operations等等，方法：add，delete等等）！", "\n一个Package包含多个Field字段（也就是说组合关系！）他的要求是用类似c的struct+动态数组定义一个数据结构！", "\n这里我不知道这个动态数组应该怎么加入！挺基础的一个设计！哪位大侠出出主意？呵呵", "\n[b]问题补充：[/b]", "\nadd，delete的作用：在Package对Field字段进行删除或者添加！原则还是Package包含（组合关系）多个Field字段，可以删除，添加某个字段！", "\n\n", "我的设想是：Package类的某个属性为Field对象。这样二者就联系起来。 然后在声明一个class FiledCollection , 里面维护一个私有的HashTable, 用这个类的实例来保存一个个的FiledManager实例, Packagemanager也一样, 这样程序整洁, 扩展性强。关键就是这里的FieldCollection怎样写？小弟不懂啊！", "\n\n", "给出示例代码吧！", "\npackage cainiao;", "\n\n", "public class Package {", "\n    private String name;", "\n    private String type;", "\n    private Field field;", "\n\n", "public Package(String name, String type, Field field) {\n    this.name = name;\n    this.type = type;\n    this.field = field;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic String getType() {\n    return type;\n}\n\npublic void setType(String type) {\n    this.type = type;\n}\n\npublic Field getField() {\n    return field;\n}\n\npublic void setField(Field field) {\n    this.field = field;\n}\n", "\n\n", "}", "\n\n", "package cainiao;", "\n\n", "public class Field {", "\n    private String name;", "\n    private String type;", "\n    private String operation;", "\n\n", "public Field(String name, String type, String operation) {\n\n    this.name = name;\n    this.type = type;\n    this.operation = operation;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic String getType() {\n    return type;\n}\n\npublic void setType(String type) {\n    this.type = type;\n}\n\npublic String getOperation() {\n    return operation;\n}\n\npublic void setOperation(String operation) {\n    this.operation = operation;\n}\n", "\n\n", "}", "\n\n", "不知描述清楚没？呵呵", "\n\n", "[b]问题补充：[/b]", "\n我的设想是：[color=red]Package类的某个属性为Field对象。这样二者就联系起来。 然后在声明一个class FiledCollection , 里面维护一个私有的HashTable, 用这个类的实例来保存一个个的FiledManager实例, Packagemanager也一样, [/color]这样程序整洁, 扩展性强。关键就是这里的FieldCollection怎样写？PackageCollection咋写？我的设想正确不？", "\n[b]问题补充：[/b]", "\n我这个leader说的是struct+动态数组个数据结构定义！我就直接想用arraylist，这是我的个人想法,不过我就是不知道这个动态数组咋加进去？firefly兄你写出点代码出来看看！呵呵，我不知道咋写！他只是让我想。也没提示，说提示就没意思了！呵呵，哪位高人来提示一下！", "\n[b]问题补充：[/b]", "\nhashtable？哦，那是以前的想法!现在就是想用arraylist。", "\nfirefly你说的这个[color=red]：[color=orange]Java里面的ArrayList不仅是运行时指定长度，并且可以自增长。因此，说白了，ArrayList就是lz所说的“动态数组”。因此，lz直接使用ArrayList就可以，当然，也可以把ArrayList封装FieldCollection，然后在FieldCollection里面添加相应的add和delete方法。[/color][/color]", "\n你能不能用代码实现啊！我不知如何下手！", "\n[b]问题补充：[/b]", "\n好！你就ok了！多谢二位的回答！"]], "Tag": "程序设计"}
{"Answer": "自己的问题自己找到答案了，struct 内存对齐导致，传递不准确", "Konwledge_Point": "数据封装——结构体", "Question": ["Linux 的fifo管道利用write 函数如何传递结构体后，正确解析？", ["linux  fifo有名管道  ，可以用来给进程通信，但是write写的时候，发生了不正确的解析，自己整了2天，没搞清楚原因，希望大神来解答一下", "\n\n", "写端:", "\n\n", "struct msg", "\n{", "\n    int id;", "\n    char message[255];", "\n};", "\n\n", "int main(void)", "\n{", "\n    struct msg mym;", "\n    mym.id=123;", "\n    sprintf(mym.message,\"hello china\");", "\n    int ff=fifo(\"usr/myfifo\",0777);", "\n     if(ff<0)", "\n     {", "\n        perror(\"fifo fail\");", "\n        exit(1);", "\n     }", "\n    int fd=open(\"usr/myfifo\",O_WRONLY);", "\n    if(fd<0)", "\n    {", "\n        perror(\"open fail\");", "\n        exit(2);", "\n    }", "\n    write(fd,&mym,sizeof(mym));", "\n\n", "close(fd);\n\n\n\nreturn 0;\n", "\n\n", "}", "\n\n", "读端:", "\nstruct msg", "\n{", "\n    int id;", "\n    char message[255];", "\n};", "\n\n", "int main(void)", "\n{", "\n    struct msg mym;", "\n\n", "int fd=open(\"usr/myfifo\",O_RDONLY);\nif(fd<0)\n{\n    perror(\"open fail\");\n    exit(2);\n}\nread(fd,&mym,sizeof(mym));\nprintf(\"id=%d,msg:%s\",mym.id,mym.message);\n\nunlink(\"usr/myfifo\");\nclose(fd);\n\n\n\nreturn 0;\n", "\n\n", "}", "\n\n", "自己测试  读端msg结构体的对象，能正确读出int成员的值，无法正确读出char*的值，自己不清楚原因。 有种感觉是申请对象内部有脏内存存在，导致解析失败。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个跟编译器及其优化配置有关。假设无对齐&amp;#xff0c;按地址来看&amp;#xff1a;char的地址为0&amp;#xff0c;占1个字节&amp;#xff1b;short的地址为1&amp;#xff0c;占2个字节&amp;#xff1b;char的地址为3&amp;#xff0c;占1个字节&amp;#xff1b;int的地址为4&amp;#xff0c;占4个字节&amp;#xff0c;总共8个字节。若要简化对齐&amp;#xff1a;char的地址为0&amp;#xff1b;short的地址2字节对齐&amp;#xff0c;地址由1变为2&amp;#xff1b;char的地址为4&amp;#xff1b;int的地址4字节对齐&amp;#xff0c;地址由5变为8&amp;#xff0c;总共12字节。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言包含元素char short char int的结构体大小为何为12？", ["#", "include", " ", "<stdio.h>", "\n", "typedef", " ", "struct", " ", "s1", "\n{\n    ", "char", " a;\n    ", "short", " b;\n    ", "char", " c;\n    ", "int", " d;\n}s1;\n", "int", " ", "main", "()", "\n", "{\n    ", "printf", "(", "\"%ld\\n\"", ",", "sizeof", "(s1));\n    ", "return", " ", "0", ";\n}\n", "\n", "12//？", "\n", "按照C语言中结构体类型字节对齐方式", "char : 1", "short: 2", "char: 1", "int : 4", "以四字节对齐，sizeof(s1)应该为8的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\ntypedef struct date\n{\n\tint year;\n\tint month;\n\tint day;\n}DATE;\n\ntypedef struct student\n{\n\tint num;\n\tchar name[20];\n\tchar sex;\n\tDATE birthday;\n\tfloat score;\n}STUDENT;\n\nvoid inputarr(STUDENT s[],int n)\n{\n\tint i &amp;#61; 0;\n\tprintf(&amp;#34;请输入%d个学生的学号、姓名、性别、生日、成绩\\n&amp;#34;,n);\n\tfor (; i &amp;lt; n; i&amp;#43;&amp;#43;)\n\t{\n\t\tscanf(&amp;#34;%d&amp;#34;,&amp;amp;s[i].num);\n\t\tscanf(&amp;#34;%s&amp;#34;,s[i].name);\n\t\tscanf(&amp;#34; %c%*c&amp;#34;,&amp;amp;s[i].sex);\n\t\tscanf(&amp;#34;%d %d %d&amp;#34;,&amp;amp;s[i].birthday.year,&amp;amp;s[i].birthday.month,&amp;amp;s[i].birthday.day);\n\t\tscanf(&amp;#34;%f&amp;#34;,&amp;amp;s[i].score);\n\t}\n}\n\nvoid outputarr(STUDENT s[],int n)\n{\n\tint i &amp;#61; 0;\n\tfor (; i &amp;lt; n; i&amp;#43;&amp;#43;)\n\t{\n\t\tprintf(&amp;#34;%d  %s   %c   %d-%d-%d   %.2f\\n&amp;#34;,s[i].num,s[i].name,s[i].sex,s[i].birthday.year,s[i].birthday.month,s[i].birthday.day,s[i].score);\n\t}\n}\n\nint main()\n{\n\tSTUDENT s[5];\n\tinputarr(s,3);\n\toutputarr(s,3);\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["输入5个学生的信息，输出这五个学生的信息，用结构体数组保存学生的信息，实现结构体数组的输入输出。", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;My first recommendation would be for you to just use &lt;code&gt;[]string&lt;/code&gt; instead of &lt;code&gt;[]byte&lt;/code&gt; if you know the input type is going to be an array of strings. &lt;/p&gt;\n\n&lt;p&gt;If &lt;code&gt;data&lt;/code&gt; is going to be a JSON array with various types, then your best option is to use &lt;code&gt;[]interface{}&lt;/code&gt; instead - Go will happily unmarshal the JSON for you and you can perform checks at runtime to cast those into more specific typed variables on an as-needed basis. &lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Golang，使用[] byte类型的字段将bytes数组转换为struct", ["\n\n", "I need some help with unmarshaling. I have this example code:", "\n\n", "package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Obj struct {\n    Id   string `json:\"id\"`\n    Data []byte `json:\"data\"`\n}\n\nfunc main() {\n    byt := []byte(`{\"id\":\"someID\",\"data\":[\"str1\",\"str2\"]}`)\n\n    var obj Obj\n    if err := json.Unmarshal(byt, &obj); err != nil {\n        panic(err)\n    }\n\n    fmt.Println(obj)\n}\n", "\n\n", "What I try to do here - convert bytes to the struct, where type of one field is ", "[]byte", ". The error I get:", "\n\n", "\n  ", "panic: json: cannot unmarshal string into Go struct field Obj.data of\n  type uint8", "\n", "\n\n", "That's probably because parser already sees that \"data\" field is already a slice and tries to represent \"str1\" as some char bytecode (type uint8?).", "\n\n", "How do I store the whole ", "data", " value as one bytes array? Because I want to unmarshal the value to the slice of strings later. I don't include a slice of strings into struct because this type can change (array of strings, int, string, etc), I wish this to be universal.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You just have to write &lt;code&gt;structType{fieldName: value}&lt;/code&gt; !&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何在Go结构体中初始化特定字段", ["\n\n", "If i had a Go ", "struct", " with a long list of fields. Is there a built-in way to initialize an instance while providing value for specific fields only?", "\n    "]], "Tag": "程序设计"}
{"Answer": "当成基本类型来用就好了，结构体唯一要注意的是分配空间，拷贝构造（特别是浅拷贝）\r\n类似下面这样：\r\n```\r\nstruct complex_struct a1, b1, c1;\r\nc1 = add_complex(a1, b1);\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言中关于结构体变量当函数参数问题", ["这样算是递归么，然后就是函数里那两个参数算是结构定义的变量么，这到底算是函数还是结构"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\nstruct Student\n{\n\tint nmb;  //学号\n\tchar name[20]; //姓名\n\tchar sex;  //m or w\n\tchar partment[20]; //院系\n\tint score1;  //成绩1\n\tint score2;  //成绩2\n};\n\n//输入学生信息\nvoid inputInfo(struct Student* arr,int size)\n{\n\tint i &amp;#61; 0;\n\tprintf(&amp;#34;请输入学生的学号、姓名、性别(w/m)、院系、成绩1、成绩2\\n&amp;#34;);\n\tfor (  i &amp;#61; 0; i &amp;lt; size; i&amp;#43;&amp;#43;)\n\t{\n\t\tscanf(&amp;#34;%d %s %c %s %d %d&amp;#34;,&amp;amp;arr[i].nmb,arr[i].name,&amp;amp;arr[i].sex,arr[i].partment,&amp;amp;arr[i].score1,&amp;amp;arr[i].score2);\n\t}\n}\n\n//qizui\nvoid Max(struct Student* arr,int size)\n{\n\tint i;\n\tint index &amp;#61; 0;\n\tint mm &amp;#61; arr[0].score1 &amp;#43; arr[0].score2;\n\tfor (i &amp;#61; 1; i &amp;lt; size; i&amp;#43;&amp;#43;)\n\t{\n\t\tif ( arr[i].score1 &amp;#43; arr[i].score2 &amp;gt; mm)\n\t\t{\n\t\t\tmm &amp;#61; arr[i].score1 &amp;#43; arr[i].score2 ;\n\t\t\tindex &amp;#61; i;\n\t\t}\n\t}\n\tprintf(&amp;#34;最高分同学信息&amp;#xff1a;%d %s %c %s %d %d\\n&amp;#34;,arr[index].nmb,arr[index].name,arr[index].sex,arr[index].partment, arr[index].score1,arr[index].score2);\n}\n\nint main()\n{\n\tstruct Student arr[5];\n\tinputInfo(arr,5);\n\tMax(arr,5);\n\t//getchar();\n\t//getchar();\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["使用函数和结构体，输入5名同学的基本信息，判断输出总分最高的同学的信息。", ["使用函数和结构体，输入5名同学的基本信息（学号、姓名、性别、院系、成绩1，成绩2），判断输出总分最高的同学的信息。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你遇到这种问题首先要看看&amp;#xff0c;你的结构体地址变没变&amp;#xff0c;如果地址没变&amp;#xff0c;那么大概率就是他说的那个取地址的问题&amp;#xff0c;因为对指针就去地址就变成了二级指针所以他就不再代表字符串&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体数组输出时的问题", ["如图，为什么没有输出呢。。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是这样的&amp;#xff0c;在C语言里面&amp;#xff0c;如果你使用的超出了申请的内存空间&amp;#xff0c;其实还是可以继续用的&amp;#xff0c;程序不会报错&amp;#xff0c;因为malloc函数和calloc函数都只是给你一个首地址&amp;#xff0c;你申请到这个首地址之后就算越界了&amp;#xff0c;之后对越界之后的内存进行赋值操作&amp;#xff0c;都不会报错。你自己可以测试一下&amp;#xff0c;用一个指针指向一个数组&amp;#xff0c;然后你的指针一直移动&amp;#xff0c;超出了数组范围之后得到的乱码而不是报错。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言一个结构体指针的问题，不明白请指点", ["\n", "#include<stdio.h>\n\ntypedef struct test{\n\tint a;\n\tint b;\n}TEST_ST;\n\ntypedef struct hello{\n\tint m;\n\tTEST_ST *v;\n}SOURCE_DATA;\n\nSOURCE_DATA *creat_data2()\n{\n\tSOURCE_DATA *data_m=NULL;\n\n\tdata_m = calloc(1,sizeof(SOURCE_DATA));\n\n\tdata_m->v = malloc(sizeof(TEST_ST));\n\n\tprintf(\"data_v addr = %p\\n\",data_m->v);\n\n\tprintf(\"data_v0-a addr = %p\\n\",&(data_m->v[0].a));\n\tprintf(\"data_v0-b addr = %p\\n\",&(data_m->v[0].b));\n\tprintf(\"data_v1-a addr = %p\\n\",&(data_m->v[1].a));\n\tprintf(\"data_v1-b addr = %p\\n\",&(data_m->v[1].b));\n\tprintf(\"data_v2-a addr = %p\\n\",&(data_m->v[2].a));\n\tprintf(\"data_v2-b addr = %p\\n\",&(data_m->v[2].b));\n\tprintf(\"data_v3-a addr = %p\\n\",&(data_m->v[3].a));\n\tprintf(\"data_v3-b addr = %p\\n\",&(data_m->v[3].b));\n\tprintf(\"data_v4-a addr = %p\\n\",&(data_m->v[4].a));\n\tprintf(\"data_v4-b addr = %p\\n\",&(data_m->v[4].b));\n\n\tdata_m->m = 2;\n\n\tdata_m->v[0].a =3;\n\tdata_m->v[0].b =4;\n\tdata_m->v[1].a =3;\n\tdata_m->v[1].b =4;\n\tdata_m->v[2].a =8;\n\tdata_m->v[2].b =7;\n\tdata_m->v[3].a =4;\n\tdata_m->v[3].b =4;\n\tdata_m->v[4].a =4;\n\tdata_m->v[4].b =5;\n\n\treturn data_m;\n}\n\nvoid creat_data(SOURCE_DATA *data)\n{\n\tSOURCE_DATA *data_tmp=NULL;\n\n\tdata_tmp = creat_data2();\n\n\tmemcpy(data,data_tmp,sizeof(SOURCE_DATA));\n\n\n//\tif(data_tmp->v)\n//\t{\n//\t\tfree(data_tmp->v);\n//\t\tdata_tmp->v = NULL;\n//\t}\n\n\tif(data_tmp)\n\t{\n\t\tfree(data_tmp);\n\t\tdata_tmp = NULL;\n\t}\n\n}\n\nint main(void)\n{\n\n\t\tSOURCE_DATA data={0};\n\n\t\tcreat_data(&data);\n\n\t\tprintf(\"end data m = %d\\n\",data.m);\n\n//\t\tprintf(\"data v = %p\\n\",data.v);\n\t\tprintf(\"end data0  = %d\\n\",data.v[0].a);\n\t\tprintf(\"end data0_ = %d\\n\",data.v[0].b);\n\t\tprintf(\"end data1  = %d\\n\",data.v[1].a);\n\t\tprintf(\"end data1_ = %d\\n\",data.v[1].b);\n\t\tprintf(\"end data2  = %d\\n\",data.v[2].a);\n\t\tprintf(\"end data2_ = %d\\n\",data.v[2].b);\n\t\tprintf(\"end data3  = %d\\n\",data.v[3].a);\n\t\tprintf(\"end data3_ = %d\\n\",data.v[3].b);\n\t\tprintf(\"end data4  = %d\\n\",data.v[4].a);\n\t\tprintf(\"end data4_ = %d\\n\",data.v[4].b);\n\n//\t\tfree(data.v);\n\n}\n", "\n\n", "请教个C问题没有想明白。请大家给个解答。", "\n\n", "这个代码里的第19行，data_m->v = malloc(sizeof(TEST_ST))，这句只申请了8个字节的空间，为什么v对应的数组超出8个字节后还能正常存储数值啊？", "\n\n", "这个data_m->v 申请的内存，怎么样释放？若是在第59行释放，只能释放申请的8个字节，但为什么v[1]到v[4]还能有数据？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;STREC h[N],t;相当于 STREC h[N]&amp;#xff1b;STREC t;&lt;br /&gt;就像int a,b;一样&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C语言二级考试结构体的问题", ["＃C语言二级考试菜鸡试水", "请各位大佬帮忙看下，程序运行完毕后出现乱码，百度上说可能是数组越界？但是我不会改了😭，求指点。放程序和结果:", "(fun函数是需要自己编写的部分)", "#include <stdio.h>", "#define   N   12", "typedef  struct", "{  char  num[10];", "   double  s;", "} STREC;", "\n", "\n", "double  fun( STREC  *a, STREC *b, int *n )", "{", "    double ave = 0.0,sum=0.0;int i;", "    for(i=0;i<N;i++)", "        sum += a[i].s;", "    ave = (double)sum/N;", "    *n = 0;", "    for(i=0;i<N;i++)", "    {", "        if(a[i].s>=ave)", "        {", "            b[i] = a[i];", "            (*n)++;", "        }", "    }", "    return ave;", "}", "\n", "\n", "main()", "{  STREC  s[N]={{\"GA05\",85},{\"GA03\",76},{\"GA02\",69},{\"GA04\",85}****,", "        {\"GA01\",91},{\"GA07\",72},{\"GA08\",64},{\"GA06\",87},", "        {\"GA09\",60},{\"GA11\",79},{\"GA12\",73},{\"GA10\",90}};", "   STREC  h[N],t;FILE *out ;", "   int  i,j,n;  double  ave;", "   ave=fun( s,h,&n );", "   printf(\"The %d student data which is higher than %7.3f:\\n\",n,ave);", "   for(i=0;i<n; i++)", "     printf(\"%s  %4.1f\\n\",h[i].num,h[i].s);", "   printf(\"\\n\");", "   out = fopen(\"C:\\WEXAM\\000000000000\\out.dat\",\"w\") ;", "   fprintf(out, \"%d\\n%7.3f\\n\", n, ave);", "   for(i=0;i<n-1;i++)", "     for(j=i+1;j<n;j++)", "       if(h[i].s<h[j].s) {t=h[i] ;h[i]=h[j]; h[j]=t;}", "   for(i=0;i<n; i++)", "     fprintf(out,\"%4.1f\\n\",h[i].s);", "   fclose(out);", "   getchar();", "}", "\n", "\n", "还有主函数中，STREC  h[N],t;中的t是什么意思呢？谢谢各位大佬！"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;\nstruct person\n{\n    char id [20];\n    char name [20];\n    int s1,s2,s3;\n} p[5];\nvoid input()\n{\n    for(int i&amp;#61;0; i&amp;lt;5; i&amp;#43;&amp;#43;)\n    {\n        scanf(&amp;#34;%s %s %d %d %d&amp;#34;,p[i].name,p[i].id,&amp;amp;p[i].s1,&amp;amp;p[i].s2,&amp;amp;p[i].s3);\n    }\n}\nint main()\n{\n    input();\n    int n1&amp;#61;0;\n    for(int i&amp;#61;0; i&amp;lt;5; i&amp;#43;&amp;#43;)\n    {\n        n1&amp;#61;0;\n        n1&amp;#43;&amp;#61;p[i].s1;\n        n1&amp;#43;&amp;#61;p[i].s2;\n        n1&amp;#43;&amp;#61;p[i].s3;\n        printf(&amp;#34;%.2f\\n&amp;#34;,n1/3.0);\n    }\n    int sum&amp;#61;0,t,j;\n    for(int i&amp;#61;0; i&amp;lt;5; i&amp;#43;&amp;#43;)\n    {\n        t&amp;#61;0;\n        t&amp;#43;&amp;#61;p[i].s1&amp;#43;p[i].s2&amp;#43;p[i].s3;\n        if(t&amp;gt;sum)\n        {\n            sum&amp;#61;t;\n            j&amp;#61;i;\n        }\n    }\n    printf(&amp;#34;最高成绩是%s %s %d %d %d %d&amp;#34;,p[j].name,p[j].id,p[j].s1,p[j].s2,p[j].s3,sum);\n}\n/*张三 101  80 76 98\n李四 102 96 56 78\n王五 103 64 89 63\n小二 104 62 54 86\n小四 105 78 86 91*/\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"328\" src=\"https://img-ask.csdnimg.cn/upload/1623493341030.png\" width=\"547\" /&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言小白，求助，结构体方面的", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你看一下程序的头部是不是有个宏定义SIZE_STU&amp;#xff0c;后面跟了数字&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["这个结构体的结尾部分SIZE_stu是什么意思", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Your struct fields must be exported (field is exported if it begins with a capital letter) or they won't be encoded:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Struct values encode as JSON objects. Each exported struct field\n  becomes a member of the object&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;To get the JSON representation as probably expected change the code to this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type SpanInfo struct {\n    IMSI string `json:\"imsi\"`\n    Network string `json:\"network\"`\n    NetworkStatus string `json:\"network_status\"`\n    SignalQuality int `json:\"signal_quality\"`\n    Slot int `json:slot\"`\n    State string `json:\"state\"`\n}\n\ntype GatewayInfo []SpanInfo\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Golang和JSON与结构体数组", ["\n\n", "I would like to create a JSON of a ", "GatewayInfo", " where the type are defined like this:", "\n\n", "type SpanInfo struct {\n    imsi string\n    network string\n    network_status string\n    signal_quality int\n    slot int\n    state string\n}\n\ntype GatewayInfo []SpanInfo\n", "\n\n", "The gateway information is created with:", "\n\n", "var gatewayInfo = make(GatewayInfo, nb_spans)\n", "\n\n", "To create the JSON, I use the ", "json.Marshal", " function:", "\n\n", "gatewayInfo := getGatewayInfo(spans)\nlog.Printf(\"Polling content: %s\n\", gatewayInfo)\n\njsonInfo, _ := json.Marshal(gatewayInfo)\nlog.Printf(\"jsonInfo: %s\n\", jsonInfo)\n", "\n\n", "Unfortunately the result is not what I was expecting:", "\n\n", "2015/02/09 13:48:26 Polling content: [{652020105829193 20801 Registered (Roaming) %!s(int=17) %!s(int=2) } {652020105829194 20801 Registered (Roaming) %!s(int=16) %!s(int=3) } {652020105829192 20801 Registered (Roaming) %!s(int=19) %!s(int=1) } {652020105829197 20801 Registered (Roaming) %!s(int=19) %!s(int=4) }]\n2015/02/09 13:48:26 jsonInfo: [{},{},{},{}]\n", "\n\n", "As we can see, the ", "GatewayInfo", " instance has the ", "SpanInfo", ", but in the JSON I have empty ", "SpanInfo", ".", "\n    "]], "Tag": "程序设计"}
{"Answer": "最后一句pre=current\n当在一个链表尾端插入一个节点，插入结束后，那么最后一个节点不就是刚刚插入的那个节点了吗？如果下次再插入一个节点在末尾，相对于又要插入的节点，链表的最后一个节点不就是pre了，最后一句就是实现pre指针始终指向链表的最后一个节点", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言关于结构体的问题", ["结构指针变量也必须要先赋值后才能使用吗 那图片的是什么情况 还有最后一个语句不懂 新手小白 忘大神解释 不胜感激"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;改动处见注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 11     &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;book&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; price;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,n,j;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; max,min;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; a,b;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;book&lt;/span&gt; s[N]; &lt;span class=\"hljs-comment\"&gt;//s[10] 修改&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Input n:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Input the name,price of the %d book:&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; %s%lf&amp;#34;&lt;/span&gt;,s[i].name,&amp;amp;s[i].price);\n    }\n    max&amp;#61;s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].price,min&amp;#61;s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].price;\n                       &lt;span class=\"hljs-comment\"&gt;//a&amp;#61;s[0].name,b&amp;#61;s[0].name;修改&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(max &amp;lt; s[i].price)\n                      &lt;span class=\"hljs-comment\"&gt;//a&amp;#61;s[i].name; 修改&lt;/span&gt;\n            max&amp;#61;s[i].price;\n                      &lt;span class=\"hljs-comment\"&gt;//}&lt;/span&gt;\n                      &lt;span class=\"hljs-comment\"&gt;//   for(j&amp;#61;0;j&amp;lt;n;j&amp;#43;&amp;#43;)&lt;/span&gt;\n                      &lt;span class=\"hljs-comment\"&gt;//   {&lt;!-- --&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(min &amp;gt; s[i].price)\n                      &lt;span class=\"hljs-comment\"&gt;//b&amp;#61;s[j].name;&lt;/span&gt;\n            min&amp;#61;s[i].price;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s[i].price &amp;#61;&amp;#61; max)\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;The book with the max price:%s,%.1f\\n&amp;#34;&lt;/span&gt;,s[i].name,s[i].price);\n            &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;The book with the max price:%s,%.1f\\n&amp;#34;,a,max);修改&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s[i].price &amp;#61;&amp;#61; min)\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;The book with the min price:%s,%.1f\\n&amp;#34;&lt;/span&gt;,s[i].name,s[i].price);\n            &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;The book with the min price:%s,%.1f\\n&amp;#34;,b,min);修改&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["编写程序，从键盘输入n(n<=10)本书的名称和定价并存入结构数组中,从中查找定价最高和最低的书的名称和定价，并输出。提示（1）定义结构体  （2）定义结构体数组", ["#", "include", "<stdio.h>", "\n", "struct", " ", "book", "{\n", "char", " name[", "80", "];\n", "double", " price;\n};\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " i,n,j;\n    ", "double", " max,min;\n    ", "char", " a,b;\n    ", "struct", " ", "book", " s[", "10", "];\n    ", "printf", "(", "\"Input n:\"", ");\n    ", "scanf", "(", "\"%d\"", ",&n);\n    ", "for", "(i=", "0", ";i<n;i++)\n       {\n    ", "printf", "(", "\"Input the name,price of the %d book:\"", ",i+", "1", ");\n    ", "scanf", "(", "\"%s%lf\"", ",s[i].name,&s[i].price);\n       }\n       max=s[", "0", "].price,min=s[", "0", "].price;\n       a=s[", "0", "].name,b=s[", "0", "].name;\n       ", "for", "(i=", "0", ";i<n;i++)\n       {\n           ", "if", "(max<s[i].price)\n            a=s[i].name;\n           max=s[i].price;\n       }\n       ", "for", "(j=", "0", ";j<n;j++)\n       {\n           ", "if", "(min>s[j].price)\n            b=s[j].name;\n           min=s[j].price;\n       }\n       ", "printf", "(", "\"The book with the max price:%s,%.1f\\n\"", ",a,max);\n       ", "printf", "(", "\"The book with the min price:%s,%.1f\\n\"", ",b,min);\n    ", "return", " ", "0", ";\n}\n", "\n", "为什么无法输出结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Huffman *pHfm&amp;#61;(Huffman*)malloc(sizeof(huffman))&lt;/p&gt;\n\n&lt;p&gt;sizeof里面直接用数据结构名&amp;#xff0c;malloc产生的是指针&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何在visual stdio初始化这个结构体变量？", ["\n", "typedef struct {\n\tint weight;\n\tchar ch;\n\tint parent, lchild, rchild;\n}HTNode, *HuffmanTree;\ntypedef char **HuffmanCode;\ntypedef struct {\n\tHuffmanTree HT;\n\tchar        *c;\n\tint         length;\n\tHuffmanCode HC;\n}Huffman; ", "\n\n", "上面这部分是我的结构体定义；", "\n\n", "\n", "#include \"head.h\"\nint main() {\n\tHuffman Hfm;\n\tchar ch;\n\tscanf(\"%c\", &ch);\n\tgetchar();\n\twhile (ch != 'Q') {\n\t\tif (ch == 'I') Hfm=InitHTree(Hfm);\n\t\telse if (ch == 'E') EnHTree(Hfm);\n\t\telse if (ch == 'D') DeHTree(Hfm);\n\t\telse if (ch == 'P') PrintHTree(Hfm);\n\t\tprintf(\"\\n------------------\\n\");\n\t\tprintf(\"  初始化         I\\n\");\n\t\tprintf(\"  编码           E\\n\");\n\t\tprintf(\"  解码           D\\n\");\n\t\tprintf(\"  打印代码文件   P\\n\");\n\t\tprintf(\"  退出           Q\\n\");\n\t\tprintf(\"请选择服务:\");\n\t\tscanf(\"%c\", &ch);\n\t\tgetchar();\n\t}\n\treturn 0;\n}", "\n\n", "这是我的主函数部分，在visual stdio里报错说我在主函数里引用了未初始化的变量Hfm,但是我这样初始化：Hfm=(Huffman)malloc(sizeof(&huffman)) 仍然是报错，请问应该如何初始化呢？"]], "Tag": "程序设计"}
{"Answer": "```\r\n//1. scanf(\"%s,&amp;name1\");  改成 scanf(\"%s\",name1);\r\n//2.for循环加个花括号\r\n//3.如果你是想输入人名输出对应的工资，if判断也要改；\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\n\r\n\r\nstruct\r\n{\r\n    char name[20];\r\n    int salary;\r\n}stu[]={{\"zhangsan\",5000},{\"lisi\",5100},{\"wangmazi\",4900}};\r\nvoid main()\r\n{\r\n    int i;\r\n    char name1[20];\r\n    printf (\"input staff name:\");\r\n\r\n    scanf(\"%s\",name1);\r\n    for(i=0;i&lt;3;i++)\r\n    {\r\n        if(strcmp(stu[i].name,name1)==0)\r\n        {\r\n            printf(\"%d \",stu[i].salary);\r\n            break;\r\n        }\r\n    }\r\n\r\n    printf(\"\\n\");\r\n}\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["刚学了结构体，试着用了下怎么输出不对啊，求指点", ["这个是输入姓名就会输出工资的小程序，怎么不对啊", "\n\n", "#include\"string.h\"\n#include\"stdio.h\"\nstruct \n{\n    char name[20];\n    int salary;\n}stu[]={{\"zhangsan\",5000},{\"lisi\",5100},{\"wangmazi\",4900}};\nvoid main()\n{\n    int i;\n    char name1[20];\n    printf (\"input staff name:\");\n    scanf(\"%s,&name1\");\n        for(i=0;i<3;i++)\n         if(strcmp(stu[i].name,name1)==0)\n         break;\n         printf(\"%d\",stu[i].salary);\n\nprintf(\"\\n\");\n}\n\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "用handle可以实现你功能吗?\r\nm_ctx.powner = this.Handle", "Konwledge_Point": "数据封装——结构体", "Question": ["C#调用C++的dll,C++程序中给结构体中变量赋值this指针，对应C#中应该怎么写呢？", ["C++程序中有一个结构体", "\n\n", " struct Ctx\n{\n    void* owner;\n    DevInfo devinfo;\n};\n\n", "\n\n", "对话框类头文件中有", "\n\n", " Ctx m_ctx;//回调上下文, 作为回调函数的参数\n", "\n\n", "在对话框初始化程序中有", "\n\n", " m_ctx.owner = this;\n", "\n\n", "我在C#中定义结构体", "\n\n", " public struct Ctx\n    {\n       public  IntPtr powner;\n       public  DevInfo devinfo;\n    }\n", "\n\n", "    定义了\n\n    public  Ctx m_ctx;\n\n    那么怎么给m_ctx.powner赋值呢？\n\n    下面是部分代码，需要的话也可以把代码都发出来\n    C++\n", "\n\n", " BOOL Cdbc_demoDlg::OnInitDialog()\n{\n    CDialog::OnInitDialog();\n\n    // 将“关于...”菜单项添加到系统菜单中。\n\n    // IDM_ABOUTBOX 必须在系统命令范围内。\n    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n    ASSERT(IDM_ABOUTBOX < 0xF000);\n\n    CMenu* pSysMenu = GetSystemMenu(FALSE);\n    if (pSysMenu != NULL)\n    {\n        BOOL bNameValid;\n        CString strAboutMenu;\n        bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\n        ASSERT(bNameValid);\n        if (!strAboutMenu.IsEmpty())\n        {\n            pSysMenu->AppendMenu(MF_SEPARATOR);\n            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n        }\n    }\n\n    // 设置此对话框的图标。当应用程序主窗口不是对话框时，框架将自动\n    //  执行此操作\n    SetIcon(m_hIcon, TRUE);         // 设置大图标\n    SetIcon(m_hIcon, FALSE);        // 设置小图标\n\n    // TODO: 在此添加额外的初始化代码\n    m_hDBC = DBC_Init();\n    if (INVALID_DBC_HANDLE == m_hDBC)\n    {\n        MessageBox(_T(\"生成DBC句柄失败!\"));\n        return TRUE;\n    }\n    m_ctx.owner = this;\n    m_ctx.devinfo = m_devInfo;\n    DBC_SetSender(m_hDBC, OnSendFunc, &m_ctx);\n    DBC_SetOnMultiTransDoneFunc(m_hDBC, OnMultiTransDoneFunc, &m_ctx);\n    InitList();\n    if (!InitDevice())\n    {   \n        MessageBox(_T(\"打开设备失败!\"));\n        return TRUE;\n    }\n\n    return TRUE;  // 除非将焦点设置到控件，否则返回 TRUE\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;For 1. Try the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;return c.RenderJson(map[string]string{\"error\": \"xyz\"})\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;RenderJson&lt;/code&gt; takes an interface, which means you can pass it anything.  You don't need to explicitly cast to an interface, though that would be done like&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;interface{}(map[string]string{\"error\": \"xyz\"})\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For 2.  I am not certain, but I tend to have a helper function that takes the error string (or error type) and a status code and does the handling for me.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;return HandleError(c, \"xyz is not valid\", 400)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then &lt;code&gt;HandleError&lt;/code&gt; just creates and writes the error.&lt;/p&gt;\n\n&lt;p&gt;If you are going to be handling errors in general, I don't know why you wouldn't make an error type though, &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type RequestError struct {\n    Error string `json:\"error_message\"`,\n    StatusCode int `json:\"status_code\"`,\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["通过接口对象而不声明结构", ["\n\n", "How can I pass an ", "Interface{}", " object without declaring a Struct? \nfor example when I'm using the Revel framework I want to return an error on a specific case.", "\n\n", "\n", "\n", "The following example is not working, I tried various conventions nothing worked, whats the right approach?", "\n\n", "return c.RenderJson(interface{\"error\":\"xyz\"})", "\n", "\n", "Whats the right approach to return an error to the Client if i'm building a Server with the Revel framework?", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "if(n.a != m.a)\r\n{\r\n    return n.a&gt;m.a;\r\n}else if(n.b != m.b)\r\n{\r\n\t  return n.b &gt; m.b\r\n}else\r\n{\r\n\t   return strcmp(n.s,m.s);\r\n}", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体排序，自定义比较函数bool cmp()", ["C++结构体    用sort排序     自己定义比较函数cmp     bool cmp()", "\nstruct lzl", "\n{", "\n    string s;", "\n    int a,b;", "\n}x[100];", "\nbool cmp(lzl n,lzl m)", "\n{", "\n    if(n.a!=m.a)", "\n    return n.a>m.a;", "\n    if(n.a==m.a&&n.b!=m.b)", "\n    return n.b>m.b;", "\n    if(n.a==m.a&&n.b==m.b)", "\n    return n.s<m.s;", "\n}", "\n如果a不同，用a来排序，如果a相同，b不同，就用b来排序，a,b都相同就用s来排序。", "\n我想问的是，这个语句在cmp里面怎么写啊！两个的我会写，但是3个怎么写啊？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;联合体类型的变量在定义并初始化时&amp;#xff0c;只能是对第 1 个成员赋初值&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言运用结构体输入学生数据", ["\n", "设置学生结构体，然后输入4个学生的学号，名字，性别，年龄，成绩(如果缺考输入缺考原因)。", "为啥我原因那里会报错啊?"]], "Tag": "程序设计"}
{"Answer": "1.有这种可能，你目前的修改方法只是降低了问题出现的概率。\r\n2.建议你还是找出内存越界的原因，如果实在不想找，或者不好找，建议你先预估一下输入的数据最大有多大，然后申请足够的内存。\r\n3.不过对于一个优秀的程序员，查找出问题的真正原因对你的进步是非常有帮助的。", "Konwledge_Point": "数据封装——结构体", "Question": ["关于c语言解析json，nalloc段错误问题", ["\n\n", "如图，我现在有四条数据，主函数传进来，前三条没问题， 第四条的时候段错误", "\ngdb显示段错误位置在malloc，求助，为什么会这样"]], "Tag": "程序设计"}
{"Answer": "point[0]中出现3个‘*’是什么意思，point不是个2维数组吗？point[0]算什么？而且point是char型数组，怎么会在一个元素里有3个字符？", "Konwledge_Point": "数据封装——结构体", "Question": ["对结构体中的二维数组赋值为何会影响下一排", ["#include \"stdio.h\"", "\nstruct qipan", "\n{", "\n    char point[20][80];", "\n    bool isClear;", "\n};", "\nqipan board;", "\nint main()", "\n{", "\n    for(int i=0;i<=19;i++)", "\n            for(int j=0;j<=79;j++)", "\n                board.point[i][j]=' ';", "\n    board.point[1][1] = board.point[1][2]=board.point[1][3]='*';", "\n    //board.point[1][2] = '*';", "\n}", "\n\n", "代码如上，在不要for循环的时候可以将其正确初始化，但是加入了for循环对每一个都先赋空值的时候，再执行，会在point[0]中出现3个*在point[1]中也会有三个* ", "\n求教，为什么会出现这种情况？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/30553128245611.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#define &lt;span class=\"hljs-symbol\"&gt;_CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;stdlib.h&amp;gt;\n\ntypedef struct student{\n    int num;\n    char name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    int score[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    int sum;\n    float avg;\n} stu;\n\nvoid input(stu a[],int n)\n{\n    int i,j;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        scanf_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%s&amp;#34;&lt;/span&gt;,&amp;amp;a[i].num,a[i].name,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n        for (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; &amp;#43;&amp;#43;j)\n            scanf_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i].score[j]);\n    }\n}\n\nvoid sort(stu a[],int n)\n{\n    int i,j;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        for(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;n-i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;j&amp;#43;&amp;#43;)\n            if(a[j].avg &amp;lt; a[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].avg)\n            {\n                stu t &amp;#61; a[j];\n                a[j] &amp;#61; a[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                a[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t;\n            }\n}\n\nvoid calc(stu a[],int n)\n{\n    int i,j;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        int sum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for (j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; &amp;#43;&amp;#43;j)\n        {\n            sum &amp;#43;&amp;#61; a[i].score[j];\n        }\n        a[i].avg &amp;#61; sum/&lt;span class=\"hljs-number\"&gt;5.0&lt;/span&gt;;\n        a[i].sum &amp;#61; sum;\n    }\n}\nvoid out(stu a[],int n)\n{\n    int i;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34; 学号       姓名 成绩1 成绩2 成绩3 成绩4 成绩5 总成绩 平均成绩\\n&amp;#34;&lt;/span&gt;) ;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%5d %10s %5d %5d %5d %5d %5d %6d %8.2f\\n&amp;#34;&lt;/span&gt;,a[i].num,a[i].name,a[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;],a[i].sum,a[i].avg);\n    }\n}\nvoid maxscore(stu a[],int n)\n{\n    int i,j,max&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        max&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;n;j&amp;#43;&amp;#43;)\n        {\n            if (a[max].score[i]&amp;lt;a[j].score[i])\n                max &amp;#61; j;\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;成绩%d 单科的最高分学生学号:%d 姓名:%s 总成绩:%d 平均成绩:%.2f\\n&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,a[max].num,a[max].name,a[max].sum,a[max].avg );\n    }\n}\nvoid save(stu a[],int n)\n{\n    int i;\n    &lt;span class=\"hljs-symbol\"&gt;FILE&lt;/span&gt;* fp;\n    if ((fp &amp;#61; fopen(&lt;span class=\"hljs-string\"&gt;&amp;#34;data.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;)) &amp;#61;&amp;#61; &lt;span class=\"hljs-symbol\"&gt;NULL&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;cannot open file\\n&amp;#34;&lt;/span&gt;);\n        return;\n    }\n    fprintf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34; 学号       姓名 成绩1 成绩2 成绩3 成绩4 成绩5 总成绩 平均成绩\\n&amp;#34;&lt;/span&gt;) ;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        fprintf(fp,&lt;span class=\"hljs-string\"&gt;&amp;#34;%5d %10s %5d %5d %5d %5d %5d %6d %8.2f\\n&amp;#34;&lt;/span&gt;,a[i].num,a[i].name,a[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;],a[i].score[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;],a[i].sum,a[i].avg);\n    }\n    fclose(fp);\n}\n\nint main()\n{\n    int i,j,k,n;\n    stu a[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n    scanf_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n    input(a,n);\n    calc(a,n);\n    sort(a,n);\n    out(a,n);\n    maxscore(a,n);\n    save(a,n);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体，学生成绩信息排序和输出单科最高分记录", ["学生记录由学号、姓名和五门课的成绩组成，根据班级人数，将学生记录存放在结构体数组中。编程实现学生记录按平均成绩降序排序，输出单科的最高分学生记录将排序后的学生记录保存至文件中。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If I understand the question correctly, I would convert the struct into a map, and then check if the field you are interested in is in the map.&lt;/p&gt;\n\n&lt;p&gt;For example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main                                                                                                                       \n\nimport (                                                                                                                           \n    \"encoding/json\"                                                                                                                \n    \"fmt\"                                                                                                                          \n)                                                                                                                                  \n\ntype MyStruct struct {                                                                                                             \n    Name  string                                                                                                                   \n    Score int                                                                                                                      \n}                                                                                                                                  \n\nfunc main() {                                                                                                                      \n\n    ms := MyStruct{Name: \"Amy\", Score: 34}                                                                                         \n\n    var myMap map[string]interface{}                                                                                               \n    data, _ := json.Marshal(ms)                                                                                                    \n    fmt.Println(data)                                                                                                              \n\n    json.Unmarshal(data, &amp;amp;myMap)                                                                                                   \n\n    fmt.Println(myMap)                                                                                                             \n\n    _, ok := myMap[\"Name\"]                                                                                                         \n    fmt.Printf(\"name is in myMap: %t\n\", ok)                                                                                       \n\n    _, ok = myMap[\"Location\"]                                                                                                      \n    fmt.Printf(\"Location is in myMap: %t\n\", ok)                                                                                   \n\n} \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/jjByob2XP6-\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何检查结构中是否存在结构值", ["\n\n", "I am retrieving data from an API.\nThe struct output is :", "\n\n", " {\n    StreamSpecification: {\n      StreamEnabled: true,\n      StreamViewType: \"NEW_AND_OLD_IMAGES\"\n     },\n    TableStatus: \"ACTIVE\"\n  }\n", "\n\n", "But if the API output does not have StreamSpecification in it, I am receiving the following error when trying to print the struct.", "\n\n", "panic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=xxxxxxxx]", "\n\n", "How to check if the struct StreamSpecification exists in the value? Or how to fix the issue in any other way?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n#include&amp;lt;stdio.h&amp;gt;\n\n\nstruct &lt;span class=\"hljs-symbol\"&gt;Student&lt;/span&gt;\n{\n    char name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    char id[&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;];\n    float grad[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    float aver;\n} stu[&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;];\n\n\nvoid aver()\n{\n    for(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        stu[i].aver&amp;#61;(stu[i].grad[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#43;stu[i].grad[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#43;stu[i].grad[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])/&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    }\n    for(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名:%s 学号:%s 平均成绩:%f\\n&amp;#34;&lt;/span&gt;,stu[i].name,stu[i].id,stu[i].aver);\n    }\n}\n\nvoid &lt;span class=\"hljs-symbol\"&gt;Max&lt;/span&gt;()\n{\n    int flag;\n    int &lt;span class=\"hljs-symbol\"&gt;Max&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    for(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        if(&lt;span class=\"hljs-symbol\"&gt;Max&lt;/span&gt;&amp;lt;stu[i].grad[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#43;stu[i].grad[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#43;stu[i].grad[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])\n        {\n            &lt;span class=\"hljs-symbol\"&gt;Max&lt;/span&gt;&amp;#61;stu[i].grad[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#43;stu[i].grad[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#43;stu[i].grad[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];\n            flag&amp;#61;i;\n        }\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;成绩最高者:%s\\t%s\\t%.2f\\t%.2f\\t%.2f&amp;#34;&lt;/span&gt;,stu[flag].name,stu[flag].id,stu[flag].grad[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],stu[flag].grad[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],stu[flag].grad[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n}\n\nint main()\n{\n    for(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d名同学的姓名/学号/成绩&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %f %f %f&amp;#34;&lt;/span&gt;,stu[i].name,stu[i].id,&amp;amp;stu[i].grad[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],&amp;amp;stu[i].grad[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],&amp;amp;stu[i].grad[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n\n    }\n    //平均成绩\n    aver();\n    //成绩最高\n    &lt;span class=\"hljs-symbol\"&gt;Max&lt;/span&gt;();\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["一道大一结构体相关c语言，求解答", ["有 6 个学生，每个学生的数据包括学号、姓名、3 门课的成绩，编写函数，实现", "功能: （1）从键盘输入学生信息，存入到一个结构体数组中；", "（2）计算学生三门课程的平均成绩，并存入到结构体数组中；", "（3）打印出每门课的班级平均成绩；", "（4）打印出最高分的学生的数据(包括学号、姓名、3 门课的成绩)。", "要求：设计一个能保存学生信息的结构，包括学生的学号，姓名，成绩数组和平均", "分； 在主函数中输入学生的学号，姓名和三门课成绩；在主函数中调用各函数实现功能，并", "显示相应结果。"]], "Tag": "程序设计"}
{"Answer": "scanf里面的数组名已经代表地址了，不用再加取地址符&amp;了。\r\nsum代表一个学生的成绩总和，为什么要定义成数组？\r\n如果sum[0]是存放成绩总和，那sum[1]存放什么？\r\n数组的存放是从下标为0的元素开始的，s[2]和sum[2]明显是错的。\r\n数组越界了，基本不存在这两个元素。\r\ns[2]要改为s[3]。\r\nfor(i = 0; i &lt; 1; i++)什么意思？就循环一次。\r\n你想一下，这一句要与不要有区别吗？\r\n交换两个结构体居然用二重循环，完全没必要！\r\n从你的代码可以看出你对数组和循环还是没掌握。\r\n还需要弄明白什么是数组？什么是数组元素？如何表示数组元素？数组名代表什么？\r\n数组地址代表什么？数组与指针的关系是什么？什么是数组指针？什么是指针数组？\r\n不要以为数组很简单，数组还是有必要去深究的。\r\n\r\n\r\n```\r\n #include &lt;stdio.h&gt;\r\n\r\nstruct Student\r\n{\r\n\tint num;\r\n\tchar name[20];\r\n\tchar class[7];\r\n\tchar sex[3];\r\n\tfloat math;\r\n\tfloat english;\r\n\tfloat chinese;\r\n\tfloat sum;\r\n}s[3],temp;\r\nint main()\r\n{\r\n\tint i,j,k;\r\n\tprintf(\"请输入学生的学号，姓名，班级，性别，数学成绩，英语成绩，语文成绩\\n\");\r\n\tscanf(\"%d%s%s%s%f%f%f\",&amp;s[0].num,s[0].name,s[0].class,s[0].sex,&amp;s[0].math,&amp;s[0].english,&amp;s[0].chinese);\r\n\tscanf(\"%d%s%s%s%f%f%f\",&amp;s[1].num,s[1].name,s[1].class,s[1].sex,&amp;s[1].math,&amp;s[1].english,&amp;s[1].chinese);\r\n\tscanf(\"%d%s%s%s%f%f%f\",&amp;s[2].num,s[2].name,s[2].class,s[2].sex,&amp;s[2].math,&amp;s[2].english,&amp;s[2].chinese);\r\n\ts[0].sum = s[0].math+s[0].english+s[0].chinese;\r\n\ts[1].sum = s[1].math+s[1].english+s[1].chinese;\r\n\ts[2].sum = s[2].math+s[2].english+s[2].chinese;\r\n\r\n\tif(s[0].sum &gt; s[1].sum )\r\n\t{\r\n\t\ttemp = s[0];\r\n\t\ts[0] = s[1];\r\n\t\ts[1] = temp;\r\n\t}\r\n\telse if(s[0].sum &gt; s[2].sum)\r\n\t{\r\n\t\ttemp = s[0];\r\n\t\ts[0] = s[2];\r\n\t\ts[2] = temp;\r\n\t}\r\n\telse if(s[1].sum &gt; s[2].sum)\r\n\t{\r\n\t\ttemp = s[1];\r\n\t\ts[1] = s[2];\r\n\t\ts[2] = temp;\r\n\t}\r\n\tfor(i = 0;i &lt;= 2;i++)\r\n\t{\r\n\t\tprintf(\"%d %s %s %s %.1f %.1f %.1f %.1f\\n\",s[i].num,s[i].name,s[i].class,s[i].sex,s[i].math,s[i].english,s[i].chinese,s[i].sum);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n运行结果：\r\n请输入学生的学号，姓名，班级，性别，数学成绩，英语成绩，语文成绩\r\n1 li class1 M 80 70 80\r\n2 xi class1 M 70 70 70\r\n3 qi class1 M 90 90 90\r\n\r\n2 xi class1 M 70.0 70.0 70.0 210.0\r\n1 li class1 M 80.0 70.0 80.0 230.0\r\n3 qi class1 M 90.0 90.0 90.0 270.0\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言中的结构体和数组结合，不知道错在哪儿", ["#include", "\nstruct Student", "\n{", "\n    int num;", "\n    char name[20];", "\n    int banji;", "\n    char sex;", "\n    int math;", "\n    int english;", "\n    int chinese;", "\n    int sum[2]; ", "\n}s[2],temp;", "\nmain()", "\n{", "\n    int i,j,k;", "\n\n", "printf(\"请输入学生的学号，姓名，班级，性别，数学成绩，英语成绩，语文成绩\\n\");\nscanf(\"%d%s%d%s%d%d%d\",&s[0].num,&s[0].name,&s[0].banji,&s[0].sex,&s[0].math,&s[0].english,&s[0].chinese);\nscanf(\"%d%s%d%s%d%d%d\",&s[1].num,&s[1].name,&s[1].banji,&s[1].sex,&s[1].math,&s[1].english,&s[1].chinese);\nscanf(\"%d%s%d%s%d%d%d\",&s[2].num,&s[2].name,&s[2].banji,&s[2].sex,&s[2].math,&s[2].english,&s[2].chinese);\n\ns[0].sum[0]=s[0].math+s[0].english+s[0].chinese;\ns[1].sum[1]=s[1].math+s[1].english+s[1].chinese;\ns[2].sum[2]=s[2].math+s[2].english+s[2].chinese;\n\nfor(i=0;i<1;i++)\n{\n    k=i;\n    for(j=i+1;j<2;j++)\n    if(s[j].sum[j]>s[k].sum[k])\n    k=j;\n    temp=s[k];\n    s[k]=s[i];\n    s[i]=temp;\n\n}\nfor(i=0;i<2;i++)\n{\n", "\n\n", "//  printf(\"%d\",s[i].sum[i]);", "\n    printf(\"%d%s%d%s%d%d%d%d\\n\",s[i].num,s[i].name,s[i].banji,s[i].sex,s[i].math,s[i].english,s[i].chinese,s[i].sum);", "\n}", "\n}"]], "Tag": "程序设计"}
{"Answer": "把姓名和名字放在一个结构体里，就是用结构体写。\r\nstruct stuff{  \r\n        char Xing;  \r\n        char Name\r\n}Xingming;", "Konwledge_Point": "数据封装——结构体", "Question": ["什么问题啊啊，这个用结构体应该怎么写啊", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You can get very close to the amount of memory required by the structure and its content by using the package reflect. You need to iterate over the fields and obtain the size of each field. For example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func getSize(v interface{}) int {\n    size := int(reflect.TypeOf(v).Size())\n    switch reflect.TypeOf(v).Kind() {\n    case reflect.Slice:\n        s := reflect.ValueOf(v)\n        for i := 0; i &amp;lt; s.Len(); i++ {\n            size += getSize(s.Index(i).Interface())\n        }\n    case reflect.Map:\n        s := reflect.ValueOf(v)\n        keys := s.MapKeys()\n        size += int(float64(len(keys)) * 10.79) // approximation from https://golang.org/src/runtime/hashmap.go\n        for i := range(keys) {\n            size += getSize(keys[i].Interface()) + getSize(s.MapIndex(keys[i]).Interface())\n        }\n    case reflect.String:\n        size += reflect.ValueOf(v).Len()\n    case reflect.Struct:\n        s := reflect.ValueOf(v)\n        for i := 0; i &amp;lt; s.NumField(); i++ {\n            if s.Field(i).CanInterface() {\n                size += getSize(s.Field(i).Interface())\n            }\n        }\n    }\n    return size\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This obtains the size of v using reflect and then, for the supported types in this example (slices, maps, strings, and structs), it computes the memory required by the content stored in them. You would need to add here other types that you need to support.&lt;/p&gt;\n\n&lt;p&gt;There are a few details to work out:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Private fields are not counted.&lt;/li&gt;\n&lt;li&gt;For structs we are double-counting the basic types.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;For number two, you can filter them out before doing the recursive call when handling structs, you can check the kinds in the documentation for the &lt;a href=\"https://golang.org/pkg/reflect/#Kind\" rel=\"nofollow noreferrer\"&gt;reflect package&lt;/a&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何在Go中获取包含数据结构的结构的大小？", ["\n\n", "I'm currently trying to get the size of a complex struct in Go.", "\n\n", "I've read solutions that use ", "reflect", " and ", "unsafe", ", but neither of these help with structs that contain arrays or maps (or any other field that's a pointer to an underlying data structure). ", "\n\n", "Example:", "\n\n", "type testStruct struct {\n    A     int\n    B     string\n    C     struct{}\n    items map[string]string\n}\n", "\n\n", "How would I find out the correct byte size of the above if ", "items", " contains a few values in it?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;局部和全局&amp;#xff0c;与结构体是没有啥关系的。&lt;br /&gt;这里有几个知识点你梳理一下&amp;#xff1a;&lt;br /&gt;1&amp;#xff1a;结构体的概念&amp;#xff0c;在我的理解中结构体是提供给我们自定义我们需要的类型提供的关键字&amp;#xff0c;可以把他和int&amp;#xff0c;char这种对比理解。&lt;br /&gt;2&amp;#xff1a;有关局部和全局的概念&amp;#xff0c;你肯定经常会听说作用域&amp;#xff0c;局部变量&amp;#xff0c;全局变量等一些概念&amp;#xff0c;我们应该一起对比去理解&amp;#xff1a;&lt;br /&gt;我们知道&amp;#xff0c;变量有作用域&amp;#xff0c;比如函数内部声明的变量&amp;#xff0c;出了函数作用域&amp;#xff0c;就无效了&amp;#xff0c;那么&amp;#xff0c;这个函数内部相对于调用这个函数的外部&amp;#xff0c;函数内部就是一个局部作用域&amp;#xff0c;内部的变量就是局部变量喽&amp;#xff0c;而如果直接定义在main()函数外面&amp;#xff0c;这个变量是一开始程序就会去定义&amp;#xff0c;在main开始执行前&amp;#xff0c;那么main函数入口以及其他所有的函数都能使用这个变量&amp;#xff0c;这种变量叫做全局喽。&lt;br /&gt;所以 像楼上那种&amp;#xff0c;你定义在main函数外部&amp;#xff0c;那就叫全局&amp;#xff0c;在任何的作用域内定义的变量&amp;#xff0c;其实相对这个作用域外部&amp;#xff0c;叫局部喽。&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;个人理解描述&amp;#xff0c;细节可以参考百度~&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体和结构体数组的概念和内容", ["局部结构体数组是什么意思？和全局结构体数组有什么区别呢？比如:构造学生类型，包括学号、姓名以及A、B、C三门课程的成绩信息。现对n个学生的数据做统计，要求得出A、B、C每门课程的平均成绩，以及每个学生三门课程的平均成绩。（采用局部结构体数组实现，测试数据同上题）"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You can use &lt;code&gt;make&lt;/code&gt; and then iterate through the matrix to initialize it.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    defaultInner := newInner(100)\n    o.members = make([][]Inner, o.row)\n    for i := 0; i &amp;lt; o.row; i++ {\n        o.members[i] = make([]Inner, o.col)\n        for j := 0; j &amp;lt; o.col; j++ {\n            o.members[i][j] = *defaultInner\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["嵌套的结构体初始化数组：如果两个结构体的构造函数都可用，该怎么办？", ["\n\n", "New to golang. I have two struct types (called Inner, Outer), and have constructors for each of them that I would like to use. Outer struct \"has-a\" 2d array of Inner struct. How do  I use the constructor for the inner type inside the constructor of outer struct, to initialize the array of inner?", "\n\n", "\n", "\n", "\n", "type Inner struct {\n  val int\n}\n\nfunc newInner(val int) *Inner {\n  i:=new(Inner)\n  i.val=val\n  return i\n}\n\n\ntype Outer struct {\n  members [][]Inner\n  row int\n  col int\n}\n\nfunc newOuter(row int, col int) *Outer {\n  o:=new(Outer)\n  o.row=row\n  o.col=col\n  //how do I initialize a 2d array of size [row][col] and \n  //using the constructor for inner?\n  return o  \n}", "\n", "\n\n", "\n", "\n\n", "</div>\n", "\n"]], "Tag": "程序设计"}
{"Answer": "1.数组在定义时可以用字符串对其直接初始化，如你程序中：\r\n  char test[20]=\"xxxxx\";\r\n  这是编译不报错的原因。\r\n\r\n2.若要对数组进行赋值可用strcpy或者对数组每个元素单独赋值。你程序中：\r\n  stu.name=\"xxxxx\"; \r\n  赋值运算符左边stu.name是个地址常量，显然是不能被赋值的，编译肯定是要报错的。", "Konwledge_Point": "数据封装——结构体", "Question": ["关于C++结构体、数组还有指针的问题", ["1.char test[20]=\"xxxxx\";编译是不会出错的。", "\n2.struct student", "\n{", "\n    int num;", "\n    char name[20];", "\n    float score[3];", "\n};", "\nvoid main(int argc, char* argv[])", "\n{", "\n    struct student stu;", "\n    stu.name=\"xxxxx\";", "\n}", "\n会报：", "\nerror C2440: '=' : cannot convert from 'char [6]' to 'char [20]'", "\n        There is no context in which this conversion is possible", "\n这样的错误。", "\n3.改成struct student", "\n{", "\n    int num;", "\n    char name[6];", "\n    float score[3];", "\n};", "\nvoid main(int argc, char* argv[])", "\n{", "\n    struct student stu;", "\n    stu.name=\"xxxxx\";", "\n}", "\n则会报:", "\nerror C2106: '=' : left operand must be l-value", "\n4.将char name[20];改为char *name;就不会报错了。", "\n请问上面为什么报错？"]], "Tag": "程序设计"}
{"Answer": "（1）node表明的是这个结构体的名字，建议一般都写上，因为如果之后需要用的时候，也可以直接使用这个名字来进行定义，比如说： node nod1；\r\n（2）BiNode表示的是用node定义的一个node节点，那么在需要操作这个里面的数据的时候用‘.’就能操作，比如说：BiNode.value ， BiNode.data；\r\nBitree表示的是node指针，这个指针可以用来指向一个node，比如说你之后在用的时候，可以：Bitree = new node(); 表明让Bitree指针指向一个新建的node对象（其实就是一块内存控件，在c++中可以说是对象），之后操作的时候就可以：Bitree-&gt;value, Bitree-&gt;data 。", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构 树的结构体定义 在线等！！", ["\n\n", "如图所示", "\n\n", "（1）第一行typedef struct node 的那个node 什么时候写 什么时候不写？", "\n\n", "（2）最后括号外面的 BiNode ，*BiTree 分别是什么作用？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第18 行 &amp;#xff0c;23 行&amp;#xff0c;前面的格式控制符的个数 和 后面对应的参数个数对不上&amp;#xff0c;前面是5个后面是6个&amp;#xff0c;前面是6个后面是7个&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/288862347736166.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/275772347736136.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["用结构体输入学号成绩等，计算平均分，输出排行榜。为什么计算出平均值是0？", ["\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;point&lt;/span&gt;{    &lt;span class=\"hljs-comment\"&gt;//定义坐标结构体&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; s;   &lt;span class=\"hljs-comment\"&gt;//同时加上距离项&amp;#xff0c;方便排序&lt;/span&gt;\n};\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;    &lt;span class=\"hljs-comment\"&gt;//n个候选点&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);    \n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;point&lt;/span&gt; poi[n];\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;point&lt;/span&gt; test;     &lt;span class=\"hljs-comment\"&gt;//调换顺序中间体&amp;#xff08;结构体允许整个结构赋值&amp;#xff09;&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;,&amp;amp;poi[i].x,&amp;amp;poi[i].y);\n        poi[i].s&amp;#61;poi[i].x*poi[i].x&amp;#43;poi[i].y*poi[i].y;\n        poi[i].s&amp;#61;&lt;span class=\"hljs-built_in\"&gt;pow&lt;/span&gt;(poi[i].s,&lt;span class=\"hljs-number\"&gt;0.5&lt;/span&gt;);\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;n-i&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;j&amp;#43;&amp;#43;){\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(poi[j].s&amp;gt;poi[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].s)   &lt;span class=\"hljs-comment\"&gt;//根据s数据项进行排序&lt;/span&gt;\n            {                         \n                test&amp;#61;poi[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                poi[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;poi[j];      &lt;span class=\"hljs-comment\"&gt;//首尾相接三行代码调换顺序&lt;/span&gt;\n                poi[j]&amp;#61;test;\n            }\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;(%d,%d)&amp;#34;&lt;/span&gt;,poi[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].x,poi[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].y);   &lt;span class=\"hljs-comment\"&gt;//输出排序第一&amp;#xff0c;即s最小的点坐标&lt;/span&gt;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体，找坐标上距离原点最近的点", ["现在结构体写的是", "struct point{", "int x；", "int y；}", "从键盘上输入一个整数n，100＞＝n＞＝1 ，输n个横纵坐标，找距离原点最近的点输出，如果两点到原点距离相等的话，取横坐标小的点，如果横坐标也一样，就取纵坐标小的点输出格式为(横坐标，纵坐标)"]], "Tag": "程序设计"}
{"Answer": "你光定义了指针，没有分配空间\r\n```\r\nStaticTable *Tb1 = (StaticTable *)malloc(sizeof(StaticTable));\r\n```\r\n\r\n# 问题解决的话，请点采纳", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体里的数组出错", ["#include<stdio.h>\ntypedef struct Node{\n    int A[100];\n    int Length;\n}StaticTable;\nint BinerySearch(StaticTable *Tb1,int K){\n    /**/\n    }\n    return NotFound;\n} \nint SequentialSearch(StaticTable *Tb1,int K){\n/**/\n} \nint main(){\n    StaticTable *Tb1;\n    for(int i=1;i<=10;i++){\n        Tb1->A[i]=5;//执行到这里就会出错，可是我看不出哪里错了，求大佬指点\n    }\n    Tb1->Length=10;\n    printf(\"%d\\t\",SequentialSearch(Tb1,36));\n    printf(\"%d\",BinerySearch(Tb1,36));\n    return 0;\n} \n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你测试有什么问题&amp;#xff0c;还有方便的话&amp;#xff0c;直接粘贴代码吧&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;printf(&amp;#34;请输入学生的学号&amp;#xff0c;姓名&amp;#xff0c;成绩\\n&amp;#34;); \nscanf(&amp;#34;%d%s%d&amp;#34;,&amp;amp;&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.number&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.name&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.math&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.english&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.chinse&lt;/span&gt;); \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["使用C语言结构体编一段程序，输入10个学生的学号，姓名，三门课程的成绩，求出总分最高的学生姓名并输出", ["帮我看看错在哪里啊😓"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;code&gt;t.H&lt;/code&gt; is nil because you are giving an incorrect value in &lt;code&gt;Set&lt;/code&gt; method. You are getting &lt;code&gt;Value&lt;/code&gt; of &lt;code&gt;reflect.New&lt;/code&gt;'s return (&lt;code&gt;reflect.New(...).Elem()&lt;/code&gt; is &lt;code&gt;Hello&lt;/code&gt; type, no &lt;code&gt;*Hello&lt;/code&gt; type and type of &lt;code&gt;H&lt;/code&gt; field is &lt;code&gt;*Hello&lt;/code&gt; type). If you change the type of &lt;code&gt;H&lt;/code&gt;field to &lt;code&gt;Hello&lt;/code&gt; type, you will see that it is initialized okay Then, you should do this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;controllerStruct.Elem().Field(i).Set(\n    reflect.New(\n        controllerStruct.Elem().Field(i).Type().Elem(),\n    ),\n)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Value of &lt;code&gt;reflect.New(controllerStruct.Elem().Field(i).Type().Elem())&lt;/code&gt; is a new &lt;code&gt;*Hello&lt;/code&gt; struct.&lt;/p&gt;\n\n&lt;p&gt;I hope that it's useful to you! :-)&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Golang使用反射设置结构字段", ["\n\n", "I am currently doing the following", "\n\n", "func Test(controller interface{}) {\n    controllerType := reflect.TypeOf(controller)\n    controllerFunc := reflect.ValueOf(controller)\n    controllerStruct := reflect.New(controllerType.In(0))\n    for i := 0; i < controllerStruct.Elem().NumField(); i++ {\n        if controllerStruct.Elem().Field(i).Kind().String() == \"ptr\" {\n            controllerStruct.Elem().Field(i).Set(\n                reflect.New(\n                    controllerStruct.Elem().Field(i).Type(),\n                ).Elem(),\n            )\n        }\n    }\n    controllerFunc.Call([]reflect.Value{\n        controllerStruct.Elem(),\n    })\n}\n", "\n\n", "Using the following function call", "\n\n", "Test(controllers.Test.IsWorking)\n\ntype Test struct {\n    Name string\n    H    *Hello\n}\n\ntype Hello struct {\n    Friend string\n}\n\nfunc (t Test) IsWorking() {\n    log.Println(t.H)\n}\n", "\n\n", "t.H", " is always ", "nil", " even tho I am setting it on the for loop. Also I am not sure if this is the correct way to make this since what about if ", "Hello", " struct contains another pointer to a struct. Is there a better method to achieve what I am trying to do and why is ", "t.H", " ", "nil", " if I am setting it up", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;改了下&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/950571557256116.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;\n \n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt; ss;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; id[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;25&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, ss* p)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Output&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, ss* p)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;N);\n    ss* p &amp;#61; (ss*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(ss)*N);\n    &lt;span class=\"hljs-built_in\"&gt;Input&lt;/span&gt;(N, p);\n    &lt;span class=\"hljs-built_in\"&gt;Output&lt;/span&gt;(N, p);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(p);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, ss* p)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s%s%d%d%d\\n&amp;#34;&lt;/span&gt;, p[i].id, p[i].name, &amp;amp;p[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], &amp;amp;p[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], &amp;amp;p[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Output&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, ss* p)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s,%s,%d,%d,%d\\n&amp;#34;&lt;/span&gt;, p[i].id, p[i].name, p[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], p[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], p[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在做结构体的时候用vs输入的答案，但vs还是一直报错", ["\n#", "include", "<stdio.h>\n#", "include", "<stdlib.h>\ntypedef ", "struct", " student ss;\n", "struct", " student\n{\n    ", "char", " id", "[", "20", "]", ";\n    ", "char", " name", "[", "25", "]", ";\n    ", "int", " score", "[", "3", "]", ";\n};\nvoid ", "Input(", "int", " ", "n", ", ", "ss", "*", " ", "p", ")", ";\nvoid ", "Output(", "int", " ", "n", ", ", "ss", "*", " ", "p", ")", ";\n", "int", " main", "()", "\n{\n    ", "int", " N;\n    scanf", "_s(", "\"%d\"", ", &N)", ";\n    ss* p = (ss*)malloc(sizeof(ss)*N);\n    ", "Input(N, ", "p", ")", ";\n    ", "Output(N, ", "p", ")", ";\n    free(p);\n    return ", "0", ";\n}\nvoid ", "Input(", "int", " ", "n", ", ", "ss", "*", " ", "p", ")", "\n{\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        scanf", "_s(", "\"%s%s%d%d%d\\n\"", ", ", "p", "[", "i", "].", "id", ", ", "p", "[", "i", "].", "name", ", &", "p", "[", "i", "].", "score", "[0], &", "p", "[", "i", "].", "score", "[1], &", "p", "[", "i", "].", "score", "[2])", ";\n    }\n    return;\n}\nvoid ", "Output(", "int", " ", "n", ", ", "ss", "*", " ", "p", ")", "\n{\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        printf(", "\"%s,%s,%d,%d,%d\\n\"", ", p", "[", "i", "]", ".id, p", "[", "i", "]", ".name, p", "[", "i", "]", ".score", "[", "0", "]", ", p", "[", "i", "]", ".score", "[", "1", "]", ", p", "[", "i", "]", ".score", "[", "2", "]", ");\n    }\n    return ;\n}\n", "\n", "vs一直报错Input中scanf_s那一句一直说：0x7BF5D4EC (ucrtbased.dll)处(位于 结构体成绩记录（答案）.exe 中)引发的异常: 0xC0000005: 写入位置 0x0107E000 时发生访问冲突。", "我输入的是正确答案，但是我自己输入自己代码的时候也是一直报这个错误，为啥啊。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;写字符串需要加双引号的 像stu&amp;#61;{&amp;#34;11&amp;#34;,&amp;#34;22&amp;#34;,&amp;#34;33&amp;#34;,&amp;#34;44&amp;#34;}&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["我想把结构体的内容写入一个文件，为什么不成功，怎么才行", ["#include\"stdio.h\"", " struct student", " {char rcord[10];", "  char name[10];", "  char phone[12];", "  char qq[20];", " }stu={11,22,33,44},stu1;", "void main()", "{", "  FILE *fp;", "  fp=fopen(\"c://p.txt\",\"wb+\");", "  rewind(fp);", "  fwrite(&stu,sizeof(stu),1,fp);", "  rewind(fp);", "  fread(&stu1,sizeof(stu1),1,fp);", "  printf( \"%c%c%c%c\",stu1.rcord,stu1.name,stu1.phone,stu1.qq);", "  fclose(fp);", "}"]], "Tag": "程序设计"}
{"Answer": "代码不全。\r\n\r\n是这样的，和参数无关，C语言存在类型的隐式转换，比如说一个short可以被当作一个int，而无需额外的转换，但是相反就不行。\r\n隐式转换方便了开发者编码，但是它的限制同样为了防止你无心犯错。\r\n\r\n好比你用大碗盛小碗的食物，编译器不用让你确认，自己就做了。但是你用小碗装大碗的食物，那么编译器提醒你，如果大碗的东西太多，可能会出错。那么你需要写清楚，表示你知道这么回事，它才接受。", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言函数的形参（结构体类型）和实参类型（指针）可以不同吗？", ["int numstus; ", "\nint lens; ", "\nstudent ", "pointer; ", "\nvoid main() ", "\n{ ", "\n int i=1; ", "\n char str[2]; ", "\n lens=100; ", "\n pointer=(student *)malloc(lens*LEN); /", "分配内存*/ ", "\n numstus=0; ", "\n welcome(); /*欢迎界面*/ ", "\n while(i>0) ", "\n { ", "\n  i=menu_select(); /*控制菜单*/ ", "\n  switch(i) ", "\n  { ", "\n  case 1:addrecord(pointer);break; /*增加学生信息*/ ", "\n    。。。省略", "\n    而当调用addrecord函数的定义是", "\n    void addrecord(student stud[]) {...}", "\n    pointer是个结构体指针", "\n    addrecord参数是 结构体类型", "\n    程序无错，传递可行", "\n    真是怎么回事"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;应该答案错了吧&amp;#xff0c;int 4字节&amp;#xff0c;但是实际上总共占用32字节&amp;#xff0c;因为还有补齐原则&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体所占内存的字节数", ["请问为什么是加上s数组的八个字节啊，题目没看懂怎么算的，晕了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的name是不是string类型的。&lt;br /&gt;malloc是c的写法&lt;br /&gt;c&amp;#43;&amp;#43;用new&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/qq_28234213/article/details/77880629\" id=\"textarea_1631600866101_1631600880242_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;结构体中含有string 会异常的原因和解决办法_蔡松豆的博客-CSDN博客_结构体包含string&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;#include #include #include using namespace std;typedef struct node{string str;}NODE;int main(){string var &amp;#61; &amp;#34;lirao&amp;#34;;NODE * node &amp;#61; (NODE *)malloc (sizeof(NODE));node-&amp;gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_28234213/article/details/77880629&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["vs2019c++把string字符串写入定义于在堆上的结构体中失败，和我输入的不一样，是什么问题？", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;GORM &lt;em&gt;is&lt;/em&gt; returning an empty object; when it comes to Go values, \"empty\" and \"default\" are the same, and are actually called the &lt;a href=\"https://golang.org/ref/spec#The_zero_value\" rel=\"nofollow noreferrer\"&gt;zero value&lt;/a&gt;. In your situation, you're needing to control the JSON output, not the GORM return value.&lt;/p&gt;\n\n&lt;p&gt;You can add the &lt;code&gt;omitempty&lt;/code&gt; tag to your fields to have them exluded from JSON output if they contain the zero value for their type:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Domain struct {\n    gorm.Model\n    Name string `json:\",omitempty\"`\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;For each field with this tag, when you call &lt;code&gt;Encode&lt;/code&gt; or &lt;code&gt;Marshal&lt;/code&gt;, if the field contains its zero value (e.g. for &lt;code&gt;Name&lt;/code&gt;, which is a &lt;code&gt;string&lt;/code&gt;, if it is equal to &lt;code&gt;\"\"&lt;/code&gt;), the field will not be included in the output. If you tag all the exported fields this way, and they all contain their zero values, the output will be an empty JSON object &lt;code&gt;{}&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Also note that this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;json.NewEncoder(w).Encode(make(map[string]string))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Is equivalent to, but significantly less efficient than:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;w.Write([]byte(\"{}\"))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Your other option would be a custom marshal func, something like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (d Domain) MarshalJSON() ([]byte, error) {\n    if t.ID == 0 {\n        return []byte(\"{}\"), nil\n    }\n\n    // Wrap the type to avoid infinite recursion on MarshalJSON\n    type dd Domain\n    return json.Marshal(dd(d))\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can see a working sample here: &lt;a href=\"https://play.golang.org/p/mIRfRKXeyyW\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/mIRfRKXeyyW&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["当找不到值时，Gorm返回空对象，而不是默认对象", ["\n\n", "I made a MySQL query using GORM inside a little go app.", "\n\n", "I have declared my ", "domain", " struct", "\n\n", "type Domain struct {\n    gorm.Model\n    Name string\n    ...\n}\n", "\n\n", "Then when I send a query to MySQL with GORM with this method.", "\n\n", "func DomainInfos(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    w.WriteHeader(http.StatusOK)\n\n    var d Domain\n\n    config.DbConnection.Where(\"name = ?\", vars[\"domain\"]).Find(&d)\n\n    json.NewEncoder(w).Encode(d)\n}\n", "\n\n", "When the domain is not found it return an default object from my struct definition", "\n\n", "{\n    {0 0001-01-01 00:00:00 +0000 UTC 0001-01-01 00:00:00 +0000 UTC <nil>} \n    0\n    0\n    0\n}\n", "\n\n", "So I wrote a little condition to manually return an empty object", "\n\n", "if d.ID == 0 {\n    json.NewEncoder(w).Encode(make(map[string]string))\n    return\n}\n", "\n\n", "Is it possible GORM return an empty object directly when the query return nothing, to avoid this manual checking ?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;方差先求平均值&amp;#xff0c;然后用所有的值减去平均值求平方和/N&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 4&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Date&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; year;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; month;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; day;\n};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; qu;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Date&lt;/span&gt; birthday;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student stu[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入各学生的信息&amp;#xff1a;学号、姓名、区域、生日、C语言成绩&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lld %s %d %d %d %d %d&amp;#34;&lt;/span&gt;, &amp;amp;stu[i].num, stu[i].name, &amp;amp;stu[i].qu, &amp;amp;stu[i].birthday.year, &amp;amp;stu[i].birthday.month, &amp;amp;stu[i].birthday.day, &amp;amp;stu[i].score);\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//输出最高成绩&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;maxScore&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student stu[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (stu[i].score &amp;gt; stu[index].score)\n            index &amp;#61; i;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;成绩最高的学生信息为&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lld %s %d %d%02d%02d %d\\n&amp;#34;&lt;/span&gt;, stu[index].num, stu[index].name, stu[index].qu, stu[index].birthday.year, stu[index].birthday.month, stu[index].birthday.day, stu[index].score);\n}\n&lt;span class=\"hljs-comment\"&gt;//求平均值和方差&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ave&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student stu[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; ave1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, ave2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//区内和区外学生的平均分&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, n2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; s1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, s2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//方差&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (stu[i].qu &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//区内&lt;/span&gt;\n        {\n            ave1 &amp;#43;&amp;#61; stu[i].score;\n            n1&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            ave2 &amp;#43;&amp;#61; stu[i].score; &lt;span class=\"hljs-comment\"&gt;//区外&lt;/span&gt;\n            n2&amp;#43;&amp;#43;;\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;//平均值&lt;/span&gt;\n    ave1 /&amp;#61; n1;\n    ave2 /&amp;#61; n2;\n    &lt;span class=\"hljs-comment\"&gt;//方差&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (stu[i].qu &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//区内&lt;/span&gt;\n        {\n            s1 &amp;#43;&amp;#61; (stu[i].score - ave1) * (stu[i].score - ave1);\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            s2 &amp;#43;&amp;#61; (stu[i].score - ave2) * (stu[i].score - ave2); &lt;span class=\"hljs-comment\"&gt;//区外&lt;/span&gt;\n        }\n    }\n    s1 /&amp;#61; n1;\n    s2 /&amp;#61; n2;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;区内学生平均分&amp;#xff1a;%.2f,方差&amp;#xff1a;%.2f\\n&amp;#34;&lt;/span&gt;, ave1, s1);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;区外学生平均分&amp;#xff1a;%.2f,方差&amp;#xff1a;%.2f\\n&amp;#34;&lt;/span&gt;, ave2, s2);\n}\n&lt;span class=\"hljs-comment\"&gt;//比较日期&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Date d1, &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Date d2)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.year &amp;lt; d2.year)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.year &amp;gt; d2.year)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.month &amp;lt; d2.month)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.month &amp;gt; d2.month)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.day &amp;lt; d2.day)\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1.day &amp;gt; d2.day)\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//按生日排序&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sortByBirtyday&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student stu[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; t;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; N - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; - i; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;cmp&lt;/span&gt;(stu[j].birthday, stu[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].birthday) &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//按生日从小到大排序&lt;/span&gt;\n            {\n                t &amp;#61; stu[j];\n                stu[j] &amp;#61; stu[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                stu[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t;\n            }\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;//输出&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;按生日先后排序&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lld %s %d %d%02d%02d %d\\n&amp;#34;&lt;/span&gt;, stu[i].num, stu[i].name, stu[i].qu, stu[i].birthday.year, stu[i].birthday.month, stu[i].birthday.day, stu[i].score);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; stu[N];\n    &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(stu);\n    &lt;span class=\"hljs-built_in\"&gt;maxScore&lt;/span&gt;(stu); &lt;span class=\"hljs-comment\"&gt;//&amp;#xff08;1&amp;#xff09;&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;ave&lt;/span&gt;(stu);&lt;span class=\"hljs-comment\"&gt;//(2)&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;sortByBirtyday&lt;/span&gt;(stu);&lt;span class=\"hljs-comment\"&gt;//(3)&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["用结构体分别输入n个学生信息，包括，学号，姓名，区域，C语言成绩，计算区域外和区域内的平均值和方差", ["不会解第二三题，自己用书本做出了第一题", "\n", "有15个结构体变量，内含学生学号、姓名、生日、籍贯和C语言成绩，如表所示。", "要求用函数实现以下三个功能：", "1．输出C语言成绩最高的学生的信息；", "2．输出区内学生和区外学生C语言成绩的平均值、方差；", "3．按照生日先后顺序输出全部学生的信息；"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This converts a BitmapDrawable to a Bitmap.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Drawable d = ImagesArrayList.get(0);  \nBitmap bitmap = ((BitmapDrawable)d).getBitmap();\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何转换一个可绘制位图？          ", ["\n\n", "I would like to set a certain ", "Drawable", " as the device's wallpaper, but all wallpaper functions accept ", "Bitmap", "s only. I cannot use ", "WallpaperManager", " because I'm pre 2.1.", "\n\n", "Also, my drawables are downloaded from the web and do not reside in ", "R.drawable", ".", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/3035692/how-to-convert-a-drawable-to-a-bitmap"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n#define Header printf(&amp;#34;图书编号   图书名称   图书单价   作者   状态   借书人学号   借书人姓名   借书人性别\\n&amp;#34;)\n#define Print printf(&amp;#34;%-8d%-8s%-8f%-8s%-8s%-8d%-8s%-8s%\\n&amp;#34;,book[p].BookNum,book[p].BookName,book[p].Money,book[p].Author,book[p].State,book[p].StudentNum,book[p].Name,book[p].Sex)\n\nstruct Book\n{\n    int BookNum;//图书编号\n    char BookName[50];//图书名称\n    float Money;//图书单价\n    char Author[20];//作者\n    char State[10];//存在状态\n    int StudentNum;//借书人学号\n    char Name[20];//借书人姓名\n    char Sex[10];//借书人性别\n}book[100];\nint saveflag&amp;#61;0;\nvoid Menu()\n{\n    printf(&amp;#34;------------图 书 管 理 系 统-----------\\n&amp;#34;);\n    printf(&amp;#34;               主菜单                   \\n&amp;#34;);\n    printf(&amp;#34;    1 新进图书基本信息的输入            \\n&amp;#34;);\n    printf(&amp;#34;    2 图书基本信息的查询                \\n&amp;#34;);\n    printf(&amp;#34;    3 对撤消图书信息的删除              \\n&amp;#34;);\n    printf(&amp;#34;    4 为借书人办理注册                  \\n&amp;#34;);\n    printf(&amp;#34;    5 办理借书手续                      \\n&amp;#34;);\n    printf(&amp;#34;    6 办理还书手续                      \\n&amp;#34;);\n    printf(&amp;#34;----------------------------------------\\n&amp;#34;);\n}\nint OpenFile(int cnt)\n{\n    FILE *fp;\n    int i&amp;#61;0;\n    fp&amp;#61;fopen(&amp;#34;book.dat&amp;#34;,&amp;#34;ab&amp;#43;&amp;#34;);//以追加方式打开D:\\\\demo\\\\Salary.dat二进制文件\n    if(fp&amp;#61;&amp;#61;NULL)\n    {\n        printf(&amp;#34;Can not open file!&amp;#34;);\n        exit(0);\n    }\n    while(!feof(fp))//循环读取文件中的记录&amp;#xff0c;直到文件结束\n    {\n        if(fread(&amp;amp;book[i],sizeof(struct Book),1,fp)&amp;#61;&amp;#61;1)//判断fread()函数读取数据是否成功&amp;#xff0c;返回值为1&amp;#xff0c;则读取了一条记录\n        {\n            cnt&amp;#43;&amp;#43;;\n            i&amp;#43;&amp;#43;;\n        }\n    }\n    fclose(fp);//关闭文件\n    return cnt;//返回文件中记录数\n}\nint Add(int cnt)//添加图书记录\n{\n    int choice;\n    int i,bookNumTemp,j,recordcnt;\n    recordcnt&amp;#61;cnt;\n    printf(&amp;#34;开始添加图书信息....\\n&amp;#34;);\n    for(i&amp;#61;cnt;i&amp;lt;100;i&amp;#43;&amp;#43;)\n    {\n        printf(&amp;#34;图书编号&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%d&amp;#34;,&amp;amp;bookNumTemp);\n        for(j&amp;#61;0;j&amp;lt;i;j&amp;#43;&amp;#43;)\n        {\n            if(book[j].BookNum&amp;#61;&amp;#61;bookNumTemp)//如果编号重复&amp;#xff0c;提示重新输入\n            {\n                printf(&amp;#34;图书编号重复&amp;#xff0c;请重新输入&amp;#xff1a;&amp;#34;);\n                scanf(&amp;#34;%d&amp;#34;,&amp;amp;bookNumTemp);\n                j&amp;#61;-1;//重新输入编号后&amp;#xff0c;让j&amp;#61;-1&amp;#xff0c;经过j&amp;#43;&amp;#43;后&amp;#xff0c;使其为j&amp;#61;0&amp;#xff0c;重新从数组的第一个元素开始比较编号是否重复\n            }\n        }\n        book[i].BookNum&amp;#61;bookNumTemp;\n        getchar();\n        printf(&amp;#34;图书名称&amp;#xff1a;&amp;#34;);\n        gets(book[i].BookName);\n        printf(&amp;#34;图书单价&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%f&amp;#34;,&amp;amp;book[i].Money);\n        printf(&amp;#34;图书作者&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%s&amp;#34;,&amp;amp;book[i].Author);\n        printf(&amp;#34;借阅状态&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%s&amp;#34;,book[i].State);\n        printf(&amp;#34;是否继续输入&amp;#xff1f;1 继续  0 退出&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%d&amp;#34;,&amp;amp;choice);\n        recordcnt&amp;#43;&amp;#43;;//输入完一条记录后让记录数增1\n        if(choice!&amp;#61;1)\n            break;\n    }\n    saveflag&amp;#61;1;//输入记录&amp;#xff0c;记录发生变化&amp;#xff0c;saveflag&amp;#61;1,表示变动后的数据未保存\n    printf(&amp;#34;记录输入完成&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n    getchar();\n    getchar();\n    return recordcnt;//返回记录数\n}\nint Locate(int num,int cnt)//按图书编号查询图书信息\n{\n    int p&amp;#61;-1,i;\n    for(i&amp;#61;0;i&amp;lt;cnt;i&amp;#43;&amp;#43;)\n    {\n        if(book[i].BookNum&amp;#61;&amp;#61;num)\n        {\n            p&amp;#61;i;//记录查询到的记录的下标\n            break;\n        }\n    }\n    return p;//返回查询到的记录下标&amp;#xff0c;如果返回为-1&amp;#xff0c;表示记录不存在\n}\nvoid Query(int cnt)//图书信息查询\n{\n    int choice&amp;#61;0,tempnum,p,count&amp;#61;0,i;\n    char tempname[20];\n    printf(&amp;#34;开始查询图书信息....\\n&amp;#34;);\n    printf(&amp;#34;请选择查询方式&amp;#xff08;1 按编号 2 按书名):&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;choice);\n    switch(choice)\n    {\n        case 1:\n            printf(&amp;#34;请输入要查询图书的编号&amp;#xff1a;&amp;#34;);\n            scanf(&amp;#34;%d&amp;#34;,&amp;amp;tempnum);\n            p&amp;#61;Locate(tempnum,cnt);//调用按编号查询图书信息函数\n            if(-1&amp;#61;&amp;#61;p)\n            {\n                printf(&amp;#34;\\n 查询的图书信息不存在&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n            }\n            else\n            {\n                printf(&amp;#34;查询的图书信息如下&amp;#xff1a;\\n\\n&amp;#34;);\n                Header;\n                printf(&amp;#34;%-8d%-8s%-8f%-8s%-8s%-8d%-8s%-8s\\n&amp;#34;,book[p].BookNum,book[p].BookName,book[p].Money,book[p].Author,book[p].State,book[p].StudentNum,book[p].Name,book[p].Sex);\n                printf(&amp;#34;\\n 图书信息查询完成&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n            }\n            getchar();\n            break;\n        case 2:\n            getchar();\n            printf(&amp;#34;请输入要查询图书姓名&amp;#xff1a;&amp;#34;);\n            gets(tempname);\n            for(i&amp;#61;0;i&amp;lt;cnt;i&amp;#43;&amp;#43;)//按姓名查询可能有多条记录满足&amp;#xff0c;所以不能用Locate()函数\n            {\n                if(strcmp(tempname,book[i].BookName)&amp;#61;&amp;#61;0)//判断元素姓名是否与要查询的姓名相同\n                {\n                    if(count&amp;#61;&amp;#61;0)\n                    {\n                        Header;//如果时第1条要查询的记录&amp;#xff0c;则输出行标题&amp;#xff0c;否则不输出\n                    }\n                    p&amp;#61;i;\n                    Print;//输出查询到的记录\n                    count&amp;#43;&amp;#43;;//查询到的记录数\n                }\n            }\n            if(0&amp;#61;&amp;#61;count)\n                printf(&amp;#34;\\n查询的图书信息不存在&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n            else\n                printf(&amp;#34;\\n图书信息查询完成&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n            break;\n        default:\n            printf(&amp;#34;选择错误&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n    }\n    getchar();\n}\nint Del(int cnt)\n{\n    int tempnum,p,i;\n    printf(&amp;#34;开始删除图书信息....\\n\\n&amp;#34;);\n    printf(&amp;#34;请输入要删除图书的编号&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;tempnum);\n    p&amp;#61;Locate(tempnum,cnt);//调用按编号查询图书信息函数\n    if(-1&amp;#61;&amp;#61;p)\n    {\n        printf(&amp;#34;\\n要删除的图书信息不存在&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n    }\n    else\n    {\n        printf(&amp;#34;要删除的图书信息如下&amp;#xff1a;\\n\\n&amp;#34;);\n        Header;\n        Print;\n        for(i&amp;#61;p;i&amp;lt;cnt-1;i&amp;#43;&amp;#43;)//从要删除的位置开始&amp;#xff0c;用后一条记录把前一条记录覆盖\n        {\n            book[i]&amp;#61;book[i&amp;#43;1];\n        }\n        cnt--;//记录数在原来记录数的基础上减1\n        saveflag&amp;#61;1;//记录发生变化&amp;#xff0c;存盘标志改为未存盘\n        printf(&amp;#34;\\n图书信息修改成功&amp;#xff0c;按任意键返回菜单....&amp;#34;);\n    }\n    getchar();\n    getchar();\n    return cnt;//返回记录数\n}\nint Register(int cnt)//添加借书人记录\n{\n    int choice;\n    int i,bookNumTemp,j,recordcnt;\n    recordcnt&amp;#61;cnt;\n    printf(&amp;#34;开始添加借书人信息....\\n&amp;#34;);\n    for(i&amp;#61;cnt;i&amp;lt;100;i&amp;#43;&amp;#43;)\n    {\n        printf(&amp;#34;借书人学号&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%d&amp;#34;,&amp;amp;bookNumTemp);\n        for(j&amp;#61;0;j&amp;lt;i;j&amp;#43;&amp;#43;)\n        {\n            if(book[j].BookNum&amp;#61;&amp;#61;bookNumTemp)//如果编号重复&amp;#xff0c;提示重新输入\n            {\n                printf(&amp;#34;借书人学号重复&amp;#xff0c;请重新输入&amp;#xff1a;&amp;#34;);\n                scanf(&amp;#34;%d&amp;#34;,&amp;amp;bookNumTemp);\n                j&amp;#61;-1;//重新输入编号后&amp;#xff0c;让j&amp;#61;-1&amp;#xff0c;经过j&amp;#43;&amp;#43;后&amp;#xff0c;使其为j&amp;#61;0&amp;#xff0c;重新从数组的第一个元素开始比较编号是否重复\n            }\n        }\n        book[i].BookNum&amp;#61;bookNumTemp;\n        getchar();\n        printf(&amp;#34;借书人学号&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%d&amp;#34;,&amp;amp;book[i].StudentNum);\n        printf(&amp;#34;借书人姓名&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%s&amp;#34;,&amp;amp;book[i].Name);\n        printf(&amp;#34;借书人性别&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%s&amp;#34;,&amp;amp;book[i].Sex);\n        printf(&amp;#34;是否继续输入&amp;#xff1f;1 继续  0 退出&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%d&amp;#34;,&amp;amp;choice);\n        recordcnt&amp;#43;&amp;#43;;//输入完一条记录后让记录数增1\n        if(choice!&amp;#61;1)\n            break;\n    }\n    saveflag&amp;#61;1;//输入记录&amp;#xff0c;记录发生变化&amp;#xff0c;saveflag&amp;#61;1,表示变动后的数据未保存\n    printf(&amp;#34;记录输入完成&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n    getchar();\n    getchar();\n    return recordcnt;//返回记录数\n}\nvoid ExitSystem(cnt){\n}//退出系统\nint a[100]&amp;#61;{0};\nvoid Borrow(int cnt)//借阅\n{\n    int tempnum,p,teaNumTemp,j;\n    printf(&amp;#34;开始借阅图书....\\n\\n&amp;#34;);\n    int a1;\n    char a2,a3;\n    printf(&amp;#34;请输入您的学号&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;a1);\n    printf(&amp;#34;请输入您的姓名&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%s&amp;#34;,&amp;amp;a2);\n    printf(&amp;#34;请输入您的性别&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%s&amp;#34;,&amp;amp;a3);\n    printf(&amp;#34;请输入要借阅的图书编号&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;tempnum);\n    p&amp;#61;Locate(tempnum,cnt);//调用按编号查询图书信息函数\n    if(-1&amp;#61;&amp;#61;p)//返回值-1,表示要查询的图书信息不存在\n    {\n        printf(&amp;#34;\\n要借阅的图书不存在&amp;#xff0c;按任意键返回菜单....&amp;#34;);\n    }\n    else\n    {\n        printf(&amp;#34;要借阅的图书信息如下&amp;#xff1a;\\n\\n&amp;#34;);\n        Header;\n        Print;//显示查询到的图书信息\n        printf(&amp;#34;借阅后图书信息&amp;#xff1a;\\n&amp;#34;);\n        printf(&amp;#34;图书状态&amp;#xff1a;&amp;#34;);\n        strcpy(book[10].State,&amp;#34;已借出&amp;#34;);\n        printf(&amp;#34;借书人学号&amp;#xff1a;&amp;#34;);\n        book[p].StudentNum&amp;#61;a1;\n        printf(&amp;#34;借书人姓名&amp;#xff1a;&amp;#34;);\n//        book[p].Name&amp;#61;a2;\n        printf(&amp;#34;借书人性别&amp;#xff1a;&amp;#34;);\n//        book[p].Sex&amp;#61;a3;\n        Header;\n        Print;\n        a[p]&amp;#61;book[p].BookNum;\n        book[p].BookNum&amp;#61;0;\n        saveflag&amp;#61;1;//记录发生变化&amp;#xff0c;存盘标志改为未存盘\n        printf(&amp;#34;\\n图书借阅成功&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n    }\n    getchar();\n    getchar();\n}\nvoid Back(int cnt)//归还\n{\n    int tempnum,p,teaNumTemp,j,a1&amp;#61;0;\n    char x2;\n    x2 &amp;#61; &amp;#39;X&amp;#39;;\n    int i,c,d;\n    printf(&amp;#34;开始归还图书....\\n\\n&amp;#34;);\n    printf(&amp;#34;请输入要归还的图书编号&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;c);\n    for(i&amp;#61;0;i&amp;lt;101;i&amp;#43;&amp;#43;)\n    {\n        if(a[i]&amp;#61;&amp;#61;c)\n        {\n            book[i].BookNum&amp;#61;a[i];\n        }else{\n            printf(&amp;#34;该书不属于图书馆&amp;#34;);\n        }\n    }\n    printf(&amp;#34;图书状态&amp;#xff1a;&amp;#34;);\n    strcpy(book[10].State,&amp;#34;已归还&amp;#34;);\n    printf(&amp;#34;借书人学号&amp;#xff1a;&amp;#34;);\n    book[p].StudentNum&amp;#61;x2;\n    printf(&amp;#34;借书人姓名&amp;#xff1a;&amp;#34;);\n//    book[p].Name&amp;#61;x2;\n    printf(&amp;#34;借书人性别&amp;#xff1a;&amp;#34;);\n//    book[p].Sex&amp;#61;x2;\n    Header;\n    Print;\n    saveflag&amp;#61;1;//记录发生变化&amp;#xff0c;存盘标志改为未存盘\n    printf(&amp;#34;\\n图书归还成功&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n    getchar();\n    getchar();\n}\nvoid main()\n{\n    int choice&amp;#61;0,count&amp;#61;0;\n    count&amp;#61;OpenFile(count);//打开文件&amp;#xff0c;获取文件中记录数\n    while(1)\n    {\n        system(&amp;#34;cls&amp;#34;);//调用系统清屏功能清除屏幕信息&amp;#xff0c;使光标回到左上角开始位置\n        Menu();//调用菜单函数\n        printf(&amp;#34;请输入你的选择&amp;#xff1a;&amp;#34;);\n        scanf(&amp;#34;%d&amp;#34;,&amp;amp;choice);\n        switch(choice)\n        {\n            case 1:\n                count&amp;#61;Add(count);//调用添加记录函数\n                break;\n            case 2:\n                Query(count);//调用查询记录函数\n                break;\n            case 3:\n                count&amp;#61;Del(count);//调用删除记录函数\n                break;\n            case 4:\n                Register(count);\n                break;\n            case 5:\n                Borrow(count);\n                break;\n            case 6:\n                Back(count);\n                break;\n            default:\n                printf(&amp;#34;选择错误&amp;#xff0c;按任意键返回主菜单....&amp;#34;);\n                getchar();\n                getchar();\n        }\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言图书管理系统设计", [" ", "\n\n", "\n\n", " ", "\n\n", "#include<stdio.h>", "\n#include <stdlib.h>", "\n#include <string.h>", "\n#define Header printf(\"图书编号   图书名称   图书单价   作者   状态   借书人学号   借书人姓名   借书人性别\\n\")", "\n#define Print printf(\"%-8d%-8s%-8f%-8s%-8s%-8d%-8s%-8s%\\n\",book[p].BookNum,book[p].BookName,book[p].Money,book[p].Author,book[p].State,book[p].StudentNum,book[p].Name,book[p].Sex) ", "\n\n", "struct Book", "\n{", "\n    int BookNum;//图书编号", "\n    char BookName[50];//图书名称", "\n    float Money;//图书单价 ", "\n    char Author;//作者 ", "\n    char State[10];//存在状态 ", "\n    int StudentNum;//借书人学号 ", "\n    char Name;//借书人姓名", "\n    char Sex;//借书人性别", "\n}book[100];", "\nint saveflag=0;", "\nvoid Menu()", "\n{", "\n    printf(\"------------图 书 管 理 系 统-----------\\n\");", "\n    printf(\"               主菜单                   \\n\");", "\n    printf(\"    1 新进图书基本信息的输入            \\n\");", "\n    printf(\"    2 图书基本信息的查询                \\n\");", "\n    printf(\"    3 对撤消图书信息的删除              \\n\");", "\n    printf(\"    4 为借书人办理注册                  \\n\");", "\n    printf(\"    5 办理借书手续                      \\n\");", "\n    printf(\"    6 办理还书手续                      \\n\");", "\n    printf(\"----------------------------------------\\n\");", "\n}", "\nint OpenFile(int cnt)", "\n{", "\n    FILE *fp;", "\n    int i=0;", "\n    fp=fopen(\"D:\\\\demo\\\\book.dat\",\"ab+\");//以追加方式打开D:\\\\demo\\\\Salary.dat二进制文件", "\n    if(fp==NULL)", "\n    {", "\n        printf(\"Can not open file!\");", "\n        exit(0);", "\n    }", "\n    while(!feof(fp))//循环读取文件中的记录，直到文件结束", "\n    {", "\n        if(fread(&book[i],sizeof(struct Book),1,fp)==1)//判断fread()函数读取数据是否成功，返回值为1，则读取了一条记录", "\n        {", "\n            cnt++;", "\n            i++;", "\n        }", "\n    fclose(fp);//关闭文件", "\n    return cnt;//返回文件中记录数 ", "\n    } ", "\n}", "\nint Add(int cnt)//添加图书记录", "\n{ ", "\n    int choice;", "\n    int i,bookNumTemp,j,recordcnt;", "\n    recordcnt=cnt;", "\n    printf(\"开始添加图书信息....\\n\");", "\n    for(i=cnt;i<100;i++)", "\n    {", "\n        printf(\"图书编号：\");", "\n        scanf(\"%d\",&bookNumTemp);", "\n        for(j=0;j<i;j++)", "\n        {", "\n            if(book[j].BookNum==bookNumTemp)//如果编号重复，提示重新输入", "\n            {", "\n                printf(\"图书编号重复，请重新输入：\");", "\n                scanf(\"%d\",&bookNumTemp);", "\n                j=-1;//重新输入编号后，让j=-1，经过j++后，使其为j=0，重新从数组的第一个元素开始比较编号是否重复 ", "\n            } ", "\n        }", "\n        book[i].BookNum=bookNumTemp;", "\n        getchar();", "\n        printf(\"图书名称：\");", "\n        gets(book[i].BookName);", "\n        printf(\"图书单价：\");", "\n        scanf(\"%f\",&book[i].Money);", "\n        printf(\"图书作者：\");", "\n        scanf(\"%s\",&book[i].Author);", "\n        printf(\"借阅状态：\");", "\n        scanf(\"%s\",&book[i].State);", "\n        printf(\"是否继续输入？1 继续  0 退出：\");", "\n        scanf(\"%d\",&choice);", "\n        recordcnt++;//输入完一条记录后让记录数增1", "\n        if(choice!=1)", "\n        break; ", "\n    }", "\n    saveflag=1;//输入记录，记录发生变化，saveflag=1,表示变动后的数据未保存", "\n    printf(\"记录输入完成，按任意键返回主菜单....\");", "\n    getchar();", "\n    getchar();", "\n    return recordcnt;//返回记录数 ", "\n}", "\nint Locate(int num,int cnt)//按图书编号查询图书信息", "\n{", "\n    int p=-1,i;", "\n    for(i=0;i<cnt;i++)", "\n    {", "\n        if(book[i].BookNum==num)", "\n        {", "\n            p=i;//记录查询到的记录的下标 ", "\n            break;", "\n        }", "\n    }", "\n    return p;//返回查询到的记录下标，如果返回为-1，表示记录不存在 ", "\n}", "\nvoid Query(int cnt)//图书信息查询 ", "\n{", "\n    int choice=0,tempnum,p,count=0,i;", "\n    char tempname[20];", "\n    printf(\"开始查询图书信息....\\n\");", "\n    printf(\"请选择查询方式（1 按编号 2 按书名):\");", "\n    scanf(\"%d\",&choice);", "\n    switch(choice)", "\n    {", "\n    case 1:", "\n            printf(\"请输入要查询图书的编号：\");", "\n            scanf(\"%d\",&tempnum);", "\n            p=Locate(tempnum,cnt);//调用按编号查询图书信息函数", "\n            if(-1==p)", "\n            {", "\n                printf(\"\\n 查询的图书信息不存在，按任意键返回主菜单....\"); ", "\n            }", "\n            else", "\n            {", "\n                printf(\"查询的图书信息如下：\\n\\n\");", "\n                Header;", "\n                printf(\"%-8d%-8s%-8f%-8s%-8s%-8d%-8s%-8s%\\n\",book[p].BookNum,book[p].BookName,book[p].Money,book[p].Author,book[p].State,book[p].StudentNum,book[p].Name,book[p].Sex);", "\n                printf(\"\\n 图书信息查询完成，按任意键返回主菜单....\"); ", "\n            }", "\n            getchar();", "\n            break;", "\n    case 2:", "\n            getchar();", "\n            printf(\"请输入要查询图书姓名：\");", "\n            gets(tempname);", "\n            for(i=0;i<cnt;i++)//按姓名查询可能有多条记录满足，所以不能用Locate()函数 ", "\n            {", "\n                if(strcmp(tempname,book[i].BookName)==0)//判断元素姓名是否与要查询的姓名相同 ", "\n                {", "\n                    if(count==0)", "\n                    { ", "\n                        Header;//如果时第1条要查询的记录，则输出行标题，否则不输出 ", "\n                    }", "\n                    p=i;", "\n                    Print;//输出查询到的记录 ", "\n                    count++;//查询到的记录数 ", "\n                }", "\n            }    ", "\n        if(0==count)", "\n            printf(\"\\n查询的图书信息不存在，按任意键返回主菜单....\"); ", "\n        else", "\n            printf(\"\\n图书信息查询完成，按任意键返回主菜单....\");  ", "\n        break;", "\n    default:", "\n        printf(\"选择错误，按任意键返回主菜单....\");", "\n    }", "\n    getchar();", "\n}", "\nint Del(int cnt)", "\n{", "\n    int tempnum,p,i;", "\n    printf(\"开始删除图书信息....\\n\\n\");", "\n    printf(\"请输入要删除图书的编号：\");", "\n    scanf(\"%d\",&tempnum);", "\n    p=Locate(tempnum,cnt);//调用按编号查询图书信息函数", "\n    if(-1==p)", "\n    {", "\n        printf(\"\\n要删除的图书信息不存在，按任意键返回主菜单....\"); ", "\n    }", "\n    else", "\n    {", "\n        printf(\"要删除的图书信息如下：\\n\\n\");", "\n        Header;", "\n        Print;", "\n        for(i=p;i<cnt-1;i++)//从要删除的位置开始，用后一条记录把前一条记录覆盖 ", "\n        {", "\n            book[i]=book[i+1]; ", "\n        }", "\n        cnt--;//记录数在原来记录数的基础上减1", "\n        saveflag=1;//记录发生变化，存盘标志改为未存盘", "\n        printf(\"\\n图书信息修改成功，按任意键返回菜单....\"); ", "\n    }", "\n    getchar();", "\n    getchar();", "\n    return cnt;//返回记录数    ", "\n}", "\nint Register(int cnt)//添加借书人记录", "\n{ ", "\n    int choice;", "\n    int i,bookNumTemp,j,recordcnt;", "\n    recordcnt=cnt;", "\n    printf(\"开始添加借书人信息....\\n\");", "\n    for(i=cnt;i<100;i++)", "\n    {", "\n        printf(\"借书人学号：\");", "\n        scanf(\"%d\",&bookNumTemp);", "\n        for(j=0;j<i;j++)", "\n        {", "\n            if(book[j].BookNum==bookNumTemp)//如果编号重复，提示重新输入", "\n            {", "\n                printf(\"借书人学号重复，请重新输入：\");", "\n                scanf(\"%d\",&bookNumTemp);", "\n                j=-1;//重新输入编号后，让j=-1，经过j++后，使其为j=0，重新从数组的第一个元素开始比较编号是否重复 ", "\n            } ", "\n        }", "\n        book[i].BookNum=bookNumTemp;", "\n        getchar();", "\n        printf(\"借书人学号：\"); ", "\n        scanf(\"%d\",&book[i].StudentNum);", "\n        printf(\"借书人姓名：\");", "\n        scanf(\"%s\",&book[i].Name);", "\n        printf(\"借书人性别：\");", "\n        scanf(\"%s\",&book[i].Sex);", "\n        printf(\"是否继续输入？1 继续  0 退出：\");", "\n        scanf(\"%d\",&choice);", "\n        recordcnt++;//输入完一条记录后让记录数增1", "\n        if(choice!=1)", "\n        break; ", "\n    }", "\n    saveflag=1;//输入记录，记录发生变化，saveflag=1,表示变动后的数据未保存", "\n    printf(\"记录输入完成，按任意键返回主菜单....\");", "\n    getchar();", "\n    getchar();", "\n    return recordcnt;//返回记录数 ", "\n}", "\nvoid ExitSystem(cnt){", "\n}//退出系统", "\nint a[100]={0};", "\nvoid Borrow(int cnt)//借阅", "\n{", "\n    int tempnum,p,teaNumTemp,j;", "\n    printf(\"开始借阅图书....\\n\\n\");", "\n    int a1;", "\n    char a2,a3;", "\n    printf(\"请输入您的学号：\");", "\n    scanf(\"%d\",&a1);", "\n    printf(\"请输入您的姓名：\");", "\n    scanf(\"%s\",&a2);", "\n    printf(\"请输入您的性别：\");", "\n    scanf(\"%s\",&a3);", "\n    printf(\"请输入要借阅的图书编号：\");", "\n    scanf(\"%d\",&tempnum);", "\n    p=Locate(tempnum,cnt);//调用按编号查询图书信息函数", "\n    if(-1==p)//返回值-1,表示要查询的图书信息不存在 ", "\n    {", "\n        printf(\"\\n要借阅的图书不存在，按任意键返回菜单....\"); ", "\n    }", "\n    else", "\n    {", "\n        printf(\"要借阅的图书信息如下：\\n\\n\");", "\n        Header;", "\n        Print;//显示查询到的图书信息", "\n        printf(\"借阅后图书信息：\\n\");", "\n        printf(\"图书状态：\");", "\n        strcpy(book[10].State,\"已借出\");", "\n        printf(\"借书人学号：\");", "\n        book[p].StudentNum=a1;", "\n        printf(\"借书人姓名：\");", "\n        book[p].Name=a2; ", "\n        printf(\"借书人性别：\");", "\n        book[p].Sex=a3;", "\n        Header;", "\n        Print;", "\n        a[p]=book[p].BookNum;", "\n        book[p].BookNum=0;", "\n        saveflag=1;//记录发生变化，存盘标志改为未存盘", "\n        printf(\"\\n图书借阅成功，按任意键返回主菜单....\");", "\n    }", "\n    getchar();", "\n    getchar(); ", "\n}", "\nvoid Back(int cnt)//归还 ", "\n{", "\n    int tempnum,p,teaNumTemp,j,a1=0;", "\n    char x2;", "\n    x2 = 'X';", "\n    int i,c,d;", "\n    printf(\"开始归还图书....\\n\\n\");", "\n    printf(\"请输入要归还的图书编号：\");", "\n    scanf(\"%d\",&c);", "\n    for(i=0;i<101;i++)", "\n    {", "\n        if(a[i]==c)", "\n        {", "\n            book[i].BookNum=a[i];", "\n        }else{", "\n            printf(\"该书不属于图书馆\");", "\n        }", "\n    } ", "\n        printf(\"图书状态：\");", "\n        strcpy(book[10].State,\"已归还\");", "\n        printf(\"借书人学号：\");", "\n        book[p].StudentNum=x2; ", "\n        printf(\"借书人姓名：\");", "\n        book[p].Name=x2; ", "\n        printf(\"借书人性别：\");", "\n        book[p].Sex=x2;", "\n        Header;", "\n        Print;", "\n        saveflag=1;//记录发生变化，存盘标志改为未存盘", "\n        printf(\"\\n图书归还成功，按任意键返回主菜单....\");", "\n    getchar();", "\n    getchar(); ", "\n}", "\nvoid main()", "\n{", "\n    int choice=0,count=0;", "\n    count=OpenFile(count);//打开文件，获取文件中记录数", "\n    while(1)", "\n    {", "\n        system(\"cls\");//调用系统清屏功能清除屏幕信息，使光标回到左上角开始位置 ", "\n        Menu();//调用菜单函数", "\n        printf(\"请输入你的选择：\");", "\n        scanf(\"%d\",&choice);", "\n        switch(choice)", "\n        {", "\n        case 1:", "\n            count=Add(count);//调用添加记录函数", "\n            break;", "\n        case 2:", "\n            Query(count);//调用查询记录函数", "\n            break;", "\n        case 3:", "\n            count=Del(count);//调用删除记录函数", "\n            break;", "\n        case 4:", "\n            Register(count);", "\n            break;", "\n        case 5:", "\n              Borrow(count);", "\n            break;", "\n        case 6:", "\n            Back(count);", "\n            break; ", "\n        default:", "\n            printf(\"选择错误，按任意键返回主菜单....\");", "\n            getchar();", "\n            getchar();         ", "\n        } ", "\n    } ", "\n}", "\n\n", "写入不了文件，输出也有问题。", "\n\n", "怎么搞"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;同学&amp;#xff01;&lt;br /&gt;请检查函数内部变量send和recv的数据类型&amp;#xff0c;根据matlab错误显示其数据类型不是正整数或者逻辑数组。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["matlab，结构体传入函数中，调用时报错无法将struct的值用作索引，求解答", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一种静态数组&amp;#xff0c;在栈区&amp;#xff0c;个数需要确定&amp;#xff0c;不可以是变量&amp;#xff1b;第二种是动态数组&amp;#xff0c;在堆区&amp;#xff0c;个数可以改变&amp;#xff0c;大小可以是变量传值&amp;#xff0c;声明时需要和系统申请&amp;#xff0c;需要手动释放空间&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["[c/c++]请问定义结构体数组时这两种方法一样吗？", ["如图，我用这两种方法分别执行，系统给后者判错，原因提示可能是溢出"]], "Tag": "程序设计"}
{"Answer": "**\r\n\r\n```\r\n *(c-&gt;name)  = \"zhangsan\";\r\n```\r\n\r\n**\r\n改为\r\n\r\n```\r\n strcpy(c-&gt;name,\"zhangsan\");\r\n```\r\n\r\n[指针声明和数组声明（例如 char *a 和 char a[] ）具体都有哪些区别](https://www.zhihu.com/question/26117197 \"\")", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体中字符型数组为什么用strcmp时与预期结果不符？", ["typedef struct person{", "\n    char name[32];", "\n    char sex;", "\n    char age;", "\n    char num[16];", "\n    char addr[128];", "\n} people_t, *people_p, **people_pp;", "\n\n", "int main()", "\n{", "\n\n", "people_t x;\nchar tmp[20] = \"zhangsan\";\npeople_p c = &x;\n*(c->name)  = \"zhangsan\";\nint z = strcmp(tmp, c->name);\nprintf(\"%s\\n%d\\n\", c->name, z);\nsystem(\"pause\");\nreturn 0;\n}\n\n1.代码是这样，为什么两个都是“zhangsan”，但是用strcmp比较出来的值为-1，明显与预期结果不符，\n不知道哪出错了？\n2.还有*(c->name)  = \"zhangsan\";这行代码对吗？如果不能这样写，那要怎么写？\n"]], "Tag": "程序设计"}
{"Answer": "可以在结构体中加入一个type字段，然后函数参数直接传入一个void指针，在函数中根据type来判断具体是哪个结构体传入。", "Konwledge_Point": "数据封装——结构体", "Question": ["c++中想把不同的构造体作为形参传入相同函数怎么做", ["c++中想把不同的构造体作为形参传入相同函数怎么做，在不用重载函数的情况下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你文件最后一行加个回车看看&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["文件内容传入结构体中并打印，结果会和文件内容有差异", ["\n", "\n", "最后会出现一堆与我文件内容不相关的内容，本人编程刚学半年，基础比较薄弱，请问一下大家"]], "Tag": "程序设计"}
{"Answer": "问题出在你的函数声明：\r\nvoid traverse_list(NODE pHead);\r\n\r\n而你的函数定义为：\r\nvoid traverse_list(PNODE pHead)；\r\n\r\n由于声明在main前，定义在main函数之后，所以main中调用的时候是根据你的声明调用。注意你声明的是NODE pHead，而你传参为PNODE，所以报错", "Konwledge_Point": "数据封装——结构体", "Question": ["数据结构 链表的创建 不知道怎么改", ["#include ", "\n#include ", "\n#include ", "\n\n", "typedef struct Node //创建新的数据类型", "\n{", "\n    int data; //数据域", "\n    struct Node * pNext; //指针域", "\n}NODE, *PNODE; //NODE等价与struct Node   //PNODE等价于struct Node *", "\n\n", "//函数声明", "\nPNODE create_list();", "\nvoid traverse_list(NODE pHead);", "\n\n", "int main()", "\n{", "\n    PNODE pHead = NULL;", "\n\n", "pHead = create_list(); //create_lsit()功能：创建一个非循环单链表，并将该链表的头结点的地址付给pHead\ntraverse_list(pHead);\n\nreturn 0;\n", "\n\n", "}", "\n\n", "PNODE create_list()", "\n{", "\n    int len; //用来存放有效节点的个数", "\n    int i;", "\n    int val; //用来临时存放用户输入的结点的值", "\n\n", "PNODE pHead = (PNODE)malloc(sizeof(NODE));\npHead->pNext = NULL;\nif (NULL == pHead)\n{\n    printf(\"内存分配失败，程序终止！\");\n    exit(-1);\n}\n\nprintf(\"请输入您需要生成的链表节点个数：len = \");\nscanf(\"%d\", &len);\n\nfor (i=0; i<len; i++)\n{\n    printf(\"请输入第%d个结点的数据：\", i+1);\n    scanf(\"%d\", &val);\n\n    PNODE pNew = (PNODE)malloc(sizeof(NODE));\n    if (NULL == pHead)\n    {\n        printf(\"内存分配失败，程序终止！\");\n        exit(-1);\n    }\n\n    pNew->data = val;\n    pNew->pNext = pHead->pNext;\n    pHead->pNext = pNew;\n}\n\nreturn pHead;\n", "\n\n", "}", "\n\n", "void traverse_list(PNODE pHead)", "\n{", "\n    PNODE p = pHead->pNext;", "\n\n", "while(p)\n{\n    printf(\"%d \", p->data);\n    p = p->pNext;\n}\n", "\n\n", "}", "\n\n", "G:\\编程\\数据结构\\源代码\\List.cpp(20) : error C2664: 'traverse_list' : cannot convert parameter 1 from 'struct Node *' to 'struct Node'"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;tableName := db.NewScope(model).GetModelStruct().TableName(db)\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何从gorm中的模型获取表名？", ["\n\n", "Is it possible to get model's table name? I see that it's possible to get it from ", "ModelStruct", " but I don't know how to do it correctly. I didn't find any initializations for this structure.", "\n\n", "user := User{}\ntableName := db...\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个主题下知识点比较多&amp;#xff0c;我就不写了&amp;#xff08;包括封送&amp;#xff0c;ref 接收&amp;#xff0c;字节对齐&amp;#xff0c;字符集选择等一大堆的东西&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;自己百度“pinvoke  ref 封送结构体”&amp;#xff0c;如果有可能自己下本《精通.NET互操作PInvoke》的电子书看看&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于#c++#的问题：我在C#怎么调用 C++动态库生成的结构体数组数据", ["我在C#怎么调用 C++动态库生成的结构体数组数据，", "typedef struct TEST_PIN", "{", "    char* Name[45];", "    double Test[45];", "    UCHAR Result[45] = {0};", "}TEST_PIN;", "动态库这边将生成的数据保存在这个结构体数组中，", "我在C#那边怎么调用？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;struct里 成员变量写char num;char name;&lt;br /&gt;你scanf里写的是%s 而结构体成员变量里是字符变量不是数组&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构体，求最高分和最低分", ["为什么这个没有输出？调试的时候stu【t1】.num都是有内容的，但是没有输出的结果，不知道为什么😣"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n\ntypedef struct Student\n{\n    char &lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    int gender;\n    int id;\n} Student;\n\nvoid swap(Student *a, Student *b)\n{\n    char tmp[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(tmp, a-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(a-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;name&lt;/span&gt;, b-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;strcpy&lt;/span&gt;(b-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, tmp);\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; tmp_id &amp;#61; a-&amp;gt;&lt;/span&gt;id;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;id&lt;/span&gt; &amp;#61; b-&amp;gt;&lt;/span&gt;id;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;-&amp;gt;&lt;/span&gt;id &amp;#61; tmp_id;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; tmp_gender &amp;#61; a-&amp;gt;&lt;/span&gt;gender;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;gender&lt;/span&gt; &amp;#61; b-&amp;gt;&lt;/span&gt;gender;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;-&amp;gt;&lt;/span&gt;gender &amp;#61; tmp_gender;\n}\n\nvoid print(Student s, char *&lt;span class=\"hljs-built_in\"&gt;title&lt;/span&gt;)\n{\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s:  name: %s, gender: %s, id: %d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;title&lt;/span&gt;, s.&lt;span class=\"hljs-keyword\"&gt;name&lt;/span&gt;, ((s.gender &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) ? &lt;span class=\"hljs-string\"&gt;&amp;#34;male&amp;#34;&lt;/span&gt; : &lt;span class=\"hljs-string\"&gt;&amp;#34;female&amp;#34;&lt;/span&gt;), s.id);\n}\n\nint main()\n{\n    Student s1 &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;aaa&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;123&lt;/span&gt;};\n    Student s2 &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;bbb&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;234&lt;/span&gt;};\n    print(s1, &lt;span class=\"hljs-string\"&gt;&amp;#34;s1&amp;#34;&lt;/span&gt;);\n    print(s2, &lt;span class=\"hljs-string\"&gt;&amp;#34;s2&amp;#34;&lt;/span&gt;);\n    swap(&amp;amp;s1, &amp;amp;s2);\n    print(s1, &lt;span class=\"hljs-string\"&gt;&amp;#34;s1&amp;#34;&lt;/span&gt;);\n    print(s2, &lt;span class=\"hljs-string\"&gt;&amp;#34;s2&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;/* output:\n    s1:  name: aaa, gender: male, id: 123\n    s2:  name: bbb, gender: female, id: 234\n    s1:  name: bbb, gender: female, id: 234\n    s2:  name: aaa, gender: male, id: 123\n*/&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言小问题，求解答", ["定义一个结构体类型 student,包含三个变量，分别存储自 己的姓名、性别、学号 定义一个函数，实现交换两个 student 结构体内容的 功能。 定义 2 个 student 结构体变量 stu1,stu2 分别输入两个结构体变量的值 分别打印 stu1， stu2 中的内容，之后利用自己定义的函数 交换 stu1， stu2 中的内容，再分别打印 stu1，stu2"]], "Tag": "程序设计"}
{"Answer": "[http://www.cnblogs.com/scrat/archive/2012/08/14/2638740.html](http://www.cnblogs.com/scrat/archive/2012/08/14/2638740.html \"\")", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言 带结构体的链表（如补充所示） 如何创建？", ["链表如下：", "\nstruct  ipaddr_t", "\n{", "\n    int size;", "\n    char* ipaddr", "\n\n", "};", "\n\n", "struct msg_t", "\n{", "\n    int size;", "\n    char* msg;", "\n\n", "};", "\n\n", "struct node_t", "\n{", "\n    int port;", "\n    struct ipaddr_t* ipaddr_h;", "\n    struct msg_t* msg;", "\n        struct node_t* next;", "\n\n", "};"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There is a &lt;code&gt;scanner&lt;/code&gt; package in the &lt;a href=\"https://github.com/benbjohnson/megajson/\" rel=\"nofollow\"&gt;megajson package&lt;/a&gt; that allows you to walk through the json yourself.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;scanner := scanner.NewScanner(strings.NewReader(`{\"foo\":\"bar\", \n\"bat\":1293,\"truex\":true,\"falsex\":false,\"nullx\":null,\"nested\":{\"xxx\":\"yyy\"}}`))\n\n// Scan for the next JSON token.\nposition, token, err := scanner.Scan()\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在Go中解析JSON（无需解组）", ["\n\n", "I need to parse arbitrary JSON structures in Golang for the sake of translating them into another language format (whether it be C structs or XML), but the Golang library apparently makes this impossible to do with Marshalling and Unmarshalling into structs and maps.", "\n\n", "I don't necessarily even need a map-like data structure from the JSON input anyway. All I need is a recursive parser, maybe even something like PHP's ", "XMLParser", " where you decide what do do yourself at each node, so I can translate it without the need for maps or interfaces.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你说的是可以的&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体指针与结构体？", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "#", "include", "<string.h>", "\n\n", "#", "define", " MAX 100", "\n", "#", "define", " LENGTH(a) (sizeof(a)/sizeof(a[0]))", "\n\n", "//邻接表中标对应的链表的结点", "\n", "typedef", " ", "struct", " ", "_ENode", "\n{\n    ", "int", " ivex;                   ", "// 该边所指向的顶点的位置,是数组的下标", "\n    ", "struct", " ", "_ENode", "* next_edge;   ", "// 指向下一条弧的指针", "\n}ENode,*PENode;\n\n", "//邻接表中的表的顶点", "\n", "typedef", " ", "struct", " ", "_VNode", "\n{\n    ", "char", " data;              ", "// 顶点信息", "\n    ENode* first_edge;      ", "// 指向第一条依附该顶点的弧", "\n}VNode;\n\n", "//邻接表", "\n", "typedef", " ", "struct", " ", "_LGraph", "\n{\n    ", "int", " vexnum;            ", "// 图的顶点的数目", "\n    ", "int", " edgnum;            ", "// 图的边的数目", "\n    VNode vexs[MAX];\n}LGraph;\n\n", "//返回ch在matrix矩阵中的位置", "\n", "static", " ", "int", " ", "get_position", "(LGraph g, ", "char", " ch)", "    ", "//为什么用static？", "\n", "{\n    ", "int", " i;\n    ", "for", " (i = ", "0", "; i < g.vexnum; i++)\n        ", "if", " (g.vexs[i].data == ch)\n            ", "return", " i;\n    ", "return", " ", "-1", ";\n}\n", "//将node链接到list的末尾", "\n", "static", " ", "void", " ", "link_last", "(ENode* list, PENode node)", "\n", "{\n    PENode p = list;\n    ", "while", " (p->next_edge)\n        p = p->next_edge;\n    p->next_edge = node;\n}\n", "//打印邻接表图", "\n", "void", " ", "print_lgraph", "(LGraph G)", "\n", "{\n    ", "int", " i;\n    PENode node;\n\n    ", "printf", "(", "\"List Graph:\\n\"", ");\n    ", "for", " (i = ", "0", "; i < G.vexnum; i++)  ", "//遍历所有的顶点", "\n    {\n        ", "printf", "(", "\"%d(%c): \"", ", i, G.vexs[i].data);\n        node = G.vexs[i].first_edge;\n        ", "while", " (node != ", "NULL", ")  ", "//把每个顶点周围的结点都输出一下", "\n        {\n            ", "printf", "(", "\"%d(%c) \"", ", node->ivex, G.vexs[node->ivex].data);\n            node = node->next_edge;\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n}\n\n", "//创建邻接表对应的图(用已提供的数据)，无向图", "\n", "LGraph* ", "create_example_lgraph", "()", "\n", "{\n    ", "char", " c1, c2;\n    ", "char", " vexs[] = { ", "'A'", ", ", "'B'", ", ", "'C'", ", ", "'D'", ", ", "'E'", ", ", "'F'", ", ", "'G'", " };\n    ", "char", " edges[][", "2", "] = {\n        {", "'A'", ", ", "'C'", "},\n        {", "'A'", ", ", "'D'", "},\n        {", "'A'", ", ", "'F'", "},\n        {", "'B'", ", ", "'C'", "},\n        {", "'C'", ", ", "'D'", "},\n        {", "'E'", ", ", "'G'", "},\n        {", "'F'", ", ", "'G'", "} };\n    ", "int", " vlen = ", "LENGTH", "(vexs);\n    ", "int", " elen = ", "LENGTH", "(edges);\n    ", "//上面类似一个邻接矩阵存储", "\n    ", "int", " pos1, pos2;\n    ENode* node1, * node2;      ", "//无向图，一条边两个对应关系", "\n    LGraph* pG;                 ", "//pG表示图", "\n\n    ", "if", " ((pG = (LGraph*)", "malloc", "(", "sizeof", "(_LGraph))) == ", "NULL", ")   ", "///////", "\n        ", "//若硬件没有内存申请失败", "\n        ", "return", " ", "NULL", ";\n    ", "memset", "(pG, ", "0", ", ", "sizeof", "(LGraph));", "//就是把申请的空间内初始化为0", "\n\n    ", "// 初始化\"顶点数\"和\"边数\"", "\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    ", "// 初始化\"邻接表\"的顶点", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = ", "NULL", ";\n    }\n\n    ", "// 初始化\"邻接表\"的边", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        ", "// 读取边的起始顶点和结束顶点", "\n        c1 = edges[i][", "0", "];\n        c2 = edges[i][", "1", "];\n\n        pos1 = ", "get_position", "(*pG, c1);        ", "//pos1对应起始顶点下标位置", "\n        pos2 = ", "get_position", "(*pG, c2);        ", "//pos2对应结束顶点下标位置", "\n                                             ", "//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以", "\n        ", "// 初始化node1", "\n        node1 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node1->ivex = pos2;\n        ", "// 将node1链接到\"p1所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos1].first_edge == ", "NULL", ")\n            pG->vexs[pos1].first_edge = node1;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos1].first_edge, node1);\n       \n        ", "// 初始化node2", "\n        node2 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node2->ivex = pos1;\n        ", "// 将node2链接到\"p2所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos2].first_edge == ", "NULL", ")\n            pG->vexs[pos2].first_edge = node2;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos2].first_edge, node2);\n    }\n}\n\n", "//创建邻接表对应的图(用已提供的数据)，有向图", "\n", "LGraph* ", "create_example_lgraph_directed", "()", "\n", "{\n    ", "char", " c1, c2;\n    ", "char", " vexs[] = { ", "'A'", ", ", "'B'", ", ", "'C'", ", ", "'D'", ", ", "'E'", ", ", "'F'", ", ", "'G'", " };\n    ", "char", " edges[][", "2", "] = {\n        {", "'A'", ", ", "'C'", "},\n        {", "'A'", ", ", "'D'", "},\n        {", "'A'", ", ", "'F'", "},\n        {", "'B'", ", ", "'C'", "},\n        {", "'C'", ", ", "'D'", "},\n        {", "'E'", ", ", "'G'", "},\n        {", "'F'", ", ", "'G'", "} };\n    ", "int", " vlen = ", "LENGTH", "(vexs);\n    ", "int", " elen = ", "LENGTH", "(edges);\n    ", "//上面类似一个邻接矩阵存储", "\n    ", "int", " pos1, pos2;\n    ENode* node1, * node2;      ", "//无向图，一条边两个对应关系", "\n    LGraph* pG;                 ", "//pG表示图", "\n\n    ", "if", " ((pG = (LGraph*)", "malloc", "(", "sizeof", "(_LGraph))) == ", "NULL", ")   ", "///////", "\n        ", "//若硬件没有内存申请失败", "\n        ", "return", " ", "NULL", ";\n    ", "memset", "(pG, ", "0", ", ", "sizeof", "(LGraph));", "//就是把申请的空间内初始化为0", "\n\n    ", "// 初始化\"顶点数\"和\"边数\"", "\n    pG->vexnum = vlen;\n    pG->edgnum = elen;\n    ", "// 初始化\"邻接表\"的顶点", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        pG->vexs[i].data = vexs[i];\n        pG->vexs[i].first_edge = ", "NULL", ";\n    }\n\n    ", "// 初始化\"邻接表\"的边", "\n    ", "for", " (", "int", " i = ", "0", "; i < pG->edgnum; i++)\n    {\n        ", "// 读取边的起始顶点和结束顶点", "\n        c1 = edges[i][", "0", "];\n        c2 = edges[i][", "1", "];\n\n        pos1 = ", "get_position", "(*pG, c1);        ", "//pos1对应起始顶点下标位置", "\n        pos2 = ", "get_position", "(*pG, c2);        ", "//pos2对应结束顶点下标位置", "\n                                             ", "//这里传入用结构体而不是结构体指针，因为没有对其本身改变后续更改的时候因为成员是数组可以", "\n        ", "// 初始化node1", "\n        node1 = (ENode*)", "calloc", "(", "1", ", ", "sizeof", "(ENode));\n        node1->ivex = pos2;\n        ", "// 将node1链接到\"p1所在链表的末尾\"", "\n        ", "if", " (pG->vexs[pos1].first_edge == ", "NULL", ")\n            pG->vexs[pos1].first_edge = node1;\n        ", "else", "\n            ", "link_last", "(pG->vexs[pos1].first_edge, node1);\n    }\n}\n\n", "//深度优先搜索遍历图的递归实现", "\n", "static", " ", "void", " ", "DFS", "(LGraph G, ", "int", " i, ", "int", " visited[])", "\n", "{\n    ", "printf", "(", "\"%c \"", ", G.vexs[i].data);\n    visited[i] = ", "1", ";\n    ENode* node;\n    node = G.vexs[i].first_edge;\n    ", "while", " (node !=", "NULL", ")\n    {\n        ", "if", " (!visited[node->ivex])", "//只要对应顶点没有访问过，深入到下一个顶点访问", "\n            ", "DFS", "(G, node->ivex, visited);\n        node = node->next_edge;", "//某个顶点的下一条边，例如B结点的下一条边", "\n    }\n}\n\n", "//深度优先搜索遍历图", "\n", "void", " ", "DFSTraverse", "(LGraph G)", "\n", "{\n    ", "int", " visited[MAX];       ", "// 顶点访问标记", "\n    ", "//初始化所有顶点都没有被访问", "\n    ", "memset", "(visited, ", "0", ", ", "sizeof", "(visited));\n   ", "/* for (int i = 0; i < G.vexnum; i++)\n        visited[i] = 0;*/", "\n    ", "printf", "(", "\"DFS:\"", ");\n    ", "for", " (", "int", " i = ", "0", "; i < G.vexnum; i++)\n    {\n        ", "if", " (!visited[i])\n            ", "DFS", "(G, i, visited);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n", "int", " ", "main", "()", "\n", "{\n    LGraph* pG;\n    pG = ", "create_example_lgraph_directed", "();\n    ", "print_lgraph", "(*pG);\n    ", "DFSTraverse", "(*pG);\n}\n", "\n", "请问定义函数时 比如static void DFS(LGraph G, int i, int visited[])", "为什么用LGraph呢 是不是把结构体指针当做参数传入也可以呀 就是后面的访问要变成-> 了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;br /&gt;#include&amp;lt;string.h&amp;gt;&lt;/p&gt;\n&lt;p&gt;struct cand&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    char name[10];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int  a;&lt;/span&gt;&lt;br /&gt;}st[5];&lt;/p&gt;\n&lt;p&gt;int main()&lt;br /&gt;{&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt; struct cand st[3]&amp;#61;{&lt;!-- --&gt;{&amp;#34;Lisi&amp;#34;,0},{&amp;#34;Zhangsan&amp;#34;,0},{&amp;#34;Wuting&amp;#34;,0}};&lt;br /&gt; FILE *fp;&lt;br /&gt; FILE *fb;&lt;br /&gt; fp&amp;#61;fopen(&amp;#34;in.txt&amp;#34;,&amp;#34;r&amp;#34;);&lt;br /&gt; fb&amp;#61;fopen(&amp;#34;out.txt&amp;#34;,&amp;#34;w&amp;#43;&amp;#34;);&lt;br /&gt; int i;&lt;br /&gt; char s[10];&lt;br /&gt; int num;&lt;br /&gt; while(!feof(fp))&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     fscanf(fp,&amp;#34;%s&amp;#34;,s);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     fscanf(fp,&amp;#34;%d&amp;#34;,&amp;amp;num);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     for(i&amp;#61;0;i&amp;lt;3;i&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     if(strcmp(s,st[i].name)&amp;#61;&amp;#61;0) st[i].a &amp;#43;&amp;#61; num;&lt;/span&gt;&lt;br /&gt; }&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   fclose(fp);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   for(i&amp;#61;0;i&amp;lt;3;i&amp;#43;&amp;#43;) fprintf(fb,&amp;#34;%s的票数是%d\\n&amp;#34;,st[i].name,st[i].a);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   fclose(fb);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   return 0;&lt;/span&gt;&lt;br /&gt;} &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义结构体的投票问题，对三名候选人投票", ["对候选人进行统计，现有候选人3位：分别是 Lisi，Zhangsan，Wuting", "\n", "候选人信息类型：包括候选人姓名姓名，票数", "\n", "in.txt文件中保存者所有的投票记录（候选人名字），从in.txt文件中读取候选人名字，为相应的候选人计票。", "\n", "将投票统计结果 （每位候选人的姓名及票数）输出到out.txt文件中", "\n", "提示：判断字符串比较函数 strcmp(  )==0 ，可确定字符串是否是对应的候选人"]], "Tag": "程序设计"}
{"Answer": "根据前边的定义，若定义了指针*Node, 那么后边使用*Node p声明的P就是指针型变量，若是定义成Node了，只能使用Node *p定义Node型指针了，结构体属于自定义类型，才会这么灵活.", "Konwledge_Point": "数据封装——结构体", "Question": [" 新手求教，关于以下两种结构体定义，有什么区别，求指点", ["typedef struct node", "\n{", "\nfloat x;", "\nfloat fx;", "\n} Node, *Node;", "\n\n", "Node *p;", "\n*Node p;", "\n这两个有什么区别"]], "Tag": "程序设计"}
{"Answer": "第一次看见解引这么玩的哈哈\r\n问题一：pjf这个函数的i的意义是什么，怎么在for的时候又给i重新赋了个值。\r\n问题二：初始化的时候只有4个元素，但是在pjf这个函数里面怎么访问到了第五个元素的位置，这个虽然是可以的，而且系统自动帮你初始化了。\r\n问题三：也就是最致命的，你在输入的时候只是把name那一项当作字符串了，期间没有制表符，所以此时你输入的所有东西都是name，不是其他的。\r\n之后还有一些其他地方的小问题，加油", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言结构体数组赋值新值但旧值还在", ["#include", "\n#include", "\n struct stu{", "\n   char name[20];", "\n   int num;", "\n   int age;", "\n   char group;", "\n    float score;", "\n          }stus[5] = {{\"Zhou ping\", 5, 18, 'C', 145.0},", "\n       {\"Zhang ping\", 4, 19, 'A', 130.5},", "\n       {\"Liu fang\", 1, 18, 'A', 148.5},", "\n       {\"Wang ming\", 3, 17, 'B', 144.5} } ;", "\nint main ()", "\n{", "\n       struct stu*p=stus;", "\n        int j; ", "\n    char name[20];", "\n    int pjf ( struct stu w[],int i ); ", "\n      int charu ( struct stu a[3]);", "\n    int shang  ( struct stu *a);", "\n    pjf (stus,5);", "\n    (p+4)[0]=(p+3)[0];", "\n   charu(stus);", "\n   printf(\"     \\n\"); ", "\n   for(j=0;j<5;j++)", "\n      {", "\n        printf(\"%s,%d,%d,%c,%7.2f\\n\",p[j].name,p[j].num,p[j].age,p[j].group,p[j].score);", "\n       }", "\n     printf(\"     \\n\");", "\n     shang  (stus);", "\n     for(j=0;j<4;j++)", "\n      {", "\n        printf(\"%s,%d,%d,%c,%7.2f\\n\",p[j].name,p[j].num,p[j].age,p[j].group,p[j].score);", "\n\n", "   }   \n", "\n\n", "return 0;", "\n}", "\n\n", "int pjf ( struct stu w[],int i  )", "\n{", "\n    int sum=0;", "\n    for(i=0;i<5;i++)", "\n     {", "\n       sum+=w[i].score;", "\n      }", "\n      printf (\"平均分是  %7.2f\\n\",sum/4.0);", "\n      return 0;", "\n}", "\n\n", "int charu ( struct stu a[3])", "\n{", "\n    printf(\"请输入一条记录 姓名，学号，年龄，小组，成绩 （逗号隔开）\\n\");", "\n    scanf(\"%s,%d,%d,%c,%f\",a[3].name,a[3].num,a[3].age,a[3].group,a[3].score);", "\n    return 0;", "\n }", "\n\n", "int shang  ( struct stu *a)", "\n{", "\n    (a+2)[0]=(a+3)[0]; ", "\n        (a+3)[0]=(a+4)[0]; ", "\n    return 0;", "\n}", "\n\n", "\n圈出的就是问题所在，为什么原来的数值还在，跪求大神"]], "Tag": "程序设计"}
{"Answer": "stunum分配的长度是多少，很可能是分配长度过短，结果越界访问到了sex字段。请保证至少分配字符串长度+1。以便存储字符串和结束的\\\\0", "Konwledge_Point": "数据封装——结构体", "Question": ["求助！！！关于C里scanf %s %c和结构体之间的疑惑！！！", ["最近在编一个学生成绩管理系统，然后就发现了一个问题.....", "\n scanf(\"%s   %s   %c \",name,stunum,&sex);", "\n 在运行时输入Xiaoming   2015000000   F", "\n 输出的stunum是2015000000, sex是F", "\n 但是把语句改成 ", "\n scanf(\"%s   %s   %c \",student[0].name,student[0].stunum,&student[0].sex);", "\n 输入和上面一样的东西，输出却变成了stunum是2015000000F，sex还是F", "\n为什么啊？不明白TAT", "\n难道结构体里的字符串和普通字符串不一样么", "\n\n", "求高手拯救我这个小白orz"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;count数组元素应该初始赋值为0&lt;br /&gt;count[5]  &amp;#61; {0}&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student &lt;span class=\"hljs-constructor\"&gt;SetGrade(&lt;span class=\"hljs-params\"&gt;struct&lt;/span&gt; Student &lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;d&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;q&lt;/span&gt;)&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//q是指针前面要加*&lt;/span&gt;\n&lt;span class=\"hljs-constructor\"&gt;SetGrade(&lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;count&lt;/span&gt;,&amp;amp;&lt;span class=\"hljs-params\"&gt;auer&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//调用时auer前面要加&amp;amp;&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 10&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; grade;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, count[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; g[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; auer;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; s[N];\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;SetGrade&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student * p, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *d, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; *q); &lt;span class=\"hljs-comment\"&gt;//q是指针前面要加*&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入%d个学生的学号、姓名和成绩&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;, N);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;No%d:&amp;#34;&lt;/span&gt;, i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%s%d&amp;#34;&lt;/span&gt;, &amp;amp;s[i].num, s[i].name, &amp;amp;s[i].score);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;SetGrade&lt;/span&gt;(s, count, &amp;amp;auer); &lt;span class=\"hljs-comment\"&gt;//调用时auer前面要加&amp;amp;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%4d%10s%6d%6c\\n&amp;#34;&lt;/span&gt;, s[i].num, s[i].name, s[i].score, s[i].grade);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;各等级人数为&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c:%d\\n&amp;#34;&lt;/span&gt;, g[i], count[i]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;平均成绩为%.2f\\n&amp;#34;&lt;/span&gt;, auer);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;SetGrade&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student *p, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *d, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; *q) &lt;span class=\"hljs-comment\"&gt;//q是指针前面要加*&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, sum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;, p&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;score &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;90&lt;/span&gt;)\n        {\n            p-&amp;gt;grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;;\n            (*d)&amp;#43;&amp;#43;;      &lt;span class=\"hljs-comment\"&gt;//*d要加括号先计算 &lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;score &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;)\n        {\n            p-&amp;gt;grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;;\n            (*(d &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;))&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;score &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;70&lt;/span&gt;)\n        {\n            p-&amp;gt;grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;;\n            (*(d &amp;#43; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;))&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;score &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;)\n        {\n            p-&amp;gt;grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;;\n            (*(d &amp;#43; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;))&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            p-&amp;gt;grade &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;;\n            (*(d &amp;#43; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;))&amp;#43;&amp;#43;;\n        }\n        sum &amp;#43;&amp;#61; p-&amp;gt;score;&lt;span class=\"hljs-comment\"&gt;//p已经&amp;#43;&amp;#43;了&amp;#xff0c;不用p&amp;#43;i&lt;/span&gt;\n    }\n    *q &amp;#61; &lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt; * sum / N;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/110105889936172.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["定义结构体，输入十个学生信息，需要实现统计各等级人数，输出全部学生信息和统计结果、平均成绩", ["\n", "\n", "以上是我的代码有些混乱，是错的，我的思路是设置两个数组对应各等级和各等级人数，用指针指向存储各等级人数的数组，但是不清楚怎么在函数里面循环增加各等级人数"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\nmemcpy(&lt;span class=\"hljs-name\"&gt;&amp;amp;a&lt;/span&gt;, &lt;span class=\"hljs-symbol\"&gt;&amp;amp;b&lt;/span&gt;, sizeof(&lt;span class=\"hljs-name\"&gt;dat&lt;/span&gt;))&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体变量和指针的关系", ["定义两个结构体，如何用首地址的方式来把结构体里的内容进行替换呢？", "比如：", "typedef struct{", "  unsigned char data[2];", "}dat;", "\n", "dat a,b;", "问：如何用指针把b结构里的数据传输到a结构体对应的位置上？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You cannot, at least not in Go 1.12.7.&lt;/p&gt;\n\n&lt;p&gt;Go's Protobuf compiler adds 3 extra fields to each struct generated from a message:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;XXX_NoUnkeyedLiteral         struct{} `json:\"-\"`\nXXX_unrecognized             []byte   `json:\"-\"`\nXXX_sizecache                int32    `json:\"-\"`\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Therefore your &lt;code&gt;struct&lt;/code&gt; and generated one have different fields and are not identical as per, therefore not &lt;a href=\"https://golang.org/ref/spec#Assignability\" rel=\"nofollow noreferrer\"&gt;assignable&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;If two structs differ only in the tags, it is possible to &lt;a href=\"https://golang.org/ref/spec#Conversions\" rel=\"nofollow noreferrer\"&gt;convert it&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Person struct {\n    Name    string\n    Address *struct {\n        Street string\n        City   string\n    }\n}\n\nvar data *struct {\n    Name    string `json:\"name\"`\n    Address *struct {\n        Street string `json:\"street\"`\n        City   string `json:\"city\"`\n    } `json:\"address\"`\n}\n\nvar person = (*Person)(data)  // ignoring tags, the underlying types are identical\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You have to create a new &lt;code&gt;struct&lt;/code&gt; instance manually.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何将结构转换/转换为Protobuf？", ["\n\n", "I am working on a personal project & using Go for the first time. I am using structs for operating on the data and for storing the data in a file, I am using proto as the encoder.", "\n\n", "In the project, my proto definition looks something like this", "\n\n", "message Data {\n    string key = 1;\n    string value = 2;\n}\n\nmessage Record {\n    int64 size = 1;\n    Data data = 2;\n}\n", "\n\n", "and my struct looks like this", "\n\n", "type KVData struct {\n    Key       string\n    Value     string\n}\n", "\n\n", "Currently, this is how I am creating proto data", "\n\n", "kvData := KVData{Key: \"name\", Value: \"A\"}\n\nrecord := &pb.Record{\n        Size: 20,\n        Data: &pb.Data{Key: \"name\", Value: \"A\"},\n}\n", "\n\n", "What I am looking for is a way to do this:", "\n\n", "record := &pb.Record{\n        Size: 20,\n        Data: &((pb.Data)kvData), // Won't work\n}\n\n// or like Python\n\nrecord := &pb.Record{\n        Size: 20,\n        Data: &(pb.Data{**kvData}), // Won't work\n}\n\n", "\n\n", "I tried googling but couldn't find any solution explaining how to do this.", "\n\n", "Note, I am not just trying to solve this specific case, I also want to know what's the recommended Go way to operate between structs and proto(use only proto?)?", "\n    "]], "Tag": "程序设计"}
{"Answer": "自己写一个比较器，作为参数传给qsort\r\n大概的写法\r\nif (a.字段1 == b.字段1)\r\nreturn a.字段2 - b.字段2;\r\nreturn a.字段1 - b.字段1;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++ 6.0按照结构体数组中多个字段的排序", ["用系统库函数怎么实现？传函数指针么？但是多个条件没办法传函数指针的，用冒泡排序行么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体中常见的冒号的用法是表示位域。&lt;/p&gt;\n&lt;p&gt;有些信息在存储时&amp;#xff0c;并不需要占用一个完整的字节&amp;#xff0c;而只需占几个或一个二进制位。例如在存放一个开关量时&amp;#xff0c;只有0和1两种状态&amp;#xff0c;用一位二进位即可。为了节省存储空间&amp;#xff0c;并使处理简便&amp;#xff0c;C语言又提供了一种数据结构&amp;#xff0c;称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几个不同的区域&amp;#xff0c;并说明每个区域的位数。每个域有一个域名&amp;#xff0c;允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。&lt;/p&gt;\n&lt;p&gt; 参考&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/caidi/p/10583924.html\" id=\"textarea_1644416600283_1644416782576_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;c语言结构体中的冒号的用法 - hunterDing - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;结构体中常见的冒号的用法是表示位域。 有些信息在存储时&amp;#xff0c;并不需要占用一个完整的字节&amp;#xff0c;而只需占几个或一个二进制位。例如在存放一个开关量时&amp;#xff0c;只有0和1两种状态&amp;#xff0c;用一位二进位即可。为了节省存储空间&amp;#xff0c;并使处理&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/caidi/p/10583924.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["这个输出结果为什么会是这样呀，结构体里面的冒号是什么意思", []], "Tag": "程序设计"}
{"Answer": "你说的没错，ticktok的确没用，估计写程序的人原来打算 int seconds = time(NULL);写在while循环外面，靠ticktok更新时间，但是不知道为什么，他写在了里面\r\n写在循环里面，每次都得到时间，就不再需要ticktok，可是他也没有把这代码删除。", "Konwledge_Point": "数据封装——结构体", "Question": ["c语言简单问题求解答：结构体显示当前时间", ["这道题就是表示时间，然后我的问题是为什么要有void ticktok(Time *p) 这个代码？因为我发现即使不使用这一行代码，显示出来也是对的啊，所以这个函数到底有身边么用？求解答，谢谢", "\n\n", "#include <stdio.h>\n#include <windows.h>\n#include <conio.h>\n#include <time.h>\n\ntypedef struct Time\n{\n    int hour;\n    int minute;\n    int second;\n}Time;\n\nvoid ticktok(Time *p)\n{\n    p ->second++;\n    if(p->second >= 60)\n    {\n        p->second = 0;\n        p->minute++;\n        {\n            if(p->minute >= 60)\n            {\n                p->minute = 0;\n                p->hour++;\n                if(p->hour >=24)\n                {\n                    p->hour %= 24 ;\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(!kbhit())\n    {\n\n\n    int seconds = time(NULL);\n    Time now;\n    now.hour = (seconds/3600 +8 )%24;\n    now.minute = seconds/60%60;\n    now.second = seconds%60;\n    ticktok(&now);\n    printf(\"%d:%d:%d\",now.hour,now.minute,now.second);\n    Sleep(1000);\n    system(\"cls\");\n    }\n\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You need to make your fields visible for &lt;a href=\"https://godoc.org/labix.org/v2/mgo/bson#Unmarshal\" rel=\"nofollow\"&gt;mgos bson Unmarshall&lt;/a&gt; by naming them with a starting capital letter. You also need to map to the appropiates json/bson field names&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Category struct {\n    ListName string      `json:\"listName\" bson:\"listName\"`\n    Slug string          `json:\"slug\"     bson:\"slug\"`\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Golang Revel + MGO-当结构变量的名称为小写时不返回任何数据", ["\n\n", "This is my struct type", "\n\n", "type Category struct {\n    Name string     `bson:\"listName\"`\n    Slug string     `bson:\"slug\"`\n}\n", "\n\n", "used with the following function to return all results from a mongo collection -", "\n\n", "func GetCategories(s *mgo.Session) []Category {\n    var results []Category\n    Collection(s).Find(bson.M{}).All(&results)\n    return results\n}\n", "\n\n", "The problem is that the field names in my db have names starting in lowercase but the Golang struct returns null when I try to use variable names starting with lower case. For e.g. this returns a JSON with corresponding fields empty -", "\n\n", "type Category struct {\n    listName string `bson:\"listName\"`\n    slug string     `bson:\"slug\"`\n}\n", "\n\n", "I'm actually porting a Meteor based API to Golang and a lot of products currently using the API rely on those field names like they are in the db!\nIs there a workaround?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;I think you are on the right track with \"I have two arrays of hashes and i want to merge them on a shared key\"&lt;/p&gt;\n\n&lt;p&gt;However, in Go you are going to be responsible for doing the merging yourself as their is no notion of a group_by type function / method.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func merge(As, Bs []Item) []Item {\n    if len(As) == 0 {\n        return Bs\n    }\n    bMap := make(map[string]Item)\n    for _, b := range Bs {\n        bMap[b.Uid] = b\n    }\n    merged := make([]Item, len(As))\n    for i, a := range As {\n        if b, ok := bMap[a.Uid]; ok {\n            a.Val5 = b.Val5    // this and the next two lines could be done\n            a.Val6 = b.Val6    // using reflection, but if you know the fields\n            a.Val7 = b.Val7    // then this would be my preferred way.\n        }\n        merged[i] = a\n    }\n    return merged\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here is a &lt;a href=\"https://play.golang.org/p/lVG6EaOqiEn\" rel=\"nofollow noreferrer\"&gt;playground&lt;/a&gt; of the results&lt;/p&gt;\n\n&lt;p&gt;Note: This wouldn't account for an empty slice of As as you would get nothing in the merge.  Since I don't know the specifics of your application I can't say whether that is something that can happen, but if it can you will need to account for it.&lt;/p&gt;\n\n&lt;p&gt;For what it's worth, I think this is approximately the approach Verran was suggesting:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/3EpWlFdB8c6\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/3EpWlFdB8c6&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;Basically, let the results be returned on a channel and have them merged as you get both results. &lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["使用Golang将两片相似的数据合并到JSON中", ["\n\n", "I'm a Go newbie, so go easy on me. I'm coming from Rubyland and struggling to understand some of this new terrain.", "\n\n", "Context: We have a service with two endpoints that hit multiple API's, massage the data and send it back as json. They're serving data on the same objects, but they do distinctly different things. The only common attribute is ", "uid", ".", "\n\n", "They're sharing a model, which looks like this:", "\n\n", "type Item struct {\n  Uid     string      `json:\"uid\"`\n  Val1    string      `json:\"param1,omitempty\"`\n  Val2    []NestedVal `json:\"param2,omitempty\"`\n  Val5    int         `json:\"param5,omitempty\"`\n  Val6    string      `json:\"param6,omitempty\"`\n  Val7    string      `json:\"param7,omitempty\"`\n}\n\ntype NestedVal struct {\n  Val3  int    `json:\"val3,omitempty\"`\n  Val4  string `json:\"val4,omitempty\"`\n}\n", "\n\n", "An example response from endpoint ", "A", " would be:", "\n\n", "[\n {\n   \"uid\": \"123\",\n   \"val1\": \"foobar\"\n   \"val2\": [\n     {\"val3\": 666, \"val4\": \"qux\"},\n     {\"val3\": 666, \"val4\": \"qux\"}\n   ]\n },\n {\n   \"uid\": \"456\",\n   \"val1\": \"foobar\"\n   \"val2\": [\n     {\"val3\": 666, \"val4\": \"qux\"},\n     {\"val3\": 666, \"val4\": \"qux\"}\n   ]\n }\n]\n", "\n\n", "An example response from endpoint ", "B", " would be:", "\n\n", "[\n {\n   \"uid\": \"123\",\n   \"val5\": 999\n   \"val6\": \"bar\"\n   \"val7\": \"baz\"\n },\n {\n   \"uid\": \"456\",\n   \"val5\": 999\n   \"val6\": \"bar\"\n   \"val7\": \"baz\"\n }\n]\n", "\n\n", "Right now these exist as stand-alone services because they serve slightly different needs, but now we need to offer them up as a combined dataset, something like:", "\n\n", "[\n {\n   \"uid\": \"123\",\n   \"val1\": \"foobar\"\n   \"val2\": [\n     {\"val3\": 666, \"val4\": \"qux\"},\n     {\"val3\": 666, \"val4\": \"qux\"}\n   ],\n   \"val5\": 999\n   \"val6\": \"bar\"\n   \"val7\": \"baz\"\n },\n {\n   \"id\": \"456\",\n   \"val1\": \"foobar\"\n   \"val2\": [\n     {\"val3\": 666, \"val4\": \"qux\"},\n     {\"val3\": 666, \"val4\": \"qux\"}\n   ],\n   \"val5\": 999\n   \"val6\": \"bar\"\n   \"val7\": \"baz\"\n }\n]\n", "\n\n", "For what it's worth, this is how they're returned (basically the same for both endpoints):", "\n\n", "func FetchA(uids []string) []Item {\n  var collection []Item\n\n  *... fetching, parsing, and appending to collection ...*\n\n  return collection\n}\n\nfunc HandlerA(response http.ResponseWriter, request *http.Request) {\n  *... pull uids out of qs ...*\n  collection := fetchA(uids)\n  responseData, _ := json.Marshal(collection)\n  *... write the response ...*\n}\n", "\n\n", "Bottom line: I have two data sets, both of type ", "[]Item", ". I just want to combine them on their shared ", "uid", " keys. Obviously I'm approaching this as a Ruby dev, thinking about this problem as \"I have two arrays of hashes and i want to merge them on a shared key\" - I know thats the wrong frame of mind here, but I'm pretty stuck and I know the answer is right under my nose. ", "\n\n", "I've looked around and none of the answers I've seen have been particularly helpful. I checked out mergeo and go-merge but couldn't find a way around overwriting the merge-ee.", "\n\n", "I think my real problem here is a lack of good understanding of Go data structures. This is how I'd combine the two in Ruby:", "\n\n", "(responseA + responseB).group_by{|h| h[:uid]}.map{|k,v| v.reduce(:merge)}\n", "\n\n", "EDIT: Here's a rough simulation on a Go playground ", "https://play.golang.org/p/J0bJMjiM8DR", "\n    "]], "Tag": "程序设计"}
{"Answer": "```\r\n 错误多着呢\r\n\r\n&amp;sell[i]dm\r\n中间少了点\r\n\r\nstruct(sell[i].mc&gt;sell[i+1].mc\r\n这里多了struct(\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构数组的题，请大神看看错误出在哪里", ["#include", "\nstruct sell", "\n{", "\n    char dm[4];", "\n    char mc[10];", "\n    int dj;", "\n    int sl;", "\n    long int je;", "\n}sell[100];", "\nvoid main()", "\n{", "\n    int i,j,t;", "\n    long int m;", "\n    for(i=0;i\n        scanf(\"%s,%s,%4d,%5d,%5d\\n\",&sell[i]dm,&sell[i].mc,&sell[i].dj,&sell[i].sl,&sell[i].je);", "\n    for(i=0;i\n        for(i=0;i\n            if(struct(sell[i].mc>sell[i+1].mc)", "\n            {", "\n                t=sell[i].mc;", "\n                sell[i].mc=sell[i+1].mc;", "\n                sell[i+1].mc=t;", "\n            }", "\n            else if(sell[i].mc==sell[i+1].mc)", "\n            {", "\n                if(sell[i].je>sell[i+1].je)", "\n                {", "\n                    m=sell[i].je;", "\n                    sell[i].je=sell[i+1].je;", "\n                    sell[i+1].je=m;", "\n                }", "\n            }", "\n\n", "for(i=0;i<100;i++)", "\nprintf(\"%s,%s,%4d,%5d,%5d\\n\",sell[i].dm,sell[i].mc,sell[i].dj,sell[i].sl,sell[i].je);", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你要先输入n&amp;#xff0c;然后输入n行数据&lt;br /&gt;你第一个数据就输入个李是要闹哪样&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["用结构体数组存储数据", ["\n", "\n", "\n", "运行结果要求在第一张图片，void函数不变。我的运行结果是第四张图片。请各位指出错误并提供详细的解决方案"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This is your program from the edit with a interface type implementation:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"log\"\n)\n\n//// Interfaces ////\ntype PhotoManager interface {\n    AddPhotos(id string) (bool, error)\n}\n\n//// Post ////\ntype Post struct {\n    Photos []string\n}\n\nfunc (p *Post) AddPhotos(id string) (bool, error) {\n    p.Photos = append(p.Photos, id)\n    return true, nil\n}\n\n//// Product ////\ntype Product struct {\n    Photos []string\n    Docs   []string\n}\n\nfunc (p *Product) AddPhotos(id string) (bool, error) {\n    p.Photos = append(p.Photos, id)\n    return true, nil\n}\n\n// Useless function to demonstrate interface usage //\nfunc AddPhotoToInterfaceImplementation(id string, pm PhotoManager) {\n    pm.AddPhotos(id)\n}\n\n//// Main ////\nfunc main() {\n    post := Post{}\n    product := Product{}\n    post.AddPhotos(\"123\")\n    product.AddPhotos(\"321\")\n    AddPhotoToInterfaceImplementation(\"456\", &amp;amp;post)\n    AddPhotoToInterfaceImplementation(\"654\", &amp;amp;product)\n    log.Println(post)\n    log.Println(product)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The moving parts here are:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;the type &lt;code&gt;PhotoManager interface&lt;/code&gt; that is used to define an interface with generic functions&lt;/li&gt;\n&lt;li&gt;the implementations of &lt;code&gt;AddPhotos&lt;/code&gt; on &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;Product&lt;/code&gt; to provide the actual implementations of the interface functions&lt;/li&gt;\n&lt;li&gt;the usage of &lt;code&gt;pm PhotoManager&lt;/code&gt; as parameter to &lt;code&gt;AddPhotoToInterfaceImplementation&lt;/code&gt; to show the usage of the interface type.&lt;/li&gt;\n&lt;/ul&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何在golang中定义动态的“类型结构”？", ["\n\n", "Here is Playground link ", "https://play.golang.org/p/qMKxqrOcc2", ". Problem is similar to one that is on Playground.", "\n\n", "Let's say I have a condition and need to do this:", "\n\n", "if modelName == \"a\"{\n    model = models.A\n} \nelse{\n    model = models.B\n}\n", "\n\n", "where ", "A", " and ", "B", " are some models:", "\n\n", "type A struct{\n    filed1 string\n    field2 string\n    //etc\n\n}\n", "\n\n", "and model ", "B", " is", "\n\n", "type B struct{\n    filed1 string\n    field2 string\n    //etc\n\n}\n", "\n\n", "Fields in ", "A", " and ", "B", " has some same fields but mostly they reflect database table (document) and they are of same type (type struct).", "\n\n", "When I say in front of all that:", "\n\n", "var model interface{}\n", "\n\n", "I got error:", "\n\n", "type models.A is not an expression \n", "\n\n", "I am doing this to avoid code redundancy in code if you are asking why.", "\n\n", "Question is similar to this: ", "How to return dynamic type struct in Golang?", "\n\n", "Here is update for code:", "\n\n", "b := c.mainHelper.GetModelBy(\"id\", id, modelName).(map[string]interface{})\nmapstructure.Decode(b, &model)\n\nif modelName == \"a\"{\n    model.Photos = []string{\"ph1\",\"ph2\"}\n}\nif modelName == \"b\"{\n    model.Docs = []string{\"doc1\",\"doc2\"}\n}\n\nc.mainHelper.UpdateModel(product, id, modelName)\n", "\n\n", "I know this is stupid and probably is impossible to do but is there and way to do this:", "\n\n", "var model models.modelName --> somehow to concat modelName to this models?\n", "\n\n", "HERE IS NEW UPDATE", "\n\n", "I have two models Post and Product. Both of them has Photos field.", "\n\n", "type Post struct{\n\n    Photos []string\n    //etc\n}\n\ntype Product {\n\n    Photos []string\n    //\n}\n", "\n\n", "Now I need one function that will say this:", "\n\n", "func () RemovePhotos(id string, modelName string){\n\n//if modelName==\"post\"\n    //get model post with id\n\n//if modelName==\"product\"\n    //get model product with id\n\n//set model.Photos = []string\n//update model in db\n}\n", "\n\n", "I can understand that I can not assign type but how to use this one function to remove data from differnt types? As far as I can see code redundancy will look like this:", "\n\n", "func () RemovePhotos(id string, modelName string) return bool{\n\n    if modelName == \"post\"{\n\n      var model models.Post\n      modelWithdata := getModelWithId.(*model)\n      modelWithdata.Photos = []string\n      //update model in db here\n    } \n    if modelName == \"product\"{\n      var model models.Product\n      modelWithdata := getModelWithId.(*model)\n      modelWithdata.Photos = []string\n      //update model in db here\n    }\n\n    //it does not matter what I return this is just redundancy example\n    return true\n\n}\n", "\n\n", "As you can only difference is var model ", "models.Post/var model models.Product", ".\nThis is redundancy in code and it looks ugly but if there is no way around this then ok, i will have this one completed with redundancy.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;其实我们写一个结构体就是在写一个类型。&lt;br /&gt;上面的代码写了一个叫 Table 的结构体&amp;#xff0c;而后面的 table 只是 Table 的一个别名&amp;#xff0c;就是我们可以用 table 来代表 Table。&lt;br /&gt; &lt;br /&gt;所以 table initTable() 就是一个常规的定义函数的形式&amp;#xff0c;table 是一种类型&amp;#xff0c;而 initTable 是函数名。&lt;br /&gt;至于 table t&amp;#xff0c;是定义了一个结构体变量&amp;#xff0c;t 里面有 * head&amp;#xff0c;length 和 size。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于结构体struct", ["#include <stdio.h>", "#include <stdlib.h>  //malloc()、exit()", "#define size 5", "typedef struct Table {", "    int * head;", "    int length;", "    int size;", "}table;", "table initTable() {", "    table t;", "\n", "Table应该是结构体类型 ，table应该是结构体变量。结构体变量+函数名 是什么用法？table t又是什么用法？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、先用读模式用fscanf每次从.dat文件读取一个结构数据到临时结构数组&amp;#xff0c;判断判断是否是需要改动的结构&amp;#xff0c;如果不是&amp;#xff0c;继续读取&amp;#xff0c;如果是&amp;#xff0c;则把需要修改的数据从输入读到赋值到结构数组当前下标元素&amp;#xff0c;然后继续读取文件后面的结构数据到临时结构数组。&lt;br /&gt;2、用写模式用fprintf函数把临时结构数组写入到文件.dat。&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["怎么将.dat文件部分内容改动（结构体数组)", ["怎么将.dat文件部分内容改动（结构体数组)", "怎么将.dat文件部分内容改动（结构体数组)", "怎么将.dat文件部分内容改动（结构体数组)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;额&amp;#xff0c;正当要放弃的时候&amp;#xff0c;突然一下灵感来了&amp;#xff0c;&lt;/p&gt;\n\n&lt;p&gt;原来是sort()函数的范围写错了&lt;/p&gt;\n\n&lt;p&gt;因该是&amp;#xff1a;sort(cake&amp;#43;1,cake&amp;#43;n&amp;#43;1,cmp);  &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["为什么结构体数组下标从1开始就得到错误的结果，而从零开始就是正确的答案哪？（贪心算法）", ["/*从0开始*/", "\n\n", "#include <bits/stdc++.h>", "\nusing namespace std;", "\n\n", "struct mooncake{", "\n    double store; //库存量 ", "\n    double sell;  //总售价 ", "\n    double price;  //单价 ", "\n}cake[1010];", "\n\n", "bool cmp(mooncake a,mooncake b)", "\n{", "\n    return a.price>b.price; ", "\n}", "\n\n", "int main()", "\n{", "\n    int n; //月饼的数量", "\n    double D;  //市场最大的需求量 ", "\n    cin>>n>>D;", "\n    ", "\n    for(int i=0;i<n;i++)", "\n    {", "\n        cin>>cake[i].store; ", "\n     }", "\n    ", "\n    for(int i=0;i<n;i++)", "\n    {", "\n        cin>>cake[i].sell;", "\n        cake[i].price=cake[i].sell/cake[i].store;", "\n    }", "\n    sort(cake,cake+n,cmp);  //对单价进行降序排序", "\n    double money=0;", "\n    /*选择单价最高的出售*/", "\n    for(int i=0;i<n;i++)", "\n    {", "\n        if(cake[i].store<=D)", "\n        {", "\n            D-=cake[i].store;  //此时的市场需求量还剩多少", "\n            money+=cake[i].sell;", "\n             ", "\n        }", "\n        else", "\n        {", "\n            money+=cake[i].price*D;", "\n            break;", "\n         } ", "\n     }", "\n     printf(\"%.2f\\n\",money);", "\n    return 0; ", "\n}", "\n/*", "\n3 20", "\n18 15 10", "\n75 72 45", "\n*/", "\n\n", "\n\n", "/*从1开始*/", "\n\n", "#include <bits/stdc++.h>", "\nusing namespace std;", "\n\n", "struct mooncake{", "\n    double store; //库存量 ", "\n    double sell;  //总售价 ", "\n    double price;  //单价 ", "\n}cake[1010];", "\n\n", "bool cmp(mooncake a,mooncake b)", "\n{", "\n    return a.price>b.price; ", "\n}", "\n\n", "int main()", "\n{", "\n    int n; //月饼的数量", "\n    double D;  //市场最大的需求量 ", "\n    scanf(\"%d%lf\",&n,&D);", "\n    ", "\n    for(int i=0;i<n;i++)", "\n    {", "\n        cake[i].store=cake[i].sell=0;", "\n    }", "\n    for(int i=1;i<=n;i++)", "\n    {", "\n        scanf(\"%lf\",&cake[i].store);", "\n     }", "\n    ", "\n    for(int i=1;i<=n;i++)", "\n    {", "\n        scanf(\"%lf\",&cake[i].sell);", "\n        cake[i].price=cake[i].sell/cake[i].store;", "\n    }", "\n    sort(cake,cake+n,cmp);  //对单价进行降序排序", "\n    double money=0;", "\n    /*选择单价最高的出售*/", "\n    for(int i=1;i<=n;i++)", "\n    {", "\n        if(cake[i].store<=D)", "\n        {", "\n            D-=cake[i].store;  //此时的市场需求量还剩多少", "\n            money+=cake[i].sell;", "\n             ", "\n        }", "\n        else", "\n        {", "\n            money+=cake[i].price*D;", "\n            break;", "\n         } ", "\n     }", "\n     printf(\"%.2f\\n\",money);", "\n    return 0; ", "\n}", "\n/*", "\n3 20", "\n18 15 10", "\n75 72 45", "\n*/", "\n\n"]], "Tag": "程序设计"}
{"Answer": "scanf(\"%d/:%d/:%d\",&amp;c.hour,&amp;c.minute,&amp;c.second);\r\n修改为\r\nscanf(\"%d%%d\",&amp;c.hour,&amp;c.minute,&amp;c.second);", "Konwledge_Point": "数据封装——结构体", "Question": ["C语言结构输出有关的问题", ["题目：按照下面要求定义一个时钟结构体类型：", "\n\n", "struct clock\n{\n    int hour;\n    int minute;\n    int second;\n};\n然后，编程实现将时钟模拟显示在屏幕上。注意：时钟是24小时的。需要判断输入的数据是否合法。\n输入样例1：\n10,20,3\n输出样例1：\n10:20:03\n\n我写的程序是：\n\n", "\n\n", "#include<stdio.h>\n", "\n\n", "\n", "\n\n", "struct clock\n    {\n        int hour;\n        int minute;\n        int second;\n    };\nint main()\n{\n    struct clock c;\n    scanf(\"%d/:%d/:%d\",&c.hour,&c.minute,&c.second);\n    printf(\"%02d:%02d:%02d\",c.hour,c.minute,c.second);\n    return 0;\n}\n", "\n\n", "\n\n", "但输出出来只有小时是正确的，请问为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Go &lt;a href=\"http://godoc.org/time#Time\" rel=\"noreferrer\"&gt;time.Time&lt;/a&gt; values store an instant in time and a location. The mgo BSON decoder sets the location to &lt;a href=\"http://godoc.org/time#Local\" rel=\"noreferrer\"&gt;time.Local&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;You can set &lt;code&gt;time.Local&lt;/code&gt; to the UTC location:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;time.Local = time.UTC\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;A package designed to be used third parties should not modify the local location, but it's OK within the scope of an application.&lt;/p&gt;\n\n&lt;p&gt;The &lt;a href=\"http://godoc.org/time#Time.UTC\" rel=\"noreferrer\"&gt;Time.UTC()&lt;/a&gt; method returns a time at the same instant in time as the receiver and the location set to UTC. This line will print the time in UTC:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    fmt.Printf(\"%s\n\", items[0].SampleDate.UTC())\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Because MongoDB stores time with lower precision than a time.Time, the value returned from MongoDB may not equal the value you stored.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在Golang中查询mongodb时如何获得UTC时间", ["\n\n", "I am relatively new to Golang and MongoDB and ran into a date issue where it appears that I can insert a UTC date into MongoDB, but when I query through Golang it is getting automatically converted to the local time. I want to get it back from MongoDB in UTC with no conversion. Here is a quick example:", "\n\n", "type SampleItem struct {\n    ObjId      bson.ObjectId `bson:\"_id,omitempty\" json:\"-\"`\n    SampleDate time.Time     `bson:\"sampleDate\" json:\"sampleDate\"`\n}\n\nfunc TestMe() {\n\n    var item SampleItem\n    var items []SampleItem\n\n    sess := getSession()\n    defer sess.Close()\n\n    item.SampleDate = time.Now().UTC()\n    fmt.Printf(\"%s\n\", item.SampleDate)\n\n    collection := sess.DB(\"myCollection\").C(\"sampleItems\")\n    collection.Insert(item)\n\n    err := collection.Find(bson.M{}).All(&items)\n    if err == nil {\n        fmt.Printf(\"%s\n\", items[0].SampleDate)\n    }\n}\n", "\n\n", "My output:", "\n\n", "\n  ", "2014-10-12 04:10:50.3992076 +0000 UTC", "\n  \n  ", "2014-10-11 23:10:50.399 -0500 CDT", "\n", "\n\n", "It appears that the mgo driver may be automatically converting it because when I query mongodb from a console window my date is in UTC. Am I missing a mgo option somewhere that turns this off?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;需要子函数么&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\nusing namespace std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\ntypedef struct &lt;span class=\"hljs-variable\"&gt;_student&lt;/span&gt;\n{\n    int num;\n    string &lt;span class=\"hljs-built_in\"&gt;name&lt;/span&gt;;\n    float &lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n    float avg;\n}student;\n\nint main()\n{\n    student stu[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;],t;\n    int i,j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;输入第&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;个学生信息:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n        cin&amp;gt;&amp;gt;stu[i].num&amp;gt;&amp;gt;stu[i].&lt;span class=\"hljs-built_in\"&gt;name&lt;/span&gt;&amp;gt;&amp;gt;stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;gt;&amp;gt;stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;gt;&amp;gt;stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];\n        stu[i].avg &amp;#61; (stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#43; stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;])/&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;-i;j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(stu[j].avg &amp;lt; stu[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].avg)\n            {\n                t &amp;#61; stu[j];\n                stu[j] &amp;#61; stu[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                stu[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t;\n            }\n        }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        cout&amp;lt;&amp;lt;stu[i].num&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;stu[i].&lt;span class=\"hljs-built_in\"&gt;name&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;stu[i].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&amp;lt;&amp;lt;&lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        int &lt;span class=\"hljs-built_in\"&gt;count&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;j&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(stu[j].&lt;span class=\"hljs-built_in\"&gt;score&lt;/span&gt;[i]&amp;lt;&lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;)\n                &lt;span class=\"hljs-built_in\"&gt;count&lt;/span&gt;&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt;(i)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;高数不及格人数:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;count&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;英语不及格人数:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;count&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;计算机不及格人数:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;count&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n            &lt;span class=\"hljs-built_in\"&gt;break&lt;/span&gt;;\n        }\n    }\n    \n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["hurry！定义学生结构体，每个学生数据包括学号姓名及高数英语…", ["用c++（不是c）编写", "定义学生结构体，每个学生数据包括学号姓名高数英语计算机三门课的成绩。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt; &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; total( struct student stu[],&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; nmb)\n {\n     &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i,j;\n     &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,ave&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n     for (i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;nmb;i&amp;#43;&amp;#43;)\n     {\n         ave &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n         for(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;j&amp;#43;&amp;#43;)\n             ave &amp;#43; stu[i].score[j];\n         ave/&amp;#61;&lt;span class=\"hljs-number\"&gt;3.0&lt;/span&gt;;\n         &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt; &amp;#43;&amp;#61; ave;\n     }\n     &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;/nmb;\n }\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["求n个学生的信息（包括学生的姓名、语数英三门的成绩、）存储在一个结构体数 组 StudentInform 中，现需设计一个函数，统计学生各科成绩平均分的总和， 并通过 函数返回。", ["其中，结构体类型定义的代码如下。 struct student { char name[20]; float score[3]; char address[20];"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sum/5改成sum/5.0&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["帮我看看错在哪。输出结构体mystudent的平均成绩。", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n ", "struct", " ", "STU", "{\n   ", "int", " num;\n   ", "char", " name[", "20", "],sex[", "2", "];\n   ", "int", " age,score;\n   };\n", "/**/", " ", "struct", "  ", "STU", "    ", "/**/", " mystudent[]={\n       {", "1111", ",", "\"Zhangqiang\"", ",", "\"m\"", ",", "20", ",", "80", "},\n       {", "2104", ",", "\"Liminghong\"", ",", "\"w\"", ",", "18", ",", "82", "},\n       {", "3121", ",", "\"Wangxingda\"", ",", "\"m\"", ",", "21", ",", "78", "},\n       {", "4118", ",", "\"Liushaotao\"", ",", "\"m\"", ",", "20", ",", "90", "},\n       {", "1456", ",", "\"Wuminghong\"", ",", "\"w\"", ",", "35", ",", "86", "}\n       };\n", "void", " ", "main", "()", "\n", "{  ", "int", " i;\n", "/**/", " ", "int", " sum=", "0", " ;   ", "/**/", "\n  ", "for", "(i=", "0", ";i<", "5", ";i++)\n      ", "/**/", " sum+=(mystudent[i].score);      ", "/**/", "\n   ", "printf", "(", "\"\\nThr average is:%.2f\\n\"", ",sum/", "5", ");\n   ", "getch", "();\n  }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;amp;student[i].name,&lt;br /&gt;改成&lt;br /&gt;student[i].name,&lt;br /&gt;别的地方也有问题&amp;#xff0c;改了下&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/748860177046152.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\ntypedef struct Stu\n{\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    long long ID;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; Math;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; English;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pj;&lt;span class=\"hljs-regexp\"&gt;//p&lt;/span&gt;j为数学和英语地平均值\n} Stu;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i;\n    Stu student[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入学生信息&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %lld %d %d&amp;#34;&lt;/span&gt;, student[i].name, &amp;amp;student[i].ID,&amp;amp;student[i].Math,&amp;amp;student[i].English);\n        student[i].pj &amp;#61; (student[i].English &amp;#43; student[i].Math)/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;第%d名同学信息&amp;#xff1a;\\n名字&amp;#xff1a;%s 学号&amp;#xff1a;%lld 数&amp;#xff1a;%d 英&amp;#xff1a;%d 平均&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, student[i].name, student[i].ID, student[i].Math, student[i].English,student[i].pj);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["问题：设定一名学生的基本信息包括学号，姓名，数学成绩，英语成绩。现要求你用结构体构 建一个学生的信息库，信息由键盘输入，至少能同时输入五个人的信息。输出学生信息。为什么打印不出来啊，求解答", ["typedef struct Stu", "{", "    char name[20];", "    unsigned long long ID;", "    int Math;", "    int English;", "    int pj;//pj为数学和英语地平均值", "}Stu;", "int main()", "{", "    int i;", "    Stu student[5];", "    printf(\"请输入学生信息：\");", "    for (i = 0; i < 5; i++)", "    {", "        scanf_s(\"%s   %llu   %d    %d\", &student[i].name, &student[i].ID,&student[i].Math,&student[i].English);", "        student[i].pj = (student[i].English + student[i].Math)/2;", "    }", "    for (i = 1; i <= 5; i++)", "    {", "        printf(\"第%d名同学信息：名字：%s   学号：%llu  数：%d  英：%d  平均：%d\",i, student[i].name, student[i].ID, student[i].Math, student[i].English,student[i].pj);", "    }", "    return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "p和q都是指针变量，赋值只是指针之间的赋值，和指针指向的内容没有关系。", "Konwledge_Point": "数据封装——结构体", "Question": ["c＋＋中创建单链表的问题。", ["最后一句p＝q。书上写的是将p指针后移，指向后继结点q。  怎么是指针呢?难道不是直接q把覆盖了吗?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;s是结构体的指针&amp;#xff0c;不是结构体的拷贝&lt;br /&gt;它依赖于被指向的内存&lt;br /&gt;仔细检查args的生命周期&amp;#xff0c;有没有被回收&amp;#xff0c;有没有别的线程在修改它&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Pthread传入一个结构体，在线程内读不到这个结构体", ["结构体 * s =(结构体 * )args", "\n", "然后访问结构体时 ，结构体s的值有时为空 有时正确", "\n", "请教一下是什么原因，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Use the &lt;a href=\"http://godoc.org/reflect\" rel=\"nofollow noreferrer\"&gt;reflect&lt;/a&gt; package to set a field by name:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// setField sets field of v with given name to given value.\nfunc setField(v interface{}, name string, value string) error {\n    // v must be a pointer to a struct\n    rv := reflect.ValueOf(v)\n    if rv.Kind() != reflect.Ptr || rv.Elem().Kind() != reflect.Struct {\n        return errors.New(\"v must be pointer to struct\")\n    }\n\n    // Dereference pointer\n    rv = rv.Elem()\n\n    // Lookup field by name\n    fv := rv.FieldByName(name)\n    if !fv.IsValid() {\n        return fmt.Errorf(\"not a field name: %s\", name)\n    }\n\n    // Field must be exported\n    if !fv.CanSet() {\n        return fmt.Errorf(\"cannot set field %s\", name)\n    }\n\n    // We expect a string field\n    if fv.Kind() != reflect.String {\n        return fmt.Errorf(\"%s is not a string field\", name)\n    }\n\n    // Set the value\n    fv.SetString(value)\n    return nil\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Call it like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var config SshConfig\n\n...\n\nerr := setField(&amp;amp;config, split[0], strings.Join(split[1:], \" \"))\nif err != nil {\n   // handle error\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/16vqu2yhw6d\" rel=\"nofollow noreferrer\"&gt;playground example&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["Golang动态访问struct属性", ["\n\n", "I am writing a quick ssh config to json processor in golang. I have the following stuct:", "\n\n", "type SshConfig struct {\n    Host string\n    Port string\n    User string\n    LocalForward string\n    ...\n}\n", "\n\n", "I am currently looping over every line of my ssh config file and splitting the line on spaces and checking which property to update.", "\n\n", "if split[0] == \"Port\" {\n    sshConfig.Port = strings.Join(split[1:], \" \")\n}\n", "\n\n", "Is there a way to check a property exists and then set it dynamically?", "\n    "]], "Tag": "程序设计"}
{"Answer": "scanf(\"%c\", sex1);\r\n-&gt;\r\nscanf(\"%c\", &amp;sex1);", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体内元素的赋值问题", ["定义一个结构体：", "\ntypedef struct person{", "\n    char name[32];", "\n    char sex;", "\n    int  age;", "\n    char num[16];", "\n    char addr[128];", "\n} people_t, *people_p, **people_pp;", "\n\n", "typedef struct tab", "\n{", "\n    int size;", "\n    int max;", "\n    people_p list;", "\n}tab_t, *tab_p, **tab_pp;", "\n\n", "然后给people结构体中的元素通过tab中的list赋值。我是下面这么写的，", "\n但是运行不过去，每次都会中断。", "\n\n", "  char sex1=0;\n        int age1=0;\n        fflush(stdin);\n        gets(c->list->name);\n        fflush(stdin);\n\n        scanf(\"%c\", sex1);\n        c->list->sex = sex1;//大概就是这里有错，但是实在想不出来怎么弄了\n        fflush(stdin);\n\n        scanf(\"%d\", &age1);\n        c->list->age = age1;//再看看这块可以吗？\n        fflush(stdin);\n\n        gets(c->list->num);\n        fflush(stdin);\n\n        gets(c->list->addr);\n        fflush(stdin);\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;public class Class1&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public int[] ary;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public Class1&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    ary&amp;#61;new int[] { 1,2, 3, 4, 5 };&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;      }&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;//你的主窗体调用&amp;#xff1a;&lt;br /&gt;Class1 c&amp;#61;new Class1();&lt;br /&gt;for (int i &amp;#61; 0; i &amp;lt; c.ary.count; i&amp;#43;&amp;#43;)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;textbox.AppendText(c.ary[i]);&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C#winform在cs文件中（非窗体cs）的数组如何全部显示在textbox里面呢？", ["这是我的cs文件中的代码，数据都储存在hvec_coordinates[hv_I1]里面，手工hvec_coordinates[0],[1],[2]取出是可以的，但是要如何做到循环全部呢？", "\n", "      ", "for", " (hv_I1=", "0", "; (", "int", ")hv_I1<=(", "int", ")((", "new", " ", "HTuple(", "hv_matching_row", ".TupleLength()", "))-", "1", "); hv_I1 = (", "int", ")hv_I1 + ", "1", ")\n      {\n\n        ", "//测量坐标位置", "\n        using (HDevDisposeHelper dh = ", "new", " ", "HDevDisposeHelper()", ")\n        {\n        hvec_coordinates", "[", "hv_I1", "]", " = dh.", "Add(", "new", " HTupleVector(", "hv_child", ")", ");\n        }\n       }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;In your case you don't want to append the &lt;code&gt;string&lt;/code&gt; representation of the struct &lt;code&gt;Link&lt;/code&gt;, you just need its &lt;code&gt;Href&lt;/code&gt; field which is already of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (s Entry) LinkString() string {\n    return s.Link.Href\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also note that if you use a non-pointer receiver &lt;code&gt;Entry&lt;/code&gt;, your method &lt;code&gt;LinkString()&lt;/code&gt; will receive a copy of the struct. Which in this case is not a problem, it's just a little slower because a copy has to be made.&lt;/p&gt;\n\n&lt;p&gt;If your struct gets bigger, it's better to use pointer receiver: &lt;code&gt;*Entry&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (s *Entry) LinkString() string {\n    return s.Link.Href\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also note that you don't even need a method to access the URL text because your fields (&lt;code&gt;Entry.Link&lt;/code&gt; and &lt;code&gt;Link.Href&lt;/code&gt;) are exported because they start with an upper-case letter, so you can simply refer to it like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// e is of type Entry:\nurl := e.Link.Href\n// url is of type string\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["将Go结构转换为字符串", ["\n\n", "My Code :", "\n\n", "type Link struct {\n    Href string `xml:\"href,attr\"`\n}\n\nvar html Link = \"\"\nfunc (s Entry) String() string {\n  links := string(s.Link)\n}\n", "\n\n", "I parsed a whole XML document to get the links and text, Now I want to append all the parsed data in ", "html", " variable to construct a nice view on the localhost. But ", "s.Link", " can't be converted to string data type maybe because type conversion only supports basic data-types , Any Solutions ?", "\n\n", "Live demo : ", "http://play.golang.org/p/7HRHusXLe2", "\n    "]], "Tag": "程序设计"}
{"Answer": "1.换个类名，不要和结构体名字一样\r\n2.private：里的：是全角的，你要改成半角的才行\r\n3.private的成员不能这样赋值，改成public的才行\r\n```\r\n class book2\r\n{\r\npublic:\r\nint number;//书名\r\nchar name[20];//书名\r\nchar writer[30];//作者名\r\nchar press[30];//出版社\r\nint year;//出版日期\r\nint amount;//数量\r\n}str[100]={\r\n{1001,\"c语言程序设计\",\"谭浩强\",\"清华大学出版社\",200704,10},\r\n{1002,\"高等数学\",\"同济大学数学系\",\"高等教育出版社\",200704,10},\r\n{1003,\"大学英语精读\",\"董亚芬\",\"上海外语教育出版社\",200606,8},\r\n{1004,\"证券分析\",\"本杰明?格雷厄姆\",\"中国人民大学出版社\",201304,10},\r\n{1005,\"资源革命\",\"斯蒂芬·赫克\",\"浙江人民出版社\",201507,4}\r\n};\r\n```", "Konwledge_Point": "数据封装——结构体", "Question": ["C++类能不能像结构体一样这么使用？能的话格式是啥样的求大神指导", ["struct book", "\n{", "\n    int number;//书名", "\n    char name[20];//书名", "\n    char writer[30];//作者名", "\n    char press[30];//出版社", "\n    int year;//出版日期", "\n    int amount;//数量", "\n}str[100]={", "\n{1001,\"c语言程序设计\",\"谭浩强\",\"清华大学出版社\",200704,10},", "\n{1002,\"高等数学\",\"同济大学数学系\",\"高等教育出版社\",200704,10},", "\n{1003,\"大学英语精读\",\"董亚芬\",\"上海外语教育出版社\",200606,8},", "\n{1004,\"证券分析\",\"本杰明?格雷厄姆\",\"中国人民大学出版社\",201304,10},", "\n{1005,\"资源革命\",\"斯蒂芬·赫克\",\"浙江人民出版社\",201507,4}", "\n};", "\nclasst book", "\n{", "\nprivate：", "\n    int number;//书名", "\n    char name[20];//书名", "\n    char writer[30];//作者名", "\n    char press[30];//出版社", "\n    int year;//出版日期", "\n    int amount;//数量", "\n}str[100]={", "\n{1001,\"c语言程序设计\",\"谭浩强\",\"清华大学出版社\",200704,10},", "\n{1002,\"高等数学\",\"同济大学数学系\",\"高等教育出版社\",200704,10},", "\n{1003,\"大学英语精读\",\"董亚芬\",\"上海外语教育出版社\",200606,8},", "\n{1004,\"证券分析\",\"本杰明?格雷厄姆\",\"中国人民大学出版社\",201304,10},", "\n{1005,\"资源革命\",\"斯蒂芬·赫克\",\"浙江人民出版社\",201507,4}", "\n};", "\n但为什么类会出错"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个问题&amp;#xff0c;gets()函数从输入流中读取字符串&amp;#xff0c;直至接受到换行符或EOF时停止&amp;#xff0c;读取的换行符被转换为‘\\0’空字符&amp;#xff0c;并由此来结束字符串。scanf()函数从输入流中读取时&amp;#xff0c;它会忽略空白符 制表符 和 新换行符等&amp;#xff0c;它要比gets()函数复杂些。上面的代码&amp;#xff0c;当我们输入第一本书的价格后&amp;#xff0c;有一个回车换行符被保留在了输入缓冲区里&amp;#xff0c;当我们开始输入第二本书的书名时&amp;#xff0c;这个保留在缓冲区的回车换行符被gets()读取了&amp;#xff0c;所以出现了图一的现象。解决这个问题的办法&amp;#xff0c;就是在scanf(&amp;#34;%d&amp;#34;, &amp;amp;arr[i].price); 这条语句之后&amp;#xff0c;加入 getchar(); 这句&amp;#xff0c;利用getchar();这句吸收释放掉缓冲区残留的回车换行符。&lt;br /&gt;第二个问题&amp;#xff0c;对于字符串数组或字符串指针变量&amp;#xff0c;由于数组名和指针变量名本身就是地址&amp;#xff0c;因此使用scanf()函数时&amp;#xff0c;不需要在它们前面加上&amp;#34;&amp;amp;&amp;#34;操作符。 &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体数组接受数据的问题", ["这里用gets函数为什么会出问题，scanf函数就没问题", "                                为什么前面接受字符串的函数不用&（arr[ i ]）,用arr[ i ]就可以了    ", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n//定义一个结构体\nstruct NodeData \n{\n\tint nmb;\n\tint bsxh; //是否是水仙花数\n};\n\n//判断是否是水仙花\nint isShuixianhua(int n)\n{\n\tint d,nmb&amp;#61;n;\n\tint sum &amp;#61; 0;\n\twhile(n)\n\t{\n\t\td &amp;#61; n%10;\n\t\tsum &amp;#43;&amp;#61; (d*d*d);\n\t\tn /&amp;#61; 10;\n\t}\n\tif(nmb &amp;#61;&amp;#61; sum)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nint main()\n{\n\tstruct NodeData a[1000];\n\tstruct NodeData* p;\n\tint i;\n\tFILE* fp;\n\tfor (i&amp;#61;100;i&amp;lt;&amp;#61;1000;i&amp;#43;&amp;#43;)\n\t{\n\t\ta[i-100].nmb &amp;#61; i;\n\t\ta[i-100].bsxh &amp;#61; isShuixianhua(i);\n\t}\n\tp &amp;#61; a;\n\ti &amp;#61; 100;\n\tfp &amp;#61; fopen(&amp;#34;out.txt&amp;#34;,&amp;#34;w&amp;#34;);\n\twhile(i&amp;lt;&amp;#61;1000)\n\t{\n\t\tif(p-&amp;gt;bsxh)\n\t\t\tfprintf(fp,&amp;#34;%d\\n&amp;#34;,p-&amp;gt;nmb);\n\t\tp&amp;#43;&amp;#43;;\n\t\ti&amp;#43;&amp;#43;;\n\t}\n\tfclose(fp);\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["怎样用数组，指针，结构体，文件写出这个程序", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "首先，\r\n struct letters next;\r\n应该是\r\nstruct letters* next;", "Konwledge_Point": "数据封装——结构体", "Question": ["关于一个单词匹配的题目，得不到想要的结果，贴出源程序，求大神帮忙~~~", ["#include", "\n#include", "\n#include", "\n#include", "\n#include", "\nint IsOneCharDifferent(char array[255]);", "\nint IsIt(char array[255]);", "\nint IsMoreOrLessOneChar(char array[255]);", "\n//*************************************************************************************", "\n//创建结构体链表保存每个单词的序号、长度、以及链表所需的指针。即字典表的单词数目无限。", "\n//*************************************************************************************", "\n\n", "typedef struct letters", "\n{", "\n    char letter[255];", "\n    int num;", "\n    int lenth;", "\n    struct letters ", "next;", "\n}NODE;", "\nNODE *head;", "\nNODE *p;", "\n//", "*********************************************************************************************", "\n//load函数读取系统文件", "\n//**********************************************************************************************", "\n\n", "void load()", "\n{", "\n    FILE * fp;", "\n    fp=fopen(\"c:\\Big Scary\\课程设计\\2_单词匹配\\letters.txt\",\"r\");", "\n    if((fp=fopen(\"c:\\Big Scary\\课程设计\\2_单词匹配\\output.txt\",\"r\"))==NULL)", "\n    {", "\n        printf(\"不能打开文件\\n\");", "\n        return;", "\n    }", "\n    NODE *head;", "\n    head=(NODE *)malloc(sizeof(NODE));", "\n    NODE *p;", "\n    head->next=NULL;", "\n    while(!feof(fp))", "\n    {", "\n        p=(NODE *)malloc(sizeof(NODE));", "\n        fscanf(fp,\"%s\",&p->letter);", "\n        fscanf(fp,\"%d\",&p->num);", "\n        fscanf(fp,\"%d\",&p->lenth);", "\n        if(feof(fp))", "\n        {", "\n            free(p);", "\n            break;", "\n        }", "\n        p->next=head->next;", "\n        head->next=p;", "\n    } ", "\n    fclose(fp);", "\n}", "\n\n", "//**********************************************************************************************", "\n//int IsOneCharDifferent(char array[255])函数找出与输入单词相差一个字母的单词序号。并赋值给Ei。", "\n//**********************************************************************************************", "\n\n", "int IsOneCharDifferent(char array[255])", "\n{", "\n    load();", "\n    int num=0;", "\n    int len=strlen(array);", "\n    NODE ", "ps=p;", "\n    for(;ps->next!=0;ps=ps->next)", "\n    {", "\n        if(p->lenth!=len)", "\n        {", "\n            return 0;", "\n        }", "\n        for(int c=0;clenth;c++)", "\n            if(p->letter!=array)", "\n            {", "\n                num++;", "\n                if(num>1)", "\n                    return 0;", "\n                else", "\n                    return p->num;", "\n            }", "\n    }", "\n    return 0;", "\n}", "\n//", "************************************************************************************************", "\n//int IsMoreOrLessOneChar(char array[255])函数找出与输入单词多或者少一个字母的单词序号。并赋值给Fi。", "\n//*************************************************************************************************", "\nint IsMoreOrLessOneChar(char array[255])", "\n{", "\n    load();", "\n    int len=strlen(array);", "\n    NODE *ps=p;", "\n    for(;ps->next!=0;ps=ps->next)", "\n    {", "\n        if(p->lenth!=len)", "\n        {", "\n            return 0;", "\n        }", "\n        else if(p->lenth-len==1||len-p->lenth==1)", "\n        {", "\n            return(p->num);", "\n        }", "\n        else", "\n            return 0;", "\n    }", "\n    return 0;", "\n}", "\n\n", "//**********************************************************************************************", "\n//int IsIt(char array[255])函数找出与输入单词完全相同的单词序号。并赋值给i。", "\n//**********************************************************************************************", "\n\n", "int IsIt(char array[255])", "\n{", "\n    load();", "\n    int len=strlen(array);", "\n    NODE *ps=p;", "\n    for(;ps->next!=0;ps=ps->next)", "\n    {", "\n        if(p->lenth!=len)", "\n        {", "\n            return 0;", "\n        }", "\n        if(strcmp(array,p->letter)==0)", "\n        {", "\n            return(p->num);", "\n        }", "\n        else", "\n            return 0;", "\n    }", "\n    return 0;", "\n}", "\n\n", "//*******************************************************************", "\n//CharPiPei()函数进行单词匹配操作。", "\n//*******************************************************************", "\n\n", "void CharPiPeiSave()", "\n{", "\n\n", "char array[255];\nprintf(\"请随意输入一个单词:\\n\");\nfflush(stdin);\ngets(array);\nIsIt(array);\nIsOneCharDifferent(array);\nIsMoreOrLessOneChar(array);\nFILE * fp;\nfp=fopen(\"c:\\\\Big Scary\\\\课程设计\\\\2_单词匹配\\\\output.txt\",\"w\");\nNODE *p=head->next;\nint i=0,Ei=0,Fi=0;\ni=IsIt(array);\nEi=IsOneCharDifferent(array);\nFi=IsMoreOrLessOneChar(array);\nwhile(p!=0)\n{\n    fprintf(fp,\"i %d\",i);\n    fprintf(fp,\"Ei %d\",Ei);\n    fprintf(fp,\"Fi %d\",Fi);\n    p=p->next;\n}\nfclose(fp);\n", "\n\n", "}", "\n\n", "//*******************************************************************************************", "\n//menu函数提供三种操作，添加新单词；单词匹配；退出。用switch语句分别选择调用3个函数进行操作 ", "\n//*******************************************************************************************", "\n\n", "void menu()", "\n{", "\n    printf(\"                 ┏━━━━━━━━━━━━━━━━━━━━━━┓\\n\");", "\n    printf(\"                 ┃           欢迎使用字典表匹配单词           ┃\\n\");", "\n    printf(\"                 ┃                                            ┃\\n\");", "\n    printf(\"                 ┃                                            ┃\\n\");", "\n    printf(\"                 ┃                1. 添加新单词               ┃\\n\");", "\n    printf(\"                 ┃                                            ┃\\n\");", "\n    printf(\"                 ┃                2. 单词匹配                 ┃\\n\");", "\n    printf(\"                 ┃                                            ┃\\n\");", "\n    printf(\"                 ┃                3. 退出程序                 ┃ \\n\");", "\n    printf(\"                 ┃                                            ┃\\n\");", "\n    printf(\"                 ┗━━━━━━━━━━━━━━━━━━━━━━┛\\n\");", "\n    printf(\"\\n\");", "\n    printf(\"请选择所要进行的项目:\\n\");", "\n    int select;", "\n    scanf(\"%d\",&select);", "\n    switch(select)", "\n    {", "\n        case 1:    ;", "\n        case 2:    CharPiPeiSave();", "\n        case 3:    ;", "\n    ;}", "\n\n", "}", "\n\n", "//******************************************************", "\n//调背景色彩", "\n//******************************************************", "\n\n", "void system()", "\n{", "\n    system(\"color f5\");", "\n}", "\n\n", "//******************************************************", "\n//用main函数调用所需所有函数", "\n//******************************************************", "\n\n", "void main()", "\n{", "\n    system();", "\n    menu();", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Go does not support enums. You should either define your enumerated fields as &lt;code&gt;var&lt;/code&gt;s or to ensure immutability, maybe use functions that return a constant result.&lt;br&gt;\nFor example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type myStruct { ID int }\n\nfunc EnumValue1() myStruct { \n    return myStruct { 1 } \n}\n\nfunc EnumValue2() myStruct { \n    return myStruct { 2 } \n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["GO中的结构枚举", ["\n\n", "I would like to enumerate the planets in my Go program.\nEach planet includes a common name (ex: \"Venus\") and a distance from the sun in Astronomical Unit (ex: 0.722)", "\n\n", "So I wrote this code :", "\n\n", "type planet struct {\n    commonName string\n    distanceFromTheSunInAU float64\n}\n\nconst(\n    venus planet = planet{\"Venus\", 0.387}      // This is line 11\n    mercury planet = planet{\"Mercury\", 0.722}\n    earth planet = planet{\"Eath\", 1.0}\n    mars planet = planet{\"Mars\", 1.52}\n    ...\n)\n", "\n\n", "But Go didn't let me compile this, and gave me this error :", "\n\n", "# command-line-arguments\n./Planets.go:11: const initializer planet literal is not a constant\n./Planets.go:12: const initializer planet literal is not a constant\n./Planets.go:13: const initializer planet literal is not a constant\n./Planets.go:14: const initializer planet literal is not a constant\n", "\n\n", "Do you have any idea of how I could do?\nThanks", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;_mystruct不是变量&amp;#xff0c;是类型名称&lt;br /&gt;分开来理解一下&lt;br /&gt; struct mystruct&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;int a&amp;#xff1b;&lt;br /&gt;int b&amp;#xff1b;&lt;br /&gt;}&lt;br /&gt;是我们常见的结构定义&amp;#xff0c;定义后结构体就是个类型&amp;#xff0c;用法是 struct mystruct my1; 这样定义一个my1的结构体变量&amp;#xff0c;类型与 int a这样定义一个整型变量&lt;br /&gt;为了使用或者后续修改方便&amp;#xff0c;使用typedef 给类型定义一个别名&lt;br /&gt;比如&lt;br /&gt;typedef int DWORD &amp;#xff0c;这样DWORD相当于int&lt;br /&gt;同理&lt;br /&gt;typedef struct mystruct&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;int a&amp;#xff1b;&lt;br /&gt;int b&amp;#xff1b;&lt;br /&gt;} _mystruct&lt;br /&gt;就是给结构体mystruct定义了一个别名_mystruct&amp;#xff0c;后续可以直接 _mystruct my1;来定义一个结构体变量了&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["C++结构体声明问题", ["  C++中结构体声明", "\n", "typedef struct mystruct", "{", "  int a；", "  int b；", "}_mystruct ;", "\n", "这个最后的结构体类型变量的声明 ", "mystruct 是什么意思？跟前面结构体类型变量mystruct一样，就多个", "请解释一下这是什么用法，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You CANNOT do that. &lt;code&gt;map[string]interface{}&lt;/code&gt; and &lt;code&gt;map[string]Bar&lt;/code&gt; are two different types. You have to build a &lt;code&gt;map[string]interface{}&lt;/code&gt; with the &lt;code&gt;map[string]Bar&lt;/code&gt; manually.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;mapAny := make(map[string]interface{})\nfor key, val := range myMap {\n    mapAny[key] = val\n}\nfoo(mapAny)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;What you need is template in C++, however, Golang doesn't have template support.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何声明可以在golang中接受任何类型的值的map参数？  [重复]", ["\n\n", "\n    ", "This question already has an answer here:", "\n    ", "\n", "\n            ", "Type converting slices of interfaces", "\n                \n                    5 answers\n                \n        ", "\n    ", "\n", "\n\n", "For your convenience: ", "go playground", "\n\n", "I has a function which does not care the value type of a map parameter, so\nI declare it as this:", "\n\n", "func foo(generalMap map[string]interface{}) {}", "\n\n", "But when I call it with a specified map like this:", "\n\n", "myMap := make(map[string]Bar)\nfoo(myMap)\n", "\n\n", "Then the compiler error comes out:\n", "cannot use myMap (type map[string]Bar) as type map[string]interface {} in argument to foo", "\n\n", "</div>\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;One defines a Car variable, the other returns a pointer to a Car.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var car Car      // defines variable car is a Car\ncar2 := new(Car) // defines variable car2 is a *Car and assigns a Car to back it\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;car := new(Car)&lt;/code&gt; can be implemented in relation to &lt;code&gt;var car Car&lt;/code&gt; like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var x Car\ncar := &amp;amp;x\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["在Go中声明带有“ var”的新结构实例与使用“ new”有何不同？", ["\n\n", "The following code creates a usable instance of the struct, ", "Car", ". How is this different than using ", "new(Car)", "?", "\n\n", "Example:", "\n\n", "type Car struct {\n  make string\n}\n\nfunc Main() {\n  var car Car; // how is this different than \"car := new(Car)\"?\n\n  car.make = \"Honda\"\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You should hardly ever use pointer to interface. My advice is to never use it, when you'll need it, you'll know.&lt;/p&gt;\n\n&lt;p&gt;Instead if you need a pointer to something (so you can have the same pointer at multiple places, and so modifying the pointed value somewhere, it will have effect on the others), \"wrap the pointer\" in the interface value.&lt;/p&gt;\n\n&lt;p&gt;So first modify the &lt;code&gt;items&lt;/code&gt; field so that it stores &lt;code&gt;interface{}&lt;/code&gt; values instead of pointers:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;items map[string]interface{}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This means no restriction: you can pass and store pointers, that's not a problem.&lt;/p&gt;\n\n&lt;p&gt;Next modify &lt;code&gt;Get()&lt;/code&gt; to return &lt;code&gt;interface{}&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (cls *Container) Get(value string) interface{}{\n    return cls.items[value]\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And also in &lt;code&gt;Put()&lt;/code&gt;, don't take the address of an &lt;code&gt;interface{}&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (cls *Container) Put(value string, a int64) {\n    res := cls.GetMysql(value, a)\n    cls.items[value] = res\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And you have to type-assert &lt;code&gt;*Member&lt;/code&gt; from the values returned by &lt;code&gt;Get()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;And now testing it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;c := Container{outerType: Member{}}\nc.items = make(map[string]interface{})\nc.Put(\"Jack\", 500)\nres := c.Get(\"Jack\")\nfmt.Println(res)\nm := res.(*Member) // Here is the problem. How to convert ?\nfmt.Println(m)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output (try it on the &lt;a href=\"https://play.golang.org/p/fJ3bvW4DyUk\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;amp;{0 Jack 500 0}\n&amp;amp;{0 Jack 500 0}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Now if you would modify a field of &lt;code&gt;m&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;m.Credit = 11\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then get the value form the cache:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;fmt.Println(c.Get(\"Jack\"))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We'll see the modified value, even though we did not call &lt;code&gt;Put()&lt;/code&gt; (try it on the &lt;a href=\"https://play.golang.org/p/jUX9rj2omZ3\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;amp;{0 Jack 11 0}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["如何将接口转换为结构", ["\n\n", "Here is the simplified code of a cache. Suppose ", "Container", " placed in a package, so it don't know about ", "Member", ".\nWhile I wanna store instances of Member in Container, So I store an empty instance of Member in Container as ", "outerType", ". \nIn the ", "Container->GetMysql", ", I fill a new variable by test values (but, in real world, It fill by data of database, dynamically).\nthen in the function ", "Put", ", I store data in items as Cache for next uses. In the ", "Get", " I get the data stored in the items.\nBefore this every thing is fine. My problem is where i want to convert result of Get to type of Member ", "m = res.(Member)", " . How Can I convert it to an instance of Member \nI found many question about this subject, but none of them solved my problem", "\n\n", "For more detail: I want the ", "Get", " return data with its pointer of where it stored in items. So if I get some variable of same member, an change in one are shown in others", "\n\n", "package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Member struct {\n    Id     int\n    Name   string\n    Credit int\n    Age    int\n}\n\ntype Container struct {\n    outerType interface{}\n    items     map[string]*interface{}\n}\n\nfunc (cls *Container)GetMysql(s string, a int64) interface{}{\n    obj := reflect.New(reflect.TypeOf(cls.outerType))\n    elem := obj.Elem()\n    //elem := reflect.ValueOf(o).Elem()\n    if elem.Kind() == reflect.Struct {\n        f := elem.FieldByName(\"Name\")\n        f.SetString(s)\n        f = elem.FieldByName(\"Credit\")\n        f.SetInt(a)\n    }\n    return obj.Interface()\n}\n\nfunc (cls *Container)Get(value string) *interface{}{\n    return cls.items[value]\n}\n\nfunc (cls *Container)Put(value string, a int64) {\n    res := cls.GetMysql(value, a)\n    cls.items[value] = &res\n}\n\nfunc main() {\n    c := Container{outerType:Member{}}\n    c.items = make(map[string]*interface{})\n    c.Put(\"Jack\", 500)\n    res := c.Get(\"Jack\")\n    fmt.Println(*res)\n    m := &Member{}\n    m = res.(Member) // Here is the problem. How to convert ?\n    fmt.Println(m)\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、如果把成绩放在课程结构体里有点混乱了&amp;#xff0c;每个学生有多门课的成绩&amp;#xff0c;如果把成绩放课程结构体里你可能又得包含更多学生的信息来标识这门课是哪个学生的成绩。&lt;br /&gt;2、你只需要关注每门课程是哪个学生选择&amp;#xff0c;也就是在课程结构体里加所属哪个学生&amp;#xff0c;然后把成绩放在学生结构体里。&lt;br /&gt;3、要用最精简的结构来存储数据&amp;#xff0c;这样才是好的代码。&lt;br /&gt;4、推荐使用visual studio来写代码&amp;#xff0c;号称宇宙第一编译器可不是盖的&amp;#x1f600;&lt;/p&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["c++结构体间引用问题", ["一个学生每门课的成绩不一样，我应该是在学生结构体里引用成绩结构体呢，还是在课程结构体里引用成绩结构体呢？该如何引用呢？谢谢学霸们了。", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;%s,%s字符串输入之间不能用逗号作为分隔符。比如你输入ab,cd的话&amp;#xff0c;整个ab,cd都作为第一个字符串的内容了。&lt;br /&gt;建议全部改用空格作为分隔符&lt;br /&gt;另外就是函数最后一个参数ave只是值参&amp;#xff0c;函数内是修改不了传入变量的值的。改为指针或者作为函数的返回值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;math.h&amp;gt;\n&lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; ave&lt;span class=\"hljs-constructor\"&gt;Score(&lt;span class=\"hljs-params\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;)&lt;/span&gt;\n{\n    return (a&amp;#43;b&amp;#43;c)/&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; stu\n{\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; number&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; name&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;]&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; programming;\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; database;\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; network;\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; ave;\n}s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;]&lt;/span&gt;;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;i&amp;#43;&amp;#43;)\n{\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d名学生的学号,姓名,和三门课程的成绩\\n&amp;#34;&lt;/span&gt;,i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %s %f %f %f&amp;#34;&lt;/span&gt;,s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.number,s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.name,&amp;amp;s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.programming,&amp;amp;s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.database,&amp;amp;s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.network);\n    s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.ave &amp;#61; ave&lt;span class=\"hljs-constructor\"&gt;Score(&lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;programming&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;database&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;].&lt;span class=\"hljs-params\"&gt;network&lt;/span&gt;)&lt;/span&gt;;\n}\nprintf(&lt;span class=\"hljs-string\"&gt;&amp;#34;-----------------------\\n姓名   平均分\\n&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s %.1f\\n&amp;#34;&lt;/span&gt;,s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.name,s&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;.ave);\nreturn &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数据封装——结构体", "Question": ["结构体数组函数问题，代码运行报错，运行环境DEV", ["题目：输入6名学生的学号，姓名和三门课程的成绩，三门课程的名称：", "（programming,database,network），存入到一个结构体数组中；编写aveScore()函数，其功能是计算学生三门课程的平均成绩，并存到结构体数组中；在主函数中输入学生信息，调用aveScore()函数，并输出学生的姓名和平均分信息。", "\n", "自己写的源程序（运行有问题）：", "\n", "#", "include", "<stdio.h>\n#", "include", "<math.h> \nvoid ave", "Score(", "float", " ", "a", ",", "float", " ", "b", ",", "float", " ", "c", ",", "float", " ", "ave", ")", "\n{\n    ave=(a+b+c)/", "3", ";\n}\n", "struct", " stu\n{\n    ", "char", " number;\n    ", "char", " name", "[", "50", "]", ";\n    ", "float", " programming;\n    ", "float", " database;\n    ", "float", " network;\n    ", "float", " ave;\n}s", "[", "6", "]", ";\n", "int", " main", "()", "\n{\n", "int", " i;\n", "for", "(i=", "0", ";i<", "6", ";i++)\n{\n    printf(", "\"请输入第%d名学生的学号,姓名,和三门课程的成绩\\n\"", ",i+", "1", ");\n    scanf(", "\"%s,%s,%f,%f,%f\"", ",&s", "[", "i", "]", ".number,&s", "[", "i", "]", ".name,&s", "[", "i", "]", ".programming,&s", "[", "i", "]", ".database,&s", "[", "i", "]", ".network);\n    ave", "Score(", "s", "[", "i", "].", "programming", ",", "s", "[", "i", "].", "database", ",", "s", "[", "i", "].", "network", ",", "s", "[", "i", "].", "ave", ")", ";\n}\nprintf(", "\"-----------------------\\n姓名   平均分\\n\"", ");\n", "for", "(i=", "0", ";i<", "6", ";i++)\n{\nprintf(", "\"\\n%s%f\"", ",s", "[", "i", "]", ".name,s", "[", "i", "]", ".ave);\nprintf(", "\"\\n\"", ");\n}\nreturn ", "0", ";\n}\n\n", "\n", "问题截图：", "\n", "请问一下我的错误出在哪，帮忙改正一下"]], "Tag": "程序设计"}
