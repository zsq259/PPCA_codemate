{"Answer": "http://blog.csdn.net/wangyuchun_799/article/details/38460515", "Konwledge_Point": "多重赋值", "Question": ["多重数组的dim后，怎么把一个整个下标拷贝到另一个整个下标里，直接等号赋值不行？", ["多重数组的dim后，怎么把一个整个下标拷贝到另一个整个下标里，直接等号赋值不行？还有什么办法可以直接拷贝整个下标的？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的代码贴出来看看&amp;#xff0c;是不是越界了啊。另外应该是scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i][j]); &amp;amp;符号不能少&lt;br /&gt;参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n&lt;span class=\"hljs-attribute\"&gt;for&lt;/span&gt;(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    &lt;span class=\"hljs-attribute\"&gt;for&lt;/span&gt;(int j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-attribute\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i][j]);\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "多重赋值", "Question": ["C语言中，如何用scanf语句在双重for循环中给二维数组a[5][5]赋值", ["在循环for(i){  for(j) {    scanf(\"%d\",a[i][j]);     }   }，每次输入后按回车，只能输入几个就程序中断，而且后续输出a[i][j]语句也不执行了  ", "\n", "能否帮忙写出正确的双重for循环，使用scanf赋值的语句，多谢啦"]], "Tag": "程序设计"}
{"Answer": "经深入看书，试对此问题自行回答。\r\n\r\n问题一：Wine的构造函数中可以对Pair&lt; ArrayInt, ArrayInt&gt;的两个ArrayInt对象分别赋值，但是为什么对Pair&lt; ArrayInt, ArrayInt&gt;作为一个整体的对象不能这么做？\r\n答：示例代码中先定义了两个ArrayInt对象的临时变量作为左值，并将它们作为参数分别对Pair&lt;&gt;的first()和second()进行复制赋值，所以可以通过。\r\n而(*((PairArray*)this)) = Pair(yr_temp, bot_temp);  // invalid 这条语句赋值符号右边是函数返回值，是一个右值，但Pair&lt;&gt;没有定义移动赋值运算符，所以不通过编译。\r\n解决方案有两个：要么定义移动语义版本的赋值运算符和构造函数，要么显式定义一个变量（左值）temp_val存储此右值，然后用temp_val作为相应的函数参数\r\n\r\n\r\n问题2的答案就在图示的编译器错位提示里。。。。。", "Konwledge_Point": "多重赋值", "Question": ["C++中私有继承的派生类，如何对继承来的子对象使用赋值运算符？", ["本人新手，做书上的练习题遇到的麻烦。", "\n\n", "问题背景：", "\n要操作的是一个多重继承的派生类Wine，分别私有继承了一个标准string类和一个模板类Pair< T1,T2>,", "\n其中T1、T2均具体化为std::valarray< int>，代码如下", "\n\n", "// 模板类（作为基类）的定义\ntemplate <class T1, class T2>\nclass Pair {\nprivate:\n    T1 a;\n    T2 b;\npublic:\n    ...\n    T1 & first() { return a; }\n    T2 & second() { return b; }\n    T1 first() const { return a; }\n    T2 second() const { return b; }\n    Pair & operator=(Pair & rp);\n};\ntemplate < class T1, class T2 >\nPair<T1, T2> & Pair<T1, T2>::operator=(Pair<T1, T2> & rp) {\n    a = rp.first();\n    b = rp.second();\n    return *this;\n}\n\n// 派生类的定义\ntypedef std::valarray<int> ArrayInt;\ntypedef Pair<ArrayInt, ArrayInt> PairArray;\n\nclass Wine : private string,private PairArray {\nprivate:\n    int years;\npublic:\n    Wine(const char *lab, int y, int yr[], const int bot[]);\n    // 字符串lab填充继承来的string子对象，y填充years，\n    // yr[] 和 bot[] 都转换成ArrayInt，用来填充继承来的 Pair<ArrayInt, ArrayInt>\n    ...\n};\n", "\n\n", "我的问题：", "\n\n", "问题1：Wine的构造函数中可以对Pair< ArrayInt, ArrayInt>的两个ArrayInt对象分别赋值，但是为什么对Pair< ArrayInt, ArrayInt>作为一个整体的对象不能这么做？", "\n\n", "Wine::Wine(const char *l, int y, int yr[], const int bot[]) : string(l), years(y) {\n    ArrayInt yr_temp(years), bot_temp(years);\n    for (int i = 0; i < years; i++) {\n        yr_temp[i] = yr[i];\n        bot_temp[i] = bot[i];\n    }\n    (*((PairArray*)this)).first() = yr_temp;    // ok\n    (*((PairArray*)this)).second() = bot_temp;  // ok\n}\n\nWine::Wine(const char *l, int y, int yr[], const int bot[]) : string(l), years(y) {\n    ArrayInt yr_temp(years), bot_temp(years);\n    for (int i = 0; i < years; i++) {\n        yr_temp[i] = yr[i];\n        bot_temp[i] = bot[i];\n    }\n    (*((PairArray*)this)) = Pair(yr_temp, bot_temp);  // invalid\n}\n", "\n\n", "\n\n", "（问题1的图片）", "\n\n", "问题2：为什么必须用(*((PairArray*)this))而不能用(PairArray &)(*this)，这两者有什么不同吗？", "\n\n", "问题2的图片：", "\n\n", "\n\n", "本人C++后进，若有前辈能不吝点拨一二，感激不尽"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;reverse()用于颠倒数组中的元素&amp;#xff0c;这个方法会直接在原数组上操作&amp;#xff0c;比如 var a&amp;#61;[1,2,3,4],那么a.severse()后a数组就直接变成了[4,3,2,1]。但是join()不会对原数组进行操作&amp;#xff0c;也就是不会去改变原数组&amp;#xff0c;jion()方法是将数组转为字符串&amp;#xff0c;如果说直接对原数组操作&amp;#xff0c;那么我刚刚例子里的a就不是一个数组&amp;#xff0c;而是一个字符串&amp;#xff0c;那么如果我在后续的操作中还需要a是一个数组就需要将a从字符串转为一个数组&amp;#xff0c;这样就会变得很繁琐&amp;#xff0c;如果不对原数组进行直接操作&amp;#xff0c;而是返回一个新数组&amp;#xff0c;那么我只需要在场景需要时转变一下就好&amp;#xff0c;不会影响之后我对该数组的操作&amp;#xff0c;很方便。&lt;/p&gt;", "Konwledge_Point": "多重赋值", "Question": ["js问题，为什么这样写join不起作用？", ["\n", "var str = \"welcome to beijing\";\n                  var arr = str.split(\" \", 3);\n                  arr.reverse();\n                  arr.join(\" \");\n                  alert(arr)", "\n\n", "为什么必须得把join赋给一个值alert（arr）才起作用，为什么reverse不用这样赋值?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;详解都发在这了&amp;#xff0c;那我求个采纳&amp;#xff1f;&amp;#xff08;手动狗头&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "多重赋值", "Question": ["C语言运算符的优先级和结合性详细解说", ["C语言运算符的优先级和结合性详细解说", "\n\n", "原文地址", "\n\n", "\n\t\t\t", "优先级", "\n\t\t\t", "\n\t\t\t", "运算符", "\n\t\t\t", "\n\t\t\t", "含义", "\n\t\t\t", "\n\t\t\t", "使用形式", "\n\t\t\t", "\n\t\t\t", "结合性", "\n\t\t\t", "\n\t\t\t", "操作数", "\n\t\t\t", "\n\t\t\t", "1", "\n\t\t\t", "\n\t\t\t", "[ ]", "\n\t\t\t", "\n\t\t\t", "数组下标", "\n\t\t\t", "\n\t\t\t", "数组名[整型表达式]", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", " ", "\n\t\t\t", "( )", "\n\t\t\t", "\n\t\t\t", "圆括号", "\n\t\t\t", "\n\t\t\t", "(表达式)", "\n\t\t\t", " ", "\n\t\t\t", ".", "\n\t\t\t", "\n\t\t\t", "成员选择(对象)", "\n\t\t\t", "\n\t\t\t", "对象.成员名", "\n\t\t\t", " ", "\n\t\t\t", "->", "\n\t\t\t", "\n\t\t\t", "成员选择(指针)", "\n\t\t\t", "\n\t\t\t", "对象指针->成员名", "\n\t\t\t", " ", "\n\t\t\t", "++", "\n\t\t\t", "\n\t\t\t", "后缀自增运算符", "\n\t\t\t", "\n\t\t\t", "变量名++", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "--", "\n\t\t\t", "\n\t\t\t", "后缀自减运算符", "\n\t\t\t", "\n\t\t\t", "变量名--", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "2", "\n\t\t\t", "\n\t\t\t", "-", "\n\t\t\t", "\n\t\t\t", "负号运算符", "\n\t\t\t", "\n\t\t\t", "-表达式", "\n\t\t\t", "\n\t\t\t", "右结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "(类型)", "\n\t\t\t", "\n\t\t\t", "强制类型转换", "\n\t\t\t", "\n\t\t\t", "(数据类型)表达式", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "++", "\n\t\t\t", "\n\t\t\t", "前缀自增运算符", "\n\t\t\t", "\n\t\t\t", "++变量名", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "--", "\n\t\t\t", "\n\t\t\t", "前缀自减运算符", "\n\t\t\t", "\n\t\t\t", "--变量名", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "*", "\n\t\t\t", "\n\t\t\t", "取值运算符", "\n\t\t\t", "\n\t\t\t", "*指针表达式", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "&", "\n\t\t\t", "\n\t\t\t", "取地址运算符", "\n\t\t\t", "\n\t\t\t", "&左值表达式", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "!", "\n\t\t\t", "\n\t\t\t", "逻辑非运算符", "\n\t\t\t", "\n\t\t\t", "!表达式", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "~", "\n\t\t\t", "\n\t\t\t", "按位取反运算符", "\n\t\t\t", "\n\t\t\t", "~表达式", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "sizeof", "\n\t\t\t", "\n\t\t\t", "长度运算符", "\n\t\t\t", "\n\t\t\t", "sizeof 表达式 或 sizeof(类型)", "\n\t\t\t", "\n\t\t\t", "单目运算符", "\n\t\t\t", "\n\t\t\t", "3", "\n\t\t\t", "\n\t\t\t", "/", "\n\t\t\t", "\n\t\t\t", "除法运算符", "\n\t\t\t", "\n\t\t\t", "表达式/表达式", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "*", "\n\t\t\t", "\n\t\t\t", "乘法运算符", "\n\t\t\t", "\n\t\t\t", "表达式*表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "%", "\n\t\t\t", "\n\t\t\t", "求余运算符", "\n\t\t\t", "\n\t\t\t", "整型表达式%整型表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "4", "\n\t\t\t", "\n\t\t\t", "+", "\n\t\t\t", "\n\t\t\t", "加法运算符", "\n\t\t\t", "\n\t\t\t", "表达式+表达式", "\n\t\t\t", "左结合性", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "-", "\n\t\t\t", "\n\t\t\t", "减法运算符", "\n\t\t\t", "\n\t\t\t", "表达式-表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "5", "\n\t\t\t", "\n\t\t\t", "<<", "\n\t\t\t", "\n\t\t\t", "左移运算符", "\n\t\t\t", "\n\t\t\t", "表达式<<表达式", "\n\t\t\t", "左结合性", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", ">>", "\n\t\t\t", "\n\t\t\t", "右移运算符", "\n\t\t\t", "\n\t\t\t", "表达式>>表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "6", "\n\t\t\t", "\n\t\t\t", ">", "\n\t\t\t", "\n\t\t\t", "大于运算符", "\n\t\t\t", "\n\t\t\t", "表达式>表达式", "\n\t\t\t", "左结合性", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", ">=", "\n\t\t\t", "\n\t\t\t", "大于等于运算符", "\n\t\t\t", "\n\t\t\t", "表达式>=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "<", "\n\t\t\t", "\n\t\t\t", "小于运算符", "\n\t\t\t", "\n\t\t\t", "表达式<表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "<=", "\n\t\t\t", "\n\t\t\t", "小于等于运算符", "\n\t\t\t", "\n\t\t\t", "表达式<=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "7", "\n\t\t\t", "\n\t\t\t", "==", "\n\t\t\t", "\n\t\t\t", "等于运算符", "\n\t\t\t", "\n\t\t\t", "表达式==表达式", "\n\t\t\t", "左结合性", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "!=", "\n\t\t\t", "\n\t\t\t", "不等于运算符", "\n\t\t\t", "\n\t\t\t", "表达式!=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "8", "\n\t\t\t", "\n\t\t\t", "&", "\n\t\t\t", "\n\t\t\t", "按位与运算符", "\n\t\t\t", "\n\t\t\t", "整型表达式&整型表达式", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "9", "\n\t\t\t", "\n\t\t\t", "^", "\n\t\t\t", "\n\t\t\t", "按位异或运算符", "\n\t\t\t", "\n\t\t\t", "整型表达式^整型表达式", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "10", "\n\t\t\t", "\n\t\t\t", "|", "\n\t\t\t", "\n\t\t\t", "按位或运算符", "\n\t\t\t", "\n\t\t\t", "整型表达式|整型表达式", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "11", "\n\t\t\t", "\n\t\t\t", "&&", "\n\t\t\t", "\n\t\t\t", "逻辑与运算符", "\n\t\t\t", "\n\t\t\t", "表达式&&表达式", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "12", "\n\t\t\t", "\n\t\t\t", "||", "\n\t\t\t", "\n\t\t\t", "逻辑或运算符", "\n\t\t\t", "\n\t\t\t", "表达式||表达式", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "13", "\n\t\t\t", "\n\t\t\t", "?:", "\n\t\t\t", "\n\t\t\t", "条件运算符", "\n\t\t\t", "\n\t\t\t", "表达式1?表达式2:表达式3", "\n\t\t\t", "\n\t\t\t", "右结合性", "\n\n\t\t\t", " ", "\n\t\t\t", "\n\t\t\t", "三目运算符", "\n\t\t\t", "\n\t\t\t", "14", "\n\t\t\t", "\n\t\t\t", "=", "\n\t\t\t", "\n\t\t\t", "赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量 = 表达式", "\n\t\t\t", "右结合性", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "/=", "\n\t\t\t", "\n\t\t\t", "除后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量 /=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "*=", "\n\t\t\t", "\n\t\t\t", "乘后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量 *=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "%=", "\n\t\t\t", "\n\t\t\t", "取模后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量%=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "+=", "\n\t\t\t", "\n\t\t\t", "加后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量+=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "-=", "\n\t\t\t", "\n\t\t\t", "减后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量-=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "<<=", "\n\t\t\t", "\n\t\t\t", "左移后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量<<=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", ">>=", "\n\t\t\t", "\n\t\t\t", "右移后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量>>=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "&=", "\n\t\t\t", "\n\t\t\t", "按位与后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量&=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "^=", "\n\t\t\t", "\n\t\t\t", "按位异或后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量^=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "|=", "\n\t\t\t", "\n\t\t\t", "按位或后赋值运算符", "\n\t\t\t", "\n\t\t\t", "变量|=表达式", "\n\t\t\t", "\n\t\t\t", "双目运算符", "\n\t\t\t", "\n\t\t\t", "15", "\n\t\t\t", "\n\t\t\t", ",", "\n\t\t\t", "\n\t\t\t", "逗号运算符", "\n\t\t\t", "\n\t\t\t", "表达式,表达式,表达式,...", "\n\t\t\t", "\n\t\t\t", "左结合性", "\n\t\t\t", " ", "\n\n", "运算符", "\n\n", "在一个表达式中可能包含多个有不同运算符连接起来的或具有不同数据类型的数据对象，表达式有多种运算，不同的结合顺序可能得出不同结果或者出现运算错误，因为当表达式中含多种运算时，必须按一定顺序进行结合，才能保证运算的合理性和结果的正确性和唯一性。", "\n\n", "每种同类型的运算符都有内部的运算符优先级，不同类型的运算符之间也有相应的优先级顺序。一个表达式中既可以包括相同类型的运算符，也可以包括不同类型的运算符或者函数。当多种运算符出现在同一个表达式中时，应该先按照不同类型运算符间的优先级进行运算。可以用括号改变优先级顺序，使得括号内的运算优先于括号外的运算。对于多重括号，总是由内到外强制表达式的某些部分优先运行。括号内的运算总是最优先计算。", "\n\n", "优先级", "\n\n", "优先级与求值顺序无关。优先级高低从上到下依次递减，表达式的结合次序取决于表达式中各种运算符的优先级。优先级高的运算符先结合，优先级低的运算符后结合，同一行中的运算符的优先级相同。", "\n\n", "结合性", "\n\n", "当一个运算对象两侧的运算符优先级别相同时，则按运算符的结合性来确定表达式的运算顺序。大多数运算符结合方向是左结合性，只有三类运算符的结合方向是右结合性，即：单目运算符、条件运算符、赋值运算符。结合性是针对两个相邻的优先级相同的运算符而言，而不是表达中的运算对象，运算符是决定左右的基准点，先以前面的运算符构造运算，就是左结合性，反之，就是右结合性 。", "\n\n", "操作数", "\n\n", "运算符是一种特殊的函数，它们具有一个或多个操作数并返回相应的值。运算符可以是一目、二目或三目的，有多少目就代表有多少个操作数。只有一个运算符的操作数是三目运算符，即：条件运算符。"]], "Tag": "程序设计"}
