{"Answer": "```\r\nclass Teacher\r\n{\r\npirvate:\r\nint num;\r\nstring name;\r\nchar sex;\r\npublic:\r\nvoid set(int n, string na, char s) { num = n; name = na; sex = s; }\r\nvoid show() { cout &lt;&lt; num &lt;&lt; name &lt;&lt; sex; }\r\n};\r\nclass BirthDate\r\n{\r\nprivate:\r\nint year;\r\nint month;\r\nint day;\r\npublic:\r\nvoid set(int y, int m, int d) { year = y; month = m; day = d; }\r\nvoid show() { cout &lt;&lt; year &lt;&lt; month &lt;&lt; day; }\r\n};\r\nclass Professor:public Teacher\r\n{\r\npublic:\r\nvoid setbd(int y, int m, int d) { birthday.set(y,m,d); }\r\nvoid show() { Teacher::show(); birthday.show(); }\r\nprivate:\r\nBirthDate birthday;\r\n};\r\nint main()\r\n{\r\nProfessor prof1;\r\nprof1.set(1, \"p1\", 1);\r\nprof1.serbd(1990,1,1);\r\nprof1.show();\r\n}\r\n```", "Konwledge_Point": "组合与继承", "Question": ["派生类继承和组合问题，有大佬帮忙解决一下吗", ["对于组合问题不是很懂", "\n继承和组合的关系：声明Professor(教授）类是Teacher（教师）类的派生类（继承关系），另有一个类BirthDate（生日）类，Professor类有一个生日数据（组合关系）。", "\n\n", "在定义Professor类对象prof1时给出所有数据的初值，然后修改prof1的生日数据，最后输出prof1的全部最新数据，其余成员随意设计", "\n\n", "class Teacher", "\n\n", "{", "\n\n", "public:", "\n\n", "pirvate:", "\n\n", "int num;\nstring name;\nchar sex;\n", "\n\n", "};", "\n\n", "class BirthDate", "\n\n", "{", "\n\n", "public:", "\n\n", "private:", "\n\n", "int year;\nint month;\nint day;\n", "\n\n", "};", "\n\n", "class Professor:public Teacher", "\n\n", "{", "\n\n", "public:", "\n\n", "private:", "\n\n", "BirthDate birthday;\n", "\n\n", "};"]], "Tag": "程序设计"}
{"Answer": "编译时和运行时区别的应该就是多态的原理吧，编译时是基类的，运行时就是用的导出类的吧。我是这么想的。", "Konwledge_Point": "组合与继承", "Question": ["研究继承和组合时查到一句话不是很懂", ["在继承中，导出类从基类继承的方法在编译期间就已经确定，无法在运行期间改变从基类继承的方法的行为。", "\n这句话具体意思是什么，不是所有的类的方法都是在编译期间确定的吗，运行期间方法的行为是可以改变的？各位大神能不能给解释一下。"]], "Tag": "程序设计"}
{"Answer": "具体解释看我加的代码注释:\r\n\r\n\r\n&lt;script type=\"text/javascript\"&gt;\r\n function Base(){\r\n \tthis.name = \"base\";\r\n\tthis.age = 25;\r\n\tthis.sayName = function(){alert(this.name);};\r\n }\r\n Base.prototype.sayAge = function(){alert(this.age)};\r\n \r\n \r\n function Extend(){\r\n \t\r\n \t\r\n \t/* \r\n \t\t此处是将Base()当成一个普通的函数来调用，而不是把它当做父类的构造函数；\r\n \t\tBase.call(this);实际是将Extend的作用域指定给Base()函数，也就是给Extend动态添加了两个成员变量（属性），name和age；\r\n \t\t而并没有进行任何关于原型方面的操作，没有构成原型链。\r\n \t\t这种继承方法叫做“借用构造函数”。 \t\r\n \t*/\r\n \tBase.call(this);\r\n\t\r\n\tthis.name = \"extend\";\r\n }\r\n\r\n // (1)\r\n // Extend.prototype = new Base();\r\n \r\n var e = new Extend();\r\n var b = new Base();\r\n \r\n \r\n e.sayName();  //正常。“extend”\r\n \r\n /* \r\n\t由于没有来自于Base()的原型继承，自然找不到原型中定义的sayAge。\r\n\t如果想要同样实现原型的继承，需要在var e = new Extend();之前将Extend()的原型指定为Base()类型的实例，即在（1）处加上：\r\n\t\r\n\tExtend.prototype = new Base();\r\n\t\r\n\t这就构成了原型链，与“借用构造函数”共同构成了“组合继承”，也称为“伪经典继承”。\t\r\n*/\r\n //e.sayAge();\r\n \r\n b.sayAge(); \r\n b.sayName();\r\n&lt;/script&gt;\r\n\r\n\r\n伪经典继承，也不是最完美的继承方式，更理想的是使用“寄生组合式继承”。具体的内容推荐阅读《JavaScript高级程序设计（第2版）》。", "Konwledge_Point": "组合与继承", "Question": ["关于js里利用call继承的一点疑惑，头疼！", ["      我在网上看到call的用法时，他这样写道：", "     “应用call和apply更有一个技巧在里面，就是用call和apply应用另一个函数（类）以后，当前的函数（类）就具有了另一个函数（类）的方法或是属性，这也能称之为“继承”。”", "      ", "      于是我用下面的这段代码做了实验：得出了下面结论：", "\n", "1、确实能够起到继承的作用。", "\n", "2、给原型里添加的属性和方法为什么继承不到？", "\n", "      第二点我百思不得其解，希望哪位高高手帮我解答下。以下便是我实验代码：", "<script type=\"text/javascript\">", "\n function Base(){", "\n    this.name = \"base\";", "\n    this.age = 25;", "\n    this.sayName = function(){alert(this.name);};", "\n }", "\n Base.prototype.sayAge = function(){alert(this.age)};\n\n", "function Extend(){", "\n    //继承", "\n    Base.call(this);", "\n    //覆盖", "\n    this.name = \"extend\";", "\n }", "\n\n", "var e = new Extend();", "\n var b = new Base();", "\n\n", "e.sayName();  //正常。“extend”", "\n //e.sayAge(); //会报错。", "\n b.sayAge();   //正常。", "\n b.sayName();  //正常。", "\n</script>", "问题补充", "    昨天晚上回去看了下《JavaScript高级程序设计（第2版）》，正巧是你推荐的那本。自认为弄懂了个大概，今日看兄台所写，觉得我有必要再看一次。", "    因为我昨天也看到了“组合继承模式”就是“原型继承模式”和“构造函数继承模式”的组合（不知对否？），却没联想到这上面来。", "    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我有个实现简单计算机的程序&amp;#xff0c;跟你的需求一样的。&lt;/p&gt;", "Konwledge_Point": "组合与继承", "Question": ["使用Swing组件设计图形界面程序；", [" 使 用继承、组合方法设计图形界面程序（1）设计一个包含四则运算的图形界面程序；（2）内容包含2个输入文本框、1个输出文本框、加减乘除四个事件按钮及一个清空按钮。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;类继承和对象组合是面向对象编程中两种重要的代码复用机制。它们各自有不同的应用场景&amp;#xff0c;下面分别介绍。&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;类继承的应用场景&lt;/li&gt;&lt;/ol&gt;\n&lt;ul&gt;&lt;li&gt;&lt;p&gt;类继承是一种创建新类的机制&amp;#xff0c;通过继承现有类的属性和方法&amp;#xff0c;派生出新的类。通常情况下&amp;#xff0c;子类会继承父类的所有属性和方法&amp;#xff0c;并可以在此基础上增加新的属性和方法&amp;#xff0c;或者重写父类的方法&amp;#xff0c;实现不同的行为。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;类继承的主要应用场景是&amp;#xff1a;当多个类具有相同的属性和行为时&amp;#xff0c;可以将这些共性提取出来&amp;#xff0c;封装成一个父类&amp;#xff0c;让所有子类继承它。这样&amp;#xff0c;就可以实现代码的复用&amp;#xff0c;避免重复编写相同的代码&amp;#xff0c;同时也方便后期的扩展和维护。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;举例来说&amp;#xff0c;假设我们有一个图形类 Shape&amp;#xff0c;其中包含了所有图形的公共属性和方法&amp;#xff08;如位置、颜色、面积、周长等&amp;#xff09;。然后我们再创建三个子类 Circle、Rectangle 和 Triangle&amp;#xff0c;它们都继承自 Shape 类&amp;#xff0c;并在此基础上增加了各自独有的属性和方法。这样&amp;#xff0c;我们就可以在不重复编写公共代码的情况下&amp;#xff0c;创建多种不同的图形对象。&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;ol start=\"2\"&gt;&lt;li&gt;对象组合的应用场景&lt;/li&gt;&lt;/ol&gt;\n&lt;ul&gt;&lt;li&gt;&lt;p&gt;对象组合是一种将多个不同的对象组合在一起&amp;#xff0c;创建出新的对象的机制。在对象组合中&amp;#xff0c;一个对象可以包含多个其他对象&amp;#xff0c;这些对象可以是不同类的对象&amp;#xff0c;也可以是同一类的对象。通过对象组合&amp;#xff0c;可以实现更灵活的代码复用。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;对象组合的主要应用场景是&amp;#xff1a;当一个对象需要拥有另一个对象的功能时&amp;#xff0c;可以将该对象作为成员变量嵌入到当前对象中&amp;#xff0c;从而实现复合对象的功能。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;举例来说&amp;#xff0c;假设我们有一个机器人类 Robot&amp;#xff0c;其中包含了机器人的基本属性和方法&amp;#xff08;如移动、旋转、攻击等&amp;#xff09;。然后我们再创建一个武器类 Weapon&amp;#xff0c;它也有自己的属性和方法&amp;#xff08;如攻击力、射程、消耗等&amp;#xff09;。接着&amp;#xff0c;我们将 Weapon 对象作为 Robot 类的成员变量&amp;#xff0c;将武器嵌入到机器人中。这样&amp;#xff0c;我们就可以实现一个具备攻击能力的机器人&amp;#xff0c;它可以使用武器来攻击敌人。&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "组合与继承", "Question": ["类继承和对象组合的应用场景", ["类继承的应用场景，和对象组合的应用场景。类继承和对象组合的应用场景"]], "Tag": "程序设计"}
{"Answer": "不同的名称\r\n不同的参数\r\n增加警报器属性。\r\n随便一种", "Konwledge_Point": "组合与继承", "Question": ["java 不能在继承某个类的同时实现某个接口", ["如果 Door 类存在 open();（打开门）方法。 Alarm 接口存在 open();（打开警报）方法。现在要写一个 AlarmDoor 类，该类继承 Door 类，并实现 Alarm 接口。那么又如何在 AlarmDoor 类中将 Alarm 的 open 方法和 Door 的 open 方法进行区别。", "\n[b]问题补充：[/b]", "\n我要对 Door 和 Alarm 只能使用，不能修改呢？", "\n[b]问题补充：[/b]", "\n组合啊~~~", "\n只能这样以丧失“多态”来实现了么？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;the signature of &lt;code&gt;Handle&lt;/code&gt; has to be exactly &lt;code&gt;func (ch HelloWorldCommandHandler) Handle(cmd Command) {&lt;/code&gt; to implement the interface.\nA quick fix would be to do a &lt;a href=\"https://golang.org/ref/spec#Type_assertions\" rel=\"nofollow\"&gt;type assertion&lt;/a&gt; at the beginning of your &lt;code&gt;Handle&lt;/code&gt; function to get the &lt;code&gt;HelloWorldCommand&lt;/code&gt; from your &lt;code&gt;Command&lt;/code&gt;)&lt;/p&gt;\n\n&lt;p&gt;But I think this might be a symptom of a possible design issue: if the polymorphism is on &lt;code&gt;Command&lt;/code&gt;, maybe command should handle/run itself? maybe with a &lt;code&gt;Run() error&lt;/code&gt; in the interface?&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "组合与继承", "Question": ["如何通过Golang的组合继承将Command调度到正确的Command Handler？", ["\n\n", "I want to learn to program in Go, I decided as a pet program I would do a simple dispatcher of different Commands to several CommandHandler (if the CommandHandler has the same name as the Command it should handle.)", "\n\n", "My problem is when I want to have a CommandHandlerManager that publishes a Commands that would be dispatch to the correct CommandHandler, it tells me that I need to have a concrete implementation of my HelloWorldCommand because HelloWorldCommandHandler doesn't implement the interface of Command.", "\n\n", "Error message at compilation", "\n\n", "E:\\Desktop\\ManBear\\golang\\src>go run main.go\n# command-line-arguments\n.\\main.go:71: cannot use cmdHandler (type HelloWorldCommandHandler) as type CommandHandler in array or slice literal:\n        HelloWorldCommandHandler does not implement CommandHandler (wrong type for Handle method)\n                have Handle(HelloWorldCommand)\n                want Handle(Command)\n", "\n\n", "I would need that someone explains the me what I'm doing wrong, I guessed it meant that I should implement an alone ", "func", " method to my HelloWorldCommandHandler for the interface alone like below:", "\n\n", "func (ch HelloWorldCommandHandler) Handle(cmd Command) {\n    fmt.Println(\"HelloWorldCommandHandler handled the basic command with name --> \" + cmd.GetName())\n}\n", "\n\n", "But it created more type-related errors.", "\n\n", "A working example of what I'm trying to do with an explanation of how and why I'm doing it wrong would be appreciated.", "\n\n", "Thank you.", "\n\n", "Here's my code:", "\n\n", "package main \n\nimport (\n    \"fmt\"\n    \"strconv\"\n)\n\n\ntype Command interface {\n    GetName() string\n}\n\n\ntype CommandHandler interface {\n    Command\n    Handle(cmd Command)\n}\n\n\ntype HelloWorldCommand struct {\n    Command\n    Name string\n    Age int\n}\n\nfunc (cmd HelloWorldCommand) GetName() string {\n    return \"HelloWorldCommand\"\n}\n\n\ntype HelloWorldCommandHandler struct {\n    CommandHandler\n}\n\nfunc (cmd HelloWorldCommandHandler) GetName() string {\n    return \"HelloWorldCommand\"\n}\n\nfunc (ch HelloWorldCommandHandler) Handle(cmd HelloWorldCommand) {\n    fmt.Println(\"Hello World! My name is \" + cmd.Name + \" and I'm \" + strconv.Itoa(cmd.Age) + \" years old!\")\n}\n\ntype CommandHandlerManager struct {\n    CommandHandlers []CommandHandler\n}\n\nfunc (chm CommandHandlerManager) Publish(cmd Command) {\n\n    for _, cmdHandler := range chm.CommandHandlers {\n        if cmd.GetName() == cmdHandler.GetName() {\n            cmdHandler.Handle(cmd)\n        }\n    }\n}\n\n\nfunc main() {\n\n    fmt.Println(\"Hey my friend!\")\n\n    cmd := HelloWorldCommand {Name: \"ManBear\", Age: 357}\n    cmdHandler := HelloWorldCommandHandler {}\n\n    fmt.Println(cmd.GetName())\n    fmt.Println(cmdHandler.GetName())\n\n    cmdHandler.Handle(cmd)\n\n    cmdHandlerManager := CommandHandlerManager { \n        CommandHandlers: []CommandHandler { \n            cmdHandler, // <-- the error is here \n        },\n    };\n}\n", "\n\n", "UPDATE:", "\n\n", "For the curious, here is a functionning version of my pet program", "\n\n", "Thanks to the help of ", "Dean Elbaz", " by suggesting to use the type assertion, it makes it possible to handle a Command by it correct CommandHandler and use the correct set of values that comes with each Command. ", "\n\n", "package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"time\"\n)\n\n\ntype Command interface {\n    GetName() string\n}\n\n\ntype CommandHandler interface {\n    Command\n    Handle(cmd Command)\n}\n\nconst HelloWorldCommandName string = \"HelloWorldCommand\"\n\ntype HelloWorldCommand struct {\n    Command\n    Name string\n    Age int\n}\n\nfunc (cmd HelloWorldCommand) GetName() string {\n    return HelloWorldCommandName\n}\n\n// Basic Hello World\ntype HelloWorldCommandHandler struct {\n    CommandHandler\n}\n\nfunc (cmd HelloWorldCommandHandler) GetName() string {\n    return HelloWorldCommandName\n}\n\nfunc (ch HelloWorldCommandHandler) Handle(cmd Command) {\n    fmt.Println(\"Hello World!\n----------------------------------------\n\")\n}\n\n// Hello World with Name and Age\ntype HelloWorldWithNameAndAgeCommandHandler struct {\n    CommandHandler\n}\n\nfunc (cmd HelloWorldWithNameAndAgeCommandHandler) GetName() string {\n    return HelloWorldCommandName\n}\n\nfunc (ch HelloWorldWithNameAndAgeCommandHandler) Handle(cmd Command) {\n    var helloWorldCommand HelloWorldCommand = cmd.(HelloWorldCommand)\n    fmt.Println(\"Hello World! My name is \" + helloWorldCommand.Name + \" and I'm \" + strconv.Itoa(helloWorldCommand.Age) + \" years old!\n----------------------------------------\n\")\n}\n\n\nconst TodayDateTimeCommandName string = \"TodayDateTimeCommand\"\n\n// Today's DateTime Command\ntype TodayDateTimeCommand struct {\n    Command\n    TimeZone string\n}\n\nfunc (cmd TodayDateTimeCommand) GetName() string {\n    return TodayDateTimeCommandName\n}\n\n\ntype TodayDateTimeCommandHandler struct {\n\n}\n\nfunc (ch TodayDateTimeCommandHandler) GetName() string {\n    return TodayDateTimeCommandName\n}\n\nfunc (ch TodayDateTimeCommandHandler) Handle(cmd Command) {\n    var todayCommand TodayDateTimeCommand = cmd.(TodayDateTimeCommand)\n    location, err := time.LoadLocation(todayCommand.TimeZone)\n    if err != nil {\n        fmt.Errorf(\"Could not load the Location of the TimeZone. %f\", err.Error())\n        return\n    }\n    current_time := time.Now().In(location)\n    fmt.Println(\"Today's date and time is \" + current_time.String() + \" for the time zone: \" + todayCommand.TimeZone)\n}\n\n\n// The CommandHandler Manager\ntype CommandHandlerManager struct {\n    CommandHandlers []CommandHandler\n}\n\nfunc (chm CommandHandlerManager) Publish(cmd Command) {\n\n    for _, cmdHandler := range chm.CommandHandlers {\n        if cmd.GetName() == cmdHandler.GetName() {\n            cmdHandler.Handle(cmd)\n        }\n    }\n}\n\n\nfunc main() {\n\n    fmt.Println(\"Hey my friend!\n\n\n\")\n\n    cmdHandlerManager := CommandHandlerManager {\n        CommandHandlers: []CommandHandler {\n            HelloWorldCommandHandler {},\n            HelloWorldWithNameAndAgeCommandHandler {},\n            TodayDateTimeCommandHandler {},\n        },\n    };\n\n    cmd := HelloWorldCommand {Name: \"ManBear\", Age: 357}\n    cmdHandlerManager.Publish(cmd)\n\n    fmt.Println(\"~~~~~~~~ other command published ~~~~~~~~~~~~~~~~~~~~~\")\n    cmd2 := TodayDateTimeCommand{ TimeZone: \"America/Montreal\" }\n    cmdHandlerManager.Publish(cmd2)\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;public class Circle {&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    private double radius;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public Circle(double radius){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        this.radius &amp;#61; radius;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public double getArea(){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        return Math.PI * radius * radius;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;public class Ring {&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    private Circle large;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    private Circle small;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public Ring(Circle large,Circle small) throws Exception {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        if(large.getArea()&amp;lt;small.getArea()) throw new Exception(&amp;#34;The area of a large circle is smaller than that of a small circle&amp;#34;);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        this.large &amp;#61; large;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        this.small &amp;#61; small;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public double getArea(){&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        return large.getArea() - small.getArea();&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    /**&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     * 测试方法 声明一个大圆一个小圆&amp;#xff0c;将其组合成一个圆环&amp;#xff0c;求圆环面积&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     * &lt;a class=\"md_call_user\" type=\"user\"&gt;&amp;#64;param &lt;/a&gt;args&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     * &lt;a class=\"md_call_user\" type=\"user\"&gt;&amp;#64;throws &lt;/a&gt;Exception&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;     */&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    public static void main(String[] args) throws Exception {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        Circle l &amp;#61; new Circle(10);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        Circle s &amp;#61; new Circle(5);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        Ring r &amp;#61; new Ring(l,s);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        System.out.println(r.getArea());&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "组合与继承", "Question": ["如何使用组合的方法编写一个计算圆环面积的Java程序？", ["使用组合的方法编写一个计算圆环面积的Java程序。要求：先设计一个圆形类Circle，再基于类Circle使用组合的方法定义一个圆环类Ring。圆环可认为是由一大一小两个同心圆组合而成。最后编写一个测试类测试所编写的圆环类Ring。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt; \n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt;&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Person{\n    public:\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; name;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; sex;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; zz;\n        &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; zw;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; wages;\n        &lt;span class=\"hljs-constructor\"&gt;Person(&lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;z1&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;w1&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;)&lt;/span&gt;{\n            name&amp;#61;n;\n            sex&amp;#61;s;\n            zz&amp;#61;z1;\n            zw&amp;#61;w1;\n            wages&amp;#61;w;\n        }\n        ~&lt;span class=\"hljs-constructor\"&gt;Person()&lt;/span&gt;{}\n};\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Date{\n    public:\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; year;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; month;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; day;\n        &lt;span class=\"hljs-constructor\"&gt;Date()&lt;/span&gt;{year&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            month&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            day&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;}\n        &lt;span class=\"hljs-constructor\"&gt;Date(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;m&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;d&lt;/span&gt;)&lt;/span&gt;{\n            year&amp;#61;y;\n            month&amp;#61;m;\n            day&amp;#61;d;\n        }\n};\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Worker:public Person{\n    public:\n        Date b;\n    public:\n        &lt;span class=\"hljs-constructor\"&gt;Worker(&lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;z&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;w2&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;)&lt;/span&gt;\n            :&lt;span class=\"hljs-constructor\"&gt;Person(&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;s&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;z&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;w2&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;w&lt;/span&gt;)&lt;/span&gt;\n        {\n\n            \n        }\n        void display( ){\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl;\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;出生日期&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b.year&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b.month&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b.day&amp;lt;&amp;lt;endl;\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;性别&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;sex&amp;lt;&amp;lt;endl;\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;工作总站&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;zz&amp;lt;&amp;lt;endl;\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;职务&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;zw&amp;lt;&amp;lt;endl;\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;工资&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;wages&amp;lt;&amp;lt;endl;\n        }\n};\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main( ){\n    Worker aa(&lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;杨萍&amp;#34;&lt;/span&gt;),&lt;span class=\"hljs-string\"&gt;&amp;#34;女&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;团委&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;团委书记&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6000&lt;/span&gt;);\n    aa.b &amp;#61; &lt;span class=\"hljs-constructor\"&gt;Date(2000,6,6)&lt;/span&gt;;\n    aa.display( );\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "组合与继承", "Question": ["C++报错多，类的组合相关概念不太懂。", ["题目要求：", "设计职员类，它继承了Person类并组合了Date类。编写主程序显示职员数据如下：", "姓名：杨萍", "出生日期：1988.10.6", "性别：女", "工作总站：团委", "职务：团委书记", "工资：6000", "\n", "\n#", "include", "<iostream>\nusing namespace std;\n", "class", " Person{\n    public:\n        ", "string", " name;\n        ", "char", " sex;\n        ", "string", " zz;\n        ", "string", " zw;\n        ", "int", " wages;\n        ", "Person(", "string", " ", "n", ", ", "char", " ", "s", ", ", "string", " ", "z1", ",", "string", " ", "w1", ", ", "int", " ", "w", ")", "{\n            name=n;\n            sex=s;\n            zz=z1;\n            zw=w1;\n            wages=w;\n        }\n};\n", "class", " Date{\n    public:\n        ", "int", " year;\n        ", "int", " month;\n        ", "int", " day;\n        ", "Date(", "int", " ", "y", ", ", "int", " ", "m", ", ", "int", " ", "d", ")", "{\n            year=y;\n            month=m;\n            day=d;\n        }\n};\n", "class", " Worker:public Person{\n    public:\n        Date b(", "2000", ",", "6", ",", "6", ");\n        ", "Worker(", "string", " ", "n", ", ", "char", " ", "s", ", ", "string", " ", "z", ", ", "string", " ", "w2", ", ", "int", " ", "w", ")", "：", "Person(", "n", ",", "s", ",", "z", ",", "w2", ",", "w", ")", "{\n            ;}\n        void display( ){\n            cout<<", "\"姓名：\"", "<<name<<endl;\n            cout<<", "\"出生日期：\"", "<<b.year<<", "\".\"", "<<b.month<<", "\".\"", "<<b.day<<endl;\n            cout<<", "\"性别：\"", "<<sex<<endl;\n            cout<<", "\"工作总站：\"", "<<zz<<endl;\n            cout<<", "\"职务：\"", "<<zw<<endl;\n            cout<<", "\"工资：\"", "<<wages<<endl;\n        }\n};\n", "int", " main( ){\n    Worker aa(", "\"杨萍\"", ",", "\"女\"", ",", "\"团委\"", ",", "\"团委书记\"", ",", "6000", ");\n    aa.display( );\n    return ", "0", ";\n    \n}\n", "\n", "报错多，对类的组合不太理解，帮我看一看"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/shineflowers/article/details/50264589", "Konwledge_Point": "组合与继承", "Question": ["android studio自定义标题报错：您不能将自定义标题与其他标题功能组合在一起", ["问题描述：", "\n小弟下载了网上的一段代码，具体内容无关，eclipse代码转移到android studio上。", "\n       requestWindowFeature(Window.FEATURE_CUSTOM_TITLE);", "\n        setContentView(R.layout.main);", "\n        getWindow().setFeatureInt(Window.FEATURE_CUSTOM_TITLE, R.layout.custom_title);", "\n这三行是用于更改界面标题的经典做法，我继承了Activity类，在manifest文件中自定义了theme为一个简易style，然后又在layout内写了一个名为上面三行第三行中的custom-title的xml文件，最后程序报错You cannot combine custom titles with other title features（用了log日志显示在第二行挂了）", "\n\n", "问题分析：小弟根据网上的意见各种改，但是想来想去这种更改标题栏的方式一点问题没有，为什么一直报我重复定义的错？先是manifest定义一个基本框架theme，然后再setcontent主界面，再将标题栏的xml文件加载进去emmmmm 。按照错误提示我是多定义了一次标题，但这三句是主程序里oncreat的初始部分，报错就说明我manifest里面有问题？可我又是自定义theme", "\n\n", "我用的最低API11，目标25，网上有说这种更改标题栏方式必须降到11以下才行，那这样我就得下个新的SDK。也有说法是继承APPcompatactivity用别的方式就ok了。", "\n\n", "是否有哪位大佬曾经在android studio下更改标题栏遇到过类似问题，小弟在此求解，万分感谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;包括了10条全部要求&amp;#xff0c;代码如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Answer7718218&lt;/span&gt; {\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;[] args&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;Person&lt;/span&gt; person &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;小李&amp;#34;&lt;/span&gt;);\n        person.&lt;span class=\"hljs-title function_\"&gt;doWork&lt;/span&gt;();\n        person.&lt;span class=\"hljs-title function_\"&gt;eat&lt;/span&gt;();\n        &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; student &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;);\n        student.&lt;span class=\"hljs-title function_\"&gt;doWork&lt;/span&gt;();\n        student.&lt;span class=\"hljs-title function_\"&gt;eat&lt;/span&gt;();\n        student.&lt;span class=\"hljs-title function_\"&gt;sleep&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        student.&lt;span class=\"hljs-title function_\"&gt;sleep&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n        student.&lt;span class=\"hljs-title function_\"&gt;sleep&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    }\n}\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Work&lt;/span&gt; {\n\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; name;\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person&lt;/span&gt;() {\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person&lt;/span&gt;(&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; name) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;name&lt;/span&gt; &amp;#61; name;\n    }\n\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;doWork&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;这是Person的work&amp;#34;&lt;/span&gt;);\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; final &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;eat&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;我在吃饭&amp;#34;&lt;/span&gt;);\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getName&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; name;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setName&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; name&lt;/span&gt;) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;name&lt;/span&gt; &amp;#61; name;\n    }\n}\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title class_ inherited__\"&gt;Person&lt;/span&gt; {\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 学号\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; stuNo;\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;() {\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;(&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; stuNo) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;stuNo&lt;/span&gt; &amp;#61; stuNo;\n    }\n\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;doWork&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;这是Studen的work&amp;#34;&lt;/span&gt;);\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;sleep&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;int count&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt; (count) {\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n                &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;sleep 1&amp;#34;&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; &amp;#43;&amp;#43;i) {\n                    &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;循环:&amp;#34;&lt;/span&gt; &amp;#43; i);\n                }\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n                &lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt; {\n                    &lt;span class=\"hljs-keyword\"&gt;throw&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;MyException&lt;/span&gt;();\n                } &lt;span class=\"hljs-keyword\"&gt;catch&lt;/span&gt; (&lt;span class=\"hljs-title class_\"&gt;Exception&lt;/span&gt; e) {\n                    &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;捕捉了异常&amp;#34;&lt;/span&gt;);\n                }\n        }\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getStuNo&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; stuNo;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setStuNo&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; stuNo&lt;/span&gt;) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;stuNo&lt;/span&gt; &amp;#61; stuNo;\n    }\n}\n\n&lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; Work {\n\n    &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;doWork&lt;/span&gt;();\n}\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;MyException&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title class_ inherited__\"&gt;Exception&lt;/span&gt; {\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;这是Person的work\n我在吃饭\n这是Studen的work\n我在吃饭\nsleep 1\n&lt;span class=\"hljs-section\"&gt;循环:0&lt;/span&gt;\n&lt;span class=\"hljs-section\"&gt;循环:1&lt;/span&gt;\n&lt;span class=\"hljs-section\"&gt;循环:2&lt;/span&gt;\n捕捉了异常\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请采纳&amp;#xff0c;十分感谢&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "组合与继承", "Question": ["任选五个组合，随意就可以了，能实现就可以", ["1)包含类的封装，get/set方法 。", "2)包含构造方法和构造方法的重载。", "3)包含继承,方法重写。", "4)包含抽象类和接口。", "5)包含异常处理机制。", "6)包含自定义异常。", "7)包含super, finalI关键字 。", "8)包含多态。", "9)包含4个字符串处理方法。", "10)包含选择语句和循环语句。"]], "Tag": "程序设计"}
{"Answer": "1. 强制性类型转换就是为了方便staff[1] 来调用子类中的某些方法，为什么这里会出现这么个判断，staff[1]本来就属于Manager啊，这个判断铁定是错的啊。\r\n\r\n这个地方所说的场景很广泛，并非指的是已知类型，比如在Android中就有很多获取View的,需要通过强制转换来实现,但那会你已经知道转换不会出错,因此可以不用判断,而在部分你不知道转换是否会异常的时候，就需要instanceof来进行判断.\r\n\r\n2.上面这个一段话中提到一个捕获异常，都出现异常了，程序肯定会终止，并且出现问题啊，为什么会说如果没有捕获这个异常，那么程序就会终止呢？ 没有办法理解。\r\n\r\nJava里面有一种异常是需要程序员主动处理的，比如\r\n\r\n\r\n```\r\n File file = new File(\"d:/temp\", \"addfile.txt\");  \r\n        try {  \r\n            file.createNewFile(); // 创建文件  \r\n        } catch (IOException e) {  \r\n            // TODO Auto-generated catch block  \r\n            e.printStackTrace();  \r\n        } \r\n```\r\n\r\n这一段出现的IOException是一个文件操作异常，也就是说，try块里面的代码，可能导致这个异常,Java需要你提前捕获进行处理。\r\n\r\n有另外的异常是可以再捕获之后，程序不终止。", "Konwledge_Point": "组合与继承", "Question": ["强制性转换和instanceof 组合在一起的问题         Java核心技术卷一", [" package inheritance; \n //Manager类继承了Employee类 \n public class Manager extends Employee{ \n\n private double bonus; \n\n public Manager(String n, double s, int year, int month, int day){ \n //利用super关键词调用Employee类的构造器 \n super(n, s, year, month, day); \n bonus = 0;\n } \n //覆盖了Employee类中的getSalary方法 \n public double getSalary(){ \n //用super关键字调用Employee类的方法 \n double baseSalary = super.getSalary(); \n return baseSalary + bonus; \n } \n public void setBonus(double b){ \n bonus = b;\n } \n }\n\npackage inheritance; \nimport java.util.Date;\nimport java.util.GregorianCalendar\npublic class Employee { \nprivate String name; \nprivate double salary; \nprivate Date hireDay; \npublic Employee(String n,double s ,int year,int month,int day){\nname = n; \nsalary = s; \nGregorianCalendar calendar = new GregorianCalendar(year, month-1, day); hireDay = calendar.getTime(); \n} \n\npublic String getName(){ \nreturn name; \n} \npublic double getSalary(){ \nreturn salary; \n} \n\npublic Date getHireDay(){\nreturn hireDay; \n} http://ask.csdn.net/questions/648777#\n\npublic void raiseSalary(double byPercent){ \ndouble raise = salary * byPercent / 100; \nsalary += raise; \n} \n}\n\npublic static void main(String[] args){ \n//constrcut a Manager object \nManager boss = new Manager(\"Cracker\",80000,1988,12,15); boss.setBonus(5000); \nEmployee[] staff = new Employee[3]; //fill the staff arry with Manager and //Employee object \nstaff[0] = boss; \nstaff[1] = new Employee(\"Harry\",50000,1986,10,1); \nstaff[2] = new Employee(\"Tommy\",40000,1987,3,15); \n//print out information about all Employee objects \n//体现了多态与动态捆绑 \nfor(Employee e : staff) \nSystem.out.println(\"name:\" + e.getName() + \"，salary:\" + e.getSalary());\n}\n", "\n\n", "在书中，我看到一段话：", "\nManager boss = (Manager) staff[1];// Error", "\n行这个程序的时候，JAVA 运行时系统将报告这个错误，并产生一个ClassCastException异常。如果没有捕获这个异常，那么程序就会终止。因此应该养成一个良好的程序设计习惯： 在进行类型转换之前先查看一下是否能够成功的转换。这个过程简单地使用instanceof 运算符就可以实现。例如：", "\nif（staff[1] instanceof Manager）", "\n{", "\nboss =(Manager)staff [1];", "\n...", "\n}", "\n\n", "我有如下几个问题：", "\n1. 强制性类型转换就是为了方便staff[1] 来调用子类中的某些方法，为什么这里会出现这么个判断，staff[1]本来就属于Manager啊，这个判断铁定是错的啊。", "\n2.上面这个一段话中提到一个捕获异常，都出现异常了，程序肯定会终止，并且出现问题啊，为什么会说如果没有捕获这个异常，那么程序就会终止呢？ 没有办法理解。"]], "Tag": "程序设计"}
{"Answer": "设计模式里面到处是这种例子，比如策略模式（Strategy），它在你的主类中聚合了一个策略类，而不同的策咯则是继承策略类。而不是把策略的方法写在主类中，然后直接继承。\r\n再比如Proxy模式，把适配放在Proxy类中，等等。", "Konwledge_Point": "组合与继承", "Question": ["简答的来说‘合成复用原则’是什么意思？", [" 7、合成复用原则（Composite Reuse Principle）\n\n合成复用原则就是在一个新的对象里通过关联关系（组合关系、聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，尽量使用 组合/聚合 的方式，而不是使用继承。\n", "\n\n", "谁能举个栗子"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用JFrame&amp;#xff0c;JButton&amp;#xff0c;JTextField实现就可以了。&lt;/p&gt;", "Konwledge_Point": "组合与继承", "Question": ["使用swing组件编程", ["使用继承、组合方法设计图形界面程序（1）设计一个包含四则运算的图形界面程序；（2）内容包含2个输入文本框、1个输出文本框、加减乘除四个事件按钮及一个清空按钮。"]], "Tag": "程序设计"}
{"Answer": "[color=red][i]昏迷 Lz的意思 Dao有一个公用的接口是吧 。\r\n\r\n其实 设计Dao的时候 本来就是这用的 \r\n\r\n使用一个泛型就好了，因为一个Dao无非就是增删改查那些操作。\r\n\r\n如果某个Dao有特殊的要求，可以再具体写在自己的实现类里头，\r\n\r\n要不继承的Dao只要继承就够了，不用写方法。\r\n\r\n也就是说是一个空白的类 。\r\n\r\nEG：\r\n\r\n\r\npublic abstract class BaseDao&lt;T&gt;{\r\n    private EntityManage em;\r\n    public T save(T){\r\n        this.getEm().insert(T);\r\n    }\r\n\r\n    public void del(T){\r\n        this.getEm.delete(T);\r\n    }\r\n    \r\n    public T findByid(Class&lt;T&gt; clazz, Serializable id) {\r\n\tT t = em.find(clazz, id);\r\n\tif (t == null) {\r\n\t\tthrow new SpecException(\"\");\r\n\t}\r\n\treturn t;\r\n    }\r\n\r\n   ....\r\n}\r\n\r\n\r\npublic UrDaoImpl extends BaseDao&lt;UrEntity&gt;{\r\n\r\n   \r\n}\r\n\r\n\r\n这样的话，就可以直接的service里头用这个UrDaoImpl。\r\n\r\n你这种设计方法是合理的，一点都不会加深复杂。\r\n\r\nservice也是同一道理。 因为service也是一样的执行一些增删改查.\r\n\r\n可以把这些抽象出来，而调用的时候还是调用特定的Impl。\r\n\r\n根本不用去理会 这个公共的基类的存在 。\r\n\r\nOVER 。\r\n\r\n\r\n[/i][/color]", "Konwledge_Point": "组合与继承", "Question": ["CRM系统详细设计遇到了问题.....搞的我崩溃了..!", ["JAVA语言，SSH框架，开发工具MyEclipse6.0 ", "\n在设计BIZ包的接口的时候，发现有很多方法是可以公用的。所以就写了一个父类 ", "\n让BIZ包下所有的接口实现类都继承这个父类。 ", "\n\n", "在设计DAO接口的时候，也是有很多方法可以公用的，也写了一个父类。 ", "\n因为DAO是用Hibernate反向生成的，所有，我改了所有DAO的父类，让它们继承我自己写的那个DAO。 ", "\n\n", "设计到这里的时候，我想到了一个问题，因为BIZ包下的实现类继承了我写的那个BIZ基类 ", "\n所以，我在BIZ包下的实现类里调用DAO方法的时候，因为DAO里也继承了父类嘛， ", "\n这时候，程序的逻辑复杂程度加深了不少，但是省去了BIZ的重复代码。 ", "\n\n", "我想问的是，这样的设计，怎么样？ ", "\n有没有好点的建议？ ", "\n[b]问题补充：[/b]", "\n组合模式?", "\n2楼的师哥解释解释.."]], "Tag": "程序设计"}
{"Answer": "其实这样设计是为了降低类之间的耦合，\r\n你说的 那种抽象出来但是耦合性太大\r\n你可以看下jpa的现在设计,他的repository的设计的 就是体现出来了 \r\n\r\n\r\n现在大部分框架都是尽量低耦合的，你看下这个文章:\r\nhttp://www.cnblogs.com/tiwlin/archive/2010/02/24/1672459.html", "Konwledge_Point": "组合与继承", "Question": ["java web 项目，DAO层应该如何设计", ["公司的项目基本上一个domain就对应一个dao接口和一个实现daoImpl,可是我想了好一阵子都没想出这有什么好，我的想法是：domain继承于EntityBase，然后用一个dao，方法是通用增删改查方法和执行原生SQL语句的方法以及调用存储过程的方法等，参数用泛型，复杂的业务全部定义在service中，在service中组合dao里面的方法，就不用给每一个domain定义dao实现了，求过来人指点下"]], "Tag": "程序设计"}
{"Answer": "工厂模式是：定义一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到子类。\r\n它有个特点，就是通常工厂的类层次与产品的类层次几乎是一样的树。如果说工厂是你的影子，你就是产品了。在你平时未用到模式的时候，你需要什么就new一个，这种情况就好比你躺在地上，人影合一了。那什么时候需要工厂模式呢。看看定义：“使一个类的实例化延迟到子类”，这个是关键，当你有必要延迟实例化的时候才需要用工厂模式。那什么情况下要延迟呢，在单例模式中有惰性单例（就是单例那个静态属性）……等等，就是一开始你还不适合立刻就创建该对象，你还需要一些资源或其它准备工作。整个系统的运行不像单个程序那样，系统需要很多资源和多方面的协同工作。\r\n\r\n抽象工厂是：提供一个创建一系列相关或相互依赖对象的接口，而无虚指定他们的具体类。\r\n抽象工厂比工厂模式复杂的多。如果楼主说他们像可能是他们都叫工厂，都生成产品，都是接口型设计模式。但是我觉得他们是两个不同的设计模式。首先他们的目的是不同的。工厂是为了“延迟创建”，而抽象工厂是提供一系列的接口，是为了组织创建对象的灵活性，避免重复，避免耦合低内聚。\r\n设计模式本身语言晦涩难懂，这个抽象工厂我也是没次都看着头昏眼花^_^,举个运用他的场景：\r\n1。你有两台单色打印机，一台黑白墨的，一台彩墨的。\r\n2。你有两种文件要打，一种讲演搞，一种图片\r\n\r\n3。要求是讲演稿如果是有图就打黑白的，没图打彩色的，照片有字的就打黑白的，没字就打彩色的。\r\n\r\n\r\nclass Print{\r\n……\r\n    void doTalk(){\r\n       if(flag)\r\n           //color            1\r\n       else\r\n           //non-color        2\r\n   }\r\n\r\n   void doPicture(){\r\n       if(flag)\r\n          //color             3\r\n       else\r\n          //non-color         4\r\n   }\r\n……\r\n}\r\n\r\n\r\n上面的这个场景就是可以运用抽象工厂来重构的。\r\n\r\npublic abstract class AbsFactory{\r\n    abstract TalkPrint getTalkPrint(); //打讲演稿\r\n    abatract PicPrint getPicPrint();   //打图片的\r\n}\r\n\r\npublic class ColorFactory extends AbsFactory{\r\n    TalkPrint getTalkPrint(){\r\n       //彩色讲演稿打印\r\n    }\r\n\r\n    PicPrint getPicPrint(){\r\n       //彩色图片打印\r\n    }\r\n}\r\n\r\npublic class NonColorFactory extends AbsFactory{\r\n    TalkPrint getTalkPrint(){\r\n         //黑白讲演稿打印\r\n    }\r\n\r\n    PicPrint getPicPrint(){\r\n         //黑白图片打印\r\n    }  \r\n}\r\n\r\npublic abstract class TalkPrint{\r\n   //抽象的讲演稿打印\r\n}\r\n\r\npublic class colorTalkPrint extends TalkPrint{\r\n   //彩色讲演稿打印\r\n}\r\n\r\npublic class noncolorTalkPrint extends TalkPrint{\r\n   //黑白讲演稿打印\r\n}\r\n\r\npublic abstract class PicPrint{\r\n   //抽象的图片打印\r\n}\r\n\r\n\r\npublic class colorPicPrint extends PicPrint{\r\n   //彩色图片打印\r\n}\r\n\r\npublic class noncolorPicPrint extends PicPrint{\r\n   //黑白图片打印\r\n}\r\n\r\n进一步解释这个场景，就是当你做相似的工作又多种选择的时候，可以考虑用抽象工厂。\r\n\r\n这里你要打印各种文件是一组相似的工作，打印有彩色、黑白等针对打印的不同要求。\r\n\r\n\r\n这里仅仅举了一个方面的例子。\r\n\r\n我们可以看出，虽然抽象工厂和工厂在代码形式上很相似，甚至抽象工作可以有工厂来拓展，但是他们的出发点是不一样的。\r\n\r\n在搞单例模式的时候我们针对多线程拓展了为“双重检查模式”，那是同一个场景同一个任务，跟这里是不一样的。\r\n\r\n关于单例模式，我有笔记留在我的博客，欢迎大家来一起讨论：\r\n\r\nhttp://zhaipuhong.iteye.com/blog/214675", "Konwledge_Point": "组合与继承", "Question": ["工厂方法模式和抽象工厂模式的区别", ["看了一些网上的例子,头有点晕,感觉好象差不多,", "\n可能是我看的不够细,", "\n但是还是没办法理解这2钟模式的区别,", "\n和用在什么地方", "\n\n", "大家帮忙", "\n[b]问题补充：[/b]", "\n上面讲的是抽象工厂,我想知道他们的分别,我想要真正了解的人告诉我他的理解是什么,而不是网上GOOGLE,出来", "\n\n", "2楼说的在ioc中添加工厂有点不理解", "\n\n", "抽象工厂模式是让工厂和依赖工厂的子类全部依赖一个接口或者抽象类，因为抽象代表这稳定，这样可以很容易的遵循oo中比较著名的开放关闭原则，设计出来的系统、框架或者程序很富有弹性和扩展能力(这句话有点大概的意思,没有具体的)", "\n\n", "网上搜一句话,不知道对还是错", "\n其实这两者的区别，GOF的书上说得很清楚。工厂方法采用的是类继承机制（生成一个子类，重写该工厂方法，在该方法中生产一个对象）。而抽象工厂采用的是对象组合机制，专门定义“工厂”对象来负责对象的创建。对象组合的方式就是把“工厂”对象作为参数传递。", "\n\n", "如果是对的,能不能稍微帮我解释下,我看是懂非懂的,最好能用白话文,例子好象都差不多", "\n\n", "谢谢"]], "Tag": "程序设计"}
{"Answer": "一个动画要有起始状态和结束状态，这样就必须经过两次页面渲染才能确定两个状态、\r\n我在你上一问题中说了：一个js代码的线程执行结束页面才会重新渲染。\r\n就是说，在js线程执行前是动画的起始状态，在js线程执行后是动画的结束状态。\r\n\r\n如果你在一个js线程中同时设置动画的起始状态和动画的结束状态，这样在设置动画的起始状态后页面不会重新渲染。也就不能形成动画了", "Konwledge_Point": "组合与继承", "Question": ["这里的同步函数为什么没有效果，必须要加个计时器才行？", ["//组合继承  部分代码", "\n\n", " //构造函数 传入一个id 生成一个轮播图对象\n    function Slider (id) {\n        this.create(id)\n    };\n    //定义原型\n    Slider.prototype = {\n        create: function (id) {\n                        this.list = document.getElementById('list');\n                        ...\n                        ...\n                        ...\n            //初始化实例中的dom以及属性     **初始状态没有transition**\n        },\n        animate: function (offset,animateDuration) {\n            //获取的是style.left，是相对左边获取距离，所以第一张图后style.left都为负值，\n            //且style.left获取的是字符串，需要用parseInt()取整转化为数字。\n            this.list.style.transition = `left ${animateDuration} linear`;//看这里！\n            var newLeft = parseInt(this.list.style.left) + offset;\n            this.list.style.left = newLeft + 'px';  //看这里！\n        },\n    };\n    var slider = new Slider('container');\n    /*setTimeout(function () {\n        slider.animate(-300,'1s')\n    },0)  只有异步才有效，刷新有动画 */\n    slider.animate(-300,'1s')   //无效，没有动画，刷新直接跳转\n", "\n\n", "遇到这么一个问题， slider.animate(-300,'1s') 无效，必须放计时器里才用动画", "\n为什么会出现这种情况", "\nanimate函数执行完，浏览器渲染的时候list的left,transition我认为应该是都设置上去了的呀？"]], "Tag": "程序设计"}
{"Answer": "（1）首先判断object问题：equals方法是object类中的方法，他是判断两个对象是否是统一对象，这里对它进行了重写。\r\n这里的判空主要是：1.如果一个对象为空了，她就没有和其它对象比较的意义了  2.为空的时候，Cat c = (Cat)obj也会为空，下面获取成员变量的值也会报错。\r\n\r\n\r\n（2）c1.equals(c2)中用到的this主要是获取c1中各个成员变量的值。this代表c1（即调用equals方法的那个对象）", "Konwledge_Point": "组合与继承", "Question": ["关于equals的,实在是看不懂", ["class Cat {\nint color, weight, height;\n\npublic Cat(int color, int weight, int height) {\nthis.color = color;\nthis.weight = weight;\nthis.height = height;\n}\n\n/**\n* 这里是重写相等从Object类继承下来的equals()方法，改变这个方法默认的实现，\n* 通过我们自己定义的实现来判断决定两个对象在逻辑上是否相等。\n* 这里我们定义如果两只猫的color，weight，height都相同，\n* 那么我们就认为这两只猫在逻辑上是一模一样的，即这两只猫是“相等”的。\n*/\npublic boolean equals(Object obj){\nif (obj==null){\nreturn false;\n}\nelse{\n/**\n* instanceof是对象运算符。\n* 对象运算符用来测定一个对象是否属于某个指定类或指定的子类的实例。\n* 对象运算符是一个组合单词instanceof。\n* 该运算符是一个双目运算符，其左边的表达式是一个对象，右边的表达式是一个类，\n* 如果左边的对象是右边的类创建的对象，则运算结果为true，否则为false。\n*/\nif (obj instanceof Cat){\nCat c = (Cat)obj;\nif (c.color==this.color && c.weight==this.weight && c.height==this.height){\nreturn true;\n}\n}\n}\nreturn false;\n}\n}\n\npublic static void main(String[] args) {\n/**\n* 这里使用构造方法Cat()在堆内存里面new出了两只猫，\n* 这两只猫的color，weight，height都是一样的，\n* 但c1和c2却永远不会相等，这是因为c1和c2分别为堆内存里面两只猫的引用对象，\n* 里面装着可以找到这两只猫的地址，但由于两只猫在堆内存里面存储在两个不同的空间里面，\n* 所以c1和c2分别装着不同的地址，因此c1和c2永远不会相等。\n*/\nCat c1 = new Cat(1, 1, 1);\nCat c2 = new Cat(1, 1, 1);\nSystem.out.println(\"c1==c2的结果是：\"+(c1==c2));//false\nSystem.out.println(\"c1.equals(c2)的结果是：\"+c1.equals(c2));//true\n}\n\n------------------------------------------------------------------\n\n问题：1.这个程序为什么要判断object obj为空指针呢，我完全不理解，因为明明没有实例化。2.这里的this的作用是什么呢\n"]], "Tag": "程序设计"}
{"Answer": "使用组合啊，你自定义一个类，做为抽象类，再下面搞两个实现类，一个实现类使用本地的ResultSet做为内在属性，然后覆盖它的某一些方法\r\n另一个实现类使用远程的ResultSet做为内在属性，然后覆盖它的某一些方法，不就可以了吗？不需要去改已经封装好的代码，当然，这个方法也只能说是权宜之计,考虑一下，", "Konwledge_Point": "组合与继承", "Question": ["关于两种对象类型使用", ["直接描述的我的问题了。", "\n    我的需求是读取本地或异地的数据，程序中用到ResultSet（本地读取）和DepartResultset（异地读取，自己写的）来获得数据，程序就像这样：", "\n[code=\"java\"]", "\n本地：代码一", "\nconn = DBUtil.getConnection();", "\n                Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,", "\n                        ResultSet.CONCUR_UPDATABLE);", "\n                ResultSet rs = null;", "\n                rs = stmt.executeQuery(sql); [/code]", "\n\n", "[code=\"java\"]", "\n异地：代码二", "\nUnNativeDataSource ds = (UnNativeDataSource) DataSourceFactory.create(DataSourceTypes.UNNATIVETYPE);", "\n             DepartResultset rs = null;", "\n\n", "         rs = ds.exec(this.postCode,sql);\n         rs.first(); [/code]\n", "\n\n", "下面再读取时统一用rs变量来读，如 ", "\n[code=\"java\"]", "\n代码三：", "\nif (rs.next()) {[/code]", "\n我想问得是前面怎么设置两个不同类型rs, 怎么判断后给他转换个类型，就像如果true用本地rs,false用异地rs,最主要的是保证代码3不用修改。", "\n[b]问题补充：[/b]", "\n类被封装了，改不了。", "\n我最简单的想法就是不用", "\n[code=\"java\"]if(本地)", "\n   if(rs.next)", "\n     ...", "\nelse if(异地)", "\n   if(rs.next)", "\n     ...[/code]", "\n\n", "省略部分代码量比较大。", "\n最好就是，[code=\"java\"]Object rs = null;", "\n        if(本地)", "\n           rs = 本地", "\n          else", "\n           rs = 异地", "\n\n", "  然后if(rs.next)\n     ...[/code]\n", "\n\n", "有没有这种方式的实现。", "\n[b]问题补充：[/b]", "\n如果本地", "\nConnection conn = DBUtil.getConnection();", "\n                Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,", "\n                        ResultSet.CONCUR_UPDATABLE);", "\n                ResultSet rs = null;", "\n                rs = stmt.executeQuery(sql);  ", "\n\n", "/*", "\n如果异地", "\nUnNativeDataSource ds = (UnNativeDataSource) DataSourceFactory.create(DataSourceTypes.UNNATIVETYPE);", "\n             DepartResultset rs = null;", "\n             rs = ds.exec(this.postCode,sql);", "\n             rs.first();", "\n*/", "\n\n", "if(rs.next()){", "\n  ...", "\n}", "\n\n", "我要做的是就是把注释的这段也实现出来，这样会不会清楚些。", "\n[b]问题补充：[/b]", "\npublic void test(boolean isNative, Object obj){", "\nif(flag)", "\nrs = (ResultSet)Obj;", "\nelse", "\nrs = (DepartResultset)Obj;", "\nif(rs.next)        ... ", "\n}", "\n\n", "wangying95599 的做法试过，rs很难定义，定义成Object，它没有.next()方法；定义成ResultSet/DepartResultset,似乎不行。", "\n最好的做法我想还是异地操作类继承ResultSet类比较好。但是类被封装起来了。想办法沟通去。谢谢大家！", "\n[b]问题补充：[/b]", "\n[quote]使用组合啊，你自定义一个类，做为抽象类，再下面搞两个实现类，一个实现类使用本地的ResultSet做为内在属性，然后覆盖它的某一些方法 ", "\n另一个实现类使用远程的ResultSet做为内在属性，然后覆盖它的某一些方法，不就可以了吗？不需要去改已经封装好的代码，当然，这个方法也只能说是权宜之计,考虑一下，", "\nwangdgsc (初级程序员) 2009-09-21 [/quote]", "\n\n", "这个建议很好啊，虽然没做，但是思路比较清晰了，谢谢wangdgsc!", "\nAbstractResulsetSet(抽象类)", "\n|e", "\n|x", "\n|t", "\n|e", "\n|n", "\n|d    _____NativeResult {ResultSet rs; method(){return rs;}}", "\n|s    |", "\n------|", "\n      |", "\n      _____UnNativeResult", "\n           {DepartResultset rs; method(){return rs;}}"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/xqhrs232/article/details/27536481", "Konwledge_Point": "组合与继承", "Question": ["异步方式串口 死循环读取线程 如何退出？", ["用VC2015写了一个SDI程序，在app类的InitInstance()函数总，开启了一个串口读指令线程（异步方式）。对于串口的操作，比如读、写、配置、清理缓存等等，全部封装在了一个DLL中。", "\n读线程中，用一个BOOL型的开关变量制造了一个死循环，以便实时接收串口收到的数据。同时，也希望在需要终止该线程的时候，将开关量置反，结束死循环。", "\n已知：读指令函数中，会持续监测串口事件，当检测到有数据时，即读取数据。完整数据的读取，是通过GetOverlappedResult函数实现的。", "\n现在的问题是：要关闭进程了（点击文件菜单上的“退出”），在APP类的ExitInstance()函数中置反上述开关量，并且用PurgeComm 刷新串口（使用了PURGE_TXABORT 、PURGE_RXABORT、PURGE_TXCLEAR、PURGE_RXCLEAR四个组合值作为该函数的参数），希望产生串口事件，使待函数WaitCommEvent能够返回，进而在再次循环的时候，对开关量进行判断，因为该开关量已经置反，从而达到结束循环，退出退出线程的目的。", "\n奇怪的是:PurgeComm函数，总是返回不成功，读线程始终结束不了。", "\n本人为新手，不懂的太多，还望高手给与指点！非常感谢！", "\n读线程代码如下：", "\n\n", "////worker thread.to receive  instruction from control board.///////\ntypedef CString(*FuncReceiveFromBoard)(HANDLE, char*);\n//int panelFlushSerialPort(HANDLE h)\ntypedef int(*FuncFlush232)(HANDLE);\nFuncReceiveFromBoard ReceiveFromBoard;\nFuncFlush232 Flush232;\nHINSTANCE hDll_232DLL_RE;\nchar* pbufcmd = nullptr;\nUINT ReceiveInstructionFromBoard(LPVOID pParam)\n{\n    CDEMODVView *pDemoView1 = (CDEMODVView *)pParam;    \n    pbufcmd=nullptr;\n    pbufcmd = (char *)malloc(sizeof(char)*253); //分配内存\n    memset(pbufcmd, 0, 253);    //将分配给pcmbuf的内存初始化为0\n    if (theApp.communi_state == FALSE)  //说明232串口没有配置好或者没有打开\n        return 1;\n    else\n    {\n        ReceiveFromBoard = (FuncReceiveFromBoard)GetProcAddress(theApp.hDll_232com, \"panelReceiveCmdFromCBoard\");   //获取函数theApp.hDll_232com\n        Flush232 = (FuncFlush232)GetProcAddress(theApp.hDll_232com, \"panelFlushSerialPort\");\n        if (!ReceiveFromBoard|| !Flush232)\n        {\n            AfxMessageBox(_T(\"获取函数失败\"));\n            return 1;\n        }\n        else\n        {\n            CString resStrFromB;    //接收指令字符串\n            while (theApp.m_threadrunning==TRUE)\n            {\n                AfxMessageBox(_T(\"I am going\"));\n                resStrFromB = ReceiveFromBoard(theApp.hDleopen, pbufcmd);   \n                //用DLL中接收函数得到指令字符串给resStrFromB\n                if (resStrFromB !=_T(\"\"))//\n                {                   \n                    pDemoView1->m_strInstruction2Recive = resStrFromB;\n                    pDemoView1->SendMessage(WM_INSTRUCTION_RECEIVE);    //给VIEW类发送接收到字符串的消息\n                    resStrFromB = _T(\"\");\n                    Flush232(theApp.hDleopen);\n                    //Sleep(4000);\n                }\n\n            }\n//          设置线程等待函数已经退出循环，可以结束的标志;\n            theApp.m_threadstop = TRUE;\n        }\n    }\n    free(pbufcmd);\n    pbufcmd = nullptr;  \n    return 0;\n}\n", "\n\n", "前述封装的对串口操作的DLL中，关于读文件的部分，代码如下：", "\n\n", "DWORD __stdcall ReadCmdSerialPort(HANDLE h, char * const pszBuf, DWORD bufSize, DWORD *dwSize, DWORD *dwEventMask)\n{\n    DWORD error = ERROR_SUCCESS;\n    memset(&overread, 0, sizeof(OVERLAPPED));   \n    overread.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n    //创建overlapped事件：句柄不能被继承，人工重置事件，初始状态为无信号，匿名事件\n    DWORD dwError;  \n    COMSTAT comstat;    \n    ClearCommError(h, &dwError, &comstat);  \n    //清除端口错误\n    if (!SetCommMask(h, EV_BREAK | EV_ERR | EV_RXCHAR | EV_RXFLAG)) /* Setting Event Type */\n    {\n        /*printf(\"$\\n\");*/\n        return ::GetLastError();\n    }\n\n    if (!WaitCommEvent(h, dwEventMask, &overread)) /* Waiting For Event to Occur */\n    {\n        DWORD dwIncommingReadSize;\n        if (GetLastError() == ERROR_IO_PENDING)\n        {\n            GetOverlappedResult(h, &overread, &dwIncommingReadSize, TRUE);\n            // 等待异步操作结束后才返回到应用程序，此时，GetOverlappedResult函数与WaitForSingleObject函数等效\n            switch (*dwEventMask)\n            {\n            case EV_BREAK:\n                _snprintf_s(pszBuf, bufSize, _TRUNCATE, \"BREAK received\");\n                /*printf(\"*\\n\");*/\n                return error;\n                break;\n            case EV_ERR:\n                _snprintf_s(pszBuf, bufSize, _TRUNCATE, \"Line status error occurred\");\n                /*printf(\"&\\n\");*/\n                return error;\n                break;\n            case EV_RXFLAG:\n                return error;\n                break;\n            case EV_RXCHAR:\n            {\n                char szBuf;\n                //DWORD dwIncommingReadSize;\n                *dwSize = 0;\n                unsigned int ndx = 0;\n                do\n                {\n                    // 读取数据：指定读取的字节数为1，dwIncommingReadSize：读到的字节数；异步读取\n                    if (ReadFile(h, &szBuf, 1, &dwIncommingReadSize, &overread) != 0)   //\n                    {\n                        if (dwIncommingReadSize > 0)\n                        {\n                            *dwSize += dwIncommingReadSize;\n                            if (ndx < bufSize - 1)\n                            {\n                                pszBuf[ndx] = szBuf;\n                                ndx += dwIncommingReadSize;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        break;\n                    }\n\n                } while (dwIncommingReadSize > 0);\n                ResetEvent(overread.hEvent);// 释放事件句柄                                       \n                return error;\n                break;\n            }               \n            default:\n                _snprintf_s(pszBuf, bufSize, _TRUNCATE, \"unknown COMM event\");\n                return error;\n                break;\n            }\n            ResetEvent(overread.hEvent);// 释放事件句柄  \n        }\n        else\n        {\n            return ::GetLastError();\n        }\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "https://www.cnblogs.com/zhangbo2008/p/8459528.html", "Konwledge_Point": "组合与继承", "Question": ["用qtdesign弄出来gui怎么接入功能？", ["-*- coding: utf-8 -*-", "\n\n", "Form implementation generated from reading ui file 'C:\\Users\\yantao\\PycharmProjects\\untitled14\\venv\\untitled.ui'", "\n\n", "#", "\n\n", "Created by: PyQt5 UI code generator 5.12", "\n\n", "#", "\n\n", "WARNING! All changes made in this file will be lost!", "\n\n", "from PyQt5 import QtCore, QtGui, QtWidgets", "\n\n", "class Ui_mainWindow(object):", "\n    def setupUi(self, mainWindow):", "\n        mainWindow.setObjectName(\"mainWindow\")", "\n        mainWindow.resize(796, 598)", "\n        self.centralwidget = QtWidgets.QWidget(mainWindow)", "\n        self.centralwidget.setObjectName(\"centralwidget\")", "\n        self.listView = QtWidgets.QListView(self.centralwidget)", "\n        self.listView.setGeometry(QtCore.QRect(290, 300, 481, 192))", "\n        self.listView.setObjectName(\"listView\")", "\n        self.label = QtWidgets.QLabel(self.centralwidget)", "\n        self.label.setGeometry(QtCore.QRect(290, 280, 91, 16))", "\n        self.label.setObjectName(\"label\")", "\n        self.label_2 = QtWidgets.QLabel(self.centralwidget)", "\n        self.label_2.setGeometry(QtCore.QRect(10, 100, 54, 12))", "\n        self.label_2.setObjectName(\"label_2\")", "\n        self.label_3 = QtWidgets.QLabel(self.centralwidget)", "\n        self.label_3.setGeometry(QtCore.QRect(10, 140, 54, 12))", "\n        self.label_3.setObjectName(\"label_3\")", "\n        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)", "\n        self.textBrowser.setGeometry(QtCore.QRect(70, 90, 81, 31))", "\n        self.textBrowser.setObjectName(\"textBrowser\")", "\n        self.textBrowser_2 = QtWidgets.QTextBrowser(self.centralwidget)", "\n        self.textBrowser_2.setGeometry(QtCore.QRect(70, 130, 81, 31))", "\n        self.textBrowser_2.setObjectName(\"textBrowser_2\")", "\n        self.pushButton = QtWidgets.QPushButton(self.centralwidget)", "\n        self.pushButton.setGeometry(QtCore.QRect(290, 510, 91, 41))", "\n        self.pushButton.setObjectName(\"pushButton\")", "\n        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)", "\n        self.pushButton_2.setGeometry(QtCore.QRect(20, 290, 75, 23))", "\n        self.pushButton_2.setObjectName(\"pushButton_2\")", "\n        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)", "\n        self.pushButton_3.setGeometry(QtCore.QRect(20, 490, 75, 23))", "\n        self.pushButton_3.setObjectName(\"pushButton_3\")", "\n        self.openGLWidget = QtWidgets.QOpenGLWidget(self.centralwidget)", "\n        self.openGLWidget.setGeometry(QtCore.QRect(290, -10, 471, 281))", "\n        self.openGLWidget.setObjectName(\"openGLWidget\")", "\n        self.pushButton_4 = QtWidgets.QPushButton(self.centralwidget)", "\n        self.pushButton_4.setGeometry(QtCore.QRect(210, 110, 75, 23))", "\n        self.pushButton_4.setObjectName(\"pushButton_4\")", "\n        self.radioButton = QtWidgets.QRadioButton(self.centralwidget)", "\n        self.radioButton.setGeometry(QtCore.QRect(10, 50, 125, 16))", "\n        self.radioButton.setObjectName(\"radioButton\")", "\n        self.radioButton_2 = QtWidgets.QRadioButton(self.centralwidget)", "\n        self.radioButton_2.setGeometry(QtCore.QRect(10, 20, 119, 16))", "\n        self.radioButton_2.setObjectName(\"radioButton_2\")", "\n        self.horizontalSlider = QtWidgets.QSlider(self.centralwidget)", "\n        self.horizontalSlider.setGeometry(QtCore.QRect(120, 390, 141, 22))", "\n        self.horizontalSlider.setOrientation(QtCore.Qt.Horizontal)", "\n        self.horizontalSlider.setObjectName(\"horizontalSlider\")", "\n        self.label_4 = QtWidgets.QLabel(self.centralwidget)", "\n        self.label_4.setGeometry(QtCore.QRect(30, 380, 41, 31))", "\n        self.label_4.setObjectName(\"label_4\")", "\n        mainWindow.setCentralWidget(self.centralwidget)", "\n        self.menubar = QtWidgets.QMenuBar(mainWindow)", "\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 796, 23))", "\n        self.menubar.setObjectName(\"menubar\")", "\n        self.menufile = QtWidgets.QMenu(self.menubar)", "\n        self.menufile.setObjectName(\"menufile\")", "\n        self.menu_2 = QtWidgets.QMenu(self.menubar)", "\n        self.menu_2.setObjectName(\"menu_2\")", "\n        self.menu_3 = QtWidgets.QMenu(self.menubar)", "\n        self.menu_3.setObjectName(\"menu_3\")", "\n        self.menu_4 = QtWidgets.QMenu(self.menubar)", "\n        self.menu_4.setObjectName(\"menu_4\")", "\n        self.menu_5 = QtWidgets.QMenu(self.menubar)", "\n        self.menu_5.setObjectName(\"menu_5\")", "\n        mainWindow.setMenuBar(self.menubar)", "\n        self.statusbar = QtWidgets.QStatusBar(mainWindow)", "\n        self.statusbar.setObjectName(\"statusbar\")", "\n        mainWindow.setStatusBar(self.statusbar)", "\n        self.actionopen = QtWidgets.QAction(mainWindow)", "\n        self.actionopen.setObjectName(\"actionopen\")", "\n        self.actionExit = QtWidgets.QAction(mainWindow)", "\n        self.actionExit.setObjectName(\"actionExit\")", "\n        self.action_7 = QtWidgets.QAction(mainWindow)", "\n        self.action_7.setObjectName(\"action_7\")", "\n        self.action_8 = QtWidgets.QAction(mainWindow)", "\n        self.action_8.setObjectName(\"action_8\")", "\n        self.action_10 = QtWidgets.QAction(mainWindow)", "\n        self.action_10.setObjectName(\"action_10\")", "\n        self.menufile.addAction(self.actionopen)", "\n        self.menufile.addAction(self.action_7)", "\n        self.menufile.addAction(self.action_8)", "\n        self.menufile.addSeparator()", "\n        self.menufile.addAction(self.action_10)", "\n        self.menubar.addAction(self.menufile.menuAction())", "\n        self.menubar.addAction(self.menu_2.menuAction())", "\n        self.menubar.addAction(self.menu_3.menuAction())", "\n        self.menubar.addAction(self.menu_4.menuAction())", "\n        self.menubar.addAction(self.menu_5.menuAction())", "\n\n", "    self.retranslateUi(mainWindow)\n    QtCore.QMetaObject.connectSlotsByName(mainWindow)\n\ndef retranslateUi(self, mainWindow):\n    _translate = QtCore.QCoreApplication.translate\n    mainWindow.setWindowTitle(_translate(\"mainWindow\", \"三维可视化\"))\n    self.label.setText(_translate(\"mainWindow\", \"Action Logs\"))\n    self.label_2.setText(_translate(\"mainWindow\", \"组织数：\"))\n    self.label_3.setText(_translate(\"mainWindow\", \"组织数：\"))\n    self.pushButton.setText(_translate(\"mainWindow\", \"显示函数值\"))\n    self.pushButton_2.setText(_translate(\"mainWindow\", \"上色\"))\n    self.pushButton_3.setText(_translate(\"mainWindow\", \"去色\"))\n    self.pushButton_4.setText(_translate(\"mainWindow\", \"输出画面\"))\n    self.radioButton.setText(_translate(\"mainWindow\", \"面绘制\"))\n    self.radioButton_2.setText(_translate(\"mainWindow\", \"体绘制\"))\n    self.label_4.setText(_translate(\"mainWindow\", \"透明度：\"))\n    self.menufile.setTitle(_translate(\"mainWindow\", \"文件\"))\n    self.menu_2.setTitle(_translate(\"mainWindow\", \"编辑\"))\n    self.menu_3.setTitle(_translate(\"mainWindow\", \"格式\"))\n    self.menu_4.setTitle(_translate(\"mainWindow\", \"查看\"))\n    self.menu_5.setTitle(_translate(\"mainWindow\", \"帮助\"))\n    self.actionopen.setText(_translate(\"mainWindow\", \"打开\"))\n    self.actionExit.setText(_translate(\"mainWindow\", \"Exit\"))\n    self.action_7.setText(_translate(\"mainWindow\", \"保存\"))\n    self.action_8.setText(_translate(\"mainWindow\", \"另存为\"))\n    self.action_10.setText(_translate(\"mainWindow\", \"退出\"))\n", "\n\n", "if ", "name", " == \"__main__\":", "\n    import sys", "\n    app = QtWidgets.QApplication(sys.argv)", "\n    mainWindow = QtWidgets.QMainWindow()", "\n    ui = Ui_mainWindow()", "\n    ui.setupUi(mainWindow)", "\n    mainWindow.show()", "\n    sys.exit(app.exec_())", "\n\n", "功能一体绘制\n```import vtk\nfrom vtk.util.misc import vtkGetDataRoot\n\n# Create the renderer, the render window, and the interactor. The renderer\n# draws into the render window, the interactor enables mouse- and\n# keyboard-based interaction with the scene.\nren = vtk.vtkRenderer()\nrenWin = vtk.vtkRenderWindow()\nrenWin.AddRenderer(ren)\niren = vtk.vtkRenderWindowInteractor()\niren.SetRenderWindow(renWin)\n\n# The following reader is used to read a series of 2D slices (images)\n# that compose the volume. The slice dimensions are set, and the\n# pixel spacing. The data Endianness must also be specified. The reader\n# usese the FilePrefix in combination with the slice number to construct\n# filenames using the format FilePrefix.%d. (In this case the FilePrefix\n# is the root name of the file: quarter.)\n\n# v16 = vtk.vtkVolume16Reader()\n# v16.SetDataDimensions(64, 64)\n# v16.SetImageRange(1, 93)\n# v16.SetDataByteOrderToLittleEndian()\n# v16.SetFilePrefix(\"D:/dicom_image/headsq/quarter\")\n# v16.SetDataSpacing(3.2, 3.2, 1.5)\nv16 = vtk.vtkDICOMImageReader()\n# v16.SetDirectoryName('D:/dicom_image/vtkDicomRender-master/sample')\nv16.SetDirectoryName('C:\\\\Users\\\\yantao\\\\PycharmProjects\\\\untitled14\\\\Examples\\\\CT')\n\n# The volume will be displayed by ray-cast alpha compositing.\n# A ray-cast mapper is needed to do the ray-casting, and a\n# compositing function is needed to do the compositing along the ray.\nvolumeMapper = vtk.vtkGPUVolumeRayCastMapper()\nvolumeMapper.SetInputConnection(v16.GetOutputPort())\nvolumeMapper.SetBlendModeToComposite()\n\n# The color transfer function maps voxel intensities to colors.\n# It is modality-specific, and often anatomy-specific as well.\n# The goal is to one color for flesh (between 500 and 1000)\n# and another color for bone (1150 and over).\nvolumeColor = vtk.vtkColorTransferFunction()\nvolumeColor.AddRGBPoint(0,    0.0, 0.0, 0.0)\nvolumeColor.AddRGBPoint(500,  1.0, 0.5, 0.3)\nvolumeColor.AddRGBPoint(1000, 1.0, 0.5, 0.3)\nvolumeColor.AddRGBPoint(1150, 1.0, 1.0, 0.9)\n\n# The opacity transfer function is used to control the opacity\n# of different tissue types.\nvolumeScalarOpacity = vtk.vtkPiecewiseFunction()\nvolumeScalarOpacity.AddPoint(0,    0.00)\nvolumeScalarOpacity.AddPoint(500,  0.15)\nvolumeScalarOpacity.AddPoint(1000, 0.15)\nvolumeScalarOpacity.AddPoint(1150, 0.85)\n\n# The gradient opacity function is used to decrease the opacity\n# in the \"flat\" regions of the volume while maintaining the opacity\n# at the boundaries between tissue types.  The gradient is measured\n# as the amount by which the intensity changes over unit distance.\n# For most medical data, the unit distance is 1mm.\nvolumeGradientOpacity = vtk.vtkPiecewiseFunction()\nvolumeGradientOpacity.AddPoint(0,   0.0)\nvolumeGradientOpacity.AddPoint(90,  0.5)\nvolumeGradientOpacity.AddPoint(100, 1.0)\n\n# The VolumeProperty attaches the color and opacity functions to the\n# volume, and sets other volume properties.  The interpolation should\n# be set to linear to do a high-quality rendering.  The ShadeOn option\n# turns on directional lighting, which will usually enhance the\n# appearance of the volume and make it look more \"3D\".  However,\n# the quality of the shading depends on how accurately the gradient\n# of the volume can be calculated, and for noisy data the gradient\n# estimation will be very poor.  The impact of the shading can be\n# decreased by increasing the Ambient coefficient while decreasing\n# the Diffuse and Specular coefficient.  To increase the impact\n# of shading, decrease the Ambient and increase the Diffuse and Specular.\nvolumeProperty = vtk.vtkVolumeProperty()\nvolumeProperty.SetColor(volumeColor)\nvolumeProperty.SetScalarOpacity(volumeScalarOpacity)\n# volumeProperty.SetGradientOpacity(volumeGradientOpacity)\nvolumeProperty.SetInterpolationTypeToLinear()\nvolumeProperty.ShadeOn()\nvolumeProperty.SetAmbient(0.9)\nvolumeProperty.SetDiffuse(0.9)\nvolumeProperty.SetSpecular(0.9)\n\n# The vtkVolume is a vtkProp3D (like a vtkActor) and controls the position\n# and orientation of the volume in world coordinates.\nvolume = vtk.vtkVolume()\nvolume.SetMapper(volumeMapper)\nvolume.SetProperty(volumeProperty)\n\n# Finally, add the volume to the renderer\nren.AddViewProp(volume)\n\n# Set up an initial view of the volume.  The focal point will be the\n# center of the volume, and the camera position will be 400mm to the\n# patient's left (which is our right).\ncamera = ren.GetActiveCamera()\nc = volume.GetCenter()\ncamera.SetFocalPoint(c[0], c[1], c[2])\ncamera.SetPosition(c[0] + 400, c[1], c[2])\ncamera.SetViewUp(0, 0, -1)\n\n# Increase the size of the render window\nrenWin.SetSize(640, 480)\n\n# Interact with the data.\niren.Initialize()\nrenWin.Render()\niren.Start()\n功能二面绘制\n# 抽取轮廓(等值面)的操作对象是标量数据。mianhuizhi2\nimport vtk\n\n# source—filter——mapper——actor——render——renderwindow——interactor\naRenderer = vtk.vtkRenderer()  # 渲染器\nrenWin = vtk.vtkRenderWindow()  # 渲染窗口,创建窗口\nrenWin.AddRenderer(aRenderer)  # 渲染窗口\n# renWin.Render()\niren = vtk.vtkRenderWindowInteractor()  # 窗口交互\niren.SetRenderWindow(renWin)\n\n# The following reader is used to read a series of 2D slices(images)\n# that compose the volume.Theslicedimensions are set, and the\n#  pixel spacing.The data Endianness must also be specified.The reader\n#  uses the FilePrefix in combination with the slice number to construct\n# filenames using the format FilePrefix. % d.(In this case the FilePrefix\n# is the root name of the file.\n\nv16 = vtk.vtkDICOMImageReader()\n# v16.SetDirectoryName('D:/dicom_image/V')\nv16.SetDirectoryName('C:\\\\Users\\\\yantao\\\\PycharmProjects\\\\untitled14\\\\Examples\\\\CT')\n\n\n\n# An isosurface, or contour value of 500 is known to correspond to the\n# skin of the patient.Once generated, a vtkPolyDataNormals filter is\n# used to create normals for smooth surface shading during rendering.\nskinExtractor = vtk.vtkContourFilter()\nskinExtractor.SetInputConnection(v16.GetOutputPort())\nskinExtractor.SetValue(0, -10)\n# skinExtractor.GenerateValues(2, 100, 110)\nskinNormals = vtk.vtkPolyDataNormals()\nskinNormals.SetInputConnection(skinExtractor.GetOutputPort())\nskinNormals.SetFeatureAngle(60.0)\nskinMapper = vtk.vtkPolyDataMapper()  # 映射器\nskinMapper.SetInputConnection(skinNormals.GetOutputPort())\nskinMapper.ScalarVisibilityOff()\n\nskin = vtk.vtkActor()\n# 设置颜色RGB颜色系统就是由三个颜色分量：红色(R)、绿色(G)和蓝色(B)的组合表示，\n# 在VTK里这三个分量的取值都是从0到1，(0, 0, 0)表示黑色，(1, 1, 1)表示白色。\n#  vtkProperty::SetColor(r,g, b)采用的就是RGB颜色系统设置颜色属性值。\n#skin.GetProperty().SetColor(0, 0, 1)\nskin.SetMapper(skinMapper)\n\nskin.GetProperty().SetDiffuseColor(1, .49, .25)\n\nskin.GetProperty().SetSpecular(.5)\n\nskin.GetProperty().SetSpecularPower(20)\n\n# skin.GetProperty().SetRepresentationToSurface()\n# 构建图形的方框\noutlineData = vtk.vtkOutlineFilter()\noutlineData.SetInputConnection(v16.GetOutputPort())\nmapOutline = vtk.vtkPolyDataMapper()\nmapOutline.SetInputConnection(outlineData.GetOutputPort())\noutline = vtk.vtkActor()\noutline.SetMapper(mapOutline)\noutline.GetProperty().SetColor(0, 0, 0)\n\n# 构建舞台的相机\naCamera = vtk.vtkCamera()\naCamera.SetViewUp(0, 0, -1)\naCamera.SetPosition(0, 1, 0)\naCamera.SetFocalPoint(0, 0, 0)\naCamera.ComputeViewPlaneNormal()\n\n# Actors are added to the renderer.An initial camera view is created.\n# The Dolly() method moves the camera towards the Focal　Point,\n# thereby enlarging the image.\naRenderer.AddActor(outline)\naRenderer.AddActor(skin)\naRenderer.SetActiveCamera(aCamera)\n# 将相机的焦点移动至中央，The camera will reposition itself to view the center point of the actors,\n# and move along its initial view plane normal\naRenderer.ResetCamera()\n# aCamera.Dolly(1.5)\n# aCamera.Roll(180)\n# aCamera.Yaw(60)\n\naRenderer.SetBackground(250, 250, 250)\n# renWin.SetSize(640, 480)\n# 该方法是从vtkRenderWindow的父类vtkWindow继承过来的，用于设置窗口的大小，以像素为单位。\nrenWin.SetSize(500, 500)\naRenderer.ResetCameraClippingRange()\n\nstyle = vtk.vtkInteractorStyleTrackballCamera()\niren.SetInteractorStyle(style)\n\niren.Initialize()\niren.Start()\n", "\n\n"]], "Tag": "程序设计"}
