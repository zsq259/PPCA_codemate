{"Answer": "https://blog.csdn.net/qq_26437925/article/details/47703119", "Konwledge_Point": "关系运算", "Question": ["关系运算，                                                   用一个C语言实现？", ["For two rational numbers, your task is to implement the basic arithmetics, that is, to calculate their sum, difference, product and quotient.", "\n\n", "Input Specification:", "\n\n", "Each input file contains one test case, which gives in one line the two rational numbers in the format \"a1/b1 a2/b2\". The numerators and the denominators are all in the range of long int. If there is a negative sign, it must appear only in front of the numerator. The denominators are guaranteed to be non-zero numbers.", "\n\n", "Output Specification:", "\n\n", "For each test case, print in 4 lines the sum, difference, product and quotient of the two rational numbers, respectively. The format of each line is \"number1 operator number2 = result\". Notice that all the rational numbers must be in their simplest form \"k a/b\", where k is the integer part, and a/b is the simplest fraction part. If the number is negative, it must be included in a pair of parentheses. If the denominator in the division is zero, output \"Inf\" as the result. It is guaranteed that all the output integers are in the range of long int.", "\n\n", "Sample Input 1:", "\n2/3 -4/2", "\nSample Output 1:", "\n2/3 + (-2) = (-1 1/3)", "\n2/3 - (-2) = 2 2/3", "\n2/3 * (-2) = (-1 1/3)", "\n2/3 / (-2) = (-1/3)", "\nSample Input 2:", "\n5/3 0/6", "\nSample Output 2:", "\n1 2/3 + 0 = 1 2/3", "\n1 2/3 - 0 = 1 2/3", "\n1 2/3 * 0 = 0", "\n1 2/3 / 0 = Inf"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一题&amp;#xff1a;&lt;br /&gt;x &amp;#61; y-- &amp;lt;&amp;#61;x || x&amp;#61;y!&amp;#61;z;&lt;br /&gt;其实这个等式是一个错误的等式&amp;#xff0c;因为等号的优先级最低&amp;#xff0c;所以x&amp;#61;y!&amp;#61;z这里x后面的等号会报错。&lt;br /&gt;所以这里只能猜测出题者的意图&amp;#xff0c;按照这个思路&amp;#xff0c;公式可以分解为&amp;#xff1a;&lt;br /&gt;&amp;#xff08;1&amp;#xff09;y &amp;lt;&amp;#61;x (y&amp;#61;2,x&amp;#61;1,所以y&amp;lt;&amp;#61;x的结果是0&amp;#xff09;&lt;br /&gt;&amp;#xff08;2&amp;#xff09;x&amp;#61;y!&amp;#61;z这个先计算 y!&amp;#61;z&amp;#xff0c;结果是1&amp;#xff0c;所以x&amp;#61;1&lt;br /&gt;&amp;#xff08;3&amp;#xff09;x &amp;#61; 0 || 1 &amp;#xff08;0是步骤1的结果&amp;#xff0c;1是步骤2的结果&amp;#xff09;&amp;#xff0c;x &amp;#61; 1&lt;br /&gt;&amp;#xff08;4&amp;#xff09;y-- &amp;#xff08;y--最后计算&amp;#xff09;&amp;#xff0c;y &amp;#61; 1&lt;br /&gt;所以显示的结果就是&amp;#xff1a;1,1&lt;br /&gt;第二题&amp;#xff1a;&lt;br /&gt;x &amp;#61; x || y &amp;amp;&amp;amp; z;  先计算x || y &amp;#xff0c;x和y都非0&amp;#xff0c;所以x || y 的结果是1&amp;#xff0c;然后计算1 &amp;amp;&amp;amp; z &amp;#xff0c;z&amp;#61;0&amp;#xff0c;所以结果就是0&amp;#xff0c;所以x &amp;#61; 0;&lt;br /&gt;printf中x &amp;amp;&amp;amp; !y || z &amp;#xff0c;先计算 x &amp;amp;&amp;amp; !y &amp;#xff0c;x&amp;#61;0&amp;#xff0c;所以结果是0&amp;#xff0c;然后计算 0 || z&amp;#xff0c;z&amp;#61;0&amp;#xff0c;所以结果仍然是0&amp;#xff0c;&lt;br /&gt;所以最后的结果是&amp;#xff1a;0,0&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["C语言  关系运算符、逻辑运算符与表达式的程序阅读题", ["求解释printf上面的语句，不知道从哪里开始看，", "第一题知道或前面为假，但是或后面不知道怎么看。", "第二题，！怎么看。求解释。", "\n"]], "Tag": "程序设计"}
{"Answer": "不知道你这个9是你的编译器的结果还是书上的答案。\r\n在一个式子里对同一个变量进行++是个未定义的行为，不同的编译器结果很可能不同。\r\n得到9的编译器，一般来说是进行优化过的，并不是如楼主所想2*3,而是3*3\r\n这里涉及到压栈和弹栈的操作，编译器压入的是i的引用，而并不是数值，所以第二个++会使得*左边的i也自加1\r\n参考：http://bbs.csdn.net/topics/370153775", "Konwledge_Point": "关系运算", "Question": ["C计算问题，结合性，优先级，，，，，，", ["int i = 1;", "\n++i * ++i为什么是9而不是6呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结果集就是你最后投影出的的那一行一行的就是结果集&amp;#xff0c;如果你学过dbc你应该知道有这么一个对象ResultSet 就是结果集对象&amp;#xff0c;接收查询出来的那一行一行的数据&amp;#xff0c;望采纳&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["那个关系运算结果是什么意思", ["那个关系运算结果是什么意思呀？tc表是教师授课表，tno是教师编号，cno是学生编号"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a&amp;gt;b&amp;gt;c编译能通过&amp;#xff0c;但应该得不到你想要的结果。&lt;br /&gt;连等也是可以的&amp;#xff0c;比如a&amp;#61;b&amp;#61;1&amp;#xff0c;将a,b同时设置为1&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["在关系运算符中，可写a>b,那可以写a>b>c吗，就是可以连等吗", ["在关系运算符中，可写a>b,那可以写a>b>c吗，就是可以连等吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;翻译成数据库就是将两张表按照B字段和D字段进行关联查询&amp;#xff0c;对应语句应该是&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-sql\"&gt;&lt;span class=\"hljs-keyword\"&gt;select&lt;/span&gt; * &lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; r &lt;span class=\"hljs-keyword\"&gt;inner&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;join&lt;/span&gt; s &lt;span class=\"hljs-keyword\"&gt;where&lt;/span&gt; r.B &amp;#61; s.D\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算", "Question": ["数据库中选择的关系运算", ["问题遇到的现象和发生背景", "\n", "这个第三小问，那个选择运算符是对谁运算，结果是啥"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果 greaterThan 为 true&amp;#xff0c;则检查学生的平均分数是否大于阈值。如果 greaterThan 为 false&amp;#xff0c;则检查学生的平均分数是否小于阈值。如果这两个条件中有一个为 true&amp;#xff0c;则返回 true&amp;#xff0c;否则返回 false。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["解释逻辑运算式和关系运算式", ["\nif ((", "greaterThan", " ", "&&", " studentRecords[i].averageScore > threshold) || (!greaterThan ", "&&", " studentRecords[i].averageScore < threshold))\n", "\n", "可以给我说明一下这个逻辑吗？"]], "Tag": "程序设计"}
{"Answer": "首先搞清楚元是什么，元就是数据库里面的字段。字段相同，才是相同类型的数据，相同类型的数据才能求差集、并集。\r\n好比，这次开会的人中哪些人是上次开会的时候没来的（求差）。\r\n你总不能计算，这次开会的人中哪些是动物园猴山上的猴子吧。", "Konwledge_Point": "关系运算", "Question": ["关于一个数据库的关系代数运算问题", ["关系代数中的减，并，为什么要求两个关系的元相同呢？", "\n关系代数中的减，并，为什么要求两个关系的元相同呢？", "\n关系代数中的减，并，为什么要求两个关系的元相同呢？", "\n关系代数中的减，并，为什么要求两个关系的元相同呢？关系代数中的减，并，为什么要求两个关系的元相同呢？", "\n关系代数中的减，并，为什么要求两个关系的元相同呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;u&gt;&lt;strong&gt;不能直接用&amp;#61;&amp;#61; 字符串比较相等用equals()方法&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["大佬们Java可以用字符进行关系运算吗", ["如图代码", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "都是浮点运算，数字大小操作起来速度一样。但是请注意，数字越大，那么尾数的精度越低。\r\n比如你买一个计算器，是8位的，那么如果整数部分是1-9，小数点后可以精确到0.0000001，如果整数部分是10000，那么小数精度只有0.001了。", "Konwledge_Point": "关系运算", "Question": ["浮点数的运算，数字大小对计算速度有影响吗？", ["如果类型一样，都是浮点数的话，数字大小对计算有影响吗？", "\n写游戏的时候有runningTime+=DeltaTime的运算，如果不定期清理runningTime让", "\n其归零，一直不停的加DeltaTime的话，会不会让游戏越来越卡？", "\n还是说都是浮点型，数字大小对资源消耗没有影响？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;i&amp;#43;&amp;#43;是先用i当前值进行运算&amp;#xff0c;运算结束后才加1&amp;#xff0c;所以&lt;br /&gt;j&amp;#61;i&amp;#43;&amp;#43;-1;相当于两句&lt;br /&gt;j&amp;#61;i-1;&lt;br /&gt;i&amp;#61;i&amp;#43;1;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["关于运算顺序问题（没有逻辑符号和关系符号）", ["编码中遇到运算顺序问题，不知道如何得到的结果", "\n", "图一为什么j为0而不是1啊", "图二为什么j等于7呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.没看懂哪里用到除法&lt;br /&gt;2.不写all就不能从语法上保证返回条目是唯一的&amp;#xff0c;那就报错了呀&amp;#xff0c;一个数不能与一个集合比较大小&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["数据库中关系代数的除法运算", ["问题遇到的现象和发生背景", "\n", "把这两个换成除法的方式？？", "\n", "还有这个，>all我直接写>不写all区别大吗", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给你写了一个交集的&amp;#xff0c;就是遍历A B 共同的放到一个集合里&amp;#xff0c;其他几个同理&lt;br /&gt;如有帮助&amp;#xff0c;请击【采纳该答案】按钮支持一下,谢谢&amp;#xff01;以后有什么问题可以互相交流。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;Set Intersection(Set A,Set &lt;span class=\"hljs-keyword\"&gt;B)\n&lt;/span&gt;{\n    Set S&amp;#61;CreatSet(&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;);\n    int i,&lt;span class=\"hljs-keyword\"&gt;j;\n&lt;/span&gt;    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i&amp;lt;A.Size; i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;B.Size; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;)\n&lt;/span&gt;            if(A.site[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.site[j])\n&lt;/span&gt;                S.site[S.Size&amp;#43;&amp;#43;]&amp;#61;A.site[i];\n    }\n    return S;\n}\nSet Union(Set A,Set &lt;span class=\"hljs-keyword\"&gt;B)\n&lt;/span&gt;{\n    int i,&lt;span class=\"hljs-keyword\"&gt;j,f&amp;#61;1;\n&lt;/span&gt;    Set S&amp;#61;CreatSet(&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i&amp;lt;A.Size; i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {f&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;S.Size; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;){\n&lt;/span&gt;            if(A.site[i]&amp;#61;&amp;#61;S.site[&lt;span class=\"hljs-keyword\"&gt;j]){\n&lt;/span&gt;                f&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;break;&lt;/span&gt;\n            }\n        }\n        if(f&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)S.site[S.Size&amp;#43;&amp;#43;]&amp;#61;A.site[i];\n    }\n    for(i&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.Size-1; &lt;/span&gt;i&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i--){&lt;!-- --&gt;&lt;/span&gt;\n        f&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;S.Size; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;){\n&lt;/span&gt;            if(&lt;span class=\"hljs-keyword\"&gt;B.site[i]&amp;#61;&amp;#61;S.site[j]){\n&lt;/span&gt;                f&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;break;&lt;/span&gt;\n            }\n\n        }if(f&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)S.site[S.Size&amp;#43;&amp;#43;]&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.site[i];\n&lt;/span&gt;\n    }\n    return S;\n}\nSet Complement(Set A,Set &lt;span class=\"hljs-keyword\"&gt;B){\n&lt;/span&gt;    int i,&lt;span class=\"hljs-keyword\"&gt;j,f&amp;#61;0;\n&lt;/span&gt;    Set S&amp;#61;CreatSet(&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i&amp;lt;A.Size; i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;\n        f&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;B.Size; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;){\n&lt;/span&gt;            if(A.site[i]!&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.site[j]){\n&lt;/span&gt;                f&amp;#43;&amp;#43;;\n            }\n        }\n        if(f&amp;#61;&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.Size)\n&lt;/span&gt;        S.site[S.Size&amp;#43;&amp;#43;]&amp;#61;A.site[i];\n    }\n    return S;\n}\n&lt;span class=\"hljs-comment\"&gt;/* 你编写和几个函数将嵌入在这里 */&lt;/span&gt;\nSet SymmetricDifference(Set A,Set &lt;span class=\"hljs-keyword\"&gt;B){\n&lt;/span&gt;    int i,&lt;span class=\"hljs-keyword\"&gt;j,f&amp;#61;0;\n&lt;/span&gt;    Set S&amp;#61;CreatSet(&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;);\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i&amp;lt;A.Size; i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;/span&gt;\n        f&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;lt;B.Size; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;#43;&amp;#43;){\n&lt;/span&gt;            if(A.site[i]!&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.site[j]){\n&lt;/span&gt;                f&amp;#43;&amp;#43;;\n            }\n        }\n        if(f&amp;#61;&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.Size)\n&lt;/span&gt;        S.site[S.Size&amp;#43;&amp;#43;]&amp;#61;A.site[i];\n    }\n    for(i&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.Size-1; &lt;/span&gt;i&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i--){&lt;!-- --&gt;&lt;/span&gt;\n        f&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        for(&lt;span class=\"hljs-keyword\"&gt;j&amp;#61;A.Size-1; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j&amp;gt;&amp;#61;0; &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;j--){\n&lt;/span&gt;            if(&lt;span class=\"hljs-keyword\"&gt;B.site[i]!&amp;#61;A.site[j]){\n&lt;/span&gt;                f&amp;#43;&amp;#43;;\n            }\n        }\n        if(f&amp;#61;&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.Size)\n&lt;/span&gt;        S.site[S.Size&amp;#43;&amp;#43;]&amp;#61;&lt;span class=\"hljs-keyword\"&gt;B.site[i];\n&lt;/span&gt;    }\n    return S;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算", "Question": ["请教一下这个pta实验怎么做，集合运算[用结构类型表示集合]", ["如下给出的结构类型用来表示一个有关正整数的集合类型，结构类型中的每个成员与集合中的相关要素的关联关系已经在注释中说明。", "\n", "struct ", "Set", "\n{\n    ", "int", " MaxSize;           ", "//记录集合中最大元素数", "\n    ", "int", " Size;              ", "//记录集合中实际元素数", "\n    ", "int", " *site;             ", "//指向集合存储空间的指针", "\n};\n", "typedef", " struct ", "Set", " ", "Set", ";    ", "//为集合类型声明了一个别名Set", "\n\n\n", "\n", "本题要求用这个类型来编写一系列的函数来实现集合的交、并、相对补以及对称差运算。", "\n", "说明：", "为集合分配存储空间，给集合中输入元素、输出集合中元素的相关函数已经编写好，与测试裁判程序一道给出，这些函数无需编写，直接使用即可。检测一个元素是否在集合中的函数也已经编写好了，亦无需定义。请详细阅读测试裁判程序中的相关函数。", "\n", "函数接口定义：", "\n", "Set Union(Set ", "A", ",Set ", "B", ");                      //求", "A", "∪", "B", "\nSet Intersection(Set ", "A", ",Set ", "B", ")；              //求", "A", "∩", "B", "\nSet Complement(Set ", "A", ",Set ", "B", ")；                //求", "A", "-", "B", "\nSet SymmetricDifference(Set ", "A", ",Set ", "B", ")；       //求", "A", "⊕", "B", "  \n\n\n", "\n", "其中A 和 B 都是用户传入的参数,其类型均为用上述定义的Set型集合。函数的返回值均为Set 类型的集合。", "\n", "裁判测试程序样例：", "\n", "#", "include", "\"stdio.h\"", "\n", "#", "include", "\"stdlib.h\"", "\n", "struct", " ", "Set", "\n{\n    ", "int", " MaxSize;    ", "//记录集合中最大元素数", "\n    ", "int", " Size;        ", "//记录集合中实际元素数", "\n    ", "int", " *site;        ", "//指向集合存储空间的指针", "\n};\n", "typedef", " ", "struct", " ", "Set", " Set; ", "//为集合类型声明了一个别名Set", "\n", "/****************以下函数为输出一个集合的函数*************/", "\n", "void", " ", "display", "(Set S)", "\n", "{\n    ", "printf", "(", "\"{\"", ");\n    ", "for", "(", "int", " i=", "0", ";i<S.Size;i++)\n        ", "if", "(i==", "0", ")", "printf", "(", "\"%d\"", ",S.site[i]);\n        ", "else", " ", "printf", "(", "\",%d\"", ",S.site[i]);\n    ", "printf", "(", "\"}\\n\"", ");\n}\n", "/****************以下函数创建集合的存储空间*************/", "\n", "Set ", "CreatSet", "(", "int", " maxSize)", "\n", "{\n    Set S;\n    S.Size=", "0", ";              ", "//集合的实际元素数置0", "\n    S.MaxSize=maxSize;     ", "//集合最大元素数为maxSize;", "\n    S.site=(", "int", "*)", "malloc", "(maxSize*", "sizeof", "(", "int", "));\n    ", "return", " S;\n}\n", "/****以下函数判断x是否在集合A中 *****/", "\n", "int", " ", "IsIn", "(", "int", " x,Set S)", "\n", "{\n    ", "int", " i;\n    ", "for", "(i=", "0", ";i<S.Size;i++)\n    {\n        ", "if", "(x==S.site[i])\n            ", "return", " ", "1", ";\n    }\n    ", "return", " ", "0", ";\n}\n", "/***************以下函数为集合S输入元素**************\n输入的元素均为非0正整数，若输入0则认为输入结束\n****************************************************/", "\n", "void", " ", "InputSet", "(Set *S)", "\n", "{\n    ", "int", " a=", "0", ";\n    ", "do", "\n    {\n        ", "scanf", "(", "\"%d\"", ",&a);\n        ", "if", "(!", "IsIn", "(a,*S)&&a>", "0", ")      ", "//检验集合元素的互异性", "\n            S->site[S->Size++]=a;\n    }", "while", "(a>", "0", "&&S->Size<S->MaxSize);\n}\n\n", "/* 你编写和几个函数将嵌入在这里 */", "\n\n", "int", " ", "main", "()", "{\n    Set A,B,C;", "//声明集合类型的变量A、B、C", "\n    ", "int", " num;\n    ", "scanf", "(", "\"%d\"", ",&num);   ", "//为集合A输入最大元素数", "\n    A=", "CreatSet", "(num);    ", "//为集合A创建存储空间", "\n    ", "InputSet", "(&A);       ", "//给集合A输入元素", "\n    ", "scanf", "(", "\"%d\"", ",&num);   ", "//为集合B输入最大元素数", "\n    B=", "CreatSet", "(num);    ", "//为集合B创建存储空间", "\n    ", "InputSet", "(&B);       ", "//给集合B输入元素", "\n    C=", "Union", "(A,B);       ", "//将A、B的并存入C", "\n    ", "printf", "(", "\"A∪B=\"", ");", "display", "(C);\n    C=", "Intersection", "(A,B);", "//将A、B的交存入C", "\n    ", "printf", "(", "\"A∩B=\"", ");", "display", "(C);\n    C=", "Complement", "(A,B);", "//将A、B的相对补存入C", "\n    ", "printf", "(", "\"A-B=\"", ");", "display", "(C);\n    C=", "SymmetricDifference", "(A,B);", "//将A、B的对称差存入C", "\n    ", "printf", "(", "\"A⊕B=\"", ");", "display", "(C);\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "输入说明及输入样例：", "输入分两行进行，第一行为第一个集合中的相关数据，第二行为第二个集合中的相关数据。每行第一个数字为该集合中的存储空间的大小(即最大元素数)，紧接着的若干个非零正整数为集合中的元素值，最后一个数0为数据输入结束标志。", "\n", "10 ", "1", " ", "2", " ", "3", " ", "4", " ", "5", " ", "3", " ", "6", " ", "0", "\n", "10 ", "1", " ", "2", " ", "9", " ", "8", " ", "4", " ", "6", " ", "2", " ", "0", "\n\n\n", "\n", "输出样例：", "输出分四行，第一行输出并集，第二行输出交集，第三行输出相对补集合，第四行输出对称差集合。如果某个集合是空集，则在相应的表达式后输出{}。", "\n", "A", "∪B={", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "8", ",", "9", "}\n", "A", "∩B={", "1", ",", "2", ",", "4", ",", "6", "}\n", "A", "-B={", "3", ",", "5", "}\n", "A", "⊕B={", "3", ",", "5", ",", "8", ",", "9", "}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n int a=3;\r\nint b=5;\r\na&gt;b&amp;&amp;++a; //a&gt;b不满足，所以++a不执行\r\na&lt;b||++b; //a&lt;b满足，所以++b也不执行\r\nprintf(\"%d %d\", a, b); //所以还是3 5\r\n和优先级没关系，你可以认为，条件表达式优化，导致部分表达式不求值，这个比任何优先级都高\r\n上机验证\r\n3 5\r\nhttps://ideone.com/jMSAyH\r\n```", "Konwledge_Point": "关系运算", "Question": ["关于c语言的运算顺序。", ["今天老师讲作业，碰到下图第八题，按照老师的说法，++运算符的优先级大于关系运算符和逻辑运算符，所以这题的答案是a=4,b=6。但是我记得自己写过这个程序，结果并不是这样，然后又写了一次，如下图34。", "\n依旧和老师讲的不一样，但是翻了书，后面的优先级确实是算数运算符大于&&运算符。", "\n我想的是，&&运算符和||运算符都是先算左边再算右边，&&运算符算出左边为假就不会继续运算，后面的++a也就不执行，||同理。但是这样想就和书后面的运算顺序还有老师的说法矛盾了，&&运算符的优先级很低，所以求助大佬，这个该怎么理解。"]], "Tag": "程序设计"}
{"Answer": "机器指令本身就是二进制的，哪里来的什么“转换为2进制”一说。\r\n现代的处理器往往都是多发射、流水线设计，这意味着在一个时钟周期内，cpu可以取多条指令，译码和执行。\r\n对于像两个整数的加法这样的操作Intel Core系列处理器每时钟周期可以执行4条。每条指令都是32位位宽。\r\n但是要考虑到，Intel Core处理器采用了流水线技术，拥有14个工位（Core i7甚至有17个工位，而P4有20~31个），所以对于单条指令，它需要几个甚至更多时钟周期才能执行完毕。\r\n\r\n你完全没有一点点计算机的基本常识，如果你对计算机感兴趣，可以找一本《深入理解计算机系统》先入门下。", "Konwledge_Point": "关系运算", "Question": ["计算机（运算速度）和读取代码速度 之间的关系。", ["1Ghz = 10亿次/每秒", "\n但是计算机都是读取的2进制，所有的语句都要转换为2进制。", "\n\n", "        1.一个字母就是8位，读取每一位是否都算是运行了一次呢？\n\n        2.加法运算是运行了多少次呢？\n\n        3.把加法看做是运行1的话\n                        式子：0 + 0 = 0\n                        次数：1  1 1    1    一共是运行了4次吗？\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;具体是什么结果不对,我跑了几次都能正确输出&lt;/p&gt;\n&lt;p&gt;&lt;img title=\"image.png\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/005802984036121.png\" /&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// #include&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OK 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; ERROR 0&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXSIZE 100&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OVERFLOW -2&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; oper[&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;};\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;std&lt;/span&gt;;\ntypedef &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; SElemType; &lt;span class=\"hljs-comment\"&gt;//定义字符类型&lt;/span&gt;\ntypedef &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; NElemType;  &lt;span class=\"hljs-comment\"&gt;//定义int类型&lt;/span&gt;\ntypedef &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; Status;\n\ntypedef &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//字符型栈的存储结构&lt;/span&gt;\n{\n    SElemType *&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;;\n    SElemType *top;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; stackSize;\n} SqStack_optr;\n\ntypedef &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//int型栈的存储结构&lt;/span&gt;\n{\n    NElemType *&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;;\n    NElemType *top;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; stackSize;\n} SqStack_opnd;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;InitStackS&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_optr &amp;amp;S&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//字符型栈的初始化&lt;/span&gt;&lt;/span&gt;\n{\n    S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; SElemType[MAXSIZE];\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OVERFLOW;\n    S.top &amp;#61; S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;;\n    S.stackSize &amp;#61; MAXSIZE;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;InitStackN&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_opnd &amp;amp;S&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//int型栈的初始化&lt;/span&gt;&lt;/span&gt;\n{\n    S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; NElemType[MAXSIZE];\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OVERFLOW;\n    S.top &amp;#61; S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;;\n    S.stackSize &amp;#61; MAXSIZE;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;PushS&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_optr &amp;amp;S, SElemType e&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//字符型进栈&lt;/span&gt;&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (S.top - S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt; &amp;#61;&amp;#61; S.stackSize)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    *S.top&amp;#43;&amp;#43; &amp;#61; e;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;PushN&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_opnd &amp;amp;S, NElemType e&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//int型进栈&lt;/span&gt;&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (S.top - S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt; &amp;#61;&amp;#61; S.stackSize)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    *S.top&amp;#43;&amp;#43; &amp;#61; e;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;PopS&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_optr &amp;amp;S, SElemType &amp;amp;e&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//字符型栈顶元素退栈&lt;/span&gt;&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (S.top &amp;#61;&amp;#61; S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR; &lt;span class=\"hljs-comment\"&gt;// 栈空&lt;/span&gt;\n    e &amp;#61; *--S.top;     &lt;span class=\"hljs-comment\"&gt;// --S.top; e&amp;#61;*S.top;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n} &lt;span class=\"hljs-comment\"&gt;//Pop&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;PopN&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_opnd &amp;amp;S, NElemType &amp;amp;e&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//int型栈顶元素退栈&lt;/span&gt;&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (S.top &amp;#61;&amp;#61; S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR; &lt;span class=\"hljs-comment\"&gt;// 栈空&lt;/span&gt;\n    e &amp;#61; *--S.top;     &lt;span class=\"hljs-comment\"&gt;// --S.top; e&amp;#61;*S.top;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n} &lt;span class=\"hljs-comment\"&gt;//Pop&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;SElemType &lt;span class=\"hljs-title\"&gt;GetTopS&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_optr S&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//字符型取栈顶&lt;/span&gt;&lt;/span&gt;\n{\n    SElemType e;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (S.top &amp;#61;&amp;#61; S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR; &lt;span class=\"hljs-comment\"&gt;//栈空&lt;/span&gt;\n    e &amp;#61; *(S.top - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; e;\n}\n\n&lt;span class=\"hljs-function\"&gt;NElemType &lt;span class=\"hljs-title\"&gt;GetTopN&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;SqStack_opnd S&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//int型取栈顶&lt;/span&gt;&lt;/span&gt;\n{\n    NElemType e;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (S.top &amp;#61;&amp;#61; S.&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR; &lt;span class=\"hljs-comment\"&gt;//栈空&lt;/span&gt;\n    e &amp;#61; *(S.top - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; e;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;In&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; ch&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//判断是否为运算符&lt;/span&gt;&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ch &amp;#61;&amp;#61; oper[i])\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Precede&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; theta1, &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; theta2&lt;/span&gt;)&lt;/span&gt;\n{ &lt;span class=\"hljs-comment\"&gt;//判断运算符优先级&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((theta1 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; theta2 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;) || (theta1 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; theta2 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;))\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#61;&amp;#39;&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (theta1 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; || theta1 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt; || theta2 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; || (theta1 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt; || theta1 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;) &amp;amp;&amp;amp; (theta2 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt; || theta2 &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;))\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Operate&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; first, &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; theta, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; second&lt;/span&gt;)&lt;/span&gt;\n{ &lt;span class=\"hljs-comment\"&gt;//计算两数运算结果&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt; (theta)\n    {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; first &amp;#43; second;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; first - second;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; first * second;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; first / second;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;EvaluateExpression&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; c, theta, x; &lt;span class=\"hljs-comment\"&gt;//c为输入的字符&amp;#xff0c;theta为运算符&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a, b, num;\n    SqStack_optr OPTR;\n    SqStack_opnd OPND;\n    InitStackS(OPTR); &lt;span class=\"hljs-comment\"&gt;//初始化OPTR栈&lt;/span&gt;\n    PushS(OPTR, &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//将表达式起始符“#”压入OPTR栈&lt;/span&gt;\n    InitStackN(OPND); &lt;span class=\"hljs-comment\"&gt;//初始化OPND栈&lt;/span&gt;\n    cin &amp;gt;&amp;gt; c;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (c !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt; || GetTopS(OPTR) !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!In(c)) &lt;span class=\"hljs-comment\"&gt;// In(c, OP)判断c是否为运算符&lt;/span&gt;\n        {\n            num &amp;#61; c - &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n            PushN(OPND, num);\n            cin &amp;gt;&amp;gt; c;\n        } &lt;span class=\"hljs-comment\"&gt;//不是运算符则进栈&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt; (Precede(GetTopS(OPTR), c)) &lt;span class=\"hljs-comment\"&gt;//判定OPTR的栈顶运算符1与读入的运算符2间的优先关系&lt;/span&gt;\n            {\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;// 新输入的算符c优先级高&amp;#xff0c;c进栈&lt;/span&gt;\n                PushS(OPTR, c);\n                cin &amp;gt;&amp;gt; c;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#61;&amp;#39;&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;// 脱括号并接收下一字符&lt;/span&gt;\n                PopS(OPTR, x);\n                cin &amp;gt;&amp;gt; c;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;//新输入的算符c优先级低&amp;#xff0c;即栈顶算符优先权高&lt;/span&gt;\n                &lt;span class=\"hljs-comment\"&gt;//出栈并将运算结果入栈OPND&lt;/span&gt;\n                PopS(OPTR, theta); &lt;span class=\"hljs-comment\"&gt;//弹出OPTR栈顶的运算符&lt;/span&gt;\n                PopN(OPND, b);\n                PopN(OPND, a);                     &lt;span class=\"hljs-comment\"&gt;//弹出OPND栈顶的两个运算数&lt;/span&gt;\n                PushN(OPND, Operate(a, theta, b)); &lt;span class=\"hljs-comment\"&gt;//进行二元运算ab,将运算结果压入OPND栈&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            } &lt;span class=\"hljs-comment\"&gt;//switch&lt;/span&gt;\n        }     &lt;span class=\"hljs-comment\"&gt;//else&lt;/span&gt;\n    }         &lt;span class=\"hljs-comment\"&gt;//while&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (GetTopN(OPND));\n} &lt;span class=\"hljs-comment\"&gt;//EvaluateExpression&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; result;\n    result &amp;#61; EvaluateExpression();\n    cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; endl;\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算", "Question": ["C++、栈实现四则运算，编译可过结果不对", ["#include", "#include", "#define OK 1", "#define ERROR 0", "#define MAXSIZE 100", "#define OVERFLOW -2", "\n", "const char oper[7]={'+','-','*','/','(',')','#'};", "\n", "using namespace std;", "typedef char SElemType;//定义字符类型", "typedef int NElemType;//定义int类型", "typedef int Status;", "\n", "typedef struct//字符型栈的存储结构", "{", "    SElemType *base;", "    SElemType *top;", "    int stackSize;", "}SqStack_optr;", "\n", "typedef struct//int型栈的存储结构", "{", "    NElemType *base;", "    NElemType *top;", "    int stackSize;", "}SqStack_opnd;", "\n", "Status InitStackS(SqStack_optr &S)//字符型栈的初始化", "{", "    S.base = new SElemType[MAXSIZE];", "    if(!S.base)  return OVERFLOW;", "    S.top=S.base;", "    S.stackSize = MAXSIZE;", "    return OK;", "}", "\n", "Status InitStackN(SqStack_opnd &S)//int型栈的初始化", "{", "    S.base = new NElemType[MAXSIZE];", "    if(!S.base)  return OVERFLOW;", "    S.top=S.base;", "    S.stackSize = MAXSIZE;", "    return OK;", "}", "\n", "Status PushS (SqStack_optr &S,SElemType e)//字符型进栈", "{", "    if(S.top-S.base==S.stackSize)  return ERROR;", "    *S.top++=e;", "    return OK;", "}", "\n", "Status PushN (SqStack_opnd &S,NElemType e)//int型进栈", "{", "    if(S.top-S.base==S.stackSize)  return ERROR;", "    *S.top++=e;", "    return OK;", "}", "\n", "Status PopS ( SqStack_optr &S, SElemType &e )//字符型栈顶元素退栈", "{ if ( S.top==S.base )", " return ERROR; // 栈空", " e = * -- S.top; // --S.top; e=*S.top;", " return OK;", "} //Pop", "\n", "Status PopN ( SqStack_opnd &S, NElemType &e )//int型栈顶元素退栈", "{ if ( S.top==S.base )", " return ERROR; // 栈空", " e = * -- S.top; // --S.top; e=*S.top;", " return OK;", "} //Pop", "\n", "SElemType GetTopS ( SqStack_optr S)//字符型取栈顶", "{", " SElemType e;", " if ( S.top==S.base )", " return ERROR; //栈空", " e = *(S.top-1);", " return e;", "}", "\n", "NElemType GetTopN ( SqStack_opnd S)//int型取栈顶", "{", " NElemType e;", " if ( S.top==S.base )", " return ERROR; //栈空", " e = *(S.top-1);", " return e;", "}", "\n", "bool In(char ch)//判断是否为运算符", "{", "    for(int i=0;i<7;i++)", "    {", "        if(ch==oper[i])", "        return true;", "    }", "    return false;", "}", "\n", "char Precede(char theta1, char theta2)", "{//判断运算符优先级", "    if ((theta1 == '(' && theta2 == ')') || (theta1 == '#' && theta2 == '#'))", "    {", "        return '=';", "    }", "    else if (theta1 == '(' || theta1 == '#' || theta2 == '(' || (theta1", "            == '+' || theta1 == '-') && (theta2 == '*' || theta2 == '/'))", "    {", "        return '<';", "    }", "    else", "        return '>';", "}", "\n", "int Operate(int first, char theta, int second)", "{//计算两数运算结果", "    switch (theta)", "    {", "    case '+':", "        return first + second;", "    case '-':", "        return first - second;", "    case '*':", "        return first * second;", "    case '/':", "        return first / second;", "    }", "    return 0;", "}", "\n", "EvaluateExpression()", "{", "    char c,theta,x;//c为输入的字符，theta为运算符", "    int a,b,num;", "    SqStack_optr OPTR;", "    SqStack_opnd OPND;", "    InitStackS(OPTR);//初始化OPTR栈", "    PushS (OPTR, '#');//将表达式起始符“#”压入OPTR栈", "    InitStackN(OPND);//初始化OPND栈", "    cin>>c;", "    while ( c!='#' || GetTopS(OPTR)!='#' )", "    {", "       if (! In (c)) // In(c, OP)判断c是否为运算符", "          {", "          num=c-'0';", "          PushN(OPND, num);", "          cin>>c;", "          } //不是运算符则进栈", "       else", "       {", "       switch (Precede(GetTopS(OPTR),c))//判定OPTR的栈顶运算符1与读入的运算符2间的优先关系", "        {  case '<': // 新输入的算符c优先级高，c进栈", "               PushS(OPTR, c);", "               cin>>c;", "               break;", "           case '=': // 脱括号并接收下一字符", "               PopS(OPTR, x);", "               cin>>c;", "               break;", "           case '>': //新输入的算符c优先级低，即栈顶算符优先权高", "           //出栈并将运算结果入栈OPND", "               PopS ( OPTR, theta); //弹出OPTR栈顶的运算符", "               PopN ( OPND, b);", "               PopN ( OPND, a); //弹出OPND栈顶的两个运算数", "               PushN ( OPND, Operate(a, theta, b) ); //进行二元运算ab,将运算结果压入OPND栈", "               break;", "        } //switch", "        }//else", "    } //while", "    return(GetTopN(OPND));", " } //EvaluateExpression", "\n", " int main()", " {", "     int result;", "     result=EvaluateExpression();", "    cout<<resu<<endl;", "     system(\"pause\");", "     return 0;", " }"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是数据库中的并集运算&amp;#xff0c;在关系型数据库中采用union关键字来表达&amp;#xff0c;如上题中&amp;#xff0c;表达成sql语句就是&amp;#xff1a;&lt;br /&gt;select * from R&lt;br /&gt;union&lt;br /&gt;select * from S&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["数据库中关系代数的运算", ["问题遇到的现象和发生背景", "\n", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "这个RUS的答案对不对，我咋感觉是有点问题啊", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "运行结果及详细报错内容", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "程序设计"}
{"Answer": "```\r\n喵  10:26:56\r\nhttps://ask.csdn.net/questions/1080789\r\n前者是逻辑not，结果是一个Boolean，后者则是按位取反哦\r\n\r\n喵  10:27:34\r\n定义一个数组\r\nString[] arr = {zero, one, two, ...}\r\n然后直接取下标即可\r\n\r\n\r\n```", "Konwledge_Point": "关系运算", "Question": ["Java语言!和~运算的区别是什么，还有什么是补码，它和取反有什么关系么", ["Java语言!和~运算的区别是什么，还有什么是补码，它和取反有什么关系么", "\nJava语言!和~运算的区别是什么，还有什么是补码，它和取反有什么关系么"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; result, name;\n &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; birthday; \n&lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,&amp;amp;name);\n&lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;birthday);\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(name&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;Z&amp;#39;&lt;/span&gt;&amp;amp;&amp;amp;birthday&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;2000&lt;/span&gt;){\n    result&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;;\n}&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n    result&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;N&amp;#39;&lt;/span&gt;;\n}\n \n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,result);\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算", "Question": ["c语言的if_else基础题型求解。", ["用if_else语句完成：定义字符变量result, name, 整型birthday。然后输入一个字母用name记录，输入一个年份用birthday记录。用逻辑，关系运算判断：如果name是你本人的姓氏首字母，并且birthday是你本人的生日，则在if复合语句中令result等于’Y’、然后输出result；否则在else复合语句中令result等于’N’、然后输出result。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;把solution改成x2就行拉&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;syms&lt;/span&gt; x2\n&lt;span class=\"hljs-attribute\"&gt;F&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n&lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;;\n&lt;span class=\"hljs-attribute\"&gt;f1&lt;/span&gt;&amp;#61;(x2/(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#43;x2))*(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;-x2)*(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;-((-&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;&amp;#43;F&amp;#43;&lt;span class=\"hljs-number\"&gt;120&lt;/span&gt;*(x2/(x2&amp;#43;&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;)))*((F*(B-x2))/(F/&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;))/F/&lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;))*(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;-(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#43;F/&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;02&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;*(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;/(F*x2))));\n&lt;span class=\"hljs-attribute\"&gt;x2&lt;/span&gt;&amp;#61;vpasolve(f1,x2,[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3000&lt;/span&gt;]);\n&lt;span class=\"hljs-attribute\"&gt;x1&lt;/span&gt;&amp;#61;(F*(B-x2))./(&lt;span class=\"hljs-number\"&gt;123&lt;/span&gt;&amp;#43;F&amp;#43;&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;*x2);\n&lt;span class=\"hljs-attribute\"&gt;x3&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;&amp;#43;F&amp;#43;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;*x2).*((F*(B-x2))./(F&amp;#43;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;*x2)); \n&lt;span class=\"hljs-attribute\"&gt;x4&lt;/span&gt;&amp;#61;(-&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;&amp;#43;F*&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;*(x2./(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;*x2&amp;#43;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;))).*((&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;&amp;#43;F/&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;*(x2./(x2&amp;#43;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;)))); \n&lt;span class=\"hljs-attribute\"&gt;x5&lt;/span&gt;&amp;#61;(-&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;&amp;#43;F&amp;#43;(x2./(x2&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;))).*(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;/F&amp;#43;&lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;./(F*x2)).*((F*(B-x2))./(F&amp;#43;(x2./(x2&amp;#43;B))));\n&lt;span class=\"hljs-attribute\"&gt;p1&lt;/span&gt;&amp;#61;[x1,x2,x3,x4,x5]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attr\"&gt;p1&lt;/span&gt; &amp;#61;\n \n&lt;span class=\"hljs-section\"&gt;[                              30/247,   0,                               315,                                -27,                               -Inf]&lt;/span&gt;\n&lt;span class=\"hljs-section\"&gt;[ 0.083573487031700288184438040345821, 1.0, 40.863636363636363636363636363636, -27.045454545454545454545454545455, -4994.4444444444444444444444444444]&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可见有5列呢&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["matlab结果显示为表达式，为何不能计算结果", ["%想应用matlab求出x2的值，再通过x2与x1,x3,x4,x5的关系式，\n求出x1,x3,x4,x5的值，但是matlab输出结果只有x2的值，\nx1,x3,x4,x5都是表达式呈现的，没有数值结果。\n大致程序如下，请求大家指点\n\n\nsyms x1 x2 x3 x4 x5\nF=0.5;\nB=30;\nf1=(x2/(2+x2))*(1-x2)*(1-((", "-5", "+F", "+120", "*(x2/(x2", "+12", ")))*((F*(B-x2))/(F/0.2", "+20", "))/F/200))*(1-(2+F/0.02", "+50", "*(0.6/(F*x2))));\nsolution=vpasolve(f1,x2,[0,3000])\nx1=(F*(B-x2))/(123+F", "+50", "*x2);\nx3=(10+F", "+5", "*x2)*((F*(B-x2))/(F", "+5", "*x2)); \nx4=(", "-5", "+F*4", "+5", "*(x2/(5*x2", "+5", ")))*((4+F/0.1", "+20", "*(x2/(x2", "+10", ")))); \nx5=(", "-5", "+F+(x2/(x2", "+2", ")))*(10/F", "+12", "/(F*x2))*((F*(B-x2))/(F+(x2/(x2+B))));\np1=[x1,x2,x3,x4,x5]\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;HAVING子句用于过滤掉组后不符合条件的行&amp;#xff0c;通常与GROUP BY配合使用。在查询中&amp;#xff0c;HAVING子句需要比较一个分组条件&amp;#xff0c;这个分组条件是经过COUNT&amp;#xff08;I.items&amp;#xff09;函数处理后的数字。如果直接使用COUNT&amp;#xff08;I.items&amp;#xff09;&amp;#xff0c;SQL可能会产生错误&amp;#xff0c;因为COUNT&amp;#xff08;I.items&amp;#xff09;表示的是商品的数量&amp;#xff0c;而不是分组数。&lt;/p&gt;\n&lt;p&gt;因此&amp;#xff0c;在HAVING子句中使用select子句是为了在分组条件前额外对商品数量进行一次查询&amp;#xff0c;以便与分组条件进行比较。&lt;/p&gt;\n&lt;p&gt;最终的查询应该是这样的&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-sql\"&gt;&lt;span class=\"hljs-keyword\"&gt;SELECT&lt;/span&gt; S.shop_name\n&lt;span class=\"hljs-keyword\"&gt;FROM&lt;/span&gt; Shops S\n&lt;span class=\"hljs-keyword\"&gt;JOIN&lt;/span&gt; Items I\n&lt;span class=\"hljs-keyword\"&gt;ON&lt;/span&gt; S.shop_id &amp;#61; I.shop_id\n&lt;span class=\"hljs-keyword\"&gt;GROUP&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;BY&lt;/span&gt; S.shop_name\n&lt;span class=\"hljs-keyword\"&gt;HAVING&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;COUNT&lt;/span&gt;(I.items) &amp;#61; \n  (&lt;span class=\"hljs-keyword\"&gt;SELECT&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;COUNT&lt;/span&gt;(*)\n   &lt;span class=\"hljs-keyword\"&gt;FROM&lt;/span&gt; Items\n   &lt;span class=\"hljs-keyword\"&gt;WHERE&lt;/span&gt; shop_id &amp;#61; S.shop_id)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请注意&amp;#xff0c;这是一种通用方法&amp;#xff0c;对于您具体的需求可能需要进行一些调整。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["SQL关系除法运算进行购物篮分析", ["题目：查询囊括了表Items中所有商品的店铺", "\n", "疑问：不太理解HAVING子句中，等号右边为什么不可以是COUNT(I.items) 为什么要再写一个select子句？", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "你这不是A对象里的方法吗", "Konwledge_Point": "关系运算", "Question": ["java语法问题，运算顺序", ["new A( ).B( )", "\n运算顺序是如何的", "\n如何理解这种运算顺序", "\njava中的.号是从属关系", "\n方法的方法是A( ).B( )", "\n对象的方法", "\n类的方法", "\n对象的对象都可以用.号连接吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数据库每个地方都可以考选择填空&amp;#xff0c;看你们老师有没有給你们提纲&amp;#xff0c;这样子的话就可以快速的将题目写出来。&lt;/p&gt;\n\n&lt;p&gt;大题出后面的几率会比较大&amp;#xff0c;难度会比较高嘛&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["求大佬分析一下数据库原理提纲，并参照提纲给点学习建议。谢谢", ["一、考试基本要求", "\n\n", "本课程是一门数据库系统的基本概念和基本理论的课程。该课程考试的基本要求：", "\n\n", "掌握与数据库有关的基本概念，了解数据库的设计，应用开发和运行维护过程。", "了解关系模型的数学基础和关系数据库的规范化理论，掌握并学会使用关系数据库系统的标准语言SQL。", "\n\n", "二、考核知识范围及考核要求", "\n\n", "1", "、绪论", "\n\n", "数据库系统概述：", "数据、数据库、数据库管理系统、数据库系统、数据库系统的特点等基本概念的定义与理解。", "\n\n", "数据模型：", "层次、网状、关系、E-R模型等的构造形式及特点。重点是关系及E-R模型，要求熟练掌握其概念、技术及建模方法。", "\n\n", "数据库系统结构：", "数据库系统的三级模式与二级映象。", "\n\n", "2", "、关系数据库", "\n\n", "掌握关系模型的数学定义，关系模型、关系模式、关系数据库等基本概念；掌握关系代数的九种运算，即专门关系运算能熟练运用。", "\n\n", "3", "、关系数据库标准语言", "SQL", "\n\n", "掌握各类SQL语句的语法构成、语义与功能，特别是Select语句的不同应用方法。包括基本的定义及修改，索引的建立和删除；掌握SQL的数据操纵，连接查询，嵌套查询，库函数的应用；了解视图的定义，视图的查询，视图的更新及视图的优点。", "\n\n", "4", "、数据库安全性", "\n\n", "掌握计算机系统的三类安全性问题以及数据库安全性控制的基本技术。", "\n\n", "5", "、数据库完整性", "\n\n", "掌握完整性约束条件及完整性控制。", "\n\n", "6", "、关系数据理论", "\n\n", "掌握关系数据库理论提出的背景，对给定的数据如何改造数据模型；掌握函数依赖的定义：函数依赖中的部分函数依赖、完全函数依赖、传递函数依赖；对给定的实际问题可以确定函数依赖；掌握码的定义，对实际问题可以确定码；掌握1NF，2NF，3NF，BCNF的定义，对给定的关系模式可以确定属于什么级范式。", "\n\n", "7", "、数据库设计", "\n\n", "掌握数据库设计步骤；实际问题的需求分析；概念模型E-R图； E-R图向数据模型的转换；数据库的物理设计以及应用实例等。", "\n\n", "8", "、数据库恢复技术", "\n\n", "掌握事务的概念及特征，数据库恢复的基本原则；恢复的具体实现方法。", "\n\n", "9", "、并发控制", "\n\n", "掌握并发控制的基本概念，并发控制与实现技术，尤其是封锁技术的实施等。", "\n\n", "三、考试形式与试卷结构", "\n\n", "1", "、试卷分数及考试时间", "\n\n", "满分为100分，考试时间为120分钟。", "\n\n", "2", "、答题方式", "\n\n", "答题方式为闭卷、笔试。", "\n\n", "3", "、试卷题型结构", "\n\n", "题型", "\n\n", "题量", "\n\n", "分值", "\n\n", "单项选择题", "\n\n", "15", "\n\n", "30", "\n\n", "填空题", "\n\n", "10", "\n\n", "10", "\n\n", "判断题", "\n\n", "10", "\n\n", "10", "\n\n", "简答题", "\n\n", "4", "\n\n", "20", "\n\n", "综合应用题", "\n\n", "2", "\n\n", "30", "\n\n", "总计", "\n\n", "41", "\n\n", "100", "\n\n", " ", "\n\n", " ", "\n\n", " ", "\n\n", " ", "\n\n", " ", "\n\n", " ", "\n\n", "四、主要参考书目", "\n\n", "1、《数据库系统概论》王珊，萨师煊著， 2014年（第五版），高等教育出版社。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;根本问题&amp;#xff0c;是你不理解 if  else&lt;br /&gt;这是条件语句&amp;#xff0c;是一套&amp;#xff0c;要么走if  要么走else&lt;br /&gt;按照你这样写&amp;#xff0c;是不是就只判断了一次&amp;#xff1f;&lt;br /&gt;那怎么办&amp;#xff1f;判断三次 if 就好了&amp;#xff0c;明白了否&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["用关系和条件运算求四个数中的最大值", ["\n", "麻烦大家看看我是哪一步出错了呀，怎么会部分正确呢，我感觉没毛病啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结构体类型相当于int,float等普通数据类型&amp;#xff0c;变量是用类型定义的变量。相当于int a;中int和a的区别&lt;br /&gt;所以你说结构体变量与类型和数据变量和类型&amp;#xff0c;他们是类似的&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["结构体变量与类型和数据变量和类型，它们的关系一样吗？", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a&amp;gt;b?a:b&lt;br /&gt;这不就是三目运算符吗&lt;br /&gt;你会用但是不知道它叫什么是吗&lt;br /&gt;三目运算符也叫三元运算符&amp;#xff0c;因为它是由三个表达式组成的&lt;br /&gt;a?b:c&amp;#xff0c;当a的值是true&amp;#xff0c;返回b&amp;#xff0c;否则返回c&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["请问我这个与三目运算法有啥关系啊", ["注释部分是我看编程课敲的，课上老有人说三目运算法，求问一下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;matlab程序运行的速度受到如下因素影响&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;1&amp;#xff09;matlab版本&amp;#xff08;有较大影响&amp;#xff0c;以本篇博客出现的现象为例&amp;#xff09;&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;2&amp;#xff09;电脑配置&amp;#xff08;CPU主频、内存大小、计算机位数等&amp;#xff09;&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;3&amp;#xff09;电脑当前运行状态&amp;#xff08;资源占用率等&amp;#xff0c;因为电脑每时每刻的资源占用率都不一样&amp;#xff0c;因此这一点为测量matlab程序运行时间带来较大随机性&amp;#xff09;&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;4&amp;#xff09;matlab文件和所调用文件的目录深度&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;5&amp;#xff09;matlab运行的程序复杂度&amp;#xff08;循环的次数&amp;#xff0c;开辟的空间大小&amp;#xff0c;是否有画图以及是几维的画图等&amp;#xff09;&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;6&amp;#xff09;matlab自身的设置&amp;#xff08;如默认的变量长度和精度等设置不同会导致开辟的内存空间大小不同&amp;#xff09;&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;7&amp;#xff09;每次运行程序是否预分配内存&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;8&amp;#xff09;是否是第一次运行&amp;#xff08;和第七条有相似的道理&amp;#xff0c;第二次运行程序可以使用第一次已经开辟的内存空间&amp;#xff1b;很多人把这一点理解为matlab的“记忆性”&amp;#xff09;&amp;#xff1b;\n参考&amp;#xff1a;&lt;a href=\"https://www.cnblogs.com/CCWangsj/p/13125030.html\"&gt;https://www.cnblogs.com/CCWangsj/p/13125030.html&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["有哪些硬件能影响matlab跑代码的速度", ["请问有哪些硬件会影响matlab运行速度？我的17年的游戏本画个等值线图都要等好久"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;假设qa开始是3x^2&amp;#xff08;x加上去为了好看&amp;#xff09;&amp;#xff0c;qb开始是2x^3&amp;#xff0c;那么这种情况是先打印qa的&amp;#xff0c;因为2比3小&amp;#xff0c;也就是add里面的m&amp;lt;n小的情况&amp;#xff0c;因为qa已经打印&amp;#xff0c;因此qa&amp;#61;qa next&amp;#xff0c;qb还没动留着下次再做比较。那如果m&amp;#61;n&amp;#xff0c;这样就要先算前面的3&amp;#43;2了&amp;#xff0c;即sum&amp;#61;qa的a&amp;#43;qb的a&amp;#xff0c;因为m&amp;#61;&amp;#61;n&amp;#xff0c;所以print (sum, m或者n随便一个)&amp;#xff0c;这里qa和qb已经相加输出了&amp;#xff0c;qa和qb都要换到下一个节点。后面m&amp;gt;n&amp;#xff0c;同m&amp;lt;n一样。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["一元多项式加法运算的实现", ["题目描述", "编程实现一元多项式的加法运算。（要求用链表实现）", "\n", "输入", "第一行为一元多项式A， 以 0,0 作为输入结束；", "\n", "第二行为一元多项式B， 以 0,0 作为输入结束。", "\n", "输出", "多项式A和多项式B的和。", "\n", "样例输入", "5,3 7,8 9,15 0,0", "2,0 6,3 -7,8 0,0", "\n", "样例输出//一般格式发不出去，不符合要求\n", "2", "x", "0", "+", "11", "x", "3", "+", "9", "x", "^", "1", "\n", "\n", "\n", "#include<stdio.h>", "\n", "#include<malloc.h>", "\nint flag;\ntypedef struct node\n{\n    int a;\n    int b;\n    struct node *next;\n}Linklist;\nvoid creat(Linklist *&L)\n{\n    int m,n;\n    Linklist *s,*r;\n    L=(Linklist *)malloc(sizeof(Linklist));\n    ", "r", "=L;\n    ", "while", "(1)\n    {\n        s=(Linklist *)malloc(sizeof(Linklist));\n        scanf(", "\"%d,%d\"", ",&m,&n);\n        ", "if", "(", "m", "==0&&n==0)\n            break;\n        s->", "a", "=m;\n        s->", "b", "=n;\n        r->", "next", "=s;\n        ", "r", "=s;\n    }\n    r->", "next", "=", "NULL", ";\n}\n\nvoid ", "add", "(Linklist *&Qa,Linklist *&Qb)\n{\n     \n    Linklist *qa,*qb;\n    ", "qa", "=Qa->next;\n    ", "qb", "=Qb->next;\n    ", "while", "(1)\n    {\n        int m,n,sum;\n        ", "m", "=qa->b;\n        ", "n", "=qb->b;\n        ", "if", "(m<n)\n        {\n            printf(", "\"%dx^%d+\"", ",qa->a,qa->b);\n            ", "qa", "=qa->next;\n        }\n        ", "else", " ", "if", "(", "m", "==n)\n        {\n            ", "sum", "=qa->a+qb->a;\n            ", "if", "(sum!=0)\n            {\n                qa->", "a", "=sum;\n                printf(", "\"%dx^%d+\"", ",qa->a,qa->b);\n            }\n            ", "qa", "=qa->next;\n            ", "qb", "=qb->next;\n        }\n        ", "else", "\n        {\n            printf(", "\"%dx^%d+\"", ",qb->a,qb->b);\n            ", "qb", "=qb->next;\n        }\n        ", "if", "(", "qa", "==NULL)\n        {\n            ", "flag", "=1;\n            break;\n        }\n        ", "if", "(", "qb", "==NULL)\n        {\n            ", "flag", "=2;\n            break;\n        }\n    }\n    ", "if", "(", "flag", "==1)\n    {\n        ", "while", "(qb->next!=", "NULL", ")\n        {\n            printf(", "\"%dx^%d+\"", ",qb->a,qb->b);\n            ", "qb", "=qb->next;\n        }\n        printf(", "\"%dx^%d\"", ",qb->a,qb->b);\n    }\n    ", "if", "(", "flag", "==2)\n    {\n        ", "while", "(qa->next!=", "NULL", ")\n        {\n        printf(", "\"%dx^%d+\"", ",qa->a,qa->b);\n        ", "qa", "=qa->next;\n        }\n        printf(", "\"%dx^%d\"", ",qa->a,qa->b);\n    }\n \n     \n}\nint main()\n{\n    Linklist *pa,*pb;\n    creat(pa);\n    creat(pb);\n    ", "add", "(pa,pb);\n    return 0;\n}\n\n", "\n", "我感觉add函数里面m，n比大小是对应的关系（QA第一个数和QB第一个数比较，QA第二个数和QB第二个数比较），但是如果这样显然不符合题意，能讲一下add函数吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;也就是说会把int类型转成unsigned int来计算。&lt;br /&gt;10的二级制是&amp;#xff1a;  0000 0000  0000 0000  0000 0000  0000 1010&lt;br /&gt;-10的二进制是在10的二进制码基础上取反&amp;#43;1&amp;#xff0c;也就是 1111 1111 1111 1111 1111 1111 1111 0110&lt;br /&gt;-10的十六进制是 FF FF FF F6&amp;#xff0c;转成unsigned int后值是 4294967286&amp;#xff0c; 4294967286除以500取余数就是286&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["c++中求模取余运算%的问题（int % unsigned）", ["本人在调试他人代买的过程中，无意间注意到了这样一个问题：int类型的负数，与unsigned类型的正数，进行求模（取余）%运算，但是结果并不是我想要的，我猜测是是unsigned类型闯祸，但是查找资料没有头绪。", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", " ", "{\n    ", "int", " a = ", "-100", ";\n    ", "unsigned", " b = ", "500", ";\n    a %= b;\n    cout << a << endl;\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n\n}\n\n", "\n", "运行结果是：196", "\n", "我一开始以为运行结果会是-100，结果却是196。如果将代码中的a赋值为-10，那么结果就是286。似乎都跟296这个数有关系？为啥会这样？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在Union函数中&amp;#xff0c;使用了错误的参数来调用LocateElem函数。在代码中&amp;#xff0c;你调用了LocateElem(*La, i, compare)&amp;#xff0c;其中i是Lb中的元素位置&amp;#xff0c;而不是元素值。因此&amp;#xff0c;LocateElem无法正确地找到相应的元素。&lt;/p&gt;\n&lt;p&gt;要修复此问题&amp;#xff0c;请更改代码中的ListInsert语句&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!&lt;span class=\"hljs-constructor\"&gt;LocateElem(&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;La,&lt;span class=\"hljs-params\"&gt;e&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;compare&lt;/span&gt;)&lt;/span&gt;)    &lt;span class=\"hljs-comment\"&gt;/*若La中不存在和e相同的元素&amp;#xff0c;则插入之*/&lt;/span&gt; \n    &lt;span class=\"hljs-constructor\"&gt;ListInsert(La,&lt;span class=\"hljs-operator\"&gt;&amp;#43;&amp;#43;&lt;/span&gt;La_len,&lt;span class=\"hljs-params\"&gt;e&lt;/span&gt;)&lt;/span&gt;;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里将查找的元素从i更改为e&amp;#xff0c;这样就可以正确地找到Lb中的元素&amp;#xff0c;并将其添加到La中。&lt;/p&gt;\n&lt;p&gt;另外还有一个小问题&amp;#xff1a;在ListInsert函数中&amp;#xff0c;如果i等于L-&amp;gt;length&amp;#xff0c;插入的元素会覆盖最后一个元素。要解决此问题&amp;#xff0c;请将if语句中的等号去掉&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;if(i &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; L-&amp;gt;length)\n    L-&amp;gt;data[i] &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; e&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;应该变成&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(i &amp;#61;&amp;#61; &lt;span class=\"hljs-type\"&gt;L&lt;/span&gt;-&amp;gt;length &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    &lt;span class=\"hljs-type\"&gt;L&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i - 1] &amp;#61; e;&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样可以确保新元素始终插入到表末尾。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["c语言求两个集合的合并运算", ["输出错误，不晓得哪个函数出错了，验证过Union函数没有错误", "\n", "\n#", "include", "<stdio.h>\n#", "include", "<", "string", ".h>\n#define OK ", "1", "\n#define ERROR ", "0", "\n#define TRUE ", "1", "\n#define FALSE ", "0", "\n#define MAXSIZE ", "20", "\ntypedef ", "int", " Status;\ntypedef ", "int", " ElemType;\ntypedef ", "struct", "\n{\n    ElemType data", "[MAXSIZE]", ";   ", "/*存储数组元素*/", "\n    ", "int", " length;               ", "/*表当前有效长度*/", " \n}SqList;", "/*数组存储类型名*/", " \n", "int", " ", "ListLength(SqList L)", ";\nStatus ", "GetElem(SqList L,", "int", " ", "i", ",ElemType ", "*", "e", ")", ";\n", "int", " ", "LocateElem(SqList L,ElemType ", "e", ",", "int", " ", "compare", "(ElemType ", "x", ",ElemType ", "y", ")", ");\n", "int", " compare(ElemType x,ElemType y);\nStatus ", "ListInsert(SqList ", "*", "L,ElemType ", "i", ",ElemType ", "e", ")", ";\nStatus  ", "ListEmpty(SqList L)", ";\nvoid ", "Union(SqList ", "*", "La,SqList Lb)", ";\n\n", "int", " main", "()", "\n{\n    ", "int", " i; \n    ", "char", " ch;\n    SqList La,Lb;\n    ", "La", ".", "length=", "0", ";\n    ", "Lb", ".", "length=", "0", ";\n    ", "for", "(i=", "0", ";;i++)\n    {\n        scanf(", "\"%d%c\"", ",&", "La", ".", "data", "[", "i", "]", ",&ch);\n        ", "La", ".", "length++;\n        ", "if", "(ch==", "'\\n'", ")\n            break;\n    }\n    ", "for", "(i=", "0", ";;i++)\n    {\n        scanf(", "\"%d%c\"", ",&", "Lb", ".", "data", "[", "i", "]", ",&ch);\n        ", "Lb", ".", "length++;\n        ", "if", "(ch==", "'\\n'", ")\n            break;\n    }\n    ", "if", "(!", "ListEmpty(La)", "&&!", "ListEmpty(Lb)", ")\n        ", "Union(&La,Lb)", ";\n    ", "for", "(i=", "0", ";i<", "La", ".", "length;i++)\n        printf(", "\"%d \"", ",", "La", ".", "data", "[", "i", "]", ");\n    return ", "0", ";\n}\n\n", "/*返回L中数据元素个数*/", "\n", "int", " ", "ListLength(SqList L)", "\n{\n    return ", "L", ".", "length;\n} \n\n", "/*用e返回L中第i个数据元素的值*/", "\nStatus ", "GetElem(SqList L,", "int", " ", "i", ",ElemType ", "*", "e", ")", "\n{\n    ", "if", "(", "L", ".", "length==", "0", "||", "i<1", "||", "i>", "L", ".length)\n        return ", "ERROR", ";\n    ", "*", "e=", "L", ".data[i-1];\n    return ", "OK", ";\n} \n\n", "/", "*", "返回", "L", "中第1个与e满足关系compare()的数据元素的位序。若这样的数据元素不存在，则返回值为0", "*", "/", "\n", "int", " ", "LocateElem(SqList L,ElemType ", "e", ",", "int", " ", "compare", "(ElemType ", "x", ",ElemType ", "y", ")", ")\n{\n    ", "int", " i;\n    ", "for", "(i=0;i<", "L", ".length;i", "++", ")\n    {\n        ", "if", "(compare(", "L", ".data[i],e))\n            return i+1;\n    }\n    return 0;\n} \n\n", "int", " compare(", "ElemType", " x,", "ElemType", " y)\n{\n    ", "if", "(x", "==", "y)\n        return 1;\n    ", "else", "\n        return 0;\n}\n\n", "/", "*", "在", "L", "中第i个位置之前插入新的数据元素e,", "L", "的长度+1", "*", "/", "\n", "Status", " ", "ListInsert(SqList ", "*", "L,ElemType ", "i", ",ElemType ", "e", ")", "\n{\n    ", "int", " k;\n    ", "if", "(i", "==", "L", "->length)\n        ", "L", "->data[i]=e;\n    ", "else", "\n    {\n        ", "for", "(k=", "L", "->length-1;k>=i-1;k--)\n        {\n            ", "L", "->data[k+1]=", "L", "->data[k];\n        }\n        ", "L", "->data[i-1]=e;\n    }\n    ", "L", "->length", "++", ";\n} \n\n", "/", "*", "若", "L", "为空表，则返回", "TRUE", "，否则返回", "FALSE", "*", "/", "\n", "Status", "  ", "ListEmpty(SqList L)", "\n{\n    ", "if", "(", "L", ".length", "==", "0)\n        return ", "TRUE", ";\n    ", "else", "\n        return ", "FALSE", ";\n}\n\n", "/", "*", "将所有在表", "Lb", "中但不在表", "La", "中的数据元素插入到", "La", "中", "*", "/", "\nvoid ", "Union(SqList ", "*", "La,SqList Lb)", "\n{\n    ", "ElemType", " e;\n    ", "int", " ", "La_len", ",", "Lb_len", ";\n    ", "int", " i;\n    ", "La_len", "=", "ListLength(", "*", "La)", ";   ", "/", "*", "求", "La", "长度", "*", "/", "\n    ", "Lb_len", "=", "ListLength(Lb)", ";   ", "/", "*", "求", "Lb", "长度", "*", "/", " \n    ", "for", "(i=1;i<=", "Lb_len", ";i", "++", ")\n    {\n        ", "GetElem(Lb,", "i", ",&", "e", ")", ";\n        ", "if", "(!", "LocateElem(", "*", "La,", "i", ",", "compare", ")", ")    ", "/", "*", "若", "La", "中不存在和e相同的元素，则插入之", "*", "/", " \n            ", "ListInsert(La,", "++", "La_len,", "e", ")", ";\n    }\n}  \n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个代码格式看起来实在是有点费劲&amp;#xff0c;根据你的描述&amp;#xff0c;我推测是因为复制出来的共有变量赋值问题&amp;#xff0c;比如下图这两个变量&amp;#xff0c;建议检查一下赋值是否正确&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/71785248164614.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["Unity复制体与本体的逻辑关系", ["我在写追踪敌人的时候，写一个机器人追踪的时候没有问题，但是想要复制多几个机器人的时候，出现了问题。在检测到有敌人时，应该是所有机器人都要追踪才对，但是并没有，只有本体追踪了。请问这是什么原因呢？代码如下", "\n", "//这个是机器人代码", "using System.Collections;", "using System.Collections.Generic;", "using UnityEngine;", "using UnityEngine.AI;", "\n", "public class aiscript : MonoBehaviour", "{", "    public static bool FindEnemy;//发现敌人为真", "    public float detectfield;//探测范围", "    private Monitor1 monitor1 ;//监控", "    bool SystemdetectResult;", "\n", " ", "int", " length;\npublic ", "float", " aispeed;\npublic ", "float", "[]", " Distance;\npublic ", "float", " attackfield;", "//public的值不需要初始化，在unity界面直接设置即可", "\n", "//Vector3 DisiredmovementVector;", "\n", "//Vector3 CurrentmovementVector;", "\npublic Transform playertransform,aitransform;", "/*,eyestransform1,eyestransform2*/", "\nRigidbody rigid;\nAnimator anim;\n", "private", " NavMeshAgent ai;\n", "private", " void ", "OnDrawGizmos()", "//本是private", "\n{\n    ", "Gizmos", ".", "color = ", "Color", ".", "green;\n    Gizmos.", "DrawWireSphere(", "aitransform", ".", "position", ", ", "detectfield", ")", ";\n    ", "if", " (Vector3.", "Distance(", "playertransform", ".", "position", ", ", "aitransform", ".", "position", ")", " <= detectfield)\n    {\n        ", "Gizmos", ".", "color = ", "Color", ".", "red;\n        Gizmos.", "DrawWireSphere(", "aitransform", ".", "position", ", ", "detectfield", ")", ";\n    }\n   \n\n}\npublic Vector3 ", "TrackEnemy()", "\n{\n    var collider = Physics.", "OverlapSphere(", "aitransform", ".", "position", ", ", "detectfield", ")", ";\n    Vector3 EnemyPosition = ", "new", " ", "Vector3()", ";\n    Vector3 EnemyPositionLog = ", "new", " ", "Vector3()", ";\n    ", "if", " (SystemdetectResult)\n    {\n        EnemyPositionLog = playertransform.position;\n    }\n    ", "else", "\n        EnemyPositionLog = transform.position;\n    foreach (var enemy ", "in", " collider)\n    {\n        ", "if", " (enemy.", "CompareTag(", "\"Player\"", ")", ")\n        {\n            EnemyPosition = playertransform.position;\n        }\n        ", "else", "\n            EnemyPosition = EnemyPositionLog;\n    }\n    return EnemyPosition;\n}\n", "\n", "void Start()", "    {", "        SystemdetectResult = false;", "        rigid = GetComponent", "();", "        anim = GetComponent", "();", "        //bool iswall=Iswall();", "        ai = GetComponent", "();", "\n", "}\n", "\n", "void Update()", "    {", "\n", "    ", "/* FindEnemy = SystemDetectresult();*/", "//应将后面函数中用到此函数的全部替换为该变量，减少系统运算负担！", "\n    ", "AiDetectresult()", ";\n    Vector3 currentposition = ", "TrackEnemy()", ";\n    SystemdetectResult = ", "SystemDetectresult()", ";\n    ", "//Debug.Log(FindEnemy);", "\n    ", "AiAction(", "currentposition", ")", ";\n\n}\npublic ", "bool", " ", "AiDetectresult()", "//ai检测到敌人", "\n{\n    ", "if", " (Vector3.", "Distance(", "playertransform", ".", "position", ", ", "aitransform", ".", "position", ")", " <= detectfield)\n\n        return ", "true", ";\n    ", "else", "\n    {\n        Monitor1.SystemAlarm = ", "true", ";\n        return ", "false", ";\n    }\n}\npublic ", "bool", " ", "SystemDetectresult()", "\n{\n    ", "if", " (Monitor1.Alarm", " || ", "AiDetectresult()", ")\n    {\n        return ", "true", ";\n    }\n   \n    ", "else", " return ", "false", ";\n}public void ", "AiAction(Vector3 Currentposition)", "\n{\n    ", "float", " DistanceToPhysics = Vector3.", "Distance(", "playertransform", ".", "position", ", ", "transform", ".", "position", ")", ";\n    ", "if", " (SystemdetectResult)\n    {\n        Debug.", "Log(", "\"有敌人\"", ")", ";\n        ai.", "SetDestination(Currentposition)", ";\n        ", "if", " (DistanceToPhysics < attackfield)\n            ai.isStopped = ", "true", ";\n        ", "else", "\n            ai.isStopped = ", "false", ";\n        anim.", "SetFloat(", "\"forward\"", ", ", "ai", ".", "velocity", ".", "magnitude", ")", ";\n    }\n    ", "else", "\n    {\n        anim.", "SetFloat(", "\"forward\"", ", ", "ai", ".", "velocity", ".", "magnitude", ")", ";\n    }\n}\n", "\n", "//以下是监控代码，挂在空物体上", "using System.Collections;", "using System.Collections.Generic;", "using UnityEngine;", "\n", "public class Monitor1 : MonoBehaviour", "{", "    // Start is called before the first frame update", "    public float detectfield;", "    public Transform  playertransform;", "   public static bool Alarm;", "    public static bool SystemAlarm;", "    public static Vector3 EnemyPosition;", "    void Start()", "    {", "\n", "}\npublic  void ", "OnDrawGizmos()", "\n{\n    ", "Gizmos", ".", "color = ", "Color", ".", "green;\n    Gizmos.", "DrawWireSphere(", "transform", ".", "position", ", ", "detectfield", ")", ";\n    ", "if", " (", "IsAlarm()", ")\n    {\n        ", "Gizmos", ".", "color = ", "Color", ".", "red;\n        Gizmos.", "DrawWireSphere(", "transform", ".", "position", ", ", "detectfield", ")", ";\n    }\n}\n", "// Update is called once per frame", "\nvoid ", "Update()", "\n{\n    \n    Alarm = ", "IsAlarm()", ";\n   \n}\n public ", "bool", " ", "IsAlarm()", "\n{\n    ", "if", " (Vector3.", "Distance(", "transform", ".", "position", ", ", "playertransform", ".", "position", ")", " < detectfield)\n        return ", "true", ";\n    ", "else", " return ", "false", ";\n}\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我正好写了一篇博客&amp;#xff0c;你看一下&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/qq_54121864/article/details/115264595\" id=\"textarea_1644213412963_1644213465361_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_54121864/article/details/115264595&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;别忘记采纳哦&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["C语言中 函数参数中使用 | 来添加多种参数,这是什么原理?", ["比如C++中 outfile.open(\"file.dat\", ios::out | ios::trunc );  和一些WINAPI, | 是或运算,不知道和这个有什么关系,有什么规律嘛?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;按照你这个要求&amp;#xff0c;1498:902转化成98:59比5:3的误差更小&amp;#xff0c;前者是14&amp;#xff0c;后者是16&amp;#xff0c;为什么选择5:3呢&amp;#xff1f;是不是还有别的条件&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["Python关于比例简化", ["比例简化. 在社交媒体上, 经常会看到针对某一个观点同意与否的民意调查以及结果. 例如, 对某一观点表示支持的有1498 人, 反对的有 902人, 那么赞同与反对的比例可以简单的记为1498:902.", "不过, 如果把调查结果就以这种方式呈现出来, 大多数人肯定不会满意. 因为这个比例的数值太大, 难以一眼看出它们的关系. 对于上面这个例子, 如果把比例记为5:3, 虽然与真实结果有一定的误差, 但依然能够较为准确地反映调查结果, 同时也显得比较直观.", "现给出支持人数A, 反对人数B, 以及一个上限L(1 ≤ L ≤ 100), 请将A:B化简为A':B'(化简过程定义为函数). 要求在A'和B'均不大于L且A'和B'互质(两个整数的最大公约数是1)的前提下, A'/B' ≥ A/B且A'/B'-A/B的值尽可能小.", "注意: 为了避免浮点数运算的误差, 应使用整数运算进行条件判断. 如: 判断A'/B' ≥ A/B可转换为判断A'B≥ AB', 前者是浮点数运算, 有误差; 后者是整数运算, 无误差. 同理, A'/B'-A/B的值尽可能小也应该转换成整数运算的比较, 请大家思考如何表示."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.关系太多&amp;#xff0c;我一下也说不清&lt;br /&gt;2.数据结构的设计就是为了便利数据的储存与运算&lt;br /&gt;3.抽象数据类型又叫复杂数据类型&amp;#xff0c;在面向对象语言中一般以类的形式体现&amp;#xff0c;在C语言中则以结构体的方式体现&amp;#xff1b;树/栈的具体设计是一种抽象数据类型&amp;#xff0c;树/栈的逻辑思想是数据结构中的逻辑结构。&lt;br /&gt;4.数据结构与数据类型的关系是汉字与汉字笔划的关系。数据类型是面向应用领域的具体化&amp;#xff0c;同时面向计算机系统底层是为了确定分配的内存容量的大小&amp;#xff1b;数据结构的作用是设计内存中的数据分布&amp;#xff0c;方便数据的存取与操作。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["关于数据结构的一些概念性问题", ["1.能讲下程序/算法/数据结构/数据/数据元素/数据项/数据对象/数据类型/抽象数据类型之间的关系吗？", "2.数据结构的内容不就是逻辑结构和存储结构吗？为什么又要研究数据的运算？", "3.树/栈等为什么算是一种抽象数据类型？他们不是数据结构中的逻辑结构吗？", "4.数据结构和数据类型的关系又是什么？", "\n", "希望指导下，谢谢！", "\n", "9"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的理解是有问题的&amp;#xff0c;你可以考虑下这个问题&amp;#xff0c;假如A要连接B&amp;#xff0c;A可以知道B的掩码吗&amp;#xff1f;&lt;/p&gt;\n\n&lt;p&gt;子网掩码是用来给所在设备找到当前网段并得到广播ip&amp;#xff0c;以此查找目的ip设备。子网掩码只用于当前设备&amp;#xff0c;与其他设备无关&amp;#xff0c;其他设备只要有ip就能连通。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["求赐教，源主机IP与目的主机IP在判断是否为同一子网内时的疑问", ["在源主机向目的主机发送IP数据报时，要先判断是否在同一子网内，将目的主机IP地址与源主机的子网掩码进行 与 运算，得到网络地址，再将源主机IP地址与源主机的子网掩码做 与 运算，得到另一个网络地址，最后，将两个网络地址进行对比，若一致，则在同一子网内，若不一致，则不在同一子网。", "\n\n", "我在网上查找的时候，看到另一种判断方法，将源主机IP地址与自身的子网掩码进行 与 运算，再将目的IP地址与目的主机的子网掩码做 与 运算，对比两个计算后的结果，一致为同一子网，不一致为不同子网。", "\n\n", "如果上述说的没问题的话，那么，我想问的是，比如说，源IP地址是172.16.175.211，子网掩码是255.255.255.0，目的IP地址是172.16.175.123，目的主机子网掩码是255.255.0.0， 源主机的子网掩码和目的IP地址 与 运算后，得到172.16.175.0，源IP与源子网掩码做 与 运算后，也得到172.16.175.0，可以判断为同一子网，但按照分别做 与 运算的方法来看，源IP地址与源主机的子网掩码做 与 运算后为172.16.175.0，目的IP地址与目的主机的子网掩码做 与 运算后为172.16.0.0，并不一致，是用分别计算来判定同一子网的方法不对还是说目的子网掩码设置为255.255.0.0是有问题的？还是因为255.255.0.0的主机位大于255.255.255.0的主机位，所以是包含的关系？这两个IP到底是不是在同一子网内？但我用远程连接目的主机（如上述的源主机去远程连接目的主机）时还是可以连上的，我想是因为在不同网段，而通过默认网关发送分组而连接上的？", "\n\n", "希望大神们不吝赐教！！！ 万分感谢", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个问题很无聊&amp;#xff0c;这是C语言未定义行为&amp;#xff0c;因此不同编译器&amp;#xff0c;结果都不一样。&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/jaydenhpj/p/4432677.html\" id=\"textarea_1681137636210_1681137962790_0\"&gt;https://www.cnblogs.com/jaydenhpj/p/4432677.html&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["关于a++ 和括号的关系。", ["int a =1;", "a = (1+ ++a)+ ++a;", "为什么在前面加个括号，不是等于（1+2）+3，而是先进行了两遍自增，最后结果等于7，对这一点非常疑惑，难道如果一个表达式有许多++a，需要先自增完了，再进行运算吗"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-python\"&gt;\ndef fab(&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;): &lt;span class=\"hljs-comment\"&gt;#&lt;/span&gt;\n    n,&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;,b&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;# n 为循环次数&amp;#xff0c;ab为数列中两个连续值&lt;/span&gt;\n    fab_reasult&amp;#61;[] &lt;span class=\"hljs-comment\"&gt;# 存放结果的数组&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; n&amp;lt;&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;# 循环不够max次则继续&lt;/span&gt;\n        fab_reasult.append(b) &lt;span class=\"hljs-comment\"&gt;# 将第二个数放入结果里&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;,b&amp;#61;b,&lt;span class=\"hljs-keyword\"&gt;a&lt;/span&gt;&amp;#43;b  &lt;span class=\"hljs-comment\"&gt;# a,b &amp;#61; b,a&amp;#43;b  &amp;#xff0c;如 a,b&amp;#61;0,1&amp;#xff0c;运行后&amp;#xff0c;a&amp;#61;&amp;#61;1,b&amp;#61;&amp;#61;1&amp;#xff0c;再次运行则 a &amp;#61;&amp;#61; 1,b&amp;#61;&amp;#61;2&lt;/span&gt;\n        n&amp;#61;n&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;# 循环次数加1&lt;/span&gt;\n    &lt;span class=\"hljs-literal\"&gt;return&lt;/span&gt; fab_reasult\nprint(fab(&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;))  &lt;span class=\"hljs-comment\"&gt;# 参数为9&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算", "Question": ["python设计的斐波那契数列的程序", ["以下是用python设计的斐波那契数列的程序，请帮忙解答一下：", "1、fab(max)里的max是参数，但是下面的程序中只有n<max这个判断式用到了，但是并没有定义max是多少？这是为什么？", "2、函数中定义了变量n，但是n和a，b的关系并没有定义，所以n和a，b的关系是什么？", "3、要形成数列，a，b需要自增长，这里有没有定义，只有n的自加运算，请帮忙解释一下，谢谢", "\n", "\ndef fab(max):\n    n,a,", "b", "=0,0,1\n    fab_reasult=[]\n    ", "while", " n<max:\n        fab_reasult.append(b)\n        a,", "b", "=b,a+b\n        ", "n", "=n+1\n    return fab_reasult\n", "print", "(fab(9))\n"]], "Tag": "程序设计"}
{"Answer": "如果你的表达式里面的除数仅有常量,可以分析表达式.\r\n  如果表达式里面仅有变量,直接用decode函数就可以了.\r\n  如果是混合常量和变量,两步都要做. 先分析表达式,把除数中出现常量0的情况过滤掉,直接给它替换成0. 再用decode函数包装起来放在sql里面.\r\n\r\n  我想问你,这个表达式怎么得到的? 你能保证表达式里面变量的正确性?", "Konwledge_Point": "关系运算", "Question": ["把公式中的除数和被除数分解出来,", ["本人有一个字符串,它是一个公式,是属于四则运算那种,我要把它里面的除数和被除数全部分解出来,让后通过decode函数来判断被除数是不是0,如果是0就把整个表达式为0,想了N久,发现里面的逻辑关系太复杂了,希望有那位解决过类似问题的给咱一个提示"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有几个问题&lt;br /&gt;1.用字典的方式&amp;#xff0c;在字典赋值的时候&amp;#xff0c;会将所有方法都调用一遍&amp;#xff0c;相当于计算了不需要的方法&amp;#xff0c;影响效率&lt;br /&gt;建议先判断选择项大小&amp;#xff0c;大于7的直接写分支调用代码&lt;br /&gt;2.方法需要有返回值&amp;#xff0c;直接将返回值更新到label上&amp;#xff0c;调用时需要加括号&lt;br /&gt;3.后面计算时&amp;#xff0c;需要有字符类型等输入值判断&amp;#xff0c;更严谨&lt;br /&gt;修改后的代码如下&amp;#xff1a;&lt;br /&gt;4.计算方法返回的字符串没有处理&amp;#xff0c;直接拷贝原有内容&amp;#xff0c;如果为了显示更好看&amp;#xff0c;使用占位符方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; tkinter import *\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; tkinter.ttk import *\n\n\ndef calc(event):\n    a &amp;#61; float(t1.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    b &amp;#61; float(t2.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    dic &amp;#61; {0: a &amp;#43; b, 1: a - b, 2: a * b, 3: a / b, 4: a ** b, 5: a % b\n        , 6: compare1(), 7: compare2(), 8: compare3(), 9: compare4()}\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(comb.current())\n    c &amp;#61; dic[comb.current()]\n    lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;str(c))\n\n\n\n&lt;span class=\"hljs-comment\"&gt;# 比大小&lt;/span&gt;\ndef compare1():\n    a &amp;#61; float(t1.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    b &amp;#61; float(t2.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; a &amp;gt; b:\n        #lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;第一个数大于第二个数&amp;#34;&lt;/span&gt;)\n        result &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;第一个数大于第二个数&amp;#34;&lt;/span&gt;\n    elif a &amp;#61;&amp;#61; b:\n        #lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;第一个数大于第二个数&amp;#34;&lt;/span&gt;)\n        result &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;第一个数等于第二个数&amp;#34;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n        #lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;第一个数大于第二个数&amp;#34;&lt;/span&gt;)\n        result &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;第一个数小于第二个数&amp;#34;&lt;/span&gt;\n    return result\n\n\n&lt;span class=\"hljs-comment\"&gt;# 逻辑与运算&lt;/span&gt;\ndef compare2():\n    a &amp;#61; float(t1.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    b &amp;#61; float(t2.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    # lbl1 &amp;#61; Label(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;str((a, &lt;span class=\"hljs-string\"&gt;&amp;#34;and&amp;#34;&lt;/span&gt;, b, &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;, a &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; b)))\n    # lbl1.place(&lt;span class=\"hljs-attribute\"&gt;relx&lt;/span&gt;&amp;#61;0.6, &lt;span class=\"hljs-attribute\"&gt;rely&lt;/span&gt;&amp;#61;0.4, &lt;span class=\"hljs-attribute\"&gt;relwidth&lt;/span&gt;&amp;#61;0.2, &lt;span class=\"hljs-attribute\"&gt;relheight&lt;/span&gt;&amp;#61;0.3)\n    #lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;str((a, &lt;span class=\"hljs-string\"&gt;&amp;#34;and&amp;#34;&lt;/span&gt;, b, &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;, a &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; b)))\n    result &amp;#61; str((a, &lt;span class=\"hljs-string\"&gt;&amp;#34;and&amp;#34;&lt;/span&gt;, b, &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;, a &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; b))\n    return result\n\n&lt;span class=\"hljs-comment\"&gt;# 逻辑或运算&lt;/span&gt;\n\ndef compare3():\n    a &amp;#61; float(t1.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    b &amp;#61; float(t2.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    #lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;print(a, &lt;span class=\"hljs-string\"&gt;&amp;#34;or&amp;#34;&lt;/span&gt;, b, &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;, a &lt;span class=\"hljs-keyword\"&gt;or&lt;/span&gt; b))\n    result &amp;#61; str((a, &lt;span class=\"hljs-string\"&gt;&amp;#34;or&amp;#34;&lt;/span&gt;, b, &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;, a &lt;span class=\"hljs-keyword\"&gt;or&lt;/span&gt; b))\n    return result\n\n\n&lt;span class=\"hljs-comment\"&gt;# 逻辑非运算&lt;/span&gt;\ndef compare4():\n    a &amp;#61; float(t1.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    b &amp;#61; float(t2.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;())\n    #lbl.configure(&lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;print(a, &lt;span class=\"hljs-string\"&gt;&amp;#34;的非运算结果为&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; a))\n    result &amp;#61; str((a, &lt;span class=\"hljs-string\"&gt;&amp;#34;的非运算结果为&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;not&lt;/span&gt; a))\n    return result\n\n\nroot &amp;#61; Tk()\nroot.geometry(&lt;span class=\"hljs-string\"&gt;&amp;#39;320x240&amp;#39;&lt;/span&gt;)\nroot.title(&lt;span class=\"hljs-string\"&gt;&amp;#39;多功能计算器&amp;#39;&lt;/span&gt;)\n\nt1 &amp;#61; Entry(root)\nt1.place(&lt;span class=\"hljs-attribute\"&gt;relx&lt;/span&gt;&amp;#61;0.1, &lt;span class=\"hljs-attribute\"&gt;rely&lt;/span&gt;&amp;#61;0.1, &lt;span class=\"hljs-attribute\"&gt;relwidth&lt;/span&gt;&amp;#61;0.2, &lt;span class=\"hljs-attribute\"&gt;relheight&lt;/span&gt;&amp;#61;0.1)\n\nt2 &amp;#61; Entry(root)\nt2.place(&lt;span class=\"hljs-attribute\"&gt;relx&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;rely&lt;/span&gt;&amp;#61;0.1, &lt;span class=\"hljs-attribute\"&gt;relwidth&lt;/span&gt;&amp;#61;0.2, &lt;span class=\"hljs-attribute\"&gt;relheight&lt;/span&gt;&amp;#61;0.1)\n\nvar &amp;#61; StringVar()\n\ncomb &amp;#61; Combobox(root, &lt;span class=\"hljs-attribute\"&gt;textvariable&lt;/span&gt;&amp;#61;var,\n                values&amp;#61;[&lt;span class=\"hljs-string\"&gt;&amp;#39;加&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;减&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;乘&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;除&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;乘方&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;余数&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;比大小&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;逻辑&amp;#34;与&amp;#34;预算&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;逻辑&amp;#34;或&amp;#34;运算&amp;#39;&lt;/span&gt;,\n                        &lt;span class=\"hljs-string\"&gt;&amp;#39;逻辑&amp;#34;非&amp;#34;运算&amp;#39;&lt;/span&gt;])\ncomb.place(&lt;span class=\"hljs-attribute\"&gt;relx&lt;/span&gt;&amp;#61;0.1, &lt;span class=\"hljs-attribute\"&gt;rely&lt;/span&gt;&amp;#61;0.5, &lt;span class=\"hljs-attribute\"&gt;relwidth&lt;/span&gt;&amp;#61;0.35)\ncomb.bind(&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;lt;&amp;lt;ComboboxSelected&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, calc)\n\nlbl &amp;#61; Label(root, &lt;span class=\"hljs-attribute\"&gt;text&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;结果&amp;#39;&lt;/span&gt;)\nlbl.place(&lt;span class=\"hljs-attribute\"&gt;relx&lt;/span&gt;&amp;#61;0.6, &lt;span class=\"hljs-attribute\"&gt;rely&lt;/span&gt;&amp;#61;0.4, &lt;span class=\"hljs-attribute\"&gt;relwidth&lt;/span&gt;&amp;#61;0.2, &lt;span class=\"hljs-attribute\"&gt;relheight&lt;/span&gt;&amp;#61;0.3)\n\nroot.mainloop()\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算", "Question": ["tkinter的label对象无法调用的问题", ["\n\n```python\n", "from", " tkinter import *\n", "from", " tkinter.ttk import *\n\n\ndef calc(event):\n    a = float(t1.", "get", "())\n    b = float(t2.", "get", "())\n    dic = {0: a + b, 1: a - b, 2: a * b, 3: a / b, 4: a ** b, 5: a % b\n        , 6: compare1, 7: compare2, 8: compare3, 9: compare4}\n    c = dic[comb.current()]\n    lbl.config(", "text", "=str(c))\n\n\n", "# 比大小", "\ndef compare1():\n    a = float(t1.", "get", "())\n    b = float(t2.", "get", "())\n    ", "if", " a > b:\n        lbl(", "text", "=", "\"第一个数大于第二个数\"", ")\n    elif a == b:\n        lbl(", "text", "=", "\"第一个数大于第二个数\"", ")\n    ", "else", ":\n        lbl(", "text", "=", "\"第一个数大于第二个数\"", ")\n\n\n", "# 逻辑与运算", "\ndef compare2():\n    a = float(t1.", "get", "())\n    b = float(t2.", "get", "())\n    lbl1 = Label(", "text", "=str((a, ", "\"and\"", ", b, ", "\"=\"", ", a ", "and", " b)))\n    lbl1.place(", "relx", "=0.6, ", "rely", "=0.4, ", "relwidth", "=0.2, ", "relheight", "=0.3) \n\n\n", "# 逻辑或运算", "\n\ndef compare3():\n    a = float(t1.", "get", "())\n    b = float(t2.", "get", "())\n    lbl(", "text", "=print(a, ", "\"or\"", ", b, ", "\"=\"", ", a ", "or", " b))\n\n\n", "# 逻辑非运算", "\ndef compare4():\n    a = float(t1.", "get", "())\n    b = float(t2.", "get", "())\n    lbl(", "text", "=print(a, ", "\"的非运算结果为\"", ", ", "not", " a))\n\n\nroot = Tk()\nroot.geometry(", "'320x240'", ")\nroot.title(", "'多功能计算器'", ")\n\nt1 = Entry(root)\nt1.place(", "relx", "=0.1, ", "rely", "=0.1, ", "relwidth", "=0.2, ", "relheight", "=0.1)\n\nt2 = Entry(root)\nt2.place(", "relx", "=0.5, ", "rely", "=0.1, ", "relwidth", "=0.2, ", "relheight", "=0.1)\n\nvar = StringVar()\n\ncomb = Combobox(root, ", "textvariable", "=var,\n                values=[", "'加'", ", ", "'减'", ", ", "'乘'", ", ", "'除'", ", ", "'乘方'", ", ", "'余数'", ", ", "'比大小'", ", ", "'逻辑\"与\"预算'", ", ", "'逻辑\"或\"运算'", ",\n                        ", "'逻辑\"非\"运算'", "])\ncomb.place(", "relx", "=0.1, ", "rely", "=0.5, ", "relwidth", "=0.35)\ncomb.bind(", "'<<ComboboxSelected>>'", ", calc)\n\nlbl = Label(root, ", "text", "=", "'结果'", ")\nlbl.place(", "relx", "=0.6, ", "rely", "=0.4, ", "relwidth", "=0.2, ", "relheight", "=0.3)\n\nroot.mainloop()\n\n\n", "\n", "\n老师好，我的问题是我自己def的运算函数的运算结果怎么跟最后lbl结果绑定关系啊？\n就是我想在结果栏显示我", "print", "的内容！自己打的结果栏显示“<", "function", "\"", "\n我def的都是实验的应该是错的 望纠正感谢！！！\n\n\n> \n![img](https://img-mid.csdnimg.", "cn", "/release/static/image/mid/ask/", "92903633017612", ".png ", "\"#left\"", ")\n\n![img](https://img-mid.csdnimg.", "cn", "/release/static/image/mid/ask/", "233736330176111", ".png ", "\"#left\"", ")\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没啥问题吧&amp;#xff0c;重新编译一下再运行看看&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["函数调用的问题，无参数的情况怎么填void都Error", ["问题遇到的现象和发生背景", "\n", "函数调用的问题，无参数的情况怎么填void都Error，请教原因", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<math.h>", " ", "\n", "double", " ", "exp", "()", ";\n", "int", " ", "main", "()", "\n", "{\n    ", "double", " a=", "exp", "();\n    ", "printf", "(", "\"%lf\"", ",a);\n    ", "return", " ", "0", ";\n}\n", "double", " ", "exp", "()", "{\n        ", "char", " s[", "50", "];\n        ", "scanf", "(", "\"%s\"", ",s);\n        ", "switch", "(s[", "0", "]){\n            ", "case", " ", "'+'", ":", "return", " ", "exp", "()+", "exp", "();\n            ", "case", " ", "'-'", ":", "return", " ", "exp", "( )-", "exp", "( );\n            ", "case", " ", "'*'", ":", "return", " ", "exp", "( )*", "exp", "( );\n            ", "case", " ", "'/'", ":", "return", " ", "exp", "( )/", "exp", "( );\n            ", "default", " :", "return", " ", "atof", "(s);\n        }\n}\n\n", "\n", "运行结果及报错内容", "\n", "波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。", "输入", "输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。", "输出", "输出为一行，表达式的值。", "可直接用printf(\"%f\\n\", v)输出表达式的值v。", "样例输入", "\n", "11.0 12.0 + 24.0 35.0", "样例输出", "\n", "\n", "1357.000000"]], "Tag": "程序设计"}
{"Answer": "那就用润乾吧。学习简单功能强大。\r\n我用了5年润，感觉不错。\r\n你也可以先看看 快逸就是润乾的免费版。\r\n我感觉Java报表最好的就是润乾。用过jasperReport发现，根本就没法比。", "Konwledge_Point": "关系运算", "Question": ["请帮忙推荐一个java 报表工具", ["请大家帮忙推荐一个报表工具，需求:", "1，支持B/S 结构，易于开发(API 简单)", "2，能支持大数据量复杂运算(千万级数据?)，至少不要算到服务器死机", "3，支持2 次开发", "4，价格不是最大的问题(几十万不是问题，上百万就要考虑了:(   )", "最好是有成功案例，哈哈，要求是不是太多了呢~~~", "现在在用水晶报表，问题是和B/S 结合以后性能不能接受；", "也在用快逸报表，还是性能的问题，数据量大了直接就占掉所有的CPU(SUN V240)。", "我没有抱怨的意思，一分钱一分货，快逸报表还是蛮好用的。", "谢谢。", "问题补充", "你觉得呢？", "问题补充", "不是讨论那个好那个坏，怎么实现报表，怎么改进人家产品的性能等。", "我的需求是:", "一个现成的能支持大数据量的商业报表工具，我拿过来可以快速的开发我要的报表。", "如果有推荐的，直接给产品名字就好了，我会去评估的，谢谢啊。", "问题补充", "huangyy 写道", "千万级的数据，就别考虑做复杂的运算了，否则用什么报表都一样", "\n", "数据量和运算是OR 的关系~", "数据量主要是捞Raw data 时的考量。", "运算有时也是必须的，", "即使数据使用了星形结构雪片状结构，数据的Rollup 和Drilldown 也是逃不掉的。", "水晶报表可以Down 出来无限大的数据量，要的只是时间，而有些报表工具就只能Down 很小的数据量，这个就可以看出来工具的优劣了。", "还有个例子，我们这边工厂以前月结要好几天才能结出来(Oracle ERP)，但还是出来了。后来买花了大价钱买了顶级的SUN 服务器（包括主机和Storage），几分钟就可以结出来了。", "说明两个问题，", "1，Oracle 卖那么贵是有道理的，因为算了3 天还是算出来了", "2，硬件真的很重要", "为什么要找第三方的工具?", "因为我们不是软件公司，即使是，我们也不想发明轮子，因为这样成本会更高。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;5.水仙花&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\nint main(void)\n{\n\tint num;\n\tint a,b,c;\n\tfor(num&amp;#61;100;num&amp;lt;&amp;#61;999;num&amp;#43;&amp;#43;)\n\t{\n\t\ta&amp;#61;num/100;\n\t\tb&amp;#61;num/10%10;\n\t\tc&amp;#61;num%10;\n\t\tif(num&amp;#61;&amp;#61;a*a*a&amp;#43;b*b*b&amp;#43;c*c*c)\n\t\tprintf(&amp;#34;%d\\n&amp;#34;,num);\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;10.&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;string.h&amp;gt;\n#define N 80\nvoid Inverse(char str[]);\n\nmain()\n{\n    char str[N];\n    printf(&amp;#34;Input a string:\\n&amp;#34;);\n    gets(str);\n    Inverse(str);\n    printf(&amp;#34;Inversed results:\\n&amp;#34;);\n    printf(&amp;#34;%s\\n&amp;#34;,str);\n}\n\nvoid Inverse(char str[])\n{\n    int a &amp;#61; strlen(str), i;\n    char temp;\n    for(i &amp;#61; 0;i &amp;lt; a/2; i&amp;#43;&amp;#43;)\n    {\n        temp &amp;#61; str[i];\n        str[i] &amp;#61; str[a - 1 - i];\n        str[a - 1 - i] &amp;#61; temp;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["几道c语言的编程题，求各位大佬解答一下呀。哪怕其中某一道也可以哦，小妹在这谢谢各位大佬了，呜呜呜。", ["2、设计C程序，根据分段函数关系，输入X，计算并输出Y 的值。", "\n\n", "3.计算器程序，用户输入运算数和四则运算符，输出计算结果，例如：用户输入9*2，显示结果为18.", "\n\n", "4.设计C程序根据如下的分段函数，从键盘输入四个百分制成绩，将其转化位五分制等级输出。", "\n\n", "5.编程计算并输出三位数的水仙花数。", "\n\n", "6编程计算并输出指定范围内的全部素数。", "\n\n", "7.用数组编程，从键盘上输入不超过100个学生单科成绩，统计并输出低于平均成绩的学生人数。", "\n\n", "8.用数组编程，从键盘上输入不超过50个字符，统计其中英文字符，空格字符，数字字符及其它字符的个数，并将结果输出。", "\n\n", "9.用字符数组会指针做函数参数设计函数，测试字符串长度，类似于strlen()函数功能。", "\n\n", "10.用字符数组会指针做函数参数设计函数，将一个字符串逆序存放。", "\n\n", "11.用字符数组或指针做函数参数设计函数，将两个字符串连接起来，实现类似于strcat()函数的功能。", "\n\n", "12.用字符数组或指针做函数参数设计函数，比较两个字符串的大小，实现类似于strcmp()函数的功能。", "\n\n", "13.设计函数，对一组数排序，用数组或指向数组的指针变量做函数参数。", "\n\n", "14.编写程序完成如下功能：根据输入m的值，2<=m<=9,在m行m列的二维数组中存放如下所示的数据。结果显示在屏幕上。", "\n\n", "例如输入3 例如输入5", "\n\n", "15.编写C程序，随机产生0~100随整数，存放在一个3*4的矩阵中，编程序求出值最大的那个元素的值，以及其所在的行号和列号。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;都没说到重点。。。&lt;br /&gt;for( j &amp;#61; i-1 ;  temp &amp;lt; r[j] &amp;amp;&amp;amp; j &amp;gt;&amp;#61; 0 ; j--) {&lt;!-- --&gt;&lt;br /&gt; 这个是你的代码&amp;#xff0c;当 i 初始值为 1时&amp;#xff0c;j 从0开始&amp;#xff1b;&lt;br /&gt;当 j 为0&amp;#xff0c;第一次满足条件&amp;#xff0c;for 循环执行&amp;#xff0c;最后会 j--&amp;#xff0c;这个时候 j 变成了-1&amp;#xff1b;&lt;br /&gt;再次进入判断条件时&amp;#xff0c;temp &amp;lt; r[-1]&amp;#xff0c;这不就越界了&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["java 逻辑与 插入排序算法越界报错", ["问题遇到的现象和发生背景", "\n", "问问各位，为什么下面插入排序代码如果将temp< r[j]写在&&前面就会报错", "但是如果把j >= 0 写在前面就能正常运行", "不知道那一步出错了", "知道逻辑与有个短路效应", "\n", "问题相关代码", "\n", "public", " ", "class", " ", "InsetSort", " {\n\n     ", "public", " ", "void", " InsertSort(", "int", "[] r,", "int", " n) {\n        ", "int", " temp, j;\n         ", "for", "(", "int", " i = ", "1", "; i<n ; i++) { ", "//第一个数组元素不用排序,从第二个元素开始", "\n                temp = r[i];   ", "//数组下标为0的元素是哨兵,用来存储待插入元素", "\n                ", "for", "( j = i", "-1", " ;  temp < r[j] && j >= ", "0", " ; j--) {", "//分别寻找待插入元素之前的数组元素与待插入元素的关系", "\n                                   ", "//逻辑与具短路效果,第一个只要为假就不再对后面进行运算     ", "\n                    r[j+", "1", "]=r[j]; ", "//将元素后移", "\n                }\n                r[j+", "1", "]=temp;\n         }\n     }\n}\n\n", "\n", "报错内容", "\n", "Exception ", "in", " thread ", "\"main\"", " java", ".lang", ".ArrayIndexOutOfBoundsException", ": -", "1", "\n    at SuanFa", ".InsetSort", ".InsertSort", "(InsetSort", ".java", ":", "9", ")\n    at SuanFa", ".Test", ".main", "(Test", ".java", ":", "12", ")\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你先把代码粘好把&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["else if取大小排序输出的问题", ["else if问题", "\n", "#include <stdio.h>", "int main()", "{", "    int a, b, c;", "    scanf_s(\"%d,%d,%d\", &a, &b, &c);", "    if (a > b)", "    {", "        b > c;", "        printf(\"a = % d, b = % d, c = % d\", a, b, c);", "    }", "    else if (a > c)", "    {", "        c > b;", "        printf(\"a=%d,c=%d,b=%d\", a, c, b);", "    }", "    else if (b > a)", "    {", "        a > c;", "        printf(\"b=%d,a=%d,c=%d\", b, a, c);", "    }", "    else if (b > c)", "    {", "        c > a;", "        printf(\"b=%d,c=%d,a=%d\");", "    }", "    else if (c > a)", "    {", "        a > b;", "        printf(\"c=%d,a=%d,b=%d\");", "    }", "    else if (c > b)", "    {", "        b > a;", "        printf(\"c=%d,b=%d,a=%d\");", "    }", "    return 0;", "}", "运行结果及报错内容 :输入有的数值时，只是按着elseif后面的语句来进行顺序输出，没有{里面的规则，请问是运算关系出了什么问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我上课用的是同济大学的&amp;#xff0c;看你的学校层次&amp;#xff0c;如果比较好的话&amp;#xff0c;前面三张就是划水&amp;#xff0c;后面从不定积分开始才是玩的。老师会出一些应用题和牛顿-莱布尼茨公式相对应的式子&amp;#xff0c;但是像前三章&amp;#xff0c;虽然基础&amp;#xff0c;但重要。 后面的多元微分学和偏导数等会考&amp;#xff0c;二重积分会考试&amp;#xff01;&lt;/p&gt;\n\n&lt;p&gt;一些公式还是要记住的&amp;#xff01;&lt;/p&gt;\n\n&lt;p&gt;普通学校的话就考的层次不会太难&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["求大佬分析一下高等数学提纲，并参照提纲给点学习建议。谢谢", ["三、考试内容与要求", "\n\n", "第一章  函数极限与连续", "\n\n", "（一）考试内容", "\n\n", "一元函数的概念，函数的性质(有界性、单调性、奇偶性、周期性)，反函数，基本初等函数的概念、性质及其图形，复合函数，初等函数，数列极限，函数极限，无穷小与无穷大，无穷小与极限之间的关系，无穷小与无穷大之间的关系，极限的运算法则，极限存在准则，两个重要极限，无穷小的比较，函数的连续性，函数的间断点及其类型，连续函数的运算定理，初等函数的连续性，闭区间上连续函数的基本性质．", "\n\n", "（二）考试要求", "\n\n", "1．理解函数、初等函数的概念；", "\n\n", "2．了解函数的性质以及反函数的概念；", "\n\n", "3．掌握基本初等函数的性质及其图形；", "\n\n", "4．理解极限的概念，思想方法；", "\n\n", "5．了解极限的", "定义；", "\n\n", "6．掌握左、右极限的概念，左、右极限与双边极限的关系；", "\n\n", "7．掌握极限四则运算法则；", "\n\n", "8．了解两个极限存在准则，熟练掌握两个重要极限；", "\n\n", "9．理解无穷小的概念及与极限的关系；", "\n\n", "10．了解无穷小的比较；", "\n\n", "11．理解连续的两种定义，掌握连续性的证明方法、连续函数的运算性质，会判定间断点的类型；", "\n\n", "12．知道闭区间上连续函数的性质，会用零点定理判别方程的根。", "\n\n", " ", "\n\n", "第二章  导数与微分", "\n\n", "（一）考试内容", "\n\n", "导数的概念，基本初等函数的导数，函数的和，差、积、商的导数，反函数和复合函数的导数，高阶导数，由隐函数、参数方程确定的函数的导数，微分的基本公式，微分形式不变性，微分在近似计算中的应用．", "\n\n", "（二）考试要求", "\n\n", "1．理解导数的概念，掌握利用概念求某些特殊极限的方法；", "\n\n", "2．掌握导数的几何意义，掌握求切线和法线方程的方法，明确可导与连续的关系；", "\n\n", "2．熟练掌握导数的运算；", "\n\n", "3．理解微分的概念、几何意义、微分形式不变性，明确可导与可微的关系；", "\n\n", "4．掌握微分在近似计算中的应用；", "\n\n", "第三章  中值定理与导数的应用。", "\n\n", "（一）考试内容", "\n\n", "微分中值定理(罗尔定理、拉格朗日中值定理、柯西中值定理)，罗必塔法则，泰勒公式，函数单调性的判别、函数的凸凹性及拐点的判别、函数的极值概念及求法，最大值与最小值及其应用，函数图形的水平渐近线与铅直渐近线，函数作图．", "\n\n", "（二）考试要求", "\n\n", "1．了解三个微分中值定理的条件、结论，能证明前两个定理，了解构造函数的方法，掌握不等式的证明；", "\n\n", "2．掌握洛必达法则的条件，结论以及常见的各种未定式的计算；", "\n\n", "3．掌握泰勒公式和麦克劳林公式展开某些较简单的初等函数并求其近似值；", "\n\n", "4．掌握函数的单调、凹凸、拐点、极值的判别，会求曲线的水平、垂直渐近线，会作函数的草图；", "\n\n", "5．掌握解决简单的最大值、最小值的实际应用问题。", "\n\n", " ", "\n\n", "第四章  不定积分", "\n\n", "（一）考试内容", "\n\n", "原函数与不定积分的概念，不定积分的基本性质，积分基本公式，换元积分法，分部积分法，有理函数的积分，三角函数有理式的积分，简单无理函数的积分．", "\n\n", "（二）考试要求", "\n\n", "1．理解不定积分的概念，了解不定积分的几何意义；", "\n\n", "2．熟练掌握不定积分的基本公式，掌握不定积分的性质；", "\n\n", "3．熟练掌握不定积分的两类换元积分和分部积分法；", "\n\n", "4．掌握较简单的有理函数、三角函数有理式的积分；", "\n\n", "5．会求较简单的无理函数的积分；", "\n\n", " ", "\n\n", "第五章  定积分及其应用", "\n\n", "（一）考试内容", "\n\n", "定积分的概念，定积分的基本性质、微积分基本定理，定积分的换元积分及分部积分法，定积分的应用(求面积、体积、功、水压力)．", "\n\n", " ", "\n\n", "（二）考试要求", "\n\n", "1．理解定积分的概念，几何意义，掌握定积分的性质；", "\n\n", "2．熟练掌握定积分的换元积分法和分部积分法；", "\n\n", "3．理解变上限的定积分作为其上限的函数及其求导定理，熟悉牛顿－莱布尼兹公式和变上限积分函数的求导；", "\n\n", "4．掌握定积分的微元法，掌握用定积分来表达面积、体积、弧长，了解功、水压力；", "\n\n", " ", "\n\n", "第六章  空间解析几何与向量代数", "\n\n", "（一）考试内容", "\n\n", "空间直角坐标系，两点间距离公式，向量代数，直线、平面的方程，常见曲面及其方程．", "\n\n", "（二）考试要求", "\n\n", "1．了解空间直角坐标系，建立空间点与数组的一一对应关系；", "\n\n", "2．掌握两点间距离公式,了解向量的运算（线性运算、点乘法、叉乘法）,两个向量夹角的求法与垂直、平行的条件；", "\n\n", "3．熟练掌握用坐标表达式进行向量运算；", "\n\n", "4．掌握平面，直线的方程；", "\n\n", "5．知道常见曲面及其方程。", "\n\n", " ", "\n\n", "第七章  多元函数微分法及其应用", "\n\n", "（一）考试内容", "\n\n", "二元函数的概念，二元函数的图形，二元函数的极限、连续，偏导数的概念，高阶偏导数、全增量与全微分，全微分存在的条件、复合函数微分法，隐函数及其微分法、二元函数的极值，最大值、最小值及其应用．", "\n\n", "（二）考试要求", "\n\n", "1．理解二元函数的概念，知道二元函数的几何意义；", "\n\n", "2．知道二元函数的极限、连续性等概念以及有界闭域上连续函数的性质；", "\n\n", "3．理解偏导数、全微分等概念并熟练掌握其计算，知道全微分存在条件；", "\n\n", "4．熟练掌握复合函数的求导法则；", "\n\n", "5．会求隐函数所确定的函数的偏导数；", "\n\n", "6．理解多元函数极值的概念，会求函数的极值，了解条件极值的概念，会用拉格朗日乘数法求条件极值；", "\n\n", "7．会求解一些较简单的最大值和最小值的应用问题。", "\n\n", " ", "\n\n", "第八章  二重积分", "\n\n", "（一）考试内容", "\n\n", "二重积分的的概念及性质，二重积分的计算（直角坐标、极坐标），二重积分的应用（曲面的面积、体积、薄片质量)。", "\n\n", "（二）考试要求", "\n\n", "1．理解二重积分的概念，掌握二重积分的性质；", "\n\n", "2．熟练掌握直角坐标下二重积分的计算方法；", "\n\n", "3．熟练掌握极坐标下二重积分的计算；", "\n\n", "4．会应用二重积分求面积，体积、薄片质量。", "\n\n", " ", "\n\n", " ", "\n\n", "四、考试方式及时间", "\n\n", "1．考试方式：闭卷                ", "\n\n", "2．考试时间：120分钟", "\n\n", " ", "\n\n", "五、教材与参考书目", "\n\n", "1．同济大学应用数学系,高等数学[M].北京:高等教育出版社，2002年.", "\n\n", "2．黄立宏,廖基定,高等数学[M].上海:复旦大学出版社,2006年.", "\n\n", "3．朱健民,李建平,高等数学[M].北京:高等教育出版社,2007年."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/269502262376155.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["ptthon词云图最简单的结果", ["文件如下", "\n", "Python学习总结", "   通过学习计算思维这门学科，我得以进入一个完全不同的世界，数码的世界，编程的世界。计算思维这么学科带我认识了Python，从中我又知道电脑是如何运作，对于电脑运行以及数码世界有了浅薄的认知。", "　　同时在python学习中，我知道了列表、字典、函数、类、对象等等，每一个看起来简单的词语的背后都是一套独有的思维方式，而也这些这一个个特有的“元素”汇聚成了Python语言这门课程，学习时间虽然很短，但是获得的知识是无穷的。每一节课堂内容的背后，我相信都是无数人知识、思维甚至是语言的集合，真的很感谢这门语言带给我的乐趣。下面是我的一些学习总结。", "　　学习中的第一个难点，就是循环逻辑的建构。Python的循环结构分为两种。分别是while和for循环。For 循环一般用于有限次数，while循环而用于未知次数的循环。在学习循环语句时，最大的感受就是逻辑的严密，什么地方要缩进，什么地方要结束，什么语句要置于循环的下方，一步也不能出错，大到逻辑的合理性，小到一个冒号是否添加。哪怕一个地方出现问题，电脑运行都会出现错误或者得出错误结论。在循环中对于列表，字典，元组……都有不同的循环遍历方式，不可以弄混淆。在我看来，循环语句是最考验逻辑严密性的一环了。", "　　接下来学习了函数和列表，元组，字典，集合这些不同键不同的区别以及如何对他们进行操作。下面我简单介绍一些基本操作方法。", "　　列表：列表是Python中使用最频繁的数据类型，集合中可以放任何数据类型，可对集合进行创建、查找、切片、增加、修改、删除、循环和排序操作。与字符串的索引一样，List索引从0开始，list 的数据项可以不同类型，list 的各个元素可以改变，list 是使用 [ ] 方括号包含各个数据项。+ 多个列表进行合并成一个列表 * 列表重复输出多次 in 某个项是否在列表中", "　　  Python中对序列提供了一些统计函数，其中len()函数就是可以获取序列长度的一个统计操作，可以结合range()哈数可以生成一个访问的索引范围，就可以实现循环索引访问列表的操作了。如果需要对列表进行排序或者反转等操作，那么通过索引这种访问就比较方便了。", "　　元组：Python 的元组与列表类似，不同之处在于元组的元素一旦初始化就不能修改。元组使用小括号 ( )，列表使用方括号 [ ]。元组与字符串类似，下标索引从0开始，可以进行截取，组合等。元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。", "　　元组可以进行访问，修改，删除，索引和截取操作。", "　　字典：字典是一种键值对的集合，列表是有序的对象集合，字典是无序的对象集合。字典是可变容器模型，且可存储任意类型对象字典可以通过键来引用，键必须是唯一的且键名必须是不可改变的（即键名必须为Number、String、元组三种类型的某一种），但值则不必。字典是使用 { } 大括号包含键值对，创建空字典使用 { }", "　　字典可以进行访问，添加，删除和修改功能。dict.keys( ) 以列表返回一个字典所有的键，dict.values( ) 以列表返回字典中的所有值，dict.items( ) 以列表返回可遍历元组数组，以上是字典的几种常见用法。", "　　集合：集合（set）是一个无序的不重复元素序列，它的主要作用有两个，分别是去重和关系测试。", "　　集合的基本用法是集合的去重，增删，判断集合是否存在以及集合的四种基础运算方法。", "　　这学期的计算思维课程让我接触到了一个全新的领域，哲理有着严格的条例，但同时又创造出无限的可能。手指飞快打出几行代码，输出的结果却可以是瑰丽的图形或是精确的数据。以上仅是我的一小段学习总结，但是计算思维这门课对我思维的锻炼，逻辑推理能力的增进，以及使我渐渐养成严谨认真的态度，使我终身受益。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;针对以上三种查询方案的执行代价&amp;#xff0c;可以进行以下分析&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;Q1&amp;#xff1a;首先需要对两个表中的数据进行 JOIN 操作&amp;#xff0c;由于表的大小都不是很大&amp;#xff0c;因此可以使用 Nested Loop 连接算法。如果在 College 表的 CollegeName 列上创建索引&amp;#xff0c;则可以加快筛选的速度。因此&amp;#xff0c;可以认为 Q1 是一种较优的查询方案。&lt;br /&gt;Q2&amp;#xff1a;首先对 College 表进行筛选&amp;#xff0c;然后通过 CollegeID 列进行 JOIN 操作&amp;#xff0c;这一步操作可以使用 Index Scan 算法&amp;#xff0c;然后再对 TeacherName 列进行筛选。但是这种查询方案会多进行一次表的访问操作&amp;#xff0c;不如 Q1 方案直接对两个表进行 JOIN 操作来得优秀。&lt;br /&gt;Q3&amp;#xff1a;首先对 Teacher 表进行筛选&amp;#xff0c;然后通过 CollegeID 列与 College 表进行 JOIN 操作&amp;#xff0c;最后再对 CollegeName 列进行筛选。这种查询方案与 Q1 方案类似&amp;#xff0c;但是先进行一次表的筛选操作&amp;#xff0c;因此比 Q1 方案稍微劣一些。&lt;br /&gt;因此&amp;#xff0c;可以认为 Q1 是最优查询方案。&lt;/p&gt;\n&lt;p&gt;当对 College 和 Teacher 表的主外键列创建索引并且对 CollegeName 列也创建索引后&amp;#xff0c;查询代价会进一步降低。具体的查询代价取决于索引的实现和数据分布情况&amp;#xff0c;但是可以预期&amp;#xff0c;这些索引的加入可以提高查询效率&amp;#xff0c;特别是在 CollegeName 列上创建索引&amp;#xff0c;因为它是查询条件中的一个关键字。&lt;/p&gt;", "Konwledge_Point": "关系运算", "Question": ["SQL数据库查询代价问题", ["教学管理数据库包含了学院表College（CollegeID，CollegeName）和教师表Teacher（TeacherID，TeacherName，CollegeID）。学院表College中已有20个学院信息，教师表Teacher中已有4000名教师信息。假定需要查询输出“软件学院”的教师名单，其查询SQL语句如下：", "\n", "\nSELECT  A.CollegeName,  ", "B.TeacherID, ", " ", "B.TeacherName\n", "FROM  College  AS  A,  Teacher  AS  ", "B\n", "WHERE  A.CollegeID=", "B.CollegeID ", "AND ", "A.CollegeName=’软件学院’\n", "\n", "在执行处理该查询语句时，可以采用如下3种等价的关系运算表达式来解析该查询语句。", "\n", "Q1=ΠA", ".CollegeName", ",B", ".TeacherID", ",B", ".TeacherName", "(σA.CollegeID=B", ".CollegeID", " L A.CollegeName=’软件学院’(College×Teacher))\nQ2=ΠA", ".CollegeName", ",B", ".TeacherID", ",B", ".TeacherName", "(σA.CollegeName=’软件学院’(College∞Teacher))\nQ3=ΠA", ".CollegeName", ",B", ".TeacherID", ",B", ".TeacherName", "(Teacher∞(σA.CollegeName=’软件学院’(College)))\n\n", "\n", "1）研究分析Q1、Q2、Q3三种查询方案的执行代价，请选出一个最优查询方案。", "2）在以上最优查询方案基础上，对College表和Teacher表的主外键列创建了索引，并且CollegeName列也创建了索引，其查询代价又如何？"]], "Tag": "程序设计"}
