{"Answer": "&lt;p&gt;初始化可以像你这样&amp;#xff0c;但是除了初始化之外&amp;#xff0c;后面数组名是一个常量&amp;#xff0c;不能赋值&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么不可以在赋值语句中通过赋值运算符“＝”对字符数组整体赋值", ["下述对C语言字符数组的描述中错误的是 (c )", "\n", "\nA．字符数组可以存放字符串", "\nB．字符数组中的字符串可以整体输入、输出", "\nC．可以在赋值语句中通过赋值运算符“＝”对字符数组整体赋值", "\nD．不可以用关系运算符对字符数组中的字符串进行比较", "\n\n", "为啥c是错的嘞？", "\n\n", "难道s[10]={\"happy\"}这样 的语句不算是通过赋值运算符“＝”对字符数组整体赋值吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;(b gt 0) * 1 &amp;#43; (b lt 0) * (-1)&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["envi波段运算怎么赋值", ["envi波段运算中想把大于零的像元赋为1，小于零的赋为-1，应该怎么输入公式？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;char取值范围&amp;#xff1a;-128~127&lt;br /&gt;%u就行了&amp;#xff0c;d去掉&lt;br /&gt;想了解具体的话可以参考&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/CodeByCoder/article/details/77725155\" id=\"textarea_1635427892677_1635428192052_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C语言中 char 类型的取值范围为什么是-128&amp;#xff5e;127_当代码遇上音乐-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;我们之前已经说过关于原码、反码和补码的一些东西&amp;#xff0c;如果你没有看过&amp;#xff0c;可以点这里《 你知道原码、反码和补码吗&amp;#xff0c;进来了解一下吧 》看一下 。好了&amp;#xff0c;可能你不会太想看&amp;#xff0c;所以我们一起再来简单的复习一下&amp;#xff0c;如果我们现在有一个十进制的整数 1 &amp;#xff0c;我们知道 1 个字节等于 8 位&amp;#xff0c;一个整型数据占 4 个字节&amp;#xff0c;也就是说一个整型数据占 4 个 8 位&amp;#xff0c;也就是 32 位&amp;#xff0c;所以整数 1 用二进制表示&amp;#xff0c;如&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/CodeByCoder/article/details/77725155&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["定义字符变量a=128;为什么输出-128", ["#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "char", " a=", "128", ";\n    ", "printf", "(", "\"%d\\n\"", ",a);\n    ", "printf", "(", "\"%ud\"", ",a);\n} \n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是计算机语言通有的缺陷&lt;br /&gt;因为计算机精度有限,且对小数的存储使用的是二进制拟合,所以会造成一定的精度损失&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["增强型赋值运算为什么会出现这样", ["为什么后面会有那么一串呢？🤔🤔🤔🤔🤔"]], "Tag": "程序设计"}
{"Answer": "```\r\n\tint k = 1;\r\n00007FF6C5061575  mov         dword ptr [k],1  \r\n\tint t=(k = 2)*++k;\r\n00007FF6C506157D  mov         dword ptr [k],2  \r\n00007FF6C5061585  mov         eax,dword ptr [k]  \r\n00007FF6C5061589  inc         eax  \r\n00007FF6C506158B  mov         dword ptr [k],eax  \r\n00007FF6C506158F  mov         eax,dword ptr [k]  \r\n00007FF6C5061593  imul        eax,dword ptr [k]  \r\n00007FF6C5061598  mov         dword ptr [t],eax \r\n\r\n```\r\n\r\n从汇编来看，vs编译器是先执行了k=2，然后++k，最后计算k*k\r\n\r\n因为k=2返回的是左值而不是右值，所以这样是合理的\r\n\r\n比较早的编译器在定义k的时候加上volatile会出现返回右值的情况，这种情况下结果会是6", "Konwledge_Point": "赋值运算", "Question": ["c++中自增运算是否会影响赋值运算？", ["n = 1;", "\nc = (n = 2)* ++n;", "\n都是用VS2015运行结果是9，但是9=3*3,难道后面的自增会影响前面的赋值？", "\nn=2的赋值结果应该是2，为何会变成3呢？", "\n\n", "下边是代码测试，VS2015", "\n\n", "\n#include \"stdafx.h\"\n#include <iostream>\n#include \"stdlib.h\"\n#include \"Test.h\"\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\n\nint add(int a, int b)\n{\n    cout << \"a = \" << a << \", b = \" << b << endl;\n    int c = a + b;\n    return c;\n}\n\nint main()\n{\n\n    int n = 1;\n    int c = add( n = 2, ++n);\n    cout << \"c = \" << c << \", n = \"<< n<<endl;\n    cout << \"---------------\" << endl;\n    n = 1;\n    c = add(++n, n = 2);\n    cout << \"c = \" << c << \", n = \" << n << endl;\n    cout << \"---------------\" << endl;\n    n = 1;\n    c = add(n = 2, n++);\n    cout << \"c = \" << c << \", n = \" << n << endl;\n    cout << \"---------------\" << endl;\n    n = 1;\n    c = add(n++, n = 2);\n    cout << \"c = \" << c << \", n = \" << n << endl;\n    cout << \"---------------\" << endl;\n    n = 1;\n    c = (n = 2)* ++n;\n    cout << \"c = \"<< c << \", n = \"<< n << endl;\n    cout << \"---------------\" << endl;\n    system(\"pause\");\n    return 0;\n}\n\n", "\n\n", "运行结果：", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/253131051066125.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;第二道题编译都不过&amp;#xff0c;印刷错误吧&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["两个赋值运算的程序题", ["1 这个程序我最后又算了一遍是4，7，6", "   但答案是：4 7，7", "2  这个程序我不知道怎么做的，能得到这个答案", "求详解诶"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;后面还有一个赋值。&lt;br /&gt;a&amp;#61;c1,c1&amp;#61;&amp;#39;k&amp;#39;对应的十进制数是107&lt;br /&gt;输出在最后输出的&amp;#xff0c;输出的结果就是最后更新后的值。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c++赋值运算中类型转换的规则", ["各位大佬能不能告诉我一下为什么运行结果不是8 322.0 107 B"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;确实是A&lt;/p&gt;\n&lt;p&gt;重点是表达式&amp;#xff0c;什么是表达式  X&amp;#61;a&amp;#43;b&amp;#xff0c;就是表达式&lt;/p&gt;\n&lt;p&gt;上面的选项 C和D&amp;#xff0c;你可以想象为  C: x&amp;#61;&amp;#43;&amp;#43;k&amp;#xff1b;D:x&amp;#61;k&amp;#43;1;&lt;/p&gt;\n&lt;p&gt;所以A是错误的 x&amp;#61;k&amp;#43;&amp;#43;;  x&amp;#61;0&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["求解是赋值运算还是自加运算", ["想问问各位大佬，这道题我选的340D理由是k+1后k的值还是不变，但是老师说这道题选A因为是后加1所以其他表达式的值都是1A的表达式k是0"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;问题出在这一行代码上&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;int &lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[i]&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在定义数组时&amp;#xff0c;你使用了变量 i 来指定数组的长度。但是在这个时候&amp;#xff0c;i 的值还没有被初始化&amp;#xff0c;它是随机的。所以&amp;#xff0c;当你试图访问 a[0] 到 a[49] 时&amp;#xff0c;程序可能会试图访问未分配的内存&amp;#xff0c;导致运行时错误。&lt;/p&gt;\n&lt;p&gt;当你将数组长度改为 5 和 4 时&amp;#xff0c;它们的值是已知的&amp;#xff0c;因此不会有这个问题。&lt;/p&gt;\n&lt;p&gt;要解决这个问题&amp;#xff0c;你可以在读取输入之前将 i 初始化为数组的长度&amp;#xff0c;或者使用固定的数组长度。例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-selector-id\"&gt;#define&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;ARRAY_LENGTH&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;50&lt;/span&gt;\n&lt;span class=\"hljs-selector-tag\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[ARRAY_LENGTH]&lt;/span&gt;;\n\n&lt;span class=\"hljs-comment\"&gt;// 或者&lt;/span&gt;\n\n&lt;span class=\"hljs-selector-tag\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;i&lt;/span&gt;, &lt;span class=\"hljs-selector-tag\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[50]&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["C语言数组的定义赋值运算", ["\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "{\n ", "int", " sum=", "0", ",i=", "0", ";\n ", "float", " aver=", "0.0", ";\n ", "int", " a[i];\n ", "int", " max=", "0", ";\n ", "for", "(i=", "0", ";i<=", "49", ";i++){\n   ", "scanf", "(", "\"%d\"", ",&a[i]);\n }\n max=a[", "0", "];\n ", "for", "(i=", "0", ";i<=", "49", ";i++)\n {\n ", "if", "(a[i]>max)\n max=a[i];\n sum+=a[i];\n}\n aver=sum/", "50", ";\n ", "printf", "(", "\"%d,%f\"", ",max,aver);\n ", "return", " ", "0", ";\n}\n为什么编译的时候没出错，但是运行不出来啊。但如果把", "50", "和", "49", "改成", "5", "和", "4", "就可以运行了。这是怎么一回事啊？\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;i&amp;#43;&amp;#43; 是先赋值再加一&amp;#xff0c;所以就是&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                                tempArr[p] &amp;#61; arr[p1];&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                                 p &amp;#61; p&amp;#43;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                                 p1 &amp;#61; p1 &amp;#43;1;&lt;/span&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["关于自加加和赋值运算的问题", ["25行，怎么理解吖，求分解", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;printf()函数是自带打印的&amp;#xff0c;调用后必然打印。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["这里不就是一个赋值运算吗？为什么会打印出来", ["请问红色荧光笔部分为什么会打印出来啊？", "这里不就是把printf这个函数赋值给n吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;scanf(&amp;#34;%c %c %c %c %c&amp;#34;,...........);&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["赋值运算，初学者不太懂 请帮帮忙", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;要看具体程序&amp;#xff0c;因为问题并不是出在你以为的这句话&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["赋值运算等号左右两边是一个变量会运行超时。。", ["c语言编程里面，我见过很多循环体里面有sum = sum + 变量 ；但是写里面写稍微复杂一点就不行了，像sum = (1 + sum) * 2;就会显示运行超时，为什么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你把R写到字符串中&amp;#xff0c;就只是当字母处理了&amp;#xff0c;不会当变量的啊&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么运算赋值后，输出仍是字母", ["\n", "为啥给字母赋值运算后，输出仍是字母", "想不明白", "提前谢谢各位老师了！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int c&amp;#61;1&amp;lt;2&lt;br /&gt;首先 小于 &amp;lt; 的优先级要高于赋值运算符 &amp;#61; 的&amp;#xff0c;所以先进行1与2之间的比较 1&amp;lt;2成立 成立则为真 结果为1&lt;br /&gt;c&amp;#61;1&lt;br /&gt;以上仅供参考&amp;#xff0c;&lt;strong&gt;希望对题主有所帮助&amp;#xff01;&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["赋值运算，1<2满足，则c=1，为什么c=0?", ["int c=1<2，满足1，不满足0，则c=多少？请高人指点，谢谢！!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;三目运算类似&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;cond&lt;/span&gt;:\n  &lt;span class=\"hljs-keyword\"&gt;do&lt;/span&gt; a\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n  &lt;span class=\"hljs-keyword\"&gt;do&lt;/span&gt; b\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;所以也可以用于字符串操作&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["在Java中三目运算能用于字符串的判断吗？", ["三目运算除了用于赋值运算中还可以用于字符串吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int k &amp;#61; 11;&lt;br /&gt;k&amp;#43;&amp;#43;就是先赋值后加1&amp;#xff0c;所以表达式是11&amp;#xff0c;k的值是12&lt;br /&gt;而&amp;#43;&amp;#43;k是先加一后赋值&amp;#xff0c;这是k和k的表达式都为12&lt;/p&gt;\n&lt;p&gt;举个例子&amp;#xff1a;&lt;br /&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;\n&lt;p&gt;void main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int k&amp;#61;11;&lt;/span&gt;&lt;br /&gt;printf(&amp;#34;%d\\n&amp;#34;,k&amp;#43;&amp;#43;);//11&lt;br /&gt;printf(&amp;#34;%d&amp;#34;,k);//12&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;第二个&lt;/p&gt;\n&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;\n&lt;p&gt;void main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int k&amp;#61;11;&lt;/span&gt;&lt;br /&gt;printf(&amp;#34;%d\\n&amp;#34;,&amp;#43;&amp;#43;k);//12&lt;br /&gt;printf(&amp;#34;%d&amp;#34;,k);//12&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;希望采纳&amp;#xff0c;感谢&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["若k为int型变量且赋值11，运算k++后，表达式得值为12", ["若k为int型变量且赋值11，运算k++后，表达式得值为12    判断题  是对的还是错的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为你这么写的话&amp;#xff0c;b不是还没有定义么&lt;br /&gt;int a,b;&lt;br /&gt;a&amp;#61;b&amp;#61;5;&lt;br /&gt;这样是可以的&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么ab连续赋值不能运算，求解！！", ["ab分开赋值可以算，这个为啥不行，求解！！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a&amp;#xff1a;6  --&amp;#xff1e;5  --&amp;#xff1e;4&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么a＝4，b等于14，好奇怪啊", ["这是如何计算的，求解答，我的理解是这样的，符号在变量前，先自加(减)1，再做赋值运算", "符号在变量后，则先做赋值运算，再加(减）1"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; System.out.println(  1 &amp;gt; 5 ? &amp;#34;a&amp;#34;: &amp;#34;b&amp;#34;);&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["Java的三元运算符（?）是只能做赋值操作吗?与C中的三元运算符的区别？", ["比如C中可以这么写：", "1>5 ? printf(\"1\") : printf(\"5\");", "可以正常编译运行。", "\n", "但java好像不允许1>5这个写法，必须用变量来代替,比如:", "int a = 1, b = 5;   a>b  要这么写，", "就算这样写了后，Eclipse会在b下面打红线说不能把int转换为boolean，", "也就是说编译器没有把(a>b)这个当boolean，而是把b当成了boolean？", "如果用括号括起来(a>b)?System.out.printf(\"1\") : System.out.printf(\"5\");", "编译器又报错说让我把括号去掉。", "那java的三元运算符是不是并不能完全的当成一个if   else来用?好像没法让他进行输出操作?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;等号的优先级是最低的&amp;#xff0c;计算完表达式再赋值&amp;#xff0c;有没有具体的语句呢&amp;#xff1f;是运算符的优先级不清楚还是别的问题&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["赋值表达式如何进行运算?", ["赋值表达式如何进行运算?老是绕不过来，希望高人指点，万分感谢感谢!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先 a 是数组名&amp;#xff0c;数组名是指向这个数组内存的首地址。其次&amp;#xff0c;在数值是 a &amp;amp;a &amp;amp;a[0] 都是相等的&amp;#xff0c;且在内存上都是指向这段数组的首地址。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["ip1=a;我赋值给ip1的不是数组a，没有加取地址符号&为什么ip1中存放的确是a[]0的值", ["// 47指针的运算.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。", "//", "\n", "#include ", "using namespace std;", "\n", "int main()", "{", "   //声明数组，变量和指针变量", "    int a[] = { 1,2,3,4,5,6 };", "    int* ip1, * ip2;", "    //测试指针的赋值运算", "    ip1 = a;", "    ip2 = ip1;", "    cout << \"*ip1=\" << (*ip1) << endl;", "    cout << \"*ip2=\" << (*ip2) << endl;", "    //测试指针的自增自减运算和组合运算", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;推荐《C程序设计语言》&lt;br /&gt;另外CSDN C的技能树 。菜鸟教程也可以。开始学习就不晚&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["要求的调程序是这样搞吗", ["\n", "\n", "还不太懂程序设计，有推荐的课程吗,有人能讲一下程序中赋值运算的具体信息吗"]], "Tag": "程序设计"}
{"Answer": "```\r\nfloat aver(float a[],int n) { //用for循环求出所有值的和，再除以个数n \r\n    int i;\r\n    float sum;\r\n//  float sum = 0; // 要赋初值\r\n\r\n    for(i=0;i&lt;n;i++) \r\n        sum+=a[i];\r\n    \r\n    return sum/n; //返回结果 \r\n}\r\n```\r\n这个函数sum没有赋初值\r\n```\r\n#include &lt;stdio.h&gt; \r\n\r\n#define N 96\r\n\r\nint main() { \r\n\tfloat Temp_X[N] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.46667, 11.4667, 31.6, 52.7333, 80.3333, 116.333, 156.6, 199.4, 242.2, 283.4, 329.2, 379.333, 431.333, 482.6, 541, 594.4, 643.533, 692.133, 736.267, 772.667, 810.133, 841.867, 868.2, 892.4, 917.667, 939.8, 954.667, 969, 976.8, 983.4, 987.467, 994.933, 1023.67, 875.2, 873.933, 758.8, 678.2, 515.867, 782.533, 908.8, 779.2, 831.4, 645.533, 734.067, 679.533, 610.267, 565.067, 512.467, 462, 405.2, 354.133, 302, 247.8, 191.533, 140, 94.2667, 57.5333, 25.9333, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };            //定义初始化数组X \r\n\tfloat Temp_Y[N] = {0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 1.785, 2.57833, 3.927, 5.79233, 7.379, 9.48133, 11.1473, 12.4167, 13.6627, 16.193701, 18.248699, 19.042, 19.042, 19.105301, 16.6383, 17.240999, 14.631, 11.8217, 11.663, 12.155, 15.488, 21.859301, 19.32, 19.042, 19.6133, 21.105, 22.9937, 20.827299, 23.858299, 23.0333, 19.2883, 15.6937, 21.5893, 23.802999, 20.518299, 21.5893, 17.907301, 17.971001, 17.574301, 16.781, 15.5513, 12.3773, 10.2747, 8.60867, 6.86333, 5.39567, 3.88767, 2.856, 2.142, 2.142, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952 }; //定义初始化数组Y \r\n\t\r\n    float xSum = 0,ySum = 0, \r\n    float xySum=0, x2Sum=0;//这里赋值了后面就忘了 \r\n    float a, b;\r\n\t\r\n\tfor( int i = 0; i &lt; N; i++ ) {\r\n\t    xySum += (Temp_X[i] * Temp_Y[i]);\r\n\t    x2Sum += (Temp_X[i] * Temp_X[i]);\r\n\t    xSum += Temp_X[i];\r\n\t    ySum += Temp_Y[i];\r\n\t}\r\n//\ta = (xySum - 96 * xAver * yAver) / (x2Sum-96 * xAver * xAver);  \r\n\ta = (N * xySum - xSum * ySum)/(N * x2Sum - xSum*xSum);\r\n\tb = ySum / N - a * xSum / N;\r\n\tprintf( \"a = %f\\n b = %f\", a, b ); \r\n}\r\n```\r\n[最小二乘法](https://blog.csdn.net/qq_35082030/article/details/88709990 \"\")", "Konwledge_Point": "赋值运算", "Question": ["为什么调用函数参与运算再给变量赋值，数就不对了", ["求线性回归方程a和b值，结果明显不对", "\n代码如下", "\n\n", "#include ", "\n                                                         //调用库函数 ", "\nint main()                                                //主函数 ", "\n{   float aver(float a[],int);                         //声明求均值函数 ", "\n\n", "float Temp_X[96] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.46667, 11.4667, 31.6, 52.7333, 80.3333, 116.333, 156.6, 199.4, 242.2, 283.4, 329.2, 379.333, 431.333, 482.6, 541, 594.4, 643.533, 692.133, 736.267, 772.667, 810.133, 841.867, 868.2, 892.4, 917.667, 939.8, 954.667, 969, 976.8, 983.4, 987.467, 994.933, 1023.67, 875.2, 873.933, 758.8, 678.2, 515.867, 782.533, 908.8, 779.2, 831.4, 645.533, 734.067, 679.533, 610.267, 565.067, 512.467, 462, 405.2, 354.133, 302, 247.8, 191.533, 140, 94.2667, 57.5333, 25.9333, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };            //定义初始化数组X \nfloat Temp_Y[96] = {0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 0.595, 1.785, 2.57833, 3.927, 5.79233, 7.379, 9.48133, 11.1473, 12.4167, 13.6627, 16.193701, 18.248699, 19.042, 19.042, 19.105301, 16.6383, 17.240999, 14.631, 11.8217, 11.663, 12.155, 15.488, 21.859301, 19.32, 19.042, 19.6133, 21.105, 22.9937, 20.827299, 23.858299, 23.0333, 19.2883, 15.6937, 21.5893, 23.802999, 20.518299, 21.5893, 17.907301, 17.971001, 17.574301, 16.781, 15.5513, 12.3773, 10.2747, 8.60867, 6.86333, 5.39567, 3.88767, 2.856, 2.142, 2.142, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952 }; //定义初始化数组Y \nfloat a,b,sum1=0,sum2=0;                         //定义变量，a，b为线性回归方程y=ax+b中a，b的值，sum1，sum2，为求a时分步求解用的变量 \nint i,j;                                              //i，j为循环时使用的变量 \nfor(i=0;i<96;i++)\n{\n    sum1+=(Temp_X[i]*Temp_Y[i]);\n    sum2+=(Temp_X[i]*Temp_X[i]);\n}\na=(sum1-96*aver(Temp_X,96)*aver(Temp_Y,96))/(sum2-96*aver(Temp_X,96)*aver(Temp_X,96));  //通过线性回归方程公式求出a值 \nb=aver(Temp_Y,96)-(a*aver(Temp_X,96));\nprintf(\"a=%f,b=%f\",a,b); \n", "\n\n", "}", "\nfloat aver(float a[],int n)   //求均值的函数 ", "\n{                                //用for循环求出所有值的和，再除以个数n ", "\n    int i;", "\n    float sum;", "\n    for(i=0;i<n;i++)", "\n    {", "\n        sum+=a[i];", "\n    }", "\n    return sum/n;                 //返回结果 ", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运行是可以运行啊&amp;#xff0c;但是不会根据你输入的值去找对应的字呀&amp;#xff0c;一个等号表示赋值操作&amp;#xff0c;为真&amp;#xff0c;你不是永远输出男么&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["关于C语言中=和==", ["\n", "题目是判定X等于，所以应该用==，但是第一次我用的=，是赋值运算，为什么也能正常运行呢"]], "Tag": "程序设计"}
{"Answer": "这里说的随机，并不是数学上的随机的那个随机值。而是指因为编译器分配了空间，而没有刻意往里面初始化或者填0，从而原来是什么，就是什么值。\r\n所以这个值每次运行可能都是一样的，但是放在不同编译器不同环境又是不同并且不能确定的。\r\n之所以你看到22，这个可能是因为这个变量在堆栈上分配，它之前的函数调用的时候正好写在这里这么个值。虽然main是入口函数，但是实际上操作系统创建进程，到执行你的代码，还是调用了别的函数的，所以堆栈上有数据。", "Konwledge_Point": "赋值运算", "Question": ["关于c++不赋值int，字数字数字数", ["#include <iostream>\nusing namespace std; \nint main(){\n    int a,b;\n    cout<<a<<endl;\n    int c=a+b;\n    cout<<c<<endl; \n    cout<<\"a+b=\"<<a+b; \n    return 0;\n\n} \n", "\n\n", "如上代码中，定义a,b两个整型变量，但未赋值，进行加法运算最后结果为什么是22？", "\n是内存随机给他俩赋值了吗？"]], "Tag": "程序设计"}
{"Answer": "a+=b+=a+=b; \r\n等价于\r\na=a+(b=b+(a=a+b));\r\n\r\n1、运算过程中注意a是原子类型 值是拷贝的\r\n2、a=a+(××××); //+结合率是从左到右。 即先将a压栈 然后计算括号内的，这样算就明白了，具体请看用javap -verbose 来观看字节码操作\r\n   0:   iconst_2   \r\n   1:   istore_1   ---&gt;a\r\n   2:   iconst_5\r\n   3:   istore_2   ---&gt;b\r\n   4:   iload_1    载入a(2)\r\n   5:   iload_2    载入b(5)\r\n   6:   iload_1    载入a(2)\r\n   7:   iload_2    载入b(5)\r\n   8:   iadd       7 (第6和7行累计 结果压栈)\r\n   9:   dup        复制栈顶\r\n   10:  istore_1   a(7)  把栈顶结果保存到a\r\n   11:  iadd       12 （栈顶7+第5行）\r\n   12:  dup        复制12\r\n   13:  istore_2   b(12) 结果保存到b\r\n   14:  iadd       12+2（栈顶+第4行）\r\n   15:  istore_1   a(14)", "Konwledge_Point": "赋值运算", "Question": ["请教 java中 a+=b+=a+=b 的详细运算过程", ["本人使用java3年，也算是个程序小鸟，但是总喜欢把问题研究的透彻。", "\n原题是这么个样子：", "\nint a = 2，b = 5；", "\na+=b+=a+=b；", "\n问最后a，b分别是多少。", "\n\n", "我原本以为整个过程是这样的", "\n0.原式清晰化的表达一下： a+=(b+=(a+=b));", "\n1.先算最里面的括号 a+=b //a = 7；", "\n2.再算中间括号     b+=a //b = 12;", "\n3.计算最后括号     a+=b //a = 19", "\n\n", "但是实际结果出乎我的意料，答案是a=14 b=12", "\n\n", "后来我想了一下，出现这样的原因是因为第一次计算最里面的括号并没有给a赋值。", "\n也就是说，[color=red]a，b在整个计算过程中，只进行了最后那一次的赋值运算[/color]。但是这个说法遭来了同事的反驳。", "\n\n", "因此，我在这里发帖询问，[color=blue]想彻底弄清楚，这么个表达式的整个运算过程。", "\n如果能顺便提到编译器如何实现这样操作那就更好不过了，还望知道详情的大神不吝赐教，小弟在此叩拜[/color]", "\n如果实在是腾不出时间解答这无聊的问题，给点参考资料也许，哪怕给几个搜索关键字（我都不知道该对这样的问题怎么搜索）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;当然会被重新赋值&amp;#xff0c;因为是赋值语句&lt;br /&gt;显示(a&amp;#61;4)*(a&amp;#61;3)&amp;#xff0c;值为9&amp;#xff0c;因为先执行a&amp;#61;4&amp;#xff0c;再执行 a&amp;#61;3&amp;#xff0c;最后执行a * a &amp;#61; 3 * 3 &amp;#61; 9&lt;br /&gt;然后a-&amp;#61;9&amp;#xff0c;相当于 a&amp;#61;a-9&amp;#61;3-9 &amp;#61; -6&lt;br /&gt;最后 a&amp;#43;&amp;#61;-6&amp;#xff0c;所以a&amp;#61;-12&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["运算过程中，变量会不会被重新赋值？", ["已知double a=5.2; ，则语句a+=a-=(a=4)*(a=3);运行后a的值为？", "在运算过程中，a有没有被重新赋值？", "运算a+＝时的a是5.2还是4？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;0、null、NaN、undefined、&amp;#34;&amp;#34; 转成布尔值为false 其他则一律返回true&amp;#xff1b;&lt;br /&gt;然后就看代码    x&amp;#43;&amp;#43;   此时还是1    但是||  或   --------一真则真    y&amp;#43;&amp;#43;就不计算了&lt;br /&gt; 输出的时候  x在上一步&amp;#43;&amp;#43;了  所以 x成了2    y是1                    上面的x&amp;#43;&amp;#43;是true    赋值给了c   c就是1了&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c语言初学者的小问题，帮一下忙", ["为什么答案是211？", "\n", "#include <stdio.h>\nint main()\n{\n    int ", "c", ",", " ", "x", ",", " y", ";", "\n    ", "x", " ", "=", " ", "1", ";", "\n    y ", "=", " ", "1", ";", "\n    ", "c", " ", "=", " ", "0", ";", "\n    ", "c", " ", "=", " ", "x", "++ || y++", ";;", "\n    printf(", "\"\\n%d%d%d\\n\"", ",", " ", "x", ",", " y", ",", " ", "c", ")", ";", "\n}\n\n\n", "\n", "211", "\n", "赋值运算", "\n", "为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-type\"&gt;A&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;B&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;100.0&lt;/span&gt;\n&lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;type&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;A&lt;/span&gt;),&lt;span class=\"hljs-keyword\"&gt;type&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;B&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你这是根本没去上课吗&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["变量赋值的判断类型与运算", ["如何将100赋值给变量A，将100.0赋值给变量B；并分别判断A，B的变量类型"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;先是&lt;code class=\"language-javascript\"&gt;n %&amp;#61; 2&lt;/code&gt;得到&lt;code class=\"language-javascript\"&gt;n &amp;#61; 11% 2&amp;#61;1&lt;/code&gt;&lt;br /&gt;再是&lt;code class=\"language-javascript\"&gt;a %&amp;#61; n&lt;/code&gt;得到&lt;code class=\"language-javascript\"&gt;a&amp;#61;9%1&amp;#61;0&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["希望能有人给我解释下这个题", ["int a = 9, b = 8, c = 5, n = 11, m, k;", "    a %= n %= 2;", "    cout << a<<\"\\n\";", "    cout << n<<\"\\n\";  ", "\n", "为什么n的值会变成1，n不应该只是参与了a的赋值运算么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你for循环3次就输出3个6啊&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么a的值赋值为6没有进行运算却输出666", ["把a赋值为6，随后进行了for语句，语句里运算了i随后直接输出了a，为什么结果出现了666？？a没参与任何运算啊"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/weixin_33869377/article/details/94462830", "Konwledge_Point": "赋值运算", "Question": ["想把列表中俩列分别赋值到x和y,再对x和y分别对应做运算", ["import xlrd as xd", "\nimport numpy as np", "\nfrom minepy import MINE", "\n\n", "data =xd.open_workbook (r'C:\\Users\\dengm\\Desktop\\text1.xls') #打开excel表所在路径", "\nsheet = data.sheet_by_name('sheet1')  #读取数据，以excel表名来打开", "\nlist = []", "\nfor r in range(sheet.nrows): #将表中数据按行逐步添加到列表中，最后转换为list结构", "\n    data1 = []", "\n    for c in range(sheet.ncols):", "\n        data1.append(sheet.cell_value(r,c))", "\n    list.append(list(data1))", "\n\n", "x1,x2,x3,...,xk = list[i:i+k]    #默认i=0,k=len(List)", "\ny1,y2,y3,...,yk = list[i:i+k]    #默认i=0,k=len(List)", "\nmine = MINE(alpha=0.6, c=15)", "\nmine.compute_score(xk, yk)", "\n\n", "print(\"Without noise:\")", "\nprint(\"MIC\", mine.mic())", "\n\n", "print(xk)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;宏定义的需要把printf(&amp;#34;%d\\n&amp;#34;, pi(i&amp;#43;&amp;#43;)); 变成 printf(&amp;#34;%d\\n&amp;#34;, pi(i)); &amp;#43;&amp;#43;i;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["用函数和宏定义写出来的代码输出来的结果不一样？？", ["这是函数的", "\n\n", "\n", "#include<stdio.h>\nint main()\n{\n\tint i=1;\n\tint sq(int y);\n\twhile(i<=5)\n\t{\n\t\tprintf(\"%d\\n\",sq(i++));\n\t}\n}\nint sq(int y)\n{\n\treturn((y)*(y));\n}", "\n\n", "然后这是宏定义的", "\n\n", "\n", "#include<stdio.h>\n#define pi(y) ((y)*(y))\nint main()\n{\n\tint i=1;\n\twhile(i<=5)\n\t{\n\t\t\n\t\tprintf(\"%d\\n\",pi(i++)); \n\t}\n } "]], "Tag": "程序设计"}
{"Answer": "同名函数会被覆盖，而且xxxx=赋值事件也会覆盖，写一个函数就行了，传入参数\r\n\r\n```\r\n &lt;html&gt;\r\n&lt;head&gt;\r\n    &lt;script type='text/javascript'&gt;\r\n        window.onload = function () {\r\n            for (var i = 1; i &lt;= 27; i += 3) compute('txt' + i, 'txt' + (i + 1), 'txt' + (i + 2))\r\n        };\r\n        function compute(a,b,c) {\r\n            q = parseFloat(document.getElementById(a).value);\r\n            r = parseFloat(document.getElementById(b).value);\r\n            if (q &amp;&amp; r) {\r\n                document.getElementById(c).value = (q / r).toFixed(2);\r\n            }\r\n        }\r\n    &lt;/script&gt;\r\n&lt;/head&gt;\r\n&lt;body&gt;\r\n    &lt;input id=\"txt1\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt2\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt3\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt4\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt5\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt6\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt7\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt8\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt9\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt10\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt11\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt12\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt13\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt14\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt15\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt16\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt17\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt18\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt19\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt20\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt21\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt22\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt23\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt24\" size=\"1\" readonly&gt;\r\n    &lt;br&gt;\r\n\r\n\r\n\r\n\r\n\r\n    &lt;input id=\"txt25\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt26\" type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"&gt;\r\n    &lt;input id=\"txt27\" size=\"1\" readonly&gt;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n&lt;/body&gt;\r\n&lt;/html&gt; \r\n```", "Konwledge_Point": "赋值运算", "Question": ["问题又来了，分别赋值了9个之后为什么跑起来只有一个能运算？不清楚问题出在哪里了", ["\n\n", " <html> \n<head>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    a=parseFloat(document.getElementById(\"txt1\").value);\n    b=parseFloat(document.getElementById(\"txt2\").value);\n    if(a!=\"\" && b!=\"\"){\n        document.getElementById(\"txt3\").value=(a/b).toFixed(2);\n    }\n}\n</script>\n\n\n\n\n\n\n\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    c=parseFloat(document.getElementById(\"txt4\").value);\n    d=parseFloat(document.getElementById(\"txt5\").value);\n    if(c!=\"\" && d!=\"\"){\n        document.getElementById(\"txt6\").value=(c/d).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    e=parseFloat(document.getElementById(\"txt7\").value);\n    f=parseFloat(document.getElementById(\"txt8\").value);\n    if(e!=\"\" && f!=\"\"){\n        document.getElementById(\"txt9\").value=(e/f).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    g=parseFloat(document.getElementById(\"txt10\").value);\n    h=parseFloat(document.getElementById(\"txt11\").value);\n    if(g!=\"\" && h!=\"\"){\n        document.getElementById(\"txt12\").value=(g/h).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    i=parseFloat(document.getElementById(\"txt13\").value);\n    j=parseFloat(document.getElementById(\"txt14\").value);\n    if(a!=\"\" && b!=\"\"){\n        document.getElementById(\"txt15\").value=(i/j).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    k=parseFloat(document.getElementById(\"txt16\").value);\n    l=parseFloat(document.getElementById(\"txt17\").value);\n    if(k!=\"\" && l!=\"\"){\n        document.getElementById(\"txt18\").value=(k/l).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    m=parseFloat(document.getElementById(\"txt19\").value);\n    n=parseFloat(document.getElementById(\"txt20\").value);\n    if(m!=\"\" && n!=\"\"){\n        document.getElementById(\"txt21\").value=(m/n).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    o=parseFloat(document.getElementById(\"txt22\").value);\n    p=parseFloat(document.getElementById(\"txt23\").value);\n    if(o!=\"\" && p!=\"\"){\n        document.getElementById(\"txt24\").value=(o/p).toFixed(2);\n    }\n}\n</script>\n<script type='text/javascript'>\nonload=compute;\nfunction compute(){\n    q=parseFloat(document.getElementById(\"txt25\").value);\n    r=parseFloat(document.getElementById(\"txt26\").value);\n    if(q!=\"\" && r!=\"\"){\n        document.getElementById(\"txt27\").value=(q/r).toFixed(2);\n    }\n}\n</script>\n</head> \n<body>\n<input  id=\"txt1\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt2\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt3\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n\n\n<input  id=\"txt4\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt5\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt6\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n\n<input  id=\"txt7\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt8\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt9\" size=\"1\" readonly>\n<br>\n\n\n\n\n<input  id=\"txt10\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt11\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt12\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n<input  id=\"txt13\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt14\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt15\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n<input  id=\"txt16\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt17\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt18\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n<input  id=\"txt19\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt20\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt21\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n<input  id=\"txt22\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt23\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt24\" size=\"1\" readonly>\n<br>\n\n\n\n\n\n<input  id=\"txt25\"  type=\"hidden\" value=\"123123\" size=\"1\" readonly oninput=\"compute()\"> \n<input  id=\"txt26\"  type=\"hidden\" value=\"123123\" size=\"1\"readonly oninput=\"compute()\"> \n<input id=\"txt27\" size=\"1\" readonly>\n\n\n\n\n\n\n\n\n\n\n</body> \n</html> \n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;两种传参方式&amp;#xff0c;首先主函数定义数组char a[5],第一种对端函数形参是指针int fun(char *p),主函数应取数组地址过去&amp;#xff0c;fun(&amp;amp;a);第二种对端函数形参为数组int (char p[]),主函数可直接传数组过去&amp;#xff0c;fun(a)&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["怎么把字符数组赋值给其他函数形参", ["就是单纯的不知道怎么做。", "函数的字符串数组结果要回的函数开头参与运算，", "但不知道格式也不知道程序编译是不动，也不会报错。求邦邦"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;非常抱歉&amp;#xff0c;本次您提出的有问必答问题&amp;#xff0c;技术专家团超时未为您做出解答&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;本次提问扣除的有问必答次数&amp;#xff0c;已经为您补发到账户&amp;#xff0c;我们后续会持续优化&amp;#xff0c;扩大我们的服务范围&amp;#xff0c;为您带来更好地服务。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["arr是一个数组的名字，那么*(&arr) 是什么 ？", ["arr是一个数组的名字，那么*(&arr) 是什么 ？ 很多人会说是数组的首元素的指针，但是&arr 的时候，arr是解释为数组的", "\n", "int  arr[3] = {1,2,3}；", "int ( * p)[3] = arr；        p是指向数组arr的指针，这句没问题吧？", "\n", "int a= * p；  按道理p是arr数组的指针，那么 * p就是arr数组，但是这这样写语句 * p 被解释会int*类型", "\n", "编译的时候警告   * p 被认为是 int * 类型指针，这边 * p 是指向数组第一个元素1的指针", "\n", "\n", "运行起来看下，单独输出 * p 被解释为 数组类型，* p被认为是arr数组，但是当参与到赋值运算的时候，又被解释成int* 类型", "\n"]], "Tag": "程序设计"}
{"Answer": "```\r\nstruct ff *p=(struct ff *)malloc(sizeof(struct ff));\r\n这里少一个ff\r\n最后一行没问题\r\n```", "Konwledge_Point": "赋值运算", "Question": ["c语言结构体成员指针运算的问题", ["有结构体如下", "\nstruct ff{", "\nint   b;", "\nint *c;", "\n};", "\nstruct ff *p=(struct ff *)malloc(sizeof(struct));", "\np->c=(int *)malloc(sizeof(int)*5);", "\n*(p->c+1)=5;", "\n最后一句这样的指针运算，引用，赋值。是否合法。"]], "Tag": "程序设计"}
{"Answer": "4×4的矩阵，数组大小应该定义为A[4][4]吧", "Konwledge_Point": "赋值运算", "Question": ["用C语言实现两个4x4矩阵相乘，系统没有报错，但是结果是错的······", ["\n                                                                                                                  这部分想要实现的功能是：在已经输入的一个二维数组中找到最大值和最小值并且输出，还要写出最大值和最小值所在的行和列数。", "\n问题：系统编译后没有报错，但是最后现实的结果却是错的，例如：", "\n这部分要实现的功能是：分别求出这个矩阵的两条对角线之和。问题：但是每次求和是总有一条是错的·······", "\n\n", "实在是不知道哪里错了，求各路大神帮帮忙。。。。", "\n\n", "有尝试过单步调试，但是它好像直接就跳过子函数了。。。。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;直接输入xx%的话需要分割出数字再计算&lt;br /&gt;例如&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;x&amp;#61;&lt;span class=\"hljs-selector-tag\"&gt;input&lt;/span&gt;()&lt;span class=\"hljs-selector-class\"&gt;.split&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;%&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(str(int(x[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;0.01&lt;/span&gt;))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/863307305746190.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["python中进行数值运算，为什么不能直接输入百分数进行运算", ["python中进行数值运算，为什么不能直接输入百分数进行运算"]], "Tag": "程序设计"}
{"Answer": "结果不可预料，和编译器的编译有关。返回值（对于x86 cpu来说）其实就是函数返回的时候 eax 寄存器的值。具体要看函数生成的机器代码是什么", "Konwledge_Point": "赋值运算", "Question": ["在调用函数中，为何如果没有返回值，图中的p能接受且只能接受调用函数中c的第一次赋值？", ["\n\n", "如图，忍不住好奇试了试去掉return，居然能输出结果，然后我发现调用函数的两条表达式均有执行，但赋值给p的结果只是运算c = a * b后c的值，这是为什么......"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个简单&amp;#xff0c;因为a是int型&amp;#xff0c;a*a当然也是int型 &amp;#xff0c;需要long long来强制转换。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["不同数据类型的运算与赋值", ["为什么第七行不加long long会溢出。", "比如我输入1000000，结果不对。但我明明把sum定义成long long 了呀！感觉有点迷。请帮忙看看，谢谢啦！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C&amp;#43;&amp;#43;可以吗&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["实现一个表达式求值的工具(类似计算器，但是接受变量赋值)", ["使用c语言(最好是c语言，c++可以接受，只接受这两种语言)，编写一个表达式求值工具，接受两种输入形式:", "例如", "        1，a = 233, b = 1,a ＋ b", "       或者a = 233，a + 1", "        2，1 + 1", "输出结果为赋值计算表达式的值，计算限定在四则运算的浮点数计算，变量名不局限于a, b 上述只是举例说明，变量由用户输入", "(可联系我私发具体操作要求)"]], "Tag": "程序设计"}
{"Answer": "(b=4) * (a=3)把4赋值给b，3赋值给a，表达式的值为3 * 4=12\r\na-=(b=4) * (a=3)即a=3-12=-9\r\na+=a-=(b=4) * (a=3)即a=-9+-9=-18", "Konwledge_Point": "赋值运算", "Question": ["一个简单的运算的问题", ["求解释运算过程。"]], "Tag": "程序设计"}
{"Answer": "&amp;f就是Folder类型指针。至于Folder &amp;f表示save的形参是引用，引用则只是变量的别名，表示的仍然是值。因此&amp;f表示的是f的地址。", "Konwledge_Point": "赋值运算", "Question": ["C++ primer 里面STL容器set的insert操作问题。。。", ["在C++primer 5th 的13.4节里面有个类的定义是这样的：", "\nclass Message", "\n{", "\n    friend void swap(Message&, Message&);", "\n    friend class Folder;", "\npublic:", "\n    //folders被隐式初始化为空集合", "\n    explicit Message(const string &str=\"\"):contents(str){}", "\n    //拷贝控制成员，用来管理指向本Message的指针", "\n    Message(const Message&);        //拷贝构造函数", "\n    Message& operator=(const Message&); //拷贝赋值运算符", "\n    ~Message();                     //析构函数", "\n    //从给定的Folder中添加/删除本Message", "\n    void save(Folder&);", "\n    void remove(Folder&);", "\n    //显示有几个Message对象", "\n    void show();", "\nprivate:", "\n    string contents;        //实际消息文本", "\n    set folders;   //包含本Message的folder", "\n    //拷贝构造函数，拷贝赋值运算符合析构函数所使用的工具函数", "\n    //将本message添加到指向参数的folder中", "\n    void add_to_Folders(const Message&);", "\n    //从folders中的每个Folder中删除本Message", "\n    void remove_from_Folders();", "\n    //向folders添加和删除", "\n    void addFldr(Folder *f){folders.insert(f);}", "\n    void remFldr(Folder *f){folders.erase(f);}", "\n};", "\n其中的成员函数 void save(Folder&);定义为：", "\nvoid Message::save(Folder &f)", "\n{", "\n    folders.insert(&f);     //将给定Folder添加到我们的Folder列表中", "\n    f.addMsg(this);         //将本Message添加到f的Message中", "\n}", "\n请教下大神，folders不是set< Folder的指针> 类型么，为什么在函数里面folders可以insert像Folder& 的类型（不是应该insert像 Folder的指针的类型）？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码有误&amp;#xff0c;su2不能得到全部累加的结果&amp;#xff0c; 而是每个线程最后一次计算的结果相加。四线程&amp;#xff1a;200&amp;#43;24&amp;#43;49&amp;#43;74&amp;#43;99&amp;#61;446。&lt;br /&gt;下面这个简单的例子可以体现&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/084847080136147.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["omp中reduction的疑问", ["\nvoid TestReduction2()\n{\n    ", "int", " sum = ", "100", ";        ", "//", " Assign an initial value.\n    ", "int", " su1 = ", "200", ";\n    ", "int", " su2 = ", "200", ";\n    ", "int", " su3 = ", "200", ";\n", "#pragma omp parallel for reduction(+:sum,su2,su3)", "\n    ", "for", " (", "int", " i = ", "0", "; i < ", "100", "; i++)\n    {\n        sum += i;\n        su1 = i;\n        su2 = i;\n        su3 = ", "1", ";\n    }\n    ", "printf", "(", "\"ThreadNo.%d,  Sum: %d\\n\"", ", omp_get_thread_num(), sum);\n    ", "printf", "(", "\"ThreadNo.%d,  su1: %d\\n\"", ", omp_get_thread_num(), su1);\n    ", "printf", "(", "\"ThreadNo.%d,  su2: %d\\n\"", ", omp_get_thread_num(), su2);\n    ", "printf", "(", "\"ThreadNo.%d,  su3: %d\\n\"", ", omp_get_thread_num(), su3);\n}\n\n", "int", " main()\n{\n    ", "for", " (", "int", " i = ", "0", "; i < ", "4", "; ++i)\n    {\n        TestReduction2();\n        cout << endl;\n    }\n    ", "return", " ", "0", ";\n}\n", "\n", "代码中sum是正常写法，su2和su3都是赋值运算，su3的值是标准的200+线程数(*1)，但su2不是(八核笔记本计算结果是650，四核台式机计算结果是446，且这个值不会发生变化)，请问su2的值是怎么计算出来的？", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你觉得5051不是垃圾值吗&lt;br /&gt;垃圾值之所以垃圾&amp;#xff0c;就是因为没用啊&lt;br /&gt;如果你不给变量赋初值&amp;#xff0c;那么c语言会随便给它分配一个内存&amp;#xff0c;并且不初始化&lt;br /&gt;那么它到底是个什么值是不确定的&amp;#xff0c;有可能开机之后就没有使用过&amp;#xff0c;那就是0&lt;br /&gt;也有可能是其它程序使用过的&amp;#xff0c;残留了一堆不知道干什么的数据&lt;br /&gt;如果一个算术结果不确定&amp;#xff0c;那它就是个垃圾值&amp;#xff0c;因为你没法拿来做任何用处&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["1-100和运算中未对sum赋值", ["刚刚学习c语言，用的dev C++。在打1-100所有的数之和时忘记给 sum 赋值，但是语法上却没有出错，也没有给出垃圾值，但是结果为5051，多出了一个1。用 dev C++试了一个不复制，直接输出的语句。结果答案是0.和书上说的会给出垃圾值不一样。请帮忙解答！", "\n", "*", "\n", " ", "int", " i, ", "sum", " ;\n ", "for", "(i = ", "1", "; i <= ", "100", "; ++i)\n    {", "sum", " = ", "sum", " + i;\n   }\n printf(", "\"1到100的所有数之和为%d\\n\"", ",", "sum", ");\n \n", "\n", " 在dev 上的运行结果", "\n", " 1到100的所有数之和为5051", "\n", "总结：为啥sum的结果为5051 "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;算&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["数组赋值到另一个数组里", ["#", "define", " _CRT_SECURE_NO_WARNINGS 1", "\n", "/*请随机生成一个 5*10 的二维数组，数组元素大小为 0-256，对其进行隔列取值（隔\n一列取一列），组成新的数组（5*5），求新数组的和、平均值，并找出每行的最大值。*/", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "srand", "((", "unsigned", ")", "time", "(", "0", "));               ", "//设置一个随机种子，防止运算数据输出重复", "\n    ", "int", " a[", "5", "][", "10", "],b[", "5", "][", "5", "];\n    ", "int", " i, j;\n    ", "int", " sum = ", "0", ";\n    ", "printf", "(", "\"随机生成的原数组：\\n\"", ");\n    ", "for", " (i = ", "0", "; i < ", "5", "; i++)                   ", "/*求原数组*/", "\n        ", "for", " (j = ", "0", "; j < ", "10", "; j++)\n        {\n            a[i][j] = (", "rand", "() % ", "257", ");\n        }\n    ", "for", " (i = ", "0", "; i < ", "5", "; i++)\n    {\n        ", "for", " (j = ", "0", "; j < ", "10", "; j++)\n        {\n            ", "printf", "(", "\"%d\\t\"", ", a[i][j]);\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n    ", "printf", "(", "\"变换过的数组：\\n\"", ");\n    ", "for", " (i = ", "0", "; i < ", "5", "; i++)                        ", "/*求变换过的数组*/", "\n    {\n        ", "for", " (j = ", "0", "; j < ", "10", "; j +=", "2", ")\n        {\n            b[i][j] = a[i][j];\n            ", "printf", "(", "\"%d\\t\"", ", b[i][j]);\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n    ", "/*求数组的和*/", "\n    ", "for", " (i = ", "0", "; i < ", "5", "; i++)\n        ", "for", " (j = ", "0", "; j < ", "10", "; j += ", "2", ")\n        {\n            sum = sum + b[i][j];\n        }\n    ", "printf", "(", "\"和 : %d\\n\"", ", sum);\n    ", "double", " avg = sum / ", "25", ";\n    ", "printf", "(", "\"平均值 : %.1f\\n\"", ", avg);\n    ", "/*求每行最大值*/", "\n    ", "int", " max;\n    ", "printf", "(", "\"每行元素的最大值：\\n\"", ");\n    ", "for", " (i = ", "0", "; i < ", "5", "; i++)\n    {\n        max = b[", "0", "][", "0", "];                         ", "//将max重置，防止输出的值重复", "\n        ", "for", " (j = ", "0", "; j < ", "10", "; j += ", "2", ")\n        {\n            ", "if", " (b[i][j] >= max)\n                max = b[i][j];\n        }\n        ", "printf", "(", "\"%d\\t\"", ", max);\n    }\n}\n\n\n\n", "\n", "\n", "请问这样算是建立新的数组了吗，就是将原数组5", "10的值赋到新的5", "5数组里。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;22行和32行输出是&lt;code class=\"language-javascript\"&gt;.num&lt;/code&gt;成员数据&amp;#xff0c;改为&lt;code class=\"language-javascript\"&gt;.weight&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么输出结果不是10，怎么回事10001呢", ["为什么输出结果不是10，怎么回事10001呢", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    ", "struct", " ", "date", "\n    {\n        ", "int", " year;\n        ", "int", " month;\n        ", "int", " day;\n    };\n    ", "//定义baby结构", "\n    ", "struct", " ", "baby", "\n    {\n        ", "int", " num;\n        ", "float", " weight;\n        date birthday;", "//date 为结构类型", "\n\n    };\n    ", "//声明结构变量并初始化", "\n    baby b1 = { ", "10001", ",", "10", ",{", "2002", ",", "12", ",", "25", "} };\n    ", "//下列是baby结构变量b1的引用", "\n    cout << ", "\"b1.num=\"", " << b1.num << endl;\n    cout << ", "\"b1.weight=\"", " << b1.num << endl;\n    cout << ", "\"b1.birthday.year=\"", " << b1.birthday.year << endl;\n    cout << ", "\"b1.birthday.month=\"", " << b1.birthday.month << endl;\n    cout << ", "\"b1.birthday.day=\"", " << b1.birthday.day << endl;\n    cout << ", "\"___________________________________________\"", " << endl;\n    ", "//声明baby结构变量temp，并进行赋值运算", "\n    baby temp;\n    temp = b1;\n    cout << ", "\"temp.num=\"", " << temp.num << endl;\n    cout << ", "\"temp.weight=\"", " << temp.num << endl;\n    cout << ", "\"temp.birthday.year=\"", " << temp.birthday.year << endl;\n    cout << ", "\"temp.birthday.month=\"", " << temp.birthday.month << endl;\n    cout << ", "\"temp.birthday.day=\"", " << temp.birthday.day << endl;\n\n\n}\n\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "node a[maxn],b[maxn],c[maxn],d[maxn];\r\n这一行有错，应该是node a[maxn+1],b[maxn+1],c[maxn+1],d[maxn+1];\r\n或者后面的调用maxn的地方改为maxn-1；\r\n创建数组时，数组的大小要比其最大序号大1；", "Konwledge_Point": "赋值运算", "Question": ["02-线性结构2 一元多项式的乘法与加法运算，这道题的代码上的问题", ["题目：", "\n设计函数分别求两个一元多项式的乘积与和。", "\n输入格式:", "\n\n", "输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。", "\n输出格式:", "\n\n", "输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。", "\n输入样例:", "\n\n", "4 3 4 -5 2  6 1  -2 0", "\n3 5 20  -7 4  3 1", "\n\n", "输出样例:", "\n\n", "15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1", "\n5 20 -4 4 -5 2 9 1 -2 0", "\n\n", "问题：", "\n代码敲出来了，样例过了。网上找的测试用例也过了，可是PAT上面过不了，PAT上面的测试用例都是答案错误。。。不知道错那里了，请各位大神帮忙看看。", "\n代码在下面", "\n\n", " #include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn=1e3+10;\nconst int minn=-1005;\nstruct node\n{\n    int cor;\n    int exp;\n    node *next;\n};\nbool flag=false;\nint n,lena,lenb,lenc;\nnode * List1,*List2,*List3;\nnode CreatNode(node a[])                        ///建立结构数组\n{\n    cin>>n;\n    if(n==0)\n    {\n        a[0].cor=0;\n        a[0].exp=0;\n    }\n    for(int i=0; i<n; i++)\n    {\n        cin>>a[i].cor;\n        cin>>a[i].exp;\n    }\n    return *a;\n}\nvoid print(node c[])                          ///打印结构数组\n{\n    if(c[0].cor==0){\n        flag=true;\n    }\n    else cout<<c[0].cor<<\" \"<<c[0].exp;\n    for(int i=1; i<=lenc-1; i++)\n    {\n        if(c[i].cor!=minn)\n        {\n            if(c[i].cor!=0)\n                cout<<\" \"<<c[i].cor<<\" \"<<c[i].exp;\n        }\n    }\n     if(flag==true)\n        cout<<\"0 0\";\n    flag=false;\n}\nbool cmp(const  node & a, const node &b)            ///cmp比较\n{\n    return a.exp>b.exp;\n}\nnode UnionNode(node a[],node b[],node d[])          ///将两个结构数组合并成一个大的结构数组\n{\n    int t=0;\n    for(int i=0; i<lena; i++)\n    {\n        d[t].cor=a[i].cor;\n        d[t].exp=a[i].exp;\n        t++;\n    }\n    for(int i=0; i<lenb; i++)\n    {\n        d[t].cor=b[i].cor;\n        d[t].exp=b[i].exp;\n        t++;\n    }\n    return *d;\n}\nvoid add(node c[])                              ///将数组a,b的值赋值给c并排好序后，在c中进行加法运算\n{\n    int t=lenc;\n    for(int i=0; i<t-1; i++)\n    {\n        if(c[i].exp==c[i+1].exp)\n        {\n            c[i].cor=c[i].cor+c[i+1].cor;\n            c[i+1].cor=minn;\n        }\n    }\n}\n\nnode mulNode(node a[],node b[],node c[])                    ///将两个结构数组相乘的值赋值给第三个结构数组\n{\n    int t=0;\n    for(int i=0; i<lena; i++)\n    {\n        for(int j=0; j<lenb; j++)\n        {\n            c[t].cor=a[i].cor*b[j].cor;\n            c[t].exp=a[i].exp+b[j].exp;\n            t++;\n        }\n    }\n    return *c;\n}\nvoid hh()\n{\n    cout<<endl;\n}\nint main()\n{\n    node a[maxn],b[maxn],c[maxn],d[maxn];\n    a[maxn]=CreatNode(a);                   ///建立第一个结构数组\n    lena=n;\n    b[maxn]=CreatNode(b);                       ///建立第二个结构数组\n    lenb=n;\n\n    lenc=lena*lenb;\n    c[maxn]=mulNode(a,b,c);\n    sort(c,c+lenc,cmp);\n    add(c);\n    print(c);\n\n    hh();\n    //cout<<endl;\n\n    lenc=lena+lenb;\n    d[maxn]=UnionNode(a,b,d);           ///将两个结构数组合并起来为C\n    sort(d,d+lenc,cmp);                     ///对C排序\n    add(d);                     ///C中的元素相加\n    print(d);\n\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;\ndouble currentweight &amp;#61;&lt;span class=\"hljs-number\"&gt;122.5&lt;/span&gt;\ndouble &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;weight&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;\ndouble  weight &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;weight&lt;/span&gt; - currentweight\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["java怎么像pyhton一样赋值给字符串运算呀", ["比如", "double currentweight =122.5", "double new weight = 60", "weight = newweight - current weight", "输出System .out println(weight)", "这样是算不出的，怎么让他能够计算出来"]], "Tag": "程序设计"}
{"Answer": "```\r\n this.pack();\r\n//添加菜单与目录 this.setJMenuBar(mb); mb.add(mEdit); mEdit.setMnemonic(KeyEvent.VK_E); mEdit.add(mCopy); mEdit.add(mPaste); }\r\n只是添加了菜单，没有添加事件\r\nmEdit.add(mPaste); 后面加上监听事件\r\nmCopy.addActionListener(this);\r\nmPaste.addActionListener(this);\r\n```", "Konwledge_Point": "赋值运算", "Question": ["Java 自制的计算器菜单键无法复制", ["代码如下：", "\n\n", "import java.awt.BorderLayout;", "\nimport java.awt.Color;", "\nimport java.awt.GridLayout;", "\nimport java.awt.event.ActionEvent;", "\nimport java.awt.event.ActionListener;  ", "\n\n", "import java.awt.event.KeyEvent;", "\n\n", "import javax.swing.JButton;", "\nimport javax.swing.JFrame;", "\nimport javax.swing.JMenu;", "\nimport javax.swing.JMenuBar;", "\nimport javax.swing.JMenuItem;", "\nimport javax.swing.JPanel;", "\nimport javax.swing.JTextField;  ", "\n\n", "/** ", "\n\n", "\n", "\n", "一个计算器，与Windows附件自带计算器的标准版功能、界面相仿。 但还不支持键盘操作。 ", "/", "\npublic class Calculator extends JFrame implements ActionListener {", "\n/", "* 计算器上的键的显示名字 ", "/", "\nprivate final String[] KEYS = { \"7\", \"8\", \"9\", \"/\", \"4\", \"5\", \"6\", \"", "\"", "\n        , \"1\", \"2\", \"3\",\"-\", \"0\",\"+/-\",\".\",\"+\", \"1/x\", \"%\", \"sqrt\", \"=\" };", "\n/** 计算器上的功能键的显示名字 ", "/", "\nprivate final String[] COMMAND = { \"Backspace\", \"C\" };", "\n/", "* 计算器上键的按钮 ", "/", "\nprivate JButton keys[] = new JButton[KEYS.length];", "\n/", "* 计算器上的功能键的按钮 ", "/", "\nprivate JButton commands[] = new JButton[COMMAND.length];", "\n/", "* 计算结果文本框 */", "\nprivate JTextField resultText = new JTextField(\"0\");", "\n//", "\nprivate JMenuBar mb=new JMenuBar();", "\n//编辑", "\nprivate JMenu mEdit = new JMenu(\"编辑(E)\");", "\n//复制黏贴", "\nprivate JMenuItem mCopy = new JMenuItem(\"复制(C)\");", "\nprivate JMenuItem mPaste = new JMenuItem(\"黏贴(V)\");", "\n//剪切板", "\nprivate StringBuffer copyBoard=new StringBuffer(20);", "\n// 标志用户按的是否是整个表达式的第一个数字,或者是运算符后的第一个数字", "\nprivate boolean firstDigit = true;", "\n// 计算的中间结果。", "\nprivate double resultNum = 0.0;", "\n// 当前运算的运算符", "\nprivate String operator = \"=\";", "\n// 操作是否合法", "\nprivate boolean operateValidFlag = true;  ", "\n\n", "/** ", "\n\n", "\n", "构造函数 \n*/", "\npublic Calculator() {", "\nsuper();", "\n// 初始化计算器", "\ninit();", "\n// 设置计算器的背景颜色", "\nthis.setBackground(Color.LIGHT_GRAY);", "\nthis.setTitle(\"计算器\");", "\n// 在屏幕(500, 300)坐标处显示计算器", "\nthis.setLocation(500, 300);", "\n// 许修改计算器的大小", "\nthis.setResizable(true);", "\n// 使计算器中各组件大小合适", "\nthis.pack();", "\n//添加菜单与目录\nthis.setJMenuBar(mb);\nmb.add(mEdit);\nmEdit.setMnemonic(KeyEvent.VK_E);\nmEdit.add(mCopy);\nmEdit.add(mPaste);\n}", "\n", "\n", "\n", "/** ", "\n\n", "\n", "\n", "初始化计算器 ", "\n*/", "\nprivate void init() {", "\n// 文本框中的内容采用右对齐方式", "\nresultText.setHorizontalAlignment(JTextField.RIGHT);", "\n// 允许修改结果文本框", "\nresultText.setEditable(true);", "\n// 设置文本框背景颜色为白色", "\nresultText.setBackground(Color.white);  ", "\n\n", "// 初始化计算器上键的按钮，将键放在一个画板内", "\nJPanel calckeysPanel = new JPanel();", "\n// 用网格布局器，5行，4列的网格，网格之间的水平方向间隔为3个象素，垂直方向间隔为3个象素", "\ncalckeysPanel.setLayout(new GridLayout(5, 4, 0, 0));", "\nfor (int i = 0; i < KEYS.length; i++) {", "\n    keys[i] = new JButton(KEYS[i]);", "\n    calckeysPanel.add(keys[i]);", "\n    keys[i].setForeground(Color.black);", "\n}", "\n// 初始化功能键，都用红色标示。将功能键放在一个画板内", "\nJPanel commandsPanel = new JPanel();", "\n// 用网格布局器，1行，3列的网格，网格之间的水平方向间隔为3个象素，垂直方向间隔为3个象素", "\ncommandsPanel.setLayout(new GridLayout(1, 3, 0, 0));", "\nfor (int i = 0; i < COMMAND.length; i++) {", "\n    commands[i] = new JButton(COMMAND[i]);", "\n    commandsPanel.add(commands[i]);", "\n}  ", "\n\n", "// 下面进行计算器的整体布局，将calckeys和command画板放在计算器的中部，", "\n// 将文本框放在北部，将calms画板放在计算器的西部。  ", "\n\n", "// 新建一个大的画板，将上面建立的command和calckeys画板放在该画板内", "\nJPanel panel1 = new JPanel();", "\n// 画板采用边界布局管理器，画板里组件之间的水平和垂直方向上间隔都为3象素", "\npanel1.setLayout(new BorderLayout(3, 3));", "\npanel1.add(\"North\", commandsPanel);", "\npanel1.add(\"Center\", calckeysPanel);  ", "\n\n", "// 建立一个画板放文本框", "\nJPanel top = new JPanel();", "\ntop.setLayout(new BorderLayout());", "\ntop.add(\"Center\", resultText);  ", "\n\n", "// 整体布局", "\ngetContentPane().setLayout(new BorderLayout(3, 5));", "\ngetContentPane().add(\"North\", top);", "\ngetContentPane().add(\"Center\", panel1);", "\n// 为各按钮添加事件侦听器", "\n// 都使用同一个事件侦听器，即本对象。本类的声明中有implements ActionListener", "\nfor (int i = 0; i < KEYS.length; i++) {", "\n    keys[i].addActionListener(this);", "\n}", "\nfor (int i = 0; i < COMMAND.length; i++) {", "\n    commands[i].addActionListener(this);", "\n}", "\n}  ", "\n", "\n", "\n", "/** ", "\n\n", "\n", "\n", "处理事件 ", "\n*/", "\npublic void actionPerformed(ActionEvent e) {", "\n// 获取事件源的标签", "\nString label = e.getActionCommand();", "\nif(label.equals(\"复制(C)\"))", "\n{", "\nString temp = resultText.getText().trim();", "\ncopyBoard.replace(0, copyBoard.length(), temp);", "\n\n", "}", "\nelse if(label.equals(\"黏贴(V)\"))", "\n{", "\n    resultText.setText(copyBoard.toString());", "\n}else if (label.equals(COMMAND[0])) {", "\n    // 用户按了\"Backspace\"键", "\n    handleBackspace();", "\n}else if (label.equals(COMMAND[1])) {", "\n    // 用户按了\"C\"键", "\n    handleC();", "\n} else if (\"0123456789.\".indexOf(label) >= 0) {", "\n    // 用户按了数字键或者小数点键", "\n    handleNumber(label);", "\n    // handlezero(zero);", "\n} else {", "\n    // 用户按了运算符键", "\n    handleOperator(label);", "\n}", "\n}  ", "\n", "\n", "\n", "/** ", "\n\n", "\n", "处理Backspace键被按下的事件 \n*/", "\nprivate void handleBackspace() {", "\nString text = resultText.getText();", "\nint i = text.length();", "\nif (i > 0) {", "\n    // 退格，将文本最后一个字符去掉", "\n    text = text.substring(0, i - 1);", "\n    if (text.length() == 0) {", "\n        // 如果文本没有了内容，则初始化计算器的各种值", "\n        resultText.setText(\"0\");", "\n        firstDigit = true;", "\n        operator = \"=\";", "\n    } else {", "\n        // 显示新的文本", "\n        resultText.setText(text);", "\n    }", "\n}", "\n}", "\n", "\n", "\n", "/** ", "\n\n", "\n", "处理数字键被按下的事件 ", "\n", " ", "\n", "@param key \n*/", "\nprivate void handleNumber(String key) {", "\nif (firstDigit) {", "\n    // 输入的第一个数字", "\n    resultText.setText(key);", "\n} else if ((key.equals(\".\")) && (resultText.getText().indexOf(\".\") < 0)) {", "\n    // 输入的是小数点，并且之前没有小数点，则将小数点附在结果文本框的后面", "\n    resultText.setText(resultText.getText() + \".\");", "\n} else if (!key.equals(\".\")) {", "\n    // 如果输入的不是小数点，则将数字附在结果文本框的后面", "\n    resultText.setText(resultText.getText() + key);", "\n}", "\n// 以后输入的肯定不是第一个数字了", "\nfirstDigit = false;", "\n}", "\n", "\n", "\n", "/** ", "\n\n", "\n", "处理C键被按下的事件 \n*/", "\nprivate void handleC() {", "\n// 初始化计算器的各种值", "\nresultText.setText(\"0\");", "\nfirstDigit = true;", "\noperator = \"=\";", "\n}", "\n", "\n", "\n", "/** ", "\n\n", "\n", "处理运算符键被按下的事件 ", "\n", " ", "\n", "@param key \n", "/", "\nprivate void handleOperator(String key) {", "\nif (operator.equals(\"/\")) {", "\n    // 除法运算", "\n    // 如果当前结果文本框中的值等于0", "\n    if (getNumberFromText() == 0.0) {", "\n        // 操作不合法", "\n        operateValidFlag = false;", "\n        resultText.setText(\"除数不能为零\");", "\n    } else {", "\n        resultNum /= getNumberFromText();", "\n    }", "\n} else if (operator.equals(\"1/x\")) {", "\n    // 倒数运算", "\n    if (resultNum == 0.0) {", "\n        // 操作不合法", "\n        operateValidFlag = false;", "\n        resultText.setText(\"零没有倒数\");", "\n    } else {", "\n        resultNum = 1 / resultNum;", "\n    }", "\n} else if (operator.equals(\"+\")) {", "\n    // 加法运算", "\n    resultNum += getNumberFromText();", "\n} else if (operator.equals(\"-\")) {", "\n    // 减法运算", "\n    resultNum -= getNumberFromText();", "\n} else if (operator.equals(\"", "\")) {", "\n    // 乘法运算", "\n    resultNum *= getNumberFromText();", "\n} else if (operator.equals(\"sqrt\")) {", "\n    // 平方根运算", "\n    resultNum = Math.sqrt(resultNum);", "\n} else if (operator.equals(\"%\")) {", "\n    // 百分号运算，除以100", "\n    resultNum = resultNum / 100;", "\n} else if (operator.equals(\"+/-\")) {", "\n    // 正数负数运算", "\n    resultNum = resultNum * (-1);", "\n} else if (operator.equals(\"=\")) {", "\n    // 赋值运算", "\n    resultNum = getNumberFromText();", "\n}", "\nif (operateValidFlag) {", "\n    // 双精度浮点数的运算", "\n    long t1;", "\n    double t2;", "\n    t1 = (long) resultNum;", "\n    t2 = resultNum - t1;", "\n    if (t2 == 0) {", "\n        resultText.setText(String.valueOf(t1));", "\n    } else {", "\n        resultText.setText(String.valueOf(resultNum));", "\n    }", "\n}", "\n// 运算符等于用户按的按钮", "\noperator = key;", "\nfirstDigit = true;", "\noperateValidFlag = true;", "\n}", "\n", "\n", "\n", "/** ", "\n\n", "\n", "从结果文本框中获取数字 ", "\n", " ", "\n", "@return \n*/", "\nprivate double getNumberFromText() {", "\ndouble result = 0;", "\ntry {", "\n    result = Double.valueOf(resultText.getText()).doubleValue();", "\n} catch (NumberFormatException e) {", "\n}", "\nreturn result;", "\n}", "\n", "\n", "\n", "public static void main(String args[]) {", "\n    Calculator calculator1 = new Calculator();", "\n    calculator1.setVisible(true);", "\n    calculator1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);", "\n}", "\n}  ", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你条件满足他不就执行了么&amp;#xff0c;刚开始d&amp;#61;1&amp;#xff0c;满足了d&amp;lt;5的条件,你的输出是在d&amp;#61;d&amp;#43;1变量改变之前的&amp;#xff0c;代码的执行逻辑就是这样&amp;#xff0c;不知道你是哪没想明白&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["感谢！一个循环里的自增运算，也执行初始的变量赋值？", ["import random", "\nprint(\"你有5次猜数的机会\")", "\na=random.randint(1, 10)", "\nb=input(\"请输入：\")            #1次", "\nc=int(b)", "\nd=1", "\nwhile b!=a and d<5:           #4次", "\n      if c>a:", "\n         input(\"大了，重新输入：\")", "\n      else:", "\n         b=int(input (\"小了，重新输入：\"))", "\n      d=d+1", "\nif (d<=3) and (b==a):", "\n    print(\"对了\")", "\n    ", "\n#d=1,1<5,所以继续运行", "\n#d=1+1,2<5,所以继续运行", "\n#d=2+1,3<5,所以继续运行", "\n#d=3+1,4<5,所以继续运行", "\n\n", "#所以一个循环里的自增运算，也执行初始的变量赋值？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;maxstr 最后少了个} &lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c++中，求这两个串最大公共子串（求解为何报错）", ["\n", "//cpp\n#include<iostream>\nusing namespace std;\n#include\"acb.h\"\nint main()\n{\n\tsqstr s1,t1,str;\n\tinput(s1,\"adssdaxczefrcbxcvxqwgcxx\");\n\tinput(t1,\"sadxccxassdyii\");\n\tcout<<\"s1:\";     output(s1);\n\tcout<<\"t1:\";     output(t1);\n\tstr=maxstr(s1,t1);\n\tcout<<\"str:\";\n\toutput(str);\n\tcout<<str.length<<endl;\n\treturn 0;\n}\n\n\n//acb.h\n#define MaxSize 100     //串中的最多字符个数\ntypedef struct\n{\n\tchar data[MaxSize];\n\tint length;\n}sqstr;\n \n\n\nvoid input(sqstr &s, char str[])  //串的赋值运算\n{\n\tint i=0;\n\twhile (str[i]!='\\0')\n\t{\n\t\ts.data[i]=str[i];\n\t\ti++;\n\t}\n\ts.length=i;\n}\n\n\n\nsqstr maxstr(sqstr s,sqstr t)\n{\n\tsqstr str;\n\tint midx=0,mlen=0,tlen,i=0,j,k;\n\twhile (i<s.length)        //用i扫描串s\n\t{\n\t\tj=0;                  //用j扫描串t\n\t\twhile (j<t.length)\n\t\t{\n\t\t\tif(s.data[i]==t.data[j])\n\t\t\t{\n\t\t\t\ttlen=1;\n\t\t\t\tfor (k=1;i+k<s.length && j+k<t.length && s.data[i+k]==t.data[j+k];k++)\n\t\t\t\t{\n\t\t\t\t\ttlen++;\n\t\t\t\t}\n\t\t\t\tif (tlen>mlen)          //将较大长度付给midx和mlen\n\t\t\t\t{\n\t\t\t\t\tmidx=i;          //记录当前相同字符串的下标\n\t\t\t\t\tmlen=tlen;       //记录当前相同字符串的长度\n\t\t\t\t}\n\t\t\tj=j+1;\n\t\t\t}\n\t\t\telse j++;\n\t\t}\n\t\ti++;                                // 继续扫描s中第i字符之后的字符\n\t}\n\tfor (i=0;i<mlen;i++)                    //将最大公共子串复制到str中\n\t{\n\t\tstr.data[i]=s.data[midx+i];\n\t}\n\tstr.length=mlen;\n\treturn str;                               //返回最大公共子串\n\n\n\nvoid output(sqstr s)  //串的输出运算\n{\n\tint i;\n\tfor(i=0;i<s.length;i++)\n\t\tcout<<s.data[i];\n\tcout<<endl;\n}\n\n\n\n\n\n//--------------------Configuration: 1125 - Win32 Debug--------------------\nCompiling...\n1125.cpp\nC:\\Users\\51207\\Desktop\\vC\\11\\1125.cpp(5) : error C2601: 'main' : local function definitions are illegal\nC:\\Users\\51207\\Desktop\\vC\\11\\1125.cpp(17) : fatal error C1004: unexpected end of file found\n执行 cl.exe 时出错.\n\n1125.obj - 1 error(s), 0 warning(s)\n\n"]], "Tag": "程序设计"}
{"Answer": "if (_____________)\r\ncout&lt; else\r\ncout }\r\n}\r\n这里没有贴对，请你检查你原始的问题。", "Konwledge_Point": "赋值运算", "Question": ["c++程序填空求大佬帮忙", ["整数栈2(用动态数组实现)", "\n\n", "描述", "\n设计一个(整数)栈类Stack(用动态数组实现)，成员函数(方法)主要有：", "\n构造函数，析构函数，栈的运算(判栈满、判栈空、返回栈顶元素、元素压入栈顶、返回并删除栈顶元素)，", "\n可以设计其它你自己认为必要的方法并进行充分的测试。", "\n#include", "\nusing namespace std;", "\n//自定义整数栈类(用动态数组实现)", "\n\n", "......", "\n\n", "//输出栈的所有元素", "\nvoid showStack(Stack &s) {", "\n int x;", "\n for (int i=0;i<=s.getMaxTop();i++) {", "\n  //获得栈(顶)元素并存入x中", "\n  if (_____________)", "\n   cout<<x<<' ';", "\n  else", "\n   cout<<\"Stack is empty.\\n\";", "\n\n", "//删除栈(顶)元素并存入x中", "\n  if (_____________)", "\n   cout<\n  else", "\n   cout\n }", "\n}", "\nint main() {", "\n int i,n,x;", "\n cin>>n;", "\n //定义一个栈最多可以存放n个元素", "\n ______________________________;", "\n\n", "for (i=0;i<=s.getMaxTop();i++) {", "\n  cin>>x;", "\n  //元素x压入栈(顶)", "\n  if (!________________) {", "\n   cout<<\"Stack is full.\\n\";", "\n  }", "\n }", "\n cout<<endl;", "\n\n", "//用默认长度构造2个整数栈s1和s2", "\n _______________________________;", "\n s2=s1=s;   //使用赋值运算", "\n //用栈s2构造s3(会调用拷贝构造函数)", "\n Stack s3(s2);", "\n\n", "showStack(s); cout<<endl;", "\n\n", "showStack(s1); cout<<endl;", "\n\n", "showStack(s3); cout<<endl;", "\n //s2.showStatus();", "\n return 0;", "\n}", "\n输入", "\n第1行：正整数n（栈的大小） 第2～m行：n个将入栈的整数和1个额外用于测试的整数（空格分开）", "\n输出", "\n2+3*(n+3)行，其中： 第1行：Stack is full. 第2行：空行 接下去的n：每行2个相同的用空格分开的整数（返回栈顶元素、返回并删除栈顶元素） 输出2行的Stack is empty. 第n+4行：空行 接下去的2个n+3行都和前面的n+3行一样。", "\n输入样例 1 ", "\n15", "\n\n", "12 80 78 62 63 89  5  9 ", "\n\n", "88 23 91  6 33 54 30 9999", "\n\n", "输出样例 1", "\nStack is full.", "\n\n", "30 30", "\n\n", "54 54", "\n\n", "33 33", "\n\n", "6 6", "\n\n", "91 91", "\n\n", "23 23", "\n\n", "88 88", "\n\n", "9 9", "\n\n", "5 5", "\n\n", "89 89", "\n\n", "63 63", "\n\n", "62 62", "\n\n", "78 78", "\n\n", "80 80", "\n\n", "12 12", "\n\n", "Stack is empty.", "\n\n", "Stack is empty.", "\n\n", "30 30", "\n\n", "54 54", "\n\n", "33 33", "\n\n", "6 6", "\n\n", "91 91", "\n\n", "23 23", "\n\n", "88 88", "\n\n", "9 9", "\n\n", "5 5", "\n\n", "89 89", "\n\n", "63 63", "\n\n", "62 62", "\n\n", "78 78", "\n\n", "80 80", "\n\n", "12 12", "\n\n", "Stack is empty.", "\n\n", "Stack is empty.", "\n\n", "30 30", "\n\n", "54 54", "\n\n", "33 33", "\n\n", "6 6", "\n\n", "91 91", "\n\n", "23 23", "\n\n", "88 88", "\n\n", "9 9", "\n\n", "5 5", "\n\n", "89 89", "\n\n", "63 63", "\n\n", "62 62", "\n\n", "78 78", "\n\n", "80 80", "\n\n", "12 12", "\n\n", "Stack is empty.", "\n\n", "Stack is empty."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;定义函数时参数是形参&amp;#xff0c;调用函数时参数是实参&amp;#xff1b;形参不占内存的&amp;#xff0c;只是告诉系统参数必须是指定的类型。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["定义函数中形参的实质是什么", ["如果多次调用函数 那么我的形参是固定内存只不过在不断赋值还是重新创建形参参加运算？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a&amp;#61;(s&amp;#61;c1&amp;#61;&amp;#61;c2) || (b&amp;#61;c3&amp;gt;c4); t&amp;#61;c3&amp;gt;c4;等价于&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;1&amp;#xff09;s&amp;#61;c1&amp;#61;&amp;#61;c2; //先计算c1&amp;#61;&amp;#61;c2&amp;#xff0c;c1和c2都等于2&amp;#xff0c;所以c1&amp;#61;&amp;#61;c2成立&amp;#xff0c;结果为真&amp;#xff0c;所以s&amp;#61;1&lt;br /&gt;&amp;#xff08;2&amp;#xff09;a&amp;#61;s&amp;#61;1 &amp;#xff0c;所以 ||的左侧是1&amp;#xff0c;也就是真&lt;br /&gt;&amp;#xff08;3&amp;#xff09;|| 运算时&amp;#xff0c;如果左侧为真&amp;#xff0c;右侧就不再计算了&amp;#xff0c;所以b&amp;#61;c3&amp;gt;c4这里不再执行&lt;br /&gt;&lt;strong&gt;(如果上面初始化了b&amp;#61;2&amp;#xff0c;那么b的值仍然是2&amp;#xff0c;如果b没有初始化&amp;#xff0c;b的值就是一个不确定的值&amp;#xff0c;可能是0&amp;#xff0c;也可能是别的值&amp;#xff0c;你这里b未初始化的时候&amp;#xff0c;b的值是0)&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;4&amp;#xff09;t&amp;#61;c3&amp;gt;c4; //先判断c3&amp;gt;c4,c3和c4都等于2&amp;#xff0c;所以不成立&amp;#xff0c;结果为假&amp;#xff0c;所以t&amp;#61;0&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["问：为什么b没有赋值的时候运算以后等于0；而初始化后等于2？", ["\n", "\n"]], "Tag": "程序设计"}
{"Answer": "你的输出是错的\r\n\r\n```\r\n#include &lt;iostream&gt;\r\n#include &lt;cstring&gt;\r\nusing namespace std;\r\n\r\nclass Password {\r\npublic:\r\n\tPassword()\r\n\t{\r\n\t\tchgPWD(\"Abcd1234\");\r\n\t}\r\n\tPassword(char * p)\r\n\t{\r\n\t\tchgPWD(p);\t\r\n\t}\r\n\tPassword(Password &amp;p)\r\n\t{\r\n\t\tchgPWD(p.pwd);\t\r\n\t}\r\n\tvoid chgPWD(char * p)\r\n\t{\r\n\t\tint chk = 0;\r\n\t\tif (strlen(p) &gt;= 8 &amp;&amp; strlen(p) &lt;= 32)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i &lt; strlen(p); i++)\r\n\t\t\t{\r\n\t\t\t\tif (p[i] &gt;= 'A' &amp;&amp; p[i] &lt;= 'Z') chk |= 1;\r\n\t\t\t\tif (p[i] &gt;= 'a' &amp;&amp; p[i] &lt;= 'z') chk |= 2;\r\n\t\t\t\tif (p[i] &gt;= '0' &amp;&amp; p[i] &lt;= '9') chk |= 4;\r\n\t\t\t}\r\n\t\t\tif (chk == 7)\r\n\t\t\t{\r\n\t\t\t\tchar * p1 = new char[100];\r\n\t\t\t\tstrcpy(p1, p);\r\n\t\t\t\tpwd = p1;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tchgPWD(\"Abcd1234\");\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tchgPWD(\"Abcd1234\");\r\n\t\t}\r\n\t}\r\n\tvoid chgPWD()\r\n\t{\r\n\t\tchgPWD(\"Abcd1234\");\r\n\t}\r\n\tPassword&amp; operator=(Password&amp; p)\r\n\t{\r\n\t\tchgPWD(p.pwd);\r\n\t\treturn *this;\r\n\t}\r\n\tbool operator==(Password&amp; p)\r\n\t{\r\n\t\treturn strcmp(pwd, p.pwd) == 0;\r\n\t}\r\n\tbool operator!=(Password&amp; p)\r\n\t{\r\n\t\treturn strcmp(pwd, p.pwd) != 0;\r\n\t}\r\n\tfriend ostream &amp; operator&lt;&lt;(ostream &amp;out,Password p);\r\nprivate:\r\n\tchar *pwd; //密码(该行不允许修改)\r\n};\r\n\r\nostream &amp; operator&lt;&lt;(ostream &amp;out,Password p)\r\n{\r\n\tout &lt;&lt; \"(\" &lt;&lt; p.pwd &lt;&lt; \")\";\r\n\treturn out;\r\n}\r\n\r\nint main() {\r\nPassword s1; //s1被设置为默认密码：Abcd1234\r\ncout&lt;&lt;s1&lt;&lt;endl&lt;&lt;endl;\r\n//密码长度必须在8～32之间，否则密码被置为默认密码：Abcd1234\r\nPassword s2(\"123456\");\r\nPassword s3(\"ABCDEFGabcdefg01234567890123456789\");\r\ncout&lt;&lt;s2&lt;&lt;','&lt;&lt;s3&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//密码必须包含大写字母，小写字母和数字三者。\r\n//否则密码被置为默认密码：Abcd1234\r\nPassword s4(\"ABCD1234\");\r\nPassword s5(\"abcde12345\");\r\ncout&lt;&lt;s4&lt;&lt;','&lt;&lt;s5&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//密码长度在8～32之间，包含大写字母，小写字母和数字三者。\r\n//正确构造用户所需要的密码。\r\nPassword s6(\"Wch54321\");\r\nPassword s7(\"ABCDEFG0123456789abcdefg01234567\");\r\ncout&lt;&lt;s6&lt;&lt;','&lt;&lt;s7&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//拷贝构造\r\nPassword s8(s1);\r\nPassword s9=s6;\r\ncout&lt;&lt;s8&lt;&lt;','&lt;&lt;s9&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//赋值运算\r\ns2=s8=s6=s6;\r\ncout&lt;&lt;s2&lt;&lt;','&lt;&lt;s8&lt;&lt;','&lt;&lt;s6&lt;&lt;endl;\r\ns3=s4=s5=s6;\r\ncout&lt;&lt;s3&lt;&lt;','&lt;&lt;s4&lt;&lt;','&lt;&lt;s5&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//将密码修改为默认密码：Abcd1234\r\ns2.chgPWD(); //s2被设置为默认密码：Abcd1234\r\ns3.chgPWD(\"Abcd1234\");\r\ncout&lt;&lt;s2&lt;&lt;','&lt;&lt;s3&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//密码长度必须在8～32之间，否则保持密码不变。\r\ns4.chgPWD(\"123456\");\r\ns5.chgPWD(\"ABCDEFGabcdefg01234567890123456789\");\r\ncout&lt;&lt;s4&lt;&lt;','&lt;&lt;s5&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//密码长度在8～32之间，包含大写字母，小写字母和数字三者。\r\n//正确修改为用户所需要修改的密码。\r\ns4.chgPWD(\"Wch88888\");\r\ns5.chgPWD(\"abcde0123456789ABCDEFG0123456789\");\r\ncout&lt;&lt;s4&lt;&lt;','&lt;&lt;s5&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//密码必须包含大写字母，小写字母和数字三者。\r\n//否则保持密码不变。\r\ns4.chgPWD(\"ABCD1234\");\r\ns5.chgPWD(\"abcde12345\");\r\ncout&lt;&lt;s4&lt;&lt;','&lt;&lt;s5&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//输出所有已经构造的密码\r\ncout&lt;&lt;\"s1:\"&lt;&lt;s1&lt;&lt;',';    cout&lt;&lt;\"s2:\"&lt;&lt;s2&lt;&lt;',';    cout&lt;&lt;\"s3:\"&lt;&lt;s3&lt;&lt;endl;\r\ncout&lt;&lt;\"s4:\"&lt;&lt;s4&lt;&lt;',';    cout&lt;&lt;\"s5:\"&lt;&lt;s5&lt;&lt;',';    cout&lt;&lt;\"s6:\"&lt;&lt;s6&lt;&lt;endl;\r\ncout&lt;&lt;\"s7:\"&lt;&lt;s7&lt;&lt;',';    cout&lt;&lt;\"s8:\"&lt;&lt;s8&lt;&lt;',';    cout&lt;&lt;\"s9:\"&lt;&lt;s9&lt;&lt;endl&lt;&lt;endl;\r\n\r\n//密码比较==和!=\r\ncout&lt;&lt;\"s1==s2:\"&lt;&lt;(s1==s2?\"TRUE\":\"FALSE\")&lt;&lt;',';\r\ncout&lt;&lt;\"s1==s4:\"&lt;&lt;(s1==s4?\"TRUE\":\"FALSE\")&lt;&lt;endl;\r\ncout&lt;&lt;\"s1!=s2:\"&lt;&lt;(s1!=s2?\"TRUE\":\"FALSE\")&lt;&lt;',';\r\ncout&lt;&lt;\"s1!=s4:\"&lt;&lt;(s1!=s4?\"TRUE\":\"FALSE\")&lt;&lt;endl;\r\n\r\nreturn 0;\r\n}\r\n\r\n```\r\n(Abcd1234)\r\n\r\n(Abcd1234),(Abcd1234)\r\n\r\n(Abcd1234),(Abcd1234)\r\n\r\n(Wch54321),(ABCDEFG0123456789abcdefg01234567)\r\n\r\n(Abcd1234),(Wch54321)\r\n\r\n(Wch54321),(Wch54321),(Wch54321)\r\n(Wch54321),(Wch54321),(Wch54321)\r\n\r\n(Abcd1234),(Abcd1234)\r\n\r\n(Abcd1234),(Abcd1234)\r\n\r\n(Wch88888),(abcde0123456789ABCDEFG0123456789)\r\n\r\n(Abcd1234),(Abcd1234)\r\n\r\ns1:(Abcd1234),s2:(Abcd1234),s3:(Abcd1234)\r\ns4:(Abcd1234),s5:(Abcd1234),s6:(Wch54321)\r\ns7:(ABCDEFG0123456789abcdefg01234567),s8:(Wch54321),s9:(Wch54321)\r\n\r\ns1==s2:TRUE,s1==s4:TRUE\r\ns1!=s2:FALSE,s1!=s4:FALSE\r\nPress any key to continue . . .", "Konwledge_Point": "赋值运算", "Question": ["c++假想且不实用的密码类(程序填空)", ["//创建一个假想并且不实用的密码类Password。", "\n#include ", "\n\n", "......", "\n\n", "class Password {", "\npublic:", "\n    ________________________________________________________________________________", "\n    ________________________________________________________________________________", "\n    ________________________________________________________________________________", "\n    ......", "\n    ________________________________________________________________________________", "\n    ________________________________________________________________________________", "\n    ________________________________________________________________________________", "\nprivate:", "\n    char *pwd;  //密码(该行不允许修改)", "\n};", "\n\n", "......", "\n\n", "int main() {", "\n    Password s1; //s1被设置为默认密码：Abcd1234", "\n    cout<<s1<<endl<<endl;", "\n\n", "//密码长度必须在8～32之间，否则密码被置为默认密码：Abcd1234\nPassword s2(\"123456\");\nPassword s3(\"ABCDEFGabcdefg01234567890123456789\");\ncout<<s2<<','<<s3<<endl<<endl;\n\n//密码必须包含大写字母，小写字母和数字三者。\n//否则密码被置为默认密码：Abcd1234\nPassword s4(\"ABCD1234\");\nPassword s5(\"abcde12345\");\ncout<<s4<<','<<s5<<endl<<endl;\n\n//密码长度在8～32之间，包含大写字母，小写字母和数字三者。\n//正确构造用户所需要的密码。\nPassword s6(\"Wch54321\");\nPassword s7(\"ABCDEFG0123456789abcdefg01234567\");\ncout<<s6<<','<<s7<<endl<<endl;\n\n//拷贝构造\nPassword s8(s1);\nPassword s9=s6;\ncout<<s8<<','<<s9<<endl<<endl;\n\n//赋值运算\ns2=s8=s6=s6;\ncout<<s2<<','<<s8<<','<<s6<<endl;\ns3=s4=s5=s6;\ncout<<s3<<','<<s4<<','<<s5<<endl<<endl;\n\n//将密码修改为默认密码：Abcd1234\ns2.chgPWD(); //s2被设置为默认密码：Abcd1234\ns3.chgPWD(\"Abcd1234\");\ncout<<s2<<','<<s3<<endl<<endl;\n\n//密码长度必须在8～32之间，否则保持密码不变。\ns4.chgPWD(\"123456\");\ns5.chgPWD(\"ABCDEFGabcdefg01234567890123456789\");\ncout<<s4<<','<<s5<<endl<<endl;\n\n//密码长度在8～32之间，包含大写字母，小写字母和数字三者。\n//正确修改为用户所需要修改的密码。\ns4.chgPWD(\"Wch88888\");\ns5.chgPWD(\"abcde0123456789ABCDEFG0123456789\");\ncout<<s4<<','<<s5<<endl<<endl;\n\n//密码必须包含大写字母，小写字母和数字三者。\n//否则保持密码不变。\ns4.chgPWD(\"ABCD1234\");\ns5.chgPWD(\"abcde12345\");\ncout<<s4<<','<<s5<<endl<<endl;\n\n//输出所有已经构造的密码\ncout<<\"s1:\"<<s1<<',';    cout<<\"s2:\"<<s2<<',';    cout<<\"s3:\"<<s3<<endl;\ncout<<\"s4:\"<<s4<<',';    cout<<\"s5:\"<<s5<<',';    cout<<\"s6:\"<<s6<<endl;\ncout<<\"s7:\"<<s7<<',';    cout<<\"s8:\"<<s8<<',';    cout<<\"s9:\"<<s9<<endl<<endl;\n\n//密码比较==和!=\ncout<<\"s1==s2:\"<<(s1==s2?\"TRUE\":\"FALSE\")<<',';\ncout<<\"s1==s4:\"<<(s1==s4?\"TRUE\":\"FALSE\")<<endl;\ncout<<\"s1!=s2:\"<<(s1!=s2?\"TRUE\":\"FALSE\")<<',';\ncout<<\"s1!=s4:\"<<(s1!=s4?\"TRUE\":\"FALSE\")<<endl;\n\nreturn 0;\n", "\n\n", "}", "\n\n", "输入", "\n\n", "无", "\n\n", "输出", "\n\n", "见“样例输出”", "\n\n", "输入样例 1 ", "\n\n", "无", "\n输出样例 1", "\n\n", "(Abcd1234)", "\n\n", "(Abcd1234),(Abcd1234)", "\n\n", "(Abcd1234),(Abcd1234)", "\n\n", "(Wch54321),(ABCDEFG0123456789abcdefg01234567)", "\n\n", "(Abcd1234),(Wch54321)", "\n\n", "(Wch54321),(Wch54321),(Wch54321)", "\n(Wch54321),(Wch54321),(Wch54321)", "\n\n", "(Abcd1234),(Abcd1234)", "\n\n", "(Wch54321),(Wch54321)", "\n\n", "(Wch88888),(abcde0123456789ABCDEFG0123456789)", "\n\n", "(Wch88888),(abcde0123456789ABCDEFG0123456789)", "\n\n", "s1:(Abcd1234),s2:(Abcd1234),s3:(Abcd1234)", "\ns4:(Wch88888),s5:(abcde0123456789ABCDEFG0123456789),s6:(Wch54321)", "\ns7:(ABCDEFG0123456789abcdefg01234567),s8:(Wch54321),s9:(Wch54321)", "\n\n", "s1==s2:TRUE,s1==s4:FALSE", "\ns1!=s2:FALSE,s1!=s4:TRUE"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这个问题的回答你可以参考下: &lt;a href=\"https://ask.csdn.net/questions/7733560\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7733560&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "赋值运算", "Question": ["在进行自增运算时，赋值的变量不同，为什么输出的结果也不同", ["问题遇到的现象和发生背景", "\n", "疑问我写在代码块中了", "\n", "遇到的现象和发生背景，请写出第一个错误信息", "\n", "用代码块功能插入代码，请勿粘贴截图。 不用代码块回答率下降 50%", "\n", "#", "include", " ", "<stdio.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a;\n    ", "int", " b = ", "1", ";\n    a = b++; ", "// 先返回一个值赋给a，b再自增，所以a = 1，b = 2;", "\n    ", "printf", "(", "\"%d\\n\"", ", a);\n    ", "printf", "(", "\"%d\\n\"", ", b);\n    ", "return", " ", "0", ";\n}\n\n", "#", "include", " ", "<stdio.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " b = ", "1", ";\n    b = b++;           ", "// 这里可以拆成两个部分，先返回一个值，b再自增，结果应该为2", "\n    ", "printf", "(", "\"%d\\n\"", ", b); ", "// 但是计算机给出的结果为1", "\n    ", "return", " ", "0", ";\n}\n", "\n", "运行结果及详细报错内容", "\n", "第一个程序的输出结果\n1\n2\n\n\n第二个程序的输出结果\n1\n", "\n", "我的解答思路和尝试过的方法，不写自己思路的，回答率下降 60%", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;print(&amp;#34;%d%%%d&amp;#61;%d&amp;#34;,a,b,e);&lt;br /&gt;&lt;br /&gt;&lt;font color=\"red\"&gt;&lt;strong&gt;觉得有用的话采纳一下哈&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["整型变量，赋值，乘除余四则运算，第15行有点弄不了", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a--这个表达式的意思是&amp;#xff0c;以a的值来运算&amp;#xff0c;运算结束后&amp;#xff0c;a的值减1&amp;#xff0c;所以a--这个表达式的值&amp;#xff1d;a的值&amp;#61;6&amp;#xff0c;而题中要打印的是a--这个表达式的值&amp;#xff0c;也就是6&amp;#xff0c;如果打印a的值&amp;#xff0c;则答案是5&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["关于#赋值#的问题，如何解决？", ["这个运行结果为六，是不是因为会先赋值，所以输出为6，后运算a最后为5？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你应该退回到float型那一章&amp;#xff0c;看看float型的二进制到底是怎么回事&amp;#xff0c;就能理解它为什么只有6-7位有效数字&lt;br /&gt;因为计算机里存的是2进制&amp;#xff0c;而我们平时说的有效数字是10进制&amp;#xff0c;所以并不能精确的说它有6位或者7位有效数字&amp;#xff0c;而是在6-7之间&lt;br /&gt;c语言属于弱类型的编程语言&amp;#xff0c;各种值类型之间可以隐式互相转换&lt;br /&gt;所以你可以将一个有21位有效数字的数赋值给float型&amp;#xff0c;但是它会自动舍去多余的数据&amp;#xff0c;只能保存4个字节的数据&lt;br /&gt;运算过程中&amp;#xff0c;各种类型之间会先统一转换成一个较大的类型&amp;#xff0c;再进行计算&lt;br /&gt;比如int型加上一个double型&amp;#xff0c;那么会先统一都转成double型再做加法&lt;br /&gt;如果是float型&amp;#43;double型&amp;#xff0c;也会转换成double型&amp;#xff0c;此时计算过程中有可能产生更多的有效数据&amp;#xff0c;但是一旦再赋值给float型的变量&amp;#xff0c;多余的数据又会被舍去&lt;br /&gt;这就类似一个ushort里只能放0-65535的数据&amp;#xff0c;再多就溢出了&amp;#xff0c;又从0开始了&amp;#xff0c;是一样的&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["浮点数赋值和储存的有效数字限制？", ["刚开始 自学中  这里的意思是？", "c语言浮点数赋值是可以超过6/7位有效数字", "但是在进行运算 浮点数需要储存时 就不能超过6/7位有效数字？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/351767652966140.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c++赋值操作符该如何理解?", ["“a<<=”“a>>=”“a&=b”“a&=b”“a^=b”“a|=b”这几个赋值操作符都代表着什么运算方式啊，求解释"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#43;&amp;#43;a先执行&amp;#xff0c;无论a执行后会是几&amp;#xff0c;接着运行a-&amp;#61;a&amp;#xff0c;相当于a&amp;#61; a-a&amp;#xff0c;那么a肯定是0&amp;#xff0c;所以c就是0&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c语言中关于++运算符计算", ["这里a-=++a不应该等于a=a-(++a)吗？++a等于1，a=0,那结果不应该是等于-1吗? 为什么会等于1-1=0呢?难道++a先加1赋值给了a，表达式左边的a第二个a同时也被赋值成了a?吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你index错了&amp;#xff0c;应该是&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;(&lt;span class=\"hljs-keyword\"&gt;c&lt;/span&gt;.a)[i*&lt;span class=\"hljs-keyword\"&gt;c&lt;/span&gt;.n &amp;#43; j]\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["C++用类实现复数矩阵操作遇到的问题？", ["码：", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Complex", "\n{\n", "public", ":\n    ", "Complex", "(", "double", " x = ", "0", ", ", "double", " y = ", "0", ") :", "real", "(x), ", "imag", "(y) {};\n    ", "friend", " istream& ", "operator", ">>(istream& , Complex& c);\n    ", "friend", " ostream& ", "operator", "<<(ostream& , ", "const", " Complex& c);\n    ", "friend", " Complex ", "operator", " + (", "const", " Complex& c1, ", "const", " Complex& c2);\n", "private", ":\n    ", "double", " real;\n    ", "double", " imag;\n};\n", "class", " ", "Complex_matrix", "\n{\n", "public", ":\n    ", "Complex_matrix", "(", "int", " x=", "0", ",", "int", " y=", "0", ");\n    ", "Complex_matrix", "(Complex_matrix& p);\n    ", "friend", " istream& ", "operator", ">>(istream&, Complex_matrix&);\n    ", "friend", " ostream& ", "operator", "<<(ostream&, ", "const", " Complex_matrix&);\n    ", "friend", " Complex_matrix ", "operator", " + (", "const", " Complex_matrix& c1, ", "const", " Complex_matrix& c2);\n", "private", ":\n    ", "int", " m;\n    ", "int", " n;\n    Complex*a;\n};\nistream& ", "operator", ">>(istream& input1, Complex& c)\n{\n    input1>> c.real >> c.imag;\n    ", "return", " input1;\n}\nostream& ", "operator", "<<(ostream& output1, ", "const", " Complex& c)\n{\n    output1 << ", "\"(\"", " << c.real << ", "\"+\"", " << c.imag << ", "\"i)\"", " ;\n    ", "return", " output1;\n}\nComplex ", "operator", " + (", "const", " Complex& c1, ", "const", " Complex& c2)\n{\n    ", "return", " ", "Complex", "(c1.real + c2.real, c1.imag + c2.imag);\n}\n\n\n", "/*................................这是分割线......................................*/", "\n\nComplex_matrix::", "Complex_matrix", "(", "int", " x, ", "int", " y)\n{\n    ", "if", " (x > ", "0", " && y > ", "0", ")\n    {\n        a = ", "new", " Complex[x * y];\n        m = x;\n        n = y;\n    }\n}\nComplex_matrix::", "Complex_matrix", "(Complex_matrix& p)\n{\n    a = ", "new", " Complex[p.m * p.n];\n    m = p.m;\n    n = p.n;\n    ", "for", " (", "int", " i = ", "0", ";i < m;i++)\n    {\n        ", "for", " (", "int", " j = ", "0", ";j < n;j++)\n            (a)[(i - ", "1", ") * n + j - ", "1", "] = (p.a)[(i - ", "1", ") * n + j - ", "1", "] + (p.a)[(i - ", "1", ") * n + j - ", "1", "];\n    }\n\n}\nistream& ", "operator", ">>(istream& input2, Complex_matrix& c)\n{\n    ", "for", " (", "int", " i = ", "0", ";i < c.m;i++)\n    {\n        ", "for", " (", "int", " j = ", "0", ";j < c.n;j++)\n        {\n            cout << ", "\"请输入第（\"", " << i + ", "1", " << ", "\",\"", " << j + ", "1", " << ", "\"）位的元素\"", " << endl;\n            cin >> (c.a)[(i - ", "1", ") * c.n + j - ", "1", "];\n        }\n    }\n    ", "return", " input2;\n\n}\nostream& ", "operator", "<<(ostream& output2, ", "const", " Complex_matrix& c)\n{\n    ", "for", " (", "int", " i = ", "0", ";i < c.m;i++)\n    {\n        ", "for", " (", "int", " j = ", "0", ";j < c.n;j++)\n            cout << (c.a)[(i - ", "1", ") * c.n + j - ", "1", "];\n        cout << endl;\n    }\n    ", "return", " output2;\n}\nComplex_matrix ", "operator", " + (", "const", " Complex_matrix& c1, ", "const", " Complex_matrix& c2)\n{\n    cout << c1;\n    cout << c2;\n        ", "Complex_matrix ", "result", "(", "3", ", ", "2", ")", ";\n        ", "return", " result;\n\n}\n", "int", " ", "main", "()", "\n", "{\n\n        ", "Complex_matrix ", "m1", "(", "2", ", ", "2", ")", ";\n        cin >> m1;\n        cout << m1;\n        ", "Complex_matrix ", "m2", "(", "2", ", ", "2", ")", ";\n        cin >> m2;\n        cout << m2;\n}\n", "\n", "对m1和m2进行赋值操作的时候为什么会出现这样的情况，对第一个对象能够正常赋值，对第二个对象的右上角元素不能进行正常赋值，如图：", "\n"]], "Tag": "程序设计"}
{"Answer": "我想详细把这个问题回答下。\r\n\r\n要搞清楚这个问题，必须搞清楚什么叫等价。\r\n\r\n看这样两个程序（伪代码）：\r\n    var i = input.read\r\n    output.write(i)\r\n程序1\r\n    var x = input.read\r\n    output.write(x)\r\n程序2\r\n\r\n这两个程序是等价的，换一句话说，将程序视作一个黑盒（并且计算机是理想的，速度无限快，存储无限大），你不能从输入和输出区分出计算机执行的是哪个程序。\r\n\r\n我们继续看\r\n    var i = input.read\r\n    j = 1 + 1\r\n    output.write(i)\r\n程序3\r\n\r\n这个程序和上面的程序等价么？仍然是等价的。因为虽然内部多了一个操作，j = 1 + 1，但是输出的结果不变，给定的输入有给定的输出，前面我说了，这就是等价。\r\n\r\n再看一个程序\r\n    var i = input.read\r\n    i = 1 + 1\r\n    output.write(i)\r\n程序4\r\n\r\n这个程序和之前的程序等价么？显然不等价了，因为多出来的一行改变了程序的结果。如果把程序1和程序4放在计算机中运行，如果输入n，输出n，就是程序1，如果总是输出2，就是程序4\r\n\r\n我们知道，程序4表示如果不管输入什么，输出总是2，那么根据这个，我们不管程序四是怎么写的，都可以写出它的等价形式\r\n    output.write(2)\r\n程序5\r\n\r\n这个程序和程序4是等价的。\r\n\r\n我之所以啰里啰唆地说了半天，就是让你明白，什么叫等价，这是理解这个问题的关键。", "Konwledge_Point": "赋值运算", "Question": ["java中运算中的变量是不是变量本身？", ["int i=0;", "\ni= i++;", "\ni最后得0，那运算的i++去哪了。？？", "\n很多回答都是，先赋值，后++，这个我清楚，我就是想问=号左边的i和i++是同一个地址值还是只是和传进来的变量相等的值。", "\n比如", "\ni=(i++)+(++i)", "\n\n", "i++中的i和被赋值的i应该不是同一个地址值的i，只是和传进来的变量相等的值？这样理解是对的吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;仅供参考&amp;#xff0c;望采纳~&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n[]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;66&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;66&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;-7&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; count[&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(j!&amp;#61;i)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;((n[i]^n[j])&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                {\n                    count[i]&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                }\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(count[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,n[i]);\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/468593741866184.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["位运算的，请问怎么写", ["小明接到字节跳动的笔试通知，其中有一道算法题目是：有11个整数，其中有5个整数各出现2次，1个整数出现了1次，请找出这个出现1次的整数。测试数据为{32,-1,0,32,100,66,66,-7,100,0,-1}。小明知道要定义一个一维数组，并将这11个整数初始化赋值给这个数组的每一个元素。请你在小明的想法的基础上，编写程序完成这道面试题目的要求。将程序代码复制粘贴到答题区，可以尝试运用位运算知识。", "位运算知识提示:", "(1)相同为0，不同为1，即1^1=0， 0^0=0， 0^1=1", "(2)任何一个数和0按位异或就是其自身。例如：3^0=3；0000 0011 ^ 0000 0000 = 0000 0011"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a&amp;#43;&amp;#43;是先取值后&amp;#43;1&amp;#xff1b;&amp;#43;&amp;#43;b是先&amp;#43;1后取值。&lt;/p&gt;\n&lt;p&gt;a的初始值是1&amp;#xff0c;b的初始值是10&lt;br /&gt;进入循环 b-&amp;#61;a;  b&amp;#61;b-a;  b&amp;#61;9; a&amp;#43;&amp;#43;; a&amp;#61;a&amp;#43;1; a&amp;#61;2;&lt;br /&gt;while 条件 b--&amp;lt;0  b&amp;#61;2&amp;lt;0  不满足循环条件&amp;#xff0c;结束循环 b--; b&amp;#61;b-1; b&amp;#61;8&lt;/p&gt;\n&lt;p&gt;输出结果&amp;#xff0c;a&amp;#61;2 ;b&amp;#61;8;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["关于a++ 和++a的运算问题！", ["想问问这个问题！", "a++不应该是先将a赋值为1然后和b-=a进行运算完之后再进行a+1吗？", "那为什么会等于2,8呢？！ 不应该是2 和9嘛？！", "麻烦详细解释一下！最好是a++ 和++a 都详细一下！"]], "Tag": "程序设计"}
{"Answer": "问题补充：\r\ncuiran 写道\r\n计算后的结果不还是要用个变量接收?\r\n\r\n\r\n假如计算后的结果是3，直接写=3不就结了？ \r\n\r\n\r\n其实这个问题的理解就是要理解为什么这个地方要用常量了。\r\n\r\npublic static final byte QUEUE_TYPE = 0x01;\r\npublic static final byte TOPIC_TYPE = 0x02;\r\n\r\npublic static final byte TEMP_TOPIC_TYPE = TOPIC_TYPE | TEMP_MASK; \r\n\r\n假如说以后QUEUE_TYPE 或者 TOPIC_TYPE 变了，如果你这里直接写结果值，那是不是\r\nTEMP_TOPIC_TYPE  也要跟着变呢？\r\n\r\nTEMP_TOPIC_TYPE就是为了表达TOPIC_TYPE | TEMP_MASK 这个关系的。\r\n就算 TOPIC_TYPE 或者 TEMP_MASK 变了，那么TEMP_TOPIC_TYPE 就不用改了。\r\n\r\n这个主要还是代码风格上，主要是担心以后会手工的改。虽然说final运行时不可改。但是业务变了还是会手工改的。\r\n\r\n再说运行效率上，也一样的，存储上TEMP_TOPIC_TYPE 还是会存储它们的结果值的。\r\n\r\n不用纠结的。", "Konwledge_Point": "赋值运算", "Question": ["二进制运算", ["请问，下面的代码", "\npublic static final byte QUEUE_TYPE = 0x01;", "\npublic static final byte TOPIC_TYPE = 0x02;", "\npublic static final byte TEMP_MASK = 0x04;", "\npublic static final byte TEMP_TOPIC_TYPE = TOPIC_TYPE | TEMP_MASK;", "\npublic static final byte TEMP_QUEUE_TYPE = QUEUE_TYPE | TEMP_MASK;", "\n\n", "TEMP_TOPIC_TYPE和TEMP_QUEUE_TYPE 这样写比直接赋值有什么好处吗？"]], "Tag": "程序设计"}
{"Answer": "[javascript计算不同数据类型如何转换](http://www.w3dev.cn/article/20161014/javascript-calculate-different-datatype-convert.aspx \"\")", "Konwledge_Point": "赋值运算", "Question": ["js加运算中数据转换问题", ["var a=10;", "\nconsole.log(a+\"px\");", "\nconsole.log(true+\"px\");", "\n为啥第二行会给a赋值，第三行的true的值没有呢？", "\n也就是啥时候会给true赋值；", "\n请大家帮帮忙，多谢啦"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为a,b两个数组连续定义&amp;#xff0c;分配的空间可能是连续的&amp;#xff0c;你把b[-1]设置为0&amp;#xff0c;b[-1]的位置正好是a[7]的位置&amp;#xff0c;所以a[7]被覆盖为0了&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c语言代码为什么会出现最后一次输出数据会为0？", ["如下代码，在scanf()后添加b[0] = a[0];并对第二个for循环做出修改后输出可以正常运行。", "\n", "但是如果在第二次循环给b[-1]赋值，然后进行循环，会导致a少一个值，最终输出结果a[7]为0，这是为什么呢？", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "define", " SIZE 8", "\n\n", "int", " ", "main", " ", "(", "void", ")", "\n", "{\n    ", "int", " i;\n    ", "double", " a[SIZE], b[SIZE];\n    ", "printf", "(", "\"please input 8 number: \"", ");\n\n    ", "for", " ( i=", "0", "; i< SIZE; i++)\n        ", "scanf", "(", "\"%lf\"", ", &a[i]);\n\n    ", "for", " ( i=", "0", ",b[", "-1", "] = ", "0", "; i< SIZE; i++)\n        b[i]= b[i", "-1", "] +a[i];\n\n    ", "for", " ( i=", "0", "; i< SIZE; i++)\n        ", "printf", "(", "\"%10lf %10lf\\n\"", ", a[i], b[i]);\n\n    ", "return", " ", "0", ";\n}\n", "\n", "代码运行情况如图："]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先赋值&amp;#xff0c;再自减&lt;/p&gt;\n&lt;p&gt;continue的意思是跳过本次循环&amp;#xff0c;执行下一次循环。你这里continue写在if里是不对的&amp;#xff0c;编译会报错。&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["c语言应用基础与基本运算", ["当x=3的时候，x是先赋值给y呢，还是先自减呢？下边的continue什么意思呢，输出会是什么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;while (y &amp;#61;&amp;#61; &amp;#39;&amp;#43;&amp;#39; || y &amp;#61;&amp;#61; &amp;#39;-&amp;#39; || y &amp;#61; &amp;#39;s&amp;#39; || y &amp;#61;&amp;#61; &amp;#39;e&amp;#39;) {&lt;!-- --&gt;&lt;br /&gt;这行y&amp;#61;&amp;#39;s&amp;#39;&amp;#xff0c;少了一个等号了&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["如何解决需要左值作为赋值左操作数问题？具体情况如下", ["准备做一个简单的计算器，要求是当输入s时可以设置初始数字，输入+时开始加法计算，输入减号时开始减法计算，输入e时结束运算程序，能够通过while函数多次循环运算。", "\n", "#", "include", " ", "<stdio.h>", "\n\n", "int", " ", "main", "(", "void", ")", " ", "{\n    ", "float", " x;\n    ", "char", " y;\n    ", "float", " z;\n    ", "printf", "(", "\"plz type the basic number\\n\"", ");\n    ", "scanf", "(", "\"%f\"", ", &x);\n    ", "printf", "(", "\"u can begin your cauculation\"", ");\n    ", "scanf", "(", "\"%c\"", ", &y);\n    ", "while", " (y == ", "'+'", " || y == ", "'-'", " || y = ", "'s'", " || y == ", "'e'", ") {\n        ", "if", " (y == ", "'+'", ") {\n            ", "printf", "(", "\"add\\n\"", ");\n            ", "scanf", "(", "\"%f\"", ", &z);\n            x = x + z;\n            ", "printf", "(", "\"answer %f\"", ", x);\n\n        }\n     ", "else", " ", "if", "(y == ", "'-'", ") {\n            ", "printf", "(", "\"minus\\n\"", ");\n            ", "scanf", "(", "\"%f\"", ", &z);\n            x = x - z;\n            ", "printf", "(", "\"answer %f\"", ", x);\n\n        }\n     ", "else", " ", "if", " (y == ", "'s'", ") {\n            ", "printf", "(", "\"set the basic value\\n\"", ");\n            ", "scanf", "(", "\"%f\"", ", &z);\n            x = z;\n            ", "printf", "(", "\"now the basic value is %f\"", ", x);\n        }\n\n        ", "else", " {\n            ", "printf", "(", "\"end the program\"", ");\n            ", "return", " ", "0", ";\n\n        }\n\n    }\n    ", "if", " (y != ", "'+'", " && y != ", "'-'", " && y != ", "'s'", " && y != ", "'e'", ") {\n        ", "printf", "(", "\"wrong command, try it by using + - s e\"", ");\n    }\n\n\n    ", "return", " ", "0", ";\n\n\n}\n\n", "\n", " 报错内容为  需要左值作为赋值左操作数", "\n", "可能会是因为函数限制不准我使用char类型的数据作为参数？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你while循环的条件写错了哦&amp;#xff0c;要判断num是否为1需要用&amp;#61;&amp;#61;号&amp;#xff0c;即num&amp;#61;&amp;#61;1&lt;br /&gt;num&amp;#61;1表达式的值恒等于1&amp;#xff0c;这样会是一个死循环哦&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["C++使用while语句出现了问题，是想利用while实现“输入1重新开始，输入0结束”", ["学C++才几天，当时主要是为了方便做数学题，所以写了一段求卡方的代码", "一开始没想到用while，后来学到while语句后学以致用，想在不退出程序的情况下进行多次计算，但是出现了问题", "同题，代码运行和运算结果没有问题", "就是没法实现“输入1重新开始，输入0结束”，而且无论输入什么，都是重新开始循环", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    ", "bool", " num = ", "1", ";\n    ", "while", " (num = ", "1", ")\n    {\n        cout << ", "\"输入a，b，c，d的值\"", " << endl;\n        ", "float", " a, b, c, d;\n        cin >> a >> b >> c >> d;                            ", "//从标准输入流中给a,b,c,d赋值", "\n        ", "float", " n = a + b + c + d;                            ", "//算n", "\n        ", "float", " x = a * d - b * c;\n        ", "//接下来开始计算(a+b)*(c+d)*(a+c)*(b+d)的值", "\n        ", "float", " y = a + b, z = a + c;                            ", "//1 令z=a+c", "\n        y = y * z;                                            ", "//2 求得(a+b)*(a+c)", "\n        z = c + d;                                            ", "//3 令z=c+d", "\n        y = y * z;                                            ", "//4 求得(a+b)*(a+c)*(c+d)", "\n        z = b + d;                                            ", "//5 令z=b+d", "\n        y = y * z;                                            ", "//6 1-6步获得(a+b)*(c+d)*(a+c)*(b+d)的值", "\n        ", "//代入公式", "\n        cout << ", "\"总数的值为 \"", " << n << endl;\n        cout << ", "\"交叉相乘的差的平方为 \"", " << x * x << endl;\n        cout << ", "\"四组和的积为 \"", " << y << endl;\n        cout << ", "\"卡方的值为 \"", " << n * x * x / y << endl;\n        cout << ", "\"输入1重新开始，输入0结束:\"", ";\n        cin >> num;\n        cout << endl;\n    }\n    ", "return", " ", "0", ";\n    ", "system", "(", "\"pause\"", ");\n}\n", "\n", "\n", "如图，第一次循环的最后输入了0，但没能使得程序结束循环", "虽然知道可以用其他方法代替，但是这个问题真的折磨我，望解答"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], b[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], c[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n  &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;方阵阶数: &amp;#34;&lt;/span&gt;);\n  &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n      &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;a[i][j]);\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n      &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;b[i][j]);\n  &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n  {\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n    {\n      c[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n      &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; n; k&amp;#43;&amp;#43;)\n        c[i][j] &amp;#43;&amp;#61; a[i][k] * b[k][j];\n      &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%10d&amp;#34;&lt;/span&gt;, c[i][j]);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n  }\n  &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["C语言中求解方阵乘法运算", ["【问题描述】", "    从键盘输入一个正整数n（n∈[1,10]），表示进行乘法运算的两个整形方阵的阶。然后分别输入两个整形方阵A和B，计算A×B后将结果输出到屏幕。", "【输入形式】", "    从键盘输入一个正整数，然后再输入两个整形方阵。", "【输出形式】", "    在屏幕上输出两个整形方阵的乘积。", "【输入样例】", "3", "1 1 1", "3 3 3", "6 6 6", "9 9 9", "6 6 6", "5 5 5", "【输出样例】", "########20########20########20", "########60########60########60", "#######120#######120#######120", "【样例说明】", "首先输入正整数3,说明接下来要输入的方阵是3×3的。因为", "1 1 1         9 9 9          20  20  20", "3 3 3  ×   6 6 6    =    60  60  60", "6 6 6        5 5 5          120 120 120", "所以在屏幕上打印：", "########20########20########20", "########60########60########60", "#######120#######120#######120", "注：\"#\"代表空格，每个输出的整数占10位，不足10位在整数的左边用空格补足。", "\n", "#", "include", "<stdio.h>", "\n ", "int", " ", "main", "()", "\n", "{   ", "int", " a[", "3", "][", "3", "], b[", "3", "][", "3", "], c[", "3", "][", "3", "];\n    ", "int", " i, j, k, sum;\n    ", "printf", "(", "\"输入一个3*3的矩阵：\\n\"", ");\n    ", "for", "(i=", "0", ";i<", "3", ";i++)                    ", "//处理矩阵a中的一行中各元素", "\n     ", "for", "(j=", "0", ";j<", "3", ";j++)               ", "//处理矩阵a中某一列中各元素", "\n   ", "scanf", "(", "\"%d\"", ",&a[i][j]);   ", "//输入数据", "\n ", "printf", "(", "\"输入一个3*3的矩阵；\\n\"", ");\n ", "for", "(i=", "0", ";i<", "3", ";i++)                   ", "//处理矩阵b中的一行中各元素", "\n  ", "for", "(j=", "0", ";j<", "3", ";j++)               ", "//处理矩阵b中某一列中各元素", "\n   ", "scanf", "(", "\"%d\"", ",&b[i][j]);    ", "//输入数据", "\n ", "for", "(i=", "0", ";i<", "3", ";i++)                 ", "//对矩阵c进行处理", "\n { ", "for", "(j=", "0", ";j<", "3", ";j++)\n  { sum=", "0", ";\n   ", "for", "(k=", "0", ";k<", "4", ";k++)   ", "//矩阵c中每一个元素的循环计算", "\n   {\n     sum+=a[i][k]*b[k][j]; ", "//对矩阵c中的某一元素进行计算", "\n   }\n   c[i][j]=sum;           ", "//给矩阵c中的某一元素进行赋值", "\n  }\n }\n ", "printf", "(", "\"得到一个3×3的矩阵：\\n\"", ");\n ", "for", "(i=", "0", ";i<", "3", ";i++)            ", "//输出矩阵c", "\n {\n  ", "for", "(j=", "0", ";j<", "3", ";j++)\n    ", "printf", "(", "\"%5d\"", ",c[i][j]);\n   ", "printf", "(", "\"\\n\"", ");\n   }\n   ", "return", " ", "0", ";\n}\n\n", "\n", "我的运算结果是错的，然后输出也不对，不知道怎么去修改。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;b拿过来直接赋值后值为10&amp;#xff0c;另一个赋值后自增后变为11&amp;#xff08;只是自增&amp;#xff0c;没有赋值&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["0基础java问题，自增运算", ["public static void main(String[] args) {", "        int b = 10;", "        b = b++;", "        System.out.println();", "    }", "这里输出的为什么是10，而不是11，不应该是先将b赋值给b，然后b++，所以b = 11吗？", "知道b++是先用后自增，++b是先自增在使用。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没有初始化的地址&amp;#xff0c;里面的值可能是随机的&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["关于keil5的watch1的问题", ["在程序里定义了一个变量赋值为0，没有对它进行任何操作，添加到watch1中，显示的value为0x062D780D，其他变量也是这样，只是value不同。本来用的好好的，不知道怎么回事就变成了这样，其他原本正常的程序也成这样了"]], "Tag": "程序设计"}
{"Answer": "```\r\n 再定义一个变量保存\r\nchar *s1；\r\ns1=\"hello\";\r\nchar *s1org = s1;\r\ns1++;\r\n...\r\ns1 = s1org;\r\n```", "Konwledge_Point": "赋值运算", "Question": ["直接赋值字符串指针后怎么再次指向该字符串首地址", ["比如 char *s1；", "\ns1=\"hello\";", "\n这样把字符串首字符h的地址赋给字符指针变量", "\n之后s1++运算后 如果s1指向o的地址之后  怎么初始化使s1重新指向h的地址"]], "Tag": "程序设计"}
{"Answer": "如果你能再加一个就更有趣了\r\n\t\r\n\tString d = \"ab\" + \"c\";\r\n\tc == d的判断结果为true\r\n\t\r\n\t原因：\r\n\tString b = a + \"c\"是 一个变量  + 一个已知的字符串\r\n\tString d = \"ab\" + \"c\"是一个已知的字符串 + 另一个已知的字符串\r\n\t在编译期间，String c的值为“abc”是已知的字面量，String d 的结果也是已知的字面量，所以c和d在jvm编译时都会把常量区的\"abc\"赋值给它们\r\n\t而String b在编译期间是未知的，谁知道a在运行时到底是什么，所以jvm会给b开辟一个新的内存空间，因而b和c就不等了。", "Konwledge_Point": "赋值运算", "Question": ["String类中对象创建的问题", ["String a=\"ab\";", "\n    String c=\"abc\";", "\n    String b=a+\"c\";", "\n    System.out.println((c==b));//false", "\n    问题：为啥a是一个对象，而“b”是一个字符串，为啥可以相加得b？为啥得false ？", "\n    在内存中是怎么变化的，怎样运算的，求大神解惑。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#43;&amp;#43;i是先i加上1&amp;#xff0c;再运算&amp;#xff1b;j&amp;#43;&amp;#43;是先用j运算&amp;#xff0c;然后j再加上1&lt;br /&gt;所以 m&amp;#61;&amp;#43;&amp;#43;i &amp;#43; j&amp;#43;&amp;#43;时&amp;#xff0c;i先加1成为9&amp;#xff0c;然后加上j赋值给m&amp;#xff0c;所以m&amp;#61;9&amp;#43;10&amp;#61;19&amp;#xff0c;然后j变为11&lt;br /&gt;n &amp;#61; &amp;#43;&amp;#43;i &amp;#43; &amp;#43;&amp;#43;j &amp;#43; m时&amp;#xff0c;i先加1成为10&amp;#xff0c;j再加1成为12&amp;#xff0c;所以n&amp;#61;10&amp;#43;12&amp;#43;19 &amp;#61; 41&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["希望可以帮我解释下这个题", ["C++中递增运算++在前应该是先运算公式后再递增，所以我觉得n应该事9+11+19+39，但是跑出来41，那他就是10+12+39了，这应该事后++先赋值后运算的结果么，希望能帮我解答一下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;128&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, a) !&amp;#61; EOF) {\n        k &amp;#43;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(a);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, k);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["如何用strlen去数出一个赋值数组的长度大小(语言-c语言)", ["当我将此程序进行运算之后，strlen函数好像计算出来的是乱码一样，并且将它打印，", "但是我的目的是当我每输入一组数据时，strlen函数可以随着我的输入而增加，程序如图", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给你改好了&lt;br /&gt;确实是scanf&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; {};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m, n;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j,temp;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[i][j]);  &lt;span class=\"hljs-comment\"&gt;//这里取地址&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,a[i][j]);   &lt;span class=\"hljs-comment\"&gt;//这里不取地址&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入交换行m,n的值&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d,%d&amp;#34;&lt;/span&gt;,&amp;amp;m,&amp;amp;n);   &lt;span class=\"hljs-comment\"&gt;//注意要交换的行数&amp;#xff0c;与数组内m&amp;#xff0c;n相差1&lt;/span&gt;\n    m&amp;#61;m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    n&amp;#61;n&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//不可使用 m--&amp;#xff0c;n--&amp;#xff0c;因为系统会认为没赋值便执行运算&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        temp &amp;#61; a[m][i];\n        a[m][i] &amp;#61; a[n][i];\n        a[n][i] &amp;#61; temp;\n    }\n \n \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输出&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,a[i][j]);\n        }\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/166085088646165.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["无法完成for循环内通过scanf函数对二位整形数组赋值（应该是scanf出问题了，求修正）", ["#", "include", "<stdio.h>", "\n", "#", "include", "<math.h>", "\n", "#", "include", "<stdlib.h>", "\n", "int", " ", "main", "()", "{\n    ", "int", " a[", "5", "][", "5", "] = {};\n    ", "int", " m, n;\n    ", "int", " i,j,temp;\n    ", "for", "(i = ", "0", ";i < ", "5", ";i++)\n    {\n        ", "for", "(j = ", "0", ";j < ", "5", ";j++)\n        {\n            ", "scanf", "(", "\"%d\"", ",a[i][j]);\n            ", "printf", "(", "\"%d\\n\"", ",&a[i][j]);\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n\n\n    ", "printf", "(", "\"输入交换行m,n的值：\\n\"", ");\n    ", "scanf", "(", "\"%d,%d\"", ",&m,&n);   ", "//注意要交换的行数，与数组内m，n相差1", "\n    m=m", "-1", ";\n    n=n", "-1", ";    ", "//不可使用 m--，n--，因为系统会认为没赋值便执行运算", "\n    ", "for", "(i=", "0", ";i<", "5", ";i++){\n        temp = a[m][i];\n        a[m][i] = a[n][i];\n        a[n][i] = temp;\n    }\n\n\n    ", "printf", "(", "\"输出：\\n\"", ");\n    ", "for", "(i = ", "0", ";i < ", "5", ";i++)\n    {\n        ", "for", "(j = ", "0", ";j < ", "5", ";j++)\n        {\n            ", "printf", "(", "\"%d\"", ",a[i][j]);\n        }\n        ", "printf", "(", "\"\\n\"", ");\n    }\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "直接赋值就行\r\n\r\n```\r\n id=\"DPrice/ProductPrice \"\r\n```", "Konwledge_Point": "赋值运算", "Question": ["struts2在遍历的同时能不能调用js函数进行运算", ["s:iterator value=\"page.list\" status=\"userOrders\"", "\n     /td align=\"center\"  s:property value=\"ProductPrice\"/  /td", "\n   /td align=\"center\"  s:property value=\"DPrice\"   /i id=\"dis\"  /td", "\n/s:iterator", "\n\n", "在这个遍历的时候，我想用  DPrice/ProductPrice = dis ，然后赋值给id=‘dis’"]], "Tag": "程序设计"}
{"Answer": "什么叫没错误，你释放那块就有问题：\r\nvoid Queue::clear(void)//清空链队\r\n自己到底调过没有，张嘴就说\r\n改成这样就不会崩了，你有其他转换问题就自行查询吧\r\n```\r\nvoid Queue::clear(void)//清空链队\r\n{\r\n\tif (count == 0) return;\r\n\tnode *searchp = front-&gt;next, *followp = front;//初始化两个指针\r\n\twhile (searchp != rear)\r\n\t{\r\n\t\tfollowp = searchp;\r\n\t\tsearchp = searchp-&gt;next;\r\n\t\tdelete followp;\r\n\t}\r\n\tfront-&gt;next = NULL;//保留了最后一个结点，就是头结点，并且链域置为空\r\n\trear = front;\r\n\tcount = 0;//计数器也清零\r\n}\r\n```", "Konwledge_Point": "赋值运算", "Question": ["代码没有错误，为什么程序没运行完就直接结束了？", ["\n\n", "//主要功能：实现带小数二进制和十进制之间数据的转换\n#include <iostream.h>\n#include <windows.h>\n#include <fstream.h>\n#include <string>\n#include <math.h>\n\nusing namespace std;\n\nconst int TAILMAXLENTH=10;//定义十进制转换成二进制小数部分最大位数\nconst int DABAMAXLENTH=40;//定义原始数据的最大长度\nconst double ADDMENBERNUM=111.11;//定义一个加数用于检测数据真实可用\n\n/*********************************************************************************************************\n*栈的部分\n*********************************************************************************************************/\nclass Stack;//类Stack的声明\n\n/*\n定义一个链栈结点类Stacknode\n*/\nclass Stacknode\n{\n    friend class Stack;//申请友元类\nprivate:\n    Stacknode(Stacknode *nextp=NULL);//构造函数\n    Stacknode(int &newdata,Stacknode *nextp=NULL);//构造函数\n    int data;//数据元素\n    Stacknode *next;//递归定义指向后继结点的指针\n};\n\n/*\nStacknode的实现部分\n*/\nStacknode::Stacknode(Stacknode *nextp)//构造函数\n{\n    next=nextp;\n}\n\nStacknode::Stacknode(int &newdata,Stacknode *nextp)//构造函数\n{\n    data=newdata;\n    next=nextp;\n}\n//结点类Stacknode的定义结束\n\n/*\n定义一个链栈类Stack\n*/\nclass Stack\n{\npublic:\n    Stack();//创建一个空栈\n    ~Stack();//回收一个栈\n    void clear();//销毁一个栈\n    bool empty() const;//确定栈是否已空\n    bool push(int &item);//把数据压进栈\n    bool pop();//出栈\n    bool top(int &item) const;//取出栈顶元素\nprivate:\n    Stacknode *newnode(Stacknode *nextp=NULL);\n    Stacknode *newnode(int &item,Stacknode *nextp=NULL);//创建新的结点\n    Stacknode *Stacktop;\n    int Stacklength;\n};\n\n/*\nStack的实现部分\n*/\nStacknode *Stack::newnode(Stacknode *nextp)//创建新的结点，不带数据\n{\n    return new Stacknode(nextp);\n}\n\nStacknode *Stack::newnode(int &item,Stacknode *nextp)//创建新的结点，数据域赋值\n{\n    return new Stacknode(item,nextp);\n}\n\n//以下为栈类Stack的函数定义\nStack::Stack()//创建一个空栈\n{\n    Stacktop=newnode();//创建一个栈顶指针初始化，相当于Stacktop=NULL；本链表没有用头结点\n    Stacklength=0;\n}\n\nStack::~Stack()//回收一个栈\n{\n    clear();\n    delete Stacktop;//释放栈底\n}\n\nvoid Stack::clear()//销毁一个栈\n{\n    //while(pop());//不停地出栈，而每次释放空间在出栈函数中完成\n    Stacknode *usednodep;//定义指针usednodep，准备指向出栈的结点\n    while(Stacktop->next!=NULL)\n    {\n        usednodep=Stacktop;//指向出栈的结点\n        Stacktop=Stacktop->next;//栈顶指针后移\n        delete usednodep;//释放空间\n    }\n}\n\nbool Stack::empty() const//确定栈是否已空\n{\n    return Stacklength<=0?true:false;\n}\n\nbool Stack::push(int &item)//数据进栈\n{\n    Stacknode *newnodep;//定义指针newnodep，准备指向申请的新结点\n    newnodep=newnode(item,Stacktop);//申请新结点，把数据存入，把指针域指向头指针\n    if(!newnodep)//如果没有申请到空间，返回失败\n        return false;\n    Stacktop=newnodep;//改链，完成进栈\n    Stacklength++;//栈的长度增加\n    return true;//本次操作成功\n}\n\nbool Stack::pop()//出栈,不要栈顶数据\n{\n    Stacknode *usednodep;//定义指针usednodep，准备指向出栈的结点\n    if(!empty())//判断是否栈空\n    {\n        usednodep=Stacktop;//指向出栈的结点\n        Stacktop=Stacktop->next;//栈顶指针后移\n    //  delete usednodep;//释放空间\n        Stacklength--;//栈的长度减少\n        return true;//本次操作成功\n    }\n    return false;//否则本次操作失败\n}\n\nbool Stack::top(int &item) const//取出栈顶数据返回去\n{\n    if(!empty())//如果栈不空，记录当前栈顶元素\n    {\n        item=Stacktop->data;//通过item返回去\n        return true;//本次操作成功\n    }\n    return false;//否则本次操作失败\n}\n\n/*********************************************************************************************************\n*队列的部分\n*********************************************************************************************************/\n/*\n定义一个结点类node\n*/\nclass node\n{\npublic:\n    int data;\n    node *next;\n};\n\n/*\n定义一个链队类Queue\n*/\nclass Queue\n{\nprivate:\n    node *rear;\n    node *front;\nprotected:\n    int count;//计数器，统计结点个数即线性队列的长度\npublic:\n    Queue();//构造函数\n    ~Queue();//析构函数\n    void clear(void);//清空链队\n    bool empty(void) const;//判断是否空队\n    bool retrieve(int &item) const;//读取队头\n    bool append(const int &item);//数据入队\n    bool serve();//数据出队\n};\n\n/*\n类Queue的实现部分\n*/\nQueue::Queue()//构造函数\n{\n    front=new node;//申请新结点，作为队头结点\n    front->next=NULL;\n    rear=front;//队尾指针指向队头\n    count=0;//计数器清零，队列开始时没有实际数据\n}\n\nQueue::~Queue()//析构函数\n{\n    clear();//删除所有数据，释放所有结点\n    delete front;//把头结点也释放掉\n    count=0;//计数器清零，队列开始时没有实际数据\n}\n\nvoid Queue::clear(void)//清空链队\n{\n    node *searchp=front->next,*followp=front;//初始化两个指针\n    while(searchp!=rear)\n    {\n        followp=searchp;\n        searchp=searchp->next;\n        delete followp;\n    }\n    front->next=NULL;//保留了最后一个结点，就是头结点，并且链域置为空\n    rear=front;\n    count=0;//计数器也清零\n}\n\nbool Queue::empty(void) const//判断是否空链\n{\n    return count==0?true:false;\n}\n\nbool Queue::retrieve(int &item) const//读取队头\n{\n    if(empty())//处理意外\n        return false;\n    item=front->next->data;//返回读取的数据\n    return true;//本次操作成功\n}\n\nbool Queue::append(const int &item)//进队\n{\n    node *newnodep=new node;\n    newnodep->data=item;//给数据赋值\n    rear->next=newnodep;//这一步可以看出有头结点\n    rear=rear->next;//改动队尾指针的位置\n    count++;//计数器加1\n    return true;\n}\n\nbool Queue::serve()//出队\n{\n    if(empty())//空队处理\n        return false;\n    node *tempp=front->next;\n//  item=tempp->data;//保存数据\n    front->next=tempp->next;//改变指针\n    delete tempp;//释放该结点\n    count--;//计数器减1\n    return true;\n}\n\n/*********************************************************************************************************\n*定义一个功能类NumSysConversion\n*********************************************************************************************************/\nclass NumSysConversion\n{\nprivate:\n    int inter;\n    float floater;\n    Stack *stack;\n    Queue *queue;\npublic:\n    NumSysConversion();//构造函数\n    ~NumSysConversion();//析构函数\n    bool check(char *array,int number);//检查输入数据是否符合要求\n    void change(char *array,int number);//将原始数据转化成数值\n    double change_to_aim(int tokind);//将原始数据转化成目标进制的数据\n};\n\nNumSysConversion::NumSysConversion()//构造函数\n{\n    stack=new Stack;\n    queue=new Queue;\n    inter=0;\n    floater=0;\n}\n\nNumSysConversion::~NumSysConversion()//析构函数\n{\n    delete stack;\n    delete queue;\n}\n\nbool NumSysConversion::check(char *array,int number)//检查输入数据是否符合要求\n{\n    bool flag=true;\n    for(int i=0;array[i]!='\\0';i++)\n    {\n        cout<<array[i];\n        if(array[i]-48>=number)\n        {\n            flag=false;\n            break;\n        }\n    }\n    return flag;\n}\n\nvoid NumSysConversion::change(char *array,int number)//将原始数据转化成数值\n{\n    int flag=0,j=0;\n    for(int i=0;array[i]!='\\0';i++)\n    {\n        if(array[i]=='.')\n        {\n            flag=1;\n            continue;\n        }\n        if(flag==0)//取整数数据\n            inter=inter*number+array[i]-48;\n        if(flag==1)//取小数数据\n            floater+=(float)(((int)array[i]-48)*(float)pow(number,--j));\n    }\n}\n\ndouble NumSysConversion::change_to_aim(int tokind)//将原始数据转化成目标进制的数据\n{\n    int count=0,temp,flag=0,num;\n    double resnumb=0;\n    //第一步：先将整数部分转换进制后的数据依次入栈\n    while(inter)\n    {\n        num=inter%tokind;\n        stack->push(num);\n        inter/=tokind;\n    }\n    //第二步：再将小数部分转换进制后的数据依次入队\n    while(floater&&count<TAILMAXLENTH)\n    {\n        queue->append(int(floater*tokind));\n        floater*=tokind;\n        if(floater>=1)\n            floater-=(int)floater;\n        count++;\n    }\n    //第三步：显示栈和队中的数据并将其转换成可用数据\n    cout<<\"数据转换后为：\";\n    while(!stack->empty())\n    {\n        stack->top(temp);\n        stack->pop();\n        cout<<temp;\n        resnumb=resnumb*tokind+temp;\n        flag=1;\n    }\n    if(!queue->empty())\n    {\n        if(flag==0)\n            cout<<\"0\";\n        cout<<\".\";\n        count=-1;\n    }\n    while(!queue->empty())\n    {\n        queue->retrieve(temp);\n        queue->serve();\n        cout<<temp;\n        resnumb+=temp*pow(tokind,count--);\n    }\n    cout<<endl;\n    //第四步：清空栈和队中的数据\n    stack->clear();\n    queue->clear();\n    inter=0;\n    floater=0;\n    //第五步：将可用数据信息返回\n    return resnumb;\n}\n\n/*\n定义一个实现进制转换功能的菜单处理类interfacebase\n*/\nclass interfacebase\n{\nprivate:\n    NumSysConversion NumSysConversiononface;\npublic:\n    void clearscreen(void);//清屏\n    void showmenu(void);//显示菜单函数\n    int userchoice(void);//用户的选项\n    void processmenu(int menuchoice);//菜单函数\n};\n\n/*\n类interfacebase的实现部分\n*/\nvoid interfacebase::clearscreen(void)\n{\n    system(\"cls\");\n}\n\nvoid interfacebase::showmenu(void)\n{\n    cout<<\"进制转换功能菜单\"<<endl;\n    cout<<\"================\"<<endl;\n    cout<<\"1.十进制转换为二进制\"<<endl;\n    cout<<\"2.二进制转换为十进制\"<<endl;\n    cout<<\"0.结束程序\"<<endl;\n    cout<<\"================\"<<endl;\n}\n\nint interfacebase::userchoice(void)\n{\n    int menuchoice;\n    cout<<\"请输入您的选择：\";\n    cin>>menuchoice;\n    return menuchoice;\n}\n\nvoid interfacebase::processmenu(int menuchoice)\n{\n    switch(menuchoice)//根据用户的选择进行相应的操作\n    {\n    case 1:\n        {\n            char array[10]={'0','.','1','2','5'};\n            int number=10;\n            if(NumSysConversiononface.check(array,number))\n                cout<<\"符合要求！\"<<endl;\n            else\n                cout<<\"不符合要求！\"<<endl;\n            NumSysConversiononface.change(array,number);\n            cout<<NumSysConversiononface.change_to_aim(2)<<endl;\n            cout<<\"进制转换成功！\"<<endl;\n        }\n        break;\n    case 2:\n        {\n            char array[10]={'1','1','1','1'};\n            int number=2;   \n            if(NumSysConversiononface.check(array,number))\n                cout<<\"符合要求！\"<<endl;\n            else\n                cout<<\"不符合要求！\"<<endl;\n            NumSysConversiononface.change(array,number);\n            cout<<NumSysConversiononface.change_to_aim(10)<<endl;\n            cout<<\"进制转换成功！\"<<endl;\n        }\n        break;\n    case 0:\n        exit(0);\n    default:\n        cout<<\"对不起，您输入的功能编号有错！请重新输入！！！\"<<endl;\n        break;\n    }\n}\n\n/*\n程序主入口\n*/\nvoid main(void)\n{\n    int menuchoice;//定义变量，菜单选单项的选择\n    interfacebase interfacenow;\n    system(\"color f0\");//修改屏幕的背景色和字的颜色\n    interfacenow.clearscreen();//清屏\n    while(1)//永真循环\n    {\n        interfacenow.showmenu();//显示菜单\n        menuchoice=interfacenow.userchoice();//获取用户的选择\n        interfacenow.processmenu(menuchoice);//处理用户的选择\n        system(\"pause\");//暂停\n        interfacenow.clearscreen();//清屏\n    }\n}//主函数结束\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;x&amp;#43;&amp;#43;&amp;lt;5是先计算x&amp;lt;5&amp;#xff0c;然后x&amp;#43;&amp;#43;&amp;#xff0c;和x小于5成立不成立没有关系。就是说5&amp;lt;5不成立,但依然会计算x&amp;#43;&amp;#43;。&lt;br /&gt;所以最终x&amp;#61;6。&lt;br /&gt;有帮助的话采纳一下哦&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["int x＝1 while（x++＜5)  i++和++i区别", ["int x＝1 while（x++＜5）为啥子x＝6呢 当x++等于5的时候已经不小于5了呀 先赋值再运算也不满足循环条件了啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;设本月预算为num1&lt;br /&gt;设本月支出为num2&lt;br /&gt;设剩余预算为sum&lt;br /&gt;给这两个输入框都绑定一个bindinput事件&lt;br /&gt;在各自的事件函数中给各自对应的变量赋值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;inputNum1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(e)&lt;/span&gt;&lt;/span&gt; {\n  this&lt;span class=\"hljs-selector-class\"&gt;.setData&lt;/span&gt;({\n    num1: e&lt;span class=\"hljs-selector-class\"&gt;.detail&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.value&lt;/span&gt;,\n    sum: e&lt;span class=\"hljs-selector-class\"&gt;.detail&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.value&lt;/span&gt; - this&lt;span class=\"hljs-selector-class\"&gt;.data&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.num2&lt;/span&gt;\n  })\n},\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;inputNum2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(e)&lt;/span&gt;&lt;/span&gt; {\n  this&lt;span class=\"hljs-selector-class\"&gt;.setData&lt;/span&gt;({\n    num2: e&lt;span class=\"hljs-selector-class\"&gt;.detail&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.value&lt;/span&gt;,\n    sum: this&lt;span class=\"hljs-selector-class\"&gt;.data&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.num1&lt;/span&gt; - e&lt;span class=\"hljs-selector-class\"&gt;.detail&lt;/span&gt;&lt;span class=\"hljs-selector-class\"&gt;.value&lt;/span&gt; \n  })\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["输入本月预算与支出之后怎么样可以立马显示剩余预算", ["我是用的一个弹出层来进行输入预算，支出，但剩余预算应该怎么弄呢，是在js对其进行运算赋值吗"]], "Tag": "程序设计"}
{"Answer": "bds operator+(bds&amp; s1, bds&amp; s2) 改为bds operator+(const bds&amp; s1, const bds&amp; s2)\r\nvoid operator=(bds&amp; c)  改为void operator=(const bds&amp; c);", "Konwledge_Point": "赋值运算", "Question": ["VS2019 C++ 重载‘+’，‘=’后不能正确的把相加后的表达式赋值给新创建的类。", ["\n这个是重载的+", "\n这个是重载的=", "\n\n", "\n这个是主函数", "\n这里就是报错内容了", "\n\n", "直接两个类相等都没问题，为什么进行重载后的+运算会出错呢？。。。", "\n\n", ".cpp", "\n\n", "#include \"bds.h\"\n#include<iostream>\n#include<iomanip>\nusing namespace std;\nbds::bds(){\n    p = new char[80];\n    x1 = 0, x2 = 0,x3 = 0;\n}\nbds::~bds() {\n    delete[]p;\n}\nbds::bds(const char* x)\n{\n    p = new char[80];\n    int t = 0;\n    for (; x[t] != '\\0'; t++)\n    {\n        p[t] = x[t];\n    }\n    p[t] = '\\0';\n    x1 = 0, x2 = 0, x3 = 0;\n}\nbds::bds(bds& c)\n{\n    p = new char[80];\n    int i = 0;\n    for (; c.p[i] != '\\0'; i++)\n    {\n        p[i] = c.p[i];\n    }\n    p[i] = '\\0';\n    x1 = c.x1, x2 = c.x2, x3 = c.x3;\n};\nostream& operator<<(ostream& out, bds& c)\n{\n    out << c.p;\n    return out;\n};//重载输出字符\nistream& operator>>(istream& in, bds& c)\n{\n    in >> c.p;\n    return in;\n}\nbds operator+(bds& s1, bds& s2)\n{\n    bds s3;\n    s1.shu(), s2.shu();\n    s3.x1 = s1.x1 + s2.x1;\n    s3.x2 = s1.x2 + s2.x3;\n    s3.x3 = s1.x3 + s2.x3;\n    if (s3.x1!=0)\n    {\n        if (s3.x2!=0)\n        {\n            if (s3.x3!=0)\n            {\n                bds s(\"(0x+0x*x+0x*x*x)\");\n                char c1[2],  c2[2], c3[2];\n                _itoa_s(s3.x1, c1, 10);\n                _itoa_s(s3.x2, c2, 10);\n                _itoa_s(s3.x3, c3, 10);\n                s3 = s;\n                s3.p[1] = c1[0];\n                s3.p[4] = c2[0];\n                s3.p[9] = c3[0];\n\n            }\n        }\n    }\n    return s3;\n}\nvoid bds::operator=(bds& c)\n{\n    int i = 0;\n    for (; c.p[i] != '\\0'; i++)\n    {\n        p[i] = c.p[i];\n    }\n    p[i] = '\\0';\n    x1 = c.x1, x2 = c.x2, x3 = c.x3;\n}\nvoid bds::shu()\n{\n    for (int i = 0; i<strlen(p); i++)\n    {\n        int k = 0;\n        if (p[i] == 'x')\n        {\n            int j = 0;\n            for (; p[i + j] != '+'; j++)\n            {\n\n                if (p[i + j] == '\\0')\n                {\n                    if (p[i + j - 1] == ')')\n                    {\n                        j = j - 1;\n                    }\n                    break;\n                }\n            }\n            k = j;\n            switch (j)\n            {\n                char str[100];\n            case 1: {str[0] = p[i - 1];\n                x1 = atoi(str);\n                if (p[i - 1] == '+')\n                {\n                    x1 = 1;\n                }\n            }\n                  break;\n            case 3: {str[0] = p[i - 1];\n                x2 = atoi(str);\n                if (p[i - 1] == '+')\n                {\n                    x2 = 1;\n                }\n            }\n                  break;\n            case 5: {str[0] = p[i - 1];\n                x3 = atoi(str);\n                if (p[i - 1] == '+')\n                {\n                    x3 = 1;\n                }\n            }\n            default:\n                break;\n            }\n        }\n        i += k;\n    }\n}\n;\n", "\n\n", ".h", "\n\n", "#pragma once\n#include<iostream>\n#include<iomanip>\nusing namespace std;\nclass bds\n{\nprivate:\n    int x1,x2,x3;\n    char* p;\npublic:\n    bds();\n    ~bds();\n    bds(const char* x);\n    bds(bds& c);\n    friend ostream& operator<<(ostream& out, bds& c);\n    friend istream& operator>>(istream& in, bds& c);\n    friend bds operator+(bds&s1,bds&s2);\n    void operator=(bds& c);\n    void show()\n    {\n        cout << x1 << \",\" << x2 << \",\" << x3;\n    }\n    void shu();\n};\n", "\n\n", "主程序", "\n\n", "#include<iostream>\n#include<iomanip>\n#include\"bds.h\"\nusing namespace std;\nint main()\n{\n    bds t(\"(4x*x*x+3x*x+x)\");\n    bds w(\"(2x+2x*x+2x*x*x)\");\n    t.shu();\n    w.shu();\n    bds q;\n    q = t+w;\n    q = t;\n    q.shu();\n    //char s1[100]{ \"(2x*x+1)\" };\n    //cout << t << endl;\n    /*t.show();*/\n    q.show();\n    cout << q;\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组下标是从0开始的&amp;#xff0c;&lt;br /&gt;你int a[30]设置数组长度30&amp;#xff0c;这样数组分配空间是30个&amp;#xff0c;数组下标是a[0]到a[29]&amp;#xff0c;没有a[30]。&lt;br /&gt;你 for(int i&amp;#61;2;i&amp;lt;&amp;#61;30;i&amp;#43;&amp;#43;) 这样 i 循环到30会造成数组下标越界。&lt;br /&gt;数组下标越界会把数据写入到数组分配空间之后的未知空间中&amp;#xff0c;&lt;br /&gt;可能其他变量的空间地址就处于这块未知空间中&amp;#xff0c;这样其他变量的值就被意外的改变了。&lt;/p&gt;\n&lt;p&gt;你可以设置a&amp;#xff0c;b&amp;#xff0c;c数组长度为31&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int n,a[31],b[31],c[31],d&amp;#61;0,ans;&lt;/span&gt;&lt;br /&gt;或者让数组下标 从 0循环到29.不要访问数组的30下标&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["对一个与结果无关的变量进行运算后打印的结果不一致是什么原因，QAQ", ["在输出前进行了一个循环并且赋值，这个值与输出结果无关但是却导致了输出结果不一致", "\n", "\n", "\n", "#include<stdio.h>\n\nint main()\n\n{\n\n    int n,a[", "30", "],b[", "30", "],c[", "30", "],d=", "0", ",ans;\n    a[", "1", "]=", "0", ";\n    b[", "1", "]=", "1", ";\n    c[", "1", "]=", "1", ";\n    for(int i=", "2", ";i<=", "30", ";i++)\n    {\n        a[i]=", "0", ";\n        b[i]=", "0", ";\n        c[i]=", "0", ";\n    }\n    scanf(", "\"%d\"", ",&n);\n    for(int i=", "1", ";i<=n;i++)\n    {\n\n        for(int j=", "1", ";j<=", "30", ";j++)\n        {\n            c[j]=a[j]+b[j];\n            c[j]=c[j]+d;\n            if(c[j]>", "9", ")\n            {\n                d=c[j]/", "10", ";\n                c[j]=c[j]", "%10;", "\n            }\n            else d=", "0", ";\n        }\n        for(int j=", "1", ";j<=", "30", ";j++)\n        {\n            a[j]=b[j];\n        }\n        for(int j=", "1", ";j<=", "30", ";j++)\n            {b[j]=c[j];\n            }\n        }\n    for(int p=", "20", ";p>", "0", ";p--)\n    {\n        ans++;\n    }\n    for(int i=", "30", ";i>", "0", ";i--)\n    {\n        printf(", "\"%d\"", ",c[i]);\n    }\n            return ", "0", ";\n\n}\n\n\n", "\n", "#include<stdio.h>\n\nint main()\n\n{\n\n    int n,a[", "30", "],b[", "30", "],c[", "30", "],d=", "0", ",ans;\n    a[", "1", "]=", "0", ";\n    b[", "1", "]=", "1", ";\n    c[", "1", "]=", "1", ";\n    for(int i=", "2", ";i<=", "30", ";i++)\n    {\n        a[i]=", "0", ";\n        b[i]=", "0", ";\n        c[i]=", "0", ";\n    }\n    scanf(", "\"%d\"", ",&n);\n    for(int i=", "1", ";i<=n;i++)\n    {\n\n        for(int j=", "1", ";j<=", "30", ";j++)\n        {\n            c[j]=a[j]+b[j];\n            c[j]=c[j]+d;\n            if(c[j]>", "9", ")\n            {\n                d=c[j]/", "10", ";\n                c[j]=c[j]", "%10;", "\n            }\n            else d=", "0", ";\n        }\n        for(int j=", "1", ";j<=", "30", ";j++)\n        {\n            a[j]=b[j];\n        }\n        for(int j=", "1", ";j<=", "30", ";j++)\n            {b[j]=c[j];\n            }\n        }\n    for(int p=", "20", ";p>", "0", ";p--)\n    {\n     //   ans++;\n    }\n    for(int i=", "30", ";i>", "0", ";i--)\n    {\n        printf(", "\"%d\"", ",c[i]);\n    }\n            return ", "0", ";\n\n}\n\n", "\n", "两段代码仅有42行的ans++是否被注释不一致", "所用软件为最新官网下载的code blocks", "编译器位GNU GCC"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/u012222078/article/details/32911955", "Konwledge_Point": "赋值运算", "Question": ["getchar的用法不太会，请大神指教", ["我在用vs2010编程学习时用这个总会出错，是在赋值符号和算法运算时出错，比如从键盘输入一个字符，然后显示出来，该怎么做？请大神指教下菜鸟，"]], "Tag": "程序设计"}
{"Answer": "隐式类型转换可以从小到大自动转，即byte-&gt;short-&gt;int-&gt;long\r\n如果反过来会丢失精度，必须进行显示类型转换 \r\n \r\ns=s+1这句先执行s+1然后把结果赋给s，由于1为int类型，所以s+1的返回值是int\r\n\r\n  所以将一个int类型赋给short就会出错，\r\n\t\r\ns+=1不同由于是+=操作符，在解析时候s+=1就等价于s = (short)(s+1),翻番来讲就是 \r\n  s+=1 &lt;=&gt; s =  (s的类型)(s+1)", "Konwledge_Point": "赋值运算", "Question": ["java运算符+=引出的问题，希望搞明白", [" short s = 3;\n s = s + 5;  \n s += 5;  \n", "\n\n", "运算结果是 s = s + 5;  这句话编译错误，因为 s+5后，数值类型强制转换成了int型，", "\n再赋值给一个short变量是，会丢失精度，出现编译错误", "\n\n", "但是s += 5；  这个运算过程是怎样的，原理是什么，为什么这个就可以编辑通过呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这代码没写错吧&amp;#xff1f;&lt;br /&gt;a&amp;#61;31141529  打印没毛病啊&lt;br /&gt;b初始化为0&amp;#xff0c;然后你 r &amp;#61; (long)b&amp;#xff0c;printf打印b自然还是0&lt;br /&gt;c都不知道从哪里来的&amp;#xff0c;你咋输出的呢&amp;#xff1f;&lt;br /&gt;你不会赋值语句写反了吧&amp;#xff1f;&lt;br /&gt;r赋值给a&amp;#xff0c;应该写成  a &amp;#61; (long)r;啊&amp;#xff0c;后面也是 b &amp;#61; (long)r啊&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["dev c++关于long类型转换出现错误", ["想将long型a的变量赋值给int型r，此时r暂时为long型，再将r赋值给int型，再看此时的r是用的long型计算还是用的原本的int型进行与b的运算。但是，r、b的赋值操作出现错误，有大佬来帮忙看看的吗", "代码：", "int main（）", "{", "    long a=31141529;", "    printf(\"a=%ld\\n\",a);", "    int r=0,b=0;", "    a=(long)r;", "    printf(\"r=%ld\",r);", "    r=(long)b;", "    printf(\"b=%ld\",b);", "}", "输出结果：", "a=31141529", "b=0", "c=0"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ok&amp;#xff0c;写好了&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Demo&lt;/span&gt; {\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;{\n        Complex complex1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;21&lt;/span&gt;);\n        Complex complex2 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;19&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;99&lt;/span&gt;);\n\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;复数1为&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; complex1);\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;复数2为&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; complex2);\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;复数相减为&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; complex1.&lt;span class=\"hljs-built_in\"&gt;subtraction&lt;/span&gt;(complex2).&lt;span class=\"hljs-built_in\"&gt;toString&lt;/span&gt;());\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;复数相乘为&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; complex1.&lt;span class=\"hljs-built_in\"&gt;multiplication&lt;/span&gt;(complex2).&lt;span class=\"hljs-built_in\"&gt;toString&lt;/span&gt;());\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * 复数类\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Complex&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; real, imaginary;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Complex&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-built_in\"&gt;this&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Complex&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; real)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-built_in\"&gt;this&lt;/span&gt;(real, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Complex&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; real, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; imaginary)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.real &amp;#61; real;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.imaginary &amp;#61; imaginary;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getReal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; real;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setReal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; real)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.real &amp;#61; real;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getImaginary&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; imaginary;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setImaginary&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; imaginary)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.imaginary &amp;#61; imaginary;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 复数的减法\n     *\n     * &amp;#64;param complex 减数\n     * &amp;#64;return 相减以后的复数对象\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; Complex &lt;span class=\"hljs-title\"&gt;subtraction&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Complex complex)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;() - complex.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;(), &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;getImaginary&lt;/span&gt;() - complex.&lt;span class=\"hljs-built_in\"&gt;getImaginary&lt;/span&gt;());\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 复数的乘法\n     *\n     * &amp;#64;param complex 乘数\n     * &amp;#64;return 相乘以后的复数对象 计算方法&amp;#xff1a;(a&amp;#43;bi)(c&amp;#43;di)&amp;#61;(ac-bd)&amp;#43;(bc&amp;#43;ad)i。\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; Complex &lt;span class=\"hljs-title\"&gt;multiplication&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Complex complex)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; a &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;(), b &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;getImaginary&lt;/span&gt;(), c &amp;#61; complex.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;(), d &amp;#61; complex.&lt;span class=\"hljs-built_in\"&gt;getImaginary&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(a * c - b * d, b * c &amp;#43; a * d);\n    }\n\n    &amp;#64;&lt;span class=\"hljs-function\"&gt;Override\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;toString&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; real &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt; &amp;#43; imaginary &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;;\n    }\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["编写一个Java程序，实现以下功能", ["设计一个复数类，要求:", "(1)在复数内部用双精度浮点数定义其实部和虚部;", "(2)实现3个构造函数:无参(实部，虚部均为0)、1 个参数(参数赋值给实部，虚部为0)、2个参数(参数分别给实部虚部赋值);", "(3)编写获取和修改复数的实部和虚部的成员方法;", "(4)编写实现复数减法、乘法运算的成员方法;", "(5)设计主方法，验证各成员方法的正确性;"]], "Tag": "程序设计"}
{"Answer": "你的问题是昨天danielinbiti回答你的吧。\r\n首先，他说的本身没有问题，但是我觉得danielinbiti把问题说复杂了。\r\n解释下什么是“入栈”，Java编译器会把你的程序编译成中间代码（Java字节码），这种中间代码不面向具体的机器，而是一种抽象的计算机，这种计算机使用了一种类似堆栈的结构来处理它的指令。\r\n这涉及到编译原理等背景知识，这里不展开说。\r\n但是你应该从语言本身去理解。而不是编译器的实现。按照Java编译器对代码的理解意图，它会视a为一个不变的值，这样做的好处是，a只会被求值一次。因此，\r\na+3*a++中左边的a不会因为a++而增加1。\r\n要注意一个问题，a++中的a和a++表达式求值是两回事。a++虽然拥有表达式中最高的优先级，但是说的是a++被求值拥有最高的优先级，而不是说a++被求值后对a的改变会反映到表达式上。\r\n我之前分析了，这个表达式是一个副作用表达式，它的表意本身就是含糊的，所以不要试图预测编译器的行为。\r\n顺便说下，这其实和Java是否使用计算栈还是什么别的方式编译和生成代码其实没有关系，计算栈也是图灵等价的，没有道理说它会有别于别的计算机或者抽象计算机设备。\r\n这只是Java编译器设计者的一种意图的体现——当代码拥有规范所没有规定的行为的时候，或者说，它可以这么被理解，也可以那么被理解，这种情况下，编译器可以选择一种让它实现简单的方式去实现。\r\n而代码最终是这样而不是那样，只是这种设计的体现。", "Konwledge_Point": "赋值运算", "Question": ["JAVA运算符优先级问题还有什么是入栈", ["int a=2 ; int b=a+3*a++ ;", "\nb的值为什么是8，a++不是先赋值后自+1吗 ", "\nb不是等于3+3*2吗最后结果不是9吗 ", "\n还有就是什么是入栈双目运算为什么先入栈啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;j等于1时&amp;#xff0c;看看k(1)等于多少&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["关于matlab循环的问题", ["想问大噶在j=1的时候这个循环的a数组怎么走的？数组不应该都是正整数吗？因为看的别人的代码但是最后运算结果是对的，a赋值为全为0的N*N数组，所以比较奇怪这个事情，答案谢谢大噶了！"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-html\"&gt;&lt;span class=\"hljs-meta\"&gt;&amp;lt;!DOCTYPE &lt;span class=\"hljs-keyword\"&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;html&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;lang&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;meta&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;charset&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;UTF-8&amp;#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Title&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;\n  &lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"language-css\"&gt;\n    &lt;span class=\"hljs-selector-id\"&gt;#box&lt;/span&gt; {\n      &lt;span class=\"hljs-attribute\"&gt;top&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;100px&lt;/span&gt;;\n      &lt;span class=\"hljs-attribute\"&gt;position&lt;/span&gt;: fixed;\n      &lt;span class=\"hljs-attribute\"&gt;width&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;100px&lt;/span&gt;;\n      &lt;span class=\"hljs-attribute\"&gt;height&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;100px&lt;/span&gt;;\n      &lt;span class=\"hljs-attribute\"&gt;background&lt;/span&gt;: red;\n      &lt;span class=\"hljs-attribute\"&gt;animation&lt;/span&gt;: move &lt;span class=\"hljs-number\"&gt;3s&lt;/span&gt; linear &lt;span class=\"hljs-number\"&gt;0s&lt;/span&gt; infinite alternate;\n    }\n    \n    &lt;span class=\"hljs-selector-class\"&gt;.stop&lt;/span&gt; {\n      &lt;span class=\"hljs-attribute\"&gt;animation-play-state&lt;/span&gt;: paused &lt;span class=\"hljs-meta\"&gt;!important&lt;/span&gt;;\n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;&amp;#64;keyframes&lt;/span&gt; move {\n      &lt;span class=\"hljs-selector-tag\"&gt;from&lt;/span&gt; {\n        &lt;span class=\"hljs-attribute\"&gt;left&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n      }\n      &lt;span class=\"hljs-selector-tag\"&gt;to&lt;/span&gt; {\n        &lt;span class=\"hljs-attribute\"&gt;left&lt;/span&gt;: &lt;span class=\"hljs-built_in\"&gt;calc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;100%&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;100px&lt;/span&gt;);\n      }\n    }\n  &lt;/span&gt;&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;style&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;button&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;id&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;btn&amp;#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;change animation&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;div&lt;/span&gt; &lt;span class=\"hljs-attr\"&gt;id&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;box&amp;#34;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=\"language-javascript\"&gt;\n  &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; box &amp;#61; &lt;span class=\"hljs-variable language_\"&gt;document&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;getElementById&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;box&amp;#39;&lt;/span&gt;)\n  &lt;span class=\"hljs-variable language_\"&gt;document&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;getElementById&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;btn&amp;#39;&lt;/span&gt;).&lt;span class=\"hljs-title function_\"&gt;addEventListener&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;click&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;function&lt;/span&gt; (&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (box.&lt;span class=\"hljs-property\"&gt;classList&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;contains&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;stop&amp;#39;&lt;/span&gt;)) {\n      box.&lt;span class=\"hljs-property\"&gt;classList&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;remove&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;stop&amp;#39;&lt;/span&gt;)\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n      box.&lt;span class=\"hljs-property\"&gt;classList&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;add&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;stop&amp;#39;&lt;/span&gt;)\n    }\n  })\n&lt;/span&gt;&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-tag\"&gt;&amp;lt;/&lt;span class=\"hljs-name\"&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["css平移如何中途暂停", ["我想知道css的平移动画如何暂停呢？我百度看说用", "\n", "animation-play-state", ":paused;\n\n", "\n", "的，但是我这个平移是动态的，没有办法写在", "@keyframes里啊", "我现在是在暂停的事件中获取下降的距离然后取消元素的平移属性，再把下降的距离赋给元素，但是这样会有一个问题就是当设备的运算处理能力不足时会看到一个明显的上拉动作（这里的上拉我知道是因为取消平移效果后元素会回到原来的位置，然后又赋值了新的距离，所以在运算能力不足的设备上这个上拉效果尤为明显）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;rUU&amp;#61;zeros(600,5,m)&lt;br /&gt;rc&amp;#61;zeros(5,3,m)&lt;br /&gt;for f&amp;#61;1:m&lt;br /&gt;[rUU(:,:,f)&amp;#xff0c;rc(:,:,f)]&amp;#61;F(k&amp;#xff0c;data)&lt;br /&gt;end&lt;br /&gt;这样写&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["matlab如何循环调用函数并把两个矩阵的结果存起来", ["首先我自定义了一个函数F，返回值[UU,c]，UU是一个600", "5的矩阵，c是5", "3的矩阵我想让这个函数循环m次，然后把UU和c的值存起来，之后还要在这m个UU和c上运算。", "但是我一直没有找到合适的方法，网上找到了一种，但是显示带有下标的赋值维度不匹配。", "\n", "一个m文件是：function [UU,c]= F(K,data)", "主函数调用：", "\n", "for f=1:m", "%     [U,center]=FCM_U(5,data);用这一句的话就能看到一次的UU和center", "    [UU(:,end+1),center(:,end+1)]=FCM_U(5,data);%显示带有下标的赋值维度不匹配。", "end", "请问应该怎样解决呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没有主方法&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["为什么编译不出，哪里有错？", ["   题目:为两个整形变量a,b赋值，并将a/b的运算结果输出。\n    ", "public", " ", "class", " Play{\n    ", "int", " a=", "12", ";\n", "int", " b=", "3", ";\n", "System", ".", "out", ".println(\"a=\"+ a +\",b=\"+b);\n", "System", ".", "out", ".println(\"a/b=\"+(a/b));\n", "System", ".", "out", ".println(\"a/b=\"+(", "float", ")a/b);\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇文章&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/weixin_51526796/article/details/117997156\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;数据结构顺序表的基本操作—插入&lt;/font&gt;&lt;/a&gt; 也许能够解决你的问题&amp;#xff0c;你可以看下&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "赋值运算", "Question": ["顺序表基本操作(对插入删除的操作）", ["实现线性表中数据的插入、删除功能。", "顺序表的定义如下：", "typedef struct", "{", "    ElemType *elem;", "    int length;", "} seqList;", "对顺序表的操作，可以使用指针形式，也可以使用数组下标形式：", "如定义了顺序表  seqList   sl;", "可以使用：", "*(sl.elem+1) = x;", "给指针的指向赋值为x。 指针的加法是寻址，elem+i 即跳过i个数据单元。", "或者", " sl.elem[1] = x;", " 因为[]是运算符，等同于指针运算"]], "Tag": "程序设计"}
{"Answer": "哦，原来，那块内存现在被ps所指。", "Konwledge_Point": "赋值运算", "Question": ["C++ primer 第三版中的一个小问题", ["在原书453~455页有这样一段代码，是用来写拷贝赋值函数的。", "\nHasPtr& HasPtr::operator=(const HasPtr &rhs)", "\n{", "\n                    auto newp = new string(*rhs.ps);    //拷贝底层string", "\n                    delete ps;    //释放旧内存", "\n                    ps = newp;   //从右侧运算对象拷贝数据到本对象", "\n                    i = rhs.i;", "\n                    return *this;   //返回本对象", "\n}", "\n这个函数中，用new申请了一段内存，为什么在离开是没有delete掉呢？", "\nauto在这里应该不会把newp定义为一个shared ptr 智能指针对象吧？求解..."]], "Tag": "程序设计"}
{"Answer": "你的xxx2（test1,test2）给xxx2输入的两个形参是两个线程（test1，test2）。自然不是你想要的结果。\r\n\r\n改成：\r\nimport time,threading\r\n\r\nl1=[]\r\nl2=[]\r\n\r\ndef xxx(a,b,l):\r\n  x = a+b\r\n  print(x)\r\n  l.append(x)\r\n\r\ndef xxx2(c,d):\r\n  x2 = c-d\r\n  print(x2)\r\n  return x2\r\n\r\n\r\ntest1 = threading.Thread(target=xxx,args=(100,200,l1))\r\ntest2 = threading.Thread(target=xxx,args=(100,100,l2))\r\n\r\ntest1.start()\r\ntest2.start()\r\ntest1.join()\r\ntest2.join()\r\n\r\n\r\nxxx2(l1[0],l2[0]) \r\n\r\n\r\n通过两个list来传递线程的执行结果，这样就能把线程的返回值传递出来。", "Konwledge_Point": "赋值运算", "Question": ["python threading多线程的一个小问题。", ["在使用threading 多线程的时候遇到个小问题，正常情况的执行，函数返回结果可以赋值给变量，然后用另一个函数来引用这个变量。但多线程时，赋值给变量的变成这个线程本身，并非函数运行的结果。  有什么办法在使用多线程，又可以正常让函数运算结果赋予给变量。谢谢", "\n\n", "import time,threading\n\ndef xxx(a,b):\n  x = a+b\n  print(x)\n  return x\n\ndef xxx2(c,d):\n  x2 = c-d\n  print(x2)\n\n# 正常需要实现功能\ntest1 = xxx(100,200)\ntest2 = xxx(100,100)\nxxx2(test1,test2)\n\n# 通过多线程来实现：\ntest1 = threading.Thread(target=xxx,args=(100,200))\ntest2 = threading.Thread(target=xxx,args=(100,100))\n\ntest1.start()\ntest2.start()\ntest1.join()\ntest2.join()\n\n#此处类型报错，线程本身不支持xx2函数内的减法\nxxx2(test1,test2) \n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff01;点击该回答右侧的“采纳”按钮即可采纳&amp;#xff01;&amp;#xff01;&lt;br /&gt;下面是代码&amp;#xff0c;希望可以给我采纳呀&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;BEGIN&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i&amp;#61;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n{\ns&amp;#61;(LinkNode*)malloc(sizeof(LinkNode)); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建新结点\ns-&amp;gt;data&amp;#61;a[i]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;赋值\ns-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;&amp;#61;L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;插入头结点之后\nL-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;&amp;#61;s; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改头结点的指针\n}\n&lt;span class=\"hljs-keyword\"&gt;END&lt;/span&gt;\n\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["用头插法创建单链表补充begin与end的内容", ["问题遇到的现象和发生背景", "\n", "1、使用头插法创建单链表，补充BEGIN-END之间的内容。", "//单链表基本运算算法", "typedef struct LNode", "{", "    int data;", "    struct LNode *next;        //指向后继结点", "} LinkNode;                    //声明单链表结点类型", "void CreateListF(LinkNode *&L,int a[],int n)", "//头插法建立单链表", "{", "    LinkNode *s;", "    L=(LinkNode *)malloc(sizeof(LinkNode));      //创建头结点", "    L->next=NULL;", "/", "BEGIN", "/创建n个s节点并为每个节点赋值，然后插入头结点之后", "\n", "/", "END", "/", "}", "\n", "操作环境、软件版本等信息", "\n", "尝试过的解决方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "思路是没问题，但是你没有初始化sum，结果就会错。\r\n简单地说就是 int sum=0;\r\n改一下就好", "Konwledge_Point": "赋值运算", "Question": ["Digital Roots 题目大意将输入的正整数的各个数相加", ["题目如下", "\nThe digital root of a positive integer is found by summing the digits of the integer. If the resulting value is a single digit then that digit is the digital root. If the resulting value contains two or more digits, those digits are summed and the process is repeated. This is continued as long as necessary to obtain a single digit. ", "\nFor example, consider the positive integer 24. Adding the 2 and the 4 yields a value of 6. Since 6 is a single digit, 6 is the digital root of 24. Now consider the positive integer 39. Adding the 3 and the 9 yields 12. Since 12 is not a single digit, the process must be repeated. Adding the 1 and the 2 yeilds 3, a single digit and also the digital root of 39. ", "\n\n", "输入 ", "\n\n", "The input file will contain a list of positive integers, one per line. The end of the input will be indicated by an integer value of zero. ", "\n\n", "输出 ", "\n\n", "For each integer in the input, output its digital root on a separate line of the output. ", "\n\n", "样例输入 ", "\n\n", "24 ", "\n39 ", "\n0 ", "\n\n", "样例输出 ", "\n\n", "6 ", "\n3 ", "\n\n", "我的思路是 ", "\n1.将sum各位数字加起来，赋值sum", "\n2.判断sum是否是个位数，如果不是，转1", "\n3是个位数，输出结果，运算结束", "\nsum%9的结果和整个数模9的结果相同，用来运算各个书之和。以下是我的代码。思路看起来没问题，但是运行结果和想象的不一样。", "\n\n", " #include <stdio.h>\nint main()\n{\n    char ch;\n    while(1){  //计算各位数字的和\n    int sum;\n    while(scanf(\"%c\",&ch) && ch!='\\n'){\n        sum+=ch-'0';\n        }\n    if (sum==0) break;\n    //模9运算求根\n    if(sum%9==0) sum=9;\n    else sum=sum%9;\n    printf(\"%d\\n\",sum);\n    }\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "你确认就这几条记录？看存储过程没什么问题，是不是这个触发器逻辑有问题，存储过程重复执行了", "Konwledge_Point": "赋值运算", "Question": ["关于SQL server 2008时间差datediff函数计算问题", ["如题，我设置了个触发器，每当table4插入的数据符合触发器条件时，则执行名字为", "\ntable5-insert的存储过程，在此存储过程里，包含了时间差datediff的运算过程和赋值，还有数据的更新和叠加，时间段if条件判断语句等，", "\n\n", "问题的重点来了：时间差的运算出了问题，我的时间差算法是最新一条的0状态记录machine-itime减去非0状态记录的ng-itime，得出来的时间差值赋值到对应的字段，如果有旧数据记录，则进行数据叠加记录下来。", "\n\n", "可是不知道为什么，时间差运算出来的结果有时候是正常，确确实实只相差几秒，但有时候是几百秒的甚至几万秒", "\n没搞懂为什么会有这种状况，我把图发上来让大神和大佬们更好理解我的问题~！", "\n\n", "这个是table4插入数据的图,可以很明显的知道,第一次的时间差，两个数据记录相减，得出来的时间差是3秒，第二次的时间差，两个数据记录相减，得出来的时间差是4秒", "\n\n", "可是，计算出来的结果很有问题，时好时坏的那种，现在我贴图把计算出来的结果给你们看下", "\n这个是第一次进行的时间差数据，没错，是3秒，并且添加进去了", "\n\n", "这个是第二次进行的时间差数据，由table4看出，明明只影响了4秒，可结果是这样的！！！", "\n\n", "不知道为何无缘无故变成了91秒，如果再有时间差数据插进来，进行叠加的话，计算出来的数值结果有时候是叠加对的，也有时候像刚刚那种情况，叠加个几十，几百秒进去", "\n\n", "请问为什么会发生这样的情况，我真的没搞懂，我用的也是SS单位来计算的，如果换成MI单位计算的话，就不会有这种异常数值结果情况发生了，但是不是每个错误代码类型（即location+pointer连起来就是一个错误代码类型）都是能够持续1分钟以上的，多数都是只影响几秒或几十秒，求各路SQL server大神或大佬来帮忙看看我的问题，顺便留下我的QQ:584958184，希望能解决这个问题~ 感谢大家~！！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码看着没啥问题。&lt;br /&gt;例化led时&amp;#xff0c;可以代入CNT_MAX参数&amp;#xff0c;这个参数的值改小点led流水就快&amp;#xff0c;改大流水就慢。相当于延时时间了&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["大家好，下面是我对于一个问题的Verilog编码，大家能帮我看看有什么问题吗？还有，如何在程序中设定延时时间？", ["题目：", "流水灯设计（有两种以上设计方案）", "设计要求：控制8只LED灯，周而复始地从LED1~LED8，延时点亮，产生流水效果。需设定合适的延时时间：延时时间太短，由于人眼视觉暂留，看到的是8个LED同时点亮；延时时间太长，8个LED断续点亮，没有流水的效果。比较各种设计方案。", "输入：clk，//内部时钟", "输出：【7：0】LEDS，//控制实验板上8个LED灯", "\n", "代码：", "module led", "#(", "  parameter CNT_MAX = 25'd24_999_999   //声明计数最大值参数，24999999二进制为25位", ")", "(", "input wire       sys_clk,", "input wire       sys_rst_n,", "\n", "output reg [8:0] LEDS   //端口列表", ");", "reg [24:0] cnt;", "reg cnt_flag;      //声明寄存器", "\n", "always", "@(posedge ", "sys_clk or negedge sys_rst_n)     //计数器赋值", "    if(sys_rst_n == 1'b0)", "        cnt <= 25'd0;", "     else if (cnt == CNT_MAX)", "        cnt <= 25'd0;", "     else", "        cnt <= cnt + 25'd1;", "\n", "always", "@(posedge ", "sys_clk or negedge sys_rst_n)    //脉冲标志信号赋值", "    if(sys_rst_n == 1'b0)", "         cnt_flag <= 1'b0;", "     else if (cnt == (CNT_MAX - 25'd1 ))", "         cnt_flag <= 1'b1;", "     else", "         cnt_flag <= 1'b0;", "\n", "always", "@(posedge ", "sys_clk or negedge sys_rst_n)  //输出信号赋值", "    if(sys_rst_n == 1'b0)", "         LEDS <= 8'b11111110", "     else if(cnt_flag == 1'b1)", "     LEDS <= {LEDS[6:0],LEDS[7]};   //拼接运算符（例如上一状态为11111110，现状态为11111101，将上一状态的后七位110放在现状态的前七位，", "     else                                    //上一状态的第一位1放在现状态的最后一位，再将1111110与1进行拼接运算，即可得到现状态11111101）", "         LEDS <=  LEDS;", "\n", "endmodule"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;main函数里&amp;#xff0c;你定义了int 和 clock_t两个不同类型的f&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["重定义，不同的基类型，孩子不会啊", ["\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#define N 100\nint suyang()\n{\n\nFILE *fp;                                             //定义一个文件指针，用于之后对文件的操作\nfp=fopen(\"D:\\\\record.txt\",\"a+\");\nint scord=0;\nint a,c, e,i,b,k;\nint z[10];                                         //定义一个长度为10的数组，元素值为0-3的随机数，0-3分别对应一种运算\nint jia=0,jian=0,cheng=0,chu=0;\nint l=10;\nsrand( (unsigned)time( NULL ) );                      //用于产生随机数的时间种子\nwhile(1)                                              //死循环，不断给数组赋值，直到满足条件后结束循环\n{\n\nfor(int y=0;y<=9;y++)\n{\nc=rand()%4;\nif(l==c)                                        //判断本次产生的c是否与上次相同\n{\ny--;\ncontinue;\n}\nz[y]=c;\nif(c==0)\njia++;\nelse if(c==1)\njian++;\nelse if(c==2)\ncheng++;\nelse\nchu++;\nl=c;                                         //将c的值付给l，用于判断下次产生的c是否与本次相同\n}\nif(jia&&jian&&cheng&&chu!=0)                       //判断是否有运算出现的次数为0，无则结束循环，有则继续循环\n{\n\nfor(int v=0;v<=9;v++)\n{\n}\nbreak;\n}\n}\n\nfor(a=0;a<=9;a++)                                    //产生运算\n{\n\ni=rand()%100;\nb=rand()%100;\nswitch(z[a])\n{\ncase 0:e=i+b;\nif(e>100||e<0)                               //保证结果在0-100之间\n{\na--;                                       //若不满足要求，则结束本次循环，重新开始产生i和b\ncontinue;\n}\nprintf(\"%d+%d=\",i,b);\nfprintf(fp,\"%d+%d=%d\\n\",i,b,e );                 //将产生的运算和正确答案存入文件\nbreak;\ncase 1:e=i*b;\nif(e>100||e<0)                       \n{\na--;\ncontinue;\n}\nprintf(\"%d*%d=\",i,b);\nfprintf(fp,\"%d*%d=%d\\n\",i,b,e );                  //将运算式及结果记录到文件中\nbreak;\ncase 2:e=i-b;\nif(e>100||e<0)\n{\na--;\ncontinue;\n}\nprintf(\"%d-%d=\",i,b);\nfprintf(fp,\"%d-%d=%d\\n\",i,b,e );\nbreak;\ncase 3:e=i/b;\nif(i%b!=0||e>100||e<0)                            //保证可以整除\n{\na--;\ncontinue;\n}\nprintf(\"%d/%d=\",i,b);\nfprintf(fp,\"%d/%d=%d\\n\",i,b,e );\nbreak;\n}\n\nscanf(\"%d\",&k);\nif(k==e)\nscord+=10;\nfprintf(fp,\"你的答案是：%d\\n\",k);                         //将用户输入的答案存入文件\n}\nprintf(\"得分：%d分\\n\",scord);\n\n\nfprintf(fp,\"得分：%d分\\n\", scord);                     //将用户得分存入文件\n\nfclose(fp);\nreturn 0;\n}\nint main()\n{\nint i,z,d,f;\nFILE *fp;\nchar str[N + 1];\ndouble  duration;\nclock_t start,f;\n}", "\n\n", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Mi&lt;/span&gt; {\n&lt;span class=\"hljs-comment\"&gt;/*类Mi\n  成员变量 double型diShu,zhiShu\n  含参构造方法Mi(double a,double b)\n  输出方法shuChu(),按幂的形式输出结果&amp;#xff0c;如 2^4\n  获取底数方法getDiShu(),返回幂的底数\n  获取指数方法getZhiShu(),返回幂的指数\n  muti(Mi r) 计算同底数幂的乘法&amp;#xff0c;指数相加&amp;#xff1b;底数不同&amp;#xff0c;报错\n  div(Mi r) 计算同底数幂的除法&amp;#xff0c;指数相减&amp;#xff1b;底数不同&amp;#xff0c;报错\n  power(Mi r) 计算同底数幂的乘方\n*/&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//---begin---&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//【代码】声明double型变量diShu,zhiShu&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; diShu;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; zhiShu;\n\n&lt;span class=\"hljs-comment\"&gt;//【代码】含参构造方法&amp;#xff0c;将参数赋值给变量diShu,zhiShu&lt;/span&gt;\n\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Mi&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; diShu, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; zhiShu&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.diShu &amp;#61; diShu;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.zhiShu &amp;#61; zhiShu;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getDiShu&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; diShu;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getZhiShu&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; zhiShu;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;shuChu&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (diShu &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.print(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (zhiShu &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.print(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (diShu &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; zhiShu &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.print(&lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;#43; diShu &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &amp;#43; zhiShu);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (diShu &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; zhiShu &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.print(diShu &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;#43; zhiShu &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (zhiShu &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; diShu &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.print(&lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;#43; diShu &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;#43; zhiShu &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.print(diShu &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;^&amp;#34;&lt;/span&gt; &amp;#43; zhiShu);\n    }\n\n    &lt;span class=\"hljs-function\"&gt;Mi &lt;span class=\"hljs-title\"&gt;muti&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;Mi r&lt;/span&gt;)&lt;/span&gt; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//同底数幂的乘法运算&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// 同底数幂相乘&amp;#xff0c;底数不变&amp;#xff0c;指数相加&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Mi(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.getDiShu(), &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.getZhiShu() &amp;#43; r.getZhiShu());\n    }\n\n\n    &lt;span class=\"hljs-function\"&gt;Mi &lt;span class=\"hljs-title\"&gt;div&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;Mi r&lt;/span&gt;)&lt;/span&gt; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//同底数幂的除法运算&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// 同底数幂相乘&amp;#xff0c;底数不变&amp;#xff0c;指数相减&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Mi(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.getDiShu(), &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.getZhiShu() - r.getZhiShu());\n    }\n\n    &lt;span class=\"hljs-function\"&gt;Mi &lt;span class=\"hljs-title\"&gt;power&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; r&lt;/span&gt;)&lt;/span&gt; {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//同底数幂的乘方运算&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;// 幂的乘方&amp;#xff0c;底数不变&amp;#xff0c;指数相乘&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Mi(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.getDiShu(), &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.getZhiShu() * r);\n    }\n}\n\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;MainClass&lt;/span&gt; {\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {\n        Mi r1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Mi(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;);\n        Mi r2 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Mi(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; r &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;幂的乘法&amp;#34;&lt;/span&gt;);\n        Mi Result &amp;#61; r1.muti(r2);\n        Result.shuChu();\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n幂的除法&amp;#34;&lt;/span&gt;);\n        Result &amp;#61; r1.div(r2);\n        Result.shuChu();\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n幂的乘方&amp;#34;&lt;/span&gt;);\n        Result &amp;#61; r1.power(r);\n        Result.shuChu();\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["java幂的类封装怎么补充代码", ["class", " ", "Mi", " {\n", "/*类Mi\n  成员变量 double型diShu,zhiShu\n  含参构造方法Mi(double a,double b)\n  输出方法shuChu(),按幂的形式输出结果，如 2^4\n  获取底数方法getDiShu(),返回幂的底数\n  获取指数方法getZhiShu(),返回幂的指数\n  muti(Mi r) 计算同底数幂的乘法，指数相加；底数不同，报错\n  div(Mi r) 计算同底数幂的除法，指数相减；底数不同，报错\n  power(Mi r) 计算同底数幂的乘方\n*/", "\n", "double", " diShu,zhiShu;\n", "//---begin---", "\n\n", "//【代码】声明double型变量diShu,zhiShu", "\n\n \n", "//【代码】含参构造方法，将参数赋值给变量diShu,zhiShu", "\n \n", "double", " ", "getDiShu", "(", ")", " {\n    ", "return", " diShu;\n}\n", "double", " ", "getZhiShu", "(", ")", " {\n    ", "return", " zhiShu;\n}\n\n", "void", " ", "shuChu", "(", ")", " {\n    ", "if", "(diShu==", "0", ") \n        System.", "out", ".print(", "0", ");    \n    ", "else", " ", "if", "(zhiShu==", "0", ")\n        System.", "out", ".print(", "1", ");    \n    ", "else", " ", "if", "(diShu<", "0", "&&zhiShu>", "0", ")\n        System.", "out", ".print(", "\"(\"", "+diShu+", "\")\"", "+", "\"^\"", "+zhiShu);\n    ", "else", " ", "if", "(diShu>", "0", "&&zhiShu<", "0", ")\n        System.", "out", ".print(diShu+", "\"^\"", "+", "\"(\"", "+zhiShu+", "\")\"", ");    \n    ", "else", " ", "if", "(zhiShu<", "0", "&&diShu<", "0", ")\n        System.", "out", ".print(", "\"(\"", "+diShu+", "\")\"", "+", "\"^\"", "+", "\"(\"", "+zhiShu+", "\")\"", ");\n    ", "else", "\n        System.", "out", ".print(diShu+", "\"^\"", "+zhiShu);\n}\n\n", "Mi ", "muti", "(", "Mi r", ")", " {", "//同底数幂的乘法运算", "\n \n}\n\n\n", "Mi ", "div", "(", "Mi r", ")", " {", "//同底数幂的除法运算", "\n \n}\n\n", "Mi ", "power", "(", "double", " r", ")", " {", "//同底数幂的乘方运算 ", "\n \n \n}\n}\n \n  \n", "public", " ", "class", " ", "MainClass", " {\n\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String[] args", ")", " { \n        Mi r1=", "new", " Mi(", "4", ",", "4", ");\n        Mi r2=", "new", " Mi(", "4", ",", "2", ");\n        ", "double", " r=", "3", ";\n        System.", "out", ".println(", "\"幂的乘法\"", ");\n        Mi Result=r1.muti(r2);\n        Result.shuChu();\n        System.", "out", ".println(", "\"\\n幂的除法\"", ");\n        Result=r1.div(r2);\n        Result.shuChu();\n        System.", "out", ".println(", "\"\\n幂的乘方\"", ");\n        Result=r1.power(r); \n        Result.shuChu();\n    }\n\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;两处问题见注释&amp;#xff0c;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sum&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *c,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; z;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];  &lt;span class=\"hljs-comment\"&gt;//int a[z];  数组的大小必须是常量 修改&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; total;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;b);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;z&amp;lt;b;z&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;a[z]);\n\n    }\n    total &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;(a,b);&lt;span class=\"hljs-comment\"&gt;//调用函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,total);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sum&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *c,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sum1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;// int sum1;  修改 sum1需初始化&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        sum1 &amp;#61; *c &amp;#43;  sum1;\n        c&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sum1;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["解决新数组求和问题的代码出现bug", ["新数组求和", "思考的问题是 ：", "牛牛学习了指针相关的知识，想实现一个 int cal(int *array,int n) 的函数求出长度为 n 的数组的和。", "输入描述：", "第一行输入一个正整数 n ，表示数组的长度", "第二行输入 n 个正整数，表示数组中每个数字的值", "输出描述：", "实现 int cal(int *array,int n) 求出数组array的和。", "这个问题来自于牛客网，我在写码的过程中发现，如果直接将数组及其每个元素在主函数中定义出来（也就是把数组赋完值），并执行，则可以准确算出结果；但是如果使用scanf函数，在小窗口中输入 该数组的元素总个数 和n个正整数时，则会出现无法运算的情况。", "我使用 5（数组长度）和 1   2  2  2  3 这几个数进行测试的时候，发现执行结果为1；而输入 2 2  2   2  2  ，则结果为4。", "\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "sum", "(", "int", " *c,", "int", " n)", ";\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " z;", "//作为数组a的下标", "\n    ", "int", " a[z];\n    ", "int", " b;", "//实际参数，数组元素的数量", "\n    ", "int", " total;", "//数组元素相加总和", "\n    ", "scanf", "(", "\"%d\"", ",&b);", "//有几个 元素参加运算", "\n    \n   ", "for", "(z=", "0", ";z<b;z++)\n    {\n        ", "scanf", "(", "\"%d\"", ",&a[z]);", "// 给数组循环赋值", "\n        \n    }\n    total = ", "sum", "(a,b);", "//调用函数，并接受函数返回的数值", "\n    ", "printf", "(", "\"%d\"", ",total);\n    ", "return", " ", "0", ";\n}\n", "int", " ", "sum", "(", "int", " *c,", "int", " n)", "//调用函数模块 ,数组名a将地址发给指针c，然后数组中元素的总数 是n个", "\n", "{\n    ", "int", " sum1;", "//sum函数中 计算之和", "\n    ", "for", "(", "int", " i=", "0", ";i<n;i++)\n    {\n        sum1 = *c +  sum1;\n        c++;", "//指针 地址加一", "\n    }\n    ", "return", " sum1;\n}\n\n", "\n", "。", "\n", "。", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "兩個FOR循环是逐位相乘 [a,b,c]*[d,e,f] 會等於 [ad,ae,af],[bd,be,bf]....等等的組合,然後再错位相加\r\n下面的那個for就是处理进位,在result[index]的數除10儲在carry中\r\nresult赋值那句，长度+3,是為了給result更多的位置去儲存兩個FOR循环逐位相乘出來的數", "Konwledge_Point": "赋值运算", "Question": ["关于C#的大数乘法问题", ["public static string Multiply(string num1, string num2)", "\n        {", "\n            int carry;", "\n            int[] result;", "\n            int[] multiplicand, multiplier;", "\n\n", "        multiplicand = Reverse(num1);\n        multiplier = Reverse(num2);//这两条代码实现字符串反转，并变成数组形式\n\n        //存储大数相乘后的结果\n        result = new int[multiplicand.Length + multiplier.Length + 3];\n        //两层循环，完成大数乘法运算逐位相乘，然后错位相加\n        for (int indexMplier = 0; indexMplier < multiplier.Length; indexMplier++)\n        {\n            for (int indexMplicand = 0; indexMplicand < multiplicand.Length; indexMplicand++)\n            {\n                result[indexMplier + indexMplicand] +=\n                    multiplicand[indexMplicand] * multiplier[indexMplier];\n            }\n        }  \n        //处理进位\n        for (int index = 0; index < result.Length; index++)\n        {\n            carry = result[index] / 10;\n                   result[index] = result[index] % 10;\n\n            if (carry > 0)\n            {\n                result[index + 1] += carry;\n            }\n        }\n\n        //将结果反转，返回\n        return Reverse(result);\n    }\n}\n    两个for循环都表示什么意思？还有result赋值那句，长度为啥+3？\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/23759793525616.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["待有缘人（将会是长期陪伴）", ["问题遇到的现象和发生背景", "\n", "将123分别赋值xyz", "\n", "问题相关代码，请勿粘贴截图", "\n", "//体会五种输入方法", "    {", "    int x,y,z;", "    printf(\"The first method:\\n\");scanf(\"x=%d,y=%d,z=%d\",&x,&y,&z);", "    printf(\"x=%d,y=%d,z=%d\\n\",x,y,z);", "\n", "printf", "(", "\"The second method:\\n\"", ");scanf(", "\"%d%d%d\"", ",&", "x", ",&", "y", ",&z);\n", "printf", "(", "\"x=%d,y=%d,z=%d\\n\"", ",", "x", ",", "y", ",z);\n\n", "printf", "(", "\"The third method:\\n\"", ");scanf(", "\"%d %d %d\"", ",&", "x", ",&", "y", ",&z);\n", "printf", "(", "\"x=%d,y=%d,z=%d\\n\"", ",", "x", ",", "y", ",z);\n\n", "printf", "(", "\"The fouth method:\\n\"", "); scanf(", "\"%d %d %d \"", ",&", "x", ",&", "y", ",&z);\n", "printf", "(", "\"x=%d,y=%d,z=%d\\n\"", ",", "x", ",", "y", ",z);\n\n", "printf", "(", "\"The fifth method:\\n\"", ");scanf(", "\"%d%d%d\\n\"", ",&", "x", ",&", "y", ",&z);\n", "printf", "(", "\"x=%d,y=%d,z=%d\\n\"", ",", "x", ",", "y", ",z);\n ", "return", " ", "0", ";}\n", "\n", "运行结果及报错内容", "\n", "不理解每个输入输出，希望得到运算截图", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;unsigned char cap[6] &amp;#61; {&amp;#39;1&amp;#39;,&amp;#39;5&amp;#39;,&amp;#39;.&amp;#39;,&amp;#39;5&amp;#39;,&amp;#39;6&amp;#39;,&amp;#39; &amp;#39;};前面的unsigned去掉。&lt;br /&gt;UART1_Send_Array函数改成下面的试试&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;void &lt;span class=\"hljs-constructor\"&gt;UART1_Send_Array(&lt;span class=\"hljs-params\"&gt;char&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;send_array&lt;/span&gt;[],&lt;span class=\"hljs-params\"&gt;short&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;num&lt;/span&gt;)&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//两个参数 一是数组(的数据) 二是数组长度1-255 &lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;//串口发送&lt;/span&gt;\n    short i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//定义一个局部变量  用来 发送字符串 &amp;#43;&amp;#43;运算&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i!&amp;#61;num)\n    {\n        &lt;span class=\"hljs-constructor\"&gt;USART_SendData(USART1,&lt;span class=\"hljs-params\"&gt;send_array&lt;/span&gt;[&lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;])&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//经过库函数  发送数据&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;( &lt;span class=\"hljs-constructor\"&gt;USART_GetFlagStatus(USARTx,USART_FLAG_TXE)&lt;/span&gt;!&amp;#61;RESET);  \n        i&amp;#43;&amp;#43;;  &lt;span class=\"hljs-comment\"&gt;//值 加一         &lt;/span&gt;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["STM32串口发送一个字符型数组上位机接受的是乱码", ["问题遇到的现象和发生背景", "\n", "大致就是想要通过stm32将ad芯片转换的电容数值先存入一个叫cap【】的数组中（比如电容值为84.96，处理过后转为字符8 4  9 6 存入cap【6】中）正点原子的上位机接受的是显示如下图，我想让他在上位机上显示84.96，这是为什么呢？恳求各位巨佬解惑", "\n", "问题相关代码，请勿粘贴截图", "\n", "float", " cap_val = ", "0.0f", ";\n", "unsigned", " ", "char", " cap[", "6", "] = {", "'1'", ",", "'5'", ",", "'.'", ",", "'5'", ",", "'6'", ",", "' '", "};\n", "unsigned", " ", "int", " capsw,capgw,capzs,capxs1,capxs2;\n", "int", " ", "main", "(", "void", ")", "\n", "{\n cap_reszult0 = ", "0x1b3011", ";                         ", "//这里直接给测量值赋值了，测量部分和一些不影响的代码就没有贴上来无关就没贴上来", "\n        cap_temp = ", "0x1fffff", ";\ncap_val = (", "double", ")cap_reszult0/(", "double", ")cap_temp;", "//0.8496 为C0/C1的比值", "\n        cap_val = cap_val*", "100", ";", "//84.96 cap_val 为待测电容的容值？100为基准电容容值", "\n\n        capzs = (", "unsigned", " ", "int", ")cap_val;\n        capsw = capzs/", "10", ";\n        capgw = capzs%", "10", ";\n\n        cap_val = cap_val - capzs;\n        cap_val = cap_val*", "100", ";\n        capzs = (", "unsigned", " ", "int", ")cap_val;\n        capxs1 = capzs/", "10", ";\n        capxs2 = capzs%", "10", ";\n\n        cap[", "0", "] = capsw + ", "'0'", ";\n        cap[", "1", "] = capgw + ", "'0'", ";\n        cap[", "3", "] = capxs1 + ", "'0'", ";\n        cap[", "4", "] = capxs2 + ", "'0'", ";\n        \n\n", "UART1_Send_Array", "(cap,", "6", ");\n}\n", "void", " ", "UART1_Send_Array", "(", "unsigned", " ", "char", " send_array[],", "unsigned", " ", "char", " num)", " ", "//两个参数 一是数组(的数据) 二是数组长度1-255 ", "\n", "{\n        ", "//串口发送", "\n        ", "unsigned", " ", "char", " i=", "0", ";  ", "//定义一个局部变量  用来 发送字符串 ++运算", "\n\n\n        ", "while", "(i!=num)\n        {\n                \n               ", "USART_SendData", "(USART1,send_array[i]);", "//经过库函数  发送数据", "\n                ", "while", "( ", "USART_GetFlagStatus", "(USARTx,USART_FLAG_TXE)==RESET);  \n            i++;  ", "//值 加一         ", "\n        }\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "本人究极小白，描述肯定很不贴切，贴的东西可能不够精准，需要补充的话可以后续贴上去，恳请各位巨佬能够指导一下该怎么做呢？", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n//定义结构体类型Range\ntypedef struct _Range {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;start&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;;\n} Range;\n//获得结构体变量的函数&amp;#xff1a;它表示一个数组中的区间&amp;#xff0c;由起始点和结束点构成\nRange new_Range(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; e) {\n    Range r;\n    r.start &amp;#61; s;\n    r.end &amp;#61; e;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; r;\n}\n//将x指向的元素和y指向的元素交换顺序&amp;#xff1a;如果基准点左侧某个元素大于基准点且右侧有一个元素小于基准点&amp;#xff0c;交换这两个元素\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; swap(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *x, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *y) {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t &amp;#61; *x;\n    *x &amp;#61; *y;\n    *y &amp;#61; t;\n}\n//快速排序的方法\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; quick_sort(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[], const &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len) {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (len &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;; // 避免len等於負值時引發段錯誤&amp;#xff08;Segment Fault&amp;#xff09;&amp;#xff0c;排除要排序的数组的元素个数为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;或负值\n    //技巧&amp;#xff1a; r[]模擬列表,p為數量,r[p&amp;#43;&amp;#43;]為push&amp;#xff08;它先使用,r[&lt;span class=\"hljs-comment\"&gt;--p]為定位到前一个元素并取出该元素&lt;/span&gt;\n    Range r[len];//声明待排序数组的元素区间组成的数组&amp;#xff0c;区间个数等于要排序的数组\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;//区间数组的初始索引为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    r[p&amp;#43;&amp;#43;] &amp;#61; new_Range(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);//表示要排序数组从第一个元素到最后一个元素的索引区间&amp;#xff0c;并存入区间数组\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p) {//如果有一个及以上的区间就进入循环直到没有区间循环终止\n        Range range &amp;#61; r[&lt;span class=\"hljs-comment\"&gt;--p];//取出刚存入的待排数组地元素区间&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (range.&lt;span class=\"hljs-keyword\"&gt;start&lt;/span&gt; &amp;gt;&amp;#61; range.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;//但元素区间起始索引大于终了索引&amp;#xff0c;这个区间无效&amp;#xff0c;继续使用下一个元素区间&amp;#xff1b;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; mid &amp;#61; arr[(range.&lt;span class=\"hljs-keyword\"&gt;start&lt;/span&gt; &amp;#43; range.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;) / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;/* 取出该有效元素区间地中间值对应地元素的值作为基准&amp;#xff0c;\n        该基准将元素区间划分成左右两部分*/&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; left &amp;#61; range.&lt;span class=\"hljs-keyword\"&gt;start&lt;/span&gt;, right &amp;#61; range.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;/*有效元素区间的起始值作为左部序列的开始元素索引\n        有效元素区间的终了值作为右部序列的结束元素的索引*/&lt;/span&gt;\n\n        &lt;span class=\"hljs-keyword\"&gt;do&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (arr[left] &amp;lt; mid) &amp;#43;&amp;#43;left;   &lt;span class=\"hljs-comment\"&gt;/*对基准点左部的元素向右扫描直到左部序列的某个元素大于基准点&amp;#xff0c;\n            这样就将小于基准的元素集中在元素区间的左部&amp;#xff0c;left是向右移动的指针*/&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (arr[right] &amp;gt;&amp;#61; mid) &lt;span class=\"hljs-comment\"&gt;--right; /*对基准点右部的元素向左扫描直到右部序列的某个元素小于基准点&amp;#xff0c;&lt;/span&gt;\n            将大于或等于基准的元素集中在元素区间的右部&amp;#xff0c;right是向左移动的指针*/\n \n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (left &amp;lt;&amp;#61; right)&lt;span class=\"hljs-comment\"&gt;/*当左部序列扫描结束之时的元素依然在右部序列扫描结束之时的元素之前*/&lt;/span&gt;\n            {\n                swap(&amp;amp;arr[left],&amp;amp;arr[right]);//将左部序列扫描结束之时的元素和右部序列扫描结束之时的元素进行交换\n                left&amp;#43;&amp;#43;;right&lt;span class=\"hljs-comment\"&gt;--;               /*接着向右扫描左部序列&amp;#xff0c;向左扫描右部序列&amp;#xff0c;重复上面的步骤*/ &lt;/span&gt;\n            }\n        } &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (left &amp;lt;&amp;#61; right);&lt;span class=\"hljs-comment\"&gt;/*向右扫描左部序列和向左扫描右部序列直到相遇&amp;#xff1a;相同索引的元素交换彼此的值&amp;#xff1b;之后向\n        右扫描到了右部序列&amp;#xff0c;向左扫描到了左部序列&amp;#xff0c;基准点左部的各元素都小于它&amp;#xff0c;右部的的各元素都大于等于它&amp;#xff0c;循环结束*/&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (range.&lt;span class=\"hljs-keyword\"&gt;start&lt;/span&gt; &amp;lt; right) r[p&amp;#43;&amp;#43;] &amp;#61; new_Range(range.&lt;span class=\"hljs-keyword\"&gt;start&lt;/span&gt;, right);&lt;span class=\"hljs-comment\"&gt;/*上面的工作完成之后&amp;#xff0c;right指针\n        遇到left或者right再left左边紧邻&amp;#xff1b;只是现在将原来元素区间的起始点和right指针现在的位置构成新的元素区间&amp;#xff0c;\n        然后通过一个基准点划分该区间为左部和右部&amp;#xff0c;使得左部序列的元素小于右部序列的元素\n        */&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (range.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt; &amp;gt; left) r[p&amp;#43;&amp;#43;] &amp;#61; new_Range(left, range.&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;/*上面的工作完成之后&amp;#xff0c;left指针\n        遇到right或者再righ后面与之紧邻&amp;#xff1b;只是现在将left指针现在的元素位置和原来元素区间的终了点构成新的元素区间&amp;#xff0c;\n        然后通过一个基准点划分该区间为左部和右部&amp;#xff0c;使得左部序列的元素小于右部序列的元素*/&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;/*左部序列向右扫描&amp;#xff0c;右部序列向左扫描&amp;#xff0c;肯定会在某个索引处相遇或者错开b&amp;#xff0c;原来的基准在其中的一个区间中&amp;#xff0c;之后从该根据right和left两个索引\n        划分两个区间&amp;#xff0c;存到区间数组中&amp;#xff1b;\n        先完成右部序列的快速排序&amp;#xff0c;再完成左部序列的快速排序&amp;#xff0c;最终能得到数组的排序*/&lt;/span&gt;\n    }\n\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;] &amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;18&lt;/span&gt;};\n    quick_sort(arr,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; ( i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        printf(&amp;#34;%d\\n&amp;#34;,arr[i]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算", "Question": ["下面迭代法快速排序算法的方法体中有一个地方不明白，该怎样解释呢？", ["\n", "//定义结构体类型Range", "\ntypedef ", "struct", " _Range {\n    ", "int", " start, ", "end", ";\n} Range;\n", "//获得结构体变量的函数：它表示一个数组中的区间，由起始点和结束点构成", "\nRange ", "new", "_Range(", "int", " ", "s", ", ", "int", " ", "e", ")", " {\n    Range r;\n    r.start = s;\n    r.", "end", " = e;\n    return r;\n}\n", "//将x指向的元素和y指向的元素交换顺序：如果基准点左侧某个元素大于基准点且右侧有一个元素小于基准点，交换这两个元素", "\nvoid swap(", "int", " *x, ", "int", " *y) {\n    ", "int", " t = *x;\n    *x = *y;\n    *y = t;\n}\n", "//快速排序的方法", "\nvoid quick", "_sort(", "int", " ", "arr", "[], ", "const", " ", "int", " ", "len", ")", " {\n    ", "if", " (len <= ", "0", ")\n        return; ", "// 避免len等於負值時引發段錯誤（Segment Fault）", "\n    ", "//技巧： r[]模擬列表,p為數量,r[p++]為push（它先使用,r[--p]為定位到前一个元素并取出该元素", "\n    Range r", "[", "len", "]", ";", "//结构体变量组成的结构体数组：变量个数等于数组元素个数？", "\n    ", "int", " p = ", "0", ";\n    r", "[", "p", "++", "]", " = ", "new", "_Range(0, ", "len", " - 1)", ";", "//存入一个结构体变量：它的成员分别表示区间开始值和结束值", "\n    ", "while", " (p) {", "//存入一个结构体变量之后p的值变成1，此时条件成立", "\n        Range range = r", "[--", "p", "]", ";", "//取出结构体数组种存入的结构体变量（它表示一个区间)；注意--p是先运算再使用", "\n        ", "if", " (range.start >= range.", "end", ")\n            continue;", "//如果取出的开始值大于结束值，则进行下一次循环", "\n        ", "int", " mid = arr", "[(", "range", ".", "start", " + ", "range", ".", "end", ") ", "/", " ", "2", "]", "; ", "// 满足条件，選取区间中間點对应的元素為基準點", "\n        ", "int", " left = range.start, right = range.", "end", ";", "//区间的起始值赋值作为最左端元素的索引，结束值作为最右端元素的索引", "\n\n        ", "do", "\n        {\n            ", "while", " (arr", "[", "left", "]", " < mid) ++left;   ", "/* 檢測基準點左側是否符合要求，什么要求？检查基准点左侧的第一个元素值是否小于它，满足就把索引加上1继续判断左侧的下一个元素是否小于基准点，直到左侧的某个元素索引值加上1之后对应的元素大于基准点，则循环结束*/", "\n            ", "while", " (arr", "[", "right", "]", " > mid) --right; ", "/*檢測基準點右側是否符合要求，要求：检查基准点右侧的最后一个元素值是否大于它，满足就把索引减去1继续判断右侧的上一个元素是否大于基准点，直到右侧的某个元素索引值减去1之后对应的元素小于基准点，则循环结束*/", "\n \n            ", "if", " (left <= right)", "/*只有这样前面给left和right的赋值才有意义；上面两个循环都得进入，只要有不满足的\n            元素，就将它们的值交换，但交换后的元素有可能小于他前面已经判断的元素（左侧），但交换后的元素有可能大于他后面已经判断的元素（右侧），这是确定的，因为上面并未判断基准点左侧和右侧的元素的顺序*/", "\n            {\n                swap(&arr", "[", "left", "]", ",&arr", "[", "right", "]", ");\n                left++;right--;               ", "/*移動指針以繼續。继续什么：判断左侧的下一个元素和右侧的上一个元素是否是否在小于基准点或大于基准点*/", " \n            }\n        } ", "while", " (left <= right);", "/*当数组有奇数个元素时可能出现相等（等于中间元素的索引）的情况:此时直接执行到if语句块，交换后left > right，如果是偶数个元素则最终出现的是left>right;do-while循环结束；do-while循环保证了当前基准点左侧（部）的元素小于基准点，右侧（部）的元素大于基准点\n        */", "\n        ", "if", " (range.start < right) r", "[", "p", "++", "]", " = ", "new", "_Range(", "range", ".", "start", ", ", "right", ")", ";", "/*right经过do...while循环后已经是小于基准点的索引了，如果此时区间的起始值还小于它，那就在原来基准的左侧再建立一个区间（Range对象），存入结构体数组，*/", "\n        ", "if", " (range.", "end", " > left) r", "[", "p", "++", "]", " = ", "new", "_Range(", "left", ", ", "range", ".", "end", ")", ";", "/*left经过do...while循环后已经是大于基准点的索引了，如果此时区间的结束值还大于它，那就在原来基准的右侧再建立一个新的区间（Range对象），也存入结构体数组*/", "\n        ", "/*如果两个条件都满足那么结构体数组岂不是右两个Range变量：r[0],r[1];且进入while循环中的p就等于2，用r[--p]取出来的是r[1]对应原基准点右侧（右部）的一个区间，下面将使用while循环来使得该索引区间中通新的基准点左侧都是小于它的元素，右侧都是大于它的元素；那么r[0]怎么办？原来基准点左侧的新的区间中的元素并没有被基准点分到小的在新的基准点左侧大的在新基准点基准点右侧，如果条件还满足的化这个工作还没有做就将新的基准点左侧和右侧又分别建立一个区间，这样一来第一次划分基准点之后左侧的元素继续划分区间就省略了，怎么最终得到正确的排序呢？*/", "\n    }\n}\n", "\n", "最后两个if语句如果同时满足条件该怎样继续进行下面的while循环才能达到快速排序的算法要求？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;startGame&amp;#xff08;&amp;#xff09;方法设置一个参数&amp;#xff0c;输入的选择3局还是5局在方法里进行区别处理&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["java实现猜拳小游戏，Game代码有错误，求指正", ["Game.java (想实现由用户选择三局两胜还是五局三胜的赛制）", "\n\n", "\n", "import java.util.Scanner;\n\npublic class Game {\n\tScanner sc = new Scanner(System.in);\n\tUser User;//用户对象\n\tComputer Computer;//电脑玩家对象\n\tint count;//对战次数\n\tint score;//分数\n\tpublic void initial() {//游戏的初始化方法\n\t\tUser = new User();//创建用户对象\n\t\tComputer = new Computer();//创建电脑对象\n\t\tcount = 0;//比赛次数\n\t}\n\tpublic void startGame() {\n\t\tSystem.out.println(\"--------------------猜拳游戏开始了-----------------------\\n\\n\");\n\t\tSystem.out.println(\"出拳规则：1.石头 2.剪刀 3.布\");\n\t\tSystem.out.print(\"请选择对方角色(1:孙悟空 2:唐僧 3:猪八戒)\");\n\t\tint choose = sc.nextInt();//用户输入\n\t\tswitch (choose) {\n\t\tcase 1:\n\t\t\tComputer.computerName = \"孙悟空\";//对象.变量\n\t\t\tSystem.out.println(\"你与\" + Computer.computerName + \"PK\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tComputer.computerName = \"唐僧\";\n\t\t\tSystem.out.println(\"你与\" + Computer.computerName + \"PK\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tComputer.computerName = \"猪八戒\";\n\t\t\tSystem.out.println(\"你与\" + Computer.computerName + \"PK\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"输入错误！\");\n\t\t\tbreak;\n\t\t}\n\t\tSystem.out.println(\"请输入玩家姓名：\");\n\t\tUser.userName = sc.next();//对象.变量  赋值\n\t\tSystem.out.println(\"是否开始游戏（yes/no）\");\n\t\tString con = sc.next();\n\t\tif (con.equals(\"no\")) {\n\t\t\tSystem.out.println(\"退出游戏！\");\n\t\t}\n\t\tint perFist;//定义人出拳的数字\n\t\tint comFist;//定义电脑出拳的数字\n\t\tperFist = User.showFirst();//对象.方法  赋值\n\t\tcomFist = Computer.chuQuan();//对象.方法  赋值\n\t\tint computerCount = 0;//一局中电脑获胜的次数\n\t\tint playerCount = 0;//一句中玩家获胜的次数\n\t\twhile (con.equals(\"yes\")) {\n\t\t\tSystem.out.println(\"游戏规则：1.三局两胜    2.五局三胜\");\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint choose2 = sc.nextInt();// 接收用户选择的赛事\n\t\t\tswitch (choose2) {\n\t\t\tcase 1:\n\t\t\t\tfor (int i = 1; i <= 3;) {\n\t\t\t\t\tif (perFist == comFist) {// 平局\n\t\t\t\t\t\tSystem.out.println(\"平局，再接再厉！\");\n\t\t\t\t\t\tbreak;// 跳过平局的本次循环，为保证平局的i不做计算继续保持三局两胜的游戏规则\n\t\t\t\t\t} else if ((perFist == 1 && comFist == 3) || (perFist == 2 && comFist == 1)\n\t\t\t\t\t\t\t|| (perFist == 3 && comFist == 2)) {\n\t\t\t\t\t\tSystem.out.println(\"恭喜,你获胜了！\");\n\t\t\t\t\t\tplayerCount++;// 一局中玩家胜场数\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"很遗憾，你输了！\");\n\t\t\t\t\t\tcomputerCount++;// 一局中电脑胜场数\n\t\t\t\t\t}\n\t\t\t\t\t// 判断双方是否连胜两局，如果连胜两局需要 break;结束\n\t\t\t\t\tif (playerCount == 2) {\n\t\t\t\t\t\tSystem.out.println(\"最终玩家获胜！\");\n\t\t\t\t\t\tUser.score++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (computerCount == 2) {\n\t\t\t\t\t\tSystem.out.println(\"最终电脑获胜！\");\n\t\t\t\t\t\tComputer.score++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;// 平局跳过的循环不进行累加运算，来保持三局两胜的游戏规则\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\n\t\t\t\tcase2: for (int i = 1; i <= 5;) {\n\t\t\t\t\tif (perFist == comFist) {// 平局\n\t\t\t\t\t\tSystem.out.println(\"平局，再接再厉！\");\n\t\t\t\t\t\tbreak;// 跳过平局的本次循环，为保证平局的i不做计算继续保持五局三胜的游戏规则\n\t\t\t\t\t} else if ((perFist == 1 && comFist == 3) || (perFist == 2 && comFist == 1)\n\t\t\t\t\t\t\t|| (perFist == 3 && comFist == 2)) {\n\t\t\t\t\t\tSystem.out.println(\"恭喜,你获胜了！\");\n\t\t\t\t\t\tplayerCount++;// 玩家胜场数\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"很遗憾，你输了！\");\n\t\t\t\t\t\tcomputerCount++;// 电脑胜场数\n\t\t\t\t\t}\n\t\t\t\t\t// 判断双方是否连胜两局，如果连胜两局需要 break;结束\n\t\t\t\t\tif (playerCount == 3) {\n\t\t\t\t\t\tSystem.out.println(\"最终玩家获胜！\");\n\t\t\t\t\t\tUser.score++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (computerCount == 3) {\n\t\t\t\t\t\tSystem.out.println(\"最终电脑获胜！\");\n\t\t\t\t\t\tComputer.score++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti++;// 平局跳过的循环不进行累加运算，来保持五局三胜的游戏规则\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"输入有误！\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcount++;// 对战次数依次加一\n\t\t\tSystem.out.println(\"是否进入下一轮（yes/no）\");\n\t\t\tcon = sc.next();\n\t\t}\n\t\n\t\tshowResult();\n\t}\n\n\n\tpublic void showResult() {\n\t\tSystem.out.println(\"对战次数：\" + count);\n\t\tSystem.out.println(\"姓名\" + \"\\t\" + \"积分\");\n\t\tSystem.out.println(User.userName + \"\\t\" + User.score);\n\t\tSystem.out.println(Computer.computerName + \"\\t\" + Computer.score);\n\t\tif (User.score > Computer.score) {\n\t\t\tSystem.out.println(\"恭喜\"+User.userName + \"赢了！\");\n\t\t} else {\n\t\t\tSystem.out.println(\"很遗憾\"+Computer.computerName + \"赢了！\");\n\t\t}\n\t}\n}", "\n\n", "Main.java", "\n\n", "\n", "public class Main {\n\tpublic static void main(String[] args) {\n\t\tGame g = new Game();\n\t\tg.initial();// 调用初始化方法\n\t\tg.startGame();// 调用开始游戏的方法\n\n\t}\n}", "\n\n", "Computer.java", "\n\n", "\n", "public class Computer {\n\tString computerName;// 电脑名\n\tint score;// 电脑积分\n\n\tpublic int chuQuan() {\n\t\tint random = (int) (Math.random() * 3) + 1;\n\t\tswitch (random) {\n\t\tcase 1:\n\t\t\tSystem.out.println(computerName + \"出：石头\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tSystem.out.println(computerName + \"出：剪刀\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSystem.out.println(computerName + \"出：布\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"输入有错，请重新输入：\");\n\t\t\tbreak;\n\t\t}\n\t\treturn random;\n\t}\n}", "\n\n", "User.java", "\n\n", "\n", "import java.util.Scanner;\n\npublic class User {\n\tString userName;// 用户名\n\tint score;// 积分\n\n\tpublic int showFirst() {\n\t\tSystem.out.print(\"请出拳:1.剪刀2.石头3.布(输入相应的数字):\");\n\t\tScanner sc = new Scanner(System.in);\n\t\tint choice = sc.nextInt();\n\t\tswitch (choice) {\n\t\tcase 1:\n\t\t\tSystem.out.println(\"你出：石头\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tSystem.out.println(\"你出：剪刀\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSystem.out.println(\"你出：布\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"输入错误!\");\n\t\t\tbreak;\n\t\t}\n\t\treturn choice;\n\t}\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为这是以 %s输出&amp;#xff0c;即以字符串形式输出&amp;#xff0c;直接传首地址就行了&amp;#xff0c;然后printf 会往后一直输出&amp;#xff0c;直到遇到结束符&amp;#39;\\0&amp;#39;&amp;#xff0c;停止输出%s对应的字符串内容&lt;/p&gt;", "Konwledge_Point": "赋值运算", "Question": ["C语言中结构体输出的问题", ["\n", "#", "include", "<stdio.h>", "\n", "struct", " ", "student", "{        \n    ", "char", " *pcNum;\n    ", "char", " *pcName;\n    ", "char", " cSex;\n    ", "struct", " ", "date", "{\n        ", "int", " nYear,nMonth,nDay;\n    }dBirth;\n    ", "float", " fScore;\n}sStu1={", "\"0804101\"", ",", "\"Mr.Zhang\"", ",", "'M'", ",", "1979", ",", "9", ",", "1", ",", "80", "},sStu2;\n\n", "void", " ", "main", "()", "\n", "{    \n    sStu2=sStu1;", "/*同类型结构体变量之间进行赋值运算*/", "\n    ", "printf", " (", "\"Number=%s\\n\"", ",sStu2.pcNum);\n    ", "printf", " (", "\"Name=%s\\n\"", ",sStu2.pcName);\n    ", "printf", " (", "\"Born=%d年\"", ",sStu2.dBirth.nYear);\n    ", "printf", " (", "\"%d月\"", ",sStu2.dBirth.nMonth);\n    ", "printf", " (", "\"%d日\\n\"", ",sStu2.dBirth.nDay);\n    ", "printf", " (", "\"Sex=%c\\n\"", ",sStu2.cSex);\n    ", "printf", " (", "\"Score=%.1f\\n\"", ",sStu2.fScore);\n} \n\n", "\n", "请问对结构体成员输出的时候为什么是sStu2.pcNum呢，以我对指针的理解，这里应该用是sStu2.(*pcNum),结构体里面不是定义的指针的形式吗，这个pcNum不就是个地址嘛，是如何做到把值输出的，大学生学不明白了"]], "Tag": "程序设计"}
