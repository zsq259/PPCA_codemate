{"Answer": "你跟自己较这个劲干嘛呢，判断是否数字，网上一搜一大堆", "Konwledge_Point": "数学函数库", "Question": ["org.mariuszgromada.math.mxparser 数学公式jar包的问题", ["只是想单纯的问下", "\norg.mariuszgromada.math.mxparser  这个公式包里是否有function 支持判断输入参数是不是数字function。", "\n英语苦手 apidoc里没发现 怕看漏了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;利用#include&amp;lt;math.h&amp;gt;库&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["C语言中怎么去调用数学库", ["调用数学函数", "利用数学库去进行一些数学公式的运算\n", "调用数学函数", "利用数学库去进行一些数学公式的运算"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;c语言生成正弦数据很简单&amp;#xff0c;rad &amp;#61; 2&lt;em&gt;PI&lt;/em&gt;fre&lt;em&gt;point;        SinTab[point] &amp;#61; A&lt;/em&gt; sin(rad);就能够得到&amp;#xff0c;A为幅度&amp;#xff0c;fre为频率&amp;#xff0c;至于加噪声一个随机函数就搞定了&amp;#xff0c;滤波算法你可以搞一个你指定频率fre为中心的带通滤波器&amp;#xff0c;类似巴特沃斯之类的多阶滤波器就可以&amp;#xff0c;mathlab有现成的fdatools根据&amp;#xff0c;我的博客里有现成的例子。&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["关于C语言生成正弦波的系列问题", ["1-用C语言写一个函数生成一个正弦波信号（频率和幅值可设定）", "2-在正弦波基础上叠加一个随机噪声", "3-编写滤波算法，尽可能去除噪声，还原原来的信号（验证滤波算法的滤波效果）", "\n", "提示：", "1-查阅常规的滤波算法及C语言实现", "2-数据显示的方法", "1）输入信号的数据和滤波输出数据可以保存到文本csv，然后导入到excel进行对比处理", "2）用matlab直接写程序验证（不允许使用现成的数学函数库）"]], "Tag": "程序设计"}
{"Answer": "https://zhidao.baidu.com/question/254133857.html", "Konwledge_Point": "数学函数库", "Question": ["设计一个函数，使用二分法求方程e^x+x=0在(-1,0)之间的根？", ["设计一个函数，使用二分法求方程e^x+x=0在(-1,0)之间的根，注意调用数学库函", "\n数前源程序中要包含头文件math.h，不然可能出现异常的结果。在main函数中输入", "\nx，在main函数中输出该方程的根。", "\n请认真测试程序的正确性。将源代码以文本方式提交，不要直接提交文件。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-comment\"&gt;/*********begin*********/&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; a,x,sin,cos,e,f,g,i,j,k;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  h,l;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; PI 3.1416&lt;/span&gt;\ncin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;x;\nf&amp;#61;&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\ng&amp;#61;&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\nh&amp;#61;&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\nj&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;\nk&amp;#61;&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\nl&amp;#61;&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;;\nx&amp;#61;x*PI/&lt;span class=\"hljs-number\"&gt;180&lt;/span&gt;;\nsin&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\ncos&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(e&amp;#61;-x;-e&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0000001&lt;/span&gt;;h&amp;#43;&amp;#43;)\n{\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(h%&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\nsin&amp;#61;sin-e;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\nsin&amp;#61;sin&amp;#43;e;\n}\n  g&amp;#61;(f&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)*(f&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n  f&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n  e&amp;#61;e*x*x/g;\n}\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;/(x*x);-i&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0.0000001&lt;/span&gt;; l&amp;#43;&amp;#43;)\n{\ni&amp;#61;i*x*x/k;\nk&amp;#61;(j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)*(j&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\nj&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(l%&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\ncos&amp;#61;cos-i;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncos&amp;#61;cos&amp;#43;i;\n}\n}\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;amp;&amp;amp; sin&amp;gt;&lt;span class=\"hljs-number\"&gt;0.5&lt;/span&gt;)\n{\ncout&amp;lt;&amp;lt;sin&lt;span class=\"hljs-number\"&gt;-0.04655&lt;/span&gt;;\n}\n  &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;amp;&amp;amp; sin&amp;gt;&lt;span class=\"hljs-number\"&gt;0.34&lt;/span&gt;)\n    cout&amp;lt;&amp;lt;sin&lt;span class=\"hljs-number\"&gt;-0.014006&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; )\n{\ncout&amp;lt;&amp;lt;cos;\n}\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*********end*********/&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;好奇怪的答案哎&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["三角函数计算（不能使用cmath库）C++", ["######编写一个程序，根据用户命令和所输入锐角值计算并输出三角函数值。", "简化使用：用一个整数表示用户命令。1表示sin，2表示cos。", "sin(x) = x – (x^3/3!) + (x^5/5!) – (x^7/7!) + …", "cos(x) = 1 – (x^2/2!) + (x^4/4!) – (x^6/6!) + …", "要求：实现2种三角函数，不能用<math.h>中的三角函数，用泰勒级数展开实现。", "\n", "注：x^3 表示x的三次方，3!表示3的阶乘，其它类推。", "终止条件：直到最后分项的绝对值小于0.0000001(即1e-7)。", "\n", "注意：输入的角度必须先转成弧度，其中圆周率PI取值约定为3.1416。", "\n", "测试说明：", "测试输入：1 30", "预期输出：0.453451", "\n", "测试输入：2 45", "预期输出：0.707105", "\n", "\n", "#include<iostream>", "\nusing namespace std;\nint main()\n{\n    #define pi 3.1416\n   int m,n;\n   cin>>m>>n;\n   switch(m){\n   case 1:\n   {float a,", "x", "=1,answer=0;\n   ", "a", "=n/180*pi;\n   ", "for", "(int ", "i", "=1;i<20;i++){\n    x*=a/i;\n    ", "if", "(i%", "4", "==1){answer+=x;}\n    ", "if", "(i%", "4", "==3){", "answer-", "=x;}\n    }\n    cout<<answer;\n}\n   case 2:\n   {float a,", "x", "=1,answer=1; \n   ", "a", "=n/180*pi;\n   ", "for", "(int ", "i", "=1;i<20;i++){\n     x*=a/i;\n     ", "if", "((i+1)%", "4", "==3){", "answer-", "=x;}\n     ", "if", "((i+1)%", "4", "==1){answer+=x;}\n     }\n     cout<<answer;\n     }\n}\n}  \n\n", "\n", "测试出来貌似没有执行for，可是不应该啊，不懂哎，不理解，新手上路，望指正。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;n&amp;#61;&amp;#61;0 两个等号&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["关于#c语言#的问题：语言幂运算if语块", ["问题：输入任意实数x和正整数n，计算x的n次幂。", "\n", "\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "double", " x, n,m;\n    ", "scanf", "(", "\"%lf %lf\"", ", &x, &n);\n    ", "if", " (n = ", "0", ") {\n        ", "printf", "(", "\"0.000\"", ");\n    \n    \n    ", "for", " (m = x; n - ", "1", " > ", "0", "; n = n - ", "1", ") {\n\n        m = x * m;\n        \n    }\n    \n    ", "printf", "(", "\"%.3lf\\n\"", ", m);\n", "return", " ", "0", ";\n}\n", "\n", "不调用数学函数库的情况下，if语段加上以后就出现问题，if语段不加就没啥问题这是为啥呀，可是不加if的话就逻辑就不太严密"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这给判断素数的函数写的是有问题的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; math  &lt;span class=\"hljs-comment\"&gt;# 导入数学函数库&lt;/span&gt;\n\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;isPrime&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;):  &lt;span class=\"hljs-comment\"&gt;# def函数&amp;#xff0c;定义了函数isPrime&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; n &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;\n    k &amp;#61; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(math.sqrt(n))\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, k &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; n % i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;\n\n\nx &amp;#61; &lt;span class=\"hljs-built_in\"&gt;eval&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入&amp;#xff1a;&amp;#34;&lt;/span&gt;))\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; isPrime(x):\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(x, &lt;span class=\"hljs-string\"&gt;&amp;#34;是素数&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(x, &lt;span class=\"hljs-string\"&gt;&amp;#34;不是素数&amp;#34;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数学函数库", "Question": ["python输入之后不运行反而是回车是因为什么原因", ["python程序运行之后，输入之后不运行反而是回车是因为什么原因", "附上代码", "\n", "\n", "#例：判断素数。函数isPrime的功能是判断参数n是否为素数。返回值为逻辑值。", "\n", "#ps.素数：指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。", "\nimport math#导入数学函数库\ndef isPrime(n):#def函数，定义了函数isPrime\n    ", "f", "=1\n    ", "i", "=2\n    ", "while", " i<=math.sqrt(n)", "and", " ", "f", "==1:#i小于等于sqrt.(n)时循环，函数.sqrt()是就数学平方根。\n        ", "if", " n%", "i", "==0:#判断n是否能被i整除\n            ", "f", "==0#如果能被整除，不是素数\n        ", "else", ":", "i", "=i+1\n    ", "if", " ", "f", "==1:\n        return  ", "True", "\n    ", "else", ":return ", "False", "\n", "x", "=eval(input(\"请输入：\"))\n", "if", " isPrime(x):\n    ", "print", "(x,", "\"是素数\"", ")\n", "else", ":", "print", "(x,", "\"不是素数\"", ")\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x,y;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lf&amp;#34;&lt;/span&gt;,&amp;amp;x);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;lt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        y &amp;#61; (x&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)*(x&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &amp;#43; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*x&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;/x;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        y &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sqrt&lt;/span&gt;(x);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2lf&amp;#34;&lt;/span&gt;,y);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数学函数库", "Question": ["计算分段函数[2]:输入x，计算并输出下列分段函数f(x)的值(保留2位小数)。可在头文件中包含math.h，并调用sqrt函数求平方根，调用pow函数求幂。试编写相应程序。", []], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; a,b,c;\n    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\n    c&amp;#61;&lt;span class=\"hljs-built_in\"&gt;sqrt&lt;/span&gt;(a*b)&amp;#43;&lt;span class=\"hljs-built_in\"&gt;log&lt;/span&gt;(a&amp;#43;b)&amp;#43;&lt;span class=\"hljs-built_in\"&gt;exp&lt;/span&gt;(b);\n    cout&amp;lt;&amp;lt;c;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n } \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如有用请采纳&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["下列要求程序中求函数y，在输入a和x的值后求y的值，不就是double类型吗，为什么编译一直不正确，感觉逻辑正确的呀？调用数学库函数也用了，是哪里出错了？各位帮帮我这种刚刚学C语言的大一学生", ["下列要求程序中求函数y，在输入a和x的值后求y的值，不就是调用数学库函数吗，调用了呀，编译一直错误，为啥呀！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个x,y是坐标轴的x,y&amp;#xff0c;不是控制台的&amp;#xff0c;y从上到下&amp;#xff0c;x从左到右&amp;#xff0c;对应控制台输出空格和1.&lt;br /&gt;因此这个-1.2对应控制台第一列。y&amp;#61;1.3对应第一行。&lt;br /&gt;y递减对应行往下走&amp;#xff0c;x递增&amp;#xff0c;对应列往右输出。&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["c++写爱心的一个问题，请各位解答", ["在制作爱心时", "遍历下y，x的值时如下：", "#include ", "#include //使用数学函数库，pow（a,b)来求a的b次方的值", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cmath>", "//使用库函数，pow（a,b)来求a的b次方的值", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", " ", "{\n\n    ", "for", " (", "float", " y = ", "1.3", "; y >= ", "-1.1", "; y -= ", "0.06", ")", "//涉及函数图像的输出，一般的要用全体实数则最好数据类型为浮点型的，并且双for循环遍历y，x在区间内的所有值", "\n    {\n        ", "for", " (", "float", " x = ", "-1.2", "; x <= ", "1.2", "; x += ", "0.025", ")", "//x的步长为0.015，用来修改长度与宽度", "\n            ", "if", " (", "pow", "((x * x + y * y - ", "1.0", "), ", "3", ") - x * x * y * y * y <= ", "0.0", ")", "//网上的心形方程，小于等于0则说明满足在心形内的所有点", "\n                cout << ", "'1'", ";", "//填充心形的符号", "\n            ", "else", "\n                cout << ", "' '", ";", "//在心形外的用空格填满", "\n        cout << endl;\n    }\n\n    ", "return", " ", "0", ";\n}\n", "\n", "在输出时y=1.3显示在屏幕上到底是那个位置怎么预估呢，x=-1.2又在调试控制台里的哪个位置呢？"]], "Tag": "程序设计"}
{"Answer": "在while（1）后面不用接\";\"，直接大括号就可以了。如果你想无限循环的话  括号中直接true就行了 如果是判断性的，可以声名一个标识符。希望采纳。", "Konwledge_Point": "数学函数库", "Question": ["c语言 运行出错 求大佬帮忙", ["#include", "\n#include", "\n#include", "\n#include", "\n\n", "//定义全局变量", "\nint isEmpty=0;//标志，判断链表是否为空 ", "\n\n", "//！！!定义单链表结构体！！！ ", "\ntypedef struct Node{", "\n    int NUM;//类型总数 ", "\n    char NAME[100];//各类型名称 ", "\n    int num; //各类型下的货物总数", "\n    struct Node*next;", "\n}Node;", "\n\n", "//函数声明 ", "\nNode*create(int n,Node*L);", "\nNode*input(Node*L);", "\nNode*output(Node*L);", "\nNode*outnum(Node*L);", "\nNode*outname(Node*L);", "\nNode*current(Node*L);", "\nvoid search(Node*L);", "\nvoid print(Node*L);", "\nvoid searchnum(Node*L);", "\nvoid searchname(Node*L);", "\nvoid display(Node*L);", "\n//========新增加的函数========", "\nNode*append(Node*L); ", "\n\n", "//主函数", "\nvoid main()", "\n{", "\n    int x;", "\n    int n;//初次输入的大小 ", "\n    Node *L;", "\n    if(!(L=(Node *)malloc(sizeof(Node)))) //分配空间", "\n    {", "\n    printf(\"\\n\");", "\n    exit(1);", "\n    }", "\n\n", "printf(\"欢迎使用我的仓库管理系统！\\n\"); \nwhile(1);\n{\n    //主菜单开始 \n    printf(\"==========================\\n\");\n    printf(\"1.显示货物类型列表\\n\");\n    printf(\"2.增加货物类型\\n\");\n    printf(\"3.删除货物类型\\n\");\n    printf(\"4.货物入库\\n\");\n    printf(\"5.货物出库\\n\");\n    printf(\"6.库存显示\\n\");\n    printf(\"7.退出\\n\");\n    printf(\"==========================\\n\");\n    //主菜单结束\n    printf(\"选择1-7:\");\n    scanf(\"%d\",&x); \n    switch(x)\n    {\n        case 1:;break;\n        case 2:create(n,L);break;\n        case 3:;break;\n        case 4:;break;\n        case 5:;break;\n        case 6:;break;\n        case 7:;break;\n        default:printf(\"input error!\\nplaese input1-7\");\n    }       \n}           \n", "\n\n", "} ", "\n\n", "//函数", "\n//1.创建链表节点", "\nNode*create(int n,Node*L)", "\n{", "\n    Node*pTail=L; ", "\n    L->next=NULL;", "\n    Node*p;", "\n    p=(Node*)malloc(sizeof(Node));", "\n    if(p==NULL)", "\n    {", "\n        printf(\"申请内存空间失败！\\n\");", "\n    }", "\n    //利用尾插建立单链表 ", "\n    int i;", "\n    for(i=1;i<=n;i++)", "\n    {", "\n        printf(\"请输入第%d种类型编号:\\n\",i);", "\n        scanf(\"%d\",&p->NUM);", "\n        printf(\"请输入第%d种类型名称:\\n\",i);", "\n        scanf(\"%s\",&p->NAME);", "\n        printf(\"请输入第%d种类型库存:\\n\",i);", "\n        scanf(\"%d\",&p->num);", "\n        pTail->next=p;", "\n        pTail=p;", "\n    }", "\n    p->next=NULL;", "\n    return L; ", "\n} ", "\n欢迎下面就运行不了了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;直接重新安装一下就好&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;pip &lt;span class=\"hljs-keyword\"&gt;install&lt;/span&gt; numpy\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数学函数库", "Question": ["sublimehelp函数显示已有numpy函数，但在实际使用中无法调用", ["最近在学习使用Python进行数学建模，但是在调用一些数学库时出现问题，甚至无法识别“math”，不知道咋回事。无论是在终端还是在sublime都显示已有numpy库，但调用就是不行！请问大家是啥子问题啊？", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;-b&amp;#43;math.sqrt(2&lt;em&gt;a&lt;/em&gt;math.sin(0.33&lt;em&gt;3.14)&lt;em&gt;math.cos(0.33&lt;/em&gt;3.14))/(2&lt;/em&gt;a)&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["Python求x的值", ["根据下面的公式计算并输出x的值，a和b的值由用户在两行中输入，括号里的数字是角度值，要求圆周率的值使用数学常数math.pi，三角函数的值用math库中对应的函数进行计算。请编程计算并输出表达式的值。", "式子看图"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/719252915176160.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;jc&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; s &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)\n        s *&amp;#61; i;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x, sx &amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; fz, fm &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, v;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lf&amp;#34;&lt;/span&gt;, &amp;amp;x);\n    fz &amp;#61; x;\n    v &amp;#61; fz / fm;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;fabs&lt;/span&gt;(v) &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;1e-5&lt;/span&gt;)\n    {\n        sx &amp;#43;&amp;#61; flag * v;\n        i &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        fz &amp;#61; &lt;span class=\"hljs-built_in\"&gt;pow&lt;/span&gt;(x, i);\n        fm &amp;#61; &lt;span class=\"hljs-built_in\"&gt;jc&lt;/span&gt;(i);\n        flag &amp;#61; -flag;\n        v &amp;#61; fz / fm;\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lf&amp;#34;&lt;/span&gt;, sx);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数学函数库", "Question": ["C语言程序C语言程序", ["求sin函数的值，要求最后一项的绝对值小于十的负五次方，求实数绝对值的数学库函数为fabs"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;br /&gt;int inter(int a,int b)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int loop,sum&amp;#61;1;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for(loop&amp;#61;0;loop&amp;lt;b;loop&amp;#43;&amp;#43;)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        sum &amp;#61; sum * a;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    return sum;&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;int main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int a,b,c;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;a,&amp;amp;b);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    c &amp;#61; inter(a,b);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    printf(&amp;#34;%d\\n&amp;#34;,c);&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    return 0;&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["一道关于c的程序题，请问这个应该如何做？", ["关于这道指数的题，不知道大家都是怎么做的：假设指数是一个正的非零整数，而基数是一个整数。函数 integerPower 应该用于控制计算。不要", "使用任何数学库函数。"]], "Tag": "程序设计"}
{"Answer": "max=b&gt;max?b:max\r\n的意思是\r\nif (b &gt; max)\r\nmax = b;\r\nelse\r\nmax = max;\r\n也就是如果b比max还大，那么用b作为新的max", "Konwledge_Point": "数学函数库", "Question": ["一道C语言题目 看一下这个编程有些疑惑", ["大概意思就是输入一组成绩 求最大 最小 平均值 ", "\n看下这道提", "\n有个地方不明白", "  看一下有 问号的那两个地方", "\n\n", "就拿一个问号那句来说", "\n\n", "我不理解这程序是怎么一个运算顺序", "\n\n", "比如 b大于max不成立", "\n那么输出max"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;的确是很多第三方库给你去用&amp;#xff0c;直接import就可以&amp;#xff0c;但是问题是&amp;#xff0c;如果目前出了问题&amp;#xff0c;第三方库无法满足你的需求&amp;#xff0c;你需要进一步修改代码你怎么办&amp;#xff1f;而且这个问题在实际应用中是经常碰见的&amp;#xff0c;这时候你会不会神经网络基础和代码基础的差距就出来了。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/430215586256195.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;就像你自己说的&amp;#xff0c;看着都会&amp;#xff0c;实际上你自己写一个网络模块就知道怎么回事了。别的不说&amp;#xff0c;简单的vgg自己搭建一个试试看下分类效果就知道了&amp;#xff0c;而实际上很多情况下SOTA网络只有数学公式和效果而没有具体的代码&amp;#xff0c;这时候你又很需要用到这个网络你怎么办&amp;#xff1f;你只能根据人家给出的公式自己搭建网络来用。&lt;br /&gt;所以&amp;#xff0c;不会相关原理和相关代码能力&amp;#xff08;手里无剑&amp;#xff09;和掌握原理而调用第三方库&amp;#xff08;手里有剑而不用&amp;#xff09;是两回事。&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["基于python做神经网络、深度学习需不需要自己写代码，需要写到什么程度呢？", ["我的情况是：刚刚接触神经网络、深度学习半年。目前跟着一些教学视频和书来学习相关理论知识。", "慢慢地，我对神经网络整体上有了大概的了解。大部分的教学视频课程都是介绍一下某种神经网络的基本思路，以及核心的数学公式，数学公式这里有的一笔带过，详细一点的会推理一遍。但到了真正应用实战的时候，往往都是直接import 某个库，然后实例化，调参。这个过程是完全没有用到前面铺垫的数学知识的，这让我感到迷茫。", "所以基于python做神经网络、深度学习需不需要自己写代码，需要写到什么程度呢？", "我自己也只是能够跟着教程推一下像梯度下降，反向传播这些公式。可是如果说让我自己根据这些公式来写神经网络，我感觉我是写不出来的。包括像正则化，CNN,RNN等,这些我都能够用keras实现，也理解背后的含义，但我无法做到从头开始搭建网络啊，我觉得这跟使用一些便捷的函数是不同的（比如可以直接用.sort()，没必要自己写冒泡法排序）。", "所以能不能请大家给我一些指点，后续应该学什么，怎么做，需不需要自己编程，编程到哪种程度呢，如果仅仅在import keras 的基础上，可以实现对神经网络做哪些创新工作呢？", "谢谢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是函数指针&amp;#xff0c;由于几个算法函数的参数和返回值是一样的&amp;#xff0c;所以定义了一个函数指针&amp;#xff0c;根据用户的算法选择&amp;#xff0c;分别指向不同的算法函数&amp;#xff0c;然后根据参数调用函数指针实现不同算法获得需要的计算结果&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["【C语言】【矩形法求积分】res=(fun)(2.00)是什么意思？", ["这里的res=(fun)*(2.0)是什么意思？", "\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>", "//引入sin x,cos x,e^x的库", "\n", "//使用指向函数的指针变量来复用一个通用函数", "\nint main()\n{\n int i,j,k,n,m;\n float res;\n float (*", "fun", ")", "(float)", ";", "//定义指向函数的指针变量", "\n float integral (float a,float b,float (*", "fun", ")", "(float)", ",int n);", "//n为将积分区间（b-a)分成n等分，当n的值越大的时候结果越精确，数学上的定义是取无穷大", "\n float fsin(float);", "//sin x函数的声明", "\n float fcos(float);", "//cos x函数的声明", "\n float fexp(float);", "//e^x 函数的声明", "\n printf (", "\"请输入积分的下限\\n\"", ");\n scanf (", "\"%d\"", ",&m);\n printf (", "\"请输入积分的上限\\n\"", ");\n scanf (", "\"%d\"", ",&n);\n printf(", "\"请输入你要计算的函数的具体函数\\n\"", ");\n printf(", "\"1.sin(x) 2.cos(x) 3.e^x\\n\"", ");\n scanf (", "\"%d\"", ",&i);\n switch(i)\n {\n case ", "1", ":\n  ", "fun", "=fsin;//函数地址（入口）交给指针变量，灵活性强", "\n  ", "break", ";\n \n case ", "2", ":\n  ", "fun", "=fcos;", "\n  ", "break", ";\n case ", "3", ":\n  ", "fun", "=fexp;", "\n }\n res=(", "fun", ")", "(", "2.00", ")", ";\n ", "//printf(\"xxxx=%f\\n\",res);", "\n printf (", "\"计算的结果为\\n\"", ");\n res=integral(m,n,", "fun", ",200000);", "\n printf(", "\"res=%f\"", ",res);\n ", "return", " ", "0", ";\n}\nfloat fsin(float x)\n{\n ", "// printf(\"fsinx=%f\\n\",x);", "\n ", "return", " sin(x);\n}\nfloat fcos(float x)\n{\n ", "//printf(\"fcosx=%f\\n\",x);", "\n ", "return", " cos(x);\n}\nfloat fexp(float x)\n{\n ", "//getchar();", "\n ", "//printf(\"fexp=%f\\n\",x);", "\n ", "return", " exp(x);\n}\nfloat integral(float a,float b,float (*", "fun", ")", "(float)", ",int n)\n{\n ", "//矩形法计算,定积分转换为连续求和的形式", "\n int i=", "0", ";\n float x=a,s=", "0", ";\n float h=(b-a)/n;\n \n ", "for", " (i=", "1", ";i<=n;i++)\n {\n  x=x+h;\n  s=s+((*", "fun", ")", "(x)", "*h);\n \n }\n ", "return", " s;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;# 第一题\nd &amp;#61; {&amp;#39;k1&amp;#39;: [], &amp;#39;k2&amp;#39;: []}\nfor i in [6,29,32,45,50,60,77,80,100,90]:\n    if i &amp;gt;&amp;#61; 60:\n        d[&amp;#39;k1&amp;#39;].append(i)\n    else:\n        d[&amp;#39;k2&amp;#39;].append(i)\nprint(d)\n\n# 第二题\ndef fun(n):\n   if n &amp;#61;&amp;#61; 1:\n       return [0]\n   elif n &amp;#61;&amp;#61; 2:\n       return [0, 1]\n   l &amp;#61; [0, 1] \n   for i in range(2, n):\n       l.append(l[-2] &amp;#43; l[-1])\n   return l\n\nprint(fun(15))\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "数学函数库", "Question": ["有关Python的基础问答题", ["1、有如下值的列表[6,29,32,45,50,60,77,80,100,90]，请编程实现：构造字典将所有大于60的值保存至字典的第一个key中，将小于60值保存至第二个key的值中，并打印字典数据，即打印结果：{'k1': [6, 29, 32, 45, 50], 'k2': [77, 80, 100, 90]}。", "\n\n", " ", "\n\n", "2、定义一个类Myclasss及方法factorial，实例化类对象并调用方法factorial打印用户输入的数n的斐波那契数列。斐波那契数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N*）。如用户输入10， 则打印结果：1,1,2,3,5,8,13,21,34,55， 请编程实现", "\n\n", " ", "\n\n", " ", "\n\n", "3、定义一个教师类Teacher，教师对象有teac_id、teac_name、age三个成员变量，成员方法display_info用于显示教师的基本信息。定义完类Teacher后，创建一个教师对象，并输出该教师的基本信息。", "\n\n", " ", "\n\n", "4. 利用random库随机产生2个整数列表，每个列表10个元素，元素取值范围1~100，判断两个列表中是否存在相同元素，若存在，则打印出所有相同元素及其在两个列表中的下标，若不存在，将两个列表合并为一个列表后打印出来。", "\n\n", " ", "\n\n", " ", "\n\n", "5.利用jieba和wordcloud库，绘制出文件“中国共产党十九届五中全会公报.txt”中前1000个热点词云。", "\n\n", "【提示】词云形状自选，中国共产党十九届五中全会公报.txt文件及可能用到的其它文件见文件夹data。", "\n\n", " ", "\n\n", "6．输入两个数x 和y，如果x 或y 小于等于0，提示请输入正整数，求这两个数的最大公约数和最小公倍数。", "\n\n", "注意：可以采用欧几里得辗转相除算法来求最大公约数。最小公倍数的计算方法是两数的乘积除以两数最大公约数的结果。", "\n\n", " ", "\n\n", " ", "\n\n", "7．定义一个函数fsum，求1+2+3……+n-1+n的值。用此函数计算机n=1000的值", "\n\n", " ", "\n\n", "8. 编写一个程序，打印出如下图所示的金字塔。", "\n\n", " ", "\n\n", "下图附第八题", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;应该是没有读取进来数据。在getstate函数里&amp;#xff0c;for循环没有运行&amp;#xff0c;所以state是None。也可能len(block)刚好等于1&amp;#xff0c;而你又用len(block)-1,所以循环没有进行。我不知道你是不是想用for去枚举block&amp;#xff0c;如果是&amp;#xff0c;应该是for i in range(len(block))&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["请各位大神帮帮忙,因为这是毕业论文所用的代码,我想问问到底是否是对的,看看是我代码错了,还是逻辑错了", ["首先我这里有一个yunfuzai_main.py:", "\n\n", "\n", "from dqn_agent import Agent\nfrom model import QNetwork\nimport matplotlib.pyplot as plt\nimport  numpy as np\nimport torch\nimport xlrd\nfrom openpyxl import load_workbook\nimport gc\n\n\nSTATE_SIZE = 10\nEPISODE_COUNT = 1000\n\n# def dqn(n_episodes=EPISODE_COUNT,eps_start=2.0,eps_end=0.03,eps_decay=0.990):\n#     scores = []\n#     for i_episode in range(1, n_episodes + 1):\n#         print(\"Episode\" + str(i_episode))\n#         state = getState(stockData, 0, STATE_SIZE + 1)\n#         total_profit = 0\n#         agent.inventory = []\n#         eps = eps_start\n#\n#         for t in range(l):\n#             action = agent.act(state, eps)\n#             next_state = getState(stockData, t + 1, STATE_SIZE + 1)\n#             reward = 0\n#\n#             if action == 1:  # 买入\n#                 agent.inventory.append(stockData[t])\n#                 # print(\"buy\" + str(stockData[t]))\n#             elif action == 2 and len(agent.inventory) > 0:  # 卖出\n#                 bought_price = agent.inventory.pop(0)\n#                 total_profit += stockData[t] - bought_price\n#                 # reward = max(stockData[t] - bought_price, 0)\n#                 reward = stockData[t] - bought_price\n#                 # print(\"Sell: \" + str(stockData[t]) + \" | Profit: \" + str(stockData[t] - bought_price))\n#             done = 1 if t == l - 1 else 0\n#             agent.step(state, action, reward, next_state, done)\n#             eps = max(eps_end, eps * eps_decay)\n#             state = next_state\n#\n#             # if done:\n#             #     print(\"------------------------------\")\n#             #     print(\"total_profit = \" + str(total_profit))\n#             #     print(\"------------------------------\")\n#         scores.append(total_profit)\n#     return scores\n\ndef dqn1(n_episodes1=EPISODE_COUNT, eps_start1=1.0, eps_end1=0.01, eps_decay1=0.9995):\n    scores1 = []\n    for i_episode in range(1,n_episodes1+1):\n        print(\"Episode\" + str(i_episode))\n\n        state = getState(stockData, 0, STATE_SIZE + 1)\n        agent.inventory = []\n        eps = eps_start1\n        #global loss\n        print(1)\n        for t in range(l):\n            print(2)\n            action = agent.act(state,eps)\n            print(1)\n            next_state = getState(stockData, t + 1, STATE_SIZE + 1)\n            reward = 0\n            done = 1 if t == l - 1 else 0\n            global loss\n            loss = agent.step(state, action, reward, next_state, done)\n\n            print(\"loss\", + str(loss))\n            scores1.append(loss)\n            gc.collect()\n        gc.collect()\n\n    return scores1\n\n            # if action == 1:# 过载\n            #     agent.inventory.append(stockData[t])\n            # elif action == 2 and len(agent.inventory) > 0:\n\n\ndef getState(data, t, n):\n    d = t - n + 1\n    # block = data[d:t + 1] if d>= 0 else -d * [data[0]]+ data[0:t+1]\n    block = data[d:t + 1]\n    #res = [0 for x in range(0, n)]\n    #res = []\n    buffer = []\n    for i in range(len(block) - 1):\n        print(\"res=\",buffer[i])\n        buffer.append(block[i + 1]-block[i])\n        #print(\"res=\",res[i])\n        return np.array([buffer])\n    #return np.array([res])\n\nif __name__== '__main__':\n    print(1)\n    #stockData = []\n    #stockData = []\n    stockData = [None]*801\n    datas1 =xlrd.open_workbook(r'C:\\Users\\86138\\Desktop\\zi_ding_yi.xlsx',{'constant_memory':True})\n\n    #datas1 = xlrd.open_workbook(r'C:\\Users\\86138\\Desktop\\zi_ding_yi.xlsx')\n    print(2)\n    table = datas1.sheets()[0]\n    row_num = 0\n    print(3)\n    # for item in table[1:]:\n    #      stockData.append(float(table.col_values(6)))\n    col = table.col_values(5)\n    while row_num <= 800 :\n        # stockData[row_num] = table.col_values(5,0,row_num)\n        #stockData[row_num] = table.cell_value(row_num,5)\\\n        stockData.append(table.cell_value(row_num,5))\n        row_num += 1\n     # stockData{row_num} = table.col_values(5,0,row_num)\n     # row_num =+1\n\n    agent = Agent(state_size=STATE_SIZE, action_size=3)\n    print(4)\n    l = len(stockData) - 1\n\n    # scores = dqn()\n    scores1 =dqn1()", "\n\n", "它说我的错误是：", "\n\n", "\n", "C:\\Users\\86138\\anaconda3\\python.exe C:/Users/86138/Desktop/stockPrediction-master/yunfuzai_main.py\n1\n2\n3\n4\nEpisode1\n1\n2\nTraceback (most recent call last):\n  File \"C:/Users/86138/Desktop/stockPrediction-master/yunfuzai_main.py\", line 123, in <module>\n    scores1 =dqn1()\n  File \"C:/Users/86138/Desktop/stockPrediction-master/yunfuzai_main.py\", line 61, in dqn1\n    action = agent.act(state,eps)\n  File \"C:\\Users\\86138\\Desktop\\stockPrediction-master\\dqn_agent.py\", line 136, in act\n    state = torch.tensor(state).float.unsqueeze(0).to(device)\nRuntimeError: Could not infer dtype of NoneType\n", "\n\n", "而我的dqn_agent.py:", "\n\n", "\n", "import numpy as np\nimport random\nfrom collections import namedtuple, deque\n\nfrom model import QNetwork\n\nimport torch\nimport torch.nn.functional as F\nimport torch.optim as optim\n\n#初始化超参数\nBUFFER_SIZE = int(1e5)\n#缓冲去大小，重播缓冲区大小\nBATCH_SIZE = 64\n#批处理大小，最小批量大小，minbatch size\nGAMMA = 0.99\n##折扣率\nTAU = 1e-3\n#用于目标参数的软更新\nLR = 5e-4\n#学习率\nUPDATE_EVERY = 4\n#更新网络的快慢\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n#首先看下你的设备有无cuda可用：\n\nclass ReplayBuffer:\n    def __init__(self, action_size, buffer_size, batch_size):# 初始化记忆库\n        self.action_size = action_size\n        self.memory = deque(maxlen=buffer_size)\n        #使用 deque(maxlen=N) 构造函数会创建一个固定大小的队列。当新的元素加入并且这个队列已满的时候，最老的元素会自动被移除掉\n        self.batch_size = batch_size\n        #batch字面上是批量的意思，在深度学习中指的是计算一次cost需要的输入数据个数。\n        self.experience = namedtuple(\"Experience\", field_names=[\"state\", \"action\", \"reward\", \"next_state\", \"done\"])\n        #经验池的作用就是把每次进行的游戏回合transition（episode，step）记录下来存储起来。\n        # 在训练的时候则是在经验池中随机取一组transition batch对Q网络进行优化。同时，也需要及时丢掉过老的记录，及时更新。\n        #首先，定义了一个名为Experience的namedtuple。包括内容除了上面算法中提到的（s,a,r,s'）.还有结束的标识’done’。\n    def add(self, state, action, reward, next_state, done):# 向记忆库中加入一个记忆\n        e = self.experience(state, action, reward, next_state, done)\n        self.memory.append(e)\n\n    def sample(self):# 随机取出一个minibatch\n        experiences = random.sample(self.memory, k=self.batch_size)\n        states = torch.from_numpy(np.vstack([e.state for e in experiences if e is not None])).float().to(device)\n        actions = torch.from_numpy(np.vstack([e.action for e in experiences if e is not None])).float().to(device)\n        rewards = torch.from_numpy(np.vstack([e.reward for e in experiences if e is not None])).float().to(device)\n        next_states = torch.from_numpy(np.vstack([e.next_state for e in experiences if e is not None])).float().to(device)\n        dones = torch.from_numpy(np.vstack([e.done for e in experiences if e is not None])).float().to(device)\n\n        return (states, actions, rewards, next_states, dones)\n\n    def __len__(self):\n        return len(self.memory)\n\n\nclass Agent:\n\n    def __init__(self, state_size, action_size):\n        self.state_size = state_size\n        self.action_size = action_size\n\n        # Q-Network\n        #在学习过程中，我们使用两个不相关的Q网络（Q_network_local和Q_network_target）来计算预测值（权重θ）和目标值（权重θ’）。\n        # 经过若干步骤后，目标网络会被冻结，然后拷贝实际的Q网络的权重到目标网络权重。\n        # 冻结目标Q网络一段时间再用实际Q网络的权重更新其权重，可以稳定训练过程\n        self.qnetwork_local = QNetwork(state_size, action_size).to(device)\n        self.qnetwork_target = QNetwork(state_size, action_size).to(device)#目标策略，智能体要学习的策略\n        self.optimizer = optim.Adam(self.qnetwork_local.parameters(), lr=LR)\n        #在线性回归或者监督学习中，我们会计算预测值与真实值之间的差距，也就是loss\n        #在计算得出loss之后，通常会使用Optimizer对所构造的数学模型/网络模型进行参数优化，\n        #通常情况下，优化的最终目的是使得loss趋向于最小。\n\n\n        # Replay Buffer，所以我们设置一个replay_buffer，获得新的交互数据，抛弃旧的数据，\n        # 并且每次从这个replay_buffer中随机取一个batch，来训练我们的系统\n        self.memory = ReplayBuffer(action_size, buffer_size=BUFFER_SIZE,batch_size=BATCH_SIZE)\n        # 初始化迭代步数\n        self.t_step = 0\n        # 初始化持仓\n        self.inventory = []\n    # Experience Replay就是这样的一种技术，在游戏数据的采集过程中，所有的经验数据<script type=\"math/tex\" id=\"MathJax-Element-85\">< s, a, r, s'\n    # ></script>都被存储到一个回放池(replay memory)中。当训练网络时，从回放池中随机地取一小撮数据，\n    # 而不是最新连续的几条转换数据，进行训练。\n\n    def step(self, state, action, reward, next_state, done):\n        # 每一步需要先存储记忆库\n        self.memory.add(state, action, reward, next_state, done)\n\n        # 每隔若干步学习一次\n        self.t_step = (self.t_step + 1) % UPDATE_EVERY\n        if self.t_step == 0:\n            if len(self.memory) > BATCH_SIZE:\n                experience = self.memory.sample()\n                self.learn(experience, GAMMA)\n\n    def learn(self, experience, gamma):\n        # 更新迭代\n        states, actions, rewards, next_states, dones = experience\n\n        # target network:compute and minimize the loss.计算并最小化损失\n        # Get max predicted Q values(for next states) from target model:从目标模型得到最大的预测Q值(下一个状态)\n        Q_targets_next = self.qnetwork_target(next_states).detach().max(1)[0].unsqueeze(1)\n        # compute Q target for current states:计算当前状态的Q目标。\n        Q_targets = rewards + (gamma * Q_targets_next * (1 - dones))\n\n        Q_expected = self.qnetwork_local(states).gather(1, actions.long())# 固定行号，确认列\n        # Compute loss\n        loss = F.mse_loss(Q_expected, Q_targets)\n        # Minimize the loss\n        self.optimizer.zero_grad()\n        loss.backward()\n        self.optimizer.step()\n        # update target network\n        self.soft_update(self.qnetwork_local, self.qnetwork_target, tau=TAU)\n        return loss\n\n\n    def soft_update(self, local_model, target_model, tau):\n        for target_param, local_param in zip(target_model.parameters(), local_model.parameters()):\n            target_param.data.copy_(tau * local_param.data + (1.0 - tau) * target_param.data)\n    #实现Q'到Q的逼近 use .data and .data.copy#\n    def act(self, state, eps = 0.):\n        #Returns actions for given state as per current policy.\n        #Params\n        # state (array_like): current state\n        # eps (float): epsilon, for epsilon-greedy action selection\n        #参数个数\n        #状态(array_like):当前状态\n        #eps (float):用于epsilon-贪婪动作选择\n\n\n        # 返回动作值orch.unsqueeze()这个函数主要是对数据维度进行扩充\n        #state = torch.from_numpy(state).float().unsqueeze(0).to(device)\n        state = torch.tensor(state).float.unsqueeze(0).to(device)\n        self.qnetwork_local.eval()\n        with torch.no_grad():\n            action_values = self.qnetwork_local(state)\n        self.qnetwork_local.train()\n# # Epsilon-greedy action selection\n        if random.random() > eps:\n            return np.argmax(action_values.cpu().data.numpy())\n        else:\n            return random.choice(np.arange(self.action_size))\n        #eps:根据当前策略返回给定状态的操作参数个数", "\n\n", "我也是真没辙了，所以我想问问，到底是怎么回事，因为我真实想法是把那个loss输出来。但似乎不行，想请各位大神帮我看看，因为是毕业论文用的代码，所以就想问问。拜托了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;错误请截取完整错误信息&amp;#xff0c;就一个段错误&amp;#xff0c;谁知道你是哪里的段错误&lt;/p&gt;", "Konwledge_Point": "数学函数库", "Question": ["关于fasterrcnn的train.py报错“段错误，核心已转储”", ["本人在Linux上运行train.py代码，结果出现如题报错，找不到原因", "\n", "import", " numpy ", "as", " np\n", "import", " torch\n", "import", " torch.backends.cudnn ", "as", " cudnn\n", "import", " torch.optim ", "as", " optim\n", "from", " torch.utils.data ", "import", " DataLoader\n\n", "from", " nets.frcnn ", "import", " FasterRCNN\n", "from", " nets.frcnn_training ", "import", " FasterRCNNTrainer, weights_init\n", "from", " utils.callbacks ", "import", " LossHistory\n", "from", " utils.dataloader ", "import", " FRCNNDataset, frcnn_dataset_collate\n", "from", " utils.utils ", "import", " get_classes\n", "from", " utils.utils_fit ", "import", " fit_one_epoch\n\n", "'''\n训练自己的目标检测模型一定需要注意以下几点：\n1、训练前仔细检查自己的格式是否满足要求，该库要求数据集格式为VOC格式，需要准备好的内容有输入图片和标签\n   输入图片为.jpg图片，无需固定大小，传入训练前会自动进行resize。\n   灰度图会自动转成RGB图片进行训练，无需自己修改。\n   输入图片如果后缀非jpg，需要自己批量转成jpg后再开始训练。\n\n   标签为.xml格式，文件中会有需要检测的目标信息，标签文件和输入图片文件相对应。\n\n2、训练好的权值文件保存在logs文件夹中，每个epoch都会保存一次，如果只是训练了几个step是不会保存的，epoch和step的概念要捋清楚一下。\n   在训练过程中，该代码并没有设定只保存最低损失的，因此按默认参数训练完会有100个权值，如果空间不够可以自行删除。\n   这个并不是保存越少越好也不是保存越多越好，有人想要都保存、有人想只保存一点，为了满足大多数的需求，还是都保存可选择性高。\n\n3、损失值的大小用于判断是否收敛，比较重要的是有收敛的趋势，即验证集损失不断下降，如果验证集损失基本上不改变的话，模型基本上就收敛了。\n   损失值的具体大小并没有什么意义，大和小只在于损失的计算方式，并不是接近于0才好。如果想要让损失好看点，可以直接到对应的损失函数里面除上10000。\n   训练过程中的损失值会保存在logs文件夹下的loss_%Y_%m_%d_%H_%M_%S文件夹中\n\n4、调参是一门蛮重要的学问，没有什么参数是一定好的，现有的参数是我测试过可以正常训练的参数，因此我会建议用现有的参数。\n   但是参数本身并不是绝对的，比如随着batch的增大学习率也可以增大，效果也会好一些；过深的网络不要用太大的学习率等等。\n   这些都是经验上，只能靠各位同学多查询资料和自己试试了。\n'''", "  \n", "if", " __name__ == ", "\"__main__\"", ":\n    ", "#-------------------------------#", "\n    ", "#   是否使用Cuda", "\n    ", "#   没有GPU可以设置成False", "\n    ", "#-------------------------------#", "\n    Cuda = ", "True", "\n    ", "#--------------------------------------------------------#", "\n    ", "#   训练前一定要修改classes_path，使其对应自己的数据集", "\n    ", "#--------------------------------------------------------#", "\n    classes_path    = ", "'model_data/voc_classes.txt'", "\n    ", "#----------------------------------------------------------------------------------------------------------------------------#", "\n    ", "#   权值文件的下载请看README，可以通过网盘下载。模型的 预训练权重 对不同数据集是通用的，因为特征是通用的。", "\n    ", "#   模型的 预训练权重 比较重要的部分是 主干特征提取网络的权值部分，用于进行特征提取。", "\n    ", "#   预训练权重对于99%的情况都必须要用，不用的话主干部分的权值太过随机，特征提取效果不明显，网络训练的结果也不会好", "\n    ", "#", "\n    ", "#   如果训练过程中存在中断训练的操作，可以将model_path设置成logs文件夹下的权值文件，将已经训练了一部分的权值再次载入。", "\n    ", "#   同时修改下方的 冻结阶段 或者 解冻阶段 的参数，来保证模型epoch的连续性。", "\n    ", "#   ", "\n    ", "#   当model_path = ''的时候不加载整个模型的权值。", "\n    ", "#", "\n    ", "#   此处使用的是整个模型的权重，因此是在train.py进行加载的，下面的pretrain不影响此处的权值加载。", "\n    ", "#   如果想要让模型从主干的预训练权值开始训练，则设置model_path = ''，下面的pretrain = True，此时仅加载主干。", "\n    ", "#   如果想要让模型从0开始训练，则设置model_path = ''，下面的pretrain = Fasle，Freeze_Train = Fasle，此时从0开始训练，且没有冻结主干的过程。", "\n    ", "#   一般来讲，从0开始训练效果会很差，因为权值太过随机，特征提取效果不明显。", "\n    ", "#", "\n    ", "#   网络一般不从0开始训练，至少会使用主干部分的权值，有些论文提到可以不用预训练，主要原因是他们 数据集较大 且 调参能力优秀。", "\n    ", "#   如果一定要训练网络的主干部分，可以了解imagenet数据集，首先训练分类模型，分类模型的 主干部分 和该模型通用，基于此进行训练。", "\n    ", "#----------------------------------------------------------------------------------------------------------------------------#", "\n    model_path      = ", "'model_data/voc_weights_resnet.pth'", "\n    ", "#------------------------------------------------------#", "\n    ", "#   输入的shape大小", "\n    ", "#------------------------------------------------------#", "\n    input_shape     = [", "600", ", ", "600", "]\n    ", "#---------------------------------------------#", "\n    ", "#   vgg或者resnet50", "\n    ", "#---------------------------------------------#", "\n    backbone        = ", "\"resnet50\"", "\n    ", "#----------------------------------------------------------------------------------------------------------------------------#", "\n    ", "#   是否使用主干网络的预训练权重，此处使用的是主干的权重，因此是在模型构建的时候进行加载的。", "\n    ", "#   如果设置了model_path，则主干的权值无需加载，pretrained的值无意义。", "\n    ", "#   如果不设置model_path，pretrained = True，此时仅加载主干开始训练。", "\n    ", "#   如果不设置model_path，pretrained = False，Freeze_Train = Fasle，此时从0开始训练，且没有冻结主干的过程。", "\n    ", "#----------------------------------------------------------------------------------------------------------------------------#", "\n    pretrained      = ", "False", "\n    ", "#------------------------------------------------------------------------#", "\n    ", "#   anchors_size用于设定先验框的大小，每个特征点均存在9个先验框。", "\n    ", "#   anchors_size每个数对应3个先验框。", "\n    ", "#   当anchors_size = [8, 16, 32]的时候，生成的先验框宽高约为：", "\n    ", "#   [90, 180] ; [180, 360]; [360, 720]; [128, 128]; ", "\n    ", "#   [256, 256]; [512, 512]; [180, 90] ; [360, 180]; ", "\n    ", "#   [720, 360]; 详情查看anchors.py", "\n    ", "#   如果想要检测小物体，可以减小anchors_size靠前的数。", "\n    ", "#   比如设置anchors_size = [4, 16, 32]", "\n    ", "#------------------------------------------------------------------------#", "\n    anchors_size    = [", "8", ", ", "16", ", ", "32", "]\n\n    ", "#----------------------------------------------------#", "\n    ", "#   训练分为两个阶段，分别是冻结阶段和解冻阶段。", "\n    ", "#   显存不足与数据集大小无关，提示显存不足请调小batch_size。", "\n    ", "#----------------------------------------------------#", "\n    ", "#----------------------------------------------------#", "\n    ", "#   冻结阶段训练参数", "\n    ", "#   此时模型的主干被冻结了，特征提取网络不发生改变", "\n    ", "#   占用的显存较小，仅对网络进行微调", "\n    ", "#----------------------------------------------------#", "\n    Init_Epoch          = ", "0", "\n    Freeze_Epoch        = ", "50", "\n    Freeze_batch_size   = ", "4", "\n    Freeze_lr           = ", "1e-4", "\n    ", "#----------------------------------------------------#", "\n    ", "#   解冻阶段训练参数", "\n    ", "#   此时模型的主干不被冻结了，特征提取网络会发生改变", "\n    ", "#   占用的显存较大，网络所有的参数都会发生改变", "\n    ", "#----------------------------------------------------#", "\n    UnFreeze_Epoch      = ", "100", "\n    Unfreeze_batch_size = ", "4", "\n    Unfreeze_lr         = ", "1e-5", "\n    ", "#------------------------------------------------------#", "\n    ", "#   是否进行冻结训练，默认先冻结主干训练后解冻训练。", "\n    ", "#------------------------------------------------------#", "\n    Freeze_Train        = ", "True", "\n    ", "#------------------------------------------------------#", "\n    ", "#   用于设置是否使用多线程读取数据", "\n    ", "#   开启后会加快数据读取速度，但是会占用更多内存", "\n    ", "#   内存较小的电脑可以设置为2或者0  ", "\n    ", "#------------------------------------------------------#", "\n    num_workers         = ", "0", "\n    ", "#----------------------------------------------------#", "\n    ", "#   获得图片路径和标签", "\n    ", "#----------------------------------------------------#", "\n    train_annotation_path   = ", "'2007_train.txt'", "\n    val_annotation_path     = ", "'2007_val.txt'", "\n    \n    ", "#----------------------------------------------------#", "\n    ", "#   获取classes和anchor", "\n    ", "#----------------------------------------------------#", "\n    class_names, num_classes = get_classes(classes_path)\n\n    model = FasterRCNN(num_classes, anchor_scales = anchors_size, backbone = backbone, pretrained = pretrained)\n    ", "if", " ", "not", " pretrained:\n        weights_init(model)\n    ", "if", " model_path != ", "''", ":\n        ", "#------------------------------------------------------#", "\n        ", "#   权值文件请看README，百度网盘下载", "\n        ", "#------------------------------------------------------#", "\n        ", "print", "(", "'Load weights {}.'", ".", "format", "(model_path))\n        device          = torch.device(", "'cuda'", " ", "if", " torch.cuda.is_available() ", "else", " ", "'cpu'", ")\n        model_dict      = model.state_dict()\n        pretrained_dict = torch.load(model_path, map_location = device)\n        pretrained_dict = {k: v ", "for", " k, v ", "in", " pretrained_dict.items() ", "if", " np.shape(model_dict[k]) == np.shape(v)}\n        model_dict.update(pretrained_dict)\n        model.load_state_dict(model_dict)\n\n    model_train = model.train()\n    ", "if", " Cuda:\n        model_train = torch.nn.DataParallel(model)\n        cudnn.benchmark = ", "True", "\n        model_train = model_train.cuda()\n\n    loss_history    = LossHistory(", "\"logs/\"", ")\n\n    ", "#---------------------------#", "\n    ", "#   读取数据集对应的txt", "\n    ", "#---------------------------#", "\n    ", "with", " ", "open", "(train_annotation_path) ", "as", " f:\n        train_lines = f.readlines()\n    ", "with", " ", "open", "(val_annotation_path) ", "as", " f:\n        val_lines   = f.readlines()\n    num_train   = ", "len", "(train_lines)\n    num_val     = ", "len", "(val_lines)\n\n    ", "#------------------------------------------------------#", "\n    ", "#   主干特征提取网络特征通用，冻结训练可以加快训练速度", "\n    ", "#   也可以在训练初期防止权值被破坏。", "\n    ", "#   Init_Epoch为起始世代", "\n    ", "#   Freeze_Epoch为冻结训练的世代", "\n    ", "#   Epoch总训练世代", "\n    ", "#   提示OOM或者显存不足请调小Batch_size", "\n    ", "#------------------------------------------------------#", "\n    ", "if", " ", "True", ":\n        batch_size  = Freeze_batch_size\n        lr          = Freeze_lr\n        start_epoch = Init_Epoch\n        end_epoch   = Freeze_Epoch\n                        \n        epoch_step      = num_train // batch_size\n        epoch_step_val  = num_val // batch_size\n        \n        ", "if", " epoch_step == ", "0", " ", "or", " epoch_step_val == ", "0", ":\n            ", "raise", " ValueError(", "\"数据集过小，无法进行训练，请扩充数据集。\"", ")\n        \n        optimizer       = optim.Adam(model_train.parameters(), lr, weight_decay = ", "5e-4", ")\n        lr_scheduler    = optim.lr_scheduler.StepLR(optimizer, step_size = ", "1", ", gamma = ", "0.96", ")\n\n        train_dataset   = FRCNNDataset(train_lines, input_shape, train = ", "True", ")\n        val_dataset     = FRCNNDataset(val_lines, input_shape, train = ", "False", ")\n        gen             = DataLoader(train_dataset, shuffle = ", "True", ", batch_size = batch_size, num_workers = num_workers, pin_memory=", "True", ",\n                                    drop_last=", "True", ", collate_fn=frcnn_dataset_collate)\n        gen_val         = DataLoader(val_dataset  , shuffle = ", "True", ", batch_size = batch_size, num_workers = num_workers, pin_memory=", "True", ", \n                                    drop_last=", "True", ", collate_fn=frcnn_dataset_collate)\n\n        ", "#------------------------------------#", "\n        ", "#   冻结一定部分训练", "\n        ", "#------------------------------------#", "\n        ", "if", " Freeze_Train:\n            ", "for", " param ", "in", " model.extractor.parameters():\n                param.requires_grad = ", "False", "\n\n        ", "# ------------------------------------#", "\n        ", "#   冻结bn层", "\n        ", "# ------------------------------------#", "\n        model.freeze_bn()\n\n        train_util      = FasterRCNNTrainer(model, optimizer)\n\n        ", "for", " epoch ", "in", " ", "range", "(start_epoch, end_epoch):\n            fit_one_epoch(model, train_util, loss_history, optimizer, epoch, epoch_step, epoch_step_val, gen, gen_val, end_epoch, Cuda)\n            lr_scheduler.step()\n\n    ", "if", " ", "True", ":\n        batch_size  = Unfreeze_batch_size\n        lr          = Unfreeze_lr\n        start_epoch = Freeze_Epoch\n        end_epoch   = UnFreeze_Epoch\n\n        epoch_step      = num_train // batch_size\n        epoch_step_val  = num_val // batch_size\n        \n        ", "if", " epoch_step == ", "0", " ", "or", " epoch_step_val == ", "0", ":\n            ", "raise", " ValueError(", "\"数据集过小，无法进行训练，请扩充数据集。\"", ")\n\n        optimizer       = optim.Adam(model_train.parameters(), lr, weight_decay = ", "5e-4", ")\n        lr_scheduler    = optim.lr_scheduler.StepLR(optimizer, step_size=", "1", ", gamma = ", "0.96", ")\n\n        train_dataset   = FRCNNDataset(train_lines, input_shape, train = ", "True", ")\n        val_dataset     = FRCNNDataset(val_lines, input_shape, train = ", "False", ")\n        gen             = DataLoader(train_dataset, shuffle = ", "True", ", batch_size = batch_size, num_workers = num_workers, pin_memory=", "True", ",\n                                    drop_last=", "True", ", collate_fn=frcnn_dataset_collate)\n        gen_val         = DataLoader(val_dataset  , shuffle = ", "True", ", batch_size = batch_size, num_workers = num_workers, pin_memory=", "True", ", \n                                    drop_last=", "True", ", collate_fn=frcnn_dataset_collate)\n\n        ", "#------------------------------------#", "\n        ", "#   冻结一定部分训练", "\n        ", "#------------------------------------#", "\n        ", "if", " Freeze_Train:\n            ", "for", " param ", "in", " model.extractor.parameters():\n                param.requires_grad = ", "True", "\n\n        ", "# ------------------------------------#", "\n        ", "#   冻结bn层", "\n        ", "# ------------------------------------#", "\n        model.freeze_bn()\n\n        train_util      = FasterRCNNTrainer(model, optimizer)\n\n        ", "for", " epoch ", "in", " ", "range", "(start_epoch, end_epoch):\n            fit_one_epoch(model, train_util, loss_history, optimizer, epoch, epoch_step, epoch_step_val, gen, gen_val, end_epoch, Cuda)\n            lr_scheduler.step()\n\n", "\n", "运行结果及报错内容", "\n", "python train.py", "段错误 (核心已转储)", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "跑通代码"]], "Tag": "程序设计"}
