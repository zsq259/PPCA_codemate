{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;It is not allowed to define methods outside the package where the type is defined. This leaves you with a couple of options:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;Define the methods in the &lt;code&gt;models&lt;/code&gt; package. That's the simplest approach when dealing with your own code but of course won't work for 3rd-party types.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Create a regular function instead of a method (&lt;code&gt;func String(meter models.Meter) string&lt;/code&gt;). That might be less idiomatic, though (especially for the &lt;code&gt;String&lt;/code&gt; method), and also does not have access to private fields (unless you define the function in the &lt;code&gt;models&lt;/code&gt; package, in which case you could just define the method instead).&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;Create a new type embedding the original type. That would be a bit cumbersome to use but allows you to extend existing behavior. Something like this:&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;`&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    myTime := MyTime{time.Now()}\n    fmt.Println(myTime)        /* behaves as time.Time */ \n    fmt.Println(myTime.Foo())  /* also has extra methods */\n}\n\ntype MyTime struct {\n  time.Time\n}\n\nfunc (m MyTime) Foo() string {\n  return \"foo\"\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "定义新的类型", "Question": ["无法在非本地类型模型上定义新方法。", ["\n\n", "I want to put all my models in a shared ", "Common", " lib.", "\n\n", "So, I made a new repo: ", "gitlab.com/xxx/common", "\n\n", "Inside I put a package: ", "models", "\n\n", "Here is the definition of an object: ", "\n\n", "type Meter struct {\n    ID           string\n    OperationID  string\n    Type         ConsoProd\n    Unit         string\n    Timestep     time.Duration\n    Measures     []Measure \n    FetchMethod  AcquisitionMethod\n    Metadata     interface{}\n}\n", "\n\n", "Now, I want to use it in an external project, I do: ", "\n\n", "go get gitlab.com/xxx/common\n", "\n\n", "And Go Modules will download it.", "\n\n", "I import use it like that:", "\n\n", "import \"gitlab.com/xxx/common/models\"\n\n//String transparent method\nfunc (meter models.Meter) String() string {\n    var stringifyMeter string\n    stringifyMeter += \"Meter \" + meter.ID + \" is a \" + meter.Type.String() + \" and compute in operation #\" + meter.OperationID + \".\"\n    return stringifyMeter\n}\n", "\n\n", "But Goland will not resolve it, and when I compile, I get: ", "\n\n", "cannot define new methods on non-local type models.Meter\n", "\n\n", "Why is it happening and what can I do to fix it ?", "\n    "]], "Tag": "程序设计"}
{"Answer": "int main()\r\n{\r\n    list_iterator&lt;CData, list_node&lt;CData&gt;&gt; it2;\r\n    it2++;\r\n}\r\n it2++;请改为++it2，因为你没定义it2++。以上", "Konwledge_Point": "定义新的类型", "Question": ["C++模板错误：不定义该运算符或到预定义运算符可接收的类型的转换", ["// 代码如下：", "\n\n", "#pragma once\n\ntemplate<typename _T>\nclass list_node\n{\npublic:\n    _T Data;\n    bool bValid;\n    list_node<_T> *pPrev;\n    list_node<_T> *pNext;\n\n    list_node() {}\n    ~list_node() {}\n};\n\ntemplate<typename _DATA, typename _NODE=list_node<_T_DATA>>\nclass list_iterator\n{\npublic:\n    list_iterator() { _ptr = NULL; }\n    ~list_iterator() {}\n\n    _NODE* _ptr;\n\n    list_iterator<_DATA, _NODE>& operator++()\n    {\n        _ptr = _ptr->pNext;\n        return *this;\n    }\n};\n\nclass list_test\n{\npublic:\n    list_test() {}\n    ~list_test() {}\n};\n\nstruct CData\n{\n    CData() {}\n    CData(int a){x = a;}\n    ~CData() {}\n    int x;\n};\n\nint main()\n{\n    list_iterator<CData, list_node<CData>> it2;\n    it2++;\n}\n", "\n\n", "程序报如下错误：", "\n\n", "1>------ 已启动生成: 项目: LinkTest, 配置: Debug Win32 ------\n1>  LinkTest.cpp\n1>d:\\work\\linktest\\test1.h(50): error C2676: 二进制“++”:“list_iterator<CData,list_node<CData>>”不定义该运算符或到预定义运算符可接收的类型的转换\n====生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ====\n", "\n\n", "问题：明明定义了 operator++()，为什么没有定义？"]], "Tag": "程序设计"}
{"Answer": "比较好的办法是用矩阵运算，而不是对每个元素自己写计算操作。opencv内部有些SIMD计算加速，或者显卡加速等机制，比循环效率高。\r\n参考： \r\n[https://blog.csdn.net/spw_1201/article/details/53482877](https://blog.csdn.net/spw_1201/article/details/53482877 \"\")", "Konwledge_Point": "定义新的类型", "Question": ["c++如何根据变量的值决定另一个变量的类型？", ["比如我要对opencv矩阵中的每个元素取对数，矩阵元素的类型有uchar,char,ushort,short,int,float,double7种，但7种都是数值类型，我想返回一个与输入矩阵size和type都相同的对数矩阵，我该怎么做，如果用条件判断我该用什么保存数据类型，试过#define，typedef好像都不行，#define在预编译期间就会确定，条件语句无法约束它，typedef会重定义报错。", "\n\n", "比如下面代码中的ELEMTYPE应该怎么实现：", "\n\n", "Mat logImg(Mat img){\n    Mat res(img.size(), CV_8U);\n    if (img.channels() == 3) {\n        cvtColor(img, img, CV_BGR2GRAY);\n    }\n    switch(img.depth()){\n        case CV_8U:\n            //ELEMTYPE=uchar;\n        case CV_8S:\n            //ELEMTYPE=char;\n        case CV_16U:\n            //ELEMTYPE=ushor;\n        case CV_16S:\n            //ELEMTYPE=short;\n        case CV_32S:\n            //ELEMTYPE=int;\n        case CV_32F:\n            //ELEMTYPE=float;\n        case CV_64F:\n            //ELEMTYPE=double;\n    }\n    for(int i=0;i<img.rows;i++){\n        for(int j=0;j<img.cols;j++){\n            res.at<uchar>(i,j)=(uchar)(log(img.at<ELEMTYPE>(i,j)+1)*255/log(256));\n        }\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;示例代码如下&lt;br /&gt;&lt;strong&gt;有帮助望采纳&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;pastebin&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; s[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c;\n} ps;\n\n&lt;span class=\"hljs-function\"&gt;ps &lt;span class=\"hljs-title\"&gt;func&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;\n&lt;/span&gt;{\n    ps *a &amp;#61; &lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(ps));\n    a-&amp;gt;b &amp;#61; x;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *a;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;/* code */&lt;/span&gt;\n    ps x &amp;#61; &lt;span class=\"hljs-built_in\"&gt;func&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, x.b);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["如果用c语言定义了一个矩阵类型Matrix ，如何定义一个新函数返回矩阵类型", ["如果用c语言定义了一个矩阵类型Matrix ，如何定义一个新函数返回矩阵类型 "]], "Tag": "程序设计"}
{"Answer": "1、更改子类属性名程，不然系统默认你是重写父类的方法，因为返回类型不一致所以报错。\r\n2、首先要看该方法的使用范围，\r\n\t\t\t如果是private，那么这样定义是没有问题的。\r\n\t\t\t如果不是private的。我们知道，子类是可以访问父类的非private方法。这样的话，如果子类有和父类同名不同返回类型的方法，就相当于在一个类中有两个同名不同返回类型的方法，这在java中犯了二异性的错误，是不允许的。", "Konwledge_Point": "定义新的类型", "Question": ["父类和子类中属性同名但不同类型怎么处理啊？", ["在父类中有private int a；", "\n在子类中有private Object a；", "\n然后在后面的方法返回值类型上就出错了，有冲突，怎么解决啊？本人新手，请大神指教"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;code&gt;time&lt;/code&gt; isn't a type. &lt;code&gt;time.Time&lt;/code&gt; is. See the package docs for the types: &lt;a href=\"http://golang.org/pkg/time/\"&gt;http://golang.org/pkg/time/&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;import time\n\ntype Person struct {\n    Name string\n    DateJoined time.Time\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "定义新的类型", "Question": ["在golang中定义新的时间类型", ["\n\n", "I want to have a struct like this:", "\n\n", "type Person struct {\n    Name string\n    DateJoined time\n}\n", "\n\n", "But this struct will not compile, because there is no type ", "time", ", isn't it?\nShould I alternatively use a ", "string", " and insert the time / date information there?", "\n    "]], "Tag": "程序设计"}
{"Answer": "不太明白那个distance什么意思    能表述清晰点吗\r\nclass Point{\r\n\tprivate double x = 0, y = 0;\r\n\tpublic Point() {\r\n\t\tthis.x = 0;\r\n\t\tthis.y = 0;\r\n\t}\r\n\tpublic Point(double x , double y) {\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t}\r\n\tpublic double getX() {\r\n\t\treturn x;\r\n\t}\r\n\tpublic void setX(double x) {\r\n\t\tthis.x = x;\r\n\t}\r\n\tpublic double getY() {\r\n\t\treturn y;\r\n\t}\r\n\tpublic void setY(double y) {\r\n\t\tthis.y = y;\r\n\t}\r\n\tpublic double distance(int nx, int ny) {\r\n\t\treturn  Math.sqrt(Math.pow((nx - this.x), 2) + Math.pow(ny - this.y, 2));\r\n\t}\r\n}", "Konwledge_Point": "定义新的类型", "Question": ["java设计一个名为Point的类，表示一个带x坐标和y坐标的点。该类包括： 两个带get方法的数据域x和y分别表示它们的坐标。", ["1.设计一个名为Point的类，表示一个带x坐标和y坐标的点。该类包括：", "\n两个带get方法的数据域x和y分别表示它们的坐标。", "\n一个创建点(0,0)的无参构造方法。", "\n一个创建特定坐标点的构造方法。", "\n一个名为distance的方法，返回从该点到Point类型的指定点之间的距离。", "\n一个名为distance的方法，返回从该点到指定x和y坐标的指定点之间的距离。", "\n编写一个测试类，创建两个点(0,0)和(10,30.5)，并显示它们之间的距离。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Your format string is using the wrong &lt;a href=\"https://godoc.org/time#Parse\" rel=\"nofollow noreferrer\"&gt;reference date&lt;/a&gt; (&lt;code&gt;2006-01-02 15:04:05&lt;/code&gt;). It should be the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;const longForm2 = \"2006/01/02 15:04:05\"\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "定义新的类型", "Question": ["Golang时间。解析定义新格式类型[重复]", ["\n\n", "\n    ", "This question already has an answer here:", "\n    ", "\n", "\n            ", "Go: time.Format: how to understand meaning of '2006-01-02' layout?", "\n                \n                    3 answers\n                \n        ", "\n    ", "\n", "\n\n", "I am trying to parse a date of the format \"2017/02/28 17:07:54\". I am using the time.Parse method.", "\n\n", "playground example: ", "https://play.golang.org/p/B_hnws1AGv", "\n\n", "This is failing. It produces a time object: 0001-01-01 00:00:00 +0000 UTC (which clearly is not the date I am trying to parse). ", "\n\n", "How can I parse a date of this format? My end goal is to convert  \"2017/02/28 17:07:54\" to \"Feb 28\" Note that I do not want \"February 28\" I want \"Feb 28.\"", "\n\n", "I have looked at the following links:", "\n\n", "\n", "How to convert date format in golang?", "\n", "Parsing date string in golang", "\n", "\n", "</div>\n", "\n"]], "Tag": "程序设计"}
{"Answer": "这个要问出题的人，按照我的理解，增加对类类型的支持应该就是泛型模板里\r\n```\r\ntemplate &lt;class T&gt;\r\n```用class\r\n\r\n这个是题目的要求，你也只有一个类，实际开发中也并不会每个类都重载运算符。", "Konwledge_Point": "定义新的类型", "Question": ["是不是每定义一个新类都要进行输出运算符重载？实在不知道该怎样理解“增加对类类型数据的支持”这句话", ["1、将程序调试通过后，用模板类改写；", "\n2、加入按值查找的基本操作，求线性表中值为x的元素序号；", "\n3、增加对类类型数据的支持。", "\n输出的参考样张如下所示。", "\n\n", "#include <iostream>           //引用输入输出流库函数的头文件\nusing namespace std;\n\n/////////////////////////////////////\n////  功能3.  增加对类类型的支持 ////\n\nclass B\n{\npublic:\n    B(int i = 0) :data(i) {}\n    friend ostream& operator<<(ostream& stream, B b);\n    int getdata() { return data; }\nprivate:\n    int data;\n};\n\nostream& operator <<(ostream& out, B b)\n{\n    out << b.getdata();\n    return out;\n}\n\n\nconst int MaxSize = 10;    //10只是示例性的数据，可以根据实际问题具体定义\ntemplate <class T>\nclass SeqList\n{\npublic:\n    SeqList() { length = 0; }       //无参构造函数，创建一个空表\n    SeqList(T a[], int n);       //有参构造函数\n    void Insert(int i, T x);   //在线性表中第i个位置插入值为x的元素\n    T Delete(int i);        //删除线性表的第i个元素\n    void PrintList();      //遍历线性表，按序号依次输出各元素\n    int Locate(T x);\nprivate:\n    T data[MaxSize];      //存放数据元素的数组\n    int length;            //线性表的长度\n};\n\ntemplate <class T>\nSeqList<T>::SeqList(T a[], int n)\n{\n    if (n > MaxSize) throw \"参数非法\";\n    for (int i = 0; i < n; i++)\n        data[i] = a[i];\n    length = n;\n}\n\ntemplate<class T>\nvoid SeqList<T>::Insert(int i, T x)\n{\n    if (length >= MaxSize) throw \"上溢\";\n    if (i<1 || i>length + 1) throw \"位置非法\";\n    for (int j = length; j >= i; j--)\n        data[j] = data[j - 1];   //注意第j个元素存在数组下标为j-1处\n    data[i - 1] = x;\n    length++;\n}\n\ntemplate<class T>\nT SeqList<T>::Delete(int i)\n{\n    if (length == 0) throw \"下溢\";\n    if (i<1 || i>length) throw \"位置非法\";\n    int x = data[i - 1];\n    for (int j = i; j < length; j++)\n        data[j - 1] = data[j];   //注意此处j已经是元素所在的数组下标\n    length--;\n    return x;\n}\n\ntemplate<class T>\nvoid SeqList<T>::PrintList()\n{\n    for (int i = 0; i < length; i++)\n        cout << data[i] << \"  \";\n    cout << endl;\n}\n\n\ntemplate<class T>\nint SeqList<T>::Locate(T x)\n{\n    for (int i = 0; i < length; i++)\n    {\n        if (data[i] == x)\n        {\n            return i + 1;\n            break;\n        }\n    }\n}\n\n\n\nint main()\n{\n    int r[5] = { 1, 2, 3, 4, 5 };\n    SeqList<int> L(r, 5);\n    cout << \"执行插入操作前数据为：\" << endl;\n    L.PrintList();              //输出所有元素\n    L.Insert(2, 3);\n    cout << \"执行插入操作后数据为：\" << endl;\n    L.PrintList();              //输出所有元素\n\n/////////////////////////////////////\n//// 功能2.  增加按值查找的功能  ////\n    cout << \"值为3的元素位置为:\";\n    cout << L.Locate(3) << endl;    //查找元素3，并返回在单链表中位置\n\n/////////////////////////////////////\n//// 功能3.  增加对类类型的支持  ////\n    cout << \"支持类类型的数据元素:\";\n    B b[3] = { B(10),B(20),B(30) };\n    SeqList<B> list(b, 3);\n    list.PrintList();\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "构造函数是用来说明对象的。构造函数可以有任意类型的参数，但是不能有返回值。在你对一个对象进行初始化的时候要调用构造函数。并且构造函数不能定义在在私有部分。还有，构造函数的函数名为类名。就像你上面说的Book类，如下\r\n\r\n```\r\n#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nclass Book\r\n{\r\npublic :\r\n    string Bookname;\r\n    int Bookprince;\r\n    Book(string name);                      //有一个参数的构造函数\r\n    Book(string name,int prince);           //有两个参数的构造函数\r\n    ~Book();                                //析构函数\r\n};\r\n\r\nBook::Book(string name)                     //构造函数不需要返回值\r\n{\r\n    Bookname = name;\r\n    Bookprince = 100;\r\n}\r\n\r\nBook::Book(string name,int prince)          //构造函数不需要返回值\r\n{\r\n    Bookname = name;\r\n    Bookprince = prince;\r\n}\r\n\r\nBook::~Book()                               //析构函数用于在对象生命结束的时候自动调用\r\n{\r\n    cout &lt;&lt; \"The Book is over\" &lt;&lt; endl;\r\n}\r\n\r\nint main()\r\n{\r\n    Book book1(\"c++\"),book2(\"c语言\",50);          //用构造函数进行初始化\r\n    cout &lt;&lt; book1.Bookname &lt;&lt; \"  \" &lt;&lt; book1.Bookprince &lt;&lt; endl;\r\n    cout &lt;&lt; book2.Bookname &lt;&lt; \"  \" &lt;&lt; book2.Bookprince &lt;&lt; endl;\r\n    return 0;\r\n}\r\n```\r\n\r\n而像构造函数这种函数名称相同但是参数不同实现的代码也有区别，在调用的时候根据参数类型和数目决定调用哪个函数。这种方式称为函数重载。", "Konwledge_Point": "定义新的类型", "Question": ["c++构造函数和函数重载", ["定义书类Book类：", "\n1）  每本书的信息包含有书名（C++string类型）和单价；", "\n2）  定义两个构造函数：带一个参数的构造函数、带两个参数的构造函数", "\n       在主函数内测试，分别调用这两个构造函数，完成对象的初始化。", "\n注意：使用string类", "\n新手小白构造函数老师讲的太快没学懂，有大佬帮忙解析一下吗，", "\n相关链接注释更好。"]], "Tag": "程序设计"}
{"Answer": "class newtype\r\n{\r\npublic long val1;\r\npublic short val2;\r\n}", "Konwledge_Point": "定义新的类型", "Question": ["如何java中定义一个包含short和long新的数据类型", ["rt   就像java对short的封装  还有一些数据元信息   初来乍到 不会搞"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为你的构造函数是2个参数&amp;#xff0c;但是在main函数中&amp;#xff0c;你只写了1个参数&amp;#xff0c;编译器找不到合适的构造函数。&lt;br /&gt;把main函数中的 Array  test(b); 改成 Array  test(b,4); 就可以了&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["如何在主程序中定义数组 int b[ ][4]作为原始数组。定义一个 Array 类对象 test，用 b 初始化 test，现在主函数test（b）报错了", ["\n", "#", "include", "<iostream>", "\n", "#", "include", " ", "<iomanip>", "\n\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Array", "             ", "//创建Array类", "\n{\n", "private", ":\n    ", "int", " a[", "4", "][", "4", "];        ", "//新创建一个数组装传入的数据", "\n", "public", ":\n    ", "Array", "(", "int", " a1[][", "4", "],", "int", " n);\n    ", "friend", " ", "void", " ", "xuanzhuan", "(Array& b)", "; ", "//定义顺时针翻转", "\n    ", "void", " ", "show", "()", ";\n};\nArray::", "Array", "(", "int", " a1[][", "4", "], ", "int", " n)        ", "//通过遍历给Array内的b[][]赋值", "\n{\n    ", "int", " i, j;\n\n    ", "for", " (i = ", "0", "; i < ", "4", "; i++)\n    {\n        ", "for", " (j = ", "0", "; j < ", "4", "; j++)\n        {\n            a[i][j] = a1[i][j];\n        }\n        cout << endl;\n    }\n}\n\n", "void", "  ", "xuanzhuan", "(Array& b)", "\n", "{\n    ", "int", " i, j, t;\n    ", "int", " c[", "4", "][", "4", "];\n    ", "for", " (i = ", "0", "; i < ", "4", "; i++)\n        ", "for", " (j = ", "0", "; j < ", "4", "; j++)\n        {\n            c[i][j] = b.a[i][j];\n        }\n    ", "for", " (i = ", "0", "; i < ", "4", "; i++)\n        ", "for", " (j = ", "0", "; j < ", "4", "; j++)\n        {\n            b.a[i][j] = c[", "3", " - j][i];\n        }\n}\n", "void", "  Array:: ", "show", "()\n{\n    ", "for", " (", "int", " i = ", "0", "; i < ", "4", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < ", "4", "; j++)\n        {\n            cout << ", "setw", "(", "4", ") << right << a[i][j];\n        }\n        cout << endl;\n    }\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " b[][", "4", "] = { ", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", ",", "10", ",", "11", ",", "12", ",", "13", ",", "14", ",", "15", ",", "16", " };\n    ", "for", " (", "int", " i = ", "0", "; i < ", "4", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < ", "4", "; j++)\n\n        cout << ", "\"next\"", " << endl;\n    } \n    ", "Array  ", "test", "(b)", ";\n    test.", "show", "();\n    ", "xuanzhuan", "(test);\n    test.", "show", "();\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "typedef int disjset[munset+1];\r\n就是指以后你看到代码中有disjset，你就脑补下，它就是int[]。\r\n\r\n也就是看到void initialize(disjset s)\r\n你就看作void initialize(int s[])", "Konwledge_Point": "定义新的类型", "Question": ["c语言typedef定义int型数组问题", ["这个题目描述的不好，我也不知道如何描述。。", "\n在数据结构和算法分析这本书上有这样一段代码：", "\n\n", " typedef int disjset[munset+1];\n//这里的定义数组可以直接这样吗？\n//或者这里定义的是一个数据类型？\nvoid initialize(disjset s)//因为disjset是数据类型所以这里可以定义一个新的数组？\n{\n    for(int i=numset;i>0;i--)\n        s[i]=0;\n}\n", "\n\n", "我就是觉得这里的数组刷新了我之前对数组的映像，，以及，typedef好神奇好费解", "\n希望懂的朋友可以给我讲一下里面的原理，谢谢啦！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/248512654846110.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\nusing &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;std&lt;/span&gt;;\n\ntemplate&amp;lt;typename T&amp;gt;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;SingleLinkedList&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;SLNode&lt;/span&gt;\n    &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        T _data;\n        SLNode* next;\n\n        SLNode()\n        {\n            &lt;span class=\"hljs-comment\"&gt;//this-&amp;gt;_data &amp;#61; 0;&lt;/span&gt;\n            this-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        }\n    };\n    SLNode* _head;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; _count;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n\n    SingleLinkedList()\n    {\n        _head &amp;#61;  &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; SLNode();\n        _head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//SLNode&amp;lt;T&amp;gt;* _head &amp;#61; NULL;&lt;/span&gt;\n        this-&amp;gt;_count &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; push_back( T data)\n    {\n        SLNode* new_node &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; SLNode();\n        new_node-&amp;gt;_data &amp;#61; data;\n        new_node-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n\n        SLNode* last_node &amp;#61; _head;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; _count; i&amp;#43;&amp;#43;)\n        {\n            last_node &amp;#61; last_node-&amp;gt;next;\n        }\n        new_node-&amp;gt;next &amp;#61; last_node-&amp;gt;next;\n        last_node-&amp;gt;next &amp;#61; new_node;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; insert(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pos, T data)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (_head &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n        {\n            pos &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n        SLNode* new_node &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; SLNode();\n        new_node-&amp;gt;_data &amp;#61; data;\n        new_node-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n\n        SLNode* pos_node &amp;#61; _head;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; pos; i&amp;#43;&amp;#43;)\n            pos_node &amp;#61; pos_node-&amp;gt;next;\n        new_node-&amp;gt;next &amp;#61; pos_node-&amp;gt;next;\n        pos_node-&amp;gt;next &amp;#61; new_node;\n        _count&amp;#43;&amp;#43;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; show()\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (_count &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;该链表中没有数据&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            SLNode* pcurrent &amp;#61; _head-&amp;gt;next;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pcurrent !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n            {\n                cout &amp;lt;&amp;lt; pcurrent-&amp;gt;_data &amp;lt;&amp;lt; endl;\n                pcurrent &amp;#61; pcurrent-&amp;gt;next;\n            }\n            cout &amp;lt;&amp;lt; endl;\n        }\n    }\n\n};\n\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Student&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    Student();\n    Student(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; id, &lt;span class=\"hljs-keyword\"&gt;string&lt;/span&gt; name, &lt;span class=\"hljs-keyword\"&gt;float&lt;/span&gt; age, &lt;span class=\"hljs-keyword\"&gt;double&lt;/span&gt; score);\n    ~Student();\n    friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Student&amp;amp; s)\n    {\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;学号:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; s._id &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  姓名&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; s._name &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  年龄&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; s._age &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  成绩&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; s._score &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n\n    }\n    &lt;span class=\"hljs-keyword\"&gt;string&lt;/span&gt; str()\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;内部输出:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;学号:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; _id &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  姓名&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; _name &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  年龄&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; _age &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;  成绩&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; _score &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;;\n    };\n    Student&amp;amp; operator &amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Student&amp;amp; x)\n    {\n        this-&amp;gt;_id &amp;#61; x._id;\n        this-&amp;gt;_age &amp;#61; x._age;\n        this-&amp;gt;_score &amp;#61; x._score;\n        this-&amp;gt;_name &amp;#61; x._name;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *this;\n\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; _id;\n    &lt;span class=\"hljs-keyword\"&gt;string&lt;/span&gt; _name;\n    &lt;span class=\"hljs-keyword\"&gt;float&lt;/span&gt; _age;\n    &lt;span class=\"hljs-keyword\"&gt;double&lt;/span&gt; _score;\n\n};\nStudent::Student()\n{\n    _id &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    _name &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&lt;/span&gt;;\n    _age &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    _score &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\nStudent::Student(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; id, &lt;span class=\"hljs-keyword\"&gt;string&lt;/span&gt; name, &lt;span class=\"hljs-keyword\"&gt;float&lt;/span&gt; age, &lt;span class=\"hljs-keyword\"&gt;double&lt;/span&gt; score)\n{\n    _id &amp;#61; id;\n    _name &amp;#61; name;\n    _age &amp;#61; age;\n    _score &amp;#61; score;\n}\n\nStudent::~Student()\n{\n}\n\n\n\n\n\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n\n    Student s1 &amp;#61; { &lt;span class=\"hljs-number\"&gt;001&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;桑桑&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;18.0&lt;/span&gt;f,&lt;span class=\"hljs-number\"&gt;88.0&lt;/span&gt;l };\n    Student s2 &amp;#61; { &lt;span class=\"hljs-number\"&gt;002&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;稚稚&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8.0&lt;/span&gt;f,&lt;span class=\"hljs-number\"&gt;77.0&lt;/span&gt;l };\n    Student s3 &amp;#61; { &lt;span class=\"hljs-number\"&gt;000&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;渊渊&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;25.0&lt;/span&gt;f,&lt;span class=\"hljs-number\"&gt;99.0&lt;/span&gt;l };\n    SingleLinkedList&amp;lt;Student&amp;gt; L1;\n    cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl;\n    L1.push_back(s1);\n    L1.push_back(s2);\n    cout &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl;\n    L1.insert(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, s3);\n    L1.show();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于自定义单链表实现Student类型数据存放的问题，主要是结点的构造不太明白！(语言-c++)", ["实验要求： main 函数中利用单向链表类 SingleLinkedList， 定义和初始化一个 Student 类型的线性链表，在表中添加（push_back）和插入（insert）新的元素。", "\n", "结点的构造", "\n", "template", "<", "typename", " T>\n", "class", " ", "SLNode", "\n{\n", "public", ":\n    T _data;\n    SLNode<T>* next; \n    \n    ", "SLNode", "()\n    {\n        ", "this", "->_data = ", "NULL", ";\n        ", "this", "-> next = ", "NULL", ";\n    }\n};\n", "\n", "链表的实现", "\n", "template<typename T>\n", "class", " ", "SingleLinkedList", "\n", "{\n", "private", ":\n    SLNode<T>* _head;\n    ", "int", " _count;\n\n", "public", ":\n\n    SingleLinkedList()\n    {\n        SLNode<T>* _head = ", "NULL", ";\n        this->_count = ", "NULL", ";\n    }\n\n    ", "void", " push_back(SingleLinkedList* L, T data)\n    {\n        SLNode<T>* new_node = ", "new", " SLNode();\n        new_node->_data = data;\n        new_node->next = ", "NULL", ";\n\n        SLNode<T>* last_node = L->_head;\n        ", "for", " (", "int", " i = ", "0", "; i < _count; i++)\n        {\n            last_node = last_node->next;\n        }\n        new_node->next = last_node->next;\n        last_node->next = new_node;\n    }\n    ", "void", " insert(SingleLinkedList* L, ", "int", " pos, T data)\n    {\n        ", "if", " (L == ", "NULL", ")\n        {\n            pos = ", "0", ";\n        }\n        SLNode<T>* new_node = ", "new", " SLNode();\n        new_node->_data = data;\n        new_node->next = ", "NULL", ";\n\n        SLNode<T>* pos_node = L->_head;\n        ", "for", " (", "int", " i = ", "0", "; i < pos; i++)\n            pos_node = pos_node->next;\n        new_node->next = pos_node->next;\n        pos_node->next = new_node;\n        L->_count++;\n    }\n\n    ", "void", " show(SingleLinkedList* L)\n    {\n        ", "if", " (L->_count == ", "0", ")\n            cout << ", "\"该链表中没有数据\"", " << endl;\n        ", "else", " {\n            SLNode<T>* pcurrent = L->_head->next;\n            ", "while", " (pcurrent != ", "NULL", ")\n            {\n                cout << pcurrent->_data << endl;\n                pcurrent = pcurrent->next;\n            }\n            cout << endl;\n        }\n    }\n\n};\n\n", "\n", "测试函数", "\n", "int main()\n{\n    \n    Student ", "s1", " = { ", "001", ",", "\"桑桑\"", ",", "18", ".", "0", "f,", "88", ".", "0", "l };\n    Student ", "s2", " = { ", "002", ",", "\"稚稚\"", ",", "8", ".", "0", "f,", "77", ".", "0", "l };\n    Student ", "s3", " = { ", "000", ",", "\"渊渊\"", ",", "25", ".", "0", "f,", "99", ".", "0", "l };\n    SingleLinkedList<Student> L1;\n        cout << ", "s1", " << endl;\n    L1.push_back(&L1,", "s1", ");\n    L1.push_back(&L1,", "s2", ");\n    cout << ", "s1", " << endl;\n    L1.", "insert(&L1, ", "0", ", ", "s3", ");\n    L1.", "show(&L1);\n", "}\n\n", "\n", "Student类", "\n", "class Student\n{\npublic:\n    Student(int id, string ", "name", ", float age, double ", "score", ");\n    ~Student();\n    friend ostream& operator<<(ostream&os, const Student&s)\n    {\n       os << ", "\"学号:\"", " << s.", "_id", " << ", "\"  姓名：\"", " << s.", "_name", " << ", "\"  年龄\"", " << s.", "_age", " << ", "\"  成绩：\"", " << s.", "_score", " << ", "endl", ";\n            return os;\n        \n    }\n    string ", "str", "()\n    {\n        cout << ", "\"内部输出:\"", " << ", "endl", ";\n        cout << ", "\"学号:\"", " << ", "_id", " << ", "\"  姓名：\"", " << ", "_name", " << ", "\"  年龄\"", " << ", "_age", " << ", "\"  成绩：\"", " << ", "_score", " << ", "endl", ";\n        return ", "\"\\n\"", ";\n    };\n    Student& operator =(const Student&x)\n    {\n        this->", "_id", " = x.", "_id", ";\n        this->", "_age", " = x.", "_age", ";\n        this->", "_score", " = x.", "_score", ";\n        this->", "_name", " = x.", "_name", ";\n        \n    \n    }\n", "private", ":\n    int ", "_id", ";\n    string ", "_name", ";\n    float ", "_age", ";\n    double ", "_score", ";\n\n};\n\nStudent::Student(int id, string ", "name", ", float age, double ", "score", ")\n{\n    ", "_id", " = id;\n    ", "_name", " = ", "name", ";\n    ", "_age", " = age;\n    ", "_score", " = ", "score", ";\n}\n\nStudent::~Student()\n{\n}\n\n", "\n", "报错", "\n", "已启动生成…\n", "1", ">", "------ 已启动生成: 项目: ex4p4, 配置: Debug x64 ------", "\n", "1", ">p4.cpp\n", "1", ">", "C", ":\\Users\\", "86150", "\\source\\repos\\ex3\\dsa\\SingledLinkedList.h(", "83", ",", "1", "): ", "error", " ", "C2514", ": “SLNode”: 无法构建类模板\n", "1", ">", "C", ":\\Users\\", "86150", "\\source\\repos\\ex3\\dsa\\SingledLinkedList.h(", "7", "): message : 参见“SLNode”的声明\n", "1", ">", "C", ":\\Users\\", "86150", "\\source\\repos\\ex3\\dsa\\SingledLinkedList.h(", "83", "): message : 查看对正在编译的 类 模板 实例化“SingleLinkedList<T>”的引用\n", "1", ">已完成生成项目“ex4p4.vcxproj”的操作 - 失败。\n========== 生成: 成功 ", "0", " 个，失败 ", "1", " 个，最新 ", "1", " 个，跳过 ", "0", " 个 ==========\n\n错误    C2514    “SLNode”: 无法构建类模板    ex4p4    ", "C", ":\\Users\\", "86150", "\\source\\repos\\ex3\\dsa\\SingledLinkedList.h    ", "83", "    //", "83", "是最后一行，有点迷惑\n", "\n", "希望可以详细指出我的错误原因，以及如何改正"]], "Tag": "程序设计"}
{"Answer": "因为控制台里是在运行中，可以推断出类型，编辑器里推断不出是可能是因为reshape的返回值不能够直接推断出\r\n\r\n可以这样声明变量时显示指定类型，后面就可以了\r\n\r\n```\r\na:np.ndarray=np.arange(15).reshape(3,5)\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["新手提问：关于Pycharm中定义的变量，为何代码无法自动补全？", ["刚接触Python，正在学习Pycharm的使用，碰到代码无法自动补全的问题。", "\n（1）导入numpy包后，定义了变量 a 是一个ndarray，但a.后面没有相关的属性和方法提示。我猜测是否Pycharm无法判断a的类型，所以无法提示。如图：", "\n\n", "（2）如果是np.则没有问题，可以正确提示方法和属性。如图：", "\n\n", "（3）不过奇怪的是，相同的代码，如果在下方python console中，是不存在上述问题的，可以正确的提示。（conda的ipython中，按下tab后也是可以提示方法和属性的。）如下图：", "\n\n", "烦请大佬们帮忙解答下，是否我的pycharm设置有误。感谢大家。"]], "Tag": "程序设计"}
{"Answer": "char *des, char *src; int len;\r\n逗号改为分号", "Konwledge_Point": "定义新的类型", "Question": ["【球球大家了】VS2017出现error C2062: 意外的类型“char”怎么解决？", ["总而言之就是我的字符型指针定义不了。。", "\n1.我的代码出现了以下问题，网上冲浪也没能解决这个问题。求助", "\n2.错误类型", "\n1>------ 已启动生成: 项目: 字符串处理库, 配置: Debug Win32 ------", "\n1>字符串处理库.cpp", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(9): error C2062: 意外的类型“char”", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(11): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(13): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(14): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(16): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(18): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(20): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(21): error C2065: “src”: 未声明的标识符", "\n1>c:\\users\\57157\\desktop\\programdesign\\vs\\数据封装结构体习题自打\\字符串处理库\\字符串处理库\\字符串处理库.cpp(23): error C2065: “src”: 未声明的标识符", "\n1>已完成生成项目“字符串处理库.vcxproj”的操作 - 失败。", "\n========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ==========", "\n3.代码", "\n#include \"pch.h\"", "\n#include ", "\nusing namespace std;", "\nint main()", "\n{", "\n    char *des, char *src; int len;", "\n    cout << \"【复制】请输入2个字符串\";", "\n    cin >> des >> src;", "\n    cout << \"复制前des\"<\n    cout \n     stringCopy(des, src);//将src的内容复制到des中", "\n     cout \n     cout\n     cout \n     cin >> des >> src >> len;", "\n     cout << \"复制前des\" << des;", "\n     cout << \"复制前src\" << src;", "\n     stringNCopy(des, src,  len);//将src的前n个字符复制到des中", "\n     cout << \"复制后des\" << des;", "\n     cout << \"复制后src\" << src;", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Use &lt;a href=\"http://golang.org/pkg/reflect/#Type\"&gt;&lt;code&gt;reflect.Type.Elem()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;s := (*SomeType)(nil)\nt := reflect.TypeOf(s).Elem()\n\nv := reflect.New(t)\nsp := (*SomeType)(unsafe.Pointer(v.Pointer()))\nsp.A = 3\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Playground: &lt;a href=\"http://play.golang.org/p/Qq8eo-W2yq\"&gt;http://play.golang.org/p/Qq8eo-W2yq&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: Elwinar in comments below pointed out that you can get the struct without &lt;code&gt;unsafe.Pointer&lt;/code&gt; by using &lt;code&gt;reflect.Indirect()&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;s := (*SomeType)(nil)\nt := reflect.TypeOf(s).Elem()\n\nss := reflect.Indirect(reflect.New(t)).Interface().(SomeType)\nss.A = 3\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Playground: &lt;a href=\"http://play.golang.org/p/z5xgEMR_Vx\"&gt;http://play.golang.org/p/z5xgEMR_Vx&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "定义新的类型", "Question": ["使用nil指针定义的类型创建一个带有反射的新结构", ["\n\n", "I would like know if it is possible to allocate a struct from a type specified by a ", "nil", " pointer by using ", "reflect.New()", "\n\n", "type SomeType struct{\n   A int\n}\n\nsometype := (*SomeType)(nil)\n\nv := reflect.valueOf(sometype)\n// I would like to allocate a new struct based on the type defined by the pointer\n// newA := reflect.New(...)\n//\nnewA.A = 3\n", "\n\n", "How should I do this ?", "\n    "]], "Tag": "程序设计"}
{"Answer": "一般需要做对应的类型映射\r\nhttp://www.cnblogs.com/djcsch2001/archive/2010/07/19/1780992.html", "Konwledge_Point": "定义新的类型", "Question": ["Delphi的DLL中的声明的类型的问题", ["假如我在DLL中新定义了一个类，并且声明了 一个变量，那么我在加载这个DLL的程序中想要使用这个变量，需不需要重新将对应类型声明再在这个程序的源码文件中再声明一遍？", "\n就是怎么能让DLL中定义的新的数据类型也在加载它的程序中使用？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;WriteAction&lt;/span&gt; {\n\n  &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; write();\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Pen&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;WriteAction&lt;/span&gt;{\n\n  &lt;span class=\"hljs-keyword\"&gt;protected&lt;/span&gt; float price;\n\n  &lt;span class=\"hljs-keyword\"&gt;protected&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; color;\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Pen&lt;/span&gt;(){\n\n  }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Pen&lt;/span&gt;(float price, &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; color) {\n    &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;price&lt;/span&gt; &amp;#61; price;\n    &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;color&lt;/span&gt; &amp;#61; color;\n  }\n\n  &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;write&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n\n  }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; float &lt;span class=\"hljs-title function_\"&gt;getPrice&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; price;\n  }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setPrice&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;float price&lt;/span&gt;) {\n    &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;price&lt;/span&gt; &amp;#61; price;\n  }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getColor&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; color;\n  }\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setColor&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; color&lt;/span&gt;) {\n    &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;color&lt;/span&gt; &amp;#61; color;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;public &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Brush&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Pen&lt;/span&gt;&lt;/span&gt;{\n\n  public &lt;span class=\"hljs-type\"&gt;Brush&lt;/span&gt;() {\n  }\n\n  public &lt;span class=\"hljs-type\"&gt;Brush&lt;/span&gt;(float price, &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; color){\n    &lt;span class=\"hljs-keyword\"&gt;super&lt;/span&gt;(price, color);\n  }\n\n  &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n  public void write() {\n    &lt;span class=\"hljs-type\"&gt;System&lt;/span&gt;.out.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;现在使用的是价格为&amp;#34;&lt;/span&gt;&amp;#43; price &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;的&amp;#34;&lt;/span&gt;&amp;#43; color &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;颜色的画笔&amp;#34;&lt;/span&gt;);\n  }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\npublic &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Pencil&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Pen&lt;/span&gt;&lt;/span&gt;{\n\n  public &lt;span class=\"hljs-type\"&gt;Pencil&lt;/span&gt;() {\n  }\n\n  public &lt;span class=\"hljs-type\"&gt;Pencil&lt;/span&gt;(float price, &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; color) {\n    &lt;span class=\"hljs-keyword\"&gt;super&lt;/span&gt;(price, color);\n  }\n\n  &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n  public void write() {\n    &lt;span class=\"hljs-type\"&gt;System&lt;/span&gt;.out.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;现在使用的是价格为&amp;#34;&lt;/span&gt;&amp;#43; price &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;的&amp;#34;&lt;/span&gt;&amp;#43; color &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;颜色的铅笔&amp;#34;&lt;/span&gt;);\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Painter {\n\n  private String &lt;span class=\"hljs-type\"&gt;name&lt;/span&gt;;\n\n  &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; Painter(){\n\n  }\n\n  &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; Painter(String &lt;span class=\"hljs-type\"&gt;name&lt;/span&gt;) {\n    this.name &amp;#61; &lt;span class=\"hljs-type\"&gt;name&lt;/span&gt;;\n  }\n\n  &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; draw(Pen p){\n    &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;画家&amp;#34; &amp;#43; &lt;span class=\"hljs-type\"&gt;name&lt;/span&gt; &amp;#43; &amp;#34;正在绘画&amp;#34;);\n    p.&lt;span class=\"hljs-keyword\"&gt;write&lt;/span&gt;();\n  }\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Test&lt;/span&gt; &lt;/span&gt;{\n\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; void main(&lt;span class=\"hljs-keyword\"&gt;String&lt;/span&gt;[] args) {\n    Brush b1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Brush&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5.8&lt;/span&gt;f, &lt;span class=\"hljs-string\"&gt;&amp;#34;红色&amp;#34;&lt;/span&gt;);\n    Pencil p1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Pencil&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2.5&lt;/span&gt;f, &lt;span class=\"hljs-string\"&gt;&amp;#34;黑色&amp;#34;&lt;/span&gt;);\n    Painter painter &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Painter&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;王流秋&amp;#34;&lt;/span&gt;);\n    painter.draw(b1);\n    painter.draw(p1);\n  }\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&amp;#xff1a;&lt;br /&gt;画家王流秋正在绘画&lt;br /&gt;现在使用的是价格为5.8的红色颜色的画笔&lt;br /&gt;画家王流秋正在绘画&lt;br /&gt;现在使用的是价格为2.5的黑色颜色的铅笔&lt;/p&gt;\n&lt;p&gt;第二个差不多&amp;#xff0c;基本概念懂了就行&amp;#xff0c;望采纳&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["java面对对象多态", ["一:", "\n", "定义书写功能接口(WriteAction)", "a)抽象方法void  write() ", "\n", "定义笔类(Pen),实现WriteAction接口,重写write()方法,方法内不需要编写内容;", "a)属性: price价格（float类型), color颜色(String 类型);", "b)提供空参,满参构造方法和set/get方法;", "\n", "定义画笔类(Brush),继承 Pen", "a)重写Pen中write()方法：输出格式: \"现在使用的是价格为X的Y颜色的画笔\",其中X为Brush的价格,Y为Brush的颜色;", "b)提供空参,满参构造方法", "\n", "定义铅笔类(Pencil),继承 Pen", "a)重写Pen中write()方法: 输出格式: \"现在使用的是价格为X的Y颜色的铅笔\",其中X为Pencil的价格,Y为Pencil的颜色;", "b)提供空参,满参构造方法", "\n", "定义画家类（Painter)", "a)属性: name姓名(String)", "b)成员方法 : 绘画方法(void draw(Pen p)),首先输出\"画家X正在绘画\",然后调用p对象的write方法,其中X为Painter的姓名;", "c)提供空参,满参构造方法,set/get方法", "\n", "测试类Test", "a)提供main方法", "b)在main方法中", "i1.创建Brush类对象b1,价格赋值为5.8,颜色赋值为红色；", "i2.创建Pencil类对象p1,价格赋值为2.5,颜色赋值为黑色；", "i3.创建Painter对象,姓名赋值为王流秋;调用两次Painter的draw方法,分别传入b1和p1,进行测试", "\n", "\n", "二:", "1.定义接口Teach，要求如下：", "定义抽象方法  void teaching();", "\n", "2.定义类Teacher，实现接口Teach，包含空参构造，满参构造和以下成员变量", "姓名 name（String 类型）", "学科 course（String类型）", "实现抽象方法teaching(),在方法内输出\"我是X师傅,我教Y学科\"", "PS:  X表示姓名，Y表示学科", "\n", "3.定义Student类，包含空参构造，满参构造和以下成员变量", "姓名 name(String类型)", "分数 score(int 类型)", "师傅 Teacher  teacher", "\n", "定义一个无参无返回值的方法getMyResult(),实现要求如下:", "1).在方法内输出\"我是学生S,我的师傅是W,他教我Z学科\"", "PS:SS是学生的姓名,W是teacher的姓名,Z是teacher所教学科", "\n", "2).判断学员分数是否大于等于60分，如果大于等于60分,则输出\"继续加油哦\"", "如果小于60分,则输出\"成绩太低了,师傅W让我回去罚写100遍\"", "PS:W是teacher的姓名", "\n", "4.定义测试类(Test),在main方法中，创建教师对象、学生对象并赋值", "调用teaching()、getMyResult()方法", "\n", "三:", "1.定义手机类Phone", "行为:  打电话(call),发短信(sendMessage)", "2.定义接口IPlay", "行为: 玩游戏(play)", "3.定义旧手机类(OldPhone)继承手机类", "行为: 继承父类的行为", "4.定义新手机类(NewPhone)继承手机类实现IPlay接口", "行为: 继承父类的行为,重写玩游戏方法", "5.定义测试类(Test),创建对象并调用方法,运行效果如下(使用多态):", "旧手机打电话", "旧手机发信息", "新手机打电话", "新手机发信息", "新手机玩游戏 "]], "Tag": "程序设计"}
{"Answer": "他的意思是\r\n\r\n\r\n```\r\n#include &lt;stdio.h&gt;\r\n\r\nint main()\r\n{\r\n\tchar ch2 = 'FATE';\r\n\tchar grade = 'B';\r\n\tprintf(\"%c\\n\", grade);\r\n   \tgrade = ch2;\r\n\tprintf(\"%c\\n\", grade);\r\n\treturn 0;\r\n}\r\n```\r\n结果是\r\nB\r\nE\r\n\r\n短短一小段程序，你要理解内存怎么分布的，ascii怎么回事，还有，你用的X86 CPU是一种little endian的处理器。所以明明是 FATE 结果  E 跑前面去了，你一个不理解，就完全不理解。更糟糕的是，万一你用了手机写程序，而手机是 big endian的，那么结果输出就是BF了。\r\n\r\n初学者学 C语言能学到怀疑人生。\r\n\r\n顺便说一下，C语言不适合自学，学了也没啥卵用。\r\n很多人反驳说，C语言可以写操作系统啊，问题是你一个初学者又不是奔着为国家编写操作系统的使命去的，写操作系统和你有一毛钱关系不？\r\n如果你学C语言感觉困难很大，建议你换一种语言。", "Konwledge_Point": "定义新的类型", "Question": ["请大家帮帮萌新！！！", ["C语言自学中。。。。。", "\n\n", "C primer plus第三章中写道：", "\n\n", "奇怪的是C语言将字符常量视为int类型而非char类型。", "\n例如在int位32位 char为8位的ASCII系统中有下面代码", "\n\n", "char grade = ‘B‘，", "\n\n", "    本来‘B’对应的66储存在32位的储存单元中，现在却可以储存在八位的单元中（grade）。利用字符常量的这种特性，可以定义一个字符常量'FATE',即把四个独立的八位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grate,只有最后八位有效。因此，grade的值是'E'。\n\n    这段话怎么理解，为什么B就变成了E了，\n    66的二进制是1000010 八位储存是01000010\n    那FATE就是四个01000010\n    那么后八位是不是还是01000010吗？\n    那么为什么grade的值会变成‘E’\n    E的ASCII是69，换成二进制储存是01000101难道后八位是这个？\n    求解答！！！！！！！谢谢！！！！！！\n"]], "Tag": "程序设计"}
{"Answer": "强制转换成double再相加", "Konwledge_Point": "定义新的类型", "Question": ["C++新手作业，不知道是否正确？", ["C++:定义4个变量:int a; float b; char c; double d;变量的原始值从键盘输入。要求编写 程序，输出4个变量的值，并计算四个变量的和 并输出,不知道是否正确。", "\n\n", "#include ", "\nusing namespace std;", "\nint main()", "\n{int a;float b;char c;double d;", "\ncin>>a>>b>>c>>d;", "\ncout<<a<<'\\n';", "\ncout<<b<<'\\n';", "\ncout<<c<<'\\n';", "\ncout<<d<<'\\n';", "\ncout<<a+b+c+d<<endl;", "\nreturn 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "```\r\n\tvar src=你的数据\r\n\tvar desc=[];//你要的数据\r\n\tsrc.forEach((data)=&gt;{\r\n\t\t  desc.push({\r\n\t\t\t  \"proccessname\": data[\"procDef.name\"].substring(0,2),\r\n\t\t\t  \"curretprocess\": data[\"task.name\"],\r\n\t\t\t  \"createTime\":  new Date(parseInt(data[\"task.createTime\"])).toUTCString(),\r\n\t\t\t  \"applyUserId\": data[\"vars\"][\"applyUserId\"]\r\n\t\t  });\r\n\t  });\r\n\t  \r\n\r\n```\r\n\r\n最终的desc：\r\n\r\n```\r\n\r\n[\r\n    {\r\n        \"proccessname\":\"请假\",\r\n        \"curretprocess\":\"领导审核\",\r\n        \"createTime\":\"Thu, 23 May 2019 10:55:17 GMT\",\r\n        \"applyUserId\":\"张大壮\"\r\n    },\r\n    {\r\n        \"proccessname\":\"请假\",\r\n        \"curretprocess\":\"领导审核\",\r\n        \"createTime\":\"Thu, 09 May 2019 10:54:32 GMT\",\r\n        \"applyUserId\":\"lilaoshi\"\r\n    },\r\n    {\r\n        \"proccessname\":\"请假\",\r\n        \"curretprocess\":\"领导审核\",\r\n        \"createTime\":\"Thu, 09 May 2019 09:09:41 GMT\",\r\n        \"applyUserId\":\"李三\"\r\n    }\r\n]\r\n\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["微信小程序中关于返回数据的操作", ["请问如何在服务器返回的数据中提取出我需要的那部分", "\n以下是服务器返回的数据", "\n\n", "    [{\n      \"procDef.name\": \"请假流程\",\n      \"task.assignee\": \"admin\",\n      \"task.executionId\": \"a25a1287decc4aea97fda5c8c4a49e4a\",\n      \"task.name\": \"领导审核\",\n      \"count\": \"11\",\n      \"task.createTime\": 1558608917000,\n      \"procDef.version\": 5,\n      \"task.id\": \"ffbf1b3ca9f543eea2402d3c365900e2\",\n      \"task.taskDefinitionKey\": \"node0\",\n      \"task.processInstanceId\": \"a25a1287decc4aea97fda5c8c4a49e4a\",\n      \"vars\": {\n        \"busId\": \"ad629b4986a34f0bace9892cfc1b8788\",\n        \"type\": \"tealeave\",\n        \"title\": \"11\",\n        \"applyUserId\": \"张大壮\"\n      },\n      \"status\": \"todo\"\n    }, {\n      \"procDef.name\": \"请假流程\",\n      \"task.assignee\": \"admin\",\n      \"task.executionId\": \"e8065adf4db344fc92165c732ed85156\",\n      \"task.processDefinitionId\": \"tealeave:5:e1b5cc7f26744495b7340434876fc8fc\",\n      \"task.name\": \"领导审核\",\n      \"count\": \"11\",\n      \"task.createTime\": 1557399272000,\n      \"procDef.version\": 5,\n      \"task.id\": \"99f7797ddad14969ad477a050fcee336\",\n      \"task.taskDefinitionKey\": \"node0\",\n      \"task.processInstanceId\": \"e8065adf4db344fc92165c732ed85156\",\n      \"vars\": {\n        \"busId\": \"288dee733e074e73becbd5bf889b2447\",\n        \"type\": \"tealeave\",\n        \"title\": \"youshi\",\n        \"applyUserId\": \"lilaoshi\"\n      },\n      \"status\": \"todo\"\n    }, {\n      \"procDef.name\": \"请假流程\",\n      \"task.assignee\": \"admin\",\n      \"task.executionId\": \"5fcb2da62b8042dfaae7a6dead57eb3b\",\n      \"task.processDefinitionId\": \"tealeave:5:e1b5cc7f26744495b7340434876fc8fc\",\n      \"task.name\": \"领导审核\",\n      \"count\": \"11\",\n      \"task.createTime\": 1557392981000,\n      \"procDef.version\": 5,\n      \"task.id\": \"0efe25339021449e9583c9e6395a1ea4\",\n      \"task.taskDefinitionKey\": \"node1\",\n      \"task.processInstanceId\": \"5fcb2da62b8042dfaae7a6dead57eb3b\",\n      \"vars\": {\n        \"busId\": \"5f88a073e4294cc78116011a3667a070\",\n        \"node0Pass\": true,\n        \"title\": \"噢噢噢噢哦哦哦哦哦哦\",\n        \"type\": \"tealeave\",\n        \"applyUserId\": \"李三\"\n      }]\n", "\n\n", "我只需要这些数据中几项", "\n\"procDef.name\"，\"task.name\",\"task.createTime\",还有\"vars\"中的\"applyUserId\"", "\n放入我下面的数据中：", "\n\n", "     info: [{\n      \"proccessname\": \"请假\",\n      \"curretprocess\": \"领导审核\",\n      \"createTime\": 1557399272000,\n      \"applyUserId\": \"张xx\"\n      }]\n", "\n\n", "直接赋值会有问题 比如proccessname=list[0].procDef.name 后面的name会报错说undefined ，请问如何处理", "\n\n", "另外 proccessname 只有前个字 比如'请假流程'只留'请假'2字 ", "\n\n", "createTime时间戳转换到年-月-日格式", "\n\n", "谢谢 新手真不太会"]], "Tag": "程序设计"}
{"Answer": "经过几番实验和查阅文档，得出结论：\r\n这个重复引用/强制转换（自己强转成自己）的问题，是由于编译器对App_Code文件夹特殊处理造成的。\r\n我的理解和解释如下（欢迎纠正）：\r\n\r\nApp_Code文件夹下的文件，会在运行时进行编译，这也是为什么我们创建在App_Code文件夹下的.cs文件默认生成操作是“内容”而不是“编译”了。这个目录的作用，是存放那些需要动态修改的代码（我的理解就像asp），这个目录下的代码，是以源码形式存在于项目中，等到访问时才进行编译（这也解释了为什么我遇到的这个错误，编译可以通过，但是运行时会报错）。当访问这个目录下的类时，这个类就被第二次编译，所以会出现重复定义/类型不明确需要强制转换的问题。根据《在ASP.NET Web Application中使用App_Code文件夹引发的异常》这篇文章的解释，如果用反编译工具打开Temporary ASP.NET Files文件夹下我们项目相关的那个DLL，应该可以看到App_Code下面的类被二次编译（我没有实验，但我感觉是可能的）。\r\n\r\n解决办法：\r\n\r\n由于我是先解决的问题，然后再寻求的原因。所以我的解决办法是采用了caozhy同学的建议，将App_Code下所有共享的代码剪切出来创建了一个新的Library，然后在WebApplication里引用了这个Library，由于这样，App_Code下就不存在代码了，所以我的问题也相当于变相的解决了。\r\n同样的解决办法还有，就像我刚刚那样，重新创建一个非App_Code目录，存放那些公用代码，结论也是可行的。\r\n\r\n参考：\r\n\r\n《在ASP.NET Web Application中使用App_Code文件夹引发的异常》\r\n《Shared Code Folders in ASP.NET Web Site Projects》\r\n《App_Code folder doesn’t work with Web Application Projects (WAPs)》", "Konwledge_Point": "定义新的类型", "Question": ["同类型为什么要强制转换（自己强转成自己）/ASP.NET Web程序重复引用（引用来自同一文件）问题（已解决）？", ["最后的补充和结论", "\n\n", "经过几番实验和查阅文档，得出结论：", "\n这个重复引用/强制转换（自己强转成自己）的问题，是由于编译器对App_Code文件夹特殊处理造成的。", "\n我的理解和解释如下（欢迎纠正）：", "\n\n", "\n", "App_Code文件夹下的文件，会在运行时进行编译，这也是为什么我们创建在App_Code文件夹下的.cs文件默认生成操作是“内容”而不是“编译”了。这个目录的作用，是存放那些需要动态修改的代码（我的理解就像asp），这个目录下的代码，是以源码形式存在于项目中，等到访问时才进行编译（这也解释了为什么我遇到的这个错误，编译可以通过，但是运行时会报错）。当访问这个目录下的类时，这个类就被第二次编译，所以会出现重复定义/类型不明确需要强制转换的问题。根据《在ASP.NET Web Application中使用App_Code文件夹引发的异常》这篇文章的解释，如果用反编译工具打开Temporary ASP.NET Files文件夹下我们项目相关的那个DLL，应该可以看到App_Code下面的类被二次编译（我没有实验，但我感觉是可能的）。", "\n", "\n\n", "解决办法：", "\n\n", "\n", "由于我是先解决的问题，然后再寻求的原因。所以我的解决办法是采用了caozhy同学的建议，将App_Code下所有共享的代码剪切出来创建了一个新的Library，然后在WebApplication里引用了这个Library，由于这样，App_Code下就不存在代码了，所以我的问题也相当于变相的解决了。", "\n同样的解决办法还有，就像我刚刚那样，重新创建一个非App_Code目录，存放那些公用代码，结论也是可行的。", "\n", "\n\n", "参考：", "\n\n", "\n", "《在ASP.NET Web Application中使用App_Code文件夹引发的异常》", "\n", "《Shared Code Folders in ASP.NET Web Site Projects》", "\n", "《App_Code folder doesn’t work with Web Application Projects (WAPs)》", "\n", "* 补充7：", "\n\n", "本着好奇学习的原则，我特意创建了一个包含错误的项目，上传到了github，求老师讲解。谢谢。", "https://github.com/awolfnet/test", "\n\n", "编译时有个警告，但可以编译通过，但运行时会报错", "\n\n", "编译警告：", "\n\n", "CS0266  无法将类型“EEGProxy.App_Code.HTTP.METHOD [App_Web_r13cya2o, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]”隐式转换为“EEGProxy.App_Code.HTTP.METHOD [EEGProxy, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]”。存在一个显式转换(是否缺少强制转换?)  EEGProxy    E:\\visualstudio2015\\Projects\\EEGProxy\\EEGProxy\\App_Code\\Prerouting.cs   38  \n", "\n\n", "运行时错误：", "\n\n", "编译器错误消息: CS0266: Cannot implicitly convert type 'EEGProxy.App_Code.HTTP.METHOD [E:\\visualstudio2015\\Projects\\EEGProxy\\EEGProxy\\App_Code\\Utils\\HTTP.cs(19)]' to 'EEGProxy.App_Code.HTTP.METHOD [C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Temporary ASP.NET Files\\eegproxy\\728b4be6\\64b07da6\\assembly\\dl3\\5c9e5e68\\1dd6f07e_a892d401\\EEGProxy.dll]'. An explicit conversion exists (are you missing a cast?)\n", "\n\n", "首先定义绝对没有重复，这个我是确认过了的。", "\n\n", "查找了不少资料，大部分都说是自己引用了自己，但是我无论在项目属性里的引用页面、还是解决方案资源管理器里的“引用”树形目录里，都没有发现对项目自身的引用。", "\n\n", "这个错误有时候会自己消失，有时候会出现，这些代码都放在APP_CODE目录下，.cs文件的生成操作已经改成了“编译”。", "\n\n", "异常代码：", "\n\n", "        public RoutedPackageModel RoutePackage(HTTP.METHOD method, string path, HttpRequestHeaders headers, byte[] payload)\n        {\n            _routedPackage.Payload = payload;\n            _routedPackage.Headers = CopyHeadersFrom(headers);\n            _routedPackage.Headers.Add(HttpRequestHeader.ContentType, \"application/json\");\n            _routedPackage.Destination = GetDestinationInRouteTable(headers.Host);\n            _routedPackage.Method = method; <<-此句会报错\n            _routedPackage.Path = path;\n            return _routedPackage;\n        }\n", "\n\n", "##**相关类：**", "\n\n", "    public class RoutedPackageModel\n    {\n        public enum ACTION\n        {\n            DROP,\n            REJECT,\n            ACCEPT,\n        }\n\n        public HTTP.METHOD Method { set; get; }\n\n        public string Initiator { set; get; }\n        public string Source { set; get; }\n        public string Original { set; get; }\n        public string Destination { set; get; }\n        public string Path { set; get; }\n        public WebHeaderCollection Headers { set; get; }\n\n        public byte[] Payload { set; get; }\n    }\n\n        public class HTTP\n    {\n        public enum METHOD\n        {\n            GET,\n            POST,\n            PUT,\n            DELETE,\n            HEAD,\n            OPTIONS,\n            TRACE,\n            PATCH,\n        }\n\n        public enum SCHEMA\n        {\n            HTTP,\n            HTTPS\n        }\n}\n", "\n\n", "这个错误有时候会自己好-_-，有时候又会突然出现。不知道从哪里下手。", "\n\n", "* 补充：", "\n\n", "一开始我以为是HTTP这个类名与系统定义冲突，随即改成了MYTTP，错误依旧：", "\n\n", "CS0266: Cannot implicitly convert type 'EEGProxy.App_Code.MYHTTP.METHOD [E:\\visualstudio2015\\Projects\\EEGProxy\\EEGProxy\\App_Code\\Utils\\HTTP.cs(19)]' to 'EEGProxy.App_Code.MYHTTP.METHOD [C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\Temporary ASP.NET Files\\eegproxy\\728b4be6\\64b07da6\\assembly\\dl3\\5c9e5e68\\4626695d_ab92d401\\EEGProxy.dll]'. An explicit conversion exists (are you missing a cast?)\n\n\n", "\n\n", "* 补充2：", "\n\n", "具体情况是这样：是我在APP_CODE\\Utils下有一个HTTP.CS的类，然后同项目里其他类都在用这个HTTP.CS类里的一个枚举。", "\n\n", "* 补充3：", "\n\n", "在RoutePackage函数的参数定义中，HTTP.METHOD有一个绿色的浪线，会有一个警告：", "\n\n", "class EEGProxy.App_Code.MYHTTP\n\n\"E:\\visualstudio2015\\Projects\\EEGProxy\\EEGProxy\\App_Code\\Utils\\HTTP.CS\"中的类型\"MYHTTP\"与\"EEGProxy,Version=1.0.0.0,Culture=neutral,PublicKeyToken=null\"中的导入类型\"MYHTTP\"冲突。请使用\"E:\\visualstudio2015\\Projects\\EEGProxy\\EEGProxy\\App_Code\\Utils\\HTTP.cs\"中定义的类型。\n", "\n\n", "这个警告明明提示的都是同一个文件。", "\n\n", "* 补充4：", "\n\n", "我什么也没改，清理几次项目，打开关闭vs，重新生成，暂时可以了，每次我都是这样解决，但是不知道根本原因在哪。", "\n先继续干活吧，等一会数据调通了，根据那位同学的建议把那些工具类的代码新建一个项目，生成dll，然后在主项目里引用它试试。", "\n\n", "* 补充5：", "\n\n", "我还是不理解，在同项目中，多个类引用同一个类中的枚举类型，为什么会报这个错误？", "\n现在具体情况是这样的，", "\n一个HTTP类，里面有个枚举类型，叫METHOD，然后另外一个模型类，叫RoutedPackageModel，其中一个属性就是HTTP.METHOD，然后在Prerouting类中有一个方法，RoutePackage，其中一个参数就是HTTP.METHOD，然后在方法内部使用这个参数时，就会出现这个错误！", "\n\n", "* 补充6：", "\n\n", "我创建了一个只有3个类的项目，问题依旧，我的环境是VS2015，版本14.0.25431.01 Update3，.net framework 版本4.7.02558，", "\n刚刚试了下用同时的vs2017，是同样的毛病。", "\n\n", "代码现在放到了网盘", "https://pan.baidu.com/s/1NCneJV9NJM9DlmHLQhQCaQ", "\n回家后我上传到github。", "\n我就是特别好奇，是怎么回事，希望大家帮我解惑。", "\n谢谢。", "\n\n", "* 补充7：", "\n\n", "本着好奇学习的原则，我特意创建了一个包含错误的项目，上传到了github，求老师讲解。谢谢。", "https://github.com/awolfnet/test", "\n\n", "* 补充8：", "\n\n", "我又做了一个实验，过程如下：", "\n目录结构：", "\nApp_Code\\ClassInAppCode.cs", "\nApp_Code\\EnumInAppCode.cs", "\nTestCode\\ClassInTestCode.cs", "\nTestCode\\EnumInTestCode.cs", "\n\n", "一共四个文件，Enum开头的两个类文件分别定义了两个枚举类型：", "\n\n", "EnumInAppCode.cs:\n    public class EnumInAppCode\n    {\n        public enum EIAC\n        {\n            A,\n            B\n        }\n    }\n\nEnumInTestCode.cs:      \n        public class EnumInTestCode\n    {\n        public enum EITC\n        {\n            A,\n            B\n        }\n    }\n", "\n\n", "然后两个Class是这样定义的：", "\n\n", "ClassInAppCode.cs:\n    public class ClassInAppCode\n    {\n        public void A(EnumInAppCode.EIAC eiac, EnumInTestCode.EITC eitc)  //这个函数的参数会报错\n        {\n            EnumInAppCode.EIAC _eiac; //<<-这里会报错\n            EnumInTestCode.EITC _eitc;\n            _eiac = eiac;//<<-这里会报错\n            _eitc = eitc;\n        }\n    }\n\nClassInTestCode.cs\n    public class ClassInTestCode\n    {\n\n        public void A(EnumInAppCode.EIAC eiac, EnumInTestCode.EITC eitc)\n        {\n            EnumInAppCode.EIAC _eiac;\n            EnumInTestCode.EITC _eitc;\n            _eiac = eiac;\n            _eitc = eitc;\n        }\n    }\n", "\n\n", "然后得出这样一个结果，就是当枚举类型和代码同在App_Code文件夹时，会出现这个异常。", "\n去查了文档：", "https://docs.microsoft.com/en-us/previous-versions/ex526337(v=vs.140)", "\n文档中描述说：", "\n\n", "\n", "App_Code", "\n\n", "Contains source code for shared classes and business objects (for example, ..cs, and .vb files) that you want to compile as part of your application. In a dynamically compiled Web site project, ASP.NET compiles the code in the App_Code folder on the initial request to your application. Items in this folder are then recompiled when any changes are detected.", "\n\n", "Note", "\n\n", "You can add any type of class file to the App_Code folder in order to create strongly typed objects that represent those classes. For example, if you put Web service files (.wsdl and .xsd files) in the App_Code folder, ASP.NET creates strongly typed proxies for those classes.", "\n\n", "Code in the App_Code folder is referenced automatically in your application. The App_Code folder can contain subdirectories of files, which can include class files that in different programming languages. For more information, see Shared Code Folders in ASP.NET Web Site Projects and codeSubDirectories Element for compilation (ASP.NET Settings Schema).", "\n", "\n\n", "重点在这句：**Code in the App_Code folder is referenced automatically in your application**", "\n从现象来看，我怀疑是这个自动引用的问题，但我不知道如何解决。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你还是去看看map数据结构吧&amp;#xff0c;map只有key和value&amp;#xff0c;没有其他&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["vue map对象如何添加数据", ["如上图，我想在value里面加入checked:false，来判断选择状态", "\n", "\n     ", "this", ".", "productSpecs", " = val.", "specItems", ";\n      ", "let", " map = ", "new", " ", "Map", "()\n      ", "this", ".", "productSpecs", ".", "forEach", "(", "(", "{specItem, specName}", ")=>", "\n      {map.", "set", "(specName, specItem.", "split", "(", "\",\"", "),\n     \n      )})\n"]], "Tag": "程序设计"}
{"Answer": "前面两个说的都是正确的，第三个Person p = new person()         ,f,change(p),   这里，其实并不是让f的p指向一个新对象，\r\nchange里面只是拿到那个新p的值，所以，change只是改变值，并没有指向新对象，所以是对的", "Konwledge_Point": "定义新的类型", "Question": ["java中为什么用final修饰了引用类型，但还是能修改对象，请大神解答下哈", ["class Person{", "\n     String name;", "\n     int age;", "\n     Person(){}", "\n     Person(String name,int age){", "\n         this.name=name;", "\n         this.age=age;", "\n     }", "\n     public void ShowInfo(){", "\n        System.out.println(\"姓名:\"+this.name+\"年龄：\"+this.age); ", "\n     }", "\n }", "\npublic class finala {", "\n        //建立的同时进行初始化", "\n        final int NUM;", "\n        //定义的同时对常亮进行初始化", "\n        final int sd=120;", "\n        //修饰一个对象引用，将不能改变对象本身，但可以改变对象的值", "\n        final Person p=new Person(\"无名氏\",20);", "\n        finala(){", "\n            this.NUM=100;", "\n        }", "\n        //可以用final来修饰形参，本例中形参是一个对象的引用", "\n        public void change(final Person p){", "\n            p.name=\"职工那样\";", "\n            //对象不能被改变", "\n            //p=new Person();", "\n\n", "    }\n    public static void main(String[] args){\n        finala f=new finala();\n        //比如这个就可以，他只是改变了对象的值，因此是合法的\n        f.p.name=\"张三丰\";\n        f.p.ShowInfo();\n        //比如这个就是错误的，因为不能指向一个新的对象\n        //f.p=new Person();，但是下面这个地方还是能创建一个指向新对象还是P，但却不报错，请指点下哈\n        Person p=new Person(\"张飞\",30);\n        f.change(p);\n        p.ShowInfo();\n    }\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以&amp;#xff0c;把定义的函数实现&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["嗖瑞，帮我改好有halfof100的￥我用c语言写的半成品职工管理，还请大家验收下，改正错误？", ["下面所有板块合起来就是我的代码了，我知道很糟糕，但是还是希望有老 师可以帮我指出错误，虽然今天改不好就要挂科了但是艾不行下次再来，不混。", "\n", "第一板块", "\n", "//定义各文件 函数 并显示主菜单", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", "<string.h>", "\n\n", "//职工数据结构体 ", "\n", "struct", " ", "Worker", "    \n{    ", "//6个属性 ", "\n    ", "char", "  num[", "20", "];                 ", "//工号  ", "\n    ", "char", " name[", "20", "];              ", "//姓名 ", "\n    ", "char", " inday[", "20", "];             ", "//入厂年月日", "\n    ", "char", " department[", "20", "];    ", "//工作部门 ", "\n    ", "char", "  job[", "20", "];           ", "//职称 ", "\n    ", "char", "  salary[", "20", "] ;        ", "//工资 计算平均要用到字符串转整数型 ", "\n}worker,w[", "200", "];", "//定义结构体数组 ", "\n\n", "//根据数据结构体定义职工链表结构体 ", "\n", "typedef", " ", "struct", " ", "node", "\n{\n    ", "struct", " ", "Worker", " worker;\n    ", "struct", " ", "node", " *next;", "//前节点 ", "\n    ", "struct", " ", "node", " *prior;", "//后节点 ", "\n}Node; \n\n\n\n \n", "int", " ", "getMeun", "(Node *worker)", ";         ", "//获取菜单 ", "\n", "int", " ", "addWorker", "(Node *worker)", ";    ", "//增加职工", "\n", "int", " ", "delWorker", "(Node *worker)", ";     ", "//删除职工", "\n", "int", " ", "querWorker", "(Node *worker)", ";     ", "//查询职工", "\n", "int", " ", "revWorker", "(Node *worker)", ";     ", "//修改职工", "\n", "int", " ", "saveFile", " ", "(Node* worker)", ";    ", "//存储到文件中 ", "\n", "int", " ", "saveNode", " ", "(Node* worker)", ";     ", "//输出排序好的链表但不更改文件", "\n", "int", " ", "readFile", "(Node *worker)", ";        ", "//读取文件信息 ", "\n", "int", " ", "next", "(Node* worker)", ";            ", "//下一步 ", "\n", "int", " ", "querNum", "(Node *worker)", ";\n\n", "int", " ", "main", "()", "\n", "{\n    Node *worker;\n    worker=(Node*)", "malloc", "(", "sizeof", "(Node)); ", "//创建头结点 ", "\n    worker->next=worker->prior=", "NULL", ";", "//开始都是空 ", "\n    ", "system", "(", "\"color 3f\"", ");", "//底色 ", "\n    ", "readFile", "(worker);    ", "//读取文件 ", "\n    ", "getMeun", " (worker);   ", "//获取主菜单 ", "\n    ", "return", " ", "0", ";\n}    \n    \n", "//主菜单", "\n", "int", " ", "getMeun", " ", "(Node *worker)", "   \n", "{\n    ", "int", " choose=", "0", " ;\n    ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n    ", "printf", "(", "\"\\t欢 迎来到职工管理系统\\n\"", "); \n    ", "printf", "(", "\"\\t1. 新增职工\\n\"", ");\n    ", "printf", "(", "\"\\t2. 删除职工\\n\"", ");\n    ", "printf", "(", "\"\\t3. 查询职工\\n\"", ");\n    ", "printf", "(", "\"\\t4. 修改职工\\n\"", ");\n    ", "printf", "(", "\"\\t0. 退出系统\\n\"", ");\n    ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n    ", "printf", "(", "\"\\t请输入操作数字\\n\"", ");\n    ", "scanf", "(", "\"%d\"", ",&choose);\n    ", "switch", "(choose) \n    {\n    ", "case", " ", "1", ":\n        ", "system", "(", "\"cls\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "printf", "(", "\"欢 迎进入新增职工页面\\n\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "addWorker", "(worker);  \n        ", "saveFile", "(worker);\n        ", "next", "(worker); \n        ", "break", ";\n    ", "case", " ", "2", ":\n        ", "system", "(", "\"cls\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "printf", "(", "\"欢 迎进入删除职工页面\\n\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "delWorker", "(worker);\n        ", "saveFile", "(worker);\n        ", "next", "(worker);\n        ", "break", ";\n    ", "case", " ", "3", ":\n        ", "system", "(", "\"cls\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "printf", "(", "\"欢 迎进入查询职工页面\\n\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "querWorker", "(worker);\n        ", "next", "(worker);\n        ", "break", ";\n    ", "case", " ", "4", ":\n        ", "system", "(", "\"cls\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "printf", "(", "\"欢 迎进入修改职工页面\\n\"", ");\n        ", "printf", "(", "\"********************************************************************************************\\n\"", ");\n        ", "revWorker", "(worker);\n        ", "saveFile", "(worker);\n        ", "next", "(worker);\n        ", "break", ";\n    ", "case", " ", "0", ":\n        ", "exit", "(", "0", ");\n    ", "default", ":\n        ", "system", "(", "\"cls\"", ");", "//清屏 ", "\n        ", "getMeun", "(worker);  ", "//递归 ", "\n    }\n}\n", "\n", "第二板块", "\n", "\n", "//1.增加职工", "\nint addWorker (Node *worker)    \n{    char addNum[", "20", "],addName[", "20", "],addJob[", "20", "],adddepartment[", "20", "];\n    int num=", "0", ",i;\n    Node *p,*q,*pre,*k;\n    q=pre=worker;    ", "//头结点不存储数据 ", "\n    ", "k", "=worker->", "next;\n", "//    if(q->next !=NULL) ", "\n", "//    {", "\n", "//        pre=q;", "\n", "//        q=q->next; ", "\n", "//        q->prior=pre;", "\n", "//    }", "\n    p=(Node *)malloc(sizeof(Node));\n    printf(", "\"请依次输入数据:\\n\"", "); \n    printf(", "\"工号:\\n\"", ");\n    ", "scanf", "(\"%s\",&p->", "worker.num);\n        ", "//这里要插入函数效验工号格式（规定格式为一个大写字母加四位数字，如果一个大写字母对应某一个部门怎么办？后面关于工号和部门还要修改说明？，这里我晕的一塌糊涂），见第三板块代码", "\n    ", "//对工号进行判断是否重复 ，循环多次判断 （这里可以运行并且判断出来）由第三板块如果输入工号格式正确的话可以并入到效验函数里", "\n     ", "while", "(k!=NULL)\n     {\n         ", "if", "(strcmp(p->", "worker", ".num ,k->", "worker.num)==", "0", ")\n         {\n             printf(", "\"该工号已存在，请重新输入工号\\n\"", ");\n            ", "scanf", "(\"%s\",p->", "worker.num);\n            k=worker;             ", "//指回头结点，再次遍历判断 ", "\n        }\n            ", "k", "=k->", "next;    \n    }\n    printf(", "\"姓名:\\n\"", ");\n    ", "scanf", "(\"%s\",&p->", "worker.", "name", ");\n        ", "//这里要插入函数效验姓名格式（规定只能是中文），见第三板块代码", "\n    ", "//对姓名进行判断 ，循环多次判断（这里可以运行但是判断 不出来）", "\n    ", "while", "(k!=NULL)\n     {\n         int choose;\n         ", "if", "(strcmp(p->", "worker", ".", "name", " ,k->", "worker.", "name", ")==", "0", ")\n         {\n             \n             printf(", "\"姓名重复，请确认是否输入\\n\"", ");\n             printf(", "\"确认：1  否认：0 \\n\"", ");\n             scanf(", "\"%d\"", ",&choose);\n             ", "if", "(choose==", "0", ")\n             {\n                 printf(", "\"请重新输入姓名：\\n\"", ");\n                 ", "scanf", "(\"%s\",p->", "worker.num);\n                 k=worker; ", "//指回头结点，再次遍历判断 ", "\n                 ", "k", "=k->", "next;\n             } \n                        \n        }\n                \n    }\n    printf(", "\"入厂年月日:\\n\"", ");\n    ", "scanf", "(\"%s\",&p->", "worker.inday);\n    ", "//这里要插入函数效验日期格式，错误的话依旧要查询输入，见第三板块代码（不知道如何调用使用） ", "\n    printf(", "\"职务:\\n\"", ");\n    ", "scanf", "(\"%s\",&p->", "worker.job);\n        ", "//这里要检验职务输入是否是公司已有的职务位置（如何设定已有职务，已有职务都是从文件读取的职工信息而取得", "\n        ", "//但一开始文件是空的，需要手动输入职工信息），如果公司没有，请确认是重新输入还是添加该职务(完全没有头绪)", "\n    printf(", "\"工作部门:\\n\"", ");\n    ", "scanf", "(\"%s\",&p->", "worker.department);\n    \n", "/*    while(k!=NULL)\n                        {    \n                    if((strcmp(p->worker.name,pre->worker.num) > 0 )||( strcmp(p->worker.name,q->worker.num) < 0 ))\n                    {\n                        int i; \n                        printf(\"该部门不存在!请选择添加重新输入：\");\n                        printf(\"添加该部门：1   重新输入：2\") ;\n                        \n                            \n                                    \n                                    scanf(\"%d\",&i);\n                                    if(i==1)\n                                    {\n                                    \n                                                printf(\"添加成功\");\n                                    \n                                        continue; \n                                    }\n                                    else\n                                    {\n                                        \n                                        printf(\"不添加该部门。返回重新输入。\");\n                                        return i==2; \n                                    } \n                                    if(i==2);\n                                    {\n                                            scanf(\"%s\",&p->worker.department);\n                                    }\n                        \n                        \n                        \n                    }\n                    else continue;\n                    p=p->next;\n                }*/", "\n    printf(", "\"工资:\\n\"", ");\n", "//这里要判断工资输入是否合理，工资范围为4000-16000；不合理同样要重新输入（不知这里是使用循环判断还是写一个效验函数来调用）", "\n    ", "scanf", "(\"%s\",&p->", "worker.salary);\n \n     \n     \n    printf(", "\"新增职工信息如下：\\n\\n\"", ");\n    printf(", "\"工号\\t姓名\\t入厂年月\\t职称\\t工作部门\\t工资 \\n\"", "); \n    printf(", "\"%s\\t%s\\t\\t%s\\t%s\\t\\t%s\\t%s\\n\"", ",\n    ", "p", "->", "worker", ".num,p->", "worker", ".", "name", ",p->", "worker", ".inday,p->", "worker", ".job,p->", "worker", ".department,p->", "worker.salary);\n    \n\n            ", "while", "(q!=NULL)\n        {\n            ", "//大于前结点而且小于后结点，插入于中间 ", "\n            ", "if", "( (strcmp(p->", "worker", ".", "name", ",pre->", "worker", ".num) > 0 )&&( strcmp(p->", "worker", ".", "name", ",q->", "worker.num) < ", "0", " ) )\n            {\n                ", "p", "->", "next=q;\n                ", "p", "->", "prior", "=q->", "prior;\n                ", "q", "->", "prior=p;\n                ", "p", "->", "prior", "->", "next=p;\n                break;\n            }    \n            ", "//插入于最后一个的后面    ", "\n            ", "if", "( (q->", "next", "==NULL)&& ( strcmp(p->", "worker", ".", "name", ",pre->", "worker.num) > ", "0", " ))\n            {\n                ", "q", "->", "next=p;\n                ", "p", "->", "prior=q;\n                ", "p", "->", "next=NULL;\n                break;\n            }\n            pre=q;\n            ", "q", "=q->", "next; \n            ", "q", "->", "prior=pre;        \n        }             \n    \n}\n", "\n", "第三板块", "\n", "//1.这里要写 插入函数效验工号格式（规定格式为一个大写字母加四位数字，如果一个大写字母对应某一个部门怎么办？后面关于工号和部门还要修改说明？，这里我晕的一塌糊涂）", "\n", "//这里写到 效验工号格式的代码  但是我还是不知道如何用作调用函数到第二板块里", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n", "//按照你要求的第一个大写字母+后四位数", "\n", "int", " ", "isValid", "(", "char", "* buf)", "\n", "{\n  ", "int", " i;\n  ", "if", "(", "strlen", "(buf) != ", "5", ") ", "//长度不匹配，直接退出", "\n  {\n    ", "printf", "(", "\"长度不符合\\n\"", ");\n    ", "return", " ", "0", ";", "//", "\n  }\n  ", "if", "(buf[", "0", "] <", "'A'", " || buf[", "0", "] > ", "'Z'", ")\n  {\n    ", "printf", "(", "\"第一个字符不是大写字母\\n\"", ");\n    ", "return", " ", "0", "; ", "//第一个字符不是大写字母，退出", "\n  }\n  ", "for", "(i=", "1", ";i<", "5", ";i++)\n    ", "if", "(buf[i] < ", "'0'", " || buf[i] > ", "'9'", ")\n    {\n      ", "printf", "(", "\"第2-5位中有非数字字符\\n\"", ");\n      ", "return", " ", "0", "；\n    }\n  ", "//上面的条件都满足，则说明输入符合要求", "\n  ", "printf", "(", "\"输入符合要求\\n\"", ");\n  ", "return", " ", "1", ";\n}\n \n", "int", " ", "main", "()", "\n", "{\n  ", "char", " buf[", "100", "]={", "0", "};\n  ", "gets", "(buf); ", "//读取字符串", "\n  ", "if", "(", "isValid", "(buf))\n    ", "//输入合法时的处理，即输入添加职工的工号格式正确，检验工号是否重复", "\n  ", "else", "\n    ", "//输入不合法的处理，即工号格式错误，需重新输入工号直到合格", "\n  ", "return", " ", "0", ";\n}\n\n", "//2.这里是要写效验姓名函数 已知以下代码可以判断姓名格式输入是否正确", "\n", "//但是我还不会，不知道怎么写，要效验姓名只能是中文才正确，否则要重新输入姓名并且再效验 ", "\n\n", "//3.这是可以效验日期格式的代码 但是如何调用到板块二里效验呢", "\n", "//定义一个表示日期的结构体类型struct Date", "\n", "struct", " ", "Date", "\n{\n    ", "int", " year;\n    ", "int", " month;\n    ", "int", " day;\n}date;\n", "//用typedef重新定义新类型名Date", "\n", "typedef", " ", "struct", " ", "Date", " Date;\n\n\n", "//检查日期是否有效函数", "\n", "//int checkDate(Date date);", "\n", "int", " ", "checkDate", "(Date date)", "\n", "{\n    ", "int", " y = ", "0", ";\n    ", "//判断月份是否为31天", "\n    ", "if", " (date.month == ", "1", " || date.month == ", "3", " || date.month == ", "5", " || date.month == ", "7", " || date.month == ", "8", " || date.month == ", "10", " || date.month == ", "12", ")\n        y = ", "1", ";\n    ", "//判断月份是否为30天", "\n    ", "if", " (date.month == ", "4", " || date.month == ", "6", " || date.month == ", "9", " || date.month == ", "11", ")\n        y = ", "4", ";\n    ", "//月份为2月时（需要判断闰年）", "\n    ", "if", " (date.month == ", "2", ")\n    {\n        ", "if", " ((date.year % ", "4", " == ", "0", " && date.year % ", "100", " != ", "0", ") || date.year % ", "400", " == ", "0", ")\n            y = ", "2", ";\n        ", "else", "\n            y = ", "3", ";\n    }\n    ", "if", " (date.year < ", "1900", " || date.year>", "2020", ")\n        ", "return", " ", "0", ";\n    ", "else", " ", "if", " (date.month < ", "1", " || date.month>", "12", ")\n        ", "return", " ", "0", ";\n    ", "else", " ", "if", " (y == ", "1", " && (date.day < ", "1", " || date.day>", "31", "))\n        ", "return", " ", "0", ";\n    ", "else", " ", "if", " ((y == ", "4", ") && (date.day < ", "1", " || date.day>", "30", "))\n        ", "return", " ", "0", ";\n    ", "else", " ", "if", " ((y == ", "2", ") && (date.day < ", "1", " || date.day>", "29", "))\n        ", "return", " ", "0", ";\n    ", "else", " ", "if", " ((y == ", "3", ") && (date.day < ", "1", " || date.day>", "28", "))\n        ", "return", " ", "0", ";\n    ", "else", "\n        ", "return", " ", "1", ";\n}\n\n\n\n\n\n\n", "//4.以下是我写的用来判断工作部门输入时面对的情况以及处理，但是貌似好像不可以运行也有许多错误", "\n", "while", "(k!=", "NULL", ")\n{    ", "if", "((", "strcmp", "(p->worker.name,pre->worker.num) > ", "0", " )||( ", "strcmp", "(p->worker.name,q->worker.num) < ", "0", " ))\n    {\n        ", "int", " i; \n        ", "printf", "(", "\"该部门不存在!请选择添加重新输入：\"", ");\n        ", "printf", "(", "\"添加该部门：1   重新输入：2\"", ") ;", "scanf", "(", "\"%d\"", ",&i)\n        ", "if", "(i==", "1", ")\n          {\n        \n        ", "printf", "(", "\"添加成功\"", ");\n                                    \n            ", "continue", "; \n        }\n            ", "else", "\n          {\n                                        \n        ", "printf", "(", "\"不添加该部门。返回重新输入。\"", ");\n        ", "return", " i==", "2", "; \n          } \n        ", "if", "(i==", "2", ");\n        {\n            ", "scanf", "(", "\"%s\"", ",&p->worker.department);\n        }\n                        \n                        \n                        \n    }\n    ", "else", " ", "continue", ";\n    p=p->next;\n}\n\n", "\n", "第四板块", "\n", "//这里按工号删除没什么问题，因为工号是惟一的", "\n", "//但是按姓名删除就运行不是很对，只能搜查出相同姓名的职工里在文件里排在较前的职工（另一职工的信息搜索不出来），然后对其可以进行删除", "\n", "//2.删除职工", "\nint delWorker(Node *worker)        \n{\n    Node *p,*r;\n    char delnum[", "20", "],delname[", "20", "];\n    int delChoose,confirmChoose;\n    ", "p", "=worker->", "next;\n    \n    ", "if", "( p==NULL)\n    {\n        printf(", "\"目前没有资料\\n\"", "); \n    }\n\n    ", "else", "\n    {\n        printf(", "\"按职工工号删除： 1\\n\"", ");\n        printf(", "\"按职工姓名删除： 2\\n\"", ");\n        printf(", "\"删除所有职工信息：   3\\n\"", "); \n        printf(", "\"********************************************************************************************\\n\"", ");\n        scanf(", "\"%d\"", ",&delChoose);\n            ", "if", "(delChoose==", "1", " ) \n            {\n                int num=", "0", "; \n                printf(", "\"请输入要删除职工的工号\\n\"", "); \n                scanf(", "\"%s\"", ",&delnum);\n                ", "while", "(p!=NULL)\n                {    \n                    ", "if", "(strcmp(p->", "worker.num,delnum)==", "0", ")\n                    {\n                        num++;\n                        printf(", "\"工号\\t姓名\\t入厂年月\\t职称\\t工作部门\\t工资 \\n\"", "); \n                        printf(", "\"%s\\t%s\\t\\t%s\\t%s\\t\\t%s\\t%s\\n\"", ",\n                        ", "p", "->", "worker", ".num,p->", "worker", ".", "name", ",p->", "worker", ".inday,p->", "worker", ".job,p->", "worker", ".department,p->", "worker.salary);\n                        ", "printf", "(\"您是否删除%s\\n\\n\",p->", "worker.", "name", ");\n                        \n                        printf(", "\"确认删除：1，取消删除：2\\n\"", ");\n                        scanf(", "\"%d\"", ",&confirmChoose);\n                        ", "if", "(confirmChoose==", "1", ")\n                        {\n                            ", "printf", "(\"%s删除成功\\n\",p->", "worker.", "name", "); \n                            ", "//删除该节点 ", "\n                                ", "if", "(p!=NULL)\n                                {\n                                    r=worker;\n                                    ", "while", " (r->", "next!=p)\n                                    {\n                                        ", "r", "=r->", "next;    \n                                    }\n                                    ", "r", "->", "next", "=r->", "next", "->", "next;    \n                                }\n                                saveFile(worker);\n                        }\n                        ", "else", " ", "if", "(confirmChoose==", "2", ")\n                        {\n                            printf(", "\"您已取消操作\\n\"", "); \n                            break;\n                        }\n                        break;\n                    }\n                    ", "else", "\n                    {\n                        ", "if", "(p->", "next==NULL&&num==", "0", ")\n                        {\n                            printf(", "\"该职工不存在\\n\"", "); \n                        }    \n                    }\n                    ", "p", "=p->", "next;    \n                }\n                \n                \n            }", "//delChoose==1", "\n            ", "else", " ", "if", " (delChoose==", "2", " )\n            {\n                printf(", "\"请输入要删除职工的姓名\\n\"", "); \n                scanf(", "\"%s\"", ",&delname);\n                int num=", "0", "; \n                \n                ", "while", "(p!=NULL)\n                {    \n                    ", "if", "(strcmp(p->", "worker.", "name", ",delname)==", "0", ")\n                    {\n                        num++;\n                                \n                                ", "if", "(num==", "1", ")\n                                {\n                                    printf(", "\"找到该职工，其信息如下：\"", "); \n                                    printf(", "\"工号\\t姓名\\t入厂年月日\\t职称\\t工作部门\\t工资 \\n\"", "); \n                                    printf(", "\"%s\\t%s\\t%s\\t%s\\t\\t%s\\t%s\\n\"", ",\n                                    ", "p", "->", "worker", ".num,p->", "worker", ".", "name", ",p->", "worker", ".inday,p->", "worker", ".job,p->", "worker", ".department,p->", "worker.salary);\n                                    ", "printf", "(\"您是否删除%s\\n\",p->", "worker.", "name", ");\n                                        printf(", "\"确认删除：1，取消删除：2\\n\"", ");\n                                        scanf(", "\"%d\"", ",&confirmChoose);\n                                        ", "if", "(confirmChoose==", "1", ")\n                                        {\n                                            ", "printf", "(\"%s删除成功\\n\",p->", "worker.", "name", "); \n                                        \n                                    \n                                        ", "//删除该节点 ", "\n                                            ", "if", "(p!=NULL)\n                                            {\n                                                r=worker;\n                                                ", "while", " (r->", "next!=p)\n                                                {\n                                                    ", "r", "=r->", "next;    \n                                                }\n                                                ", "r", "->", "next", "=r->", "next", "->", "next;    \n                                            }\n                                            saveFile(worker);\n                                        }\n                                        ", "else", " ", "if", "(confirmChoose==", "2", ")\n                                        {\n                                            printf(", "\"您已取消操作\\n\"", "); \n                                            break;\n                                        }\n                                        break;\n                                            \n                                    }\n                                ", "if", "(num>=", "2", ")\n                                {\n                                    printf(", "\"请输入你要删除的职工的工号：\"", ");\n                                    ", "scanf", "(\"%s\",p->", "worker.num) ;\n                                    ", "printf", "(\"您是否删除%s\\n\",p->", "worker.", "name", ");\n                                    printf(", "\"确认删除：1，取消删除：2\\n\"", ");\n                                    scanf(", "\"%d\"", ",&confirmChoose);\n                                    ", "if", "(confirmChoose==", "1", ")\n                                    {\n                                        ", "printf", "(\"%s删除成功\\n\",p->", "worker.", "name", "); \n                                    \n                                \n                                    ", "//删除该节点 ", "\n                                        ", "if", "(p!=NULL)\n                                        {\n                                            r=worker;\n                                            ", "while", " (r->", "next!=p)\n                                            {\n                                                ", "r", "=r->", "next;    \n                                            }\n                                            ", "r", "->", "next", "=r->", "next", "->", "next;    \n                                        }\n                                        saveFile(worker);\n                                    }\n                                    ", "else", " ", "if", "(confirmChoose==", "2", ")\n                                    {\n                                        printf(", "\"您已取消操作\\n\"", "); \n                                        break;\n                                    }\n                                    break;\n                                }\n                        \n                    }\n                    ", "else", "\n                    {\n                        ", "if", "(p->", "next==NULL&&num==", "0", ")\n                        {\n                            printf(", "\"该职工不存在\\n\"", "); \n                        }    \n                    }\n                    ", "p", "=p->", "next;    \n                }\n            }", "//delChoose==2 ", "\n        \n            ", "else", " ", "if", " (delChoose==", "3", " )\n            {\n                worker=NULL;\n                printf(", "\"所有人员信息已经删除！\"", ");\n            \n            }\n        \n        \n        \n        \n    }\n    \n\n};\n"]], "Tag": "程序设计"}
{"Answer": "```\r\nclass student\r\n{\r\npublic:\r\n\tint sid;\r\n\tstring name;\r\n\tfloat sco;\r\n\tstudent() {}\r\n\tstudent(int sid, string name, float sco) :sid(sid), name(name), sco(sco) {}\r\n};\r\n\r\nstudent ss[55];\r\n//记录学生数量\r\nint num = 0;\r\nvoid Add(int sid, string name, float sco)\r\n{\r\n\tss[num++] = student(sid, name, sco);\r\n}\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["C++对象数组——学生信息表 补充代码 计算三个学生成绩的平均值？", ["要求：", "设计 Student 类并实现用于管理学生信息表（学生表的长度不超过55）的33个函数，成员变量和函数的访问性都为公有的，具体类结构和函数要求如下：", "\n\n", "学号，int类型", "\n\n", "姓名，string类型", "\n\n", "分数，float类型", "\n\n", "带参构造函数：Student(int sid,string name,float sco)，分别用这三个参数设置内部的三个成员。", "\n\n", "void Add(int sid,string name,float sco)，函数用于向学生表的末尾添加一条学生记录。", "\n\n", "void PrintAll()，输出学生表中所有的记录，格式为：学号 姓名 成绩。", "\n\n", "void Average()，计算学生表中学生的平均成绩并输出，格式为：平均成绩 计算结果。", "\n\n", "提示：学生表可以用全局对象数组来完成，定义全局对象数组和定义全局变量一样，即定义在最外层作用域。", "\n\n", "测试说明", "\n\n", "平台会对你编写的代码进行测试，比对你输出的数值与实际正确数值，只有所有数据全部计算正确才能通过测试：", "\n\n", "测试输入：0 厉宏富 96 1 冷欣荣 85 2 鲍俊民 76", "\n\n", "预期输出：", "\n\n", "0 厉宏富 96", "\n1 冷欣荣 85", "\n2 鲍俊民 76", "\n平均成绩 85.6667", "\n\n", "/*主函数不允许修改*/", "\n**_#include \"usr.h\"", "\n#include ", "\nusing namespace std;", "\n\n", "int main()", "\n{", "\n    int i,j,k;", "\n    string name1,name2,name3;", "\n    float score1,score2,score3;", "\n    cin >> i >> name1 >> score1;", "\n    cin >> j >> name2 >> score2;", "\n    cin >> k >> name3 >> score3;", "\n    Add(i,name1,score1);", "\n    Add(j,name2,score2);", "\n    Add(k,name3,score3);", "\n    PrintAll();", "\n    Average();", "\n}", "\n\n", "#include ", "\n#include ", "\nusing namespace std;", "\n\n", "/********* Begin *********/", "\nclass Student", "\n{", "\n    //在此处声明所需的成员", "\n\n", "};", "\n/********* End *********/", "\n\n", "void Add(int sid,string name,float sco)", "\n{", "\n    /********* Begin *********/", "\n\n", "/********* End *********/\n", "\n\n", "}", "\n\n", "void PrintAll()", "\n{", "\n    /********* Begin *********/", "\n    //打印出学生表中所有记录", "\n\n", "/********* End *********/\n", "\n\n", "}", "\n\n", "void Average()", "\n{", "\n    /********* Begin *********/", "\n    //计算并打印出学生表中的平均成绩", "\n\n", "/********* End *********/\n", "\n\n", "}", "\n\n", "我是新手菜鸟", "\n搞不懂void Add(int sid,string name,float sco)", "\n//向学生表中添加一条记录", "\n是怎么整的 求助"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你需要将节点结构定义放到函数申明前面&amp;#xff0c;否则函数中的node编译器不知道是什么东西&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n \ntypedef struct Node\n{\n    int data; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;数据域\n    struct Node* &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;指针域\n}node;\n\nnode* headPointer(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建头节点,并初始化\nvoid createLink(node* head, int* arr); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建链表(有头节点)\nnode*findNode(node* head); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找链表的节点\nvoid addNode(node* head); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;添加链表的节点\nvoid travLink(node* head); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;遍历链表\n \n\n \nint main()\n{\n    int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    int arr[] &amp;#61; { &lt;span class=\"hljs-number\"&gt;23&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;34&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;45&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;56&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;67&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;78&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;89&lt;/span&gt; };\n    node* head &amp;#61; headPointer(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建头节点,并初始化\n    createLink(head, arr); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建链表(有头节点)\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;node* tarNode &amp;#61; findNode(head);\n    addNode(head); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;添加新的节点\n    travLink(head); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;遍历链表\n    free(head);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建头节点,并初始化\nnode* headPointer()\n{\n    node* head &amp;#61; (node*)malloc(sizeof(node));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!head)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;头节点创建失败&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n    head-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n    head-&amp;gt;data &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;头节点创建成功\\n&amp;#34;&lt;/span&gt;);\n    return head;\n}\n \n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建链表(有头节点)\nvoid createLink(node* head,int*arr)\n{\n    node* move_Pointer &amp;#61; head; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;移动指针指向头节点\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (head-&amp;gt;data!&amp;#61;&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;)\n    {\n        node* newNode &amp;#61; (node*)malloc(sizeof(node));\n \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (newNode &amp;#61;&amp;#61; NULL)\n        {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;新节点创建失败&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        }\n        newNode-&amp;gt;data &amp;#61; arr[head-&amp;gt;data]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;为新节点赋值\n \n        newNode-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;初始化新节点的指针域\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 尾插法----------------------------------------------------\n        move_Pointer-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; newNode;\n        move_Pointer &amp;#61; newNode;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;-----------------------------------------------------------\n \n \n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;头插法------------------------------------------------------\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;newNode-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; move_Pointer-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        &lt;span class=\"hljs-regexp\"&gt;//m&lt;/span&gt;ove_Pointer-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; newNode;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;-----------------------------------------------------------\n        head-&amp;gt;data &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;链表创建成功\\n&amp;#34;&lt;/span&gt;);\n}\n \n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;遍历链表\nvoid travLink(node* head)\n{\n    node* move_Pointer &amp;#61; head-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (move_Pointer!&amp;#61;NULL)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, move_Pointer-&amp;gt;data);\n        move_Pointer &amp;#61; move_Pointer-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    }\n}\n \n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除节点\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;void delNode(node* head)\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    node* tarNode &amp;#61; findNode(head);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    node* P;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!tarNode)\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    {\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有找到删除的位置\\n&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;        &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    }\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n \n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找链表的节点\nnode* findNode(node* head)\n{\n    int i;\n    int j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    node* movePointer &amp;#61; head-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;你要查找第几个节点\\n&amp;#34;&lt;/span&gt;);\n    scanf_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;i);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;lt;&amp;#61; head-&amp;gt;data)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (movePointer!&amp;#61; NULL)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                return head;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; j)\n            {\n                return movePointer;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                movePointer &amp;#61; movePointer-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n                j &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有你要查找的节点&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n    return NULL;\n}\n \n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;添加链表的节点\nvoid addNode(node*head)\n{\n    node* tarNode &amp;#61; findNode(head);\n    int i;\n    node* P;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!tarNode)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有查找到添加位置\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n    P &amp;#61; tarNode-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    node* newNode &amp;#61; (node*)malloc(sizeof(node));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!newNode)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;新添加的节点创建失败\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;你要添加的数据是:&amp;#34;&lt;/span&gt;);\n    scanf_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;i);\n    newNode-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n    newNode-&amp;gt;data &amp;#61; i;\n    tarNode-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; newNode;\n    newNode-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; P;\n    head-&amp;gt;data &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["#间接寻址级别不同 #重定义；不同的基类型报错", ["\n\n", "#include<stdio.h>", "\n", "#include<stdlib.h>", "\n\nnode* headPointer(); ", "//", "创建头节点,并初始化\nvoid createLink(node* head, int* arr); ", "//", "创建链表(有头节点)\nnode*findNode(node* head); ", "//", "查找链表的节点\nvoid addNode(node* head); ", "//", "添加链表的节点\nvoid travLink(node* head); ", "//", "遍历链表\n\ntypedef struct Node\n{\n    int data; ", "//", "数据域\n    struct Node* ", "next", "; ", "//", "指针域\n}node;\n\nint main()\n{\n    int i = ", "0", ";\n    int arr[] = { ", "23", ",", "34", ",", "45", ",", "56", ",", "67", ",", "78", ",", "89", " };\n    node* head = headPointer(); ", "//", "创建头节点,并初始化\n    createLink(head, arr); ", "//", "创建链表(有头节点)\n    ", "//", "node* tarNode = findNode(head);\n    addNode(head); ", "//", "添加新的节点\n    travLink(head); ", "//", "遍历链表\n    free(head);\n    return ", "0", ";\n}\n\n", "//", "创建头节点,并初始化\nnode* headPointer()\n{\n    node* head = (node*)malloc(sizeof(node));\n    ", "if", " (!head)\n    {\n        printf(", "\"头节点创建失败\"", ");\n        ", "exit", "(", "0", ");\n    }\n    head->", "next", " = NULL;\n    head->data = ", "0", ";\n    printf(", "\"头节点创建成功\\n\"", ");\n    return head;\n}\n\n\n", "//", "创建链表(有头节点)\nvoid createLink(node* head,int*arr)\n{\n    node* move_Pointer = head; ", "//", "移动指针指向头节点\n    ", "while", " (head->data!=", "7", ")\n    {\n        node* newNode = (node*)malloc(sizeof(node));\n\n        ", "if", " (newNode == NULL)\n        {\n            printf(", "\"新节点创建失败\"", ");\n            ", "exit", "(", "0", ");\n        }\n        newNode->data = arr[head->data]; ", "//", "为新节点赋值\n\n        newNode->", "next", " = NULL; ", "//", "初始化新节点的指针域\n        ", "//", " 尾插法----------------------------------------------------\n        move_Pointer->", "next", " = newNode;\n        move_Pointer = newNode;\n        ", "//", "-----------------------------------------------------------\n\n\n        ", "//", "头插法------------------------------------------------------\n        ", "//", "newNode->", "next", " = move_Pointer->", "next", ";\n        ", "//m", "ove_Pointer->", "next", " = newNode;\n        ", "//", "-----------------------------------------------------------\n        head->data += ", "1", ";\n    }\n    printf(", "\"链表创建成功\\n\"", ");\n}\n\n\n", "//", "遍历链表\nvoid travLink(node* head)\n{\n    node* move_Pointer = head->", "next", ";\n    ", "while", " (move_Pointer!=NULL)\n    {\n        printf(", "\"%d\\n\"", ", move_Pointer->data);\n        move_Pointer = move_Pointer->", "next", ";\n    }\n}\n\n\n", "//", "删除节点\n", "//", "void delNode(node* head)\n", "//", "{\n", "//", "    node* tarNode = findNode(head);\n", "//", "    node* P;\n", "//", "    ", "if", " (!tarNode)\n", "//", "    {\n", "//", "        printf(", "\"没有找到删除的位置\\n\"", ");\n", "//", "        ", "exit", "(", "0", ");\n", "//", "    }\n", "//", "\n", "//", "}\n\n\n", "//", "查找链表的节点\nnode* findNode(node* head)\n{\n    int i;\n    int j = ", "1", ";\n    node* movePointer = head->", "next", ";\n    printf(", "\"你要查找第几个节点\\n\"", ");\n    scanf_s(", "\"%d\"", ", &i);\n    ", "if", " (i <= head->data)\n    {\n        ", "while", " (movePointer!= NULL)\n        {\n            ", "if", " (i == ", "0", ")\n                return head;\n            ", "if", " (i == j)\n            {\n                return movePointer;\n            }\n            ", "else", "\n            {\n                movePointer = movePointer->", "next", ";\n                j += ", "1", ";\n            }\n        }\n    }\n    ", "else", "\n    {\n        printf(", "\"没有你要查找的节点\"", ");\n        ", "exit", "(", "0", ");\n    }\n}\n\n\n", "//", "添加链表的节点\nvoid addNode(node*head)\n{\n    node* tarNode = findNode(head);\n    int i;\n    node* P;\n    ", "if", " (!tarNode)\n    {\n        printf(", "\"没有查找到添加位置\\n\"", ");\n        ", "exit", "(", "0", ");\n    }\n    P = tarNode->", "next", ";\n    node* newNode = (node*)malloc(sizeof(node));\n    ", "if", " (!newNode)\n    {\n        printf(", "\"新添加的节点创建失败\\n\"", ");\n        ", "exit", "(", "0", ");\n    }\n    printf(", "\"你要添加的数据是:\"", ");\n    scanf_s(", "\"%d\"", ", &i);\n    newNode->", "next", " = NULL;\n    newNode->data = i;\n    tarNode->", "next", " = newNode;\n    newNode->", "next", " = P;\n    head->data += ", "1", ";\n}\n", "\n", "请帮忙看看", "间接寻址级别不同的报错以前没遇到过；", "\n", "\n", "为什么已经声明了函数还会报重定义的错；", "\n", "\n", "声明函数后又出现了其它报错，如下；", "\n"]], "Tag": "程序设计"}
{"Answer": "...你可以看看ASCII表的。\n当你把它定义为char类型时3就不再是3，在表中a是97应该if的条件成立然后再判断str的第二个字符，3在表中是51，所以不满足if的条件，所以自然就不会有输出了", "Konwledge_Point": "定义新的类型", "Question": ["新手求救为什么在输入a3时无输出", ["初学c语言，不太懂，希望得到指导", "\n求大神指导", "\n\n", "#include<string.h>\nint main(){\n    char str[100]={0};\n    scanf(\"%s\",str);\n    int temp=0,fh,s,save=0;\n\n    int i=0;\n    for(i=0;i<strlen(str);i++){\n        if (str[i]>57||str[i]<48){\n\n            if(str[i+1]>57||str[i+1]<48){\n                printf(\"%c\",str[i]);\n            }\n            else{\n                while(str[i+temp]<=57&&str[1+temp]>=48){\n                    temp++;\n                }\n                if(temp==1){\n                    save=str[i+1]-48;\n                }\n                if(temp==2){\n                    save=(str[i+1]-48)*10+str[i+2]-48;\n                }if(temp==3){\n                    save=(str[i+1]-48)*100+(str[i+2]-48)*10+str[i+3]-48;\n                }\n                for(s=0;s<save%7;s++){\n                    printf(\"%c\",str[i]);\n                }\n                printf(\" \");\n                i=i+temp;\n                temp=0;\n            }\n        }\n    }\n    return 0;\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;2.同一类的两个对象&amp;#xff0c;若其有相同的属性&amp;#xff0c;则被称为两个对象是“相等”的&lt;/p&gt;\n&lt;p&gt;错&amp;#xff1b;判断对象是否相等使用的是 Object 类的 equals 方法&amp;#xff0c;这个方法默认的是实现是比较对象的地址是否相同&amp;#xff0c;也就是说是否是一个对象。两个对象是否相等要根据这个方法的实现来&amp;#xff0c;并不能说属性相同对象就是相等的。&lt;/p&gt;\n&lt;p&gt;7.StringBuffer是系统定义的处理字符串的类&amp;#xff0c;用它可以创建动态字符串&amp;#xff0c;它有非常好的时间效率&amp;#xff08;与String相比较&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;对&amp;#xff1b;相对 String来说&amp;#xff0c;StringBuffer 可以动态拼接字符&amp;#xff0c;性能会好一些&amp;#xff0c;这个类的方法都加了 synchronized &amp;#xff0c;适用于多线程场景&amp;#xff0c;单线程场景 StringBuilder 是更好的选择。&lt;/p&gt;\n&lt;p&gt;8.java.awt 和 java.swing相比&amp;#xff0c;java.swing 的特点是:功能更强,GUI效果更佳,占用资源较多&lt;/p&gt;\n&lt;p&gt;不确定&amp;#xff0c;通常不用 java 做 GUI。&lt;/p&gt;\n&lt;p&gt;3.InputStreamReader/OutputStreamWriter是抽象类&amp;#xff0c;是不能用于实例化&amp;#xff08;创建对像的&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;错&amp;#xff1b;都不是抽象类。&lt;/p&gt;\n&lt;p&gt;4.StringBuffer类中的方法equals()方法比较的是“同一”&lt;/p&gt;\n&lt;p&gt;对&amp;#xff1b;StringBuffer 没有重写 equals() 方法&amp;#xff0c;因此默认比较是否为同一个对象。&lt;/p&gt;\n&lt;p&gt;5.抽象类是一个不完整的类&amp;#xff0c;只能实例化&amp;#xff0c;不能派生出子类。&lt;/p&gt;\n&lt;p&gt;错&amp;#xff1b;抽象类不能实例化&amp;#xff0c;子类可以继承&amp;#xff1b;同时抽象类也常用来做工具类&amp;#xff0c;内部定义一些静态方法。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["java相关的一些问题求解", ["判断题：", "1.类是Java的基本单位，除import和package外，类外不能再有其它关键字，但可以在类外定义全局变量", "2.同一类的两个对象，若其有相同的属性，则被称为两个对象是“相等”的", "3.InputStreamReader/OutputStreamWriter是抽象类，是不能用于实例化（创建对像的）", "4.StringBuffer类中的方法equals()方法比较的是“同一”", "5.抽象类是一个不完整的类，只能实例化，不能派生出子类。", "6.Oracle最新版本的JDK已不再提供对Applet的支持", "7.StringBuffer是系统定义的处理字符串的类，用它可以创建动态字符串，它有非常好的时间效率（与String相比较）", "8.java.awt 和 java.swing相比，java.swing 的特点是:功能更强,GUI效果更佳,占用资源较多。", "9.引用变量的类型转换包括：Widening reference conversions 和Narrowing reference conversions ，但一个对象只能暂时被当成更一般的对象来看待（Widening reference conversions），而不能是相反的转换。", "单选题：", "如果一个编译单元没有包名的话，该包被称为匿名包。以下说法正确的是", "A、匿名包可以实现包的隐藏；", "B、匿名包可简化程序设计；", "C、匿名包只能用于测试目的；", "D、匿名包可实现类的封装；", "\n", "我个人觉得判断题2.7.8是对的，3.4.5是错的，但不是很确定，其他问题查不到解释，问题比较多，谢谢愿意解答的各位！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;整体修改如下&amp;#xff0c;修改处见注释语句&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;string.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\ntypedef struct people {&lt;!-- --&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义联系人结构体\n        char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;名字\n        char tel[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;电话\n}P;\nP num[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义结构体数组&amp;#xff0c;可以存&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;个联系人的信息\nint i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用于作联系人的序号&amp;#xff0c;或者可以判断联系人个数是否到达了最大值\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;函数声明\nvoid menu();\nvoid add();\nvoid del();\nvoid find();\nvoid edit();\nvoid print();\nvoid listbyname();\n\nint main() {\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;通讯录管理系统&amp;#34;&lt;/span&gt;);\n    int &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;选择值\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n          menu();&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;菜单\n          scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt;);\n          switch (&lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt;) {\n             case &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;退出系统\n             case &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:add(); &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;添加联系人\n             case &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:del(); &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除联系人\n             case &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:find(); &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找联系人\n             case &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:edit(); &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;编辑联系人\n             case &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;:print(); &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;打印通讯录\n            default:printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入错误&amp;#xff0c;请重新输入&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n         }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;菜单\nvoid menu() {\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t通讯录管理系统\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t 0.退出通讯录\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t 1.添加联系人\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t 2.删除联系人\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t 3.查找联系人\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t 4.修改联系人\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\t 5.查看通讯录\\n&amp;#34;&lt;/span&gt;);\n \n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请选择&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;与用户交互、显示输出的话语&amp;#xff08;我这里是将函数里的输出语句都写在了一个函数里&amp;#xff0c;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;通过调用来显示&amp;#xff0c;让函数显得整洁一点&amp;#xff09;\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;判断字符串是否相等&amp;#xff0c;用于查询、删除、编辑等操作\n&lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;nt my_strcmp(char name[],int j) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;接收输入的名字与该结构体数组下标\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    char* p1 &amp;#61; name;               &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;strcmp参数是指针&amp;#xff0c;所以将他们用指针表示\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    char* p2 &amp;#61; (char*)&amp;amp;num[j];\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;打印单个人的信息&amp;#xff0c;用于删除和编辑操作\nvoid print2(int j) {\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;序号\\t姓名\\t\\t电话\\n&amp;#34;&lt;/span&gt;);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%2d\\t%s\\t\\t%s\\n&amp;#34;&lt;/span&gt;, (j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;),num[j].name, num[j].tel);\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.增加联系人\nvoid add() {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;如果通讯录满了就不能在添加了\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;该通讯录已经装满了&amp;#xff01;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;警告提示\n        return;\n    }\n    char chose; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用于判断是否要继续添加\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入联系人的姓名&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示输入名字\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, num[i].name);\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &amp;amp;num[i].name);\n        getchar(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;清除缓存区\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入联系人的电话&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示输入电话\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, num[i].tel);\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &amp;amp;num[i].tel);\n        getchar(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;清除缓冲区\n        i&amp;#43;&amp;#43;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;添加一个联系人就加一\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;添加成功&amp;#xff01;是否继续添加 Y/N&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示是否继续添加\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, &amp;amp;chose);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (chose &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;n&amp;#39;&lt;/span&gt; || chose &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;N&amp;#39;&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;选择y或Y就继续添加&amp;#xff0c;其他值退出\n        &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (chose &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;y&amp;#39;&lt;/span&gt; || chose &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;)\n           &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;结束本次循环&amp;#xff0c;回到判断条件处\n        }\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;return;\n    }\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除的详细操作&amp;#xff0c;将该联系人的信息变成后一个联系人&amp;#xff0c;就算删除成功\nvoid del2(int j) {\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j; j &amp;lt; i; j&amp;#43;&amp;#43;) {\n         num[j] &amp;#61; num[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    }\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;.删除联系人\nvoid del() {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;判断当前是否有联系人\n    &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (i &amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;当前没有联系人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        return;\n    }\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用来接收输入的要删除的联系人姓名\n    int chose&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用作判断\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要删除的联系人姓名&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除的姓名\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, name);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;) {\n         &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(name,num[j].name) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在数组里查找与输入名相同的元素\n         &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (my_strcmp(name,j) &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n             printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;确认删除以下信息&amp;#xff1f;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示当前联系人信息\n             print2(j); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;显示当前的联系人信息\n             printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.确认 2.返回\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示是否确认删除\n             scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;chose);\n             &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (chose &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n                del2(j); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;进行删除操作\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;删除成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示删除成功\n                i--; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;联系人的个数要减一\n                return;\n             }\n         }\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有找到该联系人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;没有找到目标&amp;#xff0c;提示没有此人\n    return;\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;.查找\nvoid find() {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;判断当前是否有联系人\n    &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n       printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;当前没有联系人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n       return;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要查找的联系人姓名&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示输入查找姓名\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;接收姓名\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, name);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(name,num[j].name) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找与输入姓名相同的元素\n        &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (my_strcmp(name,j) &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;查找成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示找到了目标联系人\n            print2(j); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;显示该联系人的信息\n            return;\n        }\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;经查无此人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示没有找到联系人\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;.修改\nvoid edit() {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;判断当前是否有联系人\n    &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n       printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;当前没有联系人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n       return;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要修改的联系人姓名&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入编辑姓名\n    char name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;接收姓名\n    char chose; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用于选择\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, name);\n    getchar(); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;清除缓存区\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(name, num[j].name) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找与输入姓名相同的元素\n        &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (my_strcmp(name, j) &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;当前联系人信息为&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示找到此人\n            print2(j); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入此人信息\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;是否确认修改&amp;#xff1f;Y/N&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示是否确认编辑\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, &amp;amp;chose); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入选择\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (chose &amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;y&amp;#39;&lt;/span&gt; || chose &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;){\n            &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (chose &amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;y&amp;#39;&lt;/span&gt; || chose &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;)\n               printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入新的姓名&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示输入新姓名\n               scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, num[j].name); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入新姓名\n               &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &amp;amp;num[j].name);\n               printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入新的电话&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示输入新电话\n               scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, num[j].tel); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入新电话\n               &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &amp;amp;num[j].tel);\n               printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;修改成功&amp;#xff01;当前联系人信息为&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示编辑成功\n               print2(j); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;显示新联系人信息\n               return;\n            }\n        }\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有该联系人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;提示没有此人\n}\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;.显示通讯录\nvoid print() {\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;判断当前是否有联系人\n    &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;f (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n       printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;当前没有联系人&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n       return;\n    }\n    int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;作数组下标&amp;#xff0c;从第一个元素开始输出\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;序号\\t姓名\\t\\t电话\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%2d\\t%s\\t\\t%s\\n&amp;#34;&lt;/span&gt;, (j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;), num[j].name, num[j].tel);\n    }\n}\n\nvoid listbyname()&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按姓名排序,冒泡排序\n{\n    int k, j;\n    &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;nt i, j;\n    struct people temp;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;person是之前定义的结构体\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(k&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;k&amp;lt;i-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;k&amp;#43;&amp;#43;)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; i 为通讯录中联系人的个数&amp;#xff08;int和*P不兼容&amp;#xff09;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;num-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; - k; j&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; num - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; - i; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (strcmp(num[j].name, num[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].name) &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; strcmp为字符串比较(头文件为&amp;lt;string.h&amp;gt;)\n            {\n                temp &amp;#61; num[j];\n                num[j] &amp;#61; num[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                num[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; temp;\n            }\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["int类型和指针不兼容怎么算", ["问题遇到的现象和发生背景", "\n", "通讯录系统最后一个通讯录排序运行", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include<stdio.h>", "#include<string.h>", "#include<stdlib.h>", "typedef struct people {//定义联系人结构体", "    char name[20];//名字", "    char tel[20];//电话", "}P;", "P num[100];//定义结构体数组，可以存100个联系人的信息", "int i=0;//用于作联系人的序号，或者可以判断联系人个数是否到达了最大值", "\n", "//函数声明", "void menu();", "void add();", "void del();", "void find();", "void edit();", "void print();", "void listbyname()", "int main() {", "    system(\"通讯录管理系统\");", "    int in;//选择值", "    while (1) {", "        menu();//菜单", "        scanf(\"%d\", &in);", "        switch (in) {", "        case 0:return 0;            //退出系统", "        case 1:add(); break;    //添加联系人", "        case 2:del(); break;    //删除联系人", "        case 3:find(); break;    //查找联系人", "        case 4:edit(); break;    //编辑联系人", "        case 5:print(); break;    //打印通讯录", "        default:printf(\"输入错误，请重新输入：\\n\"); break;", "        }", "    }", "    return 0;", "}", "\n", "//菜单", "void menu() {", "\n", "printf(", "\"", "\\t", "通讯录管理系统", "\\n", "\"", ");\nprintf(", "\"", "\\t", " 0.退出通讯录", "\\n", "\"", ");\nprintf(", "\"", "\\t", " 1.添加联系人", "\\n", "\"", ");\nprintf(", "\"", "\\t", " 2.删除联系人", "\\n", "\"", ");\nprintf(", "\"", "\\t", " 3.查找联系人", "\\n", "\"", ");\nprintf(", "\"", "\\t", " 4.修改联系人", "\\n", "\"", ");\nprintf(", "\"", "\\t", " 5.查看通讯录", "\\n", "\"", ");\n\nprintf(", "\"请选择：\"", ");\n", "\n", "}", "//与用户交互、显示输出的话语（我这里是将函数里的输出语句都写在了一个函数里，通过调用来显示，让函数显得整洁一点）", "\n", "//判断字符串是否相等，用于查询、删除、编辑等操作", "int my_strcmp(char name[],int j) {    //接收输入的名字与该结构体数组下标", "    char* p1 = name;                //strcmp参数是指针，所以将他们用指针表示", "    char* p2 = (char*)&num[j];", "    return 0;", "}", "//打印单个人的信息，用于删除和编辑操作", "void print2(int j) {", "    printf(\"序号\\t姓名\\t\\t电话\\n\");", "    printf(\"%2d\\t%s\\t\\t%s\\n\", (j+1),num[j].name, num[j].tel);", "}", "//1.增加联系人", "void add() {", "    if (i > 100) {                            //如果通讯录满了就不能在添加了", "        printf(\"该通讯录已经装满了！\\n\");                            //警告提示", "        return;", "    }", "    char chose;                                //用于判断是否要继续添加", "    while (1) {", "        printf(\"请输入联系人的姓名：\\n\");                        //提示输入名字", "        scanf(\"%s\", &num[i].name);", "        getchar();                            //清除缓存区", "        printf(\"请输入联系人的电话：\\n\");                        //提示输入电话", "        scanf(\"%s\", &num[i].tel);", "        getchar();                            //清除缓冲区", "        i++;                                //添加一个联系人就加一", "        printf(\"添加成功！是否继续添加 Y/N：\\n\");                        //提示是否继续添加", "        scanf(\"%c\", &chose);", "        if (chose = 'y' || chose = 'Y') {    //选择y或Y就继续添加，其他值退出", "            continue;                        //结束本次循环，回到判断条件处", "        }", "        return;", "    }", "}", "//删除的详细操作，将该联系人的信息变成后一个联系人，就算删除成功", "void del2(int j) {", "        for (j; j < i; j++) {", "            num[j] = num[j + 1];", "    }", "}", "//2.删除联系人", "void del() {", "    if (i =0) {                            //判断当前是否有联系人", "        printf(\"当前没有联系人！\\n\");", "        return;", "    }", "    char name[20];                            //用来接收输入的要删除的联系人姓名", "    int chose=0;                            //用作判断", "    printf(\"请输入要删除的联系人姓名：\\n\");                            //删除的姓名", "    scanf(\"%s\", name);", "    for (int j = 0; j < i; j++) {", "        if (my_strcmp(name,j) = 0) {        //在数组里查找与输入名相同的元素", "            printf(\"确认删除以下信息？\\n\");                    //提示当前联系人信息", "            print2(j);                        //显示当前的联系人信息", "            printf(\"1.确认 2.返回\\n\");                    //提示是否确认删除", "            scanf(\"%d\", &chose);", "            if (chose = 1) {", "                del2(j);                    //进行删除操作", "                printf(\"删除成功！\\n\");                //提示删除成功", "                i-;                        //联系人的个数要减一", "                return;", "            }", "        }", "    }", "    printf(\"没有找到该联系人！\\n\");                            //没有找到目标，提示没有此人", "    return;", "}", "//3.查找", "void find() {", "    if (i = 0) {                            //判断当前是否有联系人", "        printf(\"当前没有联系人！\\n\");", "        return;", "    }", "    printf(\"请输入要查找的联系人姓名：\\n\");                            //提示输入查找姓名", "    char name[20];                            //接收姓名", "    scanf(\"%s\", name);", "    for (int j = 0; j < i; j++) {", "        if (my_strcmp(name,j) = 0) {        //查找与输入姓名相同的元素", "            printf(\"查找成功！\\n\");                    //提示找到了目标联系人", "            print2(j);                        //显示该联系人的信息", "            return;", "        }", "    }", "    printf(\"经查无此人！\\n\");                            //提示没有找到联系人", "}", "//4.修改", "void edit() {", "    if (i = 0) {                            //判断当前是否有联系人", "        printf(\"当前没有联系人！\\n\");", "        return;", "    }", "    printf(\"请输入要修改的联系人姓名：\\n\");                            //输入编辑姓名", "    char name[20];                            //接收姓名", "    char chose;                                //用于选择", "    scanf(\"%s\", name);", "    getchar();                                //清除缓存区", "    for (int j = 0; j < i; j++) {", "        if (my_strcmp(name, j) = 0) {        //查找与输入姓名相同的元素", "            printf(\"当前联系人信息为：\\n\");                    //提示找到此人", "            print2(j);                        //输入此人信息", "            printf(\"是否确认修改？Y/N：\\n\");                    //提示是否确认编辑", "            scanf(\"%c\", &chose);            //输入选择", "            if (chose ='y' || chose = Y') {", "                printf(\"请输入新的姓名：\\n\");                //提示输入新姓名", "                scanf(\"%s\", &num[j].name);    //输入新姓名", "                printf(\"请输入新的电话：\\n\");                //提示输入新电话", "                scanf(\"%s\", &num[j].tel);    //输入新电话", "                printf(\"修改成功！当前联系人信息为：\\n\");                //提示编辑成功", "                print2(j);                    //显示新联系人信息", "                return;", "            }", "        }", "    }", "    printf(\"没有该联系人！\\n\");                            //提示没有此人", "}", "//5.显示通讯录", "void print() {", "    if (i = 0) {                            //判断当前是否有联系人", "        printf(\"当前没有联系人！\\n\");", "        return;", "    }", "    int j = 0;                                //作数组下标，从第一个元素开始输出", "    printf(\"序号\\t姓名\\t\\t电话\\n\");", "    for (j = 0; j < i; j++) {", "        printf(\"%2d\\t%s\\t\\t%s\\n\", (j + 1), num[j].name, num[j].tel);", "    }", "}", "\n", "void listbyname()//按姓名排序,冒泡排序", "{", "    int i, j;", "    struct people temp;//person是之前定义的结构体", "    for(i=0;i<num-1;i++)//num为通讯录中联系人的个数（int和*P不兼容）", "    {", "        for (j = 0; j < num - 1 - i; j++)", "        {", "            if (strcmp(num[j].name, num[j + 1].name) > 0)// strcmp为字符串比较(头文件为<string.h>)", "            {", "                temp = num[j];", "                num[j] = num[j + 1];", "                num[j + 1] = temp;", "            }", "        }", "    }", "}", "\n", "运行结果及报错内容", "\n", "姓名排序 for(i=0;i<num-1;i++) int类型与指针不兼容怎么改", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "为什么要 return double(s)\r\n\r\ndouble fact(int n)\r\n{\r\n    if (n == 1)\r\n        return 1;\r\n\r\n    if(n&gt;1)\r\n        return n*(n-1);\r\n}", "Konwledge_Point": "定义新的类型", "Question": ["C语言新手求助各位大佬", ["求组合数（15 分）", "\n本题要求编写程序，根据公式C", "\n​n", "\n​m", "\n​​ =", "\n​m!(n−m)!", "\n​", "\n​n!", "\n​​ 算出从n个不同元素中取出m个元素（m≤n）的组合数。", "\n\n", "建议定义和调用函数fact(n)计算n!，其中n的类型是int，函数类型是double。", "\n\n", "输入格式:", "\n\n", "输入在一行中给出两个正整数m和n（m≤n），以空格分隔。", "\n\n", "输出格式:", "\n\n", "按照格式“result = 组合数计算结果”输出。题目保证结果在double类型范围内。", "\n\n", "题目如上", "\n\n", "我的代码是", "\n\n", "#include \"stdio.h\"", "\ndouble fact(int n);", "\nmain()", "\n{", "\n    int m,n;", "\n    double result;", "\n    scanf(\"%d %d\",&m,&n);", "\n    if(m>n)", "\n        printf(\"error!!\");", "\n    else", "\n    {", "\n    result=fact(n)/(fact(m)*fact(n-m));", "\n    printf(\"result=%lf\",result);", "\n    }", "\n}", "\ndouble fact(int n)", "\n{", "\n    int i,s=1;", "\n    if(n>1)", "\n    {", "\n        for(i=1;i<=n;i++)", "\n        {", "\n            s*=i;", "\n        }", "\n        return double(s);", "\n    }", "\n    if(n=1)", "\n    s=1;", "\n}", "\n\n", "找不到问题出在哪里可就是得不到正确的结果 求助555555555QAQ"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;指针要根据要指的东西来确定&amp;#xff0c;类型要一致&lt;br /&gt;你数组里的元素是int型&amp;#xff0c;那么指针也得是int型&lt;br /&gt;你数组是二维数组&amp;#xff0c;那么指针也要是二级指针&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c++指针的一个问题", ["如果我定义了一个行指针 int (", "p)[4]=a,a是二维数组int a[4][4],我知道", "(p+i)+j是二维数组中第i行第j个元素的地址，那么如果我要定义一个新的指针b指向这个元素，也就是说b的内容是该元素的地址，那么他的数据类型是什么类型，还有我知道*p+i是第i行的地址，那么同样如果我要一个指针内容是这个地址，我应该用什么数据类型的指针"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;/*\n* C语言学生信息管理系统&amp;#xff08;动态链表版&amp;#xff09;\n* 功能&amp;#xff1a;增添新键数据、修改删除数据、查询统计数据\n* 平台&amp;#xff1a;windows\n*/\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n#include &amp;lt;windows.h&amp;gt;\n# define LEN sizeof(struct Student)\n \nstruct Student {\n\tchar num[10];  /*学号*/\n\tchar name[20]; /*姓名*/\n\tchar sex[10];  /*性别*/\n\tint age;       /*年龄*/\n\tchar phone[12];/*电话*/\n\tchar qq[12];   /*QQ号*/\n\tchar nativePlace[20];/*籍贯*/\n\tchar department[20];/*系别*/\n\tchar major[20];/*专业*/\n\tchar className[20];/*班级*/\n\tstruct Student *next;\n};\n \nchar filename[30];//全局变量&amp;#xff0c;用来保存要打开的文件名字\n \n\t\t\t\t  /*生成链表*/\nstruct Student *Creat(int n) {\n\tvoid menu_print_in(void);\n\tstruct Student *head;\n\tstruct Student *p1, *p2;\n    int i;\n\tsystem(&amp;#34;cls&amp;#34;);\n\tfor (i &amp;#61; 1;i &amp;lt; n &amp;#43; 1;i&amp;#43;&amp;#43;) {\n\t\tp1 &amp;#61; (struct Student*)malloc(LEN);\n\t\tmenu_print_in();\n\t\tscanf(&amp;#34;%s %s %s %d %s %s %s %s %s %s&amp;#34;, p1-&amp;gt;num, p1-&amp;gt;name, p1-&amp;gt;sex,\n\t\t\t&amp;amp;p1-&amp;gt;age, p1-&amp;gt;phone, p1-&amp;gt;qq,p1-&amp;gt;nativePlace,p1-&amp;gt;department,p1-&amp;gt;major,p1-&amp;gt;className);\n\t\tp1-&amp;gt;next &amp;#61; NULL;\n\t\tif (i &amp;#61;&amp;#61; 1) {\n\t\t\thead &amp;#61; p2 &amp;#61; p1;\n\t\t}\n\t\telse {\n\t\t\tp2-&amp;gt;next &amp;#61; p1;\n\t\t\tp2 &amp;#61; p1;\n\t\t}\n\t}\n\treturn(head);\n}\n \n/*数据存盘(wb只写)*/\nvoid WriteData_wb(struct Student *head) {\n\tFILE *fp;\n\tstruct Student *p;\n\tif ((fp &amp;#61; fopen(filename, &amp;#34;wb&amp;#34;)) &amp;#61;&amp;#61; NULL)\n\t\tprintf(&amp;#34;\\a error! Can not open the file!&amp;#34;);\n\tp &amp;#61; head;\n\twhile (p !&amp;#61; NULL) {\n\t\tif (fwrite(p, LEN, 1, fp) !&amp;#61; 1) {\n\t\t\tprintf(&amp;#34;写入数据出错\\n&amp;#34;);\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t\tp &amp;#61; p-&amp;gt;next;\n\t}\n\tfclose(fp);\n}\n \n/*数据存盘(ab追加)\nvoid WriteData_ab(struct Student *head) {\n\tFILE *fp;\n\tstruct Student *p;\n\tif ((fp &amp;#61; fopen(filename, &amp;#34;ab&amp;#34;)) &amp;#61;&amp;#61; NULL)\n\t\tprintf(&amp;#34;\\a error! Can not open the file!&amp;#34;);\n\tp &amp;#61; head;\n\twhile (p !&amp;#61; NULL) {\n\t\tif (fwrite(p, LEN, 1, fp) !&amp;#61; 1) {\n\t\t\tprintf(&amp;#34;写入数据出错\\n&amp;#34;);\n\t\t\tfclose(fp);\n\t\t\treturn;\n\t\t}\n\t\tp &amp;#61; p-&amp;gt;next;\n\t}\n\tfclose(fp);\n}\n/*读取数据*/\n/*读取数据文件保存到链表中 &amp;#xff0c;返回指向此链表头指针*/\nstruct Student *ReadData(void) {\n\tstruct Student *head &amp;#61; NULL;\n\tstruct Student *p1, *p2;//s &amp;#61; p1;p &amp;#61; p2;\n \n\tFILE *fp;\n\tif ((fp &amp;#61; fopen(filename, &amp;#34;rb&amp;#43;&amp;#34;)) &amp;#61;&amp;#61; NULL)\n\t{\n\t\tprintf(&amp;#34;打开文件出错\\n&amp;#34;);\n\t\texit(0);\n\t}\n\twhile (!feof(fp)) {\n\t\tif ((p1 &amp;#61; (struct Student*)malloc(LEN)) &amp;#61;&amp;#61; NULL) {\n\t\t\tprintf(&amp;#34;内存申请出错\\n&amp;#34;);\n\t\t\tfclose(fp);\n\t\t\texit(0);\n\t\t}\n\t\tif (fread(p1, LEN, 1, fp) !&amp;#61; 1) {\n\t\t\tfree(p1);\n\t\t\tbreak;\n\t\t}\n\t\tif (head &amp;#61;&amp;#61; NULL)\n\t\t\thead &amp;#61; p2 &amp;#61; p1;\n\t\telse {\n\t\t\tp2-&amp;gt;next &amp;#61; p1;\n\t\t\tp2 &amp;#61; p1;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn (head);\n}\n \n/*【1】全量查询*/\nvoid Print_inquire_all(void) {\n\tvoid menu_print_out(void);\n\tstruct Student *pt;\n\tpt &amp;#61; ReadData();\n\tmenu_print_out();\n\tdo {\n\t\tprintf(&amp;#34;%-10s%6s%8s%4d%13s%11s  %s %s %s %s\\n&amp;#34;,\n\t\t\tpt-&amp;gt;num, pt-&amp;gt;name, pt-&amp;gt;sex, pt-&amp;gt;age, pt-&amp;gt;phone, pt-&amp;gt;qq, pt-&amp;gt;nativePlace, pt-&amp;gt;department, pt-&amp;gt;major, pt-&amp;gt;className);\n\t\tpt &amp;#61; pt-&amp;gt;next;\n\t} while (pt !&amp;#61; NULL);\n\tprintf(&amp;#34;\\n\\n&amp;#34;);\n}\n \n/*【2】学号查询*/\nint Print_inquire_num() {\n\tvoid menu_print_out(void);\n\tstruct Student *pt;\n\tchar str_num[10];\n\tprintf(&amp;#34;◎请输入您要查询的学号:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;, str_num);\n\tpt &amp;#61; ReadData();\n\tmenu_print_out();\n\tdo {\n\t\tif (strcmp(pt-&amp;gt;num, str_num) &amp;#61;&amp;#61; 0) {\n\t\t\tprintf(&amp;#34;%-10s%6s%8s%4d%13s%11s %s %s %s %s\\n&amp;#34;,\n\t\t\t\tpt-&amp;gt;num, pt-&amp;gt;name, pt-&amp;gt;sex, pt-&amp;gt;age, pt-&amp;gt;phone, pt-&amp;gt;qq, pt-&amp;gt;nativePlace, pt-&amp;gt;department, pt-&amp;gt;major, pt-&amp;gt;className);\n\t\t\tprintf(&amp;#34;\\n\\n&amp;#34;);\n\t\t\treturn 0;\n\t\t}\n\t\tpt &amp;#61; pt-&amp;gt;next;\n\t} while (pt !&amp;#61; NULL);\n\tprintf(&amp;#34;数据库中没有存储您要查询的数据&amp;#xff01;\\n&amp;#34;);\n\tprintf(&amp;#34;\\n\\n&amp;#34;);\n\treturn 0;\n}\n \n/*【3】姓名查询*/\nint Print_inquire_name() {\n\tvoid menu_print_out(void);\n\tstruct Student *pt;\n\tchar str_name[20];\n\tprintf(&amp;#34;◎请输入您要查询的姓名:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;, str_name);\n\tpt &amp;#61; ReadData();\n\tmenu_print_out();\n\tdo {\n\t\tif (strcmp(pt-&amp;gt;name, str_name) &amp;#61;&amp;#61; 0) {\n\t\t\tprintf(&amp;#34;%-10s%6s%8s%4d%13s%11s  %s %s %s %s\\n&amp;#34;,\n\t\t\t\tpt-&amp;gt;num, pt-&amp;gt;name, pt-&amp;gt;sex, pt-&amp;gt;age, pt-&amp;gt;phone, pt-&amp;gt;qq, pt-&amp;gt;nativePlace, pt-&amp;gt;department, pt-&amp;gt;major, pt-&amp;gt;className);\n\t\t\tprintf(&amp;#34;\\n\\n&amp;#34;);\n\t\t\treturn 0;\n\t\t}\n\t\tpt &amp;#61; pt-&amp;gt;next;\n\t} while (pt !&amp;#61; NULL);\n\tprintf(&amp;#34;数据库中没有存储您要查询的数据&amp;#xff01;\\n&amp;#34;);\n\tprintf(&amp;#34;\\n\\n&amp;#34;);\n\treturn 0;\n}\n \n/*【4】模糊查询*/\nint Print_inquire_fuzzy(void) {\n\tvoid menu_print_out(void);\n\tstruct Student *pt;\n\tchar str_find[20];\n\tint m &amp;#61; 0;\n\tprintf(&amp;#34;◎请输入您要查询的关键词:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;, str_find);\n\tpt &amp;#61; ReadData();\n\tmenu_print_out();\n\tdo {\n\t\tif (strstr(pt-&amp;gt;num, str_find) !&amp;#61; 0 || strstr(pt-&amp;gt;name, str_find) !&amp;#61; 0\n\t\t\t|| strstr(pt-&amp;gt;sex, str_find) !&amp;#61; 0 || strstr(pt-&amp;gt;phone, str_find) !&amp;#61; 0\n\t\t\t|| strstr(pt-&amp;gt;qq, str_find) !&amp;#61; 0) {\n\t\t\tprintf(&amp;#34;%-10s%6s%8s%4d%13s%11s %s %s %s %s\\n&amp;#34;,\n\t\t\t\tpt-&amp;gt;num, pt-&amp;gt;name, pt-&amp;gt;sex, pt-&amp;gt;age, pt-&amp;gt;phone, pt-&amp;gt;qq, pt-&amp;gt;nativePlace, pt-&amp;gt;department, pt-&amp;gt;major, pt-&amp;gt;className);\n\t\t\tm &amp;#61; 1;\n\t\t}\n\t\tpt &amp;#61; pt-&amp;gt;next;\n\t} while (pt !&amp;#61; NULL);\n\tif (!m)\n\t\tprintf(&amp;#34;数据库中没有存储您要查询的数据&amp;#xff01;\\n&amp;#34;);\n\tprintf(&amp;#34;\\n\\n&amp;#34;);\n\treturn 0;\n}\n \n/*【1】修改数据之删除记录*/\nint Delete() {\n\tstruct Student *pt1, *pt2, *head;\n\tchar str_num[20];\n\tprintf(&amp;#34;\\n◎请输入您要删除的学号信息:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;, str_num);\n\tpt1 &amp;#61; ReadData();\n\tpt2 &amp;#61; pt1-&amp;gt;next;\n\thead &amp;#61; pt1;\n\twhile (pt2 !&amp;#61; NULL) {\n\t\tif (strcmp(pt1-&amp;gt;num, str_num) &amp;#61;&amp;#61; 0) {\n\t\t\tWriteData_wb(pt2);\n\t\t}\n\t\telse if (strcmp(pt2-&amp;gt;num, str_num) &amp;#61;&amp;#61; 0) {\n\t\t\tpt1-&amp;gt;next &amp;#61; pt2-&amp;gt;next;\n\t\t\tWriteData_wb(head);\n\t\t}\n\t\tpt2 &amp;#61; pt2-&amp;gt;next;\n\t\tpt1 &amp;#61; pt1-&amp;gt;next;\n\t}\n\tif (pt2 !&amp;#61; NULL)\n\t\tprintf(&amp;#34;数据库中没有存储您要删除的数据&amp;#xff01;\\n&amp;#34;);\n\tprintf(&amp;#34;\\n\\n&amp;#34;);\n\treturn 0;\n}\n \n/*【2】修改数据之修改记录*/\nint Amend() {\n\tvoid menu_print_in(void);\n\tstruct Student *pt1, *pt2, *head;\n\tchar str_num[20];\n\tprintf(&amp;#34;◎请输入您要修改的学号信息:&amp;#34;);\n\tscanf(&amp;#34;%s&amp;#34;, str_num);\n\tpt1 &amp;#61; ReadData();\n\tpt2 &amp;#61; pt1-&amp;gt;next;\n\thead &amp;#61; pt1;\n\twhile (pt2 !&amp;#61; NULL) {\n\t\tif (strcmp(pt1-&amp;gt;num, str_num) &amp;#61;&amp;#61; 0) {\n\t\t\tmenu_print_in();\n\t\t\tscanf(&amp;#34;%s %s %s %d %s %s %s %s %s %s&amp;#34;, pt1-&amp;gt;num, pt1-&amp;gt;name, pt1-&amp;gt;sex,\n\t\t\t\t&amp;amp;pt1-&amp;gt;age, pt1-&amp;gt;phone, pt1-&amp;gt;qq, pt1-&amp;gt;nativePlace, pt1-&amp;gt;department, pt1-&amp;gt;major, pt1-&amp;gt;className);\n\t\t\tWriteData_wb(head);\n\t\t}\n\t\telse if (strcmp(pt2-&amp;gt;num, str_num) &amp;#61;&amp;#61; 0) {\n\t\t\tmenu_print_in();\n\t\t\tscanf(&amp;#34;%s %s %s %d %s %s %s %s %s %s&amp;#34;, pt2-&amp;gt;num, pt2-&amp;gt;name, pt2-&amp;gt;sex,\n\t\t\t\t&amp;amp;pt2-&amp;gt;age, pt2-&amp;gt;phone, pt2-&amp;gt;qq, pt2-&amp;gt;nativePlace, pt2-&amp;gt;department, pt2-&amp;gt;major, pt2-&amp;gt;className);\n\t\t\tWriteData_wb(head);\n\t\t}\n\t\tpt2 &amp;#61; pt2-&amp;gt;next;\n\t\tpt1 &amp;#61; pt1-&amp;gt;next;\n\t}\n\tif (pt2 !&amp;#61; NULL)\n\t\tprintf(&amp;#34;数据库中没有存储您要删除的数据&amp;#xff01;\\n&amp;#34;);\n\treturn 0;\n}\n \n/*【3】修改数据之整理数据*/\nint Neaten() {\n\tstruct Student *first;\n\tstruct Student *tail;\n\tstruct Student *p_min;\n\tstruct Student *min;\n\tstruct Student *p;\n\tstruct Student *head;\n\thead &amp;#61; ReadData();\n\tfirst &amp;#61; NULL;\n\twhile (head !&amp;#61; NULL) {\n\t\tfor (p &amp;#61; head, min &amp;#61; head; p-&amp;gt;next !&amp;#61; NULL; p &amp;#61; p-&amp;gt;next) {\n\t\t\tif (strcmp(p-&amp;gt;next-&amp;gt;num, min-&amp;gt;num) &amp;lt; 0) {\n\t\t\t\tp_min &amp;#61; p;\n\t\t\t\tmin &amp;#61; p-&amp;gt;next;\n\t\t\t}\n\t\t}\n\t\tif (first &amp;#61;&amp;#61; NULL) {\n\t\t\tfirst &amp;#61; min;\n\t\t\ttail &amp;#61; min;\n\t\t}\n\t\telse {\n\t\t\ttail-&amp;gt;next &amp;#61; min;\n\t\t\ttail &amp;#61; min;\n\t\t}\n\t\tif (min &amp;#61;&amp;#61; head) {\n\t\t\thead &amp;#61; head-&amp;gt;next;\n\t\t}\n\t\telse {\n\t\t\tp_min-&amp;gt;next &amp;#61; min-&amp;gt;next;\n\t\t}\n\t}\n\tif (first !&amp;#61; NULL) {\n\t\ttail-&amp;gt;next &amp;#61; NULL;\n\t}\n\thead &amp;#61; first;\n \n\tWriteData_wb(head);\n\treturn 0;\n}\n \n/*输入写入数据的数量*/\nint Creat_num(void) {\n\tint n;\n\tprintf(&amp;#34;\\n◎请输入您此次要添加的数据个数:&amp;#34;);\n\t\n\tif (scanf(&amp;#34;%d&amp;#34;, &amp;amp;n) !&amp;#61; 1) {\n\t\tprintf(&amp;#34;\\a error!&amp;#34;);\n\t}\n\treturn n;\n}\n \n/*选择将要打开的文件*/\nint File_name() {\n\tprintf(&amp;#34;\\n◎请输入您想要打开的文件:&amp;#34;);\n\tif (scanf(&amp;#34;%s&amp;#34;, filename) !&amp;#61; 1)\n\t\tprintf(&amp;#34;\\a error!&amp;#34;);\n\treturn 0;\n}\n \n/*主菜单*/\nvoid menu(void) {\n\tvoid menu_add(void);\n\tvoid menu_inquire(void);\n\tvoid menu_amend(void);\n\tint a &amp;#61; 0;\n\tprintf(&amp;#34;              ╭════════╮              \\n&amp;#34;);\n\tprintf(&amp;#34;╭══════╣学生管理系统V1.0╠══════╮\\n&amp;#34;);\n\tprintf(&amp;#34;║            ╰════════╯            ║\\n&amp;#34;);\n\tprintf(&amp;#34;║   【1】添加数据           【3】修改数据    ║\\n&amp;#34;);\n\tprintf(&amp;#34;║                                            ║\\n&amp;#34;);\n\tprintf(&amp;#34;║   【2】查询数据           【4】退出系统    ║\\n&amp;#34;);\n\tprintf(&amp;#34;║                                            ║\\n&amp;#34;);\n\tprintf(&amp;#34;╰══════════════════════╯\\n&amp;#34;);\n\tprintf(&amp;#34;◎请输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n \n\t\n\ta &amp;#61; getchar();\n \n\twhile (a !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;3&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;4&amp;#39;) {\n\t\tprintf(&amp;#34;error! please input the right number!\\n&amp;#34;);\n\t\tputchar(&amp;#39;\\a&amp;#39;);\n\t\tgetchar();\n\t\tprintf(&amp;#34;◎请重新输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n\t\ta &amp;#61; getchar();\n\t}\n\tswitch (a) {\n\tcase &amp;#39;1&amp;#39;: File_name();menu_add();\n\t\tbreak;\n\tcase &amp;#39;2&amp;#39;: File_name();menu_inquire();\n\t\tbreak;\n\tcase &amp;#39;3&amp;#39;: File_name();menu_amend();\n\t\tbreak;\n\tcase &amp;#39;4&amp;#39;: exit(0);\n\t\tbreak;\n\t}\n\tgetchar();\n}\n \n/*二级菜单之添加数据*/\nvoid menu_add(void) {\n\tint a &amp;#61; 0;\n\tsystem(&amp;#34;cls&amp;#34;);\n\tgetchar();\n\tprintf(&amp;#34;              ╭════════╮              \\n&amp;#34;);\n\tprintf(&amp;#34;╭══════╣  添加数据方式  ╠══════╮\\n&amp;#34;);\n\tprintf(&amp;#34;║            ╰════════╯            ║\\n&amp;#34;);\n\tprintf(&amp;#34;║ 【1】新建文件 【2】增添数据 【3】返回菜单  ║\\n&amp;#34;);\n\tprintf(&amp;#34;║                                            ║\\n&amp;#34;);\n\tprintf(&amp;#34;╰══════════════════════╯\\n&amp;#34;);\n\tprintf(&amp;#34;◎请输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n \n\t\n\ta &amp;#61; getchar();\n \n\twhile (a !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;3&amp;#39;) {\n\t\tprintf(&amp;#34;error! please input the right number!\\n&amp;#34;);\n\t\tputchar(&amp;#39;\\a&amp;#39;);\n\t\tgetchar();\n\t\tprintf(&amp;#34;◎请重新输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n\t\ta &amp;#61; getchar();\n\t}\n\tswitch (a) {\n\tcase &amp;#39;1&amp;#39;: WriteData_wb(Creat(Creat_num()));\n\t\tprintf(&amp;#34;\\n◎新建文件成功且数据已成功保存◎\\n&amp;#34;);\n\t\tsystem(&amp;#34;pause&amp;#34;);\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tmenu_add();\n\t\tbreak;\n\tcase &amp;#39;2&amp;#39;: WriteData_ab(Creat(Creat_num()));\n\t\tprintf(&amp;#34;\\n◎数据已成功添加◎\\n&amp;#34;);\n\t\tsystem(&amp;#34;pause&amp;#34;);\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tmenu_add();\n\t\tbreak;\n\tcase &amp;#39;3&amp;#39;: system(&amp;#34;cls&amp;#34;);\n\t\tgetchar();\n\t\tmenu();\n\t\tbreak;\n\t}\n}\n \n/*二级菜单之查询数据*/\nvoid menu_inquire(void) {\n\tint a &amp;#61; 0;\n\tsystem(&amp;#34;cls&amp;#34;);\n\tgetchar();\n\twhile (1) {\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tprintf(&amp;#34;              ╭════════╮              \\n&amp;#34;);\n\t\tprintf(&amp;#34;╭══════╣  查询数据方式  ╠══════╮\\n&amp;#34;);\n\t\tprintf(&amp;#34;║            ╰════════╯            ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║    【1】全量查询         【4】模糊查询     ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║                                            ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║    【2】学号查询         【5】返回菜单     ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║                                            ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║    【3】姓名查询                           ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;╰══════════════════════╯\\n&amp;#34;);\n\t\tprintf(&amp;#34;◎请输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n\t\t\n\t\ta &amp;#61; getchar();\n \n\t\twhile (a !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;3&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;3&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;4&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;5&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;6&amp;#39;) {\n\t\t\tprintf(&amp;#34;error! please input the right number!\\n&amp;#34;);\n\t\t\tputchar(&amp;#39;\\a&amp;#39;);\n\t\t\tgetchar();\n\t\t\tprintf(&amp;#34;◎请重新输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n\t\t\ta &amp;#61; getchar();\n\t\t}\n\t\tswitch (a) {\n\t\tcase &amp;#39;1&amp;#39;: Print_inquire_all();system(&amp;#34;pause&amp;#34;);getchar();\n\t\t\tbreak;\n\t\tcase &amp;#39;2&amp;#39;: Print_inquire_num();system(&amp;#34;pause&amp;#34;);getchar();\n\t\t\tbreak;\n\t\tcase &amp;#39;3&amp;#39;: Print_inquire_name();system(&amp;#34;pause&amp;#34;);getchar();\n\t\t\tbreak;\n\t\tcase &amp;#39;4&amp;#39;: Print_inquire_fuzzy();system(&amp;#34;pause&amp;#34;);getchar();;\n\t\t\tbreak;\n\t\tcase &amp;#39;5&amp;#39;: system(&amp;#34;cls&amp;#34;);getchar();menu();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n \n/*二级菜单之修改数据*/\nvoid menu_amend(void) {\n\tint a &amp;#61; 0;\n\tsystem(&amp;#34;cls&amp;#34;);\n\tgetchar();\n\twhile (1) {\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tprintf(&amp;#34;              ╭════════╮              \\n&amp;#34;);\n\t\tprintf(&amp;#34;╭══════╣  修改数据方式  ╠══════╮\\n&amp;#34;);\n\t\tprintf(&amp;#34;║            ╰════════╯            ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║    【1】删除记录          【3】整理数据    ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║                                            ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;║    【2】修改记录          【4】返回菜单    ║\\n&amp;#34;);\n\t\tprintf(&amp;#34;╰══════════════════════╯\\n&amp;#34;);\n\t\tprintf(&amp;#34;◎请输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n \n\t\t\n\t\ta &amp;#61; getchar();\n \n\t\twhile (a !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;3&amp;#39;&amp;amp;&amp;amp;a !&amp;#61; &amp;#39;4&amp;#39;) {\n\t\t\tprintf(&amp;#34;error! please input the right number!\\n&amp;#34;);\n\t\t\tputchar(&amp;#39;\\a&amp;#39;);\n\t\t\tgetchar();\n\t\t\tprintf(&amp;#34;◎请重新输入功能前的序号进入相应的工具:【   】\\b\\b&amp;#34;);\n\t\t\ta &amp;#61; getchar();\n\t\t}\n\t\tswitch (a) {\n\t\tcase &amp;#39;1&amp;#39;: Delete();\n\t\t\tprintf(&amp;#34;\\n\\n◎已成功删除指定数据◎\\n&amp;#34;);\n\t\t\tsystem(&amp;#34;pause&amp;#34;);\n\t\t\tgetchar();\n\t\t\tbreak;\n\t\tcase &amp;#39;2&amp;#39;: Amend();\n\t\t\tprintf(&amp;#34;\\n\\n◎已成功修改指定数据◎\\n&amp;#34;);\n\t\t\tsystem(&amp;#34;pause&amp;#34;);\n\t\t\tgetchar();\n\t\t\tbreak;\n\t\tcase &amp;#39;3&amp;#39;: Neaten();\n\t\t\tprintf(&amp;#34;\\n\\n◎数据已成功按照学号重新排列◎\\n&amp;#34;);\n\t\t\tsystem(&amp;#34;pause&amp;#34;);\n\t\t\tgetchar();\n\t\t\tbreak;\n\t\tcase &amp;#39;4&amp;#39;: system(&amp;#34;cls&amp;#34;);\n\t\t\tgetchar();\n\t\t\tmenu();\n\t\t\tbreak;\n\t\t}\n\t}\n}\n \n/*输入输出提示栏*/\nvoid menu_print_in(void) {\n\tprintf(&amp;#34;------------------------------------------------------------------------\\n&amp;#34;);\n\tprintf(&amp;#34;学号      姓名     性别  年龄    电话         QQ        籍贯  系别  专业  班级   \\n&amp;#34;);\n\tprintf(&amp;#34;------------------------------------------------------------------------\\n&amp;#34;);\n}\nvoid menu_print_out(void) {\n\tprintf(&amp;#34;--------------------------------------------------------------------------\\n&amp;#34;);\n\tprintf(&amp;#34;学号      姓名     性别  年龄    电话         QQ        籍贯  系别  专业  班级 \\n&amp;#34;);\n\tprintf(&amp;#34;--------------------------------------------------------------------------\\n&amp;#34;);\n}\n \n/*主函数*/\nint main(void) {\n\tSetConsoleTitle(L&amp;#34;学生学籍管理系统&amp;#34;);\n\tmenu();\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;如果对你有帮助&amp;#xff0c;可以点击我这个回答右上方的【采纳】按钮&amp;#xff0c;给我个采纳吗&amp;#xff0c;谢谢&lt;br /&gt;\n &lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["学生学籍管理系统c语言", ["学生学籍管理系统", "\n\n", "课外实践要求", "\n\n", "定义学生结构体类型", "创建学生结构体类型数组或 单链表", "输入学生的信息", "将学生的信息存入硬盘", "可以打开文件将学生信息从硬盘文件中读入程序", "在程序中可以按指定学号或姓名查找某个学生的信息并显示", "在程序中可以删除某个指定学生的信息", "可以输入一个新的学生的信息到该班级", "可以修改某个指定学生的信息"]], "Tag": "程序设计"}
{"Answer": "三个if每个最后都加上continue;\r\n否则继续往下就不对了，你调试下就知道", "Konwledge_Point": "定义新的类型", "Question": ["C语言新手求助，关于用if统计字母组合的问题", ["问题是要用一个程序记录输入字符中“ei”的个数，但是问题是当我用这种定义bool类型的办法（我知道这个方法过于复杂，但是还是想了解下哪里有问题）进行操作最后无论如何输入结果都是0个，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你自己定义的&lt;/p&gt;\n\n&lt;pre&gt;\nStudentFrom构造函数中&amp;#xff0c;没有新建ui&lt;/pre&gt;\n\n&lt;p&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;StudentFrom::StudentFrom(Student * user, QWidget *parent) : QWidget(parent), user(user),\n    ui(new Ui::StudentFrom)\n{\n    //setWindowFlags(Qt::Window);\n    ui-&amp;gt;setupUi(this);\n\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["QT 如何正确创建自定义的QWidget子类窗口", ["最近在学习QT，于是打算写个成绩管理系统，本想着登陆成功就弹出用户使用的系统窗口（StudentFrom），结果碰壁，想了很久不知道怎么回事。", "\n\n", " ", "\n\n", "这是StudentFrom.h文件内容：", "\n\n", "\n", "#ifndef STUDENTFROM_H\n#define STUDENTFROM_H\n\n#include <QWidget>\n\n#include\"userfrom.h\"\n#include\"student.h\"\n\nnamespace Ui {\nclass StudentFrom;\n}\n\nclass StudentFrom : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    explicit StudentFrom(QWidget *parent = nullptr);\n    explicit StudentFrom(Student * user, QWidget *parent = nullptr);\n    ~StudentFrom();\n\nprivate:\n    Ui::StudentFrom *ui;\n\n    Student * user=nullptr;\n\n};\n\n#endif // STUDENTFROM_H", "\n\n", "定义函数createUserFrom，根据用户类型（user_type）创建对应的用户窗口（这里只能创建学生窗口）。函数定义如下：", "\n\n", "\n", "QWidget * createUserFrom(int user_type, Person * user)\n{\n    switch(user_type)\n    {\n    case STUDENT:\n        {\n            return new StudentFrom((Student *)(user));\n            break;\n        }\n    case TEACHER:\n        {\n            break;\n        }\n    default:\n        return nullptr;\n    }\n    return nullptr;\n}", "\n\n", "使用学生账号登陆结束后创建StudentFrom窗口，代码如下（user_from是QWidget指针）：", "\n\n", "\n", "if(true==creatUser(user_type))//建立当前用户\n    {\n        user_from=(StudentFrom *)createUserFrom(user_type, user);//创建用户窗口\n        if(user_from!=nullptr)\n            user_from->show();\n\n        this->hide();//隐藏窗口\n    }", "\n\n", "这是StudentFrom的ui：", "\n\n", "\n\n", "但是结果谈出来的窗口是这个样子的：", "\n\n", "\n\n", " 我感觉user_from是QWidget窗口而非StudentFrom窗口，StudentFrom有关的文件也没有问题，因为我直接定义一个StudentFrom对象show出来的窗口没有问题，这我就觉得很奇怪了，希望高人指点指点。"]], "Tag": "程序设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;fprintf(fchuhu,&amp;#34;%s\\t %s\\t%s\\t %lf\\t%s\\n&amp;#34;,&amp;amp;hu[A].name,&amp;amp;hu[A].idnumber,&amp;amp;hu[A].password,&amp;amp;hu[A].cunkuan,&amp;amp;hu[A].idnum);     //用fprintf函数将数据打印到chuhu.txt文件里&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;这一句中&amp;#xff0c;hu[A].cunkuan不应该取地址&amp;#xff08;其实那些char数组也不需要写&amp;amp;&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;另外吐槽一下&amp;#xff0c;你发的代码格式好混乱&amp;#xff0c;我调整了半天&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["有关c语言 double类型数据录入文件的问题", ["先谢谢大家了🙏", "下面是这个部分的代码", "void zhuce(){", "   FILE *nchuhu=fopen(\"chuhu.txt\",\"r\");//只读文件,查看是否已存在", "   FILE *fchuhu=fopen(\"chuhu.txt\",\"a\");//以附加的方式打开只写文件,若文件不存在则建立该文件", "   int i;", "   if((nchuhu=fopen(\"chuhu.txt\",\"r\"))==NULL) printf(\"文件不存在，将由系统创建\\n\");//判断文件是否存在", "   do{", "      system(\"cls\");//清除fopen函数判断输出值", "      date();//显示当前日期", "      printf(\"\\n\\n\\t\\t请输入新储户的信息：\");", "      fscanf(nchuhu,\"%s\\t %s\\t%s\\t %lf\\t%s\\n\",&hu[A].name,&hu[A].idnumber,&hu[A].password,", "                                                             &hu[A].cunkuan,&hu[A].idnum);", "        printf(\"\\n\\t姓名：\");                   //姓名", "      fflush(stdin);//刷新一下缓存区,将缓冲区内的数据清空并丢弃,避免键盘缓存区中未读出的字符影响程序.", "      gets(hu[A].name);", "\n", "    ", "//判断身份证格式是否正确", "\n    ", "do", "{\n        printf(", "\"请输入身份证号码(18位)：\"", ");\n        fflush(stdin);\n        gets(hu[", "A", "].idnumber);\n        ", "if", "(strlen(hu[", "A", "].idnumber)", "!=", "18", ")", "//strlen函数计算字符串长度,判断身份证位数是否正确", "\n            printf(", "\"", "\\n", "\\t", "输入错误！", "\\n", "\\t", "身份证号必须为18位数字或最后一位为字母", "\\n", "\"", ");\n\n\n    }", "while", "((strlen(hu[", "A", "].idnumber)", "!=", "18", ") );\n\n  fflush(stdin);\n    printf(", "\"", "\\n", "\\t", "\\t", "储户密码（6位）：\"", ");\n    ", "for", "(i", "=", "0", ";i", "<", "6", ";i", "++", "){\n        fflush(stdin);\n        hu[", "A", "].password[i]", "=", "getch();;\n\n  }\n\n    printf(", "\"输入要存储的金额：\"", ");              ", "//存款", "\n    fflush(stdin);\n  scanf(", "\"%lf\"", ",", "&", "hu[", "A", "].cunkuan);\n\n    printf(", "\"正在开户中……", "\\n", "\"", ");                      ", "//生成账号", "\n    printf(", "\"系统生成账号为(请牢牢记住你的账号):\"", ");\n    ", "self", "(", "A", "+", "1", ");", "//根据开户人数A生成特定账号", "\n    printf(", "\"%s", "\\n", "\\t", "\"", ",hu[", "A", "].idnum);\n    fprintf(fchuhu,", "\"%s", "\\t", " %s", "\\t", "%s", "\\t", " %lf", "\\t", "%s", "\\n", "\"", ",", "&", "hu[", "A", "].name,", "&", "hu[", "A", "].idnumber,", "&", "hu[", "A", "].password,", "&", "hu[", "A", "].cunkuan,", "&", "hu[", "A", "].idnum);     ", "//用fprintf函数将数据打印到chuhu.txt文件里", "\n  ", "A", "++", ";\n  printf(", "\"继续开户请按y      返回主界面请按n\"", ");\n  fflush(stdin);\n  scanf(", "\"%c\"", ",", "&", "ch);\n", "\n", "   }", "    while(ch=='y'||ch=='Y');", "   printf(\"存入成功！\\n\");", "   system(\"cls\");", "   fclose(nchuhu);//将上面打开的文件关闭", "   fclose(fchuhu);", "}", "\n", "然后就是这个存款接收不进去", "\n", "\n", "\n", "一直显示0.000000", "我接收double型的方法也没问题啊！不知道哪里出了问题", "下面这个是结构体定义", "\n", "1. "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Demo&lt;/span&gt; {\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[] arr &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;};\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; d &amp;#61; arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i&amp;#43;&amp;#43;) {\n            arr[i]&amp;#61;arr[i]/d;\n        }\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(Arrays.&lt;span class=\"hljs-built_in\"&gt;toString&lt;/span&gt;(arr));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果可以请采纳&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["java数组除以2  请教一下", ["定义一个double类型的数组，让数组中每个元素（包括首位元素）都除以首位元素，得到的结果过作为该位置上的新元素。请在原先数组数组上操作，并输出新数组~", "例如数组[2,4,6,4]经过运算得到新数组[1,2,3,2]"]], "Tag": "程序设计"}
{"Answer": "这个就和 mfc中的afx_msg效果是一样的，都是备用的宏定义，这里没有任何意义，你完全可以把device_builtin去掉来看", "Konwledge_Point": "定义新的类型", "Question": ["C语言中#define的问题", ["我在学CUDA的时候看到库文件driver_type.h中的一个定义", "\ntypedef ", "device_builtin", " enum cudaError cudaError_t;", "\n看不懂这是什么意思。", "\n\n", "cudaError_t是新定义类型。", "\n\n", "cudaError的定义是：enum ", "device_builtin", " cudaError{...}", "\n\n", "device_builtin", "是： #define ", "device_builtin", "\n\n", "我不明白这里的__device_builtin__在enum ", "device_builtin", " cudaError{...}和", "\ntypedef ", "device_builtin", " enum cudaError cudaError_t;这两个地方都是什么意思？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;emmmmm..&lt;br /&gt;大体框架和思路都没问题&amp;#xff0c; 但是“使用虚基类和虚函数”没有具体出&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于#C++#的问题，如何解决？", ["class TStatement", "{", "public:", "virtual void GetType() =0;", "void GetContent()", "\n", "};", "class TInclude:public TStatement", "{", "public:", "void GetType()", "{", "return", "}", "只有这些思路，对这个程序理解有点抽象，下面的是具体程序", "建立一个简单的C语言源程序解析程序，包括对语句和函数的解析。需要完成如下功能：", "1、建立一个基类TStatement类，要能表示语句的类型和内容，并把语句的类型获取函数GetType()字义为纯虚函数，内容获取函数GetContent()定义为普通成员函数。", "2、建立一个预编译指令类TInclude、一个函数定义语句类TFunction和一个赋值语句类TAssignment，均由类TStatement继承而来。要求可以输出预编译指令类（函数定义语句类/赋值语句类）对象的属性（类型和内容），分别写出GetType()函数的具体实现。", "3、从类TStatement派生循环语句类TLoop，并从TLoop派生出TFor、TWhile类，分别写出各个子类的具体实现。", "4、编写main（）主函数，读入一个C语言源程序文件，依次输出其中的各条语句的类型和内容在显示器上，可将结果保存成一个新的文本文件。", "【其它要求】", "（1）    使用虚基类和虚函数。", "（2）    所有类都需要定义构造函数。", "（3）    项目需用多文件。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;$a&lt;/code&gt;改变的原因&amp;#xff1a;第一个里面使得&lt;code class=\"language-javascript\"&gt;$a&lt;/code&gt;和&lt;code class=\"language-javascript\"&gt;$c&lt;/code&gt;共用一个地址&amp;#xff0c;因此&lt;code class=\"language-javascript\"&gt;$c&lt;/code&gt;改变也会导致&lt;code class=\"language-javascript\"&gt;$a&lt;/code&gt;改变&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-php\"&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 第一个\n&lt;span class=\"hljs-variable\"&gt;$a&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n&lt;span class=\"hljs-variable\"&gt;$b&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-variable\"&gt;$a&lt;/span&gt;;\n&lt;span class=\"hljs-variable\"&gt;$c&lt;/span&gt; &amp;#61; &amp;amp;&lt;span class=\"hljs-variable\"&gt;$a&lt;/span&gt;;\necho &lt;span class=\"hljs-variable\"&gt;$a&lt;/span&gt;  . PHP_EOL . &lt;span class=\"hljs-variable\"&gt;$b&lt;/span&gt;;\nvar_dump(&lt;span class=\"hljs-variable\"&gt;$c&lt;/span&gt;);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 第二个\n&lt;span class=\"hljs-variable\"&gt;$b&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n&lt;span class=\"hljs-variable\"&gt;$c&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;;\nvar_dump( (&lt;span class=\"hljs-variable\"&gt;$a&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-variable\"&gt;$b&lt;/span&gt;)?&lt;span class=\"hljs-string\"&gt;&amp;#39;未改变&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-variable\"&gt;$a&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/036887339746116.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于#php#的问题：1.编写phe代码", ["1.编写phe代码，实现如下功能。", "\n", "(1)定义变量Sa=3,使用传值赋值给变量sb,使用引用赋值给变量&c,输出变量sa、sb.&c的类型和值。+", "\n", "(2)改变$b的值为4，Sc的值为\"hello\"，使用三元运算符 ，判断&a的值是否改变，如未变输出未改变，如改变输出Sa新的类型和值(在源程序中注释说明$a改变的原因)，并输出$b、&c的类型和值。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;题目里给出的条件是&amp;#xff1a;L1和L2是给定的带头结点的单链表&amp;#xff0c;List Merge( List L1, List L2 ); 函数里的操作要注意&amp;#xff0c;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ElementType;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Node&lt;/span&gt;* PtrToNode;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Node&lt;/span&gt; {\n    ElementType Data;\n    PtrToNode   Next;\n};\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; PtrToNode List;\n&lt;span class=\"hljs-function\"&gt;List &lt;span class=\"hljs-title\"&gt;Read&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;/* 细节在此不表 */&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(List L)&lt;/span&gt;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;/* 细节在此不表&amp;#xff1b;空链表将输出NULL */&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;List &lt;span class=\"hljs-title\"&gt;Merge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(List L1, List L2)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    List L1 &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;, L2 &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;, L;\n    &lt;span class=\"hljs-built_in\"&gt;srand&lt;/span&gt;((&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;));\n    L1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Read&lt;/span&gt;();\n    L2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Read&lt;/span&gt;();\n    L &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Merge&lt;/span&gt;(L1, L2);\n    &lt;span class=\"hljs-built_in\"&gt;Print&lt;/span&gt;(L);\n    &lt;span class=\"hljs-built_in\"&gt;Print&lt;/span&gt;(L1);\n    &lt;span class=\"hljs-built_in\"&gt;Print&lt;/span&gt;(L2);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;List &lt;span class=\"hljs-title\"&gt;Read&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    List p, q, tmp;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, n;\n    p &amp;#61; q &amp;#61; (List)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Node));\n    p-&amp;gt;Next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入链表的长度:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        tmp &amp;#61; (List)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Node));\n        tmp-&amp;gt;Next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        tmp-&amp;gt;Data &amp;#61; &lt;span class=\"hljs-built_in\"&gt;rand&lt;/span&gt;() % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        \n        p-&amp;gt;Next &amp;#61; tmp;\n        p &amp;#61; tmp;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; q;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(List L)&lt;/span&gt;\n&lt;/span&gt;{\n    List p &amp;#61; L-&amp;gt;Next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, p-&amp;gt;Data);\n        p &amp;#61; p-&amp;gt;Next;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;cmpfunc&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;* a, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;* b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (*(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)a - *(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)b);\n}\n\n&lt;span class=\"hljs-function\"&gt;List &lt;span class=\"hljs-title\"&gt;Merge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(List L1, List L2)&lt;/span&gt;\n&lt;/span&gt;{\n    List p, q, s, L;\n                         &lt;span class=\"hljs-comment\"&gt;//L &amp;#61; (List)malloc(sizeof(List));&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, num &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;10000&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n                         &lt;span class=\"hljs-comment\"&gt;//临时变量yyds&lt;/span&gt;\n    p &amp;#61; L1-&amp;gt;Next, q &amp;#61; L2-&amp;gt;Next;\n                        &lt;span class=\"hljs-comment\"&gt;//s &amp;#61; L;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)   &lt;span class=\"hljs-comment\"&gt;//while (p-&amp;gt;Next !&amp;#61; NULL)&lt;/span&gt;\n    {\n        a[i&amp;#43;&amp;#43;] &amp;#61; p-&amp;gt;Data;\n        p &amp;#61; p-&amp;gt;Next;\n        num&amp;#43;&amp;#43;;\n    }\n                         &lt;span class=\"hljs-comment\"&gt;//p-&amp;gt;Next &amp;#61; q;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (q !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;//while (q-&amp;gt;Next !&amp;#61; NULL)&lt;/span&gt;\n    {\n        a[i&amp;#43;&amp;#43;] &amp;#61; q-&amp;gt;Data;\n        q &amp;#61; q-&amp;gt;Next;\n        num&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;qsort&lt;/span&gt;(a, num, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;), cmpfunc);\n\n    s &amp;#61; L &amp;#61; (List)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Node));\n    L-&amp;gt;Next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num; i&amp;#43;&amp;#43;)\n    {    \n        L-&amp;gt;Next&amp;#61;(List)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Node));&lt;span class=\"hljs-comment\"&gt;//L-&amp;gt;Next&amp;#61;(List)malloc(sizeof(List));&lt;/span&gt;\n        L-&amp;gt;Next-&amp;gt;Data &amp;#61; a[i];\n        L-&amp;gt;Next-&amp;gt;Next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        L &amp;#61; L-&amp;gt;Next;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//L1-&amp;gt;Next &amp;#61; NULL;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//L2-&amp;gt;Next &amp;#61; NULL;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于新链表创建的具体问题", ["原题是PTA02-线性结构1 两个有序链表序列的合并", "本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。", "函数接口定义：", "List Merge( List L1, List L2 );", "其中List结构定义如下：", "\n", "typedef struct Node ", "PtrToNode;", "struct Node {", "    ElementType Data; /", " 存储结点数据 ", "/", "    PtrToNode   Next; /", " 指向下一个结点的指针 ", "/", "};", "typedef PtrToNode List; /", " 定义单链表类型 */", "L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。", "\n", "裁判测试程序样例：", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n\n", "typedef", " ", "int", " ElementType;\n", "typedef", " ", "struct", " ", "Node", " *PtrToNode;\n", "struct", " ", "Node", " {\n    ElementType Data;\n    PtrToNode   Next;\n};\n", "typedef", " PtrToNode List;\n\n", "List ", "Read", "()", "; ", "/* 细节在此不表 */", "\n", "void", " ", "Print", "( List L )", "; ", "/* 细节在此不表；空链表将输出NULL */", "\n\n", "List ", "Merge", "( List L1, List L2 )", ";\n\n", "int", " ", "main", "()", "\n", "{\n    List L1, L2, L;\n    L1 = ", "Read", "();\n    L2 = ", "Read", "();\n    L = ", "Merge", "(L1, L2);\n    ", "Print", "(L);\n    ", "Print", "(L1);\n    ", "Print", "(L2);\n    ", "return", " ", "0", ";\n}\n", "\n", "我写的函数部分如下:", "\n", "int", " cmpfunc (", "const", " ", "void", " * a, ", "const", " ", "void", " * b)\n{\n   ", "return", " ( *(", "int", "*)a - *(", "int", "*)b );\n}\n\n\n", "List", " Merge( ", "List", " L1, ", "List", " L2 )\n{\n    ", "List", " p,q,s,L;\n    \n    L=(", "List", ")malloc(sizeof(", "List", "));\n    ", "int", " i=", "0", ",num=", "1", ";\n    ", "int", " a[", "10000", "];\n    \n    ", "//临时变量yyds", "\n    p=L1,q=L2;\n    s=L;\n    \n    ", "while", "(p->Next!=", "NULL", ")\n    {\n        a[i++]=p->Data;\n        p=p->Next;\n        num++;\n    }\n    \n    p->Next=q;\n    \n    ", "while", "(q->Next!=", "NULL", ")\n    {\n        a[i++]=q->Data;\n        q=q->Next;\n        num++;\n    }\n    \n    qsort(a,num,sizeof(", "int", "),cmpfunc);\n    \n    ", "for", "(i=", "0", ";i<num;i++)\n    {\n        L->Data=a[i];\n", "//      L->Next=(List)malloc(sizeof(List));", "\n        L=L->Next;\n    }\n    \n    L1->Next=", "NULL", ";\n    L2->Next=", "NULL", ";\n    \n    ", "return", " s;\n}\n\n", "\n", "核心逻辑是将两个短的链表连起来,然后用一个数组放入所有的数据,再用c语言自带的qsort函数排序,但除了两个空链表的情况,永远都是段错误,我想过是否是我每增加一个新节点是否需要再次申请空间,在句中加入了 L->Next=(List)malloc(sizeof(List)); 但这样会全错,从新链表实际是否占有空间角度出发好像不对,思考了很久还是没想到问题出现在哪里", "\n", "此问题最快的O(n)算法我已经学习过了,但仍想找到自己的问题,所以来咨询大家!超级感谢!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;typedef int* (*FUNC)(int, int )&amp;#xff1a;定义了指针函数的别名为FUNC&amp;#xff0c;其两参数都为整形&amp;#xff0c;返回值为指针&lt;br /&gt;typedef void (*func_t) (int, float)&amp;#xff1a;定义了指针函数的别名为func_t&amp;#xff0c;其两参数一个为整形&amp;#xff0c; 一个为浮点行&amp;#xff0c;无返回值&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言typedef的疑问", ["最近连续碰到两题这样的题目，我根本就无法理解这里到底是什么意思", "1、typedef int* (*FUNC)(int, int );表示什么含义", "2、typedef void (*func_t)  (int, float)表示什么含义", "因为感觉和平时的typedef的使用有点不一样，以前的typedef使用都是typedef  旧类型  新类型  ,而在上面的题目中我分不清旧类型和新类型，不知道是不是在上面的使用中省略了什么吗？", "\n", "还有一个选择题", "C代码中可能会出现如下的结构体定义：", "\n", "typedef ", "struct", " ", "holder", " {\n  ", "struct", " ", "holder", " *next;\n  ", "struct", " ", "holder", " *prev;\n  char data[", "0", "];\n}holder;\n\n", "\n", "最后一行char data[0]的作用是？（多选）", "A、方便管理内存缓冲区", "B、减少内存碎片化", "C、使结构体数据对齐", "D、没有作用", "答案是AB", "\n", "感谢解答"]], "Tag": "程序设计"}
{"Answer": "可以写成一个文件\r\n文件中有一个public的class\r\n然后再定义内部类 public static class （可以有很多）\r\n就可以了  然后引用可以直接用这个内部类的\r\n这样的确可以做到\r\n\r\nPS: 内部类其实不是为了这个需求用的", "Konwledge_Point": "定义新的类型", "Question": ["c++实现的协议现在转成java，有个实现的地方不明白", ["我是java新手，本来有个c++实现的协议要用java来实现，协议本身是xml标记文件，c++实现将该文件转成struct类型，因为struct定义很多，都放在一个头文件里面。", "\n\n", "现在要用java来实现协议，我想做成一个package,但是只有public类才能在包外访问，是否所有的这些struct类型都要转成public class来实现呢，每个public class一个java文件？", "\n\n", "是不是应该还有其他的办法？"]], "Tag": "程序设计"}
{"Answer": "1NF是关系模型最基本的要求，不满足第一范式的数据库模式不能称为关系数据库：\r\n如下例：我们定义一个职工表，字段有：员工编号（主键）,员工姓名,电话（一个员工的电话可能有手机，家庭电话，办公室电话）。当我们要记录一个员工编号为10001，姓名为张三，他的电话分别是：手机135********；家庭电话021-15030***； 办公室电话：021-6666****的员工信息时，就无法做到：它明显违反了第一范式的定义：每一列都是不可分割的基本数据项，同一列中不能有多个值。——电话这一列有多个值，是可以再分割成：手机，家庭电话，办公室电话三个元子属性的。所以上面的未达到1NF，也就不是关系模式了。\r\n     我们为了达到1NF可以做以下修改：\r\n    （一）：以电话为主健：\r\n     那我们在存数据时一个员工的信息就会有三条如：10001 张三  135********；10001 张三 021-15030***； 10001 张三 021-6666****； （不建议）\r\n    （二）：以员工编号为主健，把电话拆成：手机，家庭电话，办公室电话三个栏位\r\n     那我们在存数据时一个员工的信息就会只有一条如：10001 张三  135******* 021-15030*** 021-6666****； （建议）", "Konwledge_Point": "定义新的类型", "Question": ["请问数据库第一范式的问题，其他两个范式我都理解，这里第一范式说的同一列不能有多个值是什么意思啊？", ["能举个不符合第一范式的例子吗，不管是不是关系型数据库什么的", "\n\n", "所谓第一范是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。"]], "Tag": "程序设计"}
{"Answer": "我都是用这个：renderer : formatDate\r\nfield也不用特殊配置：fields : [{name : 'openTime'}]\r\n\r\nfunction formatDate(value) {\r\n\tif (Ext.isEmpty(value)) {\r\n\t\treturn '';\r\n\t} else {\r\n\t\tif (Ext.isEmpty(value.time))\r\n\t\t\treturn Ext.util.Format.date(value, 'Y-m-d');//用于时间控件返回值\r\n\t\telse\r\n\t\t\treturn Ext.util.Format.date(new Date(value.time), 'Y-m-d');//用于数据库Timestamp类型的返回值\r\n\t}\r\n}", "Konwledge_Point": "定义新的类型", "Question": ["新手报道，问个格式化日期的问题", ["看过一片文章，", "1.首先要确保你store中的field是成功的把时间字符串转换为date类型", "我查看了一下服务器返回的json格式的数据", "类似这种", "\"validTime\":1293901323000,\"lastLoginTime\":1279165615000", "所以即使我加上了renderer : Ext.util.Format.dateRenderer('Y-m-d')", "页面显示 NaN-NaN-NaN", "问过别人，他们的数据返回是类似这样", "\"validTime\":new Date(1293901323000)", "所以renderer : Ext.util.Format.dateRenderer('Y-m-d')后能正确格式化日期", "这个是我的store，如何给validTime变为Date类型", "\n    var store = new Ext.data.JsonStore({ // 定义数据源为远程代理和JSON数据格式", "\n        url : 'user/list.json',", "\n        root : \"userList\",", "\n        totalProperty : 'userCount',", "\n        fields : [\"recId\", \"loginName\", \"userName\", \"role.roleName\",", "\n            \"validTime\",\"enabled\",\"shopId\"]", "\n    });"]], "Tag": "程序设计"}
{"Answer": "最简单的局势直接修改数据库中表的数据", "Konwledge_Point": "定义新的类型", "Question": ["数据库表增加字段后如何在获取历史数据时添加默认值？", ["表增加了一个字段，定义是基本类型有默认值，新生成的数据没问题但是历史数据该字段都是空值，导致程序会出错，JavaBean中的字段类型double和数据库中的空值不匹配，本来想在get和set中做点文章，返回一个默认值，但是用hibernate的detachedCriteria查询返回的list直接就报null的错误，set方法都没执行，不知道是什么原理为什么set方法都没执行，是不是在set传入变量的时候就发现空值然后就报错了？另外有没有办法让历史数据有默认值或者JavaBean自动生成默认值？"]], "Tag": "程序设计"}
{"Answer": "有错别字，重新说一次：\r\n\r\nemprs[0]和 ps[0]这两个引用都指向了Employer对象,现在你要把ps[0]指向的对象换成person对象，emprs[0]也会同时修改为指向该对象。而emprs[0]是Emloyer对象，这就成了“子类的引用执行父类对象”，这是不可以的。所以报错。", "Konwledge_Point": "定义新的类型", "Question": ["java核心技术中一个关于数组的例子不理解，请教大家", ["Person是Employer的父类，Employer有个新方法setBonus，代码如下   ", "\n\n", "Employer[] emprs ={new Employer(\"张三\"),new Employer(\"李四\")};              \nPerson[] ps =emprs;   \nps[0] = new Person(\"小明\");//运行时该行报错ArrayStoreException\nemprs[0].setBonus(2000);\n", "\n\n", "书中给出的解释是要保持数组中的元素对象类型一致，", "\n我不理解的是ps定义的元素的类型是Person，为什么在这里不能ps[0] = new Person(\"小明\")，ps[0]不是只是对new Person(\"小明\")的一个引用吗？他又不是Employer类型，我去给它赋值为Person类型有什么不可？", "\n\n", "另外以上代码如果不用数组的形式，就是两个对象这么操作下，是没有错误的。", "\n\n", "可能我以上的理解本身有错误，请大家指教指正。"]], "Tag": "程序设计"}
{"Answer": "这个东西你越搜索越迷惑，因为网上错误的说法占了主流。\r\n\r\n多态的意思很简单，就是一个概念，多种形态。\r\n很多人的误解在于，把多态简单理解为派生类的函数重写，这种理解是很片面的。函数重写是实现多态的一种手段，但是实现多态还有别的手段。\r\n\r\n首先说为什么函数重写是实现多态的一种手段，道理很简单，对于派生类来说，它也可以被视作基类的类型，因此它是一个概念。但是每个派生类相同的方法有自己独特的实现，这个就是多种形态。所以是多态。\r\n\r\n而多态还有别的手段，具体来说，泛型、函数重载、运算符重载（C++等语言支持，Java不支持）也是多态的实现手段。\r\n\r\n比如说泛型，一种数据结构或者算法就是同样的概念，而不同的参数类型构成了不同的形态。\r\n\r\n你提到了封装，你说getter/setter是封装，没错，但是也是片面的，除了getter/setter，用来修饰成员变量和方法的关键字，private protected，也构成封装，使得类外部不能直接访问它们。final 关键字修饰类，使得类不能派生，这也是封装，不加上virtual关键字的方法，不允许派生类重写，这也是封装。\r\n\r\n继承也是类似的，不过对于Java来说，的确只有接口和派生类两种。对于一些语言，支持原型（prototype）继承。\r\n总之，无论封装、继承还是多态，说的是面向对象的设计理念，而不是具体语法。", "Konwledge_Point": "定义新的类型", "Question": ["新入行小白了解谈java面向对象的三大属性有些疑惑，还望各路大神指教教导一下", ["面向对象的三大基本特征，众所周知是：封装，继承，多态。", "\n1.封装:把同一类事物的共性（包括属性和方法）归到同一类中，方便使用，也隐藏了信息，只需根据留在外部的接口（对象名和参数）进行操作，1）具体是通过getter,setter方法", "\n2.继承:是从已有的类中派生子类，有着父类的属性和行为，一般只支持单继承，是可传递的，继承了属性方法，也有自己新定义的属性方法。具体是extends,implents", "\n3.多态：这就是最有些疑惑的了，2)有很多人说继承是多态的前提，也有人说封装和继承都是多态的前提。甚至还有人说是继承的一种表现方式，但多态本身的话我也看到了很多，如编译期与运行期状态不同，同一个事务对象在不同时候的状态，也有允许不同类型的子对象对统一消息做出不同回应？不过，在多态这方面我目前能确定的是重写和重载构成多态，是体现多态的两种方法，即不同返回值，不同的参数个数就是多态（，也就是说方法的重写，重载与动态连接构成这多态性？可能也有理解有误，请多指教）。", "\n1）2）感觉也有些问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;QTableWidget *a&amp;#61;&amp;amp;b;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["QT开发，如何让QTableWidget a = QTableWidget b ?", ["QT开发，如何让QTableWidget a = QTableWidget b ?", "现有一个函数类型为QTableWidget，函数定义为QTableWidget excelToData()。", "希望用一个新的QTableWidget dt 来接收上述函数的返回值。", "如果直接用 ‘=’等于号 系统会报错： error: overload resolution selected deleted operator '='", "请问具体该如何操作？最好有代码和注解。"]], "Tag": "程序设计"}
{"Answer": "1.string kongzhi 改为 int kongzhi;\r\nif(kongzhi == 1)\r\n{ \r\n    进入系统\r\n}\r\nelse if(kongzhi == (int)('q') || kongzhi == int('Q'))\r\n{\r\n   //退出系统\r\n}\r\nelse\r\n{\r\n   //输入不正确 \r\n}\r\n\r\n2.判断一个数是由什么进制组成不可能，只能人为告诉 如输入一个 8 它即可以是十进制的8 也可以是十六进制的8 你没有办法进行程序判断它是属于那个进制的", "Konwledge_Point": "定义新的类型", "Question": ["本人是新手，这个程序还有没实现的一点小问题，调试了很久都没有结果！求帮助！", ["程序代码如下：", "\n现在遇到的问题是：1、cout<<\"输入q退出,输入1进入系统！\"; 执行这一句的时候，输入任意的字符都能进入下面的操作，怎么改可以只在输入1的时候进入系统 ", "\n2、如何把判断输入的字符串或者数值是不是相应的进制数加到对应的函数体内（如下/* */），如何实现（重新输入）功能？ ", "\nvoid AnyBinary2DecConvert::NumConvert(string SrcNum, int ConvertType)", "\n{", "\nint i;", "\nint len = SrcNum.size();", "\nint a[100];", "\nstring test;", "\n\n", "switch (ConvertType)", "\n{", "\ncase BINARY: //2进制", "\n/*for (i=0;i<=len;i++)", "\n{", "\nif (a[i] ==0 ||a[i] ==1)", "\n{", "\ncontinue;", "\n}", "\nelse", "\n{", "\ncout<<\"该数据不是二进制数，请重新输入！\"<<endl;", "\n}", "\nreturn;*/", "\n} ", "\ncase OCTAL: //8进制", "\ncase HEX: //16进制", "\nfor(i = 0; i < len; i++)", "\n{", "\nm_CovertedNumber += Char2Dec(SrcNum[i]) * pow(ConvertType, len-i-1);//计算ConvertType的len-i-1次幂", "\n}", "\ncout << m_CovertedNumber << endl;", "\nbreak;", "\ndefault:", "\ncout << \"error\" << endl;", "\nbreak;", "\n}", "\nreturn;", "\n}", "\n\n", "#include ", "\n#include ", "\n#include ", "\n#include ", "\n\n", "using namespace std;", "\n\n", "const int BINARY = 2; // 定义2进制数常量", "\nconst int OCTAL = 8; // 定义8进制数常量", "\nconst int DEC = 10; // 定义10进制数常量", "\nconst int HEX = 16; // 定义16进制数常量", "\n\n", "const int DEC2ANYBIN = 0; // 10进制转2\\8\\16进制", "\nconst int ANYBIN2DEC = 1; // 2\\8\\16进制转10进制", "\n\n", "class NumConvertMethod//定义一个NumConvertMethod基类 数字转换方法", "\n{", "\npublic:", "\nvirtual ~NumConvertMethod(){};//虚析构函数", "\nvirtual void NumConvert(string SrcNum, int ConvertType) = 0;//简单类型转换 第1个是目标数据类型，第2个是源数据", "\n};", "\n\n", "class Dec2AnyBinaryConvert : public NumConvertMethod", "\n{", "\npublic:", "\nDec2AnyBinaryConvert();//构造函数", "\nvirtual ~Dec2AnyBinaryConvert();//虚析构函数", "\nvirtual void NumConvert(string SrcNum, int ConvertType);", "\n\n", "private:", "\nchar Dec2Char(char num);", "\nstring m_CovertedNumber;", "\n};", "\n\n", "class AnyBinary2DecConvert : public NumConvertMethod", "\n{", "\npublic:", "\nAnyBinary2DecConvert();//构造函数：二、八、十六进制数转十进制数", "\nvirtual ~AnyBinary2DecConvert();//虚析构函数", "\nvirtual void NumConvert(string SrcNum, int ConvertType);// 简单类型转换 第1个是目标数据类型，第2个是源数据", "\n\n", "private:", "\nint Char2Dec(char &num);", "\nint m_CovertedNumber;", "\n};", "\n\n", "class NumConverter//定义一个NumConverter类", "\n{", "\npublic:", "\nNumConverter(int converter);//构造函数", "\n~NumConverter();//析构函数", "\nvoid NumConvert(string SrcNum, int ConvertType);", "\n\n", "private:", "\nNumConvertMethod *m_pnumconvertmethod;", "\n};", "\n\n", "Dec2AnyBinaryConvert::Dec2AnyBinaryConvert()", "\n{", "\nm_CovertedNumber = \"\";//定义字符串为\"\"", "\n}", "\n\n", "Dec2AnyBinaryConvert::~Dec2AnyBinaryConvert()", "\n{", "\nm_CovertedNumber = \"\";", "\n}", "\n\n", "char Dec2AnyBinaryConvert::Dec2Char(char num) //十进制转换成任意进制", "\n{", "\nif((num <= 9) && (num >= 0))//int类型的转换成字符型", "\n{", "\nnum += 48;", "\n}", "\nelse", "\n{", "\nswitch(num)//把十六进制数中10——15变成A------F", "\n{", "\ncase 10:", "\nnum='A';", "\nbreak;", "\ncase 11:", "\nnum='B';", "\nbreak;", "\ncase 12:", "\nnum='C';", "\nbreak;", "\ncase 13:", "\nnum='D';", "\nbreak;", "\ncase 14:", "\nnum='E';", "\nbreak;", "\ncase 15:", "\nnum='F';", "\nbreak;", "\ndefault:", "\nbreak;", "\n}", "\n}", "\n\n", "return num;", "\n}", "\n\n", "AnyBinary2DecConvert::AnyBinary2DecConvert() //定义构造函数AnyBinary2DecConvert，二、八、十六进制转换十进制", "\n{", "\nm_CovertedNumber = 0;", "\n}", "\n\n", "AnyBinary2DecConvert::~AnyBinary2DecConvert()//析构函数", "\n{", "\nm_CovertedNumber = 0;", "\n}", "\n\n", "int AnyBinary2DecConvert::Char2Dec(char &num)", "\n{", "\nif((num <= '9') && (num >= '0'))//int类型的转换成字符型", "\n{", "\nnum -= 48; //通过ASSCII", "\n}", "\n\n", "else", "\n{", "\nswitch(num)//把十六进制数中a(A)——f(F)变成10——15", "\n{", "\ncase 'A':", "\ncase 'a':", "\nnum=10;", "\nbreak;", "\ncase 'B':", "\ncase 'b':", "\nnum=11;", "\nbreak;", "\ncase 'C':", "\ncase 'c':", "\nnum=12;", "\nbreak;", "\ncase 'D':", "\ncase 'd':", "\nnum=13;", "\nbreak;", "\ncase 'E':", "\ncase 'e':", "\nnum=14;", "\nbreak;", "\ncase 'F':", "\ncase 'f':", "\nnum=15;", "\nbreak;", "\ndefault:", "\nbreak;", "\n}", "\n}", "\n\n", "return num;", "\n}", "\n\n", "//10进制转2\\8\\16进制方法", "\nvoid Dec2AnyBinaryConvert::NumConvert(string SrcNum, int ConvertType)", "\n{", "\nchar temp;", "\nint trans = atoi(SrcNum.c_str());//atoi字符串转换成整型数", "\nint i;", "\n\n", "switch (ConvertType)", "\n{", "\ncase BINARY: //2进制", "\ncase OCTAL: //8进制", "\ncase HEX: //16进制", "\nwhile(trans > 0)", "\n{", "\ntemp = trans % ConvertType;", "\nm_CovertedNumber += Dec2Char(temp);", "\ntrans = trans / ConvertType;", "\n}", "\n\n", "for(i = m_CovertedNumber.size()-1; i >= 0; i--)", "\n{", "\ncout << m_CovertedNumber[i];", "\n}", "\ncout << endl;", "\nbreak;", "\n\n", "default:", "\ncout << \"error\" << endl;", "\nbreak;", "\n}", "\nreturn;", "\n}", "\n\n", "//2\\8\\16进制转10进制方法", "\nvoid AnyBinary2DecConvert::NumConvert(string SrcNum, int ConvertType)", "\n{", "\nint i;", "\nint len = SrcNum.size();", "\nint a[100];", "\nstring test;", "\n\n", "switch (ConvertType)", "\n{", "\ncase BINARY: //2进制", "\nfor (i=0;i<=len;i++)", "\n{", "\nif (a[i] ==0 ||a[i] ==1)", "\n{", "\ncontinue;", "\n}", "\nelse", "\n{", "\ncout<<\"该数据不是二进制数，请重新输入！\"<<endl;", "\n}", "\nreturn;", "\n} ", "\ncase OCTAL: //8进制", "\ncase HEX: //16进制", "\nfor(i = 0; i < len; i++)", "\n{", "\nm_CovertedNumber += Char2Dec(SrcNum[i]) * pow(ConvertType, len-i-1);//计算ConvertType的len-i-1次幂", "\n}", "\ncout << m_CovertedNumber << endl;", "\nbreak;", "\ndefault:", "\ncout << \"error\" << endl;", "\nbreak;", "\n}", "\nreturn;", "\n}", "\n\n", "NumConverter::NumConverter(int converter)", "\n{", "\nif (converter == DEC2ANYBIN) //十进制转二、八、十六进制", "\n{", "\nm_pnumconvertmethod = new Dec2AnyBinaryConvert();", "\n}", "\nelse if (converter == ANYBIN2DEC) //二、八、十六进制转十进制", "\n{", "\nm_pnumconvertmethod = new AnyBinary2DecConvert();", "\n}", "\nelse", "\n{", "\nm_pnumconvertmethod = NULL;", "\n}", "\n}", "\n\n", "NumConverter::~NumConverter()", "\n{", "\nif (NULL != m_pnumconvertmethod)", "\n{", "\ndelete m_pnumconvertmethod;", "\n}", "\n}", "\n\n", "void NumConverter::NumConvert(string SrcNum, int ConvertType)", "\n{", "\nm_pnumconvertmethod->NumConvert(SrcNum, ConvertType);", "\n}", "\n\n", "// 主控制台,主要实现转换控制！", "\nint main(void)", "\n{", "\ncout<<\" #################################################################\"<\ncout\ncout\ncout\nstring test; ", "\nstring kongzhi;", "\nint type=0; //转换类型： 2进制或8进制或16进制", "\nint system=0; //转换选择：10进制转2、8、16进制 或 2、8、16进制转10进制", "\nwhile (1)//非0时执行", "\n{ ", "\ncout\ncin>>kongzhi;", "\nif (kongzhi.compare(0, 1, \"q\", 1) != 0)", "\n{", "\ncout << \"请选择转换系统:\" << endl;", "\ncout << \"0: 十进制 转 二\\八\\十六进制\" << endl;", "\ncout << \"1: 二\\八\\十六进制 转 十进制\" << endl;", "\ncin >> system;", "\n\n", "if (system != 0)", "\n{", "\ncout << \"请选择转换前类型:\" << endl;", "\ncout << \"2: 二进制\" << endl;", "\ncout << \"8: 八进制\" << endl;", "\n//cout << \"10: 十进制\" << endl;", "\ncout << \"16: 十六进制\" << endl;", "\n}", "\nelse", "\n{", "\ncout << \"请选择转换后类型:\" << endl;", "\ncout << \"2: 二进制\" << endl;", "\ncout << \"8: 八进制\" << endl;", "\n//cout << \"10: 十进制\" << endl;", "\ncout << \"16: 十六进制\" << endl;", "\n}", "\ncin >> type;", "\ncout<<\"请输入数据：\";", "\ncin>>test;", "\n\n", "NumConverter numconA(system);", "\nnumconA.NumConvert(test, type); //转换并输出转换结果", "\n}", "\nelse", "\n{", "\ncout << \"你已退出本系统!\" << endl;", "\nbreak;", "\n} return 0;", "\n}", "\nreturn 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "你好，Person PER=new Student();\r\n\t\t\t\tStudent STU=(Student)PER;\r\n\t\t\t\t首先这是多态，这两段代码是没有问题的，但是PER.mathscore=5;Per.StuSayHello()是不合法的，因为mathscore和StuSayHello()是子类的扩展属性和方法，在父类里面没有，子类没有重写父类里面任何方法，Person PER=new Student();这段代码虽然是父类引用指向子类对象，但是只有子类重写了父类的方法后，Per.StuSayHello()这样调用才会执行子类重写后的StuSayHello()方法。总结一下：多态的弊端，不能使用子类提油的功能，因为子类特有方法不是重写的，如果在多态情况下想使用子类特有的方法，应该向下转型。至于为什么PER.mathscore=5;是错误的，是因为父类中没有这个属性，你使用父类引用去访问这个成员会显示找不到符号等错误。再总结一下：多态的前提：A：有继承 B:有实现  C:有方法重写 D：有父类引用指向子类对象。多态中成员访问特点：A：访问成员变量：编译看左边，运行看左边。\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tB：访问成员方法：编译看左边：运行看右边。（如果子类有方法重写，就使用子类重写过的方法；父类引用不能使用子类特有的方法）", "Konwledge_Point": "定义新的类型", "Question": ["C#中父类转换成子类之后为什么不具备子类的属性和方法了", ["笔者是新手，已经在学习面向对象了，可是有一个疑问一直想不通：根据里氏转换原则，父类对象如果里面存储的是一个子类对象，那么这个父类对象是能够强转成子类的。可是根据本人的理解，父类对象强转成子类之后应该就是一个子类对象吧，为什么不具备子类的属性和方法呢。", "\n下面是具体案例：", "\n比如我定义了一个父类对象Person:", "\nClass Person", "\n{", "\nprivate string name;  //定义person类的姓名字段和属性", "\npublic string Name", "\n{", "\nget{return name;}", "\nset{name=value;}", "\n}", "\n\n", "private char sex;  //定义Person类的性别字段和属性", "\npublic char Sex", "\n{", "\nget{return sex;}", "\nset{sex=value;}", "\n}", "\n\n", "public void PersonSayHello()", "\n{", "\nConsole.WriteLine(\"我是一个人类！\");", "\n}", "\n}", "\n\n", "然后我又定义了一个Person类的子类Student:", "\nclass Student:Person  //继承于Person类", "\n{", "\nprivate int mathscore; //定义一个数学分数属性", "\npublic int MathScore", "\n{", "\nget{return mathscore;}", "\nset{mathscore=value;}", "\n}", "\n\n", "public void StuSayHello()", "\n{", "\nConsole.WriteLine(\"我是一个学生。\");", "\n}", "\n}", "\n\n", "然后我实际代码如下：", "\nPerson PER=new Student();  //创建一个Student对象，将其赋值给Person对象PER", "\nStudent STU=(Student)PER; //根据里氏转换原则，将PER对象转换成Student类型，并赋值给STU。", "\n\n", "接下来就是问题了，我特意使用PER的GetType()方法试了转换之后PER确实是Student类型，但是我不能为PER的mathscore属性赋值，也不能调用PER作为一个Student对象的StuSayHello()方法，这是为什么呢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;解决了 之前是在构造函数里面的赋的值 就一直是固定的值  改为在onpaint事件里面赋值就ok了&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c#Winform自定义控件的属性设置问题", [" 现在有个自定义控件 (button的拓展控件) 有一个属性 string类型的", "怎么样能让这个string类型的属性根据在工具箱中拖入窗体时变化 就类似button的text ，拖入一个就是button1 两个就是button2了", "目前是写死的只能这样", "\n", "\n", "想要的效果", "\n", "\n", "这个属性是新加的 所以得要在重绘时将原来button的text属性变为空字符串，而我在构造函数时将这个属性赋值为控件的名字结果是空的", "如果在定义时赋值 那结果就是死的了 没有达到我想要的效果。 应该怎么办"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;queue-&amp;gt;rear-&amp;gt;next &amp;#61; pnew;&lt;br /&gt;刚开始rear都是空的啊&amp;#xff0c;你就操作next啊。得先判断rear是否为空&amp;#xff0c;为空则rear就是新加入的节点&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言队列，入队的时候出现指针冲突", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<stdbool.h>", "\n", "#", "define", " SIZE 66         ", "//明示常量定义10，可以自行修改", "\n\n", "typedef", " ", "int", " datatype;\n\n", "//设计结构体，定义用户相关信息", "\n", "typedef", " ", "struct", " ", "client", "\n{\n    datatype id;        ", "//用户id序号", "\n    ", "char", " name[SIZE];    ", "/*定义字符数组存储用户名字，可考虑用字符指针，\n    但是字符指针不能逐个打印字符，暂且先用字符数组*/", "\n}nclient;\n\n", "//设计队列节点类型(即节点的内容)", "\n", "typedef", " ", "struct", " ", "node", "\n{\n    nclient data;       ", "//队列节点的数据域具有nclient类型", "\n    ", "struct", " ", "node", "* next;  ", "//队列节点的next指针域", "\n}ND, * PND;\n\n", "//设计队列基本操作的指针", "\n", "typedef", " ", "struct", " ", "linkqueue", "\n{\n    PND front;          ", "//队头指针", "\n    PND rear;           ", "//队尾指针", "\n}lq, * plq;\n\n", "//构造函数，用于建立链式队列", "\n", "plq ", "initqueue", "(", "void", ")", "\n", "{\n    plq queue = (plq)", "malloc", "(", "sizeof", "(lq));  ", "//定义一个队列，并且申请大小为队列操作本身lq的空间", "\n    ", "if", " (queue == ", "NULL", ")                    ", "//判断代码健壮性是否良好", "\n        ", "return", " ", "NULL", ";\n\n    queue->front = ", "NULL", ";", "//队列头尾开始都指向NULL", "\n    queue->rear = ", "NULL", ";\n\n    ", "return", " queue;       ", "//将*plq类型的queue返回", "\n}\n\n", "bool", " ", "emqueue", "(plq queue)", "\n", "{\n    datatype id = ", "0", ";\n    PND pnew = (PND)", "malloc", "(", "sizeof", "(ND));    ", "//定义一个node类型新节点用于存放新用户信息", "\n    ", "if", " (pnew == ", "NULL", ")                      ", "//判断代码健壮性好坏", "\n        ", "return", " ", "false", ";\n    ", "printf", "(", "\"please enter the client name: \"", ");\n    ", "scanf_s", "(", "\"%s\"", ", pnew->data.name,SIZE);       ", "/*atttion: 表达data的name，需要用.结构成员运算符。否则\n                                          出现E3364错误, 结构体变量是用\".\"*/", "\n    id++;                                  ", "//插入用户名后，用户获得一个id，id+1", "\n    pnew->data.id = id;                    \n    pnew->next = ", "NULL", ";                     ", "//pnew指向空", "\n    \n    queue->rear->next = pnew;              ", "//将rear的next指向新节点，完成节点的连接", "\n    queue->rear = pnew;                    ", "//将rear的位置移到最新节点位置，保证始终为队尾", "\n    ", "return", " ", "false", ";\n}\n\n", "bool", " ", "is_empty", "(plq queue)", "\n", "{\n    ", "if", " (queue->front == queue->rear)\n        ", "return", " ", "true", ";\n    ", "else", "\n        ", "return", " ", "false", ";\n}\n\n", "bool", " ", "dequeue", "(plq queue)", "\n", "{\n    ", "if", " (", "is_empty", "(queue))\n    {\n        ", "printf", "(", "\"the linkqueue is empty\\n\"", ");\n        ", "return", " ", "false", ";\n    }\n    PND ptamp = queue->front->next;\n}\n\n", "bool", " ", "showqueue", "(plq queue)", "\n", "{\n    ", "if", " (", "is_empty", "(queue))\n    {\n        ", "printf", "(", "\"the linkqueue is empty\\n\"", ");\n        ", "return", " ", "false", ";\n    }\n    PND ptamp = queue->front->next;\n    ", "while", " (ptamp != queue->rear)\n    {\n        ", "printf", "(", "\"%d\"", ", ptamp->data.id);\n        ", "printf", "(", "\"%s\"", ", ptamp->data.name);\n        ptamp = ptamp->next;\n    }\n    ", "return", " ", "true", ";\n}\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    plq queue = ", "initqueue", "();\n    ", "emqueue", "(queue);\n    ", "//showqueue(queue);", "\n}\n\n", "\n", "想问一下，这个是C语言的队列，在程序运行到第56行的时候发生了内存冲突，想问一下，是什么原因呀，该怎么解决？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;您好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;您的问题已经有小伙伴解答了&amp;#xff0c;您看下是否解决&amp;#xff0c;可以追评进行沟通哦~&lt;br /&gt;\n&lt;br /&gt;\n如果有您比较满意的答案 / 帮您提供解决思路的答案&amp;#xff0c;可以点击【采纳】按钮&amp;#xff0c;给回答的小伙伴一些鼓励哦&amp;#xff5e;&amp;#xff5e;&lt;br /&gt;\n&lt;br /&gt;\nps:问答VIP仅需29元&amp;#xff0c;即可享受5次/月 有问必答服务&amp;#xff0c;了解详情&amp;gt;&amp;gt;&amp;gt;&lt;a href=\"https://vip.csdn.net/askvip?utm_source&amp;#61;1146287632\"&gt;https://vip.csdn.net/askvip?utm_source&amp;#61;1146287632&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["序列化和反序列化之后，继续向集合中添加对象，新添加的对象如何被序列化到文件中", ["\n", "\n\npackage demo02.ReverseStream;\n\n\n\nimport java.io.*;\n\nimport java.util.ArrayList;\n\n\n\n/*\n\n    练习：序列化集合\n\n        当我们想在文件中保存多个对象的时候\n\n        可以把多个对象存储到一个集合中\n\n        对集合进行序列化和反序列化\n\n    分析：\n\n        1.定义一个存储Person对象的ArrayList集合\n\n        2.往ArrayList集合中存储Person对象\n\n        3.创建一个序列化流ObjectOutputStream对象\n\n        4.使用ObjectOutputStream对象中的方法WriteObject，对集合进行序列化\n\n        5.创建一个反序列化ObjectInputStream对象\n\n        6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合\n\n        7.把Object类型的集合转换为ArrayList类型的集合\n\n        8.遍历ArrayList集合\n\n        9.释放资源\n\n\n\n*/\n\npublic class demo02listTest {\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n\n        //1.定义一个存储Person对象的ArrayList集合\n\n        ArrayList<Person> list = new ArrayList<>();\n\n        // 2.往ArrayList集合中存储Person对象\n\n        list.add(new Person(\"周星驰\",56));\n\n        list.add(new Person(\"刘德华\",44));\n\n        list.add(new Person(\"周润发\",65));\n\n        list.add(new Person(\"李连杰\",68));\n\n        list.add(new Person(\"刘亦菲\",22));\n\n        list.add(new Person(\"刘诗诗\",18));//新添加的对象\n\n        //3.创建一个序列化流ObjectOutputStream对象\n\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"E:\\\\javaStudy\\\\test11.txt\",true));\n\n        //4.使用ObjectOutputStream对象中的方法WriteObject，对集合进行序列化\n\n        oos.writeObject(list);\n\n        //5.创建一个反序列化ObjectInputStream对象\n\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"E:\\\\javaStudy\\\\test11.txt\"));\n\n        // 6.使用ObjectInputStream对象中的方法readObject读取文件中保存的集合\n\n        Object o = ois.readObject();\n\n        //7.把Object类型的集合转换为ArrayList类型的集合\n\n        ArrayList<Person> list01 = (ArrayList<Person>) o;\n\n        //8.遍历ArrayList集合\n\n        for(Person per:list01){\n\n            System.out.println(per.getName()+\" \"+per.getAge());\n\n        }\n\n        //9.释放资源\n\n        ois.close();\n\n        oos.close();\n\n    }\n\n}"]], "Tag": "程序设计"}
{"Answer": "还是上代码比较合适。。。CInputImage 和 CResultView 的头文件记得添加", "Konwledge_Point": "定义新的类型", "Question": ["MFC多文档分割视之后创建的视指针运行总报错", ["我将窗口分割成两个部分，左边的创建新的类为CInputImage，右边的为CResultView，在class CSplitterwnd : public CMDIChildWnd里面定义类指针CInputImage ", "pOriginalView;和CResultView *pProcessedView;，运行的时候报错语法错误 : 缺少“;”(在“", "”的前面)和缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int。", "\n\n", "头文件也添加了，请问谁知道这是什么原因？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;每个方法会在 return 执行后结束&amp;#xff0c;你把打印语句写在在了 return 后面&amp;#xff0c;所以编译器认为 return 后面的语句都是无效的&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["请问这段java代码怎么修改？新手小白在线求救", ["package work;", "\n\n", "//定义一个Shape接口，接口中含有一个抽象方法，此抽象方法接收一个double类型的参数", "\ninterface Shape", "\n{", "\n    double area(double x);", "\n}", "\n\n", "//定义一个Square类，实现Shape接口", "\nclass Square implements Shape", "\n{", "\n    double area(double x)", "\n    {", "\n        double a=x*x;", "\n        return a;", "\n        System.out.println(\"正方形的面积为    \"+a);", "\n    }", "\n}", "\n\n", "//定义一个Circle类，实现Shape接口", "\nclass Circle implements Shape", "\n{", "\n    double area(double x)", "\n    {", "\n        double a=3.14*x*x;", "\n        return a;", "\n        System.out.println(\"圆的面积为   \"+a);", "\n    }", "\n}", "\n\n", "public class Test02 {", "\n\n", "    public static void main(String[] args) ", "\n    {", "\n        // TODO Auto-generated method stub", "\n        Square square=new Square();", "\n        square.area(2.00);", "\n        Circle circle=new Circle();", "\n        circle.area(3.00);", "\n\n", "    }", "\n\n", "}", "\n\n", "运行报错提示：", "\n\n", "Exception in thread \"main\" java.lang.Error: Unresolved compilation problem: ", "\n    Cannot reduce the visibility of the inherited method from Shape", "\n\n", "    at work.Square.area(Test02.java:12)", "\n    at work.Test02.main(Test02.java:37)", "\n "]], "Tag": "程序设计"}
{"Answer": "返回值有问题\r\nLinkStack Push(LinkStack *S, DataType x)\r\n{ /入栈函数*/\r\nLinkStack p;\r\np = (LinkStack *)malloc(sizeof(LinkStack));/动态分配一个结点空间*//*生成新结点*/\r\np-&gt;data = x; /*将x放入新结点的数据域*/\r\np-&gt;next = S-&gt;next;/*新结点作为栈顶*/\r\nS-&gt;next = p; /*将新结点插入链表表头之前*/\r\nreturn S; /*返回栈顶S*/\r\n}\r\n还有下面的void showstack返回值也有问题", "Konwledge_Point": "定义新的类型", "Question": ["数据结构 栈堆 入栈入不了", ["我想问一下为什么我的程序老是出错？", "\n#include ", "\n#include ", "\n#define  MAXSIZE  1000            /*数组最大长度为100*/", "\ntypedef  int  DataType;           /*定义DataType为int类型*/", "\ntypedef  struct  stacknode        /*链栈存储类型*/", "\n{", "\n    DataType        data;          /*定义结点的数据域*/", "\n    struct  stacknode    ", "next;    /", "定义结点的指针域*/", "\n} LinkStack;", "\n\n", "LinkStack  ", "InitStack()", "\n{  /", "初始化链栈函数*/", "\n    LinkStack ", "S;", "\n    S = (LinkStack *)malloc(sizeof(LinkStack));/", "动态分配一个结点空间*/", "\n    S->next = NULL; /*初始化栈为空*/", "\n\n", "}", "\n\n", "LinkStack ", "Push(LinkStack *S, DataType x)", "\n{  /", "入栈函数*/", "\n    LinkStack ", "p;", "\n    p = (LinkStack *)malloc(sizeof(LinkStack));/", "动态分配一个结点空间*//*生成新结点*/", "\n    p->data = x;   /*将x放入新结点的数据域*/", "\n    p->next = S->next;/*新结点作为栈顶*/", "\n    S->next = p; /*将新结点插入链表表头之前*/", "\n    return 1;           /*返回栈顶S*/", "\n\n", "}", "\n\n", "void ShowStack(LinkStack ", "S)", "\n{ /", "显示栈中元素*/", "\n\n", "LinkStack *q = S->next;  /*p结点指向原栈顶S*/\nwhile (q->data != NULL)\n{\n    printf(\" %d \", q->data); /*元素显示*/\n    q = q->next;/*指向其下一个结点*/\n}\nreturn 1;\n", "\n\n", "}", "\n\n", "int main()", "\n{", "\n    LinkStack *S;", "\n    DataType x;", "\n    int i = 0, n = 0;", "\n    S = InitStack();", "\n    printf(\"请输入要入栈的元素个数：\");", "\n    scanf(\"%d\", &n);", "\n    printf(\"请输入%d个整数进行入栈：\", n);", "\n    for (i = 0; i<n; i++)", "\n    {", "\n        scanf(\"%d\", &x);", "\n        S = Push(S, x);", "\n    }", "\n    printf(\"入栈成功！\");", "\n    ShowStack(S);", "\n}"]], "Tag": "程序设计"}
{"Answer": "到现在都没有个人把这题做完，无语。", "Konwledge_Point": "定义新的类型", "Question": ["java基础高手看这里了，这几道基础性的面试题求解答。", ["同学出去应聘，笔试的时候遇到这几道基础题不会做，拿给我看，发现自己也不怎么会，java基础好多都有些忘了，来帮忙解答一下吧。", "\n1、实现一个函数，函数有一个形参，类型为整数，功能是将形参的十进制数的二进制序列打印到控制台上。", "\n2、实现一个函数，函数有一个形参，类型为集合，功能是将集合中的内容按照每行3个输出（写出两种以上方法）。", "\n3、有数据表，字段定义为如下：", "\n客户  商品  报价  报价日期", "\n    表中存放着不同客户，不同商品，不同日期的报价。", "\n    请写一条sql语句。查出不同客户，不同商品，最新和最老的报价。", "\n（结果包括：客户，商品，最新报价，最老报价）提示：需用子查询。", "\n\n", "4、先有一个树形数据集合，集合中保存有所有树节点数据，节点类型包括两个属性，即子节点ID（child），父节点ID（parent）", "\n    n个无序的节点组成此集合。请实现一个函数，将集合中的无序节点整理，将数据按树形结构输出，格式不限。"]], "Tag": "程序设计"}
{"Answer": "在以前我做过个程序，就是使用到了将字符转化为一个对象，是通过覆写一个类，然后在action中注册该类，达到model的转换目的。\r\n回想起来，这个好像是struts1的功能了，对于struts2应该没那么麻烦。试试如下方法看看。\r\n\r\nclass User{\r\n public User user;\r\n public void setUser(String str){\r\n    user = dosth();\r\n }\r\n public User getUser(){\r\n   ruturn user;\r\n }\r\n}", "Konwledge_Point": "定义新的类型", "Question": ["struts2利用domain model传参数的问题", ["就是我想发表一篇评论，评论有两个属性，String类型的content和自定义类型的User。", "\n提交表单时我的action能接到一般的属性，如String,int.但是自定义属性User怎么都接受不到。。我看了下错误异常觉得可能是session中取出的值是object类型的，如果是的话，该怎么强转成User类型的呢。", "\n原码如下：", "\n\n", "//这段是我的domain model", "\npublic class Message {", "\n\n", "private int id;\nprivate String content;\nprivate String pubTime;\nprivate User user;\n\n\npublic String getPubTime() {\n    return pubTime;\n}\npublic void setPubTime(String pubTime) {\n    this.pubTime = pubTime;\n}\npublic int getId() {\n    return id;\n}\npublic void setId(int id) {\n    this.id = id;\n}\npublic String getContent() {\n    return content;\n}\npublic void setContent(String content) {\n    this.content = content;\n}\npublic User getUser() {\n    return user;\n}\npublic void setUser(User user) {\n    this.user = user;\n}\n", "\n\n", "}", "\n//////////////////////", "\n\n", "///这段是我的action", "\npublic class MessageAction extends ActionSupport {", "\n\n", "private static final long serialVersionUID = 1L;\nprivate Message msg;\nprivate MessageDao md = new MessageDao();\n\npublic Message getMsg() {\n    return msg;\n}\n\npublic void setMsg(Message msg) {\n    this.msg = msg;\n}\n\npublic String add(){\n    if(md.add(msg) == null){\n        this.addFieldError(\"error\", \"add failed~!\");\n        return ERROR;\n    }\n    return SUCCESS;\n}\n\npublic String delete(){\n    return SUCCESS;\n}\n\npublic String modify(){\n    return SUCCESS;\n}\n", "\n\n", "}", "\n/////////////////////", "\n\n", "/////这是我前台页面的表单", "\n\n\n                    \n     \n                    \n     >     \n     \n\n", "/////////////////", "\n\n", "/////给我报了这么个错误", "\n\n", "2009-10-25 18:36:37 com.opensymphony.xwork2.util.logging.commons.CommonsLogger warn", "\n警告: Error setting expression 'msg.user' with value '[Ljava.lang.String;@f007ad'", "\nognl.MethodFailedException: Method \"setUser\" failed for object com.tls.model.Message@1325aef [java.lang.NoSuchMethodException: com.tls.model.Message.setUser([Ljava.lang.String;)]", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1265)", "\n    at ognl.OgnlRuntime.setMethodValue(OgnlRuntime.java:1454)", "\n    at ognl.ObjectPropertyAccessor.setPossibleProperty(ObjectPropertyAccessor.java:85)", "\n    at ognl.ObjectPropertyAccessor.setProperty(ObjectPropertyAccessor.java:162)", "\n    at com.opensymphony.xwork2.ognl.accessor.ObjectAccessor.setProperty(ObjectAccessor.java:28)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at ognl.ASTProperty.setValueBody(ASTProperty.java:127)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.ASTChain.setValueBody(ASTChain.java:227)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.Ognl.setValue(Ognl.java:737)", "\n    at com.opensymphony.xwork2.ognl.OgnlUtil.setValue(OgnlUtil.java:198)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:161)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:149)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.setParameters(ParametersInterceptor.java:276)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:187)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:94)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:235)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:89)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:130)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:267)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:126)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:138)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:165)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:52)", "\n    at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:488)", "\n    at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)", "\n    at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)", "\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:215)", "\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:188)", "\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)", "\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:172)", "\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)", "\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:117)", "\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:108)", "\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:174)", "\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:875)", "\n    at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:665)", "\n    at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:528)", "\n    at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:81)", "\n    at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:689)", "\n    at java.lang.Thread.run(Unknown Source)", "\nCaused by: java.lang.NoSuchMethodException: com.tls.model.Message.setUser([Ljava.lang.String;)", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1206)", "\n    ... 67 more", "\n/-- Encapsulated exception ------------\\", "\njava.lang.NoSuchMethodException: com.tls.model.Message.setUser([Ljava.lang.String;)", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1206)", "\n    at ognl.OgnlRuntime.setMethodValue(OgnlRuntime.java:1454)", "\n    at ognl.ObjectPropertyAccessor.setPossibleProperty(ObjectPropertyAccessor.java:85)", "\n    at ognl.ObjectPropertyAccessor.setProperty(ObjectPropertyAccessor.java:162)", "\n    at com.opensymphony.xwork2.ognl.accessor.ObjectAccessor.setProperty(ObjectAccessor.java:28)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at ognl.ASTProperty.setValueBody(ASTProperty.java:127)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.ASTChain.setValueBody(ASTChain.java:227)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.Ognl.setValue(Ognl.java:737)", "\n    at com.opensymphony.xwork2.ognl.OgnlUtil.setValue(OgnlUtil.java:198)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:161)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:149)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.setParameters(ParametersInterceptor.java:276)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:187)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:94)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:235)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:89)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:130)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:267)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:126)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:138)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:165)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:52)", "\n    at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:488)", "\n    at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)", "\n    at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)", "\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:215)", "\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:188)", "\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)", "\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:172)", "\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)", "\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:117)", "\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:108)", "\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:174)", "\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:875)", "\n    at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:665)", "\n    at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:528)", "\n    at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:81)", "\n    at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:689)", "\n    at java.lang.Thread.run(Unknown Source)", "\n--------------------------------------/", "\n\n", "请问高手是什么原因啊~！", "\n\n", "[b]问题补充：[/b]", "\n1楼的大哥能说详细点吗？", "\n[b]问题补充：[/b]", "\n回 ：蔡华江", "\n\n", "可是我message类里面不是定义了一个成员变量User了不~", "\n   我的domain model可以自动接收前台传过来的参数啊，那个msg.user不就是我message类里的user这个属性么？", "\n   我现在是要把struts与hibernate相结合，所以想传个user对象过去，请问struts2不能传递对象么？", "\n[b]问题补充：[/b]", "\n那像我这样的情况如果要传个对象过去应该怎么办呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; while(flag &amp;#61; 1)&lt;br /&gt;改为&lt;br /&gt; while(flag &amp;#61;&amp;#61; 1)&lt;br /&gt;主函数也有问题&amp;#xff0c;不要定义linklist的指针&amp;#xff0c;修改如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\ntypedef struct Node     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;结构体&amp;#xff0c;表示出单链表每个节点的内容&amp;#xff0c;用以定义出单链表&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n{\n    int data;           &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义节点的数据域&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n    struct Node *&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义节点的指针域&amp;#xff0c;该指针变量类型为结构体类型 &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}Node,*LinkList;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;结构体别名Node&amp;#xff0c;定义一个指针变量LinkList指向结构体&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;/*初始化单链表*/&lt;/span&gt;\nvoid InitList(LinkList *L)        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;*L是空链表指针变量&amp;#xff0c;代表空链表&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; \n{\n    *L &amp;#61; (Node *)malloc(sizeof(Node));   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;建立头节点&amp;#xff0c;内存空间是节点结构体定义出的内存空间&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n    (*L)-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;           &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;空链表&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n}\n&lt;span class=\"hljs-regexp\"&gt;/*头插法*/&lt;/span&gt;\nvoid HeadInsert(LinkList L)   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;L是带头结点的空链表头指针&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; \n{\n    Node *s;\n    char c;\n    int flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(flag &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        c &amp;#61; getchar();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(c!&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;$&amp;#39;&lt;/span&gt;)\n        {\n            s &amp;#61; (Node *)malloc(sizeof(Node));  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;建立新节点s&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;\n            s-&amp;gt;data &amp;#61; c;\n            s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n            L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n&lt;span class=\"hljs-regexp\"&gt;/*输出链表*/&lt;/span&gt; \nvoid PrintList(LinkList L)\n{\n    LinkList p;\n    p&amp;#61;L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;链表元素如下&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;NULL)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,p-&amp;gt;data);\n        p&amp;#61;p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n}\nint main()\n{\n    LinkList L;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;建立一个空链表&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; \n    InitList(&amp;amp;L);       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;初始化此空链表&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; \n    HeadInsert(L);\n    PrintList(L);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; \n}\n \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于#链表#的问题，如何解决？", ["单链表的创建、初始化、头插法出不来答案，应该是指针乱了。我是初学者，应该是低级错误！", "\n", "#代码如下", "\n", "#include <stdio.h>", "\n", "#include <stdlib.h>", "\ntypedef struct Node     ", "//", "结构体，表示出单链表每个节点的内容，用以定义出单链表", "//", "\n{\n    int data;           ", "//", "定义节点的数据域", "//", "\n    struct Node *", "next", ";        ", "//", "定义节点的指针域，该指针变量类型为结构体类型 ", "//", "\n}Node,*LinkList;        ", "//", "结构体别名Node，定义一个指针变量LinkList指向结构体", "//", "\n", "/*初始化单链表*/", "\nvoid InitList(LinkList *L)        ", "//", "*L是空链表指针变量，代表空链表", "//", " \n{\n    *L = (Node *)malloc(sizeof(Node));   ", "//", "建立头节点，内存空间是节点结构体定义出的内存空间", "//", "\n    (*L)->", "next", " = NULL;           ", "//", "空链表", "//", "\n}\n", "/*头插法*/", "\nvoid HeadInsert(LinkList L)   ", "//", "L是带头结点的空链表头指针", "//", " \n{\n    Node *s;\n    char c;\n    int flag = ", "1", ";\n    ", "while", "(flag = ", "1", ")\n    {\n        c = getchar();\n        ", "if", "(c!=", "'$'", ")\n        {\n            s = (Node *)malloc(sizeof(Node));  ", "//", "建立新节点s", "//", "\n            s->data = c;\n            s->", "next", " = L->", "next", ";\n            L->", "next", " = s;\n        }\n        ", "else", "\n        flag = ", "0", ";\n    }\n}\n", "/*输出链表*/", " \nvoid PrintList(LinkList L)\n{\n    LinkList p;\n    p=L->", "next", ";\n    printf(", "\"链表元素如下：\\n\"", ");\n    ", "while", "(p!=NULL)\n    {\n        printf(", "\"%c\"", ",p->data);\n        p=p->", "next", ";\n        printf(", "\"\\n\"", ");\n    }\n}\nint main()\n{\n    LinkList *L;        ", "//", "建立一个空链表", "//", " \n    InitList(L);       ", "//", "初始化此空链表", "//", " \n    HeadInsert(*L);\n    PrintList(*L);\n    return ", "0", "; \n}\n\n", "\n", " 运行结果及报错内容", "出来是空的。", "\n", "\n", "请问如何正确运行"]], "Tag": "程序设计"}
{"Answer": "在Bird和Dog类的前面加个public修饰符试试", "Konwledge_Point": "定义新的类型", "Question": ["Animal ，Bird ，Dog 老问题，新题目！！不同包子类不能被访问，那这题怎么做？？", ["不同包的子类，没法被缺省包访问到，请问如何实现bird.eat(),bird.wove()方法？？？", "\nJava小白不知道如何处理，请大佬指教！！！", "\n\n", "编写一个抽象类Animal，其成员变量有name，age，weight表示动物名、年龄和重量。方法有showInfo( )、move( )和eat( )，其中后面两个方法是抽象方法；", "\n\n", "\n", "编写一个类Bird继承Animal，实现相应的方法，通过构造方法给name，age，weight分别赋值，showInfo( )打印鸟名、年龄和重量，move( )方法打印鸟的运动方式，eat( )打印鸟喜欢吃的食物；", "\n", "编写一个类Dog继承Animal，实现相应的方法，通过构造方法给name，age，weight分别赋值，showInfo( )打印狗名、年龄和重量，move( )方法打印狗的运动方式，eat( )打印狗喜欢吃的食物；", "\n", "最后编写测试类TestAnimal，用Animal类型的变量，调用Bird和Dog对象的三个方法。", "\n", "要求：将Animal、Bird和Dog三个类定义在包中（包名为你的名字或姓名缩写），而测试类TestAnimal在缺省包中。\n代码如下：\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n // Q690422.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n//\r\n//int _tmain(int argc, _TCHAR* argv[])\r\n//{\r\n//\treturn 0;\r\n//}\r\n\r\n\r\n#include&lt;stdio.h&gt; \r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;malloc.h&gt;\r\n\r\n//¶¨ÒåÈ«¾Ö±äÁ¿\r\nint isEmpty=0;//±êÖ¾£¬ÅÐ¶ÏÁ´±íÊÇ·ñÎª¿Õ \r\n\r\n//£¡£¡!¶¨Òåµ¥Á´±í½á¹¹Ìå£¡£¡£¡ \r\ntypedef struct Node{\r\n\tint NUM;//ÀàÐÍ×ÜÊý \r\n\tchar NAME[100];//¸÷ÀàÐÍÃû³Æ \r\n\tint num; //¸÷ÀàÐÍÏÂµÄ»õÎï×ÜÊý\r\n\tstruct Node*next;\r\n}Node;\r\n\r\n//º¯ÊýÉùÃ÷ \r\nNode*create(int n,Node*L);\r\nNode*input(Node*L);\r\nNode*output(Node*L);\r\nNode*outnum(Node*L);\r\nNode*outname(Node*L);\r\nNode*current(Node*L);\r\nvoid search(Node*L);\r\nvoid print(Node*L);\r\nvoid searchnum(Node*L);\r\nvoid searchname(Node*L);\r\nvoid display(int n,Node*L);\r\n//========ÐÂÔö¼ÓµÄº¯Êý========\r\nNode*append(Node*L); \r\n\r\n//Ö÷º¯Êý\r\nint main()\r\n{\r\n\tint x;\r\n\tint n;//³õ´ÎÊäÈëµÄ´óÐ¡ \r\n\tNode *L;\r\n\tif(!(L=(Node *)malloc(sizeof(Node)))) //·ÖÅä¿Õ¼ä\r\n\t{\r\n\tprintf(\"\\n\");\r\n\texit(1);\r\n\t}\r\n\t\r\n\tprintf(\"»¶Ó­Ê¹ÓÃÎÒµÄ²Ö¿â¹ÜÀíÏµÍ³£¡\\n\"); \r\n\twhile(1)\r\n\t{\r\n\t\t//Ö÷²Ëµ¥¿ªÊ¼ \r\n\t\tprintf(\"==========================\\n\");\r\n\t\tprintf(\"1.ÏÔÊ¾»õÎïÀàÐÍÁÐ±í\\n\");\r\n\t\tprintf(\"2.Ôö¼Ó»õÎïÀàÐÍ\\n\");\r\n\t\tprintf(\"3.É¾³ý»õÎïÀàÐÍ\\n\");\r\n\t\tprintf(\"4.»õÎïÈë¿â\\n\");\r\n\t\tprintf(\"5.»õÎï³ö¿â\\n\");\r\n\t\tprintf(\"6.¿â´æÏÔÊ¾\\n\");\r\n\t\tprintf(\"7.ÍË³ö\\n\");\r\n\t\tprintf(\"==========================\\n\");\r\n\t\t//Ö÷²Ëµ¥½áÊø\r\n\t\tprintf(\"Ñ¡Ôñ1-7:\");\r\n\t\tscanf(\"%d\",&amp;x); \r\n\t\tswitch(x)\r\n\t\t{\r\n\t\t\tcase 1:;break;\r\n\t\t\tcase 2:printf(\"ÇëÊäÈë×î³õµÄ»õÎïÀàÐÍÊýÁ¿:\\n\");\r\n\t\t\t       scanf(\"%d\",&amp;n);\r\n\t\t\t\t   create(n,L);\r\n\t\t\t\t   break;\r\n\t\t\tcase 3:;break;\r\n\t\t\tcase 4:;break;\r\n\t\t\tcase 5:;break;\r\n\t\t\tcase 6:display(n,L);break;\r\n\t\t\tcase 7:;break;\r\n\t\t\tdefault:printf(\"input error!\\nplaese input1-7\");\r\n\t\t}\t\t\r\n\t} \t\t\t\r\n} \r\n\r\n\r\n\r\n\r\n\r\n//º¯Êý\r\n//1.´´½¨Á´±í½Úµã\r\nNode*create(int n,Node*L)\r\n{\r\n\tNode*pTail=L; \r\n\tL-&gt;next=NULL;\r\n\tNode*p;\r\n\r\n\t//ÀûÓÃÎ²²å½¨Á¢µ¥Á´±í \r\n\tint i;\r\n\tfor(i=1;i&lt;=n;i++)\r\n\t{\r\n\t\tp=(Node*)malloc(sizeof(Node));\r\n\t\tif(p==NULL)\r\n\t\t{\r\n\t\t\tprintf(\"ÉêÇëÄÚ´æ¿Õ¼äÊ§°Ü£¡\\n\");\r\n\t\t}\t\r\n\t\tprintf(\"ÇëÊäÈëµÚ%dÖÖÀàÐÍ±àºÅ:\",i);\r\n\t\tscanf(\"%d\",&amp;p-&gt;NUM);\r\n\t\tprintf(\"ÇëÊäÈëµÚ%dÖÖÀàÐÍÃû³Æ:\",i);\r\n\t\tscanf(\"%s\",&amp;p-&gt;NAME);\r\n\t\tprintf(\"ÇëÊäÈëµÚ%dÖÖÀàÐÍ¿â´æ:\",i);\r\n\t\tscanf(\"%d\",&amp;p-&gt;num);\r\n\t\tputchar('\\n');\r\n\t\tpTail-&gt;next=p;\r\n\t\tpTail=p;\r\n\r\n\t}\r\n\tp-&gt;next=NULL;\r\n\treturn L; \r\n} \r\n//2.Ôö¼Ó»õÎïÀàÐÍ\r\n/*Node*append(Node*L)\r\n{\r\n\tNode*ptail=L;\r\n\tL-&gt;next=NULL;\r\n\tNode*p;\r\n\tp=(Node*)malloc(sizeof(Node));\r\n\tif(p==NULL)\r\n\t{\r\n\t\tprintf(\"ÉêÇëÄÚ´æ¿Õ¼äÊ§°Ü£¡\\n\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tprintf(\"ÇëÊäÈëÐÂÔö¼ÓµÄÀàÐÍ±àºÅ£º\\n\");\r\n\t\tscanf(\"%d\",&amp;p-&gt;NUM);\r\n\t\tprintf(\"ÇëÊäÈëµÚ%dÖÖÀàÐÍÃû³Æ:\\n\",i);\r\n\t\tscanf(\"%s\",&amp;p-&gt;NAME);\r\n\t\tprintf(\"ÇëÊäÈëµÚ%dÖÖÀàÐÍ¿â´æ:\\n\",i);\r\n\t\tscanf(\"%d\",&amp;p-&gt;num);\r\n\t\twhile(p-&gt;NUM&gt;)\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\t\tpTail-&gt;next=p;\r\n\t\tpTail=p;\r\n\t}\r\n\tp-&gt;next=NULL;\r\n\t}\t\r\n\r\n\treturn L; \r\n\t\r\n} */\r\n//»õÎïÏÔÊ¾º¯Êý\r\nvoid display(int n,Node*L)\r\n{\r\n\tNode*p;\r\n\tp=(Node*)malloc(sizeof(Node));\r\n\tp=L-&gt;next;\r\n\tint i=0;\r\n\t//for(i=0;i&lt;n;i++)\r\n\t//{\t\r\n\twhile(p!=NULL)\r\n\t{\r\n\t\tprintf(\"the name of %d:\",p-&gt;NUM);\r\n\t\tprintf(\"%s\\n\",p-&gt;NAME);\r\n\t\tprintf(\"the stock of %d:\",p-&gt;NUM);\r\n\t\tprintf(\"%d\\n\",p-&gt;num);\r\n\t\tp=p-&gt;next;\r\n\t//}\r\n\t}\t\r\n}\r\n\r\n\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["c语言链表显示出错 求大佬帮忙", ["选项6出错", "\n#include", "\n#include", "\n#include", "\n#include", "\n\n", "//定义全局变量", "\nint isEmpty=0;//标志，判断链表是否为空 ", "\n\n", "//！！!定义单链表结构体！！！ ", "\ntypedef struct Node{", "\n    int NUM;//类型总数 ", "\n    char NAME[100];//各类型名称 ", "\n    int num; //各类型下的货物总数", "\n    struct Node*next;", "\n}Node;", "\n\n", "//函数声明 ", "\nNode*create(int n,Node*L);", "\nNode*input(Node*L);", "\nNode*output(Node*L);", "\nNode*outnum(Node*L);", "\nNode*outname(Node*L);", "\nNode*current(Node*L);", "\nvoid search(Node*L);", "\nvoid print(Node*L);", "\nvoid searchnum(Node*L);", "\nvoid searchname(Node*L);", "\nvoid display(int n,Node*L);", "\n//========新增加的函数========", "\nNode*append(Node*L); ", "\n\n", "//主函数", "\nvoid main()", "\n{", "\n    int x;", "\n    int n;//初次输入的大小 ", "\n    Node *L;", "\n    if(!(L=(Node *)malloc(sizeof(Node)))) //分配空间", "\n    {", "\n    printf(\"\\n\");", "\n    exit(1);", "\n    }", "\n\n", "printf(\"欢迎使用我的仓库管理系统！\\n\"); \nwhile(1)\n{\n    //主菜单开始 \n    printf(\"==========================\\n\");\n    printf(\"1.显示货物类型列表\\n\");\n    printf(\"2.增加货物类型\\n\");\n    printf(\"3.删除货物类型\\n\");\n    printf(\"4.货物入库\\n\");\n    printf(\"5.货物出库\\n\");\n    printf(\"6.库存显示\\n\");\n    printf(\"7.退出\\n\");\n    printf(\"==========================\\n\");\n    //主菜单结束\n    printf(\"选择1-7:\");\n    scanf(\"%d\",&x); \n    switch(x)\n    {\n        case 1:;break;\n        case 2:printf(\"请输入最初的货物类型数量:\\n\");\n               scanf(\"%d\",&n);\n               create(n,L);\n               break;\n        case 3:;break;\n        case 4:;break;\n        case 5:;break;\n        case 6:display(n,L);break;\n        case 7:;break;\n        default:printf(\"input error!\\nplaese input1-7\");\n    }       \n}           \n", "\n\n", "} ", "\n\n", "//函数", "\n//1.创建链表节点", "\nNode*create(int n,Node*L)", "\n{", "\n    Node*pTail=L; ", "\n    L->next=NULL;", "\n    Node*p;", "\n    p=(Node*)malloc(sizeof(Node));", "\n    if(p==NULL)", "\n    {", "\n        printf(\"申请内存空间失败！\\n\");", "\n    }", "\n    //利用尾插建立单链表 ", "\n    int i;", "\n    for(i=1;i<=n;i++)", "\n    {", "\n        printf(\"请输入第%d种类型编号:\",i);", "\n        scanf(\"%d\",&p->NUM);", "\n        printf(\"请输入第%d种类型名称:\",i);", "\n        scanf(\"%s\",&p->NAME);", "\n        printf(\"请输入第%d种类型库存:\",i);", "\n        scanf(\"%d\",&p->num);", "\n        putchar('\\n');", "\n        pTail->next=p;", "\n        pTail=p;", "\n    }", "\n    p->next=NULL;", "\n    return L; ", "\n} ", "\n//2.增加货物类型", "\n/*Node*append(Node*L)", "\n{", "\n    Node*ptail=L;", "\n    L->next=NULL;", "\n    Node*p;", "\n    p=(Node*)malloc(sizeof(Node));", "\n    if(p==NULL)", "\n    {", "\n        printf(\"申请内存空间失败！\\n\");", "\n    }", "\n    else", "\n    {", "\n        printf(\"请输入新增加的类型编号：\\n\");", "\n        scanf(\"%d\",&p->NUM);", "\n        printf(\"请输入第%d种类型名称:\\n\",i);", "\n        scanf(\"%s\",&p->NAME);", "\n        printf(\"请输入第%d种类型库存:\\n\",i);", "\n        scanf(\"%d\",&p->num);", "\n        while(p->NUM>)", "\n        {", "\n\n", "    }\n    pTail->next=p;\n    pTail=p;\n}\np->next=NULL;\n}   \n\nreturn L; \n", "\n\n", "} ", "/", "\n//货物显示函数", "\nvoid display(int n,Node*L)", "\n{", "\n    Node*p;", "\n    p=(Node", ")malloc(sizeof(Node));", "\n    p=L->next;", "\n    int i=0;", "\n    //for(i=0;i\n    //{ ", "\n    while(p!=NULL)", "\n    {", "\n        printf(\"第%d种类型名称:\",&p->NUM);", "\n        printf(\"%s\\n\",&p->NAME);", "\n        printf(\"第%d种类型库存:\",&p->NUM);", "\n        printf(\"%d\\n\",&p->num);", "\n        p=p->next;", "\n    //}", "\n    }", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;为什么你输入len后就不能输入&amp;#xff1a;你输入val是没问题的&amp;#xff0c;主要是pNew-&amp;gt;data &amp;#61; val&amp;#xff0c;因为你pNew没有分配空间。&lt;/li&gt;&lt;li&gt;为什么你的pNew没有分配空间&amp;#xff1a;你一开始pNew &amp;#61; Ppointer-&amp;gt;pNext&amp;#xff0c;只有Ppointer分配了&amp;#xff0c;Ppointer-&amp;gt;pNext并没有分配&amp;#xff0c;你在循环中也没有后面输入的存放的结点分配。&lt;/li&gt;&lt;li&gt;怎么做&amp;#xff1a;先分配再指向&amp;#xff0c;用pre指针指向每次输入前一个结点&amp;#xff0c;pNew每次分配完空间再让pre-&amp;gt;pNext&amp;#61;pNew。&lt;/li&gt;&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;    PNode &lt;span class=\"hljs-attr\"&gt;pre&lt;/span&gt; &amp;#61; Ppointer;\n    for (&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个元素:&amp;#34;&lt;/span&gt;, i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,val);\n        &lt;span class=\"hljs-attr\"&gt;pNew&lt;/span&gt; &amp;#61; (PNode)malloc(sizeof(Node));\n        pNew-&amp;gt;&lt;span class=\"hljs-attr\"&gt;data&lt;/span&gt; &amp;#61; val;\n        pre-&amp;gt;&lt;span class=\"hljs-attr\"&gt;pNext&lt;/span&gt; &amp;#61; pNew;\n        &lt;span class=\"hljs-attr\"&gt;pre&lt;/span&gt; &amp;#61; pNew;\n    }\n    pre-&amp;gt;&lt;span class=\"hljs-attr\"&gt;pNext&lt;/span&gt; &amp;#61; NULL;\n    return Ppointer;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["创建一个链表，实现输入，输出。但是没法输入。在devc++上运行的语法没问题", ["问题遇到的现象和发生背景", "\n", "创建一个链表，实现输入，输出。", "但是最后只能输入一个len；程序就结束了。", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include<stdio.h>", "#include<malloc.h>", "#include<stdlib.h>", "/*", "2022年3月22日", "功能：创建一个链表，实现输入，输出", "目的：学习链表的制作 ", "\n", "*/", "typedef struct node//如果数据类型增加一个新的名字，请使用typedef", "{", "    int data;//数据域", "    struct node * pNext;//指针域", "} *PNode, Node;", "\n", "PNode creat_list (void);", "void traverse_list(PNode Ppointer);", "\n", "int  main (void)", "{", "    PNode Ppointer = NULL;", "\n", "Ppointer", " ", "=", " creat_list ()", ";", "\ntraverse_list( Ppointer)", ";//传递参数式不需要再次定义数据类型，传递参数时，形参需要定义数据类型 ", "\n\n\nreturn ", "0", ";", "\n", "\n", "}", "\n", "PNode creat_list(void)", "{", "    int len;", "    int i;", "    int val;", "    PNode pNew;", "\n", "PNode Ppointer = (PNode)malloc(sizeof(Node));", "//", "创建头指针 和头节点 \n\npNew = Ppointer->pNext ;\n\n", "//", "判断头指针和头节点是否创建成功。健壮性！ \n", "if", "(Ppointer != NULL)\n  printf(", "\"创建成功!\\n\"", ");\n", "else", "\n{\n    printf(", "\"创建失败，程序终止!\\n\"", ");\n    ", "exit", "(-", "1", ");\n}\n\n", "//", "输入链表的长度!\nprintf(", "\"请输入你需要的链表的长度：len=\"", ");\nscanf(", "\"%d\"", ",len);\n\n", "//", "依次输入你存放在链表中的数据\n/*\n这里的", "for", "循环应该怎么写？\n  ", "1", ".把Ppointer->pNext存储在pNew中\n  ", "2", "把pNew->pNext在存储在pNew中。\n   \n*/\n", "for", "(i = ", "0", "; i < len; i++)\n{\n    printf(", "\"请输入第%d个元素:\"", ",i+", "1", ");\n    scanf(", "\"%d\"", ",val);\n    \n    pNew->data = val;\n    pNew = pNew->pNext ;\n    pNew = NULL;\n    \n    return Ppointer;\n    \n    \n} \n", "\n", "}", "\n", "void traverse_list(PNode PP)", "{", "    PNode pNew;", "\n", "pNew", " = PP->", "pNext;\n\n", "while", "(pNew != NULL)\n{\n    ", "printf", "(\"%d  \",pNew->", "data", ");\n    ", "pNew", " = pNew->", "pNext ; \n            \n}\n", "\n", "}", "\n", "运行结果及报错内容", "\n", "创建成功!", "请输入你需要的链表的长度：len=3（3是输入值）", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "实现输入和输出"]], "Tag": "程序设计"}
{"Answer": "先看下 《SOCKET 网络编程》吧！\r\n把套接字 地址 监听 绑定 阻塞  这些都搞明白了 你就清楚了!", "Konwledge_Point": "定义新的类型", "Question": ["为什么我编的抓包程序抓的TCP包源地址都是本机地址啊，下面是源码，新手求大神指点！！", ["#include ", "\n#include ", "\n#include ", "\n\n", "using namespace std;", "\n\n", "#define SIO_RCVALL _WSAIOW(IOC_VENDOR, 1)", "\n#define MAXLEN 65535", "\n//定义IP报头", "\ntypedef struct _iph", "\n{", "\n    unsigned char ver_len;", "\n    unsigned char ser;", "\n    unsigned short datalen;", "\n    unsigned short ident;", "\n    unsigned short flag;", "\n    unsigned char ttl;", "\n    unsigned char proto;", "\n    unsigned short checksum;", "\n    unsigned int sourceIP;", "\n    unsigned int destIP;", "\n}iph;", "\n\n", "//定义TCP报头", "\ntypedef struct _tcph", "\n{", "\n    unsigned short sourceport;", "\n    unsigned short destport;", "\n    unsigned int linum;", "\n    unsigned int trnum;", "\n    unsigned char flag;", "\n    unsigned char baoliu;", "\n    unsigned char ident;", "\n    unsigned short win;", "\n    unsigned short checksum;", "\n    unsigned short jinji;", "\n}tcph;", "\n\n", "//定义ICMP报头", "\ntypedef struct _icmphdr //定义 ICMP 报头(回送与或回送响应) ", "\n{", "\n    unsigned char i_type;//8 位类型 ", "\n    unsigned char i_code; //8 位代码", "\n    unsigned short i_cksum; //16 位校验和", "\n    unsigned short i_id; //识别号（一般用进程号作为识别号）", "\n    unsigned short i_seq; //报文序列号", "\n    unsigned int timestamp;//时间戳", "\n}icmph;", "\n\n", "void main()", "\n{", "\n    //加载套接字库", "\n    WSAData data;", "\n    if(::WSAStartup(MAKEWORD(2,0),&data))", "\n    {", "\n        cout<<\"winsock库加载失败！\"<<endl;", "\n        return;", "\n    }", "\n\n", "//创建原始套接字\nSOCKET sock;\nsockaddr_in addr;\nsock=::socket(AF_INET,SOCK_RAW,IPPROTO_IP);\nif(INVALID_SOCKET==sock)\n{\n    cout<<\"sock初始化失败！\"<<endl;\n    return;\n}\n\n//获得本机一个IP地址\nchar name[30]=\"\";\n::gethostname(name,30);\nhostent *h=::gethostbyname(name);\n::memcpy(&addr.sin_addr.S_un.S_addr,h->h_addr_list[h->h_length-1],h->h_length);\naddr.sin_family=AF_INET;\naddr.sin_port=htons(0);\n\n//绑定地址\nif(SOCKET_ERROR==::bind(sock,(SOCKADDR*)&addr,sizeof(addr)))\n{\n    cout<<\"sock绑定失败！！\"<<endl;\n    return;\n}\n\n//设置网卡为混杂模式\nu_long mk=1;\nif(SOCKET_ERROR==::ioctlsocket(sock,SIO_RCVALL,&mk))\n{\n    cout<<\"网卡的混杂模式设置失败！错误号：\"<<::WSAGetLastError()<<endl;\n    return;\n}\n\ncout<<\"协议   源地址           目的地址    数据长度    TTL\"<<endl;\n\nchar buf[MAXLEN]=\"\";\niph *iphead;\ntcph *tcphead=(tcph*)(buf+sizeof(iph));\nicmph *icmphead=(icmph*)(buf+sizeof(iph));\nint i=0;\nsockaddr_in add;\n\n//接收IP包\nwhile(i<100)\n{\n    if(SOCKET_ERROR==::recv(sock,buf,MAXLEN,0))\n    {\n        cout<<\"接收发生错误！！\"<<endl;\n        return;\n    }\n    iphead=(iph*)buf;\n    if(iphead->proto==6)                    //TCP\n    {\n        add.sin_addr.S_un.S_addr=iphead->sourceIP;\n        cout<<\"TCP  \"<<inet_ntoa(add.sin_addr)<<':'<<ntohs(tcphead->sourceport)<<\"  \";\n        add.sin_addr.S_un.S_addr=iphead->destIP;\n        cout<<inet_ntoa(add.sin_addr)<<':'<<ntohs(tcphead->destport)<<\" \"<<ntohs(iphead->datalen)<<\"        \"<<(int)iphead->ttl<<endl;\n    }\n    if(iphead->proto==1)                    //ICMP\n    {\n        add.sin_addr.S_un.S_addr=iphead->sourceIP;\n        cout<<\"ICMP  \"<<inet_ntoa(add.sin_addr)<<\"   \";\n        add.sin_addr.S_un.S_addr=iphead->destIP;\n        cout<<inet_ntoa(add.sin_addr)<<\"  \";\n        char *p=buf+sizeof(iph)+sizeof(icmph)-4;\n        cout<<p<<endl;\n    }\n    memset(buf,0,MAXLEN);\n}\n", "\n\n", "}", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if(strlen(ch)&amp;gt;m)&lt;br /&gt;你打印这两个数看看呀&amp;#xff0c;m到底是几&lt;br /&gt;根据题目描述&amp;#xff0c;repeat应该是m才对呀&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["他直接跳过了我的函数是为什么", ["输入一个正整数 repeat (0<repeat<10)，做 repeat 次下列运算：", "\n", "输入一个字符串 t 和一个正整数 m，将字符串 t 中从第 m 个字符开始的全部字符复制到字符串 s 中，再输出字符串 s。", "\n", "要求定义并调用函数 strmcpy(s,t,m), 它的功能是将字符串 t 中从第 m 个字符开始的全部字符复制到字符串 s 中，函数形参s和t的类型是字符指针，形参m的类型是int，函数类型是void。", "\n", "输入输出示例：括号内为说明，无需输入输出", "\n", "输入样例:", "3              (repeat=3）", "happy new year", "7", "happy", "1", "new", "4", "输出样例:", "new year        (从\"happy new year\"第7个字符开始组成的新字符串为\"new year\"）", "happy           (从\"happy\"第1个字符开始组成的新字符串为\"happy\"）", "error input     (\"new\"的长度小于4）", "\n", "void", " ", "strmcpy", "(", "char", " *s,", "char", " *t,", "int", " m)", "\n", "{\n    s=t+m", "-1", ";\n}\n", "#", "include", "<string.h>", "\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " m,i,repeat;\n    ", "scanf", "(", "\"%d\"", ",&repeat);\n    ", "getchar", "();\n    ", "for", "( i=", "0", ";i<repeat;i++)\n    {\n    ", "char", " ch[", "1000", "]={", "0", "},th;\n    ", "gets", "(ch);\n    ", "scanf", "(", "\"%d\"", ",&m);\n    ", "getchar", "();\n    ", "char", " *s=&th,*t=ch;\n    ", "if", "(", "strlen", "(ch)>m)\n    {\n         ", "strmcpy", "(s,t,m);\n         ", "printf", "(", "\"%s\\n\"", ",s);\n    }\n    ", "else", "\n         ", "printf", "(", "\"error input\\n\"", ");\n    }\n    ", "return", " ", "0", ";\n}\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、为什么work运行结果都是3&amp;#xff1f;因为Item里面的name加了static&amp;#xff0c;变成了类变量&amp;#xff08;全局、静态变量&amp;#xff09;&amp;#xff0c;就是下面new music了两次&amp;#xff0c;每次改的都是同一个name&amp;#xff0c;所以第二次的3把第一次的1也改成3了&amp;#xff0c;所以两次输出都是3&lt;/p&gt;\n\n&lt;p&gt;2、为什么我的子类music不能定义父类同名函数print()&amp;#xff1f;父类加了static变成静态的&amp;#xff0c;子类再定义同名方法&amp;#xff0c;就会被认为是在重写父类方法&amp;#xff08;override&amp;#xff09;&amp;#xff0c;子类的方法也必须和父类一样加static静态&amp;#xff1b;同理&amp;#xff0c;父类去掉static&amp;#xff0c;子类也不能加static&amp;#xff0c;就是要不都加&amp;#xff0c;要不都不加。&lt;/p&gt;\n\n&lt;p&gt;这里面涉及了继承&amp;#xff0c;类变量&amp;#xff0c;类方法&amp;#xff0c;实例对象&amp;#xff0c;对象方法等&amp;#xff0c;建议把每个都吃透&amp;#xff0c;不然混在一起不好理解&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["萌新问几个关于java继承的问题", ["\n", "Item.java\npackage Item;\n\npublic class Item {\n    static String  name;\n    static String author;\n    static int time;\n    static int money;\n    static boolean ifget;\n    \n\tpublic Item(String name, String author, int time, int money, boolean ifget) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.author = author;\n\t\tthis.time = time;\n\t\tthis.money = money;\n\t\tthis.ifget = ifget;\n\t}\n\n   \n\tpublic static  void print() {\n\t\t// TODO 自动生成的方法存根\n\t\tSystem.out.println(name);\n\t}\n       \n       \n}\n\n\nmusic.java\npackage Item;\n\npublic class music extends Item {\n\n\tpublic music(String name, String author, int time, int money, boolean ifget) {\n\t\tsuper(name, author, time, money, ifget);\n\t\t// TODO 自动生成的构造函数存根\n\t}\n\t\n\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n    \n\t}\n\n}\n\nwork.java\npackage Item;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class work {\n     \n\t private  ArrayList<Item> listitem = new ArrayList<Item>();\n\t \n\t public void add(Item item) {\n\t\t listitem.add(item);\n\t }\n\t \n\tpublic void list() {\n\t\tfor(Item item : listitem) {\n\t\t\tItem.print();\n\t\t}\n\t\t\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n    work a = new work();\n    a.add(new music(\"1\",\"1\",1,1,true));\n    a.add(new music(\"3\",\"1\",1,1,true));\n    a.list();\n\t}\n}\n", "\n\n", "最终work运行结果都是3", "\n\n", "\n\n", "请问为什么啊？", "\n\n", "还有，为什么我的子类music不能定义父类同名函数print(),但把父类print（）函数的static去掉就可以，但这样的话work会报错：", "\n\n", "不能对类型 Item 中的非静态方法 print（）进行静态引用"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;AddOne函数有几个错误&amp;#xff1a;&lt;br /&gt;&amp;#xff08;1&amp;#xff09;DA没有分配空间&amp;#xff0c;struct Student *DA;这一句改成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;* DA &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student));\nDA-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&amp;#xff08;2&amp;#xff09;scanf(&amp;#34;%d&amp;#34;,DA-&amp;gt;C_Language);这里&amp;#xff0c;DA-&amp;gt;C_Language前面需要&amp;amp;&lt;br /&gt;下面几个读取成绩的代码都需要加&amp;amp;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nscanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-symbol\"&gt;&amp;amp;DA-&amp;gt;C_Language&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;(3)DA这个变量你声明了2遍&amp;#xff0c;重复声明了&amp;#xff0c;第二个DA换个名字&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/929386059876199.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于#c语言#的问题：我想给此代码增添单科成绩录入的功能，于是增添了新的函数voidAddOne,但在运行的时候只能输入姓名，请帮我修改这部分函数", ["我想给此代码增添单科成绩录入的功能，于是增添了新的函数void AddOne,但在运行的时候只能输入姓名，之后会退出程序，请帮我修改这部分函数，使之可以正常运行；请帮我添加一个功能：班级内单科成绩排名", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<windows.h>", "//包含了控制台窗口操作相关的函数", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "define", " LEN sizeof(struct Student)", "// 定义结构体类型所占的内存大小", "\n", "struct", " ", "Student", "// 定义结构体类型", "\n{\n    ", "char", " name[", "10", "];        \n    ", "char", " number[", "20", "];                     \n    ", "int", " C_Language;            \n    ", "int", " Math;                \n    ", "int", " English;    \n    ", "struct", " ", "Student", "* next;     ", "// 存储下一个学生的地址", "\n};\n", "struct", " ", "Student", "* head = ", "NULL", ";", "// 定义头节点指针", "\n", "struct", " ", "Student", "* end = ", "NULL", ";", "// 定义尾节点指针", "\n ", "void", " ", "Menu", "()", "// 定义菜单函数", "\n ", "{\n     ", "void", " ", "Menu", "()", ";", "// 声明菜单函数", "\n    ", "void", " ", "Add", "()", ";\n    ", "void", " ", "View", "()", ";\n    ", "void", " ", "Delete", "()", ";\n    ", "void", " ", "Repair", "()", ";\n    ", "void", " ", "ViewAll", "()", ";\n    ", "void", " ", "AddOne", "()", ";\n    ", "system", "(", "\"cls\"", "); ", "// 清空控制台窗口内容", "\n    ", "printf", "(", "\"1.学生信息录入\\n\"", ");\n    ", "printf", "(", "\"2.学生单个成绩查询\\n\"", ");\n    ", "printf", "(", "\"3.查询全部学生成绩\\n\"", ");\n    ", "printf", "(", "\"4.修改学生信息\\n\"", ");\n    ", "printf", "(", "\"5.删除学生信息\\n\"", ");\n    ", "printf", "(", "\"6.学生单科成绩录入\\n\"", "); \n    ", "printf", "(", "\"7.退出系统\\n\"", ");\n\n    ", "int", " choice;\n    ", "printf", "(", "\"请选择要使用的功能：\\n\"", ");\n    loop:\n    ", "scanf", "(", "\"%d\"", ",&choice);\n    ", "switch", " (choice)\n    {\n        ", "case", " ", "1", ":\n            ", "Add", "();\n            ", "Menu", "();\n        ", "case", " ", "2", ":\n            ", "View", "();\n            ", "Menu", "();\n        ", "case", " ", "3", ":\n            ", "ViewAll", "();\n            ", "Menu", "();\n        ", "case", " ", "4", ":\n            ", "Repair", "();\n            ", "Menu", "();\n        ", "case", " ", "5", ":\n            ", "Delete", "();\n            ", "Menu", "();\n        ", "case", " ", "6", ":\n            ", "AddOne", "();\n            ", "Menu", "();\n        ", "case", " ", "7", ":\n            ", "exit", "(", "0", ");\n            ", "default", ":\n                ", "printf", "(", "\"输入有误，请重新选择：\"", ");\n                ", "break", ";\n    }\n} \n \n", "void", " ", "Add", "()", "\n", "{\n    ", "system", "(", "\"cls\"", ");\n    ", "int", " count;\n    ", "printf", "(", "\"请输入要录入信息的个数：\"", ");\n    ", "scanf", "(", "\"%d\"", ",&count);\n    ", "struct", " ", "Student", " *s1,*s2,*temp;\n    s1=s2=(", "struct", " Student*)", "malloc", "(LEN);\n    ", "if", "(head==", "NULL", ")\n    {\n        head = s1;\n    }\n    ", "else", "\n    {\n        end->next = s1 ;\n    }\n    ", "int", " i = ", "1", ";    \n    ", "while", "(count>", "0", ")\n    {\n        ", "printf", "(", "\"请输入第%d位学生信息：\\n\"", ",i++);\n        ", "printf", "(", "\"姓名：\\n\"", ");\n        ", "scanf", "(", "\"%s\"", ",&s1->name);\n        ", "printf", "(", "\"学号：\\n\"", ");\n        ", "scanf", "(", "\"%s\"", ",&s1->number);\n        ", "printf", "(", "\"C语言成绩：\\n\"", ");\n        ", "scanf", "(", "\"%d\"", ",&s1->C_Language);\n        ", "printf", "(", "\"数学成绩:\\n\"", ");\n        ", "scanf", "(", "\"%d\"", ",&s1->Math);\n        ", "printf", "(", "\"英语成绩:\\n\"", ");\n        ", "scanf", "(", "\"%d\"", ",&s1->English);\n        count--;\n        s2->next=s1;\n        s2=s1;\n        s1=(", "struct", " Student*)", "malloc", "(LEN);\n        ", "printf", "(", "\"添加成功！\\n\"", ");\n        ", "system", "(", "\"pause\"", ");\n        ", "system", "(", "\"cls\"", ");\n    }\n    s2->next= ", "NULL", ";\n    end = s2;\n    ", "printf", "(", "\"全部添加成功！\\n\"", ");\n    ", "system", "(", "\"pause\"", ");\n}\n", "void", " ", "View", "()", "\n", "{\n    ", "system", "(", "\"cls\"", ");\n    ", "struct", " ", "Student", " *VS;\n    ", "printf", "(", "\"输入要查询信息的学生学号：\\n\"", ");\n    ", "char", " num[", "10", "];\n    ", "int", " flag=", "1", ";\n    ", "scanf", "(", "\"%s\"", ",&num);\n    ", "for", "(VS=head;VS!=", "NULL", ";)\n    {\n        ", "if", "(", "strcmp", "(VS->number,num)==", "0", ")\n        {\n            ", "printf", "(", "\"成功找到！\\n\"", ");\n            ", "printf", "(", "\"姓名：%s\\t学号：%s\\t\\n\"", ",VS->number,VS->name);\n            ", "printf", "(", "\"C语言：%d\\t数学:%d\\t英语：%d\"", ",VS->C_Language,VS->Math,VS->English);\n            flag=", "0", ";\n            ", "break", ";\n        }\n        VS=VS->next;\n    }\n    ", "if", "(flag)\n    {\n        ", "printf", "(", "\"不好意思，未找到！\\n\"", ");\n    }\n    ", "system", "(", "\"pause\"", ");\n}\n", "void", " ", "ViewAll", "()", "\n", "{\n    ", "system", "(", "\"cls\"", ");\n    ", "struct", " ", "Student", " *VA;\n    ", "if", "(head!=", "NULL", ")\n    {\n        ", "printf", "(", "\"所有学生成绩如下：\\n\"", ");\n        ", "for", "(VA=head;VA!=", "NULL", ";)\n        {\n            ", "printf", "(", "\"姓名：%s\\t学号：%s\\t\\n\"", ",VA->name,VA->number);\n            ", "printf", "(", "\"C语言：%d\\t数学:%d\\t英语：%d\\n\"", ",VA->C_Language,VA->Math,VA->English);\n            VA=VA->next; \n        }\n        ", "printf", "(", "\"所有不及格科目超过两科的学生名单如下:\\n\"", ");\n        ", "for", "(VA=head;VA!=", "NULL", ";)\n        {\n             ", "int", " lostNum = ", "0", ";\n            ", "if", "(VA->C_Language < ", "60", ")\n            {\n                lostNum++;\n            }\n            ", "if", "(VA->Math< ", "60", ")\n            {\n                lostNum++;\n            }\n            ", "if", "(VA->English< ", "60", ")\n            {\n                lostNum++;\n            }\n            ", "if", "(lostNum > ", "1", ")\n            {\n                ", "printf", "(", "\"姓名：%s\\t\\n\"", ",VA->name);\n            }\n             VA = VA->next;\n        }\n\n    }\n    ", "else", "\n    {\n        ", "printf", "(", "\"该系统中还未录入信息\"", ");\n    }\n    ", "system", "(", "\"pause\"", ");\n}\n", "void", " ", "Repair", "()", "\n", "{\n    ", "system", "(", "\"cls\"", ");\n    ", "struct", " ", "Student", " *RS;\n    ", "char", " num[", "10", "];\n    ", "int", " flag = ", "1", ";\n    ", "printf", "(", "\"输入要修改成绩学生的学号：\\n\"", ");\n    ", "scanf", "(", "\"%s\"", ",num);\n    ", "for", "(RS=head;RS!=", "NULL", ";)\n    {\n        ", "if", "(", "strcmp", "(RS->number,num)==", "0", ")\n        {\n            ", "printf", "(", "\"成功找到该学生\"", ");\n            ", "printf", "(", "\"姓名：%s\\t学号：%s\\t\\n\"", ",RS->number,RS->name);\n            ", "printf", "(", "\"C语言：%d\\t数学:%d\\t英语：%d\\n\"", ",RS->C_Language,RS->Math,RS->English);\n            flag = ", "0", ";\n            ", "printf", "(", "\"姓名：\\n\"", ");\n            ", "scanf", "(", "\"%s\"", ",&RS->name);\n            ", "printf", "(", "\"学号：\\n\"", ");\n            ", "scanf", "(", "\"%s\"", ",&RS->number);\n            ", "printf", "(", "\"C语言成绩：\\n\"", ");\n            ", "scanf", "(", "\"%d\"", ",&RS->C_Language);\n            ", "printf", "(", "\"数学成绩:\\n\"", ");\n            ", "scanf", "(", "\"%d\"", ",&RS->Math);\n            ", "printf", "(", "\"英语成绩:\\n\"", ");\n            ", "scanf", "(", "\"%d\"", ",&RS->English);\n            ", "printf", "(", "\"修改成功\"", ");\n            ", "system", "(", "\"pause\"", ");\n        }\n        RS=RS->next;\n    }\n    ", "if", "(flag)\n    {\n        ", "printf", "(", "\"输入信息有误，未查询到\"", ");\n        ", "system", "(", "\"pause\"", ");\n    }\n}\n", "void", " ", "Delete", "()", "\n", "{\n    ", "system", "(", "\"cls\"", ");\n    ", "int", " flag =", "1", ";\n    ", "while", "(flag)\n    {\n        ", "printf", "(", "\"请输入要删除的学生学号：\"", ");\n        ", "char", " num[", "10", "];\n        ", "scanf", "(", "\"%s\"", ",&num);\n        ", "struct", " ", "Student", " * DS,*temp;\n        ", "for", "(DS=head;DS!=", "NULL", ";)\n        {\n            ", "if", "(", "strcmp", "(DS->number,num)==", "0", ")\n            {\n                ", "if", "(DS==head)\n                {\n                    head = DS->next;\n                    flag = ", "0", ";\n                    ", "printf", "(", "\"删除成功！\\n\"", ");\n                    ", "system", "(", "\"pause\"", ");\n                }\n                ", "else", "\n                {\n                    flag = ", "0", ";\n                    ", "printf", "(", "\"删除成功！\\n\"", ");\n                    temp->next= DS->next;\n                    ", "free", "(DS);\n                    ", "system", "(", "\"pause\"", ");\n                }\n                ", "break", ";\n            }\n            temp = DS;\n            DS=DS->next;\n        }\n        ", "if", "(flag)\n        {\n            ", "printf", "(", "\"未找到该学生学号！\\n\"", ");\n            ", "system", "(", "\"pause\"", ");\n        } \n    }\n}\n\n", "void", " ", "AddOne", "()", "\n", "{\n    ", "system", "(", "\"cls\"", ");\n    ", "struct", " ", "Student", " *DA;\n    ", "int", " flag = ", "1", ";\n    ", "while", "(flag)\n    {\n        ", "printf", "(", "\"请输入姓名：\\n\"", ");\n        ", "scanf", "(", "\"%s\"", ",DA->name);\n        ", "printf", "(", "\"请输入学号：\\n\"", ");\n        ", "scanf", "(", "\"%s\"", ",DA->number);\n        ", "printf", "(", "\"1.录入C语言成绩\\n\"", ");\n        ", "printf", "(", "\"2.录入数学成绩\\n\"", ");\n        ", "printf", "(", "\"3.录入英语成绩\\n\"", ");\n        ", "int", " select;\n        ", "switch", "(select)\n        {\n            ", "case", " ", "1", ":\n                ", "printf", "(", "\"请输入C语言成绩\\n\"", ");\n                ", "scanf", "(", "\"%d\"", ",DA->C_Language);\n                ", "break", ";\n            ", "case", " ", "2", ":\n                ", "printf", "(", "\"请输入数学成绩\\n\"", ");\n                ", "scanf", "(", "\"%d\"", ",DA->Math);\n                ", "break", ";\n            ", "case", " ", "3", ":\n                ", "printf", "(", "\"请输入英语成绩\\n\"", ");\n                ", "scanf", "(", "\"%d\"", ",DA->English);\n                 ", "break", ";\n                ", "default", ":\n                ", "printf", "(", "\"输入错误，请重新输入\\n\"", ");\n                ", "break", ";\n        }\n        ", "printf", "(", "\"录入成功\\n\"", ");\n        ", "struct", " ", "Student", " * DA,*temp;\n        ", "for", "(DA=head;DA!=", "NULL", ";)\n        {\n            ", "if", "(DA==head)\n            {\n                head = DA->next;\n                flag = ", "0", ";\n                ", "system", "(", "\"pause\"", ");\n            }\n            ", "else", "\n            {\n                flag = ", "0", ";\n                temp->next= DA->next;\n                ", "free", "(DA);\n                ", "system", "(", "\"pause\"", ");\n            }\n            ", "break", ";\n        }\n        temp = DA;\n        DA=DA->next;\n    }\n\n\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "void", " ", "Menu", "()", ";\n    ", "void", " ", "Add", "()", ";\n    ", "void", " ", "View", "()", ";\n    ", "void", " ", "Delete", "()", ";\n    ", "void", " ", "Repair", "()", ";\n    ", "void", " ", "ViewAll", "()", ";\n    ", "void", " ", "AddOne", "()", ";\n    ", "Menu", "();\n    \n}\n\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; str3&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;120&lt;/span&gt;]&lt;/span&gt;;\n\nvoid merge&lt;span class=\"hljs-constructor\"&gt;String(&lt;span class=\"hljs-params\"&gt;char&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;[],&lt;span class=\"hljs-params\"&gt;char&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;[])&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;b&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;!&amp;#61;&lt;span class=\"hljs-character\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;j&amp;#43;&amp;#43;){\n    str3&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; b&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;;\n}\n\nmerge&lt;span class=\"hljs-constructor\"&gt;String(&lt;span class=\"hljs-params\"&gt;str1&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;str2&lt;/span&gt;)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["编写程序将2个字符串连接起来（不使用strcat函数）并输出。", ["#include<stdio.h>", "char str1[80],str2[40];", "/", "在此处定义一个char类型的数组str3，大小为120,用来储存str1和str2连接后的字符串", "/", "void mergeString()//在括号内填入函数的参数，字符数组a和字符数组b", "{", "    int i=0,j=0;", "    for(i=0;a[i]!='\\0';i++)", "    {", "        str3[i]=a[i];", "    }", "    /", "在此处撰写一个循环，将数组b的每个值一次赋值给新数组str3,注意str3是从i开始", "/", "    str3[i]='\\0';", "    return;", "}", "int main()", "{", "\n", "  int i=0,j=0;", "  printf(\"输入字符串1：\");", "  scanf(\"%s\",str1);", "  printf(\"输入字符串2：\");", "  scanf(\"%s\",str2);", "  //在此处调用函数并传入参数", "  printf(\"\\n新的字符串是：%s\\n\",str3);", "  return 0;//主函数返回值为0", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#xff1f;函数的声明方式不是&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;返回类型 函数名&lt;span class=\"hljs-comment\"&gt;(数据类型 参数名,数据类型 参数名……)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;吗&amp;#xff1f;你的参数类型去哪了&amp;#xff1f;我建议你先把语法学好&amp;#xff0c;然后去学算法和数据结构&amp;#xff0c;直接学数据结构不太好的&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言数据结构建两个表取交集放到新表中", ["\n#", "include", "<stdio.h>\n#", "include", " <malloc.h>\n#define LISTSIZE ", "20", "\n\ntypedef ", "struct", " {\n    ", "int", " * ", "elem;\n    ", "int", " length;\n    ", "int", " ListSize;\n}SqList;\n\nvoid ", "GetElem(L, ", "i", ", &", "e", ")", ";\nvoid ", "LocateElem()", ";\nvoid ", "ListInsert()", ";\n\n", "int", " main", "()", " {\n    SqList L1,L2,L3;\n    ", "int", " i;\n    ", "L1", ".", "elem = (", "int", "*)malloc(LISTSIZE", " * ", "sizeof(", "int", "));\n    L1.ListSize = LISTSIZE;\n    printf(", "\"输入表L1的数据个数以及数据：\\n\"", ");\n    scanf(", "\"%d\"", ",&", "L1", ".", "length);\n    ", "for", " (i = ", "0", "; i < ", "L1", ".", "length; i++) {\n        scanf(", "\"%d\"", ",&", "L1", ".", "elem", "[", "i", "]", ");\n    }\n    printf(", "\"L1的数据是：\\n\"", ");\n    ", "for", " (i = ", "0", "; i < ", "L1", ".", "length; i++) {\n        printf(", "\"%d.\"", ",", "L1", ".", "elem", "[", "i", "]", ");\n    }\n\n    printf(", "\"\\n\\n\"", ");\n\n    ", "L2", ".", "elem = (", "int", "*)malloc(LISTSIZE", " * ", "sizeof(", "int", "));\n    L2.ListSize = LISTSIZE;\n    printf(", "\"输入表L2的数据个数以及数据：\\n\"", ");\n    scanf(", "\"%d\"", ", &", "L1", ".", "length);\n    ", "for", " (i = ", "0", "; i < ", "L1", ".", "length; i++) {\n        scanf(", "\"%d\"", ", &", "L1", ".", "elem", "[", "i", "]", ");\n    }\n    printf(", "\"L2的数据是：\\n\"", ");\n    ", "for", " (i = ", "0", "; i < ", "L1", ".", "length; i++) {\n        printf(", "\"%d.\"", ", ", "L1", ".", "elem", "[", "i", "]", ");\n    }\n\n    ", "L3", ".", "elem = (", "int", "*)malloc(LISTSIZE", " * ", "sizeof(", "int", ")", " * ", "2", ");\n    L3.ListSize = LISTSIZE", " * ", "2", ";\n    ", "L3", ".", "length = ", "L1", ".", "length + ", "L2", ".", "length;\n\n    ", "for", " (i = ", "1", "; i <= ", "L1", ".", "length; i++) {\n        ", "GetElem(L1, ", "i", ", &", "e", ")", ";\n        ", "if", " (", "LocateElem(L2, ", "e", ", ", "equal", ")", ") {\n            ", "ListInsert(&L3, ", "i", ", ", "e", ")", ";\n            }\n    }\n    return ", "0", ";\n}\n\n", "\n", "代码如图所示，最后的GetElem（），LocateELem（）；ListInsert（）三个函数该如何定义？", "我试着声明了GetElem函数，错误：不允许使用不完整的类型，这是为何？", "谢谢！", "\n", "（这个代码是我根据《数据结构》严蔚敏的知识点编写的，书上代码用伪码表示，如果想找到相关C代码可以去哪里呢？）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;单向循环链表&amp;#xff0c;尾插法void Creatlist_tail(LinkList L, int n)里少了最尾部插入的结点 p-&amp;gt;next &amp;#61; L; &amp;#xff0c;不然就不是循环链表了&amp;#xff0c;代码里出现的问题&amp;#xff0c;不是删除链表节点的问题&amp;#xff0c;删除结点函数没有问题。修改如下&amp;#xff0c;改动处见注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;//单向循环链表 &lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt; &lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;pragma&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;warning&lt;/span&gt;(disable: 4996)&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//链表的类型定义 &lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LNode&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LNode&lt;/span&gt;* next;\n}LNode, * LinkList;\n&lt;span class=\"hljs-comment\"&gt;//链表的初始化,创建一个有头空链表。 &lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//链表的建立 &lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//头插法 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Creatlist_head&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    LinkList q; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    q &amp;#61; L;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        LinkList p &amp;#61; (LNode*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode)); \n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;please input\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;p-&amp;gt;data);\n        p-&amp;gt;next &amp;#61; q-&amp;gt;next; \n        q-&amp;gt;next &amp;#61; p;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//尾插法&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Creatlist_tail&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    LinkList q; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    q &amp;#61; L;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        LinkList p &amp;#61; (LNode*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode));\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;intput:\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;p-&amp;gt;data);\n        q-&amp;gt;next &amp;#61; p;\n        q &amp;#61; p;\n        p-&amp;gt;next &amp;#61; L;  &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//打印函数 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList L)&lt;/span&gt;\n&lt;/span&gt;{\n    LinkList p;\n    p &amp;#61; L;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;output:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next !&amp;#61; L)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, p-&amp;gt;next-&amp;gt;data);\n        p &amp;#61; p-&amp;gt;next;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-comment\"&gt;//删除函数(按值查找)&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;deletList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)&lt;/span&gt;\n&lt;/span&gt;{\n    LinkList p, tmp;&lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    p &amp;#61; L;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next !&amp;#61; L)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;next-&amp;gt;data &amp;#61;&amp;#61; i)\n        {\n            tmp &amp;#61; p-&amp;gt;next;     &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n            p-&amp;gt;next &amp;#61; p-&amp;gt;next-&amp;gt;next;\n            &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(tmp);        &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;delete success!\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-comment\"&gt;//if (p-&amp;gt;next-&amp;gt;data !&amp;#61; i) 修改&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//{                       修改&lt;/span&gt;\n        p &amp;#61; p-&amp;gt;next;\n        &lt;span class=\"hljs-comment\"&gt;//}                       修改&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;find fail\\n&amp;#34;&lt;/span&gt;);   &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    LinkList L;\n    L &amp;#61; (LNode*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode));&lt;span class=\"hljs-comment\"&gt;//创建新的节点&lt;/span&gt;\n    L-&amp;gt;next &amp;#61; L;&lt;span class=\"hljs-comment\"&gt;//指向本身 &lt;/span&gt;\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;start Creattail: \\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Creatlist_tail&lt;/span&gt;(L, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;start Creathead: \\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Creatlist_head&lt;/span&gt;(L, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n\n    &lt;span class=\"hljs-built_in\"&gt;deletList&lt;/span&gt;(L, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printList&lt;/span&gt;(L);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["单向循环链表的内存问题", ["\n", "//单向循环链表 ", "\n", "#", "include", " ", "<stdio.h>", " ", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "pragma", " ", "warning", "(disable: 4996)", "\n", "//链表的类型定义 ", "\n", "typedef", " ", "struct", " ", "LNode", "\n{\n    ", "int", " data;\n    ", "struct", " ", "LNode", "* next;\n}LNode, * LinkList;\n", "//链表的初始化,创建一个有头空链表。 ", "\n\n", "//链表的建立 ", "\n", "//头插法 ", "\n", "void", " ", "Creatlist_head", "(LinkList L, ", "int", " n)", "\n", "{\n     LinkList q; ", "int", " i;\n    q = L;\n    ", "for", " (i = ", "0", "; i < n; i++)\n    {\n        LinkList p = (LNode*)", "malloc", "(", "sizeof", "(LNode));", "//创建新的节点 ", "\n        ", "printf", "(", "\"please input\\n\"", ");\n        ", "scanf", "(", "\"%d\"", ", &p->data);", "//给新节点数据域赋值 ", "\n        p->next = q->next;", "//插入新节点的指针域 ,p->next 是说明 p 的指向，而L->next 是指下一个指针域 ", "\n        q->next = p;", "//插入新节点的指针域 ， L->next 是说明 L 的指向", "\n\n    }\n\n}\n\n", "//尾插法", "\n", "void", " ", "Creatlist_tail", "(LinkList L, ", "int", " n)", "\n", "{\n    LinkList q; ", "int", " i;\n    q = L;\n    ", "for", " (i = ", "0", "; i < n; i++)\n    {\n        LinkList p = (LNode*)", "malloc", "(", "sizeof", "(LNode));\n        ", "printf", "(", "\"intput:\\n\"", ");\n        ", "scanf", "(", "\"%d\"", ", &p->data);\n        q->next = p;", "//插入新节点的指针域 ,L->next 是说明 L 的指向", "\n        q = p;", "//保证插入后的新节点一直是尾节点 ", "\n\n    }\n    ", "//q->next = NULL;", "\n}\n", "//打印函数 ", "\n", "void", " ", "printList", "(LinkList L)", "\n", "{\n    LinkList p;", "//定义一个指针 ", "\n    p = L;", "//", "\n    ", "printf", "(", "\"output:\\n\"", ");\n    ", "while", " (p->next != L)", "//只要不指向指向本身，就没有遍历完 ", "\n    {\n        ", "printf", "(", "\"%d \"", ", p->next->data);", "//打印已经检索到的节点的数据 //p->data?", "\n        p = p->next;", "//顺链操作 ", "\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n\n", "//删除函数(按值查找)", "\n", "void", " ", "deletList", "(LinkList L, ", "int", " i)", "\n", "{\n    LinkList p;", "//定义一个临时指针 ", "\n    p = L;\n    ", "int", " k = ", "100", ";\n    ", "while", " (p->next != L)", "//只要遍历的指针不指向头", "\n    {\n        ", "if", " (p->next->data == i)", "//", "\n        {\n            p->next = p->next->next;", "//", "\n            ", "printf", "(", "\"delete success!\\n\"", ");\n            ", "return", ";\n        }\n        ", "if", " (p->next->data != i)\n        {\n            p = p->next;\n        }\n    }\n    ", "printf", "(", "\"delete fail\\n\"", ");\n\n}\n", "int", " ", "main", "()", "\n", "{\n    LinkList L;\n\n    L = (LNode*)", "malloc", "(", "sizeof", "(LNode));", "//创建新的节点", "\n    L->next = L;", "//指向本身 ", "\n\n    ", "printf", "(", "\"start Creattail: \\n\"", ");\n    ", "Creatlist_tail", "(L, ", "5", ");\n    ", "printf", "(", "\"start Creathead: \\n\"", ");\n    ", "Creatlist_head", "(L, ", "5", ");\n    ", "deletList", "(L, ", "5", ");\n    ", "printList", "(L);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "我想问一下，我这个程序删除链表节点的时候出现内存错误，是什么地方出了问题吗"]], "Tag": "程序设计"}
{"Answer": "已找到问题的原因了，是没有弄清楚窗口类对象与窗口本身的关系的问题，在Domodal之前窗口对象虽然存在但是窗口本身是不存在的，所以不能进行执行m_TableList.GetExtendedStyle()等对窗口动作，我是在 CDeviceListDlg添加变量来传递我需要的参数，然后通过这些参数用重载OnInitDialog来对m_TableList进行初始化。可参考：[http://bbs.csdn.net/topics/390957303](http://bbs.csdn.net/topics/390957303 \"\")", "Konwledge_Point": "定义新的类型", "Question": ["MFC出现Debug assertion failed问题", ["碰到一个问题，不明白错在哪里，请大神们指点一下！！！", "\n程序目的是在主窗口触发某事件后，弹出新的窗口显示列表，不同事件列表内容不同程序大概框架如下：", "\n在主窗口类中添加了公有成员变量m_DeviceDlg，它也是窗口类型，并且它包含一个列表控件（ListCtrl）", "\n//主窗口类定义", "\nclass CZigBeeHomeAutomationDesktopDlg : public CDialogEx", "\n{", "\n....", "\npublic:", "\n  CDeviceListDlg m_DeviceDlg;", "\n  void CZigBeeHomeAutomationDesktopDlg::OnClickDeviceList(NMHDR *pNMHDR, LRESULT *pResult);", "\n....", "\n}", "\n//根据触发条件显示列表窗口", "\nvoid CZigBeeHomeAutomationDesktopDlg::OnClickDeviceList(NMHDR *pNMHDR, LRESULT *pResult)", "\n{", "\n....", "\ncase ..:", "\n  m_DeviceDlg.LoadDeviceList(m_LockDeviceList, m_LockDeviceCount);", "\n  m_DeviceDlg.DoModal();", "\ncase ..:", "\n....", "\n}", "\n//列表窗口类定义", "\nclass CDeviceListDlg : public CDialogEx", "\n{", "\n...", "\npublic:", "\n  CListCtrl m_TableList;", "\n  void LoadDeviceList(void);", "\n...", "\n}", "\n//用于重载列表控件以显示不同内容", "\nvoid CDeviceListDlg::LoadDeviceList()", "\n{", "\n....", "\nDWORD dwStyle;", "\ndwStyle = m_TableList.GetExtendedStyle();<----这里发生Debug assertion failed", "\n}", "\nm_TableList为什么不能用了呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;回答&amp;#xff1a;你可以遍历一遍查找一下当前输入的学号是否和现有的数据一致即可&amp;#xff0c;可以采用strcmp函数进行判断&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["请问如何不让学号重复", ["//增加", "void add(){", "    printf(\"增加\\n\");", "\n", "//寻找尾巴结点位置", "\n", "struct", " ", "Student", " *student = first;\n", "while", " (student->next!=", "NULL", "){\n    student = student->next;\n} \n\n", "//创建新的学生", "\n", "struct", " ", "Student", " *student1 = (", "struct", " Student *)", "malloc", "(", "sizeof", "(", "struct", " Student));\n    \n", "//定义数据类型 ", "\n", "char", " id[", "8", "];\n", "char", " name[", "64", "];     \n", "double", " score[", "3", "];\n     \n", "//输入新学生数据", "\n", "printf", "(", "\"请输入学生学号：\"", ");\n", "scanf", "(", "\"%s\"", ",&id); \n", "printf", "(", "\"请输入学生姓名：\"", "); \n", "scanf", "(", "\"%s\"", ",&name);\n", "printf", "(", "\"请输入语文成绩：\"", ");\n", "scanf", "(", "\"%lf\"", ",&score[", "0", "]);\n", "printf", "(", "\"请输入数学成绩：\"", ");\n", "scanf", "(", "\"%lf\"", ",&score[", "1", "]);\n", "printf", "(", "\"请输入C语言成绩：\"", ");\n", "scanf", "(", "\"%lf\"", ",&score[", "2", "]);\n\n", "//录入    ", "\n", "strcpy", "(student1->id,id);\nstudent1->next = ", "NULL", ";\n", "strcpy", "(student1->name,name);\nstudent1->score[", "0", "]=score[", "0", "];\nstudent1->score[", "1", "]=score[", "1", "];\nstudent1->score[", "2", "]=score[", "2", "];\n\n", "//把新学生添加到链表尾部中", "\nstudent->next =student1;\nlength++;\nlen++;\n", "printf", "(", "\"增加完成\\n\"", ");\n", "printf", "(", "\"已返回主菜单\\n\"", ");    \n", "printf", "(", "\"*********************************************************\\n\"", "); \n", "\n", "} "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;typedef struct TNode\n{\n    char data&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    TNode* lchild&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    TNode* rchild&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}TNode&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n改为\ntypedef struct TNode\n{\n    char data&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    struct TNode* lchild&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    struct TNode* rchild&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}TNode&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言结构体问题希望得到帮助", ["想不明白一点，为什么调试的时候，将新字符付给这个结构体里面定义的字符类型变量，结果却显示0/000，为什么不是A那，我输入的是A啊，很头疼", "结构体类型以及全部代码在这里，引用的该作者的代码", "https://blogcsdnnet/qq_34941153/article/details/100153245", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<malloc.h>", "\n", "#", "define", " MaxSize 13", "\n", "typedef", " ", "struct", " ", "TNode", "\n{\n    ", "char", " data;\n    TNode* lchild;\n    TNode* rchild;\n}TNode;\n\n", "int", " ", "find_public", "(TNode T[],", "int", " i,", "int", " j)", "//注意这里不是TNode* &T", "\n", "{\n    ", "if", "(T[i].data!=", "'#'", "&&T[j].data!=", "'#'", ")", "//还要判断结点是否存在", "\n    {\n        ", "while", "(i!=j)\n        {\n            ", "if", "(i>j)\n                i=i/", "2", ";\n            ", "else", "\n                j=j/", "2", ";\n        }\n        ", "return", " i;\n    }\n    ", "else", "\n        ", "return", " ", "0", ";\n\n}\n\n", "int", " ", "main", "()", "\n", "{\n    TNode T[MaxSize];\n   \n    ", "for", "(", "int", " i=", "1", ";i<MaxSize;i++)", "//从数组下标1开始存储", "\n    {\n        ", "char", " h;\n        ", "scanf", "(", "\"%c\"", ",&h);\n        T[i].data=h;\n    }\n    ", "int", " k=", "find_public", "(T,", "4", ",", "10", ");\n    ", "printf", "(", "\"%c\"", ",T[k].data);", "//测试数据：ABCDE####F#，输出data:B", "\n    ", "return", " ", "0", ";\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "如果你是单点部署的话，就用你找的这种方法。如果你是集群部署，就按照楼上说的，部署一台服务器启动一台，没有部署的可以一直处于运行状态。", "Konwledge_Point": "定义新的类型", "Question": ["大家线上Java应用的热更新都是怎么实现的？", ["热更新的时候需要注意哪些点呢？", "\n下面是从网上找到的两种解决方法：", "\n\n", "解决方案一 : 自定义类加载器。", "\n\n", "首先需要明白一点，class相等的判断条件不仅仅是类名相同，还需要加载它的ClassLoader相同。JVM内部规定一个ClassLoader不可以重复定义类，也就是说想要重定义一个类，就必须使用一个全新的ClassLoader。", "\n\n", "JVM内部class被卸载的条件及其苛刻，甚至没有明确的方法可以直接调用，只有当加载该类型的类加载器实例为unreachable状态时，也就是没有任何实例，class才有可能被卸载。（启动类加载器实例永远为reachable状态，由启动类加载器加载的类型可能永远不会被卸载）", "\n\n", "public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n        Class<?> clazz = null;\n        // 首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则继续。\n        if (name.startsWith(\"com.wafer\") || name.contains(\"Service\")) {\n            if (resolve) {\n                resolveClass(clazz); // 链接指定的 Java 类\n            }\n            // 如果class类被修改过，则重新加载\n            MoeLoader hcl = new MoeLoader(url);\n            clazz = customLoad(name, hcl);\n            return (clazz);\n        }\n        // 如果类的包名为\"java.\"开始，则有系统默认加载器加载\n        try {\n            // 得到系统默认的加载cl\n            ClassLoader system = ClassLoader.getSystemClassLoader();\n            clazz = system.loadClass(name); // 加载名称为 name的类\n            if (clazz != null) {\n                if (resolve)\n                    resolveClass(clazz);\n                return (clazz);\n            }\n        } catch (ClassNotFoundException e) {\n            // Ignore\n        }\n        return customLoad(name, this);\n        }\n\n\n", "\n\n", "此范例的核心在于缓存自己已经加载的class，当再次需要加载时，如果发生变更，则可以new一个ClassLoader，这样新的字节码便可以即时生效。", "\n\n", "JRbel是一种热更新的方案，它实现的方式是通过在启动参数中添加javaagent，即JVM底层提供的Instrumentation技术，来改变生成对象的方式。", "\n\n", "解决方法二：", "\njava.lang.instrument这个类很早就出了，redefineClasses这个方法可以更新方法级别的代码，但是不会触发一个类的初始化方法。游戏服务器的bug基本上只需要方法级别的更新就可以了，因为很多重大的bug基本在测试阶段被修复了，少量偶线的bug出现之后有些时候仅仅只需要改动一行代码却有时不得不需要重启所有应用程序，代价都似乎有点大。", "\n现在开始从instrument入手", "\n\n", "public static void premain(String agentArgs, Instrumentation inst);\n\npublic static void agentmain(String agentArgs, Instrumentation inst);\n", "\n\n", "这两个方法都可以获取到Instrumentation对象，通过redefineClasses方法就可以更新对应的方法了 ", "\n如果是调用premain这个方法 则需要在程序启动的时候指定对应的jar 同时项目里必须引用这个jar 因为获取到这个引用 ", "\njava -javaagent:agent.jar -jar xx.jar 例如这样 执行这条命令后程序会查找 agent.jar 里的MANIFEST.MF文件里的Premain-Class参数 设置对应的代理类路径就行。例如：Premain-Class: com.test.JavaAgent 还需要加上 Can-Redefine-Classes: true这个参数才能调用redefineClasses方法。同时 可以拦截对应的类添加标记 做性能分析 ", "\nagentmain 是通过指定对应的进程pid来加载对应的agent.jar 很典型的jconsule jvisualvm都是通过选择java进程来做一个简单的内存 和cpu分析 ，线程dump .Agent-Class 和上面一样", "\n\n", "package com.test;\n\nimport java.lang.instrument.Instrumentation;\n\npublic class JavaAgent {\n    public static Instrumentation INST = null;\n\n    public static void premain(String agentArgs, Instrumentation inst){\n        INST = inst;\n    }\n}\n\n", "\n\n", "这里保存下引用就可以了 ，单独打成agent.jar", "\n\n", "package com.test;\n\nimport java.io.FileInputStream;\nimport java.lang.instrument.ClassDefinition;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        getInfo();\n        testhot();\n    }\n\n    public final static void testhot(){\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                while(true){\n                    try {\n                    if(JavaAgent.INST != null){\n                        FileInputStream is = new FileInputStream(\"/Users/xxxx/Downloads/Student.class\");\n                        byte[] array = new byte[is.available()];\n                        is.read(array);\n                        is.close();\n                        Class cls = Class.forName(\"com.test.Student\");\n                        JavaAgent.INST.redefineClasses(new ClassDefinition(cls,array));\n                    }\n                        Thread.sleep(1000);\n                    } catch (Exception e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n    }\n\n\n\n\n    public final static void getInfo(){\n        new Thread(new Runnable() {\n\n            @Override\n            public void run() {\n                // TODO Auto-generated method stub\n                while(true){\n                    //System.out.println(\"==============\"+JavaAgent.INST);\n                    new Student().getName();\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }).start();\n\n    }\n}\n\n", "\n\n", "上面就是一个很简单的例子，一个线程在不停的循环检测更新这个类，另外的一个线程在不停的输出这个对象对应的方法输出信息。 ", "\n测试之后可以发现 ，方法的输出信息已经改变了。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;constructor&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(bytes32[] memory proposalNames)&lt;/span&gt;  &lt;span class=\"hljs-title\"&gt;public&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;{\n        chairperson &amp;#61; msg.sender;\n        voters[chairperson].weight &amp;#61; 1;\n        //对于提供的每个提案名称&amp;#xff0c;\n        //创建一个新的 Proposal 对象并把它添加到数组的末尾。\n        for (uint i &amp;#61; 0; i &amp;lt; proposalNames.length; i&amp;#43;&amp;#43;) {\n            // &amp;#96;Proposal({...}&lt;/span&gt;)&amp;#96; 创建一个临时 &lt;span class=\"hljs-title\"&gt;Proposal&lt;/span&gt; 对象&amp;#xff0c;\n            &lt;span class=\"hljs-comment\"&gt;// &amp;#96;proposals.push(...)&amp;#96; 将其添加到 &amp;#96;proposals&amp;#96; 的末尾&lt;/span&gt;\n            &lt;span class=\"hljs-title\"&gt;proposals&lt;/span&gt;.&lt;span class=\"hljs-title\"&gt;push&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Proposal(&lt;span class=\"hljs-comment\"&gt;{\n                name: proposalNames[i],\n                voteCount: 0\n            }&lt;/span&gt;)&lt;/span&gt;);&lt;/span&gt;\n        }\n    }\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["Solidity官方文档中的“委托投票”案例remix上运行报错。", ["问题遇到的现象和发生背景", "\n", "\n      \n        ", "根据例子学习Solidity — Solidity develop 文档", "\n        \n      ", "\n      ", "\n      ", "\n        ", "\n          ", "https://solidity-cn.readthedocs.io/zh/develop/solidity-by-example.html", "\n        ", "\n      ", "根据Solidity官方文档学习材料，我按照示范，模仿着编写。但在“为 ", "proposalNames", " 中的每个提案，创建一个新的（投票）表决”这个位置上出现了报错。", "\n", "问题相关代码", "\n", "\n", "constructor", "(bytes32[] proposalNames)", "  ", "public", "{\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n        //对于提供的每个提案名称，\n        //创建一个新的 Proposal 对象并把它添加到数组的末尾。\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...}", ")` 创建一个临时 ", "Proposal", " 对象，\n            ", "// `proposals.push(...)` 将其添加到 `proposals` 的末尾", "\n            ", "proposals", ".", "push", "(Proposal(", "{\n                name: proposalNames[i],\n                voteCount: 0\n            }", ")", ");", "\n        }\n    }\n\n", "\n", "运行结果及报错内容", "\n", "from solidity:", "TypeError: Data location must be \"storage\" or \"memory\" for constructor parameter, but none was given.", "  --> 委托投票案例.sol:31:19:", "   |", "31 |     constructor  (bytes32[] proposalNames) public {", "   |                                ^", "\n", "我想要达到的结果", "\n", "如何解决这个这个报错，以及constructor需要是用什么样的定义类型？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;linked_List.h&amp;#34;&lt;/span&gt;这一句删了&amp;#xff0c;或者把这一句上面的代码都保存到linked_List.h文件中&lt;/span&gt;\n\n看你的文件结构&amp;#xff0c;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;linked_List.h&amp;#34;&lt;/span&gt;应该是cpp文件的第一行。&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于频繁出现linked_List.h:No such file or directory的问题却不知道问题出现在哪这件事", ["做软基实验的时候出现的问题，题目大概是：建立一个空线性链表，依次进行扫描、插入、扫描、删除、扫描的操作。", "\n", "代码如下", "\n", "//linked_List.h", "\n    ", "#", "include", " ", "<iostream>", "\n    ", "using", " ", "namespace", " std;\n    ", "//定义结点类型", "\n    ", "template", " <", "class", " ", "T", ">  ", "//T为虚拟类型", "\n    ", "struct", " ", "node", "\n    { T d;\n      node *next;\n    };\n    ", "//定义线性链表类", "\n    ", "template", " <", "class", " ", "T", ">  ", "//模板声明,数据元素虚拟类型为T", "\n    ", "class", "  ", "linked_List", "\n    { ", "private", ":  ", "//数据成员", "\n        node<T> *head;     ", "//链表头指针", "\n      ", "public", ":   ", "//成员函数", "\n        ", "linked_List", "();    ", "//构造函数,建立空链表", "\n        ", "void", " ", "prt_linked_List", "()", ";  ", "//扫描输出链表中的元素", "\n        ", "void", " ", "ins_linked_List", "(T, T)", ";  ", "//在包含元素x的结点前插入新元素b", "\n        ", "int", " ", "del_linked_List", "(T)", ";     ", "//删除包含元素x的结点", "\n    };\n    ", "//建立空链表", "\n    ", "template", " <", "class", " ", "T", ">\n    linked_List<T>::", "linked_List", "()  \n    { head=", "NULL", ";  ", "return", "; }\n    ", "//扫描输出链表中的元素", "\n    ", "template", " <", "class", " ", "T", ">\n    ", "void", " linked_List<T>::", "prt_linked_List", "()\n    { node<T> *p;\n      p=head;\n      ", "if", " (p==", "NULL", ") { cout <<", "\"空链表！\"", " <<endl; ", "return", "; }\n      ", "do", " { cout <<p->d <<endl; \n           p=p->next;\n         } ", "while", " (p!=", "NULL", ");\n      ", "return", ";\n    }\n    ", "//在包含元素x的结点前插入新元素b", "\n    ", "template", " <", "class", " ", "T", ">\n    ", "void", " linked_List<T>::", "ins_linked_List", "(T x, T b)\n    { node<T> *p, *q;\n      p=", "new", " node<T>;  ", "//申请一个新结点", "\n      p->d=b;      ", "//置新结点的数据域", "\n      ", "if", " (head==", "NULL", ")  ", "//原链表为空", "\n      { head=p; p->next=", "NULL", "; ", "return", ";}\n      ", "if", " (head->d==x)  ", "//在第一个结点前插入", "\n      { p->next=head;  head=p;  ", "return", "; }\n      q=head;\n      ", "while", " ((q->next!=", "NULL", ")&&(((q->next)->d)!=x))\n          q=q->next;  ", "//寻找包含元素x的前一个结点q", "\n      p->next=q->next;  q->next=p;  ", "//新结点p插入到结点q之后", "\n      ", "return", ";\n    }\n    ", "//删除包含元素x的结点元素", "\n    ", "template", " <", "class", " ", "T", ">\n    ", "int", " linked_List<T>::", "del_linked_List", "(T x) \n    { node<T> *p, *q;\n      ", "if", " (head==", "NULL", ") ", "return", "(", "0", "); ", "//链表为空，无删除的元素", "\n      ", "if", " ((head->d)==x)  ", "//删除第一个结点", "\n      { p=head->next; ", "delete", " head; head=p; ", "return", "(", "1", "); }\n      q=head;\n      ", "while", " ((q->next!=", "NULL", ")&&(((q->next)->d)!=x))\n          q=q->next;  ", "//寻找包含元素x的前一个结点q", "\n      ", "if", " (q->next==", "NULL", ") ", "return", "(", "0", "); ", "//链表中无删除的元素", "\n      p=q->next; q->next=p->next;  ", "//删除q的下一个结点p", "\n      ", "delete", " p;  ", "//释放结点p的存储空间", "\n      ", "return", "(", "1", ");\n    }\n", "#", "include", "\"linked_List.h\"", "\n", "int", " ", "main", "()", "\n", "{linked_List<", "int", "> s;\ncout<<", "\"第一次扫描输出链表s中的元素：\"", "<<endl;\ns.", "prt_linked_List", "();\ns.", "ins_linked_List", "(", "10", ",", "10", ");\ns.", "ins_linked_List", "(", "10", ",", "20", ");\ns.", "ins_linked_List", "(", "10", ",", "30", ");\ns.", "ins_linked_List", "(", "40", ",", "40", ");\ncout<<", "\"第二次扫描输出链表s中的元素：\"", "<<endl;\ns.", "prt_linked_List", "();\n", "if", "(s.", "del_linked_List", "(", "30", "))\ncout<<", "\"删除元素：30\"", "<<endl;\n", "else", "\ncout<<", "\"链表中无元素：30\"", "<<endl;\n", "if", "(s.", "del_linked_List", "(", "50", "))\ncout<<", "\"删除元素：50\"", "<<endl;\n", "else", "\ncout<<", "\"链表中无元素：50\"", "<<endl;\ncout<<", "\"第三次扫描输出链表s中的元素：\"", "<<endl;\ns.", "prt_linked_List", "();\n", "return", " ", "0", ";\n}\n\n", "\n", "运行结果", "\n", "\n", "很多程序都出现了这个 No such file or directory，不是很懂，求大佬讲的通俗一点应该怎么解决"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个while 循环&amp;#xff0c;我在上一个问答中已经回答&lt;br /&gt;第二个框&amp;#xff0c;表示如果你num 输入ok&amp;#xff0c;那么就想这个值存到 p-&amp;gt;num 中&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["代码中用黑圈圈起来的地方是什么意思？以及为什么头尾指针要赋值为NULL?", ["#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "\n", "struct stud_node {", "     int    num;", "     char   name[20];", "     int    score;", "     struct stud_node *next;", "};", "struct stud_node *head, *tail;", "\n", "void input();", "\n", "int main()", "{", "    struct stud_node *p;", "\n", "head = tail = ", "NULL", ";\ninput();\n", "for", " ( p = head; p != ", "NULL", "; p = p->next )\n    printf(", "\"%d %s %d\\n\"", ", p->num, p->name, p->score);\n\n", "return", " ", "0", ";\n", "\n", "}", "\n", "/* 你的代码将被嵌在这里 */", "\n", "\n", "void input()", "{", "    int num;", "    //struct stud_node *head,*tail;", "    //head和tail已经声明为全局变量不可重复定义再定义就为错", "    head=tail=NULL;", "    while(scanf(\"%d\",&num)&&num!=0)", "    {", "         //C语言中开辟一个结构体stud_node大小的空间并且用指针p指向开辟的空间", "        struct stud_node *p=(struct stud_node *)malloc(sizeof(struct stud_node ));", "        p->num=num;", "        //scanf中若输入的是int类型的数则要用&", "        scanf(\"%s %d\", p->name,&p->score);", "        //若链表为空则首等于尾指向同一个位置", "        if(head==NULL)", "        {", "            head=tail=p;", "        }", "        //若链表不为空则尾的位置每次都在变化", "        //尾的下一个插入p，p又变成新的尾", "        //即尾指向p的位置", "        else", "        {", "            tail->next=p;", "            tail=p;", "        }", "    }", "}"]], "Tag": "程序设计"}
{"Answer": "pos-&gt;flags &amp;= ~SWP_DRAWFRAME;", "Konwledge_Point": "定义新的类型", "Question": ["WM_WINDOWPOSCHANGING消息中的WINDOWPOS->flags成员怎么清除相应位SWP_DRAWFRAME？？？", ["WM_WINDOWPOSCHANGING消息备注：", "\n\n", "对于具有WS_OVERLAPPED或WS_THICKFRAME样式的窗口，DefWindowProc函数将WM_GETMINMAXINFO消息发送到窗口。", "\n\n", "这样做是为了验证窗口的新大小和位置，并强制执行CS_BYTEALIGNCLIENT和CS_BYTEALIGNWINDOW客户端样式。", "\n\n", "通过不将WM_WINDOWPOSCHANGING消息传递给DefWindowProc函数，应用程序可以覆盖这些默认值。", "\n\n", "在处理此消息时，修改WINDOWPOS中的任何值会影响窗口在Z顺序中的新大小，位置或位置。应用程序可以通过设置或清除WINDOWPOS的flags成员中的相应位来阻止对窗口的更改。", "\n\n", "WINDOWPOS结构成员flags描述", "\n\n", "flags 类型：UINT", "\n\n", "该成员可以是以下一个或多个值。", "\n\n", "值 含义", "\n\n", "SWP_DRAWFRAME", "\n0×0020", "\n\n", "在窗口周围绘制一个框架（在窗口的类描述中定义）。与SWP_FRAMECHANGED标志相同。", "\n\n", "SWP_FRAMECHANGED 0×0020", "\n\n", "即使窗口的大小未更改，也会向窗口 发送WM_NCCALCSIZE消息。如果未指定此标志，则仅在更改窗口大小时发送WM_NCCALCSIZE。", "\n\n", "    case WM_NCCALCSIZE:return 0；\n    case WM_WINDOWPOSCHANGING:\n    {\n        WINDOWPOS *pos = (LPWINDOWPOS)lParam;\n        pos->flags;//怎么清除相应位SWP_DRAWFRAME？？？\n        return 0;\n    }\n", "\n\n", "WM_NCCALCSIZE消息返回0后可以无边框，但是最大化时会发生位移", "\n\n", "不正常(-8, -8)-(1374, 776), 1382x784 (最大化)", "\n\n", "正常（0，0）-（1366，768）（最大化）", "\n\n", "清除相应位SWP_DRAWFRAME后应该就可以实现正常，但怎么实现？？？"]], "Tag": "程序设计"}
{"Answer": "他说OnInitialUpdate()未申明，要在类中加个定义，而且是虚函数。", "Konwledge_Point": "定义新的类型", "Question": ["vs 2012  OnInitialUpdate() 不允许使用继成员", ["请教下大家：", "\n\n", " vs 2012中为何出现这个提示呢？同时m_ctrList已经定义后仍然提示\n", "\n\n", "\n\n", "1>  CteFormView.cpp", "\n1>d:\\myfile\\visual studio 2012\\projects\\xuglassform\\xuglassform\\cteformview.cpp(55): error C2509: “OnInitialUpdate”: 成员函数没有在“CCteFormView”中声明", "\n1>          d:\\myfile\\visual studio 2012\\projects\\xuglassform\\xuglassform\\cteformview.h(10) : 参见“CCteFormView”的声明", "\n1>d:\\myfile\\visual studio 2012\\projects\\xuglassform\\xuglassform\\cteformview.cpp(93): error C2664: “int CListCtrl::InsertItem(int,LPCTSTR)”: 不能将参数 2 从“const char [1]”转换为“LPCTSTR”", "\n1>          与指向的类型无关；转换要求 reinterpret_cast、C 样式转换或函数样式转换", "\n1>d:\\myfile\\visual studio 2012\\projects\\xuglassform\\xuglassform\\cteformview.cpp(94): error C2664: “void ATL::CStringT::Format(const wchar_t *,...)”: 不能将参数 1 从“const char [3]”转换为“const wchar_t *”", "\n1>          with", "\n1>          [", "\n1>              BaseType=wchar_t,", "\n1>              StringTraits=StrTraitMFC_DLL", "\n1>          ]", "\n1>          与指向的类型无关；转换要求 reinterpret_cast、C 样式转换或函数样式转换", "\n========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 =========="]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;添加************************************的地方是我修改的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\nstruct Node\n{\n    int info;\n    struct Node* next;\n};\ntypedef struct Node* PNode;&lt;span class=\"hljs-comment\"&gt;//定义结点类型指针&lt;/span&gt;\nstruct Linklist\n{\n    PNode head;\n};\ntypedef struct Linklist Linklist, * PLinklist;&lt;span class=\"hljs-comment\"&gt;//定义链表结构及其指针&lt;/span&gt;\nPLinklist createNullList(int n)&lt;span class=\"hljs-comment\"&gt;//创建一个新的链表&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;){\n        return nullptr;\n    }\n    int i;\n    PLinklist pllist;\n    PNode p &amp;#61; nullptr, q &amp;#61; nullptr;&lt;span class=\"hljs-comment\"&gt;//初始化一下p和q的值************************************&lt;/span&gt;\n    pllist &amp;#61; (PLinklist)malloc(sizeof(PLinklist));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pllist&lt;/span&gt;-&amp;gt;&lt;/span&gt;head &amp;#61; (PNode)malloc(sizeof(PNode));&lt;span class=\"hljs-comment\"&gt;//申请header************************************&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; pllist-&amp;gt;&lt;/span&gt;head;    \n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        q &amp;#61; (PNode)malloc(sizeof(PNode));&lt;span class=\"hljs-comment\"&gt;//用于指向下一个位置&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; q;&lt;span class=\"hljs-comment\"&gt;//赋值方向反了************************************&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;scanf&lt;/span&gt;(&amp;#34;%d&amp;#34;, &amp;amp;q-&amp;gt;&lt;/span&gt;info);&lt;span class=\"hljs-comment\"&gt;//给链表赋值&lt;/span&gt;\n        p &amp;#61; q;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;&lt;span class=\"hljs-comment\"&gt;//输入完毕&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//free(q);//这里没有必要释放&amp;#xff0c;因为你申请的内存都已经存储到链表中了************************************&lt;/span&gt;\n    return pllist;\n}\nvoid merge(PNode pa, PNode pb, PLinklist lc)&lt;span class=\"hljs-comment\"&gt;//排序&lt;/span&gt;\n{\n    PNode pc;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;lc&lt;/span&gt;-&amp;gt;&lt;/span&gt;head &amp;#61; pc &amp;#61; pa;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pb&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pa &amp;amp;&amp;amp; pb)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (pa-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;info&lt;/span&gt; &amp;lt;&amp;#61; pb-&amp;gt;&lt;/span&gt;info)\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pc&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; pa;\n            pc &amp;#61; pa;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;next;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pc&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; pb;\n            pc &amp;#61; pb;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;next;\n        }\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pc&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; pa ? pa : pb;&lt;span class=\"hljs-comment\"&gt;//较长链表的剩余部分直接接入&lt;/span&gt;\n}\nint main()&lt;span class=\"hljs-comment\"&gt;//主函数部分&lt;/span&gt;\n{\n    int n, m;\n    PLinklist la, lb, lc;&lt;span class=\"hljs-comment\"&gt;//用于排序的两个链表la,lb&amp;#xff0c;用于合并的链表lc&lt;/span&gt;\n    lc &amp;#61; (PLinklist)malloc(sizeof(PLinklist));&lt;span class=\"hljs-comment\"&gt;//构建lc ************************************&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;lc&lt;/span&gt;-&amp;gt;&lt;/span&gt;head &amp;#61; nullptr;&lt;span class=\"hljs-comment\"&gt;//************************************&lt;/span&gt;\n    PNode pa, pb;\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, &amp;amp;n);\n    la &amp;#61; createNullList(n);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; la-&amp;gt;&lt;/span&gt;head;\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, &amp;amp;m);\n    lb &amp;#61; createNullList(m);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pb&lt;/span&gt; &amp;#61; lb-&amp;gt;&lt;/span&gt;head;\n    merge(pa, pb, lc);\n    PNode temp;&lt;span class=\"hljs-comment\"&gt;//用于输出的结点&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;for&lt;/span&gt; (temp &amp;#61; lc-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;head&lt;/span&gt;; temp; temp &amp;#61; temp-&amp;gt;&lt;/span&gt;next)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d\\n&amp;#34;, temp-&amp;gt;&lt;/span&gt;info);\n    }\n    &lt;span class=\"hljs-comment\"&gt;//free(temp); //释放,这里不用释放&amp;#xff0c;因为不是你申请的&amp;#xff0c;否则lc就会被破坏了************************************&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//需要释放一下lc的内存************************************&lt;/span&gt;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["用链表实现两个有序数组的输入和排序", ["有可能是因为创建链表部分不对，希望大师支招", "以下是代码：", "#include <stdio.h>", "#include <stdlib.h>", "     struct Node", "    {", "        int info;", "        struct Node *next;", "    };", "    typedef struct Node *PNode;//定义结点类型指针", "    struct Linklist", "    {", "        PNode head;", "    };", "    typedef struct Linklist Linklist,*PLinklist;//定义链表结构及其指针", "    PLinklist createNullList(int n)//创建一个新的链表", "{", "    int i;", "    PLinklist pllist;", "    PNode p,q;", "    pllist=(PLinklist)malloc(sizeof(PLinklist));", "    p=pllist->head;", "    p->next=NULL;", "     for(i=0;i<n;i++)", "     {", "         q=(PNode)malloc(sizeof(PNode));//用于指向下一个位置", "         q=p->next;", "         scanf(\"%d\",&q->info);//给链表赋值", "         p=q;", "     }", "     p->next=NULL;//输入完毕", "     free(q);//释放", "     return pllist;", "}", "void merge(PNode pa,PNode pb,PLinklist lc)//排序", "{", "    PNode pc;", "    lc->head=pc=pa;", "    pa=pa->next;", "    pb=pb->next;", "    while(pa&&pb)", "    {", "        if(pa->info<=pb->info)", "        {", "            pc->next=pa;", "            pc=pa;", "            pa=pa->next;", "        }", "        else", "        {", "        pc->next=pb;", "        pc=pb;", "        pa=pb->next;", "        }", "    }", "    pc->next=pa?pa:pb;//较长链表的剩余部分直接接入", "}", "    int main()//主函数部分", "{", "    int n,m;", "    PLinklist la,lb,lc;//用于排序的两个链表la,lb，用于合并的链表lc", "    PNode pa,pb;", "    scanf(\"%d\\n\",&n);", "    la=createNullList(n);", "    pa=la->head;", "    scanf(\"%d\\n\",&m);", "    lb=createNullList(m);", "    pb=lb->head;", "    merge(pa,pb,lc);", "    PNode temp;//用于输出的结点", "    for(temp=lc->head;temp;temp=temp->next)", "    {", "        printf(\"%d\\n\",temp->info);", "    }", "    free(temp); //释放", "    return 0;", "}", "在DEV C++上无法输入第二个数组，", "在codeblocks上error：Aborted（program collect2）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为node是自己造的结构体&amp;#xff0c;这个node构造体中有值和指针&amp;#xff0c;所以p这个变量中除了有值之外&amp;#xff0c;还有一个指针&lt;br /&gt;&amp;#61;&amp;#61;这个理解有问题&amp;#xff0c;p指针存储的地址是node结构体的首地址&amp;#xff0c;没有什么“除了有值之外&amp;#xff0c;还有一个指针”的说法&lt;br /&gt;换个白话理解一下&lt;br /&gt;结构体也好&amp;#xff0c;普通变量也好&amp;#xff0c;就像一栋楼&amp;#xff0c;或者一个小区。指针就是一张白纸&amp;#xff0c;纸上写着楼号或者小区地址而已。甚至这个地址到底是盖的小区&amp;#xff0c;商业大楼都无所谓&amp;#xff0c;这就是void指针&amp;#xff0c;只是一个地址而已。如果带着类型&amp;#xff0c;比如结构体指针&amp;#xff0c;整型指针&amp;#xff0c;那么就是在纸上还写了这个地址到底盖了什么建筑。在这种情况下&amp;#xff0c;编译器编译的时候就会进行检查&amp;#xff0c;如果指针指向的地址盖的不是类型所指定的建筑&amp;#xff0c;就会报错提示。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于结构体链表的问题", ["\n", "\n", "\n", "第一张图片右边那部分，一开始构造了指针 p q o ，其中p，q，o是node类型的指针，之前有定义说：我们把存的值是地址的变量叫做指针，以p为例子，因为node是自己造的结构体，这个node构造体中有值和指针，所以p这个变量中除了有值之外，还有一个指针，一开始构造的时候会默认为空指针（即什么也不指），node* p=new Node(1),把新构造的结构体的地址赋值给p，所以现在p的值部分存的是Node 1的地址 p的指针部分什么也没存，q，o也一样，然后p-> next = q 把q赋值给p 中的next指针，一般把一个地址赋给一个指针的话需要写&取地址符号，代表取变量的地址，这里因为q的值本来就是一个地址，所以没有写取地址符号，直接把Node 2的地址给了p的指针，那么p的指针就指向了Node 2，然后一系列操作下来，不就变成了我在草稿纸上画的图片了吗，怎么会是第二张图片上的样子呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;复制构造函数没有实现&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["无法解析的外部符号，无法解析的外部命令，问题出在哪？如何改进?", ["\n", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cmath>", "\n", "#", "include", " ", "<iomanip>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Piont", " {", "//类的定义", "\n", "public", ":\n    ", "Piont", "(", "int", " xx = ", "0", ", ", "int", " yy = ", "0", ") {\n        x = xx;\n        y = yy;\n    }\n    ", "Piont", "(Piont& p);\n    ", "int", " ", "getX", "()", " ", "{ ", "return", " x; }\n    ", "int", " ", "getY", "()", " ", "{ ", "return", " y; }\n", "private", ":\n    ", "int", " x, y;\n};\nPiont::", "Piont", "(Piont& p) {", "//复制构造函数的实现", "\n    x = p.", "getX", "();\n    y = p.", "getY", "();\n    cout << ", "\"Calling the copy constructor of Piont\"", " << endl;\n\n\n}\n", "//类的组合", "\n", "class", " ", "Line", " {", "//Line类的定义", "\n", "public", ":", "//外部接口", "\n    ", "Line", "(Piont xp1, Piont xp2);\n    ", "Line", "(Line& l);\n    ", "double", " ", "getLen", "()", " ", "{ ", "return", " len; }\n", "private", ":\n    Piont p1, p2;\n    ", "double", " len;\n};\n", "//组合类的构造函数", "\nLine::", "Line", "(Piont xp1, Piont xp2) :", "p1", "(xp1), ", "p2", "(xp2) {\n    cout << ", "\"线段类型的构造函数\"", " << endl;\n    ", "double", " x=", "static_cast", "<", "double", ">(p1.", "getX", "() - p2.", "getX", "());\n    ", "double", " y=", "static_cast", "<", "double", ">(p1.", "getY", "() - p2.", "getY", "());\n    len = ", "sqrt", "(x * x + y * y);\n}\n\n\n\n", "int", " ", "main", "()", "\n", "{\n    ", "Piont ", "myp1", "(", "1", ", ", "1", ")", ", ", "myp2", "(", "4", ", ", "5", ")", ";", "//建立Piont类的对象", "\n    ", "Line ", "line", "(myp1, myp2)", ";", "//建立Line类的对象", "\n    ", "Line ", "line2", "(line)", ";", "//利用复制构造函数建立一个新对象", "\n    cout << ", "\"这个线段的长度是：\"", ";\n    cout << line.", "getLen", "() << endl;\n    cout << ", "\"线段2的长度是：\"", ";\n    cout << line2.", "getLen", "() << endl;\n\n\n\n\n\n\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是一个命令行程序&amp;#xff0c;需要打开cmd&amp;#xff0c;输入命令运行。如cmd进入程序所在的文件夹后&amp;#xff0c;输入命令&amp;#xff1a;图片缩放.exe &amp;#34;新建位图图像.bmp&amp;#34; 50 &amp;#34;缩放后的图像.bmp&amp;#34;&lt;br /&gt;你的代码没有考虑bmp每行按4字节对齐的情况。&lt;br /&gt;修改后的代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt; \n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;pragma&lt;/span&gt; pack(1)&lt;span class=\"hljs-comment\"&gt;//结构体中各成员按1字节对齐&lt;/span&gt;&lt;/span&gt;\n \n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;BITMAPFILEHEADER&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//定义一个存储头文件数据结构体&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; bfType;        &lt;span class=\"hljs-comment\"&gt;// 保存文件类型。&amp;#39;BM&amp;#39;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; bfSize;        &lt;span class=\"hljs-comment\"&gt;//位图文件总字节数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; bfReserved1; &lt;span class=\"hljs-comment\"&gt;//位图文件保留字段&amp;#xff0c;必须为0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; bfReserved2; &lt;span class=\"hljs-comment\"&gt;//位图文件保留字段&amp;#xff0c;必须为0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; bfOffBits;    &lt;span class=\"hljs-comment\"&gt;//RGB数据偏移地址&amp;#xff0c;位图数据起始位置&lt;/span&gt;\n    };\n \n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;BITMAPINFOHEADER&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//定义一个存储位图信息的结构体&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biSize;           &lt;span class=\"hljs-comment\"&gt;//本结构占用字节数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biWidth;           &lt;span class=\"hljs-comment\"&gt;//位图像素宽度&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biHeight;           &lt;span class=\"hljs-comment\"&gt;//位图像素高度&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; biPlanes;       &lt;span class=\"hljs-comment\"&gt;// bmp图片的平面数量&amp;#xff0c;为1&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; biBitCount;       &lt;span class=\"hljs-comment\"&gt;//每个像素所占的位数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biCompression;   &lt;span class=\"hljs-comment\"&gt;//位图压缩类型&amp;#xff0c;不压缩(为0)&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biSizeImage;       &lt;span class=\"hljs-comment\"&gt;//位图图像数据所占字节数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biXPelsPerMeter; &lt;span class=\"hljs-comment\"&gt;//位图水平分辨率&amp;#xff0c;每米像素数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biYPelsPerMeter; &lt;span class=\"hljs-comment\"&gt;//位图垂直分辨率&amp;#xff0c;每米像素数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biClrUsed;       &lt;span class=\"hljs-comment\"&gt;//位图实际使用的颜色表中的颜色数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; biClrImportant;  &lt;span class=\"hljs-comment\"&gt;//位图显示过程中重要的颜色数&lt;/span&gt;\n};\n \n&lt;span class=\"hljs-comment\"&gt;//zoom函数用于缩放&amp;#xff0c;BITMAPFILEHEADER head, BITMAPINFOHEADER info为原图像头信息,缩放倍数为2&amp;#xff0c;char字符串类型指针变量&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;zoom&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(BITMAPFILEHEADER head, BITMAPINFOHEADER info, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *input, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *output, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; rate)&lt;/span&gt;\n&lt;/span&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//r&amp;#xff1a;打开文件仅供读取&amp;#xff0c;w:打开文件仅供写入&amp;#xff0c;b&amp;#xff1a;二进制&lt;/span&gt;\n    FILE *fr &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(input, &lt;span class=\"hljs-string\"&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;);\n    FILE *fw &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(output, &lt;span class=\"hljs-string\"&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;);\n \n    &lt;span class=\"hljs-comment\"&gt;//若读取不成功&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fr &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; || fw &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;图片错误\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;//读取原图像的头信息&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(&amp;amp;head, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(BITMAPFILEHEADER), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, fr);\n    &lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(&amp;amp;info, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(BITMAPINFOHEADER), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, fr);\n \n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; old_Width &amp;#61; info.biWidth;&lt;span class=\"hljs-comment\"&gt;//获取原图像的宽信息&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; old_height &amp;#61; info.biHeight;&lt;span class=\"hljs-comment\"&gt;//获取原图像的高信息&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *old_data &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((old_Width * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)*old_height);&lt;span class=\"hljs-comment\"&gt;//获取原图像的位图数据&lt;/span&gt;\n \n    &lt;span class=\"hljs-comment\"&gt;////定位到图像数据位置&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fseek&lt;/span&gt;(fr, &lt;span class=\"hljs-number\"&gt;54&lt;/span&gt;, SEEK_SET);\n    &lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(old_data, (old_Width * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)*old_height, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, fr);\n \n    &lt;span class=\"hljs-comment\"&gt;//修改原图像的宽高&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; new_Width, new_Height;\n \n    new_Width &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)(rate * old_Width);&lt;span class=\"hljs-comment\"&gt;//新宽等于倍数乘原宽&lt;/span&gt;\n    new_Height &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)(rate * old_height);&lt;span class=\"hljs-comment\"&gt;//新高等于倍数乘原高&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//修改头信息&lt;/span&gt;\n    head.bfSize &amp;#61; (new_Width * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) * new_Height &amp;#43; &lt;span class=\"hljs-number\"&gt;54&lt;/span&gt;;\n \n    info.biWidth &amp;#61; new_Width;\n    info.biHeight &amp;#61; new_Height;\n \n    &lt;span class=\"hljs-comment\"&gt;//将修改后的头信息写进新图像&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(&amp;amp;head, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(BITMAPFILEHEADER), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, fw);\n    &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(&amp;amp;info, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(BITMAPINFOHEADER), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, fw);\n \n    &lt;span class=\"hljs-comment\"&gt;//缩放数据&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; X, Y;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *pd;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *ps;\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *new_data &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;((new_Width *&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)* new_Height);\n \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; new_Height; i&amp;#43;&amp;#43;)\n    {\n        Y &amp;#61; i / rate;\n        pd &amp;#61; new_data &amp;#43; i * (new_Width * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n        ps &amp;#61; old_data &amp;#43; Y * (old_Width * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n \n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; new_Width; j&amp;#43;&amp;#43;)\n        {\n            X &amp;#61; j / rate;\n            &lt;span class=\"hljs-built_in\"&gt;memcpy&lt;/span&gt;(pd &amp;#43; j * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, ps &amp;#43; X * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//拷贝数据&lt;/span&gt;\n        }\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;//新文件数据定位&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fseek&lt;/span&gt;(fw, &lt;span class=\"hljs-number\"&gt;54&lt;/span&gt;, SEEK_SET);\n    &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(new_data, (new_Width *&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;&amp;gt;&amp;gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;), new_Height, fw);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;已成功缩放图像\\n&amp;#34;&lt;/span&gt;);\n \n    &lt;span class=\"hljs-comment\"&gt;//关闭fr,fw&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(fr);\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(fw); \n    \n    &lt;span class=\"hljs-comment\"&gt;//释放空间&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(new_data);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(old_data);\n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *argv[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//申明存储图像数据的结构体&lt;/span&gt;\n    BITMAPFILEHEADER old_head;\n    BITMAPINFOHEADER old_info;\n \n    &lt;span class=\"hljs-comment\"&gt;//初始化结构体变量&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(&amp;amp;old_head, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(BITMAPFILEHEADER));\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(&amp;amp;old_info, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(BITMAPINFOHEADER));\n \n    &lt;span class=\"hljs-comment\"&gt;//将缩放比例转化为double类型&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; rate &amp;#61; &lt;span class=\"hljs-built_in\"&gt;atof&lt;/span&gt;(argv[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]) / &lt;span class=\"hljs-number\"&gt;100.0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;zoom&lt;/span&gt;(old_head, old_info, argv[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], argv[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;], rate);\n \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/228109911476164.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["对24位bmp图像实现等比例缩放", ["并保存缩放后的文件，如何修改下列代码", "\n", "\n", "#", "include", " ", "<cstdio>", "\n", "#", "include", " ", "<cstdlib>", "\n", "#", "include", " ", "<cstring>", "\n", "using", " ", "namespace", " std;\n", "#", "pragma", " pack(1)", "//结构体中各成员按1字节对齐", "\n\n", "struct", " ", "BITMAPFILEHEADER", "//定义一个存储头文件数据结构体", "\n{\n    ", "unsigned", " ", "short", " bfType;        ", "// 保存文件类型。'BM'", "\n    ", "unsigned", " ", "long", " bfSize;        ", "//位图文件总字节数", "\n    ", "unsigned", " ", "short", " bfReserved1; ", "//位图文件保留字段，必须为0", "\n    ", "unsigned", " ", "short", " bfReserved2; ", "//位图文件保留字段，必须为0", "\n    ", "unsigned", " ", "long", " bfOffBits;    ", "//RGB数据偏移地址，位图数据起始位置", "\n    };\n\n", "struct", " ", "BITMAPINFOHEADER", "//定义一个存储位图信息的结构体", "\n{\n    ", "unsigned", " ", "long", " biSize;           ", "//本结构占用字节数", "\n    ", "unsigned", " ", "long", " biWidth;           ", "//位图像素宽度", "\n    ", "unsigned", " ", "long", " biHeight;           ", "//位图像素高度", "\n    ", "unsigned", " ", "short", " biPlanes;       ", "// bmp图片的平面数量，为1", "\n    ", "unsigned", " ", "short", " biBitCount;       ", "//每个像素所占的位数", "\n    ", "unsigned", " ", "long", " biCompression;   ", "//位图压缩类型，不压缩(为0)", "\n    ", "unsigned", " ", "long", " biSizeImage;       ", "//位图图像数据所占字节数", "\n    ", "unsigned", " ", "long", " biXPelsPerMeter; ", "//位图水平分辨率，每米像素数", "\n    ", "unsigned", " ", "long", " biYPelsPerMeter; ", "//位图垂直分辨率，每米像素数", "\n    ", "unsigned", " ", "long", " biClrUsed;       ", "//位图实际使用的颜色表中的颜色数", "\n    ", "unsigned", " ", "long", " biClrImportant;  ", "//位图显示过程中重要的颜色数", "\n};\n\n", "//zoom函数用于缩放，BITMAPFILEHEADER head, BITMAPINFOHEADER info为原图像头信息,缩放倍数为2，char字符串类型指针变量", "\n", "void", " ", "zoom", "(BITMAPFILEHEADER head, BITMAPINFOHEADER info, ", "char", " *input, ", "char", " *output, ", "double", " rate)", "\n", "{", "//r：打开文件仅供读取，w:打开文件仅供写入，b：二进制", "\n    FILE *fr = ", "fopen", "(input, ", "\"rb\"", ");\n    FILE *fw = ", "fopen", "(output, ", "\"wb\"", ");\n\n    ", "//若读取不成功", "\n    ", "if", " (fr == ", "NULL", " || fw == ", "NULL", ")\n    {\n        ", "printf", "(", "\"图片错误\\n\"", ");\n        ", "return", ";\n    }\n\n    ", "//读取原图像的头信息", "\n    ", "fread", "(&head, ", "sizeof", "(BITMAPFILEHEADER), ", "1", ", fr);\n    ", "fread", "(&info, ", "sizeof", "(BITMAPINFOHEADER), ", "1", ", fr);\n\n    ", "unsigned", " ", "int", " old_Width = info.biWidth;", "//获取原图像的宽信息", "\n    ", "unsigned", " ", "int", " old_height = info.biHeight;", "//获取原图像的高信息", "\n    ", "unsigned", " ", "char", " *old_data = (", "unsigned", " ", "char", " *)", "malloc", "(old_Width * old_height * ", "3", ");", "//获取原图像的位图数据", "\n\n    ", "////定位到图像数据位置", "\n    ", "fseek", "(fr, ", "54", ", SEEK_SET);\n    ", "fread", "(old_data, old_Width * old_height * ", "3", ", ", "1", ", fr);\n\n    ", "//修改原图像的宽高", "\n    ", "unsigned", " ", "int", " new_Width, new_Height;\n\n    new_Width = (", "int", ")(rate * old_Width);", "//新宽等于倍数乘原宽", "\n    new_Height = (", "int", ")(rate * old_height);", "//新高等于倍数乘原高", "\n", "//修改头信息", "\n    head.bfSize = new_Width * new_Height * ", "3", " + ", "54", ";\n\n    info.biWidth = new_Width;\n    info.biHeight = new_Height;\n\n    ", "//将修改后的头信息写进新图像", "\n    ", "fwrite", "(&head, ", "sizeof", "(BITMAPFILEHEADER), ", "1", ", fw);\n    ", "fwrite", "(&info, ", "sizeof", "(BITMAPINFOHEADER), ", "1", ", fw);\n\n    ", "//缩放数据", "\n    ", "int", " i = ", "0", ", j = ", "0", ";\n    ", "unsigned", " ", "long", " X, Y;\n    ", "unsigned", " ", "char", " *pd;\n    ", "unsigned", " ", "char", " *ps;\n    ", "unsigned", " ", "char", " *new_data = (", "unsigned", " ", "char", " *)", "malloc", "(new_Width * new_Height * ", "3", ");\n\n    ", "for", " (i = ", "0", "; i < new_Height; i++)\n    {\n        Y = i / rate;\n        pd = new_data + i * new_Width * ", "3", ";\n        ps = old_data + Y * old_Width * ", "3", ";\n\n        ", "for", " (j = ", "0", "; j < new_Width; j++)\n        {\n            X = j / rate;\n            ", "memcpy", "(pd + j * ", "3", ", ps + X * ", "3", ", ", "3", ");", "//拷贝数据", "\n        }\n    }\n\n    ", "//新文件数据定位", "\n    ", "fseek", "(fw, ", "54", ", SEEK_SET);\n    ", "fwrite", "(new_data, new_Width * new_Height * ", "3", ", ", "1", ", fw);\n    ", "printf", "(", "\"已成功缩放图像\\n\"", ");\n\n    ", "//释放空间", "\n    ", "free", "(new_data);\n    ", "free", "(old_data);\n\n    ", "//关闭fr,fw", "\n    ", "fclose", "(fr);\n    ", "fclose", "(fw);\n}\n\n", "int", " ", "main", "(", "int", " argc, ", "char", " *argv[])", "\n", "{\n    ", "//申明存储图像数据的结构体", "\n    BITMAPFILEHEADER old_head;\n    BITMAPINFOHEADER old_info;\n\n    ", "//初始化结构体变量", "\n    ", "memset", "(&old_head, ", "0", ", ", "sizeof", "(BITMAPFILEHEADER));\n    ", "memset", "(&old_info, ", "0", ", ", "sizeof", "(BITMAPINFOHEADER));\n\n    ", "//将缩放比例转化为double类型", "\n    ", "double", " rate = ", "atof", "(argv[", "2", "]) / ", "100.0", ";\n    ", "zoom", "(old_head, old_info, argv[", "1", "], argv[", "3", "], rate);\n\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;getimage(&amp;amp;tmp, 0, 0, 100, 100);&lt;br /&gt;这里tmp是个空image&lt;br /&gt;你后续代码都没有用到窗体句柄&amp;#xff0c;哪句代码是从窗体截图呢&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c语言 一个截图小程序 不知道哪里不对", ["我想在魔兽世界的游戏窗口截一个小图，然后放到另一个窗口里，就这么简单的小功能", "\n", "下面代码我写了改，改了写，可怎么着也不行，就是不行", "\n", "运行结果是游戏窗口大小和位置都正确，也新开了一个窗口，但没有截图，就一个空的窗口", "\n", "有人帮忙看看吗？", "\n", "#include <Windows.h>", "#include <stdio.h>", "#include<easyx.h>", "#include<graphics.h>", "\n", "int main()", "{", "    printf(\"现在开始吗？\\n\");", "    system(\"pause\");", "    HWND wow1= FindWindow(NULL, \"魔兽世界\");", "    //获取游戏窗口尺寸", "    RECT rect;                            //定义一个RECT（表示位置和大小的）类型的变量", "    GetWindowRect(wow1, &rect);            //获得窗口尺寸", "    int w = 640;                            //rect.right - rect.left;   尺寸计算：直接写像素数，或者按原大小，最右减最左，最下减最上", "    int h = 480;                            //rect.bottom - rect.top;", "    //移动游戏窗口", "    MoveWindow(wow1, 0, 0, w,h,0);        //把游戏窗口放到指定位置", "\n", "HDC wow1dc = GetDC(wow1);            ", "//", "获取游戏窗口DC\n\n\nIMAGE tmp(", "40", ",", "40", ");                                           ", "//", "定义一个图像数组\ngetimage(&tmp, ", "0", ", ", "0", ", ", "100", ", ", "100", ");                     ", "//", "从     中拿到一个图片\n                                                              ", "//", " loadimage(&tmp,", "35", ",", "35", ",false);\n                                                               ", "//", " initgraph(", "800", ", ", "500", ");\nHWND aaaa= initgraph(", "500", ", ", "500", ", NULL);                ", "//", "打开一个窗口\nHDC tmp_dc = GetDC(aaaa);                                ", "//", "获取此窗口DC\n\nFindWindow(NULL, ", "\"project1\"", ");\nvoid SetWorkingImage();\nBitBlt(tmp_dc, ", "80", ", ", "80", ", ", "50", ", ", "50", ", wow1dc, ", "80", ", ", "80", ", SRCCOPY);              ", "//", "把图片传到此窗口\n\nputimage(", "250", ", ", "250", ", &tmp,SRCCOPY);                         ", "//", "把拿到的图片打印出来\ngetchar();\n\nreturn ", "0", ";\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;head&amp;#61;ptr 这个可以用head &amp;#61; subj&lt;br /&gt;ptr2不可以用subj&amp;#xff0c;因为ptr2只是一个循环变量指针而已&amp;#xff0c;搜索链表尾&amp;#xff0c;然后其next指向subj&lt;br /&gt;第二个中ptr完全是垃圾变量&amp;#xff0c;删掉它&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言下面两个函数中的结构体指针变量ptr有什么作用，直接用subj不可以么？", ["\n", "typedef", " ", "struct", " ", "subjects", "        ", "//定义结构体叫作SUB，在后面就可以直接使用", "\n{\n     ", "int", " num;                 ", "//课程编号", "\n     ", "char", " name[", "30", "];           ", "//课程名称", "\n     ", "char", " kind[", "20", "];           ", "//课程性质", "\n     ", "int", " stime;               ", "//总学时", "\n     ", "int", " ttime;               ", "//授课学时", "\n     ", "int", " etime;               ", "//实验或上机学时", "\n     ", "int", " score;               ", "//学分", "\n     ", "int", " term;                ", "//开课学期", "\n     ", "struct", " ", "subjects", " *next;\n}SUB;\n", "\n", "\nvoid* myInsert(SUB *subj)  ", "//", "链表插入操作  \n{\n    SUB *ptr,*ptr2;\n    ptr=subj;", "//", "要传入的节点\n     ", "if", "(head==NULL)", "//", "头节点为空，说明链表为空链表\n     {\n         head=ptr;", "//", "将头节点设置为要传入的节点\n         head->", "next", "=NULL;", "//", "指针域设为空\n     }\n     ", "else", "//", "链表不为空\n     {\n         ", "for", "(ptr2=head;ptr2;ptr2=ptr2->", "next", ")", "//", "从链表头开始找，找到目前最后一个节点\n        {        \n            ", "if", "(ptr2->", "next", "==NULL)", "//", "若当前ptr2是链表最后一个节点\n             {\n                 ptr2->", "next", "=subj;", "//", "在链表尾增加一个节点subj\n                 subj->", "next", "=NULL;", "//", "将新节点的指针域置为空结束链表\n                 ", "break", ";\n             }\n         }\n     }\n    return head;\n}\n", "\n", "void", " ", "*", "insert", "()", "//插入课程信息 ", "\n{\n     ", "SUB", " ", "*", "ptr", ",", "*", "subj", ";     ", "//定义结构体指针指向这个结构体SUB", "\n     int ", "size", "=", "sizeof", "(", "SUB", ");\n     ", "char", " ", "ch", ",", "ch1", ";\n     ", "while", "(", "ch!", "=", "'", "0", "')\n        {\n              ", "subj", "=", "(", "SUB", " ", "*", ")", "malloc", "(", "size", "); ", "//(分配类型 *)malloc(分配元素个数 *sizeof(分配类型))如果成功，则返回该空间首地址，该空间没有初始化，如果失败，则返回0", "\n              ", "ptr", "=", "subj", ";\n              ", "printf", "(", "\"输入要插入的课程信息:", "\\n", "\"", ");\n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入课程编号:\"", ");\n              ", "scanf", "(", "\"%d\"", ",", "&", "subj", "-", ">", "num", ");   \n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入课程名称:\"", ");\n              ", "scanf", "(", "\"%s\"", ",", "&", "subj", "-", ">", "name", ");  \n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入课程性质:\"", ");\n              ", "scanf", "(", "\"%s\"", ",", "&", "subj", "-", ">", "kind", ");  \n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入总学时:\"", ");\n              ", "scanf", "(", "\"%d\"", ",", "&", "subj", "-", ">", "stime", ");\n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入授课学时:\"", ");\n              ", "scanf", "(", "\"%d\"", ",", "&", "subj", "-", ">", "ttime", ");\n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入实践或上机学时:\"", ");\n              ", "scanf", "(", "\"%d\"", ",", "&", "subj", "-", ">", "etime", ");\n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入学分:\"", ");\n              ", "scanf", "(", "\"%d\"", ",", "&", "subj", "-", ">", "score", ");\n              ", "printf", "(", "\"", "\\n", "\\t", "\\t", "请输入开课学期:\"", ");\n              ", "scanf", "(", "\"%d\"", ",", "&", "subj", "-", ">", "term", ");\n              ", "myInsert", "(", "subj", ");", "//插入课程", "\n              ", "printf", "(", "\"", "\\n", "添加完毕,新信息存入文件中", "\\n", "\"", ");\n              ", "printf", "(", "\"", "\\n", "继续插入请按回车", "\\n", "\"", ");\n              ", "printf", "(", "\"", "\\n", "结束添加课程按 0: [ ]", "\\b", "\\b", "\"", ");\n              ", "ch1", "=", "getchar", "(); ", "//将回车键赋给ch1,否则subj->term输完后输入的回车键会赋给ch,因此用ch1填补。", "\n              ", "ch", "=", "getchar", "();\n        }\n     ", "return", " ", "head", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;若要将AlexNet的三通道调整为一通道&amp;#xff0c;可以在模型定义时修改第一层卷积层的输入通道数。具体地&amp;#xff0c;在&lt;code class=\"language-javascript\"&gt;BuildAlexNet&lt;/code&gt;类中&amp;#xff0c;找到&lt;code class=\"language-javascript\"&gt;self.features&lt;/code&gt;&amp;#xff0c;即AlexNet的特征提取部分&amp;#xff0c;将其中的第一层卷积层从原来的&lt;code class=\"language-javascript\"&gt;nn.Conv2d(3, 64, 11, 4, 2)&lt;/code&gt;修改为&lt;code class=\"language-javascript\"&gt;nn.Conv2d(1, 64, 11, 4, 2)&lt;/code&gt;即可。&lt;/p&gt;\n&lt;p&gt;修改后的&lt;code class=\"language-javascript\"&gt;BuildAlexNet&lt;/code&gt;类代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;BuildAlexNet&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;nn&lt;/span&gt;.&lt;span class=\"hljs-type\"&gt;Module&lt;/span&gt;):\n    def __init__(&lt;span class=\"hljs-title\"&gt;self&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;model_type&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;n_output&lt;/span&gt;):\n        super(&lt;span class=\"hljs-type\"&gt;BuildAlexNet&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;self&lt;/span&gt;).__init__()\n        self.model_type &amp;#61; model_type\n        if model_type &amp;#61;&amp;#61; &amp;#39;pre&amp;#39;:\n            model &amp;#61; models.alexnet(&lt;span class=\"hljs-title\"&gt;weights&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;AlexNet_Weights&lt;/span&gt;.&lt;span class=\"hljs-type\"&gt;DEFAULT&lt;/span&gt;)\n            self.features &amp;#61; model.features\n            fc1 &amp;#61; nn.&lt;span class=\"hljs-type\"&gt;Linear&lt;/span&gt;(9216, 4096)\n            fc1.bias &amp;#61; model.classifier[1].bias\n            fc1.weight &amp;#61; model.classifier[1].weight\n\n            fc2 &amp;#61; nn.&lt;span class=\"hljs-type\"&gt;Linear&lt;/span&gt;(4096, 4096)\n            fc2.bias &amp;#61; model.classifier[4].bias\n            fc2.weight &amp;#61; model.classifier[4].weight\n\n            self.classifier &amp;#61; nn.&lt;span class=\"hljs-type\"&gt;Sequential&lt;/span&gt;(\n                &lt;span class=\"hljs-title\"&gt;nn&lt;/span&gt;.&lt;span class=\"hljs-type\"&gt;Dropout&lt;/span&gt;(),\n                fc1,\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;Dropout&lt;/span&gt;(),\n                fc2,\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;Linear&lt;/span&gt;(4096, &lt;span class=\"hljs-title\"&gt;n_output&lt;/span&gt;))\n        if model_type &amp;#61;&amp;#61; &amp;#39;new&amp;#39;:\n            self.features &amp;#61; nn.&lt;span class=\"hljs-type\"&gt;Sequential&lt;/span&gt;(\n                &lt;span class=\"hljs-title\"&gt;nn&lt;/span&gt;.&lt;span class=\"hljs-type\"&gt;Conv2d&lt;/span&gt;(1, 64, 11, 4, 2), # 修改这一行&amp;#xff0c;将输入通道数从3改为1\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;MaxPool2d&lt;/span&gt;(3, 2, 0),\n                nn.&lt;span class=\"hljs-type\"&gt;Conv2d&lt;/span&gt;(64, 192, 5, 1, 2),\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;MaxPool2d&lt;/span&gt;(3, 2, 0),\n                nn.&lt;span class=\"hljs-type\"&gt;Conv2d&lt;/span&gt;(192, 384, 3, 1, 1),\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;Conv2d&lt;/span&gt;(384, 256, 3, 1, 1),\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;MaxPool2d&lt;/span&gt;(3, 2, 0))\n            self.classifier &amp;#61; nn.&lt;span class=\"hljs-type\"&gt;Sequential&lt;/span&gt;(\n                &lt;span class=\"hljs-title\"&gt;nn&lt;/span&gt;.&lt;span class=\"hljs-type\"&gt;Dropout&lt;/span&gt;(),\n                nn.&lt;span class=\"hljs-type\"&gt;Linear&lt;/span&gt;(9216, 4096),\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;Dropout&lt;/span&gt;(),\n                nn.&lt;span class=\"hljs-type\"&gt;Linear&lt;/span&gt;(4096, 4096),\n                nn.&lt;span class=\"hljs-type\"&gt;ReLU&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;inplace&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-type\"&gt;True&lt;/span&gt;),\n                nn.&lt;span class=\"hljs-type\"&gt;Linear&lt;/span&gt;(4096, &lt;span class=\"hljs-title\"&gt;n_output&lt;/span&gt;))\n\n    def forward(&lt;span class=\"hljs-title\"&gt;self&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;x&lt;/span&gt;):\n        x &amp;#61; self.features(&lt;span class=\"hljs-title\"&gt;x&lt;/span&gt;)\n        x &amp;#61; x.view(&lt;span class=\"hljs-title\"&gt;x&lt;/span&gt;.&lt;span class=\"hljs-title\"&gt;size&lt;/span&gt;(0), -1)\n        out &amp;#61; self.classifier(&lt;span class=\"hljs-title\"&gt;x&lt;/span&gt;)\n        return out&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["如何将三通道改为一通道", ["使用pytorch预训练alexnet网络，如何将三通道调整为一通道", "\n", "from", " torchvision ", "import", " models\n", "from", " torchvision.models ", "import", " AlexNet_Weights\n\n\n\n", "model", " = models.alexnet(weights=", "AlexNet_Weights", ".", "DEFAULT", ")\n", "print", "(model)\n\n", "import", " torch.nn ", "as", " nn  #nn设置网络结构详细参数\n", "from", " torchvision ", "import", " models\n", "#torchvision包，它包括3个子包，分别是： torchvison.datasets ，torchvision.models ，torchvision.transforms ，", "\n", "# # 分别是预定义好的数据集（比如MNIST、CIFAR10等）、预定义好的经典网络结构（比如AlexNet、VGG、ResNet等）", "\n", "# # 和预定义好的数据增强方法（比如Resize、ToTensor等）。", "\n\n", "#模型预训练", "\n", "\n", "class", " ", "BuildAlexNet", "(", "nn", ".", "Module", "):\n    def __init__(", "self", ", ", "model_type", ", ", "n_output", "):\n        super(", "BuildAlexNet", ", ", "self", ").__init__()\n        self.model_type = model_type\n        if model_type == 'pre':        #定义两种model类型，一个直接从alexnet中继承这个参数和结构，定义名称为‘pre’。\n                                       # 另一个是自己设定的网络结构，定义为'new'\n            model = models.alexnet(", "weights", "=", "AlexNet_Weights", ".", "DEFAULT", ")\n            #加载alexnet模型，pretrained为真，则加载网络结构和预训练参数。否则，只加载网络结构[2]\n            self.features = model.features\n            # 因为只要求更改最后的分类数，所以feature类直接从预训练网络中继承classifier类除了要更改的分类层，其他的也从原网络中定义好\n            fc1 = nn.", "Linear", "(9216, 4096)\n            # fc1和fc2继承原网络的classifier参数\n            fc1.bias = model.classifier[1].bias\n            fc1.weight = model.classifier[1].weight\n\n            fc2 = nn.", "Linear", "(4096, 4096)\n            fc2.bias = model.classifier[4].bias\n            fc2.weight = model.classifier[4].weight\n\n            self.classifier = nn.", "Sequential", "(\n            # 定义新的", "classifier", "层，前两层保持不变，底端分类层分类数用", "n_output", "代替\n                ", "nn", ".", "Dropout", "(),\n                fc1,\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "Dropout", "(),\n                fc2,\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "Linear", "(4096, ", "n_output", "))\n            # 或者直接修改为\n        #            model.classifier[6]==nn.", "Linear", "(4096,", "n_output", ")\n        #            self.classifier = model.classifier\n        if model_type == 'new':\n        # 这是自己定义的网络模型（feature,classifier）\n            self.features = nn.", "Sequential", "(\n                #", "nn", ".", "Conv2d", "(3, 64, 11, 4, 2),\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "MaxPool2d", "(3, 2, 0),\n                nn.", "Conv2d", "(64, 192, 5, 1, 2),\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "MaxPool2d", "(3, 2, 0),\n                nn.", "Conv2d", "(192, 384, 3, 1, 1),\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "Conv2d", "(384, 256, 3, 1, 1),\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "MaxPool2d", "(3, 2, 0))\n            self.classifier = nn.", "Sequential", "(\n                ", "nn", ".", "Dropout", "(),\n                nn.", "Linear", "(9216, 4096),\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "Dropout", "(),\n                nn.", "Linear", "(4096, 4096),\n                nn.", "ReLU", "(", "inplace", "=", "True", "),\n                nn.", "Linear", "(4096, ", "n_output", "))\n\n\n\n\n    def forward(", "self", ", ", "x", "):\n        x = self.features(", "x", ")\n        x = x.view(", "x", ".", "size", "(0), -1)\n        out = self.classifier(", "x", ")\n        return out\n\n\n#测试维度是否正确\n\nimport numpy as np           #从这里开始就是验证函数\nfrom torch.autograd import ", "Variable", "\nimport torch\n\nif __name__ == '__main__':\n    model_type = 'pre'\n    n_output = 2\n    alexnet = ", "BuildAlexNet", "(", "model_type", ", ", "n_output", ")            #调用函数buildAlexnet，网络选项是预训练模型，输出是2，也就是分两类\n    model.conv1 = nn.", "Conv2d", "(1, 64, 4, 2)\n    model.conv1.weight = alexnet.conv1.weight[:, 1, :, :]\n    print(", "model", ".", "conv1", ")\n   # print(", "alexnet", ")\n\n    x = np.random.rand(1, 3, 224, 224)            #随机创建一个224*224，通道为3的数组，模拟三通道的图片\n    x = x.astype(", "np", ".", "float32", ")\n    x_ts = torch.from_numpy(", "x", ")                 #转换成torch能用的张量形式\n    x_in = ", "Variable", "(", "x_ts", ")\n    y = alexnet(", "x_in", ")                     #输出结果\n\n\n", "\n", "\n", "尝试过在model_type中添加", "\n", "\n           ", "#w", " = layers", "[0]", ".weight", "\n            ", "#layers", "[0]", " = nn", ".Conv2d", "(", "1", ", ", "64", ", ", "11", ", ", "4", ", ", "2", " )\n            ", "#layers", "[0]", ".weight", " = torch", ".nn", ".Parameter", "(w", "[:, :1, :, :]", ")\n            ", "#torch", ".save", "(alexnet, save_weights)\n", "\n", "仍然报错"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;执行下面语句&amp;#xff0c;将SQL支持远程访问试试&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;update&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;user&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt; host&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;%&amp;#39;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;where&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;user&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;;\nflush &lt;span class=\"hljs-keyword\"&gt;privileges&lt;/span&gt;;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["Mac系统sqlalchemy如何连接mysql数据库", ["Mac系统sqlalchemy如何连接mysql数据库详解", "\n", "创建对象的基类:", "\n", "Base = declarative_base()", "\n", "定义User对象:", "\n", "class User(Base):", "    # 表的名字:", "    ", "tablename", " = 'user'", "\n", "# 表的结构:", "\n", "id", " = Column(String(", "20", "), primary_key=", "True", ")\n", "name", " = Column(String(", "20", "))\n", "\n", "初始化数据库连接:", "\n", "engine = create_engine('mysql+mysqlconnector://root:zhangqi310", "@localhost:3306/test')", "\n", "创建DBSession类型:", "\n", "DBSession = sessionmaker(bind=engine)", "\n", "创建session对象:", "\n", "session = DBSession()", "\n", "创建新User对象:", "\n", "new_user = User(id='5', name='Q')", "\n", "添加到session:", "\n", "session.add(new_user)", "\n", "提交即保存到数据库:", "\n", "session.commit()", "\n", "关闭session:", "\n", "session.close()", "\n", "创建Session:", "\n", "session = DBSession()", "\n", "创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:", "\n", "user = session.query(User).filter(User.id=='5').one()", "\n", "打印类型和对象的name属性:", "\n", "print('type:', type(user))", "print('name:', user.name)", "\n", "关闭Session:", "\n", "session.close()", "\n", "#修改加密方式", "ALTER USER 'root'", "@'localhost' ", "IDENTIFIED WITH mysql_native_password BY 'root'; ", "\n", "NotSupportedError: Authentication plugin 'caching_sha2_password' is not supported以及不知道如何再次修改mysql加密方式，把", "\n", "本人在mac系统中向使用sqlalchemy链接mysql数据库，看遍了网上的教程，使遍了所有方法，依旧存在问题，下面是我使用github上一位博客写的源码进行运转，但是最后报错NotSupportedError: Authentication plugin 'caching_sha2_password' is not supported，随后也是查了很多相关的解决方案，发现需要修改mysql的加密方式，改成native password，但发现进不去mysql数据库了", "\n", "mysqlalchemy连接mysql数据库，本人高二，在计算机方面有些不清楚的不熟练的地方，希望能得到master的解决！Thanks！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;GetElem()&lt;/code&gt;函数里&lt;code class=\"language-javascript\"&gt;while&lt;/code&gt;循环少了花括号&amp;#xff0c;修改如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(p &amp;amp;&amp;amp; j &amp;lt; i)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next;\n    &amp;#43;&amp;#43;j;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code class=\"language-javascript\"&gt;ListDelete()&lt;/code&gt;函数中没必要为q分配一个新节点&amp;#xff0c;把&lt;code class=\"language-javascript\"&gt;LNode* q &amp;#61; new LNode;&lt;/code&gt;改为&lt;code class=\"language-javascript\"&gt;LNode* q;&lt;/code&gt;&lt;br /&gt;同样&lt;code class=\"language-javascript\"&gt;CreateList_R()&lt;/code&gt;函数中&amp;#xff0c;没必要为r分配新节点&amp;#xff0c;直接定义其为指针即可&amp;#xff0c;把&lt;code class=\"language-javascript\"&gt;LNode *r &amp;#61; new LNode;&lt;/code&gt;改为&lt;code class=\"language-javascript\"&gt;LNode *r;&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["按照严慧敏版的《数据结构》里写了一段链表初始化和删除之类的代码想自己实操试试看，但是输出的不是想要的查找结果，而是一个7位数的随机数，用debug也看不出来，如何解决？", ["\n", "就是按照严慧敏版的《数据结构》里写了一段链表初始化和删除之类的代码想自己实操试试看，然后输入都是正常的，就是输出的不是想要的查找结果，而是一个 7 位数的随机数，用 debug 也看不出来。C++的基础比较薄弱，望指教~ ", "\n", "\n", "#include <iostream>", "\n", "#include <stdio.h>", "\n\ntypedef ", "int", " Status; ", "//定义状态函数", "\n\n", "#define ERROR -1", "\n\n", "#define OK 1", "\n\ntypedef ", "enum", " //定义布尔符号\n", "{\n    ", "FALSE", " = ", "0", ",\n    ", "TRUE", " = ", "1", "\n} ", "BOOL", ";\n\ntypedef struct LNode ", "//定义链表", "\n{\n    ", "int", " data;\n    struct LNode *next;\n} LNode, *LinkList;\n\nStatus InitList(LinkList &L) ", "//构建一个空链表", "\n{\n    L = ", "new", " LNode; ", "//new出来的需要用delete指令删除", "\n    L->next = ", "NULL", ";\n    ", "return", " OK;\n}\n\nStatus GetElem(LinkList L, ", "int", " i, ", "int", " &e) ", "//在带头结点的单链表L中根据序号l.获取元素的值，用e返回L中第l.个数据元素的值", "\n{\n    ", "int", " j;\n    LNode *p; ", "//定义LNode类型的p指针才能调用", "\n    p = L->next;\n    j = ", "1", ";\n    ", "while", " (p && j < i)\n        p = p->next;\n    ++j;\n    ", "if", " (!p || j > i)\n        ", "return", " ", "ERROR", ";\n    e = p->data;\n    ", "return", " OK;\n}\n\nLNode *LocateElem(LinkList L, ", "int", " e) ", "//在带头结点的单链表L中查找e元素", "\n{\n    LNode *p;\n    p = L->next; ", "//初始化，p指向首元结点", "\n    ", "while", " (p && p->data != e)\n        p = p->next;\n    ", "return", " p;\n}\n\nStatus ListInsert(LinkList &L, ", "int", " i, ", "int", " e) ", "//在带头结点的单链表L中第i个位置插入数据域为e的新结点", "\n{\n    LNode *p = L;\n    ", "int", " j = ", "0", ";\n    ", "while", " (p && (j < i - ", "1", "))\n    {\n        p = p->next;\n        ++j;\n    }\n    ", "if", " (!p || j > i - ", "1", ")\n        ", "return", " ", "ERROR", ";\n    LNode *s = ", "new", " LNode;\n    s->data = e;\n    s->next = p->next;\n    p->next = s;\n    ", "return", " OK;\n}\n\nStatus ListDelete(LinkList &L, ", "int", " i) ", "//删除第i个元素", "\n{\n    LNode *p = L;\n    LNode *q = ", "new", " LNode;\n    ", "int", " j = ", "0", ";\n    ", "while", " ((p->next) && (j < i - ", "1", "))\n    {\n        p = p->next;\n        ++j;\n    }\n    ", "if", " (!(p->next) || (j > i - ", "1", "))\n        ", "return", " ", "ERROR", ";\n    q = p->next; ", "//临时保存被删结点的地址未来释放，避免内存泄漏", "\n    p->next = q->next;\n    delete q;\n    ", "return", " OK;\n}\n\n", "//创建单链表的方式", "\n\n", "void", " CreateList_H(LinkList &L, ", "int", " n) ", "//前插法创建单链表", "\n{\n    L = ", "new", " LNode;\n    L->next = ", "NULL", ";\n    ", "for", " (", "int", " i = ", "0", "; i < n; ++i)\n    {\n        LNode *p = ", "new", " LNode;  ", "//创建数据新结点", "\n        scanf(", "\"%d\"", ", &p->data); ", "//插入数据", "\n        p->next = L->next;\n        L->next = p;\n    }\n}\n\n", "void", " CreateList_R(LinkList &L, ", "int", " n) ", "//后插法创建单链表", "\n{\n    L = ", "new", " LNode;\n    L->next = ", "NULL", ";\n    LNode *r = ", "new", " LNode;\n    r = L;\n    ", "for", " (", "int", " i = ", "0", "; i < n; ++i)\n    {\n        LNode *p = ", "new", " LNode;\n        scanf(", "\"%d\"", ", &p->data);\n        p->next = ", "NULL", ";\n        r->next = p;\n        r = p;\n    }\n}\n\n\n", "int", " main()\n{\n    printf(", "\"主程序开展：\\n\"", ");\n    LinkList first;\n    printf(", "\"请输入长度为4的数据\\n\"", ");\n    CreateList_H(first, ", "4", ");\n    ", "int", " a, e;\n    printf(", "\"请输入要搜索的项：\\n\"", ");\n    scanf(", "\"%d\"", ", &a);\n    GetElem(first, a, e)；\n    printf(", "\"%d\"", ", e);\n    ", "return", " OK;\n\n}\n\n\n", "\n", "\n", "主程序开展：", "请输入长度为4的数据", "4 3 2 1", "请输入要搜索的项：", "3", "45509436%   ", "\n", "\n", "我感觉就是初始化都没有成功，因为曾经尝试用", "\n", "if", "(GetElem(", "first", ", a, e)==OK)\n    {\n        ", "printf", "(", "\"查找成功！！！\\n\"", ");\n        ", "printf", "(", "\"%d\"", ", e);\n        ", "return", " OK;\n    }\n    ", "else", "\n    {\n        ", "printf", "(", "\"查找错误！！！\\n\"", ");\n        ", "return", " ERROR;\n    }\n\n", "\n", "返回的就是“查找错误！”，", "但是我也不清楚是哪个代码初始化失败了。因为我是跨专业考试自学的，没有同学可以问。已经困扰我一个春节了，感谢各位！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;栈空才是匹配&amp;#xff0c;修改如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXSIZE 1024&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//顺序栈的定义&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; elemtype;&lt;span class=\"hljs-comment\"&gt;//elemtype可为任意类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;SequenStack&lt;/span&gt;\n{\n    elemtype data[MAXSIZE];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; top;\n} SequenStack;\n\n&lt;span class=\"hljs-comment\"&gt;//顺序栈初始化&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;SequenStack *&lt;span class=\"hljs-title\"&gt;Init_SequenStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    SequenStack *S;&lt;span class=\"hljs-comment\"&gt;//定义顺序栈指针变量&lt;/span&gt;\n    S&amp;#61;(SequenStack *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;*&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(SequenStack));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(S&amp;#61;&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; S;\n    }\n    S-&amp;gt;top&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; S;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//判栈空&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Em_SequenStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SequenStack *S)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(S-&amp;gt;top&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//入栈&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Push_SequenStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SequenStack *S,elemtype x)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//插入新的元素作为新的栈顶&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(S-&amp;gt;top&amp;gt;&amp;#61;MAXSIZE&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    S-&amp;gt;top&amp;#43;&amp;#43;;&lt;span class=\"hljs-comment\"&gt;//栈顶指针&amp;#43;1&lt;/span&gt;\n    S-&amp;gt;data[S-&amp;gt;top]&amp;#61;x;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//出栈&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Pop_SequenStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SequenStack *S,elemtype *x)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//*x为整型指针&amp;#xff0c;删除S的栈顶元素&amp;#xff0c;并通过x返回其值&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(S-&amp;gt;top&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        S-&amp;gt;top--;\n        *x&amp;#61;S-&amp;gt;data[S-&amp;gt;top&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//取栈顶数据元素&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Get_SequenStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SequenStack *S,elemtype *x)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(S-&amp;gt;top&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        *x&amp;#61;S-&amp;gt;data[S-&amp;gt;top];\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;match&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SequenStack *S,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str)&lt;/span&gt;\n&lt;/span&gt;{\n    S&amp;#61;&lt;span class=\"hljs-built_in\"&gt;Init_SequenStack&lt;/span&gt;();\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,e;&lt;span class=\"hljs-comment\"&gt;//e用来接收栈顶&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(str[i]!&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(str[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;Push_SequenStack&lt;/span&gt;(S,str[i]);\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(str[i]&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;Em_SequenStack&lt;/span&gt;(S))\n            {\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//不匹配&lt;/span&gt;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;Pop_SequenStack&lt;/span&gt;(S,&amp;amp;e);\n            }\n        }\n        i&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; h&amp;#61;&lt;span class=\"hljs-built_in\"&gt;Em_SequenStack&lt;/span&gt;(S);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(h&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    SequenStack *S;\n    S&amp;#61; &lt;span class=\"hljs-built_in\"&gt;Init_SequenStack&lt;/span&gt;(S);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[MAXSIZE];\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一串字符以#结尾&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,str);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; h&amp;#61;&lt;span class=\"hljs-built_in\"&gt;match&lt;/span&gt;(S,str);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(h&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;不匹配&amp;#xff01;&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;匹配&amp;#xff01;&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["数据结构-用栈来实现括号匹配", ["题目是要求以#结尾，可是我不知道是哪里出错了，可不可以帮指点指点？", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include <stdio.h>", "#include <stdlib.h>", "#include<string.h>", "#define MAXSIZE 1024", "\n", "//顺序栈的定义", "typedef int elemtype;//elemtype可为任意类型", "typedef struct SequenStack", "{", "    elemtype data[MAXSIZE];", "    int top;", "}SequenStack;", "\n", "//顺序栈初始化", "SequenStack *Init_SequenStack()", "{", "    SequenStack *S;//定义顺序栈指针变量", "    S=(SequenStack *)malloc(sizeof(SequenStack));", "    if(S==NULL)", "    {", "        return S;", "    }", "    S->top=-1;", "    return S;", "}", "\n", "//判栈空", "int Em_SequenStack(SequenStack *S)", "{", "    if(S->top==-1)", "    {", "        return 1;", "    }", "    else", "    {", "        return 0;", "    }", "}", "\n", "//入栈", "int Push_SequenStack(SequenStack *S,elemtype x)//插入新的元素作为新的栈顶", "{", "    if(S->top>=MAXSIZE-1)", "    {", "        return 0;", "    }", "    S->top++;//栈顶指针+1", "    S->data[S->top]=x;", "    return 1;", "}", "\n", "//出栈", "int Pop_SequenStack(SequenStack *S,elemtype *x)//*x为整型指针，删除S的栈顶元素，并通过x返回其值", "{", "    if(S->top==-1)", "    {", "        return 0;", "    }", "    else", "    {", "        S->top--;", "        *x=S->data[S->top+1];", "        return 1;", "    }", "}", "\n", "//取栈顶数据元素", "int Get_SequenStack(SequenStack *S,elemtype *x)", "{", "    if(S->top==-1)", "    {", "        return 0;", "    }", "    else", "    {", "        *x=S->data[S->top];", "        return 1;", "    }", "}", "\n", "int match(SequenStack *S,char *str)", "{", "    S=Init_SequenStack();", "    int i=0,e;//e用来接收栈顶", "    while(str[i]!='#')", "    {", "        if(str[i]=='(')", "        {", "            Push_SequenStack(S,str[i]);", "        }", "        else if(str[i]==')')", "        {", "            if(Em_SequenStack(S))", "            {", "                return 0;//不匹配", "            }", "            else", "            {", "                Pop_SequenStack(S,&e);", "            }", "\n", "    }\n    i++;\n}\nint h=Em_SequenStack(S);\n", "if", "(h==", "1", ")\n{\n    ", "return", " ", "0", ";\n}\n", "else", "\n{\n    ", "return", " ", "1", ";\n}\n", "\n", "}", "\n", "int main()", "{", "    SequenStack S;", "    char str[MAXSIZE];", "    printf(\"请输入一串字符以#结尾：\");", "    scanf(\"%s\",str);", "    int h=match(&S,str);", "    if(h==0)", "    {", "        printf(\"不匹配！\");", "    }", "    else", "    {", "        printf(\"匹配！\");", "    }", "    return 0;", "\n", "}", "\n", "运行结果及报错内容", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "像这种代码可以说可维护性太差\r\n一定要用多态，这也太多if else了\r\n\r\n可以搞个命令模式，把view,和action封装成一个对象\r\nclass Command{\r\nString view;\r\nString action;\r\n...\r\n}\r\n\r\n\r\n\r\n服务器端controller增加方法可为：\r\nprocessRequest(Command c)\r\n用这个方法处理\r\n\r\nif(view.equals(\"insert\")){\r\n  if(\"insertProjectMes\".equals(action)){\r\n  }\r\n  if(\"insertPictures\".equals(action)){\r\n  }\r\n  ...\r\n}\r\nelse if(view.equals(\"update\")){\r\n  ...\r\n}\r\nelse if(view.equals(\"select\")){\r\n  ...\r\n}\r\nelse if(view.equals(\"delete\")){\r\n  ...\r\n}\r\n\r\n\r\n\r\n\r\n对了，每一个view，action值对都应该有对应的一个类，\r\n比如：\r\nInsertProjectMesAction,InsertPicturesAction,后面的同理\r\n它们实现一个接口Action\r\n\r\npublic interface Action\r\n{\r\n processAction( 要用到的参数);\r\n\r\n}\r\n\r\nMap&lt;Command,Action&gt; map = ....\r\n\r\n\r\ncontroller通过Map&lt;Command,Action&gt; map对象管理Action类，并在客户提交的时候根据传过来的每一对view，action参数构建一个Command，然后调用相应的业务处理类。", "Konwledge_Point": "定义新的类型", "Question": ["一年半之前的疑问，再问一遍，基础的", ["缘起：07年8月进公司发现公司的控制页面跳转和功能执行方式如下，", "\njsp页面存放两个隐藏参数：", "\n1）view：决定处理类型；", "\n2）action：决定处理方式：", "\n3）服务器端controller代码结构：", "\n[code=\"java\"]", "\nif(view.equals(\"insert\")){", "\n  if(\"insertProjectMes\".equals(action)){", "\n  }", "\n  if(\"insertPictures\".equals(action)){", "\n  }", "\n  ...", "\n}", "\nelse if(view.equals(\"update\")){", "\n  ...", "\n}", "\nelse if(view.equals(\"select\")){", "\n  ...", "\n}", "\nelse if(view.equals(\"delete\")){", "\n  ...", "\n}", "\n[/code]", "\n\n", "每个controller十几个if,else也是家常便饭，多的时候几十个，而且业务经常新增，看到03年一直被修改过来的代码也是经常的事。", "\n\n", "辞职在家进修学习，又想这个问题：请问怎么去除这些if else呢？", "\n\n", "个人想法（spring）：", "\n1)在spring上下文中配置一个jsp,和controller,和一个action参数", "\n2)在jsp中放置参数，值在第一次访问jsp的时候被spring注入；", "\n3）controller中", "\na)定义四个接口，对应操作类型：有参数无返回，无参数无返回，有参数有返回，有参数无返回；", "\npublic interface Do1 {", "\n Object doing();//无参数有返回", "\n}", "\npublic interface Do2 {", "\nvoid doing();//无返回无参数", "\n}", "\npublic interface Do3 {", "\nvoid doing(Object o);//无返回有参数", "\n}", "\npublic interface Do4 {", "\nObject doing(Object o);//有返回有参数", "\n}", "\n\n", "b）业务处理类，以action的值命名，实现上面某个接口,controller的内部类实现并存入map对象", "\n\n", "c）controller通过map对象管理处理类，并在客户提交的时候根据传过来的action参数反射调用相应的业务处理类。", "\n\n", "似乎就是一个状态模式。好处就是每个人需要添加的时候只要在后面添加新的内部类，并把自己加入map就行。", "\n\n", "请问怎么去除这些if else呢？ 谢谢"]], "Tag": "程序设计"}
{"Answer": "scanf不能读取string型的变量，string型的是c++特有的，只是因为c++能和c兼容所以能用scanf但是scanf的功能还是没有变", "Konwledge_Point": "定义新的类型", "Question": ["C++字符串问题，char type[10]跟string type 有什么区别？", ["这是在刘汝佳的书上的一道例题，我做的时候遇到了一个问题，我是新手，请指点。", "\n#include", "\nusing namespace std;", "\nint m,n;", "\nint a[100000+10];", "\nint main(){", "\n    int shift_circular_left(int,int);", "\n    int shift_circular_right(int,int);", "\n    int find(int);", "\n    cin>>m>>n;", "\n    for(int i=1;i<=m;++i){", "\n        a[i]=i;", "\n    }", "char type[10];", "           //在这一行定义的时候为什么用string type会错？", "\n    int x,y,p,q;", "\n    for(int i=0;i\n        scanf(\"%s%d%d\",type,&x,&y);", "\n        p=find(x);", "\n        q=find(y);", "\n        if(type[0]=='A'){", "\n            if(q>p)shift_circular_left(p,q-1);", "\n            else shift_circular_right(p,q);", "\n        }", "\n        else{", "\n            if(p<q)shift_circular_left(p,q);", "\n            else shift_circular_right(q+1,p);", "\n        }", "\n    }", "\n    for(int i=1;i<=m;++i){", "\n        cout<<a[i]<<' ';", "\n    }", "\n    return 0;", "\n}", "\n\n", "int shift_circular_left(int x,int y){", "\n    int t=a[x];", "\n    for(int i=x;i<=y-1;++i){", "\n        a[i]=a[i+1];", "\n    }", "\n    a[y]=t;", "\n}", "\n\n", "int shift_circular_right(int x,int y){", "\n    int t=a[y];", "\n    for(int i=y;i>=x+1;--i){", "\n        a[i]=a[i-1];", "\n    }", "\n    a[x]=t;", "\n}", "\n\n", "int find(int x){", "\n    for(int i=0;i<=m;++i){", "\n        if(a[i]==x)return i;", "\n    }", "\n}", "\n在定义type的时候，为什么必须用字符数组，不能用字符串类型？"]], "Tag": "程序设计"}
{"Answer": "debug只能跟住一条线程的 我以前碰到过类似的毛病 当多线程的时候 它只能跟住一条   仔细看看你的程序部分实质上是否和多线程有关", "Konwledge_Point": "定义新的类型", "Question": ["eclipse不能调试了", ["我用的eclipse开始好好的，但是后来调试就不稳定了，调试hibernate+spring的时候只能从ac = new FileSystemXmlApplicationContext(\"/WebRoot/WEB-INF/applicationContext.xml\");这列开始调试，而且不能跳跃的调试，不能F8到另一个断点，按了F8就一路跑到底了。只能一步一步的调啊。郁闷死了，开始dao层还可以测试，但是到了Service层，有了事物管理，根本没法调了。把eclipse卸了重装，反复几次，还弄了另一个eclipse过来，还是不行，都是这个样子。但是调普通的Java类这些功能都好好的，难道eclipse不能调试spring+hibernate？在网上搜的时候也看见有人遇到和我相同的问题，但是他们也没解决方案？不会是要重装系统在重装eclipse吧？？？ :x ", "\n[b]问题补充：[/b]", "\n一楼说的都试过了。还是不行。", "\n[b]问题补充：[/b]", "\n :cry: 问题是现在急着做项目啊。都弄的我半天才能调一个bug，还是用System.out.println（）调的。都米人知道了么？", "\n[b]问题补充：[/b]", "\n  大家说的方法都试了，最后实在不行，只能拿出MyEclipse了，JDK还是1.6的，哎，终于可以调试了，那叫一个爽啊。我现在是开发用eclipse，调试用MyEclipse。呵呵。不知道是不是wocsok老兄说的多线程问题，但是MyEclipse是可以的。", "\n  还有spring的事物加了之后老是遇到一些莫名其妙的问题，去掉事物代理运行成功，但是一加事物代理，则莫名其妙的异常了。举个例子给大家吧，不知道有人遇到类似问题没？如果嵌套超过一层，那我的save方法就变成update了（当然我传的实体是带ID的，但是单独测save还是save，就是不能嵌套），还有在事务中查出来的实体不让我改ID，改了就异常，郁闷。把事物配置发出来看看。", "\n\n", "<!-- 定义事务拦截器 -->\n <bean id=\"transactionInterceptor\"\n      class=\"org.springframework.transaction.interceptor.TransactionInterceptor\">\n    <!-- 注入事务管理 -->\n    <property name=\"transactionManager\" ref=\"transactionManager\"/>\n    <property name=\"transactionAttributes\">\n        <!-- 定义事务传播属性 -->\n       <props>\n          <prop key=\"update*\">PROPAGATION_REQUIRED</prop>\n          <prop key=\"delete*\">PROPAGATION_REQUIRED</prop>\n          <prop key=\"save*\">PROPAGATION_REQUIRED</prop>\n          <prop key=\"add*\">PROPAGATION_REQUIRED</prop>\n       </props>\n    </property>\n </bean>\n<!-- 定义BeanNameAutoProxyCreator-->\n<bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\n    <!--  指定对满足哪些bean name的bean自动生成业务代理 -->\n    <property name=\"beanNames\">\n        <!--  下面是所有需要自动创建事务代理的bean-->\n        <list>\n            <value>*Service</value>\n        </list>\n        <!--  此处可增加其他需要自动创建事务代理的bean-->\n    </property>\n    <!--  下面定义BeanNameAutoProxyCreator所需的事务拦截器-->\n    <property name=\"interceptorNames\">\n        <list>\n            <!-- 此处可增加其他新的Interceptor -->\n            <value>transactionInterceptor</value> \n        </list>\n    </property>     \n</bean>\n", "\n\n", "[b]问题补充：[/b]", "\n  呵呵，有几位兄台没看清我的说明哦，我开始已经说了，重装过eclipse。而且换了其他好的eclipse重装。都没用。算了，不能调试我就用MyEclipse。", "\n  至于595755330提出的问题我觉得spring和hibernate不调试的话怎么知道里面在怎么运行？我的事物配置并没有错，今天用MyEclipse调试的时候终于发现为什么我的save方法变update了，在hibernate的save方法里面会根据是否有事物层层调用，当走到StatefulPersisitentContext()时，会根据它的entityEntyies属性得到当前event的entry，而entityEntyies是IdentityMap类型，里面存着有id的实体和无id实体的映射，最后save的时候是根据映射关系返回entry中的id。所以我的save变update了。看了映射关系是根据内存地址映射的，没办法啊，因为我是复制数据，所以只能先查出实体，再将属性值赋给一个新变量，在save新变量。很麻烦啊，因为我一次要复制很多数据，不知道哪位兄弟遇到类似的问题了，一起交流下吧。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;前面代码没有将L-&amp;gt;next设置为NULL导致的&lt;br /&gt;create函数中&lt;br /&gt;LNode* s &amp;#61; (LNode*)malloc(sizeof(LNode));&lt;br /&gt;这里没有s-&amp;gt;next &amp;#61; NULL;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["引发了异常，读取访问权限冲突", ["就输出单链表出现了这个从来没见过的错误，网上找的方法都没啥用", "#include <stdlib.h>", "#include ", "using namespace std;", "typedef int ElemType;", "typedef struct LNode", "   /", "结点类型定义", "/", "{    ElemType data;", "struct LNode* next;", "}LNode, * LinkList;", " /* LinkList为结构指针类型*/", "void  InitList(LinkList& L)", "{    L = new LNode;", "    L->next = NULL;", "}//尾插法创建单链表中数据元素", "void CreateList(LinkList& L, int n){", "    LinkList r = L;    cout<<\"输入链表中的数据元素: \"<< endl;", "    for (int i = 1; i <= n; i++)", "    {        LNode* s = (LNode*)malloc(sizeof(LNode));", "int k;", "    cin >> k;", "    s->data = k;", "        r->next = s;", "    r = s;", "   }", "}", "void printList(LinkList L)", "{    LinkList p;", "        p = L->next;", "    cout << \"输出链表中的数据元素:\" << endl;", "        while (p!=NULL)", "    {", "        cout << p->data ;", "            p = p->next;", "    }", "}", "//单链表中按值查找数据元素", "LinkList LocationElem(LinkList L, ElemType e){", "    LinkList p = L->next;", " // p指向第一个结点", "    while (p && p->data != e)", "    p = p->next;", "    return p;", "  }", "int  ListInsert(LinkList& L, int i, ElemType e)", "{    LinkList p = L, s;", "    int j = 0;", "        while (p && j < i - 1)", "    {", "        j++;", "           p = p->next;", "    }", "     if (!p || j > i - 1) return 0;", "    s = new LNode;", "        s->data = e;// 使新结点数据域的值为 e", "      s->next = p->next;// 将新结点插入到单链表 L 中", "   p->next = s;// 修改第 i-1 个结点指针", "    return 1;", "}", "int ListDelete(LinkList& L, int i, ElemType& e)", "{    LinkList p = L, q;", "    int j = 0;", "        while (p->next != NULL && j < i - 1)", "{", "        p = p->next;", "        ++j;", "    }", "    if (p->next == NULL || j > i - 1)", "         return 0; // 删除位置不合理", "        q = p->next; // 用指针 q 指向被删除结点", "            p->next = q->next;// 删除第 i 个结点", "            e = q->data;// 取出第 i 个结点数据域值", "            free(q);// 释放第 i 个结点", "          return 1;", "}", "void ListLength(LinkList L)", "{    LinkList p;", "    int j = 0;", "    p = L->next;", "    while (L->next)", "{", "        j++;", "               L = L->next;    }", "        cout<<\"单链表表长是:\\n\"<<j<<endl;", "}", "还有什么别的错误也请指出"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;pNew-&amp;gt;name[100]&amp;#61; name[i]; pNew-&amp;gt;sex[10] &amp;#61;sex[i];是不对的&amp;#xff0c;要用字符串复制&lt;br /&gt;strcpy(pNew-&amp;gt;name,name);&lt;br /&gt;strcpy(pNew-&amp;gt;sex,sex);&lt;br /&gt;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&lt;br /&gt;输入语句也是错的&amp;#xff0c;改为&lt;br /&gt;for (i&amp;#61;0; i&amp;lt;ret; &amp;#43;&amp;#43;i)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;printf(&amp;#34;请输入第%d个学生信息\\n&amp;#34;,i&amp;#43;1);&lt;br /&gt;printf(&amp;#34;名字&amp;#xff1a;\\n&amp;#34;);&lt;br /&gt;scanf(&amp;#34;%s&amp;#34;,name);&lt;br /&gt;ah&amp;#61;getchar();&lt;br /&gt;printf(&amp;#34;性别(男/女)&amp;#xff1a;\\n&amp;#34;);&lt;br /&gt;scanf(&amp;#34;%s&amp;#34;,sex);&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["为什么给链表节点里的数组成员赋值不了呢", ["struct student {", "char name[100];//名字", "char sex[10];//性别", "int age;//年龄", "float A;//平时分", "float B;//考试分", "float C;//总分（A", "0.5+b", "0.5）", "struct student * pNext;//指针域", "};", "这个是定义的一个结构体", "struct student * pHead=NULL; //初始化头指针", "pHead = create_list(); //create_list()功能：创建一个非循环单链表，并将该链表的头结点的地址付给pHead", "进入函数", "struct student * create_list(void){", "char name[100];//名字", "char sex[10];//性别", "struct student * pHead = (struct student *)malloc(sizeof(struct student));// 给头指针分配头结点", "下面是赋值的手段（虽然赋值数组不行，但对int/float这些数字类型就能成功赋值）", "for (i=0; i<ret; ++i)", "{", "printf(\"请输入第%d个学生信息\\n\",i+1);", "printf(\"名字：\\n\");", "scanf(\"%s\",&name[i]);", "ah=getchar();", "printf(\"性别(男/女)：\\n\");", "scanf(\"%s\",&sex[i]);", "}", "struct student * pNew = (struct student *)malloc(sizeof(struct student)); //创造一个新空间，pNew指向它", "pNew->name[100]= name[i]; pNew->sex[10] =sex[i];", "这种情况输出是很奇怪的字", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if(!0)    exit(OVERFLOW);&lt;br /&gt;这是什麽鬼&amp;#xff1f;自杀性攻击吗&amp;#xff1f;这肯定就退出了程序啊&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["devc编译成功运行时界面没有结果", ["求指教，代码完全比着", "\n", "\n\n\n```敲的，没有出现错误，但是运行不出结果，就出现这个界面，一碰就退出\n\n", "#include<stdio.h>", "\n", "#include<stdlib.h>  //malloc", "\n", "#include<math.h>  //OVERFLOW", "\n\n\n", "#define LIST_INIT_SIZE  100  //初始化最大空间 ", "\n", "#define LISTINCREMENT    10  //增量", "\n", "#define OK      1", "\n", "#define ERROR   0", "\n\n\n", "//", "讨论的int   \ntypedef int ElemType;   ", "//", "数据元素类型 \ntypedef int Status;     ", "//", "函数的返回值状态 \n\n", "//", "顺序表类型定义\ntypedef  struct\n{\n    ElemType *elem;  ", "//", "顺序表的起始地址\n    int length;      ", "//", "元素个数\n    int listsize;    ", "//", " 当前容量大小 \n}SqList;\n\n", "//", "---------------相关操作-----------------\n", "//", "初始化操作\nStatus  ListInt_Sq(SqList &L)  ", "//", "输入型  输出型\n{\n    ", "//", "1", "：申请空间malloc\n    L.elem=(ElemType *)malloc(LIST_INIT_SIZE*sizeof(ElemType));\n    ", "if", "(!", "0", ")    ", "exit", "(OVERFLOW);\n    ", "//", "2", ": length \n    L.length=", "0", ";\n    ", "//", "3", ": 设定当前容量大小\n    L.listsize= LIST_INIT_SIZE;\n    \n    return  OK;\n } \n\n\n", "//", "插入操作 \n", "//", "1", "：含义 \n", "//", "2", "：算法思想 \nStatus ListInsert_Sq(SqList &L,int i,ElemType e)\n{\n    ElemType *mewbase;\n    int n=L.length;\n    int j;\n    ", "//i", "的合法性\n    ", "if", "(i<", "1", " || i>n+", "1", " ) return ERROR;\n    ", "//", "满的情况\n    ", "if", "(n>=L.listsize)\n    {\n        ", "//", "重新申请空间 realloc\n        mewbase=(ElemType*)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType));\n        ", "if", "(!mewbase)    ", "exit", "(OVERFLOW);\n        ", "//", "将新地址赋值给L.elem \n        L.elem=mewbase;\n        ", "//", "设定当前容量大小 \n        L.listsize+=LISTINCREMENT;    \n    }    \n    ", "//", "元素移动\n    ", "for", "(j=n-", "1", ";j>=i-", "1", ";j--)\n    {\n        ", "//", "指针[下标] \n        ", "//", "把[j]的元素后移一个位置[j+", "1", "] \n        L.elem[j+", "1", "]=L.elem[j];\n    }\n    ", "//", "放元素\n    L.elem[i-", "1", "]=e;\n    ", "//", "表长加", "1", "\n    L.length++; \n    \n    return OK;\n    }\n\nStatus ListDelete_Sq(SqList &L,int i,ElemType &e)\n{\n    int n=L.length;\n    int j;\n    ", "//", "1", ":删除位置i的合法范围[", "1", ",n]\n    ", "if", "(i<", "1", "||i>n)  return  ERROR;\n    ", "//", "2", "：保留删除元素\n    e=L.elem[i-", "1", "];\n    ", "//", "3", "：从第i+", "1", "个位置开始，直到an,都往前移动一格位置\n    ", "for", "(j=i;j<=n-", "1", ";j++)\n    {\n        ", "//", "把[j]元素往前移动一个位置（[j-", "1", "]）\n        L.elem[j-", "1", "]=L.elem[j] ;\n    }\n    ", "//", "4", "：表长减一 \n    L.length--;\n    \n    return OK;\n}\n\nint main()\n{\n    SqList L;  ", "//", "定义顺序表L\n    ElemType e;", "//", "定义元素类型的变量 \n    ", "//", "建表\n    ListInt_Sq(L) ;  ", "//", "函数调用\n    ", "//", "在第一个位置插入一个元素", "10", "\n    printf(", "\"在第一个位置插入一个元素10\\n\"", ") ;\n    ListInsert_Sq(L,", "1", ",", "10", ");\n    printf(", "\"在第2个位置插入一个元素20\\n\"", ") ;\n    ListInsert_Sq(L,", "2", ",", "20", ");\n    printf(", "\"在第3个位置插入一个元素30\\n\"", ") ;\n    ListInsert_Sq(L,", "3", ",", "30", ");\n    \n    printf(", "\"[1]:%d\"", ",L.elem[", "1", "]);\n    printf(", "\"长度：%d\\n\"", ",L.length);\n    printf(", "\"删除第二个位置的元素：%d\\n\"", ");\n    ListDelete_Sq(L,", "2", ",e);\n    printf(", "\"%d\"", ",e) ;\n    printf(", "\"长度：%d\\n\"", ",L.length);\n    \n     \n    \n    return ", "0", ";\n}\n![img](https:", "//img", "-mid.csdnimg.cn", "/release/", "static", "/image/mi", "d", "/ask/", "952845528236195", ".png ", "\"=600 #left\"", ")\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你现在遇到什么问题呢&amp;#xff0c;请具体说明啊&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["R语言缺失值处理实例分析_社会指标调查数据2018", ["缺失值处理实例分析", "本例中的数据是纽约市家庭的社会指标电话调查数据，每两年由哥伦比亚大学社会工作学院组织进行的。请进行如下步骤的数据分析工作：", "1.数据准备及数据预处理", "（1）将数据siswave.csv读入R后命名为wave，使用attach(wave)函数激活该数据集。", "（2）生成名为earnings的新变量列（要求：单位是$1000，原始数据单位是$），表示家庭总收入，它是由rearn(响应者收入)和tearn（响应者配偶收入）两部分加起来生成的。注意要将rearn和tearn中的负数分配为NA后再求和。统计earnings变量的缺失百分比。", "（3）生成名为white的新变量列，若race of respondent（1=white, 2=black, 3=hispanic(nonblack), 4=other）是1则white=1，否则white均为0。考虑如果race变量有缺失的情况，若缺失则white也为0。（这个步骤就是一个训练数据处理的步骤，如果原数据中有white覆盖掉即可）", "（4）生成名为male的新变量列，男性male=1，女性male=0。依据是wave中的变量列sex:  male是1, female是2。", "（5）生成名为over65的新变量列，年龄超过65则over65=1，否则over65=0。依据是wave中的年龄变量r_age。", "（6）将变量immig中的缺失值均用0插补。immig=0表示是美国公民, immig=1 则不是美国公民。", "（7）educ_r表示不同的教育水平。如果是NA，用2.5替换。1至4表示不同的教育水平，依次增高。", "（8）分别基于变量ssi，welfare，charity，生成名为any.ssi，any.welfare，any.charity的变量，将正值赋值为1，其他负值或缺失值都赋值为0。", "ssi: supplemental security Income for entire family", "welfare: public assistance for entire family", "charity: income received from charity for entire family", "-9: 响应者拒绝回答是否有此来源收入；", "-5：响应者有此项收入但没提供收入数目", "    2.缺失模式探索（Exploration of Missing pattern）", "（1）基于原始数据wave，生成一个新的数据框，命名为sis.sm，它依次包括sex, race, edu_r, r_age, earnings, police。给这些不同列合适的类型，比如sex, race, police都设置成因子型(factor)。edu_r设置为有序的因子。", "（2）判断其中的变量earnings是否是MCAR", "（3）查看数据sis.sm的缺失模式，可视化该数据的缺失状况。", "（4）如果观测中的缺失变量个数百分比超过30%，则删除这个缺失观测。统计数据sis.sm删除了多少观测，保留多少观测。", "\n", "3.简单随机插补（simple random imputation）", "    简单随机插补是从存在缺失的变量的已有观测值中随机抽取一个值来插补缺失值。本小题的任务是定义一个名为random.impute的R函数，该函数可以对变量进行随机插补后返回具有完整观测的变量列。然后使用该函数对变量earnings进行简单随机插补。", "\n", "4.回归插补（Using regression predictions to perform deterministic imputation）", "（1）生成新变量earnings.top，将收入earnings超过$100,000的修改为$100,000。目的是避免收入特别高的观测值影响回归结果，有些收入甚至上百万美元。", "（2）生成新变量workhrs.top，将工作小时数workhrs中每周超过40小时的设置为40小时。虽然有些响应者确实工作时间会超过40小时，这样简单的变换可能提高回归模型的预测性能，避免极端值的影响。", "（3）生成一个数据框名为SIS，包含变量列earnings，earnings.top，male，over65，white，immig，educ_r，workmos，workhrs.top，any.ssi，any.welfare，any.charity.", "（4）以earnings中的非零且非缺失观测值为被解释变量，建立一个回归模型，解释变量是male，over65，white，immig，educ_r，workmos，workhrs.top，any.ssi，any.welfare，any.charity.将earnings中的缺失值使用该模型的预测值进行插补。", "\n", " ", "5.", "随机回归插补（", "Random", " regression imputation）：对earnings中的缺失值进行插补，通过在上一步回归模型的预测值中增加误差可以将不确定性添加到插补值。\n                                                                         \n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;帮你改了改&amp;#xff01;这样结构其实不一样了呢&amp;#xff01;你看看如何变成你的风格吧&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; new(x) (x*)malloc(sizeof (x))&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;/*\n   项目设计3&amp;#xff1a;排队管理系统&amp;#xff08;模拟程序&amp;#xff09;&amp;#xff1a;\n   */&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;name&lt;/span&gt;{            &lt;span class=\"hljs-comment\"&gt;//声明一个结构体&amp;#xff0c;用来存放排队者的姓名 &lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; username[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];        &lt;span class=\"hljs-comment\"&gt;//排队者姓名类型是字符串&amp;#xff0c;长度30 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;name&lt;/span&gt; * next;    &lt;span class=\"hljs-comment\"&gt;// *next指针变量指向下一个节点 &lt;/span&gt;\n}Name,*pName;\n&lt;span class=\"hljs-comment\"&gt;/*初始化排队者(函数)*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;pName &lt;span class=\"hljs-title\"&gt;create&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{    &lt;span class=\"hljs-comment\"&gt;//这个函数返回一个指向链表头的指针 &amp;#xff0c;实际上就是返回create的值&amp;#xff0c;就是链表中第一个节点的起始地址 &lt;/span&gt;\n    pName head, p1, p2;    &lt;span class=\"hljs-comment\"&gt;//创建头指针和分别用于开辟和绑定新节点的p1 p2&lt;/span&gt;\n    head&amp;#61;p1&amp;#61;p2&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; check[&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;];\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请在下方输入排队者的姓名&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;){    &lt;span class=\"hljs-comment\"&gt;//开始循环 &lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, check); \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(check,&lt;span class=\"hljs-string\"&gt;&amp;#34;ok&amp;#34;&lt;/span&gt;)!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){        &lt;span class=\"hljs-comment\"&gt;//如果输入的不是&amp;#34;ok&amp;#34;&lt;/span&gt;\n            p1&amp;#61;&lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt;(Name);\n            &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(p1-&amp;gt;username,check);    &lt;span class=\"hljs-comment\"&gt;//让p1指向新的节点值 &lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(head&amp;#61;&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n                head&amp;#61;p1;    &lt;span class=\"hljs-comment\"&gt;//将p1的值赋给头指针&amp;#xff0c;象征新节点被纳入链表  (这个新节点的值可以是&amp;#34;ok&amp;#34;&amp;#xff0c;但是这个节点肯定不会被纳入链表---&amp;gt;)&lt;/span&gt;\n                p2&amp;#61;head;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{    &lt;span class=\"hljs-comment\"&gt;//这个情况是下边出现紧跟排队者情况的处理 &lt;/span&gt;\n                p2-&amp;gt;next&amp;#61;p1;\n                p2&amp;#61;p2-&amp;gt;next;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;\n} \n\n&lt;span class=\"hljs-comment\"&gt;/*打印排队者人数和姓名&amp;#xff08;函数&amp;#xff09;*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pName head)&lt;/span&gt;&lt;/span&gt;{    &lt;span class=\"hljs-comment\"&gt;//函数参数为结构体头指针 &lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(head!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){    &lt;span class=\"hljs-comment\"&gt;//头指针不为空 &lt;/span&gt;\n        n&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s &amp;#34;&lt;/span&gt;,head-&amp;gt;username);    &lt;span class=\"hljs-comment\"&gt;//输出指针指向的节点的值&amp;#xff08;姓名&amp;#xff09; &lt;/span&gt;\n        head&amp;#61;head-&amp;gt;next;    &lt;span class=\"hljs-comment\"&gt;//指针移动 指向下一个节点 &lt;/span&gt;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;当前队列人数&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;,n);\n} \n\n&lt;span class=\"hljs-comment\"&gt;/*队首排队者出队&amp;#xff08;函数&amp;#xff09;*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;pName &lt;span class=\"hljs-title\"&gt;del&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pName head)&lt;/span&gt;&lt;/span&gt;{\n    pName p;    &lt;span class=\"hljs-comment\"&gt;//创建p指针&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(head&amp;#61;&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;队列空闲无人\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;(head);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;此人已被移除队列: %s\\n&amp;#34;&lt;/span&gt;, head-&amp;gt;username);\n    p&amp;#61;head;    &lt;span class=\"hljs-comment\"&gt;//让p指针指向头指针指向的第一个节点 &lt;/span&gt;\n    head&amp;#61;head-&amp;gt;next;    &lt;span class=\"hljs-comment\"&gt;//头指针原本指向的节点里的next指针成员将自己指向的下一个节点的地址告诉自己&amp;#xff0c;然后指他去了 &lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(p);    &lt;span class=\"hljs-comment\"&gt;//第一个节点现在只被p指针指着了&amp;#xff0c;free(p),释放掉他 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;(head); \n}\n\n&lt;span class=\"hljs-comment\"&gt;/*退出模拟系统&amp;#xff08;函数&amp;#xff09;*/&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//这个函数用来清空链表&amp;#xff0c;并对应主函数switch中的语句结束整个程序 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;pName &lt;span class=\"hljs-title\"&gt;exit_system&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pName head)&lt;/span&gt;&lt;/span&gt;{\n    pName p0;    &lt;span class=\"hljs-comment\"&gt;//和上一个队首者出队原理一样 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(head!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n        p0&amp;#61;head;    \n        head&amp;#61;head-&amp;gt;next;\n        &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(p0);    &lt;span class=\"hljs-comment\"&gt;//这三个语句&amp;#xff0c;头指针去找下一个&amp;#xff0c;p0指针释放原来的节点&amp;#xff0c;释放完了再去跟头指针&amp;#xff0c;最终释放全部的链表节点 &lt;/span&gt;\n    }&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;(head);\n} \n\n&lt;span class=\"hljs-comment\"&gt;/*新的排队者加入队列&amp;#xff08;函数&amp;#xff09; 就是在链表最后再加入一个节点  */&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;pName &lt;span class=\"hljs-title\"&gt;add&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pName head)&lt;/span&gt;&lt;/span&gt;{    &lt;span class=\"hljs-comment\"&gt;//参数有头指针和用于指向主函数用来接收新节点值的指针 &lt;/span&gt;\n    pName insert&amp;#61;&lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt;(Name);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;要进入的人&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, insert-&amp;gt;username);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(head&amp;#61;&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n        head&amp;#61;insert;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; head;\n    }\n    pName p&amp;#61;head;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(head-&amp;gt;next!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n        head&amp;#61;head-&amp;gt;next;\n    }\n    head-&amp;gt;next&amp;#61;insert;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; p;\n}\n\n&lt;span class=\"hljs-comment\"&gt;/*主函数*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{\n    pName head&amp;#61;&lt;span class=\"hljs-built_in\"&gt;create&lt;/span&gt;(); \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; 1录入新的排队者&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; 2查看队列人数和信息&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; 3队首者出队&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; 4退出: &amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;a);\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(a){\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n                head&amp;#61;&lt;span class=\"hljs-built_in\"&gt;add&lt;/span&gt;(head);\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;; \n\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n                &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(head);\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n                head&amp;#61;&lt;span class=\"hljs-built_in\"&gt;del&lt;/span&gt;(head);\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n                head&amp;#61;&lt;span class=\"hljs-built_in\"&gt;exit_system&lt;/span&gt;(head);\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;: &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;参数错误&amp;#xff01;请重新选择功能&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        } \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;){\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    } \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["链表的插入函数，调用的时候从第二次开始会覆盖值，求改", ["题目：", "排队管理模拟", "    用程序实现模拟人的排队方式的一个的管理模型。适合于比如买餐，买票，或者是防疫出入校门和公共场所等场景的排队问题。", "设计任务要求：", "1)可以随时随机输入任意人名，比如Tom, Jerray, Jack, Sam等。有输入的人名，按回车键，则会立刻被程序安排进入排队机排队。并且显示出当前排队剩余多少人。", "2)队首排队的人轮候结束需要出队时。当任意时候输入“出队”（或者Dequeue），立刻从队首取出一个人名输出到屏幕上，并且显示出当前还剩余有多少人在排队。", "3)队列有容量限制，如果队列满（OVERFLOW），比如最多允许100人等候。则需要提示“当前排队人数已满”或“队列溢出”。", "\n", "题目的要求我稍微做了修改，没有完全符合题目的逻辑，只实现其中的功能。", "下边是代码，可以拿走跑一下。", "问题就是插入第一次是可以插到最后的，但是再次插入就会覆盖掉刚才的值。", "懵了，求解。。。", "\n", "#include<stdio.h>", "\n", "#include<stdlib.h>", "\n", "#include<string.h>", "\n", "#include<math.h>", "\n", "#include<malloc.h>", "\n", "#define LEN sizeof(struct name)    //将LEN定义结构体类型长度 ", "\n\n/*\n项目设计", "3", "：排队管理系统（模拟程序）：\n \n*/\n\n\ntypedef struct name{            ", "//", "声明一个结构体，用来存放排队者的姓名 \n    char username[", "30", "];        ", "//", "排队者姓名类型是字符串，长度", "30", " \n    struct name *", "next", ";    ", "//", " *", "next", "指针变量指向下一个节点 \n}Name,*NAME;\n\nint n=", "0", ";    ", "//", "正儿八经全局变量，本文件中各个函数均可使用，代表排队的人数 \n\n", "/*初始化排队者(函数)*/", "\nstruct name *creat(void){    ", "//", "这个函数返回一个指向链表头的指针 ，实际上就是返回creat的值，就是链表中第一个节点的起始地址 \n    struct name *head,*p1,*p2;    ", "//", "创建头指针和分别用于开辟和绑定新节点的p1 p2\n    char check[", "30", "];\n    p1=p2=(struct name * ) malloc(LEN);    ", "//", "开辟新的节点，实际上是开辟一个长度为LEN(自定义结构体)的内存区 \n    printf(", "\"请在下方输入排队者的姓名：\\n\\n\"", ");\n    gets(check); \n    ", "if", "(strcmp(check,", "\"ok\"", ")!=", "0", "){        ", "//", "如果输入的不是", "\"ok\"", "\n        strcpy(p1->username,check);    ", "//", "让p1指向新的节点值 \n        head=NULL;    ", "//", "先使头指针值为空，表示链表中没有节点 （节点还没有被纳入链表），纳入链表工作在下边的循环体 \n        ", "while", "(", "1", "){    ", "//", "开始循环 \n            n+=", "1", ";    ", "//", "n的值从", "0", "变为 ", "1", "，象征链表出现第一个节点 ;n的值增加，代表排队的人数 \n            ", "if", "(n==", "1", "){\n                head=p1;    ", "//", "将p1的值赋给头指针，象征新节点被纳入链表  (这个新节点的值可以是", "\"ok\"", "，但是这个节点肯定不会被纳入链表--->)\n            }\n            ", "else", "{    ", "//", "这个情况是下边出现紧跟排队者情况的处理 \n                p2->", "next", "=p1;    /*此时的p1是下边的情况，已经指向了第二个节点值，让p1把自己指向的地址给此时还在指向第一个节点的p2的\n                                 ", "next", "成员*/ \n                p2=p1;    ", "//", "再让p2也去指向p1指向的第二个节点，就完成了一二节点的绑定，链表形成了 \n            }\n            ", "//", "printf(", "\"请在下方输入排队者的姓名：\\n\\n\"", ");\n            gets(check);\n            ", "if", "(strcmp(check,", "\"ok\"", ")==", "0", "){\n                ", "break", ";    ", "//", "如果输入的是", "\"ok\"", "则跳出循环，录入工作完成 --->\n            }", "else", "{\n                p1=(struct name *)malloc(LEN);    ", "//", "如果还不是ok，开辟第二个的节点 \n                strcpy(p1->username,check);    ", "//", "让p1指向第二个节点值 \n            }\n        }p2->", "next", "=NULL;    ", "//", "<---（承接第", "34", "行注释）所以p2就不用指向这个新节点，链表收尾 \n        return(head);    ", "//", "对应第", "22", "行代码意义 返回链表中第一个节点的起始地址 \n    }", "else", "{\n        return ", "0", ";    ", "//", "如果没有任何的新节点加入，返回空值 \n    }\n} \n\n\n", "/*打印排队者人数和姓名（函数）*/", "\nvoid print(struct name *head){    ", "//", "函数参数为结构体头指针 \n    struct name *p;\n    ", "if", "(head!=NULL){    ", "//", "头指针不为空 \n        p=head;    ", "//", "让指针p跟随头指针找到第一个节点 \n        printf(", "\"\\n\\n\\t当前队列人数：%d\\n\\n\"", ",n);\n        ", "do", "{\n            printf(", "\"%s\\t\"", ",p->username);    ", "//", "输出指针指向的节点的值（姓名） \n            p=p->", "next", ";    ", "//", "指针移动 指向下一个节点 \n        }", "while", "(p!=NULL);{    ", "//", "当指针p为空时，就是移动指向了 链表初始化结束最后一个节点后边的那个p1指向的无意义的节点 \n            printf(", "\"\\n\\n\\n---------------------\\n\\n\\n\"", ");\n        }\n    }", "else", " printf(", "\"\\n\\t队列空闲无人\\n\"", ");    ", "//", "如果头指针是空的，说明根本不存在链表，象征不存在的队列 \n} \n\n\n", "/*队首排队者出队（函数）*/", "\nstruct name *del(struct name *head){\n    struct name *p;    ", "//", "创建p指针\n    ", "if", "(head==NULL){\n        printf(", "\"\\n\\t队列空闲无人\\n\"", ");\n        return(head);\n    }\n    p=head;    ", "//", "让p指针指向头指针指向的第一个节点 \n    head=head->", "next", ";    ", "//", "头指针原本指向的节点里的", "next", "指针成员将自己指向的下一个节点的地址告诉自己，然后指他去了 \n    free(p);    ", "//", "第一个节点现在只被p指针指着了，free(p),释放掉他 \n    printf(", "\"==此人已被移除队列==\\n\"", ");\n    return(head); \n\n}\n\n\n", "/*退出模拟系统（函数）*/", "\n", "//", "这个函数用来清空链表，并对应主函数switch中的语句结束整个程序 \nstruct name *", "exit", "(struct name *head){\n    struct name *p0;    ", "//", "和上一个队首者出队原理一样 \n    ", "while", "(head!=NULL){\n        p0=head;    \n        head=head->", "next", ";\n        free(p0);    ", "//", "这三个语句，头指针去找下一个，p0指针释放原来的节点，释放完了再去跟头指针，最终释放全部的链表节点 \n    }return(head);\n} \n\n\n", "/*新的排队者加入队列（函数） 就是在链表最后再加入一个节点  */", "\nstruct name *add(struct name *head,struct name *insert){    ", "//", "参数有头指针和用于指向主函数用来接收新节点值的指针 \n    \n    struct name *p0,*p1,*p2;    ", "//", "在基础上新增额外的p0指针用于指引新加入的节点 \n    p0=(struct name *)malloc(LEN);    ", "//", "给p0开辟长度为LEN（就是自定义结构体的长度）的内存区 \n    p1=head;    ", "//", "头指针传值给p1指针,让p1指向头节点 \n    p0=insert;    ", "//", "p0指向主函数里键入的新节点的值 \n    ", "if", "(head==NULL){    ", "//", "如果头指针为空，说明链表为空，不存在 \n        head=p0;    ", "//", "p0指向的新节点赋给头指针 \n        p0->", "next", "=NULL;    ", "//", "让p0指针指向的节点的", "next", "成员的值为空，不在链入新的节点，链表收尾 \n    }", "else", "{    ", "//", "头指针不为空的话，说明链表存在 \n        \n        ", "while", "(p1->", "next", "!=NULL){\n            p2=p1;\n            p1=p1->", "next", ";\n        } \n        p1->", "next", "=p0;\n        p0->", "next", "=NULL;\n    }\n    n+=", "1", ";\n    return (head);\n    \n}\n\n\n", "/*主函数*/", "\nint main(void){\n    struct name *head=NULL,message;\n    char a[", "10", "];\n\n    head=creat(); \n    printf(", "\"\\n\\n\"", ");\n    ", "while", "(", "1", "){\n        printf(", "\"\\n\\n\\n\\n\"", ");\n        printf(", "\"================================\\n\\n\"", ");\n        printf(", "\" 录入新的排队者-------------- 1 \\n\"", ");\n        printf(", "\" 查看队列人数和信息---------- 2 \\n\"", ");\n        printf(", "\" 队首者出队------------------ 3 \\n\"", ");\n        printf(", "\" 退出------------------------ 4 \\n\\n\"", ");\n        printf(", "\"================================\\n\"", ");\n        printf(", "\"  请输入一个序号来进行以上操作：\"", ");\n        gets(a);\n        switch(*a){\n            case ", "'1'", ":{\n                printf(", "\"要进入的人：\"", ");\n                gets(message.username);\n                ", "//", "scanf(", "\"%s\"", ",&message.username);\n                head=add(head,&message);\n                ", "break", "; \n            }\n            case ", "'2'", ":{\n                print(head);\n                ", "break", ";\n            }\n            case ", "'3'", ":{\n                head=del(head);\n                n=n-", "1", ";    ", "//", "出队一个，排队中人数-", "1", " \n                ", "break", ";\n            }\n            case ", "'4'", ":{\n                head=", "exit", "(head);\n                ", "break", ";\n            }\n            default: printf(", "\"参数错误！请重新选择功能\"", ");", "break", ";\n        }", "if", "(strcmp(a,", "\"4\"", ")==", "0", ") ", "break", "; \n    } \n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;题主&amp;#xff0c;建议您使用OpenCV来做图片反相处理&lt;br /&gt;关于WIN平台安装配置OpenCV开发环境&amp;#xff0c;可以参考之前写的这篇博客&lt;br /&gt;&lt;a href=\"https://chexl.blog.csdn.net/article/details/126574011\" id=\"textarea_1663924150266_1663924606994_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;Win10&amp;#43;OpenCV4.6.0之开发环境&amp;#xff08;VS2022&amp;#xff09;配置入门_来灵的博客-CSDN博客&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;如何使用OpenCV做图片反相处理&amp;#xff0c;刚我做了测试&amp;#xff0c;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;  &lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;opencv2/core/core.hpp&amp;gt;&lt;/span&gt;  &lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;opencv2/highgui/highgui.hpp&amp;gt;&lt;/span&gt;  &lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; cv;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Mat src;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; height, width;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j;\n    src &amp;#61; &lt;span class=\"hljs-built_in\"&gt;imread&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;test.jpg&amp;#34;&lt;/span&gt;);                &lt;span class=\"hljs-comment\"&gt;//载入图片&lt;/span&gt;\n    height &amp;#61; src.rows;                       &lt;span class=\"hljs-comment\"&gt;//获取图像信息&lt;/span&gt;\n    width &amp;#61; src.cols * src.&lt;span class=\"hljs-built_in\"&gt;channels&lt;/span&gt;();       &lt;span class=\"hljs-comment\"&gt;// 列项要乘通道数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;namedWindow&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;src&amp;#34;&lt;/span&gt;, WINDOW_AUTOSIZE);     &lt;span class=\"hljs-comment\"&gt;//创建窗口&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;namedWindow&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;dst&amp;#34;&lt;/span&gt;, WINDOW_AUTOSIZE);\n    &lt;span class=\"hljs-built_in\"&gt;imshow&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;src&amp;#34;&lt;/span&gt;, src);                       &lt;span class=\"hljs-comment\"&gt;//显示原图&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//图像反转&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; height; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; width; j&amp;#43;&amp;#43;)\n        {\n            src.&lt;span class=\"hljs-built_in\"&gt;at&lt;/span&gt;&amp;lt;uchar&amp;gt;(i, j) &amp;#61; &lt;span class=\"hljs-number\"&gt;255&lt;/span&gt; - src.&lt;span class=\"hljs-built_in\"&gt;at&lt;/span&gt;&amp;lt;uchar&amp;gt;(i, j);   &lt;span class=\"hljs-comment\"&gt;// 每一个像素反转&lt;/span&gt;\n        }\n    }\n    cv::&lt;span class=\"hljs-built_in\"&gt;imwrite&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;output.jpg&amp;#34;&lt;/span&gt;, src);              &lt;span class=\"hljs-comment\"&gt;//保存反色后的图片&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;imshow&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;dst&amp;#34;&lt;/span&gt;, src);                       &lt;span class=\"hljs-comment\"&gt;//显示反相图片&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;waitKey&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行效果截图&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/962165429366122.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c语言图像反色无法打开给出的图片", ["问题遇到的现象和发生背景", "\n", "        用c语言实现图像的反色，能够实现图像的打开，写入，但是进行图像反色的时候，就会导致输出的图像无法打开，而如果仅仅打开图片，然后将这个图片的二进制数据取出来保存写入另一个图片文件中，是可以打开新生成的这个文件的，相当于复制了一遍，但是一旦进行图像反色处理：", "r", "=255-l，进行这个计算之后再把二进制数据写入之后，新生成的图片文件就打不开了\n", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n\n", "#", "define", "    height    500", "\n", "#", "define", "    width    1500", "\n", "typedef", " ", "unsigned", " ", "char", "  BYTE;    ", "// 定义BYTE类型，占1个字节", "\n\n", "int", " ", "main", "()", "\n", "{\n    FILE *fp = ", "NULL", ";\n\n    BYTE B[height][width];\n    BYTE *ptr;\n\n    ", "char", " path[", "256", "];\n    ", "char", " outpath[", "256", "];\n\n    ", "int", " i,j;\n\n    ", "// 输入源路径并打开raw图像文件", "\n    ", "printf", "(", "\"Input the raw image path: \"", ");\n    ", "scanf", "(", "\"%s\"", ",path);\n    ", "if", "((fp = ", "fopen", "( path, ", "\"rb\"", " )) == ", "NULL", ")\n    {\n        ", "printf", "(", "\"can not open the raw image \"", " );\n        ", "return", ";\n    }\n    ", "else", "\n    {\n        ", "printf", "(", "\"read OK\"", ");\n    }\n\n    ", "// 分配内存并将图像读到二维数组中", "\n    ptr = (BYTE*)", "malloc", "( width * height * ", "sizeof", "(BYTE) );\n    ", "for", "( i = ", "0", "; i < height; i++ )\n    {\n        ", "for", "( j = ", "0", "; j < width ; j ++ )\n        {\n            ", "fread", "( ptr, ", "1", ", ", "1", ", fp );\n            B[i][j]= *ptr;    ", "// 把图像输入到2维数组中,变成矩阵型式", "\n            ", "//printf(\"%d  \",B[i][j]);", "\n            ptr++;\n        }\n    }\n    ", "fclose", "(fp);\n\n\n     ", "printf", "(", "\"\\n \"", ");\n     ", "printf", "(", "\"\\n \"", ");\n     ", "printf", "(", "\"\\n \"", ");\n     ", "printf", "(", "\"\\n \"", ");\n     ", "printf", "(", "\"\\n \"", ");\n\n\n    ", "// 这里可以对二维数组中的图像数据进行处理", "\n\n\n    ", "for", " (i = ", "0", "; i < height; i++)\n    {\n        ", "for", " (j = ", "0", "; j < width; j++)\n        {\n            B[i][j] = ", "255", "-  B[i][j] ;  ", "// 图像反相", "\n            ", "//printf(\"%d  \",B[i][j]);", "\n        }\n    }\n\n    ", "// 将处理后的图像数据输出至文件", "\n    ", "printf", "(", "\"Input the raw_image path for save: \"", ");\n    ", "scanf", "(", "\"%s\"", ",outpath);\n    ", "if", "( ( fp = ", "fopen", "( outpath, ", "\"wb\"", " ) ) == ", "NULL", " )\n    {\n        ", "printf", "(", "\"can not create the raw_image : %s\\n\"", ", outpath );\n        ", "return", ";\n    }\n\n    ", "for", "( i = ", "0", "; i < height; i++ )\n    {\n        ", "for", "( j = ", "0", "; j < width ; j ++ )\n        {\n            ", "fwrite", "( &B[i][j], ", "1", " , ", "1", ", fp );\n        }\n    }\n    ", "fclose", "(fp);\n\n}\n\n\n\n", "\n", "运行结果及报错内容", "\n", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我认为我从图片中读出数据和写入数据过程没有问题，疑问就是为什么用255减去二进制数据后，得到的所有数据都在0-255以内，为什么用这些数据写入图片中，无法得到反色图片，甚至根本无法打开图片"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这种程序报错建议你debug逐步调试代码&amp;#xff0c;自己跟着代码捋一遍。看看每一步走到哪个分支了。&lt;/p&gt;\n&lt;p&gt;首先你这个is_full函数就有问题&amp;#xff0c;只返回满true不返回不满false&amp;#xff1b;&lt;br /&gt;再就是你main主函数中首先调用删除函数delete_arr(&amp;amp;arr, 1, &amp;amp;val);   然后又if (delete_arr(&amp;amp;arr, 1, &amp;amp;val))判断了它&amp;#xff0c;相当于删除两次&amp;#xff0c;这样会导致内存出现问题&amp;#xff0c;从而删除失败&amp;#xff0c;往后内存异常退出吧。改为bool rnt &amp;#61; delete_arr(&amp;amp;arr, 1, &amp;amp;val);  if(rnt){}。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["功能函数，判断数组是否为空，运行失败", ["include<stdlib.h>", "\n", "include<stdio.h>", "\n", "include<malloc.h>", "\n", "include<stdbool.h>     //包含bool类型， 也含有ture,false", "\n", "struct Arr           // 定义一个数据类型，含有三个成员", "{", "    int* pBase;       // 存储的是数组的第一个元素的地址（数组的位置）", "    int len;           // 数组所能容纳的最大元素的个数（数组的最大长度）", "    int cnt;           // 当前数组有效元素的个数（数组中元素个数）", "};", "\n", "//分号不能省", "void init_arr(struct Arr* parr, int length);        //初始化数组", "bool append_arr(struct Arr* pArr, int val);         // 追加(给一个数组添加新的元素，按顺序排列)", "bool insert_arr(struct Arr* pArr, int pos, int val);  //该函数用于向数组中间插入元素，pos的值从1开始（pos代表数组中某元素的位置，方便后续插入新的元素）", "bool delete_arr(struct Arr* pArr, int pos, int* pVal);    //该函数用于删除数组中的某元素", "int get();", "bool is_empty(struct Arr* pArr);", "bool is_full(struct Arr* pArr);", "void sort_arr(struct Arr* pArr);", "void show_arr(struct Arr* pArr);", "void inverse_arr(struct Arr* pArr);", "\n", "//该函数用于测试，主要是测试追加函数的功能", "int main(void)", "{", "    struct Arr arr;", "\n", "int", " ", "val", ";          ", "//定义一个int型，用于后面删除元素", "\n\ninit", "_arr(&", "arr", ", 6)", ";        ", "//初始化结构变量arr中的数组", "\nshow", "_arr(&", "arr", ")", ";          ", "//打印", "\n\nappend", "_arr(&", "arr", ", 1)", ";     ", "//追加", "\nappend", "_arr(&", "arr", ", 2)", ";\n\nappend", "_arr(&", "arr", ", 3)", ";\nappend", "_arr(&", "arr", ", 4)", ";\ndelete", "_arr(&", "arr", ", 1, &", "val", ")", ";      ", "//删除", "\n", "if", " (delete", "_arr(&", "arr", ", 1, &", "val", ")", ")\n{\n    printf(", "\"删除成功！\\n\"", ");\n    printf(", "\"您删除的元素是： %d\\n\"", ", ", "val", ");\n}\n", "else", "\n{\n    printf(", "\"删除失败！\\n\"", ");\n}\n", "/*    show_arr(&arr);\n    append_arr(&arr, 2);\n    append_arr(&arr, 3);\n    append_arr(&arr, 4);\n    append_arr(&arr, 5);\n    append_arr(&arr, 6);\n    append_arr(&arr, 7);*/", "\n\n", "if", " (append", "_arr(&", "arr", ", 8)", ")\n{\n    printf(", "\"追加成功\\n\"", ");\n}\n", "else", "\n{\n    printf(", "\"追加失败！\\n\"", ");\n}\nshow", "_arr(&", "arr", ")", ";\nreturn ", "0", ";\n", "\n", "}", "\n", "//初始化数组的定义", "void init_arr(struct Arr* pArr, int length)", "{", "    pArr->pBase = (int*)malloc(sizeof(int) * length);           //分配空间", "    if (NULL == pArr->pBase)                       //判断是否分配空间成功", "    {", "        printf(\"动态内存分配失败！\\n\");", "        exit(-1);        //终止整个程序", "    }", "    else", "    {", "        pArr->len = length;              //初始化结构变量中的成员 len , cnt", "        pArr->cnt = 0;", "    }", "    return;", "\n", "}", "\n", "//判断结构变量中的数组（pArr->cnt）是否为空，返回bool型变量", "bool is_empty(struct Arr* pArr)", "{", "    if (0 == pArr->cnt)", "        return true;", "    else", "        return false;", "\n", "}", "\n", "//打印结构体变量中的数组", "void show_arr(struct Arr* pArr)   //传入结构体变量的地址", "{", "    if (is_empty(pArr))           //pArr即为结构体变量的地址", "        printf(\"数组为空！\\n\");", "    else", "    {", "        for (int i = 0; i < pArr->cnt; ++i)", "            printf(\"%d \", pArr->pBase[i]);  //int*", "        printf(\"\\n\");", "    }", "}", "\n", "//追加（向数组添加新的元素，顺序添加），并返回bool型，追加成功返回true", "bool append_arr(struct Arr* pArr, int val)", "{", "    if (is_full(pArr))   //数组已满时返回false", "        return false;", "    else {", "        pArr->pBase[pArr->cnt] = val;     //不满时追加新元素", "        (pArr->cnt)++;", "        return true;", "    }", "\n", "}", "\n", "//判断数组是否已满", "bool is_full(struct Arr* pArr)", "{", "    if (pArr->cnt == pArr->len)", "        return true;", "}", "\n", "//插入新的元素，并返回bool型", "bool insert_arr(struct Arr* pArr, int pos, int val)", "{", "    int i;", "    if (pos<1 || pos>pArr->cnt + 1)               //插入位置不正确时返回false , 并终止", "        return false;", "    for (i = pArr->cnt - 1; i >= pos - 1; --i);      //将pos位置的每个数据后移一个单位", "    {", "        pArr->pBase[i + 1] = pArr->pBase[i];", "    }", "    pArr->pBase[pos - 1] = val;            //将要插入的值赋值到插入位置", "    (pArr->cnt)++;                   //元素个数加一", "    return true;", "}", "\n", "//删除元素", "bool delete_arr(struct Arr* pArr, int pos, int* pVal)", "{", "    if (is_empty(pArr))", "        return false;", "    if (pos<1 || pos>pArr->cnt)", "        return false;", "\n", "*", "pVal", " = pArr->", "pBase[pos - ", "1", "];\n", "for", " (int i = pos; i < pArr->", "cnt; i++)\n{\n    ", "pArr", "->", "pBase", "[i - 1] = pArr->", "pBase[i];\n\n}\n(", "pArr", "->", "cnt)--;\nreturn ", "true", ";\n", "\n", "}", "\n", "//倒序(最后两个函数你好像不用看)", "void inverse_arr(struct Arr* pArr)", "{", "    int i = 0;", "    int j = pArr->cnt - 1;", "    int t;", "\n", "while", " (i < j)\n{\n    ", "t", " = pArr->", "pBase[i];\n    ", "pArr", "->", "pBase", "[i] = pArr->", "pBase[j];\n    ", "pArr", "->", "pBase[j] = t;\n    ++i;\n    --j;\n}\nreturn;\n", "\n", "}", "\n", "//排序", "void sort_arr(struct Arr* pArr)", "{", "    int i, j;", "    for (i = 0; i < pArr->cnt; ++i)", "    {", "        for (j = i + 1; j < pArr->cnt; ++j)", "        {", "            if (pArr->pBase[i] > pArr->pBase[j])", "            {", "                int t = pArr->pBase[i];", "                pArr->pBase[i] = pArr->pBase[j];", "                pArr->pBase[j] = t;", "            }", "        }", "    }", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Book new;&lt;br /&gt;new不能用来作为变量名&amp;#xff0c;因为new是动态分配空间的关键字&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["基于顺序存储结构的图书信息表的新图书的入库__运行错误", ["\n", "根据这个题目，在下面的begin到end的代码块有什么语法错误吗，为啥有报错？没系统学过c++,实在找不出来了。", "\n", "#", "include", "<iostream>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", "<iomanip>", "\n", "#", "define", " OK 1", "\n", "#", "define", " ERROR 0", "\n", "#", "define", " OVERFLOW -2", "\n", "#", "define", " MAXSIZE 1000    ", "//图书表可能达到的最大长度", "\n", "using", " ", "namespace", " std;\n", "typedef", " ", "struct", "\n{", "//图书信息定义", "\n    ", "char", " no[", "20", "];    ", "//图书ISBN", "\n    ", "char", " name[", "50", "];   ", "//图书名字", "\n    ", "float", " price;   ", "//图书价格", "\n}Book;\n", "typedef", " ", "struct", "\n{", "//图书表的顺序存储结构类型为SqList", "\n    Book *elem;                   ", "//存储空间的基地址", "\n    ", "int", " length;                   ", "//图书表中当前图书个数", "\n}SqList;\n", "int", " ", "InitList_Sq", "(SqList &L)", "\n", "{", "//构造一个空的顺序表L", "\n    L.elem=", "new", " Book[MAXSIZE];     ", "//为顺序表分配一个大小为MAXSIZE的数组空间", "\n    ", "if", "(!L.elem)", "exit", "(OVERFLOW);    ", "//存储分配失败退出", "\n    L.length=", "0", ";                   ", "//空表长度为0", "\n    ", "return", " OK;\n}\n", "int", " ", "Input_Sq", "(SqList &L)", "\n", "{", "//顺序表的输入", "\n    ", "int", " n;\n    cin>>n;    ", "//图书数目n", "\n    ", "for", "(", "int", " i=", "0", ";i<n;i++)\n    {\n        cin>>L.elem[i].no>>L.elem[i].name>>L.elem[i].price;\n        L.length++;\n    }\n    ", "return", " OK;\n}\n", "int", " ", "Insert_Sq", "(SqList &L)", "\n", "{", "//新图书的入库和输出.", "\n", "/**************begin************/", "\n", "int", " n;\nBook ", "new", ";\ncin>>n;\ncin>>", "new", ".no>>", "new", ".name>>", "new", ".price;\n", "if", "(n<", "1", "||n>L.length)\n{cout<<", "\"抱歉，入库位置非法！\"", "<<endl;\n\n", "return", " ", "0", ";\n}\n", "int", " m=L.length；\n", "while", "(m>=n)\n    L.elem[m]=L.elem[m", "-1", "];\n     m--;\n}\n\nL.elem[n", "-1", "]=", "new", ";\n", "for", "( ", "int", " i=", "0", ";i<=L.length;i++)\n{\n    cout<<L.elem[i].no<<", "\" \"", "<<L.elem[i].name<<", "\" \"", "<<fixed<<", "setprecision", "(", "2", ")<<L.elem[i].price<<endl;\n}\n", "return", " OK;\n\n\n    ", "/**************end************/", "\n}\n", "int", " ", "main", "()", "\n", "{\n    SqList L;           ", "//定义一个SqList类型的变量L", "\n    ", "InitList_Sq", "(L);     ", "//初始化一个空的顺序表L", "\n    ", "Input_Sq", "(L);        ", "//输入数据", "\n    ", "Insert_Sq", "(L);    ", "//新图书的入库和输出", "\n    ", "return", " ", "0", ";\n}\n\n", "\n", "以下是系统错误描述", "\n", "\n", "谢谢大家！"]], "Tag": "程序设计"}
{"Answer": "m_pConnection.CreateInstance(\"ADODB.Connection\");\r\n这里就应该初始化的。\r\nm_pConnection调用Close后连接关闭，可以再次Open，不会自动释放或者指针设置为NULL\r\n不知道你说的第六行是哪个文件的第六行，你也没有标记出行号。如果有别的问题，请留言", "Konwledge_Point": "定义新的类型", "Question": ["vs2010 mfc ADO连接SQL server 程序不解", ["\n各位网友，", "\n我在网站下载的一个MFC ADO方式连接SQL server数据库代码有个地方不明白，请帮忙看看", "\n新建一个按钮，加入如下代码：", "\n\n", "void CADOTESTDlg::OnBnClickedButton2()", "\n{", "\n    // TODO: 在此添加控件通知处理程序代码", "\n\n", "\n", " ADOConn conn;", "\n", " conn.OnInitADOConn();", "\n", " _bstr_t vSQL;", "\n", " vSQL = \"INSERT INTO [dbtest].[dbo].", "userinfo", " VALUES('seamanj','123')\";", "\n", " conn.ExecuteSQL(vSQL);", "\n", " conn.ExitConnect();", "\n", " conn.m_pConnection;\n}", "\n", "MFC 中debug执行完第2行，m_pConnection中就有了地址，SQL server 中执行Select * from sys.dm_exec_connections可看到新的连接，但是执行完第6行应该m_pConnection中的地址被清空，并且断开连接的，可是实际情况是一直到执行完所有的代码并结束，m_pConnection才被清空并断开连接。", "\n哪位能帮我解释下，谢谢。", "\n\n", "void ADOConn::ExitConnect()\n{\n    // 关闭记录集和连接\n    if (m_pRecordset != NULL)\n        m_pRecordset->Close();\n    m_pConnection->Close();\n\n    // 释放环境\n    ::CoUninitialize();\n    //CString temp=_T(\"0\");\n}\n", "\n\n", "void ADOConn::OnInitADOConn()\n{\n    // 初始化OLE/COM库环境\n    //CoInitialize(NULL)和AfxOleInit()的区别：  https://blog.csdn.net/zhoubl668/article/details/4139933\n    ::CoInitialize(NULL);\n    try\n    {\n        // 创建Connection对象\n        m_pConnection.CreateInstance(\"ADODB.Connection\");\n        // 设置连接字符串，必须是BSTR型或者_bstr_t类型\n        _bstr_t strConnect = \"Provider=SQLOLEDB; Server=127.0.0.1;Database=dbtest; uid=lnhv013710; pwd=013710;\";\n        m_pConnection->Open(strConnect,\"\",\"\",adModeUnknown);\n    }\n    // 捕捉异常\n    catch(_com_error e)\n    {\n        // 显示错误信息\n        AfxMessageBox(e.Description());\n    }\n}\n", "\n\n", "#pragma once\n\nclass ADOConn\n{\n// 定义变量\npublic:\n//添加一个指向Connection对象的指针:\n_ConnectionPtr m_pConnection;\n//添加一个指向Recordset对象的指针:\n_RecordsetPtr m_pRecordset;\n\n\n\n\n// 定义方法\npublic:\nADOConn();\nvirtual ~ADOConn();\n// 初始化—连接数据库\nvoid OnInitADOConn();\n// 执行查询\n_RecordsetPtr& GetRecordSet(_bstr_t bstrSQL);\n// 执行SQL语句，Insert Update _variant_t\nBOOL ExecuteSQL(_bstr_t bstrSQL);\n\nvoid ExitConnect();\n};\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你倒是把错误信息帖出来看看&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c++单链表一直报错，如何解决", ["没学过c++，写完也不知错哪里，编译器一直报错，怎么去解决？", "\n", "\n", "#", "include", " ", "<iostream>", "\n\n\n\n\n ", "//定义线性表类型List", "\n\n ", "template", " <", "class", " ", "T", ">\n\n ", "class", " ", "List", " {\n\n      ", "void", " ", "clear", "()", ";\n\n      ", "bool", " ", "isEmpty", "()", ";\n\n      ", "bool", " ", "insert", "(", "const", " ", "int", " p, ", "const", " T value)", ";\n\n      ", "bool", " ", "delete1", "(", "const", " ", "int", " p)", ";\n\n      ", "bool", " ", "getPos", "(", "int", "& p, ", "const", " T value)", ";\n\n      ", "bool", " ", "getValue", "(", "const", " ", "int", " p, T & value)", ";\n\n      ", "bool", " ", "setValue", "(", "const", " ", "int", " p, ", "const", " T value)", ";\n\n    \n};\n\n\n\n ", "//定义单链表结点类型", "\n\n ", "template", " <", "class", " ", "T", ">\n\n ", "class", " ", "Link", " {\n\n ", "public", ":\n\n      T data;\n\n      Link<T> *next;\n\n    \n};\n\n\n\n ", "//定义单链表类型lnkList", "\n\n ", "template", " <", "class", " ", "T", ">\n\n ", "class", " ", "lnkList", " : ", "public", " List<T>\n {\n\n ", "private", ":\n\n     Link<T>* head, * tail;\n\n     ", "//头指针、尾指针", "\n\n\n\n             ", "//返回单链表第p个元素的地址（p=-1返回头结点地址，0返回第1结点地址，不存在返回NULL）", "\n\n     ", "Link<T>* ", "setPos", "(", "const", " ", "int", " p)", " ", "{\n\n         ", "if", " (p == ", "-1", ") ", "return", " head;  ", "//p为-1则返回头结点地址", "\n\n         ", "int", " count = ", "0", ";\n\n         Link<T>* tmp = head->next;   ", "//c指向第1个结点   head->头结点   c->第1结点", "\n\n         ", "while", " (tmp != ", "NULL", " && count < p) {    ", "//head->头结点->第1结点->c第2结点->第3结点NULL ", "\n             count++;\n\n             tmp = tmp->next;     ", "//c指向下一结点（指针传递技术）   ", "\n\n\n         }\n\n         ", "return", " tmp;\n\n\n     }\n\n     ", "//c指向尾结点的条件：c->next==NULL", "\n\n         ", "//c指向倒数第二个结点的条件： c->next->next==NULL", "\n\n ", "public", ":\n\n     ", "//构造函数：构造一个只有头结点的空链表", "\n\n     ", "lnkList", "() {\n\n         head = tail = ", "new", " Link<T>;\n\n         head->next = ", "NULL", ";\n\n\n     }\n\n     ", "//析构函数：删除所有结点", "\n\n     ~", "lnkList", "() {\n\n         Link<T>* tmp;\n\n         ", "while", " (head != ", "NULL", ") {\n\n             tmp = head;    ", "//tmp指向头结点", "\n\n             head = head->next;  ", "//head指向下一结点", "\n\n             ", "delete", " tmp;    ", "//释放头结点", "\n\n\n         }\n\n\n     }\n     ", "//1.清除", "\n     ", "bool", " ", "clear", "()", "\n     ", "{\n         Link<T>* tmp;\n         tmp = head->next;\n         ", "while", " (tmp != ", "NULL", ")\n         {\n             head->next = tmp->next;\n             ", "delete", " tmp\n                 tmp = head->next;\n         }\n         ", "return", " ", "true", ";\n     }\n\n\n\n\n\n     ", "//2.显示", "\n\n     ", "bool", " ", "display", "()", " ", "{\n\n         Link<T>* tmp = head->next; ", "//tmp指向第1结点", "\n\n         ", "if", " (tmp == ", "NULL", ") cout << ", "\"空表\\n\"", ";\n\n         ", "else", " {\n\n             ", "while", " (tmp != ", "NULL", ") {\n\n                 cout << tmp->data << ", "\"  \"", ";\n\n                 tmp = tmp->next;  ", "//tmp指向下一结点", "\n\n\n             }\n\n             cout << endl;\n\n\n         }\n\n         ", "return", " ", "true", ";\n\n\n     }\n\n     ", "//3.求表长", "\n\n     ", "bool", " ", "length", "(", "int", "& i)", " ", "{\n\n         i = ", "0", ";\n\n         Link<T>* p = head->next; ", "//p指向第1结点", "\n\n         ", "while", " (p != ", "NULL", ") {\n\n             i++;\n\n             p = p->next;\n\n\n         }\n\n         ", "return", " ", "true", ";\n\n\n     }\n     ", "// 4.插入", "\n     ", "bool", " ", "insert", "(", "const", " ", "int", " p, ", "const", " T value)", "\n     ", "{\n         Link<T>* tmp, * q;\n         ", "if", " ((tmp = ", "setPos", "(p - ", "1", ")) == ", "NULL", ")\n         {\n             cout << ", "\"非法插入点\"", " << end1;\n             ", "return", " ", "false", ";\n         }\n         q = ", "new", " Link<T>;\n         q->data = value;\n         q->next = tmp->next;\n         tmp->next = q;\n         ", "if", " (tmp == tail)\n             tail = q;\n         ", "return", " ", "true", ";\n     }\n\n\n\n\n\n\n\n\n\n     ", "//5.追加", "\n\n     ", "bool", " ", "append", "(", "const", " T value)", " ", "{\n\n         Link<T>* tmp, * q;\n\n         q = ", "new", " Link<T>; ", "//q指向新结点", "\n\n         q->data = value;  ", "//填入新结点的数据域", "\n\n         q->next = ", "NULL", ";  ", "//填入新结点的指针域NULL", "\n\n         p = tail;    ", "//p指向尾结点，也可以p=head->next; while(p->next!=NULL) p=p->next;", "\n\n         tmp->next = q;   ", "//新结点链入原尾结点之后", "\n\n         tail = q;    ", "//修改尾指针", "\n\n         ", "return", " ", "true", ";\n\n\n     }\n\n     ", "//尾结点的条件p->next == NULL，头结点的条件p == head", "\n\n         ", "//第1结点的条件p == head->next，单链表结束的条件 p == NULL", "\n\n ", "//6.删除", "\n     ", "bool", " ", "delete1", "(", "const", " ", "int", " p)", "\n     ", "{\n         Link<T>* tmp, * q;\n         ", "if", " ((tmp = ", "setPos", "(p - ", "1", ")) = ", "NULL", " || tmp == tail)\n         {\n             cout << ", "\"非法删除点\"", " << end1;\n             ", "return", " ", "false", ";\n         }\n         q = tmp->next;\n         ", "if", " (q == tail)\n         {\n             tail = tmp;\n             tmp->next == ", "NULL", ";\n             ", "delete", " q;\n         }\n         ", "else", " ", "if", " (q != ", "NULL", ")\n         {\n             tmp->next = q->next;\n             ", "delete", " q;\n         }\n         ", "return", " ", "true", ";\n     }\n\n     ", "//7.查找", "\n     ", "bool", " ", "getValue", "(", "const", " ", "int", " p, T& value)", "\n     ", "{\n         Link <T>* tmp = head->next;\n         ", "int", " i = ", "1", ";\n         ", "while", " (tmp != ", "NULL", " && i < p)\n         {\n             tmp = tmp->next;\n             i++;\n         }\n         value = tmp->data;\n         ", "return", " ", "true", ";\n     }\n\n     ", "//8.修改", "\n     ", "bool", " ", "setValue", "(", "const", " ", "int", " p, T& value)", "\n     ", "{\n         Link<T>* tmp = head->next;\n         ", "int", " i = ", "1", ";\n         ", "while", " (tmp != ", "NULL", " && i < p)\n         {\n             tmp = tmp->next;\n             i++;\n         }\n         tmp->data = value;\n         ", "return", " ", "true", ";\n     }\n\n     ", "//9.定位", "\n     ", "bool", " ", "getPos", "(", "int", "& p, ", "const", " T value)", "\n     ", "{\n         Link<T>* tmp = head->next;\n         ", "int", " i = ", "0", ";\n         ", "while", " (tmp != ", "NULL", ")\n         {\n             ", "if", " (tmp->data == value)\n             {\n                 p = i;\n                 ", "return", " ture;\n             }\n             i++;\n             tmp = tmp->next;\n         }\n         ", "return", " ", "true", ";\n     }\n };\n \n\n\n\n\n\n\n\n\n     ", "void", " ", "main", "()", "\n     ", "{\n         lnkList<", "int", "> LL;\n\n         ", "int", " choice, p, value;\n\n         ", "bool", " ok;\n\n         ", "do", "\n         {\n             cout << ", "\"单链表程序(0退出,1清除,2显示,3表长,4插入,5追加,6删除,7查找,8修改,9定位),请选择:\"", ";\n\n             cin >> choice;\n\n             ", "switch", " (choice)\n             {\n\n             ", "case", " ", "0", ":\n\n                 cout << ", "\"再见!\\n\"", ";\n\n                 ", "break", ";\n\n             ", "case", " ", "1", ":\n                 ok = LL.", "clear", "();\n                 ", "if", " (ok == ", "true", ") cout << ", "\"清除操作成功！\\n\"", ";\n                 ", "else", " cout << ", "\"清除操作失败！\\n\"", ";\n\n\n                 ", "break", ";\n\n             ", "case", " ", "2", ":\n\n                 ok = LL.", "display", "();\n\n                 ", "if", " (ok == ", "true", ") cout << ", "\"显示操作成功!\\n\"", ";\n\n                 ", "else", " cout << ", "\"显示操作失败!\\n\"", ";\n\n                 ", "break", ";\n\n             ", "case", " ", "3", ":\n\n                 ok = LL.", "length", "(p);\n\n                 ", "if", " (ok == ", "true", ") cout << ", "\"求表长操作成功!表长为:\"", " << p << endl;\n\n                 ", "else", " cout << ", "\"求表长操作失败!\\n\"", ";\n\n                 ", "break", ";\n\n             ", "case", " ", "4", ":\n                 cout << ", "\"位置： \"", "cin >> p;\n                 cout << ", "\"元素:  \"", "cin >> value;\n                 ok == LL.", "insert", "(p, value);\n                 ", "if", " (ok == ", "true", ")cout << ", "\"插入操作成功！\\n\"", ";\n                 ", "else", " cout << ", "\"插入操作失败！\\n\"", ";\n\n\n                 ", "break", ";\n\n             ", "case", " ", "5", ":\n\n                 cout << ", "\"请输入元素值:\"", "; cin >> value;\n\n                 ok = LL.", "append", "(value);\n\n                 ", "if", " (ok == ", "true", ") cout << ", "\"追加操作成功!\\n\"", ";\n\n                 ", "else", " cout << ", "\"追加操作失败!\\n\"", ";\n\n                 ", "break", ";\n\n             ", "case", " ", "6", ":\n                 cout << ", "\"位置：\"", "; cin >> p;\n                 ok == LL.", "delete1", "(p);\n                 ", "if", " (ok == ", "true", ")cout << ", "\"删除表元操作成功！\\n\"", ";\n                 ", "else", " coout << ", "\"删除表元操作失败！\\n\"", ";\n\n\n                 ", "break", ";\n\n             ", "case", " ", "7", ":\n                 cout << ", "\"位置：\"", "; cin >> p;\n                 ok == LL.", "getValue", "(p, value);\n                 ", "if", " (ok == ture)cout << ", "\"查表元操作成功！\\n元素值为：\"", " << value << end1;\n                 ", "else", " cout << ", "\"差表元操作失败！\\n\"", ";\n\n                 ", "break", ";\n\n             ", "case", " ", "8", ":\n                 cout << ", "\"位置：\"", "；cin >> p;\n                 cout << ", "\"元素：\"", "；cin >> value;\n                 ok == LL.", "setValue", "(p, value);\n                 ", "if", " (ok == ", "true", ")cout << ", "\"修改表元操作成功!\\n\"", ";\n                 ", "else", " cout << ", "\"修改表元操作失败！\\n\"", ";\n\n                 ", "break", ";\n\n             ", "case", " ", "9", ":\n                 cout << ", "\"元素：\"", "；cin >> value;\n                 ok == LL.", "getPos", "(p, value);\n                 ", "if", " (ok == ", "false", ") cout << ", "\"元素不存在!\\n\"", ";\n                 ", "else", "\n                 {\n                     cout << ", "\"定位操作成功！\\n\"", ";\n                     ", "if", " (p == ", "0", ")  cout << ", "\"元素不存在！\\n\"", ";\n                     ", "else", " cout << ", "\"元素位置为：\"", " << p << end1;\n                 }\n                 ", "break", ";\n\n             ", "default", ":\n\n                 cout << ", "\"选择错误！\\n\"", ";\n             }\n             ", "while", " (choice != ", "0", ");\n         }\n     }\n"]], "Tag": "程序设计"}
{"Answer": "谢谢已经解决了，service哪里没有添加白名单", "Konwledge_Point": "定义新的类型", "Question": ["百度鹰眼返回值问题，百度工程师您好", ["我用Java 调用百度鹰眼《实时位置搜索》 返回值是{\"status\":210,\"message\":\"APP IP校验失败\"}，请问这是什么问题", "\n\n", "public static final String yingYan_AK_S=\"******\";", "\n\n", "/**\n * 百度鹰眼serviceID\n */\npublic static final String yingyan_SERVICE_ID = \"******\";\n", "\n\n", "public static final String yingyan_URL=\"", "http://yingyan.baidu.com/api/v3/", "\";", "\n\n", "/**\n * 百度鹰眼提交方式\n */\npublic static final String yingyan_POST=\"POST\";\npublic static final String yingyan_GET=\"GET\";\n\n//创建entity，并赋属性信息\npublic static class yingyanEntity{\n\n    public static final String SEARCH = \"entity/search\";\n\n    public static final String BOUNDSEARCH = \"entity/boundsearch\";\n    /**\n     * \n     */\n    public static final String AROUNDSEARCH = \"entity/aroundsearch\";\n    /**\n     * 检索符合条件的entity，返回entity属性信息和最新位置。可用于列出entity，也可用于批量查询多个entitiy的位置\n     */\n    public static final String DISTRICTSEARCH = \"entity/districtsearch\";\n\n\n}\n\npublic static String yingyanReq(String urlReq, String param, String method) {\n    try {\n        //Get请求，拼装参数\n        if (yingyan_GET.equals(method)) {\n            urlReq = urlReq + \"?\" + param;\n        }\n        //创建URL对象\n        URL url = new URL(urlReq);\n        //返回一个URLConnection对象，它表示到URL所引用的远程对象的连接\n        URLConnection urlConnection = url.openConnection();\n        //POST请求，写入参数\n        if (yingyan_POST.equals(method)) {\n            // 设置doOutput属性为true表示将使用此urlConnection写入数据\n            urlConnection.setDoOutput(true);\n            // 定义待写入数据的内容类型，我们设置为application/x-www-form-urlencoded;charset=UTF-8\"类型\n            urlConnection.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded;charset=UTF-8\");\n            // 得到请求的输出流对象\n            OutputStreamWriter out = new OutputStreamWriter(urlConnection.getOutputStream());\n            // 把数据写入请求的Body\n            out.write(param);\n            out.flush();\n            out.close();\n        }\n        InputStream inputStream = urlConnection.getInputStream();\n        String encoding = urlConnection.getContentEncoding();\n        String result = IOUtils.toString(inputStream, encoding);\n        System.out.println(result);\n        return result;\n    }catch (Exception e) {\n        // TODO: handle exception\n        e.printStackTrace();\n        return null;\n    }\n\n}\n\npublic static void main(String[] args) {\n\n    String urlReq = yingyan_URL + yingyanEntity.DISTRICTSEARCH;\n    String param = \"ak=\"+YingYan_AK_S+\"&service_id=\"+yingyan_SERVICE_ID+\"&keyword=海淀区\";\n\n    yingyanReq(urlReq, param, yingyan_GET);\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;刚试了怎么传值是可以的&amp;#xff0c;其实字符数组也是指针&amp;#xff0c;这么传理论上没有问题。&lt;br /&gt;你可以尝试修改将fname也定义成指针试试&lt;br /&gt;char *fname &amp;#61; (char *)malloc(sizeof(char));&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言函数参数为数组时值传递失败", ["运行环境：vs2022;", "问题背景：写一个家谱的操作系统", "现象：函数参数为字符串数组时传递参数失败", "\n", " 问题相关代码", "\n", "\n", "\n", "我的解答思路和尝试过的方法 、", "\n", "感觉是insertfnc()函数没有接受到传递的参数", "我试着改了一下形参名字，或者改成将参数形式改成char fname[MAX],也没有用", "看了网上一些讲这个内容的，感觉自己应该没有写错。难道是错在其他地方了吗？", "\n", "源码如下：", "/", "有没有很懂孩兄二叉树的兄弟，后面功能还有好多疑问，这是摘取了一部分功能调试，如果您愿意帮忙指点一二真的感激不尽！（付费咨询也可", "以），自己解决问题的效率太伤了", "/", "#include <stdio.h>", "#include <string.h>", "#include <stdlib.h>", "#include<windows.h>", "#define MAX 10 ", "\n", "typedef struct", "{", "    int generation;", "    char name[MAX];", "    int sex;//1为男，0为女", "}DataType;", "//此为数据域的类型定义，若想实现更多的数据要求，应在此加入更多数据类型的定义。", "\n", "typedef struct Node", "{", "    DataType person;", "    struct Node* lchild, * rbrother, * father;", "}node, * tree;", "//利用孩兄弟表示法来表示每个结点。", "\n", "tree createNode();", "void insertfnc(char);", "tree find(tree, char);//寻找到对应姓名对应的结点并用全局变量指针记录", "void create();", "//int NamePreOrderTraverse(tree T, char name[20]);", "tree BT=NULL;", "tree p=NULL;", "\n", "int main()", "{", "    p = (tree)malloc(sizeof(node));", "    create();", "    return 1;", "}", "\n", "void create()", "{", "    printf(\"请遵从提示从大到小插入家谱中的人物（先输入者必是年龄大者）:\\n\");", "    char name[MAX];", "    char fname[MAX];", "    BT=createNode();", "    printf(\"\\n您已完成创建根节点\");", "    int flag = 0;//标记是否继续输入。", "    while (!flag)", "    {", "        printf(\"\\n输入“0”继续插入新的成员,输入其他退回主界面\\n\");", "        scanf_s(\"%d\", &flag);", "        getchar();", "        if (!flag)", "        {", "            printf(\"\\n输入新成员父亲姓名:\");", "            scanf_s(\"%s\", fname, sizeof(fname)+1);", "            getchar();", "            printf(\"插入之前:%s\",fname);", "            insertfnc(fname);", "        }", "    }", "}", "\n", "tree createNode()", "{", "    tree q = (tree)malloc(sizeof(node));", "    printf(\"请输入被添加成员的姓名(长度小于5个字):\");", "    char name[MAX];", "    scanf_s(\"%s\",name,MAX); getchar();", "    strcpy_s(q->person.name,MAX,name);", "     q->person.generation = 1;", "     q->person.sex = 1;", "     q->rbrother = NULL;", "     q->lchild = NULL;", "     q->father = NULL;", "     return q;", "}", "void insertfnc(char *fname)", "     {", "    printf(\"到这还是好好的\\n\");", "    printf(\"插入中：%s\", fname);", "         tree son=(tree)malloc(sizeof(node));", "         p=find(BT,fname);", "\n", "     ", "if", " (!p) {\n         printf(", "\"插入失败，查无其父\\n按回车键以继续...\"", ");\n         getchar();\n         system(", "\"cls\"", ");\n         return;\n     }\n     son=createNode();\n\n     ", "son", "->", "father = p;", "//完成对插入点信息的补充", "\n     ", "son", "->", "person", ".generation = p->", "person.generation + ", "1", ";\n     printf(", "\"请输入插入者的性别(1为男性，0为女性)：\"", ");\n     ", "scanf_s", "(\"%d\", &(son->", "person.sex));\n     getchar();\n\n\n     ", "if", " (p->", "lchild", " == NULL) p->", "lchild = son;\n     ", "else", " {\n         ", "tree", " bro = p->", "lchild;\n         ", "while", " (bro->", "rbrother", " != NULL) bro = bro->", "rbrother;\n         ", "son", " = bro->", "rbrother;\n     }\n     printf(", "\"插入成功！\"", ");\n     return;\n }\n", "\n", "tree find(tree A, char name[MAX])", "{", "\n", "if", " (!A)  ", "return", " NULL;\n", "else", "\n{\n    printf(", "\"确实是%s\\n\"", ", A->person", ".name", ");\n    ", "if", " (strcmp(A->person", ".name", ",", " name", ") == ", "0", ")\n    {\n        ", "return", " A;\n    }\n   /* ", "else", " ", "return", " find(A->lchild,", " name", ");\n\n    ", "if", "(strcmp(A->person", ".name", ",name", ")!=", "0", ")    ", "return", " find(A->rbrother,", " name", ");*/\n\n   \n}\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;class lnkList 类的末尾缺一个}&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c++单链表最后一个括号编译器显示有误，怎么修改", ["最后一个括号编译器显示：", "\n", "严重性    代码    说明    项目    文件    行    禁止显示状态", "错误    C1075    “{”: 未找到匹配令牌", "严重性    代码    说明    项目    文件    行    禁止显示状态", "错误(活动)    E0067    应输入“}”    ", "\n", "错在哪里，要怎么去修改?", "\n", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "//定义线性表类型List", "\n", "template", " <", "class", " ", "T", ">\n", "class", " ", "List", " {\n    ", "void", " ", "clear", "()", ";\n    ", "bool", " ", "isEmpty", "()", ";\n    ", "bool", " ", "insert", "(", "const", " ", "int", " p, ", "const", " T value)", ";\n    ", "bool", " ", "delete1", "(", "const", " ", "int", " p)", ";\n    ", "bool", " ", "getPos", "(", "int", "& p, ", "const", " T value)", ";\n    ", "bool", " ", "getValue", "(", "const", " ", "int", " p, T& value)", ";\n    ", "bool", " ", "setValue", "(", "const", " ", "int", " p, ", "const", " T value)", ";\n};\n\n", "//定义单链表结点类型", "\n", "template", " <", "class", " ", "T", ">\n", "class", " ", "Link", " {\n", "public", ":\n    T data;\n    Link<T>* next;\n};\n\n", "//定义单链表类型lnkList", "\n", "template", " <", "class", " ", "T", ">\n", "class", " ", "lnkList", " : ", "public", " List<T> {\n", "private", ":\n    Link<T>* head, * tail;                ", "//头指针、尾指针", "\n\n    ", "//返回单链表第p个元素的地址（p=-1返回头结点地址，0返回第1结点地址，不存在返回NULL）", "\n    ", "Link<T>* ", "setPos", "(", "const", " ", "int", " p)", " ", "{\n        ", "if", " (p == ", "-1", ") ", "return", " head;        ", "//p为-1则返回头结点地址", "\n        ", "int", " count = ", "0", ";\n        Link<T>* tmp = head->next;            ", "//c指向第1个结点   head->头结点   c->第1结点", "\n        ", "while", " (tmp != ", "NULL", " && count < p) {    ", "//head->头结点->第1结点->c第2结点->第3结点NULL ", "\n            count++;\n            tmp = tmp->next;                    ", "//c指向下一结点（指针传递技术）            ", "\n        }\n        ", "return", " tmp;\n    }\n    ", "//c指向尾结点的条件：c->next==NULL", "\n    ", "//c指向倒数第二个结点的条件： c->next->next==NULL", "\n", "public", ":\n    ", "//构造函数：构造一个只有头结点的空链表", "\n    ", "lnkList", "() {\n        head = tail = ", "new", " Link<T>;\n        head->next = ", "NULL", ";\n    }\n    ", "//析构函数：删除所有结点", "\n    ~", "lnkList", "() {\n        Link<T>* tmp;\n        ", "while", " (head != ", "NULL", ") {\n            tmp = head;                ", "//tmp指向头结点", "\n            head = head->next;        ", "//head指向下一结点", "\n            ", "delete", " tmp;                ", "//释放头结点", "\n        }\n    }\n    ", "//1.清除", "\n    ", "bool", " ", "clear", "()", "\n    ", "{\n        Link<T>* tmp;\n        tmp = head->next;\n        ", "while", " (tmp != ", "NULL", ")\n        {\n            head->next = tmp->next;\n            ", "delete", " tmp\n                tmp = head->next;\n        }\n        ", "return", " ", "true", ";\n    }\n    ", "//2.显示", "\n    ", "bool", " ", "display", "()", " ", "{\n        Link<T>* tmp = head->next;    ", "//tmp指向第1结点", "\n        ", "if", " (tmp == ", "NULL", ") cout << ", "\"空表\\n\"", ";\n        ", "else", " {\n            ", "while", " (tmp != ", "NULL", ") {\n                cout << tmp->data << ", "\"  \"", ";\n                tmp = tmp->next;        ", "//tmp指向下一结点", "\n            }\n            cout << endl;\n        }\n        ", "return", " ", "true", ";\n    }\n    ", "//3.求表长", "\n    ", "bool", " ", "length", "(", "int", "& i)", " ", "{\n        i = ", "0", ";\n        Link<T>* p = head->next;    ", "//p指向第1结点", "\n        ", "while", " (p != ", "NULL", ") {\n            i++;\n            p = p->next;\n        }\n        ", "return", " ", "true", ";\n    }\n    ", "// 4.插入", "\n    ", "bool", " ", "insert", "(", "const", " ", "int", " p, ", "const", " T value)", "\n    ", "{\n        Link<T>* tmp, * q;\n        ", "if", " ((tmp = ", "setPos", "(p - ", "1", ")) == ", "NULL", ")\n        {\n            cout << ", "\"非法插入点\"", " << end1;\n            ", "return", " ", "false", ";\n        }\n        q = ", "new", " Link<T>;\n        q->data = value;\n        q->next = tmp->next;\n        tmp->next = q;\n        ", "if", " (tmp == tail)\n            tail = q;\n        ", "return", " ", "true", ";\n    }\n\n    ", "//5.追加", "\n    ", "bool", " ", "append", "(", "const", " T value)", " ", "{\n        Link<T>* p, * q;\n        q = ", "new", " Link<T>;    ", "//q指向新结点", "\n        q->data = value;        ", "//填入新结点的数据域", "\n        q->next = ", "NULL", ";        ", "//填入新结点的指针域NULL", "\n        p = tail;                ", "//p指向尾结点，也可以p=head->next; while(p->next!=NULL) p=p->next;", "\n        p->next = q;            ", "//新结点链入原尾结点之后", "\n        tail = q;                ", "//修改尾指针", "\n        ", "return", " ", "true", ";\n    }\n    ", "//尾结点的条件p->next == NULL，头结点的条件p == head", "\n    ", "//第1结点的条件p == head->next，单链表结束的条件 p == NULL", "\n\n    ", "//6.删除", "\n    ", "bool", " ", "delete1", "(", "const", " ", "int", " p)", "\n    ", "{\n        Link<T>* tmp, * q;\n        ", "if", " ((tmp = ", "setPos", "(p - ", "1", ")) = ", "NULL", " || tmp == tail)\n        {\n            cout << ", "\"非法删除点\"", " << end1;\n            ", "return", " ", "false", ";\n        }\n        q = tmp->next;\n        ", "if", " (q == tail)\n        {\n            tail = tmp;\n            tmp->next == ", "NULL", ";\n            ", "delete", " q;\n        }\n        ", "else", " ", "if", " (q != ", "NULL", ")\n        {\n            tmp->next = q->next;\n            ", "delete", " q;\n        }\n        ", "return", " ", "true", ";\n    }\n    ", "//7.查找", "\n    ", "bool", " ", "getValue", "(", "const", " ", "int", " p, T& value)", "\n    ", "{\n        Link <T>* tmp = head->next;\n        ", "int", " i = ", "1", ";\n        ", "while", " (tmp != ", "NULL", " && i < p)\n        {\n            tmp = tmp->next;\n            i++;\n        }\n        value = tmp->data;\n        ", "return", " ", "true", ";\n    }\n    ", "//8.修改", "\n    ", "bool", " ", "setValue", "(", "const", " ", "int", " p, T& value)", "\n    ", "{\n        Link<T>* tmp = head->next;\n        ", "int", " i = ", "1", ";\n        ", "while", " (tmp != ", "NULL", " && i < p)\n        {\n            tmp = tmp->next;\n            i++;\n        }\n        tmp->data = value;\n        ", "return", " ", "true", ";\n    }\n    ", "//9.定位", "\n    ", "bool", " ", "getPos", "(", "int", "& p, ", "const", " T value)", "\n    ", "{\n        Link<T>* tmp = head->next;\n        ", "int", " i = ", "0", ";\n        ", "while", " (tmp != ", "NULL", ")\n        {\n            ", "if", " (tmp->data == value)\n            {\n                p = i;\n                ", "return", " ", "true", ";\n            }\n            i++;\n            tmp = tmp->next;\n        }\n        ", "return", " ", "true", ";\n    }\n\n    ", "int", "  ", "main", "()", "\n", "{\n    lnkList<", "int", "> LL;\n    ", "int", " choice, p, value;\n    ", "bool", " ok;\n    ", "do", " {\n        cout << ", "\"单链表程序(0退出,1清除,2显示,3表长,4插入,5追加,6删除,7查找,8修改,9定位),请选择:\"", ";\n        cin >> choice;\n        ", "switch", " (choice) \n        {\n        ", "case", " ", "0", ":\n            cout << ", "\"再见!\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "1", ":\n            ok = LL.", "clear", "();\n            ", "if", " (ok == ", "true", ") cout << ", "\"清除操作成功！\\n\"", ";\n            ", "else", " cout << ", "\"清除操作失败！\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "2", ":\n            ok = LL.", "display", "();\n            ", "if", " (ok == ", "true", ") cout << ", "\"显示操作成功!\\n\"", ";\n            ", "else", " cout << ", "\"显示操作失败!\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "3", ":\n            ok = LL.", "length", "(p);\n            ", "if", " (ok == ", "true", ") cout << ", "\"求表长操作成功!表长为:\"", " << p << endl;\n            ", "else", " cout << ", "\"求表长操作失败!\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "4", ":\n            cout << ", "\"位置： \"", "; cin >> p;\n            cout << ", "\"元素:  \"", "; cin >> value;\n            ok == LL.", "insert", "(p, value);\n            ", "if", " (ok == ", "true", ")cout << ", "\"插入操作成功！\\n\"", ";\n            ", "else", " cout << ", "\"插入操作失败！\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "5", ":\n            cout << ", "\"请输入元素值:\"", "; cin >> value;\n            ok = LL.", "append", "(value);\n            ", "if", " (ok == ", "true", ") cout << ", "\"追加操作成功!\\n\"", ";\n            ", "else", " cout << ", "\"追加操作失败!\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "6", ":\n            cout << ", "\"位置：\"", "; cin >> p;\n            ok == LL.", "delete1", "(p);\n            ", "if", " (ok == ", "true", ")cout << ", "\"删除表元操作成功！\\n\"", ";\n            ", "else", " cout << ", "\"删除表元操作失败！\\n\"", ";\n\n            ", "break", ";\n        ", "case", " ", "7", ":\n            cout << ", "\"位置：\"", "; cin >> p;\n            ok == LL.", "getValue", "(p, value);\n            ", "if", " (ok == ", "true", ")cout << ", "\"查表元操作成功！\\n元素值为：\"", " << value << endl;\n            ", "else", " cout << ", "\"差表元操作失败！\\n\"", ";\n            ", "break", ";\n        ", "case", " ", "8", ":\n            cout << ", "\"位置：\"", "; cin >> p;\n            cout << ", "\"元素：\"", "; cin >> value;\n            ok == LL.", "setValue", "(p, value);\n            ", "if", " (ok == ", "true", ")cout << ", "\"修改表元操作成功!\\n\"", ";\n            ", "else", " cout << ", "\"修改表元操作失败！\\n\"", ";\n\n            ", "break", ";\n        ", "case", " ", "9", ":\n            cout << ", "\"元素：\"", "; cin >> value;\n            ok == LL.", "getPos", "(p, value);\n            ", "if", " (ok == ", "false", ") cout << ", "\"元素不存在!\\n\"", ";\n            ", "else", "\n            {\n                cout << ", "\"定位操作成功！\\n\"", ";\n                ", "if", " (p == ", "0", ")  cout << ", "\"元素不存在！\\n\"", ";\n                ", "else", " cout << ", "\"元素位置为：\"", " << p << endl;\n            }\n            ", "break", ";\n        ", "default", ":\n            cout << ", "\"选择错误！\\n\"", ";\n        }\n    } \n    ", "while", " (choice != ", "0", ");\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;题主代码修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXSIZE 100&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Status; &lt;span class=\"hljs-comment\"&gt;// 定义函数返回值类型&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; number[&lt;span class=\"hljs-number\"&gt;11&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//学号&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//姓名&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  score;&lt;span class=\"hljs-comment\"&gt;//成绩&lt;/span&gt;\n}Student;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; Student ElemType;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; {\n    Student* elem;&lt;span class=\"hljs-comment\"&gt;//指向数据元素的基地址&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;    length;&lt;span class=\"hljs-comment\"&gt;//线性表当前的长度&lt;/span&gt;\n}SqList;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;creatlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList* L)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//构造空表&lt;/span&gt;\n&lt;/span&gt;{\n    L-&amp;gt;elem &amp;#61; (ElemType*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(ElemType) * MAXSIZE);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!L-&amp;gt;elem) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//表示 空间分配失败&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        L-&amp;gt;length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-comment\"&gt;//void input(Student* elem)&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList* L)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//逐个录入学生信息&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; L-&amp;gt;length;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L-&amp;gt;length &amp;gt;&amp;#61; MAXSIZE) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;表已满!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名 &amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,L-&amp;gt;elem[i].name);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号 &amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,L-&amp;gt;elem[i].number);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;成绩 &amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;//scanf(&amp;#34;%s&amp;#34;, elem-&amp;gt;score);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;L-&amp;gt;elem[i].score);\n    L-&amp;gt;length&amp;#43;&amp;#43;;\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//void output(Student *elem)&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;output&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(ElemType L)&lt;/span&gt;\n&lt;/span&gt;{    \n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;姓名&amp;#xff1a;%s\\n学号&amp;#xff1a;%s\\n成绩&amp;#xff1a;%s\\n&amp;#34;, elem-&amp;gt;name, elem-&amp;gt;number, elem-&amp;gt;score);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;%s\\n学号&amp;#xff1a;%s\\n成绩&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;, L.name, L.number, L.score);\n}\n\n&lt;span class=\"hljs-comment\"&gt;//int find(SqList&amp;amp; L, char str[])&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;find&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList L, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L.length &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;表为空&amp;#xff0c;无记录!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;                  \n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L.length; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(L.elem[i].name, str) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;   &lt;span class=\"hljs-comment\"&gt;//return 0;&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-comment\"&gt;/*\n操作目的&amp;#xff1a;给定一个学生信息&amp;#xff0c;插入到表中指定的位置\n初始条件&amp;#xff1a; 已有线性表\n操作结果&amp;#xff1a; 插入指定位置(address1)&amp;#xff0c;得到新的线性表\n*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;insert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList &amp;amp;L,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; address1,ElemType information)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;L.length;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L.length &amp;gt;&amp;#61; MAXSIZE) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;表已满!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i; i &amp;gt; address1; i--)  &lt;span class=\"hljs-comment\"&gt;//for(i;i&amp;gt;&amp;#61;address1;i--)&lt;/span&gt;\n    {\n        L.elem[i] &amp;#61; L.elem[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];  &lt;span class=\"hljs-comment\"&gt;//L.elem[i&amp;#43;1]&amp;#61;L.elem[i];&lt;/span&gt;\n    }\n    L.elem[i] &amp;#61; information;\n    L.length&amp;#43;&amp;#43;;\n}\n&lt;span class=\"hljs-comment\"&gt;/*\n操作目的&amp;#xff1a;删除指定位置的学生记录\n初始条件&amp;#xff1a; 已有线性表\n操作结果&amp;#xff1a;删除指定位置信息&amp;#xff0c;得到新的线性表\n*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;deletelist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList&amp;amp; L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; address2)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L.length &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;表为空&amp;#xff0c;无记录可删!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; address2; i &amp;lt; L.length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//for (i &amp;#61; address2; i &amp;lt;&amp;#61; L.length; i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        L.elem[i] &amp;#61; L.elem[i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    }\n    L.length--;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    SqList L;\n    ElemType information;\n                                             &lt;span class=\"hljs-comment\"&gt;//creatlist(&amp;amp;L);&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;creatlist&lt;/span&gt;(&amp;amp;L)) &lt;span class=\"hljs-comment\"&gt;//构造空表 &lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;创建成功\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;                \n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;创建失败\\n&amp;#34;&lt;/span&gt;);\n\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N;&lt;span class=\"hljs-comment\"&gt;//确定学生人数&amp;#xff0c;逐个输入信息&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入想输入学生信息的人数&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;N);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)               &lt;span class=\"hljs-comment\"&gt;//for (i &amp;#61; 1; i &amp;lt;&amp;#61; N; i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;正在输入第%d位学生信息\\n&amp;#34;&lt;/span&gt;, i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&amp;amp;L);                       &lt;span class=\"hljs-comment\"&gt;//input(&amp;amp;L.elem[i]);&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L.length; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//for (i &amp;#61; 0; i &amp;lt; N; i&amp;#43;&amp;#43;)&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;output&lt;/span&gt;(L.elem[i]);        &lt;span class=\"hljs-comment\"&gt;//逐个显示学生信息 //output(&amp;amp;L.elem[i]);&lt;/span&gt;\n\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; s[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//定义数组&amp;#xff0c;储存想寻找的名字信息 &lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n请输入需要查找的姓名:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, s);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((i &amp;#61; &lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(L, s)) &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {   &lt;span class=\"hljs-comment\"&gt;//if (find(L, s)) &lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;output&lt;/span&gt;(L.elem[i]);       &lt;span class=\"hljs-comment\"&gt;// output(L.elem[find(L, s)]);&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;deletelist&lt;/span&gt;(L, i);       &lt;span class=\"hljs-comment\"&gt;//删除找到的记录&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; \n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;未录入此人信息\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n查找并删除后学生信息&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L.length; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//删除后学生信息&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;output&lt;/span&gt;(L.elem[i]);      \n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n插入一个学生信息&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(information.name, &lt;span class=\"hljs-string\"&gt;&amp;#34;abcdefg&amp;#34;&lt;/span&gt;); \n    &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(information.number, &lt;span class=\"hljs-string\"&gt;&amp;#34;888&amp;#34;&lt;/span&gt;); \n    information.score &amp;#61; &lt;span class=\"hljs-number\"&gt;90&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(L, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, information);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L.length; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//插入后学生信息&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;output&lt;/span&gt;(L.elem[i]);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["要求输入多个数据，可输入一个数据后程序突然终止了", ["/*", "顺序表", "(1) 根据指定学生个数，逐个输入学生信息；", "(2) 逐个显示学生表中所有学生的相关信息；", "(3) 根据姓名进行查找，返回此学生的学号和成绩；", "(4) 根据指定的位置可返回相应的学生信息（学号，姓名，成绩）；", "(5) 给定一个学生信息，插入到表中指定的位置；", "(6) 删除指定位置的学生记录；", "(7) 统计表中学生个数。", "*/ ", "\n", "#include<stdio.h>", "#include<string.h>", "#include<malloc.h>", "#define MAXSIZE 100  ", "\n", "typedef int Status; // 定义函数返回值类型  ", "\n", "typedef struct{", "    char number[11];//学号", "    char name[20];//姓名", "    int score;//成绩", "}Student;", "typedef Student ElemType;", "typedef struct{", "    Student *elem;//指向数据元素的基地址", "    int length;//线性表当前的长度", "}SqList; ", "\n", "Status creatlist(SqList *L)//构造空表", "{", "    L->elem=(ElemType *)malloc(sizeof(ElemType)*MAXSIZE);", "    if(!L->elem)  return 0;//表示 空间分配失败", "    else {", "        L->length=0;", "        return 1;", "    }", " } ", "\n", " void input(Student *elem)//逐个录入学生信息", " {", "    printf(\"姓名  \");", "     scanf(\"%s\",elem->name);", "     printf(\"学号  \");", "     scanf(\"%s\",elem->number);", "     printf(\"成绩  \");", "     scanf(\"%s\",elem->score);", "\n", " }", "\n", "void output(Student *elem)", "{", "    printf(\"姓名：%s\\n学号：%s\\n成绩：%s\\n\",elem->name,elem->number,elem->score);", "}", "\n", "int find(SqList &L,char str[])", "{", "    int i;", "    for(i=0;i<L.length;i++)", "    {", "        if(strcmp(L.elem[i].name,str)==0)", "        return i;", "    }", "\n", "return", " ", "0", ";\n", "\n", "}", "\n", "/*", "     操作目的：给定一个学生信息，插入到表中指定的位置", "     初始条件： 已有线性表", "     操作结果： 插入指定位置(address1)，得到新的线性表", "     ", "/", "void insert(SqList &L,int address1,ElemType information)", "{", "    int i=L.length;", "    for(i;i>=address1;i--)", "    {", "        L.elem[i+1]=L.elem[i];", "    }", "    L.elem[i]=information;", "    L.length++;", "}", "/", "     操作目的：删除指定位置的学生记录", "     初始条件： 已有线性表", "     操作结果：删除指定位置信息，得到新的线性表", "     */", "Status deletelist(SqList &L,int address2)", "{", "    int i;", "    for(i=address2;i<=L.length;i++)", "    {", "        L.elem[i]=L.elem[i+1];", "    }", "    L.length--;", "}", "\n", "int main()", "{", "    SqList L;", "    ElemType information;", "    creatlist(&L);//构造空表", "    if(creatlist(&L))  printf(\"创建成功\\n\");", "    else printf(\"创建失败\\n\") ;", "\n", " ", "int", " N;", "//确定学生人数，逐个输入信息", "\n ", "printf", "(", "\"请输入想输入学生信息的人数：\"", "); \n ", "scanf", "(", "\"%d\"", ",&N);\n ", "int", " i;\n ", "for", "(i=", "1", ";i<=N;i++)\n {\n     ", "printf", "(", "\"正在输入第%d位学生信息\\n\"", ",i);\n     ", "input", "(&L.elem[i]);\n }\n \n ", "for", "(i=", "0", ";i<N;i++)", "//逐个显示学生信息 ", "\n ", "output", "(&L.elem[i]); \n \n ", "char", " s[", "20", "];", "//定义数组，储存想寻找的名字信息 ", "\n ", "printf", "(", "\"请输入需要查找的姓名 \"", ");\n ", "scanf", "(", "\"%s\"", ",s);\n ", "if", "(", "find", "(L,s))  ", "output", "(&L.elem[", "find", "(L,s)]);\n ", "else", " ", "printf", "(", "\"未录入此人信息", "\n", "\n", "\n", "1. "]], "Tag": "程序设计"}
{"Answer": "问错了，那是答案。下面才是\n#include&lt;stdio.h&gt;//2012非负十进制化八进制 \n#include&lt;stdlib.h&gt;\n#include&lt;math.h&gt;//含有OVERFLOW的值 \n#define OK 1\n#define ERROR 0\n#define STACK_INIT_SIZE 10//初始分配 \n#define STACKINCRTMENT 2//增量 \ntypedef int Status;\ntypedef struct SqStack\n{\n\tint *base;\n\tint *top;\n\tint stacksize;\n}SqStack;//顺序栈 \n\nStatus InitStack(SqStack *S)//造空栈 \n{\n\t(*S).base=(int *)malloc(STACK_INIT_SIZE*sizeof(int));\n\tif(!(*S).base)\n\t\texit(OVERFLOW);\n\t(*S).top=(*S).base;\n\t(*S).stacksize=STACK_INIT_SIZE;\n\treturn OK;\n}\n\nStatus push(SqStack *S,int e)//入栈 \n{\n\tif((*S).top-(*S).base&gt;=(*S).stacksize)\n\t{\n\t\t(*S).base=(int *)realloc((*S).base,((*S).stacksize+STACKINCRTMENT)*sizeof(int));\n\t\tif(!(*S).base)\n\t\t\texit(OVERFLOW);\n\t\t(*S).top=(*S).base+(*S).stacksize;\n\t\t(*S).stacksize+=STACKINCRTMENT;\n\t}\n\t*((*S).top)++=e;\n\treturn 0;\n}\n\nStatus pop(SqStack *S,int *e)//出栈 \n{\n\tif((*S).base==(*S).top)\n\t\treturn ERROR;\n\t*e=*--(*S).top;\n\treturn OK;\n}\n\nStatus StackEmpty(SqStack S)//判空 \n{\n\tif(S.base==S.top)\n\t\treturn OK;\n\telse\n\t\treturn ERROR;\n}\n\nvoid conversion(int n)//十化八 \n{\n\tSqStack s;\n\tint e;\n\tInitStack(&amp;s);\n\twhile(n)\n\t{\n\t\tpush(&amp;s,n%8);\n\t\tn=n/8;\n\t}\n\twhile(!StackEmpty(s))\n\t{\n\t\tpop(&amp;s,&amp;e);\n\t\tprintf(\"%d\",e);\n\t} \n\tprintf(\"\\n\");\n}\n\nint main(void)\n{\n\tint n;\n\twhile(scanf(\"%d\",&amp;n)!=EOF)\n\t{\n\t\tconversion(n);\n\t}\n\treturn 0;\n}\n#include&lt;stdio.h&gt;//2012非负十进制化八进制 \n#include&lt;stdlib.h&gt;\n#include&lt;math.h&gt;//含有OVERFLOW的值 \n#define OK 1\n#define ERROR 0\n#define STACK_INIT_SIZE 10//初始分配 \n#define STACKINCRTMENT 2//增量 \ntypedef int Status;\ntypedef struct SqStack\n{\n\tint *base;\n\tint *top;\n\tint stacksize;\n}SqStack;//顺序栈 \n\nStatus InitStack(SqStack *S)//造空栈 \n{\n\t(*S).base=(int *)malloc(STACK_INIT_SIZE*sizeof(int));\n\tif(!(*S).base)\n\t\texit(OVERFLOW);\n\t(*S).top=(*S).base;\n\t(*S).stacksize=STACK_INIT_SIZE;\n\treturn OK;\n}\n\nStatus push(SqStack *S,int e)//入栈 \n{\n\tif((*S).top-(*S).base&gt;=(*S).stacksize)\n\t{\n\t\t(*S).base=(int *)realloc((*S).base,((*S).stacksize+STACKINCRTMENT)*sizeof(int));\n\t\tif(!(*S).base)\n\t\t\texit(OVERFLOW);\n\t\t(*S).top=(*S).base+(*S).stacksize;\n\t\t(*S).stacksize+=STACKINCRTMENT;\n\t}\n\t*((*S).top)++=e;\n\treturn 0;\n}\n\nStatus pop(SqStack *S,int *e)//出栈 \n{\n\tif((*S).base==(*S).top)\n\t\treturn ERROR;\n\t*e=*--(*S).top;\n\treturn OK;\n}\n\nStatus StackEmpty(SqStack S)//判空 \n{\n\tif(S.base==S.top)\n\t\treturn OK;\n\telse\n\t\treturn ERROR;\n}\n\nvoid conversion(int n)//十化八 \n{\n\tSqStack s;\n\tint e;\n\tInitStack(&amp;s);\n\twhile(n)\n\t{\n\t\tpush(&amp;s,n%8);\n\t\tn=n/8;\n\t}\n\twhile(!StackEmpty(s))\n\t{\n\t\tpop(&amp;s,&amp;e);\n\t\tprintf(\"%d\",e);\n\t} \n\tprintf(\"\\n\");\n}\n\nint main(void)\n{\n\tint n;\n\twhile(scanf(\"%d\",&amp;n)!=EOF)\n\t{\n\t\tconversion(n);\n\t}\n\treturn 0;\n}", "Konwledge_Point": "定义新的类型", "Question": ["能帮我看一下我的代码错哪了吗？", ["十进制正整数化为八进制", "\n#include//2012", "\n#include", "\n#include /* malloc()等 ", "/", "\n#include /", " INT_MAX等 ", "/", "\n#include /", " EOF(=^Z或F6),NULL ", "/", "\n#include /", " atoi() ", "/", "\n#include /", " floor(),ceil(),abs() ", "/", "\n/", " 函数结果状态代码 ", "/", "\n#define TRUE 1", "\n#define FALSE 0", "\n#define OK 1", "\n#define ERROR 0", "\n#define INFEASIBLE -1", "\ntypedef int Status; /", " Status是函数的类型,其值是函数结果状态代码，如OK等 ", "/", "\ntypedef int Boolean; /", " Boolean是布尔类型,其值是TRUE或FALSE */", "\n\n", "#define STACK_INIT_SIZE 10 /* 存储空间初始分配量 ", "/", "\n#define STACKINCREMENT 2 /", " 存储空间分配增量 ", "/", "\ntypedef int SElemType; /", " 定义栈元素类型为整型 ", "/", "\ntypedef struct SqStack", "\n{", "\n    SElemType *base; /", " 在栈构造之前和销毁之后，base的值为NULL ", "/", "\n    SElemType *top; /", " 栈顶指针 ", "/", "\n    int stacksize; /", " 当前已分配的存储空间，以元素为单位 ", "/", "\n} SqStack; /", " 顺序栈 */", "\n\n", "Status InitStack(SqStack ", "S)", "\n{", "\n    /", " 构造一个空栈S ", "/", "\n    (*S).base=(SElemType *)malloc(STACK_INIT_SIZE*sizeof(SElemType));", "\n    if(!(*S).base)", "\n        exit(OVERFLOW); /", " 存储分配失败 */", "\n    (*S).top=(*S).base;", "\n    (*S).stacksize=STACK_INIT_SIZE;", "\n    return OK;", "\n}", "\n\n", "Status Push(SqStack ", "S,SElemType e)", "\n{", "\n    /", " 插入元素e为新的栈顶元素 ", "/", "\n    if((*S).top-(*S).base>=(*S).stacksize) /", " 栈满，追加存储空间 ", "/", "\n    {", "\n        (*S).base=(SElemType *)realloc((*S).base,((*S).stacksize+STACKINCREMENT)*sizeof(SElemType));", "\n        if(!(*S).base)", "\n            exit(OVERFLOW); /", " 存储分配失败 */", "\n        (*S).top=(*S).base+(*S).stacksize;", "\n        (*S).stacksize+=STACKINCREMENT;", "\n    }", "\n    *((*S).top)++=e;", "\n    return OK;", "\n}", "\n\n", "Status Pop(SqStack ", "S,SElemType *e)", "\n{", "\n    /", " 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR ", "/", "\n    if((*S).top==(*S).base)", "\n        return ERROR;", "\n    *e=", "--(*S).top;", "\n    return OK;", "\n}", "\n\n", "Status StackEmpty(SqStack S)", "\n{", "\n    /* 若栈S为空栈，则返回TRUE，否则返回FALSE */", "\n    if(S.top==S.base)", "\n        return TRUE;", "\n    else", "\n        return FALSE;", "\n}", "\n\n", "void conversion(int n) /* 算法3.1 ", "/", "\n{", "\n    /", " 对于输入的任意一个非负十进制整数，打印输出与其等值的八进制数 ", "/", "\n    SqStack s;", "\n    SElemType e;", "\n    InitStack(&s); /", " 初始化栈 ", "/", "\n    while(n) /", " 当n不等于0 ", "/", "\n    {", "\n        Push(&s,n%8); /", " 入栈n除以8的余数(8进制的低位) ", "/", "\n        n=n/8;", "\n    }", "\n    while(!StackEmpty(s)) /", " 当栈不空 ", "/", "\n    {", "\n        Pop(&s,&e); /", " 弹出栈顶元素且赋值给e ", "/", "\n        printf(\"%d\",e); /", " 输出e */", "\n    }", "\n    printf(\"\\n\");", "\n}", "\n\n", "int main()", "\n{", "\n    int n;", "\n    while(~scanf(\"%d\",&n))", "\n    {", "\n        conversion(n);", "\n    }", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把出错的信息截下图&lt;br /&gt;另外&amp;#xff0c;你的代码来源有没有要求 用哪个版本的django?   django 有几个大版本。各个版本的写法有所区别。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["Django   new_topic() got an unexpected keyword argument 'topic_id'", ["forms.py\n", "from", " django ", "import", " forms\n\n", "from", " .models ", "import", " Topic,Entry\n\n\n", "class", " ", "TopicForm", "(forms.ModelForm):\n    ", "class", " ", "Meta", ":\n        model = Topic\n        fields = [", "'text'", "]\n        labels = {", "'text'", ": ", "''", "}\n\n\n", "class", " ", "EntryForm", "(forms.ModelForm):\n    ", "\"\"\"用于添加新条目的表单\"\"\"", "\n    ", "class", " ", "Meta", ":\n        model = Entry\n        fields = [", "'text'", "]\n        labels = {", "'text'", ": ", "''", "}\n        widgets = {", "'text'", ": forms.Textarea(attrs={", "'cols'", ": ", "80", "})}\nurls.py\n", "\"\"\"定义learning_logs的URL模式\"\"\"", "\n", "from", " django.conf.urls ", "import", " url\n", "#从当前的urls.py所在文件夹导入views", "\n", "from", " . ", "import", "  views\n\n", "# 包含可在应用程序learning_ logs中请求的网页", "\nurlpatterns = [\n    ", "#主页", "\n    url(", "r'^$'", ",views.index,name=", "'index'", "),\n    ", "#显示所有的主题", "\n    url(", "r'^topics/$'", ",views.topics,name=", "'topics'", "),\n    ", "#特定主题的详细页面", "\n    url(", "r'^topics/(?P<topic_id>\\d+)/$'", ",views.topic,name=", "'topic'", "),\n    ", "#用于添加新主题的网页", "\n    url(", "r'^new_topic/$'", ",views.new_topic,name=", "'new_topic'", "),\n    ", "#用于添加新条目的页面", "\n    url(", "r'^new_entry/(?P<topic_id>\\d+)/$'", ",views.new_topic,name=", "\"new_entry\"", "),\n\n]\nviews.py\n ", "from", " django.shortcuts ", "import", " render\n\n", "from", " django.http ", "import", " HttpResponseRedirect\n\n", "from", " django.urls ", "import", " reverse\n\n", "from", " .models ", "import", " Topic\n", "from", " .forms ", "import", " TopicForm,EntryForm\n\n\n", "# Create your views here.", "\n", "def", " ", "index", "(", "request", "):\n    ", "\"\"\"学习笔记的主题\"\"\"", "\n    ", "return", " render(request, ", "'learning_logs/index.html'", ")\n\n\n", "def", " ", "topics", "(", "request", "):\n    ", "\"\"\"显示所有的主题\"\"\"", "\n    topics = Topic.objects.order_by(", "'date_added'", ")\n    context = {", "'topics'", ": topics}\n    ", "return", " render(request, ", "'learning_logs/topics.html'", ", context)\n\n\n", "def", " ", "topic", "(", "request, topic_id", "):\n    ", "\"\"\"显示单个主题及其所有的条目\"\"\"", "\n    topic = Topic.objects.get(", "id", "=topic_id)\n    entries = topic.entry_set.order_by(", "'-date_added'", ")\n    context = {", "'topic'", ": topic, ", "'entries'", ": entries}\n    ", "return", " render(request, ", "'learning_logs/topic.html'", ", context)\n\n\n", "def", " ", "new_topic", "(", "request", "):\n    ", "\"\"\"添加新主题\"\"\"", "\n    ", "if", " request.method != ", "'POST'", ":\n        ", "# 未提交数据，创建一个新表单", "\n        form = TopicForm()\n    ", "else", ":\n        ", "# POST提交数据，对数据处理.我们使用用户输入的数据（它们存储在request.POST中）创建一个TopicForm实例", "\n        form = TopicForm(request.POST)\n        ", "# is_valid()核实用户填写了所有必不可少的字段,且输入的数据与要求的字段类型一致", "\n        ", "if", " form.is_valid():\n            ", "# 表单中的数据写入数据库", "\n            form.save()\n        ", "return", " HttpResponseRedirect(reserve(", "'learning_logs:topics'", "))\n\n    context = {", "'form'", ": form}\n    ", "return", " render(request, ", "'learning_logs/new_topic.html'", ", context)\n\n\n", "def", " ", "new_entry", "(", "request, topic_id", "):\n    ", "\"\"\"添加新条目\"\"\"", "\n    topic = Topic.objects.get(", "id", "=topic_id)\n\n    ", "if", " request.method != ", "'POST'", ":\n        ", "# 没提交数据，建立一个空表单", "\n        form = EntryFrom()\n\n    ", "else", ":\n         ", "# POST提交数据，对数据处理", "\n         form = EntryFrom(data=request.POST)\n         ", "if", " form.is_valid():\n            new_entry = form.save(commit=", "False", ")\n            new_entry.topic = topic\n            new_entry.save()\n            ", "return", " HttpResponseRedirect(reserve(", "'learning_logs:topic'", ", args=[topic_id]))\n\n    context = {", "'topic'", ": topic, ", "'form'", ": form}\n    ", "return", " render(request, ", "'learning_logs/new_entry.html'", ", context)\n\n\n\n\n", "\n", "我找不到错误，获得意外参数要怎么解决？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;、\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; T&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[](&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;和&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; T&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[](&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;;\n两个函数名称相同、参数数量以及类型相同&amp;#xff0c;这需要修改\n&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;、在\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Array&amp;lt;T&amp;gt;::&lt;span class=\"hljs-built_in\"&gt;resize&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz)\n函数里面&amp;#xff0c;没有传入n&amp;#xff0c;也没有在在函数内部定义\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["编译器报错这bug怎么改?", ["\n", "#", "pragma", " once", "\n", "#", "include", " ", "<cassert>", "\n", "//数组类模板定义", "\n", "template", "<", "class", " ", "T", ">\n", "class", " ", "Array", " {\n", "private", ":\n    T* list;", "//T型指针，用于存放动态分配的数组内存首地址", "\n    ", "int", " size;", "//数组大小（元素个数）", "\n", "public", ":\n    ", "Array", "(", "int", " sz = ", "50", ");", "//构造函数", "\n    ", "Array", "(", "const", " Array<T>& a);", "//复制构造函数", "\n    ~", "Array", "();", "//析构函数", "\n    Array<T>& ", "operator", " = (", "const", " Array<T>&rhs);\n    ", "const", " T& ", "operator", "[](", "int", " n)", "const", ";\n    ", "//重载“=”使数组对象可以整体赋值", "\n    T& opeator[](", "int", " i);", "//重载“[ ]”，使Array对象可以起到C++普通数组的作用", "\n    ", "const", " T& ", "operator", "[](", "int", " i)", "const", ";\n    T& ", "operator", "[](", "int", " i);\n    ", "//“[ ]”运算符的const版本", "\n    ", "operator", " T* ();", "//重载到T*类型的转换，使Array对象可以起到C++普通数组的作用", "\n    ", "operator", " ", "const", " T* ()", "const", ";", "//const版", "\n    ", "int", " ", "getSize", "()", "const", ";", "//取数组大小", "\n    ", "void", " ", "resize", "(", "int", " sz)", ";", "//修改数组大小", "\n\n};\n", "//构造函数", "\n", "template", "<", "class", " ", "T", ">\nArray<T>::", "Array", "(", "int", " sz) {\n    ", "assert", "(sz >= ", "0", ");", "//sz为数组大小，应当非负", "\n    size = sz;", "//将元素个数赋值给变量size", "\n    list = ", "new", " T[size];", "//动态分配size个T类型的元素空间", "\n}\n\n", "//析构函数", "\n", "template", "<", "class", " ", "T", ">\nArray<T>::~", "Array", "()\n{\n    ", "delete", "[]list;\n}\n\n", "//复制构造函数", "\n", "template", "<", "class", " ", "T", ">\nArray<T>::", "Array", "(", "const", " Array<T>& a)\n{\n    ", "//从对象x取得数组大小，并复制给当前对象的成员", "\n    size = a.size;\n    ", "//为对象申请内存并进行出错检查", "\n    list = ", "new", " T[size];", "//动态分配n个T类型的空间", "\n    ", "//从对象X复制数组元素到本对象", "\n    ", "for", " (", "int", " i = ", "0", "; i < size; i++)\n        list[i] = a.list[i];\n}\n\n", "//重载“=”运算符，将对象rhs复制给本对象，实现对象间的整体赋值、", "\n", "template", "<", "class", " ", "T", ">\nArray<T>& Array<T>::", "operator", "=(", "const", " Array<T>& rhs)\n{\n    ", "//如果本对象中数组大小与rhs不同。则删除数组原有内存，然后重新分配", "\n    ", "if", " (size != rhs.size)\n    {\n        ", "delete", "[]list;", "//删除数组原有内存", "\n        size = rhs.size;", "//设置本对象的数组大小", "\n        list = ", "new", " T[size];", "//重新分配n个元素的内存", "\n    }\n    ", "//从对象X复制数组元素到本对象", "\n    ", "for", " (", "int", " i = ", "0", "; i < size; i++)\n    {\n        list[i] = rhs.list[i];\n    }\n    ", "return", " *", "this", ";\n}\n", "//重载下标运算符，实现与普通数组一样通过下标访问元素，并具有越界检查的功能", "\n", "template", "<", "class", " ", "T", ">\nT& Array<T>::", "operator", "[](", "int", " n)\n{\n    ", "assert", "(n >= ", "0", " && n < size);\n    ", "return", " list[n];\n}\n", "template", "<", "class", " ", "T", ">\n", "const", " T& Array<T>::", "operator", "[](", "int", " n)", "const", "\n{\n    ", "assert", "(n >= ", "0", " && n < size);\n    ", "return", " list[n];\n}\n\n", "//重载指针转换运算符，将Array类的对象名转换为T类型的指针，指向当前对象中的私有数组", "\n", "//因而可以像使用普通数组一样使用Array类的对象名", "\n", "template", "<", "class", " ", "T", ">\nArray<T>::", "operator", " T* ()\n{\n    ", "return", " list;\n}\n\n", "template", "<", "class", " ", "T", ">\nArray<T>::", "operator", " ", "const", " T* ()", "const", "\n{\n    ", "return", " list;\n}\n", "//取当前数组的大小", "\n", "template", "<", "class", " ", "T", ">\n", "int", " Array<T>::", "getSize", "()", "const", "\n{\n    ", "return", " size;\n}\n", "//将数组大小修改为sz", "\n", "template", "<", "class", " ", "T", ">\n", "void", " Array<T>::", "resize", "(", "int", " sz)\n{\n    ", "assert", "(sz >= ", "0", ");\n    ", "if", " (sz == size)\n    {\n        ", "return", ";\n    }\n    T* newList = ", "new", " T[sz];\n    ", "int", " m = (sz < size) ? sz : size;\n    ", "//将原有数组中前n个复制到新数组中", "\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        newList[i] = list[i];\n        ", "delete", "[]list;", "//删除元数组", "\n        list = newList;", "//使list指向新数组", "\n        size = sz;", "//更新size;", "\n    }\n}\n\n```c++\n\n", "// 9-3数组类.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。", "\n\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<iomanip>", "\n", "#", "include", " ", "\"Array.h\"", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    Array<", "int", ">", "a", "(", "10", ");\n    ", "int", " count = ", "0", ";", "//存储质数的数组，初始状态有10个元素", "\n    ", "int", " n;\n    cout << ", "\"Enter a value>=1 as upper limit for prime numbers:\"", ";\n    cin >> n;\n    ", "for", " (", "int", " i = ", "2", "; i <= n; i++)\n    {\n        ", "//检查i是否能被比他小的质数整除", "\n        ", "bool", " isPrime = ", "true", ";\n        ", "for", " (", "int", " j = ", "0", "; j < count; j++)\n        {\n            ", "if", " (i % a[j] == ", "0", ")", "//若i被a[j]整除，说明i不是质数", "\n            {\n                isPrime = ", "false", ";\n                ", "break", ";\n            }\n        }\n    ", "//把i写入质数中", "\n        ", "if", " (isPrime)\n        {\n            ", "if", " (count == a.", "getSize", "())\n                a.", "resize", "(count * ", "2", ");\n            a[count++] = i;\n        }\n    }\n    \n\n}\n\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "这是因为nextInt方法不会丢弃换行符，输入的换行符还留在缓冲流中，所以下一次调用nextLine时这个遗留回车就被直接读取了，所以要先把这个换行符丢弃\r\n\r\n```\r\ncase 1:{\r\n                System.out.println(\"1.添加新菜\");\r\n                System.out.println(\"2.添加饮料\");\r\n                System.out.println(\"3.删除菜品\");\r\n                System.out.println(\"4.更改价格\");\r\n                System.out.println(\"请选择：\");\r\n                int num02 = reader.nextInt();\r\n                switch(num02){\r\n                case 1:{\r\n                    System.out.println(\"请输入菜名:\");\r\n\t\t\t\t\t\t\t\t\t\treader.nextLine();//丢弃换行符\r\n                    String vname = reader.nextLine();\r\n                    System.out.println(\"请输入价格：\");\r\n                    double vprice =reader02.nextDouble();\r\n                    System.out.println(\"请输入菜品：\");\r\n                    String vtype = reader.nextLine();\r\n                    infor = new VegeInfor(vname,vprice,vtype);//给构造函数送值\r\n                    menu.addNewMeal(infor);\r\n                }\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["Scanner对象读取无效，直接跳过了控制台输入", ["import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Show {\n    public void showMainMenu()throws IOException{\n        System.out.println(\"****************************\");\n        System.out.println(\"** 欢迎来到我们的餐饮管理系统  **\");\n        System.out.println(\"****************************\");\n        //定义一个循环标志位\n        boolean flag = true;\n        //创建对象调用方法\n        ManageMenu menu =new ManageMenu();\n        VegeInfor infor = new VegeInfor();\n        Scanner reader = new Scanner(System.in);//这个读字符类型的\n        Scanner reader02 = new Scanner(System.in);\n        while(flag){        \n            System.out.println(\"    主菜单\");\n            System.out.println(\"1.菜单管理\");\n            System.out.println(\"2.财务管理\");\n            System.out.println(\"3.人事管理\");\n            System.out.println(\"4.食材管理\");\n            System.out.println(\"5.退出本系统\");\n            System.out.println(\"请选输入要进行的项目编号：\");\n\n            int num = reader.nextInt();\n\n            switch(num){\n            case 1:{\n                System.out.println(\"1.添加新菜\");\n                System.out.println(\"2.添加饮料\");\n                System.out.println(\"3.删除菜品\");\n                System.out.println(\"4.更改价格\");\n                System.out.println(\"请选择：\");\n                int num02 = reader.nextInt();\n                switch(num02){\n                case 1:{\n                    System.out.println(\"请输入菜名:\");\n                    String vname = reader.nextLine();\n                    System.out.println(\"请输入价格：\");\n                    double vprice =reader02.nextDouble();\n                    System.out.println(\"请输入菜品：\");\n                    String vtype = reader.nextLine();\n                    infor = new VegeInfor(vname,vprice,vtype);//给构造函数送值\n                    menu.addNewMeal(infor);\n                }\n                }//switch\n\n            }\n            }\n        }\n    }\n}\n\n", "\n\n", "运行结果：", "\n\n", "** 欢迎来到我们的餐饮管理系统  **", "\n\n", "主菜单\n", "\n\n", "1.菜单管理", "\n2.财务管理", "\n3.人事管理", "\n4.食材管理", "\n5.退出本系统", "\n请选输入要进行的项目编号：", "\n1", "\n1.添加新菜", "\n2.添加饮料", "\n3.删除菜品", "\n4.更改价格", "\n请选择：", "\n1", "\n请输入菜名:", "\n请输入价格：", "\n\n", "就是到这出现了问题，没有输入菜名直接要输入价格"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;仅供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;\nusing namespace std;\nstruct huffTree {\n    int parent;\n    int lchild;\n    int rchild;\n    int weight;\n    string flag;\n};\nstruct Lowest_node {\n    char ch;\n    int ch_num;\n};\nvoid coding&lt;span class=\"hljs-params\"&gt;(int length,huffTree *tree,int n,int &amp;amp;a,int &amp;amp;b)&lt;/span&gt; {\n    int i;\n    int r,s;\n\n    r&amp;#61;s&amp;#61;length;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(tree[i].weight&amp;lt;r\n         &amp;amp;&amp;amp; tree[i].&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; {\n            r&amp;#61;tree[i]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n            a&amp;#61;i;\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;n;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(tree[i].weight&amp;lt;s\n         &amp;amp;&amp;amp; i!&amp;#61;a\n         &amp;amp;&amp;amp; tree[i].&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; {\n            s&amp;#61;tree[i]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n            b&amp;#61;i;\n        }\n    }\n}\nvoid frequency&lt;span class=\"hljs-params\"&gt;(string str)&lt;/span&gt; {\n    int i,j;\n    int length&amp;#61;str.length&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n    Lowest_node *node&amp;#61;new Lowest_node[length];\n\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; node[i]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;0&lt;/span&gt;;\n\n    int char_type_num&amp;#61;0;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(str[i]&amp;#61;&amp;#61;node[j].ch\n            || (&amp;#39;a&amp;#39;&amp;lt;&amp;#61;node[j].ch &amp;amp;&amp;amp; node[j].ch&amp;lt;&amp;#61;&amp;#39;z&amp;#39;\n                &amp;amp;&amp;amp; str[i]&amp;#43;&lt;span class=\"hljs-attr\"&gt;32&lt;/span&gt;&amp;#61;&amp;#61;node[j].ch)&lt;/span&gt;)\n                break;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(j&amp;lt;char_type_num)&lt;/span&gt; node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;#43;&amp;#43;;\n        else {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(&amp;#39;A&amp;#39;&amp;lt;&amp;#61;str[i] &amp;amp;&amp;amp; str[i] &amp;lt;&amp;#61; &amp;#39;Z&amp;#39;)&lt;/span&gt; node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;str&lt;/span&gt;[i]&amp;#43;32;\n            else node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;str&lt;/span&gt;[i];\n            node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;#43;&amp;#43;;\n            char_type_num&amp;#43;&amp;#43;;\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;i;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(node[j].ch_num&amp;lt;node[j&amp;#43;1].ch_num)&lt;/span&gt; {\n                int temp;\n                char ch_temp;\n                temp&amp;#61;node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n                ch_temp&amp;#61;node[j]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;;\n                node[j]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;node&lt;/span&gt;[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n                node[j]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;node&lt;/span&gt;[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;;\n                node[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch_num&amp;#61;temp&lt;/span&gt;;\n                node[j&amp;#43;1]&lt;span class=\"hljs-string\"&gt;.ch&amp;#61;ch_temp&lt;/span&gt;;\n            }\n        }\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt;\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;字符&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;出现了&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;次&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    huffTree *huff&amp;#61;new huffTree[2*char_type_num-1];\n    huffTree temp;\n    string *code&amp;#61;new string[2*char_type_num-1];\n\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;2*char_type_num-1;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        huff[i]&lt;span class=\"hljs-string\"&gt;.lchild&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.rchild&amp;#61;-1&lt;/span&gt;;\n        huff[i]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;-1&lt;/span&gt;;\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; huff[j]&lt;span class=\"hljs-string\"&gt;.weight&amp;#61;node&lt;/span&gt;[j]&lt;span class=\"hljs-string\"&gt;.ch_num&lt;/span&gt;;\n    int min1,min2;\n    for &lt;span class=\"hljs-params\"&gt;(int &lt;span class=\"hljs-attr\"&gt;k&lt;/span&gt;&amp;#61;char_type_num;k&amp;lt;2*char_type_num-1;k&amp;#43;&amp;#43;)&lt;/span&gt; {\n        coding&lt;span class=\"hljs-params\"&gt;(length,huff,k,min1,min2)&lt;/span&gt;;\n        huff[min1]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;k&lt;/span&gt;;\n        huff[min2]&lt;span class=\"hljs-string\"&gt;.parent&amp;#61;k&lt;/span&gt;;\n        huff[min1]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;0&amp;#34;&lt;/span&gt;;\n        huff[min2]&lt;span class=\"hljs-string\"&gt;.flag&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.lchild&amp;#61;min1&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.rchild&amp;#61;min2&lt;/span&gt;;\n        huff[k]&lt;span class=\"hljs-string\"&gt;.weight&amp;#61;huff&lt;/span&gt;[min1]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;&amp;#43;huff[min2]&lt;span class=\"hljs-string\"&gt;.weight&lt;/span&gt;;\n    }\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; {\n        temp&amp;#61;huff[i];\n        while &lt;span class=\"hljs-params\"&gt;(1)&lt;/span&gt; {\n            code[i]&amp;#61;temp.flag&amp;#43;code[i];\n            temp&amp;#61;huff[temp.parent];\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(temp.&lt;span class=\"hljs-attr\"&gt;parent&lt;/span&gt;&amp;#61;&amp;#61;-1)&lt;/span&gt; break;&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;\n        }\n    }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;字符串的每个字符huffman编码为&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;char_type_num;i&amp;#43;&amp;#43;)&lt;/span&gt; cout&amp;lt;&amp;lt;node[i]&lt;span class=\"hljs-string\"&gt;.ch&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;  &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;code[i]&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;整个字符串的huffman编码为&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;i&lt;/span&gt;&amp;#61;0;i&amp;lt;length;i&amp;#43;&amp;#43;)&lt;/span&gt; {                                                                                     &lt;span class=\"hljs-string\"&gt;//S&lt;/span&gt;?\n        for &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-attr\"&gt;j&lt;/span&gt;&amp;#61;0;j&amp;lt;char_type_num;j&amp;#43;&amp;#43;)&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(str[i]&amp;#61;&amp;#61;node[j].ch)&lt;/span&gt;\n                cout&amp;lt;&amp;lt;code[j];\n        }\n    }\n    delete[] node;\n    node&amp;#61;NULL;\n    delete[] huff;\n    huff&amp;#61;NULL;\n    delete[] code;\n    code&amp;#61;NULL;\n}\nint main&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; {\n    int length&amp;#61;0;\n    string str;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个字符串&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin&amp;gt;&amp;gt;str;\n    frequency&lt;span class=\"hljs-params\"&gt;(str)&lt;/span&gt;;\n    return 0;\n}\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;请输入一个字符串&amp;#xff1a;2333abcde\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符3出现了3次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符2出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符a出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符b出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符c出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符d出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符e出现了1次\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;字符串的每个字符huffman编码为&amp;#xff1a;\n&lt;span class=\"hljs-string\"&gt;//3&lt;/span&gt;  11\n&lt;span class=\"hljs-string\"&gt;//2&lt;/span&gt;  000\n&lt;span class=\"hljs-string\"&gt;//a&lt;/span&gt;  001\n&lt;span class=\"hljs-string\"&gt;//b&lt;/span&gt;  010\n&lt;span class=\"hljs-string\"&gt;//c&lt;/span&gt;  011\n&lt;span class=\"hljs-string\"&gt;//d&lt;/span&gt;  100\n&lt;span class=\"hljs-string\"&gt;//e&lt;/span&gt;  101\n&lt;span class=\"hljs-string\"&gt;//&lt;/span&gt;整个字符串的huffman编码为&amp;#xff1a;\n&lt;span class=\"hljs-string\"&gt;//000111111001010011100101&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["哈夫曼算法的编码译码系统", ["实现一个哈夫曼编码系统，系统包括以下功能：", "\n", "字符信息统计：读取待编码的源文件SourceFile.txt，统计出现的字符及其频率。", "建立哈夫曼树：根据统计结果建立哈夫曼树。", "建立哈夫曼码表：利用得到的哈夫曼树，将各字符对应的编码表保存在文件Code.txt中。", "对源文件进行编码：根据哈夫曼码表，将SourceFile.txt中的字符转换成相应的编码文件ResultFile.txt。", "\n", "#define _CRT_SECURE_NO_WARNINGS 1", "#include <stdio.h>", "#include <malloc.h>", "#include <string.h>", "#define MAXVALUE 32767        //极大值相当于无穷大", "#define NODENUM 10            //叶子结点数", "typedef struct", "{", "    char data;                //数据域", "    int weight;                //结点的权值", "    int parent, lch, rch;    //下标", "}htNode,*huffmanTree;        ", "\n", "typedef char** huffmanCode;    //第一个", "是代表它是指针变量，说明它是数组", "                            //第二个", "说明它是指针数组，代表这个char类型数组里每个元素都是*huffmanCode变量", "\n", "int initHuffmanTree(huffmanTree& HT);                                //初始化哈夫曼树", "void creatHuffmanTree(huffmanTree& HT, int n);                        //构建哈夫曼树", "void createHuffmanCode(huffmanTree HT, huffmanCode &HC, int n);        //编写哈夫曼编码", "int main()", "{", "    huffmanTree HT ;", "    initHuffmanTree(HT);", "    huffmanCode HC;", "    creatHuffmanTree(HT,NODENUM);", "    createHuffmanCode(HT,HC,NODENUM);", "    /", "for (int i = NODENUM + 1; i <= 2 * NODENUM - 1; i++)", "        printf(\"%d \", HT[i].weight);", "/", "    for (int i = 1; i <= NODENUM; i++)                                //遍历输出编码", "    {", "        printf(\"%c:\\t\",HT[i].data);", "        printf(\"%s\\n\", HC[i]);", "    }", "    return 0;", "}", "int initHuffmanTree(huffmanTree& HT)", "{", "    HT = (htNode*)malloc(sizeof(htNode) * (2 * NODENUM));            //给HT分配2 * NODENUM个htNOde大小的htNode类型的数组", "    for (int i = 1; i <= 2 * NODENUM - 1; i++)                        //下标从1开始到2 * NODENUM", "    {", "        HT[i].parent = HT[i].lch = HT[i].rch = -1;                    //双亲和  的值都置为-1", "    }", "    printf(\"please input some weight!\\n\");", "    for (int i = 1; i <= NODENUM; i++)                                //权值只有1-n个", "    {", "        scanf(\"%d\",&HT[i].weight);                                    //给每个结点赋予权值", "    }", "        char c = getchar();                                            //这个来接收上面的回车", "    printf(\"please input some data!\\n\");", "    for (int i = 1; i <= NODENUM; i++)", "    {", "            //scanf(\"%c \",&HT[i].data);", "            char a = getchar();", "        if(a == '\\n')                                                //遇到回车就结束", "            break;", "        else", "            HT[i].data = a;                                            //给每个结点赋予数据", "    }", "\n", "return", " ", "1", ";\n", "\n", "}", "\n", "void creatHuffmanTree(huffmanTree& HT, int n)", "{", "    if (n <= 1)                                                            //如果结点数小于等于1，不创建", "        return;", "    int min1, min2;                                                        //定义两个数，来存储每次选取最小两个结点的权值", "    int rnode, lnode;                                                    //定义两个下标值，来存储每次选取最小两个结点的下标", "    for (int i = n + 1; i <= 2 * n -1; i++)                                //要生成n-1个结点，所以要操作n—1次且从下标为n+1开始存储", "    {", "        int min1 = MAXVALUE; int lnode = -1;                            //让最小值初始化为极大值，这样叶子结点的最大值再大也不会超过这个值了", "        int min2 = MAXVALUE; int rnode = -1;", "        for (int j = 1; j <= i - 1; j++)                                //因为起先是在前n个中选择最小的两个结点的权值，但新生成一个后就得在前n+1个中选择最小的两个结点的权值", "        {                                                                //假设n = 10 总结点数就得为19，那我们就只要比较18次就可以得出结果了，记住比较的次数比生成的总结点数少1", "                if (HT[j].weight < min1 && HT[j].parent == -1)            //这个小于就使得当出现相同的权值时优先考虑先出现的值，可以假设下", "                {", "                    min2 = min1;    rnode = lnode;                        //碰到比min1小的，那min1的值就给第二小的min2，下标也给它", "                    min1 = HT[j].weight; lnode = j;                        //然后最小的给min1，下标同理", "                }", "                else if (HT[j].weight < min2 && HT[j].parent == -1)        //这是第二小的判断", "                {", "                    min2 = HT[j].weight;", "                    rnode = j;", "                }", "        }", "        HT[lnode].parent = HT[rnode].parent = i;                        //最小两个结点的parent变为生成结点的下标", "        HT[i].lch = lnode; HT[i].rch = rnode;                            //生成结点的左为最小的min1的下标，右同理", "        HT[i].weight = HT[lnode].weight + HT[rnode].weight;                //生成结点的权值等于最小结点的权值相加", "    }", "\n", "}", "\n", "void createHuffmanCode(huffmanTree HT, huffmanCode& HC, int n)", "{", "    HC = (huffmanCode)malloc(sizeof(huffmanCode) * n + 1);                //申请n + 1个huffmanCode大小huffmanCode类型的临时空间", "                                                                        //因为下标是从一开始，所以我们要申请比结点多一个的结点，和哈夫曼树的结构对应，方便输出", "    char* cd = (char*)malloc(sizeof(char) * n);                            //申请n个char大小char类型的临时空间，这个临时数组记录每次遍历出来的编码", "    int start = 0,c = 0,f = 0;                                            //start为cd数组记录下标，c初始为叶子结点下标，而后就是  结点的下标，f记录双亲结点的下标", "    cd[n - 1] = '\\0';                                                    //这个就是给printf留着的，因为printf不会生成'\\0'，如果用puts就不用这句语句了", "    for (int i = 1; i <= n; i++)                                        //只要叶子结点的编码", "    {", "        start = n - 1;                                                    //这句要赋值n的话，start--要写在判断后方", "        c = i;", "        f = HT[c].parent;", "        while (f != -1)                                                    //根节点没有双亲", "        {", "            start--;", "            if (HT[f].lch == c)                                            //是左就是0，右就为1", "                cd[start] = '0';", "            else", "                cd[start] = '1';", "            c = f; f = HT[c].parent;                                    //向根结点接近", "        }", "        HC[i] = (char*)malloc(sizeof(char) * (n - start));                //给数组里的数组申请n - start个char大小的char*类型的临时空间", "        strcpy(HC[i], &cd[start]);                                        //cd里记录的编码给HC的第i个数组", "    }", "    free(cd);                                                            //释放临时空间", "}", "想问一问为什么输入字符后程序闪退\n "]], "Tag": "程序设计"}
{"Answer": "问题已解决，谢谢大家的无语让我自己解决了。", "Konwledge_Point": "定义新的类型", "Question": ["VC++、DLL、虚函数、调用约定", ["关于“VC++、DLL、虚函数、调用约定”的一个问题折腾我很久了，希望CSDN的朋友可以助我解决问题。", "\n\n", "DLL里，接口类的虚函数（非纯虚函数），应该怎样调用约定？", "\n\n", "背景描述：", "\n一个DLL工程A（接口），有个接口类AI，里面全是纯虚函数。", "\n一个EXE工程B（平台），有个成员变量mc类型是类AI。", "\n一个DLL工程C（游戏），有个类是类AI的子类，即实现类，对类AI的所有接口（纯虚函数）进行了实现。", "\n\n", "原理是：", "\n平台只有一个在跑，而游戏是N个，工程B（平台）的mc被赋值成工程C（游戏）的对象，通过工程A的接口，mc可以调用工程C（游戏）里的函数（接口的实现）。", "\n\n", "问题：", "\n我在开发一个新游戏时，发现工程A（接口）类AI的接口不够用，想新增一个接口，于是加入了一个”虚函数“，注意不是“纯虚函数”，为的是不影响之前所有已有的游戏（不然之前的游戏不作任何改动而编译 会报error C2259: 不能实例化抽象类），即之前的游戏不用实现这个接口，修改工程B（平台）调用这个函数时是工程A（接口）新增的接口，若游戏实现这个接口，就调用游戏里的实现函数；若游戏没有定义这个接口（之前的游戏），则调用工程A（接口）类AI里的虚函数（里面只有一句调试打印）。", "\n\n", "但发现，有的游戏是正常的，有的游戏不正常。不正常的游戏，调试工程B（平台）在调用新接口时提示：", "\nRun-Time Check Failure #0 - The value of ESP was not properly saved across a function call.  This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention.", "\n\n", "百度了一下，很多人说是调名约定的问题。", "\n工程A、工程B、所有的游戏工程C，工程选项里都是 __cdecl (/Gd)。", "\n\n", "于是我在工程A、工程C里下面几种尝试：", "\nvirtual void OnEventABC(int a, bool b); //没写调用约定，有的游戏正常，有的游戏出错", "\nvirtual void __stdcall OnEventABC(int a, bool b);   //所有的游戏都出错", "\nvirtual void __cdecl OnEventABC(int a, bool b); //所有的游戏都出错", "\nvirtual void WINAPI OnEventABC(int a, bool b);  //所有的游戏都出错", "\n\n", "请问大家，怎么解决这个问题，是调名约定的问题，还是其它什么问题？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;那你得要求输入一个字符串&amp;#xff0c;或者先循环读&amp;#xff0c;读一个完整的字符串一起判断&amp;#xff0c;而不是每个字符读进来直接判断&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言在缓冲区读取字符的问题", ["#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<stdbool.h>", "\n\n", "typedef", " ", "int", " datatype;\n", "//链表内的结构体", "\n", "typedef", " ", "struct", " ", "node", "\n{\n    datatype data;      ", "//节点数据域", "\n    ", "struct", " ", "node", "* next;  ", "//节点指针域", "\n}ND, * PND;\n", "//设计管理结构体的数据类型", "\n", "typedef", " ", "struct", " ", "linkstack", "\n{\n    ", "struct", " ", "node", "* ptop;", "//定义栈顶指针,设定类型为链表结构体指针", "\n    ", "//datatype cnt;//当前栈中有几个节点(可不用)", "\n}LST, * PLST;\n\n", "PLST ", "initstack", "(", "void", ")", "\n", "{\n    PLST pst = (PLST)", "malloc", "(", "sizeof", "(LST));\n    ", "if", " (pst == ", "NULL", ")\n        ", "return", " ", "NULL", ";\n    pst->ptop = ", "NULL", ";\n    ", "//pst->cnt = 0;//当前栈中有0个节点(可不用)", "\n    ", "return", " pst;\n}\n\n", "void", " ", "push", "(PLST pst, datatype d)", "\n", "{\n    PND pnew = (PND)", "malloc", "(", "sizeof", "(ND));\n    ", "if", " (pnew == ", "NULL", ")\n        ", "return", ";\n    ", "if", " (d >= ", "10", ")\n    {\n        d = d - ", "10", " + ", "'A'", ";\n        pnew->data = d;\n        pnew->next = ", "NULL", ";\n    }\n    ", "else", "\n    {\n        pnew->data = d;\n        pnew->next = ", "NULL", ";\n    }\n    ", "//把pnew指向的新节点的next指向当前的栈顶ptop，(也就是链上了ptop指向的地方）", "\n    pnew->next = pst->ptop;\n    pst->ptop = pnew;\n    ", "//pst->cnt++;//栈中已有元素个数加一(可不用)", "\n}\n", "bool", " ", "is_empty", "(PLST pst)", "\n", "{\n    ", "//if (pst->cnt == 0)//栈中没有节点，所以返回true(可不用)", "\n    ", "if", " (pst->ptop == ", "NULL", ")\n        ", "return", " ", "true", ";\n    ", "else", "\n        ", "return", " ", "false", ";\n}\n", "void", " ", "pop", "(PLST pst, datatype *val)", "\n", "{\n    ", "if", " (", "is_empty", "(pst))\n    {\n        ", "printf", "(", "\"the link stack is empty\\n\"", ");\n        ", "return", ";\n    }\n    *val = pst->ptop->data;\n    PND ptmp = pst->ptop;       ", "//定义一个PND类型的临时指针存ptop指针", "\n    pst->ptop = pst->ptop->next;", "//ptop向下移动一个单位，方便原节点弹出。", "\n    ", "//pst->cnt--//栈中已有元素个数减一(可不用)", "\n    ptmp->next = ", "NULL", ";          ", "//断开与栈的连接，指向空", "\n    ", "free", "(ptmp);\n    ", "return", ";\n}\n", "void", " ", "dec_to_oct", "(PLST pst, datatype d)", "\n", "{\n    ", "//1.新建空栈", "\n\n    ", "//2.循环地把d对8求余，把余数入栈", "\n    ", "//int n;", "\n    ", "while", " (d > ", "0", ")\n    {\n        ", "//基础写法", "\n        ", "//n = d % 8;", "\n        ", "//push(pst, n);", "\n        ", "//d = d / 8;", "\n\n        ", "push", "(pst, d % ", "8", ");", "//数据d求一次余，将这一次求余作为形参传递给push，pst也传过去", "\n        d = d / ", "8", ";", "//第一次求余之后，", "\n    }\n    ", "int", " val;\n\n    ", "//3.把栈中的余数出栈打印", "\n    ", "while", " (", "1", ")\n    {\n        ", "if", " (", "is_empty", "(pst))", "//如果栈为空，直接退出", "\n            ", "break", ";\n        ", "pop", "(pst, &val);", "/*pop出参数，运用值传参& val传到pop\n                       函数中去*/", "\n        ", "printf", "(", "\"%d\\t\"", ", val);\n        ", "printf", "(", "\"\\n\"", ");\n    }\n}\n", "void", " ", "dec_to_every", "(PLST pst, datatype cover, datatype base)", "\n", "{\n    ", "while", " (cover > ", "0", ")\n    {\n        ", "push", "(pst, cover % base);\n        cover = cover / base;\n    }\n\n    ", "if", " (base >= ", "10", ")\n        ", "printf", "(", "\"0x\"", ");\n    ", "else", "\n        ", "printf", "(", "\"0\"", ");\n\n    datatype val;\n    ", "while", " (", "1", ")\n    {\n        ", "if", " (", "is_empty", "(pst))\n            ", "break", ";\n        ", "pop", "(pst, &val);\n        ", "if", " (val > ", "10", ")\n            ", "printf", "(", "\"%c\"", ", val);\n        ", "else", "\n            ", "printf", "(", "\"%d\"", ", val);\n    }\n}\n", "void", " ", "cls", "(", "char", " clsn)", "\n", "{\n    ", "if", " (clsn == ", "'y'", ")\n    {\n        ", "system", "(", "\"cls\"", ");\n        ", "return", ";\n    }\n    ", "else", "\n        ", "return", ";\n}\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    datatype cover, base;\n    ", "char", " clsn, ch;\n    PLST pst = ", "initstack", "();\n    ", "printf", "(", "\"please enter the cover num (<0 to quit): \"", ");\n    ", "while", " (", "scanf_s", "(", "\"%d\"", ", &cover) && (cover > ", "0", "))\n    {\n        ", "printf", "(", "\"please enter the base num: \"", ");\n        ", "scanf_s", "(", "\"%d\"", ", &base);\n        ", "printf", "(", "\"\\nobtatin anyother num through decimal num coversion: \"", ");\n        ", "dec_to_every", "(pst, cover, base);\n        ", "while", " ((ch = ", "getchar", "()) != ", "'\\n'", ") ", "//清理多余的字符", "\n            ", "continue", ";\n        ", "printf", "(", "\"\\nwhether to claer the screen?(y/n): \"", ");\n        clsn = ", "getchar", "();\n        ", "printf", "(", "\"\\n\"", ");\n        ", "while", " ((clsn != ", "'y'", ") && (clsn != ", "'n'", "))", "//判断用户是否输入准确", "\n        {\n            ", "while", " (", "getchar", "() != ", "'\\n'", ")\n                ", "continue", ";\n            ", "printf", "(", "\"please enter n or y: \"", ");\n            clsn = ", "getchar", "();\n        }\n        ", "cls", "(clsn);\n        ", "//while (getchar() != '\\n')", "\n        ", "//    continue;", "\n        ", "printf", "(", "\"please enter the cover num again(<0 to quit): \"", ");\n    }\n\n}\n", "\n", "如这一段代码，151行 我想通过输入y或n，确认是否执行清屏函数，", "我加了一段代码154-161行，判断如果用户输入错误输入了其他的字符或者数字，则让用户重新输入y或n。", "但是当我输入  yn   或者   ny 的时候，会出现执行清屏函数，或者不执行清屏函数，要怎么改正才能在输入y或者n的时候才算正确输入。其他情况要求重新输入呀？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;InitList_L(&amp;amp;L);这里L已经定义了实例&amp;#xff0c;但到函数内有malloc是不行的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXSIZE 100&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; TRUE 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; FALSE 0&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OK 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; ERROR 0&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; INFEASIBLE -1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OVERFLOW -2&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Status;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ElemType;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LNode&lt;/span&gt; {\n    ElemType data; &lt;span class=\"hljs-comment\"&gt;//结点的数据域&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LNode&lt;/span&gt; *next; &lt;span class=\"hljs-comment\"&gt;//结点的指针域&lt;/span&gt;\n} LNode, LinkList; &lt;span class=\"hljs-comment\"&gt;//LinkList为指向结构体LNode的指针类型&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;InitList_L&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList *L)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//构造一个空的单链表L&lt;/span&gt;\n    L &amp;#61; (LNode *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode)); &lt;span class=\"hljs-comment\"&gt;//生成新结点作为头结点&amp;#xff0c;用头指针L指向头结点&lt;/span&gt;\n    L-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//头结点的指针域置空&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateList_L&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList *L,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;){\n        LNode *p&amp;#61;(LNode *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode));\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;p-&amp;gt;data);\n        p-&amp;gt;next&amp;#61;L-&amp;gt;next;\n        L-&amp;gt;next&amp;#61;p;\n        L&amp;#61;L-&amp;gt;next;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//在此处定义单链表的插入函数ListInsert_L&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ListInsert_L&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LinkList *L,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    LNode *p&amp;#61;L-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,p-&amp;gt;data);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p-&amp;gt;next!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt;);\n        }\n        p&amp;#61;p-&amp;gt;next;\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    p&amp;#61;L-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i!&amp;#61;n){\n        p&amp;#61;p-&amp;gt;next;\n        i&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(i&amp;#61;&amp;#61;n){\n        LNode *s&amp;#61;(LNode *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode));\n        s-&amp;gt;data&amp;#61;m;\n        s-&amp;gt;next&amp;#61;p-&amp;gt;next;\n        p-&amp;gt;next&amp;#61;s;\n    }\n    p&amp;#61;L-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,p-&amp;gt;data);\n        p&amp;#61;p-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt;);\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    LinkList L; &lt;span class=\"hljs-comment\"&gt;//用LinkList L;替换&amp;#xff0c;与#include &amp;#34;LinkList.h&amp;#34;配合&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n,i;\n    ElemType e;\n    &lt;span class=\"hljs-comment\"&gt;//InitList_L(&amp;amp;L);&lt;/span&gt;\n    L.next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n); &lt;span class=\"hljs-comment\"&gt;//输入元素个数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;CreateList_L&lt;/span&gt;(&amp;amp;L,n);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d&amp;#34;&lt;/span&gt;,&amp;amp;i,&amp;amp;m); &lt;span class=\"hljs-comment\"&gt;//输入插入元素的位置和元素&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;ListInsert_L&lt;/span&gt;(&amp;amp;L,i,m);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["malloc多分配内存", ["我明明分配五个空间但是遍历结果时却多出一个内存地址", "\n", "#include <stdio.h>", "#include<stdlib.h>", "#define  MAXSIZE 100", "#define TRUE 1", "#define FALSE 0", "#define OK 1", "#define ERROR 0", "#define INFEASIBLE -1", "#define OVERFLOW -2", "typedef int Status;", "typedef int ElemType;", "typedef struct LNode {", "    ElemType data; //结点的数据域", "    struct LNode *next; //结点的指针域", "} LNode, LinkList; //LinkList为指向结构体LNode的指针类型", "Status InitList_L(LinkList *L)", "{", "    //构造一个空的单链表L", "    L = (LNode *)malloc(sizeof(LNode));                //生成新结点作为头结点，用头指针L指向头结点", "    L->next = NULL;               //头结点的指针域置空", "    return OK;", "}", "void CreateList_L(LinkList *L,int n)", "{", "    for(int i=0;i<n;i++){", "        LNode *p=(LNode *)malloc(sizeof(LNode));", "        scanf(\"%d\",&p->data);", "        p->next=L->next;", "        L->next=p;", "        L=L->next;", "    }", "}", "//在此处定义单链表的插入函数ListInsert_L", "void ListInsert_L(LinkList *L,int n,int m){", "    int i=1;", "    LNode *p=L->next;", "    while(p!=NULL){", "        printf(\"%d\",p->data);", "        if(p->next!=NULL){", "            printf(\",\");", "        }", "        p=p->next;", "    }", "\n", "printf(", "\"\\n\"", ");\n", "p", "=L->", "next;\n", "while", "(i!=n){\n    ", "p", "=p->", "next;\n    i++;\n}\n", "if", "(i==n){\n    LNode *s=(LNode *)malloc(sizeof(LNode));\n    ", "s", "->", "data", "=m;\n    ", "s", "->", "next", "=p->", "next;\n    ", "p", "->", "next=s;\n}\n", "p", "=L->", "next;\n", "while", "(p!=NULL){\n    ", "printf", "(\"%d\",p->", "data", ");\n    ", "p", "=p->", "next;\n    ", "if", "(p!=NULL){\n        printf(", "\",\"", ");\n    }\n}\n", "\n", "}", "int main()", "{", "    LinkList  L;              //用LinkList L;替换，与#include \"LinkList.h\"配合", "    int n,i;", "    ElemType e;", "    InitList_L(&L);", "    scanf(\"%d\",&n);      //输入元素个数", "    CreateList_L(&L,n);", "    int m;", "    scanf(\"%d%d\",&i,&m);          //输入插入元素的位置和元素", "    ListInsert_L(&L,i,m);", "\n", "return", " ", "0", ";\n", "\n", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "因为treeSet的存储是使用treemap来实现的  结构为二叉树   你的例子中 在添加了 123三个数之后   根结点为2    左节点（比父节点小）为1  右节点为3 在这个时候插入1这个数 比较器先与2判断     返回1（新插入的1比2大） 则继续与3比较 也返回1     并没有去按照你所想的      先与1比较 \r\n\r\n也就是说 你所写的这个比较方法  插入同样的数 可能会因为不同的插入顺序 导致不同的结果。", "Konwledge_Point": "定义新的类型", "Question": ["求助一个自己写程序中的关于TreeSet同时去重和按加入顺序存储的bug。", ["昨天在写一个题目其中一块的任务是：将一些字符串去重，并且按给你时候的顺序输出出来，我没有想到用LinkedHashSet，第一想到的是使用TreeSet，故构造一个带comparator的treeset，让俩东西相等时候输出0，表示重复，那么treeset应该会不添加这个新元素，其余情况输出1表示直接添加到末尾，不做交换。然鹅实际情况与我想象的不一样，重复元素出现在特定位置时候无法去除（这一部分我通过debug   自己定义的compartatoro1,o2进行了对比已经证实comparator书写正确，是没有进行全遍历而造成的无法识别重复）。为了简单复现这个问题，我书写了加入简单integer类型的treeset，代码如下", "\n\n", "public class Tree {\n\n    public static void main(String[] args) {\n        TreeSet<Integer> treeSet = new TreeSet<>(new Comparator<Integer>() {\n\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                // TODO Auto-generated method stub\n                if(o1.equals(o2))\n                {\n                    return 0;\n                }\n                return 1;\n            }\n        }); \n        treeSet.add(1);\n        treeSet.add(2);\n        treeSet.add(3);\n        treeSet.add(1);\n        treeSet.add(4);\n        treeSet.add(1);\n        treeSet.add(5);\n        treeSet.add(7);\n        treeSet.add(1);\n        treeSet.add(6);\n        treeSet.add(7);\n        treeSet.add(1);\n        for(int i : treeSet)\n        {\n            System.out.println(i);\n        }\n    }\n}\n", "\n\n", "这个代码也许你以为会输出1,2,3,4,5,7,6", "\n但是实际情况是", "\n1", "\n2", "\n3", "\n1", "\n4", "\n5", "\n7", "\n6", "\n根据debug结果可以发现在加入第二个1时候（也就是加入这个1之前是1,2,3），这时候我认为加入1之后o1一直作为1，去和剩余3个元素作对比，如果重复就不会添加，然鹅实际情况再一次不同，o1一直作为1，也就是新添加的元素，只与2,3做了对比（也就是o2元素只遍历了2,3这两个）就结束了，程序发现并没有重复，因为根本就没看开头位置的东西是1，当然认为无重复，就把1又加了进去。", "\n这个同理可以验证到字符串上面，并且更多的试验表明在总长超过6之后下标为2的元素也不会被o2遍历到。", "\n小弟长时间自己思考，百度源码结论都应该是冒泡逐个遍历，但是并没能解决，还请各位老师指点一二。非常感谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你 Ship()类中只定义了 self.screen_rect 属性,没有定义 self.screen 属性啊&lt;/p&gt;\n&lt;p&gt;Ship的def &lt;strong&gt;init&lt;/strong&gt;():方法中应该加上self.screen &amp;#61; screen 吧&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;# ship.py&lt;/span&gt;\n \n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; pygame\n \n \n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Ship&lt;/span&gt;():\n \n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, screen&lt;/span&gt;):\n        &lt;span class=\"hljs-comment\"&gt;# 初始化飞船并获取其初始位置&lt;/span&gt;\n \n        &lt;span class=\"hljs-comment\"&gt;# 加载飞船图像并获取其外接矩形&lt;/span&gt;\n        self.screen &amp;#61; screen  &lt;span class=\"hljs-comment\"&gt;#****************加上这行 &lt;/span&gt;\n        self.image &amp;#61; pygame.image.load(&lt;span class=\"hljs-string\"&gt;&amp;#34;images/ship.bmp&amp;#34;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 返回了飞船的surface&amp;#xff0c;并存储到self.image&lt;/span&gt;\n        self.rect &amp;#61; self.image.get_rect()  &lt;span class=\"hljs-comment\"&gt;# 通过get_rect()活动相应surface的属性rect。&amp;#xff08;矩形即rect对象&amp;#xff09;&lt;/span&gt;\n        self.screen_rect &amp;#61; screen.get_rect()  &lt;span class=\"hljs-comment\"&gt;# 将矩形存储到self.screent_rect&lt;/span&gt;\n \n        &lt;span class=\"hljs-comment\"&gt;# 将每艘新飞船放到屏幕底部中央&lt;/span&gt;\n        self.rect.centerx &amp;#61; self.screen_rect.centerx  \n        self.rect.bottom &amp;#61; self.screen_rect.bottom\n \n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;blitme&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):  &lt;span class=\"hljs-comment\"&gt;# 定义此方法&amp;#xff0c;让它根据self.rect的位置将图像绘制到屏幕上&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;# 在指定位置绘制飞船&lt;/span&gt;\n        self.screen.blit(self.image, self.rect)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "定义新的类型", "Question": ["python从入门到实践中的飞船项目，其显示AttributeError: 'Ship' object has no attribute 'screen，怎么解决？", ["问题如标题所述，代码运行显示如下错误：AttributeError: 'Ship' object has no attribute 'screen", "\n", "代码如下:", "\n", "分为三个文件：ship.py,alien_invasion.py,settings.py", "\n", "# ship.py", "\n\n", "import", " pygame\n\n\n", "class", " ", "Ship", "():\n\n    ", "def", " ", "__init__", "(", "self, screen", "):\n        ", "# 初始化飞船并获取其初始位置", "\n\n        ", "# 加载飞船图像并获取其外接矩形", "\n        self.image = pygame.image.load(", "\"images/ship.bmp\"", ")  ", "# 返回了飞船的surface，并存储到self.image", "\n        self.rect = self.image.get_rect()  ", "# 通过get_rect()活动相应surface的属性rect。（矩形即rect对象）", "\n        self.screen_rect = screen.get_rect()  ", "# 将矩形存储到self.screent_rect", "\n\n        ", "# 将每艘新飞船放到屏幕底部中央", "\n        self.rect.centerx = self.screen_rect.centerx  \n        self.rect.bottom = self.screen_rect.bottom\n\n    ", "def", " ", "blitme", "(", "self", "):  ", "# 定义此方法，让它根据self.rect的位置将图像绘制到屏幕上", "\n        ", "# 在指定位置绘制飞船", "\n        self.screen.blit(self.image, self.rect)\n", "\n", "# alien_invasion.py", "\n\nimport pygame\n\nfrom settings import Settings\nfrom ship import Ship\n", "# 导入所需模块", "\n\ndef run_game():\n    ", "# 初始化游戏并创建一个屏幕对象", "\n    pygame.init()  ", "# 初始化背景设置", "\n    ai_settings = Settings()\n\n    screen = pygame.display.set_mode((ai_settings.screen_width, ai_settings.screen_height))\n    pygame.display.set_caption(", "\"Alien Invasion\"", ")  ", "# 显示在屏幕的左上角", "\n\n    ", "# 设置背景色", "\n    ", "# bg_color = (230,230,230) # RGB(红绿蓝三色)", "\n\n    ", "# 创建一艘飞船ship", "\n    ship = Ship(ai_settings, screen)\n\n    ", "# 游戏的主循环", "\n    ", "while", " True:  \n          ", "# 监视键盘和鼠标事件", "\n         ", "for", " event ", "in", " pygame.event.get():  ", "# 事件循环", "\n             ", "# pygame.event.get()方法，所有的键盘和鼠标事件都会促使for循环运行。", "\n             ", "if", " event.type == pygame.QUIT:\n                 ", "# 若玩家单机游戏窗口的关闭按钮，将检测到pygame.QUIT事件，我们将调用sys.exit()来退出游戏", "\n                 sys.", "exit", "()\n        \n        ", "# 每次循环都重绘屏幕", "\n        screen.fill(bg_color)  ", "# 用背景色填充屏幕，只接受一个实参，一种颜色", "\n        ship.blitme()\n        \n        ", "# 让最近绘制的屏幕可见", "\n        pygame.display.flip()  \n\nrun_game()\n", "\n", "# settings.py", "\n\n", "class", " ", "Settings", "():", "\n    ", "# 存储alien_invasion的所有设置的类", "\n    ", "def", " ", "__init__", "(", "self", ")", ":\n        ", "# 初始化游戏设置", "\n        ", "# 屏幕设置", "\n        ", "self", ".screen_width = ", "1200", "\n        ", "self", ".screen_height = ", "800", "\n        ", "self", ".bg_color = (", "230", ", ", "230", ", ", "230", ")\n", "\n", "个人觉得可能是由于screen的数据类型没有搞清楚，但是查了好久不知道那里错了。", "\n", "谢谢大家的帮助！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;typedef struct&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    elementdata element;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    LNode* next;&lt;/span&gt;&lt;br /&gt;}LNode;&lt;br /&gt;改成&lt;br /&gt; struct LNode&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    elementdata element;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    LNode&lt;/span&gt;* next;&lt;br /&gt;};&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["请各位帮我看看怎么改！", ["\n#include <stdlib.h>\ntypedef int Statu;\n\ntypedef struct\n{\n    int ", "data", ";\n}elementdata;\n\ntypedef struct\n{\n    elementdata element;\n    LNode* next;\n}LNode;\n", "//头指针定义时用 LNode* head;", "\n\nvoid initial_L(LNode** head)\n{\n    *head = (LNode*)malloc(sizeof(LNode));\n    (*", "head", ")->", "next = NULL;\n}\n\nvoid destroy_L(LNode** head)\n{\n    LNode* p;\n    p = *head;\n    LNode* s;\n    ", "while", " (p)\n    {\n        s = p;\n        ", "p", " = p->", "next;\n        free(s);\n    }\n    *head = ", "0", ";\n}\n\nint ListLength_L(LNode L)\n{\n    LNode* p = L.next;\n    int j = ", "0", ";\n    ", "while", " (p)", "//此处我们用p但是呢和下面不同我们是从0开始，因为我们要保证可能第一个结点就没有的情况", "\n             ", "//下面的从一开始是因为他有i和j两个变量可以包括了是否为0的情况，但是我们算起长度的时候先前是没有长度的我们", "\n             ", "//必须考虑为0的情况", "\n             ", "//如果我们此处用的就是p.next判断的话就是从1开始，要单独考虑0的时候，而且那个最终结点其实就是", "\n            ", "//要循环n次多了一次访问最后空的那一次", "\n            ", "//而我们从0开始刚好就是n-1次他已经包括了最后为空的那一次而且因为不是p.next不用对0进行讨论", "\n    {\n        ", "p", " = p->", "next;\n        j++;\n    }\n    return j;\n}\n\nStatu Location_L(LNode L, elementdata e, int* i)\n{\n    LNode* p = L.next;\n    int j = ", "1", ";", "//具体问题可以具体分析取1还是取0，因为我们这边用的是p.element.data所以是1因为他的意思是该结点的数据域所以", "\n    ", "//下标就是该结点位置", "\n    ", "while", " (p && p->", "element.", "data", " != e.", "data", ")\n    {\n        ", "p", " = p->", "next;\n        j++;\n    }\n    ", "if", " (!p)\n        return ", "0", ";\n    return j;\n}\n\nStatu GetElem_L(LNode L, int i, elementdata* e)", "//若此处**指的是head的地址，*指的是L的地址，L直接是让函数复制L中的元素", "\n{\n    ", "//L为带头结点的单链表的头指针", "\n    ", "//当第i个元素存在时，将其值赋给e并返回OK，否则ERROR", "\n    LNode* p = L.next;", "//初始化一个结点类型指针，此处和上次的动态数组不一样，动态数组因为是随机存取所以我们只需要利用索引", "\n    ", "//所以其定义的指针是elementdata指针，而在这里定义节点指针，是用来指向节点的，而不单纯是数据元素因为还有指针域", "\n    ", "//初始化指针使指针指向首元节点", "\n    int j = ", "1", ";", "//计数器为1", "\n    ", "while", " (p && j < i)\n    {\n        ", "p", " = p->", "next;\n        j++;\n    }\n    ", "//顺指针后查找知道第i个元素或者p为NULL即到了最后一个元素", "\n    ", "if", " (!p || j > i)\n        return ", "0", ";", "//第i个元素不存在 ，此处为什么还要j>i 若链表中没有元素的时候返回节点插入失败。", "\n    *", "e", " = p->", "element;\n    return ", "1", ";\n}\n\nStatu ListInsert_L(LNode* L, int i, elementdata e)", "//为什么传递指针因为要改值", "\n{\n    ", "//在带头结点的单链线性表第i个位置之前插入元素e", "\n    LNode* p = L;", "//指向头结点", "\n    int j = ", "0", ";", "//头结点时计数器为0", "\n    ", "while", " (p && j < i - ", "1", ")\n    {\n\n        ", "p", " = p->", "next;\n        j++;\n    }", "//使p指向第i-1个节点", "\n    ", "if", " (!p || j > i - ", "1", ")", "//j>i-1主要是为了判断当i小于1的时候，因为是前插所以要保证在最后一个元素之前", "\n        return ", "0", ";\n    LNode* s = (LNode*)malloc(sizeof(LNode));", "//生成新结点", "\n    ", "s", "->", "element = e;\n    ", "s", "->", "next", " = p->", "next;\n    ", "p", "->", "next = s;", "//插入e", "\n    return ", "1", ";\n}\n\nStatu ListDelete_L(LNode* L, int i, elementdata e)\n{\n    ", "//在带头结点的单链线性表中，删除第i个元素，并由e返回其值", "\n    LNode* p;\n    int j = ", "0", ";", "//头结点时计数器为0", "\n    p = L;", "//p先指向头结点，因为若没有头结点删除不方便", "\n    ", "while", " (p->", "next && j < i - ", "1", ")    ", "//使p可以指向第i-1个元素", "\n    {\n        ", "p", " = p->", "next;\n        j++;\n    }\n    ", "if", " (!p || j > i - ", "1", ")", "//位置不合适，！p是保证没有超出链表长度，j>i-1 是为了保证当i为负数时不能运行", "\n        return ", "0", ";\n    LN", "ode", "* s = p->", "next;\n    ", "p", "->", "next", " = p->", "next", "->", "next;\n    ", "e", " = s->", "element;\n    free(s);\n    return ", "1", ";\n}\n\nvoid MergeList_L(LNode* La, LNode* Lb, LNode* Lc)\n{\n    ", "//已知单链线性表La和Lb的元素按值非递减排列", "\n    ", "//归并La和Lb得到新的单链表Lc，Lc的元素也按值非递减排列", "\n    LN", "ode", "* pa = La->", "next;\n    LN", "ode", "* pb = Lb->", "next;\n    LNode* pc = Lc = La;", "//用La的头结点作为Lc的头结点", "\n    ", "while", " (pa && pb)\n    {\n        ", "if", " (pa->", "element", ".", "data", " >= pb->", "element.", "data", ")", "//结构体是不能用于比较的", "\n        {\n            ", "pc", "->", "next = pa;\n            pc = pa;", "//或者pc.next", "\n            ", "pa", " = pa->", "next;\n        }\n        ", "else", "\n        {\n            ", "pc", "->", "next = pb;\n            pc = pb;\n            ", "pb", " = pb->", "next;\n        }\n    }\n    ", "while", " (pa || pb)\n        ", "pc", "->", "next = pa ? pa : pb;\n    free(Lb);", "//释放Lb的头结点,如果有头指针就要传递二级指针并把，**head = null;", "\n}\n", "\n", "编译前未找到相关问题", "表以后出现了如下的错误求解决方法", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "修改前： name : 'tpartytype.partytypename'    //定义元素名称  \r\n修改后： name : 'partytypename'' //定义元素名称", "Konwledge_Point": "定义新的类型", "Question": ["ExtJS FormPanel.getForm.load()问题", ["首先说下我的业务，配上图案大家容易理解：", "\n[table]", "\n|点击下图修改按钮：|", "\n[/table]", "\n\n", "[img]", "http://dl.iteye.com/upload/attachment/446584/96315930-cfc5-39c5-90ca-3cf35918283f.png[/img]", "\n\n", "[code=\"java\"]function loadForm(ptid){", "\n            ProgramForm.getForm().load({", "\n                waitMsg : '正在加载数据请稍后',          //提示信息", "\n                waitTitle : '提示',                         //标题", "\n                url : 'findTpartytype.action?tpartytype.id='+ptid, //请求的url地址", "\n                method:'POST',              //请求方式", "\n                success:function(form,action){ //加载成功的处理函数", "\n                    ProgramForm.load();", "\n                    (action.result.data),", "\n                    Ext.Msg.alert('提示','find成功');", "\n                },", "\n                failure:function(form,action){          //加载失败的处理函数", "\n                    Ext.Msg.alert('提示','find失败');", "\n                }", "\n            });", "\n        }[/code]", "\n\n", "[table]", "\n|效果图如下：|", "\n[/table]", "\n[img]", "http://dl.iteye.com/upload/attachment/446582/2859bccb-2c98-34fd-8ca2-86c49d0421b9.png[/img]", "\nFomrPanel代码如下：", "\n[code=\"java\"]var ProgramForm = new Ext.FormPanel({", "\n            labelSeparator : \"：\",          //元素分隔符为:s", "\n            frame:true,                    //是否渲染", "\n            height:100,", "\n            border:true,                   //无边框", "\n            reader : new Ext.data.JsonReader({ ", "\n                field:'json',", "\n                root:'root'", "\n//              totalProperty:'totalCount' ", "\n        },record),", "\n            items : [", "\n                 {", "\n                    xtype:'textfield',                 //类型", "\n                    fieldLabel:'名称',", "\n                    width : 200,", "\n                    allowBlank : false,               //验证是否为空", "\n                    blankText : '当事人名称不能为空'", "\n                    name : 'tpartytype.partytypename'    //定义元素名称", "\n                 },", "\n                {                          //放置隐藏域修改用", "\n                    xtype: 'textfield', ", "\n                    name: 'tpartytype.id', ", "\n                    id: 'tpartytype.id', ", "\n                    hidden: true, ", "\n                    hideLabel:true ", "\n\n", "            },\n            {                      //放置隐藏 把多有参数写满/看有无关系\n                xtype: 'textfield', \n                name: 'tpartytype.partytypecode', \n                id: 'tpartytype.partytypecode', \n                hidden: true, \n                hideLabel:true \n\n            }\n        ],\n        buttons:[\n            {\n                text : '提交',\n                handler : submitForm\n            },\n            {\n                text : '关闭',\n                handler : function(){\n                    win.hide();\n                }\n            }\n        ],\n         keys:[{key: [10,13],fn:submitForm}] //键盘事件 提交 fn:对应提交handler\n    });[/code]\n", "\n\n", "[table]", "\n|结果如下图：|", "\n[/table]", "\n[img]", "http://dl.iteye.com/upload/attachment/446580/58b7e537-ebc9-38c4-b760-eb240f770239.png[/img]", "\n\n", "[size=large][color=red][b]问题：[/b][/color][/size]", "\n我怎么才能把查到的数据放到上面的结果图中呢？因为我现在更新总是做插入，我的隐藏域ID传过去。请大家给下方法，我新手刚学。", "\n\n", "[table]", "\n|备注，load()交互的查询结果如下：|", "\n[/table]", "\n[code=\"java\"]{root:[{\"userlogDescription\":\"当事人类型名称为：gggggggg\",\"partytypename\":\"gggggggg\",\"systemlogDescription\":\"\",\"partytypecode\":\"\",\"searchenddate\":\"\",\"searchstartdate\":\"\",\"id\":\"14ED820E_8D8F_BFB1_37E4_AF156A3FFE88\"}]}", "\n[/code]", "\n\n", "[b][color=red]这是我的全部积分，大家帮助谢谢！[/color][/b]"]], "Tag": "程序设计"}
{"Answer": "http://www.pudn.com/downloads246/sourcecode/windows/control/detail1145977.html", "Konwledge_Point": "定义新的类型", "Question": ["求大神帮忙在我的代码（栈，C/C++，简单的四则运算）上修改一下，代码和要求都在楼下！", ["已经用C语言的栈写出个位数的四则运算，但不知道怎么修改成支持小数和多位数甚至可以sin，log，绝对值等数学运算，就类似于科学计算器，只要求控制台界面简单的输入就好，求大神帮忙在我的基础上修改，谢谢了！", "\n\n", "#include", "\n#include", "\n#define newp (inn ", ")malloc(sizeof(inn)) //定义一个申请栈地址的宏", "\ntypedef struct stack", "\n{", "\n    char data;//存入数据类型为字符 ", "\n    struct stack *next;//建立指针 ", "\n}inn;  //建立栈类型", "\nint judge(char x)  //比较优先级函数 ", "\n{", "\n    if(x=='+'||x=='-') return 0; ", "\n    else if(x=='", "'||x=='/') return 1;", "\n    else if(x=='#'||x=='('||x==')') return -1;", "\n} ", "\nint main()", "\n{", "\n    int flag = 1;", "\n    while(flag)", "\n    {", "\n        printf(\"尾部不需要添加任何符号即可计算： \");", "\n        inn ", "p,*top; //栈指针和栈顶指针", "\n        int number[50];//存入数字的数组 ", "\n        int i=0;", "\n        char c;", "\n        p = newp;//s开空间，newp为宏定义 ", "\n        p->data='#';//头指针第一个字符为# ", "\n        p->next = NULL;//初始化头指针里的next指针 ", "\n        top = p;//top跟p一起，接着新开的p的next指向top，栈用链表顺序不一样 ", "\n        c = getchar();//之后是读取中缀表达式的部分，用字符一个一个的读", "\n        while(c!='\\n')//直到读到回车结束 ", "\n        {", "\n            if(c>='0' && c<='9')//如果输入的是数字，存入数字数组（number） ", "\n            {", "\n                i++;//加完后i=1 ", "\n                number[i] = c-48;//字符转数字存入数组 ", "\n            }", "\n            else if(c=='(')//如果是左括号，直接进栈", "\n            {", "\n                p = newp; //s开空间，newp为宏定义", "\n                p->data = c;//把左括号字符存入 ", "\n                p->next = top;//指针指向栈顶指针 ", "\n                top = p;//top指向p，到后面读从top往回读直到p->next = NULL ", "\n            }", "\n            else if(c==')') //如果是右括号，匹配左括号，把两者之间的栈内符号全部弹出 ", "\n            {", "\n                while(top->data!='(')//首先判断左括号，然后从左括号开始到右括号所有字符弹出 ", "\n                {", "\n                    p = top;//从左括号开始，用于计算完后p的地址释放空间 ", "\n                    if(top->data=='+')", "\n                    {", "\n                        number[i-1]=number[i-1]+number[i];", "\n                        i--; ", "\n                    }", "\n                    else if(top->data=='-')", "\n                    {", "\n                        number[i-1]=number[i-1]-number[i];", "\n                        i--;", "\n                    }", "\n                    else if(top->data=='", "')", "\n                    {", "\n                        number[i-1]=number[i-1]*number[i];", "\n                        i--;", "\n                    }", "\n                    else if(top->data=='/')", "\n                    {", "\n                        number[i-1]=number[i-1]/number[i];", "\n                        i--;", "\n                    }", "\n                    top = top->next;//遍历链表 ", "\n                    free(p);//释放空间 ", "\n                }", "\n                p = top;//此时p用于指向空间便于下一步释放空间 ", "\n                top = top->next;//top++ ", "\n                free(p);", "\n            }", "\n            else  //否则就是+-*/了 ", "\n            {", "\n                int a =judge(c),b = judge(top->data);//比较该符号和栈顶符号优先级", "\n                if(a>b) //如果大于直接压进去", "\n                {", "\n                    p = newp;//开空间", "\n                    p->data = c;", "\n                    p->next = top;", "\n                    top = p;", "\n                }", "\n                else  //否则就把栈顶的符号一直弹出，直到弹到可以压进去（也就是说等于也不能压进去） ", "\n                {", "\n                    while(a<=b)", "\n                    {", "\n                        p = top;//从左括号开始，用于计算完后p的地址释放空间 ", "\n                        if(top->data=='+')", "\n                        {", "\n                            number[i-1]=number[i-1]+number[i];", "\n                            i--;", "\n                        }", "\n                        else if(top->data=='-')", "\n                        {", "\n                            number[i-1]=number[i-1]-number[i];", "\n                            i--;", "\n                        }", "\n                        else if(top->data=='*')", "\n                        {", "\n                            number[i-1]=number[i-1]*number[i];", "\n                            i--;", "\n                        }", "\n                        else if(top->data=='/')", "\n                        {", "\n                            number[i-1]=number[i-1]/number[i];", "\n                            i--;", "\n                        }", "\n                        top = top->next;//遍历链表 ", "\n                        free(p);//释放空间 ", "\n                        b = judge(top->data);", "\n                    }", "\n                    p = newp;//开空间 ", "\n                    p->data = c;//存入字符 ", "\n                    p->next = top; ", "\n                    top = p;", "\n                }", "\n            }", "\n            c = getchar();//读取下一个字符", "\n        }", "\n        while(top->data!='#')//读完还没有结束，还要把栈内剩余的所有符号挨个弹出 ", "\n        {", "\n            p = top;", "\n            if(top->data=='+')", "\n            {", "\n                number[i-1] = number[i-1]+number[i];", "\n                i--;", "\n            }", "\n            else if(top->data=='-')", "\n            {", "\n                number[i-1] = number[i-1]-number[i];", "\n                i--;", "\n            }", "\n            else if(top->data=='*')", "\n            {", "\n                number[i-1] = number[i-1]*number[i];", "\n                i--;", "\n            }", "\n            else if(top->data=='/')", "\n            {", "\n                number[i-1]=number[i-1]/number[i];", "\n                i--;", "\n            }", "\n            top = top->next;", "\n            free(p);", "\n        }", "\n        printf(\"结果 = %d\\n\",number[i]);", "\n        printf(\"\\n是否需要继续输入？输入任何个位数字继续 / 0则退出\\n\");", "\n        scanf(\"%d\",&flag);", "\n        c = getchar();", "\n    }", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改见注释处&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;stdlib.h&amp;gt;\n#define ElemType TreeNode\n&lt;span class=\"hljs-comment\"&gt;//定义树的结点&lt;/span&gt;\ntypedef struct node{ &lt;span class=\"hljs-comment\"&gt;//树的结点&lt;/span&gt;\n    int &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//数据域&lt;/span&gt;\n    struct node* left;  &lt;span class=\"hljs-comment\"&gt;//左儿子&lt;/span&gt;\n    struct node* right; &lt;span class=\"hljs-comment\"&gt;//右儿子&lt;/span&gt;\n} Node,*TreeNode;\n&lt;span class=\"hljs-comment\"&gt;//利用树的结点类型指针指向根结点&lt;/span&gt;\ntypedef struct {\n     TreeNode root;        &lt;span class=\"hljs-comment\"&gt;//树根&lt;/span&gt;\n}*TreeFirstNode,FirstNode;\n&lt;span class=\"hljs-comment\"&gt;//定义栈的存储类型 //新的数据类型&lt;/span&gt;\ntypedef struct Nodestack *ListStack;\nstruct Nodestack{\n    TreeNode p;           &lt;span class=\"hljs-comment\"&gt;//存树的结点指针&lt;/span&gt;\n    struct Nodestack *next; &lt;span class=\"hljs-comment\"&gt;//下一个栈元素指针&lt;/span&gt;\n}Stack;\n&lt;span class=\"hljs-comment\"&gt;//树的中序遍历&lt;/span&gt;\nvoid Show(TreeNode &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;)\n{\n    TreeNode temp &amp;#61; &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ( temp!&amp;#61; NULL)     &lt;span class=\"hljs-comment\"&gt;//工作指针&lt;/span&gt;\n    {\n        S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;left);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,temp-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n        S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;right);\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//树的先序遍历&lt;/span&gt;\nvoid Show1(TreeNode treeroot)\n{\n    TreeNode temp &amp;#61; treeroot;     &lt;span class=\"hljs-comment\"&gt;//工作指针 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp!&amp;#61; NULL)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,temp-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n        S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how1&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;left);\n        S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how1&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;right);\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//树的后序遍历 &lt;/span&gt;\nvoid Show2(TreeNode treeroot)\n{\n    TreeNode temp &amp;#61; treeroot;     &lt;span class=\"hljs-comment\"&gt;//工作指针 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ( temp!&amp;#61; NULL)\n    {\n        S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how2&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;left);\n        S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how2&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;right);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,temp-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//非递归中序遍历 &lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//栈的初始化 &lt;/span&gt;\nvoid InitStack(ListStack &amp;amp;S){\n    S &amp;#61; (ListStack)malloc(sizeof(Stack));\n    S-&amp;gt;next &amp;#61; NULL;\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;初始化成功&amp;#xff01;\\n&amp;#34;);&lt;/span&gt;\n}\n&lt;span class=\"hljs-comment\"&gt;//判断是否为空栈&lt;/span&gt;\nbool ListStackEmpty(ListStack S){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(S-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; NULL)\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n} \n&lt;span class=\"hljs-comment\"&gt;//将数据压入栈内&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//用头插法更合适 出栈的时候只需弹出第一个节点即可&lt;/span&gt;\nbool Push(ListStack &amp;amp;S ,ElemType &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;){\n    ListStack r;\n    ListStack t;\n    t &amp;#61; S;                                    &lt;span class=\"hljs-comment\"&gt;//防止s指向发生改变 &lt;/span&gt;\n    r &amp;#61; (ListStack)malloc(sizeof(Stack));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;r&lt;/span&gt;-&amp;gt;&lt;/span&gt;p&amp;#61; &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;r&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;next&lt;/span&gt; &amp;#61; t-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;t&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; r;\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;入栈成功\\n&amp;#34;);&lt;/span&gt;\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//将数据弹出栈&lt;/span&gt;\nbool Pop(ListStack &amp;amp;S,ElemType&amp;amp; t){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(S-&amp;gt;&lt;/span&gt;next&amp;#61;&amp;#61;NULL){\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;栈空\\n&amp;#34;&lt;/span&gt;);\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n    ListStack r;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;r&lt;/span&gt;&amp;#61;S-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;t&lt;/span&gt;&amp;#61;r-&amp;gt;&lt;/span&gt;p;\n    S-&amp;gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;next&lt;/span&gt;&amp;#61;r-&amp;gt;&lt;/span&gt;next;\n    free(r);\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;弹出成功/n&amp;#34;); &lt;/span&gt;\n    } \n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n} \n&lt;span class=\"hljs-comment\"&gt;//读取栈顶元素&lt;/span&gt;\nbool GetTop(ListStack s,ElemType &amp;amp;x){\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(s-&amp;gt;&lt;/span&gt;next&amp;#61;&amp;#61;NULL){\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;s&lt;/span&gt;&amp;#61;s-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;x&lt;/span&gt;&amp;#61;s-&amp;gt;&lt;/span&gt;p;\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//树的非递归中序遍历&lt;/span&gt;\nvoid InOrder2(TreeFirstNode &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,ListStack S){\n    T&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;reeNode&lt;/span&gt; p&amp;#61;&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root;\n    InitStack(S);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p||!ListStackEmpty(S)){    &lt;span class=\"hljs-comment\"&gt;//栈不空的时候 是FALSE &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p){\n            Push(S,p);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;/span&gt;left;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n            &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;%d &amp;#34;,S-&amp;gt;next-&amp;gt;p-&amp;gt;data);&lt;/span&gt;\n            Pop(S,p);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;/span&gt;right;\n        }\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//树的非递归先序遍历&lt;/span&gt;\nvoid InOrder1(TreeFirstNode &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,ListStack L){\n    T&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;reeNode&lt;/span&gt; p&amp;#61;&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root;\n    InitStack(L);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p||!ListStackEmpty(L)){    &lt;span class=\"hljs-comment\"&gt;//栈不空的时候 是FALSE &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p){\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n            Push(L,p);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;/span&gt;left;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n            Pop(L,p);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;/span&gt;right;\n        }\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;//树的非递归后序遍历&lt;/span&gt;\nvoid InOrder3(TreeFirstNode &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,ListStack L){\n    T&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;reeNode&lt;/span&gt; p&amp;#61;&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root;\n    TreeNode r &amp;#61; NULL;&lt;span class=\"hljs-comment\"&gt;//辅助指针 判断是否已被访问&lt;/span&gt;\n    InitStack(L);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p||!ListStackEmpty(L)){    &lt;span class=\"hljs-comment\"&gt;//栈不空的时候 是FALSE &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p){\n            Push(L,p);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;/span&gt;left;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n            GetTop(L,p);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;right&lt;/span&gt; &amp;amp;&amp;amp; p-&amp;gt;&lt;/span&gt;right!&amp;#61;r){\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&amp;#61;p-&amp;gt;&lt;/span&gt;right; \n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n                Pop(L,p);\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n                r&amp;#61;p;\n                p&amp;#61;NULL;\n            } \n        }\n    }\n} \n&lt;span class=\"hljs-comment\"&gt;//创建根 &lt;/span&gt;\nvoid Init( TreeFirstNode &amp;amp;&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;, int value)&lt;span class=\"hljs-comment\"&gt;//创建树  &lt;/span&gt;\n{\n    TreeNode node&amp;#61;(TreeNode)malloc(sizeof(Node));&lt;span class=\"hljs-comment\"&gt;//创建一个节点&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; value;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;left &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;right &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root &amp;#61; node;&lt;span class=\"hljs-comment\"&gt;//创建根结点   &lt;/span&gt;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;初始化成功\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-comment\"&gt;//插入结点&amp;#xff08;二叉排序树&amp;#xff09; &lt;/span&gt;\nvoid Insert(TreeFirstNode &amp;amp;&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,int value){ \n    T&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;reeNode&lt;/span&gt; temp &amp;#61; &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root;&lt;span class=\"hljs-comment\"&gt;//工作从树根开始&lt;/span&gt;\n    TreeNode node&amp;#61;(TreeNode)malloc(sizeof(Node));&lt;span class=\"hljs-comment\"&gt;//创建一个节点&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; value;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;left &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;node&lt;/span&gt;-&amp;gt;&lt;/span&gt;right &amp;#61; NULL;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (temp!&amp;#61; NULL)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (value &amp;lt; temp-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;)       &lt;span class=\"hljs-comment\"&gt;//小于就进左子树 &lt;/span&gt;\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (temp-&amp;gt;&lt;/span&gt;left &amp;#61;&amp;#61; NULL)\n            {\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;temp&lt;/span&gt;-&amp;gt;&lt;/span&gt;left &amp;#61; node;\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;插入成功\\n&amp;#34;&lt;/span&gt;);\n                return;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {                   &lt;span class=\"hljs-comment\"&gt;//不空继续判断&lt;/span&gt;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;temp&lt;/span&gt; &amp;#61; temp-&amp;gt;&lt;/span&gt;left;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{                      &lt;span class=\"hljs-comment\"&gt;//否则进右子树 &lt;/span&gt;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;right &amp;#61;&amp;#61; NULL)\n            {\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;temp&lt;/span&gt;-&amp;gt;&lt;/span&gt;right &amp;#61; node;\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;插入成功\\n&amp;#34;&lt;/span&gt;); \n                return;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{                  &lt;span class=\"hljs-comment\"&gt;//不空继续判断&lt;/span&gt;\n                &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;temp&lt;/span&gt; &amp;#61; temp-&amp;gt;&lt;/span&gt;right;\n            }\n        }\n    }\n}\n \n&lt;span class=\"hljs-comment\"&gt;//定义队列储存类型&lt;/span&gt;\ntypedef struct qnode{\n    TreeNode ptrl;\n    struct qnode *next;    \n}LinkNode;\ntypedef struct{\n    LinkNode *front,*rear;\n}LinkQueue;\n\n&lt;span class=\"hljs-comment\"&gt;//初始化队列&lt;/span&gt;\nbool InitQueue(LinkQueue &amp;amp;q){            &lt;span class=\"hljs-comment\"&gt;//传引用更加方便&lt;/span&gt;\n    q.front &amp;#61; (LinkNode*)malloc(sizeof(struct node)); &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;.front-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;&lt;span class=\"hljs-comment\"&gt;//是首结点置空&lt;/span&gt;\n    q.rear &amp;#61; q.front;                      &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;初始化成功&amp;#xff01;\\n&amp;#34;);&lt;/span&gt;\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//判断队列是否为空&lt;/span&gt;\nbool QueueEmpty(LinkQueue q){\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(q.front&amp;#61;&amp;#61;q.rear)\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n} \n \n&lt;span class=\"hljs-comment\"&gt;//入队操作&lt;/span&gt;\nbool EnterQueue(LinkQueue &amp;amp;q,TreeNode x){\n    LinkNode *s &amp;#61; (LinkNode*)malloc(sizeof(LinkNode));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;s&lt;/span&gt;-&amp;gt;&lt;/span&gt;ptrl &amp;#61; x;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;s&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;.rear-&amp;gt;&lt;/span&gt;next &amp;#61; s;\n    q.rear &amp;#61; s;\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n} \n \n&lt;span class=\"hljs-comment\"&gt;//出队操作&lt;/span&gt;\nbool OutQueue(LinkQueue &amp;amp;q,ElemType &amp;amp;j){&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//j用来保存出队数据 引用传递&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(q.front &amp;#61;&amp;#61; q.rear)\n       return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    L&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;inkNode&lt;/span&gt; *p &amp;#61; q.front;//修改 *p &amp;#61; q.front-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;.front &amp;#61; p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;next&lt;/span&gt;;   //修改   q.front-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;next&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;j&lt;/span&gt; &amp;#61; q.front-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;ptrl&lt;/span&gt;;   //修改  j &amp;#61; p-&amp;gt;&lt;/span&gt;ptrl;\n                         &lt;span class=\"hljs-comment\"&gt;//if(q.rear&amp;#61;&amp;#61;p)&lt;/span&gt;\n                         &lt;span class=\"hljs-comment\"&gt;//q.front&amp;#61;q.rear;&lt;/span&gt;\n    free(p);\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;; \n} \n&lt;span class=\"hljs-comment\"&gt;//层遍历二叉树&lt;/span&gt;\nvoid LevelOrder(TreeNode TreeRoot,LinkQueue &amp;amp;q){\n    InitQueue(q);\n    TreeNode temp; &lt;span class=\"hljs-comment\"&gt;//&amp;#61; TreeRoot;  修改&lt;/span&gt;\n    EnterQueue(q,TreeRoot);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(!QueueEmpty(q)){\n        OutQueue(q,temp);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;,temp-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;left!&amp;#61;NULL){\n           E&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;nterQueue&lt;/span&gt;(q,temp-&amp;gt;&lt;/span&gt;left);\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;(temp-&amp;gt;&lt;/span&gt;right!&amp;#61;NULL){\n           E&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;nterQueue&lt;/span&gt;(q,temp-&amp;gt;&lt;/span&gt;right);\n       }\n    }\n}\nint main(){\n    int value;\n    int N,i;\n    ElemType t;\n    ListStack S,L;\n    LinkQueue q;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入根结点的值:\\n&amp;#34;&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;value);\n    TreeFirstNode &lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;&amp;#61;(TreeFirstNode)malloc(sizeof(FirstNode));\n    Init(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,value);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要插入树的数据个数&amp;#xff08;N&amp;#xff09;:&amp;#34;&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;N);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;N&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入第%d个数:&amp;#34;&lt;/span&gt;,i);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;value);\n        Insert(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,value); \n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;递归中序遍历二叉排序树:\\n&amp;#34;&lt;/span&gt;);\n    S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;非递归中序遍历二叉排序树:\\n&amp;#34;&lt;/span&gt;);\n    InOrder2(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,S);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;递归先序遍历二叉排序树:\\n&amp;#34;&lt;/span&gt;);\n    S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how1&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;非递归先序遍历二叉排序树:\\n&amp;#34;&lt;/span&gt;); \n    InOrder1(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,S); \n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;递归后序遍历二叉排序树:\\n&amp;#34;&lt;/span&gt;);\n    S&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;how2&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;非递归后序遍历二叉排序树:\\n&amp;#34;&lt;/span&gt;);\n    InOrder3(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;,S);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;层遍历二叉树&amp;#xff1a;\\n&amp;#34;&lt;/span&gt;);\n    L&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;evelOrder&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;tree&lt;/span&gt;-&amp;gt;&lt;/span&gt;root,q);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["有没有看看层序遍历二叉树的时候为什么会异常输出", ["\n#include<stdio.h>\n#include<stdlib.h>\n#define ElemType TreeNode \n", "//定义树的结点", "\ntypedef struct node{ ", "//树的结点", "\n    int ", "data", ";    ", "//数据域 ", "\n    struct node* left;  ", "//左儿子 ", "\n    struct node* right; ", "//右儿子 ", "\n} Node,*TreeNode;\n", "//利用树的结点类型指针指向根结点", "\ntypedef struct { \n     TreeNode root;        ", "//树根", "\n}*TreeFirstNode,FirstNode; \n\n", "//定义栈的存储类型 //新的数据类型 ", "\ntypedef struct Nodestack *ListStack;\nstruct Nodestack{\n    TreeNode p;           ", "//存树的结点指针 ", "\n    struct Nodestack *next; ", "//下一个栈元素指针 ", "\n}Stack;\n\n", "//树的中序遍历", "\nvoid Show(TreeNode ", "tree", ")\n{\n    TreeNode temp = ", "tree", ";\n    ", "if", " ( temp!= NULL)     ", "//工作指针 ", "\n    {\n        S", "how", "(temp->", "left);\n        ", "printf", "(\"%d \",temp->", "data", ");\n        S", "how", "(temp->", "right);\n    }\n}\n\n", "//树的先序遍历 ", "\nvoid Show1(TreeNode treeroot)\n{\n    TreeNode temp = treeroot;     ", "//工作指针 ", "\n    ", "if", " (temp!= NULL)\n    {\n        ", "printf", "(\"%d \",temp->", "data", ");\n        S", "how1", "(temp->", "left);\n        S", "how1", "(temp->", "right);\n    }\n}\n", "//树的后序遍历 ", "\nvoid Show2(TreeNode treeroot)\n{\n    TreeNode temp = treeroot;     ", "//工作指针 ", "\n    ", "if", " ( temp!= NULL)\n    {\n        S", "how2", "(temp->", "left);\n        S", "how2", "(temp->", "right);\n        ", "printf", "(\"%d \",temp->", "data", ");\n    }\n}\n\n", "//非递归中序遍历 ", "\n\n", "//栈的初始化 ", "\nvoid InitStack(ListStack &S){\n    S = (ListStack)malloc(sizeof(Stack));\n    S->next = NULL;\n    ", "//printf(\"初始化成功！\\n\");", "\n}\n\n", "//判断是否为空栈", "\nbool ListStackEmpty(ListStack S){\n    ", "if", "(S->", "next == NULL)\n    return ", "true", ";\n    return ", "false", ";\n} \n\n", "//将数据压入栈内 ", "\n", "/* 用头插法更合适 出栈的时候只需弹出第一个节点即可*/", "\nbool Push(ListStack &S ,ElemType ", "data", "){\n    ListStack r;\n    ListStack t;\n    t = S;                                    ", "//防止s指向发生改变 ", "\n    r = (ListStack)malloc(sizeof(Stack));\n    ", "r", "->", "p= ", "data", ";\n    ", "r", "->", "next", " = t->", "next;\n    ", "t", "->", "next = r;\n    ", "//printf(\"入栈成功\\n\");", "\n    return ", "true", ";\n}\n\n", "//将数据弹出栈", "\nbool Pop(ListStack &S,ElemType& t){\n    ", "if", "(S->", "next==NULL){\n        printf(", "\"栈空\\n\"", ");\n        return ", "false", ";\n    }", "else", "{\n    ListStack r;\n    ", "r", "=S->", "next;\n    ", "t", "=r->", "p;\n    S->", "next", "=r->", "next;\n    free(r);\n    ", "//printf(\"弹出成功/n\"); ", "\n    } \n    return ", "true", ";\n} \n\n", "//读取栈顶元素", "\nbool GetTop(ListStack s,ElemType &x){\n    ", "if", "(s->", "next==NULL){\n        return ", "false", ";\n    }\n    ", "s", "=s->", "next;\n    ", "x", "=s->", "p;\n    return ", "true", ";\n}\n\n", "//树的非递归中序遍历 ", "\nvoid InOrder2(TreeFirstNode ", "tree", ",ListStack S){\n    T", "reeNode", " p=", "tree", "->", "root;\n    InitStack(S);\n    ", "while", "(p||!ListStackEmpty(S)){    ", "//栈不空的时候 是FALSE ", "\n        ", "if", "(p){\n            Push(S,p);\n            ", "p", "=p->", "left;\n        }\n        ", "else", "{\n            ", "printf", "(\"%d \",S->", "next", "->", "p", "->", "data", ");\n            Pop(S,p);\n            ", "p", "=p->", "right;\n        }\n    }\n}\n\n", "//树的非递归先序遍历", "\nvoid InOrder1(TreeFirstNode ", "tree", ",ListStack L){\n    T", "reeNode", " p=", "tree", "->", "root;\n    InitStack(L);\n    ", "while", "(p||!ListStackEmpty(L)){    ", "//栈不空的时候 是FALSE ", "\n        ", "if", "(p){\n            ", "printf", "(\"%d \",p->", "data", ");\n            Push(L,p);\n            ", "p", "=p->", "left;\n        }\n        ", "else", "{\n            Pop(L,p);\n            ", "p", "=p->", "right;\n        }\n    }\n}\n\n", "//树的非递归后序遍历", "\nvoid InOrder3(TreeFirstNode ", "tree", ",ListStack L){\n    T", "reeNode", " p=", "tree", "->", "root;\n    TreeNode r = NULL;", "//辅助指针 判断是否已被访问 ", "\n    InitStack(L);\n    ", "while", "(p||!ListStackEmpty(L)){    ", "//栈不空的时候 是FALSE ", "\n        ", "if", "(p){\n            Push(L,p);\n            ", "p", "=p->", "left;\n        }\n        ", "else", "{\n            GetTop(L,p);\n            ", "if", "(p->", "right", " && p->", "right!=r){\n                ", "p", "=p->", "right; \n            }\n            ", "else", "{\n                Pop(L,p);\n                ", "printf", "(\"%d \",p->", "data", ");\n                r=p;\n                p=NULL;\n            } \n        } \n    }\n} \n\n", "//创建根 ", "\nvoid Init( TreeFirstNode &", "tree", ", int value)", "//创建树  ", "\n{\n    TreeNode node=(TreeNode)malloc(sizeof(Node));", "//创建一个节点", "\n    ", "node", "->", "data", " = value;\n    ", "node", "->", "left = NULL;\n    ", "node", "->", "right = NULL;\n    ", "tree", "->", "root = node;", "//创建根结点   ", "\n    printf(", "\"初始化成功\\n\"", ");\n}\n\n", "//插入结点（二叉排序树） ", "\nvoid Insert(TreeFirstNode &", "tree", ",int value){ \n    T", "reeNode", " temp = ", "tree", "->", "root;", "//工作从树根开始", "\n    TreeNode node=(TreeNode)malloc(sizeof(Node));", "//创建一个节点", "\n    ", "node", "->", "data", " = value;\n    ", "node", "->", "left = NULL;\n    ", "node", "->", "right = NULL;\n    ", "while", " (temp!= NULL)\n    {\n        ", "if", " (value < temp->", "data", ")       ", "//小于就进左子树 ", "\n        {\n            ", "if", " (temp->", "left == NULL)\n            {\n                ", "temp", "->", "left = node;\n                printf(", "\"插入成功\\n\"", "); \n                return;\n            }\n            ", "else", "\n            {                   ", "//不空继续判断", "\n                ", "temp", " = temp->", "left;\n            }\n        }\n        ", "else", "{                      ", "//否则进右子树 ", "\n\n            ", "if", "(temp->", "right == NULL)\n            {\n                ", "temp", "->", "right = node;\n                printf(", "\"插入成功\\n\"", "); \n                return;\n            }\n            ", "else", "{                  ", "//不空继续判断", "\n                ", "temp", " = temp->", "right;\n            }\n        }\n    }\n}\n\n \n", "//定义队列储存类型", "\ntypedef struct qnode{\n    TreeNode ptrl;\n    struct qnode *next;    \n}LinkNode;\ntypedef struct{\n    LinkNode *front,*rear;\n}LinkQueue; \n\n\n", "//初始化队列", "\nbool InitQueue(LinkQueue &q){            ", "//传引用更加方便 ", "\n    q.front=q.rear = (LinkNode*)malloc(sizeof(struct node));\n    ", "q", ".front->", "next=NULL;", "//是首结点置空 ", "\n    ", "//printf(\"初始化成功！\\n\"); ", "\n    return ", "true", ";\n}\n\n", "//判断队列是否为空", "\nbool QueueEmpty(LinkQueue q){\n    ", "if", "(q.front==q.rear)\n    return ", "true", ";\n    return ", "false", "; \n} \n\n\n", "//入队操作", "\n\nbool EnterQueue(LinkQueue &q,TreeNode x){\n    LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));\n    ", "s", "->", "ptrl = x;\n    ", "s", "->", "next = NULL;\n    ", "q", ".rear->", "next = s;\n    q.rear = s;\n    return ", "true", ";\n} \n\n\n", "//出队操作", "\nbool OutQueue(LinkQueue &q,ElemType &j){   ", "//j用来保存出队数据 引用传递 ", "\n    ", "if", "(q.front==q.rear)\n    return ", "false", ";\n    L", "inkNode", " *p = q.front->", "next;\n    ", "j", " = p->", "ptrl;\n    ", "q", ".front->", "next", " = p->", "next;\n    ", "if", "(q.rear==p)\n    q.front=q.rear;\n    free(p); \n    return ", "true", "; \n\n} \n\n", "//层遍历二叉树", "\n\nvoid LevelOrder(TreeNode TreeRoot,LinkQueue &q){\n    InitQueue(q);\n    TreeNode temp = TreeRoot;\n    EnterQueue(q,TreeRoot);\n    ", "while", "(!QueueEmpty(q)){\n        OutQueue(q,temp);\n        ", "printf", "(\"%d \",temp->", "data", ");\n        ", "if", "(temp->", "left!=NULL){\n            E", "nterQueue", "(q,temp->", "left);\n        }\n        ", "if", "(temp->", "right!=NULL){\n            E", "nterQueue", "(q,temp->", "right);\n        }\n    }\n    \n}\nint main(){\n    int value;\n    int N,i; \n    ElemType t;\n    ListStack S,L;\n    LinkQueue q;\n    printf(", "\"请输入根结点的值:\\n\"", ");\n    scanf(", "\"%d\"", ",&value);\n    TreeFirstNode ", "tree", "=(TreeFirstNode)malloc(sizeof(FirstNode));\n    Init(", "tree", ",value);\n    printf(", "\"请输入要插入树的数据个数（N）:\"", "); \n    scanf(", "\"%d\"", ",&N);\n    ", "for", "(i=", "1", ";i<N+", "1", ";i++){\n        printf(", "\"请输入第%d个数:\"", ",i);\n        scanf(", "\"%d\"", ",&value);\n        Insert(", "tree", ",value); \n    }\n    printf(", "\"递归中序遍历二叉排序树:\\n\"", ");\n    S", "how", "(", "tree", "->", "root);\n    printf(", "\"\\n\"", ");\n    printf(", "\"非递归中序遍历二叉排序树:\\n\"", ");\n    InOrder2(", "tree", ",S);\n    printf(", "\"\\n\"", ");\n    printf(", "\"递归先序遍历二叉排序树:\\n\"", ");\n    S", "how1", "(", "tree", "->", "root);\n    printf(", "\"\\n\"", ");\n    printf(", "\"非递归先序遍历二叉排序树:\\n\"", "); \n    InOrder1(", "tree", ",S); \n    printf(", "\"\\n\"", ");\n    printf(", "\"递归后序遍历二叉排序树:\\n\"", ");\n    S", "how2", "(", "tree", "->", "root);\n    printf(", "\"\\n\"", ");\n    printf(", "\"非递归后序遍历二叉排序树:\\n\"", ");\n    InOrder3(", "tree", ",S);\n    printf(", "\"\\n\"", ");\n    printf(", "\"层遍历二叉树：\\n\"", ");\n    L", "evelOrder", "(", "tree", "->", "root,q);\n    return ", "0", ";\n} \n\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n**_for(int j=0;j&lt;chs.length;j++){//第一部分\r\n\t            if(input[i]==chs[j]){//第二部分**_\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["小白求答，写了个猜字母的代码，可是它识别不了我的答案，求大神解惑", ["import java.util.Scanner;", "\n\n", "public class Guess {", "\n\n", "public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    //第一步：定义数据结构：\n    /*Input:*/\n    char[] chs = new char[5];//保存随机生成的5个字母\n    char[] input = new char[5];//保存用户输入的5个字母\n    /*Output:*/\n    //第几次尝试，猜对几个字母，几个字母的位置正确\n    int times=0,right=0,position=0;\n    int score=0;//分数\n    char[] realtime=new char[5];//保存实时显示猜对位置字母的数组\n    /*隐含变量*/\n    String inStr=\" \";//临时保存从控制台录入的字符串\n    /*process*/\n    generate(chs);\n    /*打桩测试*/\n    for(int i=0;i<chs.length;i++){\n        System.out.print(chs[i]+\",\");\n    }\n    /*主程序循环*/\n    Scanner sc=new Scanner(System.in);//只有从控制台获得用户输入就用Scanner\n    System.out.println(\"游戏开始...\");\n    //循环\n    /*字符串不是基本类型，做等值比较，不能用==\n     * 应该使用Java专门的API比较字符串是否相等\n     * 语法：字符串1.equals(字符串2);\n     */\n    while(!inStr.equals(\"EXIT\")&&position!=chs.length){\n        System.out.println(\"请输入5个字母，按回车继续...（exit-退出）\");\n        //Step2：获得用户输入：\n        /*获得用户输入的字符串：sc.next()——返回输入整个字符串\n         * 防止、去掉空格：字符串.trim()——去掉字符前后空格\n         * 将输入的字符串中所有的小写字母，统一转换为大写字母:\n         *      字符串.toUpperCase()\n         */\n        inStr=sc.next().trim().toUpperCase();\n        //Stpe3：判断：如果用户输入的不是exit，才继续\n        if(!inStr.equals(\"EXIT\")){\n            //Stpe4:将字符串，转化为字符数组，保存到input数组中\n            //将字符串转换为字符数组的API：字符数组=字符串.toCharArray()\n            input=inStr.toCharArray();\n            //Step5:比较chs和input两个数组的相似程度\n            //得到right:猜对几个字母\n            //得到position:猜对位置的有几个\n            //得到realtime:猜对位置的实时数组\n            int[] result=compare(chs,input,realtime);\n            right=result[0];\n            position=result[1];\n            //Step6：如果没有都猜对\n            if(position!=chs.length){\n                //将尝试次数+1\n                times++;\n        System.out.println(\"第\"+times+\"次尝试：\"+\"猜对了\"\n                        +right+\"个字母，\"+\"其中\"+position+\n                        \"个位置正确\"); \n        for(int i=0;i<realtime.length;i++){\n            System.out.print(realtime[i]+\",\");\n        }\n        System.out.println();\n            }       \n        }\n    }\n    /*如果推出循环，只有两种情况：\n     * 1用户输入exit,主动退出，输入欢迎下次再来\n     * 2用户猜对了（position==chs.length）\n     * 计算得分：100*chs.length-10*times\n     * 输出，恭喜你猜对了\n     * */\n    if(inStr.equals(\"EXIT\")){\n        System.out.println(\"欢迎下次再来！\");\n    }else{\n        score=100*chs.length-10*times;\n        System.out.println(\"恭喜您，猜对了，本次得分：\"+score);\n    }\n}\n/**\n * 比较两个数组\n * 1.求出猜对几个字母，有几个字母的位置正确\n * 2.将比较结果分别保存在返回值数组的第一个元素和第二个元素中\n * 3.将位置正确的字母在realtime中实时显示\n * @param chs 随机生成的目标数组\n * @param input 用户输入的数组\n * @param realtime 实时显示猜对位置的元素数组\n * @return 1个数：[0]保存猜对字母的个数\n *               [1]保存猜对位置的个数\n */\npublic static int[] compare(char[]chs,char[]input,char[]realtime){\n    //数组的第一个元素[0]，表示有几个相同的字母\n    //数组第二个元素[1]，表示位置有几个相同的字母\n    int[] result=new int[2];//新建两个整数元素的数组\n    /*\n     * 反复取出input数组中每个元素和chs数组中每个元素比较\n     * 只有input中的元素和chs中的元素相等\n     * 对result[0]+1,表示猜对了一个字母\n     * 立刻判断此时的位置是否相同（i==j）\n     * 如果i==j\n     * 对result[1]+1,表示猜对了一个位置\n     * 将才对的字母，填入realtime数组相同的位置\n     */\n    for(int i=0;i<input.length;i++){\n        for(int j=0;i<chs.length;i++){\n            if(input[1]==chs[j]){\n                result[0]++;\n                if(i==j){\n                    result[1]++;\n                    realtime[i]=input[i];\n                }\n                break;\n            }\n    }\n    }\n    return result;\n}\n    /**\n     * 自动生成5个不重复的字母，直接保存在数组chs中\n     * @param chs：传入一个空数组。\n     *      方法内，对数组的更改，直接作用于原数组\n     */\n\n    public static void generate(char[] chs){\n        /*\n         * 反复生成多个字母，就要用循环：\n         * 循环变量：int i=0;\n         * 循环条件：i<chs.length;\n         * 迭代循环变量：无规律\n         *      只有生成字母不重复时，才+1！\n         * 循环体：随机生成65~90之间的1个整数。\n         * 判断刚生成的整数，在数组中是否重复\n         * 如果没有重复，就加入数组chs中，并且i++\n         * (否则什么都不做，再生成一个新字母，再比较）\n         */\n        //因为循环次数和迭代规律不确定，所以使用while循环\n        int i = 0;//定义循环变量\n        while(i<chs.length){\n            //随机生成65-90之间的整数\n            int r=(int)(Math.random()*(90-65+1)+65);\n            //判断r是否在数组中包含\n            //定义1个布尔类型变量，表示r是否可用。默认是ture.\n            boolean enable=true;\n            //循环遍历数组的每个元素，和r比。\n            //只要任意1个元素等于r，则改变变量enable=false,表示r不可用。\n            for(int j=0;j<i;j++){\n                if(chs[j]==r){\n                    enable=false;\n            }\n        }\n            if(enable){//如果r可用\n                chs[i]=(char)r;\n                i++;\n        }\n        }   \n    }\n}\n", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;报错是在poly.h的35和36行&lt;br /&gt;你这个数据结构定义方式不对&lt;br /&gt;struct _polyarray&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   float coef;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   float expon;&lt;/span&gt;&lt;br /&gt;}polyarray[MAX];&lt;br /&gt;当使用typedef时&amp;#xff0c;你的polyarray就是数据类型名称&amp;#xff0c;而不是变量名称&amp;#xff0c;不能后面加[MAX}形成数组的&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["写一元多项式相加的代码时，代码出现问题", ["我已经被这个问题折磨的不行了，我不会改", "\n", "#include<iostream.h>", "\n", "#include<stdlib.h>", "\n", "#define MAX 20", "\n", "//存放多项式的数组类型", "\ntypedef struct{\n    ", "float", " coef;\n    ", "int", " expon;\n}polyarray [MAX];\n", "//定义单链表结点类型", "\ntypedef struct poly_node{\n    ", "float", " coef;     ", "//系数", "\n    ", "int", " expon;      ", "//指针域", "\n    struct poly_node *next;\n}poly_node,*poly_pointer;  ", "//指向结构的指针", "\n", "//创建，初始化，显示，", "\n", "//尾插法创建链表", "\n", "void", "  creatpoly(poly_pointer &L,polyarray a[],", "int", " n){\n    poly_pointer r,s;\n    L=(poly_pointer)malloc(sizeof(poly_node));\n    L->next=", "NULL", ";\n    r=L;  ", "//p时钟指向尾结点，开始时指向头结点", "\n    ", "for", "(", "int", " i=", "0", ";i<n;i++){\n        s=(poly_pointer)malloc(sizeof(poly_node));", "//创建新结点", "\n        s->coef=a[i].coef;\n        s->expon=a[i].expon;\n        r->next=s;", "//将结点s插入到结点r之后", "\n        r=s;\n    }\n    r->next    =", "NULL", ";   ", "//尾结点next域为空", "\n}\n\n", "void", " display(poly_pointer L){\n    poly_pointer p=L->next;\n    ", "while", "(p!=", "NULL", "){\n        cout<<p->coef<<", "\"*\"", "<<p->expon;\n        p=p->next;\n    }\n    cout<<endl;\n\n}\n", "//按exp域递减排序", "\n", "void", " sort(poly_pointer &head){\n    poly_pointer p=head->next,q,r;\n    ", "if", "(p!=", "NULL", "){  ", "//若原链表中有一个以上的数据结点", "\n        r=p->next;\n        p->next=", "NULL", ";\n        p=r;\n        ", "while", "(p!=", "NULL", "){\n            r=p->next;\n            q=head;\n            ", "while", "(q->next!=", "NULL", "&&q->next->expon>p->expon)\n                q=q->next;\n            p->next=q->next;\n            q->next=p;\n            p=r;\n        }\n    }\n}\n\n\n", "void", " AddPolyn(poly_pointer &pa,poly_pointer pb){\n    ", "//求一元多项式pa 和pb 的和，保存在pa里", "\n    poly_pointer qa=pa->next,qb=pb->next; \n    \n    poly_pointer p=pa;\n    ", "while", "(qa && qb){\n        ", "if", "(qa->expon<qb->expon){\n            ", "//qa连入结果", "\n            pa=(poly_pointer)malloc(sizeof(poly_node));\n            pa->next=pa->next;\n            pa->expon=pa->expon;\n            p->next=pa;\n            p=pa;\n            pa=pa->next;\n    \n        }", "else", " ", "if", "(qa->expon==qb->expon){\n                pa->expon+=qb->expon;\n            ", "if", "(qa->coef){", "//qa连入结果", "\n                pa=(poly_pointer)malloc(sizeof(poly_node));\n                pa->expon=pa->expon;\n                pa->coef=pa->coef;\n                p->next=pa;\n                p=pa;\n\n            }\n                qa=qa->next; qb=qb->next;\n        }\n\n        ", "else", "{  ", "//qa->expon>qb->expon", "\n", "//qb连入结果", "\n                pa=(poly_pointer)malloc(sizeof(poly_node));\n                pa->expon=pb->expon;\n                pa->coef=pb->coef;\n                p->next=pa;\n                p=pa;\n                pb=pb->next;\n        }\n    }", "//while", "\n\n        ", "//谁未结束，谁连进", "\n        ", "if", "(pb!=", "NULL", ") pa=pb;\n        ", "while", "(pa!=", "NULL", "){\n            pa=(poly_pointer)malloc(sizeof(poly_node));\n            pa->expon=pa->expon;\n            pa->coef=pa->coef;\n            p->next=pa;\n            p=pa;\n            pa=pa->next;\n        }\n        p->next=", "NULL", ";\n\n\n}\n\n", "void", " mian(){\n    poly_pointer LA,LB;\n    polyarray a[]={{", "3", ",", "1", "},{", "2", ",", "2", "},{", "1", ",", "3", "},{", "4", ",", "4", "}};\npolyarray b[]={{", "3", ",", "1", "},{", "2", ",", "2", "},{", "1", ",", "3", "},{", "4", ",", "4", "},{", "3", ",", "5", "}};\n    creatpoly(LA,a,", "4", ");\n    creatpoly(LB,b,", "5", ");\n    cout<<", "\"原A：\"", ";\n    display(LA);\n    cout<<endl;\n    cout<<", "\"原B：\"", ";\n    display(LB);\n    cout<<endl;\n    sort(LA);\n        sort(LB);\ncout<<", "\"有序:\"", ";\ndisplay(LA);\ncout<<", "\"有序:\"", ";\n    display(LB);\n    AddPolyn(LA,LB);\n    cout<<", "\"结果：\"", ";\n        display(LA);\n    cout<<endl;\n}\n\n\n", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "logger.info(\"message\", new Exception());  这样来记录 第二个参数是异常", "Konwledge_Point": "定义新的类型", "Question": ["Log4J在记录的日志中怎么显示第几行报错?", ["public class TimerUpdate extends TimerTask {\n    // 获取日志生成器\n    private static Logger log = Logger.getLogger(TimerUpdate.class);\n\n               public void run() {\n\n                     try{\n             \n                }catch (Exception e) {\n       e.printStackTrace();\n       log.info(e);\n        }", "\n\n", "}\n\n}", "\n\n", " #指定logger", "\n\n", "配置Logger组件", "\n\n", "设定Log4j的日志级别(error warn info  debug)", "\n\n", "输出目的地(Console, logfile是appender的名字,是自己定义的,后面才赋予具体的含义)", "\n\n", "log4j.rootLogger=info, Console, logfile", "\n###################################################################################################################", "\n#指定appender(目的地)", "\n#设定Logger的Console(appender的名字)的Appender类型为控制台输出", "\n#org.apache.log4j.ConsoleAppender 表明 Console是控制台输出", "\nlog4j.appender.Console=org.apache.log4j.ConsoleAppender", "\n\n", "#输出的格式", "\n#设定Console的Appender布局Layout", "\n#org.apache.log4j.PatternLayout（可以灵活地指定布局模式）包含选项：", "\n#ConversionPattern=%m%n :指定怎样格式化指定的消息", "\nlog4j.appender.Console.layout=org.apache.log4j.PatternLayout", "\n#2009-09-29 07:30:43,265 INFO com.itcast.web.controller.SearchCdServlet.doGet() - e", "\nlog4j.appender.Console.layout.ConversionPattern=%d %p %c.%M() - %m%n", "\n\n", "###################################################################################################################", "\n#设定Logger的logfile(appender的名字)的Appender类型为文件大小到达指定尺寸的时候产生一个新的文件", "\nlog4j.appender.logfile=org.apache.log4j.RollingFileAppender", "\n\n", "#设定文件的输出路径(指定文件的名字和路径)", "\nlog4j.appender.logfile.File=${catalina.home}/webapps/logs/Sendmsgcsv.log", "\n#设定后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时,将会自动滚动,即将原来的内容移到logstrore.log.1文件", "\nlog4j.appender.logfile.MaxFileSize=2048KB", "\n\n", "#Keep three backup files.指定可以产生的滚动文件的最大数", "\nlog4j.appender.logfile.MaxBackupIndex=4", "\n\n", "#设定logfile的Appender布局Layout", "\nlog4j.appender.logfile.layout=org.apache.log4j.PatternLayout", "\nlog4j.appender.logfile.layout.ConversionPattern=%d %p %c.%M() - %m%n", "\n###################################################################################################################", "\n\n", "日志里错误内容: 2012-09-28 11:32:07,507 INFO org.hp.Listener.util.TimerUpdate.run() - java.lang.NullPointerException", "\n\n", " ", "\n\n", "问题这样的日志:.1.我怎么知道是第几行抛出的异常呢? 2.请大家指导下怎么在生成的错误日志中显示哪行报的错误信息"]], "Tag": "程序设计"}
{"Answer": "不是要放在main前面，而是要先申明后调用\r\n\r\ninsert(pb);\r\n你这里调用了\r\nvoid linsert(PERSON *p)\r\n这里才定义，所以要在\r\nvoid lcreate()\r\n前面加上一行\r\nvoid linsert(PERSON *p); //别忘记最后的分号。", "Konwledge_Point": "定义新的类型", "Question": ["创建链表的时候，怎么也解决不了warning C4013和error C2371，希望大佬指教", ["网上查找说的是函数没有放在main 函数之前，但是我都没有创建main函数，并且就算在函数最后添加main函数，错误也还是这样的。", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define H \"-----------------------\"\n\n\ntypedef struct Person\n{\n    char name[20];\n    char addr[20];\n    char tele[20];\n    char qq[20];\n    struct Person *next;\n}PERSON;\n\nPERSON *head;\n\nvoid lcreate()\n{\n    PERSON *pb;\n    char ch;\n\n    do\n    {\n        pb = malloc(sizeof(PERSON));\n        if (!pb)\n        {\n            printf(\"cannot have house!\");\n            getchar();\n            exit(1);\n        }\n        printf(\"%s\\nPlease put in name:\", H);\n        gets_s(pb->name,20);\n        printf(\"%s\\nPlease put in address:\",H);\n        gets_s(pb->addr,20);\n        printf(\"%s\\nPlease put in phone:\",H);\n        gets_s(pb->tele,20);\n        printf(\"%s\\nPlease put in QQ:\",H);\n        gets_s(pb->qq,20);\n\n        linsert(pb);\n        printf(\"yes or no put in next informantion!(y/n)\");\n        ch = getchar();\n        fflush(stdin);\n    } while (ch == 'y' || ch == 'Y');\n}\n\nvoid DeleteList(PERSON *head)\n{\n    PERSON *DElem, *next;\n    DElem = head;\n    while (DElem)\n    {\n        next = DElem->next;\n        free(DElem);\n        DElem = next;\n    }\n}\n\nvoid linsert(PERSON *p)\n{\n    PERSON *pa, *pb;\n    pb = head;\n    if (!head)\n    {\n        head = p;\n    }\n    else\n    {\n        while (pb)\n        {\n            pa = pb;\n            pb = pb->next;\n        }\n        pa->next = p;\n    }\n    p->next = NULL;\n}\n\nvoid ldel(char *name)\n{\n    PERSON *pa, *pb;\n    if (!head)\n    {\n        printf(\"linst is null!\\n\");\n        getchar();\n        exit(1);\n    }\n    pb = head;\n    while (strcmp(pb->name, name) && pb->next)\n    {\n        pa = pb;\n        pb = pb->next;\n    }\n    if (!strcmp(pb->name, name))\n    {\n        if (pb = head)\n        {\n            head = pb->next;\n        }\n        else\n        {\n            pa->next = pb->next;\n        }\n        free(pb);\n    }\n}\n", "\n\n", "1>------ 已启动生成: 项目: Project7, 配置: Debug Win32 ------", "\n1>源.c", "\n1>d:\\c++暂存文件\\project7\\project7\\源.c(41): warning C4013: “linsert”未定义；假设外部返回 int", "\n1>d:\\c++暂存文件\\project7\\project7\\源.c(60): error C2371: “linsert”: 重定义；不同的基类型", "\n1>已完成生成项目“Project7.vcxproj”的操作 - 失败。", "\n===== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ======"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;波特率115200&amp;#xff0c;数据每秒11KB左右&amp;#xff0c;4KB用300多毫秒&amp;#xff0c;差不多啊。要是嫌慢&amp;#xff0c;可以换c8051f340系列&amp;#xff0c;用USB&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C8051F020串口连续发送出现30延迟", ["问题遇到的现象和发生背景", "\n", "使用C8051F020实现ADC读取采样计算后使用串口连续发送，串口发送间隔在20ms左右，但是每发送4K数据就有300ms的延迟。", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include <c8051f020.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <", "string", ".h>\n#include <math.h>\n\n", "//宏声明", "\n#define uchar              unsigned char             ", "//定义uchar类型", "\n#define ", "uint", "               unsigned ", "int", "              ", "//定义uint类型", "\n#define BAUDRATE           ", "115200", "                    ", "//定义串口波特率", "\n#define SAR_CLK            ", "2500000", "                   ", "//定义SAR时钟熟读", "\n#define SAMPLE_RATE        ", "50000", "                     ", "//定义12位数模芯片采样率", "\n#define SYSTEMCLOCK        (", "22118400", "L)               ", "//定义外部晶振速率", "\n#define UART_SIZE          ", "128", "                       ", "//定义串口1读取数据位数", "\n#define SAMP_NUM           ", "22", "                        ", "//定义ADC数组采样数量", "\n#define OPERATING          -((SYSTEMCLOCK / SAMPLE_RATE) * SAMP_NUM) ", "//定义ADC运算转换频率", "\n\n", "//16位寄存器声明", "\nsfr16 ADC0                 = ", "0xbe", ";                   ", "//12位数模芯片数据定义", "\nsfr16 TMR2                 = ", "0xcc", ";                   ", "//定时器/计数器2初值", "\nsfr16 RCAP2                = ", "0xca", ";                   ", "//定时器/计数器2重载初值", "\nsfr16 TMR3                 = ", "0x94", ";                   ", "//定时器/计数器3初值", "\nsfr16 RCAP3                = ", "0x92", ";                   ", "//定时器/计数器3重载初值", "\nsfr16 TMR4                 = ", "0xF4", ";                   ", "//定时器/计数器4初值", "\nsfr16 RCAP4                = ", "0xE4", ";                   ", "//定时器/计数器4重载初值", "\n\n", "//引脚位声明", "\nsbit Auto_LED_RED          = P2^", "0", ";                   ", "//Auto红灯控制位", "\nsbit Auto_LED_GREEN        = P2^", "1", ";                   ", "//Auto绿灯控制位", "\nsbit ACK_LED_GREEN         = P3^", "1", ";                   ", "//ACK绿灯控制位", "\nsbit ACK_LED_RED           = P3^", "2", ";                   ", "//ACK红灯控制位", "\nsbit Watchdog              = P3^", "3", ";                   ", "//3.3V电源看门狗控制位", "\nsbit Manual_LED_RED        = P3^", "6", ";                   ", "//Manual红灯控制位", "\nsbit Manual_LED_GREEN      = P3^", "7", ";                   ", "//Manual绿灯控制位", "\n\n", "//函数声明", "\n", "void", " OSCILLATOR_Init (", "void", ");                         ", "//晶振初始化，切换为外部晶振", "\n", "void", " PORT_Init (", "void", ");                               ", "//单片机端口初始化", "\n", "void", " Ext_Interrupt_Init (", "void", ");                      ", "//外部中断初始化", "\n", "void", " Flash_WRITE(", "void", ");                              ", "//非易失128Bety Flash写入", "\n", "void", " Flash_READ(", "void", ");                               ", "//读取非易失Flash数据", "\n", "void", " ReadData(", "void", ");                                 ", "//读取非易失区数据", "\n", "void", " ReadData1(", "void", ");                                ", "//非中断读取非易失区数据", "\n", "void", " UART1_Init (", "void", ");                              ", "//初始化串口1", "\n", "void", " delay(", "uint", " num);                                ", "//延迟函数", "\n", "void", " TIMER2_Init();                                  ", "//初始化定时计数器2，设置功率轮询输出", "\n", "void", " TIMER3_Init (", "int", " counts);                       ", "//初始化定时计数器3，设置数模芯片转换速率", "\n", "void", " TIMER4_Init ();                                 ", "//初始化定时计数器4，监控串口接受数据间隔", "\n", "void", " ADC0_Init (", "void", ");                               ", "//初始化12位数模转换器", "\n", "void", " UART1_Deal(", "void", ");                               ", "//串口数据处理", "\n", "void", " AcceptReset(uchar output, uchar outarr[]);      ", "//串口数据清零", "\n", "void", " AcceptReset1(uchar output, uchar outarr[]);      ", "//串口数据清零", "\n\n", "//全局变量声明", "\n", "uint", " idata AckBlink = ", "0", ";                             ", "//显示频率", "\n", "uint", " idata SampNum = ", "0", ";                              ", "//采样循环次数", "\n", "uint", " idata Samp = ", "0", ";                                 ", "//采样数据", "\nlong idata SampArr = ", "0", ";                              ", "//存放累积采样数据", "\nlong idata SampArrAll= ", "0", ";                            ", "//保存组采样值", "\n", "float", " xdata Kvaule = ", "0", ";                              ", "//ADC斜率", "\n", "float", " xdata Bvalue = ", "0", ";                              ", "//ADC最小值", "\n", "float", " xdata Power = ", "0", ";                               ", "//光功率", "\nuchar idata Byte = ", "0", ";                                ", "//串口1读一位数据", "\nuchar idata InputCheck = ", "0", ";                          ", "//串口1输入累加校验和", "\nuchar idata OutputCheck = ", "0", ";                         ", "//串口1输出累加校验和", "\nuchar idata UART_Input_Size= ", "0", ";                      ", "//串口1输入数据计数", "\nuchar idata UART_Input_First= ", "0", ";                     ", "//串口1输入字符位数", "\nuchar xdata UART_Input[UART_SIZE];                   ", "//串口1读取数据大小    ", "\nuchar idata UART_output_Size = ", "0", ";                    ", "//串口1输出数据计数", "\nuchar idata UART_output_First= ", "0", ";                    ", "//串口1输出字符位数", "\nuchar xdata UART_output[UART_SIZE];                  ", "//串口1读出数据大小", "\nuchar xdata Permanent_data[", "128", "];                     ", "//不丢失数据", "\nuchar code outok[] = {", "0xEF", ", ", "0x00", ", ", "0x4F", ", ", "0x3E", "};       ", "//正确返回值", "\nuchar code outon[] = {", "0xEF", ", ", "0x00", ", ", "0x58", ", ", "0x47", "};       ", "//错误返回值", "\nuchar xdata outarr[", "128", "] = {", "0xEF", "};                    ", "//返回值", "\nuchar tempchar[", "4", "];                                   ", "//char转float数组", "\n", "float", " * tempfloat;                                   ", "//char转float指针", "\nuchar pollflag = ", "0", ";                                  ", "//轮询功率开关", "\n\n", "//主函数", "\n", "void", " main(", "void", ")\n{\n     WDTCN = ", "0xde", ";                                     ", "//关闭单片机内部看门狗", "\n   WDTCN = ", "0xad", ";                                     ", "//关闭单片机内部看门狗", "\n    \n     OSCILLATOR_Init();                                ", "//初始化晶振", "\n     ReadData1();                                      ", "//非中断读取非易失区数据", "\n     PORT_Init();                                      ", "//初始端口", "\n     Ext_Interrupt_Init();                             ", "//初始化外部中断", "\n     UART1_Init();                                     ", "//初始化串口1", "\n     TIMER2_Init();                                    ", "//初始化定时计数器2，设置功率轮询输出", "\n     TIMER3_Init(SYSTEMCLOCK/SAMPLE_RATE);             ", "//初始化定时器3,设置数模芯片转换速率", "\n     TIMER4_Init ();                                   ", "//初始化定时计数器4，监控串口接受数据间隔", "\n     ADC0_Init();                                      ", "//初始化12位数模转换器", "\n     AD0EN = ", "1", ";                                        ", "//打开12位数模转换器    ", "\n     EA    = ", "1", ";                                        ", "//打开所有中断  ", "\n\n     Manual_LED_GREEN = ", "0", ";                             ", "//关闭Manual灯", "\n     Manual_LED_RED   = ", "0", ";                             ", "//关闭Manual灯", "\n     Auto_LED_GREEN   = ", "0", ";                             ", "//关闭Auto灯", "\n     Auto_LED_RED     = ", "0", ";                             ", "//关闭Auto灯", "\n     ACK_LED_GREEN    = ", "0", ";                             ", "//关闭ACK灯", "\n     ACK_LED_RED      = ", "0", ";                             ", "//关闭ACK灯", "\n     P4               = ", "0xFF", ";                          ", "//将LED1~4号为灯亮红", "\n    \n    ", "while", "(", "1", ")\n    {\n        Watchdog = ", "0", ";                                       ", "//更新3.3V电源看门狗", "\n        Watchdog = ", "1", ";                                    ", "//更新3.3V电源看门狗", "\n        Auto_LED_RED = Manual_LED_GREEN = ", "0", ";             ", "//熄灭串口信号灯        ", "\n\n        ", "if", "(AckBlink > ", "0xDFFF", ")                            ", "//显示间隔", "\n        {\n            ACK_LED_GREEN = ~ACK_LED_GREEN;                ", "//闪烁ACK灯", "\n            AckBlink = ", "0", ";\n        }\n        \n        ", "//delay(1);", "\n        \n        AckBlink++;                                         ", "//显示次数累加", "\n    }\n\n}\n\n", "//延迟函数", "\n", "void", " delay(", "uint", " num)\n{\n    ", "uint", " i, j;\n    ", "for", "(i = ", "0", "; i < num; i++)\n        ", "for", "(j = ", "0", "; j < ", "200", "; j++);\n}\n\n", "//晶振初始化", "\n", "void", " OSCILLATOR_Init (", "void", ")\n{\n   ", "uint", " i;                                           ", "//定义累加值", "\n   OSCXCN = ", "0x67", ";                                    ", "//设置外部晶振22.1184MHz", "\n                                                       ", "//晶体振荡器方式，晶体振荡器未用或未稳定", "\n   ", "for", " (i=", "0", "; i < ", "256", "; i++) ;                         ", "//等待晶振运行", "\n   ", "while", " (!(OSCXCN & ", "0x80", "));                         ", "//等待晶振运行稳定", "\n   OSCICN = ", "0x88", ";                                    ", "//选择外部振荡器作为系统时钟", "\n                                                     ", "//允许时钟丢失检测器 检测到时钟丢失时间大于 100 微秒时将触发复位", "\n\n}\n\n", "//端口初始化", "\n", "void", " PORT_Init (", "void", ")\n{\n   XBR0      = ", "0x07", ";                                 ", "//设置P1.0为TX1，P1.1为RX1", "\n   XBR1      = ", "0x14", ";                                 ", "//设置P1.2为INT0，P1.3为INT1", "\n   XBR2      = ", "0x44", ";                                 ", "//设置P0.6为SDA，P0.7为SCL", "\n   \n   P0MDOUT   = ", "0xFF", ";                                 ", "//设置P0为推挽方式", "\n   P1MDOUT   = ", "0xFF", ";                                 ", "//设置P1为推挽方式", "\n   P2MDOUT   = ", "0xFF", ";                                 ", "//设置P2为推挽方式", "\n     P3MDOUT   = ", "0xFF", ";                                 ", "//设置P3为推挽方式", "\n     P74OUT    = ", "0xBF", ";                                 ", "//设置P4-P7为推挽方式", "\n}\n\n", "//外部中断初始化", "\n", "void", " Ext_Interrupt_Init (", "void", ")\n{\n   TCON = ", "0x05", ";                        ", "// /INT 0 和INT 1 边沿触发", "\n\n   EX0 = ", "1", ";                            ", "// 使能 /INT0 中断", "\n   EX1 = ", "1", ";                            ", "// 使能 /INT1 中断", "\n}\n\n", "//初始化串口1", "\n", "void", " UART1_Init (", "void", ")\n{\n   SCON1     = ", "0x50", ";                                 ", "//UART1 接收允许", "\n                                                       ", "//方式 1 8 位 UART 可变波特率", "\n   TMOD     &= ~", "0xF0", ";                                ", "//清除定时器 0设置", "\n   TMOD     |= ", "0x20", ";                                 ", "//自动重装载的 8 位计数器/定时器", "\n     PCON     |= ", "0x10", ";                                 ", "//禁止 UART1 的波特率/2 功能", "\n     CKCON    |= ", "0x10", ";                                 ", "//定时器 1 使用系统时钟", "\n     TH1       = -((SYSTEMCLOCK/BAUDRATE)/", "16", ");         ", "//设置定时器1 TH1初值", "\n   TL1       = TH1;                                  ", "//设置定时器1 TL1初值", "\n   TR1       = ", "1", ";                                    ", "//启动定时器1", "\n   EIE2      = ", "0x40", ";                                 ", "//允许 UART1 中断", "\n   EIP2      = ", "0x40", ";                                 ", "//外部中断 6 设置为高优先级", "\n}\n\n", "//初始化定时器3", "\n", "void", " TIMER3_Init (", "int", " counts)\n{\n   TMR3CN    = ", "0x02", ";                                 ", "//定时器3禁止;定时器3的时钟源由 T3M TMR3CN.1 位定义;计数器/定时器3使用系统时钟", "\n   RCAP3     = -counts;                              ", "//设置定时器重载初值", "\n   TMR3      = RCAP3;                                ", "//设置定时器初值", "\n   EIE2     &= ~", "0x01", ";                                ", "//禁止定时器3中断", "\n   TMR3CN   |= ", "0x04", ";                                 ", "//开始定时器3", "\n}\n\n", "//初始化12位数模转换器", "\n", "void", " ADC0_Init (", "void", ")\n{\n   ADC0CN    = ", "0x04", ";                                 ", "//ADC0禁止，当ADC被允许时除了转换期间之外一直处于跟踪方式", "\n                                                     ", "//定时器3溢出启动ADC0转换，数据右对齐", "\n   REF0CN    = ", "0x07", ";                                 ", "//内部电压基准缓冲器工作，内部电压基准提供从 VREF 引脚输出", "\n                                                     ", "//内部偏压发生器工作，内部温度传感器工作", "\n   AMX0CF    = ", "0x00", ";                                 ", "//ADC0独立的单端输入", "\n     AMX0SL    = ", "0x01", ";                                 ", "//选择AIN0.1引脚作为ADC0信号输入", "\n   ADC0CF    = (SYSTEMCLOCK/SAR_CLK) << ", "3", ";           ", "//ADC0转换时钟= 2.5MHz", "\n   ADC0CF   |= ", "0x00", ";                                 ", "//PGA增益= 1(默认)", "\n   EIE2     |= ", "0x02", ";                                 ", "//使ADC中断", "\n", "//     EIP2      = 0x03;                               //ADC 转换结束中断为高优先级", "\n                                                                                                         ", "//定时器 3 中断为高优先级", "\n}\n\n", "//初始化定时器4", "\n", "void", " TIMER4_Init ()\n{\n     CKCON &= ~", "0x40", ";                                   ", "//定时器 4 使用系统时钟12分频", "\n     RCAP4 = -(SYSTEMCLOCK/", "1000", "/", "12", "*", "5", ");                 ", "//定时器4在1 kHz溢出1ms", "\n   TMR4 = RCAP4;                                     ", "//设置定时器初值", "\n     T4CON &= ~", "0x80", ";                                   ", "//清除初始化标志", "\n     EIE2 |= ", "0x04", ";                                     ", "//启动定时器4中断", "\n     T4CON |= ", "0x04", ";                                    ", "//启动定时器4", "\n     ", "//T4CON &= ~0x04;                                    //关闭定时器4    ", "\n}\n\n", "//初始化定时器2", "\n", "void", " TIMER2_Init()\n{\n   CKCON |= ", "0x20", ";                                    ", "//定时器 2 使用系统时钟", "\n   RCAP2 = OPERATING;                                ", "//定时器2设置初值", "\n   TMR2 = RCAP2;                                     ", "//设置定时器初值", "\n     T2CON = ", "0x04", ";                                     ", "//使能定时器2自动填装", "\n     TF2 = ", "0", ";                                          ", "//清除初始化标志", "\n   ET2 = ", "1", ";                                          ", "//启动定时器2中断", "\n     TR2 = ", "1", ";                                          ", "//启动定时器2  ", "\n     ", "//PT2 = 1;                                          //定时器2优先级最高", "\n}\n\n", "//外部中断1", "\n", "void", " INT0_ISR (", "void", ") ", "int", "errupt ", "0", "\n{\n   pollflag = ", "1", ";", "//打开轮询", "\n}\n\n", "//外部中断2", "\n", "void", " INT1_ISR (", "void", ") ", "int", "errupt ", "2", "\n{\n   pollflag = ", "0", ";", "//关闭轮询", "\n}\n\n\n", "//功率轮询", "\n", "void", " Power_Poll (", "void", ") ", "int", "errupt ", "5", "\n{\n    \n    Power = ((", "float", ")SampArrAll * Kvaule + Bvalue * (", "float", ")SAMP_NUM ) / (", "float", ")SAMP_NUM;", "//计算光功率值dBm", "\n    \n    ", "if", "(Power <= ", "-65", ")                          ", "//测试最小值", "\n    {\n         Power = ", "-65", "; \n    }\n    ", "else", " ", "if", "(Power >= ", "10", ")                      ", "//测试最大值              ", "\n    {\n         Power = ", "10", ";\n    }\n    \n    ", "if", "(pollflag == ", "1", ")     \n    {  \n        ", "float", " temp = Power;                          ", "//将功率值读入缓冲区", "\n        char * temp1;                                ", "//零时指针 ", "\n        TMR2 = RCAP2;                                ", "//设置定时器初值", "\n        UART_output_Size = ", "6", ";\n        \n        temp1=(char*)(&temp);\n        outarr[", "0", "] = ", "0xEF", "; \n        outarr[", "1", "] = temp1[", "3", "];                        ", "//将缓冲器数据写入待发区", "\n        outarr[", "2", "] = temp1[", "2", "];        \n        outarr[", "3", "] = temp1[", "1", "];                              \n        outarr[", "4", "] = temp1[", "0", "];     \n        AcceptReset1(UART_output_Size, &outarr);         ", "//中断发送函数    ", "\n    }\n\n  TF2 = ", "0", ";                                         ", "//清除初始化标志", "\n}\n\n", "//12位数模转换器中断", "\n", "void", " ADC0_ISR (", "void", ") ", "int", "errupt ", "15", "\n{\n\n    ", "if", "(SampNum == SAMP_NUM)                                  ", "//判断采样次数", "\n    {\n        SampArrAll = SampArr;\n        SampArr = ", "0", ";\n        SampNum = ", "0", ";\n    }\n    \n    Samp = ADC0;                                       ", "//写入采样值", "\n    SampNum++;                                         ", "//累加", "\n    SampArr += ADC0;                                   ", "//读取采样放入数组", "\n\n  AD0INT = ", "0", ";                                        ", "//采样中断标志位清零", "\n}\n\n", "//串口接受间隔", "\n", "void", " UART1_time (", "void", ") ", "int", "errupt ", "16", "\n{\n   uchar i;\n     TMR4 = RCAP4;                                     ", "//设置定时器初值", "\n    \n     ", "for", "(i = ", "0", "; i < UART_Input_Size; i++)\n      UART_Input[i] = ", "0", ";                               ", "//清除发送缓冲器", "\n   InputCheck = ", "0", ";                                   ", "//输入校验和清零", "\n     UART_Input_Size = ", "0", ";                              ", "//发送数据计数清零", "\n      \n     T4CON &= ~", "0x80", ";                                   ", "//清除初始化标志", "\n}\n\n", "//串口1中断响应函数", "\n", "void", " UART1_Interrupt (", "void", ") ", "int", "errupt ", "20", "\n{\n   ", "if", " ((SCON1 & ", "0x01", ") == ", "0x01", ")                       ", "//判断RI1接收中断标志", "\n   {\n            TMR4 = RCAP4;                                  ", "//设置定时器初值     ", "\n          T4CON &= ~", "0x80", ";                                ", "//清除初始化标志", "\n      ", "if", "( UART_Input_Size == ", "0", ")                      ", "//检查是否输入了新单词", "\n            {\n                    UART_Input_First = ", "0", ";                      ", "//初始化数组序号", "\n            } \n      Byte  = SBUF1;                                 ", "//从超级终端读取字符    ", "\n      ", "if", " (UART_Input_Size < UART_SIZE)               ", "//判断读取数据是否超出", "\n      {\n         UART_Input[UART_Input_First] = Byte;        ", "//将Byte写入数组", "\n         UART_Input_Size++;                          ", "//更新数组大小", "\n         UART_Input_First++;                         ", "//更新数组位数", "\n                 Auto_LED_RED = ~Auto_LED_RED;               ", "//Auto灯闪烁", "\n      }\n            \n            ", "if", "(UART_Input_Size > ", "3", ")\n                 UART1_Deal();                               ", "//串口接受处理函数", "\n            SCON1 = (SCON1 & ", "0xFE", ");                        ", "//清零RI1接收中断标志位", "\n   }\n\n   ", "if", " ((SCON1 & ", "0x02", ") == ", "0x02", ")                       ", "//判断TI1发送中断标志", "\n   {\n      ", "if", " (UART_output_Size != ", "0", ")                     ", "//如果缓冲区不为空", "\n      {        \n         Byte = UART_output[UART_output_First];      ", "//在变量字节中存储一个字符", "\n         SBUF1 = Byte;                               ", "//将一位数据写入缓冲器", "\n         UART_output_First++;                        ", "//数组位累加", "\n         UART_output_Size--;                         ", "//数组总数减一", "\n                 Manual_LED_GREEN = ~Manual_LED_GREEN;       ", "//Manual灯闪烁", "\n      }\n      ", "else", "\n      {\n                 UART_output_First = ", "0", ";                      ", "//发送位清零", "\n                 ", "//UART_output_Size = 0;                       //发送数量清零", "\n      }\n            SCON1 = (SCON1 & ", "0xFD", ");                      ", "//清零TI1接收中断标志位", "\n   }\n }\n\n", "//非易失128Bety Flash写入", "\n", "void", " Flash_WRITE(", "void", ")\n{\n    uchar i;                                           ", "//初始化累加值", "\n    uchar xdata * pwrite;                              ", "//非易失区指针", "\n    uchar * pgen;                                      ", "//常规指针", "\n    EA = ", "0", ";                                            ", "//关闭所有中断", "\n  FLSCL = ", "0x01", ";                                      ", "//允许对Flash进行写入", "\n    PSCTL = ", "0x07", ";                                      ", "//允许对Flash进行擦除", "\n    pwrite = ", "0x1000", ";                                   ", "//指向Flash的首地址", "\n    *pwrite = ", "0", ";                                       ", "//擦除该Flash扇区", "\n    PSCTL = ", "0x05", ";                                      ", "//禁止对Flash进行擦除", "\n    pgen = &Permanent_data[", "0", "];                         ", "//将数组128位    数据写入Flash", "\n    ", "for", "(i = ", "0", "; i < ", "128", "; i++)\n        *pwrite++ = *pgen++;\n    FLSCL = ", "0x00", ";                                      ", "//禁止对Flash进行写入", "\n    PSCTL = ", "0x00", ";                                      ", "//禁止对Flash进行擦除", "\n    EA = ", "1", ";                                            ", "//打开所有中断", "\n}\n \n", "//读取非易失Flash数据", "\n", "void", " Flash_READ(", "void", ")\n{\n    uchar i;                                           ", "//初始化累加值", "\n    uchar code *pread;                                 ", "//程序存储空间指针", "\n    PSCTL = ", "0x04", ";                                      ", "//允许访问128K数据", "\n  EA = ", "0", ";                                            ", "//关闭所有中断", "\n    pread = ", "0x1000", ";                                    ", "//指向Flash的首地址", "\n    ", "for", "(i = ", "0", "; i < ", "128", "; i++)                           ", "//读取非易失Flash数据start到stop数据", "\n    {\n        Permanent_data[i] = *pread++;    \n    }  \n    PSCTL = ", "0x00", ";                                      ", "//禁止对Flash进行擦除", "\n    EA = ", "1", ";                                            ", "//打开所有中断", "\n}\n \n", "//串口数据处理", "\n", "void", " UART1_Deal(", "void", ")\n{\n    uchar i;                                          ", "//累加数", "\n    ", "if", "((UART_Input[", "0", "] == ", "0xEF", "))     ", "//验证引导码确定发送数据完成", "\n    {\n        InputCheck = ", "0", ";                              ", "//校验和清零", "\n        ", "for", "(i = ", "0", "; i < UART_Input_Size - ", "1", "; i++)       ", "//计算校验和", "\n            InputCheck += UART_Input[i];\n        ", "if", "(UART_Input[", "1", "] == ", "0x01", ")                        ", "//客户写入", "\n        {\n            ", "if", "((UART_Input[", "2", "] == ", "0x15", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//停止功率轮询", "\n            {    \n                 pollflag = ", "0", ";                                      ", "//关闭定时器2  ", "\n            }            \n            ", "else", " ", "if", "((UART_Input[", "2", "] == ", "0x16", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//开始功率轮询", "\n            {    \n                 pollflag = ", "1", ";                                      ", "//开启定时器2  ", "\n            }                    \n        }\n        ", "else", " ", "if", "(UART_Input[", "1", "] == ", "0x02", ")                     ", "//客户读取", "\n        {\n            ", "if", "((UART_Input[", "2", "] == ", "0x07", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//读取T1光功率", "\n            {\n                ", "float", " temp = Power;                         ", "//将功率值读入缓冲区", "\n                char * temp1;                                  ", "//零时指针 ", "\n                UART_output_Size = ", "6", ";\n                temp1=(char*)(&temp);\n                outarr[", "0", "] = ", "0xEF", "; \n                outarr[", "1", "] = temp1[", "3", "];                          ", "//将缓冲器数据写入待发区", "\n                outarr[", "2", "] = temp1[", "2", "];        \n                outarr[", "3", "] = temp1[", "1", "];                              \n                outarr[", "4", "] = temp1[", "0", "];    \n                AcceptReset(UART_output_Size, &outarr);    \n            }    \n        }\n        ", "else", " ", "if", "(UART_Input[", "1", "] == ", "0x11", ")                   ", "//后台写入", "\n        {\n            ", "if", "((UART_Input[", "2", "] == ", "0x00", ") && (UART_Input_Size == ", "0x0A", ") && (InputCheck == Byte))", "//写入SN号", "\n            {  \n                ", "for", "(i = ", "0", "; i < UART_Input_Size; i++)         ", "//将SN号写入到非易失FLASH", "\n                {\n                    ", "if", "((i > ", "2", ") && (i < UART_Input_Size ", "-1", "))\n                        Permanent_data[i", "-3", "] = UART_Input[i];   \n                }\n                Flash_WRITE();                               ", "//写入非易失Flash", "\n                ReadData();                                  ", "//读取非易失区数据", "\n                AcceptReset(", "4", ", &outok);    \n            }\n            ", "else", " ", "if", "((UART_Input[", "2", "] == ", "0x01", ") && (UART_Input_Size == ", "0x08", ") && (InputCheck == Byte))", "//写入T1K值(1550)", "\n            {\n                ", "for", "(i = ", "0", "; i < UART_Input_Size; i++)         ", "//T1K值写入到非易失FLASH", "\n                {\n                    ", "if", "((i > ", "2", ") && (i < ", "7", "))\n                        Permanent_data[i", "-3", "+", "6", "] = UART_Input[i];   \n                }\n                Flash_WRITE();                               ", "//写入非易失Flash", "\n                ReadData();                                  ", "//读取非易失区数据", "\n                AcceptReset(", "4", ", &outok);    \n            }\n            ", "else", " ", "if", "((UART_Input[", "2", "] == ", "0x05", ") && (UART_Input_Size == ", "0x08", ") && (InputCheck == Byte))", "//写入T1B值(1550)", "\n            {\n                ", "for", "(i = ", "0", "; i < UART_Input_Size; i++)         ", "//T1B值写入到非易失FLASH", "\n                {\n                    ", "if", "((i > ", "2", ") && (i < ", "7", "))\n                        Permanent_data[i", "-3", "+", "6", "+", "4", "*", "4", "] = UART_Input[i];   \n                }\n                Flash_WRITE();                               ", "//写入非易失Flash", "\n                ReadData();                                  ", "//读取非易失区数据", "\n                AcceptReset(", "4", ", &outok);                            \n            }\n        }\n        ", "else", " ", "if", "(UART_Input[", "1", "] == ", "0x12", ")", "//后台读取", "\n        {\n            ", "if", "((UART_Input[", "2", "] == ", "0x00", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//读取SN号", "\n            { \n                UART_output_Size = ", "8", ";\n                Flash_READ();                                  ", "//重新读取非易失区数据", "\n                ", "for", "(i = ", "1", "; i < UART_output_Size", "-1", "; i++)        ", "//将缓冲器数据写入待发区", "\n                {\n                    outarr[i] = Permanent_data[i", "-1", "];  \n                }    \n                AcceptReset(UART_output_Size, &outarr);\n            }\n            ", "else", " ", "if", "((UART_Input[", "2", "] == ", "0x01", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//读取T1K值(1550)", "\n            {\n                UART_output_Size = ", "6", ";\n                Flash_READ();                                  ", "//重新读取非易失区数据", "\n                ", "for", "(i = ", "1", "; i < UART_output_Size", "-1", "; i++)        ", "//将缓冲器数据写入待发区", "\n                {\n                    outarr[i] = Permanent_data[i", "-1", "+", "6", "];  \n                }    \n                AcceptReset(UART_output_Size, &outarr);        \n            }\n            ", "else", " ", "if", "((UART_Input[", "2", "] == ", "0x05", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//读取T1B值(1550)", "\n            {\n                UART_output_Size = ", "6", ";\n                Flash_READ();                                  ", "//重新读取非易失区数据", "\n                ", "for", "(i = ", "1", "; i < UART_output_Size", "-1", "; i++)        ", "//将缓冲器数据写入待发区", "\n                {\n                    outarr[i] = Permanent_data[i", "-1", "+", "6", "+", "4", "*", "4", "];  \n                }    \n                AcceptReset(UART_output_Size, &outarr);                            \n            }\n            ", "else", " ", "if", "((UART_Input[", "2", "] == ", "0x19", ") && (UART_Input_Size == ", "0x04", ") && (InputCheck == Byte))", "//读取T1采样值", "\n            {\n                ", "uint", " temp = Samp;                           ", "//将采样值读入缓冲区", "\n                UART_output_Size = ", "4", ";\n                outarr[", "0", "] = ", "0xEF", ";                     \n                outarr[", "2", "] = temp;                              ", "//将缓冲器数据写入待发区", "\n                temp = temp >> ", "8", ";\n                outarr[", "1", "] = temp;    \n                AcceptReset(UART_output_Size, &outarr);    \n            }\n        }\n    }\n}\n \n", "//发送接收缓冲器初始化", "\n", "void", " AcceptReset(uchar output, uchar outarr[])  \n{\n  uchar i;\n    InputCheck = ", "0", ";                                    ", "//输入校验和清零", "\n    OutputCheck = ", "0", ";                                   ", "//输出校验和清零", "\n    UART_output_First = ", "0", ";                             ", "//发送位清零  ", "\n    \n    UART_output_Size = output;                       ", "//初始化输出数组数量    ", "\n    \n    ", "for", "(i = ", "0", "; i < UART_output_Size - ", "1", "; i++)\n    {\n        UART_output[i] = outarr[i];                    ", "//写入返回数据", "\n        OutputCheck += outarr[i];                      ", "//计算输出校验和", "\n    }\n    UART_output[UART_output_Size", "-1", "] = OutputCheck;   ", "//写入返回最后数据", "\n    \n    SCON1 = (SCON1 | ", "0x02", ");                          ", "//激活串口RX标记位", "\n}\n\n", "//中断发送接收缓冲器初始化", "\n", "void", " AcceptReset1(uchar output, uchar outarr[])  \n{\n    uchar i;\n    InputCheck = ", "0", ";                                    ", "//输入校验和清零", "\n    OutputCheck = ", "0", ";                                   ", "//输出校验和清零", "\n    UART_output_First = ", "0", ";                             ", "//发送位清零  ", "\n    \n    UART_output_Size = output;                       ", "//初始化输出数组数量    ", "\n    \n    ", "for", "(i = ", "0", "; i < UART_output_Size - ", "1", "; i++)\n    {\n        UART_output[i] = outarr[i];                    ", "//写入返回数据", "\n        OutputCheck += outarr[i];                      ", "//计算输出校验和", "\n    }\n    UART_output[UART_output_Size", "-1", "] = OutputCheck;   ", "//写入返回最后数据", "\n    \n    SCON1 = (SCON1 | ", "0x02", ");                          ", "//激活串口RX标记位    ", "\n}\n\n", "//读取非易失区数据", "\n", "void", " ReadData(", "void", ")                                  \n{\n     Flash_READ();                                      ", "//将非易失Flash数据全部读入Permanent_data数组", "\n\n        tempchar[", "0", "] = Permanent_data[", "9", "];         ", "//读取非易失数据中K值(1550)", "\n        tempchar[", "1", "] = Permanent_data[", "8", "];\n        tempchar[", "2", "] = Permanent_data[", "7", "];\n        tempchar[", "3", "] = Permanent_data[", "6", "];\n        tempfloat=(", "float", "*)(&tempchar);\n        Kvaule = *tempfloat;\n         \n        tempchar[", "0", "] = Permanent_data[", "25", "];        ", "//读取非易失数据中B值(1550)", "\n        tempchar[", "1", "] = Permanent_data[", "24", "];\n        tempchar[", "2", "] = Permanent_data[", "23", "];\n        tempchar[", "3", "] = Permanent_data[", "22", "];\n        tempfloat=(", "float", "*)(&tempchar);\n        Bvalue = *tempfloat;\n         \n     \n}\n\n", "//非中断读取非易失区数据", "\n", "void", " ReadData1(", "void", ")                                  \n{\n     Flash_READ();                                      ", "//将非易失Flash数据全部读入Permanent_data数组", "\n    \n        tempchar[", "0", "] = Permanent_data[", "9", "];         ", "//读取非易失数据中K值(1550)", "\n        tempchar[", "1", "] = Permanent_data[", "8", "];\n        tempchar[", "2", "] = Permanent_data[", "7", "];\n        tempchar[", "3", "] = Permanent_data[", "6", "];\n        tempfloat=(", "float", "*)(&tempchar);\n        Kvaule = *tempfloat;\n         \n        tempchar[", "0", "] = Permanent_data[", "25", "];        ", "//读取非易失数据中B值(1550)", "\n        tempchar[", "1", "] = Permanent_data[", "24", "];\n        tempchar[", "2", "] = Permanent_data[", "23", "];\n        tempchar[", "3", "] = Permanent_data[", "22", "];\n        tempfloat=(", "float", "*)(&tempchar);\n        Bvalue = *tempfloat; \n\n     \n}\n\n", "\n", "运行结果及报错内容", "\n", "前面数据间隔还在20ms，后面就出现300ms延迟。", "\n", "我的解答思路和尝试过的方法", "\n", "关闭其他所有中断，尝试只用串口中断连续发送数据，也会周期性出现300ms延迟。", "\n", "我想要达到的结果", "\n", "在不使用DMA情况下，实现C8051F020连续发送数据，要求数据间隔保存在20~30ms。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;那就是程序崩溃了&lt;br /&gt;创建函数一开始就会崩溃&lt;br /&gt;void CreateList_Lsort(LinkList&amp;amp; L,int n) {&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    L-&amp;gt;next &amp;#61; NULL;&lt;/span&gt;&lt;br /&gt;LinkList是个指针&amp;#xff0c;还没有分配空间&amp;#xff0c;你就开始操作它的成员&amp;#xff0c;就会崩溃&lt;br /&gt;先L &amp;#61; new LinkList;&lt;br /&gt;然后才是L-&amp;gt;next &amp;#61; NULL;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["程序异常终止 ，但是没有报错", ["问题遇到的现象和发生背景", "\n", "不能正确运行，程序没执行完异常退出", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#include <iostream>", "\nusing namespace std;\n", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "\n", "#define ERROR 0", "\n", "#define OK 1", "\ntypedef int Status; ", "//", "单链表中的元素为整型 \ntypedef int ElemType;\n", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "\n\n", "//", "单链表的类型定义 \n\ntypedef struct  LNode {\n\n    ElemType data;  ", "//", " 数据域\n\n    struct LNode* ", "next", ";  ", "//", " 指针域\n\n}LNode, * LinkList;\n\n", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "\n\n", "//", "创建含n个元素的非递减有序单链表 ，注意插入排序 \n\nvoid CreateList_Lsort(LinkList& L,int n) {\n    L->", "next", " = NULL;\n    LNode* p_new = L->", "next", ";\n    ", "//", "新建立一个数组存放输入的元素的值\n    int a[", "1024", "];\n    ", "//", "利用冒泡发先对输入的数据进行排序\n    ", "for", " (int m = ", "0", "; m < n; ++m) { cin >> a[m]; }\n    int u, v,temp=", "0", ";\n    ", "for", "(u=", "0", ";u<n;++u)\n        ", "for", "(v=", "0", ";v<n-u-", "1", ";++v)\n        {\n            ", "if", " (a[v] <= a[v + ", "1", "]) {  temp = a[v]; a[v] = a[v + ", "1", "]; a[v + ", "1", "] = temp; }\n        }\n    ", "//", "创建一个链表按序将已经排列好的数据存放到链表中\n    ", "for", " (int j = ", "0", "; j < n; ++j) {\n        p_new = new LNode;\n        p_new->data=a[j];\n        p_new->", "next", " = L->", "next", ";\n        L->", "next", " = p_new;\n    }\n\n\n}", "//", "CreateList_Lsort\n\n\n\n", "//", "输出单链表\n\nStatus PrintList_L(LinkList L) {\n\n    LinkList p = L->", "next", ";\n\n    ", "while", " (p) {\n\n        cout << p->data << ", "\" \"", ";\n\n        p = p->", "next", ";\n\n    }\n\n    cout << endl;\n\n    return OK;\n\n}", "//", "PrintList_L\n\nint main() {\n\n    LinkList La；\n    int n;\n    cin >> n;", "//", "输入线性链表La的长度\n    CreateList_Lsort(La, n);\n    PrintList_L(La);\n    return ", "0", ";\n\n}\n\n", "\n", "运行结果及报错内容", "\n", "0x00ED6A4B 处(位于 test.exe 中)引发的异常: 0xC0000005: 写入位置 0xCCCCCCD0 时发生访问冲突。"]], "Tag": "程序设计"}
{"Answer": "重新编译下配置文件  sudo source /etc/vim/vimrc", "Konwledge_Point": "定义新的类型", "Question": ["ubuntu中已经对VIM进行设置，为什么仍然没有语法高亮？", ["etc/vim中的vimrc中内容如下，重启过后仍然没有语法高亮", "\n\n", " \" All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by\n\" the call to :runtime you can find below.  If you wish to change any of those\n\" settings, you should do it in this file (/etc/vim/vimrc), since debian.vim\n\" will be overwritten everytime an upgrade of the vim packages is performed.\n\" It is recommended to make changes after sourcing debian.vim since it alters\n\" the value of the 'compatible' option.\n\n\" This line should not be removed as it ensures that various options are\n\" properly set to work with the Vim-related packages available in Debian.\nruntime! debian.vim\n\n\" Uncomment the next line to make Vim more Vi-compatible\n\" NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous\n\" options, so any other options should be set AFTER setting 'compatible'.\n\"set compatible\n\n\" Vim5 and later versions support syntax highlighting. Uncommenting the next\n\" line enables syntax highlighting by default.\nif has(\"syntax\")\n  syntax on\nendif\n\n\" If using a dark background within the editing area and syntax highlighting\n\" turn on this option as well\n\"set background=dark\n\n\" Uncomment the following to have Vim jump to the last position when\n\" reopening a file\n\"if has(\"autocmd\")\n\"  au BufReadPost * if line(\"'\\\"\") > 1 && line(\"'\\\"\") <= line(\"$\") | exe \"normal! g'\\\"\" | endif\n\"endif\n\n\" Uncomment the following to have Vim load indentation rules and plugins\n\" according to the detected filetype.\n\"if has(\"autocmd\")\n\"  filetype plugin indent on\n\"endif\n\n\" The following are commented out as they cause vim to behave a lot\n\" differently from regular Vi. They are highly recommended though.\n\"set showcmd        \" Show (partial) command in status line.\n\"set showmatch      \" Show matching brackets.\n\"set ignorecase     \" Do case insensitive matching\n\"set smartcase      \" Do smart case matching\n\"set incsearch      \" Incremental search\n\"set autowrite      \" Automatically save before commands like :next and :make\n\"set hidden     \" Hide buffers when they are abandoned\n\"set mouse=a        \" Enable mouse usage (all modes)\n\n\" Source a global configuration file if available\nif filereadable(\"/etc/vim/vimrc.local\")\n  source /etc/vim/vimrc.local\nendif \n\nset ai                          \" 自动缩进，新行与前面的行保持—致的自动空格\nset aw                        \" 自动写，转入shell或件时，当前的缓冲区被写入\nset flash                     \" 在出错处闪烁但不呜叫(缺省)\nset ic                          \" 在查询及模式匹配时忽赂大小写\nset nu        \nset number                \" 屏幕左边显示行号\nset showmatch          \" 显示括号配对，当键入“]”“)”时，高亮度显示匹配的括号\nset showmode           \" 处于文本输入方式时加亮按钮条中的模式指示器\nset showcmd             \" 在状态栏显示目前所执行的完成的指令片段亦会显示出来\n\n\n\ncolorscheme peachpuff \" 设定背景为夜间模式\nfiletype plugin on        \" 自动识别文件类型，自n.vim”文件，使用缩进定义文件\nset autoindent            \" 设置自动缩进：即每行；使用 noautoindent 取消设置\nset cindent                 \" 以C/C++的模式缩进\nset noignorecase       \" 默认区分大小写\nset ruler                     \" 打开状态栏标尺\nset scrolloff=5            \" 设定光标离窗口上下边界 5 行时窗口自动滚动\nset shiftwidth=4          \" 设定 << 和 >> 命令移动时的宽度为 4\nset softtabstop=4       \" 使得按退格键时可以一次4 个时删掉所有剩下的空格）\nset tabstop=4             \" 设定 tab 长度为 4\nset wrap                     \" 自动换行显示\nsyntax enable\nsyntax on                    \" 自动语法\n"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这有个类似的问题, 你可以参考下: &lt;a href=\"https://ask.csdn.net/questions/7759599\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7759599&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言文件读取问题，向文件内存储数据成功但读取时屏幕输出全是零", ["\n", "typedef", " ", "struct", " ", "subjects", "        ", "//定义结构体叫作SUB，在后面就可以直接使用", "\n{\n     ", "int", " num;                 ", "//课程编号", "\n     ", "char", " name[", "30", "];           ", "//课程名称", "\n     ", "char", " kind[", "20", "];           ", "//课程性质", "\n     ", "int", " stime;               ", "//总学时", "\n     ", "int", " ttime;               ", "//授课学时", "\n     ", "int", " etime;               ", "//实验或上机学时", "\n     ", "int", " score;               ", "//学分", "\n     ", "int", " term;                ", "//开课学期", "\n     ", "struct", " ", "subjects", " *next;\n}SUB;       \n", "\n", "void choose()", "//选新课程--学生选课函数", "\n{\n    SUB *p,*q;\n    int a[", "5", "];\n    int num,total=", "0", ",i=", "0", ",j;  ", "//total为总学分，i为num的数组单元", "\n    printf(", "\"输入要选修的课程的编号,编号之间以空格分开\\n\"", ");\n    scanf(", "\"%d\"", ",&num);", "//接收输入的第一个编号", "\n    printf(", "\"如果确认输入完要选修的课程的编号,请输入0:\"", ");\n    ", "while", "(num!=", "0", ")", "//数据不为零，说明为输入的课程编号信息", "\n    {\n        ", "for", "(p=head;p;p=p->", "next)", "//在链表中从头找，直至找到最后一个节点的指针域指为空", "\n        {\n            ", "if", "(p->", "num==num)", "//编号一致的课程", "\n            {\n                ", "total", "=total+p->", "score;", "//将所找到的课程的学分累加", "\n                a[i]=num; ", "//数组a存课程编号num", "\n                i++;\n            }\n        }\n        scanf(", "\"%d\"", ",&num);", "//接收缓存区下一个数据", "\n    }\n    ", "if", "(total<", "60", ")\n    { \n        printf(", "\"选修总学分为%d,未达到60,选修失败!\\n\"", ",total);\n        system(", "\"pause\"", ");\n    }\n    ", "else", "\n    {\n        \n        FILE *fp;    ", "//声明fp是指针，用来指向FILE类型的对象，fp是指向文件结构体的指针变量", "\n        fp=fopen(", "\"3-2.txt\"", ",", "\"w\"", ");       ", "//打开文件，将学生选课信息写入文件", "\n        fprintf(fp,", "\"课程编号  课程名称  课程性质  总学时  授课学时  实践或上机学时  学分  开课学期\\n\"", ");\n        ", "for", "(j=", "0", ";j<i;j++)\n        {\n            ", "for", "(q=head;q;q=q->", "next)\n            {\n                ", "if", "(q->", "num==a[j])\n                {\n                    ", "//将学生选课信息输出输出到文件中", "\n                    ", "fprintf", "(fp,\"%5d%12s%9s%9d%9d%11d%11d%7d\\n\",q->", "num", ",q->", "name", ",q->", "kind", ",q->", "stime,\n                                                               ", "q", "->", "ttime", ",q->", "etime", ",q->", "score", ",q->", "term);\n                }\n            }\n        }\n        fclose(fp);  ", "//关闭文件", "\n        printf(", "\"\\t\\t\\n*****选修成功!****\\n\"", ");\n        printf(", "\"\\n您选修的课程总学分为%d,课程分别为:\\n\"", ",total);\n        printf(", "\"\\n课程编号  课程名称  课程性质  总学时  授课学时  实践或上机学时  学分  开课学期\\n\"", ");\n        ", "for", "(j=", "0", ";j<i;j++)\n        {\n            ", "for", "(q=head;q;q=q->", "next)\n            {\n                ", "if", "(q->", "num==a[j])\n                {\n                    ", "printf", "(\"%5d%12s%9s%9d%9d%11d%11d%7d\\n\",q->", "num", ",q->", "name", ",q->", "kind", ",q->", "stime,\n                                                           ", "q", "->", "ttime", ",q->", "etime", ",q->", "score", ",q->", "term);\n                }\n            }\n        }\n        printf(", "\"\\n以上信息全部保存在'3-2.txt'中\\n\"", ");\n    }\n    system(", "\"pause\"", ");   ", "//暂停，没这个语句点开生成的.exe文件", "\n}\n\n", "\n", "\nvoid prin1()   ", "//浏览学生所有选修课程", "\n{\n    SUB *ptr;    \n    FILE *fp;   ", "//声明fp是指针，用来指向FILE类型的对象，fp是指向文件结构体的指针变量", "\n    fp=fopen(", "\"3-2.txt\"", ",", "\"r\"", ");\n    ", "if", "(fp==NULL)\n    {\n        printf(", "\"Cannot open file.\\n\"", ");\n        choose();\n    }\n    printf(", "\"课程编号  课程名称  课程性质  总学时  授课学时  实践或上机学时  学分  开课学期\\n\"", ");\n    ", "while", "(!feof(fp))\n    {\n        ptr=(SUB*)malloc(sizeof(SUB));\n        ", "//从文件中读入数据", "\n        ", "fscanf", "(fp,\"%d%s%s%d%d%d%d%d\\n\",&ptr->", "num", ",ptr->", "name", ",ptr->", "kind", ",&ptr->", "stime,\n                                       &", "ptr", "->", "ttime", ",&ptr->", "etime", ",&ptr->", "score", ",&ptr->", "term);\n        ", "printf", "(\"%5d%12s%9s%9d%9d%11d%11d%7d\\n\",ptr->", "num", ",ptr->", "name", ",ptr->", "kind", ",ptr->", "stime,\n                                               ", "ptr", "->", "ttime", ",ptr->", "etime", ",ptr->", "score", ",ptr->", "term);\n    }\n    system(", "\"pause\"", ");\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;StackNode *NewNode&amp;#61;(StackNode *)malloc(sizeof (struct node));&lt;br /&gt;struct node就是StackNode&amp;#xff0c;两者相同。但没有struct StackNode这个东西&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言malloc，zsbd", ["问题遇到的现象和发生背景", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "//【任务2】在提示/**********blank**********/下面填写合适的内容完成算法设计，并上机调试程序。已知需要建立一个空的链栈，建立成功后元素依次入栈，s={56,89,71,25,69,48}，请将下面程序补充完整。", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "define", " TRUE 1", "\n", "#", "define", " FALSE 0", "\n", "typedef", " ", "int", " ElemType;\n", "//定义链栈结点类型", "\n", "typedef", " ", "struct", " ", "node", "\n{\n    ElemType data;\n    ", "struct", " ", "node", " *next;\n}StackNode,*LinkStack;\n\n", "//初始化链栈", "\n", "void", " ", "InitStack", "(LinkStack top)", "\n", "{    \n    top=(LinkStack)", "malloc", "(", "sizeof", "(StackNode));\n    top->next = ", "NULL", ";\n}\n\n", "//元素入栈", "\n", "int", " ", "Push", "(LinkStack top, ElemType x)", "\n", "{\n    StackNode *NewNode;\n    ", "//blank1：为结点NewNode分配存储空间", "\n    NewNode=( StackNode *)", "malloc", "(", "sizeof", " (", "struct", " node));\n    ", "if", "(NewNode==", "NULL", ")        ", "return", " (FALSE);\n    ", "//blank2：将数据x放入到结点NewNode的数据域中", "\n    NewNode->data=x;\n    ", "//blank3：头结点top的后继作为结点NewNode的后继", "\n    NewNode->next=top;\n    ", "//blank4：结点NewNode作为头结点top的新后继", "\n    top->next=NewNode->next;\n    ", "return", " (TRUE);\n}\n\n", "//元素出栈", "\n", "int", " ", "Pop", "(LinkStack top, ElemType *x)", "\n", "{\n    StackNode *DelNode;\n    DelNode=top->next;    ", "//指针DelNode指向删除结点", "\n    ", "if", "(DelNode==", "NULL", ")    ", "//栈空", "\n        ", "return", " (FALSE);\n    *x=DelNode->data;\n    ", "/**********blank**********/", "\n    ", "//blank5：被删除结点的后继成为头结点top的后继", "\n    top->next=top->next->next;\n    ", "//blank6：释放删除结点的存储空间", "\n    ", "free", "(top->next);\n    ", "return", " (TRUE);\n}\n\n", "//输出栈内的元素", "\n", "void", " ", "PrintStack", "(LinkStack top)", "\n", "{\n    StackNode *p = top->next;\n    ", "while", "(p!=", "NULL", ")\n    {\n        ", "printf", "(", "\"data=%d\\t\\t\"", ",p->data);\n        ", "printf", "(", "\"address=%d\\n\"", ",p->next);\n        p = p->next;\n    }\n}\n\n", "void", " ", "main", "()", "\n", "{\n    LinkStack top;\n    ", "int", " count,i,result;\n    ElemType x;\n    ", "//函数声明", "\n    ", "void", " ", "InitStack", "(LinkStack top)", ";\n    ", "int", " ", "Push", "(LinkStack top, ElemType x)", ";\n    ", "int", " ", "Pop", "(LinkStack top, ElemType *x)", ";\n    ", "void", " ", "PrintStack", "(LinkStack top)", ";\n    ", "printf", "(", "\"链栈初始化...\\n\"", ");\n    ", "InitStack", "(top);       ", "//调用初始化函数", "\n    ", "printf", "(", "\"初始化完成\\n\"", ");\n    ", "printf", "(", "\"\\n输入需要入栈的元素个数：\"", ");\n    ", "scanf_s", "(", "\"%d\"", ",&count);\n    ", "for", "(i=", "1", ";i<=count;i++) \n    {\n        ", "printf", "(", "\"输入第%d个入栈的元素：\"", ",i);\n        ", "scanf_s", "(", "\"%d\"", ",&x);\n        result=", "Push", "(top, x);    ", "//调用入栈函数", "\n        ", "if", "(result==", "1", ")\n            ", "printf", "(", "\"当前元素入栈成功\\n\"", ");\n        ", "else", "\n            ", "printf", "(", "\"存储空间分配失败，当前元素无法入栈\\n\"", ");\n    }\n    ", "printf", "(", "\"\\n入栈完毕，输出当前栈内元素\\n\"", ");\n    ", "PrintStack", "(top);\n    result=", "Pop", "(top,&x);            ", "//调用出栈函数", "\n    ", "if", "(result==", "1", ")\n    {\n        ", "printf", "(", "\"\\n出栈成功，出栈的栈顶元素值为%d，输出当前栈内元素\\n\"", ",x);\n        ", "PrintStack", "(top);        ", "//调用输出函数", "\n    }\n    ", "else", "\n        ", "printf", "(", "\"\\n栈空，无法出栈\\n\"", ");\n}\n", "\n", "运行结果及报错内容", "\n", "使用了未初始化的局部变量“top” ", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "用代码插入功能啊，指出哪一个函数有问题", "Konwledge_Point": "定义新的类型", "Question": ["c语言数据结构词索引表出了点问题，谁能帮忙看看呀", ["#include", "\n#include", "\n#include", "\n#include ", "\n#include ", "\n\n", "#define OK 1", "\n#define ERROR 0", "\n#define TRUE 1", "\n#define FALSE 0", "\n#define OVERFLOW -2", "\n\n", "#define MaxBookNum 1000 //假设只对1000本书建立索引表(1000)", "\n#define MaxKeyNum 2500 //索引表的最大容量(2500)", "\n#define MaxLineLen 500 //书目串的最大长度(500)", "\n#define MaxWordNum 10 //词表的最大容量", "\n#define MaxWordLength 30 //单词的最大长度", "\n\n", "typedef int Status;", "\ntypedef int ElemType; //定义链表的数据元素类型为整型", "\ntypedef int Boolean;", "\ntypedef struct", "\n{", "\nchar item[MaxWordNum][MaxWordLength]; //字符串的数组", "\nint last; //词表的长度", "\n}WordListType; //词表的类型（顺序表）", "\ntypedef struct", "\n{", "\nchar ", "ch; //如果是非空串，则按串长分配存储区，否则ch为NULL", "\nint length; //串长度", "\n}HString;", "\ntypedef struct LNode", "\n{", "\nElemType data;", "\nstruct LNode *next;", "\n}LNode,*Link,*Position;", "\ntypedef struct", "\n{", "\nLink head,tail;", "\nint len;", "\n}LinkList;", "\ntypedef struct", "\n{", "\nHString key; //关键词", "\nLinkList bnolist; //存放书号索引的链表", "\n}IdxTermType; //索引项类型", "\ntypedef struct", "\n{", "\nIdxTermType item[MaxKeyNum+1];", "\nint last;", "\n}IdxListType; //索引表类型", "\n//----------------主要变量--------------", "\nchar buf[MaxLineLen]; //书目串缓冲区", "\nWordListType wdlist; //关键字词表", "\nIdxListType idxlist; //索引表", "\nchar oftenwords[6][10] = {\"an\",\"a\",\"of\",\"and\",\"to\",\"the\"};", "\n/", "******************************声明部分****************************************/", "\n//--------------基本操作---------", "\nvoid InitIdxList (IdxListType ", "idxlist);", "\n//初始化操作，置索引表idxlist为空表，且在idxlist.item[0]设一空串", "\nvoid GetLine (FILE *f);", "\n//从文件F读入一个书目信息到书目串缓冲区buf", "\nvoid ExtractKeyWord (int *Num);", "\n//Status ExtractKeyWord(char", " Buffer,WordListType *w,int *Num);", "\n//从buf中提取书名关键词到词表wdlist，书号存入bno", "\nStatus InsIdxList (IdxListType *idxlist,ElemType bno);", "\n//将书号为bno的书名关键词按词典顺序插入索引表idxlist", "\nvoid PutText (FILE *g,IdxListType idxlist);", "\n//将生成的索引表idxlist输出到文件g", "\n//--------------为实现在索引表上进行插入，要先实现下列操作-----------", "\nvoid GetWord (int i,HString *wd);", "\n//用wd返回词表wdist中第i个关键词", "\nint Locate (IdxListType *idxlist,HString wd,Boolean *b);", "\n//在索引表idxlist中查询是否存在与wd相等的关键词。若存在，则返回其在索引表", "\n//中的位置，且b取值TRUE；否则返回插入位置，且b取值FALSE", "\nvoid InsertNewKey(int j,HString wd);", "\n//在索引表idxli的第i项上插入新关键词wd，并初始化书号索引的链表为空表", "\nStatus InsertBook (int i,int bno);", "\n//在索引表idxlist的第i项中插入书号为bno的索引", "\n//------------串的堆分配存储表示-----------", "\nStatus StrAssign(HString *T,char *chars);", "\n//生成一个其值等于串常量chars的串T", "\nint StrCompare(HString S,HString T);", "\n//若S>T，则返回值>0,若S=T，则返回值 = 0，若S<T，则返回值<0", "\nStatus StrCopy(HString *T, HString S);", "\n//由串S复制得串T", "\n\n", "//----------------带头结点的线性链表-------------", "\n\n", "Status InitList(LinkList *L);", "\n//构造一个空的线性链表L", "\n\n", "Status MakeNode(Link *p,ElemType e);", "\n//分配由p指向值e的结点，并返回OK；若分配失败，则返回ERROR", "\n\n", "Status Append (LinkList *L,Link s);", "\n//将指针s所指的一串结点链接在线性链表L的最后一个结点", "\n//之后，改变链表L的尾指针指向新的尾结点", "\n\n", "/*******************************函数部分****************************************/", "\nStatus StrAssign(HString ", "T,char *chars)", "\n{", "\nint i = strlen(chars);", "\nif((*T).ch)", "\nfree((*T).ch);", "\nif(!i){ //若chars为空", "\n(*T).ch = NULL;", "\n(*T).length = 0;", "\n}", "\nelse{ //chars不空", "\nif(!((*T).ch = (char *)malloc(i * sizeof(char)))) //为T分配chars所需的存储空间", "\nexit(OVERFLOW);", "\nint count;", "\nfor(count = 0;count <= i;count++) //把chars存入T中", "\n(*T).ch[count] = chars[count];", "\n(*T).length = i;", "\n} //else", "\nreturn OK;", "\n}", "\nvoid InitString(HString *T)", "\n{", "\n(*T).length = 0;", "\n(*T).ch = NULL;", "\n}", "\nint StrCompare(HString S,HString T)", "\n{", "\nint count;", "\nfor(count = 0;count<S.length && count<T.length;count++){", "\nif(S.ch[count] != T.ch[count])", "\nreturn S.ch[count]-T.ch[count] ;", "\n}", "\nreturn S.length-T.length;", "\n}", "\nStatus StrCopy(HString *T, HString S)", "\n{", "\nint j;", "\nif((*T).ch)", "\nfree((*T).ch); //删除T串中原有值", "\n(*T).ch = (char", ")malloc(S.length * sizeof(char));", "\nif(!(*T).ch)", "\nexit(OVERFLOW);", "\nfor(j = 0; j <= S.length; j++)", "\n(*T).ch[j] = S.ch[j];", "\n(*T).length = S.length;", "\nreturn OK;", "\n}", "\nStatus InitList(LinkList *L)", "\n{", "\nLink p;", "\np = (Link)malloc(sizeof(LNode));", "\nif(!p)", "\nexit(OVERFLOW);", "\np->next = NULL;", "\n(*L).head = (*L).tail = p;", "\n(*L).len = 0;", "\nreturn OK;", "\n}", "\nStatus MakeNode(Link *p,ElemType e)", "\n{", "\n*p = (Link)malloc(sizeof(LNode));", "\nif(!(*p))", "\nexit(OVERFLOW);", "\n(*p)->data = e;", "\n(*p)->next = NULL;", "\nreturn OK;", "\n}", "\nStatus Append (LinkList *L,Link s)", "\n{", "\nint i = 1;", "\n(*L).tail->next = s;", "\nwhile(s->next){", "\ns = s->next;", "\ni++;", "\n}", "\n(*L).tail = s;", "\n(*L).len += i;", "\nreturn OK;", "\n}", "\nvoid GetWord(int i,HString *wd)", "\n{", "\nchar *p;", "\np = *(wdlist.item +i);", "\nStrAssign(wd,p); //生成关键字字符串", "\n}", "\nint Locate(IdxListType *idxlist,HString wd,Boolean *b)", "\n{", "\nint i,m;", "\nfor(i = (*idxlist).last-1; ( m=StrCompare((*idxlist).item[i].key,wd) ) >0; --i);", "\n\n", "if(m == 0){ //找到", "b = TRUE;", "\nreturn i;", "\n}", "\nelse{", "\n*b = FALSE;", "\nreturn i+1;", "\n}", "\n}", "\nvoid InsertNewKey(int j,HString wd)", "\n{", "\nint count;", "\nInitList(&idxlist.item[idxlist.last+1].bnolist);", "\nfor(count = idxlist.last-1; count>=j; --count){ //后移索引项", "\nidxlist.item[count+1] = idxlist.item[count];", "\n}", "\nInitString(&idxlist.item[j].key);", "\nStrCopy(&idxlist.item[j].key,wd); //插入新的索引项 //串赋值", "\nInitList(&idxlist.item[j].bnolist); //初始化书号索引表为空表", "\n++idxlist.last;", "\n}", "\nStatus InsertBook (int i,int bookno)", "\n{", "\nLink p;", "\nif(!MakeNode(&p,bookno))", "\nreturn ERROR;", "\nAppend(&idxlist.item[i].bnolist,p);", "\nreturn OK;", "\n}", "\nStatus InsertIdxList(IdxListType *idxlist,int bno)", "\n{", "\nint i,j;", "\nHString wd;", "\nBoolean b;", "\nInitString(&wd);", "\nfor(i= 0;i<wdlist.last;++i){", "\nGetWord(i,&wd); //获取wdlist中保存的单词", "\nj = Locate(idxlist,wd,&b); //查找是否已存在于idxlist中", "\nif(!b) //不存在", "\nInsertNewKey(j,wd); //则插入新的关键词", "\nInsertBook(j,bno); //插入书号", "\n}", "\nreturn OK;", "\n}", "\nvoid InitIdxList (IdxListType *idxlist)", "\n{", "\nint i;", "\n(*idxlist).last = 0;", "\nfor(i = 0;i<MaxKeyNum;i++){", "\nInitList(&(*idxlist).item[i].bnolist); //初始化索引表项目中的书号的链表", "\n}", "\n}", "\nvoid ExtractKeyWord (int *BookNum)", "\n{", "\nint i = 0,j = 0,k = 0,m;", "\nwdlist.last = 0; //很重要", "\nBoolean Ignore;", "\nchar TempChar[30];", "\nfor(m = 0;m<=30;m++)", "\nTempChar[m] = '\\0'; //清空TempChat[]", "\nwhile(", "(buf+i) !=' '){ //提取书目串缓冲区其中的书号", "\nTempChar[i] = ", "(buf+i); //将书号以字符串类型保存在该数组中", "\ni++;", "\n}", "\nTempChar[i] ='\\0';", "\n*BookNum = atoi(TempChar); //将书号转为int", "\nfor(m = 0;m<=i;m++)", "\nTempChar[m] ='\\0'; //清空TempChat[]", "\ni++; //推进一位，当前", "(buf+i)开始为书名", "\nwhile(*(buf+i) !='\\n' && ", "(buf+i) != '\\0'){", "\n//每个字符串末尾都有结束符\\n", "\nif(", "(buf+i) != ' '){ //若非空字符", "\nif(*(buf+i) >'A'&& *(buf+i) <= 'Z'){", "\n*(buf+i) -= 'A' - 'a'; //若为大写，则转为小写", "\n}", "\nTempChar[j] = *(buf+i); //把当前字符加入TempChar中//------------", "\nj++;", "\ni++;", "\n} //if", "\nelse{ //若为空字符，则检索当前TempChar中保存的字符串是否为常用词", "\nIgnore = FALSE; //若Ignore为TRUE，则为常用词；为FALSE则不是常用词", "\n\n", "for(m = 0;m<6;m++){ //查找是否为常用词", "\nif(strcmp(TempChar,oftenwords[m]) == 0){", "\nIgnore = TRUE; //是常用词", "\nbreak;", "\n}//if", "\n}//for", "\nif(Ignore){", "\nfor(m = 0;m<=j;m++)", "\nTempChar[m] = '\\0'; //清空TempChat[]", "\ni++;", "\nj = 0;", "\n}//if", "\nelse{ //不是常用词", "\nfor(m = 0;m<=j;m++) //将该词插入wdlist中", "\nwdlist.item[wdlist.last][m] = TempChar[m];", "\nfor(m = 0;m<=j;m++)", "\nTempChar[m] = '\\0'; //清空TempChat[]", "\nk++;", "\nwdlist.last++;", "\ni++;", "\nj=0;", "\n}//else", "\n}//else", "\n\n", "}//while", "\n}", "\n\n", "void GetLine(FILE *f)", "\n{", "\nfgets(buf,MaxLineLen,f);", "\n}", "\n\n", "void PutText (FILE ", "g,IdxListType idxlist)", "\n{", "\nint i,j,k;", "\nLink p;", "\nfor(i = 0;i<=idxlist.last;i++){", "\nfor(j = 0;j<idxlist.item[i].key.length; j++)", "\nputc(", "(idxlist.item[i].key.ch + j),g);", "\nputc('\\t',g);", "\nif(idxlist.item[i].key.length < 8)", "\nputc('\\t',g);", "\np = idxlist.item[i].bnolist.head;", "\nfor(k = 0;k\np = p->next;", "\nfprintf(g,\"%03d\",p->data);", "\nputc(' ',g);", "\n}//for", "\nputc('\\n',g);", "\n}//for", "\n}", "\n\n", "void PrintFile(FILE *FileName)", "\n{", "\nchar ch;", "\nrewind(FileName);", "\nch = getc(FileName);", "\nwhile(ch != EOF){", "\nputchar(ch);", "\nch = getc(FileName);", "\n}", "\nprintf(\"\\n\");", "\nrewind(FileName);", "\n}", "\n\n", "/*******************************主函数部分**************************************/", "\n\n", "int main()", "\n{", "\nFILE *f,*g;", "\nint ct;", "\nint BookNo;", "\nif((f = fopen(\"BookName.txt\",\"r\")) == NULL){", "\nprintf(\"ERROR in open BookName.txt\\n\");", "\nexit(1);", "\n}", "\nif((g = fopen(\"KeyWordIndex_self.txt\",\"w\"))==NULL){", "\nprintf(\"ERROR in open KeyWordIndex_self.txt\\n\");", "\nexit(1);", "\n}", "\nprintf(\"书单文件：\\n\");", "\nPrintFile(f);", "\nInitIdxList(&idxlist);", "\nWordListType w;", "\nwhile(!feof(f)){", "\nGetLine(f); //读取书单文件中的一行到缓冲区", "\nExtractKeyWord(&BookNo);", "\nInsertIdxList(&idxlist,BookNo);", "\n}", "\nPutText(g,idxlist);", "\nfclose(f);", "\nfclose(g);", "\nprintf(\"\\n结果如下：\\n\");", "\nif((g = fopen(\"KeyWordIndex_self.txt\",\"r\"))==NULL){", "\nprintf(\"ERROR in open KeyWorkIndex_self.txt\\n\");", "\nexit(1);", "\n}", "\nPrintFile(g);", "\nfclose(g);", "\nreturn 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "complex拼写错误\r\n\r\n```\r\n#include &lt;iostream&gt;\r\nusing namespace std; \r\n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\r\n\r\n/*思考:基于上面的Complex类，有如下main函数能否通过运行，有那些是错误的，为什么?\r\nint main()\r\n{\r\nComplex a,b;\r\nComplex c=a+b;\r\nComplex d=a;\r\nComplex e;\r\ne=a;\r\nreturn 0;\r\n}*/\r\nclass Complex{\r\n    public:\r\n        void getRI(float R,float I);     //设置复数的两个私有成员\r\n        void output();                   //输出这个复数\r\n        void add(Complex c);             //与另一复数的加法函数 原型为 add (Complex c);\r\n        void isEqual(Complex c);         //判断与另一复数是否相等\r\n        Complex(){                       //不带参数的构造函数 \r\n            real=0;\r\n            imaginary=0;\r\n        } \r\n        Complex(float R,float I);        //以实部和虚部构造\r\n        Complex(Complex &amp;c);             //复制构造函数 \r\n    private:\r\n        float real,imaginary;\r\n};\r\nComplex::Complex(float R,float I)      //带参数构造函数的实现 \r\n{\r\n    real=R;\r\n    imaginary=I;\r\n}\r\nComplex::Complex(Complex &amp;c){\r\n    real=c.real;\r\n    imaginary=c.imaginary;\r\n    cout&lt;&lt;\"calling the copy constructor\"&lt;&lt;endl;\r\n} \r\nvoid Complex::getRI(float R,float I){\r\n    real=R;\r\n    imaginary=I;\r\n}\r\nvoid Complex::output(){\r\n    cout&lt;&lt;real&lt;&lt;\"+\"&lt;&lt;imaginary&lt;&lt;\"i\"&lt;&lt;endl; \r\n}\r\nvoid Complex::add(Complex c){\r\n    cout&lt;&lt;\"两复数相加为:\";\r\n    cout&lt;&lt;real+c.real&lt;&lt;\"+\"&lt;&lt;imaginary+c.imaginary&lt;&lt;\"i\"&lt;&lt;endl;\r\n}\r\nvoid Complex::isEqual(Complex c){\r\n    if(real==c.real)\r\n    {\r\n        if(imaginary==c.imaginary)\r\n            cout&lt;&lt;\"They are equal.\"&lt;&lt;endl;\r\n    }\r\n    else\r\n        cout&lt;&lt;\"They are not equal.\"&lt;&lt;endl;\r\n}\r\nint main(int argc, char** argv) {\r\n    Complex c1;\r\n    Complex c2(1,2);       //调用带参数的构造函数\r\n    Complex c3(c2);        //用对象c2初始化对象c3，复制构造函数被调用 \r\n        Complex myComplex,a;             //定义两个对象\r\n    float R1,I1,R2,I2;\r\n    cin&gt;&gt;R1&gt;&gt;I1;\r\n    cin&gt;&gt;R2&gt;&gt;I2;\r\n    myComplex.getRI(R1,I1);\r\n    a.getRI(R2,I2);\r\n    cout&lt;&lt;\"复数myComplex为:\";\r\n    myComplex.output();\r\n    cout&lt;&lt;\"复数c为:\";\r\n    a.output();\r\n    myComplex.add(a);        \r\n    /*函数调用的时候不用\r\n    也不可以包含两类型名，\r\n    应该写成myComplex.add(c); */ \r\n    myComplex.isEqual(a);\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "定义新的类型", "Question": ["为什么会出错？构造函数应该怎么调用？", ["\n/*6. 更加完整建立一个复数类 Complex，要求", "\na. 含两个私有数据成员:real, imaginary: float", "\nb. 具有三种构造函数:a.不带参数构造: 0+0i", "\n    b.以实部和虚部构造 ", "\n    c.拷贝构造函数", "\nc.公有成员函数包括如下功能:", "\n输出这个复数", "\n与另一复数的加法函数，要求函数原型为 complex add(complex c);", "\n判断与另一复数是否相等 要求函数原型为bool isEqual(complex c);", "\n在main函数中，输入两个复数，判断两个复数是否相等（实部和虚部要分别相等），然后两者相加之和赋值给一个新的复数，并输出", "\n\n", "#include <iostream>\nusing namespace std; \n/* run this program using the console pauser or add your own getch, system(\"pause\") or input loop */\n\n思考:基于上面的Complex类，有如下main函数能否通过运行，有那些是错误的，为什么?\nint main()\n{\nComplex a,b;\nComplex c=a+b;\nComplex d=a;\nComplex e;\ne=a;\nreturn 0;\n}*/\nclass Complex{\n    public:\n        void getRI(float R,float I);     //设置复数的两个私有成员\n        void output();                   //输出这个复数\n        void add(Complex c);             //与另一复数的加法函数 原型为 add (Complex c);\n        void isEqual(Complex c);         //判断与另一复数是否相等\n        Complex(){                       //不带参数的构造函数 \n            real=0;\n            imaginary=0;\n        } \n        Complex(float R,float I);        //以实部和虚部构造\n        Complex(Complex &c);             //复制构造函数 \n    private:\n        float real,imaginary;\n};\nComplex::Complex(float R,float I)      //带参数构造函数的实现 \n{\n    real=R;\n    imaginary=I;\n}\nComplex::Comeplex(Complex &c){\n    real=c.real;\n    imaginary=c.imaginary;\n    cout<<\"calling the copy constructor\"<<endl;\n} \nvoid Complex::getRI(float R,float I){\n    real=R;\n    imaginary=I;\n}\nvoid Complex::output(){\n    cout<<real<<\"+\"<<imaginary<<\"i\"<<endl; \n}\nvoid Complex::add(Complex c){\n    cout<<\"两复数相加为:\";\n    cout<<real+c.real<<\"+\"<<imaginary+c.imaginary<<\"i\"<<endl;\n}\nvoid Complex::isEqual(Complex c){\n    if(real==c.real)\n    {\n        if(imaginary==c.imaginary)\n            cout<<\"They are equal.\"<<endl;\n    }\n    else\n        cout<<\"They are not equal.\"<<endl;\n}\nint main(int argc, char** argv) {\n    Complex c1;\n    Complex c2(1,2);       //调用带参数的构造函数\n    Complex c3(c2);        //用对象c2初始化对象c3，复制构造函数被调用 \n        Complex myComplex,a;             //定义两个对象\n    float R1,I1,R2,I2;\n    cin>>R1>>I1;\n    cin>>R2>>I2;\n    myComplex.getRI(R1,I1);\n    a.getRI(R2,I2);\n    cout<<\"复数myComplex为:\";\n    myComplex.output();\n    cout<<\"复数c为:\";\n    a.output();\n    myComplex.add(a);        \n    /*函数调用的时候不用\n    也不可以包含两类型名，\n    应该写成myComplex.add(c); */ \n    myComplex.isEqual(a);\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 100&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;swap&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *a, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c &amp;#61; *a;\n    *a &amp;#61; *b;\n    *b &amp;#61; c;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;reverse&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *s)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(s);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p &amp;#61; s;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *q &amp;#61; s &amp;#43; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p &amp;lt; q)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;swap&lt;/span&gt;(p, q);\n        p&amp;#43;&amp;#43;;\n        q--;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; a[N], b[N], c[N &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s%s&amp;#34;&lt;/span&gt;, a, b);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; na &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(a);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; nb &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(b);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *pa &amp;#61; a &amp;#43; na - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *pb &amp;#61; b &amp;#43; nb - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; carry &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pa &amp;gt;&amp;#61; a &amp;amp;&amp;amp; pb &amp;gt;&amp;#61; b)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; (*pa - &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;) &amp;#43; (*pb - &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;) &amp;#43; carry;\n        c[i&amp;#43;&amp;#43;] &amp;#61; x % &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n        carry &amp;#61; x / &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n        pa--;\n        pb--;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pa &amp;gt;&amp;#61; a)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; (*pa - &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;) &amp;#43; carry;\n        c[i&amp;#43;&amp;#43;] &amp;#61; x % &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n        carry &amp;#61; x / &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n        pa--;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pb &amp;gt;&amp;#61; b)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; (*pb - &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;) &amp;#43; carry;\n        c[i&amp;#43;&amp;#43;] &amp;#61; x % &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n        carry &amp;#61; x / &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n        pb--;\n    }\n    c[i] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;reverse&lt;/span&gt;(c);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, c);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于高精度加法的疑问 蓝桥杯", ["\n\n```c\n\n\n", "\n", "#include<string.h>\n#include<stdlib.h>\nint main()\n{\n    int a, b, d, e, f, i;\n    int a1 = 0;\n    int b1 = 0;\n    char a2", "[1000]", ", b2", "[1000]", ";\n    printf(", "\"请输入两个需要求和的数\\n\"", ");\n    scanf(", "\"%s\\n%s\"", ", &a1, &b2);//输入两个需要求和的数\n    int first", "[100000]", ";\n    int second", "[100000]", ";\n    int third", "[100000]", ";\n    /*输入模块*/\n    int j = 0;\n    a1 = strlen(a2);\n    b1 = strlen(b2);\n    for (i = 0;i < a1;i++)\n        a2", "[i]", " = a2", "[i]", " - '0';\n    for (i = 0;i < b1;i++)\n        b2", "[ i]", " = b2", "[i]", " - '0';\n    for (i = 1;j < a1;i = i * 10)\n    {\n        first", "[j]", " = a2", "[j]", " / i % 10;\n        j++;\n    }\n    j = 0;\n    for (i = 1;j < b1;i = i * 10)\n    {\n        second", "[j]", " = b2", "[j]", " / i % 10;\n        j++;\n    }\n    /*输出模块*/\n    for (i = a1;i > 0;i--)\n    {\n        printf(", "\"%d\"", ", first", "[i - 1]", ");\n    }\n    printf(", "\"\\n\"", ");\n    for (i = b1;i > 0;i--)\n    {\n        printf(", "\"%d\"", ", second", "[i - 1]", ");\n    }\n    /*加法模块*/\n    printf(", "\"\\n\"", ");\n    if (a1 > b1)\n        f = a1;\n    else\n        f = b1;\n    for (i = 0;i <= f;i++)\n    {\n        third", "[i]", " = first", "[i]", " + second", "[i]", " + third", "[i]", ";\n        if (third", "[i]", " >= 10)\n        {\n            third", "[i + 1]", " = third", "[i + 1]", " + 1;\n            third", "[i]", " = third", "[i]", " - 10;\n        }\n\n    }\n    if (third", "[f]", " > 0)\n    {\n        printf(", "\"%d\"", ", third", "[f]", ");\n    }\n    for (i = f;i > 0;i--)\n    {\n        printf(", "\"%d\"", ", third", "[i - 1]", ");\n    }\n\n    return 0;\n}\n/*\n问题描述\n　　输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。\n算法描述\n　　由于a和b都比较大，所以不能直接使用语言中的标准数据类型来存储。对于这种问题，一般使用数组来处理。\n　　定义一个数组A，A", "[0]", "用于存储a的个位，A", "[1]", "用于存储a的十位，依此类推。同样可以用一个数组B来存储b。\n　　计算c = a + b的时候，首先将A", "[0]", "与B", "[0]", "相加，如果有进位产生，则把进位（即和的十位数）存入r，把和的个位数存入C", "[0]", "，即C", "[0]", "等于(A", "[0]", "+B", "[0]", ")%10。然后计算A", "[1]", "与B", "[1]", "相加，这时还应将低位进上来的值r也加起来，即C", "[1]", "应该是A", "[1]", "、B", "[1]", "和r三个数的和．如果又有进位产生，则仍可将新的进位存入到r中，和的个位存到C", "[1]", "中。依此类推，即可求出C的所有位。\n　　最后将C输出即可。\n输入格式\n　　输入包括两行，第一行为一个非负整数a，第二行为一个非负整数b。两个整数都不超过100位，两数的最高位都不是0。\n输出格式\n　　输出一行，表示a + b的值。\n样例输入\n20100122201001221234567890\n2010012220100122\n样例输出\n20100122203011233454668012\n\n!", "[img]", "(https://img-mid.csdnimg.cn/release/static/image/mid/ask/860961547146190.png ", "\"#left\"", ")\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改完善如下&amp;#xff0c;具体改动处见注释&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;Linear Table On On Link List Structure\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;conio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;#define FAIL 1   //; 修改&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define OK 0     //; 修改&lt;/span&gt;\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;程序中反复出现的H&amp;#61;H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;是因为H的首地址不存数据 \n\ntypedef int ElemType; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;数据元素类型定义\ntypedef int DataType;\ntypedef struct Node &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;线性表链式存储结构的定义\n{\n    DataType data;\n    struct Node* &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n\n}LNode, * LinkList; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n\n      &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;Node LNode;  修改\n      &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;nt* px;     修改\n      &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;nt i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, x &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;      修改\n     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;LinkList H, T, OriginH; 修改\n     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;LinkList p;             修改\n     \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;注意&amp;#xff1a;下面的链表都采用带头节点的结构 \nLinkList CreateLinkList(int n); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;带n个节点的链表,返回链表的头指针\nvoid PrintList(LinkList L);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;以(a1,a2,...,an)格式输出链表  OK\nvoid EmptyList(LinkList L);  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;把链表H清空&amp;#xff08;保留头结点&amp;#xff09;\nint ListLength(LinkList L);  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;返回链表H的长度    OK\nNode* GetData(Node* L, int i, DataType* px);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找第i(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;≤i≤n)个元素&amp;#xff0c;查找成功返回OK并把元素放入*px,查找失败返回FAIL  \nNode* Locate(LinkList H, DataType x); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;查找元素x的位置&amp;#xff0c;找到返回指向该结点指针,否则返回NULL\nint InsList(LinkList H, int i, DataType x);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在链表H的第i个位置上插入值为x的元素&amp;#xff0c;成功返回TRUE,否则FALSE\nint DelList(LinkList L, int i, ElemType* px); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除表中第i(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;≤i≤n)个元素&amp;#xff0c;删除元素值放入*px;删除成功返回OK,否则FAIL\n\nint main()\n{\n    LinkList H &amp;#61; NULL;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义一个链表指针   修改\n    int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, x &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;生成菜单 \n    char sel &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (sel !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;------线性表(链式存储结构)演示系统-------\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;   版本:1.0   作者:XXXXXX 日期:yyyy-mm-dd\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;------------------------------------------\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       1.创建线性表\\n&amp;#34;&lt;/span&gt;);   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;已经实现 \n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       2.查找元素位置\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       3.按位置查找元素\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       4.插入一个元素\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       5.删除一个元素\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       6.打印线性表\\n&amp;#34;&lt;/span&gt;);  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;已经实现 OK\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       7.打印线表长度\\n&amp;#34;&lt;/span&gt;);  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OK\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       8.清空线性表\\n&amp;#34;&lt;/span&gt;);\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       9.清空屏幕\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;已经实现 \n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;       0.退出系统\\n&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;已经实现 \n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入选项[0-7]:&amp;#34;&lt;/span&gt;);\n        sel &amp;#61; getch();\n        switch (sel)\n        {\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;:\n            int n;\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;创建线性表操作.\\n&amp;#34;&lt;/span&gt;);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入你要创建线性表的长度&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n            H &amp;#61; CreateLinkList(n);\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;查找元素操作.\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;... \n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;按位置查找元素操作.\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;... \n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;插入一个元素操作.\\n&amp;#34;&lt;/span&gt;);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入所插入的位置与数据的值&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;, &amp;amp;i, &amp;amp;x);\n            InsList(H, i, x);\n\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;删除一个元素操作.\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;... \n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;6&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;显示线性表操作.\\n&amp;#34;&lt;/span&gt;);\n            PrintList(H);\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;7&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;显示线性表长度.\\n&amp;#34;&lt;/span&gt;);\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;长度为&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;, ListLength(H));\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;8&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;清空线性表操作.\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;... \n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;按任意键继续 \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;9&amp;#39;&lt;/span&gt;:\n            system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        case &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n谢谢使用&amp;#xff0c;再见&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        default:\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;您输入的选项不合法&amp;#xff0c;请重新选择&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建带n个节点的链表,返回链表的头指针\nLinkList CreateLinkList(int n)\n{\n    LinkList H &amp;#61; (LinkList)malloc(sizeof(LNode));       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;申请一个LNode节点&amp;#xff0c;把H指向这个新申请的节点 void*\n    H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;(*H).&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;OriginH &amp;#61; H;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;统计长度或显示链表会导致地址后移&amp;#xff0c;OriginH存放原始H地址  修改\n    LinkList T &amp;#61; H;    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n    int i;\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入%d个整数&amp;#xff1a;&amp;#34;&lt;/span&gt;, n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        int x;\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;x);\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;申请节点p&amp;#xff0c;放入x \n        LNode *p &amp;#61; (LinkList)malloc(sizeof(LNode));  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        p-&amp;gt;data &amp;#61; x;\n        p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;把p点接入T后面\n        T-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p;\n        T &amp;#61; p;\n    }\n    return H;\n}\n\nint ListLength(LinkList L)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;统计长度 \n{\n    int cnt &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!L || !L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;)           &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改 \n        return cnt;\n    LinkList H &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;  修改\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (H !&amp;#61; NULL)\n    {\n        H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        cnt&amp;#43;&amp;#43;;\n    }\n                        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H &amp;#61; OriginH;   修改\n    return cnt;\n}\n\nint InsList(LinkList H, int i, DataType x)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;插入 \n{\n    int length &amp;#61; ListLength(H);\n    int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;         修改\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;gt; length || i &amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;超出范围&amp;#xff0c;无法插入&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        return FAIL;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        LinkList L &amp;#61; H, tmp &amp;#61; NULL;  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (L &amp;amp;&amp;amp; j &amp;lt; i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n            L &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n            j&amp;#43;&amp;#43;;\n        }\n        tmp &amp;#61; (LinkList)malloc(sizeof(LNode));\n        tmp-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n        tmp-&amp;gt;data &amp;#61; x;\n        tmp-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; tmp;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (; j !&amp;#61; i; j&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;后传直至找到第i个位置 \n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;x &amp;#61; x &amp;#43; H-&amp;gt;data;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;交换 x与 x&amp;#61;x&amp;#43;Tmp1-&amp;gt;data的值 可以少用一个变量 \n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H-&amp;gt;data &amp;#61; x - H-&amp;gt;data;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;x &amp;#61; x - H-&amp;gt;data;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int k &amp;#61; i; k &amp;lt; length; k&amp;#43;&amp;#43;)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;交换x与H.data中的数据方便后移 \n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;{\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;插入数据后将每一位数字后移 \n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    x &amp;#61; x &amp;#43; H-&amp;gt;data;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    H-&amp;gt;data &amp;#61; x - H-&amp;gt;data;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    x &amp;#61; x - H-&amp;gt;data;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;插入成功&amp;#xff01;\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H &amp;#61; OriginH;\n        return OK;\n    }\n\n}\n\nvoid PrintList(LinkList L)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;打印链表 \n{\n    int flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;默认为第一位 \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!L || !L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;)           &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;修改 \n        return;\n    LinkList H &amp;#61; L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;         &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;; 修改\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#xff08;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (H !&amp;#61; NULL)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flag &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, H-&amp;gt;data);\n            flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; \n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#xff0c;%d&amp;#34;&lt;/span&gt;, H-&amp;gt;data);\n        H &amp;#61; H-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#xff09;&amp;#34;&lt;/span&gt;);\n                    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H &amp;#61; OriginH;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;返回初始位置  修改\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["C语言链表 插入一个值 导致链表最后一位消失怎么办？", ["C语言链表 插入一个值 导致链表最后一位消失怎么办？", "比如链表中本身有（1,2,3） 插入99在第二位后 链表就变成了（1,99,3）", "\n", "\n", "//Linear Table On On Link List Structure", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<conio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "#", "define", " FAIL 1;", "\n", "#", "define", " OK 0;", "\n\n", "//程序中反复出现的H=H->next是因为H的首地址不存数据 ", "\n\n", "typedef", " ", "int", " ElemType; ", "//数据元素类型定义", "\n", "typedef", " ", "int", " DataType; \n", "typedef", " ", "struct", " ", "Node", " ", "//线性表链式存储结构的定义", "\n{\n    DataType data;\n    ", "struct", " ", "Node", "* next;\n    \n}Node,*LinkList;\nNode LNode;\n", "int", " *px;\n", "int", " i=", "0", ",x=", "0", ";\nLinkList H,T,OriginH;\nLinkList p;\n", "//注意：下面的链表都采用带头节点的结构 ", "\n", "LinkList ", "CreateLinkList", "(", "int", " n)", "; ", "//带n个节点的链表,返回链表的头指针", "\n", "void", " ", "PrintList", "(LinkList L)", ";", "//以(a1,a2,...,an)格式输出链表  OK", "\n", "void", " ", "EmptyList", "(LinkList L)", ";  ", "//把链表H清空（保留头结点）", "\n", "int", " ", "ListLength", "(LinkList L)", ";  ", "//返回链表H的长度    OK", "\n", "Node* ", "GetData", "(Node *L, ", "int", " i, DataType*px)", ";", "//查找第i(1≤i≤n)个元素，查找成功返回OK并把元素放入*px,查找失败返回FAIL  ", "\n", "Node* ", "Locate", "(LinkList H, DataType x)", "; ", "//查找元素x的位置，找到返回指向该结点指针,否则返回NULL", "\n", "int", " ", "InsList", "(LinkList H, ", "int", " i, DataType x)", ";", "//在链表H的第i个位置上插入值为x的元素，成功返回TRUE,否则FALSE", "\n", "int", " ", "DelList", "(LinkList L,", "int", " i, ElemType*px)", "; ", "//删除表中第i(1≤i≤n)个元素，删除元素值放入*px;删除成功返回OK,否则FAIL", "\n\n", "int", " ", "main", "()", "\n", "{\n    LinkList H;  ", "//定义一个链表指针 ", "\n    \n    ", "//生成菜单 ", "\n    ", "char", " sel=", "' '", ";\n    ", "while", "(sel!=", "'0'", ")\n    {\n        \n        ", "printf", "(", "\"------线性表(链式存储结构)演示系统-------\\n\"", ");\n        ", "printf", "(", "\"   版本:1.0   作者:XXXXXX 日期:yyyy-mm-dd\\n\"", "); \n        ", "printf", "(", "\"------------------------------------------\\n\"", ");\n        ", "printf", "(", "\"       1.创建线性表\\n\"", ");   ", "//已经实现 ", "\n        ", "printf", "(", "\"       2.查找元素位置\\n\"", ");\n        ", "printf", "(", "\"       3.按位置查找元素\\n\"", ");\n        ", "printf", "(", "\"       4.插入一个元素\\n\"", ");\n        ", "printf", "(", "\"       5.删除一个元素\\n\"", ");\n        ", "printf", "(", "\"       6.打印线性表\\n\"", ");  ", "//已经实现 OK", "\n        ", "printf", "(", "\"       7.打印线表长度\\n\"", ");  ", "//OK", "\n        ", "printf", "(", "\"       8.清空线性表\\n\"", ");\n        ", "printf", "(", "\"       9.清空屏幕\\n\"", "); ", "//已经实现 ", "\n        ", "printf", "(", "\"       0.退出系统\\n\"", "); ", "//已经实现 ", "\n        ", "printf", "(", "\"请输入选项[0-7]:\"", "); \n        sel=", "getch", "();\n        ", "switch", "(sel)\n        {\n            ", "case", " ", "'1'", ":\n                ", "int", " n;\n                ", "printf", "(", "\"创建线性表操作.\\n\"", ");\n                ", "printf", "(", "\"请输入你要创建线性表的长度：\"", ");\n                ", "scanf", "(", "\"%d\"", ",&n);\n                H = ", "CreateLinkList", "(n);\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'2'", ":\n                ", "printf", "(", "\"查找元素操作.\\n\"", ");   \n                ", "//... ", "\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'3'", ":\n                ", "printf", "(", "\"按位置查找元素操作.\\n\"", ");\n                ", "//... ", "\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'4'", ":\n                ", "printf", "(", "\"插入一个元素操作.\\n\"", ");\n                ", "printf", "(", "\"请输入所插入的位置与数据的值：\"", ");\n                ", "scanf", "(", "\"%d %d\"", ",&i,&x);\n                ", "InsList", "(H,i,x);\n                \n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'5'", ":\n                ", "printf", "(", "\"删除一个元素操作.\\n\"", ");\n                ", "//... ", "\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'6'", ":\n                ", "printf", "(", "\"显示线性表操作.\\n\"", ");\n                ", "PrintList", "(H);\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'7'", ":\n                ", "printf", "(", "\"显示线性表长度.\\n\"", ");\n                ", "printf", "(", "\"长度为：%d\\n\"", ",", "ListLength", "(H));\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'8'", ":\n                ", "printf", "(", "\"清空线性表操作.\\n\"", ");\n                ", "//... ", "\n                ", "system", "(", "\"pause\"", "); ", "//按任意键继续 ", "\n                ", "break", ";\n            ", "case", " ", "'9'", ":\n                ", "system", "(", "\"cls\"", ");\n                ", "break", ";\n            ", "case", " ", "'0'", ":\n                ", "printf", "(", "\"\\n谢谢使用，再见！\\n\"", ");\n                ", "break", ";\n            ", "default", ":\n                ", "printf", "(", "\"您输入的选项不合法，请重新选择！\\n\"", ");\n        }\n    }\n\n    ", "return", " ", "0", ";\n} \n\n\n", "//创建带n个节点的链表,返回链表的头指针", "\n", "LinkList ", "CreateLinkList", "(", "int", " n)", "\n", "{\n    \n    H = (LinkList) ", "malloc", "(", "sizeof", "(LNode));  ", "//申请一个LNode节点，把H指向这个新申请的节点 void*", "\n    H->next = ", "NULL", "; ", "//(*H).next = NULL;", "\n    OriginH=H;", "//统计长度或显示链表会导致地址后移，OriginH存放原始H地址 ", "\n    T=H;\n    ", "int", " i;\n    ", "printf", "(", "\"请输入%d个整数：\"", ",n);\n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "int", " x;\n\n        ", "scanf", "(", "\"%d\"", ",&x);\n        ", "//申请节点p，放入x ", "\n        p=(LinkList)", "malloc", "(", "sizeof", "(LNode));\n        p->data = x;\n        p->next = ", "NULL", ";\n        \n        ", "//把p点接入T后面", "\n        T->next = p;\n        T=p;\n    } \n    \n    ", "return", " H;\n}\n\n\n\n", "int", " ", "ListLength", "(LinkList L)", "//统计长度 ", "\n", "{\nH=H->next;\n", "int", " cnt=", "0", ";\n", "while", "(H!=", "NULL", ")\n    {H=H->next;\n    cnt++;\n    }\nH=OriginH;\n", "return", " cnt;\n}\n\n\n\n\n", "int", " ", "InsList", "(LinkList H, ", "int", " i, DataType x)", "//插入 ", "\n", "{\n\n\n", "int", " length=", "ListLength", "(H);\n", "int", " j=", "1", ";\n", "if", "(i>length||i<", "1", ")\n    {", "printf", "(", "\"超出范围，无法插入！\\n\"", ");\n    ", "return", " FAIL;\n    }\n        ", "else", "\n        {H=H->next;\n        ", "for", "(;j!=i;j++)\n        {H=H->next;", "//后传直至找到第i个位置 ", "\n        }\n                x=x+H->data;", "//交换 x与 x=x+Tmp1->data的值 可以少用一个变量 ", "\n                H->data=x-H->data;\n                x=x-H->data;\n                    ", "for", "(", "int", " k=i;k<length;k++)", "//交换x与H.data中的数据方便后移 ", "\n                    {H=H->next;", "//插入数据后将每一位数字后移 ", "\n                        x=x+H->data;\n                        H->data=x-H->data;\n                        x=x-H->data;                    \n                    \n                    }\n                    ", "printf", "(", "\"插入成功！\\n\"", ");\n                    H=OriginH;\n                    ", "return", " OK;\n        }\n    \n}\n\n\n", "void", " ", "PrintList", "(LinkList L)", "//打印链表 ", "\n", "{", "int", " flag=", "0", ";", "//默认为第一位 ", "\nH=H->next;\n", "printf", "(", "\"（\"", ");\n    ", "while", "(H!=", "NULL", ")\n    {", "if", "(flag==", "0", ")\n        {", "printf", "(", "\"%d\"", ",H->data);\n        flag=", "1", ";\n        }\n    ", "else", " ", "printf", "(", "\"，%d\"", ",H->data);\n    H=H->next;\n    }\n        ", "printf", "(", "\"）\"", ");\nH=OriginH;", "//返回初始位置 ", "\n}\n", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "在想要抛出该异常的地方，加上一行 throw new InputMismatchException(); 即可。", "Konwledge_Point": "定义新的类型", "Question": ["我这个只能捕获InputMismatchException异常，要想抛出该异常怎么写。", ["package lwz;", "\n\n", "import java.util.*;", "\n\n", "public class Employment {", "\n    public static void main(String[] args) throws java.util.InputMismatchException{", "\n        // 创建EmpManage对象", "\n        EmpManage em = new EmpManage();", "\n        Scanner sr = new Scanner(System.in);", "\n        // 作出一个菜单", "\n        while (true) {", "\n            System.out.println(\"公司职员薪水管理系统\");", "\n            System.out.println(\"1、录入新员工\");", "\n            System.out.println(\"2、根据工号查询信息\");", "\n            System.out.println(\"3、查询所有员工信息\");", "\n            System.out.println(\"4、通过工号修改员工薪水\");", "\n            System.out.println(\"5、删除员工信息\");", "\n            System.out.println(\"6、按薪水高低排序\");", "\n            System.out.println(\"7、计算平均工资及最高(低)工资\");", "\n            System.out.println(\"0、退出系统\");", "\n            System.out.print(\"请输入对应的数字进行操作：\");", "\n            int sel = sr.nextInt();", "\n            switch (sel) {", "\n            case 1:", "\n                System.out.println(\"请录入新员工的信息\");", "\n                try {", "\n                    System.out.print(\"工号(输入-1返回到上一级菜单中):\");", "\n                    String empNo = sr.next();", "\n                    if (empNo.equals(\"-1\")) {", "\n                        break;", "\n                    }", "\n                    System.out.print(\"姓名:\");", "\n                    String name = sr.next();", "\n                    System.out.print(\"工资:\");", "\n                    float sal = sr.nextFloat();", "\n                    // 构建emp对象", "\n                    Emp emp = new Emp(empNo, name, sal);", "\n                    // 将empNo,name,sal的值传给构造函数Emp", "\n                    em.addEmp(emp);", "\n                    System.out.println(\"创建新员工\" + name + \"成功!\");", "\n                } catch (InputMismatchException e) {", "\n                    System.out.println(\"请输入正确格式的工号、姓名和工资\" + \"\\n工号必须为字符串形式\"", "\n                            + \"\\n姓名必须为字符串形式\" + \"\\n工资必须为数字类型\");", "\n                }", "\n\n", "            break;\n        case 2:\n            System.out.println(\"请录入员工工号：\");\n            String empNo1 = sr.next();\n            em.showInfo(empNo1);\n            break;\n        case 3:\n            System.out.println(\"公司所有员工信息如下：\");\n            em.AllInfo();\n            break;\n        case 4:\n            System.out.println(\"请输入工号：\");\n            String empNo2 = sr.next();\n            System.out.println(\"将工资修改为：\");\n            float newSal = sr.nextFloat();\n            em.updateSal(empNo2, newSal);\n            break;\n        case 5:\n            System.out.println(\"请输入要删除人员的工号：\");\n            String empNo3 = sr.next();\n            em.delEmp(empNo3);\n            break;\n        case 6:\n            System.out.println(\"已按薪资高低进行排序如下：\");\n            em.SortSal();\n            break;\n        case 7:\n            System.out.println(\"显示平均工资及最高、最低工资人员信息如下：\");\n            em.Average();\n            break;\n        case 0:\n            System.out.println(\"已正常退出!\");\n            System.exit(0);\n            break;\n        default:\n            System.out.println(\"输入错误，请重新输入!\");\n\n        }\n\n    }\n}\n", "\n\n", "}", "\n\n", "// 创建员工管理类", "\nclass EmpManage {", "\n    private ArrayList al = new ArrayList();", "\n\n", "// 加入员工\npublic void addEmp(Emp emp) {// 传入员工信息\n    al.add(emp);\n}\n\n// 根据员工工号显示员工的相关信息\npublic void showInfo(String empNo) {// 将工号传入showInfo方法中\n    // 遍历整个ArrayList\n    for (int i = 0; i < al.size(); i++) {\n        // 取出Emp对象\n        Emp emp = al.get(i);\n        // 比较编号\n        if (emp.getEmpNo().equals(empNo)) {// 由于empNo类型为String，所以要使用equals进行内容比较，不可以使用==地址比较\n            System.out.println(\"找到该员工，他的信息是：\");\n            System.out.println(\"工号:\" + empNo + \"\\t姓号:\" + emp.getName()\n                    + \"\\t薪水:\" + emp.getSal());\n        }\n    }\n    System.out.println(\"工号不存在或者无此人，无法进行相关操作！\");\n}\n\n// 显示所有员工信息\npublic void AllInfo() {\n    for (int i = 0; i < al.size() - 1; i++) {// ArrayList集合类的al大小，控制循环\n        for (int j = 1; j < al.size() - i; j++) {// 将al中的值进行循环比较\n            Emp emp1 = (Emp) al.get(j - 1);\n            Emp emp2 = (Emp) al.get(j);\n            // 使用compareTo方法进行Sting类型值比较\n            if (emp1.getEmpNo().compareTo(emp2.getEmpNo()) > 0) {\n                al.set(j, emp1);// 交换值并重写入al中\n                al.set(j - 1, emp2);// 交换值并重写入al中\n            }\n        }\n    }\n    for (Emp emp : al) {\n        System.out.println(\"工号：\" + emp.getEmpNo() + \"\\t姓名：\" + emp.getName()\n                + \"\\t工资：\" + emp.getSal());\n    }\n}\n\n// 修改员工的薪水\npublic void updateSal(String empNo, float newSal) {\n    // 遍历整个ArrayList\n    for (int i = 0; i < al.size(); i++) {\n        // 取出Emp对象\n        Emp emp = (Emp) al.get(i);\n        if (emp.getEmpNo().equals(empNo)) {\n            // 修改新水\n            emp.setSal(newSal);// setSal会将修改的薪水传和ArrayList中\n            System.out.println(\"已将\" + emp.getName() + \"调整为:\" + newSal);\n        }\n    }\n    System.out.println(\"工号不存在或无此人，无法进行相应操作!\");\n}\n\n// 员工离职删除指定员工\npublic void delEmp(String empNo) {\n    // 遍历整个ArrayList\n    for (int i = 0; i < al.size(); i++) {\n        // 取出Emp对象\n        Emp emp = (Emp) al.get(i);\n        if (emp.getEmpNo().equals(empNo)) {\n            // 按工号删除\n            al.remove(i);// 也可以使用al.remove(emp);\n            System.out.println(\"已将\" + emp.getName() + \"信息清除!\");\n        }\n    }\n}\n\n// 按薪水高低排序\npublic void SortSal() {\n    for (int i = 0; i < al.size() - 1; i++) {// ArrayList集合类的al大小，控制循环\n        for (int j = 1; j < al.size() - i; j++) {// 将al中的值进行循环比较\n            Emp emp1 = (Emp) al.get(j - 1);\n            Emp emp2 = (Emp) al.get(j);\n            if (emp1.getSal() < emp2.getSal()) {// 比较sal的值大小\n                al.set(j, emp1);// 交换值并重写入al中\n                al.set(j - 1, emp2);// 交换值并重写入al中\n            }\n        }\n    }\n    for (Emp emp : al) {\n        System.out.println(\"工号：\" + emp.getEmpNo() + \"\\t姓名：\" + emp.getName()\n                + \"\\t工资：\" + emp.getSal());\n    }\n}\n\n// 计算平均工资并找出最高工资和最低工资的员工\npublic void Average() {\n    float sum = 0f, ave = 0f;\n    // 遍历整个ArrayList\n    for (int k = 0; k < al.size(); k++) {\n        // 取出Emp对象\n        Emp emp = (Emp) al.get(k);\n        sum = emp.getSal() + sum;\n    }\n    ave = sum / al.size();\n    System.out.println(\"共有员工\" + al.size() + \"人\\t总工资为：\" + sum + \"\\t平均工资为：\"\n            + ave);\n\n    // 找出最高工资与最低式资\n    for (int i = 0; i < al.size() - 1; i++) {// ArrayList集合类的al大小，控制循环\n        for (int j = 1; j < al.size() - i; j++) {// 将al中的值进行循环比较\n            Emp emp1 = (Emp) al.get(j - 1);\n            Emp emp2 = (Emp) al.get(j);\n            if (emp1.getSal() < emp2.getSal()) {// 比较sal的值大小\n                al.set(j, emp1);// 交换值并重写入al中\n                al.set(j - 1, emp2);// 交换值并重写入al中\n            }\n        }\n    }\n    for (int i = 0; i < al.size(); i++) {\n        if (i == 0) {\n            Emp emp = (Emp) al.get(i);\n            System.out.println(\"工资最高的人员是：\" + emp.getName() + \"\\t薪水是：\"\n                    + emp.getSal());\n        } else if (i == al.size() - 1) {\n            Emp emp = (Emp) al.get(i);\n            System.out.println(\"工资最低的人员是：\" + emp.getName() + \"\\t薪水是：\"\n                    + emp.getSal());\n        }\n    }\n}\n", "\n\n", "}", "\n\n", "// 创建员工类", "\nclass Emp {", "\n    // 定义成员变量工号、姓名、薪水", "\n    public String empNo;", "\n    public String name;", "\n    public float sal;", "\n\n", "// 创建构造函数，初始化成员变量\npublic Emp(String empNo, String name, float sal) {\n    this.empNo = empNo;\n    this.name = name;\n    this.sal = sal;\n}\n\n// 使用set、get方法进行数据传递\npublic String getEmpNo() {\n    return empNo;\n}\n\npublic void setEmpNo(String empNo) {\n    this.empNo = empNo;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic float getSal() {\n    return sal;\n}\n\npublic void setSal(float sal) {\n    this.sal = sal;\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "如果你未定义析构函数，编译器会自动生成默认析构函数。\r\n但题目中，你试图自己定义Card类的析构函数，只是定义语法不对，所以导致错误。\r\n\r\n需要将\r\n\r\n\r\n\r\n```\r\n ~Card(void);\r\n```\r\n修改为\r\n\r\n\r\n\r\n```\r\n ~Card(void){};  \r\n```\r\n\r\n这是个比较隐蔽的错误。", "Konwledge_Point": "定义新的类型", "Question": ["关于C++编译时的报错，求帮忙指出？", ["编译器提示错误为", "\n1>Hand.obj : error LNK2019: 无法解析的外部符号 \"public: __thiscall Card::~Card(void)\" (??1Card@@QAE@XZ)，该符号在函数 \"public: void * __thiscall Card::`scalar deleting destructor'(unsigned int)\" (??_GCard@@QAEPAXI@Z) 中被引用", "\n1>C:\\Users\\Administrator\\Desktop\\通过游戏编程实战教新手学C++编程\\21点\\Debug\\21点.exe : fatal error LNK1120: 1 个无法解析的外部命令", "\n\n", "HAND.H\n#pragma once\n#include \"Card.h\"\n#include <vector>\n\n// 定义一个手牌类\nclass Hand\n{\npublic:\n    Hand(void);\n    virtual ~Hand(void);\n    void Add(Card *pCard); // 添加一张pCard指向的卡\n    void Clear();    // 清空手中所有卡\n    int GetTotalValue()  const;   // 获取手牌中所有牌的点数和\n\nprotected:\n    vector<Card*> m_Cards;\n};\n\n", "\n\n", "HAND.CPP\n\n#include \"Hand.h\"\n\nHand::Hand(void)\n{\n    m_Cards.reserve(7);   //假定每个玩家最多摸7张牌，预留7张牌大小的容器\n}\nHand::~Hand(void)\n{\n    Clear();\n}\nvoid Hand::Add(Card *pCard)\n{\n    m_Cards.push_back(pCard);\n}\nint Hand::GetTotalValue() const\n{\n    if (m_Cards.empty())   // 假如手牌为空\n    {\n        return 0;\n    }\n    if (m_Cards[0]->GetValue()==0)   //假如第一张手牌获取到的点数为0，即第一张牌反面朝上\n    {\n        return 0;\n    }\n    int TotalValue=0;\n    vector<Card*>::const_iterator iter;\n    for (iter=m_Cards.begin();iter!=m_Cards.end();iter++)\n    {\n        TotalValue+=(*iter)->GetValue();  // 将每一张手牌的点数相加\n    }\n    bool contanACE=false;\n    for (iter=m_Cards.begin();iter!=m_Cards.end();iter++)\n    {\n        if ((*iter)->GetValue()==Card::ACE)  //遍历查找手牌中是否有A\n        {\n            contanACE=true;\n            break;\n        }\n    }\n    if (contanACE==true&&TotalValue<11)  // 此情况下视A为11点\n    {\n        TotalValue+=10;\n    }\n    return TotalValue;\n}\nvoid Hand::Clear()\n{\n    vector<Card*>::iterator iter=m_Cards.begin();\n    for (iter=m_Cards.begin();iter!=m_Cards.end();iter++)\n    {\n        delete *iter;   // 释放堆中的每一个内存\n        *iter=NULL;\n    }\n    m_Cards.clear();\n}\n\n", "\n\n", "CARD.H\n\n #pragma once\n#include <iostream>\nusing namespace std;\n\n// 扑克牌类型Card\nclass Card\n{\n\npublic:\n    enum point{ACE=1,TWO,THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN,JACK,QUEEN,KING};\n    enum kind{HeiTao,HongXin,MeiHua,FangKuai};\n    Card(point m_point=ACE,kind m_kind=HeiTao,bool m_IsFaceUp=true);\n    int GetValue() const;  // 返回牌的点数\n    void Filp();     // 将牌翻面\n    friend ostream& operator<<(ostream &os,const Card &rCard);  //重载运算符，输出Card对象\n    ~Card(void);\n\nprotected:\n    point m_point;   // 牌的点数\n    kind m_kind;     // 牌的花色\n    bool m_IsFaceUp; // 牌是否正面朝上\n};\n\n", "\n\n", "CARD.CPP", "\n\n", "#include \"Card.h\"", "\n#include ", "\n\n", "Card::Card(point p,kind k,bool ifu):m_point(p),m_kind(k),m_IsFaceUp(ifu)", "\n{", "\n}", "\nint Card::GetValue() const", "\n{", "\n    int Value=0;", "\n    if (m_IsFaceUp)  // 假如牌正面朝上则可以读出点数", "\n    {", "\n        Value=m_point;", "\n        if (Value>10)   // 出现“J,Q,K”情况，都视为10点", "\n        {", "\n            Value=10;", "\n        }", "\n    }", "\n    return Value;", "\n}", "\nvoid Card::Filp()", "\n{", "\n    m_IsFaceUp=!(m_IsFaceUp); // 正面朝上翻转后正面朝下，翻面朝上翻转后正面朝上", "\n}", "\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;上面那个函数少了后边的大括号&lt;br /&gt;60行的大括号放错地方了&amp;#xff0c;放到29行&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["error C2760: 语法错误: 意外标记 \"template\"，应为 \"语句\",符合", ["问题遇到的现象和发生背景", "\n", "三个文件", "Cirqueue_main.cpp", "Cirqueue.cpp", "Cirqueue.h", "\n", "Cirqueue.cpp(出问题的地方):", "\n", "# ", "include", " ", "<iostream>", "\n", "# ", "include", " ", "\"CirQueue.h\"", "\n", "using", " ", "namespace", " std;\n\n", "// 入队操作", "\n", "template", " <", "typename", " DataType> ", "void", " CirQueue<DataType>::", "EnQueue", "(DataType x)\n{\n    ", "if", " (Len == MaxSize)\n    {\n        cout << ", "\"队列已满，入队失败\"", " << endl;\n        ", "return", ";\n    }\n    Rear = (Rear + ", "1", ") % MaxSize;        ", "// 队尾指针在循环意义上+1", "\n    sequ[Rear] = x;\n    Len++;\n}\n", "// 出队操作 ", "\n", "template", " <", "typename", " DataType> DataType CirQueue<DataType>::", "DeQueue", "()\n{\n    ", "if", " (Len == ", "0", ") {\n\n        ", "return", " ", "' '", ";\n\n\n        ", "int", " i = ((Rear + MaxSize) - Len + ", "1", ") % MaxSize;    ", "// 获取队列第一个元素的下标 ", "\n        Len--;\n        ", "return", " sequ[i];\n    }\n    ", "// 输出当前队列有多少元素 ", "\n    ", "template", " <", "typename", " DataType> ", "int", " CirQueue<DataType>::", "GetLen", "()\n    {\n        ", "return", " Len;\n    }\n\n    ", "// 计算当前队列中有多少个char类型字符 ", "\n    ", "template", " <", "typename", " DataType> ", "int", " CirQueue<DataType>::", "Statcahr", "(", "char", " a)\n    {\n        ", "int", " count = ", "0", ", j = ((Rear + MaxSize) - Len + ", "1", ") % MaxSize; ", "// 统计char a的个数 , 获取第一个元素下标 ", "\n        ", "for", " (", "int", " i = ", "0", "; i < Len; i++)\n        {\n            ", "if", " (sequ[j] == a)\n            {\n                j++;\n            }\n        }\n\n        ", "return", " count;\n    }\n\n    ", "// 将队列中所有元素出队 ", "\n\n    ", "template", " <", "typename", " DataType> ", "void", " CirQueue<DataType>::", "DeAll", "()\n    {\n        ", "int", " j = Len;\n        ", "for", " (", "int", " i = ", "0", "; i < j; i++)\n        {\n            cout << ", "DeQueue", "();\n        }\n    }\n}\n\n", "\n", "Cirqueue_main.cpp:", "\n", "#", "include", " ", "\"CirQueue.cpp\"", "\n#", "include", " <cstdlib>\n#", "include", " <iostream>\n#", "include", " <stdio.h>\nusing namespace std;\n\nCirQueue<", "char", "> awaitcar;                ", "// awaitcar等待上船的客车队列 ", "\nCirQueue<", "char", "> awaittruck;            ", "// awaittruck等待上船的货车队列 ", "\n\n", "// 函数功能：渡船 ", "\nvoid ship", "()", "\n{\n    CirQueue<", "char", "> ship10;    ", "// 定义船", "\n    ", "// 设置 3 个变量标识已上渡船的客车数量 busNum、货车数量 truckNum 和总数量 totalNum", "\n    ", "int", " busNum, truckNum, totalNum, j = ", "0", ";        ", "// j代表第几辆船 ", "\n\n    ", "while", " (awaitcar.", "GetLen()", " != ", "0", " || ", "awaittruck.", "GetLen()", " != ", "0", ")    ", "// 如果岸上还有车那么就循环 ", "\n    {\n        busNum = ", "0", ", truckNum = ", "0", ", totalNum = ", "0", ";\n        ", "while", " (totalNum < ", "10", ")                            ", "// 如果船没有满，那么就可以上船 ", "\n        {\n            ", "if", " (busNum < ", "4", " && ", "awaitcar.", "GetLen()", " != ", "0", ")   ", "// 船上的客车没满4辆并且岸上还有客车 ", "\n            {\n                ship10.", "EnQueue(", "awaitcar", ".DeQueue()", ");        ", "// 那么就上一辆客车 ", "\n                busNum++;\n                totalNum++;\n            }\n            ", "else", " ", "if", " (busNum < ", "4", " && ", "awaitcar.", "GetLen()", " == ", "0", ") ", "// 船上的客车没满4辆并且岸上没有客车", "\n            {\n                ship10.", "EnQueue(", "awaittruck", ".DeQueue()", ");        ", "// 那么就上一辆货车", "\n                truckNum++;\n                totalNum++;\n                busNum = ", "0", ";\n            }\n            ", "else", " ", "if", " (busNum >= ", "4", " && ", "awaittruck.", "GetLen()", " != ", "0", ")", "// 如果穿上已经上了四辆客车并且岸上还有货车", "\n            {\n                ship10.", "EnQueue(", "awaittruck", ".DeQueue()", ");        ", "// 那么就上一辆货车", "\n                truckNum++;\n                totalNum++;\n                busNum = ", "0", ";\n            }\n            ", "else", " ", "if", " (busNum >= ", "4", " && ", "awaittruck.", "GetLen()", " == ", "0", ")", "// 如果穿上已经上了四辆客车并且岸上没有货车", "\n            {\n                ship10.", "EnQueue(", "awaitcar", ".DeQueue()", ");                    ", "// 那么就上一辆客车 ", "\n                busNum++;\n                totalNum++;\n            }\n        }\n        j++;\n        cout << ", "\"这是第\"", " << j << ", "\"辆船,船上的装载情况为：\"", ";\n        ship10.", "DeAll()", ";\n        ship10.~", "CirQueue()", ";\n        totalNum = ", "0", ";\n        cout << endl;\n    }\n}\n\n", "int", " main(void)\n{\n    ", "int", " alltruck, allcar;             ", "// alltruck等待上船的货车数量, allcar等待上船的客车数量 ", "\n\n    ", "while", " (", "true", ")                    ", "// 为了测试数据方便，这里设置为永真 ", "\n    {\n        cout << ", "\"请输入当前正在等待上船的客车数量：\"", ";\n        cin >> allcar;\n        cout << ", "\"请输入当前正在等待上船的货车数量：\"", ";\n        cin >> alltruck;\n\n\n        ", "for", " (", "int", " i = ", "0", "; i < allcar; i++)                ", "// * 代表客车 ", "\n        {\n            awaitcar.", "EnQueue('", "*", "')", ";\n        }\n        ", "for", " (", "int", " i = ", "0", "; i < alltruck; i++)                ", "// # 代表货车 ", "\n        {\n            awaittruck.", "EnQueue('#')", ";\n        }\n\n        ship", "()", ";\n        cout << endl;\n        awaitcar.~", "CirQueue()", ";\n        awaittruck.~", "CirQueue()", ";\n    }\n\n    system(", "\"pause\"", ");\n    return ", "0", ";\n}\n\n\n", "\n", "Cirqueue.h:", "\n", "#", "pragma", " once", "\n", "#", "ifndef", " SeqList_H", "\n", "#", "define", " SeqList_H", "\n\n", "const", " ", "int", " MaxSize = ", "300", ";\n\n", "template", " <", "typename", " DataType> ", "class", " ", "CirQueue", "\n{\n", "public", ":\n    ", "CirQueue", "()                    ", "// 构造函数，初始化队列", "\n    {\n        Len = ", "0", ";\n        Rear = MaxSize - ", "1", ";\n    }\n\n    ~", "CirQueue", "()                    ", "// 析构函数", "\n    {\n        Len = ", "0", ";\n        Rear = MaxSize - ", "1", ";\n    }\n\n    ", "void", " ", "EnQueue", "(DataType x)", ";    ", "// 入队操作    ", "\n    ", "DataType ", "DeQueue", "()", ";            ", "// 出队操作", "\n    ", "int", " ", "GetLen", "()", ";                ", "// 返回队列中元素的个数 ", "\n    ", "int", " ", "Statcahr", "(", "char", " a)", ";        ", "// 计算当前队列中有多少个char类型字符 ", "\n    ", "void", " ", "DeAll", "()", ";                ", "// 将队列中所有元素出队 ", "\n", "private", ":\n    DataType sequ[MaxSize];        ", "// 存放队列元素的数组 ", "\n    ", "int", " Len, Rear;                ", "// 队尾元素的位置和内含元素的个数", "\n};\n", "# ", "endif", "\n\n", "\n", "问题相关代码，请勿粘贴截图", "\n", "// 输出当前队列有多少元素 ", "\n    ", "template", " <", "typename", " DataType> ", "int", " CirQueue<DataType>::", "GetLen", "()\n    {\n        ", "return", " Len;\n    }\n\n", "\n", "运行结果及报错内容", "\n", "已启动生成…\n", "1>", "------ 已启动生成: 项目: Cirqueue, 配置: Debug Win32 ------", "\n", "1>", "Cirqueue.cpp", "\n", "1>", "C:\\Users\\93634\\", "source", "\\repos\\Cirqueue\\Cirqueue\\Cirqueue.cpp(30,2): error C2760: 语法错误: 意外标记 ", "\"template\"", "，应为 ", "\"语句\"", "\n", "1>", "Cirqueue_main.cpp", "\n", "1>", "C:\\Users\\93634\\", "source", "\\repos\\Cirqueue\\Cirqueue\\CirQueue.cpp(30,2): error C2760: 语法错误: 意外标记 ", "\"template\"", "，应为 ", "\"语句\"", "\n", "1>", "正在生成代码...", "\n", "1>", "已完成生成项目“Cirqueue.vcxproj”的操作 - 失败。", "\n========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ==========\n\n\n", "\n", "我的解答思路和尝试过的方法", "\n", "我不理解O.O", "error 2760这个问题网上找的和我情况不太一样，他们说改符合模式，我改了反而报了更多的错", "\n", "我想要达到的结果", "\n", "代码跑起来"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;&lt;p&gt;原因在于delete函数中&amp;#xff0c;是把形参head的值设为了null&amp;#xff0c;并没有影响函数外的实参head。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;C语言的函数中通过指针操作数据&amp;#xff0c;给人一种假象&amp;#xff0c;好像传递指针就是引用变量本身了似的。&lt;br /&gt;而实际上&amp;#xff0c;传递指针依然传递的是指针的值&amp;#xff0c;形参与实参依旧是两个不同的指针变量&amp;#xff0c;只不过他们的值(也就是指针指向的地址)相同&amp;#xff0c;让它们通过*和-&amp;gt;解引用后能指向相同的地方。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于你这个问题&amp;#xff0c;可以考虑给delete加个返回值&amp;#xff0c;把形参head返回到外部&amp;#xff0c;就能判断是否所有节点都删除了。&lt;br /&gt;也可以用更高一级的指针作为形参&amp;#xff0c;&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;(LinkList **head)&lt;span class=\"hljs-comment\"&gt;//删除节点&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后传入的实参是&amp;amp;head。这样在函数里通过*head &amp;#61; null也能给实参赋值。不过这样会让程序更难看懂&amp;#xff0c;不推荐用二级指针。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c语言用链表删除头节点的问题", ["自学完c语言尝试写一个学生管理系统", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<stdlib.h>", "\n", "typedef", " ", "struct", "         ", "/*学生类型定义*/", "\n{\n ", "int", " sno;         ", "/*学号*/", "      \n ", "char", " sname[", "8", "];    ", "/*姓名*/", "\n ", "int", " score;       ", "/*成绩*/", "\n\n}Student;\n\n", "typedef", " ", "struct", " ", "Node", "\n{\n Student data;\n ", "struct", " ", "Node", " *next;\n}LinkList;\n\n\n\n", "LinkList  *", "createTailList", " ", "()", "                        ", "/*以尾插法建立带头节点的单链表*/", "\n", "{   \n    ", "int", " x;\n   LinkList * head=", "NULL", ";           /遍历找last\n", "do", "{\n   ", "printf", "(", "\"输入学生学号\\n\"", ");\n   ", "scanf", "(", "\"%d\"", ",&x);\n   ", "if", "(x!=", "0", ")    ", "//输出0时结束录入信息", "\n   {\n      LinkList *p=(LinkList*)", "malloc", "(", "sizeof", "(LinkList));", "//建立学生信息空间", "\n      p->data.sno=x;\n         ", "printf", "(", "\"输入学生姓名，成绩。\\n\"", ");\n         ", "scanf", "(", "\"%s %d\"", ",&(p->data.sname),&(p->data.score)); \n          p->next=", "NULL", ";\n         LinkList *last=head;\n         ", "if", "(last)\n         {\n            ", "while", "(last->next)\n            {\n               last=last->next;\n            }\n            last->next=p;\n         }\n         ", "else", "\n         head=p;\n        \n      \n   }\n}", "while", " (x!=", "0", ");\n", "return", " head; ", "//返回头地址", "\n}\n\n\n", "//输出函数", "\n", "void", " ", "printElem", "(LinkList *head)", "   \n", "{   \n LinkList *p=head;", "//指向head", "\n", "printf", "(", "\"链表中所有的学生信息如下:\\n\"", ");\n   ", "while", " (p)\n {\n     ", "printf", "(", "\"学号:%d,姓名:%s,成绩:%d\\n\"", ",p->data.sno,p->data.sname,p->data.score); ", "/*输出p的节点信息*/", "\n      p=p->next;", "//指向下一个", "\n   }\n}\n\n", "void", " ", "menu", "()", "//菜单", "\n", "{\n ", "printf", "(", "\"请输入你需要实现的功能\\n\"", ");\n ", "printf", "(", "\"1.显示学生信息\\n\"", ");\n ", "printf", "(", "\"2.修改学生信息\\n\"", ");\n ", "printf", "(", "\"3.插入学生信息\\n\"", ");\n ", "printf", "(", "\"4.删除学生信息\\n\"", ");\n ", "printf", "(", "\"5.退出系统\\n\"", ");\n\n}\n\n\n", "void", " ", "fix", "(LinkList *head)", "//修改学生信息", "\n", "{\n   ", "int", " o1=", "0", ";\n   LinkList *t2=head;\n   ", "printf", "(", "\"输入被修改的学生的学号\\n\"", ");\n  ", "scanf", "(", "\"%d\"", ",&o1);\n  ", "for", "(t2;t2;t2=t2->next)\n  {\n   ", "if", "(t2->data.sno==o1)\n   {", "printf", "(", "\"输入新的姓名与成绩，中间用空格隔开\\n\"", ");\n   ", "scanf", "(", "\"%s %d\"", ",&(t2->data.sname),&(t2->data.score));", "//赋值新的数据", "\n   ", "printf", "(", "\"修改完成\\n\"", ");\n   }\n   \n  \n  }\n}\n\n", "void", " ", "myinsert", "(LinkList *head)", "//插入节点，不能插入到头节点之前", "\n", "{\n   ", "int", " k1=", "0", ";\n   LinkList *t3=head;\n   ", "printf", "(", "\"输入被插入的学生的学号\\n\"", ");\n   ", "scanf", "(", "\"%d\"", ",&k1);\n   LinkList *n;\n   LinkList *t31=head->next;\n   ", "while", " (t31&&t31->data.sno!=k1)", "//不能在头节点前插入", "\n   {\n      t3=t31;\n      t31=t31->next;\n   }\n   ", "if", "(!t31)", "//坐标", "\n   {\n      ", "printf", "(", "\"无后驱学生，将插入到最后\\n\"", ");\n     \n   }\n \n   ", "printf", "(", "\"请输入插入学生的学号，姓名，成绩，中间用空格\\n\"", ");\n   n=(LinkList *)", "malloc", "(", "sizeof", "(LinkList));\n   ", "scanf", "(", "\"%d %s %d\"", ",&(n->data.sno),&(n->data.sname),&(n->data.score));\n   n->next=t31;\n   t3->next=n;\n}\n\n\n", "void", " ", "delete", "(LinkList *head)", "//删除节点", "\n", "{\n  ", "int", " w=", "0", ";\n   ", "printf", "(", "\"请输入要删除的学生的学号\\n\"", ");\n   ", "scanf", "(", "\"%d\"", ",&w);\n   LinkList *t1;\n   LinkList *q;\n", "for", "(q=", "NULL", ",t1=head;t1;q=t1,t1=t1->next)", "// t1会指向要删除的节点;", "\n{\n   ", "if", "(t1->data.sno==w)", "//删除的不是头节点", "\n      {", "if", "(q)\n         {\n            q->next=t1->next;\n         \n         }\n         ", "else", "\n         {\n      head=t1->next;", "//要删除的是头节点", "\n     \n         }\n         ", "printf", "(", "\"删除完毕\\n\"", ");\n         ", "free", " (t1); \n         t1=", "NULL", ";\n   \n         \n         ", "break", ";\n         \n\n      }\n}\n", "printElem", "(head) ;\n\n}\n\n\n\n\n\n", "int", " ", "main", "(", "int", " argc,", "char", " *argv[ ])", "\n", "{     \n  ", "int", " a;\n", "printf", "(", "\"请输入学生信息\\n\"", ");\n   LinkList *head=", "createTailList", "(*head ) ; \n    ", "system", "(", "\"pause\"", ");", "//暂停  输入其他案件继续执行后续的代码", "\n ", "system", "(", "\"CLS\"", ");", "//清屏 清除之前的输入提示等等 使页面干净", "\n  \n  ", "menu", "();\n   ", "while", "(", "1", ")\n   {\n    ", "printf", "(", "\"请选择所需功能:\"", ");\n   ", "scanf", "(", "\"%d\"", ",&a);\n    ", "switch", "(a)\n   {\n    ", "case", " ", "1", ":\n           ", "printElem", "(head);", "//输出", "\n    ", "menu", "();\n     ", "break", ";\n\n\n   ", "case", " ", "2", ":\n       ", "fix", "(head);", "//修改", "\n    ", "menu", "();\n     ", "break", ";\n\n\n   ", "case", " ", "3", ":\n           ", "myinsert", "(head);", "//插入", "\n    ", "menu", "();\n     ", "break", ";\n\n\n     ", "case", " ", "4", ":\n           ", "delete", "(head);", "//删除", "\n    ", "menu", "();\n     ", "break", ";\n\n    \n\n\n     ", "case", " ", "5", ":", "//退出系统", "\n            ", "exit", "(", "0", ");\n      \n   ", "break", ";\n    \n   \n    \n   }\n}\n\n\n}\n \n\n\n", "\n", "在之前写过这个一模一样的，只不过没用函数，而是一长串的写下来，删除模块可以删除掉头结点的，而且不会出现垃圾值，但是用了函数后，删除头节点是不行的，我已经释放了头结点的内存，但那段内存仍然被垃圾值填充，并没有消失。我试着在删除完节点的函数中继续添加了一个输出链表的函数，这个输出是正常的，但是你在菜单页面让他再次输出，就会出现头节点并没有消失，而是被垃圾值填充。", "\n", "我的解答思路和尝试过的方法 ：我尝试过在释放内存后，让指向头结点的指针指向null，但仍然无济于事。", "\n", "我想要达到的结果 ：头节点可以正常删除，直接消失，而不是出现垃圾值。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;远程看吧 这代码有点多,用肉眼筛选的话 不方便,你私聊我&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["学习龙虾三少springboot+mybatis 一切运行顺畅但数据库不增加数据", ["开发环境\nIntelliJ IDEA 2021.1.2\nmysql 5.7 本机安装\n前端 andriod sudio4.21", "\n", "问题：注册成功但是数据库不增加记录，搞不清楚问题在哪\n", "#代码全程copy，一点点学的，springboot正常启动，数据库连接正常", "\n前端注册电话号码，数据库中有一样的号码，正常显示了重复注册", "\n", "\n证明前端可以联络到数据库，并且查询到了数据库中有重复数据，返回了不能注册", "\n", "#更换电话号码，填写信息后，点击注册，页面正常跳转通过，但是数据库没有增加新的注册数据", "\n", "idea debug启动", "\n", "\n前端数据传回后端正常", "\n", "\n到这一步开始出现问题，age和gender数据出现问题", "\n", "\n到这一步 小白 就不太懂了，数据没传过来", "\n", "下面是数据库的截图", "\n", "\n", "\n", "package", " org.example.controller;\n\n", "import", " com.alibaba.druid.util.StringUtils;\n", "import", " org.example.controller.viewobject.RegisterVO;\n", "import", " org.example.controller.viewobject.UserVO;\n", "import", " org.example.error.BusinessException;\n", "import", " org.example.error.EmBusinessError;\n", "import", " org.example.response.CommonReturnType;\n", "import", " org.example.response.OtpCode;\n", "import", " org.example.service.UserService;\n", "import", " org.example.service.model.UserModel;\n", "import", " org.example.util.CommonUtil;\n", "import", " org.slf4j.Logger;\n", "import", " org.slf4j.LoggerFactory;\n", "import", " org.springframework.beans.BeanUtils;\n", "import", " org.springframework.beans.factory.annotation.Autowired;\n", "import", " org.springframework.stereotype.Controller;\n", "import", " org.springframework.validation.BindingResult;\n", "import", " org.springframework.web.bind.annotation.*;\n", "import", " sun.misc.BASE64Encoder;\n\n", "import", " javax.servlet.http.HttpServletRequest;\n", "import", " javax.servlet.http.HttpSession;\n", "import", " javax.validation.Valid;\n", "import", " java.io.UnsupportedEncodingException;\n", "import", " java.security.MessageDigest;\n", "import", " java.security.NoSuchAlgorithmException;\n", "import", " java.util.Random;\n\n", "/*\n@Controller的作用在类级上，用来标记该类,让Spring可以扫描到\n这一部分知识属于基础知识，可以参考《Spring实战（任意一版）》\n*/", "\n", "@Controller(\"user\")", "\n", "@RequestMapping(\"/user\")", "\n", "/**\n * 继承BaseController，\n * 父类的方法子类不重新，就会引用父类的方法，\n * 若子类重写父类的方法，则引用子类的方法\n * 这里不需要进行重写handlerException\n *\n *   ", "@CrossOrigin", "解决跨域请求问题\n *   No 'Access-Control-Allow-Origin' header is present on the requested resource\n *   加上这个注解后，就会让response对象返回'Access-Control-Allow-Origin' header 为 通配符*\n *   但是单纯的加注解，只是让跨域互通了，还不能实现互信\n *   需要再加两个参数，才能实现前后端互信\n *\n * ", "@author", " littlecurl\n */", "\n", "@CrossOrigin(allowCredentials = \"true\", allowedHeaders = \"*\")", "\n", "public", " ", "class", " ", "UserController", " ", "extends", " ", "BaseController", " {\n    ", "private", " ", "static", " ", "Logger", " ", "Log", " ", "=", " LoggerFactory.getLogger(UserController.class);\n    ", "/**\n     * 带", "@Autowired", "的都是Bean，默认用单例模式创建\n     */", "\n    ", "@Autowired", "\n    ", "private", " UserService userService;\n\n    ", "@Autowired", "\n    ", "private", " HttpServletRequest httpServletRequest;\n\n    ", "/**\n     *\n     */", "\n    ", "private", " HttpSession session;\n\n    ", "/**\n     * **************** 对前两个注解的解释：****************\n     * 1、这里的", "@RequestMapping", "作用在方法级，\n     * 告诉我们不只有类级可以使用此注解，\n     * 同时也提现了SpringMVC可以映射URL到具体方法的优秀设计\n     * 2、这里需要指定", "@ResponseBody", "，\n     * 具体理解可以参考[博客园](https://www.cnblogs.com/qiankun-site/p/5774325.html#4263851)\n     * 这样返回的数据才会以JSON的格式写入到HttpServletResponse对象的body区\n     * 浏览器才能呈现body区的JSON数据\n     * 如果忘记指定", "@ResponseBody", "，则response对象为空，会报404错误\n     * （具体response对象是个啥？这是JavaEE基础Servlet里面的知识点，可以回头补习一下）\n     * 另外，JSON格式的数据，推荐是否Firefox浏览器查看，会自动格式化\n     * <p>\n     * **************** 对返回值类型CommonReturnType的解释：****************\n     * 虽然我们在Service层，将dataobject整合成了UserModel\n     * 但那是给Controller层诸如密码验证之类的，需要两张表的数据的业务准备的\n     * 单纯的getUser()业务没必要返回UserModel，将用户敏感信息诸如加密密码，登录方式等等也透传给前端\n     * 因此返回值应该再独立出一个viewobject层\n     * 但是，仅仅返回viewobject对象的JSON序列化，这样设计没有通用性\n     * 比如说，不知道返回值的状态到底是成功还是失败\n     * 因此，应该再构造一个response层，对viewobject进行封装，返回CommonReturnType\n     * <p>\n     * **************** 对", "@RequestParam", "注解的解释：****************\n     *\n     * ", "@param", " id 用户id\n     * ", "@return", " 通用返回对象\n     * ", "@RequestParam", "用来获取URL中?后面的arg=value对应的参数值 当然SpringMVC不只提供了这一种获取参数的方式，只不过这一注解最常用，其他注解还有好多\n     * 具体可以参考[博客园](https://www.cnblogs.com/selinamee/p/5266266.html)\n     */", "\n    ", "@RequestMapping(\"/get\")", "\n    ", "@ResponseBody", "\n    ", "public", " CommonReturnType ", "getUser", "(", "@RequestParam(name = \"id\")", " Integer id)", " ", "throws", " BusinessException {\n        ", "/* 调用Service服务，获取id对应的用户信息UserModel\n           将model转为viewobject\n           再将viewobject进行封装成CommonReturnType\n           返回CommonReturnType\n        */", "\n        ", "UserModel", " ", "userModel", " ", "=", " userService.getUserById(id);\n        ", "/*\n         若用户不存在，则抛出异常，抛到了Tomcat的容器层，\n         如果把异常抛到Tomcat容器层后就不管了，那就只是会在控制台Tomcat日志中打印异常信息，\n         无法返回到前端。\n         好在SpringBoot有给出解决办法，就是再定义一个handlerException方法，\n         写在了BaseController中。\n         */", "\n        ", "if", " (userModel == ", "null", ") {\n            ", "/*\n            如果把下面的代码注释掉，并且再引用一下userModel对象\n             比如：\n             userModel.setEncryptPassword(\"123\")；\n             因为userModel是null，引用空指针进行set，Java虚拟机会抛出java.lang.NullPointException\n             这时候就会触发BaseController里面SpringBoot的注解@ExceptionHandler(Exception.class)\n             然后判断到if (ex instanceof BusinessException)条件不成立\n             继而返回UNKNOWN_ERROR的CommonReturnType\n             从这里可以看出来UserController继承BaseController实现代码复用机制\n             */", "\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.USER_NOT_EXIST);\n        }\n        ", "UserVO", " ", "userVO", " ", "=", " convertFromModel(userModel);\n        ", "/*\n           如果没有异常跑出，就表示返回的是正确的结果\n           同时，因为有加@ResponseBody注解，该对象会被解析为JSON格式，呈现到前端\n         */", "\n        ", "return", " CommonReturnType.create(userVO);\n    }\n\n    ", "/**\n     * 将UserModel转为UserVO\n     *\n     * ", "@param", " userModel Model\n     * ", "@return", " UserVO\n     */", "\n    ", "private", " UserVO ", "convertFromModel", "(UserModel userModel)", " {\n        ", "if", " (userModel == ", "null", ") {\n            ", "return", " ", "null", ";\n        }\n        ", "UserVO", " ", "userVO", " ", "=", " ", "new", " ", "UserVO", "();\n        ", "/* 调用BeanUtils提供的复制属性方法，userVO不存在的属性会被自动丢弃 */", "\n        BeanUtils.copyProperties(userModel, userVO);\n        ", "return", " userVO;\n    }\n\n    ", "/**\n     * 获取otp验证码\n     * 三步走\n     * 1、生成验证码\n     * 2、存到 Session 中\n     * 3、返回验证码\n     *\n     * 注意这里POST请求要求传递请求头 content-type:application/x-www-form-urlencoded\n     *\n     * ", "@param", " telephone\n     * ", "@return", "\n     * ", "@throws", " BusinessException\n     */", "\n    ", "@RequestMapping(value = \"/getOtp\", method = {RequestMethod.POST}, consumes = {CONTENT_TYPE_FORMED})", "\n    ", "@ResponseBody", "\n    ", "public", " CommonReturnType ", "getOtp", "(", "@RequestParam(name = \"telephone\")", " String telephone)", " ", "throws", " BusinessException {\n        ", "/* 0、用户获取验证码时，检测是否已存在注册用户 */", "\n        ", "boolean", " ", "hasRegistered", " ", "=", " userService.getUserByTelephone(telephone);\n        ", "if", " (hasRegistered) {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR, ", "\"手机号已重复注册\"", ");\n        }\n        ", "// 1、按照一定规则生成OTP验证码（6位）", "\n        ", "Random", " ", "random", " ", "=", " ", "new", " ", "Random", "();\n        ", "int", " ", "randomInt", " ", "=", " random.nextInt(", "99999", ");\n        randomInt += ", "100000", ";\n        ", "String", " ", "otpCode", " ", "=", " String.valueOf(randomInt);\n\n        ", "// 2、将OTP验证码与用户手机号进行绑定", "\n        session = httpServletRequest.getSession();\n        session.setAttribute(telephone, otpCode);\n\n        ", "// 3、将OTP验证码通过短信通道发给用户，省略", "\n        Log.info(", "\"telephone: \"", " + telephone + ", "\"&otpCode: \"", " + otpCode);\n\n        ", "// 4、将信息抽象为类", "\n        ", "OtpCode", " ", "otpCodeObj", " ", "=", " ", "new", " ", "OtpCode", "(telephone, otpCode);\n        ", "// 5、返回正确信息，方便前端获取", "\n        ", "return", " CommonReturnType.create(otpCodeObj, ", "\"successGetOtpCode\"", ");\n    }\n\n    ", "/**\n     * 用户注册接口\n     * 接收参数统一使用字符串，接收后再进行类型转换\n     *\n     * ", "@param", " telephone 手机号\n     * ", "@param", " otpCode   验证码\n     * ", "@param", " name      姓名\n     * ", "@param", " ageStr    年龄\n     * ", "@param", " genderStr 性别\n     * ", "@param", " password  密码\n     * ", "@return", " 通用返回对象\n     */", "\n    ", "@RequestMapping(value = \"/register\", method = {RequestMethod.POST}, consumes = {CONTENT_TYPE_FORMED})", "\n    ", "@ResponseBody", "\n    ", "public", " CommonReturnType ", "register", "(\n            ", "@RequestParam(name = \"telephone\")", " String telephone,\n            ", "@RequestParam(name = \"otpCode\")", " String otpCode,\n            ", "@RequestParam(name = \"name\")", " String name,\n            ", "@RequestParam(name = \"age\")", " String ageStr,\n            ", "@RequestParam(name = \"gender\")", " String genderStr,\n            ", "@RequestParam(name = \"password\")", " String password\n    )", " ", "throws", " UnsupportedEncodingException, NoSuchAlgorithmException, BusinessException {\n        ", "boolean", " ", "hasRegistered", " ", "=", " userService.getUserByTelephone(telephone);\n        ", "if", " (hasRegistered) {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR, ", "\"手机号已重复注册\"", ");\n        }\n\n        ", "// 从Session中获取对应手机号的验证码", "\n        ", "// otpCode是用户填写的，inSessionOtpCode是系统生成的", "\n        ", "if", " (session == ", "null", ") {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR, ", "\"无效的验证码，请重新获取\"", ");\n        }\n\n        ", "String", " ", "inSessionOtpCode", " ", "=", " (String) session.getAttribute(telephone);\n\n\n        Log.info(", "\"telephone: \"", " + telephone + ", "\" inSessionOtpCode: \"", " + inSessionOtpCode + ", "\" otpCode: \"", " + otpCode);\n        ", "if", " (!StringUtils.equals(otpCode, inSessionOtpCode)) {\n            Log.info(", "\"短信验证码错误\"", ");\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR, ", "\"短信验证码错误\"", ");\n        }\n\n        ", "// 类型转换，适配数据库", "\n        ", "int", " ", "age", " ", "=", " Integer.valueOf(ageStr);\n        ", "int", " ", "gender", " ", "=", " Integer.parseInt(genderStr);\n        ", "// 验证码通过后，进行注册流程", "\n        ", "UserModel", " ", "userModel", " ", "=", " ", "new", " ", "UserModel", "();\n        userModel.setName(name);\n        userModel.setGender(gender);\n        userModel.setAge(age);\n        userModel.setTelephone(telephone);\n        userModel.setEncryptPassword(", "this", ".EncodeByMd5(password));\n\n        ", "// 注册成功，只返回success即可", "\n        ", "return", " CommonReturnType.create(userModel);\n    }\n\n    ", "/**\n     * 用户注册接口\n     * 接收参数统一使用字符串，接收后再进行类型转换\n     *\n     * ", "@return", " 通用返回对象\n     */", "\n    ", "@RequestMapping(value = \"/registerjson\", method = {RequestMethod.POST})", "\n    ", "@ResponseBody", "\n    ", "public", " CommonReturnType ", "registerJson", "(\n            ", "@Valid", "\n            ", "@RequestBody", " RegisterVO registerVO,\n            BindingResult bindingResult\n    )", " ", "throws", " UnsupportedEncodingException, NoSuchAlgorithmException, BusinessException {\n        ", "if", " (bindingResult.hasErrors()) {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR, CommonUtil.processErrorString(bindingResult));\n        }\n        ", "// 从Session中获取对应手机号的验证码", "\n        ", "// otpCode是用户填写的，inSessionOtpCode是系统生成的", "\n        ", "String", " ", "inSessionOtpCode", " ", "=", " (String) session.getAttribute(registerVO.getTelephone());\n        Log.info(", "\"telephone: \"", " + registerVO.getTelephone() + ", "\" inSessionOtpCode: \"", "\n                + inSessionOtpCode + ", "\" otpCode: \"", " + registerVO.getOtpCode());\n        ", "if", " (!StringUtils.equals(registerVO.getOtpCode(), inSessionOtpCode)) {\n            Log.info(", "\"短信验证码错误\"", ");\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR, ", "\"短信验证码错误\"", ");\n        }\n        ", "// 类型转换，适配数据库", "\n        ", "int", " ", "age", " ", "=", " Integer.parseInt(registerVO.getAge());\n        ", "int", " ", "gender", " ", "=", " Integer.parseInt(registerVO.getGender());\n        ", "// 验证码通过后，进行注册流程", "\n        ", "UserModel", " ", "userModel", " ", "=", " ", "new", " ", "UserModel", "();\n        userModel.setName(registerVO.getName());\n        userModel.setGender(gender);\n        userModel.setAge(age);\n        userModel.setTelephone(registerVO.getTelephone());\n\n        userModel.setEncryptPassword(", "this", ".EncodeByMd5(registerVO.getTelephone()));\n\n\n        ", "// 注册成功，只返回success即可", "\n        ", "return", " CommonReturnType.create(", "null", ");\n    }\n\n    ", "/**\n     * 用户登录接口\n     *\n     * ", "@param", " telephone 手机号\n     * ", "@param", " password  原生密码\n     * ", "@return", " 通用返回对象\n     */", "\n    ", "@RequestMapping(value = \"/login\", method = {RequestMethod.POST}, consumes = {CONTENT_TYPE_FORMED})", "\n    ", "@ResponseBody", "\n    ", "public", " CommonReturnType ", "login", "(\n            ", "@RequestParam(value = \"telephone\", required = true)", " String telephone,\n            ", "@RequestParam(value = \"password\", required = true)", " String password,\n            ", "@RequestParam(value = \"type\", required = true)", " String type\n    )", " ", "throws", " BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException {\n        ", "// 入参校验", "\n        ", "if", " (org.apache.commons.lang3.StringUtils.isEmpty(telephone)\n                || org.apache.commons.lang3.StringUtils.isEmpty(password)\n                || org.apache.commons.lang3.StringUtils.isEmpty(type)\n        ) {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR);\n        }\n\n        ", "boolean", " ", "hasRegistered", " ", "=", " userService.getUserByTelephone(telephone);\n        ", "if", " (!hasRegistered) {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.USER_NOT_EXIST);\n        }\n\n        ", "UserModel", " ", "userModel", " ", "=", " ", "null", ";\n        ", "// 登录", "\n        ", "if", " (StringUtils.equals(type, ", "\"login\"", ")) {\n            userModel = userService.validateLogin(telephone, ", "this", ".EncodeByMd5(password));\n        }\n        ", "// 自动登录", "\n        ", "else", " ", "if", " (StringUtils.equals(type, ", "\"autoLogin\"", ")) {\n            userModel = userService.validateLogin(telephone, password);\n        } ", "else", " {\n            ", "throw", " ", "new", " ", "BusinessException", "(EmBusinessError.PARAMETER_VALIDATION_ERROR);\n        }\n\n        ", "// 将登陆凭证加入到用户登录成功的Session中", "\n        ", "// 切换web页面的时候，可以不用重复登录", "\n        session = httpServletRequest.getSession();\n        session.setAttribute(", "\"IS_LOGIN\"", ", ", "true", ");\n        session.setAttribute(", "\"LOGIN_USER\"", ", userModel);\n\n        ", "// 登录成功，只返回success即可", "\n        ", "return", " CommonReturnType.create(userModel);\n    }\n\n    ", "/**\n     * MD5加密+BASE64编码\n     *\n     * ", "@return", " 加密后字符串\n     */", "\n    ", "public", " String ", "EncodeByMd5", "(String str)", " ", "throws", " NoSuchAlgorithmException, UnsupportedEncodingException {\n        ", "MessageDigest", " ", "md5", " ", "=", " MessageDigest.getInstance(", "\"MD5\"", ");\n        ", "BASE64Encoder", " ", "base64en", " ", "=", " ", "new", " ", "BASE64Encoder", "();\n        ", "String", " ", "newstr", " ", "=", " base64en.encode(md5.digest(str.getBytes(", "\"utf-8\"", ")));\n        ", "return", " newstr;\n    }\n}\n", "\n", "另外，数据库中 id 两张表都设置了自增，\nmapper表中也写了 \n  ", "\n", "请大佬们指点"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;三角和反三角函数再加上&amp;#xff0c;代码改动量比较大&lt;br /&gt;链栈的话&amp;#xff0c;需要改数据结构&amp;#xff0c;大体如下&amp;#xff1a;&lt;br /&gt;链表栈计算器代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt; &lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt; &lt;/span&gt;\n\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; M 100&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;/*定义字符串的长度*/&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//#define DEBUG 1&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;/*定义调试模式*/&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;enum&lt;/span&gt; {\n    OK &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,\n    ERROR &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n}Status;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;enum&lt;/span&gt; {\n    TRUE &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,\n    FALSE &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n}Bool;\n\n&lt;span class=\"hljs-comment\"&gt;//数据&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_datatype&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; dc;\n}Datatype;\n\n&lt;span class=\"hljs-comment\"&gt;//链栈结构&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_stacknode&lt;/span&gt; {\n    Datatype data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_stacknode&lt;/span&gt;* next;\n}Stack;\n\n\n&lt;span class=\"hljs-function\"&gt;Stack* &lt;span class=\"hljs-title\"&gt;Stack_init&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Stack* pStack)&lt;/span&gt;\n&lt;/span&gt;{\n    pStack &amp;#61; (Stack*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(Stack));\n    pStack-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; pStack;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Stack_Free&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Stack* pStack)&lt;/span&gt;\n&lt;/span&gt;{\n    Stack* p;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pStack)\n    {\n        p &amp;#61; pStack-&amp;gt;next;\n        &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(pStack);\n        pStack &amp;#61; p;\n    }\n}\n\n\n&lt;span class=\"hljs-function\"&gt;Bool &lt;span class=\"hljs-title\"&gt;Stack_IsEmpty&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Stack* pStack)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pStack &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || pStack-&amp;gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; TRUE;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; FALSE;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;Stack_GetTop&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Stack* pStack, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; f,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* d,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* c)&lt;/span&gt;\n&lt;/span&gt;{\n    Stack* p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pStack &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || pStack-&amp;gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    p &amp;#61; pStack;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next)\n    {\n        p &amp;#61; p-&amp;gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (f &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        *d &amp;#61; p-&amp;gt;data.dt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        *c &amp;#61; p-&amp;gt;data.dc;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;Stack_Push&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Stack* pStack, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    Stack* p, * t;\n    t &amp;#61; (Stack*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(Stack));\n    t-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        t-&amp;gt;data.dt &amp;#61; d;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        t-&amp;gt;data.dc &amp;#61; c;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pStack &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        pStack &amp;#61; t;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        p &amp;#61; pStack;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next)\n            p &amp;#61; p-&amp;gt;next;\n        p-&amp;gt;next &amp;#61; t;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n&lt;span class=\"hljs-comment\"&gt;//f&amp;#61;0表示int类型&amp;#xff0c;其他值表示char&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;Stack_Pop&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Stack* pStack)&lt;/span&gt;\n&lt;/span&gt;{\n    Stack* p, * t;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pStack &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || pStack-&amp;gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    p &amp;#61; pStack;\n    t &amp;#61; p-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t-&amp;gt;next)\n    {\n        p &amp;#61; p-&amp;gt;next;\n        t &amp;#61; t-&amp;gt;next;\n    }\n    p-&amp;gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;/*if (f &amp;#61;&amp;#61; 0)\n        *d &amp;#61; p-&amp;gt;data.dt;\n    else\n        *c &amp;#61; p-&amp;gt;data.dc;*/&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(t);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Judge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*功能&amp;#xff1a;判断运算符的类型并分级\n *参数&amp;#xff1a;x是运算符的符号\n *返回&amp;#xff1a;字符所代表的级数\n */&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Culculate&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x1, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x2, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; s)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*功能&amp;#xff1a;执行计算\n *参数&amp;#xff1a;x1是第一个数字\n        x2是第二个数字\n        s是运算符\n *返回&amp;#xff1a;返回运算结果\n */&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;Check&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; left, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*功能&amp;#xff1a;判断左右括号是否匹配\n *参数&amp;#xff1a;left是左括号&amp;#xff0c;right是右括号\n *返回&amp;#xff1a;若左右括号匹配返回OK&amp;#xff0c;否则返回ERROR\n */&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;CharIsSymbol&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*功能&amp;#xff1a;判断字符是运算符\n *参数&amp;#xff1a;c是字符\n *返回&amp;#xff1a;若c为运算符返回OK&amp;#xff1b;否则返回ERROR\n */&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;CharIsNum&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; d)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*功能&amp;#xff1a;判断字符是数字\n *参数&amp;#xff1a;d是字符\n *返回&amp;#xff1a;若d是数字返回OK&amp;#xff1b;否则返回ERROR\n */&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DoSingleOperation&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; s[])&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-comment\"&gt;/*功能&amp;#xff1a;执行一行字符的计算\n *参数&amp;#xff1a;s[]是这一行字符串\n *返回&amp;#xff1a;返回运算结果\n */&lt;/span&gt;\n\n\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Judge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt; || x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt; || x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (x &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Culculate&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x1, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x2, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; s)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; result &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (s) {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;: {\n        result &amp;#61; x1 &amp;#43; x2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;: {\n        result &amp;#61; x1 - x2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;: {\n        result &amp;#61; x1 * x2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;: {\n        result &amp;#61; x1 / x2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;: {\n        result &amp;#61; &lt;span class=\"hljs-built_in\"&gt;pow&lt;/span&gt;((&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)x1, x2);\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result;\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;Check&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; left, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; right)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (left &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; right &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;CharIsSymbol&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt; || c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt; || c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt; || c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; || c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; || c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt; || c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;CharIsNum&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; d)&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;gt;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; d &amp;lt;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;9&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DoSingleOperation&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; s[])&lt;/span&gt; &lt;/span&gt;{\n    Stack* pIntStack &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;/*这个栈存放数字*/&lt;/span&gt;\n    Stack* pSymbolStack &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;/*这个栈存放除括号外的符号*/&lt;/span&gt;\n    Stack* pSymbolStack_2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;/*这个栈存放括号*/&lt;/span&gt;\n    Status sta;\n\n    pIntStack &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Stack_init&lt;/span&gt;(pIntStack);\n    pSymbolStack &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Stack_init&lt;/span&gt;(pSymbolStack);\n    pSymbolStack_2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Stack_init&lt;/span&gt;(pSymbolStack_2);\n\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len, n;\n    len &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(s);\n    s[len] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;;\n    len&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a, b, c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, d &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; topele_int;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; topele_c;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; x[M];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s[i] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt;) {\n            &lt;span class=\"hljs-built_in\"&gt;Stack_Push&lt;/span&gt;(pSymbolStack_2, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, s[i]);\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s[i] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;) {\n            &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pSymbolStack_2,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;amp;topele_int,&amp;amp;topele_c);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;Check&lt;/span&gt;(topele_c, s[i]) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pSymbolStack_2);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;括号不匹配&amp;#34;&lt;/span&gt;);           &lt;span class=\"hljs-comment\"&gt;/*判断括号是否匹配*/&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            }\n        }\n    }\n    i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt; || s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt; || s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt; || s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; || s[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;^&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;运算符不能在开头&amp;#34;&lt;/span&gt;);                        &lt;span class=\"hljs-comment\"&gt;/*除括号外的运算符不能在字符串开始处*/&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s[i] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;CharIsNum&lt;/span&gt;(s[i]) &amp;#61;&amp;#61; OK) {\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s[i] &amp;gt;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &amp;amp;&amp;amp; s[i] &amp;lt;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;9&amp;#39;&lt;/span&gt;) {\n                x *&amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n                x &amp;#43;&amp;#61; s[i&amp;#43;&amp;#43;] - &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-built_in\"&gt;Stack_Push&lt;/span&gt;(pIntStack, x);\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; theta &amp;#61; s[i];\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;Stack_IsEmpty&lt;/span&gt;(pSymbolStack) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { &lt;span class=\"hljs-comment\"&gt;//&amp;amp;&amp;amp;Stack_GetTop(pSymbolStack)!&amp;#61;&amp;#39;(&amp;#39;&amp;amp;&amp;amp;Judge(Stack_GetTop(pSymbolStack))&amp;gt;&amp;#61;Judge(s[i])&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pSymbolStack,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;topele_c);\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (topele_c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; || &lt;span class=\"hljs-built_in\"&gt;Judge&lt;/span&gt;(topele_c) &amp;lt; &lt;span class=\"hljs-built_in\"&gt;Judge&lt;/span&gt;(s[i]))\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n                &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pIntStack, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&amp;amp;a,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pIntStack); \n                &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pIntStack,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;b,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pIntStack);\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; topele_c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) { &lt;span class=\"hljs-comment\"&gt;//Stack_GetTop(pSymbolStack)&lt;/span&gt;\n                    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;除数不能为0\\n&amp;#34;&lt;/span&gt;);                         &lt;span class=\"hljs-comment\"&gt;/*判断除数是否为0&amp;#xff0c;若为0则结束程序&amp;#xff0c;否则继续运行*/&lt;/span&gt;\n                    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                }\n                c &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Culculate&lt;/span&gt;(b, a, topele_c);&lt;span class=\"hljs-comment\"&gt;//Stack_GetTop(pSymbolStack)&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Push&lt;/span&gt;(pIntStack,c);\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pSymbolStack);\n            }\n            sta &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pSymbolStack,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;topele_c);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (sta &amp;#61;&amp;#61; OK &amp;amp;&amp;amp; &lt;span class=\"hljs-built_in\"&gt;Judge&lt;/span&gt;(theta) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=\"hljs-built_in\"&gt;Judge&lt;/span&gt;(topele_c) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;) {\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pSymbolStack);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;Judge&lt;/span&gt;(theta) !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                &lt;span class=\"hljs-built_in\"&gt;Stack_Push&lt;/span&gt;(pSymbolStack,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, theta);\n            }\n            i&amp;#43;&amp;#43;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;Stack_IsEmpty&lt;/span&gt;(pSymbolStack) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pSymbolStack,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;topele_c);\n        &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pIntStack, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&amp;amp;a,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pIntStack);\n        &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pIntStack,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;b,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pIntStack);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; topele_c &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;除数不能为0\\n&amp;#34;&lt;/span&gt;);                                &lt;span class=\"hljs-comment\"&gt;/*判断除数是否为0&amp;#xff0c;若为0则结束程序&amp;#xff0c;否则继续运行*/&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n        c &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Culculate&lt;/span&gt;(b, a, topele_c);&lt;span class=\"hljs-comment\"&gt;//Stack_GetTop(pSymbolStack)&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;Stack_Push&lt;/span&gt;(pIntStack, c);\n        &lt;span class=\"hljs-built_in\"&gt;Stack_Pop&lt;/span&gt;(pSymbolStack);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Stack_GetTop&lt;/span&gt;(pIntStack,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;a,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, a);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; all[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; result &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    FILE* fp &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);            &lt;span class=\"hljs-comment\"&gt;/*以只读模式打开文件1*/&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (fp &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;The first txt can not be opened!&amp;#34;&lt;/span&gt;);             &lt;span class=\"hljs-comment\"&gt;/*若打开文件1失败&amp;#xff0c;结束程序&amp;#xff0c;否则继续运行*/&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    FILE* fp2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;2.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);           &lt;span class=\"hljs-comment\"&gt;/*以写入模式打开文件2*/&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;feof&lt;/span&gt;(fp)) {\n        &lt;span class=\"hljs-built_in\"&gt;fgets&lt;/span&gt;(all, &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;, fp);                                      &lt;span class=\"hljs-comment\"&gt;/*对文件1逐行读取*/&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(all);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (len &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {                                             &lt;span class=\"hljs-comment\"&gt;/*若为空行&amp;#xff0c;则结束此次循环&amp;#xff0c;开始执行下一行的程序*/&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (all[len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;) {\n            all[len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, all);\n        result &amp;#61; &lt;span class=\"hljs-built_in\"&gt;DoSingleOperation&lt;/span&gt;(all);                          &lt;span class=\"hljs-comment\"&gt;/*对读入的一行进行运算*/&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;fprintf&lt;/span&gt;(fp2, &lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, result);                             &lt;span class=\"hljs-comment\"&gt;/*对读入的一行的运算结果打印到文件2中*/&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(fp);                                                 &lt;span class=\"hljs-comment\"&gt;/*关闭文件1*/&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(fp2);                                                &lt;span class=\"hljs-comment\"&gt;/*关闭文件2*/&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c语言计算器程序改进", ["对计算器程序的改善", "用链栈实现并增加三角函数、反三角函数、平方根功能", "\n", "\n#", "include", "<stdio.h>\n#", "include", "<stdlib.h> \n#", "include", "<math.h>\n#", "include", "<", "string", ".h> \n\n#define STACK_INIT_SIZE ", "100", "\n", "/*定义栈初始容量*/", "\n#define STACK_INCREMENT ", "10", "\n", "/*定义栈增加容量*/", "\n#define M ", "100", "\n", "/*定义字符串的长度*/", "\n#define DEBUG ", "0", " \n", "/*定义调试模式*/", "\n\ntypedef enum{\n    OK=", "1", ",\n    ERROR=", "0", "\n}Status;\n\ntypedef enum{\n    TRUE=", "1", ",\n    FALSE=", "0", "\n}Bool; \n\ntypedef ", "struct", "{\n    void* pBase;\n    void* pTop;\n    ", "int", " elementSize;\n    ", "int", " stackSize;\n}Stack;\n\nStack* ", "Stack_Construct(", "int", " ", "sizeOfElement", ")", ";\n", "/*功能：构造一个栈\n *参数：栈元素类型的长度 \n *返回：构造成功返回新构造的栈；否则返回NULL \n */", "\n\nStack* ", "Stack_Construct(", "int", " ", "sizeOfElement", ")", "{\n    Stack *pStack;\n    pStack=(Stack*)malloc(sizeof(Stack));\n    ", "if", "(pStack==NULL){\n        return NULL;\n    }\n    pStack->pBase=malloc(STACK_INIT_SIZE*sizeOfElement);\n    ", "if", "(pStack->pBase==NULL){\n        free(pStack);\n        return NULL;\n    }\n    pStack->pTop=pStack->pBase;\n    pStack->elementSize=sizeOfElement;\n    pStack->stackSize=STACK_INIT_SIZE;\n    return pStack;\n}\n\nStatus ", "Stack_Init(Stack ", "*", "pStack", ")", ";\n", "/*参数：pStack是指向栈的指针 \n *返回：成功返回OK；否则返回ERROR \n */", "\n\nvoid ", "Stack_Free(Stack ", "*", "pStack", ")", ";\n", "/*参数：pStack是指向栈的指针 \n *返回：无 \n */", "\n\nvoid ", "Stack_Clear(Stack ", "*", "pStack", ")", ";\n", "/*参数：pStack是指向栈的指针 \n *返回：无 \n */", "\n \nBool ", "Stack_IsEmpty(Stack ", "*", "pStack", ")", ";\n", "/*参数：pStack是指向栈的指针\n *返回：若栈为空，返回true；否则返回false \n */", "\n\nBool ", "Stack_IsFull(Stack ", "*", "pStack", ")", ";\n", "/*参数：pStack是指向栈的指针 \n *返回：若栈已满，返回true；否则返回false \n */", "\n\n", "int", " ", "Stack_Length(Stack ", "*", "pStack", ")", ";\n", "/*参数：pStack是指向栈的指针 \n *返回:栈的长度 \n */", "\n\n", "//char Stack_GetTop(Stack *pStack);", "\nStatus ", "Stack_GetTop(Stack ", "*", "pStack", ",", "void", " ", "*", "pElem", ")", ";\n", "/*功能：取出栈顶元素\n *参数：pStack是指向栈的指针\n *返回：返回栈顶元素 \n */", " \n\nStatus ", "Stack_Push(Stack ", "*", "pStack", ",", "void", " ", "*", "pVoid", ")", ";\n", "/*功能：将pVoid指向的数据压入pStack指向的栈 \n *参数：pStack是指向栈的指针，pVoid是指向数据的指针\n *返回：成功返回OK；否则返回ERROR \n */", " \n\nStatus ", "Stack_Pop(Stack ", "*", "pStack", ",", "void", " ", "*", "pVoid", ")", ";\n", "/*功能：将pStack指向的栈的元素弹出存入pVoid指向的内存 \n *参数：pStack是指向栈的指针，pVoid是指向数据的指针 \n *返回：成功返回OK；否则返回ERROR \n */", " \n\n", "//Status Stack_Traverse(Stack *pStack,Status(*visit)());", "\n", "/*功能：对pStack指向的栈的每个元素执行visit操作 \n *参数：pStack是指向栈的指针，visit是函数指针 \n *返回：成功返回OK；失败返回ERROR \n */", "\n\n", "float", " ", "ConvertToFloat(", "char", " ", "m", "[M],", "float", " ", "r", ")", ";\n", "/*功能：将数字串转换为浮点数 \n *参数：m[M]是原数字串，r是浮点数即结果 \n *返回：返回结果浮点数r \n */", "\n\n", "int", " ", "Judge(", "char", " ", "x", ")", ";\n", "/*功能：判断运算符的类型并分级 \n *参数：x是运算符的符号 \n *返回：字符所代表的级数 \n */", "\n \n", "int", " ", "Culculate(", "int", " ", "x1", ",", "int", " ", "x2", ",", "char", " ", "s", ")", ";\n", "/*功能：执行计算 \n *参数：x1是第一个数字\n        x2是第二个数字\n        s是运算符 \n *返回：返回运算结果 \n */", "\n\nStatus ", "Check(", "char", " ", "left", ",", "char", " ", "right", ")", ";\n", "/*功能：判断左右括号是否匹配 \n *参数：left是左括号，right是右括号 \n *返回：若左右括号匹配返回OK，否则返回ERROR \n */", "\n \nStatus ", "CharIsSymbol(", "char", " ", "c", ")", ";\n", "/*功能：判断字符是运算符 \n *参数：c是字符 \n *返回：若c为运算符返回OK；否则返回ERROR \n */", "\n \nStatus ", "CharIsNum(", "char", " ", "d", ")", ";\n", "/*功能：判断字符是数字 \n *参数：d是字符 \n *返回：若d是数字返回OK；否则返回ERROR \n */", " \n \n", "int", " ", "DoSingleOperation(", "char", " ", "s", "[])", ";\n", "/*功能：执行一行字符的计算 \n *参数：s[]是这一行字符串 \n *返回：返回运算结果 \n */", " \n\nStatus ", "Stack_Init(Stack ", "*", "pStack", ")", "{\n    pStack->pBase=malloc(STACK_INIT_SIZE*sizeof(", "char", "));\n    ", "if", "(pStack->pBase==NULL){\n        return ERROR;\n    }\n    pStack->pTop=pStack->pBase;\n    pStack->stackSize=STACK_INIT_SIZE;\n    return OK;\n}\n\nvoid ", "Stack_Free(Stack ", "*", "pStack", ")", "{\n    free(pStack->pBase);\n    pStack->pBase=NULL;\n    pStack->pTop=NULL;\n    pStack->stackSize=", "0", ";\n    free(pStack);\n    return;\n}\n\nvoid ", "Stack_Clear(Stack ", "*", "pStack", ")", "{\n    pStack->pTop=pStack->pBase;\n}\n\nBool ", "Stack_IsEmpty(Stack ", "*", "pStack", ")", "{\n    ", "if", "(pStack->pTop==pStack->pBase){\n        return TRUE;\n    }\n    ", "else", "{\n        return FALSE;\n    }\n}\n\nBool ", "Stack_IsFull(Stack ", "*", "pStack", ")", "{\n    ", "if", "((", "char", "*)pStack->pTop-(", "char", "*)pStack->pBase==pStack->stackSize){\n        return TRUE;\n    }\n    ", "else", "{\n        return FALSE;\n    }\n}\n\n", "int", " ", "Stack_Length(Stack ", "*", "pStack", ")", "{\n    return ((", "char", "*)pStack->pTop-(", "char", "*)pStack->pBase)/pStack->elementSize;\n}\n\nStatus ", "Stack_GetTop(Stack ", "*", "pStack", ",", "void", " ", "*", "pElem", ")", "{\n    ", "int", "* pt;\n    ", "char", "* pt2;\n    ", "if", "(pStack->pTop==pStack->pBase){\n        return ERROR;\n    }\n    ", "if", "(pStack->elementSize", " == ", "sizeof(", "int", "))\n    {\n        pt = (", "int", "*)((", "char", "*)pStack->pTop -pStack->elementSize);\n        *((", "int", "*)pElem) = *pt;\n    }", "else", " \n    {\n        pt2 = (", "char", "*)((", "char", "*)pStack->pTop -pStack->elementSize);\n        *((", "char", "*)pElem) = *pt2;\n    }\n    ", "//pElem=(char*)pStack->pTop - pStack->elementSize;", "\n    return OK;\n}\n\nStatus ", "Stack_Push(Stack ", "*", "pStack", ",", "void", " ", "*", "pElem", ")", "{\n    ", "int", " newSize;\n    ", "int", "* pt;\n    ", "char", "* pt2;\n    void *pTemp;\n    ", "if", "(", "Stack_Length(", "pStack", ")", ">=pStack->stackSize){\n        newSize=pStack->stackSize+STACK_INCREMENT;\n        pElem=realloc(pStack->pBase,newSize*sizeof(pStack->elementSize));\n        ", "if", "(pTemp==NULL){\n            return ERROR;\n        }\n        ", "else", "{\n            pStack->pBase=pTemp;\n            pStack->pTop = (", "char", "*)pStack->pBase+pStack->stackSize;\n            pStack->stackSize=newSize;\n        }\n    }\n    ", "if", "(pStack->elementSize", " == ", "sizeof(", "int", "))\n    {\n        pt = (", "int", "*)pStack->pTop;\n        *pt = *((", "int", "*)pElem);\n    }", "else", " \n    {\n        pt2 = (", "char", "*)pStack->pTop;\n        *pt2 = *((", "char", "*)pElem);\n    }\n    ", "//*(pStack->pTop)=*pElem;", "\n    #", "if", " DEBUG\n    printf(", "\"%d\"", ",pStack->pTop);    ", "/*调试语句*/", " \n    #endif\n    pStack->pTop=(", "char", "*)pStack->pTop+pStack->elementSize;\n    #", "if", " DEBUG\n    printf(", "\"%d\"", ",pStack->pTop);     ", "/*调试语句*/", " \n    #endif\n    return OK;\n}\n\nStatus ", "Stack_Pop(Stack ", "*", "pStack", ",", "void", " ", "*", "pElem", ")", "{\n    ", "if", "(pStack->pTop==pStack->pBase){\n        return ERROR;\n    }\n    ", "else", "{\n        pStack->pTop=(", "char", "*)pStack->pTop-pStack->elementSize; \n    ", "//    *pElem=*(pStack->pTop);", "\n        return OK;\n    }\n}\n\n", "/*Status Stack_Traverse(Stack *pStack,Status(*visit)()){\n    int i,j;\n    j=Stack_Length(pStack);\n    for(i=0;i<j;i++){\n        if(visit(&(pStack->pBase[i]))==ERROR){\n            return ERROR;\n        }\n    }\n    return OK;\n}*/", " \n\n", "float", " ", "ConvertToFloat(", "char", " ", "m", "[M])", "{\n    ", "int", " i=", "0", ";\n    ", "float", " value=", "0", ";\n    ", "while", "(m", "[", "i", "]", "!=", "'\\0'", "&&m", "[", "i", "]", "!=", "'.'", "){\n        value=value*", "10", "+(m", "[", "i", "]", "-", "'0'", ");\n        i=i+", "1", ";\n    }\n    ", "if", "(m", "[", "i", "]", "==", "'\\0'", "){\n        return value;\n    }\n    i=i+", "1", ";\n    ", "int", " weight=", "0.1", ";\n    ", "while", "(m", "[", "i", "]", "!=", "'\\0'", "){\n        value=value+(m", "[", "i", "]", "-", "'0'", ")*weight;\n        weight=weight/", "10", ";\n        i=i+", "1", ";\n    }\n    return value;\n}\n\n", "int", " ", "Judge(", "char", " ", "x", ")", "{\n    ", "if", " (x", " == ", "'('", ") {\n        return ", "4", ";\n    }\n    ", "else", " ", "if", " (x", " == ", "'+'", " || ", "x", " == ", "'-'", ") {\n        return ", "1", ";\n    }\n    ", "else", " ", "if", " (x", " == ", "'*'", " || ", "x", " == ", "'/'", ") {\n        return ", "2", ";\n    }\n    ", "else", " ", "if", " (x", " == ", "'^'", ") {\n        return ", "3", ";\n    }\n    ", "else", " ", "if", " (x", " == ", "')'", ") {\n        return ", "0", ";\n    }\n}\n\n", "int", " ", "Culculate(", "int", " ", "x1", ",", "int", " ", "x2", ",", "char", " ", "s", ")", "{\n    ", "int", " result = ", "0", ";\n    switch(s){\n        case ", "'+'", ":{\n            result=x1+x2;\n            break;\n        }\n        case ", "'-'", ":{\n            result=x1-x2;\n            break;\n        }\n        case ", "'*'", ":{\n            result=x1*x2;\n            break;\n        }\n        case ", "'/'", ":{\n            result=x1/x2;\n            break;\n        }\n        case ", "'^'", ":{\n            result=pow((double)x1,x2);\n            break;\n        }\n    }\n    return result;\n}\n\n\n\nStatus ", "Check(", "char", " ", "left", ",", "char", " ", "right", ")", "{\n    ", "if", "(left==", "'('", "&&right==", "')'", "){\n        return OK;\n    }\n    ", "else", "{\n        return ERROR;\n    }\n}\n\nStatus ", "CharIsSymbol(", "char", " ", "c", ")", "{\n    ", "if", "(c==", "'+'", "||", "c", "==", "'-'", "||", "c", "==", "'", "*", "'", "||", "c", "==", "'", "/", "'", "||", "c", "==", "'('", "||", "c", "==", "')'", "||", "c", "==", "'^'){\n        return ", "OK", ";\n    }\n    ", "else", "{\n        return ", "ERROR", ";\n    }\n}\n\n", "Status", " ", "CharIsNum(", "char", " ", "d", ")", "{\n    ", "if", "(d>='0'", "&&", "d<='9'){\n        return ", "OK", ";\n    }\n    ", "else", "{\n        return ", "ERROR", ";\n    }\n}\n\n", "int", " ", "DoSingleOperation(", "char", " ", "s", "[])", "{\n    ", "Stack", "*", " p", "IntStack", ";                               ", "/", "*", "这个栈存放数字", "*", "/", "\n    ", "Stack", "*", " p", "SymbolStack", ";                            ", "/", "*", "这个栈存放除括号外的符号", "*", "/", " \n    ", "Stack", "*", " p", "SymbolStack_2", ";                          ", "/", "*", "这个栈存放括号", "*", "/", "\n    ", "Status", " sta;\n    p", "IntStack", "=", "Stack_Construct(", "sizeof", "(", "int", ")", ");        \n    p", "SymbolStack", "=", "Stack_Construct(", "sizeof", "(", "char", ")", ");   \n    p", "SymbolStack_2", "=", "Stack_Construct(", "sizeof", "(", "char", ")", ");  \n    ", "int", " len,n;\n    len=strlen(s);\n    s[len]='#';\n    len", "++", ";\n    ", "int", " i;\n    ", "int", " a,b,c=0,d=0;\n    ", "int", " topele", "_int", ";\n    ", "char", " topele", "_c", ";\n    ", "char", " x[", "M", "];\n    ", "for", "(i=0;i<len;i", "++", "){\n        ", "if", "(s[i]", "==", "'('){\n            ", "Stack_Push(", "pSymbolStack_2", ",&", "s", "[", "i", "])", ";\n        }\n        ", "else", " ", "if", "(s[i]", "==", "')'){\n            ", "Stack_GetTop(", "pSymbolStack_2", ",&", "topele_c", ")", ";\n            ", "if", "(", "Check(", "topele_c", ",", "s", "[", "i", "])", "==", "1){\n                ", "Stack_Pop(", "pSymbolStack_2", ",&", "x", "[", "d", "++", "])", ";\n            }\n            ", "else", "{\n                printf(\"括号不匹配\\n\");                                 ", "/", "*", "判断括号是否匹配", "*", "/", " \n                return 0;\n            }\n        }\n    }\n    i=0;\n    ", "if", "(s[0]", "==", "'+'", "||", "s[0]", "==", "'-'", "||", "s[0]", "==", "'", "*", "'", "||", "s[0]", "==", "'", "/", "'", "||", "s[0]", "==", "'^'){\n        printf(\"运算符不能在开头\\n\");                                   ", "/", "*", "除括号外的运算符不能在字符串开始处", "*", "/", "\n        return 0; \n    }\n    ", "while", "(s[i]!='#'){\n        ", "int", " x=0;\n        ", "if", "(", "CharIsNum(", "s", "[", "i", "])", "==", "OK", "){\n            ", "while", "(s[i]>='0'", "&&", "s[i]<='9'){\n                x", "*", "=10;\n                x+=s[i", "++", "]-'0';\n            }\n            ", "Stack_Push(", "pIntStack", ",&", "x", ")", ";\n            continue;\n        }\n        ", "else", "{\n            ", "char", " theta=s[i];\n            ", "while", "(", "Stack_IsEmpty(", "pSymbolStack", ")", "==", "0 ){ ", "/", "/", "&&", "Stack_GetTop(", "pSymbolStack", ")", "!='('", "&&", "Judge(Stack_GetTop(", "pSymbolStack", ")", ")>=", "Judge(", "s", "[", "i", "])", "\n                ", "Stack_GetTop(", "pSymbolStack", ",&", "topele_c", ")", ";\n                ", "if", "(topele", "_c", " ", "==", "'(' ", "||", " ", "Judge(", "topele_c", ")", " < ", "Judge(", "s", "[", "i", "])", ")\n                    break;\n                ", "Stack_GetTop(", "pIntStack", ",&", "a", ")", ";\n                ", "Stack_Pop(", "pIntStack", ",&", "topele_int", ")", ";                     ", "/", "*", "这里的topele", "_int", "没有用处", "*", "/", " \n                ", "Stack_GetTop(", "pIntStack", ",&", "b", ")", ";\n                ", "Stack_Pop(", "pIntStack", ",&", "topele_int", ")", ";\n                ", "if", "(a", "==", "0", "&&", " topele", "_c", " ", "==", "'", "/", "'){ ", "/", "/", "Stack_GetTop(", "pSymbolStack", ")", "\n                    printf(\"除数不能为0\\n\");                         ", "/", "*", "判断除数是否为0，若为0则结束程序，否则继续运行", "*", "/", " \n                    return 0; \n                }\n                c=", "Culculate(", "b", ",", "a", ",", "topele_c", ")", ";", "/", "/", "Stack_GetTop(", "pSymbolStack", ")", "\n                ", "Stack_Push(", "pIntStack", ",&", "c", ")", ";\n                ", "Stack_Pop(", "pSymbolStack", ",&", "topele_c", ")", ";\n            }\n            sta = ", "Stack_GetTop(", "pSymbolStack", ",&", "topele_c", ")", ";\n            ", "if", "(sta", "==", " ", "OK", " ", "&&", "Judge(", "theta", ")", "==", "0", "&&", "Judge(", "topele_c", ")", "==", "4){\n                ", "Stack_Pop(", "pSymbolStack", ",&", "topele_c", ")", ";\n            }\n            ", "if", "(", "Judge(", "theta", ")", "!=0){\n                ", "Stack_Push(", "pSymbolStack", ",&", "theta", ")", ";\n            }\n            i", "++", ";\n        }\n    }\n    ", "while", "(", "Stack_IsEmpty(", "pSymbolStack", ")", "==", "0){\n        ", "Stack_GetTop(", "pSymbolStack", ",&", "topele_c", ")", ";\n        ", "Stack_GetTop(", "pIntStack", ",&", "a", ")", ";\n        ", "Stack_Pop(", "pIntStack", ",&", "topele_int", ")", ";\n        ", "Stack_GetTop(", "pIntStack", ",&", "b", ")", ";\n        ", "Stack_Pop(", "pIntStack", ",&", "topele_int", ")", ";\n        ", "if", "(a", "==", "0", "&&", " topele", "_c", "==", "'", "/", "'){\n            printf(\"除数不能为0\\n\");                                ", "/", "*", "判断除数是否为0，若为0则结束程序，否则继续运行", "*", "/", " \n            return 0;\n        }\n        c=", "Culculate(", "b", ",", "a", ",", "topele_c", ")", ";", "/", "/", "Stack_GetTop(", "pSymbolStack", ")", "\n        ", "Stack_Push(", "pIntStack", ",&", "c", ")", ";\n        ", "Stack_Pop(", "pSymbolStack", ",&", "topele_c", ")", ";\n    }\n    ", "Stack_GetTop(", "pIntStack", ",&", "a", ")", ";\n    printf(\"%d\\n\",a);\n    return a;\n}\n\n", "/", "/", "int", " main(){\n", "/", "/", "    ", "char", " all[100]={0};\n", "/", "/", "    ", "int", " result=0;\n", "/", "/", "    ", "FILE", " ", "*", "fp=fopen(\"", "C", ":", "/", "Users", "/", "zh", "/", "Desktop", "/", "1.txt\",\"r\");            ", "/", "*", "以只读模式打开文件1", "*", "/", " \n", "/", "/", "    ", "if", "(fp", "==", "0){\n", "/", "/", "        printf(\"", "The", " first txt can not be opened!\");             ", "/", "*", "若打开文件1失败，结束程序，否则继续运行", "*", "/", " \n", "/", "/", "        return 0;\n", "/", "/", "    }\n", "/", "/", "    ", "FILE", " ", "*", "fp2=fopen(\"", "C", ":", "/", "Users", "/", "zh", "/", "Desktop", "/", "2.txt\",\"w\");           ", "/", "*", "以写入模式打开文件2", "*", "/", " \n", "/", "/", "    ", "while", "(!feof(fp)){\n", "/", "/", "        fgets(all,100,fp);                                      ", "/", "*", "对文件1逐行读取", "*", "/", " \n", "/", "/", "        ", "int", " len=strlen(all);\n", "/", "/", "        ", "if", "(len", "==", "0){                                             ", "/", "*", "若为空行，则结束此次循环，开始执行下一行的程序", "*", "/", " \n", "/", "/", "            continue;          \n", "/", "/", "        }\n", "/", "/", "        ", "if", "(all[len-1]", "==", "'\\n'){\n", "/", "/", "            all[len-1]='\\0';\n", "/", "/", "        }\n", "/", "/", "        printf(\"%s\\n\",all);\n", "/", "/", "        result=", "DoSingleOperation(", "all", ")", ";                          ", "/", "*", "对读入的一行进行运算", "*", "/", " \n", "/", "/", "        fprintf(fp2,\"%d\\n\",result);                             ", "/", "*", "对读入的一行的运算结果打印到文件2中", "*", "/", " \n", "/", "/", "    }\n", "/", "/", "    fclose(fp);                                                 ", "/", "*", "关闭文件1", "*", "/", " \n", "/", "/", "    fclose(fp2);                                                ", "/", "*", "关闭文件2", "*", "/", " \n", "/", "/", "    return 0;\n", "/", "/", "}\n\n\n", "int", " main(){\n    ", "int", " i;\n    printf(\"", "Please", " choose the mode ", "of", " operation\\n", "From", " file ", "to", " file:0\\t", "From", " the keyboard:1\\n\");\n    scanf(\"%d\",&i);\n    switch(i){\n        case 0:{\n            ", "char", " all[", "M", "]={0};\n            ", "int", " result=0;\n            ", "FILE", " ", "*", "fp=fopen(\"", "C", ":", "/", "Users", "/", "zh", "/", "Desktop", "/", "1.txt\",\"r\");            ", "/", "*", "以只读模式打开文件1", "*", "/", " \n            ", "if", "(fp", "==", "0){\n                printf(\"", "The", " first txt can not be opened!\");             ", "/", "*", "若打开文件1失败，结束程序，否则继续运行", "*", "/", " \n                return 0;\n            }\n            ", "FILE", " ", "*", "fp2=fopen(\"", "C", ":", "/", "Users", "/", "zh", "/", "Desktop", "/", "2.txt\",\"w\");           ", "/", "*", "以写入模式打开文件2", "*", "/", " \n            ", "while", "(!feof(fp)){\n                fgets(all,", "M", ",fp);                                      ", "/", "*", "对文件1逐行读取，直到文件尾", "*", "/", " \n                ", "int", " len=strlen(all);\n                ", "if", "(len", "==", "0){                                             ", "/", "*", "若为空行，则结束此次循环，开始执行下一行的程序", "*", "/", " \n                    continue;          \n                }\n                ", "if", "(all[len-1]", "==", "'\\n'){                                   \n                    all[len-1]='\\0';                                    ", "/", "*", "去掉每行字符的回车符", "*", "/", "\n                }\n                printf(\"%s\\n\",all);\n                result=", "DoSingleOperation(", "all", ")", ";                          ", "/", "*", "对读入的一行进行运算", "*", "/", " \n                fprintf(fp2,\"%d\\n\",result);                             ", "/", "*", "对读入的一行的运算结果打印到文件2中", "*", "/", " \n            }\n            fclose(fp);                                                 ", "/", "*", "关闭文件1", "*", "/", " \n            fclose(fp2);                                                ", "/", "*", "关闭文件2", "*", "/", " \n            break;\n        }\n        case 1:{\n            printf(\"", "Please", " input the exxpression\\n\");\n            ", "int", " j=0,result;\n            ", "char", " all[", "M", "]={0};\n            ", "char", " y;\n            gets(all);\n            ", "/", "*", "while", "((y=getchar())!='\\n'){\n                all[j]=y;\n                j", "++", ";\n            }", "*", "/", "\n            result=", "DoSingleOperation(", "all", ")", ";\n            printf(\"%d\\n\",result);\n            break;\n        }\n        default:{\n            printf(\"error number\\n\");\n            break;\n        }\n    }\n    return 0;\n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;    //定义一个新的堆栈S&lt;br /&gt;\n    Stack *S&amp;#61;NULL;&lt;br /&gt;\n    //创建一个能容纳10个单元的空堆栈&lt;br /&gt;\n    Create(S,10);&lt;br /&gt;\n使用create()函数是对s进行赋值&amp;#xff0c;而不是改变指向。所以这两句代码相当于直接对(Stack *)0进行赋值&amp;#xff0c;这个是不被允许的。可以改成Stack *s &amp;#61; (Stack *)malloc(sizeof(Stack));或者Stack s; Create(&amp;amp;s,10);&lt;br /&gt;\n &lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["数据结构 堆栈 C语言", ["在学数据结构，参考课本写了一段关于堆栈的代码，总是有bug，好像是野指针空指针问题？有没有大佬帮忙看看？", "\n\n", "#include<stdio.h>", "\n#include<stdlib.h>", "\n#include<malloc.h>", "\n//堆栈里元素的数据类型定义为整型", "\ntypedef int ElemType;", "\n//堆栈的结构体定义", "\ntypedef struct stack{", "\n//当前栈顶元素下标", "\nint top;", "\n//堆栈的“最大尺寸”，因为下标是从0开始，最大栈顶位置下标其实是maxSize-1", "\nint maxSize;", "\nElemType *element;", "\n}Stack;", "\n\n", "\n//创建一个能容纳mSize个单元的空堆栈", "\nvoid Create(Stack *S,int mSize){", "\n//能容纳mSize个单元", "\nS->maxSize=mSize;", "\n//生成大小为sizeof(ElemType)*mSize的动态数组空间", "\nS->element=(ElemType*)malloc(sizeof(ElemType)*mSize);", "\n//当前栈顶元素下标是-1，说明是空栈", "\nS->top=-1;", "\n}", "\n//销毁堆栈", "\nvoid Destory(Stack *S){", "\n//最大栈顶位置下标清零", "\nS->maxSize=0;", "\n//释放空间", "\nfree(S->element);", "\n//当前栈顶元素下标变回-1", "\nS->top=-1;", "\n//加一个输出语句表示完事了", "\nprintf(\"堆栈已销毁\\n\");", "\n}", "\n//判断是否为空栈", "\nvoid IsEmpty(Stack *S){", "\n    //前面说过，当前栈顶元素下标为-1就是空栈的意思", "\n    if(S->top==-1){", "\n        printf(\"是空栈\\n\");", "\n    }else{", "\n        printf(\"不是空栈\\n\");", "\n    }", "\n}", "\n//判断堆栈是否已满", "\nvoid IsFull(Stack *S){", "\n    //如果当前栈顶元素的下标等于最大栈顶位置下标，就说明堆栈满了", "\n    if(S->top==S->maxSize-1){", "\n        printf(\"堆栈已满\\n\");", "\n    }else{", "\n    printf(\"堆栈未满\\n\");", "\n    }", "\n}", "\n//获取栈顶元素", "\nvoid Top(Stack *S){", "\n    //如果堆栈为空，则认为是Error", "\n    if(S->top==-1){", "\n        printf(\"无法获取栈顶元素，因为堆栈为空\\n\");", "\n    }else{", "\n        //如果堆栈不为空，通过*x返回下标为S的栈顶位置下标（S->top）的元素", "\n        ElemType *x;", "\n    *x=S->element[S->top];", "\n    printf(\"栈顶元素是%d\\n\",*x);", "\n    }", "\n}", "\n//实现元素x的入栈操作", "\nvoid Push(Stack *S,ElemType x){", "\n    //如果堆栈已经满了，就无法插入了(否则会溢出）", "\n    if(S->top==S->maxSize-1){", "\n        printf(\"堆栈已满，无法执行入栈操作\\n\");", "\n        //如果堆栈未满，就先把当前栈顶元素下标+1，相当于往上多堆了一层，再把x放到这一层", "\n    }else{", "\n        //往上堆一层", "\n        S->top++;", "\n        //把x放进去", "\n        S->element[S->top]=x;", "\n    }", "\n}", "\n//实现出栈操作", "\nvoid Pop(Stack *S){", "\n    //如果堆栈为空，就无法删除了", "\n    if(S->top==-1){", "\n        printf(\"堆栈为空，无法执行出栈操作\\n\");", "\n        //如果堆栈不为空，就把当前栈顶元素下标-1，这一层自动就没了", "\n        //顺序栈只能从顶上往下一个一个删除，不能从中间删除", "\n    }else{", "\n        S->top--;", "\n    }", "\n}", "\n//清除堆栈中全部元素，但并不释放空间", "\nvoid Clear(Stack *S){", "\n    //可以看到，并没有free的操作，空间不会被释放", "\n    S->top=-1;", "\n    //加一个输出语句表示完事了", "\n    printf(\"释放完毕\\n\");", "\n}", "\n//输出堆栈中的元素", "\nvoid Output(Stack *S){", "\n    for(int i=0;i<=S->top;i++){", "\n        printf(\"%d\\n\",S->element[i]);", "\n    }", "\n}", "\n//主函数", "\nint main(){", "\n    //定义一个新的堆栈S", "\n    Stack *S=NULL;", "\n    //创建一个能容纳10个单元的空堆栈", "\n    Create(S,10);", "\n    //判断它是否为空，显然，它是空的", "\n    IsEmpty(S);", "\n    //删除栈顶元素，显然此时无法删除", "\n    Pop(S);", "\n    //让0~9入栈", "\n    for(int i=0;i<10;i++){", "\n        Push(S,i);", "\n    }", "\n    //输出堆栈元素", "\n    Output(S);", "\n    //判断它是否是满的，显然，它满了", "\n    IsFull(S);", "\n    //让10入栈，显然做不到", "\n    Push(S,10);", "\n    //删除栈顶元素", "\n    Pop(S);", "\n    //再输出一次，这时候9应该没了", "\n    Output(S);", "\n    //再次判断它是不是满的，这次不是满的了", "\n    IsFull(S);", "\n    //清空堆栈", "\n    Clear(S);", "\n    //销毁堆栈", "\n    Destory(S);", "\n    //防止闪退", "\n    getchar();", "\n    getchar();", "\n    getchar();", "\n    getchar();", "\n    return 0;", "\n}", "\n "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你插入的时候把头指针移动了&amp;#xff0c;不能移动head&amp;#xff0c;head永远要指向头部&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\nvoid inputstudent(STU stu&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt;)\n{\n    NODE* newnode &amp;#61; (NODE*)malloc(sizeof(NODE)); &lt;span class=\"hljs-comment\"&gt;//创建一个新结点来作头结点&amp;#xff0c;使newnode这个指针可以通过-&amp;gt;来当作结构体变量来用&lt;/span&gt;\n    newnode-&amp;gt;next &amp;#61; NULL;\n    NODE* mov &amp;#61; head;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)   &lt;span class=\"hljs-comment\"&gt;//遍历&lt;/span&gt;\n    {\n        head &amp;#61; newnode;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(mov-&amp;gt;next !&amp;#61; NULL)\n        {\n            mov &amp;#61; mov-&amp;gt;next;\n        }\n        mov-&amp;gt;next &amp;#61; newnode;\n        \n    }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%ld&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-params\"&gt;newnode&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;stuID&lt;/span&gt;)&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;newnode&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;stuname&lt;/span&gt;, 10)&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;性别&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34; %c&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-params\"&gt;newnode&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;stusex&lt;/span&gt;, 1)&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;成绩&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-string\"&gt;&amp;#34; %d&amp;#34;&lt;/span&gt;, &amp;amp;&lt;span class=\"hljs-params\"&gt;newnode&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-params\"&gt;stu&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;score&lt;/span&gt;)&lt;/span&gt;;\n} \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["关于文件打印的问题，如何解决？", ["#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<conio.h>", "\n", "#", "include", " ", "<string.h>", "\n", "typedef", " ", "struct", " ", "stu", "\n{\n    ", "long", " stuID;     ", "//学号", "\n    ", "char", " stuname[", "10", "];    ", "//名字", "\n    ", "char", " stusex;     ", "//性别", "\n    ", "int", " score;    ", "//分数", "\n}STU;\n", "typedef", " ", "struct", " ", "node", "   ", "//创建结点类型", "\n{\n    STU stu;                ", "//数据域", "\n    ", "struct", " ", "node", "* next;   ", "//指向下一个节点的指针", "\n}NODE;\nNODE* head = ", "NULL", ";  ", "//定义头指针", "\n\n", "NODE* ", "creatlist", "()", ";\n\n", "void", " ", "start", "()", ";\n", "void", " ", "inputstudent", "(STU stu[])", ";\n", "void", " ", "savestudent", "()", ";\n", "void", " ", "readstudent", "()", ";\n", "void", " ", "printfstudent", "()", ";\n\n\n", "#", "define", " N 30", "\n", "int", " ", "main", "()", "\n", "{\n    NODE* list = ", "creatlist", "();\n    STU stu[N];\n    ", "int", " m = ", "4", ";\n    ", "while", " (", "1", ")\n    {\n        ", "start", "();\n        ", "char", " ch = _getch();\n        ", "switch", " (ch)\n        {\n        ", "case", " ", "'1'", ":  ", "//录入学生信息", "\n            ", "inputstudent", "(stu);\n            ", "break", ";\n        ", "case", " ", "'2'", ":  ", "//保存学生信息", "\n            ", "savestudent", "();\n            ", "break", ";\n        ", "case", " ", "'3'", ":", "//读取学生信息", "\n            ", "readstudent", "();\n            ", "break", ";\n        ", "case", " ", "'4'", ":  ", "//打印学生成绩", "\n            ", "printfstudent", "();\n            ", "break", ";\n        ", "case", " ", "'5'", ":  ", "//按总分由高到低排出名次", "\n            ", "break", ";\n        ", "case", " ", "'6'", ":  ", "//按总分由低到高排出名次", "\n            ", "break", ";\n        ", "case", " ", "'7'", ":  ", "//按学号由小到大排出成绩表", "\n            ", "break", ";\n        ", "case", " ", "'8'", ":  ", "//按姓名字典顺序排序排出成绩表", "\n            ", "break", ";\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n\n", "void", " ", "start", "()", "\n", "{\n    ", "printf", "(", "\"*****************************************\\n\"", ");\n    ", "printf", "(", "\"欢迎使用学生成绩管理系统        *\\n\"", ");\n    ", "printf", "(", "\"*1.录入学生信息                *\\n\"", ");\n    ", "printf", "(", "\"*2.保存学生信息                *\\n\"", ");\n    ", "printf", "(", "\"*3.读取学生信息                *\\n\"", ");\n    ", "printf", "(", "\"*4.打印学生信息                *\\n\"", ");\n    ", "printf", "(", "\"*5.按总分由高到低排出名次        *\\n\"", ");\n    ", "printf", "(", "\"*6.按总分由低到高排出名次        *\\n\"", ");\n    ", "printf", "(", "\"*7.按学号由小到大排出成绩表        *\\n\"", ");\n    ", "printf", "(", "\"*8.按姓名字典顺序排序排出成绩表        *\\n\"", ");\n    ", "printf", "(", "\"*9.根据学号查询学生成绩及排名        *\\n\"", ");\n    ", "printf", "(", "\"*0.根据姓名查询学生成绩及排名        *\\n\"", ");\n    ", "printf", "(", "\"*****************************************\\n\"", ");\n}\n\n", "NODE* ", "creatlist", "()", "    ", "//创建表头表示整个链表即创建链表（表头可以是头结点，也可以是数据结点，通常是头结点）", "\n", "{\n    NODE* headNode = (NODE*)", "malloc", "(", "sizeof", "(NODE));\n    headNode->next = ", "NULL", ";\n    ", "return", " headNode;\n}\n\n\n", "void", " ", "inputstudent", "(STU stu[])", "\n", "{\n    NODE* newnode = (NODE*)", "malloc", "(", "sizeof", "(NODE)); ", "//创建一个新结点来作头结点，使newnode这个指针可以通过->来当作结构体变量来用", "\n    newnode->next = ", "NULL", ";\n    ", "if", " (head == ", "NULL", ")   ", "//遍历", "\n    {\n        head = newnode;\n    }\n    ", "else", "\n    {\n        newnode->next = head;\n        head = newnode; ", "//newnode = head;  修改", "\n    }\n        ", "printf", "(", "\"学号：\"", ");\n        ", "scanf_s", "(", "\"%ld\"", ", &newnode->stu.stuID);\n        ", "printf", "(", "\"姓名：\"", ");\n        ", "scanf_s", "(", "\"%s\"", ", newnode->stu.stuname, ", "10", "); ", "//修改", "\n        ", "printf", "(", "\"性别：\"", ");\n        ", "scanf_s", "(", "\" %c\"", ", &newnode->stu.stusex, ", "1", ");  ", "//修改", "\n        ", "printf", "(", "\"成绩：\"", ");\n        ", "scanf_s", "(", "\" %d\"", ", &newnode->stu.score);\n} \n\n", "void", " ", "savestudent", "()", "    ", "//保存学生信息", "\n", "{\n    FILE* pf = ", "fopen", "(", "\"pph.txt\"", ", ", "\"w\"", "); ", "//创建并打开文件", "\n    ", "if", " (pf == ", "NULL", ") ", "//判断打开文件是否失败", "\n    {\n        ", "printf", "(", "\"打开文件失败\\n\"", ");\n        ", "return", ";\n    }\n    NODE* p = head;\n    ", "while", " (p != ", "NULL", ")\n    {\n        ", "fwrite", "(&p->stu, ", "1", ", ", "sizeof", "(STU), pf);\n        p = p->next;\n    }\n    ", "fclose", "(pf);\n    ", "printf", "(", "\"数据保存成功\\n\"", ");\n}\n\n\n", "void", " ", "readstudent", "()", "   ", "//读取学生信息", "\n", "{\n    FILE* pf = ", "fopen", "(", "\"pph.txt\"", ", ", "\"r\"", ");  ", "//打开文件", "\n    ", "if", " (pf == ", "NULL", ") ", "//判断打开文件是否失败", "\n    {\n        ", "printf", "(", "\"err!\\n\"", ");\n        ", "return", ";\n    }\n    ", "while", " (!", "feof", "(pf))\n    {\n        NODE* newnode = (NODE*)", "malloc", "(", "sizeof", "(NODE));\n        ", "fread", "(&newnode->stu, ", "1", ", ", "sizeof", "(STU), pf);\n        newnode->next = ", "NULL", ";\n        ", "//头插法", "\n        ", "if", " (head == ", "NULL", ")\n        {\n            head = newnode;\n        }\n        ", "else", "\n        {\n            newnode->next = head;\n            head = newnode;\n        }\n    }\n    ", "printf", "(", "\"加载数据成功\\n\"", ");\n    ", "fclose", "(pf);\n}\n", "void", " ", "printfstudent", "()", "\n", "{\n    NODE* P = head;\n    ", "while", " (P!=", "NULL", ")\n    {\n        ", "printf", "(", "\"%ld %s %c %d\"", ", P->stu.stuID, P->stu.stuname, P->stu.stusex, P->stu.score);\n        P = P->next;\n    }\n    ", "system", "(", "\"pause\"", ");\n}\n", "\n", "\n", "读取完数据后，打印的前面有有一段乱码，后面的123 张三 m 99才是我录入的内容，如何解决？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;G在main里没定义&amp;#xff0c;得先定义出该变量的类型&amp;#xff0c;再使用&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["在调用函数时参数不知道哪个有问题，希望能解决。", ["由于转专业的原因，c语言基础课程没学过，所以有些代码不了解，希望能讲解一下。", "##问题描述## 就是有个错误，但不知道怎么修改，下面有图。", "/", "代码如下", "/", "\n", "/*图结构算法管理系统*/", "\n#include  ", "\"stdio.h\"", "\n#include  ", "\"malloc.h\"", "\n#define MAX ", "100", "                ", "/*最大顶点数*/", "\ntypedef struct \n{  int n,e;               ", "/*n为顶点数，e为边数*/", "\n   char vexs[MAX];            ", "/*顶点数组*/", "\n   int edges[MAX][MAX];        ", "/*邻接矩阵*/", "\n}MGraph;\n\nvoid  CreateMGraph(MGraph *G)\n{   ", "/*图的邻接矩阵建立函数*/", "\n    int i,j,k;\n    char  ch1,ch2;\n    printf(", "\"请输入顶点数：\"", ");\n    ", "scanf", "(\"%d\",&G->", "n);\n    printf(", "\"请输入边数：\"", ");\n    ", "scanf", "(\"%d\",&G->", "e);\n    printf(", "\"请输入各顶点信息（每个顶点以回车作为结束）：\\n\"", ");\n    ", "for", "(i=0;i<G->", "n;i++)\n    {   \n        getchar();   \n        printf(", "\"输入第%d个顶点：\"", ",i+", "1", ");\n        ", "scanf", "(\"%c\",&(G->", "vexs[i]));\n    }\n    ", "for", "(i=0;i<G->", "n;i++)                 \n       ", "for", "(j=0;j<G->", "n;j++)\n           G->edges[i][j]=", "0", ";          ", "/*初始化邻接矩阵元素*/", "         \n    ", "for", "(k=1;k<=G->", "e;k++)\n    {  \n       getchar();\n       printf(", "\"建立第%d条边(输入格式：顶点1,顶点2)：\"", ",k);\n       scanf(", "\"%c,%c\"", ",&ch1,&ch2);        \n       ", "for", "(i=0;i<G->", "n;i++)\n          ", "for", "(j=0;j<G->", "n;j++)\n          ", "if", "(ch1==G->", "vexs", "[i] && ch2==G->", "vexs[j])\n            { G->edges[i][j]=", "1", ";\n              G->edges[j][i]=", "1", ";     ", "/*去掉为有向邻接矩阵*/", "  \n            }\n    }  \n}\n\nvoid  DispMGraph(MGraph G)\n{  ", "/*图的邻接矩阵输出函数*/", "\n   int i,j;\n   printf(", "\"\\n图的邻接矩阵：\\n\"", ");\n   printf(", "\"1-输出图的元素：\"", ");\n   ", "for", "(i=", "0", ";i<G.n;i++)\n       printf(", "\"%c  \"", ",G.vexs[i]);\n   printf(", "\"\\n2-输出图的关系：\\n\"", ");\n   ", "for", "(i=", "0", ";i<G.n;i++)\n   {   ", "for", "(j=", "0", ";j<G.n;j++)\n          printf(", "\"%5d\"", ",G.edges[i][j]);\n       printf(", "\"\\n\"", ");\n   }\n}      \n\ntypedef char VertexType;\nint visited[MAX];              ", "/*全局变量，访问数组*/", "\n \ntypedef struct node            \n{\n   int adjvex;                 ", "/*邻接点域*/", "\n   struct node *next;          ", "/*指向下一邻接点的指针域*/", "\n}EdgeNode;                     ", "/*定义边表结点*/", "\n\ntypedef struct vexnode         \n{\n   VertexType ", "data", ";            ", "/*顶点域*/", "\n   EdgeNode *firstedge;        ", "/*指向第一条边结点*/", "\n}VHeadNode;                    ", "/*定义顶点表结点*/", "\n\ntypedef struct\n{\n   VHeadNode adjlist[MAX];     ", "/*邻接表头结点数组*/", "\n   int n,e;                    ", "/*顶点数，边数*/", "\n}AdjList;                      ", "/*图的邻接表类型*/", "\n\nvoid  CreateAGraph(AdjList *g,int flag)           \n{  ", "/*生成无向图的邻接表函数*/", "\n   int  i,j,k;\n   EdgeNode  *p;\n   ", "if", "(flag==", "0", ")\n      printf(", "\"\\n===========将建立一个无向图===========\\n\"", ");\n   ", "else", " \n      printf(", "\"\\n===========将建立一个有向图===========\\n\"", ");\n   printf(", "\"请输入图的顶点数：\"", ");\n   ", "scanf", "(\"%d\",&g->", "n);\n   printf(", "\"请输入图的边数：\"", ");\n   ", "scanf", "(\"%d\",&g->", "e);\n   printf(", "\"\\n请输入图的各顶点信息：\\n\"", ");\n   ", "for", "(i=0;i<g->", "n;i++)                    ", "/*生成有n个顶点的顶点表*/", "\n   {  ", "//getchar();                        /*接受上次输入的换行符*/", "\n      printf(", "\"第%d个顶点信息：\"", ",i+", "1", ");\n      ", "scanf", "(\"\\n%c\",&(g->", "adjlist[i].", "data", "));   ", "/*读入顶点信息*/", "\n      ", "g", "->", "adjlist[i].firstedge=NULL;       ", "/*点的边表头指针设为空*/", "\n   }\n   printf(", "\"\\n请输入边的信息，输入格式为:序号1，序号2（序号依次为0、1、2...）：\\n\"", ");\n   ", "for", "(k=0;k<g->", "e;k++)\n   {\n         printf(", "\"请输入第%d条边：\"", ",k);\n         scanf(", "\"\\n%d,%d\"", ",&i,&j);\n         ", "/*将编号为i的结点添加到邻接表中*/", "         \n         p=(EdgeNode *)malloc(sizeof(EdgeNode)); \n         ", "p", "->", "adjvex=j;\n         ", "p", "->", "next", "=g->", "adjlist[i].firstedge;\n         ", "g", "->", "adjlist[i].firstedge=p;\n         ", "/*将编号为j的结点添加到邻接表中，有向图不用添加该结点，去掉下面if语句*/", "\n         ", "if", "(flag==", "0", ")   \n         {    \n              p=(EdgeNode *)malloc(sizeof(EdgeNode)); \n            ", "p", "->", "adjvex=i;                          ", "/*邻接点序号为i*/", "\n            ", "p", "->", "next", "=g->", "adjlist[j].firstedge;      ", "/*将新结点p插到顶点vi边表头*/", "\n            ", "g", "->", "adjlist[j].firstedge=p;\n          }\n   }\n}\n\nvoid DispAGraph(AdjList *g)                \n{ ", "/*输出图的邻接表函数*/", "\n  int i;\n  EdgeNode *p;\n  printf(", "\"\\n图的邻接表表示如下：\\n\"", ");\n  ", "for", "(i=0;i<g->", "n;i++)\n  {\n     ", "printf", "(\"%2d [%c]\",i,g->", "adjlist[i].", "data", ");\n     ", "p", "=g->", "adjlist[i].firstedge;\n     ", "while", "(p!=NULL)\n     {\n        ", "printf", "(\"-->", "[%", "d", "]\",p->", "adjvex);\n        ", "p", "=p->", "next;\n     }\n     printf(", "\"\\n\"", ");\n  }\n}\n\nvoid DFS(AdjList *g,int vi)          \n{ ", "/*用邻接表存储的图以顶点vi开始深度优先遍历函数*/", "\n  EdgeNode *p;\n  printf(", "\"(%d,\"", ",vi);\n  ", "printf", "(\"%c)\",g->", "adjlist[vi].", "data", ");\n  visited[vi]=", "1", ";\n  ", "p", "=g->", "adjlist[vi].firstedge;  \n  ", "while", "(p!=NULL)\n   {\n     ", "if", "(visited[p->", "adjvex]==", "0", ")\n          DFS(", "g", ",p->", "adjvex);\n     ", "p", "=p->", "next;\n   }\n}\n\nvoid BFS(AdjList *g,int vi)          \n{ ", "/*用邻接表存储的图以顶点vi开始广度优先遍历函数*/", "\n  int i,v,visited[MAX];\n  int qu[MAX],front=", "0", ",rear=", "0", ";        ", "/*定义循环队列*/", "\n  EdgeNode *p;\n  ", "for", "(i=0;i<g->", "n;i++)                ", "/*辅助的访问数组赋初值*/", "\n      visited[i]=", "0", ";\n  printf(", "\"(%d,\"", ",vi);                 ", "/*输出起始访问顶点*/", "\n  ", "printf", "(\"%c)\",g->", "adjlist[vi].", "data", ");\n  visited[vi]=", "1", ";\n  rear=(rear+", "1", ")%MAX;                 ", "/*队尾指针后移*/", "\n  qu[rear]=vi;                       ", "/*将vi入队*/", "\n  ", "while", " (front!=rear)                ", "/*当队不空时*/", "\n  {  front=(front+", "1", ")%MAX;\n     v=qu[front];                    ", "/*将队头元素出队，赋给顶点v*/", "\n     ", "p", "=g->", "adjlist[v].firstedge;      ", "/*将顶点v的下一条邻接边顶点指针赋给p*/", "\n     ", "while", "(p!=NULL)\n     {   ", "if", "(visited[p->", "adjvex]==", "0", ")    ", "/*若未访问过*/", "\n         {   ", "visited", "[p->", "adjvex]=", "1", ";    ", "/*访问数组该元素置1，已访问*/", "\n             ", "printf", "(\"(%d,\",p->", "adjvex);", "/*输出该顶点编号*/", "\n             ", "printf", "(\"%c)\",g->", "adjlist", "[p->", "adjvex].", "data", ");  ", "/*输出该顶点信息*/", "\n            \n             rear=(rear+", "1", ")%MAX;       ", "/*队尾指针后移*/", "\n             ", "qu", "[rear]=p->", "adjvex;      ", "/*将p所指的顶点入队*/", "\n         }\n         ", "p", "=p->", "next;                   ", "/*p指针后移*/", "\n      }\n   }\n} \n\nvoid  MenuGraph()                                     ", "/*显示菜单子函数*/", "\n{   printf(", "\"\\n                    图子系统\"", ");\n    printf(", "\"\\n==================================================\"", ");\n    printf(", "\"\\n|               1——建立与输出邻接矩阵                |\"", ");  \n    printf(", "\"\\n|               2——建立与输出邻接表                  |\"", ");\n    printf(", "\"\\n|               3——深度优先遍历                |\"", ");\n    printf(", "\"\\n|               4——广度优先遍历                |\"", ");    \n    printf(", "\"\\n|               0——返回                        |\"", ");\n    printf(", "\"\\n==================================================\"", "); \n    printf(", "\"\\n请输入菜单号（0-3）:\"", ");     \n}\n\nmain()                           ", "/*主函数*/", "\n{   \n    int  i,f;   \n    char  ch1,ch2,a;\n    AdjList  g;\n    ch1=", "'y'", ";\n   ", "while", "(ch1==", "'y'", "||ch1==", "'Y'", ") \n   {  MenuGraph();\n      scanf(", "\"%c\"", ",&ch2);\n         getchar();\n         switch(ch2)\n         {\n            case  ", "'1'", ":              \n             printf(", "\"要建立的是有向图（1）还是无向图（0），请选择（输入1或0）：\"", ");\n             scanf(", "\"%d\"", ",&f);\n             CreateMGraph(&G,f);\n             DispMGraph(&G);\n             break;\n         case  ", "'2'", ":              \n             printf(", "\"要建立的是有向图（1）还是无向图（0），请选择（输入1或0）：\"", ");\n             scanf(", "\"%d\"", ",&f);\n             CreateAGraph(&g,f);\n             DispAGraph(&g);\n             break;\n         case  ", "'3'", ":\n             printf(", "\"请输入开始进行深度遍历的顶点序号（序号从0开始编号）：\"", ");\n             scanf(", "\"%d\"", ",&f);\n             printf(", "\"\\n从顶点%d开始的深度优先遍历序列为：\"", ",f);\n             ", "for", "(i=", "0", ";i<g.n;i++)\n                 visited[i]=", "0", ";\n             DFS(&g,f); \n             break;\n         case  ", "'4'", ":\n              printf(", "\"请输入开始进行广度遍历的顶点序号（序号从0开始）：\"", ");\n             scanf(", "\"%d\"", ",&i);\n             printf(", "\"\\n从顶点%d开始的广度优先遍历序列为：\"", ",i);\n             BFS(&g,i); \n             break;\n         case  ", "'0'", ":\n             ch1=", "'n'", ";break;\n         default:\n             printf(", "\"输入有误，请输入0-3进行选择！\"", ");\n       }\n       ", "if", "(ch2!=", "'0'", ")\n       {   printf(", "\"\\n按回车键继续，按任意键返回主菜单！\\n\"", ");\n             a=getchar();\n             ", "if", "(a!=", "'\\xA'", ")\n             {\n                   getchar();ch1=", "'n'", ";\n             }\n       }\n  }\n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;瑕疵是啥&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["有点小瑕疵，但不知道问题出在哪里", ["学生信息管理程序(难度：中)1.功能要求1)添加学生信息：输入学生信息并予以保存。学生信息包括学号、姓名、年龄，性别出生年月、电话号码。若输入信息中的学号已经存在，则不允许添加该信息。(2)查询学生信息：根据输入的学号或姓名查询学生信息。若输入的内容为空，则查询出所有的学生信息。若查询出多条信息，则将这些信息按学号由小到大排序后再显示出来。(3)删除学生信息：根据输入的学号删除相应的学生信息。(4)修改学生信息：用输入的学生信息替换学号与之相同的已有学生信息。2.编程要求(1)学生信息定义为结构体类型。(2)学生信息存放在文件中。(3)以菜单方式让用户选择要执行的功能，用户输入一个数字，便可执行某项功", "能", "\n", "#define _CRT_SECURE_NO_WARNINGS ", "1", "\n#include", "<", "stdio.h", ">", " ", "/*I/O函数*/", "\n#include", "<", "stdlib.h", ">", " ", "/*其它说明*/", "\n#include", "<", "string.h", ">", " ", "/*字符串函数*/", "\n\n#define ", "LEN", " ", "15", "  ", "/* 学号和姓名最大字符数,实际请更改*/", "\n#define ", "N", " ", "50", "  ", "/* 最大学生人数,实际请更改*/", "\n\nint k ", "=", " ", "1", ", n ", "=", " ", "0", ", m ", "=", " ", "0", ";", "/* n代表当前记录的学生人数*/", "\n", "FILE", " ", "*", "fp;\n", "//函数声明", "\nvoid seek();\nvoid modify();\nvoid insert();\nvoid del();\nvoid display();\nvoid save();\nvoid menu();\n\n", "//结构体保存学生信息", "\n", "struct", " ", "student", "{\n char ", "StudentId", "[", "LEN", "+", "1", "];\n char ", "StudentName", "[", "LEN", "+", "1", "];\n int ", "StudentAge", ";\n char ", "StudentSex", ";\n char ", "StudentBirth", ";\n int  ", "StudentPhonenumber", ";\n}stu[", "N", "];\n\n", "//主函数", "\nint main()\n{\n\n ", "while", " (k)\n {\n  menu();\n }\n system(", "\"pause\"", ");\n ", "return", " ", "0", ";\n}\n\n\n", "//查找学生信息", "\nvoid seek() ", "/*查找*/", "\n{\n int i, item, flag;\n char s1[", "21", "]; ", "/* 以姓名和学号最长长度+1为准*/", "\n printf(", "\"------------------", "\\n", "\"", ");\n printf(", "\"-----1.按学号查询-----", "\\n", "\"", ");\n printf(", "\"-----2.按姓名查询-----", "\\n", "\"", ");\n printf(", "\"-----3.退出本菜单-----", "\\n", "\"", ");\n printf(", "\"------------------", "\\n", "\"", ");\n ", "while", " (", "1", ")\n {\n  printf(", "\"请选择子菜单编号:\"", ");\n  scanf(", "\"%d\"", ", ", "&", "item);\n  flag ", "=", " ", "0", ";\n  ", "switch", " (item)\n  {\n  ", "case", " ", "1", ":\n   printf(", "\"请输入要查询的学生的学号:", "\\n", "\"", ");\n   scanf(", "\"%s\"", ", s1);\n   ", "for", "(i ", "=", " ", "0", "; i", "<", "n; i", "++", ")\n   ", "if", " (strcmp(s1,stu[i].", "StudentId", ") ", "==", " ", "0", ")\n   {\n    flag ", "=", " ", "1", ";\n    printf(", "\"学生学号", "\\t", "学生姓名", "\\t", "年龄", "\\t", "性别", "\\t", "生日", "\\t", "电话号码", "\\n", "\"", ");\n    printf(", "\"--------------------------------------------------------------------", "\\n", "\"", ");\n    printf(", "\"%s", "\\t", "%s", "\\t", "%d", "\\t", "%s", "\\t", "%s", "\\t", "%d", "\\n", "\"", ", stu[i].", "StudentId", ",stu[i].", "StudentName", ",stu[i].", "StudentAge", ",stu[i].", "StudentSex", ",stu[i].", "StudentBirth", ",stu[i].", "StudentPhonenumber", ");\n   }\n   ", "if", " (", "0", " ", "==", " flag)\n    printf(", "\"该学号不存在！", "\\n", "\"", ");\n    display(); ", "break", ";\n  ", "case", " ", "2", ":\n   printf(", "\"请输入要查询的学生的姓名:", "\\n", "\"", ");\n   scanf(", "\"%s\"", ", s1);\n   ", "for", " (i ", "=", " ", "0", "; i", "<", "n; i", "++", ")\n   ", "if", " (strcmp(stu[i].", "StudentName", ", s1) ", "==", " ", "0", ")\n   {\n    flag ", "=", " ", "1", ";\n    printf(", "\"学生学号", "\\t", "学生姓名", "\\t", "年龄", "\\t", "性别", "\\t", "生日", "\\t", "电话号码", "\\n", "\"", ");\n    printf(", "\"--------------------------------------------------------------------", "\\n", "\"", ");\n    printf(", "\"%s", "\\t", "%s", "\\t", "%d", "\\t", "%s", "\\t", "%d", "\\t", "%d", "\\n", "\"", ", stu[i].", "StudentId", ", stu[i].", "StudentName", ", stu[i].", "StudentAge", ", stu[i].", "StudentSex", ",stu[i].", "StudentBirth", ",stu[i].", "StudentPhonenumber", " );\n   }\n   ", "if", " (", "0", " ", "==", " flag)\n    printf(", "\"该姓名不存在！", "\\n", "\"", ");display(); ", "break", ";\n  ", "case", " ", "3", ":", "return", ";\n  ", "default", ":printf(", "\"请在1-3之间选择", "\\n", "\"", ");\n  }\n }}\n\n", "//修改学生信息", "\nvoid modify() ", "/*修改信息*/", "\n{\nint i, item, num ", "=", " ", "-", "1", ";\n char sex1,birth1, s1[", "LEN", " ", "+", " ", "1", "], s2[", "LEN", " ", "+", " ", "1", "]; ", "/* 以姓名和学号最长长度+1为准*/", "\n printf(", "\"请输入要要修改的学生的学号:", "\\n", "\"", ");\n scanf(", "\"%s\"", ", s1);\n ", "for", " (i ", "=", " ", "0", "; i ", "<", " n; i", "++", "){\n  ", "if", " (strcmp(stu[i].", "StudentId", ", s1) ", "==", " ", "0", "){", "/*比较字符串是否相等*/", "\n   num ", "=", " i;\n   printf(", "\"------------------", "\\n", "\"", ");\n   printf(", "\"1.修改姓名", "\\n", "\"", ");\n   printf(", "\"2.修改年龄", "\\n", "\"", ");\n   printf(", "\"3.修改性别", "\\n", "\"", ");\n   printf(", "\"4.修改生日", "\\n", "\"", ");\n   printf(", "\"5.修改电话号码", "\\n", "\"", ");\n   printf(", "\"6.退出本菜单", "\\n", "\"", ");\n   printf(", "\"------------------", "\\n", "\"", ");\n   ", "while", " (", "1", ")\n   {\n    printf(", "\"请选择子菜单编号:\"", ");\n    scanf(", "\"%d\"", ", ", "&", "item);\n    ", "switch", " (item)\n    {\n    ", "case", " ", "1", ":\n     printf(", "\"请输入新的姓名:", "\\n", "\"", ");\n     scanf(", "\"%s\"", ", s2);\n     strcpy(stu[num].", "StudentName", ", s2);\n     ", "break", ";\n    ", "case", " ", "2", ":\n     printf(", "\"请输入新的年龄:", "\\n", "\"", ");\n     scanf(", "\"%d\"", ", stu[num].", "StudentAge", ");\n     ", "break", ";\n    ", "case", " ", "3", ":\n     printf(", "\"请输入新的性别:", "\\n", "\"", ");\n     scanf(", "\"%s\"", ", ", "&", "sex1);\n     stu[i].", "StudentSex", " ", "=", " sex1;\n     ", "break", ";\n    ", "case", " ", "4", ":\n     printf(", "\"请输入新的生日:", "\\n", "\"", ");\n     scanf(", "\"%s\"", ", ", "&", "birth1);\n     stu[i].", "StudentBirth", " ", "=", " birth1;\n     ", "break", ";\n    ", "case", " ", "5", ":\n     printf(", "\"请输入新的电话号码:", "\\n", "\"", ");\n     scanf(", "\"%d\"", ", stu[num].", "StudentPhonenumber", ");\n     ", "break", ";\n    ", "case", " ", "6", ": ", "return", ";\n    ", "default", ":printf(", "\"请在1-6之间选择", "\\n", "\"", ");\n    }\n   }\n   printf(", "\"修改完毕！请及时保存！", "\\n", "\"", ");\n  }\n  ", "else", "{\n   printf(", "\"没有该学生学号!!!\"", ");\n  }\n }\n}\n\n\n\n\n", "//添加学生信息函数", "\nvoid insert() ", "/*插入函数*/", "\n{\n int i ", "=", " n, j, flag;\n printf(", "\"请输入待增加的学生数:", "\\n", "\"", ");\n scanf(", "\"%d\"", ", ", "&", "m);\n ", "if", " (m ", ">", " ", "0", "){\n  ", "do", "\n  {\n   flag ", "=", " ", "1", ";\n   ", "while", " (flag)\n   {\n    flag ", "=", " ", "0", ";\n    printf(", "\"请输入第%d位学生的学号:", "\\n", "\"", ", i ", "+", " ", "1", ");\n    scanf(", "\"%s\"", ", stu[i].", "StudentId", ");\n    ", "for", " (j ", "=", " ", "0", "; j ", "<", " i; j", "++", "){\n     ", "if", " (strcmp(stu[i].", "StudentId", ", stu[j].", "StudentId", ") ", "==", " ", "0", "){\n      printf(", "\"该学号已存在，请重新输入！", "\\n", "\"", ");\n      flag ", "=", " ", "1", ";\n      ", "break", ";\n     }\n    }\n   }\n   printf(", "\"请输入第%d 个学生的姓名:", "\\n", "\"", ", i", "+", "1", ");\n   scanf(", "\"%s\"", ", stu[i].", "StudentName", ");\n   printf(", "\"请输入第%d 个学生的年龄:", "\\n", "\"", ", i", "+", "1", ");\n   scanf(", "\"%d\"", ", ", "&", "stu[i].", "StudentAge", ");\n   printf(", "\"请输入第%d 个学生的性别:", "\\n", "\"", ", i", "+", "1", ");\n   scanf(", "\" %c\"", ", ", "&", "stu[i].", "StudentSex", ");\n   printf(", "\"请输入第%d 个学生的生日:", "\\n", "\"", ",i", "+", "1", ");\n   scanf(", "\"%f\"", ", ", "&", "stu[i].", "StudentBirth", ");\n   printf(", "\"请输入第%d 个学生的电话号码:", "\\n", "\"", ", i", "+", "1", ");\n   scanf(", "\"%f\"", ", ", "&", "stu[i].", "StudentPhonenumber", ");\n   ", "if", " (", "0", " ", "==", " flag){\n    i", "++", ";\n   }\n  } ", "while", " (i", "<", "n ", "+", " m);\n }\n  n ", "+=", " m;\n  printf(\n  ", "\"学生信息增加完毕！！！", "\\n", "\"", ");\n  system(", "\"pause\"", ");\n}\n\n", "//删除学生信息函数", "\nvoid del()\n{\n int i, j, flag ", "=", " ", "0", ";\n char s1[", "LEN", " ", "+", " ", "1", "];\n printf(", "\"请输入要删除学生的学号:", "\\n", "\"", ");\n scanf(", "\"%s\"", ", s1);\n ", "for", " (i ", "=", " ", "0", "; i ", "<", " n; i", "++", "){\n  ", "if", " (strcpy(stu[i].", "StudentId", ", s1) ", "==", " ", "0", "){\n   flag ", "=", " ", "1", ";\n   ", "//要删除学生后面的学生往前移一位", "\n   ", "for", " (j ", "=", " i; j ", "<", " n ", "-", " ", "1", "; j", "++", "){\n    stu[j] ", "=", " stu[j ", "+", " ", "1", "];\n   }\n  }\n }\n  ", "//查找失败", "\n  ", "if", " (", "0", " ", "==", " flag){\n   printf(", "\"该学号不存在!!!", "\\n", "\"", ");\n  }\n  ", "if", " (", "1", " ", "==", " flag){\n   printf(", "\"删除成功！！！\"", ");\n   ", "//删除成功，学生人数减1", "\n   n", "--", ";\n  }\n  system(", "\"pause\"", ");\n}\n\n", "//显示全部数据信息", "\nvoid display()\n{\n int i;\n printf(", "\"共有%d位学生的信息:", "\\n", "\"", ", n);\n ", "if", " (", "0", " ", "!=", " n)\n {\n  printf(", "\"学生学号 ", "\\t", "学生姓名 ", "\\t", "年龄   ", "\\t", "性别   ", "\\t", "生日   ", "\\t", "电话号码", "\\n", "\"", ");\n  printf(", "\"--------------------------------------------------------------------", "\\n", "\"", ");\n  ", "for", " (i ", "=", " ", "0", "; i", "<", "n; i", "++", ")\n  {\n   printf(", "\"%s ", "\\t", "%s ", "\\t", "%d   ", "\\t", "%s   ", "\\t", "%s    ", "\\t", "%d", "\\n", "\"", ", stu[i].", "StudentId", ", stu[i].", "StudentName", ", stu[i].", "StudentAge", ", stu[i].", "StudentSex", ", stu[i].", "StudentBirth", ",stu[i].", "StudentPhonenumber", ");\n  }\n }\n system(", "\"pause\"", ");\n}\n\nvoid save(){\n int i;\n ", "FILE", " ", "*", "fp;\n ", "if", "((fp", "=", "fopen(", "\"sdf.txt\"", ",", "\"w\"", "))", "==", "NULL", "){\n     printf(", "\"文件打开失败！", "\\n", "\"", ");\n     exit(", "0", ");\n }\n ", "for", " (i ", "=", " ", "0", "; i ", "<", " n; i", "++", "){\n  fprintf(fp, ", "\"%s%s%d%s%s%d", "\\n", "\"", ", stu[i].", "StudentId", ", stu[i].", "StudentName", ", stu[i].", "StudentAge", ", stu[i].", "StudentSex", ",\n  stu[i].", "StudentBirth", ",stu[i].", "StudentPhonenumber", " );\n }\n printf(", "\"保存成功！！！", "\\n", "\"", ");\n fclose(fp);\n system(", "\"pause\"", ");\n}\n\n\nvoid sort()", "//按学号排序", "\n{\n int i, j, k, ", "*", "p, ", "*", "q, s;\n char temp[", "LEN", " ", "+", " ", "1", "], ctemp;\n float ftemp;\n ", "for", " (i ", "=", " ", "0", "; i", "<", "n ", "-", " ", "1", "; i", "++", ")\n {\n  ", "for", " (j ", "=", " n ", "-", " ", "1", "; j", ">", "i; j", "--", ")\n  ", "if", " (strcmp(stu[j ", "-", " ", "1", "].", "StudentId", ", stu[j].", "StudentId", ")", ">", "0", ")\n  {\n   strcpy(temp, stu[j ", "-", " ", "1", "].", "StudentId", ");\n   strcpy(stu[j ", "-", " ", "1", "].", "StudentId", ", stu[j].", "StudentId", ");\n   strcpy(stu[j].", "StudentId", ", temp);\n   strcpy(temp, stu[j ", "-", " ", "1", "].", "StudentName", ");\n   strcpy(stu[j ", "-", " ", "1", "].", "StudentName", ", stu[j].", "StudentName", ");\n   strcpy(stu[j].", "StudentName", ", temp);\n   ctemp ", "=", " stu[j ", "-", " ", "1", "].", "StudentSex", ";\n   stu[j ", "-", " ", "1", "].", "StudentSex", " ", "=", " stu[j].", "StudentSex", ";\n   stu[j].", "StudentSex", " ", "=", " ctemp;\n   p ", "=", " ", "&", "stu[j ", "-", " ", "1", "].", "StudentAge", ";\n   q ", "=", " ", "&", "stu[j].", "StudentAge", ";\n   s ", "=", " ", "*", "q;\n   ", "*", "q ", "=", " ", "*", "p;\n   ", "*", "p ", "=", " s;}}}\n\nvoid menu()", "/* 界面*/", "\n{\n int num;\n ", "FILE", " ", "*", "fp;\n printf(", "\" ", "\\n", "\\n", "                    ", "\\n", "\\n", "\"", ");\n printf(", "\"  *****************************************************", "\\n", "\\n", "\"", ");\n printf(", "\"  *                学生信息管理系统                    *", "\\n", " ", "\\n", "\"", ");\n printf(", "\"  ******************************************************", "\\n", "\\n", "\"", ");\n printf(", "\"*********************系统功能菜单*************************       ", "\\n", "\"", ");\n printf(", "\"     ----------------------   ----------------------   ", "\\n", "\"", ");\n printf(", "\"     *********************************************     ", "\\n", "\"", ");\n printf(", "\"     *1 .查询学生信息    * *  2.修改学生信息   *     ", "\\n", "\"", ");\n printf(", "\"     *********************************************     ", "\\n", "\"", ");\n printf(", "\"     * 3.增加学生信息    * *  4.按学号删除信息 *     ", "\\n", "\"", ");\n printf(", "\"     *********************************************     ", "\\n", "\"", ");\n printf(", "\"     * 5.显示当前信息    * *  6.保存当前学生信息*     ", "\\n", "\"", ");\n printf(", "\"     ********************** **********************     ", "\\n", "\"", ");\n printf(", "\"     * 7.退出系统        *                            ", "\\n", "\"", ");\n printf(", "\"     **********************                            ", "\\n", "\"", ");\n printf(", "\"     ----------------------   ----------------------                           ", "\\n", "\"", ");\n printf(", "\"请选择菜单编号:\"", ");\n scanf(", "\"%d\"", ", ", "&", "num);\n ", "switch", " (num)\n {\n ", "case", " ", "1", ":seek(); ", "break", ";\n ", "case", " ", "2", ":modify(); ", "break", ";\n ", "case", " ", "3", ":insert(); ", "break", ";\n ", "case", " ", "4", ":del(); ", "break", ";\n ", "case", " ", "5", ":display(); ", "break", ";\n ", "case", " ", "6", ":save(); ", "break", ";\n ", "case", " ", "7", ":\n  k ", "=", " ", "0", "; \n  printf(", "\"即将退出程序!", "\\n", "\"", ");\n  ", "break", ";\n ", "default", ":printf(", "\"请在0-7间选择", "\\n", "\"", ");\n }\n}\n", "\n", "希望能直接得改好的代码"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你可以重新设计下系统的流程&amp;#xff0c;写一个从文件读取数据到链表的函数&amp;#xff0c;进入系统时&amp;#xff0c;先运行此函数进行初始化的工作&amp;#xff0c;然后再实现系统原有的一些功能。然后把链表数据保存到文件的那部分代码单独设计成一个函数&amp;#xff0c;然后在退出系统的时候运行&amp;#xff0c;把数据保存在文件里。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["数据结构链表在文件中提取数据", ["问题遇到的现象和发生背景", "\n", "//工资定位", "void LocateElem(LinkList L,char ", "x)", "{   int buff[255];", "    char c;", "    int i=0;", "if (!L || !L->next)  return;", "LinkList p=L->next;", "int j=0;", "FILE", "fp=NULL;", "fp=fopen(\"employee.txt\",\"r\");", "fscanf(fp,\"%d\", &buff[i]);", "while ((p)&&strcmp(p->data.wages,x)!=0)", "{p=p->next; j++;}", "if(!p)", "printf(\"没有该信息\\n\");", "else", "printf(\"%d 5个%s\\n\",&p->data.id,p->data.name,&p->data.birthday,p->data.sex,p->data.address,p->data.education,p->data.wages); //输chu元素值 ，职工号，姓名，出生年月日，性别，住址，学历，工资", "}", "如何在已经生成的文件里定位数据并与p->data.wages进行比较。", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include<stdio.h>", "#include<stdlib.h>", "#include<windows.h>", "//结点类型定义", "typedef struct{", "int id;//职工号", "char name[00];//名字", "char sex[10];//性别", "char birthday[15];//出生年月", "char wages[15];//工资", "char address[60];//住址", "char education[10];//学历", "char positions[10];//职务", "} ElemType;", "typedef struct node{", "ElemType data;", "struct node* next;", "}LNode,* LinkList;", "\n", "//函数声明", "void ListCreate(LinkList &L,int n);  //创建员工基本信息链表", "void ListPrint(LinkList L); //浏览员工基本信息", "void LocateElem(LinkList L,char *x); //查找 某个员工基本信息", "void ListInsert(LinkList &L,ElemType e); //添加员工信息到单链表", "void ListDelete(LinkList &L,int x); //删除一个员工信息", "void welcome();", "//主函数", "int main()", "{system(\"color 3f\");", "int control;           // 循环中控制操作", "int x;                 //查找的员工职工号", "int n;                 //欲创建的员工个数", "char w[20];", "ElemType e={0};            //员工信息", "LinkList p=NULL;            //工作指针", "LinkList L=NULL;            //链表头指针", "while(1){", "printf(\"请选择功能。1建立。2浏览。3查找。4修改。5删除6退出\");", "//主循环", "scanf(\"%d\", &control);", "while(control)", "{", "switch(control)", "{", "case 1:", "{printf(\"请输入要创建的员工个数n=\");", "scanf(\"%d\", &n);", "printf(\"请依次输入员工职工号，姓名，出生年月日，性别，住址，学历，工资。\\n数据中间请用空格连接\\n\");", "ListCreate(L,n);", "};", "break;", "case 2:", "ListPrint(L);", "break;//输出链表内容 ", "\n", "case 3:", "{", "printf(\"请输入要查找的员工工资\\n\");", "scanf(\"%s\",&w);", "LocateElem(L,w);", "};", "break;", "case 4:", "{", "printf(\"请输入欲插入的员工信息\\n\");", " scanf(\"%d5个%s\",&p->data.id,p->data.name,&p->data.birthday,p->data.sex,p->data.address,p->data.education,p->data.wages); //输入元素值 ，职工号，姓名，出生年月日，性别，住址，学历，工资", "ListInsert(L,e);", "};", "break;", "case 5:", "{", "printf(\"请输入欲删除员工的职工号\\n\");", "scanf(\"%d\",&x);", "ListDelete(L,x);", "};", "break;", "default:", "{", "printf(\"程序结束\\n\");", "exit(0);", "}", "break;//结束程序", "}", "printf(\"0结束程序 1创造链表 2输出链表 3查找 4插入 5删除\\n\");", "scanf(\"%d\",&control);", "}", "}", "return 0;", "}", "\n", "//录入信息", "void ListCreate(LinkList &L,int n){", "      //正位序输入n个元素的值，建立带表头结点的单链表L", "     LinkList p,r;", "     int i;", "FILE *fp;//文件", "fp=fopen(\"employee.txt\",\"a+\");", "    if (fp == NULL)                    //判断文件是否成功打开", "    {", "        printf(\"File open failed!\\n\");", "        exit(0);", "    }", "  L = (LinkList) malloc (sizeof(LNode));", "      L->next=NULL;", "      r=L;                                  //尾指针r指向头结点", "      for(i=0;i<n;++i){", "         p = (LinkList) malloc (sizeof(LNode));      //生成新结点", "            scanf(\"%d5个%s\", &p->data.id, p->data.name, p->data.birthday, p->data.sex,p->data.address, p->data.education, p->data.wages);", "        //输入元素值 ，职工号，姓名，出生年月日，性别，住址，学历，工资", "            p->next=NULL; r->next=p;       //插入到表尾", "            r=p;                        //r指向新的尾结点", "      }", "    for (p = L->next; p; p = p->next) {", "        fprintf(fp, \"姓名：%s\\n性别：%s\\n职工号：%d\\n\", p->data.name, p->data.sex, p->data.id);", "        fprintf(fp, \"出生年月日：%s\\n\", p->data.birthday);", "        fprintf(fp, \"工资：%s\\n住址：%s\\n学历：%s\\n职务：%s\\n\\n\", p->data.wages, p->data.address,p->data.education, p->data.positions);", "    }", "    fclose(fp);", "}", "\n", "//输出链表的值", "void ListPrint(LinkList L)", "{", "if (!L || !L->next)  return;", "LinkList p=L->next;", "if(!p)", "printf(\"没有元素输出\\n\");", "while (p)", "{", "printf(\"%d5个%s\\n\",&p->data.id,p->data.name,&p->data.birthday,p->data.sex,p->data.address,p->data.education,p->data.wages); //输chu元素值 ，职工号，姓名，出生年月日，性别，住址，学历，工资", "p=p->next;", "}", "}", "\n", "//工资定位", "void LocateElem(LinkList L,char ", "x)", "{   int buff[255];", "    char c;", "    int i=0;", "if (!L || !L->next)  return;", "LinkList p=L->next;", "int j=0;", "FILE", "fp=NULL;", "fp=fopen(\"employee.txt\",\"r\");", "fscanf(fp,\"%d\", &buff[i]);", "while ((p)&&strcmp(p->data.wages,x)!=0)", "{p=p->next; j++;}", "if(!p)", "printf(\"没有该信息\\n\");", "else", "printf(\"%d 5个%s\\n\",&p->data.id,p->data.name,&p->data.birthday,p->data.sex,p->data.address,p->data.education,p->data.wages); //输chu元素值 ，职工号，姓名，出生年月日，性别，住址，学历，工资 ", "\n", "}", "\n", "//插入", "void ListInsert(LinkList &L,ElemType e)", "{", "// 在带头结点的单链线性表L表尾插入元素e", "LinkList q,p=L;", "while (p->next)", "{p=p->next;}", "q=(LinkList)malloc(sizeof(LNode));", "p->next=q;", "q->data=e;", "q->next=NULL;", "}", "//删除", "void ListDelete(LinkList &L,int x)", "{", "LinkList q,p=L;", "while ((p->next)&& (p->next->data.id != x))", "p=p->next;", "if(!p->next)", "printf(\"没有找到学号为%d的学生信息\\n\",x);", "else", "{", "q=p->next;", "p->next=p->next->next;", "free(q);", "}", "}", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "读取了文件数据但不知道如何与p->data.wages进行比较", "\n", "我想要达到的结果", "\n", "在程序上输入所查找的数据，在文件中找到p->data的数据，在屏幕上打印出来。"]], "Tag": "程序设计"}
{"Answer": "你没有提供company.jsp我无法继续调试\r\n\r\n不过可以看出来你的问题所在，我修改了一下，你测试看看\r\n\r\nExt.ns(\"Morik.Office\");\r\nMorik.Office.DocrecPanel = function(config) {\r\n\tMorik.Office.DocrecPanel.superclass.constructor.call(this, config);\r\n\tvar proxy = new Ext.data.HttpProxy({\r\n\t\t    url : 'company.jsp'\r\n\t    });\r\n\tvar recordType = new Ext.data.Record.create([{\r\n\t\t    name : \"id\",\r\n\t\t    type : \"int\"\r\n\t    }, {\r\n\t\t    name : \"date\",\r\n\t\t    type : \"date\"\r\n\t    }, {\r\n\t\t    name : \"name\",\r\n\t\t    type : \"string\"\r\n\t    }, {\r\n\t\t    name : \"add\",\r\n\t\t    type : \"string\"\r\n\t    }, {\r\n\t\t    name : \"tel\",\r\n\t\t    type : \"string\"\r\n\t    }, {\r\n\t\t    name : 'indoor',\r\n\t\t    type : 'bool'\r\n\t    }]);\r\n\r\n\tvar reader = new Ext.data.JsonReader({\r\n\t\t    totalProperty : \"results\",\r\n\t\t    root : \"rows\",\r\n\t\t    id : \"id\"\r\n\t    }, recordType);\r\n\tvar store = new Ext.data.Store({\r\n\t\t    proxy : proxy,\r\n\t\t    reader : reader\r\n\t    });\r\n\tthis.store = store;\r\n\tvar fm = Ext.form;\r\n\r\n\tvar checkColumn = new Ext.grid.CheckColumn({\r\n\t\t    header : \"Indoor?\",\r\n\t\t    dataIndex : 'indoor',\r\n\t\t    width : 55\r\n\t    });\r\n\tfunction formatDate(value) {\r\n\t\treturn value ? value.dateFormat('M d, Y') : '';\r\n\t};\r\n\r\n\tvar cm = new Ext.grid.ColumnModel({\r\n\t\t    defaultSortable : true,\r\n\t\t    defaultWidth : 100,\r\n\t\t    columns : [{\r\n\t\t\t        header : '编号',\r\n\t\t\t        dataIndex : 'id'\r\n\t\t        }, {\r\n\t\t\t        header : '日期',\r\n\t\t\t        dateIndex : 'date',\r\n\t\t\t        renderer : formatDate,\r\n\t\t\t        editor : new fm.DateField({\r\n\t\t\t\t            format : 'm/d/y',\r\n\t\t\t\t            minValue : '01/01/06',\r\n\t\t\t\t            disabledDays : [0, 6],\r\n\t\t\t\t            disabledDaysText : 'Plants are not available on the weekends'\r\n\t\t\t            })\r\n\t\t        }, {\r\n\t\t\t        header : '名称',\r\n\t\t\t        dataIndex : 'name',\r\n\t\t\t        editor : new fm.TextField({\r\n\t\t\t\t            allowBlank : false\r\n\t\t\t            })\r\n\t\t        }, {\r\n\t\t\t        header : '地址',\r\n\t\t\t        width : 300,\r\n\t\t\t        dataIndex : 'add',\r\n\t\t\t        editor : new fm.TextField({\r\n\t\t\t\t            allowBlank : false\r\n\t\t\t            })\r\n\t\t        }, {\r\n\t\t\t        header : '电话',\r\n\t\t\t        width : 300,\r\n\t\t\t        dataIndex : 'tel',\r\n\t\t\t        editor : new fm.NumberField({\r\n\t\t\t\t            allowBlank : false,\r\n\t\t\t\t            allowNegative : false,\r\n\t\t\t\t            maxValue : 100000\r\n\t\t\t            })\r\n\t\t        }]\r\n\t    });\r\n\r\n\tvar Plant = Ext.data.Record.create([{\r\n\t\t    name : 'id',\r\n\t\t    type : 'string'\r\n\t    }, {\r\n\t\t    name : 'date',\r\n\t\t    mapping : 'availability',\r\n\t\t    type : 'date',\r\n\t\t    dateFormat : 'm/d/Y'\r\n\t    }, {\r\n\t\t    name : 'name'\r\n\t    }, {\r\n\t\t    name : 'add',\r\n\t\t    type : 'float'\r\n\t    }, {\r\n\t\t    name : 'tel',\r\n\t\t    type : 'string'\r\n\t    }, {\r\n\t\t    name : 'indoor',\r\n\t\t    type : 'bool'\r\n\t    }\r\n\r\n\t]);\r\n\tvar grid = new Ext.grid.EditorGridPanel({\r\n\t\t    cm : cm,\r\n\t\t    store : store,\r\n\t\t    width : 1000,\r\n\t\t    height : 400,\r\n\t\t    autoExpandColumn : 'common',\r\n\t\t    plugins : checkColumn,\r\n\t\t    clicksToEdit : 1,\r\n\t\t    tbar : [{\r\n\t\t\t        text : 'Add Plant',\r\n\t\t\t        handler : function() {\r\n\t\t\t\t        var p = new Plant({\r\n\t\t\t\t\t            id : 'New Plant 1',\r\n\t\t\t\t\t            date : '',\r\n\t\t\t\t\t            name : '',\r\n\t\t\t\t\t            add : 'Mostly Shade',\r\n\t\t\t\t\t            tel : 0,\r\n\t\t\t\t\t            availDate : (new Date()).clearTime(),\r\n\t\t\t\t\t            indoor : false\r\n\t\t\t\t            });\r\n\t\t\t\t        grid.stopEditing();\r\n\t\t\t\t        store.insert(0, p);\r\n\t\t\t\t        grid.startEditing(0, 0);\r\n\t\t\t        }\r\n\t\t        }],\r\n\t\t    loadMask : {\r\n\t\t\t    msg : '正在载入数据,请稍等...'\r\n\t\t    },\r\n\t\t    title : '公司列表'\r\n\t    });\r\n\tstore.load();\r\n\r\n\tthis.add(grid);\r\n}\r\nExt.extend(Morik.Office.DocrecPanel, Ext.Panel, {});\r\n\r\nExt.grid.CheckColumn = function(config) {\r\n\tExt.apply(this, config);\r\n\tif (!this.id) {\r\n\t\tthis.id = Ext.id();\r\n\t}\r\n\tthis.renderer = this.renderer.createDelegate(this);\r\n};\r\n\r\nExt.grid.CheckColumn.prototype = {\r\n\tinit : function(grid) {\r\n\t\tthis.grid = grid;\r\n\t\tthis.grid.on('render', function() {\r\n\t\t\t    var view = this.grid.getView();\r\n\t\t\t    view.mainBody.on('mousedown', this.onMouseDown, this);\r\n\t\t    }, this);\r\n\t},\r\n\r\n\tonMouseDown : function(e, t) {\r\n\t\tif (t.className &amp;&amp; t.className.indexOf('x-grid3-cc-' + this.id) != -1) {\r\n\t\t\te.stopEvent();\r\n\t\t\tvar index = this.grid.getView().findRowIndex(t);\r\n\t\t\tvar cindex = this.grid.getView().findCellIndex(t);\r\n\t\t\tvar record = this.grid.store.getAt(index);\r\n\t\t\tvar field = this.grid.colModel.getDataIndex(cindex);\r\n\t\t\tvar e = {\r\n\t\t\t\tgrid : this.grid,\r\n\t\t\t\trecord : record,\r\n\t\t\t\tfield : field,\r\n\t\t\t\toriginalValue : record.data[this.dataIndex],\r\n\t\t\t\tvalue : !record.data[this.dataIndex],\r\n\t\t\t\trow : index,\r\n\t\t\t\tcolumn : cindex,\r\n\t\t\t\tcancel : false\r\n\t\t\t};\r\n\t\t\tif (this.grid.fireEvent(\"validateedit\", e) !== false &amp;&amp; !e.cancel) {\r\n\t\t\t\tdelete e.cancel;\r\n\t\t\t\trecord.set(this.dataIndex, !record.data[this.dataIndex]);\r\n\t\t\t\tthis.grid.fireEvent(\"afteredit\", e);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\trenderer : function(v, p, record) {\r\n\t\tp.css += ' x-grid3-check-col-td';\r\n\t\treturn '&lt;div class=\"x-grid3-check-col' + (v ? '-on' : '') + ' x-grid3-cc-'\r\n\t\t    + this.id + '\"&gt;&amp;160;&lt;/div&gt;';\r\n\t}\r\n};", "Konwledge_Point": "定义新的类型", "Question": ["老是报缺少对象，实在看不出来那里出错了 求各位帮忙", ["Morik.Office.DocrecPanel = function(config) {", "\n    Morik.Office.DocrecPanel.superclass.constructor.call(this, config);", "\n\n", "// 加上服务器上的jsp数据生成\n// 生成Company类型\nvar proxy = new Ext.data.HttpProxy( {\n    url : 'company.jsp'\n});\n\nvar recordType = new Ext.data.Record.create([ {\n    name : \"id\",\n    type : \"int\"\n},{\n    name:\"date\",\n    type:\"date\"\n    }, {\n    name : \"name\",\n    type : \"string\"\n}, {\n    name : \"add\",\n    type : \"string\"\n}, {\n    name : \"tel\",\n    type : \"string\"\n},{\n    name:'indoor',\n    type:'bool'\n    }]);\n\nvar reader = new Ext.data.JsonReader( {\ntotalProperty : \"results\",\n    root : \"rows\",\n    id : \"id\"\n}, recordType);\n", "\n\n", "//", "\n//  // 定义store", "\n    var store = new Ext.data.Store( {", "\n        proxy : proxy,", "\n        reader : reader", "\n    });", "\nthis.store=store;", "\n    // 第二，讲一下cm,grid", "\n     var fm = Ext.form;", "\n\n", "[color=red] var checkColumn = new Ext.grid.CheckColumn ({", "\n                                                      header: \"Indoor?\",", "\n       dataIndex: 'indoor',", "\n       width: 55", "\n       });[/color]", "\n         function formatDate(value){", "\n        return value ? value.dateFormat('M d, Y') : '';", "\n    };", "\n\n", "var cm = new Ext.grid.ColumnModel( {\n    defaultSortable : true,\n    defaultWidth : 100,\n    columns : [ {\n        header : '编号',\n        dataIndex : 'id'\n    }, {\n        header:'日期',\n        dateIndex:'date',\n         renderer: formatDate,\n       editor: new fm.DateField({\n            format: 'm/d/y',\n            minValue: '01/01/06',\n            disabledDays: [0, 6],\n            disabledDaysText: 'Plants are not available on the weekends'\n        })\n        },{\n        header : '名称',\n        dataIndex : 'name',\n        editor: new fm.TextField({\n           allowBlank: false\n       })\n    }, {\n        header : '地址',\n        width : 300,\n        dataIndex : 'add',\n                    editor: new fm.TextField({\n           allowBlank: false\n       })\n    }, {\n        header : '电话',\n        width : 300,\n        dataIndex : 'tel',\n        editor: new fm.NumberField({\n        allowBlank: false,\n        allowNegative: false,\n        maxValue: 100000\n        })\n    }\n    ]\n});\n\n\nvar Plant = Ext.data.Record.create([\n       // the \"name\" below matches the tag name to read, except \"availDate\"\n       // which is mapped to the tag \"availability\"\n       {name: 'id', type: 'string'},\n       {name: 'date', mapping: 'availability', type: 'date', dateFormat: 'm/d/Y'},\n       {name: 'name'},\n       {name: 'add', type: 'float'},             // automatic date conversions\n       {name: 'tel', type: 'string'},\n       {name: 'indoor', type: 'bool'}\n\n  ]);\nvar grid = new Ext.grid.EditorGridPanel( {\n    cm : cm,\n    store : store,\n    width : 1000,\n    height : 400,\n    autoExpandColumn:'common',\n", "\n\n", "//        title:'Edit Plants?',", "\n       // frame:true,", "\n        plugins:checkColumn,", "\n        clicksToEdit:1,", "\n        tbar:[{ text: 'Add Plant',", "\n            handler : function(){", "\n                var p = new Plant({", "\n                    id: 'New Plant 1',", "\n                    date:'',", "\n                    name:'',", "\n                    add: 'Mostly Shade',", "\n                    tel: 0,", "\n                    availDate: (new Date()).clearTime(),", "\n                    indoor:false", "\n\n", "            });\n            grid.stopEditing();\n            store.insert(0, p);\n            grid.startEditing(0, 0);\n        }}],\n    loadMask:{msg:'正在载入数据,请稍等...'},\n    title : '公司列表'\n});\n\n\n\n    // trigger the data store load\n\nstore.load();\n\nthis.add(grid);\n\n\n\n// 第三、调整，tbar分页,工具栏\n\n\nvar checkColumn = new Ext.grid.CheckColumn();\nExt.grid.CheckColumn = function(config){\nExt.apply(this, config);\nif(!this.id){\n    this.id = Ext.id();\n}\nthis.renderer = this.renderer.createDelegate(this);\n", "\n\n", "};", "\n\n", "Ext.grid.CheckColumn.prototype ={", "\n    init : function(grid){", "\n        this.grid = grid;", "\n        this.grid.on('render', function(){", "\n            var view = this.grid.getView();", "\n            view.mainBody.on('mousedown', this.onMouseDown, this);", "\n        }, this);", "\n    },", "\n\n", "onMouseDown : function(e, t){\n    if(t.className && t.className.indexOf('x-grid3-cc-'+this.id) != -1){\n        e.stopEvent();\n        var index = this.grid.getView().findRowIndex(t);\n        var record = this.grid.store.getAt(index);\n        record.set(this.dataIndex, !record.data[this.dataIndex]);\n    }\n}\n", "\n\n", "};", "\n\n", "}", "\nExt.extend(Morik.Office.DocrecPanel, Ext.Panel, {});", "\n\n", "出错提示代码为红色标注的这段 提示为图片所示，求各位帮忙找一下错误原因 ，3Q", "\n[b]问题补充：[/b]", "\nTO:lovewhzlq (架构师)", "\n     按照你的写法，提示出错信息依然存在 ，且为同一错误信息，郁闷了", "\n[b]问题补充：[/b]", "\nTO:lovewhzlq 因为EXTJS是新上手 所以很多代码不是自己写的", "\nvar checkColumn = new Ext.grid.CheckColumn(); ", "\nExt.grid.CheckColumn = function(config){ ", "\n    Ext.apply(this, config); ", "\n    if(!this.id){ ", "\n        this.id = Ext.id(); ", "\n    } ", "\n    this.renderer = this.renderer.createDelegate(this); ", "\n}; ", "\n\n", "Ext.grid.CheckColumn.prototype ={ ", "\n    init : function(grid){ ", "\n        this.grid = grid; ", "\n        this.grid.on('render', function(){ ", "\n            var view = this.grid.getView(); ", "\n            view.mainBody.on('mousedown', this.onMouseDown, this); ", "\n        }, this); ", "\n    }, ", "\n\n", "onMouseDown : function(e, t){ \n    if(t.className && t.className.indexOf('x-grid3-cc-'+this.id) != -1){ \n        e.stopEvent(); \n        var index = this.grid.getView().findRowIndex(t); \n        var record = this.grid.store.getAt(index); \n        record.set(this.dataIndex, !record.data[this.dataIndex]); \n    } \n} \n", "\n\n", "}; ", "\n这段代码就是从ext-js的范例里拿过来的  感觉是错在这里 跟上面的代码连续不上", "\n[b]问题补充：[/b]", "\nTO yourgame ", "\n   我没用firefox  我用的是IE的插件调试的 结果差不多的吧", "\n[b]问题补充：[/b]", "\nTO yourgame 你给我的代码调试出来报错信息如下图所示，点击进去看到的是ext-all-debug.js里面的一段代码 ，不过想想是不会这个JS里面的错误", "\n后来自己调试了下发现是autoExpandColumn : 'common',这段代码出的错 将这段代码注释掉后就正常 无报错了 PS：这个JS是点击左侧tree时所调用到的，装载到右边tabpanel中的代码"]], "Tag": "程序设计"}
{"Answer": "因为你每次都在同一个ID上渲染，所以就叠加了\r\n\r\napplyTo:'hello-win',", "Konwledge_Point": "定义新的类型", "Question": ["ext.Window 第一次打开对话框没问题，第二次，次三.....就不行了", ["一、表述：", "    使用Ext.grid.GridPanel创建gird对象。grid的最后一列定义为{header: '授权',dataIndex: 'operate1',sortable: true,renderer:authorization},即点击最后一列中的元素将对话框。", "二、错误描述：", "    第一次弹出的对话框没有问题，第一此没有问题，第二，第三。。。。次就有问题了,每多点击一次对话框就会多嵌套一层对话框，对话框不断的嵌套，不知道是怎么回事，  多谢各位高手能指点一二、谢谢了！", "\n\n", "manageMySellerGrid = function(title, id){\n    //新窗体\n    showMemerAddWindow = function(){\n        memberAddWindow = new Ext.Window({\n            el: 'window_win',\n            layout: 'fit',\n            width: 300,\n            height: 200,\n            closable: true,\n            closeAction: 'hide',\n            plain: true,\n            items: [memberForm]\n        });\n        //memberAddWindow.show(Ext.get('newWindowButton'));\n        memberAddWindow.show();\n    }\n    \n    authorization =  function(value, cellmeta, record){\n        if(record.data['userTYpe']==1){\n            return '", "授权", "';\n        }else{\n            return '';\n        }\n    }\n   authorizationOperate1=function(){\n        var win  = authorizationOperate();\n        win.show();\n    }\n    authorizationOperate = function(){\n        var win = new Ext.Window({\n            applyTo:'hello-win',\n            layout:'fit',\n            width:500,\n            height:350,\n            closeAction:'hide',\n            closable:true,\n            plain:false,\n            modal:true,\n            title:'测试'\n//          items:new Ext.TabPanel({\n//               activeTab:0,\n//               border:false,\n//               items:[{title:\"tab1\",html:\"tab1在windows窗口中\"},{title:\"tab2\",html:\"tab2在windows窗口中\"}]\n//          })          \n        });\n        return win;\n    }\n    /**\n     * 以下是表单\n     */\n    //账号\n    var idField = new Ext.form.TextField({\n        fieldLabel: '账号',\n        name: 'memberName',\n        allowBlank: false,\n        anchor: '90%',\n        blankText: '账号不能为空'\n    });\n    //密码\n    var passwordField = new Ext.form.TextField({\n        inputType: 'password',\n        fieldLabel: '密码',\n        name: 'password',\n        allowBlank: false,\n        anchor: '90%',\n        blankText: '密码不能为空'\n    });\n    //密码确认\n    var repasswordField = new Ext.form.TextField({\n        inputType: 'password',\n        fieldLabel: '密码确认',\n        name: 'repassword',\n        allowBlank: false,\n        anchor: '90%',\n        blankText: '确认密码不能为空'\n    });\n    //电子邮件\n    var emailField = new Ext.form.TextField({\n        fieldLabel: '电子邮件',\n        name: 'email',\n        allowBlank: false,\n        anchor: '90%',\n        vtype: 'email',\n        blankText: '电子邮件不能为空'\n    });\n    //真实姓名\n    var trueNameField = new Ext.form.TextField({\n        fieldLabel: '真实姓名',\n        name: 'trueName',\n        allowBlank: false,\n        anchor: '90%',\n        blankText: '真实姓名不能为空'\n    });\n    var memberForm = new Ext.FormPanel({\n        monitorValid: true,\n        labelAlign: 'top',\n        frame: true,\n        title: '添加新商户信息',\n        width: 300,\n        url: './userManage.jsp?command=insert&groupid=' + sGroupid,\n        \n        items: [{\n            layout: 'column',// 该FormPanel的layout布局模式为列模式(column),包含2列  \n            items: [{//第一列  \n                columnWidth: 0.5,\n                layout: 'form',\n                items: [idField, passwordField]\n            }, {//第二列  \n                columnWidth: 0.5,\n                layout: 'form',\n                items: [repasswordField, emailField]\n            }, {\n                columnWidth: 0.5,\n                layout: 'form',\n                items: [trueNameField]\n            }]\n        }],\n        buttons: [{\n            text: '提交',\n            formBind: true,\n            handler: function(){\n                if (memberForm.getForm().isValid()) {\n                    memberForm.getForm().submit({\n                        method: 'POST',\n                        waitMsg: '保存中,请稍后...',\n                        success: function(){\n                            memberForm.getForm().reset();\n                            memberAddWindow.hide();\n                            ds.reload();\n                        },\n                        failure: function(){\n                            Ext.Msg.alert('错误', '服务器出现错误请稍后再试！');\n                        }\n                    });\n                }\n            }\n        }, {\n            text: '取消',\n            handler: function(){\n                memberForm.getForm().reset();\n                memberAddWindow.hide();\n            }\n        }]\n    });\n    //添加标注\n    \n    addTabOfMerLabel = function(url, title,id){\n        var mytab = myTabPanel.getItem(id);\n        if(null==mytab){\n            myTabPanel.add(myGrid(url, title,id)).show();\n        }else{\n            myTabPanel.setActiveTab(mytab);\n        }\n    }\n    //查看每个商户的标注 \n    examineLabel = function(value, cellmeta, record, rowIndex, columnIndex, store){\n        var userId = record.data['id'];\n        var url = '/mapscene/member/merGrid.jsp?userId=' + userId;\n        var title = userId + '的标注';\n        var str = \"", "查看标注", "\";\n        //var str = \"", "查看标注", "\";\n        return str;\n    }\n    reader = new Ext.data.JsonReader({\n            totalProperty: 'totalProperty',\n            root: 'root'\n        }, [\n            {name: 'id'}, \n            {name: 'email'}, \n            {name: 'trueName'}, \n            {name: 'sex'}, \n            {name: 'password'}, \n            {name: 'telephone'}, \n            {name: 'fax'}, \n            {name: 'company'}, \n            {name: 'mobile'}, \n            {name: 'address'}, \n            {name: 'qq'}, \n            {name: 'msn'}, \n            {name: 'description'},\n            {name: 'userTYpe'},  \n            {name: 'createDatetime'}, \n            {name: 'operate'},\n           {name: 'operate1'}\n        ]\n    );\n    var ds = new Ext.data.Store({\n        proxy: new Ext.data.HttpProxy({\n            url: '/mapscene/member/seller.jsp'\n        }),\n        reader: reader,\n        baseParams:{userType:null,idOfSearch:null,command:'query'}\n    });\n    //列模型\n    var sm  = new Ext.grid.CheckboxSelectionModel();\n    var cm = null;\n    if(i_userType==3){\n        cm=new Ext.grid.ColumnModel([\n            new Ext.grid.RowNumberer(), \n            sm,\n            {header: '账号',dataIndex: 'id',sortable: true}, \n            {header: '电子邮件',dataIndex: 'email',sortable: true}, \n            {header: '真实姓名',dataIndex: 'trueName',sortable: true}, \n            {header: '性别',dataIndex: 'sex',sortable: true}, \n            {header: '密码',dataIndex: 'password'}, \n            {header: '电话号码',dataIndex: 'telephone',sortable: true}, \n            {header: '传真',dataIndex: 'fax',sortable: true}, \n            {header: '公司名称',dataIndex: 'company',sortable: true}, \n            {header: '手机号码',dataIndex: 'mobile',sortable: true}, \n            {header: '详细地址',dataIndex: 'address',sortable: true}, \n            {header: 'qq号码',dataIndex: 'qq',sortable: true}, \n            {header: 'msn',dataIndex: 'msn',sortable: true}, \n            {header: '描述',dataIndex: 'description'}, \n            {header: '创建时间',dataIndex: 'createDatetime',sortable: true}, \n            {header: '操作',dataIndex: 'operate',renderer: examineLabel},\n           {header: '授权',dataIndex: 'operate1',sortable: true,renderer:authorization}\n        ]);\n    }else{\n        cm=new Ext.grid.ColumnModel([\n            new Ext.grid.RowNumberer(), \n            sm,\n            {header: '账号',dataIndex: 'id',sortable: true}, \n            {header: '电子邮件',dataIndex: 'email',sortable: true}, \n            {header: '真实姓名',dataIndex: 'trueName',sortable: true}, \n            {header: '性别',dataIndex: 'sex',sortable: true}, \n            {header: '密码',dataIndex: 'password'}, \n            {header: '电话号码',dataIndex: 'telephone',sortable: true}, \n            {header: '传真',dataIndex: 'fax',sortable: true}, \n            {header: '公司名称',dataIndex: 'company',sortable: true}, \n            {header: '手机号码',dataIndex: 'mobile',sortable: true}, \n            {header: '详细地址',dataIndex: 'address',sortable: true}, \n            {header: 'qq号码',dataIndex: 'qq',sortable: true}, \n            {header: 'msn',dataIndex: 'msn',sortable: true}, \n            {header: '描述',dataIndex: 'description'}, \n            {header: '创建时间',dataIndex: 'createDatetime',sortable: true}, \n            {header: '操作',dataIndex: 'operate',renderer: examineLabel}\n        ]);\n    }\n    var grid = new Ext.grid.GridPanel({\n        id: id,\n        closable: true,\n        ds: ds,\n        cm: cm,\n        sm:sm,\n        viewConfig: {forceFit: true},\n        width: 1000,\n        height: 2000,\n        loadMask: {msg: '正在加载数据，请稍侯……'},\n        title: title,\n        frame: true,\n        renderTo: 'mylabel',\n        tbar: [{\n            text: '删除',\n            tooltip: '删除选中的项目',\n            //          iconCls:'remove',\n            handler: function(){\n                var selectedRows = grid.getSelectionModel().getSelections();\n                var ids = [];\n                for(var i=0;i<selectedrows.length;i++){ var=\"\" item=\"selectedRows[i].data;\" ids.push(item.id);=\"\" }=\"\" if(ids.join('')=\"=''){Ext.MessageBox.alert('警告',\" '必须选择一条记i录，进行删除!');return;}=\"\" ext.messagebox.confirm('提示框',=\"\" '你确定要进行该操作吗？!',=\"\" function(btn){=\"\" if=\"\" (btn=\"=\" 'yes')=\"\" {=\"\" ext.lib.ajax.request(=\"\" 'post',=\"\" 'usermanage.jsp',=\"\" {=\"\" success:=\"\" function(e,=\"\" b){=\"\" var=\"\" message=\"e.responseText;\" ext.msg.alert('信息',=\"\" message);=\"\" ds.load({=\"\" params:=\"\" {=\"\" start:=\"\" 0,=\"\" limit:=\"\" 10=\"\" }=\"\" });=\"\" },=\"\" failure:=\"\" function(){=\"\" ext.msg.alert('错误',=\"\" '删除时出现未知的错误');=\"\" }=\"\" },=\"\" 'command=\"delete&amp;ids='\" +=\"\" ids=\"\" );=\"\" }=\"\" });=\"\" }=\"\" },=\"\" '-',=\"\" {=\"\" id:=\"\" 'newwindowbutton',=\"\" text:=\"\" '新面板中添加',=\"\" iconcls:'user_add',=\"\" handler:=\"\" function(){=\"\" showmemeraddwindow();=\"\" 显示表单所在窗体=\"\" }=\"\" },'-',new=\"\" ext.form.combobox({=\"\" listclass:'x-combo-list-small',=\"\" width:120,=\"\" value:'请选择一种用户类型',=\"\" id:'search-type',=\"\" store:susername=\"='admin'?\" new=\"\" ext.data.simplestore({=\"\" fields:=\"\" ['text'],=\"\" expanddata:=\"\" true,=\"\" data=\"\" :=\"\" ['请选择一种用户类型','普通用户',=\"\" '代理商用户',=\"\" '商户用户']=\"\" }):new=\"\" ext.data.simplestore({=\"\" fields:=\"\" ['text'],=\"\" expanddata:=\"\" true,=\"\" data=\"\" :=\"\" ['请选择一种用户类型',=\"\" '商户用户']=\"\" }),=\"\" displayfield:=\"\" 'text',=\"\" mode:=\"\" 'local',=\"\" forceselection:=\"\" true,=\"\" triggeraction:=\"\" 'all',=\"\" selectonfocus:true=\"\" }),'-',new=\"\" ext.form.textfield({=\"\" fieldlabel:=\"\" '',=\"\" name:=\"\" 'idofsearch',=\"\" anchor:=\"\" '90%'=\"\" }),{=\"\" text:=\"\" '查询',=\"\" tooltip:=\"\" '删除选中的项目',=\"\" handler:=\"\" function(){=\"\" var=\"\" searchtype=\"Ext.get(&quot;search-type&quot;).getValue();\" if(searchtype=\"='请选择一种用户类型'){\" searchtype=\"null;\" }else=\"\" if(searchtype=\"='普通用户'){\" searchtype=\"0;\" }else=\"\" if(searchtype=\"='代理商用户'){\" searchtype=\"1;\" }else=\"\" if(searchtype=\"='商户用户'){\" searchtype=\"2;\" }=\"\" var=\"\" idofsearch=\"Ext.get(&quot;idOfSearch&quot;).getValue();\" ds.baseparams.usertype=\"searchType;\" ds.baseparams.idofsearch=\"idOfSearch;\" if=\"\" (searchtype=\"\" !=\"null)\" {=\"\" ds.baseparams.command=\"search\" ;=\"\" }else{=\"\" ds.baseparams.command=\"query\" ;=\"\" }=\"\" ds.load({=\"\" params:=\"\" {=\"\" start:=\"\" 0,=\"\" limit:=\"\" 10=\"\" }=\"\" });=\"\" }=\"\" },'-'=\"\" ],=\"\" bbar:=\"\" new=\"\" ext.pagingtoolbar({=\"\" pagesize:=\"\" 10,=\"\" store:=\"\" ds,=\"\" displayinfo:=\"\" true,=\"\" displaymsg:=\"\" '显示第=\"\" {0}=\"\" 条到=\"\" {1}=\"\" 条记录，一共=\"\" {2}=\"\" 条',=\"\" emptymsg:=\"\" \"没有记录\"=\"\" })=\"\" });=\"\" grid.render();=\"\" ds.load({=\"\" params:=\"\" {=\"\" start:=\"\" 0,=\"\" limit:=\"\" 10=\"\" }=\"\" });=\"\" return=\"\" grid;=\"\" }<=\"\" pre=\"\">\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;新写一个排名次函数 void rank() ,实现按总分从高到低排名&amp;#xff0c;总分相同的排名相同&amp;#xff0c;因为链表是动态的&amp;#xff0c;随时增加记录&amp;#xff0c;所以排名次放在输入函数里不合适。同时建议将 void savestudent() 保存学生信息函数不单列在菜单里&amp;#xff0c;将它放在退出程序前运行更合理&amp;#xff0c;将 void readstudent() 读取学生信息函数移动到程序代码的开始处&amp;#xff0c;加载一次即可&amp;#xff0c;同时&amp;#xff0c;已将这两个函数及其他函数做了完善修改。供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;conio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 4        &lt;span class=\"hljs-comment\"&gt;//修改 课程数目 &lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;stu&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt;  stuID;     &lt;span class=\"hljs-comment\"&gt;//学号&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;  stuname[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//名字&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;  stusex;  &lt;span class=\"hljs-comment\"&gt;//性别&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;   score[N]; &lt;span class=\"hljs-comment\"&gt;//分数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;   total;   &lt;span class=\"hljs-comment\"&gt;//总分&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; aver;    &lt;span class=\"hljs-comment\"&gt;//平均分  int&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;   line;    &lt;span class=\"hljs-comment\"&gt;//排名&lt;/span&gt;\n}STU;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;node&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;//创建结点类型&lt;/span&gt;\n{\n    STU stu;                &lt;span class=\"hljs-comment\"&gt;//数据域&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;node&lt;/span&gt;* next;   &lt;span class=\"hljs-comment\"&gt;//指向下一个节点的指针&lt;/span&gt;\n}NODE;\nNODE* head &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//定义头指针&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//NODE* creatlist();&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;start&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;inputstudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;savestudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;readstudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printfstudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;rank&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;         &lt;span class=\"hljs-comment\"&gt;//排名次函数&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//int arr[100] &amp;#61; { 1 };//存每名学生的名次   修改&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;start&lt;/span&gt;();\n        &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch &amp;#61; _getch();\n        &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt; (ch)\n        {\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;: &lt;span class=\"hljs-comment\"&gt;//录入学生信息&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;inputstudent&lt;/span&gt;();  &lt;span class=\"hljs-comment\"&gt;//inputstudent(stu);  修改&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;rank&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;//保存学生信息&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;savestudent&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-comment\"&gt;//读取学生信息&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;readstudent&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;//打印学生成绩&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;printfstudent&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;5&amp;#39;&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;//按总分由高到低排出名次&lt;/span&gt;\n\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;6&amp;#39;&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;//按总分由低到高排出名次&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;7&amp;#39;&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;//按学号由小到大排出成绩表&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;8&amp;#39;&lt;/span&gt;:  &lt;span class=\"hljs-comment\"&gt;//按姓名字典顺序排序排出成绩表&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;start&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*****************************************\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;欢迎使用学生成绩管理系统                *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*1.录入学生信息                         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*2.保存学生信息                         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*3.读取学生信息                         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*4.打印学生信息                         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*5.按总分由高到低排出名次               *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*6.按总分由低到高排出名次               *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*7.按学号由小到大排出成绩表             *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*8.按姓名字典顺序排序排出成绩表         *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*9.根据学号查询学生成绩及排名           *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*0.根据姓名查询学生成绩及排名           *\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;*****************************************\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-function\"&gt;NODE* &lt;span class=\"hljs-title\"&gt;creatlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;    &lt;span class=\"hljs-comment\"&gt;//创建表头表示整个链表即创建链表&amp;#xff08;表头可以是头结点&amp;#xff0c;也可以是数据结点&amp;#xff0c;通常是头结点&amp;#xff09;&lt;/span&gt;\n&lt;/span&gt;{\n    NODE* headNode &amp;#61; (NODE*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(NODE));\n    headNode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; headNode;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;inputstudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;  \n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  i;\n    NODE* newnode &amp;#61; (NODE*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(NODE));\n    newnode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;学号&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%ld&amp;#34;&lt;/span&gt;, &amp;amp;newnode-&amp;gt;stu.stuID);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, newnode-&amp;gt;stu.stuname, &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;性别&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; %c&amp;#34;&lt;/span&gt;, &amp;amp;newnode-&amp;gt;stu.stusex, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d门课程成绩&amp;#xff1a;&amp;#34;&lt;/span&gt;, N);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, newnode-&amp;gt;stu.total &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;newnode-&amp;gt;stu.score[i]);\n        newnode-&amp;gt;stu.total &amp;#43;&amp;#61; newnode-&amp;gt;stu.score[i];\n    }\n    newnode-&amp;gt;stu.aver &amp;#61; (&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;)(newnode-&amp;gt;stu.total / N);\n\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;//以下代码&amp;#xff0c;实现输入每个学生信息后&amp;#xff0c;按总分从高到低链入链表&lt;/span&gt;\n        head &amp;#61; newnode;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n        NODE* p &amp;#61; head; \n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p-&amp;gt;next &amp;amp;&amp;amp; p-&amp;gt;next-&amp;gt;stu.total &amp;gt; newnode-&amp;gt;stu.total)  p &amp;#61; p-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p &amp;#61;&amp;#61; head &amp;amp;&amp;amp; p-&amp;gt;stu.total &amp;lt; newnode-&amp;gt;stu.total) {\n            newnode-&amp;gt;next &amp;#61; head;\n            head &amp;#61; newnode;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            newnode-&amp;gt;next &amp;#61; p-&amp;gt;next;\n            p-&amp;gt;next &amp;#61; newnode;\n        }\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;savestudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;    &lt;span class=\"hljs-comment\"&gt;//保存学生信息&lt;/span&gt;\n&lt;/span&gt;{\n    FILE* pf &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pph.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//创建并打开文件&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pf &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//判断打开文件是否失败&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;打开文件失败\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    NODE* p &amp;#61; head;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(&amp;amp;p-&amp;gt;stu, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(STU), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf);  \n        p &amp;#61; p-&amp;gt;next;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(pf);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;数据保存成功\\n&amp;#34;&lt;/span&gt;);\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;readstudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;//读取学生信息&lt;/span&gt;\n&lt;/span&gt;{\n    FILE* pf &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pph.txt&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;//打开文件&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pf &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//判断打开文件是否失败&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;err!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    NODE* pt &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)  \n    {\n        NODE* newnode &amp;#61; (NODE*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(NODE));\n        newnode-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(&amp;amp;newnode-&amp;gt;stu, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(STU), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf) !&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) { \n            &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(newnode);                                   \n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }                                                   \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n            head &amp;#61; newnode;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!pt) {\n                pt &amp;#61; head;\n                &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pt-&amp;gt;next) pt &amp;#61; pt-&amp;gt;next;\n            }\n            pt-&amp;gt;next &amp;#61; newnode;\n            pt &amp;#61; newnode;\n        }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(pf);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;加载数据成功\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printfstudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    NODE* P &amp;#61; head;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (P !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%ld %s %c&amp;#34;&lt;/span&gt;, P-&amp;gt;stu.stuID, P-&amp;gt;stu.stuname, P-&amp;gt;stu.stusex);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; N; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; %d&amp;#34;&lt;/span&gt;, P-&amp;gt;stu.score[i]);\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; %d %.2f %d\\n&amp;#34;&lt;/span&gt;, P-&amp;gt;stu.total, P-&amp;gt;stu.aver, P-&amp;gt;stu.line);\n        P &amp;#61; P-&amp;gt;next;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;rank&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;   &lt;span class=\"hljs-comment\"&gt;// 排名次函数&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;   k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    NODE* P &amp;#61; head, * pre &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (P !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (P &amp;#61;&amp;#61; head)\n            k&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pre-&amp;gt;stu.total !&amp;#61; P-&amp;gt;stu.total) {\n            k&amp;#43;&amp;#43;;\n        }\n        P-&amp;gt;stu.line &amp;#61; k;\n        pre &amp;#61; P;\n        P &amp;#61; P-&amp;gt;next;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["想在122-125行之间实现实时给学生的总分数排名词", ["#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<conio.h>", "\n", "#", "include", " ", "<string.h>", "\n", "typedef", " ", "struct", " ", "stu", "\n{\n    ", "long", " stuID;     ", "//学号", "\n    ", "char", " stuname[", "10", "];    ", "//名字", "\n    ", "char", " stusex;     ", "//性别", "\n    ", "int", " score[", "4", "];    ", "//分数", "\n    ", "int", " total;   ", "//总分", "\n    ", "int", " aver;    ", "//平均分", "\n    ", "int", " line;   ", "//排名", "\n}STU;\n", "typedef", " ", "struct", " ", "node", "   ", "//创建结点类型", "\n{\n    STU stu;                ", "//数据域", "\n    ", "struct", " ", "node", "* next;   ", "//指向下一个节点的指针", "\n}NODE;\nNODE* head = ", "NULL", ";  ", "//定义头指针", "\n\n", "NODE* ", "creatlist", "()", ";\n\n\n", "void", " ", "start", "()", ";\n", "void", " ", "inputstudent", "()", "; ", "//void inputstudent(STU stu[]);  修改", "\n", "void", " ", "savestudent", "()", ";\n", "void", " ", "readstudent", "()", ";\n", "void", " ", "printfstudent", "()", ";\n\n\n", "//#define N 30                   修改 ", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " arr[", "100", "] = { ", "1", " };    ", "//存每名学生的名次  ", "\n    ", "//NODE* list = creatlist(); //修改", "\n    ", "//STU stu[N];               //修改", "\n    ", "int", " m = ", "4", ";\n    ", "while", " (", "1", ")\n    {\n        ", "start", "();\n        ", "char", " ch = _getch();\n        ", "switch", " (ch)\n        {\n        ", "case", " ", "'1'", ": ", "//录入学生信息", "\n            ", "inputstudent", "();  ", "//inputstudent(stu);  修改", "\n            ", "break", ";\n        ", "case", " ", "'2'", ":  ", "//保存学生信息", "\n            ", "savestudent", "();\n            ", "break", ";\n        ", "case", " ", "'3'", ":", "//读取学生信息", "\n            ", "readstudent", "();\n            ", "break", ";\n        ", "case", " ", "'4'", ":  ", "//打印学生成绩", "\n            ", "printfstudent", "();\n            ", "break", ";\n        ", "case", " ", "'5'", ":  ", "//按总分由高到低排出名次", "\n          \n            ", "break", ";\n        ", "case", " ", "'6'", ":  ", "//按总分由低到高排出名次", "\n            ", "break", ";\n        ", "case", " ", "'7'", ":  ", "//按学号由小到大排出成绩表", "\n            ", "break", ";\n        ", "case", " ", "'8'", ":  ", "//按姓名字典顺序排序排出成绩表", "\n            ", "break", ";\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n\n", "void", " ", "start", "()", "\n", "{\n    ", "printf", "(", "\"*****************************************\\n\"", ");\n    ", "printf", "(", "\"欢迎使用学生成绩管理系统                *\\n\"", ");\n    ", "printf", "(", "\"*1.录入学生信息                         *\\n\"", ");\n    ", "printf", "(", "\"*2.保存学生信息                         *\\n\"", ");\n    ", "printf", "(", "\"*3.读取学生信息                         *\\n\"", ");\n    ", "printf", "(", "\"*4.打印学生信息                         *\\n\"", ");\n    ", "printf", "(", "\"*5.按总分由高到低排出名次               *\\n\"", ");\n    ", "printf", "(", "\"*6.按总分由低到高排出名次               *\\n\"", ");\n    ", "printf", "(", "\"*7.按学号由小到大排出成绩表             *\\n\"", ");\n    ", "printf", "(", "\"*8.按姓名字典顺序排序排出成绩表         *\\n\"", ");\n    ", "printf", "(", "\"*9.根据学号查询学生成绩及排名           *\\n\"", ");\n    ", "printf", "(", "\"*0.根据姓名查询学生成绩及排名           *\\n\"", ");\n    ", "printf", "(", "\"*****************************************\\n\"", ");\n}\n\n", "NODE* ", "creatlist", "()", "    ", "//创建表头表示整个链表即创建链表（表头可以是头结点，也可以是数据结点，通常是头结点）", "\n", "{\n    NODE* headNode = (NODE*)", "malloc", "(", "sizeof", "(NODE));\n    headNode->next = ", "NULL", ";\n    ", "return", " headNode;\n}\n\n\n", "void", " ", "inputstudent", "()", "   ", "//void inputstudent(STU stu[])  修改", "\n", "{\n   \n    NODE* newnode = (NODE*)", "malloc", "(", "sizeof", "(NODE)); ", "//创建一个新结点来作头结点，使newnode这个指针可以通过->来当作结构体变量来用", "\n    newnode->next = ", "NULL", ";\n    ", "if", " (head == ", "NULL", ")   ", "//遍历", "\n    {\n        head = newnode;\n    }\n    ", "else", "\n    {\n        newnode->next = head;\n        head = newnode;\n    }\n    ", "printf", "(", "\"学号：\"", ");\n    ", "scanf_s", "(", "\"%ld\"", ", &newnode->stu.stuID);\n    ", "printf", "(", "\"姓名：\"", ");\n    ", "scanf_s", "(", "\"%s\"", ", newnode->stu.stuname, ", "10", ");\n    ", "printf", "(", "\"性别：\"", ");\n    ", "scanf_s", "(", "\" %c\"", ", &newnode->stu.stusex, ", "1", ");\n    ", "printf", "(", "\"成绩：\"", ");\n    ", "scanf_s", "(", "\"%d %d %d %d\"", ", &newnode->stu.score[", "0", "], &newnode->stu.score[", "1", "], &newnode->stu.score[", "2", "], &newnode->stu.score[", "3", "]);\n    newnode->stu.total = newnode->stu.score[", "0", "] + newnode->stu.score[", "1", "] + newnode->stu.score[", "2", "] + newnode->stu.score[", "3", "];\n    ", "printf", "(", "\"总分：%d\\n\"", ", newnode->stu.total);\n    newnode->stu.aver = (newnode->stu.score[", "0", "] + newnode->stu.score[", "1", "] + newnode->stu.score[", "2", "] + newnode->stu.score[", "3", "]) / ", "4.0", ";\n    ", "printf", "(", "\"平均分：%d\\n\"", ", newnode->stu.aver);\n     ", "// if (newnode->next->stu.total > newnode->stu.total)", "\n     ", "//   newnode->next->stu.line++;", "\n    ", "printf", "(", "\"名次：%d\"", ", newnode->stu.line);\n}\n\n", "void", " ", "savestudent", "()", "    ", "//保存学生信息", "\n", "{\n    FILE* pf = ", "fopen", "(", "\"pph.txt\"", ", ", "\"w\"", "); ", "//创建并打开文件", "\n    ", "if", " (pf == ", "NULL", ") ", "//判断打开文件是否失败", "\n    {\n        ", "printf", "(", "\"打开文件失败\\n\"", ");\n        ", "return", ";\n    }\n    NODE* p = head;\n    ", "while", " (p != ", "NULL", ")\n    {\n        ", "fwrite", "(&p->stu, ", "sizeof", "(STU), ", "1", ", pf);   ", "//修改", "\n        ", "//fwrite(&p->stu, 1, sizeof(STU), pf); //修改", "\n        p = p->next;\n    }\n    ", "fclose", "(pf);\n    ", "printf", "(", "\"数据保存成功\\n\"", ");\n}\n\n\n", "void", " ", "readstudent", "()", "   ", "//读取学生信息", "\n", "{\n    FILE* pf = ", "fopen", "(", "\"pph.txt\"", ", ", "\"r\"", ");  ", "//打开文件", "\n    ", "if", " (pf == ", "NULL", ") ", "//判断打开文件是否失败", "\n    {\n        ", "printf", "(", "\"err!\\n\"", ");\n        ", "return", ";\n    }\n    ", "while", " (", "1", ")  ", "//(!feof(pf))   修改", "\n    {\n        NODE* newnode = (NODE*)", "malloc", "(", "sizeof", "(NODE));\n        newnode->next = ", "NULL", ";\n        ", "if", " (", "fread", "(&newnode->stu, ", "sizeof", "(STU), ", "1", ", pf) != ", "1", ") { ", "//fread(&newnode->stu, 1, sizeof(STU), pf);", "\n            ", "free", "(newnode);                                   ", "//修改", "\n            ", "break", ";\n        }                                                   ", "//修改", "\n        ", "//头插法", "\n        ", "if", " (head == ", "NULL", ")\n        {\n            head = newnode;\n        }\n        ", "else", "\n        {\n            newnode->next = head;\n            head = newnode;\n        }\n    }\n    ", "printf", "(", "\"加载数据成功\\n\"", ");\n    ", "fclose", "(pf);\n}\n", "void", " ", "printfstudent", "()", "\n", "{\n    NODE* P = head;   \n    ", "while", " (P != ", "NULL", ")\n    {\n        ", "printf", "(", "\"%ld %s %c %d %d %d %d %d %d %d\"", ", P->stu.stuID, P->stu.stuname, P->stu.stusex, \n            P->stu.score[", "0", "], P->stu.score[", "1", "], P->stu.score[", "2", "], P->stu.score[", "3", "],P->stu.total, P->stu.aver); ", "//修改", "\n        P = P->next;\n        ", "break", ";\n    }\n    ", "system", "(", "\"pause\"", ");\n}\n", "\n", "想在122-125行之间实现实时给学生的总分数排名词，如何实现？"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你可以看下这个问题的回答&lt;a href=\"https://ask.csdn.net/questions/7537008\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7537008&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "定义新的类型", "Question": ["数据结构二叉树修改BUG", ["\n", "//删除整棵子树有点问题", "\n", "/*\nleft                        长子\nleft的parent                双亲\nright                        下一个兄弟\nright的parent                是上一个兄弟\np=p1->parent;\nif(p->left == p1) p就是p1的双亲\nif(p->right == p1) p就是p1的上一个兄弟\n*/", "\n#", "include", " ", "\"stdlib.h\"", "\n#", "include", " ", "\"string.h\"", "\n#", "include", "\"stdio.h\"", "\n#define MAX ", "1500", "\n", "struct", " Category {", "//类别节点", "\n    ", "int", " cate_id, parent_cid,\n        cate_level, show_status, sort;\n    ", "char", " name", "[", "40", "]", ";\n};\n", "struct", " Tree {", "//树节点", "\n    Tree* left;\n    Tree* right;\n    Tree* parent;\n    Category* data;\n};\n", "struct", " DNode {  ", "//双向链表节点", "\n    DNode* prev;\n    DNode* next;\n    Category* data;", "//T *data;", "\n};\n", "struct", " DList {", "//双向链表", "\n    DNode* p_head,", " * ", "p_end;\n    ", "int", " length;\n};\n", "/*\n功能：双向链表的初始化\n返回值：双向链表指针\n*/", "\nDList* init", "DList()", " {\n    DList* p;\n    p = (DList*)malloc(sizeof(DList));", "//双向链表数据，不是双向链表中节点数据", "\n    ", "//设置p成员", "\n    p->p_head = (DNode*)malloc(sizeof(DNode));\n    p->p_end = (DNode*)malloc(sizeof(DNode));\n    p->length = ", "0", ";\n    ", "//设置p->p_head表头节点的成员", "\n    p->p_head->prev = NULL;\n    p->p_head->next = p->p_end;\n    ", "//设置p->p_head表尾节点的成员", "\n    p->p_end->next = NULL;\n    p->p_end->prev = p->p_head;\n    return p;\n}\n", "//以下三个函数是同一类型的函数", "\n", "/*\n功能：\n参数：\n作者：\n时间：\n*/", "\nvoid display", "Category(Category", "*", " ", "p", ")", " {\n    printf(", "\"%d\\t%s\\t%d\\t%d\\t%d\\t%d\\n\"", ", p->cate_id, p->name, p->parent_cid, p->cate_level, p->show_status, p->sort);\n}\nvoid display", "CategoryName(Category", "*", " ", "p", ")", " {\n    printf(", "\"%s\\n\"", ", p->name);\n}\nvoid display", "CategoryIdName(Category", "*", " ", "p", ")", " {\n    printf(", "\"%d.%s\\n\"", ", p->cate_id, p->name);\n}\nvoid display", "List(DList", "*", " ", "pList", ")", " {\n    DNode* p1 = pList->p_head->next;\n    ", "while", " (p1 != pList->p_end) {\n        display", "Category(", "p1", "->", "data", ")", ";\n        p1 = p1->next;\n    }\n}\n", "/*\n以下两个函数是同一类型的函数（）\nint add(int, int) {}\nint sub(int, int) {}\n*/", "\n", "//函数指针做另一个函数的参数，实参是函数名，作用是选择执行哪个函数", "\nvoid display", "List(DList", "*", " ", "pList", ", ", "void", " (", "*", "fn", ")", "(Category*)) {\n    DNode* p1 = pList->p_head->next;\n    ", "while", " (p1 != pList->p_end) {\n        fn(p1->data);\n        p1 = p1->next;\n    }\n}\n", "/*\n功能：构建成绩节点\n*/", "\nCategory* ", "new", "Category(", "int", " ", "cate_id", ", ", "char", "*", " ", "name", ", ", "int", " ", "parent_cid", ", ", "int", " ", "cate_level", ", ", "int", " ", "show_status", ", ", "int", " ", "sort", ")", " {\n    Category* p;\n    p = (Category*)malloc(sizeof(Category));\n    ", "if", " (p", " == ", "NULL)return NULL;\n    p->cate_id = cate_id;\n    strcpy", "_s(", "p", "->", "name", ", ", "name", ")", ";\n    p->parent_cid = parent_cid;\n    p->cate_level = cate_level;\n    p->show_status = show_status;\n    p->sort = sort;\n    return p;\n}\nCategory* ", "new", "Category()", " {\n    Category* p;\n    p = (Category*)malloc(sizeof(Category));\n    ", "if", " (p", " == ", "NULL)return NULL;\n    return p;\n}\n", "/*\n构建链表节点\n*/", "\nDNode* ", "new", "DNode(", "int", " ", "cate_id", ", ", "char", "*", " ", "name", ", ", "int", " ", "parent_cid", ", ", "int", " ", "cate_level", ", ", "int", " ", "show_status", ", ", "int", " ", "sort", ")", " {\n    DNode* pDNode;\n    Category* p_cate;\n    ", "//申请struct Score,初始化成绩数据", "\n    p_cate = ", "new", "Category(", "cate_id", ", ", "name", ", ", "parent_cid", ", ", "cate_level", ", ", "show_status", ", ", "sort", ")", ";\n\n    ", "//申请struct DNode<struct Score*>", "\n    pDNode = (DNode*)malloc(sizeof(DNode));\n    ", "if", " (p_cate != NULL", " && ", "pDNode != NULL) {\n        ", "//初始化链表节点", "\n        pDNode->prev = pDNode->next = NULL;\n        pDNode->data = p_cate;\n    }\n    return pDNode;\n}\nDNode* ", "new", "DNode()", " {\n    DNode* pDNode;\n\n    ", "//申请struct DNode<struct Score*>", "\n    pDNode = (DNode*)malloc(sizeof(DNode));\n\n    pDNode->prev = pDNode->next = NULL;\n    pDNode->data = NULL;\n    return pDNode;\n}\n", "/*\n功能：链表节点插入\n参数：\npList:链表指针\np1:插入位置(p1之前)\np2:待插节点\n*/", "\nvoid insert", "Node(DList", "*", " ", "pList", ", DNode", "*", " ", "p1", ", DNode", "*", " ", "p2", ")", " {\n\n    ", "if", " (p1", " == ", "NULL", " || ", "p1->prev", " == ", "NULL) {\n        printf(", "\"插入位置设置错误！\\n\"", ");\n        return;\n    }\n    ", "if", " (p2", " == ", "NULL) {\n        printf(", "\"待插节点不能为空！\\n\"", ");\n    }\n    p2->next = p1;\n    p2->prev = p1->prev;\n    p1->prev->next = p2;\n    p1->prev = p2;\n    pList->length++;\n}\n", "/*\n功能：读取文件中类别数据放入到链表中\n入口参数：\nfileName：文件名\ncate_level：类别层次\n返回值：新生成的双向链表的指针\n\n*/", "\nDList* read", "File(", "char", "*", " ", "fileName", ")", " {\n    DList* p_list;\n    p_list = init", "DList()", ";\n    FILE* fp2 = fopen(fileName, ", "\"r\"", ");\n\n    ", "if", " (fp2", " == ", "NULL) {\n        printf(", "\"文件读打开失败！\"", ");\n        return p_list;\n    }\n    DNode* p_new;\n    Category* p;\n    ", "char", " str", "[", "100", "]", ";\n    fgets(str, ", "100", ", fp2);\n    ", "int", " i = ", "0", ";\n    ", "while", " (!feof(fp2)) {\n        p = ", "new", "Category()", ";\n        fscanf(fp2, ", "\"%d\\t%s\\t%d\\t%d\\t%d\\t%d\\n\"", ",\n            &p->cate_id, p->name, &p->parent_cid, &p->cate_level, &p->show_status, &p->sort);\n#ifdef debug\n        display", "Category(", "p", ")", ";\n#endif\n        p_new = ", "new", "DNode()", ";\n        p_new->data = p;\n        insert", "Node(", "p_list", ", ", "p_list", "->", "p_end", ", ", "p_new", ")", ";\n#ifdef debug\n        ", "if", " (++i", " == ", "MAX)\n            break;\n#endif\n    }\n    fclose(fp2);\n    printf(", "\"===========end of readFile==========\\n\"", ");\n    return p_list;\n}\nTree* ", "new", "TreeNode()", " {\n    Tree* p = (Tree*)malloc(sizeof(Tree));\n    p->parent = NULL;\n    p->left = NULL;\n    p->right = NULL;\n    p->data = NULL;\n    return p;\n}\nTree* ", "new", "TreeNode(Category", "*", " ", "data", ")", " {\n    Tree* p = (Tree*)malloc(sizeof(Tree));\n    p->parent = NULL;\n    p->left = NULL;\n    p->right = NULL;\n    p->data = data;\n    return p;\n}\nTree* ", "new", "TreeNode(Tree", "*", " ", "left", ", Tree", "*", " ", "parent", ", Tree", "*", " ", "right", ", Category", "*", " ", "data", ")", " {\n    Tree* p = (Tree*)malloc(sizeof(Tree));\n    p->parent = parent;\n    p->left = left;\n    p->right = right;\n    p->data = data;\n    return p;\n}\nTree* init", "Tree()", " {\n    Tree* root = ", "new", "TreeNode()", ";\n    root->data = (Category*)malloc(sizeof(Category));\n    root->data->cate_id = ", "0", ";\n    return root;\n}\n", "//使用递归查找，链表节点是按树节点生成的顺序提供的。", "\n", "/*\n功能：在root为根的树中，查找节点，条件：节点->data->cate_id==cid\n入口参数：root指向树\n入口参数：cid树中节点的类别ID\n返回:树节点指针\n*/", "\nTree* find", "ByCID(Tree", "*", " ", "root", ", ", "int", " ", "cid", ")", " {\n    Tree* p = root,", " * ", "pLeft,", " * ", "pRight;\n    ", "if", " (root", " == ", "NULL)return NULL;\n    ", "if", " (p->data->cate_id", " == ", "cid) return p;\n    pLeft = find", "ByCID(", "root", "->", "left", ", ", "cid", ")", ";\n    pRight = find", "ByCID(", "root", "->", "right", ", ", "cid", ")", ";\n    ", "if", " (pLeft)return pLeft;\n    ", "else", " return pRight;\n}\n", "//查找违背树的逻辑性的节点", "\nvoid find", "BadNodes(DList", "*", " ", "list", ")", " {\n    DNode* p1,", " * ", "p2,", " * ", "pHead;\n\n    pHead = ", "list", "->p_head->next;\n    p1 = pHead->next;", "//第二个节点", "\n\n    ", "while", " (p1 != ", "list", "->p_end) {\n        p2 = pHead;\n        ", "int", " pid = p1->data->parent_cid;\n        ", "while", " (pid > ", "0", " && ", "p2 != p1) {\n            ", "if", " (p2->data->cate_id", " == ", "pid) {\n                break;\n            }\n            p2 = p2->next;\n        }\n        ", "if", " (p2", " == ", "p1) {\n            printf(", "\"****\"", "); display", "CategoryIdName(", "p1", "->", "data", ")", ";\n        }\n        p1 = p1->next;\n    }\n}\n", "/*\n功能：根据链表数据构建树\n*/", "\nvoid create", "Tree(Tree", "*", " ", "root", ", DList", "*", " ", "list", ")", " {\n    DNode* pDNode;\n    Tree* pTreeNode,", " * ", "pTree = NULL;", "//工作指针pTree指向最近产生的节点", "\n    ", "//遍历链表节点", "\n    pDNode = ", "list", "->p_head->next;", "//pDNode指向头节点", "\n    ", "while", " (pDNode != ", "list", "->p_end) {\n#ifdef debug\n        display", "CategoryName(", "pDNode", "->", "data", ")", ";\n#endif\n        ", "//创建树节点--用链表中数据", "\n        pTreeNode = ", "new", "TreeNode(", "pDNode", "->", "data", ")", ";\n        ", "//找pTreeNode双亲节点", "\n        ", "int", " parent_cid = pDNode->data->parent_cid;\n\n        ", "if", " (pTree", " && ", "pTree->data->parent_cid", " == ", "parent_cid) {", "//遇到兄弟", "\n            pTree->right = pTreeNode;\n            pTreeNode->parent = pTree;\n        }\n        ", "else", " {", "//长子节点", "\n            pTree = find", "ByCID(", "root", ", ", "parent_cid", ")", ";", "//没遇到兄弟,找双亲", "\n            ", "if", " (pTree->left", " == ", "NULL) {", "//无长子", "\n                pTree->left = pTreeNode;\n                pTreeNode->parent = pTree;\n            }\n            ", "else", " {", "//有长子，找左子树的右链尾，插入新节点pTreeNode", "\n                pTree = pTree->left;", "//从长子开始，长子是兄弟链的头节点", "\n                ", "while", " (pTree->right) {\n                    pTree = pTree->right;\n                }\n                pTree->right = pTreeNode;", "//退出循环的时候，pTree指向尾节点", "\n                pTreeNode->parent = pTree;\n            }\n        }\n        pTree = pTreeNode;", "//下次可能会用到（遇到兄弟）", "\n        pDNode = pDNode->next;\n    }\n}\nvoid display", "Tree(Tree", "*", " ", "root", ", ", "int", " ", "indent", ", ", "int", " ", "indent0", ")", " {\n    ", "if", " (root", " == ", "NULL)return;", "//1.递归出口", "\n\n    ", "if", " (root->data->cate_id > ", "0", ") {\n        printf(", "\"%*s\"", ", indent, ", "\"\"", ");\n        display", "CategoryIdName(", "root", "->", "data", ")", ";\n    }\n    display", "Tree(", "root", "->", "left", ", ", "indent", " + ", "indent0", ", ", "indent0", ")", ";\n    display", "Tree(", "root", "->", "right", ", ", "indent", ", ", "indent0", ")", ";\n}\n", "/*\n显示根节点和根的左子树所有节点\n*/", "\nvoid display", "RootAndLeft(Tree", "*", " ", "root", ", ", "int", " ", "indent", ", ", "int", " ", "indent0", ")", " {\n    ", "if", " (root", " == ", "NULL)return;\n\n    ", "if", " (root->data->cate_id > ", "0", ") {\n        printf(", "\"%*s\"", ", indent, ", "\"\"", ");\n        display", "CategoryIdName(", "root", "->", "data", ")", ";\n    }\n    display", "Tree(", "root", "->", "left", ", ", "indent", " + ", "indent0", ", ", "indent0", ")", ";\n}\nvoid insert", "TreeNode(Tree", "*", " ", "root", ", Category", "*", " ", "p", ")", " {\n    ", "//1.查找p节点的双亲节点", "\n    Tree* pParent = find", "ByCID(", "root", ", ", "p", "->", "parent_cid", ")", ";\n    Tree* pNode;\n    Tree* newNode = NULL;\n    ", "if", " (pParent) {\n        newNode = ", "new", "TreeNode(", "p", ")", ";\n    }\n    ", "else", " {\n        return;\n    }\n    ", "if", " (pParent", " && ", "pParent->left", " == ", "NULL) {", "//作为长子", "\n        pParent->left = newNode;\n        newNode->parent = pParent;\n    }\n    ", "else", " {", "//作为兄弟,放在右链尾节点的后面", "\n        pNode = pParent->left;", "//右链首", "\n        ", "while", " (pNode->right) {\n            pNode = pNode->right;\n        }\n        ", "//pNode就是右链尾节点", "\n        pNode->right = newNode;\n        newNode->parent = pNode;\n    }\n}\nvoid insert", "TreeNode(Tree", "*", " ", "root", ", ", "char", "*", " ", "data", ")", " {\n    Category* p = ", "new", "Category()", ";\n    scanf(data, ", "\"%d\\t%s\\t%d\\t%d\\t%d\\t%d\\n\"", ",\n        &p->cate_id, p->name, &p->parent_cid, &p->cate_level, &p->show_status, &p->sort);\n    insert", "TreeNode(", "root", ", ", "p", ")", ";\n}\n", "/*\n功能：在根为root树中，删除node节点\n*/", "\nvoid delete", "TreeNode(Tree", "*", " ", "root", ", Tree", "*", " ", "node", ")", " {\n    ", "if", " (node", " == ", "NULL) {\n        printf(", "\"node节点是空节点,不能删除\\n\"", ");\n        return;\n    }\n    ", "if", " (node", " == ", "root) {\n        printf(", "\"node节点是树根节点,不能删除\\n\"", ");\n        return;\n    }\n    ", "if", " (node->left) {\n        printf(", "\"node节点有子节点,不能删除\\n\"", ");\n        return;\n    }\n    ", "if", " (node->parent->left", " == ", "node) {", "//node->left==null", "\n        printf(", "\"正在删除长子节点\\n\"", ");\n        ", "if", " (node->right", " == ", "NULL) {", "//node->right==null,node是叶子节点", "\n            printf(", "\"正在删除长子节点是叶子节点\\n\"", ");\n            node->parent->left = NULL;\n        }\n        ", "else", " {", "//非叶子节点（有兄弟）", "\n            printf(", "\"正在删除长子节点是兄弟的节点\\n\"", ");\n            node->right->parent = node->parent;\n            node->parent->left = node->right;\n        }\n        delete node;\n        return;\n    }\n    ", "if", " (node->parent->right", " == ", "node) {\n        printf(", "\"正在删除兄弟节点\\n\"", ");\n        ", "if", " (node->right", " == ", "NULL) {\n            printf(", "\"正在删除最小兄弟节点\\n\"", ");\n            node->parent->right = NULL;\n        }\n        ", "else", " {\n            printf(", "\"正在删除中间兄弟节点\\n\"", ");\n            node->parent->right = node->right;\n            node->right->parent = node->parent;\n        }\n        delete node;\n        return;\n    }\n}\n", "//删除整棵子树？有无必要，如何删除（递归后续）", "\nvoid delete", "Tree(Tree", "*", " ", "root", ", Tree", "*", " ", "node", ")", " {\n    ", "if", " (node", " == ", "NULL) {\n        ", "//printf(\"node节点是空节点,不能删除\\n\");", "\n        return;\n    }\n    delete", "Tree(", "root", ", ", "node", "->", "left", ")", ";\n    delete", "Tree(", "root", ", ", "node", "->", "right", ")", ";\n    delete node;\n}\nvoid delete", "TreeAll(Tree", "*", " ", "root", ", Tree", "*", " ", "node", ")", " {\n    ", "if", " (node", " == ", "NULL) {\n        ", "//printf(\"node节点是空节点,不能删除\\n\");", "\n        return;\n    }\n    Tree* left = node->left;\n    delete", "TreeNode(", "root", ", ", "node", ")", ";\n    delete", "Tree(", "root", ", ", "node", "->", "left", ")", ";\n}\n", "int", " main", "()", " {\n    DList* pList;\n    ", "char", " C", "[", "17", "]", " = ", "\"pms_category.txt\"", ";\n    pList = read", "File(C)", ";\n    printf(", "\"=============displayList(pList);================\\n\"", ");\n    display", "List(", "pList", ")", ";\n    printf(", "\"=============findBadNodes(pList);================\\n\"", ");\n    find", "BadNodes(", "pList", ")", ";\n    Tree* root = init", "Tree()", ";\n    printf(", "\"=============createTree(root, pList);================\\n\"", ");\n    create", "Tree(", "root", ", ", "pList", ")", ";\n    Tree* subRoot = find", "ByCID(", "root", ", 37)", ";\n    display", "RootAndLeft(", "subRoot", ", 0, 4)", ";\n    ", "char", " L ", "[", "23", "]", " = ", "\"1424 手提音箱    37    3    1    0\"", ";\n    ", "char", " M", "[", "30", "]", " = ", "\"1425    带屏手提音箱1    1424    3    1    0\"", ";\n    ", "char", " N", "[", "30", "]", " = ", "\"1426    带屏手提音箱2    1424    3    1    0\"", ";\n    ", "char", " O ", "[", "30", "]", " = ", "\"1427    带屏手提音箱3    1424    3    1    0\"", ";\n    ", "char", " P", "[", "30", "]", " = ", "\"1428    带屏手提音箱3    1425    3    1    0\"", ";\n    display", "RootAndLeft(", "subRoot", ", 0, 4)", ";\n    insert", "TreeNode(", "root", ", M)", ";\n    insert", "TreeNode(", "root", ",N)", ";\n    insert", "TreeNode(", "root", ",O )", ";\n    insert", "TreeNode(", "root", ",P )", ";\n    display", "RootAndLeft(", "subRoot", ", 0, 4)", ";\n    printf(", "\"=============删除测试开始================\\n\"", ");\n    delete", "TreeNode(", "root", ", NULL)", ";\n    delete", "TreeNode(", "root", ", ", "root", ")", ";\n    delete", "TreeNode(", "root", ", ", "findByCID", "(", "root", ", 1424)", ");\n    delete", "TreeNode(", "root", ", ", "findByCID", "(", "root", ", 1427)", ");\n    delete", "TreeNode(", "root", ", ", "findByCID", "(", "root", ", 1426)", ");\n    delete", "TreeNode(", "root", ", ", "findByCID", "(", "root", ", 1425)", ");\n    delete", "TreeAll(", "root", ", ", "findByCID", "(", "root", ", 1424)", ");\n    display", "RootAndLeft(", "subRoot", ", 0, 4)", ";\n    find", "BadNodes(", "pList", ")", ";\n    ", "//某个函数名做另一个函数的参数，作用是选择执行哪个函数", "\n    printf(", "\"=====displayList(pList,displayCategoryName);====\\n\"", ");\n    display", "List(", "pList", ", ", "displayCategoryName", ")", ";\n    printf(", "\"====displayList(pList,displayCategory);====\\n\"", ");\n    display", "List(", "pList", ", ", "displayCategory", ")", ";\n    printf(", "\"====Tree * root = initTree(); createTree(root, pList);====\\n\"", ");\n    Tree", " * ", "root = init", "Tree()", "; create", "Tree(", "root", ", ", "pList", ")", ";\n    display", "Category(", "root", "->", "left", "->", "data", ")", ";\n    display", "Category(", "root", "->", "left", "->", "right", "->", "data", ")", ";\n    display", "Category(", "root", "->", "left", "->", "left", "->", "data", ")", ";\n    display", "Category(", "root", "->", "left", "->", "left", "->", "right", "->", "data", ")", ";\n    printf(", "\"====displayTree(root, -4, 4);====\\n\"", ");\n    display", "Tree(", "root", ", -4, 4)", ";\n    printf(", "\"====displayTree(root->left, 0, 4);====\\n\"", ");\n    display", "Tree(", "root", "->", "left", ", 0, 4)", ";\n    Tree* p;\n    printf(", "\"====p = findByCID(root, 22);displayTree(p, 0, 4);====\\n\"", ");\n    p = find", "ByCID(", "root", ", 22)", "; \n    display", "Tree(", "p", ", 0, 4)", ";\n    printf(", "\"====p = findByCID(root,1); displayTree0(p, 0, 4);====\\n\"", ");\n    p =find", "ByCID(", "root", ",1)", "; \n    display", "Tree(", "p", ", 0, 4)", ";\n\n    getchar", "()", ";\n}\n", "\n", "已启动生成…", "1>已启动生成: 项目: Project18, 配置: Debug x64", "1>源.cpp", "1>D:\\Project18\\源.cpp(172,14): error C4996: 'fopen': This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.", "1>D:\\Project18\\源.cpp(185,3): error C4996: 'fscanf': This function or variable may be unsafe. Consider using fscanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.", "1>D:\\Project18\\源.cpp(359,2): error C4996: 'scanf': This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.", "1>D:\\Project18\\源.cpp(467,9): error C2374: “root”: 重定义；多次初始化", "1>D:\\Project18\\源.cpp(435): message : 参见“root”的声明", "1>已完成生成项目“Project18.vcxproj”的操作 - 失败。", "生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个", "这些报错得怎么修改才能让它运行啊？"]], "Tag": "程序设计"}
{"Answer": "http://jingyan.baidu.com/article/1612d500aa1894e20e1eee29.html", "Konwledge_Point": "定义新的类型", "Question": ["我就想知道为什么我的vim中这样的文件出不来头文件和版权信息？", ["我就想知道为什么我的vim中这样的文件出不来头文件和版权信息？", "\n\n", "新文件标题", "\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"", "\n\"新建.c,.h,.sh,.java文件，自动插入文件头 ", "\nautocmd BufNewFile ", ".cpp,", ".[ch],*.sh,*.java exec \":call SetTitle()\" ", "\n\"\"定义函数SetTitle，自动插入文件头 ", "\nfunc SetTitle() ", "\n    \"如果文件类型为.sh文件 ", "\n    if &filetype == 'sh' ", "\n        call setline(1,\"#########################################################################\") ", "\n        call append(line(\".\"), \"# File Name: \".expand(\"%\")) ", "\n        call append(line(\".\")+1, \"# Author: Nick_Duan\") ", "\n        call append(line(\".\")+2, \"# mail: ", "dlm291459214@outlook.com", "\") ", "\n        call append(line(\".\")+3, \"# Created Time: \".strftime(\"%c\")) ", "\n        call append(line(\".\")+4, \"#########################################################################\") ", "\n        call append(line(\".\")+5, \"#!/bin/bash\") ", "\n        call append(line(\".\")+6, \"\") ", "\n    else ", "\n        call setline(1, \"*************************************************************************\") ", "\n        call append(line(\".\"), \"    > File Name: \".expand(\"%\")) ", "\n        call append(line(\".\")+1, \"  > Author: Nick_Duan\") ", "\n        call append(line(\".\")+2, \"  > Mail: ", "dlm291459214@outlook.com", " \") ", "\n        call append(line(\".\")+3, \"  > Created Time: \".strftime(\"%c\")) ", "\n        call append(line(\".\")+4, \" ************************************************************************/\") ", "\n        call append(line(\".\")+5, \"\")", "\n    endif", "\n    if &filetype == 'cpp'", "\n        call setline(1, \"*************************************************************************\") ", "\n        call append(line(\".\"), \"    > File Name: \".expand(\"%\")) ", "\n        call append(line(\".\")+1, \"  > Author: Nick_Duan\") ", "\n        call append(line(\".\")+2, \"  > Mail: ", "dlm291459214@outlook.com", " \") ", "\n        call append(line(\".\")+3, \"  > Created Time: \".strftime(\"%c\")) ", "\n        call append(line(\".\")+4, \" ************************************************************************/\") ", "\n        call append(line(\".\")+5, \"\")", "\n        call append(line(\".\")+6, \"#include\")", "\n        call append(line(\".\")+7, \"using namespace std;\")", "\n        call append(line(\".\")+8, \"\")", "\n    endif", "\n    if &filetype == 'c'", "\n        call setline(1, \"*************************************************************************\") ", "\n        call append(line(\".\"), \"    > File Name: \".expand(\"%\")) ", "\n        call append(line(\".\")+1, \"  > Author: Nick_Duan\") ", "\n        call append(line(\".\")+2, \"  > Mail: ", "dlm291459214@outlook.com", " \") ", "\n        call append(line(\".\")+3, \"  > Created Time: \".strftime(\"%c\")) ", "\n        call append(line(\".\")+4, \" ************************************************************************/\") ", "\n        call append(line(\".\")+5, \"\")", "\n        call append(line(\".\")+6, \"#include\")", "\n        call append(line(\".\")+7, \"\")", "\n    endif", "\n        if &filetype == 'java'", "\n        call setline(1, \"*************************************************************************\") ", "\n        call append(line(\".\"), \"    > File Name: \".expand(\"%\")) ", "\n        call append(line(\".\")+1, \"  > Author: Nick_Duan\") ", "\n        call append(line(\".\")+2, \"  > Mail: ", "dlm291459214@outlook.com", " \") ", "\n        call append(line(\".\")+3, \"  > Created Time: \".strftime(\"%c\")) ", "\n        call append(line(\".\")+4, \" ************************************************************************/\") ", "\n        call append(line(\".\")+5, \"\")", "\n        call append(line(\".\")+6,\"public class \".expand(\"%\"))", "\n        call append(line(\".\")+7,\"\")", "\n        endif", "\n    \"新建文件后，自动定位到文件末尾", "\n    autocmd BufNewFile * normal G", "\nendfunc ", "\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"", "\n\""]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;姓名和出版社字符串太长了&amp;#xff0c;超过20字节啦&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["输出函数有问题吗 求解", ["\n", "\n", "#include \"ds.h\"//自定义的头文件", "\nusing namespace std;", "//c", "++中指定命名空间\n \nstruct Book    ", "//", "定义一种结构体类型\n{\n    int ISBN;         ", "//", "书号\n    char  name[20];        ", "//", "书名\n    char   author[20];       ", "//", "作者\n    char   publisher[20];   ", "//", "出版单位\n    float  price;", "//", "价格\n    int  year;", "//", "图书的年【若为1988年出版  请输入1988】\n    int month;", "//", "图书的月【输入方法同上】\n    int day; ", "//", "图书的日【输入方法同上】               ", "//", "中间请用空格空开\n};\nBook book[MAXSIZE];\n ", "//9787521334111", " 新未来大学英语综合教程 孙有中 外语教学与研究出版社 74.9 2022 7 1\nvoid input", "(int &num)", "\n{\n    int i;\n    cout<<", "\"输入图书的本数num=\"", ";\n    cin>>num;\n    cout<<", "\"请输入\"", "<<num<<", "\"本图书的信息,空格分开\\n\"", ";\n    for", "(", "i", "=0; i<num; i++)", "\n    {\n        cin >> book[i]", ".ISBN", " >> book[i]", ".name", " >> book[i]", ".author", " >> book[i]", ".publisher", " >> book[i]", ".price", " >> book[i]", ".year", " >> book[i]", ".month", " >> book[i]", ".day", ";\n    }\n    for", "(", "i", "=0; i<num; i++)", "\n    {\n        cout << book[i]", ".ISBN", " << book[i]", ".name", " << book[i]", ".author", " << book[i]", ".publisher", " << book[i]", ".price", " << book[i]", ".year", " << book[i]", ".month", " << book[i]", ".day", " << endl;\n    }\n}\nvoid output", "(int num)", "\n{\n    int i;\n    for ", "(", "i", "=0; i<num; i++)", "\n    {\n        cout<<", "\"书名：\"", "<<book[i]", ".name", "<<", "\" 作者；\"", "<<book[i]", ".author", "<<", "\" 出版单位：\"", "<<book[i]", ".publisher", "<<", "\" 价格：\"", "<<book[i]", ".price", "<<", "\" 出版日期：\"", "<< book[i]", ".year", " << ", "\" \"", " << book[i]", ".month", " << ", "\" \"", " << book[i]", ".day", " << ", "\" \"", "<< endl;\n    }\n    cout<<", "\"\\n\"", ";\n}\n \nvoid insertm", "(int& num)", "   ", "//", "在最后面依次添加num本图书\n{\n    int i,m;\n    cout << ", "\"需要添加图书信息的本数为：\\n \"", ";\n    cin >> m;\n    cout << ", "\"请输入其信息【依次为书号（ISBN) 书名 作者 出版单位 价格 出版日期（书号不重复，用空格空开】\\n \"", ";\n    for ", "(", "i", "=0; i<m; i++)", "\n    {\n        cin >> book[i]", ".ISBN", " >> book[i]", ".name", " >> book[i]", ".author", " >> book[i]", ".publisher", " >> book[i]", ".price", " >> book[i]", ".year", " >> book[i]", ".month", " >> book[i]", ".day", ";\n    }\n    num = num + m;\n    cout << ", "\"图书信息添加后为：\\n\"", ";\n    output", "(num)", ";\n}\n \nvoid delete_books", "(int num)", "\n{\n    int i,choice,ISBN1,t=0;\n    char name1[1];\n    cout<<", "\"进入删除图书系统\\n\"", ";\n    cout<<", "\"按书号删除请按1\\n\"", ";\n    cout<<", "\"按书名删除请按2\\n\"", ";\n    cin>>choice;\n    switch", "(choice)", "\n    {\n    case 1:\n        cout<<", "\"请输入你想删除的图书的书号： \"", ";\n        cin>>ISBN1;\n        for", "(", "i", "=0; i<num; i++)", "\n        {\n            ", "if", "(", "ISBN1", " == book[i].ISBN)", "\n            {\n                t = i; ", "//", "记住要删除图书的下标\n                break;\n            }\n            else\n                cout<<", "\"删除失败，请确认书号是否正确！\"", "<<endl;\n        }\n        ", "if", "(t != num - 1)", " ", "//", "判断要删除图书是否为最后一本 即判断t是否为最后一个值\n        {\n            for", "(", "i", "=t; i<num; i++)", "\n            {\n                book[i] = book[i+1];\n            }\n        }\n        num = num-1;\n    case 2:\n        cout<<", "\"请输入你想删除的图书的书名： \"", ";\n        cin>>name1;\n        for", "(", "i", "=0; i<num; i++)", "\n        {\n            ", "if", "(", "name1", " == book[i].name)", "\n            {\n                t = i; ", "//", "记住要删除图书的下标\n                break;\n            }\n            else\n                cout<<", "\"删除失败，请确认书名是否正确！\"", "<<endl;\n        }\n        ", "if", "(t != num-1)", " ", "//", "判断要删除图书是否为最后一本 即判断t是否为最后一个值\n        {\n            for", "(", "i", "=t; i<num; i++)", "\n            {\n                book[i] = book[i+1];\n            }\n        }\n        num = num-1;\n    }\n}\n \nvoid change_books", "(int num)", "\n{\n    int ISBN2;\n    int i,t=0,choice;\n    cout<<", "\"请输入要修改信息图书的书号：\"", "<<endl;\n    cin>>ISBN2;\n    for", "(", "i", "=0; i<num; i++)", "\n    {\n        ", "if", "(", "ISBN2", " == book[i].ISBN)", "\n        {\n            t = i;\n            break;\n        }\n        else\n            cout<<", "\"无图书信息，请确认书号是否正确！\"", "<<endl;\n    }\n    cout<<", "\"请输入需要修改信息的序号:\"", "<<endl;\n    cout<<", "\"1.书名\"", "<<endl;\n    cout<<", "\"2.作者\"", "<<endl;\n    cout<<", "\"3.出版单位\"", "<<endl;\n    cout<<", "\"4.价格\"", "<<endl;\n    cin>>choice;\n    switch", "(choice)", "\n    {\n    case 1:\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t]", ".name", ";\n        break;\n    case 2:\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t]", ".author", ";\n        break;\n    case 3:\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t]", ".publisher", ";\n        break;\n    case 4:\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t]", ".price", ";\n        break;\n    default:\n        cout<<", "\"输入错误！请重新输入1-4\"", "<<endl;\n    }\n}\n \nvoid book_search", "(int num)", "\n{\n    int i,choice,ISBN3;\n    char name3[100];\n    cout<<", "\"进入查询图书系统\\n\"", ";\n    cout<<", "\"按书号查询请按1\\n\"", ";\n    cout<<", "\"按书名查询请按2\\n\"", ";\n    cin>>choice;\n    switch", "(choice)", "\n    {\n    case 1:\n        cout<<", "\"请输入你想查询的图书的书号：\"", ";\n        cin>>ISBN3;\n        for", "(", "i", "=0; i<num; i++)", "\n        {\n            ", "if", "(", "ISBN3", " == book[i].ISBN)", "\n            {\n                cout<<", "\"查询成功\\n\"", ";\n                cout<<", "\"该书基本信息为：\\n\"", ";\n                cout<<", "\"书名：\"", "<<book[i]", ".name", "<<", "\" 作者；\"", "<<book[i]", ".author", "<<", "\" 出版单位：\"", "<<book[i]", ".publisher", "<<", "\" 价格：\"", "<<book[i]", ".price", "<<", "\" 出版日期 年：\"", "<< book[i]", ".year", " << ", "\" \"", " << ", "\"出版日期 月\"", " << book[i]", ".month", " << ", "\" \"", " << ", "\"出版日期 日\"", " << book[i]", ".day", " << ", "\" \"", "<< endl;\n                break;\n            }\n        }\n        cout<<", "\"查询失败，请核对书号是否正确\\n\"", ";\n    case 2:\n        cout<<", "\"请输入你想查询的图书的书名：\"", ";\n        cin>>name3;\n        for", "(", "i", "=0; i<num; i++)", "\n        {\n            ", "if", "(strcmp(name3,book[i].name)", ")\n            {\n                cout<<", "\"查询成功\\n\"", ";\n                cout<<", "\"该书基本信息为：\\n\"", ";\n                cout<<", "\"书名：\"", "<<book[i]", ".name", "<<", "\" 作者；\"", "<<book[i]", ".author", "<<", "\" 出版单位：\"", "<<book[i]", ".publisher", "<<", "\" 价格：\"", "<<book[i]", ".price", "<<", "\" 出版日期 年：\"", "<< book[i]", ".year", " << ", "\" \"", " << ", "\"出版日期 月\"", " << book[i]", ".month", " << ", "\" \"", " << ", "\"出版日期 日\"", " << book[i]", ".day", " << ", "\" \"", "<< endl;\n                break;\n            }\n        }\n        cout<<", "\"查询失败，请核对书名是否正确\\n\"", ";\n    }\n}\n \nint main", "()", "\n{\n    int num=0;\n    int choice;\n    /*cout << ", "\"请输入你想进行图书信息管理的图书本数：\\n\"", ";\n    cin >> num;\n    cout << ", "\"请输入\"", " << num << ", "\"本图书信息 【书号（ISBN) 书名 作者 出版单位 价格 出版日期（书号不重复），用空格空开】: \\n\"", ";   ", "//", "完成图书信息输入\n    for ", "(", "i", " = 0; i < book1.num; i++)", "\n    {\n    cin >> book.ISBN >> book.BookName[i] >> book.author[i] >> book.publisher[i] >> book.price[i] >> book.data[i] ;   ", "//", "字符数组进行整体输入\n    }*/\n    input", "(num)", ";\n    cout << ", "\"进行图书信息浏览：    \"", " << endl;\n    output", "(num)", ";\n    cout<<", "\"请输入需要进入的系统1-4\"", ";\n    cin>>choice;\n    switch", "(choice)", "\n    {\n    case 1:\n        insertm", "(num)", ";\n        break;\n    case 2:\n        delete_books", "(num)", ";\n        break;\n    case 3:\n        change_books", "(num)", ";\n        break;\n    case 4:\n        book_search", "(num)", ";\n        break;\n    }\n    system", "(\"pause\")", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "你没搞明白这个bean\r\n&lt;bean id=\"Scheduler\" lazy-init=\"false\" autowire=\"no\" \r\nclass=\"org.springframework.scheduling.quartz.Scheduler[color=red]FactoryBean[/color]\" &gt; \r\n&lt;/bean&gt; \r\n它是一个工厂bean，得到的不是它本身，而是它负责创建的org.quartz.impl.StdScheduler对象\r\n\r\n\r\n这里要修改下\r\npublic class AddAction extends ActionSupport { \r\n// 添加新任务的操作对象 \r\nprivate StdScheduler scheduler; \r\nprivate MethodInvokingJobDetailFactoryBean jobdetail; \r\nprivate CronTriggerBean cron;", "Konwledge_Point": "定义新的类型", "Question": ["有人遇到过这种奇怪的问题吗？关于Spring集成quartz并持久化方面的问题。", ["spring配置文件中的配置如下（截取片段）：", "\n\n\n\n", "<bean id=\"Scheduler\" lazy-init=\"false\" autowire=\"no\"\n    class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\" >\n</bean>\n\n\n\n\n\n<bean id=\"addJob\" class=\"com.dhcc.scheduler.action.AddAction\">\n<property name=\"scheduler\">\n<ref local=\"Scheduler\"/>\n</property>\n</bean>\n", "\n\n", "AddAction的定义如下：", "\n\n", "package com.dhcc.scheduler.action;", "\n\n", "import org.springframework.scheduling.quartz.CronTriggerBean;", "\nimport org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean;", "\nimport org.springframework.scheduling.quartz.SchedulerFactoryBean;", "\n\n", "import com.opensymphony.xwork2.ActionSupport;", "\n\n", "public class AddAction extends ActionSupport {", "\n    // 添加新任务的操作对象", "\n    private SchedulerFactoryBean scheduler;", "\n    private MethodInvokingJobDetailFactoryBean jobdetail;", "\n    private CronTriggerBean cron;", "\n\n", "@Override\npublic String execute() throws Exception {\n    return super.execute();\n}\n\npublic SchedulerFactoryBean getScheduler() {\n    return scheduler;\n}\n\npublic void setScheduler(SchedulerFactoryBean scheduler) {\n    this.scheduler = scheduler;\n}\n\npublic MethodInvokingJobDetailFactoryBean getJobdetail() {\n    return jobdetail;\n}\n\npublic void setJobdetail(MethodInvokingJobDetailFactoryBean jobdetail) {\n    this.jobdetail = jobdetail;\n}\n\npublic CronTriggerBean getCron() {\n    return cron;\n}\n\npublic void setCron(CronTriggerBean cron) {\n    this.cron = cron;\n}\n", "\n\n", "}", "\n\n", "但是部署到tomcat却保这样一个错误：（如此奇怪的错误。。。）", "\n\n", "org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'addJob' defined in ServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception is org.springframework.beans.TypeMismatchException: Failed to convert property value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler'; nested exception is java.lang.IllegalArgumentException: Cannot convert value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler': no matching editors or conversion strategy found", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:480)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)", "\n    at java.security.AccessController.doPrivileged(Native Method)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)", "\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)", "\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429)", "\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728)", "\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:380)", "\n    at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:255)", "\n    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:199)", "\n    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:45)", "\n    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3843)", "\n    at org.apache.catalina.core.StandardContext.start(StandardContext.java:4342)", "\n    at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:791)", "\n    at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:771)", "\n    at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:525)", "\n    at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:926)", "\n    at org.apache.catalina.startup.HostConfig.deployDirectories(HostConfig.java:889)", "\n    at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:492)", "\n    at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1149)", "\n    at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:311)", "\n    at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)", "\n    at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1053)", "\n    at org.apache.catalina.core.StandardHost.start(StandardHost.java:719)", "\n    at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045)", "\n    at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443)", "\n    at org.apache.catalina.core.StandardService.start(StandardService.java:516)", "\n    at org.apache.catalina.core.StandardServer.start(StandardServer.java:710)", "\n    at org.apache.catalina.startup.Catalina.start(Catalina.java:578)", "\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)", "\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)", "\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)", "\n    at java.lang.reflect.Method.invoke(Method.java:585)", "\n    at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288)", "\n    at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413)", "\nCaused by: org.springframework.beans.TypeMismatchException: Failed to convert property value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler'; nested exception is java.lang.IllegalArgumentException: Cannot convert value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler': no matching editors or conversion strategy found", "\n    at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:391)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.convertForProperty(AbstractAutowireCapableBeanFactory.java:1289)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1250)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1010)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:472)", "\n    ... 38 more", "\nCaused by: java.lang.IllegalArgumentException: Cannot convert value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler': no matching editors or conversion strategy found", "\n    at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:231)", "\n    at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:138)", "\n    at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:386)", "\n    ... 42 more", "\n2009-7-9 15:41:12 org.apache.catalina.core.StandardContext listenerStart", "\n严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener", "\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'addJob' defined in ServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception is org.springframework.beans.TypeMismatchException: Failed to convert property value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler'; nested exception is java.lang.IllegalArgumentException: Cannot convert value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler': no matching editors or conversion strategy found", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:480)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)", "\n    at java.security.AccessController.doPrivileged(Native Method)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)", "\n    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)", "\n    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)", "\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429)", "\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728)", "\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:380)", "\n    at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:255)", "\n    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:199)", "\n    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:45)", "\n    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3843)", "\n    at org.apache.catalina.core.StandardContext.start(StandardContext.java:4342)", "\n    at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:791)", "\n    at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:771)", "\n    at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:525)", "\n    at org.apache.catalina.startup.HostConfig.deployDirectory(HostConfig.java:926)", "\n    at org.apache.catalina.startup.HostConfig.deployDirectories(HostConfig.java:889)", "\n    at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:492)", "\n    at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1149)", "\n    at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:311)", "\n    at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:117)", "\n    at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1053)", "\n    at org.apache.catalina.core.StandardHost.start(StandardHost.java:719)", "\n    at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045)", "\n    at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443)", "\n    at org.apache.catalina.core.StandardService.start(StandardService.java:516)", "\n    at org.apache.catalina.core.StandardServer.start(StandardServer.java:710)", "\n    at org.apache.catalina.startup.Catalina.start(Catalina.java:578)", "\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)", "\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)", "\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)", "\n    at java.lang.reflect.Method.invoke(Method.java:585)", "\n    at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288)", "\n    at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413)", "\nCaused by: org.springframework.beans.TypeMismatchException: Failed to convert property value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler'; nested exception is java.lang.IllegalArgumentException: Cannot convert value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler': no matching editors or conversion strategy found", "\n    at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:391)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.convertForProperty(AbstractAutowireCapableBeanFactory.java:1289)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1250)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1010)", "\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:472)", "\n    ... 38 more", "\nCaused by: java.lang.IllegalArgumentException: Cannot convert value of type [org.quartz.impl.StdScheduler] to required type [org.springframework.scheduling.quartz.SchedulerFactoryBean] for property 'scheduler': no matching editors or conversion strategy found", "\n    at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:231)", "\n    at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:138)", "\n    at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:386)", "\n    ... 42 more", "\n\n", "然而我根本没有使用org.quartz.impl.StdScheduler这个类，为什么会报类型错误呢》》》？？哪位大哥见多识广的，解救一下。", "\n[b]问题补充：[/b]", "\n谢谢各位大哥们的回答，，问题解决方式我知道，我想搞清楚的是，spring配置文件加载时，里面的bean是怎么加载的，具体发生了什么，是容器自动调用了其构造方法呢，还是init方法，抑或是其他。。。这个方面了解的还不深入，还望哪位大哥指点。。。正如我上面程序一样，为什么工厂类加载后，将其注入给其他对象时，类型就变了呢》》》？？？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;string  name[MAXSIZE];&lt;br /&gt;这里需要改成&lt;br /&gt;string  name;&lt;br /&gt;别的类似 &lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["为什么用string会报这么多错", ["\n", "\n\n```c++\n", "#include \"ds.h\"//自定义的头文件", "\n", "using", " ", "namespace", " ", "std", ";", "//c++中指定命名空间", "\n \n", "struct", " Book    ", "//定义一种单本图书结构体类型", "\n{\n    ", "string", " ISBN;         ", "//书号 ", "\n    ", "string", "  name[MAXSIZE];        ", "//书名", "\n    ", "char", "   author[MAXSIZE];       ", "//作者", "\n    ", "char", "   publisher[MAXSIZE];   ", "//出版单位", "\n    ", "float", "  price;", "//价格", "\n    ", "int", "  year;", "//图书的年【若为1988年出版  请输入1988】", "\n    ", "int", " month;", "//图书的月【输入方法同上】", "\n    ", "int", " day; ", "//图书的日【输入方法同上】               //中间请用空格空开", "\n};\n\nBook book[MAXSIZE];", "//图书的结构体数组", "\n\n ", "/*9787521334111 新未来大学英语综合教程 孙有中 外语教学与研究出版社 74.9 2022 7 1\n9787516519516 军事理论 宋来新 航空工业出版社 35.00 2020 8 2\n9787115576668 数据结构 严蔚敏 人民邮电出版社 49.80 2022 1 2\n 9787521326963 视听说 孙有中 外语教学与研究出版社 62.9 2022 7 1*/", "\n\n", "void", " ", "menu", "(", ") ", "//菜单函数 更好的用户体验", "\n{\n    cout << ", "\"********************************\"", " << endl;\n    cout << ", "\"********1.图书信息输入********\"", " << endl;\n    cout <<", "\"********2.图书信息浏览********\"", " << endl;\n    cout << ", "\"********3.图书信息添加********\"", " << endl;\n    cout << ", "\"********4.图书信息删除（书号删除、按书名删除)********\"", " << endl;\n    cout << ", "\"********5.图书信息修改（修改除书名号外的图书信息等）********\"", " << endl;\n    cout << ", "\"********6.图书信息查询（按书名查询、按书号查询）********\"", " << endl;\n    cout << ", "\"********7.统计图书的平均价格********\"", " << endl;\n    cout << ", "\"********8.图书排序（按价格排序、按出版日期排序）********\"", " << endl;\n    cout << ", "\"********9.图书信息保存到文件********\"", " << endl;\n    cout << ", "\"*********************************\"", " << endl;\n}\n\n", "void", " ", "input", "(", "int", " &num", ")  ", "//输入图书基本信息", "\n{\n    ", "int", " i;\n    cout<<", "\"输入图书的本数num=\"", ";\n    cin>>num;\n    cout<<", "\"请输入\"", "<<num<<", "\"本图书的信息,空格分开\\n\"", ";\n    ", "for", "(i=", "0", "; i<num; i++)\n    {\n        cin >> book[i].ISBN >> book[i].name >> book[i].author >> book[i].publisher >> book[i].price >> book[i].year >> book[i].month >> book[i].day;\n    }\n}\n", "void", " ", "output", "(", "int", " num", ") ", "//输出图书基本信息", "\n{\n    ", "int", " i;\n    ", "for", " (i=", "0", "; i<num; i++)\n    {\n        cout<<", "\"书名：\"", "<<book[i].name<<", "\" 作者；\"", "<<book[i].author<<", "\" 出版单位：\"", "<<book[i].publisher<<", "\" 价格：\"", "<<book[i].price<<", "\" 出版日期：\"", "<< book[i].year << ", "\" \"", " << book[i].month << ", "\" \"", " << book[i].day << ", "\" \"", "<< endl;\n    }\n    cout<<", "\"\\n\"", ";\n}\n \n", "void", " ", "insertm", "(", "int", "& num", ")   ", "//在最后面依次添加num本图书", "\n{\n    ", "int", " i,m;\n    cout << ", "\"需要添加图书信息的本数为：\\n \"", ";\n    cin >> m;\n    cout << ", "\"请输入其信息【依次为书号（ISBN) 书名 作者 出版单位 价格 出版日期（书号不重复，用空格空开】\\n \"", ";\n    ", "for", " (i=", "0", "; i<m; i++)\n    {\n        cin >> book[i].ISBN >> book[i].name >> book[i].author >> book[i].publisher >> book[i].price >> book[i].year >> book[i].month >> book[i].day;\n    }\n    num = num + m;\n    cout << ", "\"图书信息添加后为：\\n\"", ";\n    output(num);\n}\n \n", "void", " ", "delete_books", "(", "int", " num", ") ", "//删除图书", "\n{\n    ", "int", " i,choice,t=", "0", ";\n    ", "string", " ISBN1;\n    ", "string", " name1[MAXSIZE];\n    cout<<", "\"**************进入删除图书系统*****************\\n\"", ";\n    cout<<", "\"**************按书号删除请按1******************\\n\"", ";\n    cout<<", "\"**************按书名删除请按2******************\\n\"", ";\n    cin>>choice;\n    ", "switch", "(choice) ", "//按书号删除和按书名删除", "\n    {\n    ", "case", " ", "1", ":\n        cout<<", "\"请输入你想删除的图书的书号： \"", ";\n        cin>>ISBN1;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(ISBN1 == book[i].ISBN)\n            {\n                t = i; ", "//记住要删除图书的下标", "\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"删除失败，请确认书号是否正确！\"", "<<endl;\n        }\n        ", "if", "(t != num - ", "1", ") ", "//判断要删除图书是否为最后一本 即判断t是否为最后一个值", "\n        {\n            ", "for", "(i=t; i<num; i++)\n            {\n                book[i] = book[i+", "1", "];\n            }\n        }\n        num = num", "-1", ";\n        output(num);\n    ", "case", " ", "2", ":\n        cout<<", "\"请输入你想删除的图书的书名： \"", ";\n        cin>>name1;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(name1 == book[i].name)\n            {\n                t = i; ", "//记住要删除图书的下标", "\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"删除失败，请确认书名是否正确！\"", "<<endl;\n        }\n        ", "if", "(t != num", "-1", ") ", "//判断要删除图书是否为最后一本 即判断t是否为最后一个值", "\n        {\n            ", "for", "(i=t; i<num; i++)\n            {\n                book[i] = book[i+", "1", "];\n            }\n        }\n        num = num", "-1", ";\n        output(num);\n    }\n}\n \n", "void", " ", "change_books", "(", "int", " num", ")", "\n{\n    ", "string", " ISBN2;\n    ", "int", " i,t=", "0", ",choice;\n    cout<<", "\"请输入要修改信息图书的书号：\"", "<<endl;\n    cin>>ISBN2;\n    ", "for", "(i=", "0", "; i<num; i++)\n    {\n        ", "if", "(ISBN2 == book[i].ISBN)\n        {\n            t = i;\n            ", "break", ";\n        }\n        ", "else", "\n            cout<<", "\"无图书信息，请确认书号是否正确！\"", "<<endl;\n    }\n    cout<<", "\"请输入需要修改信息的序号:\"", "<<endl;\n    cout<<", "\"1.书名\"", "<<endl;\n    cout<<", "\"2.作者\"", "<<endl;\n    cout<<", "\"3.出版单位\"", "<<endl;\n    cout<<", "\"4.价格\"", "<<endl;\n    cin>>choice;\n    ", "switch", "(choice)\n    {\n    ", "case", " ", "1", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].name;\n        ", "break", ";\n    ", "case", " ", "2", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].author;\n        ", "break", ";\n    ", "case", " ", "3", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].publisher;\n        ", "break", ";\n    ", "case", " ", "4", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].price;\n        ", "break", ";\n    ", "default", ":\n        cout<<", "\"输入错误！请重新输入1-4\"", "<<endl;\n    }\n    output(num);\n}\n \n", "void", " ", "book_search", "(", "int", " num", ")", "\n{\n    ", "int", " i,choice;\n    ", "string", " ISBN3;\n    ", "string", " name3[", "100", "];\n    cout<<", "\"进入查询图书系统\\n\"", ";\n    cout<<", "\"按书号查询请按1\\n\"", ";\n    cout<<", "\"按书名查询请按2\\n\"", ";\n    cin>>choice;\n    ", "switch", "(choice)\n    {\n    ", "case", " ", "1", ":\n        cout<<", "\"请输入你想查询的图书的书号：\"", ";\n        cin>>ISBN3;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(ISBN3 == book[i].ISBN)\n            {\n                cout<<", "\"查询成功\\n\"", ";\n                cout<<", "\"该书基本信息为：\\n\"", ";\n                cout<<", "\"书名：\"", "<<book[i].name<<", "\" 作者；\"", "<<book[i].author<<", "\" 出版单位：\"", "<<book[i].publisher<<", "\" 价格：\"", "<<book[i].price<<", "\" 出版日期：\"", "<< book[i].year << ", "\" \"", " << book[i].month << ", "\" \"", " << book[i].day << ", "\" \"", "<< endl;\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"查询失败，请核对书号是否正确\\n\"", ";\n        }\n        output(num);\n    ", "case", " ", "2", ":\n        cout<<", "\"请输入你想查询的图书的书名：\"", ";\n        cin>>name3;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(name3 == book[i].name)\n            {\n                cout<<", "\"查询成功\\n\"", ";\n                cout<<", "\"该书基本信息为：\\n\"", ";\n                cout<<", "\"书名：\"", "<<book[i].name<<", "\" 作者；\"", "<<book[i].author<<", "\" 出版单位：\"", "<<book[i].publisher<<", "\" 价格：\"", "<<book[i].price<<", "\" 出版日期：\"", "<< book[i].year << ", "\" \"", " << book[i].month << ", "\" \"", " << book[i].day << ", "\" \"", "<< endl;\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"查询失败，请核对书名是否正确\\n\"", ";\n        }\n        output(num);\n    }\n}\n \n", "int", " ", "main", "(", ")", "\n{\n    ", "int", " num=", "0", ";\n    ", "int", " choice;\n    menu();\n    input(num);\n    cout << ", "\"进行图书信息浏览：    \"", " << endl;\n    output(num);\n    cout<<", "\"请输入需要进入的系统3-9:\"", ";\n    cin>>choice;\n    ", "switch", "(choice)\n    {\n    ", "case", " ", "3", ":\n        insertm(num);\n        ", "break", ";\n    ", "case", " ", "4", ":\n        delete_books(num);\n        ", "break", ";\n    ", "case", " ", "5", ":\n        change_books(num);\n        ", "break", ";\n    ", "case", " ", "6", ":\n        book_search(num);\n        ", "break", ";\n    }\n    system(", "\"pause\"", ");\n}\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的问题是&amp;#xff0c;我让你要么用string要么用char[]&amp;#xff0c;你用的是char&lt;/p&gt;\n&lt;p&gt;char   author;       //作者&lt;br /&gt;char   publisher;   //出版单位&lt;br /&gt;这两行换成 string&lt;/p&gt;\n&lt;p&gt;你可以学习下调试程序&amp;#xff0c;很显然看出来author没有得到正确的值。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/968991490976124.PNG\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/38180249097612.PNG\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;完整代码已经发你邮箱了。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["为什么图书信息输不出来了", ["\n", "#include \"ds.h\"//自定义的头文件", "\n", "using", " ", "namespace", " ", "std", ";", "//c++中指定命名空间", "\n", "#include<string>;", "\n \n", "struct", " Book    ", "//定义一种单本图书结构体类型", "\n{\n    ", "string", " ISBN;         ", "//书号 ", "\n    ", "string", "  name;        ", "//书名", "\n    ", "char", "   author;       ", "//作者", "\n    ", "char", "   publisher;   ", "//出版单位", "\n    ", "float", "  price;", "//价格", "\n    ", "int", "  year;", "//图书的年【若为1988年出版  请输入1988】", "\n    ", "int", " month;", "//图书的月【输入方法同上】", "\n    ", "int", " day; ", "//图书的日【输入方法同上】               //中间请用空格空开", "\n};\n\nBook book[MAXSIZE];", "//图书的结构体数组", "\n\n ", "/*9787521334111 新未来大学英语综合教程 孙有中 外语教学与研究出版社 74.9 2022 7 1\n9787516519516 军事理论 宋来新 航空工业出版社 35.00 2020 8 2\n9787115576668 数据结构 严蔚敏 人民邮电出版社 49.80 2022 1 2\n 9787521326963 视听说 孙有中 外语教学与研究出版社 62.9 2022 7 1*/", "\n\n", "void", " ", "menu", "(", ") ", "//菜单函数 更好的用户体验", "\n{\n    cout << ", "\"********************************\"", " << endl;\n    cout << ", "\"********1.图书信息输入********\"", " << endl;\n    cout <<", "\"********2.图书信息浏览********\"", " << endl;\n    cout << ", "\"********3.图书信息添加********\"", " << endl;\n    cout << ", "\"********4.图书信息删除（书号删除、按书名删除)********\"", " << endl;\n    cout << ", "\"********5.图书信息修改（修改除书名号外的图书信息等）********\"", " << endl;\n    cout << ", "\"********6.图书信息查询（按书名查询、按书号查询）********\"", " << endl;\n    cout << ", "\"********7.统计图书的平均价格********\"", " << endl;\n    cout << ", "\"********8.图书排序（按价格排序、按出版日期排序）********\"", " << endl;\n    cout << ", "\"********9.图书信息保存到文件********\"", " << endl;\n    cout << ", "\"*********************************\"", " << endl;\n}\n\n", "void", " ", "input", "(", "int", " &num", ")  ", "//输入图书基本信息", "\n{\n    ", "int", " i;\n    cout<<", "\"输入图书的本数num=\"", ";\n    cin>>num;\n    cout<<", "\"请输入\"", "<<num<<", "\"本图书的信息,空格分开\\n\"", ";\n    ", "for", "(i=", "0", "; i<num; i++)\n    {\n        cin >> book[i].ISBN >> book[i].name >> book[i].author >> book[i].publisher >> book[i].price >> book[i].year >> book[i].month >> book[i].day;\n    }\n}\n", "void", " ", "output", "(", "int", " num", ") ", "//输出图书基本信息", "\n{\n    ", "int", " i;\n    ", "for", " (i=", "0", "; i<num; i++)\n    {\n        cout<<", "\"书名：\"", "<<book[i].name<<", "\" 作者；\"", "<<book[i].author<<", "\" 出版单位：\"", "<<book[i].publisher<<", "\" 价格：\"", "<<book[i].price<<", "\" 出版日期：\"", "<< book[i].year << ", "\" \"", " << book[i].month << ", "\" \"", " << book[i].day << ", "\" \"", "<< endl;\n    }\n    cout<<", "\"\\n\"", ";\n}\n \n", "void", " ", "insertm", "(", "int", "& num", ")   ", "//在最后面依次添加num本图书", "\n{\n    ", "int", " i,m;\n    cout << ", "\"需要添加图书信息的本数为：\\n \"", ";\n    cin >> m;\n    cout << ", "\"请输入其信息【依次为书号（ISBN) 书名 作者 出版单位 价格 出版日期（书号不重复，用空格空开】\\n \"", ";\n    ", "for", " (i=", "0", "; i<m; i++)\n    {\n        cin >> book[i].ISBN >> book[i].name >> book[i].author >> book[i].publisher >> book[i].price >> book[i].year >> book[i].month >> book[i].day;\n    }\n    num = num + m;\n    cout << ", "\"图书信息添加后为：\\n\"", ";\n    output(num);\n}\n \n", "void", " ", "delete_books", "(", "int", " num", ") ", "//删除图书", "\n{\n    ", "int", " i,choice,t=", "0", ";\n    ", "string", " ISBN1;\n    ", "string", " name1;\n    cout<<", "\"**************进入删除图书系统*****************\\n\"", ";\n    cout<<", "\"**************按书号删除请按1******************\\n\"", ";\n    cout<<", "\"**************按书名删除请按2******************\\n\"", ";\n    cin>>choice;\n    ", "switch", "(choice) ", "//按书号删除和按书名删除", "\n    {\n    ", "case", " ", "1", ":\n        cout<<", "\"请输入你想删除的图书的书号： \"", ";\n        cin>>ISBN1;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(ISBN1 == book[i].ISBN)\n            {\n                t = i; ", "//记住要删除图书的下标", "\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"删除失败，请确认书号是否正确！\"", "<<endl;\n        }\n        ", "if", "(t != num - ", "1", ") ", "//判断要删除图书是否为最后一本 即判断t是否为最后一个值", "\n        {\n            ", "for", "(i=t; i<num; i++)\n            {\n                book[i] = book[i+", "1", "];\n            }\n        }\n        num = num", "-1", ";\n        output(num);\n    ", "case", " ", "2", ":\n        cout<<", "\"请输入你想删除的图书的书名： \"", ";\n        cin>>name1;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(name1 == book[i].name)\n            {\n                t = i; ", "//记住要删除图书的下标", "\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"删除失败，请确认书名是否正确！\"", "<<endl;\n        }\n        ", "if", "(t != num", "-1", ") ", "//判断要删除图书是否为最后一本 即判断t是否为最后一个值", "\n        {\n            ", "for", "(i=t; i<num; i++)\n            {\n                book[i] = book[i+", "1", "];\n            }\n        }\n        num = num", "-1", ";\n        output(num);\n    }\n}\n \n", "void", " ", "change_books", "(", "int", " num", ")", "\n{\n    ", "string", " ISBN2;\n    ", "int", " i,t=", "0", ",choice;\n    cout<<", "\"请输入要修改信息图书的书号：\"", "<<endl;\n    cin>>ISBN2;\n    ", "for", "(i=", "0", "; i<num; i++)\n    {\n        ", "if", "(ISBN2 == book[i].ISBN)\n        {\n            t = i;\n            ", "break", ";\n        }\n        ", "else", "\n            cout<<", "\"无图书信息，请确认书号是否正确！\"", "<<endl;\n    }\n    cout<<", "\"请输入需要修改信息的序号:\"", "<<endl;\n    cout<<", "\"1.书名\"", "<<endl;\n    cout<<", "\"2.作者\"", "<<endl;\n    cout<<", "\"3.出版单位\"", "<<endl;\n    cout<<", "\"4.价格\"", "<<endl;\n    cin>>choice;\n    ", "switch", "(choice)\n    {\n    ", "case", " ", "1", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].name;\n        ", "break", ";\n    ", "case", " ", "2", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].author;\n        ", "break", ";\n    ", "case", " ", "3", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].publisher;\n        ", "break", ";\n    ", "case", " ", "4", ":\n        cout<<", "\"请输入：\"", ";\n        cin>>book[t].price;\n        ", "break", ";\n    ", "default", ":\n        cout<<", "\"输入错误！请重新输入1-4\"", "<<endl;\n    }\n    output(num);\n}\n \n", "void", " ", "book_search", "(", "int", " num", ")", "\n{\n    ", "int", " i,choice;\n    ", "string", " ISBN3;\n    ", "string", " name3;\n    cout<<", "\"进入查询图书系统\\n\"", ";\n    cout<<", "\"按书号查询请按1\\n\"", ";\n    cout<<", "\"按书名查询请按2\\n\"", ";\n    cin>>choice;\n    ", "switch", "(choice)\n    {\n    ", "case", " ", "1", ":\n        cout<<", "\"请输入你想查询的图书的书号：\"", ";\n        cin>>ISBN3;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(ISBN3 == book[i].ISBN)\n            {\n                cout<<", "\"查询成功\\n\"", ";\n                cout<<", "\"该书基本信息为：\\n\"", ";\n                cout<<", "\"书名：\"", "<<book[i].name<<", "\" 作者；\"", "<<book[i].author<<", "\" 出版单位：\"", "<<book[i].publisher<<", "\" 价格：\"", "<<book[i].price<<", "\" 出版日期：\"", "<< book[i].year << ", "\" \"", " << book[i].month << ", "\" \"", " << book[i].day << ", "\" \"", "<< endl;\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"查询失败，请核对书号是否正确\\n\"", ";\n        }\n        output(num);\n    ", "case", " ", "2", ":\n        cout<<", "\"请输入你想查询的图书的书名：\"", ";\n        cin>>name3;\n        ", "for", "(i=", "0", "; i<num; i++)\n        {\n            ", "if", "(name3 == book[i].name)\n            {\n                cout<<", "\"查询成功\\n\"", ";\n                cout<<", "\"该书基本信息为：\\n\"", ";\n                cout<<", "\"书名：\"", "<<book[i].name<<", "\" 作者；\"", "<<book[i].author<<", "\" 出版单位：\"", "<<book[i].publisher<<", "\" 价格：\"", "<<book[i].price<<", "\" 出版日期：\"", "<< book[i].year << ", "\" \"", " << book[i].month << ", "\" \"", " << book[i].day << ", "\" \"", "<< endl;\n                ", "break", ";\n            }\n            ", "else", "\n                cout<<", "\"查询失败，请核对书名是否正确\\n\"", ";\n        }\n        output(num);\n    }\n}\n \n", "int", " ", "main", "(", ")", "\n{\n    ", "int", " num=", "0", ";\n    ", "int", " choice;\n    menu();\n    input(num);\n    cout << ", "\"进行图书信息浏览：    \"", " << endl;\n    output(num);\n    cout<<", "\"请输入需要进入的系统3-9:\"", ";\n    cin>>choice;\n    ", "switch", "(choice)\n    {\n    ", "case", " ", "3", ":\n        insertm(num);\n        ", "break", ";\n    ", "case", " ", "4", ":\n        delete_books(num);\n        ", "break", ";\n    ", "case", " ", "5", ":\n        change_books(num);\n        ", "break", ";\n    ", "case", " ", "6", ":\n        book_search(num);\n        ", "break", ";\n    }\n    system(", "\"pause\"", ");\n}\n![img](https:", "//img-mid.csdnimg.cn/release/static/image/mid/ask/489492460976111.png \"#left\")", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;feof函数有些问题&amp;#xff0c;你必须先读取一次&amp;#xff0c;然后判断feof&amp;#xff0c;如果非0就说明结束&amp;#xff0c;而不是先判断再读取&amp;#xff0c;这样会多读取一次&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["大一程序期中，请帮我看看我写的将文件内容载入链表的函数为啥载入错误", ["文件内容载入链表的函数是这样的，在文件为空的情况下总是写入乱码", "\n", "\nvoid load()\n{\n    ", "FILE", "* fp;", "\n    fp = ", "fopen", "(", "\"stockdata.txt\"", ", ", "\"r\"", ");\n    ", "if", " (fp == ", "NULL", ")//如果文件不存在则创建\n    {\n        fp = ", "fopen", "(", "\"stockdata.txt\"", ", ", "\"w\"", ");\n        ", "fclose", "(fp);\n        ", "return", ";\n    }\n    FRUIT", "* fruit;", "//链表临时指针\n    ", "while", " (!feof(fp))//文件指针未达到文件尾则持续读入\n    {\n        fruit = (FRUIT", "*)malloc(sizeof(FRUIT));", "\n        fscanf(fp, ", "\"%s%s%d%d%lf%lf%lf\"", ", fruit->name, fruit->kind, ", "&fruit", "->packing,", "&fruit", "->level,", "&fruit", "->cost,", "&fruit", "->price,", "&fruit", "->stock);\n        ", "add", "(fruit);\n    }\n    ", "fclose", "(fp);\n    ", "return", ";\n}\n", "\n", "整个是这样的：", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "\"输入限制函数.h\"", "\n", "#", "include", "<string.h>", "\n", "#", "define", " NAMELENGTH 21", "\n", "#", "define", " DATELENGTH 9", "\n", "#", "pragma", " ", "warning", "(disable:4996)", "\n", "typedef", " ", "enum", " ", "level", " { FIRST, SECOND, THIRD }LEVEL;", "//定义品质等级为一等品，二等品，三等品", "\n", "typedef", " ", "enum", " ", "packingmethod", " { BOX, BULK }PACKINGMETHOD;", "//定义包装方式有盒装、散装", "\n\n", "typedef", " ", "struct", " ", "fruit", "\n{\n    ", "char", " name[NAMELENGTH] = { ", "0", " };", "//水果名称", "\n    ", "char", " kind[NAMELENGTH] = { ", "0", " };", "//品种", "\n    PACKINGMETHOD packing;", "//包装方式", "\n    LEVEL level;", "//质量等级", "\n    ", "//char number[NAMELENGTH] = { 0 };//进货单号", "\n    ", "//char date[DATELENGTH] = {0};//过期时间", "\n    ", "double", " cost = ", "0", ";", "//成本价(元/kg)", "\n    ", "double", " price = ", "0", ";", "//水果单价(元/kg)", "\n    ", "double", " stock = ", "0", ";", "//库存(kg)", "\n    ", "struct", " ", "fruit", "* next;\n}FRUIT;", "//每一批货物的结构体", "\nFRUIT* head = ", "NULL", ", * rear = ", "NULL", ";", "//链表头指针与尾指针", "\n", "void", " ", "showMainMenu", "()", ";", "//显示主功能菜单", "\n", "void", " ", "mainMenu", "()", ";", "//运行主功能菜单", "\n", "void", " ", "add", "(FRUIT* newfruit)", ";", "//创建与延长链表函数", "\n", "void", " ", "load", "()", ";", "//从文件加载文件到链表中", "\n", "void", " ", "fruitCreate", "()", ";", "//建立水果信息", "\n", "void", " ", "showFruit", "(FRUIT* fruit)", ";", "//打印水果信息", "\n", "void", " ", "searchFruit", "()", ";", "//查找水果信息", "\n", "void", " ", "saveFruit", "()", ";", "//存储水果信息", "\n", "void", " ", "showAllFruit", "()", ";", "//展示所有水果信息", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "load", "();\n    ", "showMainMenu", "();\n    ", "mainMenu", "();\n}\n\n", "//显示主功能菜单", "\n", "void", " ", "showMainMenu", "()", "\n", "{\n    ", "printf", "(", "\"欢迎使用超市果蔬管理系统！\\n\"", ");\n    ", "printf", "(", "\"**************************\\n\"", ");\n    ", "printf", "(", "\"*-----建立水果信息:1-----*\\n\"", ");\n    ", "printf", "(", "\"*-----查找水果信息:2-----*\\n\"", ");\n    ", "printf", "(", "\"*-----修改水果信息:3-----*\\n\"", ");\n    ", "printf", "(", "\"*-----删除水果信息:4-----*\\n\"", ");\n    ", "printf", "(", "\"*-----显示水果信息:5-----*\\n\"", ");\n    ", "printf", "(", "\"*-----  退出系统  :6-----*\\n\"", ");\n    ", "printf", "(", "\"**************************\\n\"", ");\n    ", "return", ";\n}\n\n", "//运行主功能菜单", "\n", "void", " ", "mainMenu", "()", "\n", "{\n    ", "int", " select;\n    ", "while", " (", "true", ")\n    {\n        ", "intInputLimitation1", "(&select);", "//选择", "\n        ", "switch", " (select)\n        {\n        ", "case", " ", "1", ":", "fruitCreate", "();", "return", ";", "//建立水果信息", "\n        ", "case", " ", "2", ":", "showAllFruit", "();", "return", ";", "//显示水果信息", "\n        ", "case", " ", "3", ":\n        ", "case", " ", "4", ":\n        ", "case", " ", "5", ":\n        ", "case", " ", "6", ":", "saveFruit", "();", "exit", "(", "0", ");\n        ", "default", ":", "printf", "(", "\"请输入正确数字！\\n\"", ");", "break", ";\n        }\n    }\n\n}\n\n", "//向链表中添加水果结构体", "\n", "void", " ", "add", "(FRUIT* fruit)", "\n", "{\n    ", "if", " (head == ", "NULL", ")", "//如果头指针为空，说明链表不存在，新建链表", "\n    {\n        head = rear = fruit;\n        rear->next = ", "NULL", ";\n        ", "return", ";\n    }\n    rear->next = fruit;", "//如果头指针不为空，链表存在，在链表尾续", "\n    rear = fruit;\n    rear->next = ", "NULL", ";\n    ", "return", ";\n}\n\n", "//打印水果信息", "\n", "void", " ", "showFruit", "(FRUIT* fruit)", "\n", "{\n    ", "printf", "(", "\"水果名称:%s\\t水果品种:%s\\t\\n\"", ", fruit->name, fruit->kind);", "//打印名称、品种，换行", "\n    ", "switch", " (fruit->packing)\n    {\n    ", "case", " BOX:", "printf", "(", "\"包装方式:盒装\\t\"", ");", "break", ";\n    ", "case", " BULK:", "printf", "(", "\"包装方式:散装\\t\"", ");", "break", ";\n    }\n    ", "switch", " (fruit->level)\n    {\n    ", "case", " FIRST:", "printf", "(", "\"质量等级:一等品\\t\"", ");", "break", ";\n    ", "case", " SECOND:", "printf", "(", "\"质量等级:二等品\\t\"", ");", "break", ";\n    ", "case", " THIRD:", "printf", "(", "\"质量等级:三等品\\t\"", ");", "break", ";\n    }\n    ", "printf", "(", "\"成本价:%.2f元/kg\\t单价:%.2f元/kg\\t库存:%.2fkg\\n\"", ", fruit->cost, fruit->price, fruit->stock);\n    ", "return", ";\n}\n\n", "//展示所有水果信息", "\n", "void", " ", "showAllFruit", "()", "\n", "{\n    FRUIT* fruit=head;\n    ", "if", " (fruit == ", "NULL", ")\n        ", "printf", "(", "\"信息为空！\\n\"", ");\n    ", "else", "\n    {\n        ", "while", " (fruit!=", "NULL", ")\n        {\n            ", "showFruit", "(fruit);\n            fruit = fruit->next;\n        }\n    }\n    ", "system", "(", "\"pause\"", ");\n    ", "system", "(", "\"cls\"", ");\n    ", "showMainMenu", "();\n    ", "mainMenu", "();\n}\n\n", "//建立水果信息", "\n", "void", " ", "fruitCreate", "()", "\n", "{\n    FRUIT* fruit;\n    fruit = (FRUIT*)", "malloc", "(", "sizeof", "(FRUIT));\n    ", "printf", "(", "\"请输入新水果名称：\\n\"", ");", "//输入水果名称", "\n    ", "stringInputLimitation", "(NAMELENGTH, fruit->name);\n    ", "printf", "(", "\"请输入水果品种：\\n\"", ");", "//输入水果品种", "\n    ", "stringInputLimitation", "(NAMELENGTH, fruit->kind);\n    ", "int", " select;", "//用于选择的整数", "\n    ", "//选择质量等级", "\n    ", "while", " (", "true", ")\n    {\n        ", "printf", "(", "\"请选择包装方式：1、盒装 2、散装\\n\"", ");\n        ", "intInputLimitation1", "(&select);", "//用户输入以选择", "\n        ", "if", " (select == ", "1", " || select == ", "2", ")\n        {\n            ", "if", " (select == ", "1", ")\n                fruit->packing = BOX;\n            ", "if", " (select == ", "2", ")\n                fruit->packing = BULK;\n            ", "break", ";", "//输入正确，跳出", "\n        }\n        ", "printf", "(", "\"请正确选择！\\n\"", ");", "//输入错误，重新输入", "\n    }\n    ", "//选择包装方式", "\n    ", "while", " (", "true", ")\n    {\n        ", "printf", "(", "\"请选择质量等级：1、一等品 2、二等品 3、三等品\\n\"", ");\n        ", "intInputLimitation1", "(&select);", "//用户输入以选择", "\n        ", "if", " (select == ", "1", " || select == ", "2", " || select == ", "3", ")\n        {\n            ", "if", " (select == ", "1", ")\n                fruit->level = FIRST;\n            ", "if", " (select == ", "2", ")\n                fruit->level = SECOND;\n            ", "if", " (select == ", "3", ")\n                fruit->level = THIRD;\n            ", "break", ";", "//输入正确，跳出", "\n        }\n        ", "printf", "(", "\"请正确选择！\\n\"", ");", "//输入错误，重新输入", "\n    }\n    ", "//输入过期时间", "\n    ", "printf", "(", "\"请按照如下格式输入过期时间：年 月 日\"", ");\n    ", "system", "(", "\"pause\"", ");\n    ", "printf", "(", "\"请输入成本价：（元/kg）\\n\"", ");", "//输入成本价", "\n    ", "doubleInputLimitation", "(&fruit->cost);\n    ", "printf", "(", "\"请输入水果单价：（元/kg）\\n\"", ");", "//输入单价", "\n    ", "doubleInputLimitation", "(&fruit->price);\n    ", "printf", "(", "\"请输入进货数量：（kg）\\n\"", ");", "//输入进货数量", "\n    ", "doubleInputLimitation", "(&fruit->stock);\n    ", "add", "(fruit);", "//添加到链表中", "\n    ", "printf", "(", "\"创建成功！按任意键返回\\n\"", ");\n    ", "system", "(", "\"pause\"", ");\n    ", "system", "(", "\"cls\"", ");\n    ", "showMainMenu", "();\n    ", "mainMenu", "();\n}\n\n", "void", " ", "saveFruit", "()", "\n", "{\n    FILE* fp;", "//文件指针", "\n    fp = ", "fopen", "(", "\"stockdata.txt\"", ", ", "\"w\"", ");\n    FRUIT* fruit=head;", "//链表临时指针", "\n    ", "while", " (fruit!=", "NULL", ")", "//信息写入文件", "\n    {\n        ", "fprintf", "(fp, ", "\"%s\\t%s\\t%d\\t%d\\t%.2lf\\t%.2lf\\t%.2lf\\n\"", ", fruit->name, fruit->kind, fruit->packing, fruit->level, fruit->cost, fruit->price, fruit->stock);\n        fruit = fruit->next;\n    }\n    ", "fclose", "(fp);", "//关闭文件指针", "\n    ", "return", ";\n}\n\n", "void", " ", "load", "()", "\n", "{\n    FILE* fp;\n    fp = ", "fopen", "(", "\"stockdata.txt\"", ", ", "\"r\"", ");\n    ", "if", " (fp == ", "NULL", ")", "//如果文件不存在则创建", "\n    {\n        fp = ", "fopen", "(", "\"stockdata.txt\"", ", ", "\"w\"", ");\n        ", "fclose", "(fp);\n        ", "return", ";\n    }\n    FRUIT* fruit;", "//链表临时指针", "\n    ", "while", " (!", "feof", "(fp))", "//文件指针未达到文件尾则持续读入", "\n    {\n        fruit = (FRUIT*)", "malloc", "(", "sizeof", "(FRUIT));\n        ", "fscanf", "(fp, ", "\"%s%s%d%d%lf%lf%lf\"", ", fruit->name, fruit->kind, &fruit->packing,&fruit->level,&fruit->cost,&fruit->price,&fruit->stock);\n        ", "add", "(fruit);\n    }\n    ", "fclose", "(fp);\n    ", "return", ";\n}\n\n", "\n", "其中输入限制头文件是自己写的限制用户输入的头文件，代码如下", "\n", "\n", "#", "ifndef", " Input_Limitation", "\n", "#", "define", " Input_Limitation", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<math.h>", "\n\n", "//限制输入字符串函数", "\n", "void", " ", "stringInputLimitation", "(", "int", " size, ", "char", " str[])", "//输入字符串大小和待输入字符串", "\n", "{\n    ", "while", " (", "true", ")\n    {\n        ", "if", " (", "scanf_s", "(", "\"%s\"", ", str, size) == ", "1", ")", "//输入正确，退出", "\n        {\n            ", "getchar", "();", "//清理缓冲区", "\n            ", "return", ";\n        }\n        ", "printf", "(", "\"最多输入%d个汉字或者%d个字符！请重新输入:\\n\"", ", size / ", "2", ", size);\n        ", "while", " (", "getchar", "() != ", "'\\n'", ");", "//清理缓冲区", "\n    }\n}\n\n", "//限制输入整数函数(只能输入9位有效数字)(完杀)", "\n", "void", " ", "intInputLimitation9", "(", "int", "* pnumber)", "\n", "{\n    ", "char", " ch;\n    ", "while", " (", "true", ")\n    {\n        ", "if", " (", "scanf_s", "(", "\"%9d\"", ", pnumber) == ", "1", ")", "//输入正确，退出", "\n        {\n            ", "while", " ((ch = ", "getchar", "()) == ", "' '", " || ch == ", "'\\t'", ");", "//数字后的空白字符忽略", "\n            ", "if", " (ch == ", "'\\n'", ")", "//输入正确只能是数字后空白字符加回车", "\n                ", "return", ";\n        }\n        ", "printf", "(", "\"请输入整数且最多为9位数！\\n\"", ");", "//输入非整数字串或者数字超过1位", "\n        ", "while", " (", "getchar", "() != ", "'\\n'", ");\n    }\n}\n\n", "//限制输入整数函数(只能输入1位有效数字)", "\n", "void", " ", "intInputLimitation1", "(", "int", "* pnumber)", "\n", "{\n    ", "char", " ch;\n    ", "while", " (", "true", ")\n    {\n        ", "if", " (", "scanf_s", "(", "\"%1d\"", ", pnumber) == ", "1", ")", "//输入正确，退出", "\n        {\n            ", "while", " ((ch = ", "getchar", "()) == ", "' '", " || ch == ", "'\\t'", ");", "//数字后的空白字符忽略", "\n            ", "if", " (ch == ", "'\\n'", ")", "//输入正确只能是数字后空白字符加回车", "\n                ", "return", ";\n        }\n        ", "printf", "(", "\"请输入整数且最多为1位数！\\n\"", ");", "//输入非整数字串或者数字超过1位", "\n        ", "while", " (", "getchar", "() != ", "'\\n'", ");\n    }\n}\n\n\n", "//限制输入整数函数（最多只能输入X位有效数字）(用字符串存)", "\n", "void", " ", "intInputLimitationX", "(", "char", " number[], ", "int", " x)", "\n", "{\n    ", "while", " (", "true", ")\n    {\n        ", "while", " (", "true", ")", "//检查超界", "\n        {\n            ", "if", " (", "scanf_s", "(", "\"%s\"", ", number, x) == ", "1", ")", "//若未超界，跳出，进行数字判断", "\n                ", "break", ";\n            ", "printf", "(", "\"请输入正确数字且最多为%d位数！\\n\"", ", x - ", "1", ");", "//若超界，清理缓冲区继续输入", "\n            ", "while", " (", "getchar", "() != ", "'\\n'", ");\n        }\n        ", "int", " i = ", "0", ";", "//计数用", "\n        ", "for", " (;number[i] != ", "'\\0'", ";i++)\n        {\n            ", "if", " (number[i] >= ", "'0'", " && number[i] <= ", "'9'", ")\n                ", "continue", ";\n            ", "printf", "(", "\"请输入正确数字且最多为%d位数!\\n\"", ", x - ", "1", ");", "//若类型不正确，重新输入", "\n            ", "break", ";\n        }\n        ", "if", " (number[i] == ", "'\\0'", ")\n        {\n            ", "getchar", "();", "//清理回车", "\n            ", "return", ";\n        }\n    }\n\n}\n\n", "//限制输入长浮点数函数(double)(整数部分只能输入10位，小数点后只能输入两位)", "\n", "void", " ", "doubleInputLimitation", "(", "double", "* pnumber)", "\n", "{\n    ", "double", " sum;\n    ", "char", " ch;\n    ", "while", " (", "true", ")\n    {\n        ", "while", " (", "scanf_s", "(", "\"%13lf\"", ", &sum) == ", "1", ")", "//浮点数输入正确", "\n        {\n            ", "if", " (sum >= ", "pow", "(", "10", ", ", "13", ")) ", "break", ";", "//检测整数部分是否超界", "\n            ", "if", " (sum * ", "100", " - (", "long", " ", "long", ")(sum * ", "100", ") != ", "0", ") ", "break", ";", "//检测小数部分是否超界", "\n            ", "while", " ((ch = ", "getchar", "()) == ", "' '", " || ch == ", "'\\t'", ");", "//数字后的空白字符忽略", "\n            ", "if", " (ch == ", "'\\n'", ")", "//输入正确只能是数字后空白字符加回车", "\n            {\n                *pnumber = sum;\n                ", "return", ";\n            }\n            ", "break", ";\n        }\n        ", "printf", "(", "\"请输入正确数字且整数部分最多为10位,小数部分最多为2位！\\n\"", ");", "//输入非浮点数或整数部分超过10位", "\n        ", "while", " (", "getchar", "() != ", "'\\n'", ");\n    }\n}\n\n\n", "#", "endif", "\n\n"]], "Tag": "程序设计"}
{"Answer": "把calculation方法中的代码全放到下面的代码处，try{代码 } catch(Exception e){e.printStackTrace();}", "Konwledge_Point": "定义新的类型", "Question": ["关于flex与java交互的问题", ["各位前辈好！", "\n  本人最近在做一个关于输气管网计算界面的项目，要用到Flex与java通信。我在java里面定义了static变量，然后在flex里面向java传值（传的值有数组类型，也有double类型），然后在java里面实现计算并返回（能不能返回数组？如何做到？在flex里输入到什么组件比较好？）到flex。现在我经过测试发现传值的过程没什么问题，但是返回到flex里老出问题，百思不得其解,请求各位援助。", "\n\n", "下面是我的调用的java类：", "\n（注：程序运行没有什么问题的，只是没法被flex调用返回值，我是想调用Final（）或者calculation（）来返回getP（）等）", "\n\n", "package danxiang;", "\n\n", "import java.sql.ResultSet;", "\n\n", "import com.sun.xml.internal.bind.v2.schemagen.xmlschema.List;", "\n\n", "import domain.Model;", "\nimport domain.Result;", "\nimport flex.messaging.io.ArrayList;", "\n\n", "public class SectionCalculationwj {", "\n\n", "static double d[];\nstatic int start[];\npublic static double deta ;\npublic static double Z;\nstatic int end[];\nstatic double l[];\nstatic double qq[];\nstatic double Q0[];\nstatic double section[];\npublic static int point;\npublic static int ss;\nstatic double P0[] ;\nstatic double T0[];\npublic static double Th ;\nstatic double K[] ;\npublic static double  rog ;\npublic static double cpg ;\npublic static double Di;\n", "\n\n", "//下面这一部分是在flex里面调用的，从flex里面往这传值", "\n\n", "public String initiateqq(double init[])\n{\n         qq=init;\n         return \"qq\";\n }\n\npublic String initiatepoint(int i)\n{\n        point=i;\n        return \"point\";\n    }\n\n\n\npublic String initiateSection(double init[])\n{\n         section=init;\n         return \"section\";\n}\n\n\n\n\npublic String initiateStart(int init[])\n", "\n\n", "{", "\n         start=init;", "\n        return \"start\";", "\n}", "\n\n", "public String initiateEnd(int init[])\n", "\n\n", "{", "\n         end=init;", "\n        return \"end::\"+end[1];", "\n}", "\n\n", "    public String initiated(double init[])\n{\n         d=init;\n         return \"D:::\"+d[1];\n }  \n\n\n    public String initiatel(double init[])\n{\n         l=init;\n\n         return \"L:::\"+l[1];\n}\n\n    public String initiateT0(double init[])\n{\n         T0=init;\n\n        return \"T0\";\n}\n\n\n    public String initiateQ0(double init[])\n    {\n             Q0=init;\n            return \"Q0\";\n    }\n\n\n    public  String initiateP(double init[])\n    {\n        P0=init;\n     return \"P0\";\n    }\n\n\n\n    public String initiateK(double init[])\n{\n         K=init;\n\n        return \"K\";\n}\n\n\n\n\n\n\n\n    public double initiatedeta(double DETA)\n    {\n             deta=DETA;\n            return deta;\n    }\n    public double initiatess(int S)\n    {\n             ss=S;\n            return ss;\n    }\n    public double initiaterog(double ROG)\n    {\n             rog=ROG;\n            return rog;\n    }\n    public double initiatecpg(double C)\n    {\n             cpg=C;\n            return cpg;\n    }\n    public double initiateDi(double di)\n    {\n             Di=di;\n            return Di;\n    }\n    public double initiateTh(double th)\n    {\n             Th=th;\n            return Th;\n    }\n    public double initiateZ(double zz)\n    {\n             Z=zz;\n            return Z;\n    }\n", "\n\n", "//", "\n//", "\n//下面是我希望调用的，并返回到flex里面。。", "\n//  public String Final() {", "\n//        SectionCalculationwj aa = new SectionCalculationwj();", "\n//        aa.calculation();", "\n//        return \"Hello,成功了！\";", "\n//", "\n//    }", "\n\n", "public double[] calculation() {\n\n    int step = 0;\n    Result result = new Result();\n    //第一步，取初值\n    Model model = getInitValue();\n    //节点数\n    int n = model.getPoint();\n    //管道数\n    int m = model.getSection().length;\n    //计算出A，Azz\n    result.setA(A(model));\n    result.setAzz(Azz(result.getA()));\n    result.setP(model.getP0());\n    result.setAverageP(averageP(model, result));\n    double condition;\n    result.setQx(model.getQ0());\n    result.setT(model.getT0());\n    result.setBw(bw(result));\n\n\n\n\n    do {\n        result.setSj(Sj(model, result));\n        double[] tempQ = {};\n        //算AGA之前先求出G\n        result.setG(G(result.getSj(), result.getQx()));\n        result.setAGA(AGA(result));\n        fenkuai kf = new fenkuai();\n        result.setP(kf.fk(result.getAGA(), model.getSs(), result.getP(), model.getQq()));\n        result.setAverageP(averageP(model, result));\n        result.setDetap(detap(result));\n        tempQ = Qnew(result);\n        condition = condition(tempQ, result.getQx());\n        for (int k = 0; k < tempQ.length; k++) {\n            tempQ[k] = (result.getQx()[k] + tempQ[k]) / 2;\n        }\n        result.setQx(tempQ);\n", "\n\n", "//            温降  水", "\n\n", "        result.setAa(aa(model, result));\n        result.setT(resetT(model, result));\n", "\n\n", "//            水的析出", "\n            result.setBw(bw(result));", "\n            result.setDetabw(detabw(model,result));", "\n            step += 1;", "\n\n", "    } while (condition > 0.001);\n\n    System.out.println(step);\n    for (int i = 0; i < 12; i++) {\n        System.out.println(\"\" + result.getP()[i]);\n    }\n    for (int i = 0; i < 12; i++) {\n        System.out.println(\"\" + result.getT()[i]);\n    }\n    for (int i = 0; i < 11; i++) {\n        System.out.println(\"\" + result.getDetabw()[i]);\n    }\n\n\n  return  result.getP();\n\n}\n", "\n\n", "public double[][] A(Model model) {", "\n        int[] start = model.getStart();", "\n        int[] end = model.getEnd();", "\n        double[] section = model.getSection();", "\n        int n = model.getPoint();", "\n        int m = section.length;", "\n        double[][] A = new double[n][m];", "\n        for (int i = 0; i < n; i++) {", "\n            for (int j = 0; j < m; j++) {", "\n                if (i + 1 == start[j]) {", "\n                    A[i][j] = -1;", "\n                }", "\n                if (i + 1 == end[j]) {", "\n                    A[i][j] = 1;", "\n                } else if (i + 1 != start[j] && i + 1 != end[j]) {", "\n                    A[i][j] = 0;", "\n                }", "\n            }", "\n        }", "\n        return A;", "\n    }", "\n    //将A矩阵转置", "\n\n", "public double[][] Azz(double[][] A) {\n    int n = A.length;\n    int m = A[0].length;\n    double[][] Azz = new double[m][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Azz[j][i] = A[i][j];\n        }\n    }\n    return Azz;\n}\n// 计算Sj\n\npublic double[] Sj(Model model, Result result) {\n    double[] section = model.getSection();\n    double[] D = model.getD();\n    double[] L = model.getL();\n    double[] T = result.getT();\n    double deta = model.getDeta();\n    double Z = model.getZ();\n    double[] averageP = result.getAverageP();\n    //第一步，计算lam的值\n    int m = section.length;\n    double[] lam = new double[m];\n    double[] Sj = new double[m];\n    for (int i = 0; i < m; i++) {\n        lam[i] = 0.009407 / Math.pow(D[i], (1.0 / 3));\n    }\n    //第二步，计算Sj\n    for (int i = 0; i < m; i++) {\n        Sj[i] = -675.3515 * lam[i] * deta * Z * T[i] * L[i] / Math.pow(D[i], 5) / (2 * averageP[i]);\n    }\n    return Sj;\n}\n// 计算G\n\npublic double[][] G(double[] Sj, double[] Q) {\n    int m = Sj.length;\n    double[][] G = new double[m][m];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i == j) {\n                G[i][j] = 1 / Sj[i] / Math.abs(Q[i]);\n            } else {\n                G[i][j] = 0;\n            }\n        }\n    }\n    return G;\n}\n//计算AGA\n\npublic double[][] AGA(Result result) {\n    double[][] G = result.getG();\n    double[][] A = result.getA();\n    double[][] Azz = result.getAzz();\n    int n = A.length;\n    int m = A[0].length;\n    double AG[][] = new double[n][m];\n    double AGA[][] = new double[n][n];\n    for (int i = 0; i < A.length; i++) {\n        for (int j = 0; j < G[0].length; j++) {\n            for (int k = 0; k < G.length; k++) {\n                AG[i][j] += A[i][k] * G[k][j];\n            }\n        }\n    }\n    for (int i = 0; i < AG.length; i++) {\n        for (int j = 0; j < Azz[0].length; j++) {\n            for (int k = 0; k < Azz.length; k++) {\n                AGA[i][j] += AG[i][k] * Azz[k][j];\n            }\n        }\n    }\n    return AGA;\n}\n\npublic double[] detap(Result result) {\n    double[][] Azz = result.getAzz();\n    double[] p = result.getP();\n    int m = Azz.length;\n    int n = Azz[0].length;\n    double[] detap = new double[m];\n    //计算压力降\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            detap[i] += Azz[i][j] * p[j];\n        }\n    }\n    return detap;\n}\n\npublic double[] averageP(Model model, Result result) {\n    double[] P = result.getP();\n    int[] start = model.getStart();\n    int[] end = model.getEnd();\n    int m = start.length;\n    double[] averageP = new double[m];\n    for (int j = 0; j < m; j++) {\n        averageP[j] = 0.5 * (P[start[j] - 1] + P[end[j] - 1]);\n    }\n    return averageP;\n}\n\npublic double[] Qnew(Result result) {\n    //计算新流量\n    double[][] G = result.getG();\n    double[] detap = result.getDetap();\n    int m = G.length;\n    double[] Qnew = new double[m];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            Qnew[i] += G[i][j] * detap[j];\n        }\n    }\n    return Qnew;\n}\n\npublic double condition(double[] tempQ, double[] Q) {\n    int m = tempQ.length;\n    double condition = 0.0;\n    for (int i = 0; i < m; i++) {\n        condition += Math.pow((tempQ[i] - Q[i]), 2);\n    }\n    condition = Math.pow(condition, 0.5);\n    return condition;\n}\n//单相温降计算\n\npublic double[] aa(Model model, Result result) {\n    double[] Q = result.getQx();\n    double[] D = model.getD();\n    double[] K = model.getK();\n    double rog = model.getRog();\n    double cpg = model.getCpg();\n    double[] bw=result.getBw();\n    int m = Q.length;\n    double[] aa = new double[m];\n    for (int i = 0; i < m; i++) {\n        aa[i] = K[i] * Math.PI * D[i] / ((rog+bw[i]) * Q[i] * cpg )/1000000;\n    }\n    return aa;\n}\n\npublic double[] resetT(Model model, Result result) {\n    double Th = model.getTh();\n    int[] start = model.getStart();\n    int[] end = model.getEnd();\n    double[] T = result.getT();\n    double[] aa = result.getAa();\n    double[] l = model.getL();\n    double Di = model.getDi();\n    double[] detap = result.getDetap();\n    int m = aa.length;\n    for (int i = 0; i < m; i++) {\n        T[end[i] - 1] = Th + ((T[start[i] - 1]) - Th) * Math.exp(-aa[i] * l[i]) + Di * detap[i] / 1000000 * (1 - Math.exp(-aa[i] * l[i])) / aa[i] / l[i];\n    }\n    return T;\n}\n //饱和水的计算kg/m3直接加在气体密度上\n      public double[] bw(Result result) {\n    double[] T = result.getT();       \n    double[] P=result.getP();\n    int m = P.length;\n      double[] pb=new double[m];//饱和蒸汽压\n    double[] bw = new double[m];\n     // y = 0.06233 x3 + 0.60057 x2 + 46.27664 x + 643.34653     xOC，ypa      \n    for (int j = 0; j < m; j++) {\n        pb[j] = 0.06233*Math.pow(T[j]-273.15,3)+0.60057*Math.pow(T[j]-273.15,2)+46.27664*(T[j]-273.15)+643.34653;\n        bw[j]=803*pb[j]/(P[j]-pb[j])*0.001;\n    }\n    return bw;\n}   \n //起终点水量变化计算    >0进水,<0析出水  单位kg\n     public double[] detabw(Model model,Result result) {\n    double[] bw = result.getBw();\n    int[] start=model.getStart();\n    int[] end=model.getEnd();\n    double[]d=model.getD();\n    double[]L=model.getL();\n    int m = start.length;\n    double[] detabw = new double[m];\n    for (int j = 0; j < m; j++) {\n        detabw[j] = (bw[end[j]-1] - bw[start[j]-1])*(Math.PI*Math.pow(d[j], 2)/4)*L[j];\n    }\n    return detabw;\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;清空函数这么写&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;void f6()\n{\n    struct list t[100];\n    int i,j,sign&amp;#61;0;\n    int count&amp;#61;0;\n    char Del_name[20];\n\n    FILE* ptr &amp;#61; fopen(&amp;#34;data.txt&amp;#34;, &amp;#34;w&amp;#34;);\n    if (!ptr) {\n        printf(&amp;#34;文件打开失败,按任意键以继续\\n&amp;#34;);\n        getch();\n        return;\n    }//判断文件是否正确\n\n    fwrite(NULL, NULL, NULL, ptr);\n    fclose(ptr);    //关闭文件\n\n    printf(&amp;#34;all contacts have been deleted!\\n&amp;#34;); getch();\n    system(&amp;#34;cls&amp;#34;);\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;另提个建议&amp;#xff0c;每个函数里不需要打开文件、保存文件&amp;#xff0c;可以在主函数系统运行初始加载文件内容到数组&amp;#xff0c;然后中间工作都做完后&amp;#xff0c;退出运行前再统一保存一次文件&amp;#xff0c;就可以了。&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["c语言通讯录，清空函数不行", ["#include<stdio.h>", "\n#include<stdlib.h>", "\n#include<string.h>", "\n#include<conio.h>", "\nstruct list                    //建立结构体list用来存放一个联系人的信息 ", "\n{", "\n    char name[20];", "\n    char sex[20];", "\n    char year[5];", "\n    char phone[12];", "\n    char home[20]; ", "\n}info[100];                  //并定义了一个结构体数组info（information的缩写），一共可以存放100个联系人的信息，如果不够用可以再加。 ", "\n//设置函数声明，便于调用相关函数。 ", "\nvoid f1();            //添加联系人信息         //", "\nvoid f2();            //删除指定联系人信息     // ", "\nvoid f3();            //查找指定联系人信息     //", "\nvoid f4();            //修改指定联系人信息     //", "\nvoid f5();            //显示所有联系人信息     //", "\nvoid f6();            //清空所有联系人         //", "\nvoid f7();            //以名字排序所有联系人(按字典顺序)     //", "\nvoid menu()", "\n{", "\nsystem(\"cls\");", "\nprintf(\"\\n\\n\\n\\n\\t\\t\\t\\t\\t   通讯录\\n\");", "\nprintf(\" \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t作者:待写\");", "\nprintf(\"\\n\\t\\t\\t*--*--*--*--*--*--||菜单||--*--*--*--*--*--*--*\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t1.添加联系人信息\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t2.删除指定联系人信息\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t3.查找指定联系人信息\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t4.修改指定联系人信息\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t5.显示所有联系人信息\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t6.清空所有联系人\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t7.以名字排序所有联系人(按字典顺序)    *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t* \\t8.退出\\t\\t\\t\\t      *\\n\\t\\t\\t|\\t\\t\\t\\t\\t      |\");", "\nprintf(\"\\n\\t\\t\\t*--*--*--*--*--*--*------*--*--*--*--*--*--*--*\");", "\nprintf(\"\\n\\n\\t\\t\\t\\t  请输入选项:\");", "\n\n", "}", "\nvoid f1()                                              //f1函数用来添加联系人信息。相关文件函数作用说明可参考红皮书第10章 ", "\n{    int i,count=0;                                    //定义一个循环变量以及记录通讯录中联系人个数的变量", "\n    char ch[2];                                      //字符数组用来记录用户的输入", "\n    FILE *fp;                                       //定义指向文件的指针变量", "\n    if((fp=fopen(\"data.txt\",\"a+\"))==NULL)          //调用fopen函数创建一个新的文本来保存联系人信息，具体作用说明可参考红皮书335页 ", "\n    {", "\n        printf(\"不能打开!\\a\\n\");", "\n        exit(0);", "\n    }", "\n    while (!feof(fp))                            //判断文件是否结束", "\n    {", "\n        if (fread(&info[count], sizeof(struct list), 1, fp)==1)//使用fread函数将文件中的记录逐条读取到结构体数组", "\n            count++;", "\n    }", "\n    fclose(fp);                                     //关闭文件", "\n    if (count==0)                                   //判断当前通讯录是否为空", "\n        printf(\"当前通讯录中无联系人！\\n\");", "\n    else", "\n    {", "\n        system(\"cls\");                              //清屏", "\n        f5();                                 //显示联系人的所有信息", "\n    }", "\n    if ((fp=fopen(\"data.txt\", \"wb\"))==NULL)       //如果打开文件失败", "\n    {", "\n        printf(\"打开文件失败！\\n\");", "\n        exit(0);", "\n    }", "\n    //将之前已经保存的联系人信息重写入磁盘", "\n    for (i = 0; i < count; i++)", "\n        fwrite(&info[i], sizeof(struct list), 1, fp);", "\n    printf(\"是否要添加新联系人的信息：（y—是，n—否）\");//提示用户输入", "\n    scanf(\"%s\", ch);", "\n    system(\"cls\"); ", "\n    while (strcmp(ch, \"Y\") == 0 || strcmp(ch, \"y\") == 0)//判断用户是否需要输入", "\n    {", "\n        printf(\"姓名:\");", "\n        scanf(\"%s\", &info[count].name);", "\n        //判断用户输入姓名在通讯录中是否存在", "\n        for(i=0;i<count;i++)", "\n            if (strcmp(info[i].name, info[count].name) == 0)", "\n            {", "\n                printf(\"该联系人已存在，按任意键退出\");", "\n                getch();                     //输入一个字符但不显示在屏幕上，其函数声明在头文件conio中。 ", "\n                fclose(fp);", "\n                return;", "\n            }", "\n        printf(\"性别:\");", "\n        scanf(\"%s\", &info[count].sex);", "\n        printf(\"年龄:\");", "\n        scanf(\"%s\", &info[count].year);", "\n        printf(\"电话:\");", "\n        scanf(\"%s\", &info[count].phone);", "\n        printf(\"地址:\");", "\n        scanf(\"%s\", &info[count].home);", "\n        if (fwrite(&info[count],sizeof(struct list) , 1, fp) != 1)//将新建联系人信息保存到磁盘", "\n        {", "\n            printf(\"保存失败\");", "\n            getch();                       ", "\n        }", "\n        else", "\n        {", "\n            printf(\"%s 已保存!\\n\", info[count].name);", "\n            count++;", "\n        }", "\n        printf(\"是否要继续添加新联系人的信息：（y—是，n—否）:\");", "\n        scanf(\"%s\", ch);", "\n    }", "\n    fclose(fp);", "\n    printf(\"完成!\\n\");", "\n}", "\n\n", "void f2()", "\n{", "\n    int count = 0,i,j,sign=0;", "\n    char Del_name[20];", "\n    FILE* ptr = fopen(\"data.txt\", \"r\");", "\n    if (!ptr) {", "\n        printf(\"文件打开失败,按任意键以继续\\n\");", "\n        getch();", "\n        return;", "\n    }", "\n    while (!feof(ptr)) {", "\n        if (fread(info, sizeof(struct list), 1, ptr) == 1)", "\n            count++;", "\n    }", "\n    fclose(ptr);", "\n    printf(\"请输入要删除人的姓名:\\n\");", "\n    scanf(\"%s\", Del_name);", "\n    for (i = 0; i < count; i++) {", "\n        if (strcmp(info[i].name, Del_name) == 0) {", "\n            sign = 1; break;", "\n        }", "\n    }", "\n    if (!sign) {", "\n        printf(\"对不起,没有找到所删除联系人,按任意键以继续...\\n\");", "\n    }", "\n    else {", "\n        for (j = i; j < count&&j<100; j++) {", "\n            strcpy(info[j].name, info[j + 1].name);", "\n            strcpy(info[j].sex, info[j + 1].sex);", "\n            strcpy(info[j].year, info[j + 1].year);", "\n            strcpy(info[j].phone, info[j + 1].phone);", "\n            strcpy(info[j].home, info[j + 1].home);", "\n        }", "\n        printf(\"已删除%s的信息,按任意键以继续...\\n\", Del_name);", "\n    }", "\n    getch();", "\n    system(\"cls\");", "\n}", "\n\n", "void f3()", "\n{", "\n    FILE *p;//读取已有文件 ", "\n    int count=0;", "\n    if((p=fopen(\"data.txt\",\"a+\"))==NULL)", "\n    {", "\n        printf(\"打开文件失败！\\a\\n\");", "\n    }", "\n    while(!feof(p))", "\n    if(fread(&info[count],sizeof(struct list),1,p)==1)", "\n    count++;//计算已有联系人数量 ", "\n    fclose(p);", "\n    if(count==0)", "\n    printf(\"当前通讯录为空！\\n\");", "\n    else", "\n    system(\"cls\");//清空初始界面 ", "\n    ", "\n    char name[20]={0};//开始查找联系人 ", "\n    printf(\"请输入要查找的联系人姓名\\n\");", "\n    scanf(\"%s\",name);", "\n    int i,x=0;//利用变量x判断输入的联系人是否存在 ", "\n    for(i=0;i<=count;i++)", "\n    {", "\n        if(strcmp(info[i].name,name)==0)", "\n        x=i;", "\n    }", "\n    if(x==0)//输出查找结果 ", "\n    {", "\n    printf(\"此联系人不存在\\n\");", "\n    }", "\n    else", "\n    { ", "\n        printf(\"以下为查找结果\\n\");", "\n        printf(\"姓名: %s\\n\",info[x].name);", "\n        printf(\"性别: %s\\n\",info[x].sex);", "\n        printf(\"年龄: %s\\n\",info[x].year);", "\n        printf(\"电话: %s\\n\",info[x].phone);", "\n        printf(\"住址: %s\\n\",info[x].home);        ", "\n    }", "\nprintf(\"按任意键退出 \"); ", "\ngetch();", "\nfclose(p);//关闭文件 ", "\n}", "\n\n", "void f4()", "\n{", "\n}", "\n\n", "void f5()", "\n{", "\n}", "\n\n", "\nvoid f6()", "\n    ", "\n{struct list t[100];", "\n    int i,j,sign=0;    int count=0; ", "\n\n", "    char Del_name[20];", "\n\n", "        FILE* ptr = fopen(\"data.txt\", \"r\");    //读取已有文件", "\n\n", "          if (!ptr) {        printf(\"文件打开失败,按任意键以继续\\n\");                  ", "\n\n", "            getch();", "\n\n", "                return;    }//判断文件是否正确    ", "\n\n", "                       while (!feof(ptr))", "\n\n", "                    if (fread(info, sizeof(struct list), 1, ptr) == 1)        ", "\n                         count++;    //计算已有联系人数量    ", "\n\n", "                         fclose(ptr);    //关闭文件 ", "\n       int n=0;", "\n       ", "\n         for(i=0;i<count;i++)", "\n                            {", "\n                            for (j = i; j < count; j++) {", "\n                        ", "\n                            strcpy(info[j].name, info[j + 1].name);", "\n        ", "\n            strcpy(info[j].sex, info[j + 1].sex);", "\n        ", "\n            strcpy(info[j].year, info[j + 1].year);", "\n        ", "\n            strcpy(info[j].phone, info[j + 1].phone);", "\n            ", "\n            strcpy(info[j].home, info[j + 1].home);}", "\n            }", "\n     ", "\n      printf(\"all contacts have been deleted!\\n\"); getch();                             ", "\n    ", "\n    system(\"cls\");", "\n\n", "}", "\n                ", "\nvoid f7()", "\n{", "\n    struct list t;     //排序时的结构体类型的交换变量", "\n    int count=0;      ", "\n    FILE *f;            //读文件", "\n    if((f=fopen(\"data.txt\",\"a+\"))==NULL)", "\n    {", "\n        printf(\"无法打开文件!\\n\\a\");", "\n    }", "\n    while(!feof(f))", "\n    if(fread(&info[count],sizeof(struct list),1,f)==1)", "\n    count++ ;", "\n    fclose(f);", "\n    if(count==0)", "\n    printf(\"\\n通讯录中暂无联系人.\");", "\n    ", "\n    for(int i=0;i<count-1;i++)           //排序 ", "\n    for(int j=i+1;j<count;j++)", "\n    {", "\n        if(strcmp(info[i].name,info[j].name)>0)", "\n        {", "\n            t=info[j];", "\n            info[j]=info[i];", "\n            info[i]=t;", "\n        }", "\n    }", "\n            ", "\n    if((f=fopen(\"data.text\",\"wb\"))==NULL)    //写文件 ", "\n    {", "\n        printf(\"无法打开文件!\\n\\a\");", "\n    }", "\n    system(\"cls\");          //清屏 ", "\n    printf(\"\\n\\n\\n\\n\\t\\t\\t以下为排序结果:\\n\\n\");", "\n    for(int i=0;i<count;i++)", "\n    if(fwrite(&info[i],sizeof(struct list),1,f)==1)", "\n    {", "\n        printf(\"\\t第%d位:%s\\t%s\\t%s\\t%s\\t%s\",i+1,info[i].name,info[i].sex,info[i].year,info[i].phone,info[i].home);", "\n        printf(\"\\n\\n\");", "\n    }", "\n    else printf(\"\\n无法保存！\");", "\n    fclose(f);", "\n    printf(\"\\n\\t\\t\\t已成功保存！\");", "\n    printf(\"\\n\\n\\t\\t\\t按任意键退出!\\n\");", "\n    getch();", "\n}", "\n\n", "\nint main()", "\n{", "\nint type;", "\nmenu();", "\nint n;", "\nscanf(\"%d\",&n);", "\nif(n==8) n=0;", "\nwhile(n)", "\n{", "\nswitch(n)", "\n{", "\ntype=0;", "\ncase 1:f1();break;", "\ncase 2:f2();break;", "\ncase 3:f3();break;", "\ncase 4:f4();break;", "\ncase 5:f5();break;", "\ncase 6:f6();break;", "\ncase 7:f7();break;", "\ncase 8:type=1;break;", "\ndefault :break;", "\n}", "\nif(type==1) break;", "\nmenu();", "\nscanf(\"%d\",&n);", "\n}", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;主界面代码修改如下&amp;#xff0c;你试试看能满足要求不&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-comment\"&gt;#coding:utf-8&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; sys\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5 &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; QtCore, QtWidgets, QtCore\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; interface &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Ui_MainWindow_inter\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; requests\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5.QtCore &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Qt\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5.QtWidgets &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; QMainWindow, QApplication,QWidget\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; lxml &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; html\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5.QtCore &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; QTimer, QDateTime\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; pandas &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; pd\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; plt\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; login &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Ui_MainWindow\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; login\n\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5.QtGui &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; *\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5.Qt &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; *\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; PyQt5.QtCore &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; *\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; sys, math, string\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; kebiao &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; PdTable &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; kebiao_UI\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; kebiao &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; g\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; login &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Ui_MainWindow &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; login_UI\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; interface &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Ui_MainWindow_inter &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; interface_UI\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; calculator &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Calculator &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; Calculator_UI\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; huaban &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; Example &lt;span class=\"hljs-keyword\"&gt;as&lt;/span&gt; huaban_UI\n\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;mainface&lt;/span&gt;(QMainWindow, login_UI):\n    face1 &amp;#61; QtCore.pyqtSignal()\n\n    &lt;span class=\"hljs-comment\"&gt;# face2&amp;#61;QtCore.pyqtSignal()   #跳转信号&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, parent&amp;#61;&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;().__init__(parent)\n        self.setupUi(self)\n        self.ui &amp;#61; Ui_MainWindow()\n        self.pushButton_3.clicked.connect(self.logindef)\n\n        &lt;span class=\"hljs-comment\"&gt;# 设置窗口标志&amp;#xff1a;隐藏窗口边框&lt;/span&gt;\n        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)\n        self.setWindowFlags(Qt.FramelessWindowHint)\n\n        self.pushButton.clicked.connect(self.click_pushButton_1)\n        self.pushButton_2.clicked.connect(self.click_pushButton_2)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;click_pushButton_1&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        &lt;span class=\"hljs-comment\"&gt;# self.textEdit.append(&amp;#34;当前动作&amp;#xff1a;click_pushButton&amp;#xff08;登录&amp;#xff09;&amp;#34;)&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;# self.textEdit.append(&amp;#34;选择堆叠布局页面&amp;#xff1a;page_0&amp;#34;)&lt;/span&gt;\n        self.stackedWidget.setCurrentIndex(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 打开 stackedWidget &amp;gt; page_0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;click_pushButton_2&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.stackedWidget.setCurrentIndex(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;logindef&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.face1.emit()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mouseReleaseEvent&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, event&lt;/span&gt;):\n        self.start_x &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.start_y &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mousePressEvent&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, event&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; event.button() &amp;#61;&amp;#61; QtCore.Qt.LeftButton:\n            &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;(mainface, self).mousePressEvent(event)\n            self.start_x &amp;#61; event.x()\n            self.start_y &amp;#61; event.y()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mouseMoveEvent&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, event&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;(mainface, self).mouseMoveEvent(event)\n            dis_x &amp;#61; event.x() - self.start_x\n            dis_y &amp;#61; event.y() - self.start_y\n            self.move(self.x() &amp;#43; dis_x, self.y() &amp;#43; dis_y)\n        &lt;span class=\"hljs-keyword\"&gt;except&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;pass&lt;/span&gt;\n\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;LoginWindow&lt;/span&gt;(QtWidgets.QMainWindow, interface_UI):\n    face2 &amp;#61; QtCore.pyqtSignal()\n    face3 &amp;#61; QtCore.pyqtSignal()\n    face4 &amp;#61; QtCore.pyqtSignal()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, parent&amp;#61;&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;().__init__(parent)\n        self.setupUi(self)\n\n        self.start_x &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.start_y &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;# 设置窗口标志&amp;#xff1a;隐藏窗口边框&lt;/span&gt;\n        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.pushButton_7.clicked.connect(self.btn_press3_clicked)\n        self.pushButton_5.clicked.connect(self.btn_press5_clicked)\n        self.pushButton_6.clicked.connect(self.btn_press6_clicked)\n        self.pushButton.clicked.connect(self.btn_press_clicked)\n\n        self.widget &amp;#61; [{\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;widget&amp;#34;&lt;/span&gt;: self.frame_6,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;temp&amp;#34;&lt;/span&gt;: self.label3,\n            &lt;span class=\"hljs-string\"&gt;&amp;#39;day&amp;#39;&lt;/span&gt;: self.label_17,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;weather&amp;#34;&lt;/span&gt;: self.label_16\n        }, {\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;widget&amp;#34;&lt;/span&gt;: self.frame_2,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;temp&amp;#34;&lt;/span&gt;: self.label_2,\n            &lt;span class=\"hljs-string\"&gt;&amp;#39;day&amp;#39;&lt;/span&gt;: self.label_12,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;weather&amp;#34;&lt;/span&gt;: self.label\n        }, {\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;widget&amp;#34;&lt;/span&gt;: self.frame_3,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;temp&amp;#34;&lt;/span&gt;: self.label_4,\n            &lt;span class=\"hljs-string\"&gt;&amp;#39;day&amp;#39;&lt;/span&gt;: self.label_13,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;weather&amp;#34;&lt;/span&gt;: self.label_3\n        }, {\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;widget&amp;#34;&lt;/span&gt;: self.frame_4,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;temp&amp;#34;&lt;/span&gt;: self.label_6,\n            &lt;span class=\"hljs-string\"&gt;&amp;#39;day&amp;#39;&lt;/span&gt;: self.label_14,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;weather&amp;#34;&lt;/span&gt;: self.label_5\n        }, {\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;widget&amp;#34;&lt;/span&gt;: self.frame_5,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;temp&amp;#34;&lt;/span&gt;: self.label_8,\n            &lt;span class=\"hljs-string\"&gt;&amp;#39;day&amp;#39;&lt;/span&gt;: self.label_15,\n            &lt;span class=\"hljs-string\"&gt;&amp;#34;weather&amp;#34;&lt;/span&gt;: self.label_7\n        }\n        ]\n        self.get_weather_info()\n        self.statusShowTime()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;btn_press5_clicked&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.face2.emit()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;btn_press6_clicked&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.face3.emit()\n\n    &lt;span class=\"hljs-comment\"&gt;# 抓去肇庆的天气&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;get_weather_info&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n\n        city_id &amp;#61; &lt;span class=\"hljs-number\"&gt;101280901&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;# 肇庆的城市编码&lt;/span&gt;\n        url &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;http://www.weather.com.cn/weather/%s.shtml&amp;#39;&lt;/span&gt; % city_id\n        content &amp;#61; requests.get(url).content\n        sel &amp;#61; html.fromstring(content)\n        top &amp;#61; sel.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;//ul[&amp;#64;class&amp;#61;&amp;#34;t clearfix&amp;#34;]&amp;#39;&lt;/span&gt;)[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n        days &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, days &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;):\n            date &amp;#61; top.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;li[%d]/h1/text()&amp;#39;&lt;/span&gt; % i)[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n            weather &amp;#61; top.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;li[%d]/p[&amp;#64;class&amp;#61;&amp;#34;wea&amp;#34;]/text()&amp;#39;&lt;/span&gt; % i)[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n            tem &amp;#61; self.get_tem(top, i)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; date:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;day&amp;#39;&lt;/span&gt;].setText(&lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;(date))\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; weather:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;weather&amp;#39;&lt;/span&gt;].setText(weather)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; tem:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;temp&amp;#39;&lt;/span&gt;].setText(tem)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; weather &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;多云&amp;#39;&lt;/span&gt;:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;].setStyleSheet(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n                image: url(:/imagesvg32/image/32svg/夜间多云.svg);\n                &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; weather &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;晴&amp;#39;&lt;/span&gt;:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;].setStyleSheet(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n                                image: url(:/imagesvg32/image/32svg/晴.svg);\n                                &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; weather &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;晴转多云&amp;#39;&lt;/span&gt;:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;].setStyleSheet(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n                image: url(:/image/image/32svg/fine-晴天.svg);\n                &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; weather &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;阵雨&amp;#39;&lt;/span&gt;:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;].setStyleSheet(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n                image: url(:/imagesvg32/image/32svg/阵雨.svg);\n                &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; weather &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;阴转阵雨&amp;#39;&lt;/span&gt;:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;].setStyleSheet(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n                image: url(:/image/image/32svg/天气阵雨.svg);\n                &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;elif&lt;/span&gt; weather &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;阴&amp;#39;&lt;/span&gt;:\n                self.widget[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][&lt;span class=\"hljs-string\"&gt;&amp;#39;widget&amp;#39;&lt;/span&gt;].setStyleSheet(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;\n                image: url(:/imagesvg32/image/32svg/阴.svg);\n                &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;)\n            &lt;span class=\"hljs-comment\"&gt;# 以此类推 可以定义更多天气的类型 显示不同的图片&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;# 获取温度&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;get_tem&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, top, index&lt;/span&gt;):\n        tem_low &amp;#61; top.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;li[%d]/p[&amp;#64;class&amp;#61;&amp;#34;tem&amp;#34;]/i/text()&amp;#39;&lt;/span&gt; % index)[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(top.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;li[%d]/p[&amp;#64;class&amp;#61;&amp;#34;tem&amp;#34;]/span&amp;#39;&lt;/span&gt; % index)) !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n            tem_high &amp;#61; top.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;li[%d]/p[&amp;#64;class&amp;#61;&amp;#34;tem&amp;#34;]/span/text()&amp;#39;&lt;/span&gt; % index)[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;℃&amp;#39;&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tem_low &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39; ~&amp;#39;&lt;/span&gt; &amp;#43; tem_high\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tem_low\n\n        &lt;span class=\"hljs-comment\"&gt;# 设置界面可以拖拽和移动&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mouseReleaseEvent&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, event&lt;/span&gt;):\n        self.start_x &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.start_y &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mousePressEvent&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, event&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; event.button() &amp;#61;&amp;#61; QtCore.Qt.LeftButton:\n            &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;(LoginWindow, self).mousePressEvent(event)\n            self.start_x &amp;#61; event.x()\n            self.start_y &amp;#61; event.y()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;mouseMoveEvent&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, event&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt;:\n            &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;(LoginWindow, self).mouseMoveEvent(event)\n            dis_x &amp;#61; event.x() - self.start_x\n            dis_y &amp;#61; event.y() - self.start_y\n            self.move(self.x() &amp;#43; dis_x, self.y() &amp;#43; dis_y)\n        &lt;span class=\"hljs-keyword\"&gt;except&lt;/span&gt;:\n            &lt;span class=\"hljs-keyword\"&gt;pass&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;# 这里设想在label_11和label_10上分别显示当地时间和日期 查找很多方法都失败了&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;# def get_time(self):&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#     datetime &amp;#61; QtCore.QDateTime.currentDateTime() # 获取当前日期时间&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#     text &amp;#61; datetime.toString(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;) # 对日期时间进行格式化&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;#     self.label_11.showMessage(&amp;#39;当前日期时间&amp;#xff1a;&amp;#39;&amp;#43;text, 0) # 在状态栏中显示日期时间&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;statusShowTime&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        &lt;span class=\"hljs-comment\"&gt;# self.timeLabel &amp;#61; QLabel()    #设置一个label的控件&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;# self.statusBar.addPermanentWidget(self.timeLabel, 0)   #将label控件放进状态栏&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;# 这里我们已经在Frame中创建了label 所以不需要在创建新的对象&lt;/span&gt;\n        self.Timer &amp;#61; QTimer()  &lt;span class=\"hljs-comment\"&gt;# 自定义QTimer类&lt;/span&gt;\n        self.Timer.start(&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 每1s运行一次&lt;/span&gt;\n        self.Timer.timeout.connect(self.updateTime)  &lt;span class=\"hljs-comment\"&gt;# 与updateTime函数连接&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;updateTime&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        time &amp;#61; QDateTime.currentDateTime()  &lt;span class=\"hljs-comment\"&gt;# 获取现在的时间&lt;/span&gt;\n        dateshow &amp;#61; time.toString(&lt;span class=\"hljs-string\"&gt;&amp;#39;yyyy-MM-dd&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 设置显示时间的格式&lt;/span&gt;\n        self.label_11.setText(dateshow)\n        timeshow &amp;#61; time.toString(&lt;span class=\"hljs-string\"&gt;&amp;#39;HH:mm:ss&amp;#39;&lt;/span&gt;)\n        self.label_10.setText(timeshow)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;btn_press3_clicked&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        df &amp;#61; pd.read_excel(&lt;span class=\"hljs-string\"&gt;&amp;#39;myLife.xlsx&amp;#39;&lt;/span&gt;, sheet_name&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;Activity&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 获取Activity表所有数据&lt;/span&gt;\n        df &amp;#61; df.loc[df[&lt;span class=\"hljs-string\"&gt;&amp;#34;操作&amp;#34;&lt;/span&gt;] &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;步行&amp;#34;&lt;/span&gt;]  &lt;span class=\"hljs-comment\"&gt;# 筛选出“步行”数据&lt;/span&gt;\n        df &amp;#61; df[[&lt;span class=\"hljs-string\"&gt;&amp;#39;日期&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;数量&amp;#39;&lt;/span&gt;]]  &lt;span class=\"hljs-comment\"&gt;# 选取两列&lt;/span&gt;\n        df &amp;#61; df.head(&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 取头7天&amp;#xff0c;尾部函数是tail()&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(df)\n        &lt;span class=\"hljs-comment\"&gt;# 支持中文&lt;/span&gt;\n        plt.rcParams[&lt;span class=\"hljs-string\"&gt;&amp;#39;font.sans-serif&amp;#39;&lt;/span&gt;] &amp;#61; [&lt;span class=\"hljs-string\"&gt;&amp;#39;SimHei&amp;#39;&lt;/span&gt;]  &lt;span class=\"hljs-comment\"&gt;# 用来正常显示中文标签&lt;/span&gt;\n        df.plot(x&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;日期&amp;#39;&lt;/span&gt;, y&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;数量&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 画图&lt;/span&gt;\n        plt.show()  &lt;span class=\"hljs-comment\"&gt;# 显示&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;btn_press_clicked&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;slef&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; os\n        &lt;span class=\"hljs-built_in\"&gt;open&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;便笺.txt&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;w&amp;#43;&amp;#39;&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# 打开文件 若没有则创建名为便笺的文件&lt;/span&gt;\n        folder &amp;#61; &lt;span class=\"hljs-string\"&gt;r&amp;#39;便笺.txt&amp;#39;&lt;/span&gt;\n        os.system(&lt;span class=\"hljs-string\"&gt;&amp;#34;start explorer %s&amp;#34;&lt;/span&gt; % folder)  &lt;span class=\"hljs-comment\"&gt;# 通过start explorer打开指定应用&lt;/span&gt;\n\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;calculator&lt;/span&gt;(QMainWindow, Calculator_UI):\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self, parent&amp;#61;&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;().__init__(parent)\n\n        self.start_x &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.start_y &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;huaban&lt;/span&gt;(QMainWindow, huaban_UI):\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;(huaban_UI, self).__init__()\n\n        self.resize(&lt;span class=\"hljs-number\"&gt;400&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;300&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# resize设置宽高&amp;#xff0c;move设置位置&lt;/span&gt;\n        self.move(&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;)\n        self.setWindowTitle(&lt;span class=\"hljs-string\"&gt;&amp;#34;一个简单的画板&amp;#34;&lt;/span&gt;)\n\n        self.setMouseTracking(&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;)  &lt;span class=\"hljs-comment\"&gt;# setMouseTracking设置为False&amp;#xff0c;否则不按下鼠标时也会跟踪鼠标事件&lt;/span&gt;\n        self.Drawing_Board &amp;#61; []\n        self.start_x &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;\n        self.start_y &amp;#61; &lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;# 用一个列表保存所有移动的点&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;# self.setAttribute(QtCore.Qt.WA_TranslucentBackground)&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;# self.setWindowFlags(Qt.FramelessWindowHint)&lt;/span&gt;\n\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ke_biao&lt;/span&gt;(&lt;span class=\"hljs-title class_ inherited__\"&gt;QWidget&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self,parent&amp;#61;&lt;span class=\"hljs-literal\"&gt;None&lt;/span&gt;&lt;/span&gt;):\n        &lt;span class=\"hljs-built_in\"&gt;super&lt;/span&gt;().__init__(parent)\n        self.model &amp;#61; kebiao_UI(g)\n        self.view &amp;#61; QTableView()\n        self.view.setModel(self.model)\n        self.view.setWindowTitle(&lt;span class=\"hljs-string\"&gt;&amp;#39;今日的课程&amp;#39;&lt;/span&gt;)\n        self.view.resize(&lt;span class=\"hljs-number\"&gt;410&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;250&lt;/span&gt;)\n        self.view.setAlternatingRowColors(&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;)\n        self.view.show()\n\n\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Controller&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;__init__&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;pass&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;# 跳转到 mainface 窗口&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_login&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.mainface &amp;#61; mainface()\n        self.mainface.face1.connect(self.show_face)\n        self.mainface.show()\n\n    &lt;span class=\"hljs-comment\"&gt;# 跳转到 LoginWindow 窗口, 注意关闭原页面&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_face&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.LoginWindow &amp;#61; LoginWindow()\n        self.mainface.close()\n        self.LoginWindow.show()\n        self.LoginWindow.face2.connect(self.show_calculator)\n        self.LoginWindow.face3.connect(self.show_huaban)\n        self.LoginWindow.face4.connect(self.show_kebiao)\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_calculator&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.calculator &amp;#61; calculator()\n        self.calculator.show()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_huaban&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.huaban &amp;#61; huaban()\n        self.huaban.show()\n\n    &lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;show_kebiao&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;self&lt;/span&gt;):\n        self.huaban &amp;#61; ke_biao()\n\n\n\n&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;():\n    app &amp;#61; QApplication(sys.argv)\n\n    controller &amp;#61; Controller()  &lt;span class=\"hljs-comment\"&gt;# 控制器实例&lt;/span&gt;\n    controller.show_login()  &lt;span class=\"hljs-comment\"&gt;# 默认展示的是 hello 页面&lt;/span&gt;\n    sys.exit(app.exec_())\n\n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; __name__ &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:\n    main()\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["pyqt5主界面跳转实现pandas运用", ["######Python +pyqt5实现pandas的可视化", " 请问一下 通过在主界面点击‘课表’按钮  如何将课表界面 运行出来而不退出原来的窗口", "这是主界面", "这是‘课表’pandas的可视化界面", "\n", "\n", "这是主界面的代码", "\n", "import", " sys\n", "from", " PyQt5 ", "import", " QtCore, QtWidgets, QtCore\n", "from", " interface ", "import", " Ui_MainWindow_inter\n", "import", " requests\n", "from", " PyQt5.QtCore ", "import", " Qt\n", "from", " PyQt5.QtWidgets ", "import", " QMainWindow, QApplication\n", "from", " lxml ", "import", " html\n", "from", " PyQt5.QtCore ", "import", " QTimer,QDateTime\n", "import", " pandas ", "as", " pd\n", "import", " matplotlib.pyplot ", "as", " plt\n", "from", " login ", "import", " Ui_MainWindow\n", "import", " login\n\n\n\n", "from", " PyQt5.QtGui ", "import", " *\n", "from", " PyQt5.Qt ", "import", " *\n", "from", " PyQt5.QtCore ", "import", " *\n", "import", " sys,math,string\n", "from", " kebiao ", "import", " PdTable ", "as", " kebiao_UI\n", "from", " kebiao ", "import", " g\n", "from", " login ", "import", " Ui_MainWindow ", "as", " login_UI\n", "from", " interface ", "import", " Ui_MainWindow_inter ", "as", " interface_UI\n", "from", " calculator ", "import", " Calculator ", "as", " Calculator_UI\n", "from", " huaban ", "import", " Example ", "as", " huaban_UI\n", "class", " ", "mainface", " (QMainWindow,login_UI):\n    face1=QtCore.pyqtSignal()\n    ", "# face2=QtCore.pyqtSignal()   #跳转信号", "\n    ", "def", " ", "__init__", "(", "self,parent=", "None", "):\n        ", "super", "().__init__(parent)   \n        self.setupUi(self)\n        self.ui=Ui_MainWindow()\n        self.pushButton_3.clicked.connect(self.logindef)\n\n        ", "# 设置窗口标志：隐藏窗口边框", "\n        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)\n        self.setWindowFlags(Qt.FramelessWindowHint)  \n\n        self.pushButton.clicked.connect(self.click_pushButton_1)\n        self.pushButton_2.clicked.connect(self.click_pushButton_2)\n    \n    ", "def", " ", "click_pushButton_1", "(", "self", "): \n        ", "# self.textEdit.append(\"当前动作：click_pushButton（登录）\")", "\n        ", "# self.textEdit.append(\"选择堆叠布局页面：page_0\")", "\n        self.stackedWidget.setCurrentIndex(", "0", ")  ", "# 打开 stackedWidget > page_0", "\n        ", "return", "\n\n    ", "def", " ", "click_pushButton_2", "(", "self", "): \n        self.stackedWidget.setCurrentIndex(", "1", ")\n        ", "return", "   \n        \n\n    ", "def", " ", "logindef", "(", "self", "):\n        self.face1.emit()\n    ", "def", " ", "mouseReleaseEvent", "(", "self, event", "):\n        self.start_x = ", "None", "\n        self.start_y = ", "None", "\n\n    ", "def", " ", "mousePressEvent", "(", "self, event", "):\n        ", "if", " event.button() == QtCore.Qt.LeftButton:\n            ", "super", "(mainface, self).mousePressEvent(event)\n            self.start_x = event.x()\n            self.start_y = event.y()\n\n    ", "def", " ", "mouseMoveEvent", "(", "self, event", "):\n        ", "try", ":\n            ", "super", "(mainface, self).mouseMoveEvent(event)\n            dis_x = event.x() - self.start_x\n            dis_y = event.y() - self.start_y\n            self.move(self.x() + dis_x, self.y() + dis_y)\n        ", "except", ":\n            ", "pass", "\n\n", "class", " ", "LoginWindow", "(QtWidgets.QMainWindow,interface_UI):\n    face2=QtCore.pyqtSignal()\n    face3=QtCore.pyqtSignal()\n    ", "def", " ", "__init__", "(", "self,parent=", "None", "):\n        ", "super", "().__init__(parent)   \n        self.setupUi(self)\n\n        self.start_x = ", "None", "\n        self.start_y = ", "None", "\n\n        ", "#设置窗口标志：隐藏窗口边框", "\n        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)\n        self.setWindowFlags(Qt.FramelessWindowHint)  \n        self.pushButton_7.clicked.connect(self.btn_press3_clicked)\n        self.pushButton_5.clicked.connect(self.btn_press5_clicked)\n        self.pushButton_6.clicked.connect(self.btn_press6_clicked)\n        self.pushButton.clicked.connect(self.btn_press_clicked)\n\n\n\n\n        self.widget = [{\n            ", "\"widget\"", ": self.frame_6,\n            ", "\"temp\"", ": self.label3,\n            ", "'day'", ": self.label_17,\n            ", "\"weather\"", ": self.label_16\n        }, {\n            ", "\"widget\"", ": self.frame_2,\n            ", "\"temp\"", ": self.label_2,\n            ", "'day'", ": self.label_12,\n            ", "\"weather\"", ": self.label\n        }, {\n            ", "\"widget\"", ": self.frame_3,\n            ", "\"temp\"", ": self.label_4,\n            ", "'day'", ": self.label_13,\n            ", "\"weather\"", ": self.label_3\n        }, {\n            ", "\"widget\"", ": self.frame_4,\n            ", "\"temp\"", ": self.label_6,\n            ", "'day'", ": self.label_14,\n            ", "\"weather\"", ": self.label_5\n        }, {\n            ", "\"widget\"", ": self.frame_5,\n            ", "\"temp\"", ": self.label_8,\n            ", "'day'", ": self.label_15,\n            ", "\"weather\"", ": self.label_7\n        }\n        ] \n        self.get_weather_info()\n        self.statusShowTime()\n\n\n    \n    ", "def", " ", "btn_press5_clicked", "(", "self", "):\n        self.face2.emit()\n    ", "def", " ", "btn_press6_clicked", "(", "self", "):\n        self.face3.emit()\n\n", "#抓去肇庆的天气", "\n    ", "def", " ", "get_weather_info", "(", "self", "):\n\n        city_id = ", "101280901", "  ", "# 肇庆的城市编码", "\n        url = ", "'http://www.weather.com.cn/weather/%s.shtml'", " % city_id\n        content = requests.get(url).content\n        sel = html.fromstring(content)\n        top = sel.xpath(", "'//ul[@class=\"t clearfix\"]'", ")[", "0", "]\n        days = ", "5", "\n        ", "for", " i ", "in", " ", "range", "(", "1", ", days + ", "1", "):\n            date = top.xpath(", "'li[%d]/h1/text()'", " % i)[", "0", "]\n            weather = top.xpath(", "'li[%d]/p[@class=\"wea\"]/text()'", " % i)[", "0", "]\n            tem = self.get_tem(top, i)\n            ", "if", " date:\n                self.widget[i - ", "1", "][", "'day'", "].setText(", "str", "(date))\n            ", "if", " weather:\n                self.widget[i - ", "1", "][", "'weather'", "].setText(weather)\n            ", "if", " tem:\n                self.widget[i - ", "1", "][", "'temp'", "].setText(tem)\n            ", "if", " weather == ", "'多云'", ":\n                self.widget[i - ", "1", "][", "'widget'", "].setStyleSheet(", "\"\"\"\n                image: url(:/imagesvg32/image/32svg/夜间多云.svg);\n                \"\"\"", ")\n            ", "elif", " weather == ", "'晴'", ":\n                self.widget[i - ", "1", "][", "'widget'", "].setStyleSheet(", "\"\"\"\n                                image: url(:/imagesvg32/image/32svg/晴.svg);\n                                \"\"\"", ")\n            ", "elif", " weather == ", "'晴转多云'", ":\n                self.widget[i - ", "1", "][", "'widget'", "].setStyleSheet(", "\"\"\"\n                image: url(:/image/image/32svg/fine-晴天.svg);\n                \"\"\"", ")\n            ", "elif", " weather == ", "'阵雨'", ":\n                self.widget[i - ", "1", "][", "'widget'", "].setStyleSheet(", "\"\"\"\n                image: url(:/imagesvg32/image/32svg/阵雨.svg);\n                \"\"\"", ")\n            ", "elif", " weather == ", "'阴转阵雨'", ":\n                self.widget[i - ", "1", "][", "'widget'", "].setStyleSheet(", "\"\"\"\n                image: url(:/image/image/32svg/天气阵雨.svg);\n                \"\"\"", ")\n            ", "elif", " weather == ", "'阴'", ":\n                self.widget[i - ", "1", "][", "'widget'", "].setStyleSheet(", "\"\"\"\n                image: url(:/imagesvg32/image/32svg/阴.svg);\n                \"\"\"", ")\n            ", "#以此类推 可以定义更多天气的类型 显示不同的图片", "\n\n\n    ", "# 获取温度", "\n    ", "def", " ", "get_tem", "(", "self, top, index", "):\n        tem_low = top.xpath(", "'li[%d]/p[@class=\"tem\"]/i/text()'", " % index)[", "0", "]\n        ", "if", " ", "len", "(top.xpath(", "'li[%d]/p[@class=\"tem\"]/span'", " % index)) != ", "0", ":\n            tem_high = top.xpath(", "'li[%d]/p[@class=\"tem\"]/span/text()'", " % index)[", "0", "] + ", "'℃'", "\n            ", "return", " tem_low + ", "' ~'", " + tem_high\n        ", "else", ":\n            ", "return", " tem_low\n\n\n        ", "#设置界面可以拖拽和移动", "\n    ", "def", " ", "mouseReleaseEvent", "(", "self, event", "):\n        self.start_x = ", "None", "\n        self.start_y = ", "None", "\n\n    ", "def", " ", "mousePressEvent", "(", "self, event", "):\n        ", "if", " event.button() == QtCore.Qt.LeftButton:\n            ", "super", "(LoginWindow, self).mousePressEvent(event)\n            self.start_x = event.x()\n            self.start_y = event.y()\n\n\n    ", "def", " ", "mouseMoveEvent", "(", "self, event", "):\n        ", "try", ":\n            ", "super", "(LoginWindow, self).mouseMoveEvent(event)\n            dis_x = event.x() - self.start_x\n            dis_y = event.y() - self.start_y\n            self.move(self.x() + dis_x, self.y() + dis_y)\n        ", "except", ":\n            ", "pass", "\n\n\n        ", "#这里设想在label_11和label_10上分别显示当地时间和日期 查找很多方法都失败了", "\n    ", "# def get_time(self):", "\n    ", "#     datetime = QtCore.QDateTime.currentDateTime() # 获取当前日期时间", "\n    ", "#     text = datetime.toString(\"yyyy-MM-dd HH:mm:ss\") # 对日期时间进行格式化", "\n    ", "#     self.label_11.showMessage('当前日期时间：'+text, 0) # 在状态栏中显示日期时间", "\n    ", "def", " ", "statusShowTime", "(", "self", "):   \n        ", "# self.timeLabel = QLabel()    #设置一个label的控件", "\n        ", "# self.statusBar.addPermanentWidget(self.timeLabel, 0)   #将label控件放进状态栏", "\n        ", "#这里我们已经在Frame中创建了label 所以不需要在创建新的对象", "\n        self.Timer=QTimer()   ", "#自定义QTimer类", "\n        self.Timer.start(", "1000", ")  ", "#每1s运行一次", "\n        self.Timer.timeout.connect(self.updateTime)   ", "#与updateTime函数连接", "\n    ", "def", " ", "updateTime", "(", "self", "):\n        time=QDateTime.currentDateTime()    ", "#获取现在的时间", "\n        dateshow=time.toString(", "'yyyy-MM-dd'", ")   ", "#设置显示时间的格式", "\n        self.label_11.setText(dateshow) \n        timeshow=time.toString(", "'HH:mm:ss'", ")\n        self.label_10.setText(timeshow)\n    ", "def", " ", "btn_press3_clicked", "(", "self", "):\n        df = pd.read_excel(", "'myLife.xlsx'", ",sheet_name = ", "'Activity'", ") ", "# 获取Activity表所有数据", "\n        df=df.loc[df[", "\"操作\"", "]==", "\"步行\"", "]           ", "# 筛选出“步行”数据", "\n        df=df[[", "'日期'", ",", "'数量'", "]]                  ", "# 选取两列", "\n        df=df.head(", "7", ")                          ", "# 取头7天，尾部函数是tail()", "\n        ", "print", "(df)\n        ", "# 支持中文", "\n        plt.rcParams[", "'font.sans-serif'", "] = [", "'SimHei'", "]  ", "# 用来正常显示中文标签", "\n        df.plot(x=", "'日期'", ",y=", "'数量'", ")              ", "# 画图", "\n        plt.show()                             ", "# 显示", "\n    ", "def", " ", "btn_press_clicked", "(", "slef", "):\n        ", "import", " os\n        ", "open", "(", "'便笺.txt'", ",", "'w+'", ")", "#打开文件 若没有则创建名为便笺的文件", "\n        folder=", "r'便笺.txt'", "\n        os.system(", "\"start explorer %s\"", " %folder)", "#通过start explorer打开指定应用", "\n\n", "class", " ", "calculator", " (QMainWindow,Calculator_UI):\n       ", "def", " ", "__init__", "(", "self,parent=", "None", "):\n            ", "super", "().__init__(parent)   \n       \n            self.start_x = ", "None", "\n            self.start_y = ", "None", "\n          \n", "class", " ", "huaban", "(QMainWindow,huaban_UI):\n       \n     ", "def", " ", "__init__", "(", "self", "):\n        ", "super", "(huaban_UI, self).__init__()\n\n        self.resize(", "400", ", ", "300", ")                  ", "#resize设置宽高，move设置位置", "\n        self.move(", "100", ", ", "100", ")\n        self.setWindowTitle(", "\"一个简单的画板\"", ")                          \n        \n        self.setMouseTracking(", "False", ")      ", "#setMouseTracking设置为False，否则不按下鼠标时也会跟踪鼠标事件        ", "\n        self.Drawing_Board = []           \n        self.start_x = ", "None", "\n        self.start_y = ", "None", "               ", "#用一个列表保存所有移动的点", "\n        ", "# self.setAttribute(QtCore.Qt.WA_TranslucentBackground)", "\n        ", "# self.setWindowFlags(Qt.FramelessWindowHint)  ", "\n\n\n\n\n", "class", " ", "Controller", ":\n    ", "def", " ", "__init__", "(", "self", "):\n        ", "pass", "\n    ", "# 跳转到 mainface 窗口", "\n    ", "def", " ", "show_login", "(", "self", "):\n        self.mainface = mainface()\n        self.mainface.face1.connect(self.show_face)\n        self.mainface.show()\n    ", "# 跳转到 LoginWindow 窗口, 注意关闭原页面", "\n    ", "def", " ", "show_face", "(", "self", "):\n        self.LoginWindow = LoginWindow()\n        self.mainface.close()\n        self.LoginWindow.show()\n        self.LoginWindow.face2.connect(self.show_calculator)\n        self.LoginWindow.face3.connect(self.show_huaban)\n    \n    ", "def", " ", "show_calculator", "(", "self", "):\n        self.calculator=calculator()\n        self.calculator.show()\n    ", "def", " ", "show_huaban", "(", "self", "):\n        self.huaban=huaban()\n        self.huaban.show()\n\n\n\n\n\n", "def", " ", "main", "():\n    app = QApplication(sys.argv)\n\n    controller = Controller() ", "# 控制器实例", "\n    controller.show_login() ", "# 默认展示的是 hello 页面", "\n    sys.exit(app.exec_())\n\n", "if", " __name__ == ", "'__main__'", ":\n\n    main()\n\n\n", "\n", "\n", "尝试不同的方法都不行 第一次是程序闪退 但不能同时存在两个APP窗口", "\n", "尝试一", "\n", "class", " ", "kebiao", " (QMainWindow,kebiao_UI):\n    ", "def", " ", "__init__", "(", "self", "):\n        ", "super", "(kebiao_UI, self).__init__()\n        self.start_x = ", "None", "\n        self.start_y = ", "None", " \n        self.model=kebiao_UI(g)\n        self.view = QTableView()\n        self.setModel(model)\n        self.setWindowTitle(", "'今日的课程'", ")\n        self.resize(", "410", ", ", "250", ")\n        self.setAlternatingRowColors(", "True", ")\n      \n\n\n\n\n", "class", " ", "Controller", ":\n    ", "def", " ", "__init__", "(", "self", "):\n        ", "pass", "\n    ", "# 跳转到 mainface 窗口", "\n    ", "def", " ", "show_login", "(", "self", "):\n        self.mainface = mainface()\n        self.mainface.face1.connect(self.show_face)\n        self.mainface.show()\n    ", "# 跳转到 LoginWindow 窗口, 注意关闭原页面", "\n    ", "def", " ", "show_face", "(", "self", "):\n        self.LoginWindow = LoginWindow()\n        self.mainface.close()\n        self.LoginWindow.show()\n        self.LoginWindow.face2.connect(self.show_calculator)\n        self.LoginWindow.face3.connect(self.show_huaban)\n        self.LoginWindow.face4.connect(self.show_kebiao)\n    \n    ", "def", " ", "show_calculator", "(", "self", "):\n        self.calculator=calculator()\n        self.calculator.show()\n    ", "def", " ", "show_huaban", "(", "self", "):\n        self.huaban=huaban()\n        self.huaban.show()\n    ", "def", " ", "show_kebiao", "(", "self", "):\n        self.kebiao=kebiao()\n        self.kebiao.show()\n        \n        \n\n\n\n\n", "def", " ", "main", "():\n    app = QApplication(sys.argv)\n\n    controller = Controller() ", "# 控制器实例", "\n    controller.show_login() ", "# 默认展示的是 hello 页面", "\n    sys.exit(app.exec_())\n\n", "if", " __name__ == ", "'__main__'", ":\n\n    main()\n\n\n", "\n", "尝试二", "\n", "def", " ", "btn_press4_clicked", "(", "self", "):\n        \n        ", "import", " pandas ", "as", " pd\n        ", "from", " PyQt5.QtWidgets ", "import", " (QApplication, QTableView)\n        ", "from", " PyQt5.QtCore ", "import", " (QAbstractTableModel, Qt)\n\n        ", "class", " ", "PdTable", "(", "QAbstractTableModel", "):\n            ", "def", " ", "__init__", "(", "self, g", "):\n                QAbstractTableModel.__init__(self)\n                self._data = g\n        \n            ", "def", " ", "rowCount", "(", "self, parent=", "None", "):\n                ", "return", " self._data.shape[", "0", "]\n        \n            ", "def", " ", "columnCount", "(", "self, parent=", "None", "):\n                ", "return", " self._data.shape[", "1", "]\n        \n            ", "# 显示数据", "\n            ", "def", " ", "data", "(", "self, index, role=Qt.DisplayRole", "):\n                ", "if", " index.isValid():\n                    ", "if", " role == Qt.DisplayRole:\n                        ", "return", " ", "str", "(self._data.iloc[index.row(), index.column()])\n                ", "return", " ", "None", "\n        \n            ", "# 显示行和列头", "\n            ", "def", " ", "headerData", "(", "self, col, orientation, role", "):\n                ", "if", " orientation == Qt.Horizontal ", "and", " role == Qt.DisplayRole:\n                    ", "return", " self._data.columns[col]\n                ", "elif", " orientation == Qt.Vertical ", "and", " role == Qt.DisplayRole:\n                    ", "return", " self._data.axes[", "0", "][col]\n                ", "return", " ", "None", "\n        model = PdTable(g)\n        view = QTableView()\n        view.setModel(model)\n        view.setWindowTitle(", "'今日的课程'", ")\n        view.resize(", "410", ", ", "250", ")\n        view.setAlternatingRowColors(", "True", ")\n        view.show()\n", "class", " ", "calculator", " (QMainWindow,Calculator_UI):\n       ", "def", " ", "__init__", "(", "self,parent=", "None", "):\n            ", "super", "().__init__(parent)   \n       \n            self.start_x = ", "None", "\n            self.start_y = ", "None", "\n          \n", "class", " ", "huaban", "(QMainWindow,huaban_UI):\n       \n     ", "def", " ", "__init__", "(", "self", "):\n        ", "super", "(huaban_UI, self).__init__()\n\n        self.resize(", "400", ", ", "300", ")                  ", "#resize设置宽高，move设置位置", "\n        self.move(", "100", ", ", "100", ")\n        self.setWindowTitle(", "\"一个简单的画板\"", ")                          \n        \n        self.setMouseTracking(", "False", ")      ", "#setMouseTracking设置为False，否则不按下鼠标时也会跟踪鼠标事件        ", "\n        self.Drawing_Board = []           \n        self.start_x = ", "None", "\n        self.start_y = ", "None", "               ", "#用一个列表保存所有移动的点", "\n        ", "# self.setAttribute(QtCore.Qt.WA_TranslucentBackground)", "\n        ", "# self.setWindowFlags(Qt.FramelessWindowHint)  ", "\n\n\n\n\n", "class", " ", "Controller", ":\n    ", "def", " ", "__init__", "(", "self", "):\n        ", "pass", "\n    ", "# 跳转到 mainface 窗口", "\n    ", "def", " ", "show_login", "(", "self", "):\n        self.mainface = mainface()\n        self.mainface.face1.connect(self.show_face)\n        self.mainface.show()\n    ", "# 跳转到 LoginWindow 窗口, 注意关闭原页面", "\n    ", "def", " ", "show_face", "(", "self", "):\n        self.LoginWindow = LoginWindow()\n        self.mainface.close()\n        self.LoginWindow.show()\n        self.LoginWindow.face2.connect(self.show_calculator)\n        self.LoginWindow.face3.connect(self.show_huaban)\n    \n    ", "def", " ", "show_calculator", "(", "self", "):\n        self.calculator=calculator()\n        self.calculator.show()\n    ", "def", " ", "show_huaban", "(", "self", "):\n        self.huaban=huaban()\n        self.huaban.show()\n\n\n\n\n\n", "def", " ", "main", "():\n    app = QApplication(sys.argv)\n\n    controller = Controller() ", "# 控制器实例", "\n    controller.show_login() ", "# 默认展示的是 hello 页面", "\n    sys.exit(app.exec_())\n\n", "if", " __name__ == ", "'__main__'", ":\n\n    main()\n\n\n", "\n", "这是课表单独的代码", "\n", "from", " numpy ", "import", " isin\n", "import", " pandas ", "as", " pd\n", "import", " datetime\n", "from", " time ", "import", " strftime\npd.set_option(", "'display.unicode.east_asian_width'", ", ", "True", ")", "#解决不对齐", "\ndf=pd.read_excel(", "'myLife.xlsx'", ",sheet_name=", "'TaskList'", ",index_col=", "False", ")\n", "# print(df.head())#看看是否读取成功", "\ndf1=df.set_index([", "'日期'", "])\n", "# # print(df1.head())", "\n", "# df['日期']=df['日期'].astype('string')", "\ndf[", "'日期'", "]=pd.to_datetime(df[", "'日期'", "])\ntime=datetime.datetime.now()\na=time.strftime(", "\"%m/%#d/%y\"", ")\n", "# c=int(a)", "\n", "# # print(type(a))", "\n", "# # print(c)", "\n\n", "# # print(type(df))", "\n", "# df.info()", "\ntime = datetime.datetime.now().strftime(", "\"%Y-%m-%d\"", ")\n", "# print(type(time))", "\n", "print", "(time)\n\nd=df.loc[df[", "'日期'", "] == time ]\n", "print", "(d)\nf=d.drop_duplicates(subset=[", "'开始时间'", "])", "#剔除相同", "\n", "# print(f)", "\ne=f[[", "'日期'", ",", "'对象名'", ",", "'开始时间'", "]]\n", "# print(e)", "\ng=e.sort_values(by=[", "'开始时间'", "],ascending=", "False", ")\n", "print", "(g)\n\n\n\n\n", "import", " pandas ", "as", " pd\n", "from", " PyQt5.QtWidgets ", "import", " (QApplication, QTableView)\n", "from", " PyQt5.QtCore ", "import", " (QAbstractTableModel, Qt)\n\n", "class", " ", "PdTable", "(", "QAbstractTableModel", "):\n    ", "def", " ", "__init__", "(", "self, g", "):\n        QAbstractTableModel.__init__(self)\n        self._data = g\n \n    ", "def", " ", "rowCount", "(", "self, parent=", "None", "):\n        ", "return", " self._data.shape[", "0", "]\n \n    ", "def", " ", "columnCount", "(", "self, parent=", "None", "):\n        ", "return", " self._data.shape[", "1", "]\n \n    ", "# 显示数据", "\n    ", "def", " ", "data", "(", "self, index, role=Qt.DisplayRole", "):\n        ", "if", " index.isValid():\n            ", "if", " role == Qt.DisplayRole:\n                ", "return", " ", "str", "(self._data.iloc[index.row(), index.column()])\n        ", "return", " ", "None", "\n \n    ", "# 显示行和列头", "\n    ", "def", " ", "headerData", "(", "self, col, orientation, role", "):\n        ", "if", " orientation == Qt.Horizontal ", "and", " role == Qt.DisplayRole:\n            ", "return", " self._data.columns[col]\n        ", "elif", " orientation == Qt.Vertical ", "and", " role == Qt.DisplayRole:\n            ", "return", " self._data.axes[", "0", "][col]\n        ", "return", " ", "None", "\n\n", "if", " __name__ == ", "'__main__'", ":\n    ", "import", " sys\n    app = QApplication(sys.argv)\n\n    model = PdTable(g)\n    view = QTableView()\n    view.setModel(model)\n    view.setWindowTitle(", "'今日的课程'", ")\n    view.resize(", "410", ", ", "250", ")\n    view.setAlternatingRowColors(", "True", ")\n    view.show()\n \n    sys.exit(app.exec_())\n\n\n", "\n", "程序代码已经实现过多个界面的跳转 利用  Controller() # 控制器 方法", "\n", "######能否解答下如何用 Controller() # 控制器发射信号的方法实现课表界面的显示"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;题主要的代码如下&amp;#xff0c;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/093513908936123.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;from&lt;/span&gt; bs4 import BeautifulSoup\nimport requests\n\nheader &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;user-agent&amp;#34;&lt;/span&gt;:&lt;span class=\"hljs-string\"&gt;&amp;#34;Mozilla/5.0.html (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.html.2171.71 Safari/537.36&amp;#34;&lt;/span&gt;} \nqcc &amp;#61; requests.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;https://www.qcc.com/zhuanliDetail/1ae4fd11b950dc39fde2ec3d7b75beff.html&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-attribute\"&gt;headers&lt;/span&gt;&amp;#61;header)\n\nsoup &amp;#61; BeautifulSoup(qcc.content,&lt;span class=\"hljs-string\"&gt;&amp;#39;lxml&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-attribute\"&gt;ea_instructions&lt;/span&gt;&amp;#61;soup.select(&amp;#39;.ea_instructions&amp;#39;)[1]#有2个ea_instructions样式容器&amp;#xff0c;第一个为权利要求&amp;#xff0c;第二个为说明书\n&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(str(ea_instructions))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/026007907936143.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;有帮助或启发麻烦点下&lt;strong&gt;【采纳该答案】&lt;/strong&gt;&amp;#xff0c;谢谢~~有其他问题可以继续交流~&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "定义新的类型", "Question": ["如何使用python爬虫从企查查上获得专利文献内容？", ["问题遇到的现象和发生背景", "\n", "写毕业论文需要专利文献，选定企查查这个网站。", "\n", "问题相关代码，请勿粘贴截图", "\n", "from", " bs4.builder import HTMLTreeBuilder\nimport requests\nheader = {", "\"user-agent\"", ":", "\"Mozilla/5.0.html (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.html.2171.71 Safari/537.36\"", "} \nqcc = requests.", "get", "(", "'https://www.qcc.com/zhuanliDetail/1ae4fd11b950dc39fde2ec3d7b75beff.html'", ",", "headers", "=header)\n", "print", "(qcc.status_code)\n", "#200表明请求网页成功", "\n", "#输出响应体", "\n", "#print(qcc.text)", "\n", "#print(type(qcc.text))", "\n", "#print(qcc.content)", "\n", "#print(type(qcc.content))", "\n", "#.text 返回的是unicode型的数据，一般是在网页的header中定义的编码形式。", "\n", "#content返回的是bytes，二进制型的数据。", "\n", "#如果想要提取文本就用text", "\n", "#如果想要提取图片、文件、视频，就用到content", "\n\n", "#使用美味汤库这个解析库解析html代码", "\n", "from", " bs4 import BeautifulSoup\n", "#BeautifulSoup的解析对象是html字符串", "\nsoup = BeautifulSoup(qcc.content,", "'lxml'", ")\n", "#将待解析的字符串以标准的缩进格式输出", "\n", "print", "(soup.prettify())\n\n", "\n", "运行结果及报错内容", "\n", "200\n", "<!DOCTYPE ", "html", ">", "\n", "<", "html", " ", "class", "=", "\"\"", ">", "\n ", "<", "head", ">", "\n  ", "<", "title", ">", "\n   【纺织机以及纺织方法专利查询】专利号|摘要-企查查\n  ", "</", "title", ">", "\n  ", "<", "meta", " ", "content", "=", "\"\"", " ", "name", "=", "\"description\"", "/>", "\n  ", "<", "meta", " ", "content", "=", "\"纺织机以及纺织方法专利注册查询,免费纺织机以及纺织方法专利查询,最新纺织机以及纺织方法专利信息查询\"", " ", "name", "=", "\"keywords\"", "/>", "\n  ", "<", "meta", " ", "charset", "=", "\"utf-8\"", "/>", "\n  ", "<", "meta", " ", "content", "=", "\"width=device-width,initial-scale=1,minimal-ui\"", " ", "name", "=", "\"viewport\"", "/>", "\n  ", "<", "link", " ", "href", "=", "\"https://www.qcc.com/material/theme/chacha/cms/v2/images/favicon.png\"", " ", "rel", "=", "\"icon\"", "/>", "\n  ", "<!--[if lt IE 9]>\n       <link rel=\"stylesheet\" href=\"https://www.qcc.com/material/theme/chacha/cms/v2/css/app_ie8.css\" type=\"text/css\" />\n       <script src=\"https://www.qcc.com/material/theme/chacha/cms/v2/js/html5shiv.js\"></script>\n       <script src=\"https://www.qcc.com/material/theme/chacha/cms/v2/js/respond.js\"></script>\n       <![endif]-->", "\n  ", "<", "link", " ", "href", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/web/css/font-awesome.css\"", " ", "rel", "=", "\"stylesheet\"", " ", "type", "=", "\"text/css\"", "/>", "\n  ", "<", "link", " ", "href", "=", "\"//at.alicdn.com/t/font_2545218_04dsnmjd1raq.css\"", " ", "rel", "=", "\"stylesheet\"", " ", "type", "=", "\"text/css\"", "/>", "\n  ", "<", "link", " ", "href", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/vendor.17ce13bf.css\"", " ", "rel", "=", "\"stylesheet\"", "/>", "\n  ", "<", "link", " ", "href", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/main.17ce13bf.css\"", " ", "rel", "=", "\"stylesheet\"", "/>", "\n  ", "<", "link", " ", "href", "=", "\"https://www.qcc.com/zhuanliDetail/1ae4fd11b950dc39fde2ec3d7b75beff.html\"", " ", "rel", "=", "\"canonical\"", "/>", "\n ", "</", "head", ">", "\n ", "<", "body", ">", "\n  ", "<", "div", " ", "id", "=", "\"app\"", ">", "\n   ", "<", "div", " ", "data-server-rendered", "=", "\"true\"", ">", "\n    ", "<", "div", " ", "class", "=", "\"app-nheader hasInput fixed\"", ">", "\n     ", "<", "div", " ", "class", "=", "\"app-nheader-wrap\"", ">", "\n      ", "<", "div", " ", "class", "=", "\"container\"", ">", "\n       ", "<", "nav", " ", "class", "=", "\"navbar navbar-left\"", ">", "\n        ", "<", "div", " ", "class", "=", "\"navbar-brand\"", ">", "\n         ", "<", "a", " ", "href", "=", "\"https://www.qcc.com/\"", ">", "\n          ", "<", "img", " ", "class", "=", "\"logo\"", " ", "src", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/logo-063645ff.png\"", "/>", "\n         ", "</", "a", ">", "\n         ", "<", "a", ">", "\n          ", "<", "span", " ", "class", "=", "\"logo-zx\"", ">", "\n          ", "</", "span", ">", "\n         ", "</", "a", ">", "\n        ", "</", "div", ">", "\n       ", "</", "nav", ">", "\n       ", "<", "div", " ", "class", "=", "\"navi-form\"", ">", "\n        ", "<", "div", " ", "class", "=", "\"app-search-input medium\"", ">", "\n         ", "<", "div", " ", "class", "=", "\"form-group\"", ">", "\n          ", "<", "div", " ", "class", "=", "\"input-group\"", ">", "\n           ", "<", "input", " ", "autocomplete", "=", "\"off\"", " ", "class", "=", "\"form-control search-key\"", " ", "id", "=", "\"searchKey\"", " ", "maxlength", "=", "\"1000\"", " ", "name", "=", "\"key\"", " ", "placeholder", "=", "\"请输入企业名、人名、产品名，或地址电话/经营范围等\"", " ", "type", "=", "\"text\"", " ", "value", "=", "\"\"", "/>", "   \n           ", "<", "span", " ", "class", "=", "\"input-group-btn\"", ">", "\n            ", "<", "button", " ", "class", "=", "\"btn btn-primary\"", " ", "type", "=", "\"button\"", ">", "\n             查一下\n            ", "</", "button", ">", "\n           ", "</", "span", ">", "\n          ", "</", "div", ">", "\n          ", "<", "a", " ", "class", "=", "\"clear-searchkey\"", " ", "style", "=", "\"display:none;\"", ">", "\n          ", "</", "a", ">", "\n         ", "</", "div", ">", "\n         ", "<", "section", " ", "class", "=", "\"search-section\"", " ", "style", "=", "\"display:none;\"", ">", "\n          ", "<", "div", " ", "class", "=", "\"nologin\"", ">", "\n           ", "<", "img", " ", "src", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/nologin-6f715836.png\"", "/>", "\n           ", "<", "a", " ", "class", "=", "\"btn btn-primary m-t-xs\"", ">", "\n            登录试试\n           ", "</", "a", ">", "\n          ", "</", "div", ">", "\n         ", "</", "section", ">", "\n        ", "</", "div", ">", "\n       ", "</", "div", ">", "\n       ", "<", "nav", " ", "class", "=", "\"navbar navbar-right\"", ">", "\n        ", "<", "ul", " ", "class", "=", "\"navbar-nav\"", ">", "\n         ", "<", "li", " ", "class", "=", "\"nav-item\"", ">", "\n          ", "<", "a", " ", "class", "=", "\"nav-link dropdown-toggle no-cart\"", " ", "href", "=", "\"https://www.qcc.com/web/pay/vip\"", " ", "rel", "=", "\"nofollow\"", ">", "\n           ", "<", "img", " ", "class", "=", "\"gicon-vip\"", " ", "src", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/gicon_vip-e4325033.png\"", "/>", "\n           ", "<", "span", " ", "class", "=", "\"gcolor-vip\"", ">", "\n            VIP会员\n           ", "</", "span", ">", "\n          ", "</", "a", ">", "\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"head-line\"", ">", "\n          |\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"nav-item\"", ">", "\n          ", "<", "a", " ", "class", "=", "\"nav-link\"", " ", "href", "=", "\"https://www.qcc.com/web/pay/qiye\"", " ", "rel", "=", "\"nofollow\"", ">", "\n           企业套餐\n          ", "</", "a", ">", "\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"head-line\"", ">", "\n          |\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"nav-item dropdown app-box\"", ">", "\n          ", "<", "a", " ", "class", "=", "\"nav-link dropdown-toggle\"", " ", "data-toggle", "=", "\"dropdown\"", ">", "\n           应用\n           ", "<", "i", " ", "class", "=", "\"caret\"", ">", "\n           ", "</", "i", ">", "\n          ", "</", "a", ">", "\n          ", "<", "div", " ", "class", "=", "\"dropdown-menu app-list\"", " ", "style", "=", "\"display:none;\"", ">", "\n           ", "<", "div", " ", "class", "=", "\"clearfix\"", ">", "\n           ", "</", "div", ">", "\n          ", "</", "div", ">", "\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"nav-item dropdown header-qrcode\"", ">", "\n          ", "<", "a", " ", "class", "=", "\"nav-link dropdown-toggle no-cart\"", " ", "data-toggle", "=", "\"dropdown\"", " ", "href", "=", "\"https://www.qcc.com/web/app\"", " ", "rel", "=", "\"nofollow\"", ">", "\n           ", "<", "span", " ", "class", "=", "\"hicon-app\"", " ", "src", "=", "\"../images/icon_app.png\"", ">", "\n           ", "</", "span", ">", "\n          ", "</", "a", ">", "\n          ", "<", "div", " ", "class", "=", "\"dropdown-menu\"", ">", "\n           ", "<", "div", " ", "class", "=", "\"download-app-container\"", ">", "\n            ", "<", "img", " ", "class", "=", "\"download-app-qr-code\"", " ", "src", "=", "\"//qcc-static.qichacha.com/qcc/pc-web/prod-4.0.63/download-app-new-0d74a257.png\"", "/>", "\n           ", "</", "div", ">", "\n          ", "</", "div", ">", "\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"nav-item\"", ">", "\n          ", "<", "a", " ", "class", "=", "\"navi-btn login-nav-btn\"", " ", "rel", "=", "\"nofollow\"", ">", "\n           ", "<", "span", ">", "\n            登录 | 注册\n           ", "</", "span", ">", "\n          ", "</", "a", ">", "\n         ", "</", "li", ">", "\n        ", "</", "ul", ">", "\n       ", "</", "nav", ">", "\n      ", "</", "div", ">", "\n     ", "</", "div", ">", "\n    ", "</", "div", ">", "\n    ", "<", "div", " ", "class", "=", "\"container m-t-md patent-detail\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n     ", "<", "section", " ", "class", "=", "\"npanel npanel-default info-title\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n      ", "<", "div", " ", "class", "=", "\"title\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n       纺织机以及纺织方法\n      ", "</", "div", ">", "\n      ", "<", "div", " ", "class", "=", "\"tags\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n       ", "<", "span", " ", "class", "=", "\"ntag text-primary\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n        发明授权\n       ", "</", "span", ">", "\n       ", "<", "span", " ", "class", "=", "\"ntag text-success\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n        授权\n       ", "</", "span", ">", "\n      ", "</", "div", ">", "\n      ", "<", "a", " ", "class", "=", "\"download\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "href", "=", "\"https://patent-image.qichacha.com/pdf/1ae4fd11b950dc39fde2ec3d7b75beff.pdf\"", " ", "target", "=", "\"_blank\"", ">", "\n       ", "<", "i", " ", "aria-label", "=", "\"icon: icon-icon_xiazai\"", " ", "class", "=", "\"icon anticon anticon-icon-icon_xiazai text-primary aicon aicon-xiazai\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n        ", "<", "svg", " ", "aria-hidden", "=", "\"true\"", " ", "fill", "=", "\"currentColor\"", " ", "focusable", "=", "\"false\"", " ", "height", "=", "\"1em\"", " ", "width", "=", "\"1em\"", ">", "\n         ", "<", "use", " ", "xlink:href", "=", "\"#icon-icon_xiazai\"", ">", "\n         ", "</", "use", ">", "\n        ", "</", "svg", ">", "\n       ", "</", "i", ">", "\n       ", "<", "span", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n        专利文献\n       ", "</", "span", ">", "\n      ", "</", "a", ">", "\n     ", "</", "section", ">", "\n     ", "<", "div", " ", "class", "=", "\"row\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n      ", "<", "div", " ", "class", "=", "\"col-md-9\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n       ", "<", "section", " ", "class", "=", "\"npanel npanel-default patentdetailbox info-content\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n        ", "<", "ul", " ", "class", "=", "\"tabs row\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n         ", "<", "li", " ", "class", "=", "\"tabs-item col-md-2 tabs-item-active\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          基础信息\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"tabs-item col-md-2\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          法律状态\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"tabs-item col-md-2\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          权利要求\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"tabs-item col-md-2\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          说明书\n         ", "</", "li", ">", "\n         ", "<", "li", " ", "class", "=", "\"tabs-item col-md-2\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          附图\n         ", "</", "li", ">", "\n        ", "</", "ul", ">", "\n        ", "<", "div", " ", "class", "=", "\"detailContent\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n         ", "<", "div", " ", "class", "=", "\"part\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          ", "<", "div", " ", "class", "=", "\"tcaption\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "<", "h3", " ", "class", "=", "\"title\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n            基础信息\n           ", "</", "h3", ">", "\n           ", "<", "span", " ", "class", "=", "\"tbadge\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "</", "span", ">", "\n           ", "<", "span", " ", "class", "=", "\"watermark\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "</", "span", ">", "\n           ", "<", "div", " ", "class", "=", "\"right\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "</", "div", ">", "\n          ", "</", "div", ">", "\n          ", "<", "div", " ", "class", "=", "\"sub-part\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n           ", "<", "div", " ", "class", "=", "\"sub-title\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n            基本信息\n           ", "</", "div", ">", "\n           ", "<", "table", " ", "class", "=", "\"ntable\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"20%\"", ">", "\n              申请号\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"30%\"", ">", "\n              CN201610349600.8\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"20%\"", ">", "\n              申请日期\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"30%\"", ">", "\n              2016-05-24\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              公开(公告)号\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              CN106245163B\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              公开(公告)日\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              2021-01-05\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              优先权号\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              JP2015-118170\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              优先权日\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              2015-06-11\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              IPC分类号\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              D01H13/00；D01H13/30；D01H4/02\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              CPC分类号\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              -\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              专利类型\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              发明授权\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              简单法律状态\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              ", "<", "div", " ", "class", "=", "\"tags\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n               ", "<", "span", " ", "class", "=", "\"ntag text-success\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n                有效\n               ", "</", "span", ">", "\n              ", "</", "div", ">", "\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n           ", "</", "table", ">", "\n          ", "</", "div", ">", "\n          ", "<", "div", " ", "class", "=", "\"sub-part\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n           ", "<", "div", " ", "class", "=", "\"sub-title\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n            申请/代理机构\n           ", "</", "div", ">", "\n           ", "<", "table", " ", "class", "=", "\"ntable\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"20%\"", ">", "\n              申请(专利权)人\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"30%\"", ">", "\n              ", "<", "span", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n               ", "<", "a", " ", "href", "=", "\"https://www.qcc.com/firm/z020895bfc0c322a9cbf7e5c23ce3da8.html\"", " ", "target", "=", "\"_blank\"", ">", "\n                村田机械株式会社\n               ", "</", "a", ">", "\n              ", "</", "span", ">", "\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"20%\"", ">", "\n              发明人\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", " ", "width", "=", "\"30%\"", ">", "\n              冈正毅;北川哲\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              申请人地址\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              日本京都府\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              申请人邮编\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              -\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n            ", "<", "tr", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              代理机构\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              ", "<", "span", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n               ", "<", "a", " ", "href", "=", "\"https://www.qcc.com/firm/w114e43abc6d0e6272560b25c83f76d8.html\"", " ", "target", "=", "\"_blank\"", ">", "\n                北京市金杜律师事务所\n               ", "</", "a", ">", "\n              ", "</", "span", ">", "\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "class", "=", "\"tb\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              代理人\n             ", "</", "td", ">", "\n             ", "<", "td", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n              陈伟\n             ", "</", "td", ">", "\n            ", "</", "tr", ">", "\n           ", "</", "table", ">", "\n          ", "</", "div", ">", "\n          ", "<", "div", " ", "class", "=", "\"sub-part\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n           ", "<", "div", " ", "class", "=", "\"sub-title\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n            摘要\n           ", "</", "div", ">", "\n           ", "<", "div", " ", "class", "=", "\"part-content\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n            本发明涉及一种纺织机以及纺织方法，纺织机(1)具备：空气纺织装置(7)，其通过利用空气对纤维束(F)加捻的纺织动作来生成纱线(Y)；供给装置(60)，其在空气纺织装置(7)中的与纤维束(F)的入口相比靠上游侧的 \n位置、与空气纺织装置(7)中的纱线(Y)的出口之间，对纤维束(F)或纱线(Y)供给包含添加剂的含添加剂空气；以及控制装置(10)，其控制供给装置(60)的动作。在应通过空气纺织装置(7)持续进行纺织动作的运转状况下纺织动作暂\n时中断时，控制装置(10)在该中断过程中的至少一部分期间内，从供给装置(60)供给含添加剂空气。\n           ", "</", "div", ">", "\n          ", "</", "div", ">", "\n         ", "</", "div", ">", "\n         ", "<", "div", " ", "class", "=", "\"part\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n          ", "<", "div", " ", "class", "=", "\"tcaption\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "<", "h3", " ", "class", "=", "\"title\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n            法律状态\n           ", "</", "h3", ">", "\n           ", "<", "span", " ", "class", "=", "\"tbadge\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "</", "span", ">", "\n           ", "<", "span", " ", "class", "=", "\"watermark\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "</", "span", ">", "\n           ", "<", "div", " ", "class", "=", "\"right\"", " ", "data-v-621a97fe", "=", "\"\"", ">", "\n           ", "</", "div", ">", "\n          ", "</", "div", ">", "\n          ", "<", "div", " ", "class", "=", "\"part-content clearfix\"", " ", "data-v-08c2d20b", "=", "\"\"", ">", "\n           ", "<", "div", " ", "class", "=", "\"e_history\"", " ", "data-v-08c2d20b", "=", "\"\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n            ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n             ", "<", "div", " ", "class", "=", "\"ea_item\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n              ", "<", "div", " ", "class", "=", "\"ea_row1\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n               ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_num ea_last\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                 3\n                ", "</", "div", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_date\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                 2021-01-05\n                ", "</", "div", ">", "\n               ", "</", "div", ">", "\n               ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_line\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                ", "</", "div", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_content\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                 授权\n                ", "</", "div", ">", "\n               ", "</", "div", ">", "\n              ", "</", "div", ">", "\n             ", "</", "div", ">", "\n            ", "</", "div", ">", "\n            ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n             ", "<", "div", " ", "class", "=", "\"ea_item\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n              ", "<", "div", " ", "class", "=", "\"ea_row1\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n               ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_num\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                 2\n                ", "</", "div", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_date\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                 2018-06-29\n                ", "</", "div", ">", "\n               ", "</", "div", ">", "\n               ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_line\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                ", "</", "div", ">", "\n                ", "<", "div", " ", "class", "=", "\"ea_content\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                 实质审查的生效\n                 ", "<", "a-popover", " ", "data-v-bd373d2a", "=", "\"\"", " ", "placement", "=", "\"right\"", ">", "\n                  ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", " ", "slot", "=", "\"content\"", ">", "\n                   ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                    实质审查的生效\n                   ", "</", "div", ">", "\n                   ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                    IPC(主分类):D01H   4/02\n                   ", "</", "div", ">", "\n                   ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                    专利申请号:2016103496008\n                   ", "</", "div", ">", "\n                   ", "<", "div", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                    申请日:20160524\n                   ", "</", "div", ">", "\n                  ", "</", "div", ">", "\n                  ", "<", "i", " ", "aria-label", "=", "\"icon: icon-icon_zhushi\"", " ", "class", "=", "\"app-glossary-info anticon anticon-icon-icon_zhushi aicon aicon-zhushi\"", " ", "data-v-bd373d2a", "=", "\"\"", ">", "\n                   ", "<", "svg", " ", "aria-hidden", "=", "\"true\"", " ", "fill", "=", "\"currentColor\"", " ", "focusable", "=", "\"false\"", " ", "height", "=", "\"1em\"", " ", "width", "=", "\"1em\"", ">", "\n                    ", "<", "use", " ", "xlink:href", "=", "\"#icon-icon_zhushi\"", ">", "\n                    ", "</", "use", ">", "\n                   ", "</", "svg", ">", "\n                  ", "</", "i", ">", "\n                 ", "</", "a-popover", ">", "\n                ", "</", "div", ">", "\n\n", "\n", "我想要达到的结果", "\n", "希望获得说明书部分"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个是因为你的PlayList 类的成员变量没有初始化赋值&amp;#xff0c;默认都是null&amp;#xff0c;所以在你添加播放列表的时候报了空指针。&lt;/p&gt;\n&lt;p&gt;你可以在构造方法里去初始化&amp;#xff0c;也可以在创建完对象之后手动去set。&lt;br /&gt;构造方法里初始化只用改 PlayList  类就可以&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;/**\n     * 构造方法\n     */&lt;/span&gt;\n \n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;PlayList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.musicList &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;ArrayList&lt;/span&gt;&amp;lt;Song&amp;gt;();\n    }\n \n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;PlayList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; playListName)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.playListName &amp;#61; playListName;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.musicList &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;ArrayList&lt;/span&gt;&amp;lt;Song&amp;gt;();\n    }\n \n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;PlayList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; playListName, List&amp;lt;Song&amp;gt; musicList)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.playListName &amp;#61; playListName;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.musicList &amp;#61; musicList;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面是完整代码 &lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt; \n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.&lt;span class=\"hljs-property\"&gt;util&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;ArrayList&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.&lt;span class=\"hljs-property\"&gt;util&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;List&lt;/span&gt;;\n \n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;PlayList&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; playListName;&lt;span class=\"hljs-comment\"&gt;// 播放列表的名称&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt;&amp;gt; musicList;&lt;span class=\"hljs-comment\"&gt;// 播放列表的歌曲集合&lt;/span&gt;\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 构造方法\n     */&lt;/span&gt;\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;PlayList&lt;/span&gt;() {\n \n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;PlayList&lt;/span&gt;(&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; playListName) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;playListName&lt;/span&gt; &amp;#61; playListName;\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;musicList&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ArrayList&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt;&amp;gt;();\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;PlayList&lt;/span&gt;(&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; playListName, &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt;&amp;gt; musicList) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;playListName&lt;/span&gt; &amp;#61; playListName;\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;musicList&lt;/span&gt; &amp;#61; musicList;\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 将歌曲添加到播放列表\n     * \n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; song 要添加的歌曲\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;addToPlayList&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;Song song&lt;/span&gt;) {\n        &lt;span class=\"hljs-comment\"&gt;// 要排除重复添加的情况&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;boolean&lt;/span&gt; flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song1 : musicList) {\n            &lt;span class=\"hljs-comment\"&gt;// 判断添加的歌曲和播放列表的歌曲是否有重复&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (song1.&lt;span class=\"hljs-title function_\"&gt;equals&lt;/span&gt;(song)) {\n                flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n        &lt;span class=\"hljs-comment\"&gt;// 如果歌曲已存在&amp;#xff0c;添加失败提示语&amp;#xff0c;否则将歌曲添加到播放列表中&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flag) {\n            &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;该歌曲已存在于播放列表中&amp;#xff0c;添加失败&amp;#xff01;&amp;#34;&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            musicList.&lt;span class=\"hljs-title function_\"&gt;add&lt;/span&gt;(song);\n        }\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 通过歌曲id查询歌曲信息\n     * \n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; id 歌曲id\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;return&lt;/span&gt; 查询到的歌曲信息\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;searchSongById&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; id&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song &amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// id是唯一的&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song1 : musicList) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (song1.&lt;span class=\"hljs-title function_\"&gt;getId&lt;/span&gt;().&lt;span class=\"hljs-title function_\"&gt;equals&lt;/span&gt;(id)) {\n                &lt;span class=\"hljs-comment\"&gt;// 如果相等就找到了&lt;/span&gt;\n                song &amp;#61; song1;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; song;\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 通过歌曲name查询歌曲信息\n     * \n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; name 歌曲名称\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;return&lt;/span&gt; 查询到的歌曲信息\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;searchSongByName&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; name&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song &amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;// id是唯一的&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song1 : musicList) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (song1.&lt;span class=\"hljs-title function_\"&gt;getName&lt;/span&gt;().&lt;span class=\"hljs-title function_\"&gt;equals&lt;/span&gt;(name)) {\n                &lt;span class=\"hljs-comment\"&gt;// 如果相等就找到了&lt;/span&gt;\n                song &amp;#61; song1;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; song;\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 修改播放列表中的歌曲信息\n     * \n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; id   要修改的歌曲id\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; song 新的歌曲信息\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;updateSong&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; id, Song song&lt;/span&gt;) {\n        &lt;span class=\"hljs-comment\"&gt;// 根据id查询到相关的歌曲信息&amp;#xff0c;然后再进行修改&lt;/span&gt;\n        &lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song1 &amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;;\n        song1 &amp;#61; &lt;span class=\"hljs-title function_\"&gt;searchSongById&lt;/span&gt;(id);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (song1 &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;) {\n            &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有找到id为&amp;#34;&lt;/span&gt; &amp;#43; id &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;对应的歌曲信息&amp;#xff01;&amp;#34;&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-comment\"&gt;// 先移除原来的信息&amp;#xff0c;然后再重新添加&lt;/span&gt;\n            musicList.&lt;span class=\"hljs-title function_\"&gt;remove&lt;/span&gt;(song1);\n            musicList.&lt;span class=\"hljs-title function_\"&gt;add&lt;/span&gt;(song);\n            &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;修改成功&amp;#xff01;&amp;#34;&lt;/span&gt;);\n        }\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 删除播放列表中的指定歌曲信息\n     * \n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; id 歌曲id\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;deleteSong&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; id&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song &amp;#61; &lt;span class=\"hljs-title function_\"&gt;searchSongById&lt;/span&gt;(id);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (song !&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;) {\n            musicList.&lt;span class=\"hljs-title function_\"&gt;remove&lt;/span&gt;(song);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;没有找到id为&amp;#34;&lt;/span&gt; &amp;#43; id &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;对应的歌曲信息&amp;#xff01;&amp;#34;&lt;/span&gt;);\n        }\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 显示播放列表中的所有歌曲\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;displayAllSong&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;播放列表中的所有歌曲为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt; song : musicList) {\n            &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(song);\n        }\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getPlayListName&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; playListName;\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setPlayListName&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; playListName&lt;/span&gt;) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;playListName&lt;/span&gt; &amp;#61; playListName;\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;Song&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-title function_\"&gt;getMusicList&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; musicList;\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setMusicList&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;List&amp;lt;Song&amp;gt; musicList&lt;/span&gt;) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;musicList&lt;/span&gt; &amp;#61; musicList;\n    }\n \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "定义新的类型", "Question": ["空指针异常报错，如何处理？", ["我在执行代码的时候，报了空指针异常的错误，但是 我没有找到原因在哪，如何修改，请哪位仁兄帮忙指导下，谢谢啦。", "\n", "\n\npackage com.imooc.player;\n\n", "/**\n * 歌曲类\n * \n * @author Administrator\n *\n */", "\npublic ", "class", " Song {\n    ", "private", " String id;", "// 歌曲id", "\n    ", "private", " String name;", "// 歌曲名称", "\n    ", "private", " String singer;", "// 演唱者", "\n\n    public ", "Song(String ", "id", ", String ", "name", ", String ", "singer", ")", " {\n        this.id = id;\n        this.name = name;\n        this.singer = singer;\n    }\n\n    public String get", "Id()", " {\n        return id;\n    }\n\n    public void set", "Id(String ", "id", ")", " {\n        this.id = id;\n    }\n\n    public String get", "Name()", " {\n        return name;\n    }\n\n    public void set", "Name(String ", "name", ")", " {\n        this.name = name;\n    }\n\n    public String get", "Singer()", " {\n        return singer;\n    }\n\n    public void set", "Singer(String ", "singer", ")", " {\n        this.singer = singer;\n    }\n\n    ", "/**\n     * hashCode方法和equals方法相辅相成 使用hashCode方法的作用是为了快速查找\n     * 参考：https://blog.csdn.net/wangqsse/article/details/107198059\n     * 若hashCode方法中，两个对象的值相等的话则用equals方法继续对比两个对象 值是否相等。\n     */", "\n    @Override\n    public ", "int", " hash", "Code()", " {\n        final ", "int", " prime = ", "31", ";\n        ", "int", " result = ", "1", ";\n        result = prime", " * ", "result + ((id", " == ", "null) ? ", "0", " : id.hash", "Code()", ");\n        result = prime", " * ", "result + ((name", " == ", "null) ? ", "0", " : name.hash", "Code()", ");\n        result = prime", " * ", "result + ((singer", " == ", "null) ? ", "0", " : singer.hash", "Code()", ");\n        return result;\n    }\n\n    @Override\n    ", "// 判断两个Song类的对象是否相等，必须三个属性全部相等才可以。", "\n    public boolean equals(Object obj) {\n        ", "// 判断对象相等，相等则直接返回true,this代表当前对象 obj代表比较对象", "\n        ", "if", " (this", " == ", "obj)\n            return ", "true", ";\n        ", "// this!=obj,判断obj类型是否和Song类型一样", "\n        ", "if", " (obj.get", "Class()", " == ", "Song", ".", "class", ") {\n            ", "// 强制类型转换", "\n            Song song = (Song) obj;\n            return (song.get", "Id()", ".equals(id))", " && ", "(song.get", "Name()", ".equals(name))", " && ", "(song.get", "Singer()", ".equals(singer));\n        }\n        ", "// 若其中一项不相等，则返回false", "\n        return ", "false", ";\n\n    }\n\n    @Override\n    public String ", "to", "String()", " {\n        return ", "\"歌曲信息： id为：\"", " + id + ", "\", 歌曲名称为：\"", " + name + ", "\", 演唱者为：\"", " + singer;\n    }\n\n}\n\n\npackage com.imooc.player;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic ", "class", " PlayList {\n    ", "private", " String playListName;", "// 播放列表的名称", "\n    ", "private", " List<Song> musicList;", "// 播放列表的歌曲集合", "\n\n    ", "/**\n     * 构造方法\n     */", "\n\n    public ", "PlayList()", " {\n\n    }\n\n    public ", "PlayList(String ", "playListName", ")", " {\n\n    }\n\n    public ", "PlayList(String ", "playListName", ", List<Song> ", "musicList", ")", " {\n        this.playListName = playListName;\n        musicList = ", "new", " ArrayList<Song>", "()", ";\n    }\n\n    ", "/**\n     * 将歌曲添加到播放列表\n     * \n     * @param song 要添加的歌曲\n     */", "\n    public void add", "ToPlayList(Song ", "song", ")", " {\n        ", "// 要排除重复添加的情况", "\n        boolean flag = ", "false", ";\n        ", "for", " (Song song1 : musicList) {\n            ", "// 判断添加的歌曲和播放列表的歌曲是否有重复", "\n            ", "if", " (song1.equals(song)) {\n                flag = ", "true", ";\n                break;\n            }\n        }\n        ", "// 如果歌曲已存在，添加失败提示语，否则将歌曲添加到播放列表中", "\n        ", "if", " (flag) {\n            ", "System", ".", "out.println(", "\"该歌曲已存在于播放列表中，添加失败！\"", ");\n        } ", "else", " {\n            musicList.add(song);\n        }\n    }\n\n    ", "/**\n     * 通过歌曲id查询歌曲信息\n     * \n     * @param id 歌曲id\n     * @return 查询到的歌曲信息\n     */", "\n    public Song search", "SongById(String ", "id", ")", " {\n        Song song = null;\n        ", "// id是唯一的", "\n        ", "for", " (Song song1 : musicList) {\n            ", "if", " (song1.get", "Id()", ".equals(id)) {\n                ", "// 如果相等就找到了", "\n                song = song1;\n                break;\n            }\n        }\n        return song;\n    }\n\n    ", "/**\n     * 通过歌曲name查询歌曲信息\n     * \n     * @param name 歌曲名称\n     * @return 查询到的歌曲信息\n     */", "\n    public Song search", "SongByName(String ", "name", ")", " {\n        Song song = null;\n        ", "// id是唯一的", "\n        ", "for", " (Song song1 : musicList) {\n            ", "if", " (song1.get", "Name()", ".equals(name)) {\n                ", "// 如果相等就找到了", "\n                song = song1;\n                break;\n            }\n        }\n        return song;\n    }\n\n    ", "/**\n     * 修改播放列表中的歌曲信息\n     * \n     * @param id   要修改的歌曲id\n     * @param song 新的歌曲信息\n     */", "\n    public void update", "Song(String ", "id", ", Song ", "song", ")", " {\n        ", "// 根据id查询到相关的歌曲信息，然后再进行修改", "\n        Song song1 = null;\n        song1 = search", "SongById(", "id", ")", ";\n        ", "if", " (song1", " == ", "null) {\n            ", "System", ".", "out.println(", "\"没有找到id为\"", " + id + ", "\"对应的歌曲信息！\"", ");\n        } ", "else", " {\n            ", "// 先移除原来的信息，然后再重新添加", "\n            musicList.remove(song1);\n            musicList.add(song);\n            ", "System", ".", "out.print(", "\"修改成功！\"", ");\n        }\n    }\n\n    ", "/**\n     * 删除播放列表中的指定歌曲信息\n     * \n     * @param id 歌曲id\n     */", "\n    public void delete", "Song(String ", "id", ")", " {\n        Song song = search", "SongById(", "id", ")", ";\n        ", "if", " (song != null) {\n            musicList.remove(song);\n        } ", "else", " {\n            ", "System", ".", "out.println(", "\"没有找到id为\"", " + id + ", "\"对应的歌曲信息！\"", ");\n        }\n    }\n\n    ", "/**\n     * 显示播放列表中的所有歌曲\n     */", "\n    public void display", "AllSong()", " {\n        ", "System", ".", "out.println(", "\"播放列表中的所有歌曲为：\"", ");\n        ", "for", " (Song song : musicList) {\n            ", "System", ".", "out.println(song);\n        }\n    }\n\n    public String get", "PlayListName()", " {\n        return playListName;\n    }\n\n    public void set", "PlayListName(String ", "playListName", ")", " {\n        this.playListName = playListName;\n    }\n\n    public List<Song> get", "MusicList()", " {\n        return musicList;\n    }\n\n    public void set", "MusicList(List<Song> ", "musicList", ")", " {\n        this.musicList = musicList;\n    }\n\n}\n\n\npackage com.imooc.player;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n", "/**\n * 播放列表集合\n * \n * @author Administrator\n *\n */", "\npublic ", "class", " PlayListCollection {\n    Map<String, PlayList> playListMap;", "// 存放播放列表集合", "\n\n    public ", "PlayListCollection()", " {\n        playListMap = ", "new", " HashMap<String, PlayList>", "()", ";\n    }\n\n    ", "/**\n     * 向播放列表集合（播放器）添加播放列表\n     * \n     * @param playList 要添加的播放列表\n     */", "\n    public void add", "PlayList(PlayList ", "playList", ")", " {\n        ", "// key值为播放列表名称：playListName；value值为PlayList类型的对象：playList", "\n        playListMap.put(playList.get", "PlayListName()", ", playList);\n    }\n\n    ", "/**\n     * 删除播放列表\n     * \n     * @param playList 要删除的播放列表对象\n     */", "\n    public void delete", "PlayList(PlayList ", "playList", ")", " {\n        playListMap.remove(playList.get", "PlayListName()", ");\n        ", "System", ".", "out.println(", "\"删除成功！\"", ");\n    }\n\n    ", "/**\n     * 通过播放列表的名称查询播放列表\n     * \n     * @param playListName 播放列表名称\n     * @return 播放列表\n     */", "\n    public PlayList search", "PlayListByName(String ", "playListName", ")", " {\n", "//        PlayList playList = new PlayList();", "\n        PlayList playList =null;\n        ", "// 查询当前播放列表的名字是否在集合中存在", "\n        ", "// playListMap.keySet()即存放播放列表集合中的key值：playListName播放列表名称", "\n        Set<String> playListSet = playListMap.key", "Set()", ";\n        ", "// 遍历playListSet集合", "\n        ", "for", " (String s : playListSet) {\n            ", "if", " (s.equals(playListName)) {\n                ", "// 如果找到了，就把找到的内容赋值给playList", "\n                ", "// playListMap.get(key)：通过key值查询", "\n                playList = playListMap.get(s);\n                break;\n            }\n        }\n        return playList;\n    }\n\n    ", "/**\n     * 显示所有播放列表的名称\n     */", "\n    public void display", "ListName()", " {\n        ", "//设定一个Set的集合来存储key的值", "\n        Set<String> playListSet = playListMap.key", "Set()", ";\n        ", "System", ".", "out.println(", "\"播放列表名称为：\"", ");\n        ", "//遍历Set集合", "\n        ", "for", " (String s : playListSet) {\n            ", "System", ".", "out.println(s);\n        }\n    }\n\n    public Map<String, PlayList> get", "PlayListMap()", " {\n        return playListMap;\n    }\n\n    public void set", "PlayListMap(Map<String, PlayList> ", "playListMap", ")", " {\n        this.playListMap = playListMap;\n    }\n\n}\n\n\npackage com.imooc.player;\n\nimport java.util.Scanner;\n\n", "/**\n\n * 播放列表管理的主要功能\n\n * @author Administrator\n   *将歌曲添加到主播放列表\n    *将歌曲添加到普通播放列表\n    *通过歌曲id查询播放列表中的歌曲\n    *通过歌曲名称查询播放列表中的歌曲\n    *修改播放列表中的歌曲\n    *删除播放列表中的歌曲\n    *显示播放列表中的所有歌曲\n    */", "\n", "/**\n * \n * 播放器管理的主要功能\n * \n * \n * \n * @author Administrator 向播放器添加播放列表 从播放器删除播放列表 通过名字查询播放列表信息 显示所有播放列表名称\n */", "\npublic ", "class", " TestDemo {\n\n    ", "private", " String playerName;\n\n    ", "// 对歌曲类Song进行测试", "\n    ", "// public void testSong() {", "\n    ", "// Song song1 = new Song(\"S001\", \"两只老虎\", \"小太阳\");", "\n    ", "// Song song2 = new Song(\"S002\", \"小燕子\", \"风车\");", "\n    ", "// Song song3 = new Song(\"S003\", \"茉莉花\", \"彩虹\");", "\n    ", "// Song song4 = new Song(\"S003\", \"茉莉花\", \"彩虹\");", "\n    ", "// System.out.println(song1);", "\n    ", "// // 测试song1和song3这两个对象是否相等", "\n    ", "// System.out.println(\"song1==song3?\" + (song4.equals(song3)));", "\n    ", "// }", "\n\n", "//对播放列表类PlayList进行测试", "\n    public void test", "PlayList()", " {\n        ", "// 定义几个Song类的对象，添加到播放列表中", "\n        Song song1 = ", "new", " ", "Song(", "\"s001\"", ", ", "\"两只老虎\"", ", ", "\"小太阳\"", ")", ";\n        Song song2 = ", "new", " ", "Song(", "\"s002\"", ", ", "\"小燕子\"", ", ", "\"风车\"", ")", ";\n        Song song3 = ", "new", " ", "Song(", "\"s003\"", ", ", "\"茉莉花\"", ", ", "\"彩虹\"", ")", ";\n        Song song4 = ", "new", " ", "Song(", "\"s003\"", ", ", "\"茉莉花\"", ", ", "\"彩虹\"", ")", ";\n        ", "// 创建一个 PlayList对象", "\n        PlayList mainPlayList = ", "new", " ", "PlayList(", "\"主播放列表\"", ")", ";\n        mainPlayList.add", "ToPlayList(", "song1", ")", ";\n        mainPlayList.add", "ToPlayList(", "song2", ")", ";\n        mainPlayList.add", "ToPlayList(", "song3", ")", ";\n        ", "// 显示播放列表的内容", "\n        mainPlayList.display", "AllSong()", ";\n        ", "// 通过id查询歌曲信息", "\n        Song song = mainPlayList.search", "SongById(", "\"s003\"", ")", ";\n        ", "if", " (song != null) {\n            ", "System", ".", "out.println(", "\"根据id查询的歌曲信息为：\"", ");\n            ", "System", ".", "out.println(song);\n        } ", "else", " {\n            ", "System", ".", "out.println(", "\"该歌曲不存在！\"", ");\n        }\n\n        ", "// 通过名称查询歌曲信息", "\n        ", "// song值之前已赋值，所以需要先置空", "\n        song = null;\n        song = mainPlayList.search", "SongByName(", "\"小燕子\"", ")", ";\n        ", "if", " (song != null) {\n            ", "System", ".", "out.println(", "\"根据name查询的歌曲信息为：\"", ");\n            ", "System", ".", "out.println(song);\n        } ", "else", " {\n            ", "System", ".", "out.println(", "\"该歌曲不存在！\"", ");\n        }\n\n        ", "// 修改播放列表歌曲信息", "\n        Song songUpdate = ", "new", " ", "Song(", "\"s005\"", ", ", "\"蜗牛与黄鹂鸟\"", ", ", "\"小太阳\"", ")", ";\n        mainPlayList.update", "Song(", "\"s003\"", ", ", "songUpdate", ")", ";\n        mainPlayList.display", "AllSong()", ";\n        ", "// 删除歌曲信息", "\n        mainPlayList.delete", "Song(", "\"s005\"", ")", ";\n        mainPlayList.display", "AllSong()", ";\n    }\n\n    ", "// 测试播放列表集合类", "\n    public void test", "PlayListCollection()", " {\n        Song song1 = ", "new", " ", "Song(", "\"s001\"", ", ", "\"两只老虎\"", ", ", "\"小太阳\"", ")", ";\n        Song song2 = ", "new", " ", "Song(", "\"s002\"", ", ", "\"小燕子\"", ", ", "\"风车\"", ")", ";\n        Song song3 = ", "new", " ", "Song(", "\"s003\"", ", ", "\"茉莉花\"", ", ", "\"彩虹\"", ")", ";\n        Song song4 = ", "new", " ", "Song(", "\"s003\"", ", ", "\"茉莉花\"", ", ", "\"彩虹\"", ")", ";\n        ", "// 创建主播放列表", "\n        PlayList mainPlayList = ", "new", " ", "PlayList(", "\"主播放列表\"", ")", ";\n        ", "// 将歌曲添加到主播放列表中", "\n        mainPlayList.add", "ToPlayList(", "song1", ")", ";\n        mainPlayList.add", "ToPlayList(", "song2", ")", ";\n        mainPlayList.add", "ToPlayList(", "song3", ")", ";\n        ", "// 定义一个新的播放列表，从主播放列表中添加歌曲进来", "\n        PlayList favouritePlayList = ", "new", " ", "PlayList(", "\"最喜欢的歌曲\"", ")", ";\n        ", "// getMusicList:主播放列表，get(0)获取第一首歌曲", "\n        favouritePlayList.add", "ToPlayList(", "mainPlayList", ".", "getMusicList", "()", ".get(", "0", "));\n        favouritePlayList.add", "ToPlayList(", "mainPlayList", ".", "getMusicList", "()", ".get(", "1", "));\n        ", "// 所有歌曲打印输出", "\n        favouritePlayList.display", "AllSong()", ";\n        ", "// 将两个播放列表添加到播放列表集合中", "\n        PlayListCollection plc = ", "new", " ", "PlayListCollection()", ";\n        ", "// 添加主播放列表", "\n        plc.add", "PlayList(", "mainPlayList", ")", ";\n        ", "// 添加新播放列表", "\n        plc.add", "PlayList(", "favouritePlayList", ")", ";\n        ", "// 打印输出所有的播放列表", "\n        plc.display", "ListName()", ";\n        ", "// 根据播放列表名字查询播放列表信息，并显示所有歌曲", "\n        PlayList playList = plc.search", "PlayListByName(", "\"最喜欢的歌曲\"", ")", ";\n        playList.display", "AllSong()", ";\n        ", "// 删除播放列表信息", "\n        ", "System", ".", "out.println(", "\"删除前：\"", ");\n        plc.display", "ListName()", ";\n        ", "// 删除指定播放列表", "\n        plc.delete", "PlayList(", "favouritePlayList", ")", ";\n        ", "System", ".", "out.println(", "\"删除后：\"", ");\n        plc.display", "ListName()", ";\n    }\n\n    ", "// 主菜单", "\n    public void main", "Menu()", " {\n        ", "System", ".", "out.println(", "\"***********************\"", ");\n        ", "System", ".", "out.println(", "\"***主菜单***\"", ");\n        ", "System", ".", "out.println(", "\"1--播放列表管理\"", ");\n        ", "System", ".", "out.println(", "\"2--播放器管理\"", ");\n        ", "System", ".", "out.println(", "\"0--退出\"", ");\n        ", "System", ".", "out.println(", "\"***********************\"", ");\n    }\n\n    ", "// 播放列表管理菜单", "\n    public void play", "ListMenu()", " {\n        ", "System", ".", "out.println(", "\"**********************************\"", ");\n        ", "System", ".", "out.println(", "\"***播放列表管理***\"", ");\n        ", "System", ".", "out.println(", "\"1--将歌曲添加到主播放列表\"", ");\n        ", "System", ".", "out.println(", "\"2--将歌曲添加到普通播放列表\"", ");\n        ", "System", ".", "out.println(", "\"3--通过歌曲id查询播放列表中的歌曲\"", ");\n        ", "System", ".", "out.println(", "\"4--通过歌曲名称查询播放列表中的歌曲\"", ");\n        ", "System", ".", "out.println(", "\"5--修改播放列表中的歌曲  \"", ");\n        ", "System", ".", "out.println(", "\"6--删除播放列表中的歌曲  \"", ");\n        ", "System", ".", "out.println(", "\"7--显示播放列表中的所有歌曲  \"", ");\n        ", "System", ".", "out.println(", "\"9--返回上一家菜单\"", ");\n        ", "System", ".", "out.println(", "\"**********************************\"", ");\n    }\n\n    ", "// 播放器菜单", "\n    public void play", "Menu()", " {\n        ", "System", ".", "out.println(", "\"**********************************\"", ");\n        ", "System", ".", "out.println(", "\"***播放器管理***\"", ");\n        ", "System", ".", "out.println(", "\"1--向播放器添加播放列表\"", ");\n        ", "System", ".", "out.println(", "\"2--从播放器删除播放列表\"", ");\n        ", "System", ".", "out.println(", "\"3--通过名字查询播放列表信息\"", ");\n        ", "System", ".", "out.println(", "\"4--显示所有播放列表名称\"", ");\n        ", "System", ".", "out.println(", "\"9--返回上一级菜单\"", ");\n        ", "System", ".", "out.println(", "\"**********************************\"", ");\n    }\n\n", "//主流程", "\n    public void test", "()", " {\n        TestDemo td = ", "new", " ", "TestDemo()", ";\n        Scanner sc = ", "new", " ", "Scanner(System.", "in", ")", ";\n        ", "int", " input = ", "0", ", input1 = ", "0", ", input2 = ", "0", ";\n        ", "// 创建一个播放列表容器（播放器）", "\n        PlayListCollection plc = ", "new", " ", "PlayListCollection()", ";\n        ", "// 创建主播放列表", "\n        PlayList mainPlayList = ", "new", " ", "PlayList(", "\"主播放列表\"", ")", ";\n        ", "// 将主播放列表添加到播放器", "\n        plc.add", "PlayList(", "mainPlayList", ")", ";\n        ", "// 创建一个普通播放列表的对象，默认值为null", "\n        PlayList favouritePlayList = null;\n\n        ", "// 显示 主菜单界面", "\n        ", "while", " (", "true", ") {\n            td.main", "Menu()", ";\n            ", "System", ".", "out.println(", "\"请输入对应数字进行操作：\"", ");\n            input = sc.next", "Int()", ";", "// 此处理论上应有异常判断，当输入非数字时抛出异常，参考前面例题", "\n            ", "if", " (input", " == ", "0", ") {\n                break;\n            }\n            switch (input) {\n            case ", "1", ":\n                ", "// 播放列表管理", "\n                ", "while", " (", "true", ") {\n                    td.play", "ListMenu()", ";\n                    ", "System", ".", "out.println(", "\"请输入对应的数字对播放列表进行管理：\"", ");\n                    input1 = sc.next", "Int()", ";\n\n                    ", "if", " (input1", " == ", "9", ")\n                        break;\n                    switch (input1) {\n                    case ", "1", ":\n                        ", "System", ".", "out.println(", "\"将歌曲添加到主播放列表\"", ");\n                        ", "System", ".", "out.println(", "\"请输入要添加的歌曲的数量：\"", ");\n                        ", "int", " count = sc.next", "Int()", ";\n                        ", "for", " (", "int", " i = ", "1", "; i <= count; i++) {\n                            ", "System", ".", "out.println(", "\"请输入第\"", " + i + ", "\"首歌曲：\"", ");\n                            ", "System", ".", "out.println(", "\"请输入歌曲的id：\"", ");\n                            String strId = sc.next", "()", ";\n                            ", "System", ".", "out.println(", "\"请输入歌曲的名称：\"", ");\n                            String strName = sc.next", "()", ";\n                            ", "System", ".", "out.println(", "\"请输入演唱者：\"", ");\n                            String strSinger = sc.next", "()", ";\n                            ", "// 创建歌曲类的对象", "\n                            Song song = ", "new", " ", "Song(", "strId", ", ", "strName", ", ", "strSinger", ")", ";\n                            mainPlayList.add", "ToPlayList(", "song", ")", ";\n", "//                            mainPlayList.displayAllSong();", "\n                        }\n                        break;\n                    case ", "2", ":\n                        ", "System", ".", "out.println(", "\"将歌曲添加到普通播放列表\"", ");\n                        ", "System", ".", "out.println(", "\"请输入要添加的播放列表名称：\"", ");\n                        String sName = sc.next", "()", ";\n                        ", "// 根据名称判断播放列表是否在播放器存在", "\n                        favouritePlayList = plc.search", "PlayListByName(", "sName", ")", ";\n                        ", "if", " (favouritePlayList", " == ", "null) {\n                            ", "System", ".", "out.println(", "\"该播放器列表不存在，请先将播放列表添加到播放器中！\"", ");\n                        } ", "else", " {\n                            ", "System", ".", "out.println(", "\"请输入要添加的歌曲的数量：\"", ");\n                            ", "int", " count1 = sc.next", "Int()", ";\n                            ", "for", " (", "int", " i = ", "1", "; i <= count1; i++) {\n                                ", "System", ".", "out.println(", "\"请输入第\"", " + i + ", "\"首歌曲：\"", ");\n                                ", "System", ".", "out.println(", "\"请输入歌曲id：\"", ");\n                                String strId = sc.next", "()", ";\n                                ", "// 判断该id的歌曲是都在主播放列表存在", "\n                                Song song = mainPlayList.search", "SongById(", "strId", ")", ";\n                                ", "if", " (song", " == ", "null) {\n                                    ", "// 如果歌曲不存在，则创建新的添加，并且添加到主播放列表", "\n                                    ", "System", ".", "out.println(", "\"该歌曲在主播放列表不存在，继续输入歌曲的其他信息！\"", ");\n                                    ", "System", ".", "out.println(", "\"请输入歌曲名称：\"", ");\n                                    String strName = sc.next", "()", ";\n                                    ", "System", ".", "out.println(", "\"请输入演唱者：\"", ");\n                                    String strSinger = sc.next", "()", ";\n                                    ", "// 创建一个Song类的对象", "\n                                    song = ", "new", " ", "Song(", "strId", ", ", "strName", ", ", "strSinger", ")", ";\n                                    ", "// 分别将歌曲添加到普通播放列表和主播放列表", "\n                                    favouritePlayList.add", "ToPlayList(", "song", ")", ";\n                                    mainPlayList.add", "ToPlayList(", "song", ")", ";\n                                } ", "else", " {\n                                    ", "// 如果歌曲存在于主播放列表，则直接添加到现在的播放列表", "\n                                    favouritePlayList.add", "ToPlayList(", "song", ")", ";\n                                }\n                            }\n                            ", "// 显示播放列表中的歌曲信息", "\n                            ", "System", ".", "out.println(", "\"主播放列表：\"", ");\n                            mainPlayList.display", "AllSong()", ";\n                            ", "System", ".", "out.println(", "\"普通播放列表：\"", ");\n                            favouritePlayList.display", "AllSong()", ";\n\n                        }\n                        break;\n                    case ", "3", ":\n                        ", "System", ".", "out.println(", "\"通过歌曲id查询播放列表中的歌曲\"", ");\n                        ", "System", ".", "out.println(", "\"请输入要查询的播放列表名称：\"", ");\n                        String strPlayListName1 = sc.next", "()", ";\n                        ", "// 查询播放列表是否存在", "\n                        PlayList pl = plc.search", "PlayListByName(", "strPlayListName1", ")", ";\n                        ", "if", " (pl", " == ", "null) {\n                            ", "System", ".", "out.println(", "\"该播放列表不存在！\"", ");\n                            break;\n                        } ", "else", " {\n                            ", "System", ".", "out.println(", "\"请输入要查询的歌曲id：\"", ");\n                            String strId1 = sc.next", "()", ";\n                            Song s = pl.search", "SongById(", "strId1", ")", ";\n                            ", "if", " (s", " == ", "null) {\n                                ", "System", ".", "out.println(", "\"该歌曲在播放列表\"", " + strPlayListName1 + ", "\"中不存在！\"", ");\n                            } ", "else", " {\n                                ", "System", ".", "out.println(", "\"该歌曲的信息为：\"", ");\n                                ", "System", ".", "out.println(s);\n                            }\n                        }\n                        break;\n                    case ", "4", ":\n                        ", "System", ".", "out.println(", "\"通过歌曲名称查询播放列表中的歌曲\"", ");\n                        break;\n                    case ", "5", ":\n                        ", "System", ".", "out.println(", "\"修改播放列表中的歌曲  \"", ");\n                        break;\n                    case ", "6", ":\n                        ", "System", ".", "out.println(", "\"删除播放列表中的歌曲  \"", ");\n                        break;\n                    case ", "7", ":\n                        ", "System", ".", "out.println(", "\"显示播放列表中的所有歌曲  \"", ");\n                        break;\n                    default:\n                        ", "System", ".", "out.println(", "\"该歌曲没有对应的操作！\"", ");\n                    }\n                }\n                break;\n            case ", "2", ":\n                ", "// 播放器管理", "\n                ", "while", " (", "true", ") {\n                    td.play", "Menu()", ";\n                    ", "System", ".", "out.println(", "\"请输入对应的数字对播放器进行管理：\"", ");\n                    input2 = sc.next", "Int()", ";\n                    ", "if", " (input2", " == ", "9", ")\n                        break;\n                    switch (input2) {\n                    case ", "1", ":\n                        ", "System", ".", "out.println(", "\"向播放器添加播放列表\"", ");\n                        ", "System", ".", "out.println(", "\"输入要添加的播放列表名称：\"", ");\n                        String playerName = sc.next", "()", ";\n                        ", "// 创建一个新的播放列表对象", "\n                        favouritePlayList = ", "new", " ", "PlayList(", "playerName", ")", ";\n                        ", "/*\n                         * 注：上面这段代码： //String playerName = sc.next();中的对象playerName和 new\n                         * PlayList(playerName)传入的对象不一致的话报： Exception in thread \"main\"\n                         * java.lang.NullPointerException 空指针异常的错误\n                         */", "\n\n                        ", "// 将播放器列表添加到播放器Map", "\n                        plc.add", "PlayList(", "favouritePlayList", ")", ";\n                        break;\n                    case ", "2", ":\n                        ", "System", ".", "out.println(", "\"从播放器删除播放列表\"", ");\n                        ", "System", ".", "out.println(", "\"请输入要删除的播放列表名称：\"", ");\n                        String strPlayListName=sc.next", "()", ";\n                        ", "//主播放列表的数据不能删除", "\n                        ", "if", "(strPlayListName.equals(", "\"主播放列表\"", ")) {\n                            ", "System", ".", "out.println(", "\"主播放列表不能删除！\"", ");\n                            break;\n                        }\n                        ", "//若不是主播放列表，则查询播放列表是否存在", "\n                        PlayList playList1=plc.search", "PlayListByName(", "strPlayListName", ")", ";\n                        ", "if", "(playList1==null) {\n                            ", "System", ".", "out.println(", "\"该播放列表不存在！\"", ");\n                        }", "else", " {\n                            ", "//若存在则删除", "\n                            plc.delete", "PlayList(", "playList1", ")", ";\n                        }\n                        break;\n                    case ", "3", ":\n                        ", "System", ".", "out.println(", "\"通过名字查询播放列表信息\"", ");\n                        ", "System", ".", "out.println(", "\"请输入要查询的播放列表名称：\"", ");\n                        String strPlayList1=sc.next", "()", ";\n                        ", "//查询播放列表的信息", "\n                        PlayList playList2=plc.search", "PlayListByName(", "strPlayList1", ")", ";\n                        ", "//判断playList2的值是否为空值", "\n                        ", "if", "(playList2==null) {\n                            ", "System", ".", "out.println(", "\"该播放列表不存在！\"", ");\n                        }", "else", " {\n                            ", "//显示该播放列表名称及其中所有歌曲", "\n                            ", "System", ".", "out.println(", "\"该播放列表存在！\"", ");\n                            ", "System", ".", "out.println(", "\"该播放列表的名称为：\"", "+strPlayList1);\n                            playList2.display", "AllSong()", ";\n                        }\n                        break;\n                    case ", "4", ":\n                        ", "System", ".", "out.println(", "\"显示所有播放列表名称\"", ");\n                        ", "System", ".", "out.println(", "\"所有播放列表的名称为：\"", ");\n                        plc.display", "ListName()", ";\n                        break;\n                    default:\n                        ", "System", ".", "out.println(", "\"该歌曲没有对应的操作！\"", ");\n                        break;\n                    }\n                }\n                break;\n            default:\n                ", "System", ".", "out.println(", "\"该数字没有对应的操作！\"", ");\n                break;\n            }\n        }\n    }\n\n    public static void main(String", "[]", " args) {\n        TestDemo td = ", "new", " ", "TestDemo()", ";\n        td.test", "()", ";\n", "//        td.testSong();", "\n", "//        td.testPlayList();", "\n", "//        td.testPlayListCollection();", "\n    }\n\n}\n"]], "Tag": "程序设计"}
{"Answer": "不知道你这个问题是否已经解决, 如果还没有解决的话: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;这篇博客: &lt;a href=\"https://blog.csdn.net/cough777/article/details/114989916?utm_source&amp;#61;csdn_ai_ada_ask_robot\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;RuntimeError: one of the variables needed for gradient computation has been modified by an inplace o&lt;/font&gt;&lt;/a&gt;中的 &lt;strong&gt;其他&lt;/strong&gt; 部分也许能够解决你的问题, 你可以仔细阅读以下内容或者直接跳转源博客中阅读: &lt;br /&gt;\n&lt;p&gt;查看出问题的地方&amp;#xff0c;会提示&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"prism language-python\"&gt; Hint&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt; enable anomaly detection to find the operation that failed to compute its gradient&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; &lt;span class=\"token keyword\"&gt;with&lt;/span&gt; torch&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;autograd&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;set_detect_anomaly&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token boolean\"&gt;True&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个用于定位挺好用的&amp;#xff0c;但对于复杂的计算图&amp;#xff0c;可能这个的放置位置我还没有细致的研究过。使用方法见下面的操作实例&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"prism language-python\"&gt;&lt;span class=\"token keyword\"&gt;import&lt;/span&gt; torch\n\n&lt;span class=\"token keyword\"&gt;with&lt;/span&gt; torch&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;autograd&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;set_detect_anomaly&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token boolean\"&gt;True&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt; &lt;span class=\"token comment\"&gt;#就是这句话&lt;/span&gt;\n    a &lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt; torch&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;rand&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token number\"&gt;1&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; requires_grad&lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"token boolean\"&gt;True&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n    c &lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt; torch&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;rand&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token number\"&gt;1&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; requires_grad&lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"token boolean\"&gt;True&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n    \n    b &lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt; a &lt;span class=\"token operator\"&gt;**&lt;/span&gt; &lt;span class=\"token number\"&gt;2&lt;/span&gt; &lt;span class=\"token operator\"&gt;*&lt;/span&gt; c &lt;span class=\"token operator\"&gt;**&lt;/span&gt; &lt;span class=\"token number\"&gt;2&lt;/span&gt;\n    b &lt;span class=\"token operator\"&gt;&amp;#43;&amp;#61;&lt;/span&gt; &lt;span class=\"token number\"&gt;1&lt;/span&gt;\n    b &lt;span class=\"token operator\"&gt;*&amp;#61;&lt;/span&gt; c &lt;span class=\"token operator\"&gt;&amp;#43;&lt;/span&gt; a\n\n    d &lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt; b&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;exp_&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n    d &lt;span class=\"token operator\"&gt;*&amp;#61;&lt;/span&gt; &lt;span class=\"token number\"&gt;5&lt;/span&gt;\n\n    b&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;backward&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"prism language-python\"&gt;sys&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt;&lt;span class=\"token number\"&gt;1&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt; RuntimeWarning&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt; Traceback of forward call that caused the error&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt;\n  File &lt;span class=\"token string\"&gt;&amp;#34;tst.py&amp;#34;&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; line &lt;span class=\"token number\"&gt;13&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; &lt;span class=\"token keyword\"&gt;in&lt;/span&gt; &lt;span class=\"token operator\"&gt;&amp;lt;&lt;/span&gt;module&lt;span class=\"token operator\"&gt;&amp;gt;&lt;/span&gt;\n    d &lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt; b&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;exp_&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n\nTraceback &lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;most recent call last&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt;\n  File &lt;span class=\"token string\"&gt;&amp;#34;tst.py&amp;#34;&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; line &lt;span class=\"token number\"&gt;16&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; &lt;span class=\"token keyword\"&gt;in&lt;/span&gt; &lt;span class=\"token operator\"&gt;&amp;lt;&lt;/span&gt;module&lt;span class=\"token operator\"&gt;&amp;gt;&lt;/span&gt;\n    b&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;backward&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n  File &lt;span class=\"token string\"&gt;&amp;#34;/Users/fmassa/anaconda3/lib/python3.6/site-packages/torch/tensor.py&amp;#34;&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; line &lt;span class=\"token number\"&gt;102&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; &lt;span class=\"token keyword\"&gt;in&lt;/span&gt; backward\n    torch&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;autograd&lt;span class=\"token punctuation\"&gt;.&lt;/span&gt;backward&lt;span class=\"token punctuation\"&gt;(&lt;/span&gt;self&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; gradient&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; retain_graph&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; create_graph&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;\n  File &lt;span class=\"token string\"&gt;&amp;#34;/Users/fmassa/anaconda3/lib/python3.6/site-packages/torch/autograd/__init__.py&amp;#34;&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; line &lt;span class=\"token number\"&gt;93&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;,&lt;/span&gt; &lt;span class=\"token keyword\"&gt;in&lt;/span&gt; backward\n    allow_unreachable&lt;span class=\"token operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"token boolean\"&gt;True&lt;/span&gt;&lt;span class=\"token punctuation\"&gt;)&lt;/span&gt;  &lt;span class=\"token comment\"&gt;# allow_unreachable flag&lt;/span&gt;\nRuntimeError&lt;span class=\"token punctuation\"&gt;:&lt;/span&gt; one of the variables needed &lt;span class=\"token keyword\"&gt;for&lt;/span&gt; gradient computation has been modified by an inplace operation\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从这里可以看出是 &lt;em&gt;d &amp;#61; b.exp_()&lt;/em&gt; 出了问题&amp;#xff0c;修改为&lt;em&gt;d &amp;#61; b.exp()&lt;/em&gt;&amp;#xff0c;即可解决&lt;/p&gt;\n&lt;p&gt;详情见&lt;/p&gt;&lt;a href=\"https://github.com/pytorch/pytorch/issues/15803\"&gt;文献五&lt;/a&gt;\n&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;如果你已经解决了该问题, 非常希望你能够分享一下解决方案, 写成博客, 将相关链接放在评论区, 以帮助更多的人 ^-^", "Konwledge_Point": "定义新的类型", "Question": ["loss.backward()反向传播问题", ["batch_data", " = batches[t]\n        ", "# 获取批量数据的预测结果", "\n        ", "_", ",pred_traj,y_traj,pred_intent,_,_ = get_prediction_on_batch(batch_data, model, device)\n\n        ", "# None的作用主要是在使用None的位置新增一个维度", "\n        ", "traj_preds", ".append(pred_traj[", "0", "].detach()[None])\n        ", "# 当我们再训练网络的时候可能希望保持一部分的网络参数不变，只对其中一部分的参数进行调整；", "\n        ", "# 或者只训练部分分支网络，并不让其梯度对主网络的梯度造成影响，这时候我们就需要使用detach()函数来切断一些分支的反向传播", "\n        ", "# 返回一个新的tensor，从当前计算图中分离下来的，但是仍指向原变量的存放位置, 不同之处只是requires_grad为false，得到的这个tensor永远不需要计算其梯度，不具有grad。", "\n        ", "# 即使之后重新将它的requires_grad置为true,它也不会具有梯度grad", "\n        ", "# 这样我们就会继续使用这个新的tensor进行计算，后面当我们进行反向传播时，到该调用detach()的tensor就会停止，不能再继续向前进行传播", "\n        ", "# 使用detach返回的tensor和原始的tensor共同一个内存，即一个修改另一个也会跟着改变。", "\n        ", "intent_preds", ".append(pred_intent[", "0", "].detach()[None])\n\n        ", "temp_pred_list", " +=", " [pred_traj]", "\n        ", "temp_label_list", " +=", " [y_traj]", "\n        ", "temp_data_list", " +=", " [batch_data]", "\n        ", "if", " len(temp_pred_list) > adapt_step:\n            ", "# maintains a buffer of length adapt_step containing the past adapt_step measurements for supervised adaptation", "\n            ", "temp_pred_list", " = temp_pred_list[", "1", ":]\n            ", "temp_label_list", " = temp_label_list[", "1", ":]\n            ", "temp_data_list", " = temp_data_list[", "1", ":]\n\n        ", "if", " t < adapt_step - ", "1", ":\n            ", "continue", "\n        ", "# temp_label_list1 = temp_label_list[0].detach()", "\n        ", "# temp_pred_list1 = temp_pred_list[0].detach()", "\n        ", "Y", " = temp_label_list[", "0", "]\n        ", "Y_hat", " = temp_pred_list[", "0", "]\n        ", "# detach()将数据的处理设备从其他设备（如.cuda()拿到cpu上），不会改变变量类型，转换后仍然是Tensor变量。", "\n        ", "full_loss", " = (Y - Y_hat).detach().pow(", "2", ").mean().cpu().numpy().round(", "6", ")  # 整体的损失值\n        ", "cost_list", ".append(full_loss)\n        ", "# torch.contiguous()方法首先拷贝了一份张量在内存中的地址，然后将地址按照形状改变后的张量的语义进行排列。", "\n        ", "# 如果想要断开这两个变量之间的依赖（x本身是contiguous的），就要使用contiguous()针对x进行变化，感觉上就是我们认为的深拷贝。", "\n        ", "#  当调用contiguous()时，会强制拷贝一份tensor，让它的布局和从头创建的一模一样，但是两个tensor完全没有联系。", "\n        ", "Y_tau", " = Y[:, :adapt_step].contiguous().view((-", "1", ", ", "1", "))\n        ", "# touch.view()方法对张量改变“形状”其实并没有改变张量在内存中真正的形状，可以理解为：", "\n        ", "# view方法没有拷贝新的张量，没有开辟新内存，与原张量共享内存；", "\n        ", "# view方法只是重新定义了访问张量的规则，使得取出的张量按照我们希望的形状展现。", "\n        ", "Y_hat_tau", " = Y_hat[:, :adapt_step].contiguous().view((-", "1", ", ", "1", "))  # 部分数据的损失值\n        ", "err", " = (Y_tau - Y_hat_tau).detach()\n        ", "curr_cost", " = err.pow(", "2", ").mean().cpu().numpy()\n        ", "update_epoch", " = ", "1", "\n\n        ", "# IPython.embed()", "\n        ", "# κt = 1, If jt < ξ1", "\n        ", "#      2, If ξ1 ≤ jt < ξ2", "\n        ", "#      0, If jt ≥ ξ2", "\n        ", "if", " multiepoch_thresh[", "0", "] <= ", "0", " <= multiepoch_thresh[", "1", "]:\n            ", "if", " curr_cost < multiepoch_thresh[", "0", "]:\n                ", "update_epoch", " = ", "1", "\n            ", "elif", " curr_cost < multiepoch_thresh[", "1", "]:\n                ", "update_epoch", " = ", "2", "\n            ", "else", ":\n                ", "update_epoch", " = ", "0", "\n        ", "cnt", "[update_epoch] += ", "1", "\n        ", "for", " cycle in range(update_epoch):\n            ", "def", " mekf_closure(index=", "0", "):\n                ", "# mekf闭包 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。", "\n                ", "# optimizer.zero_grad()清除了优化器中所有的x的x.grad，", "\n                ", "# 在每次loss.backward()之前，不要忘记使用，否则之前的梯度将会累积，这通常不是我们所期望的", "\n                ", "optimizer", ".zero_grad()\n                ", "# optimizer.state 参数的缓存,需要用到什么参数就缓存到这个地方", "\n                ", "dim_out", " = optimizer.optimizer.state['dim_out'] if 'Lookahead' in optim_name else optimizer.state['dim_out']\n                ", "retain", " = index < dim_out - ", "1", "\n                ", "Y_hat_tau", "[index].backward(retain_graph=retain)  # 反向传播\n                ", "return", " err\n\n            ", "def", " lbfgs_closure():\n                ", "optimizer", ".zero_grad()\n                ", "temp_data", " = temp_data_list[", "0", "]\n                ", "_", ", temp_pred_traj, temp_y_traj, _, _, _ = get_prediction_on_batch(temp_data, model, device)\n                ", "y_tau", " = temp_y_traj[:, :adapt_step].contiguous().view((-", "1", ", ", "1", "))\n                ", "y_hat_tau", " = temp_pred_traj[:, :adapt_step].contiguous().view((-", "1", ", ", "1", "))\n                ", "loss", " = (y_tau - y_hat_tau).pow(", "2", ").mean()\n                ", "loss", ".backward()\n                ", "return", " loss\n\n            ", "if", " 'MEKF' in optim_name:\n                ", "# step()函数的作用是执行一次优化步骤，通过梯度下降法来更新参数的值。", "\n                ", "# 因为梯度下降是基于梯度的，所以在执行optimizer.step()函数前应先执行loss.backward()函数来计算梯度", "\n                ", "optimizer", ".step(mekf_closure)  # 将函数作为参数传入\n            ", "elif", " 'LBFGS' in optim_name:\n                ", "optimizer", ".step(lbfgs_closure)\n            ", "else", ":\n                ", "torch", ".autograd.set_detect_anomaly(True)\n                ", "loss", " = (Y_tau - Y_hat_tau).pow(", "2", ").mean()\n                ", "loss", ".backward()\n                ", "optimizer", ".step()\n", "\n", "在运行else部分代码时，出现以下错误：", "RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.FloatTensor [64, 100]], which is output 0 of AsStridedBackward0, is at version 2; expected version 1 instead.", "网上找了很多方法都无法解决，希望各位能给予解决办法，谢谢"]], "Tag": "程序设计"}
