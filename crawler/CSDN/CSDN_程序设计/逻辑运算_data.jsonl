{"Answer": "0x00 是一个数字0\r\n而!0x00一个布尔值，即非0表示true\r\n你如果把一个布尔值true转换成数字就是1\r\n使用十六机制表示就是0x01", "Konwledge_Point": "逻辑运算", "Question": ["C语言中的逻辑运算，十六进制需要先转二进制再逻辑运算吗", ["C语言中的逻辑运算（！0x00＝0x01），为什么啊？求详细解释（！非，非零表示1／零表示零），结果不应该是0x00吗？在线等，挺急的。。。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一题&amp;#xff1a;&lt;br /&gt;x &amp;#61; y-- &amp;lt;&amp;#61;x || x&amp;#61;y!&amp;#61;z;&lt;br /&gt;其实这个等式是一个错误的等式&amp;#xff0c;因为等号的优先级最低&amp;#xff0c;所以x&amp;#61;y!&amp;#61;z这里x后面的等号会报错。&lt;br /&gt;所以这里只能猜测出题者的意图&amp;#xff0c;按照这个思路&amp;#xff0c;公式可以分解为&amp;#xff1a;&lt;br /&gt;&amp;#xff08;1&amp;#xff09;y &amp;lt;&amp;#61;x (y&amp;#61;2,x&amp;#61;1,所以y&amp;lt;&amp;#61;x的结果是0&amp;#xff09;&lt;br /&gt;&amp;#xff08;2&amp;#xff09;x&amp;#61;y!&amp;#61;z这个先计算 y!&amp;#61;z&amp;#xff0c;结果是1&amp;#xff0c;所以x&amp;#61;1&lt;br /&gt;&amp;#xff08;3&amp;#xff09;x &amp;#61; 0 || 1 &amp;#xff08;0是步骤1的结果&amp;#xff0c;1是步骤2的结果&amp;#xff09;&amp;#xff0c;x &amp;#61; 1&lt;br /&gt;&amp;#xff08;4&amp;#xff09;y-- &amp;#xff08;y--最后计算&amp;#xff09;&amp;#xff0c;y &amp;#61; 1&lt;br /&gt;所以显示的结果就是&amp;#xff1a;1,1&lt;br /&gt;第二题&amp;#xff1a;&lt;br /&gt;x &amp;#61; x || y &amp;amp;&amp;amp; z;  先计算x || y &amp;#xff0c;x和y都非0&amp;#xff0c;所以x || y 的结果是1&amp;#xff0c;然后计算1 &amp;amp;&amp;amp; z &amp;#xff0c;z&amp;#61;0&amp;#xff0c;所以结果就是0&amp;#xff0c;所以x &amp;#61; 0;&lt;br /&gt;printf中x &amp;amp;&amp;amp; !y || z &amp;#xff0c;先计算 x &amp;amp;&amp;amp; !y &amp;#xff0c;x&amp;#61;0&amp;#xff0c;所以结果是0&amp;#xff0c;然后计算 0 || z&amp;#xff0c;z&amp;#61;0&amp;#xff0c;所以结果仍然是0&amp;#xff0c;&lt;br /&gt;所以最后的结果是&amp;#xff1a;0,0&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言  关系运算符、逻辑运算符与表达式的程序阅读题", ["求解释printf上面的语句，不知道从哪里开始看，", "第一题知道或前面为假，但是或后面不知道怎么看。", "第二题，！怎么看。求解释。", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为  &amp;amp;&amp;amp;是与运算&amp;#xff0c;在a&amp;#43;&amp;#43;&amp;amp;&amp;amp;b&amp;#43;&amp;#43;中&amp;#xff0c;只要a的结果为假&amp;#xff0c;也就是等于0的时候&amp;#xff0c;那就不会继续b的运算。所以第11行中&amp;#xff0c;表达式x变成0了&amp;#xff0c;那后面y和z就不会参与运算&amp;#xff0c;结果不会发生改变&amp;#xff0c;所以就是0  1  1。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于逻辑运算表达式的问题", ["有会的吗？第11行怎么看，怎么出来就是0 1 1 了呢？根据优先级进行运算，是0 2 2，&&只有两个符号，怎样运算能出来三个结果。"]], "Tag": "程序设计"}
{"Answer": "同楼上。楼主原本的\"!(A1 &amp;&amp; B1) &amp;&amp; !(A2 &amp;&amp; B2) &amp;&amp; !(A3 &amp;&amp; B3)\"其实没问题。\r\n\r\n不敢相信自己的计算就试试看相信自己的眼睛吧，呵呵。执行这段C#代码：\r\nusing System;\r\nusing System.Linq;\r\n\r\nstatic class Program {\r\n  static void Main(string[] args) {\r\n    var booleanValues = new [] { true, false };\r\n    var equal = !(from a1 in booleanValues\r\n                  from a2 in booleanValues\r\n                  from a3 in booleanValues\r\n                  from b1 in booleanValues\r\n                  from b2 in booleanValues\r\n                  from b3 in booleanValues\r\n                  select !((a1 &amp;&amp; b1) || (a2 &amp;&amp; b2) || (a3 &amp;&amp; b3)) ==\r\n                        (!(a1 &amp;&amp; b1) &amp;&amp; !(a2 &amp;&amp; b2) &amp;&amp; !(a3 &amp;&amp; b3)))\r\n                  .Contains(false);\r\n    Console.WriteLine(equal); // true\r\n  }\r\n}\r\n会验证6个变量组成的表达式是否总是同真假。我这边执行结果是true。我相信我的眼睛 ^ ^\r\n\r\n要让它输出真值表也行：\r\nusing System;\r\nusing System.Linq;\r\n\r\nstatic class Program {\r\n  static void Main(string[] args) {\r\n    var booleanValues = new [] { true, false };\r\n    var result =  from a1 in booleanValues\r\n                  from a2 in booleanValues\r\n                  from a3 in booleanValues\r\n                  from b1 in booleanValues\r\n                  from b2 in booleanValues\r\n                  from b3 in booleanValues\r\n                  select string.Format(\r\n                    \"!(({0} &amp;&amp; {3}) || ({1} &amp;&amp; {4}) || ({2} &amp;&amp; {5}))) == {6}\",\r\n                    a1, a2, a3, b1, b2, b3,\r\n                    !((a1 &amp;&amp; b1) || (a2 &amp;&amp; b2) || (a3 &amp;&amp; b3)));\r\n    foreach (var s in result) {\r\n      Console.WriteLine(s);\r\n    }\r\n  }\r\n}\r\n[quote]!((True &amp;&amp; True) || (True &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (True &amp;&amp; True) || (True &amp;&amp; False))) == False\r\n!((True &amp;&amp; True) || (True &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (True &amp;&amp; False) || (True &amp;&amp; False))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; True) || (True &amp;&amp; False))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; False) || (True &amp;&amp; False))) == True\r\n!((True &amp;&amp; True) || (True &amp;&amp; True) || (False &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (True &amp;&amp; True) || (False &amp;&amp; False))) == False\r\n!((True &amp;&amp; True) || (True &amp;&amp; False) || (False &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (True &amp;&amp; False) || (False &amp;&amp; False))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; True) || (False &amp;&amp; True))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; True) || (False &amp;&amp; False))) == False\r\n!((True &amp;&amp; False) || (True &amp;&amp; False) || (False &amp;&amp; True))) == True\r\n!((True &amp;&amp; False) || (True &amp;&amp; False) || (False &amp;&amp; False))) == True\r\n!((True &amp;&amp; True) || (False &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (False &amp;&amp; True) || (True &amp;&amp; False))) == False\r\n!((True &amp;&amp; True) || (False &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (False &amp;&amp; False) || (True &amp;&amp; False))) == False\r\n!((True &amp;&amp; False) || (False &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; False) || (False &amp;&amp; True) || (True &amp;&amp; False))) == True\r\n!((True &amp;&amp; False) || (False &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((True &amp;&amp; False) || (False &amp;&amp; False) || (True &amp;&amp; False))) == True\r\n!((True &amp;&amp; True) || (False &amp;&amp; True) || (False &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (False &amp;&amp; True) || (False &amp;&amp; False))) == False\r\n!((True &amp;&amp; True) || (False &amp;&amp; False) || (False &amp;&amp; True))) == False\r\n!((True &amp;&amp; True) || (False &amp;&amp; False) || (False &amp;&amp; False))) == False\r\n!((True &amp;&amp; False) || (False &amp;&amp; True) || (False &amp;&amp; True))) == True\r\n!((True &amp;&amp; False) || (False &amp;&amp; True) || (False &amp;&amp; False))) == True\r\n!((True &amp;&amp; False) || (False &amp;&amp; False) || (False &amp;&amp; True))) == True\r\n!((True &amp;&amp; False) || (False &amp;&amp; False) || (False &amp;&amp; False))) == True\r\n!((False &amp;&amp; True) || (True &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; True) || (True &amp;&amp; True) || (True &amp;&amp; False))) == False\r\n!((False &amp;&amp; True) || (True &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; True) || (True &amp;&amp; False) || (True &amp;&amp; False))) == True\r\n!((False &amp;&amp; False) || (True &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; False) || (True &amp;&amp; True) || (True &amp;&amp; False))) == False\r\n!((False &amp;&amp; False) || (True &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; False) || (True &amp;&amp; False) || (True &amp;&amp; False))) == True\r\n!((False &amp;&amp; True) || (True &amp;&amp; True) || (False &amp;&amp; True))) == False\r\n!((False &amp;&amp; True) || (True &amp;&amp; True) || (False &amp;&amp; False))) == False\r\n!((False &amp;&amp; True) || (True &amp;&amp; False) || (False &amp;&amp; True))) == True\r\n!((False &amp;&amp; True) || (True &amp;&amp; False) || (False &amp;&amp; False))) == True\r\n!((False &amp;&amp; False) || (True &amp;&amp; True) || (False &amp;&amp; True))) == False\r\n!((False &amp;&amp; False) || (True &amp;&amp; True) || (False &amp;&amp; False))) == False\r\n!((False &amp;&amp; False) || (True &amp;&amp; False) || (False &amp;&amp; True))) == True\r\n!((False &amp;&amp; False) || (True &amp;&amp; False) || (False &amp;&amp; False))) == True\r\n!((False &amp;&amp; True) || (False &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; True) || (False &amp;&amp; True) || (True &amp;&amp; False))) == True\r\n!((False &amp;&amp; True) || (False &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; True) || (False &amp;&amp; False) || (True &amp;&amp; False))) == True\r\n!((False &amp;&amp; False) || (False &amp;&amp; True) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; False) || (False &amp;&amp; True) || (True &amp;&amp; False))) == True\r\n!((False &amp;&amp; False) || (False &amp;&amp; False) || (True &amp;&amp; True))) == False\r\n!((False &amp;&amp; False) || (False &amp;&amp; False) || (True &amp;&amp; False))) == True\r\n!((False &amp;&amp; True) || (False &amp;&amp; True) || (False &amp;&amp; True))) == True\r\n!((False &amp;&amp; True) || (False &amp;&amp; True) || (False &amp;&amp; False))) == True\r\n!((False &amp;&amp; True) || (False &amp;&amp; False) || (False &amp;&amp; True))) == True\r\n!((False &amp;&amp; True) || (False &amp;&amp; False) || (False &amp;&amp; False))) == True\r\n!((False &amp;&amp; False) || (False &amp;&amp; True) || (False &amp;&amp; True))) == True\r\n!((False &amp;&amp; False) || (False &amp;&amp; True) || (False &amp;&amp; False))) == True\r\n!((False &amp;&amp; False) || (False &amp;&amp; False) || (False &amp;&amp; True))) == True\r\n!((False &amp;&amp; False) || (False &amp;&amp; False) || (False &amp;&amp; False))) == True[/quote]", "Konwledge_Point": "逻辑运算", "Question": ["求一个逻辑运算结果", ["如下所示, 用A,B,C这些子条件来表达结果isPass是这样的, ", "\nboolean  isPass = (A1 && B1) || (A2 && B2) || (A3 && B3);", "\n\n", "那么用设boolean isNotPass = ! isPass;", "\n\n", "怎么用那些A,B,C子条件来表达isNotPass呢? ", "\n\n", "\"!(A1 && B1) && !(A2 && B2) && !(A3 && B3)\"好像不对. "]], "Tag": "程序设计"}
{"Answer": "看你对性能是否有要求以及逻辑的复杂度,如果性能要求不高,逻辑复杂度比较低,写sql也可以", "Konwledge_Point": "逻辑运算", "Question": ["在SQL语句里写逻辑好么？", ["最近开发中发现SQL语句中基本可以实现自己想要的绝大多数的逻辑运算，但是我对SQL的机制不是很了解，所以我不清楚是不是应该把大量的逻辑运算放在SQL里，还是和以前一样还是把逻辑放在代码层比较好呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果 greaterThan 为 true&amp;#xff0c;则检查学生的平均分数是否大于阈值。如果 greaterThan 为 false&amp;#xff0c;则检查学生的平均分数是否小于阈值。如果这两个条件中有一个为 true&amp;#xff0c;则返回 true&amp;#xff0c;否则返回 false。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["解释逻辑运算式和关系运算式", ["\nif ((", "greaterThan", " ", "&&", " studentRecords[i].averageScore > threshold) || (!greaterThan ", "&&", " studentRecords[i].averageScore < threshold))\n", "\n", "可以给我说明一下这个逻辑吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;!sorted的含义为对sorted取反,相当于 if not sorted,即只有取反内容不成立时才为真&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于逻辑运算符和判断语句的疑惑", ["我不是很理解逻辑运算符放在判断语句框中判断语句的标准。", "就比如", "bool sorted=false;", "while(!sorted){", "statement", "}", "问题：括号中的（！sorted）为真时的条件是什么，为什么？", "我的理解：！sorted的意思是非sroted籍非false，只要sorted不是false，“（！false）”就成立，但是事实好像是相反的。（！sorted）成立的条件是 sorted=false。", "所以问一下各位，逻辑运算符与判断语句怎么理解。。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;中缀表达式的后缀表达式是唯一的&amp;#xff0c;3&amp;#43;4*5*(2&amp;#43;3)的后缀表达式应该是&amp;#xff1a;3&amp;#xff0c;4&amp;#xff0c;5&amp;#xff0c;*&amp;#xff0c;2&amp;#xff0c;3&amp;#xff0c;&amp;#43;&amp;#xff0c;*&amp;#xff0c;&amp;#43;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["中缀表达式转后缀表达式结果唯一吗？", ["如3+4*5*(2+3)这个中缀表达式；", "\n\n", "怎么345*23+*+和34523+**+"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/124413024636112.JPG\" /&gt;&lt;/p&gt;&lt;br /&gt;画了个图&amp;#xff0c;其实很多集合的定律画一下图都好理解。另外楼主是不是发错区了。这怎么能发到数据分析和人工智能区的。。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["离散数学中吸收律的推导过程", ["求离散数学吸收律的推导过程"]], "Tag": "程序设计"}
{"Answer": "&amp;&amp;和||是逻辑运算符，&amp;和|才是位运算符。\r\n逻辑运算符的返回值并不是true或false，逻辑运算符的工作原理是：\r\n\r\n表达式A &amp;&amp; 表达式B ：如果A的值为false(或A的值可以被当做为false)就返回A的值并且不执行表达式B，否则执行表达式B并且返回B的值\r\n表达式A || 表达式B ：如果A的值为true (或A的值可以被当做为true) 就返回A的值并且不执行表达式B，否则执行表达式B并且返回B的值\r\n在javascript中0 \"\" null undefined会被当做为false，其它的值都可以被当做为true。\r\n\r\n所以 5&amp;&amp;4 中5可以被当做为true，就返回&amp;&amp;右边的4", "Konwledge_Point": "逻辑运算", "Question": ["问一下js中为什么5&&4 = 4 5&&4&&5=5", ["5&&4  = 4", "\n那 5&&4&&5  = 5 ", "\n这不是位运算把？ 是两个数不同与运算等于后面的那个数？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;两个等号表示比较是否相等&amp;#xff0c;一个等号只是赋值&amp;#xff0c;判断a是否等于b的时候就是 if(a&amp;#61;&amp;#61;b)&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["这个逻辑运算＆＆的等于号必须是两个吗？", ["这个逻辑运算＆＆的等于号必须是两个吗？为什么是两个呢？这个有具体的格式吗？谢谢回答！"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; a,b,c;\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;c);\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,a&amp;gt;b &amp;amp;&amp;amp; a&amp;lt;&amp;#61;b);\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,!a || a&amp;lt;b);\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,!a || a&amp;gt;b &amp;amp;&amp;amp; c%a);\n    &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,a&amp;#61;&amp;#61;b || (b&amp;#61;a));\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言编程计算以下逻辑表达式的结果", ["1、提示用户输入3个数", "\n", "2、扫描用户输入，分别赋值给变量a、b、c", "\n", "3、计算以下逻辑表达式的结果并打印出来", "\n", "（1）a>b&&a<=b", "\n", "（2）a==b||(b=a)", "\n", "（3）!a||a>b", "\n", "（4）!a||a>b&&c%a"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-variable\"&gt;age&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入年龄&amp;#xff1a;&amp;#34;&lt;/span&gt;))&lt;/span&gt;\n&lt;span class=\"hljs-variable\"&gt;height&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入身高&amp;#xff1a;&amp;#34;&lt;/span&gt;))&lt;/span&gt;\n\n&lt;span class=\"hljs-variable\"&gt;&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;age&lt;/span&gt;&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;18&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;&lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt;&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;age&lt;/span&gt;&amp;lt;&amp;#61;&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;&lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt;&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;height&lt;/span&gt; &amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;170&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;&lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt;&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;height&lt;/span&gt; &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;185&lt;/span&gt; :\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;恭喜&amp;#xff0c;你符合报考飞行员的条件&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=\"hljs-variable\"&gt;&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;/span&gt;:\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;抱歉&amp;#xff0c;你不符合报考飞行员的条件&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;逻辑运算符&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;th&gt;基本格式&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;and&lt;/td&gt;&lt;td&gt;逻辑与运算&amp;#xff0c;等价于数学中的“且”&lt;/td&gt;&lt;td&gt;a and b&lt;/td&gt;&lt;td&gt;当 a 和 b 两个表达式都为真时&amp;#xff0c;a and b 的结果才为真&amp;#xff0c;否则为假。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;or&lt;/td&gt;&lt;td&gt;逻辑或运算&amp;#xff0c;等价于数学中的“或”&lt;/td&gt;&lt;td&gt;a or b&lt;/td&gt;&lt;td&gt;当 a 和 b 两个表达式都为假时&amp;#xff0c;a or b 的结果才是假&amp;#xff0c;否则为真。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;not&lt;/td&gt;&lt;td&gt;逻辑非运算&amp;#xff0c;等价于数学中的“非”&lt;/td&gt;&lt;td&gt;not a&lt;/td&gt;&lt;td&gt;如果 a 为真&amp;#xff0c;那么 not a 的结果为假&amp;#xff1b;如果 a 为假&amp;#xff0c;那么 not a 的结果为真。相当于对 a 取反。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;", "Konwledge_Point": "逻辑运算", "Question": ["求python逻辑运算的说明", ["刚开始接触编程。不懂python里面的逻辑运算。有没有大佬讲一下。顺便用代码实例一下"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n知识小课堂&amp;#xff1a;\n①&lt;span class=\"hljs-meta\"&gt;&amp;amp;&amp;amp;运算符&amp;#xff1a;逻辑与&amp;#xff0c;两边都成立返回1&amp;#xff0c;否则返回0&lt;/span&gt;\n②&lt;span class=\"hljs-string\"&gt;||运算符&amp;#xff1a;逻辑或&amp;#xff0c;只要任意一个成立就成立&amp;#xff0c;并返回1&amp;#xff0c;也就是真&amp;#xff0c;都不满足才是返回0&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言中的逻辑运算问题", ["有能不能解释一下（图1，2关于逻辑运算的没有搞懂😭", "\n", "；另外图3的3（5）感觉有疑问，为什么！", "（a+b）+c-1是真呢？", "本人心手，asking for answer."]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;\n\nusing namespace std;\n\nint a[1000000];\n\nint n;\nint q;\n\nint main() \n{\n    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;q;\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n    {\n        cin&amp;gt;&amp;gt;a[i];\n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int &lt;span class=\"hljs-attribute\"&gt;i&lt;/span&gt;&amp;#61;1;i&amp;lt;&amp;#61;q;i&amp;#43;&amp;#43;)\n    {\n        int s,x,y;\n        \n        cin&amp;gt;&amp;gt;s;\n        \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-attribute\"&gt;s&lt;/span&gt;&amp;#61;&amp;#61;1)\n        {\n            cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;\n            \n            int &lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;a[x]&amp;amp;a[y];\n            \n            cout&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;\n        }\n        \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-attribute\"&gt;s&lt;/span&gt;&amp;#61;&amp;#61;2)\n        {\n            cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;\n            \n            int &lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;a[x]|a[y];\n            \n            cout&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;\n        }\n        \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-attribute\"&gt;s&lt;/span&gt;&amp;#61;&amp;#61;3)\n        {\n            cin&amp;gt;&amp;gt;x;\n            \n            int &lt;span class=\"hljs-attribute\"&gt;k&lt;/span&gt;&amp;#61;!a[x];\n            \n            cout&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;\n        }\n    }\n    \n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;百合花数是真的不会了QAQ&lt;br /&gt;打了1个多小时的表只输出了1个12位数&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑运算问题遇到的现象", ["问题遇到的现象和发生背景", "\n", "逻辑运算", "\n\n", "运行结果及报错内容", "\n", "题目描述", "有 nn 个逻辑值 a_ia", "i", "​", "  和 mm 个询问，询问格式为：", "\n", "1 x y：询问 a_xa", "x", "​", "  和 a_ya", "y", "​", "  做与运算的结果；", "2 x y：询问 a_xa", "x", "​", "  和 a_ya", "y", "​", "  做或运算的结果；", "3 x：询问 a_xa", "x", "​", "  做非运算的结果。", "输入格式", "从标准输入读入数据。 第一行输入两个正整数 nn（n\\le1000n≤1000）和 mm（m\\le1000m≤1000）。 第二行输入 nn 个整数 a_ia", "i", "​", " （a_i=0a", "i", "​", " =0 或 a_i=1a", "i", "​", " =1）。 接下来 mm 行，每行输入一个询问，询问格式为题目所述三种之一。", "\n", "输出格式", "输出到标准输出。 输出一行 mm 个整数 00 或 11，按顺序对应每个询问的结果。", "\n", "输入输出样例", "输入 #1复制", "5 5", "1 0 0 1 0", "1 1 4", "1 1 3", "2 2 3", "2 5 4", "3 2", "输出 #1复制", "1 0 0 1 1 ", "\n\n", "我想要达到的结果", "\n", "成功"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;赋值表达式的返回值为赋值结果。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": [" C语言逻辑运算符的短路求值详细解说", ["原文地址", "\n\n", " C语言逻辑运算符的短路求值详细解说", "\n\n", "在C语言中对于逻辑与(&&)和逻辑或(||)采用短路求值(也叫最小化求值)的方式。", "\n\n", "\n", "逻辑与(&&)的短路求值", "\n\n", "先来看一段代码：", "\n\n", "\n", "#include<stdio.h>\nint main(void)\n{\n    int a=3,b=5;\n    (a=0)&&(b=4);\n    printf(\"a=%d,b=%d\\n\",a,b);\n    return 0;\n}", "\n\n", "上面这段代码写的什么呢？ ", "\n\n", "首先定义了两个整型变量，a=3,b=5对吧。", "\n\n", "然后在逻辑与(&&)运算符的两个表达式中：第一个表达式是把a赋值成0，第二个表达式是把b赋值成4。", "\n\n", "最后再输出a和b的值。", "\n\n", "那么最后输出的是否会是：a=0,b=4呢？运行结果如下：", "\n\n", "\n", "逻辑与运算符的短路求值", "\n", "\n\n", "为什么a成功赋值成了0，而b还是5没有变呢?", "\n\n", "我们来认真想想，首先逻辑的意思就是判断真假是吧。", "\n\n", "再想计算机是怎么判断真假的呢？", "\n\n", "其实计算机判断一个数的真假是非0为真，就0是假，判断一个表达式也一样比如：(1-1)是假，(1>2)是假，等等。", "\n\n", "最后我们知道了这里a被赋值成0，为假了，那为什么后面不被执行了呢？", "\n\n", "因为在逻辑与(&&)运算符中采用短路求值的方法：逻辑与(&&)运算符的结合性是从左往右计算的，所以从最前面的表达式开始看。如果前面表达式为真(边执行边判断)，才继续看后面的表达式，以此类推，如果前面有一个表达式为假了(边执行边判断)，就不管(不执行)后面的表达式(跳过)。", "\n\n", "假如第一个表达式为真，第二个表达式为假，那第三个表达式会不会被执行呢？代码如下：", "\n\n", "\n", "#include<stdio.h>\nint main(void)\n{\n    int a=3,b=5,c=4;\n    (a=1)&&(b=0)&&(c=2);\n    printf(\"a=%d,b=%d,c=%d\\n\",a,b,c);\n    return 0;\n}", "\n\n", "通过上面的结论，我们也可以猜测到运行后的输出结果是：", "\n\n", "\n", "逻辑与运算符的短路求值", "\n", "\n\n", "\n", " ", "\n\n", "逻辑或(||)的短路求值", "\n\n", "再来看一段代码：", "\n\n", "\n", "#include<stdio.h>\nint main(void)\n{\n    int a=3,b=5;\n    (a=1)||(b=4);\n    printf(\"a=%d,b=%d\\n\",a,b);\n    return 0;\n}", "\n\n", "上面这段有代码讲的什么呢？ ", "\n\n", "首先还是定义了两个整型变量，a=3,b=5对吧。", "\n\n", "然后在逻辑或(||)运算符的两个表达式中：第一个表达式是把a赋值成1，第二个表达式是把b赋值成4。", "\n\n", "最后再输出a和b的值。", "\n\n", "那么最后输出的是否会是：a=1,b=4呢？运行结果如下：", "\n\n", "\n", "逻辑或运算符的短路求值", "\n", "\n\n", "有些朋友可能会认为输出结果就是：a=1,b=4吧，其实不是。", "\n\n", "因为这里是逻辑或(||)运算符，在if中只要有一个表达式为真，当然还是从左往右判断，就全部为真，同时为假，才不执行。而刚才我们讲的逻辑与(&&)运算符是：在if中只要有一个表达式为假，也是从左往右判断，就整个表达式为假，同时为真，才执行。", "\n\n", "因为在逻辑或(||)运算符中采用短路求值的方法：逻辑或(||)运算符的结合性也是从左往右计算的，所以从最前面的表达式开始看。如果前面表达式为假(边执行边判断)，才继续看后面的表达式，以此类推，如果前面有一个表达式为真(边执行边判断)，就不管(不执行)后面的表达式(跳过)", "。", "\n\n", "假如第一个表达式为假，第二个表达式为真，那第三个表达式会不会被执行呢？代码如下：", "\n\n", "\n", "#include <stdio.h>\nint main()\n{\n    int a=3,b=5,c=4;\n    (a=0)||(b=1)||(c=2);\n    printf(\"a=%d,b=%d,c=%d\\n\",a,b,c);\n    return 0;\n}", "\n\n", "依然通过上面的结论，我们也可以猜测到运行后的输出结果是：", "\n\n", "\n", "逻辑或运算符的短路求值", "\n", "\n\n", "\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Just make use of the &lt;code&gt;AND&lt;/code&gt; (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) operator. &lt;/p&gt;\n\n&lt;p&gt;The &lt;code&gt;OR&lt;/code&gt; operator just needs one true to execute the conditional, whereas the &lt;code&gt;AND&lt;/code&gt; operator needs all statement to be true.&lt;/p&gt;\n\n&lt;p&gt;I'm not hundred percent sure what you are trying to achieve, but I would also suggest having a re-look at your &lt;code&gt;NOT&lt;/code&gt; (&lt;code&gt;!&lt;/code&gt;) operator and how it is used in your code&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "逻辑运算", "Question": ["OR逻辑运算符的多条件php不返​​回false", ["\n\n", "I have a conditional statement in php, when I add an OR logical operator it doesn't work as intended, in the below example it returns the code that I am trying to prevent it doing.", "\n\n", "Individually each statement works just not when they are together as I have them below. It seems inefficient to repeat the code for each condition.", "\n\n", "if (!is_sp_post_type('profile') || !is_category(array('previews','reviews')) || !is_single(array('previews','reviews'))) {\n       //do stuff \n    };", "\n\n", "I have read this answer ", "Is there a short-circuit OR in PHP that returns the left-most value?", " but I'm still stuck", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;根据优先级的顺序来运算&amp;#xff1a;&lt;br /&gt;1.先运算not&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  flag1是True&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  not是取反运算符&amp;#xff0c;True相反是False&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  那么not flag1就是False&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  print&amp;#xff08;flag1 or flag2 and not flag1) 可以变成print&amp;#xff08;flag1 or flag2 and False)&lt;/span&gt;&lt;br /&gt;2.运算and&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  flag2是False&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  and是与运算符&amp;#xff0c;两边都是True的时候才为True&amp;#xff0c;其他都为False&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  所以flag2 and False为False&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  print&amp;#xff08;flag1 or flag2 and False) 可以变成print&amp;#xff08;flag1 or False)&lt;/span&gt;&lt;br /&gt;3.运算or&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  flag1是True&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  or是或运算符&amp;#xff0c;两边都是False的时候才为False&amp;#xff0c;其他都为True&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  所以flag1 or False为True&amp;#xff1b;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  print&amp;#xff08;flag1 or False) 可以变成print&amp;#xff08;True)&lt;/span&gt;&lt;br /&gt;最后输出True&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["为什么True 和Frue 输出的结果是True不太明白", ["为什么True 和Frue 输出的结果是True不太明白，希望有个人可以来解答一下我的困惑谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是因为逻辑运算&amp;amp;&amp;amp;和||的短路特性。&lt;br /&gt;\n逻辑运算的工作原理是&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;&lt;br /&gt;\n表达式A &amp;amp;&amp;amp; 表达式B &amp;#xff1a;&lt;br /&gt;\n如果A的值为假就返回A的值并且不执行表达式B&amp;#xff0c;否则执行表达式B并且返回B的值&lt;/p&gt;\n\n&lt;p&gt;&lt;br /&gt;\n表达式A || 表达式B &amp;#xff1a;&lt;br /&gt;\n如果A的值为真就返回A的值并且不执行表达式B&amp;#xff0c;否则执行表达式B并且返回B的值&lt;/p&gt;\n\n&lt;p&gt;&lt;br /&gt;\na 是0&amp;#xff0c; !a结果是1 &amp;#xff0c; 1为真就直接返回输出这个1&amp;#xff0c; ||右边的 &amp;#43;&amp;#43;a 不会执行了 &lt;br /&gt;\n第二个 printf(&amp;#34;%d\\n&amp;#34;, !a); 时a还是0&amp;#xff0c; !a结果依然是1&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言逻辑运算问题求大佬答疑", ["#include <stdio.h>", "\nint main()", "\n{", "\n    int a = 0; ", "\n    printf(\"%d\\n\", !a && ++a );", "\n    printf(\"%d\\n\", !a);", "\n    return 0;", "\n}", "\n\n", "这一串代码定义了a =0 ，!a 是真值，++a也是真值，第一个printf打印的是1没问题。", "\n\n", "因为++a，a 就变成了 1，第二个printf 打印的是0，没问题。", "\n\n", "那么看第二段代码", "\n\n", "#include <stdio.h>", "\nint main()", "\n{", "\n    int a = 0; ", "\n    printf(\"%d\\n\", !a || ++a );", "\n    printf(\"%d\\n\", !a);", "\n    return 0;", "\n}", "\n\n", "这里第二个printf为什么打印的会是1呢？"]], "Tag": "程序设计"}
{"Answer": "应该写什么？？？你不是写了吗？", "Konwledge_Point": "逻辑运算", "Question": ["java 逻辑运算问题，在线等", ["\n如图所示， 先算a||b  再算c||d   然后再&&运算，应该怎么写"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;下面是我的理解&amp;#xff0c;不一定正确&amp;#xff0c;仅供参考&amp;#xff1a;&lt;br /&gt;首先执行b&amp;#43;c 和b-c&amp;#xff0c;因为他们的优先级最高&amp;#xff0c;得到 a||10&amp;amp;&amp;amp;0 ,&lt;br /&gt;然后执行10&amp;amp;&amp;amp;0,因为他们是第二优先级&amp;#xff0c;得到a||0 ,&lt;br /&gt;接着执行a||0, 得到1.&lt;br /&gt;所以第二题最后结果是1.&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于c语言逻辑运算问题", ["可以帮我解释下例题第二个吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个是因为--a||b&amp;#43;&amp;#43;&amp;amp;&amp;amp;c&amp;#43;&amp;#43;这个式子先运行了--a&amp;#xff0c;a变成0了&amp;#xff0c;那么||左边就是False,那么它就还要看右边部分的情况&amp;#xff0c;而后面的&amp;#xff0c;比如&amp;#xff1a;&lt;br /&gt;&amp;#43;&amp;#43;a&amp;amp;&amp;amp;--c||&amp;#43;&amp;#43;b&amp;#xff0c;这里&amp;#43;&amp;#43;a后变成1了&amp;#xff0c;那么||左边就是True了&amp;#xff0c;||右边就没有 必要看了&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["“或”的逻辑运算相关问题", ["在课本上做练习题时遇到的问题", "\n", "#include<stdio.h>", "int main()", "{", "    int a,b,c;", "    a=b=c=1;", "    --a||b++&&c++;", "    printf(\"%d,%d,%d\\n\",a,b,c);", "    ++a&&--c||++b;", "    printf(\"%d,%d,%d\\n\",a,b,c);", "    ++a||--b||--c;", "    printf(\"%d,%d,%d\\n\",a,b,c);", "    a--&&--b||++c;", "    printf(\"%d,%d,%d\\n\",a,b,c);", "}", "结果如下", "0,2,2", "1,2,1", "2,2,1", "1,1,1", "\n", "为什么在第一行执行后输出结果显示   “||”也就是“或”逻辑运算符   两边同时执行后的结果", "而后面几行只运算了   “或”   前面的代码"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先比较&amp;#xff0c;再自减&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑运算的，有点小问题", ["#include<stdio.h>", "void main ()", "{", "    int a=-1,b=1,k;", "    if ((++a<0)&&!(b--<=0))", "    printf(\"%d %d\\n\",a,b);", "    else", "    printf(\"%d %d\\n\",b,a);", "}", "\n", "b--<=0，运算的话相当于0<=0对吧，所以说表达式是真的，前面有个！，这个时候表达式就成假的了对吧，我不明白的点在于这个b的值在整个代码中的变化，有大佬能详细讲解一下吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;x%5&amp;#61;&amp;#61;0 且 x%7&amp;#61;&amp;#61;0&lt;br /&gt;这里的x%5&amp;#61;&amp;#61;0表示逻辑判断&amp;#xff0c;当x%5等于0的时候整个表达式的值就是真&amp;#xff0c;否则为假&amp;#xff1b;你误解为表达式的值就是右边这个0&amp;#xff0c;其实不然&amp;#xff0c;而是整个表达式最终的值才是逻辑值&amp;#xff1b;同样x%7&amp;#61;&amp;#61;0则一样判断。&lt;/p&gt;\n&lt;p&gt;表达式1  &amp;amp;&amp;amp;  表达式2&lt;br /&gt;只有表达式1为真时&amp;#xff0c;才会继续判断表达式2&amp;#xff0c;否则不再判断表达式2。&lt;/p&gt;\n&lt;p&gt;不要混淆相等与赋值运算符&lt;br /&gt;比如&lt;br /&gt;if(x&amp;#61;0)这个表达式的最终逻辑就是x&amp;#xff0c;因为x为0&amp;#xff0c;所以条件为假&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["c.语言中的逻辑运算", ["一个数既是5的倍数，又是7的倍数。", "应该是用", "x％5==0&&x％7==0，", "但有个问题就是前面 x%5==0，结果为0，不就是‘假’吗，后面的x%7==0还会运算吗?。我迷了"]], "Tag": "程序设计"}
{"Answer": "运算符优先顺序没搞清楚，赋值是最后的，那个1是true，而不是int 1", "Konwledge_Point": "逻辑运算", "Question": ["php 逻辑运算if相关的问题", ["<?php", "\n\n", "$a = 6;  $b = 5;", "\n\n", "if($a = 3 || $b = 8){         ", "\n\n", "echo $a;       // 输出$a的值是1，这个是为什么么？？？ 不是应该3吗？\n\necho \"<br/>\";\n\necho $b;     \n", "\n\n", "}", "\n\n", "?>"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你只在原字母上&amp;#43;4&amp;#xff0c;后面的加不加都一样又不会超过字母&amp;#43;4。前面的之所以加上判断是应为Z的值是小于z的&amp;#xff0c;防止该值是在a-z之间&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C++逻辑运算&& ||", ["问题遇到的现象和发生背景", "\n", "\n", "问题相关代码，请勿粘贴截图", "\n", "\n", "运行结果及报错内容", "\n", "我的代码第14行比书上给出的答案多了一段 &&c>=‘z’+4 ，我试着去掉这一段，发现并没有影响", "\n", "我的解答思路和尝试过的方法", "\n", "书上的", "\n", "\n", "我想要达到的结果", "\n", "请问为什么可以没有这一段呢？我想不通"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;少东西吧&amp;#xff0c;&amp;amp;&amp;amp; 后面不能什么也没有&amp;#xff0c;或者你多打了一个&amp;amp;&amp;amp;&lt;br /&gt;第三行不对&amp;#xff0c;德摩根律是要加括号的&lt;br /&gt;所以应该是&lt;code class=\"language-javascript\"&gt;(!A || !C || !D) &amp;amp;&amp;amp;( !B || !C || !D)&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;离散数学的知识忘差不多了&amp;#xff0c;下面只能用逻辑推理讲了&lt;/p&gt;\n&lt;p&gt;再展开之后有&lt;code class=\"language-javascript\"&gt;(!A &amp;amp;&amp;amp;( !B || !C || !D))  || (!C &amp;amp;&amp;amp;( !B || !C || !D)) || (!D &amp;amp;&amp;amp;( !B || !C || !D))&lt;/code&gt;&lt;br /&gt;考虑后两者&amp;#xff0c;&lt;br /&gt;对于&lt;code class=\"language-javascript\"&gt;(!C &amp;amp;&amp;amp;(!B || !C || !D)) &lt;/code&gt;&amp;#xff0c;当&lt;code class=\"language-javascript\"&gt;!C&lt;/code&gt;为真时&amp;#xff0c;( !B || !C || !D)必然为真&amp;#xff0c;当&lt;code class=\"language-javascript\"&gt;!C&lt;/code&gt;为假时&amp;#xff0c;逻辑与的运算必然为假&amp;#xff0c;所以&lt;code class=\"language-javascript\"&gt;(!C &amp;amp;&amp;amp;( !B || !C || !D))&amp;#61;!C&lt;/code&gt;&amp;#xff0c;同理&lt;code class=\"language-javascript\"&gt;!D &amp;amp;&amp;amp;(!B || !C || !D)&amp;#61;!D&lt;/code&gt;&lt;br /&gt;所以原式可以写作&lt;code class=\"language-javascript\"&gt;(!A &amp;amp;&amp;amp;( !B || !C || !D))  || !C || !D&lt;/code&gt;&lt;br /&gt;显然当&lt;code class=\"language-javascript\"&gt;!C&lt;/code&gt;或&lt;code class=\"language-javascript\"&gt;!D&lt;/code&gt;为真时&amp;#xff0c;原式为真&amp;#xff0c;当&lt;code class=\"language-javascript\"&gt;!C&lt;/code&gt;和&lt;code class=\"language-javascript\"&gt;!D&lt;/code&gt;为假时&amp;#xff0c;必须&lt;code class=\"language-javascript\"&gt;!A&lt;/code&gt;和&lt;code class=\"language-javascript\"&gt;!B&lt;/code&gt;都为真表达式才为真&amp;#xff0c;所以原式可写作&lt;code class=\"language-javascript\"&gt;!A &amp;amp;&amp;amp; !B || !C || !D&lt;/code&gt;或者&lt;code class=\"language-javascript\"&gt;!(A || B) || C || D&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑运算不太明白，求解", ["\n!(( A && C && D &&) ||(B && C && D &&))\n=!(A && C && D &&)  && !(B && C && D &&)\n=A || C || D && B || C || D\n", "\n", "这样对吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#43;&amp;#43;y&amp;amp;&amp;amp;&amp;#43;&amp;#43;x||&amp;#43;&amp;#43;z;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;这个表达式先执行&amp;#43;&amp;#43;y&amp;amp;&amp;amp;&amp;#43;&amp;#43;x&lt;/li&gt;&lt;li&gt;同时满足true才返回true&amp;#xff0c;但是&amp;#43;&amp;#43;y是0所以不会执行后边的&amp;#43;&amp;#43;x&lt;/li&gt;&lt;li&gt;也就是说&amp;#xff1a;&amp;#43;&amp;#43;y&amp;amp;&amp;amp;&amp;#43;&amp;#43;x这句执行完成&amp;#xff0c;y&amp;#61;0,x&amp;#61;-1&amp;#xff08;x不变&amp;#xff09;&lt;/li&gt;&lt;li&gt;再执行 0 || &amp;#43;&amp;#43;z&amp;#xff08;||表示只要有个true&amp;#xff0c;就返回true&amp;#xff0c;不执行后边代码&amp;#xff09;&lt;/li&gt;&lt;li&gt;由于前边执行返回0&amp;#xff0c;是false&amp;#xff0c;所以执行后边&amp;#43;&amp;#43;z&amp;#xff0c;最后z&amp;#61;0&lt;/li&gt;&lt;li&gt;最后printf(&amp;#34;%d%d%d&amp;#34;,x,y,z)输出-1&amp;#xff0c;0&amp;#xff0c;0&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于不理解逻辑运算的问题", ["main()\n{\n    int ", "x", ",", "y", ",", "z", ";", "\n    ", "x", "=", "y", "=", "z", "=", "-1", ";", "\n    printf(", "\"%d%d%d\"", ",", "x", ",", "y", ",", "z)", ";", "\n    ++y&&++", "x", "||++z", ";", "\n    printf(", "\"%d%d%d\"", ",", "x", ",", "y", ",", "z)", ";", "\n}\n\n", "\n", "为什么第二次打印x还是-1呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;所谓真值表&lt;br /&gt;就是把a和b的每种可能的值列出来&amp;#xff0c;列成一张表&lt;br /&gt;先看第一行&lt;br /&gt;a&amp;#61;真&lt;br /&gt;b&amp;#61;真&lt;br /&gt;那么&amp;#xff01;a&amp;#61;假&lt;br /&gt;&amp;#xff01;b&amp;#61;假&lt;br /&gt;a&amp;amp;&amp;amp;b&amp;#61;真&lt;br /&gt;a||b&amp;#61;真&lt;br /&gt;后面一样&amp;#xff0c;当a是真&amp;#xff0c;b是假时&amp;#xff0c;分别列出了不同表达式的值到底是真还是假&lt;br /&gt;就这样一行一行的看&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑运算及优先次序真值表", [" a     b     !a    !b    A&&B      A Ⅱ B", "真    真    假    假       真            真", "真    假    假    真       假            真", "假    真    真    假       假            真", "假    假    真    真       假            假", "//我是自学初学者上面这个该怎么理解嘞？谢谢各位"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;代码如下&amp;#xff1a;\n&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;cstring&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#include&amp;lt;math.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; namespace std;\n//实现否定\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Neg(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p){\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; flag;\n}\n//实现合取\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Conj(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; q){\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;amp;&amp;amp;q&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; flag;\n}\n//实现析取\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Dis(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; q){\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;||q&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\n flag&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  }\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; flag;\n}\n//实现蕴含 \n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Con(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; q){\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;amp;&amp;amp;q&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; flag;\n}\n//实现等值\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Equ(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; q){\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;((p&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;amp;&amp;amp;q&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)||(p&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;amp;&amp;amp;q&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;))\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\nflag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; flag;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; main()\n{\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p,q;\ncout&amp;lt;&amp;lt;&amp;#34;请输⼊p&amp;#xff0c;q的真假&amp;#xff1a;0或者1:&amp;#34;&amp;lt;&amp;lt;endl;\ncin&amp;gt;&amp;gt;p&amp;gt;&amp;gt;q;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; neg&amp;#61;Neg(p);\ncout&amp;lt;&amp;lt;&amp;#34;判断⾮P真值:&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(neg&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\ncout&amp;lt;&amp;lt;&amp;#34;⾮P为假&amp;#34;&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncout&amp;lt;&amp;lt;&amp;#34;⾮P为真&amp;#34;&amp;lt;&amp;lt;endl;\n}\ncout&amp;lt;&amp;lt;&amp;#34;---------------&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; conj&amp;#61;Conj(p,q);\ncout&amp;lt;&amp;lt;&amp;#34;判断P合取Q真值情况:&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(conj&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\n cout&amp;lt;&amp;lt;&amp;#34;P合取Q为真&amp;#34;&amp;lt;&amp;lt;endl; } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncout&amp;lt;&amp;lt;&amp;#34;P合取Q为假&amp;#34;&amp;lt;&amp;lt;endl;\n}\ncout&amp;lt;&amp;lt;&amp;#34;---------------&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dis&amp;#61;Dis(p,q); \ncout&amp;lt;&amp;lt;&amp;#34;判断P析取Q真值情况:&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(dis&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\ncout&amp;lt;&amp;lt;&amp;#34;P析取Q为真&amp;#34;&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncout&amp;lt;&amp;lt;&amp;#34;P析取Q为假&amp;#34;&amp;lt;&amp;lt;endl;\n}\ncout&amp;lt;&amp;lt;&amp;#34;---------------&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; con&amp;#61;Con(p,q) ;\ncout&amp;lt;&amp;lt;&amp;#34;判断P蕴含Q真值情况:&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(con&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\ncout&amp;lt;&amp;lt;&amp;#34;P蕴含Q为真&amp;#34;&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncout&amp;lt;&amp;lt;&amp;#34;P蕴含Q为假&amp;#34;&amp;lt;&amp;lt;endl;\n}\ncout&amp;lt;&amp;lt;&amp;#34;---------------&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; equ&amp;#61;Equ(p,q);\ncout&amp;lt;&amp;lt;&amp;#34;判断P等值Q真值情况:&amp;#34;&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(equ&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n{\ncout&amp;lt;&amp;lt;&amp;#34;P等值Q为真&amp;#34;&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncout&amp;lt;&amp;lt;&amp;#34;P等值Q为假&amp;#34;&amp;lt;&amp;lt;endl;\n}\n &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; } \n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于离散数学解决逻辑运算的编辑代码", ["思路不太清晰，不懂如何处理这个编程问题", "\n", "，最好只用到数组的知识，c++，不用指针链表"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;位运算直接就是二进制方式处理数据&amp;#xff0c;在使用C语言做硬件开发时就发挥用处了&amp;#xff0c;像单片机开发&amp;#xff0c;你要是使用寄存器方式去开发&amp;#xff0c;那位运算在各个硬件配置都会用的到&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["c语言的位运算真的推荐使用吗？", ["具体的看，这种技巧应该有非常多的规则，应该有较多的通用公式以及推论才对。", "可是书上只写基本运算。按位与，按位或，按位异或，左移右移，常用公式几乎没有。", "推崇说高效，结果讲这么少，难道位运算只是为了让人有装X的感觉吗？", "\n", "与离散数学教材做相比，在命题逻辑一章里，除了介绍基本运算，还罗列了将近20条常用的公式。", "\n", "再拿C语言教材中推崇的指针作比较，指针、结构体，链表，共用体写了100页有余。", "\n", "请在实际工作中真正应用位运算的程序员朋友来说说心得体会。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为python允许像数学上一样的连续逻辑比较的&amp;#xff0c;如 1&amp;lt;a&amp;lt;2&lt;br /&gt;1&amp;gt;2&amp;#61;&amp;#61;0 实际上就是 1&amp;gt;2 and 2&amp;#61;&amp;#61;0 所以是 False&lt;br /&gt;你要其它的比较请带上括号&amp;#xff0c;会有不同结果&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&amp;gt;&amp;gt;&amp;gt; (1&amp;gt;2)&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;  #即 &lt;span class=\"hljs-attribute\"&gt;0&lt;/span&gt;&amp;#61;&amp;#61;0\n&amp;gt;&amp;gt;&amp;gt; 1&amp;gt;(&lt;span class=\"hljs-attribute\"&gt;2&lt;/span&gt;&amp;#61;&amp;#61;0)\n&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt; #即 1&amp;gt;0\n\n&amp;gt;&amp;gt;&amp;gt; (2&amp;gt;1)&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;  #即 &lt;span class=\"hljs-attribute\"&gt;1&lt;/span&gt;&amp;#61;&amp;#61;0\n&amp;gt;&amp;gt;&amp;gt; 2&amp;gt;(&lt;span class=\"hljs-attribute\"&gt;1&lt;/span&gt;&amp;#61;&amp;#61;0)\n&lt;span class=\"hljs-literal\"&gt;True&lt;/span&gt;  #即 2&amp;gt;0\n\n&amp;gt;&amp;gt;&amp;gt; 1&amp;gt;2 &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;2&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;  #即 &lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt;\n&amp;gt;&amp;gt;&amp;gt; 2&amp;gt;&lt;span class=\"hljs-attribute\"&gt;1&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;span class=\"hljs-literal\"&gt;False&lt;/span&gt; # 即2&amp;gt;1 &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-attribute\"&gt;1&lt;/span&gt;&amp;#61;&amp;#61;0\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["Python逻辑运算:1>2==0", ["print（1>2==0）", "为什么输出结果是false"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;由于&amp;lt;&amp;lt;运算符的优先级高于逻辑运算符&amp;amp;&amp;amp;和||&amp;#xff0c;你所有的输出都是cout&amp;lt;&amp;lt;的这个变量&amp;#xff0c;与逻辑或或者逻辑与没有任何关系。相当于都是直接输出了&amp;lt;&amp;lt;后面的整数变量。有帮助请采纳&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["请问下逻辑与和逻辑或在计算题里的运算规则是什么", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;When you check the box, $_POST[the name-not-id] comes back with the value.  Somewhat annoyingly (to me), checkboxes that are unchecked return nothing at all.  So, using the attend as an example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;input class=\"form-check-input\" type=\"checkbox\" name=\"attend\" value=\"yes\"&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;would return \"yes\" in $_POST[\"attend\"] when the box is checked, no value in $_POST when the box is unchecked.  So you could use several tests to see if it is checked.  For example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if (!empty($_POST[\"attend\"])) ...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if (isset($_POST[\"attend\"]) &amp;amp;&amp;amp; $_POST[\"attend\"] === \"yes\") ...\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "逻辑运算", "Question": ["我想对从php中的表单发布的值执行逻辑运算", ["\n\n", "Here is html...", "\n\n", "<form name=\"stream\" method=\"post\" action=\"scripts/validate.php\">\n  <div class=\"form-check\">\n    <input class=\"form-check-input\" type=\"checkbox\" name=\"attend\" value=\"yes\" autocomplete=\"off\">\n    <label class=\"form-check-label\" for=\"attend\">Yes, I will attend the event in Edo State.</label>\n  </div>\n  <div class=\"form-check\">\n    <input class=\"form-check-input\" type=\"checkbox\" name=\"trad\" value=\"yes\" autocomplete=\"off\">\n    <label class=\"form-check-label\" for=\"trad\">Yes, I'm interested in getting the Asoebi.</label>\n  </div>\n  <div class=\"form-check\">\n    <input class=\"form-check-input\" type=\"checkbox\" name=\"house\" value=\"yes\" autocomplete=\"off\">\n    <label class=\"form-check-label\" for=\"house\">Yes, I am interested in getting Accommodation.</label>\n  </div>\n\n  <button class=\"btn bg-bur text-white h4 btn-block mt-20\" type=\"submit\" name=\"stream\">Submit</button>\n</form>\n", "\n\n", "And here is the php to process the form data but it keeps displaying the same result, \"I want the full registration\" even when 1 checkbox is checked or none is checked", "\n\n", "<?php \nif( isset( $_POST['stream'] ) ) {    \n    if ($_POST['attend'] == 'yes' && $_POST['trad'] == 'yes' && $_POST['house'] == 'yes' ) {\n        echo \"I want the full registration\";\n    }\n    elseif ($_POST['attend'] == 'yes' && $_POST['trad'] == 'yes' && $_POST['house'] !== 'yes' ) {\n        echo \"I want the Asoebi and I will attend\";\n    }\n    elseif ($_POST['attend'] == 'yes' && $_POST['trad'] !== 'yes' && $_POST['house'] !== 'yes' ) {\n        echo \"I am only attending\";\n    }\n    elseif ($_POST['attend'] !== 'yes' && $_POST['trad'] == 'yes' && $_POST['house'] !== 'yes' ) {\n        echo \"I only want Asoebi\";\n    }\n    elseif ($_POST['attend'] !== 'yes' && $_POST['trad'] !== 'yes' && $_POST['house'] !== 'yes' ) {\n        echo \"You haven't selected anything\";\n    }\n}\n?>\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为C&amp;#43;&amp;#43;语法要求&lt;code class=\"language-javascript\"&gt;return&lt;/code&gt;后面可以是一个表达式&amp;#xff0c;返回的是这个表达式的值。而&lt;code class=\"language-javascript\"&gt;(a&amp;#61;&amp;#61;1)&lt;/code&gt;是一个表达式。&lt;br /&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/language/return\" id=\"textarea_1648898961944_1648899228088_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/cpp/language/return&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C++return后面可以加括号,括号内可以进行数学或者逻辑运算", ["bool型函数，", "bool aisa(int k){", "return (a==1)}", "为什么可以这么写"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;pthon中 &amp;amp; 是数值二进制按位与运算符&amp;#xff0c;不是逻辑运算符。pthon中 逻辑与运算符是 and  &lt;/p&gt;\n&lt;p&gt;数值二进制位运算符&amp;amp;的优先级高于 &amp;lt;&amp;#xff0c;&amp;gt;&amp;#xff0c;&amp;#61;&amp;#61;关系运算符&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(run.text)&amp;gt;&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt; &amp;amp; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;(re.search(&lt;span class=\"hljs-string\"&gt;r&amp;#39;\\d&amp;#39;&lt;/span&gt;&amp;#xff0c;run.text))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;实际上等于是&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(run.text) &amp;gt; ( &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt; &amp;amp; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;(re.search(&lt;span class=\"hljs-string\"&gt;r&amp;#39;\\d&amp;#39;&lt;/span&gt;&amp;#xff0c;run.text)))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同样的 2&amp;gt;3 &amp;amp; 4&amp;gt;5 等于 2&amp;gt;(3 &amp;amp; 4)&amp;gt;5&lt;/p&gt;\n&lt;p&gt;你改成真正逻辑与运算符 and 就好了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;len&lt;/span&gt;(run.text)&amp;gt;&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;and&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt;(re.search(&lt;span class=\"hljs-string\"&gt;r&amp;#39;\\d&amp;#39;&lt;/span&gt;&amp;#xff0c;run.text))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;hr /&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢! 点击我这个回答右上方的【采纳】按钮&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["Python逻辑运算:为什么false+ false等于true？什么时候等于True?", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;DO WHILE 性别&amp;#61;&amp;#34;男” .AND. 年龄&amp;gt;&amp;#61;18&lt;/p&gt;\n&lt;p&gt;foxpro的逻辑运算符两端都有.点的&amp;#xff1a; .AND.    .OR.   .NOT.&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑运算中do while性别=\"男\" and()是真值假值，还是题错了", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个多个问题&amp;#xff0c;我一个一个给你说吧&lt;/p&gt;\n\n&lt;p&gt;1. 为什么右移操作会连符号为一起改变&amp;#xff0c;&lt;/p&gt;\n\n&lt;p&gt;这个嘛&amp;#xff0c;确实不知道呢&amp;#xff0c;毕竟别人这么设计&amp;#xff0c;可能有很多考虑在里面吧&amp;#xff0c;但是不知我这种渣渣能知道了的&lt;/p&gt;\n\n&lt;p&gt;2. 移位操作比乘除快&lt;/p&gt;\n\n&lt;p&gt;是因为对计算来说移位很简单&amp;#xff0c;而如果要完成的一次乘除的话&amp;#xff0c;可能需要更多的计算。具体为啥&amp;#xff0c;可能你需要了解一下底层这么实现加减乘除的。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["Java中的移位运算", ["这是我今天看到的关于移位运算的帖子，然后有了一点想法。", "\n\n", "对于一个byte类型的变量a，a = 5 ，它的二进制补码为00000101，按照这个想法，逻辑右移一位的结果为00000010，正数的反码、补码、原码都一样，它的结果应该为2。", "\n同一个变量，进行同样的初始化操作，算数右移一位，结果应该为10000010，也就是说，算数右移一位，这个数从正数变成了负数，结果为-2。", "\n我不明白，为什么右移操作会连符号位一起改变，还有一点，就是，为什么移位操作会比乘除法更快捷？因为我要计算它的原码，对于负数，我还要计算反码和补码。", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是数学中的与&lt;br /&gt;&lt;a href=\"https://zhidao.baidu.com/question/464438175.html\" id=\"textarea_1631539591687_1631539655509_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;&amp;#xfffd;&amp;#xfffd;ѧ&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;Һͻ&amp;#xfffd;ķ&amp;#xfffd;&amp;#xfffd;ŷֱ&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;ʲô_&amp;#xfffd;ٶ&amp;#xfffd;֪&amp;#xfffd;&amp;#xfffd;&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"margin: 0px 0 2px\"&gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://www.baidu.com/favicon.ico?t&amp;#61;20171027\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://zhidao.baidu.com/question/464438175.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/663556935136179.png\" width=\"600px\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;有帮助望采纳&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["请教个问题，逻辑运算符与是&&，为什么逻辑算式里总是用向下开口的大于号表示？", ["标注红色①的位置，向下的大于号什么意思，请教个问题，逻辑运算符与是&&，为什么逻辑算式里总是用向下开口的大于号表示？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为170/30.48结果是个double型&lt;br /&gt;而你用%d输出的是int型&amp;#xff0c;输出之前你又没有将结果强制转换成int&amp;#xff0c;导致它把double型的前4个字节当做int输出&lt;br /&gt;而你输出foot的时候就很正常&amp;#xff0c;因为foot本身是int型&amp;#xff0c;double已经隐式的转换为了int&lt;br /&gt;这种丢失精度的转换在c&amp;#43;&amp;#43;&amp;#xff0c;c#等类似的语法中是不允许的&amp;#xff0c;但是c中允许。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["不能理解C语言中的带小数的运算逻辑。为什么cm/30.48 的结果这么奇怪？求解运算逻辑？", ["代码如下：", "\n", "\n", "\n", "**不能理解C语言中的带小数的运算逻辑。为什么cm/30.48 的结果这么奇怪？求解运算逻辑？", "**"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为对于&amp;amp;&amp;amp;符号&amp;#xff0c;如果左边为False的话它就不会执行右边的判断了&amp;#xff0c;这里 m &amp;#61; a &amp;gt; b&amp;#xff0c;由于a &amp;lt; b&amp;#xff0c;所以它为False,那么&amp;amp;&amp;amp;符号右边的就不会看了&amp;#xff0c;所以n还是等于2的&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于#c语言#的问题：设a、b、c、d、m、n均为int型变量，则逻辑表达式(m=a>b)&&(n=c>d)运算后", ["设a、b、c、d、m、n均为int型变量，且a = 5、b = 6、c = 7、d = 8、m = 2、n = 2，则逻辑表达式( m = a > b ) && ( n = c > d)运算后，n的值为（   ）。", "这个答案为啥是2啊，难到不应该是c>d不满足等于0然后赋值给n吗？我的逻辑是不是有问题", "\n", "#include <stdio.h>", "int main(){", "int a = 5,b = 6,c = 7,d = 8,m =2 ,n = 2;", "( m = a > b ) && ( n = c > d);", "printf(\"%d\",n);", "return 0;", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;pre&gt;&lt;code&gt;SELECT id, name FROM users WHERE id &amp;lt;&amp;gt; $value1 AND email = '$value2'\"\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; is the same. &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; is the same. You probably see &lt;code&gt;AND&lt;/code&gt; and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; because is the standard in SQL. The issue was the equal operator is &lt;code&gt;=&lt;/code&gt; instead of &lt;code&gt;==&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;In the second part of your question, &lt;code&gt;ss&lt;/code&gt; is wrong. &lt;code&gt;d&lt;/code&gt; is for type double, &lt;code&gt;s&lt;/code&gt; is for strings.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$query=$conn-&amp;gt;prepare(\"SELECT id, name from users WHERE id != ? &amp;amp;&amp;amp; email = ?\");\n$query-&amp;gt;bind_param('ds', $value1, $value2);\n$query-&amp;gt;execute();\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can check types on &lt;a href=\"http://php.net/manual/en/mysqli-stmt.bind-param.php\" rel=\"nofollow\"&gt;php bind_param function help&lt;/a&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "逻辑运算", "Question": ["如何在MYSQLI中使用逻辑运算符 -  PHP", ["\n\n", "I am writig a simple select statement, and since the connection object is mysqli, i cant use AND , && , OR like operators as it giving error", "\n\n", "function getdata($value1,$value2)\n{\nglobal $conn;\n$query = \"SELECT id, name from users WHERE id!=$value1 && email==$value2 \";\n$result = $conn->query($query);\n}\n", "\n\n", "This dosen't work :-(", "\n\n", "Error: trying to get property of non object .. bla bla .. \n", " Which means there something wrong with my sql statement, as when i try without logical operators it works, but of no use ofcourse .", "\n\n", "Using prepare statement & bind parameters", "\nI referred to This thread ", "SELECT in MYSQLI", "  and tried with prepare statements.. but i'm doing something wrong i guess", "\n\n", "$query=$conn->prepare(\"SELECT id, name from users WHERE id!=? && email==?\");\n    $query->bindParam(\"ss\", $value1,$value2); // line 20 error points here\n    $query->execute();\n", "\n\n", "Error: ", "\n\n", "Call to a member function bindParam() on a non-object in /mydir/file.php line 20\n", "\n\n", "P.S. ", "var_dump($query);", " returns ", "bool(false)", "\n    "]], "Tag": "程序设计"}
{"Answer": "先普及以下&amp;&amp; 和 || 逻辑运算符\r\n\r\n对于逻辑与运算符（&amp;&amp;），当且仅当两个运算对象都为真的时结果为真；对于逻辑或运算符（||），只要两个运算对象中的一个为真结果就为真\r\n\r\n为追求效率，有个短路求值策略。\r\n\r\n对于逻辑与运算符（&amp;&amp;），当且仅当左侧运算符为真的时候才对右侧运算对象求值。例如a&amp;&amp;b ，如果a为假，整个表达式为假，而无需知道b\r\n\r\n对于逻辑或运算符（||），当且仅当左侧运算符为假的时候才对右侧运算对象求值。例如a&amp;&amp;b ，如果a为假，需知道b的真假，才能知道表达式的真假\r\n\r\n对于A选项：\r\n\r\n```\r\n (a&gt;=0 || b&gt;=0) &amp;&amp; (a&lt;0 || b&lt;0) \r\n \r\n```\r\n要想A选项输出真，左右两边必须满足一个条件，要么a大于等于0，b小于零，要么b大于等于0，a小于零，因此这个表达式所以可以用来判断两个数是否为一正一负\r\n\r\n对于B选项：\r\n\r\n```\r\n (a&gt;=0 &amp;&amp; b&gt;=0) &amp;&amp; (a&lt;0 &amp;&amp; b&lt;0) \r\n \r\n```\r\n可以吧括号拆开来看，则等价于\r\n\r\n``` \r\n a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; a&lt;0 &amp;&amp; b&lt;0\r\n\r\n 有可以写成\r\n\r\n a&gt;=0 &amp;&amp; a&lt;0 &amp;&amp; b&gt;=0 &amp;&amp; b&lt;0\r\n \r\n```\r\n\r\n看到这应该可以明白，有这样的a，b同时满足又大于等于又小于0的数么？\r\n\r\n对于C选项：\r\n\r\n```\r\n (a+b&gt;0) &amp;&amp; (a+b&lt;=0) \r\n \r\n```\r\n\r\n你可以吧a+b看成c，那么满足c即大于等于零又小于零的数存在么？显然不存在", "Konwledge_Point": "逻辑运算", "Question": ["新人C语言问题求教求解答", ["求解答ABC什么意思 "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先&amp;#xff0c; 取出所有的数据是不可取的&amp;#xff0c;如果表很大&amp;#xff0c; 会造成长时间的索引等待&amp;#xff0c;其次&amp;#xff0c;在实际的环境中&amp;#xff0c; 数据库和站点往往不在一台服务器上&amp;#xff0c;   这也就意味着增加了数据传输的大小&amp;#xff0c; 降低了传输效率。&lt;/p&gt;\n&lt;p&gt;一般情况下&amp;#xff0c;数据逻辑很复杂&amp;#xff0c; 可以考虑存储过程去进行逻辑计算。如果查询出来的数据时效性不是高&amp;#xff0c; 允许有时间差&amp;#xff0c; 可以考虑将数据缓存到redis&amp;#xff08;设置一个容忍的过期时间&amp;#xff09;, 提高效率。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["复杂的逻辑应不应该写进 sql，请教一下", ["写一个复杂的 sql 直接取出所需要的数据", "用简单 sql 取出所有相关数据，再遍历进行复杂的逻辑运算", "工作中，以上两种方法如何选择"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C和C&amp;#43;&amp;#43;算法完整教程&amp;#xff1a;https://blog.csdn.net/it_xiangqiang/category_10768339.html&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["实现单链表盘的数据结构基本运算", ["\n", "//#pragma once\n//头文件中放的是节点类\n#ifndef _LINKLIST_H_\n#define _LINKLIST_H_\ntemplate<class Type>\nclass LinkNode {\npublic:\n\tType* next;\n\tType data;\n};\n\n\n#endif // !_LINKLIST_H_\n\n\n//下面的是函数体\n#include<iostream>\n#include \"LinkList.h\"\nusing namespace std;\ntemplate<class Type>\nclass LinkList_tail {\npublic:\n\tLinkList_tail() {}\n\tvoid InitList_tail(LinkNode<Type>* L);   //建立一个头节点\n\tvoid CreateList_tail(LinkNode<Type>* L, const Type a[], const int n);   \n\tint ListLength_tail(LinkNode<Type>* L) const;\n\tbool ListEmpty_tail(LinkNode<Type>* L) const;\n\tbool GetElem_tail(LinkNode<Type>* L, const int i, const Type& e);    //按照输入的位置查询元素值\n\tint LocateList_tail(LinkNode<Type>* L, const Type& e);               //按照元素值查询链表并返回其在链表中的逻辑位置\n\tbool InsertList_tail(LinkNode<Type>* L, const int i, const Type& e); //将元素插入到链表的第i个位置\n\tbool DeleteList_tail(LinkNode<Type>* L, const int i,const Type &e);  //删除链表中第i个位置的元素并使用e接收\n\tvoid DispList_tail(LinkNode<Type>* L) const;\n\tvoid DestoryList_tail(LinkNode<Type>* L); \n\t~LinkList_tail() {\n\t\tcout << \"调用析构函数释放LinkList对象！\" << endl;\n\t}\n\n};\n\ntemplate<class Type>\nvoid LinkList_tail<Type>::InitList_tail(LinkNode<Type>* L){\n\tL = (LinkNode*)malloc(sizeof(LinkNode));\n\tL->next = NULL;\n}\n\ntemplate<class Type>\nvoid LinkList_tail<Type>::CreateList_tail(LinkNode<Type>* L, const Type a[], const int n){\n\tLinkNode<Type>* pre = L;\n\tLinkNode<Type>* s;\n\tint i;\n\tfor (i = 0;i < n;i++) {\n\t\ts = (LinkNode*)malloc(sizeof(LinkNode));\n\t\ts->data = a[i];\n\t\tpre->next = s;\n\t\tpre = s;\n\t}\n\tpre->next = NULL;\n}\n\ntemplate<class Type>\nint LinkList_tail<Type>::ListLength_tail(LinkNode<Type>* L) const{\n\tint length = 0;\n\tLinkNode* pre = L->next;\n\twhile (pre != NULL) {\n\t\tlength++;\n\t\tpre = pre->next;\n\t}\n\treturn length;\n}\n\ntemplate<class Type>\nbool LinkList_tail<Type>::ListEmpty_tail(LinkNode<Type>* L) const\n{\n\treturn (L->next == NULL);\n}\n\ntemplate<class Type>\nbool LinkList_tail<Type>::GetElem_tail(LinkNode<Type>* L, const int i, const Type& e)\n{\n\tLinkNode<Type>* pre = L->next;\n\tint j = 0;\n\tif (i < 0) return false;\n\twhile (j < i - 1 && pre != NULL) {\n\t\tj++;\n\t\tpre = pre->next;\n\t}\n\tif (pre == NULL) {\n\t\tcout << \"查询失败！\" << endl;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\te = pre->data;\n\t\tcout << \"查询成功！\" << endl;\n\t\treturn true;\n\t}\n}\n\ntemplate<class Type>\nint LinkList_tail<Type>::LocateList_tail(LinkNode<Type>* L, const Type& e)\n{\n\tint number = 0;\n\tLinkNode<Type>* pre = L->next;\n\twhile (pre != NULL && pre->data != e) {\n\t\tnumber++;\n\t\tpre = pre->next;\n\t}\n\tif (pre == NULL) {\n\t\tcout << \"按元素值查找失败！\" << endl;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tcout << \"查找成功！\" << endl;\n\t\treturn number;\n\t}\n}\n\ntemplate<class Type>\nbool LinkList_tail<Type>::InsertList_tail(LinkNode<Type>* L, const int i, const Type& e)\n{\n\tLinkNode<Type>* pre = L->next, * s;\n\tint j = 0;\n\tif (i < 0) \n\t\treturn false;\n\twhile (j < i - 1 && pre != NULL) \n\t{   //得到链表的物理序号\n\t\tj++;\n\t\tpre = pre->next;\n\t}\n\tif (pre == NULL) \n\t\treturn false;\n\t/*else\n\t{\n\t\ts = (LinkNode*)malloc(sizeof(LinkNode);\n\t\ts->data = e;\n\t\tpre->next = s;\n\t\tpre = s;\n\t\tcout << \"插入成功！\" << endl;\n\t\treturn true;\n\t}*/\n}\n\ntemplate<class Type>\nbool LinkList_tail<Type>::DeleteList_tail(LinkNode<Type>* L, const int i, const Type& e)\n{\n\tLinkNode<Type>* pre = L;\n\tLinkNode<Type>* q;\n\tint j = 0;\n\tif (i < 0) {\n\t\tcout << \"删除失败！\" << endl;\n\t\treturn false;\n\t}\n\twhile (j < i - 1 && pre != NULL) {     //得到物理下标\n\t\tj++;\n\t\tpre = pre->next;\n\t}\n\tif (pre == NULL) {\n\t\tcout << \"删除失败！\" << endl;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tq = pre->next;\n\t\tif (q == NULL) {\n\t\t\tcout << \"删除失败！\" << endl;\n\t\t\treturn false;\n\t\t}\n\t\te = q->data;\n\t\tpre->next = q->next;\n\t\tfree(pre);\n\t}\n\treturn false;\n}\n\ntemplate<class Type>\nvoid LinkList_tail<Type>::DispList_tail(LinkNode<Type>* L) const\n{\n\tLinkNode<Type>* pre = L->next;\n\twhile (pre != NULL) {\n\t\tcout << pre->data << \"  \" << endl;\n\t}\n\tcout << endl;\n}\n\ntemplate<class Type>\nvoid LinkList_tail<Type>::DestoryList_tail(LinkNode<Type>* L)\n{\n\tLinkNode<Type>* pre = L->next;\n\twhile (pre != NULL) {\n\t\tfree(pre);\n\t\tpre = pre->next;\n\t}\n\tfree(pre);\n}\nint main() {\n\tLinkNode<int>* L;\n\tint arr[9] = { 1,2,3,4,6,7,8,9,10 };\n\tLinkList_tail<int> object;\n\tobject.InitList_tail(L);\n\tobject.CreateList_tail(L, arr, 9);\n\tobject.DestoryList_tail(L);\n\treturn 0;\n}\n\n", "\n\n", "哪位大神可以帮我看看这个程序，程序是实现单链表的基本操作，但是在VS上运行的时候碰到了很多问题，这歌程序运行不出结果，哪位大神能帮我找找错误吗，拜托了，救救孩子吧。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-attr\"&gt;“逗号表达式&amp;#xff0c;是C语言中的逗号运算符&amp;#xff0c;优先级别最低&amp;#xff0c;它将两个及其以上的式子连接起来&amp;#xff0c;从左往右逐个计算表达式&amp;#xff0c;整个表达式的值为最后一个表达式的值\n\n所以输出的是b&amp;#43;1 &lt;/span&gt;&amp;#61;&lt;span class=\"hljs-string\"&gt; 8\n\n&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["这个代码的运算逻辑是什么", ["为什么它的输出结果是8，麻烦能给我说一下这个代码的运算过程，感谢（别骂勿喷）"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;As you can see in the &lt;a href=\"http://php.net/manual/en/language.operators.precedence.php\" rel=\"nofollow\"&gt;doc&lt;/a&gt; operators in PHP have different priorities. It means:&lt;code&gt;!&lt;/code&gt; applied to &lt;code&gt;$test&lt;/code&gt; first.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;According to the &lt;a href=\"http://php.net/manual/en/language.types.boolean.php\" rel=\"nofollow\"&gt;doc&lt;/a&gt;, empty string &lt;code&gt;''&lt;/code&gt; or &lt;code&gt;'0'&lt;/code&gt; will be converted to &lt;code&gt;false&lt;/code&gt;, otherwise &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;It is not the same. When &lt;code&gt;$test&lt;/code&gt; equals to empty string &lt;code&gt;''&lt;/code&gt; or &lt;code&gt;'0'&lt;/code&gt; this two conditions have different behavior.&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n    &lt;/div&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑布尔否定运算符优先级和关联", ["\n\n", "here's my first question(s) on StackOverflow, and as such I imagine it ", "has", " been asked here before, but everything I type into the search bar gives me different questions. (Or sometimes \"no\" results at all!)", "\n\n", "I am learning on w3Schools, but I saw this seemingly simple code snippet which stirred up a small parcel of questions:", "\n\n", "In essence the code says: ", "\n\n", "if(! test === FALSE)\n  display(\"test successful!\");\nelse\n  display(\"test failed...\")\n", "\n\n", "\"", "test", "\" in this particular case returns a string on success or a (Boolean) ", "FALSE", " upon failure.", "\n\n", "Here are the questions that stirred within me.", "\n\n", "\n", "\n", "As for the exclamation point (aka \"Logical NOT\" aka \"Negation Operator\") at the beginning of a conditional/if statement, is that: ", "\n\n", "A) Applied to the whole statement within the parentheses?, or", "\n\n", "B) Only associated to \"test\"?", "\n", "\n", "\n", "Note: The negation operator's associativity may not change the outcome in this instance, but its associativity would matter in a case like: (! FALSE || TRUE), yeah?", "\n\n", "\n", "\n", "I understand how the Negation Operator works on Booleans, but how does the Negation Operator behave when faced with a (PHP) string?", "\n\n", "A) Does the negation operator's behavior change if the string happens to be something tricky like \"true\" or \"0\"?", "\n", "\n", "Is ", "(! test === FALSE)", " the same as ", "(test !== FALSE)", "? Why didn't they just use \"!==\"?", "\n", "\n", "HERE", " is the actual code in question:", "\n\n", "if (!filter_var($email, FILTER_VALIDATE_EMAIL) === false) {\n  echo(\"$email is a valid email address\");\n} else {\n  echo(\"$email is not a valid email address\");\n}\n", "\n\n", "Further PHP question", ": Is there some sort of advantage to use ", "filter_var()", " over ", "filter_input()", " in this circumstance? Why did w3Schools use filter_var() and not filter_input()?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;a&lt;/span&gt;&amp;#61;3:\n   a&amp;#43;(&lt;span class=\"hljs-attribute\"&gt;a-&lt;/span&gt;&amp;#61;a*a) 先算括号里的\n(&lt;span class=\"hljs-attribute\"&gt;a-&lt;/span&gt;&amp;#61;a*a)&amp;#xff1a;a&amp;#61;a-a*a    &lt;span class=\"hljs-attribute\"&gt;a&lt;/span&gt;&amp;#61;3-9     \n\n此时a&amp;#61; -6\na&amp;#43;(-6)&amp;#61;-12\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言的运算逻辑说明", ["\n", "void", " ", "main", "()", "\n", "{\n       ", "int", " a=", "3", ";\n       ", "printf", "(", "\"%d\"", ",a+(a-=a*a));\n\n}\n", "\n", "为什么等于-12"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不应该呀&lt;br /&gt;你直接console.log(这个if条件) 看一下输出的是 false 还是 true &lt;/p&gt;\n&lt;p&gt;req.query.cate_id&lt;br /&gt;req.query.state &lt;/p&gt;\n&lt;p&gt;两个值都是基本数据类型也不涉及数据延迟&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑或运算问题||，求各位", ["req.query.cate_id = 2", "req.query.state = '已发布‘", "两个进行逻辑或是多少?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;在 C 语言中&amp;#xff0c;逻辑与 (&amp;amp;&amp;amp;) 和逻辑或 (||) 都是带有短路特性的逻辑运算符。具体来说&amp;#xff0c;逻辑与运算符在表达式的左侧操作数为假时&amp;#xff0c;会直接返回假而不再计算右侧操作数&amp;#xff1b;而逻辑或运算符在左侧操作数为真时&amp;#xff0c;也会直接返回真而不再计算右侧操作数。&lt;/p&gt;\n&lt;p&gt;当表达式中既有逻辑与又有逻辑或运算符时&amp;#xff0c;需要按照优先级顺序和结合性进行计算。在 C 语言中&amp;#xff0c;逻辑与的优先级高于逻辑或&amp;#xff0c;因此在遇到这种情况时&amp;#xff0c;要先计算逻辑与操作。如果逻辑与操作返回假&amp;#xff0c;则整个逻辑或表达式的值也就确定为假。只有当逻辑与操作返回真时&amp;#xff0c;才需要计算逻辑或操作&amp;#xff0c;并根据右侧操作数的真或假来得到最终的结果。&lt;/p&gt;\n&lt;p&gt;在您提供的表达式 a&amp;amp;&amp;amp;b&amp;#43;c||b&amp;#43;&amp;#43;-c 中&amp;#xff0c;根据上述计算规则&amp;#xff0c;需要首先计算 a &amp;amp;&amp;amp; (b&amp;#43;c)&amp;#xff0c;再将其与 b&amp;#43;&amp;#43;-c 做逻辑或运算。因为 a 的值为非零&amp;#xff0c;因此 a &amp;amp;&amp;amp; (b&amp;#43;c) 的结果为真&amp;#xff1b;而 b&amp;#43;&amp;#43;-c 的值为 1&amp;#xff0c;因此最终表达式的值应该为真&amp;#xff0c;即 1。&lt;/p&gt;\n&lt;p&gt;需要注意的是&amp;#xff0c;虽然逻辑与和逻辑或都是带短路特性的运算符&amp;#xff0c;但这并不是说在上述表达式中会有短路发生。因为在计算 a &amp;amp;&amp;amp; (b&amp;#43;c) 的过程中&amp;#xff0c;并没有出现任何可以导致短路的情况&amp;#xff0c;所以整个表达式的值需要全部计算出来。如果您改变表达式中的变量值&amp;#xff0c;可能会得到不同的结果。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言逻辑与和逻辑或混合运算，计算顺序", ["C语言中，如果表达式中即有逻辑与&&，又有逻辑或||，应该怎么算呢？", "例如:int a =6, b = 4, c = 3，则表达式  a&&b+c||b++ - c 如何求解？是把a看成左侧表达式，把b+c||b++ - c看成右侧表达式，还是把", "a&&b+c看成左侧表达式，b++ - c看成右侧表达式呢？", "有说||优先级低于&&，所以||要后算，所以  0 && 1 ||  1  && 1，这个式子应该先算0 && 1结果为0，再算1 && 1结果为1，再0||1结果为1，还有人说应该把0看成左侧表达式，右边的1||1&&1作为右侧表达式，因为0&& 将发生短路，所以整个右边的表达式都不算，而结果为0，两种做法结果相反，我在dev c++上测试结果为1，那么是否可以说&&与||相遇，应先算&&，再算||呢？求高人指点"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;y--一直到0就终止循环了&amp;#xff0c;0为假&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["为什么循环在y=0时终止", ["while后括号里是什么意思啊，怎么看出循环几次，什么时候终止循环", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1&lt;/p&gt;\n&lt;p&gt;这里的&amp;#xff01;x 意思是取反&amp;#xff0c;例如x不等于0&amp;#xff0c;&amp;#xff01;x 就变成0&lt;br /&gt;思考角度主要是因为你对&amp;#xff01;x没有理解&amp;#xff0c;理解了之后按照运算符号优先级就能整明白了&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["有人会吗 一道问题 😊解答", ["第四题应该从什么角度思考 逻辑运算为什么可以输出一个准确的值 不能理解"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;初始值&amp;#xff1a;i&amp;#61;10,j&amp;#61;3,k&amp;#61;0&lt;br /&gt;表达式 i&amp;#61;&amp;#61;1 &amp;amp;&amp;amp; (j&amp;#61;&amp;#61;3 || (k&amp;#61;k&amp;#43;1))&lt;/p&gt;\n&lt;p&gt;计算顺序是&amp;#xff1a;&lt;br /&gt;先计算i&amp;#61;&amp;#61;1&amp;#xff0c;i&amp;#61;10&amp;#xff0c;i&amp;#61;&amp;#61;1不成立&lt;br /&gt;&amp;amp;&amp;amp;运算时&amp;#xff0c;如果&amp;amp;&amp;amp;左侧为假&amp;#xff0c;右侧就不再执行&amp;#xff0c;因为当&amp;amp;&amp;amp;左侧为假时&amp;#xff0c;右侧不管真假&amp;#xff0c;整体的运算结果都是假&amp;#xff0c;所以&amp;#xff0c;&lt;br /&gt;当&amp;amp;&amp;amp;左侧为假时&amp;#xff0c;编译器就不再执行&amp;amp;&amp;amp;右侧的运算了&amp;#xff0c;所以&amp;#xff0c;在这个表达式中(j&amp;#61;&amp;#61;3 || (k&amp;#61;k&amp;#43;1))是不执行的&lt;br /&gt;i、j、k的值不变&amp;#xff0c;仍然是 i&amp;#61;10,j&amp;#61;3,k&amp;#61;0&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;表达式&amp;#xff1a;i&amp;#61;&amp;#61;1 &amp;amp;&amp;amp; j&amp;#61;&amp;#61;3 || (k&amp;#61;k&amp;#43;1)&lt;br /&gt;计算顺序从做到右&amp;#xff0c;i&amp;#61;&amp;#61;1不成立&amp;#xff0c;所以&amp;amp;&amp;amp;右侧的j&amp;#61;&amp;#61;3不执行&amp;#xff0c;执行k&amp;#61;k&amp;#43;1,k&amp;#61;1&lt;br /&gt;所以&amp;#xff0c;最后i&amp;#61;10,j&amp;#61;3,k&amp;#61;1&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;在表达式 i&amp;#61;&amp;#61;1 &amp;amp;&amp;amp; (j&amp;#61;&amp;#61;3 || (k&amp;#61;k&amp;#43;1))中&amp;#xff0c;&amp;amp;&amp;amp;右侧在一个()中&amp;#xff0c;()中的内容看做一个整体。&lt;br /&gt;在表达式i&amp;#61;&amp;#61;1 &amp;amp;&amp;amp; j&amp;#61;&amp;#61;3 || (k&amp;#61;k&amp;#43;1)中&amp;#xff0c;&amp;amp;&amp;amp;右侧没有()&amp;#xff0c; 只有j&amp;#61;&amp;#61;3参与 &amp;amp;&amp;amp;运算&lt;br /&gt;注意两者的差别&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["这个l j k分别是几捏", ["不懂短路原则", "c语言逻辑运算的问题", "这个思考题", "l j k分别是几呢", "谢谢大家！"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;第二题&amp;#xff0c;a--&amp;amp;&amp;amp;--b&amp;#xff0c;首先计算 a--,结果为1&amp;#xff0c;a变为0&amp;#xff1b;前面a--为真&amp;#xff0c;继续计算 --b&amp;#xff0c;结果为b-1, 即0&amp;#xff0c;b变为0; 表达式结果不成立&amp;#xff0c;也就是 0。&lt;/li&gt;&lt;li&gt;第三题&amp;#xff0c;--a&amp;amp;&amp;amp;b--.&amp;#xff0c;首先计算--a, 结果为a-1&amp;#xff0c;即0&amp;#xff0c;a变为0&amp;#xff1b;前面--a为假&amp;#xff0c;后面不计算b--, b还是1。表达式结果不成立&amp;#xff0c;也就是0。&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于#c语言#的问题： 逻辑与运算断路规则", ["第2题a--&&--b,a--的值为0时按照断路规则--b,应该不计算为1(表达式b=1)像第3题因为断路规则为1才对为什么会是0"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;赋值的0.6改为1&amp;#xff0c;把最后一个else改为 if a &amp;gt; b:&amp;#xff0c;条件清晰明了&amp;#xff0c;有用记得采纳&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;import&lt;/span&gt; numpy as np\n\n&lt;span class=\"hljs-comment\"&gt;# Evaluator1 - Repeatability&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;# Deviation&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Device1_deviation&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;06&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;05&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Device2_deviation&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;06&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;05&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Device3_deviation&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;05&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;NumberOfCandidateDevices&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;DeviceEvaluatorList&lt;/span&gt; &amp;#61;&lt;span class=\"hljs-meta\"&gt; []&lt;/span&gt;\n\n&lt;span class=\"hljs-attribute\"&gt;DeviceEvaluatorList&lt;/span&gt;.append(Device1_deviation)\n&lt;span class=\"hljs-attribute\"&gt;DeviceEvaluatorList&lt;/span&gt;.append(Device2_deviation)\n&lt;span class=\"hljs-attribute\"&gt;DeviceEvaluatorList&lt;/span&gt;.append(Device3_deviation)\n&lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt; &amp;#61; np.empty((NumberOfCandidateDevices, NumberOfCandidateDevices))\n&lt;span class=\"hljs-attribute\"&gt;for&lt;/span&gt; i in range(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, NumberOfCandidateDevices &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;):\n    &lt;span class=\"hljs-attribute\"&gt;for&lt;/span&gt; j in range(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, NumberOfCandidateDevices &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;):\n        &lt;span class=\"hljs-attribute\"&gt;a&lt;/span&gt; &amp;#61; DeviceEvaluatorList[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n        &lt;span class=\"hljs-attribute\"&gt;b&lt;/span&gt; &amp;#61; DeviceEvaluatorList[j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n        &lt;span class=\"hljs-attribute\"&gt;if&lt;/span&gt; a &amp;lt; b:\n            &lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n        &lt;span class=\"hljs-attribute\"&gt;if&lt;/span&gt; a &amp;#61;&amp;#61; b:\n            &lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;\n        &lt;span class=\"hljs-attribute\"&gt;if&lt;/span&gt; a &amp;gt; b:\n            &lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;print&lt;/span&gt;(B)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["python 矩阵运算出问题", ["NumberOfCandidateDevices = 3", "python矩阵运算出问题。 按照代码逻辑， 应该会得到这样的矩阵", "\n", "\n", "#Evaluator1 - Repeatability", "\n", "#Deviation", "\n", "Device1_deviation", " = ", "0", ".", "06", " - ", "0", ".", "05", "\n", "Device2_deviation", " = ", "0", ".", "06", " - ", "0", ".", "05", "\n", "Device3_deviation", " = ", "0", ".", "3", " - ", "0", ".", "05", "\n\n", "DeviceEvaluatorList", " =", " []", "\n", "DeviceEvaluatorList", ".append(Device1_deviation)\n", "DeviceEvaluatorList", ".append(Device2_deviation)\n", "DeviceEvaluatorList", ".append(Device3_deviation)\n", "B", " =np.empty((NumberOfCandidateDevices,NumberOfCandidateDevices))\n", "for", " i in range(", "1", ", NumberOfCandidateDevices+", "1", "):\n    ", "for", " j in range(", "1", ", NumberOfCandidateDevices+", "1", "):\n        ", "a", " = DeviceEvaluatorList[i-", "1", "]\n        ", "b", " = DeviceEvaluatorList[j-", "1", "]\n        ", "if", " a < b:\n            ", "B", "[i-", "1", ",j-", "1", "] = ", "0", ".", "6", "\n        ", "if", " a == b:\n            ", "B", "[i-", "1", ",j-", "1", "] = ", "0", ".", "5", "\n        ", "else", ":\n            ", "B", "[i-", "1", ",j-", "1", "] = ", "0", "\n", "B", "\n", "\n", "但是实际运算出的矩阵如下。即最右边前两行应该为1，但是算出来却为0. 可否解释下原因，并修正下代码", "\n", "\n", "除此之外想把生成 的B 转换成矩阵，如何操作？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你是说怎么用一段二进&amp;#43;二段二进 得到三段二进&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["NEC红外段码算法分析", ["外接显示器通讯数据，以NEC红外编码形式传输，对第三段数据码变化运算方法非常困惑不得其解，望解惑，谢谢。", "\n", "\n", "\n", "\n", "问题相关代码，请勿粘贴截图", "\n", "波形一共有五个字节数据，引导码后第一段为温度编号；第二段为状态指示；第三段一般固定是8个0；第四段可能是验证码或者数据码；第五段不知道是什么作用，固定全0xff可以正常通讯。", "\n", "在第一段不变的情况下，第二段有变化，第四段编码不知是以那种运算方式得到的。", "\n", "直接使用列表内数据发送方波显示器可以正常显示温度，", "\n", "我想要达到的结果，通过前两段数据得到第三段数据得逻辑运算方式。第一次提问，有不对或者错误的地方，还请海涵，感谢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;前面只有一个%d&amp;#xff0c;对应后面第一个变量即a&amp;#61;a&amp;#43;1,也就是5&lt;/p&gt;\n&lt;p&gt;这样则会输出 5 9 6&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,b&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d&amp;#34;&lt;/span&gt;,a&amp;#61;a&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,b&amp;#43;a,b&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["请大家看看这个程序的运算逻辑是什么", ["为什么这个程序输出结果是5,这个里面的知识点和逗号运算符有关吗（a＝a＋1,b＋a,b＋1）和a＝a＋1,b＋a,b＋1的结果为什么不一样"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;跟顺序有关系&amp;#xff0c;and左边如果为假&amp;#xff0c;就不再计算右边的表达式&amp;#xff0c;即使右边的表达式可能会抛异常。如果左边的表达式为真才会计算右边的表达式&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["python  逻辑运算符and两边的语句的顺序问题", ["最近用python写了一个堆排序的代码，在向下调整的过程中发现了一个问题", "\n\n", "\n\n", "if语句中形如上图它的结果是正确的", "\n\n", " ", "\n\n", "\n\n", "但是，如果将and两边的语句变换一下位置，结果显示超出列表索引位置。", "\n\n", "我想问一下，and 的两边的判断对于语句顺序有关吗？", "\n\n", "这句代码是堆向下调整过程中，首先判断两个孩子节点哪个大，然后大的子节点取代根结点。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;大兄弟&amp;#xff0c;你这个就复杂了&amp;#xff0c;&amp;#xff08;a&amp;#43;&amp;#43; , b&amp;gt;a&amp;#43;&amp;#43;&amp;amp;&amp;amp;c&amp;gt;d&amp;#xff09;这个计算结果在不同的编译平台有所区别&amp;#xff0c;不同平台对C语言定义的后加加处理方法有所不同&amp;#xff0c;比如&amp;#xff1a;一种是在这条语句结束时&amp;#xff0c;才返回后加加的结果&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                                 另一种是&amp;#xff0c;在一条语句中&amp;#xff0c;同一个变量两次后加加&amp;#xff0c;第二次后加加&amp;#xff0c;就会在前一个后加加的基础上运算&amp;#xff0c;如&amp;#xff1a;&lt;/span&gt;&lt;br /&gt;int a &amp;#61; 0;&lt;br /&gt;t &amp;#61; a&amp;#43;&amp;#43; &amp;#43; a&amp;#43;&amp;#43;;&lt;br /&gt;t &amp;#61; 0 &amp;#43; 1;&lt;br /&gt;好了&amp;#xff0c;就这样吧&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["请问这段代码是如何运算的", ["“（a++ , b>a++&&c>d) ? ++d：a<b”得值为什么?", "初学是遇到的一个题目，自己写到环境跑了一遍知道结果为0，也能看懂递增比较和三目运算符部分，但是不知道（a++，b>a++&&c>d）是如何和后面的部分进行比较的，或者说不太理解（a++，b>a++&&c>d）算得逻辑步骤，希望有人能给我详细解释下每一步运算的逻辑是什么样的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这个目录下确实没有那个py文件啊&amp;#xff0c;而且你竟然把自己写的python代码放到了python的安装路径下&amp;#xff0c;搞不好会出问题的&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["Python好好的突然跑不了，显示找不到文件，如何解决？(开发工具-pycharm)", ["编辑语言：Python", "开发工具：pycharm社区版", "本来好好的，从E盘复制了一个. py文件到Python的文件夹里，跑了一下显示找不到文件（代码里没有打开文件累的指令，只有一些简单的逻辑运算）连带着之前能跑的其他文件也提示找不到文件。配图如下：", "\n"]], "Tag": "程序设计"}
{"Answer": "公众号菜单参考：http://www.2cto.com/weixin/201610/555273.html\r\n小程序参考：http://www.tuicool.com/articles/ZnEjQb3", "Konwledge_Point": "逻辑运算", "Question": ["关于微信H5开发的基础问题", ["现在我有一个微信公众号，只能文字交互。但是看了一些公众号都是通过点击下面的菜单后跳转到内置浏览器中显示h5内容。请问这个h5内容背后的逻辑运算应该怎么写？", "\n也就是说，比如我有个微信H5中的按钮“显示”，点击之后要从我的网易云服务中的数据库里获取信息显示，这个按钮跟着的url是什么？"]], "Tag": "程序设计"}
{"Answer": "这种一般是你运算数据太耗时了，优化下你的逻辑跟算法（优先优化逻辑）", "Konwledge_Point": "逻辑运算", "Question": ["Java做socket实时接收数据存入数据库不及时？", ["\n", "应公司业务做了一个基于socket的实时接收数据的功能，就是我java后端写了一个服务端是基于UDP协议的，实时接收客服端发来的数据，对数据进行处理存入数据库。", "\n", "      目前的客户端发来的数据比较快，一秒能有10个包发过来，每个包的数据也不大，挺小的，但就是我在处理这些数据的时候写的逻辑运算比较多，造成了目前存入数据库时不能达到所谓的实时更新的效果", "\n", "      我说一下这个数据必须要在页面实时更新展示的", "\n", "补充一下：是开启多个客户端同时向服务端发送数据的，就比如目前有三个客户端对服务端同时发送数据（同一个端口），就会出现数据存入数据库不及时，但数据是已经接收到了（我在控制台打印看到了，只是没有及时存到数据库）", "\n", "如果只是一个客户端向数据库发送数据就可以达到理想化的实时存入数据库然后在页面实时展现数据，多个就不行了", "\n", "  想问下各位大佬，是程序运行的太慢了，还是什么原因呢？我也做了开启多线程执行程序了啊", "\n", "public String startDs() {\n        DatagramSocket socket = null;\n        try {\n            socket = new DatagramSocket(8800);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n        //记录客户端的数量\n        int count = 0;\n        while (true) {\n            data = new byte[16];// 创建字节数组，指定接收的数据包的大小\n            packet = new DatagramPacket(data, data.length);\n            try {\n                socket.receive(packet);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } // 此方法在接收到数据报之前会一直阻塞\n            Thread thread = new Thread(new UDPThread(socket, packet));\n            thread.start();\n\n        }\n    }\n"]], "Tag": "程序设计"}
{"Answer": "直接把这个网页保存下来不就好了.............................", "Konwledge_Point": "逻辑运算", "Question": ["使用ant下载时的几点问题，请教！", ["在使用ant进行FTP下载时（使用FTP Task），能否在ant的xml文件中指定编码方式吗，在上传和下载时能识别中文而不至于出现乱码？能否在ant中使用类似异常的东西，能否进行日期的匹配，能否得到星期数，能否进行数学运算和逻辑运算？", "\n    那么在ant的FTP task中能否进行对远程FTP主机上某个文件夹的存在性验证？如何来统计下载的文件数呢？", "\n\n", "如果能，请说明下！谢谢！\n\n<get>如何来做FTP下载呢？\n", "\n\n", "[b]问题补充：[/b]", "\n你是不是看准了挣我这十分呢？？？", "\n    自己编写任务，貌似我还没这能力。", "\n\n", "有没有ant的使用手册之类的东西么？！\n", "\n\n", "[b]问题补充：[/b]", "\n有没有能下载看的呢？？我这里不适宜长期在线看！", "\n[b]问题补充：[/b]", "\n领导进来了，把我吓坏了！这个只是一个页面，你的意思不会是叫我把所有都保存了吧！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;SQR(k&amp;#43;m)/SQR(k&amp;#43;m) &amp;#61; k&amp;#43; m*k&amp;#43;m/k&amp;#43;m*k&amp;#43;m &amp;#61; 2&amp;#43;1*2&amp;#43;1/2&amp;#43;1*2&amp;#43;1 &amp;#61; 2&amp;#43;2&amp;#43;0&amp;#43;2&amp;#43;1 &amp;#61; 7&lt;br /&gt;a &amp;#61; a/7 &amp;#61; 2&lt;br /&gt;这个宏定义语法上没问题, 但是以后工作这么写宏定义你要被扣不少工资, 必须写成下面这样&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-C&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-selector-id\"&gt;#define&lt;/span&gt; SQR(X) ((X)*(X))\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["26. 以下程序的输出结果是为啥是2！不太明白其中的逻辑，希望有一个详细的运算逻辑图", ["以下程序的输出结果是 ()", "A) 16 B) 2 C) 9 D) 1", "#define SQR(X) X*X", "main()", "{ int a=16, k=2, m=1;", "a/=SQR(k+m)/SQR(k+m);", "printf(“%d\\n”,a);　}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;以5中取3为例&amp;#xff1a;5中取3余下的就是5中取2&amp;#xff0c;因此5中取3和5中取2结果相同&amp;#xff0c;故可取其小者以便简化计算&amp;#xff1b;5中取2的结果是&amp;#xff08;5×4&amp;#xff09;/&amp;#xff08;2×1&amp;#xff09;。题主的代码不够严谨&amp;#xff0c;我修改了一下&amp;#xff0c;加了注释&amp;#xff0c;仅供参考。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;def&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;cni2&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;n, i&lt;/span&gt;):\n    &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&amp;#34;返回n中取i的组合数&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;\n    minNI &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(i, n-i) &lt;span class=\"hljs-comment\"&gt;# n中取i和n中取n-i结果数相同&amp;#xff0c;因此可取其小者计算&lt;/span&gt;\n    result &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;#结果赋初值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;range&lt;/span&gt;(minNI): &lt;span class=\"hljs-comment\"&gt;# 1到n的自然数中&amp;#xff0c;最大的minNI个数字乘积除以最小的minNI个数字乘积&lt;/span&gt;\n        result *&amp;#61; (n-j)/(minNI-j)\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;round&lt;/span&gt;(result)) &lt;span class=\"hljs-comment\"&gt;# 返回四舍五入后取整的结果&lt;/span&gt;\n\ncni2(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\n&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;\ncni2(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\n&lt;span class=\"hljs-number\"&gt;210&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["浮点数运算误差的不理解", ["\n", "第一张图是习题，第二张图是输出出来的，下面是正确的", "#coding=UTF-8", "\n", "def cni2(n, i):", "    minNI = min(i, n-i)", "    result = 1", "    for j in range(0, minNI):", "        result = result * (n-j) / (minNI-j)", "    return result", "print(int(cni2(5, 2)))", "我的问题就是不明白整个代码是什么意思，不知道里边的数学逻辑（但是知道组合的计算原理），就是看不懂代码，看不懂每个函数的意思，尤其是倒数第三行，谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;pdata 是 从head地址开始找到的第一个空格的地址&lt;br /&gt;pdata-head 就是pdata与head两个地址相对的字符距离。&lt;br /&gt;至于为什么是等于1要看你输入的内容了&lt;/p&gt;\n&lt;p&gt;比如你输入的内容是&amp;#xff1a;a bcd ef&lt;br /&gt;head一开始指向a的地址&lt;br /&gt;pdata 就是从a地址处开始找到的第一个空格的地址&lt;br /&gt;pdata-head 就是a与空格之间的字符距离。len就是1&lt;br /&gt;之后第二个红框是让head右移 len&amp;#43;一个空格的字符长度(也就是1)的字符数距离&amp;#xff0c;使head指向b的地址。&lt;br /&gt;下一次循环&amp;#xff0c;pdata是从b地址处开始找到的第一个空格的地址&amp;#xff08;d之后的空格&amp;#xff09;&lt;br /&gt;pdata-head 就是b与空格之间的字符距离。len就是3了&lt;br /&gt;&lt;strong&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢!&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["C语言数组指针运算，字符串提取", ["这些代码的意思是我输入一组字符串，中间用空格隔开，然后提取字符串", "\n", "然后红色框的两句话我不大明白。", "为什么int len=pdata-head;len是等于1呢", "我的认为是len是计算出差的是几一位，然后第二个红框是逻辑左移", "求大神指点迷津"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我对你代码不能运行的地方都标记了注释&amp;#xff0c;主要两个问题&amp;#xff1a;前后变量不一致、使用变量函数没有先声明。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MaxSize 50&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ElemType;&lt;span class=\"hljs-comment\"&gt;//你写成了ElmeType&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    ElemType data[MaxSize];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length;\n}SqList;\n&lt;span class=\"hljs-comment\"&gt;//先把ListLength函数都声明一遍&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//因为DispList要调用&amp;#xff0c;但是没办法调用后声明的ListLength&amp;#xff0c;所以这里先声明&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ListLength&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList *L)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;LnitList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList *&amp;amp;L)&lt;/span&gt;\n&lt;/span&gt;{\n    L &amp;#61; (SqList*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(SqList));&lt;span class=\"hljs-comment\"&gt;//SqList大小写&lt;/span&gt;\n    L-&amp;gt;length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//length大小写&lt;/span&gt;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreateList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList *&amp;amp;L, ElemType a[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    L &amp;#61; (SqList*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(SqList));&lt;span class=\"hljs-comment\"&gt;//SqList大小写&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        L-&amp;gt;data[i] &amp;#61; a[i];\n    L-&amp;gt;length &amp;#61; n;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DispList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList *L)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;ListLength&lt;/span&gt;(L)&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;//你都没写ListEmpty(L)函数&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L-&amp;gt;length; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, L-&amp;gt;data[i]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ListLength&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList *L)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;(L-&amp;gt;length);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;GetElem&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList  *L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, ElemType &amp;amp;e)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i&amp;lt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || i&amp;gt;L-&amp;gt;length)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    e &amp;#61; L-&amp;gt;data[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//不是ture&lt;/span&gt;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;LocateElem&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqList *L, ElemType e)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (i &amp;lt; L-&amp;gt;length&amp;amp;&amp;amp;L-&amp;gt;data[i] !&amp;#61; e)&lt;span class=\"hljs-comment\"&gt;//不是L-&amp;gt;length-&amp;gt;data[i]&lt;/span&gt;\n        i&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;gt;&amp;#61; L-&amp;gt;length)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    SqList*L;&lt;span class=\"hljs-comment\"&gt;//SqList大小写&lt;/span&gt;\n    ElemType a[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, n &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入10个字符:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, &amp;amp;a[i]);\n    &lt;span class=\"hljs-built_in\"&gt;LnitList&lt;/span&gt;(L);\n    &lt;span class=\"hljs-built_in\"&gt;CreateList&lt;/span&gt;(L, a, n);\n    &lt;span class=\"hljs-built_in\"&gt;DispList&lt;/span&gt;(L);\n    &lt;span class=\"hljs-built_in\"&gt;ListLength&lt;/span&gt;(L);\n    ElemType e;&lt;span class=\"hljs-comment\"&gt;//先声明才能用e&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;GetElem&lt;/span&gt;(L, i, e);\n    &lt;span class=\"hljs-built_in\"&gt;LocateElem&lt;/span&gt;(L, e);\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["线性表基本运算实现不知哪里错了", ["求解答，为啥运行不得", "\n", "\n```c++\n ", "//定义头文件", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<malloc.h>", "\n", "//定义全局变量", "\n", "#", "define", " MaxSize 50", "\n", "//定义元素类型", "\n", "typedef", " ", "char", " ElmeType\n", "//定义顺序表的结构体", "\n", "typedef", " ", "struct", "\n{\n    ElemType data[MaxSize];\n    ", "int", " length;\n}SqList;\n", "//初始化线性表", "\n", "void", " ", "LnitList", "(SqList *&L)", "\n", "{\n   ", "//动态分配空间", "\n    L=(SqList*)", "malloc", "(", "sizeof", "(Sqlist));\n    ", "//线性表（顺序表）的长度为0", "\n    L->Length=", "0", ";\n}\n\n", "//创建顺序表", "\n", "void", " ", "CreateList", "(SqList *&L,ElemType a[],", "int", " n)", "\n", "{\n    ", "int", " i;\n", "//分配存放线性表的空间", "\n    L=(Sqlist*)", "malloc", "(", "sizeof", "(Sqlist));\n", "//把a数组中的元素依次放置到线性表的data[]", "\n    ", "for", "(i=", "0", ";i<n;i++)\n        L->data[i]=a[i];\n", "//设置线性表的长度", "\n    L->length=n;\n}\n", "//输出顺序表", "\n", "void", " ", "DispList", "(SqList *L)", "\n", "{\n", "//判断线性表是否为空", "\n    ", "if", "(", "ListEmpty", "(L))\n        ", "return", ";\n    ", "//依次输出线性表的内容", "\n    ", "for", "(", "int", " i=", "0", ";i<L->length;i++)\n        ", "printf", "(", "\"%d\"", ",L->data[i]);\n    ", "printf", "(", "\"\\n\"", ");\n}\n", "//求线性表的长度", "\n", "int", " ", "ListLength", "(SqList *L)", "\n", "{\n    ", "return", "(L->length);\n}\n\n", "//求线性表第i个数据元素值，并存放在变量e中", "\n", "int", " ", "GetElem", "(SqList  *L,", "int", " i,ElemType &e)", "\n", "{\n", "//判断i是否合理", "\n    ", "if", "(i<", "1", "||i>L->length)\n        ", "return", " ", "false", ";\n", "//把元素赋值给e", "\n    e=L->data[i", "-1", "];\n    ", "return", " ture;\n}\n\n", "//按元素值查找,若查找不成功，返回0，否则返回该元素的逻辑位序", "\n", "int", " ", "LocateElem", "(SqList *L, ElemType e)", "\n", "{\n    ", "int", " i=", "0", ";\n   ", "//扫描数组元素，i++", "\n    ", "while", "(i<L->length->dada[i]!=e)\n        i++;\n", "//若i>L->length,则查找不成功，返回0，否则返回该元素的逻辑位序", "\n    ", "if", "(i>=L->length)\n        ", "return", " ", "0", ";\n    ", "else", "\n        ", "return", " i+", "1", ";\n}\n", "//main函数", "\n", "void", " ", "main", "()", "\n", "{\n    Sqlist*L;\n    ElemType a[", "10", "];\n    ", "int", " i,n=", "10", ";\n    ", "printf", "(", "\"请输入10个字符:\\n\"", ");\n    ", "for", "(i=", "0", ";i<", "10", ";i++)\n        ", "scanf", "(", "\"%c\"", ",&a[i]);\n    ", "//调用InitList（）初始化线性表", "\n    ", "Lnitlist", "(L);\n", "//调用CreateList()建立线性表", "\n    ", "CreateList", "(L,a,n);\n    ", "//调用DispList()输出线性表", "\n    ", "DispList", "(L);\n", "//调用ListLength ()求线性表的长度", "\n    ", "ListLength", "(L);\n", "//调用GetElem ()找线性表第i个元素", "\n    ", "GetElem", "(L,i,e);\n", "//调用LocateElem ()查找线性表中是否存在所给元素", "\n    ", "LocateElem", "(L,e);\n}\n\n\n\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "条件运算符啊 大兄弟 \r\n 如果 a%2==1 成立 那么执行 (a+1)/2  如果不成立执行 a/2", "Konwledge_Point": "逻辑运算", "Question": ["一道java题，有些小细节不太确定，求帮助", ["\n反正我基本没在运算式里用过问号和冒号，它们分别代表啥意思，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-attribute\"&gt;if&lt;/span&gt; start.day&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; or start.weekday()&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个是 比较&lt;br /&gt;start.day 为 1   或者   start.weekday() 为 0&lt;br /&gt;结果为 8879&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-attribute\"&gt;if&lt;/span&gt; (start.day&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) | (start.weekday()&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;):\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果为 8879&lt;/p&gt;\n&lt;hr /&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; start.&lt;span class=\"hljs-built_in\"&gt;day&lt;/span&gt;&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; | start.&lt;span class=\"hljs-built_in\"&gt;weekday&lt;/span&gt;()&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n或者可以解读为&amp;#xff1a;\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; start.&lt;span class=\"hljs-built_in\"&gt;day&lt;/span&gt;&amp;#61;&amp;#61; &amp;#xff08;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; | start.&lt;span class=\"hljs-built_in\"&gt;weekday&lt;/span&gt;() &amp;#xff09;&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为 | 有优先权。结果变成&amp;#xff1a;&lt;br /&gt;start.day&amp;#61;&amp;#61; &amp;#xff08;1 | start.weekday() &amp;#xff09;&amp;#61;&amp;#61;0&lt;br /&gt;start.day&amp;#61;&amp;#61;  true &amp;#61;&amp;#61;0&lt;br /&gt;而答案永远都是否。&lt;br /&gt;7580 刚好是 2000,1,1 -- 2020,10,1 &amp;#xff08;包含开始和结束日期&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["python使用逻辑运算符和位运算符结果不同", ["问题：", "\n", "\n", "两次的运算结果为什么不一样？第二个是正确答案", "\n", "import datetime\n", "sum", "=", "0", "\n", "start", "=datetime.", "date", "(", "2000", ",", "1", ",", "1", ")\n", "end", "=datetime.", "date", "(", "2020", ",", "10", ",", "1", ")\ndays=datetime.timedelta(days=", "1", ")\n", "while", "(", "start", "<=", "end", "):\n    ", "if", " ", "start", ".day==", "1", " | ", "start", ".weekday()==", "0", ":\n        ", "sum", "+=", "2", "\n    ", "else", ":\n        ", "sum", "+=", "1", "\n    ", "start", "+=days\nprint(", "sum", "）\n", "\n", "\n", "\nimport datetime\n", "sum", "=", "0", "\n", "start", "=datetime.", "date", "(", "2000", ",", "1", ",", "1", ")\n", "end", "=datetime.", "date", "(", "2020", ",", "10", ",", "1", ")\ndays=datetime.timedelta(days=", "1", ")\n", "while", "(", "start", "<=", "end", "):\n    ", "if", " ", "start", ".day == ", "1", " ", "or", " ", "start", ".weekday() == ", "0", ":\n        ", "sum", "+=", "2", "\n    ", "else", ":\n        ", "sum", "+=", "1", "\n    ", "start", "+=days\nprint(", "sum", ")\n", "\n", "\n", "如果对第一个代码加上括号也能得到答案，这是为什么？", "\n", "import datetime\n", "sum", "=", "0", "\n", "start", "=datetime.", "date", "(", "2000", ",", "1", ",", "1", ")\n", "end", "=datetime.", "date", "(", "2020", ",", "10", ",", "1", ")\ndays=datetime.timedelta(days=", "1", ")\n", "while", "(", "start", "<=", "end", "):\n    ", "if", " (", "start", ".day==", "1", ") | (", "start", ".weekday()==", "0", "):\n        ", "sum", "+=", "2", "\n    ", "else", ":\n        ", "sum", "+=", "1", "\n    ", "start", "+=days\nprint(", "sum", "）\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;拿你的程序为例&lt;br /&gt;if(m&amp;#43;&amp;#43; &amp;gt; 5)&amp;#xff0c;执行顺序是先判断当前m &amp;gt; 5&amp;#xff0c;再m&amp;#61;m&amp;#43;1&amp;#xff0c;执行完毕&lt;br /&gt;printf( &amp;#34;%d\\n&amp;#34;,m--)&amp;#xff0c;执行顺序是先把m用%d打印出来&amp;#xff0c;再m&amp;#61;m-1&amp;#xff0c;执行完毕&lt;/p&gt;\n&lt;p&gt;就这样理解&amp;#xff0c;什么运算符在前面&amp;#xff0c;就先执行它相应的动作&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["m++,m--，自增自减运算怎么理解", ["自增自减语句的（m++）与（m--）的逻辑是什么 怎么理解，（简单明了），谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;逻辑或的左操作数为真&amp;#xff0c;右边是不会运算的&amp;#xff0c;不管右边的表达式中运算符的优先级有多高&amp;#xff0c;都不会运算&amp;#xff0c;因为整个表达式的结果已经确定。&lt;br /&gt;如果(&amp;#43;&amp;#43;a || &amp;#43;&amp;#43;b) &amp;amp;&amp;amp; &amp;#43;&amp;#43;c&amp;#xff0c;结果就是2、1、2。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑运算符的特殊规则(第35题）", ["求解逻辑运算符时，如果根据逻辑可以不需要计算后面的算数。", "算a后a==2，又是或逻辑，故不需算b，b==1，前面整个就为1，后面是和逻辑，所以应该要算c，来确定c是否为0。若为0，则为0；若不为0，则为1。(该题无要求）但是c要运算，故c要为2呀。答案就是2，1，2🤔🤔"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的解释不完全正确&amp;#xff0c;错在 这里的解释 &amp;#xff08;a&amp;#43;&amp;#43; || b--&amp;#xff09;&lt;br /&gt;计算&amp;#xff08;a&amp;#43;&amp;#43; || b--&amp;#xff09;时&amp;#xff0c;  ||前 的数 &amp;gt;&amp;#61;1 时&amp;#xff0c;就不计算 ||右边的那个数 &amp;#xff0c;因此  b--没有参与运算&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑与 逻辑或 c = a++ || b-- && c;为啥b不自减", ["\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a = ", "1", ", b = ", "1", ", c = ", "0", ";\n    c = a++ || b-- && c;\n    ", "printf", "(", "\"%d\\n\"", ", b);\n    ", "return", " ", "0", ";\n}\n", "\n", "如代码，    看我这样认为对不对", "c = a++ || b-- && c;", "c=（a++ || b--）&& c；", "c=1 && c；", "也就是说&&前面的部分已经运算了，b--不应该运算结束了吗", "我的问题是： b--为啥不运算？", "为什么", "    c = a++ && b-- && c;//b=0", "    c = a++ || b-- && c;//b=1"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;根据运算的优先级&amp;#xff0c;等式会先计算括号内的内容&lt;br /&gt;而括号里3&amp;gt;4会返回False&amp;#xff0c;而False对应的int型数据是0&lt;br /&gt;所以c&amp;#61;0&amp;#43;1&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于#python#的问题：它暗含什么知识点", ["\n", "c=(3>4)+1__", "  运算逻辑是什么，为什么就等于1 ？", "\n", "\n", "\n", "c", "=(", "3", ">", "4", ")+", "1", "\n", "print", "(c)\n", "\n", "它暗含什么知识点，运算逻辑是什么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;该回答引用GPTᴼᴾᴱᴺᴬᴵ&lt;br /&gt;这里的位运算逻辑是将命令号左移1位&amp;#xff08;相当于乘以2&amp;#xff09;然后与0按位或运算。这样做的目的是将命令号的最后一位用作一个标志位&amp;#xff0c;表示是否需要等待服务器的回应。如果等待回应&amp;#xff0c;标志位就是1&amp;#xff0c;否则是0。这样通过位运算合并参数&amp;#xff0c;就可以在发送命令时将等待回应的标志位一并传递给服务器。在自定义消息响应函数中&amp;#xff0c;使用位运算将参数还原&amp;#xff0c;并根据命令号执行相应的操作。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["这个MFC自定义消息映射函数的逻辑是什么？", ["今天读到一个自定义消息函数修改发包命令,下载文件的命令号是4， 没太看懂此处用位运算的逻辑。“4 << 1 | 0”", "\n", "\n", "//int ret = SendCommandPacket(4, false, (BYTE*)(LPCTSTR)strFile, strFile.GetLength());    //修改前", "\n    ", "int", " ret = SendMessageA(WM_SEND_PACKET, ", "4", " << ", "1", " | ", "0", ", (", "LPARAM", ")(LPCSTR)strFile)", ";   //用自定义消息函数发送下载文件命令", "\n......\n\n", "#", "define", " WM_SEND_PACKET (WM_USER + ", "1", ") ", "\n", "//自定义消息响应函数", "\n", "/*用位运算合并参数*/", "\n\nLRESULT CRemoteControlClientDlg::OnSendPacket(", "WPARAM", " ", "wParam", ", ", "LPARAM", " ", "lParam", ")\n{\n    ", "int", " ret = ", "0", ";", "\n    ", "int", " cmd = ", "wParam", " >> ", "1", ";", "\n    ", "switch", " (cmd) \n    {\n", "case", " ", "4", ": ", "//下载文件", "\n    {\n        CString strFile = (LPCTSTR)", "lParam", ";", "\n        ret = SendCommandPacket(cmd, ", "wParam", " & ", "1", ",\n            (BYTE*)(LPCTSTR)strFile, strFile.GetLength())", ";", "\n    }\n            ", "break", ";", "\n    ", "case", " ", "6", ":", "//截取屏幕", "\n    {\n        ret = SendCommandPacket(cmd, ", "wParam", " & ", "1", ")", ";", "\n    }\n            ", "break", ";", "\n    ", "default", ":\n        ret = ", "-1", ";", "\n    }\n    ", "return", " ret", ";", "\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、使用&lt;code class=\"language-javascript\"&gt;scanf_s()&lt;/code&gt;函数如果从键盘输入的参数中有字符&amp;#xff0c;或者字符串的话&amp;#xff0c;需要在函数中该参数位置后加上字符个数&amp;#xff0c;&lt;br /&gt;应当为: scanf_s(&amp;#34;%f%c%f&amp;#34;, &amp;amp;a, &amp;amp;c,&lt;code class=\"language-javascript\"&gt;1,&lt;/code&gt;&amp;amp;b);&lt;br /&gt;2、由于scanf_s()函数一次要从键盘读取多个参数&amp;#xff0c;因此&amp;#xff0c;在键盘输入参数的时候&amp;#xff0c;每输入一个参数&amp;#xff0c;都应该按一下回车&amp;#xff0c;或这输入&lt;code class=\"language-javascript\"&gt;,&lt;/code&gt;将参数隔开&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["c语言 switch函数 为啥没有结果", ["是我少什么东西了吗 感觉逻辑上好似没啥错误但是他却没有运算结果 是scanf的问题吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好同学&amp;#xff1b;&lt;br /&gt;这个意思就是说把矩阵P横竖均匀划分成大小为s(j)×s(j)的若干个方块矩阵&amp;#xff08;方块矩阵个数是Grid_num(j)×Grid_num(j)&amp;#xff09;。&lt;br /&gt;然后对每个方块矩阵求最大值和最小值&amp;#xff0c;然后都除以h(j)后&amp;#xff0c;向上取整&amp;#xff0c;再相减&amp;#xff0c;最后加1&amp;#xff0c;得到一个数&amp;#xff1b;&lt;br /&gt;然后每个方块都返回这么个数&amp;#xff0c;Grid_num(j)×Grid_num(j)个方块返回Grid_num(j)×Grid_num(j)个数&amp;#xff0c;也就是一个Grid_num(j)×Grid_num(j)的矩阵&amp;#xff1b;&lt;br /&gt;最后对这个矩阵求了两次sum&amp;#xff0c;即得到矩阵上所有元素的和&amp;#xff0c;也就是Nr(j)&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["逻辑问题，不知道这个算法是什么意思", ["for j = 1:length(s)", "    L =  s(j)*ones(1,Grid_num(j));", "    Nr(j) = sum(sum( cellfun(", "@(x) ", "ceil(max(x(:))/h(j))-ceil(min(x(:))/h(j)) + 1,mat2cell(P,L,L)) ));", "end", "我想问一下这个怎么运算的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运算符优先级问题&amp;#xff0c;单目&amp;#xff08;&amp;#xff01;&amp;#xff09;大于 算数运算&amp;#xff08;-&amp;#xff09; 大于 关系运算符&amp;#xff08;&amp;gt;&amp;#xff09; 大于 逻辑运算符&amp;#xff08;&amp;amp;&amp;amp;&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["关于c语言的问题，请各位专家解答！", ["5>3&&8<4-!0的逻辑值为什么为0，运算过程是什么样子的？"]], "Tag": "程序设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;&amp;amp; 是一个按位运算符&amp;#xff0c;按位比较每个操作数。它是一个二进制 AND 运算符&amp;#xff0c;如果它存在于两个操作数中&amp;#xff0c;则将其复制到结果中。 ... 而 &amp;amp;&amp;amp; 是逻辑 AND 运算符&amp;#xff0c;对布尔操作数进行操作。如果两个操作数都为真&amp;#xff0c;则条件为真&amp;#xff0c;否则为假。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;说人话&amp;#xff0c;举个例子&lt;/p&gt;\n&lt;p&gt;如果要判断 &lt;code class=\"language-javascript\"&gt;input&lt;/code&gt; 是否为奇数&amp;#xff0c;可以使用 &lt;code class=\"language-javascript\"&gt;&amp;amp;&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;if (input &lt;span class=\"hljs-meta\"&gt;&amp;amp; 1) { ... }&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为如果 &lt;code class=\"language-javascript\"&gt;input&lt;/code&gt; 为奇数&amp;#xff0c;其二进制的末尾必定为 1&amp;#xff0c;与 1 进行 AND 位运算&amp;#xff0c;如果 &lt;code class=\"language-javascript\"&gt;input&lt;/code&gt; 是奇数则运算结果为 1&amp;#xff0c;偶数则 0。&lt;/p&gt;\n&lt;p&gt;如果把上面代码改成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;input&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;&amp;amp;&amp;amp;&lt;/span&gt; 1) { ... }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对于 C&amp;#xff08;和大部分编程语言&amp;#xff09;&amp;#xff0c;非零对象都表示 True&amp;#xff0c;那么只要 &lt;code class=\"language-javascript\"&gt;input&lt;/code&gt; 不等于 0&amp;#xff0c;这个表达式都成立&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["说说&和&&的区别？", ["&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这题好像跟优先级关系不大&lt;br /&gt;||符号 如果||前面已经是 真 那么后面不会做 直接跳过&lt;br /&gt;&amp;amp;&amp;amp;符号 如果&amp;amp;&amp;amp;前面为假  那么后面也不会再做 直接跳过&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["想要明白优先级的一些问题", ["为什么不是选1，1啊，括号的优先级不是比逻辑或来得更高么?那不是应该先运算括号内的内容么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以用python自带的栈结构来模拟&amp;#xff0c;先进栈的后出&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;import queue\n&lt;span class=\"hljs-keyword\"&gt;res&lt;/span&gt; &amp;#61; queue.LifoQueue()\n&lt;span class=\"hljs-keyword\"&gt;N&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;())\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;N&lt;/span&gt;&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;res&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;put&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;N&lt;/span&gt;%&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;N&lt;/span&gt;//&amp;#61;&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;res&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;put&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;N&lt;/span&gt;)\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; not &lt;span class=\"hljs-keyword\"&gt;res&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;empty&lt;/span&gt;():\n    &lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;res&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;(),end&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#39;&lt;/span&gt;)\n&lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;()\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["栈——数据结构（python）", ["将一个十进制整数N转换为八进制数。", "环境：任一Python 3 解释器", "目的：掌握栈的逻辑结构、存储结构和相关运算", "该怎样运用Python语言编写代码进行实验呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.既然是纯属兴趣开发&amp;#xff0c;那就熟悉什么用什么。真正到了瓶颈再去考虑换吧。先把兴趣培养起来了&amp;#xff0c;才有足够的动力支撑你去进一步学习。&lt;br /&gt;2.可望而不可及是遗憾&amp;#xff0c;可望可及而又要忍着去学习有可能有帮助的另外一门语言是需要很大的毅力的&amp;#xff0c;也是残忍的&amp;#xff0c;这样的状态下真的能够学好这门语言吗&amp;#xff1f;说不定到你学好的时候&amp;#xff0c;你已经找到了你认为更有趣的东西。这对于你目前这个兴趣来说&amp;#xff0c;是失败的。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["业余时间想开发真正的人工智能，选哪个语言好？", ["业余时间兴趣开发，想开发一个真正意义上的", "人工智能", "，纯属民科。", "没有经验，从0开始，不过对于各种领域的专业知识都有了解和涉猎。不求成功，以享受过程为主。", "目前供选择的语言有：", "VBA，python，LISP，prolog，c++", "（PS：不是现在大数据机器学习那种“人工智能”，是真的人工智能。）", "\n", "VBA：", "优势：", " 1.工作原因比较熟悉，可以直奔AI主题。2.excel很方便，开发过程可以随时做原型测试，在excel中做观察。3.可以中文编写，注释少，好维护。", "不足：", " 1.担心后续会用到LISP和prolog，貌似不是很支持。2.可能运算效率会成为门槛。3.VBA的类用起来不方便，感觉相比c++天生残疾，而且类内部很难debug。", "\n", "python：", "优势：", " 1.人云亦云，主流。2.嫁接性貌似比较好，中途随时使用别的语言（比如当后面运算量大后，借力c++。逻辑处理方面借力lisp prolog）", "不足：", " 2.", "\n", "LISP：", "优势：", " 1.听说是AI的第一语言", "不足：", " unknow", "\n", "prolog：", "优势：", " 1.去了解了一下，后续AI逻辑思考方面的能力，还有拆解任务的能力，应该是用prolog方便很多。", "不足：", " unknow", "\n", "c++：", "优势：", " 1.小时候学过，有基础。2.类用起来特别爽。3.没有效率天花板", "不足：", " 2.综合考虑好像是最不合适的一个选择，很容易把精力和热情都消耗在写代码上了", "\n", "非常希望得到各路英雄好汉的帮助，赏金不够还可以加，期望得到有用且中肯的回答。", "补充一下，各位不要笑话我哈，业余爱好，纯属兴趣。我各方面的能力应该还算在线的，并不是无厘头恶搞。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;定义一个状态值&amp;#xff0c;在A算出值后赋值&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["求一个最佳解决方法！！！", ["需要根据类型进行相应的计算逻辑，其中有一个B类型的描述为：取A的数值，请问我该如何在A还未算出值之前不进行B值的运算，等待A的数值计算完成之后再将A的数值赋值给B"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;str &amp;#43;&amp;#61; 12&amp;#xff0c;会将12视为字符串&lt;br /&gt;str &amp;#43;&amp;#61; 12 &amp;#43; &amp;#39;1&amp;#39;;会先执行 12&amp;#43;&amp;#39;1&amp;#39;&amp;#xff0c;会将两个数当作整数计算。字符&amp;#39;1&amp;#39;的ASCII码是49&amp;#xff0c;加上12是61&amp;#xff0c;str&amp;#43;&amp;#61;61&amp;#xff0c;将61当作字符&amp;#xff0c;所以最终输出61&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["Java字符串相加遇到的问题", ["我想要的效果是121，但下面这个出来的结果是61；分开写（注释掉的部分），答案会是121.", "想问一下这个61是怎么出来的，它的运算逻辑是什么？", "\n", "public", " ", "class", " ", "draft", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args) {\n        ", "String", " ", "str", " = ", "\"\"", ";\n        ", "str", " += ", "12", " + ", "'1'", ";\n", "//        str += 12;", "\n", "//        str += '1';", "\n        System.", "out", ".", "println", "(", "str", ");\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "public static &lt;T extends Number&gt; double caculate(T a, T b) {\r\n\t\tdouble d = a.doubleValue() + b.doubleValue() + a.doubleValue() * b.doubleValue()\r\n\t\t\t\t+ a.doubleValue() / b.doubleValue();\r\n\t\treturn d;\r\n\t}", "Konwledge_Point": "逻辑运算", "Question": ["关于java泛型", ["鉴于描述原来的问题有点麻烦，我举个简单的例子", "\n假如我现在要计算两个数字A+B+A*B+A/B（这两个数字类型相同，但其类型可以是int,float,long,double等，或者要求它们是Integer,Float,Long,Double也可以）", "\n可以将计算方法封装到一个独立的类", "\n为了便于维护，我想只写一个运算逻辑，也就是A+B+A*B+A/B", "\n\n", "有阵子没碰java了，不知道这问题是我把原来的知识忘了，还是java那鸡肋的泛型本身的局限"]], "Tag": "程序设计"}
{"Answer": "[quote]开发人员还有一个理由就是数据库连接释放的问题，采用我的方法会比他的方法多“连接/释放”4n次，我们的应用服务器压力也很大，但我觉得这4n次是依次执行，应该不是太大问题，不过还是想问问。 [/quote]\r\n\r\n是的！ 数据库的链接是比较好资源的！\r\n但是 n&lt;1000  这个级别的 请放心  没问题的！\r\n从效率 和 资源上讲没什么大的区别\r\n我主要考虑的是 复杂的SQL 维护问题！ \r\n 他走了 谁给他收拾摊子呢？", "Konwledge_Point": "逻辑运算", "Question": ["解决同样问题，sql语句是用复杂而少量的好，还是简单多句的好", ["项目上要做一个定时任务，每10分钟执行一次，现在有两种意见，一种是使用复合查询语句，执行次数为n，但sql中包含in运算符；另一种是用简单查询，执行次数大概为5n（因为通过业务逻辑可以优化执行次数），并且每次只是做最简单的查询，这里面n最大不超过1000，并且这个任务对时间性能要求不高（也就是说延迟1、2分钟没人在意）开发人员想用第一种方法，部分原因是他比较喜欢复杂的sql语句；但我倾向于第二种方法，因为我们的数据库压力比较大，in运算可能带来意想不到的问题，另一个原因是代码好维护。现在想听听大家的意见。"]], "Tag": "程序设计"}
{"Answer": "```\r\n类似这样，没有调测，自己试试，针对是一对一，\r\n select mate_id,sd_price,sd_quantity+IFNULL(os_quantity,0)-IFNULL(is_quantity,0) quantity from temp_stock tsd left join temp_instore tin on tsd.mate_id=tin.mate_id and tsd.sd_price= tin.is_price\r\nleft join temp_outstore tos on tsd.mate_id=tos.mate_id and tsd.sd_price= tos.is_price\r\n\r\n如果temp_instore 、 temp_outstore 、 temp_stock是一对多，\r\nselect mate_id,sd_price, sum(quantity) quantity from(\r\nselect mate_id,sd_price,sd_quantity+IFNULL(os_quantity,0)-IFNULL(is_quantity,0) quantity from temp_stock tsd left join temp_instore tin on tsd.mate_id=tin.mate_id and tsd.sd_price= tin.is_price\r\nleft join temp_outstore tos on tsd.mate_id=tos.mate_id and tsd.sd_price= tos.is_price\r\n) group by mate_id,sd_price\r\n\r\n\r\n```", "Konwledge_Point": "逻辑运算", "Question": ["求助mysql查询语句，实现三张表数据统计", ["temp_instore 、 temp_outstore 、  temp_stock三张表，以temp_stock表数据为主，统计与mate_id、sd_price两个字段值在另外两张表中相等的记录，主要查询出mate_id、sd_price、(sd_quantity + os_quantity - is_quantity) as quantity", "\n就是sd_price与os_price、is_price比较，三者相等按上述进行加减运算，若os_price或is_price与sd_price不等按零处理。可能描述的不是很清楚，举个例子吧：", "\nmate_id=1 and sd_price= 10这条记录，与另外两张表统计时。在temp_outstore表中有条记录mate_id= 1但os_price不等于sd_price，所以按0处理。在tem_instore表中有条记录mate_id=1且is_price= sd_price，所以有值参与运算。最终计算结果是20+0-3=17", "\n\n", "这该怎么设计查询语句啊，是连接查询还是怎么弄。不是太会，逻辑这块", "\n以下插入三张表的截图：is_打头的字段是temp_instore表；os_打头的字段是temp_outstore表；sd_打头的字段是temp_stock表。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;就两个服务器&amp;#xff0c;一个web&amp;#xff0c;一个数据库吧。。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["两台树莓派或两个服务器,做一个web应用,该如何分配硬件?", ["两台树莓派4b    cpu都是四核心的.   内存一个2gb  一个4gb", "\n\n", "预计想要安装ubuntu server", "\n\n", "服务端使用nodejs的koa2   使用websocket功能     . 使用静态资源中间件 ", "\n\n", "应用计算逻辑使用python编写.   应用并不是很大. 但是会持续接收数据并写入数据  每个十几分钟会做一次数学计算. 每次计算", "\n\n", "大概会花费4-10秒钟.  (我也不知道这运算算不算复杂..... )", "\n\n", "数据库使用Redis..      ", "\n\n", "我现在的想法是.  用2g的树莓派单独运行数据库.  其余的什么功能都没有. 通过本地局域网进行通讯", "\n\n", "4g的树莓派 . koa服务器负责响应前端的各种数据  其实访问量并不大 并且托管静态页面  ", "\n\n", "4g的树莓派. python负责各种计算数据. 并持续写入数据库.  每隔十多分钟会对数据进行一次运算统计.", "\n\n", " ", "\n\n", "请问我这样使用硬件对吗  哦. 还有一个nginx做反向代理. ", "\n\n", "有什么需要注意的.     ", "\n\n", "这个行为我也不知道是分布式还是集群......  所以想请教有经验的大佬帮忙指导一下.   ", "\n\n", "因为我实在是小白. 目前部署的东西也都是 摸摸这里摸摸哪里. 稀里糊涂搞起来的.  koa2有必要用nginx反向代理吗.....?"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;if (i &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;){\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Not correct,You have tried three times! Test over!&amp;#34;&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n            break&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "逻辑运算", "Question": ["很简单的一个点但没明白", ["让学生自己输入两个加数，通过这两个加数给学生出一道加法运算题，如果学生输入答案正确，则显 示“Right！”否则提示重做，显示“Not correct! Try again!”，重做机会最多给三次，如果三次仍未做对，则显示“Not correct,You have tried three times! Test over!”，程序结束。", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", " ", "{\n    ", "float", " x, y, t;\n    cout << ", "\"input two numbers,give me the sum of them \"", ";\n    cin >> x >> y;\n    cout << x << ", "\"+\"", " << y << ", "\"=?\"", " << endl;\n    cout << ", "\"input your answer \"", ";\n    cin >> t;\n    ", "for", " (", "int", " i = ", "0", "; t != x + y; i++) {\n\n        cout << ", "\"Not correct! Try again!\"", ";\n        cin >> t;\n\n        ", "if", " (i == ", "3", ")\n            cout << ", "\"Not correct,You have tried three times! Test over!\"", ";\n        ", "break", ";\n\n\n    }\n    ", "if", " (t == x + y)\n        cout << ", "\"Right!\"", ";\n\n\n\n\n\n    ", "return", " ", "0", ";\n}\n\n", "\n", "结果输入错误答案一次之后程序就结束了，觉得逻辑没问题"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\nint judgeyear(int year){\r\n    int flag=0;//平年返回0 \r\n\r\n    if ((year%4==0 &amp;&amp; year%100 !=0) || year%400==0)\r\n           flag=1;//闰年返回1 \r\n\t\treturn flag;\r\n}\r\n\r\n\r\nint main(){\r\n    int year,month,day;\r\n    int flag_1=0; \r\n    scanf(\"%d%d%d\",&amp;year,&amp;month,&amp;day);\r\n    //判断输入的合法性\r\n    if(day&gt;=1&amp;&amp;day&lt;=31&amp;&amp;(month==1||month==3||month==5||month==7||month==8||month==10||month==12))//大月的月份\r\n           flag_1=1;\r\n    else if(day&gt;=1&amp;&amp;day&lt;=30&amp;&amp;(month==4||month==6||month==9||month==11))\r\n//小月的日的范围\r\n           flag_1=1;\r\n    else if(day&gt;=1&amp;&amp;day&lt;=29&amp;&amp;month==2)\r\n//二月的情况，\r\n//注意judgeyear函数的返回值，闰年返回1，闰年二月的天数也多1，使用加法运算\r\n           flag_1=1;\r\n\t\t\t\t\tif (!judgeyear(year) &amp;&amp; day == 29) flag_1 = 0;\r\n    if(flag_1)printf(\"yes\");\r\n    else  printf(\"no\");\r\n}\r\n\r\n```", "Konwledge_Point": "逻辑运算", "Question": ["C语言小白wen'ti，判断日期合法性", ["在下列程序的基础上完善程序。考察嵌套的if-else结构，分析程序的逻辑结构。", "\n\n", "#include<stdio.h>\nint judgeyear(int year){\n    int flag=0;//平年返回0 \n\n    if ((year%4==0 && year%100 !=0) || year%400==0)\n           flag=1;//闰年返回1 \n    【1】; //一行代码\n}\n\n\nint main(){\n    int year,month,day;\n    int flag_1=0; \n    scanf(\"%d%d%d\",&year,&month,&day);\n    //判断输入的合法性\n    if(day>=1&&day<=31&&【2】)//大月的月份\n           flag_1=1;\n    else if(【3】&&(month==4||month==6||month==9||month==11))\n//小月的日的范围\n           flag_1=1;\n    else if(【4】&month==2)\n//二月的情况，\n//注意judgeyear函数的返回值，闰年返回1，闰年二月的天数也多1，使用加法运算\n           flag_1=1;\n    if(flag_1)printf(\"yes\");\n    else  printf(\"no\");\n}\n\n", "\n\n", "思路：1)先假设所有的日期都是不合法的", "\n      2)下面考虑合法日期的几种情况", "\n                  2.1）31=>日>=1 且月份是“大月”     合法", "\n                 2.2）30=>日>=1 且月份是“小月”     合法", "\n                  2.3）29=>日>=1 且月份是闰年“二月”      合法", "\n                  2.4）28=>日>=1 且月份是平年“二月”      合法"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;和leetcode当时运行的环境有关系&amp;#xff0c;不用太在意&amp;#xff0c;只要时间和空间尽量优化即可&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["leetocde上第825题循环过程加上break执行效率反而慢了4秒", ["问题遇到的现象和发生背景", "\n", "leetocde上第825题循环过程加上break执行效率反而慢了4秒，按照逻辑来说break能减少循环及运算次数，程序执行效率应该加快才对。题目地址：", "https://leetcode-cn.com/problems/friends-of-appropriate-ages/submissions/", "\n", "问题相关代码，请勿粘贴截图", "\n", "class", " Solution {\n    // 快速排序\n    ", "public", " ", "void", " quickSort(", "int", "[] nums, ", "int", " left, ", "int", " right) {\n        ", "if", " (left >= right)\n            ", "return", ";\n        ", "int", " ", "temp", " = nums[left];\n        ", "int", " l = left;\n        ", "int", " r = right;\n        ", "while", " (l < r) {\n            ", "while", " (nums[r] <= ", "temp", " && l < r) {\n                r", "--;", "\n            }\n            ", "while", " (nums[l] >= ", "temp", " && l < r) {\n                l++;\n            }\n            ", "if", " (l < r) {\n                ", "int", " t = nums[r];\n                nums[r] = nums[l];\n                nums[l] = t;\n            }\n        }\n        nums[left] = nums[r];\n        nums[r] = ", "temp", ";\n        quickSort(nums, left, l - ", "1", ");\n        quickSort(nums, l + ", "1", ", right);\n    }\n\n      ", "public", " ", "int", " numFriendRequests(", "int", "[] ages) {\n        ", "int", " sum = ", "0", ";\n        Map<", "Integer", ", ", "Integer", "> map = ", "new", " HashMap<>();\n        // 用HashMap记录各个年龄及其对应人数\n        ", "for", " (", "int", " age : ages) {\n            map.put(age, map.getOrDefault(age, ", "0", ") + ", "1", ");\n        }\n        ", "int", "[] ages1 = ", "new", " ", "int", "[map.size()];\n        Iterator<Map.Entry<", "Integer", ", ", "Integer", ">> it = map.entrySet().iterator();\n        ", "int", " a = ", "0", ";\n        // 用数组ags1储存各个年龄的同时，处理年龄相等情况下的好友请求情况\n        ", "while", " (it.hasNext()) {\n            Map.Entry<", "Integer", ", ", "Integer", "> entry = it.next();\n            ages1[a++] = entry.getKey().intValue();\n            ", "if", " (entry.getValue().intValue() != ", "1", ") {\n                // 年龄相等则可排除除条件age[y] > age[x]和age[y] > ", "100", " && age[x] < ", "100", "\n                ", "if", " (!(entry.getKey() <= ", "0.5", " * entry.getKey() + ", "7", ")) {\n                    sum += (entry.getValue() - ", "1", ") * entry.getValue();\n                }\n            }\n        }\n        // 排序保证数组降序\n        quickSort(ages1, ", "0", ", ages1.length - ", "1", ");\n        // 循环时由于数组降序保证x<y即可排除条件age[y] > age[x]和age[y] > ", "100", " && age[x] < ", "100", "\n        ", "for", " (", "int", " x = ", "0", "; x < ages1.length - ", "1", "; x++) {\n            ", "for", " (", "int", " y = x + ", "1", "; y < ages1.length; y++) {\n                // 处理ages1[x]<ages1[y]的情况下的好友请求情况\n                ", "if", " (!(ages1[y] <= (", "0.5", " * ages1[x] + ", "7", "))){\n                       sum += map.", "get", "(ages1[x]).intValue() * map.", "get", "(ages1[y]).intValue();\n                }", "else", " break;// 这里如果不要break程序执行结果会快四秒\n            }\n        }\n        ", "return", " sum;\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "这是加上break后的运行结果：", "\n", "这是去掉break后的运行结果", "：", "\n", "我的解答思路和尝试过的方法", "\n", "我的大致思路为用哈希map储存各个年龄和该年龄对应的人数，用数组ages1储存各个年龄，再对ages1降序排序，循环时保证x<y即可不用再考虑限制条件二和三（age[y] > age[x]和age[y] > 100 && age[x] < 100），若年龄ages1[x]的人给ages1[x]的人发送好友请求，总数应为ages1[x]年龄对应的人数乘以（ages1[x]年龄对应的人数-1），若ages1[x]的人给ages1[y]的人发送好友请求，总数应为两个年龄端对应人数相乘。", "\n", "加上break的思想在于对于条件一：age[y] <= 0.5 * age[x] + 7，若找到第一个该条件后面为真，对于同一个x后面所有的y这个条件也为真，因为数组降序排列", "\n", "我想要达到的结果", "\n", "按照逻辑来说break能减少循环及运算次数，程序执行效率应该加快才对。但是加上break后反而变慢了，始终不知道为什么加上break会反而变慢"]], "Tag": "程序设计"}
{"Answer": "```\r\n 首先，如果你把代码放在按钮里，不点击按钮是不可能会启动线程，也不可能会报错。所以看不懂你说的最后一句话，是说点了按钮报错还是没点按钮报错。\r\n 如果点了按钮报错的话\r\n 等你执行到calThread.handler.sendMessage(msg);这句时，线程早就run玩了，这个线程一点意义都没有\r\n```", "Konwledge_Point": "逻辑运算", "Question": ["android线程的问题   大哥大姐帮帮忙", ["public class MainActivity extends Activity {", "\n\n", "static final String UPPER_NUM=\"upper\";\nEditText et;\nCalThread calThread;\n//定义一个线程类\nclass CalThread extends Thread{\n    public Handler handler;\n    public void run(){\n        Looper.prepare();\n        handler=new Handler(){\n            //定义处理消息的方法\n            @Override\n            public void handleMessage(Message msg){\n                if(msg.what==0x123){\n                    int upper=msg.getData().getInt(UPPER_NUM);\n                    List<Integer> nums=new ArrayList<Integer>();\n                    //计算从2开始，到upper的所有质数\n                    outer:\n                    for(int i=2;i<=upper;i++){\n                        //用i除以2开始，到I的平方根的所有数\n                        for(int j=2;j<=Math.sqrt(i);j++){\n                            //如果可以整出，则表明这个数不是指数\n                            if(i!=2 && i%j==0){\n                                continue outer;\n                            }\n                        }\n                        nums.add(i);\n                    }\n                    //使用Toast显示统计出来的所有质数\n                    Toast.makeText(MainActivity.this,nums.toString(),Toast.LENGTH_LONG).show();\n                }\n            }\n        };\n        Looper.loop();\n    }\n}\n@Override\npublic void onCreate(Bundle saveInstanceState){\n    super.onCreate(saveInstanceState);\n    setContentView(R.layout.main);\n    et=(EditText) findViewById(R.id.et);\n    //启动新线程-----------------------------------------------------111111\n             calThread=new CalThread();\n    calThread.start();\n\n\n\n}\n//为按钮的点击事件提供事件处理方法\npublic void cal(View source){\n   //-------------------------------------------------------------------2222222\n    //创建消息\n    Message msg=new Message();\n    msg.what=0x123;\n    Bundle bundle=new Bundle();\n    bundle.putInt(UPPER_NUM,Integer.parseInt(et.getText().toString()));\n    msg.setData(bundle);\n    //向新线程中的Handle发送消息\n    calThread.handler.sendMessage(msg);  //3333333333333333333333333\n}\n", "\n\n", "}", "\n\n", "现在这段代码是正确的", "\n如果把1处的线程放在2处启动就出现了异常", "\n\n", "Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'boolean android.os.Handler.sendMessage(android.os.Message)' on a null object reference  提示了3段错了", "\n\n", "按逻辑来说不是当按下按钮后才会启动这个线程去运算的吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sbit&amp;#61;a[--loa]&amp;#43;b[--lob]-&amp;#39;0&amp;#39;*2&lt;br /&gt;数组a,b为’\\0&amp;#39;的时候转换会出错&amp;#xff0c;建议先单独把字符数组转换成整数数组逆序保存&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["zzulioj大整数加法，代码纠错", ["题目是这样的：", "题目描述", "比利经常会碰到超大整数的加法运算，而普通的计算器上无法进行。因此他想你帮他写一个程序来计算结果。", "\n", "输入", "输入数据有多组。首先输入一个整数T，表示有T组输入。", "\n", "每组输入两个大整数，并用空格隔开。每个整数最多1000位。没有负数输入。", "\n", "输出", "对于每组输入，输出两个整数的和，单独占一行。", "\n", "样例输入 Copy", "2", "1 2", "112233445566778899 998877665544332211", "我的代码：", "按照样例输出是正确的，但是oj不给过，并隐藏了错误信息", "大佬们帮忙看看逻辑哪里错了-_-||", "\n", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "char", " a[", "1000", "],b[", "1000", "];", "//定义两个数组分别存储两个大整数", "\n    ", "int", " loa,lob,los,t;", "//分别代表数组a,b,sum的长度；", "\n    ", "int", " i;\n    ", "int", " s,c;", "//分别代表正在求的整数位和该位后面一位", "\n    ", "int", " sbit,sum[", "1001", "];", "/*分别代表当前位累加和，最后求和\n得到的数组，用1001是因为我觉得如果两个1000位的\n整数相加，会有1001位*/", "\n    ", "int", " T;", "//实例数", "\n    ", "scanf", "(", "\"%d\"", ",&T);\n    ", "while", "(T--)\n    {\n        ", "memset", "(sum,", "0", ",", "sizeof", "(", "int", ")*(", "1001", "));\n        ", "memset", "(a,", "'\\0'", ",", "sizeof", "(", "char", ")*(", "1000", "));\n        ", "memset", "(b,", "'\\0'", ",", "sizeof", "(", "char", ")*(", "1000", "));", "//对三个数组归零", "\n        ", "scanf", "(", "\"%s%s\"", ",&a,&b);\n    loa=", "strlen", "(a);\n    lob=", "strlen", "(b);", "//字符串a,b的长度", "\n    t=loa;\n    ", "if", "(t<lob)\n        t=lob;", "//找到较长的字符串作为基准", "\n    los=", "0", ";", "//对sum的长度归零", "\n    s=", "0", ";", "//对s归零", "\n    ", "for", "(i=t", "-1", ";i>=", "0", ";i--)", "//该次实例", "\n    {\n        c=s+", "1", ";", "//固定c为s的后一位", "\n        sbit=a[--loa]+b[--lob]-", "'0'", "*", "2", ";", "//从后往前求当前位的和", "\n        ", "if", "(sbit<", "10", ")", "//如果和<10，不进位，并进入下一位的求和", "\n        {\n             sum[s]+=sbit;\n             s++;\n        }\n        ", "else", " ", "if", "(sbit>=", "10", ")", "//如果和>10，下一位+1，并进入下一位的求和", "\n        {\n             sum[c]++;", "//下一位加一", "\n             sum[s]+=sbit", "-10", ";\n             s++;\n        }\n        los++;", "//用累和求出在最大位不进位下sum的长度", "\n    }", "/*因为上一个循环最后多计算了一次s++，所以下面\n直接用s代表最大位的下一位*/", "\n    ", "if", "(sum[s]!=", "0", ")", "//如果最大位加和进位了，sum长度+1", "\n        los++;\n    ", "for", "(i=los", "-1", ";i>=", "0", ";i--)\n        ", "printf", "(", "\"%d\"", ",sum[i]);", "//从最后得到的大整数的最大位开始顺序输出", "\n    ", "printf", "(", "\"\\n\"", ");\n\n    }\n\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你怕是理解错了默认分库策略的作用范围&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/809677885256146.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;他是在你的表已经确定分片的基础上&amp;#xff0c;才会起作用&amp;#xff0c;而不是你想的&amp;#xff0c;是张表就分库&lt;br /&gt;如果你想要一堆表都要加上分库逻辑&amp;#xff0c;要么自己一个个的配置&amp;#xff0c;要么就自己手动在SpringBootShardingRuleConfigurationProperties初始化完成后&amp;#xff0c;手动添加到SpringBootShardingRuleConfigurationProperties中&amp;#xff08;源码中我暂时没看到扩展点&amp;#xff0c;允许你搞事情&amp;#xff09;&lt;br /&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/229354095256122.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;手动加入&amp;#xff08;可以将这部分的表名&amp;#xff0c;全部配置到yml或者数据库&amp;#xff0c;然后一次性加入到tables中&amp;#xff09;&lt;br /&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/725045095256137.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/962665095256156.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;测试结果&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/414167095256150.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/121997095256181.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["shardingjdbc default-database-strategy 配置问题", ["问题遇到的现象和发生背景", "\n", "最近在使用 sharding-jdbc 做分库分表是遇到的问题，默认分库策略【default-database-strategy】要如何配置才能对所有表都生效", "业务上是多租户的类型的项目，每个表都存在一个 租户id 【tenant_id】, 通过mybatis plus的sql拦截器自动拼接在sql语句最后。", "默认的分库策略是对于 tenant_id 做取模运算，路由到不同的数据库中。", "我预期的结果是 对于未单独配置策略的 表，可以走 默认的分库策略 【default-database-strategy】，而实际上并未生效", "\n", "我关于 sharding-jdbc 的配置如下：", "\n", "  ", "shardingsphere", ":", "\n    ", "props", ":", "\n      ", "sql", ":", "\n        ", "show", ":", " ", "true", "\n    ", "datasource", ":", "\n      ", "# 数据源", "\n      ", "names", ":", " ", "master-0,slave-0,master-1,slave-1", "\n      ", "# 配置master 数据源", "\n      ", "master-0", ":", "\n        ", "# 配置druid数据源", "\n        ", "type", ":", " ", "com.alibaba.druid.pool.DruidDataSource", "\n        ", "driver-class-name", ":", " ", "com.mysql.cj.jdbc.Driver", "\n        ", "url", ":", " ", "jdbc:mysql://mysql-server:3307/xxx-0?&serverTimezone=GMT%2b8&useSSL=false", "\n        ", "username", ":", " ", "xxx", "\n        ", "password", ":", " ", "xxx", "\n        ", "maxPoolSize", ":", " ", "100", "\n        ", "minPoolSize", ":", " ", "5", "\n      ", "slave-0", ":", "\n        ", "type", ":", " ", "com.alibaba.druid.pool.DruidDataSource", "\n        ", "driver-class-name", ":", " ", "com.mysql.cj.jdbc.Driver", "\n        ", "url", ":", " ", "jdbc:mysql://mysql-server:3307/xxx-0?&serverTimezone=GMT%2b8&useSSL=false", "\n        ", "username", ":", " ", "jadows-0", "\n        ", "password", ":", " ", "xxx", "\n        ", "maxPoolSize", ":", " ", "xxx", "\n        ", "minPoolSize", ":", " ", "5", "\n      ", "master-1", ":", "\n        ", "type", ":", " ", "com.alibaba.druid.pool.DruidDataSource", "\n        ", "driver-class-name", ":", " ", "com.mysql.cj.jdbc.Driver", "\n        ", "url", ":", " ", "jdbc:mysql://mysql-server:3307/xxx-1?&serverTimezone=GMT%2b8&useSSL=false", "\n        ", "username", ":", " ", "xxx", "\n        ", "password", ":", " ", "xxx", "\n        ", "maxPoolSize", ":", " ", "100", "\n        ", "minPoolSize", ":", " ", "5", "\n      ", "slave-1", ":", "\n        ", "type", ":", " ", "com.alibaba.druid.pool.DruidDataSource", "\n        ", "driver-class-name", ":", " ", "com.mysql.cj.jdbc.Driver", "\n        ", "url", ":", " ", "jdbc:mysql://mysql-server:3307/xxx-1?&serverTimezone=GMT%2b8&useSSL=false", "\n        ", "username", ":", " ", "xxx", "\n        ", "password", ":", " ", "xxx", "\n        ", "maxPoolSize", ":", " ", "100", "\n        ", "minPoolSize", ":", " ", "5", "\n    ", "sharding", ":", "\n      ", "default-database-strategy", ":", "\n        ", "inline", ":", "\n          ", "sharding-column", ":", " ", "tenant_id", "\n          ", "algorithm-expression", ":", " ", "master-$->{tenant_id % 2}", "\n      ", "default-table-strategy", ":", "\n        ", "none", ":", "\n      ", "tables", ":", "\n        ", "# login_record 逻辑表", "\n        ", "login_record", ":", "\n          ", "# 数据节点：数据源$->{0..N}.逻辑表名$->{0..N}", "\n          ", "actual-data-nodes", ":", " ", "master-$->{0..1}.login_record_$->{0..2}", "\n          ", "# 拆分库策略", "\n          ", "database-strategy", ":", "\n            ", "inline", ":", "\n              ", "# 分片字段", "\n              ", "sharding-column", ":", " ", "tenant_id", "\n              ", "algorithm-expression", ":", " ", "master-$->{tenant_id % 2}", "\n          ", "# 拆分表策略", "\n          ", "table-strategy", ":", "\n            ", "inline", ":", "\n              ", "# 分片字段（分片键）", "\n              ", "sharding-column", ":", " ", "id", "\n              ", "# 分片算法表达式", "\n              ", "algorithm-expression", ":", " ", "login_record_$->{ id % 3 }", "\n      ", "broadcast-tables", ":", "\n        ", "-", " ", "tenant", "\n      ", "# 读写分离配置", "\n      ", "master-slave-rules", ":", "\n        ", "master-0", ":", "\n          ", "master-data-source-name", ":", " ", "master-0", "\n          ", "slave-data-source-names", ":", " ", "slave-0", "\n        ", "master-1", ":", "\n          ", "master-data-source-name", ":", " ", "master-1", "\n          ", "slave-data-source-names", ":", " ", "slave-1", "\n", "\n", "情况1) 未配置 user 表的 分表策略，查询 user 表", "\n", " @Test\n    ", "public", " ", "void", " test() {\n        List<", "User", "> list = userService.list();\n        ", "System", ".", "out", ".println(list);\n\n        List<", "User", "> l2 = userService.list();\n        ", "System", ".", "out", ".println(l2);\n    }\n", "\n", "执行上述两个查询,执行结果：", "\n", "Actual ", "SQL", ": slave", "-0", " ::: ", "SELECT", " id,..., created, tenant_id ", "FROM", " `", "user", "` ", "WHERE", " `", "user", "`.tenant_id ", "=", " ", "0", "\n\nActual ", "SQL", ": slave", "-1", " ::: ", "SELECT", " id,..., created, tenant_id ", "FROM", " `", "user", "` ", "WHERE", " `", "user", "`.tenant_id ", "=", " ", "0", "\n", "\n", "可以看到 ，master-slave 的策略生效，两次查询分别命中 slave-0 库 和 slave-1 库，而 default-database-stragegy 策略没有生效 【 预期：默认分库策略根据 tenant_id 取模，tenant_id 为 0 时 路由至 master-0 库，再根据 master-0 配置的的读写分离策略，两次查询都应该命中 slave-0 库】", "\n", "情况2) 配置了 login_record 表的分表策略，查询 login_record 表", "login_record 不按照 tenant_id 做分库【 记录用户的登录信息，未登录下不知道 tenant_id,所以取id 做分库字段 】，login_record 分为三张表，分别是 ", "\n", "logi", "n_record_0", "\nlogi", "n_record_1", "\nlogi", "n_record_2", "\n", "\n", "@Test\n    ", "public", " ", "void", " loginRecordTest() {\n        List<LoginRecord> list = loginRecordService.list();\n        ", "System", ".", "out", ".println(list);\n\n  // 配置了 ", "tables", " 策略 ，正确执行\n        List<LoginRecord> list = loginRecordService.list();\n        ", "System", ".", "out", ".println(list);\n\n        List<LoginRecord> list2 = loginRecordService.list();\n        ", "System", ".", "out", ".println(list2);\n\n        List<LoginRecord> list3 = loginRecordService.list();\n        ", "System", ".", "out", ".println(list3);\n\n        List<LoginRecord> list4 = loginRecordService.list();\n        ", "System", ".", "out", ".println(list4);\n    }\n", "\n", "执行结果：", "\n", "Actual ", "SQL", ": slave", "-0", " ::: ", "SELECT", " id, user_name, ... ", "FROM", " login_record_0 ", "WHERE", " login_record_0.tenant_id ", "=", " ", "0", "\n\nActual ", "SQL", ": slave", "-0", " ::: ", "SELECT", " id, user_name, ... ", "FROM", " login_record_1 ", "WHERE", " login_record_1.tenant_id ", "=", " ", "0", "\n\nActual ", "SQL", ": slave", "-0", " ::: ", "SELECT", " id, user_name,... ", "FROM", " login_record_2 ", "WHERE", " login_record_2.tenant_id ", "=", " ", "0", "\n\n", "\n", "单独配置 table-statagy 时，符合预期。所有查询只命中 slave-0 库。", "\n", "sharding-jdbc 及 springboot 版本：", "\n", "            ", "<", "dependency", ">", "\n                ", "<", "groupId", ">", "org.apache.shardingsphere", "</", "groupId", ">", "\n                ", "<", "artifactId", ">", "sharding-jdbc-spring-boot-starter", "</", "artifactId", ">", "\n                ", "<", "version", ">", "4.1.1", "</", "version", ">", "\n            ", "</", "dependency", ">", "\n\n          ", "<", "dependency", ">", "\n            ", "<", "groupId", ">", "org.springframework.boot", "</", "groupId", ">", "\n            ", "<", "artifactId", ">", "spring-boot-starter-parent", "</", "artifactId", ">", "\n            ", "<", "version", ">", "2.3.12.RELEASE", "</", "version", ">", "\n          ", "</", "dependency", ">", "\n", "\n", "问题", "\n", "需要如何配置，才能使得 数据库中所有的表 都支持默认的分库策略？"]], "Tag": "程序设计"}
{"Answer": "原因找到了，32位JDK下没有问题，只要是64位JDK都会出现这各现象\r\n（多谢 搞几年和程序员小董的回复）", "Konwledge_Point": "逻辑运算", "Question": ["请教一个JAVA线程的奇怪问题", ["在学习JAVA线程时候的遇到一个很奇怪的现象。让我们先来看代码", "\n\n", "public class TestThread {\n\n    public static void main(String[] args) {\n        IRun ir = new IRun();\n        Thread it = new Thread(ir);\n        it.start();\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException ex) {\n            Logger.getLogger(TestThread.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        ir.setStop();\n    }\n\n    static class IRun implements Runnable {\n        boolean exec = true;\n        public void setStop() {\n            exec = false;\n            System.out.println(\"exec = \" + exec);\n        }\n        @Override\n        public void run() {\n            int c = 0;\n            while (exec) {\n                c++;\n            }\n            System.out.println(\"退出了循环\");\n        }\n    }\n}\n", "\n\n", "     在上述程序首先创建一个Runnable对象ir，然后创建一个线程对象it，通过it.start()启动线程，执行IRun类中的run()函数，执行一个while循环。while循环的条件由布尔变量exec控制。主程序中等待1秒钟后，修改exec的值为false，按照正常的逻辑应该是在exec值为false后，循环结束执行下面输出语句，然后线程结束，程序退出。\n    但是，上述代码在运行后，将不会执行run()函数中的System.out.println(\"退出了循环\");语句，程序一直保持运行。对这种现象，在帖子”关于JAVA线程，请大神帮忙“中still_rain给出的这种现象的原因是线程访问的同步问题导致，当主线程（main函数所在的线程）中修改变量exec的值后，在创建执行的线程中访问的exec的值没有发生变化（或者说可能是主线程、执行线程这两个线程exec变量是不同的对象，好像是说java会将一些资源在每个线程中复制一份?有待确认）。在exec变量前加上volatile修饰符后，程序运行正常，问题似乎解决。\n   现在以上述代码为基础，进行一次小小的修改。在run()函数中的while循环中加上一个类对象操作，比如新建一个字符串，则run()函数为\n", "\n\n", " public void run() {\n            int c = 0;\n            while (exec) {\n                String s = new String(\"\");\n                c++;\n            }\n            System.out.println(\"退出了循环\");\n        }\n    } \n", "\n\n", "   运行程序，程序按预期的顺序执行，顺利结束。这时候不管exec变量是否有volatile修饰符，且只在while循环中存在类对象操作（新建对象、对象函数调用（调用的函数不能返回基本数据类型），以及像System.out.println这样的操作），程序的运行都很正常，对这种现象就不是上述的同步问题能够解释的了。在帖子”关于JAVA线程，请大神帮忙“中still_rain（感谢热情的回复）从编译器优化的角度进行了解释。当while循环中只有简单的基本数据类型参与运算的时候由于执行速度太快，将while循环编译成了while(true)语句。导致循环不会退出，从而循环后的输出不会执行，且程序不会退出。\n        为了探究这个奇怪现象的原因，让我们看看编译后的字节码，下图是用jclasslib查看的字节码，是修改前的run()函数字节码。\n", "\n\n", "\n\n", "从图中可以看到，循环体从aload_0开始，到goto 2结束。控制跳转的语句是ifeq 15，意思是如果值为0则跳转到15，否则执行下面的语句。", "\n当将上面的while(exec)语句修改为while(true)后，字节码为：", "\n\n", "由两图可以看出，编译器并没有将while(exec)语句优化为while(true)。再看修改后的代码编译的字节码：", "\n\n", "\n\n", "循环体从aload_0起，到goto 2结束。从ifeq 25下面的一行到astotre_2行，为String s = new String(\"\");语句的字节码，将这段去掉则字节码与修改前的一样。所以基本可以排除编译器优化导致的程序不正常运行。", "\n请看到这篇文章的大神们能够给予指导，探究出现这种情况的原因，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;非常抱歉&amp;#xff0c;本次您提出的有问必答问题&amp;#xff0c;技术专家团超时未为您做出解答&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;本次提问扣除的有问必答次数&amp;#xff0c;已经为您补发到账户&amp;#xff0c;我们后续会持续优化&amp;#xff0c;扩大我们的服务范围&amp;#xff0c;为您带来更好地服务。&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["简易cpu如何解决Verilog中的数据冒险", ["问题遇到的现象和发生背景", "\n", "\n", "在编写简易cpu时寄存器内的数据多次跳跃，当计算A+1或A-1时结果为0；", "\n", "运行结果及报错内容", "\n", "\n", "\n", "```bash", "\n", "module", " cpu(\n    ", "input", " clock,\n    ", "input", " reset,\n    ", "input", " [", "7", ":", "0", "]zhiling,\n    ", "output", " ", "reg", "[", "7", ":", "0", "] led_id,\n    ", "output", " ", "reg", "[", "6", ":", "0", "] out_led,\n    ", "output", " ", "reg", " ", "signed", "[", "7", ":", "0", "]r,\n    ", "output", " ", "reg", " ", "signed", "[", "7", ":", "0", "]r1,\n    ", "output", " ", "reg", " ", "signed", "[", "7", ":", "0", "]r2,\n    ", "output", " ", "wire", " ", "signed", "[", "7", ":", "0", "]r11,\n    ", "output", " ", "wire", " ", "signed", "[", "7", ":", "0", "]r12,\n     ", "output", " ", "wire", " ", "signed", "[", "7", ":", "0", "]r33,\n     ", "output", " ", "wire", " ", "signed", "[", "7", ":", "0", "]r44,\n     ", "output", " ", "wire", " ", "signed", "[", "7", ":", "0", "]r55,\n     ", "output", " ", "wire", " ", "signed", "[", "7", ":", "0", "]r66,\n    ", "output", " ZF1, ", "//0标志位, 运算结果为0(全零)则置1, 否则置0 ", "\n           OF1, ", "//溢出标志位 ", "\n           CF1, ", "//进借位标志位,  ", "\n           SF1, ", "//符号标志位，与F的最高位相同  ", "\n           PF1", "//奇偶标志位，F有奇数个1，则PF=1，否则为0  ", "\n    );\n   ", "/* reg signed[7:0]r1;\n    reg signed[7:0]r2;\n    wire signed[7:0]r11;\n    wire signed[7:0]r12;*/", "\n    ", "reg", " [", "7", ":", "0", "] mymem [", "3", ":", "0", "]; ", "// 定义32个8位存储器（mymem[i]表示第i个存储器）", "\n    ", "always", "@* ", "begin", "\n    ", "if", "(reset==", "1'b1", ")\n     ", "begin", "\n    mymem[", "0", "]=", "8'b00000000", ";\n    mymem[", "1", "]=", "8'b00000000", ";\n    mymem[", "2", "]=", "8'b00000000", ";\n    mymem[", "3", "]=", "8'b00000000", ";\n     ", "end", "\n     ", "end", "\n    ", "function", " [", "7", ":", "0", "]RAM;\n    ", "input", " reset;\n", "input", " we; ", "// 低电平表示读数据，高电平表示写数据 用开关SW1表示 ", "\n", "input", " rd;\n", "input", " [", "1", ":", "0", "] addr_we;\n", "input", " [", "1", ":", "0", "] addr_rd;\n", "input", " [", "7", ":", "0", "] data_in; ", "// 用开关SW7-SW14表示输入的8位二进制数据 ", "\n", "begin", "\n    ", "if", "(reset==", "1'b0", ")\n    ", "begin", "\n    ", "if", "(we==", "1'b1", "&&rd==", "1'b0", ")\n      ", "begin", "\n         mymem[addr_we]=data_in;\n       RAM=mymem[addr_we];\n      ", "end", "\n    ", "else", " ", "if", "(we==", "1'b0", "&&rd==", "1'b1", ")\n       RAM=mymem[", "2'b10", "]; \n ", "end", "\n ", "end", "\n ", "endfunction", "\n    ", "wire", " s0,s1,s2,s3,s4,s5,add_en,add1_en,sub_en,sub1_en,and_en,or_en,xor_en,slt_en;\n    ", "wire", " [", "3", ":", "0", "]opcode;", "wire", "[", "1", ":", "0", "]addr_1;", "wire", "[", "1", ":", "0", "]addr_2;\n    ", "wire", " ", "signed", " [", "3", ":", "0", "]a;", "wire", "[", "3", ":", "0", "]b; \n    control c(reset,zhiling[", "7", ":", "4", "],s0,s1,s2,s3,s4,s5,add_en,add1_en,sub_en,sub1_en,and_en,or_en,xor_en,slt_en);\n    ", "always", "@(*) \n    ", "begin", "                \n    ", "if", "(s0==", "1", "&&s3==", "0", "&&s4==", "0", ")            \n     mymem[zhiling[", "5", ":", "4", "]]=RAM (reset,s0,s1,zhiling[", "5", ":", "4", "],", "2'b10", ",{{", "4", "{zhiling[", "3", "]}},zhiling[", "3", ":", "0", "]});  \n      ", "if", "(s3==", "1'b1", ")\n    ", "begin", " r1={{", "4", "{r11[", "3", "]}},r11[", "3", ":", "0", "]};\n    mymem[", "2'b10", "]=RAM (reset,", "1'b1", ",", "1'b0", ",", "2'b10", ",", "2'b10", ",r1); ", "end", "\n    ", "if", "(s4==", "1'b1", ")\n    ", "begin", " r2=r12;\n    mymem[", "2'b10", "]=RAM (reset,", "1'b1", ",", "1'b0", ",", "2'b10", ",", "2'b10", ",r2); \n     ", "end", " \n    ", "if", "(s1==", "1", ") r=mymem[", "2'b10", "];\n       ", "end", "        \n    ", "// assign r13=mymem[zhiling[5:4]];             ", "\n    id i(reset,s2,zhiling,opcode,addr_1,addr_2);\n    ", "assign", " r33=mymem[addr_1];  \n    ", "assign", " r44=mymem[addr_2];  \n    ", "assign", " r55=mymem[", "0", "];\n    ", "assign", " r66=mymem[", "1", "];\n    alu alu1(mymem[addr_1][", "3", ":", "0", "],mymem[addr_2][", "3", ":", "0", "],reset,s3,add_en,add1_en,sub_en,sub1_en,and_en,or_en,xor_en,slt_en,r11,ZF1,OF1,CF1,SF1,PF1); \n    MULT_4 m(mymem[addr_1],mymem[addr_2],reset,s4,r12);\n    ", "/*always@(posedge clock)   \n    begin  r=mymem[2'b10];\n    end*/", "\n    ", "parameter", " CLK_COUNT = ", "249999", ";", "//时钟计数上限", "\n", "reg", " [", "31", ":", "0", "] count;", "//计数", "\n", "reg", " [", "1", ":", "0", "] id;", "//id0~3对应左到右四个数码管", "\n", "wire", " flag;  ", "//flag标记补码是否表示负数", "\n", "assign", " flag=r[", "7", "];\n\n", "//8位2进制，十进制至多3位", "\n", "reg", " [", "7", ":", "0", "] n1;    ", "//百位", "\n", "reg", " [", "7", ":", "0", "] n2;    ", "//十位", "\n", "reg", " [", "7", ":", "0", "] n3;    ", "//个位", "\n", "reg", " [", "7", ":", "0", "] abs;  \n", "always", " @(*)\n    ", "case", "(flag) ", "//求正数的个十百位", "\n    ", "1'b0", ":\n        ", "begin", "\n           n1 = r / ", "100", " % ", "10", ";\n           n2 = r/ ", "10", " % ", "10", ";\n           n3 = r % ", "10", ";\n        ", "end", "\n    ", "1'b1", ":\n        ", "begin", "\n           abs=(~r)+", "1", ";  ", "//求负数的个十百位", "\n           n1 = abs / ", "100", " % ", "10", ";        \n           n2 = abs / ", "10", " % ", "10", ";        \n           n3 = abs % ", "10", ";\n        ", "end", "\n    ", "endcase", "\n    \n", "always", " @ (", "posedge", " clock)", "//时钟上升沿", "\n", "begin", " ", "//根据时钟信号控制切换显示的数码管", "\n    ", "if", " (count == CLK_COUNT)\n    ", "begin", "\n        count <= ", "0", ";\n       id = (id + ", "1", ");", "//切换", "\n    ", "end", "\n    ", "else", "\n        count <= count+", "1", ";\n    ", "end", "\n   \n   \n   ", "//选择灯，显示数字", "\n", "always", " @ (id)\n", "begin", "        \n    ", "if", " (id == ", "0", ") \n            ", "begin", "           \n                led_id <= ", "8'b1111_0111", ";", "//最左端灯亮", "\n                ", "if", "(r[", "7", "]==", "1", ")\n                out_led<=", "7'b1111110", ";", "//负号", "\n                ", "else", " out_led<=", "7'b1111111", ";", "//不显示", "\n            ", "end", "\n    ", "else", " ", "if", " (id == ", "1", ")", "//其余三个管显示逻辑相同", "\n    ", "begin", "\n        led_id <= ", "8'b1111_1011", ";\n        ", "begin", "\n            ", "case", "(n1)\n                ", "4'b0000", ": out_led = ", "7'b0000001", ";    ", "//0", "\n                ", "4'b0001", ": out_led = ", "7'b1001111", ";    ", "//1", "\n                ", "4'b0010", ": out_led = ", "7'b0010010", ";    ", "//2", "\n                ", "4'b0011", ": out_led = ", "7'b0000110", ";    ", "//3", "\n                ", "4'b0100", ": out_led = ", "7'b1001100", ";    ", "//4", "\n                ", "4'b0101", ": out_led = ", "7'b0100100", ";    ", "//5", "\n                ", "4'b0110", ": out_led = ", "7'b0100000", ";    ", "//6", "\n                ", "4'b0111", ": out_led = ", "7'b0001111", ";    ", "//7", "\n                ", "4'b1000", ": out_led = ", "7'b0000000", ";    ", "//8", "\n                ", "4'b1001", ": out_led = ", "7'b0000100", ";    ", "//9", "\n            ", "endcase", "\n        ", "end", " \n    ", "end", "\n    ", "else", " ", "if", " (id == ", "2", ")\n    ", "begin", "\n        led_id <= ", "8'b1111_1101", ";\n        ", "begin", "\n            ", "case", "(n2)\n                ", "4'b0000", ": out_led = ", "7'b0000001", ";    ", "//0", "\n                ", "4'b0001", ": out_led = ", "7'b1001111", ";    ", "//1", "\n                ", "4'b0010", ": out_led = ", "7'b0010010", ";    ", "//2", "\n                ", "4'b0011", ": out_led = ", "7'b0000110", ";    ", "//3", "\n                ", "4'b0100", ": out_led = ", "7'b1001100", ";    ", "//4", "\n                ", "4'b0101", ": out_led = ", "7'b0100100", ";    ", "//5", "\n                ", "4'b0110", ": out_led = ", "7'b0100000", ";    ", "//6", "\n                ", "4'b0111", ": out_led = ", "7'b0001111", ";    ", "//7", "\n                ", "4'b1000", ": out_led = ", "7'b0000000", ";    ", "//8", "\n                ", "4'b1001", ": out_led = ", "7'b0000100", ";    ", "//9", "\n            ", "endcase", "\n        ", "end", "\n    ", "end", "\n    ", "else", " ", "if", " (id == ", "3", ")\n    ", "begin", "\n        led_id <= ", "8'b1111_1110", ";\n    ", "begin", "\n        ", "case", "(n3)\n            ", "4'b0000", ": out_led = ", "7'b0000001", ";    ", "//0", "\n            ", "4'b0001", ": out_led = ", "7'b1001111", ";    ", "//1", "\n            ", "4'b0010", ": out_led = ", "7'b0010010", ";    ", "//2", "\n            ", "4'b0011", ": out_led = ", "7'b0000110", ";    ", "//3", "\n            ", "4'b0100", ": out_led = ", "7'b1001100", ";    ", "//4", "\n            ", "4'b0101", ": out_led = ", "7'b0100100", ";    ", "//5", "\n            ", "4'b0110", ": out_led = ", "7'b0100000", ";    ", "//6", "\n            ", "4'b0111", ": out_led = ", "7'b0001111", ";    ", "//7", "\n            ", "4'b1000", ": out_led = ", "7'b0000000", ";    ", "//8", "\n            ", "4'b1001", ": out_led = ", "7'b0000100", ";    ", "//9", "\n        ", "endcase", "\n    ", "end", "\n    ", "end", " \n", "end", "\n", "endmodule", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;变成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attr\"&gt;b&lt;/span&gt; &amp;#61; x &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp; z&amp;#43;&amp;#43; &amp;gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/833955804086154.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "逻辑运算", "Question": ["java：为什么z不是等于1", ["请问最后这个z为什么不是1，不是和y一样用完后自加1吗，为什么最后z输出的结果是0", "\n", "\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String[] args", ")", " {\n\n        ", "int", " x = ", "0", ";  ", "// 定义变量x，初始值为0", "\n\n        ", "int", " y = ", "0", ";  ", "// 定义变量y，初始值为0", "\n\n        ", "int", " z = ", "0", ";  ", "// 定义变量z，初始值为0", "\n\n        boolean a, b;  ", "// 定义boolean变量a和b", "\n\n        a = x > ", "0", " & y++ > ", "1", ";  ", "// 逻辑运算符&对表达式进行运算", "\n\n        System.", "out", ".println(a);\n\n        System.", "out", ".println(", "\"y = \"", " + y);\n\n        b = x > ", "0", " && z++ > ", "1", "; ", "// 逻辑运算符&&对表达式进行运算", "\n\n        System.", "out", ".println(b);\n\n        System.", "out", ".println(", "\"z = \"", " + z);\n\n    }\n", "\n"]], "Tag": "程序设计"}
