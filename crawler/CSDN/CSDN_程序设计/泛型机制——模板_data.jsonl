{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Neither &lt;code&gt;json.Unmarshal&lt;/code&gt; nor &lt;code&gt;template.Execute&lt;/code&gt; cares about the actual type of the data, this will all be handled at runtime. So you can just parse the json to an &lt;code&gt;interface{}&lt;/code&gt; and pass that to your templates. Provided that the json data contains the fields that are expected by the template to which you pass the data, this will just work fine.&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.com/p/99GmCMdr3K\" rel=\"nofollow noreferrer\"&gt;Playground link&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"html/template\"\n)\n\nvar templates = map[string]*template.Template{\n    \"A\": template.Must(template.New(\"A\").Parse(\"{{ .A }}\")),\n    \"B\": template.Must(template.New(\"B\").Parse(\"{{ .B }} and {{ .C.D }}\")),\n}\n\ntype tmplReceiver struct {\n    TmplName string\n    TmplArgs string\n}\n\nfunc main() {\n    receivers := []tmplReceiver{\n        tmplReceiver{\"A\", `{\"A\": \"Value for A\"}`},\n        tmplReceiver{\"B\", `{\"B\": \"Value for B\", \"C\": { \"D\": \"Value for D\" }}`},\n    }\n\n    for _, receiver := range receivers {\n        var data interface{}\n        json.Unmarshal([]byte(receiver.TmplArgs), &amp;amp;data)\n\n        var buffer bytes.Buffer\n        templates[receiver.TmplName].Execute(&amp;amp;buffer, data)\n        fmt.Println(buffer.String())\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Which prints&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Value for A&lt;/p&gt;\n  \n  &lt;p&gt;Value for B and Value for D&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["golang模板处理和泛型", ["\n\n", "I have two golang html templates, as follows:", "\n\n", "var m map[string]string\nm = make(map[string]string)\n\nm[\"First\"] = `<html>\n<body>First template type {{.First}}\n</html>`\n\nm[\"Second\"] = `<html>\n<body>Second template type {{.SecondF1}} {{.SecondF2}}\n</html>`\n", "\n\n", "The first html template takes only one argument, named ", "First", " whereas the second template needs two arguments, named ", "SecondF1", " and ", "SecondF2", ".", "\n\n", "Now I have a struct which has two fields, one for receiving a template name and another for receiving the template arguments.", "\n\n", "type tmplReceiver struct {\n    TmplName string\n    TmplArgs string // Receives JSON string\n}\n", "\n\n", "Now, examples of instances for the above structs could be:", "\n\n", "var i, j tmplReceiver\n\ni.TmplName = \"First\"\ni.TmplArgs = `{\"Field1\": \"First Template Argument\"}`\n\nj.TmplName = \"Second\"\nj.TmplArgs = `{\n  \"SecondF1\": \"Second template First Argument\", \n  \"SecondF2\": \"Second template Second Argument\"\n}`\n", "\n\n", "Now I can get the Template string by using the map, for example:", "\n\n", "tmplStr := m[i.TmplName] (or)\ntmplStr := m[j.TmplName]\n\ntmpl, _ = template.New(\"email\").Parse(tmplStr)\n", "\n\n", "However, how do I get the template to be executed for all the possible template types, with a single ", "tmpl.Execute", " statement. In other words, if I want to have the following code:", "\n\n", "var buff bytes.Buffer\nif err := tmpl.Execute(&buff, tmplPtr); err != nil {\n    log.Fatal(err)\n}\nlog.Println(buff.String())\n", "\n\n", "How do I get the ", "tmplPtr", " to be valid, irrespective of how many templates I have (", "First", ", ", "Second", ", etc.) and each of these templates can have a variable number of arguments (", "First", " has only one arg, whereas ", "Second", " has two args, etc.)", "\n\n", "I do not want to write N different ", "tmpl.Execute", " statements with an ", "if", " block for each template name. Is there any other alternative approach to solve this ? Thanks.", "\n    "]], "Tag": "程序设计"}
{"Answer": "public class 学生\r\n{\r\npublic 班级 c { get; set; }\r\n}\r\n在你的班级类中\r\nclass 班级\r\n{\r\n    ...\r\n    string 名称;\r\n\t\tpublic override string ToString() { return 名称; }\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["winfrom datagridview 绑定泛型", ["public class 学生", "\n{", "\n    public 班级   c", "\n}", "\n我在DGV查询出来这个结果，想在DGV上显示，班级的名称。", "\nc.名称,这个应该怎么处理呢，这个"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先泛型可以作为参数传递。可以搜泛型方法的使用&amp;#xff0c;至于图中的错误是因为泛型参数是在编译阶段才会验证类型是否一致&amp;#xff0c;类型从低位类型到高位类型自动转换的。所以你如果需要明白基本原理的话&amp;#xff0c;java类型转换机制可以了解一下&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA泛型可以作为参数传递吗？", ["需求：传入一个泛型类，指定类型为Date", "\n\n", "问题：请求报错--->java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Date", "\n\n", "入参：http://127.0.0.1:8080/tgb/api/v1/water/test?endTime=2021-03-07 23:00:00", "\n\n", "泛型类：", "\n\n", "\n\n", "接口：可以看到，参数是正常传入了的", "\n\n", "\n\n", "但是为什么再下一步执行就报错了呢：", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;ArrayList&lt;/code&gt;与&lt;code class=\"language-javascript\"&gt;ArrayList&amp;lt;Object&amp;gt;&lt;/code&gt;不是同一种类型&amp;#xff0c;前者是原始类型&amp;#xff0c;是所有带泛型参数类型的父类型&amp;#xff0c;后者不是。&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/luxinfeng666/article/details/114794030\" id=\"textarea_1652409817087_1652409939427_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Generic Array Creation&amp;#xff0c;泛型数组创建时提示出错_luxinfeng666的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;起因前两天在刷leetcode时&amp;#xff0c;遇到一个设计题&amp;#xff0c;需要设计一个哈希集合&amp;#xff0c;当时的想法就是创建一个链表数组&amp;#xff0c;用链表来解决哈希冲突问题。然而在编写时&amp;#xff0c;编译器报错&amp;#xff0c;如下图所示。分析为什么会出现编译错误呢&amp;#xff1f;这里就是泛型数组的问题了。在Java中&amp;#xff0c;数组是支持协变&amp;#xff08;Covariant&amp;#xff09;的&amp;#xff0c;而泛型是不可变&amp;#xff08;Invariant&amp;#xff09;的。当两者在一起的时候&amp;#xff0c;就会出现问题。我们先来看看协变和不可变的定义协变&amp;#xff1a;是指子类型关系在类型变换的作用下保持原样。逆变&amp;#xff1a;指的是子类型关系在类型变换的作用下发生逆转。不可变&amp;#xff1a;表示子&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/luxinfeng666/article/details/114794030&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java泛型强转问题", ["\n", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args) {\n    ", "ArrayList", "<Integer> integers = ", "new ", "ArrayList", "<>();\n    ", "ArrayList", "<", "Object", "> objects = (", "ArrayList", ") integers; ", "// 编译通过", "\n    ", "ArrayList", "<", "Object", "> objects = (", "ArrayList", "<", "Object", ">) integers; ", "// 编译失败", "\n}\n", "\n", "请问为什么强转不带泛型编译通过，带上泛型反而还失败了？谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你在实例化的时候&amp;#xff0c;需要指定泛型&amp;#xff0c;如果不指定泛型&amp;#xff0c;默认就是object类型。因为Object是所有类的父类&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/751934043956137.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["没有指定泛型的泛型类对象调用泛型方法的返回值是Object", ["在实例化时没有指定泛型的泛型类的对象使用泛型方法返回值会变成Object", "\n", "问题代码", "\n", "public", " ", "class", " ", "Gener", " ", "{\n    ", "public", " ", "static", " void main(", "String", "[] args) {\n        A a = ", "new", " ", "A", "();\n        ", "String", " s = a.", "get", "(", "\"1\"", ");\n        Integer integer = a.", "get", "(", "2", ");\n\n        B<Integer> integerB = ", "new", " ", "B", "<Integer>();\n        ", "String", " s1 = integerB.", "get", "(", "\"2\"", ");\n        Integer integer1 = integerB.", "get", "(", "2", ");\n\n        ", "//?????????", "\n        B b = ", "new", " ", "B", "();\n        Object o = b.", "get", "(", "\"2\"", ");\n        Object o1 = b.", "get", "(", "2", ");\n    }\n}\n", "class", " ", "A", " ", "{\n    ", "public", " <T> T ", "get", "(T t) {\n        ", "return", " t;\n    }\n}\n", "class", " ", "B", "<", "E", "> ", "{\n    ", "public", " <T> T ", "get", "(T t) {\n        ", "return", " t;\n    }\n}\n\n", "\n", "运行结果", "\n", "已知结论：", "\n", "在非泛型类对象中使用泛型方法和", "\n", "实例化时指定了泛型类的对象使用泛型方法没问题", "\n", "但是！", "\n", "在实例化时没有指定泛型的泛型类的对象使用泛型方法返回值会变成Object", "\n", "我想要达到的结果", "\n", "得到泛型对应的返回值", "\n", "我自己的理解是：因为泛型类实例化时没有指定泛型，所以在此类实例化时所有泛型（类和方法上定义的）都被加载为Object，但是，并没有找到相关的依据能证明这一点，希望各位帮忙解决"]], "Tag": "程序设计"}
{"Answer": "```\r\n 第二个程序根本不能编译，Info&lt;String&gt;和 Info&lt;Object&gt;没有继承/派生关系。Java使用类型擦除来实现的泛型，所以Info&lt;String&gt;其实是将所有泛型参数替换成String得到的类，而Info&lt;Object&gt;是将所有泛型参数替换成Object得到的类，虽然String和Object有继承关系，但是两个泛型类没有。Java不支持泛型逆变/协变。\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型问题，方法参数问题", ["Java泛型.", "\n代码如下：", "\nclass Info{", "\n private T var;", "\n public void setVar(T var){", "\n this.var=var;", "\n }", "\n public T getVar(){", "\n return this.var;", "\n }", "\n public String toString(){", "\n return this.var.toString();", "\n }", "\n }", "\n下面是第一个测试程序：", "\npublic class GenericsDemo6{", "\n public static void main(String []agrs){", "\n Info info=new Info();", "\n info.setVar(\"lixinghua\");", "\n String str=(String)info.getVar();", "\n System.out.println(info.getVar());", "\n }", "\n }", "\n第二个测试程序；", "\npublic class GenericsDemo8{", "\n public static void main(String []agrs){", "\n Info info=new Info();", "\n fun(info);", "\n }", "\n public static void fun(Info info){", "\n System.out.println(info.getVar());", "\n }", "\n }", "\n为什么第一个测试程序可以运行，而第二个不可以？第一个测试程序没有指定泛型，则默认是Object，这里String可以向上转型为Object,而第二个程序却不可以向上转型为Object？ "]], "Tag": "程序设计"}
{"Answer": "ArrayAdapter 在实例化的时候要传入一个list集合,这个list集合中变可以放你想的泛型", "Konwledge_Point": "泛型机制——模板", "Question": ["如何理解ArrayAdapter：支持泛型操作？", ["还有其他对象或者类支持泛型操作吗？如何理解ArrayAdapter：支持泛型操作？"]], "Tag": "程序设计"}
{"Answer": "做不到，泛型只存在于编译过程，编译后就不存在了，泛型的意义就是为了在编译的时候能检查你的数据类型是不是正确。\r\n如果你想动态实例已个A，为其设置泛型为B 是完全不需要的，就像ArrayList 这个类，其实可以动态的放任何数据，但静态就会编译不通过", "Konwledge_Point": "泛型机制——模板", "Question": ["Java class反射指定实例化泛型类的<T>的问题", ["现在手里有两个class  一个A(泛型类) 一个B", "\n\n", "我想通过实例化泛型类A来为其<.T>指定B这个类型 我该如何操作?"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;请看&amp;#x1f449; &amp;#xff1a;&lt;a href=\"https://blog.csdn.net/weixin_43931625/article/details/107567333\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;easyexcel 异常处理&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["EasyExcel读取表格怎么做泛型？", ["现在有一个表格解析，用的是EasyExce，现在表格可能有两种，两种表格表头不一致，也就是会得到不同的类，但是因为是同一个业务，所以我想把它们做成一个抽象类里面然后写不同的实现，但是现在遇见一个问题，EasyExcel的读取需要传入一个class作为读取出的参数类型，但是现在这么写可以编译，但是会发生类型转换异常，asbdto是我的两个需要映射出来的类的父类，但是它不能转成DTO的运行时我输入的类型。", "请问有什么办法么？DTO是泛型标识，在实现类或者运行时它是AbsDto的子类", "\n", "\n ", "protected", " ", "List", "<", "DTO", "> ", "parse", "(", "InputStream ", "in", "){\n        ", "List", "<", "DTO", "> list=", "new", " ", "CopyOnWriteArrayList", "<>();\n        ", "EasyExcel", ".", "read", "(", "in", ",", "AbsDto", ".", "class", " ,", "new", " ", "AnalysisEventListener", "<", "DTO", ">() {\n            ", "// 每读取一行数据, 该方法会被调用一次", "\n            ", "@Override", "\n            ", "public", " ", "void", " ", "invoke", "(", "DTO testExcel, AnalysisContext analysisContext", ") {\n                list.", "add", "(testExcel);\n            }\n\n            ", "// 全部读取完成被调用", "\n            ", "@Override", "\n            ", "public", " ", "void", " ", "doAfterAllAnalysed", "(", "AnalysisContext analysisContext", ") {\n               log.", "debug", "(", "\"表格读取完成\"", ");\n            }\n        }).", "sheet", "(", "0", ").", "headRowNumber", "(", "0", ").", "doRead", "();\n"]], "Tag": "程序设计"}
{"Answer": "&lt;?&gt;是通配符呀，相当于一个占位符，看下面的例子，你就知道这个符号的意义了：\r\n用通配符，表示List泛型参数是Integer或其子类：\r\n\r\n```\r\n public static void run(List&lt;? extends Integer&gt; list){\r\n\t\t\r\n\t}\r\n```\r\n不用通配符，你能表示吗？", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型＜？>什么泛型参数", ["java泛型＜？>什么泛型参数，是不是无视它，假如可以无视它，为什么还要写上它"]], "Tag": "程序设计"}
{"Answer": "```\r\n /* package whatever; // don't place package name! */\r\n\r\nimport java.util.*;\r\nimport java.lang.*;\r\nimport java.io.*;\r\n\r\nclass Test&lt;U,V extends Test&lt;U,V&gt;&gt; {\r\n\tpublic Test(){\r\n\t\tSystem.out.println(\"success\");\r\n\t}\r\n}\r\n\r\nclass A extends Test&lt;String, A&gt;\r\n{\r\n\t\r\n}\r\n\r\n/* Name of the class has to be \"Main\" only if the class is public. */\r\nclass Ideone\r\n{\r\n\tpublic static void main (String[] args) throws java.lang.Exception\r\n\t{\r\n\t\t// your code goes here\r\n\t\tTest&lt;String, A&gt; t = new Test&lt;String, A&gt;();\r\n\t}\r\n}\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA泛型类的初始化问题", ["有以下类定义：", "\npublic class Test> {", "\n    public Test(){", "\n        System.out.println(\"success\");", "\n    }", "\n}", "\n请问各位如何创建实例？", "\nPS：", "\nTest> test=new Test>();", "\n是不行的"]], "Tag": "程序设计"}
{"Answer": "没听说这些分类。泛型就是泛型。接口、类型、方法都可以用泛型修饰。", "Konwledge_Point": "泛型机制——模板", "Question": ["C#中泛型的分类？泛型类型、泛型结构、泛型方法，还有什么？", ["C#中泛型的分类？泛型类型、泛型结构、泛型方法，还有什么？"]], "Tag": "程序设计"}
{"Answer": "这个链接是mybatis的官方文档，我看了下，没有相应的配置。\r\nhttp://www.mybatis.org/generator/configreference/table.html\r\n\r\n能考虑到2个方法，\r\n1，（不推荐）客户化mybatis generator。源代码（https://github.com/mybatis/generator）\r\n2，（推荐）使用Excel，通过文字列关联，快速生成generator用的xml配置文件代码。\r\n然后把C列生成的代码拷贝到xml配置文件中（图1），用（Ctrl+Shift+F）格式化（图2）\r\n如下图1。\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201707/11/1499775266_119066.jpg)\r\n\r\n如下图2。\r\n![图片说明](https://img-ask.csdn.net/upload/201707/11/1499775444_945043.jpg)", "Konwledge_Point": "泛型机制——模板", "Question": ["Mybatis Generator中的rootInterface怎样批量处理泛型？", ["虽然可以用<>的方式写出尖括号，并且手动写出当前类的名字。", "\n\"com.demo.domain.<User>\"", "\n但是每个表都必须要手写一遍。", "\n请问一下有没有什么批量处理的方法，比如可以引用当前生成类的名字。"]], "Tag": "程序设计"}
{"Answer": "List&lt;T&gt; list = new ArrayList&lt;T&gt;(0); \r\nMethod method = list.class.getMethod(\"get\",null); \r\nClass returnTypeClass = method.getReturnType(); \r\nreturnTypeClass就是返回类型了", "Konwledge_Point": "泛型机制——模板", "Question": ["怎么获取一个泛型List的元素类型", ["如题，有一个泛型 List 不为空，但是长度为0，怎么获取到这个List中的元素类型T是什么？"]], "Tag": "程序设计"}
{"Answer": "Java的泛型，只是为了程序员编写方便，以及在编译的时候做类型检查，在实际运行当中，会把泛型的印记擦掉，相当于一个Object类型。\r\n\r\n同样，泛型方法，也只是为了程序员编写的方便（可以不用做对象转化），以及编译时类型检查而已，运行时和实际的Object类型没有任何差别。\r\n\r\n本例中，你创建的对象，应该是没有带泛型的，实际在调用方法时再带：\r\n1. 对象初始化：new MyTest()。\r\n2. 方法调用：MyTest test = new MyTest(); test.fun&lt;Integer&gt;(1);", "Konwledge_Point": "泛型机制——模板", "Question": ["Java中 非泛型类 定义泛型方法有什么用？", ["Arrays类是非泛型的，但是有一个泛型方法", "\n    public static  Stream stream(T[] array)", "\n\n", "请纹正确的打开方式是怎样的？", "\n\n", "大家都理解错了我的意思了", "\n\n", "我问的是：", "\n\n", "非泛型类里面定义泛型方法的意义是什么，而不是你们告诉我，要让类也是泛型。"]], "Tag": "程序设计"}
{"Answer": "类比一下: public int fun(int t),这个可以理解把，最前面那个T是这个方法的返回类型是T，第二个T指的是你这个fun方法里面传入参数的类型也是T，就这么理解", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型怎么理解？求指教", ["java泛型中，定义泛型方法格式:public  T fun(T t),这几个T分别是什么意思？ 我知道最后一个T是参数，那前面两个T表示什么？哪个表示返回类型？"]], "Tag": "程序设计"}
{"Answer": "你可以看位置就知道了   \r\n\r\n一般方法   如：public String getValue(String str){...}\r\n\r\n第一个T表示的是返回类型，第二个T表示的是参数类型", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型问题，定义泛型方法", ["java泛型中，定义泛型方法格式:public  T fun(T t),这几个T分别是什么意思？ 我知道最后一个T是参数，那前面两个T表示什么？哪个表示返回类型？求高手指教"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;一种方法是在free前手动释放&lt;br /&gt;if(p-&amp;gt;str) {free(p-&amp;gt;str); p-&amp;gt;str &amp;#61; 0;}&lt;br /&gt;free(p);&lt;br /&gt;另一种方法是&amp;#xff0c;给结构体添加析构函数&amp;#xff08;结构体是一种特殊的类&amp;#xff0c;所以可以有析构函数&amp;#xff09;&amp;#xff0c;这样&amp;#xff0c;当p被释放时&amp;#xff0c;结构体中str的内容也自动调用析构函数释放str的内存。如果用析构函数&amp;#xff0c;必须给str初始化。否则析构时会出错&amp;#xff0c;可以通过构造函数来实现&amp;#xff1a;&lt;br /&gt;struct B(){str &amp;#61; 0;}&lt;br /&gt;~struct B()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;if(str) free(str); str &amp;#61; 0;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["c++ 如何free泛型结构体成员指针", ["我自定义了多个结构体，", "例如A结构体如下", "typeset struct A{", "int index;", "char* buf;", "}", "B结构体如下", "typeset struct B{", "char name[8];", "char* str;", "}", "\n", "然后使用模板写了一个队列类，其中写了一个函数来释放队列中的元素,大致意思如下", "\n", "template", "int Queuepop()", "{", "T p=this->front();", "free(p);", "}", "声明两个队列:", "Queue", " qa;", "Queue", " qb;", "使用pop函数，", "很显然free结构体A或者B时候，A里面的buf指针和B里面的str指针并没有释放掉，请问该怎么释放呢？", "能够判别泛型的实际类型然后依次free吗?有没有什么办法free结构体成员变量?", "\n"]], "Tag": "程序设计"}
{"Answer": "为何一定要传个Java参数的类型标记，任何一个有意的标记，通过map自动映射过去不一样啦。例如现在spring3 mvc都是通过url和方法自动映射的\r\n\r\n不管你怎么映射，最后都是成为一个class类型标记，不然是不可能知道转成什么的。\r\n无论你走多少弯路，最后都是一条出路。\r\nMap.put(\"ajson\",\"com.bean.A\")\r\n然后再Class.forname(\"com.bean.A\")\r\n而且这个ajson还得付在json里面，不累么？\r\n传json过来，到底要转成什么样是不知道的，是由编程的人说了算。\r\nLZ现在想法是遍历所有类型，看那个反射能匹配上就用哪个？这样不但要写的代码都得写，而且还要走一圈反射。\r\n有时候不要想着太自动化，如果能够很自动化，j2ee里面就不会动不动就那么多配置文件了。\r\n也许你会说不是可以自定义注解么？\r\n但是对于这么简单的需求来说，再写个注解\r\n\r\n@FromJson(\"ajson\")\r\nclass A(){}\r\n\r\n无非就是用一大段解析注解代码来换取\r\nMap.put(\"ajson\",\"com.bean.A\")\r\nClass.forname(\"com.bean.A\")\r\n这两行代码罢了。\r\n可读性还差，更是没必要。", "Konwledge_Point": "泛型机制——模板", "Question": ["Java通过反射实例化泛型类的问题", ["Java语言中，想通过反射实例化一个抽象类的子类，问题也可以简化点，可以建个类继承这个抽象类，然后实例化子类。", "\n\n", "[code=\"java\"]", "\npublic abstract class MyClass {", "\n    MyClass() {", "\n    }", "\n\n", "}", "\n[/code]", "\n\n", "在代码中可以这么写：", "\n[code=\"java\"]", "\nnew MyClass() {}", "\n[/code]", "\n\n", "但是如果通过反射，怎么把String这个type传进去，或者通过反射获得constructor，怎么把泛型信息传进去：", "\n\n", "下面这个是个错误的写法，只是说明要实现的内容：", "\n[code=\"java\"]", "\nnew MyClass() {", "\n}", "\n[/code]"]], "Tag": "程序设计"}
{"Answer": "Info不是string的派生类，所以调用fun的时候强制转换失败，info为null", "Konwledge_Point": "泛型机制——模板", "Question": ["Java泛型问题，空指针问题", ["程序如下：public class GenericsDemo11{", "\n    public static void main(String []agrs){", "\n        Info i1=new Info();", "\n\n", "if(i1!=null){\n        System.out.println(\"不为null\"）;\n    }\n    fun(i1);\n}\npublic static void fun(Info<? super String> info){\n    System.out.println(info);\n}\n", "\n\n", "}", "\n程序调用fun方法时出现空指针，为什么？i1不是已经分配了堆内存吗，为什么结果会出现空指针错误？"]], "Tag": "程序设计"}
{"Answer": "楼主的问题类似以下问题，\r\n\r\nArrayList&lt;Integer&gt;[] intValues1 = new ArrayList&lt;Integer&gt;[5]; \r\n\r\nArrayList&lt;Integer&gt;[] intValues2 = new ArrayList[5]; \r\n\r\nArrayList&lt;ArrayList&lt;Integer&gt;&gt; intValues3 =  new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); \r\n\r\n第一条语句是编译不通过的，第二条语句能通过的但是会包报类型不安全异常，第三种是完全通过编译的\r\n\r\n第一条语句简单的说就是泛型和数组不能共存，但是说可以使用List代替数组来创建\r\n\r\nArrayList&lt;Class&lt;? super A&gt;&gt; intValues4 =  new ArrayList&lt;Class&lt;? super A&gt;&gt;();", "Konwledge_Point": "泛型机制——模板", "Question": ["关于创建Class泛型数组", ["已知", "\n[code=\"java\"]", "\npublic class B implements A(){};", "\npublic class C implements A(){};", "\n\n", "[/code]", "\n为什么下面的代码不能编译通过", "\n[code=\"java\"]Class<? super A>[] claszz = new Class<? super A>[]{  B.class, C.class };[/code]", "\n假如不使用泛型则可以编译通过", "\n[code=\"java\"]Class[] claszz = new Class[]{  B.class, C.class };[/code]", "\n求解析"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;跟踪异常&amp;#xff0c;顶层都继承Exception&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/850443722046154.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;所以你想拿什么作为泛型&amp;#xff1f;&amp;#xff1f;判读异常有如下两种方式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;假如有个e为Exception\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;方式&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#xff1a;强转\n (RuntimeException) e;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;方式&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#xff1a;instanceOf\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(e instanceOf RuntimeException)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["异常类为什么不能是泛型的", ["请问异常类为什么不能是泛型的......................."]], "Tag": "程序设计"}
{"Answer": "楼上说错了，通用的泛型Dao就是用泛型实现的。\r\n实现的话，你这个方法的类必须是泛型类，如果LZ不熟悉可以先了解下泛型类的概念。\r\npublic class Common&lt;T&gt;\r\n{\r\n  public T queryForObject(String sql, T entity)\r\n  {\r\n    ...\r\n  }\r\n\r\n  public List&lt;T&gt; queryForObject(String sql, T entity)\r\n  {\r\n    ...\r\n  }\r\n}\r\n\r\n这个类要在初始化也就是构造函数中，获取泛型T的类型，通过反射API中可以做到，这里只做提示。关于方法体里面，要使用反射实现，可以写一个反射封装对象的通用方法，把获取的泛型T的具体类型传入里面，强转的那一步也是在反射创建对象之后进行的。\r\n\r\nT entity = (T)entityClass.newInstance(); // entityClass就是从Common获取的T的具体类型，entity是封装后最终的返回对象。返回List&lt;T&gt;依次类推。\r\n\r\n这样一来一个简单的自动封装就实现了，希望对你有所帮助", "Konwledge_Point": "泛型机制——模板", "Question": ["用java泛型方法写一个多用途方法??那位大哥出下主意!??", ["  对于这个方法是一个java泛型方法,两个参数:的一个是Sql语句,第二个javaBean对象!\n  主要功能就是传SQL语句,随便传javaBean的对象,要和数据库进行连接,javaBean里的字段要和数据库里的列进行比较,不管是传入什么什么类型的javaBean对象都要返回传入对象的类型,不可以所以Object对象来进行强转!\n   随便带上单元测试,非常感谢!\n"]], "Tag": "程序设计"}
{"Answer": "都不明白 楼主要实现啥 根据你最后补充的想到的\r\n \r\n\r\npublic class Test {\r\n\r\n    public void test(Class&lt;?&gt; clazz){ \r\n        java.util.List&lt;Class&lt;?&gt;&gt; list = new java.util.ArrayList&lt;Class&lt;?&gt;&gt;(); \r\n        list.add(clazz);\r\n        \r\n        for (Class&lt;?&gt; clz : list) {\r\n            System.out.println(\"---\" + clz.getName());\r\n        }\r\n    } \r\n\r\n    public static void main(String[] args){ \r\n        try {\r\n            Test t = new Test(); \r\n            t.test(Class.forName(\"java.lang.String\")); \r\n            t.test(java.util.List.class);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    } \r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["List 添加 Class 泛型", ["public void test(Class clazz)", "\n{", "\n   List list = new ArrayList();", "\n}", "\n这个clazz是从别的地方传过来的，可不可以指定list只能存储这个Class", "\n\n", "我用 List list = new ArrayList(); 并且在类名后加上 编译可以通过，但是运行时在后面还可以给list  add不同于clazz的对象，不知道这是为什么？", "\n\n", "[b]问题补充：[/b]", "\nList list = new ArrayList(); ", "\n是错误的 ", "\n<>中应该是类型.并不是实例clazz是Class类的实例所以你上面的代码是错误的. ", "\n\n", "这种时候应该使用接口来规范类型", "\n\n", "那我怎样做才能实现这个功能呢，网上说用反射，不过还没搞清楚。", "\n\n", "Thanks in advance!", "\n[b]问题补充：[/b]", "\npublic class Test {", "\n\n", "public void test(Class<T> clazz){\n\n    List<Class<T>> list = new ArrayList<Class<T>>();\n\n    Object str = \"aa\";      \n    list.add((Class<T>) str);       \n}\n\npublic static void main(String[] args){\n\n    Test t = new Test();        \n    t.test(String.class);\n\n}\n", "\n\n", "}", "\n差不多是这个样子的，但运行的时候会出\"java.lang.ClassCastException: java.lang.String\", 不知道为什么", "\n[b]问题补充：[/b]", "\n其实我就是想", "\nList list = new ArrayList(); 的时候 这个list中只能存放传进去的指定的class， 比如String或者其他自定义的类。", "\n谢谢大家了。", "\n[b]问题补充：[/b]", "\n比如 Test t = new Test();", "\n    t.test(String.class);", "\n\n", "这时list.add(\"abc\");是可以的", "\n但list.add(new Timestamp(100))则不行"]], "Tag": "程序设计"}
{"Answer": "c++的泛型编程和容器是通过stl实现的\r\n这说反了，是stl的容器靠模板实现，不是模板靠stl实现。", "Konwledge_Point": "泛型机制——模板", "Question": ["java的泛型编程如何实现", ["c++的泛型编程和容器是通过stl实现的，请问java的泛型是如何实现的"]], "Tag": "程序设计"}
{"Answer": "&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/baiyun8789/article/details/46572969'&gt;java泛型中extends 和 super的区别&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/mzm2438975656/article/details/17438039'&gt;java中list，map使用泛型和不使用的区别&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/expleeve/article/details/7964596'&gt;java泛型中的extends和super&lt;/a&gt;&lt;br/&gt;----------------------同志你好，我是CSDN问答机器人小N，奉组织之命为你提供参考答案，编程尚未成功，同志仍需努力！", "Konwledge_Point": "泛型机制——模板", "Question": ["Java泛型上下限super和extendS的使用区别，谢谢", ["class DemoF{", "\n\n", "public static void printA(Collection<?super Cat>  c){ 相同的方法体，例如打印集合}", "\npublic static void printB(Collection<?extend Animal> c){相同的方法体，例如打印集合}", "\npublic static void main(String[ ]  args){", "\nCollection<?> co = new linkedList<?>()", "\nco.add(new Animal(5));", "\nco.add(new Cat(6));", "\nprintA(co);", "\nprintB(co);//请问该两种方法参数泛型即super和extend的使用有何区别？即泛型的上下限定的区别？谢谢亲", "\n}", "\n}", "\nclass Animal{", "\nint age;", "\npublic Animal(int age){", "\nthis.age =age;", "\n}", "\n}", "\nclass Cat extends Animal{", "\nint age;", "\npublic Cat(int age){", "\nthis.age =age;", "\n}", "\n}"]], "Tag": "程序设计"}
{"Answer": "等价于 Dictionary&lt;Object,Object&gt; labelTable = new Hashtable&lt;Object,Object&gt;();", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型定义语法疑问", ["请问下面泛型定义：\n", "\n\n", "“Dictionary labelTable = new Hashtable<>();”", "\n\n", "两个参数是什么意思？没有看懂这句泛型定义。", "\n\n", " ，为什么是两个参数？一般泛型例如List list = new AarryList,<>中的是参数类型。两个是什么意思？ "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.如果敌人身上的脚本B传入了不同的泛型参数&amp;#xff0c;但是他们基类相同的话可以直接获取基类向下转型到目标类型即可&lt;br /&gt;2.如果敌人脚本B不是同一基类的话&amp;#xff0c;就可以通过反射获取目标类型&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;/// 用反射根据基类类型找到所有子类\n/// &amp;lt;/&lt;span class=\"hljs-keyword\"&gt;summary&lt;/span&gt;&amp;gt;\n/// &amp;lt;&lt;span class=\"hljs-keyword\"&gt;returns&lt;/span&gt;&amp;gt;The decode &lt;span class=\"hljs-keyword\"&gt;by&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;type&lt;/span&gt;.&amp;lt;/&lt;span class=\"hljs-keyword\"&gt;returns&lt;/span&gt;&amp;gt;\n/// &amp;lt;param &lt;span class=\"hljs-type\"&gt;name&lt;/span&gt;&amp;#61;&amp;#34;baseType&amp;#34;&amp;gt;Base &lt;span class=\"hljs-keyword\"&gt;type&lt;/span&gt;.&amp;lt;/param&amp;gt;\n&lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; static List&amp;lt;&lt;span class=\"hljs-keyword\"&gt;Type&lt;/span&gt;&amp;gt; GetDecodeByType(&lt;span class=\"hljs-keyword\"&gt;Type&lt;/span&gt; baseType)\n{\n    List&amp;lt;&lt;span class=\"hljs-keyword\"&gt;Type&lt;/span&gt;&amp;gt; res &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; List&amp;lt;&lt;span class=\"hljs-keyword\"&gt;Type&lt;/span&gt;&amp;gt;();\n    &lt;span class=\"hljs-keyword\"&gt;Type&lt;/span&gt;[] allType &amp;#61; Assembly.GetExecutingAssembly().GetTypes();\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; allType.Length; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (IsSubClassOf(allType[i], baseType))\n        {\n            //&lt;span class=\"hljs-keyword\"&gt;Debug&lt;/span&gt;.Log(&amp;#34;协议基类:&amp;#34;&amp;#43; allType[i] );\n            res.&lt;span class=\"hljs-keyword\"&gt;Add&lt;/span&gt;(allType[i]);\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["unity能否用脚本获取任意泛型参数的脚本?", ["角色身上有一个脚本A，我想让这个脚本A获取角色所触碰的敌人所挂载的脚本B，但是不同的敌人身上的脚本B传入了不同的泛型参数。有没有办法让脚本A获取任意泛型参数的脚本B?"]], "Tag": "程序设计"}
{"Answer": "这还是泛型的规范问题，\r\n如果你直接用T的话，它能得到的确定类型就只有Object,\r\n\r\n你想想，对于这些一个类型T extends Serializable，没有明确指定类型之前，你是不可能知道T是什么类型，唯一能知道的就是T一定是Serializable类型，\r\n\r\n对于只有T的情况，有个隐式的继承啊T extends Object ，道理同上\r\n\r\n这样你应该就能理解OGNL为什么会出现这种情况", "Konwledge_Point": "泛型机制——模板", "Question": ["ognl不支持泛型？", ["我为entity写了这样的接口", "\npublic interface Entity<T extends Serializable>{\n\n", "public T getId();\n\npublic void setId(T id);\n", "\n\n", "}", "然后写了一个实现这个接口的user entity", "\npublic class User implements Entity<Long> {\n\n", "private Long id;\nprivate String name;\n\npublic Long getId() {\n    return id;\n}\npublic void setId(Long id) {\n    this.id = id;\n}\npublic String getName() {\n    return name;\n}\npublic void setName(String name) {\n    this.name = name;\n}\n", "\n\n", "}", "然后当我用ognl设置user id 的值", "\nUser user = new User();", "\nuser.setName(\"test\");", "\nOgnl.setValue(\"id\", user, \"1\");", "运行这段代码总是抛错，说不能把string转换成Long类型", "我发现问题的原因是，ognl读取user.id的write method时，得到的方法是", "\nUser.setId(java.io.Serializable)", "而不是", "\nUser.setId(java.lang.Long)", "所以ognl没有把字符串“1”转换成long型就直接转换调用user.setId方法了，所以抛出了java.lang.ClassCastException", "有人遇到这种情况么？", "怎么解决？", "问题补充：", "引用", "泛型的规范里，好像只能用反射的方式得到<T extends Serializable>时，得到的是Serializable，而没有得到T，导致这种情况", "引用", "\n", "那按照上面的说法，能不能不用 T extends Serializable？直接一个T ", "因为Long 和 String 类型都是Serializable的啊", "\n", "我试过了，也不行，我debug看到的ognl得到id的write methods是User.setId(java.lang.Object)", "其实本来一直都工作好好的，后来就突然出现上面所说的错误了。", "我测试了很久，发现出现了很多莫名其妙的情况，无法解释。", "现在唯有抛弃这种泛型的设计了。", "去掉了Entity接口，一切正常……", "郁闷，实在搞不懂其中的缘故……"]], "Tag": "程序设计"}
{"Answer": "```\r\n T GetEntity&lt;T&gt;() where T : class, new()\r\n {\r\n if (this.Value == null)\r\n this.Value = new T();\r\n return this.Value;\r\n }\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["一个泛型的问题?C#泛型代码怎么修改？", ["C#泛型代码怎么修改？", "\nvoid GetEntity()", "\n{", "\n    if (this.Value == null)", "\n        this.Value = new T();", "\n    return new T();", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Use &lt;code&gt;interface{}&lt;/code&gt; for this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type SqlColumn struct {\n    name string\n    columnType interface{}\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["在这种简单情况下如何解决缺少泛型的问题", ["\n\n", "I am creating a simple ", "sql", " mapper that allows me to create sql mappings at run time because i have no idea how the database schema will be like.", "\n\n", "consider the following struct:", "\n\n", "type SqlColumn struct {\n    name string\n    columnType ? //int float etc...\n}\n", "\n\n", "what type should i use for the ", "columnType", " field?", "\n\n", "the only way i could think of is to use strings or a const and handle the rest using reflection, am i on the right path?", "\n    "]], "Tag": "程序设计"}
{"Answer": "作为初学者的话，理解泛型主要的两个用途，一个是封装和类型不相关的数据结构（比如列表、队列、元组），一个是封装和类型不相关的算法（比如排序子、比较子、委托）", "Konwledge_Point": "泛型机制——模板", "Question": ["c#泛型类用法                             ", ["谢谢", "\n请用自己话说，官方的定义我不理解。", "\n泛型方法我知道，参数数据类型先不确定，用的时候指定。", "\n那么泛型类 class xxxx 这是什么意思，用来干嘛"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://link.csdn.net/?target&amp;#61;https://blog.csdn.net/margin_0px/article/details/82906596\" id=\"md_link_card\" class=\"md_link_card\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;\n  &lt;span class=\"md_link_title\"&gt;https://blog.csdn.net/margin_0px/article/details/82906596&lt;/span&gt;\n  \n  &lt;span class=\"md_flex_card\"&gt;\n  &lt;span class=\"md_link_img icon iconfont icon-lianjie\"&gt;&lt;/span&gt;\n    &lt;span class=\"flex-1\"&gt;\n      &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/margin_0px/article/details/82906596&lt;/span&gt;\n    &lt;/span&gt;\n  &lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["关于java泛型T和通配符？的疑问", ["近期重新复习了泛型和通配符的相关知识，莫名的想到了一个问题：“？”无界通配符的作用在于接收任意的泛型类型，所以我定义了两个方法：1）泛型方法getListAnother() 使用泛型T；2）普通方法getList()使用无界通配符？；两者的作用都是接收包含任意类型的List，并打印类型信息，然后返回这个List。", "\n", "这两个方法输出一模一样，所以在一定程度上泛型T是可以完全代替无界通配符？的嘛？", "\n", "\n```java\nimport java.util.*;\n", "public", " ", "class", " ", "Test", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String[] args", ")", " {\n        ArrayList<String> strList = ", "new", " ArrayList<>();\n        ArrayList<Integer> intList=", "new", " ArrayList<>();\n        strList.", "add", "(", "\"123\"", ");\n        intList.", "add", "(", "12", ");\n        getList(intList);\n        getList(strList);\n        getListAnother(intList);\n        getListAnother(strList);\n    }\n    ", "public", " ", "static", " List ", "getList", "(", "List<?> list", ")", "{\n        System.", "out", ".println(", "\"? 方法里的?类型是：\"", "+list.", "get", "(", "0", ").getClass().getName());\n        ", "return", " list;\n    }\n    ", "public", " ", "static", " <T> ", "List ", "getListAnother", "(", "List<T> list", ")", "{\n        System.", "out", ".println(", "\"T 方法里的T类型是：\"", "+list.", "get", "(", "0", ").getClass().getName());\n        ", "return", " list;\n    }\n}\n\n", "\n", "输出结果", "\n", "? 方法里的?类型是：java.lang.Integer\n? 方法里的?类型是：java.lang.String\n", "T", " 方法里的", "T", "类型是：java.lang.Integer\n", "T", " 方法里的", "T", "类型是：java.lang.String\n\n"]], "Tag": "程序设计"}
{"Answer": "```\r\nTask&lt;ApiResult&lt;Page&lt;T&gt;&gt;&gt; GetfllbAsync&lt;T&gt;(int shopid);\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["c# 接口方法返回泛型定义问题", ["using Sc.Common;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq.Expressions;\nusing System.Threading.Tasks;\nusing Sc.core.Model.Shop;\nusing Sc.Service.DtoModel.Shop;\n\nnamespace Sc.Service.Interfaces\n{\n    /// <summary>\n    /// 商家分类接口\n    /// </summary>\n    public interface IShopfl\n    {\n        #region 商家分类相关操作\n        /// <summary>\n        /// 获取商家分类列表\n        /// </summary>\n        /// <param name=\"shipid\">商家的id</param>\n        /// <returns></returns>\n        Task<ApiResult<Page<sj_flb>>> GetfllbAsync(int shopid);\n", "\n\n", "接口代码如上 这个代码没有问题 ，只是我想定义一个基础接口然后其它接口从基础接口继承 其中有一个问题 就是 Page中的 sj_flb 我想定义 泛型怎么定义啊  ", "\n\n", "Task<ApiResult<Page<T>>> GetfllbAsync(int shopid);\n```我这样写不行。\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;? extends Number 这种叫做协变&amp;#xff0c;协变只能用在引用上&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java泛型类通配符类型", ["\n        ", "// 第一种", "\n        Generic<? extends Number> g9;\n        Generic<", "Float", "> g10 = ", "new", " ", "Generic", "<>();\n        g10.", "set", " = ", "new", " ", "Float", "[]{", "1", "f, ", "3", "f, ", "5", "f};\n        g9 = g10;\n        g9.show();\n\n        ", "// 第二种", "\n        Generic<? extends Number> g11 = ", "new", " ", "Generic", "<", "Float", ">();\n        g11.", "set", " = ", "new", " ", "Float", "[]{", "1", "f, ", "4", "f};\n", "\n", "请问，为什么第二种写法不行呀", "\n", "如果把 Float 换成 Double 或者 Integer，可以正常编译运行。为什么同为 Number 的子类，Float 就不行呢", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;One solution would be to &lt;a href=\"https://docs.google.com/document/d/1V03LUfjSADDooDMhe-_K59EgpTEm3V8uvQRuNMAEnjg/edit\"&gt;&lt;code&gt;go generate&lt;/code&gt;&lt;/a&gt; your &lt;code&gt;P()&lt;/code&gt; function, one for each concrete type you need to work with.&lt;br&gt;\nSee examples in:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;\"&lt;a href=\"http://htmlpreview.github.io/?http://www.onebigfluke.com/2014/12/generic-programming-go-generate.html\"&gt;Generic programming in Go using \"&lt;code&gt;go generate&lt;/code&gt;\"&lt;/a&gt;\".&lt;/li&gt;\n&lt;li&gt;\"&lt;a href=\"https://github.com/joeshaw/gengen\"&gt;joeshaw/gengen&lt;/a&gt;\"&lt;/li&gt;\n&lt;li&gt;\"&lt;a href=\"https://github.com/cheekybits/genny\"&gt;cheekybits/genny&lt;/a&gt;\"&lt;/li&gt;\n&lt;li&gt;\"&lt;a href=\"https://github.com/clipperhouse/gen\"&gt;clipperhouse/gen&lt;/a&gt;\"&lt;/li&gt;\n&lt;li&gt;\"&lt;a href=\"https://medium.com/@motemen/achieving-type-generic-functions-in-go-without-using-reflections-40bc06111970\"&gt;Achieving type generic functions in Go, without using reflections&lt;/a&gt;\"&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;That would make calling those lib functions easier, since the concrete P () implementations generated would use the right type instead of interface{}.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["在Go Lang中编写没有泛型的泛型函数", ["\n\n", "I know that Go will not have generics in the future and there are some recommendations to replace them by other constructs. But with my example below I got stuck. ", "\n\n", "func P(any interface{}, err error) (interface{}) {\n    if err != nil {\n        panic(\"error: \"+ err.Error())\n    }\n    return any\n}\n", "\n\n", "As you might guess, I'm trying to just fail on any error and want to put ", "P()", " just around any function that is returning two results and the second is an error. This is working fine, but ", "any", " is losing it's type information and is only an empty interface in the result.", "\n\n", "As I'm also calling lib functions I don't see a way to address this with Interfaces or Reflection.", "\n\n", "Any ideas? Am I totally on the wrong track or close to the goal?", "\n    "]], "Tag": "程序设计"}
{"Answer": "首先，这端代码本质上是定义了一个ThreadLocal变量，等价于：\r\n\r\n```\r\n private static ThreadLocal&lt;Integer&gt; counterContext = new ThreadLocal&lt;Integer&gt;()\r\n```\r\n这样的话它使用的就是ThreadLocal的默认的initialValue方法指定的值。\r\n其次，你这里的代码相等于实例化了一个ThreadLocal类型的匿名类，并重写了它的initialValue方法，这里的return 10并没有传给谁，而是整个方法声明需要返回一个初始化值。这个方法会在某个线程第一次调用get操作时返回。API的说明是这样的：\r\n\r\n```\r\n Returns the current thread's \"initial value\" for this\r\n     * thread-local variable.  This method will be invoked the first\r\n     * time a thread accesses the variable with the {@link #get}\r\n     * method,\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["关于java的匿名内部类和泛型", ["public class Counter {", "\n\n", "private static ThreadLocal<Integer> counterContext = new ThreadLocal<Integer>(){\n    protected synchronized Integer initialValue(){\n        return 10;\n    }\n};\n", "\n\n", "}", "\n\n", "请教下上面这个类当中的这个匿名内部类起了什么作用，这个return 的10是传给了谁了呢？另外关于ThreadLocal中的这个泛型的用法不是很理解，我对泛型的理解仅仅是 ArrayList这类集合的泛型，说明里面只能存放String，对于ThreadLocal这种类的泛型又是什么意思呢？是ThreadLocal里面的某一个成员变量只能是Integer吗？"]], "Tag": "程序设计"}
{"Answer": "java不支持数组类型的协变，虽然AnyType是compareable，但是AnyType[]并不是compareable[]\r\n你只能遍历原来的数组，分别调用元素的类型转换。", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型异常，如何解决", ["public static >  AnyType[] mergesort(AnyType[] a,AnyType[] b)", "\n    {", "\n        int i=0;", "\n        int j=0;", "\n        int index=0;", "\n        AnyType[] tmp=(AnyType[]) new Comparable[a.length+b.length];", "\n        while(i<a.length&&j<b.length){", "\n            if(a[i].compareTo(b[j])<0)", "\n            {", "\n                tmp[index]=a[i];", "\n                i++;", "\n                index++;", "\n            }", "\n            else{", "\n                tmp[index]=b[j];", "\n                j++;", "\n                index++;", "\n            }", "\n        }", "\n        return tmp;", "\n     }", "\n\n", "public static void main(String[] args){\n    Integer a[]={1,13,24,26};\n    Integer b[]={2,15,27,28};\n    Integer[] tmp= (Integer[])mergesort(a, b);\n    System.out.println(tmp);\n}\n}\n", "\n\n", "结果：Exception in thread \"main\" java.lang.ClassCastException: [Ljava.lang.Comparable; cannot be cast to [Ljava.lang.Integer;", "\n    at testcc.mergeSort.main(mergeSort.java:58)", "\n求问如何解决"]], "Tag": "程序设计"}
{"Answer": "为了java版本的向下兼容。否则一些老代码就不能再新jdk中跑了。", "Konwledge_Point": "泛型机制——模板", "Question": ["ja v a 泛型中的擦除问题", ["java泛型是后加入的概念，既然“擦除”机制不合理，为何不对java进行修改呢？"]], "Tag": "程序设计"}
{"Answer": "泛型在1.7 之后就可以省略了，有泛型就可以更精确一点，所以一般都是带着泛型写的", "Konwledge_Point": "泛型机制——模板", "Question": ["java里前后泛型参数问题", ["Listlist=new ArrayList<>()和Listlist1=new ArrayList()有什么区别", "\nList list=new ArrayList();在Android Studio里这样写编译器告诉我后面的String可以省略？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;All Go types implement the empty interface &lt;code&gt;interface{}&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Foo struct {\n   data interface{}\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The empty interface is covered in  &lt;a href=\"https://tour.golang.org/methods/14\" rel=\"noreferrer\"&gt;A Tour of Go&lt;/a&gt;, &lt;a href=\"https://blog.golang.org/laws-of-reflection\" rel=\"noreferrer\"&gt;The Laws of Reflection&lt;/a&gt; and the &lt;a href=\"https://golang.org/ref/spec#Interface_types\" rel=\"noreferrer\"&gt;specification&lt;/a&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["在go中声明泛型类型对象", ["\n\n", "Is there a generic type ", "Object", " in golang similar to other languages that can be assigned any kind of payload?", "\n\n", "type Foo struct {\n    data object\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "你想要得到的结果是什么类型就返回什么类型", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型集合的遍历，返回什么类型", ["import java.lang.reflect.Field;", "\nimport java.sql.Connection;", "\nimport java.sql.PreparedStatement;", "\nimport java.sql.ResultSet;", "\nimport java.sql.ResultSetMetaData;", "\nimport java.sql.SQLException;", "\nimport java.util.ArrayList;", "\nimport java.util.List;", "\n\n", "import com.sun.org.apache.commons.beanutils.BeanUtils;", "\n\n", "public class DBOperateTUtilts {", "\n\n", "方法1", "\n    public static  List query(String sql, Class clazz) {", "\n\n", "    Connection conn = null;\n    PreparedStatement pstmt = null;\n    ResultSet rs = null;\n    Object tempStr = null;\n    List<T> list = new ArrayList<T>();\n    try {\n        conn = DBConnectUtils.getConnection();\n        pstmt = conn.prepareStatement(sql);\n        rs = pstmt.executeQuery();\n        while (rs.next()) {\n            // newInstance实际上是把new这个方式分解为两步,即，首先调用class的加载方法加载某个类，然后实例化。\n            // 我们可以在调用class的静态加载方法forName时获得更好的灵活性，提供给了我们降耦的手段。\n            // newInstance: 弱类型。低效率。只能调用无参构造。\n            // new: 强类型。相对高效。能调用任何public构造。\n            E obj = clazz.newInstance();\n            if (obj instanceof String) {\n                // ResultSet的下标从1开始\n                obj = (E) rs.getString(1);\n            } else {\n                // Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限\n                // getDeclaredFields()返回Class中所有的字段，包括私有字段\n                // getFields 只返回公共字段，即有public修饰的字段\n                // field，域是一种属性，可以是一个类变量，一个对象变量，一个对象方法变量或者是一个函数的参数。\n                Field[] fields = obj.getClass().getDeclaredFields();\n                // 遍历域\n                for (Field field : fields) {\n                    try {\n                        // 反射获取对象成员的字段值\n                        tempStr = rs.getObject(field.getName());\n                    } catch (SQLException e) {\n                        tempStr = \"\";\n                    }\n                    // 置是否允许访问,而不是修改原来的访问权限修饰词\n                    field.setAccessible(true);\n                    // 把对象的属性数据封装到对象中\n                    BeanUtils.setProperty(obj, field.getName(), tempStr);\n                }\n            }\n            list.add(obj);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    } finally {\n        DBCloseUtils.closeCSR(conn, pstmt, rs);\n    }\n    return list;\n}\n", "\n\n", "方法2", "\n    public static  List query(String sql, Class clazz,", "\n            Object[] parameters) {", "\n\n", "    Connection conn = null;\n    PreparedStatement pstmt = null;\n    ResultSet rs = null;\n    ResultSetMetaData metaData = null;\n    List<T> list = new ArrayList<T>();\n    int index = 1;\n    try {\n        pstmt = conn.prepareStatement(sql);\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    if (parameters != null && parameters.length != 0) {\n        for (int i = 0; i < parameters.length; i++) {\n            try {\n                // pstmt.setObject(第几个参数, 替换成什么)；\n                pstmt.setObject(index, parameters[i]);\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    try {\n        rs = pstmt.executeQuery(sql);\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    // 封装resultset\n    try {\n        metaData = rs.getMetaData();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }// 取出列的信息\n    int columnLength = 0;\n    try {\n        columnLength = metaData.getColumnCount();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }// 获取列数\n    try {\n        while (rs.next()) {\n            // 通过反射机制创建一个对象\n            T result = clazz.newInstance();\n            for (int i = 0; i < columnLength; i++) {\n                String metaDataKey = metaData.getColumnName(i + 1);\n                Object resultsetValue = rs.getObject(metaDataKey);\n                if (resultsetValue == null) {\n                    resultsetValue = \"\";\n                }\n                Field field = clazz.getDeclaredField(metaDataKey);\n                field.setAccessible(true);\n                field.set(result, resultsetValue);\n            }\n            list.add(result);\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n    return list;\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给你改好了&amp;#xff0c;名字写错了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt; &lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;Generricity&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-symbol\"&gt;E&lt;/span&gt;&amp;gt;{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;abstract&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; method(E e);\n}\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;GenerricityImpl1&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;E&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-symbol\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;Generricity&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;E&lt;/span&gt;&amp;gt;{\n \n    &amp;#64;Override\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; method(E e) {\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(e);\n \n    }\n}\n \n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;Gen2&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;implements&lt;/span&gt;  &lt;span class=\"hljs-symbol\"&gt;Generricity&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;Integer&lt;/span&gt;&amp;gt;{\n \n    &amp;#64;Override\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; method(Integer &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;erger) {\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;erger);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/299127243456111.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型接口的普通实现类的错误", ["问题遇到的现象和发生背景", "\n", "泛型接口学习。", "\n", "问题相关代码，请勿粘贴截图", "\n", "interface", " ", "Generricity", " <", "E", ">{\n    ", "public", " ", "abstract", " ", "void", " method(E e);\n}\n", "class", " ", "GenerricityImpl1", "<", "E", "> ", "implements", " ", "Generricity", "<", "E", ">{\n\n    @Override\n    ", "public", " ", "void", " method(E e) {\n        System.", "out", ".println(e);\n\n    }\n}\n\n", "class", " ", "Gen2", " ", "implements", "  ", "Generricity", "<", "Interger", ">{\n\n    @Override\n    ", "public", " ", "void", " method(Interger ", "int", "erger) {\n        System.", "out", ".println(", "int", "erger);\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "编译时就报错了，Gen2的实现类，在Interger那里报错。Gen2普通实现类报错", "\n", "我的解答思路和尝试过的方法"]], "Tag": "程序设计"}
{"Answer": "PK 只是一个代名词，随便一个类就行比如 这样：\r\n//定义名为ex_class的类模板\r\ntemplate &lt;class T1,class T2&gt;  class ex_class\r\n{\r\n    T1 value1;\r\n    T2 value2;\r\npublic:\r\n    ex_class(T1 v1,T2 v2) {\r\n        value1=v1;\r\n        value2=v2;\r\n    }\r\n    void set_value(T1 v1,T2 v2) {\r\n        value1=v1;\r\n        value2=v2;\r\n    }\r\n    void put_value(void) {\r\n        cout&lt;&lt;\"valu1=\"&lt;&lt;value1&lt;&lt;endl;\r\n        cout&lt;&lt;\"valu2=\"&lt;&lt;value2&lt;&lt;endl;\r\n    }\r\n};", "Konwledge_Point": "泛型机制——模板", "Question": ["有一个泛型类 classname<T,PK> 如何实例化", ["有一个泛型类 classname 如何实例化", "\nPK 如何使用"]], "Tag": "程序设计"}
{"Answer": "没有任何关系的两个概念，多态讲的是在继承层次上关系。\r\n\r\n泛型是讲的一个类或者方法的 对于类型 的通用性", "Konwledge_Point": "泛型机制——模板", "Question": ["多态和泛型有关系么", ["可以这样理解么：泛型是针对方法和类的", "\n而多态是针对对象的"]], "Tag": "程序设计"}
{"Answer": "```\r\n public static &lt;T extends Number&gt; double avg(T[] arr) {\r\n    double sum = 0;\r\n    double avg;\r\n    for (int i = 0; i &lt; arr.length; i++) {\r\n    sum += arr[i].doubleValue();\r\n    }\r\n    avg = sum / arr.length;\r\n    return avg;\r\n}\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["用泛型求一个数组的平均值", ["java中怎么用泛型来求一个数组的平均值啊，我是新手，求大神解答"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;泛型是创建对象的时候指定的&amp;#xff0c;不是直接实现的&amp;#xff0c;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;package&lt;/span&gt; com.fanxing;\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * 泛型抽象类\n * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;author&lt;/span&gt; Jiyh\n *\n * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; &amp;lt;T&amp;gt;\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;abstract&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-title\"&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;abstract&lt;/span&gt; &lt;span class=\"hljs-function\"&gt;T &lt;span class=\"hljs-title\"&gt;mag&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(T t)&lt;/span&gt;&lt;/span&gt;;\n}\n\n\n&lt;span class=\"hljs-keyword\"&gt;package&lt;/span&gt; com.fanxing;\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * \n * 继承A类\n *\n * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; &amp;lt;T&amp;gt;\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;B&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title\"&gt;T&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title\"&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * B继承了A&amp;#xff0c;并不实现具体泛型\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-function\"&gt;T &lt;span class=\"hljs-title\"&gt;mag&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(T t)&lt;/span&gt; &lt;/span&gt;{\n        \n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; t;\n    }\n\n}\n\n&lt;span class=\"hljs-keyword\"&gt;package&lt;/span&gt; com.fanxing;\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * 示例对象\n * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;author&lt;/span&gt; Jiyh\n *\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FanXing&lt;/span&gt; &lt;/span&gt;{\n\n}\n\n&lt;span class=\"hljs-keyword\"&gt;package&lt;/span&gt; com.fanxing;\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * 示例类1\n * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;author&lt;/span&gt; Jiyh\n *\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;FanXing1&lt;/span&gt; &lt;/span&gt;{\n\n}\n\n&lt;span class=\"hljs-keyword\"&gt;package&lt;/span&gt; com.fanxing;\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * 测试类\n * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;author&lt;/span&gt; Jiyh\n *\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Test&lt;/span&gt; &lt;/span&gt;{\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-comment\"&gt;//创建对象时&amp;#xff0c;指定泛型具体类是FanXing&lt;/span&gt;\n        A&amp;lt;FanXing&amp;gt; fx &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; B&amp;lt;FanXing&amp;gt;();\n        \n        &lt;span class=\"hljs-comment\"&gt;//创建对象时&amp;#xff0c;也可以指定泛型为 FanXing1&lt;/span&gt;\n        A&amp;lt;FanXing1&amp;gt; fx1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; B&amp;lt;FanXing1&amp;gt;();\n        \n        &lt;span class=\"hljs-comment\"&gt;//创建对象时&amp;#xff0c;也可以指定泛型为 String&lt;/span&gt;\n        A&amp;lt;String&amp;gt; fxString &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; B&amp;lt;String&amp;gt;();\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["抽象泛型类，继承了要如何实现实现这个泛型", ["public abstract class a ", "{", "   public abstract N mag(N t);", "}", "\n", "不懂，继承了这个抽象类要如何实现里面的泛型"]], "Tag": "程序设计"}
{"Answer": "String字符串就已经实现了Comparator 接口。所以不用传入一个Comparator\r\n直接写成：\r\nTreeMap&lt;String,Double&gt; tm = new TreeMap&lt;String,Double&gt;();", "Konwledge_Point": "泛型机制——模板", "Question": ["下面Java代码中怎么添加泛型", ["import java.util.* ;", "\n\n", "class Employee implements Comparator {", "\n        public int compare (Object a, Object b) {", "\n                int k ;", "\n                String aStr, bStr ;", "\n                aStr = (String) a ;", "\n                bStr = (String) b ;", "\n                k = aStr.compareTo(bStr) ;", "\n                if (k == 0)", "\n                    return aStr.compareTo(bStr) ;", "\n                else", "\n                    return k ;", "\n            }", "\n    }", "\n\n", "public class TestDemo {", "\n        public static void main (String args[]) {", "\n                TreeMap tm = new TreeMap (new Employee()) ;", "\n                tm.put(\"Z、张三\", new Double(3534.34)) ;", "\n                tm.put(\"L、李四\", new Double(126.22)) ;", "\n                tm.put(\"W、王五\", new Double(1578.40)) ;", "\n                tm.put(\"Z、赵六\", new Double(99.62)) ;", "\n                tm.put(\"S、孙七\", new Double(-29.08)) ;", "\n                Set set = tm.entrySet() ;", "\n                Iterator itr = set.iterator() ;", "\n                while (itr.hasNext()) {", "\n                        Map.Entry me = (Map.Entry) itr.next() ;", "\n                        System.out.print(me.getKey() + \":\") ;", "\n                        System.out.println(me.getValue()) ;", "\n                    }", "\n                System.out.println() ;", "\n                double balance = ((Double) tm.get(\"Z、张三\")).doubleValue() ;", "\n                tm.put(\"Z、张三\", new Double(balance + 2000)) ;", "\n                System.out.println(\"张三最新的资金数为：\" + tm.get(\"Z、张三\")) ;", "\n            }", "\n    }"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;I have to ask a question in return: is your &lt;code&gt;GenSet&lt;/code&gt; \"checked\" or \"unchecked\"?\nWhat does that mean?&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Checked&lt;/strong&gt;: &lt;em&gt;strong typing&lt;/em&gt;. &lt;code&gt;GenSet&lt;/code&gt; knows explicitly what type of objects it contains (i.e. its constructor was explicitly called with a &lt;code&gt;Class&amp;lt;E&amp;gt;&lt;/code&gt; argument, and methods will throw an exception when they are passed arguments that are not of type &lt;code&gt;E&lt;/code&gt;. See &lt;a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#checkedCollection%28java.util.Collection,%20java.lang.Class%29\" rel=\"noreferrer\"&gt;&lt;code&gt;Collections.checkedCollection&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;-&amp;gt; in that case, you should write:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public class GenSet&amp;lt;E&amp;gt; {\n\n    private E[] a;\n\n    public GenSet(Class&amp;lt;E&amp;gt; c, int s) {\n        // Use Array native method to create array\n        // of a type only known at run time\n        @SuppressWarnings(\"unchecked\")\n        final E[] a = (E[]) Array.newInstance(c, s);\n        this.a = a;\n    }\n\n    E get(int i) {\n        return a[i];\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Unchecked&lt;/strong&gt;: &lt;em&gt;weak typing&lt;/em&gt;. No type checking is actually done on any of the objects passed as argument.&lt;/p&gt;\n\n&lt;p&gt;-&amp;gt; in that case, you should write&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public class GenSet&amp;lt;E&amp;gt; {\n\n    private Object[] a;\n\n    public GenSet(int s) {\n        a = new Object[s];\n    }\n\n    E get(int i) {\n        @SuppressWarnings(\"unchecked\")\n        final E e = (E) a[i];\n        return e;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Note that the component type of the array should be the &lt;a href=\"http://docs.oracle.com/javase/tutorial/java/generics/erasure.html\" rel=\"noreferrer\"&gt;&lt;em&gt;erasure&lt;/em&gt;&lt;/a&gt; of the type parameter:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;public class GenSet&amp;lt;E extends Foo&amp;gt; { // E has an upper bound of Foo\n\n    private Foo[] a; // E erases to Foo, so use Foo[]\n\n    public GenSet(int s) {\n        a = new Foo[s];\n    }\n\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;All of this results from a known, and deliberate, weakness of generics in Java: it was implemented using erasure, so \"generic\" classes don't know what type argument they were created with at run time, and therefore can not provide type-safety unless some explicit mechanism (type-checking) is implemented.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["如何在 Java 中创建泛型数组？", ["\n\n", "Due to the implementation of Java generics, you can't have code like this: ", "\n\n", "public class GenSet<E> {\n    private E a[];\n\n    public GenSet() {\n        a = new E[INITIAL_ARRAY_LENGTH]; // error: generic array creation\n    }\n}\n", "\n\n", "How can I implement this while maintaining type safety?", "\n\n", "I saw a solution on the Java forums that goes like this:", "\n\n", "import java.lang.reflect.Array;\n\nclass Stack<T> {\n    public Stack(Class<T> clazz, int capacity) {\n        array = (T[])Array.newInstance(clazz, capacity);\n    }\n\n    private final T[] array;\n}\n", "\n\n", "But I really don't get what's going on.", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/529085/how-to-create-a-generic-array-in-java"]], "Tag": "程序设计"}
{"Answer": "构造方法是可以使用泛型的。支持泛型的两种写法：\r\n\r\n```java\r\n public class Test&lt;T&gt; {\r\n\r\n\tpublic Test(T z) {\r\n\r\n\t}\r\n}\r\n```\r\n这种写法表示整个类都支持使用泛型T，且整个类使用的是同一个T\r\n\r\n```java\r\n public class Test {\r\n\r\n\tpublic &lt;T&gt; Test(T z) {\r\n\r\n\t}\r\n}\r\n```\r\n这种写法表示只有该方法支持使用泛型T\r\n\r\n问题二：ArrayList 是使用了泛型的。\r\n\r\n```java\r\n public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\r\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\r\n```\r\n当没有指定存入类型时，默认就是object的。另外我按照你的代码写了一遍，并没有报错。", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型类的构造函数，急急！！！", ["问题1.", "\nclass demo", "\n{ ", "\n      demo", "\n            {", "\n               System.out.println(z);", "\n            }", "\n} ", "\nclass temp", "\n{", "\n        public static void main(String [] args)", "\n        { ", "\n            demo d=new demo demo(\"csdn\");", "\n            /*在这里我 如果 这样", "\n为啥不报错 ，难道  泛型类的 构造函数不被泛型支配？*/", "\n        }", "\n}", "\n\n", "\n", "\n\n", "问题2.", "\nclass demo", "\n{", "\n     public static void main(String [] args)", "\n         {", "\n                ArrayList al=new ArrayList();", "\n                        al.add(\"csdn01\");//他这里存进去的 是什么类型？String类型?Object?", "\n                        Iterator it=al.iterator();//这里把数据传到迭代器过程中 是不是发生了类型转换，当我 写上al.add(4);我运行会报出 classcastException所以我觉得发生了类型转换", "\n\n", "    }\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;接口方法返回类型直接使用泛型 T 就可以了&amp;#xff0c;示例代码如下。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; CustomInterface&amp;lt;T&amp;gt; {\n\n    T &lt;span class=\"hljs-title function_\"&gt;custom&lt;/span&gt;();\n\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Test&lt;/span&gt; {\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;[] args&lt;/span&gt;) {\n\n        &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt;&amp;gt; list &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\n\n        &lt;span class=\"hljs-title class_\"&gt;CustomInterface&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt;&amp;gt; customInterface &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;CustomInterface&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt;&amp;gt;() {\n            &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;custom&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;;\n            }\n        };\n        list.&lt;span class=\"hljs-title function_\"&gt;add&lt;/span&gt;(customInterface.&lt;span class=\"hljs-title function_\"&gt;custom&lt;/span&gt;());\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型类怎么声明返回的泛型类的类型？", ["我建立了一个接口，泛型T。接口内方法返回类型是另一个实体类，具有泛型K", "我在使用这个借口匿名内部类的时候，声明了T的类型。", "但是在返回值的时候遇见了问题，提示我ListString类型无法放入object中。", "\n", "这个有什么办法嘛？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You should add an accessor to your interface:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type I interface {\n    test()\n    Name() string\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Then make sure your struct implements this method:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (s S) Name() string {\n    return s.name\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And then access the name using the accessor method:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;        fmt.Printf(\"map element name: %s\r\n\", value.Name())\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["如何从用作泛型的接口访问struct属性", ["\n\n", "Maybe i am just over complicating my code but i am trying to get a better understanding of how interfaces and structs work in golang. ", "\n\n", "Basically, i am storing elements that satisfy interface I inside an hash table. As all the items that satisfy I can be contained inside an I element, i thought i could be using I as a kind of \"generic\" interface, stuff them inside a hashmap, then pull them out later  and access the \"underlyng\" struct methond from there. ", "\n\n", "Unfortunately, after pulling the element out, i found out that i cannot call the struct method, as element is of Interface type, and the \"original\" struct is not accessible anymore. ", "\n\n", "Is there a way to get a clean and simple access to the struct that satisfy I?", "\n\n", "This is my code, it throws a \"value.name undefined (type I has no field or method name)\" inside the for loop:", "\n\n", "/**\n * Define the interface\n */\ntype I interface{\n    test()\n}\n\n/**\n * Define the struct\n */\ntype S struct{\n    name string\n}\n\n/**\n *  S now implements the I interface\n */\nfunc (s S) test(){}\n\nfunc main(){\n\n    /**\n     * Declare and initialize s S\n     */\n    s := S{name:\"testName\"}\n\n    /**\n     * Create hash table\n     * It CAN contains S types as they satisfy I interface\n     * Assign and index to s S\n     */\n    testMap := make(map[string]I)\n    testMap[\"testIndex\"] = s\n\n    /**\n     * Test the map length\n     */\n    fmt.Printf(\"Test map length: %d\n\", len(testMap))\n\n    for _, value := range testMap{\n\n        /**\n         * This is where the error is thrown, value is of Interface type, and it is not aware of any \"name\" property\n         */\n        fmt.Printf(\"map element name: %s\n\", value.name)\n    }\n\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "return -1;地方写错了，你这样想：第一次for循环，if（true）就return 了0。如果if(false)则会执行return -1;所以你的返回值不是0就是-1。\r\n再者，你这个算法写得。。。你要先对items判断是否为null.如果传null你这个不就错了么？\r\n还有equals方法是比较值，不是比较对象，如果你传的是内容值相等，对象不同，返回的是true。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型方法，求大神讲解", ["\n\n", "并非所有代码路径都返回值，怎么解决呢？求大神教"]], "Tag": "程序设计"}
{"Answer": "```\r\n         public static T[] Slice&lt;T&gt;(this IEnumerable&lt;T&gt; source, int index, int count)\r\n        {\r\n            if (index &lt; 0 || count &lt; 0 || index + count &gt; source.Count())\r\n            {\r\n                throw new ArgumentException();\r\n            }\r\n            T[] result = new T[count];\r\n            Array.Copy(source.ToArray(), index, result, 0, count);\r\n            return result;\r\n        }\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型T 如何在扩展方法中使用?", ["本来想了解一下扩展方法,但是看到文库中的实例明显有问题,特来提问", "\n泛型对象T 如何使用Length 属性? ", "\n可以像类中一样加继承于某某类的约束吗?", "\n\n", "http://wenku.baidu.com/link?url=Vz-Cjrq24tvblbk0l1I4IPYYfZ82jkGpzGBoNBDhi6qSCJko9hSTcrKGWrunO91TqTgyqB0AMvueHUP1or-mi8ktWMejceDW6Y-OphMnBh7", "\n\n", " public static class testEx\n    {\n        public static int ToInt32haha(this string str)\n        {\n            return Int32.Parse(str);\n        }\n        public static T[] Slice<T>(this T source, int index, int count)\n        {\n            if (index < 0 || count < 0 || index + count > source.Length)\n            {\n                throw new ArgumentException();\n            }\n            T[] result = new T[count];\n            Array.Copy(source, index, result, 0, count);\n            return result; \n        }\n    }\n"]], "Tag": "程序设计"}
{"Answer": "用javap的-s参数。题主给的javap输出是 javap -c 得到的。用 javap -c -s 就会看到多了一些Signature行，它们其中一些是擦除后的signature。例如这里：  public void setFirst(T);\r\n    Signature: (Ljava/lang/Object;)V\r\n这Signature行里就是 void (Object) 而不是 void (T) 了。还有在字节码（方法体）里面您也是看不到泛型的，因为已经被擦除了。在这个层面上保留的泛型信息只有调试用的LocalVariableTypeTable（LVTT）里。LVTT用 javap -verbose 看。$ javap -c -s Pair\r\nCompiled from \"Pair.java\"\r\npublic class Pair&lt;T&gt; {\r\n  public Pair();\r\n    Signature: ()V\r\n    Code:\r\n       0: aload_0       \r\n       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\r\n       4: aload_0       \r\n       5: aconst_null   \r\n       6: putfield      #2                  // Field first:Ljava/lang/Object;\r\n       9: aload_0       \r\n      10: aconst_null   \r\n      11: putfield      #3                  // Field second:Ljava/lang/Object;\r\n      14: return        \r\n\r\n  public Pair(T, T);\r\n    Signature: (Ljava/lang/Object;Ljava/lang/Object;)V\r\n    Code:\r\n       0: aload_0       \r\n       1: invokespecial #1                  // Method java/lang/Object.\"&lt;init&gt;\":()V\r\n       4: aload_0       \r\n       5: aload_1       \r\n       6: putfield      #2                  // Field first:Ljava/lang/Object;\r\n       9: aload_0       \r\n      10: aload_2       \r\n      11: putfield      #3                  // Field second:Ljava/lang/Object;\r\n      14: return        \r\n\r\n  public T getFirst();\r\n    Signature: ()Ljava/lang/Object;\r\n    Code:\r\n       0: aload_0       \r\n       1: getfield      #2                  // Field first:Ljava/lang/Object;\r\n       4: areturn       \r\n\r\n  public T getSecond();\r\n    Signature: ()Ljava/lang/Object;\r\n    Code:\r\n       0: aload_0       \r\n       1: getfield      #3                  // Field second:Ljava/lang/Object;\r\n       4: areturn       \r\n\r\n  public void setFirst(T);\r\n    Signature: (Ljava/lang/Object;)V\r\n    Code:\r\n       0: aload_0       \r\n       1: aload_1       \r\n       2: putfield      #2                  // Field first:Ljava/lang/Object;\r\n       5: return        \r\n\r\n  public void setSecond(T);\r\n    Signature: (Ljava/lang/Object;)V\r\n    Code:\r\n       0: aload_0       \r\n       1: aload_1       \r\n       2: putfield      #3                  // Field second:Ljava/lang/Object;\r\n       5: return        \r\n}\r\n=============================", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型擦除发生在哪个阶段，如何用反编译工具查看泛型擦除后的代码？", ["有如下的泛型类：", "\n\n", "public class Pair", "\n{", "\n   public Pair() { first = null; second = null; }", "\n   public Pair(T first, T second) { this.first = first;  this.second = second; }", "\n\n", "public T getFirst() { return first; }", "\n   public T getSecond() { return second; }", "\n\n", "public void setFirst(T newValue) { first = newValue; }", "\n   public void setSecond(T newValue) { second = newValue; }", "\n\n", "private T first;", "\n   private T second;", "\n}", "\n\n", "用javac编译后再用javap 查看代码，如下：", "\n\n", "Compiled from \"Pair.java\"", "\npublic class Pair {", "\n  public Pair();", "\n    Code:", "\n       0: aload_0", "\n       1: invokespecial #1                  // Method java/lang/Object.\"\":()V", "\n       4: aload_0", "\n       5: aconst_null", "\n       6: putfield      #2                  // Field first:Ljava/lang/Object;", "\n       9: aload_0", "\n      10: aconst_null", "\n      11: putfield      #3                  // Field second:Ljava/lang/Object;", "\n      14: return", "\n\n", "public Pair(T, T);", "\n    Code:", "\n       0: aload_0", "\n       1: invokespecial #1                  // Method java/lang/Object.\"\":()V", "\n       4: aload_0", "\n       5: aload_1", "\n       6: putfield      #2                  // Field first:Ljava/lang/Object;", "\n       9: aload_0", "\n      10: aload_2", "\n      11: putfield      #3                  // Field second:Ljava/lang/Object;", "\n      14: return", "\n\n", "public T getFirst();", "\n    Code:", "\n       0: aload_0", "\n       1: getfield      #2                  // Field first:Ljava/lang/Object;", "\n       4: areturn", "\n\n", "public T getSecond();", "\n    Code:", "\n       0: aload_0", "\n       1: getfield      #3                  // Field second:Ljava/lang/Object;", "\n       4: areturn", "\n\n", "public void setFirst(T);", "\n    Code:", "\n       0: aload_0", "\n       1: aload_1", "\n       2: putfield      #2                  // Field first:Ljava/lang/Object;", "\n       5: return", "\n\n", "public void setSecond(T);", "\n    Code:", "\n       0: aload_0", "\n       1: aload_1", "\n       2: putfield      #3                  // Field second:Ljava/lang/Object;", "\n       5: return", "\n}", "\n\n", "说好的类型擦除呢?怎么才能看到类型擦除后的代码？"]], "Tag": "程序设计"}
{"Answer": "【1】class Derived2 extends GenericBase {} //这里去除了T，为什么编译时没有问题？\r\n经过测试这种继承方法，是不继承父类泛型效果的，，可能就是题主所说的对父类的泛型擦除\r\n\r\n还可以这样继承，给子类设置泛型，class Derived2&lt;S&gt; extends GenericBase {}，，，和上面一样，父类的泛型效果未被继承\r\n\r\n\r\n【2】 class Derived3 extends GenericBase&lt;?&gt; {} 上面的GenericBase&lt;?&gt;会出现编译错误，这又是为什么？\r\n父类设置了泛型，子类没有泛型，，创建自类时如何给父类设置泛型？？所以系统报错“找不到泛型”\r\n必须给子类和父类设置泛型（且名字相同，测试了一下同时设置 ？ 是不行的），\r\nclass Derived2&lt;S&gt; extends GenericBase&lt;S&gt;（名字随意，但要一样）\r\n\r\n【3】d2.set(obj); // 如果上面没有@SuppressWarnings修饰的话，这里会出现一个编 译警告，为什么偏偏在set()方法这里出现一个编译警告？\r\n泛型默认是 Object 类型的，，get到一个object不会有问题吧，，，\r\nset不同，，set需要把你的对象赋值给泛型的对象，，这是有危险的，需要设置泛型才可以取出警告。\r\n编译器报错，给了个map的例子，大概意思是说“没有指定泛型的地方，赋值都会出现警告。”，，下面有个List的例子：\r\n\r\n\r\n```\r\n        List list = new ArrayList();\r\n        list.add(\"sss\");//有警告\r\n\r\n```\r\n\r\n\r\n我也是根据测试结果总结的，欢迎交流，，，，有问题还可以追问\r\n我的测试代码如下：\r\n\r\n\r\n```\r\n public class TestT {\r\n    //    @SuppressWarnings(\"unchecked\")\r\n    public static void main(String[] args) {\r\n        Derived2&lt;String&gt; d2 = new Derived2&lt;String&gt;();\r\n        Object obj = \"aaa\";\r\n        d2.set((String) obj);\r\n        System.out.println(d2.get());\r\n\r\n        List list = new ArrayList();\r\n        list.add(\"sss\");//有警告\r\n\r\n        GenericBase&lt;String&gt; genericBase = new GenericBase&lt;&gt;();\r\n        genericBase.set(\"sss\");//没警告\r\n    }\r\n}\r\n\r\nclass GenericBase&lt;T&gt; {\r\n    private T element;\r\n\r\n    public void set(T arg) {\r\n        element = arg;\r\n    }\r\n\r\n    public T get() {\r\n        return element;\r\n    }\r\n}\r\n\r\nclass Derived1 extends GenericBase {\r\n}\r\n\r\nclass Derived2&lt;S&gt; extends GenericBase&lt;S&gt; {\r\n}\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["怎样理解java泛型中的擦除", ["class GenericBase {", "\n  private T element;", "\n  public void set(T arg) { arg = element; }", "\n  public T get() { return element; }", "\n}", "\n\n", "class Derived1 extends GenericBase {}", "\n\n", "class Derived2 extends ", "GenericBase", " {} //这里去除了T，为什么编译时没有问题？", "\n\n", "// class Derived3 extends ", "GenericBase<?>", " {}", "\n// 上面的GenericBase<?>会出现编译错误，这又是为什么？", "\n\n", "public class ErasureAndInheritance {", "\n  @SuppressWarnings(\"unchecked\")", "\n  public static void main(String[] args) {", "\n    Derived2 d2 = new Derived2();", "\n    Object obj = d2.get();", "\n    d2.set(obj); // 如果上面没有@SuppressWarnings修饰的话，这里会出现一个编  译警告，为什么偏偏在set()方法这里出现一个编译警告？", "\n  }", "\n}"]], "Tag": "程序设计"}
{"Answer": "ParameterizedType parameterizedType = (ParameterizedType)this.getClass().getGenericSuperclass();\r\n\r\nentityClass= (Class&lt;T&gt;)(parameterizedType.getActualTypeArguments()[0]);", "Konwledge_Point": "泛型机制——模板", "Question": ["Java 反射：怎么取出类的泛型类型", ["[code=\"java\"]", "\npublic class BaseHello {", "\n     private Class entityClass;", "\n\n", " public BaseHello(){\n     //entityClass怎么赋值？（怎么能知道entityClass就是代表Personal这个类？）\n }\n", "\n\n", "}", "\n[/code]", "\n[code=\"java\"]", "\n    public static void main(String[] args) {", "\n        BaseHello pdao = new BaseHello();", "\n        System.out.println(pdao);", "\n    }", "\n[/code]", "\n如注释的问题：在BaseHello的构造方法中，怎么给entityClass赋值？"]], "Tag": "程序设计"}
{"Answer": "一般传一个json的数据，然后把json的数据转换为List&lt;User&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Ext整合Struts2 如何传泛型值？", ["我设一个User类，代码如下：", "\n[code=\"java\"]public class User{", "\n    private String name;", "\n    private String sex;", "\n    private String age;", "\n    private String title;", "\n    private String expertise;", "\n    private String maintask;", "\n\n", "    ....get/set方法   \n", "\n\n", "}[/code]", "\n\n", "然后是接收值的Action", "\n[code=\"java\"]", "\npublic class Test implements Action {", "\n    private int flag;", "\n    private List store;", "\n    private boolean success;", "\n      public String execute() throws Exception {", "\n              处理", "\n    }", "\n      ....get/set方法", "\n}", "\n[/code]", "\n\n", "页面上我想用Ext.ajax.request来向后台传值", "\n[code=\"java\"]", "\n Ext.Ajax.request({", "\n                     url : 'test.action',", "\n                     success : function(response) {", "\n                     },", "\n                     params : {", "\n                     flag:1,", "\n                     store:a", "\n                     }", "\n                     })", "\n[/code]", "\n\n", "我想知道页面上，store这个参数的值要是怎么样一种格式，才能让后台store正常接收并自动转化呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不能边遍历边修改原list集合&amp;#xff0c;可以尝试把list.add 这句去掉&amp;#xff0c;&amp;#xff0c;或者定义一个新的集合来接收&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型是map的list 集合遍历，put问题", ["问题遇到的现象和发生背景", "\n", "泛型是map的list 集合遍历时候，map.put一个参数，后面报错,请问下如何解决这个问题", "\n", "问题相关代码，请勿粘贴截图", "\n", "List<Map<String, Object>> list =commonRepository.findSqlCall(sb.toString(), params.toArray());", "\n", "    Iterator<Map<String, Object>> iterator = ", "list", ".iterator", "()", ";\n    ", "while", " (iterator.has", "Next()", "){\n        Map  map = iterator.next", "()", ";\n        ", "if", " (map.get(", "\"yyid\"", ") != null", " && ", "StringUtils", ".", "is", "NotEmpty(", "map", ".", "get", "(", "\"yyid\"", ")", ".", "to", "String()", ")", " && ", "StringUtils", ".", "is", "NotEmpty(", "map", ".", "get", "(", "\"yyid\"", ")", ".", "to", "String()", ")) {\n            map.put(", "\"yybs\"", ", ", "Integer", ".", "value", "Of(1)", ");\n        } ", "else", " {\n            map.put(", "\"yybs\"", ", ", "Integer", ".", "value", "Of(0)", ");\n        }\n            ", "list", ".add(map);\n    }\n", "\n", "运行结果及报错内容", "\n", "java.util.ConcurrentModificationException", "    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)", "    at java.util.ArrayList$Itr.next(ArrayList.java:851)", "    at com.jmz.bl.service.impl.MzBrblServiceImpl.queryNoSubmitBl(MzBrblServiceImpl.java:199)", "    at com.jmz.bl.service.impl.MzBrblServiceImpl$$FastClassBySpringCGLIB$$199b2dd9.invoke(", ")", "    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)", "    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:684)", "    at com.jmz.bl.service.impl.MzBrblServiceImpl$$EnhancerBySpringCGLIB$$b75778eb.queryNoSubmitBl(", ")", "    at com.jmz.bl.biz.impl.MzBrblBizImpl.queryNoSubmitBl(MzBrblBizImpl.java:1266)", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "```\r\n A a = new A();\r\n-&gt;\r\nA&lt;int&gt; a = new A&lt;int&gt;();\r\n```\r\n\r\n\r\n\r\njava使用类型擦除实现泛型，具体你可以看书", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型的一点小疑问", ["public class GenericsDemo {", "\n    public static void main (String args[]) {", "\n        A a = new A();", "\n        a.setX(40);", "\n        System.out.println(a.getX());", "\n    }", "\n}", "\nclass A {", "\n    private int x;", "\n    public void setX() {", "\n        this.x=x;", "\n    }", "\n    public int getX() {", "\n        return x;", "\n    }", "\n}", "\n程序编译出错", "\n类A变量用了泛型之后其成员变量就必须是用泛型类型声明吗？", "\n最好顺便解释一下泛型用于类后的变化……"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;u&gt;&lt;strong&gt;如有帮助&amp;#xff0c;请采纳呀&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"231\" src=\"https://img-ask.csdnimg.cn/upload/1624937723017.png\" width=\"885\" /&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt; List&amp;lt;String&amp;gt; demo &amp;#61; new ArrayList&amp;lt;&amp;gt;();\n        demo.add(&amp;#34;1&amp;#34;);\n        demo.add(&amp;#34;2&amp;#34;);\n        Map&amp;lt;String, String&amp;gt; collect &amp;#61; demo.stream().collect(Collectors.toMap(key -&amp;gt; key, value -&amp;gt; value));\n        System.out.println(collect);&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java8中如何将泛型为string的集合使用tomap转换位map", ["如果集合中的对象是string那么就不能使用funtion.indentity，针对string类型的集合就不能使用当前对象作为value吗"]], "Tag": "程序设计"}
{"Answer": "1、实现在页面添加GridView控件\r\n2、动态添加GridView控件到页面\r\n\r\n```\r\n this.Controls.Add(gv);\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["关于WEB中List泛型绑定到GridView的问题", ["-----------------------------DAL----------------------------------------------------", "\npublic  List select(int UserID)", "\n        {", "\n            //初始化数据库连接对象", "\n            DateAccessLaye dbmyfile = new DateAccessLaye();", "\n            //初始化myfilemodel对象的集合实例", "\n            DataTable dsmf = dbmyfile.GetDataTable(\"SELECT Title,FSize,Checkcode,Uploadtime FROM myfile WHERE UserID=\" + UserID);", "\n            List mfm = new List();", "\n            foreach (DataRow dr in dsmf.Rows)", "\n            {", "\n                myfilemodel mfmd=new myfilemodel();", "\n                mfmd.Title = dr[\"Title\"].ToString();", "\n                mfmd.FSize = (float)System.Convert.ToDouble(dr[\"FSize\"].ToString());", "\n                mfmd.Checkcode = dr[\"Checkcode\"].ToString();", "\n                mfmd.Uploadtime = Convert.ToDateTime(dr[\"Uploadtime\"]);", "\n                mfm.Add(mfmd);", "\n            }", "\n            return mfm;", "\n        }", "\n                ---------------------------------------BLL-------------------------------------", "\n                public class myfilebll", "\n    {", "\n        public  List select(int UserID)", "\n        {", "\n            myfiledal mf = new myfiledal();", "\n            return mf.select(UserID);", "\n        }", "\n    }", "\n        -----------------------------UI---------------------------------------------------", "\n        protected void Button8_Click(object sender, EventArgs e)", "\n    {", "\n        int s = 0;", "\n        s = Convert.ToInt32(TextBox1.Text);", "\n        GridView gv = new GridView();", "\n        myfilebll mf = new myfilebll();", "\n        gv.DataSource = mf.select(s);", "\n        gv.DataBind();", "\n\n", "}\n\n    运行时GridView没有显示   \n"]], "Tag": "程序设计"}
{"Answer": "根据情况来看，第一种写法是适合的，因为一般Domain中的Model是从Repository中取出的，所以第一种写法中的Model可以根据M来变化，而第二种写法会麻烦一些，因为不论Repository中取出的是什么Model，最终只能被转型为Device，这在通常情况下是不可接受的。", "Konwledge_Point": "泛型机制——模板", "Question": ["问一个Java泛型与类继承的问题", ["直接上代码了", "\n\n", "//DeviceRepository类\n public abstract class DeviceRepository<T extends Device> extends DomainRepository<T> \n\n//DeviceEventHandler类第一种写法\n public abstract class DeviceEventHandler<M extends Device,R extends DeviceRepository<M>>\n\n//DeviceEventHandler的子类针对第一种写法的继承\npublic class DefaultSmartControllerEventHandler extends DeviceEventHandler<SmartController, SmartControllerRepository>\n\n//DeviceEventHandler类第二种写法\npublic abstract class DeviceEventHandler<R extends DeviceRepository<? extends Device>>\n\n//DeviceEventHandler的子类针对第二种写法的继承\npublic class DefaultSmartControllerEventHandler extends DeviceEventHandler<SmartControllerRepository>\n", "\n\n", "这两种写法在Eclipse中都编译通过了，但我不清楚他们之间有什么不同，如果哪位朋友知道请告知我，谢谢。", "\n另外，针对第二种写法，我在DeviceEventHandler中通过R获取的是具体的Device类的对象，而第一种写法似乎可以写成通过R获取M类的对象。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考参考&lt;br /&gt;&lt;strong&gt;记得采纳&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; {\n\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; s_no;\n\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; s_name;\n    \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getS_no&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s_no;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setS_no&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; s_no&lt;/span&gt;) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;s_no&lt;/span&gt; &amp;#61; s_no;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getS_name&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s_name;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;setS_name&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; s_name&lt;/span&gt;) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;s_name&lt;/span&gt; &amp;#61; s_name;\n    }\n\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;(&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; s_no, &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; s_name) {\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;s_no&lt;/span&gt; &amp;#61; s_no;\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;s_name&lt;/span&gt; &amp;#61; s_name;\n    }\n\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;toString&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Student{&amp;#34;&lt;/span&gt; &amp;#43;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;s_no&amp;#61;&amp;#39;&amp;#34;&lt;/span&gt; &amp;#43; s_no &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\&amp;#39;&amp;#39;&lt;/span&gt; &amp;#43;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;, s_name&amp;#61;&amp;#39;&amp;#34;&lt;/span&gt; &amp;#43; s_name &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\&amp;#39;&amp;#39;&lt;/span&gt; &amp;#43;\n                &lt;span class=\"hljs-string\"&gt;&amp;#39;}&amp;#39;&lt;/span&gt;;\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Test&lt;/span&gt; {\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {\n        ArrayList&amp;lt;Student&amp;gt; students &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n            students.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Student(i &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;zhangsan_&amp;#34;&lt;/span&gt; &amp;#43; i));\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (Student student : students) {\n            System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(student);\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/549452294356125.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java 泛型与集合框架", ["创建一个类Student，在类中定义两个变量：s_no, s_name", "创建测试类Test，在main方法中创建一个List对象studentList，然后通过循环语句把10个Student对象添加到List中，每个Student对象的s_no值分别是1-10，s_name的值分别对应：你的姓名拼音_数字(1-10)，例如：zhangsan_1, zhangsan_2", "三、添加另一个循环语句，把List中的每个对象的号码和姓名打印出来，例如：", "  1:zhangsan_1", "  2:zhangsan_2", "  3:zhangsan_3", "  4:zhangsan_4", "不是很会打出这段代码，需要大家帮忙"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;DAO is not the model. That's different classes.&lt;/p&gt;\n\n&lt;p&gt;DAO class should NOT be the super class of all the model. Model prototype should be super class of all the model.&lt;/p&gt;\n\n&lt;p&gt;\"Supermodel\" should have methods like delete(), save(), find() and such. DAO should be assigned to the model variable and used this way.&lt;/p&gt;\n\n&lt;p&gt;As of should supermodel be static - it depends. Most frameworks disguise static in loaders, which is all the same to my view, but honest static for some reason despised and so disguise have to be used.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["模型的泛型超类应该是静态的还是单例？", ["\n\n", "status: accepting the only one answer choice. with thanks.", "\n\n", "shouldn't I use static functions and ", "self::", " instead of ", "$this->", "   in here . I would use this class Dao as a ", "super class", " in all of my model classes. ", "\n\n", "The Dao class will be the super class of all the ", "model classes.", "\n\n", "Should it be singleton? should it use static?", "\n\n", "any tips ?", "\n\n", "<?php \nclass Dao extends Object{\n    private $con;\n    //will put this in defines includes file. Or user from WP.\n    private $dbhost     = \"localhost\";\n    private $dbname     = \"wpm\";\n    private $dbuser     = \"root\";\n    private $dbpass     = \"root\";\n\n    public function __construct() {\n       if(!$this->con){\n           $this->con = new PDO(\"mysql:host=$this->dbhost;dbname=$this->dbname\",$this->dbuser,$this->dbpass); //will make it generic. \n       }\n    }\n\n    protected function getCon(){\n        if(!$this->con){\n           $this->con = new PDO(\"mysql:host=$this->dbhost;dbname=$this->dbname\",$this->dbuser,$this->dbpass);\n        } \n        return $this->con;\n    }\n\n    protected function executeQuery($query, $fetchType, $paramArray){\n        $stmt = $this->getCon()->geprepare($query);\n        $stmt->execute($paramArray);\n        $stmt->setFetchMode($fetchType);//        $stmt->setFetchMode(PDO::FETCH_ASSOC);\n        $result = $stmt->fetch();\n        return $result;\n    } \n\n}\n\n?>\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "是的，一定要传入，因为泛型的擦除机制嘛", "Konwledge_Point": "泛型机制——模板", "Question": ["能获取泛型方法的T.class吗？", ["想得到泛型方法的T.class，不知道是不是一定要传入Class?", "\n\n", "public  T getFormBean() {", "\n    Class clazz = ???", "\n    ...", "\n}", "\n\n", "谢谢！"]], "Tag": "程序设计"}
{"Answer": "看下面这个简单的例子能不能让你明白泛型是什么（临时想的可能体现不出来，泛型强大的技巧，但是能说明问题）\r\n\r\n```\r\n /**\r\n * Created by zsl on 2017/8/17.\r\n */\r\npublic class Demo&lt;T&gt; {\r\n    private T t;\r\n\r\n    public Demo(T t) {\r\n        this.t = t;\r\n    }\r\n\r\n    public void sayT() {\r\n        System.out.println(t.toString());\r\n    }\r\n}\r\n\r\nclass Main {\r\n    public static void main(String[] args) {\r\n        //会报错，，因为我规定了泛型是String，，而不是Integer\r\n        // Demo&lt;String&gt; demo = new Demo&lt;String&gt;(1);\r\n        //不会报错，，符合泛型\r\n        Demo&lt;String&gt; demo = new Demo&lt;String&gt;(\"123\");\r\n        demo.sayT();\r\n    }\r\n}\r\n```\r\n\r\n泛型说白了就是一种约束，，例如集合中，如果不添加泛型约束，遍历时不能做同一处理\r\n\r\n有问题还可以追问，，例子仅供参考，，jdk1.8完美运行。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型的问题 Java 核心技术 一", ["Function： 但在添加或删除元素时，具有自动调节数组容量的功能，而不需要为此编写任何代码。", "\n\n", "ArrayList<Employee> staff = new ArrayList<>();\n", "\n\n", "这被称为“菱形” 语法，因为空尖括号<>就像一个菱形。", "\n可以结合new操作符使用菱形语法。", "\n编译器会检查新值是什么。", "\n如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检查这个变量，参数或方法的泛型类型，然后将这个类型放在<>中。 在这个例子中，new ArrayList<>()将赋至一个类型为ArrayList的变量，所以泛型类型为Employee。", "\n\n", "\n", "我在书上看到一个叫做 ArrayList(), 这个T 就是泛型吧。", "\n", "求大神给写一个简单的泛型程序给我看一下。\n（书上将Arraylist直接放到了继承中说，但是也是一笔带过，我上网查了一下，这个泛型也是一种对象类型，目的是为了统一，所以希望能有一个简单的程序加深一下理解）", "\n"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480055_644055.gif)\r\n![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480074_157454.gif)\r\n![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480082_428617.gif)\r\n![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480089_307759.gif)\r\n![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480095_844717.gif)\r\n![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480104_83082.gif)\r\n![图片说明](https://img-ask.csdn.net/upload/201707/20/1500480111_563893.gif)", "Konwledge_Point": "泛型机制——模板", "Question": ["关于java泛型，如何做一个通用的方法？", ["需求： 做一个通用的方法，把service和实体类传进去，能够根据这个service去查一次数据库。", "\n        public Object encolseModel(Class object, Service service,ProceedingJoinPoint proceedingJoinPoint){", "\n        object = (Class)proceedingJoinPoint.getArgs()[0];", "\n\n", "    if (object != null) {\n        object = service.findById(object.get());\n    }\n    return object;\n}\n", "\n\n", "写到这里有点懵比", "\n代码需要实现：", "\n1.把【proceedingJoinPoint.getArgs()[0];】强制转换成某个实体类，比如Employee；", "\n2.通过service，去数据库中查询出某个数据，返回object，", "\n\n", "这是源代码，怎么把这段代码做的有通用性？", "\n                TblEmp tblEmp = (TblEmp) proceedingJoinPoint.getArgs()[0];", "\n            if (tblEmp != null) {", "\n                tblEmp = tblEmpService.findById(tblEmp.getEmpId());", "\n            }"]], "Tag": "程序设计"}
{"Answer": "比如说继承，在继承的过程中，你保留泛型参数：\r\n\r\n\r\n```\r\n class List&lt;T&gt;\r\n{\r\n    ...\r\n}\r\n\r\nclass LinkedList&lt;T&gt; : extends List&lt;T&gt;\r\n{\r\n    ...\r\n}\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型类的一个小问题？", ["java中带有泛型的class在用到（new\\extends\\implements\\作为函数参数等）他们时，如果不设置他们的泛型，而只是用该class的名字来操作，编译器会警告说“xxx is a raw type”,xxx是个原生类型，你应该设置一下它的泛型的类型。那有没有什么时候就是会用到raw type的？就是只需要这个class的名字，而不需要去设置他的泛型类型？"]], "Tag": "程序设计"}
{"Answer": "\"强制转换并不是ChildB 想要做的，ChildB 是希望在被实例化了以后能在编译的时候就能限制test函数的参数类型。 \" 这违反了面向对象“子类不应该隐藏父类接口”的设计原则，在java中应该是无法做到的。\r\n\r\n你考虑一下，假如你可以限制ChildB.getTest只接收String的话，下面的代码能不能通过编译呢？\r\n\r\nFatherA a = factory.getAInstance(); //经过某些复杂条件判断后返回了一个ChildB实例，但这个方法也有可能返回FatherA实例。\r\na.getTest(new Integer(1));\r\n\r\nJava在编译期无法知道这个a的具体类型，因此它也不允许（你也不应该）在子类隐藏父类接口或强化父类接口的限制。", "Konwledge_Point": "泛型机制——模板", "Question": ["请教一个关于java泛型的语法问题", ["最近编程序的时候遇到一个java泛型的语法问题，不知道应该怎样实现，麻烦各位大牛帮忙解答：", "\n\n", " ", "\n\n", "如果父类在类上声明了泛型的话子类可以将泛型类型指定成一个具体类型，比如：", "\n\n", " ", "\n\n", "class FatherA<T> {", "\n\n", " ", "\n\n", "public  void test(T t) {", "\n\n", "      ;", "\n\n", "}", "\n\n", " ", "\n\n", "}", "\n\n", " ", "\n\n", "class ChildA extends FatherA<String>{", "\n\n", " @Override", "\n\n", "public  void test(String t) {//这里的 t 类型是 java.lang.String", "\n\n", "     t.compareTo(t);//编译通过", "\n\n", "}", "\n\n", " ", "\n\n", "}", "\n\n", " ", "\n\n", "可是如果父类直接在方法前声明了泛型的话子类应该如何指定具体类型呢？ 比如：", "\n\n", " ", "\n\n", "class FatherB {", "\n\n", " ", "\n\n", "public <T> void test(T t) {", "\n\n", "      ;", "\n\n", "}", "\n\n", " ", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "class ChildB extends FatherB {", "\n\n", " @Override", "\n\n", "public <String> void test(String t) {  //这里的 t 其实是泛型的 并不是java.lang.String类型", "\n\n", "     t.compareTo(t);//编译不通过", "\n\n", "}", "\n\n", " ", "\n\n", "}", "\n\n", " ", "\n\n", " ", "\n\n", "请教各位大牛，ChildB 继承的 test方法能指定成java.lang.String类型吗？", "\n\n", " ", "\n\n", "所有悬赏积分全部送上"]], "Tag": "程序设计"}
{"Answer": "vec直接添加数组，如\r\n\r\n```\r\n Vector&lt;int[][]&gt; vec=new Vector&lt;int[][]&gt;();\r\n\t    \tint[][] e={{1,2},{3,4}};\r\n\t    \tvec.add(e);\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["Java里面，下面这个泛型实例化的语句，代表什么？", ["Vector  vec = new Vector  () ; ", "\n代表着往里面放一个int二维数组的地址吗？", "\n但如果用", "\nfor(int i = 0 ; i < 4 ; i ++)", "\n        {", "\n            for(int j = 0 ; j < 4 ; j ++)", "\n            {", "\n                if(logicBoard[i][j] == 0)", "\n                {", "\n                    vec.add(logicBoard[i][j]) ;", "\n                }", "\n            }", "\n\n", "    }\n    这样的方法来给vec 增加元素是不对的，那么该如何给vec这个泛型增加这个二维数组的地址呢？\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n Stack&lt;int&gt;\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["C#报错使用泛型类型的“Stack”需要1个类型的参数 和无法运用于方法组和int 操作数怎么解决", ["class Class1", "\n    {", "\n        static string De(int N, int D)", "\n        {", "\n            Stack stack = new Stack();", "\n            if (D < 2 || D > 16)", "\n            {", "\n                throw new ArgumentOutOfRangeException(\"D\", \"指示灯是否\");", "\n\n", "        }\n        do\n            {\n                int residue = N % D;\n                char c = (residue < 10) ? (char)(residue + 48) : (char)(residue + 55);\n                stack.Push(c);\n\n            }\n            while ((N = N / D) != 0);\n            string s = string.Empty;\n            while (stack.Count > 0)\n            {\n                s += stack.Pop().Tostring();\n            }\n            return s;\n\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "可以的，但是在接收到参数进行处理的时候，是需要注意的。给你举个例子：\r\n\r\n\r\n```\r\n public static void main(String[] args) {\r\n\t\tint int1 = (Integer) getInt();//正确\r\n\t\tint int2 = (Integer) getInt2();//报错  java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer\r\n\t\tString str = (String) getString();//正确\r\n\t\tDate date = (Date) getDate();//正确\r\n\t\t\r\n\t\tSystem.out.println(int1);\r\n\t\tSystem.out.println(int2);\r\n\t\tSystem.out.println(str);\r\n\t\tSystem.out.println(date);\r\n\t}\r\n\t\r\n\tpublic static Object getInt(){\r\n\t\treturn 1;\r\n\t}\r\n\t\r\n\tpublic static Object getString(){\r\n\t\treturn \"abc\";\r\n\t}\r\n\t\r\n\tpublic static Object getInt2(){\r\n\t\treturn \"\";\r\n\t}\r\n\t\r\n\tpublic static Object getDate(){\r\n\t\treturn new Date();\r\n\t}\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java中修饰方法的一个泛型指定为一个类问题", ["java中修饰方法的一个泛型指定为一个类，那么这个方法的返回类型肯定就是这个类的对象，那返回的是这个类的子类的对象可以吗？"]], "Tag": "程序设计"}
{"Answer": "https://msdn.microsoft.com/zh-cn/library/dd799517.aspx", "Konwledge_Point": "泛型机制——模板", "Question": ["link如何实现泛型集合的顺变、逆变", ["link如何实现泛型集合的顺变、逆变？原理是什么，语句怎么写？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;接口中的方法不能使用static&amp;#xff0c;接口中的方法默认是public&amp;#xff0c;abstract&amp;#xff0c;与static是冲突的。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["接口中static后怎么使用泛型啊", ["\n", "package libaries;\n\npublic interface  arithmetic<Key> {\n\n    static Key add(Key a, Key b) { return null; }\n    void add(Key a);\n\n    void minus(Key a);\n\n}\n", "\n\n", "这样写idea会报错'libaries.arithmetic.this' cannot be referenced from a static context"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个泛型得能被类型推导出来才行&amp;#xff0c;一般定义泛型的类的时候会带这些泛型&amp;#xff0c;构造函数不用再写一遍&amp;#xff0c;如果的确有泛型要传可以传&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;T&lt;/span&gt;&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参数进去&amp;#xff0c;这样java就能推导出来你的类型是啥了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;RNode&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;K, &lt;span class=\"hljs-symbol\"&gt;V&lt;/span&gt;&lt;/span&gt;&amp;gt; {\n  &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; RNode() {}\n}\n\nRNode node &amp;#61; new RNode&amp;lt;String, Integer&amp;gt;(); &lt;span class=\"hljs-comment\"&gt;// 一般是这样传进来的&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["为什么Java构造函数方法不能使用泛型呢", ["为什么Java构造函数方法不能使用泛型呢，是因为动态绑定的原因吗"]], "Tag": "程序设计"}
{"Answer": "自答：\r\n* 看了一些别人的说法，说是带泛型参数的变量要么是成员变量，要么是方法参数才能获取泛型参数类型，因为java在类的方面只提供了一个getGenericSuperClass()的方法，只能获取到父类的泛型参数类型。在成员变量和方法上还有getGenericType()和getGenericParameterTypes()方法。这是泛型的类型擦除导致的，具体我还没有探究。\r\n* 但这不是纯粹的泛型，因为要明确给出类型才能获取。如定义方法``` getName(List&lt;String&gt; lists)```，使用反射可以很容易得到String类型，但如果把方法改为getName(List ```&lt;T&gt;``` lists)，无论你使用什么方法都不可能得到运行时给出的T的类型，只能得到字符串“T”。有人说有个什么框架（忘了）采用了这样一个方法：定义一个内部类，把T传给该类的成员变量，然后使用匿名内部类得到该成员变量，我试了，绕了一大圈，最后得到的还是“T”，要想得到运行时传递的泛型参数类型，就必须在方法中明确声明泛型类型。\r\n* 那么如果真的想使用纯粹的泛型参数（确实有这个需求，比如设计一些工具方法时）怎么办呢，其实有一种方法，不需要反射（如果用反射，代码还要多几行），就是加一个Class的参数，如getName(Class clazz, List``` &lt;T&gt;``` lists)，这样调用方法时给出clazz即可，而clazz就是T的Class。如果你想说这代码不够优雅，那我也没办法了。", "Konwledge_Point": "泛型机制——模板", "Question": ["怎样获取List的泛型参数，如List<String>？", ["ArrayList extends AbstractList，如果用反射getGenericSuperClass()......获取到的", "\n                是E，只有自定义一个继承自ArrayList的类才能得到String。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;想写公共的查询&amp;#xff1f;有一种方法&amp;#xff0c;就是你的类得继承其他的类&amp;#xff0c;这样含字段最多的类就可以满足任何类了&amp;#xff0c;但是继承的耦合性太强&amp;#xff0c;不建议&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["封装数据库查询操作的时候返回的集合泛型应该怎么设置？", ["封装数据库查询操作的时候返回的集合泛型应该怎么设置，我知道得设置为数据库对应的实体类，但是我是想把增删改查封装成一个工具类的，这样就不只是一个对象去调用查询操作，而是多种对象，多种对象对应不同类，这个时候封装查询返回的泛型应该怎么设置啊？"]], "Tag": "程序设计"}
{"Answer": "这种设计没有用好面向对象的多态， 代码可读性差，作为公共接口也很难让人理解和调用； 使用方法重载会有更好的体验。\r\nNumber的子类还有BigDecimal， 显然BigDecimal和Integer的加法运算是不同的。\r\n使用instanceof也只能简化if中的条件代码，没有本质区别。", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA_数组_泛型：我写了一个数组结合泛型的通用求和方法，求帮忙优化，写的太烂了", ["=====《求求大神帮我优化下啊，我写的太烂了》====", "\npublic static void main(String[] args) {", "\n        Number[] num1 = {2, 3, 3, 4, 5};  //Integer", "\n        Number[] num2 = {1.1, 2.0, 3.0, 4.0, 5.0}; //Double", "\n        System.out.println(num1[0].getClass().getTypeName());", "\n        System.out.println(new ArraysTest().ArraysSum(num2));", "\n\n", "}\n\npublic static <T extends Number> T ArraysSum(T[] num) {\n    System.out.println(num.getClass().getTypeName());\n    Double sum = 0.0;\n    for (int i = 0; i < num.length; i++) {\n        sum += num[i].doubleValue();\n\n    }\n    if (num[0].getClass().getTypeName().equals(\"java.lang.Integer\")){\n        Integer result = (int)((double)sum);\n        return (T)result;\n    }\n    if (num[0].getClass().getTypeName().equals(\"java.lang.Double\")){\n        Double result = sum.doubleValue();\n        return (T)result;\n    }\n    return (T)sum;\n}\n", "\n\n", "如何结合instanceof 更加智能的判断？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Instead of emulating JavaScript in Go (why ???) I would like to suggest to compose simmilar required operations from the building blocks of &lt;a href=\"http://code.google.com/p/go-wiki/wiki/SliceTricks\" rel=\"noreferrer\"&gt;SliceTricks&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;They are:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Completely type agnostic (think \"generics\" for free).&lt;/li&gt;\n&lt;li&gt;Quite probably pretty faster compared to packing/unpacking whatsoever in/from a &lt;code&gt;[]interface{}&lt;/code&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Go中的可变参数泛型参数", ["\n\n", "Let's say I want to make the equivalent of the ", "JavaScript ", "Array.splice", " function in Go, for Slices. I have the following code:", "\n\n", "func splice(slice []int, index, amount int, elements ...int) []int {\n    newslice := make([]int, 0)\n    for i := 0; i < index; i++ {\n        newslice = append(newslice, slice[i])\n    }\n    for i := index + amount; i < len(slice); i++ {\n        newslice = append(newslice, slice[i])\n    }\n    for _, el := range elements {\n        newslice = append(newslice, el)\n    }\n    return newslice\n}\n", "\n\n", "This example will work, but only for arguments of type ", "int", ". I want to make it generic, and I know that I should give the variadic argument ", "elements", " the type ", "interface{}", ", but how do I create a new slice with the type of that interface from inside the function?", "\n\n", "In other words, how can I specify the type of the slice dynamically depending on the type of the arguments in the first line of the function, where ", "newslice", " is created?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The Marshal function also receives its parameters as &lt;code&gt;interface{}&lt;/code&gt; therefore there's no way to detect if you are passing something invalid at compile time, it's all caught at runtime.&lt;/p&gt;\n\n&lt;p&gt;One thing you can do to check if an invalid type was passed to Marshal is to check the error type, Marshal returns an &lt;code&gt;UnsupportedTypeError&lt;/code&gt; when you try to Marshal an invalid type (like &lt;code&gt;chan&lt;/code&gt; or &lt;code&gt;func&lt;/code&gt;) so you can check for that error when Marshaling.&lt;/p&gt;\n\n&lt;p&gt;So you could try something like that:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if err != nil {\n    _, ok := err.(*json.UnsupportedTypeError)\n    if ok {\n        return []byte(\"Tried to Marshal Invalid Type\")\n    } else {\n        return []byte(\"Venue does not exist\")\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Go-将泛型结构传递给函数", ["\n\n", "Considering the following code, which is responding to GET '/venues/:id':", "\n\n", "func venueShow(w http.ResponseWriter, req *http.Request) {\n\n  // get ID from params\n  vars := mux.Vars(req)\n  id := vars[\"id\"]\n\n  // initialise new struct\n  var venue Venue\n\n  // select by id and scan into struct\n  db.First(&venue, id).Scan(&venue)\n\n  // turn it to json\n  response := structToJSON(&venue)\n\n  // write headers and provide response\n  w.Header().Set(\"Content-Type\", \"application/json\")\n  w.Write(response)\n}\n", "\n\n", "and:", "\n\n", "func structToJSON (s interface{}) (response []byte) {\n  // turn it into pretty-ish json\n  response, err := json.MarshalIndent(&s, \"\", \"  \")\n  if err != nil {\n   return []byte(\"Venue does not exist\")\n  }\n  // return the json as the reponse\n  return response\n}\n", "\n\n", "My structToJSON function is taking an empty interface as the argument, because I want to pass various different structs to the function and have them spewed out as JSON.", "\n\n", "However, it doesn't strike me as very safe. If anything satisfies an empty interface, I could pass whatever I wanted into that function, and all sorts of errors might happen when json.Marshal tries to do it's business. This (I suppose) would be caught by the compiler rather than at runtime, but is there a safer way?", "\n\n", "I could duplicate the structToJSON method for each different type of Struct/Model that I pass to it, but that's not very DRY.", "\n\n", "Thanks", "\n    "]], "Tag": "程序设计"}
{"Answer": "第二行是因为数组对象也是object类的子类吧，第三行我也不懂为啥……同求解", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型数组的一个小问题（很简单！求解！）", ["代码如下：", "\n\n", "List<String>[] lsa = new List<String>[10]; // Not really allowed.  \nObject o = lsa;  \nObject[] oa = (Object[]) o;  \nList<Integer> li = new ArrayList<Integer>();  \nli.add(new Integer(3));  \noa[1] = li; // Unsound, but passes run time store check  \nString s = lsa[1].get(0); // Run-time error: ClassCastException.  \n", "\n\n", "代码第二行到第三行怎么理解，单独理解第二行还能明白，但第三行那个强制转换具体怎么做到的？不太懂，求解释原理。。"]], "Tag": "程序设计"}
{"Answer": "什么意思？你应该这么写\r\nT GetEntity(IEnumerable&lt;T&gt; entity, sting keyword)\r\n {\r\n    return entity.FirstOrDefault(x =&gt; x.字段 == keyword);\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["单个泛型变量的查询怎么做？", ["T GetEntity(T entity, sting keyword)", "\n{", "\n这个代码怎么补充，要求查找关键字匹配的", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我知道,我现在明白了,是这样的,你写错了类型,你然后就是引用那个类的方法,然后不是静态方法,就会出现这种提示了,&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["mp LambdaQueryWrapper 这个泛型不填,使用Role::getRoleId,提示不能在无法从 static 上下文引用非 static 方法", ["    @Override\n    ", "public", " String checkRoleNameUnique(", "Role", " ", "role", ") {\n        baseMapper.", "exists", "(", "new", " LambdaQueryWrapper<>().eq(", "Role", "::getRoleId,", "role", ".getRoleId())); // 这个", "Role", "::getRoleId提示不能在无法从 static 上下文引用非 static 方法\n        ", "return", " ", "null", ";\n    }\n"]], "Tag": "程序设计"}
{"Answer": "```\r\nimport java.util.* ;\r\n\r\npublic class Test {\r\n\t\r\n\tstatic&lt;T&gt; void showpush (Stack&lt;T&gt; st, T a) {\r\n\t\tst.push(a) ;\r\n\t\tSystem.out.println(\"入栈（\" + a + \"）\") ;\r\n\t\tSystem.out.println(\"Stack:\" + st) ;\r\n\t}\r\n\tstatic&lt;T&gt; void showpop (Stack&lt;T&gt; st) {\r\n\t\tSystem.out.print(\"出栈 -&gt; \") ;\r\n\t\tT a = (T) st.pop() ;\r\n\t\tSystem.out.println(a) ;\r\n\t\tSystem.out.println(\"Stack:\" + st) ;\r\n\t}\r\n\tpublic static void main(String args[]) {\r\n\t\t//Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;() ;\r\n\t\tStack&lt;String&gt; st = new Stack&lt;String&gt;() ; //使用Stack&lt;String&gt; 则必须传入String\r\n\t\tSystem.out.println(\"Stack:\" + st) ;\r\n\t\t/*showpush(st, 42) ;\r\n\t\tshowpush(st, 66) ;\r\n\t\tshowpush(st, 99) ;*/\r\n\t\tshowpush(st, \"42\") ;\r\n\t\tshowpush(st, \"66\") ;\r\n\t\tshowpush(st, \"99\") ;\r\n\t\tshowpop(st) ;\r\n\t\tshowpop(st) ;\r\n\t\tshowpop(st) ;\r\n\t\ttry {\r\n\t\t\tshowpop(st) ;\r\n\t\t}\r\n\t\tcatch (EmptyStackException e) {\r\n\t\t\tSystem.out.println(\"出现异常：栈中内容为空\") ;\r\n\t\t}\r\n\t}       \r\n}\r\n \r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["这段Java代码怎么加泛型，本人Java刚起步，望大神指点。", ["import java.util.* ;", "\n\n", "public class testdemo {", "\n        static void showpush (Stack st, int a) {", "\n                st.push(a) ;", "\n                System.out.println(\"入栈（\" + a + \"）\") ;", "\n                System.out.println(\"Stack:\" + st) ;", "\n            }", "\n        static void showpop (Stack st) {", "\n                System.out.print(\"出栈 -> \") ;", "\n                Integer a = (Integer) st.pop() ;", "\n                System.out.println(a) ;", "\n                System.out.println(\"Stack:\" + st) ;", "\n            }", "\n\n", "    public static void main(String args[]) {\n            Stack st = new Stack () ;\n            System.out.println(\"Stack:\" + st) ;\n            showpush(st, 42) ;\n            showpush(st, 66) ;\n            showpush(st, 99) ;\n            showpop(st) ;\n            showpop(st) ;\n            showpop(st) ;\n            try {\n                    showpop(st) ;\n                }\n            catch (EmptyStackException e) {\n                    System.out.println(\"出现异常：栈中内容为空\") ;\n                }\n        }       \n}\n"]], "Tag": "程序设计"}
{"Answer": "http://www.w2bc.com/Article/22805", "Konwledge_Point": "泛型机制——模板", "Question": ["gson解析对象数组，使用泛型封装报错", ["问题如下：", "\n\n", " public class App {\n\n    public static void main(String[] args) {\n        List<User> userList = new ArrayList<>();\n\n        String json = \"[{\\\"uid\\\":1,\\\"username\\\":\\\"user1\\\",\\\"password\\\":\\\"user1\\\",\\\"type\\\":\\\"普通\\\"},\"\n                + \"{\\\"uid\\\":2,\\\"username\\\":\\\"user2\\\",\\\"password\\\":\\\"user2\\\",\\\"type\\\":\\\"普通\\\"},\"\n                + \"{\\\"uid\\\":3,\\\"username\\\":\\\"user3\\\",\\\"password\\\":\\\"user3\\\",\\\"type\\\":\\\"普通\\\"}]\";\n\n        userList = jsonToBeanList(json, User.class);\n        // 这个地方报错：java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap \n        // cannot be cast to com.hezhujun.match.pojo.User\n        for (User user : userList) {\n            System.out.println(user);\n        }\n\n    }\n\n    public static <T> List<T> jsonToBeanList(String json, Class<T> clas) {\n        Gson gson = new Gson();\n        List<T> list = gson.fromJson(json, new TypeToken<List<T>>() {\n        }.getType());\n        // 这个地方可以正常打印\n        for (T t : list) {\n            System.out.println(t);\n        }\n        return list;\n    }\n\n    /* 运行之后控制台输出的信息\n\n     {uid=1.0, username=user1, password=user1, type=普通}\n    Exception in thread \"main\" {uid=2.0, username=user2, password=user2, type=普通}\n    {uid=3.0, username=user3, password=user3, type=普通}\n    java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.hezhujun.match.pojo.User\n    at com.hezhujun.match.util.App.main(App.java:22)\n\n\n     */\n}\n"]], "Tag": "程序设计"}
{"Answer": "看相对于谁来说\r\nT对于泛型来说，是一个具体的类型，对于调用泛型的来说，是一个任意（也有约束）的类型\r\n而?对于泛型来说，它也是一个任意类型。\r\n? extends E表示约束，也就是?必须是E或者E的派生类", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型的问题，谁能相对通俗点解释下？", ["1：为什么说T是代表特定类型，?代表任意类型，T不也是未知任意的类型吗，具体的要由实例化时传入的类型决定，传入之前不也是未知任意的吗？", "\n2：下图如何理解？", "\n为什么说？的意义是实例化泛型参数，？不是代表任意类型吗（如果去掉图中的extends），怎么能实例化类型参数T呢，他自己本身就是任意类型？"]], "Tag": "程序设计"}
{"Answer": "http://ideone.com/BOg1UZ\r\n确实可以。应该书上写错了。或者apple不是从fruit继承的。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于thinking in JAVA泛型里的一点问题", ["\n书上说把new Apple()放到List里是不可以的 然而自己写了下是可以放的 也不是版本的问题 那么问题来了..这是什么情况"]], "Tag": "程序设计"}
{"Answer": "```\r\n是你声明时候的问题，\r\nHolder&lt;?&gt; unbounded = new Holder&lt;Long&gt;();\r\n你这样写在传入的时候还是解析为？类型，java中会提示编译错误（wildSuperType（Holder&lt;? super T&gt;,T）to (Holder&lt;capture?&gt;,Long)）,只需要改为Holder&lt;Lang&gt; unbounded = new Holder&lt;&gt;();\r\n```\r\n\r\n至于wildSubType()方法因为是采用泛型上边界，所以无法set任何参数。你传入的arg参数根本就没用到，因此就没有报编译时错误（因为这个方法只是get了对象内的值，此时无论你的Holder对象时什么类型都不影响）\r\n\r\n这是我的理解，不一定对。", "Konwledge_Point": "泛型机制——模板", "Question": ["对Java泛型的一些疑问", ["java编程思想的泛型 15.10 通配符章节有这样一段代码", "\n\n", "package holder;\n\npublic class Holder<T> {\n    private T value;\n    public Holder() {\n\n    }\n    public Holder(T val) {\n        value = val;\n    }\n    public T get() {\n        return value;\n    }\n    public void set(T val) {\n        value = val;\n    }\n\n}\n\n\n", "\n\n", "package holder;\n\npublic class Wildcards {\n    static <T> T wildSubType(Holder<? extends T> holder, T arg) {\n        T t = holder.get();\n        return t;\n    }\n    static <T> void wildSuperType(Holder<? super T> holder, T arg) {\n        holder.set(arg);\n        Object obj = holder.get();\n    }\n    public static void main(String[] args) {\n        Holder<?> unbounded = new Holder<Long>();\n        Long lng = 1L;\n        Object r11 = wildSubType(unbounded, lng);\n        //The method wildSuperType(Holder<? super T>, T) \n        //in the type Wildcards is not applicable \n        //for the arguments (Holder<capture#5-of ?>, Long)\n        //wildSuperType(unbounded,lng); \n\n    }\n\n}\n\n", "\n\n", "为什么wildSubType(Holder<? extends T> holder, T arg)  方法可以接受 Holder<?> 作为参数 而  wildSuperType(Holder<? super T> holder, T arg)  却不能接受H older<?> 按照我自己的理解 应该两个都报错  ", "\n\n", "------- 讲一个题外话 ----", "\n我用工作电脑 两个都报错", "\n用自己的电脑 就和书中写的一样 jdk都是1.8 很迷"]], "Tag": "程序设计"}
{"Answer": "arraylist是C# 1.0时代的产物，对于简单类型，需要装箱拆箱，并且缺乏类型检查。建议用list", "Konwledge_Point": "泛型机制——模板", "Question": ["C#的ArrayList和List泛型有什么区别？分别从性能、功能、难易等方面详细分析", ["C#的ArrayList和List泛型有什么区别？分别从性能、功能、难易等方面详细分析"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;查到了,区别在于是否为静态方法.&lt;br /&gt;非静态方法的调用时对象调用.&lt;br /&gt;而对象在new的时候,会进行泛型T的声明.&lt;br /&gt;一旦声明过了.上下文中就知道T为何物.非静态方法就可以直接使用T了.&lt;/p&gt;\n&lt;p&gt;但如果是静态方法,因为可以被Class直接调用,没有new的过程.&lt;br /&gt;所以上下文中T是不存在的.此刻,静态方法返回值前面的那个T就是声明了.&lt;br /&gt;用来告诉编译器,这个静态方法中需要用一个T类型.这里可以将静态方法中所有的T改成ABCD什么都行.&lt;br /&gt;你会发现方法不报错.因为这里的T已经不是类中那个T了.而是静态方法声明出来的.&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型,这前面的和后面的什么区别啊?", ["\n", "\n", "public", " ", "static", " <T> R<T> ", "failed", "(", "String", " msg", ") {\n        ", "return", " ", "restResult", "((", "Object", ")", "null", ", ", "ApiErrorCode", ".", "FAILED", ".", "getCode", "(), msg);\n    }\n", "\n", "第二个T我知道什么意思,但是第一个T是什么意思啊?"]], "Tag": "程序设计"}
{"Answer": "Type t = this.getClass().getGenericSuperclass();\r\n\t\tif (ParameterizedType.class.isAssignableFrom(t.getClass())) {\r\n\t\t\tfor (Type t1 : ((ParameterizedType) t).getActualTypeArguments()) {\r\n\t\t\t\tSystem.out.print(t1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n这个虽然短，我想对你有意义。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型类的注入的疑问！", ["首先有一个类如下：", "\n[code=\"java\"]public class Base  {", "\n    protected Class entityClass;", "\n\n", "public Base() {\n\n}\n\npublic Base(Class<T> clz) {\n    this.entityClass = clz;\n}\n", "\n\n", "}[/code]", "\n这是一个泛型类", "\n有一个Father类：", "\n[code=\"java\"]public class Father {", "\n\n", "}[/code]", "\n然后有一个MyBase1:", "\n[code=\"java\"]public class MyBase1 extends Base {", "\n\n", "}[/code]", "\n通过泛型类将Father注入到了MyBase1中，现在测试：", "\n[code=\"java\"]MyBase1 mbase=new MyBase1();", "\nSystem.out.println(mbase.entityCLass);[/code]结果输入为空，这里如果在MyBase1中增加构造函数：", "\n[code=\"java\"]public class MyBase1 extends Base {", "\n    public MyBase1(){", "\n      super.entityClass=Father.class;", "\n   }[/code]这样才能输出结果，请问如果不增加任何构造函数如何实现能够输出System.out.println(mbase.entityCLass)的值为Father呢？而且如果使用了构造函数那么使用有什么意义！盼望高手回答！", "\n}"]], "Tag": "程序设计"}
{"Answer": "通过反射可实现\r\n\r\n```\r\n public MainWindow()\r\n{\r\n\tInitializeComponent();\r\n\r\n\tTest test = new Test();\r\n\ttest.Name = \"TestABC\";\r\n\tConsole.WriteLine(GetProp(test, \"Name\"));\r\n}\r\n\r\npublic class Test\r\n{\r\n\tpublic string Name { get; set; }\r\n}\r\n\r\nobject GetProp&lt;T&gt;(T entity, string propName)\r\n{\r\n\tPropertyInfo[] props = entity.GetType().GetProperties();\r\n\tPropertyInfo prop = props.Where(p =&gt; p.Name == propName).FirstOrDefault();\r\n\tif (prop == null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn prop.GetValue(entity, null);\r\n\t}\r\n}\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型如何读取变量？这里这么写肯定是不对的。请问怎么写？", ["void T GetProp(T entity, string propName)", "\n{", "\n    return entity.propName();这里这么写肯定是不对的。请问怎么写？", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先判断 t 和 t1的类型&lt;br /&gt;用 t instanceof Integer  可以判断是否是Integer类型&lt;br /&gt;t instanceof String 判断是否是String类型&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java用泛型将字符，数值等相加", ["问题遇到的现象和发生背景", "\n", "\n", "问题相关代码，请勿粘贴截图", "\n", "import", " java.util.Scanner;\n\n", "public", " ", "class", " ", "oj2078", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "Scanner", " ", "sc", " ", "=", " ", "new", " ", "Scanner", "(System.in);\n        ", "while", "(sc.hasNext()){\n            ", "int", " ", "id", " ", "=", " ", "1", ";\n            ", "String", " ", "str", " ", "=", " sc.next();\n            ", "switch", " (str){\n                ", "case", " ", "\"I\"", ":\n                    GnnericsA<Integer> gg1 = ", "new", " ", "GnnericsA", "<>();\n                    ", "int", " ", "num1", " ", "=", " sc.nextInt();\n                    ", "int", " ", "num2", " ", "=", " sc.nextInt();\n                    gg1.setT(num1);\n                    System.out.println(", "\"Case \"", " + id++ + ", "\":整数类，和为\"", " + gg1.sum(num2));\n                    ", "break", ";\n                ", "case", " ", "\"S\"", ":\n                    GnnericsA<String> gg2 = ", "new", " ", "GnnericsA", "<>();\n                    ", "String", " ", "str1", " ", "=", " sc.next();\n                    ", "String", " ", "str2", " ", "=", " sc.next();\n                    gg2.setT(str1);\n                    System.out.println(", "\"Case \"", " + id++ + ", "\":字符串类，和为\"", " + gg2.sum(str2));\n            }\n        }\n    }\n}\n\n", "class", " ", "GnnericsA", "<T>{\n    ", "private", " T t;\n    T tt;\n\n\n    ", "public", " ", "void", " ", "setT", "(T t)", "{\n        ", "this", ".t = t;\n    }\n\n    ", "public", " T ", "sum", "(T t1)", " {\n        ", "return", " ", "this", ".t + t1 ;\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "Operator '+' cannot be applied to 'T', 'T'", "\n", "我想要达到的结果", "\n", "希望不违背题目要求"]], "Tag": "程序设计"}
{"Answer": "不可以，扩展方法不支持索引器。你只能用自定义的类实现：\r\nclass MyList : List&lt;string&gt;\r\n{\r\n    public string this[string index]\r\n\t\t{\r\n\t\t    return this.First(x =&gt; x == index);\r\n\t\t}\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["C#泛型的下标扩展的写法", ["如题，比如List buf=new List(new string[3]{\"a\",\"b\",\"c\"});", "\n正常使用下标：string temp=buf[0];得出temp=\"a\".", "\n现在想写一个扩展：string temp=buf[\"a\"];得出temp=\"a\".", "\n当然，举得列子可能不合适，目的是想写一个下标的那种扩展，我记得有这种扩展，但是忘记不知道怎么写的了，望高手指点"]], "Tag": "程序设计"}
{"Answer": "example refer url:http://www.javatpoint.com/spring-mvc-crud-example\r\n\r\nEmp.java\r\n\r\n```\r\npackage com.javatpoint.beans;  \r\n  \r\npublic class Emp {  \r\nprivate int id;  \r\nprivate String name;  \r\nprivate float salary;  \r\nprivate String designation;  \r\n  \r\npublic int getId() {  \r\n    return id;  \r\n}  \r\npublic void setId(int id) {  \r\n    this.id = id;  \r\n}  \r\npublic String getName() {  \r\n    return name;  \r\n}  \r\npublic void setName(String name) {  \r\n    this.name = name;  \r\n}  \r\npublic float getSalary() {  \r\n    return salary;  \r\n}  \r\npublic void setSalary(float salary) {  \r\n    this.salary = salary;  \r\n}  \r\npublic String getDesignation() {  \r\n    return designation;  \r\n}  \r\npublic void setDesignation(String designation) {  \r\n    this.designation = designation;  \r\n}  \r\n  \r\n}  \r\n```\r\n\r\nEmpDao.java\r\n\r\n\r\n```\r\npackage com.javatpoint.dao;  \r\nimport java.sql.ResultSet;  \r\nimport java.sql.SQLException;  \r\nimport java.util.List;  \r\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;  \r\nimport org.springframework.jdbc.core.JdbcTemplate;  \r\nimport org.springframework.jdbc.core.RowMapper;  \r\nimport com.javatpoint.beans.Emp;  \r\n  \r\npublic class EmpDao {  \r\nJdbcTemplate template;  \r\n  \r\npublic void setTemplate(JdbcTemplate template) {  \r\n    this.template = template;  \r\n}  \r\npublic int save(Emp p){  \r\n    String sql=\"insert into Emp99(name,salary,designation)   \r\n          values('\"+p.getName()+\"',\"+p.getSalary()+\",'\"+p.getDesignation()+\"')\";  \r\n    return template.update(sql);  \r\n}  \r\npublic int update(Emp p){  \r\n    String sql=\"update Emp99 set name='\"+p.getName()+\"', salary=\"+p.getSalary()+\",   \r\n          designation='\"+p.getDesignation()+\"' where id=\"+p.getId()+\"\";  \r\n    return template.update(sql);  \r\n}  \r\npublic int delete(int id){  \r\n    String sql=\"delete from Emp99 where id=\"+id+\"\";  \r\n    return template.update(sql);  \r\n}  \r\npublic Emp getEmpById(int id){  \r\n    String sql=\"select * from Emp99 where id=?\";  \r\n    return template.queryForObject(sql, new Object[]{id},new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));  \r\n}  \r\npublic List&lt;Emp&gt; getEmployees(){  \r\n    return template.query(\"select * from Emp99\",new RowMapper&lt;Emp&gt;(){  \r\n        public Emp mapRow(ResultSet rs, int row) throws SQLException {  \r\n            Emp e=new Emp();  \r\n            e.setId(rs.getInt(1));  \r\n            e.setName(rs.getString(2));  \r\n            e.setSalary(rs.getFloat(3));  \r\n            e.setDesignation(rs.getString(4));  \r\n            return e;  \r\n        }  \r\n    });  \r\n}  \r\n}  \r\n```\r\n\r\n是你想要的吗？", "Konwledge_Point": "泛型机制——模板", "Question": ["求个基于SPRING MVC的于oracle 数据库的CRUD泛型实例", ["基础的连接已经学会了。现在求各位大大指教下泛型的CRUD怎么写。", "\n\n", "public class Layer_tbl {\n    public int layerKeyID_grp;\n    public String layerElementID_grp;\n    public String layerId_grp;\n    public int projectId_grp;\n    public int layerPid_grp;\n}\n\n\n", "\n\n", "上面是实体类。需要实现的方法  通常的增删改   单个查询和表全展示。", "\n谢谢0 0."]], "Tag": "程序设计"}
{"Answer": "说一下思路吧，定一个目标数组，存储的是最后保留的数据，然后遍历数组，如果元素不是匹配的元素，即需要保留，就把它放入目标对象。\r\n最后打印目标数值就可以了。", "Konwledge_Point": "泛型机制——模板", "Question": ["Java语言从数组中删除所有和待匹配一致的的元素，要求使用泛型技术实现", ["Java语言从数组中删除所有和待匹配一致的的元素，要求使用泛型技术实现", "\nJava语言从数组中删除所有和待匹配一致的的元素，要求使用泛型技术实现"]], "Tag": "程序设计"}
{"Answer": "不好意思，应该是Join operator -_-||\r\n例子如下：\r\n\r\n    class Person\r\n    {\r\n        public string Name { get; set; }\r\n        public string Gender { get; set; }\r\n        public int Age { get; set; }\r\n\r\n        public Person(string name, string gender, int age)\r\n        {\r\n            Name = name;\r\n            Gender = gender;\r\n            Age = age;\r\n        }\r\n    }\r\n\r\n    class ScoreCard\r\n    {\r\n        public string Name { get; set; }\r\n        public string Sports { get; set; }\r\n        public int Score { get; set; }\r\n\r\n        public ScoreCard(string name, string sports, int score)\r\n        {\r\n            Name = name;\r\n            Sports = sports;\r\n            Score = score;\r\n        }\r\n    }\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            var persons = new List&lt;Person&gt;\r\n            {\r\n                new Person(\"凯特琳\", \"女\", 90),\r\n                new Person(\"崔斯特\", \"男\", 85),\r\n                new Person(\"嘉文\", \"男\", 80),\r\n                new Person(\"维恩\", \"女\", 95),\r\n                new Person(\"韦鲁斯\", \"男\", 80)\r\n            };\r\n\r\n            var scoreCards = new List&lt;ScoreCard&gt;\r\n            {\r\n                new ScoreCard(\"凯特琳\", \"射击\", 25),\r\n                new ScoreCard(\"维恩\", \"跳高\", 24)\r\n            };\r\n\r\n            var query = persons.Join(scoreCards,\r\n                p =&gt; p.Name,\r\n                sc =&gt; sc.Name,\r\n                (p, sc) =&gt; new { p.Name, p.Gender, p.Age, sc.Sports, sc.Score });\r\n\r\n            foreach (var item in query)\r\n            {\r\n                Console.WriteLine(\"{0} {1} {2} {3} {4}\",\r\n                    item.Name, item.Gender, item.Age, item.Sports, item.Score);\r\n            }\r\n\r\n        }\r\n    }\r\n\t\t\r\n\t\t==========================\r\n\t\t\r\n\t\t输出如下：\r\n\t\t凯特琳 女 90 射击 25\r\n\t\t维恩 女 95 跳高 24\r\n\t\t\r\n**不知是不是即使你现在遇到的问题？**", "Konwledge_Point": "泛型机制——模板", "Question": ["c#2个泛型集合找到某字段重复项，怎么做，谢谢", ["2个泛型集合", "\nList  st=new  List();", "\n包含3个字段  姓名  班级 成绩", "\n如:", "\n凯特琳    女    90", "\n崔斯特    男    85", "\n嘉文       男     80", "\n维恩       女     95", "\n韦鲁斯    男     80", "\n\n", "List  pl=new  List();", "\n包含3个字段  姓名  项目  年龄", "\n如:", "\n凯特琳    射击    25", "\n维恩       跳高     24", "\n\n", "我怎样找到这2个集合的都存在的项，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看到 ArrayList apples &amp;#61; new ArrayList &lt;strong&gt;&amp;lt;&amp;gt;&lt;/strong&gt; ();的尖括号 &lt;strong&gt;&amp;lt;&amp;gt;&lt;/strong&gt; 了吗&amp;#xff0c;这个是java里面的泛型&amp;#xff0c;简单来说就是&amp;lt;&amp;gt;传入的是什么对象&amp;#xff0c;就表示这个list存储什么类型的数据&amp;#xff0c;你这里要存储Apple类的数据&amp;#xff0c;当然创建列表是需要传入Apple类&amp;#xff0c;&lt;strong&gt;默认是Object类&lt;/strong&gt;&amp;#xff0c;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\nArrayList&amp;lt;Apple&amp;gt; apples &amp;#61; new ArrayList&amp;lt;&amp;gt;()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n                for(&lt;span class=\"hljs-name\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; 3; i&amp;#43;&amp;#43;)&lt;/span&gt;\n                    apples.add(&lt;span class=\"hljs-name\"&gt;new&lt;/span&gt; Apple())&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n                for(&lt;span class=\"hljs-name\"&gt;Apple&lt;/span&gt; apple : apples) {\n                    System.out.println(&lt;span class=\"hljs-name\"&gt;apple&lt;/span&gt;.id())&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java编程思想中泛型在JAVA8使用失败 ArrayList<>", ["问题遇到的现象和发生背景", "\n", "在看JAVA编程思想中有这样一段代码，说idea说不兼容的类型。", "\n", "问题相关代码，请勿粘贴截图", "\n", "import", " java.util.ArrayList;\n\n", "public", " ", "class", " ", "ApplesAndOrangesWithGenerics", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ", "ArrayList", " ", "apples", " ", "=", " ", "new", " ", "ArrayList", "<>();\n        ", "for", "(", "int", " ", "i", " ", "=", " ", "0", "; i < ", "3", "; i++)\n            apples.add(", "new", " ", "Apple", "());\n        ", "for", "(Apple apple : apples) {\n            System.out.println(apple.id());\n        }\n    }\n}\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "不知道为什么会出现这样的问题，查了很多也不知道怎么解决。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;Pair&amp;lt;?&amp;gt;和Pair本质的不同在于:可以用任意Object对象调用原始的Pair类的setFirst方法.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;这句话的意思是一个Object对象作为参数来调用&lt;strong&gt;Pair类的setFirst方法.&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;而不是使用一个Object类型的变量来接受Pair类的实例&amp;#xff0c;再调用这个变量的&lt;strong&gt;setFirst方法。&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;要验证的话&amp;#xff0c;应该这样来对比&amp;#xff1a;&lt;/strong&gt;&lt;br /&gt;\n &lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-java\"&gt;Pair e1 &amp;#61; new Pair(new Manager(12.4, 15, &amp;#34;ceo&amp;#34;), new Manager(12.4, 15, &amp;#34;ceo&amp;#34;)); \n\nPair&amp;lt;?&amp;gt; e2 &amp;#61; new Pair(new Manager(12.4, 15, &amp;#34;ceo&amp;#34;), new Manager(12.4, 15, &amp;#34;ceo&amp;#34;)); \n\ne1.setFirst(new Manager(12.4, 15, &amp;#34;ceo&amp;#34;));\n\ne2.setFirst(new Manager(12.4, 15, &amp;#34;ceo&amp;#34;));&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;br /&gt;\n &lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java中泛型类，无限定通配符问题", ["\n\n", " ", "\n\n", "看到java core卷1时，关于泛型类中无限定通配符这里，它讲说", "Pair<?>和Pair本质的不同在于:可以用任意Object对象调用原始的Pair类的setFirst方法.", "\n\n", "我的疑问是：Object e = new Pair(new Manager(12.4, 15, \"ceo\"), new Manager(12.4, 15, \"ceo\"));之后在编译器中并不能调用e.setFirst为什么这里说Object对象可以调用原始Pair类setFirst方法"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-html\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;MyCallable&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;Integer&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-symbol\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;Callable&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;Integer&lt;/span&gt;&amp;gt;\n你这么定义等价于 &lt;span class=\"hljs-symbol\"&gt;Integer&lt;/span&gt; 是一个你自己定义的符号 和这么写没区别\n\n&lt;span class=\"hljs-symbol\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;MyCallable&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;T&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-symbol\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;Callable&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;Integer&lt;/span&gt;&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java实现Callable接口 出现的泛型问题", ["//错误代码\n", "class", " MyCallable<", "Integer", "> implements Callable<", "Integer", ">\n{\n    ", "int", " ", "sum", "=", "0", ";\n    @Override\n    ", "public", " ", "Integer", " ", "call", "() throws Exception {\n        for(", "int", " i=", "0", ";i<=", "100", ";i++)\n        {\n            System.", "out", ".println(Thread.currentThread().getName()+", "\"输出\"", "+i);\n            ", "sum", "+=i;\n        }\n        ", "return", " ", "sum", ";//报错\n    }\n}\n\n//正确代码\n", "class", " MyCallable<", "Integer", "> implements Callable<java.lang.", "Integer", ">\n{\n    ", "int", " ", "sum", "=", "0", ";\n    @Override\n    ", "public", " java.lang.", "Integer", " ", "call", "() throws Exception {\n        for(", "int", " i=", "0", ";i<=", "100", ";i++)\n        {\n            System.", "out", ".println(Thread.currentThread().getName()+", "\"输出\"", "+i);\n            ", "sum", "+=i;\n        }\n        ", "return", " ", "sum", ";\n    }\n}\n\n\n", "\n", "我想实现Callable接口，为什么<>里面不能填Integer，而是必须填java.lang.Integer，两个不是一样吗"]], "Tag": "程序设计"}
{"Answer": "http://stackoverflow.com/questions/75175/create-instance-of-generic-type-in-java\r\n用`Class&lt;T&gt;`的newInstance", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型的问题: T object = new T()能否通过设置IDE来让其成立", ["public class Example {", "\n       ..........", "\n            void doSomething()", "\n            {", "\n                            T object = new T();", "\n            }", "\n}", "\n\n", "方法doSomething()里的 new T() 在Eclipse里是不能通过的。是因为java编译器不认识 T么？ 我能否通过设置Eclipse里的Generics features来让此段代码通过？"]], "Tag": "程序设计"}
{"Answer": "已经在另一个贴回答你了，简单来说，所谓协变逆变其实只是让编译器对代码放行，因为早期clr的设计并没有考虑协变逆变，所以基于类型的协变逆变其实还是不支持的。", "Konwledge_Point": "泛型机制——模板", "Question": ["link里面支持的是哪种形式的泛型顺变和逆变机制？和汇总是什么关系？", ["link里面支持的是哪种形式的泛型顺变和逆变机制？和汇总是什么关系？"]], "Tag": "程序设计"}
{"Answer": "不使用dynamic时会自动转换为object类型\r\n这很正常，因为 return builder.t(cache); 的调用是在编译期间确定的，而编译器编译field的时候不知道T的类型，它不可能为field&lt;DateTime&gt;使用一种类型推断，为别的类型使用另一种。\r\n\r\nreturn builder.t((dynamic)cache);则不同，编译器无法推测catche的类型（否则就不叫动态了），它在运行期间确定cache的类型（从IL层面看，用ldtoken指令，但是C#没有对应的语法），然后CLR动态确定重载类型，于是可以调用 t(DateTime dt) 的版本", "Konwledge_Point": "泛型机制——模板", "Question": ["C# [疑似bug]关于泛型进行方法重载时遇到的问题, 不使用dynamic时会自动转换为object类型", ["在写一个项目时遇到了一个问题, 百思不得其解特意来CSDN求助,提供测试程序如下所示:", "\n\n", "在对泛型对象使用重载方法时, T obj 会被自动识别为 object obj类型, ", "\n但测试 obj is T(手动输入一个类型) 时会返回true, ", "\n但是给obj 加上(dynamic)后 又能成功识别为T.", "\n\n", "具体测试源码:", "\nusing System;", "\n\n", "namespace ConsoleApplication38", "\n{", "\n    public class builder", "\n    {", "\n        public static string t(DateTime dt) { return \"进入了重载方法\"+dt.Millisecond; }", "\n        public static string t(object obj) { return obj.ToString(); }", "\n    }", "\n    public class field", "\n    {", "\n        public T cache;", "\n        public string ToString1() { return builder.t((dynamic)cache); }", "\n        public string ToString2() { return builder.t(cache); }", "\n        //constructor", "\n        public field(T k) { cache = k; }", "\n    }", "\n    class Program", "\n    {", "\n        static void Main(string[] args)", "\n        {", "\n            field time = new field(DateTime.Now);", "\n            Console.WriteLine(\"type1:\" + time.ToString1());", "\n            Console.WriteLine(\"type2:\" + time.ToString2());", "\n            Console.ReadKey();", "\n        }", "\n    }", "\n}", "\n\n", "执行结果:", "\ntype1:进入了重载方法128", "\ntype2:2016-11-23 星期三 02-02-48-07 上午", "\n\n", "预期结果应该是type1 和type2 相同才对, 求大神解答到底是什么地方出现了问题?", "\n*class 执行的结果和 construction(T obj) 是一样的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;根据你调用方法的接受类型判断&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型方法的疑问，对于这种参数没有泛型，返回值为泛型的泛型方法，如何确定泛型的具体类型？", ["关于泛型方法的疑问，对于这种参数没有泛型，返回值为泛型的泛型方法，如何确定泛型的具体类型？", "\n", "public <E> E get", "Value(Connection ", "conn", ", String ", "sql", ", Object ", "...", "args", ")", " {\n        PreparedStatement ps = null;\n        ResultSet rs = null;\n        ", "try", " {\n            ps = conn.prepare", "Statement(", "sql", ")", ";\n            ", "for", " (", "int", " i = ", "0", "; i < args.length; i++) {\n                ps.set", "Object(", "i", "+1, ", "args", "[", "i", "])", ";\n            }\n\n            rs = ps.execute", "Query()", ";\n            ", "if", " (rs.next", "()", "){\n                return (E)rs.get", "Object(1)", ";\n            }\n        } catch (SQLException e) {\n            e.print", "StackTrace()", ";\n        } finally {\n            ", "JDBCUtils", ".", "close", "Resource(", "null", ",", "ps", ",", "rs", ")", ";\n        }\n        return null;\n    }\n\n", "\n", "public", " Long getCount(", "Connection", " conn) {\n        String ", "sql", " = \"select count(*) from customers\";\n        ", "return", " getValue(conn, ", "sql", ");\n\n    }\n\n", "\n", "运行是成功的，返回了一个Long类型。不明白怎么成功的"]], "Tag": "程序设计"}
{"Answer": "晕哦，当然要抛空指针异常了\r\n\r\n你的UserDao类的成员session都没有设置，你哪来的session", "Konwledge_Point": "泛型机制——模板", "Question": ["请教，泛型DAO调试不通，提示java.lang.NullPointerException。", ["刚刚接触学习泛型DAO，按照网上的一个例子来写，运行就提示，Exception in thread \"main\" java.lang.NullPointerException。开发环境是myeclipse6.5,jdk5.0，只好来这里请教，代码如下：", "\n\n", "[code=\"java\"]文件列表1：", "\n文件名 说明 ", "\nIDao.java dao的顶层抽象接口 ", "\nAbstractDao.java IDao的实现类，实现了get/update/delete等基本操作 ", "\nUser.java USER表对应的entity定义 ", "\nIUserDao.java USER表操作DAO接口定义 ", "\nUserDao.java USER表操作DAO实现 ", "\nHelloGenerics.java 测试类 ", "\n\n", "IDao.java", "\n// super dao interface", "\npublic interface IDao  {", "\n    public T get(PK pk);", "\n    public List getAll();", "\n    public PK save(T entity);", "\n    public void update(T entity);", "\n    public void saveOrUpdate(T entity);", "\n    public void delete(T entity);", "\n}", "\n\n", "AbstractDao.java", "\n//super abstract dao class", "\npublic abstract class AbstractDao implements IDao {", "\n    private Class clz;", "\n\n", "public AbstractDao(Class clz) {\n     this.clz = clz;\n }\n\npublic T get(PK pk) {\n    return (T)getSession().get(clz, pk);\n }\npublic List <T>getAll() {\n    return getSession().createCriteria(clz).list();\n }\npublic PK save(T entity) {\n    return (PK)getSession().save(entity);\n }\npublic void update(T entity) {\n     getSession().update(entity);\n }\npublic void saveOrUpdate(T entity) {\n     getSession().saveOrUpdate(entity);\n }\npublic void delete(T entity) {\n     getSession().delete(entity);\n }\n\nprivate Session session;\nprotected Session getSession() {\n    //wrap session in a class such as HibernateUtils, then you can use   HibernateUtils.getCurrentSession() for getting a session.\n    return session;\n }\n", "\n\n", "}", "\n\n", "User.java", "\n//persist entity", "\npublic class User {", "\n    private String id;", "\n    private String name;", "\n\n", "public String getId() {\n    return id;\n }\npublic void setId(String id) {\n     this.id = id;\n }\npublic String getName() {\n    return name;\n }\npublic void setName(String name) {\n     this.name = name;\n }\n\n//... setter/getter HERE\n", "\n\n", "}", "\nIUserDao.java", "\n//User Dao interface", "\npublic interface IUserDao extends IDao  {", "\n    // all are empty", "\n}", "\n\n", "UserDao.java", "\n//UserDao Implementation", "\npublic class UserDao extends AbstractDao  implements IUserDao {", "\n    public UserDao() {", "\n        super(User.class);", "\n     }", "\n    // or use the following constructor", "\n    //public UserDao(Class type) {", "\n    //     super(type);", "\n    //}", "\n}", "\n\n", "HelloGenerics.java ", "\npublic class HelloGenerics {", "\n\n", "public static void main(String[] args) {\n     IUserDao userDao = new UserDao();\n     User user = userDao.get(\"1\");\n    if (user != null) {\n         System.out.println(user.getName());\n     }\n\n     List<User> userList = userDao.getAll();\n    for (User u:userList) {\n         System.out.println(user.getName());\n     }\n }\n", "\n\n", "}[/code]"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;  &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;BaseService&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-symbol\"&gt;T,&lt;span class=\"hljs-symbol\"&gt;ID&lt;/span&gt;&lt;/span&gt;&amp;gt; {\n\n    &lt;span class=\"hljs-comment\"&gt;//不能使用&amp;#64;Resource 否则Spring无法正确注入BaseMapper&amp;lt;T,ID&amp;gt;  无法识别&lt;/span&gt;\n    &amp;#64;Autowired\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; BaseMapper&amp;lt;T,ID&amp;gt; baseMapper;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同时给baseMapper类加上注解交给IOC 就好了 是这个嵌套的内置注入发生了问题  注解&lt;a class=\"md_call_user\" type=\"user\"&gt;&amp;#64;Resource &lt;/a&gt;无法识别&lt;/p&gt;\n&lt;p&gt;已解决&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["spring容器无法识别 Mapper继承父类BaseMapper<T,ID> 带泛型", ["\n\n\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "26.483", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " com.chaos.crm1.Starter                   : Starting Starter on DESKTOP-F2FOF97 ", "with", " PID ", "28828", " (D:\\code\\javacode\\crm1\\target\\classes started by Chaos ", "in", " D:\\code\\CRM1)\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "26.485", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " com.chaos.crm1.Starter                   : No active profile set, falling back ", "to", " default profiles: default\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "26.524", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " o.s.b.devtools.restart.ChangeableUrls    : The Class-Path manifest attribute ", "in", " D:\\mysql\\maven\\repository\\com\\mchange\\c3p0\\", "0.9", ".", "5.5", "\\c3p0-", "0.9", ".", "5.5", ".jar referenced one ", "or", " more files that ", "do", " not exist: file:/D:/mysql/maven/repository/com/mchange/c3p0/", "0.9", ".", "5.5", "/mchange-commons-java-", "0.2", ".", "19.", "jar\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "26.524", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' ", "to", " '", "false", "' ", "to", " disable\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "26.524", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property ", "to", " 'DEBUG'\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.263", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized ", "with", " port(s): ", "80", " (http)\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.268", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " o.apache.catalina.core.StandardService   : Starting service ", "[T", "omcat", "]", "\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.269", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " org.apache.catalina.core.StandardEngine  : Starting Servlet engine: ", "[A", "pache", " T", "omcat", "/", "9.0", ".", "29", "]", "\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.339", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " o.a.c.c.C.", "[T", "omcat", "]", ".", "[", "localhost", "]", ".", "[", "/", "crm1", "]", "   : Initializing Spring embedded WebApplicationContext\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.339", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed ", "in", " ", "815", " ms\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.372", "  WARN ", "28828", " --- ", "[  ", "restartedMain", "]", " ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean ", "with", " name 'indexController': Injection ", "of", " resource dependencies failed; nested ", "exception", " is org.springframework.beans.factory.BeanCreationException: Error creating bean ", "with", " name 'loginService': Injection ", "of", " resource dependencies failed; nested ", "exception", " is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean ", "of", " ", "type", " 'com.chaos.crm1.base.BaseMapper<?, ?>' available: expected single matching bean but found ", "2", ": saleChanceMapper,userMapper\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.373", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " o.apache.catalina.core.StandardService   : Stopping service ", "[T", "omcat", "]", "\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.384", "  INFO ", "28828", " --- ", "[  ", "restartedMain", "]", " ConditionEvaluationReportLoggingListener : \n\nError starting ApplicationContext. To display the conditions report re-run your application ", "with", " 'debug' enabled.\n", "2021", "-", "08", "-", "16", " ", "23", ":", "13", ":", "27.391", " ERROR ", "28828", " --- ", "[  ", "restartedMain", "]", " o.s.boot.SpringApplication               : Application run failed\n\norg.springframework.beans.factory.BeanCreationException: Error creating bean ", "with", " name 'indexController': Injection ", "of", " resource dependencies failed; nested ", "exception", " is org.springframework.beans.factory.BeanCreationException: Error creating bean ", "with", " name 'loginService': Injection ", "of", " resource dependencies failed; nested ", "exception", " is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean ", "of", " ", "type", " 'com.chaos.crm1.base.BaseMapper<?, ?>' available: expected single matching bean but found ", "2", ": saleChanceMapper,userMapper\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "post", "ProcessProperties(CommonAnnotationBeanPostProcessor.", "java", ":337)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "populate", "Bean(AbstractAutowireCapableBeanFactory.", "java", ":1422)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "do", "CreateBean(AbstractAutowireCapableBeanFactory.", "java", ":594)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "create", "Bean(AbstractAutowireCapableBeanFactory.", "java", ":517)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractBeanFactory", ".", "lambda", "$doGetBean$0(AbstractBeanFactory.", "java", ":323)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "DefaultSingletonBeanRegistry", ".", "get", "Singleton(DefaultSingletonBeanRegistry.", "java", ":222)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractBeanFactory", ".", "do", "GetBean(AbstractBeanFactory.", "java", ":321)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractBeanFactory", ".", "get", "Bean(AbstractBeanFactory.", "java", ":202)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "DefaultListableBeanFactory", ".", "pre", "InstantiateSingletons(DefaultListableBeanFactory.", "java", ":879)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.support.", "AbstractApplicationContext", ".", "finish", "BeanFactoryInitialization(AbstractApplicationContext.", "java", ":878)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.support.", "AbstractApplicationContext", ".", "refresh(", "AbstractApplicationContext", ".", "java:", "550", ") ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.boot.web.servlet.context.", "ServletWebServerApplicationContext", ".", "refresh(", "ServletWebServerApplicationContext", ".", "java:", "141", ") ~", "[", "spring", "-", "boot", "-", "2.2", ".", "2.", "RELEASE.", "jar", ":", "2.2", ".", "2.", "RELEASE]", "\n    at org.springframework.boot.", "SpringApplication", ".", "refresh(", "SpringApplication", ".", "java:", "747", ") ~", "[", "spring", "-", "boot", "-", "2.2", ".", "2.", "RELEASE.", "jar", ":", "2.2", ".", "2.", "RELEASE]", "\n    at org.springframework.boot.", "SpringApplication", ".", "refresh", "Context(SpringApplication.", "java", ":397)", " ~", "[", "spring", "-", "boot", "-", "2.2", ".", "2.", "RELEASE.", "jar", ":", "2.2", ".", "2.", "RELEASE]", "\n    at org.springframework.boot.", "SpringApplication", ".", "run(", "SpringApplication", ".", "java:", "315", ") ~", "[", "spring", "-", "boot", "-", "2.2", ".", "2.", "RELEASE.", "jar", ":", "2.2", ".", "2.", "RELEASE]", "\n    at org.springframework.boot.", "SpringApplication", ".", "run(", "SpringApplication", ".", "java:", "1226", ") ~", "[", "spring", "-", "boot", "-", "2.2", ".", "2.", "RELEASE.", "jar", ":", "2.2", ".", "2.", "RELEASE]", "\n    at org.springframework.boot.", "SpringApplication", ".", "run(", "SpringApplication", ".", "java:", "1215", ") ~", "[", "spring", "-", "boot", "-", "2.2", ".", "2.", "RELEASE.", "jar", ":", "2.2", ".", "2.", "RELEASE]", "\n    at com.chaos.crm1.", "Starter", ".", "main(", "Starter", ".", "java:", "18", ") ~", "[", "classes", "/", ":", "na", "]", "\n    at java.base/jdk.internal.reflect.", "NativeMethodAccessorImpl", ".", "invoke0(Native Method) ~", "[", "na", ":", "na", "]", "\n    at java.base/jdk.internal.reflect.", "NativeMethodAccessorImpl", ".", "invoke(", "NativeMethodAccessorImpl", ".", "java:", "62", ") ~", "[", "na", ":", "na", "]", "\n    at java.base/jdk.internal.reflect.", "DelegatingMethodAccessorImpl", ".", "invoke(", "DelegatingMethodAccessorImpl", ".", "java:", "43", ") ~", "[", "na", ":", "na", "]", "\n    at java.base/java.lang.reflect.", "Method", ".", "invoke(", "Method", ".", "java:", "566", ") ~", "[", "na", ":", "na", "]", "\n    at org.springframework.boot.devtools.restart.", "RestartLauncher", ".", "run(", "RestartLauncher", ".", "java:", "49", ") ~", "[", "spring", "-", "boot", "-", "devtools", "-", "2.4", ".", "5.", "jar", ":", "2.4", ".", "5", "]", "\nCaused by: org.springframework.beans.factory.BeanCreationException: Error creating bean ", "with", " name 'loginService': Injection ", "of", " resource dependencies failed; nested ", "exception", " is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean ", "of", " ", "type", " 'com.chaos.crm1.base.BaseMapper<?, ?>' available: expected single matching bean but found ", "2", ": saleChanceMapper,userMapper\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "post", "ProcessProperties(CommonAnnotationBeanPostProcessor.", "java", ":337)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "populate", "Bean(AbstractAutowireCapableBeanFactory.", "java", ":1422)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "do", "CreateBean(AbstractAutowireCapableBeanFactory.", "java", ":594)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "create", "Bean(AbstractAutowireCapableBeanFactory.", "java", ":517)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractBeanFactory", ".", "lambda", "$doGetBean$0(AbstractBeanFactory.", "java", ":323)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "DefaultSingletonBeanRegistry", ".", "get", "Singleton(DefaultSingletonBeanRegistry.", "java", ":222)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractBeanFactory", ".", "do", "GetBean(AbstractBeanFactory.", "java", ":321)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractBeanFactory", ".", "get", "Bean(AbstractBeanFactory.", "java", ":207)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "AbstractAutowireCapableBeanFactory", ".", "resolve", "BeanByName(AbstractAutowireCapableBeanFactory.", "java", ":454)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "autowire", "Resource(CommonAnnotationBeanPostProcessor.", "java", ":543)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "get", "Resource(CommonAnnotationBeanPostProcessor.", "java", ":513)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor$ResourceElement", ".", "get", "ResourceToInject(CommonAnnotationBeanPostProcessor.", "java", ":653)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.annotation.", "InjectionMetadata$InjectedElement", ".", "inject(", "InjectionMetadata", ".", "java:", "224", ") ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.annotation.", "InjectionMetadata", ".", "inject(", "InjectionMetadata", ".", "java:", "116", ") ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "post", "ProcessProperties(CommonAnnotationBeanPostProcessor.", "java", ":334)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    ... ", "22", " common frames omitted\nCaused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean ", "of", " ", "type", " 'com.chaos.crm1.base.BaseMapper<?, ?>' available: expected single matching bean but found ", "2", ": saleChanceMapper,userMapper\n    at org.springframework.beans.factory.config.", "DependencyDescriptor", ".", "resolve", "NotUnique(DependencyDescriptor.", "java", ":220)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "DefaultListableBeanFactory", ".", "do", "ResolveDependency(DefaultListableBeanFactory.", "java", ":1265)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.support.", "DefaultListableBeanFactory", ".", "resolve", "Dependency(DefaultListableBeanFactory.", "java", ":1207)", " ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "autowire", "Resource(CommonAnnotationBeanPostProcessor.", "java", ":537)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "get", "Resource(CommonAnnotationBeanPostProcessor.", "java", ":513)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor$ResourceElement", ".", "get", "ResourceToInject(CommonAnnotationBeanPostProcessor.", "java", ":653)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.annotation.", "InjectionMetadata$InjectedElement", ".", "inject(", "InjectionMetadata", ".", "java:", "224", ") ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.beans.factory.annotation.", "InjectionMetadata", ".", "inject(", "InjectionMetadata", ".", "java:", "116", ") ~", "[", "spring", "-", "beans", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    at org.springframework.context.annotation.", "CommonAnnotationBeanPostProcessor", ".", "post", "ProcessProperties(CommonAnnotationBeanPostProcessor.", "java", ":334)", " ~", "[", "spring", "-", "context", "-", "5.2", ".", "2.", "RELEASE.", "jar", ":", "5.2", ".", "2.", "RELEASE]", "\n    ... ", "36", " common frames omitted\n\n\nProcess finished ", "with", " exit code ", "0", "\n\n", "\n", "\n", "public", " ", "interface", " ", "UserMapper", " ", "extends", " ", "BaseMapper", "<", "User", ",", "Integer", "> {\n\n \n    ", "public", "  User  selectUserByName(String userName);\n\n\n    ", "public", "   Integer updateUserPwd(Integer userId,String userPwd);\n\n\n}\n\n\n\n", "public", " ", "interface", " ", "SaleChanceMapper", " ", "extends", " ", "BaseMapper", "<", "SaleChance", ",", "Integer", "> {\n\n \n    ", "public", " List<SaleChance>  querySaleChance(String customerName,String creatorName,Integer state);\n\n}\n\n\n\n\n", "public", "  ", "class", " ", "BaseService", "<", "T,", "ID", "> {\n\n    @Resource\n    ", "private", " BaseMapper<T,ID> baseMapper;\n}\n\n@Service\n", "public", "    ", "class", " ", "LoginService", " ", "extends", " ", "BaseService", "<", "User,", "Integer", "> {\n\n        @Resource\n    ", "private", " UserMapper userMapper;\n}\n", "\n", "用的是接口代理方式实现dao", "我删除其中一个Mapper继承BaseMapper(Mapper抽取的父类)就不会报错   但我想保留父子关系   怎么处理  "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有关系&amp;#xff0c;   泛型数组  是指他的元素是一个泛型&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["请问 typescript的 泛型数组和泛型有关系吗？", ["// 泛型数组", "\n", "var", " ary: ", "Array", "<number> = [", "1", ", ", "2", ", ", "3", "]\n", "// 泛型", "\n", "function", " ", "fn", "<", "t", ">(", "x: t", ") ", "{\n  ", "return", " x\n}\n", "fn", "<", "number", ">(", "1", ")", "\n", "\n", "泛型数组在定义的时候，尖括号后面不需要()", "但是泛型函数在定义的时候就需要()", "我搞不定这两个虽然都是泛型名称开头，但是不是没有关系啊？"]], "Tag": "程序设计"}
{"Answer": "https://www.cnblogs.com/Java-dzz/p/6337300.html", "Konwledge_Point": "泛型机制——模板", "Question": ["springboot，jpa问题，谢谢解答", ["/**\n * 实体管理对象\n * @param builder\n * @return\n */\n@Bean\n@Primary\npublic LocalContainerEntityManagerFactoryBean aaEntityManagerFactory(EntityManagerFactoryBuilder builder){\n    return builder.dataSource(mtsystemDataSource())\n                                .packages(\"\")  .      //这里指什么意思？该填什么？\n            .persistenceUnit(\"\")  //这里指什么意思？该填什么？\n            .build();\n}\n"]], "Tag": "程序设计"}
{"Answer": "import java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\nclass ArrayListDemo\r\n{\r\n    public static void main(String[] args)\r\n    {\r\n\r\n        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();// 声明的时候需要指明元素的类型\r\n\r\n        int i = 0;\r\n        int x = 5;\r\n        while (i&lt; 10)\r\n        {\r\n\r\n            x = x+1;\r\n            i++;   //需要改变i保证能够退出循环\r\n            list.add(x);\r\n        }\r\n\r\n        Integer[] a = new Integer[list.size()];   //类型需要与list的元素类型匹配\r\n        list.toArray(a);\r\n\r\n        System.out.println(Arrays.toString(a));   //输出数组的内容可以借助一些工具类\r\n\r\n        int n = list.size()/2;    //怀疑你是要操作list，因为a作为数组，没有size，add，remove之类的方法\r\n\r\n        list.add(n,10);\r\n        System.out.println(list.toString());\r\n        list.remove(n);\r\n        System.out.println(list.toString());\r\n    }\r\n\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["求改一下这个程序,因为是刚接触泛型,自己写了试一下,发现好多问题", [" import java.util;\n\n\n\n\nclass ArrayListDemo\n{\npublic static void main(String[] args)\n{\n\nArrayList<> list = new ArrayList<>();// declare a type\n\nint i = 0;\nint x = 5;\nwhile (i< 10)\n{\n\nx = x+1;\nlist.add(x);\n}\n\nX[] a = new X[list.size()];\nlist.toArray(a);\n\nSystem.out.println(a.toString[]);\n}\n\nint n = a.size()/2;\na.add(n,10);\nSystem.out.println(a.toString);\na.remove(n);\nSystem.out.println(a.toString);\n} \n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt; 和 &lt;span class=\"hljs-tag\"&gt;&amp;lt;&lt;span class=\"hljs-name\"&gt;String&lt;/span&gt;&amp;gt;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java中泛型的问题", ["\n", "\n", "请问这两段代码中传入泛型实参和不传入泛型实参是指什么？  00000000000000000000000000000000000000000000000000000                                                        "]], "Tag": "程序设计"}
{"Answer": "楼主大大的代码用List&lt;E&gt;接口测试，\r\nList&lt;? extends E&gt; list：只能使用这样的方法：E出现在返回值类型上，同时E不能出现在参数的类型上\r\nList&lt;? super E&gt; list：只能使用这样的方法：E出现在参数的类型上，而不能出现在返回值类型上\r\n而List&lt;E&gt;则可以使用所有方法，无论E出现在哪里\r\n这样就很容易记住了。", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型 通配符", ["求解，为什么不能向fruit里面添加任何对象了呢？", "\n[code=\"java\"]", "\nclass ListGenertics{", "\n    public static void main(String... args) {", "\n        List<? extends Fruit> fruit=new ArrayList();", "\n        //fruit.add(new Fruit());error!", "\n        //fruit.add(new Object());error!", "\n    }", "\n}", "\nclass Fruit{}", "\nclass Apple extends Fruit{}", "\nclass Jonathan extends Apple{}", "\nclass Orange extends Fruit{}", "\n[/code]", "\n[b]问题补充：[/b]", "\n[code=\"java\"]", "\nfruit.add(new Apple());", "\n[/code]", "\n也不行，你试试", "\n[b]问题补充：[/b]", "\n是在看Thinking in java里面遇到的。现在似乎弄明白些了..."]], "Tag": "程序设计"}
{"Answer": "Func&lt;int&gt;既是泛型也是委托。表示一个没有参数，有int返回值的函数。", "Konwledge_Point": "泛型机制——模板", "Question": ["C#语言中泛型和委托的关系是什么，Func<int>是泛型还是委托？", ["C#语言中泛型和委托的关系是什么，Func是泛型还是委托？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的泛型名称定义为integer导致编译的时候 认为你返回的是一个泛型&amp;#xff0c;而不是integer类&amp;#xff0c;所以不存在自动拆箱了&amp;#xff0c;如果你的返回值值是固定的integer 你是没有必要定义泛型的&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型对程序代码编译期的影响", ["关于泛型的添加位置以及是否该添加，导致方法无法返回。自动拆装箱机制失效。", "\n", "为什么第14行会报错呢，在jdk8之后不是有自动拆装箱机制吗？", "但是如果将Impl后面的泛型去掉，程序编译通过，这又是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "错了，刚看了下是\r\n下面的方法中将要用到一个符号M来表示泛型，而这个泛型表示的具体类型，必须同时实现 Member 和 AnnotatedElement接口", "Konwledge_Point": "泛型机制——模板", "Question": ["有关泛型的疑问", ["最近在看Struts2的源码，但由于基础不够好（只有两年Java经验），看起来很吃力，源码中的代码组织与设计，以及一些编程思想对我来说很新颖，而且有不少知识是我没有接触过的，比如下面这种泛型：", "\n\n", " ", "\n\n", "  interface InjectorFactory<M extends Member & AnnotatedElement> {\n\n        Injector create( ContainerImpl container, M member, String name )\n                throws MissingDependencyException;\n    }", "\n\n", "\n 泛型我了解一些，但还比较浅，像上面这种用法我还是第一次见，而且也难以搜索到相关的博客，一般介绍泛型的博客也都流于表面。所以想在这里请教一下各位，这倒底是什么道理？那个&操作符是什么意思？谢谢了..."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; 望采纳&amp;#xff01;点击该回答右侧的“采纳”按钮即可采纳&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/p&gt;\n&lt;p&gt;总的来说就是&amp;#xff1a;在 Optional 的 ifPresent 方法中&amp;#xff0c;使用的是 Consumer 类型的参数&amp;#xff0c;即参数是一个消费 T 类型的函数。&lt;/p&gt;\n&lt;p&gt;泛型类型中的 &amp;#34;?&amp;#34; 表示未知类型&amp;#xff0c;&amp;#34;&amp;lt;? super T&amp;gt;&amp;#34; 表示任何是 T 的父类的类型。这里使用 &amp;#34;&amp;lt;? super T&amp;gt;&amp;#34; 的原因是&amp;#xff0c;它使得 Consumer 可以接受 T 及 T 的父类的对象作为参数。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;我给个例子&amp;#xff0c;如果 T 是 String 类型&amp;#xff0c;则 Consumer 可以接受 String 和 Object 类型的对象作为参数。这样做的目的是为了使 Consumer 更加通用&amp;#xff0c;可以接受更多的类型作为参数。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["一个java泛型问题", ["问题遇到的现象和发生背景", "\n", "想请教一个泛型问题。", "\n", "这个是Optional的ifPresent（）的方法源码，这里Consumer的泛型是不是 T 已经够了，如果够的话，实际上用的 <? super T>  有什么作用？    [疑问]", "\n"]], "Tag": "程序设计"}
{"Answer": "维数不匹配，建议删掉T getInstance(Class&lt;? extends IFacade&lt;?&gt;&gt; clazz) 里面的IFacade&lt;?&gt;问号，T getInstance(Class&lt;? extends IFacade&gt; clazz)", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型问题", ["public interface IFacade {", "\n    public Map execute(T param);", "\n}", "\n\n", "public final class FacadeFactory {", "\n    public static > T getInstance(Class<? extends IFacade<?>> clazz) {", "\n        return Factory.getBean(clazz.getSimpleName());", "\n    }", "\n}", "\n\n", "public class Facade implements IFacade> {", "\n    @Override", "\n    public Map execute(Map o) {", "\n            return null;", "\n        }", "\n    private static  void doSomething(List records) {", "\n        }", "\n}", "\n\n", "Facade facade = FacadeFactory.getInstance(Facade.class);", "\n\n", "最前边这个Facade类原来不带这个泛型，只是实现了IFacade>这个接口。", "\nFacadeFactory.getInstance(Facade.class);这个调用也是木有问题的。", "\n\n", "现在我由于需要Facade类增加了后，", "\nFacadeFactory.getInstance(Facade.class);这个工厂调用的getInstance部分就提示编译错误了。提示：", "\nZkiFacadeFactory 的方法 getInstance(Class<? extends IFacade<?>>) 的参数  (Class) 不匹配。", "\n\n", "请问是哪里的问题？"]], "Tag": "程序设计"}
{"Answer": "理论上支持，因为泛型指代一切类或接口，当然也可以认为是Serializable。\r\n\r\n第一种方式，具体实现可以直接作为序列化接口操作，目标明确。\r\n第二种方式，必须做分歧判断，如果参数是序列化接口，然后作为序列化接口操作。\r\n                  如果不是那么也要能处理。\r\n如果key必须使用序列化，也就是说具体实现只支持Serializable这种类型，那么推荐第一种。\r\n这时，使用第二种方式没有任何意义，还容易造成对接口功能的误解而使用错误。\r\n如果是要求对Serializable以外的类型也能处理，那么只能用第二种方式。", "Konwledge_Point": "泛型机制——模板", "Question": ["java 缓存接口设计疑问。", ["我想问，下面两种设计的区别 。", "\n第一种", "\n\n", " public interface ICache<T> {\n    T getItem(Serializable key) ;\n    void setItem(Serializable key, T item) ;\n}\n", "\n\n", "第二种", "\n\n", " public interface ILocalCache<K, V> {\n    public V get(K key) ;\n    void setItem(K key, V item) ;\n}\n", "\n\n", "第一种跟第二种的区别是key 一个是泛型， 一个是支持序列化。 ", "\n请问：当分布式缓存时第二种泛型的key是否也持之序列化 ？", "\n越详细越好 ！"]], "Tag": "程序设计"}
{"Answer": "一般来讲，我们用到“类1&lt;类2&gt;”这样的形式的Java语句，通常是希望将范围比较大的类1里面所包含的内容规范化成类2；举个简单的例子，我们通常会在创建集合的时候限定集合里面的内容的类型，如：List&lt;String&gt;。这意味着这个List集合里的内容都是字符串类型，而不会是Long或其他，这样就会在我们操作这个集合的时候提供一些规范，我们在调用add函数的时候，就只能按照规范，传进去字符串类型的参数值。这样就使我们在使用的时候更加规范。至于你说的“类&lt;类&gt;”泛型是自身的情况在项目中比较少见，如果是List&lt;List&gt;这样的，可以表示多维集合吧，不过到目前为止我并没有用过这样的东西。语法上是否有错，你可以通过在你的IDE中去试试就知道了，实践出真知，这比别人告诉你结果会更加深刻哦。希望我的回答对你有所帮助。", "Konwledge_Point": "泛型机制——模板", "Question": ["java当中的泛型类问题，类泛型参数是类的问题", ["类1<类2> 这样子写的话 类1和类2的选取范围是什", "\n么", "\n类<类>类的泛型是类的本身，这种写有错吗"]], "Tag": "程序设计"}
{"Answer": "containsAll里面不允许对元素调用方法，所以用？不是E\r\n\r\nhttps://www.cnblogs.com/Vcanccc/p/5701351.html", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型的上限、下限体现", ["为什么containsAll的泛型是collection<？>，，不能是collection"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-java\"&gt;package exception;\n\nimport java.util.*;\n\npublic class Score {\n    public static void main(String[] args) {\n        List&amp;lt;Map&amp;lt;String, Integer&amp;gt;&amp;gt; list &amp;#61; new ArrayList(1) {&lt;!-- --&gt;{\n            add(new HashMap(1) {&lt;!-- --&gt;{\n                put(&amp;#34;num&amp;#34;, 1);\n            }});\n        }};\n        List&amp;lt;Map&amp;lt;String, Integer&amp;gt;&amp;gt; list2 &amp;#61; new ArrayList(1) {&lt;!-- --&gt;{\n            add(new HashMap(1) {&lt;!-- --&gt;{\n                put(&amp;#34;num&amp;#34;, 1);\n            }});\n        }};\n        List&amp;lt;Object&amp;gt; list1 &amp;#61; new ArrayList&amp;lt;&amp;gt;();\n        for (int i &amp;#61; 0; i &amp;lt; list.size(); i&amp;#43;&amp;#43;) {\n            Map&amp;lt;String, Integer&amp;gt; map &amp;#61; list.get(i);\n            Map&amp;lt;String, Integer&amp;gt; map1 &amp;#61; list2.get(i);\n            Iterator&amp;lt;String&amp;gt; iterator &amp;#61; map.keySet().iterator();\n            while (iterator.hasNext()) {\n                String obj &amp;#61; iterator.next().toString();\n                Integer integer &amp;#61; map.get(obj);\n                map1.put(obj, map1.get(obj) &amp;#43; integer);\n            }\n            list1.add(map1);\n        }\n        System.out.println(list1);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["提问一个关于list<map<>>集合的问题", ["现在我有两个list<map<>>集合，这两个集合中的字段都是一样的的，只有值不一样。现在需要对每一个字段的值进行相减然后放入到一个新的list中，需要怎么做，最好有例子可以借鉴"]], "Tag": "程序设计"}
{"Answer": "接口名有的公司要求加i,有的不要求，命名基本上都 是大写开头+名词组成\r\n泛型就是不指定类型，而是等运行时来指定。这样可以减少代码量，有利于代码维护，提高整个程序的健状性。特别是在反射中更是常用到，而且还可以指定类型的范围。\r\n包装类型很多时候都 是自动调用的。拆包和装包的过程java中大部分时候都有帮你搞定。具体用在哪？这个得看你自己怎么来定义数据、怎么来传递数据。\r\n一般情况下，数据库对应 的pojo类里相应的字段都是包装类型，以及controller层中传递的VO参数类也是包装类型，这样数据才会一一自动对应，而不会发生问题。", "Konwledge_Point": "泛型机制——模板", "Question": ["接口，泛型，包装类型", ["接口名有什么要求？泛型有什么作用？包装类型具体用在哪呢？求大神讲解。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以这样写&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&amp;lt;T &lt;span class=\"hljs-keyword\"&gt;extends&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;A&lt;/span&gt;&amp;gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型的绑定关联111", ["要用Java泛型将两个有关联的事物绑定起来，如果输入的事物不匹配就会报错"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是这个意思&amp;#xff0c;指定了BinaryTree中的对象key的上限&amp;#xff0c;必须是Comparable的子类才可以。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型的小问题", ["同志们,这个泛型Key后面接一个继承什么鬼啊难道是制定上限的意思嘛", "\n", "public ", "class", " ", "BinaryTree<Key", " ", "extends", " ", "Comparable<Key>", ", ", "Value>", "\n", "\n", "和?extends一样的效果嘛?", "我是在学黑马程序员的java数据结构的时候看ls这么敲的"]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/callmeback/article/details/8425521", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型排序如何自定义排序规则，IComparer接口怎么用？", ["泛型排序如何自定义排序规则，IComparer接口怎么用？泛型排序如何自定义排序规则，IComparer接口怎么用？泛型排序如何自定义排序规则，IComparer接口怎么用？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;泛型 只存在于设计阶段&amp;#xff0c;T 只是个代名词&amp;#xff0c;编译时都需要替换成具体类型&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["想将object对象传入一个泛型方法", ["\n", "\n", "如图，在自己的方法中使用一个泛型方法。从外面传一个泛型对象进来，再传进这个泛型方法是没问题的。然后现在突然想试试传一个object对象进来，再传进去这个方法，就不知道该怎么处理了。各位可以解答下我的问题吗"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;&lt;code class=\"language-javascript\"&gt;AbService&amp;lt;T&amp;gt;&lt;/code&gt; 中的 T 可以表示任意类型&amp;#xff0c;User 也可以 Account 也可以&amp;#xff1b;&lt;/li&gt;&lt;li&gt;&lt;code class=\"language-javascript\"&gt;AbService&amp;lt;T extends Person&amp;gt;&lt;/code&gt; 中的 T 只能表示 Person 类及其子类&amp;#xff0c;如果使用其他类型就会报错&amp;#xff1b;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["提问 继承 泛型 T  占位符", ["就是我有一个挺简单的问题啊，但是我有点搞不明白", "比如我有个普通的类，继承了普通的类。两个类都放得是定义的属性。", "\n", "public ", "class", " ", "User", " ", "extends", " ", "Person（）", "{ }\n", "\n", "然后还有一个带有泛型的抽象类", "\n", "public ", "abstract", " ", "class", " ", "AbService<T", " ", "extends", " ", "Person>", " ", "{ }\n", "\n", "问题来了：我的User不是已经继承了Person么？为什么在泛型里的T还要继承一次Person？", "                  这个T作为一个占位符，把User放进去，不就已经是继承了Person的User实体吗？", "\n", "可能问的比较乱，还希望各位帮我解答一下"]], "Tag": "程序设计"}
{"Answer": "1、你要理解java编译和解释执行的过程。在各过程中，范型的存在性、存在方式、被处理方式。\r\n2、编译器编译源代码时，会检查范型，防止类型出错。\r\n例如：List&lt;String&gt; usernames = new ArrayList&lt;Integer&gt;();将不能通过编译。\r\n它将源代码编译为字节码，这时候的字节码，与没有使用范型编译过来的字节码比较，多出了一些范型信息。\r\n但是这些范型信息的有无，对于JVM是一样的（如果不考虑反射）。\r\nList&lt;String&gt; usernames = new ArrayList&lt;String&gt;();\r\nObject o = usernames;\r\nList&lt;Integer&gt; ints = (List&lt;Integer&gt;)o;//warning\r\nusernames.add(\"avril lavigne\");\r\nints.add(100);\r\n以上代码，ints和usernames指向同一个列表，但是却可以添加字符串和整型对象。\r\n这段代码应该会加深你对范型的理解。\r\n3、 对“拭去法”的理解，并不只是简单的将范型信息擦出。\r\npublic class Hello&lt;T&gt; {\r\n\tT t;\r\n\tpublic static void main(String[] args) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {\r\n\t\tType[] types = Hello.class.getTypeParameters();\r\n\t\tSystem.out.println(types[0]);\r\n\t\tHello&lt;String&gt; h = new Hello&lt;&gt;();\r\n\t\th.t = \"\";\r\n\t\th.getClass().getDeclaredField(\"t\").set(h, 1);;\r\n\t\tSystem.out.println(h.t);\r\n\t}\r\n}\r\n这段代码通过编译，并输出\r\nT\r\nException in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\r\n\tat generic.Hello.main(Hello.java:13)\r\n也就是说，字节码被载入jvm后，字段的类型仍然保持为T。这也验证了范型是参数化类型的说法。\r\n如果再加两行代码\r\nHello&lt;Integer&gt; h2 = new Hello&lt;&gt;();\r\n\t\th2.t = (Integer)(Object)h.t;\r\n也将通过编译，然而运行却报异常。\r\n说明在实例化对象的时候，动态的将字段的类型进行了设定，&lt;String&gt;和&lt;Integer&gt;的信息对运行时产生了影响！！！\r\n同一个类型实例化的对象，相同的属性类型却不能匹配!!!\r\n有范型和没范型，编译得到的字节码有本质的不同。jvm载入后，类中含有参数化类型。\r\n这个类型化参数，是在运行时动态绑定的！\r\n范型没有被拭去？是的。\"拭去法\"并不能简单的理解。\r\n更准确的理解应该是，编译时，对于类定义，范型作为类型的参数化信息，并不决定类型。\r\n拭去，指的是在类定义时，范型不决定被定义类的类型，而不是指范型信息被擦除！范型信息仍然是该类的一部分！！！", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型擦除原因，何为迁移兼容性", ["看了thinking in java 里的泛型篇，搞不懂里面讲的泛型的核心动机是迁移兼容性，为了使泛化客户端能够使用非泛化库类，反之亦然。", "\n作者分别了向后兼容性和迁移兼容性，可是没用例子说明什么样是迁移兼容性，能举个例子说明一下如果泛型不擦除，就无法迁移代码吗?十分感谢!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个。。。楼上都让开&amp;#xff0c;让我来。&lt;br /&gt;1、楼上说的没错&amp;#xff0c;但也不全对&amp;#xff1b;&lt;br /&gt;子类继承时&amp;#xff0c;泛型就就是限制了范围&amp;#xff1b;&lt;br /&gt;2、玄学说的有点出入&amp;#xff0c;这里的泛型限制是说必须是IView的子接口或对应的IView实现类&amp;#xff0c;不应该说子类&amp;#xff1b;&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;3、泛型本身可以当作是一个空实现的接口&amp;#xff0c;也就是说所有类型都可以&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;这个就回答了你的疑问&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;4、有继承关系就有父子的关系&amp;#xff0c;比如父类&amp;#xff0c;子类&amp;#xff1b;又比如父接口&amp;#xff0c;子接口&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;这个也回答了你的疑问之一&amp;#xff1b;&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;所以&amp;#xff0c;你还有甚么问题&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型中继承接口，该如何理解", ["类似 下面图片中的这种", "\n", "它的IView是一个接口，怎么是在泛型中继承一个接口呢？我以前学过的是继承一些类，而实现一些接口，那么，这里面泛型中 继承了接口，这该 怎么理解呢？"]], "Tag": "程序设计"}
{"Answer": "?代表暂时保留,不确认具体类型.", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型的问题", ["List<?>", "\nList<? extends Object>", "\n是什么意思，自己测试了一下，List<? extends Object>的add()方法参数是2个，不懂啊不懂", "\n[b]问题补充：[/b]", "\n现在了解了<? extends T>和<? super T>，还不知道<?>,这个问题是有关通配符的，所以请大家再解释下。谢谢"]], "Tag": "程序设计"}
{"Answer": "只是要编译通过的话，另一种改法是把第25行的声明类型改为List&lt;? super Integer&gt;。List&lt;? super T&gt;不是一种确定的类型，所以不能赋值给确定的泛型类型List&lt;Integer&gt;。楼主确认一下用泛型通配符的目的……之前在[url=http://iwtxokhtd.iteye.com/blog/386833#comments]这帖[/url]回过一些，有兴趣的话可以看看～", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型问题", ["请看以下代码，为什么不能编译呢", "\n[code=\"java\"]", "\nimport java.util.*;", "\npublic class GenerClass {", "\n\n", "/**\n * Creates a new instance of <code>GenerClass</code>.\n */\npublic GenerClass() {\n}\n\n\n\n//just for testing\npublic static <E extends Number> List<? super E> process(List<E> nums)\n{\n    return null;\n}\n\n\n/**\n * @param args the command line arguments\n */\npublic static void main(String[] args) {\n\n  List<Integer> input = new ArrayList<Integer>(0);\n  List<Integer> output = process(input);  \n\n\n}\n", "\n\n", "}[/code]", "\n\n", "编译的时候出错，说不兼容的类型。问题应该出自output的类型，但不知道为什么这样写会出错。请各位仁兄帮手解答。"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201507/07/1436263903_169718.png)", "Konwledge_Point": "泛型机制——模板", "Question": ["参数list对象结果如何使用mybatis批量插入数据", ["使用mybatis oracle，当传来的参数是list对象结果集，如何批量插入数据"]], "Tag": "程序设计"}
{"Answer": "[quote]我想你没把代码看仔细，Operator不是字符串，是个类[/quote]\r\n\r\n如果是类的话，只能这样写\r\n\r\nprotected List&lt;Operator&gt; po2vo(Iterator&lt;Operator&gt; t_it) {  \r\n        List&lt;Operator&gt; list = null;  \r\n        if(t_it!=null){  \r\n            list = new ArrayList&lt;Operator&gt;();  \r\n            while(t_it.hasNext()){  \r\n                Operator pOperator = (Operator)t_it.next();  \r\n                Operator vOperator =  OperatorPo2Vo.operatorPo2Vo(pOperator);  \r\n                list.add(vOperator);  \r\n            }  \r\n        }  \r\n        return list;  \r\n    } \r\n\r\n前面加&lt;Operator&gt;表示泛型方法，&lt;&gt;里面的表示泛型参数。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型的问题 ", ["先看2段代码", "\n\n", "protected <T> List<T> po2vo(Iterator<T> t_it) {\n    List list = null;\n    if(t_it!=null){\n        list = new ArrayList();\n        while(t_it.hasNext()){\n            Operator pOperator = (Operator)t_it.next();\n            Operator vOperator =  OperatorPo2Vo.operatorPo2Vo  (pOperator);\n            list.add(vOperator);\n        }\n    }\n    return list;\n}", "\n\n", "protected <Operator> List<Operator> po2vo(Iterator<Operator> t_it) {\n    List list = null;if(t_it!=null){\n        list = new ArrayList();\n        while(t_it.hasNext()){\n            Operator pOperator = (Operator)t_it.next();\n            Operator vOperator =  OperatorPo2Vo.operatorPo2Vo(pOperator);\n            list.add(vOperator);\n        }\n    }\n    return list;\n}", "\n\n", "第一段代码没报错，但有警告，第2段代码Myeclipse提示下面的错误 ", "\n\n", "The method operatorPo2Vo(Operator) in the type OperatorPo2Vo is not applicable for the arguments (Operator)", "\n\n", "意思很简单，OperatorPo2Vo类中参数为Operator的operatorPo2Vo方法对参数Operator不可用，我知道是由于泛型引起的，但不知道具体的原理，请教高手解释一下"]], "Tag": "程序设计"}
{"Answer": "应该用Integer 类型 才有comparater效果，", "Konwledge_Point": "泛型机制——模板", "Question": ["折半查找程序泛型问题？", ["您好，我想一下，折半查找的程序里面，我加了泛型修饰，但是后面我在主函数里面调用这个函数的时候，显示编译错误，说传入的变量不是泛型类型", "\n\n", "那么请问这个泛型是为了演示才这么写的还是我后面主函数里写错了东西？谢谢！抱拳", "\n\n", "import java.util.*;\npublic class Demo{\nprivate static<T extends Comparable<T>> int binarySearch(T[] x, int low, int high, T key) {\n          if(low <= high) {\n            int mid = low + ((high -low) >> 1);\n            if(key.compareTo(x[mid])== 0) {\n               return mid;\n            }\n            else if(key.compareTo(x[mid])< 0) {\n               return binarySearch(x,low, mid - 1, key);\n            }\n            else {\n               return binarySearch(x,mid + 1, high, key);\n            }\n          }\n          return -1;\n       }\n    }\n\n    public static void main(String[] args) {\n        int[] b={4,12,25,43,54,76,99,567,676};\n        System.out.println(binarySearch(b,0,8,54));\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;fun&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getDeclareFields&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(obj:&lt;span class=\"hljs-type\"&gt;T&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;val&lt;/span&gt; fields:Array&amp;lt;Field&amp;gt; &amp;#61; obj!!::&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt;.java.declaredFields\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;kotlin  学习 可以关注博主哦  有kotlin  以及 kotlin协程 flow等相关系列文章深度分析&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型对象获取Field数组，转成kotlin要怎么写呢？", ["java泛型对象获取Field数组，转成kotlin要怎么写呢？java泛型对象获3取Field数组，转成kotlin要怎么写呢？java泛型对象4获取Field数组，转成kotlin要怎么写呢？java泛型6对象获取Field数组，转成kotlin要怎么写呢？java泛型对象获取Field数组，转成kotlin要怎7么写呢？"]], "Tag": "程序设计"}
{"Answer": "http://www.iteye.com/problems/86185", "Konwledge_Point": "泛型机制——模板", "Question": ["在Struts2里,我想向后台注入一组list<bean>的id,怎么写才能实现?", ["A是一个bean,A里面有ID和NAME", "\n我在后台定义了一个list", "\n通过查询表A,得到了list", "\n发送到了jsp页面,循环list得到了很多个A,并且显示在页面上", "\n现在我想删除页面上的一些数据,", "\n我需要向后台注入一组list", "(A对象里面的id是我选择的id)", "\n\n", "如何实现呢?????"]], "Tag": "程序设计"}
{"Answer": "Matcher&lt;? super TypeLiteral&lt;?&gt;&gt; \r\n\r\n第一个?所指的类型必须是TypeLiteral类本身或者是它的父类，第二个?是指任意类型\r\n\r\n比如new Matcher&lt;A&lt;B&gt;&gt;();\r\n\r\n这句话必须满足的条件是：\r\nA类是TypeLiteral的父类，B类可以是任意类型(但是泛型中的引用的必须是类类类型，基础类型就不行。)。", "Konwledge_Point": "泛型机制——模板", "Question": ["一個泛型類,看不懂", ["Matcher<? super TypeLiteral<?>> ", "\n這個泛型類是什麽意思啊?", "\n求詳細解答"]], "Tag": "程序设计"}
{"Answer": "应该不是兼容的问题，可能哪里出问题了", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型DAO<T>的问题", ["用了DAO<t>,Spring 的AOP不起做用了.... ", "例子: ", "/** ", "DAO<t>定义最基本的save,delete,update,find..; ", "/ ", "public interface DAO<t> { ", "public void save(T t); ", "public void delete(T t); ", "public void update(T t); ", "public T findById(Integer id); ", "public List<t> findAll(); ", "} ", "/** ", "* CustomerDAO 一个 DAO<t> 的子类. ", "/ ", "public interface CustomerDAO extends DAO<customer> { ", "//定义Customer特有的操作. ", "public Customer findByAddress(String address); ", "} ", "/", " ", "CustomerDAO 的一个实现. ", "/ ", "public class CustomerDAOImpl extends HibernateDaoSupport implements CustomerDAO { ", "/** ", "定义过的泛型参数都会被具体化. ", "/ ", "public void save(Customer t) {} ", "public void update(Customer t){} ", "public void delete(Customer t){} ", "public Customer findById(Integer id){} ", "public List<customer> findAll(){} ", "public Customer findByAddress(String address); ", "} ", "加入AOP对 CustomerDAO 的所有方法 进行日志记录. ", "是泛型参数的AOP不起做用,如save,update,delete方法. ", "不是泛型参数的AOP都可以起到做用. findById,findAll,findByAddress方法. ", "当我修改DAO<t>中的save方法为: ", "public void save(Object obj); ", "AOP就可以起到作用了. ", "我不清楚是配置风格的问题(Spring 2.X风格),还是AOP与泛型不兼容. ", "上面的结论是:只要是泛型参数,AOP不起作用. ", "写在后面: ", "这里的DAO<t>本身没有太大的作用,只是把最基本的操作放在最顶层,利用泛型参数转变有真实参数. ", "写成这样的形式: ", "public interface DAO { ", "public void save(Object obj); ", "public void update(Object obj); ", "... ", "} ", "也可以,只是继承过来都是Object,少了显式类型. "]], "Tag": "程序设计"}
{"Answer": "细看了下你的代码，\r\n是这部分导致！\r\nentity = (T) getSession().load(getPersistentClass(), id,\r\n\t\t\t\t\t[color=red]LockMode.UPGRADE[/color]);\r\n\r\n任何关联的对象或者包含的集合都不会被以LockMode.UPGRADE方式返回，除非你指定了lock或all作为关联的级联风格（cascade=\"all\"或cascade=\"lock\"）！\r\n\r\n如果类的映射使用了代理，load方式返回的是一个未初始化的代理，直接你调用该代理的方法才会去访问数据库，所以，自然相关的级联集合也只有到比如dd.getWfactivityinsts()的时候才去数据库里查找，\r\n\r\n\r\n基本上，你改成load改成get应该就没问题了", "Konwledge_Point": "泛型机制——模板", "Question": ["Hibernat泛型DAO问题", ["在程序中使用springside的DAO，使用级联时候出现问题", "\n\n", "[code=\"java\"]", "\n\n", "public class SimpleHibernateDao {", "\n\n", "protected Logger logger = LoggerFactory.getLogger(getClass());\n\nprotected SessionFactory sessionFactory;\n\nprotected Class<T> entityClass;\n\n/**\n * 用于扩展的DAO子类使用的构造函数.\n * \n * 通过子类的泛型定义取得对象类型Class.\n * eg.\n * public class UserDao extends SimpleHibernateDao<User, Long>\n */\npublic SimpleHibernateDao() {\n    this.entityClass = ReflectionUtils.getSuperClassGenricType(getClass());\n}\n\n/**\n * 用于Service层直接使用SimpleHibernateDAO的构造函数.\n * eg.\n * SimpleHibernateDao<User, Long> userDao = new SimpleHibernateDao<User, Long>(sessionFactory, User.class);\n */\npublic SimpleHibernateDao(final SessionFactory sessionFactory, final Class<T> entityClass) {\n    this.sessionFactory = sessionFactory;\n    this.entityClass = entityClass;\n}\n\npublic SessionFactory getSessionFactory() {\n    return sessionFactory;\n}\n", "\n\n", "///................其他省略", "\n\n", "}", "\n\n", "[code=\"java\"]", "\npublic class HibernateDao extends SimpleHibernateDao {", "\n    /**", "\n     * 用于扩展的DAO子类使用的构造函数.", "\n     * ", "\n     * 通过子类的泛型定义取得对象类型Class.", "\n     * eg.", "\n     * public class UserDao extends HibernateDao{", "\n     * }", "\n     */", "\n    public HibernateDao() {", "\n        super();", "\n    }", "\n\n", "/**\n * 用于Service层直接使用HibernateDAO的构造函数.\n * eg.\n * HibernateDao<User, Long> userDao = new HibernateDao<User, Long>(sessionFactory, User.class);\n */\npublic HibernateDao(final SessionFactory sessionFactory, final Class<T> entityClass) {\n    super(sessionFactory, entityClass);\n}\n\n// 分页查询函数 //\n\n/**\n * 分页获取全部对象. \n */\npublic Page<T> getAll(final Page<T> page) {\n    return findByCriteria(page);\n}\n", "\n\n", "//其他", "\n}", "\n\n", "下面是实体", "\n[/code]", "\n\n", "[code=\"java\"]", "\n\n", "@Entity", "\n@Table(name = \"WFPROCESSINST\", schema = \"TSSA\")", "\n@Proxy(lazy=false)", "\npublic class Wfprocessinst implements java.io.Serializable {", "\nprivate BigDecimal processinstid;", "\n@Id", "\n    @Column(name = \"PROCESSINSTID\", unique = true, nullable = false, precision = 22, scale = 0)", "\n    public BigDecimal getProcessinstid() {", "\n        return this.processinstid;", "\n    }", "\n\n", "public void setProcessinstid(BigDecimal processinstid) {\n    this.processinstid = processinstid;\n}\nprivate String processinstname;\nprivate Set<Wftransition> wftransitions = new HashSet<Wftransition>(0);\n     @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER, mappedBy = \"wfprocessinst\")\npublic Set<Wfactivityinst> getWfactivityinsts() {\n    return this.wfactivityinsts;\n}\n\npublic void setWfactivityinsts(Set<Wfactivityinst> wfactivityinsts) {\n    this.wfactivityinsts = wfactivityinsts;\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "当fetch = FetchType.EAGER 报错，为FetchType.LAZY 正常。", "\n\n", "异常", "\n\n", "[WARN ]2009-04-27 16:26:57,868 org.hibernate.util.JDBCExceptionReporter  SQL Error: 17027, SQLState: null", "\n[ERROR]2009-04-27 16:26:57,868 org.hibernate.util.JDBCExceptionReporter  流已被关闭", "\n[INFO ]2009-04-27 16:26:57,870 org.hibernate.event.def.DefaultLoadEventListener  Error performing load command", "\norg.hibernate.exception.GenericJDBCException: could not load an entity: [cn.com.starit.orm.hibernate.dojo.Wfprocessinst#8809358]", "\n    at org.hibernate.exception.SQLStateConverter.handledNonSpecificException(SQLStateConverter.java:103)", "\n    at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:91)", "\n    at org.hibernate.exception.JDBCExceptionHelper.convert(JDBCExceptionHelper.java:43)", "\n    at org.hibernate.loader.Loader.loadEntity(Loader.java:1874)", "\n    at org.hibernate.loader.entity.AbstractEntityLoader.load(AbstractEntityLoader.java:48)", "\n    at org.hibernate.loader.entity.AbstractEntityLoader.load(AbstractEntityLoader.java:42)", "\n    at org.hibernate.persister.entity.AbstractEntityPersister.load(AbstractEntityPersister.java:3044)", "\n    at org.hibernate.event.def.DefaultLoadEventListener.loadFromDatasource(DefaultLoadEventListener.java:395)", "\n    at org.hibernate.event.def.DefaultLoadEventListener.doLoad(DefaultLoadEventListener.java:375)", "\n    at org.hibernate.event.def.DefaultLoadEventListener.load(DefaultLoadEventListener.java:139)", "\n    at org.hibernate.event.def.DefaultLoadEventListener.proxyOrLoad(DefaultLoadEventListener.java:179)", "\n    at org.hibernate.event.def.DefaultLoadEventListener.onLoad(DefaultLoadEventListener.java:103)", "\n    at org.hibernate.impl.SessionImpl.fireLoad(SessionImpl.java:878)", "\n    at org.hibernate.impl.SessionImpl.load(SessionImpl.java:795)", "\n    at org.hibernate.impl.SessionImpl.load(SessionImpl.java:788)", "\n    at cn.com.starit.orm.hibernate.SimpleHibernateDao.get(SimpleHibernateDao.java:114)", "\n    at cn.com.starit.orm.hibernate.EntityManager.get(EntityManager.java:38)", "\n    at cn.com.starit.orm.hibernate.EntityManager$$FastClassByCGLIB$$7a912d89.invoke()", "\n    at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:149)", "\n    at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:700)", "\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)", "\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)", "\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)", "\n    at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:635)", "\n    at cn.com.starit.service.WFManager$$EnhancerByCGLIB$$e9c4798f.get()", "\n    at cn.com.starit.action.UserAction.main(UserAction.java:21)", "\nCaused by: java.sql.SQLException: 流已被关闭", "\n    at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)", "\n    at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:146)", "\n    at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:208)", "\n    at oracle.jdbc.driver.LongAccessor.getBytes(LongAccessor.java:151)", "\n    at oracle.jdbc.driver.LongAccessor.getString(LongAccessor.java:193)", "\n    at oracle.jdbc.driver.T4CLongAccessor.getString(T4CLongAccessor.java:422)", "\n    at oracle.jdbc.driver.OracleResultSetImpl.getString(OracleResultSetImpl.java:397)", "\n    at oracle.jdbc.driver.OracleResultSet.getString(OracleResultSet.java:1515)", "\n    at org.hibernate.type.StringType.get(StringType.java:18)", "\n    at org.hibernate.type.NullableType.nullSafeGet(NullableType.java:163)", "\n    at org.hibernate.type.NullableType.nullSafeGet(NullableType.java:154)", "\n    at org.hibernate.type.AbstractType.hydrate(AbstractType.java:81)", "\n    at org.hibernate.persister.entity.AbstractEntityPersister.hydrate(AbstractEntityPersister.java:2096)", "\n    at org.hibernate.loader.Loader.loadFromResultSet(Loader.java:1380)", "\n    at org.hibernate.loader.Loader.instanceNotYetLoaded(Loader.java:1308)", "\n    at org.hibernate.loader.Loader.getRow(Loader.java:1206)", "\n    at org.hibernate.loader.Loader.getRowFromResultSet(Loader.java:580)", "\n    at org.hibernate.loader.Loader.doQuery(Loader.java:701)", "\n    at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:236)", "\n    at org.hibernate.loader.Loader.loadEntity(Loader.java:1860)", "\n[b]问题补充：[/b]", "\n代码被我没有有发完，是有的。", "\n[b]问题补充：[/b]", "\n级联查询", "\nApplicationContext context = new ClassPathXmlApplicationContext(", "\n        \"classpath:config/ApplicationContext.xml\");", "\n        WFManager wf = (WFManager) context.getBean(\"WFManager\");", "\n        Wfprocessinst dd;", "\n        try {", "\n            dd= wf.get(new BigDecimal(8809358));", "\n            System.out.println(dd.getProcessinstname());", "\n        //Iterator ac=  dd.getWfactivityinsts().iterator();", "\n//      while(ac.hasNext()){", "\n//          System.out.println(ac.next().getActivityinstname());", "\n//", "\n//      }", "\n        } catch (Exception e) {", "\n            e.printStackTrace();", "\n        }", "\n        System.out.println(\"this is a test\");", "\n注释那一部分有问题", "\n[b]问题补充：[/b]", "\n我做了一个简单例子，还是错的，控制台输出的SQL是正确的", "\n[b]问题补充：[/b]", "\n是的哦，搞半天来了，没有搞定。", "\n\n", "输出的SQL是正常的。", "\n不是为什么哦？", "\n[b]问题补充：[/b]", "\n我用list试试", "\n[b]问题补充：[/b]", "\n怎么个用法，发端代码看看。", "\n[b]问题补充：[/b]", "\n还是不知道怎么解决哦？", "\n[b]问题补充：[/b]", "\n我先试试，问题先不关闭"]], "Tag": "程序设计"}
{"Answer": "这是正常的，struts2标签本来就可以访问类的方法和属性", "Konwledge_Point": "泛型机制——模板", "Question": ["struts2迭代标签和泛型的疑问", ["DAO中返回了一个结果List,没有使用泛型，使用迭代标签能够访问POJO的属性，难道这是struts2标签的特性？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;自己已解决,以下代码,泛型数组即可返回指定数组类型:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;            Object&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; objs &amp;#61; obj instanceof Collection ? ((Collection&amp;lt;?&amp;gt;) obj).&lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;Array()&lt;/span&gt; : (Object&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt;) obj;\n            Class&amp;lt;?&amp;gt; clazz &amp;#61; itemClass.get&lt;span class=\"hljs-constructor\"&gt;ComponentType()&lt;/span&gt;;\n            Object &lt;span class=\"hljs-built_in\"&gt;array&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Array&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;Instance(&lt;span class=\"hljs-params\"&gt;clazz&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;objs&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;)&lt;/span&gt;;\n            Object&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; arrays &amp;#61; (Object&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt;) &lt;span class=\"hljs-built_in\"&gt;array&lt;/span&gt;;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java 一个泛型方法,如何使数组转换类型后返回泛型", ["我设计了一个泛型方法,使数组更改类型后返回", "\n", "结果显示异常:class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.Integer;", "实际上返回的是Object[]类型,请问应该如何改正?", "\n", "测试代码:", "\n", "\n        String[] cs3 = ", "new", " String[] { \"123\", \"321\" };\n        ", "Integer", "[] cs3s = convert(cs3, ", "Integer", "[].", "class", ");\n        ", "System", ".", "out", ".println(Arrays.toString(cs3s));\n        List<", "Boolean", "> list4 = ", "new", " ArrayList<>();\n        list4.", "add", "(", "true", ");\n        list4.", "add", "(", "false", ");\n        ", "Boolean", "[] list4s = convert(list4, ", "Boolean", "[].", "class", ");\n        ", "System", ".", "out", ".println(Arrays.toString(list4s));\n", "\n", "方法代码:", "\n", "\npublic static <T> T convert(@NotNull Object obj, Class<T> itemClass) {\n        ", "if", " (obj.get", "Class()", " == ", "itemClass) return (T) obj;\n        String itemClassName = itemClass.get", "Name()", ";\n        ", "if", " (itemClassName.starts", "With(", "\"[\"", ")", ") {\n            ", "if", " (itemClassName.", "char", "At(1)", " == ", "'L'", ") {\n                ", "try", " {\n                    Class<?> clazz = ", "Class", ".", "for", "Name(", "itemClassName", ".", "substring", "(2, ", "itemClassName", ".", "length", "()", " - ", "1", "));\n                    Constructor<?> ", "type", " = get", "Constructor(", "clazz", ", ", "\"java.lang.String\"", ")", ";\n                    ", "if", " (", "type", " == ", "null) throw ", "new", " ", "TypeException(", "\"不支持的转换类型\"", ")", ";\n                    ", "if", " (obj instanceof Collection) {\n                        List<Object> ", "list", " = ((List<Object>) obj);\n                        ", "//    Object[] result = new Object[list.size()];", "\n                        ", "for", " (", "int", " i = ", "0", "; i < ", "list", ".size", "()", "; i++) {\n                            ", "list", ".set(i, ", "type", ".", "new", "Instance(String.", "valueOf", "(", "list", ".", "get", "(", "i", ")", ")));\n                        }\n                        return (T) ", "list", ".", "to", "Array()", ";\n                    } ", "else", " {\n                        Object", "[]", " objs = ((Object", "[]", ") obj);\n                        Object", "[]", " result = ", "new", " Object", "[", "objs", ".", "length", "]", ";\n                        ", "for", " (", "int", " i = ", "0", "; i < objs.length; i++) {\n                            result", "[", "i", "]", " = ", "type", ".", "new", "Instance(String.", "valueOf", "(", "objs", "[", "i", "])", ");\n                        }\n                        return (T) result;\n                    }\n                } catch (ClassNotFoundException ", "| ", "InstantiationException", " | ", "IllegalAccessException", " | ", "InvocationTargetException", " e) {\n                    throw ", "new", " ", "RuntimeException(", "e", ")", ";\n                }\n            } ", "else", " ", "if", " (item", "ClassName", ".", "char", "At(1)", " ", "==", " '[') {\n                throw ", "new", " ", "TypeException(", "\"不支持一维以上数组转换类型\"", ")", ";\n            } ", "else", " {\n                throw ", "new", " ", "TypeException(", "\"不支持基元类型转换\"", ")", ";\n            }\n        } ", "else", " {\n            throw ", "new", " ", "TypeException(", "\"测试用,仅支持一维度数组\"", ")", ";\n        }\n    }\npublic static ", "Constructor", "<?> get", "Constructor(@NotNull Class<?> ", "itemClass", ", @NotNull String ", "item", ")", " {\n        ", "Constructor", "<?> ", "type", " = null;\n        ", "for", " (var con : item", "Class", ".get", "Constructors()", ") {\n            ", "Class", "<?>[] parameter", "Types", " = con.get", "ParameterTypes()", ";\n            ", "if", " (parameter", "Types", ".length ", "==", " 1 ", "&&", " parameter", "Types", "[0].get", "Name()", ".equals(\"java.lang.", "String", "\")) {\n                ", "type", " = con;\n            }\n        }\n        return ", "type", ";\n    }\n", "\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n \r\n            //第一是带有泛型信息的链表能这样强制转化吗？怎么感觉这样转化会出问题\r\n\t\t\t\t\t\t没有问题，因为你的接收类型和clone的返回类型一样\r\n            //第二是LinkedList中的clone方法不是浅复制吗？\r\n\t\t\t\t\t\t是浅复制。clone和直接=的区别是，前者你从原来的列表删除、添加元素，不会影响第二个，=会影响。但是你修改元素对象本身，两者都会影响\r\n\t\t\t\t\t\t正确的做法是循环，新建复制。\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java中链表的克隆问题", ["代码如下:", "\n\n", " import java.util.*;\npublic class Example12_6 {\n   public  static void main(String args[]) {\n      LinkedList<String> list1=new LinkedList<String>();\n      list1.add(\"A\");\n      list1.add(\"B\");\n      list1.add(\"C\");\n      list1.add(\"D\");\n      list1.add(\"E\");\n      LinkedList<String> list2 =(LinkedList<String>)list1.clone();  //这里我有两个问题不明白，\n            //第一是带有泛型信息的链表能这样强制转化吗？怎么感觉这样转化会出问题\n            //第二是LinkedList中的clone方法不是浅复制吗？\n            //那么list2中的元素指向的不也是list1中的元素吗？\n            //那么下面对list1进行洗牌后list2中的元素怎么不变呢？\n      System.out.print(\"链表中的数据:\");\n      Iterator<String> iter=list1.iterator();\n      while(iter.hasNext()) {\n         String str=iter.next();\n         System.out.print(str+\" \");\n      }\n      Collections.shuffle(list1);   //洗牌\n      System.out.printf(\"\\n洗牌后链表中的数据:\");\n      iter=list1.iterator();\n      while(iter.hasNext()) {\n         String str=iter.next();\n         System.out.print(str+\" \");\n      }\n      System.out.printf(\"\\n链表中的数据:\");\n      iter=list2.iterator();\n      while(iter.hasNext()) {\n         String str=iter.next();\n         System.out.print(str+\" \");\n      }\n      Collections.rotate(list2,2);   //向右旋转2步\n      System.out.printf(\"\\n向右旋转2步后链表中的数据:\");\n      iter=list2.iterator();\n      while(iter.hasNext()) {\n         String str=iter.next();\n         System.out.print(str+\" \");\n      }\n   } \n}\n\n", "\n\n", "本人还是小白一枚，虚心求教。", "\n\n", "补充一下，关于上面我两个问题中，我第一个问题的疑惑来自于sun公司java泛型教程中的这段话:", "\nAnother implication of the fact that a generic class is shared among all its instances, is that it usually makes no sense to ask an instance if it is an instance of a particular invocation of a generic type:", "\n\n", " Collection cs = new ArrayList<String>();\nif (cs instanceof Collection<String>) { ...} // illegal \n", "\n\n", "similarly, a cast such as", "\n\n", " Collection<String> cstr = (Collection<String>) cs; // unchecked warning\n", "\n\n", "gives an unchecked warning, since this isn’t something the run time system is going to check for you. The same is true of type variables", "\n\n", " <T> T badCast(T t, Object o) {return (T) o; // unchecked warning }\n", "\n\n", "Type variables don’t exist at run time. This means that they entail no performance overhead in either time nor space, which is nice. Unfortunately, it also means that you can’t reliably use them in casts."]], "Tag": "程序设计"}
{"Answer": "C#这里\r\nclass A换成struct A", "Konwledge_Point": "泛型机制——模板", "Question": ["C#调用C++的dll中参数出现无法封送处理某字段的问题，请求高手急救！！", ["在c++项目cpptest.dll中定义：", "\nstruct A", "\n{", "\n    int X;", "\n    int Y;", "\n    A *a;", "\n};", "\n\n", "extern \"C\" __declspec(dllexport) int fun1(A *a);", "\n\n", "在C#项目TestDll.exe中定义：", "\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]", "\n    class A", "\n    {", "\n        public int X;", "\n        public int Y;", "\n        public A a;", "\n    }", "\n\n", "[UnmanagedFunctionPointer(CallingConvention.Cdecl)]\ndelegate int dofun(ref A a1);\n", "\n\n", "然后调用", "\n\n", "public static class NativeMethod\n{\n    [DllImport(\"kernel32.dll\", EntryPoint = \"LoadLibrary\")]\n    public static extern int LoadLibrary(\n        [MarshalAs(UnmanagedType.LPStr)] string lpLibFileName);\n\n    [DllImport(\"kernel32.dll\", EntryPoint = \"GetProcAddress\")]\n    public static extern IntPtr GetProcAddress(int hModule,\n        [MarshalAs(UnmanagedType.LPStr)] string lpProcName);\n}\n\n    static void Main(string[] args)\n    {\n        //1. 动态加载C++ Dll\n        int hModule = NativeMethod.LoadLibrary(\"cpptest.dll\");\n        if (hModule == 0) return;\n        //2. 读取函数指针\n        IntPtr intPtr = NativeMethod.GetProcAddress(hModule, \"fun1\");\n        //3. 将函数指针封装成委托\n        dofun dofun1 = (dofun)Marshal.GetDelegateForFunctionPointer(intPtr, typeof(dofun));\n\n        A a1 = new A();\n        a1.X = 100;\n        a1.Y = 20;\n        A a2 = new A();\n        a1.a = a2;\n        Console.WriteLine(dofun1(ref a1));\n    }\n", "\n\n", "结果报错：“System.TypeLoadException”类型的未经处理的异常在TestDll.exe中发生。其他信息:无法封送处理类型为“TestDll.A”的字段“a”: 该类型不支持封送处理。", "\n\n", "这个问题如何解决？请求高手急救，不胜感激！！"]], "Tag": "程序设计"}
{"Answer": "你需要知道如下几点：\r\n1、任何类型都继承自object类。\r\n2、原始ArrayList里面存储的是object类型，也就是我可以同时把string、enum、int、double、bool、自定义类等等都可以放到一个集合里面。那么你取出来时，也是object类型，此时如果不做类型检查，那么直接转为Employee类是不安全的，因为可能我存储的是int类型的数字0。所以原始ArrayList是不安全的。\r\n3、如果使用泛型ArrayList，那么在声明的时候就指定了这个ArrayList可以存储的数据类型：如 ArrayList&lt;string&gt; arr;那么这个arr中就只能存储string类型的数据。那么我取出来的时候就不需要检查。因为一定会是一个string数据，这是泛型限定了的，限定这个ArrayList中只能保存你指定的类型数据。", "Konwledge_Point": "泛型机制——模板", "Question": ["Arraylist  Java核心技术卷一 184页", ["没有泛型类时，原始的ArrayList类提供的get方法别无选择只能返回Obejct，因此，get方法的调用必须对返回值进行类型转换：", "\nEmployee e = （Employee）staff. get(i):", "\n原始的ArrayList存在一定的危险性。 它的add和set方法允许接收任意类型的对象。", "\n对于下面这个调用", "\nstaff.set(i.new Date());", "\n编译时不会给出任何警告，只有在检索对象并试图对它进行类型转换时，才会发现有问题。如果使用ArrayList,编译器就会检测到这个错误。", "\n\n", "第一个问题：Employee e = （Employee）staff. get(i):\n\n猜测：      object obj = （object) staff.get(i)（向上转型）\n\n          Employee e =(Employee) obj(向下转型)\n", "\n\n", "这种向下转型不是很容易会出错了。 比如boss是Employee的一员，但是Employee不一定是就是boss啊。", "\n    2.为什么说add和set方法允许接收任意类型的对象的时候，就会出现一定的风险呢？", "\n    3. 为什么说只有在检索对象并试图对它进行类型转换时，才会发现问题呢？ 如果使用ArrayList,编译器就会检测到错误。"]], "Tag": "程序设计"}
{"Answer": "我运行了下， 找到原因了， 原因是System.out.println() 造成的。\r\n       这个方法可传的参数为基础类型和Object对象，还提供了一个String对象的方法参数。\r\n       第一个例子中List是Integer泛型，System.out.println() 是没有提供对应的方法参数， 所以会调用Object参数的方法，Integer转Object是没问题的，所以通过了。\r\n       第二个例子中List是String泛型，System.out.println() 提供了String参数的就去，所以用的是以String为参数的方法，但是list中的第2个值你用了反射传的是个数值，这里会做个强转，从Integer转成String，所以出错。", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA中使用泛型擦除的问题", ["import java.util.ArrayList;", "\n\n", "public class Fanxing {", "\n\n", " public static void main(String[] args) throws Exception{  \n     ArrayList<Integer> arrayList3=new ArrayList<Integer>();\n     arrayList3.add(1);//这样调用add方法只能存储整形，因为泛型类型的实例为Integer\n     arrayList3.getClass().getMethod(\"add\", Object.class).invoke(arrayList3, \"asd\");\n     for (int i=0;i<arrayList3.size();i++) {\n        System.out.println(arrayList3.get(i));\n     }\n\n\n     ArrayList<String> arrayList2=new ArrayList<String>();\n     arrayList2.add(\"asd\");//这样调用add方法只能\n        存储整形，因为泛型类型的实例为Integer\n     arrayList2.getClass().getMethod(\"add\", Object.class).invoke(arrayList2, 1);\n     for (int i=0;i<arrayList2.size();i++) {\n        System.out.println(arrayList2.get(i));\n    }\n }  \n", "\n\n", "}", "\n输出结果为：", "\n1", "\nasd", "\nasd", "\nException in thread \"main\" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String", "\n    at Fanxing.main(Fanxing.java:19)", "\n\n", "请问这是什么问题？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的MyClass 需要实现的是java.lang 包下的Comparable接口&amp;#xff0c;而不是你自定义的Comparable接口&amp;#xff0c;把你自定义的这个 Comparable 接口删掉&amp;#xff0c;重新导包就好了&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java实现泛型接口", ["package", " com.example;\n\n", "import", " java.util.Arrays;\n\n", "public", " ", "class", " ", "Main", " {\n  \n  ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n    MyClass[] ms = {\n      ", "new", " ", "MyClass", "(", "\"Monin\"", ",", "119", "),\n      ", "new", " ", "MyClass", "(", "\"Annie\"", ",", "120", "),\n      ", "new", " ", "MyClass", "(", "\"David\"", ",", "99", ")\n    };\n    Arrays.sort(ms);\n    System.out.println(Arrays.toString(ms));\n  }\n}\n\n", "interface", " ", "Comparable", "<T> {\n  ", "public", " ", "int", " ", "compareTo", "(T o)", ";\n}\n\n", "class", " ", "MyClass", " ", "implements", " ", "Comparable", "<MyClass> {\n  ", "private", " String name;\n  ", "private", " ", "int", " num;\n  \n  ", "public", " ", "MyClass", "(String name, ", "int", " num)", " {\n    ", "this", ".name = name;\n    ", "this", ".num = num;\n  }\n  \n  ", "public", " ", "int", " ", "compareTo", "(MyClass m)", " {\n    ", "return", " ", "this", ".name.compareTo(m.num);\n  }\n  \n  ", "public", " String ", "toString", "()", " {\n    ", "return", " name + ", "\":\"", " + num;\n  }\n}\n", "\n", "报错：", "\n", "java", ".lang", ".ClassCastException", ": com", ".example", ".MyClass", " cannot be cast to java", ".lang", ".Comparable", "\n    at java", ".util", ".ComparableTimSort", ".countRunAndMakeAscending", "(ComparableTimSort", ".java", ":", "320", ")\n    at java", ".util", ".ComparableTimSort", ".sort", "(ComparableTimSort", ".java", ":", "188", ")\n    at java", ".util", ".Arrays", ".sort", "(Arrays", ".java", ":", "1239", ")\n    at com", ".example", ".Main", ".main", "(Main", ".java", ":", "13", ")\n    at java", ".lang", ".reflect", ".Method", ".invoke", "(Native Method)\n    at com", ".duy", ".android", ".compiler", ".java", ".Java", ".run", "(Unknown Source:", "335", ")\n    at com", ".duy", ".ide", ".javaide", ".run", ".activities", ".ExecuteActivity", ".executeDex", "(Unknown Source:", "42", ")\n    at com", ".duy", ".ide", ".javaide", ".run", ".activities", ".ExecuteActivity", ".exec", "(Unknown Source:", "19", ")\n    at com", ".duy", ".ide", ".javaide", ".run", ".activities", ".ExecuteActivity", ".access$", "100", "(Unknown Source:", "0", ")\n    at com", ".duy", ".ide", ".javaide", ".run", ".activities", ".ExecuteActivity$", "1", ".run", "(Unknown Source:", "8", ")\n    at java", ".lang", ".Thread", ".run", "(Thread", ".java", ":", "929", ")\n", "\n", "怎么回事？如何改？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c#\"&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;LinkNode&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title\"&gt;T&lt;/span&gt;&amp;gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;LinkNode&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n        {\n\n        }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; T Data { &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;; &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt;; }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; LinkNode&amp;lt;T&amp;gt; &lt;span class=\"hljs-title\"&gt;Next&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DepthFirstTraverse&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; g&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (g)\n            {\n                &lt;span class=\"hljs-comment\"&gt;// 广度&lt;/span&gt;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-comment\"&gt;// 深度&lt;/span&gt;\n            }\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;LinkList&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title\"&gt;T&lt;/span&gt;&amp;gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; LinkNode&amp;lt;T&amp;gt; first;\n    }\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["c﹟泛型实验，泛型的链表节点和链表类", []], "Tag": "程序设计"}
{"Answer": "for-loop的底层使用的是iterator，试想你的程序编译器转化后和以下代码一致，就没问题\r\nIterator&lt;String&gt; i = list.iterator();\r\nwhile(iter.hasNext()) {\r\n    String i = iter.next(); //iterator.next()是string类型\r\n}\r\n如果不用范型，你的程序就是\r\nIterator iterator = list.iterator();\r\nwhile(iterator.hasNext()) {\r\n  String i = iterator.next(); // 看到问题了么，这里iteraotr.next()是object,类型转换失败啊\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型除了标示类还有其他的作用吗?", [" public static void main(String[] args) {\n        ArrayList<String> list=new ArrayList<String>();\n        list.add(\"hello\");\n        list.add(\"world\");\n        list.add(\"java\");\n        for(String i : list){\n            System.out.println(i);\n        }\n\n    }\n", "\n\n", "为什么不声明泛型String之后用foreach遍历就会报错?泛型在这里起到的作用是什么.?"]], "Tag": "程序设计"}
{"Answer": "当然要报错，现在你的list泛型里面是？，还不能确定具体类型，所有还不能往你面添加东西", "Konwledge_Point": "泛型机制——模板", "Question": [" JAVA 泛型，有懂泛型集合的麻烦看看。", ["            ArrayList<?> alist=new ArrayList<>();\n            ArrayList<?> blist=new ArrayList<>();\n\n            alist.addAll(blist); //报错\n\n                            alist=blist;//这样竟然不报错\n\n                            第三行报错的提示是：The method addAll(Collection<? extends capture#1-of ?>) in the type ArrayList<capture#1-of ?> is not applicable for the arguments (ArrayList<capture#2-of ?>)\n"]], "Tag": "程序设计"}
{"Answer": "按照你的代码理解 你应该是在命令行运行时 加的 文件参数，你需要确定这个文件的路径和你代码里面的argv[1] 是否对应，cout一下试试就知道你的输入参数的问题了。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于c++primer里泛型算法", ["我是一个新人现在正在学习c++primer，最近做到了第十章关于泛型算法的问题，看到了你的答案跟书上的偏差有点大，所以在这里想向大神提个问，希望能帮忙解答一下。习题里面的代码是这样的", "\n#include", "\n#include", "\n#include", "\n#include", "\n#include", "\nusing namespace std;", "\nint main(int argc,char *argv[])", "\n{", "\nifstream in(argv[1]);", "\nif(!in){", "\ncout<<打开输入文件失败!<\nexit(1);", "\n}", "\nvectorvi;", "\nint val;", "\nwhile(in>>val)", "\nvi.push_back(val);", "\ncout<<序列中的整数之和为<<accumulate(vi.begin(),vi.end(),0)<<endl;", "\nreturn 0;", "\n} ", "\n我将这串代码验证的时候老是只得到一个“打开输入文件失败”，我很是疑惑，为什么只是得到这个输出，看到与你所写答案有部分的不同，想请教是不是要创建一个输入文件，那么我应该怎么创建呢，希望大神能帮忙解答一下，谢谢"]], "Tag": "程序设计"}
{"Answer": "说构造的是Object[2]数组而不是T[2]数组", "Konwledge_Point": "泛型机制——模板", "Question": ["Java 核心技术中泛型的使用", ["在看Java核心技术的过程中有个问题不明白，求各位大神指导。", "\n\n", "书中写到：", "\n不能构造一个泛型数组：", "\npublic static  T[] minmax(T[] a)", "\n{", "\nT[] mm = new T(2);", "\n...", "\n}", "\n书中的解释是类型擦除会让这个方法永远构造Object[2]数组。", "\n\n", "什么叫永远构造Object[2]数组？是死循环？还是说构造的是Object[2]数组而不是T[2]数组"]], "Tag": "程序设计"}
{"Answer": "ImageBean 看名字应该是一个实体类吧，那么类型就是这个对象。看成一个整体。和 private ImageBean imageBean ; 是一样的。", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型变量问题private List<ImageBean> mData;", ["java 泛型变量问题private List mData;", "\n\n", "ImageBean是一个引用变量吗，它是属于String变量吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://huangliangbo.com/2194\" id=\"textarea_1650244244785_1650244584077_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"margin: 0px 0 2px\"&gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;span class=\"md_link_img icon iconfont icon-lianjie\"&gt;&lt;/span&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://huangliangbo.com/2194&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["ts  axios类型定义问题", ["\n", "我想把参数结构出来 但是提示AxiosResponse上不存在属性list ", "\n", "\n", "我需要怎么做可以解决    在axios的接口上扩展一下属性？"]], "Tag": "程序设计"}
{"Answer": "rose2003本来就不支持泛型，它只是只支持1.5以下的版本的类啦，\r\n\r\n好像rose 7是支持泛型的，\r\n\r\n建议你使用Enterprise Architect - UML CASE Tool，这个工具是支持最新的规范和版本", "Konwledge_Point": "泛型机制——模板", "Question": ["rose2003逆向工程中不支持java泛型的问题", ["用rose2003逆向工程由java源代码生成类图时，遇到java泛型Map报错。", "\n这个问题有有人遇到过吗？"]], "Tag": "程序设计"}
{"Answer": "LZ可参考一下这贴：http://www.iteye.com/topic/1021949\n\n单独一份讲泛型的资料应该无法全面说明你所问的问题，你这个问题的关键不在泛型，而在于编译器解语法糖时的泛型擦除过程。所以还需要讲一下javac（你这里实际上是ecj）是如何解语法糖的，但是那个太长了，贴出来不太方便，LZ先看看这个吧。", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型<T>的转换问题", ["在", "问答", "里提问，没有得到答案，特开此贴讨论。", "代码如下： ", "\npublic class Cast {  \n\n", "public static &lt;T&gt; T cast(Object o){  \n    return (T)o;  \n}  \n\npublic static void main(String[] args){  \n        Object o =new Bird();  \n        Bird b=Cast.cast(o);  //cast方法上的Doc提示：&lt;Bird&gt; Bird Cast.cast(Object o)\n        Cast.cast(o); //Doc提示： &lt;Object&gt; Object Cast.cast(Object o) \n\n        Fish f=Cast.cast(b); //Doc提示：&lt;Fish&gt; Fish Cast.cast(Object o) //！！ClassCastException\n}  \n\npublic static class Bird{} \npublic static class Fish{} \n", "\n\n", "} ", "cast泛型方法是如何做类型推断的？", "Bird b=Cast.cast(o); //cast如何推断出T就是Bird？？！！ 问题在这里", "Cast.cast(o); //cast此时只能推断出T就是Object", "难道区别在于有没有接收返回值，有的话，可以根据\"=\"号左边的类型继续推断；没有的话，只能推断出cast方法的参数类型；", "求详细解答 或 给予参考资料 OTZ ", "问题补充", "七心JAVA 写道", "Bird b=Cast.cast(o);", "是不是得加个类型强制转换？", "不需要，代码是从eclipse里拿出来的，java编译器可以通过", "问题补充", "IcyFenix 写道", "嗯，实际上这里确实是有个强制转换的，只不过...", "恩，请详细解释： Bird b=Cast.cast(o); //cast如何推断出T就是Bird？？！！ 问题在这里 ", "所有的泛型信息都会被擦除掉，这么说绝对吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;其他泛型是啥意思&amp;#xff0c;不是应该是里面啥泛型就是什么类型么&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java空的List可以获取他的泛型吗？", ["Java空的List可以获取他的泛型吗？", "\n", "\n", "Object", " ", "object", " = ", "new", " ArrayList<", "String", ">();\n ", "// 这里需要获取的类型就是String", "\n", "\n", "\n", "通过这种方式只能拿到\"E\"。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把你的代码放出来呀&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型声明出了问题，明明是一个类但是报错不一样？", ["原本是一个属性的繁星，我声明了T，就是前一个泛型。（没问题）", "然后返回值也要一个泛型声明，我就加了一个K。", "结果就这样了。", "明明一个类，但是说不一样，直接报错"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;java中 任何类型的父类 都是 Object类型&amp;#xff0c;重写的方法里的入参 它的父类也是Object类型&amp;#xff0c;这当然是允许用父类 Object 作为入参进行重写的了&amp;#xff0c;符合向上兼容的原则。&lt;br /&gt;简单理解就是 T类型也可以当作 Object类型使用&amp;#xff0c; 但 Object 不能当作 T类型使用&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型和方法重写", ["请问方法重写，形参不是要一样嘛，这里不一样的形参也可以运行，怎么回事"]], "Tag": "程序设计"}
{"Answer": "通过request.getParameterMap()获取的的数据Map&lt;String String[]&gt; 其中key 是String  value是一个String数组 \r\n\r\n现在你讲这样的数据放到一个Map&lt;String Object&gt; key是String  value是对象的的类型里面去 所以会发生 Type mismatch: cannot convert from Map&lt;String,String[]&gt; to Map&lt;String,Object&gt;\r\n\r\n\r\n修改成  Map&lt;String, String[]&gt; mapStr = request.getParameterMap();", "Konwledge_Point": "泛型机制——模板", "Question": ["request.getParameterMap()获取map集合泛型的问题，求解", ["Map map = request.getParameterMap();获取map集合泛型的问题", "\n\n", "错误提示信息", "\nType mismatch: cannot convert from Map to Map"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/rendaduiyan/article/details/4208966", "Konwledge_Point": "泛型机制——模板", "Question": ["C#中有没有二叉树？C#里泛型实现二叉树遍历，求代码的实现", ["C#中有没有二叉树？C#里泛型实现二叉树遍历，求代码的实现"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/hknock/article/details/47404759", "Konwledge_Point": "泛型机制——模板", "Question": ["关于JAVA泛型的类型擦除的一些疑问", ["例如", "\npublic class list", "\n{", "\nprivate Object[] elements;", "\n@SuppressWarnings(\"unchecked\")", "\npublic E get(int n)", "\n{", "\nreturn (E)elements[n];", "\n}", "\n}", "\n按照泛型的类型擦除不应该都变成Object了吗，", "\npublic E get(int n)", "\n{", "\nreturn (E)elements[n];", "\n}应该也变成", "\npublic Object get(int n)", "\n{", "\nreturn (Object)elements[n];", "\n}如果用的是list的get方法，为什么最后能返回String类型而不是Object类型。"]], "Tag": "程序设计"}
{"Answer": "http://zhidao.baidu.com/link?url=dAywmn5-CBLpCvxlXSzoSnUqMt8C-7JZHkmdnKZAUUsbxppa3QhGa6FtR9TyizmaFFt4wntYQt-O59scCUSew_", "Konwledge_Point": "泛型机制——模板", "Question": ["link中如何通过外键查询查找不同类型的实体类？如何用泛型实现", ["link中如何通过外键查询查找不同类型的实体类？如何用泛型实现"]], "Tag": "程序设计"}
{"Answer": "Class类就是你new出来的那个对象的模版 你这么想就ok了 Class会记录你new的那个对象的元数据，包括 方法信息 属性信息 实现的接口信息等等等等 虚拟机装载的就是这个Class对象 而你new的东西就是实际对象属性值的集合 看看inside jvm这书很有帮助\r\n\r\n难得lz能这么好学 这样的人不多了 加油吧", "Konwledge_Point": "泛型机制——模板", "Question": ["关于Java的Class类", ["本人初学Java，孤身奋战，经常被自己搞的头破血流，现有一问题，想与各位高人讨论讨论\n", "\n\n", "我百度了很多关于Class类的文章，看了很多，感觉好像明白了一点，但是又不敢确定，我把我的认识写下来，请各位评价评价。", "\nClass类是一个很特殊的类，在Java源文件编译完成生成的每个class文件中，都有一个Class对象，或者说跟Class这个类有关的一点东西，当JVM加载这个类(记做A)的时候，这个类(A)本身并不参与到JVM中，而是那个跟Class类有关的东西生成了一个Class的对象，这个对象包括了A的所有信息，而也可以说，这个Class对象就是一个包装了类A，让类A来了个改头换面后的一个类A的副本对象。", "\n    我的理解就是这样，不知道事实是不是这样，大家认为我理解不对请指出来吧！本来是打算问老师的，可是上次问了他一个超级简单的swing的问题，他支支吾吾硬是没回答我（我目前所出的学校是个专科院校），我觉着还是算了，另外，大家有时间的话，请告诉我一些学Java的途径，我现在老是自己一个人自学，感觉没什么进步，经常性的 :cry:  :cry:  :cry: ……"]], "Tag": "程序设计"}
{"Answer": "Map和List 都是接口，要从字符串\"Map&lt;String,List&lt;String&gt;&gt;\"获得一个Map&lt;String,List&lt;String&gt;&gt;对象？问题本身有问题，实例是HashMap&lt;String,ArrayList&lt;String&gt;&gt;还是TreeMap&lt;String,LinkedList&lt;String&gt;&gt;还是其他的实现。。。\r\n\r\n\tpublic static void main(String[] args) throws Exception {\t\tMap&lt;String, List&lt;String&gt;&gt; b = getInstance(\"Map&lt;String, List&lt;String&gt;&gt;\");\r\n\t\tSystem.out.println(b.getClass());\r\n\t}\r\n\r\n\tpublic static &lt;T&gt; T getInstance(String type) throws Exception {\r\n\t\tClass clazz = Class.forName(getClassName(type));\r\n\t\treturn (T) clazz.newInstance();\r\n\t}\r\n\r\n\tprivate static String getClassName(String type) {\r\n\t\tif (type.startsWith(\"Map\"))\r\n\t\t\treturn \"java.util.HashMap\";\r\n\t\treturn \"java.lang.Object\";\r\n\t}\r\n\r\njava泛型的类型应该不包括参数的类型，编译后被擦除了", "Konwledge_Point": "泛型机制——模板", "Question": ["java如何反转泛型？", ["如题：已知一个 关于类型的字符串（如“Map>”），现在需要根据这个字符串，获得一个Map>对象和该对象的Type?"]], "Tag": "程序设计"}
{"Answer": "这个方法是泛型方法。\r\n\r\n泛型方法使用起来比较灵活，和它所在的类是否泛型没有任何关系。该方法能够独立于类而产生变化。在定义泛型方法的时候，需要将泛型参数列表放在返回值的前面。\r\n\r\n/**\r\n * 泛型方法实例\r\n * \r\n * @author zhq\r\n * \r\n */\r\npublic class GenericMethod {\r\n\tpublic &lt;T&gt; void method(T x) {\r\n\t\tSystem.out.println(x.getClass().getName());\r\n\t}\r\n\t\r\n\tpublic static void main(String[] args) {\r\n\t\tGenericMethod gm = new GenericMethod();\r\n\t\tgm.method(\"我是字符串\");\r\n\t\tgm.method(1);\r\n\t\tgm.method(gm);\r\n\t\tgm.method('c');\r\n\t\tgm.method(true);\r\n\t}\r\n}\r\n\r\n\r\n输出结果：\r\njava.lang.String\r\njava.lang.Integer\r\ncn.com.newcom.ch18.xml.GenericMethod\r\njava.lang.Character\r\njava.lang.Boolean\r\n\r\n看了代码之后，应该明白了吧。使用泛型方法非常灵活。", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型的一个问题", [" void method()", "\n这个表示什么意思呢"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The Go paradigm is generally to avoid this by implementing the behavior in non-empty interfaces.  For example, say you wanted to print something with type-specific formatting:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func Print(i interface{}) {\n    switch o := i.(type) {\n        case int64:\n            fmt.Printf(\"%5d\n\", o)\n        case float64:\n            fmt.Printf(\"%7.3f\n\", o)\n        case string:\n            fmt.Printf(\"%s\n\", o)\n        default: // covers structs and such\n            fmt.Printf(\"%+v\n\", o)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Alternatively, you could define an interface for things that know how to string themselves (this exists in the base library as an &lt;code&gt;fmt.Stringer&lt;/code&gt;), and use that:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Stringer interface {\n    String() string\n}\n\nfunc Print(o Stringer) {\n    fmt.Println(o.String())\n}\n\ntype Foo struct {\n    a, b int\n}\n\nfunc (f Foo) String() string {\n    // Let's use a custom output format that differs from %+v\n    return fmt.Sprintf(\"%d(%d)\", f.a, f.b) \n}\n\ntype Bar struct {\n    t bool\n}\n\nfunc (b Bar) String() string {\n    if b.t {\n        return \"TRUE! =D\"\n    }\n    return \"false =(\"\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/Ez6Hez6cAv\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/Ez6Hez6cAv&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;This lets you have a generic-like functionality, but still retain type safety and have the behavior itself defined &lt;em&gt;by the types&lt;/em&gt;, rather than your generic function.&lt;/p&gt;\n\n&lt;p&gt;Go encourages you to think of types in this way, based on their behavior, what they can &lt;em&gt;do&lt;/em&gt; rather than what they &lt;em&gt;contain&lt;/em&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Go中的泛型函数", ["\n\n", "I'm in the process of learning ", "Go", " and the documentation and interactive lessons say that an empty ", "interface", " can hold any type, as it requires no additionally implemented methods.", "\n\n", "So for an example:", "\n\n", "func describe(i interace{}) {\n    fmt.Printf(\"Type: %T | Value: %v\n\", i, i)\n}\n", "\n\n", "...would print out...", "\n\n", "\"Type: int | Value: 5\" // for i := 5\n\"Type: string | Value: test\" // for i := \"test\"\n... etc\n", "\n\n", "So I guess my question is if this is ", "Go's", " way of implementing generic functions or if there is another, more suitable, way of doing them.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;blockquote&gt;\n  &lt;p&gt;Is there a better, or more idiomatic way of doing this?&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Yes: Handle the error. Log.Fatal is not error handling. If fataling is really the right thing: Encapsulate fataling only.&lt;/p&gt;\n\n&lt;p&gt;Make fataling on error a function, not the calling and please stay away from &lt;code&gt;interface{}&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func abortOnError(err error) {\n    if err == nil {return}\n    log.Fatal(err)\n}\n\nfunc whatever() int {\n    x, err := someOp()\n    abortOnError(err)\n    return x+2\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["go中的泛型函数", ["\n\n", "I am trying to abstract the following pattern that seems to occur quite a lot, but the only way I can think of doing so is through a generic function:", "\n\n", "func DoStuff () MyType {\n    result, err := SomeProcess()  // returns MyType\n    if err != nil {\n        log.Fatal(err)\n    }\n    return result // or do something else with it\n}\n", "\n\n", "Here's my solution:", "\n\n", "func FailOnError(value interface{}, err error) interface{} {\n    if err != nil {\n        log.Fatal(err)\n    }\n    return value\n}\n\nfunc DoStuff () MyType {\n    return FailOnError(SomeProcess())\n}\n", "\n\n", "The problem is that I don't have compile-time type safety, and if I want to do anything further with the result I need to explicitly type cast it, e.g.", "\n\n", "type MyType struct {\n    value int\n}\n\n// Assuming a function with this signature\nfunc GetItem() (MyType, error)\n\nfunc Add () MyType {\n    item := MyType(FailOnError(GetItem()))\n}\n", "\n\n", "This is ok, I guess, but rather inelegant. Also, it means manually enforcing types which is always somewhat fragile and a potential performance hit.", "\n\n", "Is there a better, or more idiomatic way of doing this?", "\n\n", "Edit:", " Since this seems to be a hated question, how about I use the following example instead:", "\n\n", "func Identity(x interface{}) interface{} {\n    return x\n}\n", "\n\n", "Usage would need to be:", "\n\n", "x = int(Identity(1))\ny = MyType(Identity(MyType{value}))\n", "\n\n", "And there is nothing stopping me from doing", "\n\n", "x = int(Identity(MyType{value}))\n", "\n\n", "Identity", " is intentionally trivial, but need not necessarily be so. I could be, for example, and method designed to do some logging, or mutate an object and return it.  Another situations I have is where I want to do some work on some types defined in various external libraries - they are similar enough that I can write a single function to handle all of them, but they don't share an interface.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个跟泛型擦除没有关系 , TreeMap没有参数为Class的构造方法 , 你传入Class当然会报错&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java泛型擦除有点懵", ["\n", "public class FX1 {\n    public static void main(String[] args) {\n        Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);\n        map.put(DayOfWeek.MONDAY, \"星期一\");\n        map.put(DayOfWeek.TUESDAY, \"星期二\");\n        map.put(DayOfWeek.WEDNESDAY, \"星期三\");\n        map.put(DayOfWeek.THURSDAY, \"星期四\");\n        map.put(DayOfWeek.FRIDAY, \"星期五\");\n        map.put(DayOfWeek.SATURDAY, \"星期六\");\n        map.put(DayOfWeek.SUNDAY, \"星期日\");\n        System.out.println(map);\n        System.out.println(map.get(DayOfWeek.MONDAY));\n    }\n}\n\npublic class FX2 {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new TreeMap<>();\n        map.put(\"orange\", 1);\n        map.put(\"apple\", 2);\n        map.put(\"pear\", 3);\n        for (String key : map.keySet()) {\n            System.out.println(key);\n        }\n    }\n}", "\n\n", "为什么第一个类中实例化必须要传入DayOfWeek.class，而第二个类中实例不传任何参数，传入了反而报错。求各位大佬解答"]], "Tag": "程序设计"}
{"Answer": "方法改成如下即可：\r\n\r\n\tprotected static &lt;E&gt; String getEntityName(Class clazz) {\r\n\t\t// TODO Auto-generated method stub\r\n\t\tString entityName = clazz.getSimpleName();\r\n\t\tAnnotation anno = clazz.getAnnotation(Entity.class);\r\n\t\tif(anno instanceof Entity)\r\n\t\t{\r\n\t\t\tEntity entity = (Entity)anno;\r\n\t\t\tif(entity != null &amp;&amp; !\"\".equals(entity.name())){\r\n\t\t\t\tentityName = entity.name();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn entityName;\r\n\t}\r\n\r\n实际上那个编译错误，跟&lt;E&gt;泛型无关，而是由于class.getAnnotation返回的是Annotation，而你直接用Entity entity =class.getAnnotation导致类型转换编译时失败。", "Konwledge_Point": "泛型机制——模板", "Question": ["一个关于反射，泛型的问题，欢迎讨论···", ["设计一个方法，传入一个class对象，返回这个class的类名，这个需求本身不难，代码如下：", "\n[code=\"java\"]public class GenericsTest {", "\n\n", "protected static  <E>  String getEntityName(Class<E> clazz) {\n    // TODO Auto-generated method stub\n    String entityName = clazz.getSimpleName();\n    Entity entity = clazz.getAnnotation(Entity.class);\n    if(entity != null && !\"\".equals(entity.name())){\n        entityName = entity.name();\n    }\n    return entityName;\n}\n\n\npublic static void main(String [] args){\n    GenericsTest g = new GenericsTest();\n    System.out.println(GenericsTest.getEntityName(g.getClass()));\n}\n", "\n\n", "}[/code]", "\n\n", "问题在于：如果我将上面的getEntityname方法的泛型参数去掉的话就会报错，编译不通过，我不明白的就是这里的到底有什么作用？？？我在调用getEntityname的时候并没有给他传递泛型参数，但是却不能没有这个泛型参数，这奇怪啊，欢迎讨论！！！", "\n\n", "去掉泛型参数代码如下：", "\n[code=\"java\"]public class GenericsTest {", "\n\n", "protected static   String getEntityName(Class clazz) {\n    // TODO Auto-generated method stub\n    String entityName = clazz.getSimpleName();\n    Entity entity = clazz.getAnnotation(Entity.class);\n    if(entity != null && !\"\".equals(entity.name())){\n        entityName = entity.name();\n    }\n    return entityName;\n}\n\n\npublic static void main(String [] args){\n    GenericsTest g = new GenericsTest();\n    System.out.println(GenericsTest.getEntityName(g.getClass()));\n}\n", "\n\n", "}[/code]"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;就是指定类型了呀。返回类型是T,输入类型也是T。对于这个方法的开发者来说&amp;#xff0c;传过来啥类型的参数&amp;#xff0c;就必须返回啥类型。对于使用者来说&amp;#xff0c;我传进去啥类型参数&amp;#xff0c;就得到啥类型结果&amp;#xff0c;我可以直接用这个类型变量来接收&amp;#xff0c;和Object区别就是不用强制转换类型了。&lt;br /&gt;假如我传进去一个int类型&amp;#xff0c;那么 T get(T value);和 int get(int value) 使用上没有任何区别。就相当于T是一个动态类型。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["求解答dart泛型中函数名后的T的意义", ["有没有哪位能解答下dart泛型中函数名后的T代表的意义，", "看视频做笔记时发现了疑问，当时认为“输入类型”不应该等同于传入的“参数类型”吗？", "上网搜到的简书中的解释也没搞明白，现在更摸不着头脑了。", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个是构造一个LambdaQueryWrapper对象&amp;#xff0c;你也可以这样写LambdaQueryWrapper lqw &amp;#61; new LambdaQueryWrapper&amp;lt;&amp;gt;();MaterialQrcodeInfo::getMaterialCode是一个函数&amp;#xff0c;也就是Lambda表达式的&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["LambdaQueryWrapper问题", ["此处代码中LambdaQueryWrapper lqw = Wrappers.lambdaQuery();这句是什么意思呢", "此时lqw是为空吗，那么MaterialQrcodeInfo::getMaterialCode不也是空吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;很简单的道理&amp;#xff0c;在java中&amp;#xff0c;大于、小于都只能作用于数字类型&amp;#xff08;java中并不能重载操作符&amp;#xff09;&amp;#xff0c;如long、int、short等等。图1泛型T就是一个Object&amp;#xff0c;并不是具体的数字&amp;#xff0c;因此无法用大于小于来比较。图2泛型是Integer&amp;#xff0c;为int的包装类型&amp;#xff0c;自然可以使用大于小于来比较。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["为什么不能用泛型表示？有人能解答一下吗？", ["\n", "为什么参数不能用泛型的顺序表，用了会报错，改成指定的顺序表就可以了，为什么会这样子？，不懂，这个是什么原因？", "\n"]], "Tag": "程序设计"}
{"Answer": "假如我传入的类型就是String类型呢,你Object虽然兼容String,但是我现在要的就是String,你用Object接收的话还需要抢转(向下转型),而我用泛型直接就定义泛型为String,我还需要转型么,?在假如,我需要一个接口的实现类,也是Object类型可以兼容对吧,你过来之后,你怎么知道我传入的接口是什么类型?不知道怎么调用方法?调用不了方法还有什么用?泛型是很强大得,好好研究吧!", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型public class Cacl<T>与 Cacl<Object>的区别？", ["java中定义泛型类public class Cacl与public class Cacl的区别？java为何还需要定义出一个T来替代Object？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你定义个一个Goods类&amp;#xff0c;里面按老师要求给几个商品属性&amp;#xff0c;比如名称&amp;#xff0c;价格&lt;br /&gt;然后&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-built_in\"&gt;Queue&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;queue&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;new&lt;/span&gt; LinkedList();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;变成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-built_in\"&gt;Queue&lt;/span&gt;&amp;lt;Goods&amp;gt; &lt;span class=\"hljs-built_in\"&gt;queue&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-literal\"&gt;new&lt;/span&gt; LinkedList&amp;lt;Goods&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;后面再一个个的构建Goods实例&amp;#xff0c;放入Queue&lt;br /&gt;例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Goods&lt;/span&gt; {\n\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name;\n    \n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; prise;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getName&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; name;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setName&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.name &amp;#61; name;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getPrise&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; prise;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setPrise&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; prise)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.prise &amp;#61; prise;\n    }\n    \n    \n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;final&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] args)&lt;/span&gt; throws Exception &lt;/span&gt;{\n        Queue&amp;lt;Goods&amp;gt; queue &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;LinkedList&lt;/span&gt;&amp;lt;Goods&amp;gt;();\n        Goods goods1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Goods&lt;/span&gt;();\n        goods1.&lt;span class=\"hljs-built_in\"&gt;setName&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;商品1&amp;#34;&lt;/span&gt;);\n        goods1.&lt;span class=\"hljs-built_in\"&gt;setPrise&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;12.5f&lt;/span&gt;);\n        \n        queue.&lt;span class=\"hljs-built_in\"&gt;offer&lt;/span&gt;(goods1);\n    }\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["使用泛型定义一个Queue，加入5个商品类", ["package com.jah.collection12;", "import java.util.*;", "public class TestQueue {", "public static void main(String[] args) {", "Queue queue = new LinkedList();", "queue.offer(\"abc\");", "queue.offer(\"cde\");", "queue.offer(\"123\");", "queue.offer(\"abc\");", "System.out.println(queue);", "System.out.println(\"queue.element():\"+queue.element());", "System.out.println(queue);", "System.out.println(\"queue.peek():\"+queue.peek());", "System.out.println(queue);", "System.out.println(\"queue.poll():\"+queue.poll());", "System.out.println(queue);", "System.out.println(\"queue.remove():\"+queue.remove());", "page4", "System.out.println(queue);", "} }", "大佬们，今天老师布置的作业，学会使用List的泛型，使用泛型定义一个Queue，加入5个商品对象，上面是他打出的例子，但不是商品对象，说是用的字符串，让我们用商品类goods，大佬们这咋弄"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1中实际上没有继承&amp;#xff0c;只是新建了一个实现类的对象&amp;#xff0c;调用方法的入参是Obeject类型&amp;#xff0c;随便传什么类型都是可以的&amp;#xff0c;但是2就调用的是接口的办法&amp;#xff0c;接口中定义的入参必须是泛型指定的类型&amp;#xff0c;只不过执行的是子类重写的办法而已&amp;#xff0c;但是入参不对就会直接报错了&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型接口问题，怎么弄", ["泛型接口：\n", "public", " ", "abstract", " ", "interface", " GenericInter<T> {\n    ", "public", " ", "abstract", " ", "void", " ", "printGeneric", "(T t);\n}\n\n泛型接口的实现类：\n", "public", " ", "class", " ", "GenericInterImpl1", "<A> ", "implements", " ", "GenericInter", "<A>{\n    ", "@Override", "\n    ", "public", " ", "void", " ", "printGeneric", "(", "Object", " o", ") {\n        ", "System", ".", "out", ".", "println", "(o);\n    }\n\n测试类：\n", "public", " ", "class", " ", "Main", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n        ", "GenericInterImpl", "1<", "String", "> g1=", "new", " ", "GenericInterImpl", "1<>();\n        g1.", "printGeneric", "(", "123", ");     第", "1", "处\n\n        ", "GenericInter", "<", "Integer", "> g0=", "new", " ", "GenericInterImpl", "1<>();\n        g0.", "printGeneric", "(", "\"3\"", ");", "//第2处", "\n    }\n}\n", "\n", "我的问题是：1和2的执行流程是什么？为什么1没报错，2却报错了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.不会报错&lt;br /&gt;2.输出为&amp;#xff1a;100&lt;/p&gt;\n&lt;p&gt;其实也不是泛型的问题 第一个Map没有定义泛型默认为 Map&amp;lt;Object,Object&amp;gt; 所以在输出的时候会出现类型转换的异常 所以泛型最好还是指定下&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["被Java泛型坑惨了", ["下面的Java代码会不会报错", "输出是什么", "\n", "import", " java.", "util", ".", "HashMap", ";\n", "import", " java.", "util", ".", "Map", ";\n\n", "public", " ", "class", " ", "Test", " {\n\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n\n        ", "Map", " map1 = ", "new", " ", "HashMap", "();\n        map1.", "put", "(", "\"key\"", ", ", "new", " ", "Integer", "(", "100", "));\n        ", "Map", "<", "String", ", ", "String", "> map2 = map1;\n        ", "Integer", " value = ", "Integer", ".", "valueOf", "(((", "Object", ")map2.", "get", "(", "\"key\"", ")).", "toString", "());\n        ", "System", ".", "out", ".", "println", "(value);\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "[url]http://blog.csdn.net/ykdsg/article/details/5472591[/url]", "Konwledge_Point": "泛型机制——模板", "Question": ["关于获取泛型类型的问题", ["问大家一个问题.", "\nclass A{", "\n    private List temp; <---怎么获取到字段的类型为D?", "\n    public void getTemp(List t){temp = t}  ", "\n\n", "}", "\nclass B{}", "\n\n", "class C extend A{}  <---怎么获取D?", "\nclass D extend B{}", "\n\n", "使用C.class.getTypeParameters()得到空, 使用C.class.getGenericSuperclass().getTypeParameters()得到的", "\n\n", "是B"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;泛型T相当于Object类型&amp;#xff0c;“&amp;#xff1f;”代表未知类型&amp;#xff0c;这个类型是实现Collection接口。一般用在集合中。&lt;/p&gt;\n\n&lt;p&gt;如果不明白&amp;#xff0c;可以参考这篇文章&amp;#xff0c;讲述的很详细&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/ikownyou/article/details/65630385\"&gt;https://blog.csdn.net/ikownyou/article/details/65630385&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["关于java泛型中的？", ["老师讲到：", "\n\n", " ", "\n\n", "\n", "public class Generic <T>{\n    private T flag;\n    public void setFlag(T flag){\n        this.flag=flag;\n    }\n    public T getFlag(){\n        return this.flag;\n    }\n}\n", "\n\n", "\n", "public class Showmsg {\n    public void showflag(Generic<?> generic){\n        System.out.println(generic.getFlag());\n    }\n}", "\n\n", "\n", "public class Test {\n    public static void main(String[] args) {\n        Showmsg showmsg=new Showmsg();\n        Generic<Integer>generic1=new Generic<>();\n        generic1.setFlag(20);\n        showmsg.showflag(generic1);\n        Generic<Number>generic=new Generic<>();\n        generic.setFlag(50);\n        showmsg.showflag(generic);\n\n    }\n}", "\n\n", "我的理解是？和其他通配符一样，只是便于理解认为的做出划分", "\n\n", "为了验证我的猜想，我把第一段中的T全部改成了？如下：", "\n\n", "\n", "public class Generic <?>{\n    private ? flag;\n    public void setFlag(? flag){\n        this.flag=flag;\n    }\n    public ? getFlag(){\n        return this.flag;\n    }\n}", "\n\n", "但是，改完之后就全红了，idea也没给什么提示，好像？不能做通配符似的", "\n\n", "难道？不能作为声明定义中的通配符？", "\n\n", "我就又把代码还原，在第三段中加了一句", "\n\n", "\n", "        Generic<?>g=new Generic<>();", "\n\n", "ok，没报错，然后又加了句", "\n\n", "\n", "        g.setFlag(\"56\");\n", "\n\n", "结果又报错了，看提示应该是56作为参数格式不对，那为什么上一句没报错呢？", "\n\n", "另外还想问一下，各个通配符在语法上是否存在不同含义，具体使用方法又有什么不同呢？"]], "Tag": "程序设计"}
{"Answer": "```\r\n看相对于谁来说\r\nT对于泛型来说，是一个具体的类型，对于调用泛型的来说，是一个任意（也有约束）的类型\r\n而?对于泛型来说，它也是一个任意类型。\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型的问题，关于通配符和类型参数T？", ["1：为什么说T是代表特定类型，?代表任意类型，T不也是未知任意的类型吗，具体的要由实例化时传入的类型决定，传入之前不也是未知任意的吗", "\n2：下图如何理解？", "\n为什么说？的意义是实例化泛型参数，？不是代表任意类型吗（如果去掉图中的extends），怎么能实例化类型参数T呢，他自己本身就是任意类型？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;? extends 上界通配符&amp;#xff0c;list1 的上界为 Person&amp;#xff0c; list1.get(0) ---&amp;gt; Person&amp;#xff0c;Student 继承于 Person&amp;#xff0c;自然不能把 Person 赋值给 Student&amp;#xff0c;跟Java 的继承方面有关系&amp;#xff0c;有关泛型&amp;#xff0c;可以参考一下下面链接 &lt;br /&gt;\n&lt;a href=\"https://kaixue.io/kotlin-generics/\"&gt;https://kaixue.io/kotlin-generics/&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["关于 java 中的泛型？", ["\n", "\n\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class TessWildcard {\n    @Test\n    public void test(){\n        List<? extends Person> list1 = null;\n        List<? super Person> list2 = null;\n\n        List<Student> list3 = new ArrayList<>();\n        List<Person> list4 = new ArrayList<>();\n        List<Object> list5 = new ArrayList<>();\n\n        // ***********************\n        list1 = list4; // list4 符合 list1 小于等于 Person 的规范\n\n        // 这里也没有超出 Person 请问为什么会编译报错\n        Student stu = list1.get(0);\n    }\n\n    class Person{\n\n    }\n\n    class Student extends Person{\n\n    }\n}\n", "\n\n", "本人小白，求通俗易懂的解答"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;        public static Type GetTypeByName(string typename)\n        {\n            Type t &amp;#61; null;\n            string source &amp;#61; typename;\n            if (source.IndexOf(&amp;#39;&amp;lt;&amp;#39;) &amp;gt; 0)\n            {\n                List&amp;lt;string&amp;gt; lv &amp;#61; new List&amp;lt;string&amp;gt;();\n                while (RegexExpand.IsMatch(source, &amp;#64;&amp;#34;&amp;lt;[^&amp;lt;&amp;gt;]&amp;#43;&amp;gt;&amp;#34;))\n                {\n                    lv.Add(RegexExpand.Match(source, &amp;#64;&amp;#34;(?&amp;lt;&amp;#61;&amp;lt;)[^&amp;lt;&amp;gt;]&amp;#43;(?&amp;#61;&amp;gt;)&amp;#34;).Value);\n                    source &amp;#61; RegexExpand.Replace(source, &amp;#64;&amp;#34;&amp;lt;[^&amp;lt;&amp;gt;]&amp;#43;&amp;gt;&amp;#34;, &amp;#34;/&amp;#34; &amp;#43; (lv.Count - 1));\n                }\n                List&amp;lt;Type[]&amp;gt; args &amp;#61; new List&amp;lt;Type[]&amp;gt;();\n                for (int i &amp;#61; 0; i &amp;lt; lv.Count; i&amp;#43;&amp;#43;)\n                {\n                    List&amp;lt;Type&amp;gt; arg &amp;#61; new List&amp;lt;Type&amp;gt;();\n                    string[] sp &amp;#61; lv[i].Split(&amp;#39;,&amp;#39;);\n                    for (int j &amp;#61; 0; j &amp;lt; sp.Length; j&amp;#43;&amp;#43;)\n                    {\n                        string s &amp;#61; sp[j].Trim();\n                        if (!string.IsNullOrEmpty(s))\n                        {\n                            if (RegexExpand.IsMatch(s, &amp;#64;&amp;#34;/\\d&amp;#43;$&amp;#34;))\n                            {\n                                Match m &amp;#61; RegexExpand.Match(s, &amp;#64;&amp;#34;^([^/\\s]&amp;#43;)\\s*/(\\d&amp;#43;)$&amp;#34;);\n                                if (!m.Success)\n                                {\n                                    throw new Exception(&amp;#34;&amp;#34;);\n                                }\n                                Type p &amp;#61; GetTypeByName(m.Groups[1].Value);\n                                Type c &amp;#61; p.MakeGenericType(args[Convert.ToInt32(m.Groups[2].Value)]);\n                                arg.Add(c);\n                            }\n                            else\n                            {\n                                arg.Add(GetTypeByName(s));\n                            }\n                        }\n                    }\n                    args.Add(arg.ToArray());\n                }\n                Match f &amp;#61; RegexExpand.Match(source, &amp;#64;&amp;#34;^([^/\\s]&amp;#43;)\\s*/(\\d&amp;#43;)$&amp;#34;);\n                if (!f.Success)\n                {\n                    throw new Exception(&amp;#34;&amp;#34;);\n                }\n                Type fp &amp;#61; GetTypeByName(f.Groups[1].Value);\n                Type fc &amp;#61; fp.MakeGenericType(args[Convert.ToInt32(f.Groups[2].Value)]);\n                return fc;\n            }\n            else\n            {\n                try\n                {\n                    t &amp;#61; Type.GetType(source);\n                    if (t !&amp;#61; null)\n                    {\n                        return t;\n                    }\n                    Assembly[] assembly &amp;#61; AppDomain.CurrentDomain.GetAssemblies();\n                    foreach (Assembly ass in assembly)\n                    {\n                        t &amp;#61; ass.GetType(source);\n                        if (t !&amp;#61; null)\n                        {\n                            return t;\n                        }\n                        Type[] ts &amp;#61; ass.GetTypes();\n                        foreach (Type st in ts)\n                        {\n                            if (RegexExpand.IsMatch(st.FullName, &amp;#64;&amp;#34;\\.&amp;#34; &amp;#43; RegexExpand.FormatRegExp(source) &amp;#43; &amp;#64;&amp;#34;(&amp;#96;?\\d&amp;#43;)?$&amp;#34;))\n                            {\n                                return st;\n                            }\n                        }\n                    }\n                }\n                catch (Exception ex)\n                {\n\n                }\n            }\n            return t;\n        }\n\n// 调用的时候很简单\n                string typename &amp;#61; &amp;#34;Dictionary&amp;lt;Dictionary&amp;lt;string,List&amp;lt;Ajax&amp;gt;&amp;gt;,int&amp;gt;&amp;#34;;\n                Type t &amp;#61; Common.GetTypeByName(typename);\n                dynamic item &amp;#61; t.Assembly.CreateInstance(t.FullName);\n// 代码中出现RegexExpand 可用 Regex 代替&amp;#xff0c;代替后记得加忽略大小写的参数\n// FormatRegExp &amp;#xff0c;用来替换字符串中的特殊符号加转义&amp;#xff0c;比如 .&amp;#43;*[]等&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["c# 已知字符串内容，如果把字符串作为泛型使用", ["\n", "var kind =\"PageSkill\";\nvar service =new SkillService<PageSkill>();", "\n\n", "如何根据已知变量kind，确定第二行代码的泛型？"]], "Tag": "程序设计"}
{"Answer": "首先泛型T是指代对应的实体类\r\n\r\n例如有个实体类是China，那么就可以定义对应的List\r\n\r\nList&lt;China&gt; chinaList = new ArrayList&lt;China&gt;();\r\n\r\nchinaList里的每个元素就必须都是China对象", "Konwledge_Point": "泛型机制——模板", "Question": ["<? super ComExcel>把? 换成泛型T,应该怎么写?", ["这句话要是把? 换成泛型T,应该怎么写?", "\n\n", " List<? super ComExcel> result = new ArrayList<>();\n", "\n\n", " public interface ComExcel {\n\n}\n"]], "Tag": "程序设计"}
{"Answer": "这不是泛型，而是编译器生成的方法（比如匿名方法），编译器会自动产生一个名字。这个名字为了避免和你现有代码中的方法名重合，所以C#编译器使用了`&lt;&gt;`，这保证方法名对于IL有效，但是绝对不可能和你的程序自己写的函数名冲突。", "Konwledge_Point": "泛型机制——模板", "Question": ["link中一个方法后面跟着<>是什么意思？如果是泛型，为什么中间没有类型？", ["link中一个方法后面跟着<>是什么意思？如果是泛型，为什么中间没有类型？"]], "Tag": "程序设计"}
{"Answer": "C#分为引用类型和值类型，int cha还有结构体是值类型，别的事引用类型。", "Konwledge_Point": "泛型机制——模板", "Question": ["请教一个link引用化的问题？link中哪些类型需要引用化，除了数组泛型还有么？", ["请教一个link引用化的问题？link中哪些类型需要引用化，除了数组泛型还有么？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;h2&gt;Compare method&lt;/h2&gt;\n\n&lt;p&gt;Either you implement a compare-method for your object:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;- (NSComparisonResult)compare:(Person *)otherObject {\n    return [self.birthDate compare:otherObject.birthDate];\n}\n\nNSArray *sortedArray = [drinkDetails sortedArrayUsingSelector:@selector(compare:)];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;NSSortDescriptor (better)&lt;/h2&gt;\n\n&lt;p&gt;or usually even better:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;NSSortDescriptor *sortDescriptor;\nsortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"birthDate\"\n                                           ascending:YES];\nNSArray *sortedArray = [drinkDetails sortedArrayUsingDescriptors:@[sortDescriptor]];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can easily sort by multiple keys by adding more than one to the array. Using custom comparator-methods is possible as well. Have a look at &lt;a href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSSortDescriptor_Class/Reference/Reference.html\" rel=\"noreferrer\"&gt;the documentation&lt;/a&gt;.&lt;/p&gt;\n\n&lt;h2&gt;Blocks (shiny!)&lt;/h2&gt;\n\n&lt;p&gt;There's also the possibility of sorting with a block since Mac OS X 10.6 and iOS 4:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;NSArray *sortedArray;\nsortedArray = [drinkDetails sortedArrayUsingComparator:^NSComparisonResult(id a, id b) {\n    NSDate *first = [(Person*)a birthDate];\n    NSDate *second = [(Person*)b birthDate];\n    return [first compare:second];\n}];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h1&gt;Performance&lt;/h1&gt;\n\n&lt;p&gt;The &lt;code&gt;-compare:&lt;/code&gt; and block-based methods will be quite a bit faster, in general, than using &lt;code&gt;NSSortDescriptor&lt;/code&gt; as the latter relies on KVC.  The primary advantage of the &lt;code&gt;NSSortDescriptor&lt;/code&gt; method is that it provides a way to define your sort order using data, rather than code, which makes it easy to e.g. set things up so users can sort an &lt;code&gt;NSTableView&lt;/code&gt; by clicking on the header row.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["我如何将一个带有定制对象的 NSMutableArray 排序？", ["\n\n", "What I want to do seems pretty simple, but I can't find any answers on the web. I have an ", "NSMutableArray", " of objects, and let's say they are 'Person' objects. I want to sort the ", "NSMutableArray", " by Person.birthDate which is an ", "NSDate", ".", "\n\n", "I think it has something to do with this method:", "\n\n", "NSArray *sortedArray = [drinkDetails sortedArrayUsingSelector:@selector(???)];\n", "\n\n", "In Java I would make my object implement Comparable, or use Collections.sort with an inline custom comparator...how on earth do you do this in Objective-C?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/805547/how-do-i-sort-an-nsmutablearray-with-custom-objects-in-it"]], "Tag": "程序设计"}
{"Answer": "Map&lt;K,V&gt;存储的是键值对，泛型K，V分别制定了键值的类型，例如Map&lt;String,Integer&gt;说明存储的map的key是String类型，值是Integer类型。", "Konwledge_Point": "泛型机制——模板", "Question": ["java中Map不是本身以键值对储存数据的吗，为什么有时候看到它加泛型呢", ["java中Map不是本身以键值对储存数据的吗，为什么有时候看到它加泛型呢", "\nMap"]], "Tag": "程序设计"}
{"Answer": "说说我的看法吧。泛型之所以会写在类名后面，那是因为这个泛型贯穿了整个类，是这个类的一个很重要的类型。但明显 T 不是，它仅仅就被使用了一次，然后这个V感觉也没什么用。所以如果T的确是某个成员变量的类型，你可以定义到类名后面。\r\n第二个//这个获取的是Emp类型    t是一个对象 由t可以获取t的class对象。由class对象可以获得t的类的属性。通过field.get(t) 传入一个对象。\r\n相当于就是t.getXX(); 这个方法的效果就是这样。。\r\n            T t = list.get(i);\r\n            //这个是Emp的属性数组\r\n            Field[] fields = t.getClass().getFields();\r\n            for (Field field : fields) {\r\n                //field这是属性\r\n                //field.get(t) 这句话我就不理解了\r\n                //为什么属性获取Emp类，可以获取到属性的值\r\n                Object object = field.get(t);\r\n                /*------------没看懂代码片-结束--------------*/", "Konwledge_Point": "泛型机制——模板", "Question": ["对于Java泛型的一些疑问！求大神解答！", ["全部代码如下，问题在第一个代码片中", "\n\n", "package ref;\nimport java.lang.reflect.Field;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport ref.annotation.ExcelField;\nimport ref.model.Emp;\n//测试类\npublic class Test {\n\n    public static void main(String[] args) throws Exception {\n        outExcel(initData());\n    }\n    //利用反射输出数据\n    public static <T> void outExcel(List<T> list) throws Exception{\n        Field[] declaredFields = list.get(0).getClass().getDeclaredFields();\n        for (Field field : declaredFields) {\n            ExcelField annotation = field.getAnnotation(ExcelField.class);\n            System.out.println(annotation.key());\n        }\n        /*\n         * =======================================\n         * ================问题如下===============\n         * =======================================\n         */\n\n        /*\n         * 这里有几个地方,我没看懂\n         * 1、<T>这是个泛型,泛型一般不都是定义在类后面吗?泛型定义在方法上会不会不好?\n         * 2、下面的没看懂代码片中\n         */\n        for(int i=0;i<list.size();i++){\n            /*------------没看懂代码片-开始--------------*/\n            //这个获取的是Emp类型\n            T t = list.get(i);\n            //这个是Emp的属性数组\n            Field[] fields = t.getClass().getFields();\n            for (Field field : fields) {\n                //field这是属性\n                //field.get(t) 这句话我就不理解了\n                //为什么属性获取Emp类，可以获取到属性的值\n                Object object = field.get(t);\n                /*------------没看懂代码片-结束--------------*/\n                if(object instanceof Integer) System.out.println((Integer)object);\n                if(object instanceof String) System.out.println((String)object);\n                if(object instanceof Timestamp) System.out.println((Timestamp)object);\n            }\n        }\n    }\n    //构造数据\n    private static List<Emp> initData() {\n        List<Emp> emps = new ArrayList<Emp>();\n        Emp emp;\n        for(int i=0;i<3;i++){\n            emp = new Emp(i,UUID.randomUUID().toString(),new Timestamp(System.currentTimeMillis()));\n            emps.add(emp);\n        }\n        return emps;\n    }\n}\n\n\n\n", "\n\n", " package ref.model;\nimport java.sql.Timestamp;\nimport ref.annotation.ExcelField;\npublic class Emp {\n    @ExcelField(key = \"编号\")\n    public Integer id;\n    @ExcelField(key = \"名字\")\n    public String name;\n    @ExcelField(key = \"创建时间\")\n    public Timestamp createTime;\n\n    public Emp(Integer id, String name, Timestamp createTime) {\n        super();\n        this.id = id;\n        this.name = name;\n        this.createTime = createTime;\n    }\n}\n\n", "\n\n", "package ref.annotation;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n//@Target,约束之用,告诉计算机,此注解可以被放在哪些元素之前\n@Target({\n    ElementType.FIELD,\n    ElementType.METHOD\n})\n//@Retention,告诉计算机,此注解的生命周期\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ExcelField {\n    String key();\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "jdk1.7之前要求实例化的时候需要指明泛型。而1.7以及以后的版本中可以省略。可以检查下你的编译版本。", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型创建对象时出问题", ["Map paramMap = new LinkedHashMap<>();这种写法在myeclipse 、JDK1.7环境中编译错误 ：Incorrect number of arguments for type LinkedHashMap; it cannot be parameterized with arguments <?>，请问是什么引起的呢？"]], "Tag": "程序设计"}
{"Answer": "Field使用Nest.Infer命名空间的就是正常的了", "Konwledge_Point": "泛型机制——模板", "Question": ["C#操作ElasticSearch Field泛型问题", ["\n请问Fields = Field(p=>p.Description).And(\"myOtherField\"),Project怎么填"]], "Tag": "程序设计"}
{"Answer": "应该可以的，泛型的类型不确定，加上？也是白加吧", "Konwledge_Point": "泛型机制——模板", "Question": ["java中这个AdapterView<?> arg；泛型作为方法参数的时候<?>可以省略吗？", ["这个AdapterView<?> arg；泛型作为方法参数的时候<?>可以省略吗？", "\n<?>感觉可有可无啊，"]], "Tag": "程序设计"}
{"Answer": "BeanHandle是一个类，它的构造函数的参数是Class，java有一个叫Class的类，存储的是各个类的类型信息，可以通过类名.class获取。\r\nnew BeanHandler(Category.class)就是创建了一个BeanHandler类型的对象，传递给它的参数是Category类的类型信息。", "Konwledge_Point": "泛型机制——模板", "Question": ["<Category>、(Category.class)分别代表什么，如何理解这个泛型呢", ["qr.query(sql,new BeanHandler(Category.class),cid)中Category是一个类，", "\n请问BeanHandler 、、(Category.class)分别代表什么，如何理解这个泛型呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你先自己尝试编码&amp;#xff0c;遇到问题再来问问题&amp;#xff0c;而不是一上来就把整个问题抛出来&amp;#xff0c;如果最基本的编码你都没有尝试&amp;#xff0c;给你答案又有什么用呢&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java的泛型类的相关问题", ["（数组中的最大元素）实现下面的方法，返回数组中的最大元素。", "\n", "public static E max(E[ ] list)", "\n", "定义一个圆类，实现Comparable接口，按照半径比较大小，", "\n", "编写测试方法，使用max函数，求圆数组中最大值。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给你画了个图&amp;#xff0c;不知道好理解一些不&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/219201248836112.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型的赋值，为什么可以", ["为什么是并列关系"]], "Tag": "程序设计"}
{"Answer": "import java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class Test6 {\r\n\tpublic static void main(String[] args) {\r\n\t\tGen&lt;String&gt; a=new Gen&lt;String&gt;();\r\n\t\ta.add(\"aaa\");\r\n\t\tSystem.out.println(a.select(0));\r\n\t}\r\n}\r\n\r\nclass Gen&lt;T&gt; {\r\n\tList&lt;T&gt; l = new ArrayList&lt;T&gt;();\r\n\tpublic void add(T t){\r\n\t\tl.add(t);\r\n\t}\r\n\tpublic T select(int i){\r\n\t\treturn l.get(i);\r\n\t}\r\n}\r\n\r\n\r\n为了省事 用list给你包了一个 呵呵。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于java泛型的一个编程", ["创建一个参数化类型的随机访问列表RandomList，这个类有一个put（T element）方法加入元素，并且有一个select（）方法可以从中随机的选择一个元素，创建一个main方法，使得可以打印出select（）方法所选择的元素。"]], "Tag": "程序设计"}
{"Answer": "自己创建的Course对象也是属于引用类型的，本质上和String，Integer等都是一样的，你看一下jdk的源码就知道了，String，Integer等也是一个类，只不过是被封装成了jar包而已", "Konwledge_Point": "泛型机制——模板", "Question": ["关于泛型的小问题一个", ["public class Student {", "\n\n", "public String id;\n\npublic String name;\n\npublic Set<Course> courses;就是这里有疑问\n\npublic Student(String id, String name) {\n    this.id = id;\n    this.name = name;\n    this.courses = new HashSet<Course>();\n}\n", "\n\n", "}", "\n\n", "package com.imooc.collection;", "\n\n", "/**", "\n\n", "\n", "课程类", "\n", "\n", "@author Administrator", "\n*", "\n*/", "\npublic class Course {", "\n\n", "public String id;", "\n\n", "public String name;", "\n\n", "public Course(String id, String name) {", "\n    this.id = id ;", "\n\n", "this.name = name;\n", "\n\n", "}", "\n\n", "public Course() {", "\n\n", "}", "\n}", "\n为什么在student类中定义的时候，public Set courses; set中的菱形括号", "\n可以写Course类？？菱形括号里面不是只能写类型么？", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;该回答引用NewBing&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;您好&amp;#xff0c;您可以使用Java的Map集合接口来定义单词库。Map是一种键值对的数据结构&amp;#xff0c;可以将键映射到值。例如&amp;#xff0c;您可以使用Map&amp;lt;String, Integer&amp;gt;来定义一个单词库&amp;#xff0c;其中String是单词&amp;#xff0c;Integer是单词出现的次数。下面是一个简单的例子&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.util.HashMap;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.util.Map;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;WordCount&lt;/span&gt; {\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; input &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;hello world hello world hello world&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] words &amp;#61; input.&lt;span class=\"hljs-built_in\"&gt;split&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;);\n        Map&amp;lt;&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;, Integer&amp;gt; wordCount &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;word&lt;/span&gt; : words) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (wordCount.&lt;span class=\"hljs-built_in\"&gt;containsKey&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;word&lt;/span&gt;)) {\n                wordCount.&lt;span class=\"hljs-built_in\"&gt;put&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;word&lt;/span&gt;, wordCount.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;word&lt;/span&gt;) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                wordCount.&lt;span class=\"hljs-built_in\"&gt;put&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;word&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            }\n        }\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(wordCount);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个例子将输入字符串分割成单词&amp;#xff0c;并使用Map来计算每个单词出现的次数。输出将是&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-attribute\"&gt;world&lt;/span&gt;&amp;#61;3, &lt;span class=\"hljs-attribute\"&gt;hello&lt;/span&gt;&amp;#61;3}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;关于Scanner类&amp;#xff0c;您可以使用它来读取用户输入。下面是一个简单的例子&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.util.Scanner;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ScannerExample&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(String[] args)&lt;/span&gt; {\n        &lt;span class=\"hljs-type\"&gt;Scanner&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;scanner&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Scanner&lt;/span&gt;(System.in);\n        System.out.print(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个整数&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;num&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; scanner.nextInt();\n        System.out.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;您输入的整数是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;#43; num);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个例子将提示用户输入一个整数&amp;#xff0c;并使用Scanner类读取用户输入。输出将是&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;请输入一个整数&amp;#xff1a;42\n您输入的整数是&amp;#xff1a;42\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;源: 与必应的对话&amp;#xff0c; 2023/4/19&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;&lt;p&gt;(1) Java Map集合接口及泛型应用_老蛙&lt;a type=\"user\" class=\"md_call_user\"&gt;&amp;#64;的博客-CSDN博客. &lt;/a&gt;&lt;a href=\"https://blog.csdn.net/m0_48468380/article/details/107876632\" id=\"textarea_1681914841907_1681915003804_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/m0_48468380/article/details/107876632&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;(2) Java Map 泛型简述 - CSDN博客. &lt;a href=\"https://blog.csdn.net/qq_43382750/article/details/118859807\" id=\"textarea_1681914841907_1681915003804_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_43382750/article/details/118859807&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;(3) Java 泛型 | 菜鸟教程. &lt;a href=\"https://www.runoob.com/java/java-generics.html\" id=\"textarea_1681914841907_1681915003804_2\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://www.runoob.com/java/java-generics.html&lt;/span&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA的Map和泛型的应用", ["如何使用Map定义单词库？如何使用Scancer定义输入流？并且接受判断？", "我分别用了Map和Scancer去定义，但是最后出的结果不能把二者串联起来"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;使用Iterator遍历的是list集合&amp;#xff0c;而不是addAll2方法里的可变长度参数e&amp;#xff0c;使用for-each来遍历可变长度参数e&amp;#xff0c;然后把它逐一添加到list即可。修改如下&amp;#xff1a;&lt;br /&gt;参考链接&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/qq_38038472/article/details/110058942\" id=\"textarea_1662376750871_1662376774142_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;Java中方法参数后面“...“的理解_ID_云泽的博客-CSDN博客_java 参数...&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.util.ArrayList;\n&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.util.Iterator;\n \n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ListUtil&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;  &lt;span class=\"hljs-title function_\"&gt;ListUtil&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; {\n \n \n    }\n    &lt;span class=\"hljs-comment\"&gt;//泛型修饰符要写在修饰类之后&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt;&amp;lt;E&amp;gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;addAll&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(ArrayList&amp;lt;E&amp;gt; list,E e1,E e2)&lt;/span&gt;{\n            list.add(e1);\n            list.add(e2);\n    }\n    &lt;span class=\"hljs-comment\"&gt;//在调用方法时可以添加任意个元素&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt;&amp;lt;E&amp;gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;addAll2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(ArrayList&amp;lt;E&amp;gt; list,E...e)&lt;/span&gt;{\n            &lt;span class=\"hljs-comment\"&gt;//e的底层是一个数组&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//1.for遍历&lt;/span&gt;\n       &lt;span class=\"hljs-comment\"&gt;/* for (int i &amp;#61; 0; i &amp;lt; e.length; i&amp;#43;&amp;#43;) {\n            list.add(e[i]);\n        }*/&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//2.增强for遍历&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;/*for (E tempEle : e) {\n            list.add(tempEle);\n        }*/&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//3.迭代器遍历&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//       Iterator&amp;lt;E&amp;gt; it &amp;#61; list.iterator();&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//        while(it.hasNext()){&lt;!-- --&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//             E e1&amp;#61; it.next();&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//             list.add((E)e1);&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//        }&lt;/span&gt;\n        \n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(E s:e) {\n            list.add(s);\n        }\n        \n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(String[] args)&lt;/span&gt; {\n        ArrayList&amp;lt;String&amp;gt; list1&amp;#61;&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\n        ListUtil.addAll2(list1,&lt;span class=\"hljs-string\"&gt;&amp;#34;nihao&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zixiangpeng&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;zhangsan&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;王五&amp;#34;&lt;/span&gt;);\n        System.out.println(list1);\n \n \n \n    }\n \n}\n\n\n \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/422617673266124.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["练习泛型修饰符时构建ListUtil工具类使用迭代器方法遍历失败", ["问题遇到的现象和发生背景", "\n", "练习泛型修饰符时构建ListUtil工具类使用迭代器方法遍历失败", "\n", "问题相关代码，请勿粘贴截图", "\n", "工具类", "\n", "package", " A02_genericDemo2;\n\n", "import", " java.util.ArrayList;\n", "import", " java.util.Iterator;\n\n", "public", " ", "class", " ", "ListUtil", " {\n    ", "private", "  ", "ListUtil", "()", " {\n\n\n    }\n    ", "//泛型修饰符要写在修饰类之后", "\n    ", "public", " ", "static", "<E> ", "void", " ", "addAll", "(ArrayList<E> list,E e1,E e2)", "{\n            list.add(e1);\n            list.add(e2);\n    }\n    ", "//在调用方法时可以添加任意个元素", "\n    ", "public", " ", "static", "<E> ", "void", " ", "addAll2", "(ArrayList<E> list,E...e)", "{\n            ", "//e的底层是一个数组", "\n        ", "//1.for遍历", "\n       ", "/* for (int i = 0; i < e.length; i++) {\n            list.add(e[i]);\n        }*/", "\n        ", "//2.增强for遍历", "\n        ", "/*for (E tempEle : e) {\n            list.add(tempEle);\n        }*/", "\n        ", "//3.迭代器遍历", "\n       Iterator<E> it = list.iterator();\n        ", "while", "(it.hasNext()){\n             E e1= it.next();\n             list.add((E)e1);\n        }\n    }\n\n}\n\n\n", "\n", "测试类", "\n", "package", " A02_genericDemo2;\n", "import", " java.util.ArrayList;\n", "import", " java.util.Iterator;\n\n", "public", " ", "class", " ", "Test01", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " {\n        ArrayList<String> list1=", "new", " ", "ArrayList", "<>();\n        ListUtil.addAll2(list1,", "\"nihao\"", ",", "\"zixiangpeng\"", ",", "\"zhangsan\"", ",", "\"王五\"", ");\n        System.out.println(list1);\n\n\n\n    }\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里使用的get方法是继承Arraylist的&amp;#xff0c;返回值是泛型E&amp;#xff0c;跟你这里定义的E不是一个E&amp;#xff0c;所以你获取value时要做一个强转&lt;br /&gt;下面if判断时你也给get做个强转试一下&lt;br /&gt;最后的add方法用的也是继承来的&amp;#xff0c;你传入的value时你当前的泛型E&amp;#xff0c;跟方法需要的E不是一个E&amp;#xff0c;所以报错类型错误&lt;br /&gt;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&lt;br /&gt;你想在添加到集合时进行排序&amp;#xff0c;首先集合工具类本身有排序方法&amp;#xff0c;直接写个方法实现先添加和排序即可&amp;#xff0c;不用自己继承再重写&lt;br /&gt;其次&amp;#xff0c;如果你非要自己重写&amp;#xff0c;应该考虑下装饰者模式的使用&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型类，数据类型一直报错，但提示的类型一样，恳请各位帮助解答！", ["我定义了一个泛型类SortedArrayList继承Arraylist，想定义一个方法：当add对象到arraylist集合中时进行排序，但是运用get方法时数据类型一直报错，请问各位我这个问题改如何解决？衷心感谢各位的帮助！能有效解决问题必采纳！"]], "Tag": "程序设计"}
{"Answer": "我后来查了下，泛型里面需要什么就约束什么值便可，比如是‘List&lt;对象&gt;’，就约束成HibernateCallBack&lt;List&lt;对象&gt;&gt;便可", "Konwledge_Point": "泛型机制——模板", "Question": ["ssh中做查询应该怎样约束HibernateCallback<>泛型里的值", ["下面这段代码是错的，我想知道怎么去约束HibernateCallback<>泛型里的值，或者告诉我另外一种方法（需要分页查询）", "\npublic List selectBookByPrice(final int pageNo,final int pageNum) {", "\n        List list = null;", "\n        HibernateCallback> callback = new HibernateCallback>() {", "\n            List list = null;", "\n            @Override", "\n            public List doInHibernate(Session session) throws HibernateException {", "\n                //当前页码初始下标", "\n                int minResult = (pageNo-1)*pageNum;", "\n                String hql = \"from Book order by bookPrice\";", "\n                //分页查询", "\n                Query q = session.createQuery(hql);", "\n                q.setFirstResult(minResult);", "\n                q.setMaxResults(pageNum);", "\n                list = q.list();", "\n                return list;", "\n            }", "\n        };", "\n        list=this.getHibernateTemplate().execute(callback);", "\n        return list;", "\n    }"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt; 泛型为&amp;lt;? super Number&amp;gt; &amp;#xff0c;自然只能接收Number及其超类&lt;/li&gt;&lt;li&gt;泛型为&amp;lt;? super T&amp;gt;&amp;#xff0c;自然只能接收T及其超类&amp;#xff0c;至于你的调用new &amp;lt;Number&amp;gt;bbb()&amp;#xff0c;这个一般叫做泛型构造方法&amp;#xff0c;和你后面fun的传参有什么关系呢&amp;#xff1f;说白了&amp;#xff0c;你没有用到类的泛型定义&amp;lt;? super T&amp;gt;&amp;#xff0c;你用的是构造方法的泛型&amp;#xff0c;我想你应该是想写new bbb&amp;lt;Number&amp;gt;().fun(xxxxx)?&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java 泛型 理解，这是什么原因", ["    ", "public", " ", "static", " ", "class", " ", "aaa", "   {\n        ", "public", "  ", "void", " ", "fun", "(", "List<? ", "super", " ", "Number", "> b", ") {\n        }\n    }\n    ", "public", " ", "static", " ", "class", " ", "bbb", "<T>   {\n        ", "public", "  ", "void", " ", "fun", "(", "List<? ", "super", " T> b", ") {\n        }\n    }\n\n    ", "public", " ", "static", " ", "void", " ", "test", "(", ") {\n       ", "// 这里传入子类报错 可以理解", "\n        ", "new", " ", "aaa", "().", "fun", "(", "new", " ", "ArrayList", "<", "Integer", ">());\n       ", "// 这里传入子类  为什么没有报错", "\n        ", "new", " <", "Number", ">", "bbb", "().", "fun", "(", "new", " ", "ArrayList", "<", "Integer", ">());\n    }\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;泛型使用不当&amp;#xff1a;&lt;br /&gt;前面泛型声明中&amp;#xff0c;  ,表明 T 的类型是 Comparable 的子类&amp;#xff0c;&lt;br /&gt;实际使用的时候&amp;#xff0c;传递的参数类型是 int[] a &amp;#xff0c;这个 int 类型&amp;#xff0c;是原始类型。&lt;br /&gt;原始类型 不具备对象属性&amp;#xff0c;不继承和实现任何类和接口。&lt;br /&gt;楼主可以换成 原始类型 的&lt;strong&gt;封装类型&lt;/strong&gt; 试一试。&lt;br /&gt;比如: Integer[] a;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java 排序 泛型 为什么会报错？", ["package", " com.homework;\n", "import", " java.util.Scanner;\n", "public", " ", "class", " experiment13_1{  \n  ", "public", " ", "static", " ", "void", " main(String[] args) {\n        Scanner scan= ", "new", " Scanner(System.in);\n        System.out.", "println", "(", "\"请分别输入x、y：\"", ");\n        ", "int", " x=scan.nextInt(); \n       ", "int", " y=scan.nextInt();  \n      System.out.", "println", "(", "\"最大值为：\"", "+max(x,y));  \n      ", "int", "[] a={", "3", ",", "2", ",", "4", ",", "8", ",", "9", ",", "10", ",", "7", "};        ", "int", "[] arr=", "sort", "(a);    }\n    ", "public", " ", "static", " <T ", "extends", " Comparable> T max(T x,T y){", "//最大值        ", "\n", "if", "(x.", "compareTo", "(y)>", "0", ") \n           ", "return", " x;  \n      ", "else", " \n           ", "return", " y;   \n }  \n  ", "public", " ", "static", " <T ", "extends", " Comparable> T[] ", "sort", "(T[] x){", "//排序 ", "\n       ", "int", " k=x.length; \n       ", "for", "(", "int", " i=", "0", ";i<k;i++){  \n          ", "for", "(", "int", " j=", "0", ";j<i-", "2", ";j++){ \n               ", "if", "(x[j].", "compareTo", "(x[j+", "1", "])>", "0", "){       \n             T temp=x[j];    \n                x[j]=x[j+", "1", "];         \n           x[j+", "1", "]=temp;          \n      }        \n    }     \n   }     \n   ", "return", " x;    \n}}\n", "\n", "为什么MAX（x， y）不报错，而sort（a）报错", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n String[] hua_se &amp;#61; {&amp;#34;黑桃&amp;#34;, &amp;#34;红桃&amp;#34;, &amp;#34;梅花&amp;#34;, &amp;#34;方块&amp;#34;};\n        String[] shu_zi &amp;#61; {&amp;#34;A&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;4&amp;#34;,&amp;#34;5&amp;#34;,&amp;#34;6&amp;#34;, &amp;#34;7&amp;#34;,&amp;#34;8&amp;#34;,&amp;#34;9&amp;#34; ,&amp;#34;10&amp;#34;,&amp;#34;J&amp;#34;,&amp;#34;Q&amp;#34;,&amp;#34;K&amp;#34;};\n        List&amp;lt;String&amp;gt; paiList &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span class=\"hljs-number\"&gt;54&lt;/span&gt;);\n        paiList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(&amp;#34;大王&amp;#34;);\n        paiList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(&amp;#34;小王&amp;#34;);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (String s : shu_zi) {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (String s1 : hua_se) {\n                paiList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(s1&amp;#43;s);\n            }\n        }\n        Collections.shuffle(paiList);\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;洗牌后&amp;#xff1a;&amp;#34;&amp;#43;paiList);\n        List&amp;lt;String&amp;gt; player_1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;);\n        List&amp;lt;String&amp;gt; player_2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;);\n        List&amp;lt;String&amp;gt; player_3 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span class=\"hljs-number\"&gt;17&lt;/span&gt;);\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (i&amp;lt;&lt;span class=\"hljs-number\"&gt;51&lt;/span&gt;){\n            player_1.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(paiList.&lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;(i&amp;#43;&amp;#43;));\n            player_2.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(paiList.&lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;(i&amp;#43;&amp;#43;));\n            player_3.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(paiList.&lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;(i&amp;#43;&amp;#43;));\n        }\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;玩家1&amp;#xff1a;&amp;#34;&amp;#43;player_1);\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;玩家2&amp;#xff1a;&amp;#34;&amp;#43;player_2);\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;玩家3&amp;#xff1a;&amp;#34;&amp;#43;player_3);\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;底牌&amp;#xff1a;&amp;#34;&amp;#43;paiList.subList(&lt;span class=\"hljs-number\"&gt;51&lt;/span&gt;,paiList.size()));\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["java集合及泛型的使用问题解决", ["1、在main方法中运用ArrayList实现三人斗地主游戏中的发牌功能，具体如下：", "(1) 创建两个String类型数组，其中一个用于存储牌的花色（\"黑桃\", \"红桃\", \"梅花\", \"方块\"四种花色），一个用于存储牌的数字（\"A\", \"2\", \"3\", \"4\",...\"K\"十三种数字）；", "(2) 创建一个ArrayList集合作为牌盒，先将不同花色不同数字的牌循环添加到集合中,最后别忘了将”大王”,”小王”也添加到ArrayList集合中；", "(3) 用Collections工具类的shuffle()方法洗牌。", "如：Collections.shuffle(al)      //al为一集合对象，该方法用于打乱al中元素的顺序", "(4) 创建三个ArrayList集合作为三个人的牌的集合，并循环发牌，共发51张牌，留三张底牌；", "(5) 打印出三个人的牌和集合中留的三张底牌。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;要看Basket的构造函数&amp;#xff0c;内部代码是怎么处理的。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["构造方法中的泛型约束失效问题", ["    ", "@Test", "\n    ", "public", " ", "void", " ", "testRaw", "(", ") {\n        ", "Fruit", "<", "String", "> fruit = ", "new", " ", "Fruit", "<>();\n        ", "Basket", "<", "Integer", "> basket = ", "new", " ", "Basket", "(fruit); ", "// 不报错！", "\n        basket.", "setFruit", "(fruit); ", "// 报错: required type Fruit<Integer>   ", "\n    }\n\n    ", "private", " ", "static", " ", "class", " ", "Basket", "<V> {\n        ", "public", " ", "Basket", "(", "Fruit", "<V> f) {\n        }\n\n        ", "public", " ", "void", " ", "setFruit", "(", "Fruit<V> f", ") {\n        }\n    }\n\n    ", "private", " ", "static", " ", "class", " ", "Fruit", "<R> {\n    }\n\n", "\n", "Basket的构造方法传入的不匹配类型不报错，下面的setFruit方法会报错，这是什么原因？"]], "Tag": "程序设计"}
{"Answer": "```\r\nMap&lt;String,String&gt;接收到了mybatis查询的数据,其实并没有,泛型在这里没卵用,实际上这个map可能是Map&lt;String,Double&gt;....等等\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["Map<String,String>接收到了mybatis查询的数据，并且能够获取到里面的int类型的值", ["Map《String,String》接收到了mybatis查询的数据，并且能够获取到里面的int类型的值，但是controller返回时报错Could not write JSON: java.lang.Integer cannot be cast to java.lang.String;", "\n改成Map《String,Obect》就可以成功返回，我想知道为什么会这样？", "\n我已经获取到数据了，map里面都是string为什么还要int转String", "\n,实际上我知道Map《String,Object》 就能解决，我不明白的是为什么能够得到数据，却用不了，我用的时候需要用这个Map《string ,String》get到，用Object接收，然后再把Object转换为String"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;List&amp;lt;String&amp;gt; list &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; new ArrayList&amp;lt;&amp;gt;()&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n        list.add(&lt;span class=\"hljs-string\"&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n        list.add(&lt;span class=\"hljs-string\"&gt;&amp;#34;bcd&amp;#34;&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定义这个集合&amp;#xff0c;然后遍历集合将其转为字符串&amp;#xff0c;并将字符串转为字符数组&amp;#xff0c;判断每个字符个数。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["定义一个泛型为String类型的List集合，统计该集合中每个字符出现的次数。", ["问题遇到的现象和发生背景", "\n", "定义一个泛型为String类型的List集合，统计该集合中每个字符出现的次数。", "\n", "例如：集合中有”abcbcd”两个元素，程序最终输出格式为：“a = 1,b = 2,c = 2,d = 1”"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://ask.csdn.net/questions/7452756\"&gt;https://ask.csdn.net/questions/7452756&lt;/a&gt;&amp;#xff0c;题目变了了&amp;#xff1f;写21题的&amp;#xff1f;帮助到你可以点个&lt;u&gt;&lt;strong&gt;采纳&lt;/strong&gt;&lt;/u&gt;吗 &amp;#xff0c;谢谢~&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"107\" src=\"https://img-ask.csdnimg.cn/upload/1624007177869.png\" width=\"203\" /&gt;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;using System;\nusing System.Collections.Generic;\nnamespace ConsoleApp1\n{\n    class A\n    {\n        int x, y;\n        public A(int x,int y) { this.x &amp;#61; x;this.y &amp;#61; y; }\n        public void Show() { Console.WriteLine(&amp;#34;{0},{1}&amp;#34;, x, y); }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List&amp;lt;A&amp;gt; list &amp;#61; new List&amp;lt;A&amp;gt;();\n            list.Add(new A(0, 0));\n            list.Add(new A(1, 1));\n            list.Add(new A(2, 2));\n\n            foreach (A a in list) a.Show();\n\n\n            Console.WriteLine(&amp;#34;请按任意键继续...&amp;#34;);\n            Console.ReadKey();\n        }\n    }\n}&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["C#控制台程序（泛型的应用）", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "s1,s2：他的值是final的 所以是不可以改变的。在方法中又重新创建了String对象，方法里的s1,s2是局部变量。当方法执行完成之后，方法内的s1 s2也就消失了。\r\nsb1,sb2：他底层实际是对char数组进行操作的。通过change方法把sb1和sb2的地址传过来，在change方法中sb1=sb2只是把局部变量sb1的地址改变了，当方法执行完成change中的局部变量sb1也就消失了。\r\nsb2.append(sb1)：append返回的是return this,拼接之后的对象还是原对象，虽然change方法执行完成之后局部变量sb2消失了，但是堆内存中的对象数据被改变了。\r\n![图片说明](https://img-ask.csdn.net/upload/201712/08/1512697118_358458.png)", "Konwledge_Point": "泛型机制——模板", "Question": ["java 关于值传递 引用传递的问题 大神详细解释一下 谢谢", ["下图 这个java 关于值传递 引用传递的问题 大神详细解释一下 为什么会是这样 谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;写好了 加q发你&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["想问一个关于利用Java泛型的问题？", ["我现在有一个Date类和一个Transaction类 实现了接口Transactions里的formatString()方法，功能是在初始化的时候接收格式化字符串，我现在想实现一个静态方法makeList()，接受一个字符串数组ss，用ss里面每一个字符串s构造一个实现了Transations接口的对象，所有对象用一个ArrayList盛装并返回，通过指定泛型的方式确定这个ArrayList里装的是Date的对象还是Transaction的对象 请问怎么实现", "\n\n", "接口这样定义：", "\n\n", "\n", "public interface Transactions {\n    void formatString(String s);\n}", "\n\n", "Date类的实现：", "\n\n", "\n", "public class Date implements Transactions{\n    /** 储存天 **/\n    private int day;\n    /** 储存月 **/\n    private int month;\n    /** 储存年 **/\n    private int year;\n    \n     /**\n     * 当传入日期的格式化字符串时调用此构造函数，格式\"y-m-d\"\n     * @param date String: 日期的格式化字符串，以\"-\"分隔\n     * **/\n    public Date(String date){\n        this.formatString(date);\n    }\n\n    @Override\n    public void formatString(String date) {\n        String[] d = date.split(\"-\");\n        this.day = Integer.parseInt(d[2]);\n        this.month = Integer.parseInt(d[1]);\n        this.year = Integer.parseInt(d[0]);\n    }\n}", "\n\n", "Transaction类的实现：", "\n\n", "\n", "public class Transaction implements Comparable<Transaction>, Transactions{\n    /** 交易人 **/\n    private String who;\n    /** 交易日期 **/\n    private Date when;\n    /** 交易金额 **/\n    private double amount;\n\n     /**\n     * 当传入交易信息的格式化字符串时调用此构造函数，格式\"when:amount@who\"\n     * @param transaction String: 交易信息的格式化字符串\n     * **/\n    public Transaction(String transaction){\n        this.formatString(transaction);\n    }\n   \n    @Override\n    public void formatString(String transaction) {\n        String[] t = transaction.split(\"[:@]\");\n        this.who = t[2];\n        this.when = new Date(t[0]);\n        this.amount = Double.parseDouble(t[1]);\n    }\n}"]], "Tag": "程序设计"}
{"Answer": "int[] arr={1,23,4,6,7};\r\n-&gt;\r\nObject[] arr={1,23,4,6,7};\r\n\r\nhttp://blog.csdn.net/orzlzro/article/details/7017435\r\n&gt;Java不支持声明泛型数组，更确切地表达是：数组的类型不可以是类型变量，除非是采用通配符的方式", "Konwledge_Point": "泛型机制——模板", "Question": ["Java中关于泛型的问题，谢谢了", ["public class FanXing {", "\n    public static  void main(String[] args) {", "\n            int[] arr={1,23,4,6,7};", "\n        reverse(arr);//这里提示报错，怎么回事，调用不了", "\n    }", "\n\n", "public static <T> void reverse(T[] arr){\n    for(int startIndex=0,endIndex=arr.length-1;startIndex<endIndex;startIndex++,endIndex--){\n        T temp=arr[startIndex];\n        arr[startIndex]=arr[endIndex];\n        arr[endIndex]=temp;\n    }\n    System.out.println(Arrays.toString(arr));\n}\n", "\n\n", "}", "\n\n", "    reverse(arr);//这里提示报错，怎么回事，调用不了   求帮忙，谢谢各位了\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个你定义2个类&amp;#xff0c;Person1类&amp;#xff0c;拥有姓名性别年龄三个字段&lt;br /&gt;Person2类&amp;#xff0c;拥有姓名电话字段&lt;br /&gt;然后排序算法 T 代表任意类型&lt;/p&gt;\n&lt;p&gt;找了一个类似的例子&amp;#xff0c;你看下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person1&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; gender;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Person1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name, &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; gender, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.name &amp;#61; name;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.gender &amp;#61; gender;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.age &amp;#61; age;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getName&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; name;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getGender&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; gender;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getAge&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; age;\n    }\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person2&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; phone;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Person2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name, &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; phone)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.name &amp;#61; name;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.phone &amp;#61; phone;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getName&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; name;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getPhone&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; phone;\n    }\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Sorter&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; interface Selector&amp;lt;T&amp;gt; {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;compare&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(T obj1, T obj2)&lt;/span&gt;&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(T[] data, Selector&amp;lt;T&amp;gt; selector)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len &amp;#61; data.length;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-type\"&gt;boolean&lt;/span&gt; flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; - i; j&amp;#43;&amp;#43;) {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (selector.&lt;span class=\"hljs-built_in\"&gt;compare&lt;/span&gt;(data[j], data[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n                    T temp &amp;#61; data[j];\n                    data[j] &amp;#61; data[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                    data[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; temp;\n                    flag &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n                }\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (flag) {\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;调用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;Person1&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; persons1 &amp;#61; {\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person1(&lt;span class=\"hljs-string\"&gt;&amp;#34;Amy&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Female&amp;#34;&lt;/span&gt;, 25)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person1(&lt;span class=\"hljs-string\"&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Male&amp;#34;&lt;/span&gt;, 30)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person1(&lt;span class=\"hljs-string\"&gt;&amp;#34;Charlie&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Male&amp;#34;&lt;/span&gt;, 20)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person1(&lt;span class=\"hljs-string\"&gt;&amp;#34;David&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Male&amp;#34;&lt;/span&gt;, 35)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person1(&lt;span class=\"hljs-string\"&gt;&amp;#34;Emily&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Female&amp;#34;&lt;/span&gt;, 28)&lt;/span&gt;\n};\n&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Sorter&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sort(persons1, &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Sorter.Selector&amp;lt;Person1&amp;gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt; {\n    public &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; compare(Person1 obj1, Person1 obj2) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (obj1.get&lt;span class=\"hljs-constructor\"&gt;Age()&lt;/span&gt; &amp;gt; obj2.get&lt;span class=\"hljs-constructor\"&gt;Age()&lt;/span&gt;) {\n            return &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (obj1.get&lt;span class=\"hljs-constructor\"&gt;Age()&lt;/span&gt; &amp;lt; obj2.get&lt;span class=\"hljs-constructor\"&gt;Age()&lt;/span&gt;) {\n            return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n    }\n});\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (Person1 p : persons1) {\n    &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(p.get&lt;span class=\"hljs-constructor\"&gt;Name()&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;#43; p.get&lt;span class=\"hljs-constructor\"&gt;Gender()&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;#43; p.get&lt;span class=\"hljs-constructor\"&gt;Age()&lt;/span&gt;);\n}\n&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n\nPerson2&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; persons2 &amp;#61; {\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person2(&lt;span class=\"hljs-string\"&gt;&amp;#34;Amy&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;123456&amp;#34;&lt;/span&gt;)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person2(&lt;span class=\"hljs-string\"&gt;&amp;#34;Bob&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;234567&amp;#34;&lt;/span&gt;)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person2(&lt;span class=\"hljs-string\"&gt;&amp;#34;Charlie&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;345678&amp;#34;&lt;/span&gt;)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person2(&lt;span class=\"hljs-string\"&gt;&amp;#34;David&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;456789&amp;#34;&lt;/span&gt;)&lt;/span&gt;,\n        &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Person2(&lt;span class=\"hljs-string\"&gt;&amp;#34;Emily&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;567890&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n};\n&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Sorter&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;sort(persons2, &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Sorter.Selector&amp;lt;Person2&amp;gt;&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt; {\n    public &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; compare(Person2 obj1, Person2 obj2) {\n        return obj1.get&lt;span class=\"hljs-constructor\"&gt;Name()&lt;/span&gt;.compare&lt;span class=\"hljs-constructor\"&gt;To(&lt;span class=\"hljs-params\"&gt;obj2&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getName&lt;/span&gt;()&lt;/span&gt;);\n    }\n});\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (Person2 p : persons2) {\n    &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(p.get&lt;span class=\"hljs-constructor\"&gt;Name()&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;#43; p.get&lt;span class=\"hljs-constructor\"&gt;Phone()&lt;/span&gt;);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型的实际应用，该怎么敲？", ["这用泛型该怎么做？不太懂泛型的实际应用，要是用了泛型，该怎么定义数组存储？成员变量又该怎么处理？望代码", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Go is a strongly typed language. So, it's not possible the way, it is possible with, say python. But just like python, once you do this, you loose the benefit of compile time error checks, and your runtime error checking has to be full-proof.\nHere's what you can do:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use &lt;code&gt;map[string]interface{}&lt;/code&gt; type for your function map&lt;/strong&gt;, which enables you to store anything. But then you are responsible to correctly type assertion at the time of calling. Problem is that, in most cases, if while calling a function, you could know the type of function, may be you might not need a map in the first place.&lt;/p&gt;&lt;/li&gt;\n&lt;li&gt;&lt;p&gt;&lt;strong&gt;Use a &lt;code&gt;map[string]string&lt;/code&gt; or &lt;code&gt;map[string]interface{}&lt;/code&gt; as the argument&lt;/strong&gt;, and return type in all the functions that are supposed to go into this map. Or at least put all the variable arguments into this map.&lt;/p&gt;\n\n&lt;p&gt;eg.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;map[string](func (name string, age int, other_attributes\nmap[string]interface{}) (map[string]interface{}, error))&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;But again, each function call should provide the correct arguments, and there should also be checks inside the functions, to see (with non-panic version of map lookup), if the parameters are correctly provided, if not, you can return a custom error like ErrInvalidParametersPassed. (playing the role of an interpreter). But you will still have lesser chances of messing up, compared to first option. As the &lt;code&gt;burden of type assertion&lt;/code&gt; will be on the function implementation, and not the caller. Caller just needs to fetch it's required values, which it anyways needs to know about.&lt;/p&gt;\n\n&lt;p&gt;But yet, best option would be to redesign your actual solution in a way, so that it can be done without going this road. As @bereal suggested in comments, it's good to have separate maps if possible, or maybe use a superset of arguments if they aren't too different, or too many. If there are just a few arguments, even switch case could be clean enough. Look for ways that cheat/bypass compile time checks, when you are truly convinced that there is no other elegant way.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["映射以在Go中存储泛型类型函数", ["\n\n", "I am trying to create a Map with String and functions as key and Value. It works if all functions are of same signature but my requirement is to store functions of different signature in the same map. Is this possible in Go?", "\n\n", "package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    functions := buildFunctions()\n    f := functions[\"isInValid\"]\n\n    //  f(\"hello\")\n\n}\n\nfunc buildFunctions() map[string]func() bool {\n\n    functions := map[string]func() bool{\n        \"isInValid\":   isInValid,\n        \"isAvailable\": isAvailable,\n    }\n    return functions\n}\n\nfunc isInValid(s string) bool {\n    fmt.Println(\"Invalid \", s)\n    return true\n}\n\nfunc isAvailable(s string, s1 string) bool {\n    return true\n}\n", "\n\n", "https://play.golang.org/p/ocwCgEpa_0G", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;builder 方法的返回值类型为&lt;code class=\"language-javascript\"&gt;MySqlSource.&amp;lt;String&amp;gt;&lt;/code&gt;&amp;#xff0c; String 为 MySqlSource中的元素类型&amp;#xff0c;MySqlSource.类的定义应该为 &lt;code class=\"language-javascript\"&gt;MySqlSource&amp;lt;T&amp;gt;&lt;/code&gt;&amp;#xff0c;这里的T就是泛型&amp;#xff0c; String为T的一个具体类型&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java语法问题，这是不是与泛型有关呀", ["在Flink CDC中MySqlSource.<String>builder()中<String>是什么意思，这句话代表什么意思呀，与泛型有关吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这样&amp;#xff1f;&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"167\" src=\"https://img-ask.csdnimg.cn/upload/1624005123386.png\" width=\"429\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;帮助到你能点个&lt;u&gt;&lt;strong&gt;采纳&lt;/strong&gt;&lt;/u&gt;吗&amp;#xff0c;谢谢~&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;using System;\nusing System.Collections.Generic;\nnamespace ConsoleApp1\n{\n    class MyGen&amp;lt;T&amp;gt;\n    {\n        List&amp;lt;T&amp;gt; list &amp;#61; new List&amp;lt;T&amp;gt;();\n        public void add(T t)\n        {\n            list.Add(t);\n        }\n        public void Displist()\n        {\n            foreach (var item in list)\n                Console.Write(item&amp;#43;&amp;#34; &amp;#34;);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MyGen&amp;lt;int&amp;gt; obj1 &amp;#61; new MyGen&amp;lt;int&amp;gt;();\n            Console.WriteLine(&amp;#34;向obj1对象中添加3个整数&amp;#34;);\n            obj1.add(1);\n            obj1.add(2);\n            obj1.add(3);\n            Console.Write(&amp;#34;obj1对象中的元素&amp;#xff1a;&amp;#34;);\n            obj1.Displist();\n\n            Console.WriteLine();\n\n            MyGen&amp;lt;string&amp;gt; obj2 &amp;#61; new MyGen&amp;lt;string&amp;gt;();\n            Console.WriteLine(&amp;#34;向obj2对象中添加4个字符串&amp;#34;);\n            obj2.add(&amp;#34;C&amp;#43;&amp;#43;&amp;#34;);\n            obj2.add(&amp;#34;Java&amp;#34;);\n            obj2.add(&amp;#34;VB&amp;#34;);\n            obj2.add(&amp;#34;C#&amp;#34;);\n            Console.Write(&amp;#34;obj2对象中的元素&amp;#xff1a;&amp;#34;);\n            obj2.Displist();\n\n            Console.ReadKey();\n        }\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["C#控制台应用程序（泛型应用与设计）", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "挺不错嘛，元旦还怎么刻苦，当然是可以的，你想要明白Map值怎么用的，反过来写意思就不一样了。\r\n\r\n\r\n```\r\n Map&lt;String,Object&gt; 表示 name是String 类型，Object是value的类型\r\n Map&lt;Object,String&gt; 表示 name是Object 类型，String是value的类型\r\n```\r\n你可以参考这个：[http://blog.csdn.net/qq_19558705/article/details/50250121](http://blog.csdn.net/qq_19558705/article/details/50250121 \"\")", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型当中String 和Object之间是什么关系", ["Map里面的参数可以反过来写吗", "\n写成Map "]], "Tag": "程序设计"}
{"Answer": "[quote=\"lifethinker\"]关键是两者的编译器实现不同。上面的程序可以直接在命令行用javac编译通过，所以我估计jdeveloper使用的编译器就是javac。我以前也一直认为eclipse也是直接使用javac编译器，刚才查看了eclipse插件目录下org.eclipse.jdt.core.jar，里面包括词法分析器，语法解析器，编译器，我才确定eclipse使用了自己的编译器。至于netbeans没有研究，应该也是使用了自己的编译器。\r\n\r\np.s. 在Eclipse下如果接口I中不带任何方法或者方法签名中不使用泛型，则不会出错误。\r\n\r\nto feng_gladys:从eclipse提示的错误：\r\nName clash: The method query(Map&lt;String,Object&gt;, int) of type C has the same erasure as query(Map, int) of type I but does not override it\r\n\r\n这样解释也合乎情理，但是从语言规范上来说应该是容许这种情况发生的，不应该有任何错误，至多也只是警告，不过提示错误也未尝不是坏事。\r\n[/quote]\r\n\r\n以下这段话是 The Java Programming Language 中描述overridding的：\r\n\r\nA method in a subtype potentially overrides an accessible method in a super type if the two methods have the same name and have override-equivalent signatures. We say \"potentially overrides\" because there is an additional requirement to be met: The signature of the subclass method must be the same as that of the superclass method, or it must be the same as the erasure of the signature of the superclass method. This constraint makes overriding a \"one-way street\": [b]A method without generic types can override a method with generic types, but not the other way around[/b].", "Konwledge_Point": "泛型机制——模板", "Question": ["关于继承与泛型，谁给解释一下？", ["假设如下代码： ", "\n\n", "public interface I<x> {\n      public void query(Map <string, object=\"\"> map, int count);\n}\npublic class C implements I {\n      public void query(Map <string, object=\"\"> map, int count) {}\n} ", "\n\n", " 以上代码在JDeveloper中能编译通过并运行，但是在Eclipse、NetBeans中不能编译，在Eclipse,NetBeans中需要写成： ", "\n\n", "public class C implements I {\n      public void query(Map map, int count) {}\n} ", "\n\n", " 或者是", "\n\n", "public class C implements I<c> {\n      public void query(Map <string, object=\"\"> map, int count) {}\n} ", "\n\n", " 谁能帮我解释一下，哪个是对的？", "问题补充", "xixix2004 写道", "先看看你后面所说的工具中的JRE版本", "jre均为1.5.0_06"]], "Tag": "程序设计"}
{"Answer": "package com.zw.core;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.List;\r\npublic class BaseDao&lt;T, PK extends Serializable&gt; implements IBaseDao&lt;T, PK&gt; {\r\n\tprotected Class&lt;T&gt; entityClass;// DAO所管理的Entity类型.\r\n@Autowired\t\r\nprivate GenericEntityDao&lt;T, PK&gt; gedao;\r\n\tpublic Class&lt;T&gt; getEntityClass() {\r\n\t\treturn entityClass;\r\n\t}\r\n\tpublic void setEntityClass(Class&lt;T&gt; entityClass) {\r\n\t\tthis.entityClass = entityClass;\r\n\t}\r\n\tpublic GenericEntityDao&lt;T, PK&gt; getGedao() {\r\n\t\treturn gedao;\r\n\t}\r\n\tpublic void setGedao(GenericEntityDao&lt;T, PK&gt; gedao) {\r\n\t\tthis.gedao = gedao;\r\n\t}\r\n\t/**\r\n\t * 让spring提供构造函数注入\r\n\t */\r\n\tpublic BaseDao(Class&lt;T&gt; type) {\r\n\t\tthis.entityClass = type;\r\n\t}\r\n\r\n\tpublic BaseDao() {\r\n\t}\r\n\r\n\tpublic void delete(T entityObject) {\r\n\t\tgedao.delete(entityObject);\r\n\t}\r\n\r\n\tpublic void deleteById(PK id) {\r\n\t\tgedao.deleteById(id);\r\n\t}\r\n\tpublic void evict(T entityObject) {\r\n\t\tgedao.evict(entityObject);\r\n\t}\r\n\tpublic List&lt;T&gt; getAll() {\r\n\t\treturn gedao.getAll();\r\n\t}\r\n\tpublic T getById(PK id) {\r\n\t\treturn gedao.getById(id);\r\n\t}\r\n\tpublic T load(PK id) {\r\n\t\treturn gedao.load(id);\r\n\t}\r\n\tpublic void load(T entityObject, PK id) {\r\n\t\tgedao.load(entityObject, id);\r\n\t}\r\n\tpublic T merge(T entityObject) {\r\n\t\treturn gedao.merge(entityObject);\r\n\t}\r\n\tpublic void refresh(T entityObject) {\r\n\t\tgedao.refresh(entityObject);\r\n\t}\r\n\tpublic void save(T entityObject) {\r\n\t\tSystem.out.println(\"gedao:\"+gedao);\r\n\t\tgedao.save(entityObject);\r\n\t}\r\n\tpublic void clear() {\r\n\t}\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["Spring 3.0+ Hibernate 3.3 泛型 注解管理Bean 出现问题 郁闷!", ["参照网上的Demo 自己也弄了个泛型注解 BaseDao 里面 的gedao 是null 高手们给看一下", "\n[code=\"java\"]package com.zw.core;", "\n\n", "import java.io.Serializable;", "\nimport java.util.List;", "\n\n", "public interface IBaseDao {", "\n    public T getById(PK id);", "\n    public List getAll();", "\n    public T load(PK id);", "\n    public void load(T entityObject, PK id);", "\n    public void delete(T entityObject);", "\n    public void deleteById(PK id);", "\n    public void refresh(T entityObject);", "\n    public void evict(T entityObject);", "\n    public void save(T entityObject);", "\n    public void clear();", "\n\n", "}[/code]", "\n[code=\"java\"]package com.zw.core;", "\n\n", "import java.io.Serializable;", "\nimport java.util.List;", "\npublic class BaseDao implements IBaseDao {", "\n    protected Class entityClass;// DAO所管理的Entity类型.", "\n    private GenericEntityDao gedao;", "\n    public Class getEntityClass() {", "\n        return entityClass;", "\n    }", "\n    public void setEntityClass(Class entityClass) {", "\n        this.entityClass = entityClass;", "\n    }", "\n    public GenericEntityDao getGedao() {", "\n        return gedao;", "\n    }", "\n    public void setGedao(GenericEntityDao gedao) {", "\n        this.gedao = gedao;", "\n    }", "\n    /**", "\n     * 让spring提供构造函数注入", "\n     */", "\n    public BaseDao(Class type) {", "\n        this.entityClass = type;", "\n    }", "\n\n", "public BaseDao() {\n}\n\npublic void delete(T entityObject) {\n    gedao.delete(entityObject);\n}\n\npublic void deleteById(PK id) {\n    gedao.deleteById(id);\n}\npublic void evict(T entityObject) {\n    gedao.evict(entityObject);\n}\npublic List<T> getAll() {\n    return gedao.getAll();\n}\npublic T getById(PK id) {\n    return gedao.getById(id);\n}\npublic T load(PK id) {\n    return gedao.load(id);\n}\npublic void load(T entityObject, PK id) {\n    gedao.load(entityObject, id);\n}\npublic T merge(T entityObject) {\n    return gedao.merge(entityObject);\n}\npublic void refresh(T entityObject) {\n    gedao.refresh(entityObject);\n}\npublic void save(T entityObject) {\n    System.out.println(\"gedao:\"+gedao);\n    gedao.save(entityObject);\n}\npublic void clear() {\n}\n", "\n\n", "}", "\n[/code]", "\n[code=\"java\"]package com.zw.core;", "\n\n", "import java.io.Serializable;", "\nimport java.util.List;", "\n\n", "import org.springframework.orm.hibernate3.support.HibernateDaoSupport;", "\n\n", "public class GenericEntityDao extends HibernateDaoSupport {", "\n\n", "protected Class<T> entityClass;// DAO所管理的Entity类型.\npublic GenericEntityDao() {\n}\n\npublic GenericEntityDao(Class<T> entityClass) {\n    this.entityClass = entityClass;\n}\n@SuppressWarnings(\"unchecked\")\npublic T getById(PK id) {\n    return (T) this.getHibernateTemplate().get(this.entityClass, id);\n}\n@SuppressWarnings(\"unchecked\")\npublic List<T> getAll() {\n    return (List<T>) (this.getHibernateTemplate().loadAll(this.entityClass));\n}\n\n@SuppressWarnings(\"unchecked\")\npublic T load(PK id) {\n    return (T) this.getHibernateTemplate().load(this.entityClass, id);\n}\n\npublic void load(T entityObject, PK id) {\n    this.getHibernateTemplate().load(entityObject, id);\n}\n\npublic void delete(T entityObject) {\n    this.getHibernateTemplate().delete(entityObject);\n}\npublic void deleteById(PK id) {\n    this.delete(this.getById(id));\n}\npublic void refresh(T entityObject) {\n    this.getHibernateTemplate().refresh(entityObject);\n}\n\npublic void evict(T entityObject) {\n    this.getHibernateTemplate().evict(entityObject);\n}\n\npublic void save(T entityObject) {\n\n    this.getHibernateTemplate().saveOrUpdate(entityObject);\n}\n@SuppressWarnings(\"unchecked\")\npublic T merge(T entityObject) {\n    return (T) this.getHibernateTemplate().merge(entityObject);\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "ToplMSoftDAO", "\n[code=\"java\"]package com.zw.dao;", "\n\n", "import org.apache.commons.logging.Log;", "\nimport org.apache.commons.logging.LogFactory;", "\nimport org.springframework.stereotype.Repository;", "\nimport com.zw.core.BaseDao;", "\nimport com.zw.domain.ToplMSoft;", "\n @Repository(\"toplMSoftDAO\")", "\npublic class ToplMSoftDAO  extends BaseDao  {", "\n    private static final Log log = LogFactory.getLog(ToplMSoftDAO.class);", "\n}", "\n[/code]", "\n\n", "[code=\"java\"]", "\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "\n        xmlns:context=\"http://www.springframework.org/schema/context\"", "\n        xmlns:tx=\"http://www.springframework.org/schema/tx\"", "\n        xmlns:aop=\"http://www.springframework.org/schema/aop\"   ", "\n        xsi:schemaLocation=\"", "\n        http://www.springframework.org/schema/tx ", "\n        http://www.springframework.org/schema/tx/spring-tx-3.0.xsd", "\n        http://www.springframework.org/schema/beans", "\n        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd", "\n        http://www.springframework.org/schema/context", "\n        http://www.springframework.org/schema/context/spring-context-3.0.xsd", "\n        http://www.springframework.org/schema/aop ", "\n        http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">", "\n\n", "<!-- 使用外部文件配置数据源的属性 -->", "\n                <!-- 外部文件地址 -->", "classpath:database_conn.properties", "\n\n\n\n", "<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"\n    destroy-method=\"close\">\n    <property name=\"driverClass\" value=\"${driverClassName}\" />\n    <property name=\"jdbcUrl\" value=\"${url}\" />\n    <property name=\"user\" value=\"${username}\" />\n    <property name=\"password\" value=\"${password}\" />\n    <property name=\"minPoolSize\" value=\"5\" />\n    <property name=\"maxPoolSize\" value=\"20\" />\n    <property name=\"initialPoolSize\" value=\"10\" />\n    <property name=\"maxIdleTime\" value=\"60\" />\n    <property name=\"acquireIncrement\" value=\"5\" />\n    <property name=\"maxStatements\" value=\"0\" />\n    <property name=\"idleConnectionTestPeriod\" value=\"60\" />\n    <property name=\"acquireRetryAttempts\" value=\"30\" />\n    <property name=\"breakAfterAcquireFailure\" value=\"true\" />\n    <property name=\"testConnectionOnCheckout\" value=\"false\" />\n</bean>\n<bean id=\"sessionFactory\"\n    class=\"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean\">\n    <!-- 引用数据源 -->\n    <property name=\"dataSource\">\n        <ref bean=\"dataSource\" />\n    </property>\n    <property name=\"namingStrategy\">\n        <bean class=\"org.hibernate.cfg.ImprovedNamingStrategy\" />\n    </property>\n    <property name=\"hibernateProperties\">\n        <props>\n            <prop key=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect\n            </prop>\n            <prop key=\"hibernate.show_sql\">${hibernate.show_sql}</prop>\n            <prop key=\"hibernate.format_sql\">${hibernate.format_sql}</prop>         \n            <prop key=\"hibernate.jdbc.fetch_size\">${hibernate.jdbc.fetch_size}\n            </prop>\n\n            <prop key=\"hibernate.jdbc.batch_size\">${hibernate.jdbc.batch_size}\n            </prop>\n\n        </props>\n     </property>    \n     <property name=\"packagesToScan\" value=\"com.zw.domain\" /> \n\n    <!--</property>     \n    <property name=\"annotatedClasses\">\n        <list>\n            <value>org.wpms.kernel.user.po.User</value>\n        </list>\n    </property>-->\n</bean>\n\n\n\n<!-- 定义了与实体相关的dao -->\n<bean id=\"genericEntityDao\" class=\"com.zw.core.GenericEntityDao\"\n    scope=\"prototype\" lazy-init=\"true\">\n    <property name=\"sessionFactory\">\n        <ref bean=\"sessionFactory\" />\n    </property>\n</bean>\n<!--使用泛型DAO作为抽象基类 abstract=\"true\" -->\n<bean id=\"baseDao\" class=\"com.zw.core.BaseDao\"\n    abstract=\"true\" depends-on=\"genericEntityDao\">\n    <property name=\"gedao\">\n        <ref bean=\"genericEntityDao\" />\n    </property>\n</bean>\n\n     <!-- 使Spring关注Annotation -->\n  <context:annotation-config />\n<!-- 让Spring通过自动扫描来查询和管理Bean -->\n <context:component-scan base-package=\"com.zw\" />\n\n<!--  \n<bean id=\"toplMSoftDAO\" class=\"com.zw.dao.ToplMSoftDAO\" parent=\"baseDao\"></bean>\n<bean id=\"toplMSoftServiceImpl\"\n    class=\"com.zw.service.impl.ToplMSoftServiceImpl\">\n    <property name=\"toplMSoftDAO\" ref=\"toplMSoftDAO\" />\n</bean> \n-->\n<!--\n    业务类bean的实现类标注了@Transactional注解，所以会被 tx:annotation-driven注解驱动自动织入事务增强\n-->\n<!-- 配置事务管理器 -->\n<bean id=\"transactionManager\"\n    class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\">\n    <property name=\"sessionFactory\">\n        <ref bean=\"sessionFactory\" />\n    </property>\n</bean>\n<!--注解式事务配置驱动-->\n<tx:annotation-driven transaction-manager=\"transactionManager\" proxy-target-class=\"true\" />\n</beans>\n", "\n\n", "[/code]", "\nToplMSoft ", "\n[code=\"java\"]", "\npackage com.zw.domain;", "\n\n", "import java.sql.Timestamp;", "\nimport javax.persistence.Column;", "\nimport javax.persistence.Entity;", "\nimport javax.persistence.GeneratedValue;", "\nimport static javax.persistence.GenerationType.IDENTITY;", "\nimport javax.persistence.Id;", "\nimport javax.persistence.Table;", "\n@Entity", "\n@Table(name = \"topl_m_soft\", catalog = \"zwtest\")", "\npublic class ToplMSoft implements java.io.Serializable {", "\n    // Fields", "\n\n", "/**\n * \n */\nprivate static final long serialVersionUID = -5245203859352468180L;\nprivate Integer softkey;\nprivate String softname;\nprivate String softtypekey;\nprivate String softversion;\nprivate String softsize;\nprivate String providername;\nprivate String providersite;\nprivate String downsite1;\nprivate String softfaceurl;\nprivate String issuestate;\nprivate String fruntime;\nprivate String sruntime;\nprivate Float marketprice;\nprivate Float storeprice;\nprivate String ifourcommend;\nprivate String ifspprice;\nprivate String softenglishname;\nprivate String runLink;\nprivate String runnum;\nprivate String downnum;\nprivate String column1;\nprivate String column2;\nprivate String column3;\nprivate String contact;\nprivate Timestamp createdate;\nprivate Timestamp updatedate;\n\n// Constructors\n\n/** default constructor */\npublic ToplMSoft() {\n}\n// Property accessors\n@Id\n@GeneratedValue(strategy = IDENTITY)\n@Column(name = \"softkey\", unique = true, nullable = false)\npublic Integer getSoftkey() {\n    return this.softkey;\n}\n\npublic void setSoftkey(Integer softkey) {\n    this.softkey = softkey;\n}\n\n@Column(name = \"softname\", nullable = false, length = 100)\npublic String getSoftname() {\n    return this.softname;\n}\n\npublic void setSoftname(String softname) {\n    this.softname = softname;\n}\n\n@Column(name = \"softtypekey\", nullable = false, length = 10)\npublic String getSofttypekey() {\n    return this.softtypekey;\n}\n\npublic void setSofttypekey(String softtypekey) {\n    this.softtypekey = softtypekey;\n}\n\n@Column(name = \"softversion\", length = 20)\npublic String getSoftversion() {\n    return this.softversion;\n}\n\npublic void setSoftversion(String softversion) {\n    this.softversion = softversion;\n}\n\n@Column(name = \"softsize\", length = 20)\npublic String getSoftsize() {\n    return this.softsize;\n}\n\npublic void setSoftsize(String softsize) {\n    this.softsize = softsize;\n}\n\n@Column(name = \"providername\", length = 200)\npublic String getProvidername() {\n    return this.providername;\n}\n\npublic void setProvidername(String providername) {\n    this.providername = providername;\n}\n\n@Column(name = \"providersite\", length = 100)\npublic String getProvidersite() {\n    return this.providersite;\n}\n\npublic void setProvidersite(String providersite) {\n    this.providersite = providersite;\n}\n\n@Column(name = \"downsite1\", length = 300)\npublic String getDownsite1() {\n    return this.downsite1;\n}\n\npublic void setDownsite1(String downsite1) {\n    this.downsite1 = downsite1;\n}\n\n@Column(name = \"softfaceurl\", length = 200)\npublic String getSoftfaceurl() {\n    return this.softfaceurl;\n}\n\npublic void setSoftfaceurl(String softfaceurl) {\n    this.softfaceurl = softfaceurl;\n}\n\n@Column(name = \"issuestate\", length = 10)\npublic String getIssuestate() {\n    return this.issuestate;\n}\n\npublic void setIssuestate(String issuestate) {\n    this.issuestate = issuestate;\n}\n\n@Column(name = \"fruntime\", length = 10)\npublic String getFruntime() {\n    return this.fruntime;\n}\n\npublic void setFruntime(String fruntime) {\n    this.fruntime = fruntime;\n}\n\n@Column(name = \"sruntime\", length = 10)\npublic String getSruntime() {\n    return this.sruntime;\n}\n\npublic void setSruntime(String sruntime) {\n    this.sruntime = sruntime;\n}\n\n@Column(name = \"marketprice\", precision = 10, scale = 0)\npublic Float getMarketprice() {\n    return this.marketprice;\n}\n\npublic void setMarketprice(Float marketprice) {\n    this.marketprice = marketprice;\n}\n\n@Column(name = \"storeprice\", precision = 10, scale = 0)\npublic Float getStoreprice() {\n    return this.storeprice;\n}\n\npublic void setStoreprice(Float storeprice) {\n    this.storeprice = storeprice;\n}\n\n@Column(name = \"ifourcommend\", length = 2)\npublic String getIfourcommend() {\n    return this.ifourcommend;\n}\n\npublic void setIfourcommend(String ifourcommend) {\n    this.ifourcommend = ifourcommend;\n}\n\n@Column(name = \"ifspprice\", length = 2)\npublic String getIfspprice() {\n    return this.ifspprice;\n}\n\npublic void setIfspprice(String ifspprice) {\n    this.ifspprice = ifspprice;\n}\n\n@Column(name = \"softenglishname\", length = 200)\npublic String getSoftenglishname() {\n    return this.softenglishname;\n}\n\npublic void setSoftenglishname(String softenglishname) {\n    this.softenglishname = softenglishname;\n}\n\n@Column(name = \"runLink\", length = 300)\npublic String getRunLink() {\n    return this.runLink;\n}\n\npublic void setRunLink(String runLink) {\n    this.runLink = runLink;\n}\n\n@Column(name = \"runnum\", length = 10)\npublic String getRunnum() {\n    return this.runnum;\n}\n\npublic void setRunnum(String runnum) {\n    this.runnum = runnum;\n}\n\n@Column(name = \"downnum\", length = 10)\npublic String getDownnum() {\n    return this.downnum;\n}\n\npublic void setDownnum(String downnum) {\n    this.downnum = downnum;\n}\n\n@Column(name = \"column1\", nullable = false, length = 2000)\npublic String getColumn1() {\n    return this.column1;\n}\n\npublic void setColumn1(String column1) {\n    this.column1 = column1;\n}\n\n@Column(name = \"column2\", length = 200)\npublic String getColumn2() {\n    return this.column2;\n}\n\npublic void setColumn2(String column2) {\n    this.column2 = column2;\n}\n\n@Column(name = \"column3\", length = 200)\npublic String getColumn3() {\n    return this.column3;\n}\n\npublic void setColumn3(String column3) {\n    this.column3 = column3;\n}\n\n@Column(name = \"contact\", length = 2)\npublic String getContact() {\n    return this.contact;\n}\n\npublic void setContact(String contact) {\n    this.contact = contact;\n}\n\n@Column(name = \"createdate\", length = 19)\npublic Timestamp getCreatedate() {\n    return this.createdate;\n}\n\npublic void setCreatedate(Timestamp createdate) {\n    this.createdate = createdate;\n}\n\n@Column(name = \"updatedate\", length = 19)\npublic Timestamp getUpdatedate() {\n    return this.updatedate;\n}\n\npublic void setUpdatedate(Timestamp updatedate) {\n    this.updatedate = updatedate;\n}\n", "\n\n", "}", "\n[/code]", "\nservice 层", "\nToplMSoftService ", "\n[code=\"java\"]", "\npackage com.zw.service;", "\n\n", "import com.zw.domain.ToplMSoft;", "\n\n", "public interface ToplMSoftService {", "\n    public void save(ToplMSoft tps);", "\n\n", "}", "\n\n", "[/code]", "\nToplMSoftServiceImpl ", "\n\n", "[code=\"java\"]package com.zw.service.impl;", "\n\n", "import javax.annotation.Resource;", "\n\n", "import org.springframework.stereotype.Service;", "\nimport org.springframework.transaction.annotation.Propagation;", "\nimport org.springframework.transaction.annotation.Transactional;", "\n\n", "import com.zw.core.BaseDao;", "\nimport com.zw.core.IBaseDao;", "\nimport com.zw.domain.ToplMSoft;", "\nimport com.zw.service.ToplMSoftService;", "\n @Transactional(readOnly = true)", "\n//对业务类进行事务增强的标注", "\n @Service", "\n//声明此类为业务逻辑层的类", "\npublic class ToplMSoftServiceImpl implements ToplMSoftService {", "\n     @Resource(name =\"toplMSoftDAO\")", "\n    private IBaseDao  toplMSoftDAO;", "\n    public IBaseDao getToplMSoftDAO() {", "\n\n", "    return toplMSoftDAO;\n}\npublic void setToplMSoftDAO(IBaseDao<ToplMSoft, Integer> toplMSoftDAO) {\n            this.toplMSoftDAO = toplMSoftDAO;\n}\n  @Transactional(readOnly = false, propagation = Propagation.REQUIRED)\npublic void save(ToplMSoft tps) {\n    System.out.println(\"toplMSoftDAO:\"+toplMSoftDAO);\n    this.toplMSoftDAO.save(tps);\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "Test:", "\n\n", "[code=\"java\"]", "\npackage com.zw.test;", "\n\n", "import org.springframework.context.ApplicationContext;", "\nimport org.springframework.context.support.ClassPathXmlApplicationContext;", "\n\n", "import com.zw.domain.ToplMSoft;", "\nimport com.zw.service.ToplMSoftService;", "\nimport com.zw.service.impl.ToplMSoftServiceImpl;", "\n\n", "public class TestHibernate {", "\n    public static void main(String[] args) {", "\n        ApplicationContext ctx=new ClassPathXmlApplicationContext(\"applicationContext.xml\");", "\n        ToplMSoftService dao=   (ToplMSoftServiceImpl) ctx.getBean(\"toplMSoftServiceImpl\");", "\n        //GenericEntityDao dao= (GenericEntityDao) ctx.getBean(\"ToplMSoftDAO\");", "\n        System.out.println(\"1111111111:\"+dao);", "\n        ToplMSoft tps=new ToplMSoft();", "\n        tps.setSoftname(\"测试11111111\");", "\n        tps.setSofttypekey(\"2\");", "\n        tps.setColumn1(\"xsdasdasdasd\");", "\n        dao.save(tps);", "\n\n", "}\n", "\n\n", "}", "\n\n", "[/code]", "\n\n", "控制台输出", "\n我在BaseDao save方法里面打出", "\nSystem.out.println(\"gedao:\"+gedao); 为null", "\n[code=\"java\"]", "\n1111111111:com.zw.service.impl.ToplMSoftServiceImpl@6e3e5e", "\ntoplMSoftDAO:com.zw.dao.ToplMSoftDAO@10718b7", "\ngedao:null", "\nException in thread \"main\" java.lang.NullPointerException", "\n    at com.zw.core.BaseDao.save(BaseDao.java:60)", "\n    at com.zw.service.impl.ToplMSoftServiceImpl.save(ToplMSoftServiceImpl.java:31)", "\n    at com.zw.service.impl.ToplMSoftServiceImpl$$FastClassByCGLIB$$7aa0faa6.invoke()", "\n    at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)", "\n    at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:692)", "\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)", "\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:107)", "\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)", "\n    at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:625)", "\n    at com.zw.service.impl.ToplMSoftServiceImpl$$EnhancerByCGLIB$$ded4983e.save()", "\n    at com.zw.test.TestHibernate.main(TestHibernate.java:22)", "\n\n", "[/code]", "\n\n", "如果不用注解 直接在applicationContext.xml配置", "\n[code=\"java\"]", "\n\n", "<bean id=\"toplMSoftDAO\" class=\"com.zw.dao.ToplMSoftDAO\" parent=\"baseDao\"></bean>\n<bean id=\"toplMSoftServiceImpl\"\n    class=\"com.zw.service.impl.ToplMSoftServiceImpl\">\n    <property name=\"toplMSoftDAO\" ref=\"toplMSoftDAO\" />\n</bean> \n", "\n\n", "[/code]", "\n就不会报错 可以直接插入数据.", "\n\n", "对Spring了解的不深 比较困惑", "\n朋友们帮忙解答一下 ", "\n谢谢"]], "Tag": "程序设计"}
{"Answer": "尴尬，前面乱了\r\n重写遍\r\nint是基本类型，你换成Integer就好了\r\n\r\nDemo&lt;Integer&gt; b=new Demo&lt;&gt;(5);", "Konwledge_Point": "泛型机制——模板", "Question": ["一个关于Java泛型的问题，求帮助谢谢", ["class Demo{", "\n    private c a;", "\n    public Demo(c a){", "\n        this.a=a;", "\n    }", "\n    public c getA(){", "\n        return a;", "\n    }", "\n    public void setA(c a){", "\n        this.a=a;", "\n    }", "\n}", "\npublic class Generic {", "\n    public static void main(String args[]){", "\n        Demo b=new Demo(5);", "\n        //b.setA();", "\n        System.out.print(b.getA());", "\n    }", "\n}"]], "Tag": "程序设计"}
{"Answer": "一般C++有序集合就是升序或者降序的\r\nbinary_sreach就是二分法检索，经过一次比较就缩小一半的检索区间，所以效率比find高", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型算法中find和binary_sreach有什么区别", ["有序集合是不是只有升序和降序？", "\nbinary_sreach使用的是什么搜索方式？", "\n还有其他的搜索方式吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Until generics arrive (which will most likely be called &lt;a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md\" rel=\"nofollow noreferrer\"&gt;contracts&lt;/a&gt;), reflection and interfaces are the only tools to achieve such generalization.&lt;/p&gt;\n\n&lt;p&gt;You could define &lt;code&gt;reverse()&lt;/code&gt; to take a value of &lt;code&gt;interface{}&lt;/code&gt; and use the &lt;a href=\"https://golang.org/pkg/reflect/\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;reflect&lt;/code&gt;&lt;/a&gt; package to index it and swap elements. This is usually slow, and harder to read / maintain.&lt;/p&gt;\n\n&lt;p&gt;Interfaces provide a nicer way but requires you to write methods to different types. Take a look at the &lt;a href=\"https://golang.org/pkg/sort/\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; package, specifically the &lt;a href=\"https://golang.org/pkg/sort/#Sort\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;sort.Sort()&lt;/code&gt;&lt;/a&gt; function:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func Sort(data Interface)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Where &lt;a href=\"https://golang.org/pkg/sort/#Interface\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;sort.Interface&lt;/code&gt;&lt;/a&gt; is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Interface interface {\n        // Len is the number of elements in the collection.\n        Len() int\n        // Less reports whether the element with\n        // index i should sort before the element with index j.\n        Less(i, j int) bool\n        // Swap swaps the elements with indexes i and j.\n        Swap(i, j int)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;sort.Sort()&lt;/code&gt; is able to sort any slices that implement &lt;code&gt;sort.Interface&lt;/code&gt;, any slices that have the methods the sorting algorithm needs to do its work. The good thing about this approach is that you can sort other data structures too not just slices (e.g. a linked list or an array), but usually slices are used.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["编写对泛型类型进行操作的方法的惯用方式", ["\n\n", "What's the idiomatic way to write a method that operates on a \"generic\" array?", "\n\n", "I have a typed array:", "\n\n", "a := make([]int, 0)\n", "\n\n", "I want to write a simple method that could operate on an array of any type:", "\n\n", "func reverse(a []interface{}) []interface{} {\n    for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {\n        a[i], a[j] = a[j], a[i]\n    }\n    return a\n}\n", "\n\n", "Using this method ", "a = reverse(a)", " gives me 2 errors:", "\n\n", "cannot use a (type []int) as type []interface {} in argument to reverse\ncannot use reverse(a) (type []interface {}) as type []int in assignment\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The problem is that you can't have one variable pass from one method to another like that. If you do &lt;code&gt;var_dump($em)&lt;/code&gt; in your &lt;code&gt;doSomething()&lt;/code&gt; method, you will see that it returns &lt;code&gt;NULL&lt;/code&gt;. Either pass it as a parameter to that method or set &lt;code&gt;$this-&amp;gt;em&lt;/code&gt; in your constructor.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["将doctrine实体管理器作为参数传递给泛型类", ["\n\n", "I have a generic PHP class I'm using to contain functions/methods I use in multiple Symfony Controllers. In order to use the entity manager, I'm passing it like so:", "\n\n", "class MyController extends Controller\n{\n  public function indexAction()\n  {\n     $em = $this->getDoctrine()->getManager();\n     $dbf = new DBFunctions($em);\n     $result = $dbf->doSomething();\n  }\n}\n", "\n\n", "My generic class looks like this:", "\n\n", "class DBFunctions\n{\n  private $em;\n  public function __construct($em1)\n  {\n    $em = $em1;\n    var_dump($em1);\n  }\n\n  public function doSomething(){\n      $query = $em->createQuery(<my query>);\n      return $query->getResult();\n  }\n}\n", "\n\n", "The problem is when I run the function I get the following error:", "\n\n", " Call to a member function createQuery() on a non-object\n", "\n\n", "BUT my var_dump shows this (and a ton more): ", "\n\n", "object(EntityManager514e73398155c_546a8d27f194334ee012bfe64f629947b07e4919\\__CG__\\Doctrine\\ORM\\EntityManager)[236]\nprivate 'delegate' => \nobject(Doctrine\\ORM\\EntityManager)[231]\n", "\n\n", "I'm sure its an object, so I'm lost as to what to do.", "\n\n", "Thanks for any help!", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;public &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; GenericsA&amp;lt;T extends Number&amp;gt; {\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; T t;\n\n    public &lt;span class=\"hljs-constructor\"&gt;GenericsA(T &lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;)&lt;/span&gt; {\n        this.t &amp;#61; t;\n    }\n\n    public T sum(T tl) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t instanceof Double) {\n            return (T) &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Double&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;value&lt;span class=\"hljs-constructor\"&gt;Of(&lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;doubleValue&lt;/span&gt;()&lt;/span&gt; &amp;#43; tl.double&lt;span class=\"hljs-constructor\"&gt;Value()&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t instanceof Float) {\n            return (T) &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Float&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;value&lt;span class=\"hljs-constructor\"&gt;Of(&lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;floatValue&lt;/span&gt;()&lt;/span&gt; &amp;#43; tl.&lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;Value()&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t instanceof Long) {\n            return (T) &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Long&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;value&lt;span class=\"hljs-constructor\"&gt;Of(&lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;longValue&lt;/span&gt;()&lt;/span&gt; &amp;#43; tl.long&lt;span class=\"hljs-constructor\"&gt;Value()&lt;/span&gt;);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            return (T) &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Integer&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;value&lt;span class=\"hljs-constructor\"&gt;Of(&lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;intValue&lt;/span&gt;()&lt;/span&gt; &amp;#43; tl.&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;Value()&lt;/span&gt;);\n        }\n    }\n\n    &amp;#64;Override\n    public String &lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;String()&lt;/span&gt; {\n        return &lt;span class=\"hljs-string\"&gt;&amp;#34;GenericsA{&amp;#34;&lt;/span&gt; &amp;#43;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;t&amp;#61;&amp;#34;&lt;/span&gt; &amp;#43; t &amp;#43;\n                &lt;span class=\"hljs-character\"&gt;&amp;#39;}&amp;#39;&lt;/span&gt;;\n    }\n\n    public static void main(String&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; args) {\n        GenericsA&amp;lt;Integer&amp;gt; a &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; GenericsA&amp;lt;&amp;gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(a.sum(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)); &lt;span class=\"hljs-comment\"&gt;// 输出 3&lt;/span&gt;\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(a); &lt;span class=\"hljs-comment\"&gt;// 输出 GenericsA{t&amp;#61;1}&lt;/span&gt;\n\n        GenericsA&amp;lt;Double&amp;gt; b &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; GenericsA&amp;lt;&amp;gt;(&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;);\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(b.sum(&lt;span class=\"hljs-number\"&gt;2.0&lt;/span&gt;)); &lt;span class=\"hljs-comment\"&gt;// 输出 3.0&lt;/span&gt;\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;System&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;out.println(b); &lt;span class=\"hljs-comment\"&gt;// 输出 GenericsA{t&amp;#61;1.0}&lt;/span&gt;\n    }\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型各种数据在方法里运算，怎么转变运算？", ["泛型的方法传值相加怎么实现的？ 不同数据该怎么分开处理运算？下面该如何实现？", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "这是visual studio 调试器的设置。点击Tools -----------Options菜单，如下图这样勾选，启用隐式函数计算：\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201706/19/1497868597_280638.png)\r\n\r\n\r\n**用心回答每个问题，如果对您有帮助，请采纳答案好吗，谢谢！**", "Konwledge_Point": "泛型机制——模板", "Question": ["C# 泛型集合错误提示 【用户已关闭隐式函数计算】", ["没有多余的代码，就这几行，调试的时候就提示这个，请问是怎么回事？百度搜不到任何有关的内容"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;直接&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;List&amp;lt;ProductFather&amp;gt; list &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;List&lt;/span&gt;&amp;lt;ProductFather&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt; 就行&amp;#xff0c;用的时候把它当一般的对象加入外层列表里&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["vs2019 C# List泛型集合，创建集合的集合的问题", ["\n", "using", " ", "System", ";\n", "using", " ", "System", ".Collections.Generic;\n", "using", " ", "System", ".Linq;\n", "using", " ", "System", ".Text;\n", "using", " ", "System", ".Threading.Tasks;\n\nnamespace ClassPractice13day_06_练习_超市收银系统\n{\n    ", "class", " CangKu\n    {\n        //存储货物\n        List<List<ProductFather>> list = ", "new", " List<List<ProductFather>>();\n\n    }\n}\n", "\n", "以上写的是一个给抽象类ProductFather创建一个集合的集合，也就是给不同商品分开存储放在仓库里。List<>尖括号里面只能装类和命名空间，list是字段。", "很好奇", "\n", "List", "<", "ProductFather", ">", "\n", "\n", "是怎么定义成为一个类的？", "如果要先创建一个集合，再创建这个集合的集合，也就是分开写，那得怎么写？好像会很麻烦"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个是泛型的类型&amp;#xff0c;它决定了后面两个T是什么类型。&lt;br /&gt;第二个T是函数的参数类型&amp;#xff0c;因为第一个T指定了泛型类型&amp;#xff0c;所以这个T的类型与前面的保持一致。&lt;br /&gt;第三个T是函数的返回值类型&amp;#xff0c;也与泛型类型一致。&lt;/p&gt;\n&lt;p&gt;望采纳&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型里面，这三个T，分别代表什么意思？", ["\n", "function", " ", "identity", " <T>(value: T) : ", "T", " {\n  ", "return", " ", "value", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "声明的T可以出现多个\r\n在类定义处声明的泛型，则用来指定这个类用来处理的对象类型，这个类中定义的所有方法，只要使用了类定义处声明的泛型参数，则都必须使用同一个对象，否则，编译就会出现错误\r\n如果仅仅是在方法声明处定义泛型，则表示这个方法的参数或返回值使用什么类型的数据，解决的问题\r\n   1.不再需要强制转型;\r\n   2.编辑器增加了强制检查集合中的对象类型的功能，避免了在Girl的集合中出现Boy对象的问题(虽然有的时候是我们所期待的)\r\n\r\n如:\r\n  public class Query&lt;T&gt;{\r\n    private T t;\r\n    public T get(){...};\r\n    public void set(T t){...};\r\n  }\r\n\r\n如果使用的方式如下:\r\n                  Query&lt;User&gt; query = new Query&lt;User&gt;();\r\n则上面定义的类与下面的定义一致\r\n  public class Query{\r\n     private User t;\r\n     public User get(){...}\r\n     public void set(User t){}\r\n  }", "Konwledge_Point": "泛型机制——模板", "Question": ["关于java泛型的使用问题（求解答，十分感谢）", ["首先，假如有这样的一个类定义", "\npublic class Query", "\n{", "\n   public T get(Class class){}", "\n   public List getAll(Class class){}", "\n}这里在query后面定义的是什么意思，为什么要在这个位置定义呢？跟后面方法的参数T又有什么关系呢？", "\n其次，有这样的定义类", "\npublic class Query", "\n{", "\n   public  T get(Class class){}", "\n   public  List getAll(Class class){}", "\n}这样写为什么也可以呢，为什么不在query后面跟上定义就要在方法的前面加上定义呢？", "\n然后，如果有这样的定义类", "\npublic class Query", "\n{}这里T后面的参数可以是多个吗？这样定义又是什么意思呢？", "\n求好心人解答，大恩不言谢"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;have a look at &lt;a href=\"https://play.golang.org/p/T-8l0voCDC\" rel=\"nofollow noreferrer\"&gt;this solution&lt;/a&gt;. It is one possible solution.&lt;/p&gt;\n\n&lt;p&gt;Generally: you want to work with interfaces here. In the sample I use the interface &lt;code&gt;DataRow&lt;/code&gt; to store data of a row of any table. All table structs have to implement 2 functions as you can see in my example. (Also see my note about a general function in a base class with generics)&lt;/p&gt;\n\n&lt;p&gt;Here the code again:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport \"fmt\"\n\ntype Foo struct {\n    Id string\n}\n\nfunc (s *Foo) Fill(m map[string]string) {\n    // If you want to build a general Fill you can build a base struct for Foo, Bar, etc. that works with reflect. \n    // Note that it will be slower than implementing the function here! Ask me if you want one I built recently.\n\n    s.Id = m[\"id\"]\n}\n\nfunc (s *Foo) GetRow() interface{} {\n    return nil\n}\n\ntype Bar struct {\n    Id string\n}\n\nfunc (s *Bar) Fill(m map[string]string) {\n    s.Id = m[\"id\"]\n}\n\nfunc (s *Bar) GetRow() interface{} {\n    return nil\n}\n\ntype DataRow interface {\n    Fill(m map[string]string)\n    GetRow() interface{}\n}\n\ntype Changeset struct {\n    Table   string\n    Type    string\n    OldData map[string]string\n    NewData map[string]string\n}\n\ntype ChangesetTyped struct {\n    Table   string\n    Type    string\n    OldData DataRow\n    NewData DataRow\n}\n\nfunc doMap(c Changeset) ChangesetTyped {\n    ct := ChangesetTyped{\n        Table:   c.Table,\n        Type:    c.Type,\n        OldData: parseRow(c.Table, c.OldData),\n    }\n\n    if c.Type == \"UPDATE\" {\n        ct.NewData = parseRow(c.Table, c.NewData)\n    }\n\n    return ct\n}\n\nfunc parseRow(table string, data map[string]string) (row DataRow) {\n    if table == \"foo\" {\n        row = &amp;amp;Foo{}\n    } else if table == \"bar\" {\n        row = &amp;amp;Bar{}\n    }\n\n    row.Fill(data)\n    return\n}\n\nfunc main() {\n    i := Changeset{\n        Table:   \"foo\",\n        Type:    \"INSERT\",\n        NewData: map[string]string{\"id\": \"1\"},\n    }\n\n    u1 := Changeset{\n        Table:   \"foo\",\n        Type:    \"UPDATE\",\n        OldData: map[string]string{\"id\": \"20\"},\n        NewData: map[string]string{\"id\": \"21\"},\n    }\n\n    u2 := Changeset{\n        Table:   \"bar\",\n        Type:    \"UPDATE\",\n        OldData: map[string]string{\"id\": \"30\"},\n        NewData: map[string]string{\"id\": \"31\"},\n    }\n\n    m1 := doMap(i)\n    m2 := doMap(u1)\n    m3 := doMap(u2)\n\n    fmt.Println(m1, m1.OldData)\n    fmt.Println(m2, m2.OldData, m2.NewData)\n    fmt.Println(m3, m3.OldData, m3.NewData)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;If you want to get the actual row from &lt;code&gt;DataRow&lt;/code&gt; cast to the correct type use (of type Foo in this example):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;foo, ok := dt.GetRow().(Foo)\nif !ok {\n    fmt.Println(\"it wasn't of type Foo after all\")\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Hope this helps you in you golang quest!&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["如何在没有泛型的情况下对此复合类型层次结构建模", ["\n\n", "I have a system that parses a logfile which contains changesets of mysql tables, think of something like a binlog. There can be updates and inserts, deletes we ignore for now. The function of my module gets an input like this:", "\n\n", "type Changeset struct {\n    Table string // which table was affected\n    Type string // INSERT or UPDATE\n    OldData map[string]string // these 2 fields contain all columns of a table row\n    NewData map[string]string\n}\n", "\n\n", "OldData", " is empty when it's an ", "INSERT", " changeset, when it's an ", "UPDATE", " changeset, ", "OldData", " and ", "NewData", " are filled (the data before and after the update).", "\n\n", "Now I don't want to work with untyped data like this in my module, as I need to model some domain and it would be nicer to have some type safety. However, I need to still retain the knowledge if a change was an insert or an update for that domain logic (like, if it's an update, I will validate that some fields didn't change, as an example). ", "\n\n", "Assume I have two tables (let's say they only have one field named Id, but in reality they have more and different ones). So I modeled these objects like so:", "\n\n", "type Foo struct { // foo table\n    Id string\n    // ... imagine more fields  here ...\n}\n\ntype Bar struct { // bar table\n    Id string\n    // ... imagine more fields  here ...\n}\n", "\n\n", "Now I can map the ", "map[string][string]", " from ", "Changeset.OldData", " and ", "Changeset.NewData", ", but then I don't know anymore if the change was an insert or an update. I was thinking a bit back and forth, but the best I came up with was:", "\n\n", "type FooInsert struct {\n    New Foo\n}\n\ntype FooUpdate struct {\n    New Foo\n    Old Foo\n}\n\ntype BarInsert struct {\n    New Bar\n}\n\ntype BarUpdate struct {\n    New Bar\n    Old Bar\n}\n", "\n\n", "And the mapping code looks like this:", "\n\n", "func doMap(c Changeset) interface{} {\n    if c.Table == \"foo\" {\n        switch c.Type {\n            case \"UPDATE\":\n                return FooUpdate{Old: Foo{Id: c.OldData[\"id\"]}, New: Foo{Id: c.NewData[\"id\"]}}\n\n            case \"INSERT\":\n                return FooInsert{New: Foo{Id: c.NewData[\"id\"]}}\n        }\n    }\n\n    if c.Table == \"bar\" {\n        switch c.Type {\n                // ... almost same as above, but return BarUpdate/BarInsert ...\n        }\n    }\n\n    return nil\n}\n", "\n\n", "The upside is, it enables me to write do do a typeswitch on the result of this mapping function like so:", "\n\n", "insertChangeset := Changeset{\n    Table: \"foo\",\n    Type: \"INSERT\",\n    NewData: map[string]string{\"id\": \"1\"},\n}\n\no := doMap(insertChangeset)\n\nswitch o.(type) {\n    case BarUpdate:\n        println(\"Got an update of table bar\")\n\n    case FooUpdate:\n        println(\"Got an update of table foo\")\n\n    case BarInsert:\n        println(\"Got an insert to table bar\")\n\n    case FooInsert:\n        println(\"Got an insert to table foo\")           \n}\n", "\n\n", "The typeswitch is what I would need to have in the end (different types per change changeset type and per entity.) But:", "\n\n", "\n", "the mapping code as seen in ", "doMap", " is very ugly and repetitive.", "\n", "for every new entity ", "X", " I introduce, I need to create two more types ", "XInsert", " and ", "XUpdate", ".", "\n", "\n", "Is there any way around this mess? In other programming languages I might have thought of something like:", "\n\n", "type Update<T> {\n    T Old\n    T New\n}\n\ntype Insert<T> {\n    T New\n}\n", "\n\n", "But not sure how to model this in Go. I created also a playground sample that shows the whole code in one program: ", "https://play.golang.org/p/ZMnB5K7RaI", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;        HashMap&amp;lt;String, &lt;span class=\"hljs-type\"&gt;Integer&lt;/span&gt;&amp;gt; m &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();\n        TcUser t &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &amp;#34;张三&amp;#34;, &amp;#34;&amp;#34;);\n        TcUser t1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;#34;李四&amp;#34;, &amp;#34;&amp;#34;);\n        TcUser t2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;#34;张三&amp;#34;, &amp;#34;&amp;#34;);\n        TcUser t3 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;#34;李四&amp;#34;, &amp;#34;&amp;#34;);\n        TcUser t4 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;#34;李四&amp;#34;, &amp;#34;&amp;#34;);\n        TcUser t5 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;#34;王五&amp;#34;, &amp;#34;&amp;#34;);\n        TcUser t6 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; TcUser(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &amp;#34;张三&amp;#34;, &amp;#34;&amp;#34;);\n        List&amp;lt;TcUser&amp;gt; usersList &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t);\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t1);\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t2);\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t3);\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t4);\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t5);\n        usersList.&lt;span class=\"hljs-keyword\"&gt;add&lt;/span&gt;(t6);\n\n        usersList.&lt;span class=\"hljs-keyword\"&gt;forEach&lt;/span&gt;(f -&amp;gt; {\n            m.merge(f.getUsername(), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;Integer&lt;/span&gt;::sum);\n        });\n        Map&amp;lt;String, Long&amp;gt; collect1 &amp;#61; usersList.stream().collect(Collectors.groupingBy(TcUser::getUsername, Collectors.counting()));\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(m);\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(collect1);\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;两种方案&amp;#xff0c;TcUser就一实体&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["泛型为对象的List根据某一个属性统计对应的次数", ["\nList<GdsStockResult> list ", "=", " new ArrayList()", ";", "\n        GdsStockResult result ", "=", " new GdsStockResult()", ";", "\n        result.setIsbn(", "\"123456\"", ")", ";", "\n        result.setChnlCode(null)", ";", "\n        result.setStock(", "50", "L)", ";", "\n        list.add(result)", ";", "\n\n        GdsStockResult result2 ", "=", " new GdsStockResult()", ";", "\n        result2.setIsbn(", "\"123456\"", ")", ";", "\n        result2.setChnlCode(", "\"V100\"", ")", ";", "\n        result2.setStock(", "100", "L)", ";", "\n        list.add(result2)", ";", "\n\n\n        GdsStockResult result3 ", "=", " new GdsStockResult()", ";", "\n        result3.setIsbn(", "\"1234567895\"", ")", ";", "\n        result3.setChnlCode(", "\"V100\"", ")", ";", "\n        result3.setStock(", "3", "L)", ";", "\n        list.add(result3)", ";", "\n\n\n        GdsStockResult result4 ", "=", " new GdsStockResult()", ";", "\n        result4.setIsbn(", "\"1234568\"", ")", ";", "\n        result4.setChnlCode(", "\"V100\"", ")", ";", "\n        result4.setStock(", "10", "L)", ";", "\n        list.add(result4)", ";", "\n", "\n", "想根据isbn去统计一下", "最后结果会是：123456 2次          1234567895  1次  1234568 1次"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/711475787056192.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;你的number没有改变&amp;#xff0c;一直是0&amp;#xff0c;所以这一步的意义是什么呢&amp;#xff1f;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["Java。qiu大家帮看下代码关于数组泛型那块的", ["求大家帮看一下countOpenDoors（）方法和listDoors（）方法哪里写错了，run出来是错的", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You are trying to convert &lt;code&gt;[]ConcreteType&lt;/code&gt; to &lt;code&gt;[]interface{}&lt;/code&gt;, which does not work implicitly. &lt;/p&gt;\n\n&lt;p&gt;But you can convert &lt;code&gt;[]ConcreteType&lt;/code&gt; to &lt;code&gt;interface{}&lt;/code&gt; and then cast it back to &lt;code&gt;[]ConcreteType.&lt;/code&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["golang是否有类似泛型（java）的东西？  [重复]", ["\n\n", "\n    ", "This question already has an answer here:", "\n    ", "\n", "\n            ", "Why no generics in Go?", "\n                \n                    4 answers\n                \n        ", "\n    ", "\n", "\n\n", "I want to write something like CRUD on golang. I see that like", "\n\n", "type CRUD interface {\n  Save(entity interface{})() // done\n  Update(entity interface{})() // done\n  Delete(entity interface{})() // done\n  All() []interface{} // problem is here\n}\n", "\n\n", "I have several model structures.", "\n\n", "type User struct {\n  Login string\n  Password string\n}\n\ntype Comment struct {\n  UserId int64\n  Message string\n  CreatedAt int64\n}\n", "\n\n", "and I have some service:", "\n\n", "// Struct should implement interface CRUD and use instead of interface{} User struct\ntype UserService struct {\n  Txn SomeStructForContext\n}\n\nfunc (rec *UserService) Save(entity interface{}) {\n  user := entity.(*model.User)\n  // TODO operation with user\n}\n\n// All the same with Update and Delete\n\nfunc (rec *UserService) All() ([]interface{}) {\n  // TODO: I can't convert User struct array for return \n}\n", "\n\n", "I hope, it'll explain what problem is", "\n\n", "</div>\n", "\n"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/peter521/article/details/2985577", "Konwledge_Point": "泛型机制——模板", "Question": ["link环境下，用codefirst制作一个网盘软件，请问如何和treeview绑定文件？", ["link环境下，用codefirst制作一个网盘软件，请问如何和treeview绑定文件？"]], "Tag": "程序设计"}
{"Answer": "你能理解数组也是一个对象,就能理解了,Object o=lsa,把一个数组赋值给对象o,那这时候o就是一个数组对象,后面的强转,一个数组,转化为,对象数组,也就是把数组的每一项都转化为对象,和第二步的意思一样,第二行是转一个,这里转了一个集合", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型数组的一个小问题（很简单！求解！） ", ["代码如下:", "\n\n", "List<String>[] lsa = new List<String>[10]; // Not really allowed.  \nObject o = lsa;  \nObject[] oa = (Object[]) o;  \nList<Integer> li = new ArrayList<Integer>();  \nli.add(new Integer(3));  \noa[1] = li; // Unsound, but passes run time store check  \nString s = lsa[1].get(0); // Run-time error: ClassCastException.   \n", "\n\n", "代码第二行到第三行怎么理解，单独理解第二行还能明白，但第三行那个强制转换具体怎么做到的？不太懂，求解释原理。。"]], "Tag": "程序设计"}
{"Answer": "【Array.newInstance()】这个方法返回的是Object，，向上转型很自然，向下转型就需要强转\r\n由于这个后面传入的是class，也就是通过 class来创建实例（这个是运行时才能知道类型的）\r\n\r\n所以说程序给报个异常也是理所应当，，\r\n\r\n【解决方法】题主可以不适用【Array.newInstance()】\r\n自己写一个创建实例的方法，，难度不是很大吧？？\r\n\r\n有问题还可以追问。", "Konwledge_Point": "泛型机制——模板", "Question": ["java，我使用泛型数组的时候提示unchecked cast，下有图片代码", []], "Tag": "程序设计"}
{"Answer": "```\r\n 不是自反关系，而是预序关系。\r\n\r\nhttps://en.wikipedia.org/wiki/Reflexive_relation\r\nif ∀x,y∈S: x~y ⇒ x~x ∧ y~y.\r\n如果x y是 预序关系，则x y都是自反的。\r\n\r\n预序关系的例子\r\nExamples of reflexive relations include:\r\n\r\n\"is equal to\" (equality) 相等\r\n\"is a subset of\" (set inclusion) 子集\r\n\"divides\" (divisibility) 划分\r\n\"is greater than or equal to\" 大于等于\r\n\"is less than or equal to\" 小于等于\r\n\r\n非预序关系的例子\r\nExamples of irreflexive relations include:\r\n\r\n\"is not equal to\" 不等\r\n\"is coprime to\" (for the integers&gt;1, since 1 is coprime to itself) 互质\r\n\"is a proper subset of\" 真子集\r\n\"is greater than\" 大于\r\n\"is less than\" 小于\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java泛型教材中的一句英文，不太懂什么意思？", ["the supertype relation is reflexive", "\n父类关系是自反的？还是别的什么意思？", "\n如果就是这个意思的话是什么意思。。", "\n虚心求解"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;任何类型的父类 都是 Object&amp;#xff0c;所以 ZI 的父类也是 Object的&amp;#xff0c;这里是向上兼容的&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA 中 Object和泛型，在方法重写时可以互相替换吗？？", ["父方法", "\n", "public", " ", "class", " ", "Fu", "<", "FU", "> {\n    ", "public", " ", "void", " x(FU a){\n        System.", "out", ".println(a);\n    }\n}\n", "\n", "子方法", "\n", "public ", "class", " ", "Zi<ZI>", " ", "extends", " ", "Fu<ZI>", "{\n    ", "@Override", "\n    public void x(", "Object", " o){\n        ", "System", ".out.println(o);\n    }\n}\n", "\n", "不是说形参列表完全一样才可以重写", "那子方法形参是Object类型，父方法形参是泛型，这样为啥也可以"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"646\" src=\"https://img-ask.csdnimg.cn/upload/1621060922318.png\" width=\"1071\" /&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["各位大哥，为什么我加了个泛型，就运行不出来了", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;json字符串含有数组&amp;#xff0c;核查下反序列化接收对象是否定义对应类型的参数&lt;/p&gt;\n&lt;p&gt;例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-comment\"&gt;//反序列化方法&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;lt;&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;T&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;gt;&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;T&lt;/span&gt; decode(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; json, &lt;span class=\"hljs-type\"&gt;TypeReference&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;T&lt;/span&gt;&amp;gt; typeReference)\n            &lt;span class=\"hljs-keyword\"&gt;throws&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;JsonParseException&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;JsonMappingException&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;IOException&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;T&lt;/span&gt;) objectMapper.readValue(json, typeReference);\n    }\n\n&lt;span class=\"hljs-meta\"&gt;&amp;#64;Data&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;OutModel&lt;/span&gt; {\n\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;JsonProperty&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;test&amp;#34;&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;List&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;InnerModel&lt;/span&gt;&amp;gt; test;\n}\n\n\n&lt;span class=\"hljs-meta\"&gt;&amp;#64;Data&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;InnerModel&lt;/span&gt; {\n\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;JsonProperty&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;default_value_type&amp;#34;&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; defaultValueType;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//测试调用&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; jsonstr &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;{&lt;!-- --&gt;&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;test&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;: [{&lt;!-- --&gt;&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;default_value_type&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;: &lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;123&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;},&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;default_value_type&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;: &lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;456&lt;span class=\"hljs-subst\"&gt;\\&amp;#34;&lt;/span&gt;&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;&lt;span class=\"hljs-subst\"&gt;\\t&lt;/span&gt;}]&lt;span class=\"hljs-subst\"&gt;\\n&lt;/span&gt;&amp;#34;&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#43;&lt;/span&gt;\n                &lt;span class=\"hljs-string\"&gt;&amp;#34;}&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;OutModel&lt;/span&gt; list &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; null;\n        &lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt; {\n            list &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;JsonUtil&lt;/span&gt;.decode(jsonstr, new &lt;span class=\"hljs-type\"&gt;TypeReference&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;OutModel&lt;/span&gt;&amp;gt;() {\n            });\n        } &lt;span class=\"hljs-keyword\"&gt;catch&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;IOException&lt;/span&gt; e) {\n            e.printStackTrace();\n        }\n        &lt;span class=\"hljs-type\"&gt;List&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;InnerModel&lt;/span&gt;&amp;gt; inner &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; list.getTest();\n        inner.forEach(innerModel -&amp;gt; {\n            &lt;span class=\"hljs-type\"&gt;System&lt;/span&gt;.out.println(innerModel.getDefaultValueType());\n        });\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["使用getObjectMapper().readValue 方法将字符串反序列化出现问题", ["public static  T getObjectFromJson(String json, TypeReference valueTypeRef) {", "    try {", "\n", "    return get", "ObjectMapper()", ".read", "Value(", "json", ", ", "valueTypeRef", ")", ";\n} catch (Exception e) {\n    throw ", "new", " ", "RuntimeException(", "e", ")", ";\n}\n", "\n", "}", "\n", "报错信息", "java.lang.RuntimeException: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize instance of ", "java.util.ArrayList", " out of START_OBJECT token", " at [Source: (String)\"[{\"default_value_type\":\"\",\"display_condition\":null,\"enable_default_value\":false,\"id\":\"widget16518922297380001\",\"name\":\"关联审批\",\"printable\":false,\"required\":true,\"type\":\"connect\",\"widget_default_value\":\"\"},{\"default_value_type\":\"\",\"display_condition\":null,\"enable_default_value\":false,\"id\":\"widget16518922368540001\",\"name\":\"联系人\",\"printable\":true,\"required\":true,\"type\":\"contact\",\"widget_default_value\":\"\"},{\"default_value_type\":\"\",\"display_condition\":null,\"enable_default_value\":false,\"id\":\"widget165189\"[truncated 2142 chars]; line: 1, column: 1920] (through reference chain: java.util.ArrayList[5]->cn.com.lundong.feishu.approval.request.result.ApprovalFormFieldResult[\"option\"])"]], "Tag": "程序设计"}
{"Answer": "clazz应该和泛型E没任何关系，或许是多余参数", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA项目中分页共通方法,有个泛型参数看不明白,求大神解答", ["源码", "\n    @SuppressWarnings(\"unchecked\")", "\n    public  PageList getPagingList(String statement, Object parameter, RowBounds rowBounds,", "\n            Class clazz) {", "\n\n", "    return (PageList<E>) sqlSessionTemplate.selectList(statement, parameter, rowBounds);\n}\n", "\n\n", "问题", " ", "\n这个方法为何必须要传入 Class clazz  这是为了定义 强转时 (PageList) 这个E 所代表的类型吗?"]], "Tag": "程序设计"}
{"Answer": "那你就写成\r\n```\r\nComparator&lt;T&gt; []\r\n``` \r\n就行了\r\n然后调用 接口里面的 compare 方法判断大小进行排序 代替你代码里面的那个less \r\n\r\n最终使用的时候，也就是生成 \r\n\r\n```\r\nComparator&lt;T&gt; []\r\n```\r\n数组时候，需要指定具体的类型\r\n此时这个 具体的类需要实现 Comparator 接口也就是实现 compare 方法使用什么标准来判断大小\r\n例如\r\n![图片说明](https://img-ask.csdn.net/upload/201901/10/1547099741_246307.jpg)", "Konwledge_Point": "泛型机制——模板", "Question": ["下面这段算法四里面的java排序代码怎么修改呢？我要想让支持泛型", []], "Tag": "程序设计"}
{"Answer": "可以使用\r\n```\r\nString regex=\"([a-z])+\";\r\nb1.replaceAll(regex, \"$0\").toUpperCase()；\r\n\r\n```\r\n出现七个的原因我也没弄明白，而且好像这样就不会出现七个了\r\n\r\n```\r\nString b1 = b.replaceAll(\"abcdefg\", b.toUpperCase());\r\n```\r\n如果题主知道了原因也希望可以回复一下。\r\nPS：可以参考[replaceAll方法介绍](https://juejin.im/post/5d32929df265da1bc14b6497 \"\")", "Konwledge_Point": "泛型机制——模板", "Question": ["请问怎么使用replaceAll方法？怎么在泛型中使用它来将字符串小写转换成大写？", ["题目：", "\n       创建一个元素十字符串的ArrayList对象，在其中添加若干元素。编写程序，用下面3种方法将其中每个字符串转成大写。", "\n\n", "（1）使用索引循环访问", "\n\n", "（2）使用迭代器", "\n\n", "（3）使用replaceAll（）方法", "\n我想请教一下第（3）题，怎么使用replaceAll方法？", "\n我的部分代码：", "\n    ArrayList a = new ArrayList();", "\n        a.add(\"abcdrfg\");", "\n        String b = a.toString();", "\n        String b1 = b.replaceAll(b, b.toUpperCase());", "\n        System.out.println(\"使用replaceAll方法后转化的结果：\"+b1);", "\n        但像我这样使用的话，结果将会是转换了七个出来，变成这样：", "\n        使用replaceAll方法后转化的结果：[[ABCDRFG][ABCDRFG][ABCDRFG][ABCDRFG][ABCDRFG][ABCDRFG][ABCDRFG]]", "\n        请问这怎么解决呢？", "\n        麻烦各位了，谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;改一下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;MyComparator&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;implements&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Comparator&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt;&amp;gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; int &lt;span class=\"hljs-title function_\"&gt;compare&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; ele1,&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; ele2&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ele2.&lt;span class=\"hljs-title function_\"&gt;compareTo&lt;/span&gt;(ele1);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["运行完全没问题，但是编译警告，我感觉和泛型有关，但不知道该怎么改", ["题目", "\n", "选择合适的Map集合保存5位学员的学号和姓名，然后按学号的自然顺序的倒序将这些键值对一一打印出来。要求如下：", "(1)创建TreeMap集合。", "(2)使用put()方法将学号和姓名存储到Map中，", "存的时候可以打乱顺序观察排序后的效果。", "(3)使用map.keySet()获取键的Set集合。", "(4)使用Set集合的iterator()方法获得Iterator对象用于迭代键。", "(5)使用Map集合的get()方法获取键所对应的值。", "\n", "代码：", "\n", "import", " java.", "util", ".*;\n", "public", " ", "class", " ", "Test04", "\n{\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args)\n    {\n        TreeMap<", "String", ",", "String", "> ", "map", "=", "new ", "TreeMap", "<>(", "new ", "MyComparator", "());\n        ", "map", ".", "put", "(", "\"1\"", ",", "\"Lucy\"", ");\n        ", "map", ".", "put", "(", "\"4\"", ",", "\"Aimee\"", ");\n        ", "map", ".", "put", "(", "\"2\"", ",", "\"John\"", ");\n        ", "map", ".", "put", "(", "\"5\"", ",", "\"Amanda\"", ");\n        ", "map", ".", "put", "(", "\"3\"", ",", "\"Smith\"", ");\n        Set<", "String", "> ", "set", "=", "map", ".", "keySet", "();\n        Iterator<", "String", "> it=", "set", ".", "iterator", "();\n        ", "while", "(it.", "hasNext", "())\n        {\n            ", "String", " ", "key", "=it.", "next", "();\n            System.", "out", ".", "println", "(", "key", "+", "\":\"", "+", "map", ".", "get", "(", "key", "));\n        }\n    }\n}\n", "class", " ", "MyComparator", " implements Comparator\n{\n    ", "public", " ", "int", " ", "compare", "(", "Object", " obj1,", "Object", " obj2)\n    {\n        ", "String", " ele1=(", "String", ")obj1;\n        ", "String", " ele2=(", "String", ")obj2;\n        ", "return", " ele2.", "compareTo", "(ele1);\n    }\n}\n\n", "\n", "运行结果及报错内容 ：", "注: Test04.java使用了未经检查或不安全的操作。", "注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。", "\n", "我希望编译不出警告，这个程序运行没有问题，请问需要怎么改？"]], "Tag": "程序设计"}
{"Answer": "Set&lt;Integer&gt; testIds=map.keySet();  \r\n 这一行改为 Set&lt;Object&gt; testIds=map.keySet();  \r\n 原因就是key不是Integer,没别的原因.\r\n 你这个错误相当于    \r\n\t\r\n```\r\n    public static void main(String[] args) {\r\n        Map map = new HashMap();\r\n        map.put(\"a\",\"a\");\r\n        Map&lt;Integer,String&gt; m = map;\r\n        Set&lt;Integer&gt; set = m.keySet();\r\n        for (Integer integer : set) {\r\n            System.out.println(integer);\r\n        }\r\n    }\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["一个奇怪的问题，从泛型为Integer的Set中取到的遍历取到的值为String", ["public ResponseResult putAllAnswer(Map<Integer, String> map) {\n        Set<Integer> testIds=map.keySet();\n        List<Integer> errorAnswer=new LinkedList<Integer>();\n        for(Integer testId:testIds){\n            Test test=testMapper.selectByPrimaryKey(testId);\n            if(map.get(testId).equals(test.getRightAnswer())){\n                continue;\n            }else{\n                errorAnswer.add(testId);\n            }\n        }\n}\n\npublic ResponseResult putAllAnswer(HashMap<Integer, String> map) {\n        Set<Integer> testIds=map.keySet();\n        List<Integer> errorAnswer=new LinkedList<Integer>();\n        Iterator<Integer> iter=testIds.iterator();\n        while(iter.hasNext()){\n            System.out.println(iter.next().getClass());\n            Integer testId=iter.next();\n\n        }\n}\n", "\n\n", "代码如上，在执行到for循环内时，testId无法接受testIds中的数据，显示类型转换错误，String无法转换为Integer类型，非常奇怪，即使是通过Iterator遍历也无法获取set集合中的值，始终显示String无法转换为Integer类型的报错，甚至在无法通过getClass方法来获取对象的类型信息，执行该语句也会报错"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;能打出来&amp;#xff0c;肯定能    .ShopCode  出来的&amp;#xff0c;自己检查下写的代码吧&amp;#xff0c;或者发出来看看&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["ts如何读取函数返回的对象的属性？", ["函数返回了一个对象，在edge的控制台里这样显示，但是用 object.属性 的方式读不出来，怎么才能读的到呢？"]], "Tag": "程序设计"}
{"Answer": "泛型在是编译期间编译器检查 你写的代码是否符合规范\r\n比如我实现Gene\r\n\r\nclass GeneImpl&lt;A, G extends Gene&lt;A, G&gt;&gt; implements Gene{\r\n\t\r\n\t\r\n\tpublic GeneImpl(A a,G g){\r\n\t\t\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic Object getAllele() {\r\n\t\t\r\n\t\t// TODO Auto-generated method stub\r\n\t\treturn null;\r\n\t}\r\n\t\r\n}\r\n在new GeneImpl(xx,yy )是会检查你传入的参数是否合法,\r\n\r\nxx是否是A类型；yy是否是Gene或其子类型", "Konwledge_Point": "泛型机制——模板", "Question": ["复杂的java泛型定义，Gene<A, G extends Gene<A, G>>，看不懂啊，求解释？", ["Gene是最上层的接口，代码来源于国外的java遗传算法的jentics库。", "\n其中A是类型，关键是 G extends Gene", "，看不懂", "\n\n", "public interface Gene", "> ", "\n    extends Factory, Serializable, ValueType, Verifiable ", "\n{", "\n\n", "/**\n * Return the allel of this gene.\n * \n * @return the allel of this gene.\n */\npublic A getAllele();\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "纠正：用string类型实例化test_iter ：\r\ntest_iter&lt; string &gt;test1; \r\ntest1(vec_str);\r\n》》\r\n你把test_iter设计为函数模板？ \r\n试试在main函数调用的时候，先用一种类型实例化模板,，再调用：\r\n\r\ntest_iter test1; \r\ntest1(vec_str);", "Konwledge_Point": "泛型机制——模板", "Question": ["C++模板中使用STL迭代器的问题:vector<T>::iterator声明报错的原因及解决方法", ["#include<iostream>\n#include<vector>\n#include<iterator>\nusing namespace std;\n\ntemplate<class T>\nvoid test_iter(const vector<T>);\n\nint main()\n{\n    vector<string> vec_str{ \"Anthony\",\"Chou\",\"Jay\",\"Hahaha\" };\n    test_iter(vec_str);\n\n    system(\"pause\");\n    return 0;\n}\n\ntemplate<class T>\nvoid test_iter(const vector<T> vec)\n{\n    typename vector<T>::iterator iter;\n    for (iter = vec.begin(); iter != vec.end(); iter++)\n    {\n        cout << *iter << endl;\n    }\n}\n", "\n\n", "上述代码报错，原因是我使用的：", "\n\n", " vector<T>::iterator iter;\n", "\n\n", "vs2017中错误显示如下:", "\n\n", " 错误 C2679   二进制“=”: 没有找到接受“std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_Ty>>>”类型的右操作数的运算符(或没有可接受的转换)\n错误  C2679   二进制“<<”: 没有找到接受“std::basic_string<char,std::char_traits<char>,std::allocator<char>>”类型的右操作数的运算符(或没有可接受的转换)\n", "\n\n", "我试过不使用泛型而使用：", "\n\n", "vector<int>::iterator iter;\n", "\n\n", "来声明具体类型的迭代器就没有问题。", "\n求大神解答，多谢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;。。。楼上认真的&amp;#xff1f;这是泛型方法不是返回值。&lt;/p&gt;\n&lt;p&gt;简单来说&amp;#xff0c;第一个方法使用的T不是类定义时候的T&amp;#xff0c;而是泛型方法中声明的T。&lt;br /&gt;第二个方法使用的T是类定义时候的T。你这个T命名重复&amp;#xff0c;泛型方法会覆盖掉T。&lt;br /&gt;举个例子&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/628009116726120.png\" /&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["这两种构造方法等效吗?", ["这两种构造方法等效吗? 一个带泛型，一个不带泛型。", "\n", "类名如下", "public class GenericityTest < T > {", "\n", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "1. html表单对象不存在泛型.\r\n\r\n2. 如果要提交对象的话 user.id. user.name controller中可以封装.", "Konwledge_Point": "泛型机制——模板", "Question": ["springMVC 表单数据提交问题", ["如果对象是泛型，要怎样提交到controller？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这道题不涉及到泛型哈~&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["请问List的具体意义以及idea的提示", ["\n", "\n", "他让我创建内部类，但这又涉及到泛型，就问那个ingredients前面的list的具体意思是什么。当我的泛型里面的T设为String时，我的String在idea上会变成绿色，请求回答。"]], "Tag": "程序设计"}
{"Answer": "要根据你的需求去配置，如果你只要将事务控制放在DAO层，那么就只要配置DAO就可以了；如果你事务控制要放在Service层，那么就配置Service，反正只要配置一个就可以了，但只要出了所配置的范围，事务就关掉了！", "Konwledge_Point": "泛型机制——模板", "Question": ["spring AspectJ配置", ["我用了一个泛型dao.然后根据逻辑写了许多service.sevice中调用了这些dao。我想我在配置aop:advisor中的pointcut是只需配置成泛型dao就可以了，还是要把对service的也配置上？"]], "Tag": "程序设计"}
{"Answer": "再补充下，为什么参数是super返回值是extends\r\n如果我们把函数想象成一个机器，比如面包机\r\n参数是它需要的原料，比如白面粉\r\n返回值是它能做的成品，比如面包\r\n\r\n显然，对于原料我们需要提供的是白面粉或者它的派生类，比如一级白面粉、xx牌白面粉……但是如果是黑面粉，或者大米，这个面包机都不能工作。\r\n而对于结果，恰恰相反，如果你要一个面包，这个机器能满足你，如果你要点心，也没有问题，任何基类都没有问题。但是如果你要切片面包或者法国面包，这个机器未必能满足你的要求了。\r\n\r\n类似的，对于定义Lambda寒暑，我们需要让参数“严格”，用super，只能是派生类。对于返回值，我们需要让参数“宽松”，用extends，必须是基类。", "Konwledge_Point": "泛型机制——模板", "Question": ["怎样理解java中Function<? super V, ? extends T>这样的声明？", ["小白刚学java，有点C++基础，core java 10看到泛型这一章觉得和C++的泛型差别太过巨大，理解非常费劲，语法看着也及其别扭，JDK的有些API有些函数声明都看不懂。。。", "\n比如Comparator里面的这个方法：", "\npublic static  Comparator comparing(", "\nFunction<? super T, ? extends U> keyExtractor, Comparator<? super U> keyComparator)", "\n怎么理解Function<? super T, ? extends U>这个声明呢，网上查了半天都在讲生产者消费者的的准则，", "\n但好像和这个又对不上号，苦思冥想快2天了。。。求解", "\nPS：还有为啥我觉得java的泛型系统像是个半成品，好多莫名其妙的限制啊！！？？"]], "Tag": "程序设计"}
{"Answer": "可以嵌套使用的Map&lt;String,List&lt;Object&gt;&gt;??????? 可以的\r\nQQ5339763", "Konwledge_Point": "泛型机制——模板", "Question": ["freemark同时得到两个数据源", ["能不能同时给模板传两个数据源啊。", "\n\n", "我有两个类型的数据list list 能不能同时传给模板啊。大家遇到这种情况怎么处理的啊。", "\nMap> root=null;", "\n.......", "\ntemplate.preXX(root,out);", "\n\n", "很明显 root中只能放list.我不能把list也放进去。难道要Map>???????", "\n[b]问题补充：[/b]", "\n呵呵。怎么不说的详细点啊。", "\n我解决了。给freemarker的数据源定义成map不用用泛型。这样就可以了。", "\n但最终的类型一定要指明。否则播 它是一个date string number....."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/756186461746191.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["继承上限和下限的问题", ["为什么泛型继承上限和继承下限的时候add与get方法不能调用"]], "Tag": "程序设计"}
{"Answer": "```\r\nList ap= Collections.checkedList(aps,Pair&lt;String&gt;.class);\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["java获取Pair<String>的class", ["我的疑问是改用泛型哪里，checkedList第二个type参数该写什么", "\n\n", "//一般用法:\n          List<String> aps=new ArrayList<String>();\n        List ap= Collections.checkedList(aps,String.class);\n//改用泛型\n        List<Pair<String>> aps=new ArrayList<Pair<String>>();\n        List ap= Collections.checkedList(aps,__**??????**__);\n"]], "Tag": "程序设计"}
{"Answer": "如果在同一个module下,可以直接import,,,但是如果在不同的module下,就要pom依赖一下,然后引用对应的类", "Konwledge_Point": "泛型机制——模板", "Question": ["maven的依赖和import的依赖有区别吗", ["看视频，讲到一个工程里用到另一个pojo工程里某个类的泛型。然后讲师就在pom.xml文件的坐标里添加了这个pojo的 依赖。我想问，如果写了泛型，然后不是会有下面红线吗，鼠标放在上面 会自动显示让你引入什么东西。就是你点击之后会在最上面出现import xxxx,xxx,这一句话。这两种一样吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;找到两个方法......真傻比不先去看文档&lt;br /&gt;第一个就是可以通过LambdaMetafactory将Method转为SFunction&lt;br /&gt;第二个就是调用apply方法&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["LambdaQueryWrapper能通过字段名添加参数吗？", ["现在就是想通过泛型传递", "\n", "LambdaQueryWrapper", "<", "T", ">", "\n", "\n", "现在就只有一个字段名传递进来，可以通过字段名存放吗？", "然后再.select(SFunction)", "\n", "不想用QueryWrapper，不利于扩展"]], "Tag": "程序设计"}
{"Answer": "不需要，Linq的Context对象可以用Dispose()", "Konwledge_Point": "泛型机制——模板", "Question": ["link查询完毕要不要释放内存啊？", ["link查询结束以后如何释放内存？泛型集合可以用Clear释放，那么link用什么语句释放内存呢？"]], "Tag": "程序设计"}
{"Answer": "之前以为是cglib的原因，但是去掉@Transactional后还是一样调用两次，求教啊！\r\n\r\n你的以为是对的  你可以使用AopUtils.isAopProxy() 看看是不是代理", "Konwledge_Point": "泛型机制——模板", "Question": ["为什么Spring项目中父类构造被调用两次", ["父类：", "\npublic abstract class AbstractAccountOperateBase{", "\n//构造方法", "\npublic AbstractAccountOperateBase(){", "\n//获取泛型类型，经调试，有两次调用，第一次泛型正确，第二次泛型为Object", "\n}", "\n子类：", "\n@Service", "\n@Transactional", "\npublic class A0ReadListener extends AbstractAccountOperateBaseimplements IAccountListener,Runnable{}", "\n\n", "而下面两个父子类就没有这种情况", "\n父类：", "\npublic abstract class AbstractWriteFileExdat extends AbstractWriteFile {}", "\n子类：", "\n@Service", "\npublic class EpWriteExdat extends AbstractWriteFileExdat{}", "\n\n", "这是为什么呢，实在想不明白，之前以为是cglib的原因，但是去掉@Transactional后还是一样调用两次，求教啊！"]], "Tag": "程序设计"}
{"Answer": "Android  支持反射  但是还没有Spring这样的框架", "Konwledge_Point": "泛型机制——模板", "Question": ["Android  有没有spring框架", ["Android  有没有spring框架", "\n\n", "查了下资料，Android 是用java开发的 不过用的是Android SDK", "\n\n", "不知道支不支持 泛型，反射等。", "\n有没有spring 框架 8) "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先给你解释一下代码&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/89413040656611.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;先优化一下代码&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/034527406566154.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;再优化一下&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/634465506566144.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["JS 相关代码解答 实现的目标应该是检测输入文本是否是全部由字母组成的！", ["求具体分析分析各行到底是什么意思，多谢！", "\n", "\n", "var", " button = ", "document", ".", "querySelector", "(", "'button'", ")\n            \n            button.", "onclick", " = ", "function", "(", "){\n                ", "var", " text = ", "document", ".", "querySelector", "(", "'input'", ").", "value", ".", "toLowerCase", "()\n                ", "prompt", "(text)\n                ", "console", ".", "log", "(text.", "length", ")\n                ", "function", " ", "prompt", "(", "text", "){\n                    ", "var", " b = ", "true", "\n                    \n                    ", "for", "(", "var", " i=text.", "length", ";i>", "0", ";i--){\n                        ", "if", "(text[i]>=", "0", " && text[i]<=", "9", "){\n                            b = ", "false", "\n                        }\n                        \n                    }\n                    ", "if", "(b){\n                        ", "alert", "(", "\"您使用了泛型窗口\"", ")\n                    }", "else", "{\n                        ", "alert", "(", "\"您没有使用泛型窗口\"", ")\n                    }\n                    \n                    \n                }\n                \n            }\n            \n"]], "Tag": "程序设计"}
{"Answer": "即使你使用\r\npublic class Test&lt;E extends Test&lt;E&gt;&gt; {\r\n\tpublic E get (E e) {\r\n\treturn e;\r\n\t}\r\n} \r\n\r\n\r\n那么他的子类最好轻便一些，照你这样可读性都不好，子类最好这样\r\n\r\npublic class Test1 extends Test&lt;Test1&gt; {\r\n\t\r\n}\r\n\r\n\r\n直接Test&lt;Test1&gt; test=new Test&lt;Test1&gt;();声明就好，全部通过", "Konwledge_Point": "泛型机制——模板", "Question": ["请问如何实例化这个类public static class Test<E extends Test<E>> ", ["最近研究Java泛型，请问怎么创建这个类的实例：", "\n\n", "public static class Test> {", "\n    public E get (E e) {", "\n        return e;", "\n    }", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/866435984146135.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;这是是否缺少了集合的表示&amp;#xff0c;是否应该增加一个[]&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["yml一个对象里面嵌套了一个对象，嵌套对象里面的数据无法添加", ["我建了一个集合，集合的泛型是usrs，，而user这个对象里面又有一个名为cat的对象", "我的cat对象无法注入成功", "\n", "create对象", "\n", "user对象", "\n", "\n", "cat对象", "\n", "执行结果", "\n"]], "Tag": "程序设计"}
{"Answer": "我把整个BaseDaoImpl 发上来了，JdbcTemplate jt;是用spring的set注入方式注入的，你也不用改什么东西了。\r\nSpring配置文件中，加入以下代码\r\n\t&lt;bean id=\"BaseDao\" class=\"com.global.dao.impl.BaseDaoImpl\"&gt;\r\n\t\t&lt;property name=\"jt\" ref=\"jdbcTemplete\"&gt;&lt;/property&gt;\r\n\t\t&lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;\r\n\t&lt;/bean&gt;\r\n\r\n\t&lt;bean id=\"jdbcTemplete\"\r\n\t\tclass=\"org.springframework.jdbc.core.JdbcTemplate\"&gt;\r\n\t\t&lt;constructor-arg ref=\"dataSource\"&gt;&lt;/constructor-arg&gt;\r\n\t&lt;/bean&gt;\r\n\r\n下面的代码中，动态Bean部分的注释我没有加，你自己去网上搜索一下，有很多解释的\r\n\r\n\r\n\r\nimport java.io.Serializable;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.sql.Connection;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport org.apache.commons.beanutils.BasicDynaClass;\r\nimport org.apache.commons.beanutils.DynaBean;\r\nimport org.apache.commons.beanutils.DynaClass;\r\nimport org.apache.commons.beanutils.DynaProperty;\r\nimport org.apache.commons.beanutils.PropertyUtils;\r\nimport org.hibernate.Session;\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\nimport org.springframework.orm.hibernate3.HibernateTemplate;\r\nimport org.springframework.orm.hibernate3.support.HibernateDaoSupport;\r\n\r\nimport com.global.dao.BaseDao;\r\nimport com.global.db.HibernateSessionFactory;\r\n\r\n\r\npublic class BaseDaoImpl extends HibernateDaoSupport implements BaseDao {\r\n\t\r\n\tprivate JdbcTemplate jt;\r\n\r\n\tpublic JdbcTemplate getJt() {\r\n\t\treturn jt;\r\n\t}\r\n\r\n\tpublic void setJt(JdbcTemplate jt) {\r\n\t\tthis.jt = jt;\r\n\t}\r\n\r\n\tpublic void delete(Object o) {\r\n\t\tsuper.getHibernateTemplate().delete(o);\r\n\r\n\t}\r\n\r\n\tpublic Object get(Class cls, Serializable id) {\r\n\t\treturn  super.getHibernateTemplate().get(cls, id);\r\n\t}\r\n\r\n\tpublic List list(String hql) {\r\n\t\treturn super.getHibernateTemplate().find(hql);\r\n\t}\r\n\r\n\r\n\tpublic void save(Object o) {\r\n\t\tsuper.getHibernateTemplate().save(o);\r\n\r\n\t}\r\n\r\n\tpublic void update(Object o) {\r\n\t\tsuper.getHibernateTemplate().update(o);\r\n\r\n\t}\t\r\n\t\r\n   //JdbcTemplate\r\n\tpublic List listArraryByJdbc(String sql, Object[] objs) {\r\n\t\tList list = jt.queryForList(sql, objs);\r\n\t\treturn list;\r\n\t}\r\n\r\n\tpublic List listByJdbc(String sql) {\r\n\t\tList list = jt.queryForList(sql);\r\n\t\treturn list;\r\n\t}\r\n\r\n\tpublic int getInt(String sql) {\r\n\t\tint count =jt.queryForInt(sql);\r\n\t\treturn count;\r\n\t}\r\n\r\n\tpublic int getInt(String sql, Object[] objs) {\r\n\t\tint count =jt.queryForInt(sql,objs);\r\n\t\treturn count;\r\n\t}\r\n\t\r\n\t\r\n\t/*用来执行用户自定义select语句，一般用于多表查询时，查询的字段为动态\r\n\t * 要用到动态Bean\r\n\t * \r\n\t * */\r\n\tpublic List listForJdbcCustom(String sql){\r\n\t\t\r\n\t\tConnection con = null;\r\n\t\tStatement stm = null;\r\n\t\tResultSet rs = null;\r\n\t\t//结果集元数据，即select * from... 指的是*中的的字段\r\n\t\tResultSetMetaData rsmd = null;\r\n\t\tList list = new ArrayList();\r\n\r\n\t\tint columns = 0;\r\n\t\ttry {\r\n\t\t\t//获取Connection\r\n\t\t\tcon = jt.getDataSource().getConnection();\r\n\r\n\t\t\tif (con == null)\r\n\t\t\t\treturn null;\r\n\t\t\t//获取statement\r\n\t\t\tstm = con.createStatement();\r\n\t\t\tif (stm == null)\r\n\t\t\t\treturn null;\r\n\t\t\t//执行查询语句\r\n\t\t\trs = stm.executeQuery(sql);\r\n\t\t\tif (rs == null)\r\n\t\t\t\treturn null;\r\n\t\t\t//通过结果集，初始化结果集元数据集合\r\n\t\t\trsmd = rs.getMetaData();\r\n\t\t\t//获取列数，即select * from... 指的是*中的的字段数目\r\n\t\t\tcolumns = rsmd.getColumnCount();\r\n\t\t} catch (SQLException e1) {\r\n\t\t\te1.printStackTrace();\r\n\t\t}\r\n\t\t//初始化一个动态属性数组\r\n\t\tDynaProperty[] px = new DynaProperty[columns];\r\n\t\tString prop[] = new String[columns];\r\n\r\n\t\tfor (int i = 0; i &lt; columns; i++) {\r\n\t\t\ttry {\r\n\t\t\t\tprop[i] = rsmd.getColumnLabel(i + 1);\r\n\t\t\t} catch (SQLException e1) {\r\n\t\t\t\te1.printStackTrace();\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tpx[i] = new DynaProperty(prop[i], Class\r\n\t\t\t\t\t\t.forName(\"java.lang.String\"));\r\n\r\n\t\t\t} catch (ClassNotFoundException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\t//之后的就是关于动态Bean的知识了，你可以去网上搜索DynaBean或者DynaClass去学习一下相关知识\r\n\t\tDynaClass dynaClass = null;\r\n\t\t\r\n\t\t\r\n\t\tDynaBean dynaBean;\r\n\r\n\t\ttry {\r\n\t\t\twhile (rs.next()) {\r\n\r\n\t\t\t\tdynaClass = new BasicDynaClass(\"dynaBean\", null, px);\r\n\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdynaBean = dynaClass.newInstance();\r\n\t\t\t\t} catch (IllegalAccessException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t} catch (InstantiationException e) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int i = 1; i &lt;= columns; i++) {\r\n\t\t\t\t\tObject temp = rs.getObject(i);\r\n\r\n\t\t\t\t\tif (temp == null)\r\n\t\t\t\t\t\ttemp = \"\";\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\ttemp = rs.getObject(i).toString();\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tPropertyUtils.setProperty(dynaBean, prop[i - 1], temp);\r\n\t\t\t\t\t\t// test\r\n\t\t\t\t\t\t//System.out.println(\"prop = \" + prop[i - 1]);\r\n\t\t\t\t\t\t// test\r\n\t\t\t\t\t\t//System.out.println(\"value = \" + temp);\r\n\t\t\t\t\t} catch (IllegalAccessException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t} catch (InvocationTargetException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t} catch (NoSuchMethodException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tlist.add(dynaBean);\r\n\t\t\t}\r\n\t\t} catch (SQLException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tif (con != null)\r\n\t\t\t\t\tcon.close();\r\n\t\t\t\tif (stm != null)\r\n\t\t\t\t\tstm.close();\r\n\t\t\t\tif (rs != null)\r\n\t\t\t\t\trs.close();\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn list;\t\r\n\t}\r\n\t\r\n}", "Konwledge_Point": "泛型机制——模板", "Question": ["Hibernate多表查询的问题", ["用Hibernate，在数据库表设计的时候不设计表之间外键关系，所以在hbm文件里也不存在one-to-many之类的配置信息，现在要进行多表查询，比如student表和course表，进行查询：select student.sno,course.coursename from sutdent,course where student.courseid=course.id;使用List接受返回类型。我现在需要开发webservice，故在List后要加泛型（List ），否则无法发布。请问这个泛型应该是什么？是不是需要一个student类和course类的中间类？这个中间类是否可以动态生成？（需要查的时候动态创建，查询完毕后动态销毁）。", "\n[b]问题补充：[/b]", "\n请问xiaoyu966，能否加一些注释？我是个初学者，不太能看懂。谢谢了！"]], "Tag": "程序设计"}
{"Answer": "你项目启动时注入redisTemplate2报错，是因为redisTemplate2实例没有初始化出来，你看看你配置文件", "Konwledge_Point": "泛型机制——模板", "Question": ["SSM整合redis报错 ,进来看一看", ["1、项目中添加redis，启动报错，把StringRedisTemplate redisTemplate2注释之后就可以启动。", "\n2、存入的对象也进行了序列化", "\n3、autoweird，Resource都试了", "\n4、只注入RedisTemplate redisTemplate2，加泛型和不加泛型都试了，启动还是报错", "\n\n", "大佬们，求求了", "\n\n", "具体报错问题：", "\n\n", "\n\n", "\n\n", "\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "没听说过这个概念呢，倒是Eclipse的类的Outline展示类的全部结构信息的。\r\n应该就是展示一个类的成员组成结构，便于分析和查看吧。", "Konwledge_Point": "泛型机制——模板", "Question": ["请问什么是java类分析器", ["今天看一篇泛型文章提到一个叫类分析器的对象，请问是什么来的，软件？可以下载的吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里的泛型 U extends Comparable&amp;lt;? super U&amp;gt; 表示 U实现了Comparable接口。&lt;br /&gt;这里的Function是一个函数式接口&amp;#xff0c;原型是Function&amp;lt;T,R&amp;gt;&amp;#xff0c;T是参数类型&amp;#xff0c;R是返回类型。在这里整体用作参数是为了用于lambda表达式。&lt;br /&gt;该方法用发是进行比较排序时用的&amp;#xff0c;例如对一个list进行排序如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;List&amp;lt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;&amp;gt; stringList &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();\nstringList.sort&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(Comparator.comparing((&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt; str) -&amp;gt; {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; str;\n}))&lt;/span&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因为String是实现了Comparable接口&amp;#xff0c;默认是升序。这里的(String str)就相当于是T&amp;#xff0c;return str;相当于是R返回的是字符串。也就是R是返回了实现了Comparable接口的对象。这个还可以进一步优化如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;List&amp;lt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;&amp;gt; stringList &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new &lt;/span&gt;&lt;span class=\"hljs-class title_\"&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();\nstringList.&lt;span class=\"hljs-property\"&gt;sort&lt;/span&gt;(Comparator.&lt;span class=\"hljs-property\"&gt;comparing&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt; -&amp;gt; &lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;希望对你有帮助&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["有谁可以帮解释一下 ，一个Java的题", ["请解释代码对接口中的泛型是如何进行约束的？并举例该接口如何使", "用？", "public static <T, U extends Comparable<? super U>> Comparator", "comparing(", "Function<? super T, ? extends U> keyExtractor){", "return (Comparator) (c1, c2) -> keyExtractor.apply(c1).compareTo(", "keyExtractor.apply(c2));", "}"]], "Tag": "程序设计"}
{"Answer": "已解决, 此方法是为了防止一个JDK的bug, 该bug会把普通数组反射成泛型数组, 该方法就是把这个错误的泛型数组还原成普通数组.\r\nhttps://bugs.java.com/bugdatabase/view_bug.do?bug_id=5041784", "Konwledge_Point": "泛型机制——模板", "Question": ["这个方法有什么用? (com.sun.beans.TypeResolver#fixGenericArray)", ["private static Type fixGenericArray(Type var0) {\n    if (var0 instanceof GenericArrayType) {\n        Type var1 = ((GenericArrayType)var0).getGenericComponentType();\n        var1 = fixGenericArray(var1);\n        if (var1 instanceof Class) {\n            return Array.newInstance((Class)var1, 0).getClass();\n        }\n    }\n\n    return var0;\n}\n", "\n\n", "最近在研究Java泛型的时候碰到这个方法, 但是想了半天也不知道这个方法到底有什么用.", "\n能够成为泛型数组componentType的只有以下这几种类型(这里的List和String只是作为例子): T, List<T>, List<String>, 即ParameterizedType和TypeVariable, 而不可能是原始类型, 因为形如String[]或者多维数组String[][]等形式, 它本身就不属于GenericArrayType, 而是Class. 所以, 以上代码到底有什么用?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、抽取公众方法&amp;#xff0c;把setUserIdList放在公共的接口&amp;#xff0c;比如定义接口 &lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;interface&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;IUserInterface&lt;/span&gt;{\n  &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; setUserIdList(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、然后公共方法的入参全部改为IUserInterface和user&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;handleXX&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;IUserInterface form,User user&lt;/span&gt;){\n  ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、最后每个具体实现&amp;#xff0c;自己实现IUserInterface接口的setUserIdList方法就行&amp;#xff1b;&lt;/p&gt;\n&lt;p&gt;如有疑问&amp;#xff0c;欢迎交流&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["多个方法调用同一行代码，如何优化", ["在项目中遇到了一个问题，在多个方法中调用了同一段代码，把代码提取出来之后，因为入参不一样，所以没办法通用，想到用反射，泛型去写一个通用方法，但是实在不会，能写出来借鉴一下么"]], "Tag": "程序设计"}
{"Answer": "Dictionary&lt;char,int&gt; dic = new Dictionary&lt;char,int&gt;();\r\ndic.Add('1',1);\r\n\r\nList&lt;Dictionary&lt;char,int&gt;&gt; list = new List&lt;Dictionary&lt;char,int&gt;&gt;();\r\nlist.Add(dic);", "Konwledge_Point": "泛型机制——模板", "Question": ["List<Dictionary<char, int>>怎么添加数据", ["新手求教。请问声明这样一个泛型 ", "\nList> list = new List>();", "\n怎么往里面添加数据 比如想在里面添加一个键值对 键为‘1’  值为 1的数据", "\n list.add(里面怎么写？);"]], "Tag": "程序设计"}
{"Answer": "```\r\n return p.Price&gt;10m;\r\n相当于\r\nif (p.Price&gt;10m) return true; else return false;\r\n如果不是bool的话能在Predicate这个泛型委托上注册吗\r\n不能\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["关于c#匿名方法的请教？", ["我最近正在研究c# in depth这本书，读到一句", "\npredicate test=delegate(product p){return p.Price>10m;};其中，product是一个类。我有点看不懂，该匿名方法的返回值是什么？如果不是bool的话能在Predicate这个泛型委托上注册吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;String.join()第二个参数应该是一个&lt;code class=\"language-javascript\"&gt;Iterable&amp;lt;? extends CharSequence&amp;gt; &lt;/code&gt;而不是一个Iterator &amp;#xff0c;你直接&lt;code class=\"language-javascript\"&gt;String join &amp;#61; String.join(&amp;#34;-&amp;#34;, strings);&lt;/code&gt;&amp;#xff0c;用迭代器反而多此一举&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["String.join（）该方法编译异常？", ["String[] stra = {\"abc\", \"cba\"};", "List strings = Arrays.asList(stra);", "Iterator iterator = strings.iterator();", "String join = String.join(\"-\", iterator);", "System.out.println(join);", "String.join（）这行怎么编译不过去，哪里有问题。传入的参数也没有问题啊，迭代器泛型也符合。"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201709/14/1505350107_220135.png)\r\n\r\n表设计如下：\r\n![图片说明](https://img-ask.csdn.net/upload/201709/14/1505350273_846249.png)\r\n\r\n分析：如果是主键则使用String来查询是不成功的，如果不是主键则使用String来查询时会自动做类型转换，可以操作成功。这应该是数据库的容错机制吧，\r\n最好数据类型还是与数据库的一一对应。你们公司这么做的话可能处于：1、以前的代码就是这样，运行无误便无需改了；2、将String改成int会设计到较多\r\n代码的改动；3、处于特殊的设计需求...直接问老员工啦！！！", "Konwledge_Point": "泛型机制——模板", "Question": ["关于mybatis的一个问题", ["最近在看一个项目，看到购物车模块的时候，有个批量删除购物车商品的方法。", "\n有点搞不懂，数据库里商品ID是int类型，而人家dao层代码里却传入String", "\n泛型的List集合,还能从数据库操作成功。（不是应该传一个int数组，遍历删除的吗？）", "\n为什么啊？这样做有什么好处？请大牛们指点迷津"]], "Tag": "程序设计"}
{"Answer": "看一下这个，一览表\r\n\r\nhttp://www.tot.name/show/3/7/20050323090841.htm", "Konwledge_Point": "泛型机制——模板", "Question": ["jdk1.5的新特性有哪些?", ["jdk1.5的新特性具体有哪些......", "\n[b]问题补充：[/b]", "\n“JDK1.5”（开发代号猛虎）的一个重要主题就是通过新增一些特性来简化开发，这些特性包括泛型，for-each　循环，自动装包/拆包，枚举，可变参数,　静态导入　。使用这些特性有助于我们编写更加清晰，精悍，安全的代码。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;public interface Comparable&amp;lt;String&amp;gt;{\n    public int compareTo(String string);\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;他是说这个意思吧&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["谁可以告诉我这句话是什么意思", ["\n", "\n是把comparable接口泛型定义成字符串String类是不？然后用String\n\n", "\n\n", " ", "\n\n", " ", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "springside不是早就基于spring-data-jpa了么，哪里来的HibernateDao这个类。\r\n\r\n另外你这个sql写的。。。,联合查询两表之间没有连接也可以？？", "Konwledge_Point": "泛型机制——模板", "Question": ["springside 多表查询，急，", ["public class VideoManager extends HibernateDao{", "\n类是用泛型，但我想查出video和user两个实体里的东西，", "\nhql=\"select * from User u,Video v where u.id=? and v.id=?\";", "\n查询不到，报的错误", "\nunexpected token: * near line 1, column 8 [select * from com.vision.movland.object.User u,com.vision.movland.object.Video v where u.id=? and v.id=?]"]], "Tag": "程序设计"}
{"Answer": "请问丢进来的stuid是Map么？你XML里参数写着parameterClass=\"java.util.Map\"\r\n我看你的SQL语句，判断stuid就是一个普通类型吧  这个不应该是parameterClass=\"java.lang.String\"或者parameterClass=\"java.lang.Integer\"吗？\r\n照样用##吧", "Konwledge_Point": "泛型机制——模板", "Question": ["ibatis传参数用#stuid#传不进去，用$stuid$就可以，大家看看为什么啊？", ["<typeAlias alias=\"product\" type=\"com.cms.pojo.TBankproddata\" />\n\n<select id=\"getProd\" parameterClass=\"java.util.Map\" resultClass=\"product\">\n    select stuid,stuname   from student   stuid = '$stuid$'\n\n</select>\n", "\n\n", "这是sql语句，现在可以查询出来泛型的list，但是我换成#stuid#，就是空的，不报错，返回的list为空，郁闷啊，ibatis的包换了两个了，不知道是哪里的问题 "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;T表示泛型,类型约束&lt;br /&gt;LIst&lt;a id=\"textarea_1652260715401_1652261228551_0\"&gt; robot表示集合List类型A.比如A是String表示集合里面数据的类型为String类型&lt;/a&gt;&lt;/p&gt;&lt;a id=\"textarea_1652260715401_1652261228551_1\"&gt;\n&lt;/a&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["ArrayList的用法+IJ报错", ["创建一个Interface crudRobot管理机器人的增删查改操作，机器人存放ArrayList或者LinkedList里。Interface crudRobot定义如下：", "\n", "Interface crudRobot{\n        ", "void", " ", "creat", "(List<A> robot)", ";\n        ", "void", " ", "display", "(List<A> robot)", ";\n        ", "void", " ", "delete", "(List<A> robot, <T> t)", "; ", "//删除元素t", "\n        ", "void", " ", "update", "(List<A> robot, <T> t)", "; ", "//更改元素t", "\n}\n", "\n", "这个说不是设置成interface 那做一个类的话，我是继承了原有的Robot类，但是在IJ里一直报错。这个List", "robot是什么意思呀？T是指泛型?", "\n"]], "Tag": "程序设计"}
{"Answer": "刚刚毕业的话，公司根本不会要求你太多东西！你自己也说了你会了那些东西，也可以编程！就是不断累积的过程，去了公司日积月累你就知道要学什么了！\r\n不是每个公司的技术五花八门。都是有一个唯一的开发语言，开发工具等等一系列，特定好的！如果你想从事底层，就c。c++多看看，openGL图形多看看，数据结构那些用c++自己实现实现，\r\n工作上，慢慢来就好！\r\n没你想的，好像我非要什么都会，才能找到的工作！谁公司会乱七八糟用一些关系不上的东西？", "Konwledge_Point": "泛型机制——模板", "Question": ["关于c++的继续学习问题", ["我已经熟悉了C++的基本语法(包括封装，继承，多态，等等)，了解泛型编程，STL的使用，以及一些基本的数据结构和排序算法，了解多线程(并发)编程，网络编程，想要能在企业创造价值(毕业时主要想从事偏底层软件开发，可附带些界面编程的)，需要熟练那些技术，以及推荐哪些书看(除了一些基本的语法书，其他的基本没看过几本)，希望已经工作了的，或是有经验的朋友能解答下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;con类你没有声明是泛型类&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["这里为什么报错？请问哪里出了问题？", ["这里为什么报错？请问哪里出了问题？求详解？", "package test;", "class Con{", "    private T value;", "\n", "public", " ", "Con", "(T value) {\n    ", "this", ".", "value", "=value;\n}\n\n", "public", " T ", "getValue", "(", ") {\n    ", "return", " value;\n}\n\n", "public", " ", "void", " ", "setValue", "(", "T value", ") {\n    ", "this", ".", "value", " = value;\n}\n", "\n", "}", "public class test5 {", "\n", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n    ", "Con", "<", "String", "> c=", "new", " ", "Con", "<", "String", ">(", "\"构造方法中使用泛型\"", ");\n    ", "System", ".", "out", ".", "println", "(c.", "getValue", "());\n}\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;  ContentValues &lt;span class=\"hljs-built_in\"&gt;values&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; ContentValues();\n  &lt;span class=\"hljs-built_in\"&gt;values&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;put&lt;/span&gt;(“属性名称&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;”, 属性值&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n  &lt;span class=\"hljs-built_in\"&gt;values&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;put&lt;/span&gt;(“属性名称&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;”, 属性值&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n  db.insert(“表名”, null, &lt;span class=\"hljs-built_in\"&gt;values&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面这个是每次插入一次数据的&amp;#xff0c;你的List遍历一下&amp;#xff0c;一个对象插入一次咯&lt;br /&gt;记得创建表的时候也要有这些字段&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["如何用SQLite存储从手机中扫描出来的本地音乐列表", ["想把本地的手机上的音乐，扫描出来，放入SQLite数据库中，下次打开App以后，就不用再去搜索了。现在是数据库的存储多条数据，我用了insert但是，有多条数据，且是想存储为一个实体类的对象的形式，不知道怎么弄呀？。。", "下面是这个从SK卡里面查询出来了手机上的本地音乐，用的是实体列表的", "\n", "//数据源", "\n    ", "private", " ", "static", " List<TuyuEntityImpl> mTuyuEntityImpl = ", "new", " ", "ArrayList", "<>();\n\n", "@Override", "\n            ", "public", " ", "void", " ", "scanTuyuStop", "()", " {\n                mProgressDialog.dismiss();", "//结束扫描就关闭Dialog", "\n                mTuyuEntityImpl.addAll(TuyuManager.getInstance().getClientImpl().getTuyuList());\n                ", "for", "(", "int", " i=", "0", ";i<mTuyuEntityImpl.size();++i){\n", "//                    mTuyuEntityImpl.get(i).save();//LitePal 数据库的 写法", "\n\n                    ", "DBTuyuHelper", " ", "dbTuyuHelper", " ", "=", " ", "null", ";\n                    SQLiteDatabase db;\n                    ContentValues values;\n                    ", "String", " ", "tableName", " ", "=", " ", "\"tuyu\"", ";\n\n                    db = dbTuyuHelper.getWritableDatabase();\n", "//                    values.put(\"tuyuName\");", "\n                    db.insert(tableName,", "null", ",mTuyuEntityImpl);\n                    db.close();\n\n                }\n", "\n", "就是在db.insert  这里会出问题。", "\n", "\n", "它说需要一个 ContentValues，我这里是一个多条数据的 对象性的东西，怎么给它存进去呀？", "\n", "在网上找了些资料，我接收到的是一些数组List的，我不太清楚怎样将其中泛型的类的值，给下面的添加数据的addTuyu()方法里面，一个是List的，虽然泛型是tuyuEntityImpl ，下面要调出实体类的字段", "\n", "\nList", "<", "TuyuEntityimpl", ">", "  tuyuEntityImpl\n", "\n", "所以下面类型不对，得不到，该怎么做？", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里很好的解释了&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/y506798278/article/details/104503588/\" id=\"textarea_1657682137919_1657682350566_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Java8 Lambda表达式&amp;#xff08;二&amp;#xff09;System.out::println与Lambda表达式_大海_sea的博客-CSDN博客_lambda system.out&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;1 System.out::println在哪里出现    在Java中&amp;#xff0c;执行System.out.println(&amp;#34;hello world&amp;#34;);会在控制台打印“hello world”;而在Java8引入了Lambda表达式这一新特性后&amp;#xff0c;是可能出现System.out::println这样的代码的&amp;#xff0c;比如下面这段代码。public class TestPrint {    pu...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/y506798278/article/details/104503588/&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA中关于lambda表达式的一些问题", ["  ", "@Test", "    public void iterTest() {", "        List", " languages = Arrays.asList(\"java\",\"scala\",\"python\");", "        //before java8", "        for(String each:languages) {", "            System.out.println(each);", "        }", "        //after java8", "        languages.forEach(x -> System.out.println(x));", "        languages.forEach(System.out::println);", "    }", "请问，这里的System.out.println为什么可以使用lambda表达式，lambda表达式不是必须用在函数式接口上吗？另外，数组构造器怎么构造泛型数组。"]], "Tag": "程序设计"}
{"Answer": "比如说你用一个数组作为散列表，那么如果数组长度为100，而其中的75个元素已经被填满，则此时装载因子就是75%，也就是说装载因子就是目前已经填满的位置的数目除以散列表总容量的比值\r\n而对于容量增大，比如还是这个长度为100的数组，目前已经使用75个单位，达到了装载因子，那么就把数组的长度扩充为200，这样就是容量变为原始容量的二倍\r\n对于散列映射，关键的是散列函数，散列函数决定一个数据的存储位置，一般采用取模的方法，比如散列函数为x%7，那么每一个要存储的值都要模7，比如10%7=3，那么就把10放在下标为3的位置上，而11%7=4，就放在下标为4的位置上\r\n不要把它想得那么复杂，当成数组来理解会好理解一些", "Konwledge_Point": "泛型机制——模板", "Question": ["java中散列映射的数据结构问题", ["学java集合框架的时候，书上讲HashMap泛型类的时候，讲到散列映射。", "\n其中这句话不太理解:", "\n散列映射在它需要更多的存储空间时会自动增大容量。例如，如果散列映射的装载因子是0.75，那么当散列映射的容量被使用了75%时，它就把容量增加到原始容量的2倍。", "\n这句话不太理解，什么是装载因子？怎么增大？散列映射究竟怎么存储数据？去百度也没太整清楚，希望有大神给个系统的解释"]], "Tag": "程序设计"}
{"Answer": "你是说String ch=\"\";这个嘛；不是String =\"\";这个吧。String本身是java的一种数据类型，String ch=\"\";这个便是定义了一个String类型的字符串变量ch，并给它赋了一个“”空值，相当于初始化", "Konwledge_Point": "泛型机制——模板", "Question": ["刚学完Java，做了一个简易计算器，但是不明白String =\"\";  是什么意思，希望大佬能帮帮我", ["package calc;", "\n\n", "import javax.swing.*;", "\n\n", "import java.util.ArrayList;", "\n\n", "import java.util.List;", "\n\n", "import java.util.regex.*;", "\n\n", "import java.awt.*;", "\n\n", "import java.awt.event.*;", "\n\n", "public class calc extends JFrame implements ActionListener {", "\n\n", "JPanel p1 = new JPanel();\nJPanel p2 = new JPanel();\nJButton button[]=new JButton[18];\nTextField field = new TextField(10);// 文本框\nprivate calc() {\n    p1.setLayout(new GridLayout(4,4));\n    field.setFont(new Font(\"Arial\",Font.BOLD,22));\n    field.setEditable(false);//文本框不可编辑\n    p2.add(field);\n    char ch[][]= {{'7','8','9','/'},{'4','5','6','*'},{'1','2','3','-'},{'0','.','+','='}};\n    for(int i=0;i<4;i++) {\n        for(int j=0;j<4;j++) {\n            button[i*4+j]=new JButton(\"\"+ch[i][j]);\n            button[i*4+j].addActionListener(this);\n            p1.add(button[i*4+j]);\n        }\n    }\n    button[16]=new JButton(\"<——\");\n    button[17]=new JButton(\"清空\");\n    button[16].addActionListener(this);\n    button[17].addActionListener(this);\n    p2.add(button[16]);\n    p2.add(button[17]);\n    this.setTitle(\"计算器\");\n    this.setVisible(true);\n    this.setResizable(false);//窗口不可拉伸\n    this.add(p1,BorderLayout.SOUTH);\n    this.add(p2,BorderLayout.CENTER);\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();//获取屏幕尺寸\n    int Width = (int) screenSize.getWidth();\n    int Height = (int) screenSize.getHeight();\n    this.setBounds((Width-225)/2,(Height-323)/2,300,250);//计算器大小\n    this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n}\nString ch=\"\";\npublic void actionPerformed(ActionEvent e) {// 单击按钮事件处理\n    if(e.getSource()==button[16]||e.getSource()==button[17]){\n        if(e.getSource()==button[16]) {\n            if(!ch.isEmpty()) {//判断是否为空\n                ch=ch.substring(0,ch.length()-1);//后退一格\n            }\n        }\n        else ch=\"\";\n    }\n    else {\n        if(e.getSource()==button[15]) {//等号\n            Double dd=Calculation(ch.trim());//trim去掉字符串两端的空格\n            if(dd==Double.MAX_VALUE) {\n                field.setText(\"error!\");\n                validate();\n                return ;\n            }\n            else ch=dd.toString();\n        }\n        else {\n            ch+=e.getActionCommand().toString().trim();\n        }\n    }\n    if(ch.isEmpty())  field.setText(\"0\");\n     else field.setText(ch);\n    validate();\n}\nprivate double Calculation(String ch){\n    //从字符串中提取运算符\n    Pattern patt = Pattern.compile(\"\\\\+|\\\\-|\\\\*|\\\\/\");//正则表达式\n    Matcher matc = patt.matcher(ch);//匹配器\n    List<String> lis = new ArrayList<>();//泛型\n    while(matc.find()) {//find()对任意字符串进行匹配\n        lis.add(matc.group());//group()从头到尾整个匹配符合的字符串\n    }\n    String str[]=lis.toArray(new String[0]); //将泛型转换为数组,提取运算符\n    //从字符串中提取数字\n    Pattern pattern=Pattern.compile(\"\\\\.\\\\d|\\\\d+(\\\\.\\\\d+)?\");\n    Matcher matcher=pattern.matcher(ch);\n    List<String> list=new ArrayList<>();\n    while(matcher.find()) {\n        list.add(matcher.group());\n    }\n    String st[]=list.toArray(new String[0]);\n    double sum=Double.parseDouble(st[0]);//提取第一个数字\n    System.out.println(sum);\n    for(int i=0;i<str.length;i++) {\n        switch(str[i].charAt(0)) {//charAt(0)表示提取第一个字符\n            case '+':sum+=Double.parseDouble(st[i+1]);break;//提取第二个数字,并运算\n            case '-':sum-=Double.parseDouble(st[i+1]);break;\n            case '*':sum*=Double.parseDouble(st[i+1]);break;\n            case '/':{\n                Double d=Double.parseDouble(st[i+1]);\n                if(d.equals(0))\n                    return Double.MAX_VALUE;\n                break;\n            }\n            default:System.out.println(\"错误!\");break;\n        }\n    }\n    return sum;\n}\npublic static void main(String[] args) {\n    new calc();\n}\n", "\n\n", "}", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "利用refelect生成array，已解決。", "Konwledge_Point": "泛型机制——模板", "Question": ["JAVA如何利用反射指定類型", ["自己写一个工具类，求大神帮忙看下能否利用反射或者泛型实现类型转换。", "\n\n", "public static Object[] getArray(Class c,String str){", "\n        List list=jdbcUtil.getList(c, str);//list是利用反射生成的List", "\n        return list.toArray(new Object[list.size()]);//可否根据传入的Class指定Array类型", "\n    }", "\n\n", "因為：\nObject[] objs=new Object[]{\"a\",\"b\"};\nString[] strs=(String[])objs;//这里强转会报错，需要事先指定Array类型\n"]], "Tag": "程序设计"}
{"Answer": "首先确认正确的导入(import)。\r\n然后点击Project ---- Clean 菜单，在弹出的对话框中选择相应的工程名，执行Clean操作(实质是重新编译工程)。\r\n\r\n**如果对您有帮助，请采纳答案好吗，谢谢！**", "Konwledge_Point": "泛型机制——模板", "Question": ["xxx cannot be resolved to a type", ["\n\n", "\n\n", "\n如图片所示中的错误提醒：我已经有了一个泛型中的类了，已经定义好了，但是现在报错说", "\n不能解析这个类，解决办法是重新定义这个类？？？怎么办？为什么引用不到呢？"]], "Tag": "程序设计"}
{"Answer": "[CSharpCallLua]\r\n    public static List&lt;Type&gt; cSharpCallLuaList = new List&lt;Type&gt;()\r\n    {\r\n            typeof(UnityEngine.Events.UnityAction&lt;bool&gt;),\r\n    };\r\n\t\t把这个加进去就好了，这东西坑了我半天", "Konwledge_Point": "泛型机制——模板", "Question": ["请问以下大家Lua中怎么添加Unity中的Toggle的事件", ["\n", "请问以下大家Lua中怎么添加Unity中的Toggle的事件，因为Toggle的事件是个泛型委托\n\n", "\n", "Toggle事件的委托", "AddListener(UnityAction<T0> call);", "\n", "\n", "Button事件的委托", "AddListener(UnityAction call);", "\n", "\n", "\n", "\n", "我尝试了一下只能添加Button的事件", "\n", "\n", "以下是我添加Toggle事件的lua代码  ", "\n\n", "toggle.onValueChanged:AddListener(self.UpdateClothes);\n\nfunction ClothesTagView:UpdateClothes(isON)\n\nend\n", "\n\n", "报的错", "\n\n", "LuaException: c# exception:System.InvalidCastException: This type must add to CSharpCallLua: UnityEngine.Events.UnityAction<bool>\n\n", "\n\n", "以下是我添加Button事件的代码", "\n\n", "button.onClick:AddListener(self.UpdateClothes2)\n\nfunction ClothesTagView:UpdateClothes2()    \n    ClothesTagView:UpdateData()\nend\n\n", "\n\n", "是正常的可以使用，点击可以触发事件"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;之前做的时候是要针对每一个SO类都写一个读档方法的。其他方式也都类似&amp;#xff0c;因为读取的时候需要将类型固定下来&amp;#xff0c;才能给类中的变量进行赋值&amp;#xff0c;所以之前用不了泛型的形式。&lt;/p&gt;", "Konwledge_Point": "泛型机制——模板", "Question": ["存档系统中对不同ScriptableObject类的读档方式", ["问题遇到的现象和发生背景", "\n", "有3个", "不同类", "的ScriptableObject，举例为SO_1;_2;_3", "想做存档系统，ToJson的时候没啥问题，在FromJson的时候，想要把存档读到3个不同的List列表中；", "\n", "问题相关代码，请勿粘贴截图", "\n", "问题来了，要装进不同的List列表里，就要给明列表类型；", "起初我用的scriptableObject.Createinstanc《T》创建，然后再添加到List《T》列表中；", "但是报错，scriptableObject.Createinstanc《T》这里不能用泛型T；", "\n", "我想要达到的结果", "\n", "想要把存档中的3个不同类SO，读档到不同列表中；", "除了每个SO类都写一个读档方法外，是否还有其他读档方法可用；或者有其他构建存档系统的方法；"]], "Tag": "程序设计"}
{"Answer": "和`&lt;T&gt;`或者`&lt;? super T&gt;`没什么关系, Java8比Java7有更好的泛型推断\r\n\r\n详见[Java generics - Don't allow subclasses](https://stackoverflow.com/questions/29084617/java-generics-dont-allow-subclasses \"\")", "Konwledge_Point": "泛型机制——模板", "Question": ["在Java7和Java8中<T>和<? super T>有区别吗？", ["为什么在调用以下两个方法时在Java8中不报错而在Java7中会报错\npublic class Test {\n    public static void main(String[] args) {\n\n        Animal[] animals = {new Animal(1),new Animal(3),new Animal(2)};\n        Dog[] dogs = {new Dog(1),new Dog(3),new Dog(2)};\n\n        min1(animals);//在Java1.7.0_51和Java1.8.0_181编译都没有报错\n        min1(dogs);//在Java1.8.0_181编译没有报错 在Java1.7.0_51编译报错\n        min2(animals);//在Java1.7.0_51和Java1.8.0_181编译都没有报错\n        min2(dogs);//在Java1.7.0_51和Java1.8.0_181编译都没有报错\n\n    }\n\n\n    //查找出数组中年龄最小的的元素 Comparable<T>中的泛型T没有规定下线\n    public static <T extends Comparable<T>> void min1(T[] t){\n        T min = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (min.compareTo(t[i])<0){\n                min = t[i];\n            }\n        }\n        System.out.println(min);\n    }\n\n    //查找出数组中年龄最小的的元素 Comparable<T>中的泛型T规定了下线\n    public static <T extends Comparable<? super T>> void min2(T[] t){\n\n        T min = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i].compareTo(min)<0){\n                min = t[i];\n            }\n        }\n        System.out.println(min);\n    }\n\n}\n\n//Aminmal实现了Comparable<Animal>\npublic class Animal implements Comparable<Animal>{\n\n    private int age;\n\n    public Animal(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public int compareTo(Animal o) {\n        return age-o.age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Animal{\" +\n                \"age=\" + age +\n                '}';\n    }\n}\n\n//Dog继承了Animal\npublic class Dog extends Animal{\n\n    public Dog(int age) {\n        super(age);\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "需要什么样的关系就配什么关系就可以了，需要公用的就放在最基本的那个pojo里，其他的需要扩展的就继承。不是还有override呢么，不行就override了。", "Konwledge_Point": "泛型机制——模板", "Question": ["Hibernate一个一对多的配置，不知道怎么从xml改为注解", ["我详细贴出代码说下吧", "\n\n", " ", "\n\n", "类的关系是：", "\n\n", " ", "\n\n", "  目录：SiteDirectory继承Directory", "     目录关系：SiteDirectorySubjection继承DirectorySubjection", "\n\n", " ", "\n\n", "public class Directory extends BasePojo {\n        private Set<? extends DirectorySubjection> subjections; //目录的上级目录\n    private Set<? extends DirectorySubjection> childSubjections; //目录的下级目录\n...\n}", "\n\n", "public class DirectorySubjection extends BasePojo {\n    \n    private long directoryId; //目录ID\n    private long parentDirectoryId; //上级目录ID\n...\n}", "\n\n", "public class SiteDirectory extends Directory {\n...\n}", "\n\n", "public class SiteDirectorySubjection extends DirectorySubjection {\n...\n}", "\n\n", " 以前没用泛型，xml配置如下", "\n\n", "<class name=\"XXX.XXX.XXX.XXX.pojo.SiteDirectory\" table=\"site_directory\">\n...\n<set cascade=\"delete\" inverse=\"true\" lazy=\"true\" name=\"subjections\" table=\"site_directory_subjection\" order-by=\"id\">\n            <key column=\"directoryId\" />\n            <one-to-many class=\"XXX.XXX.XXX.pojo.SitebDirectorySubjection\" />\n        </set>\n        <set cascade=\"delete\" inverse=\"true\" lazy=\"true\" name=\"childSubjections\" table=\"site_directory_subjection\">\n            <key column=\"parentDirectoryId\" />\n            <one-to-many class=\"XXX.XXX.XXX.pojo.SiteDirectorySubjection\" />\n        </set>\n...", "\n\n", " 现在加上了泛型，用注解方式怎么配置", "\n\n", " ", "\n\n", "我只有30分，全部都奉上了，帮忙下"]], "Tag": "程序设计"}
{"Answer": "你这个问题问的好！给你图片你自己找答案吧。![图片说明](https://img-ask.csdn.net/upload/202010/23/1603445506_478599.png)![图片说明](https://img-ask.csdn.net/upload/202010/23/1603445513_73315.png)", "Konwledge_Point": "泛型机制——模板", "Question": ["关于子类继承父类的问题？", ["//一个接口\npublic Inteface test{}\n\n//父类实现接口test\npublic class TestCollection implements test{}\n\n//子类继承父类\npublic class Child extends TestCollection{}\n", "\n\n", "请问子类Child默认已经实现接口test了吗？", "\n\n", "还是说如果子类要实现接口test，要重新再写一次implements?", "\n\n", "我自己做了个测试，看看准不准", "\n\n", "    //接口test,TestCollection类实现了该接口，child类继承了TestCollection类\n        //已经指定了泛型类型为接口test,所以放入该容器的对象必须实现接口\n        ArrayList<test> testExtends = new ArrayList<> ();\n        testExtends.add(new TestCollection());\n\n        //子类child没显式说明implements 该接口，但add方法可以成功运行\n        testExtends.add(new child());\n\n        //输出collection.TestCollection@15db9742\n        //输出collection.child@6d06d69c\n        System.out.println(testExtends.get(0));\n        System.out.println(testExtends.get(1));\n\n        //结果true\n        System.out.println(new child() instanceof test);\n\n"]], "Tag": "程序设计"}
{"Answer": "所以一般用ArrayList的时候，都是明确知道它里面存放的是什么类型的对象，这样获取的时候就知道怎么使用了。不然就是用多态的方式调用方法等", "Konwledge_Point": "泛型机制——模板", "Question": ["一个问过的问题 想过之后 觉得有什么地方不对   关于Java.util. Arraylist", ["没有泛型类时，原始的ArrayList类提供的get方法别无选择只能返回Obejct，因此，get方法的调用必须对返回值进行类型转换：", "\nEmployee e = （Employee）staff. get(i):", "\n原始的ArrayList存在一定的危险性。 它的add和set方法允许接收任意类型的对象。", "\n对于下面这个调用", "\nstaff.set(i.new Date());", "\n编译时不会给出任何警告，只有在检索对象并试图对它进行类型转换时，才会发现有问题。如果使用ArrayList,编译器就会检测到这个错误。", "\n\n", "第一个问题：Employee e = （Employee）staff. get(i):", "\n\n", "猜测：      object obj = （object) staff.get(i)（向上转型）", "\n\n", "      Employee e =(Employee) obj(向下转型)\n", "\n\n", "这种向下转型不是很容易会出错了。 比如boss是Employee的一员，但是Employee不一定是就是boss啊。", "\n\n", "从object这个父类往下转换，会出现错误码？"]], "Tag": "程序设计"}
{"Answer": "http://softlab.sdut.edu.cn/blog/subaochen/2017/04/safevarargs%E7%9A%84%E7%94%A8%E6%B3%95/", "Konwledge_Point": "泛型机制——模板", "Question": ["请问一下 参数化 vararg 类型T的堆可能已受污染 是什么意思，该如何修改", ["请问一下 参数化 vararg 类型T的堆可能已受污染 是什么意思，该如何修改", "\n\n", "public class GenericsDemo20{\n    public static void main(String args[]) {\n        Integer i[] = fun1(1,2,3,4,5,6);\n        fun2(i);\n    }\n    public static<T> T[] fun1(T...arg){\n        return arg;\n    }\n    public static<T> void fun2(T arg[]){\n        System.out.println(\"接收泛型数据\");\n        for(T t:arg) {\n            System.out.println(t + \"、\");\n        }\n    }\n}\n\n", "\n\n", "错误类型", "\n\n", "D:\\testjava>javac GenericsDemo20.java\n注: GenericsDemo20.java使用了未经检查或不安全的操作。\n注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。\n\nD:\\testjava>javac  -Xlint:unchecked GenericsDemo20.java\nGenericsDemo20.java:6: 警告: [unchecked] 参数化 vararg 类型T的堆可能已受污染\n        public static<T> T[] fun1(T...arg){\n                                      ^\n  其中, T是类型变量:\n    T扩展已在方法 <T>fun1(T...)中声明的Object\n1 个警告\n\nD:\\testjava>\n\n"]], "Tag": "程序设计"}
{"Answer": "这个跟泛型类型没有关系，主要是你的打印代码是toString()，这个方法是Person类的，子类没有重写。子类和父类有同名属性name，而你的Person类的代码是\r\n\r\n```\r\n \tpublic String toString() {\r\n\t//这里的this是父类的getName()方法，返回的是父类的name属性。\r\n\t\treturn this.getName();\r\n\t}\r\n```\r\n你的子类定义了与父类同名的name属性，但是没有提供getName方法，所以toString调用的getName是父类继承的方法，只能是获取父类的name属性。\r\n你实例化的子类对象的name是子类的，父类的name属性值为null，所以你打印的值都是null.\r\n\r\n```\r\n 修正你的子类方法，提供子类的name的getName（）方法就可以了。即给Student和Worker都加一个getName（）方法，返回子类自己的name属性。而不是调用父类的方法。\r\n```", "Konwledge_Point": "泛型机制——模板", "Question": ["一个继承的问题,求解答。", ["package 泛型限定;", "\n\n", "public class Person {", "\n    private String name;", "\n    public Person() {", "\n        // TODO Auto-generated constructor stub", "\n    }", "\n    public Person(String name) {", "\n        super();", "\n        this.name = name;", "\n    }", "\n    public String getName() {", "\n        return name;", "\n    }", "\n    public void setName(String name) {", "\n        this.name = name;", "\n    }", "\n\n", "public void eat(){\n    System.out.println(\"人在吃饭\");\n}\n\npublic String toString()\n{\n    return this.getName();\n}\n", "\n\n", "}", "\n\n", "@SuppressWarnings(\"all\")", "\nclass Student extends Person{", "\n    private String name;", "\n    public Student() {", "\n        // TODO Auto-generated constructor stub", "\n    }", "\n    public Student(String name) {", "\n        super();", "\n        this.name = name;", "\n    }", "\n    public void study(){", "\n        System.out.println(\"学生在学习\");", "\n    }", "\n\n", "}", "\n@SuppressWarnings(\"all\")", "\nclass Worker extends Person{", "\n    private String name;", "\n    public Worker() {", "\n        // TODO Auto-generated constructor stub", "\n    }", "\n    public Worker(String name) {", "\n        super();", "\n        this.name = name;", "\n    }", "\n    public void work(){", "\n        System.out.println(\"工人在工作\");", "\n    }", "\n}", "\n\n", "///////////////////////", "\npackage 泛型限定;", "\n\n", "import java.util.ArrayList;", "\nimport java.util.Iterator;", "\n\n", "public class TextPerson {", "\n    public static void main(String[] args) {", "\n     ArrayList list=new ArrayList<>();", "\n     ArrayList list02=new ArrayList<>();", "\n     ArrayList list03=new ArrayList<>();", "\n        list.add(new Person(\"汪洋\"));", "\n        list.add(new Person(\"刘林\"));", "\n        list.add(new Person(\"张兆年\"));", "\n        list02.add(new Student(\"学生一\"));", "\n        list02.add(new Student(\"学生二\"));", "\n        list02.add(new Student(\"学生三\"));", "\n        list03.add(new Worker(\"工人一\"));", "\n        list03.add(new Worker(\"工人二\"));", "\n        list03.add(new Worker(\"工人三\"));", "\n        paint(list);", "\n        paint(list02);", "\n        paint(list03);", "\n        System.out.println(\"==============\");", "\n        paint2(list02);", "\n        paint2(list);", "\n\n", "}\npublic static void paint(ArrayList<? extends Person> list){\n    Iterator<? extends Person> it=list.iterator();\n    while(it.hasNext())\n    {\n        System.out.println(it.next().getName());\n    }   \n}\npublic static void paint2(ArrayList<? super Student> list){\n    Iterator<? super Student> it=list.iterator();\n    while(it.hasNext())\n    {\n        System.out.println(it.next().toString());\n    }   \n}\n", "\n\n", "}", "\n///////////////////", "\n运行结果为：", "\n汪洋", "\n刘林", "\n张兆年", "\nnull", "\nnull", "\nnull", "\nnull", "\nnull", "\n\n", "null", "\n\n", "null", "\nnull", "\nnull", "\n汪洋", "\n刘林", "\n\n", "张兆年", "\n\n", "问题来了，为什么会出现null呢，是我继承的地方有什么没有弄懂吗，求解答！"]], "Tag": "程序设计"}
{"Answer": "[INFO] Scanning for projects...\r\n[INFO]                                                                         \r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] Building sshsimple Maven Webapp 0.0.1-SNAPSHOT\r\n[INFO] ------------------------------------------------------------------------\r\n[INFO] \r\n[INFO] &gt;&gt;&gt; tomcat7-maven-plugin:2.2:run (default-cli) &gt; process-classes @ sshsimple &gt;&gt;&gt;\r\n[INFO] \r\n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ sshsimple ---\r\n[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!\r\n[INFO] Copying 4 resources\r\n[INFO] \r\n[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ sshsimple ---\r\n[INFO] Nothing to compile - all classes are up to date\r\n[INFO] \r\n[INFO] &lt;&lt;&lt; tomcat7-maven-plugin:2.2:run (default-cli) &lt; process-classes @ sshsimple &lt;&lt;&lt;\r\n[INFO] \r\n[INFO] --- tomcat7-maven-plugin:2.2:run (default-cli) @ sshsimple ---\r\n[INFO] Running war on http://localhost:8080/sshsimple\r\n[INFO] Using existing Tomcat server configuration at C:\\Program Files\\daima\\sshsimple\\target\\tomcat\r\n[INFO] create webapp with contextPath: /sshsimple\r\n八月 28, 2016 12:25:09 下午 org.apache.coyote.AbstractProtocol init\r\n信息: Initializing ProtocolHandler [\"http-bio-8080\"]\r\n八月 28, 2016 12:25:10 下午 org.apache.catalina.core.StandardService startInternal\r\n信息: Starting service Tomcat\r\n八月 28, 2016 12:25:10 下午 org.apache.catalina.core.StandardEngine startInternal\r\n信息: Starting Servlet Engine: Apache Tomcat/7.0.47\r\n八月 28, 2016 12:25:28 下午 org.apache.catalina.core.ApplicationContext log\r\n信息: No Spring WebApplicationInitializer types detected on classpath\r\n八月 28, 2016 12:25:28 下午 org.apache.catalina.core.ApplicationContext log\r\n信息: Initializing Spring root WebApplicationContext\r\n八月 28, 2016 12:25:28 下午 org.springframework.web.context.ContextLoader initWebApplicationContext\r\n信息: Root WebApplicationContext: initialization started\r\n八月 28, 2016 12:25:29 下午 org.springframework.web.context.support.XmlWebApplicationContext prepareRefresh\r\n信息: Refreshing Root WebApplicationContext: startup date [Sun Aug 28 12:25:29 GMT+08:00 2016]; root of context hierarchy\r\n八月 28, 2016 12:25:29 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from URL [file:/C:/Program%20Files/daima/sshsimple/target/classes/application-context.xml]\r\n八月 28, 2016 12:25:30 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from URL [file:/C:/Program%20Files/daima/sshsimple/target/classes/application-context-hibernate.xml]\r\n八月 28, 2016 12:25:30 下午 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &lt;init&gt;\r\n信息: JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\r\nERROR StatusLogger Log4j2 could not find a logging implementation. Please add log4j-core to the classpath. Using SimpleLogger to log to the console...\r\n八月 28, 2016 12:25:39 下午 org.springframework.orm.hibernate5.HibernateTransactionManager afterPropertiesSet\r\n信息: Using DataSource [org.apache.commons.dbcp.BasicDataSource@53f1a2c] of Hibernate SessionFactory for HibernateTransactionManager\r\n八月 28, 2016 12:25:39 下午 org.springframework.web.context.ContextLoader initWebApplicationContext\r\n信息: Root WebApplicationContext: initialization completed in 10792 ms\r\n八月 28, 2016 12:25:42 下午 org.apache.coyote.AbstractProtocol start\r\n信息: Starting ProtocolHandler [\"http-bio-8080\"]\r\nHibernate: \r\n    select\r\n        tbuser0_.userId as userId1_3_,\r\n        tbuser0_.pName as pName2_3_,\r\n        tbuser0_.phoneNo as phoneNo3_3_,\r\n        tbuser0_.userName as userName4_3_,\r\n        tbuser0_.userPassword as userPass5_3_ \r\n    from\r\n        TbUser tbuser0_ \r\n    where\r\n        1=1 \r\n        and tbuser0_.userName='wangl' \r\n        and tbuser0_.userPassword='123'\r\nHibernate: \r\n    select\r\n        roles0_.users_userId as users_us1_4_0_,\r\n        roles0_.roles_roleId as roles_ro2_4_0_,\r\n        tbrole1_.roleId as roleId1_1_1_,\r\n        tbrole1_.description as descript2_1_1_,\r\n        tbrole1_.roleName as roleName3_1_1_ \r\n    from\r\n        TbUser_TbRole roles0_ \r\n    inner join\r\n        TbRole tbrole1_ \r\n            on roles0_.roles_roleId=tbrole1_.roleId \r\n    where\r\n        roles0_.users_userId=?\r\nHibernate: \r\n    select\r\n        tbuser0_.userId as userId1_3_,\r\n        tbuser0_.pName as pName2_3_,\r\n        tbuser0_.phoneNo as phoneNo3_3_,\r\n        tbuser0_.userName as userName4_3_,\r\n        tbuser0_.userPassword as userPass5_3_ \r\n    from\r\n        TbUser tbuser0_\r\nHibernate: \r\n    select\r\n        roles0_.users_userId as users_us1_4_0_,\r\n        roles0_.roles_roleId as roles_ro2_4_0_,\r\n        tbrole1_.roleId as roleId1_1_1_,\r\n        tbrole1_.description as descript2_1_1_,\r\n        tbrole1_.roleName as roleName3_1_1_ \r\n    from\r\n        TbUser_TbRole roles0_ \r\n    inner join\r\n        TbRole tbrole1_ \r\n            on roles0_.roles_roleId=tbrole1_.roleId \r\n    where\r\n        roles0_.users_userId=?\r\nHibernate: \r\n    select\r\n        roles0_.users_userId as users_us1_4_0_,\r\n        roles0_.roles_roleId as roles_ro2_4_0_,\r\n        tbrole1_.roleId as roleId1_1_1_,\r\n        tbrole1_.description as descript2_1_1_,\r\n        tbrole1_.roleName as roleName3_1_1_ \r\n    from\r\n        TbUser_TbRole roles0_ \r\n    inner join\r\n        TbRole tbrole1_ \r\n            on roles0_.roles_roleId=tbrole1_.roleId \r\n    where\r\n        roles0_.users_userId=?\r\nHibernate: \r\n    select\r\n        roles0_.users_userId as users_us1_4_0_,\r\n        roles0_.roles_roleId as roles_ro2_4_0_,\r\n        tbrole1_.roleId as roleId1_1_1_,\r\n        tbrole1_.description as descript2_1_1_,\r\n        tbrole1_.roleName as roleName3_1_1_ \r\n    from\r\n        TbUser_TbRole roles0_ \r\n    inner join\r\n        TbRole tbrole1_ \r\n            on roles0_.roles_roleId=tbrole1_.roleId \r\n    where\r\n        roles0_.users_userId=?", "Konwledge_Point": "泛型机制——模板", "Question": ["ssh框架问题，拿不到数据库关联表里的数据", ["package com.wangl.sshsimple.entity;", "\n\n", "import java.util.List;", "\n\n", "import javax.persistence.Entity;", "\nimport javax.persistence.FetchType;", "\nimport javax.persistence.GeneratedValue;", "\nimport javax.persistence.GenerationType;", "\nimport javax.persistence.Id;", "\nimport javax.persistence.ManyToMany;", "\n\n", "@Entity", "\npublic class TbUser {", "\n    @Id", "\n    @GeneratedValue(strategy=GenerationType.IDENTITY)", "\n    private Long userId;", "\n    private String userName;", "\n    private String userPassword;", "\n    private String pName;", "\n    private String phoneNo;", "\n    @ManyToMany(fetch=FetchType.EAGER)", "\n    private List roles;", "\n\n", "public String getpName() {\n    return pName;\n}\npublic void setpName(String pName) {\n    this.pName = pName;\n}\npublic String getPhoneNo() {\n    return phoneNo;\n}\npublic void setPhoneNo(String phoneNo) {\n    this.phoneNo = phoneNo;\n}\npublic List<TbRole> getRoles() {\n    return roles;\n}\npublic void setRoles(List<TbRole> roles) {\n    this.roles = roles;\n}\n\npublic String getUserPassword() {\n    return userPassword;\n}\npublic void setUserPassword(String userPassword) {\n    this.userPassword = userPassword;\n}\npublic Long getUserId() {\n    return userId;\n}\npublic void setUserId(Long userId) {\n    this.userId = userId;\n}\npublic String getUserName() {\n    return userName;\n}\npublic void setUserName(String userName) {\n    this.userName = userName;\n}\n@Override\npublic String toString() {\n    return \"TbUser [userId=\" + userId + \", userName=\" + userName + \"]\";\n}\n", "\n\n", "}", "\npackage com.wangl.sshsimple.entity;", "\n\n", "import java.util.List;", "\n\n", "import javax.persistence.Entity;", "\nimport javax.persistence.FetchType;", "\nimport javax.persistence.GeneratedValue;", "\nimport javax.persistence.GenerationType;", "\nimport javax.persistence.Id;", "\nimport javax.persistence.JoinColumn;", "\nimport javax.persistence.ManyToMany;", "\n\n", "@Entity", "\npublic class TbRole {", "\n    @Id", "\n    @GeneratedValue(strategy=GenerationType.IDENTITY)", "\n    private Long roleId;", "\n    private String roleName;", "\n    private String description;", "\n    @ManyToMany(fetch=FetchType.EAGER)", "\n    private List functions;", "\n    @ManyToMany(mappedBy=\"roles\")", "\n    private List users;", "\n\n", "public String getDescription() {\n    return description;\n}\npublic void setDescription(String description) {\n    this.description = description;\n}\npublic List<TbFunction> getFunctions() {\n    return functions;\n}\npublic void setFunctions(List<TbFunction> functions) {\n    this.functions = functions;\n}\npublic List<TbUser> getUsers() {\n    return users;\n}\npublic void setUsers(List<TbUser> users) {\n    this.users = users;\n}\npublic Long getRoleId() {\n    return roleId;\n}\npublic void setRoleId(Long roleId) {\n    this.roleId = roleId;\n}\npublic String getRoleName() {\n    return roleName;\n}\npublic void setRoleName(String roleName) {\n    this.roleName = roleName;\n}\n", "\n\n", "}", "\npackage com.wangl.sshsimple.entity;", "\n\n", "import java.util.List;", "\n\n", "import javax.persistence.Entity;", "\nimport javax.persistence.GeneratedValue;", "\nimport javax.persistence.GenerationType;", "\nimport javax.persistence.Id;", "\nimport javax.persistence.ManyToMany;", "\n\n", "@Entity", "\npublic class TbFunction {", "\n    @Id", "\n    @GeneratedValue(strategy=GenerationType.IDENTITY)", "\n    private Long functionId;", "\n    private String functionName;", "\n    private String url;", "\n    private String memo;", "\n    @ManyToMany(mappedBy=\"functions\")", "\n    private List roles;", "\n\n", "public List<TbRole> getRoles() {\n    return roles;\n}\npublic void setRoles(List<TbRole> roles) {\n    this.roles = roles;\n}\npublic String getMemo() {\n    return memo;\n}\npublic void setMemo(String memo) {\n    this.memo = memo;\n}\npublic Long getFunctionId() {\n    return functionId;\n}\npublic void setFunctionId(Long functionId) {\n    this.functionId = functionId;\n}\npublic String getFunctionName() {\n    return functionName;\n}\npublic void setFunctionName(String functionName) {\n    this.functionName = functionName;\n}\npublic String getUrl() {\n    return url;\n}\npublic void setUrl(String url) {\n    this.url = url;\n}\n@Override\npublic String toString() {\n    return \"TbFunction [functionId=\" + functionId + \", functionName=\" + functionName + \", url=\" + url + \"]\";\n}\n", "\n\n", "}", "\npackage com.wangl.sshsimple.dao;", "\n\n", "import java.util.List;", "\nimport java.util.Map;", "\n\n", "import org.hibernate.Session;", "\nimport org.springframework.stereotype.Repository;", "\n\n", "import com.wangl.sshsimple.entity.TbRole;", "\nimport com.wangl.sshsimple.entity.TbUser;", "\n\n", "@Repository", "\npublic class TbUserDaoImp extends GenericDaoImp implements TbUserDao{", "\n\n", "public TbUserDaoImp() {\n    super(TbUser.class);\n}\n\npublic List<TbUser> findByCondition(Map condition) {\n    String hql=\"from TbUser where 1=1\";\n    if(condition.size()>0){\n        if(condition.containsKey(\"userName\")){\n            hql+=\" and userName like '%\"+condition.get(\"userName\")+\"%'\";\n        }\n        if(condition.containsKey(\"pName\")){\n            hql+=\" and pName like '%\"+condition.get(\"pName\")+\"%'\";\n        }\n        if(condition.containsKey(\"phoneNo\")){\n            hql+=\" and phoneNo like '%\"+condition.get(\"phoneNo\")+\"%'\";\n        }\n        if(condition.containsKey(\"loginUserName\")){\n            hql+=\" and userName='\"+condition.get(\"loginUserName\")+\"'\";\n        }\n        if(condition.containsKey(\"loginPassword\")){\n            hql+=\" and userPassword='\"+condition.get(\"loginPassword\")+\"'\";\n        }\n    }\n    return (List<TbUser>) this.getHibernateTemplate().find(hql);\n}\n", "\n\n", "}", "\npackage com.wangl.sshsimple.dao;", "\n\n", "import java.io.Serializable;", "\nimport java.util.List;", "\nimport java.util.Map;", "\n\n", "import org.springframework.orm.hibernate5.support.HibernateDaoSupport;", "\n\n", "public class GenericDaoImp extends HibernateDaoSupport implements GenericDao {", "\n    //用添加属性这种方法拿到泛型的具体类型", "\n    private Class entityClass;", "\n\n", "public GenericDaoImp(Class<T> entityClass){\n    this.entityClass = entityClass;\n}\n\npublic void add(T entity) {\n    this.getHibernateTemplate().save(entity);\n}\n\npublic void update(T entity) {\n    this.getHibernateTemplate().update(entity);\n}\n\npublic void delete(T entity) {\n    this.getHibernateTemplate().delete(entity);\n}\n\npublic List<T> search(Map condition) {\n    return (List<T>)this.getHibernateTemplate().find(\"\");\n}\n\npublic List<T> findAll() {\n    String hql=\"from \"+entityClass.getName();   \n    return (List<T>) this.getHibernateTemplate().find(hql);\n}\n\npublic T get(K id) {\n    return this.getHibernateTemplate().get(entityClass, id);\n}\n", "\n\n", "}", "\npackage com.wangl.sshsimple.action;", "\n\n", "import java.util.HashMap;", "\nimport java.util.List;", "\nimport java.util.Map;", "\n\n", "import javax.servlet.http.HttpSession;", "\n\n", "import org.apache.struts2.ServletActionContext;", "\n\n", "import com.wangl.sshsimple.entity.TbFunction;", "\nimport com.wangl.sshsimple.entity.TbRole;", "\nimport com.wangl.sshsimple.entity.TbUser;", "\nimport com.wangl.sshsimple.service.TbRoleService;", "\nimport com.wangl.sshsimple.service.TbUserService;", "\n\n", "public class LoginAction {", "\n    private String userName;", "\n    private String userPassword;", "\n    private TbUserService tbUserService;", "\n    private TbRoleService tbRoleService;", "\n\n", "public void setTbRoleService(TbRoleService tbRoleService) {\n    this.tbRoleService = tbRoleService;\n}\npublic void setTbUserService(TbUserService tbUserService) {\n    this.tbUserService = tbUserService;\n}\npublic String getUserName() {\n    return userName;\n}\npublic void setUserName(String userName) {\n    this.userName = userName;\n}\npublic String getUserPassword() {\n    return userPassword;\n}\npublic void setUserPassword(String userPassword) {\n    this.userPassword = userPassword;\n}\n\npublic String login(){\n    //登录成功后将user放入session\n    //将用户权限放入session\n    if(userName!=null&& !userName.equals(\"\") &&userPassword!=null&& !userPassword.equals(\"\")){\n        HttpSession sess=ServletActionContext.getRequest().getSession();\n        Map condition = new HashMap();\n        condition.put(\"loginUserName\", userName);\n        condition.put(\"loginPassword\", userPassword);\n        List<TbUser> tbUsers=tbUserService.findByCondition(condition);\n        if(tbUsers!=null&&tbUsers.size()>0){\n            for(TbUser u:tbUsers){                  \n                List<TbRole> roles=u.getRoles();\n                if(roles.size()>0){\n                    for(TbRole r:roles){\n                        List<TbFunction> functions=r.getFunctions();\n                        if(functions.size()>0){\n                            sess.setAttribute(\"functions\", functions);\n                        }\n                    }\n                }\n                sess.setAttribute(\"tbUser\", u);\n            }\n            return \"success\";\n        }\n    }\n    return \"notLoged\";\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "整理了下你的报错， 希望对你有帮助： \r\norg.tantec.springmvc.service.simple.impl.UserInfoServiceImpl\r\nCommon causes of this problem include using a final class(终态类) or a non-visible class（不可视类）", "Konwledge_Point": "泛型机制——模板", "Question": ["事务我的天啊", ["用了泛型的DAO，加了", "<!---->", "\n<beans xmlns=\"", "http://www.springframework.org/schema/beans", "\" xmlns:aop=\"", "http://www.springframework.org/schema/aop", "\" xmlns:tx=\"", "http://www.springframework.org/schema/tx", "\" xmlns:xsi=\"", "http://www.w3.org/2001/XMLSchema-instance", "\" xsi:schemalocation=\"", "http://www.springframework.org/schema/beans", "http://www.springframework.org/schema/beans/spring-beans-2.0.xsd", " ", "http://www.springframework.org/schema/tx", " ", "http://www.springframework.org/schema/tx/spring-tx-2.0.xsd", " ", "http://www.springframework.org/schema/aop", " ", "http://www.springframework.org/schema/aop/spring-aop-2.0.xsd", " \">\n\n", "<!---->\n&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt;\n    &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;\n&lt;/bean&gt;\n\n<!---->\n&lt;tx:annotation-driven&gt;\n\n<!---->\n&lt;aop:aspectj-autoproxy&gt;\n\n<!---->\n&lt;aop:config proxy-target-class=\"true\"&gt;\n    &lt;aop:advisor pointcut=\"execution(* org.tantec.springmvc.service.simple.*.*(..))\" advice-ref=\"txAdvice\"&gt;\n    &lt;aop:advisor pointcut=\"execution(* org.tantec.springmvc.service.complex.*.*(..))\" advice-ref=\"txAdvice\"&gt;\n&lt;/aop:config&gt;\n\n&lt;aop:config proxy-target-class=\"true\"&gt;\n\n&lt;/aop:config&gt;\n\n<!---->\n&lt;tx:advice id=\"txAdvice\"&gt;\n    &lt;tx:attributes&gt;\n        &lt;tx:method name=\"get*\" read-only=\"true\"&gt;\n        &lt;tx:method name=\"find*\" read-only=\"true\"&gt;\n        &lt;tx:method name=\"query*\" read-only=\"true\"&gt;\n        &lt;tx:method name=\"*\"&gt;\n    &lt;/tx:attributes&gt;\n&lt;/tx:advice&gt;\n", "\n\n", "</beans>", "报错内容：", "2008-9-7 6:17:12 org.apache.catalina.core.StandardContext listenerStart", "严重: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener", "org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'userInfoService' defined in file [D:\\Program\\Tomcat 6.0\\webapps\\springmvc\\WEB-INF\\classes\\org\\tantec\\springmvc\\service\\simple\\impl\\UserInfoServiceImpl.class]: Initialization of bean failed; nested exception is org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class [class org.tantec.springmvc.service.simple.impl.UserInfoServiceImpl]: Common causes of this problem include using a final class or a non-visible class; nested exception is net.sf.cglib.core.CodeGenerationException: java.lang.ClassCastException-->java.lang.Class", "  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:480)", "  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)", "  at java.security.AccessController.doPrivileged(Native Method)", "  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)", "  at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)", "  at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221)", "  at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)", "  at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)", "  at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)", "  at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429)", "  at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:729)", "  at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:381)", "  at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:255)", "  at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:199)", "  at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:45)", "  at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3843)", "  at org.apache.catalina.core.StandardContext.start(StandardContext.java:4342)", "  at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045)", "  at org.apache.catalina.core.StandardHost.start(StandardHost.java:719)", "  at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045)", "  at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443)", "  at org.apache.catalina.core.StandardService.start(StandardService.java:516)", "  at org.apache.catalina.core.StandardServer.start(StandardServer.java:710)", "  at org.apache.catalina.startup.Catalina.start(Catalina.java:578)", "  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)", "  at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)", "  at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)", "  at java.lang.reflect.Method.invoke(Unknown Source)", "  at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:288)", "  at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:413)", "Caused by: org.springframework.aop.framework.AopConfigException: Could not generate CGLIB subclass of class [class org.tantec.springmvc.service.simple.impl.UserInfoServiceImpl]: Common causes of this problem include using a final class or a non-visible class; nested exception is net.sf.cglib.core.CodeGenerationException: java.lang.ClassCastException-->java.lang.Class", "  at org.springframework.aop.framework.Cglib2AopProxy.getProxy(Cglib2AopProxy.java:207)", "  at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110)", "  at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:488)", "  at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:363)", "  at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:324)", "  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:361)", "  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1343)", "  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:473)", "  ... 29 more", "Caused by: net.sf.cglib.core.CodeGenerationException: java.lang.ClassCastException-->java.lang.Class", "  at net.sf.cglib.core.ReflectUtils.newInstance(ReflectUtils.java:235)", "  at net.sf.cglib.core.ReflectUtils.newInstance(ReflectUtils.java:220)", "  at net.sf.cglib.core.ReflectUtils.newInstance(ReflectUtils.java:216)", "  at net.sf.cglib.proxy.Enhancer.createUsingReflection(Enhancer.java:640)", "  at net.sf.cglib.proxy.Enhancer.firstInstance(Enhancer.java:538)", "  at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:225)", "  at net.sf.cglib.proxy.Enhancer.createHelper(Enhancer.java:377)", "  at net.sf.cglib.proxy.Enhancer.create(Enhancer.java:285)", "  at org.springframework.aop.framework.Cglib2AopProxy.getProxy(Cglib2AopProxy.java:201)", "  ... 36 more", "Caused by: java.lang.ClassCastException: java.lang.Class", "  at org.tantec.framework.core.BaseService.<init>(BaseService.java:21)", "  at org.tantec.springmvc.service.simple.impl.UserInfoServiceImpl.<init>(UserInfoServiceImpl.java:14)", "  at org.tantec.springmvc.service.simple.impl.UserInfoServiceImpl$$EnhancerByCGLIB$$78ab0388.<init>(<generated>)", "  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)", "  at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)", "  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)", "  at java.lang.reflect.Constructor.newInstance(Unknown Source)", "  at net.sf.cglib.core.ReflectUtils.newInstance(ReflectUtils.java:228)", "  ... 44 more", "2008-9-7 6:17:12 org.apache.catalina.core.ApplicationContext log", "信息: Set web app root system property: 'webapp.root' = [D:\\Program\\Tomcat 6.0\\webapps\\springmvc]", "2008-9-7 6:17:12 org.apache.catalina.core.ApplicationContext log", "信息: Initializing log4j from [D:\\Program\\Tomcat 6.0\\webapps\\springmvc\\WEB-INF\\log4j.xml]", "到Javaeye找了很多帖子，也到搜索上找了好久，就是解决不了，请问那位大哥碰到过这类问题", "问题补充：", "编译路径应该没问题，就看是不是wxjiaaa (高级程序员)说的那样了，回去继续看下是什么问题，困扰了好多天。", "这里有我写的代码。", "http://tantec.iteye.com/admin/blogs/238097", "问题补充：", "这篇文章里面与我的问题类似", "http://www.iteye.com/topic/116294", "回去看下是不是这个问题了"]], "Tag": "程序设计"}
{"Answer": "不知道你要表达什么意思。\r\nson 定义为私有，定义公有的 getSon/setSon，那么子类重写 setSon() 可以对赋值的类型进行校验啊。\r\nA 子类的 setSon 只接受 A 不接受 B（如果B没有继承A的话）。", "Konwledge_Point": "泛型机制——模板", "Question": ["抽象类如何将子类作为成员的类型", ["想写一个List，其中Node的定义如下：", "\n\n", " public abstract class Node{\n    public Node son=null;//为了测试方便，使用public\n    //……还有好多\n}\n", "\n\n", "这样是想以后用的时候可以继承Node再添加实体。显然这么定义是不行的，因为以下代码可以通过：", "\n\n", "A a=new A();//A extends Node\na.son=new B();//B extends Node\n", "\n\n", "那么怎么定义呢？", "\nPS：如果写成", "\n\n", " public class Node<T>{\n    private Node son=null;\n    private T t=null;\n}\n", "\n\n", "这样然后实体作为参数传给Node可以实现的这种事情我也是知道的。单纯是觉得不美丽。"]], "Tag": "程序设计"}
{"Answer": "public static &lt;T&gt; List&lt;T&gt; query(String sql, Class&lt;T&gt; clazz)\r\n\tpublic static &lt;T&gt; List&lt;T&gt; query(String sql, Class&lt;T&gt; clazz,\r\n\t\t\tObject[] parameters)", "Konwledge_Point": "泛型机制——模板", "Question": ["遍历list应该返回什么类型", ["1.public static  List query(String sql, Class clazz)", "\n2.  public static  List query(String sql, Class clazz,", "\n            Object[] parameters) "]], "Tag": "程序设计"}
{"Answer": "后面加一个ToList（）就行了。", "Konwledge_Point": "泛型机制——模板", "Question": ["关于list<>排序的问题，请问为什么报错", []], "Tag": "程序设计"}
{"Answer": "贴出你的代码看下。作为元素的对象，是引用类型，修改其中一个，其它也会变，因为指向一个对象。你得拷贝一个再添加。", "Konwledge_Point": "泛型机制——模板", "Question": ["C#中List容器添加元素的问题", ["我现在有这样的一个类，这个类里有一个存放两个祖先节点的List，这个List用来存放父亲节点和母亲节点。然后还有一个用来存放夫妻节点的节点类型的变量。首先我实例化节点1，然后调用节点1创建夫妻节点的方法（这个方法会创建一个节点2作为节点1的夫妻节点）。然后我对节点1调用创建祖先的方法，这时候会创建节点1的父节点、母节点，添加到节点1的list中。接下来对节点2调用创建祖先的方法，这是后同上，也会创建父节点和母节点添加到节点2的list中。", "\n以上是我觉得正常的过程，现在不正常的出现了，在我调用节点1的创建祖先方法时，当我添加一个节点时，在节点2的list中也会出现相同的节点。。。。这是为什么啊，我知道list是引用传递，但我这里是两个完全不同的list，这是什么情况。。。。。求大神们给个科学的解答，最好能再给个解决方案，谢谢各位了"]], "Tag": "程序设计"}
{"Answer": "sublist的第一个参数是start(起始截取位置),第二个参数是end(结束截取位置)；\r\n截取范围是前闭后开区间；\r\n这个错误也就是你的page=100了；但是你的pageSize=1；\r\n如果你想截取的是第101个元素的话，那么你可以page, page + pageSize;\r\n所以就需要你好好看看你的page和pageSize是怎么算的；\r\n你这样的写法起始是很不明确逻辑的；\r\n\r\n希望可以帮到你...", "Konwledge_Point": "泛型机制——模板", "Question": ["List问题，sublist方法求解答", ["\n报错行指向蓝标行，这段代码是生成jqgrid对象传到前台展示的，这个错误百度也没看出来是个啥，求大家解答一下该怎么改"]], "Tag": "程序设计"}
{"Answer": "另外java泛型的机制：\r\nhttp://irfen.iteye.com/blog/1888312\r\n\r\n\r\n```\r\nJava泛型实现原理：类型擦出\r\n       Java的泛型是伪泛型。在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。\r\n       Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除。\r\n    如在代码中定义的List&lt;object&gt;和List&lt;String&gt;等类型，在编译后都会编程List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是Java的泛型实现方法与C++模版机制实现方式（后面介绍）之间的重要区别。 \r\n```\r\n\r\n因为是编译完成的，包括类型检查这些，而反射绕过了编译检查，所以是没办法的。", "Konwledge_Point": "泛型机制——模板", "Question": ["对于Java反射的安全性的一些疑问", ["最近在看深入理解JVM，随手写了一点代码，有个问题不太理解。", "\n代码如下：", "\n\n", "    public static void main(String[] args) throws Exception {\n        HashMap<Integer, String> map = new HashMap<Integer, String>();\n        Method put = HashMap.class.getMethod(\"put\", Object.class, Object.class);\n        put.invoke(map, 1, new Object());\n        System.out.println(map);\n        String val = map.get(1);\n        System.out.println(val);\n    }\n\n", "\n\n", "执行结果（编译和执行版本都是1.6）：", "\n\n", " {1=java.lang.Object@2e6e1408}\nException in thread \"main\" java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String\n    at T002.main(T002.java:12)\n\n", "\n\n", "报错是在String val = map.get(1);这一行。", "\n\n", "我不解的是：", "\n通过反射，Integer-Object键值对竟然正确地放进了Integer-String的HashMap中！", "\n\n", "这种不合理的结果，应当是很严重的BUG了吧，但是也从没听谁提到过。", "\n\n", "希望大家多多指点"]], "Tag": "程序设计"}
