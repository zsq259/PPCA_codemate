{"Answer": "&lt;p&gt;全局变量是可以保证赋初值的&amp;#xff0c;局部变量不能保证。&lt;br /&gt;题主可以看到洛谷题解往往把数组声明为全局变量&amp;#xff0c;因为如果声明在main()里&amp;#xff0c;可能会出现一些“脏数据”。&lt;br /&gt;对于int变量&amp;#xff0c;将赋值为0是一个良好的习惯。&lt;br /&gt;如果我的回答对你有帮助&amp;#xff0c;还望采纳&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["不是说不给变量赋初值时变量默认为0吗", ["在写一道洛谷题目", "\n", "输出与预期不符", "\n", "\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "{\n    ", "int", " a[", "10", "],i,height;\n    ", "int", " q;\n    ", "for", "(i = ", "0", ";i < ", "10", ";i++){\n        ", "scanf", "(", "\"%d\"", ",&a[i]);\n    }\n    ", "scanf", "(", "\"%d\"", ",&height);\n    ", "for", "(i = ", "0", ";i < ", "10", ";i++){\n        ", "if", "(height + ", "30", " >= a[i]){\n            q++;\n        }\n    }\n    ", "printf", "(", "\"%d\"", ",q);\n    ", "return", " ", "0", ";\n\n}\n", "\n", "输入100 200 150 140 129 134 167 198 200 111 110 输出6", "\n", "我给q设置一个初值0即可解决，即int q = 0；但不是说不给变量赋初值时变量默认为0吗，为何问题出现在这里？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没有初值会随机赋一个初值&amp;#xff0c;这样后面如果不小心在用之前没有再赋值很容易出现奇怪的错误。建议所有的都赋初值。定义变量后&amp;#xff0c;它的值不确定&amp;#xff0c;除非你赋初始值。貌似有的编译器会默认初值为0。&lt;br /&gt;\n为什么定义有些变量需要赋0值呢&amp;#xff1f;&lt;br /&gt;\n那是功能实现上的需要&amp;#xff0c;一个变量不赋初始值&amp;#xff0c;直接用不确定的值&amp;#xff0c;那后面利用它进行运算&amp;#xff0c;结果就会不正常。有的编译器会默认不赋初值的变量为0。当然这是看你的需要。&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["什么情况下变量不用赋初始值？", ["在学校中老师反复提醒我们要给每一个变量赋初始值，但是之前我在一本书中看到他说有的变量不用赋初始值", "\n\n", " 所以我想知道什么情况下什么变量不用赋初始值"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给编译器看的&amp;#xff0c;人并不需要特别计较&lt;br /&gt;因为编译器需要规则&amp;#xff0c;就像楼上很多人说的&amp;#xff0c;编译器默认认为是double&amp;#xff0c;那么默认规则会有一些意外&amp;#xff08;比如就本来就是想要单精度浮点的运算 2/1&amp;#xff09;&amp;#xff0c;所以特别定义一个规则告诉编译器是你指定的类型&lt;/p&gt;\n&lt;p&gt;比较一下编译器的规则推论&amp;#xff08;当然个人说&amp;#xff1a;人不必计较&amp;#xff0c;这是给机器看的&amp;#xff0c;只是有时候出于某些特殊目的&amp;#xff0c;我需要强制约定一下&amp;#xff0c;避免默认计算规则不符合需求&amp;#xff09;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c#\"&gt;&lt;span class=\"hljs-attribute\"&gt;var&lt;/span&gt; m &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; / &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;  ------------啥都不加&amp;#xff0c;他是int\n&lt;span class=\"hljs-attribute\"&gt;var&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; / &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;-------------有&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;了&amp;#xff0c;默认是double\n&lt;span class=\"hljs-attribute\"&gt;var&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; / &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;.&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;f;----------------出于某些特殊需要&amp;#xff0c;我只需要单精度浮点\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "变量赋初值", "Question": ["实型变量赋初值右值“ f ”后缀的作用", ["想要询问一个很基础的问题，在给实型变量赋初值的时候，为什么后面要加一个 “ f ”呢？", "比如：", "\n", "float f=1.5f;", "\n", "以及有符号长整型和无符号长整型后面都有“ L ”，比如：", "\n", "unsigned long iUnsignedLongNum;", "iUnsignedLongNum=6666666L;", "\n", "感谢回答[rose]!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;让f()和h()再传一个参数作为初值&lt;br /&gt;比如这样&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; f(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; x,&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;) {\n  &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; s &amp;#61; &lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "变量赋初值", "Question": ["请问如何对循环函数内的变量赋初值而不会影响接下来的循环？", ["如图，我每次执行f（x）和h（x）的循环时，编译器总是会将s和sum赋为0，而我将s和sum在外层（也就是int main（）下面），它会提示s和sum是未在循环中声明的变量，请问如何解决"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为每次测试一个数之前s都要重置为0&lt;br /&gt;s是统计单独一个数的因子之和&lt;br /&gt;赋值在for外就不能每次测试一个数之前s重置为0&lt;br /&gt;所有数的因子之和都会累加在一起&amp;#xff0c;结果自然不对了&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["变量赋初值时在for外为什么无效？", ["int", " i, ", "n", ", s  ;\ns = ", "0", ";                                                     //在这里不出结果\nfor (", "n", " = ", "2", "; ", "n", " < ", "1000", "; ", "n", "++) {\n                                                                 //如果加在这里就可以得出结果\n    for (i = ", "1", "; i < ", "n", "; i++) {\n        ", "if", " ((", "n", " % i ) == ", "0", ") {\n            s = s + i;\n        }\n    }\n\n    ", "if", " (", "n", " == s)\n        printf(", "\"%d\\n\"", ", ", "n", ");\n\n\n}\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有些编译器会帮你默认为0值的&lt;br /&gt;有些编译器只在debug下才默认0值&lt;br /&gt;有些编译器不帮你提供默认值&lt;br /&gt;比如VS在debug下会默认为0值&amp;#xff0c;在release下则不会。&lt;br /&gt;良好的编码习惯是一定要显式的初始化为0值&amp;#xff0c;不要依赖编译器&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["结构体数组中的变量不赋初值为什么是0而不是随机数？它也不是static型呀", ["\n", "\n", "结构体数组中的变量不赋初值为什么是0而不是随机数？它也不是static型啊~~"]], "Tag": "程序设计"}
{"Answer": "其实a没有初始化也是有波浪线提示未赋初值，只是ide优先先提示没有定义变量的错误，这就是注释b那行或者先定义b后面也会出现a没初始化原因。", "Konwledge_Point": "变量赋初值", "Question": ["编译报错的问题，局部变量a没有赋初值，为什么没有编译报错？求大神解释下", ["public class VariableUse{", "\n    public static void main(String[] args){", "\n        int a;", "\n        if(a==8){", "\n            int b=9;", "\n            System.out.println(\"a=\"+a);", "\n            System.out.println(\"b=\"+b);", "\n        }", "\n        System.out.println(\"a=\"+a);", "\n        System.out.println(\"b=\"+b);//这行注释后就会报a没有赋初值的错误，但是不注释就只报变量b没有声明的错误", "\n    }", "\n}"]], "Tag": "程序设计"}
{"Answer": "## 错误代码\r\n\r\n```\r\n\tp = L;\r\n    printf(\"%d\\n\", n);\r\n    while (p!=NULL)\r\n    {//输出\r\n        printf(\"%s %s %.2f\\n\", p-&gt;no, p-&gt;name, p-&gt;price);\r\n        p = p-&gt;next;\r\n    }\r\n```\r\n## 错误原因\r\n未注意头结点与第一个元素结点（首元结点）的区别。若有头结点，则头指针指向头结点，头指针的下一结点才是首元结点。若没有，则头指针指向首元结点。\r\n而在你的程序中是包含头结点的，所以你遍历输出时应该从首元结点开始。\r\n即将p = L;改为p=L-&gt;next。\r\n## 正确代码\r\n\r\n```\r\n// WIN201905220810.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。\r\n//\r\n\r\n#include \"pch.h\"\r\n#include &lt;stdio.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n#define MAXSIZE 100\r\n\r\ntypedef struct LNode\r\n{\r\n\tchar no[20];\r\n\tchar name[50];\r\n\tfloat price;\r\n\tstruct LNode *next;\r\n}LNode, *LinkList;\r\n\r\nint main()\r\n{\r\n\tint n = 0;\r\n\tLNode *p, *q;\r\n\tLinkList L = (LNode *)malloc(sizeof(LNode));\r\n\tL-&gt;no[0] = '\\0';\r\n\tL-&gt;name[0] = '\\0';\r\n\tL-&gt;price = 0;\r\n\tL-&gt;next = NULL;\r\n\tq = L;\r\n\twhile (1)\r\n\t{\r\n\t\tp = (LNode *)malloc(sizeof(LNode));//开辟新结点\r\n\t\tp-&gt;next = NULL;\r\n\t\tscanf_s(\"%s %s %f\", p-&gt;no, 20, p-&gt;name, 50, &amp;p-&gt;price);\r\n\t\tif (p-&gt;no[0] == '0'&amp;&amp;p-&gt;name[0] == '0'&amp;&amp;p-&gt;price == 0)\r\n\t\t\tbreak;\r\n\t\tq-&gt;next = p;\r\n\t\tq = p;\r\n\t}\r\n\tp = L;\r\n\twhile (p-&gt;next != NULL)\r\n\t{//计结点个数\r\n\t\tn++;\r\n\t\tp = p-&gt;next;\r\n\t}\r\n\t//p = L;\r\n\tp = L-&gt;next;\r\n\tprintf(\"%d\\n\", n);\r\n\twhile (p != NULL)\r\n\t{//输出\r\n\t\tprintf(\"%s %s %.2f\\n\", p-&gt;no, p-&gt;name, p-&gt;price);\r\n\t\tp = p-&gt;next;\r\n\t}\r\n\tsystem(\"PAUSE\");\r\n\treturn 0;\r\n}\r\n\r\n```\r\n## 运行结果\r\n![图片说明](https://img-ask.csdn.net/upload/201905/22/1558484706_27331.png)", "Konwledge_Point": "变量赋初值", "Question": ["【新手提问】malloc函数会自行输出变量原始值？", ["刚学数据结构，在使用malloc函数时遇到了奇怪的问题：", "\n\n", "不知道为什么用了malloc之后，运行会自行输出变量的原始值，我的printf函数明明输出的是存储后的值。", "\n\n", "一开始程序会自行输出“屯屯屯屯屯屯屯屯”以及数字乱码，我百度之后就在malloc函数后对name数组、no数组和price赋了初值0，但程序还是自行输出了price的初始值0.00，如下图", "\n\n", "\n\n", "一些同学跟我一样的用法却没有这样的问题。", "\n\n", "为什么会有这样的情况？怎样才能让初始值不自行输出？", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n#define MAXSIZE 100\n\ntypedef struct LNode\n{\n    char no[20];\n    char name[50];\n    float price;\n    struct LNode *next;\n}LNode,*LinkList;\n\nint main()\n{\n    int n=0;\n    LNode *p,*q;\n    LinkList L = (LNode *)malloc(sizeof(LNode));\n    L->no[0]='\\0';\n    L->name[0]='\\0';\n    L->price=0;\n    L->next = NULL;\n    q = L;\n    while (1)\n    {\n        p = (LNode *)malloc(sizeof(LNode));//开辟新结点\n        p->next = NULL;\n        scanf_s(\"%s %s %f\", p->no, 20, p->name, 50, &p->price);\n        if (p->no[0] == '0'&&p->name[0] == '0'&&p->price == 0)\n            break;\n        q->next = p;\n        q = p;\n    }\n    p = L;\n    while (p->next!= NULL)\n    {//计结点个数\n        n++;\n        p = p->next;\n    }\n    p = L;\n    printf(\"%d\\n\", n);\n    while (p!=NULL)\n    {//输出\n        printf(\"%s %s %.2f\\n\", p->no, p->name, p->price);\n        p = p->next;\n    }\n    system(\"PAUSE\");\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没有。 你把你的程序写得让人类可以理解&amp;#xff0c;明确定义变量&amp;#xff0c; 算法高效&amp;#xff0c; 有必要的注释。 让 C 语言的编译器去搞定各种微小的优化问题。 &lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["C语言临时变量赋不赋初值效率上有差异吗？", ["int func(void)", "\n\n", "{int a;...}", "\n\n", " ", "\n\n", "与 int func(void)", "\n\n", "{ int a = 0; ...} 有无效率差异? ", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为从栈里面也优先分配前面的空余内存&amp;#xff0c;你一直都是执行这同一个函数&amp;#xff0c;并且只申请一个变量a&amp;#xff0c;执行完fun2又释放&amp;#xff0c;所有第二次申请还是那片内存。&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["函数里面不赋初值的变量，下一次调用为什么会保留上一次的值呢？", ["写单片机程序时遇到的问题，简化成下例之后。", "\n", "情况一：", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "void", " ", "fun2", "()", "{\n    ", "int", " a;\n    ", "printf", "(", "\"a=%d\\n\"", ",a++);\n}\n\n", "int", " ", "main", "(", "void", ")", "{\n    ", "fun2", "();\n    ", "fun2", "();\n    ", "fun2", "();\n    ", "fun2", "();\n    \n    ", "return", " ", "1", ";\n}\n\n", "\n", "运行结果：", "\n", "\n", "情况二：", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n\n", "void", " ", "fun2", "()", "{\n    ", "int", " a=", "0", ";\n    ", "printf", "(", "\"a=%d\\n\"", ",a++);\n}\n\n", "int", " ", "main", "(", "void", ")", "{\n    ", "fun2", "();\n    ", "fun2", "();\n    ", "fun2", "();\n    ", "fun2", "();\n    ", "return", " ", "1", ";\n}\n", "\n", "运行结果：", "\n", "\n", "情况二的结果我能理解，因为每次调用函数fun2时，都对变量a赋初值0，所以打印出的结果是a=0;", "但是情况一没有对a赋初值，int型变量默认赋初值0，那么每次调用时，我认为的过程：首先声明一个变量a，没有赋值，默认值为0，打印a的值a=0；下一次调用同上。运行结果和情况二相同。", "但是实际运行结果显示a保留了上一次的值，就像一个静态变量，请问这是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对的。你这代码中构造函数没有将指针赋值为空啊&lt;br /&gt;不用增加新的构造函数&amp;#xff0c;因为你不是通过构造函数传递这个指针的&amp;#xff0c;是某个功能键产生的。只需要恢复47行就OK&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["MFC如何添加成员变量和赋初值？", ["问题遇到的现象和发生背景", "\n", "鸡啄米例程12", "\n", "问题相关代码，请勿粘贴截图", "\n", "如何在AdditionDlg.h中为CAdditionDlg类添加private成员变量CTipDlg  *m_pTipDlg;？在构造函数体中添加m_pTipDlg = NULL;？", "\n", "这是 ", "AdditionDlg", ".", "h的代码\n", "class", " CaddationDlg : public CDialogEx\n{\n", "// 构造", "\n", "private", ":CTipDlg  *m_pTipDlg;", "//在AdditionDlg.h中为CAdditionDlg类添加private成员变量CTipDlg  *m_pTipDlg;。", "\n\npublic:\n    ", "CaddationDlg(CWnd", "*", " ", "pParent", " = NULL)", ";    ", "// 标准构造函数", "\n   ", "//CaddationDlg(CTipDlg*m_pTipDlg = NULL);", "\n", "// 对话框数据", "\n    enum { IDD = IDD_ADDATION_DIALOG };\n\n    protected:\n    ", "virtual", " void ", "DoDataExchange(CDataExchange", "*", " ", "pDX", ")", ";    ", "// DDX/DDV 支持", "\n\n\n", "// 实现", "\nprotected:\n    HICON m_hIcon;\n\n    ", "// 生成的消息映射函数", "\n    ", "virtual", " BOOL ", "OnInitDialog()", ";\n    afx_msg void ", "OnSysCommand(UINT ", "nID", ", LPARAM ", "lParam", ")", ";\n    afx_msg void ", "OnPaint()", ";\n    afx_msg HCURSOR ", "OnQueryDragIcon()", ";\n    ", "DECLARE_MESSAGE_MAP()", "\npublic:\n    double m_editSummand;", "//给文本编辑框添加的变量", "\n    double m_editAddend;", "//给文本编辑框添加的变量", "\n    double m_editSum;", "//给文本编辑框添加的变量", "\n    afx_msg void ", "OnBnClickedAddButton()", ";", "//就这一个是自己双击按钮生成的按钮触发函数", "\n};\n\n\n\n\n\n\n这是cpp代码\n\n\nCaddationDlg::", "CaddationDlg(CWnd", "*", " ", "pParent", " ", "/", "*", "=NULL", "*", "/", ")", "\n    : ", "CDialogEx(CaddationDlg::IDD, ", "pParent", ")", "\n    , m", "_editSummand(0)", "\n    , m", "_editAddend(0)", "\n    , m", "_editSum(0)", "\n    ", "//, m_pTipDlg(NULL)//在CAdditionDlg类的构造函数中初始化成员变量m_pTipDlg", "\n{\n    m_hIcon = ", "AfxGetApp()", "->", "LoadIcon(IDR_MAINFRAME)", ";\n}\n\nvoid CaddationDlg::", "DoDataExchange(CDataExchange", "*", " ", "pDX", ")", "\n{\n    CDialogEx::", "DoDataExchange(", "pDX", ")", ";  ", "// 处理MFC默认的数据交换  ", "\n    ", "DDX_Text(", "pDX", ", IDC_SUMMAND_EDIT, ", "m_editSummand", ")", ";", "// 处理控件IDC_SUMMAND_EDIT和变量m_editSummand之间的数据交换  ", "\n    ", "DDX_Text(", "pDX", ", IDC_ADDEND_EDIT, ", "m_editAddend", ")", "; ", "// 处理控件IDC_ADDEND_EDIT和变量m_editAddend之间的数据交换   ", "\n    ", "DDX_Text(", "pDX", ", IDC_SUM_EDIT, ", "m_editSum", ")", "; ", "// 处理控件IDC_SUM_EDIT和变量m_editSum之间的数据交换", "\n}\n\n", "BEGIN_MESSAGE_MAP(CaddationDlg, CDialogEx)", "\n    ", "ON_WM_SYSCOMMAND()", "\n    ", "ON_WM_PAINT()", "\n    ", "ON_WM_QUERYDRAGICON()", "\n    ", "ON_BN_CLICKED(IDC_ADD_BUTTON, &CaddationDlg::OnBnClickedAddButton)", "\n", "END_MESSAGE_MAP()", "\n\n\n", "// CaddationDlg 消息处理程序", "\n\nBOOL CaddationDlg::", "OnInitDialog()", "\n{\n    CDialogEx::", "OnInitDialog()", ";\n\n    ", "// 将“关于...”菜单项添加到系统菜单中。", "\n\n    ", "// IDM_ABOUTBOX 必须在系统命令范围内。", "\n    ", "ASSERT((IDM_ABOUTBOX & 0xFFF0)", " == ", "IDM_ABOUTBOX);\n    ", "ASSERT(IDM_ABOUTBOX < 0xF000)", ";\n\n    CMenu* pSysMenu = ", "GetSystemMenu(FALSE)", ";\n    ", "if", " (pSysMenu != NULL)\n    {\n        BOOL bNameValid;\n        CString strAboutMenu;\n        bNameValid = strAboutMenu.", "LoadString(IDS_ABOUTBOX)", ";\n        ", "ASSERT(", "bNameValid", ")", ";\n        ", "if", " (!strAboutMenu.", "IsEmpty()", ")\n        {\n            pSysMenu->", "AppendMenu(MF_SEPARATOR)", ";\n            pSysMenu->", "AppendMenu(MF_STRING, IDM_ABOUTBOX, ", "strAboutMenu", ")", ";\n        }\n    }\n\n    ", "// 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动", "\n    ", "//  执行此操作", "\n    ", "SetIcon(", "m_hIcon", ", TRUE)", ";            ", "// 设置大图标", "\n    ", "SetIcon(", "m_hIcon", ", FALSE)", ";        ", "// 设置小图标", "\n\n    ", "// ", "TODO:", "  在此添加额外的初始化代码", "\n\n    return TRUE;  ", "// 除非将焦点设置到控件，否则返回 TRUE", "\n}\n\nvoid CaddationDlg::", "OnSysCommand(UINT ", "nID", ", LPARAM ", "lParam", ")", "\n{\n    ", "if", " ((nID & ", "0xFFF0", ")", " == ", "IDM_ABOUTBOX)\n    {\n        CAboutDlg dlgAbout;\n        dlgAbout.", "DoModal()", ";\n    }\n    ", "else", "\n    {\n        CDialogEx::", "OnSysCommand(", "nID", ", ", "lParam", ")", ";\n    }\n}\n\n", "// 如果向对话框添加最小化按钮，则需要下面的代码", "\n", "//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，", "\n", "//  这将由框架自动完成。", "\n\nvoid CaddationDlg::", "OnPaint()", "\n{\n    ", "if", " (", "IsIconic()", ")\n    {\n        CPaintDC dc(this); ", "// 用于绘制的设备上下文", "\n\n        ", "SendMessage(WM_ICONERASEBKGND, ", "reinterpret_cast", "<WPARAM>(", "dc", ".GetSafeHdc()", "), ", "0", ");\n\n        ", "// 使图标在工作区矩形中居中", "\n        ", "int", " cxIcon = ", "GetSystemMetrics(SM_CXICON)", ";\n        ", "int", " cyIcon = ", "GetSystemMetrics(SM_CYICON)", ";\n        CRect rect;\n        ", "GetClientRect(&", "rect", ")", ";\n        ", "int", " x = (rect.", "Width()", " - cxIcon + ", "1", ")", " / ", "2", ";\n        ", "int", " y = (rect.", "Height()", " - cyIcon + ", "1", ")", " / ", "2", ";\n\n        ", "// 绘制图标", "\n        dc.", "DrawIcon(", "x", ", ", "y", ", ", "m_hIcon", ")", ";\n    }\n    ", "else", "\n    {\n        CDialogEx::", "OnPaint()", ";\n    }\n}\n\n", "//当用户拖动最小化窗口时系统调用此函数取得光标", "\n", "//显示。", "\nHCURSOR CaddationDlg::", "OnQueryDragIcon()", "\n{\n    return static_cast<HCURSOR>(m_hIcon);\n}\n\n\n\nvoid CaddationDlg::", "OnBnClickedAddButton()", "\n{\n    ", "// ", "TODO:", "  在此添加控件通知处理程序代码", "\n    ", "/*INT_PTR nRes;             // 用于保存DoModal函数的返回值   \n\n    CTipDlg tipDlg;           // 构造对话框类CTipDlg的实例   \n    nRes = tipDlg.DoModal();  // 弹出对话框   \n    if (IDCANCEL == nRes)     // 判断对话框退出后返回值是否为IDCANCEL，如果是则return，否则继续向下执行   \n    return;*/", "\n\n    ", "// 如果指针变量m_pTipDlg的值为NULL，则对话框还未创建，需要动态创建   ", "\n    ", "if", " (NULL", " == ", "m_pTipDlg)\n    {\n        ", "// 创建非模态对话框实例   ", "\n        m_pTipDlg = ", "new", " ", "CTipDlg()", ";\n        m_pTipDlg->", "Create(IDD_TIP_DIALOG, ", "this", ")", ";\n    }\n    ", "// 显示非模态对话框   ", "\n    m_pTipDlg->", "ShowWindow(SW_SHOW)", ";\n    ", "UpdateData(TRUE)", "; ", "// 将各控件中的数据保存到相应的变量 ", "\n    m_editSum = m_editSummand + m_editAddend;", "// 将被加数和加数的加和赋值给m_editSum  ", "\n    ", "UpdateData(FALSE)", "; ", "// 根据各变量的值更新相应的控件。和的编辑框会显示m_editSum的值", "\n\n\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "如果是C++的结构体，可以在构造函数中赋值，比如\r\nstruct data\r\n{\r\n int a;\r\n data()\r\n {\r\n  a = 1;\r\n }\r\n};", "Konwledge_Point": "变量赋初值", "Question": ["结构体对象使用malloc初始化时候有办法直接对结构体变量赋值吗", ["结构体对象使用malloc初始化时候有办法直接对结构体变量赋值吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;TH0&amp;#61;(8192-1000)/32&amp;#61;0xE0;&lt;br /&gt;TL0&amp;#61;(8192-1000)%32&amp;#61;0x18;&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["51单片机定时中断 工作方式0，  1ms 初值是如何计算的？", ["想请教一下 51单片机定时中断 工作方式0，  1ms  初值是如何计算的？", "\n", "（8192-1000）=（7192）十进制=（1C18）十六进制", "TH0=0x1C;", "TL0=0X18;", "还是", "TH0=(8192-1000)/32=0xE0;", "TL0=(8192-1000)%32=0x18;", "??", "\n", "void Dingshizhongdaun_0(void)  //定时器0中断配置 函数", "{", "    TMOD=TMOD|0x00;   //(TMOD) //选择为 定时器0模式，工作方式0, 13位定时器", "    TH0=???;//(T0)   //给定时器赋初值，定时1ms", "    TL0=???;", "    ET0=1;//(IE)     //打开定时器0中断允许", "    EA=1;//(IE)      //打开总中断", "    TR0=1;//(TCON)   //打开定时器", "}", "void Dingshizhongdaun_0_zhixing() interrupt 1 //定时器0中断函数", "{                                                //执行中断的内容", "    static u16 A1=0;//定义静态16位变量A1", "    TH0=0x??;//T0", "    TL0=0x??;   //给定时器赋初值，定时1ms", "    A1++;", "    if(A1==1000)  //1000*1ms=1s", "    {", "      A1=0;", "     Led1=!Led1;", "    }", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;表2名字相同的数字合并一起有for xml path&amp;#xff0c;分开各成一列没研究过。。应该要应用程序处理才行了。。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-sql\"&gt;--如果你的d字段内容为数字需要使用str(d)转字符串&amp;#xff0c;要不会报错\nselect c,STUFF((select &amp;#39;&amp;#xff0c;&amp;#39;&amp;#43;d from t2 where t2.c&amp;#61;t2_1.c for xml path(&amp;#39;&amp;#39;)),1,1,&amp;#39;&amp;#39;) from t2 t2_1\ngroup by c&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p style=\"text-align:center\"&gt;&lt;img alt=\"\" height=\"330\" src=\"https://img-ask.csdnimg.cn/upload/1615119686885.jpg\" width=\"812\" /&gt;&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["求一个sql server语句", ["\n\n", "表1状态为1的数据左连接表2"]], "Tag": "程序设计"}
{"Answer": "private static int bookNum;\r\nprivate static double price;\r\n这些不能是static的\r\n包括 public static void show()\r\n你首先应该把主程序和Book类分开写\r\n\r\n\r\n\r\n\r\n```\r\npackage les9;\r\n\r\nimport java.util.Scanner;\r\n\r\nclass Book {\r\n\r\n/**\r\n * @param args\r\n */\r\nprivate int bookNum;\r\nprivate double price;\r\npublic Book(int bookNum,double price){\r\n    this.bookNum=bookNum;\r\n    this.price=price;\r\n}\r\n\r\npublic static double MaxPrice(Book[] b){\r\n    double MaxPrice=Double.MIN_VALUE;\r\n    for(int i=0;i&lt;b.length;i++){\r\n        if(b[i].bookNum*b[i].price&gt;MaxPrice){\r\n            MaxPrice=b[i].bookNum*b[i].price;\r\n        }\r\n    }\r\n    return MaxPrice;\r\n}\r\n\r\npublic static double MinPrice(Book[] b){\r\n    double MinPrice=Double.MAX_VALUE;\r\n    for(int i=0;i&lt;b.length;i++){\r\n        if(b[i].bookNum*b[i].price&lt;MinPrice){\r\n            MinPrice=b[i].bookNum*b[i].price;\r\n        }\r\n    }\r\n    return MinPrice;\r\n}\r\n\r\npublic void show() {\r\n    System.out.println(\"数量:\"+bookNum+\"\\t单价:\"+price);\r\n}\r\n\r\npublic static void showAll(Book[] b) {\r\n    for(int i=0;i&lt;b.length;i++) {\r\n        System.out.println(\"数量:\"+b[i].bookNum+\"\\t单价:\"+b[i].price);\r\n    }\r\n}\r\n}\r\npublic class Program {\r\npublic static void main(String[] args) {\r\n    Book b[]=new Book[2];\r\n    Scanner sc=new Scanner(System.in);\r\n    for(int i=0;i&lt;b.length;i++){\r\n        System.out.println(\"请输入第\"+(i+1)+\"本书的单价:\");\r\n        int num=sc.nextInt();\r\n        System.out.println(\"请输入第\"+(i+1)+\"本书的数量:\");\r\n        double pri=sc.nextDouble();\r\n        b[i]=new Book(num,pri);\r\n        b[i].show();\r\n    }\r\n    Book.showAll(b);\r\n    System.out.println(\"最低价为:\"+Book.MinPrice(b));\r\n    System.out.println(\"最高价为:\"+Book.MaxPrice(b));\r\n}\r\n}\r\n```\r\n将Book.java重命名为Program.java", "Konwledge_Point": "变量赋初值", "Question": ["Java怎么用for循环给数组赋值？", ["package les9;", "\n\n", "import java.util.Scanner;", "\n\n", "public class Book {", "\n\n", "/**\n * @param args\n */\nprivate static int bookNum;\nprivate static double price;\npublic Book(int bookNum,double price){\n    this.bookNum=bookNum;\n    this.price=price;\n}\n\npublic static double MaxPrice(Book[] b){\n    double MaxPrice=Double.MIN_VALUE;\n    for(int i=0;i<b.length;i++){\n        if(b[i].bookNum*b[i].price>MaxPrice){\n            MaxPrice=b[i].bookNum*b[i].price;\n        }\n    }\n    return MaxPrice;\n}\n\npublic static double MinPrice(Book[] b){\n    double MinPrice=Double.MAX_VALUE;\n    for(int i=0;i<b.length;i++){\n        if(b[i].bookNum*b[i].price<MinPrice){\n            MinPrice=b[i].bookNum*b[i].price;\n        }\n    }\n    return MinPrice;\n}\n\npublic static void show() {\n    System.out.println(\"数量:\"+bookNum+\"\\t单价:\"+price);\n}\n\npublic static void showAll(Book[] b) {\n    for(int i=0;i<b.length;i++) {\n        System.out.println(\"数量:\"+b[i].bookNum+\"\\t单价:\"+b[i].price);\n    }\n}\npublic static void main(String[] args) {\n    Book b[]=new Book[2];\n    Scanner sc=new Scanner(System.in);\n    for(int i=0;i<b.length;i++){\n        System.out.println(\"请输入第\"+(i+1)+\"本书的单价:\");\n        int num=sc.nextInt();\n        System.out.println(\"请输入第\"+(i+1)+\"本书的数量:\");\n        double pri=sc.nextDouble();\n        b[i]=new Book(num,pri);\n        Book.show();\n    }\n    showAll(b);\n    System.out.println(\"最低价为:\"+Book.MinPrice(b));\n    System.out.println(\"最高价为:\"+Book.MaxPrice(b));\n}\n", "\n\n", "}", "\n\n", "代码如图，主要的问题是，如何在new一个对象的前提下，对数组进行循环赋值，并且能够输出前一轮循环赋值的数据"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为主函数main在定义变量d时未初始化&amp;#xff08;即没有初值&amp;#xff09;&amp;#xff0c;这时变量d中的值是垃圾值&amp;#xff08;即系统分配的随机值&amp;#xff0c;不同编译器下可能是1&amp;#xff0c;可能是0&amp;#xff0c;可能是其他值&amp;#xff0c;无法确定&amp;#xff09;&amp;#xff1b;而会有的输出结果即是你的d中的垃圾值与a运算后的结果&amp;#xff0c;举个例子&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a,b;\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,a&amp;#43;b);&lt;span class=\"hljs-comment\"&gt;//这样也会有输出结果&amp;#xff0c;但都是无法预料的&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;ps.如果要想将函数fun中的d作为主函数的d值&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//定义d为全局变量即可&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;fun&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p)&lt;/span&gt;\n&lt;/span&gt;{\nd&amp;#43;&amp;#61;p&amp;#43;&amp;#43;;\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,d);}\n&lt;span class=\"hljs-built_in\"&gt;main&lt;/span&gt;()\n{\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a&amp;#61;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n&lt;span class=\"hljs-built_in\"&gt;fun&lt;/span&gt;(a);\nd&amp;#43;&amp;#61;a&amp;#43;&amp;#43;;\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,d);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "变量赋初值", "Question": ["c语言变量未赋初值,运行输出结果是多少", ["#include  <stdio.h>", "int fun(int p)", "{int d=5;", "d+=p++;", "printf(\"%d\",d);}", "main()", "{int a=3,d;", "fun(a);", "d+=a++;", "printf(\"%d\\n\",d);}", "输出结果为83", "主函数中d没有初值为什么会有输出结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C不对的。编译器会报类型错误。比如&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;char* p1 &amp;#61; new char[256];&lt;/p&gt;\n\n&lt;p&gt;char** p2 &amp;#61; &amp;amp;p1; //正确&lt;/p&gt;\n\n&lt;p&gt;char* p3 &amp;#61; &amp;amp;p1; //  编译错误&amp;#xff0c;类型不匹配。&lt;/p&gt;\n\n&lt;p&gt; 其实C讲的是 p1 &amp;#61; &amp;amp;p1&amp;#xff1b;也是类型错误。&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["关于地址和指针的叙述中正确的是", ["想问一下，c为什么不对，感觉很绕 没太能理解，this指针不是指向自己的吗", "\n\n", "以下关于地址和指针的叙述中正确的是", "\n\n", "A可以取变量的地址赋值给同类型的指针变量", "\n\n", "B可以取常量的地址赋值给同类型的指针变量", "\n\n", "C可以取一个指针变量的地址赋给本指针变量，这样就使得指针变量指向自身", "\n\n", "D所有指针变量如果未赋初值，则自动赋空值NULL"]], "Tag": "程序设计"}
{"Answer": "把这里改成\r\nSystem.out.println(\"系统设置的数字是：\"+getNum());", "Konwledge_Point": "变量赋初值", "Question": ["抽象类变量没有赋初值 但是在普通方法中赋值了  为什么在子类中使用这个变量的时候一直输出是0", ["public abstract class GuessGame {", "\n    int num;", "\n    public abstract void showMessage();", "\n    public abstract void getUserInput();", "\n\n", "public int getNum(){\n    num=(int)(Math.random()*100);//将产生的随机数赋值给num\n    return num;\n}\n", "\n\n", "}", "\n\n", "子类使用num这个变量怎么都得不到随机数  而是始终得到的是0", "\npublic class Guess extends GuessGame{", "\n    int a ;", "\n    public void showMessage() {", "\n        System.out.println(\"系统设置的数字是：\"+num);", "\n        if(a\n            System.out.println(\"输入的数字小\");", "\n        }", "\n        if(a>num){", "\n            System.out.println(\"输入的数字大\");", "\n        }", "\n        if(a==num){", "\n            System.out.println(\"猜中了！\");", "\n        }", "\n        System.out.println(\"请问是否继续猜数\");", "\n        System.out.println(\"YES|NO\");", "\n        Scanner input = new Scanner(System.in);", "\n        if(input.next().equals(\"YES\")){", "\n            getUserInput();", "\n            showMessage();", "\n        }", "\n        else{", "\n            System.out.println(\"游戏结束\");", "\n        }", "\n    }", "\n\n", "public void getUserInput() {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(\"请输入您猜测的数字：\");\n     a = sc.nextInt();\n}\n", "\n\n", "}", "\n\n", "测试类", "\npublic class test {", "\n    public static void main(String[] args) {", "\n        Guess g = new Guess();", "\n        g.getUserInput();", "\n        g.showMessage();", "\n    }", "\n}", "\n\n", "结果如下", "\n请输入您猜测的数字：", "\n55", "\n系统设置的数字是：0", "\n输入的数字大", "\n请问是否继续猜数", "\nYES|NO", "\nYES", "\n请输入您猜测的数字：", "\n22", "\n系统设置的数字是：0", "\n输入的数字大", "\n请问是否继续猜数", "\nYES|NO"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这要看编译器的规则&amp;#xff0c;不同编译器不一样。有些会默认初始化为0&amp;#xff0c;有些不会&amp;#xff0c;就看申请的空间中残留的是什么值就是什么值&lt;br /&gt;还有就是大部分DEBUG调试情况下&amp;#xff0c;编译器会给默认初始化为0&amp;#xff1b;但RELEASE发布情况下&amp;#xff0c;不会进行默认初始化&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["结构体中的整形数组参数，如果未进行初始化赋值，默认值是多少？", ["这俩int类型的一维和二维数组，其元素默认为多少？", "\n", "typedef", " ", "struct", "\n{\n    ", "int", " vexnum;\n    ", "int", " arcnum;\n    ", "int", " arc_weight[Max_Node][Max_Node];", "//数组1", "\n    ", "int", " node_weight[Max_Node];", "//数组2", "\n}Graph;\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你调用方法的时候传进去的值就是初值啊&amp;#xff0c;方法是需要被调用给参数赋值才能执行的&amp;#xff0c;你创建的方法不被调用的情况不会被执行&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["Java局部变量............", ["Java中方法的参数也属于局部变量，但为什么参数可以不赋初值？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;该回答引用ChatGPT &lt;/p&gt;\n&lt;p&gt;在您的代码中&amp;#xff0c;使用 scanf 函数读取一个字符时&amp;#xff0c;需要使用 %c 格式字符串&amp;#xff0c;而不是 %s&amp;#xff0c;因为 %s 用于读取字符串。此外&amp;#xff0c;您可以使用字符指针来代替字符数组&amp;#xff0c;这样可以节省空间。修改后的代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;I like playing basketball!&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, str);\n\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入想删除的字符&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, &amp;amp;c);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str[i] &amp;#61;&amp;#61; c)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; i; j &amp;lt; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str); j&amp;#43;&amp;#43;)\n            {\n                str[j] &amp;#61; str[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n            }\n        }\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, str);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这个实现中&amp;#xff0c;使用了字符指针来代替字符数组&amp;#xff0c;因为字符串是常量&amp;#xff0c;无需在运行时修改。因此&amp;#xff0c;使用字符指针可以节省空间。&lt;/p&gt;\n&lt;p&gt;对于时间复杂度的问题&amp;#xff0c;您的算法的时间复杂度是 O(mn)&amp;#xff0c;其中 m 是字符串长度&amp;#xff0c;n 是要删除的字符的数量。在每次删除时&amp;#xff0c;您需要将剩余部分的字符串向左移动一个位置。因此&amp;#xff0c;您需要在最坏情况下移动 m 次&amp;#xff0c;因此总时间复杂度为 O(mn)。&lt;/p&gt;\n&lt;p&gt;为了提高时间复杂度&amp;#xff0c;您可以考虑使用双指针&amp;#xff0c;遍历字符串并在原地修改字符串。这样&amp;#xff0c;您只需要遍历一次字符串&amp;#xff0c;并在必要时删除字符&amp;#xff0c;时间复杂度将降至 O(m)。具体实现方式如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;I like playing basketball!&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, str);\n\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; c;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入想删除的字符&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;, &amp;amp;c);\n\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p &amp;#61; str;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *q &amp;#61; str;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (*q)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (*q !&amp;#61; c)\n        {\n            *p&amp;#43;&amp;#43; &amp;#61; *q;\n        }\n        q&amp;#43;&amp;#43;;\n    }\n    *p &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, str);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在这个实现中&amp;#xff0c;使用双指针&amp;#xff0c;一个指针用于遍历字符串&amp;#xff0c;另一个指针用于指向当前的有效字符。当遍历到不需要删除的字符时&amp;#xff0c;将其复制到有效字符的位置&amp;#xff0c;并将有效字符指针向前移动。这样&amp;#xff0c;在遍历结束时&amp;#xff0c;有效字符指针将指向新字符串的结尾。这个算法的时间复杂度是 O(m)&amp;#xff0c;其中 m 是字符串长度。&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["C语言字符数组与字符型指针", ["给字符型变量赋初值时，可以正常运行。输入一个字符给字符型变量时，没有运行结果。", "代码如下：", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", "<string.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "char", " str[] =", "\"I like playing basketball!\"", ";\n    ", "printf", "(", "\"%s\\n\"", ",str);\n    ", "char", " c;\n    ", "printf", "(", "\"请输入想删除的字符：\"", ");\n    ", "scanf", "(", "\"%s\"", ",&c);\n    ", "//c=getchar();", "\n    ", "printf", "(", "\"%s\\n\"", ",c);\n    ", "for", "(", "int", " i=", "0", ";i<", "strlen", "(str);i++)\n    {\n        ", "if", "(str[i]==c)\n        {\n            ", "for", "(", "int", " j=i;j<", "strlen", "(str);j++)\n            {\n                str[j]=str[j+", "1", "];\n            }\n        }\n    }\n    ", "printf", "(", "\"%s\\n\"", ",str);\n    ", "return", " ", "0", ";\n}\n", "\n", "运行结果截图：", "两种输入方式都是上图的结果。如果使用字符型指针，代码该如何修改？该算法的时间复杂度为O(mn),如何提高算法的时间复杂度？"]], "Tag": "程序设计"}
{"Answer": "```java\r\npackage cn.base;\r\n\r\n/**\r\n * @Description:\r\n * @Author :小书包\r\n * @CreateDate :2018-11-23 19:15\r\n */\r\npublic class People {\r\n    // 姓名\r\n    private String name;\r\n    // 身高\r\n    private double height;\r\n    // 体重\r\n    private double weight;\r\n    \r\n    // 构造方法\r\n    public People(String name, double height, double weight) {\r\n        this.name = name;\r\n        this.height = height;\r\n        this.weight = weight;\r\n    }\r\n    // 检查体重\r\n    public int checkWeight() {\r\n        // 获得标准体重\r\n        double standardWeight = this.height - 110;\r\n        if (weight &gt;= (standardWeight + 5)) {\r\n            return 1;\r\n        }\r\n        if (weight &lt;= (standardWeight - 5)) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        int[] arr = new int[50];\r\n        for (int i = 0; i &lt; 50; i++) {\r\n            int result = new People(\"张三\"+i,100,50).checkWeight();\r\n            arr[i] = result;\r\n        }\r\n        int heavyNums = 0;\r\n        int thinNums = 0;\r\n        int normalNums = 0;\r\n        for (int i = 0; i &lt; arr.length; i++) {\r\n            if (arr[i] == 1) heavyNums++;\r\n            if (arr[i] == -1) thinNums++;\r\n            if (arr[i] == 0) normalNums++;\r\n        }\r\n    \r\n        System.out.println(\"正常人数：\" + normalNums);\r\n        System.out.println(\"瘦的人数：\" + heavyNums);\r\n        System.out.println(\"胖的人数：\" + thinNums);\r\n    }\r\n}\r\n\r\n \r\n```", "Konwledge_Point": "变量赋初值", "Question": ["java定义类，对象，方法的问题", ["定义一个People类，要求如下：", "\n\n", "（1）成员变量：name、height、weight分别表示姓名、身高cm和体重kg", "\n\n", "（2）构造方法通过参数实现对成员变量的赋初值操作。", "\n\n", "（3）成员方法int check（），方法返回0，1，-1分别表示标准、过胖或过瘦。", "\n\n", "判断方法：用身高减去110作为参考体重，超过参考体重5kg以上的，过胖；低于参考体重5kg以上的，过瘦；在参考体重上下5kg以内的为标准。", "\n\n", "（4）main方法中，输入50个人的信息（姓名，身高，体重），分别输出标准，过胖，过瘦的人数，必须通过调用check方法实现", "\n\n", "这个题目的说用check方法返回 0 1 -1 但我怎么在main里去统计个数呢 ", "\n\n", "对这里学习的很模糊 求一份代码 学习一下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;为什么不设初值呢&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["请问为什么在for循环外面定义的变量，在for循环里面初值就变成1了", ["\n", "在下有一个问题，这个变量a没有赋初值时打印等于0；但是如果加到for循环里面他的初值就变成1了，请问为什么"]], "Tag": "程序设计"}
{"Answer": "catch (ArgumentOutOfRangeException e)\r\n修改为\r\ncatch (Exception e)\r\n\r\n如果丢出别的异常，那么不会走catch，导致myDirection = Orientation.North;并没有执行", "Konwledge_Point": "变量赋初值", "Question": ["C#中try...catch...finally初学，一个变量显示没有赋初始值？", ["当代码中有finally块时，代码如下：", "\nusing System;", "\nusing System.Collections.Generic;", "\nusing System.Linq;", "\nusing System.Text;", "\nusing System.Threading.Tasks;", "\nusing static System.Console;", "\n\n", "namespace ConsoleApplication13", "\n{", "\n    enum Orientation : byte", "\n    {", "\n        North = 1,", "\n        South = 2,", "\n        East = 3,", "\n        West = 4", "\n    }", "\n    class Program", "\n    {", "\n        static void Main(string[] args)", "\n        {", "\n\n", "        Orientation myDirection;\n        for (byte myByte = 2; myByte < 10; myByte++)\n        {\n\n            try\n            {\n                myDirection = checked((Orientation)myByte);\n                if ((myDirection < Orientation.North) || (myDirection > Orientation.West))\n                {\n                    throw new ArgumentOutOfRangeException(\"Value must between 1 and 4\");\n\n                }\n            }\n            catch (ArgumentOutOfRangeException e)\n            {\n                WriteLine(e.Message);\n                WriteLine(\"myDirection is assigned by default value, North\");\n                myDirection = Orientation.North;\n\n            }\n            finally\n            {\n             WriteLine($\" mydirection = {myDirection}\");\n            }\n\n\n\n            ReadKey();\n\n\n        }\n    }\n\n}\n", "\n\n", "}", "\n这时 WriteLine($\" mydirection = {myDirection}\");显示myDirection未赋值。", "\n但是当将", "\n                finally", "\n                {", "\n                 WriteLine($\" mydirection = {myDirection}\");", "\n                }", "\n改为只剩下", "\n                WriteLine($\" mydirection = {myDirection}\");", "\n时，就可以正常运行了。", "\n不清楚这个checked((Orientation)myByte)为什么在有finally块的时候没有成功赋值"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/kongbaidepao/article/details/15028099", "Konwledge_Point": "变量赋初值", "Question": ["安卓中 surfaceview中显示三个折线图，可左右拖动查看未显示的图形", ["我在做安卓surfaceview的时候，要加载显示3条折线，但只有一条折线的时候，正常拖动都没问题，一旦显示3条折线，拖动就不能显示预期的折线，拖动后显示的是一片空白，除了最右边一点折线", "\n\n", "自定义类", "\n\n", " public class MultiLineChartSurfaceView extends SurfaceView implements SurfaceHolder.Callback, Runnable {\n    /** surface持有者 */\n    private SurfaceHolder mHolder;\n    /** 当前画布 */\n    private Canvas mCanvas;\n    /** 是否开始绘画 */\n    private boolean mIsDrawing;\n\n    /** 坐标轴举例view边框的距离 */\n    private static final int DEFAULT_PADDING = 20;\n    /** 默认宽度设置为400dp */\n    private static final int DEFAULT_WIDTH = 450;\n    /** 默认高度设置为400dp */\n    private static final int DEFAULT_HEIGHT = 300;\n    /** 默认折线的颜色 */\n    private static final int DEFAULT_LINE_COLOR = Color.GREEN;\n    /** 默认x轴的颜色 */\n    private static final int DEFAULT_X_LINE_COLOR = 0xffEBEBEB;\n    /** 默认Y轴的颜色 */\n    private static final int DEFAULT_Y_LINE_COLOR = 0xffEBEBEB;\n    /** 默认折线的宽度 */\n    private static final int DEFAULT_LINE_WIDTH = 1;\n    /** 默认x轴的量程 */\n    private static final int DEFAULT_X_RANGE = 1000;\n    /** 默认y轴的量程 */\n    private static final int DEFAULT_Y_RANGE = 1000;\n    /** 默认x轴每个刻度代表的单位 */\n    private static final int DEFAULT_X_UNIT = 50;\n    /** 默认y轴每个刻度代表的单位 */\n    private static final int DEFAULT_Y_UNIT = 50;\n    /** 每个刻度的高度 */\n    private static final int DEFAULT_SCALE_HEIGHT = 4;\n    /** 默认x轴尽头箭头的长度 */\n    private static final int DEFAULT_X_BLANK = 20;\n    /** 默认y轴尽头箭头的长度 */\n    private static final int DEFAULT_Y_BLANK = 20;\n    /** x轴的单位 */\n    private int mXUnit;\n    /** 每个y轴的单位的高度 */\n    private int mYUnit;\n    /** 折线的颜色 */\n    private int mLineColor;\n    /** x轴的颜色 */\n    private int mXLineColor;\n    /** y轴的颜色 */\n    private int mYLineColor;\n    /** 折线的宽度 */\n    private int mLineWidth;\n    /** x轴的量程 */\n    private int mXRange;\n    /** y轴的量程 */\n    private int mYRange;\n    /** 绘制折线的画笔 */\n    private Paint mLinePaint;\n    /** 绘制坐标的画笔 */\n    private Paint mCoordinatePaint;\n    /** view的宽度 */\n    private int mWidth;\n    /** View的高度 */\n    private int mHeight;\n    /** 坐标轴距离view边距的间距 */\n    private int mPaddint;\n    /** 刻度的高度 */\n    private int mScaleHeight;\n    /** y轴的实际高度 */\n    private int mAxisHeight;\n    /** x轴的实际高度 */\n    private int mAxisWidth;\n    /** X轴最后一个竖线与箭头的空格 */\n    private int mXBlank;\n    /** Y轴最后一个竖线与箭头的空格 */\n    private int mYBlank;\n    /** 每个x轴刻度的宽度 */\n    private int mXScaleWidth;\n    /** 每个y轴刻度的宽度 */\n    private int mYScaleWidth;\n\n    /** 外部的list，用来存放折线上的值 */\n    private List<List<Integer>> mLines;\n    /** 最后一次点击的x坐标 */\n    private int lastX;\n    /** 偏移量，用来实现平滑移动 */\n    private int mOffset = 0;\n    /** 移动速度，用来实现速度递减 */\n    private int mSpeed = 0;\n    /** 是否触摸屏幕 */\n    private boolean mIsTouch = false;\n    /** 时间计数器，用来快速滚动时候减速 */\n    private int time = 0;\n    /** 移动时候X方向上的速度 */\n    private double xVelocity = 0;\n    /** 是否可以滚动，当不在范围时候不可以滚动 */\n    private boolean isScroll = true;\n    /** x轴上的格子数量 */\n    private int mXScaleNum;\n    /** y轴上的格子数量 */\n    private int mYScaleNum;\n\n    public MultiLineChartSurfaceView(Context context) {\n        this(context, null);\n    }\n\n    public MultiLineChartSurfaceView(Context context, AttributeSet attrs) {\n        this(context, attrs, -1);\n    }\n\n    public MultiLineChartSurfaceView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n        init();\n    }\n\n    /** 设置一些变量的尺寸 */\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        int widthMode = MeasureSpec.getMode(widthMeasureSpec);\n        int widthSize = MeasureSpec.getSize(widthMeasureSpec);\n        int heightMode = MeasureSpec.getMode(heightMeasureSpec);\n        int heightSize = MeasureSpec.getSize(heightMeasureSpec);\n        if (widthMode == MeasureSpec.AT_MOST) {\n            mWidth = dp2px(getContext(), DEFAULT_WIDTH);\n        } else {\n            mWidth = Math.max(widthSize, dp2px(getContext(), DEFAULT_WIDTH));\n        }\n        if (heightMode == MeasureSpec.AT_MOST) {\n            mHeight = dp2px(getContext(), DEFAULT_HEIGHT);\n        } else {\n            mHeight = Math.max(heightSize, dp2px(getContext(), DEFAULT_HEIGHT));\n        }\n        setMeasuredDimension(mWidth, mHeight);\n    }\n\n    /** 初始化surfaceView操作 */\n    private void init() {\n        mHolder = getHolder();\n        mHolder.addCallback(this);\n        // 设置可以获取焦点\n        setFocusable(true);\n        // 进入触摸输入模式后,该控件是否还有获得焦点的能力\n        setFocusableInTouchMode(true);\n        // 是否保持屏幕常亮\n        this.setKeepScreenOn(true);\n        // 为部分成员变量赋初值，可以写成自定义属性\n        mLineColor = DEFAULT_LINE_COLOR;\n        mLineWidth = dp2px(getContext(), DEFAULT_LINE_WIDTH);\n        mXLineColor = DEFAULT_X_LINE_COLOR;\n        mYLineColor = DEFAULT_Y_LINE_COLOR;\n        mXRange = DEFAULT_X_RANGE;\n        mYRange = DEFAULT_Y_RANGE;\n        mXUnit = DEFAULT_X_UNIT;\n        mYUnit = DEFAULT_Y_UNIT;\n        mPaddint = dp2px(getContext(), DEFAULT_PADDING);\n        mScaleHeight = dp2px(getContext(), DEFAULT_SCALE_HEIGHT);\n\n        mLinePaint = new Paint();\n        mCoordinatePaint = new Paint();\n    }\n\n    /** 子线程，循环绘制折线 */\n    @Override\n    public void run() {\n        // 如果处于绘画状态，那么就开始绘制\n        while (mIsDrawing) {\n            // 判断是否处于边缘状态\n            setSpeedCut();\n            // 绘制方法\n            draw();\n        }\n    }\n\n    /** 具体的绘制方法 */\n    private void draw() {\n        try {\n            long start = System.currentTimeMillis();\n            // 获取并锁定画布\n            mCanvas = mHolder.lockCanvas();\n            // 设置画布背景为白色\n            mCanvas.drawColor(0xff000000);\n            // 绘制坐标轴\n            drawAxis();\n            // 绘制曲线\n            drawLine();\n            long end = System.currentTimeMillis();\n            if (end - start < 50) {\n                Thread.sleep(50 - (end - start));\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (mCanvas != null) {\n                // 保证每次都将绘制的内容提交到服务器\n                mHolder.unlockCanvasAndPost(mCanvas);\n            }\n        }\n    }\n\n    /** 绘制坐标系 */\n    private void drawAxis() {\n        mCanvas.save();\n        // 移动坐标原点到左下角\n        mCanvas.translate(mPaddint, mHeight - mPaddint);\n        // 画线\n        drawXYLine();\n        // 绘制坐标轴上的刻度\n        // 绘制xy轴末端的箭头\n        drawXYScale();\n        mCanvas.restore();\n    }\n\n    /** 绘制折线 */\n    private void drawLine() {\n        mCanvas.save();\n        mCanvas.translate(mPaddint, mHeight - mPaddint);\n        // 设置画笔属性\n        mLinePaint.setAntiAlias(true);\n        mLinePaint.setStrokeWidth(3);\n        mLinePaint.setColor(mLineColor);\n        mLinePaint.setStyle(Style.STROKE);\n        //x轴每次的步进\n        int xInterval=(int)mXScaleWidth/5;\n        // 如果折线集合不为空\n        if (mLines != null && mLines.size() > 0) {\n            for(int k=0;k<mLines.size();k++) {\n                // 循环绘制所有线条\n                for (int i = 1; i < mLines.get(k).size(); i++) {\n                    // 上一个点的xy坐标\n                    int previousY = (int) (mLines.get(k).get(i - 1) * 1.0 / mYRange * (mAxisHeight - mYBlank));\n                    int previousX = (i - 1) * mXScaleWidth + mOffset;\n                    // 当前点的xy坐标\n                    int thisY = (int) (mLines.get(k).get(i) * 1.0 / mYRange * (mAxisHeight - mYBlank));\n                    int thisX = i * xInterval + mOffset;\n                    // 保证只绘制坐标轴范围内的部分\n                    if (previousX > 0 && previousX < mAxisWidth - mXBlank && thisX > 0 && thisX < mAxisWidth - mXBlank)\n                        // 两个坐标连线\n                        mCanvas.drawLine(previousX, -previousY, thisX, -thisY, mLinePaint);\n                }\n            }\n        }\n        mCanvas.restore();\n    }\n\n    /**\n     * 设置快速滚动时，末尾的减速\n     */\n    private void setSpeedCut() {\n        if (!mIsTouch && isScroll) {\n            // 通过当前速度计算所对应的偏移量\n            mOffset = mOffset + mSpeed;\n            setOffsetRange();\n        }\n        // 每次偏移量的计算\n        if (mSpeed != 0) {\n            time++;\n            mSpeed = (int) (xVelocity + time * time * (xVelocity / 1600.0) - (xVelocity / 20.0) * time);\n        } else {\n            time = 0;\n            mSpeed = 0;\n        }\n\n    }\n\n    /**\n     * 绘制x、y轴\n     */\n    private void drawXYLine() {\n        mAxisWidth = mWidth -  mPaddint;\n        mAxisHeight = mHeight - 2 * mPaddint;\n        mCoordinatePaint.setStrokeWidth(mLineWidth);\n        mCoordinatePaint.setAntiAlias(true);\n        // 绘制x轴\n        mCoordinatePaint.setColor(mXLineColor);\n        mCanvas.drawLine(0, 0, mAxisWidth, 0, mCoordinatePaint);\n        // 绘制y轴\n        mCoordinatePaint.setColor(mYLineColor);\n        mCanvas.drawLine(0, 0, 0, -mAxisHeight, mCoordinatePaint);\n    }\n\n    /** 绘制刻度线和箭头 */\n    private void drawXYScale() {\n        // 画y轴的刻度\n        mYScaleNum = mYRange / mYUnit;\n        mYScaleWidth = (int) (mAxisHeight * 1.0 / mYScaleNum);\n        mCoordinatePaint.setTextSize(30);\n        for (int i = 0; i < mYScaleNum; i++) {\n            mCanvas.drawLine(0, -mYScaleWidth * (i + 1), mAxisWidth, -mYScaleWidth * (i + 1), mCoordinatePaint);\n            String yText = \"\";\n            if (i== 3||i==9||i==15) {\n                yText = \"0\";\n                mCanvas.drawText(yText,-30,-mYScaleWidth * (i + 1),mCoordinatePaint);\n            } else if (i  == 1||i==7||i==13) {\n                yText = \"-1\";\n                mCanvas.drawText(yText,-30,-mYScaleWidth * (i + 1),mCoordinatePaint);\n            }\n            else if(i  == 5||i==11||i==17){\n                yText = \"1\";\n                mCanvas.drawText(yText,-30,-mYScaleWidth * (i + 1),mCoordinatePaint);\n            }\n        }\n\n        // 画x轴的刻度\n        // x轴的分割线数量\n        mXScaleNum=mAxisWidth/mYScaleWidth;\n        // 每个刻度的宽度\n        mXScaleWidth =mYScaleWidth;// (int) ((mAxisWidth - mXBlank) * 1.0 / mXScaleNum);\n        for (int i = 0; i < mXScaleNum; i++) {\n            mCanvas.drawLine(mXScaleWidth * (i + 1), 0, mXScaleWidth * (i + 1), -mAxisHeight, mCoordinatePaint);\n            if(i!=0&&(i+1)%5==0) {\n                mCanvas.drawText(String.valueOf((i+1) / 5), mXScaleWidth * (i + 1), 30, mCoordinatePaint);\n            }\n        }\n    }\n\n    /** 对偏移量进行边界值判定 */\n    private void setOffsetRange() {\n        int offsetMax = -mXScaleWidth * (mLines.size()) + (mXScaleWidth * mXScaleNum + 2);\n        int offsetMin = 2 * mXScaleWidth;\n        if (mOffset > offsetMin) {\n            isScroll = false;\n            mOffset = offsetMin;\n        } else if (mOffset < offsetMax) {// 如果划出最大值范围\n            isScroll = false;\n            mOffset = offsetMax;\n        } else {\n            isScroll = true;\n        }\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        int rawX = (int) (event.getRawX());\n        // 计算当前速度\n        VelocityTracker velocityTracker = VelocityTracker.obtain();\n        velocityTracker.addMovement(event);\n        // 计算速度的单位时间\n        velocityTracker.computeCurrentVelocity(50);\n        switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            // 记录触摸点坐标\n            lastX = rawX;\n            mIsTouch = true;\n            break;\n        case MotionEvent.ACTION_MOVE:\n            // 计算便宜量\n            int offsetX = rawX - lastX;\n            // 在当前偏移量的基础上增加偏移量\n            mOffset = mOffset + offsetX;\n            setOffsetRange();\n            // 偏移量修改后下次重绘会有变化\n            lastX = rawX;\n            // 获取X方向上的速度\n            xVelocity = velocityTracker.getXVelocity();\n            mSpeed = (int) xVelocity;\n            break;\n        case MotionEvent.ACTION_UP:\n            mIsTouch = false;\n            break;\n        }\n        // 计算完成后回收内存\n        velocityTracker.clear();\n        velocityTracker.recycle();\n        return true;\n    }\n\n    /**\n     * 画布创建时候执行的方法\n     * \n     * @param holder\n     */\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        // 开始绘画\n        mIsDrawing = true;\n        // 启动绘画线程\n        new Thread(this).start();\n\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n\n    }\n\n    /**\n     * 画布销毁时候执行的方法\n     */\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // 停止绘画\n        mIsDrawing = false;\n    }\n\n    /**\n     * 外部用来设置折线数据的方法\n     */\n    public void setSingleLine(List<Integer> lines) {\n        if(this.mLines==null)\n            mLines=new ArrayList<List<Integer>>() ;\n        this.mLines.add(lines);\n        invalidate();\n    }\n\n    /**\n     * 外部用来设置折线数据的方法\n     */\n    public void setMultiLines(List<List<Integer>> lines) {\n        if(this.mLines==null)\n            mLines=new ArrayList<List<Integer>>() ;\n        this.mLines=lines;\n        invalidate();\n    }\n\n    /** dp转化为px工具 */\n    private int dp2px(Context context, int dp) {\n        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp,\n                context.getResources().getDisplayMetrics());\n    }   \n}\n\n", "\n\n", "activity中", "\n\n", " public class MainActivity extends Activity {\n\n    private MultiLineChartSurfaceView mllcv;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        List<List<Integer>> mLinesList = getData();        \n        mllcv = (MultiLineChartSurfaceView) findViewById(R.id.mllcv);\n        mllcv.setMultiLines(mLinesList);\n    }\n\n    private List<List<Integer>> getData() {\n        List<List<Integer>> mLineList = new ArrayList<List<Integer>>();\n        List<Integer> line1 = new ArrayList<Integer>();\n        List<Integer> line2 = new ArrayList<Integer>();\n        for (int i = 0; i < 600; i++) {\n            line1.add(550 + (int) (Math.random() * 200));\n            line2.add(550 - (int) (Math.random() * 200));\n        }\n        mLineList.add(line1);\n        mLineList.add(line2);\n        return mLineList;\n    }\n}\n", "\n\n", "Layout", "\n\n", " <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\nandroid:paddingBottom=\"@dimen/activity_vertical_margin\"\nandroid:paddingLeft=\"@dimen/activity_horizontal_margin\"\nandroid:paddingRight=\"@dimen/activity_horizontal_margin\"\nandroid:paddingTop=\"@dimen/activity_vertical_margin\"\ntools:context=\"com.bisa.linetest.MainActivity\" >\n    <com.bisa.linetest.MultiLineChartSurfaceView\n        android:id=\"@+id/mllcv\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n</RelativeLayout>\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用代码段贴代码&amp;#xff0c;你这么弄还得重新给你组织代码。代码改成下面这样就不报错了。如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;time.h&amp;gt; //引入头文件 #include //头文件 \n#include &amp;lt;iostream&amp;gt;\nusing namespace std; \nvoid fun() //需计时的函数 \n{ \n\tint i&amp;#61;1; //定义变量i并赋初值 \n\tint sum&amp;#61;0; //定义变量sum并赋初值&amp;#xff0c;这两行可以合并&amp;#xff0c; int i&amp;#61;1,sum&amp;#61;0;\n\twhile(i&amp;lt;&amp;#61;100) //判断条件 \n\t{ \n\t\tsum&amp;#61;sum&amp;#43;i; //循环体 \n\t\ti&amp;#43;&amp;#43;; \n\t} \n\tcout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl; //输出语句 \n}\nint main() \n{\n\tclock_t start,end; //定义clock_t变量 \n\tstart &amp;#61; clock();   //开始时间 \n\t\n\tend &amp;#61; clock(); //结束时间 \n\tcout&amp;lt;&amp;lt;&amp;#34;time &amp;#61; &amp;#34;&amp;lt;&amp;lt;double(end-start)/CLOCKS_PER_SEC&amp;lt;&amp;lt;&amp;#34;s&amp;#34;&amp;lt;&amp;lt;endl; //输出时间&amp;#xff08;单位&amp;#xff1a;&amp;#xff53;&amp;#xff09; \n\treturn 0; //返回值 \n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["c++执行c1.exe是出错，是为什么？", ["#include 　　　//引入头文件\n#include  //头文件 \nusing namespace std;\nint main()\n{\nclock_t start,end;　　　//定义clock_t变量\nstart = clock();  　　　//开始时间\nfun()  //需计时的函数\n{\n  int i=1; //定义变量i并赋初值 \n  int sum=0; //定义变量sum并赋初值，这两行可以合并，  int i=1,sum=0;"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;都是基本的类定义和方法使用。&lt;br /&gt;一步步跟着题目要求写&amp;#xff0c;挺详细的。&lt;br /&gt; &lt;a href=\"https://blog.csdn.net/qq_36055407/article/details/81182967?utm_source&amp;#61;app&amp;amp;app_version&amp;#61;4.16.0\" id=\"textarea_1634660712723_1634660865177_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;习题Hero_学习中....的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;&amp;#xff08;1&amp;#xff09;定义一个游戏中Hero 英雄的类&amp;#xff0c;在该类中定义英雄的名字&amp;#xff0c; 生命值和等级3 个属性&amp;#xff0c;定义一个构造函数完成对生命值和等级的初始化&amp;#xff0c;分别赋初值为100&amp;#xff0c;1。同时实现名字的输入和英雄信息的输出。&amp;#xff08;2&amp;#xff09;在上一题的基础上&amp;#xff0c;为英雄再定义拥有一个参数的构造方法&amp;#xff0c;传入一个英雄类型的值&amp;#xff0c;如果为1&amp;#xff0c;则为普通英雄&amp;#xff0c;生命值为100&amp;#xff0c;如果该值为2&amp;#xff0c;则为高级英雄&amp;#xff0c;生命值初始化为200。&amp;#xff08;3&amp;#xff09;在上两英雄类型的基础...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_36055407/article/details/81182967?utm_source&amp;#61;app&amp;amp;app_version&amp;#61;4.16.0&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["定义一个游戏中Hero 英雄的类,该类属于某个包，在该类中定义英雄的名字， 生命值和等级3 个属性。", [" 3、构造函数重载", "    （1）定义一个游戏中Hero 英雄的类,该类属于某个包（包名cn.edu.zucc.he)，在该类中定义英雄的名字， 生命值和等级3 个属性，定义一个无参构造方法完成对名字、生命值和等级的初始化，分别赋初值为“无名英雄”、100和1。同时实现名字和英雄信息的输出。", "    （2）在上一步的基础上，为英雄再定义拥有一个参数的构造方法，第一个参数传入英雄的名字,第二个参数传入一个英雄类型的值，如果为1，则为普通英雄，生命值为100；如果该值为2，则为高级英雄，生命值初始化为200；如果该值为3，则为超级英雄，生命值初始化为300。", "    （3）为英雄添加一个基本战斗的方法，该方法拥有一个英雄类型的参数，当传入另一个英雄时，能降低对方10点血。 再增加一个绝招战斗的重载方法，加入一个绝招类型参数，通过输入不同绝招参数，降低对方不同的血量（这里简化为：1，多杀伤3点血，2，多杀伤6点血，3，多杀伤10点血）。", "    （4）在主类的主方法中编写代码，测试。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这样吗&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-variable\"&gt;name&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;name:&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=\"hljs-variable\"&gt;sex&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;sex&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=\"hljs-variable\"&gt;hobby&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;hobby&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n&lt;span class=\"hljs-variable\"&gt;age&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;age&amp;#34;&lt;/span&gt;))&lt;/span&gt;\n&lt;span class=\"hljs-variable\"&gt;height&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;float&lt;/span&gt;(&lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;height&amp;#34;&lt;/span&gt;))&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;我叫{},{}孩,平时喜欢{},今年{}岁了,身高{}&amp;#34;&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "变量赋初值", "Question": ["但是不太懂 过程解答 !", ["完成输出个人简介任务，须首先定义字符串类型变量name（姓名）、sex（性别）和hobby（爱好），整型变量age（年龄），浮点型变量height（身高），并分别赋初值；然后使用print()函数输出个人简介。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;A&lt;br /&gt; 对的&amp;#xff0c;m&amp;#61;&amp;#61;n的值反正不是1就是0&lt;br /&gt;k&amp;#61;(m&amp;#61;&amp;#61;n);&lt;br /&gt;B&lt;br /&gt; 缺分号&lt;br /&gt;k&amp;#61;-m-n&lt;br /&gt;C&lt;br /&gt; int不是函数&amp;#xff0c;这不是python&amp;#xff0c;要写成(int)(m&amp;#43;n)才行&lt;br /&gt;k&amp;#61;int(m&amp;#43;n);&lt;br /&gt;D&lt;/p&gt;\n&lt;p&gt;k&amp;#61;m*n&amp;#61;1;&lt;br /&gt;等价于&lt;br /&gt;m*n&amp;#61;1;&lt;br /&gt;k&amp;#61;m*n;&lt;br /&gt;k&amp;#61;m*n;没问题&amp;#xff0c;你把1的值赋值给m*n&amp;#xff0c;这是个表达式不是个变量呀&lt;/p&gt;", "Konwledge_Point": "变量赋初值", "Question": ["BCD哪错了？谁可以写一下解析？", ["若变量已正确定义并赋初值，以下合法的赋值语句是（）。", "\n", "A\n\nk=(", "m", "==n);\nB\n\n", "k", "=-m-n\nC\n\n", "k", "=int(m+n);\nD\n\n", "k", "=m*n=1;\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n\nfor&amp;#xff08;&lt;span class=\"hljs-attribute\"&gt;&amp;lt;初始化&amp;gt;&lt;/span&gt;&amp;#xff0c;&lt;span class=\"hljs-attribute\"&gt;&amp;lt;条件表达式&amp;gt;&lt;/span&gt;,&lt;span class=\"hljs-attribute\"&gt;&amp;lt;控制变量增量&amp;gt;&lt;/span&gt;&amp;#xff09;\n \n{\n \n循环整体用法\n \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "变量赋初值", "Question": ["关于for循环的疑问", ["这里的k是什么意思呀？如果是表示一个变量，为什么for后面的括号有但是循环里面却没有出现呢？first我也看不太明白，first=1不是给他赋初值吗？为什么可以表示判断字符是否是输出的第一个字符捏，大一新生满头雾水，可以帮我解答一下吗？谢谢！", "\n", "标签"]], "Tag": "程序设计"}
