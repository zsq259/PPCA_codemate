{"Answer": "&lt;p&gt;把求差集和并集的逻辑再&amp;#43;和-函数中实现就可以了。&lt;br /&gt;集合中的数据由键盘输入&amp;#xff0c;运行结果如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/915852123656116.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAX 10&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;set&lt;/span&gt; \n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;set&lt;/span&gt;() { len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; }&lt;span class=\"hljs-comment\"&gt;//构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d)&lt;/span&gt;&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//向集合添加元素&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;length&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; len; }&lt;span class=\"hljs-comment\"&gt;//返回集合中元素个数&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getd&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)&lt;/span&gt;&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//返回集合中位置i的元素&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;disp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//显示集合元素&lt;/span&gt;\n    set &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(set s1);&lt;span class=\"hljs-comment\"&gt;//重载&amp;#43;&amp;#xff0c;实现集合的并集运算&lt;/span&gt;\n    set &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(set s1);&lt;span class=\"hljs-comment\"&gt;//重载-&amp;#xff0c;实现集合的差集运算&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;protected&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len;&lt;span class=\"hljs-comment\"&gt;//集合中元素个数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s[MAX];\n};&lt;span class=\"hljs-comment\"&gt;//集合中元素&lt;/span&gt;\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;set::input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d)&lt;/span&gt;\n&lt;/span&gt;{\n    s[len&amp;#43;&amp;#43;] &amp;#61; d;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;set::getd&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s[i]; }\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;set::disp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;lt; len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            cout &amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt; endl;\n    }\n}\n\nset set::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(set s1)\n{\n    set sout;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lens1 &amp;#61; s1.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;();\n    &lt;span class=\"hljs-comment\"&gt;//先把this的数据添加到sout中&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        sout.&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(s[i]);\n    }\n    &lt;span class=\"hljs-comment\"&gt;//再把s1中的数据添加到sout中&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; lens1; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; len; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-built_in\"&gt;getd&lt;/span&gt;(j) &amp;#61;&amp;#61; s1.&lt;span class=\"hljs-built_in\"&gt;getd&lt;/span&gt;(i))\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; len)\n            sout.&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(s1.&lt;span class=\"hljs-built_in\"&gt;getd&lt;/span&gt;(i));\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sout;\n}\n&lt;span class=\"hljs-comment\"&gt;//重载-&amp;#xff0c;实现集合的差集运算&lt;/span&gt;\nset set::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(set s1)\n{\n    set sout;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; lens1 &amp;#61; s1.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; lens1; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s1.&lt;span class=\"hljs-built_in\"&gt;getd&lt;/span&gt;(j) &amp;#61;&amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-built_in\"&gt;getd&lt;/span&gt;(i))\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; lens1)\n            sout.&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-built_in\"&gt;getd&lt;/span&gt;(i));\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sout;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    set s1, s2;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len1, len2, t;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入集合1的数据个数&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; len1;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入集合1的数据&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len1; i&amp;#43;&amp;#43;)\n    {\n        cin &amp;gt;&amp;gt; t;\n        s1.&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(t);\n    }\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入集合2的数据个数&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; len2;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入集合2的数据&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len2; i&amp;#43;&amp;#43;)\n    {\n        cin &amp;gt;&amp;gt; t;\n        s2.&lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;(t);\n    }\n    &lt;span class=\"hljs-comment\"&gt;//输出&lt;/span&gt;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;集合s1中的元素个数是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; s1.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;其中含有的元素是&amp;#34;&lt;/span&gt;;\n    s1.&lt;span class=\"hljs-built_in\"&gt;disp&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;集合s2中的元素个数是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; s2.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;其中含有的元素是&amp;#34;&lt;/span&gt;;\n    s2.&lt;span class=\"hljs-built_in\"&gt;disp&lt;/span&gt;();\n\n    set sout1 &amp;#61; s1 &amp;#43; s2;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;集合s1和集合s2的并集为s1&amp;#43;s2&amp;#xff0c;元素个数是&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; sout1.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;其中含有的元素是&amp;#34;&lt;/span&gt;;\n    sout1.&lt;span class=\"hljs-built_in\"&gt;disp&lt;/span&gt;();\n\n\n    set sout2 &amp;#61; s1 - s2;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;集合s1和集合s2的差集为s1-s2&amp;#xff0c;元素个数是&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; sout2.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;其中含有的元素是&amp;#34;&lt;/span&gt;;\n    sout2.&lt;span class=\"hljs-built_in\"&gt;disp&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["设计一个类，利用运算符重载，进行集合的并集、差集运算", ["设计一个类，利用运算符重载，进行集合的并集、差集运算，例如输入整数集合s1{9 5 2}和s2{7 5}，计算它们的并运算s1+s2，s1-s2,并能显示输出。示例数据显示运行结果如下：", "\n", "\n", "\n", "类设计提示如下：", "\n", "class", " ", "set", "{\n", "public", ":\n    ", "set", "(){len=", "0", ";}", "//构造函数", "\n    ", "void", " ", "input", "(", "int", " d", ")", ";", "//向集合添加元素", "\n    ", "int", " ", "length", "(", ")", "{", "return", " len;}", "//返回集合中元素个数", "\n    ", "int", " ", "getd", "(", "int", " i", ")", ";", "//返回集合中位置i的元素", "\n    ", "void", " ", "disp", "(", ")", ";", "//显示集合元素", "\n    ", "set", " ", "operator", "+(", "set", " s1);", "//重载+，实现集合的并集运算", "\n", "set", " ", "operator", "-(", "set", " s1);", "//重载-，实现集合的差集运算", "\n", "protected", ":\n    ", "int", " len;", "//集合中元素个数", "\n", "int", " s[MAX];};", "//集合中元素", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;c&amp;#43;&amp;#43;重载加法。&lt;br /&gt;仅供参考。&lt;br /&gt;就是将参数 const Box&amp;amp; b 计算成新的Box. 没有难度啊。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n \n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Box&lt;/span&gt;\n{\n   &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n \n      &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getVolume&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n      &lt;/span&gt;{\n         &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; length * breadth * height;\n      }\n      &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setLength&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; len )&lt;/span&gt;\n      &lt;/span&gt;{\n          length &amp;#61; len;\n      }\n \n      &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setBreadth&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; bre )&lt;/span&gt;\n      &lt;/span&gt;{\n          breadth &amp;#61; bre;\n      }\n \n      &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setHeight&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; hei )&lt;/span&gt;\n      &lt;/span&gt;{\n          height &amp;#61; hei;\n      }\n      &lt;span class=\"hljs-comment\"&gt;// 重载 &amp;#43; 运算符&amp;#xff0c;用于把两个 Box 对象相加&lt;/span&gt;\n      Box &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Box&amp;amp; b)\n      {\n         Box box;\n         box.length &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;length &amp;#43; b.length;\n         box.breadth &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;breadth &amp;#43; b.breadth;\n         box.height &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;height &amp;#43; b.height;\n         &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; box;\n      }\n   &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n      &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; length;      &lt;span class=\"hljs-comment\"&gt;// 长度&lt;/span&gt;\n      &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; breadth;     &lt;span class=\"hljs-comment\"&gt;// 宽度&lt;/span&gt;\n      &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; height;      &lt;span class=\"hljs-comment\"&gt;// 高度&lt;/span&gt;\n};\n&lt;span class=\"hljs-comment\"&gt;// 程序的主函数&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( )&lt;/span&gt;\n&lt;/span&gt;{\n   Box Box1;                &lt;span class=\"hljs-comment\"&gt;// 声明 Box1&amp;#xff0c;类型为 Box&lt;/span&gt;\n   Box Box2;                &lt;span class=\"hljs-comment\"&gt;// 声明 Box2&amp;#xff0c;类型为 Box&lt;/span&gt;\n   Box Box3;                &lt;span class=\"hljs-comment\"&gt;// 声明 Box3&amp;#xff0c;类型为 Box&lt;/span&gt;\n   &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; volume &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;// 把体积存储在该变量中&lt;/span&gt;\n \n   &lt;span class=\"hljs-comment\"&gt;// Box1 详述&lt;/span&gt;\n   Box1.&lt;span class=\"hljs-built_in\"&gt;setLength&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;6.0&lt;/span&gt;); \n   Box1.&lt;span class=\"hljs-built_in\"&gt;setBreadth&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;7.0&lt;/span&gt;); \n   Box1.&lt;span class=\"hljs-built_in\"&gt;setHeight&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5.0&lt;/span&gt;);\n \n   &lt;span class=\"hljs-comment\"&gt;// Box2 详述&lt;/span&gt;\n   Box2.&lt;span class=\"hljs-built_in\"&gt;setLength&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;12.0&lt;/span&gt;); \n   Box2.&lt;span class=\"hljs-built_in\"&gt;setBreadth&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;13.0&lt;/span&gt;); \n   Box2.&lt;span class=\"hljs-built_in\"&gt;setHeight&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;10.0&lt;/span&gt;);\n \n   &lt;span class=\"hljs-comment\"&gt;// Box1 的体积&lt;/span&gt;\n   volume &amp;#61; Box1.&lt;span class=\"hljs-built_in\"&gt;getVolume&lt;/span&gt;();\n   cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Volume of Box1 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; volume &amp;lt;&amp;lt;endl;\n \n   &lt;span class=\"hljs-comment\"&gt;// Box2 的体积&lt;/span&gt;\n   volume &amp;#61; Box2.&lt;span class=\"hljs-built_in\"&gt;getVolume&lt;/span&gt;();\n   cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Volume of Box2 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; volume &amp;lt;&amp;lt;endl;\n \n   &lt;span class=\"hljs-comment\"&gt;// 把两个对象相加&amp;#xff0c;得到 Box3&lt;/span&gt;\n   Box3 &amp;#61; Box1 &amp;#43; Box2;\n \n   &lt;span class=\"hljs-comment\"&gt;// Box3 的体积&lt;/span&gt;\n   volume &amp;#61; Box3.&lt;span class=\"hljs-built_in\"&gt;getVolume&lt;/span&gt;();\n   cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Volume of Box3 : &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; volume &amp;lt;&amp;lt;endl;\n \n   &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你写&amp;gt;&amp;gt;&lt;br /&gt;不就是重载输入 方法吗&lt;br /&gt;写几个cin&amp;gt;&amp;gt;&lt;br /&gt;return Date 不就行了。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["日期类输入运算符重载 ：日期类Date，重载输入运算符\">>\"", ["这个问题毫无头绪，日期类还能定义，但是运算符的重载一窍不通", "\n", "函数接口定义：", "\n", "在这里描述函数接口。例如：\nistream ", "&operator", ">>(istream ", "&in", ",Date ", "&date", ")", ";", "\n\n", "\n", "裁判测试程序样例：", "\n", "在这里给出函数被调用进行测试的例子。例如：\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Date", "\n{\n    ", "private", ":\n    ", "int", " year,month,day;\n    ", "public", ":\n    ", "Date", "(", "int", " y = ", "0", ",", "int", " m = ", "0", ",", "int", " d = ", "0", ")\n    {\n        year = y;\n        month = m;\n        day = d;\n    }\n    ", "int", " ", "getYear", "()", "const", "\n    ", "{\n        ", "return", " year;\n    }\n    ", "int", " ", "getMonth", "()", "const", "\n    ", "{\n        ", "return", " month;\n    }\n    ", "int", " ", "getDay", "()", "const", "\n    ", "{\n        ", "return", " day;\n    }\n    ", "void", " ", "setYear", "(", "int", " y)", "\n    ", "{\n        year = y;\n    }\n    ", "void", " ", "setMonth", "(", "int", " m)", "\n    ", "{\n        month = m;\n    }\n    ", "void", " ", "setDay", "(", "int", " d)", "\n    ", "{\n        day = d;\n    }\n};\n\n", "/* 请在这里填写答案 */", "\n\nostream &", "operator", "<<(ostream &out,", "const", " Date &date)\n{\n    cout<<date.", "getYear", "()<<", "'-'", ";\n    ", "if", "(date.", "getMonth", "() < ", "10", ")\n    {\n        cout<<", "'0'", ";\n    }\n    cout<<date.", "getMonth", "()<<", "'-'", ";\n    ", "if", "(date.", "getDay", "() < ", "10", ")\n    {\n        cout<<", "'0'", ";\n    }\n    cout<<date.", "getDay", "();\n}\n", "int", " ", "main", "()", "\n", "{\n    Date d1;\n    cin>>d1;\n    cout<<d1;\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "输入样例：", "在这里给出一组输入。例如：", "\n", "2020 ", "12", " ", "1", "\n\n", "\n", "输出样例：", "在这里给出相应的输出。例如：", "\n", "2020", "-", "12", "-", "01", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;\nusing namespace std;\nclass  &lt;span class=\"hljs-keyword\"&gt;jz\n&lt;/span&gt;{\n&lt;span class=\"hljs-symbol\"&gt;public:&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;jz();\n&lt;/span&gt;    friend &lt;span class=\"hljs-keyword\"&gt;jz &lt;/span&gt;operator&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;jz&amp;amp;, &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;jz&amp;amp;);\n&lt;/span&gt;    void input();\n    void &lt;span class=\"hljs-keyword\"&gt;display();\n&lt;/span&gt;&lt;span class=\"hljs-symbol\"&gt;private:&lt;/span&gt;\n    int A[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n};\n&lt;span class=\"hljs-keyword\"&gt;jz::jz()\n&lt;/span&gt;{\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; 2; i&amp;#43;&amp;#43;)&lt;/span&gt;\n        for (int &lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; j &amp;lt; 3; j&amp;#43;&amp;#43;)&lt;/span&gt;\n            A[i][&lt;span class=\"hljs-keyword\"&gt;j] &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;jz &lt;/span&gt;operator&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;jz&amp;amp;a, &lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;jz&amp;amp;b)\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;jz &lt;/span&gt;c;\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; 2; i&amp;#43;&amp;#43;)&lt;/span&gt;\n        for (int &lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; j &amp;lt; 3; j&amp;#43;&amp;#43;)&lt;/span&gt;\n            c.A[i][&lt;span class=\"hljs-keyword\"&gt;j] &lt;/span&gt;&amp;#61; a.A[i][&lt;span class=\"hljs-keyword\"&gt;j] &lt;/span&gt;&amp;#43; &lt;span class=\"hljs-keyword\"&gt;b.A[i][j];\n&lt;/span&gt;    return c;\n}\nvoid &lt;span class=\"hljs-keyword\"&gt;jz::input()\n&lt;/span&gt;{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入矩阵元素:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; 2; i&amp;#43;&amp;#43;)&lt;/span&gt;\n        for (int &lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; j &amp;lt; 3; j&amp;#43;&amp;#43;)&lt;/span&gt;\n            cin &amp;gt;&amp;gt; A[i][&lt;span class=\"hljs-keyword\"&gt;j];\n&lt;/span&gt;}\nvoid &lt;span class=\"hljs-keyword\"&gt;jz::display()\n&lt;/span&gt;{\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; 2; i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        for (int &lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; j &amp;lt; 3; j&amp;#43;&amp;#43;)&lt;/span&gt;\n            cout &amp;lt;&amp;lt; A[i][&lt;span class=\"hljs-keyword\"&gt;j] &lt;/span&gt;&amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; endl;\n    }\n}\nint main()\n{\n    &lt;span class=\"hljs-keyword\"&gt;jz &lt;/span&gt;a, &lt;span class=\"hljs-keyword\"&gt;b, &lt;/span&gt;c;\n    a.input();\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;矩阵a为:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    a.&lt;span class=\"hljs-keyword\"&gt;display();\n&lt;/span&gt;    &lt;span class=\"hljs-keyword\"&gt;b.input();\n&lt;/span&gt;    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;矩阵b为:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;b.display();\n&lt;/span&gt;    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;两个矩阵相加之后的矩阵c为:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    c &amp;#61; a &amp;#43; &lt;span class=\"hljs-keyword\"&gt;b;\n&lt;/span&gt;    c.&lt;span class=\"hljs-keyword\"&gt;display();\n&lt;/span&gt;}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["第三题不会呀能不能看一下，怎么进行输入运算符重载数组，然后进行运算符重载相加，如何在c++中定义一个二维数组", ["第三题不会呀能不能看一下，怎么进行输入运算符重载数组，然后进行运算符重载相加，如何在c++中定义一个二维数组"]], "Tag": "程序设计"}
{"Answer": "```\r\n e=c+d;  //这里重载之后 C的值已经改变了。。\r\n\te.display ();\r\n\tf=d-c;\r\n```", "Konwledge_Point": "运算符重载", "Question": ["运算符重载只能运行加法，减法是两个数反过来减了？求问大神", ["#include", "\nusing namespace std;", "\nclass RMB{", "\n    int yuan,jiao,fen;", "\npublic:", "\n    RMB(int y=0,int j=0,int f=0)", "\n    {", "\n        yuan=y;jiao=j;fen=f;", "\n        if(jiao>=10)              //让分，角逢十进一", "\n        {", "\n            jiao=jiao-10;yuan=yuan+1;", "\n        }", "\n        if(fen>=10)", "\n        {", "\n            fen=fen-10;", "\n            jiao=jiao+1;", "\n        }", "\n    }", "\n    RMB operator+(RMB b);", "\n    RMB operator-(RMB b);", "\n    void display();", "\n};", "\nRMB RMB::operator +(RMB b)", "\n{", "\n    yuan=yuan+b.yuan;", "\n    jiao=jiao+b.jiao;", "\n    fen=fen+b.fen;", "\n    if(fen>=10)", "\n    {", "\n        fen=fen-10;", "\n        jiao=jiao+1;", "\n        if(jiao>=10)", "\n        {", "\n            jiao=jiao-10;", "\n            yuan=yuan+1;", "\n        }", "\n    }", "\n    return RMB(yuan,jiao,fen);", "\n}", "\nRMB RMB::operator -(RMB b)", "\n{", "\n    if(fen\n    {", "\n        if(jiao>0)", "\n        {", "\n            fen=fen+10;", "\n            jiao=jiao-1;", "\n        }", "\n        else", "\n            if(yuan>0)", "\n            {", "\n                yuan=yuan-1;", "\n                jiao=jiao+9;", "\n                fen=fen+10;", "\n            }", "\n    }", "\n     fen=fen-b.fen;", "\n     if(jiao\n        if(yuan>0)", "\n        {", "\n            yuan=yuan-1;", "\n            jiao=jiao+10;", "\n        }", "\n\n", " jiao=jiao-b.jiao;\n yuan=yuan-b.yuan;\n return RMB(yuan,jiao,fen);\n", "\n\n", "}", "\nvoid RMB::display()", "\n{", "\n//  if(yuan>=0)", "\n    cout<<yuan<<\"元\"<<jiao<<\"角\"<<fen<<\"分\"<<endl;", "\n//  else cout<<\"输入有误！\"<<endl;", "\n}", "\nvoid main()", "\n{", "\n    RMB c(1,2,1);RMB d(3,3,3);", "\n    RMB e;RMB f;", "\n    c.display ();", "\n    d.display ();", "\n    e=c+d;", "\n    e.display ();", "\n    f=d-c;", "\n//  RMB c1(1,2,1);RMB d1(5,3,3);", "\n//  f=d1-c1;", "\n    f.display ();", "\n}", "\n如果把f=d-c注释掉，然后后两行不要注释，得出的结果又是对的？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这看你是返回*this&amp;#xff0c;还是重新定义一个新对象&amp;#xff0c;return新对象&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载运算符什么时候用引用返回值的问题", ["这个重载运算符+的位置", "CStr operator+（const CStr &cn） 为什么这里返回值为什么不用&啊", "\n", "\n", "#", "include", " ", "\"CNString.h\"", "\n", "//重载运算符：=", "\nCNString& CNString::", "operator", "=(", "const", " CNString &cn)\n{\n    ", "this", "->m_s = ", "new", " ", "char", "[", "strlen", "(cn.m_s)+", "1", "];\n    ", "strcpy", "(", "this", "->m_s,cn.m_s);\n    ", "return", " *", "this", ";\n}\n", "//重载运算符：+", "\nCNString CNString::", "operator", "+(", "const", " CNString &cn)", "//为什么这里不用&呢", "\n{\n    CNString temp;\n    temp.m_s = ", "new", " ", "char", "[", "strlen", "(", "this", "->m_s)+", "strlen", "(cn.m_s)+", "1", "];\n    ", "strcpy", "(temp.m_s, ", "this", "->m_s);\n    ", "strcat", "(temp.m_s, cn.m_s);\n    ", "return", " temp;\n}\n", "//重载运算符：[]", "\n", "char", " CNString::", "operator", "[](", "int", " index)\n{\n    ", "if", "(index >= ", "strlen", "(", "this", "->m_s))\n    {\n        ", "return", " ", "'\\0'", ";\n    }\n    ", "return", " ", "this", "->m_s[index];\n}\n", "//重载运算符：<", "\n", "bool", " CNString::", "operator", "<(", "const", " CNString &cn)\n{\n    ", "if", "(", "strcmp", "(", "this", "->m_s, cn.m_s) < ", "0", ")\n    {\n        ", "return", " ", "true", ";\n    }\n    ", "return", " ", "false", ";\n}\n", "//重载运算符：>", "\n", "bool", " CNString::", "operator", ">(", "const", " CNString &cn)\n{\n    ", "if", "(", "strcmp", "(", "this", "->m_s, cn.m_s) > ", "0", ")\n    {\n        ", "return", " ", "true", ";\n    }\n    ", "return", " ", "false", ";\n}\n", "//重载运算符：==", "\n", "bool", " CNString::", "operator", "==(", "const", " CNString &cn)\n{\n    ", "if", "(", "strcmp", "(", "this", "->m_s, cn.m_s) == ", "0", ")\n    {\n        ", "return", " ", "true", ";\n    }\n    ", "return", " ", "false", ";\n}\n", "//默认构造函数", "\nCNString::", "CNString", "()\n{\n    ", "this", "->m_s = ", "new", " ", "char", "(", "'\\0'", ");\n}\n", "//构造函数", "\nCNString::", "CNString", "(", "const", " ", "char", " *s) {\n    m_s = ", "new", " ", "char", "[", "strlen", "(s)+", "1", "];\n    ", "strcpy", "(m_s, s);\n}\n", "//拷贝构造函数", "\nCNString::", "CNString", "(", "const", " CNString &c)\n{\n    m_s = ", "new", " ", "char", "[", "strlen", "(c.m_s)+", "1", "];\n    ", "strcpy", "(m_s,c.m_s);\n}\n", "//析构函数", "\nCNString::~", "CNString", "()\n{\n    ", "delete", " m_s;\n    m_s = ", "nullptr", ";\n}\n", "//输出数据", "\n", "void", " ", "CNString::display", "()", "\n", "{\n    std::cout << m_s << std::endl;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载函数需要返回True和False&amp;#xff0c;而不是实际数值&amp;#xff0c;否则if条件一直为True只会执行m1.message()&amp;#xff0c;修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; operator&amp;lt;(Mobile &amp;amp;x1, Mobile &amp;amp;x2)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x1.&lt;span class=\"hljs-built_in\"&gt;number&lt;/span&gt; &amp;lt; x2. &lt;span class=\"hljs-built_in\"&gt;number&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["operator< 小于符号运算符重载问题，输出结果总是反的是什么原因呢？", ["输出结果总是是1234，如果想输出1321    samsung message send，应该怎么改动啊，", "只改动这一部分的代码", "\n", "\nMobile::", "Mobile()", "{}\n\nMobile::", "Mobile(", "char", " ", "*", "t", ",", "int", " ", "c", ", ", "int", " ", "n", ")", ":", "Telephone(", "n", ")", "\n{\n    strcpy(", "type", ",t);\n    cost = c;    \n}\n\n", "int", " operator<(Mobile &x1, Mobile &x2)\n{\n    ", "if", "(x1.number < x2. number) return x2.number;\n    ", "else", " return x1.number;\n}\n", "\n", "源程序如下：", "\n", "\n", "/*程序运行结果为:\n1321    samsung message send*/", "\n\n", "#", "include", "<string.h>", "\n", "//StudybarCommentBegin", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "//#include <iostream.h>", "\n", "class", " ", "Telephone", "\n{\n", "protected", " :\n    ", "int", " number;\n", "public", ":\n    ", "Telephone", "()\n    {number=", "1234", ";}\n    ", "Telephone", "(", "int", " n)\n    {number=n;}\n    ", "void", " ", "showNumber", "()", "\n    ", "{cout<<", "\"my phone number is: \"", "<<number<<endl;}\n    ", "void", " ", "call", "()", "\n    ", "{cout<<", "\"the phone is calling \\n\"", ";}\n};\n", "class", " ", "Mobile", ":", "public", " Telephone\n{\n    ", "char", " *type = ", "new", " ", "char", "[", "20", "];\n    ", "int", " cost;\n", "public", ":\n    ", "Mobile", "();\n    ", "Mobile", "(", "char", " *t,", "int", " c, ", "int", " n);   ", "//n-tel，c-cost，t-type ", "\n    ", "void", " ", "message", "()", "\n    ", "{\n        cout<<number<<", "\"\\t\"", "<<type<<", "\"\\tmessage send\\n \"", ";\n    }\n    ", "friend", " ", "int", " ", "operator", "<(Mobile &x1,Mobile &x2);\n};\n\n", "//StudybarCommentEnd", "\n\n\nMobile::", "Mobile", "(){}\n\nMobile::", "Mobile", "(", "char", " *t,", "int", " c, ", "int", " n):", "Telephone", "(n)\n{\n    ", "strcpy", "(type,t);\n    cost = c;    \n}\n\n", "int", " ", "operator", "<(Mobile &x1, Mobile &x2)\n{\n    ", "if", "(x1.number < x2. number) ", "return", " x2.number;\n    ", "else", " ", "return", " x1.number;\n}\n\n", "//StudybarCommentBegin", "\n", "int", " ", "main", "()", "\n", "{\n    Mobile m1;\n    ", "Mobile ", "m2", "(", "\"samsung\"", ",", "3500", ",", "1321", ")", ";\n    ", "if", "(m1<m2)\n        m1.", "message", "();\n    ", "else", "\n        m2.", "message", "();\n}    \n\n", "//StudybarCommentEnd", "\n"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/gaozhefeng/article/details/17248753", "Konwledge_Point": "运算符重载", "Question": ["关于运算符重载函数 = 的不安全问题", ["如何理解 = 运算符重载函数在类的数据成员中包含只想动态分配的内存的指针成员时系统提供的默认复制运算符重载函数会有指针悬挂的危险"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;返回了局部变量的引用&amp;#xff0c;接收返回值时&amp;#xff0c;局部对象已被销毁&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;operator &amp;#43;&lt;/code&gt; 一般不返回参数的引用&amp;#xff0c;为了防止 &lt;code class=\"language-javascript\"&gt;(a &amp;#43; b) &amp;#61; c&lt;/code&gt; 这种反直觉的赋值&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["运算符重载的链式问题", ["复习运算符重载的时候发现一个小问题：使用成员函数重载时，连加是没有问题的，", "\n", "\n", "\n", "\n", "但是使用全局函数是，就出错了。自己上网搜索也没有找到答案，希望有人解释一下原因。"]], "Tag": "程序设计"}
{"Answer": "# 问题解决的话，请点采纳\r\n```\r\n    Person&amp; operator++(int)\r\n    {\r\n        Person&amp; P1 = *this;\r\n        m_A++;\r\n        return P1;\r\n    }\r\n```", "Konwledge_Point": "运算符重载", "Question": ["自增运算符重载问题？求解", ["#include<iostream>\n\nusing namespace std;\n\nclass Person\n{\n    friend ostream & operator<<(ostream &cout, Person &P);\npublic:\n    Person(int A)\n    {\n        m_A = A;\n    }\n\n//自增运算符重载\n    Person operator++(int)\n    {\n        Person P1 = *this;\n        m_A++;\n        return P1;\n    }\nprivate:\n    int m_A;\n};\n\n//左移运算符重载\nostream & operator<<(ostream &cout, Person &P)\n{\n    cout << P.m_A;\n    return cout;\n}\n\nvoid text()\n{\n    Person P(10);\n    cout << P++ << endl;\n    cout << P << endl;\n\n}\n\nint main()\n{\n    text();\n\n    system(\"pause\");\n    return 0;\n}\n", "\n\n", "为什么 cout << P++ << endl这段代码出错了。"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/u010003835/article/details/47312955", "Konwledge_Point": "运算符重载", "Question": ["各位大侠，运用C++的模板类的模板方法，实现私有的运算符重载怎么实现", ["各位大侠，运用C++的模板类的模板方法，实现私有的运算符重载，在类的内部重载运算符，请教大侠怎么实现？ "]], "Tag": "程序设计"}
{"Answer": "就是说，C++允许在类的定义外面定义运算符重载。你可以重载两个整数的加减。\r\n但是C#不允许，你不能改变现有类型的运算符，只能给你自己定义的类型重载运算符。", "Konwledge_Point": "运算符重载", "Question": ["link中运算符重载必须依附于类型这个怎么理解？什么是运算符重载的类型？", ["link中运算符重载必须依附于类型这个怎么理解？什么是运算符重载的类型？"]], "Tag": "程序设计"}
{"Answer": "你的判断是对的，重载的运算符会调用拷贝构造函数，把结果放在堆栈上，看下面的最简单的程序\r\n\r\n```\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nclass A\r\n{\r\npublic:\r\n\tA() { cout &lt;&lt; \"A()\" &lt;&lt; endl; }\r\n\tA(A&amp; o){ cout &lt;&lt; \"A(A&amp; o)\" &lt;&lt; endl; }\r\n\tA operator+(A&amp; o){ return o; }\r\n};\r\nint main()\r\n{\r\n\tA a, b;\r\n\ta + b;\r\n\treturn 0;\r\n}\r\n```\r\n\r\nA()\r\nA()\r\nA(A&amp; o)\r\nPress any key to continue", "Konwledge_Point": "运算符重载", "Question": ["一个关于c++构造函数和运算符重载的问题", ["代码如下，具体情况是，我定义了一个有形参的构造函数和+号运算符重载，我觉得两个是独立的，但是在调用+号运算符重载时发现同时又调用了这个构造函数，因为我在函数里写了输出语句，所以被调用时我能看到，c++小白想请问各位大神是为什么？是运算符重载函数写的有问题吗？多谢各位~~", "\n//constructeur 2", "\nBigInt::BigInt(int n):numDigits(0)", "\n{", "\n    cout << \"constructeur 2 bien appelé\" << endl;", "\n    int quotient = n;", "\n    int residu;", "\n    cout << \"l'entier que vous donnez est \";", "\n    for(int i=0;i\n    {", "\n        numDigits++;", "\n        residu = quotient%10;", "\n        quotient = quotient/10;     ", "\n        vals[i] = residu;", "\n        if(residu == 0 && quotient == 0)", "\n        {", "\n            break;", "\n        }", "\n        cout \n    }", "\n    cout \n    cout \n}", "\n//surcharge de l'operateur+", "\nBigInt BigInt::operator+(const BigInt& a)", "\n{", "\n    cout \n    int temp[3000];", "\n    int r = 0;", "\n    for(int i=0;i\n    {", "\n        temp[i] = vals[i] + a.vals[i] + r;", "\n        if(temp[i]>9)", "\n        {", "\n            r = 1;", "\n            temp[i] -= 10;", "\n        }", "\n        else{r = 0;}", "\n        cout << temp[i] << \" \";", "\n    }", "\n    cout << endl;", "\n    return temp[numDigits];", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;多态一般只用于对象&amp;#xff0c;函数和运算符只能称为重写或者重载。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["为什么c++的运算符重载函数不具有多态的特性", ["(14条消息) 为什么C++赋值运算符重载函数不能被继承？_Sean.W的专栏-CSDN博客", "\n\n", "按照他上面的说法：", "\n\n", "\n\n", "我写了两个类：", "\n\n", "\n\n", "如图，显式声明了赋值运算符，然后我将基类的赋值运算符设置为virtual状态:", "\n\n", "\n\n", "实现：", "\n\n", "\n\n", "\n\n", "然后我声明了两个对象：", "\n\n", "\n\n", "其中第二个变量的引用类型为Fruit,实际类型为Apple", "\n\n", "然后：", "\n\n", "\n\n", "按照多态的机制，这里应该调用的是Apple::operator=()", "\n\n", "然而：", "\n\n", "\n\n", "很显然与那篇文章的结论不符合", "\n\n", "所以说为什么多态机制会消失？", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你第二个测试用例结果错了&amp;#xff0c;应该不是换行的问题&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++中<<运算符重载问题", ["【问题描述】", "\n", "定义一个时间类CTime，分钟和秒钟是其两个私有成员数据。输入一个起始时间和一个结束时间(起始时间早于结束时间)，通过运算符重载-（减号），计算这两个时间相隔多少秒钟。说明：这两个时间在同一小时之内，且采用60分钟60秒钟的计时分式，即从00:00-59:59。", "\n", "【输入形式】", "\n", "测试输入包含若干测试用例，每个测试用例占一行。每个测试用例包括四个数，每个数之间用空格间隔，每个数都由两位数字组成，第一个数和第二个数分别表示起始时间的分钟和秒钟，第三个数和第四个数分别表示结束时间的分钟和秒钟。当读入一个测试用例是00 00 00 00时输入结束，相应的结果不要输出。", "\n", "【输出形式】", "\n", "对每个测试用例输出一行。输出一个数即可，表示两者之间间隔的秒钟数。", "\n", "【样例输入】", "\n", "12 11 12 58", "\n", "00 13 16 00", "\n", "09 07 23 59", "\n", "00 00 00 00", "\n", "【样例输出】", "\n", "47", "\n", "947", "\n", "892", "\n", "#", "include", "  ", "<iostream>", "\nusing  namespace  std;\n", "#", "define", "  N  100", "\n\n", "class", " ", "CTime", "\n{\nprivate:\n    ", "int", " fen,miao;\npublic:\n    ", "void", " input();\n    ", "bool", " beZero();\n    friend ostream & operator<<(ostream& ", "out", ",", "const", " ", "CTime", "& t);\n    ", "CTime", " operator-(", "CTime", " &b) ", "const", ";\n};\n", "void", " ", "CTime", "::input()\n{\n    ", "while", "(", "1", ")\n    {\n        cin>>fen>>miao;\n        ", "if", "(fen>=", "0", "&&fen<=", "59", "&&miao>=", "0", "&&miao<=", "59", ")\n            ", "break", ";\n        ", "else", "\n            cout<<", "\"error\"", "<<endl;\n    }\n}\n", "bool", " ", "CTime", "::beZero()\n{\n    ", "if", "(fen==", "0", "&&miao==", "0", ")\n    {\n        ", "return", " ", "1", ";\n    }\n    ", "else", "\n        ", "return", " ", "0", ";\n}\nostream & operator<<(ostream& ", "out", ",", "const", " ", "CTime", "& t)\n{\n    ", "out", "<<", "60", "*t.fen+t.miao;\n    ", "return", " ", "out", ";\n}\n", "CTime", " ", "CTime", "::operator-(", "CTime", " &b) ", "const", "\n{\n    ", "CTime", " ", "out", ";\n    ", "if", "(fen>=b.fen)\n        ", "out", ".fen=fen-b.fen;\n    ", "else", "\n        ", "out", ".fen=b.fen-fen;\n    ", "if", "(miao>=b.miao)\n        ", "out", ".miao=miao-b.miao;\n    ", "else", "\n        ", "out", ".miao=b.miao-miao;\n    ", "return", " ", "out", ";\n}\n", "int", "    main()", "//main函数是答题系统已经给定的，无法修改", "\n{\n        ", "CTime", "  time[N];\n        ", "int", "  count=", "-1", ";\n        ", "do", "\n        {\n                count++;\n                time[", "2", "*count].input();\n                time[", "2", "*count+", "1", "].input();\n        }", "while", "(!(time[", "2", "*count].beZero()&&time[", "2", "*count+", "1", "].beZero()));\n        ", "for", "(", "int", "  i=", "0", ";i<count;i++)\n        {\n                cout<<time[", "2", "*i+", "1", "]-time[", "2", "*i]<<endl;\n        }\n        ", "return", "    ", "0", ";\n}\n\n", "\n", "题目要求00 00，00 00那一项不输出，但是总会多出一个换行导致出错", "如图：", "\n", "\n", "有无董哥知道怎么达到预定结果", "PS：main函数是答题系统固定的，无法修改"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Yes, use pointer receiver:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (a *A) AddValue(v A) {\n    a.value1 += v.value1\n    a.value2 += v.value2\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;By using a pointer receiver, the address of a value of type &lt;code&gt;A&lt;/code&gt; will be passed, and therefore if you modify the pointed object, you don't have to return it, you will modify the \"original\" object and not a copy.&lt;/p&gt;\n\n&lt;p&gt;You could also simply name it &lt;code&gt;Add()&lt;/code&gt;. And you could also make its argument a pointer (for consistency):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (a *A) Add(v *A) {\n    a.value1 += v.value1\n    a.value2 += v.value2\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And so using it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;x, y := &amp;amp;A{1, 2}, &amp;amp;A{3, 4}\n\nx.Add(y)\n\nfmt.Println(x)  // Prints &amp;amp;{4 6}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;Note that even though you now have a pointer receiver, you can still call your &lt;code&gt;Add()&lt;/code&gt; method on non-pointer values if they are addressable, so for example the following also works:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;a, b := A{1, 2}, A{3, 4}\na.Add(&amp;amp;b)\nfmt.Println(a)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;a.Add()&lt;/code&gt; is a shorthand for &lt;code&gt;(&amp;amp;a).Add()&lt;/code&gt;. Try these on the &lt;a href=\"https://play.golang.org/p/ZxtuXAQ1Qv\" rel=\"noreferrer\"&gt;Go Playground&lt;/a&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "运算符重载", "Question": ["Golang运算符重载", ["\n\n", "I understand that golang does not provide operator overloading, as it believe that it is increasing the complexity.", "\n\n", "So I want to implement that for structures directly. ", "\n\n", "package main\n\nimport \"fmt\"\n\ntype A struct {\n    value1 int\n    value2 int\n}\n\nfunc (a A) AddValue(v A) A {\n    a.value1 += v.value1\n    a.value2 += v.value2\n    return a\n}\n\n\nfunc main() {\n    x, z := A{1, 2}, A{1, 2}\n    y := A{3, 4}\n\n    x = x.AddValue(y)\n\n    z.value1 += y.value1\n    z.value2 += y.value2\n\n    fmt.Println(x)\n    fmt.Println(z)\n}\n", "\n\n", "https://play.golang.org/p/1U8omyF8-V", "\n\n", "From the above code, the ", "AddValue", " works as I want to. However, my only concern is that it is a pass by value and hence I have to return the newly added value everytime.", "\n\n", "Is there any other better method, in order to avoid returning the summed up variable.", "\n    "]], "Tag": "程序设计"}
{"Answer": "很明显的错误，Complex构造函数只有声明没有定义啊， 其他的没有问题。\r\n完整代码：\r\n\r\n\r\n```\r\n #include \"iostream\"\r\nusing namespace std;\r\n\r\nclass Complex\r\n{\r\nprivate:\r\n\tdouble real;\r\n\tdouble image;\r\n\t\r\npublic:\r\n\tComplex(double r = 0.0, double i = 0.0): real(r), image(i) {}\r\n\tComplex operator + (const Complex &amp;);\r\n\tdouble getComplexReal();\r\n\tdouble getComplexImage();\r\n};\r\n\r\n\r\ndouble Complex::getComplexReal()\r\n{\r\n\treturn real;\r\n}\r\n\r\ndouble Complex::getComplexImage()\r\n{\r\n\treturn image;\r\n}\r\n\r\nComplex Complex::operator+(const Complex &amp; operand2)\r\n{\r\n\treturn Complex(real + operand2.real, image + operand2.image);\r\n}\r\n\r\nint main()\r\n{\r\n\tComplex m(1.0,2.0),n(2.0,3.0),k;\r\n\tk = m + n;\r\n\tcout&lt;&lt;\"K's real is:\"&lt;&lt;k.getComplexReal()&lt;&lt;\". and image is:\"&lt;&lt;k.getComplexImage()&lt;&lt;endl;\r\n}\r\n```", "Konwledge_Point": "运算符重载", "Question": ["C++一个小程序，关于运算符重载，无法运行，不知道哪里出错。", ["我在做一个练习，关于运算符重载的，写了一个重载+ 运算符的小程序，目的是输出K的实部和虚部，但无法运行，求前辈指导！谢谢大家。", "\n代码如下：", "\n\n", "#include \"iostream\"", "\n\n", "using namespace std;", "\n\n", "class Complex", "\n{", "\nprivate:", "\n    double real;", "\n    double image;", "\n\n", "public:", "\n    Complex(double r = 0.0, double i = 0.0);", "\n    Complex operator + (const Complex &);", "\n\n", "double getComplexReal();\ndouble getComplexImage();\n", "\n\n", "};", "\n\n", "double Complex::getComplexReal()", "\n{", "\n    return real;", "\n}", "\n\n", "double Complex::getComplexImage()", "\n{", "\n    return image;", "\n}", "\n\n", "Complex Complex::operator+(const Complex & operand2)", "\n{", "\n    return Complex(real + operand2.real, image + operand2.image);", "\n}", "\n\n", "int main()", "\n{", "\n    Complex m(1.0,2.0),n(2.0,3.0),k;", "\n    k = m + n;", "\n    cout<<\"K's real is:\"<<k.getComplexReal()<<\". and image is:\"<<k.getComplexImage()<<endl;", "\n}"]], "Tag": "程序设计"}
{"Answer": "这个问题提的有问题，上面不是运算符重载，看错了。", "Konwledge_Point": "运算符重载", "Question": ["函数重载和运算符重载的区别", ["之前一直把这两个当成一回事，直到遇到这个", "求解释，为什么函数根据返回值区分会有二义性，而运算符却没有"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;box&lt;/span&gt;\n{\n  &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; num;\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; box &amp;amp;b1) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n  {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; num &amp;#43; b1.num;\n  }\n};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;box&lt;/span&gt; b_one,b_two;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n  b_one.num &amp;#61; &lt;span class=\"hljs-number\"&gt;2000&lt;/span&gt;;\n  b_two.num &amp;#61; &lt;span class=\"hljs-number\"&gt;2000&lt;/span&gt;;\n  cout &amp;lt;&amp;lt; b_one &amp;#43; b_two;\n  &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载报错，如何解决？", ["\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "box", "\n{\n  ", "long", " num;\n  ", "int", " ", "operator", "+(", "const", " box &b1,", "const", " box &b2) ", "const", "\n  {\n    ", "return", " b1.num + b2.num;\n}\nbox b_one,b_two;\n", "int", " ", "main", "()", "\n", "{\n  b_one.num = ", "2000", ";\n  b_two.num = ", "2000", ";\n  cout << b_one + b_two;\n  ", "return", " ", "0", ";\n", "\n", "操作系统：Windows 10", "初步解决方法：删除", "const", "，方法没有效果"]], "Tag": "程序设计"}
{"Answer": "第一个重载是重载了赋值运算操作符，返回类型加了&amp;代表引用，这样的话返回值又可以作为左值，从而实现连续赋值，形如a = b = c;\r\n如果没有加&amp;，则只能作为右值，右值是不能对其进行赋值的，因此无法进行连续赋值", "Konwledge_Point": "运算符重载", "Question": ["c++  运算符重载问题求大神", ["这里重载运算符了三个", "\nclass point", "\n{", "\nprivate:", "\n                int x,int y;", "\npublic:", "\n                point &operator =(point &p);     //这里有问题", "\n                point operator +(point &p);", "\n                point operator +=(point &P);", "\n｝", "\n第一个重载为什么有&，具体是为什么，什么意思"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;No, operator overloading is not a feature of Go.&lt;/p&gt;\n\n&lt;p&gt;Quoting from the &lt;a href=\"https://golang.org/doc/faq#overloading\" rel=\"nofollow\"&gt;official FAQ&lt;/a&gt; to explain &lt;em&gt;why&lt;/em&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Method dispatch is simplified if it doesn't need to do type matching as well. Experience with other languages told us that having a variety of methods with the same name but different signatures was occasionally useful but that it could also be confusing and fragile in practice. Matching only by name and requiring consistency in the types was a major simplifying decision in Go's type system.&lt;/p&gt;\n  \n  &lt;p&gt;Regarding operator overloading, it seems more a convenience than an absolute requirement. Again, things are simpler without it.&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "运算符重载", "Question": ["Go是否支持内置类型（例如map和slice）的运算符重载？", ["\n\n", "In python, I can define types that override list item access and dict value access by defining ", "__getitem__()", ". Can I do something similar in Go?", "\n\n", "// What I mean is:\ntype MySlice []MyItem\n// Definition of MySlice\n......\nfunc (s MySlice) getItem(i int) MyItem {\n}\n......\n// Access is overrided with calling getItem()\nitem := ms[0] //calling ms.getItem(0)\n// Is this doable?\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "```\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nclass STR\r\n{\r\nprivate:\r\n    char s[50];\r\npublic:\r\n    STR(char p[50]) { strcpy(s, p); }\r\n    void print() { cout &lt;&lt; s &lt;&lt; endl; }\r\n    friend STR&amp; operator+=(STR&amp; str1, STR str2);\r\n};\r\nSTR&amp; operator+=(STR&amp; str1, STR str2)\r\n{\r\n    return(STR(strcat(str1.s, str2.s)));\r\n}\r\nint main() \r\n{\r\n    STR s1(\"Hello \"), s2(\"World!\");\r\n    s1 += s2;\r\n    s1.print();\r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n```\r\n或者\r\n\r\n```\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nclass STR\r\n{\r\nprivate:\r\n    char* s;\r\npublic:\r\n    STR(char * p) { s = new char[50]; strcpy(s, p); }\r\n\tSTR(STR&amp; s2) { s = s2.s; }\r\n    void print() { cout &lt;&lt; s &lt;&lt; endl; }\r\n    friend STR&amp; operator+=(STR str1, STR str2);\r\n};\r\nSTR&amp; operator+=(STR str1, STR str2)\r\n{\r\n    return(STR(strcat(str1.s, str2.s)));\r\n}\r\nint main() \r\n{\r\n    STR s1(\"Hello \"), s2(\"World!\");\r\n    s1 += s2;\r\n    s1.print();\r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n```\r\n又或者\r\n\r\n```\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nclass STR\r\n{\r\nprivate:\r\n    char s[50];\r\npublic:\r\n    STR(char p[50]) { strcpy(s, p); }\r\n    void print() { cout &lt;&lt; s &lt;&lt; endl; }\r\n    friend STR&amp; operator+=(STR str1, STR str2);\r\n};\r\nSTR&amp; operator+=(STR str1, STR str2)\r\n{\r\n    return(STR(strcat(str1.s, str2.s)));\r\n}\r\nint main() \r\n{\r\n    STR s1(\"Hello \"), s2(\"World!\");\r\n    s1 = s1 += s2;\r\n    s1.print();\r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n```\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\nclass STR\r\n{\r\nprivate:\r\n    char s[50];\r\npublic:\r\n    STR(char p[50]) { strcpy(s, p); }\r\n    void print() { cout &lt;&lt; s &lt;&lt; endl; }\r\n    STR&amp; operator+=(STR str2)\r\n\t{\r\n\t\treturn(STR(strcat(s, str2.s)));\r\n\t}\r\n};\r\n\r\nint main() \r\n{\r\n    STR s1(\"Hello \"), s2(\"World!\");\r\n    s1 += s2;\r\n    s1.print();\r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n```\r\n\r\n办法很多很多的", "Konwledge_Point": "运算符重载", "Question": ["C++关于运算符重载的问题", ["刚做了一道C++编程题，题目是定义一个字符串类STR，实现字符串的拼接，我的代码如下，但是输出没有达到目的，哪位大神可以解释一下原因？", "\n\n", "#include <iostream>\nusing namespace std;\nclass STR\n{\nprivate:\n    char s[50];\npublic:\n    STR(char p[50]) { strcpy(s, p); }\n    void print() { cout << s << endl; }\n    friend STR& operator+=(STR str1, STR str2);\n};\nSTR& operator+=(STR str1, STR str2)\n{\n    return(STR(strcat(str1.s, str2.s)));\n}\nint main() \n{\n    STR s1(\"Hello \"), s2(\"World!\");\n    s1 += s2;\n    s1.print();\n    system(\"pause\");\n    return 0;\n}\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/yuanlulu/article/details/4853030'&gt;c++中运算符重载遇到的问题&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/liuwei271551048/article/details/24195161'&gt;c++运算符重载和友元函数&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/u013089125/article/details/22471461'&gt;C++友元函数以及运算符重载&lt;/a&gt;&lt;br/&gt;----------------------biu~biu~biu~~~在下问答机器人小D，这是我依靠自己的聪明才智给出的答案，如果不正确，你来咬我啊！", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载问题,友元函数", ["#include", "\n#include", "\nusing namespace std;", "\n\n", "class Complex", "\n{", "\n\n", "public:\n    Complex(double newx=0.0, double newy=0.0 );\n    //Complex();\n    Complex(Complex &c);\n    double getx() const;\n    double gety() const;\n    Complex Add(const Complex &another);\n    void Output();\n    friend istream & operator>>(istream &in, const Complex &c);\n    friend ostream & operator<<(ostream &out, const Complex &c);\n\n    Complex operator+(const Complex &c2)const;\n\n\n\n    ~Complex(){};\nprivate:\n    double x,y;\n", "\n\n", "};", "\n\n", "Complex::Complex(double newx, double newy)", "\n{", "\n    x=newx;", "\n    y=newy;", "\n}", "\n/*Complex::Complex()", "\n{", "\n    x=0;", "\n    y=0;", "\n}", "\n*/", "\nComplex::Complex(Complex &c)", "\n{", "\n    x=c.x;", "\n    y=c.y;", "\n}", "\ndouble Complex::getx()const", "\n{", "\n    return x;", "\n}", "\ndouble Complex::gety()const", "\n{", "\n    return y;", "\n}", "\nComplex Complex::Add(const Complex &another)", "\n{", "\n    Complex r;", "\n    r.x=x+another.getx();", "\n    r.y=y+another.gety();", "\n    return r;", "\n}", "\nvoid Complex::Output()", "\n{", "\n    cout<\n    if(y>=0)", "\n        cout<<\"+\";", "\n    cout<<y<<\"i\"<<endl;", "\n}", "\n\n", "Complex Complex::operator+(const Complex &c2)const", "\n{", "\n    return Complex(x+c2.x,y+c2.y);", "\n}", "\n\n", "istream & operator>>(istream &in, const Complex &c)", "\n{", "\n//  in>>\"(\">>c.x>>\",\"<\n    in>>c.x;", "\n    in>>c.y;", "\n    return in;", "\n}", "\n\n", "ostream & operator<<(ostream &out, const Complex &c)", "\n{", "\n    out<<\"(\"<<c.x<<\",\"<<c.y<<\")\";", "\n    return out;", "\n}", "\n\n", "int main(int argc,char&agrv[])", "\n{", "\n\n", "Complex z1(3,5),z2(4.5,2.3),z3(2,3);\nComplex z4;\nComplex z5(z1);\nz5.Output();\ncin>>z1;\ncin>>z2;\nz4=z1.Add(z2);\nz4.Output();\nz3 = z1+z2;\nz3.Output();\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "改后代码如下\r\n\r\n```\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nclass Complex                         \r\n{\r\nprivate:\r\n    double real,imag;               \r\npublic: \r\n    Complex() = default;\r\n    Complex(double r,double i):real(r),imag(i){}       \r\n    void display(const string &amp;name)\r\n    {cout &lt;&lt; name &lt;&lt; real &lt;&lt; \",\" &lt;&lt; imag &lt;&lt; \"i\" &lt;&lt; endl;}\r\n    Complex&amp; operator+=(const Complex &amp;c2);\r\n};\r\n\r\nComplex&amp; Complex::operator+=(const Complex &amp;c2)\r\n{\r\n    real += c2.real;\r\n    imag += c2.imag;\r\n    return *this;\r\n}\r\n\r\nComplex operator+(const Complex &amp;c1, const Complex&amp; c2)     \r\n{\r\n    Complex c = c1;\r\n    c += c2;\r\n    return c;\r\n}\r\n\r\nint main()\r\n{\r\n    Complex c1(1,1),c2(2,2),c3;\r\n    // c3 = c1 + c2;                         \r\n    // c3 = c3 + c1;             //为何这两行不能写成c3=c1+c2+c1？\r\n    c3 = c1 + c2 + c1;\r\n    c3.display(\"c3 = \");   \r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n附上一段《C++ Primer》的一个准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出却则：\r\n\r\n* 赋值（=），下标（[]），调用（()）和成员访问箭头（-&gt;）运算符必须是成员、\r\n* 符合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。\r\n* 改变对象状态的运算符符或者与给定类型密切相关的运算符，如递增，递减和解引用运算符，通常应该是成员。\r\n* 具有对称性的运算符可能转换任意一端的运算对象，例如算术，相等性，关系和位运算符等，因此他们通常应该是普通的非成员函数。\r\n\r\n\r\n题外话：\r\n\r\n一个留待你自己去解决的问题：为什么调用operator+=来定义operator+比其他方法更有效？", "Konwledge_Point": "运算符重载", "Question": ["c++中重载问题，为何\"+\"不能连续用？", ["随便一个简单代码:", "\n\n", " #include <iostream>\n#include <string>\nusing namespace std;\nclass Complex                         \n{\n    double real,imag;               \npublic: \n    Complex(double r,double i):real(r),imag(i){}       \n    void display(const string &name)\n    {cout << name << real << \",\" << imag << \"i\" << endl;}\n    friend Complex& operator+(Complex &c1,Complex &c2);\n};\nComplex& operator+(Complex &c1,Complex &c2)     \n{\n    Complex c;\n    c.real = c1.real + c2.real;\n    c.imag = c1.imag + c2.imag;\n    return c;\n}\nint main()\n{\n    Complex c1(1,1),c2(2,2),c3;\n    c3 = c1 + c2;                         \n    c3 = c3 + c1;             //为何这两行不能写成c3=c1+c2+c1？\n    c3.display(\"c3 = \");\n    system(\"pause\");   return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include &lt;iostream&gt;\r\nusing namespace std;\r\nclass Array\r\n{\r\nprivate:\r\n\tint a[6];\r\npublic:\r\n\tArray()\r\n\t{\r\n\t\tfor(int i=0;i&lt;=5;i++)\r\n\t\t\ta[i]=0;\r\n\t}\r\n\tArray(int *p);\r\n\tArray operator+(Array &amp;c1);\r\n\tvoid display(){\r\n\t\tfor(int i=0;i&lt;=5;i++)\r\n\t\t\tcout&lt;&lt;a[i]&lt;&lt;\" \";\r\n\t\tcout &lt;&lt; endl;\r\n\t}\r\n};\r\nArray::Array(int *p){\r\n\tfor(int i=0;i&lt;=5;i++)\r\n\t\ta[i]=*(p+i);\r\n}\r\nArray Array::operator+(Array &amp; array2){\r\n\tArray c;\r\n\tfor(int i=0;i&lt;=5;i++)\r\n\t\tc.a[i]=a[i]+array2.a[i];\r\n\treturn c;\r\n}\r\nint main()\r\n{\r\n\tint x[6]={1,3,5,7,9,11} ; int y [6]={2,4,6,8,10,12};\r\n\tArray array1(x),array2(y),array3;\r\n\tarray3=array1+array2;\r\n\tcout &lt;&lt; \"想加前:\" &lt;&lt; endl;\r\n\tarray1.display();\r\n\tarray2.display();\r\n\tcout &lt;&lt; \"想加后:\" &lt;&lt; endl;\r\n\tarray3.display();\r\n\treturn 0;\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201604/24/1461476775_234344.png)", "Konwledge_Point": "运算符重载", "Question": ["用运算符重载进行一维数组相加的程序", ["用运算符重载进行一维数组相加的程序", "\n写出函数体就行了用运算符重载进行一维数组相加的程序"]], "Tag": "程序设计"}
{"Answer": "https://tieba.baidu.com/p/6265998042?red_tag=3512005220", "Konwledge_Point": "运算符重载", "Question": ["为什么重载后置递增运算符用左移运算符重载输出时左移运算符重载函数形参不能用引用？", ["#include <iostream>\n#include <string>\nusing namespace std;\nclass person\n{\n    friend ostream& operator<<(ostream &cout,person p);\n    private:\n    int m_a;\n    int m_b;\n    public:\n    person(int a,int b)\n    {\n        m_a=a;\n        m_b=b;\n    }\n    //重载后置++运算符\n        person operator++(int)  \n    {\n        person temp=*this;\n        m_a++;\n        m_b++;\n        return temp;\n    }\n};\n//全局函数重载左移运算符\nostream& operator<<(ostream &out,person p)    //???不能用引用&p\n{\n    out<<\"m_a=\"<<p.m_a<<\"   m_b=\"<<p.m_b;\n    return out; \n}\n\nvoid test()\n{\n    person pp(0,0);\n    cout<<pp<<endl;\n    cout<<pp++<<endl;\n}\n\nint main()\n{\n    test();\n    system (\"pause\");\n    return 0;\n}\n", "\n\n", "如果在全局函数重载那儿加了引用，即：", "\n\n", "friend ostream& operator<<(ostream &cout,person &p);\n", "\n\n", "和", "\n\n", "ostream& operator<<(ostream &out,person &p)   \n", "\n\n", "会报错，如下：", "\n{", "\n\n", "\"owner\": \"C/C++\",\n\"severity\": 8,\n\"message\": \"没有与这些操作数匹配的 \\\"<<\\\" 运算符 -- 操作数类型为:  std::ostream << person\",\n\"startLineNumber\": 36,\n\"startColumn\": 9,\n\"endLineNumber\": 36,\n\"endColumn\": 9\n", "\n\n", "}", "\n但是不加引用可以正常运行。为什么？？？？"]], "Tag": "程序设计"}
{"Answer": "两个const参数中的那个说明参数本身是常量，不能修改。后面那个表示，这个函数不会修改任何对象实例中的成员。", "Konwledge_Point": "运算符重载", "Question": ["关于c运算符重载的问题", ["最近看到一段代码", "\nbool operator < (const xx&x) const{...}", "\n这是将运算符重载， ", "\n请问参数表列后加了一个const是什么意思？        "]], "Tag": "程序设计"}
{"Answer": "https://zhidao.baidu.com/question/559857700.html", "Konwledge_Point": "运算符重载", "Question": ["一个有难度的问题，怎么使用运算符重载<<实现显示输出一个复数？", ["一个有难度的问题，怎么使用运算符重载<<实现显示输出一个复数？怎么用到虚函数实现运算符重载？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对于main函数第二句cout&amp;lt;&amp;lt;string1&amp;#43;&amp;#34;ab&amp;#34;&amp;#xff0c;先执行&amp;#43;重载返回临时对象&amp;#xff0c;然后编译器试图匹配&amp;lt;&amp;lt;运算符的重载。因为自动生成的临时对象都是const的&amp;#xff0c;而const对象是无法转换成非const对象。所以与&amp;lt;&amp;lt;重载函数第二参数不能匹配&amp;#xff0c;因而编译器尝试进行类型转换。&lt;br /&gt;编译器匹配次序是先找能运算符重载函数&amp;#xff0c;如果不能匹配&amp;#xff0c;才尝试类型转换函数。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载输出运算符时的怪问题", ["代码如下：", "#include", "#include", "using namespace std;", "class String{", "     char* array;", "public:", "    String(const char* p){", "        array=new char[strlen(p)+1];", "        strcpy(array,p);", "    }", "    ~String(){    delete[] array;    }", "    String operator+(const char* b)    {", "        char* p=new char[strlen(array)+strlen(b)+1];", "        strcpy(p,array);", "        strcat(p,b);", "        return String(p);", "    }", "    operator int(){", "        return strlen(array);", "    }", "    friend ostream& operator<<(ostream& output,  String& a)", "    {", "        output<<a.array;", "        return output;", "    }", "};", "int main()", "{", "    String string1(\"mystring\");", "    cout<<string1+\"ab\"<<endl;", "    cout<<string1<<endl;", "    cout<<string1+3<<endl;", "    cout<<string1<<endl;", "    return 0;", " }", "运行结果为：", "10", "mystring", "11", "mystring", "问题：重载执行了string1+\"ab\"，返回临时对象，用cout输出时竟然又将临时对象转为int，而没有调用<<重载。但如果<<重载第二参数前加const，则输出为：", "mystringab", "mystring", "11", "mystring", "谁能解释一下？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在有必须析构的类中&amp;#xff0c;没有拷贝构造和拷贝赋值&amp;#xff0c;会引发浅拷贝&amp;#xff0c;str两次delete不崩也难。&lt;br /&gt;同时&amp;#xff0c;也没听说过返回值的赋值重载operator&amp;#61;&amp;#xff0c;返回引用不会进行自身拷贝&amp;#xff0c;而返回值则需要再次拷贝&amp;#xff0c;然后再拷贝赋值&amp;#xff0c;析构....由于又是浅拷贝所以.....多次delete....爆机。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;MyString&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;MyString&lt;/span&gt;()\n        : &lt;span class=\"hljs-built_in\"&gt;str&lt;/span&gt;(&lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;) {} &lt;span class=\"hljs-comment\"&gt;// NULL  0&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;MyString&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; MyString &amp;amp;rhs)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (rhs.str)\n        {\n            str &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(rhs.str) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n            &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(str, rhs.str);\n        }\n    }\n    MyString &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; MyString &amp;amp;rhs)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str !&amp;#61; rhs.str)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] str;\n                str &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (rhs.str)\n            {\n                str &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(rhs.str) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(str, rhs.str);\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    MyString &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *rhs);\n    ~&lt;span class=\"hljs-built_in\"&gt;MyString&lt;/span&gt;() { &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] str; }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;MyString::print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;;\n}\n\nMyString &amp;amp;MyString::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *rhs)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str !&amp;#61; rhs)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] str;\n            str &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (rhs)\n        {\n            str &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(rhs) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n            &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(str, rhs);\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    MyString s, t;\n    t &amp;#61; s &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;world&amp;#34;&lt;/span&gt;;\n    s.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n    t.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//两个输出是随机数&amp;#xff0c;并且爆机&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++里的运算符重载的区分", ["\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cstring>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "MyString", "\n{ ", "public", ":\n    ", "MyString", "(){str=", "NULL", ";}  ", "//NULL  0", "\n    ", "void", " ", "print", "()", "; \n    ~", "MyString", "(){", "delete", " []str;    }\n    MyString  ", "operator", " =(", "const", " ", "char", " *);\n  ", "private", ":\n    ", "char", " *str;    \n};\n", "void", " ", "MyString::print", "()", "\n", "{cout<<str;\n} \nMyString  MyString::", "operator", " =(", "const", " ", "char", " *r)  \n{   ", "if", " (str)  ", "delete", " []str;\n    ", "if", " (r) {str=", "new", " ", "char", "[", "strlen", "(r)+", "1", "];", "strcpy", "(str,r);}   ", "else", "  str=", "NULL", ";\n    ", "return", " *", "this", ";  \n} \n", "int", " ", "main", "()", " \n", "{   MyString s,t;\n    t=s=", "\"world\"", ";\n    s.", "print", "(); \n    t.", "print", "();\n    ", "return", " ", "0", ";\n} \n", "//两个输出是随机数，并且爆机", "\n", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cstring>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "MyString", "\n{ ", "public", ":\n    ", "MyString", "(){str=", "NULL", ";}  ", "//NULL  0", "\n    ", "void", " ", "print", "()", "; \n    ~", "MyString", "(){", "delete", " []str;    }\n    MyString & ", "operator", " =(", "const", " ", "char", " *);\n  ", "private", ":\n    ", "char", " *str;    \n};\n", "void", " ", "MyString::print", "()", "\n", "{cout<<str;\n} \nMyString & MyString::", "operator", " =(", "const", " ", "char", " *r)\n{   ", "if", " (str)  ", "delete", " []str;\n    ", "if", " (r) {str=", "new", " ", "char", "[", "strlen", "(r)+", "1", "];", "strcpy", "(str,r);}  ", "else", "  str=", "NULL", ";\n    ", "return", " *", "this", ";  \n} \n", "int", " ", "main", "()", " \n", "{   MyString s,t;\n    t=s=", "\"world\"", "; \n    s.", "print", "();\n    t.", "print", "();\n    ", "return", " ", "0", ";\n} \n\n", "//两个输出是正确的，但是爆机", "\n", "\n", "为什么运算符重载函数加和不加&的区别会这样"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;c&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++运算符重载这个怎么分析", ["C++运算符重载这个怎么分析，我该怎么理解运算符重载，求指导"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;题主要的代码如下&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/904183516146170.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; System;\n&lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ConsoleApp2&lt;/span&gt;\n{&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; 复数类&lt;/span&gt;\n &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ComplexNumber&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-comment\"&gt;//实部&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; _RealPart;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; RealPart\n        {\n            &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt; { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _RealPart; }\n            &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt; { _RealPart &amp;#61; &lt;span class=\"hljs-keyword\"&gt;value&lt;/span&gt;; }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//虚部&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; _ImaginaryPart;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; ImaginaryPart\n        {\n            &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt; { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _ImaginaryPart; }\n            &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt; { _ImaginaryPart &amp;#61; &lt;span class=\"hljs-keyword\"&gt;value&lt;/span&gt;; }\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; 创建一个复数类实例&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;param name&amp;#61;&amp;#34;rp&amp;#34;&amp;gt;&lt;/span&gt;实部&lt;span class=\"hljs-doctag\"&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;param name&amp;#61;&amp;#34;ip&amp;#34;&amp;gt;&lt;/span&gt;虚部&lt;span class=\"hljs-doctag\"&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ComplexNumber&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; rp, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; ip&lt;/span&gt;)&lt;/span&gt;\n        {\n            RealPart &amp;#61; rp;\n            ImaginaryPart &amp;#61; ip;\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; 返回一个复数的共轭复数&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;param name&amp;#61;&amp;#34;cn&amp;#34;&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-doctag\"&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-doctag\"&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-title\"&gt;ConjugateOf&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ComplexNumber cn&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart, -cn.ImaginaryPart);\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; 以字符串形式输出复数&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;&lt;span class=\"hljs-doctag\"&gt;///&lt;/span&gt; &lt;span class=\"hljs-doctag\"&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-doctag\"&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;override&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;ToString&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-comment\"&gt;//输出&amp;#xff1a;实部 &amp;#43;/- 虚部 i 虚部前的加减号取决于虚部的正负&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt;.Format(&lt;span class=\"hljs-string\"&gt;&amp;#34; {0} {1} {2} i &amp;#34;&lt;/span&gt;,\n                RealPart.ToString(&lt;span class=\"hljs-string\"&gt;&amp;#34;#0.00&amp;#34;&lt;/span&gt;),\n                ImaginaryPart &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt; : &lt;span class=\"hljs-string\"&gt;&amp;#34;-&amp;#34;&lt;/span&gt;,\n                Math.Abs(ImaginaryPart).ToString(&lt;span class=\"hljs-string\"&gt;&amp;#34;#0.00&amp;#34;&lt;/span&gt;));\n        }\n\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;region&lt;/span&gt; 重载一元运算符&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;//取正、取负&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn; }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -(ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(-cn.RealPart, -cn.ImaginaryPart); }\n\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;endregion&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;region&lt;/span&gt; 重载二元运算符&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;//加法 (a&amp;#43;bi)&amp;#43;(c&amp;#43;di)&amp;#61;(a&amp;#43;c)&amp;#43;(b&amp;#43;d)i&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num, ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart &amp;#43; num, cn.ImaginaryPart); }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(ComplexNumber cn, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart &amp;#43; num, cn.ImaginaryPart); }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(ComplexNumber cn1, ComplexNumber cn2)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(\n                cn1.RealPart &amp;#43; cn2.RealPart,\n                cn1.ImaginaryPart &amp;#43; cn2.ImaginaryPart);\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//减法 (a-bi)&amp;#43;(c-di)&amp;#61;(a-c)&amp;#43;(b-d)i&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num, ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart - num, cn.ImaginaryPart); }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -(ComplexNumber cn, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart - num, cn.ImaginaryPart); }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -(ComplexNumber cn1, ComplexNumber cn2)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(\n                cn1.RealPart - cn2.RealPart,\n                cn1.ImaginaryPart - cn2.ImaginaryPart);\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//乘法 (a&amp;#43;bi)*(c&amp;#43;di)&amp;#61;(ac-bd)&amp;#43;(ad&amp;#43;bc)i&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num, ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart * num, cn.ImaginaryPart * num); }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *(ComplexNumber cn, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart * num, cn.ImaginaryPart * num); }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *(ComplexNumber cn1, ComplexNumber cn2)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(\n                cn1.RealPart * cn2.RealPart - cn1.ImaginaryPart * cn2.ImaginaryPart,\n                cn1.RealPart * cn2.ImaginaryPart &amp;#43; cn1.ImaginaryPart * cn2.RealPart);\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//除法&amp;#xff1a;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//实数除以复数&amp;#xff1a;n/(c&amp;#43;di)&amp;#61;n*(c-di)/(c*c&amp;#43;d*d)&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; /(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num, ComplexNumber cn)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; num * &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart, -cn.ImaginaryPart) /\n                (cn.RealPart * cn.RealPart &amp;#43; cn.ImaginaryPart * cn.ImaginaryPart);\n        }\n        &lt;span class=\"hljs-comment\"&gt;//复数除以实数&amp;#xff1a;(a&amp;#43;bi)/n&amp;#61;a/n&amp;#43;b/n*i&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; /(ComplexNumber cn, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; num)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(cn.RealPart / num, cn.ImaginaryPart / num);\n        }\n        &lt;span class=\"hljs-comment\"&gt;//复数除以复数&amp;#xff1a;(a&amp;#43;bi)/(c&amp;#43;di)&amp;#61;((ac&amp;#43;bd)&amp;#43;(ad&amp;#43;bc)i)/(c*c&amp;#43;d*d)&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; ComplexNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; /(ComplexNumber cn1, ComplexNumber cn2)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; a &amp;#61; cn1.RealPart, b &amp;#61; cn1.ImaginaryPart;\n            &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; c &amp;#61; cn2.RealPart, d &amp;#61; cn2.ImaginaryPart;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(a * c &amp;#43; b * d, a * d &amp;#43; b * c) / (c * c &amp;#43; d * d);\n        }\n\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;endregion&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;region&lt;/span&gt; 重载关系运算符&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;//等于&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61;(ComplexNumber cn1, ComplexNumber cn2)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn1.RealPart &amp;#61;&amp;#61; cn2.RealPart &amp;amp;&amp;amp;\n                cn1.ImaginaryPart &amp;#61;&amp;#61; cn2.ImaginaryPart\n                ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61;(ComplexNumber cn, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; n)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart &amp;#61;&amp;#61; n &amp;amp;&amp;amp; cn.ImaginaryPart &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;; }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61;(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; n, ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart &amp;#61;&amp;#61; n &amp;amp;&amp;amp; cn.ImaginaryPart &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;; }\n\n        &lt;span class=\"hljs-comment\"&gt;//不等于&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; !&amp;#61;(ComplexNumber cn1, ComplexNumber cn2)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn1.RealPart !&amp;#61; cn2.RealPart ||\n                cn1.ImaginaryPart !&amp;#61; cn2.ImaginaryPart\n                ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; !&amp;#61;(ComplexNumber cn, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; n)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart !&amp;#61; n || cn.ImaginaryPart !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;; }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; !&amp;#61;(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; n, ComplexNumber cn)\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart !&amp;#61; n || cn.ImaginaryPart !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;; }\n\n        &lt;span class=\"hljs-comment\"&gt;//重载&amp;#61;&amp;#61;和!&amp;#61;运算符后应该重写Equal是和GetHashCode函数&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//重写Equals函数&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;override&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Equals&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;object&lt;/span&gt; obj&lt;/span&gt;)&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!(obj &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; ComplexNumber)) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                ComplexNumber cn &amp;#61; (ComplexNumber)obj;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.RealPart !&amp;#61; cn.RealPart) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.ImaginaryPart !&amp;#61; cn.ImaginaryPart) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n            }\n        }\n        &lt;span class=\"hljs-comment\"&gt;//重写GetHashCode函数&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;override&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;GetHashCode&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;.GetHashCode(); }\n\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;endregion&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;region&lt;/span&gt; 重载true和false&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;//实部和虚部至少有一个不为0时&amp;#xff0c;为true&amp;#xff0c;否则为false&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;true&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ComplexNumber cn&lt;/span&gt;)&lt;/span&gt;\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || cn.ImaginaryPart !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;; }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;false&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ComplexNumber cn&lt;/span&gt;)&lt;/span&gt;\n        { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; cn.ImaginaryPart &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; : &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;; }\n\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;endregion&lt;/span&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;region&lt;/span&gt; 转换运算符&lt;/span&gt;\n\n        &lt;span class=\"hljs-comment\"&gt;//只能显示转换&amp;#xff0c;强制转换时舍弃虚部&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;explicit&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ComplexNumber cn&lt;/span&gt;)&lt;/span&gt; { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;)cn.RealPart; }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;explicit&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;long&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ComplexNumber cn&lt;/span&gt;)&lt;/span&gt; { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;long&lt;/span&gt;)cn.RealPart; }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;explicit&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;double&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ComplexNumber cn&lt;/span&gt;)&lt;/span&gt; { &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cn.RealPart; }\n\n        &lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;endregion&lt;/span&gt;&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Program&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;\n        {\n            ComplexNumber cn &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n\n            &lt;span class=\"hljs-comment\"&gt;//两个复数&lt;/span&gt;\n            ComplexNumber cn1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            ComplexNumber cn2 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; ComplexNumber(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n\n            &lt;span class=\"hljs-comment\"&gt;//打印复数&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1: &amp;#34;&lt;/span&gt; &amp;#43; cn1);\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn2: &amp;#34;&lt;/span&gt; &amp;#43; cn2);\n\n            &lt;span class=\"hljs-comment\"&gt;//求复数的共轭复数&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;Conjugate of cn1: &amp;#34;&lt;/span&gt; &amp;#43; ComplexNumber.ConjugateOf(cn1));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;Conjugate of cn2: &amp;#34;&lt;/span&gt; &amp;#43; ComplexNumber.ConjugateOf(cn2));\n\n            &lt;span class=\"hljs-comment\"&gt;//复数取正负&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;cn1: &amp;#34;&lt;/span&gt; &amp;#43; (&amp;#43;cn1));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;-cn1: &amp;#34;&lt;/span&gt; &amp;#43; (-cn1));\n\n            &lt;span class=\"hljs-comment\"&gt;//复数加法&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1&amp;#43;cn2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 &amp;#43; cn2));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1&amp;#43;1.2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 &amp;#43; &lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt;));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.2&amp;#43;cn1: &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt; &amp;#43; cn1));\n\n            &lt;span class=\"hljs-comment\"&gt;//复数减法&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1-cn2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 - cn2));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1-1.2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 - &lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt;));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.2-cn1: &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt; - cn1));\n\n            &lt;span class=\"hljs-comment\"&gt;//复数乘法&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1*cn2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 * cn2));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1*1.2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 * &lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt;));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.2*cn1: &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt; * cn1));\n\n            &lt;span class=\"hljs-comment\"&gt;//复数除法&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1/cn2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 / cn2));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1/1.2: &amp;#34;&lt;/span&gt; &amp;#43; (cn1 / &lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt;));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;1.2/cn1: &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt; / cn1));\n\n            &lt;span class=\"hljs-comment\"&gt;//检验是否相等&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (cn1 &amp;#61;&amp;#61; cn2) { Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1&amp;#61;&amp;#61;cn2&amp;#34;&lt;/span&gt;); }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (cn1 !&amp;#61; cn2) { Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1!&amp;#61;cn2&amp;#34;&lt;/span&gt;); }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (cn1 &amp;#43; cn2 &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) { Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1&amp;#43;cn2&amp;#61;&amp;#61;2&amp;#34;&lt;/span&gt;); }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (cn1 &amp;#43; cn2 !&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) { Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;cn1&amp;#43;cn2!&amp;#61;2&amp;#34;&lt;/span&gt;); }\n\n            &lt;span class=\"hljs-comment\"&gt;//显式类型转换&lt;/span&gt;\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;(int)(cn1&amp;#43;cn2): &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;)(cn1 &amp;#43; cn2));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;(long)(cn1&amp;#43;cn2): &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-built_in\"&gt;long&lt;/span&gt;)(cn1 &amp;#43; cn2));\n            Console.WriteLine(&lt;span class=\"hljs-string\"&gt;&amp;#34;(double)(cn1&amp;#43;cn2): &amp;#34;&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;)(cn1 &amp;#43; cn2));\n\n            Console.ReadLine();\n        }\n    }\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/557568322046194.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;有其他问题可以继续交流~&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C#  用运算符重载创建定义复数相加、相减、相乘和相除的复数类Complex", ["如何设计一个程序，使用运算符重载创建定义复数相加、相减、相乘和相除的复数类Complex，并根据用户输入实现复数类的加减乘除运算？"]], "Tag": "程序设计"}
{"Answer": "stu0101  stu0102 存在堆区，这两个变量的地址相差不大。\r\nstu0103  stu0104 存在栈区，这两个变量的地址相差不大。\r\n像这种临时的即将销毁的变量，属于右值变量，可以在函数中进行对这个变量进行取地址，或者说是通过const来延长生命周期\r\n然后获取地址。\r\n\r\n你这里加号并没有进行拷贝构造。", "Konwledge_Point": "运算符重载", "Question": ["加号运算符重载中匿名对象以及拷贝构造函数和加号运算符重载的问题？", ["**1.下列程序运行中，stu0103和stu0104的地址和stu0102、stu0101的地址相差比较大。请问为什么，分别存在什么区？", "\n2.请问加号运算符重载中是否调用了拷贝构造函数？", "\n**", "\n\n", "#include<iostream>\n#include<string>\nusing namespace std;\n\nclass Student_t {\n\npublic:\n    Student_t():Student_t(\"Lilei\",18) {}\n    Student_t(const std::string name,const int age,const int high = 175) :name(name), age(age), high(high) {\n**      //学生人数++**\n        number_of_stu++;\n    }\n\n    //成员加号运算符重载\n    Student_t operator+(Student_t& stu);\n\nprivate:\n    std::string name;//学生姓名\n    int age;//年龄\n    int high;//身高\n    static int number_of_stu;//学生人数\n};\n\nextern std::ostream& operator<<(std::ostream& os, const \nStudent_t& stu);\n\n//成员加号运算符重载\nStudent_t Student_t::operator+(Student_t& stu) {\n    return Student_t(this->name + stu.name, this->age + stu.age,this->high + stu.high);\n}\n\nint main()\n{\n    //堆空间对象\n    Student_t* stu0101 = new Student_t(\"C\",10);\n    Student_t* stu0102 = new Student_t(\"X\",9);\n\n    Student_t* stu0103 = &(*stu0101 + *stu0102);\n    cout << *stu0103 << endl;\n\n    Student_t* stu0104 = &(*stu0101 + *stu0103);\n    cout << *stu0104 << endl;\n\n    cout << stu0101 << \" \" << stu0102 << \" \" << stu0103 << \" \"<< stu0104<<endl;\n\n    system(\"pause\");\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/JY_95/article/details/48326043'&gt;C++ Primer :  : 第十四章 : 重载运算符与类型转换之类型转换运算符和重载匹配&lt;/a&gt;&lt;br/&gt;----------------------同志你好，我是CSDN问答机器人小N，奉组织之命为你提供参考答案，编程尚未成功，同志仍需努力！", "Konwledge_Point": "运算符重载", "Question": ["重载运算符类型不匹配", ["#ifndef DAT_H_INCLUDED", "\n#define DAT_H_INCLUDED", "\n#include", "\n#include", "\n#include", "\nusing namespace std;", "\n\n", "class date", "\n{", "\nprivate:", "\n    int year;", "\n    int month;", "\n    int day;", "\n    int dton(date &a);  //将指定日期转换成从0年O月O日起的天数", "\n    date ntod(int b);   //将指定的0年O月O日起的天数转换成对应的日期", "\n    bool leap(int year);", "\npublic:", "\n    date();", "\n    date(int y,int m,int d);", "\n    friend istream &operator >> (istream &is,date &d);", "\n    friend ostream &operator << (ostream &os,date &d);", "\n    date operator +(int &days);", "\n    date operator -(int &days);", "\n    int operator -(date &da);", "\n    void operator =(date &da);", "\n    int dt(date &a);", "\n    date nt(int b);", "\n    bool le(int year);", "\n    ~date();", "\n};", "\n\n", "#endif // DAT_H_INCLUDED", "\n\n", "#include\"dat.h\"\n#include<istream>\n#include<ostream>\n#include<iostream>\n\nusing namespace std;\n\n static int day_tab[2][12] = {{31,28,31,30,3l,30,3l,3l,30,31,30,31},\n    {31,29,31,30,31,30,31,31,30,31,30,31}};\n\ndate::date()\n{\n    year = 0;\n    month = 1;\n    day = 1;\n}\n\n\ndate::date(int y,int m,int d)\n{\n    year = y;\n    month = m;\n    day = d;\n}\n\nistream &operator >> (istream &is,date &d)\n{\n    cin >> d.year >> d.month >> d.day;\n    return is;\n}\n\nostream &operator << (ostream &os,date &d)\n{\n    cout << d.year << \".\" << d.month << \".\" << d.day << endl;\n    return os;\n}\n\nbool date::leap(int year)\n{\n    if((year % 4 == 0 && year % 100 != 0)||year % 400 == 0)\n        return true;\n    else\n        return false;\n}\n\ndate date::operator +(int &days)\n{\n    int rest;\n    rest = this->dt(*this) + days;\n    return this->nt(rest);\n}\n\nint date::dton(date &a)\n{\n    int ye,mo,da=0;\n    for(ye = 0;ye < a.year;ye++)\n    {\n        if(a.le(a.year))\n            da += 366;\n        else da += 365;\n    }\n    for(mo = 0;mo < a.month-1;mo++)\n        {\n            if(a.le(a.year))\n                da += day_tab[0][mo];\n            else da += day_tab[1][mo];\n        }\n    da += a.day;\n    return da;\n}\n\ndate date::ntod(int b)\n{\n    date a(0,1,1);\n    int rest = b;\n    while(1)\n    {\n        if(a.le(a.year))\n        {\n            rest -= 366;\n            if(rest < 0)\n            {\n                rest += 366;\n                break;\n            }\n            a.year++;\n        }\n        else\n        {\n            rest -= 365;\n            if(rest < 0)\n            {\n                rest += 365;\n                break;\n            }\n            a.year++;\n        }\n    }\n    while(1)\n    {\n        if(a.le(a.year))\n        {\n            for(int i = 0;i < 12;i++)\n                {\n                    rest -= day_tab[0][i];\n                    if(rest < 0)\n                    {\n                        rest += day_tab[0][i];\n                        break;\n                    }\n                    a.month++;\n                }\n        }\n        else\n        {\n            for(int i = 0;i < 12;i++)\n                {\n                    rest -= day_tab[1][i];\n                    if(rest < 0)\n                    {\n                        rest += day_tab[1][i];\n                        break;\n                    }\n                    a.month++;\n                }\n        }\n        break;\n    }\n    a.day = rest;\n    return a;\n}\n\ndate date::operator -(int &days)\n{\n    int da;\n    da = this->dt(*this) - days;\n    return this->nt(da);\n}\n\nint date::operator -(date &da)\n{\n    int rest;\n    rest = this->dt(*this) - da.dt(da);\n    return rest;\n}\n\nint date::dt(date &a)\n{\n\n    return dton(a);\n}\n\ndate date::nt(int b)\n{\n    return ntod(b);\n}\n\nbool date::le(int year)\n{\n    return leap(year);\n}\n\nvoid date::operator =(date &da)\n{\n    this->year = da.year;\n    this->month = da.month;\n    this->day = da.day;\n}\n\ndate::~date()\n{\n\n}\n\n\n#include<iostream>\n#include<ostream>\n#include<windows.h>\n#include\"dat.h\"\nusing namespace std;\n\nint main()\n{\n\n    while(1)\n    {\n        date *p = new date;\n\n        cout << \"请输入日期：\" << endl;\n        cin >> *p;\n        int n;\n        cout << \"请选择功能：\" << endl;\n        cout << \"1.将日期转化为天数\\n\" << \"2.两日期相差天数\\n\" << \"3.计算所加天数后日期\\n\" << \"4.计算所减天数后日期\\n\" << \"5.将天数转化为日期\\n\"\n             << \"6.退出\" << endl;\n        cin >> n;\n        while(n<1||n>6)\n            {\n                cout << \"输入错误，请重新选择功能\" << endl;\n                n = 0;\n                cin >> n;\n            }\n        system(\"cls\");\n        switch(n)\n        {\n            case 1:\n            {\n                cout << p->dt(*p) << endl;\n                system(\"pause\");\n                system(\"cls\");\n                break;\n            }\n            case 2:\n            {\n                date *q = new date;\n                cout << \"请输入日期：\" << endl;\n                cin >> *q;\n                cout << *p - *q << endl;\n                system(\"pause\");\n                system(\"cls\");\n                delete q;\n                break;\n            }\n        case 3:\n            {\n                cout << \"请输入天数：\" << endl;\n                int m;\n                cin >> m;\n                cout << *p + m << endl;\n                system(\"pause\");\n                system(\"cls\");\n                break;\n            }\n        case 4:\n            {\n                cout << \"请输入天数：\" << endl;\n                int k;\n                cin >> k;\n                cout << (*p - k) << endl;\n                system(\"pause\");\n                system(\"cls\");\n                break;\n            }\n        case 5:\n            {\n                cout << \"请输入天数：\" << endl;\n                int u;\n                cin >> u;\n                date q = p->nt(u);\n                cout << q << endl;\n                system(\"pause\");\n                system(\"cls\");\n                break;\n            }\n        case 6:exit(0);\n        }\n\n    }\n}\n\n\n\n\n报错：\n||=== Build: Debug in Date (compiler: GNU GCC Compiler) ===|\nD:\\C++学习\\Date\\main.cpp||In function 'int main()':|\nD:\\C++学习\\Date\\main.cpp|65|error: no match for 'operator<<' in 'std::cout << date::operator-(const int&)(((const int&)((const int*)(& k))))'|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|108|note: candidates are: std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>& (*)(std::basic_ostream<_CharT, _Traits>&)) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|117|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ios<_CharT, _Traits>& (*)(std::basic_ios<_CharT, _Traits>&)) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|127|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::ios_base& (*)(std::ios_base&)) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|165|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(long int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|169|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(long unsigned int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|173|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(bool) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\bits\\ostream.tcc|91|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(short int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|180|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(short unsigned int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\bits\\ostream.tcc|105|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|191|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(unsigned int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|200|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(long long int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|204|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(long long unsigned int) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|209|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(double) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|213|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(float) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|221|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(long double) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\ostream|225|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(const void*) [with _CharT = char, _Traits = std::char_traits<char>]|\nd:\\codeblocks\\mingw\\bin\\..\\lib\\gcc\\mingw32\\4.4.1\\include\\c++\\bits\\ostream.tcc|119|note:                 std::basic_ostream<_CharT, _Traits>& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_streambuf<_CharT, _Traits>*) [with _CharT = char, _Traits = std::char_traits<char>]|\nD:\\C++学习\\Date\\dat.h|21|note:                 std::ostream& operator<<(std::ostream&, date&)|\n||=== Build failed: 1 error(s), 0 warning(s) (0 minute(s), 0 second(s)) ===|\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个错误信息表明在你的代码中调用了一个名为Integer的构造函数&amp;#xff0c;但传递的参数类型不匹配。更具体地说&amp;#xff0c;它指出没有一个与Integer类的构造函数的参数匹配。&lt;/p&gt;\n&lt;p&gt;这段代码存在几个问题&amp;#xff0c;我帮你逐个指出并进行修正。&lt;br /&gt;1.类名与构造函数名不一致&lt;br /&gt;在类定义中&amp;#xff0c;类名为 Integerf&amp;#xff0c;但构造函数的名称为 Integer&amp;#xff0c;这是不一致的。应该将类名改为 Integer&amp;#xff0c;以与构造函数名称相一致。&lt;/p&gt;\n&lt;p&gt;2.类定义中的 private 关键字&lt;br /&gt;在类定义中&amp;#xff0c;private 后面缺少了一个冒号&amp;#xff08;:&amp;#xff09;&amp;#xff0c;应该加上冒号&amp;#xff0c;否则会导致语法错误。&lt;/p&gt;\n&lt;p&gt;3.构造函数的参数类型错误&lt;br /&gt;在类定义中&amp;#xff0c;构造函数应该使用 Integer(int num) 的形式&amp;#xff0c;而不是 Integer(Integer &amp;amp;p) 的形式。因为构造函数是用来初始化对象的&amp;#xff0c;而 Integer &amp;amp;p 不是一个合法的对象类型。应该使用 int 类型作为参数类型。&lt;/p&gt;\n&lt;p&gt;4.运算符重载函数的定义错误&lt;br /&gt;在定义 operator&amp;#43; 函数时&amp;#xff0c;应该将函数体中的多余的 { 删除&amp;#xff0c;并在开头添加 Integer 类型。并且&amp;#xff0c;在函数名和参数列表之间缺少了一个空格&amp;#xff0c;应该添加上去。&lt;br /&gt;-&lt;br /&gt;修改后的代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Integer&lt;/span&gt; {\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Integer&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num): &lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;(num) {}\n    &lt;span class=\"hljs-built_in\"&gt;Integer&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Integer &amp;amp;p) { num &amp;#61; p.num / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;show&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{ cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; endl; }\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Integer &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Integer &amp;amp;il, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Integer &amp;amp;i2);\n};\n\nInteger &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Integer &amp;amp;il, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Integer &amp;amp;i2) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Integer&lt;/span&gt;(il.num &amp;#43; i2.num);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Integer &lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Integer &lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;40&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Integer &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(a)&lt;/span&gt;&lt;/span&gt;;\n    c.&lt;span class=\"hljs-built_in\"&gt;show&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;再试一下&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["(C++)运算符重载和拷贝函数", ["当拷贝函数和运算符重载同时出现时，会出现错误", "只有运算符重载时，函数正常运行", "\n", "只有拷贝函数时，函数正常运行", "\n", "当两个同时存在时，出现错误，问一下，这是什么错误", "\n"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/u010003835/article/details/47312955", "Konwledge_Point": "运算符重载", "Question": ["如何运用C++的模板类的模板方法，实现私有的运算符重载？", ["如何运用C++的模板类的模板方法，实现私有的运算符重载，在类的内部重载运算符，请教大侠怎么实现？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; out, Maker&amp;amp; m)&lt;/code&gt;&lt;br /&gt;改为&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; out, const Maker&amp;amp; m)&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["后置++通过<<运算符的重载进行输出，为什么会出错？", ["class", " ", "Maker", "\n{\n    Maker ", "operator", "++(", "int", ")", "//占位参数,必须是int", "\n    {\n        ", "Maker ", "tmp", "(", "*", "this", ")", ";\n        ++", "this", "->a;\n        ", "return", " tmp;\n    }\n......\n}\nostream& ", "operator", "<<(ostream& ", "out", ", Maker& m)\n{\n    cout << m.a << endl;\n    ", "return", " ", "out", ";\n}\n", "void", " ", "test", "(", ")", "\n{\n  cout << m1++ << endl;", "//2  这里返回的是tmp的拷贝", "\n}\n", "\n", "后置加加不能返回引用类型，所以这里返回的是Maker对象的一个拷贝，为什么在<<运算符重载的时候会报错呢？返回的错误是说“没有与这些操作数匹配的<<运算符”"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; 因为你是在被除数的作用域下执行的division, 然后又返回了被除数的this指针&lt;br /&gt;/的重载里面重新新建一个值为monet_number/i的money实例即可&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-cpp\"&gt;&lt;span class=\"hljs-type\"&gt;Money&lt;/span&gt;::&lt;span class=\"hljs-type\"&gt;Money&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;Money&lt;/span&gt;&amp;amp; tmp){\n    this-&amp;gt;money_number &amp;#61; tmp.money_number;\n}\n&lt;span class=\"hljs-type\"&gt;Money&lt;/span&gt;&amp;amp; &lt;span class=\"hljs-type\"&gt;Money&lt;/span&gt;::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;/(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; i){\n    &lt;span class=\"hljs-type\"&gt;Money&lt;/span&gt; tmp(this);\n    tmp.division(i);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;不过话说回来, 加减乘除这种运算本身就不应该修改参加运算的参数的值, 而是应该另外返回一个数据类型的实例&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["有关重载函数运算符除法运算导致被除数变化的问题", ["(语言是C++）", "我自创了一个Money类，用于表示钱。在类中我重载了“/”号，但是被除数在除法运算过程中发生了改变。如下图", "\n", "\n", "\n", "\n", "这种情况怎么解决呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;const 引用可以绑定临时变量&amp;#xff0c;或者叫右值&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["递增运算符重载与左移运算符重载", ["递增运算符重载", "\n", "\n", "左移运算符重载时，第二参数不加const的时候 前置递增运算符输出正常，后置报错", "\n", "\n", "加了const后", "\n", "\n", "正常输出", "\n", "请问这个const用途是啥呀(●'◡'●)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看明白了&amp;#xff0c;this和temp都是地址&amp;#xff0c;指向的同一个对象。*this改了*temp也会跟着改&amp;#xff0c;我傻了&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["萌新小白提问，c++重载后置递增运算符", ["class MyData", "\n{", "\n\n", "public:", "\n\n", "    int m_a;", "\n\n", "    MyData()  ", "\n    {", "\n        m_a = 0;", "\n    }", "\n\n", "\n    MyData& operator++(int)", "\n    {", "\n        MyData* temp = this;", "\n\n", "        this->m_a++;", "\n\n", "        return *temp;", "\n    }", "\n\n", "};", "\n\n", "\nostream& operator<<(ostream& cout, MyData d)", "\n{", "\n    cout << d.m_a;", "\n    return cout;", "\n}", "\n\n", "\nint main()", "\n{", "\n    MyData d;", "\n    cout << d++ << endl;", "\n    cout << d << endl;", "\n\n", "}", "\n\n", "这里最后的两个输出都是1，想知道是哪里出了问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运算符重载&amp;#xff0c;你重载的应该是个函数呀&lt;br /&gt;你定义的Boll是个class&amp;#xff0c;class后面哪能加这些东西&lt;br /&gt;还有&amp;#xff0c;既然你的类是想要intToBoll&amp;#xff0c;那你输入是个int&amp;#xff0c;输出应该是个bool呀&amp;#xff0c;你原封不动的把原值输出了是想干啥呢&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c#能否用运算符重载赋予数布尔意义", ["刚刚学到运算符重载这块，然后想到c#里数值不像c里面有布尔意义，所以想试试能不能用运算符重载让int类型的数也具有布尔意义，然而自己试着写了一下感觉没什么头猪，求指点是否可行"]], "Tag": "程序设计"}
{"Answer": "因为Data uu = nn.Return(nn);中uu和nn.Return(nn)的类型确实不一致，uu是Data类型的，而nn.Return(nn)由于是临时对象，\r\n编译器为了防止其被非期望修改，而确定nn.Return(nn)为Const Data类型。\r\n楼主如果想要cout &lt;&lt; nn.Return(nn);能直接被执行，只需要再重载一个Const Data类型的&lt;&lt;函数即可，如下：\r\nostream&amp; operator &lt;&lt; (ostream&amp; out, Const Data&amp; data)\r\n{\r\n    out &lt;&lt; data.id;\r\n    return out;\r\n}", "Konwledge_Point": "运算符重载", "Question": ["c++重载输出运算符，输出运算符后接函数的返回值为什么会报错“没有与操作数匹配的运算符”？", ["#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nclass Data\n{\npublic:\n    string id = \"01\";\n};\n\nclass Node\n{\npublic:\n    Data data;\n    Data Return(Node& temp)\n    {\n        return temp.data;\n    }\n};\n\nostream& operator << (ostream& out, Data& data)\n{\n    out << data.id;\n    return out;\n}\n\nint main()\n{\n    Node nn;\n    Data uu = nn.Return(nn);\n    cout << uu;\n    //cout << nn.Return(nn);\n}\n", "\n\n", "Node nn;\nData uu = nn.Return(nn);\ncout << uu;\n和\ncout << nn.Return(nn);\n参考代码，nn.Return(nn)的东西应该就是uu，\n但为什么直接cout输出nn.Return(nn)会报错，\n反而\nNode nn;\nData uu = nn.Return(nn);\ncout << uu;\n这样绕一圈才可以重载输出呢？\n"]], "Tag": "程序设计"}
{"Answer": "因为不使用&amp;，那么堆栈上临时开辟的新对象会被释放，传回去堆栈破坏就出错了。", "Konwledge_Point": "运算符重载", "Question": ["C++运算符重载问题，为什么重载+-运算符时operator关键字前不需要加&，重载=时operator前必须加&号啊", ["另外类作为形参传入函数时， 有些情况可以不采用引用传递，但有的时候必须采用引用传递，否则会出错。", "\n                比如重载", "\n                ARRAY & operator = (ARRAY &b);", "\n                能解释下两个&号分别有什么意义吗，谢谢大佬！"]], "Tag": "程序设计"}
{"Answer": "1）//拷贝构造函数 应为为\r\nCom(const Com&amp;c):i(c.i),j(c.j){};\r\nC++11: 最好写两个 拷贝构造函数，一个拷贝，一个移动\r\nCom(const Com&amp;c):i(c.i),j(c.j){};\r\nCom(Com&amp;&amp;c):i(c.i),j(c.j){};\r\n\r\n2）//成员函数方式重载双目运算符，一般写成这样。\r\nCom &amp;operator+(const Com &amp;c){(i+=c.i;j+=c.j;return this;); \r\n}\r\n\r\n3) 双目运算符最好重载为友元函数，这样两个参数都可以是 const T&amp; 类型参数，适应性也比较好。", "Konwledge_Point": "运算符重载", "Question": ["一个关于C++运算符重载的问题", ["#include ", "\nusing namespace std;", "\nclass Com{", "\npublic:", "\n    Com(double i,double j){i=i;j=j;}", "\n    Com(Com&c):i(c.i),j(c.j){}", "\n    void show(){cout<<i<<\"+\"<<j<<\"i\";}", "\n    Com operator+(Com c){return Com(i+c.i,j+c.j); }", "\nprivate:", "\n    double i,j;", "\n};", "\n上面这个代码有错吗？为什么我 没写复制构造函数就不会有问题，写了就报错[Error] no matching function for call to 'Com::Com(Com)'？求教"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\n\r\n\r\n//定义一个整形类\r\n\r\nclass MyInteger\r\n{\r\n    //重载\"&lt;&lt;\"运算符用来输出类对象\r\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger&amp; myint);\r\n\r\nprivate:\r\n    int m_Integer;\r\npublic:\r\n    MyInteger();\r\n\tMyInteger(MyInteger&amp; mi)\r\n\t{\r\n\t\tm_Integer = mi.m_Integer;\r\n\t}\r\n    //前置++运算符\r\n    //返回值为引用，也就是对象本身\r\n    MyInteger&amp; operator++()\r\n    {\r\n        m_Integer++;\r\n        return *this;\r\n    }\r\n\r\n    //后置++运算符\r\n    //返回值为类类型，因为返回的是自增前记录的值，temp是局部变量\r\n    MyInteger&amp; operator++(int)//加上一个占位参数，用来区分前置自增和后置自增\r\n    {\r\n        //记录当前的值\r\n        MyInteger * temp = new MyInteger(*this);\r\n        //使数据成员自增\r\n        temp-&gt;m_Integer++;\r\n        //返回此前记录的值\r\n        return *temp;\r\n\r\n    }\r\n\r\n\r\n};\r\n\r\n//定义构造函数\r\nMyInteger::MyInteger() :m_Integer(10)\r\n{\r\n\r\n}\r\n//重载\"&lt;&lt;\"运算符\r\nostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger&amp; myint)\r\n{\r\n    cout &lt;&lt; myint.m_Integer;\r\n    return cout;\r\n}\r\n\r\nvoid test_1()\r\n{\r\n    MyInteger myint;\r\n    cout &lt;&lt; ++myint &lt;&lt; endl;//这两行\r\n    cout &lt;&lt; myint &lt;&lt; endl;    //可以正常输出\r\n    MyInteger myint2;\r\n    cout &lt;&lt; myint2++&lt;&lt; endl;//这个地方报错，提示我没有这些操作数匹配的\"&lt;&lt;\"运算符为什么\r\n\r\n\r\n}\r\n\r\nint main()\r\n{\r\n\r\n    test_1();\r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n```\r\n# 问题解决的话，请点下采纳", "Konwledge_Point": "运算符重载", "Question": ["C++ 运算符重载 代码报错问题", ["\n```#include<iostream>\nusing namespace std;\n\n\n//定义一个整形类\n\nclass MyInteger\n{\n    //重载\"<<\"运算符用来输出类对象\n    friend ostream& operator<<(ostream& cout, MyInteger& myint);\n\nprivate:\n    int m_Integer;\npublic:\n    MyInteger();\n    //前置++运算符\n    //返回值为引用，也就是对象本身\n    MyInteger& operator++()\n    {\n        m_Integer++;\n        return *this;\n    }\n\n    //后置++运算符\n    //返回值为类类型，因为返回的是自增前记录的值，temp是局部变量\n    MyInteger operator++(int)//加上一个占位参数，用来区分前置自增和后置自增\n    {\n        //记录当前的值\n        MyInteger temp = *this;\n        //使数据成员自增\n        m_Integer++;\n        //返回此前记录的值\n        return temp;\n\n    }\n\n\n};\n\n//定义构造函数\nMyInteger::MyInteger() :m_Integer(10)\n{\n\n}\n//重载\"<<\"运算符\nostream& operator<<(ostream& cout, MyInteger& myint)\n{\n    cout << myint.m_Integer;\n    return cout;\n}\n\nvoid test_1()\n{\n    MyInteger myint;\n    cout << ++myint << endl;//这两行\n    cout << myint << endl;    //可以正常输出\n    MyInteger myint2;\n    cout << myint2++<< endl;//这个地方报错，提示我没有这些操作数匹配的\"<<\"运算符为什么\n\n\n}\n\nint main()\n{\n\n    test_1();\n    system(\"pause\");\n    return 0;\n}\n", "\n\n", "我用的VS2019\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运行结果及代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请帮忙采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/210997339536149.jpg\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ipaddr&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    string mip[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;ipaddr&lt;/span&gt;(string ip)\n    {\n        string t;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; pos &amp;#61; ip.&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;);\n        mip[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; ip.&lt;span class=\"hljs-built_in\"&gt;substr&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,pos);\n        t &amp;#61; ip.&lt;span class=\"hljs-built_in\"&gt;substr&lt;/span&gt;(pos&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,ip.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;()-pos);\n\n        pos &amp;#61; t.&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;);\n        mip[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; t.&lt;span class=\"hljs-built_in\"&gt;substr&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,pos);\n        t &amp;#61; t.&lt;span class=\"hljs-built_in\"&gt;substr&lt;/span&gt;(pos&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,t.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() - pos);\n\n        pos &amp;#61; t.&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;);\n        mip[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; t.&lt;span class=\"hljs-built_in\"&gt;substr&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,pos);\n        t &amp;#61; t.&lt;span class=\"hljs-built_in\"&gt;substr&lt;/span&gt;(pos&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,t.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() - pos);\n\n        mip[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]&amp;#61;t;\n    }\n\n    ipaddr&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n){ &lt;span class=\"hljs-comment\"&gt;//如果参数是const char*类型的话&amp;#xff0c;就多一个类型转换&amp;#xff0c;用atoi把字符串转成数字就可以了&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; buf[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; nb &amp;#61; &lt;span class=\"hljs-built_in\"&gt;atoi&lt;/span&gt;(mip[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;c_str&lt;/span&gt;());\n        nb &amp;#43;&amp;#61; n;\n        nb &amp;#61; nb%&lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//大于255后取余&lt;/span&gt;\n        mip[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;itoa&lt;/span&gt;(nb,buf,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    ipaddr&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n){\n        &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; buf[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; nb &amp;#61; &lt;span class=\"hljs-built_in\"&gt;atoi&lt;/span&gt;(mip[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;c_str&lt;/span&gt;());\n        nb -&amp;#61; n;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(nb &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) nb&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;;\n        nb &amp;#61; nb%&lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//大于255后取余&lt;/span&gt;\n        mip[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;itoa&lt;/span&gt;(nb,buf,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    \n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;show&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        cout &amp;lt;&amp;lt; mip[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; mip[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; mip[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt;mip[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]&amp;lt;&amp;lt;endl;\n    }\n\n};\n\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;ipaddr &lt;span class=\"hljs-title\"&gt;ip&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;192.168.0.24&amp;#34;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;    \n    ip &amp;#61; ip - &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    ip.&lt;span class=\"hljs-built_in\"&gt;show&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["求指点，用运算符重载方法实现", ["采用运算符重载的方式，实现IP地址字符串的加，减法。", "如192.168.1.23 + 5 = 192.168.1.28，", "192.168.32.54 - 9 = 192.168.32.45"]], "Tag": "程序设计"}
{"Answer": "&amp;表示返回值类型是引用\r\n什么时候需要返回引用, 基于两点\r\n第一是需求, 有些情况语法要求必须返回引用\r\n比如重载=操作符,  返回引用才可写出 a1=a2=a3这样的语句\r\n再如[]操作符, 返回引用才能实现这样的语句: a[0]=1;\r\n\r\n第二是效率问题:\r\n很多情况是不需要返回引用的, 比如双目的+, 可以是返回一个对象的副本, 但是返回引用比返回对象的副本效率要高, 因为返回副本最少要有两次拷贝构造被调用, 对于一个体积比较大的类来说,  时间上的开销还是要考虑的.   所以这时常用返回const引用来代替返回副本.", "Konwledge_Point": "运算符重载", "Question": ["c++的运算符重载 operator前&是必要的吗 有什么作用吗 求解", ["c++的运算符重载 operator前&是必要的吗 有什么作用吗 求解 谢谢各位"]], "Tag": "程序设计"}
{"Answer": "那样会多调用一次拷贝构造函数浪费性能，如果没有定义拷贝构造函数，操作不会作用到原来的变量上，也就是不会自增。", "Konwledge_Point": "运算符重载", "Question": ["关于类中的运算符重载中this指针使用的问题", ["    const Byte& operator++()\n    {\n        b++;\n        return *this;// 前缀形式 返回改变后的对象\n    }\n\n    const Byte& operator--()\n    {\n        b--;\n        return *this;\n    }\n\n    const Byte operator++(int)\n    {\n        Byte before(b);\n        b++;\n        return before;//后缀形式 返回改变前的对象 创建一个独立的类类返回先前的值 所以采用的是按值进行返回\n    }\n\n    const Byte operator--(int)\n    {\n        Byte before(b);\n        b--;\n        return before;\n    }\n", "\n\n", "为什么返回this指针的解引用的时候函数的返回值要定义为类的引用类型呢？ 可以直接定义为按值进行返回吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n \n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;vec3&lt;/span&gt; {\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;vec3&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; z&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        v[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; x;\n        v[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; y;\n        v[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;#61; z;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[] (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;// 1&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v[index];\n    }\n    vec3&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; vec3&amp;amp; rhs)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; &amp;#43;&amp;#43;i)\n            v[i] &amp;#43;&amp;#61; rhs[i]; &lt;span class=\"hljs-comment\"&gt;// 2&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 3&lt;/span&gt;\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; v[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n};\n \nvec3 &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; vec3&amp;amp; v1, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; vec3&amp;amp; v2)\n{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;vec3&lt;/span&gt;(v1[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#43;v2[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], v1[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#43;v2[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], v1[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&amp;#43;v2[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]); &lt;span class=\"hljs-comment\"&gt;// 4&lt;/span&gt;\n}\n \nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; out, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; vec3&amp;amp; v) &lt;span class=\"hljs-comment\"&gt;// 5&lt;/span&gt;\n{\n    out &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;(&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; v[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; v[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; v[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; out; &lt;span class=\"hljs-comment\"&gt;// 6&lt;/span&gt;\n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;vec3 &lt;span class=\"hljs-title\"&gt;v1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;v2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    vec3 v &amp;#61; v1 &amp;#43; v2;\n    v &amp;#43;&amp;#61; v2;\n    cout &amp;lt;&amp;lt; v &amp;lt;&amp;lt; endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运算符重载关注几个问题&amp;#xff1a;&lt;br /&gt;1、重载函数是否作为类的成员函数&amp;#xff0c;作为成员函数的话有一个默认参数this代表左操作数。也就是说如果是加法&amp;#xff0c;重载函数作为成员函数只需要写一个右操作数&amp;#xff0c;而作为非成员函数需要写两个参数(左操作数&amp;#xff0c;右操作数)。&lt;br /&gt;2、const关键字的使用&lt;br /&gt;3、this的使用&lt;br /&gt;4、一些特殊运算符的重载&amp;#xff0c;比如&amp;#43;&amp;#43;&amp;#xff0c;&amp;lt;&amp;lt;, &amp;gt;&amp;gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["简单的运算符重载问题", ["问题遇到的现象和发生背景", "\n", "刚学习C++，对它的理解还停留在数据成员和成员函数，这里遇到运算符重载的填空题，解决不了", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<vector>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "vec3", " {\n", "public", ":\n  ", "vec3", "(", "int", " x=", "0", ", ", "int", " y=", "0", ", ", "int", " z=", "0", ")\n  {\n    v[", "0", "] = x;\n    v[", "1", "] = y;\n    v[", "2", "] = z;\n  }\n  ", "int", " ", "operator", "[] \n\n  {\n    ", "return", " v[index];\n  }\n  vec3& ", "operator", "+=(", "const", " vec3& rhs)\n  {\n    ", "for", " (", "int", " i = ", "0", "; i < ", "3", "; ++i)\n      \n;\n    \n", "return", " *", "this", "\n;\n  }\n", "private", ":\n  ", "int", " v[", "3", "];\n};\n\nvec3 ", "operator", "+(", "const", " vec3& v1, ", "const", " vec3& v2)\n{\n  ", "return", " \n;\n}\n\n ", "operator", "<<(ostream& out, ", "const", " vec3& v)\n{\n  out << ", "'('", " << v[", "0", "] << ", "' '", " << v[", "1", "] << ", "' '", " << v[", "2", "] << ", "')'", ";\n  \n;\n}\n\n", "int", " ", "main", "()", "\n", "{\n  ", "vec3 ", "v1", "(", "1", ",", "2", ",", "3", ")", ", ", "v2", "(", "4", ",", "5", ",", "6", ")", ";\n  vec3 v = v1 + v2;\n  v += v2;\n  cout << v << endl;\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "还不太明白重载的原理", "\n", "我想要达到的结果", "\n", "希望能给出题目答案的同时，给出一些思路上的指导"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.就因为你没返回引用&amp;#xff0c;所以第一次&amp;#43;&amp;#43;的并不是myint&amp;#xff0c;而是&amp;#43;&amp;#43;myint的返回值&amp;#xff0c;所以myint不受影响。&lt;br /&gt;2.新建了一个对象是的确&amp;#xff0c;但是你没有赋值给调用者&amp;#xff0c;而且就算赋值了地址也不会修改&amp;#xff0c;所有变量地址都是不变的&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++自增运算符重载的问题", ["#", "define", "  _CRT_SECURE_NO_WARNINGS 1", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<string>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "MyInt", "\n{\n    ", "friend", " ostream& ", "operator", "<<(ostream& cout, MyInt myint);\n", "private", ":\n    ", "int", " a=", "0", ";\n", "public", ":", "//前置运算符重载", "\n    MyInt ", "operator", "++()\n    {\n        a++;\n        ", "return", " *", "this", ";\n    }\n    MyInt ", "operator", "++(", "int", ")\n    {\n        MyInt temp = *", "this", ";\n        a++;\n        ", "return", " temp;\n    }\n};\nostream& ", "operator", "<<(ostream& cout, MyInt myint)\n{\n    cout << myint.a;\n    ", "return", " cout;\n}\n", "void", " ", "test_01", "()", "\n", "{\n    MyInt myint;\n    cout << ++(++myint) << endl;\n   cout << myint;\n}\n", "int", " ", "main", "()", " ", "{\n    ", "test_01", "();\n    \n}\n\n", "\n", "有几个问题就是：", "1.我在重载前置++这个运算符是故意返回的不是引用数据类型，在多次调用++ （如：我在test—01那里写的第一次cout ）再次调用cout，为什么值会不一样（第一次值为2，第二次值为1）", "2.返回对象时不是拷贝吗，新建了一个对象赋值给了调用者，这里的myint地址不会被修改吗，为什么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载&amp;#43;&amp;#43; 、--、&amp;#43;这些运算符的时候&amp;#xff0c;需要对Date类的元素进行修改&amp;#xff0c;而不是直接对类对象操作。&lt;br /&gt;运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/694346869356143.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;/*运算符重载的问题&amp;#xff0c;想问下面的代码怎么改呀&amp;#xff0c;这个日期类Date&amp;#xff0c;要求&amp;#xff1a;\n&amp;#xff08;1&amp;#xff09; 可以建立具有指定日期&amp;#xff08;年、月、日&amp;#xff09;的Date对象&amp;#xff0c;默认日期是2020.1.1。\n&amp;#xff08;2&amp;#xff09; 可以从输出流输出一个格式为“年 - 月 - 日”的日期&amp;#xff0c;其中年是四位数据&amp;#xff0c;月、日可以是一位也可以是两位数据。\n&amp;#xff08;3&amp;#xff09;可以动态地设置年、月、日。\n&amp;#xff08;4&amp;#xff09;可以用运算符 &amp;#61;&amp;#61; 、 !&amp;#61; 、&amp;lt; 和 &amp;gt; 对两个日期进行比较。\n&amp;#xff08;5&amp;#xff09;可以用运算符 &amp;#43;&amp;#43;、 &amp;#43;&amp;#61; 等完成天数的加一天或若干天的操作\n&amp;#xff08;6&amp;#xff09;Date类必须能够正确表达日期&amp;#xff0c;不会出现类似于13月&amp;#xff0c;32日一类的情况。Date类还必须处理闰年的问题&amp;#xff0c;闰年包括&amp;#xff1a;所有能被400整除的年份&amp;#xff0c;以及能被4整除同时又不能被100整除的年份。\n输入格式 :\n第一行包含两个日期&amp;#xff0c;第二行包含一个日期和一个整数。输入日期的格式为“年 月 日”。\n输出格式 :\n输出两行&amp;#xff1a;\n第一行是比较输入数据第一行的两个日期&amp;#xff0c;若相等&amp;#xff0c;则输出“Equal”&amp;#xff0c;若第一个日期小于第二个日期&amp;#xff0c;则输出“Less”&amp;#xff0c;若第一个日期大于第二个日期&amp;#xff0c;则输出“Greater”。\n第二行是输入数据第二行的日期 &amp;#43;&amp;#61; 输入的整数后的日期&amp;#xff0c;输出格式和题目描述中的&amp;#xff08;2&amp;#xff09;一致&amp;#xff0c;也就是“年 - 月 - 日”。\n*/&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\nusing namespace std;\n\nclass &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;\n{\npublic:\n    &lt;span class=\"hljs-comment\"&gt;// 获取某年某月的天数&lt;/span&gt;\n    int  GetMonthDay(int year, int month)\n    {\n        static const int monthday[&lt;span class=\"hljs-number\"&gt;13&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;28&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt; };\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((month &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) &amp;amp;&amp;amp; (year % &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; year % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) || (year % &lt;span class=\"hljs-number\"&gt;400&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;))\n        {\n            return &lt;span class=\"hljs-number\"&gt;29&lt;/span&gt;;\n        }\n        return monthday[month];\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 全缺省的构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;(int year &amp;#61; &lt;span class=\"hljs-number\"&gt;2020&lt;/span&gt;, int month &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, int day &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (year &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n            &amp;amp;&amp;amp; month &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; month &amp;lt; &lt;span class=\"hljs-number\"&gt;13&lt;/span&gt;\n            &amp;amp;&amp;amp; day&amp;gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; day &amp;lt;&amp;#61; GetMonthDay(year, month))\n        {\n            &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#61; year;\n            &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; month;\n            &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#61; day;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Date invalid&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n        }\n    }\n\n\n    &lt;span class=\"hljs-comment\"&gt;// 拷贝构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;(const &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; d)\n    {\n        this-&amp;gt;&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;;\n        &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;;\n        &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt;;\n\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; operator&amp;#61;(const &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; d)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (this !&amp;#61; &amp;amp;d)\n        {\n            this-&amp;gt;&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;;\n            this-&amp;gt;&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;;\n            this-&amp;gt;&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt;;\n        }\n        return *this;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 析构函数&lt;/span&gt;\n    ~&lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;()\n    {}\n\n    &lt;span class=\"hljs-comment\"&gt;// 日期&amp;#43;&amp;#61;天数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; operator&amp;#43;&amp;#61;(int day)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (day &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#43;&amp;#61; day;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;gt; GetMonthDay(&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;, &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;))\n            {\n                &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; -&amp;#61; GetMonthDay(&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;, &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;);\n                &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;)\n                {\n                    &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                    &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                }\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; -&amp;#61; day;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                {\n                    &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;;\n                    &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                }\n                &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#43;&amp;#61; GetMonthDay(&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;, &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;);\n            }\n        }\n        \n        return *this;\n    }\n    &lt;span class=\"hljs-comment\"&gt;// 前置&amp;#43;&amp;#43;&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; operator&amp;#43;&amp;#43;()\n    {\n        &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;gt; GetMonthDay(&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;, &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;))\n        {\n            &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n        return *this;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 后置&amp;#43;&amp;#43;&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt; operator&amp;#43;&amp;#43;(int)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt; tmp(*this); &lt;span class=\"hljs-comment\"&gt;//用临时变量记录原实例的值 &lt;/span&gt;\n        \n        &lt;span class=\"hljs-comment\"&gt;//调整原实例的值&lt;/span&gt;\n        &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;gt; GetMonthDay(&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;, &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;))\n        {\n            &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n        }\n\n        return tmp; &lt;span class=\"hljs-comment\"&gt;//返回临时变量对象&lt;/span&gt;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// &amp;gt;运算符重载&lt;/span&gt;\n    bool operator&amp;gt;(const &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; d)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;gt; d.&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;)\n        {\n            return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#61;&amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;gt; d.&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;)\n            {\n                return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61;&amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;gt; d.&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt;)\n                {\n                    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n                }\n            }\n        }\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n\n    \n\n    &lt;span class=\"hljs-comment\"&gt;// &amp;#61;&amp;#61;运算符重载&lt;/span&gt;\n    bool operator&amp;#61;&amp;#61;(const &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; d)\n    {\n        return  ((&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;#61;&amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;) &amp;amp;&amp;amp; (&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;#61;&amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;) &amp;amp;&amp;amp; (&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;#61;&amp;#61; d.&lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt;));\n    }\n    bool operator !&amp;#61; (const &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; d)\n    {\n        return !(*this &amp;#61;&amp;#61; d);\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// &amp;lt;运算符重载&lt;/span&gt;\n    bool operator &amp;lt; (const &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt;&amp;amp; d)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (*this &amp;gt; d)\n            return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (*this &amp;#61;&amp;#61; d)\n            return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n\n    void Print()\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;-&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    int &lt;span class=\"hljs-variable\"&gt;_year&lt;/span&gt;;\n    int &lt;span class=\"hljs-variable\"&gt;_month&lt;/span&gt;;\n    int &lt;span class=\"hljs-variable\"&gt;_day&lt;/span&gt;;\n};\nint main()\n{\n    int y1, m1, dt1, y2, m2, dt2;\n    int y3, m3, dt3;\n    int day;\n    cin &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; m1 &amp;gt;&amp;gt; dt1 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; m2 &amp;gt;&amp;gt; dt2; &lt;span class=\"hljs-comment\"&gt;//第一行输入2个日期&lt;/span&gt;\n    cin &amp;gt;&amp;gt; y3 &amp;gt;&amp;gt; m3 &amp;gt;&amp;gt; dt3 &amp;gt;&amp;gt; day; &lt;span class=\"hljs-comment\"&gt;//第二行输入一个日期和1个整数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt; d(y1,m1,dt1);\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt; d1(y2,m2,dt2);\n    &lt;span class=\"hljs-built_in\"&gt;Date&lt;/span&gt; d3(y3, m3, dt3);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;#61;&amp;#61; d1) { cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Equal&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;; }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;lt; d1) { cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Less&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;; }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; { cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Greater&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;; }\n    d3  &amp;#43;&amp;#61; day;\n    d3.Print();\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载相关代码问题", ["直接给正确代码也可以的，不用看我写的代码了😢", "\n", "\n#include <iostream>\nusing namespace std;\n\n", "class", " ", "Date", "\n{\n", "public", ":\n ", "// 获取某年某月的天数", "\n int  GetMonthDay(int year, int month)\n {\n  static ", "const", " int monthday[", "13", "] = { ", "0", ",", "31", ",", "28", ",", "31", ",", "30", ",", "31", ",", "30", ",", "31", ",", "31", ",", "30", ",", "31", ",", "30", ",", "31", " };\n  ", "if", " ((month == ", "2", ") && (year % ", "4", " == ", "0", " && year % ", "100", " != ", "0", ") || (year % ", "400", " == ", "0", "))\n  {\n   ", "return", " ", "29", ";\n  }\n  ", "return", " monthday[month];\n }\n\n ", "// 全缺省的构造函数", "\n Date(int year = ", "2020", ", int month = ", "1", ", int day = ", "1", ")\n  {\n   ", "if", " (year >= ", "0", "\n    && month > ", "0", " && month < ", "13", "\n    && day>", "0", " && day <= GetMonthDay(year, month))\n   {\n    _year = year;\n    _month = month;\n    _day = day;\n   }\n   ", "else", "\n   {\n    cout << ", "\"Date invalid\"", " << endl;\n   }\n  }\n \n\n ", "// 拷贝构造函数", "\n Date(", "const", " Date& d)\n {\n  ", "this", "->_year = d._year;\n  _month = d._month;\n  _day = d._day;\n\n }\n Date& ", "operator", "=(", "const", " Date& d)\n {\n  ", "if", " (", "this", " != &d)\n  {\n   ", "this", "->_year = d._year;\n   ", "this", "->_month = d._month;\n   ", "this", "->_day = d._day;\n  }\n  ", "return", " *", "this", ";\n }\n ", "// 析构函数", "\n ~Date()\n {}\n\n ", "// 日期+=天数", "\n Date& ", "operator", "+=(int day)\n {\n  ", "if", " (day < ", "0", ")\n  {\n   ", "return", " *", "this", " -= -day;\n  }\n  _day += day;\n  ", "while", " (_day > GetMonthDay(_year, _month))\n  {\n   _day -= GetMonthDay(_year, _month);\n   _month++;\n   ", "if", " (_month == ", "13", ")\n   {\n    _year++;\n    _month = ", "1", ";\n   }\n  }\n  ", "return", " *", "this", ";\n }\n ", "// 前置++", "\n Date& ", "operator", "++()\n {\n  *", "this", " += ", "1", ";\n  ", "return", " *", "this", ";\n }\n\n ", "// 后置++", "\n Date ", "operator", "++(int)\n {\n  Date tmp(*", "this", ");\n  *", "this", " += ", "1", ";\n  ", "return", " tmp;\n }\n\n ", "// >运算符重载", "\n bool ", "operator", ">(", "const", " Date& d)\n {\n  ", "if", " (_year > d._year)\n  {\n   ", "return", " ", "true", ";\n  }\n  ", "else", " ", "if", " (_year == d._year)\n  {\n   ", "if", " (_month > d._month)\n   {\n    ", "return", " ", "true", ";\n   }\n   ", "else", " ", "if", " (_month == d._month)\n   {\n    ", "if", " (_day > d._day)\n    {\n     ", "return", " ", "true", ";\n    }\n   }\n  }\n  ", "return", " ", "false", ";\n }\n \n ", "// <运算符重载", "\n bool ", "operator", " < (", "const", " Date& d)\n {\n  ", "return", " !(*", "this", ">=d);\n }\n\n ", "// ==运算符重载", "\n bool ", "operator", "==(", "const", " Date &d)\n {\n  ", "return", "  ((_year == d._year) && (_month == d._month) && (_day == d._day));\n }\n bool ", "operator", " != (", "const", " Date &d)\n {\n  ", "return", " !(*", "this", " == d);\n }\n void Print()\n {\n  cout << _year << ", "\"-\"", " << _month << ", "\"-\"", " << _day << endl;\n }\n", "private", ":\n int _year;\n int _month;\n int _day;\n};\nint main()\n{\n Date d(", "2022", ", ", "5", ", ", "16", ");\n Date d1(", "2020", ", ", "1", ", ", "1", ");\n    ", "if", "(d==d1) {cout<<", "\"Equal\"", "<<endl;}\n    ", "else", " ", "if", "(d<d1) {cout<<", "\"Less\"", "<<endl;}\n    ", "else", " {cout<<", "\"Greater\"", "<<endl;}\n Date d2 = d + ", "1000", ";\n d2.Print();\n ", "return", " ", "0", ";\n}\n", "\n", "运算符重载的问题，想问下面的代码怎么改呀，这个日期类Date，要求：", "（1） 可以建立具有指定日期（年、月、日）的Date对象，默认日期是2020.1.1。", "（2） 可以从输出流输出一个格式为“年-月-日”的日期，其中年是四位数据，月、日可以是一位也可以是两位数据。", "（3）可以动态地设置年、月、日。", "（4）可以用运算符= =、!=、< 和 > 对两个日期进行比较。", "（5）可以用运算符 ++、+= 等完成天数的加一天或若干天的操作", "（6）Date类必须能够正确表达日期，不会出现类似于13月，32日一类的情况。Date类还必须处理闰年的问题，闰年包括：所有能被400整除的年份，以及能被4整除同时又不能被100整除的年份。", "输入格式:", "第一行包含两个日期，第二行包含一个日期和一个整数。输入日期的格式为“年 月 日”。", "输出格式:", "输出两行：", "第一行是比较输入数据第一行的两个日期，若相等，则输出“Equal”，若第一个日期小于第二个日期，则输出“Less”，若第一个日期大于第二个日期，则输出“Greater”。", "第二行是输入数据第二行的日期+=输入的整数后的日期，输出格式和题目描述中的（2）一致，也就是“年-月-日”。", "请问哪里出错了，出错了应该怎么写代码"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没有问题啊。又不修改p的值&amp;#xff0c;用不用引用都行啊&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于左移运算符重载：为什么对象前的“&”去掉后也能运行？", ["为什么写成 ostream& operator<<(ostream& cout, person p)也行啊？（学递增运算符重载时遇到的问题。）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载指针转换运算符&amp;#xff0c;需要有类型&lt;br /&gt;这里是重载&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["指针运算符重载为什么operator前面没有返回值，而且为什么是T*而不是*", ["operator T* ();", "Array::operator T* ()", "{", "    return list;", "}", "\n", "\n#pragma once\n#include <cassert>\n", "//数组类模板定义", "\ntemplate<", "class", " ", "T", ">\n", "class", " ", "Array", " {\n", "private", ":\n    T* list;", "//T型指针，用于存放动态分配的数组内存首地址", "\n    ", "int", " size;", "//数组大小（元素个数）", "\n", "public", ":\n    Array(", "int", " sz = ", "50", ");", "//构造函数", "\n    Array(", "const", " Array<T>& a);", "//复制构造函数", "\n    ~Array();", "//析构函数", "\n    Array<T>& opeator = (", "const", " Array<T>&rhs);", "//重载“=”使数组对象可以整体赋值", "\n    T& opeator[](", "int", " i);", "//重载“[ ]”，使Array对象可以起到C++普通数组的作用", "\n    ", "const", " T& operator[](", "int", " n)", "const", ";", "//“[ ]”运算符的const版本", "\n    operator T* ();", "//重载到T*类型的转换，使Array对象可以起到C++普通数组的作用", "\n    operator ", "const", " T* ()", "const", ";", "//const版", "\n    ", "int", " getSize()", "const", ";", "//取数组大小", "\n    ", "void", " resize(", "int", " sz);", "//修改数组大小", "\n\n};\n", "//构造函数", "\ntemplate<", "class", " ", "T", ">\n", "Array", "<", "T", ">::", "Array", "(", "int", " ", "sz", ") {\n    assert(sz >= ", "0", ");", "//sz为数组大小，应当非负", "\n    size = sz;", "//将元素个数赋值给变量size", "\n    list = new T[size];", "//动态分配size个T类型的元素空间", "\n}\n\n", "//析构函数", "\ntemplate<", "class", " ", "T", ">\n", "Array", "<", "T", ">::~", "Array", "()\n{\n    delete[]list;\n}\n\n", "//复制构造函数", "\ntemplate<", "class", " ", "T", ">\n", "Array", "<", "T", ">::", "Array", "(", "const", " ", "Array", "<", "T", ">& ", "a", ")\n{\n    ", "//从对象x取得数组大小，并复制给当前对象的成员", "\n    size = a.size;\n    ", "//为对象申请内存并进行出错检查", "\n    list = new T[size];", "//动态分配n个T类型的空间", "\n    ", "//从对象X复制数组元素到本对象", "\n    ", "for", " (", "int", " i = ", "0", "; i < size; i++)\n        list[i] = a.list[i];\n}\n\n", "//重载“=”运算符，将对象rhs复制给本对象，实现对象间的整体赋值、", "\ntemplate<", "class", " ", "T", ">\n", "Array", "<", "T", ">& ", "Array", "<", "T", ">::", "operator", "=(", "const", " ", "Array", "<", "T", ">& ", "rhs", ")\n{\n    ", "//如果本对象中数组大小与rhs不同。则删除数组原有内存，然后重新分配", "\n    ", "if", " (size != rhs.size)\n    {\n        delete[]list;", "//删除数组原有内存", "\n        size = rhs.size;", "//设置本对象的数组大小", "\n        list = new[size];", "//重新分配n个元素的内存", "\n    }\n    ", "//从对象X复制数组元素到本对象", "\n    ", "for", " (", "int", " i = ", "0", "; i < size; i++)\n    {\n        list[i] = rhs.list[i];\n    }\n    ", "return", " *", "this", ";\n}\n", "//重载下标运算符，实现与普通数组一样通过下标访问元素，并具有越界检查的功能", "\ntemplate<", "class", " ", "T", ">\n", "T", "& ", "Array", "<", "T", ">::", "operator", "[](", "int", " ", "n", ")", "const", "\n{\n    assert(n >= ", "0", " && n < size);\n    ", "return", " list[n];\n}\n", "//重载指针转换运算符，将Array类的对象名转换为T类型的指针，指向当前对象中的私有数组", "\n", "//因而可以像使用普通数组一样使用Array类的对象名", "\ntemplate<", "class", " ", "T", ">\n", "Array", "<", "T", ">::", "operator", " ", "T", "* ()\n{\n    ", "return", " list;\n}\n\ntemplate<", "class", " ", "T", ">\n", "Array", "<", "T", ">::", "operator", " ", "const", " ", "T", "* ()", "const", "\n{\n    ", "return", " list;\n}\n", "//取当前数组的大小", "\ntemplate<", "class", " ", "T", ">\n", "int", " ", "Array", "<", "T", ">::", "getSize", "()", "const", "\n{\n    ", "return", " size;\n}\n", "//将数组大小修改为sz", "\ntemplate<", "class", " ", "T", ">\n", "void", " ", "Array", "<", "T", ">::", "resize", "(", "int", " ", "sz", ")\n{\n    assert(sz >= ", "0", ");\n    ", "if", " (sz == size)\n    {\n        ", "return", ";\n    }\n    T* newList = new T[sz];\n    ", "int", " m = (sz < size) ? sz : size;\n    ", "//将原有数组中前n个复制到新数组中", "\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        newList[i] = list[i];\n        delete[]list;", "//删除元数组", "\n        list = newList;", "//使list指向新数组", "\n        size = sz;", "//更新size;", "\n    }\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;class Matrix\n{\n    int m_num0;\n    int m_num1;\n\npublic:\n    Matrix operator&amp;#43;&amp;#61;(Matrix &amp;amp;matrix);\n};\n\n//在资源文件里写\nMatrix Matrix::operator&amp;#43;&amp;#61;(Matrix &amp;amp;matrix) //  operator这里报错\n{\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;作用域问题&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["写运算符重载函数时出现“此运算符函数的参数太少”的报错", ["vs2019", "\n", "//创建一个类之后", "\n", "class", " ", "Matrix", "\n{\n        int m_num0;\n        int m_num1;\npublic:\n        ", "Matrix", " operator+=(", "Matrix", "& ", "matrix", ");\n}\n\n", "//在资源文件里写", "\n", "Matrix", " operator+=(", "Matrix", "& ", "matrix", ")    ", "//  operator这里报错", "\n{\n\n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;cout,MyInt A)&lt;br /&gt;改引用的话需要把它改成const MyInt&amp;amp; &amp;#xff0c;因为A&amp;#43;&amp;#43; ,返回的是临时变量不能用左值引用绑定他&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["有关C++运算符重载的几个问题", ["问题遇到的现象和发生背景 C++中的运算符重载", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "MyInt", "\n{\n    \n    ", "friend", " ostream& ", "operator", "<<(ostream &cout,MyInt A);\n    ", "friend", " ", "void", " ", "test01", "()", ";\n    \n    ", "public", ":\n        \n        MyInt& ", "operator", "++()\n        {\n            ", "this", "->m_A++;\n            ", "this", "->m_B++;\n            ", "return", " *", "this", ";\n        }\n        \n        MyInt ", "operator", "++(", "int", ")\n        {\n            MyInt temp;\n            temp.m_A=", "this", "->m_A;\n            temp.m_B=", "this", "->m_B;\n            ", "this", "->m_A++;\n            ", "this", "->m_B++;\n            ", "return", " temp;\n        }\n        \n    ", "private", ":\n        ", "int", " m_A;\n        ", "int", " m_B;\n};\n\nostream& ", "operator", "<<(ostream &cout,MyInt A)\n{\n    cout<<", "\"m_A = \"", "<<A.m_A<<endl<<", "\"m_B = \"", "<<A.m_B;\n    ", "return", " cout;\n}\n\n", "void", " ", "test01", "()", "\n", "{\n    MyInt MI1;\n    MI1.m_A=", "0", ";\n    MI1.m_B=", "0", ";\n    cout<<", "\"MI1(0,0)的++MI1:\"", "<<endl<<++MI1<<endl;\n    MyInt MI2;\n    MI2.m_A=", "0", ";\n    MI2.m_B=", "0", ";\n    cout<<", "\"MI2(0,0)的MI2++:\"", "<<endl<<MI2++<<endl;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "test01", "();\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "上面的代码可以正确运行，但是将ostream& operator<<(ostream &cout,MyInt A)改为ostream& operator<<(ostream &cout,MyInt &A)之后就会报错，cout<<\"MI2(0,0)的MI2++:\"<<endl<<MI2++<<endl;会标红。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;cin&amp;lt;&amp;lt;t;改为cin&amp;gt;&amp;gt;t;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载\"<<\"出错", ["问题遇到的现象和发生背景", "\n", "时间类运算符重载\"<<\"出错", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "\n```c++\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Time", "{\n    ", "friend", " istream & ", "operator", ">>(istream &in,Time &t)\n{\n", "int", " h,m,s;\ncin>>h>>m>>s;\nt.Hour=h;\nt.Minute=m;\nt.Second=s;\n", "return", " in;\n}\n", "friend", " ostream & ", "operator", "<<(ostream & out,Time&t)\n{\ncout<<t.Hour<<", "':'", "<<t.Minute<<", "':'", "<<t.Second<<endl;\n", "return", " out;\n}\n    ", "public", ":\n        ", "Time", "();\n        ", "Time", "(", "int", " NewH,", "int", " NewM,", "int", " NewS);\n        ", "void", " ", "ShowTime", "()", ";\n        ", "void", " ", "ShowTime", "(", "int", " i)", ";\n", "//        void SetTime(int,int,int);", "\n        Time&", "operator", "++();", "//前置++ ", "\n        ", "const", " Time ", "operator", "++(", "int", ");", "//后置++ ", "\n        Time ", "operator", ">>(Time &t);\n        ~", "Time", "(){cout<<", "\"GoodBye!\"", "<<endl;\n        }\n    ", "private", ":\n    ", "int", " Hour,Minute,Second;\n        \n};\nTime::", "Time", "(", "int", " NewH,", "int", " NewM,", "int", " NewS){Hour=NewH<", "0", "||NewH>", "23", "?", "0", ":NewH;\n    Minute=NewM<", "0", "||NewM>", "59", "?", "0", ":NewM;\n    Second=NewS<", "0", "||NewS>", "59", "?", "0", ":NewS;\n}\nTime::", "Time", "(){Hour=", "0", ";\n    Minute=", "0", ";\n    Second=", "0", ";} \n", "void", " ", "Time::ShowTime", "()", "\n", "{\n    cout<<Hour<<", "\":\"", "<<Minute<<", "\":\"", "<<Second<<endl;\n}\n", "//void Time::SetTime(int NewH,int NewM,int NewS){", "\n", "//    Hour=NewH<0||NewH>23?0:NewH;", "\n", "//    Minute=NewM<0||NewM>59?0:NewM;", "\n", "//    Second=NewS<0||NewS>59?0:NewS;", "\n", "//}", "\n\n", "void", " ", "Time::ShowTime", "(", "int", " i)", "{\n    cout<<(Hour>", "12", "?Hour", "-12", ":Hour)<<", "\":\"", "<<Minute<<", "\":\"", "<<Second;\n    cout<<(Hour>", "12", "?", "\"PM\"", ":", "\"AM\"", ")<<endl;\n}\nTime&Time::", "operator", "++()", "//前置++ ", "\n{\n    Second++;\n    ", "if", "(Second>=", "60", "){\n        Second=Second%", "60", ";\n        ++Minute;\n        ", "if", "(Minute>=", "60", "){\n        Minute=Minute%", "60", "; \n        ++Hour;    \n        }\n}\n    ", "return", " *", "this", ";\n}\n", "const", " Time Time::", "operator", "++(", "int", "){\n    Time t=*", "this", ";\n    Second+=", "1", ";\n    ", "if", "(Second>", "60", "){\n        Second=Second%", "60", ";\n        ++Minute;\n        ", "if", "(Minute>=", "60", "){\n        Minute=Minute%", "60", "; \n        ++Hour;    \n        }\n    }\n\n}\n\n", "int", " ", "main", "()", "{\n    Time myTime,t;\n", "//    myTime.SetTime(8,30,30);", "\n", "//    myTime.ShowTime();", "\n", "//    myTime.SetTime(20,29,59);", "\n", "//    myTime.ShowTime();", "\n", "//    ++myTime;", "\n", "//    myTime.ShowTime();", "\n", "//    myTime++;", "\n    cin<<t;\n    cout<<myTime;\n    \n    ", "return", " ", "0", ";\n}\n\n", "\n", "\n![img](https:", "//img", "-mid.csdnimg.cn", "/release/", "static", "/image/mi", "d", "/ask/", "576858745766164", ".png ", "\"#left\"", ")\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在类外定义类成员函数&amp;#xff0c;首先必须在类中有函数声明&amp;#xff0c;其次需要加上作用域&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Person&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Person&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n1, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n2):&lt;span class=\"hljs-built_in\"&gt;m_A&lt;/span&gt;(n1),&lt;span class=\"hljs-built_in\"&gt;m_B&lt;/span&gt;(n2){};\n    Person &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Person&amp;amp; p1);&lt;span class=\"hljs-comment\"&gt;//声明重载函数作为类成员函数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m_A;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m_B;\n};\n\nPerson Person::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Person&amp;amp; p1) &lt;span class=\"hljs-comment\"&gt;//类外定义重载函数&lt;/span&gt;\n{\n    &lt;span class=\"hljs-function\"&gt;Person &lt;span class=\"hljs-title\"&gt;temp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    temp.m_A &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_A &amp;#43; p1.m_A;\n    temp.m_B &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_B &amp;#43; p1.m_B;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Person &lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)&lt;/span&gt;,&lt;span class=\"hljs-title\"&gt;p1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++中，如何在类的外面使用【作用域】进行类方法的运算符重载，代码如下", ["问题遇到的现象和发生背景", "\n", "主要是想到了如果是用类的方法进行运算符重载", "\n", "问题相关代码，请勿粘贴截图", "\n", "class Person", "{", "public:", "    Person(int n1, int n2) : m_A(n1),m_B(n2){};", "    Person PersonAddPerson(Person &p1);", "    int m_A;", "    int m_B;", "};", "\n", "Person operator+(Person& p1)", "{", "    Person temp(0, 0);", "    temp.m_A = this->m_A + p1.m_A;   //代码在this处报错，错误提示：【this只能用于非静态成员内部】", "    temp.m_B = this->m_B + p1.m_B;", "    return temp;", "}", "\n", "运行结果及报错内容", "\n", "【this只能用于非静态成员内部】", "\n", "我的解答思路和尝试过的方法", "\n", "无", "\n", "我想要达到的结果", "\n", "我想要达到的效果是可以在类外使用作用域进行申明，不知道是否可行，希望能有带佬帮助"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载为友元函数&amp;#xff0c;注意分清ostream和istream&lt;/p&gt;\n\n&lt;p&gt;class RationalNumber {&lt;!-- --&gt;&lt;br /&gt;\nprivate:&lt;br /&gt;\n    int numerator;    // 分子&lt;br /&gt;\n    int denominator;  // 分母&lt;br /&gt;\npublic:&lt;br /&gt;\n    // 列表初始化[初值列]&lt;br /&gt;\n    RationalNumber();&lt;br /&gt;\n    RationalNumber(int, int);&lt;br /&gt;\n    void reSet(int, int);              // 有理数重赋值&lt;br /&gt;\n    void print();                      // 输出函数    &lt;br /&gt;\n    int getNumerator()&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        return numerator;&lt;br /&gt;\n    }&lt;br /&gt;\n    int getDenominator()&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        return denominator;&lt;br /&gt;\n    }&lt;br /&gt;\n    // 重载输入运算符1&lt;br /&gt;\n    friend istream&amp;amp; operator &amp;gt;&amp;gt; (istream&amp;amp; in, RationalNumber&amp;amp; x)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        in &amp;gt;&amp;gt; x.numerator &amp;gt;&amp;gt; x.denominator;&lt;br /&gt;\n        return in;&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;    // 重载输入运算符2&lt;br /&gt;\n    friend  ostream&amp;amp; operator &amp;lt;&amp;lt; (ostream&amp;amp; out, RationalNumber&amp;amp; x)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        out &amp;lt;&amp;lt; x.getNumerator() &amp;lt;&amp;lt; x.getDenominator();&lt;br /&gt;\n        return out;&lt;br /&gt;\n    }&lt;br /&gt;\n};&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++运算符重载  类型不匹配问题", ["\n", "// 重载输入运算符1\nistream& operator >> (istream& in, RationalNumber& x)\n{\n\tin >> x.numerator >> x.denominator;\n\treturn in;\n}\n\n\n// 重载输入运算符2\nistream& operator >> (istream& in, RationalNumber& x)\n{\n\tin >> x.getNumerator() >> x.getDenominator();\n\treturn in;\n}", "\n\n", "\n", "// 有理数类\nclass RationalNumber {\nprivate:\n\tint numerator;    // 分子\n\tint denominator;  // 分母\npublic:\n\t// 列表初始化[初值列]\n\tRationalNumber();\n\tRationalNumber(int , int);\n\tvoid reSet(int, int);              // 有理数重赋值\n\tvoid print();                      // 输出函数\t\n\tint getNumerator() \n\t{\n\t\treturn numerator;\n\t}\n\tint getDenominator() \n\t{\n\t\treturn denominator;\n\t}\n}；", "\n\n", "----------------------------------------------------------------------------------------------------", "\n\n", "\n\n", "--------------------------------------------------------------------------------------------------", "\n\n", "\n\n", "如题VS2017：", "\n\n", "输入运算符1可以匹配但是输入运算符2不能匹配，这是什么原因呢，，，", "\n\n", "int &_Val 又是什么意思呢，，，"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;string&amp;gt;\n#include&amp;lt;cmath&amp;gt;\n#include&amp;#34;Complex1.h&amp;#34;\nusing namespace std;\n\nComplex::Complex(double real&amp;#61;0,double imag&amp;#61;0){\n    re&amp;#61;real;im&amp;#61;imag;\n}\nComplex::Complex(const Complex&amp;amp; orig){\n    re&amp;#61;orig.re;im&amp;#61;orig.im;\n}\nComplex&amp;amp; Complex::operator&amp;#61;(const Complex&amp;amp; arg){\n    re&amp;#61;arg.re;im&amp;#61;arg.im;\n    return *this;\n}\nComplex Complex::operator&amp;#43;(const Complex&amp;amp; arg){\n    Complex tmp;\n    tmp.re&amp;#61;re&amp;#43;arg.re;tmp.im&amp;#61;im&amp;#43;arg.im;\n    return  tmp;\n}\nComplex Complex::operator-(const Complex&amp;amp; arg){\n    Complex tmp;\n    tmp.re&amp;#61;re-arg.re;tmp.im&amp;#61;im-arg.im;\n    return  tmp;\n}\nComplex Complex::operator*(const Complex&amp;amp; arg){\n    Complex tmp;\n    tmp.re&amp;#61;re*arg.re-im*arg.im; //这里实部、虚部都是减吗&amp;#xff1f;\n    tmp.im&amp;#61;re*arg.im-arg.re*im;\n    return  tmp;\n}\nComplex Complex::operator/(const Complex&amp;amp; arg){\n    Complex tmp;\n    tmp.re&amp;#61;(re*arg.re&amp;#43;im*arg.im)/(arg.re*arg.re&amp;#43;arg.im*arg.im);\n    tmp.im&amp;#61;(im*arg.re-re*arg.im)/(arg.re*arg.re&amp;#43;arg.im*arg.im);\n    return  tmp;\n}\nComplex&amp;amp; Complex::operator&amp;#43;&amp;#61;(const Complex&amp;amp; arg){\n    re&amp;#43;&amp;#61;arg.re;im&amp;#43;&amp;#61;arg.im;\n    return *this;\n}\nComplex Complex::operator-&amp;#61;(const Complex&amp;amp; arg){\n    re-&amp;#61;arg.re;im-&amp;#61;arg.im;\n    return *this;\n}\nComplex Complex::operator*&amp;#61;(const Complex&amp;amp; arg){\n    re&amp;#61;re*arg.re-im*arg.im;\n    im&amp;#61;re*arg.im-arg.re*im;\n    return *this;\n}\nComplex Complex::operator/&amp;#61;(const Complex&amp;amp; arg){\n    re&amp;#61;(re*arg.re&amp;#43;im*arg.im)/(arg.re*arg.re&amp;#43;arg.im*arg.im);\n    im&amp;#61;(im*arg.re-re*arg.im)/(arg.re*arg.re&amp;#43;arg.im*arg.im);\n    return *this;\n}\nbool Complex::operator&amp;#61;&amp;#61;(const Complex&amp;amp; arg){\n    return (re&amp;#61;&amp;#61;arg.re)&amp;amp;&amp;amp;(im&amp;#61;&amp;#61;arg.im);//(im&amp;#61;&amp;#61;arg.re);\n}\nbool Complex::operator!&amp;#61;(const Complex&amp;amp; arg){\n    return (re!&amp;#61;arg.re)||(im!&amp;#61;arg.im);//(im!&amp;#61;arg.re);\n}\ndouble Complex::moduls(){\n    return sqrt(re*re&amp;#43;im*im);\n}\nComplex::string str(){\n    stringstream ss;\n    ss&amp;lt;&amp;lt;re&amp;lt;&amp;lt;&amp;#34;&amp;#43;&amp;#34;&amp;lt;&amp;lt;im&amp;lt;&amp;lt;&amp;#34;i&amp;#34;;\n    return ss.str;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++请问下面的代码错在哪里，有关运算符重载", ["代码是想通过运算符重载实现复数的运算，报错了，大概是operator+, operator-那里的问题，但我不知道怎么改。（省去了头文件）", "\n\n", "\n", "#include<iostream>\n#include<string>\n#include<cmath>\n#include\"Complex1.h\"\nusing namespace std;\n\nComplex::Complex(double real=0,double imag=0){\n    re=real;im=imag;\n}\nComplex::Complex(const Complex& orig){\n    re=orig.re;im=orig.im;\n}\nComplex& Complex::operator=(const Complex& arg){\n    re=arg.re;im=arg.im;\n    return *this;\n}\nComplex Complex::operator+(const Complex& arg){\n    re+=arg.re;im+=arg.im;\n    return re,im;\n}\nComplex Complex::operator-(const Complex& arg){\n    re-=arg.re;im-=arg.im;\n    return re,im;\n}\nComplex Complex::operator*(const Complex& arg){\n    re=re*arg.re-im*arg.im;\n    im=re*arg.im-arg.re*im;\n    return re,im;\n}\nComplex Complex::operator/(const Complex& arg){\n    re=(re*arg.re+im*arg.im)/(arg.re*arg.re+arg.im*arg.im);\n    im=(im*arg.re-re*arg.im)/(arg.re*arg.re+arg.im*arg.im);\n    return re,im;\n}\nComplex& Complex::operator+=(const Complex& arg){\n    re+=arg.re;im+=arg.im;\n    return *this;\n}\nComplex Complex::operator-=(const Complex& arg){\n    re-=arg.re;im-=arg.im;\n    return *this;\n}\nComplex Complex::operator*=(const Complex& arg){\n    re=re*arg.re-im*arg.im;\n    im=re*arg.im-arg.re*im;\n    return *this;\n}\nComplex Complex::operator/=(const Complex& arg){\n    re=(re*arg.re+im*arg.im)/(arg.re*arg.re+arg.im*arg.im);\n    im=(im*arg.re-re*arg.im)/(arg.re*arg.re+arg.im*arg.im);\n    return *this;\n}\nbool Complex::operator==(const Complex& arg){\n    return (re==arg.re)&&(im==arg.re);\n}\nbool Complex::operator!=(const Complex& arg){\n    return (re!=arg.re)||(im!=arg.re);\n}\ndouble Complex::moduls(){\n    return sqrt(re*re+im*im);\n}\nComplex::string str(){\n    stringstream ss;\n    ss<<re<<\"+\"<<im<<\"i\";\n    return ss.str;\n}"]], "Tag": "程序设计"}
{"Answer": "friend ostream&amp; operator&lt;&lt;(ostream &amp; stream, const Magic &amp;c)\r\n{\r\nstream &lt;&lt; c.x;\r\nreturn stream;\r\n}", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载的问题，请问大佬如何对<<运算符重载函数，希望能有注释", ["#include ", "\n#include ", "\nusing namespace std;", "\nclass Magic {", "\n         double x; ", "\n         public:", "\n            Magic(double d = 0.00) :x(fabs(d)) {}//fabs是cmath头文件的函数，求绝对值的", "\n            Magic operator+(const Magic&c) { return Magic(sqrt(x*x + c.x*c.x)); }//sqrt是求平方根", "\n            friend ostream& operator<<(ostream & stream, const Magic &c);//函数需要你来实现，输出对象的数据成员值", "\n};", "\nint main()", "\n{", "\n         Magic ma;", "\n         cout << ma << \", \" << Magic(2) << \", \" << Magic(-6) + Magic(-8) << endl;//构造函数（实参）——创建无名对象", "\n         return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "```\r\n选择A\r\n有几个操作数就是几元\r\n一元：\r\n!a\r\n&amp;a\r\n*a\r\na++\r\n++a\r\n...\r\n二元\r\na == b\r\na = b\r\na += b\r\na &amp;&amp; b\r\na * b\r\n...\r\n三元\r\na ? b : c\r\n\r\nB的错误在于，=不能是一元的。\r\n*作为指针运算可以是一元，作为乘法，又可以是二元，所以是唯一正确的。\r\n```\r\n# 问题解决的话，请点下采纳", "Konwledge_Point": "运算符重载", "Question": ["问一道有关运算符重载的概念性问题", ["\n\n", "书上说”*“", "\n这个运算符是不能重载的", "\n说是为了保证成员功能不能被改变，答案是A，就很疑惑.....求大佬解答......顺便问一下“=”为什么不能重载为二元的，我的想法是operator=（类型A a，类型A b){a.成员1=b.成员1；a.成员2=b.成员2；....}这样重载为友元不就是2元嘛......感谢大佬(。＿ 。） ✎＿"]], "Tag": "程序设计"}
{"Answer": "第一次构造：num i；\n第二次构造：num=i++；重载了++运算符，在里面num  temp时\n第三次复制构造：return  temp；\n这三次都调用了析构函数", "Konwledge_Point": "运算符重载", "Question": ["关于C++后置运算符重载一个超简单问题", ["以下代码", "\n#include ", "\nusing namespace std;", "\nclass num", "\n{", "\npublic:", "\n    num(){n=1;cout<<\"构造函数执行\\n\";}", "\n    num(int i){n=i;cout<<\"带一个参数的构造函数执行\\n\";}", "\n    num(const num&s){this->n=s.n;cout<<\"复制构造函数执行\\n\";}", "\n    ~num(){cout<<\"析构函数执行\\n\";}", "\n    int get()const{return n;}", "\n    void set(int x){n=x;}", "\n    void add(){++n;}", "\n\n", "const num operator++(int o)\n{\n    num temp(*this);\n    ++n;\n    return temp;\n}\n", "\n\n", "private:", "\n    int n;", "\n};", "\nint main()", "\n{", "\n    num i;", "\n    cout<<\"i:\"<<i.get()<<endl;", "\n    i.add();", "\n    cout<<\"i:\"<<i.get()<<endl;", "\n    num n=i++;", "\n    cout<<\"i:\"<<i.get()<<endl;", "\n    cout<<\"n:\"<<n.get()<<endl;", "\n    return 0;", "\n}", "\n\n", "运行后显示", "\n\n", "构造函数执行", "\ni:1", "\ni:2", "\n复制构造函数执行", "\n复制构造函数执行", "\n析构函数执行", "\ni:3", "\nn:2", "\n析构函数执行", "\n析构函数执行", "\n\n", "请问为什么要执行两次复制构造函数 复制构造的都是什么？", "\n还有请问依次析构的三个对象是什么？", "\n谢谢！！"]], "Tag": "程序设计"}
{"Answer": "参考：http://blog.csdn.net/wangfengwf/article/details/11580653\r\n如果要完整代码，请先采纳本回答。", "Konwledge_Point": "运算符重载", "Question": ["C++ 编程  运算符重载", ["编写一个Customer类，包括账号、密码、姓名、余额（初始为0）。", "\n用两种方法重载运算符“-”，使得两个Customer对象相减，能得到它们余额之差。", "\n请发送到邮箱  ", "liangxiaoqi_c@163.com", ",谢谢啦"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对于你代码里&lt;code class=\"language-javascript\"&gt;MyInteger&lt;/code&gt;类的友元函数&lt;code class=\"language-javascript\"&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;第二个参数可以传值&amp;#xff0c;也可以传&lt;code class=\"language-javascript\"&gt;const&lt;/code&gt;引用。&lt;br /&gt;当类的大小能被一个寄存器装下&amp;#xff0c;那么传值可能比传引用更合适&amp;#xff0c;因为编译器可能直接用寄存器传递该类的对象&amp;#xff0c;而不用取地址间接传递&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载时引用问题", ["c++在重载后置递增/递减运算符的时候，前面先重载的左移运算符，重载左移运算符的第二个值为什么要给它值传递，不可以给引用呀？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"126\" src=\"https://img-ask.csdnimg.cn/upload/1624003552487.png\" width=\"350\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;帮助到你能点个&lt;u&gt;&lt;strong&gt;采纳&lt;/strong&gt;&lt;/u&gt;吗&amp;#xff0c;谢谢~&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;using System;\nnamespace ConsoleApp1\n{\n    class MyTime\n    {\n        public int Hour { get; set; }\n        public int Minute { get; set; }\n        public int Second { get; set; }\n        public MyTime(int Hour, int Minute, int Second)\n        {\n            this.Hour &amp;#61; Hour;\n            this.Minute &amp;#61; Minute;\n            this.Second &amp;#61; Second;\n        }\n        public static bool operator &amp;#61;&amp;#61;(MyTime t1,MyTime t2)\n        {\n            return t1.Hour &amp;#61;&amp;#61; t2.Hour &amp;amp;&amp;amp; t1.Minute &amp;#61;&amp;#61; t2.Minute &amp;amp;&amp;amp; t1.Second &amp;#61;&amp;#61; t2.Second;\n        }\n        public static bool operator !&amp;#61;(MyTime t1,MyTime t2)\n        {\n            return t1.Hour !&amp;#61; t2.Hour || t1.Minute !&amp;#61; t2.Minute || t1.Second !&amp;#61; t2.Second;\n        }\n        public static MyTime operator &amp;#43;(MyTime t, int Second)\n        {\n            MyTime t1 &amp;#61; new MyTime(t.Hour, t.Minute, t.Second);\n            t1.Second &amp;#43;&amp;#61; Second;\n            if (t1.Second &amp;gt; 59)\n            {\n                t1.Second -&amp;#61; 60; \n                t1.Minute &amp;#43;&amp;#61; 1;\n                if (t1.Minute &amp;gt; 59)\n                {\n                    t1.Minute -&amp;#61; 60;\n                    t1.Hour &amp;#43;&amp;#61; 1;\n                    if (t1.Hour &amp;gt; 23) t1.Hour &amp;#61; 0;\n                }\n\n            }\n            return t1;\n        }\n        public static MyTime operator &amp;#43;&amp;#43;(MyTime t)\n        {\n            MyTime t1 &amp;#61; t &amp;#43; 1;\n            return t1 ;\n        }\n        public void Show()\n        {\n            Console.WriteLine(Hour &amp;#43; &amp;#34;:&amp;#34; &amp;#43; Minute &amp;#43; &amp;#34;:&amp;#34; &amp;#43; Second);\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MyTime t1 &amp;#61; new MyTime(12, 8, 50), t2, t3;\n            t2 &amp;#61; new MyTime(12, 9, 0);\n            if (t1 &amp;#61;&amp;#61; t2) Console.WriteLine(&amp;#34;时间相同&amp;#34;);\n            else Console.WriteLine(&amp;#34;时间不同&amp;#34;);\n            t3 &amp;#61; t1 &amp;#43; 12;\n            t3.Show();\n            t3 &amp;#61; &amp;#43;&amp;#43;t2;\n            t3.Show();\n            t3 &amp;#61; t2&amp;#43;&amp;#43;;\n            t3.Show();\n            Console.ReadKey();\n        }\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C#控制台应用程序（运算符重载）", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "额，路过看到了，说一下你的错误原因，内存申请的太小，然后又越界使用了 ，最后在释放的时候就出问题了， 改的话...你自己改改看吧 ， 不行就等其他人来帮你整了", "Konwledge_Point": "运算符重载", "Question": ["运算符重载之后，析构函数报错，怎么改？顺便说一下原因，谢谢", [" class String\n{\npublic:\n\n    String(const char* a=NULL);\n    String(const String&a);\n    ~String();\n    void operator=(const char* a);\n    void operator=(String &a);\n    String operator+(const char* a);\n    String operator+(String a);\n    void operator<(const char* a);\n    void operator<(String a);\n    void operator>(const char* a);\n    void operator>(String a);\n    void print();\n\nprivate:\n    char *m_str;\n};\n\nString String::operator+(const char* a)\n {\n    String c;\n    c.m_str = new char[strlen(a) + strlen(m_str) + 1];\n    int i = 0;\n    for (; i < strlen(m_str); i++)\n    {\n        c.m_str[i] = m_str[i];\n    }\n    for (int t = 0; t < strlen(a); t++)\n    {\n        c.m_str[i] = a[t];\n    }\n\n    return c;\n }\n\nString String::operator+(String a)\n {\n    String c;\n    c.m_str = new char[strlen(a.m_str) + strlen(m_str) + 1];\n    int i = 0;\n    for (; i < strlen(m_str); i++)\n    {\n        c.m_str[i] = m_str[i];\n    }\n\n    for (int t = 0; t <=strlen(a.m_str); t++,i++)\n    {\n        c.m_str[i] = a.m_str[t];\n    }\n\n\n    return c;\n }\n\n void String::operator<(const char* a)\n {\n\n }\n\n void String::operator<(String a)\n {\n\n }\n\n void String::operator>(const char* a)\n {\n\n }\n\n void String::operator>(String a)\n {\n\n }\n\n\n String::String(const char* a)\n {\n     if (a == NULL)\n     {\n         m_str = new char[1];\n         m_str[0] = '\\0';\n     }\n     else\n     {\n         int b = strlen(a);\n         m_str = new char[b+1 ];\n         strcpy_s(m_str,b+1,a);\n     }\n }\n\n String::String(const String&a)\n {\n     int b = strlen(a.m_str);\n     m_str = new char[b + 1];\n     strcpy_s(m_str, b + 1, a.m_str);\n }\n\n String::~String()\n {\n     printf(\"析构%s\",this->m_str);\n     delete[]m_str;\n     m_str = NULL;\n }\n\n void String::operator=(const char* a)\n {\n     int b = strlen(a);\n     m_str = new char[b + 1];\n     strcpy_s(m_str, b + 1, a);\n }\n\n void String::operator=(String& a)\n {\n     int b = strlen(a.m_str);\n     m_str = new char[b + 1];\n     strcpy_s(m_str, b + 1, a.m_str);\n }\n\n\nvoid String::print()\n{\n    cout<<m_str<<endl;\n}\n\nint main()\n{\n    String s1 = \"abc\";\n    String s2 (\"def\");\n    String s3 =s1;\n    String s4 = s1+s3;\n\n\n    s1.print();\n    s2.print();\n    s3.print();\n    s4.print();\n\n    return 0;\n}\n", "\n\n", "String s4 = s1+s3;这一行会调用析构函数，释放内存的时候会弹出系统的debug窗口!", "图片说明"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是不是因为你最后多输出了换行符&amp;#xff0c;另外如果输出是整数的话&amp;#xff0c;分母不应该再输出了&lt;br /&gt;修改之后&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt; \n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;iostream&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; gcd(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a,&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b){return b?gcd(b,a%b):a;}\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Fenshu\n{\n    public:\n        &lt;span class=\"hljs-constructor\"&gt;Fenshu(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;:fenzi(a),fenmu(b){\n        }\n        Fenshu operator&amp;#43;(Fenshu&amp;amp; F2)\n        {\n            Fenshu temp&amp;#61;*this;\n           temp.fenmu&amp;#61;fenmu*&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F2&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu;\n            temp.fenzi&amp;#61;fenmu*&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F2&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi&amp;#43;fenzi*&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F2&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu;\n            &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; g&amp;#61;gcd(temp.fenmu,temp.fenzi);\n            temp.fenmu/&amp;#61;g; temp.fenzi/&amp;#61;g;\n            return temp;\n        }\n        friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp;,Fenshu&amp;amp;);\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; fenzi;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; fenmu;\n        \n};\nostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; os,Fenshu&amp;amp; F)\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; gong&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;lt;&amp;#61;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi%i&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu%i&amp;#61;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        gong&amp;#61;i;\n    }\n    &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi&amp;#61;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi/gong;\n    &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu&amp;#61;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu/gong;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi%&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        os&amp;lt;&amp;lt;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenmu;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n     os&amp;lt;&amp;lt;&lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;F&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;fenzi;\n    return os;\n    \n}\n \n \n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a,b;\ncin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\nFenshu &lt;span class=\"hljs-constructor\"&gt;F1(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;;\ncin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;\nFenshu &lt;span class=\"hljs-constructor\"&gt;F2(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;)&lt;/span&gt;;\nFenshu F3&amp;#61;F1&amp;#43;F2;\ncout&amp;lt;&amp;lt;F3;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["pta 运算符重载(c++)", ["请定义一个分数类，拥有两个整数的私有数据成员，分别表示分子和分母（分母永远为正数，符号通过分子表示）。", "重载运算符加号\"+\"，实现两个分数的相加，所得结果必须是最简分数。", "\n", "输入:", "第一行的两个数 分别表示 第一个分数的分子和分母（分母不为0）。 第二行的两个数 分别表示 第二个分数的分子和分母。", "\n", "输出:", "第一个数表示分子，第二个数表示分母（若分数代表的是整数，则不输出分母）。", "\n", "输入样例:", "\n", "1 ", " ", "5", "\n", "2 ", " ", "5", "\n", "\n", "输出样例:", "\n", "3 ", "5", "\n", "\n", "我的答案：", "\n", "#include<iostream>", "\nusing namespace std;\nclass Fenshu\n{\n    public:\n        Fenshu(int a,int b):fenzi(a),fenmu(b){\n        }\n        friend Fenshu operator+(Fenshu&,Fenshu&);\n        friend ostream& operator<<(ostream&,Fenshu&);\n    private:\n        int fenzi;\n        int fenmu;\n        \n};\nFenshu operator+(Fenshu& a,Fenshu& b)\n{\n    ", "if", "(a.", "fenmu", "==b.fenmu)\n    {\n        a.fenzi+=b.fenzi;\n        a.", "fenmu", "=a.fenmu;\n    }\n    ", "else", "\n    {\n        a.", "fenzi", "=a.fenzi*b.fenmu+b.fenzi*a.fenmu;\n        a.", "fenmu", "=a.fenmu*b.fenmu;\n    }\n    return a;\n}\nostream& operator<<(ostream& os,Fenshu& F)\n{\n    int ", "i", "=1;\n    int ", "gong", "=1;\n    ", "if", "(F.", "fenzi", "==0)\n    {\n        os<<0;\n    }\n    ", "else", "{\n    \n    ", "if", "(F.fenzi<F.fenmu)\n    {\n    \n    ", "for", "(", "i", "=1;i<=F.fenzi;i++)\n    {\n        ", "if", "(F.fenzi%", "i", "==0&&F.fenmu%i==0)\n        ", "gong", "=i;\n    }\n    F.", "fenzi", "=F.fenzi/gong;\n    F.", "fenmu", "=F.fenmu/gong;\n    ", "if", "(F.", "fenmu", "==1)\n    {\n        os<<F.fenzi;\n    }\n    ", "else", " os<<F.fenzi<<", "\" \"", "<<F.fenmu;\n    }\n    ", "else", " ", "if", "(F.fenzi>F.fenmu)\n    {\n    ", "for", "(", "i", "=1;i<=F.fenmu;i++)\n    {\n        ", "if", "(F.fenzi%", "i", "==0&&F.fenmu%i==0)\n        ", "gong", "=i;\n    }\n    F.", "fenzi", "=F.fenzi/gong;\n    F.", "fenmu", "=F.fenmu/gong;    \n     ", "if", "(F.", "fenmu", "==1)\n    {\n        os<<F.fenzi;\n    }\n    ", "else", " os<<F.fenzi<<", "\" \"", "<<F.fenmu;\n    }\n    ", "else", "\n    {\n        os<<1;\n    }\n}\n    return os;\n    \n}\n \n \nint main()\n{\nint a,b;\ncin>>a>>b;\nFenshu F1(a,b);\ncin>>a>>b;\nFenshu F2(a,b);\nFenshu ", "F3", "=F1+F2;\ncout<<F3<<endl;\n    return 0;\n}\n\n", "\n", "遇到的问题：", "\n", "在pta中出错：", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Well, first, your code sample doesn't seem to accurately reflect the problem you described in prose, so I'll begin by ignoring it for the moment and writing code more similar to what you actually described:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"syscall\"\n\n    \"golang.org/x/sys/unix\"\n)\n\nfunc main() {\n    src := syscall.Timespec{3, 4}\n    dst := unix.Timespec(src)\n\n    fmt.Printf(\"%v is a %s\n\", dst, reflect.TypeOf(dst))\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;We're just doing a simple type conversion, which works because the fields in both structs have exactly the same names and types.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;{3 4} is a unix.Timespec\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://golang.org/pkg/syscall/#Timespec\" rel=\"nofollow noreferrer\"&gt;syscall.Timespec&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Timespec struct {\n        Sec  int64\n        Nsec int64\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://godoc.org/golang.org/x/sys/unix#Timespec\" rel=\"nofollow noreferrer\"&gt;unix.Timespec&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Timespec struct {\n    Sec  int64\n    Nsec int64\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can copy these with a simple type conversion because the structs are exactly the same and the fields are exported.&lt;/p&gt;\n\n&lt;p&gt;Note that you can do this in cgo, but not in gccgo, which rejects the type conversion. The &lt;a href=\"https://golang.org/ref/spec#Conversions\" rel=\"nofollow noreferrer\"&gt;language specification&lt;/a&gt; states that this type conversion should work (as the structs have identical underlying types).&lt;/p&gt;\n\n&lt;p&gt;The obvious workaround is to deep copy the struct yourself, something like:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    dst := unix.Timespec{src.Sec, src.Nsec}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;But this doesn't work because gccgo complains:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;# command-line-arguments\n./x.go:13:29: error: incompatible type for field 1 in struct construction (cannot use type syscall.Timespec_sec_t as type int64)\n     dst := unix.Timespec{src.Sec, src.Nsec}\n                             ^\n./x.go:13:38: error: incompatible type for field 2 in struct construction (cannot use type syscall.Timespec_nsec_t as type int64)\n     dst := unix.Timespec{src.Sec, src.Nsec}\n                                      ^\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So we see the root of the problem is that gccgo's &lt;code&gt;syscall.Timespec&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; identical to &lt;code&gt;unix.Timespec&lt;/code&gt;, and it's not even identical to the &lt;code&gt;syscall.Timespec&lt;/code&gt; in the cgo standard library.&lt;/p&gt;\n\n&lt;p&gt;You're &lt;a href=\"https://github.com/golang/go/issues/23078\" rel=\"nofollow noreferrer\"&gt;not the first person&lt;/a&gt; to run into this issue either. Unfortunately that issue was closed without an obvious workaround that would work for you. Your best bet, of course, is to rewrite the offending code to &lt;em&gt;not&lt;/em&gt; use the syscall package. Or stop using gccgo.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The example code you posted in your question is a bit different. In this case the fields have &lt;em&gt;different&lt;/em&gt; types. Go doesn't really care that &lt;code&gt;aliased_int&lt;/code&gt; is \"actually\" an &lt;code&gt;int&lt;/code&gt; underneath. It treats them as separate types, because in Go the predeclared numeric types are also considered defined types, and thus you can't use a simple type conversion here. The spec indicates under what circumstances type conversions are allowed, and this doesn't appear to fall into any of them.&lt;/p&gt;\n\n&lt;p&gt;You'll have to do a deep copy yourself. There are numerous Go libraries to help with doing deep copies of structs.&lt;/p&gt;\n\n&lt;p&gt;The other problem in this code is that the struct fields are unexported. You can't really deep copy them at all. If you exported the fields, then you could.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "运算符重载", "Question": ["类型转换运算符重载作为'GO'中的全局函数", ["\n\n", "What I would like to do is as follows. I have an application code (say, MyApp), one package (perhaps) from a third party, and the other from gccgo. They are particularly golang.org/sys/unix and syscall, respectively.", "\n\n", "MyApp tries to assign a syscall.Timespec variable to an unix.Timespec variable. That is mismatch when I use syscall from gccgo while it is not when the syscall is from Gc. ", "\n\n", "I would like to avoid changing the two libraries. I would like to make a change to MyApp. However, the patch will not go to the upstream of MyApp. I, or my employer, should maintain the patch locally. That says if the git repo of MyApp is updated, we would need to pull it again and apply another patch to it. ", "\n\n", "In that sense, I would like to try to minimize the efforts for the future maintenance. ", "\n\n", "The mismatch itself is as follows, if I simplify:", "\n\n", "// example.go\npackage main\n\nimport \"fmt\"\n\ntype aliased_int int\n\ntype SrcStruct struct {\n    x aliased_int\n}\n\ntype DstStruct struct {\n    x int\n}\n\nfunc main() {\n    src := SrcStruct{x: 30}\n    dst := DstStruct(src)\n    fmt.Println(dst.x)\n}\n", "\n\n", "The code above caused a compile error due to the \"x aliased_int\" line. If it were \"x int,\" the code is compiled successfully. ", "\n\n", "If this were a C++ application and libraries, I would define a type-casting operator overloading from SrcStruct to DstStruct. (%p.s. this won't work because C++ does not allow type-casting operator overloading as a global function. However, I wanted to know such a solution is available in Go.)", "\n\n", "I am not sure if I could do the same in Go. (i.e. defining a custom type-casting operator as a global function or so) If not, what is the best for this situation when it comes to Go programming?", "\n\n", "%P.S.", "\n\n", "Michael Hampton kindly pointed out that gccgo's Timespec is different from Google Go compiler, Gc's Timespec. The difference is, however, gccgo uses an alias to int64 such as Timespec_sec_t or Timespec_nsec_t. ", "\n\n", "Gccgo's Timespec is defined in Gccgo's package. Gc's Timespec is included in MyApp's source tree. MyApp assumes that Timespec is the same as Gc defined. I would like only touch MyApp code minimally. ", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这个字体真难看&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;函数第二个参数不能是左值引用&amp;#xff0c;否则的话&amp;#xff0c;后缀&amp;#43;&amp;#43;返回的是右值&amp;#xff08;临时变量&amp;#xff09;&amp;#xff0c;而左值引用无法绑定右值。你可以把第二个参数修改为下面两种形式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; MyInteger&amp;amp;); &lt;span class=\"hljs-comment\"&gt;// 常量引用&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;, MyInteger); &lt;span class=\"hljs-comment\"&gt;// 传值&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载使用bug", ["\n", "\n", "这个重载里的代码明白咋回事，++放前面，放后面。编译器怎么理解翻译的就一头雾水。看哪个视频或者书籍会容易懂些呀。"]], "Tag": "程序设计"}
{"Answer": "![事实证明结果的确就是3啊图片说明](https://img-ask.csdn.net/upload/201604/30/1462017921_308692.jpg)\r\n\r\n还有，你的代码里three.get都没有“()”，真的能运行通不报错吗？", "Konwledge_Point": "运算符重载", "Question": ["关于C++加法运算符重载的一个超简单问题", ["以下代码：", "\n#include ", "\nusing namespace std;", "\nclass num", "\n{", "\npublic:", "\n    num(){n=1;cout<<\"构造函数执行\\n\";}", "\n    num(int i){n=i;cout<<\"带一个参数的构造函数执行\\n\";}", "\n    num(const num&s){this->n=s.n;cout<<\"复制构造函数执行\\n\";}", "\n    ~num(){cout<<\"析构函数执行\\n\";}", "\n    int get()const{return n;}", "\n    void set(int x){n=x;}", "\n    const num operator+(const num&r){return num(n+r.get());}", "\n\n", "private:", "\n    int n;", "\n};", "\nint main()", "\n{", "\n    num one(1),two(2),three;", "\n    three=one+two;", "\n    cout<<\"one:\"<<one.get()<<endl;", "\n    cout<<\"two:\"<<two.get()<<endl;", "\n    cout<<\"three:\"<<three.get<<endl;", "\n    return 0;", "\n\n", "}", "\n\n", "运行后three的结果我希望是3 ", "\n但程序返回的是1 ", "\n请问问题出在哪里？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;知道了&amp;#xff0c;是因为调用运算符重载函数时&amp;#xff0c;自动的对person p进行了浅拷贝&amp;#xff0c;复制了地址&amp;#xff0c;因此后续清除指针时对堆区的同一块区域进行了多次清除&amp;#xff0c;因此报错。所以哪怕换成别的函数&amp;#xff0c;只要浅拷贝存在就会报错。person p改成person &amp;amp;p得以解决&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["添加运算符重载导致断点", ["这段代码正常运行", "\n", "\n", "这段代码却报错", "\n", "\n", "后面这段代码只是用左移重载输出p的属性就出现断点（但是程序已经运行到输出两个对象的属性了）这是为什么，感谢赐教！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;单步类的实例“构造”或“复制”或“作为函数参数”或“作为函数返回值返回”或“参加各种运算”或“退出作用域”的语句对应的汇编代码几步后&amp;#xff0c;就会来到该类的“构造函数”或“复制构造函数”或“运算符重载”或“析构函数”对应的C/C&amp;#43;&amp;#43;源代码处。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载相关疑问", ["\n", "//全局", "\n", "friend", " Complex ", "operator", "+(", "const", " Complex &c1, ", "const", " Complex &c2);\n", "//成员", "\nComplex & ", "operator", "+(", "const", " Complex &c);\n\n", "\n", "对于成员函数形式的重载 “+” ，", "为什么b = a + 1.1 是正确的 而对于b = 2.2 + a确是错误的呢？", " int型不能和complex型运算，那为什么b=a+1.1却没问题呢？不是应该都是错误的吗？麻烦各位看看，谢谢！！"]], "Tag": "程序设计"}
{"Answer": "其实操作符重载一般的原则是不改变该操作符原有的语义，因此比如a += b中，假设a和b都是int类型， += 操作符干的事情就是将b的值加到a上，也就相当于a = a + b; 那么将a, b换成point对象之后，对应的，+=操作符应该将b中所有的成员变量加到a中对应的成员变量上。代码中所写的point operator +=(point &amp;p);其实是在 a += p;（其中a, p均为point类的实例）的时候进行调用的，x += p.x;和y += p.y其实就是把p的x值加到a的x值上，把p的y值加到a的y值上。", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载。。。。。。", ["class point", "\n{", "\nprivate:", "\n                int  x,y;", "\npublic:", "\n                point operator +=(point &p);", "\n};", "\npoint point::operator +=(point &p)", "\n{", "\n                x+=p.x;    //这里", "\n                y+=p.y;", "\n                return *this;", "\n}", "\n\n", "这里的x+=p.x;和y+=p.y;  怎么理解啊"]], "Tag": "程序设计"}
{"Answer": "先计算最大公约数和最小公倍数，剩下的都是数学问题了吧~", "Konwledge_Point": "运算符重载", "Question": ["一个c++运算符重载问题，希望得到完整代码", ["题目如下：", "\n已知一个有理数类zrf_Ratio,包含私有数据成员：分子num和分母den, 以及公有函数成员", "\n\n", "friend ostream& operator<<(ostream& ostr, const zrf_Ratio& r)\n\n{ return ostr << r.num << \"/\" << r.den;}\n", "\n\n", "请补充该类的构造函数，并实现如下的操作符重载形式：", "\n\n", "friend zrf_Ratio operator-(const zrf_Ratio&);\n\nfriend zrf_Ratio operator+(const zrf_Ratio&, const zrf_Ratio&);\n\nfriend zrf_Ratio operator-(const zrf_Ratio&, const zrf_Ratio&);\n\nfriend zrf_Ratio operator*(const zrf_Ratio&, const zrf_Ratio&);\n\nfriend zrf_Ratio operator/(const zrf_Ratio&, const zrf_Ratio&);\n"]], "Tag": "程序设计"}
{"Answer": "&lt;blockquote&gt;\n&lt;p&gt;核心&amp;#xff1a;代码其实走了默认生成的拷贝构造函数&amp;#xff0c;由于都是基本类型 int 之类的数据&amp;#xff0c;正常运行  &lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;望点击我回答右上角【采纳】按钮支持一下  &lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;你的代码里面&amp;#xff0c;连续两次调用&amp;#xff0c;第二次调用其实也变化了&amp;#xff0c;只是变化的那个是临时变量&amp;#xff0c;不是你的对象本身&lt;/p&gt;\n&lt;p&gt;改动如下&amp;#xff0c;你返回 引用 即可确保每次改动对象本身&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;    Average&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#61;(int x)\n    {\n        sum &amp;#43;&amp;#61; x;\n        n&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/585285720556111.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Average&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sum;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Average&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) :&lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;(x), &lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;(y) {};\n\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Average &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Average&amp;amp; avg1, Average&amp;amp; avg2)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; { avg1.sum &amp;#43; avg2.sum,avg1.n &amp;#43; avg2.n };&lt;span class=\"hljs-comment\"&gt;//返回时自动初始化&lt;/span&gt;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; out, Average&amp;amp; avg)\n    {\n        out &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;&amp;gt;(avg.sum) / &lt;span class=\"hljs-built_in\"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;&amp;gt;(avg.n);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; out;\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;Average&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Average&amp;amp; copy) :&lt;span class=\"hljs-built_in\"&gt;sum&lt;/span&gt;(copy.sum), &lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;(copy.n)\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;调用赋值构造函数&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n\n    Average&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#61;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)\n    {\n        sum &amp;#43;&amp;#61; x;\n        n&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n};\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* argv[])&lt;/span&gt; \n&lt;/span&gt;{\n    Average avg{};\n\n    avg &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; avg &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 4 / 1 &amp;#61; 4&lt;/span&gt;\n\n    avg &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; avg &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n\n    avg &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; avg &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n\n    avg &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;-10&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; avg &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n\n    (avg &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;) &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 2 calls chained together&lt;/span&gt;\n    std::cout &amp;lt;&amp;lt; avg &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n\n    Average copy{ avg };\n    std::cout &amp;lt;&amp;lt; copy &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于c++运算符重载疑问", ["\n", " visual studio 2019版本，c++20", "\n", "\n", "类文件", "\n", "class", " ", "Average", " {\n    ", "int", " sum;\n    ", "int", " n;\n\n", "public", ":\n    ", "Average", "(", "int", " x=", "0", ",", "int", " y=", "0", "):", "sum", "(x),", "n", "(y) {};\n    ", "friend", " Average ", "operator", "+(Average &avg1, Average &avg2);", "//重载加法", "\n    ", "friend", " std::ostream& ", "operator", "<<(std::ostream &out,Average &avg);", "//重载输出符号<<", "\n    ", "Average", "(", "const", " Average& copy) :", "sum", "(copy.sum), ", "n", "(copy.n) {\n        cout << ", "\"调用赋值构造函数\"", "<<endl;\n    }\n    Average ", "operator", "+=(", "int", " x) {\n        sum += x;\n        n++;\n        ", "return", " *", "this", ";\n    }\n};\n\nAverage ", "operator", "+(Average& avg1, Average& avg2) {\n    ", "return", " { avg1.sum + avg2.sum,avg1.n + avg2.n };", "//返回时自动初始化", "\n}\n\nstd::ostream& ", "operator", "<<(std::ostream& out, Average& avg) {\n    out<< ", "static_cast", "<", "float", ">(avg.sum) / ", "static_cast", "<", "float", ">(avg.n);\n    ", "return", " out;\n}\n", "\n", "主函数", "\n", "\nint main(int argc, char* argv[]) {\n    Average", " avg", "{};\n\n   ", " avg", " += ", "4", ";\n    std::cout <<", " avg", " << ", "'\\n'", "; // ", "4", " / ", "1", " = ", "4", "\n\n   ", " avg", " += ", "8", ";\n    std::cout <<", " avg", " << ", "'\\n'", "; \n\n   ", " avg", " += ", "24", ";\n    std::cout <<", " avg", " << ", "'\\n'", "; \n\n   ", " avg", " += -", "10", ";\n    std::cout <<", " avg", " << ", "'\\n'", ";\n\n    ", "(avg", " += ", "6", ") += ", "10", "; // ", "2", " calls chained together\n    std::cout <<", " avg", " << ", "'\\n'", "; \n\n    Average ", "copy", "{", " avg", " };\n    std::cout << ", "copy", " << ", "'\\n'", ";\n\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果", "\n", "调用赋值构造函数", "4", "调用赋值构造函数", "6", "调用赋值构造函数", "12", "调用赋值构造函数", "6.5", "调用赋值构造函数", "调用赋值构造函数", "6.4（这里结果应该是7）", "调用赋值构造函数", "6.4", "\n", "调试", "\n", "调试时候发现连续两个+=号过程中没有出错，但是后面一个*this的值没有返回", "\n", "\n", "\n", "后面两个为7"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;2&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;;\nnamespace ConsoleApp2\n{\n    &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Point&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; X { &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;; &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt;; }\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Y { &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;; &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt;; }\n    }\n    &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Circle&lt;/span&gt; : &lt;span class=\"hljs-type\"&gt;Point&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; R { &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;;&lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt;;}\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; Area()\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; Math.PI * Math.Pow(R, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n        }\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; Length()\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; * Math.PI * R;\n        }\n\n    }\n    &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;Global&lt;/span&gt; : &lt;span class=\"hljs-type\"&gt;Circle&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; Volume()\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; / &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;) * Math.PI * Math.Pow(R, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n        }\n        &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; Area()\n        {\n\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;*Math.PI * Math.Pow(R, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Program\n    {\n        static &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Main(string[] args)\n        {\n            var c &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;Circle&lt;/span&gt; { R &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; };\n            Console.WriteLine(c.Area());\n            var g &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;Global&lt;/span&gt; { R &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; };\n            Console.WriteLine(g.Area());\n            Console.WriteLine(g.Volume());\n            Console.ReadLine();\n        }\n    }\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["继承多态以及运算符重载", ["2.点类到圆到球体的派送如何进行", "3.抽象方法如何实现", "4.数组对于不同类型对象如何统一存储"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你后置重载25行那里返回的是一个新的对象&amp;#xff0c;所以有一次--操作是对那个新对象。39行你原始的mint其实就是减了一次&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++基础问题，运算符重载", ["\n", "\n", "\n```c++\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Myint", "\n{\n", "public", ":\n    ", "friend", " ostream&", "operator", "<<(ostream &cout, Myint mint);\n    ", "Myint", "()\n    {\n        m_H = ", "8", ";\n    }\n    ", "//前置重载", "\n    Myint& ", "operator", "--()\n    {\n        --m_H;\n        ", "return", "*", "this", ";\n    }\n    ", "//后置重载", "\n    Myint ", "operator", "--(", "int", ")\n    {\n        Myint temp=*", "this", ";\n        m_H--;\n        ", "return", " temp;\n    }\n\n", "private", ":\n    ", "int", " m_H;\n};\nostream&", "operator", "<<(ostream &cout, Myint min)\n{\n    cout << min.m_H;\n    ", "return", " cout;\n}\n", "void", " ", "test01", "()", "\n", "{\n    Myint mint;\n    cout <<(mint--)--<< endl;", "//为什么我的结果是（8，7，6）不应该是（8，6，5）吗，两次自减只用了一次，为什么", "\n    cout << mint-- << endl;\n    cout << mint-- << endl;\n\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "test01", "();\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n", "\n", "\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;横线处是构造函数&amp;#xff0c;初始化类变量时会被调用。&lt;br /&gt;加粗的内容是属于初始化列表的语法。_x(x)的小括号里面的x代码你传入的参数&amp;#xff0c;_x就是类的成员变量了。就是把你传入参数的值赋值给对应的成员变量。&lt;br /&gt;而float x&amp;#61;0,float y&amp;#61;0就是指初始化默认值&amp;#xff0c;你如果不传值就执行这个值。&lt;br /&gt;你看我的代码&amp;#xff0c;初始化了两个类变量&amp;#xff0c;a我没传值&amp;#xff0c;x、y就都是0&amp;#xff0c;b我给了两个参数&amp;#xff0c;那么x、y就是我传入的参数的值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Complex&lt;/span&gt; {\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) : &lt;span class=\"hljs-built_in\"&gt;x&lt;/span&gt;(x), &lt;span class=\"hljs-built_in\"&gt;y&lt;/span&gt;(y) {}\n    ~&lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;() {}\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;PrintData&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n        std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;x &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;x &amp;lt;&amp;lt; std::endl\n                  &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;y &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;y &amp;lt;&amp;lt; std::endl;\n    }\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{\n    Complex a;\n    a.&lt;span class=\"hljs-built_in\"&gt;PrintData&lt;/span&gt;();\n    Complex b{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;};\n    b.&lt;span class=\"hljs-built_in\"&gt;PrintData&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++单目运算符重载", ["\n", "请问画红横线的是什么作用，还有为什么可以使用Complex(float x=0,float y=0)    ", ":_x(x)，_y(y)", " 为什么可以这样使用加粗的内容。初学者望解答。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;endl是换行啊&amp;#xff0c;跟着cout输出才可以&amp;#xff0c;你写的那个是跟在函数后面&amp;#xff0c;不符合语法要求&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++运算符重载endl不能写？", ["C++重载运算符“/”，使两个复数相除。", "但去掉主函数中的endl才能正常运行，查了相关资料还是没明白，请问这是为什么呢？", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Complex", "\n{\n    ", "public", ":\n        ", "Complex", "(", "float", " x=", "0", ",", "float", " y=", "0", "){real=x;imag=y;}\n        Complex ", "operator", "/(Complex &c2);\n        ", "void", " ", "display", "()", "\n        ", "{\n            ", "if", " (imag>", "0", ")\n            cout<<real<<", "'+'", "<<imag<<", "'i'", "<<endl;\n            ", "else", "\n            cout<<real<<imag<<", "'i'", "<<endl;\n        }\n    ", "private", ":\n        ", "float", " real;\n        ", "float", " imag;        \n};\n\nComplex Complex::", "operator", "/(Complex &c2)\n\n{\n    Complex c;\n    c.real=(real*c2.real-imag*c2.imag)/(c2.real*c2.real-c2.imag*c2.imag);\n    c.imag=(real*c2.imag+c2.real*imag)/(c2.real*c2.real-c2.imag*c2.imag);\n    ", "return", " c;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "Complex ", "complex1", "(", "1", ",", "2", ")", ",", "complex2", "(", "3", ",", "4", ")", ",complex", ";\n    cout<<", "\"complex1=\"", "; complex1.", "display", "();\n    cout<<", "\"complex2=\"", "; complex2.", "display", "();\n    complex=complex1/complex2;\n    cout<<", "\"complex=\"", ";complex.", "display", "()<<endl;\n    ", "return", " ", "0", ";\n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;基于new BIng的回答&amp;#xff1a;&lt;br /&gt;你好&amp;#xff0c;你的代码中重载了前缀自增和自减运算符&amp;#xff0c;但没有重载后缀自增和自减运算符。在C&amp;#43;&amp;#43;中&amp;#xff0c;后缀自增和自减运算符需要一个额外的int参数来区分它们与前缀运算符。例如&amp;#xff0c;你可以这样定义后缀自增运算符&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Calculator::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;){\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;value&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;value&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-number\"&gt;65535&lt;/span&gt;)&lt;span class=\"hljs-keyword\"&gt;value&lt;/span&gt;&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n        cout&amp;lt;&amp;lt;&amp;#34;Date overflow&amp;#34;&amp;lt;&amp;lt;endl;\n        &lt;span class=\"hljs-keyword\"&gt;abort&lt;/span&gt;();\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;temp&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同理&amp;#xff0c;你也可以定义后缀自减运算符。希望这对你有帮助。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++中的运算符重载问题", ["c++中我想重载运算符++和--，然后我设立了一个类，之后在主函数中为什么a++会报错，而++a就可以通过呢？emm或者是我没理解运算符重载吧", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Calculator", "{\n    ", "private", ":\n        ", "int", " value;\n    ", "public", ":\n        ", "Calculator", "(){value=", "0", ";}\n        ", "int", " ", "operator", "--();\n        ", "int", " ", "operator", "++();\n        ", "int", " ", "operator", "()", "()", ";\n};\n", "int", " ", "Calculator::operator", "()", "()", "{\n    ", "return", " value;\n}\n", "int", " Calculator::", "operator", "++(){\n    ", "if", "(value<", "65535", ")value++;\n    ", "else", "{\n        cout<<", "\"Date overflow\"", "<<endl;\n        ", "abort", "();\n    }\n}\n", "int", " Calculator::", "operator", "--(){\n    ", "if", "(value>", "0", ")value--;\n    ", "else", "{\n        cout<<", "\"Date overflow\"", "<<endl;\n        ", "abort", "();\n    }\n}\n", "int", " ", "main", "()", "{\n    ", "int", " i=", "0", ";\n    Calculator a;\n    ", "for", "(i=", "0", ";i<", "5", ";i++){\n        a++;\n        cout<<", "\"A=\"", "<<", "a", "()<<endl;\n    }\n    ", "for", "(i=", "0", ";i<=", "5", ";i++){\n        --a;\n        cout<<", "\"A=\"", "<<", "a", "()<<endl;\n    }\n}\n\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;类已经是模板类了&amp;#xff0c;成员函数不用再套一层模板&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++（）运算符重载加类模板", ["\n", "使用a(x,y)，返回a[x][y],这里我把二维数组当一维数组在类里面处理应该没问题，是格式什么不对吗，main里面显示找不到对应（）运算符"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有两种改法&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;&lt;p&gt;参数用常量引用&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;Cmycomplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;);\n&lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Cmycomplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;, Cmycomplex &amp;amp;); \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;参数不使用引用&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;Cmycomplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Cmycomplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;, Cmycomplex &amp;amp;); \n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;另外Show函数前面需要加个void&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["复数类运算符重载，复数加整数计算问题", ["不知道为什么main函数中的2+z4一直报错，但是main函数是给定的不能改，有人知道怎么改吗，感谢", "\n", "//友元函数计算2+z", "\n#", "include", "<iostream>\nusing namespace std;\n\n", "class", " Cmycomplex\n{\npublic:\n    ", "Cmycomplex(", "double", " ", "a", "=0,", "double", " ", "b", "=0)", ";", "//缺省构造函数 ", "\n    void ", "Set(", "double", ", ", "double", ")", ";\n    ", "Show()", ";\n    Cmycomplex operator+(", "int", "&);\n    Cmycomplex operator+(Cmycomplex &);", "//声明运算符+ 重载函数 ", "\n    friend Cmycomplex operator+(", "int", " &, Cmycomplex &); \n", "private", ":\n    double real;", "//复数实部 ", "\n    double imag;", "//复数虚部 ", "\n};\n\nCmycomplex::", "Cmycomplex(", "double", " ", "a", ", ", "double", " ", "b", ")", "\n{\n    real = a;\n    imag = b;\n}\n\nvoid Cmycomplex::", "Set(", "double", " ", "a", ", ", "double", " ", "b", ")", "\n{\n    real = a;\n    imag = b;\n}\n\nCmycomplex Cmycomplex :: operator+(Cmycomplex &c2)\n{\n   return ", "Cmycomplex(", "real", "+", "c2", ".", "real", ",", "imag", "+", "c2", ".", "imag", ")", ";\n}\n\nCmycomplex Cmycomplex::operator+(", "int", "&i)\n{\n  return ", "Cmycomplex(", "real", "+", "i", ",", "imag", ")", ";\n}\n\n\nCmycomplex operator+(", "int", " &m, Cmycomplex &n)\n{\n    return ", "Cmycomplex(", "m", "+", "n", ".", "real", ",", "n", ".", "imag", ")", ";\n}\nCmycomplex::", "Show()", "\n{\n    ", "if", " (imag >= ", "0", ") cout << ", "'('", " <<  real << ", "'+'", "  << imag << ", "'i'", " << ", "')'", ";\n    ", "if", " (imag < ", "0", ") cout << ", "'('", " <<  real << ", "\"-\"", " << imag << ", "'i'", " << ", "')'", ";\n}\n", "//StudybarCommentBegin", "\n", "int", " main", "()", "\n{\n    Cmycomplex z1(", "3", ",", "4", "),z2(", "7", "),z3,z4(z1);\n    double x,y;\n    cin>>x>>y;\n    z3.", "Set(", "x", ",", "y", ")", ";\n    cout<<endl;\n    z3=z3+z2;\n    z3.", "Show()", ";\n    ", "//int i=2;", "\n    z4=", "2", "+z4;\n    cout<<endl;\n    z4.", "Show()", ";\n    z4=z4+", "2", ";\n    cout<<endl;\n    z4.", "Show()", ";\n\n} \n", "//StudybarCommentEnd ", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;complex&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; image;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;complex&lt;/span&gt;(){}\n        &lt;span class=\"hljs-built_in\"&gt;complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; image){\n            &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real&amp;#61;real;\n            &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image&amp;#61;image;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setReal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;{\n            real&amp;#61;value;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setImage&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;{\n            image&amp;#61;value;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getReal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;&lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; real;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getImage&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;&lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; image;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;display&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n            cout&amp;lt;&amp;lt;real&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;image&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        }\n        \n        complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; complex &amp;amp;a)&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;{\n            complex b;\n            b.&lt;span class=\"hljs-built_in\"&gt;setReal&lt;/span&gt;(real&amp;#43;a.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;());\n            b.&lt;span class=\"hljs-built_in\"&gt;setImage&lt;/span&gt;(image&amp;#43;a.&lt;span class=\"hljs-built_in\"&gt;getImage&lt;/span&gt;());\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; b;\n        }\n        complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;amp;a)&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;{\n            complex b;\n            b.&lt;span class=\"hljs-built_in\"&gt;setReal&lt;/span&gt;(real&amp;#43;a);\n            b.&lt;span class=\"hljs-built_in\"&gt;setImage&lt;/span&gt;(image);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; b;\n        }\n        &lt;span class=\"hljs-comment\"&gt;//定义非成员函数operator&amp;#43;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; complex &amp;amp;b);\n};\ncomplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; complex &amp;amp;b){\n    complex c;\n    c.&lt;span class=\"hljs-built_in\"&gt;setReal&lt;/span&gt;(a&amp;#43;b.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;());\n    c.&lt;span class=\"hljs-built_in\"&gt;setImage&lt;/span&gt;(b.&lt;span class=\"hljs-built_in\"&gt;getImage&lt;/span&gt;());\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;complex &lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    complex c;\n    complex d;\n    c&amp;#61;a&amp;#43;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    c.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n    d&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;&amp;#43;a;\n    d.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/037698005456199.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;可以参考&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["多项式乘法需要用到运算符重载", ["#include ", "#include", "using namespace std;", "const int MAX_POLY = 20;", "int p[MAX_POLY], q[MAX_POLY], s[MAX_POLY * 2];", "int n1, n2;", "class Polynomial;", "\n", "class Polynomial{//多项式类", "\n", "public:", "    Polynomial();", "   void mulit_input();", "    void mulit_poly(int p[], int n1, int q[], int n2, int s[]);//添加一项,若有相同的指数项，则合并", "   void mulit_output();", "};", "\n", "void mulit_poly(int p[], int n1, int q[], int n2, int s[]) {", "    for (int i = 0; i < n1 + n2; i++) {", "        s[i] = 0;", "    }", "    for (int i = 0; i < n1; i++) {", "        for (int j = 0; j < n2; j++) {", "            s[i + j] += p[i] * q[j];", "        }", "    }", "}", "void mulit_input(){", "    cout << \"输入第一个多项式的个数：\";", "    cin >> n1;", "    cout << \"输入第二个多项式的个数：\";", "    cin >> n2;//输入第一行的个数", "    cout << \"输入第一个多项式的系数：\";", "    for (int i = n1 - 1; i >= 0; i--) {", "\n", "    cin >> p[i];", "//", "为第一列系数\n}\ncout << ", "\"P(x)= \"", ";\nbool first = true;\n", "for", " (int i = n1 + n2 - ", "1", "; i >= ", "0", "; i--) {", "//", "输出多项式\n    ", "if", " (p[i] != ", "0", ") {\n        ", "if", " (!first)", "//", "如果不是第一个\n            cout << ", "\"+\"", ";", "//", "输出+\n        cout << p[i];", "//", "输出第i项\n        ", "if", " (i != ", "0", ")", "//", "如果i不等于", "0", "输x^\n            cout << ", "\"x^\"", " << i;\n       first=false;\n    }\n}\ncout << ", "\"\\n\"", ";\ncout << ", "\"输入第二个多项式的系数：\"", " ;\n", "for", " (int i = n2 - ", "1", "; i >= ", "0", "; i--) {\n    \ncin >> q[i];", "//", "为第二列系数\n\n}\ncout << ", "\"Q(x)= \"", " ;\n", "\n", "   for (int i = n1 + n2 - 1; i >= 0; i--) {//输出多项式", "        if (q[i] != 0) {", "            if (!first)//如果不是第一个", "                cout << \"+\";//输出+", "            cout << q[i];//输出第i项", "            if (i != 0)//如果i不等于0输x^", "                cout << \"x^\" << i;", "             first=false;", "        }", "\n", "}\n", "\n", "   cout <<\"\\n\";", "}", "\n", "void mulit_output(){", "cout << \"输出两个多项式相乘的值\";", "cout << \"S(x)= \";", " bool first = true;", "    for (int i = n1 + n2 - 1; i >= 0; i--) {//输出多项式", "        if (s[i] != 0) {", "            if (!first)//如果不是第一个", "                cout << \"+\";//输出+", "            cout << s[i];//输出第i项", "            if (i != 0)//如果i不等于0输x^", "                cout << \"x^\" << i;", "            first = false;", "        }", "    }", "}", "int main()", "{", "\n", "mulit", "_input()", ";", "//输入", "\nmulit", "_poly(", "p", ", ", "n1", ", ", "q", ", ", "n2", ", ", "s", ")", ";", "//调用多项式函数", "\nmulit", "_output()", ";", "//输出", "\n", "\n", "}", "该如何修改呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#43;运算符重载&amp;#xff0c;返回值不用引用的时候是正确的&amp;#xff0c;用引用反而是错误的。&lt;br /&gt;用引用的时候&amp;#xff0c;返回的变量是在重载运算符函数中声明的临时变量的引用&amp;#xff0c;但是这个变量出了函数后&amp;#xff0c;就被系统回收了。所以返回得到的就是一个被回收了的变量&amp;#xff0c;这个变量的值是不确定的。所以&amp;#xff0c;结果就是错误的。&lt;/p&gt;\n&lt;p&gt;下面是不用引用的时候的VS2008运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/893342550246154.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;下面是用引用的时候的运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/518651550246114.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["运算符重载时多个对象相加的问题", ["问题遇到的现象和发生背景", "\n", "两个对象相加没有问题，多个对象相加会报错", "\n", "问题相关代码，请勿粘贴截图", "\n", "// 全局函数重载+\nPerson operator+(Person& q, Person& p)\n{\n    Person temp;\n    temp.height = q.height + p.height;\n    temp.weight = q.weight + p.weight;\n   ", " return ", "temp;\n}\n", "\nint ", "main()\n{\n    Person p1(10, 10);    \n    Person p2(20, 20);    \n    Person p3(30, 30);    \n    Person p4(40, 40);    \n    Person p5(50, 50);    \n\n    cout << (p1 + p2 + p3 + p4 + p5).height << endl;    \n    cout << (p1 + p2 + p3 + p4 + p5).weight << endl;\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "返回引用输出错误", "\n", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给你一个重载的例子&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;complex&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; image;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;complex&lt;/span&gt;(){}\n        &lt;span class=\"hljs-built_in\"&gt;complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; image){\n            &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real&amp;#61;real;\n            &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image&amp;#61;image;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setReal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;{\n            real&amp;#61;value;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setImage&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; value)&lt;/span&gt;&lt;/span&gt;{\n            image&amp;#61;value;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getReal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; real;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getImage&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; image;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;display&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n            cout&amp;lt;&amp;lt;real&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;image&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        }\n        &lt;span class=\"hljs-function\"&gt;complex &lt;span class=\"hljs-title\"&gt;add&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; complex &amp;amp;a)&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;&lt;/span&gt;{\n            complex b;\n            b.&lt;span class=\"hljs-built_in\"&gt;setReal&lt;/span&gt;(real&amp;#43;a.&lt;span class=\"hljs-built_in\"&gt;getReal&lt;/span&gt;());\n            b.&lt;span class=\"hljs-built_in\"&gt;setImage&lt;/span&gt;(image&amp;#43;a.&lt;span class=\"hljs-built_in\"&gt;getImage&lt;/span&gt;());\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; b;\n        }\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;complex &lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;complex &lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    complex c;\n    c&amp;#61;a.&lt;span class=\"hljs-built_in\"&gt;add&lt;/span&gt;(b);\n    c.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["运算符重载利用到多项式乘法中", ["#include ", "#include", "using namespace std;", "const int MAX_POLY = 20;", "int p[MAX_POLY], q[MAX_POLY], s[MAX_POLY * 2];", "int n1, n2;", "class Polynomial;", "\n", "class Polynomial{//多项式类", "\n", "public:", "    Polynomial();", "   void mulit_input();", "    void mulit_poly(int p[], int n1, int q[], int n2, int s[]);//添加一项,若有相同的指数项，则合并", "   void mulit_output();", "};", "\n", "void mulit_poly(int p[], int n1, int q[], int n2, int s[]) {", "    for (int i = 0; i < n1 + n2; i++) {", "        s[i] = 0;", "    }", "    for (int i = 0; i < n1; i++) {", "        for (int j = 0; j < n2; j++) {", "            s[i + j] += p[i] * q[j];", "        }", "    }", "}", "void mulit_input(){", "    cout << \"输入第一个多项式的个数：\";", "    cin >> n1;", "    cout << \"输入第二个多项式的个数：\";", "    cin >> n2;//输入第一行的个数", "    cout << \"输入第一个多项式的系数：\";", "    for (int i = n1 - 1; i >= 0; i--) {", "\n", "    cin >> p[i];", "//", "为第一列系数\n}\ncout << ", "\"P(x)= \"", ";\nbool first = true;\n", "for", " (int i = n1 + n2 - ", "1", "; i >= ", "0", "; i--) {", "//", "输出多项式\n    ", "if", " (p[i] != ", "0", ") {\n        ", "if", " (!first)", "//", "如果不是第一个\n            cout << ", "\"+\"", ";", "//", "输出+\n        cout << p[i];", "//", "输出第i项\n        ", "if", " (i != ", "0", ")", "//", "如果i不等于", "0", "输x^\n            cout << ", "\"x^\"", " << i;\n       first=false;\n    }\n}\ncout << ", "\"\\n\"", ";\ncout << ", "\"输入第二个多项式的系数：\"", " ;\n", "for", " (int i = n2 - ", "1", "; i >= ", "0", "; i--) {\n    \ncin >> q[i];", "//", "为第二列系数\n\n}\ncout << ", "\"Q(x)= \"", " ;\n", "\n", "   for (int i = n1 + n2 - 1; i >= 0; i--) {//输出多项式", "        if (q[i] != 0) {", "            if (!first)//如果不是第一个", "                cout << \"+\";//输出+", "            cout << q[i];//输出第i项", "            if (i != 0)//如果i不等于0输x^", "                cout << \"x^\" << i;", "             first=false;", "        }", "\n", "}\n", "\n", "   cout <<\"\\n\";", "}", "\n", "void mulit_output(){", "cout << \"输出两个多项式相乘的值\";", "cout << \"S(x)= \";", " bool first = true;", "    for (int i = n1 + n2 - 1; i >= 0; i--) {//输出多项式", "        if (s[i] != 0) {", "            if (!first)//如果不是第一个", "                cout << \"+\";//输出+", "            cout << s[i];//输出第i项", "            if (i != 0)//如果i不等于0输x^", "                cout << \"x^\" << i;", "            first = false;", "        }", "    }", "}", "int main()", "{", "\n", "mulit", "_input()", ";", "//输入", "\nmulit", "_poly(", "p", ", ", "n1", ", ", "q", ", ", "n2", ", ", "s", ")", ";", "//调用多项式函数", "\nmulit", "_output()", ";", "//输出", "\n", "\n", "}该如何修改"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;后置&amp;#43;&amp;#43;改成下面的&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;my &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --(int)\n    {\n        my temp ;\n        temp.m_num &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_num;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_num--; &lt;span class=\"hljs-comment\"&gt;//这里本类的要--&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp; &lt;span class=\"hljs-comment\"&gt;//返回的是原来的值&lt;/span&gt;\n    }\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/709040349746127.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;完整代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;my&lt;/span&gt; \n{\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; cout, my myint);\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;my&lt;/span&gt;() {\n        m_num &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    my&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --()\n    {\n        m_num--;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    my &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)\n    {\n        my temp ;\n        temp.m_num &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_num;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_num--; &lt;span class=\"hljs-comment\"&gt;//这里本类的要--&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp; &lt;span class=\"hljs-comment\"&gt;//返回的是原来的值&lt;/span&gt;\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m_num;\n};\n\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; cout, my myint)\n{\n    cout &amp;lt;&amp;lt; myint.m_num;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cout;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;test01&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    my myint;\n    cout &amp;lt;&amp;lt; --(--myint) &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; myint &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;test02&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    my youint;\n    cout &amp;lt;&amp;lt; youint-- &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; youint &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//test01();&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;test02&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++递减运算符重载出现的问题", ["图上的未经处理的异常是怎么回事?之前有人说是<<那的第二个&要去掉，可是明显不行，那样cout会因为局部不能进行两次－－.帮忙解答一下这里的问题到底是什么呢谢谢！", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为在类内定义运算符重载的时&amp;#xff0c;运算符第一个操作数是类对象本身&amp;#xff08;通过this指针传递&amp;#xff09;&amp;#xff0c;而传入的参数是运算符的第二个操作数。&lt;br /&gt;在类外定义运算重载时&amp;#xff0c;需要同时把两个操作数作为参数传入。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["运算符重载的问题（C++）", ["为什么在类内声明的时候可以写成operater+(const &lhs),而在类外的时候就要写成operater+(const &rhs,const &lhs)?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#43;号运算符的操作数为2&amp;#xff0c;你在Manager里面重载的这个实际上有3个参数&amp;#xff0c;有一个隐形的参数是this&amp;#xff0c;操作数为3&amp;#xff0c;所以会有问题。你要么在Point内部重载只有一个参数的成员函数&amp;#xff0c;要么重载一个两个参数的非成员函数&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["成员运算符重载函数，把注释的代码还原回来编译就通不过，为什么，如何解决？", ["\n", "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nclass Point;\n\nclass Manager\n{\npublic:\n    void Myprint(const Point & another);\n    //Point operator +(Point & a,Point & b)；\n};\n\n\nclass Point\n{\n    friend void Manager::Myprint(const Point & another);\n    //friend Point Manager::operator +(Point & a,Point & b);\npublic:\n    Point(int a=1,int b=2)\n        :m_x(a),m_y(b)\n    {\n\n    }\n\n    void func()\n    {\n        cout << \"(\" << this->m_x << \",\" << this->m_y << \")\" << endl;\n    }\n\nprivate:\n    int m_x;\n    int m_y;\n};\n\n\n\nvoid Manager::Myprint(const Point & another)\n{\n    cout << \"Myprint():(\" << another.m_x << \",\" << another.m_y << \")\" << endl;\n}\n\n//Point Manager::operator +(Point & a,Point & b)\n//{\n//    a.m_x += b.m_x;\n//    a.m_y += b.m_y;\n//    return a;\n//}\n\n\n\n\nint main()\n{\n   Point p1(3,4);\n   Manager m;\n   m.Myprint(p1);\n\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是把a和b中不重复的元素合并到一个容器中吗&amp;#xff1f;感觉逻辑不对啊&amp;#xff0c;Queue自身的数据在第一个while循环中已经全部弹出了&amp;#xff0c;在第二个while循环中本队列中已经没有数据了。代码修改如下&amp;#xff1a;&amp;#xff08;如果不行的话&amp;#xff0c;建议你把全部代码用代码段贴出来&amp;#xff0c;帮你修改一下&amp;#xff0c;只有这些代码没法调试&amp;#xff09;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;template &amp;lt;typename &lt;span class=\"hljs-keyword\"&gt;type&lt;/span&gt;&amp;gt;\n&lt;span class=\"hljs-built_in\"&gt;Queue&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Queue&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;::operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-built_in\"&gt;Queue&lt;/span&gt; obj)\n{\n    &lt;span class=\"hljs-built_in\"&gt;Queue&lt;/span&gt; ans,tt;\n    int flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//是否存在标记&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;type&lt;/span&gt; temp,&lt;span class=\"hljs-built_in\"&gt;data&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(!obj.isEmpty())\n    {\n        temp &amp;#61; obj.front();\n        obj.pop();\n        &lt;span class=\"hljs-comment\"&gt;//判断temp是否在本队列中&lt;/span&gt;\n        flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(!isEmpty())\n        {\n            &lt;span class=\"hljs-built_in\"&gt;data&lt;/span&gt; &amp;#61; front();\n            pop(); &lt;span class=\"hljs-comment\"&gt;//从本队列中弹出&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(temp &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;data&lt;/span&gt;)\n            {\n                flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n                break;\n            }\n            tt.push(&lt;span class=\"hljs-built_in\"&gt;data&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//先存到tt中&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(flag)\n            ans.push(temp);\n        &lt;span class=\"hljs-comment\"&gt;//把tt中的数据存入本身&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(!tt.empty())\n        {\n            push(tt.front());;\n            tt.pop();\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ans;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码段贴代码&amp;#xff1a;点击下面的图标&amp;#xff0c;然后再粘贴代码即可。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/357413062746134.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于c++自定义队列类和运算符重载Orz", ["想实现的功能是讲两个队列中不重复的部分加起来", "这是主函数里的代码", "Queue a, b;", "a.push(1);", "a.push(2);", "a.push(3);", "b.push(3);", "b.push(4);", "b.push(5);", "Queue c, d;", "cout << \"a + b = \";", "c = a + b;", "cout<< c. back();", "这是实现文件中的代码", "template", "\n", "Queue Queue::operator+(Queue obj)", "{", "    int ahead = head;", "    Queue", " ans;", "    type temp;", "    while(!isEmpty())", "    {", "        ans.push(front());", "        pop();", "    }", "    head = ahead;", "    while(!obj.isEmpty())", "    {", "        temp = obj.front();", "        obj.pop();", "        while(!isEmpty())", "        {", "            if(temp == front())", "            {", "                break;", "            }", "            pop();", "        }", "        if(isEmpty())", "            ans.push(temp);", "        head = ahead;", "    }", "    head = ahead;", "    cout << ans.back() << endl;", "    return ans;", "}", "\n", "为什么在实现类中调用就没问题，而在主函数中调用，最后一个元素却变成了随机值呢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不是一样的。那个operator重载的第一个参数就是ostream对象。&lt;br /&gt;就像&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-variable\"&gt;ostream&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;&amp;amp;&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;operator&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;ostream&lt;/span&gt;&amp;amp; &lt;span class=\"hljs-params\"&gt;os&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;ClassA&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;){\n  &lt;span class=\"hljs-comment\"&gt;//………………&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;os&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果使用以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;ClassA cla;\ncout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;cla; //等价于operator&amp;lt;&amp;lt;(cout,cla&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么传入operator&amp;lt;&amp;lt;的参数中&amp;#xff0c;os是cout&amp;#xff0c;a就是cla。&lt;br /&gt;至于你写到运算符只有一个参数&amp;#xff0c;然而&amp;lt;&amp;lt;是二元运算符&amp;#xff0c;所以你这个应该定义在类里。&lt;br /&gt;而且如果定义在类里&amp;#xff0c;就要将对象放在运算符前面&amp;#xff0c;而且cout没有定义那种运算符。&lt;br /&gt;就像&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;S&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n  std::ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; os){ &lt;span class=\"hljs-comment\"&gt;//标记&amp;#xff1a;1&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//insert your code&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n  }\n};\n\nstd::ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; os,S s){ &lt;span class=\"hljs-comment\"&gt;//标记&amp;#xff1a;2&lt;/span&gt;\n  &lt;span class=\"hljs-comment\"&gt;//insert your code&lt;/span&gt;\n  &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n  S s;\n  cout &amp;lt;&amp;lt; s; &lt;span class=\"hljs-comment\"&gt;//调用2&lt;/span&gt;\n  s &amp;lt;&amp;lt; cout; &lt;span class=\"hljs-comment\"&gt;//调用1&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++中<<运算符重载中的问题", ["ostream & ", "operator", "<<(ostream &", "out", ") ", "const", "\n{\n    ", "if", "(str != NULL)\n    {\n          ", "out", " << str;\n    }\n    ", "return", " ", "out", ";\n}\n", "\n", "上述代码中最后为啥要return out这个操作", "而且假设现在有一个对象S", "S << cout和cout << S这俩玩意一样不  这个C++这块好难理解啊"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-comment\"&gt;//&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// Created by qza2468 on 2021/11/4.&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-symbol\"&gt;Square&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; x, y;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; operator&amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Square &amp;amp;s2) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; x * y &amp;#43; s2.x * s2.y;\n    }\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;题主&amp;#xff0c;想要的是这样吗&amp;#xff1f;我觉得不太可取。很容易误解。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["如何用运算符重载实现两个矩形类的面积之和", ["C++🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CStr&lt;/span&gt;&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    char* &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n    int len;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    CStr(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; char* d &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;construct----------&amp;#34; &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (d[len] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;)\n                len&amp;#43;&amp;#43;;\n\n            &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; new char[len &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//多申请一个字节给\\0&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i] &amp;#61; d[i];\n            &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[len] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//结束符&lt;/span&gt;\n        }\n        \n        \n    }\n    ~CStr() \n    {\n        &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;disconstruct.....&amp;#34; &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//析构函数中不要delete data;否则&amp;#43;运算回得不到结果&lt;/span&gt;\n    }\n\n    CStr&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61; (CStr&amp;amp; s)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;&amp;#61;:&amp;#34; &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        delete[] &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n        len &amp;#61; s.len;\n        &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; new char[len &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i] &amp;#61; s.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i];\n        &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[len] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    CStr &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CStr&amp;amp; a)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;&amp;#43;&amp;#34; &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        char* p &amp;#61; new char[len &amp;#43; a.len &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (; i &amp;lt; len; i&amp;#43;&amp;#43;)\n            p[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i];\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; a.len; j&amp;#43;&amp;#43;)\n            p[i &amp;#43; j] &amp;#61; a.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[j];\n        p[len &amp;#43; a.len] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n        CStr t(p);\n        delete[] p;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; t;\n    }\n\n    CStr &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CStr&amp;amp; a)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; (char*)realloc(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;, len &amp;#43; a.len &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//扩容&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; a.len; j&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[len &amp;#43; j] &amp;#61; a.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[j];\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[len &amp;#43; a.len] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n        len &amp;#43;&amp;#61; a.len; &lt;span class=\"hljs-comment\"&gt;//修正长度&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    bool &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CStr&amp;amp; a)\n    {\n        int t &amp;#61; len &amp;gt; a.len ? a.len : len;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; t; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i] &amp;gt; a.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i])\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    bool &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CStr&amp;amp; a)\n    {\n        int t &amp;#61; len &amp;gt; a.len ? a.len : len;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; t; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i] &amp;lt; a.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i])\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    bool &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CStr&amp;amp; a)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (len !&amp;#61; a.len)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        \n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i] !&amp;#61; a.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[i])\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n\n    char &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; [](int index)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (index &amp;lt; len)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;[index];\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n    }\n\n    friend ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CStr&amp;amp; a)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt; &amp;lt;&amp;lt; a.&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;;\n    }\n\n};\n\nint main()\n{\n    char buf[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个字符串创建CStr 实例a&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; buf;\n    CStr a(buf);\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个字符串创建CStr 实例b&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; buf;\n    CStr b(buf);\n\n    CStr c;\n    c &amp;#61; a;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;CStr c&amp;#61;a; c:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;\n\n    CStr d &amp;#61; a &amp;#43; b;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;CStr d&amp;#61;a&amp;#43;b; d:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;gt;b:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (a &amp;gt; b) &amp;lt;&amp;lt; endl;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要获取的实例a的元素下标&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    int index;\n    cin &amp;gt;&amp;gt; index;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;a[&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;]&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; a[index] &amp;lt;&amp;lt; endl;\n\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#c++#的问题：关于多种运算符重载的问题", ["关于多种运算符重载的问题，最好多几条注释，解释清楚一点，注意其返回值的不同"]], "Tag": "程序设计"}
{"Answer": "运算符重载首先不是所有的运算符都能重载，另一个，运算符重载必须依附于类型，和C++不同，你不能在类定义的外部重载运算符。也就是说你不能改变已有类型的运算符的功能。", "Konwledge_Point": "运算符重载", "Question": ["link中什么是运算符重载的局限性？局限性具体表现在哪些地方？", ["什么是link中运算符重载的局限性？这个局限性从什么地方体现出来？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;模板类&amp;#xff0c;大部分代码都写出来了&lt;br /&gt;double&amp;amp; va &amp;#61; arr[index]; //返回引用&lt;br /&gt;double vb &amp;#61; arr[index];   //返回值&lt;br /&gt;返回引用的&amp;#xff0c;修改va&amp;#xff0c;也会改变数组中的值。&lt;br /&gt;返回值的&amp;#xff0c;修改vb&amp;#xff0c;不会改变数组中的值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; T, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; N &amp;gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Array&lt;/span&gt; {\n    T data[N];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; nLength;                &lt;span class=\"hljs-comment\"&gt;//实际存放的元素个数&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Array&lt;/span&gt;() { nLength &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getLength&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; nLength; }            &lt;span class=\"hljs-comment\"&gt;//取实际元素个数&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;put&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(T value)&lt;/span&gt;            &lt;span class=\"hljs-comment\"&gt;//将value加入data[]中&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (nLength &amp;lt; N)\n        {\n            data[nLength&amp;#43;&amp;#43;] &amp;#61; value;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;set&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index, T value)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//设置某元素的值&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (index &amp;lt; nLength)\n        {\n            data[index] &amp;#61; value;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;get&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index, T&amp;amp; value)&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//获取某个元素的值&amp;#xff0c;放入value中&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (index &amp;lt; nLength)\n        {\n            value &amp;#61; data[index];\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    T&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[] (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index)  &lt;span class=\"hljs-comment\"&gt;//取某个位置元素的值&amp;#xff0c;返回该值&amp;#xff0c;可以与&amp;#43;&amp;#43;或--联用&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; data[index];\n    }\n    T &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[] (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    {\n        T v &amp;#61; data[index];\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; v;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;virtual&lt;/span&gt; ~&lt;span class=\"hljs-built_in\"&gt;Array&lt;/span&gt;() {}\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Array&amp;lt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;&amp;gt; arr;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; v;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入3个数存放如数组&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        cin &amp;gt;&amp;gt; v;\n        arr.&lt;span class=\"hljs-built_in\"&gt;put&lt;/span&gt;(v); &lt;span class=\"hljs-comment\"&gt;//调用put插入数组&lt;/span&gt;\n    }\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;当前存放的元素个数&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; arr.&lt;span class=\"hljs-built_in\"&gt;getLength&lt;/span&gt;() &amp;lt;&amp;lt; endl;\n\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要获取的元素下标&amp;#xff08;从0开始&amp;#xff09;&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; index;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (arr.&lt;span class=\"hljs-built_in\"&gt;get&lt;/span&gt;(index, v))\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;该元素为&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; v &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        cout &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;大于实际元素个数&amp;#xff0c;获取失败&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入需要修改的元素下标及新值&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; index &amp;gt;&amp;gt; v;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (arr.&lt;span class=\"hljs-built_in\"&gt;set&lt;/span&gt;(index, v))\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;设置成功&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        cout &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;大于实际元素个数&amp;#xff0c;设置失败&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要获取的元素下标&amp;#xff08;从0开始&amp;#xff09;&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; index;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;&amp;amp; va &amp;#61; arr[index]; &lt;span class=\"hljs-comment\"&gt;//返回引用&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;double&amp;amp; va &amp;#61; arr[&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt; index &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;]&amp;#xff0c;调用返回值为引用的重载函数&amp;#xff0c;va的值为&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; va &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;//使用[]注意不要越界&lt;/span&gt;\n    \n    va &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;设置va&amp;#61;10后&amp;#xff0c;double vb &amp;#61; arr[&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt; index &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;]&amp;#xff0c;调用返回值为普通类型的重载函数&amp;#xff0c;vb值为&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; vb &amp;#61; arr[index];\n    cout &amp;lt;&amp;lt; vb;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#c++#的问题：关于运算符重载的一个问题", ["关于运算符重载的一个问题，注意返回值一个是值，一个是引用，两个有不同的区别"]], "Tag": "程序设计"}
{"Answer": "必须考虑如下语意\r\nb = a - a\r\n这种情况，如果你不返回新对象，而是直接在当前对象上减，结果就不对了。", "Konwledge_Point": "运算符重载", "Question": ["C++关于类中重载运算符的问题", ["class Type{\n    int i;\npublic:\n    friend const Type operator-(const Type& a)\n    {\n        return Type(-a.i);\n    }\n\n    friend Type& operator-(Type& a)\n    {\n        a.i *= -1;\n        return a;\n    }\n}; \n", "\n\n", "为什么书上的代码 要将这种一元的运算符重载（+除外）用新创建一个类对象 再按值进行返回的方式来重载呢，是为了使用临时对象语法吗还是其他的原因呢？", "\n还有就是可不可以简单的理解为如果是创建一个新的对象来返回就按照值进行返回，没有创建新对象进行返回（返回传入参数或者this指针的解引用这种）就简单记忆为按照引用进行返回呢？"]], "Tag": "程序设计"}
{"Answer": "integer(int n = 0):i(n){}\r\n\r\n这是个构造函数, 参数需要传一个int类型, 但是参数给了默认值,也就是说不传也行默认给0.  \r\n:i(n)  是初始化列表 ,   就是i = n 的意思\r\n简而言之, 实例化对象的时候,因为显示定义了有参构造,所以编译器不会给我们加无参构造. 这种写法可以少写一个无参构造.\r\n\r\n\r\n\r\nz=x+3时，3是怎么通过这个构造函数转化为integer对象的？     明显的一个隐式类型转换", "Konwledge_Point": "运算符重载", "Question": ["c++运算符重载，构造函数integer(int n=0):i(n) {}中int n=0问题", ["求教第5行中int n=0在z=x+y时起什么作用，还有z=x+3的时候"]], "Tag": "程序设计"}
{"Answer": "当然，只要使用了这个类的代码，都可以使用运算符。", "Konwledge_Point": "运算符重载", "Question": ["link中重载运算符会不会影响到这个项目中别的源代码？谢谢！", ["link中重载运算符会不会影响到这个项目中别的源代码？谢谢！"]], "Tag": "程序设计"}
{"Answer": "原文链接：http://blog.csdn.net/lyh__521/article/details/49601489重载输入输出运算符\n  我们平时可以用流 std::cout&lt;&lt;str&lt;&lt;n ; std::cin&gt;&gt;str&gt;&gt;n ; 输出、输入字符串和整型等内置类型的值。但是对于我们自定义的类，比如 Student 类，却不能直接通过 cout&lt;&lt;Student 或 cin&gt;&gt;Student 这......&lt;br/&gt;&lt;strong&gt;答案就在这里：&lt;/strong&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/lyh__521/article/details/49601489'&gt;重载输入输出运算符&lt;/a&gt;&lt;br/&gt;----------------------Hi，地球人，我是问答机器人小S，上面的内容就是我狂拽酷炫叼炸天的答案，除了赞同，你还有别的选择吗？", "Konwledge_Point": "运算符重载", "Question": ["输入 输出运算符  >>  <<怎么重载？", ["设计一个时间类Time，要求：", "\n1、包含时(hour)，分(minute)，秒(second)私有数据成员；", "\n2、包含构造函数，重载关于一时间加上另一时间的加法运算符\"+\"、重载输出运算符\"<<\"、重载输入运算符\">>\"。", "\n要求，定义完Time类后，main函数中声明对象time1,time2,time3，然后实现", "\ncin>>time1>>time2;", "\ntime3=time1+time2;", "\ncout<"]], "Tag": "程序设计"}
{"Answer": "如果你先采纳本喵的回答，我可以直接写给你哦", "Konwledge_Point": "运算符重载", "Question": ["C++ 类 如何重载运算符", ["编写一个Customer类，包括账号、密码、姓名、余额（初始为0）。", "\n用三种方法重载运算符“-”，使得两个Customer对象相减，能得到它们余额之差。", "\n\n", "请发送至邮箱", "liangxiaoqi_c@163.com"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载运算符使用 const CComplex&amp;amp;类型,报错是因为传入是一个临时的消亡值.需要用const的方式延长生命周期.&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++重载输出流运算符", ["\n", "#include <iostream>\nusing namespace std;\nclass CComplex {\npublic:\n\tCComplex();\n\tCComplex(double x, double y);\n\tCComplex(double R);\n\tfriend CComplex operator + (CComplex& obj1, CComplex& obj2);\n\tfriend CComplex operator - (CComplex& obj1, CComplex& obj2);\n\tfriend CComplex operator * (CComplex& obj1, CComplex& obj2);\n\tfriend CComplex operator / (CComplex& obj1, CComplex& obj2);\n\tfriend ostream& operator << (ostream& output, CComplex& C);\nprivate:\n\tdouble real;\n\tdouble imag;\n};\n\nCComplex::CComplex() {\n\treal = 0.0;\n\timag = 0.0;\n}\nCComplex::CComplex(double x, double y) {\n\treal = x;\n\timag = y;\n}\nCComplex::CComplex(double R) {\n\treal = R;\n\timag = 0;\n}\n\nCComplex operator + (CComplex& obj1, CComplex& obj2) {\n\tCComplex obj3(obj1.real + obj2.real, obj1.imag + obj2.imag);\n\treturn obj3;\n}\nCComplex operator - (CComplex& obj1, CComplex& obj2) {\n\tCComplex obj3(obj1.real - obj2.real, obj1.imag - obj2.imag);\n\treturn obj3;\n}\nCComplex operator * (CComplex& obj1, CComplex& obj2) {\n\tCComplex obj3(obj1.real * obj2.real - obj1.imag * obj2.imag, obj1.real * obj2.imag - obj2.real * obj1.imag);\n\treturn obj3;\n}\nCComplex operator / (CComplex& obj1, CComplex& obj2) {\n\tif (obj2.real == 0 && obj2.imag == 0) { cout << \"Wrong!\" << endl; exit(0); }\n\tCComplex obj3((obj1.real * obj2.real - obj1.imag * (-obj2.imag)) / (obj2.real * obj2.real + obj2.imag * obj2.imag),\n\t\tobj1.real * (-obj2.imag) - obj2.real * obj1.imag / (obj2.real * obj2.real + obj2.imag * obj2.imag));\n\treturn obj3;\n}\nostream& operator << (ostream& output, CComplex& C) {\n\toutput << C.real << \" + \" << C.imag << \"i\";\n\treturn output;\n}\n\nint main()\n{\n\tCComplex c1 = 5;\n\tCComplex c2 = 0;\n\tCComplex c3 = CComplex(3, 4);\n\tcout << c1 << endl;\n\tcout << c2 << endl;\n\tcout << c3 << endl;\n\n\tCComplex c4 = c1 + c3;\n\tcout << c4 << endl;\n\tCComplex c5 = c1 - c3;\n\tcout << c5 << endl;\n\tCComplex c6 = c1 * c3;\n\tcout << c6 << endl;\n\tCComplex c7 = c1 / c3;\n\tcout << c7 << endl;\n\t//cout << ( c1 + c3 ) << endl;\n\t//cout << c1 + c3 << endl;\n\treturn 0;\n}\n/*\n提问：\n1.为什么71,72行会报错；\n*/\n"]], "Tag": "程序设计"}
{"Answer": "重载=或者==只能有一个参数，应为类自身默认作为一个参数传进来，用this进行表示的。", "Konwledge_Point": "运算符重载", "Question": ["people类重载“==”运算符和“=”运算符，", ["#include ", "\nusing namespace std;", "\n\n", "class People{", "\npublic:", "\n    bool operator ==(People &a,People &b){", "\n    if(a.id==b.id)", "\n        cout<<\"两个people对象的id相同\"<<endl;", "\n    else", "\n        cout<<\"两个people对象的id不同\"<<endl;", "\n}", "\n    void operator =(People &a,People &b){", "\n    a=b;", "\n}", "\n    input();", "\n    output(){", "\n    cout<<\"输出人员信息：\"<<endl;", "\n    cout<<\"编号:\"<<number<<endl<<\"性别:\"<<sex<<endl;", "\n    cout<<\"出生日期:\"<<birthday<<endl<<\"身份证号:\"<<id<<endl<<endl;", "\n    }", "\n\n", "private:", "\n    double number;", "\n    char sex[10];", "\n    char birthday[20];", "\n    double id;", "\n};", "\nPeople::input(){", "\n        cout<<\"录入people信息\"<\n        cout\n        cin>>number;", "\n\n", "    cout<<\"性别:\";\n    cin>>sex;\n\n    cout<<\"出生日期:\";\n    cin>>birthday;\n\n    cout<<\"身份证号:\";\n    cin>>id;\n    cout<<endl;\n", "\n\n", "}", "\n\n", "int main(int argc,char *argv[]){", "\n    People p1,p2;", "\n    p1.input();", "\n    p2.input();", "\n    People::operator ==(p1,p2);", "\n    People::operator =(p1,p2);", "\n    cout<<\"将p2赋给p1:\"<<endl;", "\n    p1.output();", "\n    system(\"pause\");", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "# 问题解决的话，请点下采纳\r\n```\r\n#include&lt;iostream&gt;\r\n#define defaultValue 0\r\nusing namespace std;\r\nclass Person{\r\nprotected:\r\n    string m_strName;\r\npublic:\r\n    Person() { cout &lt;&lt; \"Person constructing\" &lt;&lt; endl; }\r\n    ~Person() { cout &lt;&lt; \"Person destructing\" &lt;&lt; endl; }\r\n    Person(const string&amp;);\r\n    friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Person&amp;);\r\n    friend istream&amp; operator&gt;&gt;(istream&amp;, Person&amp;);\r\n};\r\n\r\nclass Student:public Person {\r\nprivate:\r\n    static int m_nLastID;\r\npublic:\r\n    int m_strSID;\r\n    Student() {\r\n        cout &lt;&lt; \"Student constructing\" &lt;&lt; endl;\r\n        int m_strSID = defaultValue;\r\n        m_strSID = ++m_nLastID; \r\n    }\r\n    ~Student(){ cout &lt;&lt; \"Student destructing\" &lt;&lt; endl; }\r\n    Student(const string&amp;name);\r\n    friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Student&amp;);\r\n    friend istream&amp; operator&gt;&gt;(istream&amp;, Student&amp;);\r\n};\r\n\r\nint Student::m_nLastID = 0;\r\n\r\nostream &amp; operator&lt;&lt;(ostream &amp;o, const Person &amp;p)\r\n{\r\n    o &lt;&lt; p.m_strName;\r\n    return o;\r\n}\r\n\r\nistream &amp; operator&gt;&gt;(istream &amp;i, Person &amp;p)\r\n{\r\n    char a[256];\r\n    i &gt;&gt; a;\r\n    p.m_strName = a;\r\n    return i;\r\n}\r\n\r\nostream &amp; operator&lt;&lt;(ostream &amp;o,  const Student &amp;s)\r\n{\r\n    o &lt;&lt; s.Person::m_strName&lt;&lt;' '&lt;&lt;s.m_strSID;\r\n    return o;\r\n}\r\n\r\nistream &amp; operator&gt;&gt;(istream &amp;i, Student &amp;s)\r\n{\r\n    char a[256]={0};\r\n    i &gt;&gt; a;\r\n    s.Person::m_strName = a;\r\n    return i;\r\n}\r\n\r\nPerson::Person(const string &amp;s)\r\n{\r\n    m_strName = s;\r\n}\r\n\r\nStudent::Student(const string &amp; name)\r\n{\r\n    m_strName = name;\r\n}\r\n\r\nint main() \r\n{\r\n\tStudent s;\r\n\tcout &lt;&lt; s;\r\n\treturn 0;\r\n}\r\n```", "Konwledge_Point": "运算符重载", "Question": ["子类与父类输出操作符重载出错", ["下面代码中两个输出运算符重载无法实现，应该怎么解决", "\n\n", "#include<iostream>\n#define defaultValue \"0\"\nusing namespace std;\nclass Person{\nprotected:\n    string m_strName;\npublic:\n    Person() { cout << \"Person constructing\" << endl; }\n    ~Person() { cout << \"Person destructing\" << endl; }\n    Person(const string&);\n    friend ostream& operator<<(ostream&, const Person&);\n    friend istream& operator>>(istream&, Person&);\n};\n\nclass Student:public Person {\n    static int m_nLastID;\npublic:\n    Student() {\n        cout << \"Student constructing\" << endl;\n        m_strSID = ++m_nLastID; \n    }\n    ~Student(){ cout << \"Student destructing\" << endl; }\n    Student(const string&name);\n    string m_strSID= defaultValue;\n    friend ostream& operator<<(ostream&, const Student&);\n    friend istream& operator>>(istream&, Student&);\n};\n\n#include \"Person.h\"\n\nostream & operator<<(ostream &o, const Person &p)\n{\n    o << p.m_strName;\n    return o;\n}\n\nistream & operator>>(istream &i, Person &p)\n{\n    char a[256];\n    i >> a;\n    p.m_strName = a;\n    return i;\n}\n\nostream & operator<<(ostream &o,  const Student &s)\n{\n    o << s.Person::m_strName<<' '<<s.m_strSID;\n    return o;\n}\n\nistream & operator>>(istream &i, Student &s)\n{\n    char a[256]{0};\n    i >> a;\n    s.Person::m_strName = a;\n    return i;\n}\n\nPerson::Person(const string &s)\n{\n    m_strName = s;\n}\n\nStudent::Student(const string & name)\n{\n    m_strName = name;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "其实是以下这两个函数没有满足重载要求，引起语法的混淆。\r\nint &amp;DoubleScriptedArray::operator()(int s1,int s2 )const\r\nint &amp;DoubleScriptedArray::operator()(int s1,int s2 )\r\n\r\n末尾有没有const，这两个函数都不是重载", "Konwledge_Point": "运算符重载", "Question": ["c++  运算符的重载 运行时出现 debug 请各位大神帮忙找错", ["// Chapter 8 of C++ How to Program", "\n// doubleScriptedArray.h", "\n#ifndef DARRAY_H", "\n#define DARRAY_H", "\n\n", "#include ", "\n\n", "using std::ostream;", "\nusing std::istream;", "\n\n", "class DoubleScriptedArray {", "\n    friend ostream &operator<<(ostream&, const DoubleScriptedArray & );", "\n   /* write declaration for overloaded ostream operator */", "\n   friend istream &operator>>( istream &,const  DoubleScriptedArray & );", "\npublic:", "\n   DoubleScriptedArray( int = 10, int = 10 );", "\n   DoubleScriptedArray( const DoubleScriptedArray & );", "\n   ~DoubleScriptedArray();  ", "\n\n", "/* write prototype for overloaded =  operator ", "/", "\n  const DoubleScriptedArray &operator=( const DoubleScriptedArray &);", "\n   bool operator==( const DoubleScriptedArray & ) const; ", "\n   DoubleScriptedArray operator!=(DoubleScriptedArray &right)const", "\n   /", " write header for operator != */   ", "\n\n", "  { return ! ( *this == right ); }\n", "\n\n", "int &operator()( int, int );", "\n   int   &operator()(int ,int )const;// lvalue", "\n   /* write prototype for overloaded () operator used as", "\n      an rvalue */", "\n\n", "private:", "\n   int rows;     // number of rows in array", "\n   int columns;  // number of columns in array", "\n   int *ptr;     // pointer to first element of array", "\n};", "\n\n", "#endif", "\n#include ", "\n\n", "using std::cout;", "\nusing std::cin;", "\nusing std::endl;", "\n\n", "#include ", "\n\n", "using std::setw;", "\n\n", "#include ", "\n#include ", "\n#include \"doubleScriptedArray.h\"", "\n\n", "DoubleScriptedArray::DoubleScriptedArray( int r, int c )", "\n{", "\n   rows = ( r > 0 ? r : 10 );", "\n   columns = ( c > 0 ? c : 10 );", "\n   ptr = new int[ rows * columns ]; ", "\n   assert( ptr != 0 );    ", "\n\n", "for ( int i = 0; i < rows * columns; i++ )", "\n      ptr[ i ] = 0;", "\n}", "\n\n", "DoubleScriptedArray::DoubleScriptedArray( ", "\n   const DoubleScriptedArray &init )", "\n{", "\n   rows = init.rows;", "\n   columns = init.columns;", "\n\n", "ptr = new int[ rows * columns ];", "\n   assert( ptr != 0 );    ", "\n\n", "for ( int i = 0; i < rows * columns; i++ )", "\n      ptr[ i ] = init.ptr[ i ];", "\n}", "\n\n", "/* write definition for destructor */", "\nDoubleScriptedArray::~DoubleScriptedArray()", "\n {", "\ndelete []ptr;", "\n\n", "}", "\n\n", "/* write definition for operator = */", "\nconst DoubleScriptedArray &DoubleScriptedArray::operator =(const  DoubleScriptedArray &init)", "\n{", "\n\n", " rows = init.rows;\n", "\n\n", "columns = init.columns;", "\n\n", "ptr = new int[ rows * columns ];", "\n   assert( ptr != 0 );    ", "\n\n", "for ( int i = 0; i < rows * columns; i++ )", "\n      ptr[ i ] = init.ptr[ i ]; ", "\n   return *this;", "\n\n", "}", "\n\n", "bool DoubleScriptedArray::operator==(", "\n   const DoubleScriptedArray &right ) const", "\n{", "\n   if ( rows != right.rows )", "\n      return false;    ", "\n\n", "if ( columns != right.columns )", "\n      return false;", "\n\n", "for ( int i = 0; i < rows * columns; i++ )", "\n      if ( ptr[ i ] != right.ptr[ i ] )", "\n         return false; ", "\n\n", "return true;", "\n}", "\n\n", "// Overloaded subscript operator for non-const Arrays", "\n // reference return creates an lvalue", "\nint &DoubleScriptedArray::operator()( int s1, int s2 )", "\n{", "\n   assert( s1 > 0 && s1 < rows );", "\n   assert( s2 > 0 && s2 < columns );", "\n\n", "return ptr[ columns * s1 + s2 ]; ", "\n}", "\n\n", "// Overloaded subscript operator for const Arrays", "\n// const reference return creates an rvalue", "\n/* write overloaded subscript operator that returns an rvalue */", "\n int &DoubleScriptedArray::operator()(int s1,int s2 )const", "\n {", "\n     assert( s1 > 0 && s1 < rows );", "\n   assert( s2 > 0 && s2 < columns );", "\n\n", "return ptr[ columns * s1 + s2 ]; ", "\n\n", "}", "\n\n", "istream &operator>>( istream &input, const DoubleScriptedArray &a )", "\n{", "\n   for ( int i = 0; i < a.rows * a.columns; i++ )", "\n      input >> a.ptr[ i ];", "\n\n", "return input;", "\n}", "\n\n", "/* write function header for overloaded insertion operator */", "\nostream &operator<<(ostream & output,const DoubleScriptedArray &a )", "\n{", "\n   for ( int i = 0; i < a.rows * a.columns; i++ ) ", "\n   {", "\n      output << setw( 6 ) << a.ptr[ i ];", "\n\n", "  if ( ( i + 1 ) % a.columns == 0 )\n     output << endl;\n", "\n\n", "}", "\n\n", "if ( i % a.columns != 0 )", "\n      output << endl;", "\n\n", "return output; ", "\n}", "\n// Chapter 8 of C++ How to Program", "\n// Driver for class DoubleScriptedArray", "\n#include ", "\n\n", "using std::cout;", "\nusing std::cin;", "\nusing std::endl;", "\n\n", "#include ", "\n#include", "\n#include", "\nusing namespace std;", "\n\n", "#include \"doubleScriptedArray.h\"", "\n\n", "int main() ", "\n{", "\n   // seed rand function", "\n   srand( time( 0 ) );", "\n\n", "// create two arrays with different dimensions", "\n   DoubleScriptedArray a( 6, 7 ), b( 8, 2 );", "\n\n", "cout << \"Uninitialized array \\\"a\\\" is: \\n\" << a ", "\n        << \"Uninitialized array \\\"b\\\" is: \\n\" << b;", "\n\n", "// initialize array \"a\" with random values (0-100)", "\n   for ( int i = 0; i < 6; i++ )", "\n\n", "  for ( int j = 0; j < 7; j++ )\n\n     a(i,j)=rand()%100;\n\n     /* write statement to insert random elements (reduced \n         to a range of 0 - 100) into the array via \n         the overloaded () */\n", "\n\n", "// use overloaded operator=", "\n   b = a;", "\n\n", "cout << \"\\nInitialized array \\\"a\\\" is now:\\n\" << a", "\n        << \"Assigning b = a:\\n\" << b;", "\n\n", "// check if arrays are equal using overloaded ==", "\n   if ( a == b )", "\n      cout << \"\\\"a\\\" was found to be equal to \\\"b\\\"\\n\";", "\n   else", "\n      cout << \"\\\"a\\\" was found to be not equal to \\\"b\\\"\\n\";", "\n\n", "// retrieve an array element using overloaded operator()", "\n   cout << \"The element (2, 1) of array \\\"a\\\" is: \"", "\n        << a( 2, 1 ) << endl;", "\n\n", "// change an element of the array using overloaded operator()", "\n   a( 2, 1 ) = -1;", "\n   cout << \"Changed element (2, 1) to -1: \\n\" << a;", "\n\n", "// check if arrays are still equal ", "\n   if (a==b /* write condition to check if arrays are equal */ )", "\n      cout << \"\\\"a\\\" was found to be equal to \\\"b\\\"\\n\";", "\n   else", "\n      cout << \"\\\"a\\\" was found to be NOT equal to \\\"b\\\"\\n\";", "\n\n", "return 0;", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "这种类型呗\r\n\r\n```\r\n istream &amp; operator&gt;&gt;(istream &amp;  input,Matrix &amp; m)\r\n{\r\n    int i,j;\r\n    for(i=0;i&lt;2;i++)\r\n        for(j=0;j&lt;3;j++)\r\n            input&gt;&gt;m.mat[i][j];\r\n    return input;\r\n}\r\n\r\n```", "Konwledge_Point": "运算符重载", "Question": ["C++课程设计 有一个要求重载输入“>>”运算符，使得可以通过cin直接读入一个类的对象值？？", ["C++课程设计 有一个要求重载输入“>>”运算符，使得可以通过cin直接读入一个类的对象值，什么意思？？怎么实现呢？？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#43;运算返回的是一个临时变量&amp;#xff0c;p&amp;#43;q返回的是一个临时变量&amp;#xff0c;&amp;lt;&amp;lt;重载运算符中用引用的时候&amp;#xff08;也就是用Point &amp;amp;p的时候&amp;#xff09;&amp;#xff0c;是对这个临时变量的引用&amp;#xff0c;但是这个临时变量在&amp;#43;运算符重载函数结束后就被回收了&amp;#xff0c;所以&amp;#xff0c;如果&amp;lt;&amp;lt;中用引用的时候&amp;#xff0c;引用指向了一个被销毁的对象&amp;#xff0c;所以会报错。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++重载输出流运算符<<时，为什么不能输出表达式的值", ["重载输出流运算符<<时，为什么只能输出单个变量的值，而不能输出表达式的值？", "原理是什么？", "\n", "#", "include", " ", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "#", "define", " N 1000", "\n", "struct", " ", "Point", "\n{\n    ", "int", " x, y;\n    ", "Point", "(){}\n    ", "Point", "(", "int", " a, ", "int", " b):", "x", "(a),", "y", "(b){}\n    Point ", "operator", " + (Point &b)\n    {\n        ", "return", " ", "Point", "(x+b.x, y+b.y);\n    }\n    ", "friend", " ostream& ", "operator", " << (ostream& os, Point &p)\n    {\n       os<<", "\"(\"", "<<p.x<<", "','", "<<p.y<<", "\")\"", ";\n       ", "return", " os;\n    }\n};\n", "int", " ", "main", "()", "\n", "{\n    ", "Point ", "p", "(", "1", ",", "2", ")", ", ", "q", "(", "3", ",", "4", ")", ", r", ";\n    cout << p << ", "' '", " << q << endl;\n    r = p + q;\n    cout << r << endl;\n    ", "//以上编译都过了 能正常运行", "\n    cout << (p+q); ", "//这行写编译不过， 请问为什么？", "\n    ", "//报错：[Error] cannot bind 'std::ostream {aka std::basic_ostream<char>}' lvalue to 'std::basic_ostream<char>&&'", "\n    ", "return", " ", "0", ";\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"hljs language-cpp\"&gt;class jz\n{\n\tint a[2][2];\npublic:\n\tjz() {}\n\tjz(int b[2][2]) \n\t{ \n\t\tfor(int i&amp;#61;0;i&amp;lt;2;i&amp;#43;&amp;#43;)\n\t\t\tfor(int j&amp;#61;0;j&amp;lt;2;j&amp;#43;&amp;#43;)\n\t\t\t\ta[i][j] &amp;#61; b[i][j];\n\t}\n\tvoid GetData(int c[2][2])\n\t{\n\t\tfor(int i&amp;#61;0;i&amp;lt;2;i&amp;#43;&amp;#43;)\n\t\t\tfor(int j&amp;#61;0;j&amp;lt;2;j&amp;#43;&amp;#43;)\n\t\t\t\tc[i][j] &amp;#61; a[i][j];\n\t}\n\tbool operator &amp;#61;&amp;#61; (jz &amp;amp; k)\n\t{\n\t\tint c[2][2];\n\t\tk.GetData(c);\n\t\tfor(int i&amp;#61;0;i&amp;lt;2;i&amp;#43;&amp;#43;)\n\t\t\tfor(int j&amp;#61;0;j&amp;lt;2;j&amp;#43;&amp;#43;)\n\t\t\t\tif(a[i][j] !&amp;#61; c[i][j])\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid main()\n{\n\tint a[2][2] &amp;#61; {5,3,2,4};\n\tjz k(a);\n\tjz r(a);\n\tif(k&amp;#61;&amp;#61;r)\n\t\tprintf(&amp;#34;OK&amp;#34;);\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++：定义一个2*2矩阵类，重载运算符“==”，用来判断两个矩阵是否相同。", ["俺不会?..............................................."]], "Tag": "程序设计"}
{"Answer": "setfill('0')才对，这个函数接受一个char类型字符作为参数，而不是字符串", "Konwledge_Point": "运算符重载", "Question": ["c++运算符<<重载,使用setfill函数出错", ["写了个时间类，想用运算符重载输出标准时间格式h:mm，使用setfill函数时出错", "\n\n", " friend ostream &operator<<(ostream &output, tempus&time)\n    {\n        output << time.hour << \":\"  << setw(2) << setfill(\"0\")<< time.minute;\n        return output;\n    }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-comment\"&gt;// g&amp;#43;&amp;#43; -Wall -std&amp;#61;c&amp;#43;&amp;#43;17 main.cpp&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;numeric&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;RationalNumber&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; value_type;\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;RationalNumber&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(value_type a, value_type b)&lt;/span&gt; : _a(a), _b(b)\n    {&lt;!-- --&gt;&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;simplify&lt;/span&gt;();\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;other)\n    {\n        _a &amp;#61; other._a;\n        _b &amp;#61; other._b;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; a &amp;#61; _a * other._b &amp;#43; other._a * _b;\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; b &amp;#61; _b * other._b;\n        _a &amp;#61; a;\n        _b &amp;#61; b;\n        &lt;span class=\"hljs-built_in\"&gt;simplify&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; a &amp;#61; _a * other._b - other._a * _b;\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; b &amp;#61; _b * other._b;\n        _a &amp;#61; a;\n        _b &amp;#61; b;\n        &lt;span class=\"hljs-built_in\"&gt;simplify&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;*&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;other)\n    {\n        _a *&amp;#61; other._a;\n        _b *&amp;#61; other._b;\n        &lt;span class=\"hljs-built_in\"&gt;simplify&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;/&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;other)\n    {\n        _a *&amp;#61; other._b;\n        _b *&amp;#61; other._a;\n        &lt;span class=\"hljs-built_in\"&gt;simplify&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;simplify&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; c &amp;#61; std::&lt;span class=\"hljs-built_in\"&gt;gcd&lt;/span&gt;(_a, _b);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            _a /&amp;#61; c;\n            _b /&amp;#61; c;\n        }\n    }\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    value_type _a;\n    value_type _b;\n\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;*(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;/(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs);\n    &lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; CharT, &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; Traits&amp;gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; std::basic_ostream&amp;lt;CharT, Traits&amp;gt; &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::basic_ostream&amp;lt;CharT, Traits&amp;gt; &amp;amp;os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;number);\n};\n\n&lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs)\n{\n    RationalNumber tmp &amp;#61; lhs;\n    tmp &amp;#43;&amp;#61; rhs;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs)\n{\n    RationalNumber tmp &amp;#61; lhs;\n    tmp -&amp;#61; rhs;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;*(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs)\n{\n    RationalNumber tmp &amp;#61; lhs;\n    tmp *&amp;#61; rhs;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;constexpr&lt;/span&gt; RationalNumber &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;/(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;rhs)\n{\n    RationalNumber tmp &amp;#61; lhs;\n    tmp /&amp;#61; rhs;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; CharT, &lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; Traits&amp;gt;\nstd::basic_ostream&amp;lt;CharT, Traits&amp;gt; &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::basic_ostream&amp;lt;CharT, Traits&amp;gt; &amp;amp;os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RationalNumber &amp;amp;r)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r._b &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;INF&amp;#34;&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r._b &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        os &amp;lt;&amp;lt; r._a;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; c &amp;#61; r._a / r._b;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            os &amp;lt;&amp;lt; r._a &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; r._b;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; a &amp;#61; r._a % r._b;\n            os &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; r._b;\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a1, b1, a2, b2;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Input Fraction 1 (Format: a/b): &amp;#34;&lt;/span&gt;;\n    std::cin &amp;gt;&amp;gt; a1 &amp;gt;&amp;gt; ch &amp;gt;&amp;gt; b1;\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Input Fraction 2 (Format: a/b): &amp;#34;&lt;/span&gt;;\n    std::cin &amp;gt;&amp;gt; a2 &amp;gt;&amp;gt; ch &amp;gt;&amp;gt; b2;\n    &lt;span class=\"hljs-function\"&gt;RationalNumber &lt;span class=\"hljs-title\"&gt;r1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(a1, b1)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;RationalNumber &lt;span class=\"hljs-title\"&gt;r2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(a2, b2)&lt;/span&gt;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; r1 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#43; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r1 &amp;#43; r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; r1 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; - &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r1 - r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; r1 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; * &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r1 * r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    std::cout &amp;lt;&amp;lt; r1 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; / &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#61; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; r1 / r2 &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["运用成员函数和友元函数运算符进行运算", ["分别用成员函数和友元函数重载运算符，使对整型的运算符=、+、-、*、/适用于分数运算。要求：（1）输出结果是最简分数（可以是带分数）；（2）分母为1，只输出分子。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;/*\n注意&amp;#xff0c;使用到的成员变量如下:\nchar *string;                    \nint length;                       \n*/\nMyString&amp;amp; MyString::operator &amp;#43;&amp;#61;(MyString &amp;amp;a){\n\n    char *dest;\n\n   dest &amp;#61; new char[str.length&amp;#43;length&amp;#43;1];\n\n   memcpy(dest,string,length);\n\n   memcpy(dest&amp;#43;length,str.string,str.length&amp;#43;1);\n\n   delete[]string;\n\n   length &amp;#61; length&amp;#43;str.length;\n\n   string &amp;#61; dest;\n\n    return *this;\n\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["如何通过重载运算符+=，实现两个字符串的拼接？", ["\n", "#include \"MyStringClass.hpp\"\nMyString::MyString(){\n\tbuff=\"\\0\";\n}\nMyString::MyString(const char *a){\n\tbuff=(char*)a;\n}\nMyString::MyString(MyString &a){\n\tbuff=a.buff;\n}\nMyString::~MyString(){}\n    \nMyString& MyString::operator +=(MyString &a){\n\t\n\treturn *this;\n}\n    \nint MyString::Length(){\n\treturn strlen(buff);\n}\nvoid MyString::toString(){\n\tcout<<\"字符串为：\"<<buff<<endl;\n}\nint MyString::Compare(MyString &a){\n\treturn strcmp(buff,a.buff);\n}", "\n\n", "MyString类中私有成员只有一个char* buff,要重载+=，实现两个MyString类中buff字符串的拼接，如何做到？请写出我这个文件里那个重载+=函数的具体内容"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;二元运算符&amp;#xff0c;作为成员函数&amp;#xff0c;被自身对象调用&amp;#xff0c;所以当括号有两个参数&amp;#xff0c;加上自身就是3个参数了。如果非要用两个参数&amp;#xff0c;请用友元函数。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载成员函数只能有一个参数吗？", ["重载成员函数只能有一个参数吗？我写的operator-中写一个参数是对的，写了两个参数就是说参数太多了", "\n", "#", "include", " <iostream>", "\nusing namespace std;\nclass ", "complex", " {\npublic:\n    double ", "real", ", ", "imag", ";\n    ", "complex", "(double r=", "0.0", ",double i=", "0.0", "):", "real", "(r),", "imag", "(i){}\n    ", "complex", " operator-(", "complex", "& a,", "complex", " &e);\n    \n};\n", "complex", " operator+(", "complex", "& b, ", "complex", "& c) {\n    ", "return", " ", "complex", "(b.", "real", " + c.", "real", ", b.", "imag", " + c.", "imag", ");\n}\n", "complex", " ", "complex", "::operator-(", "complex", "& a,", "complex", " &e) {\n    ", "return", " ", "complex", "(", "real", " - a.", "real", "+e.", "real", ", ", "imag", " - a.", "imag", "+e.", "imag", ");\n}\nint ", "main", "() {\n    ", "complex", " ", "a", "(", "4.0", ", ", "6", "), ", "b", "(", "5", ", ", "9", "), c,", "e", "(", "1", ",", "2", ");\n    c = a - b-e;\n    cout << c.real << ", "\",\"", " << c.imag << endl;\n    cout << (a + b).", "real", " << ", "\",\"", " << (a + b).", "imag", " << endl;\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以啊&amp;#xff0c;只要满足重载规则&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++类中重载运算符函数可以多个吗？", ["我在一个类中可以编写两个重载运算符函数吗，比如说两个重载运算符都是➖"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://blog.csdn.net/sentimental_dog/article/details/54588493\" id=\"textarea_1629166240490_1629166337935_0\" class=\"md_link_card\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;\n  &lt;span class=\"md_link_title\"&gt;C&amp;#43;&amp;#43;重载&amp;#43;&amp;#43; 如何区分“&amp;#43;&amp;#43;”重载的前置与后置_sentimental_dog的博客-CSDN博客&lt;/span&gt;\n  &lt;span class=\"md_link_desc\" style=\"\"&gt;来源&amp;#xff1a;http://blog.csdn.net/hemingliang1987/article/details/9204815在C&amp;#43;&amp;#43;中重载单目运算符时&amp;#xff0c;会出现前置还是后置的问题&amp;#xff0c;如&amp;#43;&amp;#43;&amp;#xff0c;–等例如 i&amp;#43;&amp;#43;与 &amp;#43;&amp;#43;i这个时候如何让编译器知道是前置还是后置呢&amp;#xff1f;其实很简单&amp;#xff0c;只要在重载操作符的参数中加上一个整数型参数&amp;#xff0c;编译器就会自动将这个函数标示为后置&amp;#xff0c;相应的不加则是前置。&lt;/span&gt;\n  &lt;span class=\"md_flex_card\"&gt;\n  &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n    &lt;span class=\"flex-1\"&gt;\n      &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/sentimental_dog/article/details/54588493&lt;/span&gt;\n    &lt;/span&gt;\n  &lt;/span&gt;&lt;/a&gt;&lt;br /&gt;只要在重载操作符的参数中加上一个整数型参数&amp;#xff0c;编译器就会自动将这个函数标示为后置&amp;#xff0c;相应的不加则是前置&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载++运算符  系统是怎么区分那个是前置那个是后置的", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为运算符重载的时候要在运算符两侧的对象中找对应的运算方法,此时对于此对象来说,他自身已经作为一个默认值被传入了,相当于对象A在其重载运算&amp;#43;中传入了参数B,或许可以等价的看做a.A&amp;#43;(B)&lt;br /&gt;重载&amp;#43;只能填写一个参数是因为&amp;#43;是个二元操作符,其中一个操作数已经被A占据,所以只需要传入另一个操作数B即可&lt;br /&gt;友元函数则是访问类中的属性,他可以显式的传入多个参数,因为友元函数本身可以不属于任何类,也就没有隐藏的this&lt;br /&gt;有帮助望采纳&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于C++中重载运算符的问题", ["请问，为什么在一个类的内部重载运算符时，参数列表中只能有一个参数存在？？", "图片中是对 + 进行重载。明明使用时需要两个参数。        似乎，this这个指针指向了另一个本该出现的参数。", "然而this不应该是正在被我们使用的对象的指针才对吗？", "问题：", "1.为什么在一个类的内部重载运算符时，参数列表中只能有一个参数存在，而在友元函数的情况下就可以两个？", "2.既然参数列表只有一个参数，为什么在使用+时  依旧可以填充两个操作数？", "3.this为什么会指向另一个本该出现在参数列表中的参数？", "4.this这个指针到底指向什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以用啊&amp;#xff0c;你编译出来有错吗&amp;#xff1f;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/386492123256140.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/209992123256169.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["为啥这个operator＝后面不能用引用", ["为啥这个运算符重载函数operator＝后面不能用引用，原因是什么?", "\n", "就是这两行是错的，但是把c3＝去掉又就没问题了或者就是去掉运算符重载函数的引用符号。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;显示的不是地址&amp;#xff0c;而是vol的值&amp;#xff0c;只是你这里没有初始化vol。&lt;br /&gt;而且这里你实现了vol_()函数&amp;#xff0c;class中就没有必要有vol成员了&amp;#xff0c;因为本来vol就是体积&amp;#xff0c;不是你类的属性&amp;#xff0c;你的类属性就只有长宽高&amp;#xff0c;只是你可以提供计算体积的方法。&lt;br /&gt;另外&amp;#xff0c;你重载了输出运算符&amp;#xff0c;就不用show方法了吧。&lt;br /&gt;仅供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-comment\"&gt;/*  求三个长方体的体积\n    成员函数&amp;#xff1a;\n    &amp;#xff08;1&amp;#xff09;计算体积\n    &amp;#xff08;2&amp;#xff09;输出三个长方体的体积\n    数据成员&amp;#xff1a;\n    长&amp;#xff08;length&amp;#xff09;宽&amp;#xff08;width&amp;#xff09;高&amp;#xff08;height&amp;#xff09;\n*/&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//定义类&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Box&lt;/span&gt; {\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-comment\"&gt;//带默认参数的构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Box&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; l &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; w &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; h &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;) :&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;(l), &lt;span class=\"hljs-built_in\"&gt;width&lt;/span&gt;(w), &lt;span class=\"hljs-built_in\"&gt;height&lt;/span&gt;(h) { }\n    &lt;span class=\"hljs-comment\"&gt;//功能&amp;#xff1a;计算、输出&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;vol_&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//void show();&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//重载 &amp;lt;&amp;lt; 操作符&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;out, Box &amp;amp;b);\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; length;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; width;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; height;\n};\n&lt;span class=\"hljs-comment\"&gt;//计算函数的实现&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Box::vol_&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; length * width*height;\n}\n&lt;span class=\"hljs-comment\"&gt;//输出函数的实现 可去掉&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;/*\nvoid Box::show() {\n    cout &amp;lt;&amp;lt; vol_() &amp;lt;&amp;lt; endl;\n}*/&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//重载函数的实现&lt;/span&gt;\nostream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;out, Box &amp;amp; b) {\n    out &amp;lt;&amp;lt; b.&lt;span class=\"hljs-built_in\"&gt;vol_&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; out;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Box box1;\n    &lt;span class=\"hljs-function\"&gt;Box &lt;span class=\"hljs-title\"&gt;box2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;18&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Box &lt;span class=\"hljs-title\"&gt;box3&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;26&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; box1 &amp;lt;&amp;lt;endl;\n    Box a[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; { box1,box2,box3 };\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; endl;\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载插入流运算符输出对象数组的元素如何实现？", ["使用对象数组求长方体体积", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "/*  求三个长方体的体积 \n    成员函数：\n    （1）计算体积\n    （2）输出三个长方体的体积\n    数据成员：\n    长（length）宽（width）高（height）\n*/", "\n", "//定义类", "\n", "class", " ", "Box", "{\n", "public", ":\n    ", "//带默认参数的构造函数", "\n    ", "Box", "(", "float", " l=", "10", ",", "float", " w=", "10", ",", "float", " h=", "10", "):", "length", "(l),", "width", "(w),", "height", "(h){}\n    ", "//功能：计算、输出", "\n    ", "float", " ", "vol_", "()", ";\n    ", "void", " ", "show", "()", ";\n    ", "//重载 << 操作符", "\n    ", "friend", " ostream & ", "operator", "<<(ostream &out,Box &b);\n", "private", ":\n    ", "float", " length;\n    ", "float", " width;\n    ", "float", " height;\n    ", "float", " vol; \n};\n", "//计算函数的实现", "\n", "float", " ", "Box::vol_", "()", "{\n    vol=length*width*height;\n     ", "return", " vol;\n}\n", "//输出函数的实现", "\n", "void", " ", "Box::show", "()", "{\n    cout<<vol<<endl;\n}\n", "//重载函数的实现", "\nostream & ", "operator", "<<(ostream &out,Box & b){\n    out<<b.vol;\n    ", "return", " out;\n}\n", "int", " ", "main", "()", "\n", "{\n    Box box1;\n    ", "Box ", "box2", "(", "15", ",", "18", ",", "20", ")", ";\n    ", "Box ", "box3", "(", "16", ",", "20", ",", "26", ")", ";\n    cout<<box1;\n    Box a[", "3", "]={box1,box2,box3};\n    ", "for", "(", "int", " i=", "0", ";i<", "3", ";i++){\n        cout<<a[i]<<endl;\n    }\n    \n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n", "\n", " 原本是一个简单的对象数组的使用，但是我自行加入了运算符重载，于是就涉及到地址与值输出的相关知识。结果显示的是地址不是值，对于对象数组，不知道应该怎么修改代码得以实现输出值的目的，希望可以得到能人指点一二（根源是基础知识不扎实，最好可以说说原理），谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;第二个参数改为&lt;code class=\"language-javascript\"&gt;const Person3&amp;amp;&lt;/code&gt;&amp;#xff0c;因为后缀&amp;#43;&amp;#43;返回的类型是&lt;code class=\"language-javascript\"&gt;const Person3&lt;/code&gt;&amp;#xff0c;不能传递给&lt;code class=\"language-javascript\"&gt;Person3&amp;amp;&lt;/code&gt;类型&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++中重载自增时 cout与++出错", ["\n", "完整代码如下：", "\n", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Person3", " {\n    ", "friend", " ostream& ", "operator", "<<(ostream& cout, Person3& p1);\n", "public", ":\n\n\n    ", "Person3", "(", "int", " a, ", "int", " b) :", "m_A", "(a), ", "m_B", "(b) {\n    }\n\n    Person3& ", "operator", "++() { \n        ", "this", "->m_A += ", "10", ";\n        ", "this", "->m_B += ", "10", ";\n        ", "return", " *", "this", ";\n    }\n\n    ", "//返回值", "\n    ", "const", " Person3 ", "operator", "++(", "int", ") { \n        Person3 temp = *", "this", ";\n        ", "this", "->m_A += ", "10", ";\n        ", "this", "->m_B += ", "10", ";\n        ", "return", " temp;\n    }\n\n", "private", ":\n    ", "int", " m_A;\n    ", "int", " m_B;\n};\n\n\n", "//运算符重载函数的重载", "\nostream& ", "operator", "<<(ostream& cout, Person3& p1) {\n    cout << ", "\"m_A = \"", " << p1.m_A << ", "\"  m_b= \"", " << p1.m_B;\n    ", "return", " cout;\n}\n\n", "void", " ", "test02", "()", " ", "{\n    ", "Person3 ", "p1", "(", "10", ", ", "10", ")", ";\n    ", "Person3 ", "p2", "(", "50", ", ", "50", ")", ";\n    cout << p1 << endl;\n    cout << ++(++p1) << endl;\n    p2++;\n    cout << p2 << endl;\n    cout << p2++ << endl;\n}\n\n\n", "int", " ", "main", "()", " ", "{\n    ", "test02", "();\n\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Here's a neat little trick I recently found out:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class Foo {\n    public $a;\n    public $b;\n\n    public function __toString() {\n        return (string)$this-&amp;gt;a;\n    }\n\n    public function __construct($a, $b) {\n         $this-&amp;gt;a = $a;\n         $this-&amp;gt;b = $b;\n    }\n\n}\n\n$a = new Foo(1, 'a');\n$b = new Foo(2, 'b');\n$c = new Foo(3, 'c');\n$d = new Foo(2, 'd');\n$array = array($a, $b);\n\n$key = array_search($d, $array);         // false\n\n$key = array_search((string)$c, $array); // false\n$key = array_search((string)$d, $array); // 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This also works:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$is_equal = ((string)$d == $b);          // true\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;When passed a string &lt;em&gt;$needle&lt;/em&gt;, &lt;code&gt;array_search&lt;/code&gt; will try to cast the objects contained in &lt;em&gt;$haystack&lt;/em&gt; to string to compare them, by calling the &lt;code&gt;__toString&lt;/code&gt; magic method if it exists, which in this case returns &lt;code&gt;Foo::$a&lt;/code&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "运算符重载", "Question": ["php重载equals-operator", ["\n\n", "In a PHP program I have an array of some custom objects, and I want to find if the array contains a certain object. Of course I can use array_search, but this checks if the objects are the same object, not if it has the same variables. So I want to be able to create my own compare function for the objects, which I can use with the array_search method (or something similar).\nI want to be able to do something like this:", "\n\n", "class foo\n{\n    public $_a,$_b;\n    function __construct($a,$b)\n    {\n        $this->_a = $a;\n        $this->_b = $b;\n    }\n\n    function __equals($object)\n    {\n        return $this->_a == $object->_a;\n    }\n}\n$f1 = new foo(5,4);\n$f2 = new foo(4,6);\n$f3 = new foo(4,5);\n\n$array = array($f1,$f2);\n$idx = array_search($f3,$array); // return 0\n", "\n\n", "Is something like this possible?\nI know I can also create my own array_search method which uses a method from the class, but than I'd have to use 2 different search functions, one for the classes which do have their own compare function, and one for those which haven't.", "\n    "]], "Tag": "程序设计"}
{"Answer": "operator new是 重载new运算符的函数\r\nhttps://blog.csdn.net/zxx910509/article/details/64905107", "Konwledge_Point": "运算符重载", "Question": ["operator new是普通函数还是重载new运算符的函数", ["1、如果operator new是重载new运算符，那为什么new关键字可以正常使用，如", "\n            class A{};", "\n            A *p = new A;", "\n                    //为何不是调用operator new函数而是new关键字，我试过重载函数void *operator new(A)但是函数编译会报错，提示第一个参数要是size_t类型", "\n            还有int *p=(int *)new(sizeof(int));同样会报错", "\n\n", "2、如果operator new只是单纯的是一个库函数而不是重载，那为什么该函数名中     间可以用空格"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/078184802556183.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["求解这个错误在哪里我有点不明白", ["这个运算符重载我不知道哪里出错的求解 他没显示错误在哪里 但是我也找不到"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运算符重载是类里的说法&amp;#xff0c;你的Real类实现什么功能&amp;#xff1f;把代码贴出来&lt;br /&gt;flag&amp;#61;true这句话目前看着没有用处&lt;br /&gt;运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/173031900176111.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Real&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; val;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Real&lt;/span&gt;() { val &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; }\n    &lt;span class=\"hljs-built_in\"&gt;Real&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; v)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (v &amp;lt; &lt;span class=\"hljs-number\"&gt;-3.4e38&lt;/span&gt; || v&amp;gt;&lt;span class=\"hljs-number\"&gt;3.4e38&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Data Overflow&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            val &amp;#61; (&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;)v;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;display&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        cout &amp;lt;&amp;lt; val &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Real&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Real&amp;amp; a, Real&amp;amp; b);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Real&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(Real&amp;amp; a, Real&amp;amp; b);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Real&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;*(Real&amp;amp; a, Real&amp;amp; b);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Real&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;/(Real&amp;amp; a, Real&amp;amp; b);\n};\n\nReal&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Real&amp;amp; a, Real&amp;amp; b)\n{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; v &amp;#61; a.val &amp;#43; b.val;\n    &lt;span class=\"hljs-function\"&gt;Real &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(v)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n}\nReal&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(Real&amp;amp; a, Real&amp;amp; b)\n{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; v &amp;#61; a.val - b.val;\n    &lt;span class=\"hljs-function\"&gt;Real &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(v)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n}\nReal&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;*(Real&amp;amp; a, Real&amp;amp; b)\n{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; v &amp;#61; a.val * b.val;\n    &lt;span class=\"hljs-function\"&gt;Real &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(v)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n}\nReal&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;/(Real&amp;amp; a, Real&amp;amp; b)\n{\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; v &amp;#61; a.val / b.val;\n    &lt;span class=\"hljs-function\"&gt;Real &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(v)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; a, b;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; op;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; op)\n    {\n        &lt;span class=\"hljs-function\"&gt;Real &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(a)&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;B&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(b)&lt;/span&gt;, C&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (op &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;) {\n            C &amp;#61; A &amp;#43; B;\n            C.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (op &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;) {\n            C &amp;#61; A - B;\n            C.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (op &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;) {\n            C &amp;#61; A * B;\n            C.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (op &amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;) {\n            C &amp;#61; A / B;\n            C.&lt;span class=\"hljs-built_in\"&gt;display&lt;/span&gt;();\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++重载运算符问题", ["\n", "如何重载加减乘除运算符，还有图片中flag＝true是什么意思"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;理论上都是可以的&amp;#xff0c;但是要注意避免造成无限递归。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++重载运算符函数中递归运算如何使用重载运算符", ["先已将AddDays函数重载为+运算符了，可是原来AddDays函数中递归运算AddDays（rem_days）这一行该如何改写呢？是+rem_days吗？还是operator+（rem_days）吗？还是别的呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果要对等号的返回值做修改,则返回值应为一个引用类型&lt;br /&gt;B选项中,因为要修改t2,而t2又是通过t1的等号重载进行赋值的,所以t1的重载返回值应为 &lt;code class=\"language-javascript\"&gt;type &amp;amp;&lt;/code&gt;而不是&lt;code class=\"language-javascript\"&gt;type&lt;/code&gt;&lt;br /&gt;C选项中因为只用到了赋值而没有涉及到修改,所以代码合法.&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;有帮助望采纳~&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++重载运算符的问题", ["\n", "这个c++重载运算符的问题", "这个问题b c选项都不明白", "想知道为什么"]], "Tag": "程序设计"}
{"Answer": "# 问题如果解决，请点下`采纳`\r\n```\r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\n \r\nclass A\r\n{\r\npublic:\r\n\tA(){}\r\n\tA(int _a, int _b)\r\n\t{\r\n\t\ta = _a;\r\n\t\tb = _b;\r\n\t}\r\n \r\n\tA operator+(A other)\r\n\t{\r\n\t\tA a1(a + other.a, b + other.b);\r\n\t\treturn a1;\r\n\t}\r\n\tvoid show()\r\n\t{\r\n\t\tcout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; endl;\r\n\t}\r\nprivate:\r\n\tint a;\r\n\tint b;\r\n};\r\n \r\nint main()\r\n{\r\n\tint a = 1, b = 2, c = 3, d = 4;\r\n\tA a1(a, b);\r\n\tA a2(c, d);\r\n\tA a3 = a1 + a2;\r\n\ta3.show();\r\n\treturn 0;\r\n}\r\n```", "Konwledge_Point": "运算符重载", "Question": ["C++重载运算符加减乘除。", ["C++如何用class重载+号实现（a,b)+(c,d)=(a+c,b+d)。"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\nclass Shape\r\n{\r\npublic:\r\n\tstring name;\r\n\tShape(string n) : name(n) { }\r\n\tvirtual void area() = 0;\r\n};\r\nclass Rectangle : public Shape\r\n{\r\nprivate:\r\n\tint abs(int n) { return n &gt; 0 ? n : -n; }\r\npublic:\r\n\tint width;\r\n\tint height;\r\n\tRectangle(string n, int w, int h) : Shape(n), width(w), height(h) { }\r\n\tint operator -(const Rectangle r)    \r\n    {\r\n        return abs(width * height - r.width * r.height);\r\n\t}\r\n\tvoid area()\r\n\t{\r\n\t\tcout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; width * height &lt;&lt; endl;\r\n\t}\r\n};\r\nclass Circle : public Shape\r\n{\r\npublic:\r\n\tint radius;\r\n\tCircle(string n, int r) : Shape(n), radius(r) { }\r\n\tvoid area()\r\n\t{\r\n\t\tcout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; radius * radius * 3.14 &lt;&lt; endl;\r\n\t}\r\n};\r\nint main()\r\n{\r\n\tRectangle r1(\"r1\", 3, 6), r2(\"r2\", 1, 1);\r\n\tr1.area();\r\n\tr2.area();\r\n\tcout &lt;&lt; r1 - r2 &lt;&lt; endl;\r\n\tcout &lt;&lt; r2 - r1 &lt;&lt; endl;\r\n\tCircle c(\"c\", 3);\r\n\tc.area();\r\n\treturn 0;\r\n}\r\n```\r\nr1 18\r\nr2 1\r\n17\r\n17\r\nc 28.26\r\n\r\n# 问题解决的话，请点下采纳", "Konwledge_Point": "运算符重载", "Question": ["计算机小白遇到一道C++题目，麻烦大神帮忙指点迷津", ["\n\n", "题目说明如上图，这个运算符重载搞不明白啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果 是demo,则必然发生一次复制&amp;#xff0c;效率低。还有最好是const Demo&amp;amp; ,否则 &lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-title class_\"&gt;Demo&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;getDemo&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;){\n   &lt;span class=\"hljs-title class_\"&gt;Demo&lt;/span&gt; res;\n    ....\n\n   &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; res;\n}\n&lt;span class=\"hljs-title class_\"&gt;Demo&lt;/span&gt; a;\na&amp;#43;&amp;#61;&lt;span class=\"hljs-title function_\"&gt;getDemo&lt;/span&gt;();&lt;span class=\"hljs-comment\"&gt;//出错&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["类的相加和+=，中关于&的问题。", ["运算符重载时第一个直接时Dmeo,第为个为啥要用 &。第一个 里面c收对象，第二里面a也时个对象，为啥用的不一样？", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdlib.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Point  &lt;span class=\"hljs-comment\"&gt;//点类&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; px,py; &lt;span class=\"hljs-comment\"&gt;//x和y坐标值&lt;/span&gt;\npublic:\n    &lt;span class=\"hljs-constructor\"&gt;Point()&lt;/span&gt; {}&lt;span class=\"hljs-comment\"&gt;//默认无参构造函数&lt;/span&gt;\n    ~&lt;span class=\"hljs-constructor\"&gt;Point()&lt;/span&gt; {}&lt;span class=\"hljs-comment\"&gt;//析构函数&lt;/span&gt;\n    &lt;span class=\"hljs-constructor\"&gt;Point(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt; {px &amp;#61; x;py &amp;#61; y;} &lt;span class=\"hljs-comment\"&gt;//带参构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-constructor\"&gt;Point(Point &amp;amp;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt; {px &amp;#61; p.get&lt;span class=\"hljs-constructor\"&gt;X()&lt;/span&gt;;py &amp;#61; p.get&lt;span class=\"hljs-constructor\"&gt;Y()&lt;/span&gt;;} &lt;span class=\"hljs-comment\"&gt;//拷贝构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;X()&lt;/span&gt; {return px;}\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;Y()&lt;/span&gt; {return py;}\n    void set&lt;span class=\"hljs-constructor\"&gt;X(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;)&lt;/span&gt; {px &amp;#61; x;}\n    void set&lt;span class=\"hljs-constructor\"&gt;Y(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt; {py &amp;#61; y;}\n};\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Circle : public Point\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; radius;\npublic:\n    &lt;span class=\"hljs-constructor\"&gt;Circle()&lt;/span&gt; {}\n    ~&lt;span class=\"hljs-constructor\"&gt;Circle()&lt;/span&gt; {}\n    &lt;span class=\"hljs-constructor\"&gt;Circle(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;r&lt;/span&gt;)&lt;/span&gt; : &lt;span class=\"hljs-constructor\"&gt;Point(&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;{radius &amp;#61; r;}\n    &lt;span class=\"hljs-constructor\"&gt;Circle(Circle &amp;amp;&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;)&lt;/span&gt; {radius &amp;#61; c.get&lt;span class=\"hljs-constructor\"&gt;R()&lt;/span&gt;;set&lt;span class=\"hljs-constructor\"&gt;X(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getX&lt;/span&gt;()&lt;/span&gt;);set&lt;span class=\"hljs-constructor\"&gt;Y(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getY&lt;/span&gt;()&lt;/span&gt;);}\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;R()&lt;/span&gt; {return radius;}\n    void set&lt;span class=\"hljs-constructor\"&gt;R(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;r&lt;/span&gt;)&lt;/span&gt; {radius &amp;#61; r;}\n    &lt;span class=\"hljs-keyword\"&gt;virtual&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;Area()&lt;/span&gt; {return &lt;span class=\"hljs-number\"&gt;3.14159&lt;/span&gt;*radius*radius;}  &lt;span class=\"hljs-comment\"&gt;//虚函数&amp;#xff0c;计算面积&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Cylinder : public Circle\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; high;\npublic:\n    &lt;span class=\"hljs-constructor\"&gt;Cylinder()&lt;/span&gt; {}\n    ~&lt;span class=\"hljs-constructor\"&gt;Cylinder()&lt;/span&gt; {}\n    &lt;span class=\"hljs-constructor\"&gt;Cylinder(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;r&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;h&lt;/span&gt;)&lt;/span&gt; : &lt;span class=\"hljs-constructor\"&gt;Circle(&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;r&lt;/span&gt;)&lt;/span&gt;{high &amp;#61; h;}\n    &lt;span class=\"hljs-constructor\"&gt;Cylinder(Cylinder &amp;amp;&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;)&lt;/span&gt; {high &amp;#61; c.get&lt;span class=\"hljs-constructor\"&gt;H()&lt;/span&gt;;set&lt;span class=\"hljs-constructor\"&gt;R(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getR&lt;/span&gt;()&lt;/span&gt;);set&lt;span class=\"hljs-constructor\"&gt;X(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getX&lt;/span&gt;()&lt;/span&gt;);set&lt;span class=\"hljs-constructor\"&gt;Y(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getY&lt;/span&gt;()&lt;/span&gt;);}\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;H()&lt;/span&gt; {return high;}\n    void set&lt;span class=\"hljs-constructor\"&gt;H(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;h&lt;/span&gt;)&lt;/span&gt; {high &amp;#61; h;}\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;Volume()&lt;/span&gt; {return Circle::get&lt;span class=\"hljs-constructor\"&gt;Area()&lt;/span&gt;*high;}  &lt;span class=\"hljs-comment\"&gt;//计算体积&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; get&lt;span class=\"hljs-constructor\"&gt;Area()&lt;/span&gt; {return &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;3.14159&lt;/span&gt;*get&lt;span class=\"hljs-constructor\"&gt;R()&lt;/span&gt;*high;} &lt;span class=\"hljs-comment\"&gt;//计算面积&lt;/span&gt;\n    void operator &amp;#61; (Cylinder &amp;amp;c) {high &amp;#61; c.get&lt;span class=\"hljs-constructor\"&gt;H()&lt;/span&gt;;set&lt;span class=\"hljs-constructor\"&gt;R(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getR&lt;/span&gt;()&lt;/span&gt;);set&lt;span class=\"hljs-constructor\"&gt;X(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getX&lt;/span&gt;()&lt;/span&gt;);set&lt;span class=\"hljs-constructor\"&gt;Y(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;getY&lt;/span&gt;()&lt;/span&gt;);}  &lt;span class=\"hljs-comment\"&gt;//赋值操作符重载&lt;/span&gt;\n    friend &lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; operator&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;(Cylinder &amp;amp;c1,Cylinder &amp;amp;c2);&lt;span class=\"hljs-comment\"&gt;//等于操作符重载&lt;/span&gt;\n};\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; operator&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;(Cylinder &amp;amp;c1,Cylinder &amp;amp;c2)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(c1.get&lt;span class=\"hljs-constructor\"&gt;X()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;c2.get&lt;span class=\"hljs-constructor\"&gt;X()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;amp;&amp;amp; &lt;/span&gt;c1.get&lt;span class=\"hljs-constructor\"&gt;Y()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;c2.get&lt;span class=\"hljs-constructor\"&gt;Y()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;amp;&amp;amp; &lt;/span&gt;c1.get&lt;span class=\"hljs-constructor\"&gt;R()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;c2.get&lt;span class=\"hljs-constructor\"&gt;R()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;amp;&amp;amp; &lt;/span&gt;c1.get&lt;span class=\"hljs-constructor\"&gt;H()&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;c2.get&lt;span class=\"hljs-constructor\"&gt;H()&lt;/span&gt;)\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    Cylinder c1(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;);\n    Cylinder c2(c1);            &lt;span class=\"hljs-comment\"&gt;//拷贝构造函数测试&lt;/span&gt;\n    Cylinder c3 &amp;#61; c1;    &lt;span class=\"hljs-comment\"&gt;//赋值操作符测试&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(c3&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;c2)    &lt;span class=\"hljs-comment\"&gt;//等于操作符测试&lt;/span&gt;\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c3与c2相等&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;圆柱体积为&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;c3.get&lt;span class=\"hljs-constructor\"&gt;Volume()&lt;/span&gt;&amp;lt;&amp;lt;endl;    &lt;span class=\"hljs-comment\"&gt;//强制调用基类虚函数测试&lt;/span&gt;\n    Circle *p &amp;#61; &amp;amp;c1;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;圆柱面积为&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;get&lt;span class=\"hljs-constructor\"&gt;Area()&lt;/span&gt;&amp;lt;&amp;lt;endl;  &lt;span class=\"hljs-comment\"&gt;//虚函数测试&lt;/span&gt;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["刚刚学，不太懂。有人可以帮写并给点注释吗？", ["C++", "1.点-圆-圆柱", "2.覆盖面向对象程序设计中的封装、继承和多态三大基本特征。", "3.基类和派生类分别拥有不少于6个成员函数(函数功能可自行确定)，至少包括构造函数、拷贝构造函数和析构函数。", "4.在基类或派生类中进行运算符重载的操作，所重载的运算符不限，但个数至少为2个，一个重载为成员函数，一个重载为友元函数。"]], "Tag": "程序设计"}
{"Answer": "```\r\n// Q706325.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n#include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nclass ARRAY{ //数组 类\r\nint N;\r\nint *arr;\r\npublic:\r\nARRAY();\r\nARRAY(int *b,int m);\r\n~ARRAY(){delete []arr;}\r\nvoid setfirst(int a){ *arr=a;}\r\n\r\nvoid show(); \r\nARRAY&amp; operator=(ARRAY&amp; b); //改这里\r\n};\r\nARRAY&amp; ARRAY::operator=(ARRAY&amp; b){ // 重载 = 改这里\r\nN=b.N;\r\narr=new int[N];\r\nfor(int i=0;i&lt;N;i++)\r\narr[i]=b.arr[i];\r\nreturn *this;\r\n}\r\nARRAY::ARRAY(){ //构造函数\r\nN=10;\r\narr=new int[N];\r\nfor(int i=0;i&lt;N;i++){\r\narr[i]=0;\r\n}\r\n}\r\nARRAY::ARRAY(int *b,int m){ //构造函数\r\nN=m;\r\narr=new int[N];\r\nfor(int i=0;i&lt;N;i++){\r\narr[i]=b[i];}\r\n}\r\nvoid ARRAY::show(){ //显示\r\nfor(int i=0;i&lt;N;i++){cout&lt;&lt;arr[i]&lt;&lt;' ';}\r\ncout&lt;&lt;endl;\r\n}\r\nvoid main(){\r\nint d[10]={1,2,3,4,5,6,7,8,9,10};\r\nint N=9;\r\nARRAY a(d,N);\r\nARRAY b;\r\na.show();\r\nb.show();\r\nb=a;            //赋值 ？？？？？？？？\r\ncout&lt;&lt;\"*************\\n\";\r\na.show();               //显示出错\r\nb.show();\r\ncout&lt;&lt;\"*************\\n\";\r\na.setfirst(10);\r\na.show();\r\nb.show();\r\ncout&lt;&lt;\"*************\\n\";\r\nwhile(1);\r\n}\r\n\r\n```\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201810/31/1540977180_271376.gif)\r\n\r\n`如果问题得到解决，请点我回答投票箭头下面的采纳`", "Konwledge_Point": "运算符重载", "Question": ["C++等号运算符‘=’重载问题，显示乱码。", ["c++中定义两个数组类，重载‘=’运算符，令其按位赋值而非直接地址赋值，调用重载操作符后，显示乱码， 刚开始学习c++，求大神帮忙", "\n\n", "class ARRAY{   //数组 类", "\n    int N;", "\n    int *arr;", "\npublic:", "\n    ARRAY();", "\n    ARRAY(int *b,int m);", "\n    ~ARRAY(){delete []arr;}", "\n    void setfirst(int a){ *arr=a;}", "\n    void show(); ", "\n    ARRAY operator=(ARRAY b);", "\n\n", "};", "\nARRAY ARRAY::operator=(ARRAY b){      // 重载 =", "\n        N=b.N;", "\n        arr=new int[N];", "\n        for(int i=0;i<N;i++)", "\n            arr[i]=b.arr[i];", "\n        return *this;", "\n}", "\nARRAY::ARRAY(){                   //构造函数", "\n    N=10;", "\n    arr=new int[N];", "\n    for(int i=0;i<N;i++){", "\n        arr[i]=0;", "\n    }", "\n}", "\nARRAY::ARRAY(int *b,int m){              //构造函数", "\n    N=m;", "\n    arr=new int[N];", "\n    for(int i=0;i<N;i++){", "\n        arr[i]=b[i];}", "\n}", "\nvoid ARRAY::show(){             //显示", "\n   for(int i=0;i<N;i++){cout<<arr[i]<<' ';}", "\n   cout<<endl;", "\n}", "\nvoid main(){", "\n    int d[10]={1,2,3,4,5,6,7,8,9,10};", "\n    int N=9;", "\n    ARRAY a(d,N);", "\n    ARRAY b;", "\n    a.show();", "\n    b.show();", "\n\n", "b=a;            //赋值 ？？？？？？？？\ncout<<\"*************\\n\";\na.show();               //显示出错\nb.show();\ncout<<\"*************\\n\";\na.setfirst(10);\na.show();\nb.show();\ncout<<\"*************\\n\";\nwhile(1);\n", "\n\n", "}", "\n重载=后显示如下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;当然不包含&lt;br /&gt;所谓运算符重载&amp;#xff0c;重载的是你自己类里的相关计算法则&lt;br /&gt;你把自己的类型的加法改的再花花&amp;#xff0c;也改变不了1&amp;#43;1&amp;#61;&amp;#61;2&amp;#xff0c;因为1和2是int型&amp;#xff0c;不是你的自定义类型&lt;br /&gt;同理&amp;#xff0c;cin&amp;gt;&amp;gt;里面的符号是在cin里面定义的&amp;#xff0c;不是你定义的&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载运算符包含cin>>吗", ["蒟蒻小问 重载运算符包含cin>>吗？ 欢迎神犇讲解（我没钱……）"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/rl529014/article/details/50099329", "Konwledge_Point": "运算符重载", "Question": ["请问怎么重载<<流运算符实现输出函数的函数的地址？函数地址变量怎么输出？", ["请问怎么重载<<流运算符实现输出函数的函数的地址？函数地址变量怎么输出？"]], "Tag": "程序设计"}
{"Answer": "你可以在CSDN搜索上搜一搜关于[“模板特例化”](https://so.csdn.net/so/search/s.do?q=%E6%A8%A1%E6%9D%BF%E7%89%B9%E4%BE%8B%E5%8C%96+C%2B%2B&amp;t=&amp;o=&amp;s=&amp;l= \"查询结果的网址\")的资料。\r\noperator bool() 是运算符重载。", "Konwledge_Point": "运算符重载", "Question": ["c++ 模板编程的代码什么意思", ["template<typename T1, typename T2>\nstruct is__same\n{\n    operator bool()\n    {\n        return false;\n    }\n};\ntemplate<typename T1>\nstruct is__same<T1, T1>\n{\n    operator bool()\n    {\n        return true;\n    }\n};\n", "\n\n", "operator bool() 是运算符重载吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ABD&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于运算符不能被重载的疑问", ["关于运算符不能被重载的疑问，有点困惑，请问有没有会这个的，帮解一下可以么，"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;一般写const Array &amp;amp;new_this&amp;#xff0c;使用引用类型传递&amp;#xff0c;否则在变量赋值过程中&amp;#xff0c;可能产生隐形变量&amp;#xff0c;一旦自动回收&amp;#xff0c;p指针就会被delete&amp;#xff0c;导致其它赋值变量的p变成野指针&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载输出运算符调用之后无法析构", ["这是析构函数", "这是调用了输出运算符", "这是没有调用，程序正常退出了", "这是重载的输出运算符函数"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先肯定是可行的。问题可能是少了个inline&amp;#xff0c;但是没有inline一般只会报重复定义的错误。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["使用类模板时，是不是不能用重载运算符<<输出对象", ["\n", "想用重载运算符<<作为友元，输出类对象，但是显示错误，是因为使用了类模板吗？如果是，怎么解决？如果还是想用类模板"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;进行u &amp;#43; 3的计算时&amp;#xff0c;编译器不会报错&amp;#xff0c;因为已经在该行上实现了隐式类型转换。&lt;/p&gt;\n&lt;p&gt;如果在类中没有定义适当的运算符重载函数&amp;#xff0c;则编译器将尝试使用隐式类型转换将一个数字转换为类对象。&lt;/p&gt;\n&lt;p&gt;因此&amp;#xff0c;进行数字&amp;#43;向量 / 向量&amp;#43;数字的加法时&amp;#xff0c;编译器将使用只重载了向量&amp;#43;向量的加法运算&amp;#xff0c;并且结果是有效的。&lt;/p&gt;\n&lt;p&gt;如果禁止这种情况&amp;#xff0c;则可以在类中定义适当的运算符重载函数&amp;#xff0c;以在不合法的情况下抛出编译错误。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Vector&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x;\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; y;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;Vector&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; a &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; b &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;): x{a}, y{b} {}\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getx&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; x;}\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;gety&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; y;}\n        Vector &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Vector &amp;amp;rhs) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;;\n};\n \nVector Vector::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Vector &amp;amp;rhs) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Vector&lt;/span&gt;(x &amp;#43; rhs.x, y &amp;#43; rhs.y);\n}\n\nVector &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; lhs, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Vector &amp;amp;rhs) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Vector&lt;/span&gt;(lhs &amp;#43; rhs.&lt;span class=\"hljs-built_in\"&gt;getx&lt;/span&gt;(), lhs &amp;#43; rhs.&lt;span class=\"hljs-built_in\"&gt;gety&lt;/span&gt;());\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载运算符时遇到的疑惑", ["为class重载运算符时出现的一些疑惑", "\n", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Vector", "{\n    ", "private", ":\n        ", "double", " x;\n        ", "double", " y;\n    ", "public", ":\n        ", "Vector", "(", "double", " a = ", "0", ", ", "double", " b = ", "0", "): x{a}, y{b} {}\n        ", "void", " ", "print", "()", ";\n        ", "double", " ", "getx", "()", " ", "const", " ", "{", "return", " x;}\n        ", "double", " ", "gety", "()", " ", "const", " ", "{", "return", " y;}\n        \n};\n\n", "void", " ", "Vector::print", "()", " ", "{\n    cout << ", "\"(\"", " << x << ", "\",\"", " << y << ", "\")\"", " << endl;\n}\n\nVector ", "operator", "+(", "const", " Vector& v1, ", "const", " Vector& v2) {\n    ", "return", " ", "Vector", "(v1.", "getx", "()+v2.", "getx", "(), v1.", "gety", "()+v2.", "gety", "());\n}\n", "\n", "以上代码创建了向量这种变量，并重载运算符+为向量加法", "但是进行数字+向量 / 向量+数字的加法时，仍然可以调用只重载了向量+向量的加法运算", "比如：", "\n", "int", " ", "main", "()", " ", "{\n  ", "Vector ", "u", "(", "1", ",", "2", ")", ", v", ";\n  v = u+", "3", ";\n  v.", "print", "(); ", "// 输出是：(4,2)", "\n  ", "return", " ", "0", ";\n}\n", "\n", "按理来说不应该会由于没有匹配的运算符而报错吗？为什么能正常运行呢？", "希望得到解释，提前谢谢答者！", "\n", "补：漏了一个关键信息，非常对不起。在我给构造函数加上默认值之前是会报错的，但是加上默认值之后就能正常运行了。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;跑了下&amp;#xff0c;没出现这个报错&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/261652178186196.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++\"+=\"运算符的重载", ["+=运算符重载时报错，", "报错内容为： recipe commences before first target.  Stop.", "以下为我的源代码", "\n", "以下为报错图片", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;以下答案引用自GPT-3大模型,请合理使用&amp;#xff1a;&lt;br /&gt;答&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;自定义Time类&amp;#xff0c;写有double转Time和Time转double的转换构造函数&amp;#xff0c;类内重载加号运算符。本来以为写Time1&amp;#61;double1&amp;#43;Time2会引发二义性&amp;#xff0c;既可以理解为将d1转换为Time类之后与t2相加&amp;#xff08;此时d1转换后为Time类符合类内运算符重载规则&amp;#xff09;&amp;#xff0c;也可以理解为t2转换为double型之后相加所得&amp;#xff0c;转化成time后赋给t2&amp;#xff0c;但是最后正常运行。&lt;/p&gt;\n&lt;p&gt;错在哪里呢&amp;#xff1f;&lt;/p&gt;\n&lt;p&gt;在C&amp;#43;&amp;#43;中&amp;#xff0c;类重载的运算符优先级高于类内的运算符。即当在类中定义了一个重载的运算符时&amp;#xff0c;编译器会自动推导出其他的运算符。在上例中&amp;#xff0c;t2&amp;#61;d1&amp;#43;t2; 其实就是t2&amp;#61;d1&amp;#43;Time(t2);&amp;#xff0c;由于类内已经定义了运算符&amp;#43;&amp;#xff0c;因此会自动调用类内的&amp;#43;。这里需要特别注意的是&amp;#xff0c;类重载的运算符必须要求参数的类型相同。因此在上面的例子中&amp;#xff0c;t1和t2的类型必须相同&amp;#xff0c;即 both of t1 and t2 must be of type Time.&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["转换构造函数造成的二义性问题", ["问题描述：", "自定义Time类，写有double转Time和Time转double的转换构造函数，类内重载加号运算符，本来以为写Time1=double1+Time2会引发二义性，", "既可以理解为将d1转换为Time类之后与t2相加（此时d1转换后为Time类符合类内运算符重载规则），也可以理解为t2转换为double型之后相加所得，转化成time后赋给t2，但是最后正常运行，想问一下我在哪里理解错误。", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "Time", " \n{\n", "public", ":\n    Time ", "operator", "+(", "const", " Time& t1)\n    {\n        ", "return", " ", "Time", "(hour + t1.hour, minute + t1.minute, second + t1.second);\n    }\n    ", "Time", "(", "int", " h,", "int", " m,", "int", " s):", "hour", "(h),", "minute", "(m),", "second", "(s){}\n    ", "Time", "(", "double", " d)\n    {\n        hour = d;\n    }\n    ", "operator", " ", "double", "()", "\n    ", "{\n        ", "return", " hour;\n    }\n", "private", ":\n    ", "int", " hour;\n    ", "int", " minute;\n    ", "int", " second;\n};\n", "int", " ", "main", "()", "\n", "{\n    ", "Time ", "t1", "(", "10", ",", "10", ",", "10", ")", ";\n    ", "Time ", "t2", "(t1)", ";\n    ", "double", " d1 = ", "10", ", d2 = ", "5", ";\n    t2 = d1+t2;", "//既可以理解为将d1转换为Time类之后与t2相加（此时d1转换后为Time类符合类内运算符重载规则）", "\n    ", "//也可以理解为t2转换为double型之后相加所得，转化成time后赋给t2；", "\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "应该说，滥用友元会破坏封装性。但是友元的确有它的用处。比如说你在定义数据结构，LinkedList类和Node类，它们就是一对，那么相互访问私有成员是很正常的需求，用友元就很合适。", "Konwledge_Point": "运算符重载", "Question": ["一些C++ 编程问题 :关于友元函数的问题", ["学习C++ 也有一段时间了，在接触完友元的概念后，一直觉得，友元这个概念破坏了面向对象设计的封装性！不知道有没有人有不一样的看法，可以和我讨论一下。", "\n而且友元的具体运用有哪些？目前我只知道在运算符重载(如cout<<)可以用到，还有其他方面的作用吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#include &amp;lt;iostream&amp;gt;\n\nauto &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;() -&amp;gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;\n{\n    unsigned &lt;span class=\"hljs-built_in\"&gt;year&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    unsigned &lt;span class=\"hljs-built_in\"&gt;month&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    unsigned &lt;span class=\"hljs-built_in\"&gt;day&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; chr;\n\n    std::cin &amp;gt;&amp;gt; &lt;span class=\"hljs-built_in\"&gt;year&lt;/span&gt; &amp;gt;&amp;gt; chr &amp;gt;&amp;gt; &lt;span class=\"hljs-built_in\"&gt;month&lt;/span&gt; &amp;gt;&amp;gt; chr &amp;gt;&amp;gt; &lt;span class=\"hljs-built_in\"&gt;day&lt;/span&gt;;\n\n    std::cout &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;year&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;month&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;day&lt;/span&gt;;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++重载输入运算符遇到问题", ["c++重载运算符遇到的问题，想要输入2023-02-01格式，输出2023-02-01格式，以下是我重载的输入输出运算符，并不能成功输出，“-”会影响后面数字的值，该如何重载可以忽略“-”的输入，谢谢各位解答", "\n", "ostream ", "&operator", "<<(ostream ", "&out", ", Date ", "&d", ")\n{\n    ", "return", " ", "out", " << d.year << ", "'-'", " << d.month << ", "'-'", " << d.day;\n}\nistream ", "&operator", ">>(istream ", "&in", ", Date ", "&d", ")\n{\n    ", "return", " ", "in", " >> d.year >> d.month >> d.day;\n}\n\n", "\n", "以下是输出结果，首行为输入，末行为输出", "\n", "arrival on (yyyy-mm-dd): 2022-02-01\n\nCALL CENTER BOOKING REQUEST\n1", " new ", "reservation request standard\n2", " new ", "reservation request superior\n3 show reservation request\n4 show all reservation requests\nyour choice: \n4\n********REQUEST NO:  1********\naccomodation at:     DD\nnumber of guests:    1\nnumber of nights:    1", "\ncheck-in ", "date:       2022-65534-65535\n\n"]], "Tag": "程序设计"}
{"Answer": "https://www.cnblogs.com/Jacket-K/p/7779140.html", "Konwledge_Point": "运算符重载", "Question": ["c++对象返回值一个细节问题。。。", ["#include", "\n#include", "\nusing namespace std;", "\nclass   Location", "\n{", "\npublic:", "\n//带参数的构造函数", "\n    Location(int xx =0,int yy   =0)", "\n    {", "\n        X=xx;", "\n        Y=yy;", "\n        cout<<\"Constructor  Object.\"<<endl;", "\n    }", "\n//copy构造函数完成对象的初始化", "\n    Location(const  Location& obj)//copy构造函数", "\n    {", "\n        X=obj.X;", "\n        Y=obj.Y;", "\n        cout<<\"Copy Constructor.\"<<endl;", "\n    }", "\n    ~Location()", "\n    {", "\n        cout<<X<<\",\"<<Y<<\"  Object  destroyed.\" <<endl;", "\n    }", "\n    int GetX()", "\n    {", "\n        return  X;", "\n    }", "\n    int GetY()", "\n    {", "\n        return  Y;", "\n    }", "\nprivate :", "\n    int X;", "\n    int Y;", "\n};", "\n\n", "Location g()", "\n{", "\n    Location temp(1,2);", "\n    return temp;", "\n}", "\nvoid test1()", "\n{", "\n    g();", "\n}", "\nvoid test2()", "\n{", "\n//用匿名对象初始化m,此时c++编译器直接把匿名对转成m;(扶正)从匿名转成有名字了m", "\n//就是将这个匿名对象起了名字m,他们都是同一个对象", "\n    Location m= g();", "\n    printf(\"匿名对象会扶正,不会被析构掉 \\n\");", "\n    cout<<m.GetX()<<endl;;", "\n}", "\nvoid test3()", "\n{", "\n    //用匿名对象赋值给m2后,匿名对象被析构", "\n    Location m2(1,2);", "\n    m2=g();", "\n    printf(\"因为用匿名对象=给m2,匿名对象被析构\\n\");", "\n    cout<<m2.GetX()<<endl;;", "\n}", "\nint main(void)", "\n{", "\n    test1();", "\n    cout<<\"---------------------\"<<endl;", "\n    test2();", "\n    cout<<\"---------------------\"<<endl;", "\n    test3();", "\n    return 0;", "\n}", "\n\n", "\n\n", "这是网上的一道题，都说", "\nLocation g()", "\n{", "\n    Location temp(1,2);", "\n    return temp;", "\n}", "\n这里返回对象时会调用拷贝构造函数，但这个例子中为什么有没有调用呢，没有打印Copy Constructor.", "\n\n", "而另外一道题", "\n#include ", "\n#include", "\nusing namespace std;", "\nclass String", "\n{", "\nprivate:", "\n    char ", "str;", "\n    int len;", "\npublic:", "\n    String(const char", " s);//构造函数声明", "\n    String operator=(const String& another);//运算符重载，此时返回的是对象", "\n    void show()", "\n    {", "\n        cout << \"value = \" << str << endl;", "\n    }", "\n\n", "/*copy construct*/\nString(const String& other)\n{\n    len = other.len;\n    str = new char[len + 1];\n    strcpy(str, other.str);\n    cout << \"copy construct\" << endl;\n}\n\n~String()\n{\n    delete[] str;\n    cout << \"deconstruct\" << endl;\n}\n", "\n\n", "};", "\n\n", "String::String(const char* s)//构造函数定义", "\n{", "\n    len = strlen(s);", "\n    str = new char[len + 1];", "\n    strcpy(str, s);", "\n}", "\n\n", "String String::operator=(const String &other)//运算符重载", "\n{", "\n    if (this == &other)", "\n        return *this;", "\n\n", "delete[] str;\nlen = other.len;\nstr = new char[len + 1];\nstrcpy(str, other.str);\nreturn *this;\n", "\n\n", "}", "\n\n", "int main()", "\n{", "\n    String str1(\"abc\");", "\n    String str2(\"123\");", "\n    String str3(\"456\");", "\n    str1.show();", "\n    str2.show();", "\n    str3.show();", "\n    str3 = str1 = str2;//str3.operator=(str1.operator=(str2))", "\n    str3.show();", "\n    str1.show();", "\n    return 0;", "\n}", "\n\n", "//运行结果", "\nvalue = abc", "\nvalue = 123", "\nvalue = 456", "\ncopy construct", "\ncopy construct", "\ndeconstruct", "\ndeconstruct", "\nvalue = 123", "\nvalue = 123", "\ndeconstruct", "\ndeconstruct", "\ndeconstruct", "\n同样调用", "\nString String::operator=(const String &other)//运算符重载", "\n{", "\n    if (this == &other)", "\n        return *this;", "\n\n", "delete[] str;\nlen = other.len;\nstr = new char[len + 1];\nstrcpy(str, other.str);\nreturn *this;\n", "\n\n", "}", "\n时返回对象，此时又成功调用了拷贝构造，我被这个整懵了，求解"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;//  加号运算符重载&lt;/span&gt;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Person&lt;/span&gt;&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n \n \n \n \n \n    &lt;span class=\"hljs-comment\"&gt;//  1、成员函数重载&amp;#43;&lt;/span&gt;\n    Person &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Person &amp;amp;p)\n    {\n        Person temp;\n        temp.m_A &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_A &amp;#43; p.m_A;\n        temp.m_B &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;m_B &amp;#43; p.m_B;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n    }\n \n    int m_A;  &lt;span class=\"hljs-comment\"&gt;//年龄&lt;/span&gt;\n    int m_B;  &lt;span class=\"hljs-comment\"&gt;//零花钱&lt;/span&gt;\n  \n};\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++中如何把类中的成员函数改为重载+运算符", ["想要把一个类中的成员函数改为重载+运算符，而且在改好厚，如何再次设计重载运算符“+”的函数？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&amp;#xff08;错误&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#xff09;结构体不能这么赋值 &amp;#xff0c;\nm&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#34;梅花&amp;#34;&lt;/span&gt;,a[n]};应该写成下面&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;句&amp;#xff1a;\n\n&lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(m.huase,&lt;span class=\"hljs-string\"&gt;&amp;#34;梅花&amp;#34;&lt;/span&gt;)&amp;#xff1b;&lt;span class=\"hljs-comment\"&gt;//字符串用strcpy拷贝&lt;/span&gt;\nm.num &amp;#61; a[n];\n&amp;#xff08;错误&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#xff09;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;card&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; huase[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//这里改成5&amp;#xff0c;一个汉字占2个字节&amp;#xff0c;2个汉字就是4个字节&amp;#xff0c;还需要给\\0留一个位置&amp;#xff0c;否则显示的时候会出错&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&amp;#xff08;错误3&amp;#xff09;在paimon函数中&amp;#xff0c;数组a没有初始化就使用了&amp;#xff0c;a中的数都是随机数。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/018791038146197.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++人工洗牌发牌中的错误，求原因和解决方法", ["初学者，真的不懂怎么改，是要运算符重载吗？但是我没设置类啊_(:з」∠)_", "\n", "\n", "\n", "错误的就是这个", "m＝{\"梅花\"，a[n]};", "连续错了四个（后面一样的错误）", "不知道为什么，希望哪位大佬解答一下，告诉一下原因和改正方法，感谢。", "最后的bug了，让我编译成功就行，网上也没搜到类似的，是我犯了太蠢的错误了吗，我深刻记住这次错误。"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;把 重载&amp;lt;&amp;lt; 的参数里 的&amp;amp; 去掉&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/310606910376173.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;MyInteger&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; cout, MyInteger p);\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;MyInteger&lt;/span&gt;() {\n        mNumber &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//成员函数重载前置&amp;#43;&amp;#43;运算符&lt;/span&gt;\n    MyInteger &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#43;() {\n        mNumber&amp;#43;&amp;#43;;&lt;span class=\"hljs-comment\"&gt;//先进行加1&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//再将自身返回&amp;#xff0c;所以返回类型为MyInteger&amp;#xff0c;返回引用是为了一直对一个数据进行递增操作 &lt;/span&gt;\n    }\n \n    &lt;span class=\"hljs-comment\"&gt;//成员函数重载后置&amp;#43;&amp;#43;运算符&lt;/span&gt;\n    MyInteger &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) {\n        &lt;span class=\"hljs-comment\"&gt;//1、先记录当时的结果&lt;/span&gt;\n        MyInteger temp &amp;#61; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//2、递增&lt;/span&gt;\n        mNumber&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-comment\"&gt;//3、返回记录的结果&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n    } \n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; mNumber;\n};\n \n&lt;span class=\"hljs-comment\"&gt;//重载左移运算符&lt;/span&gt;\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; cout, MyInteger p) {\n    cout &amp;lt;&amp;lt; p.mNumber;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cout;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;test01&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    MyInteger myInt;\n    cout &amp;lt;&amp;lt; &amp;#43;&amp;#43;myInt &amp;lt;&amp;lt; endl;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;test02&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    MyInteger myInt;\n    cout &amp;lt;&amp;lt; myInt&amp;#43;&amp;#43; &amp;lt;&amp;lt; endl;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;test02&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["代码中那里有问题，自学的不知怎么解决", ["在自学C++到递增运算符重载时", "在类中用成员函数实现递增重载，前置没有报错，后置报错说没有合适的运算符", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<string>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "MyInteger", " {\n    ", "friend", " ostream& ", "operator", "<<(ostream& cout, MyInteger& p);\n", "public", ":\n    ", "MyInteger", "() {\n        mNumber = ", "0", ";\n    }\n    ", "//成员函数重载前置++运算符", "\n    MyInteger &", "operator", "++() {\n        mNumber++;", "//先进行加1", "\n        ", "return", " *", "this", ";", "//再将自身返回，所以返回类型为MyInteger，返回引用是为了一直对一个数据进行递增操作 ", "\n    }\n\n    ", "//成员函数重载后置++运算符", "\n    MyInteger ", "operator", "++(", "int", ") {\n        ", "//1、先记录当时的结果", "\n        MyInteger temp = *", "this", ";\n\n        ", "//2、递增", "\n        mNumber++;\n\n        ", "//3、返回记录的结果", "\n        ", "return", " temp;\n\n    } \n", "private", ":\n    ", "int", " mNumber;\n};\n\n", "//重载左移运算符", "\nostream& ", "operator", "<<(ostream& cout, MyInteger& p) {\n    cout << p.mNumber;\n    ", "return", " cout;\n}\n", "void", " ", "test01", "()", " ", "{\n    MyInteger myInt;\n    cout << ++myInt << endl;\n}\n", "void", " ", "test02", "()", " ", "{\n    MyInteger myInt;\n    cout << myInt++ << endl;\n}\n", "int", " ", "main", "()", " ", "{\n\n    ", "test02", "();\n    ", "return", " ", "0", ";\n}\n", "\n", "我以为是前置和后置的函数冲突了就把前置重载给注释了，可还是报错，我猜问题是在左移运算符重载代码中", "怎么修改可以让test02中的cout不报错那"]], "Tag": "程序设计"}
{"Answer": "&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/sfgitfkqqk/article/details/5754199'&gt;急急急!!!哪位来帮忙啊!!!!!!&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/zhengxilin/article/details/342515'&gt;求  助(急急急!!!!!!!)&lt;/a&gt;&lt;br/&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/lanpeiyuan787729571/article/details/6015633'&gt;急急急&lt;/a&gt;&lt;br/&gt;----------------------同志你好，我是CSDN问答机器人小N，奉组织之命为你提供参考答案，编程尚未成功，同志仍需努力！", "Konwledge_Point": "运算符重载", "Question": ["c++作业求帮忙呀急急急", ["fraction input();", "\n fraction operator +(fraction &);", "\n fraction operator -(fraction &);", "\n fraction operator *(fraction &);", "\n fraction operator /(fraction &);", "\n friend ostream& operator<<(ostream& cout,const fraction& a);//使用友元函数重载<<输出运算符", "\n friend istream& operator>>(istream& cin,fraction& a);//使用友元函数重载>>输出运算符", "\n void output();  //输出约分后的分数", "\n void output1(); // 输出普通分数", "\n}; ", "\n//实现文件", "\nostream& operator<<(ostream& cout,const fraction& a)", "\n{", "\n       cout<\n       return cout;", "\n}", "\nistream& operator>>(istream& cin,fraction& a)", "\n{", "\n       cin>>a.rn>>\"/\"a.dn>>endl;", "\n       return cin;", "\n求大神帮忙看看，对输入输出运算符重载哪出错了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;class定义结束的地方&amp;#xff0c;缺少一个分号。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["解决运算符<<重载问题", ["这个报错应该怎么处理解决？ostream是cout的类型", "求解，求解答，谢谢，感谢各位！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;你的P是一个向量啊&amp;#xff0c;所以要循环来得到span&amp;#xff0c;而且span也是一个向量&amp;#xff0c;所以最终的代码是&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;P &amp;#61; (fs/N).*fin;\nspan &amp;#61; &lt;span class=\"hljs-built_in\"&gt;zeros&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(P));\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;i&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:&lt;span class=\"hljs-built_in\"&gt;numel&lt;/span&gt;(P)\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(P(&lt;span class=\"hljs-built_in\"&gt;i&lt;/span&gt;)&amp;lt;&lt;span class=\"hljs-number\"&gt;300&lt;/span&gt;)\nspan(&lt;span class=\"hljs-built_in\"&gt;i&lt;/span&gt;) &amp;#61; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;round&lt;/span&gt;(.....)); &lt;span class=\"hljs-comment\"&gt;% 这个自己填&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;elseif&lt;/span&gt;(P(&lt;span class=\"hljs-built_in\"&gt;i&lt;/span&gt;)&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;300&lt;/span&gt; &amp;amp;&amp;amp; P(&lt;span class=\"hljs-built_in\"&gt;i&lt;/span&gt;)&amp;lt;&lt;span class=\"hljs-number\"&gt;440&lt;/span&gt;)\nspan(&lt;span class=\"hljs-built_in\"&gt;i&lt;/span&gt;) &amp;#61; &lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;(rround(......));&lt;span class=\"hljs-comment\"&gt;%自己填&amp;#xff0c;依次类推&lt;/span&gt;\n........\n&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;end&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["matlab 报警变量为非标量，需要转换为标量", ["请帮忙分析一下如何修改。", "\n", "\n", "报警图片如下：", "\n", "variable 'P' might be set by a nonscalar operator.", "变量“p”可以由非标量运算符来设置。", "\n", "explanation", "It appears the code sets the variable with an operator that does not yield a scalar value where Code Analyzer expects one. This message can be incorrect if the operator is overloaded. For information on overloading operators, see “Implementing Operators for Your Class”.", "代码似乎使用一个运算符设置变量，该运算符不会产生代码分析器所期望的标量值。如果操作员过载，此消息可能不正确。有关重载运算符的信息，请参阅“为类实现运算符”。", "\n", "Suggested Action", "If Code Analyzer evaluated the code correctly, rewrite it to set the variable to a scalar value. Otherwise, suppress the message as described in Adjust Code Analyzer Message Indicators and Messages.", "如果代码分析器正确计算了代码，请重写它以将变量设置为标量值。否则，按调整代码分析器消息指示器和消息中的说明抑制消息。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;6参考下&lt;a href=\"https://blog.csdn.net/yanxiaolx/article/details/53393437\"&gt;https://blog.csdn.net/yanxiaolx/article/details/53393437&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;代码如下&amp;#xff1a;{如果对你有帮助&amp;#xff0c;可以给我个采纳吗&amp;#xff0c;谢谢!! 点击我这个回答右上方的【采纳】按钮}。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#define  _CRT_SECURE_NO_WARNINGS\n \n#include&amp;lt;iostream&amp;gt;\nusing namespace std;\n#include&amp;lt;string.h&amp;gt;\n#include&amp;lt;fstream&amp;gt;\n \nclass student\n{\nprivate:\n\tstudent* next;\npublic:\n\tchar stu_num[15];                  //学号\n\tchar stu_name[30];                //姓名\n\tfloat stu_score;                      //成绩\n \n\tvoid afterInsert(student *p);//在该节点后插入一个节点\n\tvoid afterDelete();//在该节点后删除一个节点\n\t\n\tstudent *getNext()//获得下一个节点的指针\n\t{ \n\t\treturn next; \n\t}\n \n\t/***********查询学生信息************/\n\tvoid getMage();\n \n\t/******学生信息修改******/\n\tvoid changeMage(int n, char *ptr);\n\tvoid changegrade(float p);\n \n\t/******构造*****/\n\tstudent(char *num, char *name, float score);\n\tstudent();\n};\n \nvoid student::changegrade(float p)\n{\n\tstu_score &amp;#61; p;\n}\n \nstudent::student()           //构造\n{\n\tstrcpy(stu_num, &amp;#34;\\0&amp;#34;);\n\tstrcpy(stu_name, &amp;#34;\\0&amp;#34;);\n\tstu_score &amp;#61; 0;\n\tnext &amp;#61; &amp;#39;\\0&amp;#39;;\n}\n \nstudent::student(char *num, char *name, float score)\n{\n\tstrcpy(stu_num, num);\n\tstrcpy(stu_name, name);\n\tstu_score &amp;#61; score;\n\tnext &amp;#61; &amp;#39;\\0&amp;#39;;\n}\n \nvoid student::afterInsert(student *p)//插入节点\n{\n\tp-&amp;gt;next &amp;#61; next;\n\tnext &amp;#61; p;\n}\n \nvoid student::afterDelete()        //删除节点\n{\n\tstudent *p &amp;#61; next;\n\tnext &amp;#61; p-&amp;gt;next;\n\tdelete p;\n}\n \nvoid student::getMage()             //获得信息\n{\n\tcout &amp;lt;&amp;lt; &amp;#34;学号&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_num &amp;lt;&amp;lt; &amp;#34;      姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_name;\n\tcout &amp;lt;&amp;lt; &amp;#34;      c&amp;#43;&amp;#43;成绩&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; stu_score &amp;lt;&amp;lt; endl;\n}\n \nvoid student::changeMage(int n, char *ptr)\n{\n\tswitch (n)\n\t{\n\tcase 1: strcpy(stu_num, ptr); \n\t\tbreak;\n\tcase 2: strcpy(stu_name, ptr);\n\t}\n}\n \n//建立链表函数\nvoid  construct_list(student *tail)\n{\n\tstudent *p &amp;#61; new student;\n\tchar very[20];\n\tfloat achieve;\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入学号:&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; very;\n\tp-&amp;gt;changeMage(1, very);\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; very;\n\tp-&amp;gt;changeMage(2, very);\n\tcout &amp;lt;&amp;lt; &amp;#34;请输入c&amp;#43;&amp;#43;成绩&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tcin &amp;gt;&amp;gt; achieve;\n\tp-&amp;gt;changegrade(achieve);\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;信息输入完毕&amp;#34; &amp;lt;&amp;lt; endl;\n \n\tfor (; tail-&amp;gt;getNext() !&amp;#61; &amp;#39;\\0&amp;#39;;)\n\t{\n\t\ttail &amp;#61; tail-&amp;gt;getNext();\n\t}\n \n\ttail-&amp;gt;afterInsert(p);\n}\n \n/*********查询信息*********/\nstudent *findmege(student *head)\n{\nloop:\n\tcout &amp;lt;&amp;lt; &amp;#34;1--按姓名查询           2--按学号查询              q--返回上一级菜单&amp;#34; &amp;lt;&amp;lt; endl;\n\tchar p[5], ptr[20];\n\tstudent *mid &amp;#61; head;\n\tcin &amp;gt;&amp;gt; p;\n \n\tif (p[0] !&amp;#61; &amp;#39;1&amp;#39;&amp;amp;&amp;amp;p[0] !&amp;#61; &amp;#39;2&amp;#39;&amp;amp;&amp;amp;p[0] !&amp;#61; &amp;#39;q&amp;#39; || strlen(p)&amp;gt;1)\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;你的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tgoto loop;\n\t}\n \n\tswitch (p[0])\n\t{\n\tcase &amp;#39;1&amp;#39;:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入要查找的姓名&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ptr;\n \n\t\tfor (; strcmp(ptr, mid-&amp;gt;stu_name) !&amp;#61; 0; mid &amp;#61; mid-&amp;gt;getNext())\n\t\t{\n\t\t\tif (mid-&amp;gt;getNext() &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t\t{\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;你要查找的人不存在&amp;#xff0c;请确认你的输入是否正确&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\tcase &amp;#39;2&amp;#39;:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入您要查找的学号&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ptr;\n\t\tfor (; strcmp(ptr, mid-&amp;gt;stu_num) !&amp;#61; 0; mid &amp;#61; mid-&amp;gt;getNext())\n\t\t{\n\t\t\tif (mid-&amp;gt;getNext() &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t\t{\n\t\t\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;您要查找的内容不存在&amp;#xff0c;请确认您的输入是否正确&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\t\tgoto loop;\n\t\t\t}\n\t\t}\n\t\treturn mid;\n\t}\n\tcase &amp;#39;q&amp;#39;: \n\t{\n\t\treturn &amp;#39;\\0&amp;#39;;\n\t}\n\tdefault:\n\t{\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;对不起&amp;#xff0c;您的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tgoto loop;\n\t}\n\t}\n}\n \n/******************删除链表 节点***********************/\nvoid delete_list(student *head)\n{\n\tstudent *p &amp;#61; &amp;#39;\\0&amp;#39;;\n\tchar selet[4];\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;在删除前&amp;#xff0c;系统会根据您的提示找到您要删除的学生信息&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\tp &amp;#61; findmege(head);\n\tif (p !&amp;#61; &amp;#39;\\0&amp;#39;)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;确认要删除吗&amp;#xff08;yes/任意键返回&amp;#xff09;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; selet;\n \n\t\tif (strcmp(selet, &amp;#34;yes&amp;#34;) &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tfor (; head-&amp;gt;getNext() !&amp;#61; p; head &amp;#61; head-&amp;gt;getNext());\n\t\t\thead-&amp;gt;afterDelete();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;该信息删除成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t}\n\t}\n}\n \n/*******************修改节点信息********************/\nvoid change_info(student *head)\n{\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;在您修改前&amp;#xff0c;系统会根据您提供的信息找的您要修改的信息&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\tstudent *p &amp;#61; &amp;#39;\\0&amp;#39;;\n \n\tfloat achieve;\n\tp &amp;#61; findmege(head);\n\tif (p !&amp;#61; &amp;#39;\\0&amp;#39;)\n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;请输入c&amp;#43;&amp;#43;成绩:&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; achieve;\n\t\tp-&amp;gt;changegrade(achieve);\n\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\tcout &amp;lt;&amp;lt; &amp;#34;修改成功!&amp;#34; &amp;lt;&amp;lt; endl;\n\t}\n \n}\n \n/**************输出学生成绩信息**************/\nvoid output(student *head)\n{\n\tsystem(&amp;#34;cls&amp;#34;);\n\tcout &amp;lt;&amp;lt; &amp;#34;1-查看指定学生信息&amp;#xff1b;2-查看所有学生信息&amp;#xff1b;3-分段输出学生信息&amp;#34; &amp;lt;&amp;lt; endl;\n\tchar ch;\n\tint n &amp;#61; 0;\n\thead &amp;#61; head-&amp;gt;getNext();\n\tcin &amp;gt;&amp;gt; ch;\n\tswitch (ch)\n\t{\n\tcase &amp;#39;1&amp;#39;: \n\t\thead &amp;#61; findmege(head);\n\t\tif (head &amp;#61;&amp;#61; &amp;#39;\\0&amp;#39;)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\thead-&amp;gt;getMage();\n\t\tbreak;\n\tcase &amp;#39;2&amp;#39;: \n\twhile (head)\n\t{\n\t\thead-&amp;gt;getMage();\n\t\thead &amp;#61; head-&amp;gt;getNext();\n\t}\n\tbreak;\n\tcase &amp;#39;3&amp;#39;: \n\t\tcout &amp;lt;&amp;lt; &amp;#34;a-60分以下&amp;#xff1b;b-60~70分之间&amp;#xff1b;c-70~80分之间&amp;#xff1b;d-80~90分之间&amp;#xff1b;e-90~100分之间&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; ch;\n\t\tswitch (ch)\n\t\t{\n\t\tcase &amp;#39;a&amp;#39;:\n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score &amp;lt;&amp;#61; 60)\n\t\t\t{\n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\t break;\n\t\tcase &amp;#39;b&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;60 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 70) \n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;; \n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;c&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;70 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 80)\n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage(); \n\t\t\t\tn&amp;#43;&amp;#43;; \n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;d&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;80 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 90)\n\t\t\t{\n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\tbreak;\n\t\tcase &amp;#39;e&amp;#39;: \n\t\twhile (head)\n\t\t{\n\t\t\tif (head-&amp;gt;stu_score&amp;gt;90 &amp;amp;&amp;amp; head-&amp;gt;stu_score &amp;lt;&amp;#61; 100)\n\t\t\t{ \n\t\t\t\thead-&amp;gt;getMage();\n\t\t\t\tn&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\thead &amp;#61; head-&amp;gt;getNext();\n\t\t}\n\t\t}\n\t\tif (n &amp;#61;&amp;#61; 0)\n\t\t{\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;该分段内没有您要找的学生信息&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t}\n\t}\n}\n \n/*****************主菜单************************/\nvoid mainmenu(student *head)\n{\n\tchar selet[10];\n\tint n &amp;#61; 1;\n\tofstream outfile;\n\tifstream infile;\n\tstudent *p, *ptr;\n\tstudent *test &amp;#61; head, *mid;\n\tcout &amp;lt;&amp;lt; &amp;#34;*************************欢迎进入学生信息管理系统*************************&amp;#34; &amp;lt;&amp;lt; endl;\n\tdo {\n\t\tcout &amp;lt;&amp;lt; &amp;#34;**************************************************************************&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;1.插入信息&amp;#xff1b;   2.删除信息&amp;#xff1b;  3.修改信息&amp;#xff1b; 4.查看信息&amp;#xff1b; 5.保存  &amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;按&amp;#39;q&amp;#39;键退出      &amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcout &amp;lt;&amp;lt; &amp;#34;**************************************************************************&amp;#34; &amp;lt;&amp;lt; endl;\n\t\tcin &amp;gt;&amp;gt; selet;\n\t\tif (((selet[0]&amp;lt;&amp;#39;1&amp;#39; || selet[0]&amp;gt;&amp;#39;6&amp;#39;) &amp;amp;&amp;amp; selet[0] !&amp;#61; &amp;#39;q&amp;#39;) || strlen(selet)&amp;gt;1)\n\t\t{\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;您的输入有误&amp;#xff0c;请重新输入&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (selet[0])\n\t\t{\n \n\t\tcase &amp;#39;1&amp;#39;:\n\t\t\tconstruct_list(head);\n\t\t\tbreak; \n\t\tcase &amp;#39;2&amp;#39;: \n\t\t\tdelete_list(head); \n\t\t\tbreak;\n\t\tcase &amp;#39;3&amp;#39;: \n\t\t\tchange_info(head);\n\t\t\tbreak;\n\t\tcase &amp;#39;4&amp;#39;: \n\t\t\toutput(head);\n\t\t\tbreak;\n\t\tcase &amp;#39;5&amp;#39;:  \n\t\t\toutfile.open(&amp;#34;students.txt&amp;#34;, ios::out | ios::app);\n\t\t\tfor (p &amp;#61; head-&amp;gt;getNext(); p !&amp;#61; &amp;#39;\\0&amp;#39;; p &amp;#61; p-&amp;gt;getNext())\n\t\t\t{\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_name &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_num &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; p-&amp;gt;stu_score &amp;lt;&amp;lt; &amp;#39; &amp;#39;;\n\t\t\t\toutfile &amp;lt;&amp;lt; endl;\n\t\t\t}\n\t\t\toutfile.close();\n\t\t\tsystem(&amp;#34;cls&amp;#34;);\n\t\t\tcout &amp;lt;&amp;lt; &amp;#34;保存成功&amp;#xff01;&amp;#34; &amp;lt;&amp;lt; endl;\n\t\t\tbreak;\n\t\tcase &amp;#39;q&amp;#39;: \n\t\t\tbreak;\n\t\t}\n\t} while (selet[0] !&amp;#61; &amp;#39;q&amp;#39;);\n}\n \nvoid main()\n{\n\tstudent head;\n\tmainmenu(&amp;amp;head);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["学生成绩管理系统，要求用C++", ["题目：学生成绩管理系统", "\n\n", "一、基本要求", "\n\n", "1）能进行数据的添加、删除、修改、查询、排序；", "\n\n", "2）完全使用类实现。", "\n\n", "3) 重载输入“>>”操作符，使得可以通过cin直接读入类的对象值。", "\n\n", "4) 编写main函数，测试系统的各种功能。二、系统基本类系统基本类4个：Score类，subject类，Student类，Class类。存储学生的个人信息，考试科目，成绩，班级信息。三、功能拓展文件操作：", "\n\n", "1）初始数据从文件导入，能够实现文件的显示；", "\n\n", "2）数据保存至文件中；", "\n\n", "3）对文件记录进行增、删、改、查；", "\n\n", "4）多个文件组成一个文件。派生：为Student类派生研究生类GStudent，为研究生填加课题类Project类。扩展功能中可包含书上的知识点内容，如文件流、STL标准模板库虚函数、派生、函数重载、运算符重载、静态数据成员和成员函数等。"]], "Tag": "程序设计"}
{"Answer": "http://codepad.org/8tG9x0eK", "Konwledge_Point": "运算符重载", "Question": ["没有找到接受“const char [2]”类型的右操作数的运算符(或没有可接受的转换)", ["#include", "\nusing namespace std;", "\nclass Time", "\n{", "\nprivate:", "\n    int hour;", "\n    int minute;", "\n    int second;", "\npublic:", "\n    Time(int h=0,int m=0, int s=0):hour(h),minute(m),second(s){}", "\n    Time operator+(Time x)", "\n    {", "\n        Time z;", "\n        z.hour=hour+x.hour;", "\n        z.minute=minute+x.minute;", "\n        z.second=second+x.second;", "\n        return z;", "\n    }", "\n    friend istream &operator>>(istream &in, Time &z);", "\n    friend ostream &operator<<(ostream &out, Time &z);", "\n};", "\nistream &operator>>(istream &in, Time &z)", "\n{", "\n    in>>z.hour>>\":\">>z.minute>>\":\">>z.second;", "\n    if(!in)", "\n        z=Time(); //如果失败，默认初始化", "\n    return in;", "\n}", "\nostream &operator<<(ostream &out, Time &z)", "\n{", "\n    out<\n    return out;", "\n}", "\nint main()", "\n{", "\n    Time time1,time2,time3;", "\n    cin>>time1>>time2;", "\n    time3=time1+time2;", "\n    cout<<time3<<endl;", "\n    system(\"PAUSE\");", "\n    return 0;", "\n\n", "}", "\n错误  1   error C2679: 二进制“>>”: 没有找到接受“const char [2]”类型的右操作数的运算符(或没有可接受的转换)    e:\\project\\3-33\\3-33\\main.cpp   24"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;当你重载运算符时&amp;#xff0c;可以选择是否将其声明为友元函数。&lt;/p&gt;\n&lt;p&gt;如果你不将重载运算符声明为友元&amp;#xff0c;那么它将是类的成员函数&amp;#xff0c;拥有隐式的 this 指针&amp;#xff0c;可以访问类的私有成员。在这种情况下&amp;#xff0c;你可以在类外部访问重载运算符&amp;#xff0c;但它只能对类的对象进行操作。&lt;/p&gt;\n&lt;p&gt;如果你将重载运算符声明为友元函数&amp;#xff0c;那么它就不再是类的成员函数了。友元函数不拥有隐式的 this 指针&amp;#xff0c;并且不能访问类的私有成员。但是&amp;#xff0c;因为它是友元&amp;#xff0c;所以可以在类外部访问类的私有成员。&lt;/p&gt;\n&lt;p&gt;在你的例子里&amp;#xff0c; &amp;#61;&amp;#61; 运算符是在类的内部实现的&amp;#xff0c;它可以访问类的私有成员。所以 不需要加 friend。简单来说&amp;#xff0c;如果重载运算符需要访问类的私有成员&amp;#xff0c;那么就应该将其声明为友元。如果不需要&amp;#xff0c;则不需要声明为友元。&lt;/p&gt;\n&lt;p&gt;为什么加了friend会报错&amp;#xff0c;可能是因为加了 friend 后没有提供正确的声明&amp;#xff0c;导致编译器无法识别&amp;#xff0c;导致错误。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载运算符时友元的作用及问题", ["请问这里在重载==运算符时加不加friend 的区别是什么呢为什么加了friend会报错", "\n", "class", " ", "person", "{\n", "public", ":\n    person(", "string", " m_name,", "int", " m_age){\n        name=m_name;\n        age=m_age;\n    }\n    ", "bool", " operator==(", "const", " person& p){\n        ", "if", "(", "this", "->name ==p.name&&", "this", "->age==p.age){\n            ", "return", " ", "true", ";\n        }\n        ", "else", "{\n            ", "return", " ", "0", ";\n        }\n    }\n    ", "string", " name;\n    ", "int", " age;\n};\n\n"]], "Tag": "程序设计"}
{"Answer": "你这是以成员函数的形式重载的，左边只能由你实例化的对象来调用。  你可以使用友元函数来进行重载   函数定义为friend BigNumber operator+(int n,BigNumber num)", "Konwledge_Point": "运算符重载", "Question": ["重载运算符的问题，如何实现int + （某类对象）", ["#include ", "\nusing namespace std;", "\n\n", "template", "\nclass BigNumber {", "\n    T n;", "\npublic:", "\n    BigNumber(T i) :n(i) {}", "\n    BigNumber operator+(BigNumber b) {", "\n        return BigNumber(n + b.n);", "\n    }", "\n};", "\n\n", "int main() {", "\n    BigNumber b1(1), b2(2);", "\n    3 + 3;", "\n    b1 + 3;", "\n    3+b1;//这是错的，如何改成对的", "\n    b1 + b2;", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;64行应该是用j作为循环变量啊&amp;#xff0c;怎么还用i啊&lt;br /&gt;43行&amp;#xff0c;54行都是一个问题&amp;#xff0c;应该是for(j&amp;#61;0;j&amp;lt;N;j&amp;#43;&amp;#43;)&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#c++#的问题：这个程序要实现矩阵运算符+-/重载", ["\n", "\n", "\n", "这个程序要实现矩阵运算符+-", "/重载，", "/还没学会，但是现在没有报错，但是运行不出来，请问有什么问题，蟹蟹！"]], "Tag": "程序设计"}
{"Answer": "你在&lt;&lt;函数中用的是 Box&amp; 类型，但是A+B返回的是不可取地址的、即将泯灭的Box类型（xvalue），xvalue的Box类型是无法转化成Box&amp;类型的，所以会报错。\r\n解决方法：把ostream&lt;&lt;中的 Box&amp; 改成 Box 。", "Konwledge_Point": "运算符重载", "Question": ["临时对象到底是不是对象，为什么我的代码会出错？c++", ["\n\n", "代码也贴过来了，希望好心大佬回答一下本人新鸟，没有积分，无法报答，好不意思", "\n\n", "#include", "\nusing namespace std;", "\n\n", "class Box", "\n{", "\npublic:", "\n    Box(int a = 1)//构造函数 ", "\n    {", "\n        this->a = a;        //初始化数据成员a = 1", "\n    }", "\n     Box  operator +(Box &h)   //运算符重载+", "\n     {", "\n         return Box(a + h.a);//返回一个临时对象，其数据成员的值为 “+”前后两个对象数据成员的和", "\n     }", "\n     friend void operator <<(ostream &, Box  &);//类内声明友元函数，来重载<<", "\n\n", "private:", "\n    int a;   //私有数据成员 a", "\n};", "\n\n", "void operator <<(ostream &n,Box &Object)//友元重载函数的类外定义", "\n{", "\n    n << Object.a;     //输出Box对象的数据成员a", "\n}", "\n\n", "int main()", "\n{", "\n    Box A,B;", "\n    cout << A;// cout 对象A可以", "\n**  cout << A + B;//此处报错，为什么  cout 临时无名对象却不可以？？？？？？（错误为：“没有与这些操作匹配的 << 运算符”**）", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "链接：https://pan.baidu.com/s/1htRyCXe 密码：62dg", "Konwledge_Point": "运算符重载", "Question": ["C++通讯录管理系统求大神指导，", ["\n", "创建文本文件，记录联系人的信息（需要创建两个文本文件，分别存储手机和手机卡上的存储的联系人的信息）。 ", "\n", "以菜单方式工作(字符界面即可)", "\n", "存储在手机上的联系人的信息包括：姓名和电话号码；存储在手机卡上的联系人的 信息包括姓名，籍贯，电话号码，QQ号等信息", "\n", "管理系统的功能包括：\na) 新建联系人：添加新的联系人（添加时确定是添加到手机上还是手机卡中）\nb) 删除：删除一个联系人（输入电话号码，删除该联系人。说明，如果两个存储位置上都存在该联系人的话，需要在两个存储位置上都要进行删除操作）\nc) 修改：修改某个联系人的信息（输入电话号码，查询到联系人之后进行信息的修改。说明，如果两个存储位置上都存在该联系人的话，需要在两个存储位置上都要进行删除操作）\nd) 查询：根据名字查询联系人信息（查询结果不唯一）\ne) 浏览：显示所有联系人的信息\nf) 将联系人的信息从手机转存到手机卡上（同时要避免重复数据的存在。并且在转存是要检查容量是否受限。下同。）\ng) 将联系人的信息从手机卡上准存到手机上（同时要避免重复数据的存在）\n\n", "\n", " 要支持继承、多态、重载(运算符重载、函数重载)等面向对象的基本特点", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;display&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(ostream&amp;amp; os&amp;#61;cout)&lt;/span&gt;&lt;/span&gt;;\n改成\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;display&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(ostream&amp;amp; os&amp;#61;cout)&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#运算符#的问题，如何解决？", ["在定义的class中重载运算符<<报错，而样例中用同样的格式重载，却没有问题。", "\n", "#ifndef A", "\n", "#", "ifndef", " A", "\n", "#", "define", " A", "\n", "#", "include", "<fstream>", "\n", "#", "include", "<vector>", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "\"Pell_iterator.h\"", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Pell", "{\n    ", "friend", " ", "class", " ", "Pell_iterator", ";\n    ", "friend", " ostream& ", "operator", "<<(ostream& os,", "const", " Pell& rhs );\n    ", "public", ":\n        ", "Pell", "(", "int", " bp=", "1", ",", "int", " len=", "1", ");\n        ", "int", " ", "size", "()", "const", "{", "return", " _length;};", "//返回对象序列的长度", "\n        ", "int", " ", "beg_pos", "()", "const", "{", "return", " _beg_pos;};", "//返回对象的开始位置", "\n        ", "void", " ", "change", "(", "int", " bp=", "1", ",", "int", " len=", "1", ")", ";", "//重新设置对象", "\n        ", "bool", " ", "next", "(", "int", "& val)", "const", ";", "//将要操作的下一数字赋给val，同时“光标”后移一位", "\n        ", "void", " ", "next_reset", "()", "const", "{_next=_beg_pos", "-1", ";};", "//重置将要操作的下一数字至开始位置", "\n        ", "int", " ", "elem", "(", "int", " pos)", "const", ";", "//返回对象序列中第pos个数字", "\n        ", "int", " ", "sum", "()", "const", ";", "//求对象序列的和", "\n        ", "bool", " ", "is_elem", "(", "int", " val)", ";", "//判断val数值是否包含在对象的序列中", "\n        ", "void", " ", "display", "(ostream& os=cout)", ";", "//用于输出对象包含的序列", "\n        ", "static", " ", "void", " ", "generate", "()", ";", "//用于填充数列", "\n        ", "Pell& ", "copy", "(", "const", " Pell)", ";\n        \n        \n        ", "typedef", " Pell_iterator iterator;\n        ", "iterator ", "begin", "()", "const", "\n        ", "{\n            ", "iterator ", "it", "(_beg_pos)", ";\n            ", "return", " it;\n        }\n        ", "iterator ", "end", "()", "const", "\n        ", "{\n            ", "iterator ", "it", "(_beg_pos+_length)", ";\n            ", "return", " it;\n        }\n    ", "private", ":\n\n        ", "static", " ", "const", " ", "int", " _max_size=", "40", ";\n        ", "int", " _length;\n        ", "int", " _beg_pos;\n        ", "mutable", " ", "int", " _next;\n        ", "static", " vector<", "int", "> _elems;\n};\nostream&\n", "operator", "<<(ostream& os,", "const", " Pell& rhs )\n{\n    cout<<", "'('", "<<rhs._beg_pos<<", "','", "<<rhs._length <<", "\") \"", ";\n    rhs.", "display", "(os);\n    ", "return", " os; \n } \n", "#", "endif", "  ", "\n\n", "#", "include", "\"Pell.h\"", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", "\n", "{\n    ", "Pell ", "it", "(", "4", ",", "3", ")", ";\n    cout<<it;\n  ", "return", " ", "0", ";\n}\n", "\n", "报错no match for 'operator'以及下面还有几百个看不懂的报错提示，但是只看重载运算符<<部分的代码，又没找出问题"]], "Tag": "程序设计"}
{"Answer": "是啊，不能继承，不能重载。对不起，C#又让你失望了。", "Konwledge_Point": "运算符重载", "Question": ["link中能不能重载string的运算符？string没办法继承啊，怎么办？", ["link中能不能重载string的运算符？string没办法继承啊，怎么办？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;空1是a.x&amp;#43;&amp;#43;&lt;br /&gt;空2是a.x--&lt;br /&gt;空3不填&lt;br /&gt;空4是--a&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载运算符问题，望解疑", ["下列程序的运行结果是：7 6 。", "请将程序中的空白填写完整。", "\n", "#", "include", " ", "<iostream>", "\n ", "using", " ", "namespace", " std;\n ", "class", " ", "A", " {\n ", "public", ":\n        ", "A", "(", "int", " i) :", "x", "(i)\n        {}\n        ", "A", "()\n        {x = ", "0", ";}\n        ", "friend", " A ", "operator", " ++(A a);\n        ", "friend", " A ", "operator", " --(A &a);\n        ", "void", " ", "print", "()", ";\n ", "private", ":\n        ", "int", " x;\n };\n A ", "operator", "++(A a)\n {________;", "//【空①】", "\n ", "return", " a;}\n A ", "operator", "--(A &a)\n {________;", "//【空②】", "\n ", "return", " a;}\n ", "void", " ", "A::print", "()", "\n ", "{cout << x << endl;}\n ", "int", " ", "main", "()", "\n ", "{\n        ", "A ", "a", "(", "7", ")", ";\n        ________;", "//【空③】", "\n        a.", "print", "();\n        ________;", "//【空④】", "\n        a.", "print", "();\n      ", "return", " ", "0", "\n\n\n"]], "Tag": "程序设计"}
{"Answer": "这个错误和你代码想实现的效果没关系，只是函数定义的不对，构造和声明不符，一个有const一个没有\r\n```\r\nistream&amp; operator&gt;&gt;(istream &amp;in, const Point &amp;p);      //输入运算符重载\r\nistream&amp; operator&gt;&gt;(istream &amp;in,       Point &amp;p) {     //输入运算符重载\r\n    //...\r\n}\r\n```\r\n无法解析的外部符号是\r\n```\r\nclass std::basic_istream&lt;char, struct std::char_traits&lt;char&gt;&gt;&amp; _cdecl \r\n    operator&gt;&gt;(\r\n        class std::basic_istream&lt;char, struct std::char_traits&lt;char&gt;&gt;&amp;,\r\n        class Point const &amp;\r\n    )\r\n//std::basic_istream&lt;char, struct std::char_traits&lt;char&gt;&gt; 指的是 istream\r\n//这种繁琐的类名都用define简化了，能认出来就行\r\n//对应下来指的就是\r\nclass istream&amp; _cdecl operator&gt;&gt;( class istream&amp;, class Point const &amp; )\r\n//忽略class和_cdecl（和编译过程有关）指的就是输入重载函数了\r\n```", "Konwledge_Point": "运算符重载", "Question": ["C++代码运行中出现无法解析的外部命令？", ["代码的作用是定义一个点类Point，派生出圆类和圆柱体类Circle和Cylinder", "\n功能是输出圆的周长（通过定义的Cirfer()函数）、面积（定义有Area()函数）和圆柱体的表面积和体积", "\n\n", "\n\n", "//Shape.h\n#ifndef SHAPE_H\n#define SHAPE_H\n#include<iostream>\n#define PI 3.1415926\nusing namespace std;\n\nclass Point\n{\npublic:\n    Point(double X, double Y);   //构造函数\n    void Set(double X, double Y);   //设置点值\n    double Getx()const;    //获取横坐标\n    double Gety()const;    //获取纵坐标\n    virtual void Output(ostream &out) const;   //输出函数\n    virtual void Input(istream &in);    //输入函数\nprotected:\n    double x, y;\n};\n\nclass Circle :public Point\n{\npublic:\n    Circle(const Point &p, double R);   \n    void Set(double X, double Y, double R);\n    void Set(const Point &p, double R);\n    double Getr()const;\n    double Area();   //计算圆的面积\n    double Cirfer();   //计算圆的周长\n    void Output(ostream &out)const;\n    void Input(istream &in);\nprotected:\n    double r;\n};\n\nclass Cylinder :public Circle\n{\npublic:\n    Cylinder(const Circle& c, double H);\n    void Set(const Circle& c, double H);\n    double Geth()const;\n    double Area();    //计算圆柱体的表面积\n    double Volume();    //计算圆柱体体积\n    void Output(ostream& out)const;\n    void Input(istream& in);\nprotected:\n    double h;\n};\n\nostream& operator<<(ostream& out, const Point& p);  //输出运算符重载\nistream& operator>>(istream& in, const Point& p);    //输入运算符重载\n#endif\n\n//Shape.cpp\n#include<iostream>\n#include\"Shape.h\"\nusing namespace std;\n\nostream & operator<<(ostream &out, const Point &p)   //输出运算符重载\n{\n    p.Output(out);\n    return out;\n}\nistream & operator>>(istream &in, Point &p)    //输入运算符重载\n{\n    p.Input(in);\n    return in;\n}\n\n//Point类成员函数\nPoint::Point(double X, double Y) :x(X), y(Y) {}\nvoid Point::Set(double X, double Y)\n{\n    x = X, y = Y;\n}\ndouble Point::Getx()const\n{\n    return x;\n}\ndouble Point::Gety()const\n{\n    return y;\n}\nvoid Point::Output(ostream &out)const\n{\n    out << '(' << x << \",\" << y << ')';\n}\nvoid Point::Input(istream& in)\n{\n    char str[80];\n    in.getline(str, 80, '(');\n    in.getline(str, 80, ','); x = atof(str);   //atof()是字符从ASCII转为float型数据\n    in.getline(str, 80, ')'); y = atof(str);\n}\n\n//Circle类成员函数\nCircle::Circle(const Point& p, double R) : Point(p), r(R) {}\nvoid Circle::Set(double X, double Y, double R)\n{\n    x = X, y = Y, r = R;\n}\nvoid Circle::Set(const Point& p, double R)\n{\n    Point::Set(p.Getx(), p.Gety());\n    r = R;\n}\ndouble Circle::Getr()const\n{\n    return r;\n}\ndouble Circle::Area()   //圆面积\n{\n    return PI * r * r;\n}\ndouble Circle::Cirfer()    //圆周长\n{\n    return 2 * PI * r;\n}\nvoid Circle::Output(ostream& out)const\n{\n    out << '[' << '(' << x << \",\" << y << ')' << \",\" << r << ']';\n}\nvoid Circle::Input(istream& in)\n{\n    char str[80];\n    in.getline(str, 80, '[');\n    Point::Input(in);\n    in.getline(str, 80, ',');\n    in.getline(str, 80, ']'); r = atof(str);\n}\n\n//Cylinder类成员函数\nCylinder::Cylinder(const Circle& c, double H) :Circle(c), h(H) {}\nvoid Cylinder::Set(const Circle& c, double H)\n{\n    Circle::Set(Getx(),Gety(),Getr());\n    h = H;\n}\ndouble Cylinder::Geth()const\n{\n    return h;\n}\ndouble Cylinder::Area()   //圆柱体表面积\n{\n    return PI*r*r* 2+2*PI*r*h;\n}\ndouble Cylinder::Volume()    //圆柱体体积\n{\n    return PI*r*r* h;\n}\nvoid Cylinder::Output(ostream& out)const\n{\n    out << '{';\n    Circle::Output(out);\n    out << \",\" << h << '}';\n}\nvoid Cylinder::Input(istream& in)\n{\n    char str[80];\n    in.getline(str, 80, '{');\n    Circle::Input(in);\n    in.getline(str, 80, ',');\n    in.getline(str, 80, '}'); h = atof(str);\n}\n\n//test.cpp\n#include<iostream>\n#include\"Shape.h\"\n\nint main()\n{\n    Point p(5, 8);   //初始化各个类的数据成员\n    Circle c(p, 10);\n    Cylinder y(c, 8);\n\n    cout << c << \"\\tArea:\" << c.Area() << \"\\t\\tCircumference\" << c.Cirfer() << '\\n'\n        << y << \"\\tArea:\" << y.Area() << \"\\tVolume:\" << y.Volume() << endl;\n\n    cout << \"\\n请注意键盘输入格式。\";\n    cout << \"\\n包括圆括号、方括号、花括号、逗号，\";\n    cout << \"其中可以插入或不插入空格、<Tab>、换行。\" << endl;\n\n    cout << \"请输入一个点 (x, y) : \";\n    cin >> p;\n    cout << \"结果：\" << p << endl;\n\n    cout << \"请输入一个圆 [(x, y), r] : \";\n    cin >> c;\n    cout << \"结果：\" << c << endl;\n\n    cout << \"请输入一个圆柱 {[(x, y), r], h} : \";\n    cin >> y;\n    cout << \"结果：\" << y << endl;\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把Complex &amp;amp; 换成const Complex&lt;br /&gt; &amp;amp; 万能引用或者右值引用才能引用右值&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++中重载运算符的问题", ["请问大家报错的地方为什么错了，怎么修改？最好是写出被修改的代码，谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;下面这段代码&amp;#xff0c;函数需要返回一个指针地址 Myint*&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    如果return *temp; 这么返回&amp;#xff0c;还是一个临时变量的拷贝&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    return temp; 这样才是返回地址&amp;#xff0c;在堆区&lt;/span&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\nMyint &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;//后置递增&lt;/span&gt;\n    {\n        Myint* temp;\n        temp &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Myint&lt;/span&gt;(*&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//先记录当前数值&lt;/span&gt;\n        m_num&amp;#43;&amp;#43;;&lt;span class=\"hljs-comment\"&gt;//再&amp;#43;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *temp;&lt;span class=\"hljs-comment\"&gt;//再返回记录的数值&lt;/span&gt;\n    }\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++中重载运算符的相关问题", ["#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Myint", "\n{\n    ", "friend", " ostream& ", "operator", "<<(ostream& cout, Myint& myint);\n", "public", ":\n    ", "Myint", "()\n    {\n        m_num = ", "0", ";\n    }\n\n    Myint& ", "operator", "++()", "//前置递增", "\n    {\n        ++m_num;", "//先+", "\n        ", "return", " *", "this", ";", "//再返回", "\n    }\n\n    Myint ", "operator", "++(", "int", ")", "//后置递增", "\n    {\n        Myint* temp;\n        temp = ", "new", " ", "Myint", "(*", "this", ");", "//先记录当前数值", "\n        m_num++;", "//再+", "\n        ", "return", " *temp;", "//再返回记录的数值", "\n    }\n\n", "private", ":\n    ", "int", " m_num;\n};\n\nostream& ", "operator", "<<(ostream& cout, Myint& myint)\n{\n    cout << myint.m_num;\n    ", "return", " cout;\n}\n\n", "void", " ", "test01", "()", "\n", "{\n    Myint myint;\n    cout << myint << endl;\n    cout << ++myint << endl;\n    cout << myint++ << endl;\n    cout << myint << endl;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "test01", "();\n    ", "return", " ", "0", ";\n}\n", "\n", "之前我在定义temp时就是简单的定义一个临时变量，然后有人跟我说匿名临时变量不能引用，后来我把重载左移运算符的myint变量前的引用去掉，确实可以运行。", "然后我就想是不是把temp变量存到堆区就可以不被删除了呢，是不是就可以取引用了呢，于是有上面的代码。结果报错原因和最开始一样，这到底是怎么回事啊", "\n", "\n", "报错说temp是未定义的标识符"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重载&amp;lt;&amp;lt;输出, 自定义的class和struct是不能直接cout的, 必须重载这个操作符才能使用cout来输出, 具体输出的内容也要重载&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++重载运算符里的格式", ["问题遇到的现象和发生背景", "\n", "本问题来源于C++ primes plus 第十三章类继承的课后习题第四题编程题，为了防止有歧义所有代码如下，只是想知道这种格式是什么意思 os<<(const Port &)vp", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include ", "using namespace std;", "class Port", "{", "private:", "    char* brand;", "    char style[20];", "    int bottles;", "public:", "    Port(const char* br = \"none\", const char* st = \"none\", int b = 0);", "    Port(const Port& p);", "    virtual ~Port() { delete[]brand;}", "    Port& operator=(const Port& p);", "    Port& operator+=(int b);", "    Port& operator-=(int b);", "    int BottleCount()const { return bottles; }", "    virtual void show()const;", "    friend ostream& operator<<(ostream& os, const Port& p);", "};", "\n", "class VintagePort :public Port", "{", "private:", "    char* nickname;", "    int year;", "public:", "    VintagePort();", "    VintagePort(const char* br, int b, const char* nn, int y);", "    VintagePort(const VintagePort& vp);", "    ~VintagePort() { delete[]nickname; }", "    VintagePort& operator=(const VintagePort& vp);", "    void show()const;", "    friend ostream& operator<<(ostream& os, const VintagePort& vp);", "\n", "};", "\n", "Port::Port(const char* br, const char* st, int b)", "{", "    brand=new char[strlen(br)+1];", "    strcpy(brand,br);", "    strcpy(style, st);", "    bottles = b;", "}", "\n", "Port::Port(const Port &p)", "{", "    brand = new char[strlen(p.brand) + 1];", "    strcpy(brand, p.brand);", "    strcpy(style, p.style);", "    bottles = p.bottles;", "}", "\n", "Port &Port:: operator=(const Port& p)", "{", "    if (this == &p)", "        return *this;", "    delete[]brand;", "    brand = new char[strlen(p.brand) + 1];", "    strcpy(brand, p.brand);", "    strcpy(style, p.style);", "    bottles = p.bottles;", "    return *this;", "    /", "brand = p.brand;", "    strcpy(style, p.style);", "    bottles = p.bottles;", "/", "}", "\n", "Port &Port::operator+=(int b)", "{", "    bottles += b;", "    return *this;", "}", "Port& Port::operator-=(int b)", "{", "    bottles -= b;", "    return *this;", "}", "void Port::show()const", "{", "    cout << \"Brand: \" << brand << endl;", "    cout << \"Kind: \" << style << endl;", "    cout << \"Bottles: \" << bottles << endl;", "}", "\n", "std::ostream& operator<<(ostream& os, const Port& p)", "{", "    os << p.brand << \",\" << p.style << \",\" << p.bottles;", "    return os;", "}", "\n", "VintagePort::VintagePort(const char* br, int b, const char* nn, int y):Port(br,\"none\",b)", "{", "    nickname = new char[strlen(nn) + 1];", "    strcpy(nickname, nn);", "    year = y;", "}", "VintagePort::VintagePort() :Port()", "{", "    nickname = new char[5];", "    strcpy(nickname, \"none\");", "    year = 0;", "}", "\n", "VintagePort::VintagePort(const VintagePort& vp) :Port(vp)", "{", "    nickname = new char[strlen(vp.nickname) + 1];", "    strcpy(nickname, vp.nickname);", "    year = vp.year;", "}", "\n", "VintagePort& VintagePort::operator=(const VintagePort& vp)", "{", "    if (this == &vp)", "        return *this;", "    delete[]nickname;", "    nickname = new char[strlen(vp.nickname) + 1];", "    strcpy(nickname, vp.nickname);", "    year = vp.year;", "    return *this;", "}", "\n", "void VintagePort::show()const", "{", "    Port::show();", "    cerr << \"Nickname\" << nickname;", "    cerr << \"Year:\" << year;", "}", "\n", "ostream& operator<<(ostream os, const VintagePort& vp)", "{", "**    ", "os << (const Port&)vp;", "\n", "```c++", "\n", "```**", "    os << \",\" << vp.nickname << vp.year << endl;", "    return os;", "}", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "原因可能跟全篇代码无关，希望各位C++er能告诉我这种是什么类型，谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对着呢呀&amp;#xff0c;比较两个人是否相等的时候&amp;#xff0c;就是比较他们的年龄。p是传进来的对象&amp;#xff0c;this是当前对象&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于重载==运算符的问题", ["如下代码所示，不理解我定义的Person类里的==重载函数为什么这么写？ bool operator==(const Person &p)中的this->m_Age和o.m_Age搞糊涂了", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<vector>", "\n", "#", "include", "<algorithm>", "\n", "#", "include", "<string>", "\n", "using", " ", "namespace", " std;\n\n", "//自定义数据类型", "\n", "class", " ", "Person", "\n{\n", "public", ":\n    ", "Person", "(string name, ", "int", " age)\n    {\n        ", "this", "->m_Name = name;\n        ", "this", "->m_Age = age;\n    }\n                ", "//不理解下面这个重载函数，希望各位大佬帮我看看", "\n    ", "bool", " ", "operator", "==(", "const", " Person &p)\n    {\n        ", "//cout << \"p.m_Age：\" << p.m_Age << \"\\t this->m_Age：\" << this->m_Age << endl;", "\n        ", "if", " (p.m_Age == ", "this", "->m_Age)\n        {\n            ", "return", " ", "true", ";\n        }\n\n        ", "else", "\n        {\n            ", "return", " ", "false", ";\n        }\n    }\n\n    string m_Name;\n    ", "int", " m_Age;\n};\n\n", "class", " ", "myPrint2", "\n{\n", "public", ":\n\n    ", "void", " ", "operator", "()", "(", "const", " Person & p)", "\n    ", "{\n        cout << ", "\"姓名：\"", " << p.m_Name << ", "\"\\t年龄：\"", " << p.m_Age << endl;\n    }\n};\n\n", "void", " ", "test02", "()", "\n", "{\n    ", "Person ", "p1", "(", "\"aa\"", ", ", "10", ")", ";\n    ", "Person ", "p2", "(", "\"bb\"", ", ", "30", ")", ";\n    ", "Person ", "p3", "(", "\"cc\"", ", ", "20", ")", ";\n    ", "Person ", "p4", "(", "\"dd\"", ", ", "10", ")", ";\n    ", "Person ", "p5", "(", "\"ee\"", ", ", "40", ")", ";\n    ", "Person ", "p6", "(", "\"ff\"", ", ", "10", ")", ";\n    vector<Person>v;\n    v.", "push_back", "(p1);\n    v.", "push_back", "(p2);\n    v.", "push_back", "(p3);\n    v.", "push_back", "(p4);\n    v.", "push_back", "(p5);\n    v.", "push_back", "(p6);\n    ", "//将所有10替换为1000", "\n    ", "Person ", "pOld", "(", "\"aa\"", ", ", "10", ")", ";\n    ", "Person ", "pNew", "(", "\"aa\"", ", ", "1000", ")", ";\n    cout << ", "\"替换前：\"", " << endl;\n    for_each(v.", "begin", "(), v.", "end", "(), ", "myPrint2", "());\n    cout << ", "\"\\n替换后：\"", " << endl;\n    ", "replace", "(v.", "begin", "(), v.", "end", "(), pOld, pNew);\n    \n    for_each(v.", "begin", "(), v.", "end", "(), ", "myPrint2", "());\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "//test01();", "\n    ", "test02", "();\n\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不会冲突&amp;#xff0c;你缺乏两个知识点。&lt;br /&gt;1、函数重载&amp;#xff0c;函数重载就是函数名相同&amp;#xff0c;而参数不同的函数&amp;#xff0c;与返回值无关。如果有两个函数同名&amp;#xff0c;参数相同&amp;#xff0c;而返回值不同&amp;#xff0c;则会报错。&lt;br /&gt;其次就是const 参数与 非const 构成重载。&lt;br /&gt;2、类成员函数后边跟一个const &amp;#xff0c;这代表这个成员函数只能被const对象调用&amp;#xff0c;另外一个类的非静态函数&amp;#xff0c;编译器会自动加一个参数&amp;#xff0c;他就是this&lt;br /&gt;结合二者&amp;#xff0c;那么拿first举例&amp;#xff0c;编译后的伪代码&lt;br /&gt;T1&amp;amp; first( Pair&amp;lt;T1,T2&amp;gt; *this)&lt;br /&gt;T1 first( const Pair&amp;lt;T1,T2&amp;gt; *this)这两个函数构成重载&amp;#xff0c;当一个const 对象调用时执行第二个&amp;#xff0c;否则执行第一个&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++类成员函数  二义性问题，求解", ["template <class T1, class T2>", "class Pair {", "private:", "        T1 a;", "        T2 b;", "public:", "        T1 & first();", "        T2 & second();", "        T1 first() const { return a; }", "        T2 second() const { return b; }", "        Pair(const T1 & aval, const T2 & bval) : a(aval), b(bval) { }", "        Pair() {}", "};", "其中", "        T1 & first();", "        T2 & second();", "        T1 first() const { return a; }", "        T2 second() const { return b; }", "这几个函数，不会存在二义性吗？", "\n", "还有看到几个运算符重载的成员函数：", "public：", "        double & operator[ ](int i);", "        double operator[ ](int i) const;", "这些都不会导致二义性吗？"]], "Tag": "程序设计"}
{"Answer": "Java 类提供了 clone 方法，可以拷贝一个对象，我们要实现深拷贝，需要对对象的每个引用属性调用 clone 方法进行深拷贝。\r\n详细可以参考这篇：https://www.cnblogs.com/Qian123/p/5710533.html", "Konwledge_Point": "运算符重载", "Question": ["Java语言如何定义拷贝构造函数和重载==运算符呢，有个c++的程序想转换", ["Java语言如何定义拷贝构造函数和重载==运算符呢，有个c++的程序想转换"]], "Tag": "程序设计"}
{"Answer": "会的！！！！！！！！！！！！！", "Konwledge_Point": "运算符重载", "Question": ["C++中这样写会不会内存泄漏，有没有好的实现方法", ["template", "\nclass Foo", "\n{", "\npublic:", "\n    Foo(T T_val);", "\n    Foo& operator=(const Foo& f);", "\n    virtual ~Foo();", "\n    const T& getTval();", "\nprivate:", "\n    const T T_val; ", "\n};", "\n\n", "template", "\nFoo::Foo(T T_val = NULL):T_val(T_val)", "\n{", "\n;", "\n}", "\ntemplate", "\nFoo::~Foo()", "\n{}", "\ntemplate", "\nFoo& Foo::operator=(const Foo& f)", "\n{", "\n    return(*new Foo(f));", "\n}", "\ntemplate", "\nconst T& Foo::getTval()", "\n{", "\n    return this->T_val;", "\n}", "\nint main()", "\n{", "\n    typedef FooFoo_int;", "\n    typedef vectorFoo_vec;", "\n    Foo_vec foo_vec(10,2);", "\n    Foo_int f(4);", "\n    foo_vec.insert(foo_vec.begin(),f);", "\n\n", "for(Foo_vec::iterator iter = foo_vec.begin();iter !=foo_vec.end();iter++)\n{\n    cout<<iter->getTval()<<endl;\n}\n", "\n\n", "}", "\n//想问一下等号运算符重载函数会不会导致内存泄漏，有没有更好的写法"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;main函数中&amp;#xff0c;调用test02函数&amp;#xff0c;必须要带()&amp;#xff0c;也就是test02()&amp;#xff0c;带上()就能正常执行test02函数了。&lt;/p&gt;\n\n&lt;p&gt;为什么没有()编译程序没有报错&amp;#xff0c;还能正常运行&amp;#xff0c;就不清楚什么原因了。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["这段代码结果为什么没有输出？", [" ", "\n\n", "\n", "#include<iostream>\nusing namespace std;\n//递增运算符重载 ++\n//自定义的整型\nclass MyInteger {\n\tfriend ostream &operator<<(ostream& cout, MyInteger myint);\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\t//重载++前置运算符\n\tMyInteger& operator++() {//返回引用是为了对一个数据进行操作 引用起别名后指向的是一个数据\n\n\t\tm_Num++;//先进行++运算\n\t\treturn *this;//再将自身做返回\n\t}\n\t//重载后置++运算符\n\t//void operator++(int)  int代表占位参数，可以用于区分前置和后置递增\n\tMyInteger operator++(int) {\n\t\t//先返回结果\n\t\tMyInteger temp = *this;\n\t\t\n\t\t//后递增\n\t\tm_Num++;\n\t\t\n\t\t//最后将记录的结果返回\n\t\treturn temp;\n\t}\n\n\nprivate:\n\tint m_Num;\n};\n//重载<<运算符\nostream& operator<<(ostream &cout, MyInteger myint) {\n\tcout << myint.m_Num ;\n\treturn cout;\n}\nvoid test01() {\n\tMyInteger myint;\n\n\tcout << ++(++myint) << endl;\n\tcout << myint << endl;\n}\nvoid test02() {\n\tMyInteger myint;\n\tcout << myint++ << endl;\n\tcout << myint << endl;\n}\n\nint main()\n{\n\t//test01();\n\t//int a = 0;\n\t//cout << ++(++a) << endl;\n\t//cout << a << endl;\n\ttest02;\n\tsystem(\"pause\");\n\treturn 0;\t\n}", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;都不完全正确&amp;#xff0c;第二个更是错误&lt;br /&gt;a&amp;#61;b;其实是a.operator&amp;#61;(b); 第二个根本没有在函数中间做改变&amp;#xff0c;所以不起作用&lt;br /&gt;第一个不完全正确是因为&amp;#xff0c;返回值不是引用&amp;#xff0c;所以要发生一次复制。&lt;br /&gt;所以最好是&lt;br /&gt;T&amp;amp; operator&amp;#61;(const T&amp;amp; rh)&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["重载运算符函数＝遇到的问题", ["\n", "这两个有什么不同吗，为什么一个正确一个错误呢，我认为都是对的啊。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为你的类不是const修饰的&amp;#xff0c;在同名的情况下会优先调用不带const的operator函数。使用const引用&amp;#xff0c;或者const修饰可以调用另外一个版本。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;tarray&amp;lt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;&amp;gt;scores &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;auto&lt;/span&gt;&amp;amp; s &amp;#61; scores;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;) cout &amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["对同一运算符两次重载，调用时优先级是怎么规定的？", ["######在书上看到了在类内对[]进行了两次重载：", "\n", "\n", "//arraytp.h -- Array Template", "\n#ifndef ARRAYTP_H_\n#define ARRAYTP_H_\n\n#include <iostream>\n#include <cstdlib>\n\ntemplate <", "class", " ", "T, ", "int", " ", "n", ">\n", "class", " ", "ArrayTP", "\n{\n", "private", ":\n    T ar[n];\n", "public", ":\n    ArrayTP() {};\n    ", "explicit", " ArrayTP(", "const", " T & v);\n    virtual T & operator[](", "int", " i);\n    virtual T operator[](", "int", " i) ", "const", ";\n};\n\ntemplate <", "class", " ", "T, ", "int", " ", "n", ">\n", "ArrayTP", "<", "T,", "n", ">::", "ArrayTP", "(", "const", " ", "T", " & ", "v", ")\n{\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n        ar[i] = v;\n}\ntemplate <", "class", " ", "T, ", "int", " ", "n", ">\n", "T", " & ", "ArrayTP", "<", "T,", "n", ">::", "operator", "[](", "int", " ", "i", ")\n{\n    ", "if", " (i < ", "0", " || i >= n)\n    {\n        std::cerr << ", "\"Error in array limits: \"", " << i\n            << ", "\" is out of range\\n\"", ";\n        std::exit(EXIT_FAILURE);\n    }\n    ", "return", " ar[i];\n}\n\ntemplate <", "class", " ", "T, ", "int", " ", "n", ">\n", "T", " ", "ArrayTP", "<", "T,", "n", ">::", "operator", "[](", "int", " ", "i", ") ", "const", "\n{\n    ", "if", " (i < ", "0", " || i >= n)\n    {\n        std::cerr << ", "\"Error in array limits: \"", " << i\n            << ", "\" is out of range\\n\"", ";\n        std::exit(EXIT_FAILURE);\n    }\n    ", "return", " ar[i];\n}\n#endif\n", "\n", "一个返回T&,另一个返回T，可是在用的时候：", "\n", "#", "include", "<iostream>", "\n", "#", "include", "\"arraytp.h\"", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    tarray<", "int", ", ", "5", ">scores = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < ", "5", "; i++) cout << scores[i] << endl;\n    ", "return", " ", "0", ";\n}\n", "\n", "我注意到调用的是 virtual T & operator[](int i);", "不太明白为什么有限调用这个版本，以及怎么写才会调用另一个版本的重载呢？"]], "Tag": "程序设计"}
{"Answer": "（1）不能，你需要重写Equals方法\r\n（2）这个简单，比较的双方都转换成大写或者小写中的一种就可以了。toupper tolower", "Konwledge_Point": "运算符重载", "Question": ["link能不能重载==运算符？如果我想让字符串忽略大小写，怎么写？ ", ["link能不能重载==运算符？如果我想让字符串忽略大小写，怎么写？ "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为运算函数需要知道运算对象的全部信息&amp;#xff0c;重载双目运算符的时候&amp;#xff0c;如果写成成员函数&amp;#xff0c;代表只要这个类在&amp;#xff0c;你就能知道入参是什么类型&amp;#xff0c;但很多时候不是这样。比如老林提的cout运算符&amp;#xff0c;如果你自己写了一个类&amp;#xff0c;想实现直接cout &amp;lt;&amp;lt; myObj 这样的效果&amp;#xff0c;就需要重载iostream的&amp;lt;&amp;lt;的友元函数&amp;#xff0c;但是iostream库在创建的时候是肯定不知道你会自己定义一个类并重载输出函数的&amp;#xff0c;所以只能留一个友元函数的口子给后续的开发了。&lt;br /&gt;相反iostream库在开发的时候是知道基本类型int&amp;#xff0c;double&amp;#xff0c;float这些类型的&amp;#xff0c;因此这些对象的输出函数是可以写成成员函数的。&lt;br /&gt;不过还要考虑一个因素是后续的扩展&amp;#xff0c;更新和模块化&amp;#xff0c;毕竟双目运算符将两个类型相关的代码写到了一起&amp;#xff0c;从工程角度看就是耦合了&amp;#xff0c;所以一般会单独找个地方定义友元函数&amp;#xff0c;这样修改友元函数的内容就不用连带着把cout类的内容一块改了&amp;#xff0c;工程上会有很大优势。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于c++中运算符重载的问题", ["如题", "为什么一般情况下将双目运算符函数重载为友元函数，单目运算符多重载为成员函数？", "\n", "除了成员函数第一个参数必须是本类的对象和和交换律有关的原因外，还有什么其他原因吗🤯"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为你在友元函数内试图返回函数内创建的&lt;code class=\"language-javascript\"&gt;临时变量&lt;/code&gt;&lt;br /&gt;c在函数返回后就会被销毁,你返回到外部的值没有意义&lt;br /&gt;改为&lt;code class=\"language-javascript\"&gt;动态新建&lt;/code&gt;并返回即可&lt;br /&gt;此外你似乎没有考虑到除法会出现分数,如果用int去作为复数的成员,在计算除法时可能出错.&lt;br /&gt;我只简单修改了加法和减法的部分,剩余两种运算同理&lt;br /&gt;示例代码如下&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;有帮助望采纳~&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-cpp\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Plural&lt;/span&gt;\n{\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real, image;\n    &lt;span class=\"hljs-built_in\"&gt;Plural&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a1, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b1)\n    {\n        a1 &amp;#61; real;\n        b1 &amp;#61; image;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Plural&lt;/span&gt;()\n    {\n    }\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;out, Plural &amp;amp;p);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; istream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream &amp;amp;in, Plural &amp;amp;p);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Plural &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(Plural a, Plural b);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Plural &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Plural a, Plural b);\n};\nostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;out, Plural &amp;amp;p)\n{\n    out &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;{&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p.real;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p.image &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        out &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt;;\n    out &amp;lt;&amp;lt; p.image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;\n        &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;}&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; out;\n}\nistream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream &amp;amp;in, Plural &amp;amp;p)\n{\n    in &amp;gt;&amp;gt; p.real;\n    in &amp;gt;&amp;gt; p.image;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; in;\n}\nPlural &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(Plural a, Plural b)\n{\n    Plural *c &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Plural;\n    c-&amp;gt;real &amp;#61; a.real - b.real;\n    c-&amp;gt;image &amp;#61; a.image - b.image;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *c;\n}\nPlural &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Plural a, Plural b)\n{\n    Plural *c &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Plural;\n    c-&amp;gt;real &amp;#61; a.real &amp;#43; b.real;\n    c-&amp;gt;image &amp;#61; a.image &amp;#43; b.image;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *c;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Plural a, b;\n    cin &amp;gt;&amp;gt; a;\n    cin &amp;gt;&amp;gt; b;\n    cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; (a &amp;#43; b) &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; a - b &amp;lt;&amp;lt; endl;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/336758704646124.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++重载输出运算符出错（输出复数的四则运算）", ["问题遇到的现象", "\n", "想要直接输出复数的四则运算，直接输出复数没有问题。", "\n", "问题相关代码", "\n", "1.重载输出函数", "\n", "ostream &", "operator", "<<(ostream &", "out", ", Plural &p)\n{\n    ", "out", "<<", "\"{\"", "<<p.real;\n    ", "if", "(p.image>", "0", ")\n    ", "out", "<<", "\"+\"", "; \n    ", "out", "<<p.image<<", "\"i\"", "<<", "\"}\"", ";\n    ", "return", " ", "out", ";\n}\n", "\n", "2.重载加法运算", "\n", "Plural operator+(Plural a,Plural b)\n{\n    Plural c;\n    c.", "real", "=a.", "real", "+b.", "real", ";\n    c.", "image", "=a.", "image", "+b.", "image", ";\n    ", "return", " c;\n}\n", "\n", "3.主函数", "\n", "int ", "main", "()\n{\n    Plural ", "a", ",", "b", ";\n    cin>>", "a", ";\n    cin>>", "b", ";\n cout<<", "a", "<<endl;\n cout<<", "b", "<<endl;\n\ncout<<(", "a", "+", "b", ")<<endl;\n//    cout<<", "a", "-", "b", "<<endl;\n//    cout<<", "a", "*", "b", "<<endl;\n//    cout<<", "a", "/", "b", "<<endl;\n    return ", "0", ";\n}\n", "\n", "总的代码", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Plural", "{\n\n    ", "public", ":\n            ", "int", " real,image;\n        ", "Plural", "(", "int", " a1,", "int", " b1)\n        {\n            a1=real;\n            b1=image;\n        }\n        ", "Plural", "()\n        {\n            \n        }\n        ", "friend", " ostream &", "operator", "<<(ostream &out,Plural &p);\n        ", "friend", " istream &", "operator", ">>(istream &in,Plural &p);\n        ", "friend", " Plural ", "operator", "-(Plural a,Plural b);\n        ", "friend", " Plural ", "operator", "+(Plural a,Plural b);\n        ", "friend", " Plural ", "operator", "*(Plural a,Plural b);\n        ", "friend", " Plural ", "operator", "/(Plural a,Plural b);\n};\nostream &", "operator", "<<(ostream &out, Plural &p)\n{\n    out<<", "\"{\"", "<<p.real;\n    ", "if", "(p.image>", "0", ")\n    out<<", "\"+\"", "; \n    out<<p.image<<", "\"i\"", "<<", "\"}\"", ";\n    ", "return", " out;\n}\nistream &", "operator", ">>(istream &in,Plural &p)\n{\n    in>>p.real;\n    in>>p.image;\n    ", "return", " in;\n}\nPlural ", "operator", "-(Plural a,Plural b)\n{\n    Plural c;\n    c.real=a.real-b.real;\n    c.image=a.image-b.image;\n    ", "return", " c;\n}\nPlural ", "operator", "+(Plural a,Plural b)\n{\n    Plural c;\n    c.real=a.real+b.real;\n    c.image=a.image+b.image;\n    ", "return", " c;\n}\nPlural ", "operator", "*(Plural a,Plural b)\n{\n    Plural c;\n    c.real=a.real*b.real-a.image*b.image;\n    c.image=a.real*b.image+a.image*b.real;\n    ", "return", " c;\n}\nPlural ", "operator", "/(Plural a,Plural b)\n{\n    ", "int", " d;\n    d=b.real*b.real-b.image*b.image;\n    Plural c;\n    c.real= (a.real*b.real-a.image*b.image)/d;\n    c.image=(a.real*b.image+a.image*b.real)/d;\n}\n", "int", " ", "main", "()", "\n", "{\n    Plural a,b;\n    cin>>a;\n    cin>>b;\n    cout<<a<<endl;\n    cout<<b<<endl;\n", "//    cout<<(a+b)<<endl;", "\n", "//    cout<<a-b<<endl;", "\n", "//    cout<<a*b<<endl;", "\n", "//    cout<<a/b<<endl;", "\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "输出单个复数（正常）", "\n", "\n", "输出复数的加（报错）", "\n", "\n", "我想要达到的结果", "\n", "怎么样通过重载运算符来输出两个复数的和，不能添加第三个变量。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Person(string name,string sex,int age){&lt;!-- --&gt;&lt;br /&gt;cout&amp;lt;&amp;lt;&amp;#34;Person Constructed!&amp;#34;&amp;lt;&amp;lt;endl;&lt;br /&gt;}&lt;br /&gt;改成&lt;br /&gt;Person(string n,string s,int a){&lt;!-- --&gt;&lt;br /&gt;name &amp;#61; n;&lt;br /&gt;sex &amp;#61; s;&lt;br /&gt;age &amp;#61; a;&lt;br /&gt;cout&amp;lt;&amp;lt;&amp;#34;Person Constructed!&amp;#34;&amp;lt;&amp;lt;endl;&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;Student(string name, string sex, int age, string major, int grade, int gpa) {&lt;!-- --&gt;&lt;br /&gt;cout&amp;lt;&amp;lt;&amp;#34;Student Constructed!&amp;#34;&amp;lt;&amp;lt;endl;&lt;br /&gt;}&lt;br /&gt;改成&amp;#xff1a;&lt;br /&gt;Student(string name, string sex, int age, string m, int g, int p) :Person(name,sex,age){&lt;!-- --&gt;&lt;br /&gt;major &amp;#61; m;grade &amp;#61; g;gpa&amp;#61; p;&lt;br /&gt;cout&amp;lt;&amp;lt;&amp;#34;Student Constructed!&amp;#34;&amp;lt;&amp;lt;endl;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["怎样创建满足要求的子类，并且按要求进行输出？", ["\n", "#include", "using namespace std;", "#include", "\n", "class Person{", "public:", "    string name,sex;", "    int age;", "    Person(string name,string sex,int age){", "        cout<<\"Person Constructed!\"<<endl;", "    }", "    Person(const Person & p){", "        cout<<\"Person Copied!\"<<endl;", "    }", "    virtual void PrintInfo(){", "cout<<\"class\"<<\"name\"<<name<<\"sex\"<<sex<<\"age\"<<age", "    }", "~Person(){cout<<\"Person Destructed!\"<<endl;}", "};", "\n", "class Student:public Person{", "public:", "     Student(string name, string sex, int age, string major, int grade, int gpa) {", "        cout<<\"Student Constructed!\"<<endl;", "    }", "    Student(const Student &p): Person(p) {", "        cout<<\"Student Copied!\"<<endl;", "    }", "    ~Student(){cout<<\"Student Destructed!\"<<endl;}", "    string major;", "     int grade,gpa;", "};", "\n", "class Worker:public Person{", "    Worker(string name,string sex,int age,string nationality,float salary){", "        cout<<\"Worker Constructed!\"<<endl;", "    }", "    Worker(const Worker &p): Person(p) {", "        cout<<\"Worker Copied!\"<<endl;", "    }", "    ~Worker(){cout<<\"Worker Destructed!\"<<endl;}", "    string nationality,salary;", "};", "int main() {", "\n", "Person ", "person", "(", "\"Allen\"", ", ", "\"male\"", ", ", "29", ")", ";\nStudent ", "student", "(", "\"Frank\"", ", ", "\"male\"", ", ", "15", ", ", "\"Robotics\"", ", ", "17", ", ", "3.5", ")", ";\nWorker ", "worker", "(", "\"Ben\"", ", ", "\"male\"", ", ", "45", ", ", "\"China\"", ", ", "3500.0f", ")", ";\n", "// 调用多态函数,按要求输出信息", "\n person.PrintInfo();\nstudent.PrintInfo();\nworker.PrintInfo();\n", "// 验证运算符重载的正确性", "\nworker(", "\"Ben\"", ", ", "\"male\"", ", ", "45", ", ", "\"China\"", ", ", "3500.0f", ");\nstd::cout << student << std::endl;\n", "// 对三个实例进行拷贝", "\n ", "Person", " ", "person2", " ", "=", " person;\n ", "Student", " ", "student2", " ", "=", " student;\n ", "Worker", " ", "worker2", " ", "=", " worker;\n ", "// 对其中一个拷贝得到的实例调用多态函数,输出信息", "\n worker2.PrintInfo();\n\n", "return", " ", "0", ";\n", "\n", "}", "ostream &append(ostream & append,Student & stu){", "    cout<<\"I'm a student named \"<<stu.name<<endl;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Complex&lt;/span&gt;&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    double real;\n    double image;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    Complex(double r,double i)\n    {\n        real&amp;#61;r; image&amp;#61;i;\n    }\n    Complex(double r)\n    {\n        real&amp;#61;r; image&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    Complex()\n    {\n        real&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; image&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right) \n    {\n        Complex temp;\n        temp.real &amp;#61; real &amp;#43; Right.real;\n        temp.image &amp;#61; image &amp;#43; Right.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n    }\n\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; - (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right) {\n        Complex temp;\n        temp.real &amp;#61; real - Right.real;\n        temp.image &amp;#61; image - Right.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n    }\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;(){\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --(){\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image -&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; * (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right) {\n        Complex temp;\n        temp.real &amp;#61; real * Right.real - image * Right.image;\n        temp.image &amp;#61; real * Right.image &amp;#43; image * Right.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n    }\n\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; /(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right)\n    {\n        Complex temp;\n        temp.real&amp;#61;real/Right.real;\n        temp.image &amp;#61;image/Right.real;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n    }\n\n    int &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#61;&amp;#61; Right.real &amp;amp;&amp;amp; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image &amp;lt; Right.image)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n\n    int &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;gt; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;gt; Right.real)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#61;&amp;#61; Right.real &amp;amp;&amp;amp; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image &amp;lt; Right.image)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#61;&amp;#61; Right.real &amp;amp;&amp;amp; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image &amp;#61;&amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n\n    friend void print(Complex comp);\n\n};\n\n\nvoid print(Complex comp)\n{\n    cout&amp;lt;&amp;lt; comp.real &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#43; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;comp.image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n}\n\nint main()\n{\n    Complex c1(&lt;span class=\"hljs-number\"&gt;3.5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5.5&lt;/span&gt;);\n    Complex c2(-&lt;span class=\"hljs-number\"&gt;3.5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1.0&lt;/span&gt;);\n\n    Complex t1 &amp;#61; c1 &amp;#43; c2; \n    print(t1);\n    Complex t2 &amp;#61; c1 - c2;\n    print(t2);\n    \n    t2--;\n    print(t2);\n\n    t1&amp;#43;&amp;#43;;\n    print(t1);\n\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(t1&amp;gt;t2)\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;t1 &amp;gt; t2&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(t1&amp;#61;&amp;#61;t2)\n        cout &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;t1&amp;#61;&amp;#61;t2&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        cout &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;t1&amp;lt;t2&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["定义一个复数类，重载运算符“+”，“-”，“++”，“>”，使之用于复数的加、减、自加并比较两个复数大小；", ["定义一个复数类，重载运算符“+”，“-”，“++”，“>”，使之用于复数的加、减、自加并比较两个复数大小；"]], "Tag": "程序设计"}
{"Answer": "大概因为拷贝构造函数是新建一个对象，而赋值运算符(=)是复制。\r\n简单的例子，某个类如果需要唯一序列号，调用拷贝构造函数则会生成新的序列号，而调用赋值运算符应该是同一序列号", "Konwledge_Point": "运算符重载", "Question": ["MyString(const MyString &_str);跟运算符=的重载不是一个意思吗？为什么复制构造函数的定义不能像=重载那样写？", ["\n//6-24.2classfile.cpp", "\n\n", "#include <iostream>\n#include <string.h>\n#include \"6-24.2classfile.h\"\nusing namespace std;\n//constructor&destructor\nMyString::MyString()\n{\n    str=new char;//???\n    str[0]='\\0';\n    len=0;   //为什么长度等于0？ \n}\nMyString::MyString(const char *_str)   //char *_str是一个char数组 \n{\n    len=strlen(_str);\n    str=new char[len+1];\n    str[len]='\\0';\n    strncpy(str,_str,len+1);        //strncpy有三个参数\n    // char *strncpy(char *dest, const char *src, size_t n) \n    //把 src 所指向的字符串复制到 dest，最多复制 n 个字符。\n    /*当_str长度小于第三个参数n时 ，str的剩余部分将用空字节填充*/ \n}\nMyString::MyString(const MyString &_str)\n{\n    len =_str.len;\n    str=new char[len+1];\n    str[len]='\\0';\n    strncpy(str,_str.str,len+1);        //_str.str(_str\n    //cout<<str<<endl;\n}\nvoid MyString::operator =(const MyString &_str)\n{\n    str=_str.str;\n    len=_str.len;\n}\nMyString::~MyString(){                  //???\n}\n//operator\nconst MyString MyString::operator +(const MyString &_str)\n{\n    int newLen=len+_str.len;\n    char *newStr=new char[newLen+1];\n    newStr[newLen]='\\0';\n    strncpy(newStr,str,len);        //先将str(原字符串)复制到新的字符数组 \n    strncat(newStr,_str.str,_str.len);    //在将_str.str将接到newStr后面\n    /*char *strncat(char *dest, const char *src, size_t n)\n     把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。*/ \n    return MyString(newStr);       //返回一个MyString类对象 \n}\n\n//friend\nistream & operator >>(istream &_in,MyString &_str)\n{\n    _in>>_str.str;                      //istream是什么鬼？ 输入流 \n    _str.len=strlen(_str.str);\n    return _in;\n}\nostream & operator <<(ostream &_out,MyString &_str)\n{\n    _out<<_str.str<<endl<<\"length:\"<<_str.len;  //\n    return _out; \n}\n", "\n\n", "//6-24.2classfile.h ", "\n\n", "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass MyString{\n    public:\n        MyString();\n        MyString(const char *_str);\n        MyString(const MyString &_str);\n        ~MyString();\n    public:\n        const MyString operator +(const MyString &_str);\n        void operator =(const MyString &_str);\n        void operator +=(const MyString& _str);\n        const char operator [](int i);\n    public:\n        friend istream & operator >>(istream &_in,MyString &_str);\n        friend ostream & operator <<(ostream &_out, MyString &_str); \n    private:\n        char *str;\n        int len;\n};\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;Rational answer;&amp;#61;&amp;#61;&amp;#61;这行有问题&amp;#xff0c;也就是    Rational 类的构造函数 &lt;span class=\"hljs-constructor\"&gt;Rational(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;numerator&lt;/span&gt;&amp;#61;0, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;denominator&lt;/span&gt;&amp;#61;0)&lt;/span&gt;;有问题\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当定义answer时&amp;#xff0c;由于没有传入参数&amp;#xff0c;导致两个参数值默认都是0&amp;#xff0c;这样在normalize_();函数中就崩溃了&amp;#xff0c;因为 numerator /&amp;#61; a;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    denominator /&amp;#61; a;时&amp;#xff0c;a是0&amp;#xff0c;所以出现除零错误。&lt;/span&gt;&lt;br /&gt;在构造函数中对参数为零进行判断&amp;#xff0c;为0则不进行normalize_()函数处理&amp;#xff0c;或者增加一个无参构造函数&amp;#xff0c;什么也不用做&amp;#xff0c;然后当前构造函数中去掉默认值。这样也可以&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;using namespace std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Rational&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; numerator;                                            \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; denominator;\n    &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;normalize_&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    Rational() {}\n    Rational(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; numerator, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; denominator);  \n    friend Rational operator&amp;#43;(Rational r1, Rational r2);        \n    friend Rational operator-(Rational r1, Rational r2);\n    friend Rational operator*(Rational r1, Rational r2);\n    friend Rational operator/(Rational r1, Rational r2);\n    friend istream &amp;amp;operator&amp;gt;&amp;gt;(istream &amp;amp;in, Rational&amp;amp; r);        \n    friend ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;out, Rational&amp;amp; r);    \n    friend bool operator&amp;#61;&amp;#61;(Rational r1,Rational r2);\n    Rational &lt;span class=\"hljs-title function_\"&gt;normalize&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;;      \n};\nRational::Rational(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; denom)\n{\n    numerator &amp;#61; num;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (denominator !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)   denominator &amp;#61; denom;                &lt;span class=\"hljs-comment\"&gt;// 分母不能为0,在流输入运算符重载中也有定义&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;denominator&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    normalize_();\n}\nRational Rational::normalize()                            \n{                                                                &lt;span class=\"hljs-comment\"&gt;//求出分子和分母的最大公约数&amp;#xff0c;用欧几里得算法&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;a&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; abs(numerator);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;b&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; abs(denominator);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (b &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;t&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; a % b;\n        a &amp;#61; b;\n        b &amp;#61; t;\n    }\n    Rational &lt;span class=\"hljs-title function_\"&gt;R&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(numerator / a, denominator / a)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; R;\n}\nRational operator&amp;#43;(Rational r1, Rational r2)                    &lt;span class=\"hljs-comment\"&gt;//重载加法运算符&amp;#xff0c;分数的加法&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;a&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r1.numerator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;b&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r1.denominator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;c&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.numerator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;d&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.denominator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;e&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; a * d &amp;#43; b * c;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;f&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; b * d;\n    Rational &lt;span class=\"hljs-title function_\"&gt;R&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(e, f)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; R;\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; Rational::normalize_()\n{\n \n                                                                &lt;span class=\"hljs-comment\"&gt;//求出分子和分母的最大公约数&amp;#xff0c;用欧几里得算法&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;a&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; abs(numerator);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;b&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; abs(denominator);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (b &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;t&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; a % b;\n        a &amp;#61; b;\n        b &amp;#61; t;\n    }\n    numerator /&amp;#61; a;\n    denominator /&amp;#61; a;\n}\n \nRational operator-(Rational r1, Rational r2)                    &lt;span class=\"hljs-comment\"&gt;//重载减法运算符,函数结构和加法一致&amp;#xff0c;返回加法运算&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;a&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r1.numerator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;b&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r1.denominator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;c&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.numerator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;d&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.denominator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;e&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; a * d - b * c;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;f&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; b * d;\n    Rational &lt;span class=\"hljs-title function_\"&gt;R&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(e, f)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; R;\n}\n \nRational operator*(Rational r1, Rational r2)                    &lt;span class=\"hljs-comment\"&gt;//重载乘法运算符&amp;#xff0c;调用初始化类是化简了分数&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;a&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r1.numerator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;b&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r1.denominator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;c&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.numerator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;d&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.denominator;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;e&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; a * c;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;f&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; b * d;\n    Rational &lt;span class=\"hljs-title function_\"&gt;R&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(e, f)&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; R;\n}\n \nRational operator/(Rational r1, Rational r2)                    &lt;span class=\"hljs-comment\"&gt;//返回乘法运算函数体&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;t&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; r2.numerator;\n    r2.numerator &amp;#61; r2.denominator;\n    r2.denominator &amp;#61; t;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; operator*(r1, r2);\n}\nbool operator&amp;#61;&amp;#61;(Rational r1,Rational r2)\n{\n     &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(r1.numerator &amp;#61;&amp;#61;r2.numerator &amp;amp;&amp;amp; r1.denominator &amp;#61;&amp;#61;r2.denominator )\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\nistream &amp;amp;operator&amp;gt;&amp;gt;(istream &amp;amp;in, Rational&amp;amp; r)                    &lt;span class=\"hljs-comment\"&gt;//流输入运算符&lt;/span&gt;\n{\n    in &amp;gt;&amp;gt; r.numerator&amp;gt;&amp;gt; r.denominator;                            &lt;span class=\"hljs-comment\"&gt;//避免除0错误&amp;#xff0c;进行判断&amp;#xff0c;分母为0时程序结束&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r.denominator !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; in;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;输入有误&amp;#34;&lt;/span&gt;;\n        exit(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    }\n}\n \nostream &amp;amp;operator&amp;lt;&amp;lt;(ostream &amp;amp;out, Rational&amp;amp; r)                    &lt;span class=\"hljs-comment\"&gt;//流输出运算符&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r.numerator%r.denominator &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)                            &lt;span class=\"hljs-comment\"&gt;//进行判断&amp;#xff0c;当为一个整数时&amp;#xff0c;改变输出&lt;/span&gt;\n        out &amp;lt;&amp;lt; r.numerator / r.denominator;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        out &amp;lt;&amp;lt; r.numerator &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\\\&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;r.denominator;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; out;\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;Test&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//有问题&lt;/span&gt;\n   cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;共10道题&amp;#xff0c;做100以内的加减运算&amp;#xff0c;满分100分:\\n&amp;#34;&lt;/span&gt;;\n   &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; score&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n   &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; op;\n   &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;;i&amp;#43;&amp;#43;)\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;m1&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand() % &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//生成1-100的随机数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;n1&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand() % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;m2&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand() % &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;n2&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand() % &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    Rational &lt;span class=\"hljs-title function_\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(m1,n1)&lt;/span&gt;,b(m2,n2);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;m3&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand()%&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;-&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;n3&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand()%&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;-&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;m4&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand()%&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;-&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-variable\"&gt;n4&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; rand()%&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;-&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    Rational &lt;span class=\"hljs-title function_\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(m3,n3)&lt;/span&gt;,d(m4,n4);\n    Rational answer;\n    op&amp;#61;rand()%&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//产生随机加减乘除运算的4个值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt;(op)\n {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n    answer&amp;#61;a&amp;#43;b;\n    cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;加上&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;等于&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n    cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;减去&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;等于&amp;#34;&lt;/span&gt;;\n    answer &amp;#61;a-b;\n    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:\n    answer&amp;#61;c*d;\n    cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;乘以&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;等于&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n    answer&amp;#61;c/d;\n    cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;除以以&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;d&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;等于&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;    \n}\n      Rational temp;\n    cin&amp;gt;&amp;gt;temp; &lt;span class=\"hljs-comment\"&gt;//输入用户计算值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(answer&amp;#61;&amp;#61;temp) &lt;span class=\"hljs-comment\"&gt;//比较用户计算值&lt;/span&gt;\n{\nscore&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n{\ncout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;此题做错了\\n&amp;#34;&lt;/span&gt;;\ncout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;正确答案为:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;answer&amp;lt;&amp;lt;endl;\n}\n}\ncout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;你的最后得分是:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;score&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;{\n    Rational &lt;span class=\"hljs-title function_\"&gt;r1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)&lt;/span&gt;;\n    Rational &lt;span class=\"hljs-title function_\"&gt;r2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;;\n    Rational &lt;span class=\"hljs-title function_\"&gt;r3&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;do&lt;/span&gt;{\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;cls&amp;#34;&lt;/span&gt;);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t这是一个简单的计算器程序&amp;#xff0c;可以实现以下功能&amp;#xff0c;请按对应的按键(1-5)\\n\\n\\n&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;MENU&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;\\n&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t1:有理数加法&amp;#xff0c;以0结束\\n&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t2:有理数减法&amp;#xff0c;以0结束\\n&amp;#34;&lt;/span&gt;;    \n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t3:有理数乘法&amp;#xff0c;以0结束\\n&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t4:有理数除法&amp;#xff0c;以0结束\\n&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t5测试&amp;#xff1a;每次10题 由计算机随机出题 每题10分 共100分&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t0:退出程序\\n\\n:&amp;#34;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t请您选择:&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; choise;\n    cin &amp;gt;&amp;gt; choise;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (choise &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {   \n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;first number r1:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r1;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;last number r2:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r2;\n        r3&amp;#61;r1&amp;#43;r2;\n        cout&amp;lt;&amp;lt;r3&amp;lt;&amp;lt;endl; \n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (choise &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n    {   cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;first number r1:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r1;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;last number r2:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r2;\n        r3&amp;#61;r1-r2;\n        cout&amp;lt;&amp;lt;r3&amp;lt;&amp;lt;endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (choise &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\n    {   cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;first number r1:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r1;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;last number r2:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r2;\n        r3&amp;#61;r1*r2;\n        cout&amp;lt;&amp;lt;r3&amp;lt;&amp;lt;endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (choise &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)\n    {   cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;first number r1:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r1;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;last number r2:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        cin &amp;gt;&amp;gt; r2;\n        r3&amp;#61;r1/r2;\n        cout&amp;lt;&amp;lt;r3&amp;lt;&amp;lt;endl; \n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(choise &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;){\n        Test();\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (choise &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;//用户选0则结束调用函数&lt;/span&gt;\n    {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\n\\n\\t欢迎下次继续使用计算器!\\n&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n     }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\n\\t输入错误&amp;#xff0c;请按任意键继续!\\n&amp;#34;&lt;/span&gt;;\n    }system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n}&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["void Test函数是错误的 想知道怎么改", ["分数计算器", "\n", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Rational", "{\n    ", "int", " numerator;                                            \n    ", "int", " denominator;\n    ", "void", " ", "normalize_", "()", ";\n", "public", ":\n    ", "Rational", "(", "int", " numerator=", "0", ", ", "int", " denominator=", "0", ");  \n    ", "friend", " Rational ", "operator", "+(Rational r1, Rational r2);        \n    ", "friend", " Rational ", "operator", "-(Rational r1, Rational r2);\n    ", "friend", " Rational ", "operator", "*(Rational r1, Rational r2);\n    ", "friend", " Rational ", "operator", "/(Rational r1, Rational r2);\n    ", "friend", " istream &", "operator", ">>(istream &in, Rational& r);        \n    ", "friend", " ostream &", "operator", "<<(ostream &out, Rational& r);    \n    ", "friend", " ", "bool", " ", "operator", "==(Rational r1,Rational r2);\n    ", "Rational ", "normalize", "()", ";      \n};\nRational::", "Rational", "(", "int", " num, ", "int", " denom)\n{\n    numerator = num;\n    ", "if", " (denominator != ", "0", ")   denominator = denom;                ", "// 分母不能为0,在流输入运算符重载中也有定义", "\n    ", "else", " denominator = ", "1", ";\n    ", "normalize_", "();\n}\n", "Rational ", "Rational::normalize", "()", "                            \n", "{                                                                ", "//求出分子和分母的最大公约数，用欧几里得算法", "\n    ", "int", " a = ", "abs", "(numerator);\n    ", "int", " b = ", "abs", "(denominator);\n    ", "while", " (b > ", "0", ")\n    {\n        ", "int", " t = a % b;\n        a = b;\n        b = t;\n    }\n    ", "Rational ", "R", "(numerator / a, denominator / a)", ";\n    ", "return", " R;\n}\nRational ", "operator", "+(Rational r1, Rational r2)                    ", "//重载加法运算符，分数的加法", "\n{\n    ", "int", " a = r1.numerator;\n    ", "int", " b = r1.denominator;\n    ", "int", " c = r2.numerator;\n    ", "int", " d = r2.denominator;\n    ", "int", " e = a * d + b * c;\n    ", "int", " f = b * d;\n    ", "Rational ", "R", "(e, f)", ";\n    ", "return", " R;\n}\n", "void", " ", "Rational::normalize_", "()", "\n", "{\n\n                                                                ", "//求出分子和分母的最大公约数，用欧几里得算法", "\n    ", "int", " a = ", "abs", "(numerator);\n    ", "int", " b = ", "abs", "(denominator);\n    ", "while", " (b > ", "0", ")\n    {\n        ", "int", " t = a % b;\n        a = b;\n        b = t;\n    }\n    numerator /= a;\n    denominator /= a;\n}\n\nRational ", "operator", "-(Rational r1, Rational r2)                    ", "//重载减法运算符,函数结构和加法一致，返回加法运算", "\n{\n    ", "int", " a = r1.numerator;\n    ", "int", " b = r1.denominator;\n    ", "int", " c = r2.numerator;\n    ", "int", " d = r2.denominator;\n    ", "int", " e = a * d - b * c;\n    ", "int", " f = b * d;\n    ", "Rational ", "R", "(e, f)", ";\n    ", "return", " R;\n}\n\nRational ", "operator", "*(Rational r1, Rational r2)                    ", "//重载乘法运算符，调用初始化类是化简了分数", "\n{\n    ", "int", " a = r1.numerator;\n    ", "int", " b = r1.denominator;\n    ", "int", " c = r2.numerator;\n    ", "int", " d = r2.denominator;\n    ", "int", " e = a * c;\n    ", "int", " f = b * d;\n    ", "Rational ", "R", "(e, f)", ";\n    ", "return", " R;\n}\n\nRational ", "operator", "/(Rational r1, Rational r2)                    ", "//返回乘法运算函数体", "\n{\n    ", "int", " t = r2.numerator;\n    r2.numerator = r2.denominator;\n    r2.denominator = t;\n    ", "return", " ", "operator", "*(r1, r2);\n}\n", "bool", " ", "operator", "==(Rational r1,Rational r2)\n{\n     ", "if", "(r1.numerator ==r2.numerator && r1.denominator ==r2.denominator )\n        ", "return", " ", "true", ";\n    ", "else", "\n        ", "return", " ", "false", ";\n}\nistream &", "operator", ">>(istream &in, Rational& r)                    ", "//流输入运算符", "\n{\n    in >> r.numerator>> r.denominator;                            ", "//避免除0错误，进行判断，分母为0时程序结束", "\n    ", "if", " (r.denominator != ", "0", ")\n        ", "return", " in;\n    ", "else", "\n    {\n        cout << ", "\"输入有误\"", ";\n        ", "exit", "(", "0", ");\n    }\n}\n\nostream &", "operator", "<<(ostream &out, Rational& r)                    ", "//流输出运算符", "\n{\n    ", "if", " (r.numerator%r.denominator == ", "0", ")                            ", "//进行判断，当为一个整数时，改变输出", "\n        out << r.numerator / r.denominator;\n    ", "else", "\n        out << r.numerator << ", "\"\\\\\"", "<<r.denominator;\n        ", "return", " out;\n}\n", "void", " ", "Test", "()", "{", "//有问题", "\n   cout<<", "\"共10道题，做100以内的加减运算，满分100分:\\n\"", ";\n   ", "int", " score=", "0", ";\n   ", "char", " op;\n   ", "for", "(", "int", " i=", "0", ";i<=", "9", ";i++)\n{\n    ", "int", " m1 = ", "rand", "() % ", "10", " + ", "1", "; ", "//生成1-100的随机数", "\n    ", "int", " n1 = ", "rand", "() % ", "100", " + ", "1", ";\n    ", "int", " m2 = ", "rand", "() % ", "10", " + ", "1", ";\n    ", "int", " n2 = ", "rand", "() % ", "100", " + ", "1", ";\n    ", "Rational ", "a", "(m1,n1)", ",", "b", "(m2,n2)", ";\n    ", "int", " m3 = ", "rand", "()%", "20", "-10", ";\n    ", "int", " n3 = ", "rand", "()%", "20", "-10", ";\n    ", "int", " m4 = ", "rand", "()%", "20", "-10", ";\n    ", "int", " n4 = ", "rand", "()%", "20", "-10", ";\n    ", "Rational ", "c", "(m3,n3)", ",", "d", "(m4,n4)", ";\n    Rational answer;\n    op=", "rand", "()%", "4", "; ", "//产生随机加减乘除运算的4个值", "\n    ", "switch", "(op)\n {\n    ", "case", " ", "0", ":\n    answer=a+b;\n    cout<<a<<", "\"加上\"", "<<b<<", "\"等于\"", ";\n    ", "break", ";\n    ", "case", " ", "1", ":\n    cout<<a<<", "\"减去\"", "<<b<<", "\"等于\"", ";\n    answer =a-b;\n    ", "break", ";\n    ", "case", " ", "2", ":\n    answer=c*d;\n    cout<<c<<", "\"乘以\"", "<<d<<", "\"等于\"", ";\n    ", "break", ";\n    ", "case", " ", "3", ":\n    answer=c/d;\n    cout<<c<<", "\"除以以\"", "<<d<<", "\"等于\"", ";\n    ", "break", ";    \n}\n      Rational temp;\n    cin>>temp; ", "//输入用户计算值", "\n    ", "if", "(answer==temp) ", "//比较用户计算值", "\n{\nscore+=", "10", ";\n}\n", "else", "\n{\ncout<<", "\"此题做错了\\n\"", ";\ncout<<", "\"正确答案为:\"", "<<answer<<endl;\n}\n}\ncout<<", "\"你的最后得分是:\"", "<<score<<endl;\n}\n", "int", " ", "main", "()", "{\n    ", "Rational ", "r1", "(", "1", ",", "2", ")", ";\n    ", "Rational ", "r2", "(", "1", ",", "3", ")", ";\n    ", "Rational ", "r3", "(", "1", ",", "4", ")", ";\n", "do", "{\n    ", "system", "(", "\"cls\"", ");\n    cout << ", "\"\\t这是一个简单的计算器程序，可以实现以下功能，请按对应的按键(1-5)\\n\\n\\n\"", ";\n    cout << ", "\"\\t=========================MENU===========================\\n\"", ";\n    cout << ", "\"\\t1:有理数加法，以0结束\\n\"", ";\n    cout << ", "\"\\t2:有理数减法，以0结束\\n\"", ";    \n    cout << ", "\"\\t3:有理数乘法，以0结束\\n\"", ";\n    cout << ", "\"\\t4:有理数除法，以0结束\\n\"", ";\n    cout << ", "\"\\t5测试：每次10题 由计算机随机出题 每题10分 共100分\"", ";\n    cout << ", "\"\\t0:退出程序\\n\\n:\"", ";\n    cout << ", "\"\\t请您选择:\"", ";\n    ", "int", " choise;\n    cin >> choise;\n    ", "if", " (choise == ", "1", ")\n    {   \n        cout << ", "\"first number r1:\"", "<<endl;\n        cin >> r1;\n        cout << ", "\"last number r2:\"", "<<endl;\n        cin >> r2;\n        r3=r1+r2;\n        cout<<r3<<endl; \n    }\n    ", "else", " ", "if", " (choise == ", "2", ")\n    {   cout << ", "\"first number r1:\"", "<<endl;\n        cin >> r1;\n        cout << ", "\"last number r2:\"", "<<endl;\n        cin >> r2;\n        r3=r1-r2;\n        cout<<r3<<endl;\n    }\n    ", "else", " ", "if", " (choise == ", "3", ")\n    {   cout << ", "\"first number r1:\"", "<<endl;\n        cin >> r1;\n        cout << ", "\"last number r2:\"", "<<endl;\n        cin >> r2;\n        r3=r1*r2;\n        cout<<r3<<endl;\n    }\n    ", "else", " ", "if", " (choise == ", "4", ")\n    {   cout << ", "\"first number r1:\"", "<<endl;\n        cin >> r1;\n        cout << ", "\"last number r2:\"", "<<endl;\n        cin >> r2;\n        r3=r1/r2;\n        cout<<r3<<endl; \n    }\n    ", "else", " ", "if", "(choise == ", "5", "){\n        ", "Test", "();\n    }\n    ", "else", " ", "if", " (choise == ", "0", ") ", "//用户选0则结束调用函数", "\n    {\n            cout << ", "\"\\n\\n\\t欢迎下次继续使用计算器!\\n\"", ";\n            ", "break", ";\n     }\n    ", "else", "\n    {\n            cout << ", "\"\\n\\t输入错误，请按任意键继续!\\n\"", ";\n    }", "system", "(", "\"pause\"", ");\n}", "while", "(", "1", ");\n}\n\n", "\n", "运行完计算是错误的 哪里错了捏"]], "Tag": "程序设计"}
{"Answer": "//问题有点多，看看。 fstream    istream不能通用。    cin是istream.\r\n```\r\n#include &lt;iostream&gt;\r\n#include &lt;fstream&gt;\r\nusing namespace std;\r\nstruct student\r\n{\r\n    int no;\r\n    string name;\r\n};\r\nistream &amp;operator&gt;&gt;(istream &amp;in, student &amp;st)\r\n{\r\n    in &gt;&gt; st.no &gt;&gt; st.name;\r\n    return in;\r\n}\r\nostream &amp;operator&lt;&lt;(ostream &amp;out, student &amp;st)\r\n{\r\n    out &lt;&lt; st.no &lt;&lt; \" \" &lt;&lt; st.name &lt;&lt; endl;\r\n    return out;\r\n}\r\n\r\nclass studentarray\r\n{\r\nprivate:\r\n    student *p;\r\n    ifstream infile;\r\n    int count = 0;\r\n    student st;\r\n    int max_num = 3;\r\n\r\npublic:\r\n    studentarray() {}\r\n    friend istream &amp;operator&gt;&gt;(istream &amp;in, student &amp;st);\r\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;out, student &amp;st);\r\n    studentarray(ifstream &amp;in)\r\n    {\r\n        p = new student[max_num];\r\n        in &gt;&gt; st;\r\n        while (!in.eof())\r\n        {\r\n            p[count] = st;\r\n            count++;\r\n            in &gt;&gt; st;\r\n            if (count == max_num)\r\n            {\r\n                max_num = 2;\r\n                student *q = new student[max_num];\r\n                for (int i = 0; i &lt; count; i++)\r\n                    q[i] = p[i];\r\n                delete[] p;\r\n                p = q;\r\n            }\r\n        }\r\n    }\r\n    ~studentarray()\r\n    {\r\n        ofstream outfile(\"d:\\\\student.bat\");\r\n        int i = 0;\r\n        while (i &lt; count)\r\n        {\r\n            i++;\r\n            outfile &lt;&lt; p[i];\r\n        }\r\n        outfile.close();\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    student st;\r\n    ifstream infile(\"d:\\\\student.bat\");\r\n    if (infile.fail())\r\n    {\r\n        cout &lt;&lt; \"请输入学生的学号与姓名，并用EOF结束输入\" &lt;&lt; endl;\r\n        ofstream outfile(\"d:\\\\student.bat\");\r\n        while ((cin &gt;&gt; st))\r\n        {\r\n            outfile &lt;&lt; st;\r\n            cin &gt;&gt; st;\r\n        }\r\n        cout &lt;&lt; \"您的数据已成功写入d:\\\\student.dat，请重新打开本程序\" &lt;&lt; endl;\r\n        outfile.close();\r\n        infile.close();\r\n    }\r\n    else\r\n    {\r\n        studentarray array1(infile);\r\n        cout &lt;&lt; \"已成功读取数据文件！\" &lt;&lt; endl;\r\n    }\r\n}\r\n```", "Konwledge_Point": "运算符重载", "Question": ["一点关于c++输入输出与重载的问题", ["#include ", "\n#include ", "\n#include ", "\nusing namespace std;", "\nstruct student", "\n{", "\n    int no;", "\n    string name;", "\n};", "\nclass studentarray", "\n{", "\nprivate:", "\n    student* p;", "\n    ifstream infile;", "\n    int count = 0;", "\n    student st;", "\n    int max_num = 3;", "\npublic:", "\n    studentarray(){}", "\n    friend istream& operator >>(istream& in, student& st);", "\n    friend ostream& operator <<(ostream& out, student& st);", "\n    studentarray(ifstream& in)", "\n    {", "\n        p = new student[max_num];", "\n        in >> st;", "\n        while (!in.eof())", "\n        {", "\n            p[count] = st;", "\n            count++;", "\n            in >> st;", "\n            if (count == max_num)", "\n            {", "\n                max_num ", "= 2;", "\n                student", " q = new student[max_num];", "\n                for (int i = 0; i < count; i++) q[i] = p[i];", "\n                delete[]p;", "\n                p = q;", "\n            }", "\n        }", "\n    }", "\n    ~studentarray()", "\n    {", "\n        ofstream outfile(\"d:\\student.bat\");", "\n        int i = 0;", "\n        while (i < count)", "\n        {", "\n            i++;", "\n            outfile << p[i];", "\n        }", "\n        outfile.close();", "\n    }", "\n\n", "};", "\nistream& operator >>(ifstream& in, student& st)", "\n{", "\n    in >> st.no >> st.name;", "\n    return in;", "\n}", "\nostream& operator <<(ostream& out, student& st)", "\n{", "\n    out << st.no << \"  \" << st.name << endl;", "\n    return out;", "\n}", "\nint main()", "\n{", "\n    student st;", "\n    ifstream infile(\"d:\\student.bat\");", "\n    if (infile.fail())", "\n    {", "\n        cout << \"请输入学生的学号与姓名，并用EOF结束输入\" << endl;", "\n        ofstream outfile(\"d:\\student.bat\");", "\n        while ((cin >> st) != EOF)", "\n        {", "\n            outfile << st;", "\n            cin >> st;", "\n        }", "\n        cout << \"您的数据已成功写入d:\\student.dat，请重新打开本程序\" << endl;", "\n        outfile.close();", "\n        infile.close();", "\n    }", "\n    else", "\n    {", "\n        studentarray array1(infile);", "\n        cout << \"已成功读取数据文件！\" << endl;", "\n    }", "\n}", "\n\n", "代码如上", "\n        编译器提示： 二进制\">>\"没有找到接受“student”类型的右操作数的运算符(或没有可接受的转换)", "\n                                    二进制“<<”: 没有找到接受“student”类型的右操作数的运算符(或没有可接受的转换)", "\n            诸如此类的提示有七八个，请问我的代码哪里有问题？", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;模板类和模板函数的定义必须放到头文件里&amp;#xff0c;不能放到cpp文件里&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["用的vscode编译器，电脑是Mac m1芯片，linux也试着编译过，但为什么显示没有关联啊，最后的运行结果，我是通过g++ main.cpp fuc.cpp编译的", ["问题遇到的现象和发生背景", "\n", "问题相关代码，请勿粘贴截图", "\n", "----------------------------------------------------array.h文件\n", "#", "ifndef", " ARRAY_H", "\n", "#", "define", " ARRAY_H", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "template", " <", "class", " ", "T", ">\n", "class", " ", "LinerList", "\n{\n", "private", ":\n    ", "int", " length; ", "//元素个数", "\n    T *element;\n    ", "int", " maxSize; ", "//数组的最大元素", "\n", "public", ":\n    ", "LinerList", "(", "int", " llmaxSize);\n    ~", "LinerList", "();\n    ", "LinerList<T> &", "Insert", "(", "int", " k, ", "const", " T &x)", ";\n    ", "friend", " ostream &", "operator", "<<(ostream &out, LinerList<T> &s);\n};\n", "#", "endif", "\n--------------------------------------------------------------fuc.cpp文件\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "\"array.h\"", "\n\n", "using", " ", "namespace", " std;\n\n", "//实现构造函数", "\n", "template", " <", "class", " ", "T", ">\nLinerList<T>::", "LinerList", "(", "int", " llmaxSize)\n{\n    maxSize = llmaxSize;\n    element = ", "new", " T[llmaxSize];\n    length = ", "0", ";\n}\n\n", "//实现析构函数", "\n", "template", " <", "class", " ", "T", ">\nLinerList<T>::~", "LinerList", "()\n{\n    ", "delete", "[] element;\n}\n\n", "//在第k个位置插入元素x", "\n", "template", " <", "class", " ", "T", ">\nLinerList<T>& LinerList<T>::", "Insert", "(", "int", " k, ", "const", " T &x)\n{\n    ", "if", " (k < ", "1", " || k > length + ", "1", ")\n        cout << ", "\"所插入的元素越界了\"", " << endl;\n    ", "else", "\n    {\n        ", "if", " (length == maxSize)\n            cout << ", "\"此表已满,无法插入新的元素\"", " << endl;\n        ", "else", "\n        {\n            ", "for", " (", "int", " i = k - ", "1", "; i < maxSize; i++)\n                element[i + ", "1", "] = element[i];\n            element[k - ", "1", "] = x;\n            length++;\n        }\n    }\n    ", "return", " *", "this", ";\n}\n\n", "//运算符重载", "\n", "template", " <", "class", " ", "T", ">\nostream &", "operator", "<<(ostream &out, LinerList<T> &s)\n{\n    ", "for", " (", "int", " i = ", "0", "; i < s.length; i++)\n        out << s.element[i] << ", "\" \"", " << endl;\n    ", "return", " out;\n}\n--------------------------------------------------------------------main.cpp文件\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "\"array.h\"", "\n\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", "\n", "{\n    ", "LinerList<", "int", "> ", "s1", "(", "10", ")", ";\n    s1.", "Insert", "(", "1", ", ", "10", ");\n    ", "// s1.Insert(2, 20);", "\n    ", "// s1.Insert(3, 30);", "\n\n    cout << s1;\n\n    ", "return", " ", "0", ";\n}\n", "\n", "运行结果及报错内容", "\n", "Undefined symbols for architecture arm64:", "  \"LinerList", "::Insert(int, int const&)\", referenced from:", "      _main in main-0d85b3.o", "  \"LinerList", "::LinerList(int)\", referenced from:", "      _main in main-0d85b3.o", "  \"LinerList", "::~LinerList()\", referenced from:", "      _main in main-0d85b3.o", "  \"operator<<(std::__1::basic_ostream<char, std::__1::char_traits", " >&, LinerList&)\", referenced from:", "      _main in main-0d85b3.o", "ld: symbol(s) not found for architecture arm64", "clang: error: linker command failed with exit code 1 (use -v to see invocation)", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "在此感谢各位同僚的耐心解答，无奈同僚们回答的我都试过了，奖励金币不重要，学习到知识才是最重要的，因此，我自己苦心钻研，终于发现问题所在strlen（）的参数不能是\r\nNULL，因此致错", "Konwledge_Point": "运算符重载", "Question": ["关于等号重载中构造函数中形参默认函数的问题，其中不懂为什么", ["#define  _CRT_SECURE_NO_WARNINGS ", "\n#include", "\n\n", "using namespace std;", "\n\n", "//等号运算符的重载", "\nclass Array", "\n{", "\npublic:", "\n    //int strlen(char *)", "\n    Array(char *t1=0)", "\n    {", "\n        this->length=strlen(t1);", "\n        this->p = new char [length +1];", "\n        strcpy(p,t1);", "\n    }", "\n    Array(const Array &t2)", "\n    {", "\n        this->length=t2.length;", "\n        this->p = new char [length +1];", "\n        strcpy(p,t2.p);", "\n    }", "\n\n", "Array& operator=(Array &obj1)\n{\n    //先释放旧的内存\n    if (this->p != NULL)\n    {\n        delete[] p;\n        length = 0;\n    }\n    //2 根据obj1分配内存大小\n    this->length = obj1.length;\n    this->p = new char [length+1];\n\n    //把obj1赋值\n    strcpy(p, obj1.p);\n    return *this;\n}\n\n~Array()\n{\n    if(*p !=NULL)\n    {\n        delete [] p;\n        length=0;\n    }\n}\nvoid printf()\n{\n    cout<<this->p;\n}\n", "\n\n", "private:", "\n    int length;", "\n    char *p;", "\nprotected:", "\n};", "\n\n", "int main()", "\n{", "\n    Array a1(\"dasfsf\");", "\n    Array a2=a1;//调用赋值构造函数，必须重新定义，要不然是浅拷贝，出错", "\n    a2.printf();", "\n    cout<<endl;", "\n    Array a4(\"dasda\");", "\n    Array a3;", "\n    a3=a4;//浅拷贝，需重新定义等号。", "\n    a3.printf();", "\n    cout<<endl;", "\n\n", "system(\"pause\");\nreturn 0;\n", "\n\n", "}", "\n\n", "源码如上，其中编译正确，却运行不了，如果把类中的构造函数的形参的默认赋值等于零，则正确，但是不知道为什么呢？"]], "Tag": "程序设计"}
{"Answer": "楼主贴一下代码吧，这样很难分析", "Konwledge_Point": "运算符重载", "Question": ["C++重载运算符“<<”和“>>”出现错误", ["主函数中用<<>时", "\n出现错误", "\nno operator defined which takes a right-hand operand of type 'class vsctor' (or there is no acceptable conversion)", "\n\n", "#include", "\nusing namespace std;", "\nclass vsctor", "\n{", "\npublic:", "\n    vsctor(int z1=0,int z2=0,int z3=0);", "\n    void set(int z1,int z2,int z3);", "\n    void get(int& a,int& b,int& c) const;", "\n    //ostream& operator<<(ostream& os,const vsctor& v);", "\n    //istream& operator>>(istream& is,vsctor& v);", "\nprivate:", "\n    int a,b,c;", "\n};", "\nmain()", "\n{", "\n    int z1,z2,z3,x1,x2,x3,y1,y2,y3;", "\n    vsctor v1(1,1,1);", "\n    vsctor v2(2,2,2);", "\n    cout<\n    vsctor v;", "\n    cin>>v;", "\n    cout<\n}", "\nvsctor::vsctor(int z1,int z2,int z3):a(z1),b(z2),c(z3)", "\n{}", "\nvoid vsctor::set(int x1,int x2,int x3)", "\n{", "\n    a=x1;b=x2;c=x3;", "\n}", "\nvoid vsctor::get(int& z1,int& z2,int& z3) const", "\n{", "\n    z1=a;z2=b;z3=c;", "\n}", "\nostream& operator\n{", "\n    int z1,z2,z3;", "\n    v.get(", "\n        z1,z2,z3);", "\n    os\n    return os;", "\n}", "\nistream& operator>>(istream& is,vsctor& v)", "\n{", "\n    int z1,z2,z3;", "\n    is>>z1>>z2>>z3;", "\n    v.set(z1,z2,z3);", "\n    return is;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码给你修改了&amp;#xff0c;读文件的也在&amp;#xff0c;运行结果如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/706627170756137.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;fstream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;matrix&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r, c; &lt;span class=\"hljs-comment\"&gt;//r表示行&amp;#xff0c;c表示列&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;** mem;\n\n    &lt;span class=\"hljs-comment\"&gt;//这里添加2个无参构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;matrix&lt;/span&gt;() { r &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, mem &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; }\n    &lt;span class=\"hljs-built_in\"&gt;matrix&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* p)\n    {\n        r &amp;#61; a;\n        c &amp;#61; b;\n        mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* [a]; &lt;span class=\"hljs-comment\"&gt;//堆区开辟一段内存 程序结束后需要手动释放&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; a; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[b];\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; b; j&amp;#43;&amp;#43;)\n                mem[i][j] &amp;#61; p[i * b &amp;#43; j];\n        }\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;matrix&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b) :&lt;span class=\"hljs-built_in\"&gt;r&lt;/span&gt;(a), &lt;span class=\"hljs-built_in\"&gt;c&lt;/span&gt;(b)\n    {\n        mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* [a]; &lt;span class=\"hljs-comment\"&gt;//堆区开辟一段内存 程序结束后需要手动释放&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; a; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[b];\n        }\n    };\n    &lt;span class=\"hljs-built_in\"&gt;matrix&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; p) &lt;span class=\"hljs-comment\"&gt;//拷贝构造函数&lt;/span&gt;\n    {\n        r &amp;#61; p.r;\n        c &amp;#61; p.c;\n        mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* [r]; &lt;span class=\"hljs-comment\"&gt;//深拷贝&amp;#xff0c;在堆区重新开辟一段内存&amp;#xff0c;避免析构函数释放内存时重复释放同一块内存时而出错&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[c];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;) {\n                mem[i][j] &amp;#61; p.mem[i][j];\n            }\n    }\n    ~&lt;span class=\"hljs-built_in\"&gt;matrix&lt;/span&gt;() &lt;span class=\"hljs-comment\"&gt;//析构函数&amp;#xff0c;释放在堆区开辟的内存&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[]mem[i];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[]mem;\n    };\n\n    &lt;span class=\"hljs-comment\"&gt;//&amp;#43;运算符重载   也可以用全局函数来重载   matrix  operatior&amp;#43;&amp;#xff08;const matrix&amp;amp; m1,const matrix&amp;amp; m2)&lt;/span&gt;\n    matrix &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r !&amp;#61; m.r || c !&amp;#61; m.c)   &lt;span class=\"hljs-comment\"&gt;//判断是否为同型矩阵&lt;/span&gt;\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, c)&lt;/span&gt;&lt;/span&gt;;         &lt;span class=\"hljs-comment\"&gt;//调用构造函数&lt;/span&gt;\n            tmp.mem &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;           &lt;span class=\"hljs-comment\"&gt;//将该二维指针置空&amp;#xff0c;避免出现野指针的情况&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            matrix &lt;span class=\"hljs-built_in\"&gt;tmp&lt;/span&gt;(r, c);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    tmp.mem[i][j] &amp;#61; mem[i][j] &amp;#43; m.mem[i][j];\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n    matrix &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;- (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r !&amp;#61; m.r || c !&amp;#61; m.c)&lt;span class=\"hljs-comment\"&gt;//判断是否符合相减的条件&lt;/span&gt;\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, c)&lt;/span&gt;&lt;/span&gt;;\n            tmp.mem &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            matrix &lt;span class=\"hljs-built_in\"&gt;tmp&lt;/span&gt;(r, c);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    tmp.mem[i][j] &amp;#61; mem[i][j] - m.mem[i][j];\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n    matrix &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;* (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)&lt;span class=\"hljs-comment\"&gt;//矩阵乘&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c !&amp;#61; m.r) {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, c)&lt;/span&gt;&lt;/span&gt;;\n            tmp.mem &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            matrix &lt;span class=\"hljs-built_in\"&gt;tmp&lt;/span&gt;(r, m.c);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m.c; j&amp;#43;&amp;#43;)\n                    tmp.mem[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//初始化二维数组&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; tmp.r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; tmp.c; j&amp;#43;&amp;#43;)\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; c; k&amp;#43;&amp;#43;)\n                        tmp.mem[i][j] &amp;#43;&amp;#61; (mem[i][k] * m.mem[k][j]);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//求逆运算&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//matrix operator/(const matrix&amp;amp; m)&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;matrixinvers&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-comment\"&gt;//double ret &amp;#61; getA(m);&lt;/span&gt;\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r !&amp;#61; c &lt;span class=\"hljs-comment\"&gt;/* || ret &amp;#61;&amp;#61; 0*/&lt;/span&gt;)\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, c)&lt;/span&gt;&lt;/span&gt;;\n            tmp.mem &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* p &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[r * c];\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    p[k&amp;#43;&amp;#43;] &amp;#61; mem[i][j];\n            }\n            &lt;span class=\"hljs-built_in\"&gt;inverse&lt;/span&gt;(r, p);\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r,c,p)&lt;/span&gt;&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;det&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* aa)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; aa[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* bb &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)];&lt;span class=\"hljs-comment\"&gt;//创建n-1阶的代数余子式阵bb    &lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; mov &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//判断行是否移动   &lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; sum &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//sum为行列式的值  &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arow &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; arow &amp;lt; n; arow&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;// a的行数把矩阵a(nn)赋值到b(n-1)  &lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; brow &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; brow &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; brow&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//把aa阵第一列各元素的代数余子式存到bb  &lt;/span&gt;\n            {\n                mov &amp;#61; arow &amp;gt; brow ? &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; : &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//bb中小于arow的行&amp;#xff0c;同行赋值&amp;#xff0c;等于的错过&amp;#xff0c;大于的加一  &lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j&amp;#43;&amp;#43;)  &lt;span class=\"hljs-comment\"&gt;//从aa的第二列赋值到第n列  &lt;/span&gt;\n                {\n                    bb[brow * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &amp;#43; j] &amp;#61; aa[(brow &amp;#43; mov) * n &amp;#43; j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                }\n            }\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag &amp;#61; (arow % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; : &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//因为列数为0&amp;#xff0c;所以行数是偶数时候&amp;#xff0c;代数余子式为1.  &lt;/span&gt;\n            sum &amp;#43;&amp;#61; flag * aa[arow * n] * &lt;span class=\"hljs-built_in\"&gt;det&lt;/span&gt;(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, bb);&lt;span class=\"hljs-comment\"&gt;//aa第一列各元素与其代数余子式积的和即为行列式&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] bb;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; sum;\n    }\n\n    \n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;inverse&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* aa)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; det_aa &amp;#61; &lt;span class=\"hljs-built_in\"&gt;det&lt;/span&gt;(n, aa);\n        &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;输入矩阵的行列式&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; det_aa &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (det_aa &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;行列式为0 &amp;#xff0c;不能计算逆矩阵。\\n&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        }\n\n\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* adjoint &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[n * n];\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* bb &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)];&lt;span class=\"hljs-comment\"&gt;//创建n-1阶的代数余子式阵bb   &lt;/span&gt;\n\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; pi, pj, q;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ai &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; ai &amp;lt; n; ai&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;// a的行数把矩阵a(nn)赋值到b(n-1)  &lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; aj &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; aj &amp;lt; n; aj&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; bi &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; bi &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; bi&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//把元素aa[ai][0]代数余子式存到bb[][]  &lt;/span&gt;\n                {\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; bj &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; bj &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; bj&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//把元素aa[ai][0]代数余子式存到bb[][]  &lt;/span&gt;\n                    {\n                        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ai &amp;gt; bi)    &lt;span class=\"hljs-comment\"&gt;//ai行的代数余子式是&amp;#xff1a;小于ai的行&amp;#xff0c;aa与bb阵&amp;#xff0c;同行赋值  &lt;/span&gt;\n                            pi &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                            pi &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//大于等于ai的行&amp;#xff0c;取aa阵的ai&amp;#43;1行赋值给阵bb的bi行  &lt;/span&gt;\n                        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (aj &amp;gt; bj)    &lt;span class=\"hljs-comment\"&gt;//ai行的代数余子式是&amp;#xff1a;小于ai的行&amp;#xff0c;aa与bb阵&amp;#xff0c;同行赋值  &lt;/span&gt;\n                            pj &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                            pj &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//大于等于ai的行&amp;#xff0c;取aa阵的ai&amp;#43;1行赋值给阵bb的bi行  &lt;/span&gt;\n\n                        bb[bi * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &amp;#43; bj] &amp;#61; aa[(bi &amp;#43; pi) * n &amp;#43; bj &amp;#43; pj];\n                    }\n                }\n                &lt;span class=\"hljs-comment\"&gt;/*printf(&amp;#34;aa[%d][%d]的余子式\\n&amp;#34;, ai, aj);\n                for (int i &amp;#61; 0; i &amp;lt; n - 1; i&amp;#43;&amp;#43;)\n                {\n                    for (int j &amp;#61; 0; j &amp;lt; n - 1; j&amp;#43;&amp;#43;)\n                    {\n                        printf(&amp;#34;%lf     &amp;#34;, bb[i * (n - 1) &amp;#43; j]);\n                    }\n                    printf(&amp;#34; \\n&amp;#34;);\n                }*/&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((ai &amp;#43; aj) % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)  q &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//因为列数为0&amp;#xff0c;所以行数是偶数时候&amp;#xff0c;代数余子式为-1.  &lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;  q &amp;#61; (&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n                adjoint[ai * n &amp;#43; aj] &amp;#61; q * &lt;span class=\"hljs-built_in\"&gt;det&lt;/span&gt;(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, bb);\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//adjoint 转置&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; tem &amp;#61; adjoint[i * n &amp;#43; j];\n                adjoint[i * n &amp;#43; j] &amp;#61; adjoint[j * n &amp;#43; i];\n                adjoint[j * n &amp;#43; i] &amp;#61; tem;\n            }\n        }\n        &lt;span class=\"hljs-comment\"&gt;/*printf(&amp;#34;伴随阵&amp;#xff1a; \\n&amp;#34;);\n        for (int i &amp;#61; 0; i &amp;lt; n; i&amp;#43;&amp;#43;) //打印伴随阵\n        {\n            for (int j &amp;#61; 0; j &amp;lt; n; j&amp;#43;&amp;#43;)\n            {\n                cout &amp;lt;&amp;lt; adjoint[i * n &amp;#43; j] &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34;;\n            }\n            cout &amp;lt;&amp;lt; endl;\n        }\n        printf(&amp;#34;逆矩阵&amp;#xff1a; \\n&amp;#34;);*/&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//打印逆矩阵&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n            {\n                aa[i * n &amp;#43; j] &amp;#61; adjoint[i * n &amp;#43; j] / det_aa;\n                &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; aa[i * n &amp;#43; j] &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34;;&lt;/span&gt;\n            }\n            &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] adjoint;\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] bb;\n    }\n\n\n\n    &lt;span class=\"hljs-comment\"&gt;//按第一行展开计算|A|&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getA&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)&lt;/span&gt;\n    &lt;/span&gt;{\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (m.r &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;amp;&amp;amp; m.c &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; mem[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        }\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; ans &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(m.r, m.c)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; m.r; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m.c; j&amp;#43;&amp;#43;)\n                tmp.mem[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//初始化二维数组&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j, k;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; m.r; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m.r - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; m.r - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; k&amp;#43;&amp;#43;)\n                {\n                    tmp.mem[j][k] &amp;#61; mem[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;][(k &amp;gt;&amp;#61; i) ? k &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; : k];\n\n                }\n            }\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; t &amp;#61; &lt;span class=\"hljs-built_in\"&gt;getA&lt;/span&gt;(tmp);\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                ans &amp;#43;&amp;#61; tmp.mem[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][i] * t;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                ans -&amp;#61; tmp.mem[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][i] * t;\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ans;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//计算每一行每一列的每个元素所对应的余子式&amp;#xff0c;组成A*&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;matrix  &lt;span class=\"hljs-title\"&gt;getAStart&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (m.r &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;amp;&amp;amp; m.c &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, c)&lt;/span&gt;&lt;/span&gt;;\n            tmp.mem[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, m.c)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m.c; j&amp;#43;&amp;#43;)\n                tmp.mem[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//初始化二维数组&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, j, k, t;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; m.r; i&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m.r; j&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; m.r; k&amp;#43;&amp;#43;)\n                {\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (t &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; t &amp;lt; m.r; t&amp;#43;&amp;#43;)\n                    {\n                        tmp.mem[k][t] &amp;#61; mem[k &amp;gt;&amp;#61; i ? k &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; : k][t &amp;gt;&amp;#61; j ? t &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; : t];\n                    }\n                }\n                tmp.mem[j][i] &amp;#61; &lt;span class=\"hljs-built_in\"&gt;getA&lt;/span&gt;(tmp);\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((i &amp;#43; j) % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                {\n                    mem[j][i] &amp;#61; -mem[j][i];\n                }\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n        }\n    }\n    matrix&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c !&amp;#61; m.r) {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;matrix &lt;span class=\"hljs-title\"&gt;tmp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r, c)&lt;/span&gt;&lt;/span&gt;;\n            tmp.mem &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    mem[i][j] &amp;#61; m.mem[i][j];\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n        }\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//输出矩阵&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;) {\n                cout &amp;lt;&amp;lt; mem[i][j] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n            }\n            cout &amp;lt;&amp;lt; endl;\n        }\n        cout &amp;lt;&amp;lt; endl;\n    }\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;matrixRead&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(matrix&amp;amp; m1, matrix&amp;amp; m2)&lt;/span&gt;\n&lt;/span&gt;{\n    ofstream ofs;\n    ofs.&lt;span class=\"hljs-built_in\"&gt;open&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;matrix1.txt&amp;#34;&lt;/span&gt;, ios::out);\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs.&lt;span class=\"hljs-built_in\"&gt;close&lt;/span&gt;();\n\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;** mem1, ** mem2;\n    ifstream is;\n    is.&lt;span class=\"hljs-built_in\"&gt;open&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;matrix1.txt&amp;#34;&lt;/span&gt;, ios::in);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!is.&lt;span class=\"hljs-built_in\"&gt;is_open&lt;/span&gt;())\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;文件打开失败&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//读取文件的行和列&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r, c;\n    is &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;\n    mem1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* [r];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        mem1[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[c];\n    &lt;span class=\"hljs-comment\"&gt;//开始读取&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n        {\n            is &amp;gt;&amp;gt; mem1[i][j];\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//给m1赋值&lt;/span&gt;\n    m1.r &amp;#61; r;\n    m1.c &amp;#61; c;\n    m1.mem &amp;#61; mem1;\n\n\n\n    is &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;\n    mem2 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* [r];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        mem2[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[c];\n    &lt;span class=\"hljs-comment\"&gt;//开始读取&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n        {\n            is &amp;gt;&amp;gt; mem2[i][j];\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//给m2赋值&lt;/span&gt;\n    m2.r &amp;#61; r;\n    m2.c &amp;#61; c;\n    m2.mem &amp;#61; mem2;\n\n    is.&lt;span class=\"hljs-built_in\"&gt;close&lt;/span&gt;();\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; oper;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; oper;\n    matrix mem1, mem2;\n    &lt;span class=\"hljs-built_in\"&gt;matrixRead&lt;/span&gt;(mem1, mem2);\n    matrix p3 &amp;#61; mem1 &amp;#43; mem2;\n    p3.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n\n    matrix m3 &amp;#61; mem1.&lt;span class=\"hljs-built_in\"&gt;matrixinvers&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;mem1的逆矩阵&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    m3.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["如和编写c++求逆矩阵", ["问题遇到的现象和发生背景", "\n", "如何编写一个类来求逆矩阵", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include ", "#include ", "#include //vector函数所包含的库", "#include //调用reverse函数所包含的库", "#include", "using namespace std;", "#include ", "using namespace std;", "class matrix {", "public:", "    int r, c;  //r表示行，c表示列", "    int** mem;", "    matrix(int a, int b):r(a),c(b)", "    {", "        mem = new int* [a];            //堆区开辟一段内存  程序结束后需要手动释放", "        for (int i = 0; i < a; i++)", "        {", "            mem[i] = new int[b];", "        }", "    };", "    matrix(const matrix& p)       //拷贝构造函数", "    {", "        r = p.r;", "        c = p.c;", "        mem = new int* [r];     //深拷贝，在堆区重新开辟一段内存，避免析构函数释放内存时重复释放同一块内存时而出错", "        for (int i = 0; i < r; i++)", "        {", "            mem[i] = new int[c];", "        }", "        for (int i = 0; i < r; i++)", "            for (int j = 0; j < c; j++) {", "                mem[i][j] = p.mem[i][j];", "            }", "    }", "    ~matrix() //析构函数，释放在堆区开辟的内存", "    {", "        for (int i = 0; i < r; i++) {", "            delete[]mem[i];", "        }", "        delete[]mem;", "    };", "\n", "//+运算符重载   也可以用全局函数来重载   matrix  operatior+（const matrix& m1,const matrix& m2)", "\nmatrix operator+ (const matrix& m)     \n{\n    ", "if", " (r != m.r || c != m.c)   ", "//判断是否为同型矩阵", "\n    {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";         ", "//调用构造函数", "\n        tmp.mem = NULL;           ", "//将该二维指针置空，避免出现野指针的情况", "\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        matrix ", "tmp", "(r, c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < c; j++)\n                tmp.mem[i][j] = mem[i][j] + m.mem[i][j];\n        ", "return", " tmp;\n    }\n}\nmatrix operator- (const matrix& m) \n{\n    ", "if", " (r != m.r || c != m.c)", "//判断是否符合相减的条件", "\n    {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        matrix ", "tmp", "(r, c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < c; j++)\n                tmp.mem[i][j] = mem[i][j] - m.mem[i][j];\n        ", "return", " tmp;\n    }\n}\nmatrix operator* (const matrix& m)", "//矩阵乘", "\n{\n    ", "if", " (c != m.r) {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        matrix ", "tmp", "(r, m.c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n                tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < tmp.r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < tmp.c; j++)\n                ", "for", " (", "int", " ", "k", " ", "=", " ", "0", "; k < c; k++)\n                    tmp.mem[i][j] += (mem[i][k] * m.mem[k][j]);\n        ", "return", " tmp;\n    }\n}\n\n", "//求逆运算", "\nmatrix operator/(const matrix& m)\n{\n    ", "double", " ", "ret", " ", "=", " getA(m);\n\n    ", "if", " (m.r != m.c||ret==", "0", ")\n    {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", "\n    {\n        matrix ", "tmp", "(m.r, m.c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n                tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < tmp.r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < tmp.c; j++)\n                    tmp.mem[i][j] =\n        ", "return", " tmp;\n        \n    }\n}\n\n\n", "//按第一行展开计算|A|", "\n", "double", " ", "getA", "(const matrix&m)", "\n{\n\n    ", "if", " (m.r == ", "1", "&&m.c==", "1", ")\n    {\n        ", "return", " mem[", "0", "][", "0", "];\n    }\n    ", "double", " ", "ans", " ", "=", " ", "0", ";\n    matrix ", "tmp", "(r, m.c)", ";\n    ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n        ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n            tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n    ", "int", " i, j, k;\n    ", "for", " (i = ", "0", "; i < m.r; i++)\n    {\n        ", "for", " (j = ", "0", "; j < m.r - ", "1", "; j++)\n        {\n            ", "for", " (k = ", "0", "; k < m.r - ", "1", "; k++)\n            {\n                tmp.mem[j][k] = mem[j + ", "1", "][(k >= i) ? k + ", "1", " : k];\n\n            }\n        }\n        ", "double", " ", "t", " ", "=", " getA(tmp);\n        ", "if", " (i % ", "2", " == ", "0", ")\n        {\n            ans += tmp.mem[", "0", "][i] * t;\n        }\n        ", "else", "\n        {\n            ans -= tmp.mem[", "0", "][i] * t;\n        }\n    }\n    ", "return", " ans;\n}\n\n", "//计算每一行每一列的每个元素所对应的余子式，组成A*", "\nmatrix  ", "getAStart", "(const matrix& m)", "\n{\n    ", "if", " (m.r == ", "1", "&&m.c==", "1", ")\n    {\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem[", "0", "][", "0", "] = ", "1", ";\n        ", "return", " tmp;\n    }\n    matrix ", "tmp", "(r, m.c)", ";\n    ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n        ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n            tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n    ", "int", " i, j, k, t;\n    ", "for", " (i = ", "0", "; i < m.r; i++)\n    {\n        ", "for", " (j = ", "0", "; j < m.r; j++)\n        {\n            ", "for", " (k = ", "0", "; k < m.r; k++)\n            {\n                ", "for", " (t = ", "0", "; t < m.r; t++)\n                {\n                    tmp.mem[k][t] = mem[k >= i ? k + ", "1", " : k][t >= j ? t + ", "1", " : t];\n                }\n            }\n            tmp.mem[j][i] = getA(tmp);\n            ", "if", " ((i + j) % ", "2", " == ", "1", ")\n            {\n                mem[j][i] = -mem[j][i];\n            }\n        }\n        ", "return", " *", "this", ";\n    }\n}\nmatrix& operator=(const matrix& m)\n{\n    ", "if", " (c != m.r) {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < c; j++)\n                mem[i][j] = m.mem[i][j];\n        ", "return", " *", "this", ";\n    }\n}\n ", "void", " ", "display", "(matrix m)", "//输出矩阵", "\n{\n    ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < m.r; i++) {\n        ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++) {\n            cout << m.mem[i][j] << ", "' '", ";\n        }\n        cout << endl;\n    }\n    cout << ", "\"====================================================================================\"", " << endl;\n}\n", "\n", "};", "\n", "运行结果及报错内容", "\n", "不知道如何求逆矩阵", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;Time&lt;/code&gt;类的&lt;code class=\"language-javascript\"&gt;*&lt;/code&gt;运算符重载函数没加&lt;code class=\"language-javascript\"&gt;const&lt;/code&gt;修饰&amp;#xff0c;声明和定义改为下面形式&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;Time operator *(int n) const;&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["想实现重载运算符的操作数的反转，为什么134行这里报错了", ["\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;matrixRead函数中&amp;#xff0c;没有给m1和m2赋值。&lt;br /&gt;另外&amp;#xff0c;你的matrix类中&amp;#xff0c;没有无参构造函数&amp;#xff0c;如果你在main函数中&amp;#xff0c;直接把矩阵的行数和列数写死了&amp;#xff0c;会导致内存泄漏。需要添加一个无参构造函数。&lt;br /&gt;修改后运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/504524551756166.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;fstream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;matrix&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; r, c; &lt;span class=\"hljs-comment\"&gt;//r表示行&amp;#xff0c;c表示列&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;** mem;\n\n    &lt;span class=\"hljs-comment\"&gt;//这里添加2个无参构造函数&lt;/span&gt;\n    matrix() { r &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, c &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, mem &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; }\n    matrix(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* p)\n    {\n        r &amp;#61; a;\n        c &amp;#61; b;\n        mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* [a]; &lt;span class=\"hljs-comment\"&gt;//堆区开辟一段内存 程序结束后需要手动释放&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; a; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[b];\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; b; j&amp;#43;&amp;#43;)\n                mem[i][j] &amp;#61; p[i * b &amp;#43; j];\n        }\n    }\n\n    matrix(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b) :r(a), c(b)\n    {\n        mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* [a]; &lt;span class=\"hljs-comment\"&gt;//堆区开辟一段内存 程序结束后需要手动释放&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; a; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[b];\n        }\n    };\n    matrix(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; p) &lt;span class=\"hljs-comment\"&gt;//拷贝构造函数&lt;/span&gt;\n    {\n        r &amp;#61; p.r;\n        c &amp;#61; p.c;\n        mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* [r]; &lt;span class=\"hljs-comment\"&gt;//深拷贝&amp;#xff0c;在堆区重新开辟一段内存&amp;#xff0c;避免析构函数释放内存时重复释放同一块内存时而出错&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[c];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;) {\n                mem[i][j] &amp;#61; p.mem[i][j];\n            }\n    }\n    ~matrix() &lt;span class=\"hljs-comment\"&gt;//析构函数&amp;#xff0c;释放在堆区开辟的内存&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;) {\n            delete[]mem[i];\n        }\n        delete[]mem;\n    };\n\n    &lt;span class=\"hljs-comment\"&gt;//&amp;#43;运算符重载   也可以用全局函数来重载   matrix  operatior&amp;#43;&amp;#xff08;const matrix&amp;amp; m1,const matrix&amp;amp; m2)&lt;/span&gt;\n    matrix operator&amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r !&amp;#61; m.r || c !&amp;#61; m.c)   &lt;span class=\"hljs-comment\"&gt;//判断是否为同型矩阵&lt;/span&gt;\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            matrix tmp(r, c);         &lt;span class=\"hljs-comment\"&gt;//调用构造函数&lt;/span&gt;\n            tmp.mem &amp;#61; NULL;           &lt;span class=\"hljs-comment\"&gt;//将该二维指针置空&amp;#xff0c;避免出现野指针的情况&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            matrix tmp(r, c);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    tmp.mem[i][j] &amp;#61; mem[i][j] &amp;#43; m.mem[i][j];\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n    matrix operator- (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r !&amp;#61; m.r || c !&amp;#61; m.c)&lt;span class=\"hljs-comment\"&gt;//判断是否符合相减的条件&lt;/span&gt;\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            matrix tmp(r, c);\n            tmp.mem &amp;#61; NULL;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            matrix tmp(r, c);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    tmp.mem[i][j] &amp;#61; mem[i][j] - m.mem[i][j];\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n    matrix operator* (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)&lt;span class=\"hljs-comment\"&gt;//矩阵乘&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c !&amp;#61; m.r) {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            matrix tmp(r, c);\n            tmp.mem &amp;#61; NULL;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            matrix tmp(r, m.c);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m.c; j&amp;#43;&amp;#43;)\n                    tmp.mem[i][j] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//初始化二维数组&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; tmp.r; i&amp;#43;&amp;#43;)\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; tmp.c; j&amp;#43;&amp;#43;)\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; c; k&amp;#43;&amp;#43;)\n                        tmp.mem[i][j] &amp;#43;&amp;#61; (mem[i][k] * m.mem[k][j]);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n\n   \n\n\n    &lt;span class=\"hljs-comment\"&gt;//求逆运算&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//matrix operator/(const matrix&amp;amp; m)&lt;/span&gt;\n    matrix matrixinvers()\n    {\n        &lt;span class=\"hljs-comment\"&gt;//double ret &amp;#61; getA(m);&lt;/span&gt;\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (r !&amp;#61; c &lt;span class=\"hljs-comment\"&gt;/* || ret &amp;#61;&amp;#61; 0*/&lt;/span&gt;)\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的类型的矩阵。&amp;#34;&lt;/span&gt;;\n            matrix tmp(r, c);\n            tmp.mem &amp;#61; NULL;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* p &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[r * c];\n            &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n                    p[k&amp;#43;&amp;#43;] &amp;#61; mem[i][j];\n            }\n            inverse(r, p);\n            matrix tmp(r, c, p);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n        }\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; det(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; n, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* aa)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; aa[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* bb &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)];&lt;span class=\"hljs-comment\"&gt;//创建n-1阶的代数余子式阵bb    &lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; mov &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//判断行是否移动   &lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;sum&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//sum为行列式的值  &lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; arow &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; arow &amp;lt; n; arow&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;// a的行数把矩阵a(nn)赋值到b(n-1)  &lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; brow &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; brow &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; brow&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//把aa阵第一列各元素的代数余子式存到bb  &lt;/span&gt;\n            {\n                mov &amp;#61; arow &amp;gt; brow ? &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; : &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//bb中小于arow的行&amp;#xff0c;同行赋值&amp;#xff0c;等于的错过&amp;#xff0c;大于的加一  &lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j&amp;#43;&amp;#43;)  &lt;span class=\"hljs-comment\"&gt;//从aa的第二列赋值到第n列  &lt;/span&gt;\n                {\n                    bb[brow * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &amp;#43; j] &amp;#61; aa[(brow &amp;#43; mov) * n &amp;#43; j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                }\n            }\n            &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; flag &amp;#61; (arow % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; : &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//因为列数为0&amp;#xff0c;所以行数是偶数时候&amp;#xff0c;代数余子式为1.  &lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;sum&lt;/span&gt; &amp;#43;&amp;#61; flag * aa[arow * n] * det(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, bb);&lt;span class=\"hljs-comment\"&gt;//aa第一列各元素与其代数余子式积的和即为行列式&lt;/span&gt;\n        }\n        delete[] bb;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;sum&lt;/span&gt;;\n    }\n\n\n\n    &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; inverse(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; n, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* aa)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; det_aa &amp;#61; det(n, aa);\n        &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; &amp;#34;输入矩阵的行列式&amp;#xff1a;&amp;#34; &amp;lt;&amp;lt; det_aa &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (det_aa &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;行列式为0 &amp;#xff0c;不能计算逆矩阵。&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n        }\n\n\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* adjoint &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[n * n];\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* bb &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)];&lt;span class=\"hljs-comment\"&gt;//创建n-1阶的代数余子式阵bb   &lt;/span&gt;\n\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; pi, pj, q;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; ai &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; ai &amp;lt; n; ai&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;// a的行数把矩阵a(nn)赋值到b(n-1)  &lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; aj &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; aj &amp;lt; n; aj&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; bi &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; bi &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; bi&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//把元素aa[ai][0]代数余子式存到bb[][]  &lt;/span&gt;\n                {\n                    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; bj &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; bj &amp;lt; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; bj&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//把元素aa[ai][0]代数余子式存到bb[][]  &lt;/span&gt;\n                    {\n                        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (ai &amp;gt; bi)    &lt;span class=\"hljs-comment\"&gt;//ai行的代数余子式是&amp;#xff1a;小于ai的行&amp;#xff0c;aa与bb阵&amp;#xff0c;同行赋值  &lt;/span&gt;\n                            pi &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                            pi &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//大于等于ai的行&amp;#xff0c;取aa阵的ai&amp;#43;1行赋值给阵bb的bi行  &lt;/span&gt;\n                        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (aj &amp;gt; bj)    &lt;span class=\"hljs-comment\"&gt;//ai行的代数余子式是&amp;#xff1a;小于ai的行&amp;#xff0c;aa与bb阵&amp;#xff0c;同行赋值  &lt;/span&gt;\n                            pj &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                            pj &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//大于等于ai的行&amp;#xff0c;取aa阵的ai&amp;#43;1行赋值给阵bb的bi行  &lt;/span&gt;\n\n                        bb[bi * (n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &amp;#43; bj] &amp;#61; aa[(bi &amp;#43; pi) * n &amp;#43; bj &amp;#43; pj];\n                    }\n                }\n                &lt;span class=\"hljs-comment\"&gt;/*printf(&amp;#34;aa[%d][%d]的余子式\\n&amp;#34;, ai, aj);\n                for (int i &amp;#61; 0; i &amp;lt; n - 1; i&amp;#43;&amp;#43;)\n                {\n                    for (int j &amp;#61; 0; j &amp;lt; n - 1; j&amp;#43;&amp;#43;)\n                    {\n                        printf(&amp;#34;%lf     &amp;#34;, bb[i * (n - 1) &amp;#43; j]);\n                    }\n                    printf(&amp;#34; \\n&amp;#34;);\n                }*/&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((ai &amp;#43; aj) % &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)  q &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//因为列数为0&amp;#xff0c;所以行数是偶数时候&amp;#xff0c;代数余子式为-1.  &lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;  q &amp;#61; (&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;);\n                adjoint[ai * n &amp;#43; aj] &amp;#61; q * det(n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, bb);\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//adjoint 转置&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;)\n            {\n                &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; tem &amp;#61; adjoint[i * n &amp;#43; j];\n                adjoint[i * n &amp;#43; j] &amp;#61; adjoint[j * n &amp;#43; i];\n                adjoint[j * n &amp;#43; i] &amp;#61; tem;\n            }\n        }\n        &lt;span class=\"hljs-comment\"&gt;/*printf(&amp;#34;伴随阵&amp;#xff1a; \\n&amp;#34;);\n        for (int i &amp;#61; 0; i &amp;lt; n; i&amp;#43;&amp;#43;) //打印伴随阵\n        {\n            for (int j &amp;#61; 0; j &amp;lt; n; j&amp;#43;&amp;#43;)\n            {\n                cout &amp;lt;&amp;lt; adjoint[i * n &amp;#43; j] &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34;;\n            }\n            cout &amp;lt;&amp;lt; endl;\n        }\n        printf(&amp;#34;逆矩阵&amp;#xff1a; \\n&amp;#34;);*/&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//打印逆矩阵&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n            {\n                aa[i * n &amp;#43; j] &amp;#61; adjoint[i * n &amp;#43; j] / det_aa;\n                &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; aa[i * n &amp;#43; j] &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34;;&lt;/span&gt;\n            }\n            &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; endl;&lt;/span&gt;\n        }\n        delete[] adjoint;\n        delete[] bb;\n    }\n\n    matrix&amp;amp; operator&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; matrix&amp;amp; m)\n    {\n        \n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;mem !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n                delete[] &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;mem[i];\n            delete[] &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;mem;\n        }\n        r &amp;#61; m.r;\n        c &amp;#61; m.c;\n\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;mem &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* [r]; &lt;span class=\"hljs-comment\"&gt;//深拷贝&amp;#xff0c;在堆区重新开辟一段内存&amp;#xff0c;避免析构函数释放内存时重复释放同一块内存时而出错&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        {\n            mem[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[c];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;) {\n                mem[i][j] &amp;#61; m.mem[i][j];\n            }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;()&lt;span class=\"hljs-comment\"&gt;//输出矩阵&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;) {\n                cout &amp;lt;&amp;lt; mem[i][j] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n            }\n            cout &amp;lt;&amp;lt; endl;\n        }\n        cout &amp;lt;&amp;lt; endl;\n    }\n};\n\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; file()\n{\n    ofstream ofs;\n    ofs.open(&lt;span class=\"hljs-string\"&gt;&amp;#34;matrix1.txt&amp;#34;&lt;/span&gt;, ios::out);\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    ofs.close();\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; matrixRead(matrix&amp;amp; m1, matrix&amp;amp; m2)\n{\n    &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;** mem1, ** mem2;\n    ifstream &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;.open(&lt;span class=\"hljs-string\"&gt;&amp;#34;matrix1.txt&amp;#34;&lt;/span&gt;, ios::&lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;.is_open())\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;文件打开失败&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//读取文件的行和列&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; r, c;\n    &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;\n    mem1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* [r];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        mem1[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[c];\n    &lt;span class=\"hljs-comment\"&gt;//开始读取&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &amp;gt;&amp;gt; mem1[i][j];\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//给m1赋值&lt;/span&gt;\n    m1.r &amp;#61; r;\n    m1.c &amp;#61; c;\n    m1.mem &amp;#61; mem1;\n\n\n\n    &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &amp;gt;&amp;gt; r &amp;gt;&amp;gt; c;\n    mem2 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;* [r];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n        mem2[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;[c];\n    &lt;span class=\"hljs-comment\"&gt;//开始读取&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; r; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; c; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &amp;gt;&amp;gt; mem2[i][j];\n        }\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//给m2赋值&lt;/span&gt;\n    m2.r &amp;#61; r;\n    m2.c &amp;#61; c;\n    m2.mem &amp;#61; mem2;\n\n    &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;.close();\n}\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; test01()\n{\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; oper;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入符号&amp;#xff08;&amp;#43;&amp;#xff0c;-&amp;#xff0c;*&amp;#xff0c;/&amp;#xff09;&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; oper;\n    matrix mem1, mem2, result;\n    file();\n    matrixRead(mem1, mem2);\n    mem1.&lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;();\n    mem2.&lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;();\n\n    &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt; (oper)\n    {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#43;&amp;#39;&lt;/span&gt;:\n        result &amp;#61; mem1 &amp;#43; mem2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;:\n        result &amp;#61; mem1 - mem2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;*&amp;#39;&lt;/span&gt;:\n        result &amp;#61; mem1 * mem2;\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;:\n        result &amp;#61; mem1.matrixinvers();\n        &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    &lt;span class=\"hljs-literal\"&gt;default&lt;/span&gt;:\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入正确的运算符。&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    result.&lt;span class=\"hljs-keyword\"&gt;print&lt;/span&gt;();\n}\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main()\n{\n    test01();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["矩阵运算，如何才能正确的得到结果", ["问题遇到的现象和发生背景", "\n", "矩阵相加运行出来是错的", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include ", "#include ", "#include //vector函数所包含的库", "#include //调用reverse函数所包含的库", "#include", "using namespace std;", "#include ", "using namespace std;", "class matrix", "{", "public:", "    int r, c;  //r表示行，c表示列", "    double** mem;", "    matrix(int a, int b) :r(a), c(b)", "    {", "        mem = new double* [a];            //堆区开辟一段内存  程序结束后需要手动释放", "        for (int i = 0; i < a; i++)", "        {", "            mem[i] = new double[b];", "        }", "    };", "    matrix(const matrix& p)       //拷贝构造函数", "    {", "        r = p.r;", "        c = p.c;", "        mem = new double* [r];     //深拷贝，在堆区重新开辟一段内存，避免析构函数释放内存时重复释放同一块内存时而出错", "        for (int i = 0; i < r; i++)", "        {", "            mem[i] = new double[c];", "        }", "        for (int i = 0; i < r; i++)", "            for (int j = 0; j < c; j++) {", "                mem[i][j] = p.mem[i][j];", "            }", "    }", "    ~matrix() //析构函数，释放在堆区开辟的内存", "    {", "        for (int i = 0; i < r; i++) {", "            delete[]mem[i];", "        }", "        delete[]mem;", "    };", "\n", "//+运算符重载   也可以用全局函数来重载   matrix  operatior+（const matrix& m1,const matrix& m2)", "\nmatrix operator+ (const matrix& m)\n{\n    ", "if", " (r != m.r || c != m.c)   ", "//判断是否为同型矩阵", "\n    {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";         ", "//调用构造函数", "\n        tmp.mem = NULL;           ", "//将该二维指针置空，避免出现野指针的情况", "\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        matrix ", "tmp", "(r, c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < c; j++)\n                tmp.mem[i][j] = mem[i][j] + m.mem[i][j];\n        ", "return", " tmp;\n    }\n}\nmatrix operator- (const matrix& m)\n{\n    ", "if", " (r != m.r || c != m.c)", "//判断是否符合相减的条件", "\n    {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        matrix ", "tmp", "(r, c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < c; j++)\n                tmp.mem[i][j] = mem[i][j] - m.mem[i][j];\n        ", "return", " tmp;\n    }\n}\nmatrix operator* (const matrix& m)", "//矩阵乘", "\n{\n    ", "if", " (c != m.r) {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        matrix ", "tmp", "(r, m.c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n                tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < tmp.r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < tmp.c; j++)\n                ", "for", " (", "int", " ", "k", " ", "=", " ", "0", "; k < c; k++)\n                    tmp.mem[i][j] += (mem[i][k] * m.mem[k][j]);\n        ", "return", " tmp;\n    }\n}\n\n", "//求逆运算", "\nmatrix operator/(const matrix& m)\n{\n    ", "double", " ", "ret", " ", "=", " getA(m);\n    ", "/*matrix inverse(m.r, m.c);\n    for (int i = 0; i < r; i++)\n        for (int j = 0; j < m.c; j++)\n            inverse.mem[i][j] = 0;*/", "\n    ", "matrix", " ", "inverse", " ", "=", " getAStart(m);\n    ", "if", " (m.r != m.c || ret == ", "0", ")\n    {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", "\n    {\n        matrix ", "tmp", "(m.r, m.c)", ";\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n                tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < tmp.r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < tmp.c; j++)\n                tmp.mem[i][j] = inverse.mem[i][j] / ret;\n        ", "return", " tmp;\n\n    }\n}\n\n\n", "//按第一行展开计算|A|", "\n", "double", " ", "getA", "(const matrix& m)", "\n{\n\n    ", "if", " (m.r == ", "1", " && m.c == ", "1", ")\n    {\n        ", "return", " mem[", "0", "][", "0", "];\n    }\n    ", "double", " ", "ans", " ", "=", " ", "0", ";\n    matrix ", "tmp", "(r, m.c)", ";\n    ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n        ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n            tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n    ", "int", " i, j, k;\n    ", "for", " (i = ", "0", "; i < m.r; i++)\n    {\n        ", "for", " (j = ", "0", "; j < m.r - ", "1", "; j++)\n        {\n            ", "for", " (k = ", "0", "; k < m.r - ", "1", "; k++)\n            {\n                tmp.mem[j][k] = mem[j + ", "1", "][(k >= i) ? k + ", "1", " : k];\n\n            }\n        }\n        ", "double", " ", "t", " ", "=", " getA(tmp);\n        ", "if", " (i % ", "2", " == ", "0", ")\n        {\n            ans += tmp.mem[", "0", "][i] * t;\n        }\n        ", "else", "\n        {\n            ans -= tmp.mem[", "0", "][i] * t;\n        }\n    }\n    ", "return", " ans;\n}\n\n", "//计算每一行每一列的每个元素所对应的余子式，组成A*", "\nmatrix  ", "getAStart", "(const matrix& m)", "\n{\n    ", "if", " (m.r == ", "1", " && m.c == ", "1", ")\n    {\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem[", "0", "][", "0", "] = ", "1", ";\n        ", "return", " tmp;\n    }\n    matrix ", "tmp", "(r, m.c)", ";\n    ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n        ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++)\n            tmp.mem[i][j] = ", "0", ";", "//初始化二维数组", "\n    ", "int", " i, j, k, t;\n    ", "for", " (i = ", "0", "; i < m.r; i++)\n    {\n        ", "for", " (j = ", "0", "; j < m.r; j++)\n        {\n            ", "for", " (k = ", "0", "; k < m.r; k++)\n            {\n                ", "for", " (t = ", "0", "; t < m.r; t++)\n                {\n                    tmp.mem[k][t] = mem[k >= i ? k + ", "1", " : k][t >= j ? t + ", "1", " : t];\n                }\n            }\n            tmp.mem[j][i] = getA(tmp);\n            ", "if", " ((i + j) % ", "2", " == ", "1", ")\n            {\n                mem[j][i] = -mem[j][i];\n            }\n        }\n        ", "return", " *", "this", ";\n    }\n}\nmatrix& operator=(const matrix& m)\n{\n    ", "if", " (c != m.r) {\n        cout << ", "\"请输入正确的类型的矩阵。\"", ";\n        matrix ", "tmp", "(r, c)", ";\n        tmp.mem = NULL;\n        ", "return", " tmp;\n    }\n    ", "else", " {\n        ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < r; i++)\n            ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < c; j++)\n                mem[i][j] = m.mem[i][j];\n        ", "return", " *", "this", ";\n    }\n}\n", "void", " ", "print", "(const matrix& m)", "//输出矩阵", "\n{\n    ", "for", " (", "int", " ", "i", " ", "=", " ", "0", "; i < m.r; i++) {\n        ", "for", " (", "int", " ", "j", " ", "=", " ", "0", "; j < m.c; j++) {\n            cout << m.mem[i][j] << ", "' '", ";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n", "\n", "};", "\n", "void matrixRead(matrix& m1, matrix& m2)", "{", "    ofstream ofs;", "    ofs.open(\"matrix1.txt\", ios::out);", "    ofs << 3 << \" \" << 3 << endl;", "    ofs << 1 << \" \" << 2 << \" \" << 3 << endl;", "    ofs << 2 << \" \" << 4 << \" \" << 5 << endl;", "    ofs << 3 << \" \" << 5 << \" \" << 7 << endl;", "    ofs << 3 << \" \" << 3 << endl;", "    ofs << 2 << \" \" << 4 << \" \" << 6 << endl;", "    ofs << 3 << \" \" << 7 << \" \" << 9 << endl;", "    ofs << 1 << \" \" << 5 << \" \" << 7 << endl;", "    ofs.close();", "\n", "double", "** mem1, ** mem2;\nifstream ", "is", ";\n", "is", ".open(", "\"matrix1.txt\"", ", ios::", "in", ");\n", "if", " (!", "is", ".is_open())\n{\n    cout << ", "\"文件打开失败\"", " << endl;\n    ", "return", ";\n}\n", "//读取文件的行和列", "\n", "int", " r, c;\n", "is", " >> r >> c;\nmem1 = ", "new", " ", "double", "* [r];\n", "for", " (", "int", " i = ", "0", "; i < r; i++)\n    mem1[i] = ", "new", " ", "double", "[c];\n", "//开始读取", "\n", "for", " (", "int", " i = ", "0", "; i < r; i++)\n{\n    ", "for", " (", "int", " j = ", "0", "; j < c; j++)\n    {\n        ", "is", " >> mem1[i][j];\n    }\n}\n", "is", " >> r >> c;\nmem2 = ", "new", " ", "double", "* [r];\n", "for", " (", "int", " i = ", "0", "; i < r; i++)\n    mem2[i] = ", "new", " ", "double", "[c];\n", "//开始读取", "\n", "for", " (", "int", " i = ", "0", "; i < r; i++)\n{\n    ", "for", " (", "int", " j = ", "0", "; j < c; j++)\n    {\n        ", "is", " >> mem2[i][j];\n    }\n}\n", "is", ".close();\n", "\n", "}", "\n", "int main()", "{", "    char oper;", "    cout << \"请输入\" << endl;", "    cin >> oper;", "    matrix mem1(3, 3), mem2(3, 3);", "    matrixRead(mem1, mem2);", "    matrix p3 = mem1 + mem2;", "    p3.print(p3);", "\n", "return", " ", "0", ";\n", "\n", "}", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "能正确的运行矩阵运算，包括加减乘以及逆运算"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;z为两个对象z值zz&lt;br /&gt;&amp;#61;&amp;#61;这是啥意思&amp;#xff1f;&lt;br /&gt;另外相加后的值是否要修改当前类的x,y,z值&amp;#xff0c;还是只是作为返回的pic对象值&lt;br /&gt;参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;pic&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x,y;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; z;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;pic&lt;/span&gt;() {}\n    &lt;span class=\"hljs-built_in\"&gt;pic&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b,&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; c) : &lt;span class=\"hljs-built_in\"&gt;x&lt;/span&gt;(a),&lt;span class=\"hljs-built_in\"&gt;y&lt;/span&gt;(b),&lt;span class=\"hljs-built_in\"&gt;z&lt;/span&gt;(c) {}\n    pic &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; pic&amp;amp;pict);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printData&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;x&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;,y&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;,z&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;z&amp;lt;&amp;lt;endl;}\n};\n\npic pic::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; pic &amp;amp; pict)\n{\n    pic c;\n    c.x &amp;#61; x * pict.x;\n    c.y &amp;#61; (y&amp;#43;pict.y)/&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    c.z &amp;#61; z &amp;#43; pict.z;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;pic &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;pic &lt;span class=\"hljs-title\"&gt;B&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;40&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    pic c &amp;#61; A&amp;#43;B;\n    c.&lt;span class=\"hljs-built_in\"&gt;printData&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#c++#的问题：类pic有三个私有数据成员x(int),y(int),z(double),用此类描述两个对象A和B。程序中需要重载”+”完成运算符A+B", ["类pic有三个私有数据成员x(int),y(int),z(double),用此类描述两个对象A和B。程序中需要重载”+”完成运算符A+B。", "要求：", "（1）A+B相加后x为两个对象x值相乘，y为两个对象y值相加的1/2，z为两个对象z值zz。", "（2）重载”+”写成成员函数，在类里声明类外定义，声明如下", "pic pic::operator +(const pic &pict)；", "（3）定义带参数的构造函数，两个对象实参分别为(2,20,3),和(6,40,2)。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Time::Time(int h, int m, int s)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;//只留下最后一句&amp;#xff0c;把输入部分去掉&lt;br /&gt;}&lt;/p&gt;\n&lt;p&gt;tm1,tm2的三参数放到main()中传放&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C加加实现两个时间的相加，通过重载操作符“+”实现", ["问问怎么改 ，要求输入两个时间得出结果，可这个程序要输入三个时间，输出的前两个相加结果，怎么改啊，输入两个就可以了。", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;1、ostream为输出流&lt;br /&gt;2、&amp;amp;在这里为引用&lt;br /&gt;ostream&amp;amp; out为定义一个名字为out的引用型输出流对象&lt;/strong&gt;&lt;br /&gt;重载时会用到它&amp;#xff0c;具体作用就要看你函数是怎么实现的或者函数功能是什么了。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++重载中的cout重载ostream &out是什么意思", ["ostream & ", "operator", "<<(ostream &", "out", ") ", "const", "\n{\n    ", "if", "(str != NULL)\n    {\n          ", "out", " << str;\n    }\n    ", "return", " ", "out", ";\n}\n", "\n", "上面是重载输出流的重载函数，其中那个ostream &out这玩意什么意思，我们在正常重载等号这种运算符的时候，参数给的都是类名的引用，这里给了ostream &out输出流的引用，那么输出流也是个类嘛，或者说ostream &out到底什么意思"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://www.bilibili.com/video/BV1et411b73Z?p&amp;#61;121\"&gt;黑马程序员匠心之作|C&amp;#43;&amp;#43;教程从0到1入门编程,学习编程不再难_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;你可以在这个视频中看下&amp;#xff0c;这个链接直达运算符重载 &amp;#43;、-、左移、&amp;#43;&amp;#61;、&amp;#61;相关&lt;/p&gt;\n\n&lt;p&gt;相比较直接给代码来说&amp;#xff0c;视频讲的会清楚点&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于c++函数重载，求代码", ["编写一个类comp，实现运算符+，-， = ，+= 的重载，并在main 函数中进行测试"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;operator&amp;lt;&amp;lt;()&lt;/code&gt;第二个参数类型应改为&lt;code class=\"language-javascript\"&gt;const MyTeger&amp;amp;&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["后置递增运算符重置报错", ["#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "MyTeger", "{\n    \n", "public", ":\n\n    ", "friend", " ostream& ", "operator", "<<(ostream &cout,MyTeger &p);\n    MyTeger &", "operator", "++();\n    MyTeger ", "operator", "++(", "int", ");\n            \n", "private", ":\n    ", "int", " m_A;\n    ", "int", " m_B;\n};\n\n", "int", " ", "main", "()", "{\n    \n    MyTeger p1;\n\n    p1++;\n    cout<<++p1;\n", "\n", "这里前置", "++", "正确，但是后置", "++", "就报错，请问为什么呢？", "\n", "\n", "    ", "return", " ", "0", ";\n} \n\n", "//左移运算符重载 ", "\nostream& ", "operator", "<<(ostream &cout,MyTeger &p){\n    cout<<", "\"m_A=\"", "<<p.m_A<<", "\"  m_B=\"", "<<p.m_B<<endl;\n    ", "return", " cout;\n}\n\n", "//前置递增 ", "\nMyTeger &MyTeger:: ", "operator", "++(){        \n    m_A++;\n    m_B++;\n    ", "return", " *", "this", ";\n}\n\n", "//后置递增 ", "\nMyTeger MyTeger::", "operator", "++(int){\n    MyTeger temp=*", "this", ";\n    m_A++;\n    m_B++; \n    ", "return", " temp;;\n}\n"]], "Tag": "程序设计"}
{"Answer": "首先要注意，Color类可以用一个Integer表示，但是两个Integer相减极端的情况下可能出现下溢。而且考虑到其实一个颜色是4个字节的分量，从颜色本身的角度来说，对每个分量计算才有意义，直接Integer相减没有事实上的意义，你得到的值就算不下溢也可能是一种很奇怪的颜色。\r\n\r\n其次，VB不支持对现有的类的运算符重载。也就是说，Color不是你定义的，所以你不能直接重载它的减运算符。但是你可以写一个函数来做。", "Konwledge_Point": "运算符重载", "Question": ["VB.net给Color类添加运算符怎么做？", ["如题，要**让Color类支持“-”这个运算符**，返回一个Integer，有没有办法做到？", "\n如写好后  Color.White - Color.Yellow 应该就可以返回一个Integer", "\n具体的运算步骤不用写，只求框架代码qwq"]], "Tag": "程序设计"}
{"Answer": "也许是我的问题不正确，我现在已经得到答案了，在自己构建QMultiHash&lt;ket,t&gt;的时候，ket和t是结构体时。需要给key重载==运算符，并设置全局的qHash函数供系统使用。\r\n小例子以方便理解：\r\n重载==函数就不写了，主要就是对qHash这个全局函数进行重载，将结构体中的每个元素异或。\r\n\r\n```\r\n typedef struct A_key\r\n {\r\n\t\t\tint a;\r\n\t\t\tchar b;\r\n\t\t\tdouble c;\r\n }Akey;\r\n \r\n typedef struct A_t\r\n {\r\n\t int a;\r\n }At;\r\n QMultiHash&lt;Akey, At&gt; TwoStructHash;\r\n \r\n int qHash(const Akey&amp; AkeyTemp)\r\n {\r\n\t return AkeyTemp.a ^ AkeyTemp.b ^ AkeyTemp.c;\r\n }\r\n```", "Konwledge_Point": "运算符重载", "Question": ["QMultiHash建立QMultiHash<key,t>时遇到问题", ["请问建立一个 一对多的映射，使用了QMultiHash，全局的qHash怎么写？", "\n重载了==运算符后，报错，主要不会qHash，也不明白。", "\n补充：我所写的key和T都是两个结构体。", "\n\n", "使用insertMulti", "\n\n", " 1>  main.cpp\n1>d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(111): error C2665: “qHash”: 17 个重载中没有一个可以转换所有参数类型\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(63): 可能是“uint qHash(char,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(64): 或       “uint qHash(uchar,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(65): 或       “uint qHash(signed char,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(66): 或       “uint qHash(ushort,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(67): 或       “uint qHash(short,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(68): 或       “uint qHash(uint,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(69): 或       “uint qHash(int,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(70): 或       “uint qHash(ulong,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(78): 或       “uint qHash(long,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(79): 或       “uint qHash(quint64,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(87): 或       “uint qHash(qint64,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(88): 或       “uint qHash(QChar,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(89): 或       “uint qHash(const QByteArray &,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(90): 或       “uint qHash(const QString &,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(91): 或       “uint qHash(const QStringRef &,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(92): 或       “uint qHash(const QBitArray &,uint) throw()”\n1>          d:\\qt\\qt5.1.1\\5.1.1\\msvc2010\\include\\qtcore\\qhash.h(93): 或       “uint qHash(QLatin1String,uint) throw()”\n.\n.\n.\n"]], "Tag": "程序设计"}
{"Answer": "用静态数组的时候，必须同时指明数组的大小，比如int w[10],这是因为静态数组在栈上分配，在编译的时候就已经分配好内存了。楼主可以使用指针，也可以使用标准模板库中的vector.\r\n\tclass s\r\n{\r\npublic:\r\ns(int a) \r\n{\r\n w=new int[a];\r\n }\r\n //别忘了在析构函数中释放内存\r\n ~s()\r\n {\r\n delete[] w;\r\n }\r\n...\r\nprivate:\r\nint* w;\r\n.....\r\n};", "Konwledge_Point": "运算符重载", "Question": ["c＋＋如何定义一个类中的数据不确定的类", ["比如 ", "\nclass s", "\n{", "\npublic:", "\n      s(int a) {b=a;}", "\n      ...", "\nprivate:", "\n     int b;", "\n     int w[b];", "\n     .....", "\n};", "\n\n", "我试着用new，但是还是不成功，那么有什么办法可以使类中的数据多少由外部确定呢？", "\n\n", "这是我在重载[]成员访问运算符", "\n和重载()函数调用运算符时遇到的问题。"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;&lt;p&gt;traverse()的操作器的参数类型需要改为右值引用&amp;amp;&amp;amp;&amp;#xff0c;因为&lt;code class=\"language-javascript\"&gt;V.traverse ( Crc&amp;lt;T&amp;gt; ( crc ) );&lt;/code&gt;传入的参数是临时变量&amp;#xff0c;左值引用无法绑定&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; T&amp;gt; &lt;span class=\"hljs-keyword\"&gt;template&lt;/span&gt; &amp;lt;&lt;span class=\"hljs-keyword\"&gt;typename&lt;/span&gt; VST&amp;gt;\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Vector&amp;lt;T&amp;gt;::&lt;span class=\"hljs-built_in\"&gt;traverse&lt;/span&gt; ( VST&amp;amp;&amp;amp; visit ) &lt;span class=\"hljs-comment\"&gt;// 参数类型改为VST&amp;amp;&amp;amp;&amp;#xff0c;当传入参数是左值时&amp;#xff0c;visit的类型是左值引用&amp;#xff0c;当传入参数是右值时&amp;#xff0c;visit的类型时右值引用&lt;/span&gt;\n{ &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; ( Rank i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; _size; i&amp;#43;&amp;#43; ) &lt;span class=\"hljs-built_in\"&gt;visit&lt;/span&gt; ( _elem[i] ); }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt; 不会。不过你已经声明了构造函数&amp;#xff0c;编译器不会为其生成默认构造函数&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code class=\"language-javascript\"&gt;Crc&amp;lt;T&amp;gt; ( crc )&lt;/code&gt;可以作为操作器使用&amp;#xff0c;它实际上是创建了一个零时对象&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "运算符重载", "Question": ["()重载后的结构体如何作为函数指针或操作器的形式使用？", ["问题背景", "：", "有遍历向量的函数，为了方便在便利时进行其他操作，其实现如下：", "\n", "\n", "template", " <", "typename", " T> ", "void", " Vector<T>::", "traverse", " ( ", "void", " ( *visit ) ( T& ) ) ", "//借助函数指针机制", "\n{ ", "for", " ( Rank i = ", "0", "; i < _size; i++ ) ", "visit", " ( _elem[i] ); } ", "//遍历向量", "\n\n", "template", " <", "typename", " T> ", "template", " <", "typename", " VST> ", "//元素类型、操作器", "\n", "void", " Vector<T>::", "traverse", " ( VST& visit ) ", "//借助函数对象机制", "\n{ ", "for", " ( Rank i = ", "0", "; i < _size; i++ ) ", "visit", " ( _elem[i] ); } ", "//遍历向量", "\n", "\n", "另有一个函数，统计向量的特征，其中重载了()运算符，如下：", "\n", "\ntemplate ", "<", "typename ", "T", ">", " struct Crc ", "{", " ", "/", "/", "函数对象：累计", "T", "类对象的特征（比如总和），以便校验对象集合\n   ", "T", "&", " ", "c", ";\n   Crc ", "(", " ", "T", "&", " crc ", ")", " ", ":", " ", "c", " ", "(", " crc ", ")", " ", "{", "}", "\n   virtual void operator", "(", ")", " ", "(", " ", "T", "&", " e ", ")", " ", "{", " ", "c", " ", "+", "=", " e; ", "}", " ", "/", "/", "假设", "T", "可直接相加\n", "}", ";\n", "\n", "为了能够在遍历向量的时候统计出所有元素的总和，封装了以下函数：", "\n", "\n", "template", " <", "typename", " T> ", "void", " ", "crc", " ", "( Vector<T> & V )", " ", "{ ", "//统计向量的特征（所有元素之和）", "\n    T crc = ", "0", ";\n    V.", "traverse", " ( ", "Crc", "<T> ( crc ) ); ", "//以crc为基本操作进行遍历", "\n    ", "printf", " ( ", "\"CRC =\"", " );\n    ", "print", " ( crc );\n    ", "printf", " ( ", "\"\\n\"", " ); ", "//输出统计得到的特征", "\n}\n", "\n", "问题", "：", "1、最终结合traverse()函数以及结构体封装出来的函数，编译器检测到在调用traverse函数时， 无法找到相匹配的traverse()函数，应该是传入参数的类型不对，代码中这样写是否有错误？应该如何修改呢？", "2、重载的()运算符会影响到结构体模板中的默认构造函数么？", "3、最后一段代码中的 Crc ( crc )可以作为函数指针或则操作器使用么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一题&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Count&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;Count&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n):&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;(n){}           &lt;span class=\"hljs-comment\"&gt;//构造函数&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Count obj);       &lt;span class=\"hljs-comment\"&gt;//定义重载&amp;#39;&amp;#43;&amp;#39;号运算符函数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n};\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Count::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Count obj)         &lt;span class=\"hljs-comment\"&gt;//实现重载函数&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;n&amp;#43;obj.n;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Count &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;)&lt;/span&gt;,&lt;span class=\"hljs-title\"&gt;B&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; A&amp;#43;B;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第二题&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Border&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;Border&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size):&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;(size){}                                &lt;span class=\"hljs-comment\"&gt;//构造函数&lt;/span&gt;\n        &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[](&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index);                                 &lt;span class=\"hljs-comment\"&gt;//重载&amp;#39;[]&amp;#39;运算符&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size;\n};\n\n&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; Border::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[](&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index)                          &lt;span class=\"hljs-comment\"&gt;//重载函数的实现&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(index &amp;gt;&amp;#61; size)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;              &lt;span class=\"hljs-comment\"&gt;//false代表越界&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; \n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;                  &lt;span class=\"hljs-comment\"&gt;//true代表未越界&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Border &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; A[&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;] &amp;lt;&amp;lt; endl;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第三题&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; SIZE 5&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Stack&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; top;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[SIZE];\n}stack;\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Push_stack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num)&lt;/span&gt;&lt;/span&gt;;           &lt;span class=\"hljs-comment\"&gt;//入栈&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Pop_stack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;                   &lt;span class=\"hljs-comment\"&gt;//出栈&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Print_stack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;                &lt;span class=\"hljs-comment\"&gt;//导出栈&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    stack.top &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;Push_stack&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Push_stack&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Push_stack&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Push_stack&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Push_stack&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Push_stack&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;Print_stack&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;Pop_stack&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;Pop_stack&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;Pop_stack&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;Pop_stack&lt;/span&gt;();\n    \n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Push_stack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(stack.top &amp;lt; SIZE&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        stack.top&amp;#43;&amp;#43;;\n        stack.arr[stack.top] &amp;#61; num;   \n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; \n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stack over flow!&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Pop_stack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(stack.top !&amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n    {\n        stack.top--;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stack under flow!&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Print_stack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; stack.top; i&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,stack.arr[i]);\n    }\n    cout &amp;lt;&amp;lt; endl;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["这几道课后题该怎样正确程序实现", ["1.定义一个计数器类Counter，包含私有成员int n、重载运算符“+”，实现对象的相加。", "2.c++语言中不会检查数组是否越界。设计类Border，通过重载运算符“【】”检查数组是否越界。", "3.数据的进栈，出栈的程序实现"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;\n&lt;span class=\"hljs-comment\"&gt;/**\n * 课程类\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt; {\n\n    &lt;span class=\"hljs-comment\"&gt;//课程编号&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; courseId;\n\n    &lt;span class=\"hljs-comment\"&gt;//课程名称&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; courseName;\n\n    &lt;span class=\"hljs-comment\"&gt;//学分信息&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Double&lt;/span&gt; credit;\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 空构造函数\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt;(){\n\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 有三个参数的构造函数\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; courseId 课程编号\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; courseName 课程名称\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; credit 学分信息\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt;(&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; courseId,&lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; courseName,&lt;span class=\"hljs-title class_\"&gt;Double&lt;/span&gt; credit){\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;courseId&lt;/span&gt; &amp;#61; courseId;\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;courseName&lt;/span&gt; &amp;#61; courseName;\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;credit&lt;/span&gt; &amp;#61; credit;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 修改学分信息的方法\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; credit 新的学分信息\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;editCredit&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;Double credit&lt;/span&gt;){\n        &lt;span class=\"hljs-variable language_\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;credit&lt;/span&gt; &amp;#61; credit;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 展示课程的所有信息\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;return&lt;/span&gt; 课程的所有信息\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;String&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;showCourseInfo&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;){\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;课程编号:&amp;#34;&lt;/span&gt;&amp;#43;courseId&amp;#43;&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n课程名称:&amp;#34;&lt;/span&gt;&amp;#43;courseName&amp;#43;&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n学分信息:&amp;#34;&lt;/span&gt;&amp;#43;credit;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;/**\n     * 测试的方法\n     * &lt;span class=\"hljs-doctag\"&gt;&amp;#64;param&lt;/span&gt; args 无\n     */&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;[] args&lt;/span&gt;) {\n        &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt; math &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;001&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;数学&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5.0&lt;/span&gt;);\n        &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt; chinese &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;002&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;语文&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4.5&lt;/span&gt;);\n        &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt; english &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Course&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;003&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;英语&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2.5&lt;/span&gt;);\n\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(math.&lt;span class=\"hljs-title function_\"&gt;showCourseInfo&lt;/span&gt;());\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(chinese.&lt;span class=\"hljs-title function_\"&gt;showCourseInfo&lt;/span&gt;());\n        &lt;span class=\"hljs-title class_\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-property\"&gt;out&lt;/span&gt;.&lt;span class=\"hljs-title function_\"&gt;println&lt;/span&gt;(english.&lt;span class=\"hljs-title function_\"&gt;showCourseInfo&lt;/span&gt;());\n\n    }\n\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["编写一个课程类Course", ["编写一个课程类Course，包括课程编号，课程名称和学分信息；设计两个成员方法，一个用来修改课程的学分信息，一个方法输出课程的所有信息；给出该类的构造方法，包括一个无参构造方法和一个三个参数的构造方法。并编写测试类通过不同的构造方法创建该类对象和调用该类方法。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;iostream&amp;gt;\n\nusing namespace std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Xil\n{\npublic:\n    &lt;span class=\"hljs-constructor\"&gt;Xil(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;_x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;_y&lt;/span&gt;)&lt;/span&gt;\n    {\n        x&amp;#61;_x;\n        y&amp;#61;_y;\n    }\n    Xil operator &amp;#43;(Xil&amp;amp;num)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;Xil(&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-params\"&gt;num&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-params\"&gt;num&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;;\n    }\n    Xil operator -(Xil&amp;amp;num)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;Xil(&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;-&lt;span class=\"hljs-params\"&gt;num&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;-&lt;span class=\"hljs-params\"&gt;num&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;y&lt;/span&gt;)&lt;/span&gt;;\n    }\n    void show&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(y&amp;lt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; x;&lt;span class=\"hljs-comment\"&gt;//实部&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; y;&lt;span class=\"hljs-comment\"&gt;//虚部&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n    Xil a(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    Xil b(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;);\n    Xil c&amp;#61;a&amp;#43;b;\n    a.show&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n    b.show&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n    c.show&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Hello world!&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/188417853556147.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++  向量要怎么计算看一下", ["设计一个向量类，包含两个私有数据成员，重载+ -", "运算符以实现向量对象之间的加减运算。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include&lt;br /&gt;using namespace std;&lt;br /&gt;int main()&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;    float a,b;&lt;br /&gt;    char c,d;&lt;br /&gt;    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;c&amp;gt;&amp;gt;b&amp;gt;&amp;gt;d;&lt;br /&gt;    cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;c&amp;lt;&amp;lt;b&amp;lt;&amp;lt;d;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["请问用C++怎么做这个", ["本题目要求完成复数类对象的输入运算符>>和输出运算符<<的重载，具体要求如下：定义复数类，包括两个私有成员：double real,imag;定义复数类的构造函数；重载输入运算符>>,使主函数可以通过cin>>接收复数对象的输入；重载输出运算符<<,使主函数可以通过cout<<输出复数对象。在主函数中构造复数对象，并用cin>>和cout<<进行输入输出的测试.", "\n", "输入格式:", "Ａ+Bi，其中Ａ和Ｂ是两个实数。", "\n", "输出格式:", "Ａ+Bi，其中Ａ和Ｂ是两个实数。", "\n", "输入样例:", "在这里给出一组输入。例如：", "\n", "3.1+4.2i", "输出样例:", "在这里给出相应的输出。例如：", "\n", "3.1+4.2i"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;string&amp;gt;\nusing namespace std;\nclass Date\n{\npublic:\n\tint year;\n\tint month;\n\tint day;\n\tDate(int y,int m,int d){year &amp;#61; y;month &amp;#61; m;day &amp;#61; d;}\n\t~Date(){}\n\tDate(long days)\n\t{\n\t\tint i;\n\t\tint ss &amp;#61; 0;\n\t\tint ds[] &amp;#61; {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tfor (i &amp;#61; 0;ss &amp;lt; days;i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tss &amp;#43;&amp;#61; ds[i];\n\t\t}\n\t\tyear &amp;#61; 2021;\n\t\tmonth &amp;#61; i -1;\n\t\tday &amp;#61; day - (ss - ds[i]);\n\t}\n\n\tfriend ostream &amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;o,const Date &amp;amp;s);\n\tfriend istream &amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;is,Date &amp;amp;s);\n\t\n\tDate&amp;amp; operator&amp;#43;&amp;#43;()\n\t{\n\t\tday&amp;#43;&amp;#43;;\n\t\tint ds[] &amp;#61; {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tswitch(month)\n\t\t{\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\tcase 7:\n\t\tcase 8:\n\t\tcase 10:\n\t\t\tif(day &amp;gt; 31)\n\t\t\t{\n\t\t\t\tday &amp;#61; 1;\n\t\t\t\tmonth&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (year %4 &amp;#61;&amp;#61; 0 &amp;amp;&amp;amp; year %100 !&amp;#61; 0 || year%400 &amp;#61;&amp;#61; 0)\n\t\t\t{\n\t\t\t\tif(day &amp;gt; 29)\n\t\t\t\t{\n\t\t\t\t\tday &amp;#61; 1;\n\t\t\t\t\tmonth &amp;#61; 3;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(day &amp;gt; 28)\n\t\t\t\t{\n\t\t\t\t\tday &amp;#61; 1;\n\t\t\t\t\tmonth &amp;#61; 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 9:\n\t\tcase 11:\n\t\t\tif (day &amp;gt; 30)\n\t\t\t{\n\t\t\t\tday &amp;#61; 1;\n\t\t\t\tmonth&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tif (day &amp;gt; 31)\n\t\t\t{\n\t\t\t\tmonth &amp;#61; 1;\n\t\t\t\tyear&amp;#43;&amp;#43;;\n\t\t\t\tday &amp;#61; 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn (*this);\n\t}\n\tDate operator&amp;#43;&amp;#43;(int)\n\t{\n\t\tDate tmp &amp;#61; (*this);\n\t\ttmp.day&amp;#43;&amp;#43;;\n\t\tint ds[] &amp;#61; {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tswitch(tmp.month)\n\t\t{\n\t\tcase 1:\n\t\tcase 3:\n\t\tcase 5:\n\t\tcase 7:\n\t\tcase 8:\n\t\tcase 10:\n\t\t\tif(tmp.day &amp;gt; 31)\n\t\t\t{\n\t\t\t\ttmp.day &amp;#61; 1;\n\t\t\t\ttmp.month&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (tmp.year %4 &amp;#61;&amp;#61; 0 &amp;amp;&amp;amp; tmp.year %100 !&amp;#61; 0 || tmp.year%400 &amp;#61;&amp;#61; 0)\n\t\t\t{\n\t\t\t\tif(tmp.day &amp;gt; 29)\n\t\t\t\t{\n\t\t\t\t\ttmp.day &amp;#61; 1;\n\t\t\t\t\ttmp.month &amp;#61; 3;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(tmp.day &amp;gt; 28)\n\t\t\t\t{\n\t\t\t\t\ttmp.day &amp;#61; 1;\n\t\t\t\t\ttmp.month &amp;#61; 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 6:\n\t\tcase 9:\n\t\tcase 11:\n\t\t\tif (tmp.day &amp;gt; 30)\n\t\t\t{\n\t\t\t\ttmp.day &amp;#61; 1;\n\t\t\t\ttmp.month&amp;#43;&amp;#43;;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tif (tmp.day &amp;gt; 31)\n\t\t\t{\n\t\t\t\ttmp.month &amp;#61; 1;\n\t\t\t\ttmp.year&amp;#43;&amp;#43;;\n\t\t\t\ttmp.day &amp;#61; 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn Date(tmp);\n\t}\n\n\toperator int()\n\t{\n\t\tint i;\n\t\tint ss &amp;#61; 0;\n\t\tint ds[] &amp;#61; {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tfor (i &amp;#61; 0;i &amp;lt;&amp;#61; month;i&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tss &amp;#43;&amp;#61; ds[i];\n\t\t}\n\t\tss &amp;#43;&amp;#61; day;\n\t\treturn ss;\n\t}\n};\n\nostream &amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;o,const Date &amp;amp;s)\n{\n\to &amp;lt;&amp;lt; s.year &amp;lt;&amp;lt; &amp;#34;-&amp;#34; &amp;lt;&amp;lt; s.month &amp;lt;&amp;lt; &amp;#34;-&amp;#34; &amp;lt;&amp;lt; s.day;\n\treturn o;\n}\nistream &amp;amp; operator&amp;gt;&amp;gt;(istream &amp;amp;is,Date &amp;amp;s)\n{\n\tstring inputStr;\n\tis &amp;gt;&amp;gt; inputStr;\n\tint pos &amp;#61; inputStr.find(&amp;#34;-&amp;#34;,0);\n\tstring tmpStr &amp;#61; inputStr.substr(0,pos);\n\ts.year &amp;#61; atoi(tmpStr.c_str());\n\tint pos2 &amp;#61; inputStr.find(&amp;#34;-&amp;#34;,pos &amp;#43; 1);\n\ttmpStr &amp;#61; inputStr.substr(pos&amp;#43;1,pos2-pos -1);\n\ts.month &amp;#61; atoi(tmpStr.c_str());\n\ttmpStr &amp;#61; inputStr.substr(pos2&amp;#43;1,inputStr.length() - pos2 -1);\n\ts.day &amp;#61; atoi(tmpStr.c_str());\n\treturn is;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于c++类的设计练习", ["仿照 Time 类的设计，设计一个 Date 类，数据成员为年、月和日，成员函数包括:", "\n\n", "适当的构造函数和析构函数，其中的转换构造函数将从今年元旦(含元旦)以来的天", "\n\n", "数(<366)转换为 Date 类对象;", "\n\n", "设置年、月和日的函数;", "\n\n", "读取年、月和日的函数;", "\n\n", "重载流提取和流插入运算符函数;", "\n\n", "重载前自增和后自增运算符函数;", "\n\n", "重载转换运算符函数，将 Date 类对象转换为天数(该年的第几天)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://zhidao.baidu.com/question/1754442216896196628.html\" id=\"textarea_1632878283108_1632878392257_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C&amp;#43;&amp;#43;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;Ʋ&amp;#xfffd;ʵ&amp;#xfffd;ַ&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;ࣨ1&amp;#xfffd;&amp;#xfffd; Fraction &amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;Ķ&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;&amp;#xfffd;ʾ_&amp;#xfffd;ٶ&amp;#xfffd;֪&amp;#xfffd;&amp;#xfffd;&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"margin: 0px 0 2px\"&gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://www.baidu.com/favicon.ico?t&amp;#61;20171027\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://zhidao.baidu.com/question/1754442216896196628.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/puermilk/p/3745710.html\" id=\"textarea_1632878283108_1632878392257_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;分数类的四则运算【C&amp;#43;&amp;#43;】编写分数类Fraction&amp;#xff0c;实现两个分数的加、减、乘和除四则运算。主函数已给定。 - 浅水戏虾sty - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Description编写分数类Fraction&amp;#xff0c;实现两个分数的加、减、乘和除四则运算。主函数已给定。Input每行四个数&amp;#xff0c;分别表示两个分数的分子和分母&amp;#xff0c;以0 0 0 0 表示结束。Output空格分&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/puermilk/p/3745710.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["《C++》课内实验 实验二 基于对象的程序设计", ["设计一个分数类Fraction，其中包含私有数据成员nume（分子）与deno（分母），以及共有默认构造函数、带参数的构造函数，成员函数display()（显示函数）和simplify()（化简函数）。2. 在上题的基础上，重载“+”、“-”、“*”、“/”完成两个分数的四则运算，要求使用成员函数化简运算结果。3. 在上题的基础上，重载“+”、“-”完成分数的取正和取负功能。4. 在上题的基础上，重载流插入运算符“<<”和流提取运算符“>>”使之能用于分数的输出与输入。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c#\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; System;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; System.Collections.Generic;\n\n&lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; ConsoleApp2\n{\n    &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Vector&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[] list;\n        &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; dim;\n\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Dim { get &amp;#61;&amp;gt; dim; set &amp;#61;&amp;gt; dim &amp;#61; value; }\n        &lt;span class=\"hljs-keyword\"&gt;protected&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[] List { get &amp;#61;&amp;gt; list; set &amp;#61;&amp;gt; list &amp;#61; value; }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Vector&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            list &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];           \n            dim &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Vector&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length)&lt;/span&gt; &lt;/span&gt;{         \n            list &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;[length];\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; length; i&amp;#43;&amp;#43;) list[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            dim &amp;#61; length;\n        }\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;SetVectorList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index,&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; value)&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (index &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;This is a wrong Dim!&amp;#34;&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n            }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (index &amp;gt;&amp;#61; dim)\n            {\n                &lt;span class=\"hljs-comment\"&gt;//数组扩容&lt;/span&gt;\n                Array.&lt;span class=\"hljs-built_in\"&gt;Resize&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;&amp;gt;(ref list, index &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.dim &amp;#61; index&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            }\n             list[index] &amp;#61; value;\n        }\n        &lt;span class=\"hljs-comment\"&gt;// 点乘&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Dot&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Vector v)&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d &amp;#61; v.Dim;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;#61;&amp;#61; Dim)\n            {\n                &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; value&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; v.dim; i&amp;#43;&amp;#43;)\n                {\n                    value &amp;#43;&amp;#61; v.list[i] * &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.list[i];\n                }\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; value;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;They have wrong Dim!&amp;#34;&lt;/span&gt;);                \n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n\n        &lt;span class=\"hljs-comment\"&gt;//距离&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Distance&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Vector v)&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d &amp;#61; v.Dim;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d &amp;#61;&amp;#61; Dim)\n            {\n                &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; value &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,tmpDouble&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; d; i&amp;#43;&amp;#43;)\n                {\n                    tmpDouble &amp;#61; v.list[i] - &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.list[i];\n                    value &amp;#43;&amp;#61; tmpDouble * tmpDouble;\n                }\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; Math.&lt;span class=\"hljs-built_in\"&gt;Sqrt&lt;/span&gt;(value);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;They have wrong Dim!&amp;#34;&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            }\n        }\n       \n        &lt;span class=\"hljs-comment\"&gt;//夹角&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Angle&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Vector v)&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; dotValue &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;Dot&lt;/span&gt;(v);\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; aLen &amp;#61; v.&lt;span class=\"hljs-built_in\"&gt;Length&lt;/span&gt;();\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; bLen &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;Length&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; Math.&lt;span class=\"hljs-built_in\"&gt;Acos&lt;/span&gt;(dotValue/(aLen*bLen));\n        }       \n        &lt;span class=\"hljs-comment\"&gt;//Normal&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Normal&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; Len &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;Length&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (Len &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; dim; i&amp;#43;&amp;#43;)\n                {\n                    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.list[i] /&amp;#61; Len;\n                }\n            }\n        }\n        &lt;span class=\"hljs-comment\"&gt;// Length&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Length&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.Dim &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) \n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; value&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; dim; i&amp;#43;&amp;#43;)\n            {\n                value &amp;#43;&amp;#61; list[i] * list[i];\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; Math.&lt;span class=\"hljs-built_in\"&gt;Sqrt&lt;/span&gt;(value);\n        }\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;override&lt;/span&gt; string &lt;span class=\"hljs-title\"&gt;ToString&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (dim &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) \n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;()&amp;#34;&lt;/span&gt;;\n            &lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; str &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;#43; list[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;ToString&lt;/span&gt;();\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; dim; i&amp;#43;&amp;#43;)\n            {\n                str &amp;#43;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;,&amp;#39;&lt;/span&gt; &amp;#43; list[i].&lt;span class=\"hljs-built_in\"&gt;ToString&lt;/span&gt;();\n            }\n            str &amp;#43;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;)&amp;#39;&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; str;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;display&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;ToString&lt;/span&gt;());\n        }\n        &lt;span class=\"hljs-comment\"&gt;//重载运算符“&amp;#43;&amp;#34;, “-”对两个向量进行加减操作,重载运算符“&amp;#61;”判断两个向量是否是同向的&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; Vector &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(Vector a, Vector b)\n        {\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d1 &amp;#61; a.Dim, d2&amp;#61;b.Dim;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1 &amp;#61;&amp;#61; d2)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; d1; i&amp;#43;&amp;#43;)\n                {\n                    a.list[i] &amp;#43;&amp;#61; b.list[i];\n                }\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;They have wrong Dim!&amp;#34;&lt;/span&gt;);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a;\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; Vector &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -(Vector a, Vector b)\n        {\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; d1 &amp;#61; a.Dim, d2 &amp;#61; b.Dim;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (d1 &amp;#61;&amp;#61; d2)\n            {\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; d1; i&amp;#43;&amp;#43;)\n                {\n                    a.list[i] -&amp;#61; b.list[i];\n                }\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;They have wrong Dim!&amp;#34;&lt;/span&gt;);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61; (Vector a, Vector b)\n        {\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; angle &amp;#61; a.&lt;span class=\"hljs-built_in\"&gt;Angle&lt;/span&gt;(b);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; angle &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; !&amp;#61;(Vector a, Vector b)\n        {\n            &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; angle &amp;#61; a.&lt;span class=\"hljs-built_in\"&gt;Angle&lt;/span&gt;(b);\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; angle !&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;override&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Equals&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(object obj)&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;Equals&lt;/span&gt;(obj);\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;override&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;GetHashCode&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; base.&lt;span class=\"hljs-built_in\"&gt;GetHashCode&lt;/span&gt;();\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Program&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(string[] args)&lt;/span&gt;\n        &lt;/span&gt;{\n            Vector v &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Vector&lt;/span&gt;();\n            v.&lt;span class=\"hljs-built_in\"&gt;SetVectorList&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            v.&lt;span class=\"hljs-built_in\"&gt;SetVectorList&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n            v.&lt;span class=\"hljs-built_in\"&gt;SetVectorList&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n            &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(v);\n            Vector v1 &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Vector&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n            v1.&lt;span class=\"hljs-built_in\"&gt;SetVectorList&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            v1.&lt;span class=\"hljs-built_in\"&gt;SetVectorList&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n            v1.&lt;span class=\"hljs-built_in\"&gt;SetVectorList&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n            &lt;span class=\"hljs-built_in\"&gt;Console&lt;/span&gt;.&lt;span class=\"hljs-built_in\"&gt;WriteLine&lt;/span&gt;(v1);\n        }\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/965738734736169.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["定义一个向量类Vector，有以下成员", ["(1)保护字段存放向量的各个分量值,使用一维数组存放。", "(2)公有属性Dim获取向量的维数。", "(3)默认的公有构造函数,产生一个零向量,带参数构造函数,使用可变数组参数。", "(4)公有方法Dot求两向量点乘的结果, Distance求两个向量之间的距离, Angle求两个向量之间的夹角, Normal对向量进行单位化， Length求向量的长度", "(5)重载运算符“+\", “.”对两个向量进行加减操作,重载运算符“=”判断两个向量是否是同向的。", "(6)公有函数display以如下形式输出向量中的各个分量(1,2..,5)"]], "Tag": "程序设计"}
{"Answer": "http://www.cnblogs.com/lifuqing/archive/2011/08/20/List.html", "Konwledge_Point": "运算符重载", "Question": ["电工4课程作业1：实现一个单链表", ["实现单链表并且要有如下操作：插入（任意位置）、删除（包括中间结点）、查找、计算链表长度、清空、链表连接（重载运算符），并且写一个程序验证。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的结果如果是--b:(3,3)的话&amp;#xff0c;&amp;#43;&amp;#43;和--只对实部起作用。&lt;br /&gt;你的结果&amp;#xff0c;最后的--b如果是--b:(3,1)&amp;#xff0c;&amp;#43;&amp;#43;和--对实部和虚部都起作用。&lt;br /&gt;两种情况的代码都贴出来了&amp;#xff0c;根据你的需要选择吧。&lt;br /&gt;&amp;#xff08;1&amp;#xff09;--只对实部起作用的运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/86917003615615.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;2&amp;#xff09;--对实部和虚部都起作用的运行结果&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/39499557515613.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&amp;#xff08;1&amp;#xff09;的代码&amp;#xff1a;&amp;#xff08;--只对实部起作用&amp;#xff09;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Complex&lt;/span&gt;&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    int real, imag;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    Complex(int r &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { real &amp;#61; r; imag &amp;#61; i; }\n    ~Complex() {}\n    friend ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex&amp;amp; c);\n\n    friend Complex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#61;(Complex&amp;amp; c1, Complex&amp;amp; c2)\n    {\n        c1.real &amp;#43;&amp;#61; c2.real;\n        c1.imag &amp;#43;&amp;#61; c2.imag;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c1;\n    }\n    friend Complex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -&amp;#61;(Complex&amp;amp; c1, Complex&amp;amp; c2)\n    {\n        c1.real -&amp;#61; c2.real;\n        c1.imag -&amp;#61; c2.imag;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c1;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//前置&amp;#43;&amp;#43;&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;() {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//this-&amp;gt;imag &amp;#43;&amp;#61; 1; //如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//后置&amp;#43;&amp;#43;&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;(int) {\n\n        Complex c(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real, &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag);\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//this-&amp;gt;imag &amp;#43;&amp;#61; 1;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//前置--&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --() {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//this-&amp;gt;imag -&amp;#61; 1;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//后置--&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --(int) {\n\n        Complex c(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real, &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag);\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//this-&amp;gt;imag -&amp;#61; 1;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n\n};\n\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex&amp;amp; c)\n{\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c.real &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c.imag &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n\nint main()\n{\n    Complex a(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;), b(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Complex a:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Complex b:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;\n    a -&amp;#61; b;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;After executing a-&amp;#61;b,Complex a:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;b--:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; b-- &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;--b:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; --b &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&amp;#xff08;2&amp;#xff09;的代码&amp;#xff1a;&amp;#xff08;--对实部和虚部都起作用&amp;#xff09;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Complex&lt;/span&gt;&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    int real, imag;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    Complex(int r&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { real &amp;#61; r; imag &amp;#61; i; }\n    ~Complex() {}\n    friend ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex&amp;amp; c);\n    \n    friend Complex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#61;(Complex&amp;amp; c1, Complex&amp;amp; c2)\n    {\n        c1.real &amp;#43;&amp;#61; c2.real;\n        c1.imag &amp;#43;&amp;#61; c2.imag;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c1;\n    }\n    friend Complex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -&amp;#61;(Complex&amp;amp; c1, Complex&amp;amp; c2)\n    {\n        c1.real -&amp;#61; c2.real;\n        c1.imag -&amp;#61; c2.imag;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c1;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//前置&amp;#43;&amp;#43;&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;() {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//后置&amp;#43;&amp;#43;&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;(int) {\n        \n        Complex c(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real, &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag);\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//前置--&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --() {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//后置--&lt;/span&gt;\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --(int) {\n        \n        Complex c(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real, &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag);\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;imag -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//如果&amp;#43;&amp;#43;只对实部起作用&amp;#xff0c;就注释掉这一句&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n\n};\n\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex&amp;amp; c)\n{\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c.real &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c.imag &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n\nint main()\n{\n    Complex a(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;), b(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Complex a:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Complex b:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;\n    a -&amp;#61; b;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;After executing a-&amp;#61;b,Complex a:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;b--:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; b-- &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;--b:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; --b &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["较为复杂的类与对象问题", ["设计一个复杂的类，", "一个复杂对象包含两个私有数据成员：real(type:int),imag(type:int)。 并且该类必须具有一个带有默认参数的构造函数，该参数的值为零和析构函数。", "输出运算符<<的重载，输出格式：(real,imag)。", "以友元函数的形式重载运算符-=、+=", "以成员函数的形式重载运算符前和后。", "我的代码：", "\n", "int main(){", "    Complex a(3,5),b(5,3);", "    cout<<\"Complex a:\"<<a<<endl;", "    cout<<\"Complex b:\"<<b<<endl;", "    a-=b;", "    cout<<\"After executing a-=b,Complex a:\"<<a<<endl;", "    cout<<\"b--:\"<<b--<<endl;", "    cout<<\"--b:\"<<--b<<endl;", "}", "\n", "当主函数给出并执行时，我希望产生如下结果：", "Complex a:(3,5)", "Complex b:(5,3)", "After executing a-=b,Complex a:(-2,2)", "b--:(5,3)", "--b:(3,3)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有用请采纳哦&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;RMB&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;RMB&lt;/span&gt;():&lt;span class=\"hljs-built_in\"&gt;yuan&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),&lt;span class=\"hljs-built_in\"&gt;jiao&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;),&lt;span class=\"hljs-built_in\"&gt;fen&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){}\n    &lt;span class=\"hljs-built_in\"&gt;RMB&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c):&lt;span class=\"hljs-built_in\"&gt;yuan&lt;/span&gt;(a),&lt;span class=\"hljs-built_in\"&gt;jiao&lt;/span&gt;(b),&lt;span class=\"hljs-built_in\"&gt;fen&lt;/span&gt;(c){}\n    &lt;span class=\"hljs-built_in\"&gt;RMB&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r1):&lt;span class=\"hljs-built_in\"&gt;yuan&lt;/span&gt;(r1.yuan),&lt;span class=\"hljs-built_in\"&gt;jiao&lt;/span&gt;(r1.jiao),&lt;span class=\"hljs-built_in\"&gt;fen&lt;/span&gt;(r1.fen){}\n\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; RMB &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r1,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r2);\n    &lt;span class=\"hljs-comment\"&gt;// 后置&amp;#43;&amp;#43;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; RMB &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43; (RMB&amp;amp; r1,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;// 前置&amp;#43;&amp;#43;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; RMB &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43; (RMB&amp;amp; r1);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt; (ostream &amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r1);\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; yuan;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; jiao;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; fen;\n};\n\nRMB &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r1,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r2){\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;RMB&lt;/span&gt;(r1.yuan&amp;#43;r2.yuan,r1.jiao&amp;#43;r2.jiao,r1.fen&amp;#43;r2.fen);\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 后置&amp;#43;&amp;#43;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// 操作一次&amp;#43;&amp;#43;将会加1分&lt;/span&gt;\nRMB &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43; (RMB&amp;amp; r1,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;){\n    &lt;span class=\"hljs-function\"&gt;RMB &lt;span class=\"hljs-title\"&gt;temp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(r1)&lt;/span&gt;&lt;/span&gt;;\n    r1.fen &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 前置&amp;#43;&amp;#43;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// 操作一次&amp;#43;&amp;#43;将会加1分&lt;/span&gt;\nRMB &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43; (RMB&amp;amp; r1){\n    r1.fen &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; r1;\n}\n\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt; (ostream &amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; RMB&amp;amp; r1){\n    os&amp;lt;&amp;lt;r1.yuan&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;元&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;r1.jiao&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;角&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;r1.fen&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;分&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["这个应该具体从哪个地方开始思考，怎样才是正确的写法呀(语言-c++)", [".请定义一个人民币类RMB，包含私有成员元、角、分，请用友元函数重载运算符“+”、“++”、<<，以对类对象进行运算，并按“10元5角3分”字样输出对应类对象的结果。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是因为你加了名称空间&amp;#xff0c;相当于加了作用域。Array成员函数的实现&amp;#xff0c;以及友元函数的实现&amp;#xff0c;同样需要放在Array类所在的名称空间内。&lt;/p&gt;\n\n&lt;p&gt;把rnyarray.cpp里的实现代码放在名称空间内即可&amp;#xff1a;&lt;br /&gt;\n &lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;namespace ARRAY{\n\n ...\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++友元函数不能访问私有变量问题", ["刚刚学习c++的友元函数以及运算符的重载，按照c++primerplus写了complex复数类，通过友元函数重载了<<运算符没问题，但是", "\n\n", "我自己在写Array类时重载<<却报错了，友元函数不能访问类的私有数据了。不知道为啥，求大佬指教，萌新虚心学习", "\n\n", "下面是图片", "\n\n", "先是complex类的", "\n\n", "\n\n", "没有问题，也能运行", "\n\n", "下面是我的Array类，", "\n\n", "\n\n", "下面是报错信息", "\n\n", "\n\n", "就不能访问私有变量length和指针p", "\n\n", "求da'lao'zhi'jiao"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdexcept&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iomanip&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Costmap2D&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size_type;\n    &lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; value_type;\n\n    &lt;span class=\"hljs-built_in\"&gt;Costmap2D&lt;/span&gt;() {}\n\n    &lt;span class=\"hljs-built_in\"&gt;Costmap2D&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; std::initializer_list&amp;lt;std::initializer_list&amp;lt;value_type&amp;gt;&amp;gt; &amp;amp;lists)\n    {\n        _numRows &amp;#61; lists.&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;();\n        size_type maxNumColumns &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; list : lists)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (list.&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;() &amp;gt; maxNumColumns)\n                maxNumColumns &amp;#61; list.&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;();\n        }\n        _numColumns &amp;#61; maxNumColumns;\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; size &amp;#61; _numRows * _numColumns;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (size &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            _data &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;value_type&lt;/span&gt;(size);\n            std::&lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(_data, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, size);\n            size_type i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; list : lists)\n            {\n                size_type j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; v : list)\n                {\n                    _data[i * _numColumns &amp;#43; j] &amp;#61; v;\n                    j&amp;#43;&amp;#43;;\n                }\n                i&amp;#43;&amp;#43;;\n            }\n        }\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;Costmap2D&lt;/span&gt;(size_type numRows, size_type numColumns,\n              value_type resolution, value_type defaultValue &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        : _numRows(numRows), _numColumns(numColumns), _resolution(resolution),\n          _defaultValue(defaultValue)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; size &amp;#61; numRows * numColumns;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (size &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            _data &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[size];\n            std::&lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(_data, defaultValue, size);\n        }\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;Costmap2D&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Costmap2D &amp;amp;other)\n        : _numRows(other._numRows), _numColumns(other._numColumns),\n          _resolution(other._resolution), _defaultValue(other._defaultValue)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; size &amp;#61; _numRows * _numColumns;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (size &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            _data &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; value_type[size];\n            std::&lt;span class=\"hljs-built_in\"&gt;memcpy&lt;/span&gt;(_data, other._data, size);\n        }\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;Costmap2D&lt;/span&gt;(Costmap2D &amp;amp;&amp;amp;other)\n        : _numRows(other._numRows), _numColumns(other._numColumns),\n          _data(other._data), _resolution(other._resolution),\n          _defaultValue(other._defaultValue)\n    {\n        other._numRows &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        other._numColumns &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        other._data &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n    }\n\n    ~&lt;span class=\"hljs-built_in\"&gt;Costmap2D&lt;/span&gt;()\n    {\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] _data;\n    }\n\n    Costmap2D &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Costmap2D &amp;amp;other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; &amp;#61;&amp;#61; &amp;amp;other)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n\n        _numRows &amp;#61; other._numRows;\n        _numColumns &amp;#61; other._numColumns;\n        _resolution &amp;#61; other._resolution;\n        _defaultValue &amp;#61; other._defaultValue;\n\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] _data;\n        _data &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n\n        &lt;span class=\"hljs-keyword\"&gt;auto&lt;/span&gt; size &amp;#61; _numRows * _numColumns;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (size &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            _data &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; value_type[size];\n            std::&lt;span class=\"hljs-built_in\"&gt;memcpy&lt;/span&gt;(_data, other._data, size);\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    Costmap2D &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(Costmap2D &amp;amp;&amp;amp;other)\n    {\n        _numRows &amp;#61; other._numRows;\n        _numColumns &amp;#61; other._numColumns;\n        _resolution &amp;#61; other._resolution;\n        _defaultValue &amp;#61; other._defaultValue;\n        _data &amp;#61; other._data;\n        other._numRows &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        other._numColumns &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        other._data &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;size_type &lt;span class=\"hljs-title\"&gt;numRows&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _numRows; }\n    &lt;span class=\"hljs-function\"&gt;size_type &lt;span class=\"hljs-title\"&gt;numColumns&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _numColumns; }\n    &lt;span class=\"hljs-function\"&gt;value_type &lt;span class=\"hljs-title\"&gt;resolution&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _resolution; }\n    &lt;span class=\"hljs-function\"&gt;value_type &lt;span class=\"hljs-title\"&gt;defaultValue&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _defaultValue; }\n\n    &lt;span class=\"hljs-function\"&gt;value_type &lt;span class=\"hljs-title\"&gt;operator&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(size_type i, size_type j)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-built_in\"&gt;assert&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;isEmpty&lt;/span&gt;());\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _data[i * _numColumns &amp;#43; j];\n    }\n\n    &lt;span class=\"hljs-function\"&gt;value_type &amp;amp;&lt;span class=\"hljs-title\"&gt;operator&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(size_type i, size_type j)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-built_in\"&gt;assert&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;isEmpty&lt;/span&gt;());\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _data[i * _numColumns &amp;#43; j];\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;isEmpty&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; _numRows &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; || _numColumns &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    size_type _numRows &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    size_type _numColumns &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    value_type *_data &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n    value_type _resolution &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    value_type _defaultValue &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n};\n\nstd::ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream &amp;amp;os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Costmap2D &amp;amp;map)\n{\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Rows: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; map.&lt;span class=\"hljs-built_in\"&gt;numRows&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Columns: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; map.&lt;span class=\"hljs-built_in\"&gt;numColumns&lt;/span&gt;() &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Resolution: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt;(map.&lt;span class=\"hljs-built_in\"&gt;resolution&lt;/span&gt;()) &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Default Value: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt;(map.&lt;span class=\"hljs-built_in\"&gt;defaultValue&lt;/span&gt;()) &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;Data:\\n&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; map.&lt;span class=\"hljs-built_in\"&gt;numRows&lt;/span&gt;(); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; map.&lt;span class=\"hljs-built_in\"&gt;numColumns&lt;/span&gt;(); j&amp;#43;&amp;#43;)\n        {\n            os &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; std::uppercase &amp;lt;&amp;lt; std::&lt;span class=\"hljs-built_in\"&gt;setw&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; std::&lt;span class=\"hljs-built_in\"&gt;setfill&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;)\n               &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt;(&lt;span class=\"hljs-built_in\"&gt;map&lt;/span&gt;(i, j)) &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n        }\n        os &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Costmap2D map &amp;#61; {&lt;!-- --&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;200&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;201&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;202&lt;/span&gt;}, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;}};\n    std::cout &amp;lt;&amp;lt; map;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;$ g&amp;#43;&amp;#43; -Wall main.cpp\n$ ./a.out\nRows&lt;/span&gt;&lt;span class=\"hljs-punctuation\"&gt;:&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Columns&lt;/span&gt;&lt;span class=\"hljs-punctuation\"&gt;:&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;3&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Resolution&lt;/span&gt;&lt;span class=\"hljs-punctuation\"&gt;:&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;1&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Default Value&lt;/span&gt;&lt;span class=\"hljs-punctuation\"&gt;:&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;0&lt;/span&gt;\n&lt;span class=\"hljs-attribute\"&gt;Data&lt;/span&gt;&lt;span class=\"hljs-punctuation\"&gt;:&lt;/span&gt;\n01 02 03 \n04 05 06 \nC8 C9 CA \nFF 00 00 \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["c++创建类构建地图雏形", ["●构建一个名为Costmap2D的类要求包含成员变量", "1存储地图数据的容器要求使用指针要求可以容纳unsigned int * unsigned int大小的地图", "2地图分辨率 即一个像素是多少米", "\n", "3地图上每一个点的默认值", "\n", "4地图上每一个点是unsigned char类型的数据", "\n", "5需要提供类的构造函数(使用初值列)析构函数,拷贝构造函数一定要提供,", "\n", "●需要重载运算符\"=\"和\"<<\" map= ; cout <<map ;"]], "Tag": "程序设计"}
{"Answer": "成员函数能够访问其所属的类中的变量（无论是私有还是公有），注意，不是其所属对象中的变量", "Konwledge_Point": "运算符重载", "Question": ["C++新手问一个在函数中关于可见性的小问题", ["是一个书上看的例子是C++primer plus上的例题，我产生了一点疑问。希望有老鸟帮助", "\n![", "我在后面那个重载运算符中的b的x应该是不可见的呀，为什么这个函数通过了编译？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;题目不全&amp;#xff0c;成员变量有哪些也不知道啊&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["利用c++解决类问题", ["定义一个类IPhone，公有继承CellPhone和Player。包含成员变量：WeChat类对象，size和color。成员函数：构造函数，初始化成员变量，打印输出“IPhone构造函数被调用啦”；析构函数，打印输出“IPhone析构函数被调用啦”；覆盖call函数，打印输出“IPhone打电话给家人”；覆盖play函数，打印输出“宝剑锋从磨砺出，梅花香自苦寒来”；重载输出运算符，输出所有的成员变量（包含继承来的成员变量）"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code&gt;package com.csdn;\n\n&lt;span class=\"hljs-comment\"&gt;/**\n * \n * &amp;#64;作者:Roc-xb\n * &amp;#64;联系QQ:327844761\n * &amp;#64;微信公众号&amp;#xff1a;ewbang\n * &amp;#64;若有帮助&amp;#xff0c;望采纳&amp;#xff0c;谢谢&amp;#xff01;\n */&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Demo&lt;/span&gt; {\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getMax&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; c&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a &amp;gt; b ? (a &amp;gt; c) ? a : c : (b &amp;gt; c) ? b : c;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getMax&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; a, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; b, &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; c&lt;/span&gt;)&lt;/span&gt; {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a &amp;gt; b ? (a &amp;gt; c) ? a : c : (b &amp;gt; c) ? b : c;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;String[] args&lt;/span&gt;)&lt;/span&gt; {\n        Demo demo &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Demo();\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; max1 &amp;#61; demo.getMax(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;);\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(max1);\n        &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; max2 &amp;#61; demo.getMax(&lt;span class=\"hljs-number\"&gt;10.0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;20.0&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;30.0&lt;/span&gt;);\n        System.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(max2);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["java里打印最大值", ["请按照以下要求设计一个有俩个重载方法的类Demo:\n1.写一个方法获取三个int类型中最大的值，三个int类型数据分别为10、20、30.\n2.写一个方法获取三个double类型数据中最大的值，三个double类型数据分别为10.0.,20.0,30.0。\n3.方法名是getMax（），并要求方法只有一条语句。（用三元运算符嵌套）"]], "Tag": "程序设计"}
{"Answer": "友元函数只能访问this，不能访问另一个对象", "Konwledge_Point": "运算符重载", "Question": ["关于友元函数的小问题", ["#include  //声明类Point", "\nusing namespace std;", "\nclass Point", "\n{", "\npublic:", "\n   Point(float x=0,float y=0);  //有默认参数的构造函数", "\n   void setPoint(float ,float);  //设置坐标值", "\n   float getX( )const {return x;}  //读x坐标", "\n   float getY( )const {return y;}  //读y坐标", "\n   friend ostream& operator<<(ostream &,const Point &); ", "\n     //重载运算符“<<”", "\nprotected:  //受保护成员", "\n   float x, y;", "\n};", "\n//下面定义Point类的成员函数", "\nPoint::Point(float a,float b) //Point的构造函数", "\n{  //对x,y初始化", "\n   x=a;", "\n   y=b;", "\n}", "\nvoid Point::setPoint(float a,float b) //设置x和y的坐标值", "\n{  //为x,y赋新值", "\n   x=a;", "\n   y=b;", "\n}", "\n//重载运算符“<<”，使之能输出点的坐标", "\nostream& operator<<(ostream &cout, const Point &p)", "\n{", "\n   cout<<\"[\"<<p.x<<\",\"<<p.y<<\"]\"<<endl;", "\n   return cout;", "\n}", "\nclass Circle:public Point  //circle是Point类的公用派生类", "\n{", "\npublic:", "\n   Circle(float x=0,float y=0,float r=0);  //构造函数", "\n   void setRadius(float );  //设置半径值", "\n   float getRadius( )const;  //读取半径值", "\n   float area ( )const;  //计算圆面积", "\n   friend ostream &operator <<(ostream &,const Circle &);  //重载运算符“<<”", "\nprivate:", "\n   float radius;", "\n};", "\n//定义构造函数，对圆心坐标和半径初始化", "\nCircle::Circle(float a,float b,float r):Point(a,b),radius(r){}", "\n//设置半径值", "\nvoid Circle::setRadius(float r){radius=r;}", "\n//读取半径值", "\nfloat Circle::getRadius( )const {return radius;}", "\n//计算圆面积", "\nfloat Circle::area( )const", "\n{", "\n   return 3.14159*radius*radius;", "\n}", "\n//重载运算符“<<”，使之按规定的形式输出圆的信息", "\nostream &operator <<(ostream &output,const Circle &c)", "\n{", "\n   output<<\"Center=[\"<<c.x<<\",\"<<c.y<<\"],r=\"<<c.radius<<\",area=\"<<c.area( )<<endl;", "\n   return output;", "\n}", "\nint main( )", "\n{", "\n   Circle c(3.5,6.4,5.2);  //建立Circle类对象c，并给定圆心坐标和半径", "\n   cout<<\"original circle:\\nx=\"<<c.getX()<<\", y=\"<<c.getY()<<\", r=\"<<c.getRadius( )<<\", area=\"<<c.area( )<<endl;  //输出圆心坐标、半径和面积", "\n   c.setRadius(7.5);  //设置半径值", "\n   c.setPoint(5,5);  //设置圆心坐标值x,y", "\n   cout<<\"new circle:\\n\"<<c;  //用重载运算符“<<”输出圆对象的信息", "\n   Point &pRef=c;  //pRef是Point类的引用变量，被c初始化", "\n   cout<<\"pRef:\"<<pRef;  //输出pRef的信息", "\n   return 0;", "\n}", "\n\n", "报错内容是（友元函数不能访问保护成员？？？）", "\nG:\\c_files\\try_2.cpp(506) : error C2248: 'x' : cannot access protected member declared in class 'Point'", "\n        G:\\c_files\\try_2.cpp(490) : see declaration of 'x'", "\nG:\\c_files\\try_2.cpp(506) : error C2248: 'y' : cannot access protected member declared in class 'Point'", "\n        G:\\c_files\\try_2.cpp(490) : see declaration of 'y'", "\nG:\\c_files\\try_2.cpp(534) : error C2248: 'x' : cannot access protected member declared in class 'Point'", "\n        G:\\c_files\\try_2.cpp(490) : see declaration of 'x'", "\nG:\\c_files\\try_2.cpp(534) : error C2248: 'y' : cannot access protected member declared in class 'Point'", "\n        G:\\c_files\\try_2.cpp(490) : see declaration of 'y'", "\nG:\\c_files\\try_2.cpp(534) : error C2248: 'radius' : cannot access private member declared in class 'Circle'", "\n        G:\\c_files\\try_2.cpp(518) : see declaration of 'radius'", "\nG:\\c_files\\try_2.cpp(539) : warning C4305: 'argument' : truncation from 'const double' to 'float'", "\nG:\\c_files\\try_2.cpp(539) : warning C4305: 'argument' : truncation from 'const double' to 'float'", "\nG:\\c_files\\try_2.cpp(545) : error C2593: 'operator <<' is ambiguous", "\n执行 cl.exe 时出错.", "\n另有，将point类中重载函数写成inline就不报错了，为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码及运行结果如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/783363338746126.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Point&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Point&amp;amp; p);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; istream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream&amp;amp; is, Point&amp;amp; p);\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Point&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x0 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; y0 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        x &amp;#61; x0; y&amp;#61;y0;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Point&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Point&amp;amp; p) {\n        x &amp;#61; p.x;\n        y &amp;#61; p.y;\n    }\n    Point &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Point&amp;amp; pt) {\n        Point pp;\n        pp.x &amp;#61; x - pt.x;\n        pp.y &amp;#61; y - pt.y;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; pp;\n    }\n    Point &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Point&amp;amp; pt) {\n        Point pp;\n        pp.x &amp;#61; x &amp;#43; pt.x;\n        pp.y &amp;#61; y &amp;#43; pt.y;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; pp;\n    }\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; ^(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Point&amp;amp; pt) {\n        &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; t &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sqrt&lt;/span&gt;((x-pt.x) * (x-pt.x) &amp;#43; (y-pt.y) * (y-pt.y));\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; t;\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; x, y;\n};\n\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; os, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Point&amp;amp; p) {\n    os &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p.x &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p.y&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\nistream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream&amp;amp; is, Point&amp;amp; p) {\n    is &amp;gt;&amp;gt; p.x &amp;gt;&amp;gt; p.y;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; is;\n}\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Point &lt;span class=\"hljs-title\"&gt;p1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;-3.5&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Point &lt;span class=\"hljs-title\"&gt;p2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;-1.5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    Point p3 &amp;#61; p1 &amp;#43; p2;\n    cout &amp;lt;&amp;lt;p1 &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p2 &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p3 &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; t &amp;#61; p1 ^ p2;\n    cout &amp;lt;&amp;lt;p1 &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;^&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p2 &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["求一道关于类和对象的题", ["自定义如下形式的 Point 类，其对象表示平面上的一个点(x, y)，通过类成员方式对该类重载二目运算符“十”和“^”，用来求出两个对象的和以及两个对象(平面点)的距离。各运算符的使用含义(运算结果）如下所示：", "(1.2,-3.5)+(-1.5,6)=(-0.3,2.5)", "(1.2,-3.5)^（-1.5,6)＝9.87623", "在类外定义类中已声明的函数，并编写主函数，验证所定义函数的正确性。", "class Point {", "friend ostream & operator<((ostream& os, const Point & p):", "friend istream & operator>>(istream & is, Point&p);", "public:", "Point (double x0 = 0, double y0 =0){x = x0:y = y0;)", "Point(const Point & p);", "Point operator＋(const Point & pt);", "double operator^(const Point & pt):", "private:", "double x,y;", "};"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;大概改了下\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Money&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n        &lt;span class=\"hljs-built_in\"&gt;Money&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; A&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; B&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; C&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        {\n            yuan&amp;#61;A;\n            jiao&amp;#61;B;\n            fen&amp;#61;C;\n            format();\n        }\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;format&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fen&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;)\n            {\n                jiao&amp;#43;&amp;#61;fen/&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n                fen%&amp;#61;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(jiao&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;)\n            {\n                yuan&amp;#43;&amp;#61;jiao/&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n                jiao%&amp;#61;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n            }\n        }\n\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n        &lt;/span&gt;{\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(yuan!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                cout &amp;lt;&amp;lt; yuan &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;元&amp;#34;&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(jiao!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                cout &amp;lt;&amp;lt; jiao &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;角&amp;#34;&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fen!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                cout &amp;lt;&amp;lt; fen &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;分&amp;#34;&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; endl;\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Money &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Money &amp;amp;a,Money &amp;amp;b)\n        {\n            Money c;\n            c.yuan&amp;#61;a.yuan&amp;#43;b.yuan;\n            c.jiao&amp;#61;a.jiao&amp;#43;b.jiao;\n            c.fen&amp;#61;a.fen&amp;#43;b.fen;\n            c.format();\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Money &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(Money &amp;amp;a,Money &amp;amp;b)\n        {\n            Money c;\n            c.fen&amp;#61;(a.yuan-b.yuan)*&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;&amp;#43;(a.jiao-b.jiao)*&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;&amp;#43;(a.fen-b.fen);\n            c.format();\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;(Money &amp;amp;a,Money &amp;amp;b)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.yuan!&amp;#61;b.yuan) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.yuan &amp;gt; b.yuan;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.jiao!&amp;#61;b.jiao) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.jiao &amp;gt; b.jiao;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.fen!&amp;#61;b.fen) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.fen &amp;gt; b.fen;\n\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;(Money &amp;amp;a,Money &amp;amp;b)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.yuan!&amp;#61;b.yuan) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.yuan &amp;lt; b.yuan;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.jiao!&amp;#61;b.jiao) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.jiao &amp;lt; b.jiao;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.fen!&amp;#61;b.fen) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a.fen &amp;lt; b.fen;\n\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-comment\"&gt;////&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream &amp;amp;o,Money &amp;amp;a)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.yuan!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                o &amp;lt;&amp;lt; a.yuan &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;元&amp;#34;&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.jiao!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                o &amp;lt;&amp;lt; a.jiao &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;角&amp;#34;&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a.fen!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                o &amp;lt;&amp;lt; a.fen &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;分&amp;#34;&lt;/span&gt;;\n\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; o;\n        }\n\n        &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; istream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream &amp;amp;i,Money &amp;amp;a)\n        {\n            i&amp;gt;&amp;gt;a.yuan&amp;gt;&amp;gt;a.jiao&amp;gt;&amp;gt;a.fen;\n            a.format();\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n        }\n        &lt;span class=\"hljs-comment\"&gt;////&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; yuan, jiao, fen;\n};\n\n&lt;span class=\"hljs-comment\"&gt;/*\n\n12 55 44\n2 8 7\n\n//*/&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Money a,b,c;\n    cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;\n    cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl;\n    a.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n\n    c&amp;#61;a&amp;#43;b;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;两数额之和为: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;\n\n    c&amp;#61;a-b;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;两数额之差为: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;\n\n    c&amp;#61;(a&amp;gt;b)?a:b;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;数额较大的为: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;\n\n    c&amp;#61;(a&amp;lt;b)?a:b;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;数额较小的为: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/24485029445612.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#c++#的问题：问题遇到的现象和发生背景", ["问题遇到的现象和发生背", "\n", "代码跑不动,总是声明不了,(顺便解答一下运算符<<重载怎么写)", "\n", "操作环境、软件版本等信息", "\n", "dev-c++", "\n", "尝试过的解决方法", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<cmath>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Mony", "//定义Mony基类 ", "\n{\n    ", "public", ":\n        ", "Mony", "(", "int", " A=", "0", ",", "int", " B=", "0", ",", "int", " C=", "0", ")\n        {\n            yuan=A;\n            jiao=B;\n            fen=C; \n            ", "int", " x,y,z;\n        x=a.yuan*", "100", "+a.jiao*", "10", "+a.fen;\n        y=b.yuan*", "100", "+a.jiao*", "10", "+a.fen;\n        } \n    ", "friend", " Mony ", "operator", "+(Mony&,Mony&b)\n    {\n        Mony c;\n        z=x+y;\n        c.yuan=z/", "100", ";\n        c.jiao=(z-c.yuan*", "100", ")/", "10", ";\n        c.fen=z%", "10", ";\n        ", "return", " c;    \n    }\n    ", "friend", " Mony ", "operator", "-(Mony&,Mony&b)\n    {\n        Mony d;\n        \n        z=x-y;\n        ", "if", "(", "z", "<", "0", ")\n        {\n            z=-z;\n        }\n        d.yuan=z/", "100", ";\n        d.jiao=(z-c.yuan*", "100", ")/", "10", ";\n        d.fen=z%", "10", ";\n        ", "return", " d;    \n    }\n    ", "friend", " Mony ", "operator", ">(Mony&,Mony&b)\n    {\n        Mony e;\n    \n        ", "if", "(x>=y)\n        {\n            e=a;\n        }\n        ", "else", "\n        {\n            e=b;\n        }\n        ", "return", " e;\n    }\n    ", "friend", " Mony ", "operator", "<(Mony&,Mony&b)\n    {\n        Mony f;\n        \n        ", "if", "(x<y)\n        {\n            f=a;\n        }\n        ", "else", "\n        {\n            f=b;\n        }\n        ", "return", " f;\n    }\n", "int", " yuan, jiao, fen; \n};\n", "void", " ", "display", "(Mony&a,Mony&b)", "\n", "{\n    cout<<", "\"数额较大的为: \"", "<<e.yuan<<", "\".\"", "<<e.jiao<<e.fen<<endl;\n    cout<<", "\"数额较小的为: \"", "<<f.yuan<<", "\".\"", "<<f.jiao<<f.fen<<endl;\n    cout<<", "\"两数额之和为: \"", "<<c.yuan<<", "\".\"", "<<c.jiao<<c.fen<<endl;\n    cout<<", "\"两数额之差为: \"", "<<d.yuan<<", "\".\"", "<<d.jiao<<d.fen<<endl; \n} \n", "int", " ", "main", "()", "\n", "{\n    ", "int", " A,B,C,D,E,F;\n    cin>>A>>B>>C>>D>>E>>F;\n    ", "Mony ", "a", "(A,B,C)", ",", "b", "(D,F,E)", ";\n    ", "display", "(a,b)\n    ", "return", " ", "0", ";\n}\n\n", "\n", "我想要达到的结果", "\n", "问题描述】设计一个Money类，能够实现两个Money的-（减） 、>运算。", "\n", "【程序必做项】", "\n", "1- 该类包含三个属性元、角、分。", "\n", "2- 至少定义一个构造函数；", "\n", "3-  重载Money类两个对象之间的 +、-、>、<运算；", "\n", "4- 定义显示输出函数；", "\n", "5- 自定义main函数，完成以上功能的测试", "\n", "【程序选做项】", "\n", "1- 重载++ 运算符", "\n", "2- 重载<< 与>>"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://www.cnblogs.com/hchacha/p/7217404.html\" id=\"textarea_1635677595411_1635677641287_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;c&amp;#43;&amp;#43;primer&amp;#xff0c;自定义一个复数类 - hchacha - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;一些问题&amp;#xff1a; 假设自定义了一个Complex类 Q:为什么需要自定义默认构造函数&amp;#xff1f; A:相比需要显示提供参数的constructor&amp;#xff0c;前者不需要用户提供初始值&amp;#xff0c;如Complex s&amp;#xff0c;如果要用vector&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/hchacha/p/7217404.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["本关任务：设计一个复数类并实现复数的三种运算。", ["在右侧编辑器中的Begin-End之间补充代码，设计一个复数类（ Complex ），该类有两个成员变量和两个函数（成员变量访问性为私有，函数为公有），并重载 ，-，*运算符，实现复数的加、减、乘运算，具体要求如下：  成员变量：float real，代表实部。  成员变量：float image，代表虚部。  构造函数：Complex(float r,float i)，用两个参数设置 real 和 image 成员变量的值。  输出复数函数：void Print()，输出格式为：实部  /- 虚部i，比如1 1i，0−5i。  测试说明 平台会对你编写的代码进行测试，比对你输出的数值与实际正确数值，只有所有数据全部计算正确才能通过测试：  测试输入：1 1 2 2（数据分为两组，前两个和后两个数分别表示一个复数 c1 和 c2，即c1=1 1i，c2=2 2i） 预期输出：  c1 = 1 1i c2 = 2 2i c1   c2 = 3 3i c1 - c2 = -1-1i c1 * c2 = 0 4i"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;_First, _Last&amp;#xff0c; _UFirst, _ULast都是迭代器&lt;br /&gt;这是函数模板&amp;#xff0c;具体的参数类型根据传入参数类型来确定。比如&amp;#xff0c;如果第三个参数传入的是函数名&amp;#xff0c;那么_Pred就是指向这个函数的函数指针&amp;#xff1b;如果第三个参数传入的是函数对象&amp;#xff0c;那么_Pred就是函数对象。不管是函数指针&amp;#xff0c;还是函数对象&amp;#xff0c;它们都必须满足这样一个concept&amp;#xff1a;即表达式_Pred(x)合法&amp;#xff0c;x的类型是_UFirst所指的元素类型&amp;#xff0c;返回值能自动转换为bool类型。否则的话编译就会报错。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++ STL中谓词是如何实现的", ["我不知道我问题问的对不对，就是 算法头文件里面 有个 count_if  函数 有个参数 就是传 一个 对象 或者 函数 ， 可以根据 所传的 对象 或者函数的 规则 进行搜索", "我想知道 是怎么实现的  既可以 放 函数对象 也可以 放函数。", "\n", "\n", "就这里 看不懂 ，", "\n", "\n", "if", " (", "_Pred", "(*", "_UFirst", "))\n\n这里 ", "_Pred", " 是个 模版定义的 类型啊  如果 我们传的 是一个 对象类 那么 我理解是 调用了 对象 重载的括号()运算符 \n                                                          如果 传个函数 是怎么 调用的？\n这个 * ", "_UFirst", "  是一个函数 返回的  这个函数 跟进去 我就更看不懂了  一堆自定义的类型 \n", "\n", "我想知道 是怎么实现的  既可以 放 函数对象 也可以 放函数。", "设计模式 是不是 有这里的知识 啊？"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/qq_46615502/article/details/106675043", "Konwledge_Point": "运算符重载", "Question": ["模块化实现学籍管理，图是运行结果图，该怎么实现", ["\n1程序说明", "\n本程序是一个双向链表的典型示范程序，双向链表的结点为模板类型，在示范程序中，模板的结点为整型。", "\n程序设计要求", "\n（1）将模板类型改为学生类class information,成员数据有：姓名、家庭住址、学号、成绩、性别等，成员函数有：构造、析构、按姓名比较、按学号比较等，并重载输入 、输出运算符。", "\n（2）完善双向链表类的成员函数，增加按结点内容（姓名、学号）排序的成员函数，增加通过查找结点内容（姓名、学号）删除指定结点的成员函数；增加可以通过结点部分内容（姓名、学号）查找并输出结点全部内容的成员函数。", "\n（3）增加双向链表对文件的操作，可以从数据文件中读取数据输入至双向链表，并将新的操作结果保存在数据文件中。", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "因为(this-&gt;x - p2.x) * (this-&gt;x - p2.x) - (this-&gt;y - p2.y) * (this-&gt;y - p2.y)是负数，开根号的时候出错了。\r\n改成sqrt(fabs((this-&gt;x - p2.x) * (this-&gt;x - p2.x) -\r\n(this-&gt;y - p2.y) * (this-&gt;y - p2.y)));", "Konwledge_Point": "运算符重载", "Question": ["请问出现这个是什么意思", ["\n作业题：自定义point类，其对象表示平面上的一个点(x,y)，并通过类成员方式对该类重载二目运算符“+”和“^”，用来求出两个对象的和以及两个对象（平面点）的距离。各运算符的使用含义（运算结果）如下所示：", "\n(1.2, -3.5) + (-1.5, 6) = (-0.3, 2.5)；", "\n(1.2, -3.5) ^ (-1.5, 6) = 9.87623。", "\n编写主函数，说明类对象，而后通过类对象实现所定义的相关运算", "\n\n", "#include", "\n#include", "\nusing namespace std;", "\nclass ponit", "\n{", "\nprivate:", "\n    double x;", "\n    double y;", "\npublic:", "\n    ponit() ", "\n    {", "\n        double x = y = 0;", "\n    }", "\n    ponit(double x_, double y_)", "\n    {", "\n        x = x_;", "\n        y = y_;", "\n    }", "\n    void display()", "\n    {", "\n        cout << \"(\" << x << \",\" << y << \")\" << endl;", "\n    }", "\n    friend ponit operator +(ponit& p1, ponit& p2);", "\n    double operator ^( ponit& p2)", "\n    {", "\n        double distance = sqrt((this->x - p2.x) * (this->x - p2.x) -", "\n        (this->y - p2.y) * (this->y - p2.y));", "\n        return distance;", "\n    }", "\n};", "\nponit operator +(ponit& p1, ponit &p2)", "\n{", "\n    return ponit(p1.x + p2.x, p1.y + p2.y);", "\n}", "\n\n", "int main()", "\n{", "\n    ponit p1(8, 8), p2(5, 4), p3;", "\n    p3 = p1 + p2;", "\n    p3.display();", "\n    double distance = p1.operator^(p2);", "\n    cout << distance << endl;", "\n    return 0;", "\n}", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-python\"&gt;class Vector3:\n    # 构造方法&amp;#xff0c;初始化&amp;#xff0c;定义向量坐标\n    def __init__(self, x, y, z):\n        self.__x &amp;#61; x\n        self.__y &amp;#61; y\n        self.__z &amp;#61; z\n    # 向量与一个向量相加&amp;#xff0c;对应分量相加&amp;#xff0c;返回新向量\n    def __add__(self, other):\n        return Vector3(self.__x&amp;#43;other.__x,self.__y&amp;#43;other.__y,self.__z&amp;#43;other.__z)\n\n    # 减去另一个向量&amp;#xff0c;对应分量相减&amp;#xff0c;返回新向量\n    def __sub__(self, other):\n        return Vector3(self.__x - other.__x, self.__y - other.__y, self.__z - other.__z)\n    # 向量与一个数字相乘&amp;#xff0c;各分量乘以同一个数字&amp;#xff0c;返回新向量\n    def __matmul__(self, other):\n        return Vector3(self.__x * other.__x, self.__y * other.__y, self.__z * other.__z)\n    # 向量除以一个数字&amp;#xff0c;各分量除以同一个数字&amp;#xff0c;返回新向量\n    def __truediv__(self, n):\n        return Vector3(self.__x / n.__x, self.__y / n.__y, self.__z / n.__z)\n    # 查看向量长度&amp;#xff0c;所有分量平方和的平方根\n    &amp;#64;property\n    def length(self):\n        l_s &amp;#61; self.__x ** 2 &amp;#43; self.__y ** 2 &amp;#43; self.__z ** 2\n        l &amp;#61; l_s ** (1 / 2)\n        return l\n    def __str__(self):\n        s_sum &amp;#61; self.__x**2 &amp;#43; self.__y**2 &amp;#43;self.__z**2\n        s_sum_ &amp;#61; s_sum**(1/2)\n        print(f&amp;#39;平方和&amp;#xff1a;{s_sum} 平方根&amp;#xff1a;{s_sum_}&amp;#39;)\n# 测试代码\nv1, v2 &amp;#61; input().split(&amp;#39;;&amp;#39;)\nv1 &amp;#61; Vector3(*eval(v1))\nv2 &amp;#61; Vector3(*eval(v2))\nprint(v1 &amp;#43; v2)\nprint(v1 - v2)\nprint(v1 * 3)\nprint(v2 / 2)\nprint(&amp;#39;向量长度&amp;#xff1a;&amp;#39;, v1.length)&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;如有帮助请采纳&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["python 代码复用 类与对象", ["3维向量类的运算重载", "\n描述", "\n编写程序，实现一个3维向量类Vector3，定义相应的特殊（保留）方法实现：‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‪‬", "\n\n", "两个类对象之间的加、减运算（要求支持运算符+、-）", "\n类对象与标量的乘、除运算（要求支持运算符*、/）", "\n向量长度的计算（要求使用@property装饰器，并保留2位小数）", "\n提示：1）输入的两个向量以分号隔开；2）请参照类的封装与方法重载认真思考如何编写该类。", "\n完成下面 7 处填空", "\n\n", "class Vector3:", "\n    # 构造方法，初始化，定义向量坐标", "\n    def __init__(self, x, y, z):", "\n        self.__x = x", "\n        self.__y = y", "\n        self.__z = z", "\n\n", "    # 向量与一个向量相加，对应分量相加，返回新向量", "\n点击在此输入一行或多行代码", "\n\n", "    # 减去另一个向量，对应分量相减，返回新向量", "\n点击在此输入一行或多行代码", "\n\n", "    # 向量与一个数字相乘，各分量乘以同一个数字，返回新向量", "\n点击在此输入一行或多行代码", "\n\n", "    # 向量除以一个数字，各分量除以同一个数字，返回新向量", "\n    def __truediv__(self, n):", "\n点击在此输入一行或多行代码", "\n\n", "    # 查看向量长度，所有分量平方和的平方根", "\n点击在此输入一行或多行代码", "\n    def length(self):", "\n点击在此输入一行或多行代码", "\n\n", "    def __str__(self):", "\n点击在此输入一行或多行代码", "\n\n", "# 测试代码", "\nv1, v2 = input().split(';') ", "\nv1 = Vector3(*eval(v1))", "\nv2 = Vector3(*eval(v2))", "\nprint(v1 + v2)", "\nprint(v1 - v2)", "\nprint(v1 * 3)", "\nprint(v2 / 2)", "\nprint('向量长度：', v1.length)"]], "Tag": "程序设计"}
{"Answer": "```\r\n template&lt;class T&gt;\r\nVector&lt;T&gt;::Vector(int sz, T t(int s))\r\n这个构造函数第二个参数是T，不是Vector&lt;T&gt;\r\n但是你调用的时候传了Vector\r\n```", "Konwledge_Point": "运算符重载", "Question": ["简单重写stl里vector的构造函数 ", ["#include", "\n#include", "\n#include", "\nusing namespace std;", "\n\n", "template", "\nclass Vector", "\n{", "\nprivate: ", "\n    int size; ", "\n    T* list;", "\npublic: ", "\n    Vector(int sz); ", "\n    Vector(int sz, T t(int s)); ", "\n    ~Vector(){ delete[] list; }", "\n    T& operator ", ";", "\n};", "\n\n", "//构造函数", "\ntemplate", "\nVector::Vector(int sz)", "\n{ ", "\n    size = sz;", "\n    list = new T [size];", "\n}", "\n\n", "//构造函数", "\ntemplate", "\nVector::Vector(int sz, T t(int s))", "\n{ ", "\n    size = sz; ", "\n    list = new T [size]; ", "\n    for(int i=0; i<size; i++)", "\n    {", "\n        list[i] = t; ", "\n    }", "\n}", "\n\n", "//重载运算符[]", "\ntemplateT& Vector::operator ", "\n{", "\n    if( n=size ) ", "\n    {", "\n        cout<<\"OUT OF RANGE\"<<endl; ", "\n        exit(1);", "\n    } ", "\n    else", "\n    {", "\n        return list[n];", "\n    }", "\n}", "\n\n", "int main()", "\n{ ", "\n    Vector< Vector  > v( 10, Vector (5) ); ", "\n    return 0;", "\n} ", "\n\n", "//编译不通过，不知道怎么改，求指点"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个是&amp;#43;运算符重载&amp;#xff0c;目的是通过Box对象相加&amp;#xff0c;实现Box对象的长宽高相加&lt;br /&gt;返回值类型为Box&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-type\"&gt;Box&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(const &lt;span class=\"hljs-type\"&gt;Box&lt;/span&gt;&amp;amp; b)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;返回值为box&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-built_in\"&gt;Box&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;box&lt;/span&gt;&amp;#xff1b;\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;box&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;建议多看看运算符重载这方面的资料&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["问题（C++）：下面代码中成员函数（Box operator+(const Box& b)）为啥可以返回box？", ["问题（C++）：下面代码中成员函数（Box operator+(const Box& b)）为啥可以返回box？", "\n", "class", " ", "Box", "\n{\n", "public", ":\n    ", "double", " ", "getVolume", "(", "void", ")", "\n    ", "{\n        ", "return", " (length*width*height);\n    }\n    ", "void", " ", "setLength", "(", "double", " l)", "\n    ", "{\n        length = l;\n    }\n    ", "void", " ", "setWidth", "(", "double", " w)", "\n    ", "{\n        width = w;\n    }\n    ", "void", " ", "setHeight", "(", "double", " h)", "\n    ", "{\n        height = h;\n    }\n\n    ", "/* 重载+运算符，用于把两个box对象相加 */", "\n    Box ", "operator", "+(", "const", " Box& b)\n    {\n        Box box;\n        box.length = ", "this", "->length + b.length;\n        box.width = ", "this", "->width + b.width;\n        box.height = ", "this", "->height + b.height;\n        ", "return", " box;\n    }\n", "protected", ":\n", "private", ":\n    ", "double", " length;\n    ", "double", " width;\n    ", "double", " height;\n};\n————————————————\n版权声明：本文为CSDN博主「透明水晶」的原创文章，遵循CC ", "4.0", " BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https:", "//blog.csdn.net/I_feige/article/details/120123407", "\n", "\n", "\n  \n    ", "C语言 | C语言函数体返回局部变量地址发生段错误", "\n    \n  ", "CSDN问答为您找到C语言 | C语言函数体返回局部变量地址发生段错误相关问题答案，如果想了解更多关于C语言 | C语言函数体返回局部变量地址发生段错误 c语言、开发语言 技术问题等相关问答，请访问CSDN问答。", "\n  ", "\n  ", "\n    ", "\n      ", "https://ask.csdn.net/questions/7500398", "\n    ", "\n  "]], "Tag": "程序设计"}
{"Answer": "```\r\n// Q1056905.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;iomanip&gt;\r\n#include &lt;string&gt;\r\n#include &lt;array&gt;\r\nusing namespace std;\r\n\r\nclass Birth\r\n{\r\npublic:\r\n    friend istream&amp; operator&gt;&gt;(istream&amp;, Birth&amp;);\r\n    int ageDate; // 以天数形式记录年龄\r\n    int year;\r\n    int mon;\r\n    int date;\r\n};\r\n\r\nistream&amp; operator&gt;&gt;(istream&amp; input, Birth&amp; bir)\r\n{\r\n\tinput.ignore();\r\n    input &gt;&gt; bir.year;\r\n    input.ignore();\r\n    input &gt;&gt; bir.mon;\r\n    input.ignore();\r\n    input &gt;&gt; bir.date;\r\n\treturn input;\r\n}\r\n\r\narray&lt;Birth, 100000&gt; birthArr = {};\r\narray&lt;string, 100000&gt; nameArr = {};\r\n\r\nint main()\r\n{\r\n    int N;\r\n\r\n    cin &gt;&gt; N;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        cin &gt;&gt; nameArr[i];\r\n        cin &gt;&gt; birthArr[i];\r\n\t\tcout &lt;&lt; \"\\n----\" &lt;&lt; nameArr[i] &lt;&lt; \"----\\n\";\r\n    }\r\n    return 0;\r\n}\r\n\r\n```", "Konwledge_Point": "运算符重载", "Question": ["【C++】请教关于循环输入字符串的问题，请看下面代码", ["用C++进行循环输入字符串，代码以及解释如下：", "\n\n", "#include <iostream>\n#include <iomanip>\n#include <array>\nusing namespace std;\n\nclass Birth\n{\npublic:\n    friend istream& operator>>(istream&, Birth&);\n    int ageDate; // 以天数形式记录年龄\n    int year;\n    int mon;\n    int date;\n};\n\nistream& operator>>(istream& input, Birth& bir)\n{\n    input >> setw(4) >> bir.year;\n    input.ignore();\n    input >> setw(2) >> bir.mon;\n    input.ignore();\n    input >> setw(2) >> bir.date;\n}\n\narray<Birth, 100000> birthArr = {};\narray<string, 100000> nameArr = {};\n\nint main()\n{\n    int N;\n\n    cin >> N;\n\n    for (int i = 0; i < N; i++)\n    {\n        cin >> nameArr[i];\n        cin >> birthArr[i];\n\n        cout << \"\\n----\" << nameArr[i] << \"----\\n\";\n    }\n\n    return 0;\n}\n", "\n\n", "程序中，我对 >>运算符 进行了重载。", "\n运行并输入以下内容：", "\n\n", "5\nJohn 2001/05/12\nTom 1814/09/06\nAnn 2121/01/30\nJames 1814/09/05\nSteve 1967/11/20\n", "\n\n", "本来预期所有输入的英文名都能 加入nameArr数组中，但是却得到了下图所示的结果", "\n\n", "\n\n", "这张图表明：名字都没有完全输入nameArr数组中。网上也搜索不到这样的问题解答（可能是我搜索关键字不够精确，因为菜得不得了的我实在不知道该怎么形容这种问题），请问为什么会发生这种情况呢？恳请高人解答。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;mystring B &amp;#61;&amp;#34;C&amp;#43;&amp;#43;&amp;#34;;这么写不对啊。代码中有一些错误&amp;#xff0c;也一起改掉了&amp;#xff0c;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; maxsize &amp;#61; &lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;mystring&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[maxsize];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;mystring&lt;/span&gt;()\n    {\n        len &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        str[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;缺省构造函数&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;mystring&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* s)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; s[i] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        {\n            str[i] &amp;#61; s[i];\n        }\n        str[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        len &amp;#61; i;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;构造函数&amp;#xff08;用C风格字符串初始化&amp;#xff09;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;mystring&lt;/span&gt;(mystring&amp;amp; ms)\n    {\n        len &amp;#61; ms.len;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n        {\n            str[i] &amp;#61; ms.str[i];\n        }\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;拷贝构造函数&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    ~&lt;span class=\"hljs-built_in\"&gt;mystring&lt;/span&gt;()\n    {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;析构函数&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-comment\"&gt;/*void show()\n    {\n        for (int i &amp;#61; 0; i &amp;lt; len; i&amp;#43;&amp;#43;)\n        {\n            cout &amp;lt;&amp;lt; str[i];\n        }\n        cout &amp;lt;&amp;lt; &amp;#39;\\n&amp;#39;;\n    }*/&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt; (ostream&amp;amp; os,mystring &amp;amp; s);\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; mystring &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(mystring&amp;amp; s1, mystring&amp;amp; s2);\n    \n    \n    \n};\n\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;lt;&amp;lt; (ostream&amp;amp; os, mystring&amp;amp; s)\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (; i &amp;lt; s.len &amp;amp;&amp;amp; s.str[i] !&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        cout &amp;lt;&amp;lt; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;)s.str[i];\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\nmystring &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(mystring&amp;amp; s1, mystring&amp;amp; s2)\n{\n    mystring s3;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s1.str[i])\n    {\n        s3.str[k] &amp;#61; s1.str[i];\n        i&amp;#43;&amp;#43;;\n        k&amp;#43;&amp;#43;;\n    }\n    i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s2.str[i])\n    {\n        s3.str[k] &amp;#61; s2.str[i];\n        i&amp;#43;&amp;#43;;\n        k&amp;#43;&amp;#43;;\n    }\n    s3.str[k] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    s3.len &amp;#61; k;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s3;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[&lt;span class=\"hljs-number\"&gt;21&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;mystring &lt;span class=\"hljs-title\"&gt;A&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(str)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;mystring &lt;span class=\"hljs-title\"&gt;B&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;C&amp;#43;&amp;#43;&amp;#34;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    mystring C;\n    C &amp;#61; A;\n    cout &amp;lt;&amp;lt; C;\n    C &amp;#61; A &amp;#43; B;\n    cout &amp;lt;&amp;lt; C;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++改造以下函数以友元函数输出", ["以友元函数的方式重载流插入运算符“<<“:实现字符串的输出", "\n", "#include <iostream>", "\n", "using", " ", "namespace", " std;\n", "const", " ", "int", " maxsize = ", "256", ";\n", "class", " ", "mystring", "\n", "{\n    ", "char", " ", "str", "[maxsize];\n    ", "int", " len;\n", "public", ":\n    mystring()\n    {\n        len = ", "0", ";\n        ", "str", "[", "0", "] = ", "'\\0'", ";\n        cout << ", "\"缺省构造函数\"", " << endl;\n    }\n    mystring(", "char", "* s)\n    {\n        ", "int", " i = ", "0", ";\n        ", "for", " (i = ", "0", "; s[i] != ", "'\\0'", "; i++)\n        {\n            ", "str", "[i] = s[i];\n        }\n        len = i;\n        cout << ", "\"构造函数（用C风格字符串初始化）\"", " << endl;\n    }\n    mystring(mystring& ms)\n    {\n        len = ms.len;\n        ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n        {\n            ", "str", "[i] = ms.", "str", "[i];\n        }\n        cout << ", "\"拷贝构造函数\"", " << endl;\n    }\n    ~mystring()\n    {\n        cout << ", "\"析构函数\"", " << endl;\n    }\n    ", "void", " show()\n    {\n        ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n        {\n            cout << ", "str", "[i];\n        }\n        cout << ", "'\\n'", ";\n    }\n};\n", "int", " main()\n{\n    ", "char", " ", "str", "[", "21", "] = ", "\"Hello\"", ";\n    mystring A(", "str", ");\n    mystring B =", "\"C++\"", ";\n    mystring C;\n    C = A;\n    cout << C;\n    C = A + B;\n    cout << C;\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "解决办法：删除DoubleArray的拷贝构造函数。\r\n\r\n同Xcode警告 **!No matching constructor for initialization of 'Student'**同问啊！为什么说** 没有用于初始化“Student”的匹配构造函数**\r\n![图片说明](https://img-ask.csdn.net/upload/202004/06/1586156736_512025.png)\r\n（宁也是大车埋土学校的？\r\nbtw说一个小问题你的两个student构造函数id没初始化  id(id)", "Konwledge_Point": "运算符重载", "Question": ["为什么会出现[Error] no matching function for call to 'Student::Student()'???", ["#include", "\n#include", "\n#pragma warning(disable:4996)", "\nusing namespace std;", "\n\n", "class Person ", "\n\n", "{", "\n\n", "protected:", "\n    char name[10];", "\n    char sex;", "\npublic:", "\n    Person(const char name[], char sex) :sex(sex) ", "\n\n", "{\n\n    strcpy(this->name, name);\n\n}\n", "\n\n", "};", "\n\n", "class DoubleArray ", "\n\n", "{", "\n\n", "protected:", "\n\n", "double score;\n", "\n\n", "public:", "\n\n", "DoubleArray(double score) :score(score) {}\nDoubleArray(DoubleArray &a)\n\n{\n\n    score=a.score;\n} \nvoid print() const\n{\n\n    cout << score;\n\n}\nint operator-()// 重载取反运算符 operator-,使Student类中的cheat函数可正确运行 \n\n{\n\n    return -score;\n\n} \n", "\n\n", "};", "\n\n", "class Student : public Person ", "\n\n", "{", "\n\n", "private:", "\n\n", "int id;\nchar name[20];\nDoubleArray score;\n", "\n\n", "public:", "\n    static int count;", "\n    ~Student() ", "\n    { ", "\n\n", "    count--; \n\n}\n\nvoid cheat(DoubleArray& ds) \n{ \n\n    score = -ds; \n\n} // 若作弊，则分数为负\nStudent(Student &s,DoubleArray& sc);\nStudent(int id, const char* name, char sex, DoubleArray& sc);\nStudent(int id, const char* name, char sex, double ds);\nvoid disp();\n", "\n\n", "};", "\nStudent::Student(int id, const char* name, char sex, DoubleArray& sc):Person(name,sex),score(sc)", "\n{", "\n\n", "count+=1;\n", "\n\n", "}", "\nStudent::Student(int id, const char* name, char sex, double ds):Person(name,sex),score(ds)", "\n{", "\n\n", "count+=1;\n", "\n\n", "}", "\nvoid Student::disp()", "\n{", "\n\n", "cout<<\"(id, name, sex, score)=\"<<\"(\"<<id<<\",\"<<name<<\",\"<<sex<<\",\";\nscore.print();\ncout<<\")\"<<endl;\n", "\n\n", "} ", "\n// 类外实现Student类的成员函数，令main函数得以正确运行并输出相应的结果", "\nint main() ", "\n{", "\n\n", "cout << \"count=\" << Student::count << endl;\nDoubleArray sc(97);\nStudent s[3]={Student(1,\"Ann\",'F',sc),Student(2,\"Mike\",'M',79),Student(3,\"Lucy\",'F',sc)};\ns[2].cheat(sc);\nfor (int i = 0; i < 3; i++)\ns[i].disp();\ncout << \"count=\" << Student::count << endl;\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "//你好，是有可能返回正确答案的。\r\n//因为销毁需要时间的，在这个时间之前还是有可能获取到正确数值的（虽然时间是极短的）；\r\n//你可以在调用函数后加个sleep再尝试一下", "Konwledge_Point": "运算符重载", "Question": ["C++返回局部变量引用，却没有得到乱码", ["class Ctest\n{\n    int m_a;\n    int b;\npublic:\n    Ctest(){}\n    Ctest(int a,int b):m_a(a),b(b){}\n    ~Ctest(){\n        cout <<this->m_a <<\"销毁局部变量\" << endl;\n    }\n    int geta(){ return m_a; }\n    friend ostream &operator<< (ostream &out, const Ctest &ts)\n    {\n        out << ts.m_a <<\"----\"<< ts.b << endl;\n        return out;\n    }\n    int t(){ return m_a; }\n    Ctest &operator+(const Ctest &a)\n    {\n        Ctest temp;\n        temp.m_a= this->m_a + a.m_a;\n        return temp;\n    }\n    /*friend Ctest &operator+(const Ctest &a,const Ctest &b)\n    {\n        Ctest temp;\n        temp.m_a = b.m_a + a.m_a;\n        return temp;\n    }*/\n};\n", "\n\n", "main\n\n    Ctest a(222, 2), b(333, 3), c;\n    c = a + b;\n    cout << \"c:\" << c << endl;//c=555\n    cout << a.geta() << endl;//a=222\n    cout << c << endl;//c=555\n", "\n\n", "为什么我重载+号运算符，返回一个局部变量的引用，却还是得到了正常的得数？不是局部变量销毁后，地址内的内容被删除，就应该乱码吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;distance函数写的不对&amp;#xff0c;要修改一下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;date&lt;/span&gt;::distance(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;date&lt;/span&gt; &amp;amp;t) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n{\n    &lt;span class=\"hljs-comment\"&gt;//非闰年中当月前几个月的总天数 &lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; DAYS_OF_MONTH[] &amp;#61;\n    { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;59&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;90&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;120&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;151&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;181&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;212&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;243&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;273&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;304&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;334&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;365&lt;/span&gt; };\n\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; years &amp;#61; y - t.y;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; months &amp;#61; DAYS_OF_MONTH[m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;] - DAYS_OF_MONTH[t.m&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;];&lt;span class=\"hljs-comment\"&gt;//当月未完&amp;#xff0c;应是到前一个月为止的总天数相减&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; days &amp;#61; d - t.d;\n\n    &lt;span class=\"hljs-comment\"&gt;//4年一闰&amp;#xff0c;100的倍数免闰&amp;#xff0c;400的倍数再闰&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; numLeapYear &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//不能根据年份差判断是否是闰年&amp;#xff0c;需要逐年判断并结合具体月份&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; yy &amp;#61; t.y; yy &amp;lt;&amp;#61; y; yy&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((yy &amp;#61;&amp;#61; t.y &amp;amp;&amp;amp; t.m &amp;gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) || (yy &amp;#61;&amp;#61; y &amp;amp;&amp;amp; m &amp;lt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)) &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n        numLeapYear &amp;#43;&amp;#61; leapyear(yy) &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt; ? &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; : &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; totalDays &amp;#61; years * &lt;span class=\"hljs-number\"&gt;365&lt;/span&gt; &amp;#43; numLeapYear &amp;#43; months &amp;#43; days;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; totalDays;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于Date类的运算问题", ["不知道为什么间隔日期有的时候算不对，像1987 3 4 和1998 2 8 就不对，是哪里错了吗", "\n", "\n", "/*\n实现日期的下一天\n\n两个日期  相减\n\n日期+ 天数 得到的日期\n\n具体要求：实现类date,其中\n\n构造函数包括year,month,day三个参数\n\n重载两个date类之间的-，以及date类的+=,-=\n\n使用int year(),int month(),int day()返回三个参数*/", "\n#include <iostream>\nusing namespace std;\n\n", "class", " ", "date", "\n{\n", "private", ":\n    int y;\n    int m;\n    int d;\n", "public", ":\n    date(){};\n    date(int yy,int mm,int dd);\n    date(", "const", " date &t):y(t.y),m(t.m),d(t.d){};\n    ~date(){};\n    \n    ", "//输出 year,month,day", "\n    int year()", "const", "{", "return", " y;}\n    int month()", "const", "{", "return", " m;}\n    int day()", "const", "{", "return", " d;}\n    \n    ", "//判断是否闰年", "\n    bool leapyear(int y) ", "const", ";\n    \n    ", "//得到某个月天数 ", "\n    int daysOfMonth(int y,int m)", "const", ";\n    \n    ", "//改变日期", "\n    date changeDays(", "const", " int days)", "const", ";  \n    \n    ", "//重载运算符", "\n    date& ", "operator", "++();    ", "//前置++ ", "\n    date ", "operator", "++(int); ", "//后置++      ", "\n    \n    ", "//日期加上days天数", "\n    friend date ", "operator", "+(", "const", " date &t, ", "const", " int days);\n    friend date ", "operator", "+(", "const", " int days, ", "const", " date &t);\n    date& ", "operator", " +=(int days);\n    \n    ", "//日期减去days天数", "\n    friend date ", "operator", "- (", "const", " date &t, ", "const", " int days);\n    friend int ", "operator", "-(", "const", " date &t1, ", "const", " date &t2);\n    date& ", "operator", " -=(int days); \n    \n    ", "//重载<,==", "\n    friend bool ", "operator", "<(", "const", " date &t1,", "const", " date &t2);\n    friend bool ", "operator", " ==(", "const", " date &d1,", "const", " date &d2); \n    \n    ", "//计算间隔天数", "\n    int distance(", "const", " date &d)", "const", "; \n    \n};\n\n", "//构造函数 ", "\ndate::date(int yy, int mm, int dd):y(yy),m(mm),d(dd)\n{\n    ", "if", "(yy<=", "0", " || mm<=", "0", " || mm>", "12", " || dd<=", "0", "||dd>daysOfMonth(y,m))\n    {\n        cout<<", "\"Error invalid date: \"", ";\n        cout<<endl;\n        exit(-", "1", ");\n    }\n}\n\n", "//闰年 ", "\nbool date::leapyear(int yy) ", "const", "\n{\n    ", "return", " (yy%", "4", " == ", "0", " && yy % ", "100", " != ", "0", " || yy % ", "400", " == ", "0", ");\n}\n\n", "//每个月天数", "\nint date::daysOfMonth(int yy, int mm)", "const", "\n{\n    int days = ", "0", ";\n    \n    switch(mm)\n    {\n    case ", "1", ":\n    case ", "3", ":\n    case ", "5", ":\n    case ", "7", ":\n    case ", "8", ":\n    case ", "10", ":\n    case ", "12", ":\n        days = ", "31", ";\n        ", "break", ";\n    case ", "4", ":\n    case ", "6", ":\n    case ", "9", ":\n    case ", "11", ":\n        days = ", "30", ";\n        ", "break", ";\n    case ", "2", ":\n        days = ", "28", "+leapyear(yy);\n        ", "break", ";\n    }\n \n    ", "return", " days;    \n } \n", "//改变日期", "\ndate date::changeDays(", "const", " int days)", "const", "\n{\n    int yearTemp = y;\n    int monthTemp = m;\n    int dayTemp = d;\n \n    ", "if", "(days>", "0", "){\n        dayTemp += days;\n \n        ", "while", "(dayTemp>daysOfMonth(yearTemp,monthTemp)){\n            dayTemp -= daysOfMonth(yearTemp,monthTemp);\n \n            monthTemp++;\n            ", "if", "(monthTemp>", "12", "){\n                yearTemp++;\n                monthTemp = ", "1", ";\n            }\n        }\n    }", "else", "{   ", "//days为负数", "\n        dayTemp += days;\n \n        ", "while", "(dayTemp<", "1", "){\n            monthTemp--;\n            ", "if", "(monthTemp<", "1", "){\n                yearTemp--;\n                monthTemp = ", "12", ";\n            }\n            dayTemp += daysOfMonth(yearTemp,monthTemp);\n        }\n    }\n \n    ", "return", " date(yearTemp,monthTemp,dayTemp);\n}\n\n", "//前置", "\ndate & date::", "operator", "++()\n{\n    *", "this", " = ", "this", "->changeDays(", "1", ");\n    ", "return", " *", "this", ";\n}\n \ndate date::", "operator", "++(int)   ", "//后置++", "\n{\n    date dTemp(*", "this", ");\n    ++(*", "this", ");\n    ", "return", " dTemp;\n} \n\n", "//日期加上days个天数", "\ndate ", "operator", " +(", "const", " date &t,", "const", " int days)\n{\n    ", "if", "(days==", "0", "){   ", "//如果天数为0，返回当个月", "\n        ", "return", " t;\n    }\n    ", "else", "\n        ", "return", " t.changeDays(days);\n}\n \n", "//日期加上days个天数的重载", "\ndate ", "operator", " +(", "const", " int days,", "const", " date &t)\n{\n    ", "if", "(days==", "0", "){   ", "//如果天数为0，返回当个月", "\n        ", "return", " t;\n    }\n    ", "else", "\n        ", "return", " t.changeDays(days);\n}\n \n", "//日期自身加上days个天数", "\ndate& date::", "operator", " +=(int days)\n{\n    ", "if", "(days==", "0", ")\n        ", "return", " *", "this", ";\n    ", "else", "{\n        *", "this", " = ", "this", "->changeDays(days);\n        ", "return", " *", "this", ";\n    }\n}\n\n", "//日期减去days个天数", "\ndate ", "operator", " -(", "const", " date &t,", "const", " int days)\n{\n    ", "if", "(days==", "0", "){   ", "//如果天数为0，返回当个月", "\n        ", "return", " t;\n    }\n    ", "else", "\n        ", "return", " t.changeDays(-days);\n}\n \n", "//两个日期相减，前一个日期必须大于后一个日期", "\nint ", "operator", " -(", "const", " date &t1,", "const", " date &t2)\n{\n    ", "if", "(t1<t2){\n        cout<<", "\"被减数日期必须大于减数日期！\"", "<<endl;\n        exit(-", "1", ");\n    }\n    ", "else", " ", "if", "(t1==t2)\n        ", "return", " ", "0", ";\n    ", "else", "\n        ", "return", " t1.distance(t2);\n}\n \n", "//日期自身减去days个天数", "\ndate& date::", "operator", " -=(int days)\n{\n    ", "if", "(days==", "0", ")\n        ", "return", " *", "this", ";\n    ", "else", "{\n        *", "this", " = ", "this", "->changeDays(-days);\n        ", "return", " *", "this", ";\n    }\n}\n\n", "//重载小于号<", "\nbool ", "operator", " <(", "const", " date &t1,", "const", " date &t2)\n{\n    ", "return", " t1.distance(t2)<", "0", " ? ", "true", ":", "false", ";\n} \n\n", "//重载==", "\nbool ", "operator", " ==(", "const", " date &d1,", "const", " date &d2)\n{\n    ", "return", " d1.distance(d2)==", "0", " ? ", "true", ":", "false", ";\n} \n\n", "//计算间隔天数", "\nint date::distance(", "const", " date &t) ", "const", "\n{\n    ", "//非闰年中当月前几个月的总天数 ", "\n    ", "const", " int DAYS_OF_MONTH[] =\n    {", "0", ",", "31", ",", "59", ",", "90", ",", "120", ",", "151", ",", "181", ",", "212", ",", "243", ",", "273", ",", "304", ",", "334", ",", "365", "};\n \n    int years = y-t.y;\n    int months = DAYS_OF_MONTH[m] - DAYS_OF_MONTH[t.m];\n    int days = d-t.d;\n \n    ", "//4年一闰，100的倍数免润，400的倍数再闰", "\n    int totalDays = years*", "365", "+years/", "4", "-years/", "100", "+years/", "400", "+months+days;\n    ", "return", " totalDays; \n } \n\n", "//StudybarCommentBegin", "\nint main(void) {\n    using std::cin;\n    using std::cout;\n    using std::endl;\n    date D1,D2;\n    int year;\n    int month;\n    int day;\n    cin>>year>>month>>day; ", "//输入第一个日期 ", "\n    D1=date(year,month,day);\n    cin>>year>>month>>day;  ", "//输入第二个日期 ", "\n    D2=date(year,month,day);\n    cout<<D2-D1<<endl; \n    cin>>day;  ", "//输入要减去的天数 ", "\n    D1+=day;\n    D2-=day;\n    cout<<D1.year()<<", "\" \"", "<<D1.month()<<", "\" \"", "<<D1.day()<<endl;\n    cout<<D2.year()<<", "\" \"", "<<D2.month()<<", "\" \"", "<<D2.day()<<endl;\n    ", "return", " ", "0", ";\n}\n\n", "//StudybarCommentEnd", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个问题很有可能是数组越界或者指针引用了无效的内存&amp;#xff0c;你可以尝试在程序中添加一些调试代码&amp;#xff0c;来追踪程序的执行情况。&lt;/p&gt;\n&lt;p&gt;具体的&amp;#xff0c;你可以使用以下方法来定位错误&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;在代码中加入许多 cout 语句&amp;#xff0c;来追踪变量的值&amp;#xff0c;以及程序的执行情况&amp;#xff0c;这有助于你了解程序是如何执行的。&lt;/p&gt;\n&lt;p&gt;使用断点调试&amp;#xff0c;来检查程序在执行时是否出现错误。&lt;/p&gt;\n&lt;p&gt;使用 assert 语句&amp;#xff0c;如果一个表达式的结果为 false&amp;#xff0c;则程序将中止执行&amp;#xff0c;这有助于你定位错误。&lt;/p&gt;\n&lt;p&gt;希望这些建议能帮助你找到问题所在。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++矩阵类定义，遇到了Segmentation fault", ["OJ系统一直提示：Segmentation fault:段错误，检查是否有数组越界，指针异常，访问到不应该访问的内存区域", "\n", "但是一直检查不出来哪里有错误。二维动态数组这个问题困扰我好久了，求指点！", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "//矩阵类定义", "\n", "class", " ", "Matrix", "\n{\n", "public", ":\n    ", "Matrix", "(", "int", ", ", "int", ");\n    ", "void", " ", "set", "(", "int", ", ", "int", ")", ";\n    ", "friend", " istream& ", "operator", ">>(istream &, Matrix&);\n    ", "friend", " ostream& ", "operator", "<<(ostream&, ", "const", " Matrix&);\n    Matrix& ", "operator", "*(Matrix&);\n    ", "void", " ", "DiagonalOrder", "()", ";\n    ", "void", " ", "setZeros", "()", ";\n    \n", "protected", ":\n    ", "int", "** mat;                                     ", "//矩阵（二位数组）", "\n    ", "int", " row;                                        ", "//行数", "\n    ", "int", " col;                                         ", "//列数", "\n};\n", "Matrix ", "temp", "(", "0", ",", "0", ")", ";                               ", "//定义全局对象，用于接受矩阵乘法结果", "\n", "void", " ", "Matrix::set", "(", "int", " n, ", "int", " m)", "                \n", "{\n    row = n;\n    col = m;\n    mat = ", "new", " ", "int", "* [n];\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        mat[i] = ", "new", " ", "int", "[m];\n    }\n    ", "if", " (mat == ", "NULL", ")\n    {\n        cout << ", "\"allocation failure!\\n\"", ";\n        ", "return", ";\n    }\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < m; j++)\n        {\n            mat[i][j] = ", "0", ";\n        }\n    }\n}\nMatrix::", "Matrix", "(", "int", " n, ", "int", " m)                       ", "//构造函数，初始化行数列数与矩阵", "\n{\n    row = n;\n    col = m;\n    ", "if", " (m > ", "0", " && n > ", "0", ")\n    {\n        mat = ", "new", " ", "int", "* [n];\n        ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n        {\n            mat[i] = ", "new", " ", "int", "[m];\n        }\n        ", "if", " (mat == ", "NULL", ")\n        {\n            cout << ", "\"allocation failure!\\n\"", ";\n            ", "return", ";\n        }\n        ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n        {\n            ", "for", " (", "int", " j = ", "0", "; j < m; j++)\n            {\n                mat[i][j] = ", "0", ";\n            }\n        }\n    }\n    ", "else", "\n        mat = ", "NULL", ";\n}\nistream& ", "operator", ">>(istream& input, Matrix& a)        ", "//重载输入运算符", "\n{\n    ", "for", " (", "int", " i = ", "0", "; i < a.row; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < a.col; j++)\n        {\n            input >> a.mat[i][j];\n        }\n    }\n    ", "return", " input;\n}\nostream& ", "operator", "<<(ostream& output,", "const", " Matrix& a)     ", "//重载输出运算符", "\n{\n   \n    ", "for", " (", "int", " i = ", "0", "; i < a.row; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < a.col", "-1", "; j++)\n        {\n            output << a.mat[i][j] << ", "\" \"", ";\n        }\n        cout << a.mat[i][a.col - ", "1", "] << endl;\n    }\n    ", "return", " output;\n}\n\nMatrix& Matrix::", "operator", "*(Matrix&a)                        ", "//重载矩阵乘法", "\n{\n    ", "if", " (col == a.row)\n    {\n        temp.", "set", "(row, a.col);\n        \n        ", "for", " (", "int", " i = ", "0", "; i < temp.row; i++)\n        {\n            ", "for", " (", "int", " j = ", "0", "; j < temp.col; j++)\n            {\n                ", "int", " sum = ", "0", ";\n                ", "int", " k = ", "0", ",o = ", "0", ";\n                ", "while", " (k < col && o < a.row)\n                {\n                    sum += mat[i][k] * a.mat[o][j];\n                    k++; o++;\n                }\n                \n                temp.mat[i][j] = sum;\n            }\n        }\n        ", "return", " temp;\n    }\n    ", "else", "\n    {\n        cout << ", "\"can't multiply!\"", " << endl;\n        \n    }\n}\n", "void", " ", "Matrix::DiagonalOrder", "()", "                                               ", "//之字形打印", "\n", "{\n    \n        cout << mat[", "0", "][", "0", "] << ", "\" \"", ";\n    \n       \n        ", "int", " is_up = ", "1", ";\n        ", "int", " x = ", "0", ", y = ", "0", ";\n        ", "while", " (x >= ", "0", " && x <= row - ", "1", " && y >= ", "0", " && y <= col - ", "1", ")\n        {\n            ", "if", " (x == ", "0", ")\n            {\n                ", "if", " (y == ", "0", ")\n                {\n                    y++;\n                    is_up = ", "0", ";                  \n                }\n                ", "else", " ", "if", "(y<col", "-1", ")\n                {\n                    ", "if", " (is_up == ", "0", ")\n                    {\n                        x++; y--;\n                        \n                    }\n                    ", "else", "\n                    {\n                       y++;\n                       is_up = ", "0", ";\n                    }\n                }\n                ", "else", "\n                {\n                    is_up = ", "0", ";\n                    x++;\n                }\n            }\n            ", "else", " ", "if", " (x == row - ", "1", ")\n            {\n                ", "if", " (y>=", "0", "&&y<col", "-1", ")\n                {\n                    ", "if", " (is_up)\n                    {\n                        x--; y++;\n                    }\n                    ", "else", "\n                    {\n                        y++;\n                        is_up = ", "1", ";\n                    }\n                }\n                \n            }\n\n            ", "else", " ", "if", " (y == ", "0", ")\n            {\n                ", "if", " (is_up == ", "1", ")\n                {\n                    x--; y++;\n                }\n                ", "else", "\n                {\n                    x++;\n                    is_up = ", "1", ";\n                }\n            }\n            ", "else", " ", "if", " (y == col - ", "1", ")\n            {\n                ", "if", " (is_up == ", "1", ")\n                {\n                    x++;\n                    is_up = ", "0", ";\n                }\n                ", "else", "\n                {\n                    x++; y--;\n                }\n            }\n            ", "else", "\n            {\n                ", "if", " (is_up ==", "1", ")\n                {\n                    x--; y++;\n                }\n                ", "else", "\n                {\n                    x++; y--;\n                }\n            }\n\n            ", "if", " (x == row - ", "1", " && y == col - ", "1", ")\n            {\n                cout << mat[x][y] << endl;\n                ", "break", ";\n            }\n            ", "else", "\n                cout << mat[x][y] << ", "' '", ";\n        }\n       \n       \n    \n   \n\n}\n", "void", " ", "Matrix::setZeros", "()", "                                            ", "//将矩阵中有0的行和列全部置0", "\n", "{\n    ", "int", "** temp = ", "new", " ", "int", "* [row];\n    ", "for", " (", "int", " i = ", "0", "; i < row; i++)\n    {\n        temp[i] = ", "new", " ", "int", "[col];\n    }\n    ", "for", " (", "int", " i = ", "0", "; i < row; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < col; j++)\n        {\n            temp[i][j] = mat[i][j];\n        }\n    }\n    ", "for", " (", "int", " i = ", "0", "; i < row; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < col; j++)\n        {\n            ", "if", " (temp[i][j] == ", "0", ")\n            {\n                ", "for", " (", "int", " k = ", "0", "; k < col; k++)\n                    mat[i][k] = ", "0", ";\n                ", "for", " (", "int", " o = ", "0", "; o < row; o++)\n                    mat[o][j] = ", "0", ";\n            }\n        }\n    }\n    ", "delete", "[]temp;\n\n}\n\n", "int", " ", "main", "()", " ", "{\n\n    ", "int", " n, m;\n\n    ", "while", " (cin >> m >> n) {\n\n        ", "Matrix ", "mat1", "(m, n)", ";\n\n        cin >> mat1;\n\n\n\n        ", "int", " x, y;\n\n        cin >> x >> y;\n\n        ", "Matrix ", "mat2", "(x, y)", ";\n\n        cin >> mat2;\n\n\n\n        Matrix res = mat1 * mat2;\n\n        cout << res;\n\n\n\n        mat1.", "DiagonalOrder", "();\n\n\n\n        mat1.", "setZeros", "();\n\n        cout << mat1;\n\n    }\n\n    ", "return", " ", "0", ";\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;操作符和f_dis函数加上const修饰&amp;#xff0c;代码修改如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;cstdio&amp;gt;\n#include&amp;lt;cmath&amp;gt;\n#include&amp;lt;queue&amp;gt;\n#include&amp;lt;vector&amp;gt;\nusing namespace std;\nconst int N&amp;#61;100,M&amp;#61;100;\nint n,m;\nbool map[N][M]; \nclass map\n{\nprivate:\n\tbool **p;\n\tint n,m;\n\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t{\n\t\treturn (((i&amp;gt;&amp;#61;((x1&amp;gt;x2)?x2:x1))&amp;amp;&amp;amp;(i&amp;lt;&amp;#61;((x1&amp;gt;x2)?x1:x2)))&amp;amp;&amp;amp;((j&amp;gt;&amp;#61;((y1&amp;gt;y2)?y2:y1))&amp;amp;&amp;amp;(j&amp;lt;&amp;#61;((y1&amp;gt;y2)?y1:y2))));\n\t}\n\tstruct point\n\t{\n\t\tstatic int tar_x,tar_y;\n\t\tint x,y,b_dis;\n\t\tint f_dis() const  //修改1\n\t\t{\n\t\t\treturn abs(x-tar_x)&amp;#43;abs(y-tar_y);\n\t\t}\n\t\tbool operator&amp;lt;(const point b)const   //修改2\n\t\t{\n\t\t\treturn (b_dis&amp;#43;f_dis())&amp;gt;(b.b_dis&amp;#43;b.f_dis());\n\t\t}\n\t};\npublic:\n\tmap(const int N,const int M)\n\t{\n\t\tn&amp;#61;N;\n\t\tm&amp;#61;M;\n\t\tp&amp;#61;new bool*[N&amp;#43;1];\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;N;i&amp;#43;&amp;#43;)\n\t\t\tp[i]&amp;#61;new bool[M&amp;#43;1];\n\t}\n\t~map()\n\t{\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\t\t\tdelete[] p[i];\n\t\tdelete[] p;\n\t}\n\tvoid set_obstruction(const int x,const int y)\n\t{\n\t\tp[x][y]&amp;#61;true;\n\t\treturn;\n\t}\n\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tfor(int i&amp;#61;1;i&amp;lt;&amp;#61;n;i&amp;#43;&amp;#43;)\n\t\t\tfor(int j&amp;#61;1;j&amp;lt;&amp;#61;m;j&amp;#43;&amp;#43;)\n\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\tp[i][j]&amp;#61;true;\n\t\treturn;\n\t}\n\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t{\n\t\tpriority_queue&amp;lt;point&amp;gt; q;\n\t\tpoint::tar_x&amp;#61;x2;\n\t\tpoint::tar_y&amp;#61;y2;\n\t\tpoint start;\n\t\tstart.x&amp;#61;x1;\n\t\tstart.y&amp;#61;y1;\n\t\tq.push(start);\n\t}\n};\nint main()\n{\n\n\treturn 0;\n}\n//我想写一个A*寻路实现&amp;#xff0c;但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了&amp;#xff08;555~~&amp;#xff09;&amp;#xff0c;求大佬告知怎么改啊&amp;#xff1f; &lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["以下这段C++代码为啥跑不了？", ["\n", "#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int N=100,M=100;\nint n,m;\nbool map[N][M]; \nclass map\n{\n\tprivate:\n\t\tbool **p;\n\t\tint n,m;\n\t\tinline bool isin(const int x1,const int y1,const int x2,const int y2,const int i,const int j)\n\t\t{\n\t\t\treturn (((i>=((x1>x2)?x2:x1))&&(i<=((x1>x2)?x1:x2)))&&((j>=((y1>y2)?y2:y1))&&(j<=((y1>y2)?y1:y2))));\n\t\t}\n\t\tstruct point\n\t\t{\n\t\t\tstatic int tar_x,tar_y;\n\t\t\tint x,y,b_dis;\n\t\t\tint f_dis()\n\t\t\t{\n\t\t\t\treturn abs(x-tar_x)+abs(y-tar_y);\n\t\t\t}\n\t\t\tbool operator<(point b)\n\t\t\t{\n\t\t\t\treturn (b_dis+f_dis())>(b.b_dis+b.f_dis());\n\t\t\t}\n\t\t};\n\tpublic:\n\t\tmap(const int N,const int M)\n\t\t{\n\t\t\tn=N;\n\t\t\tm=M;\n\t\t\tp=new bool*[N+1];\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tp[i]=new bool[M+1];\n\t\t}\n\t\t~map()\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tdelete[] p[i];\n\t\t\tdelete[] p;\n\t\t}\n\t\tvoid set_obstruction(const int x,const int y)\n\t\t{\n\t\t\tp[x][y]=true;\n\t\t\treturn;\n\t\t}\n\t\tvoid set_obstruction(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\t\tif(isin(x1,y1,x2,y2,i,j))\n\t\t\t\t\t\tp[i][j]=true;\n\t\t\treturn;\n\t\t}\n\t\tint get_way(const int x1,const int y1,const int x2,const int y2)\n\t\t{\n\t\t\tpriority_queue<point> q;\n\t\t\tpoint::tar_x=x2;\n\t\t\tpoint::tar_y=y2;\n\t\t\tpoint start;\n\t\t\tstart.x=x1;\n\t\t\tstart.y=y1;\n\t\t\tq.push(start);\n\t\t}\n};\nint main()\n{\n\t\n\treturn 0;\n}\n//我想写一个A*寻路实现，但是这段BFS的优先队列似乎因为结构体的重载运算符跑不了了（555~~），求大佬告知怎么改啊？ "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.去掉using namespace std;后面的cout和endl改成std::cout和std::endl&lt;/p&gt;\n\n&lt;p&gt;2.友元函数实现的时候写错了&amp;#xff08;第18行&amp;#xff09;&amp;#xff0c;应该是-号&amp;#xff0c;不是&amp;#43;号&lt;/p&gt;\n\n&lt;p&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;iostream&amp;gt;\n#include &amp;lt;math.h&amp;gt;\n//using namespace std;\n\nusing std::cin; using std::cout; using std::ostream; using std::istream; using std::endl;\nclass Point {\nprivate:\n\tfloat x;\n\tfloat y;\npublic:\n\tPoint(float X &amp;#61; 0.0f, float Y &amp;#61; 0.0f) :x(X), y(Y) {\n\t};\n\tfloat show();\n\tfriend Point operator -(Point&amp;amp; t, Point&amp;amp; t1);\n};\nfloat Point::show() {\n\tstd::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;,&amp;#34; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; std::endl;\n\treturn 0;\n}\nPoint operator -(Point&amp;amp; t, Point&amp;amp; t1) { //&amp;#43;\n\treturn sqrt((t.x - t1.x) * (t.x - t1.x) &amp;#43; (t.y - t1.y) * (t.x - t1.y));\n}\nint main() {\n\tPoint t, t1(3, 4), t3;\n\tt.show();\n\tt3 &amp;#61; t - t1;\n\tstd::cout &amp;lt;&amp;lt; t3.show() &amp;lt;&amp;lt; std::endl;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["C++中友元函数访问不了类中的私有成员", ["\n", "#include <iostream>\n#include <math.h>\nusing namespace std;\nclass Point {\nprivate:\n    float x;\n    float y;\npublic:\n    Point(float X = 0.0f, float Y = 0.0f) :x(X), y(Y) {\n    };\n    float show();\n    friend Point operator -(Point& t, Point& t1);\n};\nfloat Point::show() {\n    cout << x << \",\" << y << endl;\n    return 0;\n}\nPoint operator +(Point& t, Point& t1) {\n    return sqrt((t.x - t1.x) * (t.x - t1.x) + (t.y - t1.y) * (t.x - t1.y));\n}\nint main() {\n    Point t, t1(3, 4), t3;\n    t.show();\n    t3 = t - t1;\n    cout << t3.show() << endl;\n}", "\n\n", "题目要求", "\n\n", "（1）编写构造函数，用于完成点类对象初始化。默认初始值为(0,0)。", "\n\n", "（2）编写成员函数show()，用于显示平面点的坐标值。", "\n\n", "（3）重载减法运算符为非成员函数，用于计算当前点与另一点之间的距离计算。", "\n\n", "（4）编写main()函数完成上述类的测试应用。", "\n\n", "vs2019错误报告，不知道错在哪里", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;判断队列是不是满那里错了&amp;#xff0c;应该是size&amp;#61;&amp;#61;maxsize。你这个队列一直判满&amp;#xff0c;插不进元素&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["我想通过队列的方法打印杨辉三角形，但为什么用这种方法显示不了呀", ["问题遇到的现象和发生背景", "\n", "问题相关代码，请勿粘贴截图", "\n", ".h文件", "\n", "#", "ifndef", " QUEUE_H", "\n", "#", "define", " QUEUE_H", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "template", " <", "class", " ", "T", ">\n", "class", " ", "queue", "\n{\n", "private", ":\n    ", "int", " size;\n    ", "int", " maxSize;\n    ", "int", " front, rear;\n    T *element;\n\n", "public", ":\n    ", "queue", "(", "int", " mmaxsize);\n    ~", "queue", "();\n    ", "bool", " ", "isempty", "()", ";\n    ", "bool", " ", "isfull", "()", ";\n    ", "bool", " ", "insert", "(", "const", " T &x)", ";\n    ", "bool", " ", "Delete", "(T &x)", ";\n    ", "void", " ", "display", "()", ";\n    ", "bool", " ", "getElement", "(T &x)", ";\n    ", "void", " ", "output", "(ostream& out)", ";\n};\n", "//构造函数", "\n", "template", " <", "class", " ", "T", ">\nqueue<T>::", "queue", "(", "int", " mmaxsize)\n{\n    size = ", "0", ";\n    maxSize = mmaxsize;\n    front = ", "0", ";\n    rear = ", "0", ";\n    element = ", "new", " T[mmaxsize];\n}\n", "//析构函数", "\n", "template", " <", "class", " ", "T", ">\nqueue<T>::~", "queue", "()\n{\n    ", "delete", "[] element;\n}\n", "//判断是不是空", "\n", "template", " <", "class", " ", "T", ">\n", "bool", " queue<T>::", "isempty", "()\n{\n    ", "return", " size == ", "0", ";\n}\n", "//判断是不是满", "\n", "template", " <", "class", " ", "T", ">\n", "bool", " queue<T>::", "isfull", "()\n{\n    ", "return", " size = maxSize;\n}\n", "//实现入队", "\n", "template", " <", "class", " ", "T", ">\n", "bool", " queue<T>::", "insert", "(", "const", " T &x)\n{\n    ", "if", " (", "isfull", "())\n        ", "return", " ", "false", ";\n    ", "else", "\n    {\n        element[rear] = x;\n        rear = (rear + ", "1", ") % maxSize;\n        size++;\n        ", "return", " ", "true", ";\n    }\n}\n", "//实现出队", "\n", "template", " <", "class", " ", "T", ">\n", "bool", " queue<T>::", "Delete", "(T &x)\n{\n    ", "if", " (", "isempty", "())\n        ", "return", " ", "false", ";\n    ", "else", "\n    {\n        x = element[front];\n        front = (front + ", "1", ") % (maxSize);\n        size--;\n        ", "return", " ", "true", ";\n    }\n}\n", "//寻找队列里面的头元素", "\n", "template", " <", "class", " ", "T", ">\n", "bool", " queue<T>::", "getElement", "(T& x)\n{\n    ", "if", "(", "isempty", "())\n        ", "return", " ", "false", ";\n    ", "else", "\n    {\n        x = element[front];\n        ", "return", " ", "true", ";\n    }\n}\n", "//实现队列的输出", "\n", "template", " <", "class", " ", "T", ">\n", "void", " queue<T>::", "output", "(ostream& out)\n{\n    ", "int", " index;\n    index = front;\n    ", "for", "(", "int", " i = ", "0", ";i<size;i++)\n    {\n        out << element[index] << endl;\n        index = (index+", "1", ")%maxSize;\n    }\n}\n", "//重载插入运算符", "\n", "template", " <", "class", " ", "T", ">\nostream& ", "operator", "<<(ostream& out,queue<T>& x)\n{\n    x.", "output", "(out);\n}\n", "#", "endif", "\n\n", "\n", ".cpp", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "\"queue.h\"", "\n\n", "using", " ", "namespace", " std;\n", "void", " ", "printspace", "(", "int", " n, ", "int", " k)", ";\n", "void", " ", "yanghui", "(", "int", " n)", ";\n\n", "int", " ", "main", "()", "\n", "{\n    ", "yanghui", "(", "4", ");\n    ", "return", " ", "0", ";\n}\n", "void", " ", "printspace", "(", "int", " m, ", "int", " k)", "\n", "{\n    ", "for", " (", "int", " i = ", "0", "; i < m-k; i++)\n        cout << ", "' '", ";\n}\n", "void", " ", "yanghui", "(", "int", " n)", "\n", "{\n    ", "queue<", "int", "> ", "Q", "(n + ", "2", ")", ";\n    ", "int", " x, y;\n    ", "printspace", "(n, ", "1", ");\n    cout << ", "'1'", " << endl;\n    Q.", "insert", "(", "0", ");\n    Q.", "insert", "(", "1", ");\n    Q.", "insert", "(", "1", ");\n    ", "for", " (", "int", " j = ", "2", "; j <= n; j++)\n    {\n        Q.", "insert", "(", "0", ");\n        ", "printspace", "(n, j);\n        ", "do", "\n        {\n            Q.", "Delete", "(x);\n            Q.", "getElement", "(y);\n            ", "if", "(y) \n                cout << y << ", "' '", ";\n            ", "else", " \n                cout << endl;\n            Q.", "insert", "(x+y);\n        }", "while", "(y);\n    }\n\n    cout << endl;\n}\n\n", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "```\r\nC++要求先申明，后使用\r\n    void copy_from(const T* A, Rank low, Rank high);\r\n这一行要放在所有调用的前面，比如\r\nfriend class increase_operation&lt;T&gt;;\r\nprivate: \r\n    void copy_from(const T* A, Rank low, Rank high);\r\npublic:\r\n...\r\n```", "Konwledge_Point": "运算符重载", "Question": ["请问一下，在vs2019c++里面，这段代码总是报LNK2019的错误。", ["报错内容如下：", "\n\n", "错误  LNK2019 无法解析的外部符号 \"private: void __thiscall myVector<int>::copy_from(int const *,int,int)\" (?copy_from@?$myVector@H@@AAEXPBHHH@Z)，该符号在函数 \"public: __thiscall myVector<int>::myVector<int>(int const *,int)\" (??0?$myVector@H@@QAE@PBHH@Z) 中被引用  ConsoleApplication1 C:\\Users\\qwer\\source\\repos\\ConsoleApplication1\\ConsoleApplication1.obj  1   \n", "\n\n", "这个是头文件：", "\n\n", "#include<iostream>\nusing namespace std;\nconst int DEFAULT_CAPACITY = 3;\nusing Rank = int;//秩\ntemplate<class T>\nclass increase_operation\n{\npublic:\n    void operator()(T& e)\n    {\n        e++;\n    }\n};\ntemplate<class T> class myVector\n{\n    friend class increase_operation<T>;\npublic:\n//构造函数\n    myVector(int default_capacity = DEFAULT_CAPACITY, int default_size = 0, T default_elem = 0)//\n    {\n        _capacity = default_capacity;\n        _elem = new T[_capacity];\n        for (_size = 0; _size < default_size; _size++)\n        {\n            _elem[_size] = default_elem;\n        }\n    }\n    myVector(const T* elem, Rank n)\n    {\n        copy_from(elem, 0, n);\n    }\n    myVector(const T* elem, Rank low, Rank high)\n    {\n        copy_from(elem, low, high);\n    }//在调用的时候的构造函数\n    myVector(const myVector<T> & elem)\n    {\n        copy_from(elem._elem, 0, elem._size);\n    }\n    myVector(const myVector<T> & elem, Rank low, Rank high)\n    {\n        copy_from(elem._elem, low, high);\n    }\n//析构函数\n    ~myVector()\n    {\n        delete[] _elem;\n    }\n//接口\n    //重载运算符\n    myVector& operator=(myVector<T> const& V)\n    {\n        if (_elem)\n        {\n            delete[] _elem;\n        }\n        copy_from(V._elem, 0, V._size);\n    }\n    T& operator[](Rank r)\n    {\n        return _elem[r];\n    }\n    //功能\n    Rank insert(Rank, T const&);\n    int remove(Rank, Rank);\n    T remove(Rank);\n    Rank find(T const&, Rank, Rank) const;\n    void unsort(Rank lo, Rank hi);\n    int deduplicate();\n\n    template<class tx>\n    void traverse(tx visit)\n    {\n        for (int i = 0; i < this->_size; i++)\n        {\n            visit(this->_elem[i]);\n        }\n    }\nprivate:\n//数据存放\n    Rank _size = 0;//存放了的元素总数\n    int _capacity = 0;//容器的大小\n    T* _elem;//具体的元素内容\n//内置实现\n    void copy_from(const T* A, Rank low, Rank high);\n    void expand();\n    void shrink();\n    void permute(myVector<T>&, Rank low = 0, Rank high = this->_size)\n    {\n        for (Rank i = low; i < high; i++)\n        {\n            swap(this->_elem[i], this->_elem[rand() % i]);\n        }\n    }\n};\n", "\n\n", "copy_from函数定义如下：", "\n\n", "template<class T>\nvoid myVector<T>::copy_from(const T* elem, Rank low, Rank high)\n{\n    this->_capacity = (high - low) << 1;\n    this->_elem = new T[_capacity];\n    this->_size = 0;\n    while (high > low)\n    {\n        this->_elem[_size] = elem[low];\n        _size++;\n        low++;\n    }\n}\n", "\n\n", "有大佬知道是怎么了吗？谢谢。"]], "Tag": "程序设计"}
{"Answer": "你把多个cpp内容拷贝到一个文件里面了，第30行的意思是，以下内容为calculate.cpp文件中的内容，前面是.h的头文件，你要弄两个文件，有包含关系的，名称要起一致", "Konwledge_Point": "运算符重载", "Question": ["这是我找到的一个代码，这个问题怎么处理好", ["calculate.h", "\n#include", "\nclass Integer//整数类", "\n{", "\nprotected:", "\n    int fz;", "\n    intfm;", "\n    public:", "\nInteger(int a=0,int b=1):fz(a),fm(b){}", "\n~Integer(){}", "\nvoid display();", "\n};", "\nclass Fraction:public Integer", "\n{", "\n    public:", "\n    Fraction(int a=0,int b=1):Integer(a,b){}", "\n    friend istream & operator>>(istream & ,Fraction & );//重载输入流", "\n    friend ostream & operator<<(ostream & ,Fraction & );", "\n    Fraction operator+(Fraction &c);", "\n    Fraction operator+(int n);", "\n    friend Fraction operator-(int n,Fraction &c);", "\n    Fraction operator*(Fraction &c);", "\n    Fraction operator*(int n);", "\n    Fraction operator/(Fraction &c);", "\n    Fraction operator/(int n);", "\n    friend Fraction operator/(int n,Fraction &c);", "\n    Fraction predigest();", "\n    void display();", "\n};", "\ncalculate.cpp", "\n#include", "\n#include\"calculate.h\"", "\nvoid Integer::display()", "\n{", "\n    cout<\n    cout\n    cout\n    cout\n    cout\n    cout\n    cout\n}", "\nFraction Fraction::predigest()", "\n{", "\n    int n,d,t,sign=1;", "\n    Fraction temp;", "\n    if(fz\n    {", "\n        fz=-fz;", "\n        fm=-fm;", "\n    }", "\n    if(fz>0 && fm\n    {", "\n        fm=-fm;", "\n        sign=-1;", "\n    }", "\n    if(fz0)", "\n    {", "\n        fz=-fz;", "\n        sign=-1;", "\n    }", "\n    n=fz;", "\n    d=fm;", "\n\n", "int r;\nif(n<d)\n{\n    t=n;n=d;d=t;\n}\nr=n%d;\nwhile(r!=0)\n{\n    n=d;\n    d=r;\n    r=n%d;\n}\ntemp.fz=sign*(fz/d);\ntemp.fm=fm/d;\nreturn temp;\n", "\n\n", "}", "\nFraction Fraction::operator+(Fraction &c)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz*c.fm+fm*c.fz;", "\n    temp.fm=fm*c.fm;", "\n    return temp;", "\n}", "\nFraction Fraction::operator+(int n)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz+fm*n;", "\n    temp.fm=fm;", "\n    return temp;", "\n}", "\nFraction operator-(int n,Fraction &c)", "\n{", "\n    Fraction temp;", "\n    temp.fz=c.fm*n-c.fz;", "\n    temp.fm=c.fm;", "\n    return temp;", "\n}", "\nFraction Fraction::operator-(int n)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz-fm*n;", "\n    temp.fm=fm;", "\n    return temp;", "\n}", "\nFraction Fraction::operator-(Fraction &c)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz*c.fm-fm*c.fz;", "\n    temp.fm=fm*c.fm;", "\n    return temp;", "\n}", "\nFraction Fraction::operator*(Fraction &c)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz*c.fz;", "\n    temp.fm=fm*c.fm;", "\n    return temp;", "\n}", "\nFraction Fraction::operator*(int n)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz*n;", "\n    temp.fm=fm;", "\n    return temp;", "\n}", "\nFraction Fraction::operator/(Fraction &c)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz*c.fm;", "\n    temp.fm=fm*c.fz;", "\n    return temp;", "\n}", "\nFraction Fraction::operator/(int n)", "\n{", "\n    Fraction temp;", "\n    temp.fz=fz;", "\n    temp.fm=fm*n;", "\n    return temp;", "\n}", "\nFraction operator/(int n,Fraction &c)", "\n{", "\n    Fraction temp;", "\n    temp.fz=n*c.fm;", "\n    temp.fm=c.fz;", "\n    return temp;", "\n}", "\nostream&operator<<(ostream &output,Fraction &t)", "\n{", "\n    int a,b,c;", "\n    a=t.fz;", "\n    b=t.fm;", "\n    if(a==0||b==0)", "\n    cout<<\"0\";", "\n    if(b==1)", "\n    cout<", "\n    if(a>b&&b!=1)", "\n    {", "\n        c=a/b;", "\n        a=a%b;", "\n        cout<\n        if(a!=0)", "\n        cout\n    }", "\n    if(ab&&b!=1)", "\n    {", "\n        c=-a/b;", "\n        a=-a&b;", "\n        c=-c;", "\n        cout<<'='<\n        if(a!=0)", "\n        cout\n    }", "\n    if(t.fz>0&&t.fz\n    output\n    if(t.fz\n    output\n    return output;", "\n}", "\nistream&operator\n{", "\n    int a,c;", "\n    char b;", "\n    input>>a>>b>>C;", "\n    if(b=='/'&&c!=0)", "\n    {", "\n        t.fz=a;", "\n        t.fm=c;", "\n    }", "\n    else", "\n    cout<<\"错误！请退出重新输入！\"<\n    return input; ", "\n}", "\nint main()", "\n{", "\n    Integer dis;", "\n    Fraction a,b,result,real;", "\n    int m,z;", "\n    char c;", "\n    dis.display();", "\n    while(m!=0)", "\n    {", "\n        cout\n        cin>>m;", "\n        if(m==1)", "\n        {", "\n            cout<\n            cin>>a;", "\n            cout<\n            cin>>c;", "\n             cout<\n             cin>>z;", "\n             if(c=='+')", "\n             result=a+z;", "\n             if(c=='-')", "\n             result=a-z;", "\n             if(c=='*')", "\n             result=a*z;", "\n             if(c=='/')", "\n             result=a/z;", "\n             real=result.predigest();", "\n             cout<<\"运算式为：\"<", "\n             cout\n        } ", "\n        if(m==2)", "\n        {", "\n            cout\n            cout\n            cin>>z;", "\n            cout<\n            cin>>c;", "\n             cout<\n             cin>>b;", "\n             if(c=='+')", "\n             result=b+z;", "\n             if(c=='-')", "\n             result=z-b;", "\n             if(c=='*')", "\n             result=b*z;", "\n             if(c=='/')", "\n             result=z/b;", "\n             real=result.predigest();", "\n             cout<<\"运算式为：\"<\n             cout\n        }", "\n        if(m==3)", "\n        {", "\n            cout\n            cout\n            cin>>a;", "\n            cout<\n            cin>>c;", "\n             cout<\n             cin>>b;", "\n             if(c=='+')", "\n             result=b+a;", "\n             if(c=='-')", "\n             result=a-b;", "\n             if(c=='*')", "\n             result=b*a;", "\n             if(c=='/')", "\n             result=a/b;", "\n             real=result.predigest();", "\n             cout<<\"运算式为：\"<<a<<c<<b<<'=' <<a.predigest()<<c<<b.predigest()<<'='<<real<<endl;", "\n             cout<<endl; ", "\n             }", "\n    }", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我这边有挺多个源码的&amp;#xff0c;但都是很早之前写的&amp;#xff0c;可能比较乱&amp;#xff0c;但是当时都有注释&amp;#xff0c;需要可以找我&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["用c++类实现日期的基本运算", ["课上布置了一个很难的实验：", "1、设计一个日期类Date，包括年、月、日等私有数据成员。要求实现日期的基本运算，如某日期加上天数、某日期减去天数、两日期相差的天数等。", "2、设计如下的私有成员函数：", "（1）    leap(int)：判断指定的年份是否为闰年。", "（2）    dton(Date &)：将指定日期转换成从公元元年1月1日起的天数（假设公元元年1月1日为整数0）。", "（3）    ntod(int)：将指定的公元元年1月1日起的天数转换成对应的日期。", "3、在Date类中设计如下重载运算符函数：", "（1）    Date operator+(int days)：返回某日期加上天数得到的日期", "（2）    Date operator-(int days)：返回某日期减去天数得到的日期", "（3）    int operator-(Date&b)：返回两日期相差的天数", "4、利用定义好的Date类，完成下面的任务：", "（1）    输入两个日期、计算它们之间差的天数，并输出。", "（2）    输入一个日期和天数n（正整数），计算该日期后推n天和前推n天的新日期，并输出。", "\n", "我只会在源程序中手动修改日期，并且数字过大就会出错，怎么才能实现以上功能？如有源码可否在每个函数加简短注释？这对我很重要，感谢", "\n", "\n```c++\n#include<iostream>\nusing namespace std;\n", "class", " ", "Date", " ", "{\n", "private", ":\n    int year, month, day;\n", "public", ":\n    Date(int y = ", "0", ", int m = ", "0", ", int d = ", "0", ") {\n        year = y;\n        month = m;\n        day = d;\n    }\n    void Print();\n    Date ", "operator", "-(", "const", " Date &c); \n    Date ", "operator", "+(", "const", " Date &c);\n    Date ", "operator", "++();\n    Date ", "operator", "--();\n};\nvoid Date::Print() {\n    cout << ", "\"DATE£º\"", "<<year<<", "\"/\"", "<<month<<", "\"/\"", "<<day<< endl;\n}\nDate Date::", "operator", "-(", "const", " Date &c) {\n    int temp = ", "0", ",day_y=", "0", ";\n    ", "if", " (c.year - year >= ", "1", ") {\n        ", "for", " (int n = year; n < c.year; n++) {\n            ", "if", " ((n % ", "4", " == ", "0", " && n % ", "100", " != ", "0", ") || n % ", "400", " == ", "0", ") { day_y = day_y + ", "366", "; }\n            ", "else", " { day_y = day_y + ", "365", "; }\n        }\n    }\n        ", "for", " (int i = ", "1", "; i < month; i++) {\n            switch (i) {\n            case ", "1", ": temp += ", "31", "; ", "break", ";\n            case ", "2", ": ", "if", " ((year % ", "4", " == ", "0", " && year % ", "100", " != ", "0", ") || year % ", "400", " == ", "0", ") { temp += ", "29", "; ", "break", "; }\n                    ", "else", " { temp += ", "28", "; ", "break", "; }\n            case ", "3", ":    temp += ", "31", "; ", "break", ";\n            case ", "4", ":    temp += ", "30", "; ", "break", ";\n            case ", "5", ":    temp += ", "31", "; ", "break", ";\n            case ", "6", ":    temp += ", "30", "; ", "break", ";\n            case ", "7", ":    temp += ", "31", "; ", "break", ";\n            case ", "8", ":    temp += ", "31", "; ", "break", ";\n            case ", "9", ":    temp += ", "30", "; ", "break", ";\n            case ", "10", ":temp += ", "31", "; ", "break", ";\n            case ", "11", ":temp += ", "30", "; ", "break", ";\n            case ", "12", ":temp += ", "31", "; ", "break", ";\n            }\n        }\n        int sum1 = temp;\n        temp = ", "0", ";\n        ", "for", " (int i = ", "1", "; i < c.month; i++) {\n            switch (i) {\n            case ", "1", ": temp += ", "31", "; ", "break", ";\n            case ", "2", ": ", "if", " ((c.year % ", "4", " == ", "0", " && c.year % ", "100", " != ", "0", ") || c.year % ", "400", " == ", "0", ") { temp += ", "29", "; ", "break", "; }\n                    ", "else", " { temp += ", "28", "; ", "break", "; }\n            case ", "3", ":    temp += ", "31", "; ", "break", ";\n            case ", "4", ":    temp += ", "30", "; ", "break", ";\n            case ", "5", ":    temp += ", "31", "; ", "break", ";\n            case ", "6", ":    temp += ", "30", "; ", "break", ";\n            case ", "7", ":    temp += ", "31", "; ", "break", ";\n            case ", "8", ":    temp += ", "31", "; ", "break", ";\n            case ", "9", ":    temp += ", "30", "; ", "break", ";\n            case ", "10", ":temp += ", "31", "; ", "break", ";\n            case ", "11", ":temp += ", "30", "; ", "break", ";\n            case ", "12", ":temp += ", "31", "; ", "break", ";\n            }\n        }\n        int sum2 = temp;\n        day_y = day_y - sum1 + sum2+c.day-day;\n        cout << ", "\"Ïà¸ôÌìÊý\"", "<<day_y<< endl;\n        ", "return", " (", "0", ", ", "0", ", ", "0", ");\n};\n\nDate Date::", "operator", "+(", "const", " Date &c) {\n    int sumday = ", "0", ",temp=", "0", ",j=", "0", ",k=", "0", ";\n    ", "for", " (int i = ", "1", "; i < month; i++) {\n        switch (i) { \n        case ", "1", ": temp += ", "31", "; ", "break", ";\n        case ", "2", ": ", "if", " ((year % ", "4", " == ", "0", " && year % ", "100", " != ", "0", ") || year % ", "400", " == ", "0", ") { temp += ", "29", "; ", "break", "; }\n                ", "else", " { temp += ", "28", "; ", "break", "; }\n        case ", "3", ":    temp += ", "31", "; ", "break", ";\n        case ", "4", ":    temp += ", "30", "; ", "break", ";\n        case ", "5", ":    temp += ", "31", "; ", "break", ";\n        case ", "6", ":    temp += ", "30", "; ", "break", ";\n        case ", "7", ":    temp += ", "31", "; ", "break", ";\n        case ", "8", ":    temp += ", "31", "; ", "break", ";\n        case ", "9", ":    temp += ", "30", "; ", "break", ";\n        case ", "10", ":temp += ", "31", "; ", "break", ";\n        case ", "11", ":temp += ", "30", "; ", "break", ";\n        case ", "12", ":temp += ", "31", "; ", "break", ";\n        }\n    }\n    sumday = temp + c.day+day;\n    ", "for", "(  k= year; sumday > ", "365", "; k++) {\n        ", "if", " ((k % ", "4", " == ", "0", " && k % ", "100", " != ", "0", ") || k % ", "400", " == ", "0", ") { sumday = sumday - ", "366", "; }\n        ", "else", "(sumday = sumday - ", "365", ");\n    }\n    year = k;\n    ", "for", " (j = ", "1", "; sumday >", "28", "; j++) {\n        switch (j) {\n            case ", "1", ": temp = ", "31", "; ", "break", ";\n            case ", "2", ": ", "if", " ((year % ", "4", " == ", "0", " && year % ", "100", " != ", "0", ") || year % ", "400", " == ", "0", ") { temp = ", "29", "; ", "break", "; }\n                    ", "else", " { temp = ", "28", "; ", "break", "; }\n            case ", "3", ":    temp = ", "31", "; ", "break", ";\n            case ", "4", ":    temp = ", "30", "; ", "break", ";\n            case ", "5", ":    temp = ", "31", "; ", "break", ";\n            case ", "6", ":    temp = ", "30", "; ", "break", ";\n            case ", "7", ":    temp = ", "31", "; ", "break", ";\n            case ", "8", ":    temp = ", "31", "; ", "break", ";\n            case ", "9", ":    temp = ", "30", "; ", "break", ";\n            case ", "10", ":temp = ", "31", "; ", "break", ";\n            case ", "11", ":temp = ", "30", "; ", "break", ";\n            case ", "12", ":temp = ", "31", "; ", "break", ";\n        }\n            sumday = sumday - temp;\n    }\n    ", "return", "     Date(year,j,sumday);\n};\n\nDate Date::", "operator", "++() {\n    int temp = ", "0", ",i=month;\n    switch (i) {\n    case ", "1", ": temp += ", "31", "; ", "break", ";\n    case ", "2", ": ", "if", " ((year % ", "4", " == ", "0", " && year % ", "100", " != ", "0", ") || year % ", "400", " == ", "0", ") { temp += ", "29", "; ", "break", "; }\n            ", "else", " { temp += ", "28", "; ", "break", "; }\n    case ", "3", ":    temp += ", "31", "; ", "break", ";\n    case ", "4", ":    temp += ", "30", "; ", "break", ";\n    case ", "5", ":    temp += ", "31", "; ", "break", ";\n    case ", "6", ":    temp += ", "30", "; ", "break", ";\n    case ", "7", ":    temp += ", "31", "; ", "break", ";\n    case ", "8", ":    temp += ", "31", "; ", "break", ";\n    case ", "9", ":    temp += ", "30", "; ", "break", ";\n    case ", "10", ":temp += ", "31", "; ", "break", ";\n    case ", "11", ":temp += ", "30", "; ", "break", ";\n    case ", "12", ":temp += ", "31", "; ", "break", ";\n    }\n    ", "if", " (temp == day&&month!=", "12", ") {\n        month++;\n        day = ", "1", ";\n    }\n    ", "else", " ", "if", " (temp == day && month == ", "12", ") {\n        year++;\n        month = ", "1", ";\n        day = ", "1", ";\n    }\n    ", "else", " {\n        day++;\n    }\n    ", "return", " *", "this", ";\n}\nDate Date::", "operator", "--() {\n    int temp = ", "0", ", i = month-", "1", ";\n    switch (i) {\n    case ", "0", ":", "break", ";\n    case ", "1", ": temp += ", "31", "; ", "break", ";\n    case ", "2", ": ", "if", " ((year % ", "4", " == ", "0", " && year % ", "100", " != ", "0", ") || year % ", "400", " == ", "0", ") { temp += ", "29", "; ", "break", "; }\n            ", "else", " { temp += ", "28", "; ", "break", "; }\n    case ", "3", ":    temp += ", "31", "; ", "break", ";\n    case ", "4", ":    temp += ", "30", "; ", "break", ";\n    case ", "5", ":    temp += ", "31", "; ", "break", ";\n    case ", "6", ":    temp += ", "30", "; ", "break", ";\n    case ", "7", ":    temp += ", "31", "; ", "break", ";\n    case ", "8", ":    temp += ", "31", "; ", "break", ";\n    case ", "9", ":    temp += ", "30", "; ", "break", ";\n    case ", "10", ":temp += ", "31", "; ", "break", ";\n    case ", "11", ":temp += ", "30", "; ", "break", ";\n    }\n    ", "if", " (day==", "1", "&& month != ", "1", ") {\n        month--;\n        day = temp;\n    }\n    ", "else", " ", "if", " (day ==", "1", "&& month == ", "1", ") {\n        year--;\n        month = ", "12", ";\n        day = ", "31", ";\n    }\n    ", "else", " {\n        day--;\n    }\n    ", "return", " *", "this", ";\n}\nint main() {\n    Date d1(", "2004", ", ", "12", ",", "31", "), d2(", "2018", ", ", "10", ", ", "15", ");\n    d1.Print();\n    d2.Print();\n    d1-d2;\n    cout << endl;\n\n    Date d3(", "2004", ", ", "1", ", ", "1", "), d4(", "0", ", ", "0", ",", "1928", "),d5;\n    d5 = d3 + d4;\n    d5.Print();\n    \n    cout<<endl<<", "\"ÈÕÆÚ×ÔÔö¡ý\"", "<<endl;\n    d1.Print();\n    ++d1 ;\n    d1.Print();\n\n    cout << endl << ", "\"ÈÕÆÚ×Ô¼õ\"", " << endl;\n    d1.Print();\n    --d1;\n    d1.Print();\n\n    system(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "Action(int room_, int time_, int type_) : room(room_), time(time_), type(type_) {}//?\r\n这句是构造函数的初始化的一种方法，是把room_的值赋值给room，把time_赋值给time，type_赋值给type\r\nbool operator&lt;(const Action &amp;other) const {//?\r\nif(time&lt;other.time) return true;//other.time?\r\nelse if(time==other.time &amp;&amp; type&lt;other.type) return true;//?\r\nelse if(time==other.time &amp;&amp; type==other.type &amp;&amp; room&lt;other.room) return true;//?\r\nreturn false;\r\n这个是重载&lt;符号的函数，const表示函数内容不能被修改，这保护了你函数的安全\r\n如果time&lt;other.time 是判断两个变量的大小。other是你传进来的参数，也就是另外一个类，other.time是类里面的变量time，其他同理\r\n这个意思是如果time小于other.time，就返回true，如果等于，再判断 type，如果 type&lt;other.type那就返回true，\r\n相等就再判断room和other.room，如果room&lt;other.room也还是返回TRUE，\r\n所有都不满足，最后返回return false;\r\n全是手打，很辛苦，求采纳，谢谢，我十分需要你的采纳", "Konwledge_Point": "运算符重载", "Question": ["可以帮忙看看带问号的地方吗？能否详细解释一下，非常感谢，谢谢各位", ["#include ", "\n#include ", "\n#include ", "\nusing namespace std;", "\n\n", "struct Action {", "\n    int room;", "\n    int time;", "\n    int type; // 0:put, 1:get", "\n    Action(int room_, int time_, int type_) : room(room_), time(time_), type(type_) {}//? ", "\n    bool operator<(const Action &other) const {//?", "\n        if(time<other.time) return true;//other.time?", "\n        else if(time==other.time && type<other.type) return true;//?", "\n        else if(time==other.time && type==other.type && room<other.room) return true;//?", "\n        return false;", "\n    }", "\n};", "\n\n", "int main() {", "\n    int N, K;", "\n    scanf(\"%d%d\", &N, &K);", "\n    vector actions;", "\n    vector states(N+1);", "\n    for(int n=1; n<=N; n++) states[n] = n;", "\n\n", "for(int k=0; k<K; k++) {\n    int room, begin, length;\n    scanf(\"%d%d%d\", &room, &begin, &length);\n    actions.push_back(Action(room, begin, 1));\n    actions.push_back(Action(room, begin+length, 0));\n}\nsort(actions.begin(), actions.end());\nfor(int i=0; i<actions.size(); i++) {\n    Action &act = actions[i];//&act什么意思? \n    if(act.type == 0) { // put\n        for(int n=1; n<=N; n++) {\n            if(states[n] == -1) {\n                states[n] = act.room;\n                break;\n            }\n        }\n    }\n    else { // get\n        for(int n=1; n<=N; n++) {\n            if(states[n] == act.room) {\n                states[n] = -1;\n                break;\n            }\n        }\n    }\n}\nfor(int n=1; n<=N; n++) {\n    printf(\"%d \", states[n]);\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; ~Time(){delete(this);};&lt;br /&gt;这根本错误&lt;br /&gt;析构函数里delete你自己new的对象即可&amp;#xff0c;不要去delete别的东西。&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["如何让析构函数不清除调用函数里的类对象", ["今天做“运算符重载”时在类内定义了析构函数，结果执行时发现控制台什么都没输出。删掉析构函数则可以正常运行。", "代码如下：", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n \n", "class", " ", "Time", "{\n", "private", ":\n    ", "int", " mintue;\n    ", "int", " second;\n", "public", ":\n    ", "Time", "(){mintue=", "0", ";second=", "0", ";};\n    ", "Time", "(", "int", " m,", "int", " s);\n    ", "friend", " Time ", "operator", "+(Time&,Time&);\n    ~", "Time", "(){", "delete", "(", "this", ");};\n    ", "int", " ", "getMintue", "()", "{", "return", " ", "this", "->mintue;};\n    ", "int", " ", "getSecond", "()", "{", "return", " ", "this", "->second;};\n};\nTime::", "Time", "(", "int", " m,", "int", " s){\n    mintue=m;\n    second=s;\n}\nTime ", "operator", "+(Time & t1,Time & t2){\n    Time t;\n    t.mintue=t1.mintue+t2.mintue;\n    t.second=t1.second+t2.second;\n    ", "if", "(t.second>=", "60", "){\n        t.second-=", "60", ";\n        t.mintue++;\n        \n    }\n    ", "return", " t;\n}\n\n", "int", " ", "main", "()", "{\n    Time t,", "t_1", "(", "2", ",", "45", "),", "t_2", "(", "7", ",", "15", ");\n    t=t_1+t_2;\n    cout<<", "\"(mintue:second)->\"", "<<t.", "getMintue", "()<<", "\":\"", "<<t.", "getSecond", "()<<endl;\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果为空，什么都没有输出，也没有报错", "\n", "\n", "我认为导致这个结果的原因可能是** 这个析构函数把我类中函数内定义的对象给销毁了，导致传了一个空参返回输出**", "\n", "有没有能创建析构函数后正常运行的修改意见呢？还是说在这种需要调用到类内部函数有对象的类是不能使用含有“delete”的析构函数呢？或者其他可能？", "希望能得到大家的指点 QWQ"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;complex(); 默认构造函数没写函数体&amp;#xff0c;改为 complex() {}&lt;/p&gt;", "Konwledge_Point": "运算符重载", "Question": ["找不到错误在哪里，第一次碰到这个错误，求解", ["\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "complex", "\n{\n", "public", ":\n    ", "complex", "();\n    ", "complex", "(", "double", " r,", "double", " i):", "real", "(r),", "imag", "(i){}\n    ", "void", " ", "display", "()", ";\n    complex ", "operator", "+(complex&);\n    ", "friend", " ostream & ", "operator", "<<(ostream&, complex&);\n", "private", ":\n    ", "double", " real;\n    ", "double", " imag;\n};\n\ncomplex complex::", "operator", "+(complex& b)\n{", "return", " ", "complex", "(real + b.real, imag + b.imag);}\n\nostream& ", "operator", "<<(ostream& output, complex& a)\n{\n    ", "if", "(a.imag>=", "0", ")\n        output << ", "\"(\"", " << a.real << ", "\"+\"", " << a.imag << ", "\"i)\"", " << endl;\n    ", "else", "\n        output << ", "\"(\"", " << a.real << a.imag << ", "\"i)\"", " << endl;\n    ", "return", " output;\n}\n\n\n", "int", " ", "main", "()", "\n", "{\n    ", "complex ", "com1", "(", "3", ", ", "5", ")", ", ", "com2", "(", "7", ",", "-2", ")", ",com3", ";\n    com3 =com1 + com2;\n    cout << com3<<endl;\n\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "严重性    代码    说明    项目    文件    行    禁止显示状态", "错误    LNK1120    1 个无法解析的外部命令    单目运算符重载    1", "严重性    代码    说明    项目    文件    行    禁止显示状态", "错误    LNK2019    无法解析的外部符号 \"public: __cdecl complex::complex(void)\" (??0complex", "@@QEAA@XZ)，函数 ", "main 中引用了该符号    单目运算符重载        1    "]], "Tag": "程序设计"}
{"Answer": "#include＜iostream＞\nusing namespace std;\nclass Array\n{\nprivate:\n    int *a;   int l;\npublic:\n     Array()\n     {\n     \ta=NULL;\n     \tl=0;\n     }\n     Array(int x)\n     {\n     \tint c=0;\n     \ta=new int[x];\n     \twhile (c＜x)\n     \t{\n     \t\tcin＞＞a[c];\n     \t\tcin.get();\n     \t\tc++;\n     \t}\n     \tl=x;\n     }\n     ~Array()\n     {\n     \tdelete []a;\n     }\n     void datain(int f)\n     {\n     \ta[l-1]=f;\n     }\n     friend int big(Array&amp; s,Array&amp; t)\n     {\n     \tif (s.l＞=t.l)\n     \t    return s.l;\n     \telse\n     \t    return t.l;\n     }\n     Array&amp; operator=(const Array &amp;p)\n     {\n     \tl=p.l;\n     \ta=new int[l];\n     \tfor (int j=0;j＜l;j++)\n     \t     a[j]=p.a[j];\n     \treturn *this;\n     }\n     \n     Array(Array &amp;p)\n     {\n     \tl=p.l;\n     \ta=new int[l];\n     \tfor (int j=0;j＜l;j++)\n     \t     a[j]=p.a[j];\n     }\n     \t\n     friend Array operator+(Array&amp; s,Array&amp; t)\n     {\n     \tArray r;\n     \tint BIG=big(s,t);\n     \tr.l=BIG;\n     \tr.a=new int[BIG];\n     \tfor (int i=0;i＜BIG;i++)\n     \t   r.a[i]=s.a[i]+t.a[i];\n     \treturn r;\n     }\n     int average()\n     {\n     \tint all=0,i;\n     \tfor (i=0;i＜l;i++)\n     \t    all+=a[i];\n     \treturn all/l;\n     }\n     void show()\n     {\n     \tfor (int i=0;i＜l;i++)\n     \t    cout＜＜a[i]＜＜\" \";\n     }\n};\nint main()\n{\n\tArray A1(3);\n\tA1.show();\n\tcout＜＜endl;\n\tA1.datain(6);\n\tA1.show();\n\tcout＜＜endl;\n\tcout＜＜A1.average()＜＜endl;\n\tArray B(3);\n\tArray C;\n\tC=A1+B;\n\tC.show();\n\treturn 0;\n}", "Konwledge_Point": "运算符重载", "Question": ["c++基础不好，谁帮我改改", ["#include＜iostream＞", "\nusing namespace std;", "\nclass Array", "\n{", "\nprivate:", "\n    int *a;   int l;", "\npublic:", "\n     Array()", "\n     {", "\n        a=NULL;", "\n        l=0;", "\n     }", "\n     Array(int x)", "\n     {", "\n        int c=0;", "\n        a=new int[x];", "\n        while (c＜x)", "\n        {", "\n            cin＞＞a[c];", "\n            cin.get();", "\n            c++;", "\n        }", "\n        l=x;", "\n     }", "\n     ~Array()", "\n     {", "\n        delete []a;", "\n     }", "\n     void datain(int f)", "\n     {", "\n        a[l-1]=f;", "\n     }", "\n     friend int big(Array& s,Array& t)", "\n     {", "\n        if (s.l＞=t.l)", "\n            return s.l;", "\n        else", "\n            return t.l;", "\n     }", "\n     void operator=(Array &p)", "\n     {", "\n        l=p.l;", "\n        a=new int[l];", "\n        for (int j=0;j＜l;j++)", "\n             a[j]=p.a[j];", "\n     }", "\n\n", " Array(Array &p)\n {\n    l=p.l;\n    a=new int[l];\n    for (int j=0;j＜l;j++)\n         a[j]=p.a[j];\n }\n\n friend Array operator+(Array& s,Array& t)\n {\n    Array r;\n    int BIG=big(s,t);\n    r.l=BIG;\n    r.a=new int[l];\n    for (int i=0;i＜BIG;i++)\n       r.a[i]=s.a[i]+t.a[i];\n    return r;\n }\n int average()\n {\n    int all=0,i;\n    for (i=0;i＜l;i++)\n        all+=a[i];\n    return all/l;\n }\n void show()\n {\n    for (int i=0;i＜l;i++)\n        cout＜＜a[i]＜＜\" \";\n }\n", "\n\n", "};", "\nint main()", "\n{", "\n    Array A1(3);", "\n    A1.show();", "\n    cout＜＜endl;", "\n    A1.datain(6);", "\n    A1.show();", "\n    cout＜＜endl;", "\n    cout＜＜A1.average()＜＜endl;", "\n    Array B(3);", "\n    Array C;", "\n    C=A1+B;", "\n    C.show();", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;试试这样&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Counter&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; Counter &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Counter&amp;amp; c1, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Counter&amp;amp; c2);\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;getm_n&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; n;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;setm_n&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;n &amp;#61; n;\n    }\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    \n};\n\nCounter &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Counter&amp;amp; c1, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Counter&amp;amp; c2)\n{\n    Counter temp;\n    temp.n &amp;#61; c1.n &amp;#43; c2.n;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Counter c1;\n    c1.&lt;span class=\"hljs-built_in\"&gt;setm_n&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    Counter c2;\n    c2.&lt;span class=\"hljs-built_in\"&gt;setm_n&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n    Counter c3 &amp;#61; c1 &amp;#43; c2;\n    cout &amp;lt;&amp;lt; c3.&lt;span class=\"hljs-built_in\"&gt;getm_n&lt;/span&gt;();\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "运算符重载", "Question": ["关于#c++#的问题，如何解决？", ["c++题目：定义一个类Counter,包含私有成员int n，重载运算符+，实现对象相加。求解答。", "\n", "class", " ", "Counter", "\n{\n\n    ", "friend", " Counter ", "operator", "+(Counter& c1, Counter& c2);\n", "public", ":\n    ", "int", "  ", "getm_n", "(", "int", " n)", "\n    ", "{\n        ", "int", " m_n = n;\n        ", "return", " m_n;\n    }\n    ", "void", " ", "setm_n", "(", "int", " n)", "\n    ", "{\n        ", "int", " m_n = n;\n    }\n", "private", ":\n    ", "int", " n;\n    \n};\n Counter ", "operator", "+(Counter& c1, Counter& c2)\n{\n    Counter temp;\n    temp.n = c1.n + c2.n;\n    ", "return", " temp;\n}\n", "int", " ", "main", "()", "\n", "{\n    Counter c1;\n    c1.", "setm_n", "(", "1", ");\n    Counter c2;\n    c1.", "setm_n", "(", "2", ");\n    Counter c3;\n    Counter c3 = c1 + c2;\n    cout << c3.getm_n;\n    \n}\n\n", "\n", "我的最后一行错了，编译器给的原因是：", "指向绑定函数的指针只能用于调用函数        "]], "Tag": "程序设计"}
