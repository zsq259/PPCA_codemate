{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;min&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; b, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; c)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ((a - b) &amp;gt;&amp;gt; &lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;) &amp;amp;&amp;amp; ((a - c) &amp;gt;&amp;gt; &lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;) ? a : (b - c) &amp;gt;&amp;gt; &lt;span class=\"hljs-number\"&gt;31&lt;/span&gt; ? b : c;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a, b, c;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;c);   \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m &amp;#61; &lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(a, b, c);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, m);\n    &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算符", "Question": ["在不使用关系运算符的情况下判断最小值", ["如何在不使用关系运算符的情况下，判断输入的三个数的最小值", "使用语音：c语言"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一题&amp;#xff1a;&lt;br /&gt;x &amp;#61; y-- &amp;lt;&amp;#61;x || x&amp;#61;y!&amp;#61;z;&lt;br /&gt;其实这个等式是一个错误的等式&amp;#xff0c;因为等号的优先级最低&amp;#xff0c;所以x&amp;#61;y!&amp;#61;z这里x后面的等号会报错。&lt;br /&gt;所以这里只能猜测出题者的意图&amp;#xff0c;按照这个思路&amp;#xff0c;公式可以分解为&amp;#xff1a;&lt;br /&gt;&amp;#xff08;1&amp;#xff09;y &amp;lt;&amp;#61;x (y&amp;#61;2,x&amp;#61;1,所以y&amp;lt;&amp;#61;x的结果是0&amp;#xff09;&lt;br /&gt;&amp;#xff08;2&amp;#xff09;x&amp;#61;y!&amp;#61;z这个先计算 y!&amp;#61;z&amp;#xff0c;结果是1&amp;#xff0c;所以x&amp;#61;1&lt;br /&gt;&amp;#xff08;3&amp;#xff09;x &amp;#61; 0 || 1 &amp;#xff08;0是步骤1的结果&amp;#xff0c;1是步骤2的结果&amp;#xff09;&amp;#xff0c;x &amp;#61; 1&lt;br /&gt;&amp;#xff08;4&amp;#xff09;y-- &amp;#xff08;y--最后计算&amp;#xff09;&amp;#xff0c;y &amp;#61; 1&lt;br /&gt;所以显示的结果就是&amp;#xff1a;1,1&lt;br /&gt;第二题&amp;#xff1a;&lt;br /&gt;x &amp;#61; x || y &amp;amp;&amp;amp; z;  先计算x || y &amp;#xff0c;x和y都非0&amp;#xff0c;所以x || y 的结果是1&amp;#xff0c;然后计算1 &amp;amp;&amp;amp; z &amp;#xff0c;z&amp;#61;0&amp;#xff0c;所以结果就是0&amp;#xff0c;所以x &amp;#61; 0;&lt;br /&gt;printf中x &amp;amp;&amp;amp; !y || z &amp;#xff0c;先计算 x &amp;amp;&amp;amp; !y &amp;#xff0c;x&amp;#61;0&amp;#xff0c;所以结果是0&amp;#xff0c;然后计算 0 || z&amp;#xff0c;z&amp;#61;0&amp;#xff0c;所以结果仍然是0&amp;#xff0c;&lt;br /&gt;所以最后的结果是&amp;#xff1a;0,0&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C语言  关系运算符、逻辑运算符与表达式的程序阅读题", ["求解释printf上面的语句，不知道从哪里开始看，", "第一题知道或前面为假，但是或后面不知道怎么看。", "第二题，！怎么看。求解释。", "\n"]], "Tag": "程序设计"}
{"Answer": "String sl=sl;  sl 是你sl 的变量名\r\nString where =\"name='sl'\";\r\n应该是   testMap.put(\"where\",where)，\r\nand  ${where}", "Konwledge_Point": "关系运算符", "Question": ["Mybatis报无效的关系运算符异常", ["ORA-00920:无效的关系运算符", "\n工作需要将where条件封装到map中，where=name=ls，通过调试能获取name=ls，但查询时出现异常", "\nwhere 1=1", "\nand #{where}", "\n把#{where}换成1=1可以查询 map封装的where参数就是不行，哪位高手帮忙解决问题啊。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;语句短路了&amp;#xff0c;只进行了m&amp;#61;a&amp;gt;b语句的比较&lt;/strong&gt;&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;&lt;strong&gt;具体来说就是&amp;#xff0c;逻辑&amp;amp;&amp;amp; 从左到右执行 先执行m&amp;#61;a&amp;gt;b 由于a&amp;lt;b 所以m&amp;#61;0 m&amp;#61;0导致逻辑&amp;amp;&amp;amp;左侧为0&amp;#xff0c;进而导致这个无论后面结果如何&amp;#xff0c;都不再执行后面的语句&amp;#xff0c;也就是短路了。&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;希望对题主有所帮助&amp;#xff01;可以的话&amp;#xff0c;帮忙点个采纳&amp;#xff01;&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "关系运算符", "Question": ["关系运算符和逻辑运算符优先级", ["为什么最后的结果n是1？大括号强行优先级没有用处嘛，还是别的知识点"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include \"stdio.h\"\r\n#include \"math.h\"\r\nint main()\r\n{\r\nfloat x;\r\nfloat y;\r\nprintf(\"input x:\");\r\nscanf(\"%f\",&amp;x);\r\ny=(0&lt;=x&amp;&amp;x&lt;20)?5*x+11:\r\n(\r\n    (20&lt;=x&amp;&amp;x&lt;40)?sin(x)+cos(x):\r\n    (\r\n        (40&lt;=x&amp;&amp;x&lt;60)?exp(x)-1:\r\n        (\r\n            (60&lt;=x&amp;&amp;x&lt;80)?log(x+1):0\r\n        )\r\n    )\r\n);\r\nprintf(\"%f\",y);\r\n}\r\n```", "Konwledge_Point": "关系运算符", "Question": ["请问这个c程序 如何用嵌套的条件运算符计算，看下我的对吗？", ["\n\n", "#include\"stdio.h\"", "\n#include\"math.h\"", "\nvoid main()", "\n{", "\nfloat x;", "\nfloat y;", "\nprintf(\"input x:\");", "\nscanf(\"%f\",&x);", "\n(0<=x&&x\ny=sin(x)+cos(x):", "\n(40\ny=exp(x)-1:", "\n(60\ny=log(x+1):", "\n(0>x&&x>=80);", "\nprintf(\"y=0\");", "\nprintf(\"%f\",y);", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先判断10&amp;gt;x,得到结果y再判断y&amp;gt;1&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["c++中关系运算符可以连续使用是什么意思?", ["例如，书本上说可以这么写：10＞x＞1，结合方向从左至右。这是什么意思呢？看不太明白(ಥ_ಥ)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改成如下格式即可&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-symbol\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;p1&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;p2&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=\"hljs-built_in\"&gt;p2&lt;/span&gt; &amp;#61;&amp;#61; &lt;span class=\"hljs-built_in\"&gt;p3&lt;/span&gt;)\n{\n  cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算符", "Question": ["c++如何实现关系运算符==的重载使之可以**连续使用**？", ["问题", "\n", "c++如何实现关系运算符==的重载使之可以", "连续使用", "？", "定义一个点类：", "\n", "class", " ", "Point", "\n{\n", "private", ":", "//定义两个数表示一个点的坐标", "\n    float x;\n    float y;\n", "public", ":", "//构造函数", "\n    Point(float x,float y)\n    {\n        ", "this", "->x = x;\n        ", "this", "->y = y;\n    }\n    ", "//重载运算符==（双目）", "\n    Point ", "operator", " ==(Point p02)\n    {\n        ", "if", " (", "this", "->x = p02.x && ", "this", "->y == p02.y)\n        {\n            ", "return", " p02;\n        }\n    }\n};\n", "\n", "main函数如下：", "\n", "int", " main()\n{\n    ", "//这样写我是可以理解的", "\n     Point ", "p1", " = new Point(", "3", ",", "4", ")", ";", "\n     Point ", "p1", " = new Point(", "3", ",", "4", ")", ";", "\n     Point ", "p1", " = new Point(", "3", ",", "4", ")", ";", "\n    ", "if", "(", "p1", " == ", "p2", ")\n    {\n        cout<<", "\"true\"", "<<endl", ";", "\n    }\n    ", "//但是这样写就会报错", "\n    ", "if", "(", "p1", " == ", "p2", " == ", "p3", ")\n    {\n        cout<<", "\"true\"", "<<endl", ";", "\n    }\n    ", "//我知道是因为==返回的bool类型所以报错，但是应该怎么改才可以让这个代码正确运行呢？求助各位", "\n    delete ", "p1", ";", "\n    delete ", "p2", ";", "\n    delete ", "p3", ";", "\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个a得值赋值给b&amp;#xff0c;所以b&amp;#61;2  之后判断b&amp;#61;&amp;#61;2 等于2为true&lt;br /&gt;第二个选算c-a得值4-2&amp;#61;2   之后判断2&amp;#61;&amp;#61;a  a得值是2  所以也为true&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C++运算符之关系运算符", ["int a=2,b=3，c=4;", "b=a==2", "c-a==a", "为什么是true"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里的1 2 3.... 是作者自己标的&amp;#xff0c;并不是什么标准。&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C语言关系运算符优先级问题", ["在Turbo C中大于等于优先级是10？查了很多资料都是6啊，C语言不是就一个标准吗？", "\n", "10  不应该就一个吗   按位或     表达式|表达式    左到右      双目运算符"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里需要特别说明一下&amp;#xff0c;&amp;amp;&amp;amp;和||两个符号的计算过程&lt;/p&gt;\n\n&lt;p&gt;&amp;amp;&amp;amp;要求两侧都为TRUE才成立&amp;#xff0c;有一个为FALSE则为FALSE。首先计算左侧表达式是否为TRUE&amp;#xff0c;如果为FALSE&amp;#xff0c;则右边的表达式是不计算的&lt;/p&gt;\n\n&lt;p&gt;同样||要求两侧至少有一个为TRUE才成立&amp;#xff0c;都为FALSE时则为FALSE。首先计算左侧表达式是否为TRUE&amp;#xff0c;如果为TRUE&amp;#xff0c;则结果为TRUE&amp;#xff0c;右侧表达式是不计算的&lt;/p&gt;\n\n&lt;p&gt;知道这两个事&amp;#xff0c;你的问题应该就没有了&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C语言   关系运算符与表达式", ["答案是选项C,", "我的理解是c是7，d是8,7>8是假0，所以把0赋值给n，然后n就为2了", "求解释", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为i*j&amp;#61;&amp;#61;6优先级高&amp;#xff0c;i&amp;#61;2,j&amp;#61;3&amp;#xff0c;所以这个判断是成立的&amp;#xff0c;结果就是1&amp;#xff0c;然后赋值给k&amp;#xff0c;因此k值为1啊&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["printf里没有关系运算符吧，为什么得1", ["\n", "这个程序的printf里没有运算符，为什么还是得到1", "本人刚入门c语言，请各位赐教"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;三目运算个数&amp;#xff1a;条件 ? 条件为真返回这里的值 : 条件为假返回这里的值;&lt;br /&gt;你的 a &amp;gt;&amp;#61; b ? max &amp;#61; a : max &amp;#61; b;可以修改为如下两种方式&lt;br /&gt;方式一&amp;#xff1a;a &amp;gt;&amp;#61; b ? (max &amp;#61; a) : (max &amp;#61; b);&lt;br /&gt;方式二&amp;#xff1a;max&amp;#61; (a&amp;gt;&amp;#61;b) ? a : b;&lt;br /&gt;一般采用的是方式二的写法。&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["不知道关系运算符的使用哪里出错了", ["a>=b ? max=a :max=b;", "凑字数asdfgyqjegxoqbxgqoxyqkcyqkcykabsvsixgajhxiwbixbshhs"]], "Tag": "程序设计"}
{"Answer": "你确定你这个sql语句是用来建索引的？", "Konwledge_Point": "关系运算符", "Question": ["ORACLE 新建CHECK索引，报错无效的关系运算符", ["语句", "\nALTER TABLE CODE_EXAM_ITEM ADD CONSTRAINT SYS_C0012462 CHECK (CODE_EXAM_ITEM_ID) ENABLE  ;"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;注要考核运算符优先级的问题&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/057145492246157.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;题中涉及的运算符从高到低&amp;#xff1a; ! / % &amp;#43; - &amp;lt; &amp;gt;&amp;#61; &amp;amp;&amp;amp; ||&lt;br /&gt;把选择项的运算按此算出结果&amp;#xff0c;0为假值&amp;#xff0c;非0即为真&lt;br /&gt;int a&amp;#61;1,b&amp;#61;3;&lt;br /&gt;A. a&amp;gt;&amp;#61;2||!b&amp;amp;&amp;amp;b&amp;lt;4   &amp;#61;》 0||0&amp;amp;&amp;amp;0&lt;br /&gt;B. b-a&amp;amp;&amp;amp;!a||a-b&amp;amp;&amp;amp;a/b  &amp;#61;&amp;gt; 1&amp;amp;&amp;amp;0||1&amp;amp;&amp;amp;0 &amp;#61;&amp;gt; 0||0&lt;br /&gt;C. a-!a%b&amp;amp;&amp;amp;!b-!b%b  &amp;#61;&amp;gt; 1-0 &amp;amp;&amp;amp; 0 - 0 &amp;#61;&amp;gt; 1 &amp;amp;&amp;amp; 0&lt;br /&gt;D.a&amp;#43;b&amp;amp;&amp;amp;a-b&amp;amp;&amp;amp;b-3&amp;amp;&amp;amp;a||b  &amp;#61;&amp;gt; 1&amp;amp;&amp;amp;1&amp;amp;&amp;amp;0&amp;amp;&amp;amp;1 || 1 &amp;#61;&amp;#61;&amp;gt; 1&lt;br /&gt;所以选 D&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["关系运算符运算过程请说明具体的运算过程", ["问题遇到的现象和发生背景", "\n", "int a=1,b=3;,则下列表达式的结果为“真”的是：（）", "\n", "A. a>=2||!b&&b<4 B. b-a&&!a||a-b&&a/b", "\n", "C. a-!a%b&&!b-!b%b D.a+b&&a-b&&b-3&&a||b", "请说明A\\BC\\D四个选项的具体计算过程", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;No, they aren't strict.&lt;/p&gt;\n\n&lt;p&gt;They can compare most types against each other, and cast as needed. For instance there's support for string comparisons:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; $true = \"a\" &amp;lt; \"b\";\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Internally that's &lt;code&gt;zendi_smart_strcmp()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you want to do strict comparisons, you can just check the types yourself, or cast as needed.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "关系运算符", "Question": ["在PHP中使用小于，大于，gte，lte的关系运算符是否使用类型转换？", ["\n\n", "Do relational operators like less than, greater than, gte, lte use type conversion?  If they do, why are there no strict comparison relational operators like !== or === ?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;toString属于函数调用了&amp;#xff0c;优先级18&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/715421143056199.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;具体可以看这个&lt;a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\" id=\"textarea_1650340832998_1650341124648_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["js中运算符优先级问题", ["var num = 10;", "console.log(5 == num / 2 && (2 + 2 * num).toString() === '22');", "            5 ==   5     &&      22.toString（）         === '22'", "\n", "如题，解到这里搞不清楚了，我学到的是如下的顺序", "1 小括号                ()", "2 一元运算符            ++ --  !", "3 算数运算符            先 * /%后+-", "4 关系运算符            > >= < <=", "5 相等运算符            == != === !==", "6 逻辑运算符            先 && 后 ||", "7 赋值运算符            =", "8 逗号运算符            ，", "\n", "那像toString这类改变数据类型的函数在运算符优先级里处在什么位置呢？"]], "Tag": "程序设计"}
{"Answer": "试试这种格式，case when 需要指定 列名（fileA替换为对应的列名）\r\nselect PROPERID, \r\nCASE \r\n    WHEN fileA='085EB2A2A389417D8C581E3D52BDDB0C' THEN '1'\r\n    ELSE '0' END \r\nFROM MATERIAL_INFO", "Konwledge_Point": "关系运算符", "Question": ["sql语句提示 invalid relational operator", ["select PROPERID, \nCASE\n    WHEN '085EB2A2A389417D8C581E3D52BDDB0C' THEN '1'\n    ELSE '0' END CASE\nFROM MATERIAL_INFO\n", "\n\n", "为什么会提示不合法的关系运算符呢？"]], "Tag": "程序设计"}
{"Answer": "字符串判断相等最好实用 sss.equals(\"+\"),因为==判断基本数据类型变量，而非基本数据类型变量的判断的是内存地址", "Konwledge_Point": "关系运算符", "Question": ["求助各位大神为什么输入运算符号没反应", ["我想做一个四则运算", "\n但是我输入 + - * / 的运算符号的时候无法通过", "\n1，我不知道运算符号算不算字符串，也不知道应该用什么来读取运算符号？", "\n2，之后我又想把运算符号转换成ascll码，但是怎么从控制台接受运算符号然后转换ascll码？", "\n3，如果io输入流不行的话，别的方法怎样来实现？", "\n\n", "import java.io.*;", "\n\n", "public class A002 ", "\n{", "\n    public static void main(String []args)", "\n    {", "\n        try", "\n        {", "\n            InputStreamReader isr=new InputStreamReader(System.in);", "\n\n", "        BufferedReader br=new BufferedReader(isr);\n\n        System.out.println(\"输入第一个数字:\");\n        String aaa=br.readLine();\n\n        System.out.println(\"请输入运算符号\");\n        String sss=br.readLine();\n\n        System.out.println(\"输入第二个数字:\");\n        String bbb=br.readLine();\n\n        int num1=Integer.decode(aaa);\n        int num2=Integer.decode(bbb);\n\n        if(sss==\"+\")\n        {System.out.println(\"=\"+(num1+num2));}\n        else if(sss==\"-\")\n        {System.out.println(\"=\"+(num1-num2));}\n        else if(sss==\"*\")\n        {System.out.println(\"=\"+(num1*num2));}\n        else if(sss==\"/\")\n        {System.out.println(\"=\"+(num1/num2));}\n    }\n\n    catch(Exception e)\n    {e.printStackTrace();}\n\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "都是基本题：https://blog.csdn.net/chris_mao/article/details/83220962", "Konwledge_Point": "关系运算符", "Question": ["关于一个数据库关系代数问题", ["请用五种基本关系代数运算符，推出其他运算符                 ", "\n\n", "                                                                                                                                        请用五种基本关系代数运算符，推出其他运算符                 \n\n                                                                                                                                        请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符                 \n                                                                   请用五种基本关系代数运算符，推出其他运算符\n"]], "Tag": "程序设计"}
{"Answer": "http://www.2cto.com/kf/201305/211397.html", "Konwledge_Point": "关系运算符", "Question": ["c++疑问：以哪三种方式被重载？", ["string类对全部6个关系运算符>、>=、<、<=、==、!=都进行了重载，如果在机器排列序列中，一个对象位于另一个对象的前面，则前者被视为小于后者，如果机器排列序列为ASCII码，则数字将小于大写字符，而大写字符小于小写字符，对于每个关系运算符，都以三种方式被重载，以便能够将string对象与另一个string对象，c-风格字符串进行比较，并能够将c-风格字符串与string对象进行比较"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Y&amp;#61;&amp;#61;2是一个判断条件&amp;#xff0c;结果为boolean值为真 &amp;#xff0c;也就是1&amp;#xff0c;所以执行case 1 打印* 后边break&amp;#xff0c;跳出这个switch&amp;#xff0c;执行下一个&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["关于#c##的问题：执行case0，所以执行case1对吧", ["x等于0，执行case0，y等于2，逻辑值为一，所以执行case1对吧？", "是不是只要是关系运算符就使用逻辑值吗？", "求评论区给我讲一下"]], "Tag": "程序设计"}
{"Answer": "这些都是英文缩写。我建议你先学习英文，再来学任何现代的科学。\r\n比如 eq = equal = 相等\r\nne = non-equal = 不相等\r\nlt = less than = 小于\r\ngt = greater than = 大于\r\nle = less or equal = 小于等于，等等。\r\n由此可见，不会英文，学习这些如同背密码。", "Konwledge_Point": "关系运算符", "Question": ["微机原理中的一些指令操作如何使用", ["在微机原理中，关系运算符：EQ,NE,LT,GT,LE,GE都是什么意思？怎么使用？操作指令：CLC,CLD,STI,STC,CMC,STD,CLI都是什么作用？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;10&amp;#61;&amp;#61;1&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["c语言while中描述要求时，为什么使用==时while不会循环？", ["这个我改成源.c后还是这样。", "这个>=和==不都是关系运算符吗，为什么用==是它会直接跳过循环，用>=则会进入循环？", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运行结果如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/550493011836187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Fraction&lt;/span&gt;&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    double mFz;\n    double mFm;\n    &lt;span class=\"hljs-comment\"&gt;//构造函数&lt;/span&gt;\n    Fraction(double fz&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,double fm&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;){mFz&amp;#61;fz,mFm &amp;#61;fm;}\n    &lt;span class=\"hljs-comment\"&gt;//拷贝构造函数&lt;/span&gt;\n    Fraction(Fraction &amp;amp;c){mFm&amp;#61;c.mFm;mFz&amp;#61;c.mFz;}\n    &lt;span class=\"hljs-comment\"&gt;//计算分数值&lt;/span&gt;\n    double value()\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(mFm!&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) \n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; mFz/mFm; \n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; \n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//&lt;/span&gt;\n    Fraction &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Fraction c)\n    {\n        mFm&amp;#61;c.mFm;\n        mFz&amp;#61;c.mFz;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    Fraction &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Fraction c)\n    {\n        mFz *&amp;#61; c.mFz;\n        mFm *&amp;#61; c.mFm;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    bool &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;&amp;#61;(Fraction &amp;amp;c)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;value() &amp;#61;&amp;#61; c.value())\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(mFz &amp;#61;&amp;#61; c.mFz &amp;amp;&amp;amp; mFm&amp;#61;&amp;#61;c.mFm)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    friend ostream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;( ostream &amp;amp; os,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Fraction &amp;amp; c);\n    friend istream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;( istream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;,Fraction &amp;amp; c);\n\n    Fraction  &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; /(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Fraction b)\n    {\n        Fraction c;\n        c.mFz &amp;#61; mFz*b.mFz;\n        c.mFm &amp;#61; mFm*b.mFm;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n};\n\nostream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;( ostream &amp;amp; os,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Fraction &amp;amp; c)\n{\n    os &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt; c.mFz &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; c.mFm&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;)&amp;#34;&lt;/span&gt; ;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n\nistream &amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream &amp;amp;&lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;,Fraction &amp;amp;c)\n{\n    char ch;\n    &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &amp;gt;&amp;gt; c.mFz &amp;gt;&amp;gt; ch &amp;gt;&amp;gt; c.mFm;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt;;\n}\n\nint main()\n{\n    Fraction a(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    Fraction b(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;a&amp;lt;&amp;lt;endl;\n    cout &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;\n    Fraction c &amp;#61; a; &lt;span class=\"hljs-comment\"&gt;//拷贝构造函数&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;c &amp;lt;&amp;lt;endl; &lt;span class=\"hljs-comment\"&gt;//显示c&lt;/span&gt;\n    c *&amp;#61; b;\n    cout &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c*&amp;#61;b后  c&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt; c&amp;lt;&amp;lt;endl; &lt;span class=\"hljs-comment\"&gt;//显示乘以b后的数&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c&amp;#61;&amp;#61;b)\n    {\n        cout &amp;lt;&amp;lt;c&amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;等于&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;\n    }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        cout &amp;lt;&amp;lt; c&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;不等于&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl;\n\n\n    Fraction d;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入一个分数&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; d; &lt;span class=\"hljs-comment\"&gt;//输入d&lt;/span&gt;\n    cout &amp;lt;&amp;lt; d&amp;lt;&amp;lt;endl; &lt;span class=\"hljs-comment\"&gt;//输出&lt;/span&gt;\n\n    Fraction e &amp;#61; a/d;\n    cout &amp;lt;&amp;lt;a&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;d &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;e&amp;lt;&amp;lt;endl;\n\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算符", "Question": ["每日一练哇，大家都有什么好办法呐", ["设计一个分数类（Fraction）：数据成员包括分子（m_numerator）和分母（m_denominator），分子默认值为0，分母默认值为1。需要满足如下条件：", "（1）具有分子和分母两个形参的构造函数；", "（2）具有拷贝构造函数；", "（3）实现计算分数值的操作；", "（4）实现=运算符和*=运算符的重载；（成员函数）", "（5）实现关系运算符==的重载，判断两个Fraction类是否相等；（普通函数）", "（6）实现输入输出运算符的重载（友元函数）；", "（7）实现算术运算符/的重载，实现两个分数的除法运算（友元函数）。"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/qq1449301756/article/details/47702997", "Konwledge_Point": "关系运算符", "Question": ["请教，在C++语言里左值和右值分别和运算符重载的实现有什么关系？", ["请教，在C++语言里左值和右值分别和运算符重载的实现有什么关系？运算符重载怎么看出是哪个方式实现的？"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include &lt;iostream&gt;\r\nusing namespace std;\r\n\r\nclass Stonewt\r\n{\r\nprivate:\r\n\tint stone;\r\n\tdouble pounds;\r\npublic:\r\n\tStonewt()\r\n\t{\r\n\t\tstone = 0;\r\n\t\tpounds = 0.0;\r\n\t}\r\n\tStonewt(double lbs)\r\n\t{\r\n\t\tstone = (int)lbs / 14;\r\n\t\tpounds = lbs - ((int)lbs / 14 * 14);\r\n\t}\r\n\tStonewt(int stn, double lbs)\r\n\t{\r\n\t\tstone = stn + (int)lbs / 14;\r\n\t\tpounds = lbs - ((int)lbs / 14 * 14);\r\n\t}\r\n\tvoid show()\r\n\t{\r\n\t\tcout &lt;&lt; stone &lt;&lt; \"stn \" &lt;&lt; pounds &lt;&lt; \"lbs.\" &lt;&lt; endl;\r\n\t}\r\n\tbool operator &gt; (const Stonewt &amp;s)\r\n\t{\r\n\t\tif (stone == s.stone)\r\n\t\t\treturn pounds &gt; s.pounds;\r\n\t\telse\r\n\t\t\treturn stone &gt; s.stone;\r\n\t}\r\n\tbool operator &lt; (const Stonewt &amp;s)\r\n\t{\r\n\t\tif (stone == s.stone)\r\n\t\t\treturn pounds &lt; s.pounds;\r\n\t\telse\r\n\t\t\treturn stone &lt; s.stone;\r\n\t}\r\n\tbool operator == (const Stonewt &amp;s)\r\n\t{\r\n\t\tif (stone == s.stone)\r\n\t\t\treturn pounds == s.pounds;\r\n\t\telse\r\n\t\t\treturn false;\r\n\t}\r\n\tbool operator &gt;= (const Stonewt &amp;s)\r\n\t{\r\n\t\treturn *this &gt; s || *this == s;\r\n\t}\r\n\tbool operator &lt;= (const Stonewt &amp;s)\r\n\t{\r\n\t\treturn *this &lt; s || *this == s;\r\n\t}\r\n\tbool operator != (const Stonewt &amp;s)\r\n\t{\r\n\t\treturn !(*this == s);\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tStonewt arr[6] = { Stonewt(28.5), Stonewt(50.1), Stonewt(1, 2.1) };\r\n\tarr[3] = Stonewt(1, 20.0);\r\n\tarr[4] = Stonewt(12, 0.4);\r\n\tarr[5] = Stonewt(12, 0.6);\r\n\tStonewt max = arr[0];\r\n\tStonewt min = arr[0];\r\n\tint n = 0;\r\n\tStonewt c = Stonewt(11, 0.0);\r\n\tfor (int i = 0; i &lt; 6; i++)\r\n\t{\r\n\t\tarr[i].show();\r\n\t\tif (arr[i] &gt; max) max = arr[i];\r\n\t\tif (arr[i] &lt; min) min = arr[i];\r\n\t\tif (arr[i] &gt;= c) n++;\r\n\t}\r\n\tcout &lt;&lt; \"max \"; max.show();\r\n\tcout &lt;&lt; \"mix \"; min.show();\r\n\tcout &lt;&lt; \"&gt; 11 stone: \" &lt;&lt; n &lt;&lt; endl;\r\n\treturn 0;\r\n}\r\n```", "Konwledge_Point": "关系运算符", "Question": ["这道编程题怎么做？本人小白。", ["重载全部6个关系运算符，运算符对pounds成员进行比较，并返回一个bool值，编程，它声明一个包含6个Stonewt对象的数组，并在数组声明中初始化前3个对象。然后使用循环来读取用于设置剩余3个数组元素的值。接着报告最小的元素，最大的元素以及大于或等于11英石的元素的数量。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/38987050613618.png\" /&gt;&lt;/p&gt;&lt;br /&gt;你这个while是个空循环啊&lt;br /&gt;你在最后加了个分号吧while结束掉了&lt;br /&gt;而且判断相等&amp;#61;&amp;#61;符号是大于赋值符号&amp;#61;的,所以会现进行比较,再将比较结果赋给ch,所以你的ch里存放的实际是一个bool值0&lt;br /&gt;改为&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; ch;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; ((ch &amp;#61; &lt;span class=\"hljs-built_in\"&gt;getchar&lt;/span&gt;() )&amp;#61;&amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;)\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;ch &amp;#61; %d\\n&amp;#34;&lt;/span&gt;, ch);\n    &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;即可.&lt;br /&gt;&lt;strong&gt;有帮助望采纳&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["字符变量与字符常量的比较问题", ["执行下面的程序段，输入字符 ", "A", "。", "我的理解是：(关系运算符 ", "==", " 的优先级高于赋值运算符 ", "=", ")", "将输入的字符和字符常量 ", "A", " 进行比较，得出一个布尔值 ", "1", "，将 ", "1", " 赋值给字符变量 ", "ch", "，此时 ", "ch", " 的值应该是 ", "1", "。", "\n", "test.c", "\n\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<Windows.h>", "\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "char", " ch;\n\n    ", "while", " (ch = ", "getchar", "() == ", "'A'", ");\n    ", "printf", "(", "\"ch = %d\\n\"", ", ch);\n\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n", "\n", "但是输出的是 ", "0", "\n", "\n", "不知道我哪里搞错了？"]], "Tag": "程序设计"}
{"Answer": "数据库驱动用的是什么（jar包）", "Konwledge_Point": "关系运算符", "Question": ["JDBC里的sql语句", ["我有一条语句在PL/SQL里可以执行，为什么在JDBC里放到String sql =  \"...\" 就不能执行呢，老是报这样的错误", "\njava.sql.SQLException: ORA-00920: 无效的关系运算符。", "\n语句里有中文，可是其他有的语句可以执行。", "\n就是这个语句有点儿长，不知道为什么。求会的人帮一下！", "\n在线中。。。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;move(...)有问题&amp;#xff0c;如果你不介意可以将&lt;/p&gt;\n\n&lt;p&gt;else if (s &amp;#61;&amp;#61; 0)&lt;/p&gt;\n\n&lt;p&gt;    {&lt;!-- --&gt;&lt;br /&gt;\n       // ifflag &amp;#61; true; 去掉&lt;br /&gt;\n        return 0;&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;仔细确认下&amp;#xff0c;当ifflag &amp;#61; false时&amp;#xff0c;会继续多次执行move(..),保证此时ifflag不会在move永远被修改为false&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["急急急急急。c++赋值语句无效，真心求教", ["\n", "#pragma once\n#include<string.h>\n#include<stdio.h>\n\nstruct Data\n{\npublic:\n\tchar* name;\n\tint num;\n\tchar* type;\n};\n\nclass ChainListNode\n{\npublic:\n\tData data;\n\tChainListNode* nextNode;\n};\n\nclass ChainListHeadNode\n{\npublic:\n\tChainListHeadNode()\n\t{\n\t\tnextNode = nullptr;\n\t}\n\tChainListNode* nextNode;\n};\n\nclass ChainList\n{\npublic:\n\tChainListHeadNode* firstNode;\n\n\tChainList()\n\t{\n\t\tlength = 0;\n\t\tfirstNode = new ChainListHeadNode;\n\t\tfirstNode->nextNode = nullptr;\n\t}\n\n\t~ChainList()\n\t{\n\t\tChainListNode* current;\n\t\tcurrent = firstNode->nextNode;\n\t\twhile (firstNode->nextNode)\n\t\t{\n\t\t\tcurrent = current->nextNode;\n\t\t\tdelete firstNode->nextNode;\n\t\t\tfirstNode->nextNode = current;\n\t\t}\n\t\tdelete firstNode;\n\t}\n\n\tbool Insert(char* newName, int newNum, char* newType)\n\t{\n\t\tChainListNode* newNode = new ChainListNode;\n\t\tnewNode->data.name = _strdup(newName);\n\t\tnewNode->data.num = newNum;\n\t\tnewNode->data.type = _strdup(newType);\n\n\t\tnewNode->nextNode = firstNode->nextNode;\n\t\tfirstNode->nextNode = newNode;\n\t\tlength++;\n\n\t\treturn true;\n\t}\n\n\tChainListNode* Search(char* searchKey)\n\t{\n\t\tChainListNode* current = firstNode->nextNode;\n\t\tfor (int i = 0; i < length; i++)\n\t\t{\n\t\t\tif (strcmp(searchKey, current->data.name) == 0)\n\t\t\t\treturn current;\n\t\t\tif (current->nextNode == nullptr)\n\t\t\t\treturn nullptr;\n\t\t\tcurrent = current->nextNode;\n\t\t}\n\t\treturn nullptr;\n\t}\n\n\tint getListLength()\n\t{\n\t\treturn length;\n\t}\n\nprivate:\n\tint length;\n};\n\n#define _CRT_SECURE_NO_WARNINGS；\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include <string>\n#include\"head.h\"\nusing namespace std;\n\nchar KEYWORD[] = \"保留字\";\nchar ID[] = \"标识符\";\nchar NUM[] = \"常数\";\nchar SEPARATOR[] = \"分隔符号\";\nchar ARITHMETIC[] = \"算术运算符\";\nchar RELATIONAL[] = \"关系运算符\";\nchar SPECIAL[] = \"特殊符号\";\n\nchar keyWord[200][200] = {\"abstract\",\"auto\",\"break\",\"case\",\"char\",\"class\",\"const\",\n\"continue\",\"default\",\"delete\",\"double\",\"enum\",\"extern\",\"f\",\"F\",\"far\",\"final\",\n\"float\",\"for\",\"friend\",\"goto\",\"if\",\"inline\",\"int\",\"interrupt\",\"l\",\"L\",\"long\",\n\"new\",\"operator\",\"private\",\"protected\",\"public\",\"register\",\"return\",\"short\",\n\"signed\",\"sizeof\",\"static\",\"struct\",\"switch\",\"typedef\",\"u\",\"U\",\"union\",\"unsigned\",\n\"virtual\",\"void\",\"while\",\"main\",\"else\",\"wchar_t\"};\nchar entry[200] = \"\";\nFILE* cstream, * outstream;\nint sEnd[] = {2,3,4,6,7,8,11,12,14,15,17,18,20,21,23,24,26,27,29,30,32,33,35,36,37,45,47,48};\nint currentNum = 0;\nint numOfKeyWord = 0;\nint numOfID = 0;\nint numOfNum = 0;\nint numOfSeparator = 0;\nint numOfArithmetic = 0;\nint numOfRelational = 0;\nint numOfSpecial = 0;\nbool ifflag = true;\n\nChainList keyWordLt;\nChainList keyWordList;\nChainList idList;\nChainList numList;\nChainList separatprList;\nChainList arithmeticList;\nChainList relationalList;\nChainList specialList;\n\nint move(int s, char ch);\nint getLength(char entry[]);\nvoid AutoForLexical(FILE* cstream, FILE* outstream);\nint findEnd(int s);\n\nint main()\n{\n\n\tif ((cstream = fopen(\"d:\\\\sample.txt\", \"r\")) == NULL)\n\t{\n\t\tprintf(\"Failed to open sample.txt!\");\n\t\texit(0);\n\t}\n\tif ((outstream = fopen(\"d:\\\\text1.txt\", \"w\")) == NULL)\n\t{\n\t\tprintf(\"Failed to open text1.txt\");\n\t\texit(0);\n\t}\n\n\twhile (strcmp(\"\", keyWord[currentNum]) != 0)\n\t{\n\t\tkeyWordLt.Insert(keyWord[currentNum], currentNum, KEYWORD);\n\t\tcurrentNum++;\n\t}\n\n\tAutoForLexical(cstream, outstream);\n\n\tChainListNode* temp;\n\n\tfprintf(outstream,\"%s \\n\",\"标识符表\");\n\ttemp = idList.firstNode->nextNode;\n\tfor (int i = 0; i <= idList.getListLength() - 1; i++)\n\t{\t\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num,temp->data.name,temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfprintf(outstream, \"%s \\n\", \"保留字\");\n\ttemp = keyWordLt.firstNode->nextNode;\n\tfor (int i = 0; i <= keyWordLt.getListLength() - 1; i++)\n\t{\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfprintf(outstream, \"%s \\n\", \"常数表\");\n\ttemp = numList.firstNode->nextNode;\n\tfor (int i = 0; i <= numList.getListLength() - 1; i++)\n\t{\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfprintf(outstream, \"%s \\n\", \"分隔符号表\");\n\ttemp = separatprList.firstNode->nextNode;\n\tfor (int i = 0; i <= separatprList.getListLength() - 1; i++)\n\t{\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfprintf(outstream, \"%s \\n\", \"算术运算符表\");\n\ttemp = arithmeticList.firstNode->nextNode;\n\tfor (int i = 0; i <= arithmeticList.getListLength() - 1; i++)\n\t{\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfprintf(outstream, \"%s \\n\", \"关系运算符表\");\n\ttemp = relationalList.firstNode->nextNode;\n\tfor (int i = 0; i <= relationalList.getListLength() - 1; i++)\n\t{\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfprintf(outstream, \"%s \\n\", \"特殊符号表\");\n\ttemp = specialList.firstNode->nextNode;\n\tfor (int i = 0; i <= specialList.getListLength() - 1; i++)\n\t{\n\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t//printf(\"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\tprintf(\"\\n\");\n\t}\n\n\tfclose(cstream);\n\tfclose(outstream);\n\n\tsystem(\"pause\");\n\n}\n\nvoid AutoForLexical(FILE* cstream, FILE* outstream)\n{\n\tchar ch;\n\tint s0 = 0;\n\tint s = s0;\n\n\tmemset(entry, '\\0', sizeof(entry));\n\tch = fgetc(cstream);\n\n\twhile (ch!=EOF)\n\t{\n\t\ts = move(s, ch);\n\n\t\tif (findEnd(s) != -1)\n\t\t{\n\t\t\tif (s >= 2 && s <= 18)//算术运算符\n\t\t\t{\n\t\t\t\tChainListNode* temp = arithmeticList.Search(entry);\n\t\t\t\tif (temp==nullptr)\n\t\t\t\t{\n\t\t\t\t\tarithmeticList.Insert(entry, numOfArithmetic, ARITHMETIC);\n\t\t\t\t\tnumOfArithmetic++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfprintf(outstream,\"%d %s %s\\n\",temp->data.num,temp->data.name,temp->data.type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (s==48)//特殊字符\n\t\t\t{\n\t\t\t\tChainListNode* temp = specialList.Search(entry);\n\t\t\t\tif (temp == nullptr)\n\t\t\t\t{\n\t\t\t\t\tspecialList.Insert(entry, numOfSpecial, SPECIAL);\n\t\t\t\t\tnumOfSpecial++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (s==37)//分隔符号\n\t\t\t{\n\t\t\t\tif ((int)ch == 126 || (int)ch == 94)\n\t\t\t\t{\n\t\t\t\t\tChainListNode* temp = arithmeticList.Search(entry);\n\t\t\t\t\tif (temp == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tarithmeticList.Insert(entry, numOfArithmetic, ARITHMETIC);\n\t\t\t\t\t\tnumOfArithmetic++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ((int)ch == 34 || (int)ch == 39)\n\t\t\t\t{\n\t\t\t\t\tChainListNode* temp = specialList.Search(entry);\n\t\t\t\t\tif (temp == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tspecialList.Insert(entry, numOfSpecial, SPECIAL);\n\t\t\t\t\t\tnumOfSpecial++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tChainListNode* temp = separatprList.Search(entry);\n\t\t\t\t\tif (temp == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tseparatprList.Insert(entry, numOfSeparator, SEPARATOR);\n\t\t\t\t\t\tnumOfSeparator++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (s == 30)\n\t\t\t{\n\t\t\t\tChainListNode* temp = separatprList.Search(entry);\n\t\t\t\tif (temp == nullptr)\n\t\t\t\t{\n\t\t\t\t\tseparatprList.Insert(entry, numOfSeparator, SEPARATOR);\n\t\t\t\t\tnumOfSeparator++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (s>=20 && s<=36 && s!=30)//关系运算符\n\t\t\t{\n\t\t\t\tChainListNode* temp = relationalList.Search(entry);\n\t\t\t\tif (temp == nullptr)\n\t\t\t\t{\n\t\t\t\t\trelationalList.Insert(entry, numOfRelational, RELATIONAL);\n\t\t\t\t\tnumOfRelational++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (s==47)//标识符和保留字\n\t\t\t{\n\t\t\t\tif (keyWordLt.Search(entry))\n\t\t\t\t{\n\t\t\t\t\tChainListNode* temp = keyWordList.Search(entry);\n\t\t\t\t\tif (temp == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tkeyWordList.Insert(entry, numOfKeyWord, KEYWORD);\n\t\t\t\t\t\tnumOfKeyWord++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tChainListNode* temp = idList.Search(entry);\n\t\t\t\t\tif (temp == nullptr)\n\t\t\t\t\t{\n\t\t\t\t\t\tidList.Insert(entry, numOfID, ID);\n\t\t\t\t\t\tnumOfID++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (s==45)//常数\n\t\t\t{\n\t\t\t\tChainListNode* temp = numList.Search(entry);\n\t\t\t\tif (temp == nullptr)\n\t\t\t\t{\n\t\t\t\t\tnumList.Insert(entry, numOfNum, NUM);\n\t\t\t\t\tnumOfNum++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfprintf(outstream, \"%d %s %s\\n\", temp->data.num, temp->data.name, temp->data.type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(entry,'\\0',sizeof(entry));\n\t\t\ts = s0;\n\t\t}\n\n\t\tif (ifflag)\n\t\t\tch = fgetc(cstream);\n\t\telse \n\t\t\tifflag = true;\n\t}\n}\n\nint move(int s, char ch)\n{\n\tif ((int)ch == 43 && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 1;\n\t}\n\telse if((int)ch == 61 && s == 1)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 2;\n\t}\n\telse if ((int)ch == 43 && s == 1)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 3;\n\t}\n\telse if (s == 1)\n\t{\n\t\tifflag = false;\n\t\treturn 4;\n\t}\n\telse if ((int)ch == 38 && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 5;\n\t}\n\telse if ((int)ch == 61 && s == 5)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 6;\n\t}\n\telse if ((int)ch == 62 && s == 5)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 7;\n\t}\n\telse if ((int)ch == 38 && s == 5)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 8;\n\t}\n\telse if (s == 5)\n\t{\n\t\tifflag = false;\n\t\treturn 9;\n\t}\n\n\telse if ((int)ch == 42 && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 10;\n\t}\n\telse if ((int)ch == 61 && s == 10)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 11;\n\t}\n\telse if (s == 10)\n\t{\n\t\tifflag = false;\n\t\treturn 12;\n\t}\n\n\telse if ((int)ch == 40 && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 13;\n\t}\n\telse if ((int)ch == 61 && s == 13)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 14;\n\t}\n\telse if (s == 13)\n\t{\n\t\tifflag = false;\n\t\treturn 15;\n\t}\n\n\telse if ((int)ch == 37 && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 16;\n\t}\n\telse if ((int)ch == 61 && s == 16)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 17;\n\t}\n\telse if (s == 16)\n\t{\n\t\tifflag = false;\n\t\treturn 18;\n\t}\n\n\telse if ((int)ch == 33 && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 19;\n\t}\n\telse if ((int)ch == 61 && s == 19)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 20;\n\t}\n\telse if (s == 19)\n\t{\n\t\tifflag = false;\n\t\treturn 21;\n\t}\n\n\telse if ((int)ch == 38 && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 22;\n\t}\n\telse if ((int)ch == 38 && s == 22)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 23;\n\t}\n\telse if (s == 22)\n\t{\n\tifflag = false;\n\treturn 24;\n\t}\n\n\telse if ((int)ch == 124 && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 25;\n\t}\n\telse if ((int)ch == 124 && s == 25)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 26;\n\t}\n\telse if (s == 25)\n\t{\n\tifflag = false;\n\treturn 27;\n\t}\n\n\telse if ((int)ch == 61 && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 28;\n\t}\n\telse if ((int)ch == 61 && s == 28)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 29;\n\t}\n\telse if (s == 28)\n\t{\n\tifflag = false;\n\treturn 30;\n\t}\n\n\telse if ((int)ch == 62 && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 31;\n\t}\n\telse if ((int)ch == 61 && s == 31)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 32;\n\t}\n\telse if (s == 31)\n\t{\n\tifflag = false;\n\treturn 33;\n\t}\n\n\telse if ((int)ch == 60 && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 34;\n\t}\n\telse if ((int)ch == 61 && s == 34)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 35;\n\t}\n\telse if (s == 34)\n\t{\n\tifflag = false;\n\treturn 36;\n\t}\n\n\telse if (((int)ch == 34 || (int)ch == 40 || (int)ch == 41 || (int)ch == 44 || (int)ch == 39 || (int)ch == 58 || (int)ch == 91 || (int)ch == 93 || (int)ch == 94 || (int)ch == 123 || (int)ch == 125 || (int)ch == 126 || (int)ch==46 || (int)ch==59 || (int)ch == 92) && s==0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 37;\n\t}\n\n\telse if (((int)ch == 43 || (int)ch == 38) && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 38;\n\t}\n\telse if (((int)ch >= 48 && (int)ch <= 57) && s == 0)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 39;\n\t}\n\telse if (!((int)ch >= 48 && (int)ch <= 57) && s == 38)\n\t{\n\tentry[getLength(entry) - 1] = '\\0';\n\tifflag = false;\n\treturn 0;\n\t}\n\telse if (((int)ch >= 48 && (int)ch <= 57) && s == 38)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 39;\n\t}\n\telse if (((int)ch >= 48 && (int)ch <= 57) && s == 39)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 39;\n\t}\n\telse if ((int)ch == 39 && s == 39)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 40;\n\t}\n\telse if ((int)ch == 101 && s == 39)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 42;\n\t}\n\telse if (s == 39)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 45;\n\t}\n\telse if (((int)ch >= 48 && (int)ch <= 57) && s == 40)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 41;\n\t}\n\telse if (((int)ch >= 48 && (int)ch <= 57) && s == 41)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 41;\n\t}\n\telse if ((int)ch == 101 && s == 41)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 42;\n\t}\n\telse if (s == 41)\n\t{\n\tifflag = false;\n\treturn 45;\n\t}\n\telse if (((int)ch == 43 || (int)ch == 38) && s == 42)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 43;\n\t}\n\telse if (((int)ch >= 41 && (int)ch <= 57) && s == 42)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 44;\n\t}\n\telse if (((int)ch >= 41 && (int)ch <= 57) && s == 43)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 44;\n\t}\n\telse if (((int)ch >= 41 && (int)ch <= 57) && s == 44)\n\t{\n\tentry[getLength(entry)] = ch;\n\treturn 44;\n\t}\n\telse if (s == 44)\n\t{\n\tifflag = false;\n\treturn 45;\n\t}\n\n\telse if (((int)ch == 95 || ((int)ch >= 65 && (int)ch <= 90) || ((int)ch >= 97 && (int)ch <= 122)) && s == 0)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 46;\n\t}\n\n\telse if (((int)ch == 95 || ((int)ch >= 65 && (int)ch <= 90) || ((int)ch >= 97 && (int)ch <= 122) || ((int)ch >= 48 && (int)ch <= 57)) && s == 46)\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 46;\n\t}\n\telse if (s == 46)\n\t{\n\t\tifflag = false;\n\t\treturn 47;\n\t}\n\telse if (s == 0 && ((int)ch == 0 || (int)ch == 7 || (int)ch == 8 || (int)ch == 9 || (int)ch == 10 || (int)ch == 11 || (int)ch == 12 || (int)ch == 13 || (int)ch == 34 || (int)ch == 39 || (int)ch == 63 || (int)ch == 92))\n\t{\n\t\tentry[getLength(entry)] = ch;\n\t\treturn 48;\n\t}\n\n\telse if (s == 0)\n\t{\n\tifflag = false;\n\treturn 0;\n\t}\n}\n\nint findEnd(int s)\n{\n\tint low = 0;\n\tint high = 27;\n\twhile (low <= high)\n\t{\n\t\tint mid = (low + high) / 2;\n\t\tif (s == sEnd[mid])\n\t\t\treturn sEnd[mid];\n\t\telse\n\t\t\tif (s > sEnd[mid])\n\t\t\t\tlow = mid + 1;\n\t\t\telse\n\t\t\t\thigh = mid - 1;\n\t}\n\treturn -1;\n}\n\nint getLength(char ch[])\n{\n\tint length = 0;\n\twhile (ch[length] != '\\0')\n\t\tlength++;\n\treturn length;\n}", "\n\n", "这是一个进行简单词法分析的程序。本人设计一个bool型全局变量ifflag，表示是否使用当前从文件流读取的字符串ch，若ifflag值为true，则表示当前ch被使用过，下一次循环时执行ch=fgetc（cstream），否则重置ifflag的值为true。而move（）函数中if的各个分支执行ifflag=false。 但是我在执行的过程中发现，程序在ifflag第一次被置false后值就不在发生改变。", "\n\n", "用于被识别的简单程序如下：", "\n\n", "void main()", "\n{", "\n    int i,j,sum;", "\n    i=j=1;", "\n    sum=10;", "\n    sum=i+j;", "\n    wchar_t wch=\"汉字\"", "\n    printf(\"%d\\n\",sum);", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;大哥 你是笔误把~&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/520605105746192.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C++类和对象之重载问题", ["在自学C++关系运算符重载课程的时候，已经重载好了全等符，创建了两个不等的对象，运行还是显示两个对象相等", "\n", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std; \n", "//重载关系运算符  ", "\n\n", "class", " ", "pers", "\n{\n", "public", ":\n    ", "pers", "(string name, ", "int", " age)\n    {\n        name = m_name;\n        age = m_age;\n    }\n    ", "//重载==号", "\n    ", "bool", " ", "operator", "==(pers& p)\n    {\n        ", "if", " (", "this", "->m_name == p.m_name && ", "this", "->m_age == p.m_age)\n        {\n            ", "return", " ", "true", ";\n        }\n\n        ", "return", " ", "false", ";\n\n\n\n    }\n    ", "bool", " ", "operator", "!=(pers& p)\n    {\n        ", "if", " (", "this", "->m_name == p.m_name || ", "this", "->m_age == p.m_age)\n        {\n            ", "return", " ", "false", ";\n        }\n\n        ", "return", " ", "true", ";\n\n\n    }\n    string m_name;\n    ", "int", " m_age;\n};\n\n", "void", " ", "test897909", "()", "\n", "{\n    ", "pers ", "p1", "(", "\"tom\"", ", ", "18", ")", ";\n    ", "pers ", "p2", "(", "\"uihlj\"", ", ", "28", ")", ";\n    ", "if", " (p1 == p2)\n    {\n        cout << ", "\"p1和p2是相等的\"", " << endl;\n    }\n    ", "else", "\n    {\n        cout << ", "\"p1和p2是不相等的\"", " << endl;\n    }\n    ", "if", " (p1 != p3)\n    {\n        cout << ", "\"p1和p2是不相等的\"", " << endl;\n\n    }\n    ", "else", "\n    {\n        cout << ", "\"p1和p2是相等的\"", " << endl;\n    }\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "test897909", "();\n\n\n\n\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "p1与p2相等", "\n", "我的解答思路和尝试过的方法", "\n", "跟着网课学的，一模一样的代码怎么搞都是p1和p2相等", "\n", "我想要达到的结果", "\n", "怎么才能正常输出p1和p2不相等的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码贴出来看看吧&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["刚学vs2019遇到“已引发异常”", ["C语言用vs2019，生成遇到已印发异常，就是最普通的判断闰年", "#include<stdio.h>", "#include<stdlib.h>", "void calcu_operator()/", "算术运算符", "/", "{", "    int i = 12321, result;", "    while (i)/", "就是判断i!=0", "/", "    {", "        printf(\"%d\\n\", i % 10);  /", "（对10）取余操作", "/", "        i = i / 10;/", "如果上面是%c，不输出12321；如果上面是%c，后面+48或者+'0'就可以把数值转换为字符型", "/", "    }", "}", "\n", "void relation_operator()/", "关系运算符", "/", "{", "    int year,f;", "    while (scanf_s(\"%d\", &year) != EOF)", "    {", "        if (3 < year && year < 10)/", "不可以写3<year<10，因为<从左到右，例如（3<1)结果是假，就是0，而0<10永远正确", "/", "        {", "            printf(\"year is ok\\n\");", "        }", "        else", "        {", "            printf(\"year is not ok\\n\");", "        }", "    }", "    return 0;", "}", "\n", "int main()", "{", "    /", "calcu_operator();", "/", "    relation_operator();", "    return 0;"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;x&amp;#43;&amp;#43;是先输出后加一&amp;#xff0c;所以打印的就是1&amp;#xff0c;打印完之后加一了&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C++编程：有关输出流运算符<<，以及自增运算符++", ["请问为什么x的值为2，却只会输出1呢？ 是与cout输出流以及自增运算符++有关系吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; p,k,s;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; g;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; type;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d%d%c&amp;#34;&lt;/span&gt;,&amp;amp;p,&amp;amp;k,&amp;amp;s,&amp;amp;type);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s&amp;lt;&lt;span class=\"hljs-number\"&gt;250&lt;/span&gt;)\n    {\n        type&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;lt;&lt;span class=\"hljs-number\"&gt;500&lt;/span&gt;)\n    {\n        type&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;lt;&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt;)\n    {\n        type&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;lt;&lt;span class=\"hljs-number\"&gt;2000&lt;/span&gt;)\n    {\n        type&amp;#61;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;lt;&lt;span class=\"hljs-number\"&gt;3000&lt;/span&gt;)\n    {\n        type&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s&amp;gt;&lt;span class=\"hljs-number\"&gt;3000&lt;/span&gt;)\n    {\n        type&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;switch&lt;/span&gt;(type)\n    {\n     &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;:\n     g&amp;#61;s*k*p*&lt;span class=\"hljs-number\"&gt;1.00&lt;/span&gt;;\n     &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f&amp;#34;&lt;/span&gt;,g);\n     &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n     &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:\n     g&amp;#61;s*k*p*&lt;span class=\"hljs-number\"&gt;0.98&lt;/span&gt;;\n     &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f&amp;#34;&lt;/span&gt;,g);\n     &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n     &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;:  \n     g&amp;#61;s*k*p*&lt;span class=\"hljs-number\"&gt;0.95&lt;/span&gt;;\n     &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f&amp;#34;&lt;/span&gt;,g);\n     &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n     &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;:\n     g&amp;#61;s*p*k*&lt;span class=\"hljs-number\"&gt;0.92&lt;/span&gt;;\n     &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f&amp;#34;&lt;/span&gt;,g);\n     &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n     &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;:\n     g&amp;#61;s*k*p*&lt;span class=\"hljs-number\"&gt;0.9&lt;/span&gt;;\n     &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f&amp;#34;&lt;/span&gt;,g);\n     &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n     &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;:\n     g&amp;#61;s*k*p*&lt;span class=\"hljs-number\"&gt;0.85&lt;/span&gt;;\n     &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f&amp;#34;&lt;/span&gt;,g);\n     &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;细节&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["这个我不知道哪里有错误，能不帮我看下嘛？", ["7-2 计算运费", "\n", "实验三 选择结构程序设计", "\n", "实验目的", "\n", "学会使用关系运算符和关系表达式以及逻辑运算符和逻辑表达式。\n熟练掌握", "if", "语句的使用。\n熟练掌握", "switch", "语句的使用。\n", "\n", "运输公司对用户计算运输费用。路程(skm）越远，每吨·千米运费越低。(分别用if语句和switch语句实现) 标准如下：", "\n", "     ", "s", " < ", "250", "                 没有折扣\n ", "250", "<= s < ", "500", "               ", "2", "％折扣\n ", "500", " <=s < ", "1000", "              ", "5", "％折扣\n", "1000", " <=s < ", "2000", "              ", "8", "％折扣\n", "2000", " <=s < ", "3000", "             ", "10", "％折扣\n", "3000", " <=s                    ", "15", "％折扣\n", "\n", "请帮助商户老周计算一下本次的货物运到目的地需要交纳的运输费用。 提示：小数点后保留2位。", "输入格式:", "\n", "输入一行三个数据单价、重量和运输距离。", "输出格式:", "\n", "输出相应的运输费用。", "输入样例:", "\n", "在这里给出一组输入。例如：", "\n", "100 20 300", "结尾无空行", "\n", "输出样例:", "\n", "在这里给出相应的输出。例如：", "\n", "588000.00", "结尾无空行", "\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " p,k;\n    ", "char", " s;\n    ", "float", " g;\n    ", "scanf", "(", "\"%d%d%c\"", ",&p,&k,&s);\n    ", "if", "(s<", "250", ")\n    {\n        g=s*p*k;\n        ", "printf", "(", "\"%.2f\"", ",g);\n    }\n    ", "else", " ", "if", "(s>=", "250", ")\n    {\n        ", "switch", "(s)\n        {\n            ", "case", " s<", "500", ":\n            g=s*k*p*", "0.98", ";\n            ", "printf", "(", "\"%.2f\"", ",g);\n            ", "break", ";\n            ", "case", " s<", "1000", ":  \n            g=s*k*p*", "0.95", ";\n            ", "printf", "(", "\"%.2f\"", ",g);\n            ", "break", ";\n            ", "case", " s<", "2000", ":\n            g=s*p*k*", "0.92", ";\n            ", "printf", "(", "\"%.2f\"", ",g);\n            ", "break", ";\n            ", "case", " s<", "3000", ";\n            g=s*k*p*", "0.9", ";\n            ", "printf", "(", "\"%.2f\"", ",g);\n            ", "break", ";\n        }\n    }\n    ", "else", " ", "if", "(s>=", "3000", ")\n    {\n        g=s*k*p*", "0.85", ";\n        ", "printf", "(", "\"%.2f\"", ",g);\n    }\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;And the solution ......     &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$criteria-&amp;gt;addSearchCondition(\"geneExpressionCufflinksGene.fpkm\",$this-&amp;gt;patient_gecg_search, $escape=true, $operator='OR');\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;I added the escape param and changed the operator to OR instead of default AND. My guess is it's also doing a string search in there somewhere and using the OR operator allows the comparison operation to occur in addition to the string comparison.  Obviously there's something I'm not understanding but regardless, numeric comparisons now return the proper results.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "关系运算符", "Question": ["Yii CGridView BELONGS_TO关系搜索：数字比较运算符失败", ["\n\n", "I have a CGridView widget in my \"PointMutationsVarscan\" model set up to search a numeric non-pk value in a related model, called \"GeneExpressionCufflinksGene\"", "\n\n", "I declare the search var within the PointMutationsVarscan model in the usual way to disambiguate:", "\n\n", "public $patient_gecg_search;\n", "\n\n", "Search rule in PointMutationsVarscan contains search var:", "\n\n", "array('id, ... patient_gecg_search, geneExpressionCufflinksGene', 'safe', 'on'=>'search'),\n", "\n\n", "Model relation:", "\n\n", "'geneExpressionCufflinksGene' => array(self::BELONGS_TO,'GeneExpressionCufflinksGene',array('gene'=>'gene_id')),\n", "\n\n", "Search function:", "\n\n", "public function search()\n{\n$criteria=new CDbCriteria;\n$criteria->compare('id',$this->id,true);\n// yada yada\n\n$criteria->with[] = 'geneExpressionCufflinksGene';          \nif($this->patient_gecg_search) {\n$criteria->compare( 'geneExpressionCufflinksGene.fpkm', $this->patient_gecg_search, true);          \n$criteria->addSearchCondition(\"geneExpressionCufflinksGene.fpkm\",$this->patient_gecg_search);\n}\nreturn new CActiveDataProvider($this, array(\n    'criteria'=>$criteria,\n        'sort'=>array(\n        'attributes'=>array(\n            'patient_search'=>array(\n                'asc'=>'patient.id',\n                'desc'=>'patient.id DESC',\n            ),\n\n            'patient_gecg_search'=>array(\n                'asc'=>'geneExpressionCufflinksGene.fpkm',\n                'desc'=>'geneExpressionCufflinksGene.fpkm DESC',\n            ),\n            '*',\n        ),\n        ),\n));\n}   \n", "\n\n", "In the GeneExpressionCufflinksGene model rules, fpkm is a numeric value:", "\n\n", "array('fpkm, fpkm_conf_lo, fpkm_conf_hi', 'numerical'),\n", "\n\n", "The the CGridView widget in the PointMutationsVarscan view:", "\n\n", "$criteria=new CDbCriteria;\n$dataProvider=$model->search();\n$dataProvider->pagination = array('pageSize' => 15);\n$columns=array();\n$columns[]= array(\n        'name'  => 'patient_gecg_search',\n        'value'=>'$data->geneExpressionCufflinksGene->fpkm', \n        'type'  => 'raw',\n        'htmlOptions'=>array('style'=>'width:250px;'),\n    ); \n\n$this->widget('zii.widgets.grid.CGridView', array(\n        'id'=>'point-mutations-varscan',\n        'dataProvider'=>$model->search(),\n        'filter'=>$model,\n        'columns'=>$columns,\n    )\n);\n", "\n\n", "Essentially the problem is that I can't do a numeric comparison search (> < = etc ) on this belongs to relation column.  It only does a string matching search.  For example if I search for 123, it will return all the numeric fpkm values that match 123, but if I do <123 or >1 it doesn't return any records, they way you'd expect for a local parameter.", "\n\n", "fpkm is a double precision float in the database.  I can use comparison operators on fpkm just fine within the GeneExpressionCufflinksGene model's own CGridView widget.  Comparison operators only fail when searching as a relation through the PointMutationsVarscan model.", "\n\n", "Thanks for any insight you might have on this.  ", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;&lt;p&gt;第一张图 &amp;#xff0c; x&amp;#43;&amp;#61;y&amp;#61;z&amp;#61;5  &amp;#xff0c;  赋值运算&amp;#xff0c; 从右往左分析&amp;#xff1b;&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;先是 z &amp;#61; 5&amp;#xff0c;然后 y &amp;#61; 5&amp;#xff0c;最后 x &amp;#43;&amp;#61; 5 &amp;#xff0c; 即 x &amp;#61; x &amp;#43; 5&amp;#xff1b;&lt;/li&gt;&lt;/ul&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二张图 &amp;#xff0c;(n &amp;#61; 6 * 4, n &amp;#43; 6), n*2   &amp;#xff0c;   逗号表达式,    实际最后 n &amp;#61; 24&amp;#xff0c;  其他计算都不影响n&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "关系运算符", "Question": ["c语言运算符优先级的问题，这两句话怎么理解，帮帮我", ["\n", "c语言运算符优先级的问题，第二个图片的语句是不是表示逗号之间的并列关系"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;蓝色的那叫形参&amp;#xff0c;把红色的传给蓝色的时候&amp;#xff0c;红色的叫实参。&lt;br /&gt;形参的作用范围是函数范围&amp;#xff0c;函数结束&amp;#xff0c;形参也就不存在了&amp;#xff0c;所以函数外使用*max&amp;#xff0c;*min会报错的&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["翁恺C语言进阶    第一周指针与运算符", ["想问一下，我蓝色笔画的，minmax函数里面参数的    *min和    *max指针和主函数里面的min、max是什么关系，", "为什么可以直接打印min和max。不应该是指针  *min、 *max吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/29889437904616.jpg\" /&gt;&lt;/p&gt;&lt;br /&gt;&lt;a class=\"md_call_user\" type=\"user\"&gt;&amp;#64;放最后面&lt;/a&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/712395379046116.jpg\" /&gt;&lt;/p&gt;&lt;br /&gt;可参考&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/ssjhust123/article/details/8001651\" id=\"textarea_1640973309229_1640973622932_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/ssjhust123/article/details/8001651&lt;/span&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["请问答案是这样的吗，不对的话请问答案和过程是什么", ["已知一个中缀算术表达式为:3 + 4/(25-(6+15))", "8@ 写出对应的后缀算术表达式", "我的答案：3425615+-/+8@", "思路：", "\n", "\n", "序号是运算符输出的顺序"]], "Tag": "程序设计"}
{"Answer": "http://bbs.csdn.net/topics/310180657", "Konwledge_Point": "关系运算符", "Question": ["最近在自学c++ builder，但遇到了一些困扰，对里面的控件和属性之间的关系，本质不了解", ["我也正在学c++,对c++ builder的一些代码还是理解的。我查过控件是对数据和方法的封装，应该是可以看作为类吧，那属性是不是就类似于类呢？", "\n但为什么控件，属性之间是用“->”运算符呢？附上如下代码", "\n\n", "void __fastcall TForm1::Button1Click(TObject *Sender)\n", "\n\n", "{", "\n     Graphics::TBitmap*Bitmap;", "\n     TRect MyRect;", "\n     MyRect=Rect (10,200,100,250); //四个参数，分别代表矩形左边X坐标，Y左坐标，", "\n     Bitmap=new Graphics::TBitmap;   //矩形右边X坐标，Y坐标", "\n     Bitmap->LoadFromFile(\"f:\\美女.bmp\");", "\n\n", " PaintBox1->Canvas->Draw(10,10,Bitmap);\n PaintBox1->Canvas->StretchDraw(MyRect,Bitmap);\n\n BitmapBack->Height=PaintBox1->Height;\n BitmapBack->Width=PaintBox1->Width;\n BitmapBack->Canvas->CopyRect(RectCopy,PaintBox1->Canvas,RectCopy);\n delete Bitmap;\n\n\n delete Bitmap;\n", "\n\n", "}", "\n为什么之间都是用那个运算符，这不是指针才用的吗？", "\n希望有人指出错误，谢谢。还有我想用builder做一个游戏，应该从什么地方下手，", "\n是要完全理解builder代码吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;&lt;p&gt;这个的意思就是以后遇到有 &lt;code class=\"language-javascript\"&gt;add(x)&lt;/code&gt; 的地方就自动替换为 &lt;code class=\"language-javascript\"&gt;x &amp;#43; x&lt;/code&gt;&amp;#xff0c;而不是 &lt;code class=\"language-javascript\"&gt;(x &amp;#43; x)&lt;/code&gt;&amp;#xff0c;因此 &lt;code class=\"language-javascript\"&gt;int sum &amp;#61; add(1 &amp;#43; 2) * 3&lt;/code&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  就等价于 &lt;/span&gt;&lt;code class=\"language-javascript\"&gt;int sum &amp;#61; 1 &amp;#43; 2 &amp;#43; 1 &amp;#43; 2 * 3&lt;/code&gt;&amp;#xff0c;因此结果等于 &lt;code class=\"language-javascript\"&gt;10&lt;/code&gt;。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;优先级比较&amp;#xff1a;&lt;code class=\"language-javascript\"&gt;*&lt;/code&gt; 高于 &lt;code class=\"language-javascript\"&gt;&amp;lt;&lt;/code&gt; 高于 &lt;code class=\"language-javascript\"&gt;&amp;#61;&amp;#61;&lt;/code&gt;&amp;#xff0c;对于&lt;code class=\"language-javascript\"&gt;2 * 2 &amp;#61;&amp;#61; 5 &amp;lt; 2 * 2 &amp;#61;&amp;#61; 4&lt;/code&gt;&amp;#xff0c;可以看成 &lt;code class=\"language-javascript\"&gt;(2 * 2) &amp;#61;&amp;#61; (5 &amp;lt; (2 * 2)) &amp;#61;&amp;#61; 4&lt;/code&gt;&amp;#xff0c;即 &lt;code class=\"language-javascript\"&gt;4 &amp;#61;&amp;#61; (5 &amp;lt; 4) &amp;#61;&amp;#61; 4&lt;/code&gt;&amp;#xff0c;即 &lt;code class=\"language-javascript\"&gt;4 &amp;#61;&amp;#61; 0 &amp;#61;&amp;#61; 4&lt;/code&gt;&amp;#xff0c;然后得到 &lt;code class=\"language-javascript\"&gt;0 &amp;#61;&amp;#61; 4&lt;/code&gt;&amp;#xff0c;因此是FALSE&amp;#xff0c;执行 &lt;code class=\"language-javascript\"&gt;else&lt;/code&gt; 语句&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "关系运算符", "Question": ["关于define的问题", ["为什么结果是10而不是18，不应该是2+1+2+1=6，然后6*3嘛", "\n", "这里为什么是F，不太明白，和运算符优先级有关系吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没啥问题吧&amp;#xff0c;重新编译一下再运行看看&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["函数调用的问题，无参数的情况怎么填void都Error", ["问题遇到的现象和发生背景", "\n", "函数调用的问题，无参数的情况怎么填void都Error，请教原因", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<math.h>", " ", "\n", "double", " ", "exp", "()", ";\n", "int", " ", "main", "()", "\n", "{\n    ", "double", " a=", "exp", "();\n    ", "printf", "(", "\"%lf\"", ",a);\n    ", "return", " ", "0", ";\n}\n", "double", " ", "exp", "()", "{\n        ", "char", " s[", "50", "];\n        ", "scanf", "(", "\"%s\"", ",s);\n        ", "switch", "(s[", "0", "]){\n            ", "case", " ", "'+'", ":", "return", " ", "exp", "()+", "exp", "();\n            ", "case", " ", "'-'", ":", "return", " ", "exp", "( )-", "exp", "( );\n            ", "case", " ", "'*'", ":", "return", " ", "exp", "( )*", "exp", "( );\n            ", "case", " ", "'/'", ":", "return", " ", "exp", "( )/", "exp", "( );\n            ", "default", " :", "return", " ", "atof", "(s);\n        }\n}\n\n", "\n", "运行结果及报错内容", "\n", "波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。", "输入", "输入为一行，其中运算符和运算数之间都用空格分隔，运算数是浮点数。", "输出", "输出为一行，表达式的值。", "可直接用printf(\"%f\\n\", v)输出表达式的值v。", "样例输入", "\n", "11.0 12.0 + 24.0 35.0", "样例输出", "\n", "\n", "1357.000000"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;考虑字典套字典&lt;br /&gt;比如大类是外面字典的键&amp;#xff0c;然后英汉翻译键值对作为值放在里面字典&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["左边是英语，右边是汉字，做成2个列表查找替换用，可是如何与大类做成映射关系呢？", ["作为写代码翻译用，左边是英语，右边是汉字，做成2个列表查找替换用，可是如何与大类做成映射关系呢？让我们输入一个键值就懂是大类下的分类？", "\n", "Python常用英文单词：", "一、交互式环境与print输出", "1、print：打印/输出", "2、coding：编码", "3、syntax：语法", "4、error：错误", "5、invalid：无效", "6、identifier：名称/标识符", "7、character ：字符", "二、字符串的操作", "1、user：用户", "2、name：姓名/名称", "3、attribute：字段/属性", "4、value：值", "5、key：键", "三、重复/转换/替换/原始字符串", "1、upper：上面", "2、lower：下面", "3、capitalize：用大写字母写或印刷", "4、title：标题", "5、replace：替换", "6、old：旧的", "7、new：新的", "8、count：计数", "9、swap：互换", "10、case：情形", "11、path：路径", "12、new：新的\\新建", "13、project：项目", "14、test：测试", "15、file：文件", "16、data：数据", "四、去除/查询/计数", "1、strip：去除", "2、index：索引", "3、find：查找", "4、count：计数", "5、start：开始", "6、end：结束", "7、chars：字符", "8、sub：附属", "五、获取输入/格式化", "1、input：输入", "2、prompt：提示", "3、ID：身份证", "4、format：格式化", "5、args（argument）：参数", "6、kwargs：关键字参数", "7、year：年", "8、month：月", "9、day：日", "六、元组", "1、tuple：元组", "2、max：最大", "3、min：最小", "4、iterable：可迭代", "5、key：关键字", "6、function：方法/函数", "7、stop：停止", "8、object：对象", "七、列表", "1、list：列表", "2、reverse：反向", "3、true：真", "4、false：假", "5、append：附加", "6、extend：扩展", "7、insert：插入", "8、pop：取出", "9、remove：移除", "10、del（delete）：删除", "11、clear：清除", "12、sort：排序", "八、集合", "1、set：集合/设置", "2、add：添加", "3、update：更新", "4、discard：丢弃", "5、intersection：相交", "6、union：联合", "7、difference：差数", "8、symmetric：对称", "9、in：在…里面", "10、not：不/不是", "11、disjoint：不相交", "12、subset：子集", "13、superset：父集/超集", "14、copy：复制", "九、字典", "1、dict：字典", "2、key：键/关键字", "3、value：值", "4、item：项", "5、mapping：映射", "6、seq（sequence）：序列", "7、from：从/来自", "8、get：获取", "9、default：默认", "10、none：没有", "11、arg：可变元素", "12、kwargs（keyword args）：可变关键字元素", "十、循环", "1、for…in…循环的使用", "2、while…循环的使用", "3、range：范围", "4、sep(separate)：分隔", "5、flush：冲刷", "6、step：步长", "7、continue：继续", "8、break：突破/跳出", "十一、条件/跳出与结束循环", "1、if：如果", "2、else：否则", "十二、运算符与随机数", "1、module：模块", "2、sys(system)：系统", "3、path：路径", "4、import：导入", "5、from：从…", "十三、定义函数与设定参数", "1、birthday：出生日期", "2、year：年份", "3、month：月份", "4、day：日期", "5、type：类型", "6、error：错误", "7、missing：丢失", "8、required：必须", "9、positional：位置", "10、unsupported：不支持", "十四、设定收集参数", "1、create：创建", "2、info：信息", "3、age：年龄", "4、height：高度", "5、width：宽度", "6、weight：重量", "7、splicing：拼接", "8、params：参数", "9、volume：体积", "11、operand：操作数", "十五、嵌套函数/作用域/闭包", "1、inside：内部", "2、outside：外部", "3、radius：半径", "4、perimeter：周长", "5、case：情形", "6、synthesis：合成", "7、execute：执行", "十六、递归函数", "1、recursion：递归", "2、Infinite：无穷", "3、maximum：最大值", "4、depth：深度", "5、exceeded：超过", "6、factorial：阶乘", "7、search：查询", "8、power：幂", "9、lower：下方", "10、upper：上方", "11、middle：中间", "12、assert/assertion：异常", "十七、列表推导式/lambda表达式", "1、square：平方", "2、even：偶数", "3、comprehension：理解", "4、lambda：希腊字母λ的英文名称，大名鼎鼎的游戏半条命里面的logo就是这个。", "十八、列表推导式/lambda表达式", "1、regular：规则", "2、expression： 表达式", "3、group：组", "4、match：匹配", "5、span：跨度", "6、ignore case：忽略 大小写", "7、multi line：多 行", "8、dot all：点 全部", "9、unicode：万国码", "10、verbose：累赘", "11、pos/position：位置"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;32是大写和小写字母的ASCII值之间的差值&lt;br /&gt;一个&lt;code class=\"language-javascript\"&gt;&amp;amp;&lt;/code&gt;表示取地址&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["C语音代码相关问题32是什么意思", ["问题遇到的现象和发生背景", "\n", "本题中的32是什么意思&&是逻辑运算符      那么一个&又是什么意思", "\n", "问题相关代码，请勿粘贴截图", "\n", "void", " ", "main", "(", "void", ")", "\n\n", "{\n    ", "char", " c1;\n    ", "scanf", "(", "\"%c\"", ", &c1);\n    c1 = (c1 >= ", "'A'", "&& c1 <= ", "'Z'", ") ? (c1 + ", "32", ") : c1;\n        c1 = (c1>= ", "'a'", "&& c1 <= ", "'z'", ") ? (c1 - ", "32", "):c1;\n        ", "printf", "(", "\"%c\"", " , c1);\n}\n\n\n", "\n", "运行结果", "\n", "输入小t  输出大T", "\n", "我的解答思路和尝试过的方法", "\n", "32是什么意思，和真假性&&有什么关系", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;死循环了吧&lt;br /&gt;Status In(char op, char Op[]) {//判断读入字符ch是否为运算符&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    for (int i &amp;#61; 0; i &amp;lt; OPSIZE; i&amp;#43;&amp;#43;) {&lt;!-- --&gt;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        if (op &amp;#61;&amp;#61; Op[i])&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            return OK;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        else&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;            return ERROR;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;这里写错了啊&amp;#xff0c;你这等于比较了第一个字符就肯定结束了&amp;#xff0c;修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;In&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; op, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; Op[])&lt;/span&gt; &lt;/span&gt;{&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//判断读入字符ch是否为运算符&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; OPSIZE; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (op &amp;#61;&amp;#61; Op[i])\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "关系运算符", "Question": ["表达式求值，自己写的代码，不知道哪里出错了", ["想要的是这个结果", "但是却卡在了这", "这是我的代码", "\n", "\n", "#include<stdio.h>", "\n", "#include <conio.h>", "\n", "#include <stdlib.h>", "\n", "#include <iostream>", "\n", "using", " ", "namespace", " ", "std", ";\n\n", "#", "define", " MAXSIZE 100", "\n", "#", "define", " OPSIZE 7", "\n", "#", "define", " ERROR 0", "\n", "#", "define", " OK 1", "\n", "#", "define", " OVERFLOW -2", "\n\ntypedef ", "int", " SElemType;\ntypedef ", "char", " OperandType;\ntypedef ", "int", " Status;\n\nunsigned ", "char", " Prior[", "7", "][", "7", "] = {\n    ", "'>'", ",", "'>'", ",", "'<'", ",", "'<'", ",", "'<'", ",", "'>'", ",", "'>'", ",\n    ", "'>'", ",", "'>'", ",", "'<'", ",", "'<'", ",", "'<'", ",", "'>'", ",", "'>'", ",\n    ", "'>'", ",", "'>'", ",", "'>'", ",", "'>'", ",", "'<'", ",", "'>'", ",", "'>'", ",\n    ", "'>'", ",", "'>'", ",", "'>'", ",", "'>'", ",", "'<'", ",", "'>'", ",", "'>'", ",\n    ", "'<'", ",", "'<'", ",", "'<'", ",", "'<'", ",", "'<'", ",", "'='", ",", "' '", ",\n    ", "'>'", ",", "'>'", ",", "'>'", ",", "'>'", ",", "' '", ",", "'>'", ",", "'>'", ",\n    ", "'<'", ",", "'<'", ",", "'<'", ",", "'<'", ",", "'<'", ",", "' '", ",", "'='", "\n};", "//优先关系", "\n", "char", " OP[OPSIZE] = { ", "'+'", ",", "'-'", ",", "'*'", ",", "'/'", ",", "'('", ",", "')'", ",", "'#'", " };", "//运算符集合", "\n\ntypedef ", "struct", " {\n    ", "int", "* ", "base", ";", "//栈底指针", "\n    ", "int", "* top;", "//栈顶指针", "\n    ", "int", " stacksize;", "//栈最大容量", "\n}SqStack;\n\n", "Status ", "InitStack", "(", "SqStack& S", ")", " {", "//初始化", "\n    S.", "base", " = ", "new", " SElemType[MAXSIZE];", "//分配最大容量为MAXSIZE的数组空间", "\n    ", "if", " (!S.", "base", ")\n        exit(OVERFLOW);", "//存储空间分配失败", "\n    S.top = S.", "base", ";\n    S.stacksize = MAXSIZE;\n    ", "return", " OK;\n}\n", "Status ", "Push", "(", "SqStack& S, SElemType e", ")", " {", "//入栈", "\n    ", "if", " (S.top - S.", "base", " == S.stacksize)\n        ", "return", " ERROR;", "//栈满", "\n    *(S.top)++ = e;", "//元素e压入栈顶，栈顶指针加一", "\n    ", "return", " OK;\n}\n", "Status ", "Pop", "(", "SqStack& S, SElemType& e", ")", " {", "//出栈", "\n    ", "if", " (S.top == S.", "base", ")\n        ", "return", " ERROR;", "//栈空", "\n    e = *--S.top;", "//栈顶指针减一，将栈顶元素赋给e", "\n    ", "return", " OK;\n}\n", "SElemType ", "GetTop", "(", "SqStack& S", ")", " {", "//返回S的栈顶元素", "\n    ", "if", " (S.top != S.", "base", ")", "//栈非空", "\n        ", "return", " *(S.top - ", "1", ");\n}\n\n", "Status ", "In", "(", "char", " op, ", "char", " Op[]", ")", " {", "//判断读入字符ch是否为运算符", "\n    ", "for", " (", "int", " i = ", "0", "; i < OPSIZE; i++) {\n        ", "if", " (op == Op[i])\n            ", "return", " OK;\n        ", "else", "\n            ", "return", " ERROR;\n    }\n}\n", "int", " ", "FindOp", "(", "char", " op, ", "char", " Op[]", ")", " {", "//字符在优先关系表中的位置", "\n    ", "int", " x;\n    ", "for", " (", "int", " i = ", "0", "; i < OPSIZE; i++)\n        ", "if", " (op == Op[i])\n            x = i;\n    ", "return", " x;\n}\n", "char", " ", "Precede", "(", "char", " op1, ", "char", " op2", ")", " {", "//判断运算符栈的栈顶元素与读入运算符之间的优先级关系的函数", "\n    ", "return", " Prior[FindOp(op1, OP)][FindOp(op2, OP)];\n}\n", "int", " ", "Operate", "(", "int", " a, ", "int", " theta, ", "int", " b", ")", " {", "//进行二元运算函数", "\n    ", "switch", " (theta)\n    {\n    ", "case", " ", "'+'", ":\n        ", "return", " a + b;\n        ", "break", ";\n    ", "case", " ", "'-'", ":\n        ", "return", " a - b;\n        ", "break", ";\n    ", "case", " ", "'*'", ":\n        ", "return", " a * b;\n        ", "break", ";\n    ", "case", "'/'", ":\n        ", "return", " a / b;\n        ", "break", ";\n    ", "default", ":\n        ", "return", " ERROR;\n    }\n}\n", "OperandType ", "EvaluateExpression", "(", ")", "\n{", "//后缀表达式", "\n    ", "int", " ch;\n    ", "int", " x, a, b, theta;\n    SqStack OPTR, OPND;", "//操作符栈、操作数栈", "\n    InitStack(OPND);\n    InitStack(OPTR);\n    Push(OPTR, ", "'#'", ");\n    ch = getchar();\n    ", "while", " (ch != ", "'#'", " || GetTop(OPTR) != ", "'#'", ")\n    {\n        ", "if", " (!In(ch, OP))", "//不是运算符则进入OPND栈", "\n        {\n            Push(OPND, ch - ", "48", ");\n            ch = getchar();\n        }\n        ", "else", "\n            ", "switch", " (Precede(GetTop(OPTR), ch))\n            {\n            ", "case", " ", "'<'", ":\n                Push(OPTR, ch);\n                ch = getchar();\n                ", "break", ";\n            ", "case", " ", "'>'", ":\n                Pop(OPTR, theta);\n                Pop(OPND, b);\n                Pop(OPTR, a);\n                Push(OPND, Operate(a, theta, b));\n                ", "break", ";\n            ", "case", " ", "'='", ":\n                Pop(OPTR, x);\n                ch = getchar();\n                ", "break", ";\n            }\n    }\n    ", "return", " GetTop(OPND);\n}\n", "void", " ", "main", "(", ")", "\n{\n    printf(", "\"要求以字符序列的形式从终端输入语法正确，不含变量的整数表达式(以#结束）：\\n\"", ");\n    ", "int", " e = EvaluateExpression();\n    printf(", "\"%d\\n\"", ", e);\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void init(stack &amp;amp;s)   //初始化栈&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    s.base &amp;#61; (stackelm * )malloc(100 * sizeof(stackelm));&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    s.top &amp;#61; s.base;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    int stacksize &amp;#61; 100;&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;改为&lt;br /&gt;void init(stack &amp;amp;s)   //初始化栈&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    s.base &amp;#61; (stackelm * )malloc(100 * sizeof(stackelm));&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    s.top &amp;#61; s.base;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    s.stacksize &amp;#61; 100;&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["使用c语言栈完成对算术表达式的正确求值，如下程序可以通过编译，却无法正常运行，如何修改？", ["在dev c++和vc++中，均能通过编译，但无法正常运行，似乎是陷入死循环，但经检查逻辑没有错误，如何修改才能使其正常输出结果？", "\n", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<malloc.h>", "\n\n", "typedef", " ", "char", " stackelm;\n\n ", "struct", " ", "stack", "\n{\n    stackelm * top;\n    stackelm * base;\n    ", "int", " stacksize;\n};\n\n", "void", " ", "init", "(stack &s)", "   ", "//初始化栈", "\n", "{\n    s.base = (stackelm*)", "malloc", "(", "100", "*", "sizeof", "(stackelm));\n    s.top = s.base;\n    ", "int", " stacksize = ", "100", ";\n}\n\n", "bool", " ", "stackempty", "(stack s)", "  ", "//栈是否为空", "\n", "{\n    ", "if", " (s.top==s.base)\n    ", "return", " ", "true", ";\n    ", "else", "\n    ", "return", " ", "false", ";\n}\n\n", "void", " ", "push", "(stack &s, stackelm e)", "   ", "//入栈操作", "\n", "{\n    *s.top = e;\n    *s.top++; \n}\n\n", "stackelm ", "gettop", "(stack s, stackelm &e)", "   ", "//显示栈顶元素", "\n", "{\n    ", "if", "(s.top>s.base)\n    {\n    e = *(s.top", "-1", ") ;\n    ", "return", " ", "0", ";\n    }\n    ", "else", "\n    ", "return", " ", "-1", ";\n}\n\n", "stackelm ", "pop", "(stack &s, stackelm &e)", " ", "//出栈操作", "\n", "{\n    ", "if", " (", "stackempty", "(s)==", "false", ")\n    {\n    e = *(s.top", "-1", ");\n    *s.top--;\n    }\n    ", "else", "\n    ", "return", " ", "1", ";\n}\n\n\n", "char", " ", "precede", "(stackelm t1, stackelm t2)", "    ", "//判断t1 t2 两符号的优先级关系", "\n", "{\n    ", "char", " f;\n    ", "switch", " (t2)\n    {\n        ", "case", " ", "'+'", ":\n        ", "case", " ", "'-'", ":    \n        ", "if", " (t1 == ", "'('", " || t1 == ", "'\\n'", ")\n        f = ", "'<'", ";\n        ", "else", "\n        f = ", "'>'", ";\n        ", "break", ";\n        \n        ", "case", " ", "'*'", ":\n        ", "case", " ", "'/'", ":\n        ", "if", " (t1 == ", "'*'", " || t1 == ", "'/'", " || t1 == ", "')'", ")\n        f = ", "'>'", ";\n        ", "else", "\n        f = ", "'<'", ";\n        ", "break", ";\n        \n        ", "case", " ", "'('", ":\n        ", "if", " (t1 == ", "')'", ")\n        {\n        ", "printf", "(", "\"括号不匹配\\n\"", ");    \n        ", "exit", " (", "-1", ");\n        }\n        ", "else", "\n        f = ", "'<'", ";\n        ", "break", ";\n        \n        ", "case", " ", "')'", ":\n        ", "switch", " (t1)\n        {\n            ", "case", " ", "'('", ":\n            f = ", "'='", ";\n            ", "break", ";\n            \n            ", "case", " ", "'\\n'", ":\n            ", "printf", "(", "\"缺少左括号\\n\"", ");\n            ", "exit", " (", "-1", ");\n            ", "break", ";\n        \n            ", "default", ":\n            f = ", "'>'", ";\n        }\n        \n        ", "case", " ", "'\\n'", ":\n        ", "switch", " (t1)\n        {\n            ", "case", " ", "'\\n'", ":\n            f = ", "'='", ";\n            ", "break", ";\n            \n            ", "case", " ", "'('", ":\n            ", "printf", "(", "\"缺少右括号\\n\"", ");\n            ", "exit", " (", "-1", ");\n            ", "break", ";\n            \n            ", "default", ":\n            f = ", "'>'", ";\n        }\n        ", "return", " f;\n    }\n}\n\n", "bool", " ", "in", "(stackelm c)", " ", "//判断是否为七种运算符之一", "\n", "{\n    ", "switch", " (c)\n    {\n        ", "case", " ", "'+'", ":\n        ", "case", " ", "'-'", ":\n        ", "case", " ", "'*'", ":\n        ", "case", " ", "'/'", ":\n        ", "case", " ", "'('", ":\n        ", "case", " ", "')'", ":\n        ", "case", " ", "'\\n'", ":\n        ", "return", " ", "true", ";\n        \n        ", "default", ":\n        ", "return", " ", "false", ";\n    }\n}\n\n", "stackelm ", "operate", "(stackelm a, stackelm x, stackelm b)", "//进行四则运算", "\n", "{\n    ", "switch", " (x)\n    {\n        ", "case", " ", "'+'", ":\n        ", "return", " a+b;\n        \n        ", "case", " ", "'-'", ":\n        ", "return", " a-b;\n        \n        ", "case", " ", "'*'", ":\n        ", "return", " a*b;\n        \n        ", "case", " ", "'/'", ":\n        ", "return", " a/b;\n    }\n\n}\n\n", "stackelm ", "evaluateexpression", "()", "//调用上面的函数进行表达式求值", "\n", "{\n    stack OPTR, OPND;  ", "//OPTR存放运算符，OPND存放运算数", "\n    stackelm a,b,c,x;\n    ", "init", "(OPTR);\n    ", "init", "(OPND);\n    ", "push", "(OPTR,", "'\\n'", ");\n    c = ", "getchar", "();\n    ", "gettop", "(OPTR,x);\n    ", "while", " (c!=", "'\\n'", "||x!=", "'\\n'", ")  ", "//使用循环来求值", "\n    {\n        ", "if", " (", "in", "(c))\n        ", "switch", " (", "precede", "(x,c))\n        {\n            ", "case", " ", "'<'", ":\n            ", "push", "(OPTR,c);\n            c = ", "getchar", "();\n            ", "break", ";\n            \n            ", "case", " ", "'='", ":\n            ", "pop", "(OPTR,x);\n            c = ", "getchar", "();\n            ", "break", ";\n            \n            ", "case", " ", "'>'", ":\n            ", "pop", "(OPTR,x);\n            ", "pop", "(OPND,b);\n            ", "pop", "(OPND,a);\n            ", "push", "(OPND,", "operate", "(a,x,b));\n        }\n        ", "else", " ", "if", " (c >= ", "'0'", " && c <= ", "'9'", ")\n        {\n            ", "push", "(OPND,c", "-48", ");\n            c = ", "getchar", "();\n        }\n        ", "else", "\n        {\n            ", "printf", "(", "\"非法字符\\n\"", ");\n            ", "exit", " (", "-1", ");\n        }\n        ", "gettop", "(OPTR,x);\n    }\n    ", "pop", "(OPND,x);\n    ", "if", "(!", "stackempty", "(OPND))\n    {\n        ", "printf", "(", "\"表达式不正确\\n\"", ");\n        ", "exit", " (", "-1", ");\n    }\n    ", "return", " x;  ", "//x为输入表达式的最终运算结果", "\n    \n}\n", "int", " ", "main", "()", "\n", "{\n    ", "printf", "(", "\"%d\"", ",", "evaluateexpression", "());\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/269502262376155.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["ptthon词云图最简单的结果", ["文件如下", "\n", "Python学习总结", "   通过学习计算思维这门学科，我得以进入一个完全不同的世界，数码的世界，编程的世界。计算思维这么学科带我认识了Python，从中我又知道电脑是如何运作，对于电脑运行以及数码世界有了浅薄的认知。", "　　同时在python学习中，我知道了列表、字典、函数、类、对象等等，每一个看起来简单的词语的背后都是一套独有的思维方式，而也这些这一个个特有的“元素”汇聚成了Python语言这门课程，学习时间虽然很短，但是获得的知识是无穷的。每一节课堂内容的背后，我相信都是无数人知识、思维甚至是语言的集合，真的很感谢这门语言带给我的乐趣。下面是我的一些学习总结。", "　　学习中的第一个难点，就是循环逻辑的建构。Python的循环结构分为两种。分别是while和for循环。For 循环一般用于有限次数，while循环而用于未知次数的循环。在学习循环语句时，最大的感受就是逻辑的严密，什么地方要缩进，什么地方要结束，什么语句要置于循环的下方，一步也不能出错，大到逻辑的合理性，小到一个冒号是否添加。哪怕一个地方出现问题，电脑运行都会出现错误或者得出错误结论。在循环中对于列表，字典，元组……都有不同的循环遍历方式，不可以弄混淆。在我看来，循环语句是最考验逻辑严密性的一环了。", "　　接下来学习了函数和列表，元组，字典，集合这些不同键不同的区别以及如何对他们进行操作。下面我简单介绍一些基本操作方法。", "　　列表：列表是Python中使用最频繁的数据类型，集合中可以放任何数据类型，可对集合进行创建、查找、切片、增加、修改、删除、循环和排序操作。与字符串的索引一样，List索引从0开始，list 的数据项可以不同类型，list 的各个元素可以改变，list 是使用 [ ] 方括号包含各个数据项。+ 多个列表进行合并成一个列表 * 列表重复输出多次 in 某个项是否在列表中", "　　  Python中对序列提供了一些统计函数，其中len()函数就是可以获取序列长度的一个统计操作，可以结合range()哈数可以生成一个访问的索引范围，就可以实现循环索引访问列表的操作了。如果需要对列表进行排序或者反转等操作，那么通过索引这种访问就比较方便了。", "　　元组：Python 的元组与列表类似，不同之处在于元组的元素一旦初始化就不能修改。元组使用小括号 ( )，列表使用方括号 [ ]。元组与字符串类似，下标索引从0开始，可以进行截取，组合等。元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。", "　　元组可以进行访问，修改，删除，索引和截取操作。", "　　字典：字典是一种键值对的集合，列表是有序的对象集合，字典是无序的对象集合。字典是可变容器模型，且可存储任意类型对象字典可以通过键来引用，键必须是唯一的且键名必须是不可改变的（即键名必须为Number、String、元组三种类型的某一种），但值则不必。字典是使用 { } 大括号包含键值对，创建空字典使用 { }", "　　字典可以进行访问，添加，删除和修改功能。dict.keys( ) 以列表返回一个字典所有的键，dict.values( ) 以列表返回字典中的所有值，dict.items( ) 以列表返回可遍历元组数组，以上是字典的几种常见用法。", "　　集合：集合（set）是一个无序的不重复元素序列，它的主要作用有两个，分别是去重和关系测试。", "　　集合的基本用法是集合的去重，增删，判断集合是否存在以及集合的四种基础运算方法。", "　　这学期的计算思维课程让我接触到了一个全新的领域，哲理有着严格的条例，但同时又创造出无限的可能。手指飞快打出几行代码，输出的结果却可以是瑰丽的图形或是精确的数据。以上仅是我的一小段学习总结，但是计算思维这门课对我思维的锻炼，逻辑推理能力的增进，以及使我渐渐养成严谨认真的态度，使我终身受益。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-bash\"&gt;\n&lt;span class=\"hljs-keyword\"&gt;SELECT&lt;/span&gt; MAX(SUBSTR(ID,&lt;span class=\"hljs-number\"&gt;-4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)) &lt;span class=\"hljs-keyword\"&gt;AS&lt;/span&gt; maxid\n&lt;span class=\"hljs-keyword\"&gt;FROM&lt;/span&gt; customer c\n&lt;span class=\"hljs-keyword\"&gt;WHERE&lt;/span&gt; SUBSTR(id,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;) &amp;#61; TO_CHAR(SYSDATE,&lt;span class=\"hljs-string\"&gt;&amp;#39;yyyyddmm&amp;#39;&lt;/span&gt;)\n  &lt;span class=\"hljs-keyword\"&gt;AND&lt;/span&gt; SUBSTR(ID,&lt;span class=\"hljs-number\"&gt;-4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;IS&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;NOT&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;NULL&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;UNION&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;ALL&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;SELECT&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;0000&amp;#39;&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;AS&lt;/span&gt; maxid\n&lt;span class=\"hljs-keyword\"&gt;FROM&lt;/span&gt; dual\n&lt;span class=\"hljs-keyword\"&gt;WHERE&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;NOT&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;EXISTS&lt;/span&gt; (\n    &lt;span class=\"hljs-keyword\"&gt;SELECT&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;FROM&lt;/span&gt; customer c\n    &lt;span class=\"hljs-keyword\"&gt;WHERE&lt;/span&gt; SUBSTR(id,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;) &amp;#61; TO_CHAR(SYSDATE,&lt;span class=\"hljs-string\"&gt;&amp;#39;yyyyddmm&amp;#39;&lt;/span&gt;)\n      &lt;span class=\"hljs-keyword\"&gt;AND&lt;/span&gt; SUBSTR(ID,&lt;span class=\"hljs-number\"&gt;-4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;IS&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;NOT&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;NULL&lt;/span&gt;\n)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请问博主的意思是这样吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "关系运算符", "Question": ["在求最大值时，判断是否为空", ["想根据日期拼接生成流水号，在求该日订单最后4位最大值时，判断是否为空，如果为空的话将空值替换为0001，代码在下", "Oracle显示：无效的关系运算符", "应该怎么解决？", "SELECT max((SUBSTR(ID,-4,4))) AS maxid", "FROM customer c", "where SUBSTR(id,0,8)=TO_CHAR(SYSDATE ,'yyyyddmm')", "AND NVL(SUBSTR(ID,-4,4),0001)"]], "Tag": "程序设计"}
