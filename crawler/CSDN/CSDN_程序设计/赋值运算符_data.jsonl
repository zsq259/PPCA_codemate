{"Answer": "&lt;p&gt;初始化可以像你这样&amp;#xff0c;但是除了初始化之外&amp;#xff0c;后面数组名是一个常量&amp;#xff0c;不能赋值&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["为什么不可以在赋值语句中通过赋值运算符“＝”对字符数组整体赋值", ["下述对C语言字符数组的描述中错误的是 (c )", "\n", "\nA．字符数组可以存放字符串", "\nB．字符数组中的字符串可以整体输入、输出", "\nC．可以在赋值语句中通过赋值运算符“＝”对字符数组整体赋值", "\nD．不可以用关系运算符对字符数组中的字符串进行比较", "\n\n", "为啥c是错的嘞？", "\n\n", "难道s[10]={\"happy\"}这样 的语句不算是通过赋值运算符“＝”对字符数组整体赋值吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;后&amp;#43;&amp;#43;或先&amp;#43;&amp;#43; 不是优先级哪个高的问题&amp;#xff0c;是本身的功能不一样&amp;#xff0c;与优先级没有关系&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["后++或先++  与赋值运算符 的优先级哪个高一些", ["\n", "int", " a = ", "1", ";\n", "int", " b = ++a;\nConsole.", "WriteLine(", "a", ")", "  ", "//结果是2", "\n\n", "int", " c = ", "1", ";\n", "int", " d = c++;\nConsole.", "WriteLine(", "d", ")", ";", "//结果是1", "\n", "\n", "关于++a  和 a++ 我看到过一种解释，当后加时，赋值运算符的优先级是高于自增加运算符的，所以是先赋值，后自增", "\n", "那么为什么在先加时，a却是先自增在赋值呢，求解惑"]], "Tag": "程序设计"}
{"Answer": "为了防止不必要的值被复制。如果返回值，那么会把值都复制一遍再传到外面；返回引用的话，返回的对象还是与\\*this同一个地址，值就不会被复制了。\r\n\r\n如果有帮助，希望采纳，谢谢", "Konwledge_Point": "赋值运算符", "Question": ["在定义重载赋值运算符时，为什么要用应用做返回值。", ["class string", "\n{", "\n\n", "char *m_str;", "\n\n", "public:", "\n\n", "string(char *s）", "\n\n", "{", "\n\n", "m_str=s;", "\n\n", "}", "\n\n", "string()", "\n{};", "\n\n", "String & operator=(const string s) // 这里！！！返回值为啥是引用", "\n\n", "{", "\n\n", "m_str=s.m_str;", "\n\n", "return *this", "\n｝// 返回*this不是会调用析构函数的吗！", "\n\n", "};", "\n\n", "int main()", "\n\n", "{", "\n\n", "string s1(\"abc\"),s2;", "\n\n", "s2=s1;", "\n\n", "cout<<s2.m_str;", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;据我所知&amp;#xff0c;c&amp;#43;&amp;#43;除了指针&amp;#xff0c;没有NULL的空对象&amp;#xff0c;指针也要用nullptr。&lt;/p&gt;\n&lt;p&gt;所以T是什么类型&amp;#xff0c;都不会由NULL这种值&amp;#xff0c;如果是int类&amp;#xff0c;可以是0&amp;#xff0c;但不可以是NULL&amp;#xff0c;除非#define NULL 0 &amp;#xff0c;但换个类型&amp;#xff0c;比如string&amp;#xff0c;如何等于0呢。&lt;/p&gt;\n&lt;p&gt;不过好像java可以用NULL。&lt;/p&gt;\n&lt;p&gt;clear&amp;#xff08;&amp;#xff09;可以用delete[ ]数组&amp;#xff0c;size置零解决。&lt;/p&gt;\n&lt;p&gt;如果非要向int一样设成0&amp;#xff0c;可以用T&amp;#xff08;&amp;#xff09;&amp;#xff0c;如果T类型有默认构造函数。&lt;/p&gt;\n&lt;p&gt;另外拷贝赋值和移动赋值对于容器类&amp;#xff0c;最好都要有&amp;#xff0c;没有的话编译器给你生成的就不知道是啥样了。&lt;/p&gt;\n&lt;p&gt;移动赋值为了解决的是性能问题&amp;#xff0c;比如有个函数&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt; std::vector&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; func&amp;#xff08;&amp;#xff09;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当有移动赋值时候&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;std::vector&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; temp&amp;#61;&lt;span class=\"hljs-built_in\"&gt;func&lt;/span&gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;就不必再深拷贝一遍&amp;#xff0c;然后将func&amp;#xff08;&amp;#xff09;的临时对象析构&amp;#xff0c;否则简直就是对效率的侮辱。&lt;/p&gt;\n&lt;p&gt;看看右值相关的文献&amp;#xff0c;就能了解了。&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["MyVector类中赋值运算符和移动赋值运算符", ["\n", "\n", "要求要重载赋值运算符，还要一个移动赋值运算符，但是使用的时候需要区分这两个吗？为什么会报这样的错，要怎么改啊？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码及运行结果如下:&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/346068422156150.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Complex&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; image;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)\n    {\n        real &amp;#61; r; image &amp;#61; i;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r)\n    {\n        real &amp;#61; r; image &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;()\n    {\n        real &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; image &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n\n    ~&lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;()\n    {\n        &lt;span class=\"hljs-comment\"&gt;//do nothing&lt;/span&gt;\n    }\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *&amp;#61; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right) \n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a &amp;#61; real, b &amp;#61; image;\n        real &amp;#61; a * Right.real - b * Right.image;\n        image &amp;#61; b * Right.real &amp;#43; a * Right.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *&amp;#61; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n) \n    {\n        Complex &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;(n, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; *&amp;#61; t;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Complex comp)&lt;/span&gt;&lt;/span&gt;;\n\n};\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Complex comp)&lt;/span&gt;\n&lt;/span&gt;{\n    cout &amp;lt;&amp;lt; comp.real;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (comp.image &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        cout &amp;lt;&amp;lt; comp.image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (comp.image &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        cout &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; comp.image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Complex &lt;span class=\"hljs-title\"&gt;c1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Complex &lt;span class=\"hljs-title\"&gt;c2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    \n    \n    &lt;span class=\"hljs-comment\"&gt;//显示C1&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(c1);\n\n    &lt;span class=\"hljs-comment\"&gt;//与int类型相乘&lt;/span&gt;\n    c1 *&amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(c1);\n\n    \n    &lt;span class=\"hljs-comment\"&gt;//与复数相乘&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;Complex &lt;span class=\"hljs-title\"&gt;t&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    c2 *&amp;#61; t;\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(c2);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["定义复数类（Complex）", ["C++ 编写程序 ：包含必要的构造函数和析构函数，重载乘法赋值运算符“*=”实现复数与整数、复数与复数之间的乘法运算，自行举例并按照如下格式输出计算结果。（要求使用转换构造函数把整数转换为复数后进行计算）。", "输出格式示例：", "\n", "##怎么把输入的整数转为复数？", "##这里的构造函数和析构函数有什么作用（真的不太理解）🙏"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;斜杠t也就是tab健&amp;#xff0c;是四个空格&amp;#xff0c;c4 和c5就是八进制转换为10进制所对应的ASCII码值对应的字符&amp;#xff0c;通过int强制类型转换用%d输出即可&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c语言的运算符与表达式", ["请问c4，c5的ASCLL值如何表示?输出结果\\t应空多少行?", "麻烦高人指点一下，谢谢！!!"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/JoyZhou_/article/details/102482254", "Konwledge_Point": "赋值运算符", "Question": ["有没有老哥帮忙解决一下：定义类Course、类Person、类Student及类StuManage", ["定义类Course、类Person、类Student及类StuManage，", "\n其中Student类继承自Person类同时又包含多门课程Course信息，StuManage类包含多个学生信息。要求：", "\n1. 可依据自己对于题目的理解，抽象Course类的属性及功能。", "\n2. 可依据自己对于题目的理解，抽象Person类的属性及功能。", "\n3.Student类中通过重载运算符“<<”和“>>”，使之能够用于输入输出其对象；", "\n4.Student类中通过重载=赋值运算符，使之能够实现对象间赋值；", "\n5.StuManage类中通过重载[ ]数组下标运算符，实现根据学生的学号输出该学生的各门课成绩；", "\n6. 在main函数中定义各类对象，各对象需通过构造函数进行初始化，并测试其成员函数；"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;已经定义完毕后操作&amp;#xff0c;是赋值。&lt;br /&gt;定义的时候是初始化&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["C++ 关于赋值运算符的概念性问题", ["今天学习，C++ Primer 书中有这么几句话", "\n", "赋值运算符的左侧运算对象必须是一个可修改的左值。", "int i = 0;", "const int ci = i;    //初始化而非赋值", "\n", "首先初始化和赋值的区别我还是了解的，但不解的在于 const int ci = i;  这里。等号左边是一个不可修改的左值，不满足“赋值运算符的左侧运算对象必须是一个可修改的左值”，说明初始化语句里的等号不是赋值运算符。", "在我以往的认知里 ’=‘ 就是赋值运算符，赋值运算符就是 ’=‘ ，现在推导出 初始化语句里的等号不是赋值运算符感觉怪怪的。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这跟优先级没有关系&amp;#xff0c;是i&amp;#43;&amp;#43;的特性&amp;#xff0c;就是先用i当前值进行表达式计算&amp;#xff0c;计算结束后i再加1&lt;br /&gt;它相当于&lt;br /&gt;n&amp;#61;i;&lt;br /&gt;i&amp;#61;i&amp;#43;1;&lt;br /&gt;这两行代码的缩写&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["既然算术运算符优先级高于赋值运算符，为何n=i++是先把i值赋给n，i再自加", ["既然算术运算符优先级高于赋值运算符，为何n=i++是先把i值赋给n，i再自加"]], "Tag": "程序设计"}
{"Answer": "赋值运算符和复制构造函数都是用已存在的B对象来创建另一个对象A。不同之处在于：赋值运算符处理两个已有对象，即赋值前B应该是存在的；复制构造函数是生成一个全新的对象，即调用复制构造函数之前A不存在。 \nCTemp a(b); //复制构造函数，C++风格的初始化 \nCTemp a=b; //仍然是复制构造函数，不过这种风格只是为了与C兼容，与上面的效果一样 \n在这之前a不存在，或者说还未构造好。\nCTemp a; \na=b; //赋值运算符 \n在这之前a已经通过默认构造函数构造完成。\n\n而之所以要自定义这些，是因为防止有指针时浅拷贝造成错误。具体可百度 rule of three原则", "Konwledge_Point": "赋值运算符", "Question": ["关于复制构造函数跟赋值运算符重载", ["新手求指导 关于两个函数不太理解  复制构造的是同一个内存地址吗 为什么要重载赋值运算符 "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Python 赋值过程中不明确区分拷贝和引用&amp;#xff0c;一般对静态变量的传递为拷贝&amp;#xff0c;对动态变量的传递为引用。&lt;br /&gt;&lt;a href=\"https://www.runoob.com/w3cnote/python-variable-references-and-copies.html\" id=\"textarea_1661420695336_1661420785802_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://www.runoob.com/w3cnote/python-variable-references-and-copies.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["Java和Python的赋值运算符=是不是都是引用改名而已，不是值复制？", ["Java和Python的赋值运算符=是不是都是引用改名而已，而不是值复制？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用得太少了&amp;#xff0c;自然生疏&amp;#xff0c;就如你跟生人打交道&amp;#xff0c;一回生二回熟。&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["这种赋值运算符的学习适应有没有什么技巧？", ["\n", "\n", " 看的话勉强都能看懂就是要多反应一下，没有a＝a+1看的那么直观，想把这部分掌握透熟练的话有什么技巧吗？或者说怎么理解这个赋值运算符才能更容易掌握！"]], "Tag": "程序设计"}
{"Answer": "首先，区别初始化和赋值。初始化指为处于“混沌”状态的变量提供初始值，构造新的对象。变量初始化之前，它占用的内存区域的数据是未知的、无意义的，所以说它处于“混沌”的状态。严格地说，赋值指以参数值更新对象现有的值，在更新之前可能需要清理现有的资源，比如通过new申请的存储空间。参考下面的代码：\r\n```\r\nclass StringPtr \r\n{\r\npublic:\r\n\tStringPtr() : \r\n\t\tidx(++sidx),\r\n\t\tps(nullptr)\r\n\t{\r\n\t\tcout &lt;&lt; \"StringPtr(), \" &lt;&lt; *this &lt;&lt; endl;\r\n\t}\r\n\tStringPtr(const string&amp; s) :\r\n\t\tidx(++sidx),\r\n\t\tps(new string(s))\r\n\t{\r\n\t\tcout &lt;&lt; \"StringPtr(const string&amp;), \" &lt;&lt; *this &lt;&lt; endl;\r\n\t}\r\n\tStringPtr(const StringPtr&amp; obj) :\r\n\t\tidx(++sidx)\r\n\t{\r\n\t\tassign(obj);\r\n\t\tcout &lt;&lt; \"StringPtr(const StringPtr&amp;), \" &lt;&lt; *this &lt;&lt; endl;\r\n\t}\r\n\tStringPtr&amp; operator=(const StringPtr&amp; arg)\r\n\t{ \r\n\t\tassign(arg);\r\n\t\tcout &lt;&lt; \"StringPtr.operator=(const StringPtr&amp;), \" &lt;&lt; *this &lt;&lt; endl;\r\n\t\treturn *this;\r\n\t}\r\n\t~StringPtr() \r\n\t{\r\n\t\tcout &lt;&lt; \"~StringPtr(), \" &lt;&lt; *this &lt;&lt; endl;\r\n\t\tif (ps)\r\n\t\t{\r\n\t\t\tdelete ps;\r\n\t\t\tps = nullptr;\r\n\t\t}\r\n\t}\r\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; os, const StringPtr&amp; sp);\r\nprivate:\r\n\tvoid assign(const StringPtr&amp; arg)\r\n\t{\r\n\t\tif (&amp;arg != this)\r\n\t\t{\r\n\t\t\tif (ps)\r\n\t\t\t{\r\n\t\t\t\tdelete ps;                // 释放之前通过new创建的对象\r\n\t\t\t\tps = nullptr;\r\n\t\t\t}\r\n\t\t\tif (arg.ps)\r\n\t\t\t\tps = new std::string(*arg.ps);\r\n\t\t}\r\n\t}\r\n\r\n\tstatic int sidx;\r\n\r\n\tint idx;\t\t\t\t\t\t        // 唯一索引号，所有对象的索引不同\r\n\tstring* ps;\r\n};\r\n\r\nint StringPtr::sidx = 0;\r\n\r\nostream&amp; operator&lt;&lt;(ostream&amp; os, const StringPtr&amp; sp)\r\n{\r\n\tos &lt;&lt; \"idx : \" &lt;&lt; sp.idx &lt;&lt; \", ps : \" &lt;&lt; (sp.ps ? *sp.ps : \"\");\r\n\treturn os;\r\n}\r\n\r\nvoid example()\r\n{\r\n\tstring s(\"2019-10-06\");\r\n\tStringPtr p1(s);\t\t\t\t        // 初始化，调用StringPtr(const string&amp;)\r\n\tStringPtr p2(p1);\t\t\t\t       // 初始化，调用StringPtr(const StringPtr&amp;)\r\n\tStringPtr p3 = p1;\t\t\t\t      // 初始化，调用StringPtr(const StringPtr&amp;)\r\n\tStringPtr p4;\t\t\t\t\t        // 初始化，调用StringPtr().这里没有提供初值，使用默认值.\r\n\tp4 = p1;\t\t\t\t\t\t         // 拷贝赋值，调用StringPtr.operator=(const StringPtr&amp;)\r\n}\r\n```\r\n考虑`StringPtr p3 = p1;\t`，此处虽然使用了赋值运算符，但是变量p3尚未初始化，初始化之前它还不是StringPtr类型的对象，如何对它调用拷贝赋值运算呢？\r\n\r\n有关初始化的详细内容，请参考：[https://zh.cppreference.com/w/cpp/language/initialization](https://zh.cppreference.com/w/cpp/language/initialization \"\")", "Konwledge_Point": "赋值运算符", "Question": ["C++ 为什么会调用拷贝构造函数而不是拷贝赋值运算符？", ["如题", "\n\n", "#include <string>\n\nstruct X {\n   X() { std::cout << \"X()\" << std::endl; } // 构造函数\n   X(const X &x) { std::cout << \"X(const X&)\" << std::endl; } // 拷贝构造函数\n   X &operator=(const X &x) { // 赋值拷贝运算符\n      std::cout << \"X=\" << std::endl;\n      return *this;\n   }\n   ~X() { std::cout << \"~X()\" << std::endl; }\n};\n\nint main() {\n   X a;\n   X b(a);\n   X c = a; // 我期待这里调用拷贝赋值运算符，但实际是调用拷贝构造函数\n}\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;一、你没有提供拷贝构造函数&lt;br /&gt;二、你的operator&amp;lt;&amp;lt; 参数应该是const 引用而不是值&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["赋值运算符重载，内存重复释放", ["问题遇到的现象和发生背景", "\n", "在练习赋值运算符重载，重复释放问题", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Person", "\n{\n    ", "friend", " ostream &", "operator", "<<(ostream &cout, Person p);\n\n", "public", ":\n    ", "Person", "(", "int", " age, ", "double", " height);\n    ~", "Person", "();\n    Person &", "operator", "=(Person &p);\n\n", "private", ":\n    ", "int", " m_age;\n    ", "double", " m_height;\n    ", "int", " *m_grade;\n};\nPerson::", "Person", "(", "int", " age, ", "double", " height)\n{\n    m_age = age;\n    m_height = height;\n    m_grade = ", "new", " ", "int", "(", "100", ");\n}\nPerson::~", "Person", "()\n{\n    ", "if", " (m_grade != ", "NULL", ")\n    {\n        ", "delete", " m_grade;\n        m_grade = ", "NULL", ";\n    }\n}\nostream &", "operator", "<<(ostream &cout, Person p)\n{\n    cout << ", "\"age=\"", " << p.m_age << ", "\"\\t\"", "\n         << ", "\"height=\"", " << p.m_height << ", "\"\\tgrade=\"", " << *p.m_grade;\n\n    ", "return", " cout;\n}\nPerson &Person::", "operator", "=(Person &p)\n{\n    ", "this", "->m_age = p.m_age;\n    ", "this", "->m_height = p.m_height;\n    ", "if", " (", "this", "->m_grade != ", "NULL", ")\n    {\n        ", "delete", " ", "this", "->m_grade;\n        ", "this", "->m_grade = ", "NULL", ";\n    }\n    ", "this", "->m_grade = ", "new", " ", "int", "(*p.m_grade);\n    ", "return", " *", "this", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "Person ", "p1", "(", "19", ", ", "179.8", ")", ";\n    ", "Person ", "p2", "(", "15", ", ", "170", ")", ";\n    p2 = p1;\n    cout << p2 << endl;\n\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "重复释放内存", "\n", "我的解答思路和尝试过的方法", "\n", "运算符重载，重新开辟内存", "\n", "我想要达到的结果", "\n", "正常运行"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The fetch_assoc fetches one result row at a time and stores it in $row. Since this is in a loop, you are fetching until you run out of rows&lt;/p&gt;\n\n&lt;p&gt;In the loop you are essentially pushing the $row value into a $people array&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["while循环与赋值运算符", ["\n\n", "I can't seem to figure out how this loop works in PHP:", "\n\n", "$people = array();\nwhile($row = $result->fetch_assoc())\n    $people[] = $row;\n", "\n\n", "It seems as though the loop would just keep going, infinitely. But, it doesn't How exactly does this work? Can someone explain it to me step-by-step? I'm guessing that the while loop could also be written like this:", "\n\n", "while(($row = $result->fetch_assoc()) == true)\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;PHP doesn't appear to have this functionality. There is nothing in the &lt;a href=\"https://secure.php.net/manual/en/language.operators.assignment.php\" rel=\"nofollow noreferrer\"&gt;Assignment Operator documentation&lt;/a&gt; or in the &lt;a href=\"https://secure.php.net/manual/en/language.operators.logical.php\" rel=\"nofollow noreferrer\"&gt;Logical Operators documentation&lt;/a&gt; that mentions this functionality. Also, it isn't included in the &lt;a href=\"https://secure.php.net/manual/en/language.operators.assignment.php#40084\" rel=\"nofollow noreferrer\"&gt;top rated comment on the Assignment Operator page&lt;/a&gt;, which is a list that someone compiled of all of the assignment operators from information in the other pages.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["PHP中的逻辑赋值运算符", ["\n\n", "There doesn't seem to be a logical assignment operator in PHP. I would like to be able to write ", "$a = $a || $b", " as ", "$a ||= $b", ".", "\n\n", "Note that this is not the same as ", "$a |= $b", ", which does not short-circuit when ", "$a", " evaluates to ", "true", ".", "\n\n", "Is there such functionality in PHP?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对两种写法的 p2 &amp;#61; p1 语句分类讨论:&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;void operator&amp;#61;(person p)&lt;br /&gt;首先调用的是(合成)复制构造函数, 也就是是你所说的创建一份 p1 的复制品(假设为temp_p1), 然后调用赋值构造函数 (void operator&amp;#61;(person temp_p1)) 进行传值,  因此 p2 的输出是正确的, 但是临时对象在赋值过后是要被销毁的, 而复制构造函数中传入的参数为 p1 的引用, 所以最后销毁的也就是 p1 这个对象,  所以读到的值是错的, 至于为什么还能读到数值就不清楚了, 希望有大佬看到后解答一下。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;person(person const &amp;amp;p) // 产生临时对象所调用的复制构造函数&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    this-&amp;gt;m_p &amp;#61; p.m_p;&lt;/span&gt;&lt;br /&gt;}&lt;/p&gt;\n&lt;ol start=\"2\"&gt;&lt;li&gt;void operator&amp;#61;(person &amp;amp;p)&lt;br /&gt;不产生临时对象, 所以自然也就不会调用析构函数。&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "赋值运算符", "Question": ["赋值运算符重载的问题", ["问题遇到的现象和发生背景", "\n", "\n", "class", " ", "person", "{\n    \n", "public", ":\n    ", "person", "(", "int", " a)\n    {\n        m_p = ", "new", " ", "int", "(a);\n     } \n     \n     \n     ~", "person", "()\n    {\n        ", "if", "(m_p != ", "NULL", ")\n        {\n            ", "delete", " m_p;\n            m_p = ", "NULL", "; \n         } \n    } \n    \n    \n    ", "int", " *m_p;\n    \n    ", "void", " ", "operator", "=(person p)\n    {\n        ", "if", "(", "this", "->m_p != ", "NULL", ")\n        {\n            ", "delete", " ", "this", "->m_p;\n            ", "this", "->m_p = ", "NULL", "; \n        }\n    \n        ", "this", "->m_p = ", "new", " ", "int", "(*p.m_p);\n    }\n};\n", "void", " ", "text1", "()", "\n", "{\n    \n    ", "person ", "p1", "(", "10", ")", ";\n    ", "person ", "p2", "(", "20", ")", ";\n    p2 = p1;\n    cout<<", "\"p1.age=\"", "<<*p1.m_p<<endl;\n    cout<<", "\"p2.age=\"", "<<*p2.m_p<<endl;\n}\n", "\n", "\n", "cout<<\"p1.age=\"<<*p1.m_p<<endl;  输出一串数字 而不是 10", "\n", "void operator=(person p)  写成  void operator=(person & p)  就可以正常运行", "\n", "\n", "传值 不是创建一份  p1 的复制品", "复制的p1 中的m_p 的指向 也是堆区的那块空间", " 解引用赋值到 p2创建的空间上 （ this->m_p = new int(*p.m_p);）", "为啥输出的不是10 而是随机数"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇博客也许可以解决你的问题&amp;#x1f449; &amp;#xff1a;&lt;a href=\"https://blog.csdn.net/zhangfei5354/article/details/89176163\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;C&amp;#43;&amp;#43;拷贝构造与赋值重载问题&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c++赋值运算符重载与引用", ["正确答案：\n", "\n", " p2:pen", " pl:pen", " p3:pen", " p4:bookpen", "\n", "\n\n String &operator=(const String &r)\n {\n     ", "if", "(&r==this)", "//", "//", "//", "//", "//", "/1.为什么要判断这个/", "//", "//", "//", "问题主要是出现在这里\n    {\n       return *this;\n        }\n  ", "//", "//", "2", ".如果没有这句话 \n", "//", "效果如下\n", "\n", " p2:pen", " pl:pen", " p3:pen", " p4:pen", "\n", "\n", "//3.如果判断是否为空 第四行直接不输出", "\n        ", "else", "\n     {\n       ", "int", " len=", "strlen", "(r.ptr);\n     ptr=", "new", " ", "char", "[len+", "1", "];\n     ", "strcpy", "(ptr,r.ptr);\n     ", "return", " *", "this", ";}\n }\n\n\n ", "String", " &", "operator", "+=(", "String", " &r)\n {\n     ", "char", " *kk=ptr;\n     ptr=", "new", " ", "char", "[", "strlen", "(ptr)+", "strlen", "(r.ptr)+", "1", "];", "/////开辟新数组来储存 ", "\n     ", "strcpy", "(ptr,kk);\n     ", "strcat", "(ptr,r.ptr);\n     ", "delete", "[] kk;", "//释放 ", "\n     ", "return", " *", "this", ";\n }\n};", "//主函数", "\n", "int", "  ", "main", "( )", "\n", "{ ", "String", "  ", "p1", "(", "\"book\"", ")", ", ", "p2", "(", "\"pen\"", ")", ",", "p3", "(", "\"good\"", ")", ",p4", ";\n p4 = p4 = p1 ;\n p3 = p1 = p2;\n cout<<", "\"p2:\"", ";\n p2.", "print", "();\n cout<<", "\"p1:\"", "<<p1;\n cout<<", "\"p3:\"", "<<p3;\n p4+=p3;\n cout<<", "\"p4:\"", "<<p4;\n ", "return", " ", "0", ";\n}\n", "\n", "求解"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The two versions may be &lt;strong&gt;functionally different&lt;/strong&gt; (thank you for the hint, Volker):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport \"fmt\"\n\nvar idx int\nfunc n() int {\n    idx++\n    return idx - 1\n}\n\nfunc main() {\n    var nums = [2](int){ 1, 2 }\n    var adj = 10\n\n    if true {\n        nums[ n() ] += adj                   // Prints [11 2]\n    } else {\n        nums[ n() ] = nums[ n() ] + adj      // Prints [12 2]\n    }\n\n    fmt.Println(\"%v\", nums)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(You can play with it &lt;a href=\"https://play.golang.org/p/LP3dTv_kDc\" rel=\"nofollow noreferrer\"&gt;here&lt;/a&gt;.)&lt;/p&gt;\n\n&lt;p&gt;An equivalent C program behaves in exactly the same way.&lt;/p&gt;\n\n&lt;p&gt;The fact that this was surprising to me is itself surprising:  I seldom call functions to get an array index directly, so the thought never crossed my mind.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["GOPL：二进制赋值运算符“可以避免重新评估？”", ["\n\n", "Page 36 of the ", "Go Programming Language", " (GOPL) contains the following:", "\n\n", "\n  ", "Each of the arithmetic and bitwise binary operators has a corresponding ", "assignment operator", " allowing, for example, the last statement to be rewritten as", "\n  \n  ", "count[x] *= scale", "\n  \n  ", "which saves us from having to repeat (and re-evaluate) the expression for the variable.", "\n", "\n\n", "I do not understand the part about re-evaluation.  Do the authors mean to say that", "\n\n", "count[x] = count[x] * scale\n", "\n\n", "and", "\n\n", "count[x] *= scale\n", "\n\n", "compile to different bytecode?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;pre&gt;&lt;code&gt;$originalName = false === $pos ? $originalName : substr($originalName, $pos + 1);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Expansion above process:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if($pos === false) {\n   $originalName = $originalName;\n} else {\n   $originalName = substr($originalName, $pos + 1);\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if($pos !== false) {\n   $originalName = substr($originalName, $pos + 1);\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["PHP相同比较运算符与赋值运算符相结合[重复]", ["\n\n", "\n    ", "This question already has an answer here:", "\n    ", "\n", "\n            ", "What are the PHP operators “?” and “:” called and what do they do?", "\n                \n                    9 answers\n                \n        ", "\n    ", "\n", "\n\n", "The following code is from Symfony 2, input string 'folder/file.exe', will output 'file.exe'.", "\n\n", "protected function getName($name)\n{\n    $originalName = str_replace('\\\\', '/', $name);\n    $pos = strrpos($originalName, '/');\n    $originalName = false === $pos ? $originalName : substr($originalName, $pos + 1);\n\n    return $originalName;\n}\n", "\n\n", "However, I can understand everything but the following code structure:", "\n\n", "    $var = false === 'something';\n", "\n\n", "Can anyone explain this to me? Thanks!", "\n\n", "Edit:Thanks all for helping me, maybe the following code is more clear than the above code:", "\n\n", "    $originalName = ((false === $pos) ? $originalName : substr($originalName, $pos + 1));\n", "\n\n", "</div>\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这就跟a&amp;#61;b&amp;#61;c&amp;#61;d&amp;#61;0是一样的&lt;br /&gt;从右往左依次赋值&lt;br /&gt;等价于&lt;br /&gt;m-&amp;#61;15;&lt;br /&gt;m*&amp;#61;m;&lt;br /&gt;m&amp;#43;&amp;#61;m;&lt;br /&gt;m&amp;#61;m;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["赋值运算符的使用，复制表达式如何运算", ["这个m的计算结果为啥是200呢", "求指点指点这行代码的计算过程，十分感谢！"]], "Tag": "程序设计"}
{"Answer": "polynode::polynode(const polynode &amp;p)\r\n{\r\n\tint k = p.number;\r\n\tpoly temp,head,rear;\r\n\ttemp= (p.head)-&gt;link;\r\n\thead = new polynomial;\r\n\thead-&gt;link = NULL;\r\n\trear = head;\r\n\twhile (k--)\r\n\t{\r\n\r\n\t\trear-&gt;link = new polynomial;\r\n\t\trear-&gt;link-&gt;coe = temp-&gt;coe;\r\n\t\trear-&gt;link-&gt;exp = temp-&gt;exp;\r\n\t\trear = rear-&gt;link;\r\n\t\ttemp = temp-&gt;link;\r\n\t}\r\n\r\n}\r\n这里不对，poly temp,head,rear;你又定义了head和rear，所以操作的不是成员变量的head和rear，而是同名的局部变量。\r\n\r\n导致temp = (p.head)-&gt;link;\r\n这里head没有初始化", "Konwledge_Point": "赋值运算符", "Question": ["用链表类完成一元多项式的加法 为什么vs在重载赋值运算符的时候断点，说head访问权限冲突？", ["#include \"pch.h\"", "\n#include ", "\nusing namespace std;", "\nstruct polynomial", "\n{", "\n    int coe;", "\n    int exp;", "\n    polynomial ", "link;", "\n};", "\ntypedef struct polynomial", " poly;", "\nclass polynode", "\n{", "\nprivate:", "\n    poly head;", "\n    poly rear;", "\n    int number;", "\n    void attach(int x, int y);", "\n    void connection(int x, int y, poly& p);", "\npublic:", "\n    polynode();", "\n    polynode(const polynode &p);", "\n    void readpoly();", "\n    polynode operator+(polynode &p);", "\n    polynode& operator=(const polynode& p);", "\n    void printpoly();", "\n    ~polynode();", "\n};", "\npolynode::polynode()", "\n{", "\n    head = new struct polynomial;", "\n    head->link = NULL;", "\n    rear = head;", "\n    number = 0;", "\n}", "\npolynode::polynode(const polynode &p)", "\n{", "\n    int k = p.number;", "\n    poly temp,head,rear;", "\n    temp= (p.head)->link;", "\n    head = new polynomial;", "\n    head->link = NULL;", "\n    rear = head;", "\n    while (k--)", "\n    {", "\n\n", "    rear->link = new polynomial;\n    rear->link->coe = temp->coe;\n    rear->link->exp = temp->exp;\n    rear = rear->link;\n    temp = temp->link;\n}\n", "\n\n", "}", "\n\n", "void polynode::attach(int x, int y)", "\n{", "\n    poly p;", "\n    p = new struct polynomial;", "\n    p->coe = x;", "\n    p->exp = y;", "\n    rear->link = p;", "\n    rear = p;", "\n    number++;", "\n}", "\nvoid polynode::connection(int x, int y, poly& p)", "\n{", "\n    poly t;", "\n    t = new struct polynomial;", "\n    t->coe = x;", "\n    t->exp = y;", "\n    t->link = p->link;", "\n    p->link = t;", "\n    number++;", "\n}", "\n//读入函数试下来因该是没有问题的", "\nvoid polynode::readpoly()", "\n{", "\n    int num,ix,iy;", "\n    poly p;", "\n    cout << \"有多少项？\" << endl;", "\n    cin >> num;", "\n    cout << \"请输入：\" << endl;", "\n    cin >> ix >> iy;", "\n    attach(ix, iy);", "\n    num--;", "\n    while (num--)", "\n    {", "\n        cin >> ix >> iy;", "\n        p = head->link;", "\n        if (p->exp == iy)", "\n        {", "\n            p->coe += ix;", "\n            p->exp = iy;", "\n        }", "\n        while (p->exp > iy)", "\n        {", "\n            if (p == rear)", "\n            {", "\n                attach(ix, iy); ", "\n                break;", "\n            }", "\n            else", "\n            {", "\n                if ((p->link)->exp >= iy)", "\n                    p = p->link;", "\n                else", "\n                    connection(ix, iy, p); break;", "\n            }", "\n        }", "\n            if (p->exp < iy)", "\n                connection(ix, iy, head);", "\n\n", "}\n", "\n\n", "}", "\n//加法算法试下来也没有", "\npolynode polynode::operator+(polynode &p)", "\n{", "\n    int m, n;", "\n    static polynode result;", "\n    poly b, q;", "\n    m = number;", "\n    n = p.number;", "\n    b = head->link;", "\n    q = (p.head)->link;", "\n    while (m != 0 && n != 0)", "\n    {", "\n        if (b->exp == q->exp)", "\n        {", "\n            result.attach(b->coe + q->coe, b->exp);", "\n                b = b->link;", "\n                q = q->link;", "\n            m--; n--;", "\n        }", "\n        else {", "\n            if (b->exp > q->exp)", "\n            {", "\n                result.attach(b->coe, b->exp);", "\n                    b = b->link;", "\n                m--;", "\n            }", "\n            else {", "\n\n", "                result.attach( q->coe, q->exp);\n                    q = q->link;\n                n--;\n            }\n    }\n}\nif (m == 0 && n == 0)\n{\n    result.printpoly();\n    return result;\n}\nelse {\n    if (m == 0)\n    {\n        while (n--)\n        {\n            result.attach(q->coe, q->exp);\n            q = q->link;\n        }\n    }\n    else\n        while (m--)\n        {\n            result.attach(b->coe, b->exp);\n            b = b->link;\n        }\n    result.printpoly();\n    return result;\n}\n", "\n\n", "}", "\npolynode& polynode::operator=(const polynode& p)", "\n{", "\n\n", "int k = p.number;\npoly temp;\ntemp = (p.head)->link;\n\n    while (k--)\n    {\n\n        rear->link = new polynomial;\n        rear->link->coe = temp->coe;\n        rear->link->exp = temp->exp;\n        rear = rear->link;\n        temp = temp->link;\n    }\n\nreturn *this;\n", "\n\n", "}", "\nvoid polynode::printpoly()", "\n{", "\n    cout << \"print:\" << endl;", "\n    poly p=head->link;", "\n    int m;", "\n    m = number;", "\n    while (m--)", "\n    {", "\n        cout << p->coe << p->exp << \" \";", "\n        p = p->link;", "\n    }", "\n    cout << endl;", "\n}", "\npolynode::~polynode()", "\n{", "\n    poly p=head;", "\n\n", "while (number--) {\n    p = head;\n    head = head->link;\n    delete p;\n}\n", "\n\n", "}", "\n\n", "int main()", "\n{", "\n    polynode p1,p2,p3;", "\n    p1.readpoly();", "\n    p1.printpoly();", "\n    p2.readpoly();", "\n    p3=p1 + p2;", "\n    p3.printpoly();", "\n    system(\"pause\");", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;pre&gt;&lt;code&gt;$POST['sendmail'] == 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;should be:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$_POST['sendmail'] == 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Doing assignment instead of comparison is not what you want.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$_POST['sendmail'] = 1\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;is &lt;em&gt;truthy&lt;/em&gt; because the value being assigned (&lt;code&gt;1&lt;/code&gt;) is truthy. If you did &lt;code&gt;if ($var = 0)&lt;/code&gt; instead it would never pass.&lt;/p&gt;\n\n&lt;p&gt;You should also consider using &lt;code&gt;===&lt;/code&gt;. This works if you know the type of both variables. &lt;code&gt;$_POST&lt;/code&gt; input is always strings, so:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$_POST[\"sendmail\"] === \"1\"\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["如果条件不在运算符'相等'上工作并且在赋值运算符上工作", ["\n\n", "Hello I have a strange problem in which my If statement is not working. I am doing a simple user registration and would like to check if the variable 'sendmail' is equal to 1, to send an e-mail if not to not send e-mail. I have shorten the mail function code for better understanding:", "\n\n", "$usr->storeFormValues( $_POST );\n/* check if the password is the same */\nif( $_POST['password'] == $_POST['conpassword'] && $_POST['email'] == $_POST['emailconfirm'] ) {\n\n/* Check if the sendmail variable is equal to 1 */  \nif ($POST['sendmail'] == 1){\n/* send e-mail function the */\n\nmail($to,$email_subject,nl2br($email_body),$headers);   \n\n}\necho $usr->register($_POST); \n", "\n\n", "So the problem is that the condition in this case  ", "if ($POST['sendmail'] == 1)", " is not working, and it is not sending the e-mail. In case if I write it like this  if ", "($POST['sendmail'] = 1)", " this way is working no matter what argument the variable sendmail have inside it, it is always sending the e-mail.", "\n\n", "this is from where ", "sendmail", " is coming", "\n\n", "<select name=\"sendmail\"> \n<option  value=\"0\">No</option>\n<option  value=\"1\">Yes</option> \n</select>\n", "\n\n", "I've checked the post array and the variable sendmail is inside so this can't be the problem.\nAny help will be very welcome. Thank you.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;strong&gt;No&lt;/strong&gt;, not necessary but it is good practice to declare/initialize your variables first.&lt;/p&gt;\n\n&lt;p&gt;Actually, if you follow any coding standards you would clearly &lt;strong&gt;avoid&lt;/strong&gt; using the concatenation assignment operator; &lt;em&gt;you get the PHP notice for a reason&lt;/em&gt; for doing so.&lt;/p&gt;\n\n&lt;p&gt;The second case is not necessarily bad. If an array variable is used in a closure and there is no ambiguity it's arguably fine. But if we talking about a large file, a class property, or another critical piece, you arguably still doing it wrong when you use (associative) arrays that way.&lt;/p&gt;\n\n&lt;p&gt;The general advice here is, follow the coding standards that the framework at hand puts forth. Most bigger frameworks have a coding guide (here is a nice &lt;a href=\"https://softwareengineering.stackexchange.com/questions/149303/naming-classes-methods-functions-and-variables\"&gt;overview&lt;/a&gt;), otherwise stick to &lt;a href=\"https://www.php-fig.org/psr/psr-2/\" rel=\"nofollow noreferrer\"&gt;PSR-2&lt;/a&gt; and &lt;a href=\"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md\" rel=\"nofollow noreferrer\"&gt;PSR-1&lt;/a&gt; or some custom coding standard (e.g. &lt;a href=\"https://gist.github.com/ryansechrest/8138375\" rel=\"nofollow noreferrer\"&gt;this&lt;/a&gt;); the important thing is: &lt;strong&gt;be consistent&lt;/strong&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["是否有必要在php中使用连接赋值运算符之前定义变量？", ["\n\n", "I've tried and came to know that if i use ", "\n\n", "$a .=\"test\";\n$a .=\" test2\";\n", "\n\n", "and echo out $a", "\n\n", "echo $a\n", "\n\n", "it returns ", "\n\n", "test test2\n", "\n\n", "also for arrays", "\n\n", "<?php \n$testarray['Title'] = \"test\";\n$testarray['text'] = \"text\";\n print_r($testarray); \n\n ?>\n", "\n\n", "it gives the proper result without declaring $testarray=[];", "\n\n", "Array ( [Title] => test [text] => text )\n", "\n\n", "It does not even shows the warning or notice.. so i just want to know is it good practice to declare the variable before or both are ok.. also if it is related to any particular php version.. i am using php 7.1 will it show error in earlier version?", "\n    "]], "Tag": "程序设计"}
{"Answer": "建议将sstring的拷贝构造函数的参数类型改为const引用，即sstring(const sstrings&amp;)；非const引用不能接受临时对象，而28行return了一个临时sstring对象。同时注意28行少了一个分号哦", "Konwledge_Point": "赋值运算符", "Question": ["赋值运算符重载前调用 class（）为什么会出现class：：class（class）的错误", ["obj obj::operator=(obj& obb)", "\n{", "\n    return obj(obb.element);", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;当一个类没有默认构造函数&amp;#xff08;default constructor)、析构函数、拷贝构造函数、赋值操作符函数&amp;#xff0c;&amp;#xff08;这些函数都属于成员函数&amp;#xff09;编译器会自动声明一个&lt;/li&gt;&lt;li&gt;友元函数不算成员函数&amp;#xff0c;只是可以访问类里的成员&lt;/li&gt;&lt;li&gt;结合上面两点&amp;#xff0c;当你通过友元函数重载了一个赋值函数&amp;#xff0c;编译器会发生冲突&amp;#xff08;不知道调用哪一个函数&amp;#xff09;&amp;#xff0c;所以会报错&lt;/li&gt;&lt;li&gt;小建议&amp;#xff08;不重要&amp;#xff0c;可忽略&amp;#xff09;&amp;#xff1a;运算符重载考虑到可以连续赋值情况&amp;#xff0c;一般返回值推荐返回这个类的引用&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "赋值运算符", "Question": ["为什么赋值运算符不能写成友元函数，只能写成成员函数呢？", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The compiler doesn't complain about the &lt;code&gt;global_var&lt;/code&gt; outside main. It &lt;strong&gt;only complains about the newly created &lt;code&gt;global_var&lt;/code&gt; in main&lt;/strong&gt; that you don't use. Which you can check by looking at the line number that &lt;code&gt;go&lt;/code&gt; mentions.&lt;/p&gt;\n\n&lt;p&gt;You can try an empty program with a &lt;code&gt;global_var&lt;/code&gt; outside any function that nobody references: no problems there. And of course, the &lt;code&gt;usesGlobalVar&lt;/code&gt; function that &lt;em&gt;does&lt;/em&gt; reference the actual global symbol has nothing to do with the one you create in &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["具有联合声明/赋值运算符的全局变量内联赋值和另一个未声明的变量丢失范围？", ["\n\n", "This Go program will not compile. It throws the error ", "global_var declared and not used", "\n\n", "package main\n\nimport \"log\"\n\nvar global_var int\n\nfunc main() {\n\n    global_var, new_string := returnTwoVars()\n\n    log.Println(\"new_string: \" + new_string)\n}\n\nfunc returnTwoVars() (int, string) {\n    return 1234, \"woohoo\"\n}\n\nfunc usesGlobalVar() int {\n    return global_var * 2\n}\n", "\n\n", "However, when I remove the need for using the ", ":=", " operator by declaring ", "new_string", " in the main function and simply using ", "=", ", the compiler doesn't have a problem with seeing that ", "global_var", " is declared globally and being used elsewhere in the program. My intuition tells me that it should know that ", "global_var", " is declared already", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if(this!&amp;#61;&amp;amp;rhs)&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["C++为一个基类编写拷贝赋值运算符出现\"!=\"无法与操作数匹配的问题", ["\nQuote& ", "operator", " =(", "const", " Quote& rhs)\n    {\n        ", "if", " (*", "this", " != rhs)\n        {\n            bookNo = rhs.bookNo;\n            price = rhs.price;\n        }\n        std::cout << ", "\"Quote:copy =()\"", " << endl;\n\n        ", "return", " *", "this", ";\n    }\n", "\n", "啥情况", "请求各位帮忙！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/464260666256171.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Complex&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; real;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; image;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i)\n    {\n        real &amp;#61; r; image &amp;#61; i;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r)\n    {\n        real &amp;#61; r; image &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;()\n    {\n        real &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; image &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n \n    ~&lt;span class=\"hljs-built_in\"&gt;Complex&lt;/span&gt;()\n    {\n        &lt;span class=\"hljs-comment\"&gt;//do nothing&lt;/span&gt;\n    }\n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *&amp;#61; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Complex Right) \n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a &amp;#61; real, b &amp;#61; image;\n        real &amp;#61; a * Right.real - b * Right.image;\n        image &amp;#61; b * Right.real &amp;#43; a * Right.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n \n    Complex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; *&amp;#61; (&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n) \n    {\n        Complex &lt;span class=\"hljs-built_in\"&gt;t&lt;/span&gt;(n, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n        *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; *&amp;#61; t;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Complex comp)&lt;/span&gt;&lt;/span&gt;;\n \n};\n \n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Complex comp)&lt;/span&gt;\n&lt;/span&gt;{\n    cout &amp;lt;&amp;lt; comp.real;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (comp.image &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        cout &amp;lt;&amp;lt; comp.image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (comp.image &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        cout &amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; comp.image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Complex &lt;span class=\"hljs-title\"&gt;c1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Complex &lt;span class=\"hljs-title\"&gt;c2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    \n    \n    &lt;span class=\"hljs-comment\"&gt;//显示C1&lt;/span&gt;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#61;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(c1);\n \n    &lt;span class=\"hljs-comment\"&gt;//与int类型相乘&lt;/span&gt;\n    c1 *&amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c*&amp;#61;5,c&amp;#61;&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(c1);\n \n    \n    &lt;span class=\"hljs-comment\"&gt;//与复数相乘&lt;/span&gt;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;c*&amp;#61;4&amp;#43;5i,&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;Complex &lt;span class=\"hljs-title\"&gt;t&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    c2 *&amp;#61; t;\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(c2);\n \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["定义复数类（Complex）,包含必要的构造函数和析构函数，重载乘法赋值运算符“*=”实现复数与整数，复数与复数之间的乘法运算，自行举例并按格式输出", ["#要求达到的效果：", "1.格式要求举例", "c=2+3i", "c*=5，c=10+15i", "c*=4+5i,c=-7+22i", "2.要求使用转换构造函数把整数转换为复数后进行运算", "3.遇到的问题：数学逻辑不清晰", "4.", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Complex", "\n", "{", "public", ":\nComplex(){", "real", "=", "0", ";imag=", "0", ";}", "//定义构造函数", "\nComplex(", "double", " r,", "double", " i){", "real", "=r;imag=i;}", "//构造函数重载", "\nComplex operator*=(Complex &c2);\n", "void", " ", "display", "();\n", "private", ":\n    ", "double", " ", "real", ";\n    ", "double", " imag;\n};\nComplex Complex::operator*=(Complex &c1)\n{Complex c;\n    c.", "real", "=", "real", "*c1.", "real", "-imag*c1.imag;\n    c.imag=", "real", "*c1.imag+imag*c1.", "real", ";\n    \n", "return", " c;}\n", "void", " Complex::", "display", "()\n{cout<<", "\" \"", "<<", "real", "<<", "\"+\"", "<<imag<<", "\"i\"", "<<endl;}\n", "int", " main()\n{Complex c1(", "2", ",", "3", "),c2=(", "4", ",", "5", "),c3;\nc3=c1*=c2;\ncout<<", "\"c1*=\"", ";c1.", "display", "();\ncout<<", "\"c2*=\"", ";c2.", "display", "();\ncout<<", "\"c1*c2=\"", ";c3.", "display", "();\n", "return", " ", "0", ";\n}\n\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;原因是&amp;#xff0c; &amp;#xff08;&amp;#xff1f;&amp;#xff1a;&amp;#xff09; 的语句是一个表达式&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\nret-value &amp;#61; Expression1 ? Expression2 : Expression3&lt;/pre&gt;\n\n&lt;p&gt;既然是表达式&amp;#xff0c;&amp;#34;:&amp;#34;  and &amp;#34;,&amp;#34; 的优先级是一样的&amp;#xff0c; 所以你的第一个式子被解释为&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;a &amp;gt; b ? max &amp;#61; a, min &amp;#61; b : max &amp;#61; b,&lt;/p&gt;\n\n&lt;p&gt;min &amp;#61; a;&lt;/p&gt;\n\n&lt;p&gt;就是说&amp;#xff0c;不管怎么样&amp;#xff0c; min &amp;#61; a, 都是要执行的。 你加的括号不对&amp;#xff0c;如果这么加括号&amp;#xff0c;就可以了&amp;#xff1a; &lt;/p&gt;\n\n&lt;p&gt;a &amp;gt; b ? (max &amp;#61; a, min &amp;#61; b) : (max &amp;#61; b, min &amp;#61; a);&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;你再试试看。 &lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["C语言三目运算符赋值问题", ["简单的比大小，居然翻车了", "\n\n", "主要代码：", "\n\n", "\n", "a > b ? max = a, min = b : max = b, min = a;", "\n\n", "对a，b分别进行赋值，a=6，b=3", "\n\n", "跑出来，代码输出：max=6，min=6", "\n\n", "这个情况很迷，我还以为max=min=a，这样赋值错了", "\n\n", "我在三目运算符里面的赋值代码段加了括号，如下", "\n\n", "\n", "a > b ? (max = a), (min = b) : (max = b), (min = a);", "\n\n", "还是max=6，min=6"]], "Tag": "程序设计"}
{"Answer": "# 如果问题得到解决，请点下我回答左上角的采纳和向上的箭头\r\n```\r\n#include &lt;iostream&gt; \r\n#include &lt;cstring&gt; \r\n#include &lt;cstdlib&gt;\r\nusing namespace std;\r\n\r\nclass Fraction\r\n{ \r\nprivate:\r\nint _s, _m;\r\npublic:\r\nvoid Print() { cout &lt;&lt; _s &lt;&lt; \"/\" &lt;&lt; _m &lt;&lt; endl; }\r\n// 在此处补充你的代码\r\nFraction&amp; operator=(char * s)\r\n{\r\n\t_s = 0;\r\n\t_m = 0;\r\n\tint sng = 1;\r\n\twhile (*s != '/')\r\n\t{\r\n\t\tif (*s == '-') { sng = -sng; s++; continue; }\r\n\t\t_s *= 10;\r\n\t\t_s += *s - '0';\r\n\t\ts++;\r\n\t}\r\n\ts++;\r\n\twhile (*s != '\\0')\r\n\t{\r\n\t\tif (*s == '-') { sng = -sng; s++; continue; }\r\n\t\t_m *= 10;\r\n\t\t_m += *s - '0';\r\n\t\ts++;\r\n\t}\r\n\tint gcd = _s &gt; _m ? _m : _s;\r\n\tint i;\r\n\tfor (i = gcd; i &gt;= 1; i--)\r\n\t\tif (_s % i == 0 &amp;&amp; _m % i == 0)\r\n\t\t\tbreak;\r\n\tgcd = i;\r\n\t_m /= gcd;\r\n\t_s /= gcd * sng;\r\n    return *this;\r\n}\r\n};\r\n\r\nint main() \r\n{\r\nFraction a;\r\na = \"3/5\"; a.Print();\r\na = \"48/-72\"; a.Print();\r\nreturn 0;\r\n}\r\n```", "Konwledge_Point": "赋值运算符", "Question": ["c++程序编写运算符重构", ["请补足Fraction类的成员函数（不能加数据成员） ", "\n#include ", "\n#include ", "\n#include ", "\nusing namespace std;", "\n\n", "class Fraction", "\n{ ", "\nprivate:", "\n    int _s, _m;", "\npublic:", "\n    void Print() { cout << _s << \"/\" << _m << endl; }", "\n    // 在此处补充你的代码", "\n};", "\n\n", "int main() ", "\n{", "\n    Fraction a;", "\n    a = \"3/5\"; a.Print();", "\n    a = \"48/-72\"; a.Print();", "\n    return 0;", "\n}", "\n\n", "输入", "\n无", "\n\n", "输出", "\n3/5 ", "\n-2/3 ", "\n\n", "样例输入", "\n无", "\n\n", "样例输出", "\n3/5", "\n-2/3", "\n\n", "不太懂字符串的调用和赋值运算符重构，求大佬帮帮忙"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; re\n\ntxt &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#39;&amp;#39;运算符    描述    示例\n&amp;#43;    相加    a &amp;#43; b\n-    相减    a - b\n*    相乘    a * b\n/    相除    a / b\n%    取模    a % b\n**    幂    a**b 表示 a 的 b 次幂\n//    取整除    9 // 4 结果为 2\n&amp;#61;&amp;#61;    是否相等    a &amp;#61;&amp;#61; b\n!&amp;#61;    是否不等于    a !&amp;#61; b\n&amp;gt;    是否大于    a &amp;gt; b\n&amp;gt;&amp;#61;    是否大于等于    a &amp;gt;&amp;#61; b\n&amp;lt;&amp;#61;    是否小于等于    a &amp;lt;&amp;#61; b\n&amp;#61;    简单的赋值运算符    a &amp;#61; b &amp;#43; c\n&amp;#43;&amp;#61;    加法赋值运算符    a &amp;#43;&amp;#61; b 等效于 a &amp;#61; a &amp;#43; b\n-&amp;#61;    减法赋值运算符    a -&amp;#61; b 等效于 a &amp;#61; a - b\n*&amp;#61;    乘法赋值运算符    a *&amp;#61; b 等效于 a &amp;#61; a * b\n/&amp;#61;    除法赋值运算符    a /&amp;#61; b 等效于 a &amp;#61; a / b\n%&amp;#61;    取模赋值运算符    a %&amp;#61; b 等效于 a &amp;#61; a % b\n**&amp;#61;    幂赋值运算符    a **&amp;#61; b 等效于 a &amp;#61; a ** b\n//&amp;#61;    取整除赋值运算符    a //&amp;#61; b 等效于 a &amp;#61; a // b\n&amp;amp;    与    a &amp;amp; b\n|    或    a | b\n^    异或    a ^ b\n~    取反    ~a\n&amp;lt;&amp;lt;    左移动    a &amp;lt;&amp;lt; 3\n&amp;gt;&amp;gt;    右移动    a &amp;gt;&amp;gt; 3\nand    布尔类型与    a and b\nor    布尔类型或    a or b\nnot    布尔类型非    not a\nis    判断两个标识符是否引用同一个对象    a is b\nis not    判断两个标识符是否引用不同对象    a is not &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;\n\nsgn &amp;#61; [s.split() &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; s &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; txt.split(&lt;span class=\"hljs-string\"&gt;&amp;#39;\\n&amp;#39;&lt;/span&gt;)]\n\ndic &amp;#61; {d[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]:&lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;.join(d[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:]) &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; d &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; sgn[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;:]}\n\nexp &amp;#61; &lt;span class=\"hljs-built_in\"&gt;input&lt;/span&gt;()\n\n&lt;span class=\"hljs-keyword\"&gt;try&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;表达式&amp;#xff1a;&amp;#39;&lt;/span&gt;, exp)\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;结  果&amp;#xff1a;&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;eval&lt;/span&gt;(exp))\n    exp &amp;#61; re.sub(&lt;span class=\"hljs-string\"&gt;r&amp;#39;(\\d&amp;#43;)&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;, exp)\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;运算符&amp;#xff1a;&amp;#39;&lt;/span&gt;)\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; e &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; exp.split():\n        &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(e, dic[e])\n&lt;span class=\"hljs-keyword\"&gt;except&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;输入的表达式错误&amp;#xff0c;无法计算结果&amp;#39;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["input输入算式，显示结果，并且查询到相应的提示怎么做？", ["a", "=input() ", "#控制台输入5+3", "\nprint(", "a", ") ", "#print打印a的内容，显示5+3=8或者8", "\n\\n 显示：+ 相加 ", "a", "+b\n输入：", "3", "** 显示", "3", "**=__，或者__。\n\\n 显示：**    幂    ", "a", "**b 表示 ", "a", " 的 b 次幂\n", "\n", "运算符    描述    示例\n+    相加    a + ", "b", "\n-    相减    a - ", "b", "\n*    相乘    a * ", "b", "\n/    相除    a / ", "b", "\n%    取模    a % ", "b", "\n**    幂    a**", "b", " 表示 a 的 ", "b", " 次幂\n", "//    取整除    9 // 4 结果为 2", "\n==    是否相等    a == ", "b", "\n!=    是否不等于    a != ", "b", "\n>    是否大于    a > ", "b", "\n>=    是否大于等于    a >= ", "b", "\n<=    是否小于等于    a <= ", "b", "\n=    简单的赋值运算符    a = ", "b", " + c\n+=    加法赋值运算符    a += ", "b", " 等效于 a = a + ", "b", "\n-=    减法赋值运算符    a -= ", "b", " 等效于 a = a - ", "b", "\n*=    乘法赋值运算符    a *= ", "b", " 等效于 a = a * ", "b", "\n/=    除法赋值运算符    a /= ", "b", " 等效于 a = a / ", "b", "\n%=    取模赋值运算符    a %= ", "b", " 等效于 a = a % ", "b", "\n**=    幂赋值运算符    a **= ", "b", " 等效于 a = a ** ", "b", "\n", "//=    取整除赋值运算符    a //= b 等效于 a = a // b", "\n&    与    a & ", "b", "\n", "|    或    a |", " ", "b", "\n^    异或    a ^ ", "b", "\n~    取反    ~a\n<<    左移动    a << ", "3", "\n>>    右移动    a >> ", "3", "\n", "and", "    布尔类型与    a ", "and", " ", "b", "\n", "or", "    布尔类型或    a or ", "b", "\n", "not", "    布尔类型非    not a\n", "is", "    判断两个标识符是否引用同一个对象    a is ", "b", "\n", "is", " not    判断两个标识符是否引用不同对象    a is not b\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;CSet&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    std::vector&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt; m_data;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-comment\"&gt;// 构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;CSet&lt;/span&gt;() {}\n\n    &lt;span class=\"hljs-comment\"&gt;// 拷贝构造函数&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;CSet&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CSet&amp;amp; other)\n    {\n        m_data &amp;#61; other.m_data;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 析构函数&lt;/span&gt;\n    ~&lt;span class=\"hljs-built_in\"&gt;CSet&lt;/span&gt;() {}\n\n    &lt;span class=\"hljs-comment\"&gt;// 获取元素个数函数&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;GetLength&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; m_data.&lt;span class=\"hljs-built_in\"&gt;size&lt;/span&gt;();\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 赋值运算符&lt;/span&gt;\n    CSet&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CSet&amp;amp; other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; !&amp;#61; &amp;amp;other)\n        {\n            m_data &amp;#61; other.m_data;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 操作(读取和赋值)指定元素运算符[]&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[](&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; m_data[index];\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;[](&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; m_data[index];\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 取某个整数区间返回新集合运算符(start,end)&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;CSet &lt;span class=\"hljs-title\"&gt;operator&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; start, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    &lt;/span&gt;{\n        CSet result;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; start; i &amp;lt;&amp;#61; end &amp;amp;&amp;amp; i &amp;lt; &lt;span class=\"hljs-built_in\"&gt;GetLength&lt;/span&gt;(); &amp;#43;&amp;#43;i)\n        {\n            result.m_data.&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(m_data[i]);\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 把一个元素加到集合末尾并返回新集合运算符&amp;#43;&lt;/span&gt;\n    CSet &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; element) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;CSet &lt;span class=\"hljs-title\"&gt;result&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(*&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (std::&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(result.m_data.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), result.m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), element) &amp;#61;&amp;#61; result.m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n        {\n            result.m_data.&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(element);\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 合并两个集合对象并返回新集合运算符&amp;#43;&lt;/span&gt;\n    CSet &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CSet&amp;amp; other) &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;CSet &lt;span class=\"hljs-title\"&gt;result&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(*&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; other.&lt;span class=\"hljs-built_in\"&gt;GetLength&lt;/span&gt;(); &amp;#43;&amp;#43;i)\n        {\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; element &amp;#61; other[i];\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (std::&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(result.m_data.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), result.m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), element) &amp;#61;&amp;#61; result.m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n            {\n                result.m_data.&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(element);\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; result;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 把一个元素加到集合末尾运算符&amp;#43;&amp;#61;&lt;/span&gt;\n    CSet&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#61;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; element)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (std::&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(m_data.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), element) &amp;#61;&amp;#61; m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n        {\n            m_data.&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(element);\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 合并第二个集合到第一个后面运算符&amp;#43;&amp;#61;&lt;/span&gt;\n    CSet&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CSet&amp;amp; other)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; other.&lt;span class=\"hljs-built_in\"&gt;GetLength&lt;/span&gt;(); &amp;#43;&amp;#43;i)\n        {\n            &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; element &amp;#61; other[i];\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (std::&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(m_data.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), element) &amp;#61;&amp;#61; m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n            {\n                m_data.&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(element);\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 输入流提取运算符&amp;gt;&amp;gt;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; std::istream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(std::istream&amp;amp; in, CSet&amp;amp; set)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; element;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (in &amp;gt;&amp;gt; element)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (std::&lt;span class=\"hljs-built_in\"&gt;find&lt;/span&gt;(set.m_data.&lt;span class=\"hljs-built_in\"&gt;begin&lt;/span&gt;(), set.m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;(), element) &amp;#61;&amp;#61; set.m_data.&lt;span class=\"hljs-built_in\"&gt;end&lt;/span&gt;())\n            {\n                set.m_data.&lt;span class=\"hljs-built_in\"&gt;push_back&lt;/span&gt;(element);\n            }\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; in;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 输出流插入运算符&amp;lt;&amp;lt;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; out, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; CSet&amp;amp; set)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; set.&lt;span class=\"hljs-built_in\"&gt;GetLength&lt;/span&gt;(); &amp;#43;&amp;#43;i)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            {\n                out &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n            }\n            out &amp;lt;&amp;lt; set[i];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; out;\n    }\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; \n&lt;/span&gt;{     \n    CSet set1;     \n    cin &amp;gt;&amp;gt; set1;     \n    cout &amp;lt;&amp;lt; set1 &amp;lt;&amp;lt; endl; \n\n    CSet set2 &amp;#61; set1;     \n    cout &amp;lt;&amp;lt; set2 &amp;lt;&amp;lt; endl;\n\n    CSet set3;     \n    set3 &amp;#61; set1;     \n    cout &amp;lt;&amp;lt; set3 &amp;lt;&amp;lt; endl;\n\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len &amp;#61; set1.&lt;span class=\"hljs-built_in\"&gt;GetLength&lt;/span&gt;();     \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; &amp;#43;&amp;#43;i)     \n    {         \n        cout &amp;lt;&amp;lt; set1[i] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;     \n    }     \n    cout &amp;lt;&amp;lt; endl; \n\n    CSet set4 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;set1&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);     \n    cout &amp;lt;&amp;lt; set4 &amp;lt;&amp;lt; endl; \n\n    CSet set5 &amp;#61; set1 &amp;#43; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;     \n    cout &amp;lt;&amp;lt; set5 &amp;lt;&amp;lt; endl; \n\n    CSet set6 &amp;#61; set1 &amp;#43; set5;     \n    cout &amp;lt;&amp;lt; set6 &amp;lt;&amp;lt; endl; \n\n    set1 &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;     \n    cout &amp;lt;&amp;lt; set1 &amp;lt;&amp;lt; endl;\n\n    set1 &amp;#43;&amp;#61; set5;     \n    cout &amp;lt;&amp;lt; set1 &amp;lt;&amp;lt; endl;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; \n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["编写一个类，实现运算符重载", ["利用deque实现动态存储", "1）构造、析构、拷贝构造、获取元素个数函数 GetLength()", "\n", "（2）赋值运算符=", "\n", "（3）操作（读取和赋值）指定元素运算符[ ]", "\n", "（4）取某个整数区间返回新集合运算"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是函数申明的时候&amp;#xff0c;指定了参数默认值。当设定默认值时&amp;#xff0c;函数调用时可以不指定这个参数&amp;#xff0c;该参数会自动使用默认值。参数默认值必须从最右侧开始设置&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["这是什么意思？这是什么意思？", ["这个圈里面是什么意思🙃圈里面是什么意思？圈里面是什？么意思 圈里面的赋值运算符是什么意思"]], "Tag": "程序设计"}
{"Answer": "可能是A吧。  \r\n和编译器的实现、优化还有关系。 这里面没有赋值。\r\n这种题意义不大。\r\n望采纳", "Konwledge_Point": "赋值运算符", "Question": ["构造函数的调用是拷贝还是赋值？", ["a代表默认构造函数，b代表拷贝构造函数，c代表赋值运算符，d代表析构函数", "\n请问以下代码的调用顺序对应哪个选项？", "\n\n", "A f(A& a){\n    return a;\n} \nint main(int, char**){ \n    A a; \n    A b = f(a); \n    return 0; \n}\n", "\n\n", "A.abdd", "\nB.acdd", "\nC.abbddd", "\nD.abcddd", "\n\n", "答案是B", "\nA a默认构造一次，f(a)返回a自身，赋值给b", "\n其实a与b指向同一块内存，最后a,b析构"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是否送达&amp;#xff0c;通过什么来判断&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["java，简单题目，面向对象，运算符", [".编写一个模拟水果蔬菜外卖清单的程序，打印出库存中每种外卖的详细信息以及所有商品的汇总信息。每种商品信息包括名称、斤数、单价、总价、分类、是否送达，所有商品的汇总信息包括库存数如下：", "\n", "请选择适合的数据类型定义变量存储商品的详细信息，在对变量进行赋值，最后输出。", "输出数值以及格式如下：", "最后输出请用赋值运算符计算出个数以及总价并输出"]], "Tag": "程序设计"}
{"Answer": "x+=x-=x-x--;\r\n01052D35  mov         eax,dword ptr [x]  \r\n01052D38  sub         eax,dword ptr [x]  \r\n01052D3B  mov         ecx,dword ptr [x]  \r\n01052D3E  sub         ecx,eax  \r\n01052D40  mov         dword ptr [x],ecx  \r\n01052D43  mov         edx,dword ptr [x]  \r\n01052D46  add         edx,dword ptr [x]  \r\n01052D49  mov         dword ptr [x],edx  \r\n01052D4C  mov         eax,dword ptr [x]  \r\n01052D4F  sub         eax,1  \r\n01052D52  mov         dword ptr [x],eax", "Konwledge_Point": "赋值运算符", "Question": ["int x=4；求x+=x-=x-x--的值", ["int x=4；求x+=x-=x-x--的值，为什么先计算x-=x-x，--的优先级不是比赋值运算符的优先级高吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OPEN true&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; CLOSE false&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Aircondition&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *g_brand;\n    string g_colour;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; g_power;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; g_tempreture;\n    &lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; status; &lt;span class=\"hljs-comment\"&gt;// 开关状态&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Aircondition&lt;/span&gt;() &amp;#61; &lt;span class=\"hljs-keyword\"&gt;default&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;Aircondition&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *brand, string colour, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; power, &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; tempreture)\n    {\n        g_brand &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(brand) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(g_brand, brand);\n\n        g_colour &amp;#61; colour;\n        g_power &amp;#61; power;\n        g_tempreture &amp;#61; tempreture;\n\n        status &amp;#61; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 复制构造&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Aircondition&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Aircondition &amp;amp;a)\n    {\n        g_brand &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(a.g_brand) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(g_brand, a.g_brand);\n\n        g_colour &amp;#61; a.g_colour;\n        g_power &amp;#61; a.g_power;\n        g_tempreture &amp;#61; a.g_tempreture;\n\n        status &amp;#61; a.status;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 赋值运算符重载&lt;/span&gt;\n    Aircondition &amp;amp;&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Aircondition &amp;amp;a)\n    {\n        g_brand &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(a.g_brand) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(g_brand, a.g_brand);\n\n        g_colour &amp;#61; a.g_colour;\n        g_power &amp;#61; a.g_power;\n        g_tempreture &amp;#61; a.g_tempreture;\n\n        status &amp;#61; a.status;\n    }\n\n    ~&lt;span class=\"hljs-built_in\"&gt;Aircondition&lt;/span&gt;()\n    {\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] g_brand;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;show&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;品牌: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; g_brand &amp;lt;&amp;lt; endl;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;颜色: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; g_colour &amp;lt;&amp;lt; endl;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;功率: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; g_power &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;匹&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;设定温度: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; g_tempreture &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;度&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Switch&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        status &amp;#61; !status;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (status &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;空调启动&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;空调关闭&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;tempreture_turnup&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t)&lt;/span&gt;\n    &lt;/span&gt;{\n        g_tempreture &amp;#61; g_tempreture &amp;#43; t;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;tempreture_turndown&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; t)&lt;/span&gt;\n    &lt;/span&gt;{\n        g_tempreture &amp;#61; g_tempreture - t;\n    }\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Aircondition &lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;格力&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;白色&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;25&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    a.&lt;span class=\"hljs-built_in\"&gt;show&lt;/span&gt;();\n    a.&lt;span class=\"hljs-built_in\"&gt;Switch&lt;/span&gt;();\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a.status &amp;#61;&amp;#61; OPEN)\n    {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; aim_tempreture;\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;目标温度&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n        cin &amp;gt;&amp;gt; aim_tempreture;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (aim_tempreture &amp;gt; a.g_tempreture)\n            a.&lt;span class=\"hljs-built_in\"&gt;tempreture_turnup&lt;/span&gt;(aim_tempreture - a.g_tempreture);\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (aim_tempreture &amp;lt; a.g_tempreture)\n            a.&lt;span class=\"hljs-built_in\"&gt;tempreture_turndown&lt;/span&gt;(a.g_tempreture - aim_tempreture);\n    }\n    a.&lt;span class=\"hljs-built_in\"&gt;show&lt;/span&gt;();\n\n    &lt;span class=\"hljs-function\"&gt;Aircondition &lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(a)&lt;/span&gt;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//复制构造&lt;/span&gt;\n    b.&lt;span class=\"hljs-built_in\"&gt;show&lt;/span&gt;();\n\n    Aircondition c &amp;#61; b; &lt;span class=\"hljs-comment\"&gt;// 赋值重载&lt;/span&gt;\n    c.&lt;span class=\"hljs-built_in\"&gt;show&lt;/span&gt;();\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["这是我本来写的代码但是没有实现所给的要求，希望有人能够修改一下，完成要求。因为自己改了好多遍都没有实现，实在改不出来了，直接贴上第一次写的。", ["题目：设计一个空调类airCondition，其中包括：", "数据成员：品牌（要求char* 类型）、颜色、攻率、开关状态、设定温度；", "构造函数：对品牌、颜色、攻率、设定温度赋初值；", " 要求1.写出复制构造函数（参数必须被const 修饰），赋值运算符重载函数", "      2.要求有一定有默认构造函数的生成（=default的使用）", "析构函数：用户自定义（注意动态申请的资源的释放）；", "成员函数：切换开关状态、升温、降温。", "主函数中要求至少创建三个对象，其中之一用复制构造函数初始化，另外一个创建后用赋值运算符赋值；", "具体信息如：格力、白色、2匹、25度等等。调用其“切换开关状态”函数打开空调，调用其“降温”函数调整温度为20度，并打印空调状态和目前设定的温度到屏幕。", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\nclass temp{\nprivate:\n\tchar *pStuNo;\n\tchar *pPro;\n\tchar *pName;\npublic:\n\tchar * GetStuNo() { return pStuNo; }\n\tchar * GetPro() { return pPro; }\n\tchar * GetName() { return pName; }\n\tint GetStuNoInt() { return atoi(pStuNo); }\n\ttemp() { pStuNo &amp;#61; NULL; pPro &amp;#61; NULL; pName &amp;#61; NULL; }\n\ttemp(char *stuno,char *pro,char *name) \n\t{\n\t\tpStuNo &amp;#61; new char[strlen(stuno)&amp;#43;1];\n\t\tmemset(pStuNo, 0, strlen(stuno) &amp;#43; 1);\n\t\tmemcpy(pStuNo, stuno, strlen(stuno));\n\t\t//\n\t\tpPro &amp;#61; new char[strlen(pro) &amp;#43; 1];\n\t\tmemset(pPro, 0, strlen(pro) &amp;#43; 1);\n\t\tmemcpy(pPro, stuno, strlen(pro));\n\t\t//\n\t\tpName &amp;#61; new char[strlen(name) &amp;#43; 1];\n\t\tmemset(pName, 0, strlen(name) &amp;#43; 1);\n\t\tmemcpy(pName, stuno, strlen(name));\t\n\t}\n\tvoid Clear()\n\t{\n\t\tif (pStuNo !&amp;#61; NULL)\n\t\t{\n\t\t\tdelete[]pStuNo;\n\t\t\tpStuNo &amp;#61; NULL;\n\t\t}\n\t\tif (pPro !&amp;#61; NULL)\n\t\t{\n\t\t\tdelete []pPro;\n\t\t\tpPro &amp;#61; NULL;\n\t\t}\n\t\tif (pName !&amp;#61; NULL)\n\t\t{\n\t\t\tdelete []pName;\n\t\t\tpName &amp;#61; NULL;\n\t\t}\n\t}\n\t~temp() { Clear(); }\n\ttemp operator &amp;#61; (temp &amp;amp;t)\n\t{\n\t\tClear();\n\t\tpStuNo &amp;#61; new char[strlen(t.GetStuNo())&amp;#43;1];\n\t\tstrcpy(pStuNo, t.GetStuNo());\n\t\t//\n\t\tpPro &amp;#61; new char[strlen(t.GetPro()) &amp;#43; 1];\n\t\tstrcpy(pStuNo, t.GetPro());\n\t\t//\n\t\tpName &amp;#61; new char[strlen(t.GetName()) &amp;#43; 1];\n\t\tstrcpy(pStuNo, t.GetName());\n        return *this;\n\t}\n\tint StuNoDeff(temp &amp;amp;t1, temp &amp;amp;t2)\n\t{\n\t\treturn t1.GetStuNoInt() - t2.GetStuNoInt();\n\t}\n};\n\nint main()\n{\n\ttemp t(&amp;#34;20210211&amp;#34;,&amp;#34;COMPUTER&amp;#34;,&amp;#34;LIMING&amp;#34;);\n\ttemp t1 &amp;#61; t;\n\ttemp t2(&amp;#34;20210293&amp;#34;, &amp;#34;ENGLISH&amp;#34;, &amp;#34;ZHANGSAN&amp;#34;);\n\tint n &amp;#61; t.StuNoDeff(t1, t2);\n\treturn 0;\n\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["用c++定义一个学生类，该类含学号，姓名，专业，三个私有成员，全部设置为字符指针变量", ["定义带参数的构造函数，为三个成员赋值，定义转换构造函数，将整型变量转成学生类的学号，重载赋值运算符函数，实现两个对象之间的赋值工作，定义类类型转换函数，将学生类的学号转换为整型数据后输出，实现两个学生之间学号的相减运算"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、&lt;br /&gt;①.编写一个类,类名为Test01&lt;br /&gt;②.在main方法下定义变量s&amp;#xff0c;并赋值为5&amp;#xff0c;定义变量i&amp;#xff0c;并赋值为12&amp;#xff1b;&lt;br /&gt;③.使用赋值运算符计算s&amp;#43;&amp;#61;i&amp;#43;&amp;#43;的值&amp;#xff0c;并把计算结果赋给变量s&lt;br /&gt;④输出变量s的值&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Test01&lt;/span&gt; {\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;{\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;;\n        s &amp;#43;&amp;#61; i&amp;#43;&amp;#43;;\n        System.out.&lt;span class=\"hljs-built_in\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;s &amp;#61; &amp;#34;&lt;/span&gt; &amp;#43; s);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;2、利用if语句完成编程。&lt;br /&gt;①编写一个类,类名为Test02&lt;br /&gt;②从控制台输入两个整数m和n。&lt;br /&gt;③比较两个数的大小&amp;#xff0c;并输出最大值和最小值。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; Test02 {\n    &lt;span class=\"hljs-built_in\"&gt;public&lt;/span&gt; static &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; main(String[] args) {\n        Scanner sc &amp;#61; &lt;span class=\"hljs-built_in\"&gt;new&lt;/span&gt; Scanner(&lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;请输入m:&amp;#34;);\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m &amp;#61; sc.nextInt();\n        &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;请输入n:&amp;#34;);\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; sc.nextInt();\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (m &amp;gt; n) {\n            &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;最大值m &amp;#61; &amp;#34; &amp;#43; m &amp;#43; &amp;#34;\\n最小值n &amp;#61; &amp;#34; &amp;#43; n);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (m &amp;lt; n) {\n            &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;最大值n &amp;#61; &amp;#34; &amp;#43; n &amp;#43; &amp;#34;\\n最小值m &amp;#61; &amp;#34; &amp;#43; m);\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(&amp;#34;m &amp;#61; n &amp;#61; &amp;#34; &amp;#43; m);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;3、利用循环语句完成编程&lt;br /&gt;①编写一个类,类名为Test03&lt;br /&gt;②计算2&amp;#43;4&amp;#43;6&amp;#43;8&amp;#43;…&amp;#43;100的结果&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Test03&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; main(String[] args) {\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;sum&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; &lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-keyword\"&gt;sum&lt;/span&gt; &amp;#43;&amp;#61; i*&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n        System.out.println(&lt;span class=\"hljs-string\"&gt;&amp;#34;sum &amp;#61; &amp;#34;&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-keyword\"&gt;sum&lt;/span&gt;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;4、利用面向对象的知识编程&lt;br /&gt;①创建一个Rectangle类&amp;#xff0c;添加width和height两个成员变量。&lt;br /&gt;② 编写一个测试类Test&amp;#xff0c;创建一个Rectangle类的矩形对象&amp;#xff0c;矩形的width值为20&amp;#xff0c;height值为10。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Rectangle&lt;/span&gt; {\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; width;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; height;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Test&lt;/span&gt; {\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt;[] args)&lt;/span&gt; &lt;/span&gt;{\n        Rectangle r &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;Rectangle&lt;/span&gt;();\n        r.width &amp;#61; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;;\n        r.height &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["在main方法下定义变量s，并赋值为5，定义变量i，并赋值为12", ["①.编写一个类,类名为Test01", "②.在main方法下定义变量s，并赋值为5，定义变量i，并赋值为12；", "③.使用赋值运算符计算s+=i++的值，并把计算结果赋给变量s", "④输出变量s的值", "解答：（代码截图）", "\n", "利用if语句完成编程。", "①编写一个类,类名为Test02", "②从控制台输入两个整数m和n。", "③比较两个数的大小，并输出最大值和最小值。", "解答：（代码截图）", "\n", "利用循环语句完成编程", "①编写一个类,类名为Test03", "②计算2+4+6+8+…+100的结果", "解答：（代码截图）(20分)", "最多上传9张，每张不超过5M", "\n", "利用面向对象的知识编程", "①创建一个Rectangle类，添加width和height两个成员变量。", "② 编写一个测试类Test，创建一个Rectangle类的矩形对象，矩形的width值为20，height值为10。 "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Since PHP 5.3, which you are hopefully using as anything else is ancient, there's the &lt;a href=\"http://php.net/ternary#language.operators.comparison.ternary\" rel=\"nofollow\"&gt;ternary &lt;code&gt;?:&lt;/code&gt; operator&lt;/a&gt; without the middle part (so, the \"binary operator\"...?):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$get = $this-&amp;gt;input-&amp;gt;get() ?: array();\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["使用PHP中的逻辑运算符进行变量赋值", ["\n\n", "I've been trying to replicate short circuit evaluation in javascript for assignment.", "\n\n", "E.g. in Javascript", "\n\n", "var myObject = {foo: 'bar'};\n// if myObject is undefined then assign an empty array\nvar obj = myObject || [];\n", "\n\n", "obj", " will now reference ", "myObject", "\n\n", "I tried to replicate this in PHP and found that it just turns it into an expression and returns true or false.", "\n\n", "I could do this in PHP like this:", "\n\n", "$get = $this->input->get() ? $this->input->get() : array();\n", "\n\n", "The problem with this is I don't know what ", "$this->input->get()", " is doing behind the scenes so it's not efficient to call the method twice.", "\n\n", "So I got creative and found a solution doing it as follows:", "\n\n", "// $this->input->get() could return an array or false\n$get = ($params = $this->input->get() and $params) ? $params : array();\n", "\n\n", "Problem with this is it may confuse me in the future and it may not be very efficient.", "\n\n", "So is there a better way in PHP to assign a variable in a one line expression like this or should I just stick to:", "\n\n", "$get = $this->input->get();\nif (!$get) {\n   $get = array();\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/631774127366171.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;CComplex&lt;/span&gt;\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; real, image;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;CComplex&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; r &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) { real &amp;#61; r; image &amp;#61; i; }\n    ~&lt;span class=\"hljs-built_in\"&gt;CComplex&lt;/span&gt;() {}\n    \n\n    &lt;span class=\"hljs-comment\"&gt;//友元函数&amp;#43;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; CComplex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;(CComplex&amp;amp; c1, CComplex&amp;amp; c2)\n    {\n        CComplex t;\n        t.real &amp;#61; c1.real &amp;#43; c2.real;\n        t.image&amp;#61; c1.image &amp;#43; c2.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; t;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; CComplex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; -(CComplex&amp;amp; c1, CComplex&amp;amp; c2)\n    {\n        CComplex t;\n        t.real &amp;#61; c1.real - c2.real;\n        t.image &amp;#61; c1.image - c2.image;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; t;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//成员函数&amp;#61;&lt;/span&gt;\n    CComplex&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#61;(CComplex&amp;amp; c)\n    {\n        CComplex t;\n        t.real &amp;#61; c.image;\n        t.image &amp;#61; c.image;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;//前置&amp;#43;&amp;#43;&lt;/span&gt;\n    CComplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;() {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//后置&amp;#43;&amp;#43;&lt;/span&gt;\n    CComplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &amp;#43;&amp;#43;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) {\n\n        &lt;span class=\"hljs-function\"&gt;CComplex &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real, &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//前置--&lt;/span&gt;\n    CComplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --() {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//后置--&lt;/span&gt;\n    CComplex &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; --(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) {\n\n        &lt;span class=\"hljs-function\"&gt;CComplex &lt;span class=\"hljs-title\"&gt;c&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real, &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;real -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;image -&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; c;\n    }\n\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n    &lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (image &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; real &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (image &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            cout &amp;lt;&amp;lt; real;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            cout &amp;lt;&amp;lt; real &amp;lt;&amp;lt; image &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;i&amp;#34;&lt;/span&gt;;\n    }\n\n};\n\n\n\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;CComplex &lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;)&lt;/span&gt;, &lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;a: &amp;#34;&lt;/span&gt;;\n    a.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;b: &amp;#34;&lt;/span&gt;;\n    b.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#43;b&amp;#61; &amp;#34;&lt;/span&gt;;\n    CComplex c &amp;#61; a &amp;#43; b;\n    c.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;a-b&amp;#61; &amp;#34;&lt;/span&gt;;\n    CComplex d &amp;#61; a - b;\n    d.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n\n    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#43;a : &amp;#34;&lt;/span&gt;;\n    &amp;#43;&amp;#43;a;\n    a.&lt;span class=\"hljs-built_in\"&gt;print&lt;/span&gt;();\n\n\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["C++重载的相关问题", ["一、完成复数类CComplex的定义，(包括real和image两个double型数据成员)", "●包括构造函数，print()打印数据成员值的成员函数.", "●  并用成员函数重载 ‘=’赋值运算符和前、后‘++’运算符，用友元函数重载双目‘+’和‘-’运算符.", "二、在主函数中分别进行以下测试 ：", "●对象=对象+对象；", "●对象=对象-对象；", "●++对象；", "并分别调用print函数打印对象数据成员值  "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;确实和指针类型有较大关系&amp;#xff0c;只是复制指针就是浅拷贝。浅拷贝后两个对象还有共享信息。深拷贝是所有内容完全复制&amp;#xff0c;使两个对象毫无关系。&lt;br /&gt;当类对象中的成员变量均支持&amp;#61;操作符时&amp;#xff0c;两个对象就可以直接赋值。代码中  c &amp;#61; a;实际是将a的成员赋值给b的成员&amp;#xff0c;string类型的&amp;#61;操作时深拷贝。如果类中有指针变量&amp;#xff0c;那么默认只是进行指针的赋值&amp;#xff0c;使得两个指针指向同一块内存。除非你给这个类重载&amp;#61;操作符&amp;#xff0c;然后为当前类开辟新的内存空间&amp;#xff0c;实现指针指向空间数据的复制&amp;#xff0c;这样用&amp;#61;操作符就变为深拷贝了。&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["有关深拷贝和浅拷贝的问题，对于非指针类型而言，有影响吗", ["有关深拷贝和浅拷贝的问题，对于非指针类型而言，有影响吗", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "#", "include", "<string>", "\n", "class", " ", "student", "\n{\n", "public", ":\n    ", "student", "()         ", "//主动写的默认构造函数", "\n    {\n        m_name = ", "\"阿伟\"", ";\n        m_age = ", "18", ";\n    }\n    ", "student", "(string name, ", "int", " age)", "//含参构造函数", "\n    {\n        m_name = name;\n        m_age = age;\n    }\n    ", "void", " ", "change", "()", "\n    ", "{\n        m_name = ", "\"asdfasdf\"", ";\n        m_age = ", "345", ";\n    }\n    ", "void", " ", "display", "()", "\n    ", "{\n        cout << ", "\"name:\"", " << m_name << endl;\n        cout << ", "\"age:\"", " << m_age << endl;\n    }\n    ", "//student(const student& stu);    //复制构造函数", "\n", "private", ":\n    string m_name;\n    ", "int", " m_age;\n\n\n};\n\n", "/*student::student(const student& stu)\n{\n    m_name = stu.m_name;\n    m_age = stu.m_age;\n    cout << \"这里是复制构造函数\" << endl;\n}*/", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "student ", "a", "(", "\"阿斌\"", ", ", "23", ")", ";\n    student b = a;\n    ", "//cout << \"这是赋值之前的b\" << endl;", "\n    ", "//b.display();", "\n    student c;\n    c = a;\n    cout << ", "\"使用了自带的赋值运算符\"", "<<endl;\n        cout << ", "\"c的值为\"", "<<endl;\n        c.", "display", "();\n    ", "//这里用的不是复制构造函数，而是C++自动重载好的赋值运算符", "\n    cout << ", "\"初始化后的b\"", " << endl;\n    b.", "display", "();\n    b.", "change", "();\n    cout << ", "\"b的值改变之后\"", "<<endl;\n        b.", "display", "();\n    cout << ", "\"此时a的值\"", " << endl;\n    a.", "display", "();\n    c.", "change", "();\n    cout << ", "\"c的值改变之后\"", " << endl;\n    c.", "display", "();\n    cout << ", "\"此时a的值\"", " << endl;\n    a.", "display", "();\n    ", "return", " ", "0", ";\n\n\n\n}\n\n", "\n", "运行的结果是改变b和c的值，a的值都没有改变", "\n", "那么，是C++自带的重载赋值运算符和复制构造函数都是浅拷贝，还是因为，深浅拷贝只对于指针而言有区别？"]], "Tag": "程序设计"}
{"Answer": "你一个字符串一个float，那么就只能用它们公共的基类，也就是Object了。", "Konwledge_Point": "赋值运算符", "Question": ["java，要将三元运算符的结果赋值给一个什么类型的变量", ["要将三元运算符的结果赋值给一个变量，但后面冒号两边的数据类型不同，赋值时应该用什么类型的变量"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(!file)&lt;/span&gt;&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//主要是用来判断文件是否打开&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// 可以使用如下语句替换&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(!file.isopen()&lt;/span&gt;&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["头文件fstream文件流中，如何判断两个值是否相等？运算符“==”在这里是无效的。", ["问题遇到的现象和发生背景", "\n", "首先：这个是教材的原例题，教材上的执行结果时：正常输出了结构数组的5个结构变量的数据。", "然而：在visual stdio和Dev-C++上实际运行时，", "           输出结果却是“文件不能打开”。", "           通过尝试和分析，问题出在if(!file)这个判别条件上，换句话说if(file==NULL)和if(file!=NULL)中的“==”和“!=”运算符在fstream中没有判断两个值是否相等的功能。", "\n", "       当我把判别条件中的“", "=", "=", "”运算符改成赋值运算符“", "=", "”，即if(file", "=", "NULL)时，程序“  貌似  ”正确运行了。可是，“", "=", "”不是赋值运算符吗？这样使用似乎没有道理。\n", "\n", "我的问题是在fstream头文件下，应该如何正确的表示“判断两个值是否相等”这个功能呢？", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include", "#include", "#include<stdlib.h>", "using namespace std;", "struct person", "{", "    char name[80];", "    double height;", "    unsigned short age;", "};", "struct person people[5]={\"Ma\",1.78,35,\"Zhang\",1.68,24,\"Hu\",1.90,40,\"Lu\",1.89,50,\"Lang\",2.00,18};", "int main()", "{", "    fstream file;", "    file.open(\"file4.dat\",ios::in|ios::out|ios::binary);", "    if(!file)", "    {", "        cout<<\"file4.dat can't open.\\n\";", "        abort();", "    }", "    int i;", "    for(i=0;i<5;i++)", "        file.write((char *)&people[i],sizeof(people[i]));", "    file.seekp(0,ios::beg);", "    for(i=0;i<5;i++)", "    {", "        file.read((char *)&people[i],sizeof(people[i]));", "        cout<<people[i].name<<'\\t'<<people[i].height<<'\\t'<<people[i].age<<endl;", "    }", "    file.close();", "}", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;既然是空类&amp;#xff0c;就表示里面没有写代码呢&amp;#xff0c;无法佐证&amp;#xff0c;佐证了就不是空类了。&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["今日看到有博客讲述C++空类，编译器会默认添加哪些函数，可否有人给出佐证的代码演示", ["挺多帖子，诸如 ", "\n      \n        ", "6.空类有哪些函数？空类的大小？_qihang_hg的博客-CSDN博客_空类有哪些函数?空类的大小?", "\n        \n      ", "C++的空类有哪些成员函数：. 缺省构造函数。. 缺省拷贝构造函数。. 缺省析构函数。. 缺省赋值运算符。. 缺省取址运算符。. 缺省取址运算符 const。注意：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。#include<iostream>using namespace std;//C++ 空类默认产生的类成员函数:缺省构造函数,拷贝构造函数,析构", "\n      ", "\n      ", "\n        ", "\n          ", "https://blog.csdn.net/qq_41842669/article/details/116230272", "\n        ", "\n      ", "\n", "讲述空类时的默认添加函数。但是没有给出实验例子，不知有人可否佐证一下这个空类默认添加函数问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;iostream&amp;gt;&lt;br /&gt;\nusing namespace std;&lt;br /&gt;\nclass MyArray&lt;br /&gt;\n{&lt;!-- --&gt;&lt;br /&gt;\nprivate:&lt;br /&gt;\n    int size;&lt;br /&gt;\n    int *ptr;&lt;br /&gt;\npublic:&lt;br /&gt;\n    MyArray(int n&amp;#61;0){&lt;!-- --&gt;&lt;br /&gt;\n        size&amp;#61;n;&lt;br /&gt;\n        ptr &amp;#61;new int[size];&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;    ~MyArray(){&lt;!-- --&gt;&lt;br /&gt;\n        delete []ptr;&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;    MyArray(const MyArray &amp;amp;arr){&lt;!-- --&gt;&lt;br /&gt;\n        size&amp;#61;arr.size;&lt;br /&gt;\n        ptr &amp;#61;new int[size];&lt;br /&gt;\n        for(int i&amp;#61;0;i&amp;lt;size;i&amp;#43;&amp;#43;)&lt;br /&gt;\n            ptr[i]&amp;#61;arr.ptr[i];&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;&lt;br /&gt;\n    int getSize(){return size;}&lt;/p&gt;\n\n&lt;p&gt;    int &amp;amp;operator[](int n){return ptr[n];}&lt;/p&gt;\n\n&lt;p&gt;    const int &amp;amp;operator[](int n)const{return ptr[n];}&lt;/p&gt;\n\n&lt;p&gt;    MyArray &amp;amp;operator&amp;#61;(const MyArray&amp;amp; arr)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        if(&amp;amp;arr!&amp;#61;this)&lt;br /&gt;\n        {&lt;!-- --&gt;&lt;br /&gt;\n            if(size!&amp;#61;arr.size)&lt;br /&gt;\n            {&lt;!-- --&gt;&lt;br /&gt;\n                delete [] ptr;&lt;br /&gt;\n                size&amp;#61;arr.size;&lt;br /&gt;\n                ptr &amp;#61;new int[size];&lt;br /&gt;\n            }&lt;br /&gt;\n            for(int i&amp;#61;0;i&amp;lt;size;i&amp;#43;&amp;#43;)&lt;br /&gt;\n                ptr[i]&amp;#61;arr.ptr[i];&lt;br /&gt;\n        }&lt;br /&gt;\n        return *this;&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;&lt;br /&gt;\n    friend ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; os,const MyArray&amp;amp; arr);&lt;/p&gt;\n\n&lt;p&gt;    friend MyArray operator&amp;#43;(const MyArray&amp;amp; arr1, const  MyArray&amp;amp; arr2);&lt;br /&gt;\n    friend MyArray operator-(const MyArray&amp;amp; arr1, const  MyArray&amp;amp; arr2);&lt;br /&gt;\n    friend int operator*(const MyArray&amp;amp; arr1, const  MyArray&amp;amp; arr2);&lt;br /&gt;\n};&lt;br /&gt;\n    ostream &amp;amp;operator&amp;lt;&amp;lt;(ostream&amp;amp; os,const MyArray&amp;amp; arr)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        for(int i&amp;#61;0;i&amp;lt;arr.size;i&amp;#43;&amp;#43;)&lt;br /&gt;\n        {&lt;!-- --&gt;&lt;br /&gt;\n            os&amp;lt;&amp;lt;arr.ptr[i];&lt;br /&gt;\n            if(i&amp;lt;arr.size-1)&lt;br /&gt;\n                os&amp;lt;&amp;lt;&amp;#34;,&amp;#34;;&lt;br /&gt;\n        }&lt;br /&gt;\n        os&amp;lt;&amp;lt;endl;&lt;br /&gt;\n        return os;&lt;br /&gt;\n    }&lt;/p&gt;\n\n&lt;p&gt;    MyArray operator&amp;#43;(const MyArray&amp;amp; arr1, const  MyArray&amp;amp; arr2)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        MyArray arr(arr1.size);&lt;br /&gt;\n        for(int i&amp;#61;0;i&amp;lt;arr1.size;i&amp;#43;&amp;#43;)&lt;br /&gt;\n            arr.ptr[i]&amp;#61;arr1.ptr[i]&amp;#43;arr2.ptr[i];&lt;br /&gt;\n        return arr;&lt;br /&gt;\n    }&lt;br /&gt;\n    MyArray operator-(const MyArray&amp;amp; arr1, const  MyArray&amp;amp; arr2)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        MyArray arr(arr1.size);&lt;br /&gt;\n        for(int i&amp;#61;0;i&amp;lt;arr1.size;i&amp;#43;&amp;#43;)&lt;br /&gt;\n            arr.ptr[i]&amp;#61;arr1.ptr[i]-arr2.ptr[i];&lt;br /&gt;\n        return arr;&lt;br /&gt;\n    }&lt;br /&gt;\n    int operator*(const MyArray&amp;amp; arr1, const  MyArray&amp;amp; arr2)&lt;br /&gt;\n    {&lt;!-- --&gt;&lt;br /&gt;\n        int s&amp;#61;0;&lt;br /&gt;\n        for(int i&amp;#61;0;i&amp;lt;arr1.size;i&amp;#43;&amp;#43;)&lt;br /&gt;\n            s&amp;#61;arr1.ptr[i]*arr2.ptr[i]&amp;#43;s;&lt;br /&gt;\n        return s;&lt;br /&gt;\n    }&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["编程题，做了很久都还是不知道怎么做", ["定义一个MyArray类，内部有私有成员", "int size", "和", "int *ptr", "。", "\n\n", " ", "\n\n", "创建该类对象时，在构造函数中用", "new", "动态内存分配一个长度为", "size", "的一维整型数组并用", "ptr", "成员存储该数组的首地址。析构函数要释放动态数组。", "\n\n", " ", "\n\n", "为该类重载以下运算符：", "\n\n", " ", "\n\n", "（1）下标运算符[ ]，利用该下标运算符实现对数组元素的读写访问", "\n\n", " ", "\n\n", "（2）赋值运算符，实现MyArray对象之间正确的深层赋值。", "\n\n", " ", "\n\n", "（3）+运算符，实现两个MyArray对象的数组的对应元素相加，返回一个新的MyArray对象，该对象的数组中存储了之前两个数组对应元素相加的结果。", "\n\n", " ", "\n\n", "（4）-运算符，实现两个MyArray对象的数组的对应元素相减，返回一个新的MyArray对象，该对象的数组中存储了之前两个数组对应元素相减的结果。", "\n\n", " ", "\n\n", "（5）*运算符，将两个MyArray对象的数组视作向量，该运算符用于求向量内积", "\n\n", " ", "\n\n", "（6）<<运算符，实现使用cout输出对象的数组的内容", "\n\n", " ", "\n\n", "此外，该类的复制构造函数要正确实现深层复制。", "\n\n", " ", "\n\n", "main函数已经写好，请根据main函数的内容完成该类的设计：", "\n\n", " ", "\n\n", "int main(){", "\n\n", "int n;", "\n\n", "cin>>n;", "\n\n", "MyArray arr1(n);", "\n\n", "for(int i=0;i<arr1.getSize();i++)", "\n\n", "cin>>arr1[i];", "\n\n", "cout<<arr1;", "\n\n", "MyArray arr2(arr1);", "\n\n", "for(int i=0;i<arr2.getSize();i++)", "\n\n", "arr2[i]+=1;", "\n\n", "cout<<arr2;", "\n\n", "MyArray arr3,arr4;", "\n\n", "arr3=arr2+arr1;", "\n\n", "cout<<arr3;", "\n\n", "arr4=arr2-arr1;", "\n\n", "cout<<arr4;", "\n\n", "cout<<arr1*arr2<<endl;", "\n\n", "return 0;", "\n\n", "}", "\n\n", " ", "\n\n", "输入描述先输入变量n，创建一个MyArray对象，其对应的数组有n个元素", "\n\n", "然后输入数组的n个元素的值", "\n\n", "输出描述根据样例输出", "\n\n", "提示你需要提交除了main函数之外的其他代码。", "\n\n", "样例输入复制样例输入数据", "\n\n", "5", "\n1 2 3 4 5", "\n\n", "样例输出1,2,3,4,5", "\n2,3,4,5,6", "\n3,5,7,9,11", "\n1,1,1,1,1", "\n70", "\n\n", "允许最长运行时间1000ms", "\n\n", "允许使用最大内存64KB"]], "Tag": "程序设计"}
{"Answer": "左值右值的形式区分（或者称语法区分）是能否用取地址&amp;运算符；语义区分（即其本质涵义）在于表达式代表的是持久对象还是临时对象。", "Konwledge_Point": "赋值运算符", "Question": ["到底怎么确定函数调用表达式的结果是左值还是右值？", ["《C++primer》（第五版）P129页中说道：赋值运算符的左侧运输对象必须是一个可修改的左值。_", "\n还有很多人说：左值右值的判定是：看能否使用取地址运算符，能用的是左值。", "\nP202说到：函数的返回类型决定函数调用是否是左值。调用一个返回引用的的函数得到左值，其他返回类型得到右值。", "\n请看看下面的代码，为什么该函数调用可以被用在赋值符左侧，也可以使用取地址运算符？但是最后一个表达式却是错的，说是：非常量引用只能绑定到左值。", "到底怎么确定函数调用表达式的结果是左值还是右值？", "\nstring shortStr(string s1, string s2)", "\n{", "\n    return s1.size() <= s2.size() ? s1 : s2;", "\n}", "\nint main( )", "\n{", "\n    string str1 = \"abcd\", str2 = \"efghi\";", "\n    shortStr(str1, str2) = \"oooo\";                           //A", "\n    string *ps=&(shortStr(str1, str2));                     //B", "\n    string &rs = shortStr(str1,str2);                        //C", "\n    system(\"pause\");", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "第一个：你代码里的m_pName类型是string*， 是一个string类的指针，如果你直接打印，打印的是地址，*m_pName才代表这个数据的值，\r\n比如int a = 0；你可以打印出a的值，但是 int * b = &amp;a; 你直接打印b就是地址  打印*b才是数据。\r\n\r\n第二个： 因为你是在定义成员函数 ，m_pName 是成员变量，都是在同一个类里，所以this可以不写，默认就是this-&gt;m_pName.", "Konwledge_Point": "赋值运算符", "Question": ["关于C++引用传递参数以及this指针的疑问？", ["void swapint(int &a, int &b)\n{\n    cout << a << '\\n' << b << endl;\n    int temp;\n    temp = a;\n    a = b;\n    b = temp;\n}\n", "\n\n", "class Critter\n{\npublic:\n       Critter(const string& name = \"\", int age = 0);\n       ~Critter();                   \n       Critter(const Critter& c);   \n       Critter& operator=(const Critter& c); \n       void Greet() const;\nprivate:\n       string* m_pName;                       \n       int m_Age;\n};\n\nvoid testAssignmentOp()\n{\n       Critter crit1(\"crit1\", 7);\n       Critter crit2(\"crit2\", 9);\n       crit1 = crit2; //这里会调用重载的复制运算符\n       crit1.Greet();\n       crit2.Greet();\n       cout << endl;\n       Critter crit3(\"crit\", 11);\n       crit3 = crit3;\n       crit3.Greet();\n}\n\nCritter& Critter::operator=(const Critter& c)\n{\n    if (this != &c)\n        {\n            cout << *(c.m_pName) << '\\n';\n            delete m_pName;\n            m_pName = new string(*(c.m_pName));\n            m_Age = c.m_Age;\n        }\n        return *this; \n}\n", "\n\n", "上面两个代码块，第一个是通过引用传递来交换a和b的值，另一个是重载赋值运算符。", "\n\n", "我的疑问是：第一个代码块的cout << a << '\\n' << b << endl; 输出的就是实参的值。但是为什么第二个代码块的c.m_pName却需要间址运算符才能输出实参的值，只写c.m_pName只会输出对应的地址。", "\n\n", "另外关于this指针的问题是：第二个代码块中，为什么编译器可以自动识别出m_pName, m_Age指代的就是this？我编译过是能通过的。当然this->m_pName 和，this->m_Age也是能通过", "\n\n", "非常感谢回答。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以参考一下&amp;#xff01;亲&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;\n#include &amp;lt;iostream&amp;gt;\n#include&amp;lt;string&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;intArray&lt;/span&gt;&lt;/span&gt;\n{\n    friend istream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream&amp;amp; cin, intArray&amp;amp;);&lt;span class=\"hljs-comment\"&gt;//数组的整体输入&lt;/span&gt;\n    friend ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; cout, intArray&amp;amp;);&lt;span class=\"hljs-comment\"&gt;//数组的整体输出&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    intArray(){}\n    intArray(int size);&lt;span class=\"hljs-comment\"&gt;//构造函数&lt;/span&gt;\n    intArray(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; x);&lt;span class=\"hljs-comment\"&gt;//复制构造函数&lt;/span&gt;\n    ~intArray();&lt;span class=\"hljs-comment\"&gt;//析构函数&lt;/span&gt;\n    bool Set(int i, int elem)&lt;span class=\"hljs-comment\"&gt;//设置第i个数组元素的值&amp;#xff0c;设置成功返回true&amp;#xff0c;失败返回false&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i&amp;gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;amp;&amp;amp;i&amp;lt;&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element[i] &amp;#61; elem;\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        }\n    }\n    int Get(int i)&lt;span class=\"hljs-comment\"&gt;//获取第i个数组元素的值&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; &amp;amp;&amp;amp; i &amp;lt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element[i];\n        }\n    }\n    int Length() {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;//获取数组长度&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; arraysize;\n    }\n   \n    void ReSize(int size);&lt;span class=\"hljs-comment\"&gt;//重置数组的长度&lt;/span&gt;\n    intArray&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; other);&lt;span class=\"hljs-comment\"&gt;//赋值运算符“&amp;#61;”重载函数&lt;/span&gt;\n    intArray &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; other);&lt;span class=\"hljs-comment\"&gt;//加运算符“&amp;#43;”重载函数&lt;/span&gt;\n    intArray &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; other);&lt;span class=\"hljs-comment\"&gt;//减运算符“-”重载函数&lt;/span&gt;\n   \n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    int* element;&lt;span class=\"hljs-comment\"&gt;//指向动态数组的指针&lt;/span&gt;\n    int arraysize;&lt;span class=\"hljs-comment\"&gt;//数组的当前长度&lt;/span&gt;\n};\n\nintArray::~intArray() {\n    delete element;\n    element &amp;#61; NULL;\n}\nintArray::intArray(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; x) {\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize &amp;#61; x.arraysize;\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element &amp;#61; new int[arraysize];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; arraysize; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element[i] &amp;#61; x.element[i];\n    }\n}\nintArray::intArray(int size) {\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize &amp;#61; size;\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element &amp;#61; new int[size];\n}\n\n&lt;span class=\"hljs-comment\"&gt;/*\n    对数组对象进行输入\n*/&lt;/span&gt;\nistream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;gt;&amp;gt;(istream&amp;amp; cin, intArray&amp;amp; arr) {\n    int temp &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;arr.arraysize; i&amp;#43;&amp;#43;)\n    {\n        cin &amp;gt;&amp;gt; temp;\n        arr.element[i] &amp;#61; temp;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cin;\n}\n&lt;span class=\"hljs-comment\"&gt;/*\n    对数组对象进行输出\n*/&lt;/span&gt;\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; cout, intArray&amp;amp; arr) {\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; arr.arraysize; i&amp;#43;&amp;#43;)\n    {\n        cout &amp;lt;&amp;lt; arr.element[i] &amp;lt;&amp;lt; endl;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; cout;\n}\nintArray&amp;amp; intArray::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; other)&lt;span class=\"hljs-comment\"&gt;//赋值运算符“&amp;#61;”重载函数&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element !&amp;#61; NULL)\n    {\n        delete &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element &amp;#61; NULL;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize &amp;#61; other.arraysize;\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element &amp;#61; new int[arraysize];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; arraysize; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element[i] &amp;#61; other.element[i];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n}\nintArray intArray:: &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; other)&lt;span class=\"hljs-comment\"&gt;//加运算符“&amp;#43;”重载函数&lt;/span&gt;\n{\n    intArray temp(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize; i&amp;#43;&amp;#43;)\n    {\n        temp.element[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element[i] &amp;#43; other.element[i];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n}\nintArray intArray:: &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;-(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; intArray&amp;amp; other)&lt;span class=\"hljs-comment\"&gt;//减运算符“-”重载函数&lt;/span&gt;\n{\n    intArray temp(&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize; i&amp;#43;&amp;#43;)\n    {\n        temp.element[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element[i] - other.element[i];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; temp;\n}\nvoid intArray::ReSize(int size) {\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;arraysize &amp;#61; size;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element!&amp;#61;NULL)\n    {\n        delete &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;-&amp;gt;element &amp;#61; new int[size];\n}\nintArray&amp;amp; testA() {\n    int size &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入要构造的数组长度&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; size;\n    intArray* a&amp;#61;new intArray(size);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; size &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;个数字来为数组对象a初始化&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; *a;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印数组对象a&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; *a;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *a;\n}\nintArray&amp;amp; testB(intArray&amp;amp; a) {\n    &lt;span class=\"hljs-comment\"&gt;//拷贝构造数组b&lt;/span&gt;\n    intArray* b &amp;#61; new intArray(a);\n    int size &amp;#61; a.Length();&lt;span class=\"hljs-comment\"&gt;//获取数组长度&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印数组对象b&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; *b &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印数组对象b下标为奇数的值&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; size; i &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n    {\n        cout &amp;lt;&amp;lt; (*b).Get(i) &amp;lt;&amp;lt; endl;\n    }\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;将奇数下标的值翻倍&amp;#xff0c;再打印数组对象b&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; size; i &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;)\n    {\n        (*b).Set(i, (*b).Get(i) * &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n    }\n    cout &amp;lt;&amp;lt; *b &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *b;\n}\nintArray&amp;amp; testC(intArray&amp;amp; a) {\n    &lt;span class=\"hljs-comment\"&gt;//构造数组对象c&lt;/span&gt;\n    intArray* c&amp;#61;new intArray(&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        (*c).Set(i, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n    }\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印数组对象c&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; *c &amp;lt;&amp;lt; endl;\n    (*c).ReSize(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    (*c) &amp;#61; a;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印赋值操作后的数组对象c&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; *c &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *c;\n}\nvoid testD(intArray&amp;amp; b, intArray&amp;amp; c) {\n    intArray d &amp;#61; b &amp;#43; c;\n    intArray e &amp;#61; b - c;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印数组对象d&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;打印数组对象e&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; e &amp;lt;&amp;lt; endl;\n}\nvoid test() {\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;*************问题1解答*************&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;\n    intArray a&amp;#61;testA();\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;*************问题2解答*************&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;\n    intArray b &amp;#61; testB(a);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;*************问题3解答*************&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;\n    intArray c&amp;#61; testC(a);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;*************问题4解答*************&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;\n    testD(b, c);\n}\nint main()\n{\n    test();\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c++类编程学习问题", ["下面是一个整型数组类intArray的声明，请给出该类所有数据成员的类外定义。要求：", "\n", "（1）能通过对“>>”、“<<”的重载实现数组元素的直接输入及其输出。输入时，第一次输入的值为数组长度，后面连续输入若干个数作为数组内容。输出时，首先提示该数组元素个数，然后依次输出该数组各元素；", "\n", "（2）重载“=”、“+”、“-” 运算符使之能对两个数组类对象进行直接赋值、加减运算。", "\n", "（3）写出主函数对该类进行测试。要求：", "\n", "1）先构造包含10个数组元素的数组对象a，再调用流提取运算符重载函数实现a的元素初始化（元素值分别为1—10），输出a数组；", "\n", "2）并利用a来构造数组b，输出数组b，并调用get函数获取b中下标为奇数的各元素值并输出，然后调用set函数将上述元素值乘以2，输出b数组；", "\n", "3）构造一个包含5个元素的数组c，其值全为1，输出该数组，再调用ReSize函数将其大小重置为10，调用“=”重载函数将a的值复制给c，输出数组c；", "\n", "4）分别将b+c，b-c的值送给数组d和数组e，并输出结果。", "\n", "class intArray", "\n", "{public:", "\n", "intArray(int size);//构造函数", "\n", "intArray(const intArray &x);//复制构造函数", "\n", "~intArray();//析构函数", "\n", "bool Set(int i, int elem);//设置第i个数组元素的值，设置成功返回true，失败返回false", "\n", "bool Get(int i, int &elem); //获取第i个数组元素的值，获取成功返回true，失败返回false", "\n", "int Length( ) const;//获取数组的长度", "\n", "void ReSize ( int size ); //重置数组", "\n", "intArray &operator=(const intArray &other);  //赋值运算符“=”重载函数", "\n", "intArray &operator+(const intArray &other);   //加运算符“=”重载函数", "\n", "intArray &operator-(const intArray &other) ;  //减运算符“=”重载函数", "\n", "friend ostream & operator>>(ostream &, intArray &);  //数组的整体输入", "\n", "friend ostream & operator<<(ostream &, intArray &);  //数组的整体输出", "\n", "private:", "\n", "int *element;            //指向动态数组的指针", "\n", "int arraysize;            //数组的当前长度", "\n", "};"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;button没有分配内存&amp;#xff0c;还有字符串比较不能直接用&amp;#61;&amp;#61;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c++类与对象练习题，编了很久，调试却总有问题，希望大家帮我指出错误", ["题目：设计一个空调类airCondition，其中包括：", "数据成员：品牌（要求char* 类型）、颜色、攻率、开关状态、设定温度；", "构造函数：对品牌、颜色、攻率、设定温度赋初值；", "要求1.写出复制构造函数（参数必须被const 修饰），赋值运算符重载函数", "2.要求有一定有默认构造函数的生成（=default的使用）", "析构函数：用户自定义（注意动态申请的资源的释放）；", "成员函数：切换开关状态、升温、降温。", "主函数中要求至少创建三个对象，其中之一用复制构造函数初始化，另外一个创建后用赋值运算符赋值；", "具体信息如：格力、白色、2匹、25度等等。调用其“切换开关状态”函数打开空调，调用其“降温”函数调整温度为20度，并打印空调状态和目前设定的温度到屏幕。", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<conio.h>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "airCondition", "\n{\n", "private", ":\n    ", "char", " *brand;", "char", " *power;", "char", " *color;\n", "public", ":\n    ", "char", "*button;", "float", " temp;\n    ", "airCondition", "(", "char", "*br,", "char", "*po,", "char", "*co,", "char", "*button,", "float", " temp)\n    {\n        ", "if", "(br)\n        {\n            brand=", "new", " ", "char", "[", "strlen", "(br)+", "1", "];\n            ", "strcpy", "(brand,br);\n        }\n        ", "if", "(po)\n        {\n            power=", "new", " ", "char", "[", "strlen", "(po)+", "1", "];\n            ", "strcpy", "(power,po);\n        }\n        ", "if", "(co)\n        {\n            color=", "new", " ", "char", "[", "strlen", "(co)+", "1", "];\n            ", "strcpy", "(color,co);\n        };\n    }", "//定义了空调类的构造函数，不变的属性如品牌、颜色等放私有，变的属性如开关、温度放公有。", "\n        ~", "airCondition", "();\n        ", "airCondition", "(", "const", " airCondition &a);\n", "//析构函数和复制构造函数声明", "\n    ", "void", " ", "change", "()", "\n    ", "{\n        ", "if", "(button==", "\"关\"", ")\n            button=", "\"开\"", ";\n        ", "if", "(button==", "\"开\"", ")\n            button=", "\"关\"", ";\n    }", "//开关函数，按回车实现开或关", "\n    ", "void", " ", "tempup", "()", "\n    ", "{\n        cout<<", "\"按“↑”增加温度，“ESC”退出升温\"", "<<endl;\n        ", "int", " c;\n        ", "while", "(", "1", ")\n        {\n            c=", "getch", "();\n            ", "if", "(c==", "38", ")\n                temp+=", "1", ";\n            ", "if", "(c==", "27", ")\n                ", "break", ";\n        }\n    }", "//升温函数", "\n    ", "void", " ", "tempdown", "()", "\n    ", "{\n        cout<<", "\"按“↓”降低温度，“ESC”退出降温\"", "<<endl;\n        ", "int", " d;\n        ", "while", "(", "1", ")\n        {\n            d=", "getch", "();\n            ", "if", "(d==", "40", ")\n                temp+=", "1", ";\n            ", "if", "(d==", "27", ")\n                ", "break", ";\n        }\n    }", "//降温函数", "\n    ", "void", " ", "print", "()", "\n    ", "{\n        cout<<", "\"品牌：\"", "<<brand<<", "'\\t'", "<<", "\"功率\"", "<<power<<endl<<", "\"颜色\"", "<<color<<endl<<", "\"状态\"", "<<button<<endl<<", "\"温度\"", "<<temp<<endl;\n    }", "//输出函数", "\n};\nairCondition::", "airCondition", "(", "const", " airCondition &a)\n{\n    ", "if", "(a.brand)\n        {\n            brand=", "new", " ", "char", "[", "strlen", "(brand)+", "1", "];\n            ", "strcpy", "(brand,a.brand);\n        }\n        ", "if", "(a.power)\n        {\n            power=", "new", " ", "char", "[", "strlen", "(a.power)+", "1", "];\n            ", "strcpy", "(power,a.power);\n        }\n        ", "if", "(a.color)\n        {\n            color=", "new", " ", "char", "[", "strlen", "(a.color)+", "1", "];\n            ", "strcpy", "(color,a.color);\n        };\n}", "//复制构造函数", "\nairCondition::~", "airCondition", "()\n{\n    ", "if", "(brand)\n        ", "delete", " []brand;\n    ", "if", "(power)\n        ", "delete", " []power;\n    ", "if", "(color)\n        ", "delete", " []color;\n    ", "if", "(button)\n        ", "delete", " []button;\n}\n", "//析构函数", "\n", "void", " ", "main", "()", "\n", "{\n    ", "int", " m;\n    ", "airCondition ", "a1", "(", "\"格力\"", ",", "\"3匹\"", ",", "\"黄\"", ",", "\"关\"", ",", "25", ")", ";\n    ", "airCondition ", "a2", "(", "\"美的\"", ",", "\"2匹\"", ",", "\"绿\"", ",", "\"关\"", ",", "25", ")", ";\n    ", "airCondition ", "a3", "(", "\"海尔\"", ",", "\"4匹\"", ",", "\"白\"", ",", "\"关\"", ",", "25", ")", ";\n    ", "airCondition ", "a4", "(a1)", ";\n    cout<<", "\"请输入空调编号来选择空调\"", "<<endl;\n    cin>>m;\n    ", "if", "(m==", "1", ")\n    {\n        a1.", "print", "();\n        a1.", "change", "();\n        a1.", "tempup", "();\n        a1.", "tempdown", "();\n        a1.", "print", "();\n    }\n    ", "if", "(m==", "2", ")\n    {\n        a2.", "print", "();\n        a2.", "change", "();\n        a2.", "tempup", "();\n        a2.", "tempdown", "();\n        a2.", "print", "();\n    }\n    ", "if", "(m==", "3", ")\n    {\n        a3.", "print", "();\n        a3.", "change", "();\n        a3.", "tempup", "();\n        a3.", "tempdown", "();\n        a3.", "print", "();\n    }\n    ", "if", "(m==", "4", ")\n    {\n        a4.", "print", "();\n        a4.", "change", "();\n        a4.", "tempup", "();\n        a4.", "tempdown", "();\n        a4.", "print", "();\n    }\n    ", "getchar", "();\n    ", "getchar", "();\n}\n\n\n\n\n\n", "\n", "\n", "我的代码如上，应该和题目描述的差不多吧，空调温度应该是一度一度调的吧，但是运行总是有问题", "希望大家能帮我，大一小白，我真的编了好久", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;s_ &amp;#61; new char(strlen(str) &amp;#43; 1);&lt;br /&gt;这一句的含义是new申请一个char类型大小的空间&amp;#xff0c;将该空间赋值为strlen(str) &amp;#43; 1&amp;#xff0c;并返回值&lt;br /&gt;上面这句话等于下面这句话&amp;#xff1a;&lt;br /&gt;s_&amp;#61;new char&amp;#xff1b;&lt;br /&gt;*s_&amp;#61;strlen(str) &amp;#43; 1&amp;#xff1b;&lt;br /&gt;因为C&amp;#43;&amp;#43;允许对char赋整形值&amp;#xff1b;&lt;br /&gt;而new 类型&amp;#xff08; 值&amp;#xff09;这种写法是在申请地址时构造&amp;#xff1b;&lt;br /&gt;如果希望申请数组应该这么写&amp;#xff1a;&lt;br /&gt;s_&amp;#61;new char[ strlen(str) &amp;#43; 1];&lt;br /&gt;释放空间时也要用对应的delete [] s_&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["调用析构函数报错HEAP ERROR DETECTED", ["实现了一个字符串类", "Str", ".，然后重载运算符", "+", "和运算符", "=", "。在调用这两个构造函数的时候程序报错HEAP ERROR DETECTED。", "\n", "\n", "类的实现如下", "\n", "class", " ", "String", "\n{\n", "public", ":\n    ", "String", "(", "const", " ", "char", "* s=", "\"\"", ");\n    ", "String", "(", "const", " ", "String", "& other);\n    ~", "String", "();", "//拷贝构造函数", "\n    ", "String", "& ", "operator", "=(", "const", " ", "String", "& other);  ", "//赋值运算符重载", "\n    ", "String", "& ", "operator", "=(", "const", " ", "char", "* s);", "//为字符串类直接赋值", "\n    ", "friend", " ", "String", " ", "operator", "+(", "String", "& s1, ", "String", "& s2);\n    ", "void", " ", "Display", "()", " ", "const", ";", "//显示", "\n    ", "void", " ", "Copy", "(", "const", " ", "char", "* str)", ";\n", "private", ":\n    ", "char", "* s_;\n};\n", "#", "include", " ", "\"String.h\"", "\n", "#", "include", "<cstring>", "\n", "#", "include", "<iostream>", "\n\n", "using", " ", "namespace", " std;\n", "void", " ", "String::Copy", "(", "const", " ", "char", "* str)", "\n", "{\n    s_ = ", "new", " ", "char", "(", "strlen", "(str) + ", "1", ");\n    ", "strcpy_s", "(s_, ", "strlen", "(str) + ", "1", ", str);\n}\n", "String", "::", "String", "(", "const", " ", "char", "* s)\n{\n    ", "Copy", "(s);\n    cout << ", "\"Create \"", " << s_ <<", "\" by constructor\"", " << endl;\n}\n", "String", "::", "String", "(", "const", " ", "String", "& other)\n{\n    ", "//delete s_;", "\n    ", "Copy", "(other.s_);\n    cout << ", "\"Copy Constructor \"", " << s_ << endl;\n}\n", "String", "::~", "String", "()\n{\n    cout << ", "\"Delete \"", " << s_ << endl;\n    ", "delete", " s_;\n}\n", "void", " ", "String::Display", "()", " ", "const", "\n", "{\n    cout << s_ << endl;\n}\n", "String", "& ", "String", "::", "operator", "=(", "const", " ", "char", "* s)\n{\n    ", "delete", " s_;\n    ", "Copy", "(s);\n    ", "return", " *", "this", ";\n}\n", "String", "& ", "String", "::", "operator", "=(", "const", " ", "String", "& other)\n{\n    ", "if", " (", "this", " == &other)\n        ", "return", " *", "this", ";\n    ", "delete", " s_;\n    ", "Copy", "(other.s_);\n    \n    ", "return", " *", "this", ";\n}\n\n", "String", " ", "operator", "+(", "String", "& s1, ", "String", "& s2)\n{\n    ", "int", " n1 = ", "strlen", "(s1.s_);\n    ", "int", " n2 = ", "strlen", "(s2.s_);\n    ", "char", "* tmp = ", "new", " ", "char", "[n1 + n2 + ", "1", "];\n    ", "strcpy_s", "(tmp, n1 + ", "1", ", s1.s_);\n    ", "strcat_s", "(tmp, n1 + n2 + ", "1", ", s2.s_);\n    ", "return", " ", "String", "(tmp);\n}\n", "\n", "测试代码如下：", "\n", "#", "include", "\"String.h\"", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<cstring>", "\n\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", "\n", "{\n\n    ", "String", " s1;\n    s1 = ", "\"hello\"", ";\n    s1.name = ", "1", ";\n    ", "String", " ", "s2", "(", "\" world\"", ")", ";\n    s2.name = ", "2", ";\n    ", "String", " s3;\n    s3 = s1 + s2;\n    s3.name = ", "3", ";\n    ", "return", " ", "0", ";\n}\n", "\n", "进一步调试发现，在执行代码", "s3 = s1 + s2", "时，", "operator+", "函数返回一个临时变量，然后通过拷贝构造函数赋值给", "s3", "，随后调用析构函数释放该临时变量，在调用析构函数时报错。", "想不明白为什么这里报错，求解释，万分感谢！"]], "Tag": "程序设计"}
{"Answer": "解释的都太清楚了。都不知道怎么解释了。\r\n\r\n如果还不理解，看下面的例子，帮助你理解什么叫无限递归：\r\n\r\n\r\n```\r\n void foo()\r\n{\r\n    foo();\r\n}\r\n\r\nint main()\r\n{\r\n    foo();\r\n}\r\n```\r\n\r\n注意，理论上无限递归是死循环，但是实际上不是，因为堆栈的大小是有限的。所以无限递归丢出的是堆栈溢出的错误。", "Konwledge_Point": "赋值运算符", "Question": ["为什么拷贝构造函数的参数类型不是引用 就会变成死循环的递归", ["实在不理解这个递归的过程", "\n01.#include", "\n02.using namespace std;", "\n03.", "\n04.class CExample", "\n05.{", "\n06.private:", "\n07.    int m_nTest;", "\n08.", "\n09.public:", "\n10.    CExample(int x) : m_nTest(x)      //带参数构造函数", "\n11.    {", "\n12.        cout << \"constructor with argument\"<<endl;", "\n13.    }", "\n14.", "\n15.    // 拷贝构造函数，参数中的const不是严格必须的，但引用符号是必须的", "\n16.    CExample(const CExample & ex)     //拷贝构造函数", "\n17.    {", "\n18.        m_nTest = ex.m_nTest;", "\n19.        cout << \"copy constructor\"<<endl;", "\n20.    }", "\n21.", "\n22.    CExample& operator = (const CExample &ex)   //赋值函数(赋值运算符重载)", "\n23.    {", "\n24.        cout << \"assignment operator\"<<endl;", "\n25.        m_nTest = ex.m_nTest;", "\n26.        return *this;", "\n27.    }", "\n28.", "\n29.    void myTestFunc(CExample ex)", "\n30.    {", "\n31.    }", "\n32.};", "\n33.", "\n34.int main(void)", "\n35.{", "\n36.    CExample aaa(2);", "\n37.    CExample bbb(3);", "\n38.    bbb = aaa;", "\n39.    CExample ccc = aaa;", "\n40.    bbb.myTestFunc(aaa);", "\n41.", "\n42.    return 0;", "\n43.}", "\n输出结果：", "\n01.constructor with argument        // CExample aaa(2);", "\n02.constructor with argument        // CExample bbb(3);", "\n03.assignment operator              // bbb = aaa;", "\n04.copy constructor                 // CExample ccc = aaa;   ", "\n\n", "05.copy constructor                 //  bbb.myTestFunc(aaa);  ", "\n\n", "第四个输出： copy constructor                      // CExample ccc = aaa", "\n构造ccc的时候只调用一次复制构造函数从aaa那里构造出新对象了", "\n\n", "但是放到复制构造函数参数里面如果不是引用而是用aaa传值的话 就会像下面说的", "\n\n", "构造ccc，实质上是ccc.CExample(aaa); 我们假如拷贝构造函数参数不是引用类型的话， 那么将使得 ccc.CExample(aaa)变成aaa传值给ccc.CExample(CExample ex)，即CExample ex = aaa，因为 ex 没有被初始化， 所以 CExample ex = aaa 继续调用拷贝构造函数，接下来的是构造ex，也就是 ex.CExample(aaa)，必然又会有aaa传给CExample(CExample ex), 即 CExample ex = aaa;那么又会触发拷贝构造函数，就这下永远的递归下去。", "\n------------------------------  这是我百度的结果很多都是这样说的但是还是理解不了", "\n\n", "为什么2个  CExample ccc = aaa 差不多", "\n 一个是放在函数内 就无法构造对象了？而是形成递归？"]], "Tag": "程序设计"}
{"Answer": "```\r\n 可以，使用接口可以实现\r\ninterface MyOpt\r\n{\r\n    int calc(int a, int b);\r\n}\r\nclass Add implements MyOpt\r\n{\r\npublic int calc(int a, int b) { return a + b; }\r\n}\r\nclass Sub implements MyOpt\r\n{\r\npublic int calc(int a, int b) { return a - b; }\r\n}\r\n\r\n使用\r\nMyOpt a = new Add();\r\nint c = a.calc(1, 2);\r\nMyOpt a = new Sub();\r\nint d = a.calc(1, 2);\r\n这里的a就相当于运算符。\r\n```", "Konwledge_Point": "赋值运算符", "Question": ["Java能不能用变量保存运算符", ["各位大牛，我想实现这么一种功能，就是把四则运算符用变量保存起来。使用的时候用变量代替相应的运算符，举个例子就是把＋赋值给变量a，使用的时候1 a 2即可实现等于3，如何实现这种运算？"]], "Tag": "程序设计"}
{"Answer": "x=x+1，就是先加再赋值\r\nx==x+1，是先加然后做比较\r\n\r\n\r\nx==x+1可以做逻辑判断的条件。\r\n楼主没有什么理解不到位的啊。", "Konwledge_Point": "赋值运算符", "Question": ["java中=是赋值的意思，==是等于的意思，这两个运算符的区别和联系什么呢", ["java中=是赋值的意思，==是等于的意思，这两个运算符的区别和联系什么呢，是不是可以这样子理解，x=x+1是正确的写法，x==x+1是不成立的，因为x=！x+1，求分析解答指出理解不到位的地方，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;要具体看看这个BigInt类的代码&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c++运算符重载和类赋值问题", ["我在一个bigint类中重载了一个加法，如下图使用时可以正常运行", "但改成下图后程序会被强制终止", "想问一下是为什么，是没有重载=的问题吗？该怎样修改呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;逗号优先级很低&amp;#xff0c;比等号还低&amp;#xff0c;所以先执行的是y&amp;#61;(x&amp;#61;a&amp;#43;b)&amp;#xff0c;然后才是b&amp;#43;c。自然y就等于a&amp;#43;b&amp;#61;6啊&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["（C语言）对于逗号运算符最低优先级运算的困惑", ["#", "include", "<stdio.h>", "\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "int", " a = ", "2", ", b = ", "4", ", c = ", "6", ", x, y;\n    y = (x = a + b), (b + c);\n    ", "printf_s", "(", "\"y=%d,x=%d\"", ", x, y);\n", "return", " ", "0", "；\n}\n\n", "\n", "我现在用的 VS2019 初学C语言,这里有两个表达式,根据逗号运算符的运算法则,不应该是以（b+c)作为y的赋值吗,得到 y=b+c=4+6=10 吗？为什么我编译运行后得到的是 6 呢？x=6我理解,但为什么y也是等于6,晕"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;这是因为ty2和tx2都是向量&amp;#xff0c;里面元素个数大于1&amp;#xff0c;建议改成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;plane&amp;#61;zeros(10);%设置矩阵\nv1&amp;#61;randi(100);%随机生成第一个机头位置下标\nwhile true\n   &lt;span class=\"hljs-built_in\"&gt; if &lt;/span&gt;v1&amp;#61;&amp;#61;1||v1&amp;#61;&amp;#61;2||v1&amp;#61;&amp;#61;9||v1&amp;#61;&amp;#61;10||v1&amp;#61;&amp;#61;11||v1&amp;#61;&amp;#61;12||v1&amp;#61;&amp;#61;19||v1&amp;#61;&amp;#61;20||v1&amp;#61;&amp;#61;81||v1&amp;#61;&amp;#61;82||v1&amp;#61;&amp;#61;89||v1&amp;#61;&amp;#61;90||v1&amp;#61;&amp;#61;91||v1&amp;#61;&amp;#61;92||v1&amp;#61;&amp;#61;99||v1&amp;#61;&amp;#61;100\n        v1&amp;#61;randi(100);%重新生成机头下标\n    else\n        break\n    end\nend%利用randi函数生成机头位置下标并利用while循环排除机头不能出现的位置\n \n[m,n]&amp;#61;size(dir1);\nrownum&amp;#61;randi([1,m],1,1);%随机选择一行\nntx1&amp;#61;dir1(rownum,1);%将被选中行中的x坐标赋值给ntx1,ntx1代表紧靠机头的蓝色方格的行数\nnty1&amp;#61;dir1(rownum,2);%将被选中行中的x坐标赋值给nty1,nty1代表紧靠机头的蓝色方格的列数\n%此时飞机方向已确定&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;ntx1&amp;#61;&amp;#61;tx1&amp;#43;1%机头朝上的排列\n    plane([v1&amp;#43;1,v1&amp;#43;2,v1&amp;#43;3,v1-9,v1-19,v1&amp;#43;11,v1&amp;#43;21,v1-7,v1&amp;#43;13])&amp;#61;[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nelseif ntx1&amp;#61;&amp;#61;tx1-1%机头朝下的排列\n    plane([v1-1,v1-2,v1-3,v1&amp;#43;9,v1&amp;#43;19,v1-11,v1-21,v1&amp;#43;7,v1-13])&amp;#61;[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nelseif nty1&amp;#61;&amp;#61;ty1&amp;#43;1%机头朝左的排列\n    plane([v1&amp;#43;10,v1&amp;#43;20,v1&amp;#43;30,v1&amp;#43;9,v1&amp;#43;8,v1&amp;#43;11,v1&amp;#43;12,v1&amp;#43;29,v1&amp;#43;31])&amp;#61;[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nelse%机头朝右的排列\n    plane([v1-10,v1-20,v1-30,v1-9,v1-8,v1-11,v1-12,v1-29,v1-31])&amp;#61;[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nend\ndisp(plane)\n%----------------------第一个飞机放置完毕---------------------------------------------------\n%----------------------开始放置第二个飞机---------------------------------------------------\n \n \nplane(v1)&amp;#61;2;%设置第一个机头参数为2\n[tx1,ty1]&amp;#61;find(plane&amp;#61;&amp;#61;2);%获取机头坐标并赋值给tx1&amp;#xff0c;ty1\n \n \ndir1&amp;#61;[[tx1&amp;#43;1 ty1];[tx1-1 ty1];[tx1 ty1&amp;#43;1];[tx1 ty1-1]];%机头四周的位置坐标;机头位置【上&amp;#xff0c;下&amp;#xff0c;左&amp;#xff0c;右】&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;ty1&amp;lt;3||ty1&amp;gt;8||tx1&amp;gt;7\n    delnum1&amp;#61;1;%排除机头朝上的可能性\nend&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;ty1&amp;lt;3||ty1&amp;gt;8||tx1&amp;lt;4\n    delnum2&amp;#61;2;%排除机头朝下的可能性\nend&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;tx1&amp;lt;3||tx1&amp;gt;8||ty1&amp;gt;7\n    delnum3&amp;#61;3;%排除机头朝左的可能性\nend&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;tx1&amp;lt;3||tx1&amp;gt;8||ty1&amp;lt;4\n    delnum4&amp;#61;4;%排除机头朝右的可能性\nend\nA&amp;#61;[delnum1, delnum2, delnum3, delnum4];%将以上判断结果写入矩阵\nB&amp;#61;find(A&amp;gt;&amp;#61;1);%将不可能的方向写入B矩阵\nfor j&amp;#61;length(B):-1:1%利用倒序将不可能的方向删除\n    dir1(B(j),:)&amp;#61;[];\nend\n%此时dir1中剩余的方向都是可实现的\nplane(v2)&amp;#61;3;%设置第二个机头参数为3\n[tx2,ty2]&amp;#61;find(plane&amp;#61;&amp;#61;3);%获取机头坐标并赋值给tx2&amp;#xff0c;ty2\n%% 增加的两行\ntx2 &amp;#61; tx2(1);\nty2 &amp;#61; ty2(1);\n\ndir2&amp;#61;[tx2&amp;#43;1 ty2;tx2-1 ty2;tx2 ty2&amp;#43;1;tx2 ty2-1];%机头四周的位置坐标;机头位置【上&amp;#xff0c;下&amp;#xff0c;左&amp;#xff0c;右】&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;ty2&amp;lt;3||ty2&amp;gt;8||tx2&amp;gt;7\n    delnum21&amp;#61;1;%排除机头朝上的可能性\nend&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;ty2&amp;lt;3||ty2&amp;gt;8||tx2&amp;lt;4\n    delnum22&amp;#61;2;%排除机头朝下的可能性\nend&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;tx2&amp;lt;3||tx2&amp;gt;8||ty2&amp;gt;7\n    delnum23&amp;#61;3;%排除机头朝左的可能性\nend&lt;span class=\"hljs-built_in\"&gt;\nif &lt;/span&gt;tx2&amp;lt;3||tx2&amp;gt;8||ty2&amp;lt;4\n    delnum24&amp;#61;4;%排除机头朝右的可能性\nend\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["Matlab运行遇到“ || 和 && 运算符的操作数必须能够转换为逻辑标量值”问题。", ["自己写了一个寻机头的小游戏，在随机放置第二个飞机的时候有时候运行会显示“ || 和 && 运算符的操作数必须能够转换为逻辑标量值”，但是放置第一个飞机的时候就不会有问题，求帮忙看一下代码是那个地方逻辑出错了吗？", "下面是部分代码：", "\n", "plane=zeros(10);%设置矩阵\nv1=randi(100);%随机生成第一个机头位置下标\nwhile true\n   ", " if ", "v1==1||v1==2||v1==9||v1==10||v1==11||v1==12||v1==19||v1==20||v1==81||v1==82||v1==89||v1==90||v1==91||v1==92||v1==99||v1==100\n        v1=randi(100);%重新生成机头下标\n    else\n        break\n    end\nend%利用randi函数生成机头位置下标并利用while循环排除机头不能出现的位置\n\n[m,n]=size(dir1);\nrownum=randi([1,m],1,1);%随机选择一行\nntx1=dir1(rownum,1);%将被选中行中的x坐标赋值给ntx1,ntx1代表紧靠机头的蓝色方格的行数\nnty1=dir1(rownum,2);%将被选中行中的x坐标赋值给nty1,nty1代表紧靠机头的蓝色方格的列数\n%此时飞机方向已确定\n", "\nif ", "ntx1==tx1+1%机头朝上的排列\n    plane([v1+1,v1+2,v1+3,v1-9,v1-19,v1+11,v1+21,v1-7,v1+13])=[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nelseif ntx1==tx1-1%机头朝下的排列\n    plane([v1-1,v1-2,v1-3,v1+9,v1+19,v1-11,v1-21,v1+7,v1-13])=[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nelseif nty1==ty1+1%机头朝左的排列\n    plane([v1+10,v1+20,v1+30,v1+9,v1+8,v1+11,v1+12,v1+29,v1+31])=[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nelse%机头朝右的排列\n    plane([v1-10,v1-20,v1-30,v1-9,v1-8,v1-11,v1-12,v1-29,v1-31])=[1,1,1,1,1,1,1,1,1];%将机身赋值为1\nend\ndisp(plane)\n%----------------------第一个飞机放置完毕---------------------------------------------------\n%----------------------开始放置第二个飞机---------------------------------------------------\n\n\nplane(v1)=2;%设置第一个机头参数为2\n[tx1,ty1]=find(plane==2);%获取机头坐标并赋值给tx1，ty1\n\n\ndir1=[[tx1+1 ty1];[tx1-1 ty1];[tx1 ty1+1];[tx1 ty1-1]];%机头四周的位置坐标;机头位置【上，下，左，右】", "\nif ", "ty1<3||ty1>8||tx1>7\n    delnum1=1;%排除机头朝上的可能性\nend", "\nif ", "ty1<3||ty1>8||tx1<4\n    delnum2=2;%排除机头朝下的可能性\nend", "\nif ", "tx1<3||tx1>8||ty1>7\n    delnum3=3;%排除机头朝左的可能性\nend", "\nif ", "tx1<3||tx1>8||ty1<4\n    delnum4=4;%排除机头朝右的可能性\nend\nA=[delnum1, delnum2, delnum3, delnum4];%将以上判断结果写入矩阵\nB=find(A>=1);%将不可能的方向写入B矩阵\nfor j=length(B):-1:1%利用倒序将不可能的方向删除\n    dir1(B(j),:)=[];\nend\n%此时dir1中剩余的方向都是可实现的\nplane(v2)=3;%设置第二个机头参数为3\n[tx2,ty2]=find(plane==3);%获取机头坐标并赋值给tx2，ty2\n\ndir2=[tx2+1 ty2;tx2-1 ty2;tx2 ty2+1;tx2 ty2-1];%机头四周的位置坐标;机头位置【上，下，左，右】\n", "\nif ", "ty2<3||ty2>8||tx2>7\n    delnum21=1;%排除机头朝上的可能性\nend", "\nif ", "ty2<3||ty2>8||tx2<4\n    delnum22=2;%排除机头朝下的可能性\nend", "\nif ", "tx2<3||tx2>8||ty2>7\n    delnum23=3;%排除机头朝左的可能性\nend", "\nif ", "tx2<3||tx2>8||ty2<4\n    delnum24=4;%排除机头朝右的可能性\nend\n", "\n", "运行出来的结果", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.合法&lt;br /&gt;2.先自增再赋值&amp;#xff0c;例子中应该是1&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["关于在数组里的运算符的问题", ["int n；", "cin>>n；", "1：int *a=new int[n+1]；这样合法吗", "\n", "2:", "int t=0;", "for(int i=0; i<n; i++){", "     a[++t]=i;", "     b[t++]=i;", "}", "这种形式的运算数组a和b中的t是在赋值完执行还是在循环一次结束后执行？比如a[++t]=i；i被赋值到位置0还是位置1了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;当你使用||&amp;#xff0c;&amp;amp;&amp;amp;这些符号时候返回的就不是整形&amp;#xff0c;而是布尔型&amp;#xff0c;这里是或&amp;#xff0c;然后x&amp;#61;2为真&amp;#xff0c;就不执行右边的&amp;#xff0c;所以t&amp;#61;1为真&amp;#xff0c;我是菜狗&amp;#xff0c;别喷我&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["运算符的题目有点问题，赋值搞不清", ["为啥是c呢，不应该是2吗？然后++在前面不是要优先算，也就是x,y的值都会变成2吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;a href=\"http://php.net/manual/en/language.operators.precedence.php\" rel=\"nofollow\"&gt;PHP: Operator Precendence&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&amp;amp;&amp;amp; has a higher precedence than =, so in the second if, you are assigning the value of &lt;code&gt;fn1(1) &amp;amp;&amp;amp; $var4 == 123&lt;/code&gt; (true or false) to $var2.&lt;/p&gt;\n\n&lt;p&gt;In the first if, AND has a lower precedence than =, so the assignment happens first, then the result is compared.&lt;/p&gt;\n\n&lt;p&gt;In the third if, the assignment happens first again because everything in parens gets processed first.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["PHP逻辑运算符优先级奇怪地影响变量赋值结果", ["\n\n", "$var4 = 123;\n\nfunction fn1($p1)\n{\n    return array('p1' => 1, 'p2' => 2);\n}\n\nif ($var1 = fn1(1) AND $var4 == 123)\n{\n    print_r($var1);\n}\n\nif ($var2 = fn1(1) && $var4 == 123)\n{\n    print_r($var2);\n}\n\nif (($var3 = fn1(1)) && $var4 == 123)\n{\n    print_r($var3);\n}\n", "\n\n", "\n", "If you run this simple script it will output strange results, at\nleast for me!! First output from first if expression will result in\nan array returned from the function & assigned to the $var1\nvariable, which is what I'm expecting, well?", "\n", "Second output from second if expression will result in an integer\n'1' assigned to the $var2 variable, which is NOT expected at all!!\nPlease note that the only changed thing is the logical operator,\nI've used '&&' rather than 'AND', that's all!!", "\n", "Third output from third if expression will result again the expected\narray returned from the function & assigned to the $var3 variable,\nexactly as the first if expression, but wait: I've just embraced the\nassignment statement in the if expression within brackets, while\nstill using the second if expression code!!", "\n", "\n", "Can anyone explain technically -in details- why this strange behavior? php.net reference links will be appreciated.", "\n\n", "I know that '&&' has higher precedence than 'AND' but that doesn't explains it to me!!", "\n    "]], "Tag": "程序设计"}
{"Answer": "是重载函数调用运算符，也就是圆括号运算符，返回内部成员变量的引用，然后外部能够通过返回的引用去修改类内部成员变量的值。\r\n\r\n添加的代码如下：\r\n\r\n```\r\nint&amp; operator()()\r\n{\r\n\treturn v;\r\n}\r\n```", "Konwledge_Point": "赋值运算符", "Question": ["c++中类函数可以直接被赋值吗？如图", ["\n\n", "#include <iostream> \nusing namespace std;\nclass A\n{\npublic:\n    int v;\n    // 你的代码添加在这里\n    A(){\n        v=0;\n    }\n};\nint main()\n{\n    int n;\n    cin >> n;\n    A a;\n    cout << a.v << endl;\n    a() = n;\n    cout << a.v << endl;\n    return 0;\n}\n", "\n\n", "需要重载等号运算符吗？", "\n没见过这种用法，请指教"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Assuming you only have the states you have in your question, you can use a ternary to do this. It might help others understand what you're doing in the future&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$c = ($a || $b) ? 1 : 0;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There's nothing wrong with the way you did it in your question, tho.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["PHP检查| 变量赋值中的（OR）运算符", ["\n\n", "I want to check two variables ", "a", " and ", "b", " and assign both the variable to new variable \"c\" and want to get the ", "OR", " result from both the variables. for example if ", "a=1", " and ", "b=0", ", ", "c", " must be 1, while if ", "a=0", " and ", "b=1", ", ", "c", " must be 1, if ", "a=0", " and ", "b=0", " then ", "c=0", ", for this purpose i am using the following ", "|", " operator, which returns the required result, but i am not sure if i am doing it correct or not", "\n\n", "<?php \n$a = 0; \n$b = 1;     \n$c = $a | $b;\necho(\"Value in $c = \".$c); \n?>\n", "\n\n", "EDIT: i have gone through the PHP.NET website and find that:", "\n\n", " $a | $b    Or (inclusive or)   Bits that are set in either $a or $b are set.\n", "\n\n", "Reference: ", "http://php.net/manual/en/language.operators.bitwise.php", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff01;&amp;#xff01;点击该回答右侧的“采纳”按钮即可采纳&amp;#xff01;&lt;/p&gt;\n&lt;p&gt;如果你想使用MATLAB中的margin函数来计算系统的极位提前角&amp;#xff08;gamma&amp;#xff09;和相位提前角&amp;#xff08;pm&amp;#xff09;&amp;#xff0c;可以使用如下语句&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;[gm,pm] &amp;#61; margin(num, den);\n&lt;span class=\"hljs-built_in\"&gt;gamma&lt;/span&gt; &amp;#61; pm / &lt;span class=\"hljs-number\"&gt;180&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;pi&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;% 将相位提前角从角度转换为弧度&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果你想计算系统的频率增益&amp;#xff0c;可以使用如下语句&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;&lt;span class=\"hljs-attribute\"&gt;kg&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt; * log10(gm)&lt;span class=\"hljs-comment\"&gt;;  % 计算频率增益&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;注意&amp;#xff0c;MATLAB中的log函数是计算以e为底的对数&amp;#xff0c;如果你想计算以10为底的对数&amp;#xff0c;需要使用log10函数。&lt;/p&gt;\n&lt;p&gt;希望这些信息能帮助你解决问题&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["等号左侧的表达式不是用于赋值的有效目标", ["num=[50];", "den=conv([1,0],conv([0.2,1],[0.02,1]));", "[gm,pm]=margin(num,den)", "kg=20", "log(gm)γ=1.6°", "运行：γ不是matlab运算符", "把最后一行改为", "kg=20", "log(gm)/gamma=1.6/circ", "运行：等号左侧的表达式不是用于赋值的有效目标", "这该怎么改"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;文件名是什么&amp;#xff1f;后缀是.c还是.cpp&amp;#xff1f;如果是.c的话&amp;#xff0c;编译器可能会按C语言来编译&amp;#xff0c;但是C语言里是没有运算符重载的&amp;#xff0c;所以应该会有奇怪的报错。如果是这样的话&amp;#xff0c;把.c改成.cpp就可以了。&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["C语言重载==运算符", ["C语言", "结构体中重载==运算符报错", "看报错的意思是少了重要标识符，但是我觉得没毛病啊", "实在是看不懂了，求指点", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<stdbool.h>", "\n", "//定义point结构体 ", "\n", "typedef", " ", "struct", " ", "point", "\n{\n    ", "int", " x;\n    ", "int", " y;\n", "//重载==运算符 ", "\n", "bool", " ", "operator", "==(", "const", " point pfs)\n{\n        ", "return", " (", "this", "->x==pfs.x)&&(", "this", "->y==pfs.y);\n    }\n}po;\n", "//为结构体赋值", "\n", "po ", "point_gets", "(po *pf)", "\n", "{\n    ", "scanf", "(", "\"%d %d\"", ",&(pf->x),&(pf->y));\n    ", "return", " *pf;\n } \n ", "int", " ", "main", "()", "\n ", "{\n     ", "int", " i,j,m,n;\n     ", "scanf", "(", "\"%d\"", ",&n);\n     m=n;\n     po *point_s=(po *)", "malloc", "(n*", "sizeof", "(po));\n     ", "for", "(i=", "0", ";i<n;i++)\n     {\n         point_s[i]=", "point_gets", "(&point_s[i]);\n      } \n      ", "for", "(i=", "0", ";i<n", "-1", ";i++)\n      {\n          ", "for", "(j=i+", "1", ";j<n;j++)\n          {\n              ", "if", "((point_s[i].x==point_s[j].x)&&(point_s[i].y==point_s[j].y))\n              {\n                  m--;\n              }\n          }\n      }\n      ", "printf", "(", "\"%d\"", ",m);\n      ", "free", "(point_s);\n      ", "return", " ", "0", ";\n }\n \n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C&amp;#43;&amp;#43;最全复数运算符重载,参考下&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/PingBryant/article/details/123111393\" id=\"textarea_1652792572240_1652792709113_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C&amp;#43;&amp;#43;最全复数运算符重载_PingBryant的博客-CSDN博客_c&amp;#43;&amp;#43;运算符重载复数&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;C&amp;#43;&amp;#43;语言程序设计中&amp;#xff0c;有关运算符重载的相关规则与方法请参考&amp;#xff1a;https://blog.csdn.net/PingBryant/article/details/123089725?spm&amp;#61;1001.2014.3001.5501史上最全C&amp;#43;&amp;#43;复数运算符重载代码如下&amp;#xff1a;#include&amp;lt;iostream&amp;gt;using namespace std;class Complex{public:Complex(double x&amp;#61;0.0, double y&amp;#61;0.0);  //构造函数&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/PingBryant/article/details/123111393&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c++：复数的运算符重载", ["本题考虑对运算符进行重载。分别重载复数运算的+，-，*，/，=（赋值）运算符，以及比较大小的<=（复数1的模是否小于等于复数2的模）运算符，其中，比较运算符按复数的模进行比较。测试程序根据输入的mode值分别测试各个函数是否编写正确。", "函数接口定义：", "在这里描述函数接口：", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Complex", " {\n    ", "double", " real;\n    ", "double", " imag;\n", "public", ":\n    ", "//构造函数", "\n    ", "Complex", "(", "double", " real=", "0", ", ", "double", " imag=", "0", ");\n\n    ", "//operator+-*/=操作符函数", "\n    Complex ", "operator", "+(", "const", " Complex& c) ", "const", ";\n    Complex ", "operator", "-(", "const", " Complex& c) ", "const", ";\n    Complex ", "operator", "*(", "const", " Complex& c) ", "const", ";\n    Complex ", "operator", "/(", "const", " Complex& c) ", "const", ";\n    Complex ", "operator", "=(", "const", " Complex& c);\n\n    ", "//operator <=操作符函数", "\n    ", "bool", " ", "operator", "<=(", "const", " Complex& c) ", "const", ";\n\n    ", "//友元函数声明以帮助operator<<()函数访问Complex类的私有成员", "\n    ", "friend", " ostream& ", "operator", "<<(ostream& out, ", "const", " Complex& c);\n};\n\n", "//n个复数，按模从小到达排序", "\n", "void", " ", "bubble_sort", "(Complex[],", "int", " n)", ";\n\n", "\n", "bubble_sort函数按冒泡排序的算法对n个复数按模从小到大的顺序排序。", "\n", "裁判测试程序样例：", "在这里给出函数被调用进行测试的例子：", "\n", "int", " ", "main", "(", ")", " {\n    ", "double", " dReal1, dImag1, dReal2, dImag2;\n\n    ", "int", " mode;\n    cin>>mode;\n    cin>>dReal1>>dImag1>>dReal2>>dImag2;\n    ", "Complex ", "c1", "(", "dReal1, dImag1", ")", ";\n    ", "Complex ", "c2", "(", "dReal2, dImag2", ")", ";\n    Complex c[", "6", "] = {c1,c2,c1+c2,c1-c2,c1*c2,c1/c2};\n    ", "switch", "(mode)\n    {\n        ", "case", " ", "1", ": cout << c[", "0", "]<<", "\" \"", "<<c[", "1", "];", "break", ";\n        ", "case", " ", "2", ": cout << c[", "2", "];", "break", ";\n        ", "case", " ", "3", ": cout << c[", "3", "];", "break", ";\n        ", "case", " ", "4", ": cout << c[", "4", "];", "break", ";\n        ", "case", " ", "5", ": cout << c[", "5", "];", "break", ";\n        ", "case", " ", "6", ": bubble_sort(c,", "6", ");\n                ", "for", "(", "int", " i=", "0", ";i<", "6", ";i++)\n                    cout<<c[i]<<", "\" \"", ";\n\n    }\n\n    ", "return", " ", "0", ";\n}\n", "/* 请在这里填写答案 */", "\n\n", "\n", "我的答案如下：", "\n", "\n", "#include<math.h>", "\nComplex::Complex(", "double", " r,", "double", " i)\n{\n    ", "real", "=r;\n    imag=i;\n } \nComplex Complex::", "operator", "+(const Complex &c) const\n{\n    Complex c1;\n    c1.real=", "real", "+c.real;\n    c1.imag=imag+c.imag;\n    ", "return", " c1;\n }\nComplex Complex::", "operator", "-(const Complex &c) const\n{\n    Complex c1;\n    c1.real=", "real", "-c.real;\n    c1.imag=imag-c.imag;\n    ", "return", " c1;\n  } \nComplex Complex::", "operator", "=(const Complex &c)\n{\n    Complex c1;\n    c1.real=", "real", "*c.real;\n    c1.imag=imag*c.imag;\n    ", "return", " c1;\n  }\nComplex Complex::", "operator", "/(const Complex &c) const\n{\n    Complex c1;\n    c1.real=(", "real", "*c.real+imag*c.imag)/(c.imag*c.imag+c.real*c.real);\n    c1.imag=(imag*c.real-", "real", "*c.imag)/(c.imag*c.imag+c.real*c.real);\n    ", "return", " c1;\n  } \nComplex Complex::", "operator", "*(const Complex &c) const\n{\n    Complex c1;\n    c1.real=", "real", "*c.real-imag*c.imag;\n    c1.imag=", "real", "*c.imag+imag*c.real;\n    ", "return", " c1;\n  }\nostream& ", "operator", "<<(ostream& ", "out", ", const Complex& c)\n{\n    ", "if", "(c.imag>", "0", ")\n        ", "out", "<<c.real<<\"+\"<<c.imag<<\"i\";\n    ", "else", "\n        ", "out", "<<c.real<<\"+\"<<c.imag;\n    ", "return", " ", "out", ";        \n}\n\n", "double", " distance(", "double", " r,", "double", " i)\n{\n    ", "return", " sqrt(pow(r,", "2", ")+pow(i,", "2", "));\n}\n", "bool", " Complex::", "operator", "<=(const Complex &c) const\n{\n    ", "double", " a,b;\n    a=distance(", "real", ",imag);\n    b=distance(c.real,c.imag);\n    ", "if", "(a<=b) ", "return", " ", "true", ";\n    ", "else", " ", "return", " ", "false", ";\n } \n//n个复数，按模从小到达排序\n", "void", " bubble_sort(Complex D[],", "int", " n)\n{\n    ", "int", " i,j;\n    ", "for", "(i=", "1", ";i<n;i++)\n    {\n        ", "for", "(j=", "0", ";j<n-i;j++)\n        {\n            ", "if", "(!(D[j]<=D[j+", "1", "]))\n            {\n                Complex ", "temp", "=D[j];\n                D[j]=D[j+", "1", "];\n                D[j+", "1", "]=", "temp", ";\n            }\n        }\n      } \n}\n", "\n", "在输入", "\n", "6", "\n", "1 ", "2", " ", "3", " ", "4", "\n", "\n", "这个例子的时候答案始终不对，输出是错的", "\n", "\n", "请问为什么啊？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The expression &lt;a href=\"https://golang.org/ref/spec#Conversions\" rel=\"nofollow noreferrer\"&gt;converts&lt;/a&gt; &lt;code&gt;fi&lt;/code&gt; to an &lt;code&gt;*int&lt;/code&gt;.  The result contains the same address, but has a different type.&lt;/p&gt;\n\n&lt;p&gt;If a &lt;code&gt;*FlexInt&lt;/code&gt; is passed to &lt;code&gt;json.Unmarshal&lt;/code&gt;, then &lt;code&gt;json.Unmarshal&lt;/code&gt; will call the &lt;code&gt;*FlexInt.UnmarshalJSON&lt;/code&gt; method which calls &lt;code&gt;json.Unmarshal&lt;/code&gt; and so on.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "赋值运算符", "Question": ["Golang地址运算符和（* int）（Type）语法", ["\n\n", "Starting to play around with ", "golang", " and was looking at a custom ", "json.Unmarshal", ". In a blog post the had the following:", "\n\n", "type FlexInt int\n\nfunc (fi *FlexInt) UnmarshalJSON(data []byte) error {\n    if data[0] != '\"' {\n        return json.Unmarshal(data, (*int)(fi))\n    }\n    var s string\n    if err := json.Unmarshal(data, &s); err != nil {\n        return err\n    }\n    i, err := strconv.Atoi(s)\n    if err != nil {\n        return err\n    }\n    *fi = FlexInt(i)\n    return nil\n}\n", "\n\n", "And I understand what it is doing - but I dont understand ", "(*int)(fi)", " part. Looking at the value of the ", "fi", " pointer it is the same as ", "(*int)(fi)", " - ", "(*int)(fi) == fi", ". Yet when I change that line to simply ", "fi", " it then does an infinite loop", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、a&lt;br /&gt;2、7.000000&lt;br /&gt;3、运算符类型对应表达式的类型。&lt;br /&gt;4、%&lt;br /&gt;5、不对&lt;br /&gt;6、&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;&lt;span class=\"hljs-bullet\"&gt;*&lt;/span&gt;\n&lt;span class=\"hljs-strong\"&gt;**\n**&lt;/span&gt;&lt;span class=\"hljs-emphasis\"&gt;*\n&lt;span class=\"hljs-strong\"&gt;****&lt;/span&gt;\n&lt;span class=\"hljs-strong\"&gt;****&lt;/span&gt;*&lt;/span&gt;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;7、2,1&lt;br /&gt;8、&amp;#34;%d\\n&amp;#34;  &amp;#34;%d\\n&amp;#34;&lt;br /&gt;9、不能编译通过&amp;#xff0c;原因是printf语句后面缺少分号。&lt;br /&gt;10、&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a,b,c,max;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d%d%d&amp;#34;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;c);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a&amp;lt;b) {\n        max&amp;#61;b;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;  {\n        max&amp;#61;a;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(a&amp;lt;c) {\n        max&amp;#61;c;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        max&amp;#61;a;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(b&amp;lt;c) {\n        max&amp;#61;c;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        max&amp;#61;c;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,max);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;11、&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, b &amp;#61; &lt;span class=\"hljs-number\"&gt;40&lt;/span&gt;, c &amp;#61; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;, t &amp;#61; a;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t &amp;lt; b)\n    {\n        t&amp;#61;b;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ( t&amp;lt;c)\n    {\n        t &amp;#61; c;\n\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d %d中的最大数是 %d\\n&amp;#34;&lt;/span&gt;, a, b, c, t);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["想知道这些题的正确答案", ["1题", "以下程序的输出结果是（   ）。", "\n", "#include <stdio.h>", "\n", "int main()", "\n", "{", "\n", "char c='z';", "\n", "printf(\"%c\", c-25);", "\n", "return 0;", "\n", "}", "2题", "若t已经定义为double类型，则经过表达式t = 1;t++;运算后，表达式t+5的值为（ ）。", "7", "7.000000", "2.000000", "2", "\n", "3题", "下列关于表达式的描述中，错误的是（ ）。", "常量和变量都是表达式。", "运算符类型对应表达式的类型。", "每一个表达式都有自己的值。", "表达式必须以分号结尾。", "\n", "4题", "在以下一组运算符中，优先级最高的运算符是（   ）。", "<=", "=", "%", "&&", "\n", "5题", "若有定义int x = 1,y = 2;则表达式x==y是将y的值赋值给x。", "对吗", "\n", "6题", "请阅读下面的程序，分析运行结果。", "#include <stdio.h>", "\n", "int main()", "{", "\n", "printf(\"*\\n\");", "\n", "printf(\"**\\n\");", "\n", "printf(\"***\\n\");", "\n", "printf(\"****\\n\");", "\n", "printf(\"*****\\n\");", "\n", "return 0;", "}", "\n", "7题", "请阅读下面的程序，分析程序是否能编绎通过并正确运行，如果不能，说明原因；如果能，请写出运行结果。", "#include <stdio.h>", "\n", "void main()", "\n", "{", "\n", "int a, b, d = 241; ", "\n", "a=d/100%9; ", "\n", "b=(-1)&&(-1); ", "\n", "printf(\"%d,%d\", a, b);", "\n", "return  0;", "}", "\n", "8题", "请阅读下面的程序，在空白处填写正确的代码,要求输出m和n的值，且每行从头开始。", "void  main()", "{", "int m = 10, n = 20;", "printf(      ,m);", "printf(      ,n);", "}", "\n", "9题", "请阅读下面的程序，分析代码是否能够编译通过，如果能编译通过，请列出运行的结果，否则请说明编译失败的原因。", "#include <stdio.h>", "\n", "int main()", "\n", "{", "\n", "int k = -3;", "\n", "if (k <= 0)", "\n", "printf(\"####\")", "\n", "else", "\n", "printf(\"&&&&\")", "\n", "}", "\n", "10题", "从键盘输入三个数a,b,c，判断其中的最大值并输出。", "提示：", "1） 从键盘输入数据，调用scanf()函数", "2） 用if..else if..else语句判断三个数的最大值", "\n", "11题", "请阅读下面的程序，在横线处填写正确的代码，输出三个整数中最大的整数。", "#include <stdio.h>", "\n", "int main()", "{", "\n", "int a = 10, b = 40, c = 20, t = a;", "\n", "if (t < b)", "\n", "{", "\n", "            ", ";", "\n", "\n", "}", "\n", "if (                )", "\n", "{", "\n", "t = c;", "\n", "}", "\n", "printf(\"%d %d %d中的最大数是 %d\\n\", a, b, c, t);", "\n", "return 0;", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;解决了&amp;#xff0c;没有导入iostream&amp;#xff0c;&amp;#xff0c;&amp;#xff0c;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["c++ 输出<<重载，实现对象输出发生问题", ["自己利用C++类实现python的整型对象", "但是一直报错", "二元“<<”: 没有找到接受“PyInt::PyIntCell”类型的右操作数的运算符(或没有可接受的转换)", "不理解这个报错什么意思", "\n", "\n", "PyInt.h", "\n", "\n", "#", "pragma", " once", "\n", "#", "include", " ", "<string>", "\n\n", "class", " ", "PyInt", " {\n", "private", ":\n\n    ", "//数组元素单位为long long", "\n    ", "typedef", " ", "long", " ", "long", " PyIntCell;\n\n    ", "//指向长整型数组的指针", "\n    PyIntCell* pPyIntArr;\n\n    ", "//数组长度", "\n    ", "int", " PyIntArrLength = ", "0", ";\n\n    ", "//是否为负数", "\n    ", "bool", " isNegative = ", "0", ";\n", "public", ":\n    ", "//构造函数", "\n    ", "PyInt", "();\n\n    ", "//析构函数", "\n    ~", "PyInt", "();\n\n    ", "//将字符串赋值给PyInt类型", "\n    ", "const", " PyInt& ", "operator", " = (", "const", " std::string& _cpp_string);\n\n    ", "//将整数赋值给PyInt类型", "\n    ", "const", " PyInt& ", "operator", " = (", "const", " ", "int", "& _cpp_ll_int);\n\n    ", "//将PyInt类型赋值给PyInt类型", "\n    ", "const", " PyInt& ", "operator", " = (", "const", " PyInt& _py_int);\n\n    ", "//将PyInt类型输出", "\n    ", "friend", " std::ostream& ", "operator", " << (std::ostream& out,", "const", " PyInt& _py_int);\n\n    ", "//将PyInt类型输入", "\n    ", "friend", " std::istream& ", "operator", " >> (", "const", " std::istream& in, PyInt& _py_int);\n};\n", "\n", "\n", "PyInt.cpp", "\n", "\n", "#include ", "\"PyInt.h\"", "\n\nPyInt::PyInt() {\n    pPyIntArr = new PyIntCell[", "1", "];\n    pPyIntArr[", "0", "] = ", "0", ";\n}\n\nPyInt::~PyInt() {\n    ", "if", " (pPyIntArr == NULL)\n        ", "return", ";\n    delete[] pPyIntArr;\n}\n\n", "const", " PyInt& PyInt::", "operator", "=(", "const", " PyInt& _py_int) {\n    ", "if", "(pPyIntArr!=nullptr)\n        delete[] pPyIntArr;\n    ", "this", "->pPyIntArr = new PyIntCell[PyIntArrLength];\n    ", "for", " (int Floop = ", "0", "; Floop < PyIntArrLength; Floop++) {\n        ", "this", "->pPyIntArr[Floop] = _py_int.pPyIntArr[Floop];\n    }\n    ", "this", "->PyIntArrLength = _py_int.PyIntArrLength;\n    ", "this", "->isNegative = _py_int.isNegative;\n    ", "return", " *", "this", ";\n}\n\n", "const", " PyInt& PyInt::", "operator", "=(", "const", " int& _cpp_int) {\n    ", "if", "(pPyIntArr!=nullptr)\n        delete[] pPyIntArr;\n    ", "this", "->pPyIntArr = new PyIntCell[", "1", "];\n    ", "this", "->pPyIntArr[", "0", "] = _cpp_int;\n    ", "this", "->PyIntArrLength = ", "1", ";\n    ", "if", " (_cpp_int < ", "0", ")\n        ", "this", "->isNegative = ", "false", ";\n    ", "else", "\n        ", "this", "->isNegative = ", "true", ";\n    ", "return", " *", "this", ";\n}\n\n", "const", " PyInt& PyInt::", "operator", "=(", "const", " std::string& _cpp_string) {\n    ", "if", " (pPyIntArr != nullptr)\n        delete[] pPyIntArr;\n    int iStringLength = _cpp_string.length();\n    int Rloop = ", "0", ";\n    int PyArrPos = ", "0", ";\n    int StrStartLoop = iStringLength - ", "1", ";\n    int StrEndLoop;\n    ", "this", "->PyIntArrLength = iStringLength / ", "18", " + ", "1", ";\n    ", "this", "->pPyIntArr = new PyIntCell[PyIntArrLength];\n    \n    ", "if", " (_cpp_string[", "0", "] == ", "'-'", ") {\n        ", "this", "->isNegative = ", "true", ";\n        StrEndLoop = ", "1", ";\n    }\n    ", "else", " {\n        ", "this", "->isNegative = ", "false", ";\n        StrEndLoop = ", "0", ";\n    }\n    ", "for", " (int FLoop = ", "0", "; FLoop < PyIntArrLength; FLoop++) {\n        ", "this", "->pPyIntArr[FLoop] = ", "0", ";\n    }\n    ", "for", " (; StrStartLoop >= StrEndLoop; StrStartLoop--) {\n        ", "this", "->pPyIntArr[PyArrPos] += (_cpp_string[StrStartLoop] - ", "48", ") * pow(", "10", ", Rloop);\n        Rloop == ", "18", " ? Rloop = ", "0", ", PyArrPos++ : Rloop++;\n    }\n    ", "return", " *", "this", ";\n}\n\nstd::ostream& ", "operator", " << (std::ostream& ", "out", ",", "const", " PyInt& _py_int) {\n    ", "for", " (int Floop = _py_int.PyIntArrLength - ", "1", "; Floop >= ", "0", "; Floop--) {\n        ", "out", " << _py_int.pPyIntArr[Floop];", "//*****这里报错******", "\n    }\n    ", "return", " ", "out", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;写法有问题&amp;#xff0c;以Add函数和Sub函数为例&amp;#xff0c;修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;void Add() //加法运算函数\n{\n    user.nAdd&amp;#43;&amp;#43;;\n    rational num1,num2,sum,Zero(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;加法计算\\n&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;最少输入两个数,并且以-1结束\\n&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    sum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;第&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;个数:&amp;#34;&lt;/span&gt;;\n        cin &amp;gt;&amp;gt; num1;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(num1&amp;#61;&amp;#61;-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        sum&amp;#61;sum&amp;#43;num1;\n        \n        i&amp;#43;&amp;#43;;\n    }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;加法结果是:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;请按任意键继续\\n&amp;#34;&lt;/span&gt;;\n    cout.flush();\n    cin.get();\n    cin.get();\n}\n\n\nvoid Sub() //减法函数\n{\n    user.nSub&amp;#43;&amp;#43;;\n    rational num1,num2,&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;sub&lt;/span&gt;,&lt;span class=\"hljs-title\"&gt;Zero&lt;/span&gt;&lt;/span&gt;(0,0);\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;最少输入两个数&amp;#xff0c;并且以-1结束\\n&amp;#34;&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;第1个数:&amp;#34;&lt;/span&gt;;\n    cin&amp;gt;&amp;gt;num1;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;sub&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-title\"&gt;num1&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;第&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;个数:&amp;#34;&lt;/span&gt;;\n        cin&amp;gt;&amp;gt;num1;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(num1&amp;#61;&amp;#61;-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;sub&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-title\"&gt;sub&lt;/span&gt;-&lt;span class=\"hljs-title\"&gt;num1&lt;/span&gt;&lt;/span&gt;;\n        i&amp;#43;&amp;#43;;\n        \n    }\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;减法结果是:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;sub&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-title\"&gt;endl&lt;/span&gt;&lt;/span&gt;;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;请按任意键继续\\n&amp;#34;&lt;/span&gt;;\n    cout.flush();\n    cin.get();\n    cin.get();\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["分数计算器实现 bug多想知道怎么改", ["主要问题还挺大的 ：", "1.答案中没有约分", "2.计算过程 加减乘除 我想输入-1停止但是实现不了 会一直循环下去", "\n", "/*（1）为有理数定义一个Rational类。有理数可以表示成为两个相除的整数，如3/4、13/3等。将有理数表示成int类型的两个值相除，分别表示分子和分母；\n（2）通过接收从键盘输入a/b形式的分数生成有理数类的对象，在程序中可以识别出分子和分母并正确赋值;（要判断分母是否为0）；\n（3）采用运算符重载方法定义有理数的加、减、乘、除运算；（需要判断除数是否为0）\n（4）设计有理数计算器测试程序，采用由计算机随机出题（用随机数），用户答题的形式，对有理数的加法、减法、乘法和除法进行测试。\n（5）（选做题）设计记录功能，可以记录下不同用户使用计算器的情况，记录以文件形式保存。程序运行时要求输入用户名，显示该用户以前的记录。用户记录包括：做了多少次加法、减法、乘法和除法，进行测试的次数，测试的平均分等，在退出计算器程序时用新的用户记录代替原有记录。*/", "\n", "#", "include", " ", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "struct", " ", "User", " ", "//用户结构体类型定义", "\n{\n   ", "char", " szName[", "20", "]; ", "//用户名", "\n   ", "int", " nTime; ", "//使用次数", "\n   ", "int", " nTest; ", "//测试次数", "\n   ", "double", " alAve; ", "//平均成绩", "\n   ", "int", " nAdd; ", "//加法次数", "\n   ", "int", " nSub; ", "//减法次数", "\n   ", "int", " nMul; ", "//乘法次数", "\n   ", "double", " dlScore[", "3", "]; ", "//3次测试得分", "\n}user;\n", "class", " ", "rational", "  \n{\n", "public", ":\n    ", "void", " ", "print", "()", ";                    ", "//输出函数", "\n    ", "rational", "(", "int", " x=", "0", ",", "int", " y=", "0", ");\n    ", "virtual", " ~", "rational", "();\n    ", "void", " ", "optimization", "()", ";            ", "//优化有理数函数", "\n    ", "friend", " rational ", "operator", " + (rational num1,rational num2);    ", "//重载运算符+", "\n    ", "friend", " rational ", "operator", " - (rational num1,rational num2);    ", "//重载运算符-", "\n    ", "friend", " rational ", "operator", " * (rational num1,rational num2);    ", "//重载运算符*", "\n    ", "friend", " rational ", "operator", " / (rational num1,rational num2);    ", "//重载运算符/", "\n    ", "friend", " istream& ", "operator", ">>(istream& is, rational& r);", "//重载流输入 ", "\n    ", "friend", " ostream& ", "operator", "<<(ostream& os, rational& r);", "//重载流输出 ", "\n    ", "friend", " ", "bool", " ", "operator", " ==(rational num1,rational num2);        ", "//重载运算符==", "\n    ", "friend", " ", "double", " ", "real", "(rational x)", ";                            ", "//声明转换函数", "\n", "private", ":\n\n    ", "int", " denominator;                ", "//分母", "\n    ", "int", " numerator;                    ", "//分子", "\n};\nrational::", "rational", "(", "int", " x,", "int", " y)\n{\n    numerator= x;\n    denominator= y;\n    ", "optimization", "();            ", "//有理数优化", "\n}\n\nrational::~", "rational", "()\n{\n}\n", "void", " ", "rational::print", "()", "\n", "{\n    cout<<numerator;\n    ", "if", "(numerator!=", "0", " && denominator!=", "1", ")\n        cout<<", "\"/\"", "<<denominator<<", "\"\\n\"", ";\n    ", "else", "\n        cout<<", "\"\\n\"", ";\n}\n", "void", " ", "rational::optimization", "()", "\n", "{\n    ", "int", " gcd;\n    ", "int", " i=", "1", ";\n    ", "if", "(numerator==", "0", ")        ", "//如果分子为零，则分母为1后返回", "\n    {\n        denominator= ", "1", ";\n        ", "return", ";\n    }\n    ", "//取分子分母中较小的数作为公约数极限", "\n    gcd= (", "abs", "(numerator)>", "abs", "(denominator))?", "abs", "(numerator):", "abs", "(denominator);\n    ", "if", "(gcd==", "0", ")\n        ", "return", ";                ", "//若为0，则返回", "\n    ", "for", "(", "int", " i=gcd;i>", "1", ";i--)        ", "//用循环找最大公约数", "\n        ", "if", "((numerator%i==", "0", ")&& (denominator%i==", "0", "))\n            ", "break", ";\n    numerator/=i;            ", "//i为最大公约数，将分子分母整除它，重新赋值", "\n    denominator/=i;\n    ", "//若分子分母均为负数，则结果为正", "\n    ", "if", "(numerator<", "0", " && denominator<", "0", ")\n    {\n        numerator= -numerator;\n        denominator= -denominator;\n    }\n    ", "//若分子分母只有一个为负数，则调整为分子取负，分母取正", "\n    ", "else", " ", "if", "(numerator<", "0", " || denominator<", "0", ")\n    {\n        numerator= -", "abs", "(numerator);\n        denominator=", "abs", "(denominator);\n    }\n}\nrational ", "operator", " + (rational num1,rational num2)\n{\n    rational temp;\n    temp.denominator =num1.denominator *num2.denominator ;\n    temp.numerator = num1.numerator *num2.denominator +num1.denominator *num2.numerator ;\n    temp.", "optimization", " ();\n    ", "return", "  temp;\n}\nrational ", "operator", " - (rational num1,rational num2)\n{\n    rational temp;\n    temp.denominator =num1.denominator *num2.denominator ;\n    temp.numerator = num1.numerator *num2.denominator -num1.denominator *num2.numerator ;\n    temp.", "optimization", " ();\n    ", "return", "  temp;\n}    \nrational ", "operator", " * (rational num1,rational num2)\n{\n    rational  temp;\n    temp.denominator =num1.denominator *num2.denominator ;\n    temp.numerator = num1.numerator *num2.numerator ;\n    temp.", "optimization", " ();\n    ", "return", " temp;\n}\n\nrational ", "operator", " / (rational num1,rational num2)\n{\n    rational temp;\n    temp.denominator =num1.denominator *num2.numerator  ;\n    temp.numerator = num1.numerator *num2.denominator ;\n    temp.", "optimization", " ();\n    ", "return", " temp;\n}\n\n", "bool", " ", "operator", " ==(rational num1,rational num2)\n{\n    ", "if", "(num1.numerator ==num2.numerator && num1.denominator ==num2.denominator )\n        ", "return", " ", "true", ";\n    ", "else", "\n        ", "return", " ", "false", ";\n}        \nistream& ", "operator", ">>(istream& is, rational& r) {\n    is >> r.numerator >> r.denominator;\n    ", "if", " (r.denominator != ", "0", ") {\n        ", "return", " is;\n    }\n    ", "else", " {\n        cout << ", "\"The denominator is 0, which is illegal. Please try again!\"", " << endl;\n        ", "exit", "(", "0", ");\n    }\n}\nostream& ", "operator", "<<(ostream& os, rational& r) {\n    ", "if", " (r.numerator % r.denominator == ", "0", ") {\n        os << r.numerator / r.denominator << endl;\n        ", "return", " os;\n    }\n    ", "else", "\n        os << r.numerator << ", "\"\\\\\"", " << r.denominator;\n    ", "return", " os;\n}\n", "double", " ", "real", "(rational x)", "\n", "{\n    ", "return", "(", "double", "(x.numerator)/", "double", "(x.denominator));\n}    \n", "void", " ", "Test", "()", " ", "//测试函数", "\n", "{\n   user.nTest++;\n   cout<<", "\"共10道题，做100以内的加减运算，满分100分:\\n\"", ";\n   ", "double", " real1,real2,image1,image2,real3,real4,image3,image4;\n   rational answer,temp;\n   ", "int", " score=", "0", ";\n   ", "char", " op;\n   ", "for", "(", "int", " i=", "0", ";i<=", "9", ";i++)\n{\n    ", "int", " m1 = ", "rand", "() % ", "100", " + ", "1", "; ", "//生成1-100的随机数", "\n    ", "int", " n1 = ", "rand", "() % ", "100", " + ", "1", ";\n    ", "int", " m2 = ", "rand", "() % ", "100", " + ", "1", ";\n    ", "int", " n2 = ", "rand", "() % ", "100", " + ", "1", ";\n    ", "rational ", "a", "(m1,n1)", ",", "b", "(m2,n2)", ";\n    ", "int", " m3=", "rand", "()%", "20", "-10", ";\n    ", "int", " n3=", "rand", "()%", "20", "-10", ";\n    ", "int", " m4=", "rand", "()%", "20", "-10", ";\n    ", "int", " n4=", "rand", "()%", "20", "-10", ";\n    ", "rational ", "c", "(m3,n3)", ",", "d", "(m4,n4)", ";\n    op=", "rand", "()%", "4", "; ", "//产生随机加减乘除运算的三个值", "\n    ", "switch", "(op)\n {\n    ", "case", " ", "0", ":\n    answer=a+b;\n    cout<<a<<", "\"加上\"", "<<b<<", "\"等于\"", ";\n    ", "break", ";\n    ", "case", " ", "1", ":\n    cout<<a<<", "\"减去\"", "<<b<<", "\"等于\"", ";\n    ", "break", ";\n    ", "case", " ", "2", ":\n    answer=c*d;\n    cout<<c<<", "\"乘以\"", "<<d<<", "\"等于\"", ";\n   ", "break", ";\n}\ncin>>temp; ", "//输入用户计算值", "\n", "if", "(answer==temp) ", "//比较用户计算值", "\n{\nscore+=", "10", ";\n}\n", "else", "\n{\ncout<<", "\"此题做错了\\n\"", ";\ncout<<", "\"正确答案为:\"", "<<answer<<endl;\n}\n}\ncout<<", "\"你的最后得分是:\"", "<<score<<endl;\n", "if", "(user.nTest<=", "3", ")\n{\nuser.alAve=", "0", ";\nuser.dlScore[user.nTest", "-1", "]=score;\n", "for", "(", "int", " i=", "0", ";i<user.nTest;i++)\nuser.alAve+=user.dlScore[i];\nuser.alAve=user.alAve/user.nTest;\n}\n", "else", "\n{\nuser.dlScore[", "0", "]=user.dlScore[", "1", "];\nuser.dlScore[", "1", "]=user.dlScore[", "2", "];\nuser.dlScore[", "2", "]=score;\n", "for", "(", "int", " i=", "0", ";i<", "3", ";i++){\nuser.alAve=", "0", ";\nuser.alAve+=user.dlScore[i];\nuser.alAve=user.alAve/", "3", ";\n}\ncout<<", "\"请按任意键继续\\n\"", ";\ncout.", "flush", "();\ncin.", "get", "();\ncin.", "get", "();\n}\n}\n", "void", " ", "Add", "()", " ", "//加法运算函数", "\n", "{\n   user.nAdd++;\n   rational num1,num2,sum,", "Zero", "(", "0", ",", "0", ");\n   cout<<", "\"加法计算\\n\"", "<<", "\"最少输入两个数,并且以-1结束\\n\"", ";\n   cout<<", "\"第一个数:\"", ";\n   cin>>num1;\n   cout<<", "\"第二个数:\"", ";\n   cin>>num2;\n   sum=num1+num2;\n   cout<<", "\"第三个数:\"", ";\n   cin>>num1;\n   ", "int", " i=", "4", ";\n   ", "while", "(", "1", ")\n{\n   sum=sum+num1;\n   cout<<", "\"第\"", "<<i<<", "\"个数:\"", ";\n   cin>>num1;\n   i++;\n   ", "if", "(num1==", "-1", ")\n   ", "break", ";\n}\ncout<<", "\"加法结果是:\"", "<<sum<<endl;\ncout<<", "\"请按任意键继续\\n\"", ";\ncout.", "flush", "();\ncin.", "get", "();\ncin.", "get", "();\n}\n", "void", " ", "Sub", "()", " ", "//减法函数", "\n", "{\n  user.nSub++;\n  rational num1,num2,sub,", "Zero", "(", "0", ",", "0", ");\n  cout<<", "\"最少输入两个数，并且以-1结束\\n\"", ";\n  cout<<", "\"第1个数:\"", ";\n  cin>>num1;\n  cout<<", "\"第2个数:\"", ";\n  cin>>num2;\n  sub=num1-num2;\n  cout<<", "\"第3个数:\"", ";\n  cin>>num1;\n  ", "int", " i=", "4", ";\n   ", "while", "(", "1", ")\n{\nsub=sub-num1;\ncout<<", "\"第\"", "<<i<<", "\"个数:\"", ";\ncin>>num1;\ni++;\n", "if", "(num1==", "-1", ")\n", "break", ";\n}\ncout<<", "\"减法结果是:\"", "<<sub<<endl;\ncout<<", "\"请按任意键继续\\n\"", ";\ncout.", "flush", "();\ncin.", "get", "();\ncin.", "get", "();\n}\n", "void", " ", "Mul", "()", " ", "//乘积函数", "\n", "{\n   user.nMul++;\n   rational num1,num2,mul,", "Zero", "(", "0", ",", "0", ");\n   cout<<", "\"乘法计算\\n\"", "<<", "\"最少输入两数,并且以-1结束\\n\"", ";\n   cout<<", "\"第一个数:\"", ";\n   cin>>num1;\n   cout<<", "\"第二个数:\"", ";\n   cin>>num2;\n   mul=num1*num2;\n   cout<<", "\"第三个数:\"", ";\n   cin>>num1;\n   ", "int", " i=", "4", ";\n  ", "while", "(", "1", ")\n  {\n    num1=mul*num1;\n    cout<<", "\"第\"", "<<i<<", "\"个数:\"", ";\n    cin>>num1;\n    i++;\n    ", "if", "(num1==", "-1", ")\n    ", "break", ";\n}\n  cout<<", "\"乘法结果是:\"", "<<mul<<endl;\n  cout<<", "\"请按任意键继续\\n\"", ";\n  cout.", "flush", "();\n  cin.", "get", "();\n  cin.", "get", "();\n}\n", "void", " ", "userprint", "()", " ", "//输出用户信息函数", "\n", "{\n  cout<<user.szName<<", "\"使用的次数为:\"", "<<user.nTime<<endl;\n  cout<<", "\"其中:\\t加法的次数:\"", "<<user.nAdd<<", "\"\\t减法的次数:\"", "<<user.nSub<<", "\"\\t乘法的次数:\"", "<<user.nMul<<endl;\n  cout<<", "\"\\t测试次数:\"", "<<user.nTest<<", "\"\\t平均成绩:\"", "<<user.alAve<<endl;\n}\n", "void", " ", "Login", "()", " ", "//当前用户信息函数", "\n", "{\n    ", "char", " szName[", "20", "];\n    cout << ", "\"请输入您的姓名:\"", ";\n    cin.", "getline", "(szName, ", "20", ");\n    ifstream infile;\n    User user1;\n    infile.", "open", "(", "\"user.dat\"", ", ios::binary | ios::in);\n    ", "if", " (!infile)\n    {\n        cout << ", "\"没有原始记录文件，您是第一个用户!\\n\"", ";\n        ", "strcpy", "(user.szName, szName);\n        user.nTest++;\n        ", "return", ";\n    }\n    infile.", "read", "((", "char", "*)&user1, ", "sizeof", "(User));\n    ", "while", " (!infile.", "eof", "())\n    {\n        ", "if", " (", "strcmp", "(user1.szName, szName) == ", "0", ")\n        {\n            user = user1;\n            user.nTime++;\n            cout << ", "\"欢迎您再次使用计算器!\"", ";\n            ", "userprint", "();\n            cin.", "get", "();\n            infile.", "close", "();\n            ", "return", ";\n        }\n        infile.", "read", "((", "char", "*)&user1, ", "sizeof", "(User));\n    }\n    cout << ", "\"欢迎您再次使用计算器!\"", ";\n    ", "strcpy", "(user.szName, szName);\n    user.nTime++;\n    infile.", "close", "();\n    ", "return", ";\n}\n", "void", " ", "SaveFile", "()", " ", "//用户资料保存函数", "\n", "{\n    ", "userprint", "();\n    fstream file;\n    User user1;\n    file.", "open", "(", "\"user.dat\"", ", ios::binary | ios::in | ios::out);\n    ", "if", " (!file)\n    {\n        cout << ", "\"文件打开错误，不能进行更新!\\n\"", ";\n        ", "return", ";\n    }\n    file.", "seekp", "(", "0", ", ios::beg);\n    ", "while", " (!file.", "eof", "())\n    {\n        file.", "read", "((", "char", "*)&user1, ", "sizeof", "(User));\n        ", "if", " (", "strcmp", "(user1.szName, user.szName) == ", "0", ")\n        {\n            file.", "seekp", "(", "-1", " * (", "sizeof", "(User)), ios::cur);\n            file.", "write", "((", "char", "*)&user, ", "sizeof", "(User));\n            file.", "close", "();\n            ", "return", ";\n        }\n    }\n    file.", "close", "();\n    fstream outfile;\n    outfile.", "open", "(", "\"user.dat\"", ", ios::binary | ios::app);\n    outfile.", "write", "((", "char", "*)&user, ", "sizeof", "(User));\n    outfile.", "close", "();\n    ", "return", ";\n}\n\n", "int", " ", "main", "()", "{\n    rational t1,t2;\n    rational c;\n    ", "int", " choise;\n    ", "Login", "(); ", "//当前用户信息函数", "\n    ", "do", "\n    {\n        ", "system", "(", "\"cls\"", ");\n        cout << ", "\"\\t这是一个简单的计算器程序，可以实现以下功能，请按对应的按键(1-5)\\n\\n\\n\"", ";\n        cout << ", "\"\\t=========================MENU===========================\\n\"", ";\n        cout << ", "\"\\t1:有理数加法，以0结束\\n\"", ";\n        cout << ", "\"\\t2:有理数减法，以0结束\\n\"", ";\n        cout << ", "\"\\t3:测试分数加减乘法运算，1次测试10道题\\n\"", ";\n        cout << ", "\"\\t4:有理数乘法，以0结束\\n\"", ";\n        cout << ", "\"\\t5:有理数除法，以0结束\\n\"", ";\n        cout << ", "\"\\t0:退出程序\\n\\n:\"", ";\n        cout << ", "\"\\t请您选择:\"", ";\n        cin >> choise;\n        ", "if", " (choise == ", "1", ")\n        {   \n            ", "Add", "();\n        }\n        ", "else", " ", "if", " (choise == ", "2", ")\n        {   \n            ", "Sub", "();\n        }\n        ", "else", " ", "if", " (choise == ", "3", ")\n        {   \n            ", "Test", "();\n        }\n        ", "else", " ", "if", " (choise == ", "4", ")\n        {   \n            ", "Mul", "();\n        }\n        ", "else", " ", "if", " (choise == ", "5", ")\n        {   cin>>t1;\n            cin>>t2;\n            rational c = t1 / t2;\n            c.", "optimization", "();    \n            c.", "print", "();\n        }\n    \n        ", "else", " ", "if", " (choise == ", "0", ") ", "//用户选0则结束调用函数", "\n        {\n            cout << ", "\"\\n\\n\\t欢迎下次继续使用计算器!\\n\"", ";\n            ", "break", ";\n        }\n        ", "else", "\n        {\n            cout << ", "\"\\n\\t输入错误，请按任意键继续!\\n\"", ";\n        }", "system", "(", "\"pause\"", ");\n    } ", "while", " (", "1", ");\n    ", "SaveFile", "(); ", "//调用用户资料保存函数", "\n    ", "return", " ", "0", ";\n}\n", "\n", "谢谢大家！"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;var Reg &amp;#61; &lt;span class=\"hljs-regexp\"&gt;/^[&amp;#43;-\\d].*?/&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;以&amp;#43;&amp;#xff0c;-或者数字开头的字符串\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!Reg.test(usernamevalue)){&lt;!-- --&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;不是以&amp;#43;&amp;#xff0c;-或者数字开头的字符串就执行\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["javascript编写计算器的小问题", ["问题遇到的现象和发生背景", "用javascript写一个计算器，现在想让输入的第一个值不能为乘号，除号，取余号，但是可以为加号和减号。", "\n", "问题相关代码，请勿粘贴截图", "在这个函数中", "\n", "\n", "<!-- 下面是CSS样式 -->", "\n    ", "<", "style", ">", "\n        ", ".top", "{\n            ", "width", ": ", "465px", ";\n            ", "height", ": ", "60px", ";\n            ", "margin", ": auto;\n            ", "background-color", ": gray;\n            ", "margin-top", ": ", "100px", ";\n            ", "border-top-right-radius", ": ", "10px", ";\n            ", "border-top-left-radius", ": ", "10px", ";\n        }\n\n        ", ".point-red", "{\n            ", "width", ": ", "20px", ";\n            ", "height", ": ", "20px", ";\n            ", "background-color", ": red;\n            ", "float", ": left; ", "/*浮动，可以让其不独占一行*/", "\n            ", "margin-left", ": ", "20px", ";\n            ", "margin-top", ": ", "20px", ";\n            ", "border-radius", ": ", "50%", ";", "/* 通过这个指令将正方形改为一个圆 */", "\n            \n        }\n\n        ", ".point-blue", "{\n            ", "width", ": ", "20px", ";\n            ", "height", ": ", "20px", ";\n            ", "background-color", ": blue;\n            ", "float", ": left; ", "/*浮动，可以让其不独占一行*/", "\n            ", "margin-left", ": ", "20px", ";\n            ", "margin-top", ": ", "20px", ";\n            ", "border-radius", ": ", "50%", ";", "/* 通过这个指令将正方形改为一个圆 */", "\n        }\n\n        ", ".point-green", "{\n            ", "width", ": ", "20px", ";\n            ", "height", ": ", "20px", ";\n            ", "background-color", ": green;\n            ", "float", ": left; ", "/*浮动，可以让其不独占一行*/", "\n            ", "margin-left", ": ", "20px", ";\n            ", "margin-top", ": ", "20px", ";\n            ", "border-radius", ": ", "50%", ";", "/* 通过这个指令将正方形改为一个圆 */", "\n        }\n\n\n        ", "#counter", "{\n            ", "font-size", ": ", "25px", ";\n            ", "color", ": white;\n            ", "float", ": right;\n            ", "line-height", ": ", "60px", ";\n            ", "margin-right", ": ", "35px", ";\n        }\n\n\n        ", "/* 设置显示结果和计算过程的部分 */", "\n        ", "#result", "{\n            ", "width", ": ", "451px", ";\n            ", "height", ": ", "55px", ";\n            ", "border", ": ", "2px", " solid brown;\n            ", "margin", ": auto;\n            ", "text-align", ": right;\n            ", "font-size", ": ", "30px", ";\n            ", "padding-right", ": ", "10px", ";\n            ", "padding-top", ": ", "5px", ";\n        }\n\n        ", "/* 设置按钮区域的样式 */", "\n        ", ".button", "{\n            ", "width", ": ", "465px", ";\n            ", "height", ": ", "413px", ";\n            ", "background-color", ":gray;\n            ", "margin", ": auto;\n            ", "border-bottom-left-radius", ": ", "10px", ";\n            ", "border-bottom-right-radius", ": ", "10px", ";\n            \n        }\n\n        ", ".button", " ", "div", "{\n            ", "width", ": ", "110px", ";\n            ", "height", ": ", "80px", ";\n            ", "float", ": left;\n            ", "background-color", ":aquamarine;\n            ", "border", ": ", "1px", " gray solid;\n            ", "margin-left", ": ", "3.3px", ";\n            ", "text-align", ": center;\n            ", "font-size", ": ", "25px", ";\n            ", "line-height", ": ", "80px", ";\n            ", "font-weight", ": bold;\n        }\n\n        ", "/* 使用伪类，可以产生一个鼠标悬停的效果 */", "\n        ", ".button", " ", "div", ":hover", "{\n            ", "background-color", ": bisque;\n            ", "/* 鼠标放在上面有放大的效果 */", "\n            ", "font-size", ": ", "28px", ";\n            \n        }\n\n        \n    ", "</", "style", ">", "\n", "\n", "\n ", "<!-- 下面是JavaScript代码 -->", "\n    ", "<", "script", " ", "type", "=", "\"text/javascript\"", ">", "\n\n        ", "//解释：在你点击了7那个按钮，就会调用这个函数，定义一个result变量，将整个文件中的class名字为", "\n        ", "//result的值赋给result这个变量，然后再把7赋给result。", "\n        ", "//innerHTML获取HTML当前标签的起始和结束里面的内容", "\n        ", "//给函数传递参数（number），用于输入哪一个数字", "\n    ", "function", " ", "clicknumber", "(", "number", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        ", "//前面那个数加上后面你输入的数（不是相加成和，而是相加为一前一后，就是输入7和8，变成78", "\n        ", "//innerHTML提取出来的是字符串，所以会变成输入的数字变成连接而不是相加", "\n        result.", "innerHTML", " += number; ", "//这里的result是前面那个变量名，给变量名赋值为7", "\n        \n    }\n\n    ", "// 输入运算符", "\n    ", "function", " ", "clickoperator", "(", "operator", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        ", "var", " string = result.", "innerHTML", ";\n        ", "var", " len = string.", "length", "; ", "//用len变量获取string长度", "\n        ", "var", " last = string[len-", "1", "]; ", "//last变量是字符串的最后一个字符", "\n\n\n        ", "if", "(last == ", "\"+\"", " || last ==", "\"-\"", " || last == ", "\"*\"", " || last == ", "\"/\"", " || last == ", "\"%\"", "){\n            ", "//下面的代码是从string的数组下标为0开始往后获取len-1个长度，然后最后一位用新输入的那个运算符代替", "\n            ", "var", " temp = string.", "substr", "(", "0", ",len-", "1", ") + operator; ", "//substr(x,y)，x是数组开始的下标，y是往后获取y个", "\n            result.", "innerHTML", " = temp;\n        }\n        ", "else", "{\n            result.", "innerHTML", " += operator; ", "//如果不是字符那就正常执行", "\n        }\n\n        \n        \n        }\n\n\n    ", "// 计算结果", "\n    ", "//思路，先找到ID名为result的元素赋给result这个变量，然后用innerhtml将元素获取给到中间变量expression", "\n    ", "//最后将结果赋给变量result，我认为最后的innerHTML是替换的作用。", "\n    ", "function", " ", "docalc", "(", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        ", "var", " expression = result.", "innerHTML", ";\n        result.", "innerHTML", " = ", "eval", "(expression);\n       \n    }\n\n    ", "// 清空", "\n    ", "function", " ", "doclear", "(", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        result.", "innerHTML", " = ", "\" \"", ";  ", "//给这个结果赋空值", "\n        \n        ", "//或者可以这么写", "\n        ", "//document.getElementById(\"result\").innerHTML = \" \";", "\n        ", "//最简单的理解，就是将原来里面的东西替换成了空。因为innerhtml有获取的作用也有替换的作用", "\n        ", "//可能有疑问为什么有时候innerhtml放在document那一句的后面，有时候是放在下一行的", "\n        ", "//innerhtml放在哪一行就是获取这一行的标签的里面的元素的", "\n        \n    }\n\n    ", "// 删除，退格,回退删除最后一个字符", "\n    ", "// 要利用数组，在计算器中12345分别的是第01234位", "\n    ", "function", " ", "doback", "(", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        ", "var", " len = result.", "innerHTML", ".", "length", ";", "//取长度，这个字符串有多少位的长度", "\n        ", "// substr(x,y)里面有两个参数，x是从数组的第几位开始，y是往后取多少位。（0,5）意思就是从第一个开始取，一直取五个数字", "\n        result.", "innerHTML", " = result.", "innerHTML", ".", "substr", "(", "0", ",len-", "1", ");\n    }\n\n    ", "//获取字符串最后一个字符，如果是一个运算符，你还想输入一个运算法，那就把这个运算符替换了", "\n    ", "function", " ", "getlastchar", "(", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        ", "var", " string = result.", "innerHTML", ";\n        ", "var", " len = string.", "length", ";\n        ", "var", " last = string[len-", "1", "];\n        ", "if", "(last == ", "\"+\"", " || last ==", "\"-\"", " || last == ", "\"*\"", " || last == ", "\"/\"", " || last == ", "\"%\"", "){\n        }\n    }\n\n\n    ", "// 这个函数是模仿了运算符来写的", "\n    ", "function", " ", "clickpoint", "(", "point", "){\n        ", "var", " result = ", "document", ".", "getElementById", "(", "\"result\"", ");\n        ", "var", " string = result.", "innerHTML", ";\n        ", "var", " len = string.", "length", ";\n        ", "var", " last = string[len-", "1", "];\n        ", "if", "(last == ", "\".\"", "){\n            last = string.", "substr", "(", "0", ",len-", "1", ") + point;\n            result.", "innerHTML", " = last;\n        }\n        ", "else", "{\n            result.", "innerHTML", " += point;\n        }\n    }\n\n    ", "</", "script", ">", "\n", "\n", "<!-- onload元素事件：页面加载完成后则自动执行 -->", "\n", "<", "body", " ", "onload", "=", "\"countertitle()\"", ">", "\n   \n    ", "<", "div", " ", "class", "=", "\"top\"", ">", "   ", "<!-- 这是最上面那个灰色的 -->", "\n        ", "<", "div", " ", "class", "=", "\"point-red\"", ">", "</", "div", ">", "\n        ", "<", "div", " ", "class", "=", "\"point-blue\"", ">", "</", "div", ">", "\n        ", "<", "div", " ", "class", "=", "\"point-green\"", ">", "</", "div", ">", "\n        ", "<", "div", " ", "id", "=", "\"counter\"", ">", "计算器", "</", "div", ">", "\n\n        \n", "</", "div", ">", "\n   \n    ", "<!-- 显示计算结果和计算过程 -->", "\n    ", "<", "div", " ", "id", "=", "\"result\"", ">", "</", "div", ">", "\n\n    ", "<!-- <div name=\"result\">123456</div> 这个没有直接的用处，是为了验证一个命令来写的 -->", "\n\n    ", "<!-- 设置按钮区域 -->", "\n    ", "<", "div", " ", "class", "=", "\"button\"", ">", "\n        ", "<!-- 当元素被单击时，调用countertitle()这个函数，不一定是弹窗啊，只是这个函数正好是弹窗 -->", "\n        ", "<", "div", " ", "onclick", "=", "\"doclear()\"", ">", "AC", "</", "div", ">", "<!--清空-->", "\n        ", "<!--%是一个字符串，所以不能直接写入括号，要用引号包起来，但是外面有双引号了，所以要用单引号-->", "\n        ", "<", "div", " >", "+/-", "</", "div", ">", " \n        ", "<", "div", " ", "onclick", "=", "\"clickoperator('%')\"", ">", "%", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clickoperator('/')\"", ">", "÷", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(1)\"", ">", "1", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(2)\"", ">", "2", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(3)\"", ">", "3", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clickoperator('*')\"", ">", "*", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(4)\"", ">", "4", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(5)\"", ">", "5", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(6)\"", ">", "6", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clickoperator('-')\"", ">", "-", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(7)\"", ">", "7", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(8)\"", ">", "8", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(9)\"", ">", "9", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clickoperator('+')\"", ">", "+", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clicknumber(0)\"", ">", "0", "</", "div", ">", "\n        ", "<!-- 双击时，调用countertitle()这个函数 -->", "\n        ", "<", "div", " ", "onclick", "=", "\"doback()\"", ">", "删除", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"clickpoint('.')\"", ">", ".", "</", "div", ">", "\n        ", "<", "div", " ", "onclick", "=", "\"docalc()\"", ">", "=", "</", "div", ">", "\n    ", "</", "div", ">", "\n\n\n\n", "</", "body", ">", "\n", "</", "html", ">", "\n\n", "\n", "运行结果及报错内容", "没有报错，但是想尽量完善这个计算器", "\n", "我的解答思路和尝试过的方法", "刚开始想在输入数值的函数中进行一个过滤，只要第一个输入不为数值那就不能输出，但是如果这样那加和减也会被过滤掉，于是我选择在运算符的函数中过滤，只要第一个输入为乘除取余就取空值，但是不知道怎么取到第一个值。因为我的代码是将显示的结果里的值全部提出。", "\n", " 我想要达到的结果", "让输入的第一个值不能为乘号，除号，取余号，但是可以为加号和减号。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;应该叫C&amp;#43;&amp;#43;为什么释放对象内存后还能访问类成员函数.&lt;br /&gt;*&lt;br /&gt;因为你的对象内存中只存储一个虚函数表指针, 如果有成员对象则还会存储成员对象.&lt;br /&gt;*&lt;br /&gt;delete只是释放虚函数表指针和成员对象, 所以调用成员对象或虚函数会报错, 但delete没有清除类本身的实现, 所以哪怕指向nullptr的类指针也能调用类成员函数. 当然, 如果这个类成员函数调用类成员对象一样会报错.&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["C++为什么释放内存后还能访问", ["\n", "\n", "\n", "/*\n运行阶段类型识别，为程序在运行阶段确定对象的类型，只适用于包含虚函数的类\n问题引入：基类指针可以指向派生类对象，如何知道基类指针指向的是那个派生类的对象呢？\ndynamic_cast运算符使用指向基类的指针来生成派生类指针，它不能回答“指针指向的是什么类的对象”，但能回答“是否可以安全的将对象的地址赋值给特定类型的指针”\n这个问题\n重点复习：free 和 delete可以一起释放掉后面的连续空间\n*/", "\n\n", "//以下为虚函数复习,dynamic_cast", "\n\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Hero", "\n{\n", "public", ":\n    ", "virtual", " ", "void", " ", "skill1", "()", "\n    ", "{\n        cout << ", "\"英雄释放了1技能\"", " << endl;\n    }\n    \n    ", "virtual", " ", "void", " ", "skill2", "()", "\n    ", "{\n        cout << ", "\"英雄释放了2技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill3", "()", "\n    ", "{\n        cout << ", "\"英雄释放了3技能\"", " << endl;\n    }\n};\n\n", "class", " ", "XS", " : ", "public", " Hero\n{\n", "public", ":\n    ", "virtual", " ", "void", " ", "skill1", "()", "\n    ", "{\n        cout << ", "\"西施释放了1技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill2", "()", "\n    ", "{\n        cout << ", "\"西施释放了2技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill3", "()", "\n    ", "{\n        cout << ", "\"西施释放了3技能\"", " << endl;\n    }\n\n    ", "void", " ", "skill4", "()", "\n    ", "{\n        cout << ", "\"西施释放了4技能\"", " << endl;\n    }\n};\n\n", "class", " ", "LB", " : ", "public", " Hero\n{\n", "public", ":\n    ", "virtual", " ", "void", " ", "skill1", "()", "\n    ", "{\n        cout << ", "\"李白释放了1技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill2", "()", "\n    ", "{\n        cout << ", "\"李白释放了2技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill3", "()", "\n    ", "{\n        cout << ", "\"李白释放了3技能\"", " << endl;\n    }\n};\n\n", "class", " ", "HZ", " : ", "public", " Hero\n{\n", "public", ":\n    ", "virtual", " ", "void", " ", "skill1", "()", "\n    ", "{\n        cout << ", "\"猴子释放了1技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill2", "()", "\n    ", "{\n        cout << ", "\"猴子释放了2技能\"", " << endl;\n    }\n\n    ", "virtual", " ", "void", " ", "skill3", "()", "\n    ", "{\n        cout << ", "\"猴子释放了3技能\"", " << endl;\n    }\n};\n\n", "int", " ", "main", "()", "\n", "{\n    Hero* ptr = ", "nullptr", ";\n    ", "int", " id;\n    cin >> id;\n    ", "switch", " (id)\n    {\n    ", "case", " ", "1", ":\n        ptr = ", "new", " XS;\n        ", "break", ";\n    ", "case", " ", "2", ":\n        ptr = ", "new", " LB;\n        ", "break", ";\n    ", "case", " ", "3", ":\n        ptr = ", "new", " HZ;\n        ", "break", ";\n    ", "default", ":\n        ptr = ", "new", " Hero;\n        ", "break", ";\n    }\n    ptr->", "skill1", "();\n    ptr->", "skill2", "();\n    ptr->", "skill3", "();\n\n    ", "if", " (id == ", "1", ")\n    {\n        XS* xsptr = ", "dynamic_cast", "<XS*>(ptr);\n        xsptr->", "skill4", "();\n        ", "delete", " xsptr;\n        ", "//为什么这里释放掉xsptr后还能调用skill4", "\n        xsptr->", "skill4", "();\n    }\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "漏掉两行代码。btn_c 跟btn_del没有setonclicklistener（）响应。", "Konwledge_Point": "赋值运算符", "Question": ["小菜Android初次做简易计算器，不知道问题出在哪里？", ["del和c按钮  点起来没有反应，但是就是找不出问题在哪~~求指点~~", "\n\n", "代码如下：", "\n\n", " package com.example.calculaterdemo;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.Button;\nimport android.widget.EditText;\n\n\npublic class MainActivity extends Activity implements OnClickListener{\n\n    Button btn_0,btn_1,btn_2,btn_3,btn_4,btn_5,btn_6,btn_7,btn_8,btn_9,btn_jia,btn_jian,btn_cheng,btn_chu,btn_dian,btn_sum;\n    EditText et_input;\n    boolean clear_flag;//清空标识\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        et_input = (EditText)findViewById(R.id.et_input);\n        btn_0 = (Button) findViewById(R.id.btn_0);\n        btn_1 = (Button) findViewById(R.id.btn_1);\n        btn_2 = (Button) findViewById(R.id.btn_2);\n        btn_3 = (Button) findViewById(R.id.btn_3);\n        btn_4 = (Button) findViewById(R.id.btn_4);\n        btn_5 = (Button) findViewById(R.id.btn_5);\n        btn_6 = (Button) findViewById(R.id.btn_6);\n        btn_7 = (Button) findViewById(R.id.btn_7);\n        btn_8 = (Button) findViewById(R.id.btn_8);\n        btn_9 = (Button) findViewById(R.id.btn_9);\n        btn_jia = (Button) findViewById(R.id.btn_jia);\n        btn_jian = (Button) findViewById(R.id.btn_jian);\n        btn_cheng = (Button) findViewById(R.id.btn_cheng);\n        btn_chu = (Button) findViewById(R.id.btn_chu);\n        btn_dian = (Button) findViewById(R.id.btn_dian);\n        btn_sum = (Button) findViewById(R.id.btn_sum);\n\n\n        btn_0.setOnClickListener(this);\n        btn_1.setOnClickListener(this);\n        btn_2.setOnClickListener(this);\n        btn_3.setOnClickListener(this);\n        btn_4.setOnClickListener(this);\n        btn_5.setOnClickListener(this);\n        btn_6.setOnClickListener(this);\n        btn_7.setOnClickListener(this);\n        btn_8.setOnClickListener(this);\n        btn_9.setOnClickListener(this);\n        btn_jia.setOnClickListener(this);\n        btn_jian.setOnClickListener(this);\n        btn_cheng.setOnClickListener(this);\n        btn_chu.setOnClickListener(this);\n        btn_dian.setOnClickListener(this);\n        btn_sum.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        // TODO Auto-generated method stub\n\n        String str = et_input.getText().toString();//取值\n        switch (v.getId()) {\n        case R.id.btn_0:\n        case R.id.btn_1:\n        case R.id.btn_2:\n        case R.id.btn_3:\n        case R.id.btn_4:\n        case R.id.btn_5:\n        case R.id.btn_6:\n        case R.id.btn_7:\n        case R.id.btn_8:\n        case R.id.btn_9:\n        case R.id.btn_dian:\n            if(clear_flag){\n                clear_flag = false;\n                str =\"\";\n                et_input.setText(\"\");\n            }\n            et_input.setText(str+((Button)v).getText());//赋值 \n            break;\n\n        case R.id.btn_jia:\n        case R.id.btn_jian:\n        case R.id.btn_cheng:\n        case R.id.btn_chu:\n            if(clear_flag){\n                clear_flag = false;\n                str =\"\";\n                et_input.setText(\"\");\n            }\n            et_input.setText(str+\" \"+((Button)v).getText()+\" \");\n            break;\n\n        case R.id.btn_c:\n            clear_flag = false; \n            str =\"\";\n            et_input.setText(\"\");\n            break;\n\n        case R.id.btn_del:\n            if(clear_flag){\n                clear_flag = false;\n                str =\"\";\n                et_input.setText(\"\");\n            }else if(str!=null&&!str.equals(\"\")){\n                et_input.setText(str.substring(0,str.length()-1));//把显示框中的内容截取，然后返回的内容为内容长度-1（str.length()-1)\n            }\n            break;\n\n        case R.id.btn_sum:\n            getResult();\n\n            break;\n        default:\n            break;\n        }\n\n    }\n    //返回结果\n    public void getResult(){\n        String exp = et_input.getText().toString();\n        if(exp==null||exp.equals(\"\")){\n            return;\n        }\n        if(!exp.contains(\"\")){\n            return;\n        }\n        if(clear_flag){\n            clear_flag = false;\n            return;\n        }\n        clear_flag = true;\n        double result = 0;\n        String s1 = exp.substring(0,exp.indexOf(\" \"));//运算符前面的字符\n        String op = exp.substring(exp.indexOf(\" \")+1, exp.indexOf(\" \")+2);//运算符\n        String s2 = exp.substring(exp.indexOf(\" \")+3);//运算符后面的字符\n        if(!s1.equals(\"\")&&!s2.equals(\"\")){\n            Double d1 = Double.parseDouble(s1);\n            Double d2 = Double.parseDouble(s2);\n            if(op.equals(\"＋\")){\n                result = d1 + d2;\n            }else if(op.equals(\"－\")){\n                result = d1 - d2;\n            }else if(op.equals(\"×\")){\n                result = d1 * d2;\n            }else if(op.equals(\"÷\")){\n                if(d2==0){\n                    result = 0;\n                }else{\n                    result = d1/d2;\n                }\n            }\n            if(!s1.contains(\".\")&&!s2.contains(\".\")&&!op.equals(\"÷\")){\n                int r = (int)result;\n                et_input.setText(r+\"\");\n            }else{\n                et_input.setText(result+\"\");\n            }\n        }else if(!s1.equals(\"\")&&s2.equals(\"\")){\n            et_input.setText(exp);\n        }else if(s1.equals(\"\")&&!s2.equals(\"\")){\n            Double d2 = Double.parseDouble(s2);\n            if(op.equals(\"＋\")){\n                result = 0 + d2;\n            }else if(op.equals(\"－\")){\n                result = 0 - d2;\n            }else if(op.equals(\"×\")){\n                result = 0 * d2;\n            }else if(op.equals(\"÷\")){\n                    result = 0;\n            }\n            if(!s2.contains(\".\")){\n                int r = (int)result;\n                et_input.setText(r+\"\");\n            }else{\n                et_input.setText(result+\"\");\n            }\n        }else{\n            et_input.setText(\"\");\n        }\n    }\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先看前两个程序都是实现指针指向内存的值的交换，注意第三个交换的是什么。函数参数是双层指针（int **p，p是一个指针变量，指向一个指针，指针指向int类型变量）。所以box指针接收的*p1是指针，交换了*p1和*p2的指向。并没有值的交换。&lt;/p&gt;\n\n&lt;p&gt;你还可以尝试一下：&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;void swap(int **p1,int **p2)&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;{&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;int *box;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;box=p1;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;p1=p2;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;p2=box;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "赋值运算符", "Question": ["一个初学c语言指针的小白的问题：关于两指针指向的交换", ["引子：要写一个函数来交换俩变量a和b的值，可以定义指向a的指针pa，和指向b的指针pb，此时便可以向调用函数中传递地址，函数中的形参根据地址进行运算就可以直接影响实参。", "\n具体实现函数可以为：", "\n\n", "void swap(int *p1,int *p2)", "\n\n", "{", "\n\n", "int box;", "\n\n", "box=*p1;", "\n\n", "*p1=*p2;", "\n\n", "*p2=box;", "\n\n", "}", "\n\n", "运行时，实参pa,pb的值被复制传给形参p1,p2  ", "\n\n", "借助取值运算符“*”，swap函数便可根据形参中的地址直接访问a和b，从而直接交换了俩实参的值。", "\n ", "\n\n", "同理，如果要写一个函数来交换上述两个已被赋值的指针pa和pb的指向（使pa指向b，pb指向a），即交换两个指针变量的值，需要用指针的指针来对指针变量自身的地址进行传递，", "\n按照如上操作方法，实现的函数应该为：", "\n\n", "void swap(int **p1,int **p2)", "\n\n", "{", "\n\n", "int box;", "\n\n", "box=**p1;", "\n\n", "**p1=**p2;", "\n\n", "**p2=box;", "\n\n", "}", "\n\n", "但是如果把函数写为如下，也可以达到交换指针变量pa，pb值的效果：", "\n\n", "void swap(int **p1,int **p2)", "\n\n", "{", "\n\n", "int *box;", "\n\n", "box=*p1;", "\n\n", "*p1=*p2;", "\n\n", "*p2=box;", "\n\n", "}", "\n我的问题来了：", "\n\n", "这个函数操作，难道不是只对形参(*p1)和形参(*p2)进行了值的交换而并未影响到实参吗，但实际上这个函数已经达到目的了，为什么？"]], "Tag": "程序设计"}
{"Answer": "有两个问题：\r\n1. 如果不delete，那么`m_pData`重新赋值后，原先指向的的内存不能被访问，也没有被回收给程序继续使用，相当于你的内存就减小了一块，也就是内存泄漏。\r\n2. 不管是否delete，执行`m_pData = str.m_pData`都是错误的。因为这样，两个指针指向的是同一片地址，例如你执行`str1 = str2`，如果按你的方式来实现，那么以后修改str2中的字符串时，由于str1中的`m_pData`也指向同一片区域，因此str1中的字符串也会被修改。一般来说，这不是我们希望看到的结果。\r\n类似于这样：\r\n```C++\r\nint a = 1, b = 2;\r\na = b;\r\nb = 3;\r\n```\r\n那么我们希望此时a的值等于2，而不是3。如果执行了b = 3之后，a的值也变成了3，那自然是不符合预期的。", "Konwledge_Point": "赋值运算符", "Question": ["C++ 操作符重载的内存释放问题", ["=操作符重载，给复构造函数进行赋值时的代码如下：", "\n\n", "MyString & MyString::operator =(const MyString &str)", "\n{", "\n        if(this == &str)", "\n                return *this;", "\n\n", "    delete []m_pData;    //**???????????????????????????? **\n    m_pData = NULL;\n\n    m_pData = new char(strlen(str.m_pData) + 1);\n    strcpy (m_pData, str.m_pData);\n\n    return *this;\n", "\n\n", "}", "\n\n", "class MyString", "\n{", "\n        public:", "\n                ....", "\n        private:", "\n                char *m_pData;", "\n}", "\n\n", "在函数中为什么还要是对原有的内存进行释放，即delete []m_pData，直接赋值 m_pData = str.m_pData， 这样不行吗？", "\n\n", "请大神指点。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void Set::insert(int x)函数少了一个右大括号&amp;#xff0c;其它问题不少&amp;#xff0c;修改如下&amp;#xff0c;编译通过&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;bits/stdc&amp;#43;&amp;#43;.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;fstream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;    &lt;span class=\"hljs-comment\"&gt;// std::sort&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std; \n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;AbsCollection&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;protected&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *iPtr;        &lt;span class=\"hljs-comment\"&gt;//指向数组的指针&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; last;        &lt;span class=\"hljs-comment\"&gt;//数组最后一个元素的位置&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; maxSize;    &lt;span class=\"hljs-comment\"&gt;//数组总体长度&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;AbsCollection&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size &amp;#61; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;){\n        maxSize &amp;#61; size;\n        iPtr &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;[maxSize];\n        last &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    };\n    &lt;span class=\"hljs-keyword\"&gt;virtual&lt;/span&gt; ~&lt;span class=\"hljs-built_in\"&gt;AbsCollection&lt;/span&gt;() {};\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;OutputSet&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//输出集合中元素&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;AbsCollection::OutputSet&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;The number of elements:&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;last&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;last;i&amp;#43;&amp;#43;)\n    {\n        cout&amp;lt;&amp;lt;iPtr[i]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n    }\n    cout&amp;lt;&amp;lt;endl;\n}\n&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Set&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; AbsCollection\n{\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *fileName; &lt;span class=\"hljs-comment\"&gt;//存放数据的文件&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;Set&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size &amp;#61; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *szFileName&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//从文件读取数据存入数组&amp;#xff08;要判断是否有重复元素&amp;#xff09;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;virtual&lt;/span&gt; ~&lt;span class=\"hljs-built_in\"&gt;Set&lt;/span&gt;();        &lt;span class=\"hljs-comment\"&gt;//析构函数&amp;#xff0c;释放内存并将数据写入文件&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;insert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;    \n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;erase&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;isInSet&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;;     &lt;span class=\"hljs-comment\"&gt;//判断x是否已经存在于集合中&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;friend&lt;/span&gt; ostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; os, Set&amp;amp; s);\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;intersetion&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Set &amp;amp;s)&lt;/span&gt;&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//求集合的交(*this与s的交&amp;#xff0c;结果放在*this中)&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Set &amp;amp;s);     &lt;span class=\"hljs-comment\"&gt;//求集合的并(*this与s的并&amp;#xff0c;结果放在*this中)&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;diff&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Set &amp;amp;s)&lt;/span&gt;&lt;/span&gt;;         &lt;span class=\"hljs-comment\"&gt;//求集合的差(*this与s的差&amp;#xff0c;结果放在*this中)&lt;/span&gt;\n    Set&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(Set &amp;amp;s);  &lt;span class=\"hljs-comment\"&gt;//赋值拷贝函数&lt;/span&gt;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;;             &lt;span class=\"hljs-comment\"&gt;//将集合中元素从大到小排序&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Set::isInSet&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i&amp;lt;last&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(x&amp;#61;&amp;#61;iPtr[i])\n            flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    } \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; flag; \n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Set::insert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;isInSet&lt;/span&gt;(x)){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(last&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;lt;maxSize){\n            iPtr[&amp;#43;&amp;#43;last]  &amp;#61;  x; \n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n            Set &lt;span class=\"hljs-built_in\"&gt;tempSet&lt;/span&gt;(maxSize&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61; last;i&amp;#43;&amp;#43;){\n                tempSet.iPtr[i] &amp;#61; iPtr[i];\n                tempSet.last&amp;#43;&amp;#43;;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; []iPtr;\n            last &amp;#61; &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n            iPtr &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;[&amp;#43;&amp;#43;maxSize];\n            &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61; tempSet.last;i&amp;#43;&amp;#43;){\n                iPtr[i] &amp;#61; tempSet.iPtr[i];\n                last&amp;#43;&amp;#43;;\n            }\n            last&amp;#43;&amp;#43;;\n            iPtr[last] &amp;#61; x;\n        }\n    }\n}\nSet::&lt;span class=\"hljs-built_in\"&gt;Set&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *szFileName):&lt;span class=\"hljs-built_in\"&gt;AbsCollection&lt;/span&gt;(size)\n{   \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(szFileName &amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#34;&lt;/span&gt;)\n    {\n        fileName&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    fileName &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;[&lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(szFileName)];\n    &lt;span class=\"hljs-function\"&gt;fstream &lt;span class=\"hljs-title\"&gt;fs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(szFileName,ios::in)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!fs.&lt;span class=\"hljs-built_in\"&gt;is_open&lt;/span&gt;())\n    {\n        cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;open error!&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n        &lt;span class=\"hljs-built_in\"&gt;abort&lt;/span&gt;();\n    } \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(fs&amp;gt;&amp;gt;x)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;isInSet&lt;/span&gt;(x))\n        {\n            &lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(x);\n        }\n    }\n    fs.&lt;span class=\"hljs-built_in\"&gt;close&lt;/span&gt;();\n}\nSet::~&lt;span class=\"hljs-built_in\"&gt;Set&lt;/span&gt;()\n{    \n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(fileName)\n    {\n        &lt;span class=\"hljs-function\"&gt;fstream &lt;span class=\"hljs-title\"&gt;fs&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(fileName,ios::out|ios::trunc)&lt;/span&gt;&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *ip&amp;#61;iPtr;ip&amp;lt;&amp;#61;iPtr&amp;#43;last;)\n        {\n            fs&amp;lt;&amp;lt;*ip&amp;#43;&amp;#43;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n        }\n        fs.&lt;span class=\"hljs-built_in\"&gt;close&lt;/span&gt;();\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; fileName;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(iPtr)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; []iPtr;\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Set::erase&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt;\n&lt;/span&gt;{\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;last;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(iPtr[i]&amp;#61;&amp;#61;x){\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(i&amp;lt;&amp;#61;last){\n            &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i!&amp;#61;last){\n                iPtr[i]&amp;#61;iPtr[i&amp;#43;&amp;#43;];\n            }\n        }\n    }\n    last--;\n}\nostream&amp;amp; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(ostream&amp;amp; os, Set&amp;amp; s)\n{\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;s.last;i&amp;#43;&amp;#43;)\n    {\n        os&amp;lt;&amp;lt;s.iPtr[i]&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; os;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Set::intersetion&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Set &amp;amp;s)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Set &lt;span class=\"hljs-title\"&gt;tempSet&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(maxSize)&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;last;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(s.&lt;span class=\"hljs-built_in\"&gt;isInSet&lt;/span&gt;(iPtr[i]))\n        {\n            tempSet.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(iPtr[i]);\n        }\n    }\n    *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; &amp;#61; tempSet;\n}\n&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; Set::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;(Set &amp;amp;s){\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;s.last;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;isInSet&lt;/span&gt;(s.iPtr[i])){\n            &lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(s.iPtr[i]); \n        } \n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Set::diff&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Set &amp;amp;s)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Set &lt;span class=\"hljs-title\"&gt;tempSet&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(maxSize)&lt;/span&gt;&lt;/span&gt;;\n    tempSet &amp;#61; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;s.last;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;isInSet&lt;/span&gt;(s.iPtr[i]))\n        {\n            tempSet.&lt;span class=\"hljs-built_in\"&gt;erase&lt;/span&gt;(s.iPtr[i]);\n        }\n    }\n    *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; &amp;#61; tempSet;\n\n}\nSet&amp;amp; Set::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#61;(Set &amp;amp;s)\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(iPtr) &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; []iPtr;\n    maxSize &amp;#61; s.maxSize;\n    iPtr &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;[maxSize];\n    last &amp;#61; s.last;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&amp;#61;last;i&amp;#43;&amp;#43;)\n    {\n        iPtr[i]&amp;#61;s.iPtr[i];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n} \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Set::sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    std::&lt;span class=\"hljs-built_in\"&gt;sort&lt;/span&gt;(iPtr,iPtr&amp;#43;last&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;greater&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;gt;());\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-function\"&gt;Set &lt;span class=\"hljs-title\"&gt;set1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#34;f1.txt&amp;#34;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;\n    set1.&lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;);\n    set1.&lt;span class=\"hljs-built_in\"&gt;OutputSet&lt;/span&gt;();\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "赋值运算符", "Question": ["这个代码编译不通过想知道怎么改", ["要求如下", "\n", "\n", "//（1）定义Set类，编写Set类构造函数和析构函数，使它们完成打开文件读入元素到数组中和将数组中元素写入指定的磁盘文件中；", "\n", "//（2）编写集合增加一个元素的成员函数insert(int x)；(注：如果集合中已有相同的元素，则不再加入)", "\n", "//（3）编写删除一个元素的成员函数erase(int x)；", "\n", "//（4）编写判别元素是否属于集合的成员函数isInSet(int x)；", "\n", "//（5）编写求两个集合交的函数成员intersection(Set &s)；", "\n", "//（6）编写求两个集合差的成员函数intersetion(Set &s)；", "\n", "//（7）重载+运算符，用于求两个集合的并；", "\n", "//（8）编写集合排序的成员函数sort()；（从大到小排序）", "\n", "//（9）重载<<运算符，用于在屏幕上输出集合元素。", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std; \n", "class", " ", "AbsCollection", "{\n", "protected", ":\n    ", "int", " *iPtr;        ", "//指向数组的指针", "\n    ", "int", " last;        ", "//数组最后一个元素的位置", "\n    ", "int", " maxSize;    ", "//数组总体长度", "\n", "public", ":\n    ", "AbsCollection", "(", "int", " size = ", "100", "){\n        maxSize = size;\n        iPtr = ", "new", " ", "int", "[maxSize];\n        last = ", "-1", ";\n    };\n    ", "virtual", " ~", "AbsCollection", "();\n    ", "void", " ", "OutputSet", "()", ";  ", "//输出集合中元素", "\n};\n\n", "void", " ", "AbsCollection::OutputSet", "()", "\n", "{\n    cout<<", "\"The number of elements:\"", "<<last+", "1", "<<endl;\n    ", "for", "(", "int", " i=", "0", ";i<=last;i++)\n    {\n        cout<<iPtr[i]<<", "\" \"", ";\n    }\n    cout<<endl;\n}\n", "class", " ", "Set", ":", "public", " AbsCollection\n{\n", "private", ":\n    ", "char", " *fileName; ", "//存放数据的文件", "\n", "public", ":\n    ", "Set", "(", "int", " size = ", "100", ", ", "const", " ", "char", " *szFileName=", "\"\"", ");", "//从文件读取数据存入数组（要判断是否有重复元素）", "\n    ", "virtual", " ~", "Set", "();        ", "//析构函数，释放内存并将数据写入文件", "\n    ", "void", " ", "insert", "(", "int", " x)", ";    \n    ", "void", " ", "erase", "(", "int", " x)", ";\n    ", "int", " ", "isInSet", "(", "int", " x)", ";     ", "//判断x是否已经存在于集合中", "\n    ", "friend", " ostream& ", "operator", "<<(ostream& os, Set& s);\n    ", "void", " ", "intersetion", "(Set &s)", ";", "//求集合的交(*this与s的交，结果放在*this中)", "\n    ", "void", " ", "operator", "+(Set &s);     ", "//求集合的并(*this与s的并，结果放在*this中)", "\n    ", "void", " ", "diff", "(Set &s)", ";         ", "//求集合的差(*this与s的差，结果放在*this中)", "\n    set& ", "operator", "=(Set &s);  ", "//赋值拷贝函数", "\n    ", "void", " ", "sort", "()", ";             ", "//将集合中元素从大到小排序", "\n};\n\n", "int", " ", "Set::isInSet", "(", "int", " x)", "\n", "{\n    ", "int", " flag = ", "0", ";\n    ", "for", "(", "int", " i=", "0", "; i<last+", "1", "; i++)\n    {\n        ", "if", "(x==iPtr[i])\n            flag = ", "0", ";\n        ", "else", "\n            flag = ", "1", ";\n    } \n    ", "return", " flag; \n}\n", "void", " ", "Set::insert", "(", "int", " x)", "\n", "{\n    ", "if", "(!", "isInSet", "(x)){\n        ", "if", "(last+", "1", "<maxSize){\n        iPtr[++last]  =  x; \n    }\n    ", "else", "{\n        Set ", "tempSet", "(maxSize+", "1", ");\n        ", "for", "(", "int", " i = ", "0", ";i<= last;i++){\n            tempSet.iPtr[i] = iPtr[i];\n            tempSet.last++;\n        }\n        ", "delete", " []iPtr;\n        last = ", "-1", ";\n        iPtr = ", "new", " ", "int", "[++maxSize];\n        ", "for", "(", "int", " i = ", "0", ";i<= tempSet.last;i++){\n            iPtr[i] = tempSet.iPtr[i];\n            last++;\n        }\n        last++;\n        iPtr[last] = x;\n    }\n}\nSet::", "Set", "(", "int", " size, ", "const", " ", "char", " *szFileName):", "AbsCollection", "(size)\n{   \n    ", "if", "(szFileName ==", "\"\"", ")\n    {\n        fileName=Null;\n        ", "return", ";\n    }\n    fileName = ", "new", " ", "char", "[", "strlen", "(szFileName)];\n    fstream fs;\n    fs.", "open", "(szFileName,ios::in);\n    ", "if", "(!fs.", "isopen", "())\n    {\n        cout<<", "\"open error!\"", "<<endl;\n        ", "abort", "();\n    } \n    ", "int", " x;\n    ", "while", "(fs>>x)\n    {\n        ", "if", "(!", "isInSet", "(x))\n        {\n            ", "insert", "(x);\n        }\n    }\n    fs.", "close", "();\n}\nSet::~", "Set", "()\n{    \n    ", "if", "(fileName){\n    ", "fstream ", "fs", "(fileName,ios::out|ios::trunc)", "\n    ", "for", "(", "int", " *ip=iPtr;ip<=iPtr+last;)", "\n    ", "{\n        fs<<*ip++<<", "\" \"", ";\n    }\n    fs.", "close", "();\n    ", "delete", " fileName;\n}\n    ", "if", "(iPtr)\n    {\n        ", "delete", " []iPtr;\n    }\n}\n", "void", " ", "Set::erase", "(", "int", " x)", "\n", "{\n    \n    ", "for", "(", "int", " i = ", "0", ";i<=last;i++){\n        ", "if", "(iPtr[i]==x){\n            ", "break", ";\n        }\n        ", "if", "(i<=last){\n            ", "while", "(i!=last){\n                iPtr[i]=iPtr[i++];\n            }\n        }\n    }\n    last--;\n}\nostream&", "operator", "<<(ostream& os, Set& s)\n{\n    \n    ", "for", "(", "int", " i = ", "0", ";i<=last;i++)\n    {\n        os<<iPtr[i]<<", "\" \"", ";\n    }\n    ", "return", " os;\n}\n", "void", " ", "Set::intersetion", "(Set &s)", "\n", "{\n    ", "Set ", "tempSet", "(maxSize)", ";\n    ", "for", "(", "int", " i = ", "0", ";i<=last;i++)\n    {\n        ", "if", "(s.", "isInSet", "(iPtr[i]))\n        {\n            tempSet.", "insert", "(iPtr[i]);\n        }\n    }\n    *", "this", " = tempSet;\n    ", "return", " *", "this", ";\n}\n", "void", " Set::", "operator", "+(Set &s){\n    ", "for", "(", "int", " i=", "0", ";i<=s.last;i++){\n        ", "if", "(!", "isInSet", "(s.iPtr[i])){\n            ", "insert", "(s.iPtr[i]); \n        } \n    }\n}\n", "void", " ", "Set::diff", "(Set &s)", "\n", "{\n    ", "Set ", "tempSet", "(maxSize)", ";\n    tempSet = *", "this", ";\n    ", "for", "(", "int", " i=", "0", ";i<=s.last;i++)\n    {\n        ", "if", "(", "isInSet", "(s.iPtr[i]))\n        {\n            tempSet.", "erase", "(s.iPtr[i]);\n        }\n    }\n    *", "this", " = tempSet;\n    \n}\nSet& Set::", "operator", "=(Set &s)\n{\n    ", "if", "(iPtr) ", "delete", " []iPtr;\n    maxSize = s.maxSize;\n    iPtr = ", "new", " ", "int", "[maxSize];\n    last = s.last;\n    ", "for", "(", "int", " i=", "0", ";i<=last;i++)\n    {\n        iPtr[i]=s.iPtr[i];\n    }\n    ", "return", " *", "this", ";\n} \n", "void", " ", "Set::sort", "()", "\n", "{\n    std::", "sort", "(iPtr,iPtr+last+", "1", ",", "great", "<", "int", ">());\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "Set ", "set1", "(", "0", ",", "\"f1.txt\"", ")", ";\n    set1.", "insert", "(", "30", ");\n    set1.", "OutputSet", "();\n}\n", "\n", "谢谢大家！"]], "Tag": "程序设计"}
