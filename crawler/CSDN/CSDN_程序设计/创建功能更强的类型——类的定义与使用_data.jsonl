{"Answer": "题太多。。。。\r\n第3题，B\r\n第42题，静态变量是用static修饰的，在内存中只有一份，所有实例共享，实例变量是每个实例自己的。\r\n41：tomcat是web服务器，同时也是servlet的容器\r\n35：jsp有4种会话跟踪技术？ cookie和url重写2种\r\n32：j2ee是技术规范，也可以理解为平台\r\n25：string是final类了", "Konwledge_Point": "创建功能更强的类型——类的定义与使用", "Question": ["做了一个小时的面试题（没有过  希望大家帮忙答下  虽然很幼稚  毕竟每个人都是这么过来的吗  感激了！）", ["XX软件工程师笔试试题", "\n注：1、请参考人员将答案写在答题纸上，勿将答案写在此卷上。", "\n2、请参考人员将编号与姓名填写在答题纸上。", "\n\n", "1、    以下数据结构中不属于线性数据结构的是（）。", "\nA、队列   B、线性表   C、二叉树  D、栈", "\n我的答案：C", "\n\n", "2、    在结构化方法中，用数据流程图（DFD）作为描述工具的软件开发阶段是（）。", "\nA、    可行性分析  B、需求分析  C、详细设计  D、程序编码", "\n我的答案：B", "\n\n", "3、    结构化程序设计主要强调的是（）。", "\nA、    程序的规模  B、程序的易读性  C、程序的执行效率  D、程序的可移植性", "\n我的答案：C", "\n\n", "4、    在软件生命周期中，能准确地确定软件系统必须做什么和必须具备哪些功能的阶段（）。", "\nA、    概要设计  B、详细设计  C、可行性分析  D、需求分析", "\n我的答案：B", "\n\n", "5、    下列关于栈的叙述中正确的是（）。", "\nA、    在栈中只能插入数据  B、在栈中只能删除数据", "\nB、    栈是先进先出的线性表  D、栈是先进后出的线性表", "\n我的答案：D", "\n\n", "6、    下面不属于软件设计原则的是（）。", "\nA、    抽象  B、模块化  C、自底向上  D、信息隐蔽", "\n我的答案：C", "\n\n", "7、    对长度为N的线性表进行顺序查找，在最坏情况下所需要的比较次数为（）。", "\nA、    N+1  B、N  C、（N+1）/2  D、N/2", "\n我的答案：C", "\n\n", "8、    视图设计一般有3种设计次序，下列不属于视图设计的是（）。", "\nA、    自顶向下  B、由外向内  C、由内向外  D、自底向上", "\n我的答案：C", "\n\n", "9、下列有关数据库的描述，正确的是（）。", "\nA、数据库是一个DBF文件  B、数据库是一个关系", "\nC、数据库是一个结构化的数据集合  D、数据库是一组文件", "\n我的答案：C", "\n\n", "10、下列说法中，不属于数据模型所描述的内容的是（）。", "\nA、数据结构  B、数据操作  C、数据查询  D、数据约束", "\n我的答案：A", "\n\n", "11、若按功能划分，软件测试的方法通常分为白盒测试方法和（黑盒测试方法）。", "\n\n", "12、数据库系统的三级模式分别为（级联）模式、内部级模式与外部级模式。", "\n\n", "13、在最坏情况下，冒泡排序的时间复杂度为（N+1/2）。", "\n\n", "14、在面向对象方法中，信息隐蔽是通过对象的（封装）性来实现的。", "\n\n", "15、关系模型的数据操纵既是建立在关系上的数据操纵，一般有（插入）、增加、删除、和修改四种操作。", "\n\n", "16、TIME（）的返回值的数据类型是（String）类型。", "\n\n", "17、编写SQL语句", "\n  1）、创建一张学生表，包含以下信息，学号，姓名，年龄，性别，家庭住址，联系电话", "\n  我的答案：", "\n  create table student(", "\n  studentCardNo number(2) primary key,", "\n  name char(10),", "\n  age number(2),", "\n  sex char(2) check(sex in (‘男’,’女’)),", "\n  address varchar2(100),", "\n  tel number(2)", "\n  )", "\n\n", "2)、修改学生表的结构，添加一列信息，学历", "\n  我的答案：", "\n  alter table student add(xueli varchar2(20));", "\n\n", "3)、修改学生表的结构，删除一列信息，家庭住址", "\n  我的答案：", "\n  alter table student drop column address;", "\n\n", "4)、向学生表添加如下信息：", "\n      学号  姓名  年龄  性别  联系电话  学历", "\n        1    A     22    男    123456   小学", "\n        2    B     21    男     119     中学", "\n        3    C     23    男     110     高中", "\n        4    D     18    女     114     大学", "\n   我的答案：", "\n   insert into student values(‘&1’,’&2’,’&3’);", "\n   一次一次添加", "\n\n", "5)修改学生表的数据，将电话号码以11开头的学员的学历改为“大专”", "\n   我的答案：", "\n   update student set xueli=”大专” where tel like 11%;", "\n\n", "6)删除学生表的数据，姓名以C开头，性别为‘男’的记录删除", "\n   我的答案：", "\n   delete student where name like C% or sex=”男”;", "\n  7)查询学生表的数据，将所有年龄小于22岁的，学历为“大专”的，学生的姓名和学号显示出来", "\n   我的答案：", "\n   select name,studentCardNo from student where age<22 and xueli=”大专”;", "\n  8)查询学生表的数据，查询所有信息，列出前25%的记录", "\n   我的答案：", "\n   select top*0.25 from student;", "\n  9）查询出所有学生的姓名，性别，年龄降序排列", "\n   我的答案：", "\n   select name,sex,age from student where age desc;", "\n  10）按照性别分组查询所有的平均年龄", "\n   我的答案：", "\n   select avg(age) from student group by sex;", "\n\n", "18、什么是存储过程？为什么存储过程要比单纯的SQL语句执行起来要快？", "\n   我的答案：", "\n   存储过程算是一种优化查询需要比单存SQL语句执行的要快", "\n19、两张关联表，删除主表中已经在副表中没有的信息", "\n我的答案", "\n   delete from  fubiao a where a.fid not in(select id from zhubiao)", "\n20、程序题：", "\n用1、2、2、3、4、5这六个数字，用java或你熟悉的语言，打印出所有不同的排列，如：512234、412345等，要求：“4”不能再第三位，“3”与“5”不能相连。并将这些数据按从小到大输出。", "\n我的答案", "\n   我的写的不好 没贴下  笔试的时候没写全", "\n21、String 和 StringBuffer的区别", "\n我的答案", "\n    String定长 StringBuffer 变长", "\n22、&和&&的区别", "\n我的答案", "\n  &短路与 &&逻辑与", "\n网上答案：", "\n& 是位运算符，表示按位与运算，", "\n  && 是逻辑运算符，表示逻辑与（and）。", "\n23、final，finally，finalize的区别", "\n我的答案", "\nFinal静变量关键字，finally异常关键字，finalize", "\n网上答案", "\nfinal 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。", "\n  finally是异常处理语句结构的一部分，表示总是执行。", "\n  finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，", "\n  可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。", "\n24、数组有没有length（）这个方法？String有没有length（）这个方法？", "\n我的答案：", "\n数组没有length()这个方法，有length的属性。", "\nString有length()这个方法。", "\n25、是否可以继承String类？", "\n我的答案：", "\n不可以  解释的很乱", "\n26、说出数据连接池的工作机制是什么？", "\n我的答案：", "\n反正解释的很乱我感觉", "\n27、垃圾回收的优点和原理。并考虑2种回收机制。", "\n    我的答案：", "\n动态回收  解释的很乱", "\n网上答案：", "\nJava语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，", "\n  它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有\"作用域\"的概念，", "\n  只有对象的引用才有\"作用域\"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。", "\n  垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有", "\n  使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。", "\n  回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。  ", "\n\n", "28、你所知道的集合类都有哪些？区别？主要方法？", "\n    我的答案：", "\n    Arraylist 非线性的、Vertor线性的 ", "\n29、JSP的内置对象及方法。", "\n    我的答案：", "\n    Page,exception,out,page content,application,request,reponse,session,config", "\n30、页面间对象传递的方法。", "\n我的答案：", "\n那几个方法都写错了", "\n31、你知道Request对象的主要方法有哪些？", "\n\n", "32、J2EE是技术还是平台还是框架？", "\n    我的答案：", "\nJ2EE是技术也是平台", "\n网上答案：", "\nJ2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。", "\n J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。", "\n33、我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，如何输出一个某种（例如GBK编码类型）编码的字符串？", "\n   Request encording(“GBK”)", "\n34、j2ee常用的设计模式？说明工厂模式。", "\nGof23种设计模式", "\n工厂模式：Factory", "\n网上答案：", "\nJava中的23种设计模式：", "\n    Factory（工厂模式），      Builder（建造模式），       Factory Method（工厂方法模式），", "\n    Prototype（原始模型模式），Singleton（单例模式），    Facade（门面模式），", "\n    Adapter（适配器模式），    Bridge（桥梁模式），        Composite（合成模式），", "\n    Decorator（装饰模式），    Flyweight（享元模式），     Proxy（代理模式），", "\n    Command（命令模式），      Interpreter（解释器模式）， Visitor（访问者模式），", "\n    Iterator（迭代子模式），   Mediator（调停者模式），    Memento（备忘录模式），", "\n    Observer（观察者模式），   State（状态模式），         Strategy（策略模式），", "\n    Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）", "\n  工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，", "\n  通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。", "\n  首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。", "\n  然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。", "\n  当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。", "\n35、JSP四种会话跟踪技术", "\n    我的答案：", "\n    Application  cookie  session", "\n36、排序都有哪几种方法？请举例", "\n冒泡 选择 快序 二分查找", "\n网上答案：", "\n排序的方法有：插入排序（直接插入排序、希尔排序），", "\n                交换排序（冒泡排序、快速排序），", "\n                选择排序（直接选择排序、堆排序），", "\n                归并排序，分配排序（箱排序、基数排序）", "\n  快速排序的伪代码。", "\n    //使用快速排序方法对a[ 0 :n- 1 ]排序", "\n    从a[ 0 :n- 1 ]中选择一个元素作为m i d d l e，该元素为支点", "\n   把余下的元素分割为两段left 和r i g h t，使得l e f t中的元素都小于等于支点，而right 中的元素都大于等于支点", "\n   递归地使用快速排序方法对left 进行排序", "\n   递归地使用快速排序方法对right 进行排序", "\n   所得结果为l e f t + m i d d l e + r i g h t", "\n37、关于模块间的设计原则？", "\n    规范要一样", "\n38、项目过程一般是怎样的？你参加过几个项目开发？参加过的项目流程是怎样的？自己负责与人合作工作内容及自我评价？", "\n   从需求调研——设计开发——实施", "\n参加过网站的实施 模板的制作", "\n39、tomcat自动关闭常见原因？", "\n我的答案：", "\n现在没遇到过", "\n40、如何设置TOMCAT内存和连接数？", "\n    我的答案：", "\n    Tomcat群集", "\n41、你如何理解Tomcat是什么？", "\n    我的答案：", "\n    Tomcat是JSP Servlet 容器恰当的说", "\n42、静态变量和实例变量的区别？", "\n    我的答案：", "\n    静态变量域用final修饰，每次都被调用 实例变量则不会", "\n43、IE、FF下面CSS的解释区别", "\n    我的答案：", "\n    自己编的", "\n44、web前端技术你了解哪些技术？", "\n    我的答案：", "\n    JAVAScript,CSS,DIV,Ajax,Ajax框架，DWR,dojo,jguery", "\n45、什么是报表？什么是报表控件，作用是什么？你了解哪些报表工具？", "\n    我的答案：", "\n    解释的很乱", "\n46、你了解的那些统计图表类型？", "\n    我的答案：", "\n    自己编的", "\n47、Flex与数据库连接的三种方式？ ", "\n    我的答案：", "\n    自己编的", "\n\n", "我答错的、  错在哪里？  没答上的帮忙解答下？  感激了 ！  "]], "Tag": "程序设计"}
{"Answer": "&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/u011725603/article/details/38133373'&gt;小型DBMS（c实现）&lt;/a&gt;&lt;br/&gt;----------------------biu~biu~biu~~~在下问答机器人小D，这是我依靠自己的聪明才智给出的答案，如果不正确，你来咬我啊！", "Konwledge_Point": "创建功能更强的类型——类的定义与使用", "Question": ["如何在PlanePanel里面实现小型敌机的下落，好混乱啊", ["package start;", "\n\n", "import javax.swing.ImageIcon;", "\nimport javax.swing.JFrame;", "\n\n", "public class StartFrame extends JFrame{", "\n/**", "\n     * ", "\n     */", "\n    public  int x;", "\n    public  int y;", "\n    public static StartFrame startFrame;", "\n    private static final long serialVersionUID = 1L;", "\n\n", "public StartFrame(){", "\n\n", "//设置窗体大小\nthis.setSize(400, 654);\n//设置窗口居中显示\n//this.setLocationRelativeTo(null);\nthis.setLocation(150, 50);\n//设置任务栏图标\nthis.setIconImage(new ImageIcon(\"image/icon.jpg\").getImage());\n//去掉窗体的自带边框\nthis.setUndecorated(true);  \n\nStartPanel sp = new StartPanel();\nthis.add(sp);\nthis.setVisible(true);              //默认窗体可见  放在  this.add(sp);后面\n\n//启动线程\nThread th = new Thread(sp);\nth.start();\n", "\n\n", "}", "\npublic static void main(String[] args) {", "\n\n", "startFrame = new StartFrame();\n", "\n\n", "}", "\n\n", "}", "\n\n", "package start;", "\n\n", "import java.awt.Graphics;", "\n\n", "import javax.swing.ImageIcon;", "\nimport javax.swing.JPanel;", "\n\n", "import enemy.Enemy;", "\nimport enemy.EnemyMoveThread;", "\n\n", "public class StartPanel extends JPanel implements Runnable {", "\n    /**", "\n     * 通过鼠标来控制MouseMontionListener", "\n     * 重写mouseMovie（） ——————测试语句", "\n     * 给面板添加监听器", "\n     * panel.addMouseMontionListener(面板)；", "\n     * 点关闭图标关闭", "\n     * 点击缩小图标", "\n     * 实现MouseListener接口", "\n     * 重写", "\n     */", "\n    private static final long serialVersionUID = 1L;", "\n    int x;", "\n    StartPanel sp;", "\n    Enemy e;", "\n\n", "public void paint(Graphics g) {\n    // TODO Auto-generated method stub\n    super.paint(g);\n    g.drawImage(new ImageIcon(\"image/startback.png\").getImage(), 0, 0, this);\n    g.drawImage(new ImageIcon(\"image/start_aircraft.png\").getImage(), x,450, this);\n}\n\npublic void run() {\n    // TODO Auto-generated method stub\n    while (true) {\n        x++;\n        try {\n            Thread.sleep(10);\n        } catch (InterruptedException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        if (x > 400) {\n            // 隐藏StartFrame的窗体\n            StartFrame.startFrame.dispose();\n\n            /*\n             * 获得左上角的坐标 int x = StartFrame.startFrame.getLocation().x;int y\n             * = StartFrame.startFrame.getLocation().y;\n             */\n\n            // 创建新的PlaneFrame窗口\n            new PlaneFrame();\n            break;\n        }\n        repaint();\n    }\n}\n", "\n\n", "}", "\n\n", "package start;", "\n\n", "import javax.swing.ImageIcon;", "\nimport javax.swing.JFrame;", "\n\n", "import enemy.Enemy;", "\nimport enemy.EnemyMoveThread;", "\n/**", "\n\n", "\n", "当StartFrame的小飞机飞到最右边时，Start窗口隐藏(this.disapose()),显示新的窗口PlaneFrame", "\n", "\n", "创建新的面板", "封装低级Enemy   xy score  image  speed  isLive  panel;", "\n*/", "\npublic class PlaneFrame extends JFrame implements Runnable{", "\n/", "*", "\n\n", "\n", "\n*/\nPlanePanel pp;\nEnemy e;\npublic static PlaneFrame planeFrame;   //定义全局变量：可以在所有位置使用\nprivate static final long serialVersionUID = 1L;", "\n", "\n", "public  PlaneFrame(){", "\n    this.setSize(400, 654);", "\n    //x y?", "\n    this.setLocation(150,50);", "\n    this.setIconImage(new ImageIcon(\"image/icon.jpd\").getImage());", "\n    this.setUndecorated(true);", "\n    pp = new PlanePanel(this);", "\n    this.add(pp);", "\n    pp.addMouseMotionListener(pp);  //第一个pp代表面，，第二个pp代表监听器对象", "\n    //给面板添加监听器对象", "\n    pp.addMouseListener(pp);", "\n    EnemyMoveThread emt = new EnemyMoveThread(e);", "\n    emt.start();", "\n    this.setVisible(true); ", "\n\n", "}", "\npublic static void main(String[] args) {", "\n    planeFrame = new PlaneFrame();", "\n}", "\npublic void run() {", "\n\n", "//如果英雄机存活，创建敌机", "\nwhile(pp.hero_isLive){", "\n    //x, y, speed, icon, panel", "\n    /*", "\n     * Random r = new Random();", "/", "\n    ImageIcon icon = new ImageIcon(\"image/shoot0_0.png\");", "\n    //大类型的数据不能直接赋值给小类型的数据，需要强制性转换", "\n    int x = (int) (Math.random()", "(pp.getWidth()-icon.getIconWidth()));", "\n    int y = -icon.getIconHeight();", "\n    int speed = 10;", "\n\n", "//创建敌机  添加集合之中\nEnemy e = new Enemy(x,y,speed,icon,pp);\n//将敌机添加到集合中\npp.vs.add(e);\n//给敌机绑定运动的线程\nEnemyMoveThread th = new EnemyMoveThread(e);\nth.start();\ntry {\n    Thread.sleep(10);\n} catch (InterruptedException e1) {\n    // TODO Auto-generated catch block\n    e1.printStackTrace();\n}\n", "\n\n", "}", "\n}", "\n}", "\n", "\n", "package start;", "\n\n", "import java.awt.Graphics;", "\nimport java.awt.event.MouseEvent;", "\nimport java.awt.event.MouseListener;", "\nimport java.awt.event.MouseMotionListener;", "\nimport java.util.Random;", "\nimport java.util.Vector;", "\n\n", "import javax.swing.ImageIcon;", "\nimport javax.swing.JFrame;", "\nimport javax.swing.JPanel;", "\n\n", "import enemy.Enemy;", "\n\n", "public class PlanePanel extends JPanel implements MouseListener,", "\n        MouseMotionListener {", "\n\n", "// 定义布尔类型isLive（存活）\nprivate boolean isLive = true;\nint x;\nint hero_x = 200;\nint hero_y = 500;\nboolean hero_isLive = true;\nPlaneFrame f;\n\nImageIcon icon = new ImageIcon(\"Image/hero.png\");\nImageIcon min = new ImageIcon(\"image/min.png\");\n\n// 定义一个集合存放敌机\n// Vector集合避免线程异步的问题 线程安全的一个线程\npublic Vector<Enemy> vs = new Vector<Enemy>();\n\n// 通 过 构造方法 传值\npublic PlanePanel(PlaneFrame planeFrame) {\n    this.f = planeFrame;\n}\n\npublic void paint(Graphics g) {\n    // TODO Auto-generated method stub\n    super.paint(g);\n\n\n    g.drawImage(new ImageIcon(\"image/backmain.png\").getImage(), 0, 0, this);\n    g.drawImage(new ImageIcon(\"image/min.png\").getImage(), 325, 3, this);\n    g.drawImage(new ImageIcon(\"image/close.png\").getImage(), 360, 3, this);\n    g.drawImage(new ImageIcon(\"image/hero.png\").getImage(), hero_x, hero_y,\n            this);\n    for(int i = 0;i<vs.size();i++){\n        Enemy e = vs.get(i);\n        e.drawEnemy(g);\n    }\n}\n\npublic void mouseDragged(MouseEvent arg0) {\n    // TODO Auto-generated method stub\n\n}\n\npublic void mouseMoved(MouseEvent e) {\n    // TODO Auto-generated method stub\n    if (hero_isLive) {\n        int x = e.getX(); // 得到鼠标的x坐标\n        int y = e.getY(); // 得到鼠标的y坐标\n        // 根据鼠标的坐标与英雄机的宽和高计算英雄机的坐标\n        hero_x = x - icon.getIconWidth() / 2;\n        hero_y = y - icon.getIconHeight() / 2;\n\n        if (hero_x <= 400 - 55 && hero_y >= 31 && hero_y <= 650 - 90\n                && hero_x >= -40) {\n            this.repaint();\n        }\n    }\n    //\n}\n\npublic void mouseClicked(MouseEvent e) {\n    // TODO Auto-generated method stub\n    int x = e.getX();\n    int y = e.getY();\n    if (x > 325 && x < 325 + min.getIconWidth() && y > 3\n            && y < min.getIconHeight()) {\n        // 缩小窗体\n        f.setState(JFrame.ICONIFIED);\n    } else if (x > 360 && x < 360 + 31 && y > 3 && y < 3 + 31) {\n        System.exit(0); //\n    }\n}\n\npublic void mouseEntered(MouseEvent arg0) {\n    // TODO Auto-generated method stub\n\n}\n\npublic void mouseExited(MouseEvent arg0) {\n    // TODO Auto-generated method stub\n\n}\n\npublic void mousePressed(MouseEvent arg0) {\n    // TODO Auto-generated method stub\n\n}\n\npublic void mousePressed1(MouseEvent arg0) {\n    // TODO Auto-generated method stub\n\n}\n\npublic void mouseReleased(MouseEvent arg0) {\n    // TODO Auto-generated method stub\n\n}\n", "\n\n", "}", "\n\n", "package enemy;", "\n\n", "import java.awt.Graphics;", "\n\n", "import javax.swing.ImageIcon;", "\n\n", "import start.PlanePanel;", "\n\n", "public class Enemy {", "\n     int x;", "\n     int y;", "\n     int speed;", "\n     int score = 100;", "\n     ImageIcon icon;", "\n     boolean isLive = true;", "\n     PlanePanel panel;", "\n\n", " public Enemy(){\n\n }\n\npublic Enemy(int x, int y, int speed, ImageIcon icon, PlanePanel panel) {\n    super();\n    this.x = x;\n    this.y = y;\n    this.speed = speed;\n    this.icon = icon;\n    this.panel = panel;\n}\n//画敌机的方法\npublic void drawEnemy(Graphics g){\n    if(isLive){\n        g.drawImage(icon.getImage(),x,y,panel);\n    }\n\n}\npublic void move(){\n    y += speed;\n    //如果敌机飞出面板，删除该敌机，并且isLive设置成false\n    if(y>panel.getHeight()){\n        isLive = false;\n        panel.vs.remove(this);\n    }\n    panel.repaint();\n}\n", "\n\n", "}", "\n\n", "package enemy;", "\n\n", "//封装敌机运动的线程类", "\npublic class EnemyMoveThread extends Thread {", "\n\n", "// 创建成员变量e\nEnemy e;\n\npublic EnemyMoveThread(Enemy e) {\n    this.e = e;\n}\n\n@Override\npublic void run() {\n\n    super.run();\n    while (e.isLive) {\n        //\n        e.move();\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e1) {\n\n            e1.printStackTrace();\n\n        }\n    }\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;plt.contourf绘制的图是基于其中某两个特征的&amp;#xff0c;需要重新构建分类器&amp;#xff0c;并且选择数据集其中的某两个特征&amp;#xff0c;代码以前两个特征为例&amp;#xff0c;即代码中的0: 2&amp;#xff0c;PS&amp;#xff1a;由于代码太长&amp;#xff0c;我就不一一复制了&amp;#xff0c;从195行开始哈&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;predictions_2 &amp;#61; classifier.predict_proba(X_test)[:,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]\n&lt;span class=\"hljs-built_in\"&gt;from&lt;/span&gt; sklearn.metrics import roc_auc_score\ntest_auc &amp;#61; roc_auc_score(Y_test,predictions_2)\n&lt;span class=\"hljs-comment\"&gt;# test_auc &amp;#61; 0.7434&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;# 为了避免和之前的分类器重复&amp;#xff0c;所以新起了个名字&lt;/span&gt;\nclassifier_new &amp;#61; LogisticRegression(random_state &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\nclassifier_new.fit(X_train[:, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;], Y_train) &lt;span class=\"hljs-comment\"&gt;# 0&amp;#xff1a; 2表示的是前两个特征&lt;/span&gt;\n\n&lt;span class=\"hljs-built_in\"&gt;from&lt;/span&gt; matplotlib.colors import ListedColormap &lt;span class=\"hljs-comment\"&gt;# 给不同的点上不同的颜色&lt;/span&gt;\nX_set, Y_set &amp;#61; X_train[:, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;], Y_train &lt;span class=\"hljs-comment\"&gt;# 0&amp;#xff1a; 2表示的是前两个特征&lt;/span&gt;\nx1, x2 &amp;#61; np.meshgrid(np.arange(&lt;span class=\"hljs-built_in\"&gt;start&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;()&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;, &lt;span class=\"hljs-comment\"&gt;# -1 / &amp;#43;1 都能更方便我们看生成好的图像&lt;/span&gt;\n                               &lt;span class=\"hljs-built_in\"&gt;stop&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;()&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,\n                               step &amp;#61; &lt;span class=\"hljs-number\"&gt;0.01&lt;/span&gt;), &lt;span class=\"hljs-comment\"&gt;# 0.01 看显示屏的参数来设定&lt;/span&gt;\n                     np.arange(&lt;span class=\"hljs-built_in\"&gt;start&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;()&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,\n                               &lt;span class=\"hljs-built_in\"&gt;stop&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;()&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,\n                               step &amp;#61; &lt;span class=\"hljs-number\"&gt;0.01&lt;/span&gt;))\nplt.contourf(\n    x1, x2, classifier_new.predict( &lt;span class=\"hljs-comment\"&gt;# 这一行修改了&lt;/span&gt;\n        np.array([x1.ravel(),x2.ravel()]).T).reshape(x1.shape),\n    alpha &amp;#61; &lt;span class=\"hljs-number\"&gt;0.75&lt;/span&gt;,\n    cmap &amp;#61; ListedColormap((&lt;span class=\"hljs-string\"&gt;&amp;#39;red&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;green&amp;#39;&lt;/span&gt;))\n    )\nplt.xlim(x1.&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(), x1.&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;())\nplt.ylim(x2.&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(), x2.&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;())\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; enumerate(np.unique(Y_set)): &lt;span class=\"hljs-comment\"&gt;# 画出实际存在的点&lt;/span&gt;\n    plt.scatter(X_set[Y_set &amp;#61;&amp;#61; j, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], X_set[Y_set &amp;#61;&amp;#61; j, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],\n                c &amp;#61; ListedColormap((&lt;span class=\"hljs-string\"&gt;&amp;#39;orange&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;blue&amp;#39;&lt;/span&gt;))(i),label&amp;#61;j)\nplt.title(&lt;span class=\"hljs-string\"&gt;&amp;#39;Classifier (Training Set)&amp;#39;&lt;/span&gt;)\nplt.xlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;Age&amp;#39;&lt;/span&gt;)\nplt.ylabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;Estimated Salary&amp;#39;&lt;/span&gt;)\nplt.legend()\nplt.show()\n \n&lt;span class=\"hljs-comment\"&gt;# Visualising the Test set results&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;from&lt;/span&gt; matplotlib.colors import ListedColormap\nX_set, Y_set &amp;#61; X_test[:, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;: &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;], Y_test &lt;span class=\"hljs-comment\"&gt;# 0&amp;#xff1a;2表示的是前两个特征&lt;/span&gt;\nx1, x2 &amp;#61; np.meshgrid(np.arange(&lt;span class=\"hljs-built_in\"&gt;start&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;()&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,\n                               &lt;span class=\"hljs-built_in\"&gt;stop&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;()&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,\n                               step &amp;#61; &lt;span class=\"hljs-number\"&gt;0.01&lt;/span&gt;),\n                     np.arange(&lt;span class=\"hljs-built_in\"&gt;start&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;()&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;,\n                               &lt;span class=\"hljs-built_in\"&gt;stop&lt;/span&gt; &amp;#61; X_set[:,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;()&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,\n                               step &amp;#61; &lt;span class=\"hljs-number\"&gt;0.01&lt;/span&gt;))\nplt.contourf(\n    x1, x2, classifier_new.predict(\n        np.array([x1.ravel(),x2.ravel()]).T).reshape(x1.shape),\n    alpha &amp;#61; &lt;span class=\"hljs-number\"&gt;0.75&lt;/span&gt;,\n    cmap &amp;#61; ListedColormap((&lt;span class=\"hljs-string\"&gt;&amp;#39;red&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;green&amp;#39;&lt;/span&gt;))\n    )\nplt.xlim(x1.&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(), x1.&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;())\nplt.ylim(x2.&lt;span class=\"hljs-built_in\"&gt;min&lt;/span&gt;(), x2.&lt;span class=\"hljs-built_in\"&gt;max&lt;/span&gt;())\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; i, j &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; enumerate(np.unique(Y_set)):\n    plt.scatter(X_set[Y_set &amp;#61;&amp;#61; j, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;], X_set[Y_set &amp;#61;&amp;#61; j, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],\n                c &amp;#61; ListedColormap((&lt;span class=\"hljs-string\"&gt;&amp;#39;orange&amp;#39;&lt;/span&gt;,&lt;span class=\"hljs-string\"&gt;&amp;#39;blue&amp;#39;&lt;/span&gt;))(i),label&amp;#61;j)\nplt.title(&lt;span class=\"hljs-string\"&gt;&amp;#39;Classifier (Test Set)&amp;#39;&lt;/span&gt;)\nplt.xlabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;Age&amp;#39;&lt;/span&gt;)\nplt.ylabel(&lt;span class=\"hljs-string\"&gt;&amp;#39;Estimated Salary&amp;#39;&lt;/span&gt;)\nplt.legend()\nplt.show()\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "创建功能更强的类型——类的定义与使用", "Question": ["X has 2 features per sample;", ["问题遇到的现象和发生背景", "\n", "本人正在练习项目——对银行还款进行测试，其中的预测结果已经出来，但是想把结果进行可视化的时候遇到了问题，经过一系列排查，应该是 plt.contourf里面的那个ravel()部分出了问题", "（请直接跳转到代码最底下部分的：Visulising the Traning Set Result）", "\n", "问题相关代码", "\n", "import", " numpy ", "as", " np\n", "import", " pandas ", "as", " pd\n", "from", " sklearn.preprocessing ", "import", " LabelEncoder\n", "import", " os\n", "import", " warnings\nwarnings.filterwarnings(", "'ignore'", ")\n", "import", " matplotlib.pyplot ", "as", " plt\n", "import", " seaborn ", "as", " sns\n\n", "# 经典而分类问题", "\napp_train = pd.read_csv(", "'/Users/iven/Desktop/Python机器学习实战/第十一章：银行客户还款可能性预测/application_train.csv'", ")\n\n", "# 展示缺失值", "\n", "def", " ", "missing_value_table", "(", "df", "):\n    mis_val = df.isnull().", "sum", "() ", "# 计算所有缺失值", "\n    mis_val_percent = ", "100", " * df.isnull().", "sum", "() / ", "len", "(df) ", "# %比", "\n    mis_val_table = pd.concat([mis_val, mis_val_percent], axis=", "1", ")\n    ", "# 做成表格显示出来", "\n    mis_val_rename = mis_val_table.rename(columns={", "0", ":", "'Missing valyes'", ",", "1", ":", "'% of total values'", "})\n    ", "# 剔除完整的并排序（sort_value) 升序", "\n    mis_val_rename = mis_val_rename[mis_val_rename.iloc[:, ", "1", "] != ", "0", "].sort_values(", "'% of total values'", ", ascending = ", "False", ")\n    ", "return", " mis_val_rename\nmissing_value_table(app_train)[:", "10", "]\n", "'''\naxis=0代表往跨行（down)，而axis=1代表跨列（across)\n使用0值表示沿着每一列或行标签/索引值向下执行方法\n使用1值表示沿着每一行或者列标签横向执行对应的方法\n'''", "\n\n", "# Object 类型数据处理.", "\n", "# 特征个数大于2时候，一般用One-Hot去处理，而小于2的时候 label-eco", "\napp_train.dtypes.value_counts()\napp_train.select_dtypes(", "'object'", ").apply(pd.Series.nunique,axis=", "0", ") ", "#  Pandas nunique() 用于获取唯一值的统计次数。", "\nle = LabelEncoder()\n", "for", " col ", "in", " app_train:\n    ", "if", " app_train[col].dtype == ", "'object'", ":\n        ", "if", " ", "len", "(", "list", "(app_train[col].unique()))<=", "2", ":\n            le.fit(app_train[col])\n            app_train[col]=le.transform(app_train[col])\napp_train = pd.get_dummies(app_train)\napp_train.shape\n\n", "# EDA分析 特征分析", "\ntrain_labels = app_train[", "'TARGET'", "]\napp_train[", "'DAYS_BIRTH'", "][:", "5", "] ", "# 贷款的人从出生到现在\"活\"了多少天", "\n", "# 因此，我们需要转换成年", "\n(app_train[", "'DAYS_BIRTH'", "]/-", "365", ").describe()\n(app_train[", "'DAYS_EMPLOYED'", "]).describe()\n\napp_train[", "'DAYS_EMPLOYED'", "].plot.hist()\nplt.show()\n\napp_train[", "'DAYS_EMPLOYED_ANOM'", "] = app_train[", "'DAYS_EMPLOYED'", "] == ", "365243", "\napp_train[", "'DAYS_EMPLOYED'", "].replace({", "365243", ":np.nan},inplace=", "True", ")\napp_train[", "'DAYS_EMPLOYED'", "].plot.hist()\nplt.show()\n\ncorrelations = app_train.corr()[", "'TARGET'", "].sort_values()\ncorrelations.head()\ncorrelations.tail()\n", "# 但是对于年龄，它是负数", "\napp_train[", "'DAYS_BIRTH'", "] = ", "abs", "(app_train[", "'DAYS_BIRTH'", "])\napp_train[", "'TARGET'", "].corr(app_train[", "'DAYS_BIRTH'", "])\n", "# 变负了", "\nplt.figure(figsize = (", "12", ",", "6", "))\nplt.style.use(", "'fivethirtyeight'", ") ", "# 图表风格 去SeaBorn看就ok", "\nplt.hist(app_train[", "'DAYS_BIRTH'", "]/", "365", ",edgecolor=", "'k'", ",bins=", "25", ")\nplt.show()\n\nplt.figure(figsize=(", "16", ",", "8", "))\n", "#KDEPLOT", "\nsns.kdeplot(app_train.loc[app_train[", "'TARGET'", "]==", "0", ",", "'DAYS_BIRTH'", "]/", "365", ",label=", "'target==0'", ")\nsns.kdeplot(app_train.loc[app_train[", "'TARGET'", "]==", "1", ",", "'DAYS_BIRTH'", "]/", "365", ",label=", "'target==1'", ")\nplt.show()\n", "# 能用KDEPLot显示就先用，因为这是连续的，更加直观", "\n", "# 不还钱的人都是30岁左右的人", "\n\nage_data = app_train[[", "'TARGET'", ",", "'DAYS_BIRTH'", "]]\nage_data[", "'YEARS_BIRTH'", "] = age_data[", "'DAYS_BIRTH'", "]/", "365", "\nage_data[", "'YEARS_BINNED'", "] = pd.cut(age_data[", "'YEARS_BIRTH'", "],bins=np.linspace(", "20", ",", "70", ",num=", "11", ")) ", "# 设置年龄区间", "\nage_data.head()\n\nage_groups = age_data.groupby(", "'YEARS_BINNED'", ").mean()\n\nplt.figure(figsize=(", "16", ",", "16", "))\nplt.bar(age_groups.index.astype(", "str", "),", "100", "*age_groups[", "'TARGET'", "])\nplt.xticks(rotation=", "30", ") ", "# 坐标轴，多少度", "\nplt.show()\n\next_data = app_train[[", "'TARGET'", ",", "'EXT_SOURCE_1'", ",", "'EXT_SOURCE_2'", ",", "'EXT_SOURCE_3'", ",", "'DAYS_BIRTH'", "]]\next_data_corrs = ext_data.corr()\nplt.figure(figsize=(", "20", ",", "8", "))\nsns.heatmap(ext_data_corrs,cmap = plt.cm.RdYlBu_r, linewidths = ", ".5", ", annot=", "True", ")\nplt.show()\n", "# http://seaborn.pydata.org/generated/seaborn.heatmap.html", "\n\nplt.figure(figsize=(", "16", ",", "10", "))\n", "for", " i,source ", "in", " ", "enumerate", "([", "'EXT_SOURCE_3'", ",", "'EXT_SOURCE_2'", ",", "'EXT_SOURCE_1'", "]):\n    ", "# 指定好子图的位置", "\n    plt.subplot(", "3", ",", "1", ",i+", "1", ") ", "# 3行1列，位置i=0 i+1", "\n    ", "# kdeplot", "\n    sns.kdeplot(app_train.loc[app_train[", "'TARGET'", "]==", "0", ",source]/", "365", ",label=", "'target==0'", ")\n    sns.kdeplot(app_train.loc[app_train[", "'TARGET'", "]==", "1", ",source]/", "365", ",label=", "'target==1'", ")\n    plt.title(", "'D of %s'", " % source)\nplt.tight_layout(h_pad=", "2.5", ") ", "# 布局 间隙", "\nplt.show()\n\n", "# 特征工程（多项式回归） X次方越大，越准确", "\npoly_features = app_train[[", "'TARGET'", ",", "'EXT_SOURCE_1'", ",", "'EXT_SOURCE_2'", ",", "'EXT_SOURCE_3'", ",", "'DAYS_BIRTH'", "]]\n", "from", " sklearn.preprocessing ", "import", " PolynomialFeatures\n", "from", " sklearn.impute ", "import", " SimpleImputer\n\n", "# 特征工程之前 - 缺失值填充", "\nimputer = SimpleImputer(strategy=", "'median'", ") ", "# 类似于拟合器，遇到缺失值就用中位数来填补", "\npoly_target = poly_features[", "'TARGET'", "]\npoly_features.drop(columns=[", "'TARGET'", "],inplace =", "True", ") ", "# 除了Target列的其他", "\npoly_features = imputer.fit_transform(poly_features) ", "# 拟合", "\n\npoly_transformer = PolynomialFeatures(degree=", "3", ")\npoly_transformer.fit(poly_features)\npoly_features = poly_transformer.transform(poly_features)\n", "# poly_features.shape 从4个特征变成了35个", "\n\npoly_transformer.get_feature_names(input_features=[", "'TARGET'", ",", "'EXT_SOURCE_1'", ",", "'EXT_SOURCE_2'", ",", "'EXT_SOURCE_3'", ",", "'DAYS_BIRTH'", "])[:", "20", "]\n", "# 将当前得到的部分特征跟总体组合在一起", "\npoly_features = pd.DataFrame(\n    poly_features,\n    columns = poly_transformer.get_feature_names(input_features=[", "'TARGET'", ",", "'EXT_SOURCE_1'", ",", "'EXT_SOURCE_2'", ",", "'EXT_SOURCE_3'", ",", "'DAYS_BIRTH'", "])\n)\n\n", "# 与之前100个指标组合在一起", "\npoly_features[", "'SK_ID_CURR'", "] = app_train[", "'SK_ID_CURR'", "] ", "# ID是不会改变的 根据ID去传进去", "\napp_train_poly = app_train.merge(poly_features, on=", "'SK_ID_CURR'", ", how=", "'left'", ")\n\n", "# 根据实际情况来创建特征", "\n", "# 例如对时间特征，可以分出来什么特征呢？ 数据挖掘——90%时间都在和小特征打交道，不要忽视任何一个小的特征", "\n", "# 建模其实没啥花时间", "\napp_train_domain = app_train.copy() ", "# 不要乱改，防止改乱 类似于创建副本", "\n\napp_train_domain[", "'CREDIT_INCOME_PERCENT'", "] = app_train_domain[", "'AMT_CREDIT'", "] / app_train_domain[", "'AMT_INCOME_TOTAL'", "] ", "# 信用额度与工资比值", "\napp_train_domain[", "'ANNUITY_INCOME_PERCENT'", "] = app_train_domain[", "'AMT_ANNUITY'", "] / app_train_domain[", "'AMT_INCOME_TOTAL'", "] ", "# 没（每年）还款年金和工资的比值", "\napp_train_domain[", "'CREDIT_TERM'", "] = app_train_domain[", "'AMT_ANNUITY'", "] / app_train_domain[", "'AMT_CREDIT'", "] ", "# 还款总月份", "\napp_train_domain[", "'DAYS_EMPLOYED_PERCENT'", "] = app_train_domain[", "'DAYS_EMPLOYED'", "] / app_train_domain[", "'DAYS_BIRTH'", "] ", "# 上班时间和年龄的比值", "\n", "# 这是加到了最初的表，和上面的特征工程没啥关系，这是DIY的，所以新的列数为248而不是279", "\n\nplt.figure(figsize=(", "16", ", ", "20", "))\n", "for", " i, feature ", "in", " ", "enumerate", "(\n        [", "'CREDIT_INCOME_PERCENT'", ", ", "'ANNUITY_INCOME_PERCENT'", ", ", "'CREDIT_TERM'", ", ", "'DAYS_EMPLOYED_PERCENT'", "]):\n    plt.subplot(", "4", ", ", "1", ", i + ", "1", ") ", "# 定义子图的位置数量等", "\n    sns.kdeplot(app_train_domain.loc[app_train_domain[", "'TARGET'", "] == ", "0", ", feature], label=", "'target == 0'", ")\n    sns.kdeplot(app_train_domain.loc[app_train_domain[", "'TARGET'", "] == ", "1", ", feature], label=", "'target == 1'", ")\n\n    plt.title(", "'Distribution of %s by Target Value'", " % feature)\n    plt.xlabel(", "'%s'", " % feature);\n    plt.ylabel(", "'Density'", ");\n\nplt.tight_layout(h_pad=", "2.5", ")\nplt.show()\n", "'''\npad：调整边框边距\nw_pad：调整横宽边距\nh_pad：调整纵宽边距\n'''", "\n\n", "# 数据预处理：特征好了后，检查下整合没啥问题就建模了", "\nY = app_train[", "'TARGET'", "]\nX = app_train.drop(columns = [", "'TARGET'", "])\n\n", "from", " sklearn.model_selection ", "import", " train_test_split\nX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=", "0.25", ", random_state=", "0", ")\n\n", "from", " sklearn.preprocessing ", "import", " StandardScaler, MinMaxScaler\nimputer = SimpleImputer(strategy=", "'median'", ")\nstd = StandardScaler()\n", "# 填充", "\nimputer.fit(X_train)\nX_train = imputer.transform(X_train)\nX_test = imputer.transform(X_test)\n", "# 标准化", "\nstd.fit(X_train)\nX_train = std.transform(X_train)\nX_test = std.transform(X_test)\n\n", "from", " sklearn.linear_model ", "import", " LogisticRegression\nclassifier = LogisticRegression(random_state = ", "0", ")\nclassifier.fit(X_train,Y_train)\n\n", "# 用混淆矩阵", "\npredictions = classifier.predict(X_test)\n", "from", " sklearn.metrics ", "import", " confusion_matrix\ncm = confusion_matrix(Y_test, predictions)\n", "# confusion_metrix = 70787/70787+6091 = 92%", "\n\n", "# roc_auc_score", "\npredictions_2 = classifier.predict_proba(X_test)[:,", "1", "]\n", "from", " sklearn.metrics ", "import", " roc_auc_score\ntest_auc = roc_auc_score(Y_test,predictions_2)\n", "# test_auc = 0.7434", "\n\n", "# Visualising the Trainning ser results", "\n", "from", " matplotlib.colors ", "import", " ListedColormap ", "# 给不同的点上不同的颜色", "\nX_set, Y_set = X_train, Y_train\nx1, x2 = np.meshgrid(np.arange(start = X_set[:,", "0", "].", "min", "()-", "1", ", ", "# -1 / +1 都能更方便我们看生成好的图像", "\n                               stop = X_set[:,", "0", "].", "max", "()+", "1", ",\n                               step = ", "0.01", "), ", "# 0.01 看显示屏的参数来设定", "\n                     np.arange(start = X_set[:,", "1", "].", "min", "()-", "1", ",\n                               stop = X_set[:,", "1", "].", "max", "()+", "1", ",\n                               step = ", "0.01", "))\nplt.contourf(\n    x1, x2, classifier.predict(\n        np.array([x1.ravel(),x2.ravel()]).T).reshape(x1.shape),\n    alpha = ", "0.75", ",\n    cmap = ListedColormap((", "'red'", ", ", "'green'", "))\n    )\nplt.xlim(x1.", "min", "(), x1.", "max", "())\nplt.ylim(x2.", "min", "(), x2.", "max", "())\n", "for", " i, j ", "in", " ", "enumerate", "(np.unique(Y_set)): ", "# 画出实际存在的点", "\n    plt.scatter(X_set[Y_set == j, ", "0", "], X_set[Y_set == j, ", "1", "],\n                c = ListedColormap((", "'orange'", ",", "'blue'", "))(i),label=j)\nplt.title(", "'Classifier (Training Set)'", ")\nplt.xlabel(", "'Age'", ")\nplt.ylabel(", "'Estimated Salary'", ")\nplt.legend()\nplt.show()\n\n", "# Visualising the Test set results", "\n", "from", " matplotlib.colors ", "import", " ListedColormap\nX_set, Y_set = X_test, Y_test\nx1, x2 = np.meshgrid(np.arange(start = X_set[:,", "0", "].", "min", "()-", "1", ",\n                               stop = X_set[:,", "0", "].", "max", "()+", "1", ",\n                               step = ", "0.01", "),\n                     np.arange(start = X_set[:,", "1", "].", "min", "()-", "1", ",\n                               stop = X_set[:,", "1", "].", "max", "()+", "1", ",\n                               step = ", "0.01", "))\nplt.contourf(\n    x1, x2, classifier.predict(\n        np.array([x1.ravel(),x2.ravel()]).T).reshape(x1.shape),\n    alpha = ", "0.75", ",\n    cmap = ListedColormap((", "'red'", ", ", "'green'", "))\n    )\nplt.xlim(x1.", "min", "(), x1.", "max", "())\nplt.ylim(x2.", "min", "(), x2.", "max", "())\n", "for", " i, j ", "in", " ", "enumerate", "(np.unique(Y_set)):\n    plt.scatter(X_set[Y_set == j, ", "0", "], X_set[Y_set == j, ", "1", "],\n                c = ListedColormap((", "'orange'", ",", "'blue'", "))(i),label=j)\nplt.title(", "'Classifier (Test Set)'", ")\nplt.xlabel(", "'Age'", ")\nplt.ylabel(", "'Estimated Salary'", ")\nplt.legend()\nplt.show()\n\n", "\n", "运行结果及报错内容", "\n", "Traceback (most recent ", "call", " last):\n  File \"<input>\", ", "line", " ", "210", ", ", "in", " <module>\n  File \"/Users/iven/PycharmProjects/pythonProject/venv/lib/python3.8/site-packages/sklearn/linear_model/_base.py\", ", "line", " ", "447", ", ", "in", " predict\n    scores = self.decision_function(X)\n  File \"/Users/iven/PycharmProjects/pythonProject/venv/lib/python3.8/site-packages/sklearn/linear_model/_base.py\", ", "line", " ", "429", ", ", "in", " decision_function\n    X = self._validate_data(X, accept_sparse=\"csr\", ", "reset", "=", "False", ")\n  File \"/Users/iven/PycharmProjects/pythonProject/venv/lib/python3.8/site-packages/sklearn/base.py\", ", "line", " ", "600", ", ", "in", " _validate_data\n    self._check_n_features(X, ", "reset", "=", "reset", ")\n  File \"/Users/iven/PycharmProjects/pythonProject/venv/lib/python3.8/site-packages/sklearn/base.py\", ", "line", " ", "400", ", ", "in", " _check_n_features\n    ", "raise", " ValueError(\nValueError: X has ", "2", " features, but LogisticRegression ", "is", " expecting ", "243", " features ", "as", " ", "input", ".\n", "\n", "我的解答思路和尝试过的方法：", "\n", "大概只看到这个比较类似，但不知道怎么修改自己的代码：", "https://blog.csdn.net/qq_45128278/article/details/120609776", "\n", "我想要达到的结果", "\n", "但是同样的代码我取另一份没那么多维度的数据集来操作的时候，就能成功画出这幅图：", "\n"]], "Tag": "程序设计"}
