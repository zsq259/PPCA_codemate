{"Answer": "&lt;p&gt;看下你的package.json吧&amp;#xff0c;应该是打包命令的问题。删除--asar 就可以了&lt;/p&gt;", "Konwledge_Point": "过程封装——函数", "Question": ["electron child_process打开子进程报错找不到文件", ["electron-builder --win portable打包成单文件后调用子进程启动内部封装进的一个程序提示找不到文件", "\n", "require('child_process').exec('start file:///static/w.exe');", "其中w.exe放在与src平行的static文件夹下，build后dist/static下面能看到有这个文件w.exe", "但是每次运行执行这里的时候就会报 windows找到不文件 file:///static/w.exe，请确认文件是否存在。", "除这个外其它一切功能正常。", "\n", "有人遇到过类似问题吗？是怎么解决的呢？感谢", "版本信息如下：", "    \"vue\": \"^2.5.2\",", "    \"vue-router\": \"^3.0.1\"", "    \"electron-serve\": \"^1.1.0\",", "    \"electron\": \"^19.0.3\",", "    \"electron-builder\": \"^23.0.3\",", "\n", "electron的main.js代码如下：", "\n", "\n```", "javascript\n", "const", " {app, ", "BrowserWindow", ", ipcMain, ", "Menu", ", shell} = ", "require", "(", "'electron'", ");\n", "const", " path = ", "require", "(", "'path'", ");\n", "const", " url = ", "require", "(", "'url'", ");\n\n", "const", " serve = ", "require", "(", "'electron-serve'", ");\n", "const", " loadURL = ", "serve", "({", "directory", ": ", "'./dist'", "});\n\n", "let", " mainWindow;\n", "function", " ", "createWindow", "(", ") {\n  ", "Menu", ".", "setApplicationMenu", "(", "null", ");  ", "//隐藏菜单栏", "\n  mainWindow = ", "new", " ", "BrowserWindow", "({\n    ", "width", ": ", "800", ",\n    ", "height", ": ", "600", ",\n    ", "frame", ": ", "true", ",     ", "//隐藏窗口边框", "\n    ", "resizable", ": ", "false", ", ", "//禁止调整窗口大小", "\n    ", "webPreferences", ": {\n      ", "nodeIntegration", ": ", "true", ",\n      ", "contextIsolation", ": ", "false", ",\n      ", "enableRemoteModule", ": ", "true", ",\n    }\n  });\n\n  ", "loadURL", "(mainWindow);\n  ", "//mainWindow.loadURL('app://index.html');", "\n  mainWindow.", "webContents", ".", "openDevTools", "({ ", "detach", ": ", "true", " });  ", "// 自动打开调试台", "\n  mainWindow.", "on", "(", "'closed'", ", ", "function", " (", ") { mainWindow = ", "null", "; });\n\n  ", "require", "(", "'child_process'", ").", "exec", "(", "'start file:///static/w.exe'", ");\n  ", "//shell.openPath('file:///static/Wow.exe');", "\n}\n\napp.", "on", "(", "'ready'", ", createWindow);\napp.", "on", "(", "'window-all-closed'", ", ", "function", " (", ") { ", "if", " (process.", "platform", " !== ", "'darwin'", ") app.", "quit", "(); });\napp.", "on", "(", "'activate'", ", ", "function", " (", ") { ", "if", " (mainWindow === ", "null", ") ", "createWindow", "(); });\n\n", "const", " gotTheLock = app.", "requestSingleInstanceLock", "()\n", "if", " (!app.", "requestSingleInstanceLock", "()) app.", "quit", "(); ", "//防止多开", "\n\n", "\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;绝对路径前加r&lt;/p&gt;", "Konwledge_Point": "过程封装——函数", "Question": ["相对路径报错，修改为绝对路径依然报错——no such file or directory", ["\n", " # 封装数据，写入文件\ncomment_dir = {'user': users, 'score': scores, 'time': times, 'comment': comments}\ncomment_df = pd.DataFrame(comment_dir)\ncomment_df.to_csv('./tables/taptap_comments.csv')\ncomment_df['comment'].to_csv('./tables/comments.csv', index=False)\nprint(comment_df)", "\n\n", "疯狂报错", "\n\n", "\n", "发生异常: FileNotFoundError\n[Errno 2] No such file or directory: './tables/taptap_comments.csv'\n  File \"C:\\Users\\Aki\\Desktop\\python\\函数基础\\BS\\taptapciyun.py\", line 48, in crawl_comments\n    comment_df.to_csv('./tables/taptap_comments.csv')\n  File \"C:\\Users\\Aki\\Desktop\\python\\函数基础\\BS\\taptapciyun.py\", line 103, in <module>\n    blacksurvival.crawl_comments()", "\n\n", "改成绝对路径也是依然报错。", "\n\n", "\n", "comment_dir = {'user': users, 'score': scores, 'time': times, 'comment': comments}\ncomment_df = pd.DataFrame(comment_dir)\ncomment_df.to_csv('C:\\\\Users\\Aki\\Desktop\\python\\函数基础\\BS\\taptap_comments.csv')\ncomment_df['comment'].to_csv('./tables/comments.csv', index=False)\nprint(comment_df)", "\n\n", "报错如下：", "\n\n", "\n", "发生异常: OSError\n[Errno 22] Invalid argument: 'C:\\\\Users\\\\Aki\\\\Desktop\\\\python\\\\函数基础\\\\BS\\taptap_comments.csv'\n  File \"C:\\Users\\Aki\\Desktop\\python\\函数基础\\BS\\taptapciyun.py\", line 48, in crawl_comments\n    comment_df.to_csv('C:\\\\Users\\Aki\\Desktop\\python\\函数基础\\BS\\taptap_comments.csv')\n  File \"C:\\Users\\Aki\\Desktop\\python\\函数基础\\BS\\taptapciyun.py\", line 103, in <module>\n    blacksurvival.crawl_comments()"]], "Tag": "程序设计"}
{"Answer": "(1)\r\n当然不是，直接cpu拷贝值。\r\n具体来说就是\r\nmov ptr[变量a的地址], 100\r\n(2)(3)\r\napi是几个动态链接库的函数库。和你自己定义一个函数其实没有什么区别。scanf printf是c的函数库中的函数，它们在底层调用不同的操作系统调用，对于windows来说，就是api函数。\r\n有自己的特定需求，就需要自己在代码中直接调用API函数。前提是api函数中有这个需求的函数调用。\r\nwindows api是面向操作系统的，比如读写文件、输出控制台、创建用户界面，这些api有函数。但是你说，你要写一个算圆周率的，api函数也没有，还得自己写。api函数不是万能的。\r\n\r\n`如果问题解决，麻烦点下回答右边的采纳，谢谢`", "Konwledge_Point": "过程封装——函数", "Question": ["Windows系统下，c语言、c++语言中的给变量赋值，也是最终通过API实现的吗？", ["①例如程序中有一个赋值语句 a=100;  程序执行时，也是转化为调用系统API来将变量a所代表的存储区域赋值100吗？", "\n②对于程序，即是在程序中没有直接使用Windows API ，例如，main函数只包括printf，即只是使用 printf 输出一个内容时，那么程序执行时，也是最终调用系统API来完成输出的吗？", "\n\n", "③Windows API是不是可以这样理解：像scanf printf等是建立在API函数的基础上的，是封装了API函数的集合，换句话说，是别人为了方便而写的一些常用的功能，但是如果有自己的特定需求，就需要自己在代码中直接调用API函数？即printf是别人从Windows几万个API函数中找了一些函数，组装成了 printf，而我在程序中调用API是我自己直接使用API函数，组装printf使用的API函数与我可以直接调用的API函数没有什么特别之处，都是这几万个API函数     ——这样理解API对吗"]], "Tag": "程序设计"}
{"Answer": "问题有些高深，没有答案呀", "Konwledge_Point": "过程封装——函数", "Question": ["捕食者与被捕食者求大神解题C++.", ["    创建简单的二维“捕食者-被捕食者”模拟。在这个模拟中，被捕食者是蚂蚁（ant），捕食者是狮蚁（doodlebug）。这些小生物生活在20×20的网格中。每个单元格每次只能由一个个体占据。网格是封闭的，所以个体不允许离开世界边缘。时间以time step为单位。个体在每个time step里面都要采取某项行动。\n", "\n\n", "蚂蚁的行为像下面这样建模。", "\n Move（移动）：在每个time step中，都随机向上、向下、向左或者向右移动。假如所选方向上的邻居单元格被占据，或者会造成蚂蚁移动到网格的边缘之外，那么蚂蚁就停留在当前的单元格中。", "\n Breed（繁殖）：如果一只蚂蚁在3个time step中保存存活，在第3个time step结束之后（也就是在移动之后），该蚂蚁会繁殖。为了模拟繁殖，需要在相邻（上、下、左或者右）的一个空单元格中创建一只新蚂蚁。没有可用的空单元格，就不会繁殖。一旦成功繁殖出后代，除非再次经历3个time step，否则不能繁殖另一个后代。", "\n\n", "狮蚁的行为像下面这样建模。", "\n Move（移动）：在每个time step中，假如有一只相邻的蚂蚁（上、下、左或者右），就移动到那个单元格，吃掉蚂蚁。否则，狮蚁就按照和蚂蚁相同的规则移动。注意，狮蚁不能吃掉狮蚁。", "\n Breed（繁殖）：假如一只狮蚁在8个time step中保持存活，在第8个time step结束之后，会按照与蚂蚁相同的方式繁殖出一只新狮蚁。", "\n Starve（饥饿）：假如一只狮蚁在连续3个time step中没有吃掉一只蚂蚁，在第3个time step结束之后，它会感到饥饿并死亡。该狮蚁应从网格中拿掉。", "\n 在一轮中，所有狮蚁都应该先于蚂蚁移动。", "\n\n", "写程序来实现这个模拟，使用ASCII字符“o”表示蚂蚁，“x”表示狮蚁。创建名为Organism（有机生物）的类，它封装了通用于蚂蚁和狮蚁的基本数据。该类应该有一个名为Move的virtual函数，它要在派生类Ant和Doodlebug中进行具体的定义。可能需要额外的数据结构来跟踪已移动的生物。", "\n 使用5只狮蚁和100只蚂蚁初始化这个世界。在每个time step后，都提示用户按Enter键移动到下一个time step。应该看到狮蚁和蚂蚁数量的循环变化——虽然一些随机性的混乱可能造成一种或两种生物的毁灭。"]], "Tag": "程序设计"}
{"Answer": "楼上的答案看上去好高大上啊", "Konwledge_Point": "过程封装——函数", "Question": ["C++课程设计 捕食者与被捕食者", ["创建简单的二维“捕食者-被捕食者”模拟。在这个模拟中，被捕食者是蚂蚁（ant），捕食者是狮蚁（doodlebug）。这些小生物生活在20×20的网格中。每个单元格每次只能由一个个体占据。网格是封闭的，所以个体不允许离开世界边缘。时间以time step为单位。个体在每个time step里面都要采取某项行动。", "\n\n", "蚂蚁的行为像下面这样建模。", "\nMove（移动）：在每个time step中，都随机向上、向下、向左或者向右移动。假如所选方向上的邻居单元格被占据，或者会造成蚂蚁移动到网格的边缘之外，那么蚂蚁就停留在当前的单元格中。", "\nBreed（繁殖）：如果一只蚂蚁在3个time step中保存存活，在第3个time step结束之后（也就是在移动之后），该蚂蚁会繁殖。为了模拟繁殖，需要在相邻（上、下、左或者右）的一个空单元格中创建一只新蚂蚁。没有可用的空单元格，就不会繁殖。一旦成功繁殖出后代，除非再次经历3个time step，否则不能繁殖另一个后代。", "\n\n", "狮蚁的行为像下面这样建模。", "\nMove（移动）：在每个time step中，假如有一只相邻的蚂蚁（上、下、左或者右），就移动到那个单元格，吃掉蚂蚁。否则，狮蚁就按照和蚂蚁相同的规则移动。注意，狮蚁不能吃掉狮蚁。", "\nBreed（繁殖）：假如一只狮蚁在8个time step中保持存活，在第8个time step结束之后，会按照与蚂蚁相同的方式繁殖出一只新狮蚁。", "\nStarve（饥饿）：假如一只狮蚁在连续3个time step中没有吃掉一只蚂蚁，在第3个time step结束之后，它会感到饥饿并死亡。该狮蚁应从网格中拿掉。", "\n在一轮中，所有狮蚁都应该先于蚂蚁移动。", "\n\n", "写程序来实现这个模拟，使用ASCII字符“o”表示蚂蚁，“x”表示狮蚁。创建名为Organism（有机生物）的类，它封装了通用于蚂蚁和狮蚁的基本数据。该类应该有一个名为Move的virtual函数，它要在派生类Ant和Doodlebug中进行具体的定义。可能需要额外的数据结构来跟踪已移动的生物。", "\n使用5只狮蚁和100只蚂蚁初始化这个世界。在每个time step后，都提示用户按Enter键移动到下一个time step。应该看到狮蚁和蚂蚁数量的循环变化——虽然一些随机性的混乱可能造成一种或两种生物的毁灭。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ok,搞定了&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;引发错误的地方在于&amp;#xff1a;傅里叶逆变换&amp;#xff0c;实数部分和虚数部分都需要除N&amp;#xff0c;你只给实数部分除了N&amp;#xff0c;一维数据没有问题是因为&amp;#xff0c;你的一维数据全是实数&amp;#xff0c;逆变换后虚数部分为0&amp;#xff0c;所以不影响&amp;#xff1b;而二维傅里叶变换需要两次逆变换&amp;#xff08;行和列的逆变换&amp;#xff09;&amp;#xff0c;因此就有了较大影响&amp;#xff1b;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT &amp;#61; WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i &amp;#61; 0; i &amp;lt; FD2TD.Length; i&amp;#43;&amp;#43;)\n        {\n            FD2TD[i].re /&amp;#61; FD2TD.Length;\n            FD2TD[i].im /&amp;#61; FD2TD.Length;\n        }\n    }&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;这样改一下就好了&amp;#xff0c;我不太会输出txt&amp;#xff0c;我用控制台输出试了一下&amp;#xff0c;这是逆变换以后的数据&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"925\" src=\"https://img-ask.csdnimg.cn/upload/1616415175974.png\" width=\"398\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;ok,误差在可忽略的范围内&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;还有一个规范性的问题&amp;#xff0c;一般矩阵&amp;#xff08;row,columns&amp;#xff09;的行是row(Height),列是columns(Width),你刚开始初始化时确实是这么定义的&amp;#xff0c;但后面你就全部反着来了&amp;#xff0c;因为这次输入的是8*8的数据&amp;#xff0c;行列数相等&amp;#xff0c;没有报错&amp;#xff0c;如果下个数据行列数不相等&amp;#xff0c;就有错了&amp;#xff0c;还是规范起来写的好。&amp;#xff08;这个问题不影响你的这次的结果&amp;#xff0c;但还是改掉的好&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "过程封装——函数", "Question": ["我写的二维傅里叶逆变换未还原数据，求帮忙调试下!", ["先说下问题：", "\n\n", "我用8x8的数据测试FFT2和IFFT2两个算法，发现数据未还原，求帮忙检查下代码哪写错了？", "\n\n", "(注：如果只对每一行或者每一列做FFT和IFFT，可以还原数据。)", "\n\n", "打印的日志下如", "\n\n", "\n\n", "封装的傅里叶变换类", "\n\n", "\n", "using System;\n\n/// <summary>\n/// 傅里叶变换\n/// </summary>\npublic sealed class Fourier\n{\n    //快速傅里叶变换\n    public static void FFT(Complex[] TD2FD)\n    {\n        FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n    }\n\n    //快速傅里叶变换 (二维)\n    public static void FFT2(Complex2D TD2FD)\n    {\n        //对每一行做FFT\n        for (int i = 0; i < TD2FD.Height; i++)\n        {\n            Complex[] row = TD2FD.GetRow(i);\n            FFT(row);\n            TD2FD.SetRow(i, row);\n        }\n\n        //对每一列做FFT\n        for (int i = 0; i < TD2FD.Width; i++)\n        {\n            Complex[] column = TD2FD.GetColumn(i);\n            FFT(column);\n            TD2FD.SetColumn(i, column);\n        }\n    }\n\n    //快速傅里叶逆变换\n    public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT = WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i = 0; i < FD2TD.Length; i++)\n            FD2TD[i].re /= FD2TD.Length;\n    }\n\n    //快速傅里叶逆变换 (二维)\n    public static void IFFT2(Complex2D FD2TD)\n    {\n        //对每一行做IFFT\n        for (int i = 0; i < FD2TD.Height; i++)\n        {\n            Complex[] row = FD2TD.GetRow(i);\n            IFFT(row);\n            FD2TD.SetRow(i, row);\n        }\n\n        //对每一列做IFFT\n        for (int i = 0; i < FD2TD.Width; i++)\n        {\n            Complex[] column = FD2TD.GetColumn(i);\n            IFFT(column);\n            FD2TD.SetColumn(i, column);\n        }\n    }\n\n    // 将直流分量移到频谱图的中心\n    public static void FFT2Shift(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        //将图像四个象限区域按对角线交换\n        for (int i=0; i<halfH; i++)\n        {\n            for (int j=0; j<complex2D.Width; j++)\n            {\n                if (j < halfW)\n                    complex2D.SwapComplex(i, j, i + halfH, j + halfW);\n                else\n                    complex2D.SwapComplex(i, j, i + halfH, j - halfW);\n            }\n        }\n    }\n\n    // 高通滤波\n    public static void HighPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i = halfH - H4; i < halfH + H4; i++)\n        {\n            for (int j = halfW - W4; j < halfW + W4; j++)\n            {\n                Complex cpx = complex2D.GetComplex(i, j);\n                cpx.re = 0;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n    }\n\n    // 低通滤波\n    public static void LowPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i=0; i < complex2D.Height; i++)\n        {\n            for (int j=0; j < complex2D.Width; j++)\n            {\n                if (i < halfH - H4 || i > halfH + H4 ||\n                    j < halfW - W4 || j > halfW + W4)\n                {\n                    Complex cpx = complex2D.GetComplex(i, j);\n                    cpx.re = 0;\n                    cpx.im = 0;\n                    complex2D.SetComplex(i, j, cpx);\n                }\n            }    \n        }\n    }\n\n    // 返回旋转因子查询表(twiddle factor lookup table)\n    private static Complex[] WT_LUT(int N, int flag = 1)\n    {\n        Complex[] WT = new Complex[N];\n        for (int i = 0; i < N; i++)\n        {\n            Complex cpx_wt = new Complex();\n            float angle = (float)(-i * Math.PI * 2 / N);\n            cpx_wt.re = (float)Math.Cos(angle);\n            //IFFT flag=-1, FFT flag=1\n            cpx_wt.im = flag * (float)Math.Sin(angle);\n            WT[i] = cpx_wt;\n        }\n        return WT;\n    }\n\n    private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n    {\n        int power = (int)Math.Log(TD2FD.Length, 2);\n        int butterfly;\n        int p, s;\n        Complex x1, x2, wt;\n\n        //倒位排序\n        BitReverse(TD2FD);\n\n        //蝶形运算\n        for (int k = 0; k < power; k++) //级数\n        {\n            for (int j = 0; j < 1 << (power - k - 1); j++) //组数\n            {\n                //每组有几个元素\n                butterfly = 1 << k + 1;\n                //计算参与蝶形运算的两个元素的索引\n                p = j * butterfly;\n                s = p + butterfly / 2;\n                for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                {\n                    x1 = TD2FD[i + p];\n                    x2 = TD2FD[i + s];\n                    wt = WT[i * TD2FD.Length / butterfly];\n                    TD2FD[i + p] = x1 + x2 * wt;\n                    TD2FD[i + s] = x1 - x2 * wt;\n                }\n            }\n        }\n    }\n\n    // 倒位排序——雷德算法\n    private static void BitReverse(Complex[] array)\n    {\n        //倒位排序原理\n        //0   1   2   3   4   5   6   7   十进制\n        //000 001 010 011 100 101 110 111 十进制对应的二进制\n        //000 100 010 110 001 101 011 111 码位反转\n        //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n\n        int i, j, k;\n        int N = array.Length;\n        Complex temp;\n        j = 0;\n\n        for (i = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n            // 求j的下一个倒序位\n            // N/2的二进制最高位为1，其他位都为0\n            // 判断最高位是否为1，可与N/2进行比较\n            // 判断次高位是否为1，可与N/4进行比较\n            k = N >> 1;\n            //如果k<=j,表示j的最高位为1\n            while (k <= j)\n            {\n                //当k<=j时，需要将最高位变为0\n                j = j - k;\n                //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                k >>= 1;\n            }\n            j = j + k;//将0变为1\n        }\n    }\n\n    // 打印\n    public static void Print(Complex[] TD2FD)\n    {\n        for (int i = 0; i < TD2FD.Length; i++)\n        {\n            Console.WriteLine(TD2FD[i].ToString());\n        }\n        Console.WriteLine();\n    }\n}\n\n//定义复数\npublic class Complex\n{\n    public float re;//实数部\n    public float im;//虚数部\n\n    // 幅值\n    public double Amplitude\n    {\n        get\n        {\n            //测试发现取值范围为\n            //min=0.0009918213, max=412.4615\n            return Math.Sqrt(re * re + im * im);\n        }\n    }\n\n    // 频谱图像素值\n    public double PixelAmplitude\n    {\n        get\n        {\n            //幅值范围很大,需要做以下处理:\n            //1. 将幅值范围调到 [1, ?]\n            //2. 利用Log函数压缩范围\n            //3. 将范围映射到颜色值[0,1]\n            double p = Math.Log(Amplitude * 10000) / 16f;\n            return p;\n        }\n    }\n\n    // 相位\n    public double Phase\n    {\n        get\n        {\n            return Math.Atan2(im, re);\n        }\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"re={0}, im={1}\", re, im);\n    }\n\n    public static Complex operator +(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re + rhs.re;\n        result.im = lhs.im + rhs.im;\n        return result;\n    }\n\n    public static Complex operator -(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re - rhs.re;\n        result.im = lhs.im - rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs.re - lhs.im * rhs.im;\n        result.im = lhs.re * rhs.im + lhs.im * rhs.re;\n        return result;\n    }\n\n    public static Complex operator *(float lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs * rhs.re;\n        result.im = lhs * rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, float rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs;\n        result.im = lhs.im * rhs;\n        return result;\n    }\n}\n\npublic class Complex2D\n{\n    private Complex[,] matrix;\n    private int m_width;\n    private int m_height;\n\n    // width:图像宽度 height:图像高度\n    public Complex2D(int width, int height)\n    {\n        m_width = width;\n        m_height = height;\n        matrix = new Complex[width, height];\n    }\n\n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n\n    public Complex[] GetRow(int i)\n    {\n        Complex[] row = new Complex[m_width];\n        for (int j = 0; j < m_width; j++)\n            row[j] = matrix[j,i];\n        return row;\n    }\n\n    public void SetRow(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[j, i] = array[j];\n    }\n\n    public Complex[] GetColumn(int i)\n    {\n        Complex[] column = new Complex[m_height];\n        for (int j = 0; j < m_height; j++)\n            column[j] = matrix[i,j];\n        return column;\n    }\n\n    public void SetColumn(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[i, j] = array[j];\n    }\n\n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return matrix[j,i];\n    }\n\n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        matrix[j, i] = src;\n    }\n\n    // 交换两个元素\n    // i: 第几行  j: 第几列\n    public void SwapComplex(int i0, int j0, int i1, int j1)\n    {\n        Complex tmp = matrix[j0,i0];\n        matrix[j0, i0] = matrix[j1, i1];\n        matrix[j1, i1] = tmp;\n    }\n\n    // 交换行\n    public void SwapRow(int i, int j)\n    {\n        for (int k=0; k<m_width; k++)\n        {\n            Complex cpx0 = matrix[k,i];\n            Complex cpx1 = matrix[k,j];\n            matrix[k,i] = cpx1;\n            matrix[k,j] = cpx0;\n        }\n    }\n\n    // 交换列\n    public void SwapColumn(int i, int j)\n    {\n        for (int k = 0; k < m_height; k++)\n        {\n            Complex cpx0 = matrix[i,k];\n            Complex cpx1 = matrix[j,k];\n            matrix[i,k] = cpx1;\n            matrix[j,k] = cpx0;\n        }\n    }\n\n    public void Print(string fileName)\n    {\n        System.Text.StringBuilder sb = new System.Text.StringBuilder();\n        for (int i = 0; i < m_height; i++)\n        {\n            for (int j = 0; j < m_width; j++)\n                sb.AppendFormat(\"{0:G} \", matrix[j,i].re.ToString().PadRight(5));\n            sb.AppendLine();\n        }\n        System.IO.File.WriteAllText(string.Format(\"D://{0}.txt\", fileName), sb.ToString());\n    }\n}\n", "\n\n", "测试代码", "\n\n", "\n", "//测试\n        Complex2D complex2D = new Complex2D(8, 8);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            for (int j = 0; j < complex2D.Width; j++)\n            {\n                Complex cpx = new Complex();\n                cpx.re = i * complex2D.Width + j;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n\n        complex2D.Print(\"8x8\");\n        Fourier.FFT2(complex2D);\n        complex2D.Print(\"fft2\");\n        Fourier.IFFT2(complex2D);\n        complex2D.Print(\"ifft2\");"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先说你程序的错误&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;傅里叶变换和逆变换都没毛病&amp;#xff0c;但你的二维复数矩阵的定义&amp;#xff0c;错了&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;我标出来了&amp;#xff0c;你自己应该能改出来&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cs\"&gt;public class Complex2D\n{\n    private List&amp;lt;Complex[]&amp;gt; rows &amp;#61; new List&amp;lt;Complex[]&amp;gt;();\n    private List&amp;lt;Complex[]&amp;gt; columns &amp;#61; new List&amp;lt;Complex[]&amp;gt;();\n    private int m_width;\n    private int m_height;\n \n    public Complex2D(int width, int height)\n    {\n        m_width &amp;#61; width;\n        m_height &amp;#61; height;\n        for (int i &amp;#61; 0; i &amp;lt; height; i&amp;#43;&amp;#43;)\n            rows.Add(new Complex[width]);   //row[0]~row[height-1]\n        for (int i &amp;#61; 0; i &amp;lt; width; i&amp;#43;&amp;#43;)\n            columns.Add(new Complex[height]);//columns[0]~columns[height-1]\n    }                                        //你这里相当于定义了两个矩阵&amp;#xff0c;一个是行向量组成&amp;#xff0c;一个列向量组成&amp;#xff1b;按你的思路&amp;#xff0c;你后面的应该始终保持这两个矩阵相等才对&amp;#xff1b;\n \n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n \n    public Complex[] GetRow(int i)\n    {\n        return rows[i];\n    }\n \n    public Complex[] GetColumn(int i)\n    {\n        return columns[i];\n    }\n \n    public void SetRow(int i, Complex[] src)\n    {\n        rows[i] &amp;#61; src;  //你只行向量&amp;#xff1f;&amp;#xff1f;你如果改了第一行的值&amp;#xff0c;那每一列的第一个值也就跟着变了&amp;#xff0c;你没改&amp;#xff0c;你如果此时读第一列的值&amp;#xff0c;你会发现row[i][j],columns[j][i],不一样\n    }\n \n    public void SetColumn(int i, Complex[] src)\n    {\n        columns[i] &amp;#61; src;  //和上面同理\n    }\n \n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return rows[i][j];  //你的更改行和列有问题&amp;#xff0c;columns[j][i]和row[i][j]不一样了\n    }\n \n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        rows[i][j] &amp;#61; src;   //额。。。。你这里行和列改了&amp;#xff0c;说明你注意到了&amp;#xff0c;然而前面却不改。。\n        columns[j][i] &amp;#61; src;\n    }\n \n    public void SetComplexs(Complex[][] src)\n    {\n        for (int i &amp;#61; 0; i &amp;lt; src.Length; i&amp;#43;&amp;#43;)\n        {\n            Complex[] row &amp;#61; src[i];      //这里你又是只改变了row的值&amp;#xff0c;不改columns\n            for (int j &amp;#61; 0; j &amp;lt; row.Length; j&amp;#43;&amp;#43;)\n                SetComplex(i, j, row[j]);\n        }\n    }\n \n    public void Print()\n    {\n        for (int i &amp;#61; 0; i &amp;lt; rows.Count; i&amp;#43;&amp;#43;)\n        {\n            Complex[] row &amp;#61; rows[i];\n            for (int j &amp;#61; 0; j &amp;lt; row.Length; j&amp;#43;&amp;#43;)\n                Console.Write(&amp;#34;{0:G} &amp;#34;, row[j].re.ToString().PadRight(5));\n            Console.WriteLine();\n        }\n        Console.WriteLine();\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;1.你的傅里叶变换没问题&amp;#xff1b;我看了几遍&amp;#xff0c;确实找不出有啥问题&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;2.是幅度&amp;#xff08;模&amp;#xff09;&amp;#xff0c;还要考虑复数部&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;3.应该不对&amp;#xff0c;我记得中心化应该是把矩阵分成四块&amp;#xff0c;重新排序&amp;#xff0c;你写的shift没看懂什么意思&amp;#xff0c;不过就算不考虑中心化&amp;#xff0c;你的图也不对&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;下面四张图分别是&amp;#xff0c;中心化后的实部&amp;#xff0c;虚部&amp;#xff0c;幅度&amp;#xff0c;和未中心化的幅度谱&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"828\" src=\"https://img-ask.csdnimg.cn/upload/1616123239140.png\" width=\"974\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;C#我不太懂&amp;#xff0c;我用python写的&amp;#xff0c;求幅度&amp;#xff08;模&amp;#xff09;&amp;#xff0c;然后中心化&amp;#xff0c;在取对数&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;freq &amp;#61; 20*np.log10(0.01 &amp;#43; np.abs(fp.fftshift(freq1)))&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;看你的情况&amp;#xff0c;应该把二维复数那一块改一改应该就好了&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "过程封装——函数", "Question": ["请教下关于FFT算法生成频谱图的问题", ["我理解的大体思路是：", "\n\n", "1、将图像的灰度值作为输入数据代入FFT算法，生成结果A", "\n\n", "2、直接用A的实部值作为像素值生成频谱图", "\n\n", "但是我发现生成的频谱图布局不对。", "\n\n", "用幅度值作为像素值生成的频谱图", "\n\n", "\n\n", "\n\n", "现在我有3个疑问：", "\n\n", "1、将图像灰度值数据代入FFT，再直接IFFT，得到一张正确的灰度图像，是否说明写的FFT和IFFT算法没问题？", "\n\n", "2、频谱图的像素值是由FFT结果数据的实部值生成吗？", "\n\n", "3、代码中的中心化方法FFT2Shift()是我这样写的吗（不确定对公式是否理解正确）？", "\n\n", " ", "\n\n", "在线对图像做傅里叶变换 ", "https://sci2fig.herokuapp.com/fourier", "\n\n", "\n\n", " ", "\n\n", "下面给出我封装的傅里叶变换类", "\n\n", "\n", "using System;\n\n/// <summary>\n/// 傅里叶变换\n/// </summary>\npublic sealed class Fourier\n{\n    //快速傅里叶变换\n    public static void FFT(Complex[] TD2FD)\n    {\n        FFT_Core(TD2FD, WT_LUT(TD2FD.Length, 1));\n    }\n\n    //快速傅里叶变换 (二维)\n    public static void FFT2(Complex2D TD2FD)\n    {\n        //对每一行做FFT\n        for (int i = 0; i < TD2FD.Height; i++)\n        {\n            Complex[] row = TD2FD.GetRow(i);\n            FFT(row);\n            TD2FD.SetRow(i, row);\n        }\n\n        //对每一列做FFT\n        for (int i = 0; i < TD2FD.Width; i++)\n        {\n            Complex[] column = TD2FD.GetColumn(i);\n            FFT(column);\n            TD2FD.SetColumn(i, column);\n        }\n    }\n\n    //快速傅里叶逆变换\n    public static void IFFT(Complex[] FD2TD)\n    {\n        //做FFT变换\n        Complex[] WT = WT_LUT(FD2TD.Length, -1);\n        FFT_Core(FD2TD, WT);\n        //实部除以N\n        for (int i = 0; i < FD2TD.Length; i++)\n            FD2TD[i].re /= FD2TD.Length;\n    }\n\n    //快速傅里叶逆变换 (二维)\n    public static void IFFT2(Complex2D FD2TD)\n    {\n        //对每一行做IFFT\n        for (int i = 0; i < FD2TD.Height; i++)\n        {\n            Complex[] row = FD2TD.GetRow(i);\n            IFFT(row);\n            FD2TD.SetRow(i, row);\n        }\n\n        //对每一列做IFFT\n        for (int i = 0; i < FD2TD.Width; i++)\n        {\n            Complex[] column = FD2TD.GetColumn(i);\n            IFFT(column);\n            FD2TD.SetColumn(i, column);\n        }\n    }\n\n    // 将直流分量移到频谱图的中心\n    public static void FFT2Shift(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        //将图像四个象限区域按对角线交换\n        for (int i=0; i<halfH; i++)\n        {\n            for (int j=0; j<complex2D.Width; j++)\n            {\n                if (j < halfW)\n                    complex2D.SwapComplex(i, j, i + halfH, j + halfW);\n                else\n                    complex2D.SwapComplex(i, j, i + halfH, j - halfW);\n            }\n        }\n    }\n\n    // 高通滤波\n    public static void HighPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i = halfH - H4; i < halfH + H4; i++)\n        {\n            for (int j = halfW - W4; j < halfW + W4; j++)\n            {\n                Complex cpx = complex2D.GetComplex(i, j);\n                cpx.re = 0;\n                cpx.im = 0;\n                complex2D.SetComplex(i, j, cpx);\n            }\n        }\n    }\n\n    // 低通滤波\n    public static void LowPassFilting(Complex2D complex2D)\n    {\n        int halfH = complex2D.Height / 2;\n        int halfW = complex2D.Width / 2;\n        int H4 = complex2D.Height / 8;\n        int W4 = complex2D.Width / 8;\n        for (int i=0; i < complex2D.Height; i++)\n        {\n            for (int j=0; j < complex2D.Width; j++)\n            {\n                if (i < halfH - H4 || i > halfH + H4 ||\n                    j < halfW - W4 || j > halfW + W4)\n                {\n                    Complex cpx = complex2D.GetComplex(i, j);\n                    cpx.re = 0;\n                    cpx.im = 0;\n                    complex2D.SetComplex(i, j, cpx);\n                }\n            }    \n        }\n    }\n\n    // 返回旋转因子查询表(twiddle factor lookup table)\n    private static Complex[] WT_LUT(int N, int flag = 1)\n    {\n        Complex[] WT = new Complex[N];\n        for (int i = 0; i < N; i++)\n        {\n            Complex cpx_wt = new Complex();\n            float angle = (float)(-i * Math.PI * 2 / N);\n            cpx_wt.re = (float)Math.Cos(angle);\n            //IFFT flag=-1, FFT flag=1\n            cpx_wt.im = flag * (float)Math.Sin(angle);\n            WT[i] = cpx_wt;\n        }\n        return WT;\n    }\n\n    private static void FFT_Core(Complex[] TD2FD, Complex[] WT)\n    {\n        int power = (int)Math.Log(TD2FD.Length, 2);\n        int butterfly;\n        int p, s;\n        Complex x1, x2, wt;\n\n        //倒位排序\n        BitReverse(TD2FD);\n\n        //蝶形运算\n        for (int k = 0; k < power; k++) //级数\n        {\n            for (int j = 0; j < 1 << (power - k - 1); j++) //组数\n            {\n                //每组有几个元素\n                butterfly = 1 << k + 1;\n                //计算参与蝶形运算的两个元素的索引\n                p = j * butterfly;\n                s = p + butterfly / 2;\n                for (int i = 0; i < butterfly / 2; i++) //蝶形运算次数\n                {\n                    x1 = TD2FD[i + p];\n                    x2 = TD2FD[i + s];\n                    wt = WT[i * TD2FD.Length / butterfly];\n                    TD2FD[i + p] = x1 + x2 * wt;\n                    TD2FD[i + s] = x1 - x2 * wt;\n                }\n            }\n        }\n    }\n\n    // 倒位排序——雷德算法\n    private static void BitReverse(Complex[] array)\n    {\n        //倒位排序原理\n        //0   1   2   3   4   5   6   7   十进制\n        //000 001 010 011 100 101 110 111 十进制对应的二进制\n        //000 100 010 110 001 101 011 111 码位反转\n        //0   4   2   6   1   5   3   7   码位反转后对应的十进制\n\n        int i, j, k;\n        int N = array.Length;\n        Complex temp;\n        j = 0;\n\n        for (i = 0; i < N - 1; i++)\n        {\n            if (i < j)\n            {\n                temp = array[i];\n                array[i] = array[j];\n                array[j] = temp;\n            }\n            // 求j的下一个倒序位\n            // N/2的二进制最高位为1，其他位都为0\n            // 判断最高位是否为1，可与N/2进行比较\n            // 判断次高位是否为1，可与N/4进行比较\n            k = N >> 1;\n            //如果k<=j,表示j的最高位为1\n            while (k <= j)\n            {\n                //当k<=j时，需要将最高位变为0\n                j = j - k;\n                //判断次高位是否为1,依次类推，逐个比较，直到j某个位为0\n                k >>= 1;\n            }\n            j = j + k;//将0变为1\n        }\n    }\n\n    // 打印\n    public static void Print(Complex[] TD2FD)\n    {\n        for (int i = 0; i < TD2FD.Length; i++)\n        {\n            Console.WriteLine(TD2FD[i].ToString());\n        }\n        Console.WriteLine();\n    }\n}\n\n//定义复数\npublic class Complex\n{\n    public float re;//实数部\n    public float im;//虚数部\n\n    // 幅值\n    public double Amplitude\n    {\n        get\n        {\n            //测试发现取值范围为\n            //min=0.0009918213, max=412.4615\n            return Math.Sqrt(re * re + im * im);\n        }\n    }\n\n    // 频谱图像素值\n    public double PixelAmplitude\n    {\n        get\n        {\n            //幅值范围很大,需要做以下处理:\n            //1. 将幅值范围调到 [1, ?]\n            //2. 利用Log函数压缩范围\n            //3. 将范围映射到颜色值[0,1]\n            double p = Math.Log(Amplitude * 10000) / 16f;\n            return p;\n        }\n    }\n\n    // 相位\n    public double Phase\n    {\n        get\n        {\n            return Math.Atan2(im, re);\n        }\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"re={0}, im={1}\", re, im);\n    }\n\n    public static Complex operator +(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re + rhs.re;\n        result.im = lhs.im + rhs.im;\n        return result;\n    }\n\n    public static Complex operator -(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re - rhs.re;\n        result.im = lhs.im - rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs.re - lhs.im * rhs.im;\n        result.im = lhs.re * rhs.im + lhs.im * rhs.re;\n        return result;\n    }\n\n    public static Complex operator *(float lhs, Complex rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs * rhs.re;\n        result.im = lhs * rhs.im;\n        return result;\n    }\n\n    public static Complex operator *(Complex lhs, float rhs)\n    {\n        Complex result = new Complex();\n        result.re = lhs.re * rhs;\n        result.im = lhs.im * rhs;\n        return result;\n    }\n}\n\npublic class Complex2D\n{\n    private Complex[,] matrix;\n    private int m_width;\n    private int m_height;\n\n    // width:图像宽度 height:图像高度\n    public Complex2D(int width, int height)\n    {\n        m_width = width;\n        m_height = height;\n        matrix = new Complex[width, height];\n    }\n\n    public int Width { get { return m_width; } }\n    public int Height { get { return m_height; } }\n\n    public Complex[] GetRow(int i)\n    {\n        Complex[] row = new Complex[m_width];\n        for (int j = 0; j < m_width; j++)\n            row[j] = matrix[j,i];\n        return row;\n    }\n\n    public void SetRow(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[j, i] = array[j];\n    }\n\n    public Complex[] GetColumn(int i)\n    {\n        Complex[] column = new Complex[m_height];\n        for (int j = 0; j < m_height; j++)\n            column[j] = matrix[i,j];\n        return column;\n    }\n\n    public void SetColumn(int i, Complex[] array)\n    {\n        for (int j = 0; j < m_width; j++)\n            matrix[i, j] = array[j];\n    }\n\n    //i: 第几行  j: 第几列\n    public Complex GetComplex(int i, int j)\n    {\n        return matrix[j,i];\n    }\n\n    //i: 第几行  j: 第几列\n    public void SetComplex(int i, int j, Complex src)\n    {\n        matrix[j, i] = src;\n    }\n\n    // 交换两个元素\n    // i: 第几行  j: 第几列\n    public void SwapComplex(int i0, int j0, int i1, int j1)\n    {\n        Complex tmp = matrix[j0,i0];\n        matrix[j0, i0] = matrix[j1, i1];\n        matrix[j1, i1] = tmp;\n    }\n\n    // 交换行\n    public void SwapRow(int i, int j)\n    {\n        for (int k=0; k<m_width; k++)\n        {\n            Complex cpx0 = matrix[k,i];\n            Complex cpx1 = matrix[k,j];\n            matrix[k,i] = cpx1;\n            matrix[k,j] = cpx0;\n        }\n    }\n\n    // 交换列\n    public void SwapColumn(int i, int j)\n    {\n        for (int k = 0; k < m_height; k++)\n        {\n            Complex cpx0 = matrix[i,k];\n            Complex cpx1 = matrix[j,k];\n            matrix[i,k] = cpx1;\n            matrix[j,k] = cpx0;\n        }\n    }\n\n    public void Print(string fileName)\n    {\n        System.Text.StringBuilder sb = new System.Text.StringBuilder();\n        for (int i = 0; i < m_height; i++)\n        {\n            for (int j = 0; j < m_width; j++)\n                sb.AppendFormat(\"{0:G} \", matrix[j,i].re.ToString().PadRight(5));\n            sb.AppendLine();\n        }\n        System.IO.File.WriteAllText(string.Format(\"D://{0}.txt\", fileName), sb.ToString());\n    }\n}\n", "\n\n", "我的测试是在Unity中做的，下面给出我的辅助类", "\n\n", "\n", "using UnityEngine;\n\npublic sealed class FourierHelper\n{\n    public static Texture2D ToTexture2D(Complex2D complex2D)\n    {\n        Texture2D tex = new Texture2D(complex2D.Width, complex2D.Height, TextureFormat.RGBA32, false);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            Complex[] cpxs = complex2D.GetRow(i);\n            for (int j = 0; j < cpxs.Length; j++)\n            {\n                Complex cpx = cpxs[j];\n                tex.SetPixel(j, i, new Color(cpx.re, cpx.re, cpx.re));\n            }\n        }\n        tex.Apply();\n        return tex;\n    }\n\n    // 转成频谱图\n    public static Texture2D ToSpectrumTexture2D(Complex2D complex2D)\n    {\n        float min = float.MaxValue;\n        float max = float.MinValue;\n        Texture2D tex = new Texture2D(complex2D.Width, complex2D.Height, TextureFormat.RGBA32, false);\n        for (int i = 0; i < complex2D.Height; i++)\n        {\n            Complex[] cpxs = complex2D.GetRow(i);\n            for (int j = 0; j < cpxs.Length; j++)\n            {\n                Complex cpx = cpxs[j];\n                float p = (float)cpx.PixelAmplitude;\n                tex.SetPixel(j, i, new Color(p, p, p));\n                if (p < min)\n                    min = p;\n                if (p > max)\n                    max = p;\n            }\n        }\n        tex.Apply();\n        return tex;\n    }\n\n    public static Complex2D ToComplex2D(Texture2D tex)\n    {\n        Complex2D complex2D = new Complex2D(tex.width, tex.height);\n\n        for (int y = 0; y < tex.height; y++)\n        {\n            for (int x = 0; x < tex.width; x++)\n            {\n                Color c = tex.GetPixel(x, y);\n                Complex cpx = new Complex();\n                cpx.re = c.r * 0.3f + c.g * 0.59f + c.b * 0.11f; //灰度值\n                cpx.im = 0;\n                complex2D.SetComplex(y, x, cpx);\n            }\n        }\n\n        return complex2D;\n    }\n}\n", "\n\n", "FFT->IFFT测试代码", "\n\n", "\n", "using UnityEngine;\nusing UnityEngine.UI;\n/// <summary>\n/// 测试FFT->IFFT算法\n/// </summary>\npublic class FFT_IFFT_Test : MonoBehaviour\n{\n    public RawImage rawImage;\n\n    private void Start()\n    {\n        Texture2D tex = rawImage.texture as Texture2D;\n        Complex2D complex2D = FourierHelper.ToComplex2D(tex);\n\n        Fourier.FFT2(complex2D);\n        Fourier.IFFT2(complex2D);\n\n        Texture2D ifft_tex = FourierHelper.ToTexture2D(complex2D);\n        rawImage.texture = ifft_tex;\n    }\n}\n", "\n\n", "频谱图生成代码", "\n\n", "\n", "using UnityEngine;\nusing UnityEngine.UI;\n/// <summary>\n/// 显示频谱图\n/// </summary>\npublic class SpectrumTexture : MonoBehaviour\n{\n    public RawImage rawImage;\n\n    private void Start()\n    {\n        Texture2D tex = rawImage.texture as Texture2D;\n        Complex2D complex2D = FourierHelper.ToComplex2D(tex);\n\n        Fourier.FFT2(complex2D);\n\n        Texture2D sp_tex = FourierHelper.ToTexture2D(complex2D);\n        rawImage.texture = sp_tex;\n    }\n}\n", "\n\n", "如有需要也可下载我的测试工程(Unity)", "\n\n", "链接：https://pan.baidu.com/s/1B62muufCP-tWQklPT5H49Q ", "\n提取码：z6ku ", "\n\n", " ", "\n\n", "补充：IFFT2未还原数据", "\n\n", "@ 皮皮宽", "\n\n"]], "Tag": "程序设计"}
