{"Answer": "creation的形参不需要加取地址符&amp;", "Konwledge_Point": "间接访问——指针", "Question": ["C语言 间接级别不同（指针和指针函数方面）", ["出现指针和指针函数级别不同的问题。（初学者，代码比较小白轻喷）", "\n\n", "在每一个函数给指针赋值的时候都出现这个问题。", "\n\n", "下面是警告内容warning: passing argument 1 of 'creation' from incompatible pointer type", "\n\n", "顺便提问一下给指针分配空间的问题，头指针的初始化必须要分配空间么？", "\n因为当我把NULL赋值给头指针后再试图让头指针的next指向链表的时候就会弹出程序停止的问题。如果程序中有发现其他问题也希望一并指出，谢谢各位", "\n\n", "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct type\n{\n    int num;\n    char name[20];\n    int age;\n    char sex[20];\n    char cla[20];\n}elem;\ntypedef struct Node\n{\n    elem stm;\n    struct Node *next;\n}node;\nnode *creation(node *n)\n{\n    n = (node*)malloc(sizeof(node));\n    n->next = NULL;\n    return n;\n}\nnode *add(node *n, node *p)\n{\n    node *s, *ss;\n    s = n;\n    ss = p;\n    while (s->next == ss)\n    {\n        if (s->next != NULL)\n            s = s->next;\n        if (s->next == NULL && ss->next == NULL)\n            s->next = ss;\n    }\n    return s;\n}\nint main()\n{\n    node  *p, *head, *n, *pp, *headd, *tot, *tothd, *scan;\n    char str[20];\n    n = head = headd = tothd = (node*)malloc(sizeof(node));\n    tot = (node*)malloc(40 * sizeof(node));\n    tothd->next = tot;\n    p = creation(&p);//赋值的时候有问题\n    pp = creation(&pp);//赋值的时候有问题\n    head->next = p;\n    headd->next = pp;\n    printf(\"The first data num name age sex class(num=-1 to end).\\n\");\n    while (scanf(\"%d\", &p->stm.num)&&p->stm.num != -1)\n    {\n            n->next = p;\n        p->next = NULL;\n        p = (node*)malloc(sizeof(node));\n        scanf(\"%s\", str);\n        strcpy(p->stm.name, str);\n        scanf(\"%d\", &p->stm.age);\n        scanf(\"%s\", str);\n        strcpy(p->stm.sex, str);\n        scanf(\"%s\", str);\n        strcpy(p->stm.cla, str);\n        n = p;\n    }\n    free(n);\n    n = (node*)malloc(sizeof(node));\n    printf(\"The second data num name age sex class(num=-1 to end).\\n\");\n    while (scanf(\"%d\", &pp->stm.num) && pp->stm.num != -1)\n    {\n        n->next = pp;\n        pp->next = NULL;\n        pp = (node*)malloc(sizeof(node));\n        scanf(\"%s\", str);\n        strcpy(pp->stm.name, str);\n        scanf(\"%d\", &pp->stm.age);\n        scanf(\"%s\", str);\n        strcpy(pp->stm.sex, str);\n        scanf(\"%s\", str);\n        strcpy(pp->stm.cla, str);\n        n = pp;\n    }\n    p = head->next;\n    pp = headd->next;\n    tot = add(&p, &pp);//赋值的时候有问题\n    scan = tothd->next;\n    while (scan->next != NULL)\n    {\n        printf(\"%d \", scan->stm.age);\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;假设结构体指针&amp;#xff1a;Player *player;&amp;#xff0c;使用为player-&amp;gt;wares;player-&amp;gt;wares[0]这样都可以。还有就是被引用的结构体最好在前面定义&amp;#xff0c;也就是说Wares在Pack前&amp;#xff0c;Pack在Player前&amp;#xff0c;否则就需要在Player定义前先声明Wares和Pack&lt;/p&gt;\n\n&lt;p&gt;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["C语言里怎么访问结构体指针里的结构体成员", ["\n", "typedef struct _player\n{\n    Pack pack;\n}Player;\ntypedef struct _pack\n\n{\n    Wares wares[20];\n}Pack;\ntypedef struct _wares\n\n{\n    int id;\n}Wares;\nvoid ShowId(Player *);\nint main()\n\n{\n    Player player;\n    player.pack.wares[0].id = 1;\n    ShowId(&player);\n    return 0;\n}\nvoid ShowId(Player *player)\n{\n    print(\"%d\", player->pack->wares->id);\n}\n", "\n\n", "请问这个编译一直报错error: invalid type argument of ‘->’ (have ‘Pack’ {aka ‘struct _pack’})|", "\n\n", "应该怎么访问这个？ 感谢大佬"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Since the library author did not construct a slice header for you to work with you will instead need to cast the return value you get to an &lt;code&gt;unsafe.Pointer&lt;/code&gt; and then to a &lt;code&gt;uintptr&lt;/code&gt; this will allow you to perform pointer arithmetic on it to get elements later in memory.&lt;/p&gt;\n\n&lt;p&gt;Here's some example code that should run as-is on the go playground.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {\n    nums := []uint8{1, 2, 3, 4, 5, 6, 7, 8}\n\n    val := &amp;amp;nums[0] // val is the equivalent of the *uint8 the Data function returns\n\n    ptr := unsafe.Pointer(val)\n\n    sixthVal := (*uint8)(unsafe.Pointer(uintptr(ptr) + 5*unsafe.Sizeof(*val)))\n\n    fmt.Println(\"Sixth element:\", *sixthVal)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Of course, you will need to be very certain you know how many elements there are so that you do not access invalid memory.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["CGO：如何在Golang中使用指针从C中的数组访问数据", ["\n\n", "I'm writing an app for the windows platform using FFmpeg and it's golang wrapper goav, but I'm having trouble understanding how to use the C pointers to gain access to the data array they point to.", "\n\n", "I'm trying to get the data stored in the AVFrame class and use Go to write it to a file, and eventually a texture in OpenGl to make a video player with cool transitions.", "\n\n", "I think understanding how to cast and access the C data will make coding this a lot easier.", "\n\n", "I've stripped out all the relevant parts of the C code, the wrapper and my code, shown below:", "\n\n", "C code - libavutil/frame.h", "\n\n", "#include <stdint.h>\n\ntypedef struct AVFrame {\n#define AV_NUM_DATA_POINTERS 8\n    uint8_t *data[AV_NUM_DATA_POINTERS];\n}\n", "\n\n", "Golang goav wrapper - I don't really know whats going on here with the unsafe.Pointers and casting but it gives me access to the underlying C code", "\n\n", "package avutil\n\n/*\n    #cgo pkg-config: libavutil\n    #include <libavutil/frame.h>\n    #include <stdlib.h>\n*/\nimport \"C\"\nimport (\n    \"unsafe\"\n)\n\ntype Frame C.struct_AVFrame\n\nfunc AvFrameAlloc() *Frame {\n    return (*Frame)(unsafe.Pointer(C.av_frame_alloc()))\n}\n\nfunc Data(f *Frame) *uint8 {\n    return (*uint8)(unsafe.Pointer((*C.uint8_t)(unsafe.Pointer(&f.data))))\n}\n", "\n\n", "My Golang code", "\n\n", "package main\n\nimport \"github.com/giorgisio/goav/avutil\"\n\nfunc main() {\n    videoFrame := avutil.AvFrameAlloc()\n\n    data := avutil.Data(videoFrame)\n\n    fmt.Println(data) // here i want the values from data[0] to data[7], but how?\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;前几天才从从头到尾debug了一下&amp;#xff0c;我得版本是springboot2.6.1&amp;#xff08;据说是从2.6.0开始&amp;#xff09;&amp;#xff0c;springmvc默认使用新的路径匹配工具类&amp;#xff0c;swagger基于旧版本的api&amp;#xff0c;导致空指针&amp;#xff0c;你切换成旧的路径匹配就行了&lt;br /&gt;spring.mvc.pathmatch.matching-strategy&amp;#61;ant_path_matcher&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["今天用IDEA创建SpringBoot工程，集成Swagger2启动项目时出现空指针异常的错误", ["SpringBoot集成Swagger2为什么出现了空指针异常的错误，配置类也写了呀", "\n", "\n", "\n", "\n", "\n", "求解答！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;对不是指向同一个“对象&amp;#xff08;内存空间&amp;#xff09;”的指针进行加减运算&amp;#xff0c;其实并没有任何意义&amp;#xff0c;其结果由实现决定。&lt;br /&gt;ptrdiff_t这个专门进行指针计算的数据类型。&lt;br /&gt;把一个毫不相关的值强制转成指针类型&amp;#xff0c;与一个指针指向这个值的地址是不同的&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["指针相减运算——C语言指针", ["\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n\n    ", "int", "* p = (", "int", "*)", "-1", ";\n    ", "int", "* p1 = (", "int", "*)", "4", ";\n    ", "if", " (p > p1)\n    {\n        ", "printf", "(", "\"p>p1\\n\"", ");\n    }\n    ", "else", "\n    {\n        ", "printf", "(", "\"p<p1\\n\"", ");\n    }\n\n    ", "printf", "(", "\"%d\"", ", p1 - p);\n    ", "return", " ", "0", ";\n}\n", "\n", "//结果是:1"]], "Tag": "程序设计"}
{"Answer": "（*iter）-&gt;draw_it();\r\n应该这样访问吧", "Konwledge_Point": "间接访问——指针", "Question": ["小白求助 vector中放置智能指针无法访问智能指针所指的内容", ["求大神解答", "\n\n", "\n\n", "\n\n", "我在一个vector中储存了指向图形基类的智能指针，但是在使用迭代器遍历这个vector时不能访问智能指针所指的对象，错误在图2", "\n\n", "**iter不应该就是这个vector中的draw类了吗？", "\n第一个*解引用迭代器，第二个*解引用智能指针？", "\n\n", "谢谢！"]], "Tag": "程序设计"}
{"Answer": "c/c++语言中，void意思是 **无类型**，所以不能声明类型为void的变量，但可以声明指向void类型的指针。\r\n\r\n\r\n\r\n```\r\nvoid *foo ;   ///Works fine\r\nvoid foo ;   ///Error\r\n```\r\n\r\n可以给void指针赋任意类型的地址值，但不能通过void指针访问这些地址指向的变量\r\n\r\n\r\n```\r\nint i=90 ;\r\nvoid *ip ;\r\nip=&amp;i ;   ///Works fine\r\ncout&lt;&lt; *ip ;   /* error:cannot access the value of i */\r\n```\r\n\r\n\r\n如果想要访问void指针指向的变量，需要先将其转换为具体类型的指针，如下：\r\n\r\n\r\n\r\n```\r\nint i=90 ;\r\nvoid *ip=&amp;i ;\r\nint *iv=static_cast&lt;int *&gt;(ip) ; ///Casting ip to int type\r\ncout&lt;&lt; *iv ; //Works fine\r\n\r\n注意需要转换为正确的类型，否则会引入bug，如下：\r\nstring st=*static_cast&lt;string *&gt;(ip) ;// casting to string type\r\ncout&lt;&lt; st ; //undefined\r\n```\r\n\r\n**如果对您有帮助，请采纳答案好吗(鼠标在我的答案区域停留片刻即可看到采纳按钮)，谢谢！**", "Konwledge_Point": "间接访问——指针", "Question": ["C++将void*类型的指针强制转换后无法解引用该指针所指向的对象", ["请教各位前辈，为什么将void*指针进行static_cast强制类型转换后无法让该指针解引用", "\n所指向的对象？但是强制转换后赋给int*dp后却可以解引用，输出*dp的值是100；"]], "Tag": "程序设计"}
{"Answer": "http://www.2cto.com/kf/201312/263762.html", "Konwledge_Point": "间接访问——指针", "Question": ["httpclient.excute方法报空指针，求好心人帮忙", ["请求接口的时候用的httpclient, 程序在本地跑没问题，在线上服务器也没问题，可以正常请求各个接口。", "\n\n", "本来测试服务器也是可以的，但是有天突然开始发生下面的情况：", "\n\n", "如果请求一个ip，第一次可以，但是第二次请求这个ip的其他接口时就会报空指针异常", "\njava.lang.NullPointerException", "\n    at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java)", "\n\n", "这是请求那块的代码：", "\n\n", " public static HttpResp perform(HttpReq req) throws Exception {\n\n        RequestConfig globalConfig = RequestConfig.custom().setConnectTimeout(5000).setSocketTimeout(5000).build();\n\n        CloseableHttpClient httpClient =HttpClients.custom().setDefaultRequestConfig(globalConfig).build();\n        HttpResp resp = null;\n        HttpRequestBase request = buildHttpRequest(req);\n\n        HttpResponse response = httpClient.execute(request);\n        resp = buildHttpResponse(response);\n        return resp;\n\n    }\n", "\n\n", "求好心人帮忙看看。。。。"]], "Tag": "程序设计"}
{"Answer": "list-&gt;at(i)\r\n这样试试看", "Konwledge_Point": "间接访问——指针", "Question": ["qt中Qlist指针访问Qlist中的内容", ["刚学qt不久，c++基础也有点差，今天用到 Qlist *list;", "\n我要怎么用访问list中的内容呢，如果不是指针可以用 list[i]来访问，指针的话我使用c的方法貌似不可以，求大佬解决"]], "Tag": "程序设计"}
{"Answer": "参考这篇文章：https://www.cnblogs.com/hellohacker/p/5827222.html", "Konwledge_Point": "间接访问——指针", "Question": ["段错误，检查是否有数组越界，指针异常，访问到不应该访问的内存区域", ["题目：给定一组二维点，每个点对应一个字符。给定任意一个位置，输出距离其最近点与它的距离。", "\n\n", "输入", "\n\n", "第一行两个数：点的个数N以及查询的个数M ", "\n\n", "接下来N行，每行2个浮点数和一个字符，代表点的坐标以及其对应的字符 ", "\n\n", "接下来M行，每行2个浮点数，代表希望查询的位置 ", "\n\n", "输出", "\n\n", "M行，每行为点集中距离查询位置最近的距离，精确到小数点后4位。", "\n\n", "代码：", "\n#include ", "\n#include", "\n#include ", "\n#include ", "\n#include ", "\nusing namespace std;", "\nstruct data", "\n{", "\n    double x;", "\n    double y;", "\n};", "\n\n", "struct Tnode", "\n{", "\n    struct data dom_elt;", "\n    int split;", "\n    struct Tnode * left;", "\n    struct Tnode * right;", "\n};", "\n\n", "double ave(double a[],int n)", "\n  {", "\n    int sum=0;", "\n    for (int i=0;i<n;i++)", "\n    sum+=a[i];", "\n    return sum/n;", "\n   }", "\n\n", "double variance (double a[],int n)", "\n   {", "\n    double sum=0;", "\n    double average=ave(a,n);//函数调用！！不许有【】！！！不许有int和double ！！", "\n    for (int i=0;i<n;i++)", "\n    sum=(a[i]-average)*(a[i]-average);", "\n    return sum/n;", "\n    }", "\n\n", "bool cmp1(data a, data b){", "\n    return a.x < b.x;", "\n}", "\n\n", "bool cmp2(data a, data b){", "\n    return a.y < b.y;", "\n}", "\n\n", "bool equal(data a, data b){", "\n    if (a.x == b.x && a.y == b.y)", "\n    {", "\n        return true;", "\n    }", "\n    else{", "\n        return false;", "\n    }", "\n}", "\nvoid ChooseSplit(data exm_set[], int size, int &split, data &SplitChoice){", "\n    double tmp1,tmp2;", "\n    double v1,v2;", "\n    double flag1[size],flag2[size];", "\n    for(int i=0;i<size;i++){", "\n    flag1[i]=exm_set[i].x;", "\n    flag2[i]=exm_set[i].y;}", "\n    v1=variance(flag1,size);", "\n    v2=variance(flag2,size);", "\n    /*tmp1 = tmp2 = 0;", "\n    for (int i = 0; i < size; i++)", "\n    {", "\n        //while((double)size * exm_set[i].x * exm_set[i].x!=0&&(double)size * exm_set[i].x!=0)", "\n        tmp1 += 1.0 / (double)size * exm_set[i].x * exm_set[i].x;", "\n        tmp2 += 1.0 / (double)size * exm_set[i].x;", "\n\n", "}\ndouble v1 = tmp1 - tmp2 * tmp2;\ntmp1 = tmp2 = 0;\nfor (int i = 0; i < size; i++)\n{\n    //while((double)size * exm_set[i].x * exm_set[i].x!=0&&(double)size * exm_set[i].x!=0){\n    tmp1 += 1.0 / (double)size * exm_set[i].y * exm_set[i].y;\n    tmp2 += 1.0 / (double)size * exm_set[i].y;\n    ///}\n}\ndouble v2 = tmp1 - tmp2 * tmp2;*/\nsplit = v1 > v2 ? 1:0;\nif (split == 0)\n{\n    sort(exm_set,exm_set + size-1, cmp1);\n}\nelse{\n    sort(exm_set,exm_set + size-1, cmp2);\n}\nSplitChoice.x = exm_set[size / 2].x;\nSplitChoice.y = exm_set[size / 2].y;\n", "\n\n", "}", "\n\n", "Tnode* build_kdtree(data exm_set[], int size, Tnode* T){", "\n    if (size == 0){", "\n        return NULL;", "\n    }", "\n    else{", "\n        int split;", "\n        data dom_elt;", "\n        ChooseSplit(exm_set, size, split, dom_elt);", "\n        data exm_set_right [100];", "\n        data exm_set_left [100];", "\n        int sizeleft ,sizeright;", "\n        sizeleft = sizeright = 0;", "\n        if (split == 0)", "\n        {", "\n            for (int i = 0; i < size; i++)", "\n            {", "\n                if (!equal(exm_set[i],dom_elt) && exm_set[i].x <= dom_elt.x)", "\n                {", "\n                    exm_set_left[sizeleft].x = exm_set[i].x;", "\n                    exm_set_left[sizeleft].y = exm_set[i].y;", "\n                    sizeleft++;", "\n                }", "\n                else if (!equal(exm_set[i],dom_elt) && exm_set[i].x > dom_elt.x)", "\n                {", "\n                    exm_set_right[sizeright].x = exm_set[i].x;", "\n                    exm_set_right[sizeright].y = exm_set[i].y;", "\n                    sizeright++;", "\n                }", "\n            }", "\n        }", "\n        else{", "\n            for (int i = 0; i < size; i++)", "\n            {", "\n\n", "            if (!equal(exm_set[i],dom_elt) && exm_set[i].y <= dom_elt.y)\n            {\n                exm_set_left[sizeleft].x = exm_set[i].x;\n                exm_set_left[sizeleft].y = exm_set[i].y;\n                sizeleft++;\n            }\n            else if (!equal(exm_set[i],dom_elt) && exm_set[i].y > dom_elt.y)\n            {\n                exm_set_right[sizeright].x = exm_set[i].x;\n                exm_set_right[sizeright].y = exm_set[i].y;\n                sizeright++;\n            }\n        }\n    }\n    T = new Tnode;\n    T->dom_elt.x = dom_elt.x;\n    T->dom_elt.y = dom_elt.y;\n    T->split = split;\n    T->left = build_kdtree(exm_set_left, sizeleft, T->left);\n    T->right = build_kdtree(exm_set_right, sizeright, T->right);\n    return T;\n}\n", "\n\n", "}", "\ndouble Distance(data a, data b){", "\n    double tmp = (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);", "\n    return sqrt(tmp);", "\n}", "\nvoid searchNearest(Tnode * Kd, data target, data &nearestpoint, double & distance){", "\n    stack search_path;", "\n    Tnode* pSearch = Kd;", "\n    data nearest;", "\n    double dist;", "\n    while(pSearch != NULL)", "\n    {", "\n        search_path.push(pSearch);", "\n\n", "    if (pSearch->split == 0)\n    {\n        if(target.x <= pSearch->dom_elt.x)\n        {\n            pSearch = pSearch->left;\n        }\n        else\n        {\n            pSearch = pSearch->right;\n        }\n    }\n    else{\n        if(target.y <= pSearch->dom_elt.y)\n        {\n            pSearch = pSearch->left;\n        }\n        else\n        {\n            pSearch = pSearch->right;\n        }\n    }\n}\nnearest.x = search_path.top()->dom_elt.x;\nnearest.y = search_path.top()->dom_elt.y;\nwhile(!search_path.empty()){search_path.pop();}\ndist = Distance(nearest, target);\nTnode *pBack;\nwhile(!search_path.empty())\n{\n    pBack = search_path.top();\n    search_path.pop();\n    if(pBack->left == NULL && pBack->right == NULL)\n    {\n        if( Distance(nearest, target) > Distance(pBack->dom_elt, target) )\n        {\n            nearest = pBack->dom_elt;\n            dist = Distance(pBack->dom_elt, target);\n        }\n    }\n    else\n    {\n        int s = pBack->split;\n        if (s == 0)\n        {\n            if( fabs(pBack->dom_elt.x - target.x) < dist)\n            {\n                if( Distance(nearest, target) > Distance(pBack->dom_elt, target) )\n                {\n                    nearest = pBack->dom_elt;\n                    dist = Distance(pBack->dom_elt, target);\n                }\n                if(target.x <= pBack->dom_elt.x)\n                    pSearch = pBack->right;\n                else\n                    pSearch = pBack->left;\n                if(pSearch != NULL)\n                    search_path.push(pSearch);\n            }\n        }\n        else {\n            if( fabs(pBack->dom_elt.y - target.y) < dist)\n            {\n                if( Distance(nearest, target) > Distance(pBack->dom_elt, target) )\n                {\n                    nearest = pBack->dom_elt;\n                    dist = Distance(pBack->dom_elt, target);\n                }\n                if(target.y <= pBack->dom_elt.y)\n                    pSearch = pBack->right;\n                else\n                    pSearch = pBack->left;\n                if(pSearch != NULL)\n                    search_path.push(pSearch);\n            }\n        }\n    }\n}\nnearestpoint.x = nearest.x;\nnearestpoint.y = nearest.y;\ndistance = dist;\n", "\n\n", "}", "\nint main(){", "\n    double x,y;", "\n    int m,n;", "\n    cin>>m>>n;", "\n    data exm_set[m];", "\n    char pos[m];", "\n    for(int i=0;i\n    {", "\n        cin>>x>>y;", "\n        cin>>pos[i];", "\n        exm_set[i].x = x;", "\n        exm_set[i].y = y;", "\n    }", "\n    struct Tnode *root = NULL;", "\n    root = build_kdtree(exm_set, m, root);", "\n\n", "data nearestpoint;\ndouble distance;\ndata target;\nfor(int j=0;j<n;j++)\n{\n    double xx,yy;\n    cin>>xx>>yy;\n    target.x=xx;\n    target.y=yy;\n    searchNearest(root, target, nearestpoint, distance);\n    printf(\"%.4f\\n\", distance);\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "你的Base类中就没有printDerived() 函数，当然无法使用基类指针指向派生类的成员函数。虚函数是使用虚函数表实现的，派生类中的函数要覆盖并实现基类的\r\n虚函数，从而替换基类的虚函数表中的函数指针。", "Konwledge_Point": "间接访问——指针", "Question": ["基类指针怎么访问派生类的成员函数呢（新增的）？而且这样访问为什么是错的。", ["#include", "\nusing namespace std;", "\nclass Base", "\n{", "\npublic:", "\nvirtual void printBase(){}", "\nprivate:", "\n    int bval;", "\n};", "\nclass Derived:public Base{", "\npublic:", "\nvirtual void printDerived() {}", "\nprivate:", "\n    int dval;", "\n};", "\nvoid main(){", "\n    Derived derived1,derived2;", "\n    Base *ptb=&derived1;", "\n    ptb->printDerived();//没有成员函数printDerived1", "\n    ptb->printBase();", "\n    Base &rfb=derived2;", "\n    rfb.printDerived();//这个也是，", "\n    rfb.printBase();", "\n}"]], "Tag": "程序设计"}
{"Answer": "指针使用-&gt;而不是.，而且函数调用你也少了括号一对。", "Konwledge_Point": "间接访问——指针", "Question": ["关于对象指针的问题，通过对象指针访问对象和对象成员", ["下面的代码在第24行的时候我注释的地方，运行为什么不对？", "\n-> 运算：对象指针名->成员", "\n不是等价于", "\n(*对象指针名).成员", "\n   吗？", "\n\n", "#include", "\nusing namespace std;", "\nclass point", "\n{", "\npublic:", "\n    point(int x=0,int y=0):x(x),y(y){}", "\n    int getx() const", "\n    {", "\n        return x;", "\n    }", "\n    int gety() const", "\n    {", "\n        return y;", "\n    }", "\nprivate:", "\n    int x,y;", "\n};", "\nint main()", "\n{", "\n    point p1(4,5);", "\n    point *p=&p1;", "\n    cout<getx()<<endl;", "\n    cout<<p1.getx()<<endl;", "\n   // cout<<(*p1).getx<<endl;                  //为什么这样子不可以！！！", "\n    return 0;", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;没弄清楚你的意思。首先指针就是内存地址&amp;#xff0c;表示某个东西在内存中的位置。因为申请的内存它的内存地址是变化的、不确定的&amp;#xff0c;所以需要用一个变量来存储它&amp;#xff0c;这个变量叫做指针&amp;#xff08;其实就是数字&amp;#xff0c;当然计算机都是数字&amp;#xff09;&amp;#xff0c;当然变量也是占用内存的&amp;#xff0c;不过在写程序的时候变量是有名称的&amp;#xff0c;我们直接操作变量名即可&amp;#xff0c;实际编译之后就是操作变量的内存地址&amp;#xff08;这个编译器来完成&amp;#xff0c;我们可以不管&amp;#xff09;&amp;#xff0c;因此一般变量的指针不需要记录。链表的头指针只是记录了链表中第一个节点的内存地址&amp;#xff0c;然后第一个节点的next指针记录了第二个节点的内存地址&amp;#xff0c;如此类推。有头节点的链表&amp;#xff0c;那只是第一个节点空着不存数据而已&amp;#xff0c;实际上没有太多区别。&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["头指针和尾指针的位置在哪里？", ["如果一个单循环链表带头结点，那么他的链表头是头结点还是第二个有数据的元素？", "头指针和尾指针的位置在哪里？（下面是我自己的理解）", "头指针和尾指针只是在电脑中定义了，电脑在头指针和尾指针中保存了表头指针和表尾指针的位置，但在单循环链表中并没有头指针和尾指针，只有表头指针和表尾指针（既链表的第一个元素和最后一个元素的位置）对吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;基于Monster 组和GPT的调写&amp;#xff1a;&lt;br /&gt;在 C 语言中&amp;#xff0c;形参如果是指针类型&amp;#xff0c;则其实际上是一个指向实参的内存地址的指针。因此&amp;#xff0c;形参可以通过间接访问实参来获取或修改实参的值&amp;#xff0c;而不是直接访问实参本身。&lt;/p&gt;\n&lt;p&gt;例如&amp;#xff0c;考虑下面的代码片段&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;foo&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p)&lt;/span&gt; &lt;/span&gt;{\n    *p &amp;#61; &lt;span class=\"hljs-number\"&gt;42&lt;/span&gt;; &lt;span class=\"hljs-comment\"&gt;// 修改实参的值&lt;/span&gt;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;foo&lt;/span&gt;(&amp;amp;x); &lt;span class=\"hljs-comment\"&gt;// 传递实参的地址&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;, x); &lt;span class=\"hljs-comment\"&gt;// 输出 42&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;函数 foo 的形参 p 是一个指向 int 类型的指针。当在函数中使用 *p 来访问实参时&amp;#xff0c;实际上是通过间接访问实参来进行的。在调用 foo 函数时&amp;#xff0c;我们使用 &amp;amp;x 来获取实参 x 的地址&amp;#xff0c;并将该地址传递给 foo 函数。&lt;/p&gt;\n&lt;p&gt;因此&amp;#xff0c;如果一个函数的形参是指针类型&amp;#xff0c;那么在函数内部访问实参时&amp;#xff0c;通常需要通过间接访问实参来进行。&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["形参的参数是指针类型是间接访问实参还是直接访问实参", ["形成的参数是引用类型直接访问实参的，那形参的参数是指针类型是间接访问实参还是直接访问实参，它是通过一个指针应该是间接的吗？"]], "Tag": "程序设计"}
{"Answer": "typedef int ElemType;\r\ntypedef struct Node *Position;\r\ntypedef Position BTNode;\r\nstruct Node\r\n{\r\n    ElemType data;\r\n    struct node *lchild;\r\n    struct node *rchild;\r\n}b;\r\n粗略看了一下上面的应该等价于下面的\r\ntypedef int ElemType;\r\ntypedef struct Node\r\n{\r\n    ElemType data;\r\n    struct node *lchild;\r\n    struct node *rchild;\r\n}*Position, *BTNode, Node;\r\nNode b;\r\n这个\r\n所以BTNode * p; 相当于Node **p，所以你就知道了（Node *）不是一个类，而是一个指针类型，你非要这么写的话可以试试(*p）-&gt;\r\n或者 BTNode  p,建议“}*Position, *BTNode, Node;”改为“}*Position, BTNode, Node;”\r\n另外建议指针数组啥的该加的括号加上", "Konwledge_Point": "间接访问——指针", "Question": ["为什么p St b报错“表达式必须包含指向类的指针类型”？", ["#include<iostream>\n#include<stdlib.h>\n#define MaxSize 50\n\ntypedef int ElemType;\ntypedef struct Node *Position;\ntypedef Position BTNode;\nstruct Node\n{\n    ElemType data;\n    struct node *lchild;\n    struct node *rchild;\n}b;\n\nvoid CreateBTree(BTNode * &b, char*str)\n{\n    BTNode *St[MaxSize], *p;\n    int top = -1, k, j = 0;\n    char ch;\n    b = NULL;\n    ch = str[j];\n    while (ch != '\\0')\n    {\n        switch (ch)\n        {\n        case '(':top++; St[top] = p; k = 1; break;\n        case')':top--; break;\n        case',':k = 2; break;\n        default:p = (BTNode *)malloc(sizeof(BTNode));\n            p->data = ch;\n            p->lchild = p->rchild = NULL;\n            if (b == NULL)\n                b = p;\n            else\n            {\n                switch (k)\n                {\n                case 1:St[top]->lchild = p; break;\n                case 2:St[top]->rchild = p; break;\n                }\n            }\n        }\n        j++;\n        ch = str[j];\n    }\n}\n", "\n\n", "\n其中p St b报错“表达式必须包含指向类的指针类型”", "\n请问大佬们这是为什么呀？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The code isn't safe, since assignments and reads to a pointer value are not guaranteed to be atomic. This can mean that as one goroutine writes the new pointer value, the other may see a mix of bytes from the old and new value, which will cause your program to die in a nasty way. Another thing that may happen is that since there's no synchronisation in your code, the compiler may notice that nothing can change a in goroutineA, and lift the &lt;code&gt;tempA := a&lt;/code&gt; statement out of the loop. This will mean that you'll never see new map assignments as the other goroutine updates them.&lt;/p&gt;\n\n&lt;p&gt;You can use &lt;code&gt;go test -race&lt;/code&gt; to find these sorts of problems automatically.&lt;/p&gt;\n\n&lt;p&gt;One solution is to lock all access to the map with a mutex.&lt;/p&gt;\n\n&lt;p&gt;You may wish to read the &lt;a href=\"http://golang.org/ref/mem\" rel=\"noreferrer\"&gt;Go Memory Model&lt;/a&gt; document, which explains clearly when changes to variables are visible inside goroutines.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["从并发goroutine进行设置和访问指针", ["\n\n", "I have a map which is used by goroutine A and replaced once in a time in goroutine B. By replacement I mean:", "\n\n", "var a map[T]N\n\n// uses the map\nfunc goroutineA() {\n    for (...) {\n        tempA = a\n        ..uses tempA in some way...\n    }\n}\n\n//refreshes the map\nfunc gorountineB() {\n    for (...) {\n        time.Sleep(10 * time.Seconds)\n        otherTempA = make(map[T]N)\n        ...initializes other tempA....\n        a = otherTempA \n    }\n}\n", "\n\n", "Do you see any problem in this pseudo code? (in terms of concurrecy)", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;   int a[n]; 不可以这么定义c&amp;#43;&amp;#43;的数组&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;int Createlist(P* L)//  创建顺序表 \n\n{\n    int n;\n\n    int k;\n\n    printf(&amp;#34;输入所需顺序表的长度&amp;#xff1a;&amp;#34;);\n\n    scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);\n\n    int a[1000];\n\n    for (k &amp;#61; 0; k &amp;lt; n; k&amp;#43;&amp;#43;)\n\n    {\n        printf(&amp;#34;请输入第%d个位置的值&amp;#xff1a; &amp;#34;, k);\n\n        scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[k]);\n\n        L-&amp;gt;length &amp;#61; a[k];\n\n    }\n\n\n\n    L-&amp;gt;length &amp;#61; n;\n\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["表达式必须包含指向对象的指针类型，但它具有类型 \"int\"", ["#include<stdio.h>", "\n\n", "#include<stdlib.h>", "\n\n", "#include<malloc.h>", "\n\n", "#define maxsize 999", "\n\n", "typedef struct List", "\n\n", "{", "\n\n", "    int Data[maxsize];", "\n\n", "    int length;", "\n\n", "}P;", "\n\n", " ", "\n\n", "void Initialization(P *L)// 初始化顺序表 ", "\n\n", "{", "\n\n", "    ", "\n\n", "    L->length=0;", "\n\n", "}", "\n\n", " ", "\n\n", "int Createlist(P *L)//  创建顺序表 ", "\n\n", "{", "\n\n", "    int n;", "\n\n", "    int k;", "\n\n", "    printf(\"输入所需顺序表的长度：\");", "\n\n", "    scanf(\"%d\",&n);", "\n\n", "    int a[n];", "\n\n", "    for (k = 0; k < n; k++)", "\n\n", "    {", "\n\n", "        printf(\"请输入第%d个位置的值： \",k);", "\n\n", "        scanf(\"%d\",&a[k]);", "\n\n", "        L->length[k] = a[k];", "\n\n", "    }", "\n\n", " ", "\n\n", "        L->length = n;", "\n\n", "}", "\n\n", " ", "\n\n", "void Printflist(P *L)//  遍历顺序表 ", "\n\n", "{", "\n\n", "    for(int i=0;i<L->length;i++)", "\n\n", "    {", "\n\n", "        printf(\"%d \",(L->Data[i]));", "\n\n", "    }", "\n\n", "}", "\n\n", " ", "\n\n", "int insert(P *L,int i,int val)// *增：在特定位置插入特定值", "\n\n", "{", "\n\n", "    if(L->length==maxsize)", "\n\n", "    {", "\n\n", "        printf(\"存储空间已满！\\n\");", "\n\n", "        return 0;", "\n\n", "    }", "\n\n", "    for(int j=L->length-1;j>=i-1;j--)", "\n\n", "    {", "\n\n", "        L->Data[j+1]=L->Data[j];//  顺序表长度增加一位后，将原来第i位置后的每一位元素向后移一位 ", "\n\n", "    }", "\n\n", "    L->Data[i-1]=val;", "\n\n", "    L->length++;//  顺序表长度增加1 ", "\n\n", "    return 1;", "\n\n", " } ", "\n\n", " ", "\n\n", " int del(P *L,int i,int *val)//  *删：删除特定位置的值", "\n\n", " {", "\n\n", "    *val=L->Data[i-1];//  将要删除的值存放在该指针中 ", "\n\n", "    for(int j=i;j<=L->length-1;j++)", "\n\n", "    {", "\n\n", "        L->Data[j-1]=L->Data[j];//  顺序表长度减少一位后，将原来第i位置后的每一位元素向前移一位 ", "\n\n", "     }", "\n\n", "     L->length--;//  顺序表长度减少1 ", "\n\n", "  } ", "\n\n", "  ", "\n\n", "  int seek(P *L,int i,int *val)//  *查：查询特定位置的值 ", "\n\n", "  {", "\n\n", "    *val=L->Data[i-1];//  将要查询的值存放在该指针中 ", "\n\n", "  }", "\n\n", "  ", "\n\n", "  int change(P *L,int i,int x,int *val)//  *改：在特定位置更改所需值 ", "\n\n", "  {", "\n\n", "    *val=L->Data[i-1];//  将所改值存放在该指针中 ", "\n\n", "    L->Data[i-1]=x;", "\n\n", "  }", "\n\n", "  ", "\n\n", "  int main()", "\n\n", "  {", "\n\n", "    ", "\n\n", "    P *list;", "\n\n", "    int val1;", "\n\n", "    int val2;", "\n\n", "    int val3;", "\n\n", "      //Initialization(list);", "\n\n", "      Createlist(list);", "\n\n", "      {", "\n\n", "        printf(\"创建的顺序表为：\\n\");", "\n\n", "      }", "\n\n", "      Printflist(list);", "\n\n", "      seek(list,1,&val1);", "\n\n", "      {", "\n\n", "        printf(\"\\n查找的值为： %d\",val1);", "\n\n", "       } ", "\n\n", "      insert(list,1,100);", "\n\n", "      {", "\n\n", "        printf(\"\\n插入所需值后的顺序表为：\\n\");", "\n\n", "      }", "\n\n", "      Printflist(list);", "\n\n", "      del(list,2,&val2);", "\n\n", "      {", "\n\n", "        printf(\"\\n删除的值为：%d，删除后的顺序表为：\\n\",val2);", "\n\n", "      }", "\n\n", "      Printflist(list);", "\n\n", "      change(list,3,77,&val3);", "\n\n", "      {", "\n\n", "        printf(\"\\n改变的值为：%d，改变后的顺序表为：\\n\",val3);", "\n\n", "      }", "\n\n", "      Printflist(list);", "\n\n", "      return 0;", "\n\n", "   } ", "\n\n", "新手写的顺序表，但是创建部分出现的问题不知道怎么解决，求救~~~"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/u013431550/article/details/43057537?utm_term&amp;#61;%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%88%97%E6%8C%87%E9%92%88&amp;amp;utm_medium&amp;#61;distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-5-43057537&amp;amp;spm&amp;#61;3001.4430\" id=\"textarea_1635421619185_1635421701834_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;行指针和列指针详解_QRqing-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;主要指二维数组int a[3][4]&amp;#61;{1,3,5,7,9,11,13,15,17,19,21,23};换个角度看世界&amp;#xff1a;如首行一样&amp;#xff0c;将首行视为一个元素&amp;#xff0c;一个特殊的元素&amp;#xff0c;这个“特殊的”元素是一个一维数组。那么这个二维数组是由是由三个“特殊的”元素组成的一个“特殊的”一维数组。a是这个“特殊的”一维数组的名称&amp;#xff0c;也就是首地址&amp;#xff0c;也就是第一个元素的地址&amp;#xff0c;也就是第一行的首地址&amp;#xff0c;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/u013431550/article/details/43057537?utm_term&amp;#61;%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%88%97%E6%8C%87%E9%92%88&amp;amp;utm_medium&amp;#61;distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-5-43057537&amp;amp;spm&amp;#61;3001.4430&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://wenku.baidu.com/view/4b9e9e906529647d272852aa.html\" id=\"textarea_1635421619185_1635421701834_1\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;对二维数组行指针和列指针理解 - 百度文库&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"margin: 0px 0 2px\"&gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://edu-wenku.bdimg.com/v1/pc/2020%E6%96%B0%E9%A6%96%E9%A1%B5/wenku-header-icon.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://wenku.baidu.com/view/4b9e9e906529647d272852aa.html&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\"https://blog.csdn.net/baidu_41878679/article/details/82704075?utm_term&amp;#61;%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%88%97%E6%8C%87%E9%92%88&amp;amp;utm_medium&amp;#61;distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-82704075&amp;amp;spm&amp;#61;3001.4430\" id=\"textarea_1635421619185_1635421701834_2\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;二维数组中的指针类型&amp;#xff08;行指针和列指针&amp;#xff09;_baidu_41878679的博客-CSDN博客_二维数组行指针和列指针&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;1.二维数组在内存中的布局一般我们都会把二维数组看做是排列在一张表格中的一行行的一维数组&amp;#xff0c;但是事实上系统是决不允许程序按照这样的方式存储数据的。单个元素的存储和引用实际上是以线性的方式排列在内存中的。数组下标操作符在C中是内置操作符&amp;#xff0c;它的规则告诉我们如何去解析int p[i]和int a[i][j],实际上编译器会将数组的下标解析为解引用&amp;#xff08;&amp;#xff09;操作符。例如&amp;#xff1a;int p[i]解析为”(p&amp;#43;i)...&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/baidu_41878679/article/details/82704075?utm_term&amp;#61;%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%88%97%E6%8C%87%E9%92%88&amp;amp;utm_medium&amp;#61;distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-82704075&amp;amp;spm&amp;#61;3001.4430&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["行指针与列指针的详解", ["二维数组里地址的表示中行指针和列指针怎么区分，求详解或传送门，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;解析不是写的很清楚了吗。。&lt;/p&gt;\n\n&lt;p style=\"text-align:center\"&gt;&lt;img alt=\"\" height=\"648\" src=\"https://img-ask.csdnimg.cn/upload/1619513844186.png\" width=\"627\" /&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["问一道题————\n这道题里空栈的指针为什么是m+1（猫猫疑惑）", ["问一道题————\n这道题里空栈的指针为什么是m+1（猫猫疑惑）"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;b传进来的是一维数组&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["表达式必须包含指向对象的指针类型，但它具有类型“int”", ["\n", "c小白求教", "vs2019", "程序目的是输入一个n*n阶二维数组，用函数求主次对角线元素之和", "报错内容如标题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第30行 p &amp;#61; L-&amp;gt;next-&amp;gt;next;  这里是为了什么&amp;#xff0c;让 p 指向链表的第2个结点&amp;#xff1f; &lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["关于指针的读取访问权限冲突问题", ["为什么这里指针p会有这种异常，不是已经", "将传进来的链表L赋给p了吗？调试取p的值很奇怪，求指教"]], "Tag": "程序设计"}
{"Answer": "看样子你是使用的迭代器啊，你的rs中有值吗？先打个断点看看", "Konwledge_Point": "间接访问——指针", "Question": ["访问jsp页面时出现空指针异常，求大神解决", ["List中值是null,不知道怎么取到值。。。", "\nJAVA CODE:", "\nList listBrand = new ArrayList();", "\n            while(rs.next()){", "\n                BrandVO brand = new BrandVO();", "\n                brand.setId(rs.getInt(\"id\"));", "\n                brand.setBname(rs.getString(\"name\"));", "\n                listBrand.add(brand);", "\n            }", "\n            req.setAttribute(\"carList\", rs.getInt(\"id\"));", "\n            req.getRequestDispatcher(\"add_car.jsp\").forward(req, resp)", "\n\n", "        jsp中代码：\n      <%\n        List<BrandVO> listBrand = (List) request.getAttribute(\"carList\");\n\n                                for(BrandVO brand : listBrand){\n                                %>\n                                    <option><%=brand.getBname()%></option>\n                                    <% }%>\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个...你能不能翻翻书&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["请问，怎么用指针访问数组，通过冒泡方式将最大值移动到数组尾部，然后输出该数组", ["请问，怎么用指针访问数组，通过冒泡方式将最大值移动到数组尾部，然后输出该数组"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;排序函数逻辑错了&amp;#xff0c;代码修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;malloc.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;mp&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* name[])&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* temp&amp;#61;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; j &amp;lt; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;-i; j&amp;#43;&amp;#43;)\n        {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ( (&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(name[j], name[j &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]) &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) &amp;amp;&amp;amp;(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;!&amp;#61;temp)) &lt;span class=\"hljs-comment\"&gt;//你的代码这里原来写错了&lt;/span&gt;\n            {\n                &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(temp,&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n                &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(temp,name[j]);\n                &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(name[j],&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n                &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(name[j],name[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n                &lt;span class=\"hljs-built_in\"&gt;memset&lt;/span&gt;(name[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n                &lt;span class=\"hljs-built_in\"&gt;strcpy&lt;/span&gt;(name[j&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],temp);\n                &lt;span class=\"hljs-comment\"&gt;/*temp &amp;#61; name[i];\n                name[i] &amp;#61; name[i &amp;#43; 1];\n                name[i &amp;#43; 1] &amp;#61; temp;*/&lt;/span&gt;\n            }\n        }\n        \n    }\n    &lt;span class=\"hljs-built_in\"&gt;free&lt;/span&gt;(temp);\n    temp &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; country[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;][&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;];\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* ht[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;请输入五个国家名:&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;scanf_s&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,country[i],&lt;span class=\"hljs-number\"&gt;15&lt;/span&gt;);\n        ht[i] &amp;#61; country[i];\n    }\n    &lt;span class=\"hljs-built_in\"&gt;mp&lt;/span&gt;(ht);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;排序后:\\n&amp;#34;&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;)\n    {\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, ht[i]);&lt;span class=\"hljs-comment\"&gt;//这里加个回车&lt;/span&gt;\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["使用指针后出现访问位置时冲突错误", ["#大家好,我是一名小bai,第一次用指针,出现问题后查了资料,说是指针内存分配错误,我也不是太懂,试了好多种方法,还是出错.", "#求大佬救救小bai吧,给跪了...........................", "\n", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<string.h>", "\n", "#", "include", "<malloc.h>", "\n", "void", " ", "mp", "(", "char", "* name[])", "\n", "{\n    ", "char", "* temp=(", "char", "*)", "malloc", "(", "15", ");\n    ", "for", " (", "int", " i = ", "0", "; i < ", "5", "; i++)\n    {\n        ", "for", " (", "int", " j = ", "0", "; j < ", "4", "; j++)\n        {\n            ", "if", " ((", "strcmp", "(name[i], name[i + ", "1", "] < ", "0", "))&&(", "NULL", "!=temp))\n            {\n                temp = name[i];\n                name[i] = name[i + ", "1", "];\n                name[i + ", "1", "] = temp;\n            }\n        }\n        ", "free", "(temp);\n    }\n}\n", "main", "()\n{\n    ", "char", " country[", "5", "][", "15", "];\n    ", "char", "* ht[", "5", "];\n    ", "printf", "(", "\"请输入五个国家名:\"", ");\n    ", "for", " (", "int", " i = ", "0", "; i < ", "5", "; i++)\n    {\n        ", "scanf_s", "(", "\"%s\"", ",country[i],", "15", ");\n        ht[i] = country[i];\n    }\n    ", "mp", "(ht);\n    ", "printf", "(", "\"排序后:\\n\"", ");\n    ", "for", " (", "int", " i = ", "0", "; i < ", "5", "; i++)\n    {\n        ", "printf", "(", "\"%s\"", ", ht[i]);\n    }\n}\n\n\n", "\n", "#错误就是这样纸的,好烦,再次感谢大佬!!!"]], "Tag": "程序设计"}
{"Answer": "为了简单，最好是自己再用C++封装一个函数，用指针做参数，C++中做到双指针的转换。\r\n\r\n实在要用，参考：http://stackoverflow.com/questions/21259634/return-a-double-pointer-in-jni", "Konwledge_Point": "间接访问——指针", "Question": ["jna调用dll时遇到双指针", ["我用java调用c++的函数，函数中用到了一个双指针作为参数，我应该怎么样传入一个双指针的变量，java中没有指针的概念"]], "Tag": "程序设计"}
{"Answer": "直接用一个指针，就可以完成指向数组的功能，无论数组是多少维。\r\n只是指向后，如果控制下标需要自己考虑。其实，数组名就可以认为是一个静态的指针。", "Konwledge_Point": "间接访问——指针", "Question": ["可以用一个一级指针指向一个二维数组吗？ ", ["看到书上写的都是二级指针，如int *p[4]等等，", "\n\n", "数组不是在内存中的存储是连续的吗，", "\n\n", "为什么不用一级指针直接指向第一个元素呢?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;下面是我的理解&amp;#xff0c;供参考&amp;#xff1a;&lt;br /&gt;应该是swap函数的参数传递错误&amp;#xff0c;把字符指针temp1和temp2的地址传入swap函数&amp;#xff0c;交换的只是交换字符指针temp1和temp2的值&amp;#xff0c;temp1和temp2里面的值虽然和数组元素相同&amp;#xff0c;但是他们各自的地址却代表不同的含义&amp;#xff0c;然后对这个地址的解引用操作涉及的对象也不同&amp;#xff0c;所以二者不能替代&amp;#xff0c;交换temp1和temp2的值不是交换字符串数组的元素的值&amp;#xff0c;把相应字符串数组的元素的地址传入swap函数就可以了。&lt;br /&gt;代码修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt; &lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;define&lt;/span&gt; MAXLEN 1000&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;using&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;namespace&lt;/span&gt; std;\n \n&lt;span class=\"hljs-comment\"&gt;//字符串交换&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;str_swap1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; **str1, &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; **str2)&lt;/span&gt;&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *temp;\n    temp &amp;#61; *str1;  &lt;span class=\"hljs-comment\"&gt;//此时temp指向了*str1指针变量地址&lt;/span&gt;\n    *str1 &amp;#61; *str2;   &lt;span class=\"hljs-comment\"&gt;//形参中**str1是指向*str1指针的指针&amp;#xff0c;*str1指针变量地址修改成了*str2指针变量地址&lt;/span&gt;\n    *str2 &amp;#61; temp;  &lt;span class=\"hljs-comment\"&gt;//形参中**str2是指向*str2指针的指针&amp;#xff0c;*str2指针变量地址修改成了temp指针变量地址&lt;/span&gt;\n}\n \n&lt;span class=\"hljs-comment\"&gt;//字符串按字典排序&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;arr_sort&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *arr[], &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;{\n \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i,j;\n    &lt;span class=\"hljs-comment\"&gt;//插入排序&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;; i &amp;lt; len; &amp;#43;&amp;#43;i){\n        &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; index &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(j &amp;#61; i; j &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; --j){\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;strcmp&lt;/span&gt;(arr[j - &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;], arr[j]) &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;){\n               \n                &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n                cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;交换前&amp;#34;&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; len; &amp;#43;&amp;#43;k){\n                    cout &amp;lt;&amp;lt; arr[k] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n                }\n&lt;span class=\"hljs-comment\"&gt;//                &lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//                char *temp &amp;#61; arr[j - 1];&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//                char *temp1 &amp;#61; arr[j];&lt;/span&gt;\n                &lt;span class=\"hljs-built_in\"&gt;str_swap1&lt;/span&gt;(&amp;amp;arr[j&lt;span class=\"hljs-number\"&gt;-1&lt;/span&gt;],&amp;amp;arr[j]);  &lt;span class=\"hljs-comment\"&gt;//传入指针变量的地址&lt;/span&gt;\n               \n&lt;span class=\"hljs-comment\"&gt;//               char * temp &amp;#61; arr[j-1];&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//               arr[j-1]&amp;#61;arr[j];&lt;/span&gt;\n&lt;span class=\"hljs-comment\"&gt;//               arr[j]&amp;#61;temp;&lt;/span&gt;\n               \n              &lt;span class=\"hljs-comment\"&gt;//  printf(&amp;#34; swap: %s, %s&amp;#34;,temp,temp1);&lt;/span&gt;\n \n                cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;交换后&amp;#34;&lt;/span&gt;;\n                &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(k &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; k &amp;lt; len; &amp;#43;&amp;#43;k){\n                    cout &amp;lt;&amp;lt; arr[k] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34; &amp;#34;&lt;/span&gt;;\n                }\n                cout &amp;lt;&amp;lt; endl;\n            }\n        }\n    }\n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num,i;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *arr[num];  &lt;span class=\"hljs-comment\"&gt;//字符串数组&lt;/span&gt;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; str[MAXLEN];  &lt;span class=\"hljs-comment\"&gt;//输入的字符串&lt;/span&gt;\n \n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;num);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;输入%d个单词\\n&amp;#34;&lt;/span&gt;,num);\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num; &amp;#43;&amp;#43;i){\n       arr[i] &amp;#61; (&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *) &lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;) * MAXLEN);   &lt;span class=\"hljs-comment\"&gt;//如果未给arr[i]分配空间&amp;#xff0c;scanf会报错&amp;#xff1a;segmentation fault&lt;/span&gt;\n       &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,arr[i]);\n    }\n    \n    &lt;span class=\"hljs-comment\"&gt;// printf(&amp;#34;输入字符串\\n&amp;#34;);&lt;/span&gt;\n    &lt;span class=\"hljs-comment\"&gt;// scanf(&amp;#34;%s&amp;#34;,str);&lt;/span&gt;\n \n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; j;\n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;排序前:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num; &amp;#43;&amp;#43;i){\n        cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; endl;\n    }\n \n    &lt;span class=\"hljs-built_in\"&gt;arr_sort&lt;/span&gt;(arr,num);\n \n    cout &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;排序后:&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; endl;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; num; &amp;#43;&amp;#43;i){\n        cout &amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; endl;\n    }\n \n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/481306454756142.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["C语言字符指针数组交换问题", ["在C语言中，指针数组中的指针变量可以实现交换吗？我不清楚是我的代码问题，还是C语言本身就不支持指针数组中指针位置的交换，下面的交换得不到想要的结果。", "如题", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<string.h>", "\n", "#", "include", " ", "<iostream>", "\n", "#", "define", " MAXLEN 1000", "\n", "using", " ", "namespace", " std;\n\n", "//字符串交换", "\n", "void", " ", "str_swap1", "(", "char", " **str1, ", "char", " **str2)", "{\n    ", "char", " *temp;\n    temp = *str1;  ", "//此时temp指向了*str1指针变量地址", "\n    *str1 = *str2;   ", "//形参中**str1是指向*str1指针的指针，*str1指针变量地址修改成了*str2指针变量地址", "\n    *str2 = temp;  ", "//形参中**str2是指向*str2指针的指针，*str2指针变量地址修改成了temp指针变量地址", "\n}\n\n", "//字符串按字典排序", "\n", "void", " ", "arr_sort", "(", "char", " *arr[], ", "int", " len)", "{\n\n    ", "int", " i,j;\n    ", "//插入排序", "\n    ", "for", "(i = ", "1", "; i < len; ++i){\n        ", "int", " index = ", "0", ";\n        ", "for", "(j = i; j > ", "0", "; --j){\n            ", "if", "(", "strcmp", "(arr[j - ", "1", "], arr[j]) > ", "0", "){\n               \n                ", "int", " k = ", "0", ";\n                cout << ", "\"交换前\"", ";\n                ", "for", "(k = ", "0", "; k < len; ++k){\n                    cout << arr[k] << ", "\" \"", ";\n                }\n                \n                ", "char", " *temp = arr[j - ", "1", "];\n                ", "char", " *temp1 = arr[j];\n                ", "str_swap1", "(&temp,&temp1);  ", "//传入指针变量的地址", "\n                ", "printf", "(", "\" swap: %s, %s\"", ",temp,temp1);\n\n                cout << ", "\"交换后\"", ";\n                ", "for", "(k = ", "0", "; k < len; ++k){\n                    cout << arr[k] << ", "\" \"", ";\n                }\n                cout << endl;\n            }\n        }\n    }\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " num,i;\n    ", "char", " *arr[num];  ", "//字符串数组", "\n    ", "char", " str[MAXLEN];  ", "//输入的字符串", "\n\n    ", "scanf", "(", "\"%d\"", ",&num);\n    ", "printf", "(", "\"输入%d个单词\\n\"", ",num);\n    ", "for", "(i = ", "0", "; i < num; ++i){\n       arr[i] = (", "char", " *) ", "malloc", "(", "sizeof", "(", "char", ") * MAXLEN);   ", "//如果未给arr[i]分配空间，scanf会报错：segmentation fault", "\n       ", "scanf", "(", "\"%s\"", ",arr[i]);\n    }\n    \n    ", "// printf(\"输入字符串\\n\");", "\n    ", "// scanf(\"%s\",str);", "\n\n    ", "int", " j;\n    cout << ", "\"排序前:\"", " << endl;\n    ", "for", "(i = ", "0", "; i < num; ++i){\n        cout << arr[i] << endl;\n    }\n\n    ", "arr_sort", "(arr,num);\n\n    cout << ", "\"排序后:\"", " << endl;\n    ", "for", "(i = ", "0", "; i < num; ++i){\n        cout << arr[i] << endl;\n    }\n\n    ", "return", " ", "0", ";\n}\n", "\n", "输出结果为：", "\n", "3", "\n输入", "3", "个单词\npeach\n", "banana\n", "apple\n排序前:\npeach\n", "banana\n", "apple\n交换前peach ", "banana ", "apple  ", "swap: ", "banana, ", "peach交换后peach ", "banana ", "apple \n交换前peach ", "banana ", "apple  ", "swap: ", "apple, ", "banana交换后peach ", "banana ", "apple\n交换前peach ", "banana ", "apple  ", "swap: ", "banana, ", "peach交换后peach ", "banana ", "apple\n排序后:\npeach\n", "banana\n", "apple\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为需要在函数内为指针分配空间&amp;#xff0c;这样必须用二级指针才可以。只是指针参数的话是不能实现函数内修改指针地址的&lt;br /&gt;或者将root作为返回值&amp;#xff0c;改为&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; TreeNode&lt;span class=\"hljs-operator\"&gt; * &lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;CreateTree(&lt;span class=\"hljs-params\"&gt;struct&lt;/span&gt; TreeNode &lt;span class=\"hljs-operator\"&gt;*&lt;/span&gt;  &lt;span class=\"hljs-params\"&gt;root&lt;/span&gt;)&lt;/span&gt;\n{\n......\n     return root;\n}\n&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt; main&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;\n{\n  &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; TreeNode&lt;span class=\"hljs-operator\"&gt; *  &lt;/span&gt;root &amp;#61; NULL;\n  root &amp;#61; &lt;span class=\"hljs-constructor\"&gt;CreateTree(&lt;span class=\"hljs-params\"&gt;root&lt;/span&gt;)&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["c语言创建二叉树节点为啥要用二级指针？", ["为什么二叉树的根结点常常是指向指针的指针呢？如果根结点单单只是指针会怎么样？"]], "Tag": "程序设计"}
{"Answer": "不能这么转换，成员函数其实还有一个隐藏的this指针参数，在最后，而你普通函数，没有这个参数，导致堆栈不平衡。", "Konwledge_Point": "间接访问——指针", "Question": ["c++成员函数指针强制转换为一般函数指针出现问题", ["  class A\n {\n public:\n     int add(int a,int b)\n     {\n         int c = a+b;\n         return c;\n     }\n };\n typedef int (*pfun)(int,int);\n int main()\n{\n    pfun q =(pfun)&A::add;\n    int c = (*q)(7,8);\n    cout<<c<<endl;\n\n    return 1;\n}\n", "\n\n", "输出结果不是15，而是一个随机值，怎么回事？难道成员函数指针转为一般函数指针不安全吗？"]], "Tag": "程序设计"}
{"Answer": "检查一下dao调用mapper的方法是否使用param注解指定了参数名称，如果传入的是对象的话，在insert标签中需要写上入参类型，\r\n```\r\nparameterType=\"F728040Req\"\r\n```", "Konwledge_Point": "间接访问——指针", "Question": ["mybatis添加语句一直报空指针", ["传入的实体类", "\n\n", "public class F728040Req {\n    private Long clientId;\n    private String prodId;\n    private Long orderNum;\n\n    public Long getClientId() {\n        return clientId;\n    }\n\n    public void setClientId(Long clientId) {\n        this.clientId = clientId;\n    }\n\n    public String getProdId() {\n        return prodId;\n    }\n\n    public void setProdId(String prodId) {\n        this.prodId = prodId;\n    }\n\n    public Long getOrderNum() {\n        return orderNum;\n    }\n\n    public void setOrderNum(Long orderNum) {\n        this.orderNum = orderNum;\n    }\n}\n", "\n\n", "SQL语句", "\n\n", "<insert id=\"save\">\n        INSERT INTO PRODUCT_CONCERNS ( CLIENT_ID, PROD_ID, ORDER_NUM, CREATE_TIME)\n        VALUES\n            ( #{clientId}, #{prodId}, #{orderNum}, date_format(now(), '%Y%m%d%H%i%s'));\n    </insert>\n", "\n\n", "三个值全部都是有的，SQL语句也没有问题，放数据库就能跑，但就是报空指针的错误，即使把参数全都用常量替代，直接放数据库能成功，但这就是报空指针"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"492\" src=\"https://img-ask.csdnimg.cn/upload/1623922353553.png\" width=\"820\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;代码详见 &lt;a href=\"http://doc.xuehai.net/bfcc48799644df62ec23a6b7d.html\"&gt;http://doc.xuehai.net/bfcc48799644df62ec23a6b7d.html&lt;/a&gt; &lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["指针优化学生成绩排名", ["1．定义一个数组stu[10]存放10个学生的成绩，从键盘输入数据，要求用指针实现", "\n2．将数组stu[10]的内容输出到屏幕上，要求用指针实现", "\n3．将成绩数组按照从高到低进行排序，要求用指针实现", "\n4．将第三步内容放在函数中实现，在主函数中调用实现排序，用指针实现，输出排序后的成绩单", "\n5． 采用指针方法，输入字符串“student score ”,复制该字符串并输出（复制字符串采用库函数或用户自定义函数）"]], "Tag": "程序设计"}
{"Answer": "个人认为其实二维数组还是一维数组，没有什么区别，例如int a[3][4]，就相当于int a[12]。要想访问a[2][3],就用*（a+(4*2+3)*(sizeof（int）)）,应该是这样，不过我一般用a[4*2+3] 来访问对应的元素\n本人也是菜鸟，如果有错还请大神们指正~", "Konwledge_Point": "间接访问——指针", "Question": ["求大神讲解一下指针指向二维数组时该怎么用？", ["指针指向一维数组时只用*(p+n)即可，但是二维数组时候改怎么用呢？"]], "Tag": "程序设计"}
{"Answer": "[quote]那JAVA中怎样来调用呢,DLL我是没办法更改的!试过用JNative、JNA调用,都没有调用指针函数的示例.自己用C写一个DLL间接调用估计可以，但C写DLL不会...[/quote]\r\n用HANDLE作为返回指针。然后\r\nresultA.getPointer().getString(0)\r\n取得字符串。详情请看短信。", "Konwledge_Point": "间接访问——指针", "Question": ["java(JNA/JNative/JNI等)怎样调用 DLL 中 返回 指针 的函数 得到指针值?", ["JAVA", "(JNA/JNative/JNI等)怎样调用", "DLL", "中 返回指针的函数(指针函数)，得到", "其值", "(其指针对应的值)", "?", "\n\n", "以下给出其它语言的调用示例:", "\n\n", " ", "\n\n", "//////////////////////////////////////////////////////////////////////////////////////////", "\n\n", " ", "\n\n", "vb中的调用方式:", "Private Declare Function functionA Lib \"mydll.dll\" (ByVal a As Long, ByVal  b As Long, ByVal c As String, d As Long) As Long", "jieguo = \"    \"", "no1 = functionA(0,0,strA,0) '返回识别结果字符的指针", "no2 = lstrcpy(jieguo, no1) 'VB中用lstrcpy就可以从指针得到字符了，当然你也可以选择其他的方式", "\n\n", " ", "\n\n", "我要的就是", " ", "jiegou", "///////////////////////////////////////////////////////////////////////////////////////////", "\n\n", "vc中的调用:", "char* WINAPI functionA(...)", "    Def_API(tag_functionA, functionA, \"mydll.dll\")", "char* ret = functionA(...);", "我要的就是 ", "ret", "字符串", "\n\n", " ", "\n\n", "///////////////////////////////////////////////////////////////////////////////////////////", "\n\n", " ", "\n\n", "那JAVA中怎样来调用呢,DLL我是没办法更改的!试过用JNative、JNA调用,都没有调用", "指针函数", "的示例.自己用", "C", "写一个DLL", "间接", "调用估计可以，但C写DLL不会..."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;很简单&amp;#xff0c;第一次为什么controller接收不到&amp;#xff1f;&lt;br /&gt;因为第一次发的是get请求&amp;#xff0c;&lt;br /&gt;第二次发的post请求&amp;#xff0c;所以第一次数据接收不了。&lt;/p&gt;\n&lt;p&gt;解决在 controller中指定用post请求&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["为什么网页发生两次请求，第一次是空指针，报空指针异常", ["你好，我用的框架是Springboot+Mybatis+Thymeleaf+Redis。我想点击页面A，将页面A的一个字段xuhao通过ajax传到后端，然后点击页面A，跳转到页面B。将页面A的xuhao字段传递到页面B的后端。然后页面B来调用MyBatis，以xuhao为条件，查询数据库来显示相应的数据。", "但是问题是我这里页面B出现了两次请求，数据1是xuhao字段，数据2是通过MyBatis的查询的数据。", "第一次请求，xuhao出现了null，MyBatis出现了空指针错误。导致程序发生异常。", "第二次请求，xuhao正常，MyBatis数据正常的，结果如下", "\n", "数据", "1", "#null", "\n数据", "1", "#1", "\n数据", "2", "#黄河·宁夏·贺兰山", "\n\n", "\n", "第一次请求的空指针错误是这样的", "2022-07-30 13:08:16.477 ERROR 6208 --- [nio-8080-exec-8] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.NullPointerException] with root cause", "java.lang.NullPointerException: null", "为什么呢？", "这是页面A的后端代码", "\n", " @CrossOrigin\n    @", "RequestMapping(", "\"/querycp2\"", ")", "\n    @ResponseBody\n    public Model get", "Cangpin2(Model ", "mp", ",@RequestBody(", "required", " = ", "false", ")", " String xuhao){\n        ArrayList<Cangpin> cps= reds.get", "Result()", ";\n        ", "for", "(", "int", " i=", "0", ";i<cps.size", "()", ";i++) {\n            cps.get(i).set", "Yuanjia(", "new", " DecimalFormat(", "\"#0.00\"", ")", ".format(", "BigDecimal", ".", "value", "Of(Double.", "valueOf", "(", "cps", ".", "get", "(", "i", ")", ".get", "Yuanjia()", "))));\n            cps.get(i).set", "Xianjia(", "new", " DecimalFormat(", "\"#0.00\"", ")", ".format(", "BigDecimal", ".", "value", "Of(Double.", "valueOf", "(", "cps", ".", "get", "(", "i", ")", ".get", "Xianjia()", "))));\n        }\n        mp.add", "Attribute(", "\"cangpinlist\"", ", ", "cps", ")", ";\n        return mp;\n    }\n\n\n", "\n", "这是页面A的HTML前端代码", "\n", "<", "a", " ", "href", "=", "\"./li1.html\"", " ", "style", "=", "\"text-decoration: none\"", " ", "id", "=", "\"coo\"", ">", "\n        ", "<", "div", " ", "id", "=", "\"co\"", " ", "style", "=", "\"overflow:hidden;background-color: black\"", ">", "\n            ", "<", "div", " ", "id", "=", "\"cp\"", " ", "th:each", "=", "\"cangpin,cangpinStat:$", "{cangpinlist}", "\"", ">", "\n                ", "<", "div", " ", "id", "=", "\"stdlib\"", " ", "hidden", "=", "\"hidden\"", " ", "th:text", "=", "\"$", "{cangpin.xuhao}", "\"", " >", "</", "div", ">", "\n                ", "<", "div", " ", "id", "=", "\"cq\"", " ", "width", "=", "\"80%\"", " ", "height", "=", "\"auto\"", ">", "\n                    ", "<", "img", " ", "th:src", "=", "\"$", "{cangpin.path2}", "\"", ">", "\n                    ", "<", "p", " ", "class", "=", "\"cqb\"", " ", "style", "=", "\"display:none\"", " ", "th:text", "=", "\"$", "{cangpin.began}", "\"", ">", "</", "p", ">", "\n                    ", "<", "p", " ", "class", "=", "\"cqd\"", " ", "style", "=", "\"display:none\"", " ", "th:text", "=", "\"$", "{cangpin.num}", "\"", ">", "</", "p", ">", "\n                    ", "<", "p", " ", "class", "=", "\"cqc\"", ">", "</", "p", ">", "\n                ", "</", "div", ">", "\n                ", "<", "div", " ", "id", "=", "\"cqa\"", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span1\"", " ", "th:text", "=", "\"$", "{cangpin.cangpinname}", "\"", ">", "</", "nobr", ">", "<", "br", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span2\"", " ", "th:text", "=", "\"$", "{cangpin.type2}", "\"", ">", "</", "nobr", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span3\"", ">", "限量", "</", "nobr", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span4\"", " ", "th:text", "=", "\"$", "{cangpin.totalnum}", "\"", ">", "</", "nobr", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span5\"", " ", "th:text", "=", "\"'  '+$", "{cangpin.sys}", "\"", ">", "</", "nobr", ">", "<", "br", ">", "\n                    ", "<", "img", " ", "th:src", "=", "\"$", "{cangpin.icon}", "\"", " ", "style", "=", "\"height: 28px;width: 28px;margin-left:25px\"", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span6\"", " ", "th:text", "=", "\"'  '+$", "{cangpin.company}", "\"", ">", "</", "nobr", ">", "\n                    ", "<", "nobr", " ", "class", "=", "\"span7\"", "  ", "th:text", "=", "\"'  ￥'+$", "{cangpin.xianjia}", "\"", ">", "</", "nobr", ">", "\n                ", "</", "div", ">", "\n                ", "</", "div", ">", "\n            ", "</", "div", ">", "\n    ", "</", "a", ">", "\n\n", "\n", "\n", "这是页面A的ajax代码，ajax是正常的。stdlib是正常的，ajax是正常的", "\n", " ", "var", " stdlib=$(", "\"#stdlib\"", ").", "text", "();\n    $(", "\"#coo\"", ").", "click", "(", "function", " (", ") {\n        $.", "ajax", "({\n            ", "type", ":", "'post'", ",\n            ", "url", ":", "'./li1.html'", ",\n            ", "async", ":", "true", ",\n            ", "dataType", ":", "'json'", ",\n            ", "error", ":", "\"重新请求\"", ",\n            ", "contentType", ":", "\"application/json;charset=utf-8\"", ",\n            ", "data", ": stdlib,\n            ", "success", ":", "function", " (", "res", "){},\n            ", "Error", ":", "function", " (", "res", ") {}\n        });\n    })\n\n", "\n", "这是B页面的HTML的代码", "\n", "<!DOCTYPE ", "html", ">", "\n", "<", "html", " ", "lang", "=", "\"en\"", " ", "xmlns:th", "=", "\"http://www.thymeleaf.org\"", ">", "\n", "<", "head", ">", "\n    ", "<", "meta", " ", "charset", "=", "\"UTF-8\"", ">", "\n    ", "<", "title", ">", "Title", "</", "title", ">", "\n    ", "<", "script", " ", "src", "=", "\"https://code.jquery.com/jquery-3.3.1.min.js\"", ">", "</", "script", ">", "\n", "</", "head", ">", "\n", "<", "body", ">", "\n", "<", "p", " ", "id", "=", "\"st\"", " ", "th:text", "=", "\"$", "{det.cangpinname}", "\"", ">", "</", "p", ">", "\n", "<", "script", ">", "\n\n", "</", "script", ">", "\n", "</", "body", ">", "\n", "</", "html", ">", "\n\n", "\n", "\n", "这是B页面的后端代码", "\n", "@", "RequestMapping(", "\"/li1.html\"", ")", "\n    @ResponseBody\n    @CrossOrigin\n    public Model get", "CangpinDetail(Model ", "mp", ", @RequestBody(", "required", " = ", "false", ")", "String xuhao){\n      mapper mapper2 = getCangpinArr.get", "CangpinMap()", ";\n      Details det = mapper2.", "CangpinDetail(", "xuhao", ")", ";\n      ", "System", ".", "out.println(", "\"数据1#\"", " + xuhao);\n      ", "System", ".", "out.println(", "\"数据2#\"", " + det.get", "Cangpinname()", ");\n      mp.add", "Attribute(", "\"det\"", ", ", "det", ")", ";\n      return mp;\n    }\n\n", "\n", "这是MyBatis的相对应的接口的代码、", "\n", " ", "@Select", "(", "\"select * from cangpin inner join singlecangpin where cangpin.xuhao=singlecangpin.xuhao and cangpin.xuhao=#{xuhao}\"", ")\n    Details CangpinDetail(", "@Param", "(", "\"xuhao\"", ") String xuhao);\n\n", "\n", "MyBatis是正常的。", "我的目标是只发出一次请求，而且一次请求就是正常的，能正常显示数据。", "而不是发出两次请求，第一次是空指针，第二次是正常的。所以网页不能正常显示，网页直接显示空指针异常，导致网页异常，不能正常显示B页面。B页面无法正常显示，显示错误。错误页面如下：", "\n", "大家看看怎么才能解决这个问题，使得网页只发出一次请求，而且一次请求就是正常的，而不是两次请求，一次异常空指针，第二次正常。这是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "\\*p 首先指针不建议初始化为0， 建议统一为NULL\r\n其次，一个未被分配地址的指针，是指向内存中任意一个地址块的，就是俗称的野指针\r\n而你这个程序，不存在野指针的情况，但是你初始化 p指向了地址 0x0000000\r\n\r\n这个地址，理论上是存在的，但是野指针 和 你这个全0指针 ，有个共同特点，就是你这个程序是未被授权访问的。\r\n\r\n你如果对汇编、或者C的编译器稍有认知，就知道系统会给程序 划分了“数据段”“代码段”等存储地址区间，\r\n每个区间都是有地址范围的，从基址开始偏移多少等等的范围，这个范围就是你的程序被授权访问的地址范围\r\n\r\n而野指针和你定义的全0指针，指向了这个范围以外的内存区块，这个区块是实际存在的，但是无权访问，\r\n最终就会报错 读取位置 0x00000000 时访问冲突。\r\n\r\n\r\n所以你这个程序，在使用\\*p之前，应该先判断  p != 0x0000000\r\n但我建议最好用NULL", "Konwledge_Point": "间接访问——指针", "Question": ["请问指针访问内存像下面图中这种情况是怎么回事？谢谢！", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;java.lang.IllegalStateException: Failed to load ApplicationContext 现在是这个问题&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["Mybatis-Plus 空指针异常", ["public", " ", "class", " ", "User", " {\n    ", "@TableId", "(\n            value = ", "\"id\"", ",\n            ", "type", " = ", "IdType", ".", "AUTO", "\n    )\n    ", "private", " ", "Integer", " id;\n    ", "private", " ", "String", " name;\n    ", "private", " ", "Integer", " age;\n    ", "private", " ", "String", " email;\n\n    ", "public", " ", "Integer", " ", "getId", "(", ") {\n        ", "return", " id;\n    }\n\n    ", "public", " ", "void", " ", "setId", "(", "Integer id", ") {\n        ", "this", ".", "id", " = id;\n    }\n\n    ", "public", " ", "String", " ", "getName", "(", ") {\n        ", "return", " name;\n    }\n\n    ", "public", " ", "void", " ", "setName", "(", "String", " name", ") {\n        ", "this", ".", "name", " = name;\n    }\n\n    ", "public", " ", "Integer", " ", "getAge", "(", ") {\n        ", "return", " age;\n    }\n\n    ", "public", " ", "void", " ", "setAge", "(", "Integer age", ") {\n        ", "this", ".", "age", " = age;\n    }\n\n    ", "public", " ", "String", " ", "getEmail", "(", ") {\n        ", "return", " email;\n    }\n\n    ", "public", " ", "void", " ", "setEmail", "(", "String", " email", ") {\n        ", "this", ".", "email", " = email;\n    }\n\n    ", "@Override", "\n    ", "public", " ", "String", " ", "toString", "(", ") {\n        ", "return", " ", "\"User{\"", " +\n                ", "\"id=\"", " + id +\n                ", "\", name='\"", " + name + ", "'\\''", " +\n                ", "\", age=\"", " + age +\n                ", "\", email='\"", " + email + ", "'\\''", " +\n                ", "'}'", ";\n    }\n}\n\n", "\n", "mapper", "\n", "package lixiaobin.mapper;\n\n", "import", " com.baomidou.mybatisplus.core.mapper.BaseMapper;\n", "import", " lixiaobin.entity.User;\n", "/*\n* 1.Mapper,就是Dao接口\n* 2.指定实体类\n*\n*BaseMapper是MP框架中的对象，定义了17个操作方法\n*\n* */", "\n", "public", " ", "interface", " ", "UserMapper", " ", "extends", " ", "BaseMapper", "<", "User", "> {\n\n}\n\n\n", "\n", "Application", "\n", "import", " org.", "mybatis", ".", "spring", ".", "annotation", ".", "MapperScan", ";\n", "import", " org.", "springframework", ".", "boot", ".", "SpringApplication", ";\n", "import", " org.", "springframework", ".", "boot", ".", "autoconfigure", ".", "SpringBootApplication", ";\n", "/*\n* @MapperScan 扫描mapper文件\n* */", "\n", "@SpringBootApplication", "\n", "@MapperScan", "(", "\"lixiaobin.mapper\"", ")\n", "public", " ", "class", " ", "Application", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n        ", "SpringApplication", ".", "run", "(", "Application", ".", "class", ", args);\n    }\n}\n\n\n", "\n", "测试类", "\n", "import", " lixiaobin.entity.", "User", ";\n", "import", " lixiaobin.mapper.UserMapper;\n", "import", " org.junit.", "Assert", ";\n", "import", " org.junit.Test;\n", "import", " org.junit.runner.RunWith;\n", "import", " org.mybatis.spring.annotation.MapperScan;\n", "import", " org.springframework.beans.factory.annotation.Autowired;\n", "import", " org.springframework.boot.autoconfigure.SpringBootApplication;\n", "import", " org.springframework.boot.test.context.SpringBootTest;\n\n", "import", " java.util.List;\n\n\n@SpringBootTest\n\n", "public", " ", "class", " Application {\n    //使用自动注入\n    @Autowired\n    private UserMapper userMapper;\n    @Test\n    ", "public", " ", "void", " testSelect(){\n        ", "System", ".", "out", ".println(\"-------SelectAll method test ---------\");\n        List<", "User", "> users = userMapper.selectList(", "null", ");\n        ", "Assert", ".assertEquals(", "5", ",users.size());\n        users.", "forEach", "(", "System", ".", "out", "::println);\n    }\n}\n\n", "\n", "空指针异常", "\n", "C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\bin\\java.exe -ea -Didea.test.cyclic.buffer.size=1048576 \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.4\\lib\\idea_rt.jar=53990:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.4\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.4\\lib\\idea_rt.jar;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.4\\plugins\\junit\\lib\\junit5-rt.jar;C:\\Program Files\\JetBrains\\IntelliJ IDEA 2020.2.4\\plugins\\junit\\lib\\junit-rt.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\charsets.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\cldrdata.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\dnsns.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\jaccess.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\jfxrt.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\localedata.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\nashorn.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\sunec.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\sunmscapi.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\ext\\zipfs.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\jce.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\jfr.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\jfxswt.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\jsse.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\management-agent.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\resources.jar;C:\\Users\\李晓彬.jdks\\corretto-1.8.0_302\\jre\\lib\\rt.jar;C:\\Users\\李晓彬\\IdeaProjects\\Mybatis-Plus\\target\\test-classes;C:\\Users\\李晓彬\\IdeaProjects\\Mybatis-Plus\\target\\classes;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-starter\\2.6.3\\spring-boot-starter-2.6.3.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot\\2.6.3\\spring-boot-2.6.3.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-context\\5.3.15\\spring-context-5.3.15.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-aop\\5.3.15\\spring-aop-5.3.15.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-beans\\5.3.15\\spring-beans-5.3.15.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-expression\\5.3.15\\spring-expression-5.3.15.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-autoconfigure\\2.6.3\\spring-boot-autoconfigure-2.6.3.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-logging\\2.6.3\\spring-boot-starter-logging-2.6.3.jar;C:\\Users\\李晓彬.m2\\repository\\ch\\qos\\logback\\logback-classic\\1.2.10\\logback-classic-1.2.10.jar;C:\\Users\\李晓彬.m2\\repository\\ch\\qos\\logback\\logback-core\\1.2.10\\logback-core-1.2.10.jar;C:\\Users\\李晓彬.m2\\repository\\org\\apache\\logging\\log4j\\log4j-to-slf4j\\2.17.1\\log4j-to-slf4j-2.17.1.jar;C:\\Users\\李晓彬.m2\\repository\\org\\apache\\logging\\log4j\\log4j-api\\2.17.1\\log4j-api-2.17.1.jar;C:\\Users\\李晓彬.m2\\repository\\org\\slf4j\\jul-to-slf4j\\1.7.33\\jul-to-slf4j-1.7.33.jar;C:\\Users\\李晓彬.m2\\repository\\jakarta\\annotation\\jakarta.annotation-api\\1.3.5\\jakarta.annotation-api-1.3.5.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-core\\5.3.15\\spring-core-5.3.15.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-jcl\\5.3.15\\spring-jcl-5.3.15.jar;C:\\Users\\李晓彬.m2\\repository\\org\\yaml\\snakeyaml\\1.29\\snakeyaml-1.29.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-test\\2.5.6\\spring-boot-starter-test-2.5.6.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-test-autoconfigure\\2.5.6\\spring-boot-test-autoconfigure-2.5.6.jar;C:\\Users\\李晓彬.m2\\repository\\com\\jayway\\jsonpath\\json-path\\2.5.0\\json-path-2.5.0.jar;C:\\Users\\李晓彬.m2\\repository\\net\\minidev\\json-smart\\2.3\\json-smart-2.3.jar;C:\\Users\\李晓彬.m2\\repository\\net\\minidev\\accessors-smart\\1.2\\accessors-smart-1.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\ow2\\asm\\asm\\5.0.4\\asm-5.0.4.jar;C:\\Users\\李晓彬.m2\\repository\\org\\slf4j\\slf4j-api\\1.7.30\\slf4j-api-1.7.30.jar;C:\\Users\\李晓彬.m2\\repository\\jakarta\\xml\\bind\\jakarta.xml.bind-api\\2.3.3\\jakarta.xml.bind-api-2.3.3.jar;C:\\Users\\李晓彬.m2\\repository\\jakarta\\activation\\jakarta.activation-api\\1.2.2\\jakarta.activation-api-1.2.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\assertj\\assertj-core\\3.19.0\\assertj-core-3.19.0.jar;C:\\Users\\李晓彬.m2\\repository\\org\\hamcrest\\hamcrest\\2.2\\hamcrest-2.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\junit\\jupiter\\junit-jupiter\\5.7.2\\junit-jupiter-5.7.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-api\\5.7.2\\junit-jupiter-api-5.7.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\apiguardian\\apiguardian-api\\1.1.0\\apiguardian-api-1.1.0.jar;C:\\Users\\李晓彬.m2\\repository\\org\\opentest4j\\opentest4j\\1.2.0\\opentest4j-1.2.0.jar;C:\\Users\\李晓彬.m2\\repository\\org\\junit\\platform\\junit-platform-commons\\1.7.2\\junit-platform-commons-1.7.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-params\\5.7.2\\junit-jupiter-params-5.7.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\junit\\jupiter\\junit-jupiter-engine\\5.7.2\\junit-jupiter-engine-5.7.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\junit\\platform\\junit-platform-engine\\1.7.2\\junit-platform-engine-1.7.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\mockito\\mockito-core\\3.9.0\\mockito-core-3.9.0.jar;C:\\Users\\李晓彬.m2\\repository\\net\\bytebuddy\\byte-buddy\\1.10.20\\byte-buddy-1.10.20.jar;C:\\Users\\李晓彬.m2\\repository\\net\\bytebuddy\\byte-buddy-agent\\1.10.20\\byte-buddy-agent-1.10.20.jar;C:\\Users\\李晓彬.m2\\repository\\org\\objenesis\\objenesis\\3.2\\objenesis-3.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\mockito\\mockito-junit-jupiter\\3.9.0\\mockito-junit-jupiter-3.9.0.jar;C:\\Users\\李晓彬.m2\\repository\\org\\skyscreamer\\jsonassert\\1.5.0\\jsonassert-1.5.0.jar;C:\\Users\\李晓彬.m2\\repository\\com\\vaadin\\external\\google\\android-json\\0.0.20131108.vaadin1\\android-json-0.0.20131108.vaadin1.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-test\\5.3.12\\spring-test-5.3.12.jar;C:\\Users\\李晓彬.m2\\repository\\org\\xmlunit\\xmlunit-core\\2.8.3\\xmlunit-core-2.8.3.jar;C:\\Users\\李晓彬.m2\\repository\\com\\baomidou\\mybatis-plus-boot-starter\\3.5.1\\mybatis-plus-boot-starter-3.5.1.jar;C:\\Users\\李晓彬.m2\\repository\\com\\baomidou\\mybatis-plus\\3.5.1\\mybatis-plus-3.5.1.jar;C:\\Users\\李晓彬.m2\\repository\\com\\baomidou\\mybatis-plus-extension\\3.5.1\\mybatis-plus-extension-3.5.1.jar;C:\\Users\\李晓彬.m2\\repository\\com\\baomidou\\mybatis-plus-core\\3.5.1\\mybatis-plus-core-3.5.1.jar;C:\\Users\\李晓彬.m2\\repository\\com\\baomidou\\mybatis-plus-annotation\\3.5.1\\mybatis-plus-annotation-3.5.1.jar;C:\\Users\\李晓彬.m2\\repository\\com\\github\\jsqlparser\\jsqlparser\\4.3\\jsqlparser-4.3.jar;C:\\Users\\李晓彬.m2\\repository\\org\\mybatis\\mybatis\\3.5.9\\mybatis-3.5.9.jar;C:\\Users\\李晓彬.m2\\repository\\org\\mybatis\\mybatis-spring\\2.0.6\\mybatis-spring-2.0.6.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-starter-jdbc\\2.5.3\\spring-boot-starter-jdbc-2.5.3.jar;C:\\Users\\李晓彬.m2\\repository\\com\\zaxxer\\HikariCP\\4.0.3\\HikariCP-4.0.3.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-jdbc\\5.3.9\\spring-jdbc-5.3.9.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\spring-tx\\5.3.9\\spring-tx-5.3.9.jar;C:\\Users\\李晓彬.m2\\repository\\org\\springframework\\boot\\spring-boot-test\\2.2.6.RELEASE\\spring-boot-test-2.2.6.RELEASE.jar;C:\\Users\\李晓彬.m2\\repository\\mysql\\mysql-connector-java\\8.0.23\\mysql-connector-java-8.0.23.jar;C:\\Users\\李晓彬.m2\\repository\\com\\google\\protobuf\\protobuf-java\\3.11.4\\protobuf-java-3.11.4.jar;C:\\Users\\李晓彬.m2\\repository\\junit\\junit\\4.13.2\\junit-4.13.2.jar;C:\\Users\\李晓彬.m2\\repository\\org\\hamcrest\\hamcrest-core\\1.3\\hamcrest-core-1.3.jar\" com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit4 Application", "-------SelectAll method test ---------", "\n", "java.lang.NullPointerException", "    at Application.testSelect(Application.java:23)", "    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)", "    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)", "    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)", "    at java.lang.reflect.Method.invoke(Method.java:498)", "    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)", "    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)", "    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)", "    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)", "    at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)", "    at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)", "    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)", "    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)", "    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)", "    at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)", "    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)", "    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)", "    at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)", "    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)", "    at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)", "    at org.junit.runners.ParentRunner.run(ParentRunner.java:413)", "    at org.junit.runner.JUnitCore.run(JUnitCore.java:137)", "    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)", "    at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)", "    at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220)", "    at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53)", "\n", "Process finished with exit code -1"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;所谓指针域就是指向下一个节点的指针&amp;#xff0c;实际上是一个地址&amp;#xff0c;node*表示指针所指的数据类型是node&amp;#xff08;node一旦被定义了之后就可以作为一种数据类型来使用&amp;#xff09;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["链表的结点的结构体指针域的定义", ["定义链表结点的结构体时，为什么定义指针域是用struct Node *？"]], "Tag": "程序设计"}
{"Answer": "两个指针变量之间可以相互赋值，p和q都是int类型的指针。\r\np=q表示将q所指向的int类型变量的地址赋给p", "Konwledge_Point": "间接访问——指针", "Question": ["两个指针变量可以相互赋值吗？", ["int *p, *q;", "\np=q;", "\n这样写是什么意思？是p指向q吗?"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-xml\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;fun&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; y, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* p, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;* q, &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt;* s)&lt;/span&gt;\n&lt;/span&gt;{\n    *p &amp;#61; x &amp;#43; y;\n    *q &amp;#61; x * y;\n    *s &amp;#61; (x &amp;#43; y) * &lt;span class=\"hljs-number\"&gt;0.5&lt;/span&gt;;\n}\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x, y, sum, product; &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; aver;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d %d&amp;#34;&lt;/span&gt;, &amp;amp;x, &amp;amp;y);\n    &lt;span class=\"hljs-built_in\"&gt;fun&lt;/span&gt;(x, y, &amp;amp;sum, &amp;amp;product, &amp;amp;aver);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d,%d,%.1f&amp;#34;&lt;/span&gt;, sum, product, aver);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["指针做参数:求两数的和，积，平均值", [" 指针做参数: 求两数的和、积、平均值。", "本题求两整数的和、积、平均值。要求用原型是 void fun(int x, int y, int *p, int *q,float *s) 的函数来实现。", "\n", "函数接口定义：", "void fun(int x, int y, int *p, int *q,float *s) ;", "其中x和y是需要计算的两个数，p、 q、s指向的变量保存计算结果。", "\n", "裁判测试程序样例：", "在这里给出函数被调用进行测试的例子。例如：", "#include <stdio.h>", "\n", "void fun(int x, int y, int *p, int *q, float  *s) ;", "int main()", "{", " int x,y,sum,product; float aver;", "  scanf(\"%d%d\", &x, &y);", "  fun (x ,y, &sum,&product,&aver );", "  printf(\"%d,%d,%.1f\", sum,product,aver);", "  return 0;", "}", "\n", "/* 请在这里填写答案 */", "输入样例：", "31 2", "输出样例：", "33,62,16.5"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;几维向量&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["C语言问题 指针 求向量内积", ["请问大家怎么用C语言指针编写程序，题目是求两个向量的内积。谢谢大家"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#xff08;1&amp;#xff09;检查是否指针申请了空间。&lt;br /&gt;&amp;#xff08;2&amp;#xff09;代码示例如下&amp;#xff1a;&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/099029063056164.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["指针赋值用strcpy怎么操作", ["定义了两个指针，把第一个指针用strcpy复制给第二个指针，报错说第二个指针没初始化，给第二个指针赋“\\0”也运行不了"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;)&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt;\n{\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; num;\n&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; name[&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;];\n&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; score[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;];\n} stu &amp;#61; {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;2012&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;WuHua&amp;#34;&lt;/span&gt;, {&lt;!-- --&gt;&lt;span class=\"hljs-number\"&gt;75.4f&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;80&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;92&lt;/span&gt;}};\n&lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;student&lt;/span&gt; *ptr;\n\nptr &amp;#61; &amp;amp;stu;\n\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s\\n&amp;#34;&lt;/span&gt;, ptr-&amp;gt;name);\n\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["使用指针输出结构体变量stu的成员name之值", ["#include<stdio.h>", "int main(void)", "{", "    struct student", "    {", "            int num;", "            char name[10];", "            float score[3];", "    } stu = {2012,  \"WuHua\",  {75.4f, 80, 92}};", "    struct student *ptr;", "\n", "   3 分", "\n", "printf", "(", "\"%s\\n\"", ", ", "3", " 分\n", "\n", "); /* 必须使用指针变量ptr实现 */", "\n", "return", " ", "0", ";\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;getCheck 方法的jdbcTemplate是个空对象&amp;#xff0c;怎么可能调到方法&amp;#xff0c;将JdbcTemplate jdbcTemplate提出方法外&amp;#xff0c;进行自动注入&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["springboot+jdbcTemplate出现空指针错误", ["你好，我使用springboot的时候，使用的是jdbcTemplate（mybatis太麻烦，不用了），在执行查询语句时，出现了空指针错误，我的IDEA报的空指针错误是这样的", "java.lang.NullPointerException: null", "这是为什么呢？", "附代码", "bean代码", "\n", "package com.", "example", ".", "demo", ".", "bean", ";\n\n", "public", " ", "class", " ", "Cangpin", " {\n    ", "private", " long xuhao;\n    ", "private", " ", "String", " path2;\n\n    ", "public", " ", "String", " ", "getPath2", "(", ") {\n        ", "return", " path2;\n    }\n\n    ", "public", " ", "void", " ", "setPath2", "(", "String", " path2", ") {\n        ", "this", ".", "path2", " = path2;\n    }\n\n    ", "private", " ", "String", " sys;\n\n    ", "public", " long ", "getXuhao", "(", ") {\n        ", "return", " xuhao;\n    }\n\n    ", "public", " ", "void", " ", "setXuhao", "(", "long xuhao", ") {\n        ", "this", ".", "xuhao", " = xuhao;\n    }\n\n\n\n    ", "public", " ", "String", " ", "getSys", "(", ") {\n        ", "return", " sys;\n    }\n\n    ", "public", " ", "void", " ", "setSys", "(", "String", " sys", ") {\n        ", "this", ".", "sys", " = sys;\n    }\n\n    ", "public", " ", "String", " ", "getCangpinname", "(", ") {\n        ", "return", " cangpinname;\n    }\n\n    ", "public", " ", "void", " ", "setCangpinname", "(", "String", " cangpinname", ") {\n        ", "this", ".", "cangpinname", " = cangpinname;\n    }\n\n    ", "public", " double ", "getYuanjia", "(", ") {\n        ", "return", " yuanjia;\n    }\n\n    ", "public", " ", "void", " ", "setYuanjia", "(", "double yuanjia", ") {\n        ", "this", ".", "yuanjia", " = yuanjia;\n    }\n\n    ", "public", " double ", "getXianjia", "(", ") {\n        ", "return", " xianjia;\n    }\n\n    ", "public", " ", "void", " ", "setXianjia", "(", "double xianjia", ") {\n        ", "this", ".", "xianjia", " = xianjia;\n    }\n\n    ", "public", " int ", "getNum", "(", ") {\n        ", "return", " num;\n    }\n\n    ", "public", " ", "void", " ", "setNum", "(", "int num", ") {\n        ", "this", ".", "num", " = num;\n    }\n\n    ", "private", " ", "String", " cangpinname;\n    ", "private", " double yuanjia;\n    ", "private", " double xianjia;\n    ", "private", " int num;\n}\n\n", "\n", "这是controller代码", "\n", "package com.", "example", ".", "demo", ".", "controller", ";\n\n", "import", " com.", "example", ".", "demo", ".", "bean", ".", "Cangpin", ";\n", "import", " com.", "example", ".", "demo", ".", "dao", ".", "CangpinDao", ";\n", "import", " org.", "springframework", ".", "beans", ".", "factory", ".", "annotation", ".", "Autowired", ";\n", "import", " org.", "springframework", ".", "jdbc", ".", "core", ".", "BeanPropertyRowMapper", ";\n", "import", " org.", "springframework", ".", "jdbc", ".", "core", ".", "JdbcTemplate", ";\n", "import", " org.", "springframework", ".", "stereotype", ".", "Controller", ";\n", "import", " org.", "springframework", ".", "web", ".", "bind", ".", "annotation", ".", "RequestMapping", ";\n\n", "@Controller", "\n", "public", " ", "class", " ", "CangpinController", " {\n    ", "@Autowired", "\n    ", "private", " ", "CangpinDao", " cpDao;\n    ", "@RequestMapping", "(", "\"/save\"", ")\n    ", "public", " ", "String", " ", "getCpDao", "(", ") {\n        ", "Cangpin", " cp=", "new", " ", "Cangpin", "();\n        cp.", "setXuhao", "(", "1", ");\n        cp.", "setPath2", "(", "\"da\"", ");\n        cp.", "setSys", "(", "\"ss\"", ");\n        cp.", "setCangpinname", "(", "\"银币\"", ");\n        cp.", "setYuanjia", "(", "188.0", ");\n        cp.", "setXianjia", "(", "18.0", ");\n        cp.", "setNum", "(", "8844", ");\n        cpDao.", "save", "(cp);\n        ", "return", " ", "\"插入成功\"", ";\n    }\n    ", "@RequestMapping", "(", "\"/check\"", ")\n    ", "public", " ", "void", " ", "getCheck", "(", ")\n    {\n        ", "JdbcTemplate", " jdbcTemplate=", "null", ";\n        ", "String", " sql=", "\"select * from cangpin where xuhao =?\"", ";\n        ", "Cangpin", " cp = jdbcTemplate.", "queryForObject", "(sql,", "new", " ", "BeanPropertyRowMapper", "<", "Cangpin", ">(", "Cangpin", ".", "class", "),", "1", ");\n        ", "System", ".", "out", ".", "println", "(cp.", "getCangpinname", "());\n    }\n}\n\n\n", "\n", "这是DAO层代码", "\n", "package", " com.example.demo.dao;\n\n", "import", " com.example.demo.bean.Cangpin;\n", "import", " org.springframework.beans.factory.annotation.Autowired;\n", "import", " org.springframework.jdbc.core.BeanPropertyRowMapper;\n", "import", " org.springframework.jdbc.core.JdbcTemplate;\n", "import", " org.springframework.stereotype.Repository;\n\n", "import", " javax.annotation.Resource;\n", "import", " java.util.ArrayList;\n\n\n", "@Repository", "\n", "public", " ", "class", " ", "CangpinDao", " {\n    ", "@Resource(name=\"jdbcTemplate\")", "\n    ", "@Autowired", "\n    ", "private", " JdbcTemplate jdbcTemplate;\n    ", "public", " ", "void", " ", "save", "(Cangpin cangpin)", "{\n        jdbcTemplate.update(", "\"insert into cangpin(xuhao,path2,sys,cangpinname,yuanjia,xianjia,num) values (?,?,?,?,?,?,?)\"", ",\n                cangpin.getXuhao(),cangpin.getPath2(),cangpin.getSys(),cangpin.getCangpinname(),\n                cangpin.getYuanjia(),cangpin.getXianjia(),cangpin.getNum());\n    }\n}\n\n", "\n", "我启动springboot，是能够正常启动的，但是输入相应的地址路径，就会出现空指针异常，这是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;cout &amp;lt;&amp;lt; *p.height &amp;lt;&amp;lt; endl;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["C++类中的成员是一个指针，我该如何访问，请大佬解惑！", ["\n", "#include <iostream>\n#include<string>\nusing namespace std;\nclass Person {\nprivate:\n\t\npublic:\n\t//传统初始化\n\tstring name;\n\tint age;\n\tint *height;\n\tPerson(string a, int b, int c) {\n\t\tname = a;\n\t\tage = b;\n\t\theight =new int(c);\n\n\t}\n\n\n};\nvoid test01() {\n\n\tPerson p(\"haha\", 1, 2);\n\tcout << p.age << endl;\n\tcout << p.name << endl;\n\tcout << p.height << endl;\n\n}\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}", "\n\n", "cout << p.height << endl;这一句只能显示内存地址，如果我想显示他本身代表的值应该如何操作，请问？", "\n\n", "我是C++初学者，p.*height,p->height,p->*height这些写法都报错，请问该如何解决，谢谢~~~"]], "Tag": "程序设计"}
{"Answer": "1、需要输入10个数字，你的代码没有输出，当然没有反应。\r\n2、不可以修改。p&lt;p+5不是永远成立了？？p在++，这样会造成越界访问。", "Konwledge_Point": "间接访问——指针", "Question": ["C语言指针指向数组问题", ["#include", "\n\n", "int main(){\n   int a[5];\n   int *p,i;\n   printf(\"please enter ten numbers:\");\n   for(i=0;i<5;i++){\n      scanf(\"%d\",&a[i]);\n   }\n   for(p=a;p<(a+5);p++)\n      scanf(\"%d\",*p);\n   printf(\"\\n\");\n\n\n   return 0;\n}\n", "\n\n", "代码如图，是课本上的例题，我运行后输入五个数字以后没有反应。而且还想问一下，将第二个for循环中的（a+5）改为（p+5）可以吗？", "\n\n", "万分感谢！！！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;结果是不一样的&lt;br /&gt;如果head.next.next是null的话&lt;br /&gt;你老师返回是head&lt;br /&gt;你返回是 slow&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["快慢指针代码—— 奇数长度返回中点前一个，偶数长度返回下中点前一个", ["原问题是，奇数长度返回中点前一个，偶数长度返回下中点前一个。", "\n", "然后这个图片左边是👨‍🏫的右边是我的，👨‍🏫写了两个if 但我看一个if就够了，下边while循环中能包含的上呀", "想问一下我那么写是不也对。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;pIMFP_interp这个指针有没有new出来&amp;#xff1f;这种问题大部分都是因为使用了野指针导致的。&lt;br /&gt;野指针可能是&amp;#xff1a;&lt;br /&gt;&amp;#xff08;1&amp;#xff09;未初始化的指针&amp;#xff0c;比如成员变量声明了&amp;#xff0c;但是在构造函数中没有初始化为NULL&amp;#xff0c;后面使用的时候也没有new出来&lt;br /&gt;&amp;#xff08;2&amp;#xff09;指针在使用时已经被销毁&amp;#xff0c;也就是delete或者destory后&amp;#xff0c;指针没有重置为NULL&amp;#xff0c;在使用的时候也没有判断指针是否为NULL&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["VS2010调试程序时报错：读取位置时发生访问冲突。", ["问题遇到的现象和发生背景", "\n", "用vs2010调试程序的时候跳出XX.exe中的 0x00ae66bf 处有未经处理的异常: 0xC0000005: 读取位置 0xccccccf4 时发生访问冲突。", "\n", "问题相关代码，请勿粘贴截图", "\n", "经过调试发现主程序的报错是这句：", "PennScatter PennAu = PennScatter(\"OptDataAu.dat\", energy, 5.53, 220, 5.1);", "\n", "进入构造函数：", "PennScatter::PennScatter(const char* DataFileName, const double E, const double Ef, const double Eb, const double Wk)", "        : Energy(E), FermiE(Ef), BindingEnergy(Eb), WorkFunction(Wk)", "{", "            this->pOptData = new OptData(DataFileName);", "            DataLoaded = !pOptData->Ep.empty();", "            if(DataLoaded) {", "                ", "MeanFreePath();", "            }", "}", "\n", "MeanFreePath函数出错；", "继续进去：", "\n", "double PennScatter::MeanFreePath()", "{", "    double IMeanFreePath = this->pPartCSInterp->", "getIMFP(this->Energy)", ";", "    this->MFP = IMeanFreePath;", "    return IMeanFreePath;", "}", "\n", "getIMFP(this->Energy)出错，再进：", "\n", "double PartCSInterp::getIMFP(const double E)", "{", "    return pIMFP_interp->interp(E);", "}", "执行到return这句就不行了。", "\n", "运行结果及报错内容", "\n", "报错：CalPennPartCS.exe 中的 0x00d266bf 处有未经处理的异常: 0xC0000005: 读取位置 0xccccccf4 时发生访问冲突", "\n", "我想要达到的结果", "\n", "整个程序附在百度网盘里了：", "链接:", "https://pan.baidu.com/s/1-KbsuTQJAWGt7JdzC-ewjA", "  密码:49pz", "请求帮忙解答一下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以的&amp;#xff0c;但要看你是不是要传递的是指针类型的引用啊&lt;br /&gt;比如 void fun(char *&amp;amp;p)&lt;br /&gt;那么你实参可以是char *p&lt;br /&gt;但如果是  void fun(char &amp;amp;p)&lt;br /&gt;那么实参就不能是 char *p&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["当形参是引用时，实参可以是指针吗为什么？", ["当形参是引用时，实参可以是指针吗为什么？当形参是引用时，实参可以是指针吗为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;ul&gt;&lt;li&gt;你看下这篇博客吧, 应该有用&amp;#x1f449; &amp;#xff1a;&lt;a href=\"https://blog.csdn.net/weixin_45581345/article/details/102678338\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;font size=\"3\"&gt;C语言中的字符&amp;#xff08;char&amp;#xff09;&lt;/font&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["c语言中怎么提取char指针指向的char数组第一个字符", ["例如下面这个代码，我需要将buff传到函数里面去处理，为了对比第一个字符是不是特定的字符，第一个字符是一个标记", "\n", "\n", "const", " ", "char", " buf[", "5", "] = {", "'1'", ", ", "'2'", ", ", "'3'", ", ", "'4'", ", ", "'5'", "};\n\n", "void", " ", "getChar", "(", "const", " ", "char", " *args)", "\n", "{\n    ", "while", " (", "true", ")\n    {\n        ", "ESP_LOGI", "(", "\"MSG\"", ", ", "\"%s\"", ", args);\n        ", "vTaskDelay", "(", "200", " / portTICK_RATE_MS);\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "P2 存储的是P1 的地址。所以P2是二级指针，你要定义如下表示\r\nint ** P2= 0;", "Konwledge_Point": "间接访问——指针", "Question": ["指针的指针，报错：非法的间接寻址", ["如题，在最后两行产生错误：非法的间接寻址", "\n\n", "#include<stdio.h>\nmain() {\n    int a[10];\n    int* p1, * p2;\n    int i;\n\n    for (i = 0;i < 10;i++) {\n        scanf_s(\"%d\", &a[i]);\n    }\n    p1 = a;\n    p2 = &p1;\n    for (i = 0;i < 10;i++) {\n        if (*(*p2 + i) % 2 == 0) {\n            printf(\"%5d\", *(*p2 + i));\n\n        }\n\n    }\n"]], "Tag": "程序设计"}
{"Answer": "call对方服务，你检查下调用对方的wsdl地址、namespace、参数是否正确。最好上源码看看。", "Konwledge_Point": "间接访问——指针", "Question": ["webservice客户端调用报错空指针", []], "Tag": "程序设计"}
{"Answer": "Ndkddnkdjnss", "Konwledge_Point": "间接访问——指针", "Question": ["数组的指针怎么访问其中的元素", ["求大神帮忙我的这个程序到底哪不对  输不出来元素"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;指针变量是什麽类型啊&amp;#xff1f;你如何修改的&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["单链表操作中，定义了一个指针变量p，修改指针变量p的值，能不能同时修改了指针域的值？", ["单链表操作中，定义了一个指针变量p，修改指针变量p的值，能不能同时修改了指针域的值？"]], "Tag": "程序设计"}
{"Answer": "```\r\n可以这么定义\r\n\r\nstatic int a;的意思是，a这个变量是静态的（下次调用这个函数，a还是之前的值）\r\nstatic int *p;的意思是，p这个指针是静态的（下次调用这个函数，p还是指向同一个地址，至于地址本身是否有效，里面的内容是不是变化，就不一定了）\r\n```", "Konwledge_Point": "间接访问——指针", "Question": ["有哪位大佬能告诉我在C语言中 指针变量  可以被static修饰吗？", ["就是在C语言中可不可以有\"static int* p ;\"这种方式定义指针变量。", "\n如果可以效果是不是跟正常的静态变量\"static int a;\"一样？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.p-&amp;gt;next是p的指针域&amp;#xff0c;p的指针域存储的是下一个节点的地址&lt;br /&gt;2.p-&amp;gt;data指的是p的数据域,里面存储数据&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["链表中p-next指下一个结点还是p的指针域 ，p->data指的是数据吗", ["链表中p-next指下一个结点还是p的指针域 ，p->data指的是数据吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void fun1(char *p)&lt;br /&gt;{&lt;!-- --&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    printf(&amp;#34;%s&amp;#34;,p);&lt;/span&gt;&lt;br /&gt;}&lt;br /&gt;声明一个指向fun2()函数的函数指针----不应该是指向fun1()函数的函数指针么&amp;#xff1f;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(*func1)&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&lt;/span&gt;&lt;/span&gt;;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(*func2)&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(func1,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;fun1&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;,p);\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;fun2&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(func1 f,&lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p)&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-built_in\"&gt;f&lt;/span&gt;(p);\n}\n \n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    func1 f1 &amp;#61; fun1;\n    func2 f2 &amp;#61; fun2;\n    &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;f2&lt;/span&gt;(f1,p);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["关于#c语言#的问题：声明一个以字符指针为变量的函数fun1()，该函数输出字符指针指向的字符串", ["声明一个以字符指针为变量的函数fun1()，该函数输出字符指针指向的字符串。声明一个以函数指针为变量的函数fun2()，该函数调用函数指针指向的函数。声明一个指向fun2()函数的函数指针，在main()函数中通过该函数指针调用fun2()函数，并通过fun2()函数调用fun1()函数。字符串长度与内容自定。"]], "Tag": "程序设计"}
{"Answer": "内层for循环结束重置p2指针的值就好了，而且你这里面的问题很多，链表最后一个结点的next没置空，没释放内存等等", "Konwledge_Point": "间接访问——指针", "Question": ["两个指针指向同一个节点，明明对两个指针操作一样却一个正常，一个无法读取内存，急求大佬解惑", ["求大佬帮忙解惑，万分感谢", "\n出错函数代码如下", "\n\n", "struct StuLink*Rank_Link(struct StuLink*list)\n{\n    struct StuLink *p1,*p2;\n    p1=list;p2=list;\n    for(;p1!=NULL ;p1=p1->next)\n        for(;p2!=NULL;p2=p2->next)\n        {\n            if(p1->xh ==p2->xh )\n                continue;\n            if(p1->cj<p2->cj)\n                p1->mc++;\n        }\n        return list;\n}\n\n", "\n\n", "\n", "      p1  0x00be9f38 {xh=1 xm=0x00be9f3c \"aaa\" cj=88 ...} StuLink *", "\n", "      p2  0xcdcdcdcd {xh=??? xm=0xcdcdcdd1 <读取字符串的字符时出错。> cj=??? ...} StuLink *", "\n", "/*设计Rank_Link函数（10分）：计算学生链表中每个学生的名次", "\n名次规则：按成绩降序排名，从第1名开始依次排名，若出现并列名次，则名次需要叠加", "\n例如，若出现5个并列第1名，则没有第2名，下一个名次是第6名，依此类推。*/", "\n完整简化程序如下", "\n\n", "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n/*定义单向链表类型StuLink，链表结点包含xh、xm、cj、dj、mc、nxet六个数据项\n分别代表学生的学号、姓名、成绩、等级、名次和指向下一个结点的指针，\n其中：学号、姓名、成绩是输入项，等级、名次是计算项*/\nstruct StuLink*Creat_Link();                    //创建链表\nstruct StuLink*Rank_Link(struct StuLink*list);  //计算名次\nvoid display(struct StuLink *p);                //输出一个结点的内容\nstruct StuLink*Sort_Link(struct StuLink *list,int n);//链表排序\nstruct StuLink*Output_Link(struct StuLink*list);//链表按顺序输出\nvoid menu1();//一级菜单\nvoid menu2();\n//创建链表\n\n struct StuLink\n{\n    int xh;\n    char xm[20];\n    int cj;\n    char dj;\n    int mc;\n    struct StuLink*next;\n};\nint main()\n{\n    struct StuLink *list;\n    list=Creat_Link();\n    Rank_Link(list);\n    Output_Link(list);\n    return 0;\n}\nstruct StuLink*Creat_Link()\n{\n    struct StuLink*list=0,*p1=0,*p2;int i=0;\n    int score;char name[20];\n    //list->xh =0;p2=list;\n    printf(\"\\n输入成绩为-1，结束输入！\\n\");\n    printf(\"请输入学生姓名\");\n    scanf(\"%s\",name);\n    printf(\"请输入学生成绩\");\n    scanf(\"%d\",&score );\n    while(score!=-1)\n    {\n        if(score<0||score>100)\n            {\n                    printf(\"输入成绩格式错误，请重新输入正确的学生成绩\\n\");\n                    scanf(\"%d\",&score );\n                    continue ;\n\n            }\n        if( (p1=(struct StuLink*)malloc(sizeof(struct StuLink)))    ==0)\n                    {\n                        printf(\"动态内存空间分配失败\\n\");\n                        exit(0);\n                    }\n        else\n        {\n            switch(score/10)\n            {\n                case 9:p1->dj='A';break;    //计算等级\n                case 8:p1->dj='B';break;\n                case 7:p1->dj='C';break;\n                case 6:p1->dj='D';break;\n                default:p1->dj='E';\n            }\n            i++;\n            p1->xh =i;\n            p1->cj =score;\n            p1->mc=1;\n            strcpy(p1->xm,name);\n\n            if(list==0)\n                list=p1;\n            else\n                p2->next=p1;\n            p2=p1;\n            printf(\"请输入学生姓名   \");\n            scanf(\"%s\",name);\n            printf(\"请输入学生成绩   \");\n            scanf(\"%d\",&score);\n            }\n    }\n    return list;\n}\nvoid display(struct StuLink*p)\n{\n    printf(\"学号  %d\",p->xh);\n    printf(\"姓名  %s\",p->xm);\n    printf(\"成绩  %d\",p->cj);\n    printf(\"等级  %c\",p->dj);\n    /*if(p->mc>1)*/\n    printf(\"名次  %d\\n\",p->mc);\n    /*else\n        printf(\"kong\\n\");*/\n    /*if(p->mc)\n    printf(\"名次  %d\\n\",p->mc);\n    else\n        printf(\"kong\");*/\n\n}\nstruct StuLink*Rank_Link(struct StuLink*list)\n{\n    struct StuLink *p1,*p2;\n    p1=list;p2=list;\n    for(;p1!=NULL ;p1=p1->next)\n        for(;p2!=NULL;p2=p2->next)\n        {\n            if(p1->xh ==p2->xh )\n                continue;\n            if(p1->cj<p2->cj)\n                p1->mc++;\n        }\n        return list;\n}\nstruct StuLink*Output_Link(struct StuLink*list)\n{\n    struct StuLink *p3=list;\n    for(;p3!=NULL ;p3=p3->next)\n        display(p3);\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "这个变量 char ss[10][5] 的定义，至少需要修改为： char ss[10][6]。就是比实现的最大字符串的长度 + 1.\r\n否则，按字符串操作时，因为没有字符串结束符导致操作越界。", "Konwledge_Point": "间接访问——指针", "Question": ["用指针对字符串排序的问题,内存访问非法(续)", ["还是上次类似的问题，求解答。", "\n对字符串进行排序的问题，被指针搞糊涂了。", "\n\n", " #include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint main()\n{\n    void sort(char p[][5]);\n    char ss[10][5]={\"worin\",\"trafi\",\"panda\",\"dalai\",\"lama2\",\"strin\",\"tende\",\"racof\",\"lenth\",\"recte\"};\n    sort(ss);\n    printf(\"test\");\n}\n\nvoid sort(char p[][5])\n{\n    int i,j,k;\n    int n=10;\n    char temp[20];\n    for(i=0;i<n-1;i++)\n    {\n        k=i;\n        for(j=i+1;j<n;j++)\n            if(strcmp(p[k],p[j])>0)\n                k=j;\n        if(k!=i)\n        {\n            strcpy(temp,p[k]);   //本意是想复制第k个字符串，但此处将多个字符串进行复制\n            strcpy(p[k],p[i]);           //程序运行到此出错，又是内存访问非法，头痛\n            strcpy(p[i],temp);\n        }\n\n    }\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;for&amp;#xff08;j&amp;#61;0;j&amp;lt;n,j&amp;#43;&amp;#43;&amp;#xff09;&lt;br /&gt;循环结束条件是j&amp;#61;&amp;#61;n;当这个循环正常结束时j的值是n&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["C++指针求并集问题", ["C++求并集问题里面的unionElem函数里if(j>=n) arr2[len++]=arr1[i];是什么意思啊？j不是小于n的吗？在什么情况下会大于n呢？", "\n", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;pre&gt;&lt;code&gt;func Set(strukt interface{}, fieldName string, newFieldValue interface{}) {\n    struktValueElem := reflect.ValueOf(strukt).Elem()\n    field := struktValueElem.FieldByName(fieldName)\n    newFieldValueValue := reflect.ValueOf(newFieldValue)\n    if field.Kind() == reflect.Ptr {\n        rt := field.Type() // type *A\n        rt = rt.Elem()     // type A\n\n        rv := reflect.New(rt) // value *A\n        el := rv.Elem()       // value A (addressable)\n\n        el.Set(newFieldValueValue) // el is addressable and has the same type as newFieldValueValue (A), Set can be used\n        field.Set(rv)              // field is addressable and has the same type as rv (*A), Set can be used\n    } else { // not a pointer? more straightforward:\n        field.Set(newFieldValueValue)\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/jgEK_rKbgO9\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/jgEK_rKbgO9&lt;/a&gt;&lt;/p&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/B6vOONQ-RXO\" rel=\"nofollow noreferrer\"&gt;https://play.golang.org/p/B6vOONQ-RXO&lt;/a&gt; (compact)&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["如何通过反射将非指针值复制到指针间接值", ["\n\n", "I want the ", "Set", " method below to set the ", "APtr", " field of a passed in ", "B", " struct to a value that gets passed in by value, i.e. without a pointer indirection.", "\n\n", "For that to work via go reflection, I will probably have to copy that value to a new location that I have the address of? Either way, how can I get this to work? What I have is a working version for non-pointers values.", "\n\n", "type A struct {\n    AnInt int\n}\n\ntype B struct {\n    AnA   A\n    APtr *A\n}\n\nfunc Set(strukt interface{}, fieldName string, newFieldValue interface{}) {\n    struktValueElem := reflect.ValueOf(strukt).Elem()\n    field := struktValueElem.FieldByName(fieldName)\n    newFieldValueValue := reflect.ValueOf(newFieldValue)\n    if field.Kind() == reflect.Ptr {\n        // ?? implement me\n    } else { // not a pointer? more straightforward:\n        field.Set(newFieldValueValue)\n    }\n}\n\nfunc main() {\n    aB := B{}\n    anA := A{4}\n    Set(&aB, \"AnA\", anA) // works\n    Set(&aB, \"APtr\", anA) // implement me\n}\n", "\n\n", "Playground: ", "https://play.golang.org/p/6tcmbXxBcIm", "\n    "]], "Tag": "程序设计"}
{"Answer": "animationDelay\r\n初始动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果。\r\n\r\n```\r\nanimationDelay: function (idx) {\r\n            return idx * 10 + 1000;\r\n        }\r\n```", "Konwledge_Point": "间接访问——指针", "Question": ["echarts的仪表盘指针动画时间 怎么设置成2秒？", ["echarts的仪表盘 指针动画时间 每次指针怎么设置成2秒 ，官方默认太快了", "\n\n", "option = { ", "\n        tooltip: { ", "\n            formatter: '{a} {b} : {c}%' ", "\n        },", "\n        toolbox: {", "\n            feature: {", "\n                restore: {}, ", "\n                saveAsImage: {}", "\n            } ", "\n        }, ", "\n        series: [", "\n        { ", "\n        name: '业务指标',", "\n        type: 'gauge',", "\n        animationDelay: function (idx) {", "\n            return idx 2000 + 5000; ", "\n        }, //这里 一个哥推荐的 可能我不会 这里完全没效果", "\n        animationEasing: '业务指标', ", "\n        animationDuration: 2000,//这里首次可以指针移动2秒 第二次开始就没效果了", "\n        detail: {", "\n            formatter: '{value}%'", "\n        }, ", "\n        data: [{value: 50, name: '完成率'}] } ],", "\n        //希望每次指针都是移动2秒，官方移动时间太快了", "\n};", "\n\n", "setInterval(function () { option.series[0].data[0].value = (Math.random() * 100).toFixed(2) - 0; myChart.setOption(option, true); },2000);"]], "Tag": "程序设计"}
{"Answer": "数组指针可以向楼主那样访问其中的元素，只是代码中有错误，向楼上说的那样，声明的一维数组a[5]是局部变量，把指针传递到作用域之外，再去取指针的值可能是随机值。改成如下：\r\n```\r\n int a[5];\r\narry* chen()\r\n{\r\n    int j = 0, i;\r\n    i = 5;\r\n    while (1)\r\n    {\r\n        if (j == 5)\r\n        {\r\n            break;\r\n        }\r\n        a[j] = i;\r\n        ++j;\r\n    }\r\n    return &amp;a;\r\n}\r\n```\r\n应该可以打出正常的值。\r\n此外\r\nInt （*b）[5]；定义的是执行5个指针的数组，可以指向一维数组，这时就相当于只用了b的一个元素，访问时用(*b)指向一维数组的首歌元素的地址，所以也可以用如下方式访问,都是访问数组a的元素值：\r\n(*b)[i]\r\n*((*b)+i)\r\n*((b[0]) + i)\r\nb[0][i]", "Konwledge_Point": "间接访问——指针", "Question": ["数组的指针怎么访问数组中的元素求大神帮忙 ", ["所有需要的文件均已包含", "\nusing arry=int[5]；", "\narry* chen（）", "\n〔", "\nInt j=0,i,a[5]；", "\nWhile（cin>>i）", "\n{if（j==5）", "\nBreak；", "\na[j]=i；", "\n++j；", "\n\n", "}", "\nreturn &a；", "\n〕", "\nInt main（）", "\n{Int （*b）[5]；", "\nb=chen（）；", "\nfor（int i=0；i<5；i++）", "\n       cout<<（*b）[i]<<endl；", "\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数组指针的主体是指针&amp;#xff0c;是指向数组的指针&lt;br /&gt;指针数组的主体是数组&amp;#xff0c;数组中的元素都是指针&lt;/p&gt;", "Konwledge_Point": "间接访问——指针", "Question": ["指针数组和数组指针的区别", ["怎么理解指针数组和数组指针的区别"]], "Tag": "程序设计"}
