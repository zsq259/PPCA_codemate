{"Answer": "&lt;p&gt;因为你原始df是个空值&amp;#xff0c; pandas在处理缺失值上&amp;#xff0c;拥有一个自己的处理及转化逻辑 会将int转float的&amp;#xff0c;可以去看文档&lt;/p&gt;", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["pandas  使用loc赋值后，值的类型从int变成了float，这是为什么？", ["\ndef NowTime(df: pd.DataFrame, ", "p", "=", "''", "):\n    now13 = ", "int", "(time.time() * ", "1000", ")\n    now = ", "int", "(now13 / ", "1000", ")\n    now_F = time.", "strftime", "(", "'%Y-%m-%d %H:%M:%S'", ", time.", "localtime", "(now13 / ", "1000", "))\n    now_F_T = time.", "strftime", "(", "'%Y-%m-%dT%H:%M:%S'", ", time.", "localtime", "(now13 / ", "1000", "))\n    now_F_TZ = time.", "strftime", "(", "'%Y-%m-%dT%H:%M:%SZ'", ", time.", "localtime", "(now13 / ", "1000", "))\n    resultDF = pd.DataFrame()\n    ", "print", "(", "type", "(now13))\n    resultDF.", "loc", "[", "0", ", ", "'Now'", "] = now\n    resultDF.", "loc", "[", "0", ", ", "'Now13'", "] = now13\n    resultDF.", "loc", "[", "0", ", ", "'Now_F'", "] = now_F\n    resultDF.", "loc", "[", "0", ", ", "'now_F_T'", "] = now_F_T\n    resultDF.", "loc", "[", "0", ", ", "'now_F_TZ'", "] = now_F_TZ\n\n    ", "return", " resultDF\n\n", "if", " __name__ == ", "'__main__'", ":\n    df=pd.DataFrame()\n    xx=NowTime(df)\n    ", "print", "(xx.dtypes)\n", "\n", "运行结果", "\n", "<", "class", " '", "int", "'>\n", "Now", "         ", "float64", "\n", "Now13", "       ", "float64", "\n", "Now_F", "        ", "object", "\n", "now_F_T", "      ", "object", "\n", "now_F_TZ", "     ", "object", "\n", "dtype: ", "object", "\n\n"]], "Tag": "程序设计"}
{"Answer": "我补充下，首先，此处你的理解很好，但是表面了。str = \"test\"，此时的\"test\"的确是一个const char*，\r\n**华丽的分割线***\r\n但同时也是一个String对象，因为你的String是有const char*的构造函数的，\r\n**华丽的分割线***\r\n你可以试试再给他加一个构造函数用std::string来进行构造，你会发现，std::string同样可以赋值，调用的还是赋值运算符。\r\n望你采纳。", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["c++赋值操作符重载问题", ["练习定义了一下String类", "\n\n", "String.h如下", "\n\n", "其中赋值操作符重载函数的声明为：", "String& operator = (const String& str);", "\n\n", "函数参数为String对象的常量引用。", "\n\n", "main.cpp如下：", "\n\n", "在第二行，我尝试给已经构造过的String对象赋值一个", "const char *", "类型的字符串。", "\n\n", "在我的构想中，我没有重载过函数为", "const char *", "类型的赋值操作符，那么应该是要报错的。", "\n\n", "但是没有，正常输出，并且赋值是成功了的", "\n\n", "通过调试，我发现执行到赋值语句时，仍然跳到了我重载过的赋值操作符函数中去。请问这是什么道理？？？难不成自动将", "const char *", "类型给我转换String类型了嘛？？", "\n\n", "想不通，请各位指教", "\n\n", "经过很长时间后，在侯捷老师的面向对象课程中，我终于深刻理解了这个问题", "\n\n", "要理解这个问题，还要去理解一下explicit关键字的作用", "\n\n", "出现问题的原因就在于：non-explicit-one-argument ctor(没有explicit的单实参构造函数)   会在实参需要转为对应对象时自动转换。", "\n\n", "取消这个特性的方法就是在构造函数前加上explicit关键字"]], "Tag": "程序设计"}
{"Answer": "合法滴，在表示数字的字符是可以不用加引号", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["java中语句char mychar=10是合法的吗？", ["java中语句char mychar=10是合法的吗？按照我的理解，10在java中默认为int型，把一个int型赋值给char不会发生自动类型转换，所以是不合法的。可是书上却出现了这条语句，难道我的理解是错误的吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;相关的imaplib的环境&amp;#xff0c;使用的IMAP的模式来进行管理。POP3 是表示仅下载邮件&amp;#xff0c;并不具备管理文件夹的权限。&lt;br /&gt;然后你可以使用IMAP4 就是正常的模式 &amp;#xff0c;不带有SSL方式进行操作。就是m&amp;#61;imaplib.IMAP4(‘imap服务器地址’)也可以使用SSL的模式 ,m&amp;#61;imaplib.IMAP4_SSL(‘IMAP服务器地址’)&lt;br /&gt;即使已经连接到了服务器,那么你就可以进行登陆验证了。可以使用m&amp;#61;imaplib.login(‘用户名’,’密码’)进行登陆。提示login completed表示登陆成功&amp;#xff01;&lt;br /&gt;.如果有imaplib.error表示登陆失败了&amp;#xff01;&lt;br /&gt;登陆成功则可以进行相关的文件夹管理了。m.list() 则可以直接查看到现在有 那些文件夹了。&lt;br /&gt;下面可以直接使用for 语句直接循环出来。&lt;br /&gt;可以使用m.create(‘文件夹名称’)进行创建&lt;br /&gt;.m.delete(‘文件夹名称’)进行删除&lt;br /&gt;可以做一个进行文件夹权限管理。&lt;/p&gt;", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["python 自动下载阿里邮箱中已转入其他文件中的邮件的附件", ["背景：需自动下载阿里邮箱中附件，自己测试已经完成能够下载，但是邮箱中部分邮件设置在其他文件夹，无法下载。", "\n", "问题相关代码", "\n", "# -*- coding: utf-8 -*-", "\n", "import", " poplib,email,telnetlib\n", "import", " datetime,time,sys,traceback\n", "from", " email.parser ", "import", " Parser\n", "from", " email.header ", "import", " decode_header\n", "from", " email.utils ", "import", " parseaddr\n", "import", " pandas ", "as", " pd\n", "import", " numpy ", "as", " np\n", "import", " re\n", "class", " ", "down_email", "():\n\n    ", "def", " ", "__init__", "(", "self,user,password,eamil_server,fund_name,file_type", "):\n        ", "# 输入邮件地址, 口令和POP3服务器地址:", "\n        self.user = user\n        ", "# 此处密码是授权码,用于登录第三方邮件客户端", "\n        self.password = password\n        self.pop3_server = eamil_server\n        self.fund_name=fund_name\n        self.file_type=file_type\n    ", "# 获得msg的编码", "\n    ", "def", " ", "guess_charset", "(", "self,msg", "):\n        charset = msg.get_charset()\n        ", "if", " charset ", "is", " ", "None", ":\n            content_type = msg.get(", "'Content-Type'", ", ", "''", ").lower()\n            pos = content_type.find(", "'charset='", ")\n            ", "if", " pos >= ", "0", ":\n                charset = content_type[pos + ", "8", ":].strip()\n        ", "return", " charset\n\n    ", "#获取邮件内容", "\n    ", "def", " ", "get_content", "(", "self,msg", "):\n        content=", "''", "\n        content_type = msg.get_content_type()\n        ", "# print('content_type:',content_type)", "\n        ", "if", " content_type == ", "'text/plain'", ": ", "# or content_type == 'text/html'", "\n            content = msg.get_payload(decode=", "True", ")\n            charset = self.guess_charset(msg)\n            ", "if", " charset:\n                content = content.decode(charset)\n        ", "return", " content\n\n    ", "# 字符编码转换", "\n    ", "# @staticmethod", "\n    ", "def", " ", "decode_str", "(", "self,str_in", "):\n        value, charset = decode_header(str_in)[", "0", "]\n        ", "if", " charset==", "'gb2312'", ":\n            charset=", "'gbk'", "\n            value = value.decode(charset)\n        ", "else", ":\n            value = value.decode(charset)\n        ", "return", " value\n\n    ", "# 解析邮件,获取附件", "\n    ", "def", " ", "get_att", "(", "self,msg_in, str_day", "):\n        attachment_files = []\n        ", "for", " part ", "in", " msg_in.walk():\n            ", "# 获取附件名称类型", "\n            file_name = part.get_param(", "\"name\"", ")  ", "# 如果是附件，这里就会取出附件的文件名", "\n            ", "# file_name = part.get_filename() #获取file_name的第2中方法", "\n            ", "# contType = part.get_content_type()", "\n            ", "if", " file_name:\n                h = email.header.Header(file_name)\n                ", "# 对附件名称进行解码", "\n                dh = email.header.decode_header(h)\n                filename = dh[", "0", "][", "0", "]\n                ", "if", " dh[", "0", "][", "1", "]:\n                    ", "# 将附件名称可读化", "\n                    filename = self.decode_str(", "str", "(filename, dh[", "0", "][", "1", "]))\n                    ", "# print(filename)", "\n                    ", "# filename = filename.encode(\"utf-8\")", "\n                ", "# 下载附件", "\n                data = part.get_payload(decode=", "True", ")\n                ", "# 在指定目录下创建文件，注意二进制文件需要用wb模式打开", "\n                att_file = ", "open", "(", "'./test/'", " + filename, ", "'wb'", ")\n                att_file.write(data)  ", "# 保存附件", "\n                att_file.close()\n                attachment_files.append(filename)\n            ", "else", ":\n                ", "pass", "\n                ", "# 不是附件，是文本内容", "\n                ", "# print(self.get_content(part)) #输出邮件类容", "\n                ", "# # 如果ture的话内容是没用的", "\n                ", "# if not part.is_multipart():", "\n                ", "#     # 解码出文本内容，直接输出来就可以了。", "\n                ", "#     print(part.get_payload(decode=True).decode('utf-8'))", "\n\n        ", "return", " attachment_files\n\n    ", "# 获取已经下载的数据", "\n    ", "def", " ", "get_data", "(", "self,attach_file_all", "):\n        values_list = []\n        ", "for", " item ", "in", " attach_file_all:\n            list_temp = []\n            ", "try", ":\n                data = pd.read_excel(", "'./test/'", " +item, engine=", "'openpyxl'", ", header=", "0", ", dtype=", "str", ")\n            ", "except", " Exception:\n                data = pd.read_excel(", "'./test/'", " +item, header=", "0", ", dtype=", "str", ")\n            ", "# 找到单位净值", "\n            ", "for", " item1 ", "in", " data.columns:\n                df_temp = data[data[item1].", "str", ".contains(", "'^单位净值'", ", na=", "False", ")]\n                ", "if", " ", "len", "(df_temp) >= ", "1", ":\n                    ", "for", " item2 ", "in", " df_temp.values[", "0", "]:\n                        ", "if", " re.match(", "'^单位净值'", ", ", "str", "(item2)):\n                            dwjz = item2.split(", "'：'", ")[", "1", "]\n                            ", "break", "\n                    ", "break", "\n            ", "# 找到累计单位净值", "\n            ", "for", " item1 ", "in", " data.columns:\n                df_temp = data[data[item1].", "str", ".contains(", "'累计单位净值'", ", na=", "False", ")]\n                ", "if", " ", "len", "(df_temp) >= ", "1", ":\n                    ", "for", " i1 ", "in", " ", "range", "(", "0", ", ", "len", "(df_temp.values[", "0", "])):\n                        ", "if", " re.search(", "'累计单位净值'", ", ", "str", "(df_temp.values[", "0", "][i1])):\n                            ljdwjz = df_temp.values[", "0", "][i1 + ", "1", "]\n                            ", "break", "\n                    ", "break", "\n            list_temp.append(dwjz)\n            list_temp.append(ljdwjz)\n            values_list.append(list_temp)\n        df0 = pd.DataFrame(values_list, columns=[", "\"单位净值\"", ", ", "\"累计单位净值\"", "])\n        ", "return", " df0\n    ", "# def get_data(self,attach_file_all):", "\n    ", "#     for item in attach_file_all:", "\n    ", "#         try:", "\n    ", "#             data=pd.read_excel('./test/' + item,engine='openpyxl')", "\n    ", "#", "\n    ", "#         except:", "\n    ", "#             print('该文件不是xlx或xlsx格式')", "\n    ", "def", " ", "run_ing", "(", "self", "): ", "#主程序", "\n        attach_file_all=[]\n        str_day = ", "str", "(datetime.date.today())", "# 日期赋值", "\n        ", "# 连接到POP3服务器,有些邮箱服务器需要ssl加密，可以使用poplib.POP3_SSL", "\n        ", "try", ":\n            telnetlib.Telnet(self.pop3_server, ", "995", ")\n            self.server = poplib.POP3_SSL(self.pop3_server, ", "995", ", timeout=", "10", ")\n        ", "except", ":\n            time.sleep(", "5", ")\n            self.server = poplib.POP3(self.pop3_server, ", "110", ", timeout=", "10", ")\n\n        ", "# server.set_debuglevel(1) # 可以打开或关闭调试信息", "\n        ", "# 打印POP3服务器的欢迎文字:", "\n        ", "print", "(self.server.getwelcome().decode(", "'utf-8'", "))\n        ", "# 身份认证:", "\n\n        self.server.user(self.user)\n        self.server.pass_(self.password)\n        ", "# 返回邮件数量和占用空间:", "\n        ", "print", "(", "'Messages: %s. Size: %s'", " % self.server.stat())\n        ", "# list()返回所有邮件的编号:", "\n        resp, mails, octets = self.server.", "list", "()\n        ", "# 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]", "\n        ", "# print(mails)", "\n        index = ", "len", "(mails)\n        ", "for", " i ", "in", " ", "range", "(index, ", "0", ", -", "1", "):", "# 倒序遍历邮件", "\n        ", "# for i in range(1, index + 1):# 顺序遍历邮件", "\n            resp, lines, octets = self.server.retr(i)\n            ", "# lines存储了邮件的原始文本的每一行,", "\n            ", "# 邮件的原始文本:", "\n            msg_content = ", "b'\\r\\n'", ".join(lines).decode(", "'utf-8'", ")\n            ", "# 解析邮件:", "\n            msg = Parser().parsestr(msg_content)\n            ", "#获取邮件的发件人，收件人， 抄送人,主题", "\n            ", "# hdr, addr = parseaddr(msg.get('From'))", "\n            ", "# From = self.decode_str(hdr)", "\n            ", "# hdr, addr = parseaddr(msg.get('To'))", "\n            ", "# To = self.decode_str(hdr)", "\n            ", "# 方法2：from or Form均可", "\n            From = parseaddr(msg.get(", "'from'", "))[", "1", "]\n            To = parseaddr(msg.get(", "'To'", "))[", "1", "]\n            Cc=parseaddr(msg.get_all(", "'Cc'", "))[", "1", "]", "# 抄送人", "\n            Subject = self.decode_str(msg.get(", "'Subject'", "))\n            ", "print", "(", "'from:%s,to:%s,Cc:%s,subject:%s'", "%(From,To,Cc,Subject))\n            ", "# 获取邮件时间,格式化收件时间", "\n            ", "print", "(", "'运行次数'", ",i)\n            ", "# print(msg.get(\"Date\"))", "\n            ", "# try:", "\n            ", "#     date1 = time.strptime(msg.get(\"Date\")[0:24], '%a, %d %b %Y %H:%M:%S')", "\n            ", "# except:", "\n            ", "#     date1 = time.strptime(msg.get(\"Date\")[0:11], '%d %b %Y')", "\n            ", "# print(date1)", "\n            ", "# # 邮件时间格式转换", "\n            ", "# date2 = time.strftime(\"%Y-%m-%d\",date1)", "\n            regex_list = [", "\"(\\d{4}-\\d{1,2}-\\d{1,2})\"", ", ", "\"(\\d{4}\\d{1,2}\\d{1,2})\"", "]\n            ", "for", " regex ", "in", " regex_list:\n                date1 = re.search(regex, Subject)\n                ", "if", " date1:\n                    date1 = date1.group(", "1", ")\n                    ", "try", ":\n                        date1= time.strptime(date1, ", "\"%Y%m%d\"", ")\n                        date1 = time.strftime(", "\"%Y-%m-%d\"", ", date1)\n                    ", "except", " Exception:\n                        date1 = time.strptime(date1, ", "\"%Y-%m-%d\"", ")\n                        date1 = time.strftime(", "\"%Y-%m-%d\"", ", date1)\n                    ", "break", "\n            ", "print", "(", "'date1:'", ",", "str", "(date1))\n            ", "if", " date1==", "None", ":\n                ", "continue", "\n            ", "print", "(", "str", "(date1))\n            str_day=", "'2022-02-15'", "\n            ", "if", " date1 < str_day:\n                ", "break", " ", "# 倒叙用break", "\n                ", "# continue # 顺叙用continue", "\n            ", "else", ":\n                ", "# 获取附件,条件为 满足 关键词、满足日期、满足类型", "\n                ", "if", " re.search(self.fund_name,Subject) ", "and", " re.search(self.file_type,Subject) ", "and", " date1>str_day:\n                    attach_file=self.get_att(msg,str_day)\n                    attach_file_all=attach_file_all+attach_file\n                    ", "print", "(attach_file)\n\n        ", "# 可以根据邮件索引号直接从服务器删除邮件:", "\n        ", "# self.server.dele(7)", "\n        ", "print", "(", "'运行到这'", ")\n        ", "try", ":\n            self.server.quit()\n        ", "except", ":\n            ", "print", "(", "'未知原因，quit()报错,我找了找不出来'", ")\n        ", "print", "(", "'所有邮件名称'", ",attach_file_all)\n        ", "return", " attach_file_all ", "#返回所有附件名称", "\n\n\n", "if", " __name__ == ", "'__main__'", ":\n    ", "#把打印内容输出到文件", "\n    ", "# origin = sys.stdout", "\n    ", "# f = open('./test/log.txt', 'w')", "\n    ", "# sys.stdout = f", "\n    ", "try", ":\n        ", "# 输入邮件地址, 口令和POP3服务器地址:", "\n        user = ", "''", "\n        ", "# 此处密码是授权码,用于登录第三方邮件客户端", "\n        password = ", "''", "\n        eamil_server = ", "'pop.qiye.aliyun.com'", "\n        fund_name=", "'南方基金'", "\n        file_type=", "'估值表'", "\n        ", "# user='xinfei@.com'", "\n        ", "# password = 'f67h2'", "\n        ", "# eamil_server = 'pop.qiye.aliyun.com'", "\n        email_class=down_email(user=user,password=password,eamil_server=eamil_server,fund_name=fund_name,file_type=file_type)\n        attach_file_all=email_class.run_ing()\n        email_class.get_data(attach_file_all)\n    ", "except", " Exception ", "as", " e:\n        ", "# import tracebackA", "\n        ex_msg = ", "'{exception}'", ".", "format", "(exception=traceback.format_exc())\n        ", "print", "(ex_msg)\n        ", "# traceback.print_exc()", "\n    ", "# sys.stdout = origin", "\n    ", "# f.close()", "\n\n\n", "\n", "运行结果及报错内容", "\n", "运行没有报错，就是无法下载到已经转移到其他文件夹中的邮件", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果", "\n", "能够下载转到其他文件夹中的邮件的附件"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;IndentBraces设置为false就可以了&lt;/p&gt;\n&lt;p&gt;原文&amp;#xff1a;&lt;br /&gt;bool IndentBraces Indent the wrapped braces themselves.&lt;/p&gt;", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["vscode / clang-format控制语句自动被缩进", ["强迫症伤不起，有没有大lao指点一下 ，设置了保存自动格式化，图中的控制语句被莫名缩进了（红框部分所示）", "\n", "\n", "想修改成自动保存时不缩进控制语句块，如下图：", "\n", "\n", "找了很多资料还是没找到到底哪个配置项控制了这个缩进", "\n", ".clang-format配置如下", "\n", "---", "\n", "# 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto", "\n", "Language:", "        ", "Cpp", "\n", "#BasedOnStyle:  LLVM", "\n", "# 访问说明符(public、private等)的偏移", "\n", "AccessModifierOffset:", " ", "-2", "\n", "# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)", "\n", "AlignAfterOpenBracket:", " ", "Align", "\n", "# 对齐数组列", "\n", "AlignArrayOfStructures:", " ", "None", "\n", "# 对齐连续宏定义", "\n", "AlignConsecutiveMacros:", " ", "None", "\n", "# 连续赋值时，对齐所有等号", "\n", "AlignConsecutiveAssignments:", " ", "None", "\n", "# 对齐连续位字段", "\n", "AlignConsecutiveBitFields:", " ", "None", "\n", "# 连续声明时，对齐所有声明的变量名", "\n", "AlignConsecutiveDeclarations:", " ", "None", "\n", "# 左对齐逃脱换行(使用反斜杠换行)的反斜杠", "\n", "AlignEscapedNewlines:", " ", "Left", "\n", "# 水平对齐二元和三元表达式的操作数", "\n", "AlignOperands:", "   ", "Align", "\n", "# 对齐连续的尾随的注释", "\n", "AlignTrailingComments:", " ", "true", "\n", "# 允许函数声明的所有参数在放在下一行", "\n", "AllowAllParametersOfDeclarationOnNextLine:", " ", "true", "\n", "# 允许短的枚举放在同一行", "\n", "AllowShortEnumsOnASingleLine:", " ", "true", "\n", "# 允许短的块放在同一行", "\n", "AllowShortBlocksOnASingleLine:", " ", "Never", "\n", "# 允许短的case标签放在同一行", "\n", "AllowShortCaseLabelsOnASingleLine:", " ", "false", "\n", "# 允许短的函数放在同一行", "\n", "AllowShortFunctionsOnASingleLine:", " ", "All", "\n", "# 允许短的匿名函数放在同一行", "\n", "AllowShortLambdasOnASingleLine:", " ", "All", "\n", "# 允许短的if语句保持在同一行", "\n", "AllowShortIfStatementsOnASingleLine:", " ", "Never", "\n", "# 允许短的循环保持在同一行", "\n", "AllowShortLoopsOnASingleLine:", " ", "false", "\n", "# 总是在返回类型后换行", "\n", "AlwaysBreakAfterReturnType:", " ", "None", "\n", "# 总是在多行string字面量前换行", "\n", "AlwaysBreakBeforeMultilineStrings:", " ", "false", "\n", "# 总是在template声明后换行", "\n", "AlwaysBreakTemplateDeclarations:", " ", "MultiLine", "\n", "AttributeMacros:", "\n  ", "-", " ", "__capability", "\n", "# false表示函数实参要么都在同一行，要么都各自一行", "\n", "BinPackArguments:", " ", "true", "\n", "# false表示所有形参要么都在同一行，要么都各自一行", "\n", "BinPackParameters:", " ", "true", "\n", "# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效", "\n", "BraceWrapping:", "\n  ", "# class后的{是否换行", "\n  ", "AfterClass:", "      ", "false", " \n  ", "AfterCaseLabel:", "  ", "false", "\n  ", "# 控制语句 ( if/ for/ while/ switch/..)", "\n  ", "AfterControlStatement:", " ", "false", "\n  ", "AfterEnum:", "       ", "true", "\n  ", "# Function后的{是否换行", "\n  ", "AfterFunction:", "   ", "false", "\n  ", "# 命名空间", "\n  ", "AfterNamespace:", "  ", "false", "\n  ", "AfterObjCDeclaration:", " ", "true", "\n  ", "AfterStruct:", "     ", "false", "\n  ", "AfterUnion:", "      ", "false", "\n  ", "AfterExternBlock:", " ", "true", "\n  ", "BeforeCatch:", "     ", "true", "\n  ", "BeforeElse:", "      ", "true", "\n  ", "BeforeLambdaBody:", " ", "false", "\n  ", "BeforeWhile:", "     ", "true", "\n  ", "IndentBraces:", "    ", "true", "\n  ", "SplitEmptyFunction:", " ", "true", "\n  ", "SplitEmptyRecord:", " ", "true", "\n  ", "SplitEmptyNamespace:", " ", "true", "\n", "# 在二元运算符前换行", "\n", "BreakBeforeBinaryOperators:", " ", "None", "\n", "# 在concept前换行", "\n", "BreakBeforeConceptDeclarations:", " ", "true", "\n", "# 在大括号前换行: Attach(始终将大括号附加到周围的上下文)", "\n", "BreakBeforeBraces:", " ", "Custom", "\n", "# 继承列表样式", "\n", "BreakInheritanceList:", " ", "AfterComma", "\n", "# 在三元运算符前换行", "\n", "BreakBeforeTernaryOperators:", " ", "true", "\n", "# 构造函数初始值设定项换行样式", "\n", "BreakConstructorInitializers:", " ", "BeforeComma", "\n", "# 在java字段的注释后换行", "\n", "BreakAfterJavaFieldAnnotations:", " ", "false", "\n", "# 每行字符的限制，0表示没有限制", "\n", "ColumnLimit:", "     ", "0", "\n", "# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变", "\n", "CommentPragmas:", "  ", "'^ IWYU pragma:'", "\n", "# 在新行上声明每个命名空间", "\n", "CompactNamespaces:", " ", "false", "\n", "# 构造函数的初始化列表的缩进宽度", "\n", "ConstructorInitializerIndentWidth:", " ", "0", "\n", "# 延续的行的缩进宽度", "\n", "ContinuationIndentWidth:", " ", "4", "\n", "# 去除C++11的列表初始化的大括号{后和}前的空格", "\n", "Cpp11BracedListStyle:", " ", "false", "\n", "# 继承最常用的换行方式", "\n", "DeriveLineEnding:", " ", "true", "\n", "# 继承最常用的指针和引用的对齐方式", "\n", "DerivePointerAlignment:", " ", "false", "\n", "# 关闭格式化", "\n", "DisableFormat:", "   ", "false", "\n", "# 删除访问修饰符后的所有空行", "\n", "EmptyLineAfterAccessModifier:", " ", "Never", "\n", "# 仅当访问修饰符开始一个新的逻辑块时才添加空行", "\n", "EmptyLineBeforeAccessModifier:", " ", "LogicalBlock", "\n", "# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)", "\n", "ExperimentalAutoDetectBinPacking:", " ", "false", "\n", "# 自动补充namespace注释", "\n", "FixNamespaceComments:", " ", "true", "\n", "# 需要被解读为foreach循环而不是函数调用的宏", "\n", "ForEachMacros:", "\n  ", "-", " ", "foreach", "\n  ", "-", " ", "Q_FOREACH", "\n  ", "-", " ", "BOOST_FOREACH", "\n", "IfMacros:", "\n  ", "-", " ", "KJ_IF_MAYBE", "\n", "# 多个#include块合并在一起并排序为一个", "\n", "IncludeBlocks:", "   ", "Merge", "\n", "# 可以定义负数优先级从而保证某些#include永远在最前面", "\n", "IncludeCategories:", "\n  ", "-", " ", "Regex:", "           ", "'^\"(llvm|llvm-c|clang|clang-c)/'", "\n    ", "Priority:", "        ", "2", "\n    ", "SortPriority:", "    ", "0", "\n    ", "CaseSensitive:", "   ", "false", "\n  ", "-", " ", "Regex:", "           ", "'^(<|\"(gtest|gmock|isl|json)/)'", "\n    ", "Priority:", "        ", "1", "\n    ", "SortPriority:", "    ", "0", "\n    ", "CaseSensitive:", "   ", "false", "\n  ", "-", " ", "Regex:", "           ", "'.*'", "\n    ", "Priority:", "        ", "3", "\n    ", "SortPriority:", "    ", "0", "\n    ", "CaseSensitive:", "   ", "false", "\n", "IncludeIsMainRegex:", " ", "'(Test)?$'", "\n", "IncludeIsMainSourceRegex:", " ", "''", "\n", "# 缩进访问修饰符", "\n", "IndentAccessModifiers:", " ", "false", "\n", "# 缩进case标签", "\n", "IndentCaseLabels:", " ", "false", "\n", "# case 标签后面的块使用与 case 标签相同的缩进级别", "\n", "IndentCaseBlocks:", " ", "false", "\n", "# 缩进goto标签。", "\n", "IndentGotoLabels:", " ", "false", "\n", "# 缩进预处理器指令", "\n", "IndentPPDirectives:", " ", "None", "\n", "# 向后兼容缩进外部块", "\n", "IndentExternBlock:", " ", "AfterExternBlock", "\n", "# 缩进模板中的requires子句", "\n", "IndentRequires:", "  ", "false", "\n", "# 缩进宽度", "\n", "IndentWidth:", "     ", "4", "\n", "# 函数返回类型换行时，缩进函数声明或函数定义的函数名", "\n", "IndentWrappedFunctionNames:", " ", "false", "\n", "# 插入尾随逗号", "\n", "InsertTrailingCommas:", " ", "None", "\n", "# 保留JavaScript字符串引号", "\n", "JavaScriptQuotes:", " ", "Leave", "\n", "# 包装 JavaScript 导入/导出语句", "\n", "JavaScriptWrapImports:", " ", "true", "\n", "# 保留在块开始处的空行", "\n", "KeepEmptyLinesAtTheStartOfBlocks:", " ", "true", "\n", "# 相对于 lambda 签名对齐 lambda 主体", "\n", "LambdaBodyIndentation:", " ", "Signature", "\n", "# 开始一个块的宏的正则表达式", "\n", "MacroBlockBegin:", " ", "''", "\n", "# 结束一个块的宏的正则表达式", "\n", "MacroBlockEnd:", "   ", "''", "\n", "# 连续空行的最大数量", "\n", "MaxEmptyLinesToKeep:", " ", "1", "\n", "# 命名空间的缩进", "\n", "NamespaceIndentation:", " ", "None", "\n", "ObjCBinPackProtocolList:", " ", "Auto", "\n", "# 使用ObjC块时缩进宽度", "\n", "ObjCBlockIndentWidth:", " ", "0", "\n", "ObjCBreakBeforeNestedBlockParam:", " ", "true", "\n", "# 在ObjC的@property后添加一个空格", "\n", "ObjCSpaceAfterProperty:", " ", "false", "\n", "# 在ObjC的protocol列表前添加一个空格", "\n", "ObjCSpaceBeforeProtocolList:", " ", "true", "\n", "PenaltyBreakAssignment:", " ", "2", "\n", "PenaltyBreakBeforeFirstCallParameter:", " ", "19", "\n", "PenaltyBreakComment:", " ", "300", "\n", "PenaltyBreakFirstLessLess:", " ", "120", "\n", "PenaltyBreakString:", " ", "1000", "\n", "PenaltyBreakTemplateDeclaration:", " ", "10", "\n", "PenaltyExcessCharacter:", " ", "1000000", "\n", "PenaltyReturnTypeOnItsOwnLine:", " ", "60", "\n", "PenaltyIndentedWhitespace:", " ", "0", "\n", "# 指针的对齐: Left, Right, Middle", "\n", "PointerAlignment:", " ", "Left", "\n", "# 缩进预处理器语句的列数", "\n", "PPIndentWidth:", "   ", "-1", "\n", "# 引用的对齐", "\n", "ReferenceAlignment:", " ", "Pointer", "\n", "# 允许重新排版注释", "\n", "ReflowComments:", "  ", "true", "\n", "# 短命名空间跨越的最大展开行数", "\n", "ShortNamespaceLines:", " ", "1", "\n", "# 允许排序#include", "\n", "SortIncludes:", "    ", "CaseSensitive", "\n", "# java静态导入放在非静态导入之前", "\n", "SortJavaStaticImport:", " ", "Before", "\n", "# 对using声明排序", "\n", "SortUsingDeclarations:", " ", "true", "\n", "# 在C风格类型转换后添加空格", "\n", "SpaceAfterCStyleCast:", " ", "false", "\n", "# 在!后添加空格", "\n", "SpaceAfterLogicalNot:", " ", "false", "\n", "# 在Template关键字后添加空格", "\n", "SpaceAfterTemplateKeyword:", " ", "true", "\n", "# 在赋值运算符之前添加空格", "\n", "SpaceBeforeAssignmentOperators:", " ", "true", "\n", "# 不在case冒号之前添加空格", "\n", "SpaceBeforeCaseColon:", " ", "false", "\n", "# 不在C++11大括号列表之前添加空格", "\n", "SpaceBeforeCpp11BracedList:", " ", "false", "\n", "# 在构造函数初始化器冒号之前添加空格", "\n", "SpaceBeforeCtorInitializerColon:", " ", "true", "\n", "# 在继承冒号前添加空格", "\n", "SpaceBeforeInheritanceColon:", " ", "true", "\n", "# 开圆括号之前添加一个空格: Never, ControlStatements, Always", "\n", "SpaceBeforeParens:", " ", "ControlStatements", "\n", "# 不要确保指针限定符周围有空格，而是使用 PointerAlignment", "\n", "SpaceAroundPointerQualifiers:", " ", "Default", "\n", "# 在基于范围的for循环冒号之前添加空格", "\n", "SpaceBeforeRangeBasedForLoopColon:", " ", "true", "\n", "# {}中间不添加空格", "\n", "SpaceInEmptyBlock:", " ", "false", "\n", "# 在空的圆括号中添加空格", "\n", "SpaceInEmptyParentheses:", " ", "false", "\n", "# 在尾随的评论前添加的空格数(只适用于//)", "\n", "SpacesBeforeTrailingComments:", " ", "1", "\n", "# 在尖括号的<后和>前添加空格", "\n", "SpacesInAngles:", "  ", "Never", "\n", "# 不在if/for/switch/while条件周围插入空格", "\n", "SpacesInConditionalStatement:", " ", "false", "\n", "# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格", "\n", "SpacesInContainerLiterals:", " ", "true", "\n", "# 在C风格类型转换的括号中添加空格", "\n", "SpacesInCStyleCastParentheses:", " ", "false", "\n", "# 行注释开头允许有多少个空格。要禁用最大值，请将其设置为-1，除此之外，最大值优先于最小值", "\n", "SpacesInLineCommentPrefix:", "\n  ", "Minimum:", "         ", "1", "\n  ", "Maximum:", "         ", "-1", "\n", "# 在圆括号的(后和)前添加空格", "\n", "SpacesInParentheses:", " ", "false", "\n", "# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响", "\n", "SpacesInSquareBrackets:", " ", "false", "\n", "# 不在[前添加空格", "\n", "SpaceBeforeSquareBrackets:", " ", "false", "\n", "# 位域:每边都添加空格", "\n", "BitFieldColonSpacing:", " ", "Both", "\n", "# 标准", "\n", "Standard:", "        ", "Auto", "\n", "# 在语句前面被忽略的宏定义，就好像它们是一个属性一样", "\n", "StatementAttributeLikeMacros:", "\n  ", "-", " ", "Q_EMIT", "\n", "# 应该被解释为完整语句的宏定义", "\n", "StatementMacros:", "\n  ", "-", " ", "Q_UNUSED", "\n  ", "-", " ", "QT_REQUIRE_VERSION", "\n", "# tab宽度", "\n", "TabWidth:", "        ", "4", "\n", "# 使用\\n换行", "\n", "UseCRLF:", "         ", "false", "\n", "# 使用tab字符：ForIndentation——仅将制表符用于缩进", "\n", "UseTab:", "          ", "ForIndentation", "\n", "# 对空格敏感的宏定义", "\n", "WhitespaceSensitiveMacros:", "\n  ", "-", " ", "STRINGIZE", "\n  ", "-", " ", "PP_STRINGIZE", "\n  ", "-", " ", "BOOST_PP_STRINGIZE", "\n  ", "-", " ", "NS_SWIFT_NAME", "\n  ", "-", " ", "CF_SWIFT_NAME", "\n", "...", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;我把你的代码拿到本地跑了&amp;#xff0c;首先你的代码的API是TF1.x版本的&amp;#xff0c;我本地用的是tf1.15&amp;#xff0c;所以第一步是把TF切换到1.15(我测试通过了&amp;#xff0c;看你用Anaconda&amp;#xff0c;那么安装就很简单了conda install tensorflow&amp;#61;&amp;#61;1.15)&amp;#xff0c;然后注意数据集的读取路劲要写对&amp;#xff0c;你的代码train后面少了个 /&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;train_dir &amp;#61; &amp;#39;C:/Users/My104/Downloads/train/train/&amp;#39;&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;我上传一张我跑起来的截图&lt;/p&gt;\n\n&lt;p style=\"text-align:center\"&gt;&lt;img alt=\"\" height=\"1030\" src=\"https://img-ask.csdnimg.cn/upload/1620134881713.png\" width=\"1920\" /&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["使用tensorflow时在 '__init__.py' 中找不到引用", ["我使用的是Anaconde+cuda10.1+Cudnn+TensorFlow2.1.0+Pytorch1.7.1+Pycharm（python3.6）", "\n\n", "本人是机器学习初学者，想跑一个猫狗大战练练手，遇到了下列问题：", "\n\n", "个人感觉是我的一些配置出现了问题", "\n\n", "\n\n", "老是显示是 '__init__.py' 中找不到引用", "\n\n", "运行train.py会出现报错如下图:", "\n\n", "在网上也没有找到合适的解决方法，希望哥哥姐姐们可以帮我看一下，万分感谢！！!", "\n\n", "代码附在下面（数据集就是猫狗大战的数据集）：", "\n\n", "input_data.py", "\n\n", "\n", "import tensorflow as tf\nimport numpy as np\nimport os\n'''生成图片路径和标签的List'''\ndef get_files(file_dir):\n    '''\n           输入： 存放训练照片的文件地址\n           返回:  图像列表， 标签列表\n    '''\n    cats = []\n\n    label_cats = []\n    dogs = []\n    label_dogs = []\n    for file in os.listdir(file_dir):  # 用os.listdir函数来返回file_dir路径下所有的图片，file就是要读取的照片\n        name = file.split(sep='.')  # 用file.split 将文件的名字分隔开，分隔的符号是‘.’\n        if name[0] == 'cat':  # 所以只用读取 . 前面这个字符串\n            cats.append(file_dir + file)\n            label_cats.append(0)  # 把图像和标签加入列表\n        else:\n            dogs.append(file_dir + file)\n            label_dogs.append(1)  # 名字是cat就赋值0，名字是dog就赋值1\n    print('There are %d cats\\nThere are %d dogs' % (len(cats), len(dogs)))#打印有多少猫，多少狗\n    '''对生成的图片路径和标签List做打乱处理'''\n    image_list = np.hstack((cats, dogs))  #使用np.hstack()将cat和dog的图片和标签整合为列表image_list和label_list\n    label_list = np.hstack((label_cats, label_dogs))\n\n    temp = np.array([image_list, label_list])  # 将image_list和label_list合并，存放在temp\n    temp = temp.transpose()  # 对temp进行转置\n    np.random.shuffle(temp)  # 用shuffle来打乱图片和标签\n\n    image_list = list(temp[:, 0])  #从temp中取出乱序后的image_list和label_list列向量\n    label_list = list(temp[:, 1])\n    label_list = [int(float(i)) for i in label_list]  # 把标签列表转化为int类型\n\n    return image_list, label_list\n\n    ''' 由于数据集较大，需要分批次通过网络，故生成batch'''\n    '''step1：将上面生成的List传入get_batch() ，转换类型，产生一个输入队列queue，因为img和lab是分开的，\n             所以使用tf.train.slice_input_producer()，然后用tf.read_file()从队列中读取图像'''\ndef get_batch(image, label, image_W, image_H, batch_size, capacity):\n    \"\"\"\n    输入：\n    image,label ：要生成batch的图像和标签\n    image_W，image_H: 图像的宽度和高度\n    batch_size: 每个batch要放多少张图片\n    capacity: 一个队列最大多少\n    image_batch: 4D tensor [batch_size, width, height, 3], dtype=tf.float32\n    label_batch: 1D tensor [batch_size], dtype=tf.int32\n    \"\"\"\n    image = tf.cast(image, tf.string) #将列表转换成tf能够识别的格式\n    label = tf.cast(label, tf.int32)\n    \"\"\"\n    队列的理解：每次训练时，从队列中取一个batch送到网络进行训练，\n               然后又有新的图片从训练库中注入队列，这样循环往复。\n               队列相当于起到了训练库到网络模型间数据管道的作用，\n               训练数据通过队列送入网络。\n    \"\"\"\n    input_queue = tf.train.slice_input_producer([image, label])#将image和label合并生成一个队列\n\n    # 图像的读取需要tf.read_file()，标签则可以直接赋值\n    label = input_queue[1]\n    image_contents = tf.read_file(input_queue[0])#然后从队列中分别取出image和label\n    '''step2：将图像解码，不同类型的图像不能混在一起，要么只用jpeg，要么只用png等'''\n    image = tf.image.decode_jpeg(image_contents, channels=3)  # 解码彩色的.jpg图像\n    '''step3：数据预处理，对图像进行旋转、缩放、裁剪、归一化等操作，让计算出的模型更健壮'''\n    image = tf.image.resize_image_with_crop_or_pad(image, image_W, image_H)\n    image = tf.image.per_image_standardization(image)\n    '''step4：生成batch'''\n    image_batch, label_batch = tf.train.batch([image, label],\n                                              batch_size=batch_size,\n                                              num_threads=64,  # 涉及到线程，配合队列\n                                          capacity=capacity)\n    image_batch = tf.cast(image_batch, tf.float32)\n    label_batch = tf.cast(label_batch, tf.int32)  #重新排列label，行数为[batch_size]\n    return image_batch, label_batch\n\n\n# %% TEST\n# To test the generated batches of images\n# When training the model, DO comment the following codes\n\n\nimport matplotlib.pyplot as plt\n\nBATCH_SIZE = 2\nCAPACITY = 256\nIMG_W = 208\nIMG_H = 208\n\ntrain_dir = 'D:/Python/Pycharm_workstation/cats-vs-dogs-master/data/train'\nimage_list, label_list = get_files(train_dir)\nimage_batch, label_batch = get_batch(image_list, label_list, IMG_W, IMG_H, BATCH_SIZE, CAPACITY)\n\nwith tf.Session() as sess:\n    i = 0\n    coord = tf.train.Coordinator()\n    threads = tf.train.start_queue_runners(coord=coord)\n\n    try:\n        while not coord.should_stop() and i < 1:\n\n            img, label = sess.run([image_batch, label_batch])\n\n            # just test one batch\n            for j in np.arange(BATCH_SIZE):\n                print('label: %d' % label[j])  # j-index of quene of Batch_size\n                plt.imshow(img[j, :, :, :])\n                plt.show()\n            i += 1\n\n    except tf.errors.OutOfRangeError:\n        print('done!')\n    finally:\n        coord.request_stop()\n    coord.join(threads)\n\n\n", "\n\n", "model.py", "\n\n", "\n", "import tensorflow as tf\n'''网络结构定义：一个简单的卷积神经网络，卷积+池化层x2，全连接层x2，最后一个softmax层做分类'''\ndef cnn_inference(images, batch_size, n_classes):\n    \"\"\"\n    输入\n    images      输入的图像\n    batch_size  每个批次的大小\n    n_classes   n分类\n    返回\n    softmax_linear 还差一个softmax\n\n输入参数：\nimages，image batch、4D tensor、tf.float32、[batch_size, width, height, channels]\n返回参数：\nlogits, float、 [batch_size, n_classes]\n    \"\"\"\n    '''第一层的卷积层conv1：16个3x3的卷积核（3通道），padding=’SAME’，表示padding后卷积的图与原图尺寸一致，激活函数relu()'''\n    with tf.variable_scope('conv1') as scope:\n        # 建立weights和biases的共享变量\n        # conv1, shape = [kernel size, kernel size, channels, kernel numbers]\n        weights = tf.get_variable('weights',\n                                  shape=[3, 3, 3, 16],\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.1,\n                                                                              dtype=tf.float32))  # stddev标准差\n        biases = tf.get_variable('biases',\n                                 shape=[16],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        conv = tf.nn.conv2d(images, weights, strides=[1, 1, 1, 1], padding='SAME')#padding填充周围有valid（丢弃）和same（补零）可选择\n        #strides:卷积时在图像每一维的步长（这是一个一维的向量，长度4)，第一维和第四维默认为1，第二维和第三维分别是平行和竖直滑行的步进长度\n        pre_activation = tf.nn.bias_add(conv, biases)  # 加入偏差\n        conv1 = tf.nn.relu(pre_activation, name=scope.name)  # 加上激活函数非线性化处理，且是在conv1的命名空间\n\n    '''池化层1:2*2最大池化，步长strides为2，池化后执行lrn()操作，局部响应归一化，对训练有利\n       第一层的池化层pool1和规范化norm1(特征缩放）'''\n    with tf.variable_scope('pooling1_lrn') as scope:\n        pool1 = tf.nn.max_pool(conv1, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1],\n                               padding='SAME', name='pooling1')\n        norm1 = tf.nn.lrn(pool1, depth_radius=4, bias=1.0, alpha=0.001 / 9.0,\n                          beta=0.75, name='norm1')\n        # ksize是池化窗口的大小=[1,height,width,1]，一般height=width=池化窗口的步长\n        # 池化窗口的步长一般是比卷积核多移动一位\n        # tf.nn.lrn是Local Response Normalization，（局部响应归一化）将输入小于0的值幅值为0，输入大于0的值不变\n\n    # 第二层的卷积层cov2，这里的命名空间和第一层不一样，所以可以和第一层取同名\n    with tf.variable_scope('conv2') as scope:\n        weights = tf.get_variable('weights',\n                                  shape=[3, 3, 16, 16],  # 这里只有第三位数字16需要等于上一层的tensor维度\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.1, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[16],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        conv = tf.nn.conv2d(norm1, weights, strides=[1, 1, 1, 1], padding='SAME')\n        pre_activation = tf.nn.bias_add(conv, biases)\n        conv2 = tf.nn.relu(pre_activation, name='conv2')\n\n    # 第二层的池化层pool2和规范化norm2\n    with tf.variable_scope('pooling2_lrn') as scope:\n        norm2 = tf.nn.lrn(conv2, depth_radius=4, bias=1.0, alpha=0.001 / 9.0,\n                          beta=0.75, name='norm2')\n        pool2 = tf.nn.max_pool(norm2, ksize=[1, 2, 2, 1], strides=[1, 1, 1, 1],\n                               padding='SAME', name='pooling2')\n        # 这里选择了先规范化再池化\n\n    # 第三层为全连接层local3,128个神经元，将之前pool层的输出reshape成一行，激活函数relu()\n    with tf.variable_scope('local3') as scope:\n        # flatten-把卷积过的多维tensor拉平成二维张量（矩阵）\n        reshape = tf.reshape(pool2, shape=[batch_size, -1])  # batch_size表明了有多少个样本\n\n        dim = reshape.get_shape()[1].value  # 知道-1(代表任意)这里具体是多少个\n        weights = tf.get_variable('weights',\n                                  shape=[dim, 128],  # 连接128个神经元\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[128],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        local3 = tf.nn.relu(tf.matmul(reshape, weights) + biases, name=scope.name)  # 矩阵相乘加上bias\n\n    # 第四层为全连接层local4\n    with tf.variable_scope('local4') as scope:\n        weights = tf.get_variable('weights',\n                                  shape=[128, 128],  # 再连接128个神经元\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[128],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        local4 = tf.nn.relu(tf.matmul(local3, weights) + biases, name='local4')\n\n    # 第五层为输出层softmax_linear,Softmax回归层 将前面的FC层输出，做一个线性回归，计算出每一类的得分，在这里是2类，所以这个层输出的是两个得分\n    with tf.variable_scope('softmax_linear') as scope:\n        weights = tf.get_variable('weights',\n                                  shape=[128, n_classes],\n                                  dtype=tf.float32,\n                                  initializer=tf.truncated_normal_initializer(stddev=0.005, dtype=tf.float32))\n        biases = tf.get_variable('biases',\n                                 shape=[n_classes],\n                                 dtype=tf.float32,\n                                 initializer=tf.constant_initializer(0.1))\n        softmax_linear = tf.add(tf.matmul(local4, weights), biases, name='softmax_linear')\n        # 这里只是命名为softmax_linear，真正的softmax函数放在下面的losses函数里面和交叉熵结合在一起了，这样可以提高运算速度。\n        # softmax_linear的行数=local4的行数，列数=weights的列数=bias的行数=需要分类的个数\n        # 经过softmax函数用于分类过程中，它将多个神经元的输出，映射到（0,1）区间内，可以看成概率来理解\n\n    return softmax_linear\n\n'''loss计算 \n   将网络计算得出的每类得分与真实值进行比较，得出一个loss损失值，这个值代表了计算值与期望值的差距。这里使用的loss函数是交叉熵。\n   一批loss取平均数。最后调用了summary.scalar()记录下这个标量数据，在TensorBoard中进行可视化\n'''\ndef losses(logits, labels):\n    \"\"\"\n    输入\n    logits: 经过cnn_inference处理过的tensor\n    labels: 对应的标签\n    返回\n    loss： 损失函数（交叉熵）\n    \"\"\"\n    with tf.variable_scope('loss') as scope:\n        cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=labels, name='loss_per_eg')\n        '''tf.nn.sparse_softmax_cross_entropy_with_logits()放在图片上，就是对一个像素深度方向的向量，与对应的标签做交叉熵，\n           再求一个像素深度方向交叉熵的和。loss值是对所有像素点的交叉熵和取平均。'''\n        loss = tf.reduce_mean(cross_entropy, name='loss')  # 求所有样本的平均loss\n        tf.summary.scalar(scope.name + '/loss', loss)\n    return loss\n'''loss损失值优化 :目的就是让loss越小越好，使用的是AdamOptimizer优化器 \n   函数：def trainning(loss, learning_rate)'''\ndef training(loss, learning_rate):\n    \"\"\"\n    输入\n    loss: 损失函数（交叉熵）\n    learning_rate： 学习率\n    返回\n    train_op: 训练的最优值\n    \"\"\"\n    with tf.name_scope('optimizer'):\n        optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)\n        # global_step不是共享变量，初始值为0，设定trainable=False 可以防止该变量被数据流图的 GraphKeys.TRAINABLE_VARIABLES 收集,\n        # 这样我们就不会在训练的时候尝试更新它的值。\n        global_step = tf.Variable(0, name='global_step', trainable=False)\n        train_op = optimizer.minimize(loss, global_step=global_step)\n    return train_op\n'''评价/准确率计算:计算出平均准确率来评价这个模型，在训练过程中按批次计算（每隔N步计算一次），可以看到准确率的变换情况。 \n   函数：def evaluation(logits, labels):'''\ndef evaluation(logits, labels):\n    \"\"\"\n     输入\n    logits: 经过cnn_inference处理过的tensor\n    labels:\n    返回\n    accuracy：正确率\n    \"\"\"\n    with tf.variable_scope('accuracy') as scope:\n        prediction = tf.nn.softmax(logits)\n        # Softmax简单的说就是把一个N*1的向量归一化为（0，1）之间的值，由于其中采用指数运算，使得向量中数值较大的量特征更加明显\n        # prediction每行的最大元素（1）的索引和label的值相同则为1 否则为0。\n        correct = tf.nn.in_top_k(prediction, labels, 1)\n        #tf.nn.in_top_k组要是用于计算预测的结果和实际结果的是否相等\n        # correct = tf.nn.in_top_k(logits, labels, 1)   也可以不需要prediction过渡，因为最大值的索引没变，这里这样写是为了更好理解\n        correct = tf.cast(correct, tf.float16)  # tf.cast() 函数的作用是执行 tensorflow 中张量数据类型转换\n        accuracy = tf.reduce_mean(correct)\n        tf.summary.scalar(scope.name + '/accuracy', accuracy)#通过函数tf.summary.scalar()记录的数据的变化趋势\n    return accuracy\n", "\n\n", "train.py", "\n\n", "\n", "import os\nimport numpy as np\nimport tensorflow as tf\nimport input_data\nimport model\n\nN_CLASSES = 2  # 猫和狗\nIMG_W = 208  # resize图像，太大的话训练时间久\nIMG_H = 208\nBATCH_SIZE = 16#一次迭代的图片数量（50）\nCAPACITY = 2000\nMAX_STEP = 10000  # 一般5K~10k\nlearning_rate = 0.0001  # 一般小于0.0001\n\ntrain_dir = 'D:/Python/Pycharm_workstation/cats-vs-dogs-master/data/train'\nlogs_train_dir = 'D:/Python/Pycharm_workstation/catsvsdogs/log/'  # 记录训练过程与保存模型\n'''获取批次batch'''\ntrain, train_label = input_data.get_files(train_dir)\ntrain_batch,train_label_batch=input_data.get_batch(train,\n                                                   train_label,\n                                                   IMG_W,\n                                                   IMG_H,\n                                                   BATCH_SIZE,\n                                                   CAPACITY)\n'''操作定义'''\ntrain_logits = model.cnn_inference(train_batch, BATCH_SIZE, N_CLASSES)\ntrain_loss = model.losses(train_logits, train_label_batch)\ntrain_op = model.training(train_loss, learning_rate)\ntrain__acc = model.evaluation(train_logits, train_label_batch)\nsummary_op = tf.summary.merge_all() #自动管理模式\n\n#产生一个会话\nsess = tf.Session()\n#产生一个writer来写log文件\ntrain_writer = tf.summary.FileWriter(logs_train_dir, sess.graph)\n #产生一个saver来存储训练好的模型\nsaver = tf.train.Saver()\n#所有节点初始化\nsess.run(tf.global_variables_initializer())\n\n'''TensorFlow提供了两个类来实现对Session中多线程的管理：tf.Coordinator和 tf.QueueRunner，这两个类往往一起使用。'''\ncoord = tf.train.Coordinator()\n'''Coordinator类用来管理在Session中的多个线程，可以用来同时停止多个工作线程并且向那个在等待所有工作线程终止的程序报告异常，\n   该线程捕获到这个异常之后就会终止所有线程。使用 tf.train.Coordinator()来创建一个线程管理器（协调器）对象\n   QueueRunner类用来启动tensor的入队线程，可以用来启动多个工作线程同时将多个tensor（训练数据）推送入文件名称队列中，具体执行函数是\n    tf.train.start_queue_runners ， 只有调用 tf.train.start_queue_runners 之后，才会真正把tensor推入内存序列中，供计算单元调用，否则\n    会由于内存序列为空，数据流图会处于一直等待状态。\n'''\nthreads = tf.train.start_queue_runners(sess=sess, coord=coord)\n'''进行batch的训练'''\ntry:\n    #执行MAX_STEP步的训练，一步一个batch\n    for step in np.arange(MAX_STEP):\n        if coord.should_stop():\n                break\n        _, tra_loss, tra_acc = sess.run([train_op, train_loss, train__acc])\n        #每隔50步打印一次当前的loss以及acc，同时记录log，写入writer\n        if step % 50 == 0:\n            print('Step %d, train loss = %.2f, train accuracy = %.2f%%' %(step, tra_loss, tra_acc*100.0))\n            summary_str = sess.run(summary_op)\n            train_writer.add_summary(summary_str, step)\n        #每隔2000步，保存一次训练好的模型\n        if step % 2000 == 0 or (step + 1) == MAX_STEP:\n            checkpoint_path = os.path.join(logs_train_dir, 'model.ckpt')\n            saver.save(sess, checkpoint_path, global_step=step)\n\nexcept tf.errors.OutOfRangeError: #如果读取到文件队列末尾会抛出此异常\n    print('Done training -- epoch limit reached')\nfinally:\n    coord.request_stop()# 协调器coord发出所有线程终止信号\ncoord.join(threads)\nsess.close()\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;有没有创建与打开所写文件名相同的文件在当前目录下&lt;/p&gt;", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["运行结果为文件打开失败，怎么做才能运行成功", ["bank.cpp", "\n", "#include <iostream>", "\n", "#include <fstream>", "\n", "#include <cstdlib>//提供一些类型，函数和常量 ", "\n", "#include <cstdio>//输入输出流 ", "\n", "#include \"head.h\"", "\n", "#include <ctype.h>//提供两种类型函数1.字符分类函数，检测参数传入的字符是否属于某个特定的分类2.字符转换函数，用来对大小写字母进行转换 ", "\nusing namespace std;\nint acount();\nvoid ctime();\nBank::Bank(){}\n \n/***********************\n*功能：用于读取文件中保存的业务数据\n*输入参数：无\n*输出参数：无\n*返回值：无\n*其他说明：无\n***********************/\nvoid Bank::cinfile()\n{\n    ifstream infile(", "\"account.dat\"", ",ios::", "in", ");\n    ", "if", "(!infile)\n    {\n        cerr<<", "\"open error!\"", "<<endl;\n        ", "exit", "(", "1", ");\n    }\n    N = acount(); ", "//", "用静态数据成员\n    users=new User[N+", "1", "];\n    int i=", "0", ";\n    int acc;      ", "//", "账号\n    string nam;   ", "//", "姓名\n    string eid;   ", "//", "身份证号\n    string eaddr; ", "//", "家庭住址\n    int pw;       ", "//", "密码\n    double bal;   ", "//", "金额\n    int sta;      ", "//", "状态\n    ", "while", "(infile>>acc>>nam>>eid>>eaddr>>pw>>bal>>sta)   ", "//", "当读取成功……\n    {\n        users[i].setUser(acc,nam,eid,eaddr,pw,bal,sta);\n        i++;\n    }\n    infile.close();\n}\n \n/***********************\n*功能：用于读取文件中保存的数据的人数\n*输入参数：无\n*输出参数：无\n*返回值：anum-当前账户数量\n*其他说明：无\n***********************/\nint acount()\n{\n    ifstream infile(", "\"account.dat\"", ",ios::", "in", ");\n    ", "if", "(!infile)\n    {\n        cerr<<", "\"open error!\"", "<<endl;\n        ", "exit", "(", "1", ");\n    }\n    int anum=", "0", ";\n    int acc;     ", "//", "账号\n    string nam;   ", "//", "姓名\n    int pw;      ", "//", "密码\n    double bal;   ", "//", "金额\n    string eid;   ", "//", "身份证号\n    string eaddr; ", "//", "家庭住址\n    int sta;      ", "//", "状态\n    ", "while", "(infile>>acc>>nam>>eid>>eaddr>>pw>>bal>>sta)   ", "//", "当读取成功……\n    {\n        ++anum;\n    }\n    return anum;\n \n}\n \n/***********************\n*功能：用于将数据保存到文件中\n*输入参数：无\n*输出参数：无\n*返回值：无\n*其他说明：无\n***********************/\nvoid Bank::coutfile()\n{\n    ofstream outfile(", "\"account.dat\"", ",ios::out);\n    ", "if", "(!outfile)    ", "//", "测试文件打开操作是否成功，不成功则提示后退出。\n    {\n        cerr<<", "\"open error!\"", "<<endl;\n        ", "exit", "(", "1", ");\n    }\n    int i;\n    ", "for", "(i=", "0", "; i<N; i++)\n    {\n        outfile<<users[i].account<<", "\" \"", ";\n        outfile<<users[i].name<<", "\" \"", ";\n        outfile<<users[i].cid<<", "\" \"", ";\n        outfile<<users[i].address<<", "\" \"", ";\n        outfile<<users[i].password<<", "\" \"", ";\n        outfile<<users[i].balance<<", "\" \"", ";\n        outfile<<users[i].status<<endl;\n    }\n    outfile.close();\n}\n \n/***********************\n*功能：办理业务\n*输入参数：iChoice   ", "//i", "nt型\n*输出参数：无\n*返回值：无\n*其他说明：无\n***********************/\nvoid Bank::work()\n{\n    int iChoice;   ", "//", "用于选择系统功能\n    ", "//", "办理业务\n    ", "do", "\n    {\n        cinfile();\n        iChoice = chooseInMenu();  ", "//", "从菜单中获得功能代码\n        switch(iChoice)\n        {\n        case ", "1", ":\n            openAccount();    ", "//", "开户\n            ", "break", ";\n        case ", "2", ":\n            cancelAccount();  ", "//", "注销账户\n            ", "break", ";\n        case ", "3", ":\n            save();            ", "//", "存款\n            ", "break", ";\n        case ", "4", ":\n            withdraw();       ", "//", "取款\n            ", "break", ";\n        case ", "5", ":\n            showAccount();     ", "//", "查询余额\n            ", "break", ";\n        case ", "6", ":\n            transferAccounts();  ", "//", "转账\n            ", "break", ";\n        case ", "0", ":\n            cout<<", "\"欢迎您再来. \"", "<<endl;\n        }\n        coutfile();\n    }\n    ", "while", "(iChoice);\n    ", "delete", " []users;\n}\n \n/***********************\n*功能：开户\n*输入参数：\n    账号acc;      ", "//", " int型\n    姓名nam;      ", "//", " string型\n    身份证号did;  ", "//", " string型\n    地址daddr;      ", "//", " string型\n    密码pw;       ", "//", "  int型\n    金额bal;      ", "//", " double 型\n*输出参数：无\n*返回值：无\n*其他说明：在进入系统时，在读入数据过程中，已经记录了用户数为N，在数组中对应下标为", "0", "~N-", "1", "\n  开户时要增加一个用户，只要为下标为N的数组元素置值，并在成功之后令N++即可。\n  账号由系统自动生成(", "10001", "+序号)，保证其连续，这样在顺序增加的时候，就保证了其有序。\n***********************/\nvoid Bank::openAccount()\n{\n    ", "//", "下面正常办理开户业务\n    int acc;   ", "//", "账号\n    string nam;   ", "//", "姓名\n    string did;  ", "//", "身份证号\n    string daddr; ", "//", "家庭住址\n    int pw;   ", "//", "密码\n    double bal;   ", "//", "金额\n    int sta;   ", "//", "状态\n    cout<<", "\"正在开户\"", "<<endl;\n    acc=", "10001", "+N;\n    cout<<", "\"账号：\"", "<<acc<<endl;\n    cout<<", "\"户主姓名：\"", ";\n    cin>>nam;\n    cout<<", "\"身份证号：\"", ";\n    cin>>did;\n    ", "while", "(did.length()!=", "18", ")\n    {\n        cout<<", "\"身份证号码必须是18位!\"", "<<endl<<", "\"重新输入：\"", ";\n        cin>>did;\n    }\n \n    cout<<", "\"家庭住址：\"", ";\n    cin>>daddr;\n    int iPass1, iPass2;\n    cout<<", "\"密码：\"", ";\n    iPass1=inputPassword();  ", "//", "输入密码", "1", "\n    cout<<", "\"确认密码：\"", ";\n    iPass2=inputPassword();  ", "//", "输入密码", "2", "\n    ", "if", "(iPass1==iPass2)\n    {\n        pw=iPass1;\n        sta=", "0", "; ", "//", "账户状态为“正常”\n        cout<<", "\"存入金额：\"", ";\n        cin>>bal;\n        users[N].setUser(acc, nam,  did,daddr,pw,bal,sta);\n        N++; ", "//", "正式用户数增加", "1", "，确认了新用户已经加入\n        cout<<", "\"成功开户！\"", "<<endl;\n    }\n    ", "else", "\n    {\n        cout<<", "\"两次密码不一致，未成功开户！\"", "<<endl; ", "//", "没有N++，则读入的值无效\n    }\n}\n \n/***********************\n*功能：注销账户\n*输入参数：无\n*输出参数：无\n*返回值：无\n*其他说明：找到账户，并将其状态改为", "2", "-注销即可。\n注销前应该检查余额，应该先取款再注销\n***********************/\nvoid Bank::cancelAccount()\n{\n    int who;  ", "//", "查找到该账号在数组中对应的下标\n    who = getUser();  ", "//", "根据账号查询用户，返回用户的下标\n    ", "if", "(who>=", "0", ")   ", "//", "说明id账户存在\n    {\n        users[who].showName();\n        ", "if", "(users[who].passwordIsRight())\n        {\n            users[who].showid();\n            users[who].showaddress();\n            users[who].showBalance(", "\"余额\"", ");   ", "//", "提示", "\"余额\"", "二字，显示金额\n            ", "if", "(users[who].status==", "0", "||users[who].status==", "1", "||users[who].status==", "2", ")\n            {\n                cout<<", "\"确认销户（y/n）？\"", ";\n                ", "if", "(tolower(getchar())==", "'y'", ")\n                {\n                    users[who].showBalance(", "\"销户成功！本次取款金额为\"", ");\n                    users[who].balance=", "0", ";  ", "//", "取款后余额变", "0", "\n                    users[who].status=", "2", ";  ", "//", "状态变为注销\n                }\n                ", "else", "\n                {\n                    cout<<", "\"你取消了操作，销户失败！\"", "<<endl;\n                }\n            }\n            ", "else", " ", "if", "(users[who].status==", "3", ")\n                cout<<", "\"该用户处于冻结状态，不能销户！\"", ";\n            fflush(stdin);  ", "//", "清除了getchar()时在键盘缓存中的遗留，以免影响后续操作\n        }\n    }\n}\n/***********************\n*功能：存款\n*输入参数：money   ", "//", "double 型\n*输出参数：无\n*返回值：无\n*其他说明：需要保证账户存在，且处于正常状态\n***********************/\nvoid Bank::save()\n{\n    int who;\n    double money;\n    who = getUser();  ", "//", "根据账号查询用户，返回用户的下标\n    ", "if", "(who>=", "0", ")   ", "//", "说明id账户存在\n    {\n        ", "if", "(users[who].status==", "0", ")\n        {\n            users[who].showName();\n            users[who].showid();\n            users[who].showaddress();\n            cout<<", "\"输入存款额：\"", ";\n            cin>>money;\n            users[who].balance+=money;\n            users[who].showBalance(", "\"存款后，您有\"", ");\n            ofstream outfile(", "\"yw.txt\"", ",ios::app);\n            ", "if", "(!outfile)    ", "//", "测试文件打开操作是否成功，不成功则提示后退出。\n            {\n                cerr<<", "\"open error!\"", "<<endl;\n                ", "exit", "(", "1", ");\n            }\n            ctime();\n            outfile<<", "\"  \"", ";\n            outfile<<users[who].account<<", "\" \"", "<<users[who].name<<", "\" \"", "<<", "\"存入金额\"", "<<money<<", "\"元\"", "<<endl;\n            outfile.close();\n        }\n        ", "else", " ", "if", "(users[who].status==", "2", ")\n        {\n            cout<<", "\"该用户已经销户，存款失败！\"", "<<endl;\n        }\n        \n    }\n    return;\n}\n \n/***********************\n*功能：取款\n*输入参数：money    ", "//", " double型\n*输出参数：无\n*返回值：无\n*其他说明：需要保证账户存在，且处于正常状态，另外，余额要足够取\n***********************/\nvoid Bank::withdraw()\n{\n    int who;\n    double money;\n    who = getUser();  ", "//", "根据账号查询用户，返回用户的下标\n    ", "if", "(who>=", "0", ")   ", "//", "说明id账户存在\n    {\n        ", "if", "(users[who].isNormalUser())\n        {\n            users[who].showName();\n            users[who].showid();\n            users[who].showaddress();\n            ", "if", "(users[who].passwordIsRight())\n            {\n                cout<<", "\"输入取款额：\"", ";\n                cin>>money;\n                ", "if", "(money>users[who].balance)  ", "//", "亲，不玩透支\n                {\n                    cout<<", "\"余额不足，取款失败！\"", "<<endl;\n                }\n                ", "else", "\n                {\n                    users[who].balance-=money;\n                    users[who].showBalance(", "\"取款后，还有\"", ");\n                    ofstream outfile(", "\"yw.txt\"", ",ios::app);\n                    ", "if", "(!outfile)    ", "//", "测试文件打开操作是否成功，不成功则提示后退出。\n                    {\n                        cerr<<", "\"open error!\"", "<<endl;\n                        ", "exit", "(", "1", ");\n                    }\n                    ctime();\n                    outfile<<", "\"  \"", ";\n                    outfile<<users[who].account<<", "\" \"", "<<users[who].name<<", "\" \"", "<<", "\"取走金额\"", "<<money<<", "\"元\"", "<<endl;\n                    outfile.close();\n                }\n            }\n        }\n    }\n    return;\n}\n/***********************\n*功能：查询账户\n*输入参数：无\n*输出参数：无\n*返回值：无\n*其他说明：显示账户信息\n***********************/\nvoid Bank::showAccount()\n{\n    int who;\n    string hms;\n    int cacc;\n    string cname;\n    string cyw;\n    string sta[", "2", "]= {", "\"正常\"", ",", "\"已经销户\"", "};\n    who = getUser();  ", "//", "根据账号查询用户，返回用户的下标\n    ", "if", "(who>=", "0", ")   ", "//", "说明id账户存在\n    {\n        users[who].showName();\n        ", "if", "(users[who].passwordIsRight())\n        {\n            users[who].showid();\n            users[who].showaddress();\n            users[who].showBalance(", "\"余额\"", ");\n            cout<<", "\"状态：\"", "<<sta[users[who].status]<<endl;\n            cout<<", "\"是否查询明细（y/n）？\"", ";\n            ", "if", "(tolower(getchar())==", "'y'", ")\n            {\n                ifstream infile(", "\"yw.txt\"", ",ios::", "in", ");\n                ", "if", "(!infile)    ", "//", "测试文件打开操作是否成功，不成功则提示后退出。\n                {\n                    cerr<<", "\"open error!\"", "<<endl;\n                    ", "exit", "(", "1", ");\n                }\n                ", "while", "(infile>>hms>>cacc>>cname>>cyw)\n                {\n                    ", "if", "(users[who].name==cname)\n                        cout<<hms<<", "\" \"", "<<cacc<<", "\" \"", "<<cname<<", "\" \"", "<<cyw<<endl;\n                }\n                ", "if", "(users[who].name!=cname)\n                    cout<<", "\"当前未办理过任何业务。\"", "<<endl;\n                infile.close();\n            }\n            ", "else", "\n            {\n                cout<<endl;\n            }\n \n        }\n        return;\n    }\n}\n \n/***********************\n*功能：转账\n*输入参数：money   ", "//", "double型\n*输出参数：无\n*返回值：无\n*其他说明：需要保证两个账户都存在，且处于正常状态，另外，转出账户的余额要足够\n***********************/\nvoid Bank::transferAccounts()\n{\n    int whoout, whoin;\n    double money;\n    cout<<", "\"转出自\"", ";\n    whoout = getUser();  ", "//", "根据账号查询用户，返回用户的下标\n    ", "if", "(whoout>=", "0", ")   ", "//", "说明id账户存在\n    {\n        ", "if", "(users[whoout].isNormalUser())\n        {\n            users[whoout].showName();\n            ", "if", "(users[whoout].passwordIsRight())\n            {\n                users[whoout].showid();\n                users[whoout].showaddress();\n                cout<<", "\"输入转账金额：\"", ";\n                cin>>money;\n                ", "if", "(money>users[whoout].balance)  ", "//", "亲，不玩透支\n                {\n                    cout<<", "\"余额不足，转账失败！\"", "<<endl;\n                }\n                ", "else", "\n                {\n                    cout<<", "\"转出到\"", ";\n                    whoin = getUser();  ", "//", "根据账号查询用户，返回用户的下标\n                    ", "if", "(whoin>=", "0", ")   ", "//", "说明id账户存在\n                    {\n                        ", "if", "(users[whoin].isNormalUser())\n                        {\n                            users[whoout].balance-=money;\n                            users[whoin].balance+=money;\n                            users[whoout].showBalance(", "\"转账后，您还有\"", ");\n                            ofstream outfile(", "\"yw.txt\"", ",ios::app);\n                            ", "if", "(!outfile)    ", "//", "测试文件打开操作是否成功，不成功则提示后退出。\n                            {\n                                cerr<<", "\"open error!\"", "<<endl;\n                                ", "exit", "(", "1", ");\n                            }\n                            ctime();\n                            outfile<<", "\"  \"", ";\n                            outfile<<users[whoout].account<<", "\" \"", "<<users[whoout].name<<", "\" \"", "<<", "\"转出金额\"", "<<money<<", "\"元\"", "<<endl;\n                            outfile.close();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return;\n}\n\n/***********************\n*功能：输入账号查询用户，返回用户在数组中的下标\n*输入参数：要查询用户的账号\n*输出参数：无\n*返回值：如果该用户存在，返回该用户在数组中的下标，否则，返回一个负数（-", "1", "）\n*其他说明：由账号自动产生，使按账号有序，本模块采用二分查找\n***********************/\nint Bank::getUser()\n{\n    int id;\n    cout<<", "\"账号：\"", ";\n    cin>>id;\n    int index=-", "1", ";\n    int low=", "0", ", high=N-", "1", ", mid;\n    ", "while", "(low<=high)\n    {\n        mid = (low+high)/", "2", ";\n        ", "if", "(users[mid].account==id)\n        {\n            index=mid;\n            ", "break", ";   ", "//", "找到了，立即退出循环\n        }\n        ", "else", " ", "if", " (users[mid].account>id)\n            high=mid-", "1", ";\n        ", "else", "\n            low=mid+", "1", ";\n    }\n    ", "if", " (index<", "0", ")\n        cout<<", "\"该用户不存在，本次操作失败！\"", "<<endl;\n    return index; ", "//", "若找到，其值在", "0", "~N-", "1", "间，否则，保持-", "1", "\n}\n\n", "\n", "head.h", "\n", "#", "ifndef", " BANK_H_INCLUDED", "\n", "#", "define", " BANK_H_INCLUDED", "\n", "#", "include", " ", "<cstring>", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<time.h>", "\n", "#", "include", " ", "<iostream>", "\n", "using", " ", "namespace", " std;\n \n", "class", " ", "Bank", ";\n", "class", " ", "User", "\n{\n", "public", ":\n    ", "void", " ", "setUser", "(", "int", " acc, string nam, string xid,string xaddr,", "int", " pw, ", "double", " bal,", "int", " sta)", ";\n    ", "void", " ", "showName", "()", ";                 ", "//显示姓名", "\n    ", "void", " ", "showaddress", "()", ";              ", "//显示地址", "\n    ", "void", " ", "showid", "()", ";                   ", "//显示身份证号", "\n    ", "void", " ", "showBalance", "(string prompt)", "; ", "//显示余额，前面加上提示词prompt", "\n    ", "bool", " ", "passwordIsRight", "()", ";          ", "//校验密码，输入的密码正确则返回true", "\n    ", "bool", " ", "isNormalUser", "()", ";            ", "//存款、取款、转帐等功能，需要账户处于正常姿态，处于正常状态时返回true，其他情形返回false并提示", "\n    ", "friend", " ", "class", " ", "Bank", ";              ", "//将Bank声明为友元类，方便其访问数据成员", "\n", "private", ":\n    ", "int", " account;     ", "//账号", "\n    string name;     ", "//用户名", "\n    string cid;      ", "//身份证号", "\n    string address;  ", "//家庭住址", "\n    ", "int", " password;    ", "//密码", "\n    ", "double", " balance;  ", "//账户余额", "\n    ", "int", " status;     ", "//状态 0-正常  1-挂失  2-销户 3-冻结", "\n};\n \n", "class", " ", "Bank", "\n{\n", "public", ":\n    ", "Bank", "();\n    ", "void", " ", "cinfile", "()", ";          ", "//从文件中读数据，存在数组中", "\n    ", "void", " ", "coutfile", "()", ";         ", "//将数组中的数据写入到文件中", "\n    ", "void", " ", "work", "()", ";             ", "//业务驱动", "\n    ", "void", " ", "openAccount", "()", ";      ", "//开户", "\n    ", "void", " ", "cancelAccount", "()", ";    ", "//注销账户", "\n    ", "void", " ", "save", "()", ";             ", "//存款", "\n    ", "void", " ", "withdraw", "()", ";         ", "//取款", "\n    ", "void", " ", "showAccount", "()", ";      ", "//查询余额", "\n    ", "void", " ", "transferAccounts", "()", ";  ", "//转账", "\n    ", "void", " ", "updatePassword", "()", ";   ", "//更改密码", "\n    ", "int", " ", "getUser", "()", ";          ", "//输入账号查询用户，返回用户在对象数组中的下标", "\n", "private", ":\n    ", "int", " N;                  ", "//实际的用户数目", "\n    User *users;            ", "//User数组，耗空间啊！改进方案：1.对象指针数组；2. 动态数组；3. 链表", "\n};\n \n", "int", " ", "pass", "()", ";                ", "//业务员登录", "\n", "int", " ", "chooseInMenu", "()", ";        ", "//显示菜单并由业务员选择", "\n", "int", " ", "inputPassword", "()", ";       ", "//返回键盘输入的密码", "\n \n \n", "#", "endif", " ", "// BANK_H_INCLUDED", "\n\n", "\n", "main.cpp", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<cstdio>", "\n", "#", "include", "<fstream>", "\n", "#", "include", "<iomanip>", "\n", "#", "include", " ", "<stdio.h>", "\n", "#", "include", " ", "<conio.h>", "    ", "//将密码变成*号", "\n", "#", "include", " ", "\"head.h\"", "\n", "#", "include", " ", "<stdlib.h>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "pass", "()", ";  ", "//业务员登录", "\n", "int", " ", "chooseInMenu", "()", "; ", "//显示菜单并由业务员选择", "\n", "int", " ", "inputPassword", "()", ";   ", "//返回键盘输入的密码", "\n", "void", " ", "ctime", "()", ";\n", "void", " ", "welcome", "()", "\n", "{\n    cout<<", "\"+----------------------+\"", "<<endl;\n    cout<<", "\"+   欢迎光临银行   +\"", "<<endl;\n    cout<<", "\"+----------------------+\"", "<<endl;\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "welcome", "();\n    Bank b;\n    ", "if", "(", "pass", "())\n    {\n    b.", "work", "();}\n    ", "return", " ", "0", ";\n}\n\n", "\n", "work.cpp", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<fstream>", "\n", "#", "include", " ", "<conio.h>", "\n", "#", "include", " ", "<cstdlib>", "\n", "#", "include", " ", "<cstring>", "\n", "#", "include", " ", "<ctype.h>", "\n", "#", "include", " ", "\"head.h\"", "\n", "using", " ", "namespace", " std;\n \n", "/***************\n功能：验证用户密码\n返回值：密码正确，返回1；\n        不能通过密码验证，返回0\n****************/", "\n", "int", " ", "pass", "()", "\n", "{\n    ", "char", " sNameInFile[", "20", "];   ", "//由文件中读出的业务员用户名", "\n    ", "char", " sPassInFile[", "20", "];  ", "//文件中保存的密码，这一版本中，用字符保存密码", "\n    ", "ifstream ", "infile", "(", "\"password.txt\"", ",ios::in)", ";\n    ", "if", "(!infile)\n    {\n        cout<<", "\"password file cannot open!\"", "<<endl;\n        ", "exit", "(", "1", ");\n    }\n    infile>>sNameInFile>>sPassInFile;\n    infile.", "close", "();\n \n    ", "char", " sName[", "20", "];   ", "//业务员登录时输入的用户名", "\n    ", "char", " sPass[", "20", "];  ", "//业务员登录时输入的密码", "\n    ", "char", " ch;\n    ", "int", " iTry=", "3", ";   ", "//进入系统时尝试的次数", "\n    ", "int", " right = ", "0", ";  ", "//要返回的结果：0-不正确 1-正确", "\n \n    ", "//进入系统，密码三次不对将退出", "\n    ", "do", "\n    {\n        cout<<", "\"请输入业务员用户名:\"", ";\n        cin>>sName;\n        cout<<", "\"请输入密码:\"", ";\n        ", "int", " i=", "0", ";\n        ", "while", "((ch=", "getch", "())!=", "'\\r'", ")  ", "//getch在接受输入后，不在屏幕上显示", "\n        {\n            sPass[i++]=ch;\n            ", "putchar", "(", "'*'", ");   ", "//接受任何字符，屏幕上只显示*", "\n        }\n        sPass[i]=", "'\\0'", ";\n        ", "fflush", "(stdin);\n        cout<<endl;;\n        ", "if", "(", "strcmp", "(sPass,sPassInFile)==", "0", "&&", "strcmp", "(sName,sNameInFile)==", "0", ")\n        {\n            right = ", "1", ";\n            ", "break", ";\n        }\n        ", "else", "\n        {\n            iTry--;\n            ", "if", "(iTry>", "0", ")\n                cout<<", "\"超过3次将退出，你还可以尝试\"", "<<iTry<<", "\"次！\"", "<<endl;\n            ", "else", "\n            {\n                cout<<", "\"对不起，你不能进入系统\"", "<<endl;\n                right=", "0", ";\n            }\n        }\n    }\n    ", "while", "(iTry);\n    ", "return", " right;\n}\n \n", "/*\n关于getch()的一点说明：\n所在头文件：conio.h\n函数用途：从控制台读取一个字符，但不显示在屏幕上\n函数原型：int getch(void)\n返回值：读取的字符\n在不同平台，输入回车，getch()将返回不同数值，而getchar()统一返回10(即\\n)\n1)windows平台下ENTER键会产生两个转义字符 \\r\\n，因此getch返回13(\\r)。\n2)unix、 linux系统中ENTER键只产生 \\n ，因此getch返回10(\\n)。\n3)MAC OS中ENTER键将产生 \\r ，因此getch返回13(\\r)。\n为避免键盘缓存区中未读出的字符影响程序，用fflush(stdin);清除输入缓存区\n*/", "\n \n", "/***************\n功能：显示菜单并由业务员选择\n返回值：用户选择的功能，范围0-11\n****************/", "\n", "int", " ", "chooseInMenu", "()", "\n", "{\n    ", "int", " i;\n    ", "while", "(", "1", ")\n    {\n        cout<<endl;;\n        cout<<", "\"+----------------------------+\"", "<<endl;\n        cout<<", "\"+ 1 开户    2 销户    3 存款 +\"", "<<endl;\n        cout<<", "\"+ 4 取款    5 查询    6 转账 +\"", "<<endl;\n        cout<<", "\"+ 7 改密                      +\"", "<<endl;\n        cout<<", "\"+ 0 退出                     +\"", "<<endl;\n        cout<<", "\"+----------------------------+\"", "<<endl;\n        cout<<", "\"请输入操作指令:\"", ";\n        cin>>i;\n        ", "if", "(i>=", "0", " && i<=", "8", ")\n            ", "break", ";\n        ", "else", "\n            cout<<", "\"请重新选择功能\"", "<<endl;;\n    }\n    ", "return", " i;\n}\n \n", "/***************\n功能：输入密码\n返回值：整型的密码值\n技术说明：\n（1）此功能在多个模块中都要用到且功能单一，故分离出来，单独作业一个函数\n（2）为了便于在输入中只显示*，接受输入时以字符形式输入，而后转为对应的整型数\n（3）规定密码由不全为0的6位数字构成（当开头是'0'时，实际不足6位），一旦输入错误将重新输入\n附：在实际的系统中，密码通常用字符串描述，即使只允许出现数字字符，本例仅作为参考\n****************/", "\n", "int", " ", "inputPassword", "()", "\n", "{\n    ", "char", " ch;  ", "//接收字符形式密码", "\n    ", "int", " iPass=", "0", ";   ", "//要转换为数字", "\n    ", "int", " i;\n    ", "while", "(", "1", ")\n    {\n        ", "for", "(i=", "0", "; i<", "6", "; i++)\n        {\n            ch=", "getch", "();  ", "//输入但不显示", "\n            ", "putchar", "(", "'*'", ");   ", "//输出*", "\n            ", "if", "(", "isdigit", "(ch))\n                iPass=iPass*", "10", "+(ch-", "'0'", ");\n            ", "else", "\n            {\n                iPass=", "0", ";\n                ", "break", ";  ", "//退出for循环后，再次接受", "\n            }\n        }\n        ", "fflush", "(stdin); ", "//清除键盘缓存区中已经有的输入", "\n        cout<<endl;;\n        ", "if", "(iPass==", "0", ")  ", "//此条件成立可能由两种情况引起：输入了非数字字符被直接重置为0，或6位全0后正常退出for循环", "\n        {\n            cout<<", "\"密码要求全为数字，且不能全0！\"", "<<endl;;\n            cout<<", "\"请重新输入密码: \"", ";\n        }\n        ", "else", "\n            ", "break", ";\n    }\n    ", "return", " iPass;\n}\n \n", "void", " ", "ctime", "()", "\n    ", "{\n        tm *year;    ", "//年", "\n        tm *month;   ", "//月", "\n        tm *day;     ", "//日", "\n        tm *hour;    ", "//时", "\n        tm *minute;  ", "//分", "\n        tm *second;  ", "//秒", "\n        ", "time_t", " t;\n        t=", "time", "(", "0", ");\n        year   = ", "localtime", "(&t);\n        month  = ", "localtime", "(&t);\n        day    = ", "localtime", "(&t);\n        hour   = ", "localtime", "(&t);\n        minute = ", "localtime", "(&t);\n        second = ", "localtime", "(&t);\n        ", "ofstream ", "outfile", "(", "\"yw.txt\"", ",ios::app)", ";\n        ", "if", "(!outfile)                          ", "//测试文件打开操作是否成功，不成功则提示后退出。", "\n        {\n            cerr<<", "\"open error!\"", "<<endl;\n            ", "exit", "(", "1", ");\n        }\n        outfile<<(year ->tm_year+", "1900", ")<<", "\"年\"", "  ", "//返回的是今年减1900,所以要加上1900", "\n               <<(month->tm_mon+", "1", ")<<", "\"月\"", "     ", "//因为Month (0 – 11; January = 0),所以要加1", "\n               <<day   ->tm_mday<<", "\"日\"", "\n               <<hour  ->tm_hour<<", "\"时\"", "\n               <<minute->tm_min<<", "\"分\"", "\n               <<second->tm_sec<<", "\"秒\"", ";\n    }\n\n", "\n", "user.cpp", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "\"head.h\"", "\n", "using", " ", "namespace", " std;\n \n", "/***************\n*功能：对用户进行赋值\n*输入参数：无\n*输出参数：无\n*返回值：无\n*其他说明：无\n****************/", "\n", "void", " ", "User::setUser", "(", "int", " acc, string nam, string xid,string xaddr,", "int", " pw, ", "double", " bal,", "int", " sta)", "\n", "{\n    account=acc;\n    name=nam;\n    cid=xid;\n    address=xaddr;\n    password=pw;\n    balance=bal;\n    status=sta;\n}\n \n", "/***************\n*功能：显示姓名\n*输入参数：无\n*输出参数：name  //string型\n*返回值：无\n*其他说明：无\n****************/", "\n", "void", " ", "User::showName", "()", "\n", "{\n    cout<<", "\"户主姓名：\"", "<<name<<endl;\n}\n \n", "/***************\n*功能：显示余额\n*输入参数：无\n*输出参数：balance  //double型\n*返回值：无\n*其他说明：无\n****************/", "\n", "void", " ", "User::showBalance", "(string prompt)", "\n", "{\n    cout<<prompt<<", "\" \"", "<<balance<<", "\" 元\"", "<<endl;\n}\n \n", "/***************\n*功能：显示家庭住址\n*输入参数：无\n*输出参数：address   //string型\n*返回值：无\n*其他说明：无\n****************/", "\n", "void", " ", "User::showaddress", "()", "\n", "{\n    cout<<", "\"家庭住址：\"", "<<address<<endl;\n}\n \n", "/***************\n*功能：显示身份证号\n*输入参数：无\n*输出参数：cid   //string型\n*返回值：无\n*其他说明：无\n****************/", "\n", "void", " ", "User::showid", "()", "\n", "{\n    cout<<", "\"身份证号：\"", "<<cid<<endl;\n}\n \n", "/***************\n*功能：验证密码正误\n*输入参数：无\n*输出参数：无\n*返回值：返回1，成功\n          返回0，失败\n*其他说明：无\n****************/", "\n", "bool", " ", "User::passwordIsRight", "()", "\n", "{\n    ", "int", " iPass;\n    ", "bool", " right = ", "true", ";\n    cout<<", "\"输入密码：\"", ";\n    iPass=", "inputPassword", "();\n    ", "if", "(iPass!=password)\n    {\n        right = ", "false", ";\n        cout<<", "\"输入密码错误，不能继续操作！\"", "<<endl;\n    }\n    ", "return", " right;\n}\n \n", "/***************\n*功能：判断用户当前状态\n*输入参数：无\n*输出参数：normal //bool型\n*返回值：true：0-正常；false：1-挂失  2-销户 3-冻结\n*其他说明：无\n****************/", "\n", "bool", " ", "User::isNormalUser", "()", "\n", "{\n    ", "bool", " normal = ", "true", ";\n    ", "if", "(status!=", "0", ")\n    {\n        normal = ", "false", ";\n        cout<<", "\"该账户处于\"", ";\n        ", "if", "(status==", "2", ")\n            cout<<", "\"销户状态，不能继续操作...\"", "<<endl;\n    }\n    ", "return", " normal;\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "[color=blue][b]在《Struts2 in Aciton》一书中，描述了这样的过程(5.3.1)：\r\n\r\n首先，从HTTP中获得参数date = xyz;\r\n\r\n然后，OGNL根据参数的key（这里是“date”），定位到RegisterAction.setAge属性\r\n\r\n接着，调用内部的converters，“xyz”别转成字符串类型\r\n\r\n最后，通过反射得到set方法，传入参数时，出错了！\r\n\r\n\r\n如果，你以 月/日/年  的方式（比如 23/07/2010），后台就会正确的识别！！是因为在上述的第3步，内部转换器，根据字符串“23/07/2010”，将其转成了Date类型。\r\n\r\n\r\n我的猜测（仅是猜测）：\r\n\r\nStruts内部的转换器，不是按目标类型来转换的。而是 根据参数更像什么而转化的。\r\n\r\n比如“abcd” 默认转成 String ； “1234”默认转成 Integer、String2种类型；等等。[/b][/color]", "Konwledge_Point": "赋值时的自动类型转换", "Question": ["Struts2 输入校验错误！", ["我把一个“xyz”字符串输入本应输入的Date类型，结果报错", "\n我理解的错误校验的过程：", "\nStruts2 把“xyz”自动进行类型转换到Date，不能转换成功！报错！", "\n然后它就不应该再把“xyz”字符串赋值给setDate（）方法了。", "\n可是居然报错了！", "\n谁能告诉我怎么搞的？", "\n\n", "我的html：", "\n[code=\"java\"]", "/s:textfield", "/s:password", "/s:password", "/s:textfield", "/s:form", "\n[/code]", "\nRegisterAction.java的主要代码", "\n[code=\"java\"]", "\npublic Date getDate() {", "\n        return date;", "\n    }", "\n\n", "public void setDate(Date date) {\n    this.date = date;\n}\n", "\n\n", "public String register() throws Exception {", "\n        System.out.println(\"register() invoked\");", "\n        return SUCCESS;", "\n    }", "\npublic void validateRegister() {", "\nSystem.out.println(\"validateRegister() invoked\");", "\n}", "\n[/code]", "\n报错：", "\njava.lang.NoSuchMethodException: com.jwx.struts.action.RegisterAction.setAge([Ljava.lang.String;)", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1206)", "\n    at ognl.OgnlRuntime.setMethodValue(OgnlRuntime.java:1454)", "\n    at ognl.ObjectPropertyAccessor.setPossibleProperty(ObjectPropertyAccessor.java:85)", "\n    at ognl.ObjectPropertyAccessor.setProperty(ObjectPropertyAccessor.java:162)", "\n    at com.opensymphony.xwork2.ognl.accessor.ObjectAccessor.setProperty(ObjectAccessor.java:28)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor.setProperty(CompoundRootAccessor.java:65)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at ognl.ASTProperty.setValueBody(ASTProperty.java:127)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.Ognl.setValue(Ognl.java:737)", "\n    at com.opensymphony.xwork2.ognl.OgnlUtil.setValue(OgnlUtil.java:198)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:161)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:149)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.setParameters(ParametersInterceptor.java:276)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:187)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:94)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:235)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:89)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:130)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:267)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:126)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:138)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:165)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:52)", "\n    at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:488)", "\n    at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)", "\n    at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)", "\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)", "\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)", "\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)", "\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)", "\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)", "\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)", "\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)", "\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)", "\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849)", "\n    at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)", "\n    at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454)", "\n    at java.lang.Thread.run(Thread.java:619)", "\n--------------------------------------/", "\n2010-3-25 14:23:12 com.opensymphony.xwork2.util.logging.commons.CommonsLogger warn", "\n警告: Error setting expression 'date' with value '[Ljava.lang.String;@ae6a99'", "\nognl.MethodFailedException: Method \"setDate\" failed for object com.jwx.struts.action.RegisterAction@af7016 [java.lang.NoSuchMethodException: com.jwx.struts.action.RegisterAction.setDate([Ljava.lang.String;)]", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1265)", "\n    at ognl.OgnlRuntime.setMethodValue(OgnlRuntime.java:1454)", "\n    at ognl.ObjectPropertyAccessor.setPossibleProperty(ObjectPropertyAccessor.java:85)", "\n    at ognl.ObjectPropertyAccessor.setProperty(ObjectPropertyAccessor.java:162)", "\n    at com.opensymphony.xwork2.ognl.accessor.ObjectAccessor.setProperty(ObjectAccessor.java:28)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor.setProperty(CompoundRootAccessor.java:65)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at ognl.ASTProperty.setValueBody(ASTProperty.java:127)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.Ognl.setValue(Ognl.java:737)", "\n    at com.opensymphony.xwork2.ognl.OgnlUtil.setValue(OgnlUtil.java:198)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:161)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:149)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.setParameters(ParametersInterceptor.java:276)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:187)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:94)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:235)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:89)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:130)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:267)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:126)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:138)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:165)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:52)", "\n    at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:488)", "\n    at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)", "\n    at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)", "\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)", "\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)", "\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)", "\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)", "\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)", "\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)", "\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)", "\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)", "\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849)", "\n    at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)", "\n    at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454)", "\n    at java.lang.Thread.run(Thread.java:619)", "\nCaused by: java.lang.NoSuchMethodException: com.jwx.struts.action.RegisterAction.setDate([Ljava.lang.String;)", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1206)", "\n    ... 64 more", "\n/-- Encapsulated exception ------------\\", "\njava.lang.NoSuchMethodException: com.jwx.struts.action.RegisterAction.setDate([Ljava.lang.String;)", "\n    at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1206)", "\n    at ognl.OgnlRuntime.setMethodValue(OgnlRuntime.java:1454)", "\n    at ognl.ObjectPropertyAccessor.setPossibleProperty(ObjectPropertyAccessor.java:85)", "\n    at ognl.ObjectPropertyAccessor.setProperty(ObjectPropertyAccessor.java:162)", "\n    at com.opensymphony.xwork2.ognl.accessor.ObjectAccessor.setProperty(ObjectAccessor.java:28)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor.setProperty(CompoundRootAccessor.java:65)", "\n    at ognl.OgnlRuntime.setProperty(OgnlRuntime.java:2225)", "\n    at ognl.ASTProperty.setValueBody(ASTProperty.java:127)", "\n    at ognl.SimpleNode.evaluateSetValueBody(SimpleNode.java:220)", "\n    at ognl.SimpleNode.setValue(SimpleNode.java:301)", "\n    at ognl.Ognl.setValue(Ognl.java:737)", "\n    at com.opensymphony.xwork2.ognl.OgnlUtil.setValue(OgnlUtil.java:198)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:161)", "\n    at com.opensymphony.xwork2.ognl.OgnlValueStack.setValue(OgnlValueStack.java:149)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.setParameters(ParametersInterceptor.java:276)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:187)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:195)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:75)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:94)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:235)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:89)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ScopedModelDrivenInterceptor.intercept(ScopedModelDrivenInterceptor.java:130)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.debugging.DebuggingInterceptor.intercept(DebuggingInterceptor.java:267)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:126)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:138)", "\n    at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:87)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:165)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:179)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:176)", "\n    at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:237)", "\n    at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:52)", "\n    at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:488)", "\n    at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:77)", "\n    at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:91)", "\n    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)", "\n    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)", "\n    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)", "\n    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)", "\n    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)", "\n    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)", "\n    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)", "\n    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)", "\n    at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849)", "\n    at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)", "\n    at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454)", "\n    at java.lang.Thread.run(Thread.java:619)"]], "Tag": "程序设计"}
