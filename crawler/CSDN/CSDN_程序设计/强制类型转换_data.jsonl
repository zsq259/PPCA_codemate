{"Answer": "&lt;p&gt;不能这样转&amp;#xff0c;左边的类型&amp;#xff0c;定义成什么样&amp;#xff0c;后面赋值时不能再修改了&amp;#xff01;&amp;#xff01;&lt;br /&gt;类型转换都是右边的改&amp;#xff0c;与左边对齐。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["赋值左边不能强制类型转换吗", ["int类型的变量，赋值的时候不能强制类型转换成float类型，赋值左边不能强制类型转换吗", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;动态转换类型&amp;#xff0c;可以写个工具类来实现&amp;#xff0c;代码参考如下&amp;#xff1a;&lt;br /&gt;参数传入要转换的实例和目标类型&amp;#xff0c;返回转换为目标类型的实例。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T &lt;span class=\"hljs-title function_\"&gt;convert&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;span class=\"hljs-built_in\"&gt;Object&lt;/span&gt; obj, Class&amp;lt;T&amp;gt; &lt;span class=\"hljs-keyword\"&gt;var&lt;/span&gt;&lt;/span&gt;) {\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; (T) obj;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Java动态强制类型转换", ["Java怎么实现动态的类型转换。", "\n", "简单的来说就是一个对象需要转换为另一种类型，我知道要转换的类型class，但是要把这个class写成动态的。", "\n", "看下面伪代码，是我想要达到的效果：", "\n", "Object", " obj = ", "new", " ", "Student", "();\n\n\n", "public", " ", "void", " ", "cast", "(", "Object", " obj, Class clazz", "){\n    clazz result =  (clazz)obj;\n    ", "// 动态类型 实例 = （动态类型强制转换）obj;", "\n}\n", "\n", "就是我是明确知道要转换的类型class，但是不能直接写出来，需要动态的去绑定。这个要怎么去实现。"]], "Tag": "程序设计"}
{"Answer": "泛型类型的擦除问题，\r\n\r\n编译器会自动插入强制类型转换！", "Konwledge_Point": "强制类型转换", "Question": ["相同类型的强制类型转换是否会被触发？", ["对一个看似简单的问题疑惑不解，希望有大牛可以解答详细原理：", "\n\n", "代码如下：", "\n\n", "[code=\"java\"]", "\nString a = \"javaeye\";", "\nString b = (String)a; ", "\n[/code]", "\n\n", "[list]", "\n[*]不知道这样做是否会发生强制类型转换？", "\n[*]", "\n[*]如果会发生，是否和不同类型间（如继承关系）的强制类型转换步骤一致？", "\n[/list]", "\n\n", "多谢了。", "\n[b]问题补充：[/b]", "\n那么这样会强制类型转换吗？", "\n\n", "[code=\"java\"]", "\npublic class Simple", "\n{", "\n    private T type;", "\n\n", "public T getType()\n{\n    return type;\n}\n\n@SuppressWarnings(\"unchecked\")\npublic <M> void setType2(M type)\n{\n    this.type = (T)type;\n}\n\npublic static void main(String[] args)\n{\n    String typer = \"vvvvvvv\";\n\n    Simple<String> aSimple = new Simple<String>();\n\n    aSimple.setType2(typer);\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "这样会发生强制类型转换吗？"]], "Tag": "程序设计"}
{"Answer": "粘过来的，Java类型转换\r\n(1)boolean类型不参与转换\r\n\t(2)默认转换\r\n\t\tA:从小到大\r\n\t\tB:byte,short,char --&gt; int   long   float  double\r\n\t\tC:byte,short,char之间是平级的，不相互转换，直接转成int类型参与运算。\r\n\t(3)强制转换\r\n\t\tA:从大到小\r\n\t\tB:可能会有精度的损失，一般不建议这样使用。\r\n\t\tC:格式：\r\n\t\t\t目标数据类型 变量名 = (目标数据类型) (被转换的数据);\r\n\r\nA:下面两种方式有区别吗?\r\n\t\t\tfloat f1 = 12.345f;\r\n\t\t\tfloat f2 = (float)12.345;向下类型转换，浮点数默认是double类型\r\n\tB:下面的程序有问题吗，如果有，在哪里呢?\r\n\t\t\tbyte b1 = 3;\r\n\t\t\tbyte b2 = 4;\r\n\t\t\tbyte b3 = b1 + b2;\r\n\t\t\tshort s1=3;\r\n\t\t\tshort s2=3;\r\n\t\t\tshort s3=s1+s2;\r\n\t\t\tchar c1=3;\r\n\t\t\tchar c2=4;\r\n\t\t\tchar c3=c1+c2;\r\nbyte、short、char在运算时，会自动向上转型为int型，所以返回的结果是int类型，而返回值的类型均不是int，由于类型不匹配，所以报错\r\n\t\t\tbyte b4 = 3 + 4;\r\n\t\t\tshort s=3+4; \r\n\t\t\t常量进行计算后的值，预编译时能够判断其是否超出范围\r\n\t\t\tint a=1;\r\n\t\t\tint b=2;\r\n\t\t\tint c=a+b;\r\n\t\t\tlong l1=3l;\r\n\t\t\tlong l2=3l;\r\n\t\t\tlong l3=l1+l2; \r\n\t\t\tfloat f1=2.3f;\r\n\t\t\tfloat f2=2.3f;\r\n\t\t\tfloat f3=f1+f2;\r\n\t\t\tdouble d1=3.7;\r\n\t\t\tdouble d2=3.9;\r\n\t\t\tdouble d3=d1+d2;\r\n\t\t\t均不会报错，因为整数常用，java进行了优化。", "Konwledge_Point": "强制类型转换", "Question": ["java中强制类型转换的问题", ["作为初学者，我想验证下强制类型转换后能否输出的问题，不在乎是否丢失精度哈，写了下面一段代码，为什么一输出就报错呢？", "\npublic class QiangZhiZhuanHuan1", "\n{", "\n    public static void main(String[] args)", "\n    {", "\n        int a=12;", "\n        byte b=13;", "\n        byte c=(byte)a+b;", "\n        System.out.println(c);", "\n    }", "\n}", "\n改成下面这样才不会出错：", "\npublic class QiangZhiZhuanHuan1", "\n{", "\n    public static void main(String[] args)", "\n    {", "\n        int a=12;", "\n        byte b=13;", "\n        byte c=(byte)(a+b);", "\n        System.out.println(c);", "\n    }", "\n}", "\n\n", "有点不太明白，变量b已经在前面定义为byte类型啦，什么在进行强制转换时候还需要对（a+b）的结果进行转换，我直接对a进行强制类型转换成byte类型，然后再和b相加不行吗？"]], "Tag": "程序设计"}
{"Answer": "String类型进行比较的话，用equals，建议换成   if( \"1\".equals(name) &amp;&amp;  \"1\".equals(passwd)){", "Konwledge_Point": "强制类型转换", "Question": ["session.getAttribute方法强制类型转换不成功", ["我用(String)session.getAttribute（）的方法对session中的内容进行强制转换，", "\n转换出来的数据在控制台上可以正常显示，但是一放到条件判断语句中就无法和", "\n条件的字符进行匹配，好像类型不对一样，这是什么原因？求大神帮忙看下", "\n\n", "<%\n        //这里强制类型转换\n        String name = (String)session.getAttribute(\"username\");\n        String passwd =(String)session.getAttribute(\"passwd\");\n\n        if(name != null && passwd != null){\n\n        /*下面的name和passwd判断就总是进else，感觉name和passwd\n        就不是String类型*/\n\n            if(name == \"1\" && passwd == \"1\"){\n                out.print(\"<script type='text/javascript'>alert('登陆成功！');</script>\");\n                System.out.print(name+\"  \"+passwd);\n                response.sendRedirect(\"../admin/AdminMain.jsp\");\n            }\n            else{\n                out.print(\"<script type='text/javascript'>alert('用户名或密码错误，请重试！');</script>\");\n\n                System.out.print(name+\"  \"+passwd);\n                response.sendRedirect(\"../admin/login.jsp\");\n            }\n        }else\n            out.print(\"请登录,<a href = '../admin/login.jsp'>点击此处</a>跳转到登录页面......\");\n\n%>\n"]], "Tag": "程序设计"}
{"Answer": "看你的send返回的是什么类型。java规定，从抽象往具体转换，需要强制转换操作，反之不需要。\r\n举例：\r\nsend返回“中国人”类型，你用“人”接收，不需要转换。你用“北京人”接收，需要转换。假设它们的继承关系是 人-中国人-北京人", "Konwledge_Point": "强制类型转换", "Question": ["这句话等号右面是强制类型转换吗?", ["Map map111 = (Map) send(map);这句话等号右面是强制类型转换吗?"]], "Tag": "程序设计"}
{"Answer": "Convert的这个转换不单单是类型转换，主要是内容转换。     因为这种转换不是强制转换，你要考虑它的精度问题。\r\n另外，你发现 Convert.ToInt32 有很多重载版本，例如 Convert.ToInt32(double value);，当我们用这个版本来把一个 double 转换成 int 时，ToInt32 会检查被转换的数值是否能够用 int 表示，即是否会发生“越界”，如果是就会抛出 OverflowException，否则就会为你转换，但使用 (int) 进行强制转换，如果被转换的数值大于 Int32.MaxValue，那么你将得到一个错误的结果", "Konwledge_Point": "强制类型转换", "Question": ["有关c#的强制类型转换", ["采用Convert类来实现转换，该类基本支持所以类型之间的转换", "\nstring str=”100〃;", "\nint i = Convert.ToInt(str);", "\n注意:str除掉引号的类型必须和Convert.*的类型一致。如果将100改成100.78,即变成float类型，运行时将会报错”输入字符串的格式不正确.*", "\n为什么100改为100.78就不行了？"]], "Tag": "程序设计"}
{"Answer": "函数的返回值规定的类型为int啊", "Konwledge_Point": "强制类型转换", "Question": ["一个数组在函数的内部进行强制类型转换，在返回后是什么类型呢；", ["今天了做个题目：", "\n\n", "编写一个函数，不用临时变量，直接交换numbers = [a, b]中a与b的值。", "\n\n", "示例：", "\n\n", "输入: numbers = [1,2]", "\n\n", "输出: [2,1]", "\n\n", "\nint* swapNumbers(int* numbers, int numbersSize, int* returnSize){\n             *returnSize=2;\n            numbers=(long long)numbers;\n            numbers[0]=numbers[0]+numbers[1];\n            numbers[1]=numbers[0]-numbers[1];\n            numbers[0]=numbers[0]-numbers[1];\n            return  numbers;\n}\n", "\n\n", "因为在使用int 型做时会发生溢出，我就将int 转换成long long 但是结果任然为溢出。 是因为函数的返回值规定的类型为int，有将long long 转化为 int 还是其它的原因？ 希望有懂的大神解释一下。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;String value &amp;#61; box.getSelectedItem().toString();&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["JAVA swing ，泛型，强制类型转换", ["package", " SwingPractic;\n\n", "import", " javax.swing.*;\n", "import", " java.awt.event.ActionEvent;\n", "import", " java.awt.event.ActionListener;\n\n", "public", " ", "class", " ", "MyFrame06", " ", "extends", " ", "JFrame", " {\n    JComboBox<String> box = ", "new", " ", "JComboBox", "<>();\n\n    ", "public", " ", "MyFrame06", "()", "{\n        ", "this", ".setSize(", "500", ",", "500", ");\n        ", "this", ".setVisible(", "true", ");\n        ", "JPanel", " ", "panel", " ", "=", " ", "new", " ", "JPanel", "();\n        ", "this", ".setContentPane(panel);\n\n        panel.add(box);\n        box.addItem(", "\"用户\"", ");\n        box.addItem(", "\"管理员\"", ");\n\n        ", "JButton", " ", "button", " ", "=", " ", "new", " ", "JButton", "(", "\"test\"", ");\n        panel.add(button);\n        button.addActionListener(", "new", " ", "ActionListener", "() {\n            ", "@Override", "\n            ", "public", " ", "void", " ", "actionPerformed", "(ActionEvent e)", " {\n                test();\n            }\n        });\n    }\n\n    ", "private", " ", "void", " ", "test", "()", " {\n        ", "//int count = box.getItemCount();", "\n        ", "String", " ", "value", " ", "=", " (String) box.getSelectedItem();\n        System.out.println(value);\n    }\n\n}\n\n\n\n", "\n", "test()方法中String value = (String)box.getSelectedItem()可以替换为不含强制类型转化的代码吗?"]], "Tag": "程序设计"}
{"Answer": "指针，是指向一块内存区域的标识。如何使用这块内存，由指针的类型决定。\r\n例如：指针指向一块内存区域（以 Byte 为单位）的内容是：1 2 3 4 时，如果指针是 BYTE* 类型，则分四次可以取完全部内容；如果指针是 int * ，则一次就取完全部的内容。\r\n如果是 void* 时，编译则不知道应该如何对指针所指向区域的数据进行处理，一般都会转换为一个系统定义或用户自定义的类型。然后，按转换后的类型进行取值。", "Konwledge_Point": "强制类型转换", "Question": ["关于C语言结构体指针类型的强制转换（求大神详细解答）", [" #include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n    string dna;\n    int count;\n}DNA;\nDNA dna[101];\n**int cmp(const void *a,const void *b)\n{\n    DNA *aa = (DNA *)a;\n    DNA *bb = (DNA *)b;\n    return aa->count-bb->count;\n}**\nint main()\n{\n    int n,m;\n    char c;\n    cin>>n>>m;\n    for(int i = 0; i < m; i++)\n    {\n        cin>>dna[i].dna;\n        dna[i].count = 0;\n        for(int j = 0; j < n; j++)\n        for(int k = j+1; k < n; k++)\n        {\n            if(dna[i].dna[j]>dna[i].dna[k])\n            dna[i].count++;\n        }\n    }\n    qsort(dna,m,sizeof(dna[0]),cmp);\n    for(int i = 0; i < m; i++)\n    cout<<dna[i].dna<<endl;\n    return 0;\n}\n", "\n\n", "加粗体部分是指针类型强制转换，但是我不明为什么，求大神详细解答"]], "Tag": "程序设计"}
{"Answer": "使用astype方法，如：\r\ntmp=tmp.astype('int')", "Konwledge_Point": "强制类型转换", "Question": ["如何将Series转换城int格式", ["在python，如何将Series中的数据转换成int格式"]], "Tag": "程序设计"}
{"Answer": "java中任何子类都可以转成父类（一般子类中的东西会比父类多，所以这是做减法，只要把不是父类中的东西保存一下，是父类的就直接放在父类，\r\n所以子类转父类可以实现）。\r\n\r\n父类转子类就需要讨论了\r\n1.如果这个父类就是来源于new出来的父类，本身就没有子类中任何信息，这时候父类是不能强转子类的（毕竟子类的东西多，父类并不能把子类的数据\r\n补全）。\r\n\r\n2.如果这个父类的实例就是子类强转过来，这时候这个父类就可以在转为子类，因为子类在转父类时子类相关数据并没有丢失。\r\n\r\n\r\n```\r\npublic void run(){\r\n\t\t\r\n\t\tA a = new A();\r\n\t\ta.a=1;\r\n\t\t\r\n\t\tObject o = a;//子类转父类\r\n\t\t\r\n\t\tA b = (A)o;//还可以转回子类\r\n\t\tSystem.out.println(b.a);\r\n\t\t\r\n\t\tObject o1 = new Object();\r\n\t\tA c = (A)o1;//这时就会报错,提示不能强转\r\n\t\t\r\n\t\tSystem.out.println(c.a);\r\n\t}\r\n \r\n```\r\n\r\n相信上面已经把java父子类之间的转换将明白了。\r\n\r\n如果你的Object的实例来源跟Tuple类没有关系，那就不能强转，你只能自己手动new Tuple(),并且把相关参数设置进去。\r\n\r\n存手打，望采纳。\r\n有不明白的地方可以 继续交流", "Konwledge_Point": "强制类型转换", "Question": ["java中如何将Object类型的数据强制转换为tuple类型的？", ["Object [] parg = {input , //测试数据", "\n        \"F:\\shuju\\model.txt\" , // 调用训练模型", "\n        \"F:\\shuju\\jieguo2.txt\" }; //预测结果  ", "\n\n", "    我把tuple类型的数据input和String类型的数据同时放在object数组中，现在我要用数组中的input，我怎么能把object类型的数据强制转换为tuple类型？\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个涉及到C&amp;#43;&amp;#43;对象内存模型&amp;#xff0c;建议你去找一下有本老外写的书看看。&lt;br /&gt;多继承时&amp;#xff0c;比如D多继承了A和B&amp;#xff0c;但B并没有继承自A&amp;#xff0c;那么D的内存模型里&amp;#xff0c;A在最前(按继承顺序A在前)&amp;#xff0c;B在中间&amp;#xff0c;D本身定义的成员在最后&amp;#xff0c;也即AB是D的一部分&amp;#xff0c;对D对象取地址时&amp;#xff0c;自然是得到整个对象的首地址&amp;#xff0c;转成A&lt;em&gt;时不会有变化&amp;#xff0c;但转成B&lt;/em&gt;时&amp;#xff0c;因为B并不继承自A也即B是不包含A的成员的&amp;#xff0c;所以必然会发生地址偏移&amp;#xff0c;把A的部分偏移掉&amp;#xff0c;才能指向B那部分的首地址。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["指针通过强制类型转换以后，指针中的值 也就是地址会发生变化吗？", ["指针通过强制类型转换以后，指针中的值 也就是地址会发生变化吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;uchar是无符号字节类型&amp;#xff0c;如果直接赋值给double报错的话&amp;#xff0c;只需要强行转换就可以了&lt;/p&gt;\n\n&lt;p&gt;uchar a &amp;#61; 10;&lt;/p&gt;\n\n&lt;p&gt;double d &amp;#61; (double)a;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C++中double类型的值怎么赋值给uchar类型？", ["做图像处理的时候，要对每个像素的灰度值进行变换，读取的灰度值是uchar的，但是计算结果是double型的，怎么赋值啊", "\n\n", " "]], "Tag": "程序设计"}
{"Answer": "String是object的子类，在父子关系上，父类的引用是指向一个子类实例则可以通过强制转化将父类引用转化为子类引用，而对于父类的引用能指向一个子类实例是因为java里面的隐含了自动转换，但是引用是指向父类的一个实例而不是一个子类实例的时候，这种向下转换则不能完成，因此运行时报错。", "Konwledge_Point": "强制类型转换", "Question": ["请教一个数组类型强制转换的基本问题", ["[code=\"java\"]", "\nObject[] obj = {\"t1\",\"t2\"};", "\nString[] str1   = (String[])obj;", "\nSystem.out.println(str1.length);", "\n[/code]", "\n这段代码能编译，但是运行报错，不能强制转换。为什么？诚心请教！", "\n\n", "System.out.println(obj[0].getClass());能得到class java.lang.String", "\n\n", "obj中两个类型既然都知道是String为什么不能强制转换，如果数组不能强制转换，为什么编译不报错。", "\n\n", "把Object[] obj = {\"t1\",\"t2\"};     （这个obj类型是java.lang.Object）", "\n\n", "用Object[] obj = new String{\"t1\",\"t2\"};替换是可以运行。", "\n\n", "（这样obj类型是java.lang.Object）是不是与这个有关系。", "\n\n", "[b]问题补充：[/b]", "\n用Object[] obj = new String{\"t1\",\"t2\"};替换是可以运行。 ", "\n\n", "（这样obj类型是java.lang.String）是不是与这个有关系。 "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以通过反射来设置实例的属性值&amp;#xff0c;具体参考&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/cestarme/article/details/6548126\" id=\"textarea_1651459530410_1651460256215_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;C#反射设置属性值和获取属性值_cestarme的博客-CSDN博客&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;        ///         /// 获取类中的属性值        ///         ///         ///         ///         public string GetModelValue(string FieldName, object obj)        {            try            {&lt;!-- --&gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/cestarme/article/details/6548126&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C#如何把一个变量转化为一个Type变量所指的类型？", ["Type A ", "=", " typeof(HorizontalLayoutGroup)", ";", "\nComponent B", "=", "GetComponent(A)", ";", "\n", "\n", "我希望B是一个HorizontalLayoutGroup类型的变量。即：", "\n", "Type A ", "=", " typeof(HorizontalLayoutGroup)", ";", "\nHorizontalLayoutGroup B", "=", "(HorizontalLayoutGroup)GetComponent(A)", ";", "\n", "\n", "这样我就可以：", "\n", "((", "HorizontalLayoutGroup", ")", "GetComponent", "(", "A", ")).childControlWidth = ", "false", ";", "\n", "\n", "但是我不希望在代码中出现【HorizontalLayoutGroup】这个词，我希望只使用A这个变量。", "因为A可能是【HorizontalLayoutGroup】，也可能是【VerticalLayoutGroup】。我不想写分类讨论，我希望能把它封装成一个函数、使用Type类型的变量作为参数。", "我该怎么做？", "即，我的核心问题是：对于本文第一段代码，我该怎么做才能把B转化为A所指向的类型？"]], "Tag": "程序设计"}
{"Answer": "当然要，给你举个例子，控件绑定id的方法findViewById方法获取到的是view，转换成子控件需要进行强转", "Konwledge_Point": "强制类型转换", "Question": ["v是View的子类，如果要把v转化为Button类，要不要强制类型转换呢", ["v是View的子类，如果要把v转化为Button类，要不要强制类型转换呢", "\n父类转换为子类是自动完成的", "\n子类转换为父类需要强制类型转换"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-java\"&gt;\npublic &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;void&lt;/span&gt; main(&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;[] args) {\n        &lt;span class=\"hljs-built_in\"&gt;Map&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-built_in\"&gt;String&lt;/span&gt;, &lt;span class=\"hljs-built_in\"&gt;Object&lt;/span&gt;&amp;gt; &lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();\n        &lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt;.put(&lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;1&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt;.put(&lt;span class=\"hljs-string\"&gt;&amp;#34;2&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt;.put(&lt;span class=\"hljs-string\"&gt;&amp;#34;3&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;3.3&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;map&lt;/span&gt;.forEach&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-params\"&gt;((k, v) -&amp;gt; {\n            System.out.println(k);\n            System.out.println(v);\n        })&lt;/span&gt;;\n\n    }\n&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["foreach怎么进行参数强转呢？", ["我现在有一个linkedhashmap数组。", "我现在想对这个数组挨个进行修改。", "我现在用foreach循环之后我发现这个数组，类型得转成map才能进行操作，所以要怎么做呢？声明foreach参数类型么？", "java，spring"]], "Tag": "程序设计"}
{"Answer": "这个要看字符串的编码，与类型定义 unsigned char 无关。\r\n字符串的编码是：ASCII 、Unicode 还是 UTF-8 或者其它格式，知道格式后，再进行必要的编码转换与识别。", "Konwledge_Point": "强制类型转换", "Question": ["字符数组强制转换问题", ["如题，QT下， unsigned char pMsg[192];", "\n数组pMsg中有汉字有数字，该怎么样来提取出数组中的汉字，", "\n求指点，"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/qq_33366098/article/details/78137422", "Konwledge_Point": "强制类型转换", "Question": ["C++的4个强制类型转换，事实上那个返回值，对内存造成了变化了吗", ["C++的4个强制类型转换，事实上那个返回值，对内存造成了变化了吗？举个例子：", "\nclass a", "\nclass b:public a", "\nb ", "test=(b", ")new a", "\n这是不倡导的行为，但是，子类指针指向强制类型转换之后的父类对象，b指针竟然可以可以调用b自身的方法和属性，只不过并没有执行自己的构造函数罢了，想究其原因，望大神赐教，文不对题的就不要参与了，", "\n谢谢"]], "Tag": "程序设计"}
{"Answer": "上面显示的\n5\n6.2\n不就是exampleFive.print();这个的运行结果吗？不知道你想问什么", "Konwledge_Point": "强制类型转换", "Question": ["求助！！C++关于类的强制类型转换和构造函数的问题", ["C++关于类的强制类型转换和构造函数的问题", "\n为什么exampleFive不显示呢？求高手解答！！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;加了&amp;amp;表示取得是地址而不是值&amp;#xff0c;由于数组中的空间是连续的空间所以地址是连续的所以a[4]的地址减去a[0]的地址值为4&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["搞不懂了，🆘—涉及地址的类型强制转换", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;先执行(float)i&amp;#xff0c;再转换为int类型。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["请问下面类型是哪个先转换?", ["i=(int)(float)i;", "在C语言中这样的类型是怎么转换的，先后次序是什么?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你需要复习double型和int型存为二进制时是怎么存的&lt;br /&gt;当以%d形式输出时&amp;#xff0c;是按int型输出的&lt;br /&gt;不是类型强制转换&amp;#xff0c;仅仅是4个字节的二进制以int格式输出&amp;#xff0c;但是其实里面存的是个double型的数据&amp;#xff0c;那不乱码了吗&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["指针的强制类型转换问题", ["为什么强制类型转换之后，*pa是171798692？求解答。"]], "Tag": "程序设计"}
{"Answer": "gcc不知道你的真实意图,你的真实意图需要自己去实现.\r\ngcc怎么知道你的调用不是下面的方式?\r\n\r\nint f1(int *x);\r\n\r\nint main()\r\n{\r\nsigned char a[2], b = 0;\r\nint ab;\r\nf1(a);\r\nf1(&amp;ab);\r\n}\r\n\r\nint f1(int *x)\r\n{\r\n*x = 0xaabb;\r\nreturn 0;\r\n}", "Konwledge_Point": "强制类型转换", "Question": ["为什么gcc 对类型转换不报错？", ["比如 ", "\n\n", "int f1(int *x);", "\n\n", "int main()", "\n{", "\n    signed char a = 0, b = 0;", "\n    f1(&a);", "\n}", "\n\n", "int f1(int *x)", "\n{", "\n    *x = 0xaabb;", "\n}", "\n\n", "b 被改写为0xaa, 显然不是符合原来的意图。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这就是多态啊&amp;#xff0c;父类指针可以指向子类对象&amp;#xff0c;也就是理解成父类指针可以保存子类对象的数据。只是在语法上需要父类子类转换。至于这几种转换&amp;#xff0c;你可看看相关的博客。&lt;a href=\"https://blog.csdn.net/wildand/article/details/90049606?spm&amp;#61;1001.2101.3001.6661.1&amp;amp;utm_medium&amp;#61;distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90049606-blog-46624693.pc_relevant_paycolumn_v3&amp;amp;depth_1-utm_source&amp;#61;distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90049606-blog-46624693.pc_relevant_paycolumn_v3&amp;amp;utm_relevant_index&amp;#61;1\" id=\"textarea_1652591253578_1652591484303_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/wildand/article/details/90049606?spm&amp;#61;1001.2101.3001.6661.1&amp;amp;utm_medium&amp;#61;distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90049606-blog-46624693.pc_relevant_paycolumn_v3&amp;amp;depth_1-utm_source&amp;#61;distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-90049606-blog-46624693.pc_relevant_paycolumn_v3&amp;amp;utm_relevant_index&amp;#61;1&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;event函数这样的设计是常见的&amp;#xff0c;函数参数为父类&amp;#xff0c;即这个函数可以操作所有继承于这个父类的子类&amp;#xff0c;。&lt;br /&gt;此时这个event函数就可以操作&amp;#xff0c;鼠标事件、键盘事件、屏幕事件等等继承于QEvent的事件类型。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么Qt事件中父类可以强转为子类", ["学习qt事件过滤器时发现这样的一段码，而且能运行通过，求解答", "\n", "\n", "bool", " MyLabel::", "event", "(QEvent* e)\n{\n    ", "//鼠标左键按下，拦截", "\n    ", "if", "(e", "->", "type", "() == QEvent::MouseButtonPress)\n    {\n        QMouseEvent* ev = static_cast<QMouseEvent*>(e);\n        QString ", "str", " = ", "QString", "(", "\"Event函数中,鼠标按下了  x = %1  y = %2\"", ").\\\n                ", "arg", "(ev", "->", "x", "()).", "arg", "(ev", "->", "y", "());\n\n        ", "qDebug", "() << ", "str", ";\n        ", "return", " ", "true", ";\n    }\n\n    ", "//其它事件交给父类处理", "\n    ", "return", " QLabel::", "event", "(e);\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;就是将变量类型强行转换为其它类型&lt;br /&gt;比如 double a &amp;#61; 10.25;&lt;br /&gt;int b &amp;#61; (int)a;&lt;br /&gt;这样b就是10了&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["强制类型转换是什么？", ["强制类型转换是什么呢？在百度上搜没看懂", "   ，=_％+<<", "@?{＋。{）^xbdcnfxvndxcvbfzxbfxxbfscbfxcb}}>>，(补字数)"]], "Tag": "程序设计"}
{"Answer": "加这两行在TestBean tb1 = (TestBean)JSONSerializer.toJava(jo1); 前面试试\r\n\r\nnet.sf.json.JsonConfig jsonConfig = new net.sf.json.JsonConfig();\r\njsonConfig.setRootClass(TestBean.class);", "Konwledge_Point": "强制类型转换", "Question": ["将json对象转化为java对象？", ["TestBean tb = new TestBean();", "\ntb.setName(\"闫燕飞\");", "\ntb.setSex(\"男\");", "\nList list = new ArrayList();", "\nlist.add(\"mother\");", "\nlist.add(\"father\");", "\ntb.setParentName(list);", "\n//将一个实体类对象转化为json对象", "\nJSONObject jo1= JSONObject.fromObject(tb);", "\n\n", "//将json对象转化为java对象(这里编译通过，执行的时候报异常)", "\nTestBean tb1 = (TestBean)JSONSerializer.toJava(jo1);", "\n\n", "异常：Exception in thread \"main\" java.lang.ClassCastException: net.sf.ezmorph.bean.MorphDynaBean cannot be cast to com.second.TestBean"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;看到这个问题&amp;#xff0c; 你可能对float 或者double 不熟悉。&lt;br /&gt;你强制转换可以&amp;#xff0c;你可以这样&amp;#xff1a;&lt;br /&gt;printf(&amp;#34;%d&amp;#34;, (int)n);&lt;br /&gt;或者可以这样&amp;#xff1a;&lt;br /&gt;int temp &amp;#61; &amp;#xff08;int&amp;#xff09;n;&lt;br /&gt;但是你不要将n 强制转换后&amp;#xff0c;又赋值给float&amp;#xff0c;float 的内存存储&amp;#xff0c;跟int 是不一样的&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c语言关于强制类型转换的问题", ["\n", "请问为什么我强制类型转换为int后输出结果是0而不是2？为什么之后我把第9行改为", "    printf(\"%f\",n);后又能输出2？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n   &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;  a &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;;\n   &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; b &amp;#61; (&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)a;&lt;span class=\"hljs-comment\"&gt;//隐式转换&lt;/span&gt;\n   &lt;span class=\"hljs-comment\"&gt;//类型的转换  所需要的类型和给的类型不匹配,需要转换&lt;/span&gt;\n   &lt;span class=\"hljs-comment\"&gt;//强制转换  (需要转的类型)原来的数据类型&lt;/span&gt;\n   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)&lt;span class=\"hljs-number\"&gt;3.14&lt;/span&gt;);\n   &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%lf\\n&amp;#34;&lt;/span&gt;,(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt;)a);\n   &lt;span class=\"hljs-built_in\"&gt;system&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;pause&amp;#34;&lt;/span&gt;);\n   &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;高效学习C语言可以看我的主页或者专栏 &lt;a href=\"https://blog.csdn.net/gzplyx?type&amp;#61;blog\" id=\"textarea_1671109874631_1671109993307_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/gzplyx?type&amp;#61;blog&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["强制类型转换是什么样的，该怎么敲代码", ["自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“通人性”，可能不能满足所有的需求。那么强制类型转换是什么？"]], "Tag": "程序设计"}
{"Answer": "对象也可以强制类型转换，但是能否转换成功取决于：\r\n转换的目标类型必须是对象的实际类型或者它的基类类型；\r\n或者，转换的类型实现了显式强制类型转换运算符。", "Konwledge_Point": "强制类型转换", "Question": ["link中为什么变量可以强制类型转换，但是对象就不可以？", ["link中为什么变量可以强制类型转换，但是对象就不可以？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;-0可以用在字符型数字转为数字类型&amp;#xff0c;&amp;#43;空字符用于转字符类型&amp;#xff0c;已经typeof判断都是同一个类型了还做这个操作感觉没什么意义&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["有关克隆函数里的强制类型转换问题", ["想请问各位一个小问题 ！", "图片的克隆函数中（见图片的划线部分），判断出为 ”number“ 或者 ”string“ 类型了，赋给新变量时，为什么还要减 ”0“ 或者 加空字符串。", "即这里的强制类型转换是为了防止什么问题。", "求解答", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;A&lt;br /&gt;能被编译&lt;br /&gt;出警告而已&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["用malloc做动态内存分配是不是要强制类型转换？", ["片段复制下来我的电脑编译不了。而且我看没有强制类型转换，直接选了D。", "\n", "\n", "这道题是不是出错了？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"453\" src=\"https://img-ask.csdnimg.cn/upload/1607069457514.png\" width=\"747\" /&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["double转String类型报错For input string", ["double distance=0.1;", "\n\n", "String.valueOf(distance)+\"km\";", "\n\n", "这样写就会报java.lang.NumberFormatException: For input string", "\n\n", "但是改成String.valueOf(distance)+\"1\";这样的数字或者空字符串，空格就不会报错"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;This is because a variable of &lt;em&gt;static&lt;/em&gt; type &lt;code&gt;Nexter&lt;/code&gt; (which is just an interface) may hold values of many different &lt;em&gt;dynamic&lt;/em&gt; types.&lt;/p&gt;\n\n&lt;p&gt;Yes, since &lt;code&gt;*Node&lt;/code&gt; implements &lt;code&gt;Nexter&lt;/code&gt;, your &lt;code&gt;p&lt;/code&gt; variable &lt;em&gt;may&lt;/em&gt; hold a value of type &lt;code&gt;*Node&lt;/code&gt;, but it may hold &lt;em&gt;other types&lt;/em&gt; as well which implement &lt;code&gt;Nexter&lt;/code&gt;; or it may hold &lt;em&gt;nothing&lt;/em&gt; at all (&lt;code&gt;nil&lt;/code&gt; value). And &lt;a href=\"https://golang.org/ref/spec#Type_assertions\" rel=\"noreferrer\"&gt;Type assertion&lt;/a&gt; cannot be used here because quoting from the spec:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;code&gt;x.(T)&lt;/code&gt; asserts that &lt;code&gt;x&lt;/code&gt; is &lt;strong&gt;not &lt;code&gt;nil&lt;/code&gt;&lt;/strong&gt; and that the value stored in &lt;code&gt;x&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;But &lt;code&gt;x&lt;/code&gt; in your case is &lt;code&gt;nil&lt;/code&gt;. And if the type assertion is false, &lt;strong&gt;a run-time panic occurs&lt;/strong&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you change your program to initialize your &lt;code&gt;p&lt;/code&gt; variable with:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var p Nexter = (*Node)(nil)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Your program will run and type assertion succeeds. This is because an interface value actually holds a pair in the form of: &lt;code&gt;(value, dynamic type)&lt;/code&gt;, and in this case your &lt;code&gt;p&lt;/code&gt; will not be &lt;code&gt;nil&lt;/code&gt;, but will hold a pair of &lt;code&gt;(nil, *Node)&lt;/code&gt;; for details see &lt;a href=\"http://blog.golang.org/laws-of-reflection#TOC_3.\" rel=\"noreferrer\"&gt;The Laws of Reflection #The representation of an interface&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;If you also want to handle &lt;code&gt;nil&lt;/code&gt; values of interface types, you may check it explicitly like this:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;if p != nil {\n    n = p.(*Node) // will not fail IF p really contains a value of type *Node\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or better: use the special \"comma-ok\" form:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;// This will never fail:\nif n, ok := p.(*Node); ok {\n    fmt.Printf(\"n=%#v\n\", n)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Using the \"comma-ok\" form:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;The value of &lt;code&gt;ok&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; if the assertion holds. Otherwise it is &lt;code&gt;false&lt;/code&gt; and the value of &lt;code&gt;n&lt;/code&gt; is the zero value for type &lt;code&gt;T&lt;/code&gt;. &lt;strong&gt;No run-time panic occurs in this case.&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["将nil接口转换为Golang中某物的指针？", ["\n\n", "In the following code piece, trying to convert a nil interface to a pointer of something fails with the following error: ", "interface conversion: interface is nil, not *main.Node", "\n\n", "type Nexter interface {\n    Next() Nexter\n}\n\ntype Node struct {\n    next Nexter\n}\n\nfunc (n *Node) Next() Nexter {...}\n\nfunc main() {\n    var p Nexter\n\n    var n *Node\n    fmt.Println(n == nil) // will print true\n    n = p.(*Node) // will fail\n}\n", "\n\n", "Play link here: ", "https://play.golang.org/p/2cgyfUStCI", "\n\n", "Why does this fail exactly? It's entirely possible to do ", "\n\n", "n = (*Node)(nil)\n", "\n\n", ", so I'm wondering how can you achieve a similar effect starting from a nil interface.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;数字默认int类型&amp;#xff0c;char&amp;amp;int&amp;#xff0c;最后是int&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C语言中的隐式强制类型转换问题", ["当两个数据类型不同的变量在进行逻辑运算时，会进行怎样的类型转换操作？", "\n\n", "如 char a;", "\n\n", "a & (1<<2) = ?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;if(48&amp;lt;&amp;#61;t&amp;lt;&amp;#61;57)改为&lt;br /&gt;if(48&amp;lt;&amp;#61;t &amp;amp;&amp;amp; t  &amp;lt;&amp;#61;57)&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c+ +强制类型转换后不能进行判断", ["问题", "\n", "c++强制类型转换后不能进行判断", "\n", "代码", "\n", "c++", "\n", "#", "include", "<iostream>", "\n", "#", "include", "<string>", "\n", "using", " ", "namespace", " std;\n", "void", " ", "judge", "(string a,", "int", " n)", "{\n    ", "int", " j,t;\n    \n    ", "for", "(j=", "0", ";j<n;j++){\n        t=a[j];\n        ", "//if(a[i]<='9'&&a[i]>='0')", "\n        cout<<t<<", "\" \"", ";\n        ", "if", "(", "48", "<=t<=", "57", ")\n        {\n        cout<<a[j]<<", "\" \"", ";    \n        }\n        ", "else", "{\n            cout<<", "\" \"", ";\n        }\n        \n    }\n}\n\n", "int", " ", "main", "()", "{\n    string a;\n    ", "int", " n;\n    cin>>a;\n    n=a.", "length", "();\n    ", "judge", "(a,n);\n    ", "return", " ", "0", ";\n    }\n\n\n\n", "\n", "运行结果及报错内容", "\n", "\n", "转换成int类型的t输出检验都是正确的，已将转成int，但是输出结果来看并没有进行if条件的判断,都直接输出了。", "\n", "尝试过的方法", "\n", "如果不进行转换直接换成对于字符的对比判断就没有错if(a[i]<='9'&&a[i]>='0')", "\n", "问题", "\n", "为什么转换后的判断失灵了"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;a href=\"https://golang.org/ref/spec\" rel=\"nofollow noreferrer\"&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"https://golang.org/ref/spec#Expressions\" rel=\"nofollow noreferrer\"&gt;Expressions&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;An expression specifies the computation of a value by applying\n  operators and functions to operands. &lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"https://golang.org/ref/spec#Conversions\" rel=\"nofollow noreferrer\"&gt;Conversions&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;Conversions are expressions of the form T(x) where T is a type and x\n  is an expression that can be converted to type T. &lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"https://golang.org/ref/spec#Address_operators\" rel=\"nofollow noreferrer\"&gt;Address operators&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;For an operand x of type T, the address operation &amp;amp;x generates a\n  pointer of type *T to x. The operand must be addressable, that is,\n  either a variable, pointer indirection, or slice indexing operation;\n  or a field selector of an addressable struct operand; or an array\n  indexing operation of an addressable array. As an exception to the\n  addressability requirement, x may also be a (possibly parenthesized)\n  composite literal. If the evaluation of x would cause a run-time\n  panic, then the evaluation of &amp;amp;x does too.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;Expressions are temporary, transient values. The expression value has no address. It may be stored in a register. A comversion is an expression. For example,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    type str string\n    s := \"hello, world\"\n    fmt.Println(&amp;amp;s, s)\n\n    // error: cannot take the address of str(s)\n    sp := &amp;amp;str(s)\n    fmt.Println(sp, *sp)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;main.go:13:8: cannot take the address of str(s)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;To be addressable a value must be persistent, like a variable. For example,&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    type str string\n    s := \"hello, world\"\n    fmt.Println(&amp;amp;s, s)\n\n    ss := str(s)\n    sp := &amp;amp;ss\n    fmt.Println(sp, *sp)\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;0x1040c128 hello, world\n0x1040c140 hello, world\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么我无法在Go中获得类型转换的地址？", ["\n\n", "When I compile this code, the compiler tells me that I ", "cannot take the address of str(s)", ".", "\n\n", "func main() {\n    s := \"hello, world\"\n    type str string\n    sp := &str(s)\n}\n", "\n\n", "So my question is whether a ", "type conversion", " may look for a new address to locate the current new ", "s", ", or something else that I haven't thought of?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;java的byte数据类型类似于C/C&amp;#43;&amp;#43;的char类型&amp;#xff0c;取值都是[-128,127],也就是一个字节 &amp;#xff0c;8bite&amp;#xff0c;&lt;strong&gt;而且在计算机内存当中负数都是以补码的形式存在的&lt;/strong&gt;&amp;#xff0c;所以-128&amp;#xff08;byte&amp;#xff09;在内存当中是1000 0000 &amp;#xff08;反码0111 1111 &amp;#43; 1&amp;#xff09; 而且第一位是符号位。int类型4个字节&amp;#xff0c;32bite.&lt;/p&gt;\n\n&lt;p&gt;&lt;strong&gt;重点就是&amp;#xff0c;int在强制转成byte&amp;#xff08;c&amp;#43;&amp;#43;的char&amp;#xff09;的时候会强制截断&amp;#xff0c;也就是说32bite的int类型只要最后8bite&amp;#xff01;&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/strong&gt;&lt;/p&gt;\n\n&lt;p&gt;所以1200&amp;#61;100 1011 0000&amp;#xff08;前面还有0我没写&amp;#xff09;&amp;#xff0c;在截断之后变成了1011 0000。然后再看我上面讲的&amp;#xff0c;byte是有符号位的&amp;#xff0c;所以第一位是符号位1&amp;#xff0c;表示负数&amp;#xff0c;1011 0000是一个负数&amp;#xff0c;然后后面的就是补码转成原码的过程了。&lt;/p&gt;\n\n&lt;p&gt;补码&amp;#61;反码&amp;#43;1 &amp;#61;&amp;#xff08;原码取反&amp;#xff09;&amp;#43;1  所以推理得到&lt;/p&gt;\n\n&lt;p&gt;原码&amp;#61;&amp;#xff08;补码-1&amp;#xff09;再取反。&lt;/p&gt;\n\n&lt;p&gt;1011 0000-1&amp;#61;1010 1111 取反&amp;#61;0101 0000&amp;#61;80。然后最重要的是&amp;#xff0c;这个数是个负数&amp;#xff0c;所以有&amp;#xff1a;&lt;/p&gt;\n\n&lt;p&gt;1200 &amp;#61;-80&lt;/p&gt;\n\n&lt;p&gt;搞清楚原理之后&amp;#xff0c;还有个简单的计算方法&amp;#xff0c;那就是对256进行取模&amp;#xff0c;看结果是不是在[-128,127]之间&amp;#xff0c;如果不在&amp;#xff0c;那么要再减去256就是最终的结果。&lt;/p&gt;\n\n&lt;p&gt;比如1200%256&amp;#61;176&amp;gt;127.所以176-256&amp;#61;-80.&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["大佬帮忙解释下这里的强制类型转换是怎么把1200变成-80的？", ["大佬帮忙解释下这里的强制类型转换是怎么把1200变成-80的？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为byte类型再相加的时候&amp;#xff0c;会自动转换成int类型&amp;#xff0c;右边的int类型赋值给byte类型便会报错&amp;#xff0c;加上强制类型转换可以通过编译。比如byte c&amp;#61; (byte)(a&amp;#43;b);&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["一个关于byte类型赋值的基础问题", ["\nbyte ", "a", "=1;\nbyte ", "b", "=2;\nbyte ", "c", "=a+b;//无法通过编译\nbyte ", "d", "=1+2;//可以通过编译\n"]], "Tag": "程序设计"}
{"Answer": "&lt;h2 id=\"h2_首先题主的代码应该是想表现成这样吧&amp;#xff1a;_1662359211526\"&gt;首先题主的代码应该是想表现成这样吧&amp;#xff1a;&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p &amp;#61; &lt;span class=\"hljs-built_in\"&gt;realloc&lt;/span&gt;(&lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;40&lt;/span&gt;);\n    p[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    p[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;] &amp;#61; &lt;span class=\"hljs-number\"&gt;12&lt;/span&gt;;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i &amp;lt; n; &amp;#43;&amp;#43;i)\n        &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d\\n&amp;#34;&lt;/span&gt;,p[i]);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code class=\"language-javascript\"&gt;realloc&lt;/code&gt; 函数返回的是一个 &lt;code class=\"language-javascript\"&gt;void *&lt;/code&gt;的指针&amp;#xff0c;在 &lt;code class=\"language-javascript\"&gt;c&lt;/code&gt;语言中&amp;#xff0c;可以不用强制转换&amp;#xff0c;直接使用&amp;#xff0c;但是在&lt;code class=\"language-javascript\"&gt;C&amp;#43;&amp;#43;&lt;/code&gt;就不行&amp;#xff0c;而且为了养成一个良好的编码习惯&amp;#xff0c;还是建议写上强制转换~&lt;/p&gt;\n&lt;p&gt;在C&amp;#43;&amp;#43;中会出现以下报错&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/66329195326611.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["relloct使用时为什么不用强制类型转换？", ["如。 ing", "p=realloc（NULL，40）；", "realloct前为什么可以不加（int", "）进行强转？"]], "Tag": "程序设计"}
{"Answer": "伪代码如下:\r\nClass&lt;User&gt; clazz=java.lang.reflect.Method.getParameterTypes() \r\nUser user=clazz.cast(person);\r\n\r\n封装了一个简单的方法如下:\r\npublic static &lt;T&gt; T cast(Class&lt;T&gt; clazz, Object obj) {\r\n\t\treturn clazz.cast(obj);\r\n\t}\r\n测试如下:\r\nObject str = new String(\"test\");\r\n\t\tString s = cast(String.class, str);\r\n\t\tSystem.out.println(s);\r\n注意处理clazz.cast(obj)的ClassCastException.", "Konwledge_Point": "强制类型转换", "Question": ["java强制类型转换括号里面的是个什么东西？", ["比如(User)person，要把person对象转化成User类型，", "\n现在这个User类型是通过java.lang.reflect.Method.getParameterTypes() 反射获取的 Class<?>[]", "\n请问一下大家这个强制类型转化怎么写？"]], "Tag": "程序设计"}
{"Answer": "http://zhidao.baidu.com/link?url=eihpOQRSHW7f_5I8pUK4lRVncRYacvQ2Dqw5RIYV7kbymjJL6KvKXd0-hBjKG95-QlmO_DPr4Nu58hQGthsrSqoOYSZWHvjZOt_zrk42PWy", "Konwledge_Point": "强制类型转换", "Question": ["用android viewPager出现的强转异常", ["用一个页面切换到另外一个页面出现了异常", "\n02-19 19:56:32.645: E/GED(11205): Failed to get GED Log Buf, err(0)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205): FATAL EXCEPTION: main", "\n02-19 19:56:37.141: E/AndroidRuntime(11205): Process: com.example.shuyannvshen, PID: 11205", "\n02-19 19:56:37.141: E/AndroidRuntime(11205): java.lang.ClassCastException: com.viewpagerindicator.CirclePageIndicator$SavedState cannot be cast to android.widget.HorizontalScrollView$SavedState", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.widget.HorizontalScrollView.onRestoreInstanceState(HorizontalScrollView.java:1667)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.view.View.dispatchRestoreInstanceState(View.java:14030)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3018)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.view.ViewGroup.dispatchRestoreInstanceState(ViewGroup.java:3024)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.view.View.restoreHierarchyState(View.java:14008)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.support.v4.app.Fragment.restoreViewState(Fragment.java:449)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:964)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.support.v4.app.FragmentManagerImpl.moveToState(FragmentManager.java:1121)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.support.v4.app.BackStackRecord.run(BackStackRecord.java:682)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:1484)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.support.v4.app.FragmentManagerImpl$1.run(FragmentManager.java:450)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.os.Handler.handleCallback(Handler.java:815)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.os.Handler.dispatchMessage(Handler.java:104)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.os.Looper.loop(Looper.java:194)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at android.app.ActivityThread.main(ActivityThread.java:5691)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at java.lang.reflect.Method.invoke(Native Method)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at java.lang.reflect.Method.invoke(Method.java:372)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:959)", "\n02-19 19:56:37.141: E/AndroidRuntime(11205):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:754)"]], "Tag": "程序设计"}
{"Answer": "动作还是慢了，为了确保能拿到这分，其实你的DaoFactory可以再完善一点\r\n\r\npublic class DaoFactory {   \r\n       \r\n    private DaoFactory(){}   \r\n    private static DaoFactory instance = new DaoFactory();   \r\n       \r\n    public static DaoFactory getinstance(){   \r\n        return instance;             \r\n    }   \r\n       \r\n       \r\n    public &lt;T&gt; T createDao(Class&lt;T&gt; clazz){   \r\n           \r\n        try {   \r\n            return  (T) Class.forName(clazz.getName).newInstance();  \r\n        } catch (Exception e) {   \r\n            throw new RuntimeException(e);   \r\n        }   \r\n    }   \r\n}", "Konwledge_Point": "强制类型转换", "Question": ["强制类型转换问题", ["[code=\"java\"]CategoryDao dao = new CategoryDaoImpl();[/code]很好理解", "\n\n", "但是下面代码我几有点迷惑了", "\n[code=\"java\"]package cn.factory;", "\n\n", "import cn.dao.CategoryDao;", "\nimport cn.dao.impl.CategoryDaoImpl;", "\nimport cn.domain.Category;", "\n\n", "public class DaoFactory {", "\n\n", "private DaoFactory(){}\nprivate static DaoFactory instance = new DaoFactory();\n\npublic static DaoFactory getinstance(){\n    return instance;          \n}\n\n\npublic <T> T createDao(String classname,Class<T> clazz){\n\n    try {\n        T t = (T) Class.forName(classname).newInstance();\n        return t;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "\n\n", "}[/code]", "\n\n", "不用泛型", "\n[code=\"java\"]", "\npublic CategoryDao createCategoryDao(String classname){", "\n\n", "    try {\n        CategoryDao dao = (CategoryDao) Class.forName(classname).newInstance();\n        return dao;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    } \n\n}\n", "\n\n", "[/code]", "\n\n", "得到实例", "\n[code=\"java\"]", "\nCategoryDao dao = DaoFactory.getinstance().createDao(\"cn.dao.impl.CategoryDaoImpl\",CategoryDao.class);", "\n//CategoryDao dao = DaoFactory.getinstance().createDao(\"cn.dao.impl.CategoryDaoImpl\");", "\n[/code]", "\n\n", "很明显Class.forName(classname).newInstance()得到是接口实现类为什么还需要强转", "\n\n", "想了很久[code=\"java\"]CategoryDao dao = new CategoryDaoImpl();[/code]两个感觉矛盾了  :cry: .", "\n求解...  :oops: "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;字符‘k’的ASCII码值&amp;#xff0c;是107&lt;br /&gt;c2是char型的&amp;#xff0c;赋值322溢出了322-256&amp;#61;66&amp;#xff0c;ASCII码66的是字符‘B’&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c语言强制类型转换问题", ["\n\n", " ", "\n为什么第一a为什么是107，是等级低了吗\n最后c2为什么是B,"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在getchar()前面加个 (char)。&lt;br /&gt;还有&amp;#xff0c;第8行&amp;#xff0c;&amp;amp;&amp;amp;的两个条件最好就加上括号()&amp;#xff0c;要考虑到优先级的问题。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["这种如何强制类型转换", ["如何解决这类的问题啊最近刚学还是有点不清楚，在c=getchar()前面加个(int)了还是不行"]], "Tag": "程序设计"}
{"Answer": "浮点数存在精度误差，而int并不是四舍五入，而是仅仅单纯舍去尾数。\r\n最好写\r\nint t2 = (int)(num * 100 + 0.5);", "Konwledge_Point": "强制类型转换", "Question": ["CodeBlocks强制类型转换，求大神", ["\n\n", "图中num = 0.12，乘100后等于12，怎么强制转换成int就是11了？求大神"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, &amp;amp;n);\n\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (n &amp;lt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n        n &amp;#61; -n;\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; temp &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n\n    &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (n &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        temp &amp;#61; temp * &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt; &amp;#43; n % &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n        n /&amp;#61; &lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;;\n    }   \n\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;, temp);\n\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n } \n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["网络工程大一强制类型转换", ["从键盘任意输入一个3位数，编程计算并输出它的逆序数（忽略整数前的正负号）。例如输入-123，则忽略负号，由123分离出其百位1，十位2，个位3，然后计算3×100+2×10+1=321，并输出321。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;sum&amp;#43;&amp;#61;1/i&amp;#xff0c;应该改为sum &amp;#43;&amp;#61; 1.0/i&lt;br /&gt;因为1和i都是整数&amp;#xff0c;相除是进行整除&lt;br /&gt;因为while开始时i&amp;#43;&amp;#43;&amp;#xff0c;所以在累加前i值已经是2&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["计算机二级C语言强制类型转换", ["\n", "他是不是搞错了，应该把sum初始化为0.0或者把i初始化为2！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&amp;#xff08;int&amp;#xff09;5.2/2.5 和 &amp;#xff08;int&amp;#xff09;&amp;#xff08;5.2/2.5&amp;#xff09;&lt;br /&gt;&amp;#xff08;int&amp;#xff09;表示将一个其他数字类型强制转换为int类型&amp;#xff0c;在转换时&amp;#xff0c;会要只保留整数&amp;#xff0c;注意&amp;#xff0c;它不像我们的数学会四舍五入&amp;#xff0c;它会直接去掉小数点后面部分&lt;br /&gt;所以这里&amp;#xff0c;&amp;#xff08;int&amp;#xff09;5.2会变成5&amp;#xff0c;&amp;#xff08;int&amp;#xff09;2.5会变成2&lt;br /&gt;&amp;#xff08;int&amp;#xff09;&amp;#xff08;5.2/2.5&amp;#xff09;这里&amp;#xff0c;Java里面括号优先执行&amp;#xff0c;5.2/2.5&amp;#61;2.08&amp;#xff0c;强制去掉小数点后为2&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["java中的强制类型转换疑问", ["（int）5.2/2.5   和   （int）（5.2/2.5） 的各自的结果有无区别？ 或是无法计算？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;转int后除以了一个浮点数&amp;#xff0c;又会变成浮点数&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["int不是强制类型转换吗，不是没小数吗", []], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;PHP is loosely typed and does not require you to declare a variable type when declaring a variable. You can’t change that behavior with a magic &lt;code&gt;php.ini&lt;/code&gt; directive. &lt;/p&gt;\n\n&lt;p&gt;The benefit of having “loose typing” is that it allows for flexibility. It allows you to create dynamic applications without having to worry about the type of the variable – PHP makes this possible by &lt;em&gt;not&lt;/em&gt; enforcing variable types.&lt;/p&gt;\n\n&lt;p&gt;However, if you &lt;em&gt;must&lt;/em&gt; convert a variable into a particular format, just cast it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$int   = (int) $foo;\n$str   = (string) $foo;\n$bool  = (bool) $foo;\n$float = (float) $foo;\n...\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;There are functions to do the same, e.g. &lt;a href=\"http://php.net/intval\" rel=\"nofollow\"&gt;&lt;code&gt;intval()&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"http://php.net/strval\" rel=\"nofollow\"&gt;&lt;code&gt;strval()&lt;/code&gt;&lt;/a&gt;, &lt;a href=\"http://php.net/boolval\" rel=\"nofollow\"&gt;&lt;code&gt;boolval()&lt;/code&gt;&lt;/a&gt; – all of them do the same task, but a function is very useful when you want to use it as a callback to another function.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["你能用PHP强制类型转换吗？", ["\n\n", "I have been doing some research online and it appears that the answer to my question is no, but I realize there are times when I might miss something or search for something incorrectly. I know in languages like C++, when a variable is declared it can be declared as int or string. Is it possible to force this in PHP?", "\n\n", "For Example:", "\n\n", "<?php\n(int)$var = 5;\n?>\n", "\n\n", "will be validated and not cause an error in PHP, but:", "\n\n", "<?php\n$var = 5;\n?>\n", "\n\n", "will cause an error because it was not cast as a type string, int, object, etc...", "\n\n", "I know PHP is loosely typed so this may not be an option, however I would like to use it that way I ensure that I sanitize data appropriately and improve readability by letting others know exactly what is going on with the code. I am hoping there is a way to enforce this in the php.ini file or to load it in a script that will always be executed by my program.", "\n\n", "Thank you for any help you can offer! ", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为你输出的是%d&lt;br /&gt; 所以是5       【望采纳】&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C需要初学者关于强制类型转换的疑惑", ["float后a＋b不就是float型了嘛？那么不就等于3.5然后加2不就等于5.5了嘛？我哪里错了，求答案。", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;double(a*b)这样的写法只能把结果转换成double类型&lt;br /&gt;&amp;#xff08;(double)a&amp;#xff09; * &amp;#xff08;(double)b&amp;#xff09;这个才是先转成double类型再计算&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么我的强制类型转换符时好时坏", ["\n", "我明明加了（double）为什么它就是输出的数最后都有个2，就是达不到书上的要求……"]], "Tag": "程序设计"}
{"Answer": "子类的引用转换为超类的引用是不会出现问题的，属于向前转型\r\n因为子类本身就属于超类，是is a的关系，但是调用staff[0] = new Employee(...) 的操作的时候，\r\n实际上staff这个数组指向的是Manager的数组，而这个new只会将employee对象中的属性初始化，然而去调用manager[0]的时候，\r\n我们知道manager[0]实际上不是Manager对象而是Employee对象，这个对象是没有setBonus这个方法的，但是因为我们使用的引用是manager，也就是第一行创建的Manager[]数组，这里就会发生向后转型\r\n但是超类的集合是小于子类的集合的，导致超类部分已经被初始化，而子类部分没有被初始化，\r\n因此调用超类没有的setBonus实际上是对Employee对象的调用，而这个对象根本没有这部分", "Konwledge_Point": "强制类型转换", "Question": ["在java中,子类数组的引用可以转换成超类数据的引用,而不需要采用强制类型转换.", ["\n上面标记的拿个不存在的实例域是啥意思,其他的我都能看懂"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;强制类型转化是最优先的。a强制类型转换后变为1。&lt;br /&gt;1➗2.0&amp;#61;0.5&lt;br /&gt;存入int型变量i中&amp;#xff0c;由于i只能存整数&amp;#xff0c;就变为了0。&lt;br /&gt;例如&lt;br /&gt;&amp;#xff08;int&amp;#xff09;0.8&amp;#61;0&lt;br /&gt;&amp;#xff08;int&amp;#xff09;1.2&amp;#61;1&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c语言中强制类型转换和四则运算运算的顺序是什么？", ["问题遇到的现象和发生背景", "\n", "这个应该要怎么进行运算？运算的顺序是什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Use the &lt;code&gt;(*BaseType)()&lt;/code&gt; &lt;a href=\"https://golang.org/ref/spec#Conversions\" rel=\"noreferrer\"&gt;type conversion&lt;/a&gt; to convert a &lt;code&gt;*LabeledType1&lt;/code&gt; and &lt;code&gt;*LabeledType2&lt;/code&gt; to a &lt;code&gt;*BaseType&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func handle(evt interface{}) error {\n    switch e := evt.(type) {\n    case *LabeledType1:\n        return handleBaseEvent((*BaseType)(e))\n    }\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/lhvW2Y2Hk_X\" rel=\"noreferrer\"&gt;Run it on the playground&lt;/a&gt;.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["将变量分配给“标签”类型，或如何在指针之间键入强制类型转换", ["\n\n", "I have two identical structures, which for disambiguation purposes have different types:", "\n\n", "type BaseType struct {\n   id  uint64\n   name string\n}\n\ntype LabeledType1 BaseType\ntype LabeledType2 BaseType\n", "\n\n", "There is one function in the whole chain which actually doesn't care about the ", "LabeledType", ", it just works with the ", "BaseType", " (because it does the exact same thing with both). The sender of the event has to send the labeled type, not the base type, because the actual type defines some post-behavior.", "\n\n", "func handle(evt interface{}) error {\n  switch e := evt.(type) {\n  case *LabeledType1: \n    return handleBaseEvent(e)\n  case *LabeledType2:\n    return handleBaseEvent(e)\n  //there are other types\n  case *OtherType:\n      return handleOtherType(e)\n  } \n}\n\nfunc handleBaseEvent(evt *BaseType) {\n   //do stuff\n}\n", "\n\n", "Now of course this doesn't compile:", "\n\n", "cannot convert e (type *LabeledType1) to type BaseType\n", "\n\n", "But I wonder, both types are ", "assignable", " as far as I understand that concept, so there should be some easy conversion? I've tried type casting: ", "\n\n", "evt.(BaseType)", ") ", "\n\n", "and also ", "\n\n", "BaseType(e)", "\n\n", "I can't use a ", "bool", " inside ", "BaseType", ".", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不能这样转&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;imageSwitcher.&lt;span class=\"hljs-title function_\"&gt;setFactory&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;ViewSwitcher&lt;/span&gt;.&lt;span class=\"hljs-title class_\"&gt;ViewFactory&lt;/span&gt;() {\n    &lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;View&lt;/span&gt; &lt;span class=\"hljs-title function_\"&gt;makeView&lt;/span&gt;(&lt;span class=\"hljs-params\"&gt;&lt;/span&gt;) {\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;;\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["这个强制类型转换是哪里有问题吗，是它的包有问题吗", [" 问题遇到的现象和发生背景", "\n", "\n", " 问题相关代码，请勿粘贴截图", "setfactory这个方法是这样写的不，我按照书上来的，不知道咋报错了，图片切换类就是这样写的呀", " 运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这里哪里有16进制转换成10进制了&lt;br /&gt;你只做了数据类型转换&amp;#xff0c;并没有做进制转换啊&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C++强制转换出现警告", ["C++就行数组转换输出中，就行强制转换由16进制转换为10进制输出出现警告⚠️，一共三个语句出现了六个警告。", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;变量和内存不能这样理解。a&amp;#61;(double)a后a还是int类型&amp;#xff0c;不会变成double类型&amp;#xff0c;这点和python不一样&amp;#xff0c;不能把python的思维带入C中来。在语言中&amp;#xff0c;如果你进行类型强转&amp;#xff0c;强转得到的值只是暂时的&amp;#xff0c;这时它其实不在内存中&amp;#xff0c;而是在CPU的寄存器里&amp;#xff0c;更不会立即写入内存。不同的是&amp;#xff0c;python可以自行保留右值的类型&amp;#xff0c;但C/C&amp;#43;&amp;#43;会隐式转换double值到整数再进行赋值。不存在跳过这种隐式转换的方法。&lt;/p&gt;\n\n&lt;p&gt;以你的a&amp;#61;(double)a为例&amp;#xff0c;CPU先从a所在的位置&amp;#xff08;当然&amp;#xff0c;这一步常常要访存&amp;#xff0c;也可能是直接从cache line读取&amp;#xff09;取出数据丢进一个能存放32位数值的寄存器里&amp;#xff08;寄存器本身是没有类型的概念的&amp;#xff0c;它存储的可以是字符&amp;#xff0c;可以是整数&amp;#xff0c;可以是float甚至是没什么意义的脏数据。赋予类型意义的是CPU指令而不是存储器&amp;#xff09;。在我的编译器上&amp;#xff0c;我看了下汇编码&amp;#xff0c;如果是O2优化&amp;#xff0c;CPU会直接把数据放进XMM寄存器&amp;#xff0c;然后调用cvtsi2ss&amp;#xff0c;cvttss2si指令进行转换。如果没有编译器优化&amp;#xff0c;CPU还要多中转几次&amp;#xff0c;但最终还是要调用这两条指令。&amp;#xff08;这是x86_64架构的结果&amp;#xff0c;其他指令集和微架构上很可能有不同做法&amp;#xff0c;但都会进行至少两条调用。&amp;#xff09;这两条调用的含义分别是有符号整数转浮点和浮点转有符号整数&amp;#xff0c;显而易见&amp;#xff0c;前者对应你写的显式强转&amp;#xff0c;后者则是C/C&amp;#43;&amp;#43;自动进行的隐式转换。&lt;/p&gt;\n\n&lt;p&gt;这种转换通常没有什么实际意义&amp;#xff0c;但是编译器似乎不会省略它们。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["关于强转后内存地址的问题", ["就是变量在内存里面是成线性排列的，但是现在我用强制类型转换，将相邻两个int型变量a，b中的a转换为double型，那a索取的内存要比原来int型多出4个字节的内存，它应该向哪里索取，毕竟旁边变量b已经占据了a 变量所需的四个字节"]], "Tag": "程序设计"}
{"Answer": "不是所有的人都是中国人。\r\n第一次 张三转换为中国人，没问题\r\n第二次，汤姆转换为中国人，不行了。\r\n你要判断下\r\nLabel lab = null;\r\nif (this.panel.Controls[j] is Label)\r\nlab = (Label)this.panel.Controls[j];", "Konwledge_Point": "强制类型转换", "Question": ["无法将类型为LiteralControl的对象强制转换为类型.Label", ["我的代码：", "\n                            int index = 0;", "\n            for ( index = 0; index < this.panel.Controls.Count; index++)", "\n            {", "\n                if (this.panel.Controls[index].ID==Session[\"vote\"].ToString())", "\n                {", "\n                    Response.Write(this.panel.Controls[index].ID);", "Label lab = (Label)this.panel.Controls[index];", "\n                    sum++;", "\n                    break;", "\n                }", "\n\n", "        }\n        int j = 0;\n        for (j=0; j < this.panel.Controls.Count; j++)\n        {\n            if (j == index + 1)\n            {\n                Response.Write(this.panel.Controls[j].ID);\n                _Label lab = (Label)this.panel.Controls[j];_\n                Response.Write(lab.ID);\n                 lab.Text = (Double.Parse(lab.Text) + 1).ToString();\n                //Response.Redirect(\"VoteResult.aspx\");\n            }\n        }\n                    问题：第一个强制转换label就没有毛病，第二个就出错，为什么？怎么解决这个问题？\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;应该是版本的问题&amp;#xff0c;虽然上面那个可以运行&amp;#xff0c;但是也会报错。最好是强制转换一下才是最安全的。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么他可以直接运行而我得强制转换指针类型才能运行？", ["\n", "第一张图是视频里的代码，第二张是我的，为什么他可以直接运行而我得强制转换指针类型才能运行？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为之前是hibernate框架换成spring boot框架，关键是加了一个热处理【devtools】&lt;/p&gt;\n\n&lt;p&gt;而为了实现热部署，Devtools原有自己的类加载器，进行更新，由于类加载器的不同导致类型转换失败。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么同一个类 不能强制转换：cannot be cast to ", []], "Tag": "程序设计"}
{"Answer": "是的，父类转换到子类自动完成，因为一个子类中包含父类的所有东西\r\n子类转父类要强制转换，因为子类中有的父类可能没有", "Konwledge_Point": "强制类型转换", "Question": ["java当中类型转换问题", ["父类对象转换为子类对象就是向下转型 程序会自动完成", "\n子类对象转换为父类对象为向上转型需要强制类型转换，我这么理解对不"]], "Tag": "程序设计"}
{"Answer": "printf(\"%f\",a); %f和a类型不一致 丢失数据", "Konwledge_Point": "强制类型转换", "Question": ["C4244：从float转换到int，可能丢失数据", ["小白，实现强制类型转换过程中出现问题", "\n\n", "按照道理出现的应该是3.000000", "\n附上代码：", "\n#include \"stdafx.h\"", "\nint main(){", "\n\n", "int a ;\nint b = 3;\na = (float)b;\nprintf(\"%f\",a);\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "你要看函数返回值里面的指针真正的值是什么，然后就知道强制类型转换是转换回什么信息", "Konwledge_Point": "强制类型转换", "Question": ["关于指针强制转换的一点疑问…………", ["\nTlsGetValue函数的返回类型是LPVOID，为什么可以用DWORD强制转换得到时间？", "\n返回的是指针的话对其使用（DWORD）不是仍得到那个地址值吗？如下所示："]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;语言执行顺序 按照你想的 应该是  a&amp;#61;int(1.99*3); 后边用括号括起来&amp;#xff0c;作为一整整体&amp;#xff0c;结果才是5&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么先进行强制类型转化然后再计算呢？", ["为什么先进行强制类型转换然后再进行运算呢？有没有人可以解答一下呢"]], "Tag": "程序设计"}
{"Answer": "后面加上 \r\n\r\n```\r\n=getlist(... ) as List&lt;Tb_Inte_role&gt;;\r\n```", "Konwledge_Point": "强制类型转换", "Question": ["asp.net一个关于隐式转换为 存在一个显式转换(是否缺少强制转换?)", ["无法将类型“System.Collections.Generic.IList”隐式转换为“System.Collections.Generic.List”。存在一个显式转换(是否缺少强制转换?)   "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你应该是要转值吧&amp;#xff0c;Convert.ToDouble(textEdit39.Text) 或者 Convert.ToDouble(textEdit39.EditValue)&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["DevExpress  TextEdit的对象强制转换", ["\n double zhi ", "=", " Convert.ToDouble(textEdit39)", ";", "\n                for (int i ", "=", " ", "0", "; i < this.gridView14.RowCount; i++)", "\n                {\n                    if (this.gridView14.IsRowSelected(i) ", "=", "=", " true)\n\n                    {\n                        //string s ", "=", " gridView14.GetDataRow(i)[", "\"值\"", "].ToString()", ";", "\n                         //this.gridView14.GetDataRow(i)[", "\"原始值\"", "]", "=", "textEdit39.Text.Trim()", ";//取选中行的ID字段的值", "\n                        this.gridView14.GetDataRow(i)[", "\"值\"", "] ", "=", " zhi", ";", "\n                      \n                    }\n                }\n", "\n", "提示错误", "System.InvalidCastException:“无法将类型为“DevExpress.XtraEditors.TextEdit”的对象强制转换为类型“System.IConvertible”。”"]], "Tag": "程序设计"}
{"Answer": "你说的强制转换发生在这步：A=&amp;B。所以两个都发生了强制转化\r\n了解一个名词：虚表。\r\nｃ＋＋的的实例都会维护一个虚表，表中的数据就是虚函数的指针，这个表在实例的最前面，你可以通过指针直接访问到这张表。\r\n有这张表就简单了，如果子类的函数覆盖掉了父类的函数，则子类实例化后的对象中，虚表中的地址就会被子类ｏｖｅｒｒｉｄｅ的函数的指针给代替\r\n这样，子类对象在访问这个虚函数时，就会根据这个新的函数地址访问到这个函数了。\r\n在让你理解一个概念，ｃ＋＋类实例化出的对象中没有函数，只有指向函数的指针。也就是说，一个类实例化出１０个对象，然后这１０个对象将要调用一个ｒｕｎ函数，实际上他们调用的是同一个ｒｕｎ函数，他们全部都有指向ｒｕｎ函数的指针", "Konwledge_Point": "强制类型转换", "Question": ["C++中关于类继承的类型转换问题", ["我的问题是：子类继承基类后，若基类中没有虚函数，都有breathe成员函数的定义这时我定义一个指向基类的指针，同时定义一个子类对象，将这个指针指向子类对象，如：animal是基类，fish是子类", "\n\n", "animal* A；fish B；A=&B;A->breathe（）；\n", "\n\n", "按书上说，是发生了强制类型转换，调用了animal中的breathe（），这个我可以理解；", "\n然后若基类中有虚函数breathe，子类中也有同名定义breathe，再执行上面的代码", "\n\n", "animal* A；fish B；A=&B;A->breathe（）；", "\n可以肯定调用的是fish中的breathe（）。是不是同样发生了类型强制转换？那么书上说，实际执行breathe时，会自动根据对象的实际类型调用相应的函数。请问这个实际类型是编译器自动保存的吗？是不是不需要我们做别的操作？", "\n请大佬解惑！谢谢！", "\n附完整代码", "\n\n", "#include<stdlib.h>\n#include<typeinfo.h>\nusing namespace std;\nclass animal\n{\npublic:\n    void eat()\n    {\n        cout<<\"animal eat\"<<endl;\n    }\n    void sleep()\n    {\n        cout<<\"animal sleep\"<<endl;\n    }\n    virtual void breath()\n    {\n        cout<<\"animal breath\"<<endl;\n    }\n};\nclass fish:public animal\n{\npublic:\n    void breath()\n    {\n        cout<<\"fish breath\"<<endl;\n    }\n};\n\nvoid fn(animal *species)\n{\n    species->breath();\n    cout<<typeid(species).name()<<endl;\n}\nvoid main()\n{\n    fish fh;\n    animal* fit;\n    fit=&fh;\n    fn(fit);\n    cout<<typeid(fit).name()<<endl;\n    //cout<<typeid(fh).name()<<endl;\n    system(\"pause\");\n}\n\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-java\"&gt;int b&amp;#61;2;\nbyte b1&amp;#61;b;//b为int变量&amp;#xff0c;无法直接赋值给byte\nbyte b2&amp;#61;2;//整数型常量且在byte范围内&amp;#xff0c;编译自动默认为byte&amp;#xff0c;通过 \nbyte b3&amp;#61;288;//超出byte范围编译不通过&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;如果把一个较小的&lt;strong&gt;整数型常量&lt;/strong&gt;&amp;#xff08;在byte或short范围内)赋值给byte或short,系统在编译时会自动将这个整数型常量当作byte或short来处理&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["关于java数据类型转换", ["我是一名java学习的初学者，我涉及到数据类型转换时有一个点把我难住了。", "\n\n", "①当要把数据范围大的数据类型赋值给数据范围小的类型的时候需要强制类型转换。", "\n\n", "所以就出现了类似 --》 int a = (int) 99.9;等表达式，那byte类型的数据范围比int类型的数据范围小，为何在赋值时不时 --》byte a = （byte）10；？而是直接的 --》 byte a = 10；呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Your &lt;code&gt;errValidation&lt;/code&gt; type and the &lt;code&gt;validator.ValidationErrors&lt;/code&gt; type are completely different, distinct types. If an interface value holds a value of concrete type &lt;code&gt;errValidation&lt;/code&gt;, you can't type assert another concrete type from it, only &lt;code&gt;errValidation&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;So this will work:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;e := ValidationError(errors.New(\"some err\"))\nif _, ok := e.(errValidation); ok {\n    fmt.Println(\"ValidationError: OK\")\n} else {\n    fmt.Println(\"ValidationError: FALSE\")\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;And output will be (try it on the &lt;a href=\"https://play.golang.org/p/yC4VBtyevNw\" rel=\"nofollow noreferrer\"&gt;Go Playground&lt;/a&gt;):&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;ValidationError: OK\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["如果包装对象，将Golang强制转换为自定义类型会失败", ["\n\n", "In my app I use ", "validator.v9", " to validate my model. After validation I can cast the ", "error", " interface and it's successes, I see 'OK' on the console", "\n\n", "err := v.ModelValidator.Struct(model)\n\nif _, ok := err.(validator.ValidationErrors); ok {\n    fmt.Println(\"ValidateModel: OK\")\n} else{\n    fmt.Println(\"ValidateModel: FALSE\")\n}\n", "\n\n", "I need to wrap this object to another one for future processing", "\n\n", "type errValidation struct {\n    error\n}\n\nfunc ValidationError(err error) error {\n    return errValidation{err}\n}\n", "\n\n", "But if I try to cast this wrapped object back to ", "validator.ValidationErrors", " in the same function just below the cast from a first case above it fails", "\n\n", "e := ValidationError(err)\nif _, ok := e.(validator.ValidationErrors); ok {\n    fmt.Println(\"ValidationError: OK\")\n} else{\n    fmt.Println(\"ValidationError: FALSE\")\n}\n", "\n\n", "I see in the console ", "\n\n", "ValidateModel: OK\nValidationError: FALSE\n", "\n\n", "How can I make this cast work from wrapped object?", "\n\n", "ValidationErrors", " from ", "\"gopkg.in/go-playground/validator.v9\"", " looks like this", "\n\n", "type ValidationErrors []FieldError\nfunc (ve ValidationErrors) Error() string {\n     //.....\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "从异常来看，你的 list 中的元素类型不是 Map 而是 String 类型的。\r\n所以还是需要检查你的封装返回的代码，保证是 List  的元素是 Map 类型才可以。", "Konwledge_Point": "强制类型转换", "Question": ["JAVA list集合内以Map格式 强制转换map怎么做？", ["我从数据库取出数据放到list中想要将list转化为Map", "\n\n", "System.out.println(list1.get(0));\n", "\n\n", "打印出来的结果是 ：uname:李华", "\n\n", "list里面是以Map的格式存在的，怎么把list强制转化为Map，使用以下代码时出错了", "\n\n", "Map maps = (Map) list1.get(0);\n", "\n\n", "Exception in thread \"main\" java.lang.ClassCastException: java.lang.String cannot be cast to java.util.Map\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n        [DisplayName(\"职称代码\")]\r\n        [MaxLength(3)]\r\n        public int TitleID { get; set; }\r\n```", "Konwledge_Point": "强制类型转换", "Question": ["无法将类型为“System.Int32”的对象强制转换为类型“System.Array”   ", ["修改Edit.cshtml上部分字段，点击保存跳转到Index.cshtml。", "\n但现在点击保存，就跳出以下错误。", "\n\n", "\n\n", "**这是Model **", "\n\n", " using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing System.Linq;\nusing System.Web;\n\nnamespace MvcSilverTalent.Models\n{\n    public class RetireeModel\n    {\n        [Key]\n        [DatabaseGeneratedAttribute(DatabaseGeneratedOption.Identity)]\n        public int RetireNum { get; set; }\n\n        [Required]\n        [DisplayName(\"单位编号\")]\n        [MaxLength(3)]\n        public string UnitID { get; set; }\n\n        [Required]\n        [DisplayName(\"员工编号\")]\n        [MaxLength(6)]\n        public string EmployeeID { get; set; }\n\n        [Required]\n        [DisplayName(\"离退休类型\")]\n        public int RetireType { get; set; }\n\n        [Required]\n        [DisplayName(\"删除标记\")]\n        public int DeleteFlag { get; set; }\n\n\n        //\n        // 基本信息\n\n\n        [Required]\n        [DisplayName(\"姓名\")]\n        [MaxLength(20)]\n        public string Name { get; set; }\n\n        [Required]\n        [DisplayName(\"性别\")]\n        public Boolean Gender { get; set; }\n\n        [Required]\n        [DisplayName(\"身份证号码\")]\n        public string IDCardNo { get; set; }\n\n        [Required]\n        [DisplayName(\"出生年月\")]\n        public DateTime Brityday { get; set; }\n\n        [Required]\n        [DisplayName(\"民族\")]\n        [MaxLength(30)]\n        public string Nationality { get; set; }\n\n        [Required]\n        [DisplayName(\"籍贯\")]\n        [MaxLength(30)]\n        public string NativePlace { get; set; }\n\n        [DisplayName(\"党派\")]\n        [MaxLength(30)]\n        public string Party { get; set; }\n\n        [DisplayName(\"所在党支部\")]\n        [MaxLength(100)]\n        public string PartyBranch { get; set; }\n\n        [DisplayName(\"最高学历\")]\n        [MaxLength(20)]\n        public string EducationDegree { get; set; }\n\n        [Required]\n        [DisplayName(\"用户组\")]\n        public string GroupName { get; set; }\n\n        [Required]\n        [DisplayName(\"是否参加爱心基金\")]\n        public Boolean HasLoveFund { get; set; }\n\n        [DisplayName(\"享受爱心基金慰问情况\")]\n        public string LoveFundCase { get; set; }\n\n        [DisplayName(\"慰问走访情况\")]\n        public string VisitCase { get; set; }\n\n\n        //\n        // 工作信息\n\n\n        [Required]\n        [DisplayName(\"参加工作时期\")]\n        public int WorkPeriod { get; set; }\n\n        [Required]\n        [DisplayName(\"参加工作时间\")]\n        public DateTime WorkTime { get; set; }\n\n        [Required]\n        [DisplayName(\"退休时间\")]\n        public DateTime RetireTime { get; set; }\n\n        [Required]\n        [DisplayName(\"工龄\")]\n        public int WorkAge { get; set; }\n\n        [Required]\n        [DisplayName(\"退休单位\")]\n        [MaxLength(100)]\n        public string UnitName { get; set; }\n\n        [DisplayName(\"职称代码\")]\n        [MaxLength(3)]\n        public int TitleID { get; set; }\n\n        [DisplayName(\"职称\")]\n        [MaxLength(30)]\n        public string Title { get; set; }\n\n        [DisplayName(\"职务\")]\n        [MaxLength(30)]\n        public string Position { get; set; }\n\n        [DisplayName(\"编制\")]\n        [MaxLength(30)]\n        public string Formation { get; set; }\n\n\n        //\n        // 可修改信息 \n\n\n        [Required]\n        [MaxLength(255)]\n        [DisplayName(\"近照\")]\n        public string PhotoUrl { get; set; }\n\n        [MaxLength(255)]\n        [DisplayName(\"特长\")]\n        public string Specialty { get; set; }\n\n        [Required]\n        [MaxLength(255)]\n        [DisplayName(\"现住地址\")]\n        public string Address { get; set; }\n\n        [MaxLength(30)]\n        [DisplayName(\"家庭电话\")]\n        public string HomeTel { get; set; }\n\n        [MaxLength(30)]\n        [DisplayName(\"手机号码\")]\n        public string MobileNum { get; set; }\n\n        [MaxLength(10)]\n        [DisplayName(\"邮政编码\")]\n        public string ZipCode { get; set; }\n\n        [MaxLength(40)]\n        [DisplayName(\"邮箱\")]\n        public string Email { get; set; }\n\n\n        public virtual ICollection<EventSignModel> EventSignModels { get; set; }\n        public virtual ICollection<HealthSignMain> HealthSignMains { get; set; }\n    }\n}\n\n", "\n\n", "**这是controller **", "\n\n", "\n        // GET: /UserInfo/Edit.cshtml\n\n        public ActionResult Edit(int RetireNum) \n        {\n            RetireeModel RetireeModel = db.RetireeModels.Find(RetireNum);\n            if (RetireeModel == null)\n            {\n                return HttpNotFound();\n            }\n            return View(RetireeModel);\n        }\n\n\n        //\n        // POST: /UserInfo/Edit.cshtml\n\n        [HttpPost]\n        [ValidateAntiForgeryToken]\n        public ActionResult Edit(RetireeModel RetireeModel)\n        {\n            Response.Write(\"<script>alert('ddddd')</script>\");\n\n            if (ModelState.IsValid)\n            {\n                db.Entry(RetireeModel).State = EntityState.Modified;\n\n                db.SaveChanges();\n                return RedirectToAction(\"Index\");\n            }\n            Response.Write(\"<script>alert('xxxx')</script>\");\n\n            return View(\"Index\");\n        }\n\n"]], "Tag": "程序设计"}
{"Answer": "C++分配内存，特别是对象的内存，建议使用new delete，不要使用malloc和free", "Konwledge_Point": "强制类型转换", "Question": ["类中的内存分配和指针类型强制转换问题", ["问题描述：", "\ntemplate //element type", "\nclass list", "\n{", "\nprivate:", "\n    EleT data;//数据本身，即是需要的信息", "\n    list* prio;//the pointer of prior element", "\n    list* next;//the pointer of next element", "\n    list* last;//the last pointer of list", "\n    int len;//the length of list", "\npublic:", "\n    list()", "\n    {", "\n        len=0;", "\n        last=prio=next=NULL;", "\n    }", "\n        void append（eleT e）", "\n        {", "\n            list* temp=(list*)malloc(sizeof(data)+ sizeof(list*))；", "\n            if（len==0)", "\n            ...", "\n            else", "\n            ...", "\n        }", "\n        }；", "\n        我这样的后续节点会存在什么问题，我自己测试过，发现在后续的使用中，是可以访问data和前后节点的属性的，但我总担心会有问题，求解觉疑惑"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; n;\n    &lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%d&amp;#34;&lt;/span&gt;,&amp;amp;n);\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%x\\n&amp;#34;&lt;/span&gt;,n);\n    &lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *p &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;unsigned&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt; *)&amp;amp;n;\n    &lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%x %x %x %x\\n&amp;#34;&lt;/span&gt;,p[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;],p[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;],p[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;],p[&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;]);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["关于指针强制转换的问题，如何解决？", ["求指教QAQ", "\n", "题目：", "无符号整数v由4个字节构成。请编程完成下述任务：", "从键盘读取一个整数，存入unsinged int v；", "以16进制格式打印v的值；", "取v的地址，并强制类型转换成unsigned char*，然后通过这个地址/指针依次打印构成v的第零个，第一个，第二个，第三个字节的16进制值。", "\n", "输入格式:", "正整数v", "\n", "输出格式:", "请参考样例", "\n", "输入样例:", "12345678", "\n", "输出样例:", "bc614e", "4e 61 bc 0", "\n", "说明：输出的第1行为无符号整数v的16进制值，第2行为构成v的四个字节各自的16进制值。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Use the following code to create a copy of the draft struct and unmarshal to it:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;t := reflect.TypeOf(methodsMap[Method(base.Method)])\npv := reflect.New(t)\nerr := json.Unmarshal(p, pv.Interface())\nreturn pv.Elem().Interface(), err  // pv.Elem() dereferences ptr \n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;a href=\"https://play.golang.org/p/H8capqmxp5\" rel=\"nofollow noreferrer\"&gt;playground example&lt;/a&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["将接口{}强制转换为运行时类型", ["\n\n", "Here is schematic example what I need:", "\n\n", "func decode(data []byte, target interface{}) (interface{}, error) {\n    decoded := target.(reflect.TypeOf(target)) // pseudocode\n    err := json.Unmarshal(data, &decoded)\n    ...\n", "\n\n", "I found several similar questions on SO, but all solutions are about switch by ", "target.(type)", ". This is not the best solution what I look for.", "\n\n", "Also I found solution with reflection:", "\n\n", "decoded := reflect.ValueOf(target).Convert(reflect.TypeOf(target))\n// fmt.Printf(\"%T\", decoded) == reflect.Value\n", "\n\n", "But I couldn't understand how to get struct from ", "reflect.Value", " to pass it to ", "json.Unmarshal", " function.", "\n\n", "How this ", "decode", " function will be used?", "\n\n", "I have multiple requests in different structures. I can determine what struct I should use to decode request. I have mapping between request type and structure like this ", "map[RequestMethod]interface{}", ".", "\n\n", "Schematic version looks like this:", "\n\n", "func hydrate(data []byte) (interface{}, error) {\n    var base baseResponse\n\n    if err := json.Unmarshal(data, &base); err != nil {\n        return nil, err\n    }\n\n    target, ok := methodsMap[Method(base.Method)]\n\n    if !ok {\n        return nil, errors.New(\"Trying to hydrate data with unknown method: \" + base.Method)\n    }\n\n    decoded, err := decode(data, target) // Expected target type.\n", "\n\n", "Added:", "\n\n", "If we pass our ", "target", " to ", "json.Unmarshal", " without casting to it type we will obtain ", "map", ". Example:", "\n\n", "func decode(data []byte, target interface{}) (interface{}, error) {\n    err := json.Unmarshal(data, &target)\n    // fmt.Printf(\"%T\", target) == map[string]interface{} not struct.\n", "\n\n", "Solution", "\n\n", "Thanks to ", "@icza", " we found solution:", "\n\n", "func hydrate(data []byte) (interface{}, error) {\n        var base baseResponse", "\n\n", "    if err := json.Unmarshal(data, &base); err != nil {\n        return nil, err\n    }\n\n    target, ok := methodsMap[Method(base.Method)]\n\n    if !ok {\n        return nil, errors.New(\"Trying to hydrate data with unknown method: \" + base.Method)\n    }\n\n    // Clone request draft struct.\n    decoded := reflect.New(reflect.ValueOf(target).Type()).Interface()\n    err := decode(data, decoded)\n    ...\n", "\n\n", "Related links:", "\n\n", "Golang interface{} type misunderstanding", "\n\n", "How to copy an interface value in Go?", "\n    "]], "Tag": "程序设计"}
{"Answer": "但是呢，我们的intel x87 cpu，内部使用的是80位精度，这意味着，中间运算的精度实际上要比double/float的精度高。但是一些编译器会用isse/avx等指令加速，而这些指令的精度就没有那么高了，所以这也是为什么不能直接比较两个浮点数的原因。因为没法保证不同环境下运算的结果精确的一致。", "Konwledge_Point": "强制类型转换", "Question": ["Java中整形向浮点类型强制转换精度丢失问题", ["这里我就以int转换为float为例。int 在内存中占用四个字节，取值范围是 -2 147 483 648 ～ 2 147 483 6487，float 在内存中占用内存同样是四个字节，取值范围 大约是正负3.40282347E+38F（有效位数6～7位），当我们将一个int整数12345678转换为float类型时，因为他包含的位数比float类型所能表达的位数多，所以会丢失精度。", "\n那么，请问此处提到的float类型的位数是不是说的flaot类型十进制下的有效位数？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;No you can't. Go is a static typed language. The type of a variable is determined at compile time.&lt;/p&gt;\n\n&lt;p&gt;If you want to determine dynamically the &lt;code&gt;type&lt;/code&gt;of an &lt;code&gt;interface{}&lt;/code&gt; you could use &lt;a href=\"http://golang.org/doc/effective_go.html#type_switch\" rel=\"noreferrer\"&gt;type switching&lt;/a&gt;: &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var t interface{}\nt = functionOfSomeType()\nswitch t := t.(type) {\ndefault:\n    fmt.Printf(\"unexpected type %T\", t)       // %T prints whatever type t has\ncase bool:\n    fmt.Printf(\"boolean %t\n\", t)             // t has type bool\ncase int:\n    fmt.Printf(\"integer %d\n\", t)             // t has type int\ncase *bool:\n    fmt.Printf(\"pointer to boolean %t\n\", *t) // t has type *bool\ncase *int:\n    fmt.Printf(\"pointer to integer %d\n\", *t) // t has type *int\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Golang：将接口动态转换为类型变量", ["\n\n", "In go, is it possible to cast variables dynamically somehow?", "\n\n", "For example, if a simple cast would be:", "\n\n", "var intAge  = interfaceAge.(int)\n", "\n\n", "What if I do not know that age is an int in advance? A simple way of writing it would be ", "\n\n", "var x = getType()\nvar someTypeAge = interfaceAge(.x)\n", "\n\n", "Is there a way of achieving something like this? The reflect package gives some ways of determining or casting a type at runtime - but I couldn't find anything like the above mentioned (a generic scheme that would work for all types). ", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;C语言中&amp;#xff0c;浮点型转整形&amp;#xff0c;都是忽略小数点后面的数&amp;#xff0c;只保留整数。跟编译器没关系。如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C++中   浮点型转化为整型是向下取整还是向零取整？", ["主要是强制类型转换部分，用常用的devcpp测试是向零取整。", "\n\n", "想知道是所有都是向零取整还是会根据编程环境不同而不同？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;void指针&amp;#xff0c;咋访问啊&amp;#xff0c;必须有类型啊&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么A是错误的？谁来详细解释一下A选项？", ["若有语句：void* p=malloc(80);,则以下叙述错误的是（）。", "\n", "A", "\n\n可以通过指针", "p", "直接访问用malloc开辟的这块内存\n", "B", "\n\n", "p", "所指内存可以通过强制类型转换当作具有", "20", "个int型元素的一维数组来使用\nC\n\n", "p", "所指内存可以通过强制类型转换当作具有", "10", "个double型元素的一维数组来使用\nD\n\n", "p", "所指内存可以通过强制类型转换当作具有", "80", "个char型元素的一维数组来使用\n"]], "Tag": "程序设计"}
{"Answer": "对象o是个变量，指向的一个对象，例如\r\nObject o = new Employee();\r\n加入我们想要调用Object类和Employee共同的成员，通过变量\"o.XXX\"形式访问就可以了，\r\n但是我们要访问Employee类中的专有成员，就需要将o转换为Employee类型\r\nEmployee e = (Employee)o;", "Konwledge_Point": "强制类型转换", "Question": ["        c#显示类型转换", ["在c#书上看到的代码,我想问这个基类变量强制转换为派生类变量是什么意思，还有有什么用，不是说基类对象不能被派生类引用吗？为什么要实现这一步。"]], "Tag": "程序设计"}
{"Answer": "clone 返回的是object类型，当然要转换了", "Konwledge_Point": "强制类型转换", "Question": ["在做JAVA的Cloneable类的题是，为什么克隆是还要显示的类型强制转换", ["在做JAVA的Cloneable类的题是，为什么克隆是还要显示的类型强制转换（在注释出）"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;You cannot cast pointers to arbitrary types in Go. If you really want to do that, you should use unsafe.Pointer:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type varAttrib1b struct {\n    vaHeader uint8\n    vaData   []string\n}\n\nfunc varAttIs1B(ptr uintptr) bool {\n    return ((*varAttrib1b)(unsafe.Pointer(ptr)).vaHeader &amp;amp; 0x01) == 0x01\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It compiles and works, but are you sure there is no safe way of doing that in go? Can't you just define an interface:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type Attr interface {\n    AttrIs1B() bool\n}\n\nfunc (b varAttrib1b) AttrIs1B() bool {\n    return b.vaHeader &amp;amp; 0x01 == 0x01\n}\n\nfunc varAttIs1B(attr Attr) bool {\n    return attr.AttrIs1B()\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Or implement it with type casts?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func varAttIs1B(ptr interface{}) bool {\n    switch a := ptr.(type) {\n    case varAttrib1b:\n        return a.vaHeader &amp;amp; 0x01 == 0x01\n    }\n    return false\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["在go lang中强制转换为结构类型", ["\n\n", "I have some c macros in the form of ", "\n\n", "#define VARATT_IS_4B(PTR) \\\n    ((((varattrib_1b *) (PTR))->va_header & 0x80) == 0x00)\n", "\n\n", "and want to convert it to Go lang. I am doing something like ", "\n\n", "func varAttIs1B(ptr uintptr) bool {\n    return (*varAttrib1b(ptr).vaHeader & 0x01) == 0x01\n}\n", "\n\n", "but yeah, it is not working and I am getting compiler error ", "\"cannot convert ptr (type int) to type varAttrib1b\"", ".", "\n\n", "varAttrib1b is a struct with two fields and ptr is a uintptr(could be some other type also). ", "\n\n", "type varAttrib1b struct {\n    vaHeader uint8\n    vaData   []string\n}\n", "\n\n", "How can I do this?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;建议用vs2008&amp;#xff0c;经典版本&amp;#xff0c;一些函数在vs2022中都已经不能使用了。&lt;br /&gt;至于你说的错误&amp;#xff0c;可以贴出代码来帮你看一下。&lt;br /&gt;如果使用了typedef&amp;#xff0c;在使用结构体的时候&amp;#xff0c;就不需要在用struct关键字了&amp;#xff0c;参考如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;typedef struct _node\n{\n    int data;\n    struct _node* next;\n}&lt;span class=\"hljs-keyword\"&gt;Node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;,*LinkNode&lt;/span&gt;;\n\nLinkNode p &amp;#61; (LinkNode)malloc(sizeof(&lt;span class=\"hljs-keyword\"&gt;Node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;)); //注意Node&lt;/span&gt;前面不需要在加struct关键字\n&lt;span class=\"hljs-keyword\"&gt;Node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;* t&lt;/span&gt; &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;Node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;*)malloc&lt;/span&gt;(sizeof(&lt;span class=\"hljs-keyword\"&gt;Node&lt;/span&gt;&lt;span class=\"hljs-title\"&gt;)); //注意Node&lt;/span&gt;前面不需要加struct关键字\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["有没有啥对初学者友好一点的编译器🌚（现在用c语言）", ["之前用的dev c++，程序老是出各种奇奇怪怪的错，比如不论用NULL还是nullptr它都会报错说未定义，昨天装了个vs2022，用typedef自定义了一个结构体，在malloc时使用强制类型转换的时候又报错告诉我不能使用自定义类型的强制类型转换，究竟该怎么解决"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;r是int类型&amp;#xff0c;r*r也应该是int类型&amp;#xff0c;没问题啊。&lt;/p&gt;\n&lt;p&gt;这里引用你的问题&amp;#xff1a;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;这个里面明明对rr进行了强制类型转换成double类型&amp;#xff0c;为什么在监视窗口看到rr仍然为int类型?&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;强制类型转换后&amp;#xff0c;是将 r*r 的&lt;strong&gt;结果&lt;/strong&gt;转换成一个 double 类型&lt;strong&gt;保存到寄存器或一个临时的栈空间中&lt;/strong&gt;。你在编译器监视的时候&amp;#xff0c;输入 r*r 进行监视&amp;#xff0c;监视器会再次计算 r&lt;em&gt;r 的结果&amp;#xff0c;然后展示到监视窗口上。可以说监视窗口的 r*r 与代码中的 r*r 不是一个东西&amp;#xff08;这里的r&lt;/em&gt;r是一个右值&amp;#xff09;。&lt;/p&gt;\n&lt;p&gt;另外&amp;#xff0c;&lt;strong&gt;强制类型转换是不会改变原变量的类型的&lt;/strong&gt;&amp;#xff0c;换句话说&amp;#xff0c;r 最初定义的是 int&amp;#xff0c; 则在整个 r 的声明周期和作用内 都不可能变成另一种类型。强制类型转换只是将结果的值装换成目标类型&amp;#xff0c;它保存在寄存器中或临时栈空间中 以待对齐进行运算或赋值&amp;#xff0c;在该语句结束后临时空间被销毁。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么r*r的类型仍然是int", ["\n", "这个里面明明对r", "r进行了强制类型转换成double类型，为什么在监视窗口看到r", "r仍然为int类型?"]], "Tag": "程序设计"}
{"Answer": "int a = 100;这样定义时，100是int 类型\r\n\r\nbyte a =100;这样定义时，100是byte类型\r\n\r\ndouble a =100,这样定义时，100是double类型\r\n\r\n单单讨论100这个数值的时候，100什么类型也不是\r\n\r\n强转类型只发生在a已经定义，如 int a = 100;  byte b = (byte)a;\r\n\r\n强转的时候可能会发生数值缺失byte类型只能是存0-255的数值，而int可以到达21亿，希望我的回答可以给帮助", "Konwledge_Point": "强制类型转换", "Question": [" java基础：byte b1 = 100;", ["请问100是int类型吗？", "\n然后如果是int，那么100赋值给b1为何不需要强制类型转换呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不是没法打印&amp;#xff0c;而是数字7强制转换成char后并没有对应显示字符&amp;#xff0c;这是一个响铃&amp;#xff0c;运行程序的时候应该会听到电脑响铃的声音。可以去查看ASCII表&amp;#xff0c;了解128个字符的情况。像你程序里面的&amp;#xff0c;将i赋值成48&amp;#xff0c;将打印出字符0.&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c语言关于强制转换int到char类型的疑问，为什么下图无法打印出b的值，不是给他赋值了吗", ["求大佬帮助"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Is this what you are after ?&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;function remdec($num) { return intval(str_replace(\".\", \"\", strval($num))); }\n\n$number = remdec(1.5058) - remdec(1.5215);\necho $number;\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;&lt;strong&gt;&lt;a href=\"http://viper-7.com/xJc9es\" rel=\"nofollow\"&gt;FIDDLE&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["如何在php中将浮点值转换为整数", ["\n\n", "i have a function for forex site that subtract two numbers like the following example", "\n\n", "140.50 - 140.00\n1.1010 - 1.1050\n1.5215 - 1.5058\n", "\n\n", "what i get is the following", "\n\n", "\n  ", "0.5", "\n  \n  ", "-0.004", "\n  \n  ", "0.0157", "\n", "\n\n", "what i want to get is the following", "\n\n", "\n  ", "50", "\n  \n  ", "-40", "\n  \n  ", "157", "\n", "\n\n", "i have tried the following ", "\n\n", "$number = 1.5058 - 1.5215;\nlist($real, $decimal) = explode('.', $number);\necho $result = $number*pow(10,strlen($decimal));\n", "\n\n", "but i got ", "\n\n", "\n  ", "5", "\n  \n  ", "-4", "\n  \n  ", "157", "\n", "\n\n", "because the zero in the right is no sense for it", "\n    "]], "Tag": "程序设计"}
{"Answer": ":wink: 看看java反射机制\r\n相关文章:   \r\nJAVA反射机制的学习 \r\nwebwork与orm结合时，参数绑定的方法 \r\n基于SSH架构上的ajax翻页（json+prototype+jstemplate） \r\n\r\n推荐圈子: EXT \r\n更多相关推荐 一、什么是反射： \r\n      反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。其中LEAD/LEAD++ 、OpenC++ 、MetaXa和OpenJava等就是基于反射机制的语言。最近，反射机制也被应用到了视窗系统、操作系统和文件系统中。 \r\n\r\n      反射本身并不是一个新概念，尽管计算机科学赋予了反射概念新的含义。在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。 \r\n\r\n二、什么是Java中的类反射： \r\n       Reflection 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序对自身进行检查，或者说“自审”，并能直接操作程序的内部属性和方法。Java 的这一能力在实际应用中用得不是很多，但是在其它的程序设计语言中根本就不存在这一特性。例如，Pascal、C 或者 C++ 中就没有办法在程序中获得函数定义相关的信息。 \r\nReflection 是 Java 被视为动态（或准动态）语言的关键，允许程序于执行期 Reflection APIs 取得任何已知名称之 class 的內部信息，包括 package、type parameters、superclass、implemented interfaces、inner classes, outer class, fields、constructors、methods、modifiers，並可于执行期生成instances、变更 fields 內容或唤起 methods。 \r\n\r\n三、Java类反射中所必须的类： \r\n      Java的类反射所需要的类并不多，它们分别是：Field、Constructor、Method、Class、Object，下面我将对这些类做一个简单的说明。 \r\nField类：提供有关类或接口的属性的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）属性或实例属性，简单的理解可以把它看成一个封装反射类的属性的类。 \r\nConstructor类：提供关于类的单个构造方法的信息以及对它的访问权限。这个类和Field类不同，Field类封装了反射类的属性，而Constructor类则封装了反射类的构造方法。 \r\nMethod类：提供关于类或接口上单独某个方法的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 这个类不难理解，它是用来封装反射类方法的一个类。 \r\nClass类：类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 \r\nObject类：每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。 \r\n\r\n四、Java的反射类能做什么： \r\n       看完上面的这么多我想你已经不耐烦了，你以为我在浪费你的时间，那么好吧！下面我们就用一些简单的小例子来说明它。 \r\n       首先我们来看一下通过Java的反射机制我们能得到些什么。 \r\n       首先我们来写一个类： \r\nimport java.awt.event.ActionListener; \r\nimport java.awt.event.ActionEvent; \r\nclass A extends Object implements ActionListener{ \r\nprivate int a = 3; \r\npublic Integer b = new Integer(4); \r\npublic A(){} \r\npublic A(int id,String name){} \r\npublic int abc(int id,String name){return 0;} \r\npublic void actionPerformed(ActionEvent e){} \r\n} \r\n你可能被我这个类弄糊涂了，你看不出我要做什么，那就不要看这个类了，这个类是用来测试的，你知道知道它继承了Object类，有一个接口是ActionListener，两个属性int和Integer,两个构造方法和两个方法，这就足够了。 \r\n下面我们把A这个类作为一个反射类，来过去A类中的一些信息，首先我们先来过去一下反射类中的属性和属性值。 \r\nimport java.lang.reflect.*; \r\nclass B{ \r\npublic static void main(String args[]){ \r\nA r = new A(); \r\nClass temp = r.getClass(); \r\ntry{ \r\n         System.out.println(\"反射类中所有公有的属性\"); \r\n                         Field[] fb  =temp.getFields(); \r\nfor(int j=0;j&lt;fb.length;j++){ \r\nClass cl = fb[j].getType(); \r\nSystem.out.println(\"fb:\"+cl); \r\n} \r\n\r\n                        System.out.println(\"反射类中所有的属性\"); \r\nField[] fa = temp.getDeclaredFields(); \r\n                        for(int j=0;j&lt;fa.length;j++){ \r\nClass cl = fa[j].getType(); \r\nSystem.out.println(\"fa:\"+cl); \r\n} \r\n                           System.out.println(\"反射类中私有属性的值\"); \r\nField f = temp.getDeclaredField(\"a\"); \r\nf.setAccessible(true); \r\nInteger i = (Integer)f.get(r); \r\nSystem.out.println(i); \r\n}catch(Exception e){ \r\ne.printStackTrace(); \r\n} \r\n} \r\n\r\n} \r\n这里用到了两个方法，getFields()、getDeclaredFields()，它们分别是用来获取反射类中所有公有属性和反射类中所有的属性的方法。另外还有getField(String)和getDeclaredField(String)方法都是用来过去反射类中指定的属性的方法，要注意的是getField方法只能取到反射类中公有的属性，而getDeclaredField方法都能取到。 \r\n这里还用到了Field 类的setAccessible方法，它是用来设置是否有权限访问反射类中的私有属性的，只有设置为true时才可以访问，默认为false。另外Field类还有set(Object AttributeName,Object value)方法，可以改变指定属性的值。 \r\n\r\n下面我们来看一下如何获取反射类中的构造方法 \r\nimport java.lang.reflect.*; \r\npublic class SampleConstructor { \r\npublic static void main(String[] args) { \r\nA r = new A(); \r\nprintConstructors(r); \r\n} \r\n\r\npublic static void printConstructors(A r) { \r\nClass c = r.getClass(); \r\n//获取指定类的类名 \r\nString className = c.getName(); \r\ntry { \r\n//获取指定类的构造方法 \r\nConstructor[] theConstructors = c.getConstructors(); \r\nfor(int i=0; i&lt;theConstructors.length; i++) { \r\n//获取指定构造方法的参数的集合 \r\nClass[] parameterTypes = theConstructors[i].getParameterTypes(); \r\n\r\nSystem.out.print(className + \"(\"); \r\n\r\nfor(int j=0; j&lt;parameterTypes.length; j++) \r\nSystem.out.print(parameterTypes[j].getName() + \" \"); \r\n\r\nSystem.out.println(\")\"); \r\n\r\n} \r\n}catch(Exception e) { \r\ne.printStackTrace(); \r\n} \r\n} \r\n} \r\n这个例子很简单,只是用getConstructors()方法获取了反射类的构造方法的集合，并用Constructor类的getParameterTypes()获取该构造方法的参数。 \r\n\r\n下面我们再来获取一下反射类的父类（超类）和接口 \r\nimport java.io.*; \r\nimport java.lang.reflect.*; \r\n\r\npublic class SampleInterface { \r\npublic static void main(String[] args) throws Exception { \r\nA raf = new A(); \r\nprintInterfaceNames(raf); \r\n} \r\n\r\npublic static void printInterfaceNames(Object o) { \r\nClass c = o.getClass(); \r\n//获取反射类的接口 \r\nClass[] theInterfaces = c.getInterfaces(); \r\nfor(int i=0; i&lt;theInterfaces.length; i++) \r\nSystem.out.println(theInterfaces[i].getName()); \r\n//获取反射类的父类（超类） \r\nClass theSuperclass = c.getSuperclass(); \r\nSystem.out.println(theSuperclass.getName()); \r\n} \r\n} \r\n这个例子也很简单，只是用Class类的getInterfaces()方法获取反射类的所有接口，由于接口可以有多个，所以它返回一个Class数组。用getSuperclass()方法来获取反射类的父类（超类），由于一个类只能继承自一个类，所以它返回一个Class对象。 \r\n\r\n下面我们来获取一下反射类的方法 \r\nimport java.lang.reflect.*; \r\npublic class SampleMethod { \r\n\r\npublic static void main(String[] args) { \r\nA p = new A(); \r\nprintMethods(p); \r\n} \r\n\r\npublic static void printMethods(Object o) { \r\nClass c = o.getClass(); \r\nString className = c.getName(); \r\nMethod[] m = c.getMethods(); \r\nfor(int i=0; i&lt;m.length; i++) { \r\n//输出方法的返回类型 \r\nSystem.out.print(m[i].getReturnType().getName()); \r\n//输出方法名 \r\nSystem.out.print(\" \"+m[i].getName()+\"(\"); \r\n//获取方法的参数 \r\nClass[] parameterTypes = m[i].getParameterTypes(); \r\nfor(int j=0; j&lt;parameterTypes.length; j++){ \r\nSystem.out.print(parameterTypes[j].getName()); \r\nif(parameterTypes.length&gt;j+1){ \r\nSystem.out.print(\",\"); \r\n} \r\n} \r\n\r\nSystem.out.println(\")\"); \r\n} \r\n\r\n} \r\n\r\n} \r\n这个例子并不难，它只是获得了反射类的所有方法，包括继承自它父类的方法。然后获取方法的返回类型、方法名和方法参数。 \r\n\r\n接下来让我们回过头来想一想，我们获取了反射类的属性、构造方法、父类、接口和方法，可这些东西能帮我们做些什么呢！！ \r\n下面我写一个比较完整的小例子，来说明Java的反射类能做些什么吧！！ \r\nimport java.lang.reflect.Constructor; \r\nimport java.lang.reflect.Method; \r\n\r\npublic class LoadMethod { \r\npublic Object Load(String cName,String MethodName,String[] type,String[] param){ \r\nObject retobj = null; \r\ntry { \r\n        //加载指定的Java类 \r\n            Class cls = Class.forName(cName); \r\n            \r\n            //获取指定对象的实例 \r\n            Constructor ct = cls.getConstructor(null); \r\n            Object obj = ct.newInstance(null); \r\n            \r\n            //构建方法参数的数据类型 \r\n            Class partypes[] = this.getMethodClass(type); \r\n            \r\n            //在指定类中获取指定的方法 \r\n            Method meth = cls.getMethod(MethodName, partypes); \r\n            \r\n            //构建方法的参数值 \r\n            Object arglist[] = this.getMethodObject(type,param); \r\n\r\n            //调用指定的方法并获取返回值为Object类型 \r\n            retobj= meth.invoke(obj, arglist); \r\n\r\n        } \r\n        catch (Throwable e) { \r\n            System.err.println(e); \r\n        } \r\nreturn retobj; \r\n} \r\n\r\n//获取参数类型Class[]的方法 \r\npublic Class[] getMethodClass(String[] type){ \r\nClass[] cs = new Class[type.length]; \r\nfor (int i = 0; i &lt; cs.length; i++) { \r\nif(!type[i].trim().equals(\"\")||type[i]!=null){ \r\nif(type[i].equals(\"int\")||type[i].equals(\"Integer\")){ \r\ncs[i]=Integer.TYPE; \r\n}else if(type[i].equals(\"float\")||type[i].equals(\"Float\")){ \r\ncs[i]=Float.TYPE; \r\n}else if(type[i].equals(\"double\")||type[i].equals(\"Double\")){ \r\ncs[i]=Double.TYPE; \r\n}else if(type[i].equals(\"boolean\")||type[i].equals(\"Boolean\")){ \r\ncs[i]=Boolean.TYPE; \r\n}else{ \r\ncs[i]=String.class; \r\n} \r\n} \r\n} \r\nreturn cs; \r\n} \r\n\r\n//获取参数Object[]的方法 \r\npublic Object[] getMethodObject(String[] type,String[] param){ \r\nObject[] obj = new Object[param.length]; \r\nfor (int i = 0; i &lt; obj.length; i++) { \r\nif(!param[i].trim().equals(\"\")||param[i]!=null){ \r\nif(type[i].equals(\"int\")||type[i].equals(\"Integer\")){ \r\nobj[i]= new Integer(param[i]); \r\n}else if(type[i].equals(\"float\")||type[i].equals(\"Float\")){ \r\nobj[i]= new Float(param[i]); \r\n}else if(type[i].equals(\"double\")||type[i].equals(\"Double\")){ \r\nobj[i]= new Double(param[i]); \r\n}else if(type[i].equals(\"boolean\")||type[i].equals(\"Boolean\")){ \r\nobj[i]=new Boolean(param[i]); \r\n}else{ \r\nobj[i] = param[i]; \r\n} \r\n} \r\n} \r\nreturn obj; \r\n} \r\n} \r\n这是我在工作中写的一个实现Java在运行时加载指定的类，并调用指定方法的一个小例子。这里没有main方法，你可以自己写一个。 \r\nLoad方法接收的五个参数分别是，Java的类名，方法名，参数的类型和参数的值。", "Konwledge_Point": "强制类型转换", "Question": ["急救！如何将字符串名转化成类名？", ["因为毕业设计的需要，接触到了VRML+EAI+JAVA编程。现有以下问题被困住，望大哥们帮帮我！", "\n :cry: ", "\nString vrmlobj=\"VrmlEvent\"。这里的\"VrmlEvent\"字符串有对应的一个同名的类，名为VrmlEvent,现需要调用这个VrmlEvent类的setValue(X)方法,但由于实际需要无法直接导入该类。", "\n我本意是做如下操作：", "\n\n", "((VrmlEvent)EventInMFNodeObj).setValue(node);", "\n\n", "但是这个强制转化的类VrmlEvent并不直接可用，只是已知一个String类型的变量vrmlobj=\"VrmlEvent\",", "\n我该怎么将这个字符串vrmlobj的值\"VrmlEvent\"变成类名VrmlEvent并成功运用到上面的强制类型转化中去？？", "\n听说反射机制可以，但是我查阅了API文档好像还不能运用到强制类型转换方面，我是初学者，希望大家帮帮我。晚辈再此先谢过！", "\n :arrow:  :arrow:  :arrow: ", "\n[b]问题补充：", "/b", "EventInMFNodeObj).setValue(node); ", "\n用发射至少也要用到EventInMFNodeObj这个对象引用吧，没有它,直接反射就得不到我要的结果了... :cry: "]], "Tag": "程序设计"}
{"Answer": "是用来强制类型转换，无法转换的则返回null。", "Konwledge_Point": "强制类型转换", "Question": ["actionscript的简单语法", ["[color=blue]var[/color] swListResponseDto:VlanConfigErrorSwListResponseDto = event.result [color=blue]as[/color] VlanConfigErrorSwListResponseDto;", "\n\n", "上面语句里的as是什么意思那? 是强制类型转换的意思吗?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳&amp;#xff01;&amp;#xff01;点击该回答右侧的“采纳”按钮即可采纳&amp;#xff01;&amp;#xff01;&lt;br /&gt;我的分析是这是因为在调用函数 Add 的时候&amp;#xff0c;你的实参 1.2 和 4.5 都是 double 类型的&amp;#xff0c;而你在定义函数时&amp;#xff0c;并没有定义 double 类型的形参。&lt;br /&gt;因此在编译器看来&amp;#xff0c;这个函数调用语句既可以匹配 int 类型的形参&amp;#xff0c;也可以匹配 float 类型的形参&amp;#xff0c;导致了“有多个重载函数与参数列表匹配”的错误&lt;/p&gt;\n&lt;hr /&gt;\n&lt;p&gt;要解决这个问题&amp;#xff0c;你可以在定义函数的时候添加一个 double 类型的形参&amp;#xff0c;以便与 double 类型的实参匹配。&lt;br /&gt;我给你个例子&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Add&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; a, &lt;span class=\"hljs-type\"&gt;double&lt;/span&gt; b)&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; a &amp;#43; b;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\ncout &amp;lt;&amp;lt; &lt;span class=\"hljs-built_in\"&gt;Add&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1.2&lt;/span&gt;, &lt;span class=\"hljs-number\"&gt;4.5&lt;/span&gt;) &amp;lt;&amp;lt; endl;\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样就可以解决“有多个重载函数与参数列表匹配”的错误了。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c++函数重载中，实参无法正确匹配形参，请问如何解决？", ["我使用的实参是double类型，却同时匹配上了int和float类型的形参。", "导致主函数报错“有多个重载函数“Add”实例与参数列表匹配”。", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "Add", "(", "int", " a, ", "int", " b)", "\n", "{\n    ", "return", " a + b;\n}\n\n", "float", " ", "Add", "(", "float", " a, ", "float", " b)", "\n", "{\n    ", "return", " a + b;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    cout << ", "Add", "(", "1.2", ", ", "4.5", ") << endl;\n    ", "return", " ", "0", ";\n}\n", "\n", "报错具体内容为：", "\n", "\n", "有多个 重载函数“Add”实例与参数列表匹配:", "函数“Add(int a,int b)\"(已声明 所在行数:4)", "函数“Add(float a,float b)\"(已声明 所在行数:9)", "参数类型为: (double,double)", "\n", "\n", "我知道c++中，浮点型常数的默认类型是double类型。", "所以输入的实参无法进行精确匹配，需要进行转换。", "但是根据重载决议，“小数转换”应该优先于“整数和小数转换”才对", "\n", "所以double->float应该优先于double->int才对", "但却同时发生了，同时匹配了float和int。", "\n", "我对实参进行强制类型转换，或者将float类型的函数重载修改为double", "\n", "double", " ", "Add", "(", "double", " a, ", "double", " b)", "//将float类型的函数重载修改为double", "\n", "{\n    ", "return", " a + b;\n}\n\n", "int", " ", "main", "()", "\n", "{\n    cout << ", "Add", "((", "float", ")", "1.2", ", (", "float", ")", "4.5", ") << endl;", "//对实参进行强制类型转换", "\n    ", "return", " ", "0", ";\n}\n", "\n", "确实能解决这个问题，但还是无法理解这个问题产生的原因。", "求各位赐教，如果我哪里描述有问题敬请指正，感谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;字符串a没有初始化&amp;#xff1a;可以char a[n&amp;#43;1] &amp;#61; {0}; 或者 char a[n&amp;#43;1]; memset(a,0x0,n&amp;#43;1);&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C++对于字符类数组输出乱码的情况", ["本人在完成学校编程的时候发现了一个问题，具体题目是这样的", "\n", "要求通过数组的方式将正整数转换为英文表示字符串 例如输入1 2 3 4 5   输出的是字符型的1  2  3  4  5 最后用cout << a <<endl输出", "\n", "然后我自己写的代码中运用的是强制类型转换符，能输出以上结果， 但是可惜的是后面会乱码，像下图", "\n", "\n", "因为我好像记得就算不定义字符型变量最后的\\0，它数组也会自己补上去，所以不明白到底哪里有问题，会造成乱码"]], "Tag": "程序设计"}
{"Answer": "是否是版本问题 :oops:", "Konwledge_Point": "强制类型转换", "Question": ["为什么我的 OnClickListener 继承的 方法是public void onClick(DialogInterface dialog, int whi", ["如题 。。新手 看着Mars 老师的 视频 边学边做 。。。", "\n\n", "但 我的 监听器总是出错 。。。OnClickListener 继承的 方法是public void onClick(DialogInterface dialog, int which)", "\n\n", "绑定的时候 还要强制类型转换 ", "\n\n", "eclipse 没显错 但 运行时总是提示 stopped unexpectedly  try again!"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;编译器帮我们自动转了  &lt;a href=\"https://blog.csdn.net/weixin_33964094/article/details/94117643\"&gt;https://blog.csdn.net/weixin_33964094/article/details/94117643&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["一个关于泛型的小问题", ["\nArrayList<Integer> list ", "=", " new ArrayList<>()", ";", "\n        list.add(", "11", ")", ";", "\n        Integer i ", "=", " list.get(", "0", ")", ";", "\n", "\n", "既然泛型会被擦除，也就是说运行时内存中加载的集合依然是object类的，那为什么数据取用的时候不用强制类型转换呢？"]], "Tag": "程序设计"}
{"Answer": "嗯，C编译器不支持这种写法\r\ni = (int)c;\r\n\r\nC++才支持。", "Konwledge_Point": "强制类型转换", "Question": ["C语言文件读写和类型转换的一个小问题", ["#include <stdio.h>\n#include <Windows.h>\nmain()\n{\n    FILE *f;\n    int c;\n    errno_t err = fopen_s(&f,\"E:\\\\workspace\\\\TVPLAY\\\\data\\\\diffFrame\\\\txts\\\\file2.txt\",\"r\");\n    if (err)\n    {\n        printf(\"can't open file\\n\");\n    }\n    c = fgetc(f);\n    while (c!=EOF)\n    {\n        printf(\"%d \",c);\n        c = fgetc(f);\n    }\n    Sleep(30000);\n    return 0;\n}\n", "\n\n", "定义的c是int型", "\n但是如果如此输出是ascII的值", "\n0空格1空格2空格2空格0空格", "\n会输出", "\n48 32 49 32 50 32 50 32", "\n\n", "如果在函数前面定义int i", "\nint i；", "\n在下面执行强制转换", "\ni=（int）c；", "\n则在此行编译报错。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;size是字节数&amp;#xff0c;所以是64&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["memcpy函数应用", ["想请教下，假设定义数组a为uint8_t a[64]，定义指针b为b为uint32_t *b，在我对a进行(uint32_t *）a强制类型转换后，我调用memcpy(b,a,size)时，size应该是64还是16"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;double n &amp;#61; in.nextDouble();&lt;br /&gt;你输入的5.6是浮点数&amp;#xff0c;不是整型&amp;#xff0c;不能用nextInt()&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["java,强制转换数据类型报错", ["\n", "想用Java写一个正小数四舍五入的方法,强制转换数据类型不行,求师兄们帮帮忙,谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;.父类引用对象指向的是子类对象&amp;#xff0c;那么在向下转型的过程中是安全的&amp;#xff0c;就是编译是不会出错误。&lt;br /&gt; &lt;strong&gt;但是如果父类引用对象是父类本身&amp;#xff0c;那么在向下转型的过程中是不安全的&amp;#xff0c;编译不会出错&amp;#xff0c;但是运行时会 出现 Java 强制类型转换异常&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Java中多态的向下强制转换类型", ["这是为什么不能转呢", "\n", "但是这个可以转", "\n", "\n", "所以是需要本身new所创建的类型是dog类型是吗？Animal b=new Dog();向上自动转为了Animal，这个时候可以向下转为Dog类型。如果是new Animal();本身new的类型就是Animal,就不能向下转了。不知道是不是这样.求解"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;小数部分比较好写吧&amp;#xff1f;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;def frac(&lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;):\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;00&amp;#39;&lt;/span&gt;:&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;&amp;#39;&lt;/span&gt;\n    jiao &amp;#61; han_list[&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;])] &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;角&amp;#39;&lt;/span&gt;\n    fen &amp;#61; han_list[&lt;span class=\"hljs-built_in\"&gt;int&lt;/span&gt;(&lt;span class=\"hljs-built_in\"&gt;num&lt;/span&gt;[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;])] &amp;#43; &lt;span class=\"hljs-string\"&gt;&amp;#39;分&amp;#39;&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; jiao &amp;#43; fen\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;另外题目说小数2位后直接舍弃&amp;#xff0c;应该不用round&amp;#xff0c;直接int取整就好&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["数字转人民币程序设计", ["这是整数部分 怎么搞到小数点后两位", "\n", "实验原理：将一个浮点数转换为人民币读法的字符串。首先把一个浮点数分成整数部分和小数部分。抓取整数部分，即直接将这个浮点数强制类型转换成一个整数；再使用浮点数减去整数就可以得到这个浮点数的小数部分，最后将整数和小数部分分别转换为对应的汉字大写数字并拼接在一起输出。例如：180018001.50转换后的输出为“壹亿捌仟零壹万捌仟零壹元 伍角零分”。"]], "Tag": "程序设计"}
{"Answer": "虚拟机类加载器在加载的时候有类的主动引用（一定会发生类的初始化）和被动引用（不会发生类的初始化）的区别\r\n如果你没有导入父类的jar包，类加载器将无法加载这个父类，当然也无妨将其初始化", "Konwledge_Point": "强制类型转换", "Question": ["Java JAR包中的类 父类方法不可见等", ["场景：", "\n两个jar包分别为a.jar、b.jar。b.jar中引用了a.jar，具体为b.jar中的类B继承了a.jar中的类A。", "\nA有两个方法，a.getName()，a.getAge()，B重写了getName方法，未重写getAge方法。", "\n新建了一个Java项目C，**C只引用了b.jar，未引用a.jar**，于是出现了如下两个问题：", "\n1、在C项目中，类B没有getAge方法", "\n2、在C项目中，使用强制类型转换时（如）B b = (B)map.get(\"key\")，会报错：  - The type A cannot be resolved. It is indirectly referenced from  required .class files", "\n请教：1、构建子类对象时，继承自父类的方法为何没有加载？2、强制类型转换为何需要找A类？", "\n\n", "追加：前提就是C项目不能引用a.jar。不然也不会发现这个问题。我知道引入a.jar可以解决这个问题。但是想知道为何必须引入a.jar。虚拟机加载b.jar中的类并创建对象时，难道不是把所有方法都准备好了吗？为什么还会有父类方法不可见的情况"]], "Tag": "程序设计"}
{"Answer": "javacode.HelloFlex类下面看看有没有helloflex这个方法，flex就是没用找到这个方法才报这错", "Konwledge_Point": "强制类型转换", "Question": ["Flex与Java通信HelloWorld出现异常！", ["异常信息", "\n[RPC Fault faultString=\"Cannot invoke method 'helloflex'.\" faultCode=\"Server.ResourceUnavailable\" faultDetail=\"Method 'helloflex' not found.\"]", "\n\n", "我的MXML代码", "\n<?xml version=\"1.0\" encoding=\"utf-8\"?>", "mx:Script", "\n        <![CDATA[", "\n            import mx.controls.Alert;", "\n            import mx.rpc.events.FaultEvent;", "\n            import mx.rpc.events.ResultEvent;", "\n            import flash.net.registerClassAlias;", "\n            import mx.messaging.messages.RemotingMessage;", "\n\n", "        [Bindable]\n        private var helloResult:String;    \n        private function sayHelloTo():void {\n            Alert.show(\"进入sayHelloTo..........\");\n            var userName:String=txtName.text;\n            ro.helloflex(userName);    \n        }\n        private function resultHandler(event:ResultEvent):void {\n            Alert.show(\"进入resultHandler........\");\n            helloResult=event.result as String;\n            Alert.show(helloResult);\n            ggg.text=helloResult\n        }\n    ]]>\n</mx:Script>\n<mx:RemoteObject id =\"ro\" destination=\"helloflex\" result=\"resultHandler(event)\"\n    endpoint=\"http://localhost:8080/flexjoinjava/messagebroker/amf\"></mx:RemoteObject>\n<mx:Label x=\"433\" y=\"183\" text=\"名称: \"/>\n<mx:TextInput x=\"475\" y=\"181\" id=\"txtName\"/>\n<mx:Button x=\"475\" y=\"227\" label=\"提交\" id=\"btnButton\" click=\"sayHelloTo()\"/>\n<mx:TextArea id=\"ggg\"  x=\"109\" y=\"122\"/>\n", "\n\n", "/mx:Application", "\n\n", "remoting-config.xml配置文件", "\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "\n    class=\"flex.messaging.services.RemotingService\">", "\n\n", "<adapters>\n    <adapter-definition id=\"java-object\" class=\"flex.messaging.services.remoting.adapters.JavaAdapter\" default=\"true\"/>\n</adapters>\n\n<default-channels>\n    <channel ref=\"my-amf\"/>\n</default-channels>\n\n<destination id=\"helloflex\">\n    <properties>\n        <source>javacode.HelloFlex</source>\n    </properties>\n</destination>\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201905/03/1556869402_425879.png)", "Konwledge_Point": "强制类型转换", "Question": ["Go语言中一个函数返回类型为 map[string]interface{}，如何将其强制转换为string类型呢？", ["如题，返回result map[string]interface{}", "\n1、尝试使用result.(string)强制转换，发现会报错，如下图", "\n\n", "\n\n", "2、尝试使用Marshal和Unmarshal，也失败，如下图"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;第八行中的1024后面的*可以理解为把1024当作数字进行运算&amp;#xff0c;结果就是1024 * 100。&lt;/p&gt;\n&lt;p&gt;当指针地址改变后&amp;#xff0c;正确的free()写法是free(改变前的指针地址)。例如&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;c&lt;br /&gt;Copy code&lt;br /&gt;int *p &amp;#61; malloc(100 * sizeof(int));&lt;br /&gt;int *p2 &amp;#61; p;&lt;br /&gt;p &amp;#61; p &amp;#43; 50;&lt;br /&gt;free(p2);&lt;br /&gt;可以这样写&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; *p &amp;#61; &lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt; * &lt;span class=\"hljs-built_in\"&gt;sizeof&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;));\n因为&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;()返回的是&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;类型的指针&amp;#xff0c;所以可以直接用&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt;指针接收返回值&amp;#xff1a;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; *p &amp;#61; &lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;(&lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;);\n写成纯数字形式&lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;不需要写明白这&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt; MB要存什么类型&amp;#xff0c;因为&lt;span class=\"hljs-built_in\"&gt;malloc&lt;/span&gt;()函数只分配内存&amp;#xff0c;不管存储的是什么类型的数据。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果需要强制类型转换&amp;#xff0c;可以这样写&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-attribute\"&gt;void&lt;/span&gt; *p &amp;#61; (void *)malloc(&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt; * &lt;span class=\"hljs-number\"&gt;1024&lt;/span&gt;);\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["指针地址改变后如何正确 free掉这个指针？", ["图上这样写会崩溃，", "当指针地址改变后，free（  ）里要怎么写呀？", "\n", "\n", "上图第八行，", "两个1024之间的", "号，代表乘法，100后面的", "代表（分节符）", "分节符这个称呼正确吗，该怎么理解100后面的*呢？", "\n", "3.如果一个", " int类型指针=malloc（ 100", "sizeof（int类型说明符） ）", "   这时候还能写1024", "\n", "图上的void ", "p", "void指针名=malloc（ 数字", "sizeof（void类型说明符） ）", "为什么不按照这种模式来写？", "\n", "为什么写成纯数字形式 1024", "1024  不用写明白这1mb要存什么类型？", "  原因是不能传递类型吗？？不能传递类型的话，我们要强制类型转换吧，如p=（void", "）malloc（100", "1024", "1024）；"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;父类强制转换为子类的条件是父类变量的实际类型为子类&amp;#xff0c;把 &lt;code class=\"language-javascript\"&gt;Person p &amp;#61; new Person(2,&amp;#34;zhangsan&amp;#34;);&lt;/code&gt; 改成 &lt;code class=\"language-javascript\"&gt;Person p &amp;#61; new Student(2,&amp;#34;zhangsan&amp;#34;);&lt;/code&gt; 保证变量 p 的实际类型为 Student&amp;#xff0c;才能将变量 p 强转为 Student。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Java中父子类之间的强制转换", ["父类强制转换位子类的类型然后赋给子类报错", "Perosn类是Student类的父类", "\n"]], "Tag": "程序设计"}
{"Answer": "因为你实际上是animal不是dog，你强行转换为dog，但是cry在虚表实际上没有\r\n所以可以编译，运行报错\r\n\r\n# 问题解决的话，请及时采纳", "Konwledge_Point": "强制类型转换", "Question": ["c++简单代码细节错误....求解", ["#include<iostream>\nusing namespace std;\n\nclass   Animal\n{\npublic:\n    virtual void cry()=0;\n};\nclass Dog:public Animal\n{\npublic:\n    virtual void cry()\n    {\n        cout<<\"旺旺~\"<<endl;\n    }\n    void doHome()\n    {\n        cout<<\"看家\"<<endl;\n    }\n};\nclass Cat:public Animal\n{\npublic:\n    virtual void cry()\n    {\n        cout<<\"喵喵~\"<<endl;\n    }\n    void doHome()\n    {\n        cout<<\"抓老鼠\"<<endl;\n    }\n};\nclass Book\n{\npublic:\n    void printP()\n    {\n        cout<<\"book\"<<endl;\n    }\n};\nint main(void)\n{\n    Animal  *base=NULL;\n    //1.可以把子类指针赋给父类指针 但是反过来是不可以的,需要如下转换\n    Dog *pDog=static_cast<Dog*>(base);\n    pDog->doHome();//这里为什么doHome可以执行，cry会报错\n\n    //2.把base转换成其他,非动物相关的   err\n    //Book *book=static_cast<Book*>(base);\n\n    //3.reinterpret_cast可以强制类型转换\n    Book *book=reinterpret_cast<Book*>(base);\n    book->printP();\n    return 0;\n}\n//运行结果\n看家\nbook\n\n", "\n\n", "请问为什么pDog->doHome那个位置换成cry()就会报错"]], "Tag": "程序设计"}
{"Answer": "Date time = data.getTime();   \r\n        if (time != null) {   \r\n            long now = time.getTime();   \r\n            now = now - now % 86400000 + 57600000;   \r\n  \r\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm\");   \r\n            map.put(\"begin\", sdf.format(new Date(now)));   \r\n            map.put(\"end\", sdf.format(new Date(now + 86400000)));   \r\n            hql.append(\"and s.time between :begin and :end \");   \r\n        }  \r\n\r\n这个地方就搞错了，你怎么把date转换成字符串保存成参数\r\n\r\nwhile (it.hasNext()) {   \r\n                String key = it.next();   \r\n//这个地方对给date类型的参数设置参数不能为字符串的，否则自然就出现上面的类型转换错误\r\n                query.[color=red]setParameter[/color](key, map.get(key));   \r\n            }", "Konwledge_Point": "强制类型转换", "Question": ["Hibernate数据库DATETIME类型字段映射为Date类型后的强制转型错误", ["用Struts2 + Hibernate（3.3.1）做了一个测试程序，查询的时候遇到了强制转换类型错误，数据库是MySQL 5.0，麻烦看下代码，很简单。", "\n异常提示：", "\n[code=\"java\"]", "\njava.lang.ClassCastException: java.lang.String", "\n  at org.hibernate.type.DateType.toString(DateType.java:101)", "\n  at org.hibernate.type.NullableType.nullSafeToString(NullableType.java:117)", "\n  at org.hibernate.type.NullableType.nullSafeSet(NullableType.java:158)", "\n  at org.hibernate.type.NullableType.nullSafeSet(NullableType.java:136)", "\n  at org.hibernate.param.NamedParameterSpecification.bind(NamedParameterSpecification.java:61)", "\n  at org.hibernate.loader.hql.QueryLoader.bindParameterValues(QueryLoader.java:514)", "\n  at org.hibernate.loader.Loader.prepareQueryStatement(Loader.java:1589)", "\n  at org.hibernate.loader.Loader.doQuery(Loader.java:696)", "\n  …………", "\n[/code]", "\n\n", "Hibernate 映射文件：", "\n[code=\"xml\"]", "\n    <!-- MySQL数据库中TIME字段的类型为DATETIME -->", "\n[/code]", "\n\n", "DAO类", "\n[code=\"java\"]", "\npackage dao;", "\n\n", "import java.text.SimpleDateFormat;", "\nimport java.util.Date;", "\nimport java.util.HashMap;", "\nimport java.util.Iterator;", "\nimport java.util.List;", "\nimport java.util.Map;", "\n\n", "import model.SData;", "\n\n", "import org.hibernate.HibernateException;", "\nimport org.hibernate.Query;", "\nimport org.hibernate.Session;", "\nimport org.hibernate.Transaction;", "\n\n", "public class SDao {", "\n\n", "private Session session = null;\n\nprivate Transaction tx = null;\n\nMap<String, String> map = null;\n\n@SuppressWarnings(\"unchecked\")\npublic List<SData> query( SData data ) {\n    session = HibernateUtil.getCurrentSession();\n    try {\n        String hql = createSQL(data);\n        Query query = HibernateUtil.getCurrentSession().createQuery(hql);\n\n        Iterator<String> it = map.keySet().iterator();\n        while (it.hasNext()) {\n            String key = it.next();\n            query.setParameter(key, map.get(key));\n        }\n\n        query.setMaxResults(512);\n        List list = query.list();\n        return list;\n    }\n    catch (HibernateException e) {\n        HibernateUtil.rollbackTransaction();\n    }\n\n    return null;\n}\n\nprivate String createSQL( SData data ) {\n    StringBuffer hql = new StringBuffer();\n    hql.append(\"from SData as s where 1=1 \");\n\n    map = new HashMap<String, String>();\n\n    String value = data.getName();\n    if (value != null && value.length() > 0) {\n        map.put(\"name\", \"%\" + value + \"%\");\n        hql.append(\"and s.name like :name \");\n    }\n\n    value = data.getAddr();\n    if (value != null && value.length() > 0) {\n        map.put(\"addr\", value);\n        hql.append(\"and s.addr = :addr \");\n    }\n\n    Date time = data.getTime();\n    if (time != null) {\n        long now = time.getTime();\n        now = now - now % 86400000 + 57600000;\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm\");\n        map.put(\"begin\", sdf.format(new Date(now)));\n        map.put(\"end\", sdf.format(new Date(now + 86400000)));\n        hql.append(\"and s.time between :begin and :end \");\n    }\n\n    value = data.getLine();\n    if (value != null && value.length() > 0) {\n        map.put(\"line\", value);\n        hql.append(\"and s.line = :line \");\n    }\n\n    return hql.toString();\n}\n", "\n\n", "}", "\n[/code]", "\n\n", "个人感觉应该不是大问题，不过我找了很久还是没想出来解决办法，实属无奈来此发帖劳烦大家，求帮忙，感激不尽。"]], "Tag": "程序设计"}
{"Answer": "getClass()永远返回的是真实类型，而不是变量的类型，因为变量的类型是代码编写者此刻知道的，要是getClass()不能返回真实类型，要它何用。\r\n\r\nPerson p = it.next(); 这个肯定不可以，因为编译的时候不能判断it.next()返回了什么类型，万一它返回的不是Person而是别的什么东西呢。\r\n\r\n特别注意两个概念：`编译时`和`运行时`。编译的时候能确定的事情和运行的时候才能确定的事情。getClass()是运行时获取的，所以能知道具体类型\r\nPerson p = it.next(); 这里next()返回的类型是object，编译器无法知道它是不是Person", "Konwledge_Point": "强制类型转换", "Question": ["为什么打印出来的是person类型？但在转换为person类型时要强制转换？？不然报错", ["为什么打印出来的是person类型？但在转换为person类型时要强制转换？？不然报错", "\npublic class Test {", "\n\n", "public static void main(String[] args) {\n\n     HashSet hs = new HashSet();\n\n     hs.add(new Person(\"a1\",11));   //将Person类添加进Hashset里面\n\n     Iterator it = hs.iterator();   //定义1个迭代器\n\n     while(it.hasNext()) //开始遍历HashSet\n        {\n          System.out.println(it.next().getClass().toString());   //测试类型，结果为class Person\n\n            Person p = (Person) it.next();   //编译通过\n\n            Person p = it.next();           //编译报错\n        }\n\n}\n", "\n\n", "}"]], "Tag": "程序设计"}
{"Answer": "首先 a 是一个二维数组的首地址，这是一个数组指针类型。\r\n数组指针转普通指针是不同类型之间的转换，需要用强转。\r\n第二强转a之后，因为a是一个二维数组指针，接收这个变量的类型应该是 const \\*\\*\\*类型的指针，\r\n而你访问就是 \r\np4表示a的地址，\r\n\\*p4表示a地址存储的值即99，\r\n\\*\\*p4表示地址为99的内存存储的数据，非法访问，这个地址是不能访问\r\n\\*\\*\\*p4一样的，表示地址99存储的地址的值。\r\n这个解索引很像是存储了一个int\\*类型成员的链表", "Konwledge_Point": "强制类型转换", "Question": ["二维数组指针的一些疑惑", ["int main()\n{\n    int a[2][2]={{99,88},{77,66}};\n\n    int ***p4;\n    p4 = &a;\n    printf(\"%d\\n\",***p4);\n\n    return 0;\n}\n\n", "\n\n", "这段代码中p4=&a报错，说类型不对，估计编译器默认&a的类型是int*[2][2]", "\n但是我希望他是int***，这要怎么写才对呢？", "\n\n", "    int ***p4;\n    p4 = (int***)&a;\n    printf(\"%d\\n\",***p4);\n", "\n\n", "我把&a强制类型转换为（int***），编译器不报错，但是运行就出错又是为什么呢?", "\n我如何才能让指针指向&a呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;As always with these questions, the JLS holds the answer. In this case &lt;a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2\"&gt;§15.26.2 Compound Assignment Operators&lt;/a&gt;. An extract:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;A compound assignment expression of the form &lt;code&gt;E1 op= E2&lt;/code&gt; is equivalent to &lt;code&gt;E1 = (T)((E1) op (E2))&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the type of &lt;code&gt;E1&lt;/code&gt;, except that &lt;code&gt;E1&lt;/code&gt; is evaluated only once.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;An example cited from &lt;a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.26.2\"&gt;§15.26.2&lt;/a&gt;&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;[...] the following code is correct:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;short x = 3;\nx += 4.6;\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;and results in x having the value 7 because it is equivalent to:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;short x = 3;\nx = (short)(x + 4.6);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In other words, your assumption is correct.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么 Java 的 + ,-，* ，/ 复合赋值操作符不需要强制转换？", ["\n\n", "Until today, I thought that for example:", "\n\n", "i += j;\n", "\n\n", "Was just a shortcut for:", "\n\n", "i = i + j;\n", "\n\n", "But if we try this:", "\n\n", "int i = 5;\nlong j = 8;\n", "\n\n", "Then ", "i = i + j;", " will not compile but ", "i += j;", " will compile fine.", "\n\n", "Does it mean that in fact ", "i += j;", " is a shortcut for something like this\n", "i = (type of i) (i + j)", "?", "\n    ", "\n\n", "转载于:https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting"]], "Tag": "程序设计"}
{"Answer": "```\r\n #include &lt;stdio.h&gt;\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n\tint b;\r\n\tchar c;\r\n\tscanf(\"%d\", &amp;b);\r\n\tscanf(\"%c\", &amp;c);\r\n\tprintf(\"%d %c\", b, c);\r\n\treturn 0;\r\n}\r\n```\r\n输入1.2其实%d只捕获到了1，后面那个.没有捕获。下次再捕获%d的时候就是0了，所以循环不能继续。\r\n看上面那个程序，看得很清楚。", "Konwledge_Point": "强制类型转换", "Question": ["C语言scanf返回值的问题", ["其调用格式为:      scanf(\"<格式化字符串>\"，<地址表>);", "\nscanf()函数返回成功赋值的数据项数，出错时则返回EOF。", "\n\n", "为了测试这一点我写了两段代码，第一段是", "\na=scanf(\"%d\",&b);", "\nprintf(\"%d\",a);这样写输入1.2，2.3，2，3，4", "\n都会打印1.", "\n但是", "\nwhile(scanf(\"%d\",&b)==1);输入1.2就会终止循环，2，3，4，都会正常循环并让我继续输入。这说明输入1.2是返回0的。", "\n为什么？并没有发现两种形式的不同之处，还是说在赋值的时候scanf自带强制类型转换所以无所谓？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你可以试试将 record.morey 转换为字符串&amp;#xff0c;然后再将其加到字典值上。例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;&lt;span class=\"hljs-title\"&gt;data_dict&lt;/span&gt;[record.&lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;data&lt;/span&gt;] &amp;#43;&amp;#61; str(&lt;span class=\"hljs-title\"&gt;record&lt;/span&gt;.&lt;span class=\"hljs-title\"&gt;morey&lt;/span&gt;)&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["python运行出现错误，如何解决？", ["为什么会提示 TypeError: can only concatenate str (not \"int\") to str", "\n", "已经在另外一个函数方法里面强制类型转换过了", "\n", "\n", "data_dict = {}\n", "for", " Record ", "in", " all_data:\n    ", "if", " Record", ".data", " ", "in", " data_dict", ".keys", "():\n        data_dict", "[Record.data]", " += Record", ".morey", "\n    ", "else", ":\n        data_dict", "[Record.data]", " = Record", ".data", "\n\n", "print", "(data_dict)", "\n\n", "\n", "Traceback (most recent call last):", "\n", "  File \"E:\\pycm\\yunjiang\\练习2\\数据分析案例\\main.py\", line 13, in ", "    data_dict[record.data] += record.morey", "TypeError: can only concatenate str (not \"int\") to str", "\n", "实在不知道该怎么办了", "\n", "我想要达到的结果，如果你需要快速回答，请尝试 “付费悬赏”"]], "Tag": "程序设计"}
{"Answer": "从代码调试角度来看，，我先从转发走起：\r\nA a -&gt;     这是申明一个A的对象a，放在栈空间内 ,\r\nnew B();   这是在调用B的构造方法构造一个B的实例化对象。因为B类继承自A类。所以B类中的构造函数实际应该是这样的\r\npublic B(){\r\n    supre（）；//默认构造父类，之后再执行B中具体的构造\r\n}\r\n这个时候调用new B（）完了后其实是在堆空间创建了空间大小为B实例对象大小的空间，即在堆空间创建了B的实例化。\r\n然而，申明的a是A类型对象，，，并不是A的实例化，，相当于一个A类型的空间的引用。。。可我们创建的空间却是B类型大小的空间\r\n但是B是A的继承，这就不妨碍，将 A的引用的指向改为指向我们创建出来的堆空间这块B大小的空间\r\n\r\n那么接下来就好解释了，，\r\na的地址，，对应的是a这个申明在栈空间的地址，他的指向是堆空间中的B。\r\n接下来就是a.a = 1 ;a.get() =2这个问题了。。首先，，堆空间里的B：他构造了A，构造了B，\r\n\r\n那么现在堆空间里就有两个a,一个是==1；\r\n\r\n一个==2；这点是重点，，，，\r\n子类中的a=2；并不是单纯的覆盖了父类中a的1,而是重新创建空间，，\r\n\r\n这样就好解释，，，a.a==1这个了，，，，那么为什么a.get（）==2呢。。这是因为get 方法是被覆写后的方法，，，，\r\n覆写后的方法现在要去堆里面拿数据a ,,那么有两个a拿 哪个呢？？？先从自己找，，自己有了就不拿父亲的。正好自己有个\r\na=2,被存在堆空间里。。。。。这样就解释了a.get() == 2；", "Konwledge_Point": "强制类型转换", "Question": ["关于java多态的一些问题", ["源代码：", "\n\n", " public class test {\n\n    public static void main(String args[])\n    {\n        A a = new B();\n        System.out.println(\"a的地址=\"+a);\n        System.out.println(\"在a中--------a=\"+a.a);\n        System.out.print(\"调用a.get()方法后---------\");\n        a.get();\n        B b = new B();\n        System.out.println(\"b的地址=\"+b);\n        System.out.println(\"在b中--------a=\"+b.a);\n\n        System.out.println(\"-------------将a强制类型转换成b并将a的引用赋给b---------------\");\n        b=(B)a;\n        System.out.println(\"a的地址=\"+a);\n        System.out.println(\"b的地址=\"+b);\n        System.out.println(\"在a中--------a=\"+a.a);\n        System.out.println(\"在b中--------a=\"+b.a);\n\n        System.out.print(\"调用a.get()方法后---------\");\n        a.get();\n        System.out.print(\"调用b.get()方法后---------\");\n        b.get();\n    }\n}\n\nclass A{\n    int a =1;\n    A()\n    {\n        System.out.println(\"构造A\");\n    }\n\n    public void get()\n    {\n        System.out.println(\"A中a=\"+this.a);\n    }\n}\nclass B extends A{\n    int a =2;\n    B()\n    {\n        System.out.println(\"构造B\");\n    }\n    public void get()\n    {\n        System.out.println(\"B中a=\"+this.a);\n    }\n}\n", "\n\n", "程序执行结果：", "\n构造A", "\n构造B", "\na的地址=stringOperate.B@65b1fd9c", "\n在a中--------a=1", "\n调用a.get()方法后---------B中a=2", "\n构造A", "\n构造B", "\nb的地址=stringOperate.B@88140ed", "\n在b中--------a=2", "\n-------------将a强制类型转换成b并将a的引用赋给b---------------", "\na的地址=stringOperate.B@65b1fd9c", "\nb的地址=stringOperate.B@65b1fd9c", "\n在a中--------a=1", "\n在b中--------a=2", "\n调用a.get()方法后---------B中a=2", "\n调用b.get()方法后---------B中a=2", "\n\n", "问题：", "\n一、A a = new B();是a的引用指向了b的空间，为什么会打印出a.a=1而在调用get方法后打印出的是b的结果", "\n二、将a强制类型转换成b并将a的引用赋给b后，a，b指向同一块地址空间为什么打印出的a.a=1 而b.a=2", "\n\n", "希望大神能从内存原理角度分析下原因，谢谢"]], "Tag": "程序设计"}
{"Answer": "首先，你这句Animal a=new Dog(\"旺财\",2);，获取到的a是Animal类型，\r\n然后你进行Dog dog=(Dog) a;// 强转为Dog类型这句代码，只是说将a内容赋值给Dog类型的对象dog，a依旧是Animal对象啊\r\n最后a=new Cat(\"咪咪\",3)；这句代码，是给a重新赋值，但是，a依旧是Animal对象啊，只是内容发生变化了而已", "Konwledge_Point": "强制类型转换", "Question": ["java初学者关于引用数据类型 强制转换的问题", ["class  TestDemo7{", "\n    public static void main(String[] args)      {", "\n        Animal a=new Dog(\"旺财\",2);", "\n        System.out.println(\"名字:\"+a.getName());", "\n        System.out.println(\"年龄:\"+a.getAge());", "\n        a.eat();", "\n        Dog dog=(Dog) a;// 强转为Dog类型", "\n        dog.zuanHuoQuan();", "\n        System.out.println(\"_______________________________\");", "\n\n", "    a=new Cat(\"咪咪\",3);//**此句有疑问**\n    System.out.println(\"名字:\"+a.getName());\n    System.out.println(\"年龄:\"+a.getAge());\n    a.eat();\n}\n", "\n\n", "}", "\n\n", "变量a已经被转换为 Dog类型", "\n在创建Cat对象时  为何还是Animal类型？"]], "Tag": "程序设计"}
{"Answer": "成员函数看上去参数符合，其实不是，编译器会在函数最后加上隐含的 this 参数。\r\n比如\r\nvoid A::foo(int x)\r\n其实是\r\nvoid foo(int x, A* this)\r\n所以和你的函数指针类型不匹配。", "Konwledge_Point": "强制类型转换", "Question": ["无法从“overloaded-function”转换为“TIMERPROC”", ["SetTimer(NULL, 0, 1000, (TIMERPROC)Timer2Proc);", "\n\n", "void CALLBACK NetSocket::Timer2Proc(HWND hWnd, UINT nMsg, UINT nTimerid, DWORD dwTime)", "\n{", "\n    int err;", "\n    byte buf[32] = \"\";", "\n    char recvbuf[32] = \"connect!!\";", "\n    byte back[20] = {}; ", "\n    memset(buf, 0, sizeof(buf));", "\n    SetTimer(NULL, 1, 10000, SocketTimeOut);", "\n    err = Send(index, buf, back, 0, sizeof(buf));", "\n    KillTimer(NULL, 1);", "\n}", "\nSetTimer总是报错"]], "Tag": "程序设计"}
{"Answer": "弹出提示用这个：Toast.makeText(MainActivity.this,\"我被点击了 我要挂了\",Toast.LENGTH_SHORT).show();\r\n如果是测试，用这个：   Log.d(\"Tag\", \"我被点击了 我要挂了);", "Konwledge_Point": "强制类型转换", "Question": ["android写了个简单地按钮监听器 但是没有用", ["写了个Button的监听器 通过匿名内部类的方式，但是没有任何反应", "\n布局文件没有问题：", "\n        android:id=\"@+id/button1\"", "\n        android:layout_width=\"wrap_content\"", "\n        android:layout_height=\"wrap_content\"", "\n        android:layout_alignParentTop=\"true\"", "\n        android:layout_centerHorizontal=\"true\"", "\n        android:text=\"@string/button1_name\" />", "\n            Activity不知道哪里错了", "\n            public class MainActivity extends ActionBarActivity {", "\n     private Button bt1;      //定义一个Button对象 bt1", "\n     //private Button bt2;", "\n    @Override", "\n    protected void onCreate(Bundle savedInstanceState) {", "\n        super.onCreate(savedInstanceState);", "\n        setContentView(R.layout.activity_main);", "\n        bt1=(Button)findViewById(R.id.button1);   //初始化bt1 ,findViewById返回的是View  要强制类型转换；", "\n        /*", "\n         * 监听方式通过第一种方式实现： 匿名内部类", "\n         * ", "\n         * setOnClickListener（）中需要一个OnClickListener对象", "\n         * */", "\n        bt1.setOnClickListener(new OnClickListener() {", "\n\n", "        @Override\n        public void onClick(View arg0) {\n            // TODO Auto-generated method stub\n            //在当前方法中监听 点击Button的动作\n        System.out.println(\"我被点击了 我要挂了\");         }\n    });\n}\n"]], "Tag": "程序设计"}
{"Answer": "参考[谈谈VB.NET数组的使用](http://developer.51cto.com/art/200910/155208.htm \"谈谈VB.NET数组的使用\")中VB．NET数组的声明，应该是\r\nDim lHandle(U_NUMITEMS) As Integer", "Konwledge_Point": "强制类型转换", "Question": ["OPC-无法将类型为“System.Int32”的对象强制转换为类型“System.Array”", ["\n\n", "在用VB.NET编写OPC读写西门子S7400程序时候，碰到以上句柄问题，请问该问题如何解决？", "\n\n", "Public Shared MyItemServerHandles2 As System.Array", "\n\n", "Private Sub PLC_AsyncWrite(ByVal NumItemsW As Integer, ByRef ItemValuesW() As System.Object, ByRef MyErrors As System.Array)", "\n Dim lHandle(U_NUMITEMS) As System.Array", "\n        Dim i As Integer", "\n        If MyGroup2 Is Nothing Then", "\n            Exit Sub", "\n        End If", "\n        If MyGroup2.OPCItems.Count > 0 Then", "\n lTransID_Rd2 = lTransID_Rd2 + 1", "\n For i = 1 To 30", "\n lHandle(i) = MyItemServerHandles2(NumItemsW)", "\n                MyGroup2.AsyncWrite(1, lHandle(i), ItemValuesW,", "\n               MyErrors, lTransID_Rd2, lCancelID_Rd2)", "\n    Next", "\n        End If", "\n    End Sub"]], "Tag": "程序设计"}
{"Answer": "“WindowsFormsApplication1.Form2”的对象强制转换为类型“System.Windows.Forms.PictureBox”。\r\n看你的代码，你出错的那行代码（用了as或者强制类型转换），有个变量是picturebox，你赋值给form2类型了", "Konwledge_Point": "强制类型转换", "Question": ["vs2010的错误处理相关问题", ["未处理 System.InvalidCastException", "\n  Message=无法将类型为“WindowsFormsApplication1.Form2”的对象强制转换为类型“System.Windows.Forms.PictureBox”。", "\n  Source=WindowsFormsApplication1", "\n  StackTrace:", "\n       在 WindowsFormsApplication1.Form2.pictureBox1_MouseDown(Object sender, MouseEventArgs e) 位置 G:\\333\\WindowsFormsApplication1\\WindowsFormsApplication1\\Form2.cs:行号 44", "\n       在 System.Windows.Forms.Control.OnMouseDown(MouseEventArgs e)", "\n       在 System.Windows.Forms.Control.WmMouseDown(Message& m, MouseButtons button, Int32 clicks)", "\n       在 System.Windows.Forms.Control.WndProc(Message& m)", "\n       在 System.Windows.Forms.ScrollableControl.WndProc(Message& m)", "\n       在 System.Windows.Forms.Form.WndProc(Message& m)", "\n       在 System.Windows.Forms.Control.ControlNativeWindow.OnMessage(Message& m)", "\n       在 System.Windows.Forms.Control.ControlNativeWindow.WndProc(Message& m)", "\n       在 System.Windows.Forms.NativeWindow.DebuggableCallback(IntPtr hWnd, Int32 msg, IntPtr wparam, IntPtr lparam)", "\n       在 System.Windows.Forms.UnsafeNativeMethods.DispatchMessageW(MSG& msg)", "\n       在 System.Windows.Forms.Application.ComponentManager.System.Windows.Forms.UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop(IntPtr dwComponentID, Int32 reason, Int32 pvLoopData)", "\n       在 System.Windows.Forms.Application.ThreadContext.RunMessageLoopInner(Int32 reason, ApplicationContext context)", "\n       在 System.Windows.Forms.Application.ThreadContext.RunMessageLoop(Int32 reason, ApplicationContext context)", "\n       在 System.Windows.Forms.Application.Run()", "\n       在 WindowsFormsApplication1.Program.Main() 位置 G:\\333\\WindowsFormsApplication1\\WindowsFormsApplication1\\Program.cs:行号 21", "\n       在 System.AppDomain._nExecuteAssembly(RuntimeAssembly assembly, String[] args)", "\n       在 System.AppDomain.ExecuteAssembly(String assemblyFile, Evidence assemblySecurity, String[] args)", "\n       在 Microsoft.VisualStudio.HostingProcess.HostProc.RunUsersAssembly()", "\n       在 System.Threading.ThreadHelper.ThreadStart_Context(Object state)", "\n       在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean ignoreSyncCtx)", "\n       在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)", "\n       在 System.Threading.ThreadHelper.ThreadStart()", "\n  InnerException: "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;int和char的字节大小不同&amp;#xff0c;差了3个字节&amp;#xff0c;&amp;#43;&amp;#43;后指针由原来指向第一个字符变成指向第4个字符&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["关于字符串的类型强制转换", []], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;具体我也不太懂&amp;#xff0c;不知道这篇文章有没有用&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/zz460833359/article/details/47999775\" id=\"textarea_1643347540688_1643349178880_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://blog.csdn.net/zz460833359/article/details/47999775&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C中 int = (int*) - char,为什么与int = (int)(int*) - (int)char结果不一样？", ["问题遇到的现象和发生背景", "\n", "在给几年前的代码消除warning的时候。碰到一行奇怪的代码：", "int m = (int)(((int *)p[0]) - '0'); //p是个char数组", "warning只是提示类型转换的size不同，按道理删掉(int *)这个强制类型转换就ok了。", "在改动之前先复现一下这行代码的效果，结果就发现了这个问题：", "(int)(((int *)p[0]) - '0')输出并不等于(int)(p[0]) - '0'", "当时认为可能是（int *)p[0]和p[0]值不一样，但是这个类型转化应该没有改变p[0]的值，打印出来结果也一样，实在是搞不懂。", "相关的代码如下：", "\n", "问题相关代码", "\n", "#", "include", "<stdio.h>", "\n", "#", "include", "<stdlib.h>", "\n\n", "void", " ", "main", "()", "\n", "{\n    \n    ", "char", " p[] =", "\"123\"", ";\n    ", "char", " s = ", "'0'", ";\n    \n    ", "// '1' - '0'", "\n    ", "int", " m1 = (", "int", ")(((", "int", " *)p[", "0", "]) - s);\n    ", "int", " m2 = (", "int", ")(p[", "0", "] - s);\n    ", "printf", "(", "\"m1:%d , m2:%d\\n\"", ",m1,m2);\n    \n    m1 = (", "int", ")(", "int", " *)p[", "0", "] - (", "int", ")s;\n    ", "printf", "(", "\"m1:%d\\n\"", ",m1);\n    \n    m1 = (", "int", " *)p[", "0", "] - (", "int", " *)s;\n    ", "printf", "(", "\"m1:%d\\n\"", ",m1);\n    \n    ", "return", ";\n}\n", "\n", "运行结果", "\n", "m1", ":-", "143", " , m2:", "1", "\n", "m1", ":", "1", "\n", "m1", ":", "0", "\n", "\n", "给s强行变成int*，结果反而变成0了，真是搞不懂，指针对我来说果然还是太难了..."]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Z&amp;#61;&amp;#61;null是表示文本框不存在&amp;#xff0c;Z.equals(&amp;#34;&amp;#34;)表示文本框里面没有输入数据。&lt;/p&gt;\n\n&lt;p&gt;if (Z !&amp;#61; null) &lt;/p&gt;\n\n&lt;p&gt;改为&lt;/p&gt;\n\n&lt;p&gt;if (Z !&amp;#61; null &amp;amp;&amp;amp; !Z.equals(&amp;#34;&amp;#34;)){&lt;!-- --&gt;&lt;/p&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["jsp的if判断问题", ["\n", "<body>\n\t<form action=\"text2.jsp\" method=\"post\">\n\t\t<table width=\"\" border=\"1\" align=\"center\" cellspacing=\"1\"\n\t\t\tcellpadding=\"1\">\n\t\t\t<tr>\n\t\t\t\t<td>存款总额</td>\n\t\t\t\t<td><input name=\"Z\">元</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>存款期限</td>\n\t\t\t\t<td><select name=\"year\">\n\t\t\t\t\t\t<option value=\"1\">一年</option>\n\t\t\t\t\t\t<option value=\"2\">二年</option>\n\t\t\t\t\t\t<option value=\"3\">三年</option>\n\t\t\t\t</select></td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>币种</td>\n\t\t\t\t<td><input type=\"radio\" name=\"BZ\" value=\"RMB\">人民币 <input\n\t\t\t\t\ttype=\"radio\" name=\"BZ\" value=\"DOL\">美元</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"2\" align=\"center\"><input type=\"submit\" value=\"提交\"\n\t\t\t\t\tname=\"submit\">\n\t\t\t</tr>\n\t\t\t<%\n\t\t\t\tdouble LL = 0;\n\t\t\t\tdouble LX = 0;\n\t\t\t\tint years = 0;\n\t\t\t\tdouble z = 10000;\n\t\t\t\tString BZ = request.getParameter(\"BZ\");\n\t\t\t\tString year = request.getParameter(\"year\");\n\t\t\t\tif (year != null) {\n\t\t\t\t\tyears = Integer.parseInt(year);\n\t\t\t\t}\n\t\t\t\tString Z = request.getParameter(\"Z\");\n\t\t\t\tif (Z != null) {\n\t\t\t\t\tz = Double.parseDouble(Z);\n\t\t\t\t}\n\t\t\t\tif (BZ != null) {\n\t\t\t\t\tif (BZ.equals(\"RMB\")) {\n\t\t\t\t\t\tswitch (years) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tLL = 0.0175;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tLL = 0.0225;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tLL = 0.0275;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (BZ.equals(\"DOL\")) {\n\t\t\t\t\t\tswitch (years) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tLL = 0.0035;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tLL = 0.0045;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tLL = 0.005;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t%>\n\t\t\t\t<%\n\t\t\t\tLX = z * LL * years;\n\t\t\t%>\n\t\t\t<tr align=\"center\">\n\t\t\t\t<td>年利率</td>\n\t\t\t\t<td><%=String.format(\"%.2f\", LL * 100)%>%</td>\n\t\t\t</tr>\n\t\t\t<tr align=\"center\">\n\t\t\t\t<td>利息</td>\n\t\t\t\t<td><%=String.format(\"%.2f\", LX)%>元</td>\n\t\t\t</tr>\n\t\t</table>\n\t</form>\n</body>", "\n\n", "为什么当存款总额为空时提交会被if语句判断为符合，进行强制类型转换导致报错", "\n\n", "\n\n"]], "Tag": "程序设计"}
{"Answer": "你这个两个输出的对象完全不一样啊，第一个输出集合的值，第二个数输出迭代器接口对象，不管你迭代多少次，都是同一个对象呀。", "Konwledge_Point": "强制类型转换", "Question": ["Java中迭代器对象的一个疑问", ["最近学习了Java的迭代器对象（iterator），它有一个方法是.next()，返回下一个，或者说游标刚刚经过的那一个元素，很好理解，但是使用的时候却让我有些疑惑", "\n完整代码如下", "\n\n", "\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        //1)创建一个String集合，并添加元素\n        Collection collection01 = new LinkedList();\n        collection01.add(\"123\");\n        collection01.add(\"456\");\n        collection01.add(\"789\");\n\n        //2)创建一个String的迭代器对象\n        Iterator<String> iterator01 = collection01.iterator();\n\n\n        //3)使用迭代器对象遍历集合\n        while(iterator01.hasNext()) {\n            String thisString = iterator01.next();//指向下一个元素\n            System.out.println(thisString + '\\t');\n        }\n\n\n    }\n", "\n\n", "当while中的代码是先新建一个String对象，然后把.next()的值赋值给String对象时，得到的结果是正常的输出值，但是如果while循环的写法是下面这种", "\n\n", "while(iterator01.hasNext()) {\n            iterator01.next();\n            System.out.println(iterator01.toString());\n        }\n", "\n\n", "得到的结果却是完整类名加哈希码，或者不用toString(),直接输出也是完整类名加哈希码，这是为什么呢，它在第一种写法里被强制类型转换了吗？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;完全可以啊&amp;#xff0c;你可以char p &amp;#61; (char )&amp;amp;a;但这没什么用。这段代码的作用是把a的前八位置为0&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为啥强制转换符不能转换char类型而是char *??", ["\n", "  int main(){\n    int a = 0x11223344;\n    char* p = (char *)&a;//此处不懂\n    *p = 0;\n    printf(\"%x\\n\", a)\n    return 0;\n}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为字符串的存储方式类似于数组&amp;#xff0c;如果想访问的话一般访问数组的基地址即可&amp;#xff0c;后面的元素用一个步长就可以轻松获取&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么都要进行（char*）转换，意义是什么？", ["\n", "\n", "char ", "getmonth( int n )", "{", "    switch(n)", "    {", "        case 1: return (char", ")\"January\";", "        case 2: return (char*)\"February\";", "        case 3: return (char*)\"March\";", "        case 4: return (char*)\"April\";", "        case 5: return (char*)\"May\";", "        case 6: return (char*)\"June\";", "        case 7: return (char*)\"July\";", "        case 8: return (char*)\"August\";", "        case 9: return (char*)\"September\";", "        case 10: return (char*)\"October\";", "        case 11: return (char*)\"November\";", "        case 12: return (char*)\"December\";", "        default: return NULL;", "    }", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/62433916624611.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么用集合存储FileReader类中read()方法返回的数值输出后内容不一致?", ["刚刚学到IO流的知识，了解到FileReader类中的read()方法可以读取文件，正常代码是用int类型去接受read()方法返回的数值，然后通过强制类型转换输出，那既然这样我直接使用字符集合来保存，并且输出为什么不行呢，我尝试了以后发现用这种方法输出的字符跟文件不一样，想了半天也不明白哪里出错了", "\n", "正常方法读取外部文件并输出:", "\n", "Demo.txt文件中的内容为:我是一个文本文档，用于测试数据的", "\n", "import", " java.io.*;\n", "public", " ", "class", " Demo{\n      FileReader fileReader = new FileReader(", "\"D:\\\\myfwy\\\\review\\\\src\\\\pers\\\\iostream\\\\demo.txt\"", ") \n      ", "int", " ", "data", " = fileReader.read();\n      ", "while", "(", "data", " ", "!= -1){", "\n           System.", "out", ".", "print", "((", "char", ") ", "data", ");\n           ", "data", " = fileReader.read();\n  }\n}\n", "\n", "运行结果为:我是一个文本文档，用于测试数据的", "\n", "我想的方法：", "\n", "import", " java.io.*;\n", "public", " ", "class", " Demo{\n      FileReader fileReader = ", "new", " FlieReader(\"D:\\\\myfwy\\\\review\\\\src\\\\pers\\\\iostream\\\\demo.txt\");\n      ArrayList<", "Character", "> readList = ", "new", " ArrayList<", "Character", "> ();\n      readList.", "add", "((", "char", ")fileReader.", "read", "());\n      ", "for", "(i = ", "0", ";fileReader.", "read", "() != ", "-1", ";i++){\n            ", "System", ".", "out", ".print(readList.", "get", "(i));\n            readList.", "add", "((", "char", ")fileReader.", "read", "());\n  }\n}\n", "\n", "运行结果为:我一文文，于试据", "\n", "为什么这样输出的内容跟文件原本的内容不一致，希望得到解决"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不用也可以&amp;#xff0c;主要是sqrt函数定义是 double sqrt(double)&amp;#xff0c;它的返回值类型为double&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么要把第九行sqrt()的返回值强转为float.a,b,c,s,area不都已经定义为float了吗", ["为什么要把第九行sqrt()的返回值强转为float.a,b,c,s,area不都已经定义为float了吗"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;晕&amp;#xff0c;这不是引用啊&amp;#xff0c;这是取地址符啊。就是取m1的地址&amp;#xff0c;然后转换成const char*指针&lt;br /&gt;&amp;amp;只有在定义变量的时候才是引用的意思&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C++：为什么这里需要使用引用？ofs.write((const char *)&m1, sizeof(Maker));", ["如题，为什么在ofs.write和ifs.read的时候需要添加引用？", "\n", "如果没有引用的话编译器报错：", "Error (active)        no suitable conversion function from \"Maker\" to \"const char *\" exist", "按照编译器报的错，加了引用就有转换的函数了?", "\n", "#", "define", " _CRT_SECURE_NO_WARNINGS", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<fstream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "Maker", " {\n", "public", ":\n    ", "Maker", "() = ", "default", ";\n    ", "Maker", "(", "const", " ", "char", " * name,", "int", " age) {\n        ", "strcpy", "(", "this", "->name, name);\n        ", "this", "->age = age;\n    }\n    ", "void", " ", "printM", "()", " ", "{\n        cout<<", "this", "->age<<", "\" \"", " << ", "this", "->name<< endl;\n    }\n", "public", ":\n    ", "char", " name[", "64", "];\n    ", "int", " age;\n};\n", "int", " ", "main", "()", "\n", "{\n    ", "Maker ", "m1", "(", "\"小林\"", ", ", "20", ")", ";\n    ", "Maker ", "m2", "(", "\"布林\"", ", ", "22", ")", ";\n    ofstream ofs;\n    ofs.", "open", "(", "\"test.dat\"", ", ios::out |ios::binary );\n    ", "if", " (!ofs.", "is_open", "()) {\n        cout << ", "\"打开文件失败\"", " << endl;\n    } \n    ofs.", "write", "((", "const", " ", "char", " *)&m1, ", "sizeof", "(Maker));", "//这里强制类型转换，会产生临时量", "\n    ofs.", "write", "((", "const", " ", "char", " *)&m2, ", "sizeof", "(Maker));\n    ofs.", "close", "();\n    ifstream ifs;\n    ifs.", "open", "(", "\"test.dat\"", ", ios::in | ios::binary);\n    ", "if", " (!ifs.", "is_open", "()) {\n        cout << ", "\"dakaiwenjianshibai\"", " << endl;\n    }\n    Maker m3;\n    Maker m4;\n    ifs.", "read", "((", "char", "*)&m3, ", "sizeof", "(Maker));\n    ifs.", "read", "((", "char", "*)&m4, ", "sizeof", "(Maker));\n    m3.", "printM", "();\n    m4.", "printM", "();\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;There are several PHP bugs about it:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\"http://bugs.php.net/bug.php?id=45346\" rel=\"noreferrer\"&gt;http://bugs.php.net/bug.php?id=45346&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://bugs.php.net/bug.php?id=51635\" rel=\"noreferrer\"&gt;http://bugs.php.net/bug.php?id=51635&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\"http://bugs.php.net/bug.php?id=46758\" rel=\"noreferrer\"&gt;http://bugs.php.net/bug.php?id=46758&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;The same things happens here:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;$obj-&amp;gt;{0} = \"hello\";\n$arr = (array)$obj;\necho $arr[0];\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;It happens because the \"0\" is used as string array key, whereas $arr[0] searches for the integer array key. It is documented in the PHP documentation simply by stating: &lt;em&gt;integer properties are unaccessible&lt;/em&gt; (&lt;a href=\"http://docs.php.net/manual/en/language.types.array.php#language.types.array.casting\" rel=\"noreferrer\"&gt;link&lt;/a&gt;).&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["PHP：强制转换为（数组）和返回类型：数组不一样？", ["\n\n", "I have following problem in PHP:", "\n\n", "print_r()", " says it's the same, ", "gettype()", " says same type, but the last output works not for both cases although they should be the same!", "\n\n", "This looks very strange to me.", "\n\n", "code and output:", "\n\n", "$docdatau = get_object_vars(json_decode($docdata));\n$docdatau2 = (array)json_decode($docdata);\n\necho \"1\n\";\necho gettype($docdatau);\necho \"\n\";\necho \"--------------------------------------\n\";\nprint_r($docdatau);\necho \"--------------------------------------\n\";\n\necho \"2\n\";\necho gettype($docdatau2);\necho \"\n\";\necho \"--------------------------------------\n\";\nprint_r($docdatau2);\n\necho \"out1\n\";\necho \"--------------------------------------\n\";\nprint_r($docdatau[0]);\necho \"out2\n\";\necho \"--------------------------------------\n\";\nprint_r($docdatau2[0]);\n", "\n\n", "The output:", "\n\n", "1\narray\n--------------------------------------\nArray\n(\n\n    [0] => stdClass Object\n        (\n            [produkt] => Produkt 2\n            [laufzeit] => 24\n            [addtext] => sdsd\n            [provision] => 39\n        )\n\n    [1] => stdClass Object\n        (\n            [produkt] => Produkt 1\n            [laufzeit] => \n            [addtext] => \n            [provision] => 0\n        )\n\n)\n--------------------------------------\n2\narray\n--------------------------------------\n\nArray\n(\n\n    [0] => stdClass Object\n        (\n            [produkt] => Produkt 2\n            [laufzeit] => 24\n            [addtext] => sdsd\n            [provision] => 39\n        )\n\n    [1] => stdClass Object\n        (\n            [produkt] => Produkt 1\n            [laufzeit] => \n            [addtext] => \n            [provision] => 0\n        )\n\n)\nout1\n--------------------------------------\nstdClass Object\n(\n    [produkt] => Produkt 2\n    [laufzeit] => 24\n    [addtext] => sdsd\n    [provision] => 39\n)\nout2\n--------------------------------------\n--------------------------------------\n", "\n\n", "out1", " and ", "out2", " should produce the same results but don't.", "\n\n", "Perhaps anybody has a hint for me?", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/670392486746123.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么往重写了equals和hashCode方法的Set集合里成功添加了相同的元素？", ["\npackage pace;\n\n", "import", " com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;\n\n", "import", " java.util.HashSet;\n", "import", " java.util.Iterator;\n\n", "class", " ", "testHas", "{\n    ", "public", " ", "final", " ", "int", " count;\n    ", "public", " ", "testHas", "(", "int", " count)", "{\n        ", "this", ".count = count;\n    }\n    ", "public", " ", "String", " ", "toString", "()", "{\n        ", "return", " ", "\"testHas[count: \"", " + count + ", "\"]\"", ";\n    }\n    @", "Override\n    ", "public", " ", "int", " ", "hashCode", "()", "{\n        ", "return", " ", "this", ".count;\n    }\n    @", "Override\n    ", "public", " ", "boolean", " ", "equals", "(Object obj)", "{\n        ", "if", "(", "this", " == obj){   ", "// 判断是否为同一个对象，自己与自己比较", "\n            ", "return", " ", "true", ";\n        }\n        ", "else", " ", "if", "( obj != null && obj.", "getClass", "() == testHas.", "class", "){  ", "// 判断两个对象是否出自同一个（运行时）类", "\n            testHas temp = (testHas) obj; ", "// 强制类型转换", "\n            ", "return", " ", "this", ".", "toString", "() == temp.", "toString", "();\n        }\n        ", "return", " ", "false", ";\n    }\n}\n", "public", " ", "class", " ", "HashSetclass", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args)", "{\n        HashSet set = ", "new", " ", "HashSet", "();\n        set.", "add", "(", "new", " ", "testHas", "(", "1", "));\n        set.", "add", "(", "new", " ", "testHas", "(", "2", "));\n        set.", "add", "(", "new", " ", "testHas", "(", "3", "));\n        set.", "add", "(", "new", " ", "testHas", "(", "4", "));\n        set.", "add", "(", "new", " ", "testHas", "(", "4", "));\n        System.out.", "println", "(set);  ", "// [testHas[count: 1], testHas[count: 2], testHas[count: 3], testHas[count: 4], testHas[count: 4]", "\n    }\n}\n\n", "\n", "如图，我重复向Set集合里add了相同count变量的testHas对象，然后输出结果里还存在它，为什么？刚学，求解答", "\n", "// 结果", "\n[testHas[", "count", ": ", "1", "], testHas[", "count", ": ", "2", "], testHas[", "count", ": ", "3", "], testHas[", "count", ": ", "4", "], testHas[", "count", ": ", "4", "]\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;我是有问必答小助手&amp;#xff0c;非常抱歉&amp;#xff0c;本次您提出的有问必答问题&amp;#xff0c;技术专家团超时未为您做出解答&lt;br /&gt; &lt;br /&gt;&lt;br /&gt;本次提问扣除的有问必答次数&amp;#xff0c;已经为您补发到账户&amp;#xff0c;我们后续会持续优化&amp;#xff0c;扩大我们的服务范围&amp;#xff0c;为您带来更好地服务。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["stm32寄存器问题？", ["下面讲的有几点不懂：1 代码5-2中“GPIOH_BASE+0x14”怎么得来的？2 代码5-2和5-3差一个*号，是不是代码5-2少写了？", "比如，我们找到 GPIOH 端口的输出数据寄存器 ODR 的地址是 0x4002 1C14（至于这", "个地址如何找到可以先跳过，后面我们会有详细的讲解），ODR 寄存器是 32bit，低 16bit", "有效，对应着 16 个外部 IO，写 0/1 对应的的 IO 则输出低/高电平。现在我们通过 C 语言指", "针的操作方式，让 GPIOH 的 16 个 IO 都输出高电平，具体见代码 5-1。", "代码 5-1 通过绝对地址访问内存单元", "\n", "1 ", "// GPIOH 端口全部输出 高电平\n", "2 ", "*(unsigned ", "int", "*)(", "0", "x4002 ", "1", "C14) = ", "0", "xFFFF;\n\n", "\n", "0x4002 1C14 在我们看来是 GPIOH 端口 ODR 的地址，但是在编译器看来，这只是一", "个普通的变量，是一个立即数，要想让编译器也认为是指针，我们得进行强制类型转换，", "把它转换成指针，即(unsigned int *)0x4002 1C14，然后再对这个指针进行 * 操作。", "刚刚我们说了，通过绝对地址访问内存单元不好记忆且容易出错，我们可以通过寄存", "器的方式来操作，具体见代码 5-2。", "代码 5-2 通过寄存器别名方式访问内存单元", "\n", "1 ", "// GPIOH 端口全部输出 高电平\n", "2 ", "#define GPIOH_ODR   (unsigned ", "int", "*)(GPIOH_BASE+", "0", "x14)\n", "3 ", "* GPIOH_ODR = ", "0", "xFF;\n\n", "\n", "为了方便操作，我们干脆把指针操作“*”也定义到寄存器别名里面，具体见代码 5-3。", "代码 5-3 通过寄存器别名访问内存单元", "\n", "\n", "1 ", "// GPIOH 端口全部输出 高电平\n", "2 ", "#define GPIOH_ODR *(unsigned ", "int", "*)(GPIOH_BASE+", "0", "x14)\n", "3 ", "GPIOH_ODR = ", "0", "xFF;\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在这个例子中&amp;#xff0c;变量p的类型为float&amp;#xff0c;而0.1的类型为double。在执行p&amp;#43;p*0.1时&amp;#xff0c;编译器会将p自动转换为double类型&amp;#xff0c;然后进行乘法运算。乘法运算的结果是一个double类型的值&amp;#xff0c;然后再将其与p相加。由于double类型的值在内存中占用的空间比float类型的值多&amp;#xff0c;因此在将double类型的值转换为float类型的值时&amp;#xff0c;精度可能会丢失。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["float类型为什么进行强制转换", ["想知道为什么已经都设为float类型了，在if语句中还要强制转换才不报错误？", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;printf(&amp;#34;a[%d] &amp;#61; %d\\n&amp;#34;**,****&lt;strong&gt;pt2[i]); 这一行报错&amp;#xff0c;缺了a[%d]   这个%d 的参数&amp;#xff0c;&lt;/strong&gt;pt2[i] 表达式也有误&amp;#xff0c;修改如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-comment\"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;\n&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; main()\n{\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; a[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;] &amp;#61; { &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;,&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; }; &lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义一个一维数组 a\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;(*pt1)[&lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;];&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt; 步长为 &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; 的数组指针&amp;#xff0c;即 prt 指向的数组里有 &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt; 个元素  \n    pt1 &amp;#61; &amp;amp;a;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;给数组指针赋值&amp;#xff1a;数组的地址\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;** pt2;&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;定义一个指针的指针&amp;#xff1b;\n    pt2 &amp;#61; (&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt;**)&amp;amp;pt1;&lt;span class=\"hljs-regexp\"&gt;//p&lt;/span&gt;t2存储pt1这个变量的地址\n    &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (; i &amp;lt; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;; i&amp;#43;&amp;#43;) {\n        &lt;span class=\"hljs-keyword\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;a[%d] &amp;#61; %d\\n&amp;#34;&lt;/span&gt;, i, **pt2 &amp;#43; i);&lt;span class=\"hljs-regexp\"&gt;//&lt;/span&gt;*(*pt2 &amp;#43; i));\n        &lt;span class=\"hljs-regexp\"&gt;//prin&lt;/span&gt;tf(&lt;span class=\"hljs-string\"&gt;&amp;#34;a[%d] &amp;#61; %d\\n&amp;#34;&lt;/span&gt;,(**pt2)[i]);\n    }\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["请问下面的代码为什么无法打印出依次数组元素的值？", ["在研究指针的指针过程中，用一个数组的指针pt1指向数组，再用一个指针指pt2向这个指针，为什么通过pt2无法获取数组元素的值", "\n", "int  a[5]={ 1,2,3,4,5 };    //定义一个一维数组 a", "\n", "         ", "int", "  (*pt1)[", "5", "];      ", "//", " 步长为 ", "5", " 的数组指针，即 prt 指向的数组里有 ", "5", " 个元素  \n         pt1=&a;", "//", "给数组指针赋值：数组的地址\n         ", "int", " **pt2;", "//", "定义一个指针的指针；\n         pt2 =（", "int", " **)&pt1;", "//p", "t2存储pt1这个变量的地址\n         ", "int", " i =", "0", ";\n         ", "for", "(； i < ", "5", ";i++){\n\n                 ", "printf", "(", "\"a[%d] = %d\\n\"", ",(**pt2)[i]);\n         }\n", "\n", "printf(\"a[%d] = %d\\n\",**pt2[i]); 这一行报错：大概意思“[\"前面既不是指针，也不是变量，也不是vector;", "\n", "(", "pt2)[i])就表示数组中各元素的值，pt2中存储的是pt1的地址，*pt2就表示取得pt1这个变量的地址对应的值，它就是数组a的地址，", "pt2就表示这个数组，自然最后(**pt2)[i]就能表示数组元素的值；", "\n", "难道是因为指针的指针定义的时候没有指定步长，之后给它赋值的时候又进行了强制类型转换成了步长为一个元素的指针，所以最终**pt2无法代表数组；解决的办法是将pt2的步长也定义为5吗 ,int **pt2[5]？这样是不是太麻烦了，我就想用一下指针的指针求出指针所指向的变量的值；"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;treeSet 和 HashSet 存放的元素都是唯一的&amp;#xff0c; HashSet 是根据equals 和 hashCode 来判断元素是否重读  而 treeSet  是根据compareTo 来判断 大于0 放左边小于0 放右边 等于0 判断为相同忽略&lt;br /&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/938319377746136.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["这段代码，为什么用TreeSet自然排序后，和用HashSet呈现不一样的结果", ["我的理解是：TreeSet可以进行自定义排序，但是内容应该和选用HashSet是一样的。但是结果是：", "使用TreeSet打印集合少了一个（我认为少了个元素[student 2020124 is 19 years old]）", "。是不是和我写的compareTo方法有关系？", "\n", "使用HashSet：", "\n", "import", " java.util.HashSet;\n", "import", " java.util.TreeSet;\n\n", "class", " ", "testTre", "{\n    ", "public", " ", "int", " age;\n    ", "public", " ", "final", " String id;\n    ", "public", " ", "testTre", "(String id, ", "int", " age)", "{\n        ", "this", ".id = id;\n        ", "this", ".age = age;\n    }\n    ", "@Override", "\n    ", "public", " String ", "toString", "()", "{\n        ", "return", " ", "\"[student \"", " + ", "this", ".id + ", "\" is \"", "+ ", "this", ".age + ", "\" years old]\"", ";\n    }\n", "//    @Override", "\n", "//    public int compareTo(Object obj){      //  自然排序", "\n", "//        testTre temp = (testTre) obj;", "\n", "////        if(this.age < temp.age)", "\n", "////            return -1;", "\n", "////        else", "\n", "////            return 1;", "\n", "//        if(temp.age == this.age)", "\n", "//            System.out.println(\"相同\");", "\n", "//        return this.age > temp.age ? 1 : this.age < temp.age ? -1 : 0;", "\n", "//    }", "\n    ", "@Override", "\n    ", "public", " ", "boolean", " ", "equals", "(Object obj)", "{\n        ", "if", "(", "this", " == obj){   ", "// 判断是否为同一个对象，即自己与自己比较", "\n            ", "return", " ", "true", ";\n        }\n        ", "else", " ", "if", "( obj != ", "null", " && obj.getClass() == testTre.class){  ", "// 判断两个对象是否出自同一个（运行时）类", "\n            ", "testTre", " ", "temp", " ", "=", " (testTre) obj; ", "// 强制类型转换", "\n            ", "return", " temp.id == ", "this", ".id;\n        }\n        ", "return", " ", "false", ";\n    }\n    ", "@Override", "\n    ", "public", " ", "int", " ", "hashCode", "()", "{\n        ", "return", " Integer.valueOf(", "this", ".id).intValue();\n    }\n}\n", "public", " ", "class", " ", "Treeset", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", "{\n        ", "HashSet", " ", "Ts", " ", "=", " ", "new", " ", "HashSet", "();\n        Ts.add(", "new", " ", "testTre", "(", "\"2020106\"", ",", "12", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020108\"", ",", "19", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020208\"", ",", "15", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020104\"", ",", "22", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020124\"", ",", "19", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020124\"", ",", "19", "));\n\n        System.out.println(Ts);\n    }\n}\n", "// HashSet:", "\n", "//[[student 2020108 is 19 years old], [student 2020124 is 19 years old],", "\n", "// [student 2020106 is 12 years old], [student 2020104 is 22 years old],", "\n", "// [student 2020208 is 15 years old]]", "\n", "\n", "使用TreeSet：", "\n", "import", " java.util.HashSet;\n", "import", " java.util.TreeSet;\n\n", "class", " ", "testTre", " ", "implements", " ", "Comparable", "{\n    ", "public", " ", "int", " age;\n    ", "public", " ", "final", " String id;\n    ", "public", " ", "testTre", "(String id, ", "int", " age)", "{\n        ", "this", ".id = id;\n        ", "this", ".age = age;\n    }\n    ", "@Override", "\n    ", "public", " String ", "toString", "()", "{\n        ", "return", " ", "\"[student \"", " + ", "this", ".id + ", "\" is \"", "+ ", "this", ".age + ", "\" years old]\"", ";\n    }\n    ", "@Override", "\n    ", "public", " ", "int", " ", "compareTo", "(Object obj)", "{      ", "//  自然排序", "\n        ", "testTre", " ", "temp", " ", "=", " (testTre) obj;\n", "//        if(this.age < temp.age)", "\n", "//            return -1;", "\n", "//        else", "\n", "//            return 1;", "\n", "//        if(temp.age == this.age)", "\n", "//            System.out.println(\"相同\");", "\n        ", "return", " ", "this", ".age > temp.age ? ", "1", " : ", "this", ".age < temp.age ? -", "1", " : ", "0", ";\n    }\n    ", "@Override", "\n    ", "public", " ", "boolean", " ", "equals", "(Object obj)", "{\n        ", "if", "(", "this", " == obj){   ", "// 判断是否为同一个对象，即自己与自己比较", "\n            ", "return", " ", "true", ";\n        }\n        ", "else", " ", "if", "( obj != ", "null", " && obj.getClass() == testTre.class){  ", "// 判断两个对象是否出自同一个（运行时）类", "\n            ", "testTre", " ", "temp", " ", "=", " (testTre) obj; ", "// 强制类型转换", "\n            ", "return", " temp.id == ", "this", ".id;\n        }\n        ", "return", " ", "false", ";\n    }\n    ", "@Override", "\n    ", "public", " ", "int", " ", "hashCode", "()", "{\n        ", "return", " Integer.valueOf(", "this", ".id).intValue();\n    }\n}\n", "public", " ", "class", " ", "Treeset", " {\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", "{\n        ", "TreeSet", " ", "Ts", " ", "=", " ", "new", " ", "TreeSet", "();\n        Ts.add(", "new", " ", "testTre", "(", "\"2020106\"", ",", "12", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020108\"", ",", "19", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020208\"", ",", "15", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020104\"", ",", "22", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020124\"", ",", "19", "));\n        Ts.add(", "new", " ", "testTre", "(", "\"2020124\"", ",", "19", "));\n\n        System.out.println(Ts);\n    }\n}\n", "// TreeSet:", "\n", "// [[student 2020106 is 12 years old], [student 2020208 is 15 years old],", "\n", "//  [student 2020108 is 19 years old], [student 2020104 is 22 years old]]", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;scanf(&amp;#34;%d&amp;#34;, (p &amp;#43; m * i&amp;#43;j));和printf(&amp;#34;%d &amp;#34;, *(p &amp;#43; i * m &amp;#43; j));这里计算错误了&amp;#xff0c;应该是&lt;/p&gt;\n\n&lt;p&gt;scanf(&amp;#34;%d&amp;#34;, (p &amp;#43; n * i&amp;#43;j));和printf(&amp;#34;%d &amp;#34;, *(p &amp;#43; i * n &amp;#43; j));&lt;/p&gt;\n\n&lt;p&gt;完整代码如下&amp;#xff0c;如有帮助&amp;#xff0c;请采纳一下&amp;#xff0c;谢谢。&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;stdlib.h&amp;gt;\nint main()\n{\n\tint i,j, m, n;\t\n\tprintf(&amp;#34;Please input the number of m and n;&amp;#34;);\n\tscanf(&amp;#34;%d %d&amp;#34;, &amp;amp;m, &amp;amp;n);\n\tint *p &amp;#61; (int*)malloc(sizeof(int) * m * n);//p是一个指向int形的指针&amp;#xff0c;malloc函数返回类型为void*,即指向void形的指针使用int*类型进行强制类型转换。动态分配内存以实现用户输入数组大小分配数组内存的效果\n\tfor (i &amp;#61; 0; i &amp;lt; m; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor(j&amp;#61;0;j&amp;lt;n;j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tscanf(&amp;#34;%d&amp;#34;, (p &amp;#43; n* i&amp;#43;j));  //修改1\n\t\t}\n\t}\t//printf(&amp;#34;%d\\n&amp;#34;, *(p &amp;#43; 3));\n\tfor (i &amp;#61; 0; i &amp;lt; m; i&amp;#43;&amp;#43;)\n\t{\n\t\tfor (j &amp;#61; 0; j &amp;lt; n; j&amp;#43;&amp;#43;)\n\t\t{\n\t\t\tprintf(&amp;#34;%d &amp;#34;, *(p &amp;#43; i * n &amp;#43; j));//修改2\n\t\t}\n\t\tprintf(&amp;#34;\\n&amp;#34;);\n\t}\n\tfree(p); //修改3&amp;#xff0c;释放内存空间\n\treturn 0;\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C语言生成用户输入大小的数组", ["\n", "int main()\n{\n\tint i,j, m, n;\t\n\tprintf(\"Please input the number of m and n;\");\n\tscanf(\"%d %d\", &m, &n);\n\tint *p = (int*)malloc(sizeof(int) * m * n);//p是一个指向int形的指针，malloc函数返回类型为void*,即指向void形的指针使用int*类型进行强制类型转换。动态分配内存以实现用户输入数组大小分配数组内存的效果\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor(j=0;j<n;j++)\n\t\t{\n\t\t\tscanf(\"%d\", (p + m * i+j));\n\t\t}\n\t}\t//printf(\"%d\\n\", *(p + 3));\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tfor (j = 0; j < n; j++)\n\t\t{\n\t\t\tprintf(\"%d \", *(p + i * m + j));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}", "\n\n", "代码如上，写一些特定的组合就会出现奇怪的结果，但输入其他组合也会显示正确，到底是为什么?", "\n\n", "错误输出", "\n\n", "\n\n", "正确输出", "\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你抓回来的数据比如name,是这样的[name,],不是字符串就是个列表&amp;#xff0c;你把列表再往表格里写&amp;#xff0c;当然写不进去&amp;#xff0c;你爬下来的比如name之类用join都给变成单个字符串&amp;#xff0c;就能写进去了&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["在写爬虫运用xlwt库将网页信息写入execl中遇到的问题", ["问题遇到的现象和发生背景", "\n", "使用xlwt库将爬虫获取当当网的图书信息写入excel中时遇到了数据格式错误无法写入的问题", "\n", "问题相关代码", "\n", "import requests", "import xlwt", "\n", "def dangdang(url):", "    res = requests.get(url, headers=headers)", "    res.encoding =res.apparent_encoding", "    book = xlwt.Workbook(encoding='utf-8')", "    sheet = book.add_sheet('Book')", "    cont =0", "    dom = etree.HTML(res.text, etree.HTMLParser())", "\n", "book_infos = dom.xpath(", "'//li[starts-with(@class, \"line\")]'", ")\n\n", "for", " book_info ", "in", " book_infos:\n    ", "date", " = []\n  ...................................（此处使用了xpath语句对网页内容进行抓取）\n    ", "date", ".append(name), ", "date", ".append(now_price), ", "date", ".append(pre_price), ", "date", ".append(author), ", "date", ".append(time), ", "date", ".append(publisher), ", "date", ".append(comment), ", "date", ".append(detail)\n    ", "# 遍历输入数据到工作簿里面", "\n    ", "for", " i ", "in", " range(cont, cont + ", "1", "):\n        ", "for", " a, b ", "in", " enumerate(", "date", "):", "# 使用enumerate函数返回列表的索引和对应的值", "\n            sheet.write(i,a,b)  ", "# 将数据写入到工作簿里面", "\n    cont += ", "1", "  ", "# 循环结束行数加一", "\n    info = {\n        ", "'书名'", ": name,\n        ", "'折扣价'", ": now_price,\n        ", "'定价'", ": pre_price,\n        ", "'作者'", ": author,\n        ", "'出版日期'", ": out_date.replace(", "' /'", ", ", "''", "),\n        ", "'出版社'", ": publisher,\n        ", "'评论数'", ": comment,\n        ", "'简介'", ": detail\n    }\n    ", "print", "(info)\nbook.save(", "'Book.xls'", ")\n", "\n", "运行结果及报错内容", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "曾在CSDN中搜索知道是数据格式问题，但本人语法功底较差，在使用了几次不同的数据强制类型转换后问题仍未得到解决，故在此求各位指点。", "\n", "我想要达到的结果", "\n"]], "Tag": "程序设计"}
{"Answer": "System.Xml.XmlCDataSection用XmlNode接收，而不是XmlElement\r\n也就是foreach (XmlElement node in root)这里", "Konwledge_Point": "强制类型转换", "Question": ["怎么解析这个xml所有的InnerText", ["<__InSite ", "version=\"1.1\" __encryption=\"2\">", "\n<", "session>", "\n<__useSession>", "\n<__name>", "\n<![CDATA[ CamstarAdmin ]]>", "\n</__name>", "\n<![CDATA[ b3014ec6-e2fd-4687-95f3-3f12ff5aca77 ]]>", "\n</__useSession>", "\n</__session>", "\n<__service ", "serviceType=\"MfgOrderMaint\">", "\n<", "utcOffset>", "\n<![CDATA[ 08:00:00 ]]>", "\n</__utcOffset>", "\n<__inputData>", "\n<__listItem/>", "\n</__inputData>", "\n<__perform>", "\n<__eventName>", "\n<![CDATA[ New ]]>", "\n</__eventName>", "\n</__perform>", "\n<__requestData>", "\n</__requestData>", "\n</__service>", "\n</__InSite>", "\n\n", "代码：", "\nprivate void toolStripSaveas_Click(object sender, EventArgs e)", "\n        {", "\n            //初始化一个xml文档对象", "\n            XmlDocument xmldoc = new XmlDocument();", "\n            //加载xml文档", "\n            xmldoc.LoadXml(this.txtXML.Text);", "\n            //获取根节点的所有子节点", "\n            XmlNodeList root = xmldoc.DocumentElement.ChildNodes;", "\n            GetAllNodes(root);", "\n        }", "\n        public void GetAllNodes(XmlNodeList root)", "\n        {", "\n\n", "            foreach (XmlElement node in root)\n            {\n                //获取节点名字、值\n                txtvalue.Text = txtvalue.Text + node.InnerText + \"\\r\\n\";\n                if (node.ChildNodes[0] is XmlText)\n                {\n                    continue;\n                }\n                else\n                {\n                    GetAllNodes(node.ChildNodes);\n                }\n            }\n\n    }\n", "\n\n", "报错：", "\n无法将类型为“System.Xml.XmlCDataSection”的对象强制转换为类型“System.Xml.XmlElement”。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;pre&gt;&lt;code&gt;func main() {\n    f := Foo{\"test\"}\n    Exported(f)\n}\n\ntype Foo struct{\n    Bar string\n}\n\nfunc Exported (v interface{}){\n    t, ok := v.(Foo)\n    if !ok {\n        log.Fatal(\"boom\")\n    }\n    fmt.Println(t.Bar)\n}\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["将界面{}强制转换为类型", ["\n\n", "Say I have something like this:", "\n\n", "type Foo struct{\n   Bar string\n}\n\nfunc Exported (v interface{}){\n // cast v to Foo\n}\n", "\n\n", "is there a way to cast v to Foo in the Exported func?", "\n\n", "I tried a type assertion like so:", "\n\n", "func Exported (v interface{}){\n\n  v, ok := v.(Foo)\n\n  if !ok {\n    log.Fatal(\"oh fuk\")\n  }\n\n  // but v.Bar is not available here tho ??\n\n}\n", "\n\n", "The problem is that if I try to access v.Bar after the assertion, it doesn't compile.", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;太长不看emm&lt;br /&gt;一般思路就是遍历棋子,对每个棋子,扫描其右上,右,右下,下&lt;br /&gt;四个方向是否有至少五个连续棋子,因为找到一组即可,所以找到了就返回&lt;br /&gt;扫描一遍后没找到就是没人胜利&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Java Gui五子棋输赢判断问题", ["package sample;", "\n", "import javax.swing.", ";", "import java.awt.", ";", "\n", "public class MyJPanel extends JPanel{", "    //初始化chessState 为15*15的二维数组", "    public int[][]chessState = new int[15][15];", "    public static int flag = 1;", "    public boolean isBlack = true;", "\n", "public void paint(Graphics g) {\n        super.paint(g);\n        ", "//强制类型转换得到Graphics子类Graphics2D对象", "\n        Graphics2D g2 = (Graphics2D)g;", "//又得到一支笔", "\n        ", "//先JPanel绘制背景图片", "\n        ", "// g2.drawImage(image,0,0,1600,900,null);", "\n        ", "//设置画笔颜色", "\n        g2.set", "Color(Color.CYAN)", ";\n        ", "//填充规定区域", "\n        g2.fill3", "DRect(50, 50, 700, 700, ", "true", ")", ";\n\n        ", "//再设置画笔颜色，画直线", "\n        g2.set", "Color(Color.", "black", ")", ";\n        ", "//设置画出直线的宽度", "\n        g2.set", "Stroke(", "new", " BasicStroke(3)", ");\n\n        ", "//绘制下棋区域", "\n        ", "for", "(", "int", " i = ", "1", ";i < ", "16", ";i ++) {\n            g2.draw", "Line(50,50", "*", "i", ",750,50", "*", "i", " )", ";\n        }\n        ", "for", "(", "int", " i = ", "1", ";i < ", "16", ";i ++) {\n            g2.draw", "Line(50", "*", "i", ",50,50", "*", "i", ",750 )", ";\n        }\n\n        ", "//画外框", "\n        ", "//设置画笔宽度", "\n        g2.set", "Stroke(", "new", " BasicStroke(5)", ");\n        g2.draw", "Line(25,25,775, 25)", ";\n        g2.draw", "Line(25,775,775, 775)", ";\n        g2.draw", "Line(25,25,25, 775)", ";\n        g2.draw", "Line(775,25,775, 775)", ";\n\n        ", "//画四个黑色圆", "\n        g2.fill", "Oval(240, 240, 20, 20)", ";\n        g2.fill", "Oval(540, 240, 20, 20)", ";\n        g2.fill", "Oval(240, 540, 20, 20)", ";\n        g2.fill", "Oval(540, 540, 20, 20)", ";\n\n        ", "//填充框框与下棋区域之间的区域", "\n        g2.set", "Color(", "new", " Color(176, 166, 100, 254)", ");", "//设置画笔颜色", "\n        g2.fill", "Rect(26, 26, 749, 23)", ";\n        g2.fill", "Rect(26, 49, 23, 725)", ";\n        g2.fill", "Rect(49, 752, 725, 23)", ";\n        g2.fill", "Rect(752, 49, 23, 703)", ";\n        ", "//检查chessState状态，如果棋盘位置游子则打印对应的棋子", "\n        ", "for", "(", "int", " i = ", "0", ";i<", "15", ";i++){\n            ", "for", "(", "int", " j=", "0", ";j<", "15", ";j++){\n                ", "if", "(chessState", "[", "i", "]", "[", "j", "]", "==", "1", "){\n                    g2.set", "Color(Color.BLACK)", ";\n                    ", "//计算落子位置", "\n                    ", "int", " pos_x = ", "50", "+i*", "50", ";\n                    ", "int", " pos_y = ", "50", "+j*", "50", ";\n          怎么再实现悔棋和五子棋输赢判断      \n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个可以这么理解&amp;#xff0c;在java语言中&amp;#xff0c;它是支持自动转型的&amp;#xff0c;但只能向上转&amp;#xff0c;因为向上转型一定是安全的。而向下转隐含一定的风险&amp;#xff08;可能会导致类型转换异常&amp;#xff09;&amp;#xff0c;同时也是为了在比较的时候更加精确的指导两者的类型&amp;#xff0c;因此需要在代码中进行类型判断。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-meta\"&gt;&amp;#64;Override&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; boolean equals(Object obj) {\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt; &amp;#61;&amp;#61; obj)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (obj &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;)\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (getClass() !&amp;#61; obj.getClass())\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        Person other &amp;#61; (Person) obj;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (age &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (other.age !&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;)\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!age.equals(other.age))\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (name &amp;#61;&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;) {\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (other.name !&amp;#61; &lt;span class=\"hljs-literal\"&gt;null&lt;/span&gt;)\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (!name.equals(other.name))\n            &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;false&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-literal\"&gt;true&lt;/span&gt;;\n    }\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Equals重写为啥要强制转换同类型", ["为啥要判断o值与Person类是否一致，不理解", "为啥要进行类型强转也不理解", "这个方法不就是在相同的地址值里面判断其内容是否一致么", "\n", "求解"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;注意operator后面的空格&amp;#xff0c;我简单写了一个例子&amp;#xff08;你的定义的简化版&amp;#xff09;&amp;#xff0c;你自己完善了。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title class_\"&gt;RMB&lt;/span&gt; {\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt;:\n    &lt;span class=\"hljs-built_in\"&gt;RMB&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; yuan &amp;#61; &lt;span class=\"hljs-number\"&gt;0.0f&lt;/span&gt;) : &lt;span class=\"hljs-built_in\"&gt;m_yuan&lt;/span&gt;(yuan) {}\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;toFloat&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; m_yuan; }\n    &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;explicit&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;float&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;/span&gt;{ &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; &lt;span class=\"hljs-built_in\"&gt;toFloat&lt;/span&gt;(); }\n\n&lt;span class=\"hljs-keyword\"&gt;private&lt;/span&gt;:\n    &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; m_yuan;\n};\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["内置数据类型可以进行类型强制转换，类也可以进行同样的转换。", ["通过定义类型转换函数实现的，它只能是类的成员函数，格式为：类名：：operator转换后的数据类型（）{}", "题目：定义人名币类，数据成员包括元角分且均为整型。类型转换函数将人民币强制转换为浮点数。", "以下为我的代码", "\n", "以下为代码报错内容", "\n"]], "Tag": "程序设计"}
{"Answer": "TreeSet对象每次add的时候，都会把要add的对象和目前set里的（部分）对象比较，以便让新增的元素放在合适的位置上。但是和哪个先比较，比较几次？我们定不了，只要JVM认为新加入的元素到了合适的位置，就停止比较，所以，firstName和otherName输出来的结果基本没有什么意义，也就无所谓看懂看不懂了。\r\n\r\n如果你偏偏想看懂，对你的代码略加修改，你仔细品味其中奥妙吧\r\n\r\npackage Account;\r\n\r\nimport java.util.Set;\r\nimport java.util.TreeSet;\r\n\r\n\r\npublic class TreeSetTestMain {\r\npublic static void main(String[] args) {\r\nSet set = new TreeSet();\r\n//set.add(\"1\");\r\n//set.add(\"3\");\r\n//set.add(\"2\");\r\n//for (Object o : set) {\r\n// System.out.println(o);\r\n//}\r\nSystem.out.println(\" add 赵宁 开始\");\r\nset.add(new Account(\"赵宁\",21,1000));\r\nSystem.out.println(\" add 赵宁 结束\");\r\nSystem.out.println();\r\nSystem.out.println();\r\n\r\nSystem.out.println(\" add 吴宁 开始\");\r\nset.add(new Account(\"吴宁\",1,4000));\r\nSystem.out.println(\" add 吴宁 结束\");\r\nSystem.out.println();\r\nSystem.out.println();\r\n\r\nSystem.out.println(\" add 李宁 开始\");\r\nset.add(new Account(\"李宁\",2,3000));\r\nSystem.out.println(\" add 李宁 结束\");\r\nSystem.out.println();\r\nSystem.out.println();\r\n\r\nSystem.out.println(\" add 王宁 开始\");\r\nset.add(new Account(\"王宁\",3,2000));\r\nSystem.out.println(\" add 王宁 结束\");\r\nSystem.out.println();\r\nSystem.out.println();\r\n\r\nSystem.out.println(\" add 钱宁 开始\");\r\nset.add(new Account(\"钱宁\",24,6000));\r\nSystem.out.println(\" add 钱宁 结束\");\r\nfor (Object o : set) {\r\n\tSystem.out.println(o);\r\n}\r\n\r\n}\r\n\r\n} \r\n\r\n\r\nAccount.java中部分代码\r\n\r\n@Override\r\n\tpublic int compareTo(Object object) {\r\n\t\tAccount account = (Account) object;\r\n\t\tString firstName = this.name.substring(0, 1);\r\n\t\tString otherName = account.name.substring(0, 1);\r\n//\t\tSystem.out.println(firstName);\r\n//\t\tSystem.out.println(otherName);\r\n\t\tSystem.out.println(\"------------------\");\r\n\t\tSystem.out.println(\"我是\"+this.name+\",和我比较的是：\"+account.name);\r\n\t\tSystem.out.println(\"-------------------\");\r\n\t\tchar fc = 0;\r\n\t\tchar oc = 0;\r\n\t\tfor (int i = 0; i &lt; CompareTable.list.size(); i++) {\r\n\t\t\tString s[] = (String[]) CompareTable.list.get(i);\r\n\t\t\tif (s[0].equals(firstName)) {\r\n\t\t\t\tfc = s[1].toCharArray()[0];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (s[0].equals(otherName)) {\r\n\t\t\t\toc = s[1].toCharArray()[0];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (fc &gt; oc)\r\n\t\t\treturn -1;\r\n\t\tif (fc &lt; oc)\r\n\t\t\treturn 1;\r\n\t\telse\r\n\t\t\treturn 0;\r\n\t}", "Konwledge_Point": "强制类型转换", "Question": ["新手学J2SE，遇到一个集合问题，搞不懂代码什么意思", ["主要有3个类：", "\npublic class CompareTable {", "\n\n", "public static List list = new ArrayList();\nstatic{\n        String[]s1 = {\"赵\",\"z\"};\n        String[]s2 = {\"钱\",\"q\"};\n        String[]s3 = {\"孙\",\"s\"};\n        String[]s4 = {\"李\",\"l\"};\n        String[]s5 = {\"周\",\"z\"};\n        String[]s6 = {\"吴\",\"w\"};\n        String[]s7 = {\"郑\",\"z\"};\n        String[]s8 = {\"王\",\"w\"};\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n        list.add(s4);\n        list.add(s5);\n        list.add(s6);\n        list.add(s7);\n        list.add(s8);\n\n}\n", "\n\n", "}", "\n\n", "package Account;", "\n\n", "import Object.Person;", "\n\n", "public class Account implements Comparable{", "\n    private String name;", "\n    private int age;", "\n    private int money;", "\n\n", "public Account(String name,int age,int money) {\n    this.name = name;\n    this.age = age;\n    this.money = money;\n}\n\npublic String getName() {\n    return name;\n}\n\npublic void setName(String name) {\n    this.name = name;\n}\n\npublic int getAge() {\n    return age;\n}\n\npublic void setAge(int age) {\n    this.age = age;\n}\n\npublic int getMoney() {\n    return money;\n}\n\npublic void setMoney(int money) {\n    this.money = money;\n}\n\npublic String toString() {\n    return name+\" \"+age+\" \"+money;\n}\npublic boolean eqsuals(Object otherObject) {\n    //检查otherObject同this是不是同一个对象\n    if(this ==otherObject)  return true;\n    //检查otherObject是否为null\n    if(otherObject ==null)  return false;\n    //检查otherObject是不是某类的实例\n    if(!(otherObject instanceof Person))    return false;\n    //强制类型转换，执行按照业务要比较的2个对象的属性\n    Account other = (Account)otherObject;\n    if(age == other.age && name == other.name && money == other.money)  return true;\n    else\n        return false;\n}\npublic int hashCode() {\n    return this.name.hashCode()+this.age+this.money;\n}\n\n@Override\npublic int compareTo(Object object) {\n    Account account = (Account)object;\n    String firstName = this.name.substring(0,1);\n    String otherName = account.name.substring(0,1);\n    //System.out.println(firstName);\n    System.out.println(otherName);\n    char fc = 0;\n    char oc =0;\n    for(int i=0;i<CompareTable.list.size();i++) {\n        String s[] = (String[]) CompareTable.list.get(i);\n        if(s[0].equals(firstName)) {\n            fc = s[1].toCharArray()[0];\n            break;\n        }\n        if(s[0].equals(otherName)) {\n            oc = s[1].toCharArray()[0];\n            break;\n        }\n    }\n    if(fc>oc)\n        return -1;\n    if(fc<oc) return 1;\n    else\n    return 0;\n}\n\n/*public int compareTo(Object object) {\n    Account account = (Account)object;\n    if(age<account.age) return 1;\n    if(age>account.age) return -1;\n    else\n    return 0;\n}*/\n", "\n\n", "}", "\npackage Account;", "\n\n", "import java.util.Set;", "\nimport java.util.TreeSet;", "\n\n", "public class TreeSetTestMain {", "\n    public static void main(String[] args) {", "\n        Set set = new TreeSet();", "\n        //set.add(\"1\");", "\n        //set.add(\"3\");", "\n        //set.add(\"2\");", "\n        //for (Object o : set) {", "\n        //  System.out.println(o);", "\n        //}", "\n        set.add(new Account(\"赵宁\",21,1000));", "\n        set.add(new Account(\"吴宁\",1,4000));", "\n        set.add(new Account(\"李宁\",2,3000));", "\n        set.add(new Account(\"王宁\",3,2000));", "\n        set.add(new Account(\"钱宁\",24,6000));", "\n        for (Object o : set) {", "\n            System.out.println(o);", "\n            }", "\n\n", "}\n", "\n\n", "}", "\n\n", "以及那个比较方法具体是怎么实现的", "\n我最搞不懂的是firstName和otherName输出来的结果。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;指针转换为int&amp;#xff0c;编译器警告而已。你如果确定是要转换成int&amp;#xff0c;那就不用管。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["变量地址强制转换为int类型的警告", ["\n", "#", "include", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " i;\n    ", "int", " p;\n    p = (", "int", ")&i;\n    \n    ", "printf", "(", "\"p=%p\\n\"", ",p);\n    ", "printf", "(", "\"&i=%p\\n\"", ",&i);\n    \n    \n    ", "return", " ", "0", ";\n}\n", "\n", "[Warning] cast from pointer to integer of different size [-Wpointer-to-int-cast", "\n", "这个警告是为什么呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;&lt;code&gt;datastore.Put&lt;/code&gt; takes a struct pointer as its 3rd parameter, but you are passing a pointer to an interface which is invalid in this case.&lt;/p&gt;\n\n&lt;p&gt;To get around this, you need to pass a pointer when calling &lt;code&gt;save&lt;/code&gt; and pass that as is to &lt;code&gt;datastore.Put&lt;/code&gt;.&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func save(kind string, c appengine.Context, object interface{}) {\n    k := datastore.NewKey(c, kind, \"some_key\", 0, nil)\n    _, err := datastore.Put(c, k, object)\n}\nsave(\"MyType\", c, &amp;amp;someMyTypeObject)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;You can think of this as passing &lt;code&gt;someMyTypeObject&lt;/code&gt; to &lt;code&gt;datastore.Put&lt;/code&gt; via &lt;code&gt;save&lt;/code&gt; without &lt;code&gt;save&lt;/code&gt; knowing what it is.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["将界面{}强制转换为特定类型", ["\n\n", "I'm trying to make a generic function for saving to the datastore. The second of the following two examples works, but the first gives me a \"datastore: invalid entity type\" error.", "\n\n", "I'm vastly ignorant about Go at the moment, but attempting to decrease my ignorance. Is there some way to cast object in the first example into a type the name of which is held in a string. Eg some kind of reflection. I tried reflect.ValueOf, but failed with it.", "\n\n", "Thanks in advance", "\n\n", "Example 1:", "\n\n", "func save(kind string, c.appengine.Context, object interface{}) {\n    k := datastore.NewKey(c, kind, \"some_key\", 0, nil)\n    _, err := datastore.Put(c, k, &object)\n}\nsave(\"MyType\", c, someMyTypeObject)\n", "\n\n", "Example2:", "\n\n", "func save(kind string, c.appengine.Context, object MyType) {\n    k := datastore.NewKey(c, kind, \"some_key\", 0, nil)\n    _, err := datastore.Put(c, k, &object)\n}\nsave(\"MyType\", c, someMyTypeObject)\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;基本输入输出IO流&amp;#xff0c;对象流&amp;#xff0c;TreeSet集合保存数据&amp;#xff0c;目录创建&amp;#xff0c;文件操作保存集合数据等技术。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["提问 要写实训报告从这些代码里面咋写啊 用到了哪些知识", ["package cn.glutnn.jy03;", "\n", "import java.io.FileInputStream;", "import java.io.FileNotFoundException;", "import java.io.FileOutputStream;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.OutputStream;", "import java.nio.file.FileAlreadyExistsException;", "import java.nio.file.Files;", "import java.nio.file.Path;", "import java.nio.file.Paths;", "import java.time.LocalDate;", "import java.util.Scanner;", "import java.util.Set;", "import java.util.TreeSet;", "import java.util.regex.Pattern;", "\n", "public class Jy200335 {", "\n", "public", " ", "static", " ", "void", " ", "main", "(", "String", "[] args", ") {\n", "\n", "//  //1.接收控制台的用户输入数据", "        String in = getInputs();", "        System.out.println(in);", "\n", "    ", "//2.根据用户的输入数据来创建文件夹", "\n    Path dir=make", "Dir(", "in", ")", ";\n", "\n", "//        System.out.println(dir.toAbsolutePath().toString());", "\n", "    ", "//3.在指定文件夹下创建文本文件", "\n    Path file=make", "File(", "dir", ",", "in", ")", ";\n", "\n", "//        //4.准备存入文本文件的书籍", "        Book b1=new Book(\"1001011\", \"书1\", LocalDate.of(2001, 4, 13));", "        Book b2=new Book(\"1001012\", \"书2\", LocalDate.of(2003, 5, 1));", "        Book b3=new Book(\"1001013\", \"书3\", LocalDate.of(2010, 4, 23));", "        Book b4=new Book(\"1001014\", \"书4\", LocalDate.of(2021, 8, 13));", "        Book b5=new Book(\"1001015\", \"书5\", LocalDate.of(2011, 7, 22));", "        Book b6=new Book(\"1001015\", \"书6\", LocalDate.of(2016, 8, 22));", "\n", "    TreeSet<Book> ", "books", "=new TreeSet<Book>(new MyComparable());\n    books.", "add", "(b6);\n    books.", "add", "(b5);\n    books.", "add", "(b4);\n    books.", "add", "(b3);\n    books.", "add", "(b2);\n    books.", "add", "(b1);\n    \n", "\n", "//         for(Book book:books) {", "//            System.out.println(book);", "//", "//         }", "\n", "    ", "//5.", "\n    write", "File(", "file", ",", "books", ")", ";\n    \n    ", "//6.", "\n    TreeSet<Book> bookset=read", "File(", "file", ")", ";\n    ", "System", ".", "out.println(", "\"读取到的文本内容如下：\"", ");\n    ", "for", "(Book book:bookset) {\n        ", "System", ".", "out.println(book);\n    }\n\n }\n\n", "private", " static TreeSet<Book> read", "File(Path ", "file", ")", " {\n    \n    TreeSet<Book> bookset = null;\n    ", "try", "(InputStream ", "in", "=", "new", " ", "FileInputStream(", "file", ".", "toFile", "()", ");\n        ObjectInputStream ois=", "new", " ", "ObjectInputStream(", "in", ")", ";) {\n        bookset = (TreeSet<Book>) ois.read", "Object()", ";\n    } catch (FileNotFoundException e) {\n        ", "System", ".", "out.println(", "\"被读取的文本文件不存在！\"", ");\n    } catch (ClassNotFoundException e) {\n        ", "System", ".", "out.println(", "\"强制类型转换失败！\"", ");\n    } catch (IOException e) {\n        ", "System", ".", "out.println(", "\"指定文本文件读取失败！\"", ");\n    }    \n    \n    return bookset;\n}\n\n", "private", " static void write", "File(Path ", "file", ", TreeSet<Book> ", "books", ")", " {        \n    ", "//追加数据写入到文本文件", "\n    ", "try", "(OutputStream io=", "new", " ", "FileOutputStream(", "file", ".", "toFile", "()", ");\n            ObjectOutputStream oos=", "new", " ", "ObjectOutputStream(", "io", ")", ";) {    \n        oos.write", "Object(", "books", ")", ";\n        ", "System", ".", "out.println(", "\"写文本文件成功！\"", ");\n    } catch (FileNotFoundException e) {\n        ", "System", ".", "out.println(", "\"被写入的文本文件不存在！\"", ");\n    } catch (IOException e) {\n", "\n", "System.out.println(file.toAbsolutePath().toString()+\"该文本文件写入失败！\");", "e.printStackTrace();", "        }", "    }", "\n", "private", " ", "static", " ", "Path", " ", "makeFile", "(", "Path", " ", "dir", ", ", "String", " ", "in", ") {\n    ", "Path", " ", "file", "=", "Paths", ".", "get", "(", "dir", ".", "toAbsolutePath", "().", "toString", "(),", "in", ".", "concat", "(", "\".txt\"", "));\n    ", "try", " {\n        ", "file", " ", "=", " ", "Files", ".", "createFile", "(", "file", ");\n    } ", "catch", "(", "FileAlreadyExistsException", " ", "e", "){\n        ", "System", ".", "out", ".", "println", "(", "\"同名文本文件已经存在！\"", ");\n    }", "catch", " (", "IOException", " ", "e", ") {\n        ", "System", ".", "out", ".", "println", "(", "\"无法创建指定的文本文件！\"", ");\n        ", "file", "=", "null", ";\n    }\n    ", "return", " ", "file", ";\n}\n\n", "private", " ", "static", " ", "Path", " ", "makeDir", "(", "String", " ", "in", ") {\n    ", "Path", " ", "dir", " ", "=", " ", "Paths", ".", "get", "(", "in", ");\n    ", "try", " {\n        ", "dir", "=", "Files", ".", "createDirectory", "(", "dir", ");\n    } ", "catch", " (", "FileAlreadyExistsException", "  ", "e", ") {\n        ", "System", ".", "out", ".", "println", "(", "\"已经存在同名的文件夹！\"", ");\n    }", "catch", "(", "IOException", " ", "e", ") {\n        ", "System", ".", "out", ".", "println", "(", "\"无法创建指定文件夹！\"", ");\n        ", "dir", "=", "null", ";\n    }    \n    ", "return", " ", "dir", ";\n}\n\n", "private", " ", "static", " ", "String", " ", "getInputs", "() {\n    ", "Scanner", " ", "scanner", " ", "=", " ", "new", " ", "Scanner", "(", "System", ".", "in", ");        \n    ", "boolean", " ", "flag", " ", "=", " ", "false", ";\n    ", "String", " inputs ", "=", " ", "null", ";\n    ", "while", " (", "!", "flag", ") {\n        ", "System", ".", "out", ".", "println", "(", "\">>>\"", ");\n        inputs ", "=", " ", "scanner", ".", "next", "();\n        ", "Pattern", " ", "pattern", " ", "=", " ", "null", ";\n        ", "//正则表达式：jy200[3|4][0-9]{2}", "\n        ", "flag", " ", "=", " ", "pattern", ".", "matches", "(", "\"^jy200[3|4][0-9]{2}$\"", ", inputs);\n", "\n", "//            System.out.println(\"flag的返回值为：\" + flag);", "\n", "        if (flag ", "=", "=", " true) {\n            break", ";", "\n        }else {\n            System.err.println(", "\"你输入的数据格式错误，要重新输入！\"", ")", ";", "\n        }\n    }\n", "\n", "scanner.close();", "        return inputs;", "    }"]], "Tag": "程序设计"}
{"Answer": "呵呵 我以为你的事务陪在了Dao这一层了\r\n如果是你说的Manager那么这样抛出异常模拟事务回滚是对的\r\n\r\n至于你说自己createQuery 执行hql不受事务控制 我可以明确的告诉你 没有这种说法\r\n我之前三四个Spring+Hibernate的项目经验告诉我事务这样控制是没有问题的\r\n\r\n找找其他原因吧 不可能是你总结的那个原因", "Konwledge_Point": "强制类型转换", "Question": ["Spring事务的问题，bulkUpdate,或query.executeUpdate", ["今天在测试spring任务调度时，突然发现我配的声明事务不起作用了，找了好久才发现不是我的事务的问题，是我在Dao中用了一个方法有问题", "\n\n", "方法如下：", "\npublic void updateByIds(final Set updateIds)throws DaoException{", "\ntry {", "\n    String queryString=\"update from Yaoyueyingyue y set y.state='2' where y.yaoyueid in (?)\";", "\n    getHibernateTemplate().bulkUpdate(queryString, updateIds.toArray());", "\n} catch (Exception e) {", "\n    e.printStackTrace();", "\n    throw new DaoException(this.getClassName()+e.getMessage());", "\n}", "\n\n", "updateIds是一个包含要更新的编号集合，我发现用这个方法在我Manager中调用Dao事务就不起作用了，后来又改成这样", "\npublic void updateByIds(final Set updateIds)throws DaoException{", "\ntry {", "\n  getHibernateTemplate().execute(new HibernateCallback(){", "\n       final String hql=\"update Yaoyueyingyue y set y.state=2 where yaoyueid in (:yaoyueid)\";", "\n       public Object doInHibernate(Session session) throws HibernateException, SQLException {", "\n        Query query=session.createQuery(hql);", "\n        query.setParameterList(\"yaoyueid\", updateIds);", "\n        query.executeUpdate();", "\n        return null;", "\n        }", "\n\n", "    });\n", "\n\n", "} catch (Exception e) {", "\n    e.printStackTrace();", "\n    throw new DaoException(this.getClassName()+e.getMessage());", "\n}", "\n}   ", "\n\n", "事务还是不行，这两个方法好像不受spring AOP事务管理，只要执行到这个Dao的方法就自动提交了，出来异常也不能回滚，真是郁闷，小弟对这块不是很明白，为什么事务就不行了呢，希望那位牛人，帮我解释下，谢谢了，", "\n\n", "我的spring声明事务大概如下：", "true", "\n\n", "<bean id=\"atomikosUserTransaction\" class=\"com.atomikos.icatch.jta.UserTransactionImp\">  \n    <property name=\"transactionTimeout\" value=\"300\"/>    \n</bean>  \n\n<bean id=\"springTransactionManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\">  \n    <property name=\"transactionManager\"><ref bean=\"atomikosTransactionManager\"  /></property>  \n    <property name=\"userTransaction\"><ref bean=\"atomikosUserTransaction\"  /></property>  \n</bean>  \n", "\n\n", "aop:config", "\n        <!-- ", "\n            This definition creates auto-proxy infrastructure based on the given pointcut,", "\n            expressed in AspectJ pointcut language. Here: applying the advice named", "\n            \"txAdvice\" to all methods on classes named PetStoreImpl.", "\n        -->", "\n            advice-ref=\"txAdvice\" />", "\n            advice-ref=\"txAdvice\" />", "/aop:config", "\n\n", "<!-- @Transactional 时要使用下面一行 -->\n", "\n\n", "<!--  -->", "\n    <!--  Transaction advice definition, based on method name patterns.", "\n        Defaults to PROPAGATION_REQUIRED for all methods whose name starts with", "\n        \"insert\" or \"update\", and to PROPAGATION_REQUIRED with read-only hint", "\n        for all other methods.-->", "\n        <!-- 引用springTransactionManager -->", "tx:attributes", "\n            ....", "/tx:attributes", "/tx:advice", "  ", "\n\n", "atomikosTransactionManager这个东西不用管，是一个开源的支持JTA分布式的JAR，希望有人能够为我解答........", "\n[b]问题补充：[/b]", "\n谢谢你的解答，但是我还是不明白你的意思，你是指我的Dao中用了内部类吗，你所指的 “调用updateByIds方法 的代码 跳出你的当前类 然后在别的类调用当前了类的接口中的方法updateByIds  ”是指什么意思，能不能说明白点，谢谢了！！！", "\n[b]问题补充：[/b]", "\n谢谢你的答复，你的意思我也理解，但好像不是这个问题，因为我并没有像你说的那样在类的内部调用，我的所有方法都是在业务逻辑层调用的Manager层，Manager层我是在Spring中配置了的声明事务的，我给你据个例子：", "\n这两个方法都是Dao中的", "\n方法一:", "\n[code=\"java\"]", "\npublic void updateByIds(final Set updateIds)throws DaoException{", "\n        try {", "\n            /*String queryString=\"update from Yaoyuepub y set y.state='2' where y.yaoyueid in (?)\";", "\n            getHibernateTemplate().bulkUpdate(queryString, updateIds.toArray());*/", "\n\n", "        getHibernateTemplate().execute(new HibernateCallback(){\n            final String hql=\"update Yaoyuepub y set y.state=2 where yaoyueid in (:yaoyueid)\";\n            public Object doInHibernate(Session session) throws HibernateException, SQLException {\n                Query query=session.createQuery(hql);\n                query.setParameterList(\"yaoyueid\", updateIds);\n                query.executeUpdate();\n                return null;\n            }\n\n        }\n        );\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new DaoException(this.getClassName()+e.getMessage());\n    }       \n}\n", "\n\n", "[/code]", "\n\n", "这个方法是把所有的要改的ID都一次性更新调，我是不想执行多条sql,在Manager中调用这个方法事务就起不了作用，还有一个方法，就是普通的更新对象", "\n[code=\"java\"]", "\npublic void update(T t) throws DaoException {", "\n        try {", "\n            getHibernateTemplate().update(t);", "\n        } catch (Exception e) {", "\n            throw new DaoException(getClassName() + \" update exception...\",e);", "\n        }", "\n\n", "}\n", "\n\n", "[/code]", "\n\n", "要是把刚才Manager中调用改成循环执行下面的方法一个一个对象，就是有事务的，所以调用都一样，更类的内部调用应给没有关系的，我认为不管是query.executeUpdate还是spring自己提供的bulkUpdate这两个方法都是要写sql的，目的是满足批量更新和更大的灵活性，但是事务就不行了，我认为肯定可以让声明式事务支持这两个方法，就是不知道怎么配置一下，你可以自己在代码中分别做个例子试试，看看是不是用批量更新事务就控制不了了，", "\n\n", "这就是我的理解，还请多多指教，谢谢诶！！！", "\n[b]问题补充：[/b]", "\n\n", "我测试过了，以为可以了，但是还是不行，下面是我调用的一小部分代码", "\n[code=\"java\"]", "\npublic void runThread() {", "\nSet updateIds = new HashSet();", "\nfor (Yaoyueyingyue yaoyueyingyue : yaoyueyingyues) {", "\n\n", "updateIds.add(yaoyueyingyue.getYaoyueid());", "\n\n", "}", "\n\n", "if (updateIds.size() > 0) {", "\nyaoyuepubDao.updateByIds(updateIds);", "\nif(true)", "\nthrow new RuntimeException(\"AAAAAAAAAAAAAAAAAAAAAAAAA\");", "\nyaoyueyingyueDao.updateByIds(updateIds);", "\n}", "\n\n", "[/code]", "\n上面是我Manager中Spring任务调度自动执行的方法的一小部分，我中间估计抛出了异常，但是yaoyuepubDao数据库中都更新了，事务不起作用，我估计其实就是和bulkUpdate方法一样，只要这个方法能用事务控制了的话，应该没问题了", "\n[b]问题补充：[/b]", "\n下面是我在网上拷贝的--------------------------------", "\n\n", "　　Spring的HibernateTemplate提供了Hibernate的完美封装，即通过匿名类实现回调，来保证Session的自动资源管理和事务的管理。其中核心方法是： ", "\n\n", "　　java代码: ", "\n\n", "HibernateTemplate.execute(new HibernateCallback() { ", "\n　public Object doInHibernate(Session session) throws HibernateException { ", "\n　　.... ", "\n　} ", "\n} ", "\n\n", "　　回调方法提供了session作为参数，有了session，就可以自由的使用Hibernate API编程了。使用了spring的之后，代码修改如下： ", "\n\n", "　　web层代码： ", "\n\n", "　　java代码: ", "\n\n", "DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Department.class); ", "\ndetachedCriteria.createAlias(\"employees\", \"e\").add(Restrictions.eq(\"name\", \"department\")).add(Restrictions.gt((\"e.age\"), new Integer(20))); ", "\ndepartmentManager.findByCriteria(detachedCriteria); ", "\n\n", "　　构造detachedCriteria，作为参数传递给departmentManager ", "\n\n", "　　业务层代码使用spring，DepartmentManager的findByCriteria如下： ", "\n\n", "　　java代码: ", "\n\n", "public List findByCriteria(final DetachedCriteria detachedCriteria) { ", "\n　return (List) getHibernateTemplate().execute(new HibernateCallback() { ", "\n　　public Object doInHibernate(Session session) throws HibernateException { ", "\n　　　Criteria criteria = detachedCriteria.getExecutableCriteria(session); ", "\n　　　return criteria.list(); ", "\n　　} ", "\n　}); ", "\n} ", "\n\n", "　　实际上也就是： ", "\n\n", "　　java代码: ", "\n\n", "Criteria criteria = detachedCriteria.getExecutableCriteria(session); ", "\nreturn criteria.list();  ", "\n\n", "　　而已 ", "\n\n", "　　但是该程序代码执行，会抛出强制类型转换异常！ ", "\n\n", "　　我跟踪了一下spring和Hibernate源代码，原因如下： ", "\n\n", "　　spring的HibernateTemplate的execute方法提供的回调接口具有Session作为参数，但是实际上，默认情况下，HibernateTemplate传递给回调接口的session并不是org.hibernate.impl.SessionImpl类，而是SessionImpl类的一个Proxy类。之所以替换成为一个Proxy类，HibernateTemplate的注释说明，Proxy提供了一些额外的功能，包括自动设置Cachable，Transaction的超时时间，Session资源的更积极的关闭等等。 ", "\n\n", "　　java代码: ", "\n\n", "private boolean exposeNativeSession = false; ", "\n...  ", "\n\n", "　　execute方法内部： ", "\n\n", "Session sessionToExpose = (exposeNativeSession ? session : createSessionProxy(session)); ", "\n\n", "　　但是遗憾的是，Hibernate的DetachedCriteria的setExecutableCriteria方法却要求将session参数强制转为SessionImpl，但是spring传过来的却是一个Proxy类，因此就报错了。 ", "\n\n", "　　java代码: ", "\n\n", "public Criteria getExecutableCriteria(Session session) { ", "\n　impl.setSession( (SessionImpl) session ); // 要求SessionImpl，Spring传递的是Proxy ", "\n　return impl; ", "\n} ", "\n\n", "　　解决方法，禁止Spring的HibernateTemplate传递Proxy类，强制要求它传递真实的SessionImpl类，即给exexute方法增加一个参数，提供参数为true，如下： ", "\n\n", "　　java代码: ", "\n\n", "public List findByCriteria(final DetachedCriteria detachedCriteria) { ", "\n　return (List) getHibernateTemplate().execute(new HibernateCallback() { ", "\n　　public Object doInHibernate(Session session) throws HibernateException { ", "\n　　　Criteria criteria = detachedCriteria.getExecutableCriteria(session); ", "\n　　　return criteria.list(); ", "\n　　} ", "\n　}, true); ", "\n} ", "\n\n", "[b]问题补充：[/b]", "\nbulkUpdate这个方法按你给的源码，那我是用错了，但是你所说的我的模拟异常不再AOP的事务之内，我就不同意你的观点了，[code=\"java\"]", "\n\n", "if (updateIds.size() > 0) {", "\n    yaoyuepubDao.updateByIds(updateIds); // 事务开启 执行updateByIds 事务提交", "\n    if(true)", "\n        throw new RuntimeException(\"AAAAAAAAAAAAAAAAAAAAAAAAA\");", "\n    yaoyueyingyueDao.updateByIds(updateIds); // 事务开启 执行updateByIds 事务提交", "\n}  ", "\n\n", "[/code]", "\n\n", "我这段代码是两个Dao的操作，而这两个Dao的操作是被封装在一个Manger中的方法中的，Manager的每个方法都是有事务的，在操作玩第一个Dao后抛出一个RunTime异常，这时候第一个Dao操作已经执行了，这时候事务应该回滚的，不应该去更新的第一个Dao的操作，Manager中本来就业务层，中间有好多的Dao操作，事务应该控制这些Dao要不都提交，要不都回滚，你说呢，而你说的在11-12行之间加异常，那在一个Dao中，再说的的Dao是没有配事务的，又何谈回滚呢，要是把我上面两个Dao操作改成普通的对象更新，是可以回滚的，这个我肯定", "\n比如这样", "\n[code=\"java\"]", "\n  yaoyuepubDao.update(yaoyuepub);", "\nif(true)", "\n        throw new RuntimeException(\"AAAAAAAAAAAAAAAAAAAAAAAAA\");", "\nyaoyueyingyueDao.update(yaoyueyingyue);", "\n\n", "[/code]", "\n\n", "这个时候如果抛出异常，yaoyuepub是不会更新到数据库的，会回滚的，所以我总结就是executeUpdate(sql)这个方法我们直接sql,和操作对象是不一样的的，具体我也没有研究", "\n[b]问题补充：[/b]", "\n[code=\"java\"]", "\npublic void updateByIds(final Set updateIds)throws DaoException{", "\n    try {   ", "\n\n", "    getHibernateTemplate().execute(new HibernateCallback(){   \n        final String hql=\"update Yaoyuepub y set y.state=2 where yaoyueid in (:yaoyueid)\";   \n        public Object doInHibernate(Session session) throws HibernateException, SQLException {   \n            Query query=session.createQuery(hql);   \n            query.setParameterList(\"yaoyueid\", updateIds);   \n            query.executeUpdate();   \n            return null;   \n        }   \n\n    }   \n    , true);   \n} catch (Exception e) {   \n    e.printStackTrace();   \n    throw new DaoException(this.getClassName()+e.getMessage());   \n}   \n", "\n\n", "}  ", "\n\n", "[/code]", "\n\n", "把上面的updateIds方法改成：", "\n[code=\"java\"]", "\npublic void updateByIds(final Set updateIds)throws DaoException{", "\n        try {", "\n                    DetachedCriteria dc=DetachedCriteria.forClass(Yaoyuepub.class);", "\n            dc.add(Restrictions.in(\"yaoyueid\", updateIds));", "\n            List yaoyuepubs=select(dc);", "\n            for(Yaoyuepub y:yaoyuepubs){", "\n                update(y);", "\n            }", "\n\n", "                } catch (Exception e) {\n        e.printStackTrace();\n        throw new DaoException(this.getClassName()+e.getMessage());\n    }       \n}\n", "\n\n", "[/code]", "\n\n", "所有的调用都不变，spring事务就起作用了，说明自己createQuery然后executeUpdate是不被事务管理的，后其他都没有关系"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;The errors says that you are trying to Scan a struct pointer to the UUID pointer. The struct is defined &lt;a href=\"https://github.com/jackc/pgx/blob/master/pgtype/uuid.go#L11\" rel=\"nofollow noreferrer\"&gt;here&lt;/a&gt;. So basically you should use this struct and Scan it into that and then convert the byte array in the struct to whatever UUID type you are using.&lt;/p&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["使用扫描将db值强制转换为特定类型", ["\n\n", "I'm trying to read a UUID retrieved from Postgres, using github.com/jackc/pgx, into a variable of type uuid.UUID (From the github.com/google/uuid package).", "\n\n", "An example code could be:", "\n\n", "var dbId = uuid.UUID \nerr = db.Pool.QueryRow(\"SELECT id FROM users WHERE objectname = $1;\", objectUUID.String()).Scan(&dbId)\n  if err != nil {\n    log.Printf(\"Failed to fetch from database: %v\", err)\n    return\n  }\n", "\n\n", "The quickfix is to store the dbId in a temporary variable and then later convert said temporary variable into the correct type, but I have a feeling that there is a better, or more idiomatic, way to do it.", "\n\n", "The error I'm getting is:", "\n\n", "2018/02/12 07:09:18 handlers.go:187: Failed to fetch from database: can't scan into dest[1]: cannot assign &{[127 122 68 237 130 120 65 78 159 189 9 188 27 48 117 88] 2} into *uuid.UUID\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "第三种方法没有转换只是语法上的。从代码层面，它多一个乘的步骤。大多数编译器不会把x1.0优化掉。所以它极可能是最慢的。当然，具体还是看你的环境和所用的编译器，以及在什么机器上运行。", "Konwledge_Point": "强制类型转换", "Question": ["两个整数想要的到bouble类型三种方法的比较，求大神分析", ["方法一", "\nint i=1;", "\nint k =2;", "\ndouble result = (double)i/(double)k;", "\n方法二", "\ndouble i=1;", "\ndouble k =2;", "\ndouble result =i/k;", "\n方法三", "\nint i=1;", "\nint k=2;", "\ndouble result=i*1.0/k;", "\n\n", "请问这三种类型哪一种最好？？", "\n个人见解是第三种，即没有开始定义double浪费空间，又没有强制转换而导致鲁棒性下降。c++小白，求教。"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;As stated above, &lt;code&gt;libtorrent-go&lt;/code&gt; developer answered me, so I am forwarding the answer for posterity reasons.&lt;/p&gt;\n\n&lt;p&gt;Casting C++ structures in Golang using SWIG library is documented in &lt;a href=\"http://www.swig.org/Doc2.0/Go.html\" rel=\"nofollow\"&gt;SWIG-Golang documentation&lt;/a&gt;.&lt;br&gt;\nIn particular in this statement:  &lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;Given a value of the interface type, Go code can retrieve the pointer\n  to the C++ type by calling the Swigcptr method. This will return a\n  value of type SwigcptrClassName, which is just a name for uintptr. A\n  Go type conversion can be used to convert this value to a different\n  C++ type, but note that this conversion will not be type checked and\n  is essentially equivalent to reinterpret_cast. This should only be\n  used for very special cases, such as where C++ would use a\n  dynamic_cast.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;In that particular piece of code I posted above, the following was necessary to make it work:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;case \"save_resume_data_alert\":\n  log.Println(\"Wrote Metadata!\")\n  // need to actually write the resume_data :( can't find how\n  SaveRDAlert := lt.SwigcptrSave_resume_data_alert(alert.Swigcptr())\n  log.Printf(\"Resume Data: %#v\", SaveRDAlert.GetResume_data())\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["使用Golang绑定在libtorrent中强制转换“警报”类型", ["\n\n", "I am developing a personal project in Golang, using ", "libtorrent-go", "\n\n", "When I do receive an alert of type ", "\"save_resume_data_alert\"", ", I pick it up and have to CAST it as written in ", "libtorrent documentation", "\n\n", "...\n        save_resume_data_alert const* rd = alert_cast<save_resume_data_alert>(a);\n...\n", "\n\n", "But i really have not idea how to cast it in golang! Current code:  ", "\n\n", "package main\n\nimport (\n    lt \"github.com/steeve/libtorrent-go\"\n\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n\n    randomTorrent := lt.NewAdd_torrent_params()\n    randomTorrent.SetUrl(\"PUT A MAGNET LINK HERE\")\n    randomTorrent.SetSave_path(\".\")\n\n    ec := lt.NewError_code()\n    torrentSession := lt.NewSession()\n    torrentSession.Set_alert_mask(status_notification + storage_notification)\n    torrentSession.Listen_on(lt.NewStd_pair_int_int(6900, 6999), ec)\n    if ec.Value() != 0 {\n        log.Println(ec.Message())\n    }\n\n    torrentHandle := torrentSession.Add_torrent(randomTorrent, ec)\n    if ec.Value() != 0 {\n        log.Println(ec.Message())\n    }\n\n    go func() {\n        for {\n            if torrentSession.Wait_for_alert(lt.Seconds(10)).Swigcptr() == 0 {\n                log.Println(\"Alert timeout occurred!\")\n            }\n\n            alert := torrentSession.Pop_alert()\n            switch alert.What() {\n            default:\n                log.Printf(\"Alert: %#v\", alert.What())\n            case \"metadata_received_alert\":\n                log.Println(\"Received Metadata!! finally!\")\n                torrentHandle.Save_resume_data()\n            case \"save_resume_data_alert\":\n                log.Println(\"Wrote Metadata!\")\n                // need to actually write the resume_data :( can't find how\n            case \"save_resume_data_failed_alert\":\n                log.Println(\"Failed Metadata!\")\n            }\n        }\n    }()\n\n    select {}\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/217350615956191.png\" align=\"left\" /&gt;&lt;/p&gt;&lt;br /&gt;这几个属性&amp;#xff0c;你看一下在User类中是否有这些属性&amp;#xff0c;如果没有的话&amp;#xff0c;反序列化就会报错。&lt;br /&gt;下面是我之前遇到的&amp;#xff0c;序列化后字段变多的情况&amp;#xff0c;你可以参考一下&lt;br /&gt;&lt;a href=\"https://roswu.blog.csdn.net/article/details/125426566?spm&amp;#61;1001.2014.3001.5502\" id=\"textarea_1659515804465_1659516138347_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://roswu.blog.csdn.net/article/details/125426566?spm&amp;#61;1001.2014.3001.5502&lt;/span&gt;&lt;/a&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Redis获取出来的对象无法转换报错：com.ali.fastjson.JSONObject cannot be cast", ["问题遇到的现象和发生背景", "\n", "配置Springboot Security的时候，使用User 实现了UserDetails。然后使用 redis 把用户登录信息存放到 Redis中", "然后从 redis 中利用 key 获取对应数据，能获取出来，但是没办法转成对应的User类了，只能是个 Object 。数据正常", "\n", "问题相关代码，请勿粘贴截图", "\n", "@", "GetMapping()", "\n    public void redis", "Test()", " {\n        User user = ", "new", " ", "User()", ";   ", "//User 类实现了 UserDetails", "\n        user.set", "Id(1L)", ";\n        user.set", "Username(", "\"xxxxxx\"", ")", ";\n        user.set", "Password(", "\"123456\"", ")", ";\n        user.set", "Sex(", "\"女\"", ")", ";\n        user.set", "CreateTime(", "new", " Date()", ");\n\n        redisCache.set", "CacheObject(", "\"user\"", ",", "user", ")", ";\n\n        Object o = redisCache.get", "CacheObject(", "\"user\"", ")", ";\n", "//        Object o = redisTemplate.opsForValue().get(\"user\");", "\n        ", "System", ".", "out.println(", "\"o = \"", " + o.", "to", "String()", ");   ", "// 这里查看 Obejct 中的数据正常", "\n\n        User userCast = (User) o;   ", "// 无法转换类型。直接报错", "\n        ", "System", ".", "out.println(", "\"userCast = \"", " + userCast);\n\n    }\n}\n\n", "\n", "运行结果及报错内容", "\n", "\n", "\n", "\n", "我的解答思路和尝试过的方法", "\n", "很多方法，都不行", "\n", "我想要达到的结果", "\n", "能正常转换成对应类型"]], "Tag": "程序设计"}
{"Answer": "char c3 = '1'+'2'; 是显式赋值，在编译时就可以确定的常量，因而不会报错。char c4 = c1+c2; 是通过变量赋值，是在运行时才能确定它的值，所以需要显式强制类型转换。", "Konwledge_Point": "强制类型转换", "Question": ["问个类型转换的问题：", ["    char c1 = '1';\n    char c2 = '2';\n    char c3 = '1'+'2';\n    char c4 = c1+c2; //(char)c1+c2;\n", "\n\n", "如上述，为何c3的计算，不用强制转换。但c4的计算，却一定要转换？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;可以参考这个&amp;#xff1a;&lt;a id=\"textarea_1640186112929_1640186221763_0\" target=\"_blank\"&gt;&lt;span class=\"md_link_url\"&gt;ASCII码图&lt;/span&gt;&lt;/a&gt;&lt;br /&gt;并不是空白&amp;#xff0c;只不过是电脑无法显示罢了。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["c++里将一个超过127的十进制数强制转换为字符类型会怎么样？", ["今天发现一个bug就是因为这个原因引起的，请问c++如何处理超过127的情况？试了一下好像是空字符？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;hr&gt;\n\n&lt;p&gt;&lt;code&gt;map[string]interface{}&lt;/code&gt; is not the same as &lt;code&gt;map[string]string&lt;/code&gt;. Type &lt;code&gt;interface{}&lt;/code&gt; is not the same as type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;If they are both &lt;code&gt;map[string]string&lt;/code&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;package main\n\nimport \"fmt\"\n\nfunc main() {\n    v := map[string]string{\"hello\": \"world\"}\n    checkCast(v)\n\n}\n\nfunc checkCast(v interface{}) {\n    _, isCorrectType := v.(map[string]string)\n    if !isCorrectType {\n        fmt.Printf(\"incorrect type\")\n        return\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Output:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;[no output]\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;The statement &lt;code&gt;v.(map[string]string)&lt;/code&gt; is a type assertion, not a cast.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;a href=\"http://golang.org/ref/spec\" rel=\"noreferrer\"&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"http://golang.org/ref/spec#Type_assertions\" rel=\"noreferrer\"&gt;Type assertions&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;For an expression &lt;code&gt;x&lt;/code&gt; of interface type and a type &lt;code&gt;T&lt;/code&gt;, the primary\n  expression&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;x.(T)\n&lt;/code&gt;&lt;/pre&gt;\n  \n  &lt;p&gt;asserts that &lt;code&gt;x&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt; and that the value stored in &lt;code&gt;x&lt;/code&gt; is of\n  type &lt;code&gt;T&lt;/code&gt;. The notation &lt;code&gt;x.(T)&lt;/code&gt; is called a type assertion.&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Go has conversions.&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;&lt;a href=\"http://golang.org/ref/spec\" rel=\"noreferrer\"&gt;The Go Programming Language Specification&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;&lt;a href=\"http://golang.org/ref/spec#Conversions\" rel=\"noreferrer\"&gt;Conversions&lt;/a&gt;&lt;/p&gt;\n  \n  &lt;p&gt;Conversions are expressions of the form &lt;code&gt;T(x)&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a type and\n  &lt;code&gt;x&lt;/code&gt; is an expression that can be converted to type &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;\n&lt;/blockquote&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["转到：强制转换类型无法将map [string] interface {}映射到map [string] string", ["\n\n", "I wasn't sure why the following casting doesn't work: ", "\n\n", "import \"fmt\"\n\nfunc main() {\n    v := map[string]interface{}{\"hello\": \"world\"}\n    checkCast(v)\n\n}\n\nfunc checkCast(v interface{}) {\n    _, isCorrectType := v.(map[string]string)\n    if !isCorrectType { \n        fmt.Printf(\"incorrect type\")  <------------- why does it enter this if statement?\n        return\n    }\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "```\r\ndate = 0x40dd1eb8\r\nfloat kk = *((float*)&amp;date);这样转换出来的结果就是6.91\r\n\r\ndate = 0xb81edd40\r\nfloat kk = *((float*)&amp;date);这样转换出来的结果就是-0.00038\r\n\r\n你的字节序搞反了！\r\n```", "Konwledge_Point": "强制类型转换", "Question": ["四字节16进制转换浮点数时变成零     stm32", ["四字节16进制转换浮点数时变成零        stm32", "\n\n", "0x40,0xdd,0x1e,0xb8转化成正确的浮点数是6.91，但是在mdk中强制转换类型后串口回来的是-0.00038"]], "Tag": "程序设计"}
{"Answer": "建议看一下读取文件时的路径是否正确，可以debug下operateFile.load(file);的返回值，确认返回的是什么对象", "Konwledge_Point": "强制类型转换", "Question": ["Object类强制转换时出现java.lang.ClassCastException: elective.system.Administrator cannot be cast to elective.system.Student错误", ["1.进行学生的帐号注册和登录时会出现标题的错误，可是我强制转换时，并不是从Administrator转换为Student类，而是从Object类强制转换为Student类", "\n2.这是Student类的代码", "\n\n", "package elective.system;\n\nimport java.io.Serializable;\n\n/*\n学生类\n */\npublic class Student implements Serializable {\n    private static final long serialVersionUID = 5816167009388425995L;\n    private String number;          //账号\n    private String passWord;        //密码\n\n    public Student(String number, String passWord) {\n        this.number = number;\n        this.passWord = passWord;\n    }\n\n    public Student() {\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public void setNumber(String number) {\n        this.number = number;\n    }\n\n    public String getPassWord() {\n        return passWord;\n    }\n\n    public void setPassWord(String passWord) {\n        this.passWord = passWord;\n    }\n\n    //选择选修课程\n    public boolean select_class(){\n        return true;\n    }\n\n    //查看自己所选课程\n    public void look_class(){\n\n    }\n\n    //查找课程\n    public void seek_class(){\n\n    }\n}\n", "\n\n", "这是文件读取和保存的类", "\n\n", "package elective.system;\n\nimport java.io.*;\nimport java.util.ArrayList;\n\n/*\n文件操作类\n */\npublic class OperateFile implements Serializable{\n\n    public boolean save(Object e, File file, Boolean flag2) throws Exception{                         // 保存对象\n        boolean flag = false ;                                                // 定义操作标志位\n        FileOutputStream fos = new FileOutputStream(file,flag2);       //采用追加方式写入数据\n        if(file.length()<1){\n            ObjectOutputStream oos = new ObjectOutputStream(fos);\n            oos.writeObject(e);\n            flag = true;\n            oos.close();\n        }else{\n            MyObjectOutputStream mos = new MyObjectOutputStream(fos);\n            mos.writeObject(e);\n            flag = true;\n            mos.close();\n        }\n        return flag ;\n    }\n    public ArrayList load(File file) throws Exception{                          // 读取对象\n        ArrayList<Object> list = new ArrayList();\n        FileInputStream fis = new FileInputStream(file);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        while(fis.available()>0){\n            Object p =  ois.readObject();\n            list.add(p);\n        }\n        ois.close();\n        return list;\n    }\n}\nclass MyObjectOutputStream  extends ObjectOutputStream{\n\n    public MyObjectOutputStream(OutputStream out) throws IOException {\n        super(out);\n    }\n\n    public void writeStreamHeader() throws IOException{\n        return;\n    }\n}\n\n", "\n\n", "这是注册和登录的方法", "\n\n", "public boolean enter2(String number, String passWord,String pathName) throws Exception {\n        File file = new File(pathName);\n        OperateFile operateFile = new OperateFile();\n        ArrayList<Object> list =  operateFile.load(file);\n        for (Object ot:list) {\n            Student ar = (Student) ot;\n            if(ar.getNumber().equals(number)&&ar.getPassWord().equals(passWord)){\n                return true;\n            }\n        }\n        return false;\n    }\n\n        public boolean sign2(String number,String passWord,String pathName) throws Exception {\n        File file = new File(pathName);\n        OperateFile operateFile = new OperateFile();\n        ArrayList<Object> list =  operateFile.load(file);\n        for(Object ot : list){\n            Student ar = (Student) ot;\n            if(ar.getNumber().equals(number)){\n                return false;\n            }\n        }\n        Object ar = new Student(number, passWord);\n        operateFile.save(ar,file,true);\n        return true;\n    }\n", "\n\n", "请问大佬们这到底是为什么啊"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;When you unmarshall JSON into &lt;code&gt;interface{}&lt;/code&gt;, &lt;em&gt;it has no way to know what type you want it to use&lt;/em&gt;, so it defaults to &lt;code&gt;map[string]interface{}&lt;/code&gt; &lt;a href=\"https://golang.org/pkg/encoding/json/#Unmarshal\" rel=\"nofollow noreferrer\"&gt;as indicated in the documentation&lt;/a&gt;:&lt;/p&gt;\n\n&lt;blockquote&gt;\n  &lt;p&gt;To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:&lt;/p&gt;\n  \n  &lt;p&gt;...&lt;/p&gt;\n  \n  &lt;p&gt;&lt;code&gt;map[string]interface{}, for JSON objects&lt;/code&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;If you want to unmarshal to a specific type, pass an instance of that type to Unmarshal:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;var result sample \nerr = json.Unmarshal(data,&amp;amp;result)\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["将字节数组解组到接口，然后将该接口类型强制转换为struct不起作用？", ["\n\n", "I have been coding in golang for a while now. I have come across something I thought would work perfectly fine. ", "\n\n", "When I JSON Marshal a nested struct in golang I get the array of bytes, when I UnMarshal the same into an interface and convert the interface into the respective nested struct, it gives me a panic stating interface conversion: interface is map[string]interface but not the nested struct.", "\n\n", "Please go through the link below.", "\n\n", "https://play.golang.org/p/apdR4TKjee-", "\n\n", "Can someone explain to me what is that I am missing?", "\n    "]], "Tag": "程序设计"}
{"Answer": "1.什么叫暂时忽视对象的类型，使用对象的全部功能？\r\nstaff数组中对象的类型是Employee，但实际上其中保存了一个子类的对象boss。如果把boss当作Employee使用是无法使用该对象的所有方法的，\r\n比如setBonus方法，要使用这个方法（因为boss作为Manager的实例，需要使用这个方法），就需要暂时忽略它的类型（Employee），把它当作Manager使用。\r\n\r\n2.什么叫复原成Manager类，以便能够访问新增加的所有变量？这些新增加的变量是啥，能否指出来？\r\n所谓的复原，修改下代码可能更清晰些：\r\n去掉boss对象，直接给staff[0]赋值：\r\nstaff[0] = new Manager(\"Cracker\",80000,1988,12,15); \r\n好了，这时候直接调用staff[0].setBonus就会报错，因为此时staff[0]按照声明的类型是Employee，没有setBonus这个方法。\r\n需要强制转换成Manager类，也就是所谓的复原成Manager类来调用:\r\n((Manager)staff[0]).setBonus(5000);\r\n新增加的成员变量/方法：就是Manager类中新定义的bonus变量，setBonus方法。\r\n\r\n3.上段话还提出了做出了特别的处理，完全搞不懂在哪儿？\r\n一些特别的处理，上面已经提到了：**，即将boss变量存入数组之前，先用Manager对象对它进行初始化。\r\n实际上就是说，为了给staff[0] setBonus，这儿做了技巧性的处理：\r\n先声明一个Manager类型的boss变量，调用setBonus方法之后，再把bonus赋值给staff[0].\r\n不技巧性的做法就是强制类型转换，就是我在上一问中的代码写法：\r\nstaff[0] = new Manager(\"Cracker\",80000,1988,12,15); \r\n((Manager)staff[0]).setBonus(5000);", "Konwledge_Point": "强制类型转换", "Question": ["关于强制性转换的一段话，看不明白，是Java核心技术卷一中的，附上了程序", [" package inheritance; \n //Manager类继承了Employee类 \n public class Manager extends Employee{ \n\n private double bonus; \n\n public Manager(String n, double s, int year, int month, int day){ \n //利用super关键词调用Employee类的构造器 \n super(n, s, year, month, day); \n bonus = 0;\n } \n //覆盖了Employee类中的getSalary方法 \n public double getSalary(){ \n //用super关键字调用Employee类的方法 \n double baseSalary = super.getSalary(); \n return baseSalary + bonus; \n } \n public void setBonus(double b){ \n bonus = b;\n } \n }\n\npackage inheritance; \nimport java.util.Date;\nimport java.util.GregorianCalendar\npublic class Employee { \nprivate String name; \nprivate double salary; \nprivate Date hireDay; \npublic Employee(String n,double s ,int year,int month,int day){\nname = n; \nsalary = s; \nGregorianCalendar calendar = new GregorianCalendar(year, month-1, day); hireDay = calendar.getTime(); \n} \n\npublic String getName(){ \nreturn name; \n} \npublic double getSalary(){ \nreturn salary; \n} \n\npublic Date getHireDay(){\nreturn hireDay; \n} \n\npublic void raiseSalary(double byPercent){ \ndouble raise = salary * byPercent / 100; \nsalary += raise; \n} \n}\n\npublic static void main(String[] args){ \n//constrcut a Manager object \nManager boss = new Manager(\"Cracker\",80000,1988,12,15); boss.setBonus(5000); \nEmployee[] staff = new Employee[3]; //fill the staff arry with Manager and //Employee object \nstaff[0] = boss; \nstaff[1] = new Employee(\"Harry\",50000,1986,10,1); \nstaff[2] = new Employee(\"Tommy\",40000,1987,3,15); \n//print out information about all Employee objects \n//体现了多态与动态捆绑 \nfor(Employee e : staff) \nSystem.out.println(\"name:\" + e.getName() + \"，salary:\" + e.getSalary());\n}\n\n\n\n", "\n\n", "进行类型转换的唯一原因是：**在暂时忽视对象的实际类型之后，使用对象的全部功能。**例如，在Manager类中，由于某些项是普通雇员，所以staff数组必须是Employee对象的数组。我们需要将数组中引用经理的元**素复原成Manager类，**以便能够访问新增加的所有变量（需要注意，在前面的代码中，为了避免类型转换，我们做了**一些特别的处理**，即将boss变量存入数组之前，先用Manager对象对它进行初始化。为了设置经理的奖金，必须使用正确的类型）", "\n\n", "1.什么叫暂时忽视对象的类型，使用对象的全部功能？", "\n\n", "2.什么叫复原成Manager类，以便能够访问新增加的所有变量？这些新增加的变量是啥，能否指出来？", "\n\n", "3.上段话还提出了做出了特别的处理，完全搞不懂在哪儿？"]], "Tag": "程序设计"}
{"Answer": "&lt;div class=\"post-text\" itemprop=\"text\"&gt;\r\n&lt;p&gt;Based on how you're skipping over the first six fields in your &lt;code&gt;newItem&lt;/code&gt; function, it seems like these properties:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type BaseModel struct {\n    Date             string\n    Hour             int\n    Id_user          int\n    Id_line          float64\n    Id_region        int\n    Id_tree_devision int\n}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;are common to all models. Why not &lt;a href=\"https://golang.org/doc/effective_go.html#embedding\" rel=\"nofollow\"&gt;embed&lt;/a&gt; these values?&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;Is there some reason your &lt;code&gt;OrgPack&lt;/code&gt; struct can't just hold a &lt;code&gt;nextIdLine int&lt;/code&gt; value or something along those lines? I think that might result in cleaner code than using reflection and slice lengths to compute row id values.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;If you did the above two things, you could easily also replace &lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func newItem(modelName string, el models.OrgPack) interface{}\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;with&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;func (el OrgPack) NewNoagg() Noagg\nfunc (el OrgPack) NewFcr() Fcr\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;or perhaps&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;type RowFactory interface { New(el OrgPack) StatRow }\ntype NoaggFactory struct{}\nfunc (_ NoaggFactory) New(el OrgPack) StatRow\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;In the latter case, you could attach &lt;code&gt;RowFactory&lt;/code&gt; properties to your &lt;code&gt;OrgPack&lt;/code&gt;s instead of, or in addition to, &lt;code&gt;ModelName&lt;/code&gt;s, which would allow you to produce the correct &lt;code&gt;StatRow&lt;/code&gt; values without needing to switch over string values.&lt;/p&gt;\n\n&lt;hr&gt;\n\n&lt;p&gt;As you've noted, every case of your switch in &lt;code&gt;receiveLightWork&lt;/code&gt; is essentially the same: you create a slice of new elements, \"cluster\" them somehow, format the output, and return it.&lt;/p&gt;\n\n&lt;p&gt;The creation of the slice can be done through a &lt;code&gt;Factory&lt;/code&gt;-like interface, as described above. &lt;code&gt;ClusterData&lt;/code&gt; is already an interface method. &lt;code&gt;FormatOutput&lt;/code&gt; probably &lt;em&gt;should&lt;/em&gt; be.&lt;/p&gt;\n\n&lt;p&gt;If you move logic that depends on the type of data you're working with into methods for those types, I think it should be possible to achieve a &lt;code&gt;receiveLightWork&lt;/code&gt; that looks &lt;a href=\"https://play.golang.org/p/Cr3a898d1K\" rel=\"nofollow\"&gt;like this&lt;/a&gt;:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;    func receiveLightWork(org &amp;lt;-chan models.OrgPack, request ChartOptions) map[string][]OrgStat {\n        modelClusters := make(map[string][]models.OrgPack)\n\n        for orgPack := range org {\n            if model, ok := modelClusters[orgPack.ModelName]; ok {\n                modelClusters[orgPack.ModelName] = append(model, orgPack)\n            } else {\n                modelClusters[orgPack.ModelName] = []models.OrgPack{orgPack}\n            }\n        }\n\n        customFilter := request.Filters\n        customFilter.Cluster = \"clusterDay\"\n\n        output := make(map[string][]OrgStat)\n        for modelName, slice := range modelClusters {\n            if len(slice) == 0 {\n                continue\n            }\n            model := slice[0].ModelFactory.New()\n            for _, el := range slice {\n                model.Add(el.RowFactory.New(el))\n            }\n            model.ClusterData(customFilter)\n            for sourceName, charts := range request.Charts {\n                output = model.FormatOutput(output, sourceName, charts)\n            }\n        }\n        return output\n    }\n&lt;/code&gt;&lt;/pre&gt;\n    &lt;/div&gt;", "Konwledge_Point": "强制类型转换", "Question": ["转到：具有接口的结构的动态类型强制转换/断言（以调用方法并使用结构公用）", ["\n\n", "I cracked my brain trying to make my code shorter and cleaner. The problem is in one function, that is working with different ", "structs", ", that ", "implements", " one ", "interface", ".", "\n\n", "In some cases I need the ", "model", " variable to implement the structure (slice of rowModel's) ([]rowModel) and some times I need to use methods from interface. \nThe code is not short, sorry for that. So I put main comments in the code below.", "\n\n", "Here is interface:", "\n\n", "type StatModel interface {\n    FilterData(Filter)\n    ClusterData(Filter)\n    CountDataForChart(string)[]ChartElement\n    GroupByTreeGroups(Filter)[]OrgPack\n}\n\ntype StatRow interface {\n    Count( name string) float64\n}\n", "\n\n", "This interfaces are created for methods calls, and to make code shorter.  But Interface cannot have fields or structure as Abstruct class in OOP. One of the models is here:", "\n\n", " type NoaggModel []NoaggRow\n\n type NoaggRow struct {\n    Date             string\n    Hour             int\n    Id_user          int\n    Id_line          float64\n    Id_region        int\n    Id_tree_devision int\n    N_inb            float64\n    N_out            float64\n    N_hold           float64\n    N_abandon        float64\n    N_transfer       float64\n    T_inb            float64\n    T_out           float64\n    T_hold           float64\n    T_ring           float64\n    T_acw            float64\n    T_wait           float64\n}\n\ntype FcrModel  []FcrRow\n\ntype FcrRow struct {\n    Date             string\n    Hour             int\n    Id_user          int\n    Id_line          float64\n    Id_region        int\n    Id_tree_devision int\n    N_irr            float64\n    N_inb            float64\n}\n", "\n\n", "So , I'm reading from channel, and getting different structures, and trying to calculate everything correctly. How to make type assertion and method calls correctly in this case? ", "\n\n", "func receiveLightWork(org <-chan models.OrgPack, request ChartOptions) interface{} {\n\n    modelClusters := make(map[string][]models.OrgPack)\n\n    // here  I fill data into modelClusters\n\n    output := make(map[string][]OrgStat)\n\n\n    // here I begin loop over clusters of different model types\n\n    for modelName, slice := range modelClusters {\n\n        //here I can't choose what to write\n        // model must be convertable to NoaggModel, that is []NoaggRow{}\n        // as others AcsiModel, FcrModel ...etc. \n        // Also model.ClusterData(customFilter) must be callable as it is in interface of common model\n\n        var model []interface{} \n\n        var rowModel interface{}\n\n        switch modelName {\n\n        case \"noagg\":\n            model = model.(models.NoaggModel)\n            rowModel = rowModel.(models.NoaggRow{})\n        case \"acsi\":\n            model = model.(models.AcsiModel)\n            rowModel = rowModel.(models.AcsiRow)\n        case \"fcr24\":\n            model = model.(models.FcrModel)\n            rowModel = rowModel.(models.FcrRow)\n        case \"aic\":\n            model = model.(models.AicModel)\n            rowModel = rowModel.(models.AicRow)\n        }\n\n        for _, el := range slice {\n\n\n            modelFields := reflect.ValueOf(&rowModel).Elem()\n            sliceFields := reflect.ValueOf(&el.SummorisedData).Elem()\n\n            fieldsTypes := modelFields.Type()\n\n            for i := 6; i < modelFields.NumField(); i++ {\n                fmt.Println(\" model_field \", fieldsTypes.Field(i).Name )\n                modelField := modelFields.Field(i);\n                sliceField := sliceFields.Index(i-6) ;\n\n                modelField.Set(reflect.Value(sliceField));\n            }\n\n            id_line := sliceFields.Index(len(el.SummorisedData) - 1) ;\n            date := sliceFields.FieldByName(\"PackName\");\n\n            modelFields.FieldByName(\"Id_line\").Set(id_line)\n            modelFields.FieldByName(\"Date\").Set(date)\n\n     // here append not works, because model is []interface{} and not []NoaggRow or others.\n     // Writes [non-interface type []interface {} on left]\n            model = append(model, rowModel)\n        }\n\n\n // here I need to call interface method for model     \n        model.ClusterData(customFilter) // now here is unresolved Reference 'ClusterData'\n\n        for _, mod := range model {\n          // here some common logick for creating data for chart output\n         }    \n    }\n\n    return output\n}\n", "\n\n", "All help is very highly appreciated. I'll answer to each question on this topic if necessary. ", "\n\n", "Update 1:", "\n\n", "Have modified few things for generating struct's on the fly. Now all is compiling correctly until the place, where I need to get instance of struct. It sees only interface.. The comments and code update is here:  ", "\n\n", "func typeSwitch(model string) (interface{}, interface{}){\n\n    switch model{\n        case \"noagg\":\n            fmt.Println(\"Model type:\", model)\n            return &models.NoaggModel{}, &models.NoaggRow{}\n        case \"acsi\":\n            fmt.Println(\"Model type:\", model)\n            return &models.AcsiModel{}, &models.AcsiRow{}\n        case \"fcr24\":\n            fmt.Println(\"Model type:\", model)\n            return &models.FcrModel{}, &models.FcrRow{}\n        case \"aic\":\n            fmt.Println(\"Model type:\", model)\n            return &models.AicModel{}, &models.AicRow{}\n        default:\n            fmt.Println(\"Unknown\")\n            return false,false\n    }\n}\n\n\nfunc receiveLightWork(org <-chan models.OrgPack, request ChartOptions) interface{} {\n\n    modelClusters := make(map[string][]models.OrgPack)\n\n    for orgPack := range org {\n        // here I fill data into clusters\n    }\n\n    output := make(map[string][]OrgStat)\n\n   // here I need common code to put data from clusters in correct structures and call interface methods\n\n    for modelName, slice := range modelClusters {\n\n        model, rowModel := typeSwitch(modelName)\n\n        var data_slice []interface{}\n\n        for _, el := range slice {\n\n            modelFields := reflect.ValueOf(rowModel).Elem()\n            fieldsCounter := modelFields.NumField()\n\n            sliceFields := reflect.ValueOf(&el.SummorisedData).Elem()\n            sliceObjFields := reflect.ValueOf(&el).Elem()\n\n            fieldsTypes := modelFields.Type()\n\n            for i := 6; i < fieldsCounter; i++ {\n                fmt.Println(\" model_field \", fieldsTypes.Field(i).Name )\n                modelField := modelFields.Field(i);\n                sliceField := sliceFields.Index(i-6) ;\n\n                modelField.Set(reflect.Value(sliceField));\n            }\n\n            id_line := sliceFields.Index(len(el.SummorisedData) - 1) ;\n            date := sliceObjFields.FieldByName(\"PackName\");\n\n\n            modelFields.FieldByName(\"Id_line\").Set(id_line)\n            modelFields.FieldByName(\"Date\").Set(date)\n\n            fmt.Println(\"row_data : \", rowModel)\n            data_slice = append(data_slice, rowModel)\n        }\n\n    // here comes : invalid type assertion: data_slice.(model) (non-interface type []interface {} on left           \n        dataModel := data_slice.(model)\n    // here I need correctly created instance of model \n    // (NoaggModel or FcrModel) with data inside its struct \n    // to work with it and call interface methods that are shown in interface above\n\n    }\n\n    return output\n}\n", "\n    "]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-python\"&gt;\nf &amp;#61; &lt;span class=\"hljs-keyword\"&gt;open&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#39;train_list.txt&amp;#39;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;)\n    &lt;span class=\"hljs-type\"&gt;path&lt;/span&gt; &amp;#61; &amp;#34;foods&amp;#34;\n    &lt;span class=\"hljs-keyword\"&gt;index&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;\n    &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; dirname &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; os.listdir(&lt;span class=\"hljs-type\"&gt;path&lt;/span&gt;):\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; fname &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; os.listdir(&lt;span class=\"hljs-type\"&gt;path&lt;/span&gt; &amp;#43; &amp;#34;/&amp;#34; &amp;#43; dirname):\n            f.&lt;span class=\"hljs-keyword\"&gt;write&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;path&lt;/span&gt; &amp;#43; &amp;#34;/&amp;#34; &amp;#43; dirname &amp;#43; &amp;#34;/&amp;#34; &amp;#43; fname &amp;#43; &amp;#34;\\t&amp;#34; &amp;#43; &amp;#43;&amp;#34;\\n&amp;#34;)\n        &lt;span class=\"hljs-keyword\"&gt;index&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;index&lt;/span&gt; &amp;#43; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;\n    str(&lt;span class=\"hljs-keyword\"&gt;index&lt;/span&gt;)\n    f.&lt;span class=\"hljs-keyword\"&gt;close&lt;/span&gt;()\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["paython问题，修改增添代码将index强制转化为string", ["将index强制转化为string增加代码", "\n", "\nf=", "open", "(", "'train_list.txt'", ",", "'w'", ")\n", "path", " = \"foods\"\n", "index", " = ", "0", "\n", "for", " dirname ", "in", " os.listdir(", "path", "):\n    ", "for", " fname ", "in", " os.listdir(", "path", "+\"/\"+dirname):\n        f.", "write", "(", "path", "+\"/\"+dirname+\"/\"+fname+\"\\t\"+   +\"\\n\")\n    ", "index", " = ", "index", "+", "1", "\nf.", "close", "()\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;因为在java中所有数字的常量默认类型是int&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["java中为什么byte在运算的时候会自动转化为int类型而不是short类型。", ["java中为什么byte在运算的时候会自动转化为int类型而不是short类型。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;然后你具体的问题是&amp;#xff1f;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C# 调用C++ DLL，dll返回值类型为void*，需要强制转换为struct*，并接收。", ["C++导出函数 JR_API void* MicrodebProcess(float* p_aibk);", "C#接收方式：MicroAnnulusOutput* pout = (MicroAnnulusOutput*)MicrodebProcess(&AIBK);", "MicroAnnulusOutput为结构体"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在将字符串类型转换为浮点型之前&amp;#xff0c;需要保证该字符串可以被正确的解析为浮点数&amp;#xff0c;否则会抛出异常。一般地&amp;#xff0c;可以使用Float类中的parseFloat()方法将字符串类型转换为浮点型&amp;#xff0c;示例代码如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-python\"&gt;String str &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;3.14&amp;#34;&lt;/span&gt;&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\nfloat f &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; Float.parseFloat(str)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在实际应用中&amp;#xff0c;需要从数据库中获取字符串类型的数据并进行转换。假设有一个名为&amp;#34;price&amp;#34;的字符串类型的字段&amp;#xff0c;需要将其转换为浮点型。则可以使用以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;ResultSet rs &amp;#61; statement.execute&lt;span class=\"hljs-constructor\"&gt;Query(&lt;span class=\"hljs-string\"&gt;&amp;#34;SELECT price FROM my_table&amp;#34;&lt;/span&gt;)&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt; (rs.next&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;) {\n    String str &amp;#61; rs.get&lt;span class=\"hljs-constructor\"&gt;String(&lt;span class=\"hljs-string\"&gt;&amp;#34;price&amp;#34;&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-built_in\"&gt;float&lt;/span&gt; f &amp;#61; &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Float&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;parse&lt;span class=\"hljs-constructor\"&gt;Float(&lt;span class=\"hljs-params\"&gt;str&lt;/span&gt;)&lt;/span&gt;;\n    &lt;span class=\"hljs-comment\"&gt;// 进行操作&lt;/span&gt;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其中&amp;#xff0c;statement是一个已经初始化好的Statement对象&amp;#xff0c;&amp;#34;my_table&amp;#34;是数据库中的表名&amp;#xff0c;&amp;#34;price&amp;#34;是需要获取的字段名。需要注意的是&amp;#xff0c;由于字符串类型与浮点型在精度上存在差异&amp;#xff0c;可能会导致一些问题&amp;#xff0c;需要谨慎处理。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["如何将数据库中的string类型转换成float类型", ["数据库的内容是这样的", "\n", "\n", "其中latitude字段是string类型", "当我运行到下面程序的时候", "\n", "报错：ValueError: could not convert string to float", "然后我尝试着修改数据库中的类型，没办法修改！.", "\n", "\n", "\n", "然后我又尝试着使用pandas强制转换，还是报错", "是不是因为数据库的-x.X中负号的原因呀？", "我使用access数据库就可以设置成数字类型", "\n", "\n", "应该怎么解决呢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;嗨&amp;#xff0c;你好。&lt;br /&gt;如果你可以使用gdb 调试的话&amp;#xff0c;这个问题&amp;#xff0c;你看看内存就明白了。&lt;br /&gt;因为double  的数&amp;#xff0c;例如0.25&amp;#xff0c;在内存中只能是个近似值&amp;#xff0c;而不是精确值&amp;#xff0c;0.25 在内存中可能是0.2499999&amp;#xff0c;当你去两位去乘以100&amp;#xff0c;有可能是0.24&amp;#xff1b;&lt;br /&gt;怎么做才可以呢&amp;#xff1f;如果你想要保留两位&amp;#xff0c;那么加上0.005 之后乘以100&amp;#xff0c;就可以啦。。&lt;br /&gt;详细可以看下&amp;#xff1a;&lt;a href=\"https://ask.csdn.net/questions/7753796/53840832?spm&amp;#61;1001.2014.3001.5501\" id=\"textarea_1659923489762_1659923804613_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;【C语言】定义一个宏命令&amp;#xff0c;实现对一个数值保留小数点后一位有效数字的问题疑问&amp;#xff1f;-编程语言-CSDN问答&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"\"&gt;CSDN问答为您找到【C语言】定义一个宏命令&amp;#xff0c;实现对一个数值保留小数点后一位有效数字的问题疑问&amp;#xff1f;相关问题答案&amp;#xff0c;如果想了解更多关于【C语言】定义一个宏命令&amp;#xff0c;实现对一个数值保留小数点后一位有效数字的问题疑问&amp;#xff1f; c语言、c&amp;#43;&amp;#43; 技术问题等相关问答&amp;#xff0c;请访问CSDN问答。&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;img class=\"md_link_img\" id=\"md_link_img\" src=\"https://g.csdnimg.cn/static/logo/favicon32.ico\" /&gt;\n        &lt;span class=\"flex-1\"&gt;\n          &lt;span class=\"md_link_url\"&gt;https://ask.csdn.net/questions/7753796/53840832?spm&amp;#61;1001.2014.3001.5501&lt;/span&gt;\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;br /&gt;我之前在这里回复过&amp;#xff0c;很详细&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["double转int的精度损失问题？", ["输入一个浮点数，因为要用到小数部分，所以我把double强转为了int类型，然后用原浮点数减去强转之后的int类型数得到了小数部分，把小数部分乘了100把它变为了整数以便后续使用。", "其它一切良好，就是不知道结果中为什么小数部分的个位数计算出来的结果不对，比如图中的464.02，应该有两张0.1元的钞票，但是最后结果却只有一张，别的数关于个位也不对，于是我就用vstudio试了一下，提醒我强转可能会精度缺失，有人能讲一下原理吗，浮点数转化为整数不应该直接舍弃小数部分吗，怎么最后得到的小数钞票部分结果少1？", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "#include <iostream>", "\n", "#include <cstdio>", "\n\nusing namespace std;\n\n", "int", " main(){\n    double n;\n    ", "int", " n1;\n    scanf(", "\"%lf\"", ",&n);\n    ", "printf", "(", "\"NOTAS:\\n\"", ");\n    n1=(n-(", "int", ")n)*", "100", ";\n    ", "printf", "(", "\"%d nota(s) de R$ 100.00\\n\"", ",(", "int", ")n/", "100", ");\n    n=(", "int", ")n%100;\n    ", "printf", "(", "\"%d nota(s) de R$ 50.00\\n\"", ",(", "int", ")n/", "50", ");\n    n=(", "int", ")n%50;\n    ", "printf", "(", "\"%d nota(s) de R$ 20.00\\n\"", ",(", "int", ")n/", "20", ");\n    n=(", "int", ")n%20;\n    ", "printf", "(", "\"%d nota(s) de R$ 10.00\\n\"", ",(", "int", ")n/", "10", ");\n    n=(", "int", ")n%10;\n    ", "printf", "(", "\"%d nota(s) de R$ 5.00\\n\"", ",(", "int", ")n/", "5", ");\n    n=(", "int", ")n%5;\n    ", "printf", "(", "\"%d nota(s) de R$ 2.00\\n\"", ",(", "int", ")n/", "2", ");\n    n=(", "int", ")n%2;\n    ", "printf", "(", "\"MOEDAS:\\n\"", ");\n    ", "printf", "(", "\"%d moeda(s) de R$ 1.00\\n\"", ",(", "int", ")n);\n    \n    ", "printf", "(", "\"%d moeda(s) de R$ 0.50\\n\"", ",n1/", "50", ");\n    n1=n1%50;\n    ", "printf", "(", "\"%d moeda(s) de R$ 0.25\\n\"", ",n1/", "25", ");\n    n1=n1%25;\n    ", "printf", "(", "\"%d moeda(s) de R$ 0.10\\n\"", ",n1/", "10", ");\n    n1=n1%10;\n    ", "printf", "(", "\"%d moeda(s) de R$ 0.05\\n\"", ",n1/", "5", ");\n    n1=n1%5;\n    ", "printf", "(", "\"%d moeda(s) de R$ 0.01\\n\"", ",n1/", "1", ");\n    \n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;1.while循环是在对n的每一位进行分解&lt;br /&gt;num%10得到num的个位&amp;#xff0c;num/&amp;#61;10去掉个位&lt;br /&gt;得到的数字作为索引增加count[n]&amp;#43;&amp;#43;&amp;#xff0c;最后统计出的是num里各个数字的个数&lt;br /&gt;count[0]里存的是0的个数&amp;#xff0c;count[1]里存的是1的个数&lt;br /&gt;2.num是long型&amp;#xff0c;那么num%10也是long型&lt;br /&gt;java是强类型的编程语言&lt;br /&gt;一个小类型可以直接赋值给一个大的类型&amp;#xff0c;隐式转换&lt;br /&gt;而一个大类型不可以赋值给一个小类型&amp;#xff0c;必须强制转换&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["如果输入的值为12321（即num值为12321），分析每次循环后循环体内每个变量的值的变化。第6行语句为何要有类型强制转换？", ["System.out.println(\"请输入一个正整数：\");", "Scanner in = new Scanner(System.in);", "long num = in.nextLong();", "int[] count = new int[10];", "while (num != 0) {", " ", "int", " n = (", "int", ") (", "num", " % ", "10", ");\n", "\n", "  ", "count", "[", "n", "]++;\n", "\n", " num /", "=", " ", "10", ";", "\n", "\n", "}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;img alt=\"\" height=\"24\" src=\"https://img-ask.csdnimg.cn/upload/1623975016344.png\" width=\"234\" /&gt;&lt;/p&gt;\n\n&lt;p&gt;细看了下上下文代码&amp;#xff0c;是这里被强制转换了。。。问题是解决了。。剩下的就是如何转换成自己想要的数据啦~&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["type类型为str的byte格式的数据，如何变成type为byte类型", ["问题：type类型为str的byte格式的数据，如何变成type为byte类型,使之能够和str类型相互转换？", "\n\n", "\n\n", "\n\n", "最近在处理USB数据，用的pyserial包，出现了如图所示问题：", "\n\n", "按道理这个byte类型的格式应该是byte类型，但是却是str类型，我该如何变回byte类型？", "\n\n", "用了spilt 还是str类型；用了encode、decode直接报错；用了str()、byte()强制转换也报错"]], "Tag": "程序设计"}
{"Answer": "你上面的程序是C#，下面的程序是C++，两者根本没有可比性。\r\nC#里对应的操作是\r\nzifu = (char)((int)zifu + 4);", "Konwledge_Point": "强制类型转换", "Question": ["char型变量的加减法关于隐式转换和显示转换方面的问题。", ["如下，我想建一个数组，用textbox1.Text 中输入的字符为它赋值，再将每个元素转换成char型，再进行加减法，但是出现了错误：", "\n    CS0266  无法将类型“int”隐式转换为“char”。存在一个显式转换(是否缺少强制转换?) ", "\n private void textBox1_TextChanged(object sender, EventArgs e)", "\n        {", "\n                        String[] ch = textBox1.Text.Split();", "\n            for(int i=0;i\n            {", "\n                char zifu= Convert.ToChar(ch[i]);", "\n                if((zifu>='a'&&zifu<='z')||(zifu>='A'&&zifu<='Z'))", "\n                {", "\n                    zifu += 4;我", "\n                }", "\n                        }", "\n                }", "\n\n", "            char类型的值加减法我去百度了下是可以隐式转换，像下面这样，请问我上面的程序哪里有问题？\n            int main（）\n            {\nchar ch;\nscanf_s(\"%c\", &ch);\nch += 4;\nprintf(\"%c\", ch);\n}\n"]], "Tag": "程序设计"}
{"Answer": "https://blog.csdn.net/weixin_37288522/article/details/86524168", "Konwledge_Point": "强制类型转换", "Question": ["java后台将base64字符串转换为PDF后生成的PDF打不开怎么回事呀", ["\n后台代码：", "\npublic static void base64StringToPdf(String base64Content,String filePath){", "\n        File file = new File(filePath);// 将原来参数修改为字符串", "\n        BASE64Decoder decoder = new BASE64Decoder();", "\n        BufferedInputStream bin = null;", "\n        FileOutputStream fout = null;", "\n        BufferedOutputStream bout = null;", "\n        try {", "\n            //将base64编码的字符串解码成字节数组", "\n            byte[] bytes = decoder.decodeBuffer(base64Content);", "\n            //创建一个将bytes作为其缓冲区的ByteArrayInputStream对象", "\n            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);", "\n            //创建从底层输入流中读取数据的缓冲输入流对象", "\n            bin = new BufferedInputStream(bais);", "\n            //创建到指定文件的输出流", "\n            fout  = new FileOutputStream(file);", "\n            //为文件输出流对接缓冲输出流对象", "\n            bout = new BufferedOutputStream(fout);", "\n\n", "        byte[] buffers = new byte[1024];\n        int len = bin.read(buffers);\n        while(len != -1){\n            bout.write(buffers, 0, len);\n            len = bin.read(buffers);\n        }\n        //刷新此输出流并强制写出所有缓冲的输出字节，必须这行代码，否则有可能有问题\n        bout.flush();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            bout.close();\n            fout.close();\n            bin.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n    前台是将页面展示的数据图标什么的生成PDF \n    前台代码：\n    function downloadofpdf(){\n    var varname = $(\"#taskid\").text();\n      if(confirm(\"您确认下载该PDF文件吗?\")){\n         var target = document.getElementById(\"bodyid\");\n         target.style.background = \"#FFFFFF\";\n", "\n\n", "//            if(pdfName==''||pdfName==undefined) pdfName= getNowFormatDate();", "\n             html2canvas(target, {", "\n                 onrendered:function(canvas) {", "\n                     var contentWidth = canvas.width;", "\n                     var contentHeight = canvas.height;", "\n                     //一页pdf显示html页面生成的canvas高度;", "\n                     var pageHeight = contentWidth /1592.28 * 841.89;", "\n                     //未生成pdf的html页面高度", "\n                     var leftHeight = contentHeight;", "\n                     //页面偏移", "\n                     var position = 0;", "\n                     //a4纸的尺寸[595.28,841.89]，html页面生成的canvas在pdf中图片的宽高", "\n                     var imgWidth = 595.28;", "\n                     var imgHeight = 592.28/contentWidth * contentHeight;", "\n\n", "                 var pageData = canvas.toDataURL('image/jpeg', 1.0);\n\n                 var pdf = new jsPDF('', 'pt', 'a4');\n\n                 //有两个高度需要区分，一个是html页面的实际高度，和生成pdf的页面高度(841.89)\n                 //当内容未超过pdf一页显示的范围，无需分页\n                 if (leftHeight < pageHeight) {\n                     pdf.addImage(pageData, 'JPEG', 0, 0, imgWidth, imgHeight );\n                 } else {\n                     while(leftHeight > 0) {\n                         pdf.addImage(pageData, 'JPEG', 0, position, imgWidth, imgHeight);\n                         leftHeight -= pageHeight;\n                         position -= 841.89;\n                         //避免添加空白页\n                         if(leftHeight > 0) {\n                             pdf.addPage();\n                         }\n                     }\n                 }\n                 pdf.save(varname+\".pdf\");\n\n                 // 将pdf输入为base格式的字符串\n                 var buffer = pdf.output(\"datauristring\");\n", "\n\n", "//                     // 将base64格式的字符串转换为file文件", "\n//                     var myfile = dataURLtoFile(buffer, varname);", "\n//                     var formdata = new FormData();", "\n//                     formdata.append(name, myfile);", "\n                     $.post(\"/riskManage/uploadpdf\",{data:JSON.stringify({formdata:buffer})},function(result){", "\n                        //alert(\"hao\");", "\n                     })", "\n                     //sc();", "\n                 },", "\n                 background: \"#fff\"", "\n             })", "\n         }", "\n\n", "}\n"]], "Tag": "程序设计"}
{"Answer": "```\r\n void CDlgp1Dlg::OnButton1() \r\n{\r\n\t// TODO: Add your control notification handler code here\r\n\tfor (int i = 1; i &lt; 5; i++)\r\n\t{\r\n\t\tchar t[100];\r\n\t\titoa(i, t, 10);\r\n\t\tm_list.AddString(t);\r\n\t}\r\n}\r\n```", "Konwledge_Point": "强制类型转换", "Question": ["VC++ 6.0的List控件怎么添加整数值进去？", ["VC++ 6.0的List控件怎么添加整数值进去？AddString报错类型不兼容，强制转换也不行？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;malloc(len)申请的是内存地址&amp;#xff0c;通俗地说&amp;#xff0c;就是指针的模板&amp;#xff0c;然后(char*)malloc(len)则是把这个模板转换成char*类型指针&lt;br /&gt;char的话&amp;#xff0c;不是地址不能这样子转换&lt;br /&gt;如果对你有帮助&amp;#xff0c;望采纳&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["malloc分配内存的问题", ["void use_malloc()", "{", "    int len;", "    char* p;", "    printf(\"输入申请的内存大小：\");", "    scanf(\"%d\", &len);", "    p = (char*)malloc(len);", "}", "想问一下malloc分配内存，为什么要强制转换类型？强制转换类型的结果是什么", "为什么不是(char)malloc(len)而是(char*)malloc(len)?"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;望采纳。&lt;br /&gt;你这样呢&amp;#xff1f;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-constructor\"&gt;SetCtrlVal(&lt;span class=\"hljs-params\"&gt;panelHandle&lt;/span&gt;,PANEL_NUMERICTHERM, &lt;span class=\"hljs-params\"&gt;f&lt;/span&gt;)&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["CVI string控件赋值问题", ["十六进制转浮点数，红框位置需要填什么，直接写进去f不对，我也不知道该怎么写了，有没有哪位来支支招。", "还不能强制转换，强制转换以后小数点后面部分丢失，CVI里还没有string类型。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;Collection换个名字吧&amp;#xff0c;可能关键字冲突了&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Java 使用xml文件配置更新数据库数据发生java.lang.Integer cannot be cast to java.util.Collection错误", ["Java 使用xml文件配置更新数据库数据发生java.lang.Integer cannot be cast to java.util.Collection错误", "\n", "\n", "xml的配置（采用的是注解类型注入参数，所以没加parameterType）", "\n", "<", "update", " id=", "\"updateAccountCollection\"", " >\n        ", "update", " app_account ", "AS", " ", "ac", "\n        <", "set", ">\n            <", "if", " ", "test", "=", "\"display != null\"", ">\n                ", "ac", ".", "display", " = #{", "display", "},\n            </", "if", ">\n            ", "ac", ".collection = #{collection}\n        </", "set", ">\n        where ", "ac", ".id = #{id}\n</", "update", ">\n", "\n", "其中display、collection两个字段在数据库的类型为tinyint(2),在实体类中两个字段的类型为Integer", "\n", "mapper代码", "\n", "\n", "//更新收藏、是否显示", "\n    ", "void", " ", "updateAccountCollection", "(", "@Param", "(", "\"display\"", ")int display,", "@Param", "(", "\"collection\"", ")int collection,", "@Param", "(", "\"id\"", ")Long id);\n", "\n", "\n", "报错日志", "\n", "org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:\n### Error updating database.  Cause: java.lang.ClassCastException: java.lang.Integer cannot be cast to java.util.Collection\n### The error may exist ", "in", " ", "class", " path resource [mapper/ResourceMapper.xml]\n### The error may involve com.selfcare.mapper.ResourceMapper.updateAccountCollection\n### The error occurred while executing an update\n### Cause: java.lang.ClassCastException: java.lang.Integer cannot be cast to java.util.Collection\n\n\n", "\n", "请问，这种报错该怎么解决啊？", "\n", "知道是数据类型无法强制转换，但是我反找了一遍，也没找到是哪里用到了java.util.Collection这个类型"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;调用LINQ的&lt;code class=\"language-javascript\"&gt;.ToArray()&lt;/code&gt;方法&amp;#xff0c;将其转换成数组&amp;#xff0c;示例如下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-csharp\"&gt;IReadOnlyCollection&amp;lt;BluetoothDeviceInfo&amp;gt; list &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;List&lt;/span&gt;&amp;lt;BluetoothDeviceInfo&amp;gt;\n{\n    &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;&lt;/span&gt;() {Id &amp;#61; &lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;},\n    &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;&lt;/span&gt;() {Id &amp;#61; &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;},\n    &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;&lt;/span&gt;() {Id &amp;#61; &lt;span class=\"hljs-number\"&gt;3&lt;/span&gt;},\n    &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;&lt;/span&gt;() {Id &amp;#61; &lt;span class=\"hljs-number\"&gt;4&lt;/span&gt;},\n    &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt;&lt;span class=\"hljs-type\"&gt;&lt;/span&gt;() {Id &amp;#61; &lt;span class=\"hljs-number\"&gt;5&lt;/span&gt;}\n}.AsReadOnly();\n\nBluetoothDeviceInfo[] devices &amp;#61; list.ToArray();\nforeach (&lt;span class=\"hljs-keyword\"&gt;var&lt;/span&gt; item &lt;span class=\"hljs-keyword\"&gt;in&lt;/span&gt; devices)\n{\n    Console.WriteLine(item.Id);\n}\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-class\"&gt;&lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;BluetoothDeviceInfo&lt;/span&gt;\n&lt;/span&gt;{\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; int Id { &lt;span class=\"hljs-keyword\"&gt;get&lt;/span&gt;; &lt;span class=\"hljs-keyword\"&gt;set&lt;/span&gt;; }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code class=\"language-javascript\"&gt;IReadOnlyCollection&lt;/code&gt;的集合从字面理解&amp;#xff0c;它是只读的&amp;#xff0c;你不能修改&lt;code class=\"language-javascript\"&gt;IReadOnlyCollection&lt;/code&gt;集合中的数据&amp;#xff0c;比如&amp;#xff1a;添加&amp;#xff0c;修改&amp;#xff0c;删除集合中的元素等等。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["C#中关于System.Collections.Generic.IReadOnlyCollection< >数据类型的疑惑", ["写了一个语句：", "BluetoothDeviceInfo[] devices = client.DiscoverDevices();", "报错是：", "无法将类型“System.Collections.Generic.IReadOnlyCollection<InTheHand.Net.Sockets.BluetoothDeviceInfo>”隐式转换为“InTheHand.Net.Sockets.BluetoothDeviceInfo[]”。存在一个显式转换(是否缺少强制转换?)", "写成 ", "BluetoothDeviceInfo[] devices = (BluetoothDeviceInfo[])client.DiscoverDevices()", " 来强制转换也不行。运行时还是报错，显示无法强转。", "\n", "想知道System.Collections.Generic.IReadOnlyCollection< >这是一个什么类型的数据，我试了赋值给List< BluetoothDeviceInfo >也是类似报错。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;该回答引用ChatGPT &lt;/p&gt;\n&lt;p&gt;问题1&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;当您执行 &amp;#34;&amp;#34;&amp;#43;str[0] 时&amp;#xff0c;由于 C&amp;#43;&amp;#43; 中字符串是以 null 结尾的字符数组&amp;#xff0c;因此 &amp;#34;&amp;#34; 实际上是一个长度为 1 的字符串&amp;#xff0c;其中唯一的字符是 null 终止符。因此&amp;#xff0c;表达式 &amp;#34;&amp;#34;&amp;#43;str[0] 实际上将 null 终止符与 str[0] 进行了连接。如果 str[0] 是一个字母&amp;#xff0c;则结果是一个长度为 2 的字符串&amp;#xff0c;其中第一个字符是 null 终止符&amp;#xff0c;第二个字符是 str[0] 所表示的字母。但是&amp;#xff0c;如果 str[0] 是一个空格或其他符号&amp;#xff0c;则结果仍然是一个长度为 2 的字符串&amp;#xff0c;但是第二个字符是 str[0] 所表示的符号&amp;#xff0c;而不是字母。&lt;/p&gt;\n&lt;p&gt;此外&amp;#xff0c;在某些操作系统上&amp;#xff0c;如果尝试在控制台窗口中输出 null 字符&amp;#xff0c;则可能会显示为 ? 字符。&lt;/p&gt;\n&lt;p&gt;问题2&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;您可以使用 std::to_string() 函数将 char 类型的变量转换为字符串。这个函数定义在  头文件中。例如&amp;#xff0c;如果您要将 char 类型变量 c 转换为字符串&amp;#xff0c;可以使用以下代码&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-bash\"&gt;&lt;span class=\"hljs-built_in\"&gt;char&lt;/span&gt; c &amp;#61; &lt;span class=\"hljs-character\"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;\nstd::&lt;span class=\"hljs-built_in\"&gt;string&lt;/span&gt; s &amp;#61; std::&lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;_string(&lt;span class=\"hljs-params\"&gt;c&lt;/span&gt;)&lt;/span&gt;;\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;请注意&amp;#xff0c;这种方法只适用于表示数字的 char 值。如果您要将包含其他字符的 char 变量转换为字符串&amp;#xff0c;则需要使用其他方法&amp;#xff0c;例如使用字符串流 stringstream。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["提问，C++字符串与字符转换问题", ["提问qaq，c++编程问题：", "问题1：", "定义了一个", "vector words；", "string str;  //str为传入的字符串，不为空", "words.push_back(\"\"+str[0]);", "因为words必须push形式为字符串格式的，\"\"+str[0]这句代码如果str[0]为字母时可以正常运行，但他为符号时就显示为奇怪的字符串，比如空格字符‘ ’最后得到的时“ge”。并且也会输出？为什么？", "问题2：", "为了解决上面的问题，我需要将char类型转为string，c++里该怎么操作？是否有强制转换的函数，如果有需要加什么头文件吗？"]], "Tag": "程序设计"}
{"Answer": "```\r\n int x = 123;\r\nint 十位数 = (x / 10) % 10;\r\nbyte b1 =  (byte)(十位数 / 16);\r\nbyte b2 =  (byte)(十位数 % 16);\r\n```", "Konwledge_Point": "强制类型转换", "Question": ["c# Byte的高四位和低四位", ["一个两位数int；如何将int十位上的数强制转换为byte后取出该字节的高四位转换给另一个byte类型的b1；低四位给另一个b2；最后得到2个字节,怎么做？谢谢！"]], "Tag": "程序设计"}
{"Answer": "void DealObjectStr(ref object obj)//写一个方法处理object参数\r\n{\r\n    int pp=0;\r\n\t\tif(int.TryParse(obj.ToString(),ref pp))\r\n\t\t{\r\n\t\t   obj=Convert.ToInt32(obj);\r\n\t\t}else\r\n\t\t{\r\n\t\t    object= obj.ToString();\r\n\t\t}\r\n}\r\n\r\n\r\nDealObjectStr(ref obj);//调用方法前，先处理参数\r\nfunc(obj);", "Konwledge_Point": "强制类型转换", "Question": ["C#中 object类型的参数遇到重载该如何写得优雅？", ["大致就是有一个object类型的参数，在调用时遇到重载，目前只能根据类型直接进行强制转换，代码看起来很坑爹：", "\nvoid text(object obj)｛", "\n    if(obj is int)｛", "\n        func((int)obj);", "\n    ｝", "\n    else｛", "\n        func((string)obj)", "\n    ｝", "\n｝", "\n只能这样了吗？是否有更合理的做法？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;可以在next()后面增加一个charAt(0)获取输入的第一个字符即可&amp;#xff0c;另外如果需要向其他方法传递注册信息&amp;#xff0c;可以把存放注册信息的String数组放在main方法&amp;#xff0c;然后向其他方法传递这个String数组和可以当前可以存储注册信息的下标。&lt;br /&gt;&lt;br /&gt;修改如下&amp;#xff1a;&lt;br /&gt;&lt;br /&gt;参考链接&amp;#xff1a;&lt;br /&gt;&lt;a href=\"https://blog.csdn.net/weixin_62079735/article/details/128920895\" id=\"textarea_1678669074999_1678671322763_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;div class=\"md_link_card\"&gt;\n      \n        &lt;span class=\"md_link_title\"&gt;&lt;/span&gt;\n        \n      &lt;span class=\"md_link_desc\" style=\"margin: 0px 0 2px\"&gt;&lt;/span&gt;\n      &lt;span class=\"md_flex_card\"&gt;\n      &lt;span class=\"md_link_img icon iconfont icon-lianjie\"&gt;&lt;/span&gt;\n        &lt;span class=\"flex-1 md_link_url\"&gt;\n         https://blog.csdn.net/weixin_62079735/article/details/128920895\n        &lt;/span&gt;\n      &lt;/span&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;import&lt;/span&gt; java.util.Scanner;\n\n&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;class&lt;/span&gt; RegisterTest {\n\n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;void&lt;/span&gt; main(String[] args) {\n        &lt;span class=\"hljs-comment\"&gt;// TODO Auto-generated method stub&lt;/span&gt;\n        String [] h &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; String[&lt;span class=\"hljs-number\"&gt;100&lt;/span&gt;];\n        \n        &lt;span class=\"hljs-comment\"&gt;// 第一次注册&amp;#xff0c;传入h数组&amp;#xff0c;当前可以存储注册信息的下标len&amp;#61;0&lt;/span&gt;\n        &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; len&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n        &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; newLen&amp;#61;register(h,len);  &lt;span class=\"hljs-comment\"&gt;// 使用newLen存放最新可以存储注册信息的下标&amp;#xff0c;以便后面打印和再次注册&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//System.out.println(&amp;#34;newLen&amp;#61;&amp;#34;&amp;#43;newLen);&lt;/span&gt;\n        \n        System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;注册信息为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;newLen;i&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) {\n            System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;#43;h[i]&amp;#43;&lt;span class=\"hljs-string\"&gt;&amp;#34;,密码&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;#43;h[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n        }\n        \n        &lt;span class=\"hljs-comment\"&gt;// 第二次注册&amp;#xff0c;传入h数组&amp;#xff0c;当前可以存储注册信息的下标newLen&amp;#xff0c;并再次获取返回的可以存储注册信息的下标&amp;#xff0c;以便后面打印&lt;/span&gt;\n        newLen&amp;#61;register(h,newLen);\n        &lt;span class=\"hljs-comment\"&gt;//System.out.println(&amp;#34;newLen&amp;#61;&amp;#34;&amp;#43;newLen);&lt;/span&gt;\n        \n        System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;注册信息为&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n        &lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt;(&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i&amp;#61;&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;i&amp;lt;newLen;i&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;) {\n            System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;#43;h[i]&amp;#43;&lt;span class=\"hljs-string\"&gt;&amp;#34;,密码&amp;#xff1a;&amp;#34;&lt;/span&gt;&amp;#43;h[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]);\n        }\n    }\n    \n    &lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;static&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; register(String[] h,&lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; len) {\n        \n        &lt;span class=\"hljs-keyword\"&gt;int&lt;/span&gt; i&amp;#61;len;\n        &lt;span class=\"hljs-comment\"&gt;//System.out.println(&amp;#34;i&amp;#61;&amp;#34;&amp;#43;i);&lt;/span&gt;\n        Scanner sc &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; Scanner(System.in);\n        \n        \n        &lt;span class=\"hljs-keyword\"&gt;while&lt;/span&gt;(i&amp;lt;h.length-&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;) {\n            \n            System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;姓名&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n            h[i] &amp;#61; sc.&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;();\n\n            System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;密码&amp;#xff1a;&amp;#34;&lt;/span&gt;);\n            h[i&amp;#43;&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;]&amp;#61;sc.&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;();\n            \n            System.out.&lt;span class=\"hljs-keyword\"&gt;println&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;是否继续注册&amp;#xff1f;Y/N&amp;#34;&lt;/span&gt;);\n            &lt;span class=\"hljs-keyword\"&gt;char&lt;/span&gt; m ;\n            &lt;span class=\"hljs-comment\"&gt;// https://blog.csdn.net/weixin_62079735/article/details/128920895&lt;/span&gt;\n            m &amp;#61; sc.&lt;span class=\"hljs-keyword\"&gt;next&lt;/span&gt;().charAt(&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;);\n            i&amp;#43;&amp;#61;&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n        &lt;span class=\"hljs-comment\"&gt;//    System.out.println(&amp;#34;i&amp;#61;&amp;#34;&amp;#43;i);&lt;/span&gt;\n        &lt;span class=\"hljs-comment\"&gt;//    System.out.println(&amp;#34;m&amp;#61;&amp;#34;&amp;#43;m);&lt;/span&gt;\n            &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt;(m&amp;#61;&amp;#61;&lt;span class=\"hljs-string\"&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;) {\n                &lt;span class=\"hljs-keyword\"&gt;continue&lt;/span&gt;;\n            }&lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n            &lt;span class=\"hljs-comment\"&gt;///&amp;#61;    sc.close();&lt;/span&gt;\n            &lt;span class=\"hljs-comment\"&gt;//    System.out.println(&amp;#34;i-2&amp;#61;&amp;#34;&amp;#43;(i-2));&lt;/span&gt;\n                &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n            }\n            \n        }\n        \n        \n        &lt;span class=\"hljs-comment\"&gt;//sc.close();&lt;/span&gt;\n        \n        &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; i;\n        \n    }\n\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/313068076876118.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["java中scanner输入问题", ["我的目的是定义一个char类型，然后输入一个字符，判断与Y或N是否相等，我用int类型输入强制转换成char会报错，用next或者nextline又报错如何解决"]], "Tag": "程序设计"}
{"Answer": "![图片说明](https://img-ask.csdn.net/upload/201708/02/1501659538_175957.png)\r\n\r\n因为anObject被定义为Object了，强制转换为String后才能给String类型的变量赋值", "Konwledge_Point": "强制类型转换", "Question": ["关于String类equals源代码问题", ["if (anObject instanceof String) {", "\n\n", "    String anotherString = (String)anObject;\n", "\n\n", "为什么已经判断anObject是否是String类，还要强制转换成String类型"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;\n&lt;span class=\"hljs-attr\"&gt;li_url&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;https://www.shicimingju.com&amp;#34;&lt;/span&gt; &amp;#43; link.xpath(&lt;span class=\"hljs-string\"&gt;&amp;#39;./a/&amp;#64;href&amp;#39;&lt;/span&gt;)[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样子就行了&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["用python爬取小说时，拼接url类型错误", ["问题遇到的现象和发生背景", "\n", "用python爬取网页时，拼接url类型错误，运行后显示拼接的那段url需要转换为str类型，但是如果强制转换后输出的url就会带有[]，是无效的url，就不能继续进行对新的url的解析了", "\n", "问题相关代码，请勿粘贴截图", "\n", "import requests\n", "from", " lxml import html\netree=html.etree\n", "if", " __name__ == ", "'__main__'", ":\n    url=", "\"https://www.shicimingju.com/book/sanguoyanyi.html\"", "\n    headers = {\n    ", "\"User-Agent\"", ": ", "\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 Safari/537.36\"", "}\n    page_text=requests.get(url,headers).content.decode(", "'utf-8'", ")\n    tree=etree.HTML(page_text)\n    li_link=tree.xpath(", "'//div[@class=\"book-mulu\"]/ul/li'", ")\n    fp = ", "open", "(", "'./三国.txt'", ", ", "'w'", ", encoding=", "'utf-8'", ")\n    for ", "link", " ", "in", " li_link:\n        #拼接错误！！！！！！\n        #li_url=", "\"https://www.shicimingju.com\"", "+str(", "link", ".xpath(", "'./a/@href'", "))\n        li_url = ", "\"https://www.shicimingju.com\"", " + ", "link", ".xpath(", "'./a/@href'", ")\n        pr", "int", "(li_url)\n        ", "title", "=", "link", ".xpath(", "'./a/text()'", ")\n        detail_text=requests.get(url=li_url,headers=headers).content.decode(", "'utf-8'", ")\n        tree = etree.HTML(detail_text)\n\n        content=tree.xpath(", "'//div[@class=\"card bookmark-list\"]/div/text()'", ")\n        fp.write(str(", "title", "+content))\n        # pr", "int", "(content,", "\"结束\"", ")\n        pr", "int", "(", "title", ",", "'成功！！'", ")\n\n\n\n\n\n\n", "\n", "运行结果及报错内容", "\n", "```", "\n", "```li_url = \"", "https://www.shicimingju.com\"", " + link.xpath('./a/", "@href')", "TypeError: can only concatenate str (not \"list\") to str", "\n", "我的解答思路和尝试过的方法", "\n", "加str强制转换", "\n", "我想要达到的结果", "\n", "拼接生成正确的url"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是加i&amp;#xff0c;不是加1&lt;br /&gt;emm[i] &amp;#61; ‘A’ &amp;#43; i&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["java数组输出a到z", ["应该输出的是a到z，但运行是26个B，有谁知道问题在哪吗？且没有强制转换 'A' + i的数据类型也没报错"]], "Tag": "程序设计"}
{"Answer": "没见过你这么写\r\n\r\n\r\n```\r\n    @RequestMapping(params = \"test\")\r\n    public void test(\r\n                         HttpServletRequest request, HttpServletResponse response) {\r\n\t\tresponse.setContentType(\"application/json\");\r\n\t\tresponse.setHeader(\"Cache-Control\", \"no-store\");\r\n\t\ttry {\r\n\t\t\tPrintWriter pw=response.getWriter();\r\n\t\t\tpw.write(\"hehe\");\r\n            pw.flush();\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n    }\r\n```\r\n\r\n这样写就Ok了 不用在配置文件配置其他的", "Konwledge_Point": "强制类型转换", "Question": ["请问为什么设置了数据返回的格式为application/json,但实际返回的却是text/html", ["我想让客户端的响应码以application/json的格式返回给服务器，但总是以text/html的方式返回，看了很多资料，还是没有解决。", "\n下图分别是代码和springmvc的配置信息：", "\n下面是服务器端的报错信息：", "\n请问是客户端哪里出了问题"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;是的&amp;#xff0c;malloc返回值是 void * &amp;#xff0c;将(void *)类型强制转换成(struct film *)&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["大佬帮帮忙，(struct film*)", ["movies=(struct film*)malloc(n*sizeof(struct film))", "\n\n", "这个(struct film*)什么意思啊，类型强制转换指针？"]], "Tag": "程序设计"}
{"Answer": "试了下，运行效果如图\r\n![图片说明](https://img-ask.csdn.net/upload/201911/18/1574045517_81955.png)\r\n\r\n\r\n整个代码文件：\r\n\r\n``` csharp\r\n    class SystemParamClass\r\n    {\r\n        public String ModelFileSavePathName = \"D:/Data/SystemParam\";//保存参数的文件夹名称\r\n        public String ModelSystemParamFileName = \"/SystemParam.ini\";\r\n\r\n\r\n        public List&lt;FileInfoInIni&gt; AllIniParam = new List&lt;FileInfoInIni&gt;();\r\n\r\n        public FileInfoInIni LeftDownCamGrapImageHeight;\r\n        public FileInfoInIni LeftDownCamGrapImagePoseX;\r\n        public FileInfoInIni LeftDownCamGrapImagePoseY;\r\n\r\n        public FileInfoInIni RightDownCamGrapImageHeight;\r\n        public FileInfoInIni RightDownCamGrapImagePoseX;\r\n        public FileInfoInIni RightDownCamGrapImagePoseY;\r\n    }\r\n    public class FileInfoInIni\r\n    {\r\n        private string FilePathAndName;\r\n        private string FileSection;\r\n        private string FileAppName;\r\n        public object Value;\r\n        public string Key { get =&gt; FileAppName; }\r\n\r\n        [DllImport(\"kernel32\", CharSet = CharSet.Ansi, EntryPoint = \"GetPrivateProfileStringA\", ExactSpelling = true, SetLastError = true)]\r\n        private static extern int GetPrivateProfileString([MarshalAs(UnmanagedType.VBByRefStr)] ref string lpApplicationName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpKeyName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpDefault, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpReturnedString, int nSize, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpFileName);\r\n        [DllImport(\"kernel32\", CharSet = CharSet.Ansi, EntryPoint = \"WritePrivateProfileStringA\", ExactSpelling = true, SetLastError = true)]\r\n        private static extern int WritePrivateProfileString([MarshalAs(UnmanagedType.VBByRefStr)] ref string lpApplicationName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpKeyName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpString, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpFileName);\r\n        public string GetINI(string Section, string AppName, string lpDefault, string FileName)\r\n        {\r\n            string text = Strings.LSet(\"\", 256);\r\n            FileInfoInIni.GetPrivateProfileString(ref Section, ref AppName, ref lpDefault, ref text, Strings.Len(text), ref FileName);\r\n            return Strings.Left(text, checked(Strings.InStr(text, \"\\0\", CompareMethod.Binary) - 1));\r\n        }\r\n        public long WriteINI(string Section, string AppName, string lpDefault, string FileName)\r\n        {\r\n            return (long)FileInfoInIni.WritePrivateProfileString(ref Section, ref AppName, ref lpDefault, ref FileName);\r\n        }\r\n        public bool ReadValue()\r\n        {\r\n            bool result;\r\n            try\r\n            {\r\n                this.Value = this.GetINI(this.FileSection, this.FileAppName, \"\", this.FilePathAndName);\r\n                bool flag = Operators.ConditionalCompareObjectEqual(this.Value, \"\", false);\r\n                if (flag)\r\n                {\r\n                    result = false;\r\n                    return result;\r\n                }\r\n            }\r\n            catch (Exception expr_41)\r\n            {\r\n                ProjectData.SetProjectError(expr_41);\r\n                result = false;\r\n                ProjectData.ClearProjectError();\r\n                return result;\r\n            }\r\n            result = true;\r\n            return result;\r\n        }\r\n        public bool SaveValue()\r\n        {\r\n            bool result;\r\n            try\r\n            {\r\n                string left = this.Value.ToString();\r\n                this.WriteINI(this.FileSection, this.FileAppName, Conversions.ToString(this.Value), this.FilePathAndName);\r\n                string iNI = this.GetINI(this.FileSection, this.FileAppName, \"\", this.FilePathAndName);\r\n                bool flag = Operators.CompareString(left, iNI, false) != 0;\r\n                if (flag)\r\n                {\r\n                    result = false;\r\n                    return result;\r\n                }\r\n            }\r\n            catch (Exception expr_71)\r\n            {\r\n                ProjectData.SetProjectError(expr_71);\r\n                result = false;\r\n                ProjectData.ClearProjectError();\r\n                return result;\r\n            }\r\n            result = true;\r\n            return result;\r\n        }\r\n        public FileInfoInIni(string TempFilePathAndName, string TempFileSection, string TempFileAppName)\r\n        {\r\n            this.Value = RuntimeHelpers.GetObjectValue(new object());\r\n            this.FilePathAndName = TempFilePathAndName;\r\n            this.FileSection = TempFileSection;\r\n            this.FileAppName = TempFileAppName;\r\n            this.Value = null;\r\n        }\r\n        public void dispose()\r\n        {\r\n            this.FilePathAndName = \"\";\r\n            this.FileSection = \"\";\r\n            this.FileAppName = \"\";\r\n            this.Value = null;\r\n        }\r\n    }\r\n    public class MyTest\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            //实例化\r\n            SystemParamClass param = new SystemParamClass\r\n            {\r\n                LeftDownCamGrapImageHeight = new FileInfoInIni(\"template1.bmp\", \"E:/abc\", \"VisionPro.exe\"),\r\n                LeftDownCamGrapImagePoseX = new FileInfoInIni(\"template2.bmp\", \"E:/abc\", \"VisionPro.exe\"),\r\n                LeftDownCamGrapImagePoseY = new FileInfoInIni(\"template3.bmp\", \"E:/abc\", \"VisionPro.exe\"),\r\n\r\n                RightDownCamGrapImageHeight = new FileInfoInIni(\"template4.bmp\", \"E:/abc\", \"VisionPro.exe\"),\r\n                RightDownCamGrapImagePoseX = new FileInfoInIni(\"template5.bmp\", \"E:/abc\", \"VisionPro.exe\"),\r\n                RightDownCamGrapImagePoseY = new FileInfoInIni(\"template6.bmp\", \"E:/abc\", \"VisionPro.exe\")\r\n            };\r\n\r\n            var list = new List&lt;FileInfoInIni&gt;();\r\n            //反射加载\r\n            FieldInfo[] fields = param.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Instance \r\n                | BindingFlags.Static | BindingFlags.Public);\r\n            foreach (FieldInfo field in fields)\r\n            {\r\n                if (field.FieldType == typeof(FileInfoInIni))\r\n                {\r\n                    object value = field.GetValue(param);\r\n                    list.Add(value as FileInfoInIni);\r\n                }\r\n            }\r\n            param.AllIniParam = list;\r\n        }\r\n    }\r\n\r\n```\r\n我也是做视觉集成模块的。。。。", "Konwledge_Point": "强制类型转换", "Question": ["C#　如何将一个类中全部字段添加到List中（字段为自定义类，引用类型，不是值类型）？", ["自定义了一个类，里面包含了很多字段（也是自定义的类），如何将类中的字段全部添加到ｌｉｓｔ中", "\n做这个功能主要是为了能够通过list来访问FileInfoInIni，调用FileInfoInIni的方法。", "\n或者哪位大神有更好的办法能实现这个功能也行", "\n\n", "class SystemParamClass\n    {\n         public String ModelFileSavePathName = \"D:/Data/SystemParam\";//保存参数的文件夹名称\n        public String ModelSystemParamFileName = \"/SystemParam.ini\";\n\n\n        public List<FileInfoInIni> AllIniParam = new List<FileInfoInIni>();\n\n        public FileInfoInIni LeftDownCamGrapImageHeight;\n        public FileInfoInIni LeftDownCamGrapImagePoseX;\n        public FileInfoInIni LeftDownCamGrapImagePoseY;\n\n        public FileInfoInIni RightDownCamGrapImageHeight\n        public FileInfoInIni RightDownCamGrapImagePoseX;\n        public FileInfoInIni RightDownCamGrapImagePoseY;\n\n                ｝\n", "\n\n", "如何写一个方法，自动将　FileInfoInIni　全部添加到　AllIniParam　中", "\nFileInfoInIni 　为自定义的类，我试过了反射，只能设置值，不知道怎么转换类型，然后添加进去", "\n\n", " public static void AddTolist(object TempClass)\n        {\n            Type t = TempClass.GetType();\n            FieldInfo[] fields = t.GetFields(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public);\n            foreach (FieldInfo field in fields)\n            {\n                if (field.FieldType == typeof(FileInfoInIni))\n                {\n                    Console.WriteLine(\"Field:\" + field);\n                    Console.WriteLine(\"Field:\" + field.Name );\n                }\n                //Console.WriteLine(\"Field:\" + field);\n\n            }\n\n        }\n", "\n\n", "不能强制转换类型", "\n\n", "FileInfoInIni的定义", "\n\n", "public class FileInfoInIni\n    {\n        private string FilePathAndName;\n        private string FileSection;\n        private string FileAppName;\n        public object Value;\n        public string Key { get => FileAppName; }\n\n        [DllImport(\"kernel32\", CharSet = CharSet.Ansi, EntryPoint = \"GetPrivateProfileStringA\", ExactSpelling = true, SetLastError = true)]\n        private static extern int GetPrivateProfileString([MarshalAs(UnmanagedType.VBByRefStr)] ref string lpApplicationName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpKeyName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpDefault, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpReturnedString, int nSize, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpFileName);\n        [DllImport(\"kernel32\", CharSet = CharSet.Ansi, EntryPoint = \"WritePrivateProfileStringA\", ExactSpelling = true, SetLastError = true)]\n        private static extern int WritePrivateProfileString([MarshalAs(UnmanagedType.VBByRefStr)] ref string lpApplicationName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpKeyName, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpString, [MarshalAs(UnmanagedType.VBByRefStr)] ref string lpFileName);\n        public string GetINI(string Section, string AppName, string lpDefault, string FileName)\n        {\n            string text = Strings.LSet(\"\", 256);\n            FileInfoInIni.GetPrivateProfileString(ref Section, ref AppName, ref lpDefault, ref text, Strings.Len(text), ref FileName);\n            return Strings.Left(text, checked(Strings.InStr(text, \"\\0\", CompareMethod.Binary) - 1));\n        }\n        public long WriteINI(string Section, string AppName, string lpDefault, string FileName)\n        {\n            return (long)FileInfoInIni.WritePrivateProfileString(ref Section, ref AppName, ref lpDefault, ref FileName);\n        }\n        public bool ReadValue()\n        {\n            bool result;\n            try\n            {\n                this.Value = this.GetINI(this.FileSection, this.FileAppName, \"\", this.FilePathAndName);\n                bool flag = Operators.ConditionalCompareObjectEqual(this.Value, \"\", false);\n                if (flag)\n                {\n                    result = false;\n                    return result;\n                }\n            }\n            catch (Exception expr_41)\n            {\n                ProjectData.SetProjectError(expr_41);\n                result = false;\n                ProjectData.ClearProjectError();\n                return result;\n            }\n            result = true;\n            return result;\n        }\n        public bool SaveValue()\n        {\n            bool result;\n            try\n            {\n                string left = this.Value.ToString();\n                this.WriteINI(this.FileSection, this.FileAppName, Conversions.ToString(this.Value), this.FilePathAndName);\n                string iNI = this.GetINI(this.FileSection, this.FileAppName, \"\", this.FilePathAndName);\n                bool flag = Operators.CompareString(left, iNI, false) != 0;\n                if (flag)\n                {\n                    result = false;\n                    return result;\n                }\n            }\n            catch (Exception expr_71)\n            {\n                ProjectData.SetProjectError(expr_71);\n                result = false;\n                ProjectData.ClearProjectError();\n                return result;\n            }\n            result = true;\n            return result;\n        }\n        public FileInfoInIni(string TempFilePathAndName, string TempFileSection, string TempFileAppName)\n        {\n            this.Value = RuntimeHelpers.GetObjectValue(new object());\n            this.FilePathAndName = TempFilePathAndName;\n            this.FileSection = TempFileSection;\n            this.FileAppName = TempFileAppName;\n            this.Value = null;\n        }\n        public void dispose()\n        {\n            this.FilePathAndName = \"\";\n            this.FileSection = \"\";\n            this.FileAppName = \"\";\n            this.Value = null;\n        }\n    }\n"]], "Tag": "程序设计"}
{"Answer": "首先，看起来你还不清楚writeObject()和readObject()方法是用来实现对象的序列化和反序列化的\r\n\r\n这个this是指反序列化之后的引用\r\n\r\n反序列化是不会调用类的构造方法的", "Konwledge_Point": "强制类型转换", "Question": ["小弟最近用HashSet时无意看了下它的源码，发现一段奇怪的代码，不知是小弟所学不精还是java源码编写者别有深意呢", ["[code=\"java\"]", "\nmap = (((HashSet)this) instanceof LinkedHashSet ?", "\n               new LinkedHashMap(capacity, loadFactor) :", "\n               new HashMap(capacity, loadFactor));", "\n[/code]", "\n\n", "这是HashSet中readObject的一段代码", "\nLinkedHashSet是HashSet的子类，这里却在instanceof前对this用了强制转换", "\n虽说LinkedHashSet用的也是这段代码，但这里的强制转换怎么看都觉得有点别扭似的", "\n\n", "按小弟的理解，readObject应该是new了之后就使用，那this的类型也就该是new的类型吧？", "\n又或者说是为了容错？为了编码的方便理解？", "\n\n", "小弟学java还是新手，希望各位高手们不吝指教一下，谢谢"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;建议引入NPOI&amp;#xff0c;不要引入excel库&amp;#xff0c;excel库依赖于本机安装的office版本&amp;#xff0c;而且必须进行com注册&amp;#xff0c;很麻烦&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["这个问题应该怎么解决（Excel）", ["System.InvalidCastException:“无法将类型为“System.__ComObject”的 COM 对象强制转换为接口类型“Microsoft.Office.Interop.Excel.Worksheet”。此操作失败的原因是对 IID 为“{000208D8-0000-0000-C000-000000000046}”的接口的 COM 组件调用 QueryInterface 因以下错误而失败: 库没有注册。 (异常来自 HRESULT:0x8002801D (TYPE_E_LIBNOTREGISTERED))。”"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;true是个字符串&amp;#xff0c;false也是个字符串&amp;#xff0c;你把字符串强制转布尔值&amp;#xff0c;它只要ascii码不是0就肯定是true啊&lt;br /&gt;所以你要做的不是强制转换&amp;#xff0c;是用函数去转&lt;br /&gt;或者干脆直接判断字符串是&amp;#34;true&amp;#34;还是“false”&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么false取反后仍为false", [" console.log(!", "Boolean(", "route", ".", "query", ".", "isRead", ")", ")\n\n", "\n", "用路由query传值，传了一个布尔类型，因为采用的是路由，传过来成字符串了，所以强制转换了一下，但是当传的是true时，这边取反正常为false。当传的是false时，这边取反仍为false，是为什么？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;a1&amp;#61;int(req...)&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["django从前端通过input获取向量并计算，以实现一个向量夹角的网页计算器", ["我写的函数如下：", "\n", "\n", "打印a时是成功的，但输入完六个参数后进行计算时报错can't multiply sequence by non-int of type 'str'", "\n", "\n", "我的网页代码如下：", "\n", "\n", "在查询后得知是因为input获取的是字符串类型，但是这种情况我应该如何强制转换呢？", "想要的效果是将答案直接展示在网页"]], "Tag": "程序设计"}
{"Answer": "使用npoi完美导出excel，有现成的代码可以直接使用。\r\n[http://blog.csdn.net/chinacsharper/article/details/12999435](http://blog.csdn.net/chinacsharper/article/details/12999435 \"\")", "Konwledge_Point": "强制类型转换", "Question": ["将datagridview的数据导出为excel时出现异常", ["“System.InvalidCastException”类型的未经处理的异常在 FaceTest.exe 中发生 ", "\n\n", "其他信息: 无法将类型为“Microsoft.Office.Interop.Excel.ApplicationClass”的 COM 对象强制转换为接口类型“Microsoft.Office.Interop.Excel._Application”。此操作失败的原因是对 IID 为“{000208D5-0000-0000-C000-000000000046}”的接口的 COM 组件调用 QueryInterface 因以下错误而失败: 加载类型库/DLL 时出错。 (异常来自 HRESULT:0x80029C4A (TYPE_E_CANTLOADLIBRARY))。", "\n\n", "我用的是vs2013，office2013，添加的引用库为vs2013自带的Microsoft Office 15.0 Object Library，看网上有人说这是版本问题？有办法解决吗？"]], "Tag": "程序设计"}
{"Answer": "执行结果：\r\n1\r\nB的构造方法\r\n2\r\n4\r\n3\r\nHello\r\n\r\n虚拟机首先，会加载类的信息，如果类中有静态方法，则会执行静态方法，有多个静态方法，则按顺序执行，构造方法则是在实例化该类（创建对象）时才调用。\r\n虚拟机首先，优先加载含有main函数的主类，所以先加载A类，发现A类中有一个静态代码成员，所以先执行\r\n```\r\nprivate static A a = new A();\r\n```\r\nnew A（）则是创建对象了，就会执行A的构造函数，实例化A的时候，会初始化A的成员变量，也就是：\r\n```\r\nprivate C c = new C();\r\n```\r\n这时，虚拟机会先去加载C的类信息，发现其中也有静态方法，则会执行：\r\n\r\n```\r\nstatic {\r\n    System.out.println(\"1\");\r\n}\r\n```\r\n加载完后，会接着刚刚的程序，接着实例化C：\r\n\r\n```\r\npublic C(){\r\n    super();\r\n    System.out.println(\"2\");\r\n}\r\n```\r\n这个spuer（）;则是构造父类了，然后就会去构造B：\r\n\r\n```\r\nB(){\r\n    System.out.println(\"B的构造方法\");\r\n}\r\n```\r\n执行完后，接着刚刚的C的构造方法执行：\r\n```\r\nSystem.out.println(\"2\");\r\n```\r\n此时，A类的成员变量已经初始化完毕了，可以构造A类了，执行A的构造函数：\r\n\r\n```\r\npublic A() {\r\nSystem.out.println(\"4\");\r\n}\r\n```\r\n此时，A的第一个静态方法执行完毕，执行第二个静态方法：\r\n```\r\nstatic {\r\n            System.out.println(\"3\");\r\n        }\r\n```\r\n执行完后，所有的类信息都加载完毕了，然后执行主函数：\r\n\r\n```\r\npublic static void main(String[] args) {\r\n\r\nSystem.out.println(\"Hello\");\r\n}\r\n```\r\n\r\n希望对你有帮助", "Konwledge_Point": "强制类型转换", "Question": ["请问这个题执行顺序是什么", ["》》》》》》问题1", "\npackage java_study;", "\n/**", "\n\n", "\n", "\n", "请说出下列代码的输出结果", "\n*/", "\npublic class A {", "\n\n", "private static A a = new A();", "\n\n", "private C c = new C();", "\n\n", "static {", "\n    System.out.println(\"3\");", "\n}", "\n\n", "public A() {", "\n    System.out.println(\"4\");", "\n}", "\n\n", "public static void main(String[] args) {", "\n\n", "System.out.println(\"Hello\");\n", "\n\n", "}", "\n", "\n", "}", "\n\n", "//定义一个父类B", "\n\n", "class B{", "\n\n", "B(){\n    System.out.println(\"B的构造方法\");\n}\n", "\n\n", "}", "\n\n", "//定义一个子类C 继承 B", "\n\n", "class C extends B{", "\n\n", "static {\n    System.out.println(\"1\");\n}\npublic C(){\n    super();\n    System.out.println(\"2\");\n}\n", "\n\n", "}", "\n\n", "》》》》》》》》问题2", "\n如果该父类引用所调用的方法参数列表未定义，就调用该父类的父类中查找，如果还没找到就强制向上类型转换参数列表中的参数类型，具体优先级高到低依次如下：", "\n\n", "this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。", "\n\n", "能给我解释一下这方面的问题吗？？"]], "Tag": "程序设计"}
{"Answer": "我知道了，在C++ primer第5版的 2.4.1节有说明，即引用类型与其所引用对象类型不一致时，编译器会生成一个临时的常量，所以如果引用不是const的，则会报错", "Konwledge_Point": "强制类型转换", "Question": ["C++中字符数组转 string类引用问题", ["函数定义：", "\nvoid fun(const string &s){", "\n    cout<<s<<endl;", "\n}", "\n如果调用fun(\"hello\"),可以正确编译。但是如果把函数定义中的const去掉，则不能正确编译。", "\n问字符数组\"hello\"是通过什么方式装换成const string &类型的，是某种强制转换吗？", "\n我再C++ primer里没找到相关说明，如有知道的说明下哪本书，那页有说明。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你直接敲就行&amp;#xff0c;能执行&amp;#xff0c;不报错&lt;br /&gt;因为你多次强制转换类型&amp;#xff0c;而且list套list&amp;#xff0c;IDE会认不出你最里层的结构到底是个什么类型&amp;#xff0c;所以点的时候点不出对应的方法&amp;#xff0c;这很正常&lt;br /&gt;毕竟python是解释性的语言&amp;#xff0c;不是所有操作在一开始编译阶段IDE都能搞清楚&lt;br /&gt;执行的时候能执行的&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["有关元组方面出现的问题", ["问题遇到的现象和发生背景", "\n", "在python3.10中 创建一个字符串", "通过split对字符串进行分割 并输出列表", "将列表中的第三个元素强制改为列表类型", "也就是列表里套了一个列表", "随后对这个大列表进行类型转换，转为元组类型", "对元组内可变元素（被套的小列表）进行操作时 虽然type为list 但是对其操作时报错", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "s", "=", "'hello|python|123'", " \n", "a", "=s.split(sep='|')  #对字符串分割，转化为list格式\na[2]=list(a[2])  # 将第三个元素转为list格式\n", "aa", "=tuple(a) \n", "print", "(aa[2],type(aa[2]))  # [", "'1'", ", ", "'2'", ", ", "'3'", "] <class ", "'list'", ">\n", "print", "(len(a[2]))  # 3\n", "\n", "运行结果及报错内容", "\n", "在aa[2]后输入.append提示框里的操作语句都是对str操作的", "没有对list的有关操作", "\n", "我的解答思路和尝试过的方法", "\n", "由于元组内不能更改不可变元素类型，所以就在列表那一步里更改类型", "更改完在小列表内的元素类型为str 但是应该不影响对整个列表的增删改", "\n", "我想要达到的结果", "\n", "可以对aa[2]进行增删改操作"]], "Tag": "程序设计"}
{"Answer": "虽然不知道你的mdc对应的代码实际是什么样的，不过这样大概能解决你的问题：\r\nmdc.Message.Skip(pageindex * pagesize).Take(pagesize).ToList();\r\n这个ToList&lt;T&gt;()是Enumerable类上的方法，是针对IEnumerable&lt;T&gt;的扩展方法。DataQuery&lt;T&gt;同时实现了IQueryable&lt;T&gt;与IEnumerable&lt;T&gt;，因此可以使用该方法。", "Konwledge_Point": "强制类型转换", "Question": ["C#三层linq", ["无法将类型为“System.Data.Linq.DataQuery`1[DAL.Message]”的对象强制转换为类型“System.Collections.Generic.List`1[DAL.Message]”。 ", "说明: 执行当前 Web 请求期间，出现未处理的异常。请检查堆栈跟踪信息，以了解有关该错误以及代码中导致错误的出处的详细信息。 ", "异常详细信息: System.InvalidCastException: 无法将类型为“System.Data.Linq.DataQuery`1[DAL.Message]”的对象强制转换为类型“System.Collections.Generic.List`1[DAL.Message]”。 ", "源错误: ", "\n\n", "行 74:         public List<Message> findPage(int pagesize, int pageindex)\n行 75:         {\n行 76:             return (List<Message>)mdc.Message.Skip(pageindex * pagesize).Take(pagesize);\n行 77:         }\n行 78: \n", "\n\n", "源文件: D:\\My Documents\\Visual Studio 2008\\Projects\\Messages\\BLL\\MessageBLL.cs    行: 76 ", "堆栈跟踪: ", "[InvalidCastException: 无法将类型为“System.Data.Linq.DataQuery", "1[DAL.Message]”的对象强制转换为类型“System.Collections.Generic.List", "1[DAL.Message]”。] ", "   BLL.MessageBLL.findPage(Int32 pagesize, Int32 pageindex) in D:\\My Documents\\Visual Studio 2008\\Projects\\Messages\\BLL\\MessageBLL.cs:76 ", "   Web.index.GetData() in D:\\My Documents\\Visual Studio 2008\\Projects\\Messages\\Web\\index.aspx.cs:45 ", "   Web.index.Page_Load(Object sender, EventArgs e) in D:\\My Documents\\Visual Studio 2008\\Projects\\Messages\\Web\\index.aspx.cs:40 ", "   System.Web.Util.CalliHelper.EventArgFunctionCaller(IntPtr fp, Object o, Object t, EventArgs e) +14 ", "   System.Web.Util.CalliEventHandlerDelegateProxy.Callback(Object sender, EventArgs e) +43 ", "   System.Web.UI.Control.OnLoad(EventArgs e) +91 ", "   System.Web.UI.Control.LoadRecursive() +74 ", "   System.Web.UI.Page.ProcessRequestMain(Boolean includeStagesBeforeAsyncPoint, Boolean includeStagesAfterAsyncPoint) +2603 ", "问题补充：", "谢谢你的回答,这个我知道就是不知道怎么去转换。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;给你个工具类&lt;/p&gt;\n\n&lt;pre&gt;\n&lt;code class=\"language-java\"&gt;import java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\n\n\npublic class test1 {\n\n    /**\n     * &amp;#64;param args\n     * &amp;#64;throws ParseException \n     */\n    public static void main(String[] args) throws ParseException {\n        // TODO Auto-generated method stub\n        SimpleDateFormat sdf&amp;#61;new SimpleDateFormat(&amp;#34;yyyy-MM-dd HH:mm:ss&amp;#34;);\n        Date d1&amp;#61;sdf.parse(&amp;#34;2012-09-08 10:10:10&amp;#34;);\n        Date d2&amp;#61;sdf.parse(&amp;#34;2012-09-15 00:00:00&amp;#34;);\n        System.out.println(daysBetween(d1,d2));\n\n        System.out.println(daysBetween(&amp;#34;2012-09-08 10:10:10&amp;#34;,&amp;#34;2012-09-15 00:00:00&amp;#34;));\n    }\n    \n    /** \n     * 计算两个日期之间相差的天数 \n     * &amp;#64;param smdate 较小的时间\n     * &amp;#64;param bdate  较大的时间\n     * &amp;#64;return 相差天数\n     * &amp;#64;throws ParseException \n     */  \n    public static int daysBetween(Date smdate,Date bdate) throws ParseException  \n    {  \n        SimpleDateFormat sdf&amp;#61;new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;);\n        smdate&amp;#61;sdf.parse(sdf.format(smdate));\n        bdate&amp;#61;sdf.parse(sdf.format(bdate));\n        Calendar cal &amp;#61; Calendar.getInstance();  \n        cal.setTime(smdate);  \n        long time1 &amp;#61; cal.getTimeInMillis();               \n        cal.setTime(bdate);  \n        long time2 &amp;#61; cal.getTimeInMillis();       \n        long between_days&amp;#61;(time2-time1)/(1000*3600*24);\n          \n       return Integer.parseInt(String.valueOf(between_days));         \n    }  \n    \n　　/**\n　　 *字符串的日期格式的计算\n　　 */\n    public static int daysBetween(String smdate,String bdate) throws ParseException{\n        SimpleDateFormat sdf&amp;#61;new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;);\n        Calendar cal &amp;#61; Calendar.getInstance();  \n        cal.setTime(sdf.parse(smdate));  \n        long time1 &amp;#61; cal.getTimeInMillis();               \n        cal.setTime(sdf.parse(bdate));  \n        long time2 &amp;#61; cal.getTimeInMillis();       \n        long between_days&amp;#61;(time2-time1)/(1000*3600*24);\n          \n       return Integer.parseInt(String.valueOf(between_days));   \n    }\n\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt; &lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["请看看吧，如何让功能实现", ["date类以String存储在数据库mysql，以类Note封装记录，获取mysql中的String类型之后，如何强制转换，实现日期类相减，得到一个int类型的返回值", "\n\n", " ", "\n\n", "public  int jiaofei111(Note a) throws Exception{ //判断是否交费及钱数", "\n            ", "\n             ", "\n", "\n              SimpleDateFormat  sdf=new SimpleDateFormat(\"yyyy-MM-dd\");", "\n              Date d1=(Date) sdf.parse(a.getReturntime());//结束时间  //强制转换string->date", "\n              Date d2=(Date) sdf.parse(a.getLenttime());//结束时间  //强制转换string->date", "\n                     int stateTimeLong = (int) d1.getTime();", "\n                    int endTimeLong =(int) d2.getTime();", "\n                    // 结束时间-开始时间 = 天数", "\n                    int day = (int)(endTimeLong-stateTimeLong)/(24*60*60*1000); ", "\n                    if(day>30) return day;                ", "\n                    else{day=0;}        ", "\n\n", "                    return day;", "\n              ", "\n        }", "\n "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这是可行的但思想上是不一样的&amp;#xff0c;h 的类型为 node* &amp;#xff0c;是一个结构体指针&amp;#xff0c;他的大小也是已知的&amp;#xff0c;* h 是解引用 h 这个指针变量&amp;#xff0c;等价于 h 指向的结构体&amp;#xff0c;虽然未指向但 malloc 只需要获取目标空间大小即可&amp;#xff0c;该结构体大小同定义结构体大小一样&amp;#xff0c;根据自义定类型对齐机制可计算结构体大小&amp;#xff0c;date 整型大小为 4 字节&amp;#xff0c;next 指针类型大小为 4 字节&amp;#xff0c;如果编译器为 vs &amp;#xff08;默认对齐数为 8&amp;#xff09;则正好偏移量为 0和4得到该结构体大小为 8 字节&amp;#xff0c;即可实现 malloc。&lt;br /&gt;ps&amp;#xff1a;扣字不易&amp;#xff0c;如有帮助&amp;#xff0c;还请点个采纳捏~&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["帮我看看两种结构体指针与malloc用法", ["问题遇到的现象和发生背景", "\n", "我在用malloc为结构体指针分配内存时发现了两种写法但是我不理解为什么", "\n", "问题相关代码，请勿粘贴截图", "\n", "例如：typedef struct node", "{", "    int date;", "    struct node *next;", "}node;", "\n", "node  * h=malloc(sizeof( * h));//这是一种写法，我不理解为什么不用在malloc前面强制转换类型，然后分配的空间是多大的，为什么是sizeof（* h），h不是还没指向吗？", "node *h；", "h=（node *）malloc（sizeof(node））//这种写法就可以比较容易理解。但是我想请教上面一种是为什么。", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这个跟方法返回类型有关&amp;#xff0c;你方法返回的类型是整型。&lt;br /&gt;&lt;strong&gt;修改方法返回类型为float即可。&lt;/strong&gt;&lt;br /&gt;&lt;strong&gt;代码修改如下&amp;#xff1a;&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-meta\"&gt;#&lt;span class=\"hljs-keyword\"&gt;include&lt;/span&gt;&lt;span class=\"hljs-string\"&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;area&lt;/span&gt; &lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; a, &lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; b,&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; c)&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; d, s;\nd &amp;#61; (a &amp;#43; b &amp;#43; c) / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\ns &amp;#61; &lt;span class=\"hljs-built_in\"&gt;sqrt&lt;/span&gt;(d * (d - a) * (d - b) * (d - c));\n&lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; s;\n}\n\n&lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;main&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;()&lt;/span&gt;\n&lt;/span&gt;{\n&lt;span class=\"hljs-type\"&gt;float&lt;/span&gt; a, b, c,f;\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;please input 3 sides of one triangle:\\n&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-built_in\"&gt;scanf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;%f,%f,%f&amp;#34;&lt;/span&gt;, &amp;amp;a, &amp;amp;b, &amp;amp;c);\nf&amp;#61;&lt;span class=\"hljs-built_in\"&gt;area&lt;/span&gt;(a,b,c);\n&lt;span class=\"hljs-built_in\"&gt;printf&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;area of triangle is %10.5f\\n&amp;#34;&lt;/span&gt;, f);\n}\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "强制类型转换", "Question": ["我定义的函数里是float为什么最后的返回值是int型", ["问题遇到的现象和发生背景", "\n", "#include <stdio.h>", "\n", "#include<math.h>", "\n", "int area (float a, float b,float c)", "{", "    float d, s;", "    d = (a + b + c) / 2;", "    s = sqrt(d * (d - a) * (d - b) * (d - c));", "    return s;", "}", "\n", "int main()", "{", "    float a, b, c,f;", "    printf(\"please input 3 sides of one triangle:\\n\");", "    scanf_s(\"%f，%f，%f\", &a, &b, &c);", "    f=area(a,b,c);", "    printf(\"area of triangle is %10.5f\\n\", f);", "}    ", "\n", "\n", "算术溢出: 使用 4 字节值上的运算符 * ，然后将结果转换到 8 字节值。在调用运算符 * 之前将值强制转换为宽类型可避免溢出(io.2)。", "”=“ 从“double”转换到“float”，可能丢失数据  8", "    “=”: 从“int”转换到“float”，可能丢失数据  18    ", "\n", "我的解答思路和尝试过的方法", "\n", "我想最后的返回值为float型"]], "Tag": "程序设计"}
{"Answer": "楼主的问题跟反射没关系，只是跟可变长度参数有关系而已。\r\n简单来说，Java的可变长度参数（varargs）就是一种语法糖，可以让你把写可变个数的参数，由编译器帮忙打包成数组，也可以直接传数组进去：\r\npublic class VarargsDemo {\r\n    static void foo(String s, Object... args) { // varargs here\r\n        System.out.println(s);\r\n        for (Object o : args) {\r\n            System.out.println(o);\r\n        }\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        Object[] array = { \"a\", \"b\", \"c\" };\r\n        foo(\"test1\", array);         // pass in array\r\n        foo(\"test2\", \"d\", \"e\", \"f\"); // let compiler generate the array\r\n    }\r\n}\r\n如果在上面的代码里写成这样：foo(null, null);的话，编译器就无法分辨这个null到底是指new Object[] { null }（作为Object类型）还是就是null（作为Object[]）。\r\n所以如果遇到varargs时，要传入一个Object类型的参数，值为null的话，就在null前面加一个(Object)的转换就行：\r\nfoo(\"testNull\", (Object)null);\r\n这样编译器就知道这是要让它来打包数组。这样args就是{ null }，一个长度为1的一维数组。\r\n如果写成：\r\nfoo(\"testNullArray\", (Object[])null);\r\n那就是告诉编译器不要打包数组，直接传个null作为args的值。\r\n\r\n把上面的例子修改一下：\r\npublic class Demo {\r\n    static void foo(String s, Object... args) {\r\n        System.out.println(s);\r\n        for (Object o : args) {\r\n            System.out.println(o);\r\n        }\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        Object[] array = { \"a\", \"b\", \"c\" };\r\n        foo(\"test1\", array);\r\n        foo(\"test2\", \"d\", \"e\", \"f\");\r\n        foo(\"testNull\", (Object)null);\r\n        foo(\"testNullArray\", (Object[])null);\r\n    }\r\n}\r\n运行，输出是：\r\ntest1\r\na\r\nb\r\nc\r\ntest2\r\nd\r\ne\r\nf\r\ntestNull\r\nnull\r\ntestNullArray\r\nException in thread \"main\" java.lang.NullPointerException\r\n        at y.foo(y.java:4)\r\n        at y.main(y.java:14)\r\n可以看到null的两种用法的区别。", "Konwledge_Point": "强制类型转换", "Question": ["Reflect API警告问题", ["警告地方（ms[0].invoke(o,null);） ", "最后报了一个警告： ", "要从类型 Method 中调用 varargs 方法 invoke（Object, Object...），应该将类型为 null 的参数显式地强制转换为 Object[]。对于 varargs 调用来说，也可以将其强制转换为 Object ", "不是很明白问题警告中应该将类型为 null 的参数显式地强制转换为 Object[]。对于 varargs 调用来说，也可以将其强制转换为 Object。应该怎样改。", "\n\n", " ", "\n\n", "import java.lang.reflect.*; ", "public class ClassTest ", "{ ", "public static void main(String[] args) ", "{ ", "try ", "{ ", "Class c=Class.forName(args[0]); ", "Constructor[] conc=c.getDeclaredConstructors(); ", "Class[] params=conc[0].getParameterTypes(); ", "Object[] paramValues=new Object[params.length]; ", "for(int i=0;i<params.length;i++) ", "{ ", "if(params[i].isPrimitive()) ", "paramValues[i]=new Integer(i+3); ", "} ", "Object o=conc[0].newInstance(paramValues); ", "Method[] ms=c.getDeclaredMethods(); ", "try{ ", "ms[0].invoke(o,null); ", "} ", "catch(IllegalAccessException e){ ", "e.printStackTrace(); ", "} ", "catch(IllegalArgumentException e){ ", "e.printStackTrace(); ", "} ", "catch(InvocationTargetException e){ ", "e.printStackTrace(); ", "} ", "catch(NullPointerException e){ ", "e.printStackTrace(); ", "} ", "catch(Exception e){ ", "e.printStackTrace(); ", "} ", "} ", "catch(Exception ex) ", "{ ", "} ", "} ", "} ", "class Point ", "{ ", "static ", "{ ", "System.out.println(\"Ponit is loading\"); ", "} ", "int x,y; ", "void outPut() ", "{ ", "System.out.println(\"X=\"+x+\"Y=\"+y); ", "              } ", "Point(int x,int y){ ", "this.x=x; ", "this.y=y; ", "} ", "} ", "class Line ", "{ ", "static ", "{ ", "System.out.println(\"Line is loading\"); ", "} ", "} "]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你好&amp;#xff0c;针对你这个问题其实解决不难&amp;#xff0c;主要是找准位置点&amp;#xff0c;即判别那里出现问题。&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    从你给出的错误信息&amp;#xff1a;“无法将类型为“System.Net.FileWebRequest”的对象强制转换为类型“System.Net.HttpWebRequest””我猜测应该是对方后台给出的异常提示&amp;#xff0c;但是既然人家提供接口&amp;#xff0c;出现错误的可能性不大&amp;#xff0c;极大的可能性就是你调用规范有误&amp;#xff0c;没有按照对方接口规范来请求。&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    既然判断出是你没有按照对方规范来请求&amp;#xff0c;那么处理办法就是先保证一次请求正常&amp;#xff0c;而最便捷的方式就是先使用postman、代码demo来尝试&amp;#xff0c;先请求成功&amp;#xff0c;再将请求成功的经验利用到正式业务逻辑中。&lt;/span&gt;&lt;br /&gt;&lt;span style=\"display:inline-block;text-indent:2em;\"&gt;    注意&amp;#xff1a;看对方接口有token令牌&amp;#xff0c;这个是有时效性的。&lt;/span&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["接入第三方系统时接口调用出现错误", ["问题遇到的现象和发生背景", "\n", "接入第三方系统时接口调用出现错误", "\n", "用代码块功能插入代码，请勿粘贴截图", "\n", "<", "add", " ", "key", "=", "\"Url\"", " ", "value", "=", "\"https://a1.7x24cc.com/commonInte?flag=107\"", " />", "\n    ", "\n    ", "<", "add", " ", "key", "=", "\"appid\"", " ", "value", "=", "\"pj1cowppsc3di\"", " />", "\n    ", "\n    ", "<", "add", " ", "key", "=", "\"VoiceRecId\"", " ", "value", "=", "\"1012\"", " />", "\n    ", "\n    ", "<", "add", " ", "key", "=", "\"ServiceNo\"", " ", "value", "=", "\"02020994\"", " />", "\n    ", "\n    ", "<", "add", " ", "key", "=", "\"PlayTimes\"", " ", "value", "=", "\"2\"", " />", "\n    ", "\n    ", "<", "add", " ", "key", "=", "\"SoftVersion\"", " ", "value", "=", "\"2016-01-01\"", " />", "\n    ", "<", "add", " ", "key", "=", "\"Account\"", " ", "value", "=", "\"N000008447\"", " />", "\n    ", "<", "add", " ", "key", "=", "\"accessToken\"", " ", "value", "=", "\"4c3ba2105fd7dba195b82eb761\"", " />", "\n\n", "\n", "运行结果及报错内容", "\n", "无法将类型为“System.Net.FileWebRequest”的对象强制转换为类型“System.Net.HttpWebRequest”", "\n\n", "我想要达到的结果", "\n", "接口调用成功返回{\"success\":true;\"accessToken\":\"ACCESSTOKEN\",﻿\"invalidTime\" : \"2018-11-05 14:25:13\",\"message\":\"更新accessToken成功\"}"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;以下答案由GPT-3.5大模型与博主波罗歌共同编写&amp;#xff1a;&lt;br /&gt;首先需要确认从ActionScript 3中调用PowerShell运行脚本的部分代码是否正确&amp;#xff0c;因为从报错信息来看&amp;#xff0c;很可能是执行到Add方法时$doc对象为null。&lt;/p&gt;\n&lt;p&gt;以下是检查代码的建议&amp;#xff1a;&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;确认PowerShell的执行权限及策略&amp;#xff0c;建议打开命令行&amp;#xff0c;执行powershell.exe&amp;#xff0c;尝试执行createWord2.ps1脚本&amp;#xff0c;根据情况选择开启或关闭 Execution Policy。设置执行策略的方法请参考微软官方文档。如果是在管理员模式下双击脚本文件执行&amp;#xff0c;则默认执行策略为Unrestricted&amp;#xff0c;这个一般不需要额外处理。 &lt;/li&gt;&lt;li&gt;确认Powershell脚本的代码无误。可以创建一个新的脚本文件&amp;#xff0c;只包含上述PowerShell代码&amp;#xff0c;然后执行看看是否可以正常运行。&lt;/li&gt;&lt;li&gt;确认com对象名称是否正确。在PowerShell中使用com对象的时候需要正确的对象名称&amp;#xff0c;正确的方法是打开Word&amp;#xff0c;打开VBA编辑器&amp;#xff0c;查看对象模型中的名称。或者用下面代码来获取对象的完整名称&amp;#xff1a;&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-string\"&gt;Get-ChildItem&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;HKLM&lt;/span&gt;:\\&lt;span class=\"hljs-string\"&gt;SOFTWARE&lt;/span&gt;\\&lt;span class=\"hljs-string\"&gt;Classes&lt;/span&gt;\\&lt;span class=\"hljs-string\"&gt;TypeLib&lt;/span&gt;\\ | &lt;span class=\"hljs-string\"&gt;where&lt;/span&gt; { $&lt;span class=\"hljs-string\"&gt;_&lt;/span&gt;.&lt;span class=\"hljs-string\"&gt;Name&lt;/span&gt; -&lt;span class=\"hljs-string\"&gt;match&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#39;^\\d|^M&amp;#39;&lt;/span&gt; } | &lt;span class=\"hljs-string\"&gt;Get-ItemProperty&lt;/span&gt; | &lt;span class=\"hljs-string\"&gt;select&lt;/span&gt; -&lt;span class=\"hljs-string\"&gt;Expand&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;Description&lt;/span&gt; | &lt;span class=\"hljs-string\"&gt;select&lt;/span&gt; -&lt;span class=\"hljs-string\"&gt;Unique&lt;/span&gt; -&lt;span class=\"hljs-string\"&gt;OutVariable&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;objDesc&lt;/span&gt; ; &lt;span class=\"hljs-built_in\"&gt;get-item&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;HKLM&lt;/span&gt;:\\&lt;span class=\"hljs-string\"&gt;SOFTWARE&lt;/span&gt;\\&lt;span class=\"hljs-string\"&gt;Classes&lt;/span&gt;\\&lt;span class=\"hljs-string\"&gt;TypeLib&lt;/span&gt;\\ | &lt;span class=\"hljs-string\"&gt;where&lt;/span&gt; {\n (&lt;span class=\"hljs-built_in\"&gt;get-itemproperty&lt;/span&gt; $&lt;span class=\"hljs-string\"&gt;_&lt;/span&gt;.&lt;span class=\"hljs-string\"&gt;PSPath&lt;/span&gt;) -&lt;span class=\"hljs-string\"&gt;match&lt;/span&gt; $&lt;span class=\"hljs-string\"&gt;objDesc&lt;/span&gt; } | &lt;span class=\"hljs-built_in\"&gt;get-itemproperty&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;PSPath&lt;/span&gt; | &lt;span class=\"hljs-string\"&gt;select&lt;/span&gt; -&lt;span class=\"hljs-string\"&gt;Expand&lt;/span&gt; &lt;span class=\"hljs-string\"&gt;&amp;#34;(default)&amp;#34;&lt;/span&gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;/li&gt;&lt;li&gt;确认代码是否可以在64位系统中正常运行&amp;#xff0c;比如AS3是否是以64位方式运行。可以尝试将PowerShell脚本中的文档保存路径改为非系统盘符&amp;#xff0c;如D:\\myWord.docx&amp;#xff0c;再运行看看是否仍会报错。 &lt;/li&gt;&lt;/ol&gt;\n&lt;p&gt;以下是一个ActionScript 3中调用PowerShell运行脚本的示例代码&amp;#xff0c;可以参考&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;var&lt;/span&gt; psFile:&lt;span class=\"hljs-type\"&gt;File &lt;/span&gt;&amp;#61; File.desktopDirectory.resolvePath(&lt;span class=\"hljs-string\"&gt;&amp;#34;createWord2.ps1&amp;#34;&lt;/span&gt;);\n&lt;span class=\"hljs-keyword\"&gt;var&lt;/span&gt; processInfo:&lt;span class=\"hljs-type\"&gt;NativeProcessStartupInfo &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;NativeProcessStartupInfo&lt;/span&gt;();\nprocessInfo.executable &amp;#61; File.applicationDirectory.resolvePath(&lt;span class=\"hljs-string\"&gt;&amp;#34;powershell.exe&amp;#34;&lt;/span&gt;);\nprocessInfo.arguments &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;&lt;/span&gt;&amp;lt;&lt;span class=\"hljs-keyword\"&gt;String&lt;/span&gt;&amp;gt;[&lt;span class=\"hljs-string\"&gt;&amp;#34;-ExecutionPolicy&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;Bypass&amp;#34;&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;-File&amp;#34;&lt;/span&gt;, psFile.nativePath];\n&lt;span class=\"hljs-keyword\"&gt;var&lt;/span&gt; psProcess:&lt;span class=\"hljs-type\"&gt;NativeProcess &lt;/span&gt;&amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;NativeProcess&lt;/span&gt;();\npsProcess.addEventListener(NativeProcessExitEvent.EXIT, &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;function&lt;/span&gt; &lt;/span&gt;(event:&lt;span class=\"hljs-type\"&gt;NativeProcessExitEvent&lt;/span&gt;):&lt;span class=\"hljs-type\"&gt;void &lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;// 处理退出事件&amp;#xff0c;根据需要进行操作&lt;/span&gt;\n});\npsProcess.addEventListener(NativeProcessErrorEvent.STANDARD_ERROR_IO_ERROR, &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;function&lt;/span&gt; &lt;/span&gt;(event:&lt;span class=\"hljs-type\"&gt;NativeProcessErrorEvent&lt;/span&gt;):&lt;span class=\"hljs-type\"&gt;void &lt;/span&gt;{\n    &lt;span class=\"hljs-comment\"&gt;// 处理错误事件&amp;#xff0c;根据错误信息进行调整&lt;/span&gt;\n    &lt;span class=\"hljs-built_in\"&gt;trace&lt;/span&gt;(&lt;span class=\"hljs-string\"&gt;&amp;#34;process error :&amp;#34;&lt;/span&gt;, event.text);\n});\npsProcess.start(processInfo);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码中&amp;#xff0c;我们首先通过File类获取PowerShell脚本文件所在的路径&amp;#xff0c;然后定义一个NativeProcessStartupInfo对象&amp;#xff0c;设置可执行文件为PowerShell&amp;#xff0c;同时设置执行参数。最后&amp;#xff0c;创建并启动NativeProcess实例。&lt;/p&gt;\n&lt;p&gt;完整的PowerShell脚本代码见下&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;Add-Type -AssemblyName Microsoft.Office.Interop.Word\n&lt;span class=\"hljs-built_in\"&gt;$word&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-keyword\"&gt;New&lt;/span&gt;-Object -ComObject Word.Application\n&lt;span class=\"hljs-built_in\"&gt;$doc&lt;/span&gt;  &amp;#61; &lt;span class=\"hljs-built_in\"&gt;$word&lt;/span&gt;.Documents.Add()\n&lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;$doc&lt;/span&gt;.Sections.Item(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt;.PageSetup.LeftMargin &amp;#61; &lt;span class=\"hljs-number\"&gt;36&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt;.PageSetup.RightMargin &amp;#61; &lt;span class=\"hljs-number\"&gt;36&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt;.PageSetup.TopMargin &amp;#61; &lt;span class=\"hljs-number\"&gt;36&lt;/span&gt;\n&lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt;.PageSetup.BottomMargin &amp;#61; &lt;span class=\"hljs-number\"&gt;36&lt;/span&gt; \n\n&lt;span class=\"hljs-built_in\"&gt;$Header&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt;.Headers.Item(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$Footer&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;$section&lt;/span&gt;.Footers.Item(&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$myDoc&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;$word&lt;/span&gt;.Selection\n&lt;span class=\"hljs-built_in\"&gt;$myDoc&lt;/span&gt;.TypeText(&lt;span class=\"hljs-string\"&gt;&amp;#34;111111&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$myDoc&lt;/span&gt;.TypeText(&lt;span class=\"hljs-string\"&gt;&amp;#34;2222222&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$myDoc&lt;/span&gt;.TypeText(&lt;span class=\"hljs-string\"&gt;&amp;#34;333\n3333&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$selection&lt;/span&gt; &amp;#61; &lt;span class=\"hljs-built_in\"&gt;$word&lt;/span&gt;.Selection\n&lt;span class=\"hljs-built_in\"&gt;$selection&lt;/span&gt;.InsertNewPage()\n&lt;span class=\"hljs-built_in\"&gt;$selection&lt;/span&gt;.EndKey(&lt;span class=\"hljs-number\"&gt;6&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$doc&lt;/span&gt;.SaveAs(&lt;span class=\"hljs-string\"&gt;&amp;#34;C:\\myMergeDoc.docx&amp;#34;&lt;/span&gt;)\n&lt;span class=\"hljs-built_in\"&gt;$doc&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;Close&lt;/span&gt;()\n&lt;span class=\"hljs-built_in\"&gt;$word&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;Quit&lt;/span&gt;()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果我的回答解决了您的问题&amp;#xff0c;请采纳&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["as3调用ps1脚本操作office word报错，最好来个既会as3又会powershell的", ["一段用powershell操作office word的代码，在这台win7 64位的系统上直接双击ps1脚本文件能正常运行，但是一通过其他语言（actionscript 3）来调用执行就会报错，值得注意的是，在另一台win7 64位电脑上无论直接双击还是用actionscript 3调用都没问题。", "\n", "已经排除权限问题，值得注意的是，在另一台win10电脑上也遇到同样的报错。", "\n", "# 加载Word应用程序", "\n", "$word", " = ", "New", "-", "Object", " -ComObject Word.Application\n", "#$word.visible=$true", "\n", "# 打开文档", "\n", "$doc", " = ", "$word", ".Documents.Add()\n", "# 设置页面边距", "\n", "$section", " = ", "$doc", ".Sections.Item(", "1", ")\n", "$section", ".PageSetup.LeftMargin = ", "36", "\n", "$section", ".PageSetup.RightMargin = ", "36", "\n", "$section", ".PageSetup.TopMargin = ", "36", "\n", "$section", ".PageSetup.BottomMargin = ", "36", "\n ", "#获取文档object", "\n", "$Section", " = ", "$doc", ".Sections.Item(", "1", ");\n", "#获取页眉", "\n", "$Header", " = ", "$Section", ".Headers.Item(", "1", ");\n", "#获取页脚", "\n", "$Footer", " = ", "$Section", ".Footers.Item(", "1", ");\n", "#设置页眉页码", "\n", "$myDoc", "=", "$word", ".Selection\n", "$myDoc", ".TypeText(", "\"111111\"", ")  ", "#processArgs[4]", "\n", "$myDoc", ".TypeText(", "\"2222222\"", ")  ", "#processArgs[5]", "\n", "$myDoc", ".TypeText(", "\"333\n3333\"", ")  ", "#processArgs[6]", "\n", "# 插入空白页", "\n", "$selection", " = ", "$word", ".Selection\n", "$selection", ".InsertNewPage()\n", "# 将光标移动到文档结尾", "\n", "$selection", ".EndKey([Microsoft.Office.Interop.Word.WdUnits]::wdStory)\n", "# 保存并关闭文档", "\n", "$doc", ".SaveAs([ref]", "\"C:\\myMergeDoc.docx\"", ")\n", "$doc", ".Close()\n", "# 关闭Word应用程序", "\n", "$word", ".Quit()\n", "\n", "报错内容如下（因为是从flash里面输出的报错信息，所以内容可能会和PS直接输出的有点不一样，主要就是多了几个as3那边的变量，比如process error ，以及process 都是as3的变量可以忽略）：", "\n", "process ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:5 字符: 27\n\n+ ", "$doc", " = ", "$word", ".Documents.", "Add", " <<<< ()\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (Add:String) [], RuntimeExcept \n\n   ion\n\nprocess ", "error", " :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess ", "error", " : \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:7 字符: 30\n\nprocess ", "error", " :+ ", "$section", " = ", "$doc", ".Sections.Item <<<< (1)\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (Item:String) [], RuntimeExcep \n\nprocess ", "error", " :   tion\n\nprocess ", "error", " :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess ", "error", " : \n\nprocess ", "error", " :在此对象上找不到属性“LeftMargin”；请确保该属性存在且可设置。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:8 字符: 20\n\nprocess ", "error", " :+ ", "$section", ".PageSetup. <<<< LeftMargin = 36\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (LeftMargin:String) [], Runtim \n\nprocess ", "error", " :   eException\n\nprocess ", "error", " :    + FullyQualifiedErrorId : PropertyNotFound\n\n \n\nprocess ", "error", " :在此对象上找不到属性“RightMargin”；请确保该属性存在且可设置。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:9 字符: 20\n\nprocess ", "error", " :+ ", "$section", ".PageSetup. <<<< RightMargin = 36\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (RightMargin:String) [], Runti \n\nprocess ", "error", " :   meException\n\nprocess ", "error", " :    + FullyQualifiedErrorId : PropertyNotFound\n\nprocess ", "error", " : \n\nprocess ", "error", " :在此对象上找不到属性“TopMargin”；请确保该属性存在且可设置。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:10 字符: 20\n\nprocess ", "error", " :+ ", "$section", ".PageSetup. <<<< TopMargin = 36\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (TopMargin:String) [], Runtime \n\nprocess ", "error", " :   Exception\n\nprocess ", "error", " :    + FullyQualifiedErrorId : PropertyNotFound\n\n \n\nprocess ", "error", " :在此对象上找不到属性“BottomMargin”；请确保该属性存在且可设置。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:11 字符: 20\n\nprocess ", "error", " :+ ", "$section", ".PageSetup. <<<< BottomMargin = 36\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (BottomMargin:String) [], Runt \n\nprocess ", "error", " :   imeException\n\n    + FullyQualifiedErrorId : PropertyNotFound\n\n \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:13 字符: 30\n\n+ ", "$Section", " = ", "$doc", ".Sections.Item <<<< (1);\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (Item:String) [], RuntimeExcep \n\nprocess ", "error", " :   tion\n\n    + FullyQualifiedErrorId : InvokeMethodOnNull\n\n \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:15 字符: 32\n\nprocess ", "error", " :+ ", "$Header", " = ", "$Section", ".Headers.Item <<<< (1);\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (Item:String) [], RuntimeExcep \n\n   tion\n\n    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess ", "error", " : \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:17 字符: 32\n\n+ ", "$Footer", " = ", "$Section", ".Footers.Item <<<< (1);\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (Item:String) [], RuntimeExcep \n\nprocess ", "error", " :   tion\n\nprocess ", "error", " :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\n \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\n所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:20 字符: 16\n\nprocess ", "error", " :+ ", "$myDoc", ".TypeText <<<< (", "\"111111\"", ")  #processArgs[4]\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (TypeText:String) [], RuntimeE \n\nprocess ", "error", " :   xception\n\nprocess ", "error", " :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess ", "error", " : \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:21 字符: 16\n\nprocess ", "error", " :+ ", "$myDoc", ".TypeText <<<< (", "\"2222222\"", ")  #processArgs[5]\n\nprocess ", "error", " :    + CategoryInfo          : InvalidOperation: (TypeText:String) [], RuntimeE \n\nprocess ", "error", " :   xception\n\nprocess ", "error", " :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess ", "error", " : \n\nprocess ", "error", " :不能对值为空的表达式调用方法。\n\nprocess ", "error", " :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:22 字符: 16\n\nprocess ", "error", " :+ ", "$myDoc", ".TypeText <<<< (", "\"333\n\nprocess error :    + CategoryInfo          : InvalidOperation: (TypeText:String) [], RuntimeE \n\n   xception\n\n    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess error : \n\nprocess error :不能对值为空的表达式调用方法。\n\nprocess error :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:26 字符: 25\n\n+ ", "$selection", ".InsertNewPage <<<< ()\n\nprocess error :    + CategoryInfo          : InvalidOperation: (InsertNewPage:String) [], Run \n\nprocess error :   timeException\n\nprocess error :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess error : \n\nprocess error :不能对值为空的表达式调用方法。\n\nprocess error :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:28 字符: 18\n\nprocess error :+ ", "$selection", ".EndKey <<<< ([Microsoft.Office.Interop.Word.WdUnits]::wdStory)\n\nprocess error :    + CategoryInfo          : InvalidOperation: (EndKey:String) [], RuntimeExc \n\nprocess error :   eption\n\nprocess error :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess error : \n\nprocess error :不能对值为空的表达式调用方法。\n\nprocess error :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:30 字符: 12\n\n+ ", "$doc", ".SaveAs <<<< ([ref]\"", "C:\\myMergeDoc.docx", "\")\n\nprocess error :    + CategoryInfo          : InvalidOperation: (SaveAs:String) [], RuntimeExc \n\nprocess error :   eption\n\n    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess error : \n\nprocess error :不能对值为空的表达式调用方法。\n\nprocess error :所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:31 字符: 11\n\n+ ", "$doc", ".Close <<<< ()\n\nprocess error :    + CategoryInfo          : InvalidOperation: (Close:String) [], RuntimeExce \n\nprocess error :   ption\n\nprocess error :    + FullyQualifiedErrorId : InvokeMethodOnNull\n\nprocess error : \n\nprocess error :使用“3”个参数调用“Quit”时发生异常:“无法将类型为“Microsoft.Office.Interop.Word.A\n\nprocess error :pplicationClass”的 COM 对象强制转换为接口类型“Microsoft.Office.Interop.Word._Ap\n\nplication”。此操作失败的原因是对 IID 为“{00020970-0000-0000-C000-000000000046}”\n\nprocess error :的接口的 COM 组件调用 QueryInterface 因以下错误而失败: 加载类型库/DLL 时出错。 (\n\n异常来自 HRESULT:0x80029C4A (TYPE_E_CANTLOADLIBRARY))。”\n\n所在位置 D:\\2023年3月7日_测_as3直接操作ps写word\\bin\\createWord2.ps1:33 字符: 11\n\nprocess error :+ ", "$word", ".Quit <<<< ()\n\n    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException\n\n    + FullyQualifiedErrorId : DotNetMethodException\n\nprocess error : \n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "CaptureD(); 是不是只能初始化1次，你定义成static，多次调用。看名字好像是图像捕捉？那么设备只能打开并且被一个对象调用。", "Konwledge_Point": "强制类型转换", "Question": ["C# 不同控件调用同一方法出错。", ["private void btn_Record_Click(object sender, EventArgs e)", "\n        {", "\n            record();", "\n        }", "\n                //在一个button上调用了一个record（）方法。此方法可以正常使用", "\n\n", "             private void port_PinChanged(object sender, System.IO.Ports.SerialPinChangedEventArgs e)\n    {\n            switch (e.EventType)\n            {\n                case System.IO.Ports.SerialPinChange.DsrChanged:\n                    //开始录像\n                    if (com.DsrHolding == true)\n                    {\n                                                record();\n                    }\n                    break;\n                default:\n                    break;\n            }\n            //在一个SerialPort的PinChanged事件上也调用了一个record（）方法。\n            但是为啥会报一下错误---------------------------\n", "\n\n", "无法将类型为“DirectShowLib.CaptureGraphBuilder2”的 COM 对象强制转换为接口类型“DirectShowLib.ICaptureGraphBuilder2”。此操作失败的原因是对 IID 为“{93E5A4E0-2D50-11D2-ABFA-00A0C9C6E38D}”的接口的 COM 组件调用 QueryInterface 因以下错误而失败: 不支持此接口 (异常来自 HRESULT:0x80004002 (E_NOINTERFACE))。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;要保证 java.txt 文件使用 GBK 编码存储才能用 GBK 编码读取&amp;#xff0c;否则就会乱码&amp;#xff0c;如果你不确定编码类型的话可以改成 &lt;code class=\"language-javascript\"&gt;UTF-8&lt;/code&gt; 试试看&amp;#xff0c;这个编码用的比较多。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["【java】使用字符流复制文件  乱码", ["问题相关代码，请勿粘贴截图", "\n", "\n", "import", " java.io.FileInputStream;\n", "import", " java.io.FileOutputStream;\n", "import", " java.io.IOException;\n", "import", " java.io.InputStreamReader;\n", "import", " java.io.OutputStreamWriter;\n", "import", " java.nio.CharBuffer;\n\n", "public", " ", "class", " ", "Ooutputstreamwrite", " {\n\n    ", "public", " ", "static", " ", "void", " ", "main", "(String[] args)", " ", "throws", " IOException {\n\n        OutputStreamWriter o= ", "new", " ", "OutputStreamWriter", "(", "new", " ", "FileOutputStream", "(", "\"D:\\\\FILE\\\\a.txt\"", "),", "\"GBK\"", ");\n        ", "/* 构造方法\n         * OutputStreamWriter(OutputStream out)\n         * OutputStreamWriter(OutputStream out,String charsetName) */", "\n        InputStreamReader i= ", "new", " ", "InputStreamReader", "(", "new", " ", "FileInputStream", "(", "\"D:\\\\FILE\\\\java.txt\"", "),", "\"GBK\"", ");\n\n        ", "char", "[]  b=", "new", " ", "char", "[", "100", "];\n        ", "while", "(i.read(b)!=-", "1", ") {\n            o.write(b);\n        }\n        o.close();\n        i.close();\n\n    }\n\n}\n\n", "\n", "运行结果及报错内容", "\n", "a.txt文件复制内容乱码", "\n", "我的解答思路和尝试过的方法", "\n", "加上了GBK编码为什么还是乱码，new String（）方法里面要求的是 byte[]类型，强制转换也不行，字符流用来操作中文的便利性体现在哪里，感觉还是很麻烦", "\n", "我想要达到的结果", "\n", "成功复制中文"]], "Tag": "程序设计"}
{"Answer": "问题一：不是将第一次的值给覆盖了，IntWarapper wrapper = null;null在底层也是一种指针，这个你先不用管，就把它当成，给wrapper初始化为空，不指向任何对象，wrapper = new intwrapper这一句，jvm在运行的时候发现new关键字，在堆中开辟内存空间，并调用构造方法进行初始化，返回这个对象的引用，并赋值给wrapper变量，引用类似C语言的指针但稍有区别，刚开始学习可以把它当成指针\r\n问题二：java中成员变量如果你不对它进行初始化，jvm也会把它赋值为0或者null或者false，类型不同，就不同，局部变量，需要自己初始化，另外，其实一般情况下都是构造器中进行初始化的，因为你要使用它，肯定要给它赋值，如果不初始化的话，基本类型可能只会造成逻辑错误，引用类型会直接崩溃并抛出控指针异常\r\n另外如果需要使用包装类，可以使用java自带的包装类库", "Konwledge_Point": "强制类型转换", "Question": ["关于包装类 提出一个问题", ["下面这个程序是模拟对Integer的一个包装。", "\n\n", "     public class IntWrapper\n\n    {\n\n    private int value;\n\n    public IntWrapper(int value)\n\n    {\n\n    this.value = value;\n\n    }\n\n    // 包含int类型相关的算法\n\n    把十进制转换成2进制，8进制和16进制\n\n    }\n\n    ...main...\n\n    {\n\n    IntWarapper wrapper = null；\n\n     wrapper = new intwrapper(17);\n\n    }\n", "\n\n", "学了一段时间的Java，现在忽然有些困惑。", "\n第一次 IntWarapper wrapper = null；", "\n第二次 wrapper =  new intwrapper(17);", "\n\n", "    问题一： 第二次是将第一次的值给覆盖了吗。\n    问题二： 在我们编写java程序的时候，哪些值是需要初始化或者说程序强制初始化，哪些值是不需要初始化的。\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;空指针了么不是&amp;#xff0c;54行这里this后的值都是没有的&amp;#xff0c;有参构造方法里边传值进来没有赋值&amp;#xff0c;这样改一下试试&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt; &lt;span class=\"hljs-function\"&gt;&lt;span class=\"hljs-keyword\"&gt;public&lt;/span&gt; &lt;span class=\"hljs-title\"&gt;Object_4&lt;/span&gt;&lt;span class=\"hljs-params\"&gt;(&lt;span class=\"hljs-type\"&gt;String&lt;/span&gt; name, &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; age)&lt;/span&gt;&lt;/span&gt;{\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.name&amp;#61;name;\n        &lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;.age&amp;#61;age;\n    }\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/129604128766192.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img align=\"left\" alt=\"img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/964648128766149.png\" class=\"md_img\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["java中遇到的问题，难以解决", ["Object_4.java", "\n", "package ", "JAVA", ";\n\n", "public", " ", "class", " ", "Object_4", " {\n    ", "private", " ", "String", " name;\n    ", "private", " int age;\n    ", "//设置内部类为外部类传递参数参数", "\n    ", "public", " ", "Object", "_4(){\n        ", "//TODO Auto-generated constructor stub", "\n        ", "//添加TODO方法", "\n    }\n    ", "public", " ", "Object", "_4(", "String", " name, int age){\n\n    }\n\n    ", "//添加Getter和Setter方法。", "\n    ", "public", " ", "String", " ", "getName", "(", ") {\n        ", "return", " name;\n    }\n\n    ", "public", " ", "void", " ", "setName", "(", "String", " name", ") {\n        ", "this", ".", "name", " = name;\n    }\n\n    ", "public", " int ", "getAge", "(", ") {\n        ", "return", " age;\n    }\n\n    ", "public", " ", "void", " ", "setAge", "(", "int age", ") {\n        ", "this", ".", "age", " = age;\n    }\n\n    ", "//重构toString方法", "\n\n    ", "@Override", "\n    ", "public", " ", "String", " ", "toString", "(", ") {\n        ", "return", "  ", "\"姓名：\"", "+", "this", ".", "name", "+", "\"，年龄:\"", "+", "this", ".", "age", ";\n    }\n\n    ", "//重写equals方法", "\n    ", "@Override", "\n    ", "public", " ", "boolean", " ", "equals", "(", "Object", " obj", ") {\n        ", "//判断内存地址", "\n        ", "if", " (obj == ", "this", ") {\n            ", "return", " ", "true", ";\n        }\n        ", "if", " (obj == ", "null", ") {\n            ", "return", " ", "false", ";\n        }\n        ", "//判断是否是同一类型的对象", "\n        ", "if", " (obj ", "instanceof", " ", "Object", "_4) {\n            ", "//强制转换成Person类型", "\n            ", "Object", "_4 s = (", "Object", "_4) obj;\n            ", "//判断他们的属性值    注：这里的age为什么要用==？可以在评论区回答", "\n            ", "if", " (", "this", ".", "name", ".", "equals", "(s.", "name", ") && ", "this", ".", "age", " == (s.", "age", ")) {\n                ", "return", " ", "true", ";\n            }\n        }\n        ", "return", " ", "false", ";\n    }\n}\n\n", "\n", "Test.java", "\n", "package JAVA;\n\npublic ", "class", " Test04 {\n    public static void main(String", "[]", " args) {\n        Object_4 s1=", "new", " ", "Object_4(", "\"ZYH\"", ",20)", ";\n        Object_4 s2=", "new", " ", "Object_4(", "\"SG\"", ",20)", ";\n        ", "//getClass()方法是获得调用该方法的类", "\n        Class class1=s1.get", "Class()", ";\n        Class class2=s2.get", "Class()", ";\n        ", "if", "(class1==class2){  ", "//class方法的返回值是一个类型", "\n            ", "System", ".", "out.println(", "\"s1和s2是同一个类型\"", ");\n        }", "else", "{\n            ", "System", ".", "out.println(", "\"s1和s2不是同一个类型\"", ");\n        }\n        ", "System", ".", "out.println(", "\"=======================\"", ");\n        ", "//hashCode()方法： 对象的地址字符串或数字使用hash算法计算出来的int类型的数值", "\n        ", "System", ".", "out.println(s1.hash", "Code()", ");\n        ", "System", ".", "out.println(s2.hash", "Code()", ");\n        ", "System", ".", "out.println(", "\"=======================\"", ");\n        ", "//toString方法: 返回类名和他的引用地址", "\n        ", "System", ".", "out.println(s1.", "to", "String()", ");\n        ", "System", ".", "out.println(s2.", "to", "String()", ");\n        ", "System", ".", "out.println(", "\"=======================\"", ");\n        ", "//equals方法判断两个对象是否相等true/false", "\n        ", "System", ".", "out.println(s1.equals(s2));\n\n        Object_4 s3=", "new", " ", "Object_4(", "\"小敏\"", ",20)", ";\n        Object_4 s4=", "new", " ", "Object_4(", "\"小敏\"", ",20)", ";\n        ", "System", ".", "out.println(s3.equals(s4));\n    }\n}\n\n", "\n", "运行Tes.java的时候出现如下报错：", "\n", "\n", "跟着教程来写的，一模一样，但是我的始终不行。", "望帮忙解决，谢谢！！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考GPT的内容和自己的思路&amp;#xff0c;您可以尝试使用字符串比较方法 equals() 来比较两个字符串是否相等&amp;#xff0c;而不是使用 &amp;#61;&amp;#61; 运算符或强制类型转换后的 &amp;#61;&amp;#61; 比较。&lt;/p&gt;\n&lt;p&gt;以下是修改后的代码示例&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;public void login(View view){\n    EditText account &amp;#61; find&lt;span class=\"hljs-constructor\"&gt;ViewById(R.&lt;span class=\"hljs-params\"&gt;id&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;zhanghao&lt;/span&gt;)&lt;/span&gt;;\n    EditText password &amp;#61; find&lt;span class=\"hljs-constructor\"&gt;ViewById(R.&lt;span class=\"hljs-params\"&gt;id&lt;/span&gt;.&lt;span class=\"hljs-params\"&gt;pass&lt;/span&gt;)&lt;/span&gt;;\n    String got_account &amp;#61; account.get&lt;span class=\"hljs-constructor\"&gt;Text()&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;String()&lt;/span&gt;;\n    String got_password &amp;#61; password.get&lt;span class=\"hljs-constructor\"&gt;Text()&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;to&lt;/span&gt;&lt;span class=\"hljs-constructor\"&gt;String()&lt;/span&gt;;\n    SQLiteOpenHelper helper &amp;#61; &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;MySqliteOpenHelper&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;getm&lt;span class=\"hljs-constructor\"&gt;Instance(&lt;span class=\"hljs-params\"&gt;this&lt;/span&gt;)&lt;/span&gt;;\n    SQLiteDatabase db &amp;#61; helper.get&lt;span class=\"hljs-constructor\"&gt;ReadableDatabase()&lt;/span&gt;;\n\n    String sq &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;select * from users where _account &amp;#61; ?&amp;#34;&lt;/span&gt;;\n    Cursor cursor &amp;#61; db.raw&lt;span class=\"hljs-constructor\"&gt;Query(&lt;span class=\"hljs-params\"&gt;sq&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;new&lt;/span&gt; String[]{&lt;!-- --&gt;&lt;span class=\"hljs-params\"&gt;got_account&lt;/span&gt;})&lt;/span&gt;;\n\n    &lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; (cursor.get&lt;span class=\"hljs-constructor\"&gt;Count()&lt;/span&gt; &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;) {\n        &lt;span class=\"hljs-comment\"&gt;// 如果结果集中存在该账号&amp;#xff0c;则表示账号已存在&lt;/span&gt;\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Toast&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;make&lt;span class=\"hljs-constructor\"&gt;Text(DL.&lt;span class=\"hljs-params\"&gt;this&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;账号重复&amp;#34;&lt;/span&gt;, Toast.LENGTH_SHORT)&lt;/span&gt;.show&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n    } &lt;span class=\"hljs-keyword\"&gt;else&lt;/span&gt; {\n        &lt;span class=\"hljs-comment\"&gt;// 否则插入新账号&lt;/span&gt;\n        String sql &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;insert into users(_account,_password) values(?,?)&amp;#34;&lt;/span&gt;;\n        db.exec&lt;span class=\"hljs-constructor\"&gt;SQL(&lt;span class=\"hljs-params\"&gt;sql&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;new&lt;/span&gt; Object[]{&lt;!-- --&gt;&lt;span class=\"hljs-params\"&gt;got_account&lt;/span&gt;, &lt;span class=\"hljs-params\"&gt;got_password&lt;/span&gt;})&lt;/span&gt;;\n        &lt;span class=\"hljs-module-access\"&gt;&lt;span class=\"hljs-module\"&gt;&lt;span class=\"hljs-identifier\"&gt;Toast&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;make&lt;span class=\"hljs-constructor\"&gt;Text(DL.&lt;span class=\"hljs-params\"&gt;this&lt;/span&gt;, &lt;span class=\"hljs-string\"&gt;&amp;#34;注册成功&amp;#34;&lt;/span&gt;, Toast.LENGTH_SHORT)&lt;/span&gt;.show&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n    }\n\n    cursor.close&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n    db.close&lt;span class=\"hljs-literal\"&gt;()&lt;/span&gt;;\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在修改后的代码中&amp;#xff0c;使用了一个 select 语句来查询数据库中是否已经存在该账号&amp;#xff0c;如果结果集中存在该账号&amp;#xff0c;则表示账号已存在&amp;#xff0c;否则插入新账号。请注意&amp;#xff0c;在 select 语句中使用了一个参数占位符 ? 来代替要查询的账号&amp;#xff0c;这是为了避免 SQL 注入攻击。同时&amp;#xff0c;在 rawQuery 方法中传入了一个数组参数 new String[]{got_account}&amp;#xff0c;来代替参数占位符中的 ?&amp;#xff0c;以此来查询指定的账号。&lt;/p&gt;\n&lt;p&gt;回答不易&amp;#xff0c;还请采纳&amp;#xff01;&amp;#xff01;&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["Android 注册功能如何实现账号查重", ["Android 在使用sqlite完成注册功能时，使用if语句判定注册账号是否和数据库内账号列一致，使用equlas判定一直为否，将两个string强制转换类型后进行==比较依然为否。想询问一下如何才能在此基础上实现该功能。", "即，无论账号是否重复，运行结果一直显示else里的内容，除了使用账号：123，密码：123，这个例子能成功进入if。", "\n", "public void login(View view){", "//对应注册按钮", "\n        EditText account=find", "ViewById(R.", "id", ".", "zhanghao", ")", ";\n        EditText password=find", "ViewById(R.", "id", ".", "pass", ")", ";\n        String got_account=account.get", "Text()", ".", "to", "String()", ";\n        String got_password=password.get", "Text()", ".", "to", "String()", ";\n        SQLiteOpenHelper helper=", "MySqliteOpenHelper", ".", "getm", "Instance(", "this", ")", ";\n        SQLiteDatabase db=helper.get", "ReadableDatabase()", ";\n\n        ", "int", " a = ", "Integer", ".", "parse", "Int(", "got_account", ")", ";\n        String sq = ", "\"select * from users\"", ";\n        Cursor cursor=db.raw", "Query(", "sq", ",", "null", ")", ";", "//取users数据表中所有用户数据，cursor是迭代游标，用于遍历操作", "\n        ", "if", " (db.is", "Open()", "){", "//判断数据库是否成功打开", "\n            ", "while", "(cursor.move", "ToNext()", ") {\n                ", "int", " zhanghaoColumnIndex = cursor.get", "ColumnIndex(", "\"_account\"", ")", ";\n                 String _account = cursor.get", "String(", "zhanghaoColumnIndex", ")", ";\n                ", "int", " i =  ", "Integer", ".", "parse", "Int(", "_account", ")", ";\n                ", "if", " (a==i){\n                    ", "Toast", ".", "make", "Text(DL.", "this", ", ", "\"账号重复\"", ", Toast.LENGTH_SHORT)", ".show", "()", ";\n                    break;\n                }", "else", " {\n                    String sql = ", "\"insert into users(_account,_password) values(?,?)\"", ";", "//因为注册账号和密码需要获取用户输入的信息，所以我们暂时用问号代替，下面再用Object替代", "\n                    db.exec", "SQL(", "sql", ", ", "new", " Object[]{", "got_account", ", ", "got_password", "})", ";\n                    ", "Toast", ".", "make", "Text(DL.", "this", ", ", "\"注册成功\"", ", Toast.LENGTH_SHORT)", ".show", "()", ";\n                    break;\n                }\n            }\n            cursor.close", "()", ";", "//关闭迭代游标", "\n            db.close", "()", ";", "//关闭数据库", "\n        }\n\n"]], "Tag": "程序设计"}
{"Answer": "接口方法定义如下：\r\n\r\npublic QueryUserRsp getUsers(int[] userId, int[] groupId)\r\n\r\nQueryUserRsp :结果对象（包括 查询的User对象，还有操作码，或操作信息）\r\n\r\n\r\npublic class QueryUserRsp \r\n{\r\n       private ParamType[] paramType; // 拓展信息 该对象 两个成功变量（key,Vale）\r\n\r\n    private int returnCode; // 返回码，标识成功或失败\r\n\r\n    private java.lang.String returnMsg; // 返回操作信息\r\n}\r\n\r\n提供参考", "Konwledge_Point": "强制类型转换", "Question": ["接口设计问题", ["比如设计一个“用户查询”的webservice接口，有两种方式：", "\n[code=\"java\"]class User {", "\n   int id;", "\n   int groupId;", "\n   String name;", "\n   ......", "\n}", "\n\n", "1.", "\npublic String getUsers(int userId, int groupId);", "\n// 用这种方法可以返回一些错误信息，比如用户权限不够，参数错误，group不存在等等", "\n// 缺点是只能将User对象的属性拼成字符串，客户端得到后要自己解析字符串得到对象", "\n\n", "2.", "\npublic User[] getUsers(int userId, int groupId);", "\n// 这种方法的缺点是只能得到两种结果，一是有数据，一是没有数据", "\n// 如果没有得到数据，客户端很难判断是哪里出了问题，不好调试", "\n[/code]", "\n\n", "请各位帮忙分析一下，比较好的做法是什么？", "\n或者我想的都是错的，请指出正确的方法...", "\n[b]问题补充：[/b]", "\n一楼的意思明白了，我现在再写一个类", "\n[code=\"java\"]public class UserResponse {", "\n  private String message;", "\n  private User[] users;", "\n...", "\n}", "\n\n", "//接口改成：", "\npublic UserResponse getUsers();", "\n//这样就即可以得到错误消息又可以得到User对象的结果了[/code]", "\n\n", "再补充一个问题：", "\n我现在有几个类似User这样的类，每个都得这样再写一个XXXResponse类封装", "\n一下才可以，有没有更简单的办法可以不用为每个类写一个XXXResponse?", "\n[b]问题补充：[/b]", "\n有更好的方案了，返回Object[]", "\nobj[0] = \"错误提示\";", "\nobj[1] = new User[]{...};", "\n\n", "这样就不用给每个类封装一个xxxResponse", "\n在客户端强制转换一下类型就可以"]], "Tag": "程序设计"}
{"Answer": "犯了一个错误。\r\n你是web的。。\r\n\r\n把你的页面和代码贴出来看看。。。", "Konwledge_Point": "强制类型转换", "Question": ["asp，c#，GridView编辑更新是报错", ["无法将类型为“System.Web.UI.WebControls.DataControlLinkButton”的对象强制转换为类型“System.Web.UI.WebControls.TextBox”。 ", "\n\n", "\nprotected void GridView1_RowUpdating(object sender, GridViewUpdateEventArgs e)", "\n    {", "\n        //取得编辑行的关键字段的值", "\n        string ID = GridView1.DataKeys[e.RowIndex].Value.ToString();", "\n        //取得文本框中输入的内容", "\n        string id = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[1].Controls[0])).Text.ToString();", "\n      string name = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[2].Controls[0])).Text.ToString();", "\n     string price = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[3].Controls[0])).Text.ToString();", "\n   string comment = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[4].Controls[0])).Text.ToString();", "\n   string picture = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[5].Controls[0])).Text.ToString();", "\n      string type = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[6].Controls[0])).Text.ToString();", "\n  string identify = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[7].Controls[0])).Text.ToString();", "\n string introduce = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[8].Controls[0])).Text.ToString();", "\n      string pic1 = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[9].Controls[0])).Text.ToString();", "\n      string pic2 = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[10].Controls[0])).Text.ToString();", "\n      string pic3 = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[11].Controls[0])).Text.ToString();", "\n      string pic4 = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[12].Controls[0])).Text.ToString();", "\n      string pic5 = ((TextBox)(GridView1.Rows[e.RowIndex].Cells[13].Controls[0])).Text.ToString();", "\n\n", "请大神帮帮忙"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;报错很清楚了&amp;#xff0c;告诉你不能把空替换成数据&lt;br /&gt;你可以把任何匹配到的字符替换成空&amp;#xff0c;但是不能倒过来&lt;br /&gt;没法把空替换成数据&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["python中出现错误 ValueError: Series.replace cannot use dict-value and non-None to_replace   如何解决？", ["\n", "#导入工具包并加载数据", "\n", "#-*- coding: utf-8 -*-", "\nimport pandas as pd\nimport numpy as np\n", "# 可视化", "\nimport matplotlib.pyplot as plt \nimport seaborn as sns \n", "# 机器学习---用于用户流失预测", "\n", "from", " sklearn.model_selection import train_test_split, GridSearchCV\n", "from", " sklearn.svm import SVC\n", "from", " sklearn.tree import DecisionTreeClassifier\n", "from", " sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\n", "from", " sklearn.neighbors import KNeighborsClassifier\n", "from", " sklearn.pipeline import Pipeline\n", "from", " sklearn.metrics import accuracy_score\n", "#plt.rcParams['font.family'] = 'SimHei'", "\n", "#plt.rcParams['axes.unicode_minus'] = False", "\n", "#读取数据", "\ndx = pd.read_csv(", "'telecom.csv'", ")\n", "# 查看数据集大小", "\n", "print", "(dx.shape)\n", "# 运行结果：(7043, 21)", "\n\n", "# 设置查看不省略", "\n", "##列名与数据对其显示", "\npd.set_option(", "'display.unicode.ambiguous_as_wide'", ", ", "True", ")\npd.set_option(", "'display.unicode.east_asian_width'", ", ", "True", ")\n", "##显示所有列", "\npd.set_option(", "'display.max_columns'", ", None)\n", "##显示所有行", "\npd.set_option(", "'display.max_rows'", ", None)\n\n", "# 查看前5条数据", "\n", "print", "(dx.head())\n", "# 查看数据是否存在Null", "\n", "print", "(pd.isnull(dx).sum()) # ", "Null", "计数\n", "# 查看数据类型", "\n", "print", "(dx.", "info", "())\n", "#dx.dtypes", "\n", "#dx[['TotalCharges']].astype(float)", "\n", "#ValueError: could not convert string to float:", "\n", "#强制转换为数字，不可转换的变为NaN", "\ndx[", "'TotalCharges'", "]=dx[", "'TotalCharges'", "].apply(pd.to_numeric, ", "errors", "=", "'coerce'", ")\n", "test", "=dx.loc[:,", "'TotalCharges'", "].value_counts().sort_index()\n", "print", "(test.sum()) #运行结果：7032\n", "# 查看缺失数据", "\n", "print", "(dx.tenure[dx[", "'TotalCharges'", "].isnull().", "values", "==True])\n", "# 统计缺失总数", "\n", "print", "((dx.tenure[dx[", "'TotalCharges'", "].isnull().", "values", "==True]).value_counts())\n", "#运行结果：0   11", "\n", "print", "(dx.isnull().any())\n", "print", "(dx[dx[", "'TotalCharges'", "].isnull().", "values", "==True] [[", "'tenure'", ",", "'MonthlyCharges'", ",", "'TotalCharges'", "]])\n", "#将总消费额填充为月消费额", "\ndx.loc[:,", "'TotalCharges'", "].replace(", "to_replace", "=np.nan,value=dx.loc[:,", "'MonthlyCharges'", "],", "inplace", "=", "True", ")\n", "#查看是否替换成功", "\n", "print", "(dx[dx[", "'tenure'", "]==0][[", "'tenure'", ",", "'MonthlyCharges'", ",", "'TotalCharges'", "]])\n", "\n", "到这就提示错误ValueError: Series.replace cannot use dict-value and non-None to_replace", "求解", "\n", "[](链接：", "\n      \n        ", "百度网盘 请输入提取码", "\n        \n      ", "百度网盘为您提供文件的网络备份、同步和分享服务。空间大、速度快、安全稳固，支持教育网加速，支持手机端。注册使用百度网盘即可享受免费存储空间", "\n      ", "\n      ", "\n        ", "\n          ", "https://pan.baidu.com/s/1FewH2LR8tV9Ye8EWo6pF7w", "\n        ", "\n      ", "提取码：ad39)"]], "Tag": "程序设计"}
{"Answer": "&lt;h2 id=\"h2_该回答引用chatgptᴼᴾᴱᴺᴬᴵ_1676901477750\"&gt;该回答引用ChatGPTᴼᴾᴱᴺᴬᴵ&lt;/h2&gt;\n&lt;h2 id=\"h2_在新的代码中&amp;#xff0c;变量n的定义为int-n&amp;#xff0c;而在原代码中定义为ushort-n&amp;#xff0c;所以在计算时会有类型转换警告。另外&amp;#xff0c;在新代码中&amp;#xff0c;变量buf的类型为byte&amp;#xff0c;而原代码中定义为byte&amp;#xff0c;需要注意一下。_1676901477750\"&gt;在新的代码中&amp;#xff0c;变量n的定义为int n&amp;#xff0c;而在原代码中定义为USHORT n&amp;#xff0c;所以在计算时会有类型转换警告。另外&amp;#xff0c;在新代码中&amp;#xff0c;变量buf的类型为byte*&amp;#xff0c;而原代码中定义为BYTE[]&amp;#xff0c;需要注意一下。&lt;/h2&gt;\n&lt;p&gt;正确的修改应该是&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;string buffstr &amp;#61; &lt;span class=\"hljs-string\"&gt;&amp;#34;450001650100000080113139322E3136382E33312E313838FFFFFFFF&amp;#34;&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;char&lt;/span&gt;* strp &amp;#61; buffstr.&lt;span class=\"hljs-built_in\"&gt;c_str&lt;/span&gt;();\n&lt;span class=\"hljs-type\"&gt;byte&lt;/span&gt;* buf &amp;#61; &lt;span class=\"hljs-keyword\"&gt;new&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;byte&lt;/span&gt;[buffstr.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];\n&lt;span class=\"hljs-built_in\"&gt;HexStrToByte&lt;/span&gt;(strp, buf, buffstr.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; cbBuf &amp;#61; buffstr.&lt;span class=\"hljs-built_in\"&gt;length&lt;/span&gt;() / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;const&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; iCount &amp;#61; cbBuf / &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;;\n&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; iCheckSum &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;;\n&lt;span class=\"hljs-keyword\"&gt;for&lt;/span&gt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; i &amp;#61; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;; i &amp;lt; iCount; &amp;#43;&amp;#43;i)\n{\n    USHORT n &amp;#61; *(USHORT*)(buf &amp;#43; i * &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\n    iCheckSum &amp;#43;&amp;#61; n;\n}\n\n&lt;span class=\"hljs-keyword\"&gt;if&lt;/span&gt; ((iCheckSum &amp;gt;&amp;gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;) &amp;gt; &lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;)\n{\n    iCheckSum &amp;#61; (iCheckSum &amp;gt;&amp;gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;) &amp;#43; (iCheckSum &amp;amp; &lt;span class=\"hljs-number\"&gt;65535&lt;/span&gt;);\n    iCheckSum &amp;#43;&amp;#61; iCheckSum &amp;gt;&amp;gt; &lt;span class=\"hljs-number\"&gt;16&lt;/span&gt;;\n}\n\nBYTE byResult[&lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;];\niCheckSum &amp;#61; ~iCheckSum;\n&lt;span class=\"hljs-built_in\"&gt;memcpy&lt;/span&gt;(byResult, &amp;amp;iCheckSum, &lt;span class=\"hljs-number\"&gt;2&lt;/span&gt;);\ncout &amp;lt;&amp;lt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)byResult[&lt;span class=\"hljs-number\"&gt;0&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span class=\"hljs-string\"&gt;&amp;#34;,&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (&lt;span class=\"hljs-type\"&gt;int&lt;/span&gt;)byResult[&lt;span class=\"hljs-number\"&gt;1&lt;/span&gt;];\n&lt;span class=\"hljs-keyword\"&gt;delete&lt;/span&gt;[] buf;\nbuf &amp;#61; &lt;span class=\"hljs-literal\"&gt;NULL&lt;/span&gt;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里将变量n的类型修改为USHORT&amp;#xff0c;同时在循环内计算时进行类型转换。另外&amp;#xff0c;将buf的定义修改为byte*类型&amp;#xff0c;并将其内存分配放在循环外面&amp;#xff0c;同时在循环结束后释放内存。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["怎么修改代码，避免算数溢出？", ["上面一段是原来的代码，因为这个buffstr字符串不是定长的，所以改了下。但有错误提示！怎么正确的修改?", "这句代码：n = ", "(USHORT", ")(buf + i * 2);//这里会有警告    C26451    算术溢出: 使用 4 字节值上的运算符 * ，然后将结果转换到 8 字节值。在调用运算符 * 之前将值强制转换为宽类型可避免溢出(io.2)。", "原代码：", "\n", "        ", "BYTE", " Buf[] = { ", "0x45", ",", "0x00", ",", "0x01", ",", "0x65", ",", "0x01", ",", "0x00", ",", "0x00", ",", "0x00", ",", "0x80", ",", "0x11", ",", "0x31", ",", "0x39", ",", "0x32", ",", "0x2E", ",\n                ", "0x31", ",", "0x36", ",", "0x38", ",", "0x2E", ",", "0x33", ",", "0x31", ",", "0x2E", ",", "0x31", ",", "0x38", ",", "0x38", ",", "0xFF", ",", "0xFF", ",", "0xFF", ",", "0xFF", " }", ";", "\n        const ", "int", " cbBuf = sizeof(Buf)", ";", "\n        const ", "int", " iCount = cbBuf / ", "2", ";", "\n        ", "int", " iCheckSum = ", "0", ", n", ";", "\n        for (", "int", " i = ", "0", "; i < iCount; ++i)", "\n        {\n                n = *(USHORT*)(Buf + i * ", "2", ")", ";", "\n                iCheckSum += n", ";", "\n        }\n \n        if ((iCheckSum >> ", "16", ") > ", "0", ")\n        {\n                iCheckSum = (iCheckSum >> ", "16", ") + (iCheckSum & ", "65535", ")", ";", "\n                iCheckSum += iCheckSum >> ", "16", ";", "\n        }\n \n        ", "BYTE", " byResult[", "2", "]", ";", "\n        iCheckSum = ~iCheckSum", ";", "\n        memcpy(byResult, &iCheckSum, ", "2", ")", ";", "\n        cout << (", "int", ")byResult[", "0", "] << ", "\",\"", " << (", "int", ")byResult[", "1", "]", ";", "\n", "\n", "修改的代码：    ", "\n", "void", " ", "HexStrToByte", "(", "const", " ", "char", "* source, ", "unsigned", " ", "char", "* dest, ", "int", " sourceLen)", "\n", "{\n    ", "short", " i;\n    ", "unsigned", " ", "char", " highByte, lowByte;\n\n    ", "for", " (i = ", "0", "; i < sourceLen; i += ", "2", ")\n    {\n        highByte = ", "toupper", "(source[i]);\n        lowByte = ", "toupper", "(source[i + ", "1", "]);\n\n        ", "if", " (highByte > ", "0x39", ")\n            highByte -= ", "0x37", ";\n        ", "else", "\n            highByte -= ", "0x30", ";\n\n        ", "if", " (lowByte > ", "0x39", ")\n            lowByte -= ", "0x37", ";\n        ", "else", "\n            lowByte -= ", "0x30", ";\n\n        dest[i / ", "2", "] = (highByte << ", "4", ") | lowByte;\n    }\n    ", "return", ";\n}\n    string buffstr = ", "\"450001650100000080113139322E3136382E33312E313838FFFFFFFF\"", ";\n    ", "const", " ", "char", "* strp = buffstr.", "c_str", "();\n    ", "byte", "* buf = ", "new", " ", "byte", "[buffstr.", "length", "() / ", "2", "];\n    ", "HexStrToByte", "(strp, buf, buffstr.", "length", "() / ", "2", ");\n\n", "//因为这个buffstr字符串不是定长的，所以以上要改。", "\n\n    ", "const", " ", "int", " cbBuf = buffstr.", "length", "() / ", "2", ";\n    ", "const", " ", "int", " iCount = cbBuf / ", "2", ";\n    ", "int", " iCheckSum = ", "0", ", n;\n    ", "for", " (", "int", " i = ", "0", "; i < iCount; ++i)\n    {\n        n = *(USHORT*)(buf + i * ", "2", ");", "//这里会提示算数溢出，什么4字节", "\n        iCheckSum += n;\n    }\n\n    ", "if", " ((iCheckSum >> ", "16", ") > ", "0", ")\n    {\n        iCheckSum = (iCheckSum >> ", "16", ") + (iCheckSum & ", "65535", ");\n        iCheckSum += iCheckSum >> ", "16", ";\n    }\n\n    BYTE byResult[", "2", "];\n    iCheckSum = ~iCheckSum;\n    ", "memcpy", "(byResult, &iCheckSum, ", "2", ");\n    cout << (", "int", ")byResult[", "0", "] << ", "\",\"", " << (", "int", ")byResult[", "1", "];\n    ", "delete", "[] buf;\n    buf = ", "NULL", ";\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;问题分析&amp;#xff1a;&lt;br /&gt;iris.data 类型是一个数据框&lt;br /&gt;iris.target 类型是一pandas.Seris 序列&lt;/p&gt;\n&lt;p&gt;解决办法&amp;#xff1a;&lt;br /&gt;1、首先用data&amp;#61;pd.read_csv() 方法读取数据集&lt;br /&gt;如&amp;#xff1a;# 导入txt数据&lt;br /&gt;data&amp;#61;pd.read_csv(train_data_path,sep&amp;#61;&amp;#39;\\t&amp;#39;)&lt;br /&gt;2、把特征和目标 赋值给X_train&amp;#xff0c;y_train 相当于iris.data&amp;#xff0c;iris.target&lt;/p&gt;\n&lt;h1 id=\"h1_筛选自变量_1639217707884\"&gt;筛选自变量&lt;/h1&gt;\n&lt;p&gt;X_train&amp;#61;data.iloc[:,:-1]&lt;/p&gt;\n&lt;h1 id=\"h1_筛选因变量_1639217707884\"&gt;筛选因变量&lt;/h1&gt;\n&lt;p&gt;y_train&amp;#61;data.iloc[:,-1]&lt;/p&gt;\n&lt;p&gt;望采纳&amp;#xff0c;谢谢&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["模仿鸢尾花数据的交叉验证时，如何以自己导入的数据替代iris.data, iris.target？", ["问题遇到的现象和发生背景", "\n", "我需要利用股票数据做决策树分类器，我把A股市值作为y，其余特征项作为x，仿照鸢尾花数据集的案例构造决策树，交叉验证的时候我用df_X和df_y代替iris.data, iris.target，但试了很多次都有报错，这次是大片红色报错，请问有人知道该怎么改吗？", "网上鸢尾花数据交叉验证的参考：", "\n", "cross", "_val_score(", "clf", ", ", "iris", ".", "data", ", ", "iris", ".", "target", ", ", "cv", "=10)", "\n", "\n", "问题相关代码，请勿粘贴截图", "\n", "from", " sklearn import tree\nimport pandas as pd\n", "df", "=pd.read_excel('数据.xlsx') #读取数据\ntype(df)\n", "'化连续为离散'", "\n", "df", "=pd.read_excel('数据.xlsx')\n", "df", "=df.dropna()\n", "df", "=df.drop(0,axis = 0)\n", "df", "=df.iloc[::-1]\n", "df_diff", "=df.iloc[:,1:].diff(axis = 0)\ndf[df_diff >= 0] = 1   #变量上涨则赋值为1\ndf[df_diff < 0] = 0    #变量下跌则赋值为0\n", "df", "=df.reset_index(drop = ", "True", ") #重置索引\n", "df", "=df.drop(0,axis = 0) #删除无法赋值的第0行\n", "df", "=df.drop('指标名称',axis = 1) #删除日期列\n", "df", "=df.reset_index(drop = ", "True", ") #重置索引\ndf\n", "'分离训练集与数据集'", "\n", "train", "=df.head(211)\n", "test", "=df.tail(8)\n", "test", "=test.reset_index(drop = ", "True", ")\n", "X_train", "=train.drop('上证A股指数',axis = 1)\n", "X_test", "=test.drop('上证A股指数',axis = 1)\n", "y_train", "=train[", "'上证A股指数'", "]\n", "y_test", "=test[", "'上证A股指数'", "]\n", "'强制转换数据类型'", "\n", "X_train", "=X_train.astype('int')\n", "X_test", "=X_test.astype('int')\n", "y_train", "=y_train.astype('int')\n", "y_test", "=y_test.astype('int')\n", "'构造决策树'", "\n", "from", " sklearn import tree\nclf = tree.DecisionTreeClassifier() #创建分类器对象\nclf.fit(X_train,y_train) #用训练集拟合分类器模型\nclf.predict(X_test) #用训练好的分类器预测数据的标签\n", "'交叉验证'", "\n", "from", " sklearn.model_selection import cross_val_score\n", "from", " sklearn import tree\nclf = tree.DecisionTreeClassifier() #创建分类器对象\n", "df_X", "=df.drop('上证A股指数',axis = 1)\n", "df_y", "=df[", "'上证A股指数'", "]\nscore = cross_val_score(clf,df_X,df_y,", "cv", "=10,scoring='accuracy')\n", "\n", "运行结果及报错内容", "\n", "\n", "D:\\Anaconda\\lib\\site-packages\\sklearn\\model_selection_validation.py:536: FitFailedWarning: Estimator fit failed. The score on this train-test partition for these parameters will be set to nan. Details:", "ValueError: Unknown label type: 'unknown'", "\n", "  FitFailedWarning)"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;参考GPT和自己的思路&amp;#xff1a;根据代码和描述来看&amp;#xff0c;可能是由于结束函数没有将BUZZ端口重新设置为高电平&amp;#xff0c;导致蜂鸣器始终处于反转状态&amp;#xff0c;无法响应。建议在结束函数中添加BUZZ&amp;#61;1这行代码来解决问题。另外&amp;#xff0c;建议在中断服务函数中添加一个延迟&amp;#xff0c;使蜂鸣器可以持续一段时间后再停止&amp;#xff0c;而不是立即停止。&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["为什么在进入结束函数时只是关闭了中断，BUZZ没有取反，蜂鸣器却不响l呢。", ["使用51单片机中的无源蜂鸣器  在进入启动函数后进入中断，BUZZ端口取反，问题是为什么在进入结束函数时只是关闭了中断，BUZZ没有取反，蜂鸣器却不响l呢。", "\n", "#", "include", "<reg52.h>", "\n\nsbit BUZZ=P1^", "6", ";                         ", "//蜂鸣器控制引脚", "\n\n", "unsigned", " ", "char", " T0RH=", "0", ";                 ", "//T0重载值高字节", "\n", "unsigned", " ", "char", " T0RL=", "0", ";                 ", "//T0重载值低字节", "\n\n", "void", " ", "OpenBuzz", "(", "unsigned", " ", "int", " frequ)", ";     ", "//打开蜂鸣器", "\n", "void", " ", "StopBuzz", "()", ";                     ", "//关闭蜂鸣器", "\n\n", "void", " ", "main", "()", "\n", "{\n    ", "unsigned", " ", "int", " i;\n    TMOD=", "0x01", ";                           ", "//指定模式  但不启动", "\n    EA=", "1", ";                               ", "//中断总使能", "\n\n    ", "while", "(", "1", ")\n    {\n        ", "OpenBuzz", "(", "4000", ");                    ", "//以4khz的频率启动蜂鸣器", "\n        ", "for", "(i=", "0", ";i<", "40000", ";i++);            ", "//延时", "\n        ", "StopBuzz", "();\n        ", "for", "(i=", "0", ";i<", "40000", ";i++);\n        ", "OpenBuzz", "(", "1000", ");                    ", "//以1khz的频率启动蜂鸣器", "\n        ", "for", "(i=", "0", ";i<", "40000", ";i++);\n        ", "StopBuzz", "();\n        ", "for", "(i=", "0", ";i<", "40000", ";i++);\n    }\n}\n\n", "void", " ", "OpenBuzz", "(", "unsigned", " ", "int", " frequ)", "\n", "{\n    ", "unsigned", " ", "int", " reload;\n\n    reload=", "65536", "-(", "11059200", "/", "12", ")/(frequ*", "2", ");             ", "//计算所需的定时器重载值    强制类型转换", "\n    T0RH=(", "unsigned", " ", "char", ")(reload>>", "8", ");                  ", "//由给定频率计算定时器重载值      reload两个字节，把16位reload进行转换后得到的低8位移出，把高八位给到T0RH ", "\n    T0RL=(", "unsigned", " ", "char", ")reload;                          ", "//16位重载值分解为高低两个字节  把reload低八位赋值给T0RL", "\n    TH0=", "0xFF", ";\n    TL0=", "0xFE", ";                                          ", "//设定接近溢出的初值，让定时器马上投入工作   随意给定的", "\n    ET0=", "1", ";                                              ", "//使能t0中断", "\n    TR0=", "1", ";                                              ", "//启动t", "\n\n}\n", "void", " ", "StopBuzz", "()", "\n", "{\n    ET0=", "0", ";                                              ", "//关闭定时器和中断", "\n    TR0=", "0", ";\n}\n\n", "/*t0中断服务函数，用于控制蜂鸣器发声*/", "\n", "void", " ", "interrupttimer0", "()", " interrupt 1\n", "{\n    TH0=T0RH;                                           ", "//重新加载重载值", "\n    TL0=T0RL;\n    BUZZ=~BUZZ;                                           ", "//反转蜂鸣器控制点平", "\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;chatgpt:&lt;br /&gt;这是一个 C 语言中的宏定义&amp;#xff0c;用来定义一个函数&amp;#xff0c;函数名为 _b&amp;#xff0c;参数为 x&amp;#xff0c;返回值为 a 类型的结构体变量&amp;#xff0c;结构体变量的成员变量为 x。&lt;/p&gt;\n&lt;p&gt;具体解释如下&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;#define 是 C 语言中的宏定义关键字&amp;#xff0c;用来定义宏。&lt;br /&gt;_b 是宏的名称&amp;#xff0c;可以自己定义。&lt;br /&gt;(x) 是宏的参数&amp;#xff0c;用圆括号括起来&amp;#xff0c;表示参数是一个整数变量。&lt;br /&gt;((a) { (x) }) 是宏的返回值&amp;#xff0c;表示返回一个类型为 a 的结构体变量&amp;#xff0c;结构体变量的成员变量为 x。&lt;br /&gt;这里 a 是一个未知的类型&amp;#xff0c;需要在宏定义时定义好。具体使用时&amp;#xff0c;可以通过定义结构体的方式来实现。例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;&lt;span class=\"hljs-keyword\"&gt;typedef&lt;/span&gt; &lt;span class=\"hljs-keyword\"&gt;struct&lt;/span&gt; {\n    &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; x;\n} a;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上述代码定义了一个结构体类型 a&amp;#xff0c;该结构体包含一个整数类型的成员变量 x。然后&amp;#xff0c;可以使用宏定义来创建 a 类型的结构体变量。例如&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-javascript\"&gt;a a1 &lt;span class=\"hljs-operator\"&gt;&amp;#61;&lt;/span&gt; _b(&lt;span class=\"hljs-number\"&gt;10&lt;/span&gt;)&lt;span class=\"hljs-comment\"&gt;;&lt;/span&gt;\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这将会创建一个 x 值为 10 的 a 类型的结构体变量 a1&lt;/p&gt;", "Konwledge_Point": "强制类型转换", "Question": ["一个C语言的宏看得不太懂", ["a是个类型，以下这个宏是什么意思呀？我不明白这个花括号的用法，是把x强制类型转换成a类型吗？", "\n", "\n#define _b(", "x", ") ((", "a", ") { (", "x", ") })\n"]], "Tag": "程序设计"}
