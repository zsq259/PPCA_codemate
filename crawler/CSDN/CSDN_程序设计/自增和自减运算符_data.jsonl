{"Answer": "&lt;p&gt;对类重载可以重载出任何奇奇怪怪的功能&amp;#xff0c;包括与原始自增语义完全不同的功能。但是要注意&amp;#xff1a;如果不进行重载&amp;#xff0c;类是**不会**自动产生带有原始自增语义的自增操作符的。例如&amp;#xff0c;你定义了一个Integer类&amp;#xff0c;对整数进行封装。从原始语义上来讲&amp;#xff0c;自增在整数类型上的定义是非常平凡的&amp;#xff0c;但是如果你不去重载&amp;#xff0c;Integer就不会自动产生这种看上去非常平凡的功能&amp;#xff0c;必须要通过代码来指定才可以。&lt;/p&gt;\n\n&lt;p&gt;一言以蔽之&amp;#xff1a;对于类而言&amp;#xff0c;除非你是继承了一个已经进行过重载的类来写派生类&amp;#xff0c;否则在重载自增运算符之前&amp;#xff0c;尝试对该类实例进行自增操作是非法的。换句话说&amp;#xff0c;重载自增运算符之前&amp;#xff0c;一个类根本不可能支持自增操作&amp;#xff08;基础类型和类有着本质的区别&amp;#xff0c;不要搞混了&amp;#xff09;。&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["自增自减运算符重载后与之前有啥功能上的区别呀？", ["自增自减运算符重载后与之前有啥功能上的区别呀？看了几个例子，感觉功能都一样呀"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;运算顺序 自增自减运算优先于加减   这里面a先&amp;#43;&amp;#43;a自增1又--a自减1 然后进行 a-a&amp;#61;0   0&amp;#61;&amp;#61;0为真&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["c语言自增自减运算符", ["\n", "运行结果为什么是真？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;这跟运算符没关系&amp;#xff0c;跟printf的执行顺序有关系&lt;br /&gt;printf里多个参数&amp;#xff0c;从最右边的开始计算表达式&amp;#xff0c;依次计算出结果之后先缓存&amp;#xff0c;最后再从左到右的次序替换到字符串里输出&lt;br /&gt;但是这在不同的IDE里执行顺序是会变的&amp;#xff0c;所以实际开发的时候要竭力避免这种坑人的写法&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["自增自减运算符的顺序", ["这三个运算顺序是从左到右还是从右到左。", "从左到右的话不是9，59，31", "从右到左不是9，61，31吗？？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;总结起来就是这三条原则&amp;#xff1a;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;原则0&amp;#xff1a;printf语句是从右往左计算会改变变量本身的表达式&amp;#xff0c;计算完毕叫做假结束&amp;#xff08;而后自增的表达式叫做真结束&amp;#xff09;\n&lt;span class=\"hljs-attribute\"&gt;C&lt;/span&gt;&amp;#61;--z 即 &lt;span class=\"hljs-attribute\"&gt;z&lt;/span&gt;&amp;#61;z-1&amp;#61;3 &lt;span class=\"hljs-attribute\"&gt;C&lt;/span&gt;&amp;#61;z&amp;#61;3\n&lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;&amp;#61;&amp;#43;&amp;#43;z 即 &lt;span class=\"hljs-attribute\"&gt;z&lt;/span&gt;&amp;#61;z&amp;#43;1&amp;#61;4 &lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;&amp;#61;z&amp;#61;4\n&lt;span class=\"hljs-attribute\"&gt;A&lt;/span&gt;&amp;#61;z&amp;#43;&amp;#43; 即 &lt;span class=\"hljs-attribute\"&gt;A&lt;/span&gt;&amp;#61;z&amp;#61;4,本来这里是后自增&amp;#xff0c;我们先不操作去看原则1\n\n原则1&amp;#xff1a;后自增运算是要在整条语句结束以后才自加\n此时A,B,C所有表达式都已假/真结束&amp;#xff0c;所以开始运行被搁置的后自增&lt;span class=\"hljs-attribute\"&gt;z&lt;/span&gt;&amp;#61;z&amp;#43;1&amp;#61;5\n\n原则2&amp;#xff1a;所有后自增运行结束后&amp;#xff0c;再从左往右将变量值代入之前所有假结束的表达式中&amp;#xff0c;但不可对变量进行任何改变\n&lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;&amp;#61;&amp;#43;&amp;#43;z 即相当于&amp;#xff1a;&lt;span class=\"hljs-attribute\"&gt;z&lt;/span&gt;&amp;#61;z&amp;#43;1由原则2知道不可执行这句&amp;#xff0c;所以 &lt;span class=\"hljs-attribute\"&gt;B&lt;/span&gt;&amp;#61;z&amp;#61;5\n&lt;span class=\"hljs-attribute\"&gt;C&lt;/span&gt;&amp;#61;--z 即相当于&amp;#xff1a;&lt;span class=\"hljs-attribute\"&gt;z&lt;/span&gt;&amp;#61;z-1由原则2知道不可执行这句&amp;#xff0c;所以 &lt;span class=\"hljs-attribute\"&gt;C&lt;/span&gt;&amp;#61;z&amp;#61;5\n\n所以最后打印的是A&amp;#xff1a;4 &amp;#xff0c;B&amp;#xff1a;5&amp;#xff0c;C&amp;#xff1a;5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;谢谢这个问题&amp;#xff0c;也让我复习了这几个原则&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["关于自增自减运算符怎样计算？", ["请问输出结果为什么是4 5 5？", "\n", "#", "include", " ", "<stdio.h>", "\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " x,y,z;\n    x=y=", "2", ";\n    z=", "3", ";\n    z=", "4", ";", "printf", "(", "\"%d\\t%d\\t%d\"", ",z++,++z,--z);\n    ", "return", " ", "0", ";\n}\n\n", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;输出&amp;#xff1a;c&amp;#61;7,d&amp;#61;8,a&amp;#61;8,b&amp;#61;8 &lt;/p&gt;\n&lt;p&gt;分析&amp;#xff1a;&lt;/p&gt;\n&lt;p&gt;c&amp;#61;a&amp;#43;&amp;#43;;等价于&amp;#xff0c;c&amp;#61;a,a&amp;#61;a&amp;#43;1;(a&amp;#43;&amp;#43;是先计算后自增)&lt;br /&gt;b&amp;#61;&amp;#43;&amp;#43;b;等价于&amp;#xff0c;b&amp;#61;b&amp;#43;1,b&amp;#61;b;(&amp;#43;&amp;#43;b是先自增后计算)&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;如有帮助&amp;#xff0c;请采纳。点击我回答右上角【采纳】按钮。&lt;/strong&gt;&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["自增自减运算符前缀和后缀运算形式的规律", ["\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你这段代码属于undefined behavior&amp;#xff0c;因为C/C&amp;#43;&amp;#43;语言标准没有规定函数参数的计算顺序&amp;#xff0c;所以编译器可以按任意顺序来计算每个参数值&amp;#xff0c;这就使得你的代码在不同编译器上得到的结果可能不一样。&lt;/p&gt;\n&lt;p&gt;From &lt;a href=\"https://en.cppreference.com/w/c/language/eval_order\" id=\"textarea_1641978951035_1641979425391_0\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;&lt;span class=\"md_link_url\"&gt;https://en.cppreference.com/w/c/language/eval_order&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Order of evaluation of the operands of any C operator, including &lt;strong&gt;the order of evaluation of function arguments in a function-call expression&lt;/strong&gt;, and the order of evaluation of the subexpressions within any expression &lt;strong&gt;is unspecified&lt;/strong&gt; (except where noted below). &lt;strong&gt;The compiler will evaluate them in any order&lt;/strong&gt;, and may choose another order when the same expression is evaluated again.&lt;/p&gt;\n&lt;/blockquote&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["自增自减运算符放在同一句输出时", ["为什么输出", "\n", "```c", "#include <stdio.h>", "\n", "void main()", "{", "    int i=8;", "    printf(\"%d\\n%d\\n%d\\n%d\\n%d\\n%d\\n\",++i,--i,i++,i--,-i++,-i--);", "}", "\n", "```是从8开始啊"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;你是哪里不明白&amp;#xff0c;解析已经非常清楚了&amp;#xff0c;这两个是平级的运算符&amp;#xff0c;并且不存在括号&amp;#xff0c;所以采用从右往左的顺序&amp;#xff0c;而从右往左需要先看i&amp;#43;&amp;#43;&amp;#xff0c;它表示先用i的值然后再令i加1&amp;#xff0c;即i&amp;#43;&amp;#43;首先返回i的原始值&amp;#xff0c;再让i加1&amp;#xff0c;也就是说&amp;#xff0c;-i&amp;#43;&amp;#43;首先使用i的原始值&amp;#xff0c;得到-3&amp;#xff0c;再让i加1变成4&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["自加、自减运算符和后缀运算符", ["问题遇到的现象和发生背景", "\n", "我不太明白下面这个例子", "有一表达式-i++ ，其中i的原值为3  ，由于负号运算符与自加运算符的优先级相同，结合方向是“自右向左”，即相当于对表达式-（i++）进行运算此时自加运算符“++\"为后缀运算符，（i++）的值为3，因此-（i++）的值为-3   然后i自增为4", "\n", "问题相关代码，请勿粘贴截图", "\n", "运行结果及报错内容", "\n", "我的解答思路和尝试过的方法", "\n", "我想要达到的结果"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;z&amp;#61;x&amp;#43;&amp;#43;的执行顺序是&amp;#xff1a;先执行z&amp;#61;x&amp;#xff0c;然后执行x&amp;#43;&amp;#43;;这样z&amp;#61;1&amp;#xff0c;x&amp;#61;2&amp;#xff1b;&lt;/p&gt;\n\n&lt;p&gt;y&amp;#43;&amp;#43;以后y是2&amp;#xff0c;&amp;#43;&amp;#43;y以后y是3&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["这里为啥自增自减后它的值就为2.3了呀哦，大佬可以解释一下嘛，谢谢", ["题目：以下程序的输出结果是：\nmain()\n{\nint x,y,z;\nx=1;\ny=1;\nz=x++,y++,++y;\nprintf(\"%d,%d,%d\\n\",x,y,z);\n}\n[A]2，3，3 [B]2，3，2 [C]2，3，1 [D]1，1，1\n解析：\nx和y的值经过自增以后分别为2和3，D可以排除。剩下3个选项选择什么呢？\n如果是（x++,y++,++y）实际上可以看成（1,1,3）整个逗号表达式的值应该是3，那么选A。\n如果是（x++,++y,y++）实际上可以看成（1,2,2）整个逗号表达式的值应该是2，那么选B。\n但这是错的，这儿还有赋值运算符。赋值运算符的优先级是14，而逗号表达式的优先级是15，也就是说上面的表达式中应该等价于这样的结合：(z=x++),y++,++y;如果这样写的话，则答案很清晰，为：2，3，1"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在C&amp;#43;&amp;#43;语言中&amp;#xff0c;可以将一个自动变量转换为引用类型&amp;#xff0c;即将一个局部变量的引用返回。这也就是为什么在函数myinteger&amp;amp; operator&amp;#43;&amp;#43;(int)中&amp;#xff0c;可以将temp作为引用类型返回的原因。此处应当注意的是&amp;#xff0c;在该函数返回时&amp;#xff0c;temp变量仍然存在&amp;#xff0c;能够正常使用&amp;#xff0c;但当函数结束时&amp;#xff0c;temp变量会立刻被销毁&amp;#xff0c;此时再使用temp变量可能会发生未定义的错误。&lt;/p&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["后置自增运算符重载的返回值类型", ["\n", "红框处，返回的temp是局部变量，当函数MyInteger& operator++(int)执行完成后，temp应该会被销毁，无法用引用类型返回。为什么这里却可以运行？（编译器是VS2022）", "\n", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n\n", "class", " ", "MyInteger", "\n{\n    ", "friend", " ostream& ", "operator", "<<(ostream& cout, MyInteger myInt);\n    ", "int", " m_num;\n\n", "public", ":\n    ", "MyInteger", "()\n    {\n        m_num = ", "0", ";\n    }\n\n    ", "MyInteger", "(", "int", " num)\n    {\n        m_num = num;\n    }\n\n    ", "// 前置自增运算符重载", "\n    MyInteger& ", "operator", "++()\n    {\n        ++m_num;\n        ", "return", " *", "this", ";\n    }\n\n    ", "// 前置自减运算符重载", "\n    MyInteger& ", "operator", "--();\n\n    ", "// 后置自增运算符重载", "\n    MyInteger& ", "operator", "++(", "int", ")   ", "// 此处的int为占位参数, 构成函数重载", "\n    {\n        MyInteger temp = *", "this", ";\n        m_num++;\n        ", "return", " temp;\n    }\n\n    ", "// 后置自减运算符重载", "\n};\n\n", "// 前置自减运算符重载", "\nMyInteger& MyInteger::", "operator", "--()\n{\n    --m_num;\n    ", "return", " *", "this", ";\n}\n\nostream& ", "operator", "<<(ostream& cout, MyInteger myInt)\n{\n    cout << myInt.m_num;\n    ", "return", " cout;\n}\n\n", "void", " ", "test01", "()", "\n", "{\n    MyInteger myInt;\n    cout << ++myInt << endl;\n    cout << --myInt << endl;\n}\n\n", "void", " ", "test02", "()", "\n", "{\n    MyInteger myInt;\n    cout << myInt++ << endl;\n    cout << myInt++ << endl;\n    ", "//cout << myInt-- << endl;", "\n}\n\n", "int", " ", "main", "()", "\n", "{\n    ", "// test01();", "\n    ", "test02", "();\n\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n"]], "Tag": "程序设计"}
{"Answer": "a++和++a,a++是在整句执行完之后才执行的，也就是在;之后执行，而++a是在语句执行前执行的。", "Konwledge_Point": "自增和自减运算符", "Question": ["JAVA算术运算符的优先级", ["public static void main(String[] args) {", "\n\n", "          int a,b,c;\n          a=b=c=5;\n          a=++b-++c;\n          System.out.println(\"a=\"+a+\"b=\"+b+\"c=\"+c);\n          a=b+++c++;\n          System.out.println(\"a=\"+a+\"b=\"+b+\"c=\"+c);\n          a=b--+c--;\n          System.out.println(\"a=\"+a+\"b=\"+b+\"c=\"+c);\n        }\n        }\n        为什么这串代码第二次第三次输出的a值是在b c自增之前所得出的？\n        按优先级不是应该自增自减运算先吗？\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;java 的打印没有这个类型的&amp;#xff0c;你要打印的是String类型的&lt;br /&gt;需要这么写&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-java\"&gt;&lt;span class=\"hljs-keyword\"&gt;System&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;out&lt;/span&gt;.println(String.format(&amp;#34;y&amp;#61;--x的结果是&amp;#xff1a;%d,%d\\n&amp;#34;,x,y));\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["Java编译错误，用记事本写的，用的是cmd运算符运行的", ["代码完全正确，为什么会出错？", "代码如下:", "public class test13{", "    public static void main(String[] args){", "        int x=5,y;//声明用于自增自减的整型变量", "\n", "    ", "System", ".", "out", ".println(\"--------对整数的自增和自减--------\");\n\n    y=x++;\n    ", "System", ".", "out", ".printf(\"y=x++的结果为：%d,%d \\n\",x,y);\n    y=x", "--;", "\n    ", "System", ".", "out", ".printf(\"y=x--的结果为：%d,%d \\n\",x,y);\n    y=++x;\n    ", "System", ".", "out", ".printf(\"y=++x的结果为：%d,%d \\n\",x,y);\n    y=", "--y;", "\n    ", "System", ".", "out", ".println(\"y=--x的结果为：%d,%d \\n\",x,y);\n\n}\n", "\n", "}", "错误显示为:", "test13.java:14: 错误: 对于println(String,int,int), 找不到合适的方法", "                System.out.println(\"y=--x的结果为：%d,%d \\n\",x,y);", "                          ^", "    方法 PrintStream.println()不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(boolean)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(char)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(int)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(long)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(float)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(double)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(char[])不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(String)不适用", "      (实际参数列表和形式参数列表长度不同)", "    方法 PrintStream.println(Object)不适用", "      (实际参数列表和形式参数列表长度不同)", "1 个错误", "图片为:", "\n", "\n"]], "Tag": "程序设计"}
{"Answer": "y=x++ -1; \r\n是y = x - 1;\r\nx++;\r\n\r\ny=++x-1;\r\n是x++;\r\ny = x - 1;", "Konwledge_Point": "自增和自减运算符", "Question": ["新人求教C语言运算问题", [" \n \nint main(void)\n{\n    int x,y,z;\n    x=y=2;\n    z=3;\n    y=x++ -1;\n    printf(\"%d\\t %d\\t\",x,y);\n    y=++x-1;\n    printf(\"%d\\t %d\\t\",x,y);\n    y=z-- +1;\n    printf(\"%d\\t %d\\t\",z,y);\n    y=--z+1;\n    printf(\"%d\\t %d\\n\",z,y);\n    return 0;\n}\n\n", "\n\n", "输出的结果是3 1   4 3   2 4   1 2", "\n按照我对于自增自减运算符的理解 第一个y=x++ -1; 不应该是2先加1 然后减1应该是2吗 为什么是3", "\n一系列的不理解 希望大手能给点解释 关于运算顺序和为啥出来这个运算结果的解释 "]], "Tag": "程序设计"}
{"Answer": "亲测合格，请验证：\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\nusing namespace std;\r\n\r\nint num, opera_num, result;\r\nchar opera[100];\r\n\r\nvoid main()\r\n{\r\n\tint i,j=0, max = 4, right_max=1, right_extent, model=3, model_temp,test_num;\r\n\tcout &lt;&lt; \"请输入操作数\" &lt;&lt; endl;\r\n\tcin &gt;&gt; num ;\r\n\tcout &lt;&lt; \"请输入操作符个数\" &lt;&lt; endl;\r\n\tcin &gt;&gt; opera_num;\r\n\tcout &lt;&lt; \"请输入最后结果数\" &lt;&lt; endl;\r\n\tcin &gt;&gt; result;\r\n\r\n\tfor (i = 1; i &lt; opera_num; i++)\r\n\t{\r\n\t\tmax *= 4;\r\n\t\tmodel *= 4;\r\n\t\tright_max *= 4;\r\n\t}\r\n\tfor (i = 0; i &lt; max; i++)\r\n\t{\r\n\t\ttest_num = num;\r\n\t\tright_extent = right_max;\r\n\t\tfor (model_temp = model; model_temp &gt; 0; model_temp /= 4)\r\n\t\t{\r\n\t\t\tswitch ((i&amp;model_temp) / right_extent)\r\n\t\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\topera[j] = '+';\r\n\t\t\t\ttest_num = test_num + (++num);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\topera[j] = '-';\r\n\t\t\t\ttest_num = test_num - (++num);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\topera[j] = '*';\r\n\t\t\t\ttest_num = test_num * (++num);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\topera[j] = '%';\r\n\t\t\t\ttest_num = test_num % (++num);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tright_extent /= 4;\r\n\t\t\tj++;\r\n\t\t}\r\n\t\tnum -= opera_num;\r\n\t\tj = 0;\r\n\t\tif (test_num == result) goto end;\r\n\t}\r\n\tprintf(\"没有符合结果的预测，请检查输入!\");\r\n\tsystem(\"pause\");\r\n\r\nend:\r\n\tprintf(\"这种公式符合结果数：%d \", num);\r\n\tfor (i = 0; i &lt; opera_num; i++) printf(\"%c %d \", opera[i], ++num);\r\n\tsystem(\"pause\");\r\n}\r\n\r\n```\r\n \r\n```", "Konwledge_Point": "自增和自减运算符", "Question": ["求一个程序算法，关于找出符合条件的操作符排列？", ["给一个初始操作数a，然后对这个操作数执行n次加减乘余的计算操作【每次操作a自增1，而且不考虑运算符优先级，谁在前面先算谁】，最后会得到一个结果数x，问如何求出这些操作符？？", "\n重要：程序不能使用递归，最好只用一个主函数！！", "\n比如，给你一个初始数3，执行7次加减乘余操作，最后得到结果147，那么有一种操作符序列满足条件：* + + - * + +", "\n既：3*4+5+6-7*8+9+10=147"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;&lt;code class=\"language-c\"&gt;&lt;span class=\"hljs-comment\"&gt;// 前置&amp;#43;&amp;#43;&lt;/span&gt;\nPoint&amp;amp; Point::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#43;() {\n    &amp;#43;&amp;#43;_x;\n    &amp;#43;&amp;#43;_y;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 后置&amp;#43;&amp;#43;&lt;/span&gt;\nPoint Point::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;&amp;#43;&amp;#43;(int) {\n    Point tmp &amp;#61; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    &amp;#43;&amp;#43;(*&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 前置--&lt;/span&gt;\nPoint&amp;amp; Point::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;--() {\n    --_x;\n    --_y;\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n}\n\n&lt;span class=\"hljs-comment\"&gt;// 后置--&lt;/span&gt;\nPoint Point::&lt;span class=\"hljs-keyword\"&gt;operator&lt;/span&gt;--(int) {\n    Point tmp &amp;#61; *&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;;\n    --(*&lt;span class=\"hljs-keyword\"&gt;this&lt;/span&gt;);\n    &lt;span class=\"hljs-keyword\"&gt;return&lt;/span&gt; tmp;\n}\n\n&lt;/code&gt;&lt;/pre&gt;", "Konwledge_Point": "自增和自减运算符", "Question": ["c＋＋关于坐标的计算", ["声明 Point 类，有坐标 _ x，_ y 两个成员变量；对Point 类重载“++”（自增）、“--”（自减）运算符，实现对坐标值的改变。求绿色区域内容。"]], "Tag": "程序设计"}
