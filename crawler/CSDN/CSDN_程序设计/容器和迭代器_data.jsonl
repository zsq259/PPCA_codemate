{"Answer": "迭代器是模版，容器按照它的标准来进行元素遍历。\r\n改变容器的话，需要重新生成迭代器，不能用之前保存的迭代器，因为它还是用的之前位置。", "Konwledge_Point": "容器和迭代器", "Question": ["C++迭代器和容器类怎么建立联系的?", ["我看了一些书 书上光说了迭代器怎么用，但是我不知道容器和迭代器怎么联系的，因为书上没有完整的代码。   ", "\n\n", "比如说如下代码：", "\nset actors1;", "\nset actors2:", "\nset result;", "\nset::iterator role;  ( 1 )", "\n如上所示， 我不明白（1）那句是什么意思 难道说在容器类中已经定义了要使用的迭代器吗？", "\n还是说这句话就建立了这个类和这个迭代器的联系。", "\n\n", "之后的代码利用 copy 函数将actors1和actors2赋给了result 然后用左包含的方式遍历了整个数据项 那么迭代器是不是在copy过程中被改变了?书上还说如果改变基本容器,迭代器会失效，那它岂不是失效了？那么它又是什么确定的呢？应该是我理解有误吧?"]], "Tag": "程序设计"}
{"Answer": "出现异常是因为迭代器vector::iterator已经失效了，原因是你的函数testVector的参数Vector&lt;int&gt;是值传递，函数返回的nums其实是一个拷贝构造，但是nums又是一个局部变量，函数返回时内存已经被释放，即迭代器已经失效。\r\n\r\n当然的，你可以传递引用或指针作为函数参数，则都是正确的哈。\r\n\r\n```c\r\n// 传入引用举例\r\nvector&lt;int&gt; testVector(vector&lt;int&gt; &amp;nums){\r\n    return nums;\r\n}\r\n```\r\n```c\r\n// 传入指针举例\r\nvector&lt;int&gt; testVector(vector&lt;int&gt; *nums){\r\n    return *nums;\r\n}\r\n```\r\n以上两种传参举例，返回都指向 t 本身的地址，即迭代器 it2 均指向 t 的第一个元素。（ it1 指向 a 的第一个元素）", "Konwledge_Point": "容器和迭代器", "Question": ["C++ vector<int>类型 简单使用迭代器出现异常 不知道是什么原因", ["我刚学容器这一块, 想试试vector的特性, 我想实现一个函数,就是代入一个", "\nvector类型并且原模原样的返回, 最后输出第一个元素的值.", "\n使用方法1, 用另一个vector变量接收返回值, 并且用迭代器获得头部指针没有问题, 方法2不用变量, 直接begin就有问题了, 不知道这里是什么原因", "\n\n", "\n\n", "vector<int> testVector(vector<int> nums){\n    return nums;\n}\nint main()\n{\n    vector<int> t = { 2,7,11,15 };\n\n    /*方法1输出正常*/\n    vector<int> a = testVector(t);\n    vector<int>::iterator it1 = a.begin();\n    cout << *it1 << endl;\n\n    /*方法2输出异常*/\n    vector<int>::iterator it2 = testVector(t).begin();\n    cout << *it2 << endl;\n\n}\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;不要用迭代器的自减操作。如果要从后向前遍历&amp;#xff0c;请使用rbegin&amp;#xff0c;rend。 你这个地方直接用insert函数即可。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\"language-c&amp;#43;&amp;#43;\"&gt;&lt;span class=\"hljs-type\"&gt;void&lt;/span&gt; myinsert(CPt &lt;span class=\"hljs-type\"&gt;point&lt;/span&gt; &lt;span class=\"hljs-type\"&gt;int&lt;/span&gt; pos)\n{\n    &lt;span class=\"hljs-type\"&gt;Line&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;insert&lt;/span&gt;(&lt;span class=\"hljs-type\"&gt;Line&lt;/span&gt;.&lt;span class=\"hljs-keyword\"&gt;begin&lt;/span&gt;() &amp;#43; pos, &lt;span class=\"hljs-type\"&gt;point&lt;/span&gt;);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;提问的时候&amp;#xff0c;别贴图&amp;#xff0c;贴代码。&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["请问编写容器插入元素函数时使用迭代器，这里为什么会触发断点", ["这是我写的函数代码，请问编写容器插入元素函数时使用迭代器，这里为什么会触发断点"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;s.erase(10)将begin这个迭代对象删除掉了啊。begin的值就是10啊。&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["set容器中直接解引用迭代器打印为什么会报错呢", ["c++中在使用set容器的时候为什么定义迭代器直接打印的时候位置不同的时候就会报错呢", "\n", "\n", "这样的话就可以正常运行，但是，如果放到下面的那个遍历的循环后面的话就会报错", "\n", "是和下面遍历循环的it中冲突了吗，还是什么情况，但是下面的迭代器的循环打印中定义的it不应该是局部的吗？", "为什么会出现这种情况呢？"]], "Tag": "程序设计"}
{"Answer": "&lt;pre&gt;\n&lt;code class=\"language-cpp\"&gt;for (auto it &amp;#61; xishu.begin(); it !&amp;#61; xishu.end();) {\n    it&amp;#43;&amp;#43;;\n    result[a &amp;#43; (it-&amp;gt;first)] &amp;#61; d * (it-&amp;gt;second);\n}&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;这个迭代器赋值出错了&amp;#xff0c;每次进入循环体&amp;#xff0c;迭代器it都要自增&amp;#xff0c;当第二次循环时&amp;#xff0c;it&amp;#43;&amp;#43;已经是end了&amp;#xff0c;然后你在使用it去访问firsh()和second()这两个函数&amp;#xff0c;导致了报错&amp;#xff01;&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["c++小白提问，在循环中利用map容器的指针时出现错误", ["\n", "#include<iostream>\n#include<cstdio>\n#include<map>\nusing namespace std;\nint main()\n{\n    map<int, double>xishu;\n    map<int, double>result;\n    int K;\n    cin >> K;\n    while(K--){\n        int a;\n        double d;\n        cin >> a >> d;\n        xishu[a] = d;\n    }\n    cin >> K;\n    while (K--) {\n        int a;\n        double d;\n        cin >> a >> d;\n        for (auto it = xishu.begin(); it != xishu.end();) {\n            it++;\n            result[a + (it->first)] = d * (it->second);\n        }\n    }\n    cout << result.size();\n    for (auto it = result.end(); it != result.begin();) {\n        it--;\n        printf(\" %d %.1f\", it->first, it->second);\n    }\n}", "\n\n", "\n\n", "这个循环第一次是可以运行的，第二次就出现这个错误了"]], "Tag": "程序设计"}
{"Answer": "也就是说调用后，elem1==elem2，即删除了 elem1 和  elem2 之间的元素。\r\n如果你想知道书上说的是对，还是错，最好是自己上机编程来验证，而不是来这里提问。\r\n\r\n编译器给出的答案，肯定是正确的。虽然说，不同编译器、对某些语句可能得到不同的答案，但这也是你学习的一部分，知道会比不会强一些。", "Konwledge_Point": "容器和迭代器", "Question": ["C++中顺序容器 erase，C++ Primer是否出错", ["C++ Primer中文第五版9.3.3的P312删除多个元素原文：", "\nelem1=slist.erase(elem1,elem2);              //调用后，elem1==elem2", "\n迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。", "\n\n", "这句话是不是错了。调用slist.erase(elem1,elem2)删除了slist从elem1到elem2（包含elem2）的元素，指向elem2后的元素。那么调用之后elem1怎么会等于elem2呢！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;在vector为空的时候，begin()返回尾后迭代器，也就是vec.begin()==vec.end()，此时用vec[0]会抛out_of_range异常。&lt;/p&gt;\n\n&lt;p&gt;在不为空的时候，*vec.begin()等价于vec[0]。对*vec.begin()的修改等价于对vec[0]的修改。&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["vector容器中begin和[0]是指代同一个数据吗？", ["我目前只知道begin是一个迭代器 应该是数组头指针 那么就是指向vector [0]了？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;find方法是通过key来找的&amp;#xff0c;你的key是char&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["C++   容器算法 STL MAP容器", ["，麻烦看下哪里出错了，我找了好久不同的做法没结果没有找的用map容器的这种", "求指教", "****", "\n", "题目描述", "小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组 成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。", "\n", "现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。", "\n", "输入描述", "输入一行包含一个单词，单词只由小写英文字母组成。", "\n", "对于所有的评测用例，输入的单词长度不超过 1000。", "\n", "输出描述", "输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。", "\n", "第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。", "\n", "输入输出样例", "输入：lanqiao", "\n", "输出：a 2", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", "<string>", "\n", "#", "include", "<map>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    ", "//创建输入的字符串", "\n    string valuable;\n    ", "//输入字符串", "\n    cin >> valuable;\n    ", "//创建map对象", "\n    map<", "char", ", ", "int", ">M;\n    ", "//", "\n    ", "for", " (", "int", " i = ", "0", "; i < valuable.", "size", "(); i++)\n    {\n        ", "char", " temp = valuable[i];", "//temp=第I个元素", "\n        M.", "insert", "(", "pair", "<", "char", ", ", "int", ">(temp, ", "0", "));", "//创建key为char;value为int的数据元素", "\n        M[temp]++;", "//该元素的value值++", "\n    }\n    ", "int", " max = ", "0", ";\n    ", "for", " (map<", "char", ",", "int", ">::iterator it=M.", "begin", "(); it!= M.", "end", "(); it++)", "//迭代器遍历map容器", "\n    {\n        ", "if", " (it->second > max)\n        {\n            max = it->second;\n        }", "//从key为a的元素开始遍历，如果value>max则更新max的值", "\n    }\n    cout << M.", "find", "(max)->first << endl;", "//输出最大值的key值，即出现次数最多的字母", "\n    cout << max << endl;", "//输出出现最多的次数", "\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;报错是因为operator[]如果key不存在会自动创建&amp;#xff0c;需要无参构造函数。对象直接放进去不可能&amp;#xff0c;因为你传进去的参数是一个临时对象&amp;#xff0c;会被析构&amp;#xff0c;想减少复制&amp;#xff0c;可以用移动构造函数。具体复制了这么多次我也不确定&amp;#xff0c;你可以看看内部实现\n &lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["C++ 容器unordered_map问题", ["问题1：unoedered map 中的find 和  operator[]  和 at  什么区别 ？", " 我想在这个容器中找到 一个 元素  如果是 find  则返回 指向这一对组的迭代器  如果用【】 那就应该直接返回当前那个索引下的元素吧？at 应该和 [] 差不多 ？", "我这样用 就报错", "\n", "这是class A", "\n", "class", " A{\npublic:\n    ", "string", " m_str;\n    ", "A(", "string", " ", "s", ")", ":m", "_str(", "s", ")", "{\n        cout<<", "\"A(string s)    s = \"", "<<s<<endl;\n    }\n\n    ", "A(", "const", " A& ", "p", ")", " {\n        cout<<", "\"A(const A& p) p.m_str = \"", "<<p.m_str<<endl;\n        ", "string", " s = p.m_str;\n        s.append(", "\" append \"", ");\n        m_str = s;\n    }\n};\n\n", "int", " main", "()", "{\n    unordered_map<", "int", ",A> mp;\n    mp.insert(pair<", "int", ",A>(", "1", ",", "A(", "\"csdn\"", ")", "));\n    mp.insert(pair<", "int", ",A>(", "2", ",", "A(", "\"hub\"", ")", "));\n    cout<<mp.at(", "1", ").m_str<<endl;   ", "// 用find()->second.m_str 也可以跑", "\n    cout<<mp.at(", "2", ").m_str<<endl;\n    cout<<mp", "[", "1", "]", ".m_str; ", "// 这一句 是 报错的  ", "\n}\n", "\n", "错误：", "\n", "还有 一个问题 ： 这个容器我原本以为是，在对应索引位置插入一个临时对象，那她就把那个对象直接放到容器里，后来我重写了一下拷贝构造函数，发现它好像 拷贝构造了 好几回 ， 就按上面这个main 函数里的 例子  打印结果如下", "\n", "A", "(string s)", "   s = csdn\n", "A", "(const A& p)", " ", "p", ".m_str", " = csdn\n", "A", "(const A& p)", " ", "p", ".m_str", " = csdn append\n", "A", "(string s)", "   s = hub\n", "A", "(const A& p)", " ", "p", ".m_str", " = hub\n", "A", "(const A& p)", " ", "p", ".m_str", " = hub append\ncsdn append  append\nhub append  append\n\n", "\n", "为什么打印结果 每插入一个 它调用了 3次 构造函数   不应该是 第一次 是我 传参数的时候传的那个临时对象 调用的第一个构造函数，然后打印出第一行，然后 这个容器拷贝一份 调用 第二个构造函数 打印出 第 二行 ，那第三行 哪里来的？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;end()类似文件的EOF一样&amp;#xff0c;是个无效标志&amp;#xff0c;你用*取地址当然报错了&lt;br /&gt;你需要先判断find结果不等于end()&amp;#xff0c;然后才能输出&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["c++中set容器find的问题", ["set容器中的find，不是如果找不到对应的元素的话就会返回end()吗，但是为什么cout<<*(s1.find(3));这行代码会使程序崩溃，", "理论上他应该会返回22才对呀", "\n", "#", "include", "<iostream>", "\n", "using", " ", "namespace", " std;\n", "#", "include", "<set>", "\n", "void", " ", "test4", "()", "\n", "{\n    ", "//查找和统计", "\n    set<", "int", ">s1;\n    s1.", "insert", "(", "10", ");\n    s1.", "insert", "(", "12", ");\n    s1.", "insert", "(", "0", ");\n    s1.", "insert", "(", "1", ");\n    s1.", "insert", "(", "13", ");\n    s1.", "insert", "(", "22", ");\n    s1.", "insert", "(", "4", ");\n    s1.", "insert", "(", "11", ");\n    ", "//s1.find(key)", "\n    ", "//查找key存不存在，若存在返回该元素的迭代器，如不存在返回set.end();", "\n    ", "//s1.count(key)", "\n    ", "// 查找key的个数", "\n    \n    \n    cout<<*(s1.", "find", "(", "3", "));\n}\n", "int", " ", "main", "()", "\n", "{\n    ", "test4", "();\n    ", "system", "(", "\"pause\"", ");\n    ", "return", " ", "0", ";\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;做完16-17行的操作&amp;#xff0c;第index个元素不在elementData中了&amp;#xff0c;但是在elementData的末尾多出来一个元素&amp;#xff0c;他和到数第二个元素是重复的&amp;#xff1b;而且在ArrayList对象中再也访问不到&amp;#xff0c; 但是实际上有一个引用指向它&amp;#xff0c;导致在ArrayList不能回收的情况&amp;#xff0c;它也不能回收。因此第18行代码就是让ArrayList中的elementData不再指向它&amp;#xff0c;就可以在Arraylist回收之前回收了。&lt;br /&gt;add(null) elementData[size&amp;#43;&amp;#43;] &amp;#61; e&amp;#xff0c;是在末尾添加一个空元素&amp;#xff0c;和18的代码含义不一样&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["Java中ArrayList的相关问题？GC回收问题？", ["\n", "public", " ", "boolean", " add(E e) {\n    ensureCapacityInternal(size + ", "1", ");  ", "// Increments modCount!!  add操作涉及到容器的扩容", "\n    elementData[size++] = e;", "//正常操作，多线程时不安全", "\n    ", "return", " ", "true", ";\n}\n\n", "public", " E remove(", "int", " ", "index", ") {\n    rangeCheck(", "index", ");\n\n    modCount++;", "//使用迭代器遍历元素时，删除元素会让迭代器失效", "\n    E oldValue = elementData(", "index", ");\n\n    ", "int", " numMoved = size - ", "index", " - ", "1", ";", "//找到要移动到前面的长度", "\n    ", "if", " (numMoved > ", "0", ")\n        System.arraycopy(elementData, ", "index", "+", "1", ", elementData, ", "index", ",\n                         numMoved);", "//把数组index之后的元素向前移1。", "\n    elementData[--size] = ", "null", "; ", "// clear to let GC do its work", "\n\n    ", "return", " oldValue;\n}\n", "\n", "elementData[--size] = null; // clear to let GC do its work", " 那么和我直接add(null)  elementData[size++] = e;这句话有什么区别？"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/612639132276122.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;\n&lt;p&gt;&lt;/p&gt;&lt;p class=\"md_img_container\"&gt;&lt;img class=\"md_img\" src=\"https://img-mid.csdnimg.cn/release/static/image/mid/ask/287249132276147.png\" alt=\"img\" align=\"left\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["C++ list容器与文件的使用 读不出来", ["如图所示 我的文件里已经有存入对应的数据 但是读出来的时候 显示不全 我用的是list容器", "\n", "#include<iostream>", "\nusing ", "namespace", " ", "std", ";\n", "#include<fstream>", "\n", "#define filename \"booklist.txt\"", "\n", "#include<list>", "\n", "#include<cstring>", "\n", "#include<iomanip>", "\n\n", "class", " ", "Book", "\n", "{\n", "public", ":\n    Book(", "string", " na = ", "\" \"", ", ", "int", " p = ", "0", ", ", "int", " n = ", "0", ", ", "string", " m = ", "\" \"", ", ", "string", " o = ", "\" \"", ", ", "int", " s = ", "0", ", ", "int", " r = ", "0", ", ", "string", " t = ", "\" \"", ")\n    {\n        name = na;\n        num = n;\n        riqi = p;\n        chubanshe = m;\n        leibie = o;\n        bianhao = s;\n        ISBN = r;\n        zuozhe = t;\n    }\n    ", "void", " Show()\n    {\n        cout << ", "\"书名：\"", " << std::left << setw(", "20", ") << name << std::right << setw(", "6", ") << ", "\"\\t日期：\"", " << riqi << ", "\"\\t数量：\"", " << num << ", "\"\\t作者:\"", "<<zuozhe<<", "\"\\t出版社:\"", " << chubanshe << ", "\"\\t类别:\"", " << leibie << ", "\"\\t编号：\"", " << bianhao << ", "\"\\tISBN:\"", " << ISBN << endl;\n    }\n    ", "void", " Set()\n    {\n        cout << ", "\"请输入书名:\"", ";\n        cin >> name;\n        cout << ", "\"请输入日期:\"", ";\n        cin >> riqi;\n        cout << ", "\"请输入数量:\"", ";\n        cin >> num;\n        cout << ", "\"请输入作者:\"", ";\n        cin >> zuozhe;\n        cout << ", "\"请输入出版社:\"", ";\n        cin >> chubanshe;\n        cout << ", "\"请输入类别:\"", ";\n        cin >> leibie;\n        cout << ", "\"请输入编号:\"", ";\n        cin >> bianhao;\n        cout << ", "\"请输入ISBN:\"", ";\n        cin >> ISBN;\n    }\n    ", "void", " Addnum()\n    {\n        ", "int", " n;\n        cout << ", "\"请输入归还的数量：\"", ";\n        cin >> n;\n        num += n;\n    }\n    ", "void", " Borrownum()\n    {\n        ", "int", " n;\n        cout << ", "\"请输入借出的数量：\"", ";\n        cin >> n;\n        num -= n;\n    }\n", "public", ":\n    ", "string", " name;\n    ", "int", " riqi;", "//出版日期", "\n    ", "int", " num;", "//剩余数量", "\n    ", "string", " chubanshe;", "//出版社", "\n    ", "string", " leibie;", "//类别", "\n    ", "int", " bianhao;", "//编号", "\n    ", "int", " ISBN;", "//ISBN", "\n    ", "string", " zuozhe;", "//作者", "\n};\n", "bool", " paixuguize(Book& b1, Book& b2)", "//排序规则", "\n{\n\n    ", "if", " (b1.leibie == b2.leibie)\n    {\n        ", "if", " (b1.num == b2.num)\n\n        {\n            ", "return", " b1.ISBN < b2.ISBN;\n\n        }\n        ", "else", "\n        {\n            ", "return", " b1.num < b2.num;\n        }\n\n\n\n    }\n    ", "else", "\n    {\n        ", "return", " b1.num < b2.num;\n    }\n\n\n\n\n}\n", "void", " menu()\n{\n    cout << ", "\"--------------------------------------欢迎进入图书管理系统--------------------------------------\"", " << endl;\n    cout << endl << ", "\"0 - 退出系统；\"", " << ", "\"1 - 显示库存；\"", " << ", "\"2 - 查询图书；\"", " << ", "\"3 - 借阅图书；\"", " << ", "\"4 - 归还图书；\"", " << ", "\"5 - 增加图书；\"", " << ", "\"6 - 删除图书；\"", " <<", "\"7 -排序图书；\"", "<< endl;\n}\n\n", "class", " ", "Booklist", "//创建", "BookList", "类，数据成员有", "Book", "还有图书数量\n", "{\n", "public", ":\n    ", "void", " save()", "//新建图书的话保存数据，用app方式打开文件", "\n    {\n        ofstream fout(filename, ios::app);\n        ", "list", "<Book>::iterator it = BList.begin();\n        ", "for", " (", "int", " i = ", "0", "; i < num - ", "1", "; i++)", "//偏移迭代器，指向新加入的Book并写入文件", "\n        {\n            it++;\n        }\n        ", "for", " (; it != BList.end(); it++)\n        {\n            fout << (*it).name << ", "' '", " << (*it).riqi << ", "' '", " << (*it).num << (*it).chubanshe<<", "'  '", "<<(*it).zuozhe<<", "'  '", "<<(*it).leibie << ", "'  '", " << (*it).ISBN << ", "'  '", " << (*it).bianhao << ", "'  '", " << ", "'\\n'", ";\n        }\n        fout.close();\n    }\n    ", "void", " resave()\n    {\n        ofstream fout(filename, ios::out);", "//重新写入数据，因为删除了某个元素", "\n        ", "if", " (fout.is_open())\n        {\n            ", "for", " (", "list", "<Book>::iterator it = BList.begin(); it != BList.end(); it++)\n            {\n                fout << (*it).name << ", "' '", " << (*it).riqi << ", "' '", " << (*it).num << (*it).chubanshe << ", "'  '", " << (*it).zuozhe << ", "'  '", " << (*it).leibie << ", "'  '", " << (*it).ISBN << ", "'  '", " << (*it).bianhao << ", "'  '", " << ", "'\\n'", ";\n            }\n        }\n        fout.close();\n    }\n    ", "void", " Show()\n    {\n        ", "for", " (", "list", "<Book>::iterator it = BList.begin(); it != BList.end(); it++)\n        {\n            (*it).Show();\n        }\n    }\n    ", "void", " adddata()", "//添加数据", "\n    {\n        Book B;\n        B.Set();\n        BList.push_back(B);\n        num++;\n    }\n    ", "void", " start()", "//程序一开始读取文件里的数据", "\n    {\n        ", "string", " na;\n        ", "int", " n;\n        ", "int", " p;\n        ", "string", " m;\n        ", "string", " o;\n        ", "int", " s;\n        ", "int", " r;\n        ", "string", " t;\n\n        ifstream fin(filename, ios::in);\n        ", "if", " (fin.is_open())\n        {\n            ", "while", " (fin >> na >> p >>  n>>  m>>  o>>  s>>  r>>  t)\n            {\n                Book B(na, p, n,m,o,s,r,t);\n                BList.push_back(B);\n                num++;\n            }\n        }\n        fin.close();\n    }\n    ", "void", " increase()\n    {\n        cout << ", "\"请输入书名：\"", " << endl;\n        ", "string", " n;\n        cin >> n;\n        ", "for", " (", "list", "<Book>::iterator it = BList.begin(); it != BList.end(); it++)\n        {\n            ", "if", " ((*it).name == n)\n                (*it).Addnum();\n        }\n        resave();\n    }\n    ", "void", " decrease()\n    {\n        cout << ", "\"请输入书名：\"", " << endl;\n        ", "string", " n;\n        cin >> n;\n        ", "for", " (", "list", "<Book>::iterator it = BList.begin(); it != BList.end(); it++)\n        {\n            ", "if", " ((*it).name == n)\n                (*it).Borrownum();\n        }\n\n        resave();\n    }\n    ", "void", " FindBook()\n    {\n        ", "string", " name;\n        cin >> name;\n        ", "for", " (", "list", "<Book>::iterator it = BList.begin(); it != BList.end(); it++)", "//遍历整个list，所以符合关键字的都会被找到", "\n        {\n            ", "int", " index = (*it).name.find(name);", "//如果没找到返回值是一个很大的数", "\n            ", "if", " (index < (*it).name.length())\n                (*it).Show();\n        }\n    }\n\n    \n        \n    \n    ", "//void  show(list<Book>&b1) //排序后的显示", "\n    ", "//{", "\n    ", "//    for (list<Book>::iterator it = BList.begin(); it != BList.end(); it++)", "\n    ", "//    {", "\n\n\n    ", "//    cout<<\"姓名:\"<< (*it).name << ' ' <<\"日期:\" << (*it).riqi << ' ' <<\"数量：\" << (*it).num <<\"出版社：\"<< (*it).chubanshe << '  ' <<\"作者:\"<< (*it).zuozhe << '  ' <<\"类别:\"<< (*it).leibie << '  ' << \"ISBN:\"<<(*it).ISBN << '  ' << \"编号:\"<<(*it).bianhao << '  ' << '\\n';", "\n    ", "//    }", "\n\n\n    ", "//}", "\n    ", "void", " paixu()", "//进行排序并打印", "\n    {\n        BList.sort(paixuguize);\n        resave();\n    }\n    ", "void", " DeleteBook()\n    {\n        ", "string", " name;\n        cout << ", "\"请输入书名：\"", ";\n        cin >> name;\n        ", "int", " i = ", "0", ";\n        ", "for", " (", "list", "<Book>::iterator it = BList.begin(); it != BList.end(); it++)\n        {\n            ", "if", " ((*it).name == name)\n                ", "break", ";\n            ++i;\n        }\n        ", "list", "<Book>::iterator it = BList.begin();\n        advance(it, i);\n        BList.erase(it);\n        --num;\n        resave();\n    }\n", "public", ":\n    ", "list", "<Book>BList;\n    ", "int", " num = ", "0", ";\n};\n\n", "int", " main()\n{\n    Booklist B1;\n    B1.start();\n    ", "while", " (", "1", ")\n    {\n        menu();\n        ", "int", " key;\n        cout << ", "\"请输入要进行的操作：\"", ";\n        cin >> key;\n        ", "switch", " (key)\n        {\n        ", "case", " ", "0", ":\n            ", "return", " ", "0", ";\n            ", "break", ";\n        ", "case", " ", "1", ":\n            B1.Show();\n            ", "break", ";\n        ", "case", " ", "2", ":\n            B1.FindBook();\n            ", "break", ";\n        ", "case", " ", "3", ":\n            B1.decrease();\n            ", "break", ";\n        ", "case", " ", "4", ":\n            B1.increase();\n            ", "break", ";\n        ", "case", " ", "5", ":\n        {\n            B1.adddata();\n            B1.save();\n            ", "break", ";\n        }\n        ", "case", " ", "6", ":\n            B1.DeleteBook();\n            ", "break", ";\n        ", "case", " ", "7", ":\n            B1.paixu();\n            ", "break", ";\n            \n\n        }\n\n    }\n\n}\n\n"]], "Tag": "程序设计"}
{"Answer": "一个类可以按照不同方式迭代，拥有多个迭代器\r\n迭代器可以单独实现，和Iterable分开（设计模式里面叫外部迭代器）", "Konwledge_Point": "容器和迭代器", "Question": ["关于java中Iterable和Iterator接口的问题", ["java中foreach为什么设计成通过Iterable访问容器，而不直接通过Iterator访问？", "\n\n", "这样产生特定Iterable接口，满足foreach，就需要实现两层匿名内部类，Iterable和Iterator，为什么foreach不设计成通过Iterator访问容器？", "\n不知道多设计一层Iterable是为了什么目的。请指教，谢谢。", "\n\n", "class ReversibleArrayList<T> extends ArrayList<T>\n{\n    public ReversibleArrayList(Collection<T> c) { super(c); }\n    public Iterable<T> reversed()\n    {\n        return new Iterable<T>()\n                {\n                    public Iterator<T> iterator()\n                    {\n                        return new Iterator<T>()\n                                {\n                                    int current = size() - 1;\n                                    public boolean hasNext() { return current > -1; }\n                                    public T next() { return get(current--); }\n                                    public void remove() { throw new UnsupportedOperationException(); }\n                                };\n                    }\n                };\n    }\n}\n\n", "\n\n", "通过两层匿名内部类，才得到迭代器。"]], "Tag": "程序设计"}
{"Answer": "finalgrade vector 没有初始化大小，导致后面访问的时候不是按照你预期的方式去遍历的。\r\n\r\n    std::vector&lt;int&gt; scores = {60,54,70,86,90,64,98};\r\n    auto p = scores.begin();\r\n\t\t\r\n   ** std::vector&lt;std::string&gt; finalgrade(scores.size());**\r\n\t \r\n    auto q = finalgrade.begin();\r\n \r\n    while (q != finalgrade.end() &amp;&amp; p != scores.end())\r\n    {\r\n        *q = (*p &gt; 90) ? \"high pass\"\r\n            : ((*p &lt;= 90) &amp;&amp; (*p&gt;75)) ? \"pass\"\r\n            : (*p &lt; 60) ? \"fail\" : \"low pass\";\r\n        ++p;\r\n        std::cout &lt;&lt; *q++ &lt;&lt; std::endl;\r\n    }", "Konwledge_Point": "容器和迭代器", "Question": ["代码问题| Vector内数据处理", ["题目是使用条件运算符将成绩划分为high pass/pass/low pass/fail四种，", "\n成绩用一个容器存储，Finalgrade用另一个容器存储，最后显示。", "\n\n", "我使用迭代器遍历容器内数据，但是没有输出，请问问题出在哪？非常感谢！", "\n\n", "代码如下： ", "\n\n", "    vector<int> scores = {60,54,70,86,90,64,98};\n    auto p = scores.begin();\n    vector<string> finalgrade = {};\n    auto q = finalgrade.begin();\n\n    while (q != finalgrade.end() && p != scores.end())\n    {\n        *q = (*p > 90) ? \"high pass\"\n            : ((*p <= 90) && (*p>75)) ? \"pass\"\n            : (*p < 60) ? \"fail\" : \"low pass\";\n        ++p;\n        cout << *q++ << endl;\n    }\n"]], "Tag": "程序设计"}
{"Answer": "因为你for循环中有it+1。而判断条件是不等于end。所以当it达到end前面一个元素时。it+1会有问题", "Konwledge_Point": "容器和迭代器", "Question": ["用vector时最后输出正确没有报错但却出现 Debug assertion failed", ["题目是：将若干个整数输入vector容器，用迭代器将相邻的两个元素之和输出。", "\n下面是代码：", "\n当没有输入和输入的数字个数为奇数时，都有正确结果并且不会出现Debug assertion failed，如图：", "\n但是当输入数字个数为偶数时，虽然有正确的结果输出，但是伴随有Debug assertion failed的出现，如图：", "\n是else 后面的偶数语句中超出了vector的范围导致的么？请大家帮忙指出错误和出现Debug assertion failed这类情况的解决办法，谢谢大家！"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;unordered_map底层是哈希表&amp;#xff0c;排列无序&amp;#xff1b;要顺序排列用map&amp;#xff0c;底层是红黑树&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["对于unordered_map当key是string时的使用", ["\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<string>", "\n", "#", "include", " ", "<unordered_map>", "\n", "using", " ", "namespace", " std;\n", "int", " ", "main", "()", "\n", "{\n    ", "//创建空 umap 容器", "\n    unordered_map<string, string> umap;\n    ", "//向 umap 容器添加新键值对", "\n    umap.", "emplace", "(", "\"Python教程\"", ", ", "\"http://c.biancheng.net/python/\"", ");\n    umap.", "emplace", "(", "\"Java教程\"", ", ", "\"http://c.biancheng.net/java/\"", ");\n    umap.", "emplace", "(", "\"Linux教程\"", ", ", "\"http://c.biancheng.net/linux/\"", ");\n    ", "//输出 umap 存储键值对的数量", "\n    cout << ", "\"umap size = \"", " << umap.", "size", "() << endl;\n    ", "//使用迭代器输出 umap 容器存储的所有键值对", "\n    ", "for", " (", "auto", " iter = umap.", "begin", "(); iter != umap.", "end", "(); ++iter) {\n        cout << iter->first << ", "\" \"", " << iter->second << endl;\n    }\n    ", "return", " ", "0", ";\n}\n\n", "\n", "我的输出结果刚好是反的，这是为什么，请各位解答", "\n", "umap size = ", "3", "\nLinux教程 http:", "//", "c.biancheng.net", "/linux/", "\nJava教程 http:", "//", "c.biancheng.net", "/java/", "\nPython教程 http:", "//", "c.biancheng.net", "/python/", "\n"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;lfind的返回值是一个iterator啊&amp;#xff0c;你应该这样写&amp;#xff1a;iter &amp;#xff01;&amp;#61; ilist.end()&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["C++中没有与这些操作数匹配的!=运算符", ["练习list时遇到这个问题如何解决？", "\n", "\n", "源代码：", "\n", "\n", "//重点查看list的构造方式以及大小的变化", "\n", "#", "include", " ", "<iostream>", "\n", "#", "include", " ", "<list>", "\n", "#", "include", " ", "<algorithm>", "\n", "using", " ", "namespace", " std;\n\n", "int", " ", "main", "()", "\n", "{\n    ", "int", " i;\n    list<", "int", ">ilist;\n    cout << ", "\"刚开始size=\"", " << ilist.", "size", "() << endl;\n\n    ilist.", "push_back", "(", "0", ");\n    ilist.", "push_back", "(", "1", ");\n    ilist.", "push_back", "(", "2", ");\n    ilist.", "push_back", "(", "3", ");\n    cout << ", "\"插入四个元素后size=\"", " << ilist.", "size", "() << endl;\n\n    ", "//使用迭代器for循环遍历容器元素", "\n    cout<<", "\"list容器内的元素为\"", " << endl;\n    list<", "int", ">::iterator ite;\n    ", "for", " ( ite= ilist.", "begin", "(); ite != ilist.", "end", "(); ++ite)\n    {\n        cout<< *ite << ", "\" \"", ";\n    }\n    cout  << endl;\n\n    ite = ", "find", "(ilist.", "begin", "(), ilist.", "end", "(), ", "3", ");\n    ", "if", " (ite != ", "0", ")\n    {\n        ilist.", "insert", "(ite,", "99", ");\n    }\n\n\n    ", "return", " ", "0", ";\n}\n", "\n", "怎么解决啊"]], "Tag": "程序设计"}
{"Answer": "果然还是要靠自己啊。\r\n自己追踪了两天，发现是一个状态控制的原因，哪个list容器，原本应该在连接失败，调用close时被删除掉，但是因为(m_bConnecting)_的状态出现问题，\r\n原本应是是true的，却变成了false。\r\n\r\nif (m_bListening)\r\n   {\r\n      m_bListening = false;\r\n      m_pRcvQueue-&gt;removeListener(this);\r\n   }\r\n   else if (m_bConnecting)\r\n   {\r\n      m_pRcvQueue-&gt;removeConnector(m_SocketID);\r\n   }\r\n\t \r\n猜测可能是recv 的work线程中的函数\r\n\t\t\t// Check connection requests status for all sockets in the RendezvousQueue.\r\n      self-&gt;m_pRendezvousQueue-&gt;updateConnStatus();\r\n将(m_bConnecting)_置为false（在超时的情况下）\r\n\t\t\t// avoid sending too many requests, at most 1 request per 250ms\r\n      if (CTimer::getTime() - i-&gt;m_pUDT-&gt;m_llLastReqTime &gt; 250000)\r\n      {\r\n         if (CTimer::getTime() &gt;= i-&gt;m_ullTTL)\r\n         {\r\n            // connection timer expired, acknowledge app via epoll\r\n            i-&gt;m_pUDT-&gt;m_bConnecting = false;\r\n            CUDT::s_UDTUnited.m_EPoll.update_events(i-&gt;m_iID, i-&gt;m_pUDT-&gt;m_sPollID, UDT_EPOLL_ERR, true);\r\n            continue;\r\n         }\r\n从而到时在connect失败是，调用close释放了UDT本身的空间，但是list却没有释放，而在list中有一个指针是指向UDT的空间的，而这个空间已经被释放，这样就会出错。\r\n解决方案1：从根源解决\r\n\t\t\t先释放list，在释放UDT时判断list是否释放，如果没有就释放。\r\n解决方案2:简单解决\r\n\t\t\t在connect失败后延时250ms以上，使(m_bConnecting)_得状态一定处于false，并改变删除list的判断条件，已false为释放出发点。\r\n我用的是方案2，因为时间紧，目前未发现修改这个控制变量对其他地方的影响。", "Konwledge_Point": "容器和迭代器", "Question": ["UDT协议在连接对端时出错（UDT4.11 connect）", ["本人最近在研究UDT协议，想用它写一个Windows下运行的客户端，用c++编写，在写完测试时发现个问题，随后用UDE demo测试发现问题依然存在。（非Rendezvous模式）", "\n运行环境：", "\nWin7 VS2010 UDT版本4.11", "\n问题描述：", "\n因为是一个长期运行的程序，修改UDT demo recvfile.cpp  使它循环发送，不退出  对connect做如下处理", "\nif (UDT::ERROR == UDT::connect(fhandle, peer->ai_addr, peer->ai_addrlen))", "\n   {", "\n      cout << \"connect: \" << UDT::getlasterror().getErrorMessage() << endl;", "\n\n", "  UDT::close(fhandle);\n\n  freeaddrinfo(peer);\n\n  continue ;      \n", "\n\n", "}", "\n运行demo，让它连接一个不存在的IP，发现demo在运行几次后就会死掉，大约3次左右，使用VS2010调试，发现在死在UDT的接收线程里面，", "\nCRcvQueue::worker(LPVOID param)函数的self->m_pRendezvousQueue->updateConnStatus();_而GC线程停在等待释放接收线程的位置。", "\n再跟进去看发现是一个list的迭代器获取失败导致的，但是我没有找到有对这个容器的修改啊，希望有那个知道的大牛讲解下，万分感谢。"]], "Tag": "程序设计"}
{"Answer": "&lt;p&gt;安装EasyX库后才能用graphics.h头文件的&lt;/p&gt;", "Konwledge_Point": "容器和迭代器", "Question": ["开头#include<graphics.h>说\t[Error] graphics.h: No such file or directory该如何改？", ["#include", "#include", "#include//操纵器", "#include//文件流输入输出", "#include//容器", "#include//算法库", "#include<graphics.h>", "#include<conio.h>", "using namespace std;", "fstream f;", "typedef struct statis", "{//汇总专用结构体", "    double average[6]={0},MAX[6]={0},MIN[6]={999,999,999,999,999,999};//平均分最高最低分", "    double SucessPercent[6],FailPercent[6];//及格率不及格率", "    int number=0,SucessNumber[6]={0},FailNumber[6]={0};//总人数，及格人数，不及格人数", "}statis;", "typedef struct Student", "{", "    string id,name;", "    int Class;//班级", "    double score[6],sum=0;//成绩 总分", "    int totalrank=1,classrank=1;//总排名和班排名", "}Student;", "bool downcmp(Student a,Student b)", "{//按总分降序排序", "    return a.sum>b.sum;", "}", "bool idcmp(Student a,Student b)", "{//按学号排序", "    return a.id<b.id;", "}", "void stu_Rank(vector&stu)", "{//排名", "    sort(stu.begin(),stu.end(),downcmp);//班级排名容器也按总分排序", "    int totalRank=1,totalcount=1;//排名,计数器", "    double last=-1;", "    int Rank[2]={1,1},Count[2]={1,1};", "    double Last[2]={-1,-1};//n个就开n就好了", "    for(auto it=stu.begin();it!=stu.end();it++)", "    {//走一趟总排和班排一起出！", "        if(last==-1)", "            last=-2;//就只是第一次启动不管last而已", "        else if(it->sum==last)//总分相同排名数不变，计数器加", "            totalcount++;", "        else", "        {", "            totalRank+=totalcount;", "            last=it->sum;//前一个的数据要被更新", "            totalcount=1;", "        }", "        it->totalrank=totalRank;", "        for(int i=0;i<2;i++)", "        {//n个到n就好,遍历已有班级", "            if(it->Class==i+1)", "            {", "                if(Last[i]==-1)", "                    Last[i]=-2;//就只是第一次启动不管last而已", "                else if(it->sum==Last[i]||Last[i]==-1)//总分相同排名数不变，计数器加", "                    Count[i]++;", "                else", "                {", "                    Rank[i]+=Count[i];", "                    Last[i]=it->sum;//前一个的数据要被更新", "                    Count[i]=1;", "                }", "                it->classrank=Rank[i];", "            }", "        }", "    }", "}", "void stu_Out(vectorstu,string filename,int outtype)", "{//输出文件名和输出类型0：txt 1：csv表格 2：直接输出", "    if(outtype==0)", "    {//txt导出", "        f.open(filename+\".txt\",ios::out);", "        f<<left<<setw(18)<<\"学号\";", "        f<<left<<setw(20)<<\"姓名\";", "        for(int i=0;i<6;i++)", "            f<<\"学科\"<<left<<setw(10)<<i+1;", "        f<<left<<setw(10)<<\"总分\";", "        f<<left<<setw(10)<<\"总排名\";", "        f<<left<<setw(10)<<\"班排名\"<<endl;", "        for(auto it=stu.begin();it!=stu.end();it++)", "        {", "            f<<left<<setw(18)<", "id;", "            f<<left<<setw(20)<", "name;", "            for(int i=0;i<6;i++)", "                f<<left<<setw(14)<", "score[i];", "            f<<left<<setw(10)<", "sum;", "            f<<left<<setw(10)<", "totalrank;", "            f<<left<<setw(10)<", "classrank;", "            f<<endl;", "        }", "        f.close();", "    }", "    else if(outtype==1)", "    {//csv表格导出", "        f.open(filename+\".csv\",ios::out);", "        f<<\"学号,\";", "        f<<\"姓名,\";", "        for(int i=0;i<6;i++)", "            f<<\"学科\"<<i+1<<\",\";", "        f<<\"总分,\";", "        f<<\"总排名,\";", "        f<<\"班排名,\"<<endl;", "        for(auto it=stu.begin();it!=stu.end();it++)", "        {", "            f<", "id<<\",\";", "            f<", "name<<\",\";", "            for(int i=0;i<6;i++)", "                f<", "score[i]<<\",\";", "            f<", "sum<<\",\";", "            f<", "totalrank<<\",\";", "            f<", "classrank<<\",\";", "            f<<endl;", "        }", "        f.close();", "    }", "    else", "    {//直接输出", "        cout<<left<<setw(18)<<\"学号\";", "        cout<<left<<setw(20)<<\"姓名\";", "        for(int i=0;i<6;i++)", "            cout<<\"学科\"<<left<<setw(10)<<i+1;", "        cout<<left<<setw(10)<<\"总分\";", "        cout<<left<<setw(10)<<\"总排名\";", "        cout<<left<<setw(10)<<\"班排名\"<<endl;", "        for(auto it=stu.begin();it!=stu.end();it++)", "        {", "            cout<<left<<setw(18)<", "id;", "            cout<<left<<setw(20)<", "name;", "            for(int i=0;i<6;i++)", "                cout<<left<<setw(14)<", "score[i];", "            cout<<left<<setw(10)<", "sum;", "            cout<<left<<setw(10)<", "totalrank;", "            cout<<left<<setw(10)<", "classrank;", "            cout<<endl;", "        }", "    }", "}", "vector stu_search(vectorstu,string information)", "{//搜索并列出相关内容", "    vector", "result;", "    for(auto it=stu.begin();it!=stu.end();it++)", "    {//符合条件的都加入结果的容器", "        if(it->id.find(information)!=-1)", "            result.push_back(*it);", "        else if(it->name.find(information)!=-1)", "            result.push_back(*it);", "    }", "    return result;//输出交给主程序，返回结果容器方便删除修改的时候也能用", "    //stu_Out(result,\"\",2);直接展示搜索结果即可", "}", "void stu_statistics(vectorstu,string filename,int outtype)", "{//统计汇总,txt:0 csv:1 直接输出:2", "    statis class1,class2,total;", "    for(auto it=stu.begin();it!=stu.end();it++)", "    {", "        if(it->Class==1)", "        {", "            class1.number+=1;//统计各班人数别放里面就一次加6人了", "            for(int i=0;i<6;i++)", "            {//遍历6科", "                class1.MAX[i]=max(it->score[i],class1.MAX[i]);", "                class1.MIN[i]=min(it->score[i],class1.MIN[i]);", "                class1.average[i]+=it->score[i];//先直接加，最外面知道了人数再除", "                if(it->score[i]>=60)//统计及格人数", "                    class1.SucessNumber[i]+=1;", "            }", "        }", "        else", "        {", "            class2.number+=1;//统计各班人数", "            for(int i=0;i<6;i++)", "            {//遍历6科", "                class2.MAX[i]=max(it->score[i],class2.MAX[i]);", "                class2.MIN[i]=min(it->score[i],class2.MIN[i]);", "                class2.average[i]+=it->score[i];//先直接加，最外面知道了人数再除", "                if(it->score[i]>=60)//统计及格人数", "                    class2.SucessNumber[i]+=1;", "            }", "        }", "    }", "    total.number=stu.size();", "    for(int i=0;i<6;i++)", "    {", "        class1.FailNumber[i]=class1.number-class1.SucessNumber[i];", "        class2.FailNumber[i]=class2.number-class2.SucessNumber[i];", "        class1.average[i]=class1.average[i]/class1.number;", "        class2.average[i]=class2.average[i]/class2.number;", "        class1.SucessPercent[i]=(double)class1.SucessNumber[i]/class1.number;", "        class1.FailPercent[i]=(double)class1.FailNumber[i]/class1.number;", "        class2.SucessPercent[i]=(double)class2.SucessNumber[i]/class2.number;", "        class2.FailPercent[i]=(double)class2.FailNumber[i]/class2.number;", "        //这些数据适合遍历完后再计算", "        total.MAX[i]=max(class1.MAX[i],class2.MAX[i]);//总的只需要在这两个班之间取一个", "        total.MIN[i]=min(class1.MIN[i],class2.MIN[i]);", "        total.SucessNumber[i]=class1.SucessNumber[i]+class2.SucessNumber[i];", "        total.FailNumber[i]=total.number-total.SucessNumber[i];", "        total.SucessPercent[i]=(double)total.SucessNumber[i]/total.number;", "        total.FailPercent[i]=(double)total.FailNumber[i]/total.number;", "        total.average[i]=(class1.average[i]+class2.average[i])/2.0;", "    }", "    if(outtype==0)", "    {//txt导出", "        f.open(filename+\".txt\",ios::out);", "        f<<left<<setw(18)<<\"班级\";", "        for(int i=0;i<6;i++)", "        {", "            f<<\"均分\"<<left<<setw(10)<<i+1;", "            f<<\"最高分\"<<left<<setw(10)<<i+1;", "            f<<\"最低分\"<<left<<setw(10)<<i+1;", "            f<<\"及格人数\"<<left<<setw(12)<<i+1;", "            f<<\"不及格人数\"<<left<<setw(15)<<i+1;", "            f<<\"及格率\"<<left<<setw(10)<<i+1;", "            f<<\"不及格率\"<<left<<setw(12)<<i+1;", "        }", "        f<<endl;", "        f<<left<<setw(18)<<\"班级1\";", "        for(int i=0;i<6;i++)", "        {//班级1", "            f<<left<<setw(10)<<class1.average[i];", "            f<<left<<setw(10)<<class1.MAX[i];", "            f<<left<<setw(10)<<class1.MIN[i];", "            f<<left<<setw(12)<<class1.SucessNumber[i];", "            f<<left<<setw(15)<<class1.FailNumber[i];", "            f<<left<<setw(10)<<class1.SucessPercent[i];", "            f<<left<<setw(12)<<class1.FailPercent[i];", "        }", "        f<<endl;", "        f<<left<<setw(18)<<\"班级2\";", "        for(int i=0;i<6;i++)", "        {//班级2", "            f<<left<<setw(10)<<class2.average[i];", "            f<<left<<setw(10)<<class2.MAX[i];", "            f<<left<<setw(10)<<class2.MIN[i];", "            f<<left<<setw(12)<<class2.SucessNumber[i];", "            f<<left<<setw(15)<<class2.FailNumber[i];", "            f<<left<<setw(10)<<class2.SucessPercent[i];", "            f<<left<<setw(12)<<class2.FailPercent[i];", "        }", "        f<<endl;", "        f<<left<<setw(18)<<\"总情况\";", "        for(int i=0;i<6;i++)", "        {//总", "            f<<left<<setw(10)<<total.average[i];", "            f<<left<<setw(10)<<total.MAX[i];", "            f<<left<<setw(10)<<total.MIN[i];", "            f<<left<<setw(12)<<total.SucessNumber[i];", "            f<<left<<setw(15)<<total.FailNumber[i];", "            f<<left<<setw(10)<<total.SucessPercent[i];", "            f<<left<<setw(12)<<total.FailPercent[i];", "        }", "        f.close();", "    }", "    else if(outtype==1)", "    {//csv表格导出", "        f.open(filename+\".csv\",ios::out);", "        f<<\"班级,\";", "        for(int i=0;i<6;i++)", "        {", "            f<<\"均分\"<<i+1<<\",\";", "            f<<\"最高分\"<<i+1<<\",\";", "            f<<\"最低分\"<<i+1<<\",\";", "            f<<\"及格人数\"<<i+1<<\",\";", "            f<<\"不及格人数\"<<i+1<<\",\";", "            f<<\"及格率\"<<i+1<<\",\";", "            f<<\"不及格率\"<<i+1<<\",\";", "        }", "        f<<endl;", "        f<<\"班级1,\";", "        for(int i=0;i<6;i++)", "        {//班级1", "            f<<class1.average[i]<<\",\";", "            f<<class1.MAX[i]<<\",\";", "            f<<class1.MIN[i]<<\",\";", "            f<<class1.SucessNumber[i]<<\",\";", "            f<<class1.FailNumber[i]<<\",\";", "            f<<class1.SucessPercent[i]<<\",\";", "            f<<class1.FailPercent[i]<<\",\";", "        }", "        f<<endl;", "        f<<\"班级2,\";", "        for(int i=0;i<6;i++)", "        {//班级2", "            f<<class2.average[i]<<\",\";", "            f<<class2.MAX[i]<<\",\";", "            f<<class2.MIN[i]<<\",\";", "            f<<class2.SucessNumber[i]<<\",\";", "            f<<class2.FailNumber[i]<<\",\";", "            f<<class2.SucessPercent[i]<<\",\";", "            f<<class2.FailPercent[i]<<\",\";", "        }", "        f<<endl;", "        f<<\"总情况,\";", "        for(int i=0;i<6;i++)", "        {//总", "            f<<total.average[i]<<\",\";", "            f<<total.MAX[i]<<\",\";", "            f<<total.MIN[i]<<\",\";", "            f<<total.SucessNumber[i]<<\",\";", "            f<<total.FailNumber[i]<<\",\";", "            f<<total.SucessPercent[i]<<\",\";", "            f<<total.FailPercent[i]<<\",\";", "        }", "        f.close();", "    }", "    else", "    {//直接输出", "        cout<<left<<setw(18)<<\"班级\";", "        for(int i=0;i<6;i++)", "        {", "            cout<<\"均分\"<<left<<setw(10)<<i+1;", "            cout<<\"最高分\"<<left<<setw(10)<<i+1;", "            cout<<\"最低分\"<<left<<setw(10)<<i+1;", "            cout<<\"及格人数\"<<left<<setw(12)<<i+1;", "            cout<<\"不及格人数\"<<left<<setw(15)<<i+1;", "            cout<<\"及格率\"<<left<<setw(10)<<i+1;", "            cout<<\"不及格率\"<<left<<setw(12)<<i+1;", "        }", "        cout<<endl;", "        cout<<left<<setw(18)<<\"班级1\";", "        for(int i=0;i<6;i++)", "        {//班级1", "            cout<<left<<setw(10)<<class1.average[i];", "            cout<<left<<setw(10)<<class1.MAX[i];", "            cout<<left<<setw(10)<<class1.MIN[i];", "            cout<<left<<setw(12)<<class1.SucessNumber[i];", "            cout<<left<<setw(15)<<class1.FailNumber[i];", "            cout<<left<<setw(10)<<class1.SucessPercent[i];", "            cout<<left<<setw(12)<<class1.FailPercent[i];", "        }", "        cout<<endl;", "        cout<<left<<setw(18)<<\"班级2\";", "        for(int i=0;i<6;i++)", "        {//班级2", "            cout<<left<<setw(10)<<class2.average[i];", "            cout<<left<<setw(10)<<class2.MAX[i];", "            cout<<left<<setw(10)<<class2.MIN[i];", "            cout<<left<<setw(12)<<class2.SucessNumber[i];", "            cout<<left<<setw(15)<<class2.FailNumber[i];", "            cout<<left<<setw(10)<<class2.SucessPercent[i];", "            cout<<left<<setw(12)<<class2.FailPercent[i];", "        }", "        cout<<endl;", "        cout<<left<<setw(18)<<\"总情况\";", "        for(int i=0;i<6;i++)", "        {//总", "            cout<<left<<setw(10)<<total.average[i];", "            cout<<left<<setw(10)<<total.MAX[i];", "            cout<<left<<setw(10)<<total.MIN[i];", "            cout<<left<<setw(12)<<total.SucessNumber[i];", "            cout<<left<<setw(15)<<total.FailNumber[i];", "            cout<<left<<setw(10)<<total.SucessPercent[i];", "            cout<<left<<setw(12)<<total.FailPercent[i];", "        }", "        cout<<endl;", "    }", "}", "void stu_append(vector&stu)", "{//增加记录", "    int n;", "    puts(\"请输入补录个数\");", "    cin>>n;", "    for(int i=0;i<n;i++)", "    {", "        puts(\"请输入学号 姓名 6科成绩\");", "        Student temp;", "        cin>>temp.id>>temp.name;", "        temp.sum=0;", "        for(int i=0;i<6;i++)", "        {", "            cin>>temp.score[i];", "            temp.sum+=temp.score[i];", "        }", "        temp.Class=temp.id[10]-'0'+1;//班级也要记得和排序导入的时候一样哦", "        stu.push_back(temp);", "    }", "    stu_Rank(stu);//加完重新计算名次", "}", "void stu_change(vector&stu,int type)", "{//模糊查找加修改 0修改1删除(代码高度相似所以整合)", "    if(type==0)", "        puts(\"请输入要修改者的信息（支持模糊查找）\");", "    else", "        puts(\"请输入被删除者的信息（支持模糊查找）\");", "    string information;", "    cin>>information;", "    vector", " result=stu_search(stu,information);", "    int n=result.size();", "    cout<<setw(20)<<\"学号\";", "    cout<<setw(20)<<\"姓名\";", "    for(int i=0;i<6;i++)", "        cout<<setw(10)<<\"学科\"+to_string(i+1);", "    cout<<setw(10)<<\"总分\";", "    cout<<setw(10)<<\"总排\";", "    cout<<setw(10)<<\"班排\"<<endl;", "    for(int i=0;i<n;i++)", "    {//输出所有符合条件的人", "        cout<<setw(5)<<i+1<<setw(19)<<result[i].id<<setw(20)<<result[i].name;", "        for(int j=0;j<6;j++)", "            cout<<setw(10)<<result[i].score[j];", "        cout<<setw(10)<<result[i].sum<<setw(10)<<result[i].totalrank;", "        cout<<setw(10)<<result[i].classrank<<endl;", "    }", "    if(type==0)", "        puts(\"请输入你要修改的编号\");", "    else", "        puts(\"请输入你要删除的编号\");", "    int index;", "    cin>>index;", "    index--;//对应物理下标", "    auto it=stu.begin();", "    for(;it!=stu.end();it++)", "    {//在真正大容器中找到要修改的这个", "        if(it->id==result[index].id)", "            break;", "    }", "    if(type==0)", "    {", "        puts(\"请输入新学号 姓名 6科成绩\");", "        Student temp;", "        cin>>temp.id>>temp.name;", "        for(int i=0;i<6;i++)", "        {", "            cin>>temp.score[i];", "            temp.sum+=temp.score[i];//总分别忘记了哦", "        }", "        temp.Class=temp.id[10]-'0'+1;//班级也要记得和排序导入的时候一样哦", "        *it=temp;//替换", "        puts(\"修改成功\");", "    }", "    else", "    {", "        stu.erase(it);//根据迭代器删除", "        puts(\"删除成功\");", "    }", "    stu_Rank(stu);//修改完重新排序", "}", "void stu_extraappend(vector stu1,vector &stu2)", "{//补录并导出stu2", "    vector", " wait;//需要进行补录的", "    for(auto it=stu1.begin();it!=stu1.end();it++)", "    {", "        bool flag=false;//默认没找到", "        for(auto it2=stu2.begin();it2!=stu2.end();it2++)", "        {", "            if(it->id==it2->id)", "            {", "                flag=true;//找到了有一样的", "                break;", "            }", "        }", "        if(flag==false)", "            wait.push_back(*it);", "    }", "    if(wait.size()!=0)", "    {", "        for(auto it=wait.begin();it!=wait.end();it++)", "        {", "            cout<", "id<<\"  \"<name<<endl;", "            it->sum=0;//总分也要记得改哦", "            puts(\"请输入6科成绩\");", "            for(int i=0;i<6;i++)", "            {", "                cin>>it->score[i];", "                it->sum+=it->score[i];", "            }", "            stu2.push_back(*it);", "        }", "        puts(\"补录完成\");", "        stu_Rank(stu2);", "    }", "    else", "        puts(\"无需补录\");", "\n", "}", "void stu_analysis(vector stu1,vector stu2)", "{//0 txt 1csv 2直接输出", "    sort(stu1.begin(),stu1.end(),idcmp);", "    sort(stu2.begin(),stu2.end(),idcmp);", "    puts(\"请选择导出方式txt:0 Excel表格:1 直接输出:2\");", "    int operat;", "    cin>>operat;", "    int n=stu1.size();", "    if(operat==0)", "    {", "        puts(\"请输入导出文件名\");", "        string output;", "        cin>>output;", "        f.open(output+\".txt\",ios::out);", "        f<<left<<setw(18)<<\"学号\";", "        f<<left<<setw(20)<<\"姓名\";", "        f<<left<<setw(10)<<\"总分1\";", "        f<<left<<setw(10)<<\"总分2\";", "        f<<left<<setw(22)<<\"总排名变化情况\";", "        f<<left<<setw(22)<<\"班排名变化情况\"<<endl;", "        for(int i=0;i<n;i++)", "        {", "            f<<left<<setw(18)<<stu1[i].id;", "            f<<left<<setw(20)<<stu1[i].name;", "            f<<left<<setw(10)<<stu1[i].sum;", "            f<<left<<setw(10)<<stu2[i].sum;", "            f<<left<<setw(22)<<stu2[i].totalrank-stu1[i].totalrank;", "            f<<left<<setw(22)<<stu2[i].classrank-stu1[i].classrank;", "            f<<endl;", "        }", "        f.close();", "    }", "    else if(operat==1)", "    {", "        puts(\"请输入导出文件名\");", "        string output;", "        cin>>output;", "        f.open(output+\".csv\",ios::out);", "        f<<\"学号,\";", "        f<<\"姓名,\";", "        f<<\"总分1,\";", "        f<<\"总分2,\";", "        f<<\"总排名变化情况,\";", "        f<<\"班排名变化情况,\"<<endl;", "        for(int i=0;i<n;i++)", "        {", "            f<<stu1[i].id<<\",\";", "            f<<stu1[i].name<<\",\";", "            f<<stu1[i].sum<<\",\";", "            f<<stu2[i].sum<<\",\";", "            f<<stu2[i].totalrank-stu1[i].totalrank<<\",\";", "            f<<stu2[i].classrank-stu1[i].classrank<<\",\";", "            f<<endl;", "        }", "        f.close();", "    }", "    else", "    {", "        cout<<left<<setw(18)<<\"学号\";", "        cout<<left<<setw(20)<<\"姓名\";", "        cout<<left<<setw(10)<<\"总分1\";", "        cout<<left<<setw(10)<<\"总分2\";", "        cout<<left<<setw(22)<<\"总排名变化情况\";", "        cout<<left<<setw(22)<<\"班排名变化情况\"<<endl;", "        for(int i=0;i<n;i++)", "        {", "            cout<<left<<setw(18)<<stu1[i].id;", "            cout<<left<<setw(20)<<stu1[i].name;", "            cout<<left<<setw(10)<<stu1[i].sum;", "            cout<<left<<setw(10)<<stu2[i].sum;", "            cout<<left<<setw(22)<<stu2[i].totalrank-stu1[i].totalrank;", "            cout<<left<<setw(22)<<stu2[i].classrank-stu1[i].classrank;", "            cout<<endl;", "        }", "    }", "}", "void picture()", "{", "    initgraph(640,480);", "    IMAGE img;", "    loadimage(&img,_T(\"菜单.jpg\"));", "    putimage(0,0,&img);", "    getch();", "    closegraph();", "}", "int main(void)", "{", "    vector", " stu1,stu2;", "    string source,output;", "    puts(\"请输入文件名1\");", "    cin>>source;", "    f.open(source+\".txt\",ios::in);//根据文件名打开相对路径文件", "    Student temp;", "    while(f>>temp.id>>temp.name)", "    {//没必要while里面读完一行，先读2个 成绩放里面用循环读就好了", "        for(int i=0;i<6;i++)", "        {", "            f>>temp.score[i];", "            temp.sum+=temp.score[i];//总分", "        }", "        temp.Class=temp.id[10]-'0'+1;", "        stu1.push_back(temp);", "        temp.sum=0;//记得恢复", "    }", "    stu_Rank(stu1);", "    f.close();", "    puts(\"请输入文件名2\");", "    cin>>source;", "    f.open(source+\".txt\",ios::in);//根据文件名打开相对路径文件", "    while(f>>temp.id>>temp.name)", "    {//没必要while里面读完一行，先读2个 成绩放里面用循环读就好了", "        for(int i=0;i<6;i++)", "        {", "            f>>temp.score[i];", "            temp.sum+=temp.score[i];//总分", "        }", "        temp.Class=temp.id[10]-'0'+1;", "        stu2.push_back(temp);", "        temp.sum=0;//记得恢复", "    }", "    stu_Rank(stu2);", "    f.close();", "    cout<<left<<setw(50)<<\"++\"<<endl;", "    cout<<left<<setw(51)<<\"|1.导出数据(已计算排序)        2.统计汇总成绩情况\"<<\"|\\n\";", "    cout<<left<<setw(49)<<\"|3.查询数据(模糊查找)        4.增加数据\"<<\"|\\n\";", "    cout<<left<<setw(48)<<\"|5.删除数据(含查找)         6.修改数据(含查找)\"<<\"|\\n\";", "    cout<<left<<setw(41)<<\"|7.数据补录             8.成绩分析\"<<\"|\\n\";", "    cout<<left<<setw(50)<<\"\"<<endl;", "    puts(\"|0.图片菜单|\");", "    puts(\"请输入对应操作编号\");", "\n", "int", " choose;\n", "while", "(cin>>choose)\n{\n    ", "if", "(choose==", "0", ")\n        picture", "()", ";\n    ", "else", " ", "if", "(choose==", "1", ")\n    {\n        puts(", "\"请选择导出方式txt:0 Excel表格:1 直接输出:2\"", ");\n        ", "int", " operat;\n        cin>>operat;\n        ", "if", "(operat!=", "2", ")\n        {\n            puts(", "\"请输入导出文件名\"", ");\n            ", "string", " output;\n            cin>>output;\n            stu", "_Out(", "stu1", ",", "output", "+", "\"1\"", ",", "operat", ")", ";\n            stu", "_Out(", "stu2", ",", "output", "+", "\"2\"", ",", "operat", ")", ";\n        }\n        ", "else", "\n        {\n            stu", "_Out(", "stu1", ",", "\"\"", ",", "operat", ")", ";\n            stu", "_Out(", "stu2", ",", "\"\"", ",", "operat", ")", ";\n        }\n    }\n    ", "else", " ", "if", "(choose==", "2", ")\n    {\n        puts(", "\"请选择导出方式txt:0 Excel表格:1 直接输出:2\"", ");\n        ", "int", " operat;\n        cin>>operat;\n        ", "if", "(operat!=", "2", ")\n        {\n            puts(", "\"请输入导出文件名\"", ");\n            ", "string", " output;\n            cin>>output;\n            stu", "_statistics(", "stu1", ",", "output", "+", "\"1\"", ",", "operat", ")", ";\n            stu", "_statistics(", "stu2", ",", "output", "+", "\"2\"", ",", "operat", ")", ";\n        }\n        ", "else", "\n        {\n            stu", "_statistics(", "stu1", ",", "\"\"", ",", "operat", ")", ";\n            stu", "_statistics(", "stu2", ",", "\"\"", ",", "operat", ")", ";\n        }\n    }\n        \n    \n"]], "Tag": "程序设计"}
