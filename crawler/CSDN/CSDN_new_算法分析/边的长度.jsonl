{"Answer": "这样吗#include<stdio.h>int main(){    int a,b,c,i,sum;    sum=0;    for(i=100;i<999;i++)    {        a = i / 100;        b = i / 10 % 10;        c = i % 10;        if((a>0)&&(b>0)&&(c>0))        {            if((a+b>c)&&(abs(a-b)<c))            {                if((a==b)||(a==c)||(b==c))                {                    printf(\"%d\\t\",i);                    sum++;                }            }        }\n}\nprintf(\"\\n%d\\n\",sum);\nreturn 0;\n\n}", "Konwledge_Point": "边的长度", "Question": "能不能用简单一点的c语言编写一下这个程序。\n在100-999的自然数中，若将组成这个数的三个数字认为是三条线段的长度，那么是三条线段组成一个等腰三角形（包括等边）的共有多少个", "Tag": "算法分析"}
{"Answer": "float CalcTriangleEdge(float a float b float gamma)\r\n函数定义放在函数中间还缺少了标点符号\r\n#include\r\n#include\r\n头文件也缺少了", "Konwledge_Point": "边的长度", "Question": "C++ 语法改错 谢谢了 我是一个初学者\n修复给定代码中的语法错误。该规范的目的是根据另两条边的长度以及它们之间的夹角，使用如下所示的余弦定律计算三角形边的长度：\n\n\n\n#include \n\n\n\n#include \n\n\n\nusing namespace std;\n\n\n\nconst float PI = 3.14159f;\n\n\n\nfloat DegreesToRadians(float degrees)\n\n\n\n{\n\n\n\ndegrees * PI / 180.0f;\n\n\n\nfloat CalcTriangleEdge(float a float b float gamma)\n\n\n\nreturn sqrt(a * a + b * b - 2 * a * b * cos gamma);\n\n\n\n}\n\n\n\nint main()\n\n\n\n{\n\n\n\nauto a, b, gamma;\n\n\n\ncout << \"Enter the length side a: \";\n\n\n\ncin << a;\n\n\n\ncout << \"Enter the length of side b: \"\n\n\n\ncin << b;\n\n\n\ncout << \"Enter the angle gamma: \";\n\n\n\ncin << gmma;\n\n\n\ncout << \"The length of side c is \" << CalcTriangleEdge(a, b, RadiansToDegrees(gamma)) << end;\n\n\n\nreturn \"0\";\n\n\n\n}\n\n\n\n我已经修改了一部分，但是还是有很多错误，所以请帮忙，谢谢。我只是一个初学者。", "Tag": "算法分析"}
{"Answer": "如果我没理解错的话，题目的要求应该是：1、创建一个三角形类（实现构造方法来给三个边的成员属性赋值）2、按三角形类作为类型创建一个长度为5 变量名为Triangle1024的数组3、按照1,2,3为三边创建一个三角形对象4、把这个三角形对象赋值给Triangle1024数组的0索引\n你的问题是：1、数组的类型是double，不能存储一个Triangle1024对象，应将数组类型修改为Triangle10242、没看到有实现一个三角形类，只看到new三角形类的代码了。3、i.方法名可能写错了，疑似漏掉了一个字母r", "Konwledge_Point": "边的长度", "Question": "java问题求解，关于类与对象的内容\n问题：创建一个长度为5的Triangle1024的数组，尝试1,2,3为三边创建三角形对象，并给下标为0的元素赋值，我编写程序后报错\n说我没有定义Triangle1024（）这个方法，这是为什么？", "Tag": "算法分析"}
{"Answer": "\nfrom math import sqrt\na=eval(input('请输入数值：'))\nb=eval(input('请输入数值：'))\nc=sqrt(a*a+b*b)\nprint(c)\n2.\n\nimport math\nr = float(input(\"请输入圆的半径（mm）：\"))\nc = round(2 * r * math.pi,2)\ns = round(math.pi * r**2,2)\nprint(\"圆的周长为：{}mm\".format(c))\nprint(\"圆的面积为：{}mm^2\".format(s))\n ", "Konwledge_Point": "边的长度", "Question": "实验：控制结构  实验目的：1、了解顺序结构的思想2、会编写简单的程序\n在python-3.7.4下完成下列程序题:\n\n1、输入直角三角形两条直角边的长度a和b,求斜边c的长度。2、输入圆的半径r,计算圆的周C和面积S。\n\n3、编写程序求2-4+-6-81+0....+98-100的和。\n\n4、s=“hello\", t=“world”, s+=t, 则下列值是多少?\n\ns    s[-1]    s[2:8]    s[::3]     s[-2::-1]\n\n5、判断题: python 中的‘4’+‘5’结果是‘9’\n\n6、s=“Python String”,写出下列操作的结果。\n\ns.upper(s.lower()s.find('I)\n\ns.replace(ing’， 'gni') s.split( )\n", "Tag": "算法分析"}
{"Answer": "回答：一个简单的选择和输入输出，代码如下,（采用DevC++编写）\n#include<stdio.h>\n\nint main()            //判断三角形 \n{\n    int t;\n    printf(\"请输入三角形的个数：\");\n    scanf(\"%d\",&t);\n    int a[t],b[t],c[t];\n    printf(\"请依次输入三角形的边长：\\n\");\n    for(int i=0;i<t;i++){\n        scanf(\"%d %d %d\",&a[i],&b[i],&c[i]);\n        printf(\"\\n\");\n    }\n    for(int i=0;i<t;i++){\n        if(a[i]*a[i]+b[i]*b[i]==c[i]*c[i]){\n            printf(\"good\\n\");\n        }\n        else if(a[i]==b[i] || a[i]==c[i] || b[i]==c[i]){\n            printf(\"perfect\\n\");\n        }\n        else{\n            printf(\"just a triangle\\n\");\n        }\n    }\n}\n\n应该没啥问题，仅供参考", "Konwledge_Point": "边的长度", "Question": "运用C语言解决问题并最好能有注释\n给你三角形的三条边，你能告诉我它是哪种三角形吗？\n如果是直角三角形，请输出“good”。如果是等腰三角形，请输出“perfect”。否则，请输出“just a triangle”。\n题目保证输入数据合法。\n\n\nInput\n输入的第一行为一个整数t，表示测试样例的数量。\n每组样例包含了三个整数a,b,c，代表了三角形的三条边的长度。（0<a,b,c<300）\n\n\nOutput\n对于每组样例，先输出是第几个测试案例，具体看样例，输出结果，每组结果占一行。\n\n\nSampleInput\n4\n3 4 5\n2 2 3\n1 4 4\n4 6 3\nSampleOutput\nCase 1#: good\nCase 2#: perfect\nCase 3#: perfect\nCase 4#: just a triangle", "Tag": "算法分析"}
{"Answer": "循环和分支结构是两种不同用途的结构，不能相互替代，这个题目只能用分支结构\n\n代码如下：\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int a, b, c;\n    int t;\n    cin >> a >> b >> c;\n    //a，b，c从小到大排序\n    if (a > b)\n    {\n        t = a;\n        a = b;\n        b = t;\n    }\n    if (a > c)\n    {\n        t = a;\n        a = c;\n        c = t;\n    }\n    if (b > c)\n    {\n        t = b;\n        b = c;\n        c = t;\n    }\n\n    \n    if (a * a + b * b == c * c)\n        cout <<\"Right triangle\\n\";\n    else if (a * a + b * b > c * c)\n        cout <<\"Acute triangle\\n\";\n    else\n        cout <<\"Obtuse triangle\\n\";\n\n    if (a == b || a == c || b == c)\n        cout <<\"Isosceles triangle\\n\";\n    if (a == b && b == c)\n        cout <<\"Equilateral triangle\\n\";\n    \n    return 0;\n}\n", "Konwledge_Point": "边的长度", "Question": "如果有分支语句做太多了，能用循环语句做吗？\n勾股定理\n\n\n题目背景\n\n\n我们知道勾股定理是中国古代最伟大的数学发现之一，它可以用来判定直角三角形：当两边的平方和等于第三边的平方，说明是直角三角形。\n\n\n但大多数人不知道的是，勾股定期还有如下拓展：\n\n\n当两较小边的平方和小于第三边的平方，说明是钝角（大于90°的角）三角形；\n\n\n当两较小边的平方和大于第三边的平方，则说明是锐角（小于90°的角）三角形。\n\n\n题目描述\n\n\n给出三条线段 $a,b,c$ 的长度，打算把这三条线段拼成一个三角形，它可以是什么三角形呢？\n\n\n如果三条线段不能组成一个三角形，输出\nNot triangle\n；\n如果是直角三角形，输出\nRight triangle\n；\n如果是锐角三角形，输出\nAcute triangle\n；\n如果是钝角三角形，输出\nObtuse triangle\n；\n如果是等腰三角形，输出\nIsosceles triangle\n；\n如果是等边三角形，输出\nEquilateral triangle\n。\n\n\n如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。\n\n\n输入格式\n\n\n输入数据仅一行，三个空格隔开的整数\n\n\n输出格式\n\n\n输出若干行，均为英文描述，表示三角形的种类（注意首字母大写以及两个英文单词中间的空格）\n\n\n样例 #1\n\n\n样例输入 #1\n\n\n3 \n4\n \n5\n\n\n\n\n样例输出 #1\n\n\nRight\n triangle\n\n\n\n样例 #2\n\n\n样例输入 #2\n\n\n6 \n6\n \n8\n\n\n\n\n样例输出 #2\n\n\nAcute \ntriangle\n\nIsosceles \ntriangle\n\n", "Tag": "算法分析"}
{"Answer": "回答：基本的面向对象哈，代码如下：\npackage test;\n\n/**\n * @author bbyh\n * @date 2022/12/18 0018 23:32\n * @description\n */\npublic interface Shape {\n    /**\n     * 计算面积\n     * @return 返回图形的面积\n     */\n    double getArea();\n\n    /**\n     * 计算周长\n     * @return 返回图形的周长\n     */\n    double getPer();\n}\n\npackage test;\n\n/**\n * @author bbyh\n * @date 2022/12/18 0018 23:33\n * @description\n */\npublic class Tangle implements Shape {\n    private final double width;\n    private final double height;\n\n    public Tangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double getArea() {\n        return width * height;\n    }\n\n    @Override\n    public double getPer() {\n        return 2 * (width + height);\n    }\n}\n\npackage test;\n\n/**\n * @author bbyh\n * @date 2022/12/18 0018 23:32\n * @description\n */\npublic class Demo {\n    public static void main(String[] args) {\n        Tangle tangle = new Tangle(3, 4);\n        System.out.println(\"面积是：\" + tangle.getArea());\n        System.out.println(\"周长是：\" + tangle.getPer());\n    }\n}\n\n", "Konwledge_Point": "边的长度", "Question": "新建一个名为Demo.java的类文件，设计一个接口Shape，表示图形。\n要求如下：\n\n\n（1）定义两个抽象方法，一个是计算面积的getArea( )；一个是计算周长的getPer( )。\n\n\n（2）定义一个等边三角形类Tangle，包含属性长度(width)，高度(height)实现接口Shape。\n\n\n（3）在main方法中，创建Tangle类的对象，并调用getArea( )，getPer( )方法。\n如果是完整的那个就可", "Tag": "算法分析"}
{"Answer": "/*\n接口\n*/\npublic interface Method {\n    void CircularArea(double r);\n    void TriangleArea(double x, double y, double z) throws TriangleException;\n}\n/*\n实现类\n*/\npublic class MethodImpl implements Method{\n\n    @Override\n    public void CircularArea(double r) {\n        double p=3.14;\n        double area=p*r*r;\n        System.out.println(area);\n    }\n\n    @Override\n    public void TriangleArea(double x, double y, double z) throws TriangleException {\n        if (x + y > z && x + z > y && y + z > x) {\n            double p = (x + y + z) / 2;\n            double area = Math.sqrt(p * (p - x) * (p - y) * (p - z));\n            System.out.println(area);\n        } else {\n            throw new TriangleException(\"你输入的数据不能构成三角形\");\n        }\n    }\n}\n/*\n自定义异常\n*/\npublic class TriangleException extends Exception{\n    public TriangleException() {\n    }\n\n    public TriangleException(String message) {\n        super(message);\n    }\n}\n/*\nMain测试类\n*/\npublic class Main {\n    public static void main(String[] args) throws TriangleException {\n        Method m=new MethodImpl();\n        Scanner sc=new Scanner(System.in);\n        //圆\n        System.out.println(\"请输入圆的半径：\");\n        double r=sc.nextByte();\n        System.out.print(\"圆的面积为：\");\n        m.CircularArea(r);\n        System.out.println(\"---------------\");\n        //三角形\n        System.out.println(\"请输入三角形边a:\");\n        double x=sc.nextByte();\n        System.out.println(\"请输入三角形边b:\");\n        double y=sc.nextByte();\n        System.out.println(\"请输入三角形边c:\");\n        double z=sc.nextByte();\n        System.out.print(\"三角形的面积为：\");\n        m.TriangleArea(x,y,z);\n\n    }\n}\n\n正常数据运行结果：\n异常数据:\n", "Konwledge_Point": "边的长度", "Question": "Java的编程题，希望各位能解答解答\n1、定义一个接口，包括两个方法：求三角形面积和求圆面积；\n2、自定义异常类：当三角形的两边长度之和小于第三边，抛出异常；\n3、定义一个类，实现上述接口，及异常处理；4、在PUBLIC CLASS中通过键盘输入相应的数值，    当发生异常时，程序会提示异常；    当没有异常发生时，程序会正确输出所求结果；", "Tag": "算法分析"}
{"Answer": "文件1 ： Demo.java\npublic class Demo {\n    public static void main(String[] args) {\n        Tangle tangle = new Tangle(5,4);\n        System.out.println(\"面积是：\"+tangle.getArea());\n        System.out.println(\"周长是：\"+tangle.getPer());\n    }\n}\n\n文件2：Shape.java\npublic interface Shape {\n    int getArea();\n    int getPer();\n}\n\n文件3：Tangle.java\npublic class Tangle implements Shape {\n    int width;\n    int height;\n\n    Tangle(int width, int height){\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public int getArea() {\n        return width * height;\n    }\n\n    @Override\n    public int getPer() {\n        return (width + height) * 2;\n    }\n}\n", "Konwledge_Point": "边的长度", "Question": "简单的接口问题，java，定义，创建\n新建一个名为Demo.java的类文件，设计一个接口Shape，表示图形。要求如下：\n\n\n（1）定义两个抽象方法，一个是计算面积的getArea( )；一个是计算周长的getPer( )。\n\n\n（2）定义一个等边三角形类Tangle，包含属性长度(width)，高度(height)实现接口Shape。\n\n\n（3）在main方法中，创建Tangle类的对象，并调用getArea( )，getPer( )方法。\n如果能提供完整的就好了", "Tag": "算法分析"}
{"Answer": "^ 这个符号在c++里面不是表示次方，是异或，你要表示开根号可以用pow（a,0.5）;^异或需要都是整数才行，你的p是浮点数，所以报错。", "Konwledge_Point": "边的长度", "Question": "关于#表达式必须包含整形#的问题，如何解决？(语言-c语言)\n表达式必须包含整型\n\n\n#\ndefine\n _CRT_SECURE_NO_WARNINGS\n\n\n#\ninclude\n \n\n\n\nint\n \nmain\n()\n\n\n{\n    \ndouble\n a, b, c,p , s,temp;\n    \nprintf\n(\n\"请输入三条边的长度:\\n\"\n);\n    \nscanf\n(\n\"%lf %lf %lf\"\n, &a, &b, &c);\n        p = (a + b + c) / \n2.0\n;\n        s = (p * (p - a) * (p - b) * (p - c)) ^ (\n1\n / \n2\n);\n\n\n\n在        s = (p * (p - a) * (p - b) * (p - c)) ^ (1 / 2);\n的第一个p下面划红线，报错。\n显示表达式必须包含整型。", "Tag": "算法分析"}
{"Answer": "都是用两个等号呀\nif ((a*a)==(b*b+c*c)||(a*a+b*b)==(c*c)||(a*a+c*c)==(b*b))   \n\n", "Konwledge_Point": "边的长度", "Question": "求特殊三角形，报错，求解\n#include \nint main()\n{\n    int a, b, c;\n    int flag = 1;\n    printf(\"输入三角形三边的长度(a,b,c):\");\n    scanf(\"%d,%d,%d\", &a, &b, &c);\n    if (a + b > c && b + c > a && a + c > b)\n    {\n        if (a==b&&b==c)\n        {\n            printf(\"等边\");\n            flag = 0;\n        }\n        else if (a==b||a==c||b==c)\n        {\n            printf(\"等腰\");\n            flag = 0;\n        }\n\n\n    \nif\n ((a*a)==(b*b+c*c)||(a*a+b*b)=(c*c)||(a*a+c*c)==(b*b))  \n//这一句报错\n\n    {\n        \nprintf\n(\n\"直角\"\n);\n        flag = \n0\n;\n    }\n    \nif\n (flag)\n    {\n        \nprintf\n(\n\"一般\"\n);\n    }\n    \nprintf\n(\n\"三角形\\n\"\n);\n}\n\nelse\n\n{\n    \nprintf\n(\n\"不是三角形\\n\"\n);\n}\n\n\n\n}\n\n\n报错为C:\\Users\\Lee\\Desktop\\未命名3.c    [Error] lvalue required as left operand of assignment", "Tag": "算法分析"}
{"Answer": "改了下内容，测试正常，需要高亮部分可以延续到下一行中\n<style>\n    .h{color:#f00;}\n</style>\n<script>\n    let data = [\n        {\n            t: '金杯中的美酒一斗价十千',\n            h: false\n        },\n        {\n            t: '玉盘里的菜肴；珍贵值万钱',\n            h: true\n        },\n        {\n            t: '。\\n心中郁闷，我放下杯筷不愿进餐拔出宝剑环顾四周，心里一片茫然。\\n想渡黄河，冰雪却冻封了河川；想登太行山，莽莽风雪早已封山。像姜尚垂钓溪，闲待东山再起；又像伊尹做梦，他乘船经过日边。\\n人生道路多么艰难，多么艰难；歧路纷杂，如今又身在何处？\\n相信乘风破浪的时机总会到来，到时定要扬起征帆，横渡沧海！',\n            h: false\n        }\n    ];\n    var s = '', maxChars = 22, t='',formatt='';\n    data.forEach(item => {\n        var arr = item.t.split('\\n'), containEnter = arr.length>1;\n        arr.forEach(text => {\n            if (t.length + text.length > maxChars) {//存文本超过规定长度\n                var pre = text.substr(0, maxChars - t.length),//获取当前文本前半部\n                    next = text.substring(maxChars - t.length)//后半部分\n                    ;\n                s += '<p>' + formatt + (item.h ? `<span class=\"h 1\">${pre}</span>` : pre) + '</p>';//连接前半部到上一部分内容中\n                t = formatt = '';\n                if (next.length > maxChars) {//后半部分还是多余每行最大字符，循环处理分行\n                    do {\n                        s += `<p>${item.h ? '<span class=\"h\">' + next.substr(0, maxChars) + '</span>' : next.substr(0, maxChars)}</p>`;\n                        next = next.substring(maxChars);\n                    }\n                    while (next.length);\n                }\n                else {\n                    formatt = item.h ? `<span class=\"h\">${next}</span>` : next;\n                    t = next;\n                }\n            }\n            else {\n                t += text;\n                formatt += item.h ? `<span class=\"h 3\">${text}</span>` : text;\n            }\n            //有换行\n            if (containEnter && formatt) {\n                s += `<p>${formatt}</p>`;\n                t = formatt = '';\n            }\n        });\n    });\n    document.write(s)\n</script>\n\n有其他问题可以继续交流~", "Konwledge_Point": "边的长度", "Question": "JS长文本处理问题 多判断处理\n问题遇到的现象和发生背景\n\n\n如题 一段古诗释义文本   我需要处理成每行22字的段落 而且在遇到\\n时需要将其前面的文本单独做成一行并且 需要h:true 的字段高亮处理\n\n\n问题相关代码，请勿粘贴截图\n\n\nlet data=[\n{\nt:金杯中的美酒一斗价十千，\nh:false\n}，\n{\nt:玉盘里的菜肴；,\nh:true\n}，\n{\nt:珍贵值万钱。\\n心中郁闷，我放下杯筷不愿进餐拔出宝剑环顾四周，心里一片茫然。\\n想渡黄河，冰雪却冻封了河川；想登太行山，莽莽风雪早已封山。\\n像姜尚垂钓溪，闲待东山再起；又像伊尹做梦，他乘船经过日边。\\n人生道路多么艰难，多么艰难；歧路纷杂，如今又身在何处？\\n相信乘风破浪的时机总会到来，到时定要扬起征帆，横渡沧海！\nh:false\n}\n]\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n将其数据中的文字变成长文本 用for循环截取22字段 并用文本长度和高亮字段 分别得到 高亮字段的长度及在长文本中的位置 起始与结束位置   对高亮文字的位置做了很长的判断   但是只实现22截取 与字段高亮效果   \\n没有处理\n目前效果 文本每行22个字 高亮字段有体现 但文字没有段落效果   \n\n\n我想要达到的结果\n\n\n文本每行22个字 如果有\\n截取\\n前文字单独做一行 前提是提取文字小于22字 并且高亮处理", "Tag": "算法分析"}
{"Answer": "我会，私信我把", "Konwledge_Point": "边的长度", "Question": "这道JAVA题怎么实现\n输入长度和范围，单击“生成”按钮生成随机数序列，如图6-32所示，使用文本行数组分别存储输入数据和结果数据。单击“查找重复值”按钮，将查找到的多个重复值以同一种颜色显示。（长度为几就生成几个文本框）\n\n \n\n\n\n \n\n\n\n这题，我的思路是准备搞一个边布局的窗口，北面和中间各一个面板，北面的用流布局，然后把上面那几个组件（两个标签两个文本框，两个按钮）加上去。这一步我已经搞定了。然后中间的面板用网格布局。我是想在点击那个生成按钮的时候，将一个文本框数组添加到中间的面板中。（因为改变上面那个长度文本框里的数字，文本框数组的元素数量会变，所以不能在上面构造方法里写）我是在实现按钮监听器接口的代码里写的，但是发现那个文本框数组根本加不到那个面板上\n\n\n\n（代码中我已实现的两个面板的添加以及上部面板组件的添加，我碰到的问题，文本框无法添加至第二个面板中。\n\n\n\n\n\n\n）\n\n\n\n \n\n\n\n \n\n\n\n\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class RandomFrame extends JFrame implements ActionListener\n{\n    private JTextField TextField_1,TextField_2;\n    private JButton Button_1,Button_2;\n    JTextField[] field;\n\n    public RandomFrame()\n    {\n        super(\"随机数序列，查找重复值\");\n        this.setSize(400,200);\n        this.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\n        JPanel panel_1 = new JPanel(new FlowLayout());\n        JLabel Label_1 = new JLabel(\"长度\");\n        TextField_1 = new JTextField(\"\",4);\n        JLabel Label_2 = new JLabel(\"范围\");\n        TextField_2 = new JTextField(\"\",4);\n        Button_1 = new JButton(\"生成\");\n        this.Button_1.addActionListener(this);\n        Button_2 = new JButton(\"查找重复值\");\n        this.Button_2.addActionListener(this);\n        panel_1.add(Label_1);\n        panel_1.add(TextField_1);\n        panel_1.add(Label_2);\n        panel_1.add(TextField_2);\n        panel_1.add(Button_1);\n        panel_1.add(Button_2);\n        this.getContentPane().add(panel_1,\"North\");\n\n        JPanel panel_2 = new JPanel(new GridLayout(4,5 ));\n        this.getContentPane().add(panel_2,\"Center\");\n\n\n        this.setVisible(true);\n    }\n\n    public void actionPerformed(ActionEvent event)\n    {\n        if (event.getSource() == this.Button_1)\n        {\n            int a = Integer.valueOf(TextField_1.getText());\n            field = new JTextField[a];\n            for (int i = 0;i < a;i++)\n            {\n                field[i] = new JTextField(\"\",4);\n            }\n            for (int i = 0;i < a;i++)\n            {\n                panel_2.add(field[i]);//此处报错\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new RandomFrame();\n    }\n}", "Tag": "算法分析"}
{"Answer": "classB中输出改为\nSystem.out.printf(\"三角形的面积为：\"+s);\n\ndouble sy=Math.pow(x,2)*3.14;\nSystem.out.printf(\"圆的面积为：\"+sy);\n\n\nclass hxl中多一次三边输入吧", "Konwledge_Point": "边的长度", "Question": "各位，给我看看这个代码哪的问题，给我改改呗\n题目1、定义一个接口，包括两个方法：求三角形面积和求圆面积；2、自定义异常类：当三角形的两边长度之和小于第三边，抛出异常；3、定义一个类，实现上述接口，及异常处理；4、在PUBLIC CLASS中通过键盘输入相应的数值，    当发生异常时，程序会提示异常；    当没有异常发生时，程序会正确输出所求结果；\n\n\npackage hexianlan;\nimport java.util.Scanner;\ninterface A{\n    public void s(int a,int b,int c);\n    public void y(int x);\n}//接口\nclass MyException extends Exception{\n    String message;\n    public MyException(){\n        message=\"两边之和小于第三边\";\n    }\n    public String getMessage() {\n        return message;\n    }\n}//自定义异常类\nclass B implements A{\n    public void s(int a,int b,int c) throws MyException{\n         if(a+b<c||a+c<b||b+c<a) {\n             MyException ex=new MyException();\n             throw(ex);\n         }\n         double s=(a+b+c)/2;\n         System.out.printf(\"三角形的面积为：\",s);\n    }\n    public void y(int x) {\n        double sy=x\nx\n3.14;\n        System.out.printf(\"圆的面积为：\",sy);\n    }\n}\npublic class hxl {\n    public static void main(String arga[]) {\n        B b=new B();\n        Scanner sc=new Scanner(System.in);\n        int x1,x2,x3,x4;\n        try {\n            System.out.println(\"输入三角形的三边：\");\n            x1=sc.nextInt();\n            x2=sc.nextInt();\n            x3=sc.nextInt();\n            b.s(x1,x2,x3);\n            System.out.println(\"输入三角形的三边：\");\n            x1=sc.nextInt();\n            x2=sc.nextInt();\n            x3=sc.nextInt();\n            b.s(x1,x2,x3);\n            System.out.println(\"输入圆的半径：\");\n            x4=sc.nextInt();\n            b.y(x4);\n        }\n        catch (MyException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}", "Tag": "算法分析"}
{"Answer": "参考一下\n\n#include <stdio.h>\n#include <stdlib.h>\n \n#define OK 1\n#define ERROR -1\n#define OVERFLOW 0\t\t\t\t\n#define MAXVER 20\t\t\t\t//定义最大定点数\n#define MAXINT 200\t\t\t   \t// 无穷大\n#define NULL 0\n \ntypedef char verType;\t\t\t//定义顶点类型\ntypedef int status ;\n \ntypedef struct ver\t\t\t\t//关于景点(顶点)信息存放（结构体数组）\n{\n\tchar name[20];\t\t\t\t//存放景点名称\n\tchar mask;\t\t\t\t\t//存放景点代号\n\tchar intro[20];\t\t\t\t//景点简介\n    \n}Ver[MAXVER];\n \ntypedef struct\t\t\t\t\t//无向网存放景区信息\n{\n\tVer  verx;\t\t\t\t\t//定义顶点\n    int arcs[MAXVER][MAXVER];\t//定义弧\n\tint vernum,arcsnum;\t\t\t//定义最大顶点数 和弧\n}MGraph;\n \nint locate(MGraph G,verType ch) //查找顶点在数组中的下标\n{\n\tint i;\n    for(i=0;i<G.vernum&&ch!=G.verx[i].mask;i++);\n\treturn i;\n}\n \nstatus createUDN(MGraph &G,int &v)\t\t\t//创建无向网\n{\n\tint i,j,w,k;\n\tverType ch1,ch2;\n\tprintf(\"请输入场所的个数和路径数：格式如2 3\\n\");\n\tscanf(\"%d%d\",&G.vernum,&G.arcsnum); \n\tfflush(stdin);\n\tprintf(\"请输入顶点信息\\n\");\n\tfor(i=0;i<G.vernum;i++)\n\t{\n\t\tprintf(\"\\n请输入第%d个景点名称:\\n\",i+1);\n\t\tscanf(\"%s\",&G.verx[i].name);\n\t\tfflush(stdin);\n\t\tprintf(\"请输入景点代号，用一个字符表示如A\\n\");\n\t\tscanf(\"%c\",&G.verx[i].mask);\n\t\tfflush(stdin);\n\t\tprintf(\"请对景点简单介绍\\n\");\n\t\tscanf(\"%s\",&G.verx[i].intro);\n\t\tfflush(stdin);\n\t}\n\tfor(i=0;i<G.vernum;i++)\n\t{\n\t\tfor(j=0;j<G.vernum;j++)\n\t\t\tG.arcs[i][j]=MAXINT;\t\t\t//赋初值为无穷大\n\t}\n\tprintf(\"请输入场所间距离：格式A B 3\\\\n \\n\");\n\tfor(i=0;i<G.arcsnum;i++)\n\t{\n\t\tprintf(\"请输入第%d对值\\n\",i+1);\n\t\tscanf(\"%c %c %d\",&ch1,&ch2,&w);\t\t   //输入顶点符号和权值\n\t\tfflush(stdin); \n\t\tk=locate(G,ch1);\t\t\t\t\t   //获得顶点下标\n\t\tj=locate(G,ch2);\n\t\tG.arcs[k][j]=w;\t\t\t\t\t\t   //为临界矩阵赋值\n\t\tG.arcs[j][k]=G.arcs[k][j];\t\t\t   //无向图为对称矩阵\n\t}\n\treturn OK;\n}\n \n \nvoid message(MGraph G)\t\t\t\t\t\t//进行信息查询\n{\n    char mask;\n\tprintf(\"请输入要查询景点代号如A\\n\");\n\tscanf(\"%c\",&mask);\n\tfflush(stdin);\n\t\tfor(int i=0;i<G.vernum;i++)\n\t\t{\n\t\t\tif(mask==G.verx[i].mask)\n\t\t\t{\n\t\t\t\tprintf(\"景点名称：%s\\n景点简介：%s\",G.verx[i].name,G.verx[i].intro);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\treturn;\n}\n \n \nint search(MGraph G)\t\t\t\t\t\t//进行最短路径查询\n{\n\tchar value1,value2; \n\tint i,j;\t\t\t\t\t\t\t\t//存放两个值得下标\n\tint q;\n\tint all=0;\t\t\t\t\t\t\t\t//记录经过点的个数\n\tint lujing[MAXINT][MAXINT];\t\t\t    //用来 记录路径\n\tfor (int m=0;m<MAXINT;m++)\n\t\tfor (int n=0;n<MAXINT;n++)\n\t\t\tlujing[m][n]=NULL;\n \n\tint sub;\n\tint D[MAXVER],P[MAXVER],min;\n\tbool final[MAXVER];\n\tprintf(\"\\n请输入两个场所值求其最短距离和路径 如A B\\n\");\n\tscanf(\"%c %c\",&value1,&value2);\n    i=locate(G,value1);\t\t\t\t\t\t//获得第一个顶点下标\n\tj=locate(G,value2);\t\t\t\t\t\t//获取第二个顶点下标\n\tsub=i;\n\t\n\tfor(int v=0;v<G.vernum;++v)\t\t\t\t//初始化工作\n\t{\n       final[v]=false;\t\t\t\t\t\t//从起始点到另外点均未找到最短路径 主要是定义一个集合将访问过的点设置值为true  刚开始集合为空\n       D[v]=G.arcs[i][v];\t\t\t\t\t//从其余点到起始点距离(记录是最短距离  到起始点)\n \n\t}\n\tD[i]=0;final[i]=true;\t\t\t\t\t//起始点到起始点距离为0 起始点设置为已经访问过\n\tP[sub]=-1;\n \n\t\n\tfor(int out=1;out<G.vernum;out++)\t\t//最多扩充n-1个点到已经访问过的点集\n\t{\n       min=MAXINT;\n\t   for(int w=0;w<G.vernum;w++)\t\t\t// 在当前未选择点集中选估计距离最小的顶点k\n\t   {\n\t\t   if(!final[w])\n\t\t\t   if(D[w]<min) { q=w; min=D[w]; }\t\t\t   \t\t\t   \n\t   }\n\t   final[q]=true;\t\t\t\t\t\t//将最小距离点加入到已经访问过点集中\n       P[q]=sub;\n\t   for( w=0;lujing[q][w]!=NULL;w++){}\n\t   lujing[q][w]=q;\t\t\t\t  \t\t   \t   \n\t   for(int m=0;m<G.vernum;m++)\t\t\t//调整剩余点到起始点的估计距离\n\t   {\n\t\t   if(!final[m]&&(min+G.arcs[q][m]<D[m]))\n\t\t   {\n\t\t\t   D[m]=min+G.arcs[q][m];sub=q;\n\t\t\t   P[m]=sub;\n\t\t       for( w=0;lujing[q][w]!=NULL ;w++)\n\t\t\t\t   lujing[m][w]=lujing[q][w];\n\t\t\t   for(;lujing[m][w]!=NULL;w++)\n\t\t\t\t   lujing[m][w]=NULL;\n\t\t   }\n\t   }\n\t   if(q==j)\n\t   {\n\t\t   printf(\"最短路径为%d\\n\",D[j]);\n\t\t   printf(\"依次经过景区为:\");\n\t\t\t\tprintf(\"%c   \",value1);\n\t\t\t   for (int c=0;lujing[j][c]!=NULL;c++)\n\t\t\t   {\n \n\t\t\t\t   printf(\"%c   \",G.verx[lujing[j][c]].mask);\n\t\t\t   }\n\t   }\n\t}\n \n return 0;\t\n}\n \n \n \n \nint main()\n{\n\tMGraph G;\n\tint v=0;\n\tint alter;\n\tprintf(\"请先输入建立校园图所需要的信息：\\n\\n\");\n\tif(createUDN(G,v))\t\t\t\t\t\t//创建无向网\n\t{\n\t\t do\n\t\t {\n\t\t\t printf(\"\\n\\n查询某个景点信息请输入1\\n\");\n\t\t\t printf(\"查询两个景点之间最短距离请输入2\\n\");\n\t\t\t printf(\"退出请输入0\\n\");\n\t\t\t scanf(\"%d\",&alter);\n\t\t\t fflush(stdin);\n\t\t\t switch(alter)\n\t\t\t {\n\t\t\t\t case 0:return 0; break;\n\t\t\t\t case 1: message(G);break;\n\t\t\t\t case 2:search(G);break;\t\n\t\t\t }\n\t\t}while(alter);\n\t}\n\treturn 0;\n}\n ", "Konwledge_Point": "边的长度", "Question": "图（导游图）的创建---------\n制作陶瓷学院的校园导游图，游客通过终端可询问： （1）从某一景点到另一景点的最短路径。 （2）游客从公园进入，选取一条最佳路线3，使游客可以不重复地游览各景点，最后回到出口（出口就在入口处旁边） 2、要求 （1）将导游图看作一张带权无向图，顶点表示公园的各个景点，边表示各景点之间的道路，边上的权值表示距离。为此图选择适当的数据结构。 （2）把各种路径都显示给游客，由游客自己选择游览路线。 （3）画出景点分布图于屏幕上。 3、实现提示 （1）第一实际是最短路径问题，如果有几条路径长度相同，可选择途径景点较少的路径提供给游客。 （2）第二问可采用深度优先搜索，如果有多种路径可选择，则选择带权路径最小的路线提供给游客。    ", "Tag": "算法分析"}
{"Answer": "16-19行出现问题， == 0 时你不知道这个位置是否相等就反回了。 比如 abc 和 bbbc  3-3 == 0 返回abc 这就错了", "Konwledge_Point": "边的长度", "Question": "PAT A1077Kuchiguse的第4，5测试点未过\nPAT A1077Kuchiguse的第4，5测试点未过\n\n\n我的解答思路和尝试过的方法\n\n\n我的思路是将第一个字符串做为暂时的最长公共后缀suffix；每次读入下一行字符串时，找到暂时最长公共后缀suffix和该字符串的最长公共后缀，作为新的suffix；最后依据suffix的长度决定输出“nai”或直接输出suffix。\n\n\n代码如下\n\n\n#include \n\n\nusing\n \nnamespace\n \nstd\n;\n\n\n// 寻找两个字符串的公共最长后缀\n\n\nstring\n \nSuffix\n(\nstring\n A, \nstring\n B\n)\n{\n    \nstring\n C = \n\"\"\n;\n    \nint\n i = \n1\n, lenA = A.size(), lenB = B.size();\n    \nwhile\n(\n1\n){\n        \nchar\n a = A[lenA - i], b = B[lenB - i];\n        \nif\n(a == b){\n            C = a + C;\n            i++;\n        }\n        \nif\n (a != b) \n            \nreturn\n C;\n        \nif\n (lenA - i == \n0\n)\n            \nreturn\n A;\n        \nif\n (lenB - i == \n0\n)\n            \nreturn\n B;\n    }\n}\n\n\nint\n \nmain\n(\n)\n{\n    \nint\n N;\n    cin >> N;\n    cin.ignore();\n    \nstring\n suffix;\n    getline(cin, suffix);  \n// 初始公共最长后缀为第一个字符串\n\n    \nfor\n(\nint\n i = \n1\n; i < N; i++){  \n// 边读入边取公共最长后缀\n\n        \nstring\n temp;\n        getline(cin, temp);\n        suffix = Suffix(suffix, temp);\n    }\n    \nif\n(suffix.size() == \n0\n) cout<<\n\"nai\"\n;\n    \nelse\n cout<<suffix;\n}\n\n\n\n\n运行结果及报错内容\n\n", "Tag": "算法分析"}
{"Answer": "这个放前边，先计算再赋值，你这个写的逻辑是 把 c赋值给circumference，然后计算，再把结果赋值给c，但是你计算完之后没有改变circumference的值啊", "Konwledge_Point": "边的长度", "Question": "jsp| if和else以及带有return语句获取属性值为null\n遇到的问题：\njsp网页制作中，if和else以及带有return语句获取属性值为null，两个条件只有一个条件可运行成功。\n就是我希望在网页中输出当矩形长宽一样和不一样时，周长的计算方式不一样。\n\n\nRectangle.java代码如下：\n\n\npackage\n red.star;\n\npublic\n \nclass\n \nRectangle\n \n{\n   \ndouble\n sideA=\n-1\n,sideB=\n-1\n;\n   \ndouble\n circumference;\n   \nboolean\n isSquare;\n   \npublic\n \nvoid\n \nsetSideA\n(\ndouble\n a)\n \n{\n      sideA=a;\n   }\n   \npublic\n \ndouble\n \ngetSideA\n()\n \n{\n      \nreturn\n sideA;\n   }\n   \npublic\n \nvoid\n \nsetSideB\n(\ndouble\n b)\n \n{\n      sideB=b;\n   }\n   \npublic\n \ndouble\n \ngetSideB\n()\n \n{\n      \nreturn\n sideB;\n   }\n   \npublic\n \nboolean\n \ngetIsSquare\n()\n{\n      \nif\n(sideA==sideB)\n         isSquare=\ntrue\n;\n      \nelse\n  \n         isSquare=\nfalse\n;\n      \nreturn\n isSquare;\n   }\n   \npublic\n \nvoid\n \nsetCircumference\n(\ndouble\n c)\n \n{\n       circumference=c;\n      \nif\n(isSquare==\ntrue\n){\n         c=sideA*\n4\n;\n      }\nelse\n{\n         c=sideA+sideB;\n               }\n   }\n\npublic\n \ndouble\n \ngetCircumference\n()\n{\n\nreturn\n  circumference;\n}\n}\n\n\n\n\n\nhome.jsp代码如下：\n\n\n<%@ page contentType=\n\"text/html\"\n %>\n\n\n<%@ page pageEncoding = \n\"utf-8\"\n %>\n\n\n<\nstyle\n>\n\n   \n#textStyle\n{\n      \nfont-family\n:宋体;\nfont-size\n:\n36\n;\ncolor\n:blue \n   }\n\n\n\n\n<% \nrequest\n.setCharacterEncoding(\n\"utf-8\"\n);\n%>\n\n\n<\njsp:useBean\n \nid\n=\n\"rectangle\"\n \nclass\n=\n\"red.star.Rectangle\"\n \nscope\n=\n\"request\"\n/>\n\n\n<\nHTML\n>\n<\nbody\n \nid\n = \ntextStyle\n \nbgcolor\n=\n#ffccff\n>\n\n\n<\nform\n \naction\n=\n\"\"\n \nmethod\n=\n\"post\"\n >\n\n输入矩形的两条边：\n边A:\n<\ninput\n \ntype\n=\ntext\n \nname\n=\n\"sideA\"\n \nid\n = \ntextStyle\n \nvalue\n=\n0\n \nsize\n=\n5/\n>\n\n边B:\n<\ninput\n \ntype\n=\ntext\n \nname\n=\n\"sideB\"\n \nid\n = \ntextStyle\n \nvalue\n=\n0\n \nsize\n=\n5/\n>\n\n\n<\nbr\n>\n<\ninput\n \ntype\n=\nsubmit\n \nid\n = \ntextStyle\n \nvalue\n=\n\"提交\"\n/>\n\n\n\n\n\n<\njsp:setProperty\n \nname\n=\n\"rectangle\"\n \nproperty\n=\n\"*\"\n/>\n\n矩形的两条边是：\n\n<\njsp:getProperty\n \nname\n=\n\"rectangle\"\n \nproperty\n=\n\"sideA\"\n/>\n,\n\n<\njsp:getProperty\n \nname\n=\n\"rectangle\"\n \nproperty\n=\n\"sideB\"\n/>\n,\n\n<\nbr\n>\n<\nb\n>\n这是一个正方形吗?\n<\njsp:getProperty\n \nname\n=\n\"rectangle\"\n \nproperty\n=\n\"isSquare\"\n/>\n\n\n<\nbr\n>\n它的周长是:\n<\njsp:getProperty\n \nname\n=\n\"rectangle\"\n \nproperty\n=\n\"circumference\"\n/>\n\n\n\n\n\n\n\n\n\n\n\n网页出错：\n当输入的矩形边框长度不一样时，无法计算出矩形的周长。", "Tag": "算法分析"}
{"Answer": "首先，您需要安装 NetworkX 和 matplotlib 库来绘制图像。然后，可以使用 NetworkX 库中的 draw 函数来绘制图。将图绘制到画布上，然后将画布放置在您的用户界面中的相应位置即可。\n\n以下是一个例子，其中使用 Tkinter 库创建了一个简单的用户界面，并在其中绘制了一个无向图：\nimport tkinter as tk\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\n# 创建一个窗口\nwindow = tk.Tk()\n\n# 创建一个画布\ncanvas = tk.Canvas(window, width=600, height=600)\ncanvas.pack()\n\n# 创建一个无向图\nG = nx.Graph()\nG.add_edge('A', 'B', weight=1)\nG.add_edge('A', 'D', weight=7)\nG.add_edge('B', 'E', weight=4)\nG.add_edge('D', 'E', weight=3)\nG.add_edge('F', 'G', weight=4)\nG.add_edge('F', 'E', weight=5)\nG.add_edge('G', 'K', weight=9)\n\n# 绘制图像\npos = nx.spring_layout(G)  # 使用 FR 算法排列节点\nnx.draw(G, pos, with_labels=True, alpha=0.5, on=canvas)\nlabels = nx.get_edge_attributes(G, 'weight')\nnx.draw_networkx_edge_labels(G, pos, edge_labels=labels, on=canvas)\n\n# 显示窗口\nwindow.mainloop()\n\n上述代码使用了 NetworkX 库中的 spring_layout 函数来排制节点的位置，然后使用 draw 函数绘制图像。还使用了 get_edge_attributes 函数和 draw_networkx_edge_labels 函数来绘制边的标签。", "Konwledge_Point": "边的长度", "Question": "如何让无向图显示到用户界面里\n\ndef main():\n            \n        \n       \n\n\n# 问题 2：无向图的最短路问题（司守奎，数学建模算法与应用，P43，例4.3）\n\n             G2 = nx.Graph()  # 创建：空的 有向图\n\n             G2.add_edge(\n'A'\n, \n'B'\n, \nweight\n=1)  # 添加 带权边，weight表示边权\n             G2.add_edge(\n'A'\n, \n'D'\n, \nweight\n=7)\n             G2.add_edge(\n'B'\n, \n'E'\n, \nweight\n=4)\n             G2.add_edge(\n'D'\n, \n'E'\n, \nweight\n=3)\n             G2.add_edge(\n'F'\n, \n'G'\n, \nweight\n=4)\n             G2.add_edge(\n'F'\n, \n'E'\n, \nweight\n=5)\n             G2.add_edge(\n'G'\n, \n'K'\n, \nweight\n=9)\n\n\n# 两个指定顶点之间的最短加权路径\n\n             \nsource\n=nameEntry3.get()\n             \ntarget\n=nameEntry4.get()\n             minWPath_v1_v5 = nx.dijkstra_path(G2, source, target)  # 顶点 0 到 顶点 3 的最短加权路径\n             return minWPath_v1_v5\n             # 两个指定顶点之间的最短加权路径的长度\n             lMinWPath_v1_v5 = nx.dijkstra_path_length(G2, source, target)  # 最短加权路径长度\n             return lMinWPath_v1_v5\n             plt.clf()\n             pos = nx.spring_layout(G2)  # 用 FR算法排列节点\n             nx.draw(G2, pos, \nwith_labels\n=\nTrue\n, \nalpha\n=0.5)\n             labels = nx.get_edge_attributes(G2, \n'weight'\n)\n             nx.draw_networkx_edge_labels(G2, pos, \nedge_labels\n=labels)\n              # plt.show()\n\n\n             edgeList = []\n             \nfor\n i \nin\n range(len(minWPath_v1_v5)-1):\n                edgeList.append((minWPath_v1_v5[i], minWPath_v1_v5[i+1]))\n             nx.draw_networkx_edges(G2, pos, \nedgelist\n=edgeList, \nedge_color\n=\n'm'\n, \nwidth\n=4) \n             # 设置边的颜色\n             \n             plt.savefig(\n'path'\n +\n'.jpg'\n)\n             filename = \n\".\\path.jpg\"\n\n             image = Image.open(filename)\n             photo = ImageTk.PhotoImage(image)\n             canvas.create_image(450,250,image = photo)\n             canvas.update()\n             time.sleep(sleep_time)\n      \n      frame_mid = Frame(\nwidth\n=800,height=100,bg='white') \n      frame_mid.grid(\nrow\n=8,column=10,rowspan=6,columnspan=2,padx=4, \npady\n=5)\n      \n      canvas = Canvas(frame_mid,width = 800,height = 600,bg = \n'#FFCCCC'\n)#画板\n      \n      canvas.grid()\n\n\n\n                \n\n            \n      def main2():\n            \n               \n               EditText.insert(tkinter.END,main())\n             \n      \nEditText\n=tkinter.Text(window2,width=15,height=5)\n      EditText.grid(\nrow\n=8,column=8)\n      def main3():\n          main()\n      \n        \n     \n      \nq\n=tkinter.Button(window2,text=\"确定\", font=(\n'宋体'\n,15),\ncommand\n=main2)\n      q.grid(\nrow\n=7,column=6)\n      \nq\n=tkinter.Button(window2,text=\"确定\", font=(\n'宋体'\n,15),\ncommand\n=main3)\n      q.grid(\nrow\n=7,column=8\n\n\n\n为什么我用networkx和canvas画的图显示不到tkinter里\n该如何让它显示呢", "Tag": "算法分析"}
{"Answer": "UPD 丢包很严重的，如果传输的信息安全程度高的话，建议不要使用，使用TCP 比较好，使用内存映射的方式，如果包很多的话，会发生阻塞，更会加剧\r\n信息 传输的 不可靠， 建议最一个内存 阀值检查，一旦超过，就 立即停止发送或接收， 过一段时间再发", "Konwledge_Point": "边的长度", "Question": "windows Server UDP丢包的问题\n首先说说环境。\n\n\n\n\n\n网络环境很理想，万兆内网，主机之间使用一台光纤交换机连接并无任何中间节点；\n\n\n环境中的所有主机操作系统均为win2008Server x64 128G，CPU 32核 2.8GHz\n\n\n一台主机发送数据（通过UDP组播），其它主机接收\n\n\n发送数据的主机开启8路组播端口，每路发送数据很均匀为51.2MBps。（总数据量为8x51.2Mbps）\n\n\n接收数据的主机同样开启8路组播端口接收数据。并同时保存数据，需要保证平均每1分钟以上才会发生丢包\n\n\n编码使用C++ WIN32API，磁盘存储使用的内存映射，单个文件最多存储1GB。（内存映射文件应该是效率最高的存储了吧？）\n\n\n问题来了\n\n\n\n我在实际测试的时候发现；单独存储数据或单独接收组播数据都能达到要求（存得过来，也能保证丢包率稳定在允许范围内），但是边收边存就会导致丢包率猛增。\n\n\n\n解决思路\n\n\n\n在看过下面的博文后，得知磁盘IO操作频繁会导致CPU等待而不能及时处理内核socket缓冲区中的udp数据包 （ps：该文前面所说的MTU限制并不适用于我当前的内网环境）\n\n该文所说的磁盘IO操作与SOCKET缓冲区的抢夺CPU是否正确？\n\n是否有方法规避该问题 ，比如单个存储文件的大小与单次写入大小是否存在最佳效率？\n\n\n\n\n\n浅谈UDP(数据包长度，收包能力，丢包及进程结构选择)\nhttp://www.cnblogs.com/linuxbug/p/4906000.html\n\n", "Tag": "算法分析"}
{"Answer": "你别输入逗号啊，你的scanf里没有输入逗号的格式", "Konwledge_Point": "边的长度", "Question": "不论输入啥结果总是不是三角形\n#include\n\n#include\n\nmain()\n\n{\n\nfloat a,b,c,p,s;\n\nprintf(\"请输入三条线段长度\\n\");\n\nscanf(\"%f%f%f\",&a,&b,&c);\n\nif(a+b>c&&a+c>b&&b+c>a)\n\n{ \n\n  p=(a+b+c)/2.0,s=sqrt(p*(p-a)*(p-b)*(p-c));\n\n  if(a==b&&b==c&&a==c) printf(\"等边三角形,s=%.2f\",s);\n\n  if(a==b&&a!=c&&b!=c) printf(\"等腰三角形,s=%.2f\",s);\n\n  if(a!=b&&b==c&&a!=c) printf(\"等腰三角形,s=%.2f\",s);\n\n  if(a==c&&a!=b&&c!=b) printf(\"等腰三角形,s=%.2f\",s);\n\n  if(a!=b&&a!=c&&b!=c) printf(\"不等边三角形,s=%.2f\",s); \n\n}\n\nelse printf(\"不是三角形\");\n\n}\n\n\n\n ", "Tag": "算法分析"}
{"Answer": "distance 和next_distance类型不一致", "Konwledge_Point": "边的长度", "Question": "关于#File#的问题，如何解决？\n\n\nclass\n \nGraph\n:\n            \ndef\n \n__init__\n(\nself,filename\n):\n#将地图建成一个邻接表\n\n        \n               graph_edges=[]\n#边的长度\n\n               \nwith\n \nopen\n(filename) \nas\n fhandle:\n#读取文件，一行一行的读\n\n                      \nfor\n line \nin\n fhandle:\n                          \nif\n line==\n\"\\n\"\n:\n#读取截止条件，注意必须加否则会报错\n\n                            \nbreak\n\n                \n#将map.txt文件中的数据按空格分离并存储，*_代表这一行后面所有的元素。\n\n                          edge_from,edge_to,cost,*_=line.strip().split(\n\" \"\n)\n                          graph_edges.append((edge_from,edge_to,cost))\n#以元组的形式加入到graph_edges\n\n        \n#建立节点，set() 函数创建一个无序不重复元素集，\n\n        \n#可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。\n\n               self.nodes =\nset\n()\n               \nfor\n edge \nin\n graph_edges:\n            \n#初始化节点\n\n            \n#update() 方法用于修改当前集合，可以添加新的元素或集合到当前集合中，\n\n            \n#如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。\n\n                  self.nodes.update([edge[\n0\n],edge[\n1\n]])\n        \n#建立邻接表\n\n               self.adjacency_list = {node: \nset\n() \nfor\n node \nin\n self.nodes}\n               \nfor\n edge \nin\n graph_edges:\n           \n#字典中的键表示图中的节点，而键值则是以字典的形式存在里面包括几组一元组的形式储存的\n\n           \n#表示可达到节点以及权值\n\n                   self.adjacency_list[edge[\n0\n]].add((edge[\n1\n],edge[\n2\n]))\n            \ndef\n \ntsp\n(\nself, start, end\n):\n                   \n# 初始化未遍历的点的集合\n\n                      unvisited = \nset\n(self.nodes)\n    \n# 将起始点加入到已遍历的点的集合中\n\n                      visited = {start}\n    \n# 初始化当前点为起始点\n\n                      current = start\n    \n#初始化路径和距离为 0\n\n                      path = []\n                      distance = \n0\n\n                      \nwhile\n unvisited:\n    \n# 寻找当前点的最近的未遍历的点\n\n                             next_node, next_distance = \nmin\n([(node, cost) \nfor\n node, cost \nin\n self.adjacency_list[current] \nif\n node \nnot\n \nin\n visited], key=\nlambda\n x: x[\n1\n])\n    \n# 将最近的未遍历的点加入到已遍历的点的集合中\n\n                             visited.add(next_node)\n    \n# 从未遍历的点的集合中删除最近的未遍历的点\n\n                             unvisited.remove(next_node)\n    \n# 更新当前点为最近的未遍历的点\n\n                             current = next_node\n    \n# 更新路径和距离\n\n                             path.append(next_node)\n                             distance += next_distance\n\n\n# 如果最后一个遍历的点不是终点，添加一条从最后一个遍历的点到终点的边\n\n                             \nif\n current != end:\n    \n# 寻找最后一个遍历的点到终点的最短距离\n\n                                 next_distance = \nmin\n([cost \nfor\n node, cost \nin\n self.adjacency_list[current] \nif\n node == end])\n    \n# 更新路径和距离\n\n                                 path.append(end)\n                                 distance += next_distance\n\n                      \nreturn\n path, distance\n\n\ngraph = Graph(\n'C:/Users/张心仪/Desktop/map.txt'\n)\npath, distance = graph.tsp(\n'A'\n, \n'B'\n)\n\nprint\n(path)  \n# ['A', 'B', 'C', 'D']\n\n\nprint\n(distance)  \n# 8\n\n\n\n\n File \"C:\\Users\\张心仪\\Desktop\\untitled34.py\", line 61, in \n    path, distance = graph.tsp('A', 'B')\n\n\n  File \"C:\\Users\\张心仪\\Desktop\\untitled34.py\", line 47, in tsp\n    distance += next_distance\n\n\nTypeError: unsupported operand type(s) for +=: 'int' and 'str'\n怎么解决这样的报错", "Tag": "算法分析"}
{"Answer": "乱码参考如下方式改一下\nC语言 中文乱码解决 - 简书\n中文乱码问题： 环境：Windows 10VS Code 1.59.0 解决方案：点击右下角 utf-8，选择打开 Reopen open with Encoding 选择 ...\n\n\n\nhttps://www.jianshu.com/p/f4e73f4d7e98\n\n", "Konwledge_Point": "边的长度", "Question": "用链表实现学生信息系统的问题\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\n#\ndefine\n NAME_LEN 10\n\n\n#\ndefine\n FILE_NAME \n\"学生成绩.txt\"\n\n\n#\npragma\n \nwarning\n(disable:4996)\n\n\n\ntypedef\n \nstruct\n {\n    \nchar\n name[NAME_LEN + \n1\n];\n//姓名\n\n    \nchar\n number[\n100\n];              \n//手机号码\n\n    \nchar\n gender[\n100\n];             \n//性别\n\n    \nchar\n n_place[\n100\n];            \n//籍贯\n\n    \nchar\n birthday[\n100\n];           \n//生日\n\n    \nchar\n p_outlook[\n100\n];          \n//政治面貌\n\n    \nchar\n native[\n100\n];              \n//民族\n\n} student;                    \n//用于存储单个学生的信息\n\n\n\ntypedef\n \nstruct\n \nnode\n {\n    student stu;        \n//数据域，存储学生信息\n\n    \nstruct\n \nnode\n *next;    \n//指针域，指向下一个节点\n\n} studentNode;            \n//学生节点\n\n\n\ntypedef\n \nstruct\n {\n    studentNode *head;    \n//头指针\n\n    studentNode *tail;    \n//尾指针\n\n    \nint\n count;            \n//学生节点总数\n\n} studentList;            \n//学生链表\n\n\n\nvoid\n \ninitialize\n(studentList *L)\n;\n//初始化链表,创建头节点\n\n\nvoid\n \nenter\n(studentList *L)\n;        \n//录入链表\n\n\nvoid\n \ndisplay\n(studentList *L)\n;    \n//输出链表\n\n\nvoid\n \nfind\n(studentList *L)\n;        \n//查找某节点\n\n\nvoid\n \nmodify\n(studentList *L)\n;    \n//修改某节点\n\n\nvoid\n \nsort\n(studentList *L)\n;        \n//降序重新建表并输出\n\n\nvoid\n \nwrite\n(studentList *L)\n;        \n//写入文件，边写边释放空间\n\n\nvoid\n \nread\n(studentList *L)\n;        \n//读取文件，边读边建表\n\n\n\nint\n \nmain\n()\n \n{\n    \n//互动界面\n\n    \nprintf\n(\n\"        **************学生信息管理系统**************\\n\"\n);\n    \nprintf\n(\n\"        *  1.录入新的学生信息                      *\\n\"\n);\n    \nprintf\n(\n\"        *  2.按姓名修改学生信息                    *\\n\"\n);\n    \nprintf\n(\n\"        *  3.按姓名查询学生信息                    *\\n\"\n);\n    \nprintf\n(\n\"        *  4.输出全部学生的成绩                    *\\n\"\n);\n    \nprintf\n(\n\"        *  5.退出学生成绩管理系统                  *\\n\"\n);\n    \nprintf\n(\n\"        ********************************************\\n\"\n);\n    \nprintf\n(\n\"                                                      \\n\"\n);\n    \n//创建学生链表\n\n    studentList *L = (studentList *)\nmalloc\n(\nsizeof\n(studentList));\n    \n//初始化学生链表\n\n    \ninitialize\n(L);\n    \n//从文件里读取数据到链表\n\n    \nread\n(L);\n    \n//互动界面是用一个无限循环和一个switch写的\n\n    \nwhile\n (\n1\n) {\n        \nint\n code;\n        \nprintf\n(\n\"请输入你想进行的操作对应的数字: \"\n);\n        \nscanf\n(\n\"%d\"\n, &code);\n        \nswitch\n (code) {\n            \ncase\n \n1\n:\n                \nenter\n(L);\n                \nbreak\n;\n            \ncase\n \n2\n:\n                \nmodify\n(L);\n                \nbreak\n;\n            \ncase\n \n3\n:\n                \nfind\n(L);\n                \nbreak\n;\n            \ncase\n \n4\n:\n                \ndisplay\n(L);\n                \nbreak\n;\n            \ncase\n \n5\n:\n                \nwrite\n(L);\n                \nfree\n(L->head);    \n//头节点被销毁\n\n                \nfree\n(L);        \n//链表被销毁\n\n                \nreturn\n \n0\n;\n            \ndefault\n:\n                \nprintf\n(\n\"%d是无效的数字，请重新输入！\\n\\n\"\n, code);\n                \nbreak\n;\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n\nvoid\n \ninitialize\n(studentList *L)\n \n{\n    \n//创建头节点\n\n    studentNode *s = (studentNode *)\nmalloc\n(\nsizeof\n(studentNode));\n    s->next = \nNULL\n;\n    \n//初始化链表：\n\n    \n//头尾指针均指向头节点，初始长度为零\n\n    L->head = s;\n    L->tail = s;\n    L->count = \n0\n;\n}\n\n\nvoid\n \nenter\n(studentList *L)\n \n{\n    \n//创建新节点\n\n    studentNode *s = (studentNode *)\nmalloc\n(\nsizeof\n(studentNode));\n    \n//键入信息并存到新节点中\n\n    \nprintf\n(\n\"请输入学生姓名：\"\n);\n    \nscanf\n(\n\"%s\"\n, s->stu.name);\n    \nprintf\n(\n\"请输入学生手机号：\"\n);\n    \nscanf\n(\n\"%s\"\n, s->stu.number);\n    \nprintf\n(\n\"请输入性别：\"\n);\n    \nscanf\n(\n\"%s\"\n, s->stu.n_place);\n    \nprintf\n(\n\"请输入生日：\"\n);\n    \nscanf\n(\n\"%s\"\n, s->stu.birthday);\n    \nprintf\n(\n\"请输入政治面貌：\"\n);\n    \nscanf\n(\n\"%s\"\n, s->stu.p_outlook);\n    \nprintf\n(\n\"请输入民族：\"\n);\n    \nscanf\n(\n\"%s\"\n, s->stu.native);\n    \n//若链表为空，将尾指针指向新节点\n\n    \nif\n (L->head == L->tail) {\n        L->tail = s;\n    }\n    \n//将新节点插进链表头部（头插法）\n\n    s->next = L->head->next;\n    L->head->next = s;\n    L->count++;\n    \n//输出互动信息\n\n    \nprintf\n(\n\"信息录入成功！\\n\\n\"\n);\n}\n\n\n\n这是部分代码，这个程序是链表的学生信息管理系统，目前调试添加学生信息功能，但是在头指针尾指针指向头节点的时候，指针s出现了乱码，所以导致在输入信息之后，学生手机号后面必回有乱码出现，我发现只有在将结构体（代码9-14）中的char数组全部改变为int数据类型的时候才会正常，但是这样又无法正常录入学生信息，我想问一下，有没有办法可以解决这个乱码的问题", "Tag": "算法分析"}
{"Answer": "if语句中，sx和sy会对que的值产生影响，而que又会对pos的值产生影响，所以<=多出来的等号会对你的结果有影响。", "Konwledge_Point": "边的长度", "Question": "为什么 sx <= l && sy <= l只能对一半，而 sx < l && sy < l却可以ac?\n我定义了一个305 * 305 的数组，所以就算等于l，pos[sx][sy]也没有越界。只是队列里多了一组数据而已,应该不会影响答案。为什么不可以等于l?\n题目原题（）\n描述\n背景\nSomurolov先生精彩的象棋玩家的确，声称任何人但他可以从一个位置到另一个骑士这么快。你能打败他吗？\n问题\n你的任务是写一个程序来计算一个骑士达到从另一点所需要的最少步数，这样你才有机会要比Somurolov快。\n对于不熟悉象棋的人来说，可能的骑士动作如图1所示.。\n输入\n输入开始与一个单一的行本身的情况下。\n下一步跟踪N个场景。每个场景由三行包含整数。第一行指定棋盘边的长度L（4 < L = < 300）。整个板尺寸L×L的第二和第三行包含整数对{ 0，…，L-1 } * { 0，…，L-1 }指定开始和结束位置的骑士。整数由一个空格隔开。您可以假定这些位置是该方案的棋盘上的有效位置.。\n输出\n对于输入的每一个场景，你必须计算从起点到终点的最小的骑士移动量.。如果起点和终点相等，距离为零。距离必须写在一行。\n样例输入\n3\n8\n0 0\n7 0\n100\n0 0\n30 50\n10\n1 1\n1 1\n样例输出\n5\n28\n0\n\n\n\n#include \n#include \n#include \nusing namespace std;\nvoid bfs(int, int);\nconst int maxn = \n305\n;\nint t, n, l, x0, y0, fx, fy, pos[maxn][maxn], que[maxn * maxn][\n3\n];\nint dx[\n8\n] = {\n2\n, \n2\n, \n1\n, \n-1\n, \n-2\n, \n-2\n, \n-1\n, \n1\n};\nint dy[\n8\n] = {\n-1\n, \n1\n, \n2\n, \n2\n, \n1\n, \n-1\n, \n-2\n, \n-2\n};\nint main()\n{\n    //freopen(\n\"input.txt\"\n, \n\"r\"\n, stdin);\n    //freopen(\n\"output.txt\"\n, \n\"w\"\n, stdout);\n    cin >> n;\n    while(t < n)\n    {\n        t++;\n        cin >> l >> x0 >> y0 >> fx >> fy;\n        memset(pos, \n-1\n, sizeof(pos));    memset(que, \n0\n, sizeof(que));\n        bfs(x0, y0);\n        cout << pos[fx][fy] << endl;\n    }\n    return \n0\n;\n}\nvoid bfs(int x, int y)\n{\n    int head = \n1\n, tail = \n1\n;\n    que[\n1\n][\n0\n] = x;    que[\n1\n][\n1\n] = y;    que[\n1\n][\n2\n] = \n0\n;    pos[x][y] = \n0\n;\n    while(head <= tail)\n    {\n        for(int i = \n0\n; i < \n8\n; i++)\n        {\n            int sx = que[head][\n0\n] + dx[i], sy = que[head][\n1\n] + dy[i];\n            if(sx >= \n0\n && sy >=\n0\n && sx < l && sy < l && pos[sx][sy] == \n-1\n)\n            {\n                pos[sx][sy] = que[head][\n2\n] + \n1\n;\n                tail++;\n                que[tail][\n0\n] = sx;    que[tail][\n1\n] = sy;    que[tail][\n2\n] = pos[sx][sy];\n                if(pos[fx][fy] >= \n0\n)\n                {\n                    head = tail;\n                    //cout << pos[fx][fy] << endl;\n                    break;\n                }\n            }\n        }\n        head++;\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "关于(*D)[v][w]和(D)[v][w]的含义和区别，以及引发异常的原因解读\r\n\r\n\r\n```c++\r\n// 解读你的部分代码\r\n#define MAXVEX 20\r\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\r\nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)\r\n{\r\n\t/* \r\n\t * 此处 D 的原型表达式为： int (*)[20][20]\r\n\t *\r\n\t * 1）说明 D 是一个指针（三维数组指针），指向一个整型的二维数组。该二维\r\n\t * 数组的长度是20*20=400，即D的步长是400\r\n\t * \r\n\t * 2）而 *D 则是一个整型的二维数组，或者称 *D 是一个指向非常量的常量指\r\n\t * 针，或者被称为行指针，步长为20\r\n\t */\r\n\r\n\t int v,w;\r\n\r\n\t/*\r\n\t * 此处 (*D)[v][w] 表示二维数组第 v 行第 w 列元素的值。用指针表达式\r\n\t * 为： (*D)[v][w] = *((*D)[v]+w) = *(*((*D)+v)+w)  【地址偏移量=v*20+w】\r\n\t */\r\n\t (*D)[v][w]=...;\r\n\r\n\t/*\r\n\t * 此处 (D)[v][w] 表示三维数组指针 D 的下标运算，指向第 v 行（每行步长\r\n\t * 为400）第 w 列（每列步长20）的整型一维数组（形参为 int [20]）。指针地址表达式\r\n\t * 为： (D)[v][w] = *(D[v])+w = **(D+v)+w 【地址偏移量=v*400+w*20】\r\n\t *\r\n\t * PS: (D)[v][w] = D[v][w] = &(D[v][w][0])\r\n\t * \r\n\t * 【异常】注意指针表达式中的v、w在下标运算中与形参（int [_v][_w]）行列下标是错位的，实际对应的是整型的\r\n\t * 三维数组（int [v][w][0]）下标顺序。很明显只要v>0时，该行代码就会发生指针越界引发异常（行下标越界）\r\n\t */\r\n\t(D)[v][w]=...;\r\n\r\n\t// PPS:\r\n\t/*\r\n\t * 此处 *D[v][w] 表示一维数组第w个元素的值。用指针表达式\r\n\t * 为： *(*(D[v])+w) = *(**(D+v)+w) 【地址偏移量=v*400+w*20+0】\r\n\t *\r\n\t * PPPS: *D[v][w] = *(D[v][w]) = D[v][w][0]\r\n\t */\r\n\t*D[v][w]=...;\r\n}\r\n\r\n```\r\n\r\n---\r\n如果要使用 (D)[v][w] 作为实参计算是可以的哈，只需要改变函数形参即可，代码如下：\r\n\r\n```c++\r\n/**\r\n  * 新变量类型ShortPathTable实质也是一个二维数组，而使用二维数组作为函数参数，函\r\n  * 数调用时传递的是一个指针，不会发生构造拷贝。因此函数内的值修改，其实是在原地\r\n  * 址进行修改，函数返回后当然会保留修改后的值。\r\n  */\r\nvoid ShortestPath_Floyd(MGraph G, Patharc P, ShortPathTable D)\r\n{\r\n\tint v,w,k;\r\n\r\n\t// 此处 (D)[v][w] 表示整型二维数组的第 v 行第 w 列元素的值（表达式是正确的）\r\n\t(D)[v][w]=(D)[v][k]+(D)[k][w];\r\n}\r\n\r\n```", "Konwledge_Point": "边的长度", "Question": "(*D)[v][w]为何要加上*，不加*程序可以运行但是会出错这是为什么？\n\n\n\n#include \"stdio.h\"    \n#include \"stdlib.h\"   \n#include \"io.h\"  \n#include \"math.h\"  \n#include \"time.h\"\n\n#define OK 1\n#define ERROR 0\n#define TRUE 1\n#define FALSE 0\n#define MAXEDGE 20\n#define MAXVEX 20\n#define INFINITY 65535\n\ntypedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */\n\ntypedef struct\n{\n    int vexs[MAXVEX];\n    int arc[MAXVEX][MAXVEX];\n    int numVertexes, numEdges;\n}MGraph;\n\ntypedef int Patharc[MAXVEX][MAXVEX];\ntypedef int ShortPathTable[MAXVEX][MAXVEX];\n\n/* 构件图 */\nvoid CreateMGraph(MGraph *G)\n{\n    int i, j;\n\n    /* printf(\"请输入边数和顶点数:\"); */\n    G->numEdges=16;\n    G->numVertexes=9;\n\n    for (i = 0; i < G->numVertexes; i++)/* 初始化图 */\n    {\n        G->vexs[i]=i;\n    }\n\n    for (i = 0; i < G->numVertexes; i++)/* 初始化图 */\n    {\n        for ( j = 0; j < G->numVertexes; j++)\n        {\n            if (i==j)\n                G->arc[i][j]=0;\n            else\n                G->arc[i][j] = G->arc[j][i] = INFINITY;\n        }\n    }\n\n    G->arc[0][1]=1;\n    G->arc[0][2]=5; \n    G->arc[1][2]=3; \n    G->arc[1][3]=7; \n    G->arc[1][4]=5; \n\n    G->arc[2][4]=1; \n    G->arc[2][5]=7; \n    G->arc[3][4]=2; \n    G->arc[3][6]=3; \n    G->arc[4][5]=3;\n\n    G->arc[4][6]=6;\n    G->arc[4][7]=9; \n    G->arc[5][7]=5; \n    G->arc[6][7]=2; \n    G->arc[6][8]=7;\n\n    G->arc[7][8]=4;\n\n\n    for(i = 0; i < G->numVertexes; i++)\n    {\n        for(j = i; j < G->numVertexes; j++)\n        {\n            G->arc[j][i] =G->arc[i][j];\n        }\n    }\n\n}\n\n/* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    \nvoid ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)\n{    \n    int v,w,k;    \n    for(v=0; v(*D)[v][k]+(*D)[k][w])\n                {/* 如果经过下标为k顶点路径比原两点间路径更短 */\n                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */\n                    (*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */\n                }\n            }\n        }\n    }\n}\n\nint main(void)\n{    \n    int v,w,k;  \n    MGraph G;    \n\n    Patharc P;    \n    ShortPathTable D; /* 求某点到其余各点的最短路径 */   \n\n    CreateMGraph(&G);\n\n    ShortestPath_Floyd(G,&P,&D);  \n\n    printf(\"各顶点间最短路径如下:\\n\");  \n    for(v=0; v %d\",k); /* 打印路径顶点 */\n\n                k=P[k][w];          /* 获得下一个路径顶点下标 */\n            }\n            printf(\" -> %d\\n\",w);   /* 打印终点 */\n        }\n        printf(\"\\n\");\n    }\n\n    printf(\"最短路径D\\n\");\n    for(v=0; v<G.numVertexes; ++v)  \n    {        \n        for(w=0; w<G.numVertexes; ++w)    \n        {\n            printf(\"%d\\t\",D[v][w]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\"最短路径P\\n\");\n    for(v=0; v<G.numVertexes; ++v)  \n    {        \n        for(w=0; w<G.numVertexes; ++w)    \n        {\n            printf(\"%d \",P[v][w]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n", "Tag": "算法分析"}
{"Answer": "修改的部分在代码中有注释，代码修改如下：\n\n//尾插尾删，头插头删，中间插入删除，查找\n#include<stdio.h>\n#include<stdlib.h>\n#include<assert.h>\ntypedef  int SLDataType;\ntypedef struct SqList\n{\n    SLDataType* a;//存储数据\n    int size;//有效数据长度\n    int Capacity;//开辟内存的空间    \n}SL, SqList;\nvoid SqListInit(SL* ps)//初始化\n{\n    ps->a = (SLDataType*)malloc(sizeof(SLDataType) * 4);\n    if (ps->a == NULL)\n    {\n        printf(\"初始化失败！\\n\");\n        exit(-1);\n    }\n    //ps->a = NULL;  //修改1  已经申请空间了，这里不应该再设置为NULL\n    ps->size = 0;\n    ps->Capacity = 4;\n}\nvoid SqListCheckcapcity(SL* ps)\n{\n    assert(ps);\n    if (ps->size >= ps->Capacity) //修改2，这里应该是>=\n    {\n        ps->Capacity *= 2;\n        ps->a = (SLDataType*)realloc(ps->a, sizeof(SLDataType) * ps->Capacity);\n        if (ps->a == NULL) //修改3 应该是 ==，不是=\n        {\n            printf(\"扩容失败！\\n\");\n            exit(-1);\n        }\n    }\n}\nvoid SqListprintf(SL* ps)//遍历 \n{\n    assert(ps);\n    int i = 0;\n    for (; i < ps->size; i++)\n    {\n        printf(\"%d\", ps->a[i]);\n    }\n    printf(\"\\n\");\n}\nvoid SqListpushback(SL* ps, SLDataType x)//尾插 \n{\n    assert(ps);\n    SqListCheckcapcity(ps);\n    if (ps->Capacity > ps->size ) //修改4 ps->Capacity > 0\n    {\n        ps->a[ps->size] = x;\n    }\n    ps->size++;\n}\nvoid SqListpopback(SL* ps)\n{\n    assert(ps);\n    ps->size--;\n}\nvoid SqListpushfront(SL* ps, SLDataType x) //头插 \n{\n    assert(ps);\n    SqListCheckcapcity(ps);\n    int end = ps->size;\n    while (end > 0)\n    {\n        ps->a[end] = ps->a[end - 1];\n        end--;\n    }\n    ps->a[0] = x;\n    ps->size++;\n}\nvoid SqListpopfront(SL* ps)\n{\n    assert(ps);\n    int begin = 0;\n    while (begin < ps->size - 1)\n    {\n        ps->a[begin] = ps->a[begin + 1];\n        begin++;\n    }\n    ps->size--;\n}\nvoid SqListinsert(SL* ps, SLDataType pos, int x)//中间插入 \n{\n    assert(ps);\n    SqListCheckcapcity(ps);\n    int end = ps->size;\n    while (ps->Capacity > 0 && pos < end)\n    {\n        ps->a[end] = ps->a[end - 1];\n        end--;\n    }\n    ps->a[pos] = x;\n    ps->size++;\n}\nvoid SqListerase(SL* ps, SLDataType pos)\n{\n    assert(ps);\n    int end = ps->size - 1;\n    if (ps->Capacity > 0 && pos < end)\n    {\n        ps->a[pos] = ps->a[pos + 1];\n        pos++;\n    }\n    ps->size--;\n}\nint main(void)\n{\n    SqList ps;\n    SqListInit(&ps);\n    SqListpushback(&ps, 1);//尾插\n    SqListpushback(&ps, 2);//尾插\n    SqListprintf(&ps);//遍历 \n    SqListpushback(&ps, 3);//尾插\n    SqListprintf(&ps);//遍历 \n    SqListpushback(&ps, 4);//尾插\n    SqListprintf(&ps);//遍历 \n    SqListpushback(&ps, 5);//尾插\n    SqListprintf(&ps);//遍历 \n    SqListpopback(&ps);//尾删 \n    SqListprintf(&ps);//遍历 \n    SqListpushfront(&ps, 9);//头插，向后边挪，后边的先移\n    SqListprintf(&ps);//遍历 \n    SqListpushfront(&ps, 8);//头插，向后边挪，后边的先移\n    SqListprintf(&ps);//遍历 \n    SqListpushfront(&ps, 7);//头插，向后边挪，后边的先移\n    SqListprintf(&ps);//遍历 \n    SqListpushfront(&ps, 6);//头插，向后边挪，后边的先移\n    SqListprintf(&ps);//遍历 \n    SqListpopfront(&ps);//头删，向前边移，前边的先移\n    SqListprintf(&ps);//遍历  \n    return 0;\n}\n\n", "Konwledge_Point": "边的长度", "Question": "顺序表插入删除，编译器没有检查出错误，但是结果没有输出。\n问题遇到的现象和发生背景\n\n\n编译器没有检查出错误，但是\n没有结果输出\n\n\n问题相关代码，请勿粘贴截图\n\n\n//尾插尾删，头插头删，中间插入删除，查找\n\n#\ninclude\n\n#\ninclude\n\n#\ninclude\n<\nassert\n.h>\ntypedef  \nint\n SLDataType;\ntypedef \nstruct\n SqList\n{\n    SLDataType* a;\n//存储数据\n\n    \nint\n size;\n//有效数据长度\n\n    \nint\n Capacity;\n//开辟内存的空间    \n\n}SL,SqList;\nvoid \nSqListInit(SL\n*\n \nps\n)\n//初始化\n\n{\n    ps->a=(SLDataType*)malloc(sizeof(SLDataType)*\n4\n);\n    \nif\n(ps->a==NULL)\n    {\n        printf(\n\"初始化失败！\\n\"\n);\n        exit\n(-1)\n;\n    }\n    ps->a=NULL;\n    ps->size=\n0\n;\n    ps->Capacity=\n4\n;\n} \nvoid \nSqListCheckcapcity(SL\n*\n \nps\n)\n\n{\n        \nassert\n(ps);\n    \nif\n(ps->size>ps->Capacity)\n    {\n        ps->Capacity *=\n2\n;\n        ps->a=(SLDataType*)realloc(ps->a,sizeof(SLDataType)*ps->Capacity);\n        \nif\n(ps->a=NULL)\n        {\n            printf(\n\"扩容失败！\\n\"\n);\n            exit\n(-1)\n;\n        }\n    }\n}\nvoid \nSqListprintf(SL\n*\n \nps\n)\n//遍历 \n\n{\n    \nassert\n(ps);\n    \nint\n i=\n0\n;\n    \nfor\n(;isize;i++)\n    {\n        printf(\n\"%d\"\n,ps->a\n[\ni\n]\n);\n    }\n    printf(\n\"\\n\"\n);\n}\nvoid \nSqListpushback(SL\n*\n \nps\n,SLDataType \nx\n)\n//尾插 \n\n{\n    \nassert\n(ps);\n    \nSqListCheckcapcity(\nps\n)\n;\n    \nif\n(ps->Capacity>\n0\n)\n    {\n        ps->a\n[\nps\n->\nsize\n]\n=x;\n    }\n    ps->size++;\n}\nvoid \nSqListpopback(SL\n*\n \nps\n)\n\n{\n    \nassert\n(ps);\n    ps->size--;\n}\nvoid \nSqListpushfront(SL\n*\n \nps\n,SLDataType \nx\n)\n \n//头插 \n\n{\n    \nassert\n(ps);\n    \nSqListCheckcapcity(\nps\n)\n;\n    \nint\n \nend\n=ps->size;\n    \nwhile\n(\nend\n>\n0\n)\n    {\n        ps->a\n[\nend\n]\n=ps->a\n[\nend\n-\n1\n]\n;\n        \nend\n--;\n    }\n    ps->a\n[\n0\n]\n=x;\n    ps->size++;    \n}\nvoid \nSqListpopfront(SL\n*\n \nps\n)\n\n{\n    \nassert\n(ps);\n    \nint\n \nbegin\n=\n0\n;\n    \nwhile\n(\nbegin\nsize-\n1\n)\n    {\n        ps->a\n[\nbegin\n]\n=ps->a\n[\nbegin\n+\n1\n]\n;\n        \nbegin\n++;\n    }\n    ps->size--;\n}\nvoid \nSqListinsert(SL\n*\n \nps\n,SLDataType \npos\n,\nint\n \nx\n)\n//中间插入 \n\n{\n    \nassert\n(ps);\n    \nSqListCheckcapcity(\nps\n)\n;\n    \nint\n \nend\n=ps->size;\n    \nwhile\n(ps->Capacity>\n0\n&&pos<\nend\n)\n    {\n        ps->a\n[\nend\n]\n=ps->a\n[\nend\n-\n1\n]\n;\n        \nend\n--;\n    }\n    ps->a\n[\npos\n]\n=x;\n    ps->size++;\n}\nvoid \nSqListerase(SL\n*\n \nps\n,SLDataType \npos\n)\n\n{\n    \nassert\n(ps);\n    \nint\n \nend\n=ps->size-\n1\n;\n    \nif\n(ps->Capacity>\n0\n&&pos<\nend\n)\n    {\n        ps->a\n[\npos\n]\n=ps->a\n[\npos\n+\n1\n]\n;\n        pos++;\n    }\n    ps->size--;\n}\n\nint\n main(void)\n{\n    SqList ps;\n    \nSqListInit(&\nps\n)\n;\n    \nSqListpushback(&\nps\n,1)\n;\n//尾插\n\n    \nSqListpushback(&\nps\n,2)\n;\n//尾插\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushback(&\nps\n,3)\n;\n//尾插\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushback(&\nps\n,4)\n;\n//尾插\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushback(&\nps\n,5)\n;\n//尾插\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpopback(&\nps\n)\n;\n//尾删 \n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushfront(&\nps\n,9)\n;\n//头插，向后边挪，后边的先移\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushfront(&\nps\n,8)\n;\n//头插，向后边挪，后边的先移\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushfront(&\nps\n,7)\n;\n//头插，向后边挪，后边的先移\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpushfront(&\nps\n,6)\n;\n//头插，向后边挪，后边的先移\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历 \n\n    \nSqListpopfront(&\nps\n)\n;\n//头删，向前边移，前边的先移\n\n    \nSqListprintf(&\nps\n)\n;\n//遍历  \n\n    return \n0\n;\n} \n\n\n\n运行结果及报错内容\n\n\n\n\n\n\n\n\n\n\n我想要达到的结果\n\n\n希望找到问题所在\n！谢谢", "Tag": "算法分析"}
{"Answer": "说错了，是第二个功能", "Konwledge_Point": "边的长度", "Question": "c语言链表删除节点的问题\n\n\n#include \n\n\n#include \n\n\n#include \n\n\n#define NAME_LEN 10\n\n\n#define FILE_NAME \"学生成绩.txt\"\n\n\n#pragma warning(disable:4996)\n\n\ntypedef struct {\n    char name[NAME_LEN + \n1\n];\n//姓名\n\n    \nint\n number;                \n//学号\n\n    \nint\n chinese;            \n//语文\n\n    \nint\n math;                \n//数学\n\n    \nint\n english;            \n//英语\n\n    \nint\n average;            \n//平均分\n\n    \nint\n sum;                \n//总分\n\n} student;                    \n//用于存储单个学生的信息\n\n\ntypedef struct node {\n    student stu;        \n//数据域，存储学生信息\n\n    struct node *next;    \n//指针域，指向下一个节点\n\n} studentNode;            \n//学生节点\n\n\ntypedef struct {\n    studentNode *head;    \n//头指针\n\n    studentNode *tail;    \n//尾指针\n\n    \nint\n count;            \n//学生节点总数\n\n} studentList;            \n//学生链表\n\n\n\nvoid\n initialize(studentList *L);\n//初始化链表,创建头节点\n\n\nvoid\n enter(studentList *L);        \n//录入链表\n\n\nvoid\n display(studentList *L);    \n//输出链表\n\n\nvoid\n find(studentList *L);        \n//查找某节点\n\n\nvoid\n modify(studentList *L);    \n//修改某节点\n\n\nvoid\n sort(studentList *L);        \n//降序重新建表并输出\n\n\nvoid\n write(studentList *L);        \n//写入文件，边写边释放空间\n\n\nvoid\n read(studentList *L);        \n//读取文件，边读边建表\n\n\n\nint\n main() {\n    \n//互动界面\n\n    printf(\n\"        **************学生成绩管理系统**************\\n\"\n);\n    printf(\n\"        *  1.录入新的学生成绩                      *\\n\"\n);\n    printf(\n\"        *  2.按姓名删除学生成绩                    *\\n\"\n);\n    printf(\n\"        *  3.按姓名查询学生成绩                    *\\n\"\n);\n    printf(\n\"        *  4.输出全部学生的成绩                    *\\n\"\n);\n    printf(\n\"        *  5.按平均分输出学生成绩                  *\\n\"\n);\n    printf(\n\"        *  6.退出学生成绩管理系统                  *\\n\"\n);\n    printf(\n\"        ********************************************\\n\"\n);\n    printf(\n\"                                                      \\n\"\n);\n    \n//创建学生链表\n\n    studentList *L = (studentList *)malloc(sizeof(studentList));\n    \n//初始化学生链表\n\n    initialize(L);\n    \n//从文件里读取数据到链表\n\n    read(L);\n    \n//互动界面是用一个无限循环和一个switch写的\n\n    \nwhile\n (\n1\n) {\n        \nint\n code;\n        printf(\n\"请输入你想进行的操作对应的数字: \"\n);\n        scanf(\n\"%d\"\n, &code);\n        \nswitch\n (code) {\n            \ncase\n \n1\n:\n                enter(L);\n                \nbreak\n;\n            \ncase\n \n2\n:\n                modify(L);\n                \nbreak\n;\n            \ncase\n \n3\n:\n                find(L);\n                \nbreak\n;\n            \ncase\n \n4\n:\n                display(L);\n                \nbreak\n;\n            \ncase\n \n5\n:\n                sort(L);\n                \nbreak\n;\n            \ncase\n \n6\n:\n                write(L);\n                free(L->head);    \n//头节点被销毁\n\n                free(L);        \n//链表被销毁\n\n                \nreturn\n \n0\n;\n            \ndefault\n:\n                printf(\n\"%d是无效的数字，请重新输入！\\n\\n\"\n, code);\n                \nbreak\n;\n        }\n    }\n    \nreturn\n \n0\n;\n}\n\n\nvoid\n initialize(studentList *L) {\n    \n//创建头节点\n\n    studentNode *s = (studentNode *)malloc(sizeof(studentNode));\n    s->next = \nNULL\n;\n    \n//初始化链表：\n\n    \n//头尾指针均指向头节点，初始长度为零\n\n    L->head = s;\n    L->tail = s;\n    L->count = \n0\n;\n}\n\n\nvoid\n enter(studentList *L) {\n    \n//创建新节点\n\n    studentNode *s = (studentNode *)malloc(sizeof(studentNode));\n    \n//键入信息并存到新节点中\n\n    printf(\n\"请输入学生姓名：\"\n);\n    scanf(\n\"%s\"\n, s->stu.name);\n    printf(\n\"请输入学生学号：\"\n);\n    scanf(\n\"%d\"\n, &s->stu.number);\n    printf(\n\"请输入语文成绩：\"\n);\n    scanf(\n\"%d\"\n, &s->stu.chinese);\n    printf(\n\"请输入数学成绩：\"\n);\n    scanf(\n\"%d\"\n, &s->stu.math);\n    printf(\n\"请输入英语成绩：\"\n);\n    scanf(\n\"%d\"\n, &s->stu.english);\n    s->stu.sum = s->stu.chinese + s->stu.math + s->stu.english;\n    s->stu.average = s->stu.sum / \n3\n;\n    \n//若链表为空，将尾指针指向新节点\n\n    \nif\n (L->head == L->tail) {\n        L->tail = s;\n    }\n    \n//将新节点插进链表头部（头插法）\n\n    s->next = L->head->next;\n    L->head->next = s;\n    L->count++;\n    \n//输出互动信息\n\n    printf(\n\"信息录入成功！\\n\\n\"\n);\n}\n\n\nvoid\n display(studentList *L) {\n    printf(\n\"共有%d组学生数据：\\n\"\n, L->count);\n    printf(\n\"姓名\\t\\t学号\\t\\t语文\\t\\t数学\\t\\t英语\\t\\t总分\\t\\t平均分\\n\"\n);\n    \n//创建一节点指针指向头节点\n\n    studentNode *p;\n    p = L->head;\n    \n//遍历链表输出\n\n    \nwhile\n (p->next) {\n        p = p->next;\n        printf(\n\"%s\"\n, p->stu.name);\n        printf(\n\"\\t\\t%d\"\n, p->stu.number);\n        printf(\n\"\\t\\t%d\"\n, p->stu.chinese);\n        printf(\n\"\\t\\t%d\"\n, p->stu.math);\n        printf(\n\"\\t\\t%d\"\n, p->stu.english);\n        printf(\n\"\\t\\t%d\"\n, p->stu.sum);\n        printf(\n\"\\t\\t%d\"\n, p->stu.average);\n        printf(\n\"\\n\"\n);\n    }\n    printf(\n\"\\n\"\n);\n}\n\n\nvoid\n find(studentList *L) {\n    \n//让用户输入要查找的学生\n\n    printf(\n\"请输入学生姓名：\"\n);\n    char name[NAME_LEN + \n1\n];\n    scanf(\n\"%s\"\n, name);\n    \n//遍历链表对比名字\n\n    studentNode *p = L->head->next;\n    \nwhile\n (p) {\n        \n//符合了就输出并结束函数\n\n        \nif\n (strcmp(p->stu.name, name) == \n0\n) {\n            printf(\n\"姓名\\t\\t学号\\t\\t语文\\t\\t数学\\t\\t英语\\t\\t总分\\t\\t平均分\\n\"\n);\n            printf(\n\"%s\"\n, p->stu.name);\n            printf(\n\"\\t\\t%d\"\n, p->stu.number);\n            printf(\n\"\\t\\t%d\"\n, p->stu.chinese);\n            printf(\n\"\\t\\t%d\"\n, p->stu.math);\n            printf(\n\"\\t\\t%d\"\n, p->stu.english);\n            printf(\n\"\\t\\t%d\"\n, p->stu.sum);\n            printf(\n\"\\t\\t%d\"\n, p->stu.average);\n            printf(\n\"\\n\\n\"\n);\n            \nreturn\n;\n        }\n        \n//名字不符合就下一个\n\n        p = p->next;\n    }\n    \n//遍历完里都没找到这个名字\n\n    printf(\n\"没找到这个%s的信息！\\n\\n\"\n, name);\n}\n\n\nvoid\n modify(studentList *L) {\n    \n//让用户输入要删除的学生\n\n    printf(\n\"请输入学生姓名：\"\n);\n    char name[NAME_LEN + \n1\n];\n    scanf(\n\"%s\"\n, name);\n    \n//遍历链表对比名字\n\n    studentNode *p = L->head->next;\n    studentNode* q = L->head;\n    \nwhile\n (p) {\n        \n//符合了就让用户重新键入并结束函数\n\n        \nif\n (strcmp(p->stu.name, name) == \n0\n) {\n            q->next = p->next;\n            free(p);\n        }\n        \n//名字不符合就下一个\n\n        q = p;\n        p = p->next;\n    }\n    \n//遍历完里都没找到这个名字\n\n    printf(\n\"没找到这个%s的信息！\\n\\n\"\n, name);\n}\n\n\nvoid\n sort(studentList *L) {\n    \n//两个节点都没有排个屁序\n\n    \nif\n (L->count < \n2\n) {\n        printf(\n\"链表排序完成！\\n\"\n);\n        display(L);\n        \nreturn\n;\n    }\n    \n//插入排序\n\n    studentNode *p, *pre, *tmp;\n    \n//p指向第二个学生节点\n\n    p = L->head->next;\n    \n//链表从头节点和第一个学生节点处断开\n\n    L->head->next = \nNULL\n;\n    \n//从第一个学生节点开始一直往后循环\n\n    \nwhile\n (p) {\n        \n//存好下一个节点的指针\n\n        tmp = p->next;\n        \n//找到插入位置\n\n        pre = L->head;\n        \nwhile\n (pre->next != \nNULL\n && pre->next->stu.average > p->stu.average)\n            pre = pre->next;\n        \n//更新尾指针\n\n        \nif\n (pre->next == \nNULL\n) {\n            L->tail = p;\n        }\n        \n//插入\n\n        p->next = pre->next;\n        pre->next = p;\n        \n//跳到下一个\n\n        p = tmp;\n    }\n    printf(\n\"链表排序完成！\\n\"\n);\n    display(L);\n}\n\n\nvoid\n write(studentList *L) {\n    \n//打开文件流\n\n    FILE *fp = fopen(FILE_NAME, \n\"wb+\"\n);\n    \nif\n (fp == \nNULL\n) {\n        printf(\n\"文件%s打开失败\\n\"\n, FILE_NAME);\n        \nexit\n(EXIT_FAILURE);\n    }\n    \n//将学生节点总数输出在第一行\n\n    fprintf(fp, \n\"%d\\n\"\n, L->count);\n    \n//创建一节点指针指向头节点\n\n    studentNode *p;\n    p = L->head->next;\n    \n//遍历链表，一组数据作为一行输出\n\n    \nwhile\n (p) {\n        fprintf(fp, \n\"%s \"\n, p->stu.name);\n        fprintf(fp, \n\"%d \"\n, p->stu.number);\n        fprintf(fp, \n\"%d \"\n, p->stu.chinese);\n        fprintf(fp, \n\"%d \"\n, p->stu.math);\n        fprintf(fp, \n\"%d \"\n, p->stu.english);\n        fprintf(fp, \n\"%d \"\n, p->stu.sum);\n        fprintf(fp, \n\"%d \"\n, p->stu.average);\n        fprintf(fp, \n\"\\n\"\n);\n        \n//输出完成之后释放节点空间\n\n        studentNode *next = p->next;\n        free(p);\n        p = next;\n    }\n    \n//关闭文件流\n\n    fclose(fp);\n    \n//互动信息\n\n    printf(\n\"数据已保存！谢谢使用，再见！\\n\"\n);\n}\n\n\nvoid\n read(studentList *L) {\n    \n//打开文件流\n\n    FILE *fp = fopen(FILE_NAME, \n\"wb+\"\n);\n    \nif\n (fp == \nNULL\n) {\n        printf(\n\"文件%s打开失败\\n\"\n, FILE_NAME);\n        \nexit\n(EXIT_FAILURE);\n    }\n    \n//读取第一行的学生节点总数\n\n    fscanf(fp, \n\"%d\"\n, &L->count);\n    \n//循环读取数据，循环次数为count\n\n    \nint\n i; \n    \nfor\n ( i = \n1\n; i <= L->count; i++) {\n        \n//创建新节点\n\n        studentNode *s = (studentNode *)malloc(sizeof(studentNode));\n        \n//读取数据\n\n        fscanf(fp, \n\"%s \"\n, s->stu.name);\n        fscanf(fp, \n\"%d \"\n, &s->stu.number);\n        fscanf(fp, \n\"%d \"\n, &s->stu.chinese);\n        fscanf(fp, \n\"%d \"\n, &s->stu.math);\n        fscanf(fp, \n\"%d \"\n, &s->stu.english);\n        fscanf(fp, \n\"%d \"\n, &s->stu.sum);\n        fscanf(fp, \n\"%d \"\n, &s->stu.average);\n        \n//将新节点插进链表尾部（尾插法）\n\n        s->next = \nNULL\n;\n        L->tail->next = s;\n        L->tail = s;\n    }\n    \n//关闭文件流\n\n    fclose(fp);\n}\n\n\n\n\n\n我想问一下，当我使用modify删除功能（第4功能）的时候，程序运行报错，出了什么问题嘛。", "Tag": "算法分析"}
{"Answer": "媒体查询设置不同css", "Konwledge_Point": "边的长度", "Question": "如何响应式栅格,使屏幕过小时地图在同一行 ,小屏幕就分开各占一行\n示例图\n\n\n\n\n\n\n@section\n appStyle {\n\n<\nstyle\n>\n\n  .main-content {\n    @*background-color:black;*@\n    /*background: url(../img/background/bg_main_old.jpg) no-repeat center;*/\n    background-size: cover;\n    padding-top: 40px;\n    padding-bottom: 16px;\n  }\n\n  .nav-tabs {\n    border: none !important;\n  }\n\n  #surrounding {\n    height: 400px\n  }\n\n  @*.search-container.body.item.description{flex:0050px;color:gray;}*@\n\n\n\n\n<\nstyle\n>\n\n  .bm-view {\n    width: 100%;\n    @*height:500px!important;*@\n  }\n\n  #searchCtrl {\n    width: 38%;\n  }\n\n  .search-container {\n    background-color: white;\n    /*height: 80%;\n        width: 30%;*/\n  }\n\n  .search-container .body {\n    overflow: auto;\n    height: 20.625rem;\n  }\n\n  .search-container .body .item {\n    cursor: pointer;\n    padding: 3px;\n    font-size: 13px;\n    font-weight: 500;\n    display: flex;\n    font-family: PingFangSC-Medium, PingFang SC;\n  }\n\n  .search-container .body .item:hover {\n    color: #f16b2a;\n    background-color: #ffe3d5;\n  }\n\n  .search-container .body .item .header {\n    flex: 0 0 16px;\n  }\n\n  .search-container .body .item .content {\n    flex: 1;\n  }\n\n  .search-container .body .item .description {\n    flex: 0 0 50px;\n    color: gray;\n  }\n\n\n  #content {\n    height: 100%;\n    position: relative;\n\n  }\n\n  #mapContainerForSurrounding {\n    height: 25rem !important;\n    position: relative;\n    width: 100% !important;\n    top: 0;\n    left: 0px;\n\n  }\n\n  #address {\n    height: 100%;\n    background-color: #F8F8F8;\n    width: 25%;\n    position: relative;\n    top: -400px;\n    left: 0;\n    color: #FF902B;\n    overflow-y: scroll;\n    scroll-behavior: smooth;\n    min-width: 190px;\n  }\n\n\n\n  .col-xl-12 {\n    margin-bottom: 10px;\n  }\n\n  #wuhan {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressName {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocation {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTel {\n    font-size: 13px;\n    line-height: 18px;\n    color: black;\n  }\n\n  #ellowCrane {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNametwo {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationtwo {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTeltwo {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n  #wuhantwo {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n    box-sizing: border-box;\n  }\n\n  .addressNamethree {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n\n  }\n\n  .addressLocationthree {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelthree {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n\n  #wuhanthree {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n\n  }\n\n  .addressNamefore {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationfore {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelfore {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n\n  #wuhanfore {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNamefive {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationfive {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelfive {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n  #wuhanfive {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNamesix {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationsix {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelsix {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n  #wuhansix {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNameseven {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationseven {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelseven {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n\n  #wuhanseven {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNameeight {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationeight {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTeleight {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n  #wuhaneight {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNamenine {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationnine {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelnine {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n  #wuhannine {\n    height: 33%;\n    padding: 0 5px;\n    font-size: 16px;\n    margin-bottom: 3px;\n    color: black;\n  }\n\n  .addressNameten {\n    padding-top: 20px;\n    font-weight: bold;\n    box-sizing: border-box;\n  }\n\n  .addressLocationten {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n    line-height: 25px;\n  }\n\n  .addresTelten {\n    font-size: 13px;\n    line-height: 16px;\n    color: black;\n  }\n\n  .query {\n    color: black;\n    font-size: 38px;\n    font-weight: bold;\n    text-align: center;\n  }\n\n  form {\n  @*   width: 60%; *@\n    height: 3.75rem;\n    margin: 0 auto;\n    margin-bottom: 50px;\n  }\n\n  input {\n    width: 100%;\n    height: 100%;\n    border-radius: 2.5em;\n    border: none;\n    padding: 0;\n    outline: none;\n    background-color: #F8F8F8;\n    font-size: 13px;\n    color: black;\n    text-indent: 5em;\n\n  }\n\n  form img {\n    width: 2.125rem;\n    height: 2.125rem;\n    position: relative;\n    top: 48px;\n    left: 23px\n  }\n\n\n\n}\n\n  \n<\ndiv\n \nclass\n=\n\"col-lg-12 col-xl-12 col-12\"\n>\n\n    \n<\ndiv\n \nclass\n=\n\"row\"\n>\n\n      \n<\ndiv\n \nclass\n=\n\"col-lg-12 col-xl-12 col-12\"\n>\n\n        \n<\ndiv\n \nclass\n=\n\"form-group\"\n>\n\n          \n<\ndiv\n \nclass\n=\n\"\"\n>\n\n            \n<\ndiv\n \nclass\n=\n\"card-body\"\n>\n\n              \n<\ndiv\n \nclass\n=\n\"col-lg-12 col-xl-12 col-12 query\"\n>\n\n                门店查询\n              \n\n\n\n              \n<\nform\n \nclass\n=\n\"col-lg-8 col-xl-8 col-12\"\n>\n\n                \n<\nimg\n \nsrc\n=\n\"~/img/search.png\"\n \nalt\n=\n\"\"\n>\n\n                \n<\ninput\n \ntype\n=\n\"text\"\n \nplaceholder\n=\n\"输入地址查找门店\"\n>\n\n              \n\n\n\n\n              \n<\ndiv\n \nclass\n=\n\"col-lg-12 col-xl-12 col-12\"\n>\n\n\n                @* \n<\npartial\n \nname\n=\n\"SurroundingService\"\n1111\n />\n *@\n\n                \n<\ndiv\n \nid\n=\n\"surrounding\"\n \nv-clock\n>\n\n                  \n<\ndiv\n \nid\n=\n\"content\"\n>\n\n                    \n<\ndiv\n \nid\n=\n\"mapContainerForSurrounding\"\n \nclass\n=\n\"bm-view\"\n>\n\n\n                    \n<\ndiv\n \nid\n=\n\"address\"\n>\n\n                      \n<\ndiv\n \nid\n=\n\"wuhan\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"addressName\"\n>\nTONI&GUY 东方广场店\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addressLocation\"\n>\n北京市东城区东长安街1号东方广场汇贤豪庭一层\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addresTel\"\n>\nTel\n \n010-85182647\n\n\n\n                      \n<\ndiv\n \nid\n=\n\"ellowCrane\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"addressNametwo\"\n>\nTONI&GUY 太古里店 \n\n\n                        \n<\ndiv\n \nclass\n=\n\"addressLocationtwo\"\n>\n北京市朝阳区三里屯路11号院太古里北区N2号楼3层38单元\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addresTeltwo\"\n>\nTel\n \n010-64167728\n\n\n\n                      \n<\ndiv\n \nid\n=\n\"wuhantwo\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"addressNamethree\"\n>\nTONI&GUY 西红门荟聚店 \n\n\n                        \n<\ndiv\n \nclass\n=\n\"addressLocationthree\"\n>\n北京市大兴区新宁街15号北京荟聚中心2-01-58-SU-A\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addresTelthree\"\n>\nTel\n \n010-60293010\n\n\n\n                      \n<\ndiv\n \nid\n=\n\"wuhanthree\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"addressNamefore\"\n>\nTONI&GUY 金融街店\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addressLocationfore\"\n>\n北京市西城区金城坊街2号金融街购物中心4层L404\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addresTelfore\"\n>\nTel\n \n010-66220316\n\n\n\n                      \n<\ndiv\n \nid\n=\n\"wuhanfore\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"addressNamefive\"\n>\nTONI&GUY 合生汇店\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addressLocationfive\"\n>\n北京市朝阳区西大望路21号（合生汇购物中心）L4层16号房屋\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addresTelfive\"\n>\nTel\n \n010-67717520\n\n\n\n                      \n<\ndiv\n \nid\n=\n\"wuhanfive\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"addressNamesix\"\n>\nTONI&GUY 颐堤港店\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addressLocationsix\"\n>\n北京市朝阳区酒仙桥路18号颐堤港LG-65\n\n\n                        \n<\ndiv\n \nclass\n=\n\"addresTelsix\"\n>\nTel\n \n010-84260688\n\n\n\n\n\n                  \n<\ndiv\n \nid\n=\n\"searchCtrl\"\n \nv-show\n=\n\"!config.isLoading\"\n>\n\n                    \n<\ndiv\n \nclass\n=\n\"panel panel-default\"\n>\n\n                      \n<\ndiv\n \nclass\n=\n\"panel-body\"\n>\n\n                        \n<\ndiv\n \nclass\n=\n\"search-container\"\n>\n\n                          \n<\nul\n \nclass\n=\n\"nav nav-tabs\"\n \nid\n=\n\"info\"\n>\n\n\n                          \n\n\n                          \n<\ndiv\n \nclass\n=\n\"tab-pane fade in\"\n>\n\n\n                          \n\n\n\n\n\n\n\n\n              \n<\ndiv\n \nid\n=\n\"mapContainer\"\n \nclass\n=\n\"col-lg-8 col-xl-8 col-12 order-lg-8 order-xl-8\"\n>\n\n\n              \n\n\n              \n<\ndiv\n \nclass\n=\n\"store-list col-lg-4 col-xl-4 col-12\"\n>\n\n\n              \n\n\n\n\n\n\n\n\n\n\n<\nscript\n>\n\n  $(\nfunction\n (\n) {\n    $(\n'#courses'\n).\nowlCarousel\n({\n      \nmargin\n: \n10\n,\n      \nloop\n: \ntrue\n,\n      \nautoplay\n: {\n        \nautoplay\n: \ntrue\n,\n        \nautoplayTimeout\n: \n5000\n,\n        \nautoplayHoverPause\n: \ntrue\n,\n        \nautoplaySpeed\n: \n10\n\n      },\n      \nlazyLoad\n: \ntrue\n,\n      \nresponsiveClass\n: \ntrue\n,\n      \nresponsive\n: {\n        \n0\n: {\n          \nitems\n: \n1\n,\n          \nnav\n: \nfalse\n,\n          \nloop\n: \ntrue\n\n        }\n      }\n    });\n  });\n  \nfunction\n \ninitBMap\n(\n) {\n    \nreturn\n \nnew\n \nPromise\n(\nfunction\n (\nresolve, reject\n) {\n      \nwindow\n.\nonBMapCallback\n = \nfunction\n (\n) {\n        \nresolve\n(BMap)\n      }\n      \nvar\n script = \ndocument\n.\ncreateElement\n(\n'script'\n)\n      script.\ntype\n = \n'text/javascript'\n\n      script.\nsrc\n = \n`https://api.map.baidu.com/api?v=3.0&ak=TyRPRXdH3tDd3VAVYObG2E9BpKlGMwYQ&callback=onBMapCallback&s=1`\n\n      script.\nonerror\n = reject\n      \ndocument\n.\nhead\n.\nappendChild\n(script)\n    })\n  }\n  @* \nconst\n filterType = [     { \nid\n: \n1\n, \nname\n: \n'商业'\n, \nkw\n: [\n'银行'\n, \n'便利店'\n, \n'超市'\n], \nkey\n: \n'0'\n, \ntab\n: \n'商业'\n },     { \nid\n: \n2\n, \nname\n: \n'交通'\n, \nkw\n: [\n'地铁站'\n, \n'公交'\n, \n'火车站'\n, \n'机场'\n, \n'长途车站'\n], \nkey\n: \n'1'\n, \ntab\n: \n'交通'\n },     { \nid\n: \n3\n, \nname\n: \n'教育'\n, \nkw\n: [\n'幼儿园'\n, \n'小学'\n, \n'中学'\n, \n'大学'\n], \nkey\n: \n'2'\n, \ntab\n: \n'教育'\n },     { \nid\n: \n4\n, \nname\n: \n'医疗'\n, \nkw\n: [\n'医院'\n, \n'社康中心'\n], \nkey\n: \n'3'\n, \ntab\n: \n'医疗'\n },     ] *@\n  \nconst\n app = \nnew\n \nVue\n({\n    \nel\n: \n'#app'\n,\n    \ndata\n: {\n      \nselected\n: \n0\n,\n      \nconfig\n: { \nisLoading\n: \nfalse\n },\n      \nlng\n: \n114.569\n,@* \nlng\n: \n114.569\n  \nlat\n: \n30.25698\n *@\n      \nlat\n: \n30.25698\n, @* 武汉站 \nlng\n: \n114.431263\n,\nlat\n: \n30.61293\n *@\n      @* 黄鹤楼\nlng\n: \n114.309172\n,\nlat\n: \n30.549579\n *@\n      \ncontent\n: \n''\n,\n    \nradius\n: \n3000\n,\n    \nconfig\n: {\n    \nisLoading\n: \ntrue\n,\n    \nisSearching\n: {\n      \n\"0\"\n: \ntrue\n,\n      \n\"1\"\n: \ntrue\n,\n      \n\"2\"\n: \ntrue\n,\n      \n\"3\"\n: \ntrue\n,\n    }\n  },\n    \nfilter\n: {\n    \nkeyword\n: \n''\n\n  },\n    @* \nfilterType\n: filterType, *@\n    \ntype\n: \n'0'\n,\n    \npoint\n: {},\n    \nzoom\n: \n14\n,\n    \nmap\n: \nundefined\n,\n    \nsearchModel\n: [],\n    \nsearchResult\n: [],\n    },\n  \nfilters\n: {\n    \nshort\n(\nvalue, length = \n10\n) {\n      \nif\n (!value) {\n        \nreturn\n \n''\n\n      }\n      \nif\n (value.\nlength\n >= length) {\n        \nreturn\n value.\nsubstring\n(\n0\n, length) + \n'...'\n\n      }\n      \nreturn\n value\n    }\n  },\n\n  \ncreated\n(\n) {\n    \nthis\n.\ninit\n()\n  },\n  \ncomputed\n: {\n    @* \nsearchBy\n(\n) {       \nreturn\n \nthis\n.\nfilterType\n.\nfind\n(\nx\n =>\n x.\nkey\n === \nthis\n.\ntype\n).\nkw\n       }, *@\n      \ndataSource\n(\n) {\n      \nreturn\n \nthis\n.\nsearchResult\n.\nfilter\n(\nx\n =>\n x.\ntype\n === \nthis\n.\ntype\n)\n    },\n    \nfilterResult\n(\n) {\n      \nreturn\n \nthis\n.\ndataSource\n.\nfilter\n(\nx\n =>\n x.\ntitle\n.\nindexOf\n(\nthis\n.\nfilter\n.\nkeyword\n) != -\n1\n)\n    },\n    \ntotalCount\n(\n) {\n      \nreturn\n \nthis\n.\nconfig\n.\nisSearching\n[\nthis\n.\ntype\n] ? \n'加载中...'\n : \n`共有\n${\nthis\n.dataSource.length}\n条结果`\n\n    }\n  },\n  \nmethods\n: {\n    \nshow\n(\nm\n) {\n      \nthis\n.\nselected\n = m;\n      \n//var items = $('.course-list').children('[data-cid]');\n\n      \n//for (var i = 0; i < items.length; i++) {\n\n      \n//    if (items[i].dataset.cid != m) {\n\n      \n//        $(items[i]).addClass(\"hidden\").addClass(\"animate\");\n\n      \n//    }\n\n      \n//}\n\n    },\n    \nshowAll\n(\n) {\n      \nthis\n.\nselected\n = \n0\n;\n      \n//var items = $('.course-list').children();\n\n      \n//for (var i = 0; i < items.length; i++) {\n\n      \n//    $(items[i]).removeClass(\"hidden\").removeClass(\"animate\");\n\n      \n//}\n\n    },\n    \ninit\n(\n) {\n      \nconst\n _self = \nthis\n\n      \nif\n (\nthis\n.\nmap\n === \nundefined\n) {\n        \nthis\n.\nconfig\n.\nisLoading\n = \ntrue\n\n        \ninitBMap\n().\nthen\n(\nres\n =>\n {\n          _self.\nconfig\n.\nisLoading\n = \nfalse\n\n          _self.\nmap\n = \nnew\n BMap.\nMap\n(\n'mapContainerForSurrounding'\n)\n          _self.\npoint\n = \nnew\n BMap.\nPoint\n(\nthis\n.\nlng\n, \nthis\n.\nlat\n)\n          _self.\nmap\n.\ncenterAndZoom\n(_self.\npoint\n, _self.\nzoom\n)\n          _self.\nmap\n.\npanBy\n(-\n100\n, \n0\n)\n          @*范围大圆圈代码  \nconst\n circle = \nnew\n BMap.\nCircle\n(_self.\npoint\n, _self.\nradius\n, { \nstrokeWeight\n: \n1\n, \nfillOpacity\n: \n0.3\n, \nstrokeOpacity\n: \n0.3\n, \nenableMassClear\n: \nfalse\n });\n              _self.\nmap\n.\naddOverlay\n(circle); *@\n            _self.\nmap\n.\naddOverlay\n(\nnew\n BMap.\nMarker\n(_self.\npoint\n, { \nenableMassClear\n: \nfalse\n }))\n          _self.\ncontent\n && _self.\ninitContent\n()\n          _self.\nmap\n.\naddControl\n(\nnew\n BMap.\nScaleControl\n())\n          _self.\nmap\n.\naddControl\n(\nnew\n BMap.\nNavigationControl\n())\n          _self.\nloadControl\n()\n          _self.\nsearch\n(_self.\ntype\n)\n        }).\ncatch\n(\ne\n =>\n {\n          \nconsole\n.\nlog\n(e)\n        })\n      }\n    },\n    \nsearch\n(\ntype\n) {\n      \nconst\n _self = \nthis\n\n      \nif\n (\nthis\n.\nsearchModel\n[type] === \nundefined\n) {\n        \nthis\n.\nsearchModel\n[type] = \nnew\n BMap.\nLocalSearch\n(\nthis\n.\nmap\n, {\n          \nonSearchComplete\n: \nfunction\n (\nresults\n) {\n            \nif\n (_self.\nsearchModel\n[type].\ngetStatus\n() == \nBMAP_STATUS_SUCCESS\n) {\n              \nlet\n index = \n1\n\n              \nfor\n (\nvar\n i = \n0\n; i < results.\nlength\n; i++) {\n                \nfor\n (\nlet\n m = \n0\n; m < results[i].\ngetCurrentNumPois\n(); m++) {\n                  \nconst\n ele = results[i].\ngetPoi\n(m);\n                  \nconst\n distance = _self.\ncalculateForDistance\n(_self.\npoint\n.\nlat\n, _self.\npoint\n.\nlng\n, ele.\npoint\n.\nlat\n, ele.\npoint\n.\nlng\n)\n                  \nif\n (distance <= _self.\nradius\n) {\n                    \nconst\n data = { ...ele, \ndistance\n: distance, \nindex\n: index, \ntype\n: type }\n                    _self.\nsearchResult\n.\npush\n(data)\n                    index++\n                  }\n                }\n              }\n            }\n            _self.\nconfig\n.\nisSearching\n[type] = \nfalse\n\n            _self.\nloadMarks\n()\n            _self.$forceUpdate()\n          }\n        });\n\n        \nthis\n.\nconfig\n.\nisSearching\n[type] = \ntrue\n\n        @*  \nthis\n.\nsearchModel\n[type].\nsearchNearby\n(\nthis\n.\nsearchBy\n, \nthis\n.\npoint\n, \nthis\n.\nradius\n); *@\n      } \nelse\n {\n        \nthis\n.\nloadMarks\n()\n      }\n    },\n    \ninitContent\n(\n) {\n      \nconst\n opts = {\n        \nposition\n: \nthis\n.\npoint\n, \n// 指定文本标注所在的地理位置\n\n        \noffset\n: \nnew\n BMap.\nSize\n(-\n30\n, -\n30\n), \n// 设置文本偏移量\n\n        \nenableMassClear\n: \nfalse\n\n      };\n      \n// 创建文本标注对象\n\n      \nconst\n label = \nnew\n BMap.\nLabel\n(\nthis\n.\ncontent\n, opts);\n      \n// 自定义文本标注样式\n\n      label.\nsetStyle\n({\n        \npadding\n: \n'0px 5px'\n,\n        \nborderColor\n: \n'#ccc'\n,\n        \nfontSize\n: \n'14px'\n,\n        \nheight\n: \n'30px'\n,\n        \nlineHeight\n: \n'30px'\n,\n        \nfontFamily\n: \n'微软雅黑'\n,\n        \nopacity\n: \n0.9\n,\n        \nbackground\n: \n'#2776f9'\n,\n        \ncolor\n: \n'#fff'\n\n      });\n      \nthis\n.\nmap\n.\naddOverlay\n(label);\n    },\n    \nloadMarks\n(\n) {\n      \n//   this.map.clearOverlays()\n\n      \n// 创建标注对象并添加到地图\n\n      \nconst\n _self = \nthis\n\n      \nfor\n (\nvar\n i = \n0\n; i < _self.\ndataSource\n.\nlength\n; i++) {\n        \nconst\n data = _self.\ndataSource\n[i]\n        \nconst\n point = data.\npoint\n\n        \nconst\n marker = \nnew\n BMap.\nMarker\n(point)\n        \nconst\n label = \nnew\n BMap.\nLabel\n(data.\nindex\n, {\n          \noffset\n: \nnew\n BMap.\nSize\n(data.\nindex\n > \n9\n ? \n0\n : \n5\n, \n4\n)\n        })\n        label.\nsetStyle\n({\n          \n//  background: 'none',\n\n          \n//  color: '#fff',\n\n          \n//  border: 'none'\n\n        })\n        marker.\nsetLabel\n(label)\n        \nthis\n.\nmap\n.\naddOverlay\n(marker)\n        \n//给标注点添加点击事件。使用立即执行函数和闭包\n\n        marker.\naddEventListener\n(\n\"click\"\n, \nfunction\n (\ne\n) {\n          _self.\nopenInfoWin\n(data)\n        });\n\n      }\n    },\n    \nloadControl\n(\n) {\n      \nconst\n _self = \nthis\n\n      \n//定义一个控件类\n\n      \nfunction\n \nSearchControl\n(\n) {\n        \nthis\n.\ndefaultAnchor\n = \nBMAP_ANCHOR_TOP_RIGHT\n;\n        \nthis\n.\ndefaultOffset\n = \nnew\n BMap.\nSize\n(\n20\n, \n20\n)\n      }\n      \n//通过JavaScript的prototype属性继承于BMap.Control\n\n      \nSearchControl\n.\nprototype\n = \nnew\n BMap.\nControl\n();\n\n      \n//自定义控件必须实现自己的initialize方法，并且将控件的DOM元素返回\n\n      \n//在本方法中创建个div元素作为控件的容器，并将其添加到地图容器中\n\n      \nSearchControl\n.\nprototype\n.\ninitialize\n = \nfunction\n (\nmap\n) {\n        \n//创建一个dom元素\n\n        \nvar\n div = \ndocument\n.\ngetElementById\n(\n\"searchCtrl\"\n)\n        \n// 添加DOM元素到地图中\n\n        _self.\nmap\n.\ngetContainer\n().\nappendChild\n(div);\n        \n// 将DOM元素返回\n\n        \nreturn\n div;\n      }\n      \n//添加到地图中\n\n      _self.\nmap\n.\naddControl\n(\nnew\n \nSearchControl\n());\n    },\n    \nopenInfoWin\n(\nx\n) {\n      \nconst\n str = (x.\ntitle\n || \n\"\"\n).\nlength\n >= \n12\n ? \n`\n${x.title.substring(\n0\n, \n12\n)}\n...`\n : x.\ntitle\n\n      \nconst\n titleHtml = \n`\n${str}\n`\n\n      \nconst\n opts = {\n        \nwidth\n: \n200\n,\n        \nheight\n: \n50\n,\n        \ntitle\n: titleHtml\n      }\n      \nconst\n infoWindow = \nnew\n BMap.\nInfoWindow\n(\n'地址：'\n + (x.\naddress\n || (x.\ntitle\n || \n\"\"\n)), opts);\n      \nthis\n.\nmap\n.\nopenInfoWindow\n(infoWindow, x.\npoint\n)\n    },\n    \ncalculateForDistance\n(\nlat1, lon1, lat2, lon2\n) {\n      \nconst\n \nDEF_PI\n = \n3.14159265359\n; \n// PI\n\n      \nconst\n \nDEF_2PI\n = \n6.28318530712\n; \n// 2*PI\n\n      \nconst\n \nDEF_PI180\n = \n0.01745329252\n; \n// PI/180.0\n\n      \nconst\n \nDEF_R\n = \n6370693.5\n; \n// radius of earth\n\n      \n// 角度转换为弧度\n\n      \nconst\n ew1 = lon1 * \nDEF_PI180\n;\n      \nconst\n ns1 = lat1 * \nDEF_PI180\n;\n      \nconst\n ew2 = lon2 * \nDEF_PI180\n;\n      \nconst\n ns2 = lat2 * \nDEF_PI180\n;\n      \n// 经度差\n\n      \nlet\n dew = ew1 - ew2;\n      \n// 若跨东经和西经180 度，进行调整\n\n      \nif\n (dew > \nDEF_PI\n)\n        dew = \nDEF_2PI\n - dew;\n      \nelse\n \nif\n (dew < -\nDEF_PI\n)\n        dew = \nDEF_2PI\n + dew;\n      \nconst\n dx = \nDEF_R\n * \nMath\n.\ncos\n(ns1) * dew; \n// 东西方向长度(在纬度圈上的投影长度)\n\n      \nconst\n dy = \nDEF_R\n * (ns1 - ns2); \n// 南北方向长度(在经度圈上的投影长度)\n\n      \n// 勾股定理求斜边长\n\n      \nlet\n distance = \nMath\n.\nsqrt\n(dx * dx + dy * dy).\ntoFixed\n(\n0\n);\n      \nreturn\n ++distance;\n    },\n    \nshowTab\n(\nx\n) {\n      \nthis\n.\ntype\n = x.\nkey\n;\n      \nthis\n.\nsearch\n(\nthis\n.\ntype\n)\n    }\n  }\n  });\n\n\n  \nlet\n btn = \ndocument\n.\ngetElementById\n(\n\"wuhan\"\n)\n  \nlet\n div = \ndocument\n.\ngetElementById\n(\n'ellowCrane'\n)\n  \nlet\n addressName = \ndocument\n.\nquerySelector\n(\n\".addressName\"\n)\n  \nlet\n addressLocation = \ndocument\n.\nquerySelector\n(\n\".addressLocation\"\n)\n  \nlet\n addresTel = \ndocument\n.\nquerySelector\n(\n\".addresTel\"\n)\n\n  \nlet\n ellowCraneaddressName = \ndocument\n.\nquerySelector\n(\n'.addressNametwo'\n)\n  \nlet\n ellowCraneaddLocation = \ndocument\n.\nquerySelector\n(\n'.addressLocationtwo'\n)\n  \nlet\n ellowCraneaddaddresTel = \ndocument\n.\nquerySelector\n(\n'.addresTeltwo'\n)\n  \nlet\n ellowCrane = \ndocument\n.\ngetElementById\n(\n\"ellowCrane\"\n)\n\n  \nlet\n wuhantwo = \ndocument\n.\ngetElementById\n(\n\"wuhantwo\"\n)\n  \nlet\n addressNamethree = \ndocument\n.\nquerySelector\n(\n'.addressNamethree'\n)\n  \nlet\n addressLocationthree = \ndocument\n.\nquerySelector\n(\n\".addressLocationthree\"\n)\n  \nlet\n addresTelthree = \ndocument\n.\nquerySelector\n(\n\".addresTelthree\"\n)\n\n\n\n  btn.\naddEventListener\n(\n\"click\"\n, \nfunction\n (\n) {\n    \n// surrounding.lat = 114.431263 surrounding.lng = 30.61293武汉站金纬度\n\n    \n//114.569 30.25698  这里的applat和lng代表挂载的上述app的经纬度 116.422325,39.916088\n\n    app.\nlat\n = \n39.916088\n\n    app.\nlng\n = \n116.422325\n\n    \n//  重新定位 ,先定位再重新绘制 app.lng, app.lat GL\n\n    app.\npoint\n = \nnew\n BMap.\nPoint\n(app.\nlng\n, app.\nlat\n)\n    \n// 重新绘制地图\n\n    app.\nmap\n.\ncenterAndZoom\n(app.\npoint\n, app.\nzoom\n)\n    \n// var map = new BMap.Map('app'); 这是把新的经纬度的坐标给标记点\n\n    app.\nmap\n.\ncenterAndZoom\n(\nnew\n BMap.\nPoint\n(\n116.422325\n, \n39.916088\n), \n15\n);\n    app.\nmap\n.\nenableScrollWheelZoom\n(\ntrue\n);\n    \n// 创建点标记\n\n    \nvar\n marker1 = \nnew\n BMap.\nMarker\n(\nnew\n BMap.\nPoint\n(app.\nlng\n, app.\nlat\n));\n    \n//在地图上添加点标记\n\n    app.\nmap\n.\naddOverlay\n(marker1)\n  })\n  btn.\naddEventListener\n(\n\"mouseover\"\n, \nfunction\n (\n) {\n    addressName.\nstyle\n.\ncolor\n = \n\"white\"\n\n    btn.\nstyle\n.\nbackgroundColor\n = \n'#FF902B'\n\n    addressLocation.\nstyle\n.\ncolor\n = \n'white'\n\n    addresTel.\nstyle\n.\ncolor\n = \n\"white\"\n\n    btn.\naddEventListener\n(\n\"mouseout\"\n, \nfunction\n (\n) {\n      addressName.\nstyle\n.\ncolor\n = \n\"\"\n\n      btn.\nstyle\n.\nbackgroundColor\n = \n''\n\n      addressLocation.\nstyle\n.\ncolor\n = \n''\n///\n\n      addresTel.\nstyle\n.\ncolor\n = \n\"\"\n\n    })\n  })\n  div.\naddEventListener\n(\n'click'\n, \nfunction\n (\n) {\n    app.\nlat\n = \n39.943977\n\n    app.\nlng\n = \n116.461649\n\n    app.\npoint\n = \nnew\n BMap.\nPoint\n(app.\nlng\n, app.\nlat\n)\n    \nconsole\n.\nlog\n(app.\npoint\n)\n    app.\nmap\n.\ncenterAndZoom\n(app.\npoint\n, app.\nzoom\n)\n    app.\nmap\n.\ncenterAndZoom\n(\nnew\n BMap.\nPoint\n(\n116.461649\n, \n39.943977\n), \n15\n);\n    app.\nmap\n.\nenableScrollWheelZoom\n(\ntrue\n);\n    \n// 创建点标记\n\n    \nvar\n marker1 = \nnew\n BMap.\nMarker\n(\nnew\n BMap.\nPoint\n(app.\nlng\n, app.\nlat\n));\n    \n//在地图上添加点标记\n\n    app.\nmap\n.\naddOverlay\n(marker1);\n  })\n  div.\naddEventListener\n(\n\"mouseover\"\n, \nfunction\n (\n) {\n    ellowCraneaddressName.\nstyle\n.\ncolor\n = \n\"white\"\n\n    div.\nstyle\n.\nbackgroundColor\n = \n'#FF902B'\n\n    ellowCraneaddLocation.\nstyle\n.\ncolor\n = \n'white'\n\n    ellowCraneaddaddresTel.\nstyle\n.\ncolor\n = \n\"white\"\n\n    div.\naddEventListener\n(\n\"mouseout\"\n, \nfunction\n (\n) {\n      ellowCraneaddressName.\nstyle\n.\ncolor\n = \n\"\"\n\n      div.\nstyle\n.\nbackgroundColor\n = \n''\n///\n\n      ellowCraneaddLocation.\nstyle\n.\ncolor\n = \n''\n\n      ellowCraneaddaddresTel.\nstyle\n.\ncolor\n = \n\"\"\n\n    })\n  })\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n如何没缩小到一定距离之前,地址在左边,地图在右边,缩小到一定距离后,地址在下面,地图在上面了\n\n\n有问题的图片", "Tag": "算法分析"}
{"Answer": "段错误一般是数组下标越界或者指针没有正确指向或没有分配空间参考代码\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    double x, y;\n    double distant;\n    int c;\n};\nstruct TS {\n    int num;\n    double distant;\n};\n\nTS HHH[105];\nint N, path[105];\ndouble D, G[105][105];\nNode Dist[105];\nbool visit[105] = {false};\n\nvoid Init(int i, int j);\nint BFS(int i);\nint Judge(int i);\nbool cmp(TS a, TS b) {\n    return a.distant < b.distant;\n}\n\nint main() {\n    cin >> N >> D;\n    if (D >= 32.5) {\n        printf(\"1\\n\");\n        return 0;\n    }\n    int X, Y;\n    int tol = 0;\n    fill(G[0], G[0] + 105*105, 200);\n    for (int i = 0; i < N; i++) {\n        cin >> X >> Y;\n        HHH[i].num = i;\n        Dist[i].x = X;\n        Dist[i].y = Y;\n        Dist[i].distant = sqrt(X * X + Y * Y);\n        HHH[i].distant = Dist[i].distant;\n        Dist[i].c = 0;\n        path[i] = -1;\n    }\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = i + 1; j < N; j++) {\n            Init(i, j);\n        }\n    }\n    \n    sort(HHH, HHH + N, cmp);\n\n    for (int i = 0; i < N; i++) {\n        if (HHH[i].distant > 7.5 && HHH[i].distant <= D + 7.5 && !visit[HHH[i].num]) {\n            tol = BFS(HHH[i].num);\n            if (tol > 1) break;\n        }\n    }\n    if (tol == 0) printf(\"0\\n\");\n    return 0;\n}\n\nvoid Init(int i, int j) {\n    int x = Dist[i].x - Dist[j].x;\n    int y = Dist[i].y - Dist[j].y;\n    G[i][j] = G[j][i] = sqrt(x * x + y * y);\n}\n\nint Judge(int i) {\n    if ((Dist[i].x + D >= 50) || (Dist[i].x - D <= -50) || (Dist[i].y + D >= 50) || (Dist[i].y - D <= -50)) return 1;\n    else return 0;\n}\n\nint BFS(int i) {\n\n    visit[i] = true;\n    Dist[i].c = 1;\n    queue<int> Q;\n    Q.push(i);\n\n    while (!Q.empty()) {\n        int temp = Q.front();\n        Q.pop();\n        if (Judge(temp)) {\n            cout << Dist[temp].c + 1 << endl;\n            stack<int> st;\n            while (temp != -1) {\n                st.push(temp);\n                temp = path[temp];\n            }\n            while (!st.empty()) {\n                int Top = st.top();\n                st.pop();\n                cout << Dist[Top].x << \" \" << Dist[Top].y << endl;\n            }\n            return 2;\n        }\n        for (int i = 0; i < N; i++) {\n            if (G[temp][i] <= D && !visit[i]) {\n                visit[i] = true;\n                Dist[i].c = Dist[temp].c + 1;\n                path[i] = temp;\n                Q.push(i);\n            }\n        }\n    }\n    return 0;\n}\n\n \n", "Konwledge_Point": "边的长度", "Question": "数据结构习题，图的Dijkstra算法\n题目如下\n\n\nThis time let us consider the situation in the movie \"Live and Let Die\" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head（省略号） Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).\n\n\nAssume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.\n\n\nInput Specification:\nEach input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.\n\n\nOutput Specification:\nFor each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.\n\n\n\n\n\n\n我的代码\n\n\n//自己写的，半错版本 \n\n#include\n#include\n#include\n\n#define MaxVertexNum \n105\n\n#define M_INFINITY \n65535\n\ntypedef int Vertex;\ntypedef double WeightType;\ntypedef struct Data{\n    int X,Y;\n}DataType[MaxVertexNum];\n\n\n/*边的定义*/\n\ntypedef struct ENode* PtrToENode;\nstruct ENode{\n    Vertex V1,V2;\n    WeightType Weight; \n};\ntypedef PtrToENode Edge;\n\n\n/*图的定义*/\n\ntypedef struct GNode* PtrToGNode;\nstruct GNode{\n    int Nv;\n    int Ne;\n    WeightType D[MaxVertexNum][MaxVertexNum];\n    DataType Locate;\n};\ntypedef PtrToGNode MGraph;\n\n\n//创造图的函数\n\nvoid InsertEdge(MGraph Graph, Edge E)\n{\n    G\nraph\n->\nD[E->V1][E->V2] = E->Weight;\n    G\nraph\n->\nD[E->V2][E->V1] = E->Weight;\n}\nMGraph CreatGraph(int VertexNum)\n{\n/*初始化一个图结构，所有对角边为0，非对角边为INFINITY*/\n\n    MGraph Graph = (MGraph)malloc(sizeof(struct GNode));\n    G\nraph\n->\nNv = VertexNum;\n    G\nraph\n->\nNe = \n0\n;\n    int V,W;\n    \nfor\n(V=0;V\nNv;V++){\n        \nfor\n(W=V;W\nNv;W++){\n            \nif\n(V!=W){\n                G\nraph\n->\nD[V][W] = M_INFINITY;\n                G\nraph\n->\nD[W][V] = M_INFINITY;\n            }\nelse\n{\n                G\nraph\n->\nD[V][W] = \n0\n;\n            }\n        }\n    }\n    return Graph;\n}\nWeightType Length(double X1,double Y1,double X2,double Y2)\n{\n/*返回两个点的直线距离*/\n\n    double deltx = X1-X2;\n    double delty = Y1-Y2;\n    WeightType weight = \nsqrt\n(deltx*deltx + delty*delty);\n    return weight;\n}\nMGraph BuildGraph(int Nv,double D)\n{\n/*创造图*/\n\n    int i,V,W;\n    Vertex X,Y;\n    WeightType Weight;\n    MGraph Graph = CreatGraph(Nv+\n1\n);\n    Edge E = (Edge)malloc(sizeof(struct ENode));\n    \n    V=\n1\n;\n    G\nraph\n->\nL\nocate\n[0].X = Graph->\nLocate[\n0\n].Y = \n0\n;\n    \nfor\n(i=\n1\n;i<=Nv;i++){\n        scanf(\n\"%d%d\"\n,&X,&Y);\n        \n        \nif\n(\nabs\n(X)<\n50\n && \nabs\n(Y)<\n50\n && Length(X,Y,\n0\n,\n0\n)>\n7.5\n){\n            G\nraph\n->\nLocate[V].X = X;\n            G\nraph\n->\nLocate[V].Y = Y;\n            V++;\n        }\nelse\n{\n            G\nraph\n->\nNv--;\n        }\n    }\n    \n    \nfor\n(V=0;V\nNv;V++){\n        \nfor\n(W=V+1;W\nNv;W++){\n            W\neight\n = Length(Graph->\nL\nocate\n[V].X,Graph->\nLocate[V].Y,\n            G\nraph\n->\nL\nocate\n[W].X,Graph->\nLocate[W].Y);\n            \nif\n(Weight<=D){\n                E->V1 = V;\n                E->V2 = W;\n                E->Weight = Weight;\n                \nif\n(E->\nV1==\n0\n) E->Weight-=\n7.5\n;\n                InsertEdge(Graph,E);\n            }\n        }\n    }\n    \n    return Graph;\n}\n\nVertex FindMinDist(MGraph Graph, double dist[], int collected[])\n{\n    Vertex MinV, V;\n    int MinDist = M_INFINITY;\n    \n    \nfor\n(V=0; V\nNv; V++){\n        \nif\n(collected[V]==\n0\n && dist[V]\nNv;V++){\n        \ndist\n[V] = Graph->\nD[\n0\n][V];\n        \nif\n(dist[V]\nNv;W++)\n            \nif\n(collected[W]==0 && Graph->\nD[V][W]\nD[V][W]\nD[V][W];\n                    \npath\n[W] = V; \n                }\n            }\n    }\n}\n\nint min(int x,int y)\n{\n    \nif\n(x\nNv];\n    \nint\n \npath\n[Graph->\nN\nv\n],collected[Graph->\nNv];\n    \nfor\n(i=0;i\nNv;i++){\n        dist[i] = M_INFINITY;\n        \npath\n[i] = -\n1\n;\n        collected[i] = \n0\n;\n    }\n    \n/*Dijkstra算法算dist*/\n\n    Dijkstra(Graph,dist,\npath\n,collected);\n    \n    \n/*找到可以作为出口得鳄鱼，同时将它到出口的距离存储到数组中*/\n\n    V\nertex\n V,W,OutNode[Graph->\nNv];\n    int flag = \n0\n;\n    \nfor\n(V=0;V\nNv;V++) OutNode[V]=\n0\n;\n    \nfor\n(V=0;V\nNv;V++){\n        \nif\n(50-fabs(Graph->\nL\nocate\n[V].X)<=D || 50-fabs(Graph->\nLocate[V].Y)<=D){\n            \nif\n(50-fabs(Graph->\nLocate[V].X)<=D){\n                O\nutNode\n[V] = 50-fabs(Graph->\nLocate[V].X);\n            }\nelse\n \nif\n(50-fabs(Graph->\nLocate[V].Y<=D)){\n                O\nutNode\n[V] = 50-fabs(Graph->\nLocate[V].X);\n            }\n            flag=\n1\n;\n        }\n    }\n    \nif\n(!flag){\n        printf(\n\"0\"\n);\n        return \n0\n;\n    }\n    flag = \n0\n;\n    \nfor\n(W=1;W\nNv;W++){\n        \nif\n(Graph->\nD[\n0\n][W]!=M_INFINITY){\n            flag = \n1\n;\n        }\n    }\n    \nif\n(!flag){\n        printf(\n\"0\"\n);\n        return \n0\n;\n    }\n    \n/*以上为判断是否有可能可以出去，也就是1>Island有没有邻接点，2>有没有可以跳出去的鳄鱼*/\n\n\n    \n/*\n    找最短路\n    1.找可以出去的路径\n    2.比较可以出去的路径中最短路径 \n    */\n\n    \n    V\nertex\n OutWay[Graph->\nNv];\n    \nfor\n(i=0;i\nNv;i++){\n        OutWay[i]=-\n1\n;\n    }\n    \nfor\n(i=0;i\nNv;i++){\n        \nif\n(50-\nabs\n(Graph->\nL\nocate\n[i].X)<=D || 50-\nabs\n(Graph->\nLocate[i].Y)<=D){\n            O\nutWay\n[i] = min(50-\nabs\n(Graph->\nL\nocate\n[i].X),50-\nabs\n(Graph->\nLocate[i].Y));\n        }\n    }\n    \n    \n    \n/*从出口中更新路径长度*/\n\n    \ndouble\n Outdist[Graph->\nNv];\n    \nfor\n(i=0;i\nNv;i++){\n        Outdist[i] = \n0\n;\n    }\n    \nfor\n(i=0;i\nNv;i++){\n        \nif\n(OutWay[i]!=-\n1\n){\n            Vertex temNode = i;\n            \nwhile\n(temNode){\n                Outdist[i]+=dist[temNode];\n                temNode = \npath\n[temNode];\n            }\n        }\n    }\n    \n    \n/*从路径中找最小长，并记录*/\n\n    Vertex MinWay;\n    double Mindist=M_INFINITY;\n    \nfor\n(i=0;i\nNv;i++){\n        \nif\n(OutWay[i]!=-\n1\n){\n            \nif\n(Mindist>Outdist[i]){\n                Mindist = Outdist[i];\n                MinWay = i;\n            }\n        }\n    }\n    \n    \n/*从最小路径中找结点，反向输出*/\n\n    V\nertex\n Stack[Graph->\nNv];\n    int rear=-\n1\n,count=\n1\n;\n    Vertex temNode = MinWay;\n    \nwhile\n(temNode){\n        Stack[++rear] = temNode;\n        temNode = \npath\n[temNode];\n        count++;\n    }\n    printf(\n\"%d\\n\"\n,count);\n    \nwhile\n(rear!=-\n1\n){\n        \nprintf\n(\"%d %d\\n\",Graph->\nL\nocate\n[Stack[rear]].X,Graph->\nLocate[Stack[rear]].Y);\n        rear--;\n    }\n    \n    return \n0\n;\n}\n\n\n\n\n最后结果\n\n\n\n\n实在不知道哪错了，最初是前三项都通过了，后来就从头再来一遍，哪知道现在后面几个对了第一个项目说段错误，段错误给的理由如下\n\n\n\n\n不过现在测试点也不知道哪错了，麻烦看看吧", "Tag": "算法分析"}
{"Answer": "kaishi.setOnClickListener(new Button.OnClickListener(){\r\n            public void onClick(View v){\r\n                DisplayMetrics dm = new DisplayMetrics();\r\n                getWindowManager().getDefaultDisplay().getMetrics(dm);\r\n                screenWidth = dm.widthPixels;\r\n                screenHeight = dm.heightPixels;             \r\n                setTitle(\"宽\"+screenWidth+\"  高\"+screenHeight);\r\n                requestWindowFeature(Window.FEATURE_NO_TITLE); \r\n                getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN); \r\n                    `myview = new BallView(this);`    //错误在这里 \r\n                setContentView(myview);\r\n            }\r\n\r\n这里面的这个`myview = new BallView(dazhuankuaiActivity.this);", "Konwledge_Point": "边的长度", "Question": "所做Android打砖块代码其中 出错 求教\n下面是代码  可其中出现了一个错误（做了标记），不知道怎么解决，可否有高手帮我看看，能不能稍作修改一下，做成正确的。\n\n就是这句错了  myview = new BallView(this);\n\n\n\npackage sen.tan;\n\n\nimport android.app.Activity;\nimport android.graphics.Color;\nimport android.os.Bundle;\nimport android.util.DisplayMetrics;\nimport android.view.KeyEvent;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\npublic class dazhuankuaiActivity extends Activity {\n    BallView myview;\n    public static  int screenWidth ;\n    public static  int screenHeight;\n    private TextView textview;\n    Button kaishi,jieshu,guanyu;\n    ImageView image;\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        String string = \"欢迎进入疯狂打砖块游戏\";\n        image = (ImageView) this.findViewById(R.id.image);\n        image.setImageResource(R.drawable.img1);\n        textview =(TextView) this.findViewById(R.id.textview);\n        textview.setTextSize(20);\n        textview.setTextColor(Color.GREEN);\n        textview.setBackgroundColor(Color.RED);\n        textview.setText(string);\n        kaishi=(Button)findViewById(R.id.button1);\n        guanyu=(Button)findViewById(R.id.button2);\n        jieshu=(Button)findViewById(R.id.button3);\n        kaishi.setWidth(250);\n        guanyu.setWidth(200);\n        jieshu.setWidth(150);\n        kaishi.setTextSize(35);\n        guanyu.setTextSize(29);\n        jieshu.setTextSize(24);\n\n\n        jieshu.setOnClickListener(new Button.OnClickListener(){\n            public void onClick(View v)\n            {\n                dazhuankuaiActivity.this.finish();\n            }\n\n\n        });\n        guanyu.setOnClickListener(new Button.OnClickListener(){\n            public void onClick(View v){\n                textview.setText(\"本游戏由xxx制作，此游戏控制左右按键，来回移动挡板，不让小球掉落，当小球把上方砖块全部打完时，游戏胜利\");\n            }\n        });\n        kaishi.setOnClickListener(new Button.OnClickListener(){\n            public void onClick(View v){\n                DisplayMetrics dm = new DisplayMetrics();\n                getWindowManager().getDefaultDisplay().getMetrics(dm);\n                screenWidth = dm.widthPixels;\n                screenHeight = dm.heightPixels;             \n                setTitle(\"宽\"+screenWidth+\"  高\"+screenHeight);\n                requestWindowFeature(Window.FEATURE_NO_TITLE); \n                getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN); \n                    `myview = new BallView(this);`    //错误在这里 \n                setContentView(myview);\n            }\n\n            public boolean onKeyDown(int keyCode, KeyEvent event)\n            {\n\n            switch (keyCode)\n                {\n        case KeyEvent.KEYCODE_MENU:\n            myview.resetGame();\n            break;\n            case KeyEvent.KEYCODE_DPAD_CENTER:\n            myview.ball_isRun = !myview.ball_isRun;\n               break;\n            case KeyEvent.KEYCODE_DPAD_LEFT:\n\n                    if(myview.ball_isRun){\n\n                if(myview.board_left<=myview.board_x_move)\n\n                    {\n\n            myview.board_left=0;\n\n                myview.board_right=myview.board_length;\n\n                }else{\n\n                myview.board_left-=myview.board_x_move;\n\n                        myview.board_right-=myview.board_x_move;}\n        }\n\n                         break;\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\n        if(myview.ball_isRun){\n\n                if(screenWidth-myview.board_right<=myview.board_x_move )\n\n        {\n                            myview.board_left=screenWidth-myview.board_length;\n\n                                            myview.board_right=screenWidth;\n\n            }else{\n                            myview.board_left+=myview.board_x_move;\n\n                                                myview.board_right+=myview.board_x_move;\n\n                    }\n                    }\n\n                    break;\n                 case KeyEvent.KEYCODE_DPAD_UP:\n\n                if(myview.ball_isRun){\n\n                if( myview.board_alterable_top==myview.board_default_top)\n        {\n\n                myview.board_alterable_top-=myview.boardYadd;\n\n                        myview.board_alterable_bottom-=myview.boardYadd;\n                        }\n                    }\n\n                    break;  \n                 case KeyEvent.KEYCODE_DPAD_DOWN:\n\n            if(myview.ball_isRun){\n\n            if( myview.board_alterable_top==myview.board_default_top-myview.boardYadd )\n\n            {\n                            myview.board_alterable_top=myview.board_default_top;\n\n            myview.board_alterable_bottom=myview.board_alterable_top+myview.board_thickness;\n                        }\n                    }\n\n            break;  \n\n            case KeyEvent.KEYCODE_BACK:\n\n            dazhuankuaiActivity.this.finish();\n\n            break;  \n\n        }//end switch\n            return false;\n            }\n\n            //按键弹起事件\n\n        }\n        );\n        }\n}\npackage sen.tan;\n\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.RadialGradient;\nimport android.graphics.Shader;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\npublic class BallView extends SurfaceView implements\n        SurfaceHolder.Callback, Runnable {\n\n    //线程延时控制 \n    final int ball_sleep=1;//毫秒，延时越大，球速越慢\n    final int ball_r= 8;//小球半径\n    final float ball2_r= 8;//底下滚珠小球半径\n    final int ballXorYadd = 4;//小球的基本位移。测试可行值：2，4\n\n    //获取屏幕宽度和高度\n    int screen_width;//320;\n    int screen_height;//480;\n\n    //砖的属性\n    int brick_width;//每块砖宽\n    int brick_height;//每块砖高\n    boolean brick_exist[];//砖是否存在\n    int k ;// 列//到for循环里才初始化\n    int j ;// 行\n    int brick_left = brick_width*(k-1);//到判断语句才初始化\n    int brick_right = brick_width*k;\n    int brick_top = brick_height*j;\n    int brick_bottom = brick_height*(j+1);\n\n    //挡板的属性\n    int board_length;//挡板长度:80比较合适，可以随意修改,但别超过screen_width\n    final int boardYadd = 16;//按上下键时挡板y方向位移量。经验证4、8、16可以，12不行\n    final int board_x_move = 30;//挡板x方向位移量:可以随意自定义\n    int board_left;//挡板左侧（可变）\n    int board_right;//挡板右侧（可变）\n    int board_thickness;//挡板厚度\n    int board_default_top;//即435,挡板的top面初始位置\n    int board_alterable_top;//挡板上侧（可变）\n    int board_alterable_bottom;//挡板下侧（可变）\n\n    int ball_default_x;//球的初始x坐标\n    int ball_default_y;//球的初始y坐标\n    //球的即时坐标（可变）：\n    int ball_x;//球心横坐标\n    int ball_y;//球心纵坐标\n    //球的前一步的y坐标\n    int ball_previous_y;\n    int ball_x_speed;//球的横向偏移量//可变\n    int ball_y_speed;//球的纵向偏移量//可变\n    boolean ball_isRun;//球是否在动\n    // 控制循环\n    boolean mbLoop;\n    // 定义SurfaceHolder对象\n    SurfaceHolder mSurfaceHolder = null;\n    //获得分数\n    int score;\n    /* 唤醒渐变渲染 */\n    Shader mRadialGradient = null;\n\n\n//------------------------------------------------------------------------------------------------------//\n    public BallView(Context context) {\n        super(context);\n        // 实例化SurfaceHolder\n        mSurfaceHolder = this.getHolder();\n        // 添加回调\n        mSurfaceHolder.addCallback(this);\n        this.setFocusable(true);\n\n        //获取屏幕宽度和高度\n        screen_width = dazhuankuaiActivity.screenWidth;//320\n        screen_height = dazhuankuaiActivity.screenHeight;//480\n\n        //砖的属性\n        brick_width = screen_width/5;//每块砖宽64\n        brick_height = screen_height/15;//每块砖高32\n\n        //挡板的属性\n        board_length = screen_width/4;//挡板长度:80比较合适，可以随意修改,但别超过screen_width\n        board_left = (screen_width-board_length)/2;//挡板左侧（可变）\n        board_right = (screen_width+board_length)/2;//挡板右侧（可变）\n        board_thickness = 5;//挡板厚度\n        board_default_top = 13*screen_height/15;//即435,挡板的top面初始位置\n        board_alterable_top = board_default_top;//挡板上侧（可变）\n        board_alterable_bottom = board_alterable_top+board_thickness;//挡板下侧（可变）\n\n        ball_default_x = screen_width/2;//球的初始x坐标\n        ball_default_y = board_default_top - ball_r;//球的初始y坐标\n        //球的即时坐标（可变）：\n        ball_x = ball_default_x;\n        ball_y = ball_default_y;\n        //球的前一步的y坐标\n        ball_previous_y = 0;\n        ball_x_speed = ballXorYadd;//球的横向偏移量\n        ball_y_speed = ballXorYadd;//球的纵向偏移量\n\n        mbLoop = true;\n        ball_isRun = false;\n        score=0;\n\n        brick_exist = new boolean[25];\n        for (int i = 0; i < 25; i++) {\n            brick_exist[i] = true;\n        }\n        /* 构建RadialGradient对象，设置半径的属性 */\n        mRadialGradient = new RadialGradient(ball_x, ball_y, ball_r,//球中心坐标x,y,半径r\n                new int[]{Color.WHITE,Color.BLUE,Color.GREEN,Color.RED,Color.YELLOW},//颜色数组\n                null,//颜色数组中每一种颜色对应的相对位置，为空的话就是平均分布，由中心向外排布\n                Shader.TileMode.REPEAT);//渲染模式：重复\n    }\n\n    public void resetGame(){\n        ball_isRun = false;\n        score =0;//分数\n        ball_x_speed = ballXorYadd;//球的横向偏移量\n        ball_y_speed = ballXorYadd;//球的纵向偏移量\n        ball_x = screen_width/2;//球心起始横坐标\n        ball_y = board_default_top - ball_r;//球心起始纵坐标\n        board_left = (screen_width-board_length)/2;//挡板左侧\n        board_right = (screen_width+board_length)/2;//挡板右侧\n        board_alterable_top = board_default_top;//挡板上侧\n        board_alterable_bottom = board_alterable_top+board_thickness;//挡板下侧\n        for (int i = 0; i < 25; i++) {\n            brick_exist[i] = true;\n        }\n    }\n\n    //---------------------------------绘图循环开始----------------------------------\n    public void run() {\n\n        while (mbLoop&&!Thread.currentThread().isInterrupted()) {\n            try {\n                Thread.sleep(ball_sleep);\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n            //球的前一步y坐标\n            ball_previous_y = ball_y;\n\n            if (ball_isRun) {\n                ballRunning();// 让小球移动\n                boardPositionCheck();//检测挡板是否处于“中线”位置，是就随小球上升一步，直至到“上线”\n                hitWallCheck();//墙壁碰撞检测\n                hitBoardCheck();//挡板碰撞检测\n                hitBrickCheck();//砖块碰撞检测\n            }\n            synchronized (mSurfaceHolder) \n            {\n                Draw();\n            }\n        }\n    }\n    //---------------------------------绘图循环结束----------------------------------\n    //------------------------------------------------------------------------------\n\n    //让小球移动\n    public void ballRunning() {\n        ball_x += ball_x_speed;\n        ball_y -= ball_y_speed;\n    }\n    //朝左或朝右碰撞后小球水平方向逆向\n    public void ballLeftOrRightHit() {\n        ball_x_speed *= -1;\n    }\n    //朝上或朝下碰撞后小球竖直方向逆向\n    public void ballUpOrDownHit() {\n        ball_y_speed *= -1;\n    }\n\n    public void ballcornerHit() {\n        ball_x_speed *= -1;\n        ball_y_speed *= -1;\n    }\n\n    public void ballStraightUp() {//功能没实现，这是多余代码\n        ball_x_speed = 0;//注意在其他地方恢复\n        ball_y_speed *= -1;\n    }\n\n    //-------------------墙壁碰撞检测开始-------------------------------------\n    public void hitWallCheck() {\n        // 左碰墙\n        if (ball_x <= ball_r && \n            ball_y >= ball_r && ball_y <= screen_height) \n        {\n            ballLeftOrRightHit();\n        // 右碰墙\n        }\n        if (ball_x >= screen_width - ball_r && //不能写为 else if,因为可能恰好碰到角落。\n                   ball_y >= ball_r && ball_y <= screen_height) \n        {\n            ballLeftOrRightHit();\n        }\n        // 上碰墙\n        if (ball_x >= ball_r && ball_x <= screen_width - ball_r && \n                 ball_y <= ball_r + brick_height) //、、、、、、、、、、、、、、、25号修改\n        {\n            ballUpOrDownHit();\n        }\n        // 下碰墙\n        if (ball_x >= ball_r && ball_x <= screen_width - ball_r && \n                 ball_y >= screen_height-ball_r) \n        {\n            ballUpOrDownHit();\n            if(score<=10){\n                score = 0;\n            }\n            else score-=10;\n        }\n    }\n    //-------------------墙壁碰撞检测结束-------------------------------------\n\n    //-----------------------------挡板碰撞检测开始---------------------------\n    public void hitBoardCheck() {\n        // 下碰挡板正面\n        if (ball_x >= ball_r && ball_x <= screen_width - ball_r && //在屏幕内，起码条件\n            ball_x >= board_left && ball_x <= board_right && //在挡板X域上方\n            ball_y == board_alterable_top - ball_r &&//球面与挡板相切\n            ball_previous_y <= board_alterable_top - ball_r  //确定球是从上方下落\n            )\n        {\n            if(board_alterable_top==board_default_top-boardYadd ){//如果弹簧伸张，挡板位于上线\n                ballHitBoardlower();//作用：ball_y_move减小；挡板被打下;小球Y向运动反向\n            }\n            else if(board_alterable_top==board_default_top){//如果弹簧压缩，挡板位于下线\n                boardHitBallHigher();//作用：ball_y_move增加；挡板弹上;小球Y向运动反向\n            }\n        }\n        //斜碰挡板右上角//经验证有效\n        else if(Math.pow(board_right-ball_x, 2)+Math.pow(board_alterable_top-ball_y,2)<=Math.pow(ball_r, 2)&&\n                ball_x>board_right && ball_y ball_y_speed ){//在线程这一轮，小球上升多少，挡板就上升多少。\n            board_alterable_top = board_default_top - ball_y_speed;\n            board_alterable_bottom= board_alterable_top+board_thickness;//挡板下层面\n        }\n    }\n\n    //检测挡板是否处于“中线”位置，是就随小球上升一步，直至到“上线”\n    private void boardPositionCheck() {//还可直接利用球的位置刷新，board_top与球心相差ball_r\n        if(board_alterable_top < board_default_top && board_alterable_top > board_default_top-boardYadd){\n            //挡板随球上升\n            if(board_alterable_top - ball_y_speed >= board_default_top-boardYadd){\n                board_alterable_top -= ball_y_speed;//挡板上层面\n                board_alterable_bottom= board_alterable_top+board_thickness;//挡板下层面\n            }\n            else{\n                board_alterable_top = board_default_top-boardYadd;//挡板上层面\n                board_alterable_bottom= board_alterable_top+board_thickness;//挡板下层面\n            }\n        }\n    }\n\n    private void ballHitBoardlower() {//减弱\n        board_alterable_top=board_default_top;\n        board_alterable_bottom=board_default_top+board_thickness;//挡板被打退\n        ballUpOrDownHit();//小球Y方向反向\n        if(ball_y_speed==2*ballXorYadd){\n            ball_y_speed -= ballXorYadd;//小球Y方向速度减弱\n        }\n    }\n\n    //砖块碰撞检测开始-----------------------------------------------------------\n    public void hitBrickCheck() {\n        for (int i = 0; i <25 ; i++) {\n        if (brick_exist[i]) {\n            k = i % 5+1;// 1,2,3,4,5循环\n            j = i / 5+1;// 1,1,1,1,1;2,2,2,2,2,;...;5,5,5,5,5\n            brick_left = brick_width*(k-1);\n            brick_right = brick_width*k;\n            brick_top = brick_height*j;\n            brick_bottom = brick_height*(j+1);\n            //朝下碰砖的top面 AAAAAAAAAAAAAAAAAAAAA\n            if(ball_x >= brick_left && ball_x <= brick_right &&\n               ball_y >= brick_top-ball_r && ball_y < brick_top) \n            {\n                ballUpOrDownHit();\n                brick_exist[i] = false;\n                score+=4;\n                //朝下正碰2砖中间，i砖右上角检测\n                if(k!=5 && ball_x == brick_right)//如果不是第5列砖的右侧边\n                {\n                    //如果砖[i+1]存在\n                    if(brick_exist[i+1]){\n                        brick_exist[i+1] = false;\n                        score+=4;\n                    }\n                }\n                //朝下正碰2砖中间，i砖左上角检测\n                else if(k!=1 && ball_x == brick_left)//如果不是第1列砖的左侧边\n                {\n                    //如果砖[i-1]存在\n                    if(brick_exist[i-1]){\n                        brick_exist[i-1] = false;\n                        score+=4;\n                    }\n                }\n            }\n            //朝上碰砖的bottom面 BBBBBBBBBBBBBBBBB\n            else if(ball_x >= brick_left && ball_x <= brick_right &&\n                    ball_y > brick_bottom&& ball_y <= brick_bottom + ball_r )\n            {\n                ballUpOrDownHit();\n                brick_exist[i] = false;\n                score+=4;\n                //朝上正碰2块砖中间--i砖的右下角检测\n                if(k!=5 && ball_x == brick_right) //如果不是第5列砖的右侧边\n                {\n                    if(brick_exist[i+1]){//如果砖[i+1]存在\n                        brick_exist[i+1] = false;\n                        score+=4;\n                    }\n                }\n                //朝上正碰2块砖中间--i砖的左下角检测\n                else if(k!=1 && ball_x == brick_left) //如果不是第1列砖的左侧边\n                {\n                    if(brick_exist[i-1]){//如果砖[i-1]存在\n                        brick_exist[i-1] = false;\n                        score+=4;\n                    }\n                }\n            }\n            //朝右碰砖的left面CCCCCCCCCCCCCCCCC\n            else if(ball_x >= brick_left -ball_r&&ball_x < brick_left&&\n               ball_y >= brick_top && ball_y <= brick_bottom)\n            {\n                ballLeftOrRightHit();\n                brick_exist[i] = false;\n                score+=4;\n                //朝右正碰2块砖中间，左下角检测\n                if(j!=5 && ball_y == brick_bottom)//如果不是第5行砖的下侧边\n                {\n                    if(brick_exist[i+5]){//如果砖[i+5]存在\n                        brick_exist[i+5] = false;\n                        score+=4;\n                    }\n                }\n                //朝右正碰2块砖中间，左上角检测\n                else if(j!=1 && ball_y == brick_top)//如果不是第1行砖的上侧边\n                {\n                    if(brick_exist[i-5]){//如果砖[i-5]存在\n                        brick_exist[i-5] = false;\n                        score+=4;\n                    }\n                }\n            }\n            //朝左碰砖的right面DDDDDDDDDDDDDDDDDD\n            else if(ball_x >= brick_right && ball_x <= brick_right+ball_r&&\n               ball_y >= brick_top && ball_y <= brick_bottom)\n            {\n                ballLeftOrRightHit();\n                brick_exist[i] = false;\n                score+=4;\n                //朝左正碰2块砖中间，右下角检测\n                if(j!=5 && ball_y == brick_bottom )//如果不是第5行砖的下侧边\n                {\n                    if(brick_exist[i+5]){//如果砖[i+5]存在\n                        brick_exist[i+5] = false;\n                        score+=4;\n                    }\n                } \n                //朝左正碰2块砖中间，右上角检测\n                else if(j!=1 && ball_y == brick_top )//如果不是第1行砖上侧边\n                {\n                    if(brick_exist[i-5]){//如果砖[i-5]存在\n                        brick_exist[i-5] = false;\n                        score+=4;\n                    }\n                }\n            }\n            /////////////////////////////////////////\n            //斜碰i砖的左下角EEEEEEEEEEEEEEEEEEEEEEEE\n            else if(( i-1<0||(i-1>=0&&!brick_exist[i-1]) ) &&\n                    (i+5>=25||(i+5<25&&!brick_exist[i+5]) )&&\n                    Math.pow(brick_left-ball_x, 2)+Math.pow(brick_bottom-ball_y,2)<=Math.pow(ball_r, 2)&&\n                    ball_x>brick_left-ball_r && ball_xbrick_bottom && ball_y=25||(i+1<25&&!brick_exist[i+1]) )&&\n                     (i+5>=25||(i+5<25&&!brick_exist[i+5]) )&&\n                    Math.pow(brick_right-ball_x, 2)+Math.pow(brick_bottom-ball_y,2)<=Math.pow(ball_r, 2)&&\n                    ball_x>brick_right&&ball_xbrick_bottom&&ball_y=25||(i+1<25&&!brick_exist[i+1]) )&&\n                    (i-5<0||(i-5>0&&!brick_exist[i-5]) )&&\n                    Math.pow(brick_right-ball_x, 2)+Math.pow(brick_top-ball_y,2)<=Math.pow(ball_r, 2)&&\n                    ball_x>brick_right && ball_xbrick_top-ball_r && ball_y=0&&!brick_exist[i-1])) &&\n                    (i-5<0||(i-5>=0&&!brick_exist[i-5])) &&\n                    Math.pow(brick_left-ball_x, 2)+Math.pow(brick_top-ball_y,2)<=Math.pow(ball_r, 2)&&\n                    ball_x>brick_left-ball_x && ball_xbrick_top-ball_r && ball_y<brick_top )\n            {\n                ballcornerHit();\n                brick_exist[i] = false;\n                score+=4;\n            }\n        }//end if\n        }//end for  \n    }//end hitBrickCheck()\n    //砖块碰撞检测结束-----------------------------------------------------------\n\n    //------------------------------------------\n    public boolean gameOver(){\n        int count = 0;\n        for(boolean s:brick_exist){\n            if(!s){\n                count++;\n            }\n        }\n        if(count == 25){\n            return true;\n        }else{\n            return false;\n        }\n\n    }\n    //------------------------------------------\n\n    //---------------绘图方法开始------------------------\n    public void Draw() {\n        // 锁定画布，得到canvas\n        Canvas canvas = mSurfaceHolder.lockCanvas();\n        if (mSurfaceHolder == null || canvas == null) {\n            return;\n        }\n        // 绘图\n        Paint mPaint = new Paint();\n        // 设置取消锯齿效果\n        mPaint.setAntiAlias(true);\n\n        mPaint.setColor(Color.BLACK);\n        // 绘制矩形--背景\n        canvas.drawRect(0, 0, screen_width, brick_height-2, mPaint);\n\n        mPaint.setColor(Color.GREEN);\n        // 绘制矩形--背景\n        canvas.drawRect(0, brick_height-2, screen_width, screen_height, mPaint);\n\n        mPaint.setColor(Color.RED);//设置字体颜色\n        mPaint.setTextSize(brick_height-7);//设置字体大小\n        canvas.drawText(\"得分：\"+score, 0, brick_height-7, mPaint);\n\n        // 绘制顶层挡板````````````````````````````````````````````````````````25号修改\n        mPaint.setColor(Color.BLACK);//设置颜色 \n        mPaint.setStrokeWidth(4);//设置粗细\n        canvas.drawLine(0, brick_height-2, screen_width, brick_height-2, mPaint);\n\n        for (int i = 0; i <25 ; i++) {\n            if (brick_exist[i]) {\n                k = i % 5+1;// 1,2,3,4,5循环\n                j = i / 5+1;// 1,1,1,1,1;2,2,2,2,2,;...;5,5,5,5,5\n                brick_left = brick_width*(k-1);\n                brick_right = brick_width*k;\n                brick_top = brick_height*j;\n                brick_bottom = brick_height*(j+1);\n\n                mPaint.setStyle(Paint.Style.FILL);// 设置实心画笔\n                mPaint.setColor(Color.YELLOW);\n                canvas.drawRect(brick_left+1, brick_top+1, brick_right-1,brick_bottom-1, mPaint);\n\n                mPaint.setStyle(Paint.Style.STROKE);// 设置空心画笔\n                mPaint.setStrokeWidth(2);//设置粗细\n                mPaint.setColor(Color.BLUE);\n                canvas.drawRect(brick_left+3, brick_top+3, brick_right-3,brick_bottom-3, mPaint);\n            }\n        }\n        // 设置实心画笔\n        mPaint.setStyle(Paint.Style.FILL);\n        {\n            mPaint.setShader(mRadialGradient);\n            canvas.drawCircle(ball_x, ball_y, ball_r, mPaint);\n        }   \n\n        Paint mPaint2 = new Paint();\n            // 设置取消锯齿效果\n        mPaint2.setAntiAlias(true); \n        // 设置实心画笔\n        mPaint2.setStyle(Paint.Style.FILL);\n        {   \n        mPaint2.setColor(Color.BLACK);\n        /* 绘制矩形挡板 */\n        canvas.drawRect(board_left, board_alterable_top, board_right, board_alterable_bottom,mPaint2);\n        float board2_bottom = screen_height - 2*ball2_r;//164\n        float board2_top = board2_bottom - 4;//160\n        //线段端点坐标数组\n        float x0 = board_left+(board_right-board_left)/4;\n        float y0 = board_alterable_bottom;//440或者444\n        float springAdd = (board2_top- board_alterable_bottom)/8;//即2.5或者2：弹簧小线段的y向长度\n        float springWidth = 5.0f;//弹簧小线段的x向长度\n        float x1 = x0 - springWidth;\n        float y1 = y0 + springAdd;\n        float x2 = x0 + springWidth;\n        float y2 = y0 + 3*springAdd;\n        float x3 = x1 ;\n        float y3 = y0 + 5*springAdd;\n        float x4 = x2;\n        float y4 = y0 + 7*springAdd;\n        float x5 = x0 ;\n        float y5 = board2_top;//即460 \n        float between_spring = (board_right-board_left)/2;\n        float pts[] = { x0,y0,x1,y1,\n                        x1,y1,x2,y2,\n                        x2,y2,x3,y3,\n                        x3,y3,x4,y4,\n                        x4,y4,x5,y5};\n        float pts2[] = {x0+between_spring,y0, x1+between_spring,y1,\n                        x1+between_spring,y1, x2+between_spring,y2,\n                        x2+between_spring,y2, x3+between_spring,y3,\n                        x3+between_spring,y3, x4+between_spring,y4,\n                        x4+between_spring,y4, x5+between_spring,y5};\n        mPaint2.setStrokeWidth(2);//设置弹簧粗细\n        //绘制2个弹簧\n        canvas.drawLines(pts, mPaint2);\n        canvas.drawLines(pts2, mPaint2);\n        //绘制下层挡板\n        canvas.drawRect(board_left, board2_top, board_right, board2_bottom,mPaint2);\n        mPaint2.setColor(Color.BLACK);//\n        // 绘制最下面的两个“轮子”(圆心x,圆心y,半径r,p) \n        canvas.drawCircle(board_left+ball2_r, screen_height-ball2_r, ball2_r, mPaint2);//圆\n        canvas.drawCircle(board_right-ball2_r, screen_height-ball2_r, ball2_r, mPaint2);\n        mPaint2.setColor(Color.WHITE);//\n        canvas.drawPoint(board_left+ball2_r, screen_height-ball2_r, mPaint2);//绘制左轮轮心\n        canvas.drawPoint(board_right-ball2_r, screen_height-ball2_r, mPaint2);//绘制右轮轮心\n\n        }//实心画笔mPaint2结束\n\n        if(gameOver()){ \n//          mbLoop = false;//注释掉的话GAME OVER后也可重启\n            ball_isRun = false;\n            mPaint2.setColor(Color.BLACK);//设置字体颜色\n            mPaint2.setTextSize(40.0f);//设置字体大小\n            canvas.drawText(\"GAME OVER\", screen_width/32+40, screen_height/16*9-70, mPaint2);\n            mPaint2.setTextSize(20.0f);//设置字体大小\n            canvas.drawText(\"Press \\\"MENU\\\" button to restart,\", \n                            screen_width/32, //320/32=10\n                            screen_height/16*9, //480/16=30,30*9=270\n                            mPaint2);\n            canvas.drawText(\"Press \\\"BACK\\\" button to exit.\", \n                    screen_width/32, //320/32=10\n                    screen_height/16*10, //480/16=30,30*10=300\n                    mPaint2);\n        }\n        // 绘制后解锁，绘制后必须解锁才能显示\n        mSurfaceHolder.unlockCanvasAndPost(canvas);\n    }// end of Draw()\n    //---------------------绘图方法结束-----------------------------------------------\n\n    // 在surface的大小发生改变时激发\n    public void surfaceChanged(SurfaceHolder holder, int format, int width,\n            int height) {\n    }\n\n    // 在surface创建时激发\n    public void surfaceCreated(SurfaceHolder holder) {\n        new Thread(this).start();// 开启绘图线程\n    }\n\n    // 在surface销毁时激发\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        // 停止循环\n        mbLoop = false;\n    }\n}\n\n\n\n下个界面的代码是  \npackage ab.cc;\n\nimport android.app.Activity;\n\nimport android.os.Bundle;\n\nimport android.util.DisplayMetrics;\n\nimport android.view.KeyEvent;\n\nimport android.view.MotionEvent;\n\nimport android.view.Window;\nimport android.view.WindowManager;\n\n\npublic class BaomingActivity extends Activity\n{\n\nBallView myView;\n\nstatic int  screenWidth;\n\nstatic int screenHeight;\n\n/** Called when the activity is first created. */\n    @Override\n\n    public void onCreate(Bundle savedInstanceState)\n    {\n\n    super.onCreate(savedInstanceState);\n\n    /* 定义DisplayMetrics对象 */\n\nDisplayMetrics dm = new DisplayMetrics();\n\n    /* 取得窗口属性 */\n\ngetWindowManager().getDefaultDisplay().getMetrics(dm);\n\n    /* 窗口的宽度 */\n\nscreenWidth = dm.widthPixels;\n\n        /* 窗口的高度 */\n\nscreenHeight = dm.heightPixels;\n//      \nsetTitle(\"宽\"+screenWidth+\"  高\"+screenHeight);\n\n\n        /* 设置为无标题栏 */\n\nrequestWindowFeature(Window.FEATURE_NO_TITLE); \n\n    /* 设置为全屏模式 */ \n\ngetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN); \n\n\n\nmyView = new BallView(this);\n\n       //设置显示GameSurfaceView视图\n\nsetContentView(myView);\n    }//end of onCreate()\n\n\n       //触笔事件\n\npublic boolean onTouchEvent(MotionEvent event)\n    {\n\n    return true;\n    }\n\n\n       //按键按下事件\n\n public boolean onKeyDown(int keyCode, KeyEvent event)\n    {\n\n    switch (keyCode)\n        {\n\n    //菜单按键-设为初始菜单\n\ncase KeyEvent.KEYCODE_MENU:\n\n    myView.resetGame();\n        //重新开始\n\n    break;\n\n    //中间按键\n\n    case KeyEvent.KEYCODE_DPAD_CENTER:\n\n    myView.ball_isRun = !myView.ball_isRun;//开始//暂停\n\n        break;\n\n\n//左方向键  \n\ncase KeyEvent.KEYCODE_DPAD_LEFT:\n\n            if(myView.ball_isRun){\n\n        if(myView.board_left<=myView.board_x_move)\n\n            {\n\n    myView.board_left=0;\n\n        myView.board_right=myView.board_length;\n\n        }else{\n\n        myView.board_left-=myView.board_x_move;\n\n                myView.board_right-=myView.board_x_move;}\n}\n\n                 break;\n\n\n//右方向键\n\ncase KeyEvent.KEYCODE_DPAD_RIGHT:\nif(myView.ball_isRun){\n\n        if(screenWidth-myView.board_right<=myView.board_x_move )\n\n{\n                    myView.board_left=screenWidth-myView.board_length;\n\n                                    myView.board_right=screenWidth;\n\n    }else{\n                    myView.board_left+=myView.board_x_move;\n\n                                        myView.board_right+=myView.board_x_move;\n\n            }\n            }\n\n            break;\n\n            //上方向键\n\n    case KeyEvent.KEYCODE_DPAD_UP:\n\n        if(myView.ball_isRun){\n\n        if( myView.board_alterable_top==myView.board_default_top)\n{\n\n        myView.board_alterable_top-=myView.boardYadd;\n\n                myView.board_alterable_bottom-=myView.boardYadd;\n                }\n            }\n\n            break;  \n        //下方向键\n\n       case KeyEvent.KEYCODE_DPAD_DOWN:\n\n    if(myView.ball_isRun){\n\n    if( myView.board_alterable_top==myView.board_default_top-myView.boardYadd )\n\n    {\n                    myView.board_alterable_top=myView.board_default_top;\n\n    myView.board_alterable_bottom=myView.board_alterable_top+myView.board_thickness;\n                }\n            }\n\n    break;  \n\n//返回键\n        case KeyEvent.KEYCODE_BACK:\n\n    this.finish();\n\n    break;  \n\n}//end switch\n    return false;\n    }\n\n    //按键弹起事件\n\npublic boolean onKeyUp(int keyCode, KeyEvent event)\n    {\n\n        return true;\n    }\n\n\npublic boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)\n    {\n\n    return true;\n    }\n}\n", "Tag": "算法分析"}
{"Answer": "要么条件不符合，要么之前代码已经崩溃了", "Konwledge_Point": "边的长度", "Question": "为什么运行不进函数？\n主函数运行的时候不会进入Dijkstra函数，莫名其妙就结束啦。\n\n\n#include \n\n\n#include\n\n\n#include \n\n\n#include \n\n\n#define MVNum 100\n\n\n#define INFINE 666666\n\n\n#define MAXLEN 20\n\nstruct transportation  \n//边的数据 \n{\n    float gotimehour;\n    float gotimemin;\n    float intimehour;\n    float intimemin;\n    int price;\n    float time;\n    float weight;\n    char range[20];\n};\ntypedef struct ArcNode //\n边集 \n{\n    int adjvex;\n    struct ArcNode *nextarc;\n    struct transportation info;\n} ArcNode;\ntypedef struct VNode \n//顶点集 \n{\n    int NO;\n    char name[20];\n    ArcNode *firstarc;\n}VNode,AdjList[MVNum];\ntypedef struct TransGraph//\n图 \n{\n    AdjList vertices;\n    int vexnum,arcnum;\n}TransGraph;\nint getPosition(TransGraph *G, int c)\n{\n    int m;\n    \nfor\n (m = \n1\n; m <= G->vexnum; m++)\n    {\n        G->vertices[m].NO=m;\n        \nif\n (G->vertices[m].NO == c) \n        {\n            \nreturn\n  m;\n        }\n    }\n    \nreturn\n \n1\n;\n}\n\n//or\nint LocateVex(TransGraph *G,int v)//\n查找元素v在一维数组 Vertex[] 中的下标，并返回下标 \n{\n    int i;\n    \nfor\n(i=\n0\n;ivexnum;i++)\n    {\n        G->vertices[i].NO=i;\n        \nif\n(v==G->vertices[i].NO)\n        {\n            \nreturn\n i; \n        } \n     }      \n     printf(\n\"No Such Vertex!\\n\"\n);\n     \nreturn\n -\n1\n;\n}\n\n\nvoid\n Create(TransGraph *G)\n{\n    int i,j,k;\n    int v1,v2;\n    scanf(\n\"%d %d\"\n,&G->vexnum,&G->arcnum);\n    printf(\n\"%d %d\\n\"\n,G->vexnum,G->arcnum);\n    \nfor\n(i=\n0\n;ivexnum;i++)\n    {\n        scanf(\n\"%s\"\n,G->vertices[i].name);\n        printf(\n\"%s\"\n,G->vertices[i].name);\n        G->vertices[i].NO=i;\n        G->vertices[i].firstarc=NULL;\n    }\n    \nfor\n(k=-\n0\n;karcnum;k++)\n    {\n        scanf(\n\"%d %d\"\n,&v1,&v2);\n        printf(\n\"%d %d\\n\"\n,v1,v2);\n        i=LocateVex(G,v1);\n        j=LocateVex(G,v2);\n        ArcNode* p1=(ArcNode*)malloc(sizeof(ArcNode));\n        scanf(\n\"%f %f %f %f %d\"\n,&p1->info.gotimehour,&p1->info.gotimemin,&p1->info.intimehour,&p1->info.intimemin,&p1->info.price);\n        printf(\n\"%f %f %f %f %d\"\n,p1->info.gotimehour,p1->info.gotimemin,p1->info.intimehour,p1->info.intimemin,p1->info.price);\n        p1->info.time=p1->info.intimehour-p1->info.gotimehour+(p1->info.intimemin-p1->info.gotimemin)/\n60.0\n;\n        scanf(\n\"%s\"\n,&p1->info.range);\n        printf(\n\" %s\\n\"\n,p1->info.range);\n        p1->adjvex=j;\n        p1->nextarc=G->vertices[i].firstarc;\n        G->vertices[i].firstarc=p1;\n    }\n}\n\nvoid\n SeeAll(TransGraph *G)\n{\n    int i;\n    \nfor\n(i=\n0\n;ivertices[i].firstarc;\n        \nwhile\n(p1!=NULL)\n        {\n            printf(\n\"交通方式:%s \"\n,p1->info.range);\n            printf(\n\"出发时间:%0.f:%0.f    到达时间:%0.f:%0.f    票价格:%d    总时间:%f \\n\"\n,p1->info.gotimehour,p1->info.gotimemin,p1->info.intimehour,p1->info.intimemin,p1->info.price,p1->info.time);\n            p1=p1->nextarc;\n        }\n    }\n}\nint get_weight(TransGraph *G, int start, int end,float a,float b)\n{\n    ArcNode* node=(ArcNode*)malloc(sizeof(ArcNode));\n    \nif\n (start == end)\n    \nreturn\n \n0\n;\n    node=G->vertices[start].firstarc;\n    \nwhile\n (node != NULL)\n    {\n        node->info.weight=(a*(node->info.time)+b*(node->info.price));\n        \nif\n (end == node->adjvex)\n            \nreturn\n node->info.weight;\n        node = node->nextarc;\n    }\n\n    \nreturn\n INFINE;\n}\n\nvoid\n Dijkstra(TransGraph *G, int vs,int final, int prev[], int dist[])\n{\n    printf(\n\"%d\\n\"\n,prev[\n1\n]);\n    int i, j, k, t,m,q;\n    float a,b;\n    int min;\n    int tmp;\n    int flag[INFINE];  \n    int path[MAXLEN][MAXLEN]={\n0\n};\n    printf(\n\"请输入时间与价格的权重:\"\n);\n    scanf(\n\"%d %d\"\n,&a,&b); \n    \nfor\n (i = \n1\n; i <= G->vexnum; i++)\n    {\n        flag[i] = \n0\n;                 \n        prev[i] = \n0\n;                    \n        dist[i] = get_weight(G, vs, i,a,b);  \n        path[i][\n0\n] = \n0\n;\n    }\n    flag[vs] = \n1\n;\n    dist[vs] = \n0\n;\n    path[vs][\n0\n] =\n1\n;\n    \nfor\n (i = \n2\n; i <= G->vexnum; i++)\n    {\n        t = \n0\n;\n        min = INFINE;\n        \nfor\n (j = \n1\n; j <= G->vexnum; j++)\n        {\n            \nif\n (flag[j] == \n0\n && dist[j]vexnum; j++)\n        {\n            tmp = get_weight(G, k, j,a,b);\n            tmp = (tmp == INFINE ? INFINE : (min + tmp));\n            \nif\n (flag[j] == \n0\n && (tmp  < dist[j]))\n            {\n                dist[j] = tmp;\n                prev[j] = k;\n                path[j][t] = k;\n                t++;\n            }\n        }\n    }\n    printf(\n\"当前出发站:\"\n);\n    printf(\n\"%s\"\n,G->vertices[vs].name);\n    i=final;\n    int showpath[MAXLEN] = {\n0\n};\n    \nfor\n (m = \n0\n; m < G->vexnum; m++)\n    {\n        \nif\n (path[i][m] == \n0\n|| G->vertices[path[i][m]].NO == G->vertices[vs].NO) \n        {\n            \nbreak\n;\n        }\n        showpath[m] = path[i][m];\n    }\n    printf(\n\"根据您的期待权重所选择的从\"\n); \n    printf(\n\"%s\"\n,G->vertices[vs].name);\n    printf(\n\"前往\"\n);\n    printf(\n\"%s\"\n,G->vertices[i].name);\n    printf(\n\"的最合适路线时间为%d小时,价格为%d元\"\n,((a*dist[i])\n/(a+b)), (b*dist[i])/\n(a+b));\n    \nif\n (dist[i]!= INFINE)\n    {\n        printf(\n\"\\t当前最合适路线为\"\n);\n        puts(G->vertices[vs].name); \n        int z=\n0\n;\n        \nfor\n (q = MAXLEN - \n1\n; q >= \n0\n; q--)\n        {\n            \nif\n (showpath[q] == \n0\n) { \ncontinue\n; }\n            printf(\n\"%s\"\n,G->vertices[showpath[q]].name);\n            printf(\n\"(\"\n);\n            printf(\n\"%s\"\n,G->vertices[showpath[q]].firstarc->info.range);\n            printf\n(\n\")->\"\n)\n;\n            \nz\n++;\n        }\n        \nprintf\n(\n\"%s\"\n,G->vertices[i].name)\n;\n        \nprintf\n(\n\"\\n共需换乘%d次。\"\n,z)\n;\n    }\n    \nelse\n\n    {\n        \nprintf\n(\n\"很抱歉，目前无法前往目的地\"\n)\n;\n    }\n}\n\nvoid\n \nGetNext\n(char ch[],int cLen,int next[])\n{//\ncLen\n为串\nch\n的长度\n    \nnext\n[0] = -1;\n    \nint\n \nk\n = -1,\nj\n = 0;\n    \nwhile\n(j<=cLen-\n1\n)\n{\n        \nif\n(k==-\n1\n||ch[j]==ch[k])\n \n        {\n            \nj\n++;\n            \nk\n++;\n            \nnext\n[\nj\n]=\nk\n;\n        }\n        \nelse\n \nk\n = \nnext\n[\nk\n];\n    }\n}\n\nint\n \nKMP\n(char ch[],char b[],int next[])\n\n{\n    \nint\n \ni\n=0,\nj\n=0,\npos\n,\nlen\n;\n    \nlen\n=\nstrlen\n(b)\n;\n    \nwhile\n(i<\n15\n && jlen-\n1\n)\n\n    {\n      \nprintf\n(\n\"匹配成功\\n\"\n)\n;\n      \nreturn\n 1;\n    }\n    \nelse\n \n    {\n       \nprintf\n(\n\"匹配未成功\\n\"\n)\n;\n       \nreturn\n 0;\n    }\n}\n\nint\n \nmain\n()\n\n{\n    \nint\n \ni\n,\nm\n,\nn\n,\no\n,\nf\n,\ng\n;\n    \nint\n \nvs\n=-1,\nfinal\n=-1;\n    \nint\n \ndist\n[\nMAXLEN\n], \nprev\n[\nMAXLEN\n];\n    \nint\n \nnext1\n[50],\nnext2\n[50];\n    \nchar\n \nleave\n[10],\narrive\n[10];\n    \nstruct\n \nTransGraph\n* \nG\n=\n(struct TransGraph*)\nmalloc\n(sizeof(struct TransGraph))\n;\n    \nCreate\n(G)\n;\n    \nprintf\n(\n\"v[0].firstarc:%d\\n\"\n,G->vertices[\n0\n].firstarc)\n;\n    \nprintf\n(\n\"arc:%f\\n\"\n,G->vertices[\n0\n].firstarc->info.gotimehour)\n;\n    \nprintf\n(\n\"全部交通行程表为:\\n\"\n)\n;\n    \nSeeAll\n(G)\n;\n    \nprintf\n(\n\"请输入您的出发地与目的地\\n\"\n)\n;\n    \nscanf\n(\n\"%s\"\n,&leave)\n;\n    \nprintf\n(\n\"%s\\n\"\n,leave)\n;\n    \nm\n=\nstrlen\n(leave)\n;\n    \nscanf\n(\n\"%s\"\n,&arrive)\n; \n    \nprintf\n(\n\"%s\\n\"\n,arrive)\n;\n    \nn\n=\nstrlen\n(arrive)\n;\n    \nfor\n(i=\n0\n;ivexnum;i++)\n    \n    {\n        \no\n=\nstrlen\n(G->vertices[i].name)\n;\n        \nGetNext\n(leave,m,next1)\n;\n        \nGetNext\n(arrive,n,next2)\n;\n        \nf\n=\nKMP\n(leave,G->vertices[i].name,next1)\n;\n        \nif\n(f==\n1\n)\n\n        {\n            \nvs\n=\ngetPosition\n(G,G->vertices[i].NO)\n;\n            \nprintf\n(\n\"\\n%d\\n\"\n,vs)\n;\n        }\n        \ng\n=\nKMP\n(arrive,G->vertices[i].name,next2)\n;\n        \nif\n(g==\n1\n)\n\n        {\n            \nfinal\n=\ngetPosition\n(G,G->vertices[i].NO)\n;\n            \nprintf\n(\n\"\\n%d\\n\"\n,final)\n;\n        }    \n    }\n    \nif\n(vs==-\n1\n || final==-\n1\n)\n\n    \nprintf\n(\n\"您的出发地/目的地不在当前服务范围内\"\n)\n;\n    \nelse\n \nDijkstra\n(G,vs,final,prev,dist)\n;\n    \nsystem\n(\n\"pause\"\n)\n;\n    \nreturn\n 0;\n}\n\n\n\n\n\n\n就是倒数第三行那个.", "Tag": "算法分析"}
{"Answer": "9\nclass class1():\n    def __init__(self,num):\n        self.num=num\n    def function1(self):\n       return self.num*self.num+914\n\ndef show_string(num):\n    print(\"该值为:\"+str(num))\nif __name__ == \"__main__\":\n    myclass = class1(3)\n    show_string(myclass.function1())\n\n", "Konwledge_Point": "边的长度", "Question": "关于#python#的题目，请各位专家解答！\n9、现使用如下代码:\n\n\n   class class1():\n         def \ninit\n(self,num):\n            self.num=num\n         def function1(self):\n            return self.num*self.num+914\n\n\n   def show_string(num):\n         print(\"该值为:\"+str(num))\n   if \nname\n==\"\nmain\n\":\n   \n①\n_________________________\n   \n②\n_______________________\n请在上两行横线中填入代码，通过调用类中的方法和自定义方法，定义一个名为myclass 的class1 类，并得到如下输出：\"该值为:923\" (10分)\n\n\n请在此处输入答案\n10、给出以下加密代码(Python3)，最后输出126，求整数x_0的值。\n\n\na,b,p=42,19,137\ndef f(x):\n    return (a*x+b)%p\nx0=??????\nassert x0%137 == x0\nprint(f(f(f(f(x0)))))\nOutput:126 (10分)\n\n\n请在此处输入答案\n11、在RSA加密中，已知p=43,q=67\n\n\n(1)选择一个合适的加密指数e (5分)\n\n\nA.3\nB.5\nC.7\nD.9\n(2)根据你选出来的e，组成公钥(n,e)和“私钥(n,d) 求明文50的加密结果、私钥d的值和密文50的解密结果。 (5分)\n\n\n请在此处输入答案\n12、在GF(256)上计算(x^7+x^6+x^4+x^3+1)(x^4+x^2+x)，其中使用不可约多项式x^8+x^4+x^3+x^2+1，写出计算过程。 (10分)\n\n\n请在此处输入答案\n\n\n1、现有如下MySQL表结构\n\n\nPerson表:\n+-------------+---------+\n| 列名         | 类型     |\n+-------------+---------+\n| PersonId    | int     |\n| Name        | varchar |\n| age         | int     |\n+-------------+---------+\nPersonId 是上表主键\n请你写一个查询语句，查出age>=18的Person的所有字段信息 (10分)\n\n\n请在此处输入答案\n2、多线程\n\n\n说说线程的生命周期和六种状态并且 调用哪一种方法可以让线程处于对应的状态 (10分)\n\n\n请在此处输入答案\n3、请简述一下Spring中的AOP的概念，并举出一个实例来说明一下AOP的优点。 (10分)\n\n\n请在此处输入答案\n4、众所周知,在二十多种设计模式中,单例模式是最简单的设计模式.单例是指类的实例在全局只有一个。什么时候我们希望类的实例在整个JVM进程中只有一个？比如说线程池:创建开销很大；还有缓存：占用内存空间很多，而且超过一个也不利于维护。还有其他比如注册表对象，日志对象等等我们都希望它们全局唯一。单例模式指导我们如何创建这样一个对象。\n\n\n下面这是其中一种饿汉式单例\n\n\npublic class Hungry {\n    private byte[] data = new byte[1024*1024];\n    private Hungry(){\n\n\n}\n\nprivate\n \nfinal\n \nstatic\n Hungry HUNGRY= \nnew\n \nHungry\n();\n\n\npublic\n \nstatic\n Hungry \ngetInstance\n()\n{\n    \nreturn\n HUNGRY;\n}\n\n\n\n}\n这是懒汉式单例\n\n\npublic class Singleton {\n\n\nprivate\n \nSingleton\n()\n {\n\n}\n\n\nstatic\n \nclass\n \nSingletonHolder\n {\n    \npublic\n \nstatic\n \nfinal\n \nSingleton\n \nINSTANCE\n \n=\n \nnew\n \nSingleton\n();\n}\n\n\npublic\n \nstatic\n Singleton \ngetInstance\n()\n {\n    \nreturn\n SingletonHolder.INSTANCE;\n}\n\n\n\n}\n你可能发现了.static大量出现在代码块中.被static修饰的变量或方法会附上静态属性,这在一些程序中,可以大大节约内存.\n\n\n那么接下来好好答题.\n\n\npublic class Son extends Father{\n\n\nstatic\n{\n    System.\nout\n.println(\n\"Son static\"\n);\n}\n\n\npublic\n \nSon\n(\n)\n{\n    System.\nout\n.println(\n\"Son constructor\"\n);\n}\n\n\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString[] args\n)\n {\n    \nnew\n Son();\n}\n\n\n\n}\n\n\nclass Father{\n\n\nstatic\n{\n    System.\nout\n.println(\n\"Father static\"\n);\n}\n\n\npublic\n \nFather\n(\n)\n{\n    System.\nout\n.println(\n\"Father constructor\"\n);\n}\n\n\n\n}\n问题1:以上程序输出结果是什么 (3分)\n\n\n请在此处输入答案\npublic class consumer{\n    public static int number = 100;\n\n\npublic\n static \nvoid\n \nadd\n(){\n    number++;\n}\n\npublic\n static \nvoid\n main(String[] args) {\n    \nSystem\n.\nout\n.println(number);\n    \nadd\n();\n\n    consumer first = \nnew\n consumer();\n    \nSystem\n.\nout\n.println(first.number);\n\n    first.\nadd\n();\n    \nSystem\n.\nout\n.println(first.number);\n\n    consumer second = \nnew\n consumer();\n    second.\nadd\n();\n    \nSystem\n.\nout\n.println(first.number);\n}\n\n\n\n}\n问题2:上列输出结果是什么? (3分)\n\n\n请在此处输入答案\npublic class consumer{\n    public  int number = 100;\n\n\npublic\n  \nvoid\n \nadd\n(){\n    number++;\n}\n\npublic\n static \nvoid\n main(String[] args) {\n\n\n    consumer first = \nnew\n consumer();\n    \nSystem\n.\nout\n.println(first.number);\n\n    first.\nadd\n();\n    \nSystem\n.\nout\n.println(first.number);\n\n    consumer second = \nnew\n consumer();\n    second.\nadd\n();\n    \nSystem\n.\nout\n.println(first.number);\n}\n\n\n\n}\n问题3:上列输出结果是什么? (3分)\n\n\n请在此处输入答案\n（4）:你能得出什么结论 (1分)\n\n\n请在此处输入答案\n5、你了解过标准的css的盒子模型吗？尝试打开浏览器的开发者工具,点击Elements来查看页面中的“盒子”吧！ (10分)\n\n\n请在此处输入答案\n6、web页面实现文件下载的方式有几种？分别是什么？ (10分)\n\n\n请在此处输入答案\n7、http与https有什么区别？ (10分)\n\n\n请在此处输入答案\n8、\n\n\n//HTML\n\n\n\n\n\n\n\n//CSS\n#content-id{\n   color:red;\n}\n.content-class{\n   color:blue;\n}\ndiv{\n   color:grey;\n}\n最终div的color为什么？你知道选择器的优先级是怎样的吗？ (10分)\n\n\n请在此处输入答案\n9、（1）html引入css有几种方式，分别是哪些？ (5分)\n\n\n请在此处输入答案\n（2）尝试创建一个html文件和css文件，并将css引入到html（将引入css的那行代码作为答案提交）！（其他方法也可！） (5分)\n\n\n请在此处输入答案\n10、在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 180 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢从小到大排序。（例如，初始车厢顺序为592136487，你能告诉我用什么方法可以解决这样的问题？） (10分)\n\n\n请在此处输入答案\n11、在图论中，从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径。如下图所示，每个圆圈表示图中的一个顶点，每条有向线段表示一个顶点到另一个顶点的距离，分别求1号顶点到2、3、4、5、6号顶点的最短路径（无需给出确切答案，只需要思路） pic (10分)\n\n\n请在此处输入答案\n12、给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 编写一个程序或描述一种算法解决这个问题。 来源：力扣（LeetCode） 链接：\n\n      \n        \n力扣\n\n        \n      \n\n      \n\n      \n\n        \n\n          \nhttps://leetcode-cn.com/problems/coin-change\n\n        \n\n      \n 问：\n\n\n（1）、金额和面额这两个嵌套for循环的顺序，代码中是先遍历面额嵌套遍历金额还是先遍历金额嵌套遍历面额。 (2分)\n\n\n请在此处输入答案\n（2）遍历金额是顺序还是逆序，面额呢。为什么。 (2分)\n\n\n请在此处输入答案\n（3）将空间限制为O(amount），代码如何修改，上述问题是否有变化。 (2分)\n\n\n请在此处输入答案\n（4）将硬币数改为有限个，个数用数组num存储，代码如何修改，12两问有什么变化 (4分)\n\n\n请在此处输入答案\n13、 列出你所知道的机器学习算法。 (10分)\n\n\n请在此处输入答案\n14、python作为一门简单易懂的编程语言，常被用于处理机器学习方面的问题。那么，不妨让我们着手一试。 现假设有一场富有创意性的的新奇时装秀海选，派出的评委张三是一个瞎子，张三有一名助手，而助手不参加评价，只负责向张三提供以往评委的评价参考和各个参加海选的人的身体数据，如：声音，颧骨宽窄，眼睛大小，身高尺寸，腰围等数据。\n\n\n现要求张三将参选者进行分类，若张三可选择性使用评委的评价参考，提出你认为可行的机器学习算法 (2分)\n请在此处输入答案\n（2）在一番思考之后，张三决定按照评委的评价参考分出每一个人从属的类别，他选用了一种树状图的方法来将每一个海选者进行分类，也就是被叫做决策树的算法。\n\n\n已知在之前评委的评价中，给出了每个人声音尖锐与否，颧骨宽窄与否，身高尺寸区间，腰围区间，体重尺寸区间等数据表格，以此将每个人分为身材伟岸的猛男，身材瘦高的帅哥，中等身材的帅哥，身材高挑的美女，中等身材的美女等。\n\n\n在机器学习中，上述的每一个人被称作样本(sample)，他们的身体数据被叫作特征(feature),而每个人所属的类别，如：高大伟岸的猛男等，则叫作标签(label)。\n\n\n让我们来假设有一个样本，其特征如下：\n\n\n声音是否尖锐    颧骨是否宽    身高    腰围\n否(0)    是(1)    191cm    80cm\n对于每个特征所对应的具体值，我们通常叫作特征值(feature value)，而在离散数学里，对于“是(ture)”或“否(false)”通常我们使用”1“和”0“来表示。\n\n\n将每一个特征，分别用一个坐标轴（维度）表示，所组成的空间即为特征空间。\n\n\n按照表中的顺序，该样本的每一个特征值放入其对应的维度中，可表示为：\n\n\n[ 0 1 191 80]T 。这样的向量叫作特征向量(feature vector)。\n\n\n在一番大致的了解机器学习基本术语过后，再让我们来看看张三所采用的算法：\n\n\n决策树算法(Decision Tree)：\n\n\n所谓决策树，就是一个类似于流程图的树形结构，树内部的每一个节点代表的是对一个特征的测试，树的分支代表该特征的每一个测试结果，而树的每一个叶子节点代表一个类别。\n\n\n用作分类问题时，其具体过程可大致类似为下图：\n\n\n（图为用决策树判断西瓜好坏）\n\n\n123\n\n\n不纯度(impurity):\n\n\n采用基尼系数(Gini)计算:\n\n\n信息增益(Gain):\n\n\nGain_Gini\n\n\n现有如下信息:\n\n\n号牌    声音尖锐    颧骨宽    类别\n1    否    是    猛男\n2    否    否    帅哥\n3    否    否    帅哥\n4    否    否    帅哥\n5    否    是    猛男\n6    是    否    美女\n7    是    否    美女\n8    是    否    美女\n9    是    否    美女\n10    是    否    美女\n将声音尖锐与否，全国是否宽作为特征数据：\n\n\n表示出6号的特征向量。 计算出声音尖锐与否和颧骨是否宽的Gini系数，决定出两者中的上层节点并说明理由。 (6分)\n请在此处输入答案\n（3）对于张三的分类方法，你觉得还有什么缺陷吗？请提出你觉得存在的一种或多种缺陷和可能有效的改进方法。 (2分)\n\n\n请在此处输入答案\n15、阅读以下C代码，思考出该输入怎样的数据使程序输出结果为 Right!!!\n\n\n#include\n#include\nint main()\n{\n    int number;\n    scanf(\"%d\",&number);\n    number = abs(number);\n    number += 1024;\n    if(number < 1024){\n        printf(\"Rigth!!!\");\n        return 0;\n    }\n    printf(\"Wrong!!!\");\n    return 0;\n}\n(10分)\n\n\n请在此处输入答案\n16、阅读以下函数，输入一个int范围内[-2147483648,2147483647] ，即[-2^{31},2^{31}-1]的数据，试问输入数据为多少使得函数输出结果为 Rigth!!!\n\n\n函数说明：\n\n\n定义函数：int abs (int j); 函数说明：abs(j)用来计算参数$j$ 的绝对值，然后将结果返回。 返回值：返回参数$j$ 的绝对值结果\n\n\n#include\n#include\nint main()\n{\n    int number;\n    scanf(\"%d\",&number);\n    number = abs(number);\n    number += 1024;\n    if(number < 1024){\n        printf(\"Rigth!!!\");\n        return 0;\n    }\n    printf(\"Wrong!!!\");\n    return 0;\n}\n(10分)\n\n\n请在此处输入答案\n17、在 C/C++中，int 和 float 都是 4 字节，32 个比特。因此，对于任意连续的$32$个比特，可能表示某一个整数，也可能表示某一个浮点数。因此就存在某个浮点数在内存中存储的比特与某个整数的比特一致。\n\n\n求一个 float 型小数，使得它与 int 型整数 s= 1127398111(十六进制0x4332badf)在内存中的比特分布完全一致（不是值一致）！求出这个值。 (10分)", "Tag": "算法分析"}
{"Answer": "返回的是弧度不是角度2*pi 弧度=180角度所以45度就是3.1416/2，也就是0.785398，没毛病。", "Konwledge_Point": "边的长度", "Question": "为什么C++ cmath atan算的结果不对？\n我最近用C++的cmath头文件算东西，结果我发现atan函数算的结果似乎不对！\n这是代码：\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\nint\n \nmain\n()\n{\n    cout<<\natan\n(\n1\n);\n}\n\n\n\n按理说，两个直角边的比例是1，说明长度相同，所以返回应该是45，但实际效果是0.785398，为什么呢？\n而且，不光是atan，其他的sin cos tan asin acos也有问题\n如果我想用正常的运算，我该怎么做？", "Tag": "算法分析"}
{"Answer": "import java.util.Scanner;\nclass Circle implements Shape{\n    double dmyr;\n    Circle(){\n        dmyr = 0;\n    }\n    Circle(double dmyr){\n        this.dmyr = dmyr;\n        if(dmyr <= 0) this.dmyr = 0;\n    }\n    public double length() {\n        return 2 * 3.14 * dmyr;\n    }\n}\nclass Rectangle implements Shape{\n    double da, db;\n    Rectangle(){\n        this.da = this.db = 0;\n    }\n    Rectangle(double da){\n        this.da = this.db = 0;\n    }\n    Rectangle(double da, double db){\n        this.da = da;\n        this.db = db;\n        if(da <= 0 || db <= 0){\n            this.da = this.db = 0;\n        }\n    }\n    public double length() {\n        return 2 * (da + db);\n    }\n}\nclass Triangle implements Shape{\n    double da;\n    double db;\n    double dc;\n    Triangle(){\n        this.da = this.db = this.dc = 0;\n    }\n    Triangle(double da){\n        this.da = this.db = this.dc = 0;\n    }\n    Triangle(double da, double db){\n        this.da = this.db = this.dc = 0;\n    }\n    Triangle(double da, double db, double dc){\n        this.da = da;\n        this.db = db;\n        this.dc = dc;\n        if(da <= 0 || db <= 0 || dc <= 0 || !(da + db > dc && da + dc > db && db + dc > da)){\n            this.da = this.db = this.dc = 0;\n        }\n    }\n    public double length() {\n        return da + db + dc;\n    }\n}\ninterface Shape{\n    double length();\n}\npublic class Main {\n    public static void main(String[] args) {\n        Scanner dmy = new Scanner(System.in);\n        while(dmy.hasNextInt()) {\n            double[] l = new double[5];\n            String s;\n            s = dmy.nextLine();\n            String[] str = s.split(\" \");\n            int cnt = 0;\n            for (String value : str) {\n                l[cnt++] = Double.parseDouble(value);\n            }\n            if(cnt == 1){\n                Circle C = new Circle(l[0]);\n                System.out.printf(\"%.2f\\n\", C.length());\n            }\n            else if (cnt == 2){\n                Rectangle r = new Rectangle(l[0], l[1]);\n                System.out.printf(\"%.2f\\n\", r.length());\n            }\n            else{\n                Triangle t = new Triangle(l[0], l[1], l[2]);\n                System.out.printf(\"%.2f\\n\", t.length());\n            }\n        }\n    }\n}\n\n\n", "Konwledge_Point": "边的长度", "Question": "计算各种图形的周长（多态）更\n定义接口或类 Shape，定义求周长的方法length()。\n\n\n定义如下类，实现接口Shape或父类Shape的方法。\n\n\n（1）三角形类Triangle （2）长方形类Rectangle （3）圆形类Circle等。\n\n\n定义测试类ShapeTest，用Shape接口（或类）定义变量shape，用其指向不同类形的对象，输出各种图形的周长。并为其他的Shape接口实现类提供良好的扩展性。\n\n\n提示： 计算圆周长时PI取3.14。\n\n\n输入格式:\n输入多组数值型数据（double）；\n\n\n一行中若有1个数，表示圆的半径；\n\n\n一行中若有2个数（中间用空格间隔），表示长方形的长度、宽度。\n\n\n一行中若有3个数（中间用空格间隔），表示三角形的三边的长度。（需要判断三个边长是否能构成三角形）\n\n\n若输入数据中有0或负数，则不表示任何图形，周长为0。\n\n\n我的代码：\n\n\npackage com.sxt;\n\nimport\n java.util.Scanner;\n\npublic\n \nclass\n \nShapeTest\n {\n\n    \npublic\n static \nvoid\n main(String[] args) {\n        \n// TODO 自动生成的方法存根\n\n        Scanner sc=new Scanner(System.\nin\n);\n        Shape shape;\n        \nwhile\n(sc.hasNextDouble()) {\n            \ndouble\n a = sc.nextDouble();\n            \nif\n (a <= \n0\n) {\n                System.\nout\n.println(\n\"0.00\"\n);\n                \ncontinue\n;\n            }\n            \nif\n (sc.hasNextDouble()) {\n//长方形\n\n                \ndouble\n b = sc.nextDouble();\n                \nif\n (b <= \n0\n) {\n                    System.\nout\n.println(\n\"0.00\"\n);\n                }\n                \nelse\n {\n                    shape = new Rectangle(a,b);\n                    System.\nout\n.printf(\n\"%.2f\"\n,shape.length());\n                    System.\nout\n.println();\n                }\n            } \nelse\n \nif\n (sc.hasNextDouble()) {\n//三角形\n\n                \ndouble\n b = sc.nextDouble();\n                \ndouble\n c = sc.nextDouble();\n                shape = new Triangle(a,b,c);\n                System.\nout\n.printf(\n\"%.2f\"\n,shape.length());\n                System.\nout\n.println();\n            }\n            \nelse\n {\n//圆形\n\n                shape = new Circle(a);\n                System.\nout\n.printf(\n\"%.2f\"\n,shape.length());\n                System.\nout\n.println();\n            }\n        }\n        sc.close();\n    }\n}\n\ninterface\n \nShape\n {\n    \ndouble\n length();\n}\n\nclass\n \nTriangle\n \nimplements\n \nShape\n{\n//三角形\n\n    \nprivate\n \ndouble\n a,b,c;\n    \npublic\n Triangle(\ndouble\n a, \ndouble\n b, \ndouble\n c) {\n        \nthis\n.a=a;\n        \nthis\n.b=b;\n        \nthis\n.c=c;\n    }\n\n    \npublic\n \ndouble\n length() {\n        \nif\n(a<=\n0\n||b<=\n0\n||c<=\n0\n) {\n            \nreturn\n \n0\n;\n        }\n        \nelse\n \nif\n(a+b<=c||a+c<=b||b+c<=a) {\n            \nreturn\n \n0\n;\n        }\n        \nelse\n {\n            \nreturn\n a+b+c;\n        }\n    }\n}\n\nclass\n \nRectangle\n \nimplements\n \nShape\n{\n//长方形\n\n    \nprivate\n \ndouble\n a,b;\n    \npublic\n Rectangle(\ndouble\n a,\ndouble\n b){\n        \nthis\n.a=a;\n        \nthis\n.b=b;\n    }\n    \npublic\n \ndouble\n length(){\n        \nif\n(a<=\n0\n||b<=\n0\n) {\n            \nreturn\n \n0\n;\n        }\n        \nelse\n {\n            \nreturn\n \n2\n*(a+b);\n        }\n    }\n}\n\nclass\n \nCircle\n \nimplements\n \nShape\n{\n//圆形\n\n    \nprivate\n \ndouble\n radius;\n    \npublic\n Circle (\ndouble\n radius){\n        \nthis\n.radius=radius;\n    }\n    \npublic\n \ndouble\n length() {\n        \nif\n(radius<=\n0\n){\n            \nreturn\n \n0\n;\n        }\n        \nelse\n {\n            \nreturn\n \n2\n*\n3.14\n*radius;\n        }\n    }\n}\n\n\n\n我的运行结果怎么是这样？\n好像只执行了长方形类，怎么修改？\n怎么让它实现，我输入几个数字就输出对应图形的周长？", "Tag": "算法分析"}
{"Answer": "public interface Shape {\n     double length();\n}\n\npublic class Circle implements Shape {\n    private double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    public double length() {\n        if (radius <= 0) {\n            // 圆不合法\n            return 0;\n        }\n        return 2 * 3.14 * radius;\n    }\n}\n\n\npublic class Rectangle implements Shape {\n    private double length;\n    private double width;\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n    public double length() {\n        if (length <= 0 || width <= 0) {\n            // 长方形不合法\n            return 0;\n        }\n        return 2 * (length + width);\n    }\n}\n \n\n\npublic class Triangle implements Shape {\n    private double a;\n    private double b;\n    private double c;\n    public Triangle(double a, double b, double c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    public double length() {\n        if (a + b <= c || a + c <= b || b + c <= a) {\n            // 三角形不合法\n            return 0;\n        }\n        return a + b + c;\n    }\n}\n\n\npublic class ShapeTest {\n     public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            while (sc.hasNext()) {\n                double a = sc.nextDouble();\n                if (a <= 0) {\n                    // 不合法的输入，周长为0\n                    System.out.println(0);\n                    continue;\n                }\n                Shape shape;\n                if (sc.hasNextDouble()) {\n                    // 长方形\n                    double b = sc.nextDouble();\n                    shape = new Rectangle(a, b);\n                } else if (sc.hasNextDouble()) {\n                    // 三角形\n                    double b = sc.nextDouble();\n                    double c = sc.nextDouble();\n                    shape = new Triangle(a, b, c);\n                } else {\n                    // 圆形\n                    shape = new Circle(a);\n                }\n                System.out.println(shape.length());\n            }\n            sc.close();\n        }\n}                  \n\n\n", "Konwledge_Point": "边的长度", "Question": "计算各种图形的周长（多态）\n义接口或类 Shape，定义求周长的方法length()。\n\n\n定义如下类，实现接口Shape或父类Shape的方法。\n\n\n（1）三角形类Triangle （2）长方形类Rectangle （3）圆形类Circle等。\n\n\n定义测试类ShapeTest，用Shape接口（或类）定义变量shape，用其指向不同类形的对象，输出各种图形的周长。并为其他的Shape接口实现类提供良好的扩展性。\n\n\n提示： 计算圆周长时PI取3.14。\n\n\n输入格式:\n输入多组数值型数据（double）；\n\n\n一行中若有1个数，表示圆的半径；\n\n\n一行中若有2个数（中间用空格间隔），表示长方形的长度、宽度。\n\n\n一行中若有3个数（中间用空格间隔），表示三角形的三边的长度。（需要判断三个边长是否能构成三角形）\n\n\n若输入数据中有0或负数，则不表示任何图形，周长为0。\n\n\npackage\n com.sxt;\n\nimport\n java.util.Scanner;\n\npublic\n \nclass\n \nShapeTest\n {\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n {\n        \n// TODO 自动生成的方法存根\n\n        Scanner sc=\nnew\n \nScanner\n(System.in);\n        Shape shape;\n        \nwhile\n(sc.hasNextDouble()) {\n            \ndouble\n \na\n \n=\n sc.nextDouble();\n            \nif\n (a <= \n0\n) {\n                System.out.println(\n\"0.00\"\n);\n                \ncontinue\n;\n            }\n            \nif\n (sc.hasNextDouble()) {\n//长方形\n\n                \ndouble\n \nb\n \n=\n sc.nextDouble();\n                \nif\n (b <= \n0\n) {\n                    System.out.println(\n\"0.00\"\n);\n                    \ncontinue\n;\n                }\n                \nelse\n {\n                    shape = \nnew\n \nRectangle\n(a,b);\n                    System.out.printf(\n\"%.2f\"\n,shape.length());\n                }\n            } \nelse\n \nif\n (sc.hasNextDouble()) {\n//三角形\n\n                \ndouble\n \nb\n \n=\n sc.nextDouble();\n                \ndouble\n \nc\n \n=\n sc.nextDouble();\n                shape = \nnew\n \nTriangle\n(a,b,c);\n                System.out.printf(\n\"%.2f\"\n,shape.length());\n            }\n            \nelse\n {\n//圆形\n\n                shape = \nnew\n \nCircle\n(a);\n                System.out.printf(\n\"%.2f\"\n,shape.length());\n            }\n        }\n            sc.close();\n        }\n        }\n    \ninterface\n \nShape\n {\n        \ndouble\n \nlength\n()\n;\n    }\n    \nclass\n \nTriangle\n \nimplements\n \nShape\n{\n//三角形\n\n        \nprivate\n \ndouble\n a,b,c;\n        \npublic\n \nvoid\n \nTriangle\n(\ndouble\n a,\ndouble\n b,\ndouble\n c)\n{\n            \nthis\n.a=a;\n            \nthis\n.b=b;\n            \nthis\n.c=c;\n        }\n        \npublic\n \ndouble\n \nlength\n()\n {\n            \nif\n(a<=\n0\n||b<=\n0\n||c<=\n0\n) {\n                \nreturn\n \n0\n;\n            }\n            \nelse\n \nif\n(a+b<=c||a+c<=b||b+c<=a) {\n                \nreturn\n \n0\n;\n            }\n            \nelse\n {\n                \nreturn\n a+b+c;\n            }\n        }\n    }\n    \nclass\n \nRectangle\n \nimplements\n \nShape\n{\n//长方形\n\n        \nprivate\n \ndouble\n a,b;\n        \npublic\n \nvoid\n \nRectangle\n(\ndouble\n a,\ndouble\n b)\n{\n            \nthis\n.a=a;\n            \nthis\n.b=b;\n        }\n        \npublic\n \ndouble\n \nlength\n()\n{\n            \nif\n(a<=\n0\n||b<=\n0\n) {\n                \nreturn\n \n0\n;\n            }\n            \nelse\n {\n                \nreturn\n \n2\n*(a+b);\n            }\n        }\n    }\n    \nclass\n \nCircle\n \nimplements\n \nShape\n{\n//圆形\n\n        \nprivate\n \ndouble\n radius;\n        \npublic\n \nvoid\n \nCircle\n \n(\ndouble\n radius)\n{\n            \nthis\n.radius=radius;\n        }\n        \npublic\n \ndouble\n \nlength\n()\n {\n            \nif\n(radius<=\n0\n){\n                \nreturn\n \n0\n;\n            }\n            \nelse\n {\n                \nreturn\n \n2\n*\n3.14\n*radius;\n            }\n        }\n    }\n\n\n\n为什么会有这样的提示？应该怎么更改？", "Tag": "算法分析"}
{"Answer": "float=sqrt(c);改成c=sqrt(c);\n你题目的解答代码如下：\n#include<stdio.h>\n#include<math.h>\nvoid main()\n{\nfloat a,b,c;\nscanf(\"%f,%f\",&a,&b);\nc=a*a+b*b;\nc=sqrt(c);\nprintf(\"c=%f\",c);\n}\n\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "边的长度", "Question": "输入直角三角形的两边长，输出斜边长\n我想算输入直角三角形的两条直角边长，输出斜边长度，结果保留2位小数的程序。，但我不知道怎么出错了\n#include\nvoid main()\n{\n    float a,b,c;\n    scanf(\"%f,%f\",&a,&b);\n    c=a\na+b\nb;\n    float=sqrt(c);\n    printf(\"c=%f\",c);\n}", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：（如有帮助，望采纳！谢谢! 点击我这个回答右上方的【采纳】按钮）\nimport java.util.Scanner;\nimport java.lang.Math;\n \nclass TriangleArea{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double a,b,c,s,n;\n        a=sc.nextDouble();\n        b=sc.nextDouble();\n        c=sc.nextDouble();\n        if(a+b>c && a-b<c){\n            s = (a+b+c)/2;\n            n = Math.sqrt( s*(s-a)*(s-b)*(s-c) );\n            System.out.println(String.format(\"%.3f\", n));\n        }else{\n            System.out.println(\"不满足三角形构成条件\");\n        }\n    }\n}\n", "Konwledge_Point": "边的长度", "Question": "请教Java行家，初学者不是很懂\n若已知三角形三个边的长度分别为a,b,c（并假设三个边长度的单位一致，在本编程题中忽略其单位），则可以利用公式:\n  求得三角形的面积，其中：s=(a+b+c)/2。编程实现从控制台读入以整数表示的三个边的长度（假设输入的长度肯定可以形成三角形），求平方根函数Math.sqrt(double n),然后利用上述公式计算面积并输出，结果小数点后保留3位有效数字。", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n好的，对于这个问题，我们可以使用三角函数来计算直角三角形的面积。具体流程如下：\n输入直角三角形的斜边长和一个锐角的度数；利用三角函数计算直角三角形的底边长和高度；根据底边长和高度计算面积；输出结果。\n具体的代码如下（假设输入的斜边长和角度分别为 c 和 alpha）：\nimport math\nalpha = float(input(\"请输入锐角的度数：\"))c = float(input(\"请输入斜边长：\"))\n计算底边长和高度\na = c * math.sin(math.radians(alpha))b = c * math.cos(math.radians(alpha))\n计算面积\ns = 0.5 * a * b\nprint(\"三角形的面积为：\", s)\n以上代码会输出计算出的直角三角形面积。希望我的回答能够帮到您！", "Konwledge_Point": "边的长度", "Question": "编写程序，实现输入直角三角形的斜边长和一个锐角的度数，输出其面积\n编写程序，实现输入直角三角形的斜边长和一个锐角的度数，输出其面积", "Tag": "算法分析"}
{"Answer": "因为没有看到你提供的求三角形面积的公式，我搜索了一个求三角形面积的办法求解，如下：参考链接：C 库函数 – sqrt() | 菜鸟教程已知三角形的三边长如何求面积？_百度知道\n\n#include <stdio.h>\n#include <math.h>\n\nint main(void){\n    \n    int a,b,c;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    \n    double p = 1.0/2*(a+b+c);\n    \n    double s = sqrt(p*(p-a)*(p-b)*(p-c));\n    \n    printf(\"%f\",s);\n    \n    return 0;\n     \n} \n\n", "Konwledge_Point": "边的长度", "Question": "3 6关于#c语言#的问题：从键盘输入3个整数作为一个三角形的三条边长，值保存到3个变量a、b、c中，计算并输出该三角形面积\n从键盘输入3个整数作为一个三角形的三条边长，值保存到3个变量a、b、c中，计算并输出该三角形面积。三角形面积的计算公式为：\n\n\n测试数据：当a=2，b=3，c=2时，运行结果为1.984313", "Tag": "算法分析"}
{"Answer": "两个问题，一个是scanf 应该是 %d，因为是整数一个是逻辑错误，等腰直角三角形在你这里判断不了直角", "Konwledge_Point": "边的长度", "Question": "输入三边长度 判断类型是直角三角形等边三角形等腰三角形还是一般三角形\n\n\n为啥输入最终判断有误哇，我有个困惑1. a,b,c有先后顺序啊？所以讨论关系要多讨论几次咯？,2.三边关系条件我写得对叭 谢谢啦", "Tag": "算法分析"}
{"Answer": "\ndef is_triangle(a=0, b=0, c=0): #abc 三条边长\n    A = [a,b,c]\n    A.sort() #升序排序\n    if A[2] < A[1] +A[0]:\n        print(\"{} is triangle\".format(A))\n    else:\n        print(\"不构成三角\")\n\n\nis_triangle(11,20,30); #[11, 20, 30] is triangle\n ", "Konwledge_Point": "边的长度", "Question": "输入三边，判断其是否构成三角形\nPython\n\n\n\n判断三边是否为三角形的代码", "Tag": "算法分析"}
{"Answer": "\nIf you're worried about the line length you could simply split your if statement onto multiple lines to make it more readable:\nif     (firstNum  + secondNum > thirdNum)\n    && (firstNum  + thirdNum  > secondNum)\n    && (secondNum + thirdNum  > firstNum) {\n    fmt.Println(\"A triangle can be built\")\n} else {\n    fmt.Println(\"A triangle can't be built\")\n}\n\n", "Konwledge_Point": "边的长度", "Question": "该程序检查是否可以使用给定长度的边来构建三角形。 如何缩短中频条件？\n\n\n\nI wrote a simple GO program to asks the user for three integers (firstNum, secondNum, and thirdNum). I'm using the triangle inequality to determine if a triangle can be built using those three integers:\n\n\n\nA (firstNum) + B (secondNum) > C (thirdNum)\n\n\n\nA (firstNum) + C (thirdNum) > B (secondNum)\n\n\n\nB (secondNum) + C (thirdNum) > A (firstNum)\n\n\n\nThe program works fine if I use the following IF statement (see below), but the conditions make the statement a bit too long. I know I can also use nested IF statements but I'm wondering if there's a better way to do it.\n\n\n\nif (firstNum+secondNum > thirdNum) && (firstNum+thirdNum > secondNum) && (secondNum+thirdNum > firstNum) {\n    fmt.Println(\"A triangle can be built\")\n} else {\n    fmt.Println(\"A triangle can't be built\")\n}\n\n\n\n\nThank you!\n\n    ", "Tag": "算法分析"}
{"Answer": "\n \n#include <stdio.h>\n#include <math.h>\nint main() {\n double a,b,c,A,B;\n scanf(\"%lf%lf\",&a,&b);\n c=sqrt(a*a+b*b);\n A=atan(a,b)/M_PI*180;\n B=90.0-A;\n printf(\"c=%.1lf\\np=%.1lf\\ns=%.1lf\\nA=.0lf\\nB=%.0lf\\nA=%.1lf\\nB=%.1lf\\n\",c,a+b+c,a*b/2,A,B,A,B);\n return 0;\n}\n", "Konwledge_Point": "边的长度", "Question": "c语言 输入直角三角形的两条直角边a，b\n", "Tag": "算法分析"}
{"Answer": "直角三角形的基本特点是满足勾股定理，写个简单的判断就可以了。", "Konwledge_Point": "边的长度", "Question": "Java语言高分悬赏：输入三角形的3条边，判断三角形是不是直角三角形，怎么判断呢\nJava语言高分悬赏：输入三角形的3条边，判断三角形是不是直角三角形，怎么判断呢", "Tag": "算法分析"}
{"Answer": "算法思路：定义判断各种三角形的规则，然后走不同分支输出结果，这里有一个完整的 Java 实现的，可以参考：\r\nhttps://blog.csdn.net/yuxiangaaaaa/article/details/78292251", "Konwledge_Point": "边的长度", "Question": "高分悬赏，给出三角形的三条边a,b,c，从键盘输入，然后判断它是什么类型的三角形（直角、等边、等腰或者不是三角形）\n高分悬赏，给出三角形的三条边a,b,c，从键盘输入，然后判断它是什么类型的三角形（直角、等边、等腰或者不是三角形）", "Tag": "算法分析"}
{"Answer": "是没编译成功嘛，代码没错的", "Konwledge_Point": "边的长度", "Question": "请输入三条边长，判断这三条边能否构成三角形，若能构成三角形，则继续判断该三角形是属于等边三角形、等腰三角形还是一般三角形。（判断三条边能否构成三角形的条件是任意两条边之和总是大于第三边）\n#include\nint main()\n{\n    int a=0,b=0,c=0;\n    printf(\"please input a,b,c: \");\n    scanf(\"%d,%d,%d\",&a,&b,&c);\n    if(a!=0 && b!=0 && c!=0)\n  {\n       if(a+b>c && b+c>a && a+c>b)\n         {\n           if(a==b ||a==c ||b==c)\n               {if(a==b&&b==c)\n                 printf(\"Equilateral triangle\");\n                 else\n                 printf(\"isosceles triangle\");\n                }\n          else\n          printf(\"General triangle\");\n          }\n         else\n         printf(\"Cannon form a triangle\");\n    }\nreturn 0;\n}\n运行编译的时候输入了数字5,5,5，出现的编译结果是空白，并没有输出Equilateral。", "Tag": "算法分析"}
{"Answer": "回答如下，记得采纳哦！\n# 输入三角形的三边长\na <- 3\nb <- 4\nc <- 5\n\n# 判断是否能构成三角形\nif ((a + b > c) && (a + c > b) && (b + c > a)) {\n  if (a == b && b == c) {\n    print(\"等边三角形\")\n  } else if (a == b || a == c || b == c) {\n    print(\"等腰三角形\")\n  } else {\n    print(\"普通三角形\")\n  }\n} else {\n  print(\"不能构成三角形\")\n}\n", "Konwledge_Point": "边的长度", "Question": "输入三条线段的长度，判断能否构成三角形，构成什么样的三角形\n能构成三角形，判断构成等边三角形还是等腰三角形还是普通三角形，不能构成三角形则说明不能构成三角形", "Tag": "算法分析"}
{"Answer": "\nimport math\nclass Triangle(object):\n    def __init__(self,a,b,c):\n        self.a = a\n        self.b = b\n        self.c = c\n    \n    # 获取面积\n    def get_area(self): \n        # 三角形面积公式,根据三边\n        return 1/4 * math.sqrt((self.a + self.b + self.c) * (self.a + self.b -self.c) \n                               * (self.a + self.c - self.b) * (self.b + self.c - self.a))\n    \n    # 获取周长\n    def get_permeter(self):\n        return self.a + self.b + self.c\n    \ntrig = Triangle(2,3,4)\narea = trig.get_area()\npermeter = trig.get_permeter()\nprint(\"面积: {:.2f},周长: {}\".format(area,permeter))\n\n结果:\n\n如果觉得答案对你有帮助,请点击下采纳,谢谢~", "Konwledge_Point": "边的长度", "Question": "python创建类Triangle求三角形面积和周长\n创建类Triangle,计算三角形的周长和面积,并创建两个实例进行检测。", "Tag": "算法分析"}
{"Answer": "你用的什么编译器，不是所有的编译器都支持long long\r\n用GCC 14看看", "Konwledge_Point": "边的长度", "Question": "计算最长的异或路径，请看下这个程序怎么修改\n#include \n\n#include \n\n#include \n\n#include \n\n#include \n\n#include \n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 100005;\n\n\n\nint n;\n\nstruct Edge {\n\n    int v, w, nex;\n\n    Edge() {}\n\n    Edge(int v, int w, int nex) : v(v), w(w), nex(nex) {}\n\n};\n\nEdge e[N << 1];\n\nint head[N], tot;\n\nvoid add(int u, int v, int w) {\n\n    e[tot] = Edge(v, w, head[u]);\n\n    head[u] = tot++;\n\n}\n\nvoid read() {\n\n    memset(head, -1, sizeof head);\n\n    tot = 0;\n\n    int u, v, w;\n\n    for(int i = 1; i < n; ++i) {\n\n        scanf(\"%d%d%d\", &u, &v, &w);\n\n        add(u, v, w);\n\n        add(v, u, w);\n\n    }\n\n}\n\nint d[N], vis[N];\n\nvoid bfs() {\n\n    queue que;\n\n    que.push(0);\n\n    d[0] = 0;\n\n    memset(vis, 0, sizeof vis);\n\n    int u, v, w;\n\n    vis[0] = 1;\n\n    while(!que.empty()) {\n\n        u = que.front(); que.pop();\n\n        for(int i = head[u]; ~i; i = e[i].nex) {\n\n            v = e[i].v; w = e[i].w;\n\n            if(vis[v]) continue;\n\n            d[v] = d[u] ^ w;\n\n            vis[v] = 1;\n\n            que.push(v);\n\n        }\n\n    }\n\n}\n\nint ch[N * 32][2];\n\nstruct Trie {\n\n    int sz;\n\n    Trie() { sz = 1; memset(ch[0], 0, sizeof ch[0]); }\n\n    void _insert(int bs[]) {\n\n        int u = 0;\n\n        for(int i = 30; i >= 0; --i) {\n\n            int c = bs[i];\n\n            if(!ch[u][c]) {\n\n                memset(ch[sz], 0, sizeof ch[sz]);\n\n                ch[u][c] = sz++;\n\n            }\n\n            u = ch[u][c];\n\n        }\n\n    }\n\n    int _search(int bs[]) {\n\n        int u = 0, ans = 0;\n\n        for(int i = 30; i >= 0; --i) {\n\n            int c = bs[i];\n\n            if(c == 1) {\n\n                if(ch[u][0]) { ans += (1 << (i)); u = ch[u][0]; }\n\n                else u = ch[u][1];\n\n            }else {\n\n                if(ch[u][1]) { ans += (1 << (i)); u = ch[u][1]; }\n\n                else u = ch[u][0];\n\n            }\n\n        }\n\n        return ans;\n\n    }\n\n};\n\n\n\nint ans;\n\nint b[35];\n\nvoid get(int x) {\n\n    int ls = 0;\n\n    memset(b, 0, sizeof b);\n\n    while(x) {\n\n        b[ls++] = x % 2;\n\n        x >>= 1;\n\n    }\n\n}\n\nvoid solve() {\n\n    Trie mytrie;\n\n    ans = 0;\n\n    for(int i = 0; i < n; ++i) {\n\n        get(d[i]);\n\n        mytrie._insert(b);\n\n        ans = max(ans, mytrie._search(b));\n\n    }\n\n    printf(\"%d\\n\", ans);\n\n}\n\nint main() {\n\n   // freopen(\"in.txt\", \"r\", stdin);\n\n    while(~scanf(\"%d\", &n)) {\n\n        read();\n\n        bfs();\n\n        solve();\n\n    }\n\n}", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n#include \r\nint main()\r\n{\r\n    int a,b,c;\r\n    scanf(\"%d %d %d\",&a,&b,&c);\r\n    if(((a+b)>c) && ((b+c)>a) && ((a+c)>b))\r\n    {\r\n        double p = (a+b+c)/2.0;\r\n        double S = sqrt(p*(p-a)*(p-b)*(p-c));\r\n        printf(\"S=%0.2lf\\n\",S);\r\n    }\r\n    else\r\n        printf(\"no\\n\");\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "边的长度", "Question": "构成三角形不会做大佬看看\n构成三角形\n\n描述\n\n给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。若能，请给出三角形的面积。\n\n输入\n\n共1行，三个正整数x、y、z（0<x,y,z<=1000000）表示三条线段的长度。\n\n输出\n\n共1行。若可以构成三角形，输出三角形的面积（保留两位小数），否则输出”no”。不要输出双引号。\n\n输入样例 1 \n\n1 2 3\n\n输出样例 1\n\nno\n\n提示\n\n1. 若三角形三条边的长度为a，b，c，则其面积可以写为：\n\nS = √(p*(p-a)*(p-b)*(p-c))\n\n其中p=(a+b+c)/2，√表示平方根。\n\n2. C++中用sqrt表示平方根，比如sqrt(4) 的值为2.0。", "Tag": "算法分析"}
{"Answer": "float=sqrt(c);改成c=sqrt(c);\n你题目的解答代码如下：\n#include<stdio.h>\n#include<math.h>\nvoid main()\n{\nfloat a,b,c;\nscanf(\"%f,%f\",&a,&b);\nc=a*a+b*b;\nc=sqrt(c);\nprintf(\"c=%f\",c);\n}\n\n\n\n如有帮助，请点击我的回答下方的【采纳该答案】按钮帮忙采纳下，谢谢!\n", "Konwledge_Point": "边的长度", "Question": "输入直角三角形的两边长，输出斜边长\n我想算输入直角三角形的两条直角边长，输出斜边长度，结果保留2位小数的程序。，但我不知道怎么出错了\n#include\nvoid main()\n{\n    float a,b,c;\n    scanf(\"%f,%f\",&a,&b);\n    c=a\na+b\nb;\n    float=sqrt(c);\n    printf(\"c=%f\",c);\n}", "Tag": "算法分析"}
{"Answer": "你题目的解答代码如下：（如有帮助，望采纳！谢谢! 点击我这个回答右上方的【采纳】按钮）\nimport java.util.Scanner;\nimport java.lang.Math;\n \nclass TriangleArea{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        double a,b,c,s,n;\n        a=sc.nextDouble();\n        b=sc.nextDouble();\n        c=sc.nextDouble();\n        if(a+b>c && a-b<c){\n            s = (a+b+c)/2;\n            n = Math.sqrt( s*(s-a)*(s-b)*(s-c) );\n            System.out.println(String.format(\"%.3f\", n));\n        }else{\n            System.out.println(\"不满足三角形构成条件\");\n        }\n    }\n}\n", "Konwledge_Point": "边的长度", "Question": "请教Java行家，初学者不是很懂\n若已知三角形三个边的长度分别为a,b,c（并假设三个边长度的单位一致，在本编程题中忽略其单位），则可以利用公式:\n  求得三角形的面积，其中：s=(a+b+c)/2。编程实现从控制台读入以整数表示的三个边的长度（假设输入的长度肯定可以形成三角形），求平方根函数Math.sqrt(double n),然后利用上述公式计算面积并输出，结果小数点后保留3位有效数字。", "Tag": "算法分析"}
{"Answer": "参考GPT和自己的思路：\n好的，对于这个问题，我们可以使用三角函数来计算直角三角形的面积。具体流程如下：\n输入直角三角形的斜边长和一个锐角的度数；利用三角函数计算直角三角形的底边长和高度；根据底边长和高度计算面积；输出结果。\n具体的代码如下（假设输入的斜边长和角度分别为 c 和 alpha）：\nimport math\nalpha = float(input(\"请输入锐角的度数：\"))c = float(input(\"请输入斜边长：\"))\n计算底边长和高度\na = c * math.sin(math.radians(alpha))b = c * math.cos(math.radians(alpha))\n计算面积\ns = 0.5 * a * b\nprint(\"三角形的面积为：\", s)\n以上代码会输出计算出的直角三角形面积。希望我的回答能够帮到您！", "Konwledge_Point": "边的长度", "Question": "编写程序，实现输入直角三角形的斜边长和一个锐角的度数，输出其面积\n编写程序，实现输入直角三角形的斜边长和一个锐角的度数，输出其面积", "Tag": "算法分析"}
{"Answer": "因为没有看到你提供的求三角形面积的公式，我搜索了一个求三角形面积的办法求解，如下：参考链接：C 库函数 – sqrt() | 菜鸟教程已知三角形的三边长如何求面积？_百度知道\n\n#include <stdio.h>\n#include <math.h>\n\nint main(void){\n    \n    int a,b,c;\n    scanf(\"%d%d%d\",&a,&b,&c);\n    \n    double p = 1.0/2*(a+b+c);\n    \n    double s = sqrt(p*(p-a)*(p-b)*(p-c));\n    \n    printf(\"%f\",s);\n    \n    return 0;\n     \n} \n\n", "Konwledge_Point": "边的长度", "Question": "3 6关于#c语言#的问题：从键盘输入3个整数作为一个三角形的三条边长，值保存到3个变量a、b、c中，计算并输出该三角形面积\n从键盘输入3个整数作为一个三角形的三条边长，值保存到3个变量a、b、c中，计算并输出该三角形面积。三角形面积的计算公式为：\n\n\n测试数据：当a=2，b=3，c=2时，运行结果为1.984313", "Tag": "算法分析"}
{"Answer": "两个问题，一个是scanf 应该是 %d，因为是整数一个是逻辑错误，等腰直角三角形在你这里判断不了直角", "Konwledge_Point": "边的长度", "Question": "输入三边长度 判断类型是直角三角形等边三角形等腰三角形还是一般三角形\n\n\n为啥输入最终判断有误哇，我有个困惑1. a,b,c有先后顺序啊？所以讨论关系要多讨论几次咯？,2.三边关系条件我写得对叭 谢谢啦", "Tag": "算法分析"}
{"Answer": "\ndef is_triangle(a=0, b=0, c=0): #abc 三条边长\n    A = [a,b,c]\n    A.sort() #升序排序\n    if A[2] < A[1] +A[0]:\n        print(\"{} is triangle\".format(A))\n    else:\n        print(\"不构成三角\")\n\n\nis_triangle(11,20,30); #[11, 20, 30] is triangle\n ", "Konwledge_Point": "边的长度", "Question": "输入三边，判断其是否构成三角形\nPython\n\n\n\n判断三边是否为三角形的代码", "Tag": "算法分析"}
{"Answer": "\nIf you're worried about the line length you could simply split your if statement onto multiple lines to make it more readable:\nif     (firstNum  + secondNum > thirdNum)\n    && (firstNum  + thirdNum  > secondNum)\n    && (secondNum + thirdNum  > firstNum) {\n    fmt.Println(\"A triangle can be built\")\n} else {\n    fmt.Println(\"A triangle can't be built\")\n}\n\n", "Konwledge_Point": "边的长度", "Question": "该程序检查是否可以使用给定长度的边来构建三角形。 如何缩短中频条件？\n\n\n\nI wrote a simple GO program to asks the user for three integers (firstNum, secondNum, and thirdNum). I'm using the triangle inequality to determine if a triangle can be built using those three integers:\n\n\n\nA (firstNum) + B (secondNum) > C (thirdNum)\n\n\n\nA (firstNum) + C (thirdNum) > B (secondNum)\n\n\n\nB (secondNum) + C (thirdNum) > A (firstNum)\n\n\n\nThe program works fine if I use the following IF statement (see below), but the conditions make the statement a bit too long. I know I can also use nested IF statements but I'm wondering if there's a better way to do it.\n\n\n\nif (firstNum+secondNum > thirdNum) && (firstNum+thirdNum > secondNum) && (secondNum+thirdNum > firstNum) {\n    fmt.Println(\"A triangle can be built\")\n} else {\n    fmt.Println(\"A triangle can't be built\")\n}\n\n\n\n\nThank you!\n\n    ", "Tag": "算法分析"}
{"Answer": "\n \n#include <stdio.h>\n#include <math.h>\nint main() {\n double a,b,c,A,B;\n scanf(\"%lf%lf\",&a,&b);\n c=sqrt(a*a+b*b);\n A=atan(a,b)/M_PI*180;\n B=90.0-A;\n printf(\"c=%.1lf\\np=%.1lf\\ns=%.1lf\\nA=.0lf\\nB=%.0lf\\nA=%.1lf\\nB=%.1lf\\n\",c,a+b+c,a*b/2,A,B,A,B);\n return 0;\n}\n", "Konwledge_Point": "边的长度", "Question": "c语言 输入直角三角形的两条直角边a，b\n", "Tag": "算法分析"}
{"Answer": "直角三角形的基本特点是满足勾股定理，写个简单的判断就可以了。", "Konwledge_Point": "边的长度", "Question": "Java语言高分悬赏：输入三角形的3条边，判断三角形是不是直角三角形，怎么判断呢\nJava语言高分悬赏：输入三角形的3条边，判断三角形是不是直角三角形，怎么判断呢", "Tag": "算法分析"}
{"Answer": "算法思路：定义判断各种三角形的规则，然后走不同分支输出结果，这里有一个完整的 Java 实现的，可以参考：\r\nhttps://blog.csdn.net/yuxiangaaaaa/article/details/78292251", "Konwledge_Point": "边的长度", "Question": "高分悬赏，给出三角形的三条边a,b,c，从键盘输入，然后判断它是什么类型的三角形（直角、等边、等腰或者不是三角形）\n高分悬赏，给出三角形的三条边a,b,c，从键盘输入，然后判断它是什么类型的三角形（直角、等边、等腰或者不是三角形）", "Tag": "算法分析"}
{"Answer": "是没编译成功嘛，代码没错的", "Konwledge_Point": "边的长度", "Question": "请输入三条边长，判断这三条边能否构成三角形，若能构成三角形，则继续判断该三角形是属于等边三角形、等腰三角形还是一般三角形。（判断三条边能否构成三角形的条件是任意两条边之和总是大于第三边）\n#include\nint main()\n{\n    int a=0,b=0,c=0;\n    printf(\"please input a,b,c: \");\n    scanf(\"%d,%d,%d\",&a,&b,&c);\n    if(a!=0 && b!=0 && c!=0)\n  {\n       if(a+b>c && b+c>a && a+c>b)\n         {\n           if(a==b ||a==c ||b==c)\n               {if(a==b&&b==c)\n                 printf(\"Equilateral triangle\");\n                 else\n                 printf(\"isosceles triangle\");\n                }\n          else\n          printf(\"General triangle\");\n          }\n         else\n         printf(\"Cannon form a triangle\");\n    }\nreturn 0;\n}\n运行编译的时候输入了数字5,5,5，出现的编译结果是空白，并没有输出Equilateral。", "Tag": "算法分析"}
{"Answer": "回答如下，记得采纳哦！\n# 输入三角形的三边长\na <- 3\nb <- 4\nc <- 5\n\n# 判断是否能构成三角形\nif ((a + b > c) && (a + c > b) && (b + c > a)) {\n  if (a == b && b == c) {\n    print(\"等边三角形\")\n  } else if (a == b || a == c || b == c) {\n    print(\"等腰三角形\")\n  } else {\n    print(\"普通三角形\")\n  }\n} else {\n  print(\"不能构成三角形\")\n}\n", "Konwledge_Point": "边的长度", "Question": "输入三条线段的长度，判断能否构成三角形，构成什么样的三角形\n能构成三角形，判断构成等边三角形还是等腰三角形还是普通三角形，不能构成三角形则说明不能构成三角形", "Tag": "算法分析"}
{"Answer": "\nimport math\nclass Triangle(object):\n    def __init__(self,a,b,c):\n        self.a = a\n        self.b = b\n        self.c = c\n    \n    # 获取面积\n    def get_area(self): \n        # 三角形面积公式,根据三边\n        return 1/4 * math.sqrt((self.a + self.b + self.c) * (self.a + self.b -self.c) \n                               * (self.a + self.c - self.b) * (self.b + self.c - self.a))\n    \n    # 获取周长\n    def get_permeter(self):\n        return self.a + self.b + self.c\n    \ntrig = Triangle(2,3,4)\narea = trig.get_area()\npermeter = trig.get_permeter()\nprint(\"面积: {:.2f},周长: {}\".format(area,permeter))\n\n结果:\n\n如果觉得答案对你有帮助,请点击下采纳,谢谢~", "Konwledge_Point": "边的长度", "Question": "python创建类Triangle求三角形面积和周长\n创建类Triangle,计算三角形的周长和面积,并创建两个实例进行检测。", "Tag": "算法分析"}
{"Answer": "你用的什么编译器，不是所有的编译器都支持long long\r\n用GCC 14看看", "Konwledge_Point": "边的长度", "Question": "计算最长的异或路径，请看下这个程序怎么修改\n#include \n\n#include \n\n#include \n\n#include \n\n#include \n\n#include \n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 100005;\n\n\n\nint n;\n\nstruct Edge {\n\n    int v, w, nex;\n\n    Edge() {}\n\n    Edge(int v, int w, int nex) : v(v), w(w), nex(nex) {}\n\n};\n\nEdge e[N << 1];\n\nint head[N], tot;\n\nvoid add(int u, int v, int w) {\n\n    e[tot] = Edge(v, w, head[u]);\n\n    head[u] = tot++;\n\n}\n\nvoid read() {\n\n    memset(head, -1, sizeof head);\n\n    tot = 0;\n\n    int u, v, w;\n\n    for(int i = 1; i < n; ++i) {\n\n        scanf(\"%d%d%d\", &u, &v, &w);\n\n        add(u, v, w);\n\n        add(v, u, w);\n\n    }\n\n}\n\nint d[N], vis[N];\n\nvoid bfs() {\n\n    queue que;\n\n    que.push(0);\n\n    d[0] = 0;\n\n    memset(vis, 0, sizeof vis);\n\n    int u, v, w;\n\n    vis[0] = 1;\n\n    while(!que.empty()) {\n\n        u = que.front(); que.pop();\n\n        for(int i = head[u]; ~i; i = e[i].nex) {\n\n            v = e[i].v; w = e[i].w;\n\n            if(vis[v]) continue;\n\n            d[v] = d[u] ^ w;\n\n            vis[v] = 1;\n\n            que.push(v);\n\n        }\n\n    }\n\n}\n\nint ch[N * 32][2];\n\nstruct Trie {\n\n    int sz;\n\n    Trie() { sz = 1; memset(ch[0], 0, sizeof ch[0]); }\n\n    void _insert(int bs[]) {\n\n        int u = 0;\n\n        for(int i = 30; i >= 0; --i) {\n\n            int c = bs[i];\n\n            if(!ch[u][c]) {\n\n                memset(ch[sz], 0, sizeof ch[sz]);\n\n                ch[u][c] = sz++;\n\n            }\n\n            u = ch[u][c];\n\n        }\n\n    }\n\n    int _search(int bs[]) {\n\n        int u = 0, ans = 0;\n\n        for(int i = 30; i >= 0; --i) {\n\n            int c = bs[i];\n\n            if(c == 1) {\n\n                if(ch[u][0]) { ans += (1 << (i)); u = ch[u][0]; }\n\n                else u = ch[u][1];\n\n            }else {\n\n                if(ch[u][1]) { ans += (1 << (i)); u = ch[u][1]; }\n\n                else u = ch[u][0];\n\n            }\n\n        }\n\n        return ans;\n\n    }\n\n};\n\n\n\nint ans;\n\nint b[35];\n\nvoid get(int x) {\n\n    int ls = 0;\n\n    memset(b, 0, sizeof b);\n\n    while(x) {\n\n        b[ls++] = x % 2;\n\n        x >>= 1;\n\n    }\n\n}\n\nvoid solve() {\n\n    Trie mytrie;\n\n    ans = 0;\n\n    for(int i = 0; i < n; ++i) {\n\n        get(d[i]);\n\n        mytrie._insert(b);\n\n        ans = max(ans, mytrie._search(b));\n\n    }\n\n    printf(\"%d\\n\", ans);\n\n}\n\nint main() {\n\n   // freopen(\"in.txt\", \"r\", stdin);\n\n    while(~scanf(\"%d\", &n)) {\n\n        read();\n\n        bfs();\n\n        solve();\n\n    }\n\n}", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n#include \r\nint main()\r\n{\r\n    int a,b,c;\r\n    scanf(\"%d %d %d\",&a,&b,&c);\r\n    if(((a+b)>c) && ((b+c)>a) && ((a+c)>b))\r\n    {\r\n        double p = (a+b+c)/2.0;\r\n        double S = sqrt(p*(p-a)*(p-b)*(p-c));\r\n        printf(\"S=%0.2lf\\n\",S);\r\n    }\r\n    else\r\n        printf(\"no\\n\");\r\n    return 0;\r\n}\r\n```", "Konwledge_Point": "边的长度", "Question": "构成三角形不会做大佬看看\n构成三角形\n\n描述\n\n给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。若能，请给出三角形的面积。\n\n输入\n\n共1行，三个正整数x、y、z（0<x,y,z<=1000000）表示三条线段的长度。\n\n输出\n\n共1行。若可以构成三角形，输出三角形的面积（保留两位小数），否则输出”no”。不要输出双引号。\n\n输入样例 1 \n\n1 2 3\n\n输出样例 1\n\nno\n\n提示\n\n1. 若三角形三条边的长度为a，b，c，则其面积可以写为：\n\nS = √(p*(p-a)*(p-b)*(p-c))\n\n其中p=(a+b+c)/2，√表示平方根。\n\n2. C++中用sqrt表示平方根，比如sqrt(4) 的值为2.0。", "Tag": "算法分析"}
{"Answer": "\ns = input(' ')\n[a,b,c] = [int(i) for i in s.split(' ')]\n\np = 0.5 * (a+b+c)\narea = (p * (p-a) * (p-b) * (p-c)) ** (0.5)\n\nround(area, 3)\n", "Konwledge_Point": "边的长度", "Question": "求解答！自己试了提交好多次都不对，我们刚学python，应该是用简单的语法吧\n【问题描述】\n\n\n若已知三角形三个边的长度分别为a,b,c（并假设三个边长度的单位一致，在本编程题中忽略其单位），则可以利用公式:\n\n\n求得三角形的面积，其中：s=(a+b+c)/2。编程实现从控制台读入以整数表示的三个边的长度（假设输入的长度肯定可以形成三角形），然后利用上述公式计算面积并输出，结果小数点后保留3位有效数字。\n\n\n【输入形式】\n\n\n从控制台输入三个整数表示三角形三个边的长度，以空格分隔三个整数。\n\n\n【输出形式】\n\n\n向控制台输出求得的三角形的面积，小数点后保留三位有效数字。\n\n\n【输入样例】\n\n\n4 4 6\n\n\n【输出样例】\n\n\n7.937", "Tag": "算法分析"}
{"Answer": "```\r\n#include \r\n\r\nint main()\r\n{\r\n\tint n;\r\n\tint cnt = 0;\r\n\tscanf(\"%d\", &n);\r\n\tfor (int a = 1; a < n; a++)\r\n\t\tfor (int b = a; b < n - a; b++)\r\n\t\t\tfor (int c = 1; c < n; c++)\r\n\t\t\t{\r\n\t\t\t\tif ((a+b)*(a+b)+c*c==n*n)\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"a=%d b=%d c=%d\\n\", a, b, c);\r\n\t\t\t\t\tcnt++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\tprintf(\"一共有%d种方案\", cnt);\r\n\treturn 0;\r\n}\r\n```\r\n5\r\na=1 b=2 c=4\r\na=1 b=3 c=3\r\na=2 b=2 c=3\r\n一共有3种方案Press any key to continue . . .\r\n\r\n\r\n10\r\na=1 b=5 c=8\r\na=1 b=7 c=6\r\na=2 b=4 c=8\r\na=2 b=6 c=6\r\na=3 b=3 c=8\r\na=3 b=5 c=6\r\na=4 b=4 c=6\r\n一共有7种方案Press any key to continue . . .", "Konwledge_Point": "边的长度", "Question": "一个问题代码写不来求助dalao\n目前有一个长度为 n 的木棍，当做直角三角形的斜边。A,B,C要从许多整数长度的木棍中选出三根，分别长为 a, b, c。 现在，蒜头君和花椰妹的木棍组成一条直角边长度为 a + b，白菜君组成另外一条直角边 c，并且要求 a + b ≤c。请问一共可以有多少种取木棍的方案。 提示：a = 3, b = 4 与 a = 4, b = 3 算作同一种方案。", "Tag": "算法分析"}
{"Answer": "你的问题\nmain 函数是 int 类型的 而不是 void函数s没有返回值，返回值，应该加上返回值 return s ；并且s是double类型的，所以函数 s 也应该 是 double类型的scanf 函数内 一个个参数不要有多余的空格\n修改后的代码\n如下 \n#include <stdio.h>\n#include <math.h>\ndouble s(double a, double b, double c)\n{\n    double l,s;\n    l = (a + b + c)/ 2.0 ;\n    s = sqrt(l * (l - a) * (l - b) * (l - c));\n    return s;\n}\nint main()\n{\n    double  x, y, z, sum;\n    printf(\"请输入三角形的三边长:\");\n    scanf_s(\"%lf%lf%lf\", &x, &y, &z);\n    sum = s(x, y, z);\n    printf(\"%lf\", sum);\n}\n", "Konwledge_Point": "边的长度", "Question": "编写一函数，根据三角形三条边求其面积s=√(s(s-a)(s-b)(s-c)) ,其中s=(a+b+c)/2 ,a,b,c为三角形三条边的长度。要求在主函数中输入 a、b、c，输出S的值\n这个程序怎么改才能正确啊？\n\n\n#\ninclude\n \n\n\n\nvoid\n \ns\n(\ndouble\n a, \ndouble\n b, \ndouble\n c)\n\n\n{\n    \ndouble\n l,s;\n    l = (a + b + c)/ \n2.0\n ;\n    s = \nsqrt\n(l * (l - a) * (l - b) * (l - c));\n}\n\nvoid\n \nmain\n()\n\n\n{\n    \ndouble\n  x, y, z, sum;\n    \nprintf\n(\n\"请输入三角形的三边长:\"\n);\n    \nscanf_s\n(\n\"%lf%lf%lf \"\n, &x, &y, &z);\n    sum = \ns\n(x, y, z);\n    \nprintf\n(\n\"%lf\"\n, sum);\n}\n编写一函数，根据三角形三条边求其面积s=√(\ns\n(s-a)(s-b)(s-c)) ,其中s=(a+b+c)/\n2\n ,a,b,c为三角形三条边的长度。要求在主函数中输入 a、b、c，输出S的值\n", "Tag": "算法分析"}
{"Answer": "public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        boolean flag = true;\n        Scanner sc = new Scanner(System.in);\n        while (flag) {\n            System.out.println(\"从键盘上输入3个整数并用空格隔开,单独输入0结束程序\");\n\n            String inputstr = sc.nextLine();\n            String[] inputs = inputstr.split(\" \");\n            if(inputs.length != 3 && inputs.length != 1) {\n                System.out.println(\"输入错误，请重新输入\");\n                continue;\n            }\n            int[] nums = new int[inputs.length];\n            int sum = 0;\n            for (int i = 0; i < inputs.length; i++) {\n                nums[i] = Integer.parseInt(inputs[i]);\n                sum+=nums[i];\n            }\n            if (inputs.length == 1 && nums[0] == 0) {\n                flag = false;\n                continue;\n            }else if(inputs.length == 1 && nums[0]!= 0) {\n                System.out.println(\"输入错误，请重新输入\");\n                continue;\n            }else if(nums[0]+nums[1]<=nums[2]||nums[0]+nums[2]<=nums[1]||nums[1]+nums[2]<=nums[0]) { //两边之和必须大于第三边，否则三角形不存在\n                System.out.println(\"三角形不存在，请重新输入\");\n                continue;\n            }\n\n            double p = sum / 2.0;\n            double s = Math.sqrt(p * (p - nums[0]) * (p - nums[1]) * (p - nums[2]));\n            System.out.println(\"三条边长分别为： \" + nums[0] + \",\" + nums[1] + \",\" + nums[2]);\n            System.out.printf(\"三角形面积约为： %.2f\\n\",s );\n        }\n        sc.close();\n\n    }\n", "Konwledge_Point": "边的长度", "Question": "有关三角形的java语言，应该怎么思考呢\n采用控制台输入输出实现:输入三角形的三条边长度（整数），计算并输出该三角形的面积。\n\n\n要可以不限次数的输入，直到输入0，则程序退出。\nJava语言", "Tag": "算法分析"}
{"Answer": "有没有什么报错信息啊，先说一个，一般他不要求输出其他信息，例如主函数第二行", "Konwledge_Point": "边的长度", "Question": "为什么在Dev上能正确运行，但是在洛谷上就不行啊\n问题遇到的现象和发生背景\n\n\n就也不算难的一道题，新手刚写\n\n\n题目描述\n给出n(1\\le n\\le13)n(1≤n≤13)，请输出一个直角边长度是 nn 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前导 0。\n\n\n#\ninclude\n \n\n\n\n#\ninclude\n \n\n\n\nusing\n \nnamespace\n std;\n\n\nint\n \nmain\n()\n{\n    \nint\n n;\n    cout<<\n\"please input the numbers\"\n<>n;\n    \nint\n i = \n0\n;\n    \nint\n j;\n    \nint\n k = \n0\n;\n    \nfor\n(;i<n;i++){\n        \nfor\n(j = \n0\n;j<n-i;j++){\n            k++;\n            \nif\n(k<\n10\n){\n                cout<<\n\"0\"\n<<k;\n            }\n            \nelse\n cout<<k;\n        }\n        cout<<endl;\n    }\n}\n\n\n\n\n问题相关代码，请勿粘贴截图\n\n\n运行结果及报错内容\n\n\n我的解答思路和尝试过的方法\n\n\n我想要达到的结果\n\n\n请大佬帮忙看看呜呜", "Tag": "算法分析"}
{"Answer": "package sds;\r\nimport java.util.Scanner;\r\npublic class Test77 {\r\npublic static void main(String[] args){\r\nwhile(true){\r\ndouble a,b,c; //三边长度\r\ndouble m,s; //面积为m,周长为s\r\nSystem.out.println(\"请输入三角形的三边abc的值：\");\r\nScanner scan=new Scanner(System.in);\r\nSystem.out.println(\"请输入a的值：\");\r\na=scan.nextDouble();\r\nSystem.out.println(\"请输入b的值：\");\r\nb=scan.nextDouble();\r\nSystem.out.println(\"请输入c的值：\");\r\nc=scan.nextDouble();\r\nif((a+b)>c){\r\ns=(a+b+c)*0.5;\r\n//System.out.println(+s);\r\ns=(s*(s-a)*(s-b)*(s-c)) ;\r\nm=Math.sqrt(s);\r\nSystem.out.println(\"三角形面积为：\"+m);\r\n}\r\nelse {\r\nSystem.out.println(\"该三边无法构成三角形，请重新输入\");\r\n    }\r\n\t\t}", "Konwledge_Point": "边的长度", "Question": "自己编写了一个计算三角形面积的java程序，但因为是新手，所有还有些问题想问下大家\npackage sds;\n\nimport java.util.Scanner;\n\n\n\npublic class Test77 {\n\n    public static void main(String[] args){\n\n        double a,b,c; //三边长度\n\n        double m,s; //面积为m,周长为s\n\n        System.out.println(\"请输入三角形的三边abc的值：\");\n\n        Scanner scan=new Scanner(System.in);\n\n        System.out.println(\"请输入a的值：\");\n\n        a=scan.nextDouble();\n\n        System.out.println(\"请输入b的值：\");\n\n        b=scan.nextDouble();\n\n        System.out.println(\"请输入c的值：\");\n\n        c=scan.nextDouble();\n\n        if((a+b)>c){\n\n            s=(a+b+c)*0.5;\n\n            //System.out.println(+s);\n\n            s=(s*(s-a)*(s-b)*(s-c)) ;\n\n            m=Math.sqrt(s);\n\n            System.out.println(\"三角形面积为：\"+m);\n\n        }\n\n        else {\n\n            System.out.println(\"该三边无法构成三角形，请重新输入\");\n\n\n\n    }\n\n}\n\n\n\n\n}\n\n//在输入的三角形三边无法构成三角形的情况下，如何编写，让它调回到输入部分", "Tag": "算法分析"}
{"Answer": "是不是别的还有一个PlaneGraphic类，你继承实际上是这个类，这里抽象里有个cirecleC方法需要实现你看看导包的地方，有没有问题", "Konwledge_Point": "边的长度", "Question": "关于java抽象类和抽象函数问题\n定义了一个抽象类A，里面有抽象函数\n定义一个类B继承抽象类A，重写抽象函数\n在test类里面如何对B实例化，实现B的函数。\n我用new会一直报错，看其他贴都是这样写\n\n\n```java\n\nimport\n java.util.Scanner;\n\n\nabstract\n \nclass\n \nPlaneGraphic\n {\n    \npublic\n \nabstract\n \nvoid\n \ntriangleS\n()\n;\n    \npublic\n \nabstract\n \nvoid\n \ntriangleC\n()\n;\n}\n\nabstract\n \nclass\n \nTriangle\n \nextends\n \nPlaneGraphic\n {\n    \ndouble\n a;\n    \ndouble\n b;\n    \ndouble\n c;\n\n    \npublic\n \nTriangle\n(\ndouble\n a, \ndouble\n b, \ndouble\n c)\n{\n        \nthis\n.a = a;\n        \nthis\n.b = b;\n        \nthis\n.c = c;\n    }\n    \npublic\n \nvoid\n \ntriangleC\n()\n{\n        \ndouble\n \np\n \n=\n a + b + c;\n        System.out.println(\n\"三角形周长为:\"\n + p);\n    }\n    \npublic\n \nvoid\n \ntriangleS\n()\n{\n        \ndouble\n \np\n \n=\n (a + b + c) / \n2\n;\n        \ndouble\n \ns\n \n=\n Math.sqrt(p * (p - a) * (p - b) * (p - c));\n        System.out.println(\n\"三角形的面积为:\"\n + s);\n    }\n}\n\npublic\n \nclass\n \nTest\n\n{\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(String[] args)\n\n    {\n        \nScanner\n \ninput\n \n=\n \nnew\n \nScanner\n(System.in);\n\n        \ndouble\n a, b, c;\n        System.out.println(\n\"输入三角形的三边长度\"\n);\n        a = input.nextDouble();\n        b = input.nextDouble();\n        c = input.nextDouble();\n        \nPlaneGraphic\n \ntri\n \n=\n \nnew\n \nTriangle\n(a, b, c);\n        tri.triangleC();\n        tri.triangleS();\n    }\n}\n\n\n\n报错内容\n![img](https:\n//img\n-mid.csdnimg.cn\n/release/\nstatic\n/image/mi\nd\n/ask/\n70517911143616\n.png \n\"=600 #left\"\n)\n", "Tag": "算法分析"}
{"Answer": "代码如下，如有帮助，请采纳一下，谢谢。\n\n#include <stdio.h>\n#include <map>\nusing namespace std;\nint main()\n{\n\tprintf(\"请输入火柴的根数：\");\n\tint n;\n\tscanf(\"%d\",&n);\n\tprintf(\"请输入火柴的长度：\");\n\tint buf[100] = {0};  //存储火柴的长度\n\tfor(int i = 0; i < n; i++)\n\t\tscanf(\"%d\",&buf[i]);\n\t//1.统计每种长度的火柴的根数，因为如果要组成矩形\n\t//至少需要2根相同长度的火柴\n\tmap<int,int> mapLength;\n\tmap<int,int>::iterator it = mapLength.begin();\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tit = mapLength.find(buf[i]);\n\t\tif (it == mapLength.end())\n\t\t{\n\t\t\tmapLength.insert(pair<int,int>(buf[i],1));\n\t\t}else\n\t\t{\n\t\t\tint len = it->second + 1;\n\t\t\tmapLength.erase(it);\n\t\t\tmapLength.insert(pair<int,int>(buf[i],len));\n\t\t}\n\t}\n\t\n\t//2.将map中数量少于2的火柴删除\n\tfor (it = mapLength.begin(); it != mapLength.end(); )\n\t{\n\t\tif (it->second < 2)\n\t\t{\n\t\t\tmapLength.erase(it);\n\t\t\tit = mapLength.begin();\n\t\t}else\n\t\t\tit++;\n\t}\n\tfor (it = mapLength.begin(); it != mapLength.end(); it++)\n\t\tprintf(\"长度为%d的火柴数量=%d\\n\",it->first,it->second);\n\n\t//因为map能够根据key自动排序，且按照从小到大的顺序排列\n\t//所以，map中最后一个元素是最长的火柴长度，\n\t//找最大矩形的话，就取最后两个元素的长度即可\n\tint mj = 0;\n\tif (mapLength.size() < 2)\n\t{\n\t\t//如果map中没有2组相同长度的火柴，则说明无法组成矩形\n\t\t//do nothing\n\t\tprintf(\"无法组成矩形\\n\");\n\t}else\n\t{\n\t\tit = mapLength.end();\n\t\tit--;\n\t\tint leng = it->first;\n\t\tit--;\n\t\tint leng2 = it->first;\n\t\tmj = leng * leng2;\n\t\tprintf(\"最大面积=%d * %d = %d\\n\",leng,leng2,mj);\n\t}\n\t\n\tgetchar();\n\tgetchar();\n\treturn 0;\n}\n\n\n ", "Konwledge_Point": "边的长度", "Question": "求各位大佬来讲解，救救孩子吧\n有n根厚度可以忽略不计的火柴，第i根火柴的长度为aj。\n约翰想要从中选取四根火柴(显然每根火柴只能被选取一次)，并用这四根火柴分别作为四条边围成\n一个矩形。约翰想要你告诉他，在所有选取方案中，矩形面积的最大值是多少。", "Tag": "算法分析"}
{"Answer": "如果用二维数组表示邻接矩阵，那么显然需要结点个数，也就是数组的大小。\r\n而边的条数，不是必须的，一般来说，用于2个方面：\r\n（1）从键盘输入边的时候，循环几次，完成输入\r\n（2）无需遍历，可以给出有多少边", "Konwledge_Point": "边的长度", "Question": "这是一个关于数据结构的问题\n邻接矩阵法写图存储结构，需要设置结点和线条个数，那么设置这个有什么用呢？\n\n我清楚链表线性表设置这个有效数值个数，是为了等长度为0的时候，释放掉，防止占用资源。\n\n但是图的话，至少要有个结点，我感觉设置结点和线条个数没有意义，请反驳我", "Tag": "算法分析"}
{"Answer": "兄弟，我随便写几个，你看着给，喜喜\n\n4 #include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nint main(int *argc, char *argv[])\n{\nint x, y, z = 0;\nprintf(\"请输入三角形的三条边：\\n\");\nscanf_s(\"%d %d %d\", &x, &y, &z);\nif (x+y>z&x+z>y&&y+z>x)\n{\nif (x==y&&y==z)\n{\nprintf(\"此三角形是等边三角形也是等腰三角形！！\\n\");\n}\nif (x == y || y == z || x == z)\n{\nprintf(\"此三角形是等腰三角形！！\\n\");\n}\nelse {\nprintf(\"此三角形是不规则三角形！！\\n\");\n}\n}\nelse {\nprintf(\"此三角形不是三角形！！\\n\");\n}\nreturn 0;\n}\n5 #include <stdio.h>\n\nint main()\n{\n    int length(char* p);\n    int len;\n    char str[20];\n    puts(\"input string:\\t\");\n    scanf(\"%s\",str);//这里str是字符串指针，不是漏加了 &\n    len = length(str);\n    printf(\"The length of string is %d.\\n\",len);\n    return 0;    \n}\n\nint length(char* p)//字符串指针\n{\n    int n;\n    n = 0;\n    while (*p != '\\0')\n    {\n        n++;\n        p++;\n    }\n    return n;\n}\n\n6 #include<stdio.h>\nint main()\n{\n    int a[10],i,s,medium;/*定义一个数组及变量，数组元素共10个*/\n    for(i=0;i<10;i++)\n        {\n            printf(\"input a[i] when i=%d\\n\",i);\n            scanf(\"%d\",&a[i]);/*依次输入a[0]至a[9]的值*/\n          }\n    for(i=0;i<10;i++)\n        printf(\"%d \",a[i]);/*打印数组*/\n    printf(\"%c\",'\\n');\n    for(i=0;i<10;i++)\n        {\n            for(s=0;s<9-i;s++)\n            {\n                if(a[s]>=a[s+1])\n                {\n                    medium=a[s];/*medium是交换媒介*/\n                    a[s]=a[s+1];\n                    a[s+1]=medium;\n                    }/*if语句实现大数右移的功能*/\n             }/*s的循环语句与if语句结合实现上文中所说的每一轮操作中将最大数移动至最右方*/\n                  printf(\"%d \",a[9-i]);/*每一轮比较后输出本轮中最大的数，事实上就是排序，a[9-i]就是每轮中最大的数*/\n        }/*i的循环就是实现多轮操作，即第一轮比较结束后进行第二轮，一直重复到第九轮*/\n}\n", "Konwledge_Point": "边的长度", "Question": "请教一下这几个代码，有注释最好，阿里各多\n这里都跑不出来有人来解答一下吗？\n1.编写一个函数，实现显示输出数组a[n]（double a[10]={1,2,3,4,5,6,7,8,9,10}）中大于等于平均值的所有元素值，函数原型为void f2(double a[], int n)，其中n为数组元素个数。\n\n\n2.数组a包括10个整数（a[10]={14,32,31,43,53,46,37,18,69,16}），把a中所有的后项除以前项之商取整后存入数组b，并按每行3个元素的格式输出数组，\n\n\n4.输入三角形的三条边（20,30,40或11、21、31或50、70、90）存入数组a中，判断其能否构成三角形，如果可以，则判断出三角形的种类：等腰三角形、等边三角形或一般三角形。输出格式如样张所示。\n\n\n提示：输出分四种情况：\"等边三角形\\n\";\"等腰三角形\\n\";\"一般三角形\\n\";\"不能构成三角形\\n\"。\n5.利用指针作函数参数，设计一函数fun()实现求字符串”a0b1c2d3f4g5h6j1k3l8n\\0f8s9s7”的长度。\n\n\n6.编写程序，设置一个排序函数paixu()，该函数将数组按照从小到大的顺序进行排序，其中有两个形式参数，一个为指向数组的指针p，另一个为数组的元素个数n。在主函数中，要求从键盘输入10个数（0,8,6,4,2,1,3,5,7,9）存入数组data中，同时要求调用函数paixu()对data进行排序，并在主函数中输出最终的排序结果。", "Tag": "算法分析"}
{"Answer": "```\r\nint a, b, c;\r\nscanf(\"%d %d %d\", &a, &b, &c);\r\nif (a < 1 || b <1 || c < 1) {\r\n\tprintf(\"no\\n\");\r\n}\r\na = a * a;\r\nb = b * b;\r\nc = c * c;\r\nif (a + b == c) {\r\n\tprintf(\"yes\\n\");\r\n}\r\nif (a + c == b) {\r\n\tprintf(\"yes\\n\");\r\n}\r\nif (c + b == a) {\r\n\tprintf(\"yes\\n\");\r\n}\r\nprintf(\"no\\n\");\r\n```", "Konwledge_Point": "边的长度", "Question": "刚接触C语言，看到了算法竞赛的一道题目，写了几遍都出错，求助！\n输入三角形3边的长度值（均为正整数），判断能否为直角三角形的3个边长。如果可以，则输出yes,否则输出no。", "Tag": "算法分析"}
{"Answer": "public interface  Shape {\n    public  double calcLen();\n}\n\npublic class Circle  implements Shape{\n    private double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    public double getRadius() {\n        return radius;\n    }\n    public void setRadius(double radius) {\n        this.radius = radius;\n    }\n\n    public double calcLen() {\n        return 2 * Math.PI * radius;\n    }\n}\n\npublic class Rectangle implements Shape {\n    private double height;\n    private double width;\n    public Rectangle(double height, double width) {\n        this.height = height;\n        this.width = width;\n    }\n    public double getHeight() {\n        return height;\n    }\n    public void setHeight(double height) {\n        this.height = height;\n    }\n    public double getWidth() {\n        return width;\n    }\n    public void setWidth(double width) {\n        this.width = width;\n    }\n\n    public double calcLen() {\n        return 2 * (height + width);\n    }\n}\n\n\npublic class Triangle implements Shape{\n    private double side1;\n    private double side2;\n    private double side3;\n    public Triangle(double side1, double side2, double side3) {\n        this.side1 = side1;\n        this.side2 = side2;\n        this.side3 = side3;\n    }\n    public double getSide1() {\n        return side1;\n    }\n    public void setSide1(double side1) {\n        this.side1 = side1;\n    }\n    public double getSide2() {\n        return side2;\n    }\n    public void setSide2(double side2) {\n        this.side2 = side2;\n    }\n    public double getSide3() {\n        return side3;\n    }\n    public void setSide3(double side3) {\n        this.side3 = side3;\n    }\n\n\n    public double calcLen() {\n        return side1 + side2 + side3;\n    }\n}\n\n如果对你有帮助，记得采纳一下哦~谢谢O(∩_∩)O", "Konwledge_Point": "边的长度", "Question": "设计一个接口Shape,其中声明一个无参方法calcLen())\n在该接口基础上实现圆形（Circle）矩形（Rectrangle）三角形（Trianngle）三个类\n圆形类属性：半径\n矩形类属性：长宽\n三角形属性：三条边的长度", "Tag": "算法分析"}
{"Answer": "def fun(a, b):\n    return lambda: a * a + b * b\n\nx = fun(3, 4)\n\nif x() == 5*5:\n    print(\"是直角三角形\")\n", "Konwledge_Point": "边的长度", "Question": "python使用匿名函数验证三条线是否能构成直角三角形\n1、定义一个函数，有两个接受线长度的参数a和b，返回一个匿名函数。\n2、匿名函数用于计算这两个短边的平方和。\n3、如果函数返回的结果跟第三条边的平方相等，表示是直角三角形。", "Tag": "算法分析"}
{"Answer": "a==b==c改成 a==b&& b==ca==b!=c这么写不对，应该是 a==b && b!=cint Area(float a,float b,float c)改成 float Area(float a,float b,float c)Area(a,b,c);改成s = Area(a,b,c);代码修改如下：\n\n#include<stdio.h>\n#include<math.h>\nint Triangle(float a,float b,float c)\n{\n    if(a+b>c && a+c>b && b+c>a)\n    {\n        if(a==b&& b==c)\n        {\n            printf(\"该三角形是等边三角形\");\n        }else if((a==b && b!=c)|| (b==c&& c!=a)|| (a==c && c!=b))\n        {\n            printf(\"该三角形是等边三角形\");\n        }else //if(a!=b&&a!=c&&b!=c){\n            printf(\"该三角形不是等边三角形，是普通三角形\");\n        //}\n        return 1;\n    }else //if(a+b<c||a+c<b||b+c<a)\n    {\n        printf(\"不能构成三角形\");\n        return 0;\n    }\n}\nfloat Area(float a,float b,float c){\n    float s;\n    float p=(a+b+c)/2;\n    s=sqrt((p-a)*(p-b)*(p-c));\n    return s;\n}\nint main(){\n    float a,b,c;\n    float s;\n    scanf(\"%f%f%f\",&a,&b,&c);\n    Triangle(a,b,c);\n    if(Triangle){\n        s = Area(a,b,c);\n        printf(\"三角形的面积为%f\",s);\n    }\n    return 0;    \n}\n\n\n", "Konwledge_Point": "边的长度", "Question": "运行结果错误 想问问具体哪里错了怎么改\n从键盘上输入三个代表三条线段长度的实数，由一个函数Triangle()判断这三条线段所组成的三角形属于什么类型（不等边、等腰、等边或不构成三角形）；如果能构成三角形，由求三角形面积函数计算其面积（取两位小数）。\n提示1：三角形条件：若输入的三条边中存在一条边的长度大于或等于另外两条边的长度之和，则这三条边不能组成一个三角形。\n提示2：海伦定理：假设三角形的三边为a、b、c，记p=(a+b+c)/2，则三角形的面积S=\n（2）主函数：从键盘上输入三个实数，然后调用判别函数Triangle()实现三角形类型判别，再调用面积函数Area()计算三角形面积。\n\n\n\n\n#\ninclude\n\n\n\n#\ninclude\n\n\n\nint\n \nTriangle\n(\nfloat\n a,\nfloat\n b,\nfloat\n c)\n{\n    \nif\n(a+b>c&&a+c>b&&b+c>a){\n    \nif\n(a==b==c){\n        \nprintf\n(\n\"该三角形是等边三角形\"\n);\n    }\n    \nif\n(a==b!=c||b==c!=a||a==c!=b){\n        \nprintf\n(\n\"该三角形是等边三角形\"\n);\n    }\n    \nif\n(a!=b&&a!=c&&b!=c){\n        \nprintf\n(\n\"该三角形不是等边三角形，是普通三角形\"\n);\n    }\n    \nreturn\n \n1\n;\n}\n    \nelse\n \nif\n(a+b<c||a+c<b||b+c<a){\n        \nprintf\n(\n\"不能构成三角形\"\n);\n        \nreturn\n \n0\n;\n    }\n\n}\n\nint\n \nArea\n(\nfloat\n a,\nfloat\n b,\nfloat\n c)\n{\n    \nfloat\n s;\n    \nfloat\n p=(a+b+c)/\n2\n;\n    s=\nsqrt\n((p-a)*(p-b)*(p-c));\n    \nreturn\n s;\n    \n}\n\n\n\n\nint\n \nmain\n()\n{\n    \nfloat\n a,b,c;\n    \nfloat\n s;\n    \nscanf\n(\n\"%f%f%f\"\n,&a,&b,&c);\n    \nTriangle\n(a,b,c);\n    \nif\n(Triangle){\n        \nArea\n(a,b,c);\n        \nprintf\n(\n\"三角形的面积为%f\"\n,s);\n    }\n    \nreturn\n \n0\n;    \n}\n", "Tag": "算法分析"}
